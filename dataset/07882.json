{
  "Title": "[M-04] After proposed 0.8.0 upgrade kicks in, L2 finalizeInboundTransfer might not work",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-10-thegraph/blob/309a188f7215fa42c745b136357702400f91b4ff/contracts/l2/gateway/L2GraphTokenGateway.sol#L70\n\n\n# Vulnerability details\n\n## Description\n\nL2GraphTokenGateway uses the onlyL1Counterpart modifier to make sure finalizeInboundTransfer is only called from L1GraphTokenGateway. Its implementation is:\n\n```Solidity\nmodifier onlyL1Counterpart() {\n        require(\n            msg.sender == AddressAliasHelper.applyL1ToL2Alias(l1Counterpart),\n            \"ONLY_COUNTERPART_GATEWAY\"\n        );\n        _;\n    }\n```\n\nIt uses applyL1ToL2Alias defined as:\n\n```\nuint160 constant offset = uint160(0x1111000000000000000000000000000000001111);\n\n    /// @notice Utility function that converts the address in the L1 that submitted a tx to\n    /// the inbox to the msg.sender viewed in the L2\n    /// @param l1Address the address in the L1 that triggered the tx to L2\n    /// @return l2Address L2 address as viewed in msg.sender\n    function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\n        l2Address = address(uint160(l1Address) + offset);\n    }\n```\n\nThis behavior matches with how Arbitrum augments the sender's address to L2. The issue is that I've spoken with the team and they are [planning](https://github.com/graphprotocol/contracts/pull/725) an upgrade from Solidity 0.7.6 to 0.8.0. Their proposed [changes](https://github.com/graphprotocol/contracts/blob/c4d3cb56cb4032dbb3a0f1b7535b5d94ccf86222/contracts/arbitrum/AddressAliasHelper.sol) will break this function, because under 0.8.0, this line has a ~ 1/15 chance to overflow:\n\n`l2Address = address(uint160(l1Address) + offset);`\n\nInterestingly, the sum intentionally wraps around using the uint160 type to return a correct address, but this wrapping will overflow in 0.8.0\n\n## Impact\n\nThere is a ~6.5% chance that finalizeInboundTransfer will not work.\n\n## Proof of Concept\n\nl1Address is L1GraphTokenGateway, suppose its address is 0xF000000000000000000000000000000000000000.\n\nThen 0xF000000000000000000000000000000000000000 + 0x1111000000000000000000000000000000001111 > UINT160_MAX , meaning overflow.\n\n## Tools Used\n\nManual audit\n\n## Recommended Mitigation Steps\n\nWrap the calculation in an unchecked block, which will make it behave correctly.",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-10-the-graph-l2-bridge-contest",
  "Code": [
    {
      "filename": "contracts/l2/gateway/L2GraphTokenGateway.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"../../arbitrum/L2ArbitrumMessenger.sol\";\nimport \"../../arbitrum/AddressAliasHelper.sol\";\nimport \"../../gateway/GraphTokenGateway.sol\";\nimport \"../../gateway/ICallhookReceiver.sol\";\nimport \"../token/L2GraphToken.sol\";\n\n/**\n * @title L2 Graph Token Gateway Contract\n * @dev Provides the L2 side of the Ethereum-Arbitrum GRT bridge. Receives GRT from the L1 chain\n * and mints them on the L2 side. Sends GRT back to L1 by burning them on the L2 side.\n * Based on Offchain Labs' reference implementation and Livepeer's arbitrum-lpt-bridge\n * (See: https://github.com/OffchainLabs/arbitrum/tree/master/packages/arb-bridge-peripherals/contracts/tokenbridge\n * and https://github.com/livepeer/arbitrum-lpt-bridge)\n */\ncontract L2GraphTokenGateway is GraphTokenGateway, L2ArbitrumMessenger, ReentrancyGuardUpgradeable {\n    using SafeMath for uint256;\n\n    // Address of the Graph Token contract on L1\n    address public l1GRT;\n    // Address of the L1GraphTokenGateway that is the counterpart of this gateway on L1\n    address public l1Counterpart;\n    // Address of the Arbitrum Gateway Router on L2\n    address public l2Router;\n\n    // Calldata included in an outbound transfer, stored as a structure for convenience and stack depth\n    struct OutboundCalldata {\n        address from;\n        bytes extraData;\n    }\n\n    // Emitted when an incoming transfer is finalized, i.e. tokens were deposited from L1 to L2\n    event DepositFinalized(\n        address indexed l1Token,\n        address indexed from,\n        address indexed to,\n        uint256 amount\n    );\n\n    // Emitted when an outbound transfer is initiated, i.e. tokens are being withdrawn from L2 back to L1\n    event WithdrawalInitiated(\n        address l1Token,\n        address indexed from,\n        address indexed to,\n        uint256 indexed l2ToL1Id,\n        uint256 exitNum,\n        uint256 amount\n    );\n\n    // Emitted when the Arbitrum Gateway Router address on L2 has been updated\n    event L2RouterSet(address l2Router);\n    // Emitted when the L1 Graph Token address has been updated\n    event L1TokenAddressSet(address l1GRT);\n    // Emitted when the address of the counterpart gateway on L1 has been updated\n    event L1CounterpartAddressSet(address l1Counterpart);\n\n    /**\n     * @dev Checks that the sender is the L2 alias of the counterpart\n     * gateway on L1.\n     */\n    modifier onlyL1Counterpart() {\n        require(\n            msg.sender == AddressAliasHelper.applyL1ToL2Alias(l1Counterpart),\n            \"ONLY_COUNTERPART_GATEWAY\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Initialize this contract.\n     * The contract will be paused.\n     * Note some parameters have to be set separately as they are generally\n     * not expected to be available at initialization time:\n     * - l2Router using setL2Router\n     * - l1GRT using setL1TokenAddress\n     * - l1Counterpart using setL1CounterpartAddress\n     * - pauseGuardian using setPauseGuardian\n     * @param _controller Address of the Controller that manages this contract\n     */\n    function initialize(address _controller) external onlyImpl {\n        Managed._initialize(_controller);\n        _paused = true;\n        __ReentrancyGuard_init();\n    }\n\n    /**\n     * @dev Sets the address of the Arbitrum Gateway Router on L2\n     * @param _l2Router Address of the L2 Router (provided by Arbitrum)\n     */\n    function setL2Router(address _l2Router) external onlyGovernor {\n        require(_l2Router != address(0), \"INVALID_L2_ROUTER\");\n        l2Router = _l2Router;\n        emit L2RouterSet(_l2Router);\n    }\n\n    /**\n     * @dev Sets the address of the Graph Token on L1\n     * @param _l1GRT L1 address of the Graph Token contract\n     */\n    function setL1TokenAddress(address _l1GRT) external onlyGovernor {\n        require(_l1GRT != address(0), \"INVALID_L1_GRT\");\n        l1GRT = _l1GRT;\n        emit L1TokenAddressSet(_l1GRT);\n    }\n\n    /**\n     * @dev Sets the address of the counterpart gateway on L1\n     * @param _l1Counterpart Address of the L1GraphTokenGateway on L1\n     */\n    function setL1CounterpartAddress(address _l1Counterpart) external onlyGovernor {\n        require(_l1Counterpart != address(0), \"INVALID_L1_COUNTERPART\");\n        l1Counterpart = _l1Counterpart;\n        emit L1CounterpartAddressSet(_l1Counterpart);\n    }\n\n    /**\n     * @notice Burns L2 tokens and initiates a transfer to L1.\n     * The tokens will be available on L1 only after the wait period (7 days) is over,\n     * and will require an Outbox.executeTransaction to finalize.\n     * Note that the caller must previously allow the gateway to spend the specified amount of GRT.\n     * @dev no additional callhook data is allowed. The two unused params are needed\n     * for compatibility with Arbitrum's gateway router.\n     * The function is payable for ITokenGateway compatibility, but msg.value must be zero.\n     * @param _l1Token L1 Address of GRT (needed for compatibility with Arbitrum Gateway Router)\n     * @param _to Recipient address on L1\n     * @param _amount Amount of tokens to burn\n     * @param _data Contains sender and additional data (always empty) to send to L1\n     * @return ID of the withdraw transaction\n     */\n    function outboundTransfer(\n        address _l1Token,\n        address _to,\n        uint256 _amount,\n        uint256, // unused on L2\n        uint256, // unused on L2\n        bytes calldata _data\n    ) public payable override notPaused nonReentrant returns (bytes memory) {\n        require(_l1Token == l1GRT, \"TOKEN_NOT_GRT\");\n        require(_amount > 0, \"INVALID_ZERO_AMOUNT\");\n        require(msg.value == 0, \"INVALID_NONZERO_VALUE\");\n        require(_to != address(0), \"INVALID_DESTINATION\");\n\n        OutboundCalldata memory outboundCalldata;\n\n        (outboundCalldata.from, outboundCalldata.extraData) = parseOutboundData(_data);\n        require(outboundCalldata.extraData.length == 0, \"CALL_HOOK_DATA_NOT_ALLOWED\");\n\n        // from needs to approve this contract to burn the amount first\n        L2GraphToken(calculateL2TokenAddress(l1GRT)).bridgeBurn(outboundCalldata.from, _amount);\n\n        uint256 id = sendTxToL1(\n            0,\n            outboundCalldata.from,\n            l1Counterpart,\n            getOutboundCalldata(\n                _l1Token,\n                outboundCalldata.from,\n                _to,\n                _amount,\n                outboundCalldata.extraData\n            )\n        );\n\n        // we don't need to track exitNums (b/c we have no fast exits) so we always use 0\n        emit WithdrawalInitiated(_l1Token, outboundCalldata.from, _to, id, 0, _amount);\n\n        return abi.encode(id);\n    }\n\n    /**\n     * @notice Burns L2 tokens and initiates a transfer to L1.\n     * The tokens will be received on L1 only after the wait period (7 days) is over,\n     * and will require an Outbox.executeTransaction to finalize.\n     * @dev no additional callhook data is allowed\n     * @param _l1Token L1 Address of GRT (needed for compatibility with Arbitrum Gateway Router)\n     * @param _to Recipient address on L1\n     * @param _amount Amount of tokens to burn\n     * @param _data Contains sender and additional data to send to L1\n     * @return ID of the withdraw tx\n     */\n    function outboundTransfer(\n        address _l1Token,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external returns (bytes memory) {\n        return outboundTransfer(_l1Token, _to, _amount, 0, 0, _data);\n    }\n\n    /**\n     * @notice Calculate the L2 address of a bridged token\n     * @dev In our case, this would only work for GRT.\n     * @param l1ERC20 address of L1 GRT contract\n     * @return L2 address of the bridged GRT token\n     */\n    function calculateL2TokenAddress(address l1ERC20) public view override returns (address) {\n        if (l1ERC20 != l1GRT) {\n            return address(0);\n        }\n        return address(graphToken());\n    }\n\n    /**\n     * @notice Receives token amount from L1 and mints the equivalent tokens to the receiving address\n     * @dev Only accepts transactions from the L1 GRT Gateway.\n     * The function is payable for ITokenGateway compatibility, but msg.value must be zero.\n     * Note that whitelisted senders (some protocol contracts) can include additional calldata\n     * for a callhook to be executed on the L2 side when the tokens are received. In this case, the L2 transaction\n     * can revert if the callhook reverts, potentially locking the tokens on the bridge if the callhook\n     * never succeeds. This requires extra care when adding contracts to the whitelist, but is necessary to ensure that\n     * the tickets can be retried in the case of a temporary failure, and to ensure the atomicity of callhooks\n     * with token transfers.\n     * @param _l1Token L1 Address of GRT\n     * @param _from Address of the sender on L1\n     * @param _to Recipient address on L2\n     * @param _amount Amount of tokens transferred\n     * @param _data Extra callhook data, only used when the sender is whitelisted\n     */\n    function finalizeInboundTransfer(\n        address _l1Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable override notPaused onlyL1Counterpart nonReentrant {\n        require(_l1Token == l1GRT, \"TOKEN_NOT_GRT\");\n        require(msg.value == 0, \"INVALID_NONZERO_VALUE\");\n\n        L2GraphToken(calculateL2TokenAddress(l1GRT)).bridgeMint(_to, _amount);\n\n        if (_data.length > 0) {\n            bytes memory callhookData;\n            {\n                bytes memory gatewayData;\n                (gatewayData, callhookData) = abi.decode(_data, (bytes, bytes));\n            }\n            ICallhookReceiver(_to).onTokenTransfer(_from, _amount, callhookData);\n        }\n\n        emit DepositFinalized(_l1Token, _from, _to, _amount);\n    }\n\n    /**\n     * @notice Creates calldata required to send tx to L1\n     * @dev encodes the target function with its params which\n     * will be called on L1 when the message is received on L1\n     * @param _token Address of the token on L1\n     * @param _from Address of the token sender on L2\n     * @param _to Address to which we're sending tokens on L1\n     * @param _amount Amount of GRT to transfer\n     * @param _data Additional calldata for the transaction\n     * @return Calldata for a transaction sent to L1\n     */\n    function getOutboundCalldata(\n        address _token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes memory _data\n    ) public pure returns (bytes memory) {\n        return\n            abi.encodeWithSelector(\n                ITokenGateway.finalizeInboundTransfer.selector,\n                _token,\n                _from,\n                _to,\n                _amount,\n                abi.encode(0, _data) // we don't need to track exitNums (b/c we have no fast exits) so we always use 0\n            );\n    }\n\n    /**\n     * @notice Decodes calldata required for migration of tokens\n     * @dev extraData can be left empty\n     * @param _data Encoded callhook data\n     * @return Sender of the tx\n     * @return Any other data sent to L1\n     */\n    function parseOutboundData(bytes memory _data) private view returns (address, bytes memory) {\n        address from;\n        bytes memory extraData;\n        if (msg.sender == l2Router) {\n            (from, extraData) = abi.decode(_data, (address, bytes));\n        } else {\n            from = msg.sender;\n            extraData = _data;\n        }\n        return (from, extraData);\n    }\n}"
    }
  ]
}