{
  "Title": "[H-03] Customers cannot be `topUp()`ed a second time",
  "Content": "_Submitted by IllIllI_\n\n[CompoundHandler.sol#L71](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/handlers/CompoundHandler.sol#L71)<br>\n[CompoundHandler.sol#L120](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/handlers/CompoundHandler.sol#L120)<br>\n[AaveHandler.sol#L53](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/handlers/AaveHandler.sol#L53)<br>\n[TopUpAction.sol#L847](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L847)<br>\n\nOpenZeppelin's `safeApprove()` will revert if the account already is approved and the new `safeApprove()` is done with a non-zero value.\n\n```solidity\nfunction safeApprove(\n    IERC20 token,\n    address spender,\n    uint256 value\n) internal {\n    // safeApprove should only be called when setting an initial allowance,\n    // or when resetting it to zero. To increase and decrease it, use\n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n    require(\n        (value == 0) || (token.allowance(address(this), spender) == 0),\n        \"SafeERC20: approve from non-zero to non-zero allowance\"\n    );\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n}\n```\n\n[OpenZeppelin/SafeERC20.sol#L45-L58](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/fcf35e5722847f5eadaaee052968a8a54d03622a/contracts/token/ERC20/utils/SafeERC20.sol#L45-L58)<br>\n\n### Impact\n\nCustomers cannot be topped up a second time, which will cause them to be liquidated even though they think they're protected.\n\n### Proof of Concept\n\nThere are multiple places where `safeApprove()` is called a second time without setting the value to zero first. The instances below are all related to topping up.\n\nCompound-specific top-ups will fail the second time around when approving the `ctoken` again:\n\n```solidity\nFile: backd/contracts/actions/topup/handlers/CompoundHandler.sol   #1\n\n50       function topUp(\n51           bytes32 account,\n52           address underlying,\n53           uint256 amount,\n54           bytes memory extra\n55       ) external override returns (bool) {\n56           bool repayDebt = abi.decode(extra, (bool));\n57           CToken ctoken = cTokenRegistry.fetchCToken(underlying);\n58           uint256 initialTokens = ctoken.balanceOf(address(this));\n59   \n60           address addr = account.addr();\n61   \n62           if (repayDebt) {\n63               amount -= _repayAnyDebt(addr, underlying, amount, ctoken);\n64               if (amount == 0) return true;\n65           }\n66   \n67           uint256 err;\n68           if (underlying == address(0)) {\n69               err = ctoken.mint{value: amount}(amount);\n70           } else {\n71               IERC20(underlying).safeApprove(address(ctoken), amount);\n```\n\n[CompoundHandler.sol#L50-L71](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/handlers/CompoundHandler.sol#L50-L71)<br>\n\nCompound-specific top-ups will also fail when trying to repay debt:\n\n```solidity\nFile: backd/contracts/actions/topup/handlers/CompoundHandler.sol   #2\n\n62           if (repayDebt) {\n63               amount -= _repayAnyDebt(addr, underlying, amount, ctoken);\n64               if (amount == 0) return true;\n65           }\n```\n\n[CompoundHandler.sol#L62-L65](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/handlers/CompoundHandler.sol#L62-L65)<br>\n\nAave-specific top-ups will fail for the `lendingPool`:\n\n```solidity\nFile: backd/contracts/actions/topup/handlers/AaveHandler.sol   #3\n\n36       function topUp(\n37           bytes32 account,\n38           address underlying,\n39           uint256 amount,\n40           bytes memory extra\n41       ) external override returns (bool) {\n42           bool repayDebt = abi.decode(extra, (bool));\n43           if (underlying == address(0)) {\n44               weth.deposit{value: amount}();\n45               underlying = address(weth);\n46           }\n47   \n48           address addr = account.addr();\n49   \n50           DataTypes.ReserveData memory reserve = lendingPool.getReserveData(underlying);\n51           require(reserve.aTokenAddress != address(0), Error.UNDERLYING_NOT_SUPPORTED);\n52   \n53           IERC20(underlying).safeApprove(address(lendingPool), amount);\n```\n\n[AaveHandler.sol#L36-L53](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/handlers/AaveHandler.sol#L36-L53)<br>\n\nThe `TopUpAction` itself fails for the `feeHandler`:\n\n```solidity\nFile: backd/contracts/actions/topup/TopUpAction.sol   #4\n\n840       function _payFees(\n841           address payer,\n842           address beneficiary,\n843           uint256 feeAmount,\n844           address depositToken\n845       ) internal {\n846           address feeHandler = getFeeHandler();\n847           IERC20(depositToken).safeApprove(feeHandler, feeAmount);\n```\n\n[TopUpAction.sol#L840-L847](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L840-L847)<br>\n\nI've filed the other less-severe instances as a separate medium-severity issue, and flagged the remaining low-severity instances in my QA report.\n\n### Recommended Mitigation Steps\n\nAlways do `safeApprove(0)` if the allowance is being changed, or use `safeIncreaseAllowance()`.\n\n**[chase-manning (Backd) confirmed and resolved](https://github.com/code-423n4/2022-04-backd-findings/issues/178)**\n\n\n\n***\n\n \n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-04-backd-contest",
  "Code": [
    {
      "filename": "backd/contracts/actions/topup/handlers/CompoundHandler.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../../../../libraries/AccountEncoding.sol\";\n\nimport \"./BaseHandler.sol\";\nimport \"../../../../interfaces/ICTokenRegistry.sol\";\nimport \"../../../../interfaces/vendor/CToken.sol\";\nimport \"../../../../interfaces/vendor/ExponentialNoError.sol\";\nimport \"../../../../interfaces/vendor/Comptroller.sol\";\nimport \"../../../../libraries/Errors.sol\";\nimport \"../../../../libraries/ScaledMath.sol\";\n\ncontract CompoundHandler is BaseHandler, ExponentialNoError {\n    using ScaledMath for uint256;\n    using SafeERC20 for IERC20;\n    using AccountEncoding for bytes32;\n\n    struct AccountLiquidityLocalVars {\n        uint256 sumCollateral;\n        uint256 sumBorrow;\n        uint256 cTokenBalance;\n        uint256 borrowBalance;\n        uint256 exchangeRateMantissa;\n        uint256 oraclePriceMantissa;\n        Exp collateralFactor;\n        Exp exchangeRate;\n        Exp oraclePrice;\n        Exp tokensToDenom;\n    }\n\n    Comptroller public immutable comptroller;\n    ICTokenRegistry public immutable cTokenRegistry;\n\n    constructor(address comptrollerAddress, address _cTokenRegistry) {\n        comptroller = Comptroller(comptrollerAddress);\n        cTokenRegistry = ICTokenRegistry(_cTokenRegistry);\n    }\n\n    /**\n     * @notice Executes the top-up of a position.\n     * @param account Account holding the position.\n     * @param underlying Underlying for tup-up.\n     * @param amount Amount to top-up by.\n     * @return `true` if successful.\n     */\n    function topUp(\n        bytes32 account,\n        address underlying,\n        uint256 amount,\n        bytes memory extra\n    ) external override returns (bool) {\n        bool repayDebt = abi.decode(extra, (bool));\n        CToken ctoken = cTokenRegistry.fetchCToken(underlying);\n        uint256 initialTokens = ctoken.balanceOf(address(this));\n\n        address addr = account.addr();\n\n        if (repayDebt) {\n            amount -= _repayAnyDebt(addr, underlying, amount, ctoken);\n            if (amount == 0) return true;\n        }\n\n        uint256 err;\n        if (underlying == address(0)) {\n            err = ctoken.mint{value: amount}(amount);\n        } else {\n            IERC20(underlying).safeApprove(address(ctoken), amount);\n            err = ctoken.mint(amount);\n        }\n        require(err == 0, Error.FAILED_MINT);\n\n        uint256 newTokens = ctoken.balanceOf(address(this));\n        uint256 mintedTokens = newTokens - initialTokens;\n\n        bool success = ctoken.transfer(addr, mintedTokens);\n        require(success, Error.FAILED_TRANSFER);\n        return true;\n    }\n\n    /**\n     * @notice Returns the collaterization ratio of the user.\n     *         A result of 1.5 (x1e18) means that the user has a 150% collaterization ratio.\n     * @param account account for which to check the factor.\n     * @return User factor.\n     */\n    function getUserFactor(bytes32 account, bytes memory) external view override returns (uint256) {\n        (uint256 sumCollateral, uint256 sumBorrow) = _getAccountBorrowsAndSupply(account.addr());\n        if (sumBorrow == 0) {\n            return type(uint256).max;\n        }\n        return sumCollateral.scaledDiv(sumBorrow);\n    }\n\n    /**\n     * @notice Repays any existing debt for the given underlying.\n     * @param account Account for which to repay the debt.\n     * @param underlying The underlying token to repay the debt for.\n     * @param maximum The maximum amount of debt to repay.\n     * @return The amount of debt that was repayed in the underlying.\n     */\n    function _repayAnyDebt(\n        address account,\n        address underlying,\n        uint256 maximum,\n        CToken ctoken\n    ) internal returns (uint256) {\n        uint256 debt = ctoken.borrowBalanceCurrent(account);\n        if (debt == 0) return 0;\n        if (debt > maximum) debt = maximum;\n\n        uint256 err;\n        if (underlying == address(0)) {\n            CEther cether = CEther(address(ctoken));\n            err = cether.repayBorrowBehalf{value: debt}(account);\n        } else {\n            IERC20(underlying).safeApprove(address(ctoken), debt);\n            err = ctoken.repayBorrowBehalf(account, debt);\n        }\n        require(err == 0, Error.FAILED_REPAY_BORROW);\n\n        return debt;\n    }\n\n    function _getAccountBorrowsAndSupply(address account) internal view returns (uint256, uint256) {\n        AccountLiquidityLocalVars memory vars; // Holds all our calculation results\n        uint256 oErr;\n\n        PriceOracle oracle = comptroller.oracle();\n        // For each asset the account is in\n        CToken[] memory assets = comptroller.getAssetsIn(account);\n        for (uint256 i = 0; i < assets.length; i++) {\n            CToken asset = assets[i];\n\n            // Read the balances and exchange rate from the cToken\n            (oErr, vars.cTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = asset\n                .getAccountSnapshot(account);\n            require(oErr == 0, Error.FAILED_METHOD_CALL);\n            (, uint256 collateralFactorMantissa, ) = comptroller.markets(address(asset));\n            vars.collateralFactor = Exp({mantissa: collateralFactorMantissa});\n            vars.exchangeRate = Exp({mantissa: vars.exchangeRateMantissa});\n\n            // Get the normalized price of the asset\n            vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset);\n            require(vars.oraclePriceMantissa != 0, Error.FAILED_METHOD_CALL);\n            vars.oraclePrice = Exp({mantissa: vars.oraclePriceMantissa});\n\n            // Pre-compute a conversion factor from tokens -> ether (normalized price value)\n            vars.tokensToDenom = mul_(\n                mul_(vars.collateralFactor, vars.exchangeRate),\n                vars.oraclePrice\n            );\n\n            // sumCollateral += tokensToDenom * cTokenBalance\n            vars.sumCollateral = mul_ScalarTruncateAddUInt(\n                vars.tokensToDenom,\n                vars.cTokenBalance,\n                vars.sumCollateral\n            );\n\n            // sumBorrow += oraclePrice * borrowBalance\n            vars.sumBorrow = mul_ScalarTruncateAddUInt(\n                vars.oraclePrice,\n                vars.borrowBalance,\n                vars.sumBorrow\n            );\n        }\n\n        return (vars.sumCollateral, vars.sumBorrow);\n    }\n}"
    },
    {
      "filename": "backd/contracts/actions/topup/handlers/CompoundHandler.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../../../../libraries/AccountEncoding.sol\";\n\nimport \"./BaseHandler.sol\";\nimport \"../../../../interfaces/ICTokenRegistry.sol\";\nimport \"../../../../interfaces/vendor/CToken.sol\";\nimport \"../../../../interfaces/vendor/ExponentialNoError.sol\";\nimport \"../../../../interfaces/vendor/Comptroller.sol\";\nimport \"../../../../libraries/Errors.sol\";\nimport \"../../../../libraries/ScaledMath.sol\";\n\ncontract CompoundHandler is BaseHandler, ExponentialNoError {\n    using ScaledMath for uint256;\n    using SafeERC20 for IERC20;\n    using AccountEncoding for bytes32;\n\n    struct AccountLiquidityLocalVars {\n        uint256 sumCollateral;\n        uint256 sumBorrow;\n        uint256 cTokenBalance;\n        uint256 borrowBalance;\n        uint256 exchangeRateMantissa;\n        uint256 oraclePriceMantissa;\n        Exp collateralFactor;\n        Exp exchangeRate;\n        Exp oraclePrice;\n        Exp tokensToDenom;\n    }\n\n    Comptroller public immutable comptroller;\n    ICTokenRegistry public immutable cTokenRegistry;\n\n    constructor(address comptrollerAddress, address _cTokenRegistry) {\n        comptroller = Comptroller(comptrollerAddress);\n        cTokenRegistry = ICTokenRegistry(_cTokenRegistry);\n    }\n\n    /**\n     * @notice Executes the top-up of a position.\n     * @param account Account holding the position.\n     * @param underlying Underlying for tup-up.\n     * @param amount Amount to top-up by.\n     * @return `true` if successful.\n     */\n    function topUp(\n        bytes32 account,\n        address underlying,\n        uint256 amount,\n        bytes memory extra\n    ) external override returns (bool) {\n        bool repayDebt = abi.decode(extra, (bool));\n        CToken ctoken = cTokenRegistry.fetchCToken(underlying);\n        uint256 initialTokens = ctoken.balanceOf(address(this));\n\n        address addr = account.addr();\n\n        if (repayDebt) {\n            amount -= _repayAnyDebt(addr, underlying, amount, ctoken);\n            if (amount == 0) return true;\n        }\n\n        uint256 err;\n        if (underlying == address(0)) {\n            err = ctoken.mint{value: amount}(amount);\n        } else {\n            IERC20(underlying).safeApprove(address(ctoken), amount);\n            err = ctoken.mint(amount);\n        }\n        require(err == 0, Error.FAILED_MINT);\n\n        uint256 newTokens = ctoken.balanceOf(address(this));\n        uint256 mintedTokens = newTokens - initialTokens;\n\n        bool success = ctoken.transfer(addr, mintedTokens);\n        require(success, Error.FAILED_TRANSFER);\n        return true;\n    }\n\n    /**\n     * @notice Returns the collaterization ratio of the user.\n     *         A result of 1.5 (x1e18) means that the user has a 150% collaterization ratio.\n     * @param account account for which to check the factor.\n     * @return User factor.\n     */\n    function getUserFactor(bytes32 account, bytes memory) external view override returns (uint256) {\n        (uint256 sumCollateral, uint256 sumBorrow) = _getAccountBorrowsAndSupply(account.addr());\n        if (sumBorrow == 0) {\n            return type(uint256).max;\n        }\n        return sumCollateral.scaledDiv(sumBorrow);\n    }\n\n    /**\n     * @notice Repays any existing debt for the given underlying.\n     * @param account Account for which to repay the debt.\n     * @param underlying The underlying token to repay the debt for.\n     * @param maximum The maximum amount of debt to repay.\n     * @return The amount of debt that was repayed in the underlying.\n     */\n    function _repayAnyDebt(\n        address account,\n        address underlying,\n        uint256 maximum,\n        CToken ctoken\n    ) internal returns (uint256) {\n        uint256 debt = ctoken.borrowBalanceCurrent(account);\n        if (debt == 0) return 0;\n        if (debt > maximum) debt = maximum;\n\n        uint256 err;\n        if (underlying == address(0)) {\n            CEther cether = CEther(address(ctoken));\n            err = cether.repayBorrowBehalf{value: debt}(account);\n        } else {\n            IERC20(underlying).safeApprove(address(ctoken), debt);\n            err = ctoken.repayBorrowBehalf(account, debt);\n        }\n        require(err == 0, Error.FAILED_REPAY_BORROW);\n\n        return debt;\n    }\n\n    function _getAccountBorrowsAndSupply(address account) internal view returns (uint256, uint256) {\n        AccountLiquidityLocalVars memory vars; // Holds all our calculation results\n        uint256 oErr;\n\n        PriceOracle oracle = comptroller.oracle();\n        // For each asset the account is in\n        CToken[] memory assets = comptroller.getAssetsIn(account);\n        for (uint256 i = 0; i < assets.length; i++) {\n            CToken asset = assets[i];\n\n            // Read the balances and exchange rate from the cToken\n            (oErr, vars.cTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = asset\n                .getAccountSnapshot(account);\n            require(oErr == 0, Error.FAILED_METHOD_CALL);\n            (, uint256 collateralFactorMantissa, ) = comptroller.markets(address(asset));\n            vars.collateralFactor = Exp({mantissa: collateralFactorMantissa});\n            vars.exchangeRate = Exp({mantissa: vars.exchangeRateMantissa});\n\n            // Get the normalized price of the asset\n            vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset);\n            require(vars.oraclePriceMantissa != 0, Error.FAILED_METHOD_CALL);\n            vars.oraclePrice = Exp({mantissa: vars.oraclePriceMantissa});\n\n            // Pre-compute a conversion factor from tokens -> ether (normalized price value)\n            vars.tokensToDenom = mul_(\n                mul_(vars.collateralFactor, vars.exchangeRate),\n                vars.oraclePrice\n            );\n\n            // sumCollateral += tokensToDenom * cTokenBalance\n            vars.sumCollateral = mul_ScalarTruncateAddUInt(\n                vars.tokensToDenom,\n                vars.cTokenBalance,\n                vars.sumCollateral\n            );\n\n            // sumBorrow += oraclePrice * borrowBalance\n            vars.sumBorrow = mul_ScalarTruncateAddUInt(\n                vars.oraclePrice,\n                vars.borrowBalance,\n                vars.sumBorrow\n            );\n        }\n\n        return (vars.sumCollateral, vars.sumBorrow);\n    }\n}"
    },
    {
      "filename": "backd/contracts/actions/topup/handlers/AaveHandler.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../../../libraries/Errors.sol\";\nimport \"../../../../libraries/AccountEncoding.sol\";\n\nimport \"../../../../interfaces/actions/topup/ITopUpHandler.sol\";\nimport \"../../../../interfaces/vendor/ILendingPool.sol\";\nimport \"../../../../interfaces/vendor/IWETH.sol\";\nimport \"../../../../libraries/vendor/DataTypes.sol\";\n\ncontract AaveHandler is ITopUpHandler {\n    using SafeERC20 for IERC20;\n    using AccountEncoding for bytes32;\n\n    uint16 public constant BACKD_REFERRAL_CODE = 62314;\n\n    ILendingPool public immutable lendingPool;\n    IWETH public immutable weth;\n\n    constructor(address lendingPoolAddress, address wethAddress) {\n        lendingPool = ILendingPool(lendingPoolAddress);\n        weth = IWETH(wethAddress);\n    }\n\n    /**\n     * @notice Executes the top-up of a position.\n     * @param account Account holding the position.\n     * @param underlying Underlying for tup-up.\n     * @param amount Amount to top-up by.\n     * @return `true` if successful.\n     */\n    function topUp(\n        bytes32 account,\n        address underlying,\n        uint256 amount,\n        bytes memory extra\n    ) external override returns (bool) {\n        bool repayDebt = abi.decode(extra, (bool));\n        if (underlying == address(0)) {\n            weth.deposit{value: amount}();\n            underlying = address(weth);\n        }\n\n        address addr = account.addr();\n\n        DataTypes.ReserveData memory reserve = lendingPool.getReserveData(underlying);\n        require(reserve.aTokenAddress != address(0), Error.UNDERLYING_NOT_SUPPORTED);\n\n        IERC20(underlying).safeApprove(address(lendingPool), amount);\n\n        if (repayDebt) {\n            uint256 stableDebt = IERC20(reserve.stableDebtTokenAddress).balanceOf(addr);\n            uint256 variableDebt = IERC20(reserve.variableDebtTokenAddress).balanceOf(addr);\n            if (variableDebt + stableDebt > 0) {\n                uint256 rateMode = stableDebt > variableDebt ? 1 : 2;\n                amount -= lendingPool.repay(underlying, amount, rateMode, addr);\n                if (amount == 0) return true;\n            }\n        }\n\n        lendingPool.deposit(underlying, amount, addr, BACKD_REFERRAL_CODE);\n        return true;\n    }\n\n    function getUserFactor(bytes32 account, bytes memory) external view override returns (uint256) {\n        (, , , , , uint256 healthFactor) = lendingPool.getUserAccountData(account.addr());\n        return healthFactor;\n    }\n}"
    },
    {
      "filename": "backd/contracts/actions/topup/TopUpAction.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport \"../../../interfaces/IGasBank.sol\";\nimport \"../../../interfaces/pool/ILiquidityPool.sol\";\nimport \"../../../interfaces/ISwapperRegistry.sol\";\nimport \"../../../interfaces/IController.sol\";\nimport \"../../../interfaces/IStakerVault.sol\";\nimport \"../../../interfaces/ISwapper.sol\";\nimport \"../../../interfaces/actions/topup/ITopUpHandler.sol\";\nimport \"../../../interfaces/actions/topup/ITopUpAction.sol\";\nimport \"../../../interfaces/actions/IActionFeeHandler.sol\";\n\nimport \"../../../libraries/AddressProviderHelpers.sol\";\nimport \"../../../libraries/Errors.sol\";\nimport \"../../../libraries/ScaledMath.sol\";\nimport \"../../../libraries/EnumerableExtensions.sol\";\n\nimport \"../../access/Authorization.sol\";\nimport \"../../utils/Preparable.sol\";\n\n/**\n * @notice The logic here should really be part of the top-up action\n * but is split in a library to circumvent the byte-code size limit\n */\nlibrary TopUpActionLibrary {\n    using SafeERC20 for IERC20;\n    using ScaledMath for uint256;\n    using AddressProviderHelpers for IAddressProvider;\n\n    function lockFunds(\n        address stakerVaultAddress,\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) external {\n        uint256 amountLeft = lockAmount;\n        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);\n\n        // stake deposit amount\n        if (depositAmount > 0) {\n            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;\n            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);\n            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);\n            stakerVault.stake(depositAmount);\n            stakerVault.increaseActionLockedBalance(payer, depositAmount);\n            amountLeft -= depositAmount;\n        }\n\n        // use stake vault allowance if available and required\n        if (amountLeft > 0) {\n            uint256 balance = stakerVault.balanceOf(payer);\n            uint256 allowance = stakerVault.allowance(payer, address(this));\n            uint256 availableFunds = balance < allowance ? balance : allowance;\n            if (availableFunds >= amountLeft) {\n                stakerVault.transferFrom(payer, address(this), amountLeft);\n                amountLeft = 0;\n            }\n        }\n\n        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);\n    }\n\n    /**\n     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.\n     */\n    function calcExchangeAmount(\n        IAddressProvider addressProvider,\n        address token,\n        address actionToken,\n        uint256 amount\n    ) external view returns (uint256) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(token);\n        uint256 rate = pool.exchangeRate();\n        address underlying = pool.getUnderlying();\n        if (underlying == actionToken) {\n            return amount.scaledDivRoundUp(rate);\n        }\n\n        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);\n        uint256 swapperRate = swapper.getRate(underlying, actionToken);\n        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));\n    }\n\n    function getSwapper(\n        IAddressProvider addressProvider,\n        address underlying,\n        address actionToken\n    ) public view returns (ISwapper) {\n        address swapperRegistry = addressProvider.getSwapperRegistry();\n        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);\n        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);\n        return ISwapper(swapper);\n    }\n}\n\ncontract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {\n    using ScaledMath for uint256;\n    using ScaledMath for uint128;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using EnumerableExtensions for EnumerableSet.AddressSet;\n    using AddressProviderHelpers for IAddressProvider;\n\n    /**\n     * @dev Temporary struct to hold local variables in execute\n     * and avoid the stack being \"too deep\"\n     */\n    struct ExecuteLocalVars {\n        uint256 minActionAmountToTopUp;\n        uint256 actionTokenAmount;\n        uint256 depositTotalFeesAmount;\n        uint256 actionAmountWithFees;\n        uint256 userFactor;\n        uint256 rate;\n        uint256 depositAmountWithFees;\n        uint256 depositAmountWithoutFees;\n        uint256 actionFee;\n        uint256 totalActionTokenAmount;\n        uint128 totalTopUpAmount;\n        bool success;\n        bytes topupResult;\n        uint256 gasBankBalance;\n        uint256 initialGas;\n        uint256 gasConsumed;\n        uint256 userGasPrice;\n        uint256 estimatedRequiredGas;\n        uint256 estimatedRequiredWeiForGas;\n        uint256 requiredWeiForGas;\n        uint256 reimbursedWeiForGas;\n        address underlying;\n        bool removePosition;\n    }\n\n    EnumerableSet.AddressSet private _usableTokens;\n\n    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;\n\n    bytes32 internal constant _ACTION_FEE_KEY = \"ActionFee\";\n    bytes32 internal constant _FEE_HANDLER_KEY = \"FeeHandler\";\n    bytes32 internal constant _TOP_UP_HANDLER_KEY = \"TopUpHandler\";\n    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = \"EstimatedGasUsage\";\n    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = \"MaxSwapperSlippage\";\n\n    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;\n    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;\n    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;\n\n    IController public immutable controller;\n    IAddressProvider public immutable addressProvider;\n\n    EnumerableSet.Bytes32Set internal _supportedProtocols;\n\n    /// @notice mapping of (payer -> account -> protocol -> Record)\n    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;\n\n    mapping(address => RecordMeta[]) internal _userPositions;\n\n    EnumerableSet.AddressSet internal _usersWithPositions;\n\n    constructor(IController _controller)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        controller = _controller;\n        addressProvider = controller.addressProvider();\n        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);\n    }\n\n    receive() external payable {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    function initialize(\n        address feeHandler,\n        bytes32[] calldata protocols,\n        address[] calldata handlers\n    ) external initializer onlyGovernance {\n        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);\n        _setConfig(_FEE_HANDLER_KEY, feeHandler);\n        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);\n        for (uint256 i = 0; i < protocols.length; i++) {\n            bytes32 protocolKey = _getProtocolKey(protocols[i]);\n            _setConfig(protocolKey, handlers[i]);\n            _updateTopUpHandler(protocols[i], address(0), handlers[i]);\n        }\n    }\n\n    /**\n     * @notice Register a top up action.\n     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).\n     * @param account Account to be topped up (first 20 bytes will typically be the address).\n     * @param depositAmount Amount of `depositToken` that will be locked.\n     * @param protocol Protocol which holds position to be topped up.\n     * @param record containing the data for the position to register\n     */\n    function register(\n        bytes32 account,\n        bytes32 protocol,\n        uint128 depositAmount,\n        Record memory record\n    ) external payable returns (bool) {\n        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);\n        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);\n        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);\n        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);\n        require(\n            _positions[msg.sender][account][protocol].threshold == 0,\n            Error.POSITION_ALREADY_EXISTS\n        );\n        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);\n        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);\n\n        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *\n            record.maxFee *\n            getEstimatedGasUsage();\n\n        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);\n\n        uint256 totalLockAmount = _calcExchangeAmount(\n            record.depositToken,\n            record.actionToken,\n            record.totalTopUpAmount\n        );\n        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);\n\n        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);\n\n        record.depositTokenBalance = uint128(totalLockAmount);\n        _positions[msg.sender][account][protocol] = record;\n        _userPositions[msg.sender].push(RecordMeta(account, protocol));\n        _usersWithPositions.add(msg.sender);\n\n        emit Register(\n            account,\n            protocol,\n            record.threshold,\n            msg.sender,\n            record.depositToken,\n            totalLockAmount,\n            record.actionToken,\n            record.singleTopUpAmount,\n            record.totalTopUpAmount,\n            record.maxFee,\n            record.extra\n        );\n        return true;\n    }\n\n    /**\n     * @notice See overloaded version of `execute` for more details.\n     */\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol\n    ) external override returns (bool) {\n        return execute(payer, account, beneficiary, protocol, 0);\n    }\n\n    /**\n     * @notice Delete a position to back on the given protocol for `account`.\n     * @param account Account holding the position.\n     * @param protocol Protocol the position is held on.\n     * @param unstake If the tokens should be unstaked from vault.\n     * @return `true` if successful.\n     */\n    function resetPosition(\n        bytes32 account,\n        bytes32 protocol,\n        bool unstake\n    ) external override returns (bool) {\n        address payer = msg.sender;\n        Record memory position = _positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n\n        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist\n        IStakerVault staker = IStakerVault(vault);\n        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);\n        if (unstake) {\n            staker.unstake(position.depositTokenBalance);\n            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);\n        } else {\n            staker.transfer(payer, position.depositTokenBalance);\n        }\n\n        _removePosition(payer, account, protocol);\n        addressProvider.getGasBank().withdrawUnused(payer);\n        return true;\n    }\n\n    /**\n     * @notice Execute top up handler update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @param protocol Protocol for which a new handler should be executed.\n     * @return Address of new handler.\n     */\n    function executeTopUpHandler(bytes32 protocol) external override returns (address) {\n        address oldHandler = _getHandler(protocol, false);\n        address newHandler = _executeAddress(_getProtocolKey(protocol));\n\n        _updateTopUpHandler(protocol, oldHandler, newHandler);\n        return newHandler;\n    }\n\n    /**\n     * @notice Reset new top up handler deadline for a protocol.\n     * @param protocol Protocol for which top up handler deadline should be reset.\n     * @return `true` if successful.\n     */\n    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_getProtocolKey(protocol));\n    }\n\n    /**\n     * @notice Prepare action fee update.\n     * @param newActionFee New fee to set.\n     * @return `true` if success.\n     */\n    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {\n        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);\n        return _prepare(_ACTION_FEE_KEY, newActionFee);\n    }\n\n    /**\n     * @notice Execute action fee update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return `true` if successful.\n     */\n    function executeActionFee() external override returns (uint256) {\n        return _executeUInt256(_ACTION_FEE_KEY);\n    }\n\n    /**\n     * @notice Reset action fee deadline.\n     * @return `true` if successful.\n     */\n    function resetActionFee() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ACTION_FEE_KEY);\n    }\n\n    /**\n     * @notice Prepare swapper slippage update.\n     * @param newSwapperSlippage New slippage to set.\n     * @return `true` if success.\n     */\n    function prepareSwapperSlippage(uint256 newSwapperSlippage)\n        external\n        onlyGovernance\n        returns (bool)\n    {\n        require(\n            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&\n                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,\n            Error.INVALID_AMOUNT\n        );\n        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);\n    }\n\n    /**\n     * @notice Execute swapper slippage update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return `true` if successful.\n     */\n    function executeSwapperSlippage() external override returns (uint256) {\n        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);\n    }\n\n    /**\n     * @notice Reset action fee deadline.\n     * @return `true` if successful.\n     */\n    function resetSwapperSlippage() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);\n    }\n\n    /** Set fee handler */\n    /**\n     * @notice Prepare update of fee handler.\n     * @param handler New fee handler.\n     * @return `true` if success.\n     */\n    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {\n        return _prepare(_FEE_HANDLER_KEY, handler);\n    }\n\n    /**\n     * @notice Execute update of fee handler (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return `true` if successful.\n     */\n    function executeFeeHandler() external override returns (address) {\n        return _executeAddress(_FEE_HANDLER_KEY);\n    }\n\n    /**\n     * @notice Reset the handler deadline.\n     * @return `true` if success.\n     */\n    function resetFeeHandler() external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_FEE_HANDLER_KEY);\n    }\n\n    /**\n     * @notice Prepare update of estimated gas usage.\n     * @param gasUsage New estimated gas usage.\n     * @return `true` if success.\n     */\n    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {\n        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);\n    }\n\n    /**\n     * @notice Execute update of gas usage (with time delay enforced).\n     * @return `true` if successful.\n     */\n    function executeEstimatedGasUsage() external returns (uint256) {\n        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /**\n     * @notice Reset the gas usage deadline.\n     * @return `true` if success.\n     */\n    function resetGasUsage() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /**\n     * @notice Add a new deposit token that is supported by the action.\n     * @dev There is a separate check for whether the usable token (i.e. deposit token)\n     *      is swappable for some action token.\n     * @param token Address of deposit token that can be used by the action.\n     */\n    function addUsableToken(address token) external override onlyGovernance returns (bool) {\n        return _usableTokens.add(token);\n    }\n\n    /**\n     * @notice Computes the total amount of ETH (as wei) required to pay for all\n     * the top-ups assuming the maximum gas price and the current estimated gas\n     * usage of a top-up\n     */\n    function getEthRequiredForGas(address payer) external view"
    }
  ]
}