{
  "Title": "M-13: `FlashRolloverLoan_G5` will not work for certain tokens due to not setting the approval to `0` after repaying a loan",
  "Content": "# Issue M-13: `FlashRolloverLoan_G5` will not work for certain tokens due to not setting the approval to `0` after repaying a loan \n\nSource: https://github.com/sherlock-audit/2024-04-teller-finance-judging/issues/140 \n\n## Found by \n0x73696d616f, EgisSecurity, MaslarovK.eth, givn, merlin, mgf15\n## Summary\n\n`FlashRolloverLoan_G5::_repayLoanFull()` approves `TELLER_V2` for `_repayAmount`, but `TELLER_V2` always pulls the principal and interest, possibly leaving some dust approval left. Some tokens revert when trying to set approvals from non null to non null, which will make `FlashRolloverLoan_G5` revert.\n\n## Vulnerability Detail\n\nSome `ERC20` tokens must have 0 approval before setting an approval to a non 0 amount, such as USDC. \n\nThe interest rises with `block.timestamp`, so borrowers will likely take a flash loan slightly bigger than `_repayAmount` to take this into account, or `repay` will fail.\n\nThus, when the approval is set for `TellerV2` of the `_principalToken`, `principal + interest` may be less than the approval, which will leave a dust approval.\n\n`FlashRolloverLoan_G5::executeOperation()` later on approves `POOL`, which will revert as a dust amount was left.\n\n## Impact\n\n`FlashRolloverLoan_G5` will not work and be DoSed.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-04-teller-finance/blob/main/teller-protocol-v2-audit-2024/packages/contracts/contracts/LenderCommitmentForwarder/extensions/FlashRolloverLoan_G5.sol#L243-L245\nhttps://github.com/sherlock-audit/2024-04-teller-finance/blob/main/teller-protocol-v2-audit-2024/packages/contracts/contracts/LenderCommitmentForwarder/extensions/FlashRolloverLoan_G5.sol#L194-L196\n\n## Tool used\n\nManual Review\n\nVscode\n\n## Recommendation\n\nSet the approval to 0 after repaying the loan.\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/teller-protocol/teller-protocol-v2-audit-2024/pull/32\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/295",
  "Code": [
    {
      "filename": "teller-protocol-v2-audit-2024/packages/contracts/contracts/LenderCommitmentForwarder/extensions/FlashRolloverLoan_G5.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Contracts\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n// Interfaces\nimport \"../../interfaces/ITellerV2.sol\";\nimport \"../../interfaces/IProtocolFee.sol\";\nimport \"../../interfaces/ITellerV2Storage.sol\";\nimport \"../../interfaces/IMarketRegistry.sol\";\nimport \"../../interfaces/ILenderCommitmentForwarder.sol\";\nimport \"../../interfaces/ISmartCommitmentForwarder.sol\";\nimport \"../../interfaces/IFlashRolloverLoan_G4.sol\";\nimport \"../../libraries/NumbersLib.sol\";\n\nimport { IPool } from \"../../interfaces/aave/IPool.sol\";\nimport { IFlashLoanSimpleReceiver } from \"../../interfaces/aave/IFlashLoanSimpleReceiver.sol\";\nimport { IPoolAddressesProvider } from \"../../interfaces/aave/IPoolAddressesProvider.sol\";\n\ncontract FlashRolloverLoan_G5 is IFlashLoanSimpleReceiver, IFlashRolloverLoan_G4 {\n    using AddressUpgradeable for address;\n    using NumbersLib for uint256;\n\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    ITellerV2 public immutable TELLER_V2;\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    \n\n    address public immutable POOL_ADDRESSES_PROVIDER;\n\n    event RolloverLoanComplete(\n        address borrower,\n        uint256 originalLoanId,\n        uint256 newLoanId,\n        uint256 fundsRemaining\n    );\n\n    struct AcceptCommitmentArgs {\n        uint256 commitmentId;\n        address smartCommitmentAddress;  //if this is not address(0), we will use this ! leave empty if not used. \n        uint256 principalAmount;\n        uint256 collateralAmount;\n        uint256 collateralTokenId;\n        address collateralTokenAddress;\n        uint16 interestRate;\n        uint32 loanDuration;\n        bytes32[] merkleProof; //empty array if not used\n    }\n\n    /**\n     *\n     * @notice Initializes the FlashRolloverLoan with necessary contract addresses.\n     *\n     * @dev Using a custom OpenZeppelin upgrades tag. Ensure the constructor logic is safe for upgrades.\n     *\n     * @param _tellerV2 The address of the TellerV2 contract.\n     * @param _lenderCommitmentForwarder The address of the LenderCommitmentForwarder contract.\n     * @param _poolAddressesProvider The address of the PoolAddressesProvider.\n     */\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(\n        address _tellerV2,\n        address _poolAddressesProvider\n    ) {\n        TELLER_V2 = ITellerV2(_tellerV2);\n        POOL_ADDRESSES_PROVIDER = _poolAddressesProvider;\n    }\n\n    modifier onlyFlashLoanPool() {\n        require(\n            msg.sender == address(POOL()),\n            \"FlashRolloverLoan: Must be called by FlashLoanPool\"\n        );\n\n        _;\n    }\n\n    /**\n     *\n     * @notice Allows the borrower to rollover their existing loan using a flash loan mechanism.\n     *         The borrower might also provide an additional amount during the rollover.\n     *\n     * @dev The function first verifies that the caller is the borrower of the loan.\n     *      It then optionally transfers the additional amount specified by the borrower.\n     *      A flash loan is then taken from the pool to facilitate the rollover and\n     *      a callback is executed for further operations.\n     *\n     * @param _loanId Identifier of the existing loan to be rolled over.\n     * @param _flashLoanAmount Amount of flash loan to be borrowed for the rollover.\n     * @param _borrowerAmount Additional amount that the borrower may want to add during rollover.\n     * @param _acceptCommitmentArgs Commitment arguments that might be necessary for internal operations.\n     * \n     */\n    function rolloverLoanWithFlash(\n        address _lenderCommitmentForwarder,\n        uint256 _loanId,\n        uint256 _flashLoanAmount,\n        uint256 _borrowerAmount, //an additional amount borrower may have to add\n        AcceptCommitmentArgs calldata _acceptCommitmentArgs\n    ) external   {\n        address borrower = TELLER_V2.getLoanBorrower(_loanId);\n        require(borrower == msg.sender, \"CommitmentRolloverLoan: not borrower\");\n\n        // Get lending token and balance before\n        address lendingToken = TELLER_V2.getLoanLendingToken(_loanId);\n\n        if (_borrowerAmount > 0) {\n            IERC20(lendingToken).transferFrom(\n                borrower,\n                address(this),\n                _borrowerAmount\n            );\n        }\n\n        // Call 'Flash' on the vault to borrow funds and call tellerV2FlashCallback\n        // This ultimately calls executeOperation\n        IPool(POOL()).flashLoanSimple(\n            address(this),\n            lendingToken,\n            _flashLoanAmount,\n            abi.encode(\n                RolloverCallbackArgs({\n                    lenderCommitmentForwarder :_lenderCommitmentForwarder,\n                    loanId: _loanId,\n                    borrower: borrower,\n                    borrowerAmount: _borrowerAmount,\n                    acceptCommitmentArgs: abi.encode(_acceptCommitmentArgs)\n                })\n            ),\n            0 //referral code\n        );\n    }\n\n    /**\n     *\n     * @notice Callback function that is triggered by Aave during the flash loan process.\n     *         This function handles the logic to use the borrowed funds to rollover the loan,\n     *         make necessary repayments, and manage the loan commitments.\n     *\n     * @dev The function ensures the initiator is this contract, decodes the data provided by\n     *      the flash loan call, repays the original loan in full, accepts new loan commitments,\n     *      approves the repayment for the flash loan and then handles any remaining funds.\n     *      This function should only be called by the FlashLoanPool as ensured by the `onlyFlashLoanPool` modifier.\n     *\n     * @param _flashToken The token in which the flash loan is borrowed.\n     * @param _flashAmount The amount of tokens borrowed via the flash loan.\n     * @param _flashFees The fees associated with the flash loan to be repaid to Aave.\n     * @param _initiator The address initiating the flash loan (must be this contract).\n     * @param _data Encoded data containing necessary information for loan rollover.\n     *\n     * @return Returns true if the operation was successful.\n     */\n    function executeOperation(\n        address _flashToken,\n        uint256 _flashAmount,\n        uint256 _flashFees,\n        address _initiator,\n        bytes calldata _data\n    ) external virtual onlyFlashLoanPool returns (bool) {\n        require(\n            _initiator == address(this),\n            \"This contract must be the initiator\"\n        );\n\n        RolloverCallbackArgs memory _rolloverArgs = abi.decode(\n            _data,\n            (RolloverCallbackArgs)\n        );\n\n        uint256 repaymentAmount = _repayLoanFull(\n            _rolloverArgs.loanId,\n            _flashToken,\n            _flashAmount\n        );\n\n        AcceptCommitmentArgs memory acceptCommitmentArgs = abi.decode(\n            _rolloverArgs.acceptCommitmentArgs,\n            (AcceptCommitmentArgs)\n        );\n\n        // Accept commitment and receive funds to this contract\n\n        (uint256 newLoanId, uint256 acceptCommitmentAmount) = _acceptCommitment(\n            _rolloverArgs.lenderCommitmentForwarder,\n            _rolloverArgs.borrower,\n            _flashToken,\n            acceptCommitmentArgs\n        );\n\n        //approve the repayment for the flash loan\n        IERC20Upgradeable(_flashToken).approve(\n            address(POOL()),\n            _flashAmount + _flashFees\n        );\n\n        uint256 fundsRemaining = acceptCommitmentAmount +\n            _rolloverArgs.borrowerAmount -\n            repaymentAmount -\n            _flashFees;\n\n        if (fundsRemaining > 0) {\n            IERC20Upgradeable(_flashToken).transfer(\n                _rolloverArgs.borrower,\n                fundsRemaining\n            );\n        }\n\n        emit RolloverLoanComplete(\n            _rolloverArgs.borrower,\n            _rolloverArgs.loanId,\n            newLoanId,\n            fundsRemaining\n        );\n\n        return true;\n    }\n\n    /**\n     *\n     *\n     * @notice Internal function that repays a loan in full on behalf of this contract.\n     *\n     * @dev The function first calculates the funds held by the contract before repayment, then approves\n     *      the repayment amount to the TellerV2 contract and finally repays the loan in full.\n     *\n     * @param _bidId Identifier of the loan to be repaid.\n     * @param _principalToken The token in which the loan was originated.\n     * @param _repayAmount The amount to be repaid.\n     *\n     * @return repayAmount_ The actual amount that was used for repayment.\n     */\n    function _repayLoanFull(\n        uint256 _bidId,\n        address _principalToken,\n        uint256 _repayAmount\n    ) internal returns (uint256 repayAmount_) {\n        uint256 fundsBeforeRepayment = IERC20Upgradeable(_principalToken)\n            .balanceOf(address(this));\n\n        IERC20Upgradeable(_principalToken).approve(\n            address(TELLER_V2),\n            _repayAmount\n        );\n        TELLER_V2.repayLoanFull(_bidId);\n\n        uint256 fundsAfterRepayment = IERC20Upgradeable(_principalToken)\n            .balanceOf(address(this));\n\n        repayAmount_ = fundsBeforeRepayment - fundsAfterRepayment;\n    }\n\n    /**\n     *\n     *\n     * @notice Accepts a loan commitment using either a Merkle proof or standard method.\n     *\n     * @dev The function first checks if a Merkle proof is provided, based on which it calls the relevant\n     *      `acceptCommitment` function in the LenderCommitmentForwarder contract.\n     *\n     * @param borrower The address of the borrower for whom the commitment is being accepted.\n     * @param principalToken The token in which the loan is being accepted.\n     * @param _commitmentArgs The arguments necessary for accepting the commitment.\n     *\n     * @return bidId_ Identifier of the accepted loan.\n     * @return acceptCommitmentAmount_ The amount received from accepting the commitment.\n     */\n    function _acceptCommitment(\n        address lenderCommitmentForwarder,\n        address borrower,\n        address principalToken,\n        AcceptCommitmentArgs memory _commitmentArgs\n    )\n        internal\n        virtual\n        returns (uint256 bidId_, uint256 acceptCommitmentAmount_)\n    {\n        uint256 fundsBeforeAcceptCommitment = IERC20Upgradeable(principalToken)\n            .balanceOf(address(this));\n\n\n\n        if (_commitmentArgs.smartCommitmentAddress != address(0)) {\n\n             bytes memory responseData = address(lenderCommitmentForwarder)\n                    .functionCall(\n                        abi.encodePacked(\n                            abi.encodeWithSelector(\n                                ISmartCommitmentForwarder\n                                    .acceptSmartCommitmentWithRecipient\n                                    .selector,\n                                _commitmentArgs.smartCommitmentAddress,\n                                _commitmentArgs.principalAmount,\n                                _commitmentArgs.collateralAmount,\n                                _commitmentArgs.collateralTokenId,\n                                _commitmentArgs.collateralTokenAddress,\n                                address(this),\n                                _commitmentArgs.interestRate,\n                                _commitmentArgs.loanDuration\n                            ),\n                            borrower //cant be msg.sender because of the flash flow\n                        )\n                    );\n\n                (bidId_) = abi.decode(responseData, (uint256));\n\n\n        }else { \n\n            bool usingMerkleProof = _commitmentArgs.merkleProof.length > 0;\n\n            if (usingMerkleProof) {\n                bytes memory responseData = address(lenderCommitmentForwarder)\n                    .functionCall(\n                        abi.encodePacked(\n                            abi.encodeWithSelector(\n                                ILenderCommitmentForwarder\n                                    .acceptCommitmentWithRecipientAndProof\n                                    .selector,\n                                _commitmentArgs.commitmentId,\n                                _commitmentArgs.principalAmount,\n                                _commitmentArgs.collateralAmount,\n                                _commitmentArgs.collateralTokenId,\n                                _commitmentArgs.collateralTokenAddress,\n                                address(this),\n                                _commitmentArgs.interestRate,\n                                _commitmentArgs.loanDuration,\n                                _commitmentArgs.merkleProof\n                            ),\n                            borrower //cant be msg.sender because of the flash flow\n                        )\n                    );\n\n                (bidId_) = abi.decode(responseData, (uint256));\n            } else {\n                bytes memory responseData = address(lenderCommitmentForwarder)\n                    .functionCall(\n                        abi.encodePacked(\n                            abi.encodeWithSelector(\n                                ILenderCommitmentForwarder\n                                    .acceptCommitmentWithRecipient\n                                    .selector,\n                                _commitmentArgs.commitmentId,\n                                _commitmentArgs.principalAmount,\n                                _commitmentArgs.collateralAmount,\n                                _commitmentArgs.collateralTokenId,\n                                _commitmentArgs.collateralTokenAddress,\n                                address(this),\n                                _commitmentArgs.interestRate,\n                                _commitmentArgs.loanDuration\n                            ),\n                            borrower //cant be msg.sender because of the flash flow\n                        )\n                    );\n\n                (bidId_) = abi.decode(responseData, (uint256));\n            }\n\n        }\n\n        uint256 fundsAfterAcceptCommitment = IERC20Upgradeable(principalToken)\n            .balanceOf(address(this));\n        acceptCommitmentAmount_ =\n            fundsAfterAcceptCommitment -\n            fundsBeforeAcceptCommitment;\n    }\n\n    function ADDRESSES_PROVIDER() public view returns (IPoolAddressesProvider) {\n        return IPoolAddressesProvider(POOL_ADDRESSES_PROVIDER);\n    }\n\n    function POOL() public view returns (IPool) {\n        return IPool(ADDRESSES_PROVIDER().getPool());\n    }\n\n    /**\n     * @notice Calculates the amount for loan rollover, determining if the borrower owes or receives funds.\n     * @param _loanId The ID of the loan to calculate the rollover amount for.\n     * @param _commitmentArgs Arguments for the commitment.\n     * @param _timestamp The timestamp for when the calculation is executed.\n    \n     */\n    function calculateRolloverAmount(\n        address _lenderCommitmentForwarder,\n        uint256 _loanId,\n        AcceptCommitmentArgs calldata _commitmentArgs,\n        uint16 _flashloanPremiumPct,\n        uint256 _timestamp\n    ) external view returns (uint256 _flashAmount, int256 _borrowerAmount) {\n        Payment memory repayAmountOwed = TELLER_V2.calculateAmountOwed(\n            _loanId,\n            _timestamp\n        );\n\n        uint256 _marketId = _getMarketIdForCommitment(_lenderCommitmentForwarder,\n            _commitmentArgs.commitmentId\n        );\n        uint16 marketFeePct = _getMarketFeePct(_marketId);\n        uint16 protocolFeePct = _getProtocolFeePct();\n\n        uint256 commitmentPrincipalRequested = _commitmentArgs.principalAmount;\n        uint256 amountToMarketplace = commitmentPrincipalRequested.percent(\n            marketFeePct\n        );\n        uint256 amountToProtocol = commitmentPrincipalRequested.percent(\n            protocolFeePct\n        );\n\n        uint256 commitmentPrincipalReceived = commitmentPrincipalRequested -\n            amountToMarketplace -\n            amountToProtocol;\n\n        // by default, we will flash exactly what we need to do relayLoanFull\n        uint256 repayFullAmount = repayAmountOwed.principal +\n            repayAmountOwed.interest;\n\n        _flashAmount = repayFullAmount;\n        uint256 _flashLoanFee = _flashAmount.percent(_flashloanPremiumPct);\n\n        _borrowerAmount =\n            int256(commitmentPrincipalReceived) -\n            int256(repayFullAmount) -\n            int256(_flashLoanFee);\n    }\n\n    /**\n     * @notice Retrieves the market ID associated with a given commitment.\n     * @param _commitmentId The ID of the commitment for which to fetch the market ID.\n     * @return The ID of the market associated with the provided commitment.\n     */\n    function _getMarketIdForCommitment(address _lenderCommitmentForwarder, uint256 _commitmentId)\n        internal\n        view\n        returns (uint256)\n    {\n        return ILenderCommitmentForwarder(_lenderCommitmentForwarder).getCommitmentMarketId(_commitmentId);\n    }\n\n    /**\n     * @notice Fetches the marketplace fee percentage for a given market ID.\n     * @param _marketId The ID of the market for which to fetch the fee percentage.\n     * @return The marketplace fee percentage for the provided market ID.\n     */\n    function _getMarketFeePct(uint256 _marketId)\n        internal\n        view\n        returns (uint16)\n    {\n        address _marketRegistryAddress = ITellerV2Storage(address(TELLER_V2))\n            .marketRegistry();\n\n        return\n            IMarketRegistry(_marketRegistryAddress).getMarketplaceFee(\n                _marketId\n            );\n    }\n\n    /**\n     * @notice Fetches the protocol fee percentage from the Teller V2 protocol.\n     * @return The protocol fee percentage as defined in the Teller V2 protocol.\n     */\n    function _getProtocolFeePct() internal view returns (uint16) {\n        return IProtocolFee(address(TELLER_V2)).protocolFee();\n    }\n}"
    },
    {
      "filename": "teller-protocol-v2-audit-2024/packages/contracts/contracts/LenderCommitmentForwarder/extensions/FlashRolloverLoan_G5.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Contracts\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n// Interfaces\nimport \"../../interfaces/ITellerV2.sol\";\nimport \"../../interfaces/IProtocolFee.sol\";\nimport \"../../interfaces/ITellerV2Storage.sol\";\nimport \"../../interfaces/IMarketRegistry.sol\";\nimport \"../../interfaces/ILenderCommitmentForwarder.sol\";\nimport \"../../interfaces/ISmartCommitmentForwarder.sol\";\nimport \"../../interfaces/IFlashRolloverLoan_G4.sol\";\nimport \"../../libraries/NumbersLib.sol\";\n\nimport { IPool } from \"../../interfaces/aave/IPool.sol\";\nimport { IFlashLoanSimpleReceiver } from \"../../interfaces/aave/IFlashLoanSimpleReceiver.sol\";\nimport { IPoolAddressesProvider } from \"../../interfaces/aave/IPoolAddressesProvider.sol\";\n\ncontract FlashRolloverLoan_G5 is IFlashLoanSimpleReceiver, IFlashRolloverLoan_G4 {\n    using AddressUpgradeable for address;\n    using NumbersLib for uint256;\n\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    ITellerV2 public immutable TELLER_V2;\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    \n\n    address public immutable POOL_ADDRESSES_PROVIDER;\n\n    event RolloverLoanComplete(\n        address borrower,\n        uint256 originalLoanId,\n        uint256 newLoanId,\n        uint256 fundsRemaining\n    );\n\n    struct AcceptCommitmentArgs {\n        uint256 commitmentId;\n        address smartCommitmentAddress;  //if this is not address(0), we will use this ! leave empty if not used. \n        uint256 principalAmount;\n        uint256 collateralAmount;\n        uint256 collateralTokenId;\n        address collateralTokenAddress;\n        uint16 interestRate;\n        uint32 loanDuration;\n        bytes32[] merkleProof; //empty array if not used\n    }\n\n    /**\n     *\n     * @notice Initializes the FlashRolloverLoan with necessary contract addresses.\n     *\n     * @dev Using a custom OpenZeppelin upgrades tag. Ensure the constructor logic is safe for upgrades.\n     *\n     * @param _tellerV2 The address of the TellerV2 contract.\n     * @param _lenderCommitmentForwarder The address of the LenderCommitmentForwarder contract.\n     * @param _poolAddressesProvider The address of the PoolAddressesProvider.\n     */\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(\n        address _tellerV2,\n        address _poolAddressesProvider\n    ) {\n        TELLER_V2 = ITellerV2(_tellerV2);\n        POOL_ADDRESSES_PROVIDER = _poolAddressesProvider;\n    }\n\n    modifier onlyFlashLoanPool() {\n        require(\n            msg.sender == address(POOL()),\n            \"FlashRolloverLoan: Must be called by FlashLoanPool\"\n        );\n\n        _;\n    }\n\n    /**\n     *\n     * @notice Allows the borrower to rollover their existing loan using a flash loan mechanism.\n     *         The borrower might also provide an additional amount during the rollover.\n     *\n     * @dev The function first verifies that the caller is the borrower of the loan.\n     *      It then optionally transfers the additional amount specified by the borrower.\n     *      A flash loan is then taken from the pool to facilitate the rollover and\n     *      a callback is executed for further operations.\n     *\n     * @param _loanId Identifier of the existing loan to be rolled over.\n     * @param _flashLoanAmount Amount of flash loan to be borrowed for the rollover.\n     * @param _borrowerAmount Additional amount that the borrower may want to add during rollover.\n     * @param _acceptCommitmentArgs Commitment arguments that might be necessary for internal operations.\n     * \n     */\n    function rolloverLoanWithFlash(\n        address _lenderCommitmentForwarder,\n        uint256 _loanId,\n        uint256 _flashLoanAmount,\n        uint256 _borrowerAmount, //an additional amount borrower may have to add\n        AcceptCommitmentArgs calldata _acceptCommitmentArgs\n    ) external   {\n        address borrower = TELLER_V2.getLoanBorrower(_loanId);\n        require(borrower == msg.sender, \"CommitmentRolloverLoan: not borrower\");\n\n        // Get lending token and balance before\n        address lendingToken = TELLER_V2.getLoanLendingToken(_loanId);\n\n        if (_borrowerAmount > 0) {\n            IERC20(lendingToken).transferFrom(\n                borrower,\n                address(this),\n                _borrowerAmount\n            );\n        }\n\n        // Call 'Flash' on the vault to borrow funds and call tellerV2FlashCallback\n        // This ultimately calls executeOperation\n        IPool(POOL()).flashLoanSimple(\n            address(this),\n            lendingToken,\n            _flashLoanAmount,\n            abi.encode(\n                RolloverCallbackArgs({\n                    lenderCommitmentForwarder :_lenderCommitmentForwarder,\n                    loanId: _loanId,\n                    borrower: borrower,\n                    borrowerAmount: _borrowerAmount,\n                    acceptCommitmentArgs: abi.encode(_acceptCommitmentArgs)\n                })\n            ),\n            0 //referral code\n        );\n    }\n\n    /**\n     *\n     * @notice Callback function that is triggered by Aave during the flash loan process.\n     *         This function handles the logic to use the borrowed funds to rollover the loan,\n     *         make necessary repayments, and manage the loan commitments.\n     *\n     * @dev The function ensures the initiator is this contract, decodes the data provided by\n     *      the flash loan call, repays the original loan in full, accepts new loan commitments,\n     *      approves the repayment for the flash loan and then handles any remaining funds.\n     *      This function should only be called by the FlashLoanPool as ensured by the `onlyFlashLoanPool` modifier.\n     *\n     * @param _flashToken The token in which the flash loan is borrowed.\n     * @param _flashAmount The amount of tokens borrowed via the flash loan.\n     * @param _flashFees The fees associated with the flash loan to be repaid to Aave.\n     * @param _initiator The address initiating the flash loan (must be this contract).\n     * @param _data Encoded data containing necessary information for loan rollover.\n     *\n     * @return Returns true if the operation was successful.\n     */\n    function executeOperation(\n        address _flashToken,\n        uint256 _flashAmount,\n        uint256 _flashFees,\n        address _initiator,\n        bytes calldata _data\n    ) external virtual onlyFlashLoanPool returns (bool) {\n        require(\n            _initiator == address(this),\n            \"This contract must be the initiator\"\n        );\n\n        RolloverCallbackArgs memory _rolloverArgs = abi.decode(\n            _data,\n            (RolloverCallbackArgs)\n        );\n\n        uint256 repaymentAmount = _repayLoanFull(\n            _rolloverArgs.loanId,\n            _flashToken,\n            _flashAmount\n        );\n\n        AcceptCommitmentArgs memory acceptCommitmentArgs = abi.decode(\n            _rolloverArgs.acceptCommitmentArgs,\n            (AcceptCommitmentArgs)\n        );\n\n        // Accept commitment and receive funds to this contract\n\n        (uint256 newLoanId, uint256 acceptCommitmentAmount) = _acceptCommitment(\n            _rolloverArgs.lenderCommitmentForwarder,\n            _rolloverArgs.borrower,\n            _flashToken,\n            acceptCommitmentArgs\n        );\n\n        //approve the repayment for the flash loan\n        IERC20Upgradeable(_flashToken).approve(\n            address(POOL()),\n            _flashAmount + _flashFees\n        );\n\n        uint256 fundsRemaining = acceptCommitmentAmount +\n            _rolloverArgs.borrowerAmount -\n            repaymentAmount -\n            _flashFees;\n\n        if (fundsRemaining > 0) {\n            IERC20Upgradeable(_flashToken).transfer(\n                _rolloverArgs.borrower,\n                fundsRemaining\n            );\n        }\n\n        emit RolloverLoanComplete(\n            _rolloverArgs.borrower,\n            _rolloverArgs.loanId,\n            newLoanId,\n            fundsRemaining\n        );\n\n        return true;\n    }\n\n    /**\n     *\n     *\n     * @notice Internal function that repays a loan in full on behalf of this contract.\n     *\n     * @dev The function first calculates the funds held by the contract before repayment, then approves\n     *      the repayment amount to the TellerV2 contract and finally repays the loan in full.\n     *\n     * @param _bidId Identifier of the loan to be repaid.\n     * @param _principalToken The token in which the loan was originated.\n     * @param _repayAmount The amount to be repaid.\n     *\n     * @return repayAmount_ The actual amount that was used for repayment.\n     */\n    function _repayLoanFull(\n        uint256 _bidId,\n        address _principalToken,\n        uint256 _repayAmount\n    ) internal returns (uint256 repayAmount_) {\n        uint256 fundsBeforeRepayment = IERC20Upgradeable(_principalToken)\n            .balanceOf(address(this));\n\n        IERC20Upgradeable(_principalToken).approve(\n            address(TELLER_V2),\n            _repayAmount\n        );\n        TELLER_V2.repayLoanFull(_bidId);\n\n        uint256 fundsAfterRepayment = IERC20Upgradeable(_principalToken)\n            .balanceOf(address(this));\n\n        repayAmount_ = fundsBeforeRepayment - fundsAfterRepayment;\n    }\n\n    /**\n     *\n     *\n     * @notice Accepts a loan commitment using either a Merkle proof or standard method.\n     *\n     * @dev The function first checks if a Merkle proof is provided, based on which it calls the relevant\n     *      `acceptCommitment` function in the LenderCommitmentForwarder contract.\n     *\n     * @param borrower The address of the borrower for whom the commitment is being accepted.\n     * @param principalToken The token in which the loan is being accepted.\n     * @param _commitmentArgs The arguments necessary for accepting the commitment.\n     *\n     * @return bidId_ Identifier of the accepted loan.\n     * @return acceptCommitmentAmount_ The amount received from accepting the commitment.\n     */\n    function _acceptCommitment(\n        address lenderCommitmentForwarder,\n        address borrower,\n        address principalToken,\n        AcceptCommitmentArgs memory _commitmentArgs\n    )\n        internal\n        virtual\n        returns (uint256 bidId_, uint256 acceptCommitmentAmount_)\n    {\n        uint256 fundsBeforeAcceptCommitment = IERC20Upgradeable(principalToken)\n            .balanceOf(address(this));\n\n\n\n        if (_commitmentArgs.smartCommitmentAddress != address(0)) {\n\n             bytes memory responseData = address(lenderCommitmentForwarder)\n                    .functionCall(\n                        abi.encodePacked(\n                            abi.encodeWithSelector(\n                                ISmartCommitmentForwarder\n                                    .acceptSmartCommitmentWithRecipient\n                                    .selector,\n                                _commitmentArgs.smartCommitmentAddress,\n                                _commitmentArgs.principalAmount,\n                                _commitmentArgs.collateralAmount,\n                                _commitmentArgs.collateralTokenId,\n                                _commitmentArgs.collateralTokenAddress,\n                                address(this),\n                                _commitmentArgs.interestRate,\n                                _commitmentArgs.loanDuration\n                            ),\n                            borrower //cant be msg.sender because of the flash flow\n                        )\n                    );\n\n                (bidId_) = abi.decode(responseData, (uint256));\n\n\n        }else { \n\n            bool usingMerkleProof = _commitmentArgs.merkleProof.length > 0;\n\n            if (usingMerkleProof) {\n                bytes memory responseData = address(lenderCommitmentForwarder)\n                    .functionCall(\n                        abi.encodePacked(\n                            abi.encodeWithSelector(\n                                ILenderCommitmentForwarder\n                                    .acceptCommitmentWithRecipientAndProof\n                                    .selector,\n                                _commitmentArgs.commitmentId,\n                                _commitmentArgs.principalAmount,\n                                _commitmentArgs.collateralAmount,\n                                _commitmentArgs.collateralTokenId,\n                                _commitmentArgs.collateralTokenAddress,\n                                address(this),\n                                _commitmentArgs.interestRate,\n                                _commitmentArgs.loanDuration,\n                                _commitmentArgs.merkleProof\n                            ),\n                            borrower //cant be msg.sender because of the flash flow\n                        )\n                    );\n\n                (bidId_) = abi.decode(responseData, (uint256));\n            } else {\n                bytes memory responseData = address(lenderCommitmentForwarder)\n                    .functionCall(\n                        abi.encodePacked(\n                            abi.encodeWithSelector(\n                                ILenderCommitmentForwarder\n                                    .acceptCommitmentWithRecipient\n                                    .selector,\n                                _commitmentArgs.commitmentId,\n                                _commitmentArgs.principalAmount,\n                                _commitmentArgs.collateralAmount,\n                                _commitmentArgs.collateralTokenId,\n                                _commitmentArgs.collateralTokenAddress,\n                                address(this),\n                                _commitmentArgs.interestRate,\n                                _commitmentArgs.loanDuration\n                            ),\n                            borrower //cant be msg.sender because of the flash flow\n                        )\n                    );\n\n                (bidId_) = abi.decode(responseData, (uint256));\n            }\n\n        }\n\n        uint256 fundsAfterAcceptCommitment = IERC20Upgradeable(principalToken)\n            .balanceOf(address(this));\n        acceptCommitmentAmount_ =\n            fundsAfterAcceptCommitment -\n            fundsBeforeAcce"
    }
  ]
}