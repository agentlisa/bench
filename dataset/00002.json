{
  "Title": "M-2: PerAddressTrancheVestingMerkleDistributor.claim always reverts because it checks the Merkle proof incorrectly",
  "Content": "# Issue M-2: PerAddressTrancheVestingMerkleDistributor.claim always reverts because it checks the Merkle proof incorrectly \n\nSource: https://github.com/sherlock-audit/2024-05-tokensoft-distributor-contracts-update-judging/issues/15 \n\n## Found by \njkoppel, samuraii77\n## Summary\n\nBoth the `claim` and `initializeDistributionRecord` methods of PerAddressTrancheVestingMerkleDistributor do not include the tranches when checking the Merkle proof (and do not even accept the tranches as a parameter). Both methods therefore always revert, before the function body is even entered.\n\n## Vulnerability Detail\n\nWe know from PerAddressTrancheVestingMerkle that the Merkle trees for this kind of distributor include the list of tranches for each address (and also because they have to be; there's no other way to specify the tranches). However,  PerAddressTrancheVestingMerkleDistributor omits the tranches when checking the Merkle proofs. The Merkle proofs therefore always revert.\n\n## Impact\n\nPerAddressTrancheVestingMerkleDistributor is completely inoperable.\n\n## Code Snippet\n\nNotice the lack of tranches here:\n\nhttps://github.com/sherlock-audit/2024-05-tokensoft-distributor-contracts-update/blob/main/contracts/packages/hardhat/contracts/claim/factory/PerAddressTrancheVestingMerkleDistributor.sol#L42-L58\n\n```solidity\n    function initializeDistributionRecord(\n        uint256 index, // the beneficiary's index in the merkle root\n        address beneficiary, // the address that will receive tokens\n        uint256 amount, // the total claimable by this beneficiary\n        bytes32[] calldata merkleProof\n    ) external validMerkleProof(keccak256(abi.encodePacked(index, beneficiary, amount)), merkleProof) {\n        _initializeDistributionRecord(beneficiary, amount);\n    }\n\n    function claim(\n        uint256 index, // the beneficiary's index in the merkle root\n        address beneficiary, // the address that will receive tokens\n        uint256 totalAmount, // the total claimable by this beneficiary\n        bytes32[] calldata merkleProof\n    )\n        external\n        validMerkleProof(keccak256(abi.encodePacked(index, beneficiary, totalAmount)), merkleProof)\n```\n\nContrast the code in PerAddressTrancheVestingMerkle, which checks the Merkle proof like this:\n\nhttps://github.com/sherlock-audit/2024-05-tokensoft-distributor-contracts-update/blob/main/contracts/packages/hardhat/contracts/claim/PerAddressTrancheVestingMerkle.sol#L45\n\n```solidity\n    validMerkleProof(keccak256(abi.encodePacked(index, beneficiary, amount, abi.encode(tranches))), merkleProof)\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAdd the tranches parameter to both methods and check in the Merkle proof\n\n\n\n## Discussion\n\n**ArshaanB**\n\nYes, `tranches` should be passed to `validMerkleProof()` in order to properly validate for these two functions in `PerAddressTrancheVestingMerkleDistributor.sol`.\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/285",
  "Code": [
    {
      "filename": "contracts/packages/hardhat/contracts/claim/factory/PerAddressTrancheVestingMerkleDistributor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./PerAddressTrancheVestingInitializable.sol\";\nimport \"./MerkleSetInitializable.sol\";\n\ncontract PerAddressTrancheVestingMerkleDistributor is\n    Initializable,\n    PerAddressTrancheVestingInitializable,\n    MerkleSetInitializable\n{\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        IERC20 _token, // the token being claimed\n        uint256 _total, // the total claimable by all users\n        string memory _uri, // information on the sale (e.g. merkle proofs)\n        bytes32 _merkleRoot, // the merkle root for claim membership (also used as salt for the fair queue delay time),\n        uint160 _maxDelayTime, // the maximum delay time for the fair queue\n        address _owner\n    ) public initializer {\n        __PerAddressTrancheVesting_init(_token, _total, _uri, _maxDelayTime, uint160(uint256(_merkleRoot)), _owner);\n\n        __MerkleSet_init(_merkleRoot);\n\n        _transferOwnership(_owner);\n    }\n\n    function NAME() external pure override returns (string memory) {\n        return \"PerAddressTrancheVestingMerkleDistributor\";\n    }\n\n    function VERSION() external pure override returns (uint256) {\n        return 3;\n    }\n\n    function initializeDistributionRecord(\n        uint256 index, // the beneficiary's index in the merkle root\n        address beneficiary, // the address that will receive tokens\n        uint256 amount, // the total claimable by this beneficiary\n        bytes32[] calldata merkleProof\n    ) external validMerkleProof(keccak256(abi.encodePacked(index, beneficiary, amount)), merkleProof) {\n        _initializeDistributionRecord(beneficiary, amount);\n    }\n\n    function claim(\n        uint256 index, // the beneficiary's index in the merkle root\n        address beneficiary, // the address that will receive tokens\n        uint256 totalAmount, // the total claimable by this beneficiary\n        bytes32[] calldata merkleProof\n    )\n        external\n        validMerkleProof(keccak256(abi.encodePacked(index, beneficiary, totalAmount)), merkleProof)\n        nonReentrant\n    {\n        // effects\n        uint256 claimedAmount = _executeClaim(beneficiary, totalAmount, new bytes(0));\n        // interactions\n        _settleClaim(beneficiary, claimedAmount);\n    }\n\n    function setMerkleRoot(bytes32 _merkleRoot) external onlyOwner {\n        _setMerkleRoot(_merkleRoot);\n    }\n}"
    },
    {
      "filename": "contracts/packages/hardhat/contracts/claim/PerAddressTrancheVestingMerkle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport { PerAddressTrancheVesting, Tranche } from './abstract/PerAddressTrancheVesting.sol';\nimport { MerkleSet } from './abstract/MerkleSet.sol';\n\ncontract PerAddressTrancheVestingMerkle is PerAddressTrancheVesting, MerkleSet {\n  constructor(\n    IERC20 _token,\n    uint256 _total,\n    string memory _uri, // information on the sale (e.g. merkle proofs)\n    uint256 _voteFactor,\n    bytes32 _merkleRoot,\n    uint160 _maxDelayTime // the maximum delay time for the fair queue\n  )\n    PerAddressTrancheVesting(\n      _token,\n      _total,\n      _uri,\n      _voteFactor,\n      _maxDelayTime,\n      uint160(uint256(_merkleRoot))\n    )\n    MerkleSet(_merkleRoot)\n  {}\n\n  function NAME() external pure override returns (string memory) {\n    return 'PerAddressTrancheVestingMerkle';\n  }\n\n  function VERSION() external pure override returns (uint256) {\n    return 4;\n  }\n\n  function initializeDistributionRecord(\n    uint256 index, // the beneficiary's index in the merkle root\n    address beneficiary, // the address that will receive tokens\n    uint256 amount, // the total claimable by this beneficiary\n    Tranche[] calldata tranches, // the tranches for the beneficiary (users can have different vesting schedules)\n    bytes32[] calldata merkleProof\n  )\n    external\n    validMerkleProof(keccak256(abi.encodePacked(index, beneficiary, amount, abi.encode(tranches))), merkleProof)\n  {\n    _initializeDistributionRecord(beneficiary, amount);\n  }\n\n  function claim(\n    uint256 index, // the beneficiary's index in the merkle root\n    address beneficiary, // the address that will receive tokens\n    uint256 totalAmount, // the total claimable by this beneficiary\n    // TODO: should we be providing the tranches already abi encoded to save gas?\n    Tranche[] calldata tranches, // the tranches for the beneficiary (users can have different vesting schedules)\n    bytes32[] calldata merkleProof\n  )\n    external\n    validMerkleProof(keccak256(abi.encodePacked(index, beneficiary, totalAmount, abi.encode(tranches))), merkleProof)\n    nonReentrant\n  {\n    bytes memory data = abi.encode(tranches);\n    // effects\n    uint256 claimedAmount = _executeClaim(beneficiary, totalAmount, data);\n    // interactions\n    _settleClaim(beneficiary, claimedAmount);\n  }\n\n  function setMerkleRoot(bytes32 _merkleRoot) external onlyOwner {\n    _setMerkleRoot(_merkleRoot);\n  }\n}"
    }
  ]
}