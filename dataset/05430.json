{
  "Title": "[M-10] Wrong ProfitManager in GuildToken, will always revert for other types of gauges leading to bad debt",
  "Content": "\n### Line of code\n\n<https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/2376d9af792584e3d15ec9c32578daa33bb56b43/src/tokens/GuildToken.sol#L41>\n\n### Impact\n\nIn `GuildToken.sol`, there's a mistake where `profitManager` is set in the constructor. This is problematic because different markets have different `ProfitManagers`, and the logic was initially designed for only one market (e.g., gUSDC). As a result, calling `notifyPnL()` with negative value (via `forgive()`or `onBid()` in other type of terms (e.g. gWETH)), it triggers `GuildToken::notifyGaugeLoss()`. However, this always results in a revert for other term types because the caller is the ProfitManager of that type, whereas `GuildToken::notifyGaugeLoss()` expects the one set in the constructor.\n\nAs a result, this means that loans from other markets won't be removed unless users repay them, resulting in bad debt for the protocol.\n\n[GuildToken::`notifyGaugeLoss()`](https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/2376d9af792584e3d15ec9c32578daa33bb56b43/src/tokens/GuildToken.sol#L123-L129)\n\n```solidity\nfunction notifyGaugeLoss(address gauge) external {\n    require(msg.sender == profitManager, \"UNAUTHORIZED\");\n\n    // save gauge loss\n    lastGaugeLoss[gauge] = block.timestamp;\n    emit GaugeLoss(gauge, block.timestamp);\n}\n```\n\n**Note:** It's using this `profitManager` in other parts of `GuildToken`, but it has nothing to do with the attack, and it doesn't cause any impact. However, we show how to fix it in the recommendation section. Because the `profitManager` should be removed altogether and always called dynamically based on the passed gauge.\n\n### Proof of Concept\n\nConditions:\n\n- 2+ market (gUSDC, gWETH, etc).\n- Negative `notifyPnL()` (via `forgive()` or `onBid()`).\n\n### Coded PoC\n\nFirstly, you need to add additional variables for other term type and include them in the `setUp()`.\n\nModify `SurplusGuildMinter.t.sol` as shown:\n\n<details>\n\n```diff\ncontract SurplusGuildMinterUnitTest is Test {\n    address private governor = address(1);\n    address private guardian = address(2);\n    address private term;\n+   address private termWETH;\n    Core private core;\n    ProfitManager private profitManager;\n+   ProfitManager private profitManagerWETH;\n    CreditToken credit;\n+   CreditToken creditWETH;\n    GuildToken guild;\n    RateLimitedMinter rlgm;\n    SurplusGuildMinter sgm;\n\n    // GuildMinter params\n    uint256 constant MINT_RATIO = 2e18;\n    uint256 constant REWARD_RATIO = 5e18;\n\n    function setUp() public {\n        vm.warp(1679067867);\n        vm.roll(16848497);\n        core = new Core();\n\n        profitManager = new ProfitManager(address(core));\n+       profitManagerWETH = new ProfitManager(address(core));\n        credit = new CreditToken(address(core), \"name\", \"symbol\");\n+       creditWETH = new CreditToken(address(core), \"WETH\", \"WETH\");\n        guild = new GuildToken(address(core), address(profitManager));\n        rlgm = new RateLimitedMinter(\n            address(core), /*_core*/\n            address(guild), /*_token*/\n            CoreRoles.RATE_LIMITED_GUILD_MINTER, /*_role*/\n            type(uint256).max, /*_maxRateLimitPerSecond*/\n            type(uint128).max, /*_rateLimitPerSecond*/\n            type(uint128).max /*_bufferCap*/\n        );\n        sgm = new SurplusGuildMinter(\n            address(core),\n            address(profitManager),\n            address(credit),\n            address(guild),\n            address(rlgm),\n            MINT_RATIO,\n            REWARD_RATIO\n        );\n        profitManager.initializeReferences(address(credit), address(guild), address(0));\n+       profitManagerWETH.initializeReferences(address(creditWETH), address(guild), address(0));\n        term = address(new MockLendingTerm(address(core)));\n+       termWETH = address(new MockLendingTerm(address(core)));\n\n        // roles\n        core.grantRole(CoreRoles.GOVERNOR, governor);\n        core.grantRole(CoreRoles.GUARDIAN, guardian);\n        core.grantRole(CoreRoles.CREDIT_MINTER, address(this));\n        core.grantRole(CoreRoles.GUILD_MINTER, address(this));\n        core.grantRole(CoreRoles.GAUGE_ADD, address(this));\n        core.grantRole(CoreRoles.GAUGE_REMOVE, address(this));\n        core.grantRole(CoreRoles.GAUGE_PARAMETERS, address(this));\n        core.grantRole(CoreRoles.GUILD_MINTER, address(rlgm));\n        core.grantRole(CoreRoles.RATE_LIMITED_GUILD_MINTER, address(sgm));\n        core.grantRole(CoreRoles.RATE_LIMITED_GUILD_MINTER, address(sgmWETH));\n        core.grantRole(CoreRoles.GUILD_SURPLUS_BUFFER_WITHDRAW, address(sgm));\n        core.grantRole(CoreRoles.GAUGE_PNL_NOTIFIER, address(this));\n        core.renounceRole(CoreRoles.GOVERNOR, address(this));\n\n        // add gauge and vote for it\n        guild.setMaxGauges(10);\n        guild.addGauge(1, term);\n        guild.mint(address(this), 50e18);\n        guild.incrementGauge(term, uint112(50e18));\n\n+       guild.addGauge(2, termWETH);\n\n        // labels\n        vm.label(address(core), \"core\");\n        vm.label(address(profitManager), \"profitManager\");\n        vm.label(address(credit), \"credit\");\n        vm.label(address(guild), \"guild\");\n        vm.label(address(rlgm), \"rlcgm\");\n        vm.label(address(sgm), \"sgm\");\n        vm.label(term, \"term\");\n    }\n\n...\n}\n```\n\n</details>\n\nPlace the test in the same `SurplusGuildMinter.t.sol` and run with:\n\n```\nforge test --match-contract \"SurplusGuildMinterUnitTest\" --match-test \"testNotifyPnLCannotBeCalledWithNegative\"\n```\n\n```solidity\nfunction testNotifyPnLCannotBeCalledWithNegative() public {\n    // Show that for the initial gUSDC term there is no problem.\n    credit.mint(address(profitManager), 10);\n    profitManager.notifyPnL(term, -1);\n\n    creditWETH.mint(address(profitManagerWETH), 10);\n    vm.expectRevert(\"UNAUTHORIZED\");\n    profitManagerWETH.notifyPnL(termWETH, -1);\n}\n```\n\n### Recommended Mitigation Steps\n\nIn GuildToken.sol, `ProfitManager` needs to be dynamically called, because there will be different `ProfitManager` for each market.\n\nSince the caller of the `notifyGaugeLoss()` needs to be the `profitManager` of the passed gauge, here is the refactored logic:\n\n```diff\nfunction notifyGaugeLoss(address gauge) external {\n+   address gaugeProfitManager = LendingTerm(gauge).getReferences().profitManager;\n+   require(msg.sender == gaugeProfitManager, \"UNAUTHORIZED\");\n-   require(msg.sender == profitManager, \"UNAUTHORIZED\");\n\n    // save gauge loss\n    lastGaugeLoss[gauge] = block.timestamp;\n    emit GaugeLoss(gauge, block.timestamp);\n}\n```\n\nYou should also rework `_decrementGaugeWeight()` and `_incrementGaugeWeight()` as follows:\n\n```diff\nfunction _decrementGaugeWeight(\n    address user,\n    address gauge,\n    uint256 weight\n) internal override {\n    uint256 _lastGaugeLoss = lastGaugeLoss[gauge];\n    uint256 _lastGaugeLossApplied = lastGaugeLossApplied[gauge][user];\n    require(\n        _lastGaugeLossApplied >= _lastGaugeLoss,\n        \"GuildToken: pending loss\"\n    );\n\n    // update the user profit index and claim rewards\n-   ProfitManager(profitManager).claimGaugeRewards(user, gauge);\n+   address gaugeProfitManager = LendingTerm(gauge).getReferences().profitManager;\n+   ProfitManager(gaugeProfitManager).claimGaugeRewards(user, gauge);\n\n    // check if gauge is currently using its allocated debt ceiling.\n    // To decrement gauge weight, guild holders might have to call loans if the debt ceiling is used.\n    uint256 issuance = LendingTerm(gauge).issuance();\n    if (issuance != 0) {\n        uint256 debtCeilingAfterDecrement = LendingTerm(gauge).debtCeiling(-int256(weight));\n        require(\n            issuance <= debtCeilingAfterDecrement,\n            \"GuildToken: debt ceiling used\"\n        );\n    }\n\n    super._decrementGaugeWeight(user, gauge, weight);\n}\n```\n\n```diff\nfunction _incrementGaugeWeight(\n    address user,\n    address gauge,\n    uint256 weight\n) internal override {\n    uint256 _lastGaugeLoss = lastGaugeLoss[gauge];\n    uint256 _lastGaugeLossApplied = lastGaugeLossApplied[gauge][user];\n    if (getUserGaugeWeight[user][gauge] == 0) {\n        lastGaugeLossApplied[gauge][user] = block.timestamp;\n    } else {\n        require(\n            _lastGaugeLossApplied >= _lastGaugeLoss,\n            \"GuildToken: pending loss\"\n        );\n    }\n\n-   ProfitManager(profitManager).claimGaugeRewards(user, gauge);\n+   address gaugeProfitManager = LendingTerm(gauge).getReferences().profitManager;\n+   ProfitManager(gaugeProfitManager).claimGaugeRewards(user, gauge);\n\n    super._incrementGaugeWeight(user, gauge, weight);\n}\n```\n\n### Assessed type\n\nDoS\n\n**[eswak (Ethereum Credit Guild) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/1001#issuecomment-1894007227):**\n > Confirming, I think the fix will look like this: \n> \n> *Note: to view the provided image, please see the original comment [here](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/1001#issuecomment-1894007227).*\n> \n> I'd argue no user funds are at risk (this would be detected upon deployment of a 2nd market, before users can use it) so this is more fit for Medium.\n\n**[TrungOre (judge) decreased severity to Medium](https://github.com/code-423n4/2023-12-ethereumcreditguild-findings/issues/1001#issuecomment-1915615340)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-12-ethereumcreditguild",
  "Code": [
    {
      "filename": "src/tokens/GuildToken.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {ERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\nimport {ERC20Burnable} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport {CoreRef} from \"@src/core/CoreRef.sol\";\nimport {CoreRoles} from \"@src/core/CoreRoles.sol\";\nimport {LendingTerm} from \"@src/loan/LendingTerm.sol\";\nimport {ERC20Gauges} from \"@src/tokens/ERC20Gauges.sol\";\nimport {ProfitManager} from \"@src/governance/ProfitManager.sol\";\nimport {ERC20MultiVotes} from \"@src/tokens/ERC20MultiVotes.sol\";\n\n/** \n@title  GUILD ERC20 Token\n@author eswak\n@notice This is the governance token of the Ethereum Credit Guild.\n    On deploy, this token is non-transferrable.\n    During the non-transferrable period, GUILD can still be minted & burnt, only\n    `transfer` and `transferFrom` are reverting.\n\n    The gauge system is used to define debt ceilings on a set of lending terms.\n    Lending terms can be whitelisted by adding a gauge for their address, if GUILD\n    holders vote for these lending terms in the gauge system, the lending terms will\n    have a non-zero debt ceiling, and borrowing will be available under these terms.\n\n    When a lending term creates bad debt, a loss is notified in a gauge on this\n    contract (`notifyGaugeLoss`). When a loss is notified, all the GUILD token weight voting\n    for this gauge becomes non-transferable and can be permissionlessly slashed. Until the\n    loss is realized (`applyGaugeLoss`), a user cannot transfer their locked tokens or\n    decrease the weight they assign to the gauge that suffered a loss.\n    Even when a loss occur, users can still transfer tokens with which they vote for gauges\n    that did not suffer a loss.\n*/\ncontract GuildToken is CoreRef, ERC20Burnable, ERC20Gauges, ERC20MultiVotes {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @notice reference to ProfitManager\n    address public profitManager;\n\n    constructor(\n        address _core,\n        address _profitManager\n    )\n        CoreRef(_core)\n        ERC20(\"Ethereum Credit Guild - GUILD\", \"GUILD\")\n        ERC20Permit(\"Ethereum Credit Guild - GUILD\")\n    {\n        profitManager = _profitManager;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        VOTING MANAGEMENT\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Set `maxDelegates`, the maximum number of addresses any account can delegate voting power to.\n    function setMaxDelegates(\n        uint256 newMax\n    ) external onlyCoreRole(CoreRoles.GUILD_GOVERNANCE_PARAMETERS) {\n        _setMaxDelegates(newMax);\n    }\n\n    /// @notice Allow or disallow an address to delegate voting power to more addresses than `maxDelegates`.\n    function setContractExceedMaxDelegates(\n        address account,\n        bool canExceedMax\n    ) external onlyCoreRole(CoreRoles.GUILD_GOVERNANCE_PARAMETERS) {\n        _setContractExceedMaxDelegates(account, canExceedMax);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        GAUGE MANAGEMENT\n    //////////////////////////////////////////////////////////////*/\n    function addGauge(\n        uint256 _type,\n        address gauge\n    ) external onlyCoreRole(CoreRoles.GAUGE_ADD) returns (uint256) {\n        return _addGauge(_type, gauge);\n    }\n\n    function removeGauge(\n        address gauge\n    ) external onlyCoreRole(CoreRoles.GAUGE_REMOVE) {\n        _removeGauge(gauge);\n    }\n\n    function setMaxGauges(\n        uint256 max\n    ) external onlyCoreRole(CoreRoles.GAUGE_PARAMETERS) {\n        _setMaxGauges(max);\n    }\n\n    function setCanExceedMaxGauges(\n        address who,\n        bool can\n    ) external onlyCoreRole(CoreRoles.GAUGE_PARAMETERS) {\n        _setCanExceedMaxGauges(who, can);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        LOSS MANAGEMENT\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice emitted when a loss in a gauge is notified.\n    event GaugeLoss(address indexed gauge, uint256 indexed when);\n    /// @notice emitted when a loss in a gauge is applied (for each user).\n    event GaugeLossApply(\n        address indexed gauge,\n        address indexed who,\n        uint256 weight,\n        uint256 when\n    );\n\n    /// @notice last block.timestamp when a loss occurred in a given gauge\n    mapping(address => uint256) public lastGaugeLoss;\n\n    /// @notice last block.timestamp when a user apply a loss that occurred in a given gauge\n    mapping(address => mapping(address => uint256)) public lastGaugeLossApplied;\n\n    /// @notice notify loss in a given gauge\n    function notifyGaugeLoss(address gauge) external {\n        require(msg.sender == profitManager, \"UNAUTHORIZED\");\n\n        // save gauge loss\n        lastGaugeLoss[gauge] = block.timestamp;\n        emit GaugeLoss(gauge, block.timestamp);\n    }\n\n    /// @notice apply a loss that occurred in a given gauge\n    /// anyone can apply the loss on behalf of anyone else\n    function applyGaugeLoss(address gauge, address who) external {\n        // check preconditions\n        uint256 _lastGaugeLoss = lastGaugeLoss[gauge];\n        uint256 _lastGaugeLossApplied = lastGaugeLossApplied[gauge][who];\n        require(\n            _lastGaugeLoss != 0 && _lastGaugeLossApplied < _lastGaugeLoss,\n            \"GuildToken: no loss to apply\"\n        );\n\n        // read user weight allocated to the lossy gauge\n        uint256 _userGaugeWeight = getUserGaugeWeight[who][gauge];\n\n        // remove gauge weight allocation\n        lastGaugeLossApplied[gauge][who] = block.timestamp;\n        _decrementGaugeWeight(who, gauge, _userGaugeWeight);\n        if (!_deprecatedGauges.contains(gauge)) {\n            totalTypeWeight[gaugeType[gauge]] -= _userGaugeWeight;\n            totalWeight -= _userGaugeWeight;\n        }\n\n        // apply loss\n        _burn(who, uint256(_userGaugeWeight));\n        emit GaugeLossApply(\n            gauge,\n            who,\n            uint256(_userGaugeWeight),\n            block.timestamp\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        TRANSFERABILITY\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice at deployment, tokens are not transferable (can only mint/burn).\n    /// Governance can enable transfers with `enableTransfers()`.\n    bool public transferable; // default = false\n\n    /// @notice emitted when transfers are enabled.\n    event TransfersEnabled(uint256 block, uint256 timestamp);\n\n    /// @notice permanently enable token transfers.\n    function enableTransfer() external onlyCoreRole(CoreRoles.GOVERNOR) {\n        transferable = true;\n        emit TransfersEnabled(block.number, block.timestamp);\n    }\n\n    /// @dev prevent transfers if they are not globally enabled.\n    /// mint and burn (transfers to and from address 0) are accepted.\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 /* amount*/\n    ) internal view override {\n        require(\n            transferable || from == address(0) || to == address(0),\n            \"GuildToken: transfers disabled\"\n        );\n    }\n\n    /// @notice emitted when reference to ProfitManager is updated\n    event ProfitManagerUpdated(uint256 timestamp, address newValue);\n\n    /// @notice set reference to ProfitManager\n    function setProfitManager(address _newProfitManager) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        profitManager = _newProfitManager;\n        emit ProfitManagerUpdated(block.timestamp, _newProfitManager);\n    }\n\n    /// @dev prevent outbound token transfers (_decrementWeightUntilFree) and gauge weight decrease\n    /// (decrementGauge, decrementGauges) for users who have an unrealized loss in a gauge, or if the\n    /// gauge is currently using its allocated debt ceiling. To decrement gauge weight, guild holders\n    /// might have to call loans if the debt ceiling is used.\n    /// Also update the user profit index and claim rewards.\n    function _decrementGaugeWeight(\n        address user,\n        address gauge,\n        uint256 weight\n    ) internal override {\n        uint256 _lastGaugeLoss = lastGaugeLoss[gauge];\n        uint256 _lastGaugeLossApplied = lastGaugeLossApplied[gauge][user];\n        require(\n            _lastGaugeLossApplied >= _lastGaugeLoss,\n            \"GuildToken: pending loss\"\n        );\n\n        // update the user profit index and claim rewards\n        ProfitManager(profitManager).claimGaugeRewards(user, gauge);\n\n        // check if gauge is currently using its allocated debt ceiling.\n        // To decrement gauge weight, guild holders might have to call loans if the debt ceiling is used.\n        uint256 issuance = LendingTerm(gauge).issuance();\n        if (issuance != 0) {\n            uint256 debtCeilingAfterDecrement = LendingTerm(gauge).debtCeiling(-int256(weight));\n            require(\n                issuance <= debtCeilingAfterDecrement,\n                \"GuildToken: debt ceiling used\"\n            );\n        }\n\n        super._decrementGaugeWeight(user, gauge, weight);\n    }\n\n    /// @dev prevent weight increment for gauge if user has an unapplied loss.\n    /// If the user has 0 weight (i.e. no loss to realize), allow incrementing\n    /// gauge weight & update lastGaugeLossApplied to current time.\n    /// Also update the user profit index an claim rewards.\n    /// @dev note that users voting for a gauge that is not a proper lending term could result in this\n    /// share of the user's tokens to be frozen, due to being unable to decrement weight.\n    function _incrementGaugeWeight(\n        address user,\n        address gauge,\n        uint256 weight\n    ) internal override {\n        uint256 _lastGaugeLoss = lastGaugeLoss[gauge];\n        uint256 _lastGaugeLossApplied = lastGaugeLossApplied[gauge][user];\n        if (getUserGaugeWeight[user][gauge] == 0) {\n            lastGaugeLossApplied[gauge][user] = block.timestamp;\n        } else {\n            require(\n                _lastGaugeLossApplied >= _lastGaugeLoss,\n                \"GuildToken: pending loss\"\n            );\n        }\n\n        ProfitManager(profitManager).claimGaugeRewards(user, gauge);\n\n        super._incrementGaugeWeight(user, gauge, weight);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        MINT / BURN\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice mint new tokens to the target address\n    function mint(\n        address to,\n        uint256 amount\n    ) external onlyCoreRole(CoreRoles.GUILD_MINTER) {\n        _mint(to, amount);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        Inheritance reconciliation\n    //////////////////////////////////////////////////////////////*/\n\n    function _burn(\n        address from,\n        uint256 amount\n    ) internal virtual override(ERC20, ERC20Gauges, ERC20MultiVotes) {\n        _decrementWeightUntilFree(from, amount);\n        _decrementVotesUntilFree(from, amount);\n        ERC20._burn(from, amount);\n    }\n\n    function transfer(\n        address to,\n        uint256 amount\n    )\n        public\n        virtual\n        override(ERC20, ERC20Gauges, ERC20MultiVotes)\n        returns (bool)\n    {\n        _decrementWeightUntilFree(msg.sender, amount);\n        _decrementVotesUntilFree(msg.sender, amount);\n        return ERC20.transfer(to, amount);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    )\n        public\n        virtual\n        override(ERC20, ERC20Gauges, ERC20MultiVotes)\n        returns (bool)\n    {\n        _decrementWeightUntilFree(from, amount);\n        _decrementVotesUntilFree(from, amount);\n        return ERC20.transferFrom(from, to, amount);\n    }\n}"
    },
    {
      "filename": "src/tokens/GuildToken.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {ERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\nimport {ERC20Burnable} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport {CoreRef} from \"@src/core/CoreRef.sol\";\nimport {CoreRoles} from \"@src/core/CoreRoles.sol\";\nimport {LendingTerm} from \"@src/loan/LendingTerm.sol\";\nimport {ERC20Gauges} from \"@src/tokens/ERC20Gauges.sol\";\nimport {ProfitManager} from \"@src/governance/ProfitManager.sol\";\nimport {ERC20MultiVotes} from \"@src/tokens/ERC20MultiVotes.sol\";\n\n/** \n@title  GUILD ERC20 Token\n@author eswak\n@notice This is the governance token of the Ethereum Credit Guild.\n    On deploy, this token is non-transferrable.\n    During the non-transferrable period, GUILD can still be minted & burnt, only\n    `transfer` and `transferFrom` are reverting.\n\n    The gauge system is used to define debt ceilings on a set of lending terms.\n    Lending terms can be whitelisted by adding a gauge for their address, if GUILD\n    holders vote for these lending terms in the gauge system, the lending terms will\n    have a non-zero debt ceiling, and borrowing will be available under these terms.\n\n    When a lending term creates bad debt, a loss is notified in a gauge on this\n    contract (`notifyGaugeLoss`). When a loss is notified, all the GUILD token weight voting\n    for this gauge becomes non-transferable and can be permissionlessly slashed. Until the\n    loss is realized (`applyGaugeLoss`), a user cannot transfer their locked tokens or\n    decrease the weight they assign to the gauge that suffered a loss.\n    Even when a loss occur, users can still transfer tokens with which they vote for gauges\n    that did not suffer a loss.\n*/\ncontract GuildToken is CoreRef, ERC20Burnable, ERC20Gauges, ERC20MultiVotes {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @notice reference to ProfitManager\n    address public profitManager;\n\n    constructor(\n        address _core,\n        address _profitManager\n    )\n        CoreRef(_core)\n        ERC20(\"Ethereum Credit Guild - GUILD\", \"GUILD\")\n        ERC20Permit(\"Ethereum Credit Guild - GUILD\")\n    {\n        profitManager = _profitManager;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        VOTING MANAGEMENT\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Set `maxDelegates`, the maximum number of addresses any account can delegate voting power to.\n    function setMaxDelegates(\n        uint256 newMax\n    ) external onlyCoreRole(CoreRoles.GUILD_GOVERNANCE_PARAMETERS) {\n        _setMaxDelegates(newMax);\n    }\n\n    /// @notice Allow or disallow an address to delegate voting power to more addresses than `maxDelegates`.\n    function setContractExceedMaxDelegates(\n        address account,\n        bool canExceedMax\n    ) external onlyCoreRole(CoreRoles.GUILD_GOVERNANCE_PARAMETERS) {\n        _setContractExceedMaxDelegates(account, canExceedMax);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        GAUGE MANAGEMENT\n    //////////////////////////////////////////////////////////////*/\n    function addGauge(\n        uint256 _type,\n        address gauge\n    ) external onlyCoreRole(CoreRoles.GAUGE_ADD) returns (uint256) {\n        return _addGauge(_type, gauge);\n    }\n\n    function removeGauge(\n        address gauge\n    ) external onlyCoreRole(CoreRoles.GAUGE_REMOVE) {\n        _removeGauge(gauge);\n    }\n\n    function setMaxGauges(\n        uint256 max\n    ) external onlyCoreRole(CoreRoles.GAUGE_PARAMETERS) {\n        _setMaxGauges(max);\n    }\n\n    function setCanExceedMaxGauges(\n        address who,\n        bool can\n    ) external onlyCoreRole(CoreRoles.GAUGE_PARAMETERS) {\n        _setCanExceedMaxGauges(who, can);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        LOSS MANAGEMENT\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice emitted when a loss in a gauge is notified.\n    event GaugeLoss(address indexed gauge, uint256 indexed when);\n    /// @notice emitted when a loss in a gauge is applied (for each user).\n    event GaugeLossApply(\n        address indexed gauge,\n        address indexed who,\n        uint256 weight,\n        uint256 when\n    );\n\n    /// @notice last block.timestamp when a loss occurred in a given gauge\n    mapping(address => uint256) public lastGaugeLoss;\n\n    /// @notice last block.timestamp when a user apply a loss that occurred in a given gauge\n    mapping(address => mapping(address => uint256)) public lastGaugeLossApplied;\n\n    /// @notice notify loss in a given gauge\n    function notifyGaugeLoss(address gauge) external {\n        require(msg.sender == profitManager, \"UNAUTHORIZED\");\n\n        // save gauge loss\n        lastGaugeLoss[gauge] = block.timestamp;\n        emit GaugeLoss(gauge, block.timestamp);\n    }\n\n    /// @notice apply a loss that occurred in a given gauge\n    /// anyone can apply the loss on behalf of anyone else\n    function applyGaugeLoss(address gauge, address who) external {\n        // check preconditions\n        uint256 _lastGaugeLoss = lastGaugeLoss[gauge];\n        uint256 _lastGaugeLossApplied = lastGaugeLossApplied[gauge][who];\n        require(\n            _lastGaugeLoss != 0 && _lastGaugeLossApplied < _lastGaugeLoss,\n            \"GuildToken: no loss to apply\"\n        );\n\n        // read user weight allocated to the lossy gauge\n        uint256 _userGaugeWeight = getUserGaugeWeight[who][gauge];\n\n        // remove gauge weight allocation\n        lastGaugeLossApplied[gauge][who] = block.timestamp;\n        _decrementGaugeWeight(who, gauge, _userGaugeWeight);\n        if (!_deprecatedGauges.contains(gauge)) {\n            totalTypeWeight[gaugeType[gauge]] -= _userGaugeWeight;\n            totalWeight -= _userGaugeWeight;\n        }\n\n        // apply loss\n        _burn(who, uint256(_userGaugeWeight));\n        emit GaugeLossApply(\n            gauge,\n            who,\n            uint256(_userGaugeWeight),\n            block.timestamp\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        TRANSFERABILITY\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice at deployment, tokens are not transferable (can only mint/burn).\n    /// Governance can enable transfers with `enableTransfers()`.\n    bool public transferable; // default = false\n\n    /// @notice emitted when transfers are enabled.\n    event TransfersEnabled(uint256 block, uint256 timestamp);\n\n    /// @notice permanently enable token transfers.\n    function enableTransfer() external onlyCoreRole(CoreRoles.GOVERNOR) {\n        transferable = true;\n        emit TransfersEnabled(block.number, block.timestamp);\n    }\n\n    /// @dev prevent transfers if they are not globally enabled.\n    /// mint and burn (transfers to and from address 0) are accepted.\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 /* amount*/\n    ) internal view override {\n        require(\n            transferable || from == address(0) || to == address(0),\n            \"GuildToken: transfers disabled\"\n        );\n    }\n\n    /// @notice emitted when reference to ProfitManager is updated\n    event ProfitManagerUpdated(uint256 timestamp, address newValue);\n\n    /// @notice set reference to ProfitManager\n    function setProfitManager(address _newProfitManager) external onlyCoreRole(CoreRoles.GOVERNOR) {\n        profitManager = _newProfitManager;\n        emit ProfitManagerUpdated(block.timestamp, _newProfitManager);\n    }\n\n    /// @dev prevent outbound token transfers (_decrementWeightUntilFree) and gauge weight decrease\n    /// (decrementGauge, decrementGauges) for users who have an unrealized loss in a gauge, or if the\n    /// gauge is currently using its allocated debt ceiling. To decrement gauge weight, guild holders\n    /// might have to call loans if the debt ceiling is used.\n    /// Also update the user profit index and claim rewards.\n    function _decrementGaugeWeight(\n        address user,\n        address gauge,\n        uint256 weight\n    ) internal override {\n        uint256 _lastGaugeLoss = lastGaugeLoss[gauge];\n        uint256 _lastGaugeLossApplied = lastGaugeLossApplied[gauge][user];\n        require(\n            _lastGaugeLossApplied >= _lastGaugeLoss,\n            \"GuildToken: pending loss\"\n        );\n\n        // update the user profit index and claim rewards\n        ProfitManager(profitManager).claimGaugeRewards(user, gauge);\n\n        // check if gauge is currently using its allocated debt ceiling.\n        // To decrement gauge weight, guild holders might have to call loans if the debt ceiling is used.\n        uint256 issuance = LendingTerm(gauge).issuance();\n        if (issuance != 0) {\n            uint256 debtCeilingAfterDecrement = LendingTerm(gauge).debtCeiling(-int256(weight));\n            require(\n                issuance <= debtCeilingAfterDecrement,\n                \"GuildToken: debt ceiling used\"\n            );\n        }\n\n        super._decrementGaugeWeight(user, gauge, weight);\n    }\n\n    /// @dev prevent weight increment for gauge if user has an unapplied loss.\n    /// If the user has 0 weight (i.e. no loss to realize), allow incrementing\n    /// gauge weight & update lastGaugeLossApplied to current time.\n    /// Also update the user profit index an claim rewards.\n    /// @dev note that users voting for a gauge that is not a proper lending term could result in this\n    /// share of the user's tokens to be frozen, due to being unable to decrement weight.\n    function _incrementGaugeWeight(\n        address user,\n        address gauge,\n        uint256 weight\n    ) internal override {\n        uint256 _lastGaugeLoss = lastGaugeLoss[gauge];\n        uint256 _lastGaugeLossApplied = lastGaugeLossApplied[gauge][user];\n        if (getUserGaugeWeight[user][gauge] == 0) {\n            lastGaugeLossApplied[gauge][user] = block.timestamp;\n        } else {\n            require(\n                _lastGaugeLossApplied >= _lastGaugeLoss,\n                \"GuildToken: pending loss\"\n            );\n        }\n\n        ProfitManager(profitManager).claimGaugeRewards(user, gauge);\n\n        super._incrementGaugeWeight(user, gauge, weight);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        MINT / BURN\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice mint new tokens to the target address\n    function mint(\n        address to,\n        uint256 amount\n    ) external onlyCoreRole(CoreRoles.GUILD_MINTER) {\n        _mint(to, amount);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        Inheritance reconciliation\n    //////////////////////////////////////////////////////////////*/\n\n    function _burn(\n        address from,\n        uint256 amount\n    ) internal virtual override(ERC20, ERC20Gauges, ERC20MultiVotes) {\n        _decrementWeightUntilFree(from, amount);\n        _decrementVotesUntilFree(from, amount);\n        ERC20._burn(from, amount);\n    }\n\n    function transfer(\n        address to,\n        uint256 amount\n    )\n        public\n        virtual\n        override(ERC20, ERC20Gauges, ERC20MultiVotes)\n        returns (bool)\n    {\n        _decrementWeightUntilFree(msg.sender, amount);\n        _decrementVotesUntilFree(msg.sender, amount);\n        return ERC20.transfer(to, amount);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    )\n        public\n        virtual\n        override(ERC20, ERC20Gauges, ERC20MultiVotes)\n        returns (bool)\n    {\n        _decrementWeightUntilFree(from, amount);\n        _decrementVotesUntilFree(from, amount);\n        return ERC20.transferFrom(from, to, amount);\n    }\n}"
    }
  ]
}