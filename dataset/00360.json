{
  "Title": "`removeWhitelistStatus` function Ignores updating `milestoneSeason` variable",
  "Content": "# `removeWhitelistStatus` function Ignores updating `milestoneSeason` variable\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2024-02-Beanstalk-1/blob/a3658861af8f5126224718af494d02352fbb3ea5/protocol/contracts/libraries/Silo/LibWhitelistedTokens.sol#L187\">https://github.com/Cyfrin/2024-02-Beanstalk-1/blob/a3658861af8f5126224718af494d02352fbb3ea5/protocol/contracts/libraries/Silo/LibWhitelistedTokens.sol#L187</a>\n\n\n## Summary\nThe issue in the `LibWhitelistedTokens:removeWhitelistStatus` function is that it removes the Whitelist status of a token without considering the impact on other related variables, such as the `milestoneSeason` variable.  \n## Vulnerability Details\n`milestoneSeason` Is used in many functions for checking whether a token is whitelisted or not i.e. \n```\n require(s.ss[token].milestoneSeason == 0, \"Whitelist: Token already whitelisted\");\n```\nIf the milestoneSeason variable is not updated or cleared when removing the Whitelist status, it may lead to incorrect behavior in subsequent checks or operations that rely on this variable. \n## Impact\nRemoving the Whitelist status of a token without updating related variables can lead to inconsistencies in the data stored in the contract. The `milestoneSeason` variable, used for checking whitelist status in many functions, may still hold outdated or incorrect information after removing the status, potentially leading to unexpected behavior or vulnerabilities.\n## Tools Used\nManual Review\n## Recommendations\nTo address this issue, ensure that related variables, such as `milestoneSeason`, are appropriately updated or cleared when removing the Whitelist status of a token. If the milestoneSeason variable is no longer relevant after removing the Whitelist status, it should be updated or cleared to maintain data integrity.",
  "Impact": "MEDIUM",
  "Source": "https://www.codehawks.com/contests/clsxlpte900074r5et7x6kh96",
  "Code": [
    {
      "filename": "protocol/contracts/libraries/Silo/LibWhitelistedTokens.sol",
      "content": "/*\n SPDX-License-Identifier: MIT\n*/\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {C} from \"../../C.sol\";\nimport {AppStorage, Storage, LibAppStorage} from \"contracts/libraries/LibAppStorage.sol\";\n\n/**\n * @title LibWhitelistedTokens\n * @author Brean, Brendan\n * @notice LibWhitelistedTokens holds different lists of types of Whitelisted Tokens.\n * \n * @dev manages the WhitelistStatuses for all tokens in the Silo in order to track lists.\n * Note: dewhitelisting a token doesn't remove it's WhitelistStatus entirelyâ€“It just modifies it.\n * Once a token has no more Deposits in the Silo, it's WhitelistStatus should be removed through calling `removeWhitelistStatus`.\n */\nlibrary LibWhitelistedTokens {\n\n\n    /** \n     * @notice Emitted when a Whitelis Status is added.\n     */\n    event AddWhitelistStatus(\n        address token,\n        uint256 index,\n        bool isWhitelisted,\n        bool isWhitelistedLp,\n        bool isWhitelistedWell\n    );\n\n    /**\n     * @notice Emitted when a Whitelist Status is removed.\n     */\n    event RemoveWhitelistStatus(\n        address token,\n        uint256 index\n    );\n\n    /**\n     * @notice Emitted when a Whitelist Status is updated.\n     */\n    event UpdateWhitelistStatus(\n        address token,\n        uint256 index,\n        bool isWhitelisted,\n        bool isWhitelistedLp,\n        bool isWhitelistedWell\n    );\n\n    /**\n     * @notice Returns all tokens that are currently or previously in the silo, \n     * including Unripe tokens.\n     * @dev includes Dewhitelisted tokens with existing Deposits.\n     */\n    function getSiloTokens() internal view returns (address[] memory tokens) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint256 numberOfSiloTokens = s.whitelistStatuses.length;\n\n        tokens = new address[](numberOfSiloTokens);\n\n        for (uint256 i = 0; i < numberOfSiloTokens; i++) {\n            tokens[i] = s.whitelistStatuses[i].token;\n        }\n    }\n\n    /**\n     * @notice Returns the current Whitelisted tokens, including Unripe tokens.\n     */\n    function getWhitelistedTokens() internal view returns (address[] memory tokens) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint256 numberOfSiloTokens = s.whitelistStatuses.length;\n        uint256 tokensLength;\n    \n        tokens = new address[](numberOfSiloTokens);\n\n        for (uint256 i = 0; i < numberOfSiloTokens; i++) {\n            if (s.whitelistStatuses[i].isWhitelisted) {\n                tokens[tokensLength++] = s.whitelistStatuses[i].token;\n            }\n        }\n        assembly {\n            mstore(tokens, tokensLength)\n        }\n    }\n\n    /**\n     * @notice Returns the current Whitelisted LP tokens. \n     * @dev Unripe LP is not an LP token.\n     */\n    function getWhitelistedLpTokens() internal view returns (address[] memory tokens) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint256 numberOfSiloTokens = s.whitelistStatuses.length;\n        uint256 tokensLength;\n\n        tokens = new address[](numberOfSiloTokens);\n\n        for (uint256 i = 0; i < numberOfSiloTokens; i++) {\n            if (s.whitelistStatuses[i].isWhitelistedLp) {\n                // assembly {\n                //     mstore(tokens, add(mload(tokens), 1))\n                // }\n                tokens[tokensLength++] = s.whitelistStatuses[i].token;\n            }\n        }\n        assembly {\n            mstore(tokens, tokensLength)\n        }\n    }\n\n    /**\n     * @notice Returns the current Whitelisted Well LP tokens.\n     */\n    function getWhitelistedWellLpTokens() internal view returns (address[] memory tokens) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint256 numberOfSiloTokens = s.whitelistStatuses.length;\n        uint256 tokensLength;\n\n        tokens = new address[](numberOfSiloTokens);\n\n        for (uint256 i = 0; i < numberOfSiloTokens; i++) {\n            if (s.whitelistStatuses[i].isWhitelistedWell) {\n                tokens[tokensLength++] = s.whitelistStatuses[i].token;\n            }\n        }\n        assembly {\n            mstore(tokens, tokensLength)\n        }\n    }\n\n    /**\n     * @notice Returns the Whitelist statues for all tokens that have been whitelisted and not manually removed.\n     */\n    function getWhitelistedStatuses() internal view returns (Storage.WhitelistStatus[] memory _whitelistStatuses) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        _whitelistStatuses = s.whitelistStatuses;\n    }\n\n    /**\n     * @notice Returns the Whitelist status for a given token.\n     */\n    function getWhitelistedStatus(address token) internal view returns (Storage.WhitelistStatus memory _whitelistStatus) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint256 tokenStatusIndex = findWhitelistStatusIndex(token);\n        _whitelistStatus = s.whitelistStatuses[tokenStatusIndex];\n    }\n\n    /**\n     * @notice Adds a Whitelist Status for a given `token`.\n     */\n    function addWhitelistStatus(address token, bool isWhitelisted, bool isWhitelistedLp, bool isWhitelistedWell) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.whitelistStatuses.push(Storage.WhitelistStatus(\n            token,\n            isWhitelisted,\n            isWhitelistedLp,\n            isWhitelistedWell\n        ));\n\n        emit AddWhitelistStatus(token, s.whitelistStatuses.length - 1, isWhitelisted, isWhitelistedLp, isWhitelistedWell);\n    }\n\n    /**\n     * @notice Modifies the exisiting Whitelist Status of `token`.\n     */\n    function updateWhitelistStatus(address token, bool isWhitelisted, bool isWhitelistedLp, bool isWhitelistedWell) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint256 tokenStatusIndex = findWhitelistStatusIndex(token);\n        s.whitelistStatuses[tokenStatusIndex].isWhitelisted = isWhitelisted;\n        s.whitelistStatuses[tokenStatusIndex].isWhitelistedLp = isWhitelistedLp;\n        s.whitelistStatuses[tokenStatusIndex].isWhitelistedWell = isWhitelistedWell;\n\n        emit UpdateWhitelistStatus(\n            token,\n            tokenStatusIndex,\n            isWhitelisted,\n            isWhitelistedLp,\n            isWhitelistedWell\n        );\n    }\n\n    /**\n     * @notice Removes `token`'s Whitelist Status.\n     */\n    function removeWhitelistStatus(address token) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint256 tokenStatusIndex = findWhitelistStatusIndex(token);\n        s.whitelistStatuses[tokenStatusIndex] = s.whitelistStatuses[s.whitelistStatuses.length - 1];\n        s.whitelistStatuses.pop();\n\n        emit RemoveWhitelistStatus(token, tokenStatusIndex);\n    }\n\n    /**\n     * @notice Finds the index of a given `token`'s Whitelist Status.\n     */\n    function findWhitelistStatusIndex(address token) private view returns (uint256) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint256 whitelistedStatusLength = s.whitelistStatuses.length;\n        uint256 i;\n        while (s.whitelistStatuses[i].token != token) {\n            i++;\n            if (i >= whitelistedStatusLength) {\n                revert(\"LibWhitelistedTokens: Token not found\");\n            }\n        }\n        return i;\n    }\n}"
    }
  ]
}