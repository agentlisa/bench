{
  "Title": "[H-05] Withdrawals can be frozen by creating null deposits",
  "Content": "\nIt won't be possible to withdraw any LP token after doing a deposit of $0$ liquidity, leading to withdrawals being effectively freezed.\n\n### Proof of Concept\n\nIn [**liquidity_lockbox, function withdraw**](https://github.com/code-423n4/2023-12-autonolas/blob/2a095eb1f8359be349d23af67089795fb0be4ed1/lockbox-solana/solidity/liquidity_lockbox.sol#L221C1-L225C10)\n\n```solidity\n        ...\n\n        uint64 positionLiquidity = mapPositionAccountLiquidity[positionAddress];\n        // Check that the token account exists\n        if (positionLiquidity == 0) {\n            revert(\"No liquidity on a provided token account\");\n        }\n\n        ...\n```\n\nThe code checks for the existence of a position via the recorded liquidity. This is a clever idea, as querying a non-existant value from a mapping will return $0$. However, in `deposit`, due to a flawed input validation, it is possible to make positions with $0$ liquidity as the only check being done is for liquidity to not be higher than `type(uint64).max`:\n\n[**liquidity_lockbox, function \\_getPositionData**](https://github.com/code-423n4/2023-12-autonolas/blob/2a095eb1f8359be349d23af67089795fb0be4ed1/lockbox-solana/solidity/liquidity_lockbox.sol#L94C1-L97C10)\n\n```solidity\n        ...\n\n        // Check that the liquidity is within uint64 bounds\n        if (positionData.liquidity > type(uint64).max) {\n            revert(\"Liquidity overflow\");\n        }\n\n        ...\n```\n\nAs it will pass the input validation inside `_getPositionData`, the only way for such a tx to revert is in the [transfer](https://github.com/code-423n4/2023-12-autonolas/blob/2a095eb1f8359be349d23af67089795fb0be4ed1/lockbox-solana/solidity/liquidity_lockbox.sol#L164)/[mint](https://github.com/code-423n4/2023-12-autonolas/blob/2a095eb1f8359be349d23af67089795fb0be4ed1/lockbox-solana/solidity/liquidity_lockbox.sol#L171), which are low-level calls with no checks for success, as stated in my report `Missing checks for failed calls to the token program will corrupt user's positions`.\n\nDue to the reasons above, this deposit with $0$ liquidity will be treated as a valid one and will be stored inside the `mapPositionAccountLiquidity` and `positionAccounts` arrays. If we add the fact that withdrawals are done by looping **LINEARLY** through `positionAccounts`:\n\n[**liquidity_lockbox, function withdraw**](https://github.com/code-423n4/2023-12-autonolas/blob/2a095eb1f8359be349d23af67089795fb0be4ed1/lockbox-solana/solidity/liquidity_lockbox.sol#L192C1-L323C6)\n\n```solidity\n    function withdraw(uint64 amount) external {\n        address positionAddress = positionAccounts[firstAvailablePositionAccountIndex]; // @audit linear loop\n        \n        ...\n\n        uint64 positionLiquidity = mapPositionAccountLiquidity[positionAddress];\n        // Check that the token account exists\n        if (positionLiquidity == 0) { // @audit it will revert here once it reaches the flawed position\n            revert(\"No liquidity on a provided token account\");\n        }\n\n        ...\n\n        if (remainder == 0) { // @audit if the liquidity after the orca call is 0, close the position and ++ the index\n            ...\n\n            // Increase the first available position account index\n            firstAvailablePositionAccountIndex++; // @audit it won't reach here as the revert above will roll-back the whole tx\n        }\n    }\n```\n\nIt can be seen that once it encounters such a *\"fake\"* deposit with $0$ liquidity provided, it will always revert due to the existence check. As there is no other way to update `firstAvailablePositionAccountIndex` to bypass the flawed position, withdrawals will be completely freezed.\n\n### Recommended Mitigation Steps\n\nJust check for the supplied liquidity to not be $0$ in\n\n[**liquidity_lockbox, function \\_getPositionData**](https://github.com/code-423n4/2023-12-autonolas/blob/2a095eb1f8359be349d23af67089795fb0be4ed1/lockbox-solana/solidity/liquidity_lockbox.sol#L94C1-L97C10)\n\n```diff\n        ...\n+       // Check that the liquidity > 0\n+       if (positionData.liquidity == 0) {\n+           revert(\"Liquidity cannot be 0\");\n+       }\n\n        // Check that the liquidity is within uint64 bounds\n        if (positionData.liquidity > type(uint64).max) {\n            revert(\"Liquidity overflow\");\n        }\n\n        ...\n```\n\n**[mariapiamo (Olas) confirmed](https://github.com/code-423n4/2023-12-autonolas-findings/issues/341#issuecomment-1892165566)**\n\n***\n \n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-12-autonolas",
  "Code": [
    {
      "filename": "lockbox-solana/solidity/liquidity_lockbox.sol",
      "content": "import \"./library/spl_token.sol\";\nimport \"./interfaces/whirlpool.sol\";\n\n// Position struct\nstruct Position {\n    // Whirlpool (LP pool) address, 32 bytes\n    address whirlpool;\n    // Position mint (liquidity NFT) address, 32 bytes\n    address positionMint;\n    // Position liquidity, 16 bytes\n    uint128 liquidity;\n    // Tick lower index, 4 bytes\n    int32 tickLowerIndex;\n    /// Tick upper index, 4 bytes\n    int32 tickUpperIndex;\n}\n\n/// @dev The liquidity in the position cannot be practically bigger than the max of uint64 since\n///      spl token functions are limited by the uint64 value.\n\n@program_id(\"GUGGHzwC8wEKY3g7QS38YmoS8t5Q2faWAGAfxDK2bXbb\")\ncontract liquidity_lockbox {\n    // Orca whirlpool program address\n    address public constant orca = address\"whirLbMiicVdio4qvUfM5KAg6Ct8VwpYzGff3uctyCc\";\n    // Whirlpool (LP) pool address\n    address public pool;\n    // Current program owned PDA account address\n    address public pdaProgram;\n    // Bridged token mint address\n    address public bridgedTokenMint;\n    // PDA bridged token account address\n    address public pdaBridgedTokenAccount;\n    // PDA header for position account\n    uint64 public pdaHeader = 0xd0f7407ae48fbcaa;\n    // Program PDA seed\n    bytes public constant pdaProgramSeed = \"pdaProgram\";\n    // Program PDA bump\n    bytes1 public pdaBump;\n    int32 public constant minTickLowerIndex = -443632;\n    int32 public constant maxTickLowerIndex = 443632;\n\n    // Total number of token accounts (even those that hold no positions anymore)\n    uint32 public numPositionAccounts;\n    // First available account index in the set of accounts;\n    uint32 public firstAvailablePositionAccountIndex;\n    // Total liquidity in a lockbox\n    uint64 public totalLiquidity;\n\n    //\n    mapping(address => uint64) public mapPositionAccountLiquidity;\n    mapping(address => address) public mapPositionAccountPdaAta;\n    address[type(uint32).max] public positionAccounts;\n\n    @space(10000)\n    @payer(payer)\n    @seed(\"pdaProgram\")\n    constructor(\n        address _pool,\n        address _bridgedTokenMint,\n        address _pdaBridgedTokenAccount,\n        @bump bytes1 _bump\n    ) {\n        pool = _pool;\n        bridgedTokenMint = _bridgedTokenMint;\n        pdaBridgedTokenAccount = _pdaBridgedTokenAccount;\n\n        // Independently derive the PDA address from the seeds, bump, and programId\n        (address pda, bytes1 bump) = try_find_program_address([\"pdaProgram\"], type(liquidity_lockbox).program_id);\n\n        // Verify that the bump passed to the constructor matches the bump derived from the seeds and programId\n        if (bump != _bump) {\n            revert(\"Invalid bump\");\n        }\n\n        // Assign pda and bump\n        pdaProgram = pda;\n        pdaBump = bump;\n    }\n\n    /// @dev Gets the position data.\n    /// @param position Position account.\n    /// @param positionMint Position mint (NFT).\n    /// @return positionData Position data.\n    function _getPositionData(AccountInfo position, address positionMint) internal view returns (Position positionData) {\n        // Extract the position data\n        positionData = Position({\n            whirlpool: position.data.readAddress(8),\n            positionMint: position.data.readAddress(40),\n            liquidity: position.data.readUint128LE(72),\n            tickLowerIndex: position.data.readInt32LE(88),\n            tickUpperIndex: position.data.readInt32LE(92)\n        });\n\n        // Check that the liquidity is within uint64 bounds\n        if (positionData.liquidity > type(uint64).max) {\n            revert(\"Liquidity overflow\");\n        }\n\n        // Check the whirlpool\n        if (positionData.whirlpool != pool) {\n            revert(\"Wrong pool address\");\n        }\n\n        // Check the NFT address\n        if (positionData.positionMint != positionMint) {\n            revert(\"Wrong NFT address\");\n        }\n\n        // Check tick values\n        if (positionData.tickLowerIndex != minTickLowerIndex || positionData.tickUpperIndex != maxTickLowerIndex) {\n            revert(\"Wrong ticks\");\n        }\n\n        // Check the PDA ownership\n        if (position.owner != orca) {\n            revert(\"Wrong PDA owner\");\n        }\n\n        // Check the PDA header data\n        uint64 header = position.data.readUint64LE(0);\n        if (header != pdaHeader) {\n            revert(\"Wrong PDA header\");\n        }\n\n        // Check the PDA address correctness\n        (address pdaPosition, ) = try_find_program_address([\"position\", positionData.positionMint], orca);\n        if (pdaPosition != position.key) {\n            revert(\"Wrong position PDA\");\n        }\n    }\n\n    /// @dev Deposits the position mint (NFT) in order to get a corresponding liquidity amount of bridged tokens\n    @mutableAccount(userPositionAccount)\n    @mutableAccount(pdaPositionAccount)\n    @mutableAccount(userBridgedTokenAccount)\n    @mutableAccount(bridgedTokenMint)\n    @account(position)\n    @account(positionMint)\n    @signer(userWallet)\n    function deposit() external {\n        // Get the position data based on provided accounts\n        Position positionData = _getPositionData(tx.accounts.position, tx.accounts.positionMint.key);\n\n        uint64 positionLiquidity = uint64(positionData.liquidity);\n\n        // Check that the mint of the user position ATA matches the position mint\n        address positionMint = tx.accounts.userPositionAccount.data.readAddress(0);\n        if (positionMint != tx.accounts.positionMint.key) {\n            revert(\"Wrong user position ATA\");\n        }\n\n        // Check that the bridged token mint account is correct\n        if (tx.accounts.bridgedTokenMint.key != bridgedTokenMint) {\n            revert(\"Wrong bridged token mint account\");\n        }\n\n        // PDA position account owner must be the PDA program account\n        address pdaPositionOwner = tx.accounts.pdaPositionAccount.data.readAddress(32);\n        if (pdaPositionOwner != pdaProgram) {\n            revert(\"Wrong PDA position owner\");\n        }\n\n        // Transfer the position NFT to the pdaPositionAccount address of this program\n        SplToken.transfer(\n            tx.accounts.userPositionAccount.key,\n            tx.accounts.pdaPositionAccount.key,\n            tx.accounts.userWallet.key,\n            1);\n\n        // Mint bridged tokens to the user\n        SplToken.pda_mint_to(\n            bridgedTokenMint,\n            tx.accounts.userBridgedTokenAccount.key,\n            pdaProgram,\n            positionLiquidity,\n            pdaProgramSeed,\n            pdaBump);\n\n        // Record position liquidity amount and its correspondent account address\n        address positionAddress = tx.accounts.position.key;\n        mapPositionAccountLiquidity[positionAddress] = positionLiquidity;\n        address pdaPositionAta = tx.accounts.pdaPositionAccount.key;\n        mapPositionAccountPdaAta[positionAddress] = pdaPositionAta;\n        positionAccounts[numPositionAccounts] = positionAddress;\n\n        // Increase the total number of positions\n        numPositionAccounts++;\n        // Increase the amount of total liquidity\n        totalLiquidity += positionLiquidity;\n    }\n\n    /// @dev Withdraws LP tokens separately to each token ATA and burns provided bridge tokens.\n    /// @param amount Bridged token amount.\n    @mutableAccount(pool)\n    @account(tokenProgramId)\n    @mutableAccount(position)\n    @mutableAccount(userBridgedTokenAccount)\n    @mutableAccount(pdaBridgedTokenAccount)\n    @mutableAccount(userWallet)\n    @mutableAccount(bridgedTokenMint)\n    @mutableAccount(pdaPositionAccount)\n    @mutableAccount(userTokenAccountA)\n    @mutableAccount(userTokenAccountB)\n    @mutableAccount(tokenVaultA)\n    @mutableAccount(tokenVaultB)\n    @mutableAccount(tickArrayLower)\n    @mutableAccount(tickArrayUpper)\n    @mutableAccount(positionMint)\n    @signer(sig)\n    function withdraw(uint64 amount) external {\n        address positionAddress = positionAccounts[firstAvailablePositionAccountIndex];\n        if (positionAddress != tx.accounts.position.key) {\n            revert(\"Wrong liquidity token account\");\n        }\n\n        address pdaPositionAta = tx.accounts.pdaPositionAccount.key;\n        if (mapPositionAccountPdaAta[positionAddress] != pdaPositionAta) {\n            revert(\"Wrong position ATA\");\n        }\n\n        uint64 positionLiquidity = mapPositionAccountLiquidity[positionAddress];\n        // Check that the token account exists\n        if (positionLiquidity == 0) {\n            revert(\"No liquidity on a provided token account\");\n        }\n\n        // Check the requested amount to be smaller or equal than the position liquidity\n        if (amount > positionLiquidity) {\n            revert(\"Amount exceeds a position liquidity\");\n        }\n\n        // Check the pdaBridgedTokenAccount address\n        if (tx.accounts.pdaBridgedTokenAccount.key != pdaBridgedTokenAccount) {\n            revert(\"Wrong PDA bridged token ATA\");\n        }\n\n        // Check that the pool is correct\n        if (tx.accounts.pool.key != pool) {\n            revert(\"Pool address is incorrect\");\n        }\n\n        // Check that the bridged token mint account is correct\n        if (tx.accounts.bridgedTokenMint.key != bridgedTokenMint) {\n            revert(\"Wrong bridged token mint account\");\n        }\n\n        // Transfer bridged tokens to the pdaBridgedTokenAccount address of this program\n        SplToken.transfer(\n            tx.accounts.userBridgedTokenAccount.key,\n            pdaBridgedTokenAccount,\n            tx.accounts.userWallet.key,\n            amount);\n\n        // Decrease the total liquidity amount\n        totalLiquidity -= amount;\n\n        // Burn acquired bridged tokens\n        SplToken.pda_burn(pdaBridgedTokenAccount, bridgedTokenMint, pdaProgram, amount, pdaProgramSeed, pdaBump);\n\n        // Decrease the position liquidity\n        AccountMeta[11] metasDecreaseLiquidity = [\n            AccountMeta({pubkey: pool, is_writable: true, is_signer: false}),\n            AccountMeta({pubkey: SplToken.tokenProgramId, is_writable: false, is_signer: false}),\n            AccountMeta({pubkey: pdaProgram, is_writable: false, is_signer: true}),\n            AccountMeta({pubkey: positionAddress, is_writable: true, is_signer: false}),\n            AccountMeta({pubkey: pdaPositionAta, is_writable: false, is_signer: false}),\n            AccountMeta({pubkey: tx.accounts.userTokenAccountA.key, is_writable: true, is_signer: false}),\n            AccountMeta({pubkey: tx.accounts.userTokenAccountB.key, is_writable: true, is_signer: false}),\n            AccountMeta({pubkey: tx.accounts.tokenVaultA.key, is_writable: true, is_signer: false}),\n            AccountMeta({pubkey: tx.accounts.tokenVaultB.key, is_writable: true, is_signer: false}),\n            AccountMeta({pubkey: tx.accounts.tickArrayLower.key, is_writable: true, is_signer: false}),\n            AccountMeta({pubkey: tx.accounts.tickArrayUpper.key, is_writable: true, is_signer: false})\n        ];\n        // a026d06f685b2c01 - decreaseLiquidity, eff0ae00000000000000000000000000 - amount, aaf1950200000000 - minA, b8522d0000000000 - minB\n        // bytes bincode = \"0xa026d06f685b2c01eff0ae00000000000000000000000000aaf1950200000000b8522d0000000000\";\n        // orca.call{accounts: metasDecreaseLiquidity, seeds: [[pdaProgramSeed, pdaBump]]}(bincode);\n        whirlpool.decreaseLiquidity{accounts: metasDecreaseLiquidity, seeds: [[pdaProgramSeed, pdaBump]]}(amount, 0, 0);\n\n        // Update the token remainder\n        uint64 remainder = positionLiquidity - amount;\n        // Update liquidity and its associated position account\n        mapPositionAccountLiquidity[positionAddress] = remainder;\n\n        // If requested amount can be fully covered by the current position liquidity, close the position\n        if (remainder == 0) {\n            // Update fees for the position\n            AccountMeta[4] metasUpdateFees = [\n                AccountMeta({pubkey: pool, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: positionAddress, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: tx.accounts.tickArrayLower.key, is_writable: false, is_signer: false}),\n                AccountMeta({pubkey: tx.accounts.tickArrayUpper.key, is_writable: false, is_signer: false})\n            ];\n            whirlpool.updateFeesAndRewards{accounts: metasUpdateFees, seeds: [[pdaProgramSeed, pdaBump]]}();\n\n            // Collect fees from the position\n            AccountMeta[9] metasCollectFees = [\n                AccountMeta({pubkey: pool, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: pdaProgram, is_writable: false, is_signer: true}),\n                AccountMeta({pubkey: positionAddress, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: pdaPositionAta, is_writable: false, is_signer: false}),\n                AccountMeta({pubkey: tx.accounts.userTokenAccountA.key, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: tx.accounts.tokenVaultA.key, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: tx.accounts.userTokenAccountB.key, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: tx.accounts.tokenVaultB.key, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: SplToken.tokenProgramId, is_writable: false, is_signer: false})\n            ];\n            whirlpool.collectFees{accounts: metasCollectFees, seeds: [[pdaProgramSeed, pdaBump]]}();\n\n            // Close the position\n            AccountMeta[6] metasClosePosition = [\n                AccountMeta({pubkey: pdaProgram, is_writable: false, is_signer: true}),\n                AccountMeta({pubkey: tx.accounts.userWallet.key, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: positionAddress, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: tx.accounts.positionMint.key, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: pdaPositionAta, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: SplToken.tokenProgramId, is_writable: false, is_signer: false})\n            ];\n            whirlpool.closePosition{accounts: metasClosePosition, seeds: [[pdaProgramSeed, pdaBump]]}();\n\n            // Increase the first available position account index\n            firstAvailablePositionAccountIndex++;\n        }\n    }\n\n    /// @dev Gets the position data.\n    /// @return Position data.\n    @account(position)\n    @account(positionMint)\n    function getPositionData() external view returns (Position) {\n        return _getPositionData(tx.accounts.position, tx.accounts.positionMint.key);\n    }\n\n    /// @dev Gets liquidity amounts and position accounts in order to correctly withdraw a specified liquidity amount.\n    /// @param amount Liquidity amount to withdraw.\n    /// @return positionAmounts Position amounts.\n    /// @return positionAddresses Position mint addresses.\n    /// @return positionPdaAtas Position PDA ATA-s controlled by the program.\n    function getLiquidityAmountsAndPositions(uint64 amount)\n        external view returns (uint64[] positionAmounts, address[] positionAddresses, address[] positionPdaAtas)\n    {\n        if (amount > totalLiquidity) {\n            revert (\"Requested amount is too big for the total available liquidity\");\n        }\n\n        uint64 liquiditySum = 0;\n        uint32 numPositions = 0;\n        uint64 amountLeft = 0;\n\n        // Get the number of allocated positions\n        for (uint32 i = firstAvailablePositionAccountIndex; i < numPositionAccounts; ++i) {\n            address positionAddress = positionAccounts[i];\n            uint64 positionLiquidity = mapPositionAccountLiquidity[positionAddress];\n\n            // Increase a total calculated liquidity and a number of positions to return\n            liquiditySum += positionLiquidity;\n            numPositions++;\n\n            // Check if the accumulated liquidity is enough to cover the requested amount\n            if (liquiditySum >= amount) {\n                amountLeft = liquiditySum - amount;\n                break;\n            }\n        }\n\n        // Allocate the necessary arrays and fill the values\n        positionAddresses = new address[](numPositions);\n        positionAmounts = new uint64[](numPositions);\n        positionPdaAtas = new address[](numPositions);\n        for (uint32 i = 0; i < numPositions; ++i) {\n            positionAddresses[i] = positionAccounts[firstAvailablePositionAccountIndex + i];\n            positionAmounts[i] = mapPositionAccountLiquidity[positionAddresses[i]];\n            positionPdaAtas[i] = mapPositionAccountPdaAta[positionAddresses[i]];\n        }\n\n        // Adjust the last position, if it was not fully allocated\n        if (numPositions > 0 && amountLeft > 0) {\n            positionAmounts[numPositions - 1] = amountLeft;\n        }\n    }\n\n    /// @dev Gets token account balance.\n    @account(account)\n    function getBalance() external view returns (uint64) {\n        return SplToken.get_balance(tx.accounts.account);\n    }\n\n    /// @dev Gets total supply of a provided token account.\n    @account(account)\n    function totalSupply() external view returns (uint64) {\n        return SplToken.total_supply(tx.accounts.account);\n    }\n}"
    },
    {
      "filename": "lockbox-solana/solidity/liquidity_lockbox.sol",
      "content": "import \"./library/spl_token.sol\";\nimport \"./interfaces/whirlpool.sol\";\n\n// Position struct\nstruct Position {\n    // Whirlpool (LP pool) address, 32 bytes\n    address whirlpool;\n    // Position mint (liquidity NFT) address, 32 bytes\n    address positionMint;\n    // Position liquidity, 16 bytes\n    uint128 liquidity;\n    // Tick lower index, 4 bytes\n    int32 tickLowerIndex;\n    /// Tick upper index, 4 bytes\n    int32 tickUpperIndex;\n}\n\n/// @dev The liquidity in the position cannot be practically bigger than the max of uint64 since\n///      spl token functions are limited by the uint64 value.\n\n@program_id(\"GUGGHzwC8wEKY3g7QS38YmoS8t5Q2faWAGAfxDK2bXbb\")\ncontract liquidity_lockbox {\n    // Orca whirlpool program address\n    address public constant orca = address\"whirLbMiicVdio4qvUfM5KAg6Ct8VwpYzGff3uctyCc\";\n    // Whirlpool (LP) pool address\n    address public pool;\n    // Current program owned PDA account address\n    address public pdaProgram;\n    // Bridged token mint address\n    address public bridgedTokenMint;\n    // PDA bridged token account address\n    address public pdaBridgedTokenAccount;\n    // PDA header for position account\n    uint64 public pdaHeader = 0xd0f7407ae48fbcaa;\n    // Program PDA seed\n    bytes public constant pdaProgramSeed = \"pdaProgram\";\n    // Program PDA bump\n    bytes1 public pdaBump;\n    int32 public constant minTickLowerIndex = -443632;\n    int32 public constant maxTickLowerIndex = 443632;\n\n    // Total number of token accounts (even those that hold no positions anymore)\n    uint32 public numPositionAccounts;\n    // First available account index in the set of accounts;\n    uint32 public firstAvailablePositionAccountIndex;\n    // Total liquidity in a lockbox\n    uint64 public totalLiquidity;\n\n    //\n    mapping(address => uint64) public mapPositionAccountLiquidity;\n    mapping(address => address) public mapPositionAccountPdaAta;\n    address[type(uint32).max] public positionAccounts;\n\n    @space(10000)\n    @payer(payer)\n    @seed(\"pdaProgram\")\n    constructor(\n        address _pool,\n        address _bridgedTokenMint,\n        address _pdaBridgedTokenAccount,\n        @bump bytes1 _bump\n    ) {\n        pool = _pool;\n        bridgedTokenMint = _bridgedTokenMint;\n        pdaBridgedTokenAccount = _pdaBridgedTokenAccount;\n\n        // Independently derive the PDA address from the seeds, bump, and programId\n        (address pda, bytes1 bump) = try_find_program_address([\"pdaProgram\"], type(liquidity_lockbox).program_id);\n\n        // Verify that the bump passed to the constructor matches the bump derived from the seeds and programId\n        if (bump != _bump) {\n            revert(\"Invalid bump\");\n        }\n\n        // Assign pda and bump\n        pdaProgram = pda;\n        pdaBump = bump;\n    }\n\n    /// @dev Gets the position data.\n    /// @param position Position account.\n    /// @param positionMint Position mint (NFT).\n    /// @return positionData Position data.\n    function _getPositionData(AccountInfo position, address positionMint) internal view returns (Position positionData) {\n        // Extract the position data\n        positionData = Position({\n            whirlpool: position.data.readAddress(8),\n            positionMint: position.data.readAddress(40),\n            liquidity: position.data.readUint128LE(72),\n            tickLowerIndex: position.data.readInt32LE(88),\n            tickUpperIndex: position.data.readInt32LE(92)\n        });\n\n        // Check that the liquidity is within uint64 bounds\n        if (positionData.liquidity > type(uint64).max) {\n            revert(\"Liquidity overflow\");\n        }\n\n        // Check the whirlpool\n        if (positionData.whirlpool != pool) {\n            revert(\"Wrong pool address\");\n        }\n\n        // Check the NFT address\n        if (positionData.positionMint != positionMint) {\n            revert(\"Wrong NFT address\");\n        }\n\n        // Check tick values\n        if (positionData.tickLowerIndex != minTickLowerIndex || positionData.tickUpperIndex != maxTickLowerIndex) {\n            revert(\"Wrong ticks\");\n        }\n\n        // Check the PDA ownership\n        if (position.owner != orca) {\n            revert(\"Wrong PDA owner\");\n        }\n\n        // Check the PDA header data\n        uint64 header = position.data.readUint64LE(0);\n        if (header != pdaHeader) {\n            revert(\"Wrong PDA header\");\n        }\n\n        // Check the PDA address correctness\n        (address pdaPosition, ) = try_find_program_address([\"position\", positionData.positionMint], orca);\n        if (pdaPosition != position.key) {\n            revert(\"Wrong position PDA\");\n        }\n    }\n\n    /// @dev Deposits the position mint (NFT) in order to get a corresponding liquidity amount of bridged tokens\n    @mutableAccount(userPositionAccount)\n    @mutableAccount(pdaPositionAccount)\n    @mutableAccount(userBridgedTokenAccount)\n    @mutableAccount(bridgedTokenMint)\n    @account(position)\n    @account(positionMint)\n    @signer(userWallet)\n    function deposit() external {\n        // Get the position data based on provided accounts\n        Position positionData = _getPositionData(tx.accounts.position, tx.accounts.positionMint.key);\n\n        uint64 positionLiquidity = uint64(positionData.liquidity);\n\n        // Check that the mint of the user position ATA matches the position mint\n        address positionMint = tx.accounts.userPositionAccount.data.readAddress(0);\n        if (positionMint != tx.accounts.positionMint.key) {\n            revert(\"Wrong user position ATA\");\n        }\n\n        // Check that the bridged token mint account is correct\n        if (tx.accounts.bridgedTokenMint.key != bridgedTokenMint) {\n            revert(\"Wrong bridged token mint account\");\n        }\n\n        // PDA position account owner must be the PDA program account\n        address pdaPositionOwner = tx.accounts.pdaPositionAccount.data.readAddress(32);\n        if (pdaPositionOwner != pdaProgram) {\n            revert(\"Wrong PDA position owner\");\n        }\n\n        // Transfer the position NFT to the pdaPositionAccount address of this program\n        SplToken.transfer(\n            tx.accounts.userPositionAccount.key,\n            tx.accounts.pdaPositionAccount.key,\n            tx.accounts.userWallet.key,\n            1);\n\n        // Mint bridged tokens to the user\n        SplToken.pda_mint_to(\n            bridgedTokenMint,\n            tx.accounts.userBridgedTokenAccount.key,\n            pdaProgram,\n            positionLiquidity,\n            pdaProgramSeed,\n            pdaBump);\n\n        // Record position liquidity amount and its correspondent account address\n        address positionAddress = tx.accounts.position.key;\n        mapPositionAccountLiquidity[positionAddress] = positionLiquidity;\n        address pdaPositionAta = tx.accounts.pdaPositionAccount.key;\n        mapPositionAccountPdaAta[positionAddress] = pdaPositionAta;\n        positionAccounts[numPositionAccounts] = positionAddress;\n\n        // Increase the total number of positions\n        numPositionAccounts++;\n        // Increase the amount of total liquidity\n        totalLiquidity += positionLiquidity;\n    }\n\n    /// @dev Withdraws LP tokens separately to each token ATA and burns provided bridge tokens.\n    /// @param amount Bridged token amount.\n    @mutableAccount(pool)\n    @account(tokenProgramId)\n    @mutableAccount(position)\n    @mutableAccount(userBridgedTokenAccount)\n    @mutableAccount(pdaBridgedTokenAccount)\n    @mutableAccount(userWallet)\n    @mutableAccount(bridgedTokenMint)\n    @mutableAccount(pdaPositionAccount)\n    @mutableAccount(userTokenAccountA)\n    @mutableAccount(userTokenAccountB)\n    @mutableAccount(tokenVaultA)\n    @mutableAccount(tokenVaultB)\n    @mutableAccount(tickArrayLower)\n    @mutableAccount(tickArrayUpper)\n    @mutableAccount(positionMint)\n    @signer(sig)\n    function withdraw(uint64 amount) external {\n        address positionAddress = positionAccounts[firstAvailablePositionAccountIndex];\n        if (positionAddress != tx.accounts.position.key) {\n            revert(\"Wrong liquidity token account\");\n        }\n\n        address pdaPositionAta = tx.accounts.pdaPositionAccount.key;\n        if (mapPositionAccountPdaAta[positionAddress] != pdaPositionAta) {\n            revert(\"Wrong position ATA\");\n        }\n\n        uint64 positionLiquidity = mapPositionAccountLiquidity[positionAddress];\n        // Check that the token account exists\n        if (positionLiquidity == 0) {\n            revert(\"No liquidity on a provided token account\");\n        }\n\n        // Check the requested amount to be smaller or equal than the position liquidity\n        if (amount > positionLiquidity) {\n            revert(\"Amount exceeds a position liquidity\");\n        }\n\n        // Check the pdaBridgedTokenAccount address\n        if (tx.accounts.pdaBridgedTokenAccount.key != pdaBridgedTokenAccount) {\n            revert(\"Wrong PDA bridged token ATA\");\n        }\n\n        // Check that the pool is correct\n        if (tx.accounts.pool.key != pool) {\n            revert(\"Pool address is incorrect\");\n        }\n\n        // Check that the bridged token mint account is correct\n        if (tx.accounts.bridgedTokenMint.key != bridgedTokenMint) {\n            revert(\"Wrong bridged token mint account\");\n        }\n\n        // Transfer bridged tokens to the pdaBridgedTokenAccount address of this program\n        SplToken.transfer(\n            tx.accounts.userBridgedTokenAccount.key,\n            pdaBridgedTokenAccount,\n            tx.accounts.userWallet.key,\n            amount);\n\n        // Decrease the total liquidity amount\n        totalLiquidity -= amount;\n\n        // Burn acquired bridged tokens\n        SplToken.pda_burn(pdaBridgedTokenAccount, bridgedTokenMint, pdaProgram, amount, pdaProgramSeed, pdaBump);\n\n        // Decrease the position liquidity\n        AccountMeta[11] metasDecreaseLiquidity = [\n            AccountMeta({pubkey: pool, is_writable: true, is_signer: false}),\n            AccountMeta({pubkey: SplToken.tokenProgramId, is_writable: false, is_signer: false}),\n            AccountMeta({pubkey: pdaProgram, is_writable: false, is_signer: true}),\n            AccountMeta({pubkey: positionAddress, is_writable: true, is_signer: false}),\n            AccountMeta({pubkey: pdaPositionAta, is_writable: false, is_signer: false}),\n            AccountMeta({pubkey: tx.accounts.userTokenAccountA.key, is_writable: true, is_signer: false}),\n            AccountMeta({pubkey: tx.accounts.userTokenAccountB.key, is_writable: true, is_signer: false}),\n            AccountMeta({pubkey: tx.accounts.tokenVaultA.key, is_writable: true, is_signer: false}),\n            AccountMeta({pubkey: tx.accounts.tokenVaultB.key, is_writable: true, is_signer: false}),\n            AccountMeta({pubkey: tx.accounts.tickArrayLower.key, is_writable: true, is_signer: false}),\n            AccountMeta({pubkey: tx.accounts.tickArrayUpper.key, is_writable: true, is_signer: false})\n        ];\n        // a026d06f685b2c01 - decreaseLiquidity, eff0ae00000000000000000000000000 - amount, aaf1950200000000 - minA, b8522d0000000000 - minB\n        // bytes bincode = \"0xa026d06f685b2c01eff0ae00000000000000000000000000aaf1950200000000b8522d0000000000\";\n        // orca.call{accounts: metasDecreaseLiquidity, seeds: [[pdaProgramSeed, pdaBump]]}(bincode);\n        whirlpool.decreaseLiquidity{accounts: metasDecreaseLiquidity, seeds: [[pdaProgramSeed, pdaBump]]}(amount, 0, 0);\n\n        // Update the token remainder\n        uint64 remainder = positionLiquidity - amount;\n        // Update liquidity and its associated position account\n        mapPositionAccountLiquidity[positionAddress] = remainder;\n\n        // If requested amount can be fully covered by the current position liquidity, close the position\n        if (remainder == 0) {\n            // Update fees for the position\n            AccountMeta[4] metasUpdateFees = [\n                AccountMeta({pubkey: pool, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: positionAddress, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: tx.accounts.tickArrayLower.key, is_writable: false, is_signer: false}),\n                AccountMeta({pubkey: tx.accounts.tickArrayUpper.key, is_writable: false, is_signer: false})\n            ];\n            whirlpool.updateFeesAndRewards{accounts: metasUpdateFees, seeds: [[pdaProgramSeed, pdaBump]]}();\n\n            // Collect fees from the position\n            AccountMeta[9] metasCollectFees = [\n                AccountMeta({pubkey: pool, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: pdaProgram, is_writable: false, is_signer: true}),\n                AccountMeta({pubkey: positionAddress, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: pdaPositionAta, is_writable: false, is_signer: false}),\n                AccountMeta({pubkey: tx.accounts.userTokenAccountA.key, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: tx.accounts.tokenVaultA.key, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: tx.accounts.userTokenAccountB.key, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: tx.accounts.tokenVaultB.key, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: SplToken.tokenProgramId, is_writable: false, is_signer: false})\n            ];\n            whirlpool.collectFees{accounts: metasCollectFees, seeds: [[pdaProgramSeed, pdaBump]]}();\n\n            // Close the position\n            AccountMeta[6] metasClosePosition = [\n                AccountMeta({pubkey: pdaProgram, is_writable: false, is_signer: true}),\n                AccountMeta({pubkey: tx.accounts.userWallet.key, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: positionAddress, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: tx.accounts.positionMint.key, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: pdaPositionAta, is_writable: true, is_signer: false}),\n                AccountMeta({pubkey: SplToken.tokenProgramId, is_writable: false, is_signer: false})\n            ];\n            whirlpool.closePosition{accounts: metasClosePosition, seeds: [[pdaProgramSeed, pdaBump]]}();\n\n            // Increase the first available position account index\n            firstAvailablePositionAccountIndex++;\n        }\n    }\n\n    /// @dev Gets the position data.\n    /// @return Position data.\n    @account(position)\n    @account(positionMint)\n    function getPositionData() external view returns (Position) {\n        return _getPositionData(tx.accounts.position, tx.accounts.positionMint.key);\n    }\n\n    /// @dev Gets liquidity amounts and position accounts in order to correctly withdraw a specified liquidity amount.\n    /// @param amount Liquidity amount to withdraw.\n    /// @return positionAmounts Position amounts.\n    /// @return positionAddresses Position mint addresses.\n    /// @return positionPdaAtas Position PDA ATA-s controlled by the program.\n    function getLiquidityAmountsAndPositions(uint64 amount)\n        external view returns (uint64[] positionAmounts, address[] positionAddresses, address[] positionPdaAtas)\n    {\n        if (amount > totalLiquidity) {\n            revert (\"Requested amount is too big for the total available liquidity\");\n        }\n\n        uint64 liquiditySum = 0;\n        uint32 numPositions = 0;\n        uint64 amountLeft = 0;\n\n        // G"
    }
  ]
}