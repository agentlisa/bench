{
  "Title": "[N-03] `public` functions not called by the contract should be declared `external` instead",
  "Content": "\nContracts [are allowed](https://docs.soliditylang.org/en/latest/contracts.html#function-overriding) to override their parents' functions and change the visibility from `external` to `public`.\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: src/contracts/Staking.sol   #1\n\n370:      function unstakeAllFromTokemak() public onlyOwner {\n```\n\n<https://github.com/code-423n4/2022-06-yieldy/blob/524f3b83522125fb7d4677fa7a7e5ba5a2c0fe67/src/contracts/Staking.sol#L370>\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-06-yieldy",
  "Code": [
    {
      "filename": "src/contracts/Staking.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport \"./LiquidityReserve.sol\";\nimport \"./StakingStorage.sol\";\nimport \"../interfaces/IYieldy.sol\";\nimport \"../interfaces/ITokeManager.sol\";\nimport \"../interfaces/ITokePool.sol\";\nimport \"../interfaces/ITokeReward.sol\";\nimport \"../interfaces/ILiquidityReserve.sol\";\nimport \"../interfaces/ICurvePool.sol\";\nimport \"../interfaces/ICowSettlement.sol\";\n\ncontract Staking is OwnableUpgradeable, StakingStorage {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    event LogSetEpochDuration(uint256 indexed blockNumber, uint256 duration);\n    event LogSetWarmUpPeriod(uint256 indexed blockNumber, uint256 period);\n    event LogSetCoolDownPeriod(uint256 indexed blockNumber, uint256 period);\n    event LogSetPauseStaking(uint256 indexed blockNumber, bool shouldPause);\n    event LogSetPauseUnstaking(uint256 indexed blockNumber, bool shouldPause);\n    event LogSetPauseInstantUnstaking(\n        uint256 indexed blockNumber,\n        bool shouldPause\n    );\n    event LogSetAffiliateAddress(\n        uint256 indexed blockNumber,\n        address affilateAddress\n    );\n    event LogSetAffiliateFee(uint256 indexed blockNumber, uint256 fee);\n\n    event LogSetCurvePool(address indexed curvePool, int128 to, int128 from);\n\n    function initialize(\n        address _stakingToken,\n        address _yieldyToken,\n        address _tokeToken,\n        address _tokePool,\n        address _tokeManager,\n        address _tokeReward,\n        address _liquidityReserve,\n        address _feeAddress,\n        address _curvePool,\n        uint256 _epochDuration,\n        uint256 _firstEpochEndTime\n    ) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n\n        // must have valid initial addresses\n        require(\n            _stakingToken != address(0) &&\n                _yieldyToken != address(0) &&\n                _tokeToken != address(0) &&\n                _tokePool != address(0) &&\n                _tokeManager != address(0) &&\n                _tokeReward != address(0) &&\n                _liquidityReserve != address(0),\n            \"Invalid address\"\n        );\n        STAKING_TOKEN = _stakingToken;\n        YIELDY_TOKEN = _yieldyToken;\n        TOKE_TOKEN = _tokeToken;\n        TOKE_POOL = _tokePool;\n        TOKE_MANAGER = _tokeManager;\n        TOKE_REWARD = _tokeReward;\n        LIQUIDITY_RESERVE = _liquidityReserve;\n        FEE_ADDRESS = _feeAddress;\n        CURVE_POOL = _curvePool;\n        COW_SETTLEMENT = 0x9008D19f58AAbD9eD0D60971565AA8510560ab41;\n        COW_RELAYER = 0xC92E8bdf79f0507f65a392b0ab4667716BFE0110;\n\n        timeLeftToRequestWithdrawal = 12 hours;\n\n        if (CURVE_POOL != address(0)) {\n            IERC20(TOKE_POOL).approve(CURVE_POOL, type(uint256).max);\n            setToAndFromCurve();\n        }\n\n        IERC20(STAKING_TOKEN).approve(TOKE_POOL, type(uint256).max);\n        IERC20Upgradeable(YIELDY_TOKEN).approve(\n            LIQUIDITY_RESERVE,\n            type(uint256).max\n        );\n        IERC20Upgradeable(YIELDY_TOKEN).approve(\n            LIQUIDITY_RESERVE,\n            type(uint256).max\n        );\n        IERC20Upgradeable(TOKE_TOKEN).approve(COW_RELAYER, type(uint256).max);\n\n        epoch = Epoch({\n            duration: _epochDuration,\n            number: 1,\n            timestamp: block.timestamp, // we know about the issues surrounding block.timestamp, using it here will not cause any problems\n            endTime: _firstEpochEndTime,\n            distribute: 0\n        });\n    }\n\n    /**\n        @notice claim TOKE rewards from Tokemak\n        @dev must get amount through toke reward contract using latest cycle from reward hash contract\n        @param _recipient Recipient struct that contains chainId, cycle, address, and amount \n        @param _v uint - recovery id\n        @param _r bytes - output of ECDSA signature\n        @param _s bytes - output of ECDSA signature\n     */\n    function claimFromTokemak(\n        Recipient calldata _recipient,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external {\n        // cannot claim 0\n        require(_recipient.amount > 0, \"Must enter valid amount\");\n\n        ITokeReward tokeRewardContract = ITokeReward(TOKE_REWARD);\n        tokeRewardContract.claim(_recipient, _v, _r, _s);\n        _sendAffiliateFee(_recipient.amount);\n    }\n\n    /**\n        @notice send affiliate fee\n        @param _amount uint - total amount to deduct fee from\n     */\n    function _sendAffiliateFee(uint256 _amount) internal {\n        if (affiliateFee != 0 && FEE_ADDRESS != address(0)) {\n            uint256 feeAmount = (_amount * affiliateFee) / BASIS_POINTS;\n            IERC20Upgradeable(TOKE_TOKEN).safeTransfer(FEE_ADDRESS, feeAmount);\n        }\n    }\n\n    /**\n        @notice transfer TOKE from staking contract to address\n        @dev used so DAO can get TOKE and manually trade to return FOX to the staking contract\n        @param _claimAddress address to send TOKE rewards\n     */\n    function transferToke(address _claimAddress) external onlyOwner {\n        // _claimAddress can't be 0x0\n        require(_claimAddress != address(0), \"Invalid address\");\n        uint256 totalTokeAmount = IERC20Upgradeable(TOKE_TOKEN).balanceOf(\n            address(this)\n        );\n        IERC20Upgradeable(TOKE_TOKEN).safeTransfer(\n            _claimAddress,\n            totalTokeAmount\n        );\n    }\n\n    /**\n        @notice sets the curve pool address\n        @param _curvePool uint\n     */\n    function setCurvePool(address _curvePool) external onlyOwner {\n        CURVE_POOL = _curvePool;\n        setToAndFromCurve();\n    }\n\n    /**\n        @notice sets the affiliate fee\n        @dev fee is set in basis points\n        @param _affiliateFee uint\n     */\n    function setAffiliateFee(uint256 _affiliateFee) external onlyOwner {\n        affiliateFee = _affiliateFee;\n        emit LogSetAffiliateFee(block.number, _affiliateFee);\n    }\n\n    /**\n        @notice sets the affiliate address to receive the affiliate fee in TOKE\n        @dev if set to 0x000.. then no affiliate will be sent\n        @param _affiliateAddress address\n     */\n    function setAffiliateAddress(address _affiliateAddress) external onlyOwner {\n        FEE_ADDRESS = _affiliateAddress;\n        emit LogSetAffiliateAddress(block.number, _affiliateAddress);\n    }\n\n    /**\n        @notice override whether or not staking is paused\n        @dev used to pause staking in case some attack vector becomes present\n        @param _shouldPause bool\n     */\n    function shouldPauseStaking(bool _shouldPause) public onlyOwner {\n        isStakingPaused = _shouldPause;\n        emit LogSetPauseStaking(block.number, _shouldPause);\n    }\n\n    /**\n        @notice override whether or not unstake & instantUnstake is paused\n        @dev used to pause unstake & instantUnstake in case some attack vector becomes present\n        @param _shouldPause bool\n     */\n    function shouldPauseUnstaking(bool _shouldPause) external onlyOwner {\n        isUnstakingPaused = _shouldPause;\n        emit LogSetPauseUnstaking(block.number, _shouldPause);\n    }\n\n    /**\n        @notice override whether or not instantUnstake is paused\n        @dev used to pause instantUnstake in case some attack vector becomes present\n        @param _shouldPause bool\n     */\n    function shouldPauseInstantUnstaking(bool _shouldPause) external onlyOwner {\n        isInstantUnstakingPaused = _shouldPause;\n        emit LogSetPauseInstantUnstaking(block.number, _shouldPause);\n    }\n\n    /**\n        @notice set epoch duration\n        @dev epoch's determine how long until a rebase can occur\n        @param duration uint\n     */\n    function setEpochDuration(uint256 duration) external onlyOwner {\n        epoch.duration = duration;\n        emit LogSetEpochDuration(block.number, duration);\n    }\n\n    /**\n     * @notice set warmup period for new stakers\n     * @param _vestingPeriod uint\n     */\n    function setWarmUpPeriod(uint256 _vestingPeriod) external onlyOwner {\n        warmUpPeriod = _vestingPeriod;\n        emit LogSetWarmUpPeriod(block.number, _vestingPeriod);\n    }\n\n    /**\n     * @notice set cooldown period for stakers\n     * @param _vestingPeriod uint\n     */\n    function setCoolDownPeriod(uint256 _vestingPeriod) external onlyOwner {\n        coolDownPeriod = _vestingPeriod;\n        emit LogSetCoolDownPeriod(block.number, _vestingPeriod);\n    }\n\n    /**\n        @notice sets the time before Tokemak cycle ends to requestWithdrawals\n        @dev requestWithdrawals is called once per cycle.\n        @dev this allows us to change how much time before the end of the cycle we send the withdraw requests\n        @param _timestamp uint - time before end of cycle\n     */\n    function setTimeLeftToRequestWithdrawal(uint256 _timestamp)\n        external\n        onlyOwner\n    {\n        timeLeftToRequestWithdrawal = _timestamp;\n    }\n\n    /**\n        @notice returns true if claim is available\n        @dev this shows whether or not our epoch's have passed\n        @param _recipient address - warmup address to check if claim is available\n        @return bool - true if available to claim\n     */\n    function _isClaimAvailable(address _recipient)\n        internal\n        view\n        returns (bool)\n    {\n        Claim memory info = warmUpInfo[_recipient];\n        return epoch.number >= info.expiry && info.expiry != 0;\n    }\n\n    /**\n        @notice returns true if claimWithdraw is available\n        @dev this shows whether or not our epoch's have passed as well as if the cycle has increased\n        @param _recipient address - address that's checking for available claimWithdraw\n        @return bool - true if available to claimWithdraw\n     */\n    function _isClaimWithdrawAvailable(address _recipient)\n        internal\n        returns (bool)\n    {\n        Claim memory info = coolDownInfo[_recipient];\n        ITokeManager tokeManager = ITokeManager(TOKE_MANAGER);\n        ITokePool tokePoolContract = ITokePool(TOKE_POOL);\n        RequestedWithdrawalInfo memory requestedWithdrawals = tokePoolContract\n            .requestedWithdrawals(address(this));\n        uint256 currentCycleIndex = tokeManager.getCurrentCycleIndex();\n        return\n            epoch.number >= info.expiry &&\n            info.expiry != 0 &&\n            info.amount != 0 &&\n            ((requestedWithdrawals.minCycle <= currentCycleIndex &&\n                requestedWithdrawals.amount + withdrawalAmount >=\n                info.amount) || withdrawalAmount >= info.amount);\n    }\n\n    /**\n        @notice withdraw stakingTokens from Tokemak\n        @dev needs a valid requestWithdrawal inside Tokemak with a completed cycle rollover to withdraw\n     */\n    function _withdrawFromTokemak() internal {\n        ITokePool tokePoolContract = ITokePool(TOKE_POOL);\n        ITokeManager tokeManager = ITokeManager(TOKE_MANAGER);\n        RequestedWithdrawalInfo memory requestedWithdrawals = tokePoolContract\n            .requestedWithdrawals(address(this));\n        uint256 currentCycleIndex = tokeManager.getCurrentCycleIndex();\n\n        if (\n            requestedWithdrawals.amount > 0 &&\n            requestedWithdrawals.minCycle <= currentCycleIndex\n        ) {\n            tokePoolContract.withdraw(requestedWithdrawals.amount);\n            requestWithdrawalAmount -= requestedWithdrawals.amount;\n            withdrawalAmount += requestedWithdrawals.amount;\n        }\n    }\n\n    /**\n        @notice creates a withdrawRequest with Tokemak\n        @dev requestedWithdraws take 1 tokemak cycle to be available for withdraw\n        @param _amount uint - amount to request withdraw\n     */\n    function _requestWithdrawalFromTokemak(uint256 _amount) internal {\n        ITokePool tokePoolContract = ITokePool(TOKE_POOL);\n        uint256 balance = ITokePool(TOKE_POOL).balanceOf(address(this));\n\n        // the only way balance < _amount is when using unstakeAllFromTokemak\n        uint256 amountToRequest = balance < _amount ? balance : _amount;\n\n        if (amountToRequest > 0) tokePoolContract.requestWithdrawal(_amount);\n    }\n\n    /**\n        @notice deposit stakingToken to tStakingToken Tokemak reactor\n        @param _amount uint - amount to deposit\n     */\n    function _depositToTokemak(uint256 _amount) internal {\n        ITokePool tokePoolContract = ITokePool(TOKE_POOL);\n        tokePoolContract.deposit(_amount);\n    }\n\n    /**\n        @notice gets balance of stakingToken that's locked into the TOKE stakingToken pool\n        @return uint - amount of stakingToken in TOKE pool\n     */\n    function _getTokemakBalance() internal view returns (uint256) {\n        ITokePool tokePoolContract = ITokePool(TOKE_POOL);\n        return tokePoolContract.balanceOf(address(this));\n    }\n\n    /**\n        @notice checks TOKE's cycleTime is within duration to batch the transactions\n        @dev this function returns true if we are within timeLeftToRequestWithdrawal of the end of the TOKE cycle\n        @dev as well as if the current cycle index is more than the last cycle index\n        @return bool - returns true if can batch transactions\n     */\n    function canBatchTransactions() public view returns (bool) {\n        ITokeManager tokeManager = ITokeManager(TOKE_MANAGER);\n        uint256 duration = tokeManager.getCycleDuration();\n        uint256 currentCycleStart = tokeManager.getCurrentCycle();\n        uint256 currentCycleIndex = tokeManager.getCurrentCycleIndex();\n        uint256 nextCycleStart = currentCycleStart + duration;\n\n        return\n            block.timestamp + timeLeftToRequestWithdrawal >= nextCycleStart &&\n            currentCycleIndex > lastTokeCycleIndex &&\n            requestWithdrawalAmount > 0;\n    }\n\n    /**\n        @notice owner function to requestWithdraw all FOX from tokemak in case of an attack on tokemak\n        @dev this bypasses the normal flow of sending a withdrawal request and allows the owner to requestWithdraw entire pool balance\n     */\n    function unstakeAllFromTokemak() public onlyOwner {\n        ITokePool tokePoolContract = ITokePool(TOKE_POOL);\n        uint256 tokePoolBalance = ITokePool(tokePoolContract).balanceOf(\n            address(this)\n        );\n        // pause any future staking\n        shouldPauseStaking(true);\n        requestWithdrawalAmount = tokePoolBalance;\n        _requestWithdrawalFromTokemak(tokePoolBalance);\n    }\n\n    /**\n        @notice sends batched requestedWithdrawals due to TOKE's requestWithdrawal overwriting the amount if you call it more than once per cycle\n     */\n    function sendWithdrawalRequests() public {\n        // check to see if near the end of a TOKE cycle\n        if (canBatchTransactions()) {\n            // if has withdrawal amount to be claimed then claim\n            _withdrawFromTokemak();\n\n            // if more requestWithdrawalAmount exists after _withdrawFromTokemak then request the new amount\n            ITokeManager tokeManager = ITokeManager(TOKE_MANAGER);\n            if (requestWithdrawalAmount > 0) {\n                _requestWithdrawalFromTokemak(requestWithdrawalAmount);\n            }\n\n            uint256 currentCycleIndex = tokeManager.getCurrentCycleIndex();\n            lastTokeCycleIndex = currentCycleIndex;\n        }\n    }\n\n    /**\n        @notice stake staking tokens to receive Yieldy tokens\n        @param _amount uint\n        @param _recipient address\n     */\n    function stake(uint256 _amount, address _recipient) public {\n        // if override staking, then don't allow stake\n        require(!isStakingPaused, \"Staking is paused\");\n        // amount must be non zero\n        require(_amount > 0, \"Must have valid amount\");\n\n        uint256 yieldyTotalSupply = IYieldy(YIELDY_TOKEN).totalSupply();\n\n        // Don't rebase unless tokens are already staked or could get locked out of staking\n        if (yieldyTotalSupply > 0) {\n            rebase();\n        }\n\n        IERC20Upgradeable(STAKING_TOKEN).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _amount\n        );\n\n        Claim storage info = warmUpInfo[_recipient];\n\n        // if claim is available then auto claim tokens\n        if (_isClaimAvailable(_recipient)) {\n            claim(_recipient);\n        }\n\n        _depositToTokemak(_amount);\n\n        // skip adding to warmup contract if period is 0\n        if (warmUpPeriod == 0) {\n            IYieldy(YIELDY_TOKEN).mint(_recipient, _amount);\n        } else {\n            // create a claim and mint tokens so a user can claim them once warm up has passed\n            warmUpInfo[_recipient] = Claim({\n                amount: info.amount + _amount,\n                credits: info.credits +\n                    IYieldy(YIELDY_TOKEN).creditsForTokenBalance(_amount),\n                expiry: epoch.number + warmUpPeriod\n            });\n\n            IYieldy(YIELDY_TOKEN).mint(address(this), _amount);\n        }\n\n        sendWithdrawalRequests();\n    }\n\n    /**\n        @notice call stake with msg.sender\n        @param _amount uint\n     */\n    function stake(uint256 _amount) external {\n        stake(_amount, msg.sender);\n    }\n\n    /**\n        @notice retrieve reward tokens from warmup\n        @dev if user has funds in warmup then user is able to claim them (including rewards)\n        @param _recipient address\n     */\n    function claim(address _recipient) public {\n        Claim memory info = warmUpInfo[_recipient];\n        if (_isClaimAvailable(_recipient)) {\n            delete warmUpInfo[_recipient];\n\n            if (info.credits > 0) {\n                IYieldy(YIELDY_TOKEN).transfer(\n                    _recipient,\n                    IYieldy(YIELDY_TOKEN).tokenBalanceForCredits(info.credits)\n                );\n            }\n        }\n    }\n\n    /**\n        @notice claims staking tokens after cooldown period\n        @dev if user has a cooldown claim that's past expiry then withdraw staking tokens from tokemak\n        @dev and send them to user\n        @param _recipient address - users unstaking address\n     */\n    function claimWithdraw(address _recipient) public {\n        Claim memory info = coolDownInfo[_recipient];\n        uint256 totalAmountIncludingRewards = IYieldy(YIELDY_TOKEN)\n            .tokenBalanceForCredits(info.credits);\n        if (_isClaimWithdrawAvailable(_recipient)) {\n            // if has withdrawalAmount to be claimed, then claim\n            _withdrawFromTokemak();\n            delete coolDownInfo[_recipient];\n\n            withdrawalAmount -= info.amount;\n\n            // only give amount from when they requested withdrawal since this amount wasn't used in generating rewards\n            // this will later be given to users through addRewardsForStakers\n            IERC20Upgradeable(STAKING_TOKEN).safeTransfer(\n                _recipient,\n                info.amount\n            );\n\n            IYieldy(YIELDY_TOKEN).burn(\n                address(this),\n                totalAmountIncludingRewards\n            );\n        }\n    }\n\n    /**\n        @notice gets reward tokens either from the warmup pool or user's wallet or both\n        @dev when transferring reward tokens the user could have their balance still in the warmup pool\n        @dev this function abstracts the logic to find the correct amount of tokens to use them\n        @param _amount uint\n        @param _user address to pull funds from \n     */\n    function _retrieveBalanceFromUser(uint256 _amount, address _user) internal {\n        Claim memory userWarmInfo = warmUpInfo[_user];\n        uint256 walletBalance = IERC20Upgradeable(YIELDY_TOKEN).balanceOf(\n            _user\n        );\n        uint256 warmUpBalance = IYieldy(YIELDY_TOKEN).tokenBalanceForCredits(\n            userWarmInfo.credits\n        );\n\n        // must have enough funds between wallet and warmup\n        require(\n            _amount <= walletBalance + warmUpBalance,\n            \"Insufficient Balance\"\n        );\n\n        uint256 amountLeft = _amount;\n        if (warmUpBalance > 0) {\n            // remove from warmup first.\n            if (_amount >= warmUpBalance) {\n                // use the entire warmup balance\n                unchecked {\n                    amountLeft -= warmUpBalance;\n                }\n                delete warmUpInfo[_user];\n            } else {\n                // partially consume warmup balance\n                amountLeft = 0;\n                uint256 remainingCreditsAmount = userWarmInfo.credits -\n                    IYieldy(YIELDY_TOKEN).creditsForTokenBalance(_amount);\n                uint256 remainingAmount = IYieldy(YIELDY_TOKEN)\n                    .tokenBalanceForCredits(remainingCreditsAmount);\n\n                warmUpInfo[_user] = Claim({\n                    amount: remainingAmount,\n                    credits: remainingCreditsAmount,\n                    expiry: userWarmInfo.expiry\n                });\n            }\n        }\n\n        if (amountLeft != 0) {\n            // transfer the rest from the users address\n            IERC20Upgradeable(YIELDY_TOKEN).safeTransferFrom(\n                _user,\n                address(this),\n                amountLeft\n            );\n        }\n    }\n\n    /**\n        @notice instant unstakes from liquidity reserve\n        @param _amount uint - amount to instant unstake\n     */\n    function instantUnstakeReserve(uint256 _amount) external {\n        require(_amount > 0, \"Invalid amount\");\n        // prevent unstaking if override due to vulnerabilities\n        require(\n            !isUnstakingPaused && !isInstantUnstakingPaused,\n            \"Unstaking is paused\"\n        );\n\n        rebase();\n        _retrieveBalanceFromUser(_amount, msg.sender);\n\n        uint256 reserveBalance = IERC20Upgradeable(STAKING_TOKEN).balanceOf(\n            LIQUIDITY_RESERVE\n        );\n\n        require(reserveBalance >= _amount, \"Not enough funds in reserve\");\n\n        ILiquidityReserve(LIQUIDITY_RESERVE).instantUnstake(\n            _amount,\n            msg.sender\n        );\n    }\n\n    /**\n        @notice instant unstake from curve\n        @param _amount uint - amount to instant unstake\n        @param _minAmount uint - minimum amount with slippage to instant unstake\n        @return uint - amount received\n     */\n    function instantUnstakeCurve(uint256 _amount, uint256 _minAmount)\n        external\n        returns (uint256)\n    {\n        require(_amount > 0, \"Invalid amount\");\n        require(\n            CURVE_POOL != address(0) &&\n                (curvePoolFrom == 1 || curvePoolTo == 1),\n            \"Invalid Curve Pool\"\n        );\n        // prevent unstaking if override due to vulnerabilities\n        require(\n            !isUnstakingPaused && !isInstantUnstakingPaused,\n            \"Unstaking is paused\"\n        );\n\n        rebase();\n        _retrieveBalanceFromUser(_amount, msg.sender);\n\n        return\n            ICurvePool(CURVE_POOL).exchange(\n                curvePoolFrom,\n                curvePoolTo,\n                _amount,\n                _minAmount,\n                msg.sender\n            );\n    }\n\n    /**\n        @notice sets to and from coin indexes for curve exchange\n     */\n    function setToAndFromCurve() internal {\n        if (CURVE_POOL != address(0)) {\n            address address0 = ICurvePool(CURVE_POOL).coins(0);\n            address address1 = ICurvePool(CURVE_POOL).coins(1);\n            int128 from = 0;\n            int128 to = 0;\n\n            if (TOKE_POOL == address0 && STAKING_TOKEN == address1) {\n                to = 1;\n            } else if (TOKE_POOL == address1 && STAKING_TOKEN == address0) {\n                from = 1;\n            }\n            require(from == 1 || to == 1, \"Invalid Curve Pool\");\n\n            curvePoolFrom = from;\n            curvePoolTo = to;\n\n            emit LogSetCurvePool(CURVE_POOL, curvePoolTo, curvePoolFrom);\n        }\n    }\n\n    /**\n        @notice estimate received using instant unstake from curve\n        @param _amount uint - amount to instant unstake\n        @return uint - estimated amount received\n     */\n    function estimateInstantCurve(uint256 _amount)\n        external\n        view\n        returns (uint256)\n    {\n        return\n            ICurvePool(CURVE_POOL).get_dy(curvePoolFrom, curvePoolTo, _amount);\n    }\n\n    /**\n        @notice redeem Yieldy tokens for staking tokens with a vesting period based on coolDownPeriod\n        @dev this function will retrieve the _amount of Yieldy tokens from the user and transfer them to the cooldown contract.\n        @dev once the period has expired the user will be able to withdraw their staking tokens\n        @param _amount uint - amount of tokens to unstake\n        @param _trigger bool - should trigger a rebase\n     */\n    function unstake(uint256 _amount, bool _trigger) external {\n        // prevent unstaking if override due to vulnerabilities asdf\n        require(!isUnstakingPaused, \"Unstaking is paused\");\n        if (_trigger) {\n            rebase();\n        }\n        _retrieveBalanceFromUser(_amount, msg.sender);\n\n        Claim storage userCoolInfo = coolDownInfo[msg.sender];\n\n        // try to claim withdraw if user has withdraws to claim function will check if withdraw is valid\n        claimWithdraw(msg.sender);\n\n        coolDownInfo[msg.sender] = Claim({\n            amount: userCoolInfo.amount + _amount,\n            credits: userCoolInfo.credits +\n                IYieldy(YIELDY_TOKEN).creditsForTokenBalance(_amount),\n            expiry: epoch.number + coolDownPeriod\n        });\n\n        requestWithdrawalAmount += _amount;\n        sendWithdrawalRequests();\n    }\n\n    /**\n        @notice trigger rebase if epoch has ended\n     */\n    function rebase() public {\n        // we know about the issues surrounding block.timestamp, using it here will not cause any problems\n        if (epoch.endTime <= block.timestamp) {\n            IYieldy(YIELDY_TOKEN).rebase(epoch.distribute, epoch.number);\n\n            epoch.endTime = epoch.endTime + epoch.duration;\n            epoch.timestamp = block.timestamp;\n            epoch.number++;\n\n            uint256 balance = contractBalance();\n            uint256 staked = IYieldy(YIELDY_TOKEN).totalSupply();\n\n            if (balance <= staked) {\n                epoch.distribute = 0;\n            } else {\n                epoch.distribute = balance - staked;\n            }\n        }\n    }\n\n    /**\n        @notice returns contract staking tokens holdings \n        @dev gets amount of staking tokens that are a part of this system to calculate rewards\n        @dev the staking tokens will be included in this contract plus inside tokemak\n        @return uint - amount of staking tokens\n     */\n    function contractBalance() internal view returns (uint256) {\n        uint256 tokeBalance = _getTokemakBalance();\n        return\n            IERC20Upgradeable(STAKING_TOKEN).balanceOf(address(this)) +\n            tokeBalance;\n    }\n\n    /**\n     * @notice adds staking tokens for rebase rewards\n     * @dev this is the function that gives rewards so the rebase function can distribute profits to reward token holders\n     * @param _amount uint - amount of tokens to add to rewards\n     * @param _shouldTransfer bool - should transfer tokens before adding rewards\n     * @param _trigger bool - should trigger rebase\n     */\n    function addRewardsForStakers(\n        uint256 _amount,\n        bool _shouldTransfer,\n        bool _trigger\n    ) external {\n        if (_shouldTransfer) {\n            IERC20Upgradeable(STAKING_TOKEN).safeTransferFrom(\n                msg.sender,\n                address(this),\n                _amount\n            );\n        }\n\n        // deposit all staking tokens held in contract to Tokemak minus tokens waiting for claimWithdraw\n        uint256 stakingTokenBalance = IERC20Upgradeable(STAKING_TOKEN)\n            .balanceOf(address(this));\n        uint256 amountToDeposit = stakingTokenBalance - withdrawalAmount;\n        _depositToTokemak(amountToDeposit);\n\n        if (_trigger) {\n            rebase();\n        }\n    }\n\n    /**\n     * @notice trades rewards generated from claimFromTokemak for staking token\n     * @dev this is function is called from claimFromTokemak if the autoRebase bool is set to true\n     */\n    function preSign(bytes calldata orderUid) external onlyOwner {\n        ICowSettlement(COW_SETTLEMENT).setPreSignature(orderUid, true);\n    }\n}"
    }
  ]
}