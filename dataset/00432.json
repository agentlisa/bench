{
  "Title": "M-13: StargateRouter cannot send payloads and rebalancing of ERC20s is broken",
  "Content": "# Issue M-13: StargateRouter cannot send payloads and rebalancing of ERC20s is broken \n\nSource: https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/68 \n\nThe protocol has acknowledged this issue.\n\n## Found by \nGiuseppeDeLaZara\n## Summary\nThe `Balancer.sol` contract can't perform the rebalancing of ERC20s across chains as the Stargate router is not able to send any payload and will immediately revert the transaction if a payload is included. In this instance payload is hardcoded to `\"0x\"`. \n\n## Vulnerability Detail\n`Balancer.sol` contract has a `rebalance` function that is supposed to perform a rebalancing of `mTOFTs` across chains. \nIn case the token being transferred through Stargate is an ERC20 it is using the Stargate router to initiate the transfer.\nThe issue however is that the stargate router is not able to send any payload and will immediately revert the transaction if a payload is included.\n\nIf we take a look at the code, there is a payload equal to [\"0x\"](https://github.com/sherlock-audit/2024-02-tapioca/blob/dc2464f420927409a67763de6ec60fe5c028ab0e/TapiocaZ/contracts/Balancer.sol#L318) being sent with the transaction:\n\n```solidity\n## Balancer.sol\n\n    router.swap{value: msg.value}(\n        _dstChainId,\n        _srcPoolId,\n        _dstPoolId,\n        payable(this),\n        _amount,\n        _computeMinAmount(_amount, _slippage),\n        IStargateRouterBase.lzTxObj({dstGasForCall: 0, dstNativeAmount: 0, dstNativeAddr: \"0x0\"}),\n        _dst,\n>>>>    \"0x\" => this is the payload that is being sent with the transaction\n    );\n```\n\nAs a proof of concept we can try to send a payload through the stargate router on a forked network and see that the transaction will revert.\np.s. make sure to run on it on a forked network on Ethereum mainnet.\n\n```solidity\nfunction testStargateRouterReverting() public {\n    vm.createSelectFork(vm.envString(\"MAINNET_RPC_URL\"));\n    \n    address stargateRouter = 0x8731d54E9D02c286767d56ac03e8037C07e01e98;\n    address DAIWhale = 0x7A8EDc710dDEAdDDB0B539DE83F3a306A621E823;\n    address DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    IStargateRouter.lzTxObj memory lzTxParams = IStargateRouter.lzTxObj(0, 0, \"0x00\");\n\n    vm.startPrank(DAIWhale);\n    vm.deal(DAIWhale, 5 ether);\n    IERC20(DAI).approve(stargateRouter, 1e18);\n    IStargateRouter(stargateRouter).swap{value: 1 ether}(\n        111, 3, 3, payable(address(this)), 1e18, 1, lzTxParams, abi.encode(address(this)), \"0x\"\n    );\n}\n```\n\nIt fails with the following error:\n<img width=\"530\" alt=\"Screenshot 2024-03-11 at 11 52 31\" src=\"https://github.com/sherlock-audit/2024-02-tapioca-windhustler/assets/38017754/d228807a-d94c-4298-b00c-e975d039252d\">\n\nProof of concept was tested on Ethereum network, but it applies to all the other blockchains as well. \n\nBy looking at the Stargate documentation we can see that it is highlighted to use the `StargateComposer` instead of the `StargateRouter` if sending payloads: https://stargateprotocol.gitbook.io/stargate/stargate-composability.\n\nBoth StargateRouter and StargateComposer have the `swap` interface, but the intention was to use the `StargateRouter` which can be observed by the [`retryRevert`](https://github.com/sherlock-audit/2024-02-tapioca/blob/dc2464f420927409a67763de6ec60fe5c028ab0e/TapiocaZ/contracts/Balancer.sol#L262-#L264) function in the `Balancer.sol` contract.\n\n```solidity\n## Balancer.sol\n\nfunction retryRevert(uint16 _srcChainId, bytes calldata _srcAddress, uint256 _nonce) external payable onlyOwner {\n    router.retryRevert{value: msg.value}(_srcChainId, _srcAddress, _nonce);\n}\n```\n\nStargateComposer does not have the `retryRevert` function. Its code be found here: https://www.codeslaw.app/contracts/ethereum/0xeCc19E177d24551aA7ed6Bc6FE566eCa726CC8a9.\n\nAs this makes the rebalancing of `mTOFTs` broken, I'm marking this as a high-severity issue.\n\n## Impact\n\nRebalancing of `mTOFTs` across chains is broken and as it is one of the main functionalities of the protocol, this is a high-severity issue.\n## Code Snippet\n- https://github.com/sherlock-audit/2024-02-tapioca/blob/dc2464f420927409a67763de6ec60fe5c028ab0e/TapiocaZ/contracts/Balancer.sol#L318\n\n## Tool used\n\nManual Review\n\n## Recommendation\nUse the `StargateComposer` instead of the `StargateRouter` if sending payloads.\n\n\n\n## Discussion\n\n**cryptotechmaker**\n\nInvalid; Duplicate of https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/69\n\n**windhustler**\n\nFor sending ERC20s with Stargate you need to use the [`StargateComposer`](https://etherscan.io/address/0xeCc19E177d24551aA7ed6Bc6FE566eCa726CC8a9#code) contract and not the `StargateRouter`. \nAs `StargateComposer` doesn't have the `retryRevert` function you should remove it from the `Balancer.sol`. \n\n**nevillehuang**\n\n@0xRektora @cryptotechmaker Might want to take a look, but seems like the same underlying root cause related to configuration of stargaterouter. I checked the composer contract and I believe @windhustler is right. I am also inclined to think they are not duplicates. Let me know if I am missing something.\n\n**cryptotechmaker**\n\n@nevillehuang  It's duplicate in the sense that #69 mentioned an issue that's being fixed by using StargateComposer, which is the same solution for this one\n\nPlease lmk if otherwise\n\n**nevillehuang**\n\nHi @cryptotechmaker consulted tapioca's internal judge @cvetanovv and agree although fixes are similar, different funcitonalities are impacted and so it can be seen as two separate fixes combined into one, so will be separating this from #69 \n\n**cryptotechmaker**\n\n@nevillehuang Sure! However, there's not going to be any PR for the issue as we plan to use StargateComposer\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/170",
  "Code": [
    {
      "filename": "TapiocaZ/contracts/Balancer.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Tapioca\nimport {IStargateRouter, IStargateRouterBase} from \"tapioca-periph/interfaces/external/stargate/IStargateRouter.sol\";\nimport {IStargateEthVault} from \"tapioca-periph/interfaces/external/stargate/IStargateEthVault.sol\";\nimport {ITOFTVault} from \"tapioca-periph/interfaces/tapiocaz/ITOFTVault.sol\";\nimport {ITOFT} from \"tapioca-periph/interfaces/oft/ITOFT.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title Balancer\n * @author TapiocaDAO\n * @notice Rebalances mTOFT by transferring underlying tokens to other layers through Stargate\n */\ncontract Balancer is Ownable {\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice current OFT => chain => destination OFT\n     * @dev chain ids (https://stargateprotocol.gitbook.io/stargate/developers/chain-ids):\n     *         - Ethereum: 101\n     *         - BNB: 102\n     *         - Avalanche: 106\n     *         - Polygon: 109\n     *         - Arbitrum: 110\n     *         - Optimism: 111\n     *         - Fantom: 112\n     *         - Metis: 151\n     *     pool ids https://stargateprotocol.gitbook.io/stargate/developers/pool-ids\n     */\n    mapping(address => mapping(uint16 => OFTData)) public connectedOFTs;\n\n    struct OFTData {\n        uint256 srcPoolId;\n        uint256 dstPoolId;\n        address dstOft;\n        uint256 rebalanceable;\n    }\n\n    IStargateRouter public immutable routerETH;\n    IStargateRouter public immutable router;\n\n    address public rebalancer;\n\n    // @dev swapEth is not available on some chains\n    bool public disableEth;\n\n    event ConnectedChainUpdated(address indexed _srcOft, uint16 indexed _dstChainId, address indexed _dstOft);\n    event Rebalanced(\n        address indexed _srcOft, uint16 indexed _dstChainId, uint256 indexed _slippage, uint256 _amount, bool _isNative\n    );\n    event RebalanceAmountUpdated(\n        address indexed _srcOft, uint16 indexed _dstChainId, uint256 indexed _amount, uint256 _totalAmount\n    );\n    event ToggledSwapEth(bool indexed _old, bool indexed _new);\n    event EmergencySaved(address indexed _token, uint256 indexed _amount, bool indexed _native);\n    event RebalancerUpdated(address indexed prev, address indexed current);\n\n    error NotAuthorized();\n    error RouterNotValid();\n    error ExceedsBalance();\n    error DestinationNotValid();\n    error SlippageNotValid();\n    error FeeAmountNotSet();\n    error PoolInfoRequired();\n    error RebalanceAmountNotSet();\n    error Failed();\n    error SwapNotEnabled();\n    error AlreadyInitialized();\n    error RebalanceAmountNotValid();\n\n    modifier onlyValidDestination(address _srcOft, uint16 _dstChainId) {\n        if (connectedOFTs[_srcOft][_dstChainId].dstOft == address(0)) {\n            revert DestinationNotValid();\n        }\n        _;\n    }\n\n    modifier onlyValidSlippage(uint256 _slippage) {\n        // @dev a slippage higher than 20% shouldn't be necessary\n        if (_slippage >= 2e4) revert SlippageNotValid();\n        _;\n    }\n\n    constructor(address _routerETH, address _router, address _owner) {\n        if (_router == address(0)) revert RouterNotValid();\n        if (_routerETH == address(0)) revert RouterNotValid();\n        routerETH = IStargateRouter(_routerETH);\n        router = IStargateRouter(_router);\n\n        transferOwnership(_owner);\n        rebalancer = _owner;\n        emit RebalancerUpdated(address(0), _owner);\n    }\n\n    receive() external payable {}\n\n    /// =====================\n    /// View\n    /// =====================\n    function checker(address payable _srcOft, uint16 _dstChainId, uint256 _slippage)\n        external\n        view\n        returns (bool canExec, bytes memory execPayload)\n    {\n        bytes memory ercData;\n        {\n            if (ITOFT(_srcOft).erc20() != address(0)) {\n                ercData = abi.encode(\n                    connectedOFTs[_srcOft][_dstChainId].srcPoolId, connectedOFTs[_srcOft][_dstChainId].dstPoolId\n                );\n            }\n        }\n\n        canExec = connectedOFTs[_srcOft][_dstChainId].rebalanceable > 0;\n        execPayload = abi.encodeCall(\n            Balancer.rebalance,\n            (_srcOft, _dstChainId, _slippage, connectedOFTs[_srcOft][_dstChainId].rebalanceable, ercData)\n        );\n    }\n\n    /// =====================\n    /// Owner\n    /// =====================\n\n    /**\n     * @notice set rebalancer role\n     * @param _addr the new address\n     */\n    function setRebalancer(address _addr) external onlyOwner {\n        rebalancer = _addr;\n        emit RebalancerUpdated(rebalancer, _addr);\n    }\n\n    /**\n     * @notice toggle swap eth\n     * @param _val true/false\n     */\n    function setSwapEth(bool _val) external onlyOwner {\n        emit ToggledSwapEth(disableEth, _val);\n        disableEth = _val;\n    }\n\n    /**\n     * @notice performs a rebalance operation\n     * @dev callable only by the owner\n     * @param _srcOft the source TOFT address\n     * @param _dstChainId the destination LayerZero id\n     * @param _slippage the destination LayerZero id\n     * @param _amount the rebalanced amount\n     * @param _ercData custom send data\n     */\n    function rebalance(\n        address payable _srcOft,\n        uint16 _dstChainId,\n        uint256 _slippage,\n        uint256 _amount,\n        bytes memory _ercData\n    ) external payable onlyValidDestination(_srcOft, _dstChainId) onlyValidSlippage(_slippage) {\n        if (msg.sender != owner() || msg.sender != rebalancer) revert NotAuthorized();\n\n        if (connectedOFTs[_srcOft][_dstChainId].rebalanceable < _amount) {\n            revert RebalanceAmountNotSet();\n        }\n\n        //extract\n        ITOFT(_srcOft).extractUnderlying(_amount);\n\n        //send\n        {\n            bool _isNative = ITOFT(_srcOft).erc20() == address(0);\n            if (msg.value == 0) revert FeeAmountNotSet();\n            if (_isNative) {\n                if (disableEth) revert SwapNotEnabled();\n                _sendNative(_srcOft, _amount, _dstChainId, _slippage);\n            } else {\n                _sendToken(_srcOft, _amount, _dstChainId, _slippage, _ercData);\n            }\n\n            connectedOFTs[_srcOft][_dstChainId].rebalanceable -= _amount;\n            emit Rebalanced(_srcOft, _dstChainId, _slippage, _amount, _isNative);\n        }\n    }\n\n    /**\n     * @notice saves token/native gas from this contract\n     * @param _token the token address; `address(0)` should be passed for the Native coin\n     * @param _amount the amount to be saved\n     */\n    function emergencySaveTokens(address _token, uint256 _amount) external onlyOwner {\n        if (_token == address(0)) {\n            (bool sent,) = msg.sender.call{value: _amount}(\"\");\n            if (!sent) revert Failed();\n            emit EmergencySaved(_token, _amount, true);\n        } else {\n            IERC20(_token).safeTransfer(msg.sender, _amount);\n            emit EmergencySaved(_token, _amount, false);\n        }\n    }\n\n    /**\n     * @notice registeres mTapiocaOFT for rebalancing\n     * @param _srcOft the source TOFT address\n     * @param _dstChainId the destination LayerZero id\n     * @param _dstOft the destination TOFT address\n     * @param _ercData custom send data\n     */\n    function initConnectedOFT(address _srcOft, uint16 _dstChainId, address _dstOft, bytes memory _ercData)\n        external\n        onlyOwner\n    {\n        if (connectedOFTs[_srcOft][_dstChainId].rebalanceable > 0) {\n            revert AlreadyInitialized();\n        }\n        bool isNative = ITOFT(_srcOft).erc20() == address(0);\n        if (!isNative && _ercData.length == 0) revert PoolInfoRequired();\n\n        (uint256 _srcPoolId, uint256 _dstPoolId) = abi.decode(_ercData, (uint256, uint256));\n\n        OFTData memory oftData =\n            OFTData({srcPoolId: _srcPoolId, dstPoolId: _dstPoolId, dstOft: _dstOft, rebalanceable: 0});\n\n        connectedOFTs[_srcOft][_dstChainId] = oftData;\n        emit ConnectedChainUpdated(_srcOft, _dstChainId, _dstOft);\n    }\n\n    /**\n     * @notice assings more rebalanceable amount for TOFT\n     * @param _srcOft the source TOFT address\n     * @param _dstChainId the destination LayerZero id\n     * @param _amount the rebalanced amount\n     */\n    function addRebalanceAmount(address _srcOft, uint16 _dstChainId, uint256 _amount)\n        external\n        onlyValidDestination(_srcOft, _dstChainId)\n        onlyOwner\n    {\n        connectedOFTs[_srcOft][_dstChainId].rebalanceable += _amount;\n        uint256 totalToftSupply = ITOFTVault(ITOFT(_srcOft).vault()).viewSupply();\n        if (connectedOFTs[_srcOft][_dstChainId].rebalanceable > totalToftSupply) {\n            revert RebalanceAmountNotValid();\n        }\n        emit RebalanceAmountUpdated(_srcOft, _dstChainId, _amount, connectedOFTs[_srcOft][_dstChainId].rebalanceable);\n    }\n\n    function retryRevert(uint16 _srcChainId, bytes calldata _srcAddress, uint256 _nonce) external payable onlyOwner {\n        router.retryRevert{value: msg.value}(_srcChainId, _srcAddress, _nonce);\n    }\n\n    /// =====================\n    /// Private\n    /// =====================\n    function _sendNative(address payable _oft, uint256 _amount, uint16 _dstChainId, uint256 _slippage) private {\n        if (address(this).balance < _amount) revert ExceedsBalance();\n        uint256 valueAmount = msg.value + _amount;\n        routerETH.swapETH{value: valueAmount}(\n            _dstChainId,\n            payable(this),\n            abi.encodePacked(connectedOFTs[_oft][_dstChainId].dstOft),\n            _amount,\n            _computeMinAmount(_amount, _slippage)\n        );\n    }\n\n    function _sendToken(\n        address payable _oft,\n        uint256 _amount,\n        uint16 _dstChainId,\n        uint256 _slippage,\n        bytes memory _data\n    ) private {\n        address erc20 = ITOFT(_oft).erc20();\n        if (IERC20Metadata(erc20).balanceOf(address(this)) < _amount) {\n            revert ExceedsBalance();\n        }\n        {\n            (uint256 _srcPoolId, uint256 _dstPoolId) = abi.decode(_data, (uint256, uint256));\n            _routerSwap(_dstChainId, _srcPoolId, _dstPoolId, _amount, _slippage, _oft, erc20);\n        }\n    }\n\n    function _routerSwap(\n        uint16 _dstChainId,\n        uint256 _srcPoolId,\n        uint256 _dstPoolId,\n        uint256 _amount,\n        uint256 _slippage,\n        address payable _oft,\n        address _erc20\n    ) private {\n        bytes memory _dst = abi.encodePacked(connectedOFTs[_oft][_dstChainId].dstOft);\n        IERC20(_erc20).safeApprove(address(router), _amount);\n        router.swap{value: msg.value}(\n            _dstChainId,\n            _srcPoolId,\n            _dstPoolId,\n            payable(this),\n            _amount,\n            _computeMinAmount(_amount, _slippage),\n            IStargateRouterBase.lzTxObj({dstGasForCall: 0, dstNativeAmount: 0, dstNativeAddr: \"0x0\"}),\n            _dst,\n            \"0x\"\n        );\n    }\n\n    function _computeMinAmount(uint256 _amount, uint256 _slippage) private pure returns (uint256) {\n        return _amount - ((_amount * _slippage) / 1e5);\n    }\n}"
    },
    {
      "filename": "TapiocaZ/contracts/Balancer.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Tapioca\nimport {IStargateRouter, IStargateRouterBase} from \"tapioca-periph/interfaces/external/stargate/IStargateRouter.sol\";\nimport {IStargateEthVault} from \"tapioca-periph/interfaces/external/stargate/IStargateEthVault.sol\";\nimport {ITOFTVault} from \"tapioca-periph/interfaces/tapiocaz/ITOFTVault.sol\";\nimport {ITOFT} from \"tapioca-periph/interfaces/oft/ITOFT.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title Balancer\n * @author TapiocaDAO\n * @notice Rebalances mTOFT by transferring underlying tokens to other layers through Stargate\n */\ncontract Balancer is Ownable {\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice current OFT => chain => destination OFT\n     * @dev chain ids (https://stargateprotocol.gitbook.io/stargate/developers/chain-ids):\n     *         - Ethereum: 101\n     *         - BNB: 102\n     *         - Avalanche: 106\n     *         - Polygon: 109\n     *         - Arbitrum: 110\n     *         - Optimism: 111\n     *         - Fantom: 112\n     *         - Metis: 151\n     *     pool ids https://stargateprotocol.gitbook.io/stargate/developers/pool-ids\n     */\n    mapping(address => mapping(uint16 => OFTData)) public connectedOFTs;\n\n    struct OFTData {\n        uint256 srcPoolId;\n        uint256 dstPoolId;\n        address dstOft;\n        uint256 rebalanceable;\n    }\n\n    IStargateRouter public immutable routerETH;\n    IStargateRouter public immutable router;\n\n    address public rebalancer;\n\n    // @dev swapEth is not available on some chains\n    bool public disableEth;\n\n    event ConnectedChainUpdated(address indexed _srcOft, uint16 indexed _dstChainId, address indexed _dstOft);\n    event Rebalanced(\n        address indexed _srcOft, uint16 indexed _dstChainId, uint256 indexed _slippage, uint256 _amount, bool _isNative\n    );\n    event RebalanceAmountUpdated(\n        address indexed _srcOft, uint16 indexed _dstChainId, uint256 indexed _amount, uint256 _totalAmount\n    );\n    event ToggledSwapEth(bool indexed _old, bool indexed _new);\n    event EmergencySaved(address indexed _token, uint256 indexed _amount, bool indexed _native);\n    event RebalancerUpdated(address indexed prev, address indexed current);\n\n    error NotAuthorized();\n    error RouterNotValid();\n    error ExceedsBalance();\n    error DestinationNotValid();\n    error SlippageNotValid();\n    error FeeAmountNotSet();\n    error PoolInfoRequired();\n    error RebalanceAmountNotSet();\n    error Failed();\n    error SwapNotEnabled();\n    error AlreadyInitialized();\n    error RebalanceAmountNotValid();\n\n    modifier onlyValidDestination(address _srcOft, uint16 _dstChainId) {\n        if (connectedOFTs[_srcOft][_dstChainId].dstOft == address(0)) {\n            revert DestinationNotValid();\n        }\n        _;\n    }\n\n    modifier onlyValidSlippage(uint256 _slippage) {\n        // @dev a slippage higher than 20% shouldn't be necessary\n        if (_slippage >= 2e4) revert SlippageNotValid();\n        _;\n    }\n\n    constructor(address _routerETH, address _router, address _owner) {\n        if (_router == address(0)) revert RouterNotValid();\n        if (_routerETH == address(0)) revert RouterNotValid();\n        routerETH = IStargateRouter(_routerETH);\n        router = IStargateRouter(_router);\n\n        transferOwnership(_owner);\n        rebalancer = _owner;\n        emit RebalancerUpdated(address(0), _owner);\n    }\n\n    receive() external payable {}\n\n    /// =====================\n    /// View\n    /// =====================\n    function checker(address payable _srcOft, uint16 _dstChainId, uint256 _slippage)\n        external\n        view\n        returns (bool canExec, bytes memory execPayload)\n    {\n        bytes memory ercData;\n        {\n            if (ITOFT(_srcOft).erc20() != address(0)) {\n                ercData = abi.encode(\n                    connectedOFTs[_srcOft][_dstChainId].srcPoolId, connectedOFTs[_srcOft][_dstChainId].dstPoolId\n                );\n            }\n        }\n\n        canExec = connectedOFTs[_srcOft][_dstChainId].rebalanceable > 0;\n        execPayload = abi.encodeCall(\n            Balancer.rebalance,\n            (_srcOft, _dstChainId, _slippage, connectedOFTs[_srcOft][_dstChainId].rebalanceable, ercData)\n        );\n    }\n\n    /// =====================\n    /// Owner\n    /// =====================\n\n    /**\n     * @notice set rebalancer role\n     * @param _addr the new address\n     */\n    function setRebalancer(address _addr) external onlyOwner {\n        rebalancer = _addr;\n        emit RebalancerUpdated(rebalancer, _addr);\n    }\n\n    /**\n     * @notice toggle swap eth\n     * @param _val true/false\n     */\n    function setSwapEth(bool _val) external onlyOwner {\n        emit ToggledSwapEth(disableEth, _val);\n        disableEth = _val;\n    }\n\n    /**\n     * @notice performs a rebalance operation\n     * @dev callable only by the owner\n     * @param _srcOft the source TOFT address\n     * @param _dstChainId the destination LayerZero id\n     * @param _slippage the destination LayerZero id\n     * @param _amount the rebalanced amount\n     * @param _ercData custom send data\n     */\n    function rebalance(\n        address payable _srcOft,\n        uint16 _dstChainId,\n        uint256 _slippage,\n        uint256 _amount,\n        bytes memory _ercData\n    ) external payable onlyValidDestination(_srcOft, _dstChainId) onlyValidSlippage(_slippage) {\n        if (msg.sender != owner() || msg.sender != rebalancer) revert NotAuthorized();\n\n        if (connectedOFTs[_srcOft][_dstChainId].rebalanceable < _amount) {\n            revert RebalanceAmountNotSet();\n        }\n\n        //extract\n        ITOFT(_srcOft).extractUnderlying(_amount);\n\n        //send\n        {\n            bool _isNative = ITOFT(_srcOft).erc20() == address(0);\n            if (msg.value == 0) revert FeeAmountNotSet();\n            if (_isNative) {\n                if (disableEth) revert SwapNotEnabled();\n                _sendNative(_srcOft, _amount, _dstChainId, _slippage);\n            } else {\n                _sendToken(_srcOft, _amount, _dstChainId, _slippage, _ercData);\n            }\n\n            connectedOFTs[_srcOft][_dstChainId].rebalanceable -= _amount;\n            emit Rebalanced(_srcOft, _dstChainId, _slippage, _amount, _isNative);\n        }\n    }\n\n    /**\n     * @notice saves token/native gas from this contract\n     * @param _token the token address; `address(0)` should be passed for the Native coin\n     * @param _amount the amount to be saved\n     */\n    function emergencySaveTokens(address _token, uint256 _amount) external onlyOwner {\n        if (_token == address(0)) {\n            (bool sent,) = msg.sender.call{value: _amount}(\"\");\n            if (!sent) revert Failed();\n            emit EmergencySaved(_token, _amount, true);\n        } else {\n            IERC20(_token).safeTransfer(msg.sender, _amount);\n            emit EmergencySaved(_token, _amount, false);\n        }\n    }\n\n    /**\n     * @notice registeres mTapiocaOFT for rebalancing\n     * @param _srcOft the source TOFT address\n     * @param _dstChainId the destination LayerZero id\n     * @param _dstOft the destination TOFT address\n     * @param _ercData custom send data\n     */\n    function initConnectedOFT(address _srcOft, uint16 _dstChainId, address _dstOft, bytes memory _ercData)\n        external\n        onlyOwner\n    {\n        if (connectedOFTs[_srcOft][_dstChainId].rebalanceable > 0) {\n            revert AlreadyInitialized();\n        }\n        bool isNative = ITOFT(_srcOft).erc20() == address(0);\n        if (!isNative && _ercData.length == 0) revert PoolInfoRequired();\n\n        (uint256 _srcPoolId, uint256 _dstPoolId) = abi.decode(_ercData, (uint256, uint256));\n\n        OFTData memory oftData =\n            OFTData({srcPoolId: _srcPoolId, dstPoolId: _dstPoolId, dstOft: _dstOft, rebalanceable: 0});\n\n        connectedOFTs[_srcOft][_dstChainId] = oftData;\n        emit ConnectedChainUpdated(_srcOft, _dstChainId, _dstOft);\n    }\n\n    /**\n     * @notice assings more rebalanceable amount for TOFT\n     * @param _srcOft the source TOFT address\n     * @param _dstChainId the destination LayerZero id\n     * @param _amount the rebalanced amount\n     */\n    function addRebalanceAmount(address _srcOft, uint16 _dstChainId, uint256 _amount)\n        external\n        onlyValidDestination(_srcOft, _dstChainId)\n        onlyOwner\n    {\n        connectedOFTs[_srcOft][_dstChainId].rebalanceable += _amount;\n        uint256 totalToftSupply = ITOFTVault(ITOFT(_srcOft).vault()).viewSupply();\n        if (connectedOFTs[_srcOft][_dstChainId].rebalanceable > totalToftSupply) {\n            revert RebalanceAmountNotValid();\n        }\n        emit RebalanceAmountUpdated(_srcOft, _dstChainId, _amount, connectedOFTs[_srcOft][_dstChainId].rebalanceable);\n    }\n\n    function retryRevert(uint16 _srcChainId, bytes calldata _srcAddress, uint256 _nonce) external payable onlyOwner {\n        router.retryRevert{value: msg.value}(_srcChainId, _srcAddress, _nonce);\n    }\n\n    /// =====================\n    /// Private\n    /// =====================\n    function _sendNative(address payable _oft, uint256 _amount, uint16 _dstChainId, uint256 _slippage) private {\n        if (address(this).balance < _amount) revert ExceedsBalance();\n        uint256 valueAmount = msg.value + _amount;\n        routerETH.swapETH{value: valueAmount}(\n            _dstChainId,\n            payable(this),\n            abi.encodePacked(connectedOFTs[_oft][_dstChainId].dstOft),\n            _amount,\n            _computeMinAmount(_amount, _slippage)\n        );\n    }\n\n    function _sendToken(\n        address payable _oft,\n        uint256 _amount,\n        uint16 _dstChainId,\n        uint256 _slippage,\n        bytes memory _data\n    ) private {\n        address erc20 = ITOFT(_oft).erc20();\n        if (IERC20Metadata(erc20).balanceOf(address(this)) < _amount) {\n            revert ExceedsBalance();\n        }\n        {\n            (uint256 _srcPoolId, uint256 _dstPoolId) = abi.decode(_data, (uint256, uint256));\n            _routerSwap(_dstChainId, _srcPoolId, _dstPoolId, _amount, _slippage, _oft, erc20);\n        }\n    }\n\n    function _routerSwap(\n        uint16 _dstChainId,\n        uint256 _srcPoolId,\n        uint256 _dstPoolId,\n        uint256 _amount,\n        uint256 _slippage,\n        address payable _oft,\n        address _erc20\n    ) private {\n        bytes memory _dst = abi.encodePacked(connectedOFTs[_oft][_dstChainId].dstOft);\n        IERC20(_erc20).safeApprove(address(router), _amount);\n        router.swap{value: msg.value}(\n            _dstChainId,\n            _srcPoolId,\n            _dstPoolId,\n            payable(this),\n            _amount,\n            _computeMinAmount(_amount, _slippage),\n            IStargateRouterBase.lzTxObj({dstGasForCall: 0, dstNativeAmount: 0, dstNativeAddr: \"0x0\"}),\n            _dst,\n            \"0x\"\n        );\n    }\n\n    function _computeMinAmount(uint256 _amount, uint256 _slippage) private pure returns (uint256) {\n        return _amount - ((_amount * _slippage) / 1e5);\n    }\n}"
    },
    {
      "filename": "TapiocaZ/contracts/Balancer.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Tapioca\nimport {IStargateRouter, IStargateRouterBase} from \"tapioca-periph/interfaces/external/stargate/IStargateRouter.sol\";\nimport {IStargateEthVault} from \"tapioca-periph/interfaces/external/stargate/IStargateEthVault.sol\";\nimport {ITOFTVault} from \"tapioca-periph/interfaces/tapiocaz/ITOFTVault.sol\";\nimport {ITOFT} from \"tapioca-periph/interfaces/oft/ITOFT.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title Balancer\n * @author TapiocaDAO\n * @notice Rebalances mTOFT by transferring underlying tokens to other layers through Stargate\n */\ncontract Balancer is Ownable {\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice current OFT => chain => destination OFT\n     * @dev chain ids (https://stargateprotocol.gitbook.io/stargate/developers/chain-ids):\n     *         - Ethereum: 101\n     *         - BNB: 102\n     *         - Avalanche: 106\n     *         - Polygon: 109\n     *         - Arbitrum: 110\n     *         - Optimism: 111\n     *         - Fantom: 112\n     *         - Metis: 151\n     *     pool ids https://stargateprotocol.gitbook.io/stargate/developers/pool-ids\n     */\n    mapping(address => mapping(uint16 => OFTData)) public connectedOFTs;\n\n    struct OFTData {\n        uint256 srcPoolId;\n        uint256 dstPoolId;\n        address dstOft;\n        uint256 rebalanceable;\n    }\n\n    IStargateRouter public immutable routerETH;\n    IStargateRouter public immutable router;\n\n    address public rebalancer;\n\n    // @dev swapEth is not available on some chains\n    bool public disableEth;\n\n    event ConnectedChainUpdated(address indexed _srcOft, uint16 indexed _dstChainId, address indexed _dstOft);\n    event Rebalanced(\n        address indexed _srcOft, uint16 indexed _dstChainId, uint256 indexed _slippage, uint256 _amount, bool _isNative\n    );\n    event RebalanceAmountUpdated(\n        address indexed _srcOft, uint16 indexed _dstChainId, uint256 indexed _amount, uint256 _totalAmount\n    );\n    event ToggledSwapEth(bool indexed _old, bool indexed _new);\n    event EmergencySaved(address indexed _token, uint256 indexed _amount, bool indexed _native);\n    event RebalancerUpdated(address indexed prev, address indexed current);\n\n    error NotAuthorized();\n    error RouterNotValid();\n    error ExceedsBalance();\n    error DestinationNotValid();\n    error SlippageNotValid();\n    error FeeAmountNotSet();\n    error PoolInfoRequired();\n    error RebalanceAmountNotSet();\n    error Failed();\n    error SwapNotEnabled();\n    error AlreadyInitialized();\n    error RebalanceAmountNotValid();\n\n    modifier onlyValidDestination(address _srcOft, uint16 _dstChainId) {\n        if (connectedOFTs[_srcOft][_dstChainId].dstOft == address(0)) {\n            revert DestinationNotValid();\n        }\n        _;\n    }\n\n    modifier onlyValidSlippage(uint256 _slippage) {\n        // @dev a slippage higher than 20% shouldn't be necessary\n        if (_slippage >= 2e4) revert SlippageNotValid();\n        _;\n    }\n\n    constructor(address _routerETH, address _router, address _owner) {\n        if (_router == address(0)) revert RouterNotValid();\n        if (_routerETH == address(0)) revert RouterNotValid();\n        routerETH = IStargateRouter(_routerETH);\n        router = IStargateRouter(_router);\n\n        transferOwnership(_owner);\n        rebalancer = _owner;\n        emit RebalancerUpdated(address(0), _owner);\n    }\n\n    receive() external payable {}\n\n    /// =====================\n    /// View\n    /// =====================\n    function checker(address payable _srcOft, uint16 _dstChainId, uint256 _slippage)\n        external\n        view\n        returns (bool canExec, bytes memory execPayload)\n    {\n        bytes memory ercData;\n        {\n            if (ITOFT(_srcOft).erc20() != address(0)) {\n                ercData = abi.encode(\n                    connectedOFTs[_srcOft][_dstChainId].srcPoolId, connectedOFTs[_srcOft][_dstChainId].dstPoolId\n                );\n            }\n        }\n\n        canExec = connectedOFTs[_srcOft][_dstChainId].rebalanceable > 0;\n        execPayload = abi.encodeCall(\n            Balancer.rebalance,\n            (_srcOft, _dstChainId, _slippage, connectedOFTs[_srcOft][_dstChainId].rebalanceable, ercData)\n        );\n    }\n\n    /// =====================\n    /// Owner\n    /// =====================\n\n    /**\n     * @notice set rebalancer role\n     * @param _addr the new address\n     */\n    function setRebalancer(address _addr) external onlyOwner {\n        rebalancer = _addr;\n        emit RebalancerUpdated(rebalancer, _addr);\n    }\n\n    /**\n     * @notice toggle swap eth\n     * @param _val true/false\n     */\n    function setSwapEth(bool _val) external onlyOwner {\n        emit ToggledSwapEth(disableEth, _val);\n        disableEth = _val;\n    }\n\n    /**\n     * @notice performs a rebalance operation\n     * @dev callable only by the owner\n     * @param _srcOft the source TOFT address\n     * @param _dstChainId the destination LayerZero id\n     * @param _slippage the destination LayerZero id\n     * @param _amount the rebalanced amount\n     * @param _ercData custom send data\n     */\n    function rebalance(\n        address payable _srcOft,\n        uint16 _dstChainId,\n        uint256 _slippage,\n        uint256 _amount,\n        bytes memory _ercData\n    ) external payable onlyValidDestination(_srcOft, _dstChainId) onlyValidSlippage(_slippage) {\n        if (msg.sender != owner() || msg.sender != rebalancer) revert NotAuthorized();\n\n        if (connectedOFTs[_srcOft][_dstChainId].rebalanceable < _amount) {\n            revert RebalanceAmountNotSet();\n        }\n\n        //extract\n        ITOFT(_srcOft).extractUnderlying(_amount);\n\n        //send\n        {\n            bool _isNative = ITOFT(_srcOft).erc20() == address(0);\n            if (msg.value == 0) revert FeeAmountNotSet();\n            if (_isNative) {\n                if (disableEth) revert SwapNotEnabled();\n                _sendNative(_srcOft, _amount, _dstChainId, _slippage);\n            } else {\n                _sendToken(_srcOft, _amount, _dstChainId, _slippage, _ercData);\n            }\n\n            connectedOFTs[_srcOft][_dstChainId].rebalanceable -= _amount;\n            emit Rebalanced(_srcOft, _dstChainId, _slippage, _amount, _isNative);\n        }\n    }\n\n    /**\n     * @notice saves token/native gas from this contract\n     * @param _token the token address; `address(0)` should be passed for the Native coin\n     * @param _amount the amount to be saved\n     */\n    function emergencySaveTokens(address _token, uint256 _amount) external onlyOwner {\n        if (_token == address(0)) {\n            (bool sent,) = msg.sender.call{value: _amount}(\"\");\n            if (!sent) revert Failed();\n            emit EmergencySaved(_token, _amount, true);\n        } else {\n            IERC20(_token).safeTransfer(msg.sender, _amount);\n            emit EmergencySaved(_token, _amount, false);\n        }\n    }\n\n    /**\n     * @notice registeres mTapiocaOFT for rebalancing\n     * @param _srcOft the source TOFT address\n     * @param _dstChainId the destination LayerZero id\n     * @param _dstOft the destination TOFT address\n     * @param _ercData custom send data\n     */\n    function initConnectedOFT(address _srcOft, uint16 _dstChainId, address _dstOft, bytes memory _ercData)\n        external\n        onlyOwner\n    {\n        if (connectedOFTs[_srcOft][_dstChainId].rebalanceable > 0) {\n            revert AlreadyInitialized();\n        }\n        bool isNative = ITOFT(_srcOft).erc20() == address(0);\n        if (!isNative && _ercData.length == 0) revert PoolInfoRequired();\n\n        (uint256 _srcPoolId, uint256 _dstPoolId) = abi.decode(_ercData, (uint256, uint256));\n\n        OFTData memory oftData =\n            OFTData({srcPoolId: _srcPoolId, dstPoolId: _dstPoolId, dstOft: _dstOft, rebalanceable: 0});\n\n        connectedOFTs[_srcOft][_dstChainId] = oftData;\n        emit ConnectedChainUpdated(_srcOft, _dstChainId, _dstOft);\n    }\n\n    /**\n     * @notice assings more rebalanceable amount for TOFT\n     * @param _srcOft the source TOFT address\n     * @param _dstChainId the destination LayerZero id\n     * @param _amount the rebalanced amount\n     */\n    function addRebalanceAmount(address _srcOft, uint16 _dstChainId, uint256 _amount)\n        external\n        onlyValidDestination(_srcOft, _dstChainId)\n        onlyOwner\n    {\n        connectedOFTs[_srcOft][_dstChainId].rebalanceable += _amount;\n        uint256 totalToftSupply = ITOFTVault(ITOFT(_srcOft).vault()).viewSupply();\n        if (connectedOFTs[_srcOft][_dstChainId].rebalanceable > totalToftSupply) {\n            revert RebalanceAmountNotValid();\n        }\n        emit RebalanceAmountUpdated(_srcOft, _dstChainId, _amount, connectedOFTs[_srcOft][_dstChainId].rebalanceable);\n    }\n\n    function retryRevert(uint16 _srcChainId, bytes calldata _srcAddress, uint256 _nonce) external payable onlyOwner {\n        router.retryRevert{value: msg.value}(_srcChainId, _srcAddress, _nonce);\n    }"
    }
  ]
}