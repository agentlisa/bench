{
  "Title": "3S-LENFT-N08 Documentation: Incorrect formula for rewards",
  "Content": "#### Description\nOn the [Gauges](https://lenft.gitbook.io/lenft-docs/le-token/gauges) documentation page, the formula for the `rewards(epoch)` presented does not match the plotted curve nor the code implementation.\nThe formula presented is:\n- rewards = ceiling * (locked_LE / (5 * total_LE)) ^3\n\nThis represents a monotonically increasing function starting at 0 (when the locked tokens are 0) and reaching 0.008*ceiling  (when the locked_LE is equal to the total_LE). This function does not match the decreasing function plotted in the graph.\n\nThe [code](https://github.com/leNFT/contracts/blob/master/contracts/protocol/Gauges/GaugeController.sol#L497) implementation uses the formula:\n- rewards = ceiling * (1 - (locked_LE / (5 * total_LE))) ^3\n\nwhich starts at 1* ceiling and decreases to 0.512*ceiling, matching the plotted curve.\n\n#### Recommendation\nFix the documentation",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/protocol/Gauges/GaugeController.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity 0.8.19;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {PercentageMath} from \"../../libraries/utils/PercentageMath.sol\";\nimport {DataTypes} from \"../../libraries/types/DataTypes.sol\";\nimport {IVotingEscrow} from \"../../interfaces/IVotingEscrow.sol\";\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {IGaugeController} from \"../../interfaces/IGaugeController.sol\";\nimport {IAddressProvider} from \"../../interfaces/IAddressProvider.sol\";\nimport {ERC165CheckerUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165CheckerUpgradeable.sol\";\nimport {IGauge} from \"../../interfaces/IGauge.sol\";\nimport {SafeCast} from \"../../libraries/utils/SafeCast.sol\";\n\n/// @title Gauge Controller\n/// @author leNFT\n/// @notice Manages the different gauges\n/// @dev Contract that manages gauge vote weights, total vote weight, user vote power in each gauge, and user vote ratios.\ncontract GaugeController is OwnableUpgradeable, IGaugeController {\n    uint256 private constant INFLATION_PERIOD = 52; // 52 epochs (1 year)\n    uint256 private constant MAX_INFLATION_PERIODS = 8; // Maximum 8 inflation periods (8 years) and then base emissions\n    uint256 private constant INITIAL_REWARDS = 28e23; // 2.8 million tokens per epoch\n\n    IAddressProvider private immutable _addressProvider;\n\n    // Epoch history of gauge vote weight\n    mapping(address => uint256[]) private _gaugeWeightHistory;\n    // Last checkpoint for history of gauge vote weight\n    mapping(address => DataTypes.Point) private _lastGaugeWeigthCheckpoint;\n    // Slope changes for total weight of each gauge\n    mapping(address => mapping(uint256 => uint256))\n        private _gaugeWeightSlopeChanges;\n    // Epoch history of total vote weight\n    uint256[] private _totalWeigthHistory;\n    // Last checkpoint for the total vote weight\n    DataTypes.Point private _lastWeightCheckpoint;\n    // Slope changes for total weight\n    mapping(uint256 => uint256) private _totalWeightSlopeChanges;\n    // vote ratio being used by each lock (%), smallest tick is 0.01%\n    mapping(uint256 => uint256) private _lockVoteRatio;\n    // User vote ratio used by each lock at each gauge (%), smallest tick is 0.01%\n    mapping(uint256 => mapping(address => uint256)) private _lockGaugeVoteRatio;\n    // Weight vote power each lock has in each gauge\n    mapping(uint256 => mapping(address => DataTypes.Point))\n        private _lockGaugeVotePoint;\n    mapping(address => bool) private _isGauge;\n    mapping(address => address) private _liquidityPoolToGauge;\n    uint256 private _lpMaturityPeriod; // in seconds\n\n    using ERC165CheckerUpgradeable for address;\n\n    modifier validGauge(address gauge) {\n        _requireValidGauge(gauge);\n        _;\n    }\n\n    modifier noFutureEpoch(uint256 epoch) {\n        _requireNoFutureEpoch(epoch);\n        _;\n    }\n\n    modifier lockExists(uint256 lockId) {\n        _requireLockExists(lockId);\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(IAddressProvider addressProvider) {\n        _addressProvider = addressProvider;\n        _disableInitializers();\n    }\n\n    /// @notice Initializes the contract by setting up the owner and the addresses provider contract.\n    /// @param lpMaturityPeriod The maturity period for the LP tokens\n    function initialize(uint256 lpMaturityPeriod) external initializer {\n        __Ownable_init();\n        _lpMaturityPeriod = lpMaturityPeriod;\n        _totalWeigthHistory.push(0);\n        _lastWeightCheckpoint = DataTypes.Point(\n            0,\n            0,\n            SafeCast.toUint40(block.timestamp)\n        );\n    }\n\n    /// @notice Adds a gauge contract to the list of registered gauges.\n    /// @dev Only the contract owner can call this method.\n    /// @param gauge Address of the gauge contract to add.\n    function addGauge(address gauge) external onlyOwner {\n        // Check if the gauge is already registered\n        require(!_isGauge[gauge], \"GC:AG:GAUGE_ALREADY_ADDED\");\n\n        // Check if the gauge is a valid gauge\n        require(\n            gauge.supportsInterface(type(IGauge).interfaceId),\n            \"GC:AG:INVALID_GAUGE\"\n        );\n\n        address liquidityPool = IGauge(gauge).getLPToken();\n        _liquidityPoolToGauge[liquidityPool] = gauge;\n        _isGauge[gauge] = true;\n\n        emit AddGauge(gauge, liquidityPool);\n    }\n\n    /// @notice Remove a gauge\n    /// @dev Only the contract owner can call this method.\n    /// @param gauge The address of the gauge to be removed\n    function removeGauge(address gauge) external onlyOwner validGauge(gauge) {\n        address liquidityPool = IGauge(gauge).getLPToken();\n        if (_liquidityPoolToGauge[liquidityPool] == gauge) {\n            delete _liquidityPoolToGauge[liquidityPool];\n        }\n\n        delete _isGauge[gauge];\n\n        emit RemoveGauge(gauge, liquidityPool);\n    }\n\n    /// @notice Check if a gauge exists (meaning is registered with the gauge controller)\n    /// @param gauge The address of the gauge to check\n    /// @return A boolean indicating whether the gauge exists\n    function isGauge(address gauge) external view override returns (bool) {\n        return _isGauge[gauge];\n    }\n\n    /// @notice Get the gauge associated with a given liquidity pool\n    /// @param liquidityPool The address of the liquidity pool to check\n    /// @return The address of the gauge associated with the liquidity pool\n    function getGauge(address liquidityPool) external view returns (address) {\n        return _liquidityPoolToGauge[liquidityPool];\n    }\n\n    /// @notice Get the current weight of a gauge\n    /// @param gauge The address of the gauge to check\n    /// @return The current weight of the gauge\n    function getGaugeWeight(\n        address gauge\n    ) external view validGauge(gauge) returns (uint256) {\n        DataTypes.Point\n            memory lastGaugeWeightCheckpoint = _lastGaugeWeigthCheckpoint[\n                gauge\n            ];\n\n        if (\n            lastGaugeWeightCheckpoint.bias <\n            lastGaugeWeightCheckpoint.slope *\n                (block.timestamp - lastGaugeWeightCheckpoint.timestamp)\n        ) {\n            return 0;\n        }\n\n        return\n            lastGaugeWeightCheckpoint.bias -\n            lastGaugeWeightCheckpoint.slope *\n            (block.timestamp - lastGaugeWeightCheckpoint.timestamp);\n    }\n\n    /// @notice Get the weight of a gauge at a specific epoch\n    /// @param gauge The address of the gauge to check\n    /// @param epoch The epoch for which to retrieve the gauge weight\n    /// @return The weight of the gauge at the specified epoch\n    function getGaugeWeightAt(\n        address gauge,\n        uint256 epoch\n    ) public noFutureEpoch(epoch) validGauge(gauge) returns (uint256) {\n        // Update gauge weight history\n        writeGaugeWeightHistory(gauge);\n\n        return _gaugeWeightHistory[gauge][epoch];\n    }\n\n    /// @notice Get the total weight sum of all gauges\n    /// @return The total weight sum of all gauges\n    function getTotalWeight() external view returns (uint256) {\n        if (\n            _lastWeightCheckpoint.bias <\n            _lastWeightCheckpoint.slope *\n                (block.timestamp - _lastWeightCheckpoint.timestamp)\n        ) {\n            return 0;\n        }\n\n        return\n            _lastWeightCheckpoint.bias -\n            _lastWeightCheckpoint.slope *\n            (block.timestamp - _lastWeightCheckpoint.timestamp);\n    }\n\n    /// @notice Get the total weight of all gauges at a specific epoch\n    /// @param epoch The epoch for which to retrieve the total weight\n    /// @return The total weight of all gauges at the specified epoch\n    function getTotalWeightAt(\n        uint256 epoch\n    ) public noFutureEpoch(epoch) returns (uint256) {\n        // Update total weight history\n        writeTotalWeightHistory();\n\n        return _totalWeigthHistory[epoch];\n    }\n\n    /// @notice Get the current used vote power for a given lock.\n    /// @param tokenId The tokenId of the lock.\n    /// @return The current used vote power.\n    function getLockVoteRatio(\n        uint256 tokenId\n    ) external view override lockExists(tokenId) returns (uint256) {\n        return _lockVoteRatio[tokenId];\n    }\n\n    /// @notice  Get the current used vote power for a given user in a specific gauge.\n    /// @param tokenId The tokenId of the lock.\n    /// @param gauge The address of the gauge.\n    /// @return The current used vote power for the given user in the specified gauge.\n    function getLockVoteRatioForGauge(\n        uint256 tokenId,\n        address gauge\n    ) external view validGauge(gauge) lockExists(tokenId) returns (uint256) {\n        return _lockGaugeVoteRatio[tokenId][gauge];\n    }\n\n    /// @notice Get the vote point for a lock in a specific gauge.\n    /// @param tokenId The tokenId of the lock.\n    /// @param gauge The address of the gauge.\n    function getLockVotePointForGauge(\n        uint256 tokenId,\n        address gauge\n    )\n        external\n        view\n        validGauge(gauge)\n        lockExists(tokenId)\n        returns (DataTypes.Point memory)\n    {\n        return _lockGaugeVotePoint[tokenId][gauge];\n    }\n\n    /// @notice Get the vote weight for a user in a specific gauge.\n    /// @param tokenId The tokenId of the lock.\n    /// @param gauge The address of the gauge.\n    /// @return The vote weight for the user in the specified gauge.\n    function getLockVoteWeightForGauge(\n        uint256 tokenId,\n        address gauge\n    ) external view validGauge(gauge) lockExists(tokenId) returns (uint256) {\n        if (\n            _lockGaugeVotePoint[tokenId][gauge].slope *\n                (block.timestamp -\n                    _lockGaugeVotePoint[tokenId][gauge].timestamp) >\n            _lockGaugeVotePoint[tokenId][gauge].bias\n        ) {\n            return 0;\n        }\n\n        return\n            _lockGaugeVotePoint[tokenId][gauge].bias -\n            _lockGaugeVotePoint[tokenId][gauge].slope *\n            (block.timestamp - _lockGaugeVotePoint[tokenId][gauge].timestamp);\n    }\n\n    /// @notice Update the total weight history\n    function writeTotalWeightHistory() public {\n        // Update last saved weight checkpoint and record weight for epochs\n        // Will break if is not used for 128 epochs\n        IVotingEscrow votingEscrow = IVotingEscrow(\n            _addressProvider.getVotingEscrow()\n        );\n        uint256 epochTimestampPointer = votingEscrow.getEpochTimestamp(\n            _totalWeigthHistory.length\n        );\n        uint256 epochPeriod = votingEscrow.getEpochPeriod();\n\n        for (uint256 i = 0; i < 2 ** 7; i++) {\n            if (epochTimestampPointer > block.timestamp) {\n                break;\n            }\n\n            // Save epoch total weight\n            uint256 epochTotalWeight = _lastWeightCheckpoint.bias -\n                (_lastWeightCheckpoint.slope *\n                    (epochTimestampPointer - _lastWeightCheckpoint.timestamp));\n            _totalWeigthHistory.push(epochTotalWeight);\n\n            // Update last weight checkpoint\n            _lastWeightCheckpoint.bias = SafeCast.toUint128(epochTotalWeight);\n            _lastWeightCheckpoint.timestamp = SafeCast.toUint40(\n                epochTimestampPointer\n            );\n            _lastWeightCheckpoint.slope -= SafeCast.toUint128(\n                _totalWeightSlopeChanges[epochTimestampPointer]\n            );\n\n            //Increase epoch timestamp\n            epochTimestampPointer += epochPeriod;\n        }\n    }\n\n    /// @notice Update the weight history of a gauge\n    /// @param gauge The address of the gauge to update\n    function writeGaugeWeightHistory(address gauge) public validGauge(gauge) {\n        IVotingEscrow votingEscrow = IVotingEscrow(\n            _addressProvider.getVotingEscrow()\n        );\n\n        // If the gauge weights are empty set the weight for the first epoch\n        if (_gaugeWeightHistory[gauge].length == 0) {\n            _gaugeWeightHistory[gauge].push(0);\n            _lastGaugeWeigthCheckpoint[gauge] = DataTypes.Point(\n                0,\n                0,\n                SafeCast.toUint40(votingEscrow.getEpochTimestamp(0))\n            );\n        }\n\n        // Update last saved weight checkpoint and record weight for epochs\n        // Will break if is not used for 128 epochs\n        uint256 epochPeriod = votingEscrow.getEpochPeriod();\n        uint256 epochTimestampPointer = votingEscrow.getEpochTimestamp(\n            _gaugeWeightHistory[gauge].length\n        );\n\n        for (uint256 i = 0; i < 2 ** 7; i++) {\n            //Increase epoch timestamp\n            if (epochTimestampPointer > block.timestamp) {\n                break;\n            }\n            // Save epoch total weight\n            uint256 epochGaugeWeight = _lastGaugeWeigthCheckpoint[gauge].bias -\n                _lastGaugeWeigthCheckpoint[gauge].slope *\n                (epochTimestampPointer -\n                    _lastGaugeWeigthCheckpoint[gauge].timestamp);\n            _gaugeWeightHistory[gauge].push(epochGaugeWeight);\n\n            // Update last weight checkpoint\n            _lastGaugeWeigthCheckpoint[gauge].bias = SafeCast.toUint128(\n                epochGaugeWeight\n            );\n            _lastGaugeWeigthCheckpoint[gauge].timestamp = SafeCast.toUint40(\n                epochTimestampPointer\n            );\n            _lastGaugeWeigthCheckpoint[gauge].slope -= SafeCast.toUint128(\n                _gaugeWeightSlopeChanges[gauge][epochTimestampPointer]\n            );\n\n            epochTimestampPointer += epochPeriod;\n        }\n    }\n\n    /// @notice Vote for a gauge\n    /// @param tokenId The tokenId of the lock.\n    /// @param gauge The address of the gauge to vote for\n    /// @param ratio The ratio of the vote power to use\n    function vote(\n        uint256 tokenId,\n        address gauge,\n        uint256 ratio\n    ) external lockExists(tokenId) validGauge(gauge) {\n        //Must be the owner of the lock to use it to vote\n        IVotingEscrow votingEscrow = IVotingEscrow(\n            _addressProvider.getVotingEscrow()\n        );\n        require(\n            IERC721Upgradeable(address(votingEscrow)).ownerOf(tokenId) ==\n                msg.sender,\n            \"GC:V:NOT_LOCK_OWNER\"\n        );\n\n        // Get user locked balance\n        DataTypes.LockedBalance memory lockedBalance = votingEscrow.getLock(\n            tokenId\n        );\n\n        require(\n            ratio +\n                _lockVoteRatio[tokenId] -\n                _lockGaugeVoteRatio[tokenId][gauge] <=\n                PercentageMath.PERCENTAGE_FACTOR, // 100%\n            \"GC:V:INVALID_RATIO\"\n        );\n\n        // Lock must not be expired unless the ratio is 0 (we are removing the vote)\n        require(\n            lockedBalance.end > block.timestamp || ratio == 0,\n            \"GC:V:LOCK_EXPIRED\"\n        );\n\n        require(lockedBalance.amount > 0, \"GC:V:LOCKED_BALANCE_ZERO\");\n\n        require(_isGauge[gauge], \"GC:V:INVALID_GAUGE\");\n\n        // Write weight history to make sure its up to date until this epoch\n        writeTotalWeightHistory();\n        writeGaugeWeightHistory(gauge);\n\n        // Get lock last action\n        DataTypes.Point memory lockLastPoint = votingEscrow.getLockHistoryPoint(\n            tokenId,\n            votingEscrow.getLockHistoryLength(tokenId) - 1\n        );\n        DataTypes.Point memory oldGaugeVoteWeight;\n        DataTypes.Point memory newGaugeVoteWeight;\n\n        // Get the updated gauge vote weight\n        newGaugeVoteWeight.bias = SafeCast.toUint128(\n            PercentageMath.percentMul(\n                lockLastPoint.bias -\n                    (lockLastPoint.slope *\n                        (block.timestamp - lockLastPoint.timestamp)),\n                ratio\n            )\n        );\n        newGaugeVoteWeight.slope = SafeCast.toUint128(\n            PercentageMath.percentMul(lockLastPoint.slope, ratio)\n        );\n\n        newGaugeVoteWeight.timestamp = SafeCast.toUint40(block.timestamp);\n\n        // If we already have valid votes in this gauge\n        if (\n            _lockGaugeVoteRatio[tokenId][gauge] > 0 &&\n            block.timestamp < lockedBalance.end\n        ) {\n            // Get the updated old gauge vote weight\n            oldGaugeVoteWeight.bias = SafeCast.toUint128(\n                _lockGaugeVotePoint[tokenId][gauge].slope *\n                    (block.timestamp -\n                        _lockGaugeVotePoint[tokenId][gauge].timestamp)\n            );\n            oldGaugeVoteWeight.slope = SafeCast.toUint128(\n                _lockGaugeVotePoint[tokenId][gauge].slope\n            );\n            oldGaugeVoteWeight.timestamp = SafeCast.toUint40(block.timestamp);\n\n            _gaugeWeightSlopeChanges[gauge][\n                lockedBalance.end\n            ] -= oldGaugeVoteWeight.slope;\n\n            _totalWeightSlopeChanges[lockedBalance.end] -= oldGaugeVoteWeight\n                .slope;\n        }\n\n        // Add new slope updates\n        _gaugeWeightSlopeChanges[gauge][lockedBalance.end] += newGaugeVoteWeight\n            .slope;\n        _totalWeightSlopeChanges[lockedBalance.end] += newGaugeVoteWeight.slope;\n\n        // Update checkpoints\n        _lastGaugeWeigthCheckpoint[gauge].bias = SafeCast.toUint128(\n            _lastGaugeWeigthCheckpoint[gauge].bias -\n                (_lastGaugeWeigthCheckpoint[gauge].slope *\n                    (block.timestamp -\n                        _lastGaugeWeigthCheckpoint[gauge].timestamp)) +\n                newGaugeVoteWeight.bias -\n                oldGaugeVoteWeight.bias\n        );\n        _lastGaugeWeigthCheckpoint[gauge].slope =\n            _lastGaugeWeigthCheckpoint[gauge].slope +\n            newGaugeVoteWeight.slope -\n            oldGaugeVoteWeight.slope;\n        _lastGaugeWeigthCheckpoint[gauge].timestamp = SafeCast.toUint40(\n            block.timestamp\n        );\n\n        _lastWeightCheckpoint.bias = SafeCast.toUint128(\n            _lastWeightCheckpoint.bias -\n                (_lastWeightCheckpoint.slope *\n                    (block.timestamp - _lastWeightCheckpoint.timestamp)) +\n                newGaugeVoteWeight.bias -\n                oldGaugeVoteWeight.bias\n        );\n        _lastWeightCheckpoint.slope =\n            _lastWeightCheckpoint.slope +\n            newGaugeVoteWeight.slope -\n            oldGaugeVoteWeight.slope;\n        _lastWeightCheckpoint.timestamp = SafeCast.toUint40(block.timestamp);\n\n        // Update user vote info\n        _lockVoteRatio[tokenId] =\n            ratio +\n            _lockVoteRatio[tokenId] -\n            _lockGaugeVoteRatio[tokenId][gauge];\n        _lockGaugeVoteRatio[tokenId][gauge] = ratio;\n        _lockGaugeVotePoint[tokenId][gauge] = newGaugeVoteWeight;\n\n        emit Vote(msg.sender, tokenId, gauge, ratio);\n    }\n\n    /// @notice Returns the maximum amount of tokens that can be distributed as rewards for the specified epoch.\n    /// @param epoch The epoch for which to get the rewards.\n    /// @return The maximum amount of tokens that can be distributed as rewards for the specified epoch.\n    function getRewardsCeiling(uint256 epoch) public pure returns (uint256) {\n        uint256 inflationEpoch = epoch / INFLATION_PERIOD;\n        // If we are in the loading period, return smaller rewards\n        if (inflationEpoch == 0) {\n            return (INITIAL_REWARDS * epoch) / INFLATION_PERIOD;\n        } else if (inflationEpoch > MAX_INFLATION_PERIODS) {\n            // Cap the inflation epoch = stabilize rewards\n            inflationEpoch = MAX_INFLATION_PERIODS;\n        }\n\n        return\n            (INITIAL_REWARDS * (3 ** inflationEpoch)) / (4 ** inflationEpoch);\n    }\n\n    /// @notice Returns the amount of tokens to distribute as rewards for the specified epoch.\n    /// @dev The amount of tokens to distribute goes down as the number of locked tokens goes up.\n    /// @param epoch The epoch for which to get the rewards.\n    /// @return The amount of tokens to distribute as rewards for the specified epoch.\n    function getEpochRewards(\n        uint256 epoch\n    ) public noFutureEpoch(epoch) returns (uint256) {\n        // If there are no votes in any gauge, return 0\n        if (getTotalWeightAt(epoch) == 0) {\n            return 0;\n        }\n\n        return\n            (((PercentageMath.PERCENTAGE_FACTOR -\n                (IVotingEscrow(_addressProvider.getVotingEscrow())\n                    .getLockedRatioAt(epoch) / 5)) ** 3) *\n                getRewardsCeiling(epoch)) /\n            (PercentageMath.PERCENTAGE_FACTOR ** 3);\n    }\n\n    /// @notice Get the LE reward for a gauge in a given epoch\n    /// @param gauge The address of the gauge\n    /// @param epoch The epoch to get the reward for\n    /// @return rewards The LE reward for the gauge in the given epoch\n    function getGaugeRewards(\n        address gauge,\n        uint256 epoch\n    )\n        external\n        validGauge(gauge)\n        noFutureEpoch(epoch)\n        returns (uint256 rewards)\n    {\n        // If there are no votes in any gauge, return 0\n        uint256 totalWeight = getTotalWeightAt(epoch);\n        if (totalWeight == 0) {\n            return 0;\n        }\n\n        return\n            (getEpochRewards(epoch) * getGaugeWeightAt(gauge, epoch)) /\n            totalWeight;\n    }\n\n    /// @notice Sets the maturity period for LP tokens\n    /// @param maturityPeriod The new maturity period in epochs\n    function setLPMaturityPeriod(uint256 maturityPeriod) external onlyOwner {\n        require(maturityPeriod > 0, \"GC:SLPMP:INVALID_MATURITY_PERIOD\");\n        _lpMaturityPeriod = maturityPeriod;\n    }\n\n    /// @notice Gets the maturity period for LP tokens\n    /// @return The maturity period in epochs\n    function getLPMaturityPeriod() external view override returns (uint256) {\n        return _lpMaturityPeriod;\n    }\n\n    function _requireValidGauge(address gauge) internal view {\n        require(_isGauge[gauge], \"GC:INVALID_GAUGE\");\n    }\n\n    function _requireLockExists(uint256 tokenId) internal view {\n        try\n            IERC721Upgradeable(_addressProvider.getVotingEscrow()).ownerOf(\n                tokenId\n            ) // solhint-disable-next-line no-empty-blocks\n        {} catch {\n            revert(\"GC:LOCK_NOT_FOUND\");\n        }\n    }\n\n    function _requireNoFutureEpoch(uint256 epoch) internal view {\n        require(\n            epoch <=\n                IVotingEscrow(_addressProvider.getVotingEscrow()).getEpoch(\n                    block.timestamp\n                ),\n            \"GC:FUTURE_EPOCH\"\n        );\n    }\n}"
    }
  ]
}