{
  "Title": "M-1: Auction fails if the 'Honorarium Rate' is 0%",
  "Content": "# Issue M-1: Auction fails if the 'Honorarium Rate' is 0% \n\nSource: https://github.com/sherlock-audit/2024-02-radicalxchange-judging/issues/31 \n\n## Found by \nAl-Qa-qa, sammy\n## Summary\nThe Honorarium Rate is the required percentage of a winning Auction Pitch bid that the Steward makes to the Creator Circle at the beginning of each Stewardship Cycle. \n\n`$$ Winning Bid * Honorarium Rate = Periodic Honorarium $$`\n\nTo mimic the dynamics of private ownership, the _Creator Circle_ may choose a 0% _Honorarium Rate_. However, doing so breaks the functionality of the protocol.\n## Vulnerability Detail\nTo place a bid, a user must call the [`placeBid`](https://github.com/RadicalxChange/pco-art/blob/4acd6b06840028ba616b6200439ce0d6aa1e6276/contracts/auction/facets/EnglishPeriodicAuctionFacet.sol#L153) function in `EnglishPeriodicAuctionFacet.sol` and deposit collateral(`collateralAmount`) equal to `bidAmount + feeAmount`. The `feeAmount` here represents the _Honorarium Rate_ mentioned above. \nThe `placeBid` function calls the [`_placeBid`](https://github.com/RadicalxChange/pco-art/blob/4acd6b06840028ba616b6200439ce0d6aa1e6276/contracts/auction/EnglishPeriodicAuctionInternal.sol#L286) internal function in `EnglishPeriodicAuctionInternal.sol` which calculates the  `totalCollateralAmount` as follows : \n```solidity\nuint256 totalCollateralAmount = bid.collateralAmount + collateralAmount;\n```\nHere, `bid.collateralAmount` is the cumulative collateral deposited by the bidder in previous bids during the current auction round(i.e, zero if no bids were placed), and `collateralAmount` is the collateral to be deposited to place the bid. However the `_placeBid` function requires that `totalCollateralAmount` is strictly greater than `bidAmount` if the bidder is not the current owner of the _Stewardship License_. This check fails when the `feeAmount` is zero and this causes a _Denial of Service_ to users trying to place a bid. Even if the users try to bypass this by depositing a value slightly larger than `bidAmount`, the [`_checkBidAmount`](https://github.com/RadicalxChange/pco-art/blob/4acd6b06840028ba616b6200439ce0d6aa1e6276/contracts/auction/EnglishPeriodicAuctionInternal.sol#L338) function would still revert with `'Incorrect bid amount'`\n\n## POC\nThe following test demonstrates the above-mentioned scenario :\n\n```solidity\n describe('exploit', function () {\n    it('POC', async function () {\n      // Auction start: Now + 100\n      // Auction end: Now + 400\n      const instance = await getInstance({\n        auctionLengthSeconds: 300,\n        initialPeriodStartTime: (await time.latest()) + 100,\n        licensePeriod: 1000,\n      });\n      const licenseMock = await ethers.getContractAt(\n        'NativeStewardLicenseMock',\n        instance.address,\n      );\n\n      // Mint token manually\n      const steward = bidder2.address;\n      await licenseMock.mintToken(steward, 0);\n\n      // Start auction\n      await time.increase(300);\n        \n      const bidAmount = ethers.utils.parseEther('1.0');\n      const feeAmount = await instance.calculateFeeFromBid(bidAmount);\n      const collateralAmount = feeAmount.add(bidAmount);\n\n      // Reverts when a user tries to place a bid\n      await expect( instance\n        .connect(bidder1)\n        .placeBid(0, bidAmount, { value: collateralAmount })).to.be.revertedWith('EnglishPeriodicAuction: Collateral must be greater than current bid');\n\n      \n    \n      const extraAmt = ethers.utils.parseEther('0.1');\n      const collateralAmount1 = feeAmount.add(bidAmount).add(extraAmt);\n      \n      // Also reverts when the user tries to deposit collateral slighty greater than bid amount\n      await expect( instance\n        .connect(bidder1)\n        .placeBid(0, bidAmount, { value: collateralAmount1 })).to.be.revertedWith('EnglishPeriodicAuction: Incorrect bid amount');  \n      \n      // Only accepts a bid from the current steward\n      \n      await expect( instance\n        .connect(bidder2)\n        .placeBid(0, bidAmount, { value: 0 })).to.not.be.reverted;\n\n    });\n  });\n```\nTo run the test, copy the code above to `EnglishPeriodicAuction.ts` and alter [L#68](https://github.com/RadicalxChange/pco-art/blob/4acd6b06840028ba616b6200439ce0d6aa1e6276/test/auction/EnglishPeriodicAuction.ts#L68) as follows : \n```diff\n-          [await owner.getAddress(), licensePeriod, 1, 10],\n+          [await owner.getAddress(), licensePeriod, 0, 10],\n```\nRun `yarn run hardhat test --grep 'POC'`\n## Impact\nThe protocol becomes dysfunctional in such a scenario as users as DOS'd from placing a bid.\n## Code Snippet\n\n## Tool used\n\nManual Review\nHardhat\n\n## Recommendation\nAlter [EnglishPeriodicAuctionInternal.sol::L#330](https://github.com/RadicalxChange/pco-art/blob/4acd6b06840028ba616b6200439ce0d6aa1e6276/contracts/auction/EnglishPeriodicAuctionInternal.sol#L330) as follows :\n```diff\n- totalCollateralAmount > bidAmount,\n+ totalCollateralAmount >= bidAmount, \n```\n\n\n\n\n## Discussion\n\n**sammy-tm**\n\nEscalate\nIt states in the docs that the Honorarium rate may be 0 to mimic private ownership. However, as clearly described in the issue above, this functionality fails.\nhttps://pco-art-docs.vercel.app/for-artists/pco-settings\n_**\"Lower Honorarium Rates will tend to lead to higher nominal Auction Prices: the capital commitment required of the Steward each cycle is lower given a valuation. A 0% Honorarium Rate effectively would mimic the dynamics of private ownership (with a periodic auction in which the Steward could set an arbitrarily high reserve price). The theoretically optimal rate from a Periodic Honorarium maximization perspective is equal to the probability that a new Steward emerges who values the work more than the current Steward (e.g. 1 in every 10 periods implies a 10% optimal rate), but that, of course, might not be the priority.\"**_\n\n\n**sherlock-admin2**\n\n> Escalate\n> It states in the docs that the Honorarium rate may be 0 to mimic private ownership. However, as clearly described in the issue above, this functionality fails.\n> https://pco-art-docs.vercel.app/for-artists/pco-settings\n> _**\"Lower Honorarium Rates will tend to lead to higher nominal Auction Prices: the capital commitment required of the Steward each cycle is lower given a valuation. A 0% Honorarium Rate effectively would mimic the dynamics of private ownership (with a periodic auction in which the Steward could set an arbitrarily high reserve price). The theoretically optimal rate from a Periodic Honorarium maximization perspective is equal to the probability that a new Steward emerges who values the work more than the current Steward (e.g. 1 in every 10 periods implies a 10% optimal rate), but that, of course, might not be the priority.\"**_\n> \n\nThe escalation could not be created because you are not exceeding the escalation threshold.\n\nYou can view the required number of additional valid issues/judging contest payouts in your Profile page,\nin the [Sherlock webapp](https://app.sherlock.xyz/audits/).\n\n\n**cawfree**\n\nEscalate\n\nThe amazing supporting [**documentation**](https://pco-art-docs.vercel.app/for-artists/pco-settings) for RadicalxChange states that one of the intended logical underpinnings of the fee model should be to mimic private ownership when operating using a 0% honorarium:\n<img width=\"911\" alt=\"image\" src=\"https://github.com/sherlock-audit/2024-02-radicalxchange-judging/assets/7922333/3577c537-4c76-4456-913b-fc4271162f48\">.\n\nHowever, the codebase strictly does not permit this due to emergent strict equality checks, which only arise later when actually trying to place a bid. The collection deployer finds out too late.\n\nThe counterargument to this finding is it just seems low severity given that this can be resolved by doing something like redeploy to a collection with `1 wei` (i.e. a frontend fix), or even wondering how often communities are going to do this in practicality.\n\nIt is just clear that this implementation quirk works directly against the advertised functionality (a literal feature), and that should probably play into the severity. People do like free mints after all.\n\n**sherlock-admin2**\n\n> Escalate\n> \n> The amazing supporting [**documentation**](https://pco-art-docs.vercel.app/for-artists/pco-settings) for RadicalxChange states that one of the intended logical underpinnings of the fee model should be to mimic private ownership when operating using a 0% honorarium:\n> <img width=\"911\" alt=\"image\" src=\"https://github.com/sherlock-audit/2024-02-radicalxchange-judging/assets/7922333/3577c537-4c76-4456-913b-fc4271162f48\">.\n> \n> However, the codebase strictly does not permit this due to emergent strict equality checks, which only arise later when actually trying to place a bid. The collection deployer finds out too late.\n> \n> The counterargument to this finding is it just seems low severity given that this can be resolved by doing something like redeploy to a collection with `1 wei` (i.e. a frontend fix), or even wondering how often communities are going to do this in practicality.\n> \n> It is just clear that this implementation quirk works directly against the advertised functionality (a literal feature), and that should probably play into the severity. People do like free mints after all.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Al-Qa-qa**\n\nBesides what @cawfree said, I want to add that if the Artist (Collection Admin), deployed the Collection as immutable (i.e. without an owner). No one will be able to change the fees to just make it `1 wei` (And this point I mentioned in my report `107`). This will make all the Auction processes/NFT Collection broken and insolvable.\n\n**zzykxx**\n\nThis is valid. Setting a fee of `0` is a legitimate and expected input and the core functionality of the protocol (auctions) breaks when this is the case.\n\n**Hash01011122**\n\nIt appears valid finding to me with duplicates #12 and #107 @gravenp @St4rgarden would you like to add something here??\n\n**sammy-tm**\n\nI would also like to urge the lead judge to re-evaluate the severity of this finding. \"Breaking core functionality\" might be considered High in some cases.\n\n**gravenp**\n\nThe 0% Honorarium example is the theoretical limit, but in practice, it doesn't make sense to configure it that way (the PCO system ends up being a lot of complex code for the current steward to basically hold the art as long as they want). I agree that as implemented, we allowed it, and it breaks things. Our fix will not allow the artist/admin to configure a 0% honorarium as this specific configuration isn't core to our intended functionality.\n\n**Hash01011122**\n\nI think this issue is open ended double edge sword where sponsors claiming this cannot be rectified as this is design choice but in my opinion, it suffices medium severity as this breaks protocol's functionality, let me know your thoughts @zzykxx, @gravenp, @Czar102  \n\n**gravenp**\n\nI'm fine with whatever the judges decide. Ultimately, our design choice is not to allow 0% honorarium, so the intended functionality won't include supporting this scenario.\n\n**zzykxx**\n\n> I think this issue is open ended double edge sword where sponsors claiming this cannot be rectified as this is design choice but in my opinion, it suffices medium severity as this breaks protocol's functionality, let me know your thoughts @zzykxx, @gravenp, @Czar102\n\nIn my opinion this should be a valid issue unless it was mentioned somewhere public that the 0% honorarium is not allowed/intended.\n\n**Hash01011122**\n\nAs mentioned by @zzykxx, this is a valid finding with duplicates #107 and #12\n\n**Czar102**\n\n> A 0% Honorarium Rate effectively **would mimic** the dynamics of private ownership (with a periodic auction in which the Steward could set an arbitrarily high reserve price).\n\nThe usage of \"would mimic\" instead of \"mimics\" implies that it's either know not to be possible to use such a configuration, or it is undesired for such a configuration to be used.\n\n> The 0% Honorarium example is the theoretical limit, but in practice, it doesn't make sense to configure it that way (the PCO system ends up being a lot of complex code for the current steward to basically hold the art as long as they want).\n\nIt seems that using a 0% Honorarium Rate doesn't make sense, hence it doesn't really limit the intended functionality of the implemented codebase.\n\nAm I mistaken somewhere?\n\n**sammy-tm**\n\nYou're correct; however, it doesn't expressly state that the artists are not supposed to do this. Neither does it prevent them from doing so. A naive artist may read the documentation and want to mimic an IRL auction/ private ownership for their art, so they would set the fees to 0%. But doing so visibly breaks the protocol. This needs to be handled either during configuration (as @gravenp mentioned) \n>I agree that as implemented, we allowed it, and it breaks things. Our fix will not allow the artist/admin to configure a 0% honorarium as this specific configuration isn't core to our intended functionality.\n\nor  mitigated using the recommendation in the Issue.\n\n\n**Al-Qa-qa**\n\nThe documentation did not deny setting 0 fees totally, it expresses that setting 0% is not typically advisable (Or What means this).\n\n> The 0% Honorarium example is the theoretical limit\n\nThis sentence does not exist in the docs, The docs did not explain that 0% is prevented or other, it explained that `it's like the Steward owns the thing they're managing as if it were their own property. They get all the benefits without having to pay anything for it`\n\nSo according to the documentation which was the only resource for that issue in the Auditing period, setting 0% Honorarium was not prevented totally, nor said by the Devs in the README, nor that edge case was handled in the code.\n\nI hope the issue gets reviewed according to the information that was with us (Auditors) in the Auditing period, The points that the sponsor said after the Auditing finished (In Escalation) should not be taken as proof to either validate or invalidate issues.\n\nAnd if the likelihood of the issue is LOW, its impact is so HIGH. And this is illustrated in my report, and escalation engagements.\n\n**Hash01011122**\n\nThis issue, along with its duplicates #12 and #107, should be deemed valid. It highlights the complication arising from a 0% honorarium rate, contradicting the project documentation which states this as a theoretical limit not reflected in the codebase. Moreover, the documentation does not clearly advise against its use. What are your thoughts, @Czar102?\n\n**Evert0x**\n\nI believe this issue should be valid and the main issue (12) should be assigned Medium severity. \n\n**gravenp**\n\nIt doesn't seem that #12 is the right parent issue to me. #42 and #107 appear to be the proper issues to connect here, @Hash01011122. \n\n**sammy-tm**\n\n#42 is about setting the fee denominator to 0, which is a completely different issue and is invalid.\n\n**Al-Qa-qa**\n\nI read issue `12`, and the issue is about different Root causes and Impact.\n\nCould you give another look at it @Hash01011122 , and determine your final thought about this issue, whether it is a Dup of `31` and `107` or not?\n\n**sammy-tm**\n\nWent through #12, agree with @Al-Qa-qa that the concern highlighted in the issue is completely different from #31 and #107. I think the judge has incorrectly grouped these together because the mitigation step is the same.\n\nIf you read carefully, #12 is a wrong interpretation of the codebase and focuses on user input validation (invalid according to sherlock rules)\n\nQuoting Issue #12 :\n>The root of the issue is the expectation that the fee should be paid on top of the bidAmount, which goes fully against documentation and poses many problems.\n Since the protocol has the stated requirement of 100% collateralisation, many valid bids will revert with the confusing message that you need overcollateralisation.\n_**@>\"The fee is a percentage of the bid, so there is no logical reason why the fee should be paid on top of the bid.\"**_\nEven if users are willing to overcollateralise, for every bid they need to take into account both collateral paid and fee paid and recalculate both perfectly to be within rounding error. This is prone to error.\nIn a heated auction with many competing bidders trying to take the price close to a deadline, the complexity demanded to perfectly calculate every bid is not realistic. This will lead to many valid bids being reverted due to a wei-sized deviation and the auction will close at a lower price than the highest valid bid submitted. This constitutes a loss to the creator's circle and the current holder of the license.\n\nIt talks about how it is \"confusing\" to the user to pay the fee on top of the bid and argues against the intended implementation of the codebase. It is known that the codebase is implemented in such a way that the user is **expected** to pay the fee on top of the bid. The watson has simply misinterpreted the codebase and this is further illustrated by the example scenario described by the watson in the issue.\n\nIssue #12 has nothing to do with the `Honorarium Rate` being set to 0.\n\nI urge the judges @Evert0x @Hash01011122 and the sponsor @gravenp  to go through #12 separately and remove duplication from #31 and #107 \n\n**Hash01011122**\n\n@sammy-tm thanks for providing a detailed explanation for every issue of this family, after inspecting issues thoroughly I can say #31 is valid finding with #107 as its dup @Evert0x \n\n**Evert0x**\n\nAgree with the proposed outcome here. Thanks @sammy-tm \n\nPlanning to accept escalation, make #31 a Medium issue with #107 as a duplicate.\n\n\n**Evert0x**\n\nResult:\nMedium\nHas Duplicates \n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [cawfree](https://github.com/sherlock-audit/2024-02-radicalxchange-judging/issues/31/#issuecomment-2025282881): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/191",
  "Code": [
    {
      "filename": "contracts/auction/facets/EnglishPeriodicAuctionFacet.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { EnglishPeriodicAuctionInternal } from '../EnglishPeriodicAuctionInternal.sol';\nimport { IPeriodicAuctionReadable } from '../IPeriodicAuctionReadable.sol';\nimport { IPeriodicAuctionWritable } from '../IPeriodicAuctionWritable.sol';\nimport { IAllowlistReadable } from '../../allowlist/IAllowlistReadable.sol';\nimport { ERC165BaseInternal } from '@solidstate/contracts/introspection/ERC165/base/ERC165BaseInternal.sol';\nimport { AccessControlInternal } from '@solidstate/contracts/access/access_control/AccessControlInternal.sol';\n\n/**\n * @title EnglishPeriodicAuctionFacet\n */\ncontract EnglishPeriodicAuctionFacet is\n    IPeriodicAuctionReadable,\n    IPeriodicAuctionWritable,\n    EnglishPeriodicAuctionInternal,\n    AccessControlInternal,\n    ERC165BaseInternal\n{\n    // Component role\n    bytes32 internal constant COMPONENT_ROLE =\n        keccak256('EnglishPeriodicAuctionFacet.COMPONENT_ROLE');\n\n    /**\n     * @notice Initialize auction parameters\n     */\n    function initializeAuction(\n        address repossessor_,\n        address initialBidder_,\n        uint256 initialPeriodStartTime_,\n        uint256 initialPeriodStartTimeOffset_,\n        uint256 startingBid_,\n        uint256 auctionLengthSeconds_,\n        uint256 minBidIncrement_,\n        uint256 bidExtensionWindowLengthSeconds_,\n        uint256 bidExtensionSeconds_\n    ) external {\n        require(\n            !_isInitialized(),\n            'EnglishPeriodicAuctionFacet: already initialized'\n        );\n\n        _setSupportsInterface(type(IPeriodicAuctionReadable).interfaceId, true);\n        _initializeAuction(\n            repossessor_,\n            initialBidder_,\n            initialPeriodStartTime_,\n            initialPeriodStartTimeOffset_,\n            startingBid_,\n            auctionLengthSeconds_,\n            minBidIncrement_,\n            bidExtensionWindowLengthSeconds_,\n            bidExtensionSeconds_\n        );\n    }\n\n    /**\n     * @notice Initialize auction parameters with owner\n     */\n    function initializeAuction(\n        address owner_,\n        address repossessor_,\n        address initialBidder_,\n        uint256 initialPeriodStartTime_,\n        uint256 initialPeriodStartTimeOffset_,\n        uint256 startingBid_,\n        uint256 auctionLengthSeconds_,\n        uint256 minBidIncrement_,\n        uint256 bidExtensionWindowLengthSeconds_,\n        uint256 bidExtensionSeconds_\n    ) external {\n        require(\n            !_isInitialized(),\n            'EnglishPeriodicAuctionFacet: already initialized'\n        );\n\n        _setSupportsInterface(type(IPeriodicAuctionReadable).interfaceId, true);\n        _setSupportsInterface(type(IPeriodicAuctionWritable).interfaceId, true);\n        _grantRole(COMPONENT_ROLE, owner_);\n        _initializeAuction(\n            repossessor_,\n            initialBidder_,\n            initialPeriodStartTime_,\n            initialPeriodStartTimeOffset_,\n            startingBid_,\n            auctionLengthSeconds_,\n            minBidIncrement_,\n            bidExtensionWindowLengthSeconds_,\n            bidExtensionSeconds_\n        );\n    }\n\n    /**\n     * @notice Set auction parameters\n     */\n    function setAuctionParameters(\n        address repossessor_,\n        uint256 auctionLengthSeconds_,\n        uint256 minBidIncrement_,\n        uint256 bidExtensionWindowLengthSeconds_,\n        uint256 bidExtensionSeconds_,\n        uint256 startingBid_\n    ) external onlyRole(COMPONENT_ROLE) {\n        _setAuctionParameters(\n            repossessor_,\n            auctionLengthSeconds_,\n            minBidIncrement_,\n            bidExtensionWindowLengthSeconds_,\n            bidExtensionSeconds_,\n            startingBid_\n        );\n    }\n\n    /**\n     * @notice Get starting bid\n     */\n    function startingBid() external view returns (uint256) {\n        return _startingBid();\n    }\n\n    /**\n     * @notice Get is auction period\n     */\n    function isAuctionPeriod(uint256 tokenId) external view returns (bool) {\n        return _isAuctionPeriod(tokenId);\n    }\n\n    /**\n     * @notice Get initial period start time\n     */\n    function initialPeriodStartTime() external view returns (uint256) {\n        return _initialPeriodStartTime();\n    }\n\n    /**\n     * @notice Get initial bidder\n     */\n    function initialBidder() external view returns (address) {\n        return _initialBidder();\n    }\n\n    /**\n     * @notice Is token ready for transfer\n     */\n    function isReadyForTransfer(uint256 tokenId) external view returns (bool) {\n        return _isReadyForTransfer(tokenId);\n    }\n\n    /**\n     * @notice Place a bid\n     */\n    function placeBid(uint256 tokenId, uint256 bidAmount) external payable {\n        require(\n            _isAuctionPeriod(tokenId),\n            'EnglishPeriodicAuction: can only place bid in auction period'\n        );\n        require(\n            !_isReadyForTransfer(tokenId),\n            'EnglishPeriodicAuction: auction is over and awaiting transfer'\n        );\n        require(\n            IAllowlistReadable(address(this)).isAllowed(msg.sender),\n            'EnglishPeriodicAuction: sender is not allowed to place bid'\n        );\n\n        _placeBid(tokenId, msg.sender, bidAmount, msg.value);\n    }\n\n    /**\n     * @notice Cancel bid for current round\n     */\n    function cancelBid(uint256 tokenId, uint256 round) external {\n        _cancelBid(tokenId, round, msg.sender);\n    }\n\n    /**\n     * @notice Withdraw collateral\n     */\n    function withdrawCollateral() external {\n        _withdrawCollateral(msg.sender);\n    }\n\n    /**\n     * @notice Cancel all bids and withdraw collateral\n     */\n    function cancelAllBidsAndWithdrawCollateral(uint256 tokenId) external {\n        _cancelAllBids(tokenId, msg.sender);\n        _withdrawCollateral(msg.sender);\n    }\n\n    /**\n     * @notice Cancel bid for current round and withdraw collateral\n     */\n    function cancelBidAndWithdrawCollateral(\n        uint256 tokenId,\n        uint256 round\n    ) external {\n        _cancelBid(tokenId, round, msg.sender);\n        _withdrawCollateral(msg.sender);\n    }\n\n    /**\n     * @notice Get locked collateral from all bids\n     */\n    function lockedCollateral(\n        uint256 tokenId,\n        address bidder\n    ) external view returns (uint256) {\n        return _lockedCollateral(tokenId, bidder);\n    }\n\n    /**\n     * @notice Get available collateral\n     */\n    function availableCollateral(\n        address bidder\n    ) external view returns (uint256) {\n        return _availableCollateral(bidder);\n    }\n\n    /**\n     * @notice Close auction and trigger a transfer to the highest bidder\n     */\n    function closeAuction(uint256 tokenId) external {\n        require(\n            _isReadyForTransfer(tokenId),\n            'EnglishPeriodicAuction: auction is not over'\n        );\n\n        _closeAuction(tokenId);\n    }\n\n    /**\n     * @notice Calculate fee from bid\n     */\n    function calculateFeeFromBid(\n        uint256 bidAmount\n    ) external view returns (uint256) {\n        return _calculateFeeFromBid(bidAmount);\n    }\n\n    /**\n     * @notice Get auction start time\n     */\n    function auctionStartTime(uint256 tokenId) external view returns (uint256) {\n        return _auctionStartTime(tokenId);\n    }\n\n    /**\n     * @notice Get auction end time\n     */\n    function auctionEndTime(uint256 tokenId) external view returns (uint256) {\n        return _auctionEndTime(tokenId);\n    }\n\n    /**\n     * @notice Get repossessor\n     */\n    function repossessor() external view returns (address) {\n        return _repossessor();\n    }\n\n    /**\n     * @notice Set starting bid\n     */\n    function setStartingBid(\n        uint256 startingBid_\n    ) external onlyRole(COMPONENT_ROLE) {\n        _setStartingBid(startingBid_);\n    }\n\n    /**\n     * @notice Set repossessor\n     */\n    function setRepossessor(\n        address repossessor_\n    ) external onlyRole(COMPONENT_ROLE) {\n        _setRepossessor(repossessor_);\n    }\n\n    /**\n     * @notice Get auction length\n     */\n    function auctionLengthSeconds() external view returns (uint256) {\n        return _auctionLengthSeconds();\n    }\n\n    /**\n     * @notice Set auction length\n     */\n    function setAuctionLengthSeconds(\n        uint256 auctionLengthSeconds_\n    ) external onlyRole(COMPONENT_ROLE) {\n        _setAuctionLengthSeconds(auctionLengthSeconds_);\n    }\n\n    /**\n     * @notice Get minimum bid increment\n     */\n    function minBidIncrement() external view returns (uint256) {\n        return _minBidIncrement();\n    }\n\n    /**\n     * @notice Set minimum bid increment\n     */\n    function setMinBidIncrement(\n        uint256 minBidIncrement_\n    ) external onlyRole(COMPONENT_ROLE) {\n        _setMinBidIncrement(minBidIncrement_);\n    }\n\n    /**\n     * @notice Get bid extension window length\n     */\n    function bidExtensionWindowLengthSeconds() external view returns (uint256) {\n        return _bidExtensionWindowLengthSeconds();\n    }\n\n    /**\n     * @notice Set bid extension window length\n     */\n    function setBidExtensionWindowLengthSeconds(\n        uint256 bidExtensionWindowLengthSeconds_\n    ) external onlyRole(COMPONENT_ROLE) {\n        _setBidExtensionWindowLengthSeconds(bidExtensionWindowLengthSeconds_);\n    }\n\n    /**\n     *  @notice Get bid extension seconds\n     */\n    function bidExtensionSeconds() external view returns (uint256) {\n        return _bidExtensionSeconds();\n    }\n\n    /**\n     *  @notice Set bid extension seconds\n     */\n    function setBidExtensionSeconds(\n        uint256 bidExtensionSeconds_\n    ) external onlyRole(COMPONENT_ROLE) {\n        _setBidExtensionSeconds(bidExtensionSeconds_);\n    }\n\n    /**\n     * @notice Get highest outstanding bid\n     */\n    function highestBid(uint256 tokenId) external view returns (Bid memory) {\n        return _highestBid(tokenId, _currentAuctionRound(tokenId));\n    }\n\n    /**\n     * @notice Get highest outstanding bid for a particular round\n     */\n    function highestBid(\n        uint256 tokenId,\n        uint256 round\n    ) external view returns (Bid memory) {\n        return _highestBid(tokenId, round);\n    }\n\n    /**\n     * @notice Get bid for address\n     */\n    function bidOf(\n        uint256 tokenId,\n        address bidder\n    ) external view returns (Bid memory) {\n        return _bidOf(tokenId, _currentAuctionRound(tokenId), bidder);\n    }\n\n    /**\n     * @notice Get bid for address for particular round\n     */\n    function bidOf(\n        uint256 tokenId,\n        uint256 round,\n        address bidder\n    ) external view returns (Bid memory) {\n        return _bidOf(tokenId, round, bidder);\n    }\n\n    /**\n     * @notice Get current auction round\n     */\n    function currentAuctionRound(\n        uint256 tokenId\n    ) external view returns (uint256) {\n        return _currentAuctionRound(tokenId);\n    }\n}"
    },
    {
      "filename": "contracts/auction/EnglishPeriodicAuctionInternal.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { EnglishPeriodicAuctionStorage } from './EnglishPeriodicAuctionStorage.sol';\nimport { IPeriodicPCOParamsReadable } from '../pco/IPeriodicPCOParamsReadable.sol';\nimport { IStewardLicense } from '../license/IStewardLicense.sol';\nimport { IBeneficiary } from '../beneficiary/IBeneficiary.sol';\nimport { IEnglishPeriodicAuctionInternal } from './IEnglishPeriodicAuctionInternal.sol';\n\n/**\n * @title EnglishPeriodicAuctionInternal\n */\nabstract contract EnglishPeriodicAuctionInternal is\n    IEnglishPeriodicAuctionInternal\n{\n    /**\n     * @notice Initialize parameters\n     */\n    function _initializeAuction(\n        address repossessor,\n        address initialBidder,\n        uint256 initialPeriodStartTime,\n        uint256 initialPeriodStartTimeOffset,\n        uint256 startingBid,\n        uint256 auctionLengthSeconds,\n        uint256 minBidIncrement,\n        uint256 bidExtensionWindowLengthSeconds,\n        uint256 bidExtensionSeconds\n    ) internal {\n        EnglishPeriodicAuctionStorage.Layout\n            storage l = EnglishPeriodicAuctionStorage.layout();\n\n        l.isInitialized = true;\n        l.initialBidder = initialBidder;\n        l.initialPeriodStartTimeOffset = initialPeriodStartTimeOffset;\n        l.initialPeriodStartTime = initialPeriodStartTime;\n        _setStartingBid(startingBid);\n        _setRepossessor(repossessor);\n        _setAuctionLengthSeconds(auctionLengthSeconds);\n        _setMinBidIncrement(minBidIncrement);\n        _setBidExtensionWindowLengthSeconds(bidExtensionWindowLengthSeconds);\n        _setBidExtensionSeconds(bidExtensionSeconds);\n    }\n\n    /**\n     * @notice Set auction parameters\n     */\n    function _setAuctionParameters(\n        address repossessor,\n        uint256 auctionLengthSeconds,\n        uint256 minBidIncrement,\n        uint256 bidExtensionWindowLengthSeconds,\n        uint256 bidExtensionSeconds,\n        uint256 startingBid\n    ) internal {\n        _setRepossessor(repossessor);\n        _setAuctionLengthSeconds(auctionLengthSeconds);\n        _setMinBidIncrement(minBidIncrement);\n        _setBidExtensionWindowLengthSeconds(bidExtensionWindowLengthSeconds);\n        _setBidExtensionSeconds(bidExtensionSeconds);\n        _setStartingBid(startingBid);\n    }\n\n    /**\n     * @notice Check if initialized\n     */\n    function _isInitialized() internal view returns (bool) {\n        return EnglishPeriodicAuctionStorage.layout().isInitialized;\n    }\n\n    /**\n     * @notice Get starting bid\n     */\n    function _startingBid() internal view returns (uint256) {\n        return EnglishPeriodicAuctionStorage.layout().startingBid;\n    }\n\n    /**\n     * @notice Get repossessor\n     */\n    function _repossessor() internal view returns (address) {\n        return EnglishPeriodicAuctionStorage.layout().repossessor;\n    }\n\n    /**\n     * @notice Set repossessor\n     */\n    function _setRepossessor(address repossessor) internal {\n        EnglishPeriodicAuctionStorage.layout().repossessor = repossessor;\n\n        emit RepossessorSet(repossessor);\n    }\n\n    /**\n     * @notice Get initial period start time\n     */\n    function _initialPeriodStartTime() internal view returns (uint256) {\n        return EnglishPeriodicAuctionStorage.layout().initialPeriodStartTime;\n    }\n\n    /**\n     * @notice Get auction length\n     */\n    function _auctionLengthSeconds() internal view returns (uint256) {\n        return EnglishPeriodicAuctionStorage.layout().auctionLengthSeconds;\n    }\n\n    /**\n     * @notice Set starting bid\n     */\n    function _setStartingBid(uint256 startingBid) internal {\n        EnglishPeriodicAuctionStorage.layout().startingBid = startingBid;\n\n        emit StartingBidSet(startingBid);\n    }\n\n    /**\n     * @notice Set auction length\n     */\n    function _setAuctionLengthSeconds(uint256 auctionLengthSeconds) internal {\n        EnglishPeriodicAuctionStorage\n            .layout()\n            .auctionLengthSeconds = auctionLengthSeconds;\n\n        emit AuctionLengthSet(auctionLengthSeconds);\n    }\n\n    /**\n     * @notice Get minimum bid increment\n     */\n    function _minBidIncrement() internal view returns (uint256) {\n        return EnglishPeriodicAuctionStorage.layout().minBidIncrement;\n    }\n\n    /**\n     * @notice Set minimum bid increment\n     */\n    function _setMinBidIncrement(uint256 minBidIncrement) internal {\n        EnglishPeriodicAuctionStorage\n            .layout()\n            .minBidIncrement = minBidIncrement;\n\n        emit MinBidIncrementSet(minBidIncrement);\n    }\n\n    /**\n     * @notice Get bid extension window length\n     */\n    function _bidExtensionWindowLengthSeconds()\n        internal\n        view\n        returns (uint256)\n    {\n        return\n            EnglishPeriodicAuctionStorage\n                .layout()\n                .bidExtensionWindowLengthSeconds;\n    }\n\n    /**\n     * @notice Set bid extension window length\n     */\n    function _setBidExtensionWindowLengthSeconds(\n        uint256 bidExtensionWindowLengthSeconds\n    ) internal {\n        EnglishPeriodicAuctionStorage\n            .layout()\n            .bidExtensionWindowLengthSeconds = bidExtensionWindowLengthSeconds;\n\n        emit BidExtensionWindowLengthSet(bidExtensionWindowLengthSeconds);\n    }\n\n    /**\n     * @notice Get bid extension\n     */\n    function _bidExtensionSeconds() internal view returns (uint256) {\n        return EnglishPeriodicAuctionStorage.layout().bidExtensionSeconds;\n    }\n\n    /**\n     * @notice Set bid extension\n     */\n    function _setBidExtensionSeconds(uint256 bidExtensionSeconds) internal {\n        EnglishPeriodicAuctionStorage\n            .layout()\n            .bidExtensionSeconds = bidExtensionSeconds;\n\n        emit BidExtensionSet(bidExtensionSeconds);\n    }\n\n    /**\n     * @notice Get initial bidder\n     */\n    function _initialBidder() internal view returns (address) {\n        return EnglishPeriodicAuctionStorage.layout().initialBidder;\n    }\n\n    /**\n     * @notice Get highest outstanding bid\n     */\n    function _highestBid(\n        uint256 tokenId,\n        uint256 round\n    ) internal view returns (Bid storage) {\n        return\n            EnglishPeriodicAuctionStorage.layout().highestBids[tokenId][round];\n    }\n\n    /**\n     * @notice Get bid for address\n     */\n    function _bidOf(\n        uint256 tokenId,\n        uint256 round,\n        address bidder\n    ) internal view returns (Bid storage) {\n        return\n            EnglishPeriodicAuctionStorage.layout().bids[tokenId][round][bidder];\n    }\n\n    /**\n     * @notice Get is auction period\n     */\n    function _isAuctionPeriod(uint256 tokenId) internal view returns (bool) {\n        if (tokenId >= IStewardLicense(address(this)).maxTokenCount()) {\n            return false;\n        }\n        //slither-disable-next-line timestamp\n        return block.timestamp >= _auctionStartTime(tokenId);\n    }\n\n    /**\n     * @notice Is token ready for transfer\n     */\n    function _isReadyForTransfer(uint256 tokenId) internal view returns (bool) {\n        if (tokenId >= IStewardLicense(address(this)).maxTokenCount()) {\n            return false;\n        }\n        //slither-disable-next-line timestamp\n        return block.timestamp >= _auctionEndTime(tokenId);\n    }\n\n    /**\n     * @notice Get current auction round\n     */\n    function _currentAuctionRound(\n        uint256 tokenId\n    ) internal view returns (uint256) {\n        return\n            EnglishPeriodicAuctionStorage.layout().currentAuctionRound[tokenId];\n    }\n\n    /**\n     * @notice Get locked collateral from all bids\n     */\n    function _lockedCollateral(\n        uint256 tokenId,\n        address bidder\n    ) internal view returns (uint256) {\n        EnglishPeriodicAuctionStorage.Layout\n            storage l = EnglishPeriodicAuctionStorage.layout();\n\n        uint256 currentAuctionRound = l.currentAuctionRound[tokenId];\n        uint256 lockedCollateral = 0;\n        for (uint256 i = 0; i <= currentAuctionRound; i++) {\n            Bid storage bid = l.bids[tokenId][i][bidder];\n            lockedCollateral += bid.collateralAmount;\n        }\n\n        return lockedCollateral;\n    }\n\n    /**\n     * @notice Get available collateral\n     */\n    function _availableCollateral(\n        address bidder\n    ) internal view returns (uint256) {\n        return\n            EnglishPeriodicAuctionStorage.layout().availableCollateral[bidder];\n    }\n\n    /**\n     * @notice Place a bid\n     */\n    function _placeBid(\n        uint256 tokenId,\n        address bidder,\n        uint256 bidAmount,\n        uint256 collateralAmount\n    ) internal {\n        EnglishPeriodicAuctionStorage.Layout\n            storage l = EnglishPeriodicAuctionStorage.layout();\n\n        uint256 currentAuctionRound = l.currentAuctionRound[tokenId];\n\n        Bid storage bid = l.bids[tokenId][currentAuctionRound][bidder];\n\n        // Check if higher than starting bid\n        require(\n            bidAmount >= l.startingBid,\n            'EnglishPeriodicAuction: Bid amount must be greater than or equal to starting bid'\n        );\n\n        // Check if highest bid\n        if (l.highestBids[tokenId][currentAuctionRound].bidAmount > 0) {\n            require(\n                bidAmount >=\n                    l.highestBids[tokenId][currentAuctionRound].bidAmount +\n                        l.minBidIncrement,\n                'EnglishPeriodicAuction: Bid amount must be greater than highest outstanding bid'\n            );\n        }\n\n        uint256 totalCollateralAmount = bid.collateralAmount + collateralAmount;\n\n        uint256 feeAmount;\n        address currentBidder;\n        if (IStewardLicense(address(this)).exists(tokenId)) {\n            currentBidder = IStewardLicense(address(this)).ownerOf(tokenId);\n        } else {\n            currentBidder = l.initialBidder;\n        }\n\n        if (bidder == currentBidder) {\n            // If current bidder, collateral is entire fee amount\n            feeAmount = totalCollateralAmount;\n        } else {\n            require(\n                totalCollateralAmount > bidAmount,\n                'EnglishPeriodicAuction: Collateral must be greater than current bid'\n            );\n            // If new bidder, collateral is bidAmount + fee\n            feeAmount = totalCollateralAmount - bidAmount;\n        }\n\n        require(\n            _checkBidAmount(bidAmount, feeAmount),\n            'EnglishPeriodicAuction: Incorrect bid amount'\n        );\n\n        // Save bid\n        bid.bidder = bidder;\n        bid.bidAmount = bidAmount;\n        bid.feeAmount = feeAmount;\n        bid.collateralAmount = totalCollateralAmount;\n\n        l.highestBids[tokenId][currentAuctionRound] = bid;\n\n        emit BidPlaced(tokenId, currentAuctionRound, bid.bidder, bid.bidAmount);\n\n        // Check if auction should extend\n        uint256 auctionEndTime = _auctionEndTime(tokenId);\n\n        // slither-disable-start timestamp\n        if (\n            auctionEndTime >= block.timestamp &&\n            auctionEndTime - block.timestamp <\n            _bidExtensionWindowLengthSeconds()\n        ) {\n            uint256 auctionLengthSeconds;\n            if (l.currentAuctionLength[tokenId] == 0) {\n                auctionLengthSeconds = _auctionLengthSeconds();\n            } else {\n                auctionLengthSeconds = l.currentAuctionLength[tokenId];\n            }\n            // Extend auction\n            l.currentAuctionLength[tokenId] =\n                auctionLengthSeconds +\n                _bidExtensionSeconds();\n        }\n        // slither-disable-end timestamp\n    }\n\n    /**\n     * @notice Cancel bid for current round if not highest bidder\n     */\n    function _cancelBid(\n        uint256 tokenId,\n        uint256 round,\n        address bidder\n    ) internal {\n        EnglishPeriodicAuctionStorage.Layout\n            storage l = EnglishPeriodicAuctionStorage.layout();\n\n        address currentBidder;\n        if (IStewardLicense(address(this)).exists(tokenId)) {\n            currentBidder = IStewardLicense(address(this)).ownerOf(tokenId);\n        } else {\n            currentBidder = l.initialBidder;\n        }\n\n        require(\n            bidder != l.highestBids[tokenId][round].bidder,\n            'EnglishPeriodicAuction: Cannot cancel bid if highest bidder'\n        );\n\n        Bid storage bid = l.bids[tokenId][round][bidder];\n\n        require(\n            bid.collateralAmount > 0,\n            'EnglishPeriodicAuction: No bid to cancel'\n        );\n\n        // Make collateral available to withdraw\n        l.availableCollateral[bidder] += bid.collateralAmount;\n\n        // Reset collateral and bid\n        bid.collateralAmount = 0;\n        bid.bidAmount = 0;\n    }\n\n    /**\n     * @notice Cancel bids for all rounds\n     */\n    function _cancelAllBids(uint256 tokenId, address bidder) internal {\n        EnglishPeriodicAuctionStorage.Layout\n            storage l = EnglishPeriodicAuctionStorage.layout();\n\n        uint256 currentAuctionRound = l.currentAuctionRound[tokenId];\n\n        for (uint256 i = 0; i <= currentAuctionRound; i++) {\n            Bid storage bid = l.bids[tokenId][i][bidder];\n\n            if (bid.collateralAmount > 0) {\n                // Make collateral available to withdraw\n                l.availableCollateral[bidder] += bid.collateralAmount;\n\n                // Reset collateral and bid\n                bid.collateralAmount = 0;\n                bid.bidAmount = 0;\n            }\n        }\n    }\n\n    /**\n     * @notice Withdraw collateral\n     */\n    function _withdrawCollateral(address bidder) internal {\n        EnglishPeriodicAuctionStorage.Layout\n            storage l = EnglishPeriodicAuctionStorage.layout();\n\n        uint256 collateralAmount = l.availableCollateral[bidder];\n\n        require(\n            collateralAmount > 0,\n            'EnglishPeriodicAuction: No collateral to withdraw'\n        );\n\n        // Make collateral unavailable to withdraw\n        l.availableCollateral[bidder] = 0;\n\n        // Transfer collateral back to bidder\n        //slither-disable-next-line low-level-calls\n        (bool success, ) = bidder.call{ value: collateralAmount }('');\n        require(\n            success,\n            'EnglishPeriodicAuction: Failed to withdraw collateral'\n        );\n    }\n\n    /**\n     * @notice Close auction and trigger a transfer to the highest bidder\n     */\n    function _closeAuction(uint256 tokenId) internal {\n        EnglishPeriodicAuctionStorage.Layout\n            storage l = EnglishPeriodicAuctionStorage.layout();\n\n        uint256 currentAuctionRound = l.currentAuctionRound[tokenId];\n\n        address oldBidder;\n        if (IStewardLicense(address(this)).exists(tokenId)) {\n            oldBidder = IStewardLicense(address(this)).ownerOf(tokenId);\n        } else {\n            oldBidder = l.initialBidder;\n        }\n\n        // Set lastPeriodEndTime to the end of the current auction period\n        uint256 licensePeriod = IPeriodicPCOParamsReadable(address(this))\n            .licensePeriod();\n\n        l.lastPeriodEndTime[tokenId] = block.timestamp;\n        l.currentLicensePeriod[tokenId] = licensePeriod;\n\n        if (l.highestBids[tokenId][currentAuctionRound].bidder == address(0)) {\n            // No bids were placed, transfer to repossessor\n            Bid storage repossessorBid = l.bids[tokenId][currentAuctionRound][\n                l.repossessor\n            ];\n            repossessorBid.bidAmount = 0;\n            repossessorBid.feeAmount = 0;\n            repossessorBid.collateralAmount = 0;\n            repossessorBid.bidder = l.repossessor;\n\n            l.highestBids[tokenId][currentAuctionRound] = repossessorBid;\n        } else if (\n            l.highestBids[tokenId][currentAuctionRound].bidder != oldBidder\n        ) {\n            // Transfer bid to previous bidder's collateral\n            l.availableCollateral[oldBidder] += l\n            .highestBids[tokenId][currentAuctionRound].bidAmount;\n            l.highestBids[tokenId][currentAuctionRound].collateralAmount = 0;\n            l\n            .bids[tokenId][currentAuctionRound][\n                l.highestBids[tokenId][currentAuctionRound].bidder\n            ].collateralAmount = 0;\n        } else {\n            l.highestBids[tokenId][currentAuctionRound].collateralAmount = 0;\n            l\n            .bids[tokenId][currentAuctionRound][oldBidder].collateralAmount = 0;\n        }\n\n        emit AuctionClosed(\n            tokenId,\n            currentAuctionRound,\n            l.highestBids[tokenId][currentAuctionRound].bidder,\n            oldBidder,\n            l.highestBids[tokenId][currentAuctionRound].bidAmount\n        );\n\n        // Reset auction\n        l.currentAuctionLength[tokenId] = 0;\n        l.currentAuctionRound[tokenId] = l.currentAuctionRound[tokenId] + 1;\n\n        // Transfer to highest bidder\n        IStewardLicense(address(this)).triggerTransfer(\n            oldBidder,\n            l.highestBids[tokenId][currentAuctionRound].bidder,\n            tokenId\n        );\n\n        // Distribute fee to beneficiary\n        if (l.highestBids[tokenId][currentAuctionRound].feeAmount > 0) {\n            IBeneficiary(address(this)).distribute{\n                value: l.highestBids[tokenId][currentAuctionRound].feeAmount\n            }();\n        }\n    }\n\n    /**\n     * @notice Get auction start time\n     */\n    function _auctionStartTime(\n        uint256 tokenId\n    ) internal view returns (uint256 auctionStartTime) {\n        EnglishPeriodicAuctionStorage.Layout\n            storage l = EnglishPeriodicAuctionStorage.layout();\n\n        uint256 initialPeriodStartTime;\n        uint256 initialPeriodStartTimeOffset;\n        if (l.tokenInitialPeriodStartTime[tokenId] > 0) {\n            initialPeriodStartTime = l.tokenInitialPeriodStartTime[tokenId];\n            initialPeriodStartTimeOffset = 0;\n        } else {\n            initialPeriodStartTime = l.initialPeriodStartTime;\n            initialPeriodStartTimeOffset = l.initialPeriodStartTimeOffset;\n        }\n\n        if (l.lastPeriodEndTime[tokenId] > initialPeriodStartTime) {\n            // Auction starts after licensePeriod has elapsed\n            auctionStartTime =\n                l.lastPeriodEndTime[tokenId] +\n                l.currentLicensePeriod[tokenId];\n        } else {\n            // Auction starts at initial time\n            auctionStartTime =\n                initialPeriodStartTime +\n                (tokenId * initialPeriodStartTimeOffset);\n        }\n    }\n\n    /**\n     * @notice Get auction end time\n     */\n    function _auctionEndTime(\n        uint256 tokenId\n    ) internal view returns (uint256 auctionEndTime) {\n        EnglishPeriodicAuctionStorage.Layout\n            storage l = EnglishPeriodicAuctionStorage.layout();\n\n        uint256 auctionLengthSeconds;\n        if (l.currentAuctionLength[tokenId] == 0) {\n            auctionLengthSeconds = _auctionLengthSeconds();\n        } else {\n            auctionLengthSeconds = l.currentAuctionLength[tokenId];\n        }\n\n        auctionEndTime = _auctionStartTime(tokenId) + auctionLengthSeconds;\n    }\n\n    /**\n     * @notice Calculate fee from bid\n     */\n    function _calculateFeeFromBid(\n        uint256 bidAmount\n    ) internal view returns (uint256) {\n        uint256 feeNumerator = IPeriodicPCOParamsReadable(address(this))\n            .feeNumerator();\n        uint256 feeDenominator = IPeriodicPCOParamsReadable(address(this))\n            .feeDenominator();\n\n        return (bidAmount * feeNumerator) / feeDenominator;\n    }\n\n    /**\n     * @notice Check that fee is within rounding error of bid amount\n     */\n    function _checkBidAmount(\n        uint256 bidAmount,\n        uint256 feeAmount\n    ) internal view returns (bool) {\n        uint256 calculatedFeeAmount = _calculateFeeFromBid(bidAmount);\n\n        return calculatedFeeAmount == feeAmount;\n    }\n}"
    },
    {
      "filename": "contracts/auction/EnglishPeriodicAuctionInternal.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { EnglishPeriodicAuctionStorage } from './EnglishPeriodicAuctionStorage.sol';\nimport { IPeriodicPCOParamsReadable } from '../pco/IPeriodicPCOParamsReadable.sol';\nimport { IStewardLicense } from '../license/IStewardLicense.sol';\nimport { IBeneficiary } from '../beneficiary/IBeneficiary.sol';\nimport { IEnglishPeriodicAuctionInternal } from './IEnglishPeriodicAuctionInternal.sol';\n\n/**\n * @title EnglishPeriodicAuctionInternal\n */\nabstract contract EnglishPeriodicAuctionInternal is\n    IEnglishPeriodicAuctionInternal\n{\n    /**\n     * @notice Initialize parameters\n     */\n    function _initializeAuction(\n        address repossessor,\n        address initialBidder,\n        uint256 initialPeriodStartTime,\n        uint256 initialPeriodStartTimeOffset,\n        uint256 startingBid,\n        uint256 auctionLengthSeconds,\n        uint256 minBidIncrement,\n        uint256 bidExtensionWindowLengthSeconds,\n        uint256 bidExtensionSeconds\n    ) internal {\n        EnglishPeriodicAuctionStorage.Layout\n            storage l = EnglishPeriodicAuctionStorage.layout();\n\n        l.isInitialized = true;\n        l.initialBidder = initialBidder;\n        l.initialPeriodStartTimeOffset = initialPeriodStartTimeOffset;\n        l.initialPeriodStartTime = initialPeriodStartTime;\n        _setStartingBid(startingBid);\n        _setRepossessor(repossessor);\n        _setAuctionLengthSeconds(auctionLengthSeconds);\n        _setMinBidIncrement(minBidIncrement);\n        _setBidExtensionWindowLengthSeconds(bidExtensionWindowLengthSeconds);\n        _setBidExtensionSeconds(bidExtensionSeconds);\n    }\n\n    /**\n     * @notice Set auction parameters\n     */\n    function _setAuctionParameters(\n        address repossessor,\n        uint256 auctionLengthSeconds,\n        uint256 minBidIncrement,\n        uint256 bidExtensionWindowLengthSeconds,\n        uint256 bidExtensionSeconds,\n        uint256 startingBid\n    ) internal {\n        _setRepossessor(repossessor);\n        _setAuctionLengthSeconds(auctionLengthSeconds);\n        _setMinBidInc"
    }
  ]
}