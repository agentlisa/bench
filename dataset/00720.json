{
  "Title": "H-2: Users can deposit \"0\" ether to any round",
  "Content": "# Issue H-2: Users can deposit \"0\" ether to any round \n\nSource: https://github.com/sherlock-audit/2024-01-looksrare-judging/issues/18 \n\n## Found by \n0rpse, 0xG0P1, 0xMAKEOUTHILL, 0xrcontre360, 0xrice.cooker, Cosine, HSP, KingNFT, Krace, KupiaSec, LTDingZhen, Varun\\_05, asauditor, ast3ros, bughuntoor, cawfree, cocacola, dany.armstrong90, deepplus, dimulski, fibonacci, jasonxiale, mert\\_eren, mstpr-brainbot, nobody2018, petro1912, pontifex, s1ce, thank\\_you, unforgiven, vvv, zraxx, zzykxx\n## Summary\nThe main invariant to determine the winner is that the indexes must be in ascending order with no repetitions. Therefore, depositing \"0\" is strictly prohibited as it does not increase the index. However, there is a method by which a user can easily deposit \"0\" ether to any round without any extra costs than gas.\n## Vulnerability Detail\nAs stated in the summary, depositing \"0\" will not increment the entryIndex, leading to a potential issue with the indexes array. This, in turn, may result in an unfair winner selection due to how the upper bound is determined in the array. The relevant code snippet illustrating this behavior is found [here](https://github.com/sherlock-audit/2024-01-looksrare/blob/7d76b96a58a6aee38f23bb38b8a5daa3bdc03f7c/contracts-yolo/contracts/libraries/Arrays.sol#L17-L19).\n\nLet's check the following code snippet in the `depositETHIntoMultipleRounds` function\n```solidity\nfor (uint256 i; i < numberOfRounds; ++i) {\n            uint256 roundId = _unsafeAdd(startingRoundId, i);\n            Round storage round = rounds[roundId];\n            uint256 roundValuePerEntry = round.valuePerEntry;\n            if (roundValuePerEntry == 0) {\n                (, , roundValuePerEntry) = _writeDataToRound({roundId: roundId, roundValue: 0});\n            }\n\n            _incrementUserDepositCount(roundId, round);\n\n            // @review depositAmount can be \"0\"\n            uint256 depositAmount = amounts[i];\n\n            // @review 0 % ANY_NUMBER = 0\n            if (depositAmount % roundValuePerEntry != 0) {\n                revert InvalidValue();\n            }\n            uint256 entriesCount = _depositETH(round, roundId, roundValuePerEntry, depositAmount);\n            expectedValue += depositAmount;\n\n            entriesCounts[i] = entriesCount;\n        }\n\n        // @review will not fail as long as user deposits normally to 1 round\n        // then he can deposit to any round with \"0\" amounts\n        if (expectedValue != msg.value) {\n            revert InvalidValue();\n        }\n```\n\nas we can see in the above comments added by me starting with \"review\" it explains how its possible. As long as user deposits normally to 1 round then he can also deposit \"0\" amounts to any round because the `expectedValue` will be equal to msg.value.\n\n**Textual PoC:**\nAssume Alice sends the tx with 1 ether as msg.value and \"amounts\" array as [1 ether, 0, 0].\nfirst time the loop starts the 1 ether will be correctly evaluated in to the round. When the loop starts the 2nd and 3rd iterations it won't revert because the following code snippet will be \"0\" and adding 0 to `expectedValue` will not increment to `expectedValue` so the msg.value will be exactly same with the `expectedValue`.\n```solidity\nif (depositAmount % roundValuePerEntry != 0) {\n                revert InvalidValue();\n            }\n```\n\n**Coded PoC (copy the test to `Yolo.deposit.sol` file and run the test):**\n```solidity\nfunction test_deposit0ToRounds() external {\n        vm.deal(user2, 1 ether);\n        vm.deal(user3, 1 ether);\n\n        // @dev first round starts normally\n        vm.prank(user2);\n        yolo.deposit{value: 1 ether}(1, _emptyDepositsCalldata());\n\n        // @dev user3 will deposit 1 ether to the current round(1) and will deposit\n        // 0,0 to round 2 and round3\n        uint256[] memory amounts = new uint256[](3);\n        amounts[0] = 1 ether;\n        amounts[1] = 0;\n        amounts[2] = 0;\n        vm.prank(user3);\n        yolo.depositETHIntoMultipleRounds{value: 1 ether}(amounts);\n\n        // @dev check user3 indeed managed to deposit 0 ether to round2\n        IYoloV2.Deposit[] memory deposits = _getDeposits(2);\n        assertEq(deposits.length, 1);\n        IYoloV2.Deposit memory deposit = deposits[0];\n        assertEq(uint8(deposit.tokenType), uint8(IYoloV2.YoloV2__TokenType.ETH));\n        assertEq(deposit.tokenAddress, address(0));\n        assertEq(deposit.tokenId, 0);\n        assertEq(deposit.tokenAmount, 0);\n        assertEq(deposit.depositor, user3);\n        assertFalse(deposit.withdrawn);\n        assertEq(deposit.currentEntryIndex, 0);\n\n        // @dev check user3 indeed managed to deposit 0 ether to round3\n        deposits = _getDeposits(3);\n        assertEq(deposits.length, 1);\n        deposit = deposits[0];\n        assertEq(uint8(deposit.tokenType), uint8(IYoloV2.YoloV2__TokenType.ETH));\n        assertEq(deposit.tokenAddress, address(0));\n        assertEq(deposit.tokenId, 0);\n        assertEq(deposit.tokenAmount, 0);\n        assertEq(deposit.depositor, user3);\n        assertFalse(deposit.withdrawn);\n        assertEq(deposit.currentEntryIndex, 0);\n    }\n```\n## Impact\nHigh, since it will alter the games winner selection and it is very cheap to perform the attack.\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-01-looksrare/blob/7d76b96a58a6aee38f23bb38b8a5daa3bdc03f7c/contracts-yolo/contracts/YoloV2.sol#L312-L362\n## Tool used\n\nManual Review\n\n## Recommendation\nAdd the following check inside the depositETHIntoMultipleRounds function\n```solidity\nif (depositAmount == 0) {\n     revert InvalidValue();\n   }\n```\n\n\n\n## Discussion\n\n**0xhiroshi**\n\nhttps://github.com/LooksRare/contracts-yolo/pull/176\n\n**sherlock-admin2**\n\n2 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  valid because {valid: but the impact is very low compared to the duplicated issue 002}, ?\n\n**takarez** commented:\n>  valid: high(1)\n\n\n\n**mstpr**\n\n> LooksRare/contracts-yolo#176\n\nFix LGTM!\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/163",
  "Code": [
    {
      "filename": "contracts-yolo/contracts/libraries/Arrays.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/**\n * @dev Collection of functions related to array types.\n *      Modified from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Arrays.sol\n */\nlibrary Arrays {\n    /**\n     * @dev Searches a sorted `array` and returns the first index that contains\n     * a value greater or equal to `element`. If no such index exists (i.e. all\n     * values in the array are strictly less than `element`), the array length is\n     * returned. Time complexity O(log n).\n     *\n     * `array` is expected to be sorted in ascending order, and to contain no\n     * repeated elements.\n     */\n    function findUpperBound(uint256[] memory array, uint256 element) internal pure returns (uint256) {\n        if (array.length == 0) {\n            return 0;\n        }\n\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds down (it does integer division with truncation).\n            if (array[mid] > element) {\n                high = mid;\n            } else {\n                unchecked {\n                    low = mid + 1;\n                }\n            }\n        }\n\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\n        if (low > 0 && array[low - 1] == element) {\n            unchecked {\n                return low - 1;\n            }\n        } else {\n            return low;\n        }\n    }\n}"
    },
    {
      "filename": "contracts-yolo/contracts/YoloV2.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {ITransferManager} from \"@looksrare/contracts-transfer-manager/contracts/interfaces/ITransferManager.sol\";\nimport {TokenType as TransferManager__TokenType} from \"@looksrare/contracts-transfer-manager/contracts/enums/TokenType.sol\";\nimport {IERC20} from \"@looksrare/contracts-libs/contracts/interfaces/generic/IERC20.sol\";\nimport {SignatureCheckerMemory} from \"@looksrare/contracts-libs/contracts/SignatureCheckerMemory.sol\";\nimport {ReentrancyGuard} from \"@looksrare/contracts-libs/contracts/ReentrancyGuard.sol\";\nimport {Pausable} from \"@looksrare/contracts-libs/contracts/Pausable.sol\";\n\nimport {LowLevelWETH} from \"@looksrare/contracts-libs/contracts/lowLevelCallers/LowLevelWETH.sol\";\nimport {LowLevelERC20Transfer} from \"@looksrare/contracts-libs/contracts/lowLevelCallers/LowLevelERC20Transfer.sol\";\nimport {LowLevelERC721Transfer} from \"@looksrare/contracts-libs/contracts/lowLevelCallers/LowLevelERC721Transfer.sol\";\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {VRFCoordinatorV2Interface} from \"@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\";\nimport {VRFConsumerBaseV2} from \"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\";\n\nimport {IYoloV2} from \"./interfaces/IYoloV2.sol\";\nimport {IPriceOracle} from \"./interfaces/IPriceOracle.sol\";\nimport {Arrays} from \"./libraries/Arrays.sol\";\n\n//                                          @@@@@@@@@@@@@                                        @@@@@@@@@@@@@\n// @@@@@@@@@@@@@@@       @@@@@@@@@@@@@@ @@@@%*+++++++++*%@@@@     @@@@@@@@@@@@@@             @@@@%+-:::::::-+%@@@@\n//  @#:........=@@      @@*.........+@@@@*=================*@@@   @@=........=@@           @@@+.................+@@@\n//  @@=........:#@@     @@.........:@@%+=====================+%@@ @@=........=@@         @@%-.....................-#@@\n//  @@%:........=@@    @@=........:%@*=========================+%@@@=........=@@       @@%-.........................=@@@\n//   @@+........:#@   @@#........:%%============================+#@@=........=@@      @@#:...........................:#@@\n//    @@:........+@@  @@:.......:#%%@#*=======*%%@@@%%*==========+%@=........=@@      @#:.........:=*%%@%%#=..........:#@@\n//    @@#........:%@ @@+........+%+==+#@@*==#@@@@   @@@@#=========+@#........=@@     @%-........:*@@@@   @@@@+:........-%@\n//     @@=........=@@@#:.......-%*=======*@@@@         @@@=========*@:.......+@@    @@*.........@@@         @@%:........+@@\n//      @%:.......:%@@=........=@+========*@@            @%=========@+.......+@@    @@-........%@@           @@*........=%@\n//      @@+:.....:.-@#:.:......+@@@@@@@@@@@@             @@%%%%%%%%#@#::....:+@@    @@:.:.....:@@             @@::.:..:.-%@\n//       @%-::::::::*-:::::::::@@*+++++++*@@             @@+++++++++@*:::::::+@@    @@:::::::::%@            @@%::::::::-%@\n//       @@%********=:::::::::*@@*+*#%@@@##@@           @@*========+@=:::::::+@@    @@=::::::::=@@           @@=::::::::+@@\n//        @@@@@@@@@@:::::::::=@@@@@#*++++++*@@        @@@+=========%@::::::::+@@     @%:::::::::=@@@       @@@=:::::::::#@@\n//               @@=:::::::::%@ @@*++++++++++*@@@@@@@@@*+========+#@+::::::::+%@@@@@@@%+::::::::::+@@@@@@@@@+::::::::::+@@\n//              @@#:::::::::*@@  @@*+++++++++*@#++++++==========+*@@+::::::::::::::::::::::::::::::::-===-::::::::::::=@@\n//              @@-::::::::-%@    @@#++++++++%%+===============+#@@@+::::::::::::::::::::::::::::::::::::::::::::::::*@@\n//             @@+:::::::::*@@     @@@*+++++%%+===============*%@@@@+:::::::::::::::::::::*=:::::::::::::::::::::::=%@@\n//             @%-::::::::=@@        @@@#++#@*+============+*@@@  @@+:::::::::::::::::::::%@%+-::::::::::::::::::+%@@\n//            @@%*********%@@          @@@@@*+==========+#@@@@    @@#*********************%@@@@@*-:::::::::::-*@@@@\n//            @@@@@@@@@@@@@@              @@@@@@@%%%@@@@@@@       @@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@%%%@@@@@@@\n//                                               @@@@                                                @@@@@\n\n/**\n * @title YoloV2\n * @notice This contract permissionlessly hosts yolos on LooksRare.\n * @author LooksRare protocol team (ðŸ‘€,ðŸ’Ž)\n */\ncontract YoloV2 is\n    IYoloV2,\n    AccessControl,\n    VRFConsumerBaseV2,\n    LowLevelWETH,\n    LowLevelERC20Transfer,\n    LowLevelERC721Transfer,\n    ReentrancyGuard,\n    Pausable\n{\n    using Arrays for uint256[];\n\n    /**\n     * @notice Operators are allowed to add/remove allowed ERC-20 and ERC-721 tokens.\n     */\n    bytes32 public constant OPERATOR_ROLE = keccak256(\"OPERATOR_ROLE\");\n\n    /**\n     * @notice The TWAP period in seconds to use.\n     */\n    uint256 private constant TWAP_DURATION = 3_600;\n\n    /**\n     * @notice The maximum protocol fee in basis points, which is 25%.\n     */\n    uint16 public constant MAXIMUM_PROTOCOL_FEE_BP = 2_500;\n\n    /**\n     * @notice The maximum number of deposits per round.\n     */\n    uint256 private constant MAXIMUM_NUMBER_OF_DEPOSITS_PER_ROUND = 100;\n\n    /**\n     * @notice Reservoir oracle's message typehash.\n     * @dev It is used to compute the hash of the message using the (message) id, the payload, and the timestamp.\n     */\n    bytes32 private constant RESERVOIR_ORACLE_MESSAGE_TYPEHASH =\n        keccak256(\"Message(bytes32 id,bytes payload,uint256 timestamp,uint256 chainId)\");\n\n    /**\n     * @notice Reservoir oracle's ID typehash.\n     * @dev It is used to compute the hash of the ID using price kind, TWAP seconds, and the contract address.\n     */\n    bytes32 private constant RESERVOIR_ORACLE_ID_TYPEHASH =\n        keccak256(\n            \"ContractWideCollectionPrice(uint8 kind,uint256 twapSeconds,address contract,bool onlyNonFlaggedTokens)\"\n        );\n\n    /**\n     * @notice The bits offset of the round's maximum number of participants in a round slot.\n     */\n    uint256 private constant ROUND__MAXIMUM_NUMBER_OF_PARTICIPANTS_OFFSET = 8;\n\n    /**\n     * @notice The bits offset of the round's protocol fee basis points in a round slot.\n     */\n    uint256 private constant ROUND__PROTOCOL_FEE_BP_OFFSET = 48;\n\n    /**\n     * @notice The bits offset of the round's cutoff time in a round slot.\n     */\n    uint256 private constant ROUND__CUTOFF_TIME_OFFSET = 64;\n\n    /**\n     * @notice The bits offset of the round's value per entry in a round slot.\n     */\n    uint256 private constant ROUND__VALUE_PER_ENTRY_OFFSET = 160;\n\n    /**\n     * @notice The slot offset of the round's value per entry starting from the round's slot.\n     */\n    uint256 private constant ROUND__VALUE_PER_ENTRY_SLOT_OFFSET = 1;\n\n    /**\n     * @notice The bits offset of the randomness request's round ID in a randomness request slot.\n     */\n    uint256 private constant RANDOMNESS_REQUEST__ROUND_ID_OFFSET = 8;\n\n    /**\n     * @notice The slot offset of the round's deposits length starting from the round's slot.\n     */\n    uint256 private constant ROUND__DEPOSITS_LENGTH_SLOT_OFFSET = 3;\n\n    /**\n     * @notice The number of slots a round struct occupies.\n     */\n    uint256 private constant DEPOSIT__OCCUPIED_SLOTS = 4;\n\n    /**\n     * @notice The slot offset of the deposit's token ID starting from the deposit's slot.\n     */\n    uint256 private constant DEPOSIT__TOKEN_ID_SLOT_OFFSET = 1;\n\n    /**\n     * @notice The slot offset of the deposit's token amount starting from the deposit's slot.\n     */\n    uint256 private constant DEPOSIT__TOKEN_AMOUNT_SLOT_OFFSET = 2;\n\n    /**\n     * @notice The slot offset of the deposit's last slot starting from the deposit's slot.\n     */\n    uint256 private constant DEPOSIT__LAST_SLOT_OFFSET = 3;\n\n    /**\n     * @notice The bits offset of the deposit's token address in the deposit's slot 0.\n     */\n    uint256 private constant DEPOSIT__TOKEN_ADDRESS_OFFSET = 8;\n\n    /**\n     * @notice The bits offset of the deposit's current entry index in the deposit's slot 3.\n     */\n    uint256 private constant DEPOSIT__CURRENT_ENTRY_INDEX_OFFSET = 168;\n\n    /**\n     * @notice Wrapped Ether address.\n     */\n    address private immutable WETH;\n\n    /**\n     * @notice The key hash of the Chainlink VRF.\n     */\n    bytes32 private immutable KEY_HASH;\n\n    /**\n     * @notice The subscription ID of the Chainlink VRF.\n     */\n    uint64 public immutable SUBSCRIPTION_ID;\n\n    /**\n     * @notice The Chainlink VRF coordinator.\n     */\n    VRFCoordinatorV2Interface private immutable VRF_COORDINATOR;\n\n    /**\n     * @notice Transfer manager faciliates token transfers.\n     */\n    ITransferManager private immutable transferManager;\n\n    /**\n     * @notice LOOKS token address.\n     */\n    address private immutable LOOKS;\n\n    /**\n     * @notice The value of each entry in ETH.\n     */\n    uint96 public valuePerEntry;\n\n    /**\n     * @notice The duration of each round.\n     */\n    uint40 public roundDuration;\n\n    /**\n     * @notice The protocol fee basis points.\n     */\n    uint16 public protocolFeeBp;\n\n    /**\n     * @notice The protocol fee discount basis points if paid with LOOKS.\n     */\n    uint16 public protocolFeeDiscountBp;\n\n    /**\n     * @notice Number of rounds that have been created.\n     * @dev In this smart contract, roundId is an uint256 but its\n     *      max value can only be 2^40 - 1. Realistically we will still\n     *      not reach this number.\n     */\n    uint40 public roundsCount;\n\n    /**\n     * @notice The maximum number of participants per round.\n     */\n    uint40 public maximumNumberOfParticipantsPerRound;\n\n    /**\n     * @notice Whether token outflow is allowed.\n     */\n    bool public outflowAllowed = true;\n\n    /**\n     * @notice The address of the protocol fee recipient.\n     */\n    address public protocolFeeRecipient;\n\n    /**\n     * @notice ERC-20 oracle address.\n     */\n    IPriceOracle public erc20Oracle;\n\n    /**\n     * @notice Reservoir oracle address.\n     */\n    address public reservoirOracle;\n\n    /**\n     * @notice Reservoir oracle's signature validity period.\n     */\n    uint40 public signatureValidityPeriod;\n\n    /**\n     * @notice It checks whether the currency is allowed.\n     * @dev 0 is not allowed, 1 is allowed.\n     */\n    mapping(address currency => uint256 isAllowed) public isCurrencyAllowed;\n\n    mapping(uint256 roundId => Round) private rounds;\n\n    /**\n     * @notice The deposit count of a user in any given round.\n     */\n    mapping(uint256 roundId => mapping(address depositor => uint256 depositCount)) public depositCount;\n\n    /**\n     * @notice Chainlink randomness requests.\n     */\n    mapping(uint256 requestId => RandomnessRequest) public randomnessRequests;\n\n    /**\n     * @notice The price of an ERC-20/ERC-712 token or a collection in any given round.\n     */\n    mapping(address tokenOrCollection => mapping(uint256 roundId => uint256 price)) public prices;\n\n    /**\n     * @param params The constructor params.\n     */\n    constructor(ConstructorCalldata memory params) VRFConsumerBaseV2(params.vrfCoordinator) {\n        _grantRole(DEFAULT_ADMIN_ROLE, params.owner);\n        _grantRole(OPERATOR_ROLE, params.operator);\n        _updateRoundDuration(params.roundDuration);\n        _updateProtocolFeeRecipient(params.protocolFeeRecipient);\n        _updateProtocolFeeBp(params.protocolFeeBp);\n        _updateProtocolFeeDiscountBp(params.protocolFeeDiscountBp);\n        _updateValuePerEntry(params.valuePerEntry);\n        _updateERC20Oracle(params.erc20Oracle);\n        _updateMaximumNumberOfParticipantsPerRound(params.maximumNumberOfParticipantsPerRound);\n        _updateReservoirOracle(params.reservoirOracle);\n        _updateSignatureValidityPeriod(params.signatureValidityPeriod);\n\n        WETH = params.weth;\n        KEY_HASH = params.keyHash;\n        VRF_COORDINATOR = VRFCoordinatorV2Interface(params.vrfCoordinator);\n        SUBSCRIPTION_ID = params.subscriptionId;\n        LOOKS = params.looks;\n\n        transferManager = ITransferManager(params.transferManager);\n\n        _startRound({_roundsCount: 0});\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function deposit(uint256 roundId, DepositCalldata[] calldata deposits) external payable nonReentrant whenNotPaused {\n        _deposit(roundId, deposits);\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function depositETHIntoMultipleRounds(uint256[] calldata amounts) external payable nonReentrant whenNotPaused {\n        uint256 numberOfRounds = amounts.length;\n        if (msg.value == 0 || numberOfRounds == 0) {\n            revert ZeroDeposits();\n        }\n\n        uint256 startingRoundId = roundsCount;\n        Round storage startingRound = rounds[startingRoundId];\n        _validateRoundIsOpen(startingRound);\n\n        _setCutoffTimeIfNotSet(startingRound);\n\n        uint256 expectedValue;\n        uint256[] memory entriesCounts = new uint256[](numberOfRounds);\n\n        for (uint256 i; i < numberOfRounds; ++i) {\n            uint256 roundId = _unsafeAdd(startingRoundId, i);\n            Round storage round = rounds[roundId];\n            uint256 roundValuePerEntry = round.valuePerEntry;\n            if (roundValuePerEntry == 0) {\n                (, , roundValuePerEntry) = _writeDataToRound({roundId: roundId, roundValue: 0});\n            }\n\n            _incrementUserDepositCount(roundId, round);\n\n            uint256 depositAmount = amounts[i];\n            if (depositAmount % roundValuePerEntry != 0) {\n                revert InvalidValue();\n            }\n            uint256 entriesCount = _depositETH(round, roundId, roundValuePerEntry, depositAmount);\n            expectedValue += depositAmount;\n\n            entriesCounts[i] = entriesCount;\n        }\n\n        if (expectedValue != msg.value) {\n            revert InvalidValue();\n        }\n\n        emit MultipleRoundsDeposited(msg.sender, startingRoundId, amounts, entriesCounts);\n\n        if (\n            _shouldDrawWinner(\n                startingRound.numberOfParticipants,\n                startingRound.maximumNumberOfParticipants,\n                startingRound.deposits.length\n            )\n        ) {\n            _drawWinner(startingRound, startingRoundId);\n        }\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function getRound(\n        uint256 roundId\n    )\n        external\n        view\n        returns (\n            RoundStatus status,\n            uint40 maximumNumberOfParticipants,\n            uint16 roundProtocolFeeBp,\n            uint40 cutoffTime,\n            uint40 drawnAt,\n            uint40 numberOfParticipants,\n            address winner,\n            uint96 roundValuePerEntry,\n            uint256 protocolFeeOwed,\n            Deposit[] memory deposits\n        )\n    {\n        Round memory round = rounds[roundId];\n        status = round.status;\n        maximumNumberOfParticipants = round.maximumNumberOfParticipants;\n        roundProtocolFeeBp = round.protocolFeeBp;\n        cutoffTime = round.cutoffTime;\n        drawnAt = round.drawnAt;\n        numberOfParticipants = round.numberOfParticipants;\n        winner = round.winner;\n        roundValuePerEntry = round.valuePerEntry;\n        protocolFeeOwed = round.protocolFeeOwed;\n        deposits = round.deposits;\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function drawWinner() external nonReentrant whenNotPaused {\n        uint256 roundId = roundsCount;\n        Round storage round = rounds[roundId];\n\n        _validateRoundStatus(round, RoundStatus.Open);\n\n        if (block.timestamp < round.cutoffTime) {\n            revert CutoffTimeNotReached();\n        }\n\n        if (round.numberOfParticipants < 2) {\n            revert InsufficientParticipants();\n        }\n\n        _drawWinner(round, roundId);\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function cancel() external nonReentrant {\n        _validateOutflowIsAllowed();\n        _cancel({roundId: roundsCount});\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function cancel(uint256 numberOfRounds) external {\n        _validateIsOwner();\n\n        if (numberOfRounds == 0) {\n            revert ZeroRounds();\n        }\n\n        uint256 startingRoundId = roundsCount;\n\n        for (uint256 i; i < numberOfRounds; ++i) {\n            uint256 roundId = _unsafeAdd(startingRoundId, i);\n            rounds[roundId].status = RoundStatus.Cancelled;\n        }\n\n        emit RoundsCancelled(startingRoundId, numberOfRounds);\n\n        _startRound({_roundsCount: _unsafeSubtract(_unsafeAdd(startingRoundId, numberOfRounds), 1)});\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function cancelAfterRandomnessRequest() external nonReentrant {\n        _validateOutflowIsAllowed();\n\n        uint256 roundId = roundsCount;\n        Round storage round = rounds[roundId];\n\n        _validateRoundStatus(round, RoundStatus.Drawing);\n\n        if (block.timestamp < round.drawnAt + 1 days) {\n            revert DrawExpirationTimeNotReached();\n        }\n\n        round.status = RoundStatus.Cancelled;\n\n        emit RoundStatusUpdated(roundId, RoundStatus.Cancelled);\n\n        _startRound({_roundsCount: roundId});\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function claimPrizes(\n        WithdrawalCalldata[] calldata withdrawalCalldata,\n        bool payWithLOOKS\n    ) external payable nonReentrant {\n        _validateOutflowIsAllowed();\n\n        TransferAccumulator memory transferAccumulator;\n        uint256 ethAmount;\n        uint256 protocolFeeOwed;\n\n        _validateArrayLengthIsNotEmpty(withdrawalCalldata.length);\n\n        if (payWithLOOKS) {\n            if (msg.value != 0) {\n                revert InvalidValue();\n            }\n        }\n\n        for (uint256 i; i < withdrawalCalldata.length; ++i) {\n            WithdrawalCalldata calldata perRoundWithdrawalCalldata = withdrawalCalldata[i];\n\n            Round storage round = rounds[perRoundWithdrawalCalldata.roundId];\n\n            _validateRoundStatus(round, RoundStatus.Drawn);\n            _validateMsgSenderIsWinner(round);\n\n            uint256[] calldata depositIndices = perRoundWithdrawalCalldata.depositIndices;\n            _validateArrayLengthIsNotEmpty(depositIndices.length);\n\n            for (uint256 j; j < depositIndices.length; ++j) {\n                uint256 index = depositIndices[j];\n                _validateDepositsArrayIndex(index, round);\n                ethAmount = _transferTokenOut(round.deposits[index], transferAccumulator, ethAmount);\n            }\n\n            protocolFeeOwed += round.protocolFeeOwed;\n            round.protocolFeeOwed = 0;\n        }\n\n        if (protocolFeeOwed != 0) {\n            if (payWithLOOKS) {\n                protocolFeeOwed = _protocolFeeOwedInLOOKS(protocolFeeOwed);\n\n                transferManager.transferERC20(LOOKS, msg.sender, protocolFeeRecipient, protocolFeeOwed);\n\n                emit ProtocolFeePayment(protocolFeeOwed, LOOKS);\n            } else {\n                _transferETHAndWrapIfFailWithGasLimit(WETH, protocolFeeRecipient, protocolFeeOwed, gasleft());\n\n                emit ProtocolFeePayment(protocolFeeOwed, address(0));\n\n                protocolFeeOwed -= msg.value;\n                if (protocolFeeOwed <= ethAmount) {\n                    unchecked {\n                        ethAmount -= protocolFeeOwed;\n                    }\n                } else {\n                    revert ProtocolFeeNotPaid();\n                }\n            }\n        }\n\n        if (transferAccumulator.amount != 0) {\n            _executeERC20DirectTransfer(transferAccumulator.tokenAddress, msg.sender, transferAccumulator.amount);\n        }\n\n        if (ethAmount != 0) {\n            _transferETHAndWrapIfFailWithGasLimit(WETH, msg.sender, ethAmount, gasleft());\n        }\n\n        emit PrizesClaimed(msg.sender, withdrawalCalldata);\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     * @dev This function does not validate withdrawalCalldata to not contain duplicate round IDs and prize indices.\n     *      It is the responsibility of the caller to ensure that. Otherwise, the returned protocol fee owed will be incorrect.\n     */\n    function getClaimPrizesPaymentRequired(\n        WithdrawalCalldata[] calldata withdrawalCalldata,\n        bool payWithLOOKS\n    ) external view returns (uint256 protocolFeeOwed) {\n        uint256 ethAmount;\n\n        for (uint256 i; i < withdrawalCalldata.length; ++i) {\n            WithdrawalCalldata calldata perRoundWithdrawalCalldata = withdrawalCalldata[i];\n            Round storage round = rounds[perRoundWithdrawalCalldata.roundId];\n\n            _validateRoundStatus(round, RoundStatus.Drawn);\n\n            uint256[] calldata depositIndices = perRoundWithdrawalCalldata.depositIndices;\n            uint256 numberOfPrizes = depositIndices.length;\n            uint256 prizesCount = round.deposits.length;\n\n            for (uint256 j; j < numberOfPrizes; ++j) {\n                uint256 index = depositIndices[j];\n                if (index >= prizesCount) {\n                    revert InvalidIndex();\n                }\n\n                Deposit storage prize = round.deposits[index];\n                if (prize.tokenType == YoloV2__TokenType.ETH) {\n                    ethAmount += prize.tokenAmount;\n                }\n            }\n\n            protocolFeeOwed += round.protocolFeeOwed;\n        }\n\n        if (payWithLOOKS) {\n            protocolFeeOwed = _protocolFeeOwedInLOOKS(protocolFeeOwed);\n        } else {\n            if (protocolFeeOwed < ethAmount) {\n                protocolFeeOwed = 0;\n            } else {\n                unchecked {\n                    protocolFeeOwed -= ethAmount;\n                }\n            }\n        }\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function withdrawDeposits(WithdrawalCalldata[] calldata withdrawalCalldata) external nonReentrant {\n        _validateOutflowIsAllowed();\n\n        TransferAccumulator memory transferAccumulator;\n        uint256 ethAmount;\n\n        _validateArrayLengthIsNotEmpty(withdrawalCalldata.length);\n\n        for (uint256 i; i < withdrawalCalldata.length; ++i) {\n            WithdrawalCalldata calldata perRoundWithdrawalCalldata = withdrawalCalldata[i];\n\n            Round storage round = rounds[perRoundWithdrawalCalldata.roundId];\n\n            _validateRoundStatus(round, RoundStatus.Cancelled);\n\n            uint256[] calldata depositIndices = perRoundWithdrawalCalldata.depositIndices;\n            uint256 depositIndicesLength = depositIndices.length;\n            _validateArrayLengthIsNotEmpty(depositIndicesLength);\n\n            for (uint256 j; j < depositIndicesLength; ++j) {\n                uint256 index = depositIndices[j];\n                _validateDepositsArrayIndex(index, round);\n\n                Deposit storage singleDeposit = round.deposits[index];\n\n                _validateMsgSenderIsDepositor(singleDeposit);\n\n                ethAmount = _transferTokenOut(singleDeposit, transferAccumulator, ethAmount);\n            }\n        }\n\n        if (transferAccumulator.amount != 0) {\n            _executeERC20DirectTransfer(transferAccumulator.tokenAddress, msg.sender, transferAccumulator.amount);\n        }\n\n        if (ethAmount != 0) {\n            _transferETHAndWrapIfFailWithGasLimit(WETH, msg.sender, ethAmount, gasleft());\n        }\n\n        emit DepositsWithdrawn(msg.sender, withdrawalCalldata);\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function rolloverETH(\n        WithdrawalCalldata[] calldata withdrawalCalldata,\n        bool payWithLOOKS\n    ) external nonReentrant whenNotPaused {\n        uint256 rolloverAmount;\n        uint256 protocolFeeOwed;\n\n        uint256 withdrawalCalldataLength = withdrawalCalldata.length;\n        _validateArrayLengthIsNotEmpty(withdrawalCalldataLength);\n\n        for (uint256 i; i < withdrawalCalldataLength; ++i) {\n            WithdrawalCalldata calldata perRoundWithdrawalCalldata = withdrawalCalldata[i];\n\n            Round storage cancelledOrDrawnRound = rounds[perRoundWithdrawalCalldata.roundId];\n\n            RoundStatus status = cancelledOrDrawnRound.status;\n            if (status < RoundStatus.Drawn) {\n                revert InvalidStatus();\n            }\n\n            if (status == RoundStatus.Drawn) {\n                _validateMsgSenderIsWinner(cancelledOrDrawnRound);\n                protocolFeeOwed += cancelledOrDrawnRound.protocolFeeOwed;\n                cancelledOrDrawnRound.protocolFeeOwed = 0;\n            }\n\n            uint256[] calldata depositIndices = perRoundWithdrawalCalldata.depositIndices;\n            uint256 depositIndicesLength = depositIndices.length;\n            _validateArrayLengthIsNotEmpty(depositIndicesLength);\n\n            for (uint256 j; j < depositIndicesLength; ++j) {\n                uint256 index = depositIndices[j];\n                _validateDepositsArrayIndex(index, cancelledOrDrawnRound);\n\n                Deposit storage singleDeposit = cancelledOrDrawnRound.deposits[index];\n\n                _validateDepositNotWithdrawn(singleDeposit);\n\n                if (singleDeposit.tokenType != YoloV2__TokenType.ETH) {\n                    revert InvalidTokenType();\n                }\n\n                if (status == RoundStatus.Cancelled) {\n                    _validateMsgSenderIsDepositor(singleDeposit);\n                }\n\n                singleDeposit.withdrawn = true;\n\n                rolloverAmount += singleDeposit.tokenAmount;\n            }\n        }\n\n        if (protocolFeeOwed != 0) {\n            if (payWithLOOKS) {\n                protocolFeeOwed = _protocolFeeOwedInLOOKS(protocolFeeOwed);\n                transferManager.transferERC20(LOOKS, msg.sender, protocolFeeRecipient, protocolFeeOwed);\n\n                emit ProtocolFeePayment(protocolFeeOwed, LOOKS);\n            } else {\n                if (rolloverAmount < protocolFeeOwed) {\n                    revert ProtocolFeeNotPaid();\n                } else {\n                    unchecked {\n                        rolloverAmount -= protocolFeeOwed;\n                    }\n                }\n\n                _transferETHAndWrapIfFailWithGasLimit(WETH, protocolFeeRecipient, protocolFeeOwed, gasleft());\n\n                emit ProtocolFeePayment(protocolFeeOwed, address(0));\n            }\n        }\n\n        uint256 roundId = roundsCount;\n        Round storage round = rounds[roundId];\n        _validateRoundIsOpen(round);\n\n        _incrementUserDepositCount(roundId, round);\n        _setCutoffTimeIfNotSet(round);\n\n        uint256 roundValuePerEntry = round.valuePerEntry;\n        uint256 dust = rolloverAmount % roundValuePerEntry;\n        if (dust != 0) {\n            unchecked {\n                rolloverAmount -= dust;\n            }\n            _transferETHAndWrapIfFailWithGasLimit(WETH, msg.sender, dust, gasleft());\n        }\n\n        if (rolloverAmount < roundValuePerEntry) {\n            revert InvalidValue();\n        }\n\n        uint256 entriesCount = _depositETH(round, roundId, roundValuePerEntry, rolloverAmount);\n\n        if (_shouldDrawWinner(round.numberOfParticipants, round.maximumNumberOfParticipants, round.deposits.length)) {\n            _drawWinner(round, roundId);\n        }\n\n        emit Rollover(msg.sender, withdrawalCalldata, roundId, entriesCount);\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function togglePaused() external {\n        _validateIsOwner();\n        paused() ? _unpause() : _pause();\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function toggleOutflowAllowed() external {\n        _validateIsOwner();\n        bool _outflowAllowed = outflowAllowed;\n        outflowAllowed = !_outflowAllowed;\n        emit OutflowAllowedUpdated(!_outflowAllowed);\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function updateCurrenciesStatus(address[] calldata currencies, bool isAllowed) external {\n        _validateIsOperator();\n\n        uint256 count = currencies.length;\n        for (uint256 i; i < count; ++i) {\n            isCurrencyAllowed[currencies[i]] = (isAllowed ? 1 : 0);\n        }\n        emit CurrenciesStatusUpdated(currencies, isAllowed);\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function updateRoundDuration(uint40 _roundDuration) external {\n        _validateIsOwner();\n        _updateRoundDuration(_roundDuration);\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function updateSignatureValidityPeriod(uint40 _signatureValidityPeriod) external {\n        _validateIsOwner();\n        _updateSignatureValidityPeriod(_signatureValidityPeriod);\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function updateValuePerEntry(uint96 _valuePerEntry) external {\n        _validateIsOwner();\n        _updateValuePerEntry(_valuePerEntry);\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function updateProtocolFeeRecipient(address _protocolFeeRecipient) external {\n        _validateIsOwner();\n        _updateProtocolFeeRecipient(_protocolFeeRecipient);\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function updateProtocolFeeBp(uint16 _protocolFeeBp) external {\n        _validateIsOwner();\n        _updateProtocolFeeBp(_protocolFeeBp);\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function updateProtocolFeeDiscountBp(uint16 _protocolFeeDiscountBp) external {\n        _validateIsOwner();\n        _updateProtocolFeeDiscountBp(_protocolFeeDiscountBp);\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function updateMaximumNumberOfParticipantsPerRound(uint40 _maximumNumberOfParticipantsPerRound) external {\n        _validateIsOwner();\n        _updateMaximumNumberOfParticipantsPerRound(_maximumNumberOfParticipantsPerRound);\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function updateReservoirOracle(address _reservoirOracle) external {\n        _validateIsOwner();\n        _updateReservoirOracle(_reservoirOracle);\n    }\n\n    /**\n     * @inheritdoc IYoloV2\n     */\n    function updateERC20Oracle(address _erc20Oracle) external {\n        _validateIsOwner();\n        _updateERC20Oracle(_erc20Oracle);\n    }\n\n    /**\n     * @param _roundDuration The duration of each round.\n     */\n    function _updateRoundDuration(uint40 _roundDuration) private {\n        if (_roundDuration > 1 hours) {\n            revert InvalidRoundDuration();\n        }\n\n        roundDuration = _roundDuration;\n        emit RoundDurationUpdated(_roundDuration);\n    }\n\n    /**\n     * @param _signatureValidityPeriod The validity period of a Reservoir signature.\n     */\n    function _updateSignatureValidityPeriod(uint40 _signatureValidityPeriod) private {\n        signatureValidityPeriod = _signatureValidityPeriod;\n        emit SignatureValidityPeriodUpdated(_signatureValidityPeriod);\n    }\n\n    /**\n     * @param _valuePerEntry The value of each entry in ETH.\n     */\n    function _updateValuePerEntry(uint96 _valuePerEntry) private {\n        if (_valuePerEntry == 0) {\n            revert InvalidValue();\n        }\n        valuePerEntry = _valuePerEntry;\n        emit ValuePerEntryUpdated(_valuePerEntry);\n    }\n\n    /**\n     * @param _protocolFeeRecipient The new protocol fee recipient address\n     */\n    function _updateProtocolFeeRecipient(address _protocolFeeRecipient) private {\n        if (_protocolFeeRecipient == address(0)) {\n            revert InvalidValue();\n        }\n        protocolFeeRecipient = _protocolFeeRecipient;"
    }
  ]
}