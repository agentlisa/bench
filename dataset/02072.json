{
  "Title": "H-6: Keepers can be forced to waste gas with long revert messages",
  "Content": "# Issue H-6: Keepers can be forced to waste gas with long revert messages \n\nSource: https://github.com/sherlock-audit/2023-02-gmx-judging/issues/141 \n\n## Found by \n0xAmanda, IllIllI, KingNFT\n\n## Summary\n\nMost actions done on behalf of users have a callback triggered on an address provided by the position's account holder. In order to ensure that these callbacks don't affect order execution, they're wrapped in a try-catch block, and the actual external call has a limited amount of gas provided to it. If the callback fails, the revert message is fetched and emitted, before processing continues. Keepers are given a limited gas budget based on estimated amounts of gas expected to be used, including a maximum amount allotted for callbacks via the [`callbackGasLimit()`](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/gas/GasUtils.sol#L175-L194).\n\n\n## Vulnerability Detail\n\nA malicious user can use the full `callbackGasLimit()` to create an extremely long revert string. This would use three times the expected amount of gas, since the callback will spend that amount, the fetching of the message during the revert will fetch that much, and the emitting of the same string will fetch that much.\n\n\n## Impact\n\nKeepers can be forced to spend more gas than they expect to for all operations. If they don't have a reliable way of calculating how much gas is used, they'll have spent more gas than they get in return. \n\nIf all keepers are expected to be able to calculate gas fees, then an attacker can submit an order whose happy path execution doesn't revert, but whose failure path reverts with a long string, which would essentially prevent the order from being executed until a more favorable price is reached. The user could, for example, submit an order with a long revert string in the frozen order callback, which would prevent the order from being frozen, and would allow them to [game the price impact](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/exchange/OrderHandler.sol#L256-L261)\n\n## Code Snippet\n\nA single revert message uses gas x3:\n```solidity\n// File: gmx-synthetics/contracts/callback/CallbackUtils.sol : CallbackUtils.afterOrderCancellation()   #1\n\n127        function afterOrderCancellation(bytes32 key, Order.Props memory order) internal {\n128            if (!isValidCallbackContract(order.callbackContract())) { return; }\n129    \n130 @>         try IOrderCallbackReceiver(order.callbackContract()).afterOrderCancellation{ gas: order.callbackGasLimit() }(key, order) {\n131            } catch (bytes memory reasonBytes) {\n132 @>             (string memory reason, /* bool hasRevertMessage */) = ErrorUtils.getRevertMessage(reasonBytes);\n133 @>             emit AfterOrderCancellationError(key, order, reason, reasonBytes);\n134            }\n135:       }\n```\nhttps://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/callback/CallbackUtils.sol#L127-L135\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nCount the gas three times during gas estimation\n\n\n\n\n## Discussion\n\n**xvi10**\n\nFix in https://github.com/gmx-io/gmx-synthetics/commit/b0bac262191f4f96edc9606192d2e4abfa043dc3\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/6",
  "Code": [
    {
      "filename": "gmx-synthetics/contracts/gas/GasUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../data/DataStore.sol\";\nimport \"../data/Keys.sol\";\nimport \"../utils/Precision.sol\";\n\nimport \"../deposit/Deposit.sol\";\nimport \"../withdrawal/Withdrawal.sol\";\nimport \"../order/Order.sol\";\nimport \"../order/BaseOrderUtils.sol\";\n\nimport \"../bank/StrictBank.sol\";\n\n// @title GasUtils\n// @dev Library for execution fee estimation and payments\nlibrary GasUtils {\n    using Deposit for Deposit.Props;\n    using Withdrawal for Withdrawal.Props;\n    using Order for Order.Props;\n\n    // @param keeper address of the keeper\n    // @param amount the amount of execution fee received\n    event KeeperExecutionFee(address keeper, uint256 amount);\n    // @param user address of the user\n    // @param amount the amount of execution fee refunded\n    event UserRefundFee(address user, uint256 amount);\n\n    error InsufficientExecutionFee(uint256 minExecutionFee, uint256 executionFee);\n    error EmptyHoldingAddress();\n\n    // @dev pay the keeper the execution fee and refund any excess amount to the user\n    //\n    // @param dataStore DataStore\n    // @param bank the StrictBank contract holding the execution fee\n    // @param executionFee the executionFee amount\n    // @param startingGas the starting gas\n    // @param keeper the keeper to pay\n    // @param user the user to refund\n    function payExecutionFee(\n        DataStore dataStore,\n        StrictBank bank,\n        uint256 executionFee,\n        uint256 startingGas,\n        address keeper,\n        address user\n    ) external {\n        uint256 gasUsed = startingGas - gasleft();\n        uint256 executionFeeForKeeper = adjustGasUsage(dataStore, gasUsed) * tx.gasprice;\n\n        if (executionFeeForKeeper > executionFee) {\n            executionFeeForKeeper = executionFee;\n        }\n\n        bank.transferOutNativeToken(\n            keeper,\n            executionFeeForKeeper\n        );\n\n        emit KeeperExecutionFee(keeper, executionFeeForKeeper);\n\n        uint256 refundFeeForUser = executionFee - executionFeeForKeeper;\n        if (refundFeeForUser == 0) {\n            return;\n        }\n\n        bank.transferOutNativeToken(\n            user,\n            refundFeeForUser\n        );\n\n        emit UserRefundFee(user, refundFeeForUser);\n    }\n\n    // @dev validate that the provided executionFee is sufficient based on the estimatedGasLimit\n    // @param dataStore DataStore\n    // @param estimatedGasLimit the estimated gas limit\n    // @param executionFee the execution fee provided\n    function validateExecutionFee(DataStore dataStore, uint256 estimatedGasLimit, uint256 executionFee) internal view {\n        uint256 gasLimit = adjustGasLimitForEstimate(dataStore, estimatedGasLimit);\n        uint256 minExecutionFee = gasLimit * tx.gasprice;\n        if (executionFee < minExecutionFee) {\n            revert InsufficientExecutionFee(minExecutionFee, executionFee);\n        }\n    }\n\n    function handleExcessExecutionFee(\n        DataStore dataStore,\n        StrictBank bank,\n        uint256 wntAmount,\n        uint256 executionFee\n    ) internal {\n        uint256 excessWntAmount = wntAmount - executionFee;\n        if (excessWntAmount > 0) {\n            address holdingAddress = dataStore.getAddress(Keys.HOLDING_ACCOUNT);\n            if (holdingAddress == address(0)) {\n                revert EmptyHoldingAddress();\n            }\n\n            address wnt = TokenUtils.wnt(dataStore);\n            bank.transferOut(\n                wnt,\n                holdingAddress,\n                excessWntAmount\n            );\n        }\n    }\n\n    // @dev adjust the gas usage to pay a small amount to keepers\n    // @param dataStore DataStore\n    // @param gasUsed the amount of gas used\n    function adjustGasUsage(DataStore dataStore, uint256 gasUsed) internal view returns (uint256) {\n        uint256 baseGasLimit = dataStore.getUint(Keys.EXECUTION_GAS_FEE_BASE_AMOUNT);\n        uint256 multiplierFactor = dataStore.getUint(Keys.EXECUTION_GAS_FEE_MULTIPLIER_FACTOR);\n        uint256 gasLimit = baseGasLimit + Precision.applyFactor(gasUsed, multiplierFactor);\n        return gasLimit;\n    }\n\n    // @dev adjust the estimated gas limit to help ensure the execution fee is sufficient during\n    // the actual execution\n    // @param dataStore DataStore\n    // @param estimatedGasLimit the estimated gas limit\n    function adjustGasLimitForEstimate(DataStore dataStore, uint256 estimatedGasLimit) internal view returns (uint256) {\n        uint256 baseGasLimit = dataStore.getUint(Keys.ESTIMATED_GAS_FEE_BASE_AMOUNT);\n        uint256 multiplierFactor = dataStore.getUint(Keys.ESTIMATED_GAS_FEE_MULTIPLIER_FACTOR);\n        uint256 gasLimit = baseGasLimit + Precision.applyFactor(estimatedGasLimit, multiplierFactor);\n        return gasLimit;\n    }\n\n    // @dev the estimated gas limit for deposits\n    // @param dataStore DataStore\n    // @param deposit the deposit to estimate the gas limit for\n    function estimateExecuteDepositGasLimit(DataStore dataStore, Deposit.Props memory deposit) internal view returns (uint256) {\n        uint256 gasPerSwap = dataStore.getUint(Keys.singleSwapGasLimitKey());\n        uint256 swapCount = deposit.longTokenSwapPath().length + deposit.shortTokenSwapPath().length;\n        uint256 gasForSwaps = swapCount * gasPerSwap;\n\n        if (deposit.initialLongTokenAmount() == 0 || deposit.initialShortTokenAmount() == 0) {\n            return dataStore.getUint(Keys.depositGasLimitKey(true)) + deposit.callbackGasLimit() + gasForSwaps;\n        }\n\n        return dataStore.getUint(Keys.depositGasLimitKey(false)) + deposit.callbackGasLimit() + gasForSwaps;\n    }\n\n    // @dev the estimated gas limit for withdrawals\n    // @param dataStore DataStore\n    // @param withdrawal the withdrawal to estimate the gas limit for\n    function estimateExecuteWithdrawalGasLimit(DataStore dataStore, Withdrawal.Props memory withdrawal) internal view returns (uint256) {\n        return dataStore.getUint(Keys.withdrawalGasLimitKey(false)) + withdrawal.callbackGasLimit();\n    }\n\n    // @dev the estimated gas limit for orders\n    // @param dataStore DataStore\n    // @param order the order to estimate the gas limit for\n    function estimateExecuteOrderGasLimit(DataStore dataStore, Order.Props memory order) internal view returns (uint256) {\n        if (BaseOrderUtils.isIncreaseOrder(order.orderType())) {\n            return estimateExecuteIncreaseOrderGasLimit(dataStore, order);\n        }\n\n        if (BaseOrderUtils.isDecreaseOrder(order.orderType())) {\n            return estimateExecuteDecreaseOrderGasLimit(dataStore, order);\n        }\n\n        if (BaseOrderUtils.isSwapOrder(order.orderType())) {\n            return estimateExecuteSwapOrderGasLimit(dataStore, order);\n        }\n\n        BaseOrderUtils.revertUnsupportedOrderType();\n    }\n\n    // @dev the estimated gas limit for increase orders\n    // @param dataStore DataStore\n    // @param order the order to estimate the gas limit for\n    function estimateExecuteIncreaseOrderGasLimit(DataStore dataStore, Order.Props memory order) internal view returns (uint256) {\n        uint256 gasPerSwap = dataStore.getUint(Keys.singleSwapGasLimitKey());\n        return dataStore.getUint(Keys.increaseOrderGasLimitKey()) + gasPerSwap * order.swapPath().length + order.callbackGasLimit();\n    }\n\n    // @dev the estimated gas limit for decrease orders\n    // @param dataStore DataStore\n    // @param order the order to estimate the gas limit for\n    function estimateExecuteDecreaseOrderGasLimit(DataStore dataStore, Order.Props memory order) internal view returns (uint256) {\n        uint256 gasPerSwap = dataStore.getUint(Keys.singleSwapGasLimitKey());\n        return dataStore.getUint(Keys.decreaseOrderGasLimitKey()) + gasPerSwap * order.swapPath().length + order.callbackGasLimit();\n    }\n\n    // @dev the estimated gas limit for swap orders\n    // @param dataStore DataStore\n    // @param order the order to estimate the gas limit for\n    function estimateExecuteSwapOrderGasLimit(DataStore dataStore, Order.Props memory order) internal view returns (uint256) {\n        uint256 gasPerSwap = dataStore.getUint(Keys.singleSwapGasLimitKey());\n        return dataStore.getUint(Keys.swapOrderGasLimitKey()) + gasPerSwap * order.swapPath().length + order.callbackGasLimit();\n    }\n}"
    },
    {
      "filename": "gmx-synthetics/contracts/exchange/OrderHandler.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"./BaseOrderHandler.sol\";\nimport \"../utils/ErrorUtils.sol\";\n\n// @title OrderHandler\n// @dev Contract to handle creation, execution and cancellation of orders\ncontract OrderHandler is BaseOrderHandler {\n    using SafeCast for uint256;\n    using Order for Order.Props;\n    using Array for uint256[];\n\n    error OrderNotUpdatable(Order.OrderType orderType);\n    error InvalidKeeperForFrozenOrder(address keeper);\n\n    constructor(\n        RoleStore _roleStore,\n        DataStore _dataStore,\n        EventEmitter _eventEmitter,\n        OrderVault _orderVault,\n        Oracle _oracle,\n        SwapHandler _swapHandler,\n        IReferralStorage _referralStorage\n    ) BaseOrderHandler(\n        _roleStore,\n        _dataStore,\n        _eventEmitter,\n        _orderVault,\n        _oracle,\n        _swapHandler,\n        _referralStorage\n    ) {}\n\n    // @dev creates an order in the order store\n    // @param account the order's account\n    // @param params BaseOrderUtils.CreateOrderParams\n    function createOrder(\n        address account,\n        BaseOrderUtils.CreateOrderParams calldata params\n    ) external globalNonReentrant onlyController returns (bytes32) {\n        FeatureUtils.validateFeature(dataStore, Keys.createOrderFeatureDisabledKey(address(this), uint256(params.orderType)));\n\n        return OrderUtils.createOrder(\n            dataStore,\n            eventEmitter,\n            orderVault,\n            referralStorage,\n            account,\n            params\n        );\n    }\n\n    /**\n     * @dev Updates the given order with the specified size delta, acceptable price, and trigger price.\n     * The `updateOrder()` feature must be enabled for the given order type. The caller must be the owner\n     * of the order, and the order must not be a market order. The size delta, trigger price, and\n     * acceptable price are updated on the order, and the order is unfrozen. Any additional WNT that is\n     * transferred to the contract is added to the order's execution fee. The updated order is then saved\n     * in the order store, and an `OrderUpdated` event is emitted.\n     *\n     * @param key The unique ID of the order to be updated\n     * @param sizeDeltaUsd The new size delta for the order\n     * @param acceptablePrice The new acceptable price for the order\n     * @param triggerPrice The new trigger price for the order\n     */\n    function updateOrder(\n        bytes32 key,\n        uint256 sizeDeltaUsd,\n        uint256 acceptablePrice,\n        uint256 triggerPrice,\n        uint256 minOutputAmount,\n        Order.Props memory order\n    ) external payable globalNonReentrant onlyController {\n        FeatureUtils.validateFeature(dataStore, Keys.updateOrderFeatureDisabledKey(address(this), uint256(order.orderType())));\n\n        if (BaseOrderUtils.isMarketOrder(order.orderType())) {\n            revert OrderNotUpdatable(order.orderType());\n        }\n\n        order.setSizeDeltaUsd(sizeDeltaUsd);\n        order.setTriggerPrice(triggerPrice);\n        order.setAcceptablePrice(acceptablePrice);\n        order.setMinOutputAmount(minOutputAmount);\n        order.setIsFrozen(false);\n\n        // allow topping up of executionFee as partially filled or frozen orders\n        // will have their executionFee reduced\n        address wnt = TokenUtils.wnt(dataStore);\n        uint256 receivedWnt = orderVault.recordTransferIn(wnt);\n        order.setExecutionFee(order.executionFee() + receivedWnt);\n\n        uint256 estimatedGasLimit = GasUtils.estimateExecuteOrderGasLimit(dataStore, order);\n        GasUtils.validateExecutionFee(dataStore, estimatedGasLimit, order.executionFee());\n\n        order.touch();\n        OrderStoreUtils.set(dataStore, key, order);\n\n        OrderEventUtils.emitOrderUpdated(eventEmitter, key, sizeDeltaUsd, triggerPrice, acceptablePrice);\n    }\n\n    /**\n     * @dev Cancels the given order. The `cancelOrder()` feature must be enabled for the given order\n     * type. The caller must be the owner of the order, and the order must not be a market order. The\n     * order is cancelled by calling the `cancelOrder()` function in the `OrderUtils` contract. This\n     * function also records the starting gas amount and the reason for cancellation, which is passed to\n     * the `cancelOrder()` function.\n     *\n     * @param key The unique ID of the order to be cancelled\n     */\n    function cancelOrder(bytes32 key) external globalNonReentrant onlyController {\n        uint256 startingGas = gasleft();\n\n        DataStore _dataStore = dataStore;\n        Order.Props memory order = OrderStoreUtils.get(_dataStore, key);\n\n        FeatureUtils.validateFeature(_dataStore, Keys.cancelOrderFeatureDisabledKey(address(this), uint256(order.orderType())));\n\n        if (BaseOrderUtils.isMarketOrder(order.orderType())) {\n            ExchangeUtils.validateRequestCancellation(\n                _dataStore,\n                order.updatedAtBlock(),\n                \"Order\"\n            );\n        }\n\n        OrderUtils.cancelOrder(\n            dataStore,\n            eventEmitter,\n            orderVault,\n            key,\n            order.account(),\n            startingGas,\n            Keys.USER_INITIATED_CANCEL,\n            \"\"\n        );\n    }\n\n    // @dev simulate execution of an order to check for any errors\n    // @param key the order key\n    // @param params OracleUtils.SimulatePricesParams\n    function simulateExecuteOrder(\n        bytes32 key,\n        OracleUtils.SimulatePricesParams memory params\n    ) external\n        onlyController\n        withSimulatedOraclePrices(oracle, params)\n        globalNonReentrant\n    {\n        uint256 startingGas = gasleft();\n\n        OracleUtils.SetPricesParams memory oracleParams;\n\n        this._executeOrder(\n            key,\n            oracleParams,\n            msg.sender,\n            startingGas\n        );\n    }\n\n    // @dev executes an order\n    // @param key the key of the order to execute\n    // @param oracleParams OracleUtils.SetPricesParams\n    function executeOrder(\n        bytes32 key,\n        OracleUtils.SetPricesParams calldata oracleParams\n    ) external\n        globalNonReentrant\n        onlyOrderKeeper\n        withOraclePrices(oracle, dataStore, eventEmitter, oracleParams)\n    {\n        uint256 startingGas = gasleft();\n\n        try this._executeOrder(\n            key,\n            oracleParams,\n            msg.sender,\n            startingGas\n        ) {\n        } catch (bytes memory reasonBytes) {\n            _handleOrderError(key, startingGas, reasonBytes);\n        }\n    }\n\n    // @dev executes an order\n    // @param key the key of the order to execute\n    // @param oracleParams OracleUtils.SetPricesParams\n    // @param keeper the keeper executing the order\n    // @param startingGas the starting gas\n    function _executeOrder(\n        bytes32 key,\n        OracleUtils.SetPricesParams memory oracleParams,\n        address keeper,\n        uint256 startingGas\n    ) external onlySelf {\n        BaseOrderUtils.ExecuteOrderParams memory params = _getExecuteOrderParams(key, oracleParams, keeper, startingGas);\n        // limit swaps require frozen order keeper for execution since on creation it can fail due to output amount\n        // which would automatically cause the order to be frozen\n        // limit increase and limit / trigger decrease orders may fail due to output amount as well and become frozen\n        // but only if their acceptablePrice is reached\n        if (params.order.isFrozen() || params.order.orderType() == Order.OrderType.LimitSwap) {\n            _validateFrozenOrderKeeper(keeper);\n        }\n\n        FeatureUtils.validateFeature(params.contracts.dataStore, Keys.executeOrderFeatureDisabledKey(address(this), uint256(params.order.orderType())));\n\n        OrderUtils.executeOrder(params);\n    }\n\n    // @dev handle a caught order error\n    // @param key the order's key\n    // @param startingGas the starting gas\n    // @param reason the error reason\n    // @param reasonKey the hash or the error reason\n    function _handleOrderError(\n        bytes32 key,\n        uint256 startingGas,\n        bytes memory reasonBytes\n    ) internal {\n        (string memory reason, /* bool hasRevertMessage */) = ErrorUtils.getRevertMessage(reasonBytes);\n\n        bytes4 errorSelector = ErrorUtils.getErrorSelectorFromData(reasonBytes);\n\n        if (\n            OracleUtils.isEmptyPriceError(errorSelector) ||\n            errorSelector == InvalidKeeperForFrozenOrder.selector\n        ) {\n            ErrorUtils.revertWithCustomError(reasonBytes);\n        }\n\n        Order.Props memory order = OrderStoreUtils.get(dataStore, key);\n        bool isMarketOrder = BaseOrderUtils.isMarketOrder(order.orderType());\n\n        if (isMarketOrder) {\n            OrderUtils.cancelOrder(\n                dataStore,\n                eventEmitter,\n                orderVault,\n                key,\n                msg.sender,\n                startingGas,\n                reason,\n                reasonBytes\n            );\n        } else {\n            if (\n                errorSelector == FeatureUtils.DisabledFeature.selector ||\n                errorSelector == PositionUtils.EmptyPosition.selector ||\n                errorSelector == BaseOrderUtils.InvalidOrderPrices.selector\n            ) {\n                ErrorUtils.revertWithCustomError(reasonBytes);\n            }\n\n            // freeze unfulfillable orders to prevent the order system from being gamed\n            // an example of gaming would be if a user creates a limit order\n            // with size greater than the available amount in the pool\n            // the user waits for their limit price to be hit, and if price\n            // moves in their favour after, they can deposit into the pool\n            // to allow the order to be executed then close the order for a profit\n            //\n            // frozen order keepers will have additional validations before executing\n            // frozen orders to prevent gaming\n            //\n            // alternatively, the user can call updateOrder to unfreeze the order\n            OrderUtils.freezeOrder(\n                dataStore,\n                eventEmitter,\n                orderVault,\n                key,\n                msg.sender,\n                startingGas,\n                reason,\n                reasonBytes\n            );\n        }\n    }\n\n    // @dev validate that the keeper is a frozen order keeper\n    // @param keeper address of the keeper\n    function _validateFrozenOrderKeeper(address keeper) internal view {\n        if (!roleStore.hasRole(keeper, Role.FROZEN_ORDER_KEEPER)) {\n            revert InvalidKeeperForFrozenOrder(keeper);\n        }\n    }\n}"
    },
    {
      "filename": "gmx-synthetics/contracts/callback/CallbackUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"../data/DataStore.sol\";\nimport \"../data/Keys.sol\";\nimport \"../utils/ErrorUtils.sol\";\n\nimport \"./IOrderCallbackReceiver.sol\";\nimport \"./IDepositCallbackReceiver.sol\";\nimport \"./IWithdrawalCallbackReceiver.sol\";\n\n// @title CallbackUtils\n// @dev most features require a two step process to complete\n// the user first sends a request transaction, then a second transaction is sent\n// by a keeper to execute the request\n//\n// to allow for better composability with other contracts, a callback contract\n// can be specified to be called after request executions or cancellations\n//\n// in case it is necessary to add \"before\" callbacks, extra care should be taken\n// to ensure that important state cannot be changed during the before callback\n// for example, if an order can be cancelled in the \"before\" callback during\n// order execution, it may lead to an order being executed even though the user\n// was already refunded for its cancellation\nlibrary CallbackUtils {\n    using Address for address;\n    using Deposit for Deposit.Props;\n    using Withdrawal for Withdrawal.Props;\n    using Order for Order.Props;\n\n    event AfterDepositExecutionError(bytes32 key, Deposit.Props deposit, string reason, bytes reasonBytes);\n    event AfterDepositCancellationError(bytes32 key, Deposit.Props deposit, string reason, bytes reasonBytes);\n\n    event AfterWithdrawalExecutionError(bytes32 key, Withdrawal.Props withdrawal, string reason, bytes reasonBytes);\n    event AfterWithdrawalCancellationError(bytes32 key, Withdrawal.Props withdrawal, string reason, bytes reasonBytes);\n\n    event AfterOrderExecutionError(bytes32 key, Order.Props order, string reason, bytes reasonBytes);\n    event AfterOrderCancellationError(bytes32 key, Order.Props order, string reason, bytes reasonBytes);\n    event AfterOrderFrozenError(bytes32 key, Order.Props order, string reason, bytes reasonBytes);\n\n    error MaxCallbackGasLimitExceeded(uint256 callbackGasLimit, uint256 maxCallbackGasLimit);\n\n    // @dev validate that the callbackGasLimit is less than the max specified value\n    // this is to prevent callback gas limits which are larger than the max gas limits per block\n    // as this would allow for callback contracts that can consume all gas and conditionally cause\n    // executions to fail\n    // @param dataStore DataStore\n    // @param callbackGasLimit the callback gas limit\n    function validateCallbackGasLimit(DataStore dataStore, uint256 callbackGasLimit) internal view {\n        uint256 maxCallbackGasLimit = dataStore.getUint(Keys.MAX_CALLBACK_GAS_LIMIT);\n        if (callbackGasLimit > maxCallbackGasLimit) {\n            revert MaxCallbackGasLimitExceeded(callbackGasLimit, maxCallbackGasLimit);\n        }\n    }\n\n    // @dev called after a deposit execution\n    // @param key the key of the deposit\n    // @param deposit the deposit that was executed\n    function afterDepositExecution(bytes32 key, Deposit.Props memory deposit) internal {\n        if (!isValidCallbackContract(deposit.callbackContract())) { return; }\n\n        try IDepositCallbackReceiver(deposit.callbackContract()).afterDepositExecution{ gas: deposit.callbackGasLimit() }(key, deposit) {\n        } catch (bytes memory reasonBytes) {\n            (string memory reason, /* bool hasRevertMessage */) = ErrorUtils.getRevertMessage(reasonBytes);\n            emit AfterDepositExecutionError(key, deposit, reason, reasonBytes);\n        }\n    }\n\n    // @dev called after a deposit cancellation\n    // @param key the key of the deposit\n    // @param deposit the deposit that was cancelled\n    function afterDepositCancellation(bytes32 key, Deposit.Props memory deposit) internal {\n        if (!isValidCallbackContract(deposit.callbackContract())) { return; }\n\n        try IDepositCallbackReceiver(deposit.callbackContract()).afterDepositCancellation{ gas: deposit.callbackGasLimit() }(key, deposit) {\n        } catch (bytes memory reasonBytes) {\n            (string memory reason, /* bool hasRevertMessage */) = ErrorUtils.getRevertMessage(reasonBytes);\n            emit AfterDepositCancellationError(key, deposit, reason, reasonBytes);\n        }\n    }\n\n    // @dev called after a withdrawal execution\n    // @param key the key of the withdrawal\n    // @param withdrawal the withdrawal that was executed\n    function afterWithdrawalExecution(bytes32 key, Withdrawal.Props memory withdrawal) internal {\n        if (!isValidCallbackContract(withdrawal.callbackContract())) { return; }\n\n        try IWithdrawalCallbackReceiver(withdrawal.callbackContract()).afterWithdrawalExecution{ gas: withdrawal.callbackGasLimit() }(key, withdrawal) {\n        } catch (bytes memory reasonBytes) {\n            (string memory reason, /* bool hasRevertMessage */) = ErrorUtils.getRevertMessage(reasonBytes);\n            emit AfterWithdrawalExecutionError(key, withdrawal, reason, reasonBytes);\n        }\n    }\n\n    // @dev called after a withdrawal cancellation\n    // @param key the key of the withdrawal\n    // @param withdrawal the withdrawal that was cancelled\n    function afterWithdrawalCancellation(bytes32 key, Withdrawal.Props memory withdrawal) internal {\n        if (!isValidCallbackContract(withdrawal.callbackContract())) { return; }\n\n        try IWithdrawalCallbackReceiver(withdrawal.callbackContract()).afterWithdrawalCancellation{ gas: withdrawal.callbackGasLimit() }(key, withdrawal) {\n        } catch (bytes memory reasonBytes) {\n            (string memory reason, /* bool hasRevertMessage */) = ErrorUtils.getRevertMessage(reasonBytes);\n            emit AfterWithdrawalCancellationError(key, withdrawal, reason, reasonBytes);\n        }\n    }\n\n    // @dev called after an order execution\n    // @param key the key of the order\n    // @param order the order that was executed\n    function afterOrderExecution(bytes32 key, Order.Props memory order) internal {\n        if (!isValidCallbackContract(order.callbackContract())) { return; }\n\n        try IOrderCallbackReceiver(order.callbackContract()).afterOrderExecution{ gas: order.callbackGasLimit() }(key, order) {\n        } catch (bytes memory reasonBytes) {\n            (string memory reason, /* bool hasRevertMessage */) = ErrorUtils.getRevertMessage(reasonBytes);\n            emit AfterOrderExecutionError(key, order, reason, reasonBytes);\n        }\n    }\n\n    // @dev called after an order cancellation\n    // @param key the key of the order\n    // @param order the order that was cancelled\n    function afterOrderCancellation(bytes32 key, Order.Props memory order) internal {\n        if (!isValidCallbackContract(order.callbackContract())) { return; }\n\n        try IOrderCallbackReceiver(order.callbackContract()).afterOrderCancellation{ gas: order.callbackGasLimit() }(key, order) {\n        } catch (bytes memory reasonBytes) {\n            (string memory reason, /* bool hasRevertMessage */) = ErrorUtils.getRevertMessage(reasonBytes);\n            emit AfterOrderCancellationError(key, order, reason, reasonBytes);\n        }\n    }\n\n    // @dev called after an order has been frozen, see OrderUtils.freezeOrder in OrderHandler for more info\n    // @param key the key of the order\n    // @param order the order that was frozen\n    function afterOrderFrozen(bytes32 key, Order.Props memory order) internal {\n        if (!isValidCallbackContract(order.callbackContract())) { return; }\n\n        try IOrderCallbackReceiver(order.callbackContract()).afterOrderFrozen{ gas: order.callbackGasLimit() }(key, order) {\n        } catch (bytes memory reasonBytes) {\n            (string memory reason, /* bool hasRevertMessage */) = ErrorUtils.getRevertMessage(reasonBytes);\n            emit AfterOrderFrozenError(key, order, reason, reasonBytes);\n        }\n    }\n\n    // @dev validates that the given address is a contract\n    // @param callbackContract the contract to call\n    function isValidCallbackContract(address callbackContract) internal view returns (bool) {\n        if (callbackContract == address(0)) { return false; }\n        if (!callbackContract.isContract()) { return false; }\n\n        return true;\n    }\n}"
    }
  ]
}