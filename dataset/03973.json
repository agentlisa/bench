{
  "Title": "[L16] Not using the SafeMath library",
  "Content": "Several arithmetic operations in the codebase are not using the [`SafeMath` library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.2.0/contracts/math/SafeMath.sol) that would prevent arithmetic overflow and underflow issues. \n\n\nAs an example, we detailed some of the occurrences below:\n\n\n* In the `AddressLinkedList` contract: [L80](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/linkedlists/AddressLinkedList.sol#L80)\n* In the `AddressSortedLinkedList` contract: [L95](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/linkedlists/AddressSortedLinkedList.sol#L95), [L115](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/linkedlists/AddressSortedLinkedList.sol#L115), [L136](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/linkedlists/AddressSortedLinkedList.sol#L136)\n* In the `AddressSortedLinkedListWithMedian` contract: [L153](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/linkedlists/AddressSortedLinkedListWithMedian.sol#L153)\n* In the `Attestations` contract: [L232](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Attestations.sol#L232), [L264](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Attestations.sol#L264), [L358](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Attestations.sol#L358), [L360](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Attestations.sol#L360), [L368](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Attestations.sol#L368), [L543](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Attestations.sol#L543)\n* In the `DoubleSigningSlasher` contract: [L38](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/DoubleSigningSlasher.sol#L38), [L39](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/DoubleSigningSlasher.sol#L39)\n* In the `DowntimeSlasher` contract: [L82](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/DowntimeSlasher.sol#L82)\n* In the `Election` contract: [L902](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Election.sol#L902)\n* In the `Exchange` contract: [L161](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/stability/Exchange.sol#L161), [L182](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/stability/Exchange.sol#L182), [L289](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/stability/Exchange.sol#L289)\n* In the `Governance` contract: [L917](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/Governance.sol#L917)\n* In the `IntegerSortedList` contract: [L72](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/linkedlists/IntegerSortedLinkedList.sol#L72), [L108](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/linkedlists/IntegerSortedLinkedList.sol#L108)\n* In the `LinkedList` contract: [L146](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/linkedlists/LinkedList.sol#L146)\n* In the `LockedGold` contract: [L238](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/governance/LockedGold.sol#L238)\n* In the `MultiSig` contract: [L113](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/MultiSig.sol#L113), [L142](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/MultiSig.sol#L142), [L147](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/MultiSig.sol#L147), [L162](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/MultiSig.sol#L162), [L279](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/MultiSig.sol#L279), [L280](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/MultiSig.sol#L280), [L305](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/MultiSig.sol#L305), [L316](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/MultiSig.sol#L316), [L317](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/MultiSig.sol#L317), [L325](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/MultiSig.sol#L325), [L327](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/MultiSig.sol#L327), [L347](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/MultiSig.sol#L347), [L350](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/MultiSig.sol#L350), [L353](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/MultiSig.sol#L353), [L373](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/MultiSig.sol#L373), [L376](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/MultiSig.sol#L376)\n* In the `Random` contract: [L101](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Random.sol#L101), [L102](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Random.sol#L102), [L103](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Random.sol#L103), [L106](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Random.sol#L106), [L109](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/identity/Random.sol#L109)\n* In the `Reserve` contract: [L116](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/stability/Reserve.sol#L116), [L162](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/stability/Reserve.sol#L162), [L202](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/stability/Reserve.sol#L202), [L275](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/stability/Reserve.sol#L275), [L294](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/stability/Reserve.sol#L294)\n* In the `SortedLinkedList` contract: [L94](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/linkedlists/SortedLinkedList.sol#L94)\n* In the `SortedLinkedListWithMedian` contract: [L144](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/linkedlists/SortedLinkedListWithMedian.sol#L144)\n* In the `SortedOracles` contract: [L112](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/stability/SortedOracles.sol#L112)\n* In the `UsingRegistry` contract: [L65](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/common/UsingRegistry.sol#L65)\n\n\nWhile this issue does not pose a security risk, and it is very unlikely that these operations could cause undesired outcomes as no exploitable overflows or underflows were detected in the current implementation, this may not hold true in future changes to the codebase.\n\n\nConsider using the `SafeMath` library in these and all other places where an arithmetic operation is involved.\n\n\n***Update:** Fixed in [pull request #2893](https://github.com/celo-org/celo-monorepo/pull/2893). The cLabs team is now using the `SafeMath` library extensively.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/contracts/common/linkedlists/AddressLinkedList.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\nimport \"./LinkedList.sol\";\n\n/**\n * @title Maintains a doubly linked list keyed by address.\n * @dev Following the `next` pointers will lead you to the head, rather than the tail.\n */\nlibrary AddressLinkedList {\n  using LinkedList for LinkedList.List;\n\n  function toBytes(address a) public pure returns (bytes32) {\n    return bytes32(uint256(a) << 96);\n  }\n\n  function toAddress(bytes32 b) public pure returns (address) {\n    return address(uint256(b) >> 96);\n  }\n\n  /**\n   * @notice Inserts an element into a doubly linked list.\n   * @param key The key of the element to insert.\n   * @param previousKey The key of the element that comes before the element to insert.\n   * @param nextKey The key of the element that comes after the element to insert.\n   */\n  function insert(LinkedList.List storage list, address key, address previousKey, address nextKey)\n    public\n  {\n    list.insert(toBytes(key), toBytes(previousKey), toBytes(nextKey));\n  }\n\n  /**\n   * @notice Inserts an element at the end of the doubly linked list.\n   * @param key The key of the element to insert.\n   */\n  function push(LinkedList.List storage list, address key) public {\n    list.insert(toBytes(key), bytes32(0), list.tail);\n  }\n\n  /**\n   * @notice Removes an element from the doubly linked list.\n   * @param key The key of the element to remove.\n   */\n  function remove(LinkedList.List storage list, address key) public {\n    list.remove(toBytes(key));\n  }\n\n  /**\n   * @notice Updates an element in the list.\n   * @param key The element key.\n   * @param previousKey The key of the element that comes before the updated element.\n   * @param nextKey The key of the element that comes after the updated element.\n   */\n  function update(LinkedList.List storage list, address key, address previousKey, address nextKey)\n    public\n  {\n    list.update(toBytes(key), toBytes(previousKey), toBytes(nextKey));\n  }\n\n  /**\n   * @notice Returns whether or not a particular key is present in the sorted list.\n   * @param key The element key.\n   * @return Whether or not the key is in the sorted list.\n   */\n  function contains(LinkedList.List storage list, address key) public view returns (bool) {\n    return list.elements[toBytes(key)].exists;\n  }\n\n  /**\n   * @notice Returns the N greatest elements of the list.\n   * @param n The number of elements to return.\n   * @return The keys of the greatest elements.\n   * @dev Reverts if n is greater than the number of elements in the list.\n   */\n  function headN(LinkedList.List storage list, uint256 n) public view returns (address[] memory) {\n    bytes32[] memory byteKeys = list.headN(n);\n    address[] memory keys = new address[](n);\n    for (uint256 i = 0; i < n; i++) {\n      keys[i] = toAddress(byteKeys[i]);\n    }\n    return keys;\n  }\n\n  /**\n   * @notice Gets all element keys from the doubly linked list.\n   * @return All element keys from head to tail.\n   */\n  function getKeys(LinkedList.List storage list) public view returns (address[] memory) {\n    return headN(list, list.numElements);\n  }\n}"
    },
    {
      "filename": "packages/protocol/contracts/common/linkedlists/AddressSortedLinkedList.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/math/Math.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"./AddressLinkedList.sol\";\nimport \"./SortedLinkedList.sol\";\n\n/**\n * @title Maintains a sorted list of unsigned ints keyed by address.\n */\nlibrary AddressSortedLinkedList {\n  using SortedLinkedList for SortedLinkedList.List;\n\n  function toBytes(address a) public pure returns (bytes32) {\n    return bytes32(uint256(a) << 96);\n  }\n\n  function toAddress(bytes32 b) public pure returns (address) {\n    return address(uint256(b) >> 96);\n  }\n\n  /**\n   * @notice Inserts an element into a doubly linked list.\n   * @param key The key of the element to insert.\n   * @param value The element value.\n   * @param lesserKey The key of the element less than the element to insert.\n   * @param greaterKey The key of the element greater than the element to insert.\n   */\n  function insert(\n    SortedLinkedList.List storage list,\n    address key,\n    uint256 value,\n    address lesserKey,\n    address greaterKey\n  ) public {\n    list.insert(toBytes(key), value, toBytes(lesserKey), toBytes(greaterKey));\n  }\n\n  /**\n   * @notice Removes an element from the doubly linked list.\n   * @param key The key of the element to remove.\n   */\n  function remove(SortedLinkedList.List storage list, address key) public {\n    list.remove(toBytes(key));\n  }\n\n  /**\n   * @notice Updates an element in the list.\n   * @param key The element key.\n   * @param value The element value.\n   * @param lesserKey The key of the element will be just left of `key` after the update.\n   * @param greaterKey The key of the element will be just right of `key` after the update.\n   * @dev Note that only one of \"lesserKey\" or \"greaterKey\" needs to be correct to reduce friction.\n   */\n  function update(\n    SortedLinkedList.List storage list,\n    address key,\n    uint256 value,\n    address lesserKey,\n    address greaterKey\n  ) public {\n    list.update(toBytes(key), value, toBytes(lesserKey), toBytes(greaterKey));\n  }\n\n  /**\n   * @notice Returns whether or not a particular key is present in the sorted list.\n   * @param key The element key.\n   * @return Whether or not the key is in the sorted list.\n   */\n  function contains(SortedLinkedList.List storage list, address key) public view returns (bool) {\n    return list.contains(toBytes(key));\n  }\n\n  /**\n   * @notice Returns the value for a particular key in the sorted list.\n   * @param key The element key.\n   * @return The element value.\n   */\n  function getValue(SortedLinkedList.List storage list, address key) public view returns (uint256) {\n    return list.getValue(toBytes(key));\n  }\n\n  /**\n   * @notice Gets all elements from the doubly linked list.\n   * @return An unpacked list of elements from largest to smallest.\n   */\n  function getElements(SortedLinkedList.List storage list)\n    public\n    view\n    returns (address[] memory, uint256[] memory)\n  {\n    bytes32[] memory byteKeys = list.getKeys();\n    address[] memory keys = new address[](byteKeys.length);\n    uint256[] memory values = new uint256[](byteKeys.length);\n    for (uint256 i = 0; i < byteKeys.length; i++) {\n      keys[i] = toAddress(byteKeys[i]);\n      values[i] = list.values[byteKeys[i]];\n    }\n    return (keys, values);\n  }\n\n  /**\n   * @notice Returns the minimum of `max` and the  number of elements in the list > threshold.\n   * @param threshold The number that the element must exceed to be included.\n   * @param max The maximum number returned by this function.\n   * @return The minimum of `max` and the  number of elements in the list > threshold.\n   */\n  function numElementsGreaterThan(\n    SortedLinkedList.List storage list,\n    uint256 threshold,\n    uint256 max\n  ) public view returns (uint256) {\n    uint256 revisedMax = Math.min(max, list.list.numElements);\n    bytes32 key = list.list.head;\n    for (uint256 i = 0; i < revisedMax; i++) {\n      if (list.getValue(key) < threshold) {\n        return i;\n      }\n      key = list.list.elements[key].previousKey;\n    }\n    return revisedMax;\n  }\n\n  /**\n   * @notice Returns the N greatest elements of the list.\n   * @param n The number of elements to return.\n   * @return The keys of the greatest elements.\n   */\n  function headN(SortedLinkedList.List storage list, uint256 n)\n    public\n    view\n    returns (address[] memory)\n  {\n    bytes32[] memory byteKeys = list.headN(n);\n    address[] memory keys = new address[](n);\n    for (uint256 i = 0; i < n; i++) {\n      keys[i] = toAddress(byteKeys[i]);\n    }\n    return keys;\n  }\n\n  /**\n   * @notice Gets all element keys from the doubly linked list.\n   * @return All element keys from head to tail.\n   */\n  function getKeys(SortedLinkedList.List storage list) public view returns (address[] memory) {\n    return headN(list, list.list.numElements);\n  }\n}"
    },
    {
      "filename": "packages/protocol/contracts/common/linkedlists/AddressSortedLinkedListWithMedian.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"./AddressLinkedList.sol\";\nimport \"./SortedLinkedListWithMedian.sol\";\n\n/**\n * @title Maintains a sorted list of unsigned ints keyed by address.\n */\nlibrary AddressSortedLinkedListWithMedian {\n  using SortedLinkedListWithMedian for SortedLinkedListWithMedian.List;\n\n  function toBytes(address a) public pure returns (bytes32) {\n    return bytes32(uint256(a) << 96);\n  }\n\n  function toAddress(bytes32 b) public pure returns (address) {\n    return address(uint256(b) >> 96);\n  }\n\n  /**\n   * @notice Inserts an element into a doubly linked list.\n   * @param key The key of the element to insert.\n   * @param value The element value.\n   * @param lesserKey The key of the element less than the element to insert.\n   * @param greaterKey The key of the element greater than the element to insert.\n   */\n  function insert(\n    SortedLinkedListWithMedian.List storage list,\n    address key,\n    uint256 value,\n    address lesserKey,\n    address greaterKey\n  ) public {\n    list.insert(toBytes(key), value, toBytes(lesserKey), toBytes(greaterKey));\n  }\n\n  /**\n   * @notice Removes an element from the doubly linked list.\n   * @param key The key of the element to remove.\n   */\n  function remove(SortedLinkedListWithMedian.List storage list, address key) public {\n    list.remove(toBytes(key));\n  }\n\n  /**\n   * @notice Updates an element in the list.\n   * @param key The element key.\n   * @param value The element value.\n   * @param lesserKey The key of the element will be just left of `key` after the update.\n   * @param greaterKey The key of the element will be just right of `key` after the update.\n   * @dev Note that only one of \"lesserKey\" or \"greaterKey\" needs to be correct to reduce friction.\n   */\n  function update(\n    SortedLinkedListWithMedian.List storage list,\n    address key,\n    uint256 value,\n    address lesserKey,\n    address greaterKey\n  ) public {\n    list.update(toBytes(key), value, toBytes(lesserKey), toBytes(greaterKey));\n  }\n\n  /**\n   * @notice Returns whether or not a particular key is present in the sorted list.\n   * @param key The element key.\n   * @return Whether or not the key is in the sorted list.\n   */\n  function contains(SortedLinkedListWithMedian.List storage list, address key)\n    public\n    view\n    returns (bool)\n  {\n    return list.contains(toBytes(key));\n  }\n\n  /**\n   * @notice Returns the value for a particular key in the sorted list.\n   * @param key The element key.\n   * @return The element value.\n   */\n  function getValue(SortedLinkedListWithMedian.List storage list, address key)\n    public\n    view\n    returns (uint256)\n  {\n    return list.getValue(toBytes(key));\n  }\n\n  /**\n   * @notice Returns the median value of the sorted list.\n   * @return The median value.\n   */\n  function getMedianValue(SortedLinkedListWithMedian.List storage list)\n    public\n    view\n    returns (uint256)\n  {\n    return list.getValue(list.median);\n  }\n\n  /**\n   * @notice Returns the key of the first element in the list.\n   * @return The key of the first element in the list.\n   */\n  function getHead(SortedLinkedListWithMedian.List storage list) external view returns (address) {\n    return toAddress(list.getHead());\n  }\n\n  /**\n   * @notice Returns the key of the median element in the list.\n   * @return The key of the median element in the list.\n   */\n  function getMedian(SortedLinkedListWithMedian.List storage list) external view returns (address) {\n    return toAddress(list.getMedian());\n  }\n\n  /**\n   * @notice Returns the key of the last element in the list.\n   * @return The key of the last element in the list.\n   */\n  function getTail(SortedLinkedListWithMedian.List storage list) external view returns (address) {\n    return toAddress(list.getTail());\n  }\n\n  /**\n   * @notice Returns the number of elements in the list.\n   * @return The number of elements in the list.\n   */\n  function getNumElements(SortedLinkedListWithMedian.List storage list)\n    external\n    view\n    returns (uint256)\n  {\n    return list.getNumElements();\n  }\n\n  /**\n   * @notice Gets all elements from the doubly linked list.\n   * @return An unpacked list of elements from largest to smallest.\n   */\n  function getElements(SortedLinkedListWithMedian.List storage list)\n    public\n    view\n    returns (address[] memory, uint256[] memory, SortedLinkedListWithMedian.MedianRelation[] memory)\n  {\n    bytes32[] memory byteKeys = list.getKeys();\n    address[] memory keys = new address[](byteKeys.length);\n    uint256[] memory values = new uint256[](byteKeys.length);\n    // prettier-ignore\n    SortedLinkedListWithMedian.MedianRelation[] memory relations =\n      new SortedLinkedListWithMedian.MedianRelation[](keys.length);\n    for (uint256 i = 0; i < byteKeys.length; i++) {\n      keys[i] = toAddress(byteKeys[i]);\n      values[i] = list.getValue(byteKeys[i]);\n      relations[i] = list.relation[byteKeys[i]];\n    }\n    return (keys, values, relations);\n  }\n}"
    },
    {
      "filename": "packages/protocol/contracts/identity/Attestations.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\nimport \"./interfaces/IAttestations.sol\";\nimport \"./interfaces/IRandom.sol\";\nimport \"../common/interfaces/IERC20Token.sol\";\nimport \"../common/interfaces/IAccounts.sol\";\nimport \"../governance/interfaces/IValidators.sol\";\n\nimport \"../common/Initializable.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/Signatures.sol\";\nimport \"../common/SafeCast.sol\";\nimport \"../common/UsingPrecompiles.sol\";\n\n/**\n * @title Contract mapping identifiers to accounts\n */\ncontract Attestations is\n  IAttestations,\n  Ownable,\n  Initializable,\n  UsingRegistry,\n  ReentrancyGuard,\n  UsingPrecompiles\n{\n  using SafeMath for uint256;\n  using SafeCast for uint256;\n\n  enum AttestationStatus { None, Incomplete, Complete }\n\n  struct Attestation {\n    AttestationStatus status;\n    // For outstanding attestations, this is the block number of the request.\n    // For completed attestations, this is the block number of the attestation completion.\n    uint32 blockNumber;\n    // The token with which attestation request fees were paid.\n    address attestationRequestFeeToken;\n  }\n\n  // Stores attestations state for a single (identifier, account address) pair.\n  struct AttestedAddress {\n    // Total number of requested attestations.\n    uint32 requested;\n    // Total number of completed attestations.\n    uint32 completed;\n    // List of selected issuers responsible for attestations. The length of this list\n    // might be smaller than `requested` (which represents the total number of requested\n    // attestations) if users are not calling `selectIssuers` on unselected requests.\n    address[] selectedIssuers;\n    // State of each attestation keyed by issuer.\n    mapping(address => Attestation) issuedAttestations;\n  }\n\n  struct UnselectedRequest {\n    // The block at which the attestations were requested.\n    uint32 blockNumber;\n    // The number of attestations that were requested.\n    uint32 attestationsRequested;\n    // The token with which attestation request fees were paid in this request.\n    address attestationRequestFeeToken;\n  }\n\n  struct IdentifierState {\n    // All account addresses associated with this identifier.\n    address[] accounts;\n    // Keeps the state of attestations for account addresses for this identifier.\n    mapping(address => AttestedAddress) attestations;\n    // Temporarily stores attestation requests for which issuers should be selected by the account.\n    mapping(address => UnselectedRequest) unselectedRequests;\n  }\n\n  mapping(bytes32 => IdentifierState) identifiers;\n\n  // The duration in blocks in which an attestation can be completed from the block in which the\n  // attestation was requested.\n  uint256 public attestationExpiryBlocks;\n\n  // The duration to wait until selectIssuers can be called for an attestation request.\n  uint256 public selectIssuersWaitBlocks;\n\n  // The fees that are associated with attestations for a particular token.\n  mapping(address => uint256) public attestationRequestFees;\n\n  // Maps a token and attestation issuer to the amount that they're owed.\n  mapping(address => mapping(address => uint256)) public pendingWithdrawals;\n\n  event AttestationsRequested(\n    bytes32 indexed identifier,\n    address indexed account,\n    uint256 attestationsRequested,\n    address attestationRequestFeeToken\n  );\n\n  event AttestationIssuerSelected(\n    bytes32 indexed identifier,\n    address indexed account,\n    address indexed issuer,\n    address attestationRequestFeeToken\n  );\n\n  event AttestationCompleted(\n    bytes32 indexed identifier,\n    address indexed account,\n    address indexed issuer\n  );\n\n  event Withdrawal(address indexed account, address indexed token, uint256 amount);\n  event AttestationExpiryBlocksSet(uint256 value);\n  event AttestationRequestFeeSet(address indexed token, uint256 value);\n  event SelectIssuersWaitBlocksSet(uint256 value);\n\n  function initialize(\n    address registryAddress,\n    uint256 _attestationExpiryBlocks,\n    uint256 _selectIssuersWaitBlocks,\n    address[] calldata attestationRequestFeeTokens,\n    uint256[] calldata attestationRequestFeeValues\n  ) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    setAttestationExpiryBlocks(_attestationExpiryBlocks);\n    setSelectIssuersWaitBlocks(_selectIssuersWaitBlocks);\n\n    require(\n      attestationRequestFeeTokens.length > 0 &&\n        attestationRequestFeeTokens.length == attestationRequestFeeValues.length,\n      \"attestationRequestFeeTokens specification was invalid\"\n    );\n    for (uint256 i = 0; i < attestationRequestFeeTokens.length; i = i.add(1)) {\n      setAttestationRequestFee(attestationRequestFeeTokens[i], attestationRequestFeeValues[i]);\n    }\n  }\n\n  /**\n   * @notice Commit to the attestation request of a hashed identifier.\n   * @param identifier The hash of the identifier to be attested.\n   * @param attestationsRequested The number of requested attestations for this request.\n   * @param attestationRequestFeeToken The address of the token with which the attestation fee will\n   * be paid.\n   */\n  function request(\n    bytes32 identifier,\n    uint256 attestationsRequested,\n    address attestationRequestFeeToken\n  ) external nonReentrant {\n    require(\n      attestationRequestFees[attestationRequestFeeToken] > 0,\n      \"Invalid attestationRequestFeeToken\"\n    );\n    require(\n      IERC20Token(attestationRequestFeeToken).transferFrom(\n        msg.sender,\n        address(this),\n        attestationRequestFees[attestationRequestFeeToken].mul(attestationsRequested)\n      ),\n      \"Transfer of attestation request fees failed\"\n    );\n\n    require(attestationsRequested > 0, \"You have to request at least 1 attestation\");\n\n    IdentifierState storage state = identifiers[identifier];\n\n    require(\n      state.unselectedRequests[msg.sender].blockNumber == 0 ||\n        isAttestationExpired(state.unselectedRequests[msg.sender].blockNumber) ||\n        !isAttestationRequestSelectable(state.unselectedRequests[msg.sender].blockNumber),\n      \"There exists an unexpired, unselected attestation request\"\n    );\n\n    state.unselectedRequests[msg.sender].blockNumber = block.number.toUint32();\n    state.unselectedRequests[msg.sender].attestationsRequested = attestationsRequested.toUint32();\n    state.unselectedRequests[msg.sender].attestationRequestFeeToken = attestationRequestFeeToken;\n\n    state.attestations[msg.sender].requested = uint256(state.attestations[msg.sender].requested)\n      .add(attestationsRequested)\n      .toUint32();\n\n    emit AttestationsRequested(\n      identifier,\n      msg.sender,\n      attestationsRequested,\n      attestationRequestFeeToken\n    );\n  }\n\n  /**\n   * @notice Selects the issuers for the most recent attestation request.\n   * @param identifier The hash of the identifier to be attested.\n   */\n  function selectIssuers(bytes32 identifier) external {\n    IdentifierState storage state = identifiers[identifier];\n\n    require(\n      state.unselectedRequests[msg.sender].blockNumber > 0,\n      \"No unselected attestation request to select issuers for\"\n    );\n\n    require(\n      !isAttestationExpired(state.unselectedRequests[msg.sender].blockNumber),\n      \"The attestation request has expired\"\n    );\n\n    addIncompleteAttestations(identifier);\n    delete state.unselectedRequests[msg.sender];\n  }\n\n  /**\n   * @notice Submit the secret message sent by the issuer to complete the attestation request.\n   * @param identifier The hash of the identifier for this attestation.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Throws if there is no matching outstanding attestation request.\n   * @dev Throws if the attestation window has passed.\n   */\n  function complete(bytes32 identifier, uint8 v, bytes32 r, bytes32 s) external {\n    address issuer = validateAttestationCode(identifier, msg.sender, v, r, s);\n\n    Attestation storage attestation = identifiers[identifier].attestations[msg.sender]\n      .issuedAttestations[issuer];\n\n    address token = attestation.attestationRequestFeeToken;\n\n    // solhint-disable-next-line not-rely-on-time\n    attestation.blockNumber = block.number.toUint32();\n    attestation.status = AttestationStatus.Complete;\n    delete attestation.attestationRequestFeeToken;\n    identifiers[identifier].attestations[msg.sender].completed++;\n\n    pendingWithdrawals[token][issuer] = pendingWithdrawals[token][issuer].add(\n      attestationRequestFees[token]\n    );\n\n    IdentifierState storage state = identifiers[identifier];\n    if (identifiers[identifier].attestations[msg.sender].completed == 1) {\n      state.accounts.push(msg.sender);\n    }\n\n    emit AttestationCompleted(identifier, msg.sender, issuer);\n  }\n\n  /**\n   * @notice Revokes an account for an identifier.\n   * @param identifier The identifier for which to revoke.\n   * @param index The index of the account in the accounts array.\n   */\n  function revoke(bytes32 identifier, uint256 index) external {\n    uint256 numAccounts = identifiers[identifier].accounts.length;\n    require(index < numAccounts, \"Index is invalid\");\n    require(\n      msg.sender == identifiers[identifier].accounts[index],\n      \"Index does not match msg.sender\"\n    );\n\n    uint256 newNumAccounts = numAccounts.sub(1);\n    if (index != newNumAccounts) {\n      identifiers[identifier].accounts[index] = identifiers[identifier].accounts[newNumAccounts];\n    }\n    identifiers[identifier].accounts[newNumAccounts] = address(0x0);\n    identifiers[identifier].accounts.length--;\n  }\n\n  /**\n   * @notice Allows issuers to withdraw accumulated attestation rewards.\n   * @param token The address of the token that will be withdrawn.\n   * @dev Throws if msg.sender does not have any rewards to withdraw.\n   */\n  function withdraw(address token) external {\n    uint256 value = pendingWithdrawals[token][msg.sender];\n    require(value > 0, \"value was negative/zero\");\n    pendingWithdrawals[token][msg.sender] = 0;\n    require(IERC20Token(token).transfer(msg.sender, value), \"token transfer failed\");\n    emit Withdrawal(msg.sender, token, value);\n  }\n\n  /**\n   * @notice Returns the unselected attestation request for an identifier/account pair, if any.\n   * @param identifier Hash of the identifier.\n   * @param account Address of the account.\n   * @return [\n   *           Block number at which was requested,\n   *           Number of unselected requests,\n   *           Address of the token with which this attestation request was paid for\n   *         ]\n   */\n  function getUnselectedRequest(bytes32 identifier, address account)\n    external\n    view\n    returns (uint32, uint32, address)\n  {\n    return (\n      identifiers[identifier].unselectedRequests[account].blockNumber,\n      identifiers[identifier].unselectedRequests[account].attestationsRequested,\n      identifiers[identifier].unselectedRequests[account].attestationRequestFeeToken\n    );\n  }\n\n  /**\n   * @notice Returns selected attestation issuers for a identifier/account pair.\n   * @param identifier Hash of the identifier.\n   * @param account Address of the account.\n   * @return Addresses of the selected attestation issuers.\n   */\n  function getAttestationIssuers(bytes32 identifier, address account)\n    external\n    view\n    returns (address[] memory)\n  {\n    return identifiers[identifier].attestations[account].selectedIssuers;\n  }\n\n  /**\n   * @notice Returns attestation stats for a identifier/account pair.\n   * @param identifier Hash of the identifier.\n   * @param account Address of the account.\n   * @return [Number of completed attestations, Number of total requested attestations]\n   */\n  function getAttestationStats(bytes32 identifier, address account)\n    external\n    view\n    returns (uint32, uint32)\n  {\n    return (\n      identifiers[identifier].attestations[account].completed,\n      identifiers[identifier].attestations[account].requested\n    );\n  }\n\n  /**\n   * @notice Batch lookup function to determine attestation stats for a list of identifiers.\n   * @param identifiersToLookup Array of n identifiers.\n   * @return [0] Array of number of matching accounts per identifier.\n   * @return [1] Array of sum([0]) matching walletAddresses.\n   * @return [2] Array of sum([0]) numbers indicating the completions for each account.\n   * @return [3] Array of sum([0]) numbers indicating the total number of requested\n                 attestations for each account.\n   */\n  function batchGetAttestationStats(bytes32[] calldata identifiersToLookup)\n    external\n    view\n    returns (uint256[] memory, address[] memory, uint64[] memory, uint64[] memory)\n  {\n    require(identifiersToLookup.length > 0, \"You have to pass at least one identifier\");\n\n    uint256[] memory matches;\n    address[] memory addresses;\n\n    (matches, addresses) = batchlookupAccountsForIdentifier(identifiersToLookup);\n\n    uint64[] memory completed = new uint64[](addresses.length);\n    uint64[] memory total = new uint64[](addresses.length);\n\n    uint256 currentIndex = 0;\n    for (uint256 i = 0; i < identifiersToLookup.length; i++) {\n      address[] memory addrs = identifiers[identifiersToLookup[i]].accounts;\n      for (uint256 matchIndex = 0; matchIndex < matches[i]; matchIndex++) {\n        addresses[currentIndex] = getAccounts().getWalletAddress(addrs[matchIndex]);\n        completed[currentIndex] = identifiers[identifiersToLookup[i]]\n          .attestations[addrs[matchIndex]]\n          .completed;\n        total[currentIndex] = identifiers[identifiersToLookup[i]].attestations[addrs[matchIndex]]\n          .requested;\n\n        currentIndex++;\n      }\n    }\n\n    return (matches, addresses, completed, total);\n  }\n\n  /**\n   * @notice Returns the state of a specific attestation.\n   * @param identifier Hash of the identifier.\n   * @param account Address of the account.\n   * @param issuer Address of the issuer.\n   * @return [\n   *           Status of the attestation,\n   *           Block number of request/completion the attestation,\n   *           Address of the token with which this attestation request was paid for\n   *         ]\n   */\n  function getAttestationState(bytes32 identifier, address account, address issuer)\n    external\n    view\n    returns (uint8, uint32, address)\n  {\n    Attestation storage attestation = identifiers[identifier].attestations[account]\n      .issuedAttestations[issuer];\n    return (\n      uint8(attestation.status),\n      attestation.blockNumber,\n      attestation.attestationRequestFeeToken\n    );\n\n  }\n\n  /**\n    * @notice Returns the state of all attestations that are completable\n    * @param identifier Hash of the identifier.\n    * @param account Address of the account.\n    * @return ( blockNumbers[] - Block number of request/completion the attestation,\n    *           issuers[] - Address of the issuer,\n    *           stringLengths[] - The length of each metadataURL string for each issuer,\n    *           stringData - All strings concatenated\n    *         )\n    */\n  function getCompletableAttestations(bytes32 identifier, address account)\n    external\n    view\n    returns (uint32[] memory, address[] memory, uint256[] memory, bytes memory)\n  {\n    AttestedAddress storage state = identifiers[identifier].attestations[account];\n    address[] storage issuers = state.selectedIssuers;\n\n    uint256 num = 0;\n    for (uint256 i = 0; i < issuers.length; i = i.add(1)) {\n      if (isAttestationCompletable(state.issuedAttestations[issuers[i]])) {\n        num = num.add(1);\n      }\n    }\n\n    uint32[] memory blockNumbers = new uint32[](num);\n    address[] memory completableIssuers = new address[](num);\n\n    uint256 pointer = 0;\n    for (uint256 i = 0; i < issuers.length; i = i.add(1)) {\n      if (isAttestationCompletable(state.issuedAttestations[issuers[i]])) {\n        blockNumbers[pointer] = state.issuedAttestations[issuers[i]].blockNumber;\n        completableIssuers[pointer] = issuers[i];\n        pointer = pointer.add(1);\n      }\n    }\n\n    uint256[] memory stringLengths;\n    bytes memory stringData;\n    (stringLengths, stringData) = getAccounts().batchGetMetadataURL(completableIssuers);\n    return (blockNumbers, completableIssuers, stringLengths, stringData);\n  }\n\n  /**\n   * @notice Returns the fee set for a particular token.\n   * @param token Address of the attestationRequestFeeToken.\n   * @return The fee.\n   */\n  function getAttestationRequestFee(address token) external view returns (uint256) {\n    return attestationRequestFees[token];\n  }\n\n  /**\n   * @notice Updates the fee  for a particular token.\n   * @param token The address of the attestationRequestFeeToken.\n   * @param fee The fee in 'token' that is required for each attestation.\n   */\n  function setAttestationRequestFee(address token, uint256 fee) public onlyOwner {\n    require(fee > 0, \"You have to specify a fee greater than 0\");\n    attestationRequestFees[token] = fee;\n    emit AttestationRequestFeeSet(token, fee);\n  }\n\n  /**\n   * @notice Updates 'attestationExpiryBlocks'.\n   * @param _attestationExpiryBlocks The new limit on blocks allowed to come between requesting\n   * an attestation and completing it.\n   */\n  function setAttestationExpiryBlocks(uint256 _attestationExpiryBlocks) public onlyOwner {\n    require(_attestationExpiryBlocks > 0, \"attestationExpiryBlocks has to be greater than 0\");\n    attestationExpiryBlocks = _attestationExpiryBlocks;\n    emit AttestationExpiryBlocksSet(_attestationExpiryBlocks);\n  }\n\n  /**\n   * @notice Updates 'selectIssuersWaitBlocks'.\n   * @param _selectIssuersWaitBlocks The wait period in blocks to call selectIssuers on attestation\n   *                                 requests.\n   */\n  function setSelectIssuersWaitBlocks(uint256 _selectIssuersWaitBlocks) public onlyOwner {\n    require(_selectIssuersWaitBlocks > 0, \"selectIssuersWaitBlocks has to be greater than 0\");\n    selectIssuersWaitBlocks = _selectIssuersWaitBlocks;\n    emit SelectIssuersWaitBlocksSet(_selectIssuersWaitBlocks);\n  }\n\n  /**\n   * @notice Validates the given attestation code.\n   * @param identifier The hash of the identifier to be attested.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @return The issuer of the corresponding attestation.\n   * @dev Throws if there is no matching outstanding attestation request.\n   * @dev Throws if the attestation window has passed.\n   */\n  function validateAttestationCode(\n    bytes32 identifier,\n    address account,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public view returns (address) {\n    bytes32 codehash = keccak256(abi.encodePacked(identifier, account));\n    address signer = Signatures.getSignerOfMessageHash(codehash, v, r, s);\n    address issuer = getAccounts().attestationSignerToAccount(signer);\n\n    Attestation storage attestation = identifiers[identifier].attestations[account]\n      .issuedAttestations[issuer];\n\n    require(\n      attestation.status == AttestationStatus.Incomplete,\n      \"Attestation code does not match any outstanding attestation\"\n    );\n    require(!isAttestationExpired(attestation.blockNumber), \"Attestation timed out\");\n\n    return issuer;\n  }\n\n  function lookupAccountsForIdentifier(bytes32 identifier)\n    external\n    view\n    returns (address[] memory)\n  {\n    return identifiers[identifier].accounts;\n  }\n\n  /**\n   * @notice Helper function for batchGetAttestat"
    }
  ]
}