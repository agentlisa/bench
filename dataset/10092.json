{
  "Title": "[H-01] Copy your own portfolio to keep earning royalties",
  "Content": "_Submitted by jayjonah8_\n\n#### Impact\nIn `NestedFactory.sol` going through the `create()` function which leads to the `sendFeesWithRoyalties()` => `addShares()` function,  Im not seeing any checks preventing someone from copying their own portfolio and receiving royalty shares for it and simply repeating the process over and over again.\n\n#### Proof of Concept\n- [`FeeSplitter.sol` L152](https://github.com/code-423n4/2021-11-nested/blob/main/contracts/FeeSplitter.sol#L152)\n- [`FeeSplitter.sol` L220](https://github.com/code-423n4/2021-11-nested/blob/main/contracts/FeeSplitter.sol#L220)\n- [`NestedFactory.sol` L103](https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedFactory.sol#L103)\n- [`NestedAsset.sol` L69](https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedAsset.sol#L69)\n- [`NestedFactory.sol` L103](https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedFactory.sol#L103)\n- [`NestedFactory.sol` L491](https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedFactory.sol#L491)\n\n#### Tools Used\nManual code review\n\n#### Recommended Mitigation Steps\nA require statement should be added not allowing users to copy their own portfolios.\n\n**[maximebrugel (Nested) disagreed with severity](https://github.com/code-423n4/2021-11-nested-findings/issues/30#issuecomment-970388713):**\n > Indeed, a user can copy his own portfolio to reduce the fees, however a require statement won't fix this issue...\n>\n> This problem cannot be corrected but only mitigated, since the user can use two different wallets.\n> Currently the front-end doesn't allow to duplicate a portfolio with the same address.\n>\n> I don't consider this a \"High Risk\" since the assets are not really stolen. Maybe \"Med Risk\" ? This is by design an issue and we tolerate that users can do this (with multiple wallets).\n>\n\n**[alcueca (judge) commented](https://github.com/code-423n4/2021-11-nested-findings/issues/30#issuecomment-985642915):**\n > I'm reading that the vulnerability actually lowers fees to zero for a dedicated attacker, since creating a arbitrarily large number of wallets and bypassing the frontend is easy. In theory leaking protocol value would be a severity 2, but since this is effectively disabling a core feature of the protocol (fees), the severity 3 is sustained.\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2021-11-nested-finance-contest",
  "Code": [
    {
      "filename": "contracts/FeeSplitter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./interfaces/external/IWETH.sol\";\n\n/// @title Manage the fees between shareholders\n/// @notice Receives fees collected by the NestedFactory, and splits the income among\n/// shareholders (the NFT owners, Nested treasury and a NST buybacker contract).\ncontract FeeSplitter is Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @dev Emitted when a payment is released\n    /// @param to The address receiving the payment\n    /// @param token The token transfered\n    /// @param amount The amount paid\n    event PaymentReleased(address to, address token, uint256 amount);\n\n    /// @dev Emitted when a payment is released\n    /// @param from The address sending the tokens\n    /// @param token The token received\n    /// @param amount The amount received\n    event PaymentReceived(address from, address token, uint256 amount);\n\n    /// @dev Represent a shareholder\n    /// @param account Shareholders address that can receive income\n    /// @param weight Determines share allocation\n    struct Shareholder {\n        address account;\n        uint256 weight;\n    }\n\n    /// @dev Registers shares and amount release for a specific token or ETH\n    struct TokenRecords {\n        uint256 totalShares;\n        uint256 totalReleased;\n        mapping(address => uint256) shares;\n        mapping(address => uint256) released;\n    }\n\n    /// @dev Map of tokens with the tokenRecords\n    mapping(address => TokenRecords) private tokenRecords;\n\n    /// @dev All the shareholders (array)\n    Shareholder[] private shareholders;\n\n    /// @dev Royalties part weights when applicable\n    uint256 public royaltiesWeight;\n\n    uint256 public totalWeights;\n\n    address public immutable weth;\n\n    constructor(\n        address[] memory _accounts,\n        uint256[] memory _weights,\n        uint256 _royaltiesWeight,\n        address _weth\n    ) {\n        // Initial shareholders addresses and weights\n        setShareholders(_accounts, _weights);\n        setRoyaltiesWeight(_royaltiesWeight);\n        weth = _weth;\n    }\n\n    /// @dev Receive ether after a WETH withdraw call\n    receive() external payable {\n        require(_msgSender() == weth, \"FeeSplitter: ETH_SENDER_NOT_WETH\");\n    }\n\n    /// @notice Returns the amount due to an account. Call releaseToken to withdraw the amount.\n    /// @param _account Account address to check the amount due for\n    /// @param _token ERC20 payment token address (or ETH_ADDR)\n    /// @return The total amount due for the requested currency\n    function getAmountDue(address _account, IERC20 _token) public view returns (uint256) {\n        TokenRecords storage _tokenRecords = tokenRecords[address(_token)];\n        uint256 totalReceived = _tokenRecords.totalReleased;\n        if (_tokenRecords.totalShares == 0) return 0;\n        else totalReceived += _token.balanceOf(address(this));\n        uint256 amountDue = (totalReceived * _tokenRecords.shares[_account]) /\n            _tokenRecords.totalShares -\n            _tokenRecords.released[_account];\n        return amountDue;\n    }\n\n    /// @notice Sets the weight assigned to the royalties part for the fee\n    /// @param _weight The new royalties weight\n    function setRoyaltiesWeight(uint256 _weight) public onlyOwner {\n        totalWeights -= royaltiesWeight;\n        royaltiesWeight = _weight;\n        totalWeights += _weight;\n    }\n\n    /// @notice Sets a new list of shareholders\n    /// @param _accounts Shareholders accounts list\n    /// @param _weights Weight for each shareholder. Determines part of the payment allocated to them\n    function setShareholders(address[] memory _accounts, uint256[] memory _weights) public onlyOwner {\n        delete shareholders;\n        require(_accounts.length > 0 && _accounts.length == _weights.length, \"FeeSplitter: ARRAY_LENGTHS_ERR\");\n        totalWeights = royaltiesWeight;\n\n        for (uint256 i = 0; i < _accounts.length; i++) {\n            _addShareholder(_accounts[i], _weights[i]);\n        }\n    }\n\n    /// @notice Triggers a transfer to `msg.sender` of the amount of token they are owed, according to\n    /// the amount of shares they own and their previous withdrawals.\n    /// @param _token Payment token address\n    function releaseToken(IERC20 _token) public nonReentrant {\n        uint256 amount = _releaseToken(_msgSender(), _token);\n        _token.safeTransfer(_msgSender(), amount);\n        emit PaymentReleased(_msgSender(), address(_token), amount);\n    }\n\n    /// @notice Call releaseToken() for multiple tokens\n    /// @param _tokens ERC20 tokens to release\n    function releaseTokens(IERC20[] memory _tokens) external {\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            releaseToken(_tokens[i]);\n        }\n    }\n\n    /// @dev Triggers a transfer to `msg.sender` of the amount of Ether they are owed, according to\n    /// the amount of shares they own and their previous withdrawals.\n    function releaseETH() external nonReentrant {\n        uint256 amount = _releaseToken(_msgSender(), IERC20(weth));\n        IWETH(weth).withdraw(amount);\n        (bool success, ) = _msgSender().call{ value: amount }(\"\");\n        require(success, \"FeeSplitter: ETH_TRANFER_ERROR\");\n        emit PaymentReleased(_msgSender(), ETH, amount);\n    }\n\n    /// @notice Sends a fee to this contract for splitting, as an ERC20 token. No royalties are expected.\n    /// @param _token Currency for the fee as an ERC20 token\n    /// @param _amount Amount of token as fee to be claimed by this contract\n    function sendFees(IERC20 _token, uint256 _amount) external nonReentrant {\n        uint256 weights = totalWeights - royaltiesWeight;\n        _sendFees(_token, _amount, weights);\n    }\n\n    /// @notice Sends a fee to this contract for splitting, as an ERC20 token\n    /// @param _royaltiesTarget The account that can claim royalties\n    /// @param _token Currency for the fee as an ERC20 token\n    /// @param _amount Amount of token as fee to be claimed by this contract\n    function sendFeesWithRoyalties(\n        address _royaltiesTarget,\n        IERC20 _token,\n        uint256 _amount\n    ) external nonReentrant {\n        require(_royaltiesTarget != address(0), \"FeeSplitter: INVALID_ROYALTIES_TARGET_ADDRESS\");\n\n        _sendFees(_token, _amount, totalWeights);\n        _addShares(_royaltiesTarget, _computeShareCount(_amount, royaltiesWeight, totalWeights), address(_token));\n    }\n\n    /// @notice Updates weight for a shareholder\n    /// @param _accountIndex Account to change the weight of\n    /// @param _weight The new weight\n    function updateShareholder(uint256 _accountIndex, uint256 _weight) external onlyOwner {\n        require(_accountIndex + 1 <= shareholders.length, \"FeeSplitter: INVALID_ACCOUNT_INDEX\");\n        uint256 _totalWeights = totalWeights;\n        _totalWeights -= shareholders[_accountIndex].weight;\n        shareholders[_accountIndex].weight = _weight;\n        _totalWeights += _weight;\n        require(_totalWeights > 0, \"FeeSplitter: TOTAL_WEIGHTS_ZERO\");\n        totalWeights = _totalWeights;\n    }\n\n    /// @notice Getter for the total shares held by shareholders.\n    /// @param _token Payment token address, use ETH_ADDR for ETH\n    /// @return The total shares count\n    function totalShares(address _token) external view returns (uint256) {\n        return tokenRecords[_token].totalShares;\n    }\n\n    /// @notice Getter for the total amount of token already released.\n    /// @param _token Payment token address, use ETH_ADDR for ETH\n    /// @return The total amount release to shareholders\n    function totalReleased(address _token) external view returns (uint256) {\n        return tokenRecords[_token].totalReleased;\n    }\n\n    /// @notice Getter for the amount of shares held by an account.\n    /// @param _account Account the shares belong to\n    /// @param _token Payment token address, use ETH_ADDR for ETH\n    /// @return The shares owned by the account\n    function shares(address _account, address _token) external view returns (uint256) {\n        return tokenRecords[_token].shares[_account];\n    }\n\n    /// @notice Getter for the amount of Ether already released to a shareholders.\n    /// @param _account The target account for this request\n    /// @param _token Payment token address, use ETH_ADDR for ETH\n    /// @return The amount already released to this account\n    function released(address _account, address _token) external view returns (uint256) {\n        return tokenRecords[_token].released[_account];\n    }\n\n    /// @notice Finds a shareholder and return its index\n    /// @param _account Account to find\n    /// @return The shareholder index in the storage array\n    function findShareholder(address _account) external view returns (uint256) {\n        for (uint256 i = 0; i < shareholders.length; i++) {\n            if (shareholders[i].account == _account) return i;\n        }\n        revert(\"FeeSplitter: NOT_FOUND\");\n    }\n\n    /// @dev Transfers a fee to this contract\n    /// @param _token Currency for the fee\n    /// @param _amount Amount of token as fee\n    /// @param _totalWeights Total weights to determine the share count to allocate\n    function _sendFees(\n        IERC20 _token,\n        uint256 _amount,\n        uint256 _totalWeights\n    ) private {\n        IERC20(_token).safeTransferFrom(_msgSender(), address(this), _amount);\n\n        for (uint256 i = 0; i < shareholders.length; i++) {\n            _addShares(\n                shareholders[i].account,\n                _computeShareCount(_amount, shareholders[i].weight, _totalWeights),\n                address(_token)\n            );\n        }\n        emit PaymentReceived(_msgSender(), address(_token), _amount);\n    }\n\n    /// @dev Increase the shares of a shareholder\n    /// @param _account The shareholder address\n    /// @param _shares The shares of the holder\n    /// @param _token The updated token\n    function _addShares(\n        address _account,\n        uint256 _shares,\n        address _token\n    ) private {\n        TokenRecords storage _tokenRecords = tokenRecords[_token];\n        _tokenRecords.shares[_account] += _shares;\n        _tokenRecords.totalShares = _tokenRecords.totalShares + _shares;\n    }\n\n    function _releaseToken(address _account, IERC20 _token) private returns (uint256) {\n        TokenRecords storage _tokenRecords = tokenRecords[address(_token)];\n        uint256 amountToRelease = getAmountDue(_account, _token);\n        require(amountToRelease != 0, \"FeeSplitter: NO_PAYMENT_DUE\");\n\n        _tokenRecords.released[_account] = _tokenRecords.released[_account] + amountToRelease;\n        _tokenRecords.totalReleased = _tokenRecords.totalReleased + amountToRelease;\n\n        return amountToRelease;\n    }\n\n    function _addShareholder(address _account, uint256 _weight) private {\n        require(_weight > 0, \"FeeSplitter: ZERO_WEIGHT\");\n        shareholders.push(Shareholder(_account, _weight));\n        totalWeights += _weight;\n    }\n\n    function _computeShareCount(\n        uint256 _amount,\n        uint256 _weight,\n        uint256 _totalWeights\n    ) private pure returns (uint256) {\n        return (_amount * _weight) / _totalWeights;\n    }\n}"
    },
    {
      "filename": "contracts/FeeSplitter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./interfaces/external/IWETH.sol\";\n\n/// @title Manage the fees between shareholders\n/// @notice Receives fees collected by the NestedFactory, and splits the income among\n/// shareholders (the NFT owners, Nested treasury and a NST buybacker contract).\ncontract FeeSplitter is Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @dev Emitted when a payment is released\n    /// @param to The address receiving the payment\n    /// @param token The token transfered\n    /// @param amount The amount paid\n    event PaymentReleased(address to, address token, uint256 amount);\n\n    /// @dev Emitted when a payment is released\n    /// @param from The address sending the tokens\n    /// @param token The token received\n    /// @param amount The amount received\n    event PaymentReceived(address from, address token, uint256 amount);\n\n    /// @dev Represent a shareholder\n    /// @param account Shareholders address that can receive income\n    /// @param weight Determines share allocation\n    struct Shareholder {\n        address account;\n        uint256 weight;\n    }\n\n    /// @dev Registers shares and amount release for a specific token or ETH\n    struct TokenRecords {\n        uint256 totalShares;\n        uint256 totalReleased;\n        mapping(address => uint256) shares;\n        mapping(address => uint256) released;\n    }\n\n    /// @dev Map of tokens with the tokenRecords\n    mapping(address => TokenRecords) private tokenRecords;\n\n    /// @dev All the shareholders (array)\n    Shareholder[] private shareholders;\n\n    /// @dev Royalties part weights when applicable\n    uint256 public royaltiesWeight;\n\n    uint256 public totalWeights;\n\n    address public immutable weth;\n\n    constructor(\n        address[] memory _accounts,\n        uint256[] memory _weights,\n        uint256 _royaltiesWeight,\n        address _weth\n    ) {\n        // Initial shareholders addresses and weights\n        setShareholders(_accounts, _weights);\n        setRoyaltiesWeight(_royaltiesWeight);\n        weth = _weth;\n    }\n\n    /// @dev Receive ether after a WETH withdraw call\n    receive() external payable {\n        require(_msgSender() == weth, \"FeeSplitter: ETH_SENDER_NOT_WETH\");\n    }\n\n    /// @notice Returns the amount due to an account. Call releaseToken to withdraw the amount.\n    /// @param _account Account address to check the amount due for\n    /// @param _token ERC20 payment token address (or ETH_ADDR)\n    /// @return The total amount due for the requested currency\n    function getAmountDue(address _account, IERC20 _token) public view returns (uint256) {\n        TokenRecords storage _tokenRecords = tokenRecords[address(_token)];\n        uint256 totalReceived = _tokenRecords.totalReleased;\n        if (_tokenRecords.totalShares == 0) return 0;\n        else totalReceived += _token.balanceOf(address(this));\n        uint256 amountDue = (totalReceived * _tokenRecords.shares[_account]) /\n            _tokenRecords.totalShares -\n            _tokenRecords.released[_account];\n        return amountDue;\n    }\n\n    /// @notice Sets the weight assigned to the royalties part for the fee\n    /// @param _weight The new royalties weight\n    function setRoyaltiesWeight(uint256 _weight) public onlyOwner {\n        totalWeights -= royaltiesWeight;\n        royaltiesWeight = _weight;\n        totalWeights += _weight;\n    }\n\n    /// @notice Sets a new list of shareholders\n    /// @param _accounts Shareholders accounts list\n    /// @param _weights Weight for each shareholder. Determines part of the payment allocated to them\n    function setShareholders(address[] memory _accounts, uint256[] memory _weights) public onlyOwner {\n        delete shareholders;\n        require(_accounts.length > 0 && _accounts.length == _weights.length, \"FeeSplitter: ARRAY_LENGTHS_ERR\");\n        totalWeights = royaltiesWeight;\n\n        for (uint256 i = 0; i < _accounts.length; i++) {\n            _addShareholder(_accounts[i], _weights[i]);\n        }\n    }\n\n    /// @notice Triggers a transfer to `msg.sender` of the amount of token they are owed, according to\n    /// the amount of shares they own and their previous withdrawals.\n    /// @param _token Payment token address\n    function releaseToken(IERC20 _token) public nonReentrant {\n        uint256 amount = _releaseToken(_msgSender(), _token);\n        _token.safeTransfer(_msgSender(), amount);\n        emit PaymentReleased(_msgSender(), address(_token), amount);\n    }\n\n    /// @notice Call releaseToken() for multiple tokens\n    /// @param _tokens ERC20 tokens to release\n    function releaseTokens(IERC20[] memory _tokens) external {\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            releaseToken(_tokens[i]);\n        }\n    }\n\n    /// @dev Triggers a transfer to `msg.sender` of the amount of Ether they are owed, according to\n    /// the amount of shares they own and their previous withdrawals.\n    function releaseETH() external nonReentrant {\n        uint256 amount = _releaseToken(_msgSender(), IERC20(weth));\n        IWETH(weth).withdraw(amount);\n        (bool success, ) = _msgSender().call{ value: amount }(\"\");\n        require(success, \"FeeSplitter: ETH_TRANFER_ERROR\");\n        emit PaymentReleased(_msgSender(), ETH, amount);\n    }\n\n    /// @notice Sends a fee to this contract for splitting, as an ERC20 token. No royalties are expected.\n    /// @param _token Currency for the fee as an ERC20 token\n    /// @param _amount Amount of token as fee to be claimed by this contract\n    function sendFees(IERC20 _token, uint256 _amount) external nonReentrant {\n        uint256 weights = totalWeights - royaltiesWeight;\n        _sendFees(_token, _amount, weights);\n    }\n\n    /// @notice Sends a fee to this contract for splitting, as an ERC20 token\n    /// @param _royaltiesTarget The account that can claim royalties\n    /// @param _token Currency for the fee as an ERC20 token\n    /// @param _amount Amount of token as fee to be claimed by this contract\n    function sendFeesWithRoyalties(\n        address _royaltiesTarget,\n        IERC20 _token,\n        uint256 _amount\n    ) external nonReentrant {\n        require(_royaltiesTarget != address(0), \"FeeSplitter: INVALID_ROYALTIES_TARGET_ADDRESS\");\n\n        _sendFees(_token, _amount, totalWeights);\n        _addShares(_royaltiesTarget, _computeShareCount(_amount, royaltiesWeight, totalWeights), address(_token));\n    }\n\n    /// @notice Updates weight for a shareholder\n    /// @param _accountIndex Account to change the weight of\n    /// @param _weight The new weight\n    function updateShareholder(uint256 _accountIndex, uint256 _weight) external onlyOwner {\n        require(_accountIndex + 1 <= shareholders.length, \"FeeSplitter: INVALID_ACCOUNT_INDEX\");\n        uint256 _totalWeights = totalWeights;\n        _totalWeights -= shareholders[_accountIndex].weight;\n        shareholders[_accountIndex].weight = _weight;\n        _totalWeights += _weight;\n        require(_totalWeights > 0, \"FeeSplitter: TOTAL_WEIGHTS_ZERO\");\n        totalWeights = _totalWeights;\n    }\n\n    /// @notice Getter for the total shares held by shareholders.\n    /// @param _token Payment token address, use ETH_ADDR for ETH\n    /// @return The total shares count\n    function totalShares(address _token) external view returns (uint256) {\n        return tokenRecords[_token].totalShares;\n    }\n\n    /// @notice Getter for the total amount of token already released.\n    /// @param _token Payment token address, use ETH_ADDR for ETH\n    /// @return The total amount release to shareholders\n    function totalReleased(address _token) external view returns (uint256) {\n        return tokenRecords[_token].totalReleased;\n    }\n\n    /// @notice Getter for the amount of shares held by an account.\n    /// @param _account Account the shares belong to\n    /// @param _token Payment token address, use ETH_ADDR for ETH\n    /// @return The shares owned by the account\n    function shares(address _account, address _token) external view returns (uint256) {\n        return tokenRecords[_token].shares[_account];\n    }\n\n    /// @notice Getter for the amount of Ether already released to a shareholders.\n    /// @param _account The target account for this request\n    /// @param _token Payment token address, use ETH_ADDR for ETH\n    /// @return The amount already released to this account\n    function released(address _account, address _token) external view returns (uint256) {\n        return tokenRecords[_token].released[_account];\n    }\n\n    /// @notice Finds a shareholder and return its index\n    /// @param _account Account to find\n    /// @return The shareholder index in the storage array\n    function findShareholder(address _account) external view returns (uint256) {\n        for (uint256 i = 0; i < shareholders.length; i++) {\n            if (shareholders[i].account == _account) return i;\n        }\n        revert(\"FeeSplitter: NOT_FOUND\");\n    }\n\n    /// @dev Transfers a fee to this contract\n    /// @param _token Currency for the fee\n    /// @param _amount Amount of token as fee\n    /// @param _totalWeights Total weights to determine the share count to allocate\n    function _sendFees(\n        IERC20 _token,\n        uint256 _amount,\n        uint256 _totalWeights\n    ) private {\n        IERC20(_token).safeTransferFrom(_msgSender(), address(this), _amount);\n\n        for (uint256 i = 0; i < shareholders.length; i++) {\n            _addShares(\n                shareholders[i].account,\n                _computeShareCount(_amount, shareholders[i].weight, _totalWeights),\n                address(_token)\n            );\n        }\n        emit PaymentReceived(_msgSender(), address(_token), _amount);\n    }\n\n    /// @dev Increase the shares of a shareholder\n    /// @param _account The shareholder address\n    /// @param _shares The shares of the holder\n    /// @param _token The updated token\n    function _addShares(\n        address _account,\n        uint256 _shares,\n        address _token\n    ) private {\n        TokenRecords storage _tokenRecords = tokenRecords[_token];\n        _tokenRecords.shares[_account] += _shares;\n        _tokenRecords.totalShares = _tokenRecords.totalShares + _shares;\n    }\n\n    function _releaseToken(address _account, IERC20 _token) private returns (uint256) {\n        TokenRecords storage _tokenRecords = tokenRecords[address(_token)];\n        uint256 amountToRelease = getAmountDue(_account, _token);\n        require(amountToRelease != 0, \"FeeSplitter: NO_PAYMENT_DUE\");\n\n        _tokenRecords.released[_account] = _tokenRecords.released[_account] + amountToRelease;\n        _tokenRecords.totalReleased = _tokenRecords.totalReleased + amountToRelease;\n\n        return amountToRelease;\n    }\n\n    function _addShareholder(address _account, uint256 _weight) private {\n        require(_weight > 0, \"FeeSplitter: ZERO_WEIGHT\");\n        shareholders.push(Shareholder(_account, _weight));\n        totalWeights += _weight;\n    }\n\n    function _computeShareCount(\n        uint256 _amount,\n        uint256 _weight,\n        uint256 _totalWeights\n    ) private pure returns (uint256) {\n        return (_amount * _weight) / _totalWeights;\n    }\n}"
    },
    {
      "filename": "contracts/NestedFactory.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Multicall.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./libraries/ExchangeHelpers.sol\";\nimport \"./libraries/OperatorHelpers.sol\";\nimport \"./interfaces/external/IWETH.sol\";\nimport \"./interfaces/INestedFactory.sol\";\nimport \"./FeeSplitter.sol\";\nimport \"./MixinOperatorResolver.sol\";\nimport \"./NestedReserve.sol\";\nimport \"./NestedAsset.sol\";\nimport \"./NestedRecords.sol\";\n\n/// @title Creates, updates and destroys NestedAssets.\n/// @notice Responsible for the business logic of the protocol and interaction with operators\ncontract NestedFactory is INestedFactory, ReentrancyGuard, Ownable, MixinOperatorResolver, Multicall {\n    using SafeERC20 for IERC20;\n    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @dev Supported operators by the factory contract\n    bytes32[] private operators;\n\n    /// @dev Current feeSplitter contract/address\n    FeeSplitter public feeSplitter;\n\n    /// @dev Current reserve contract/address\n    NestedReserve public reserve;\n\n    NestedAsset public immutable nestedAsset;\n    IWETH public immutable weth;\n    NestedRecords public immutable nestedRecords;\n\n    constructor(\n        NestedAsset _nestedAsset,\n        NestedRecords _nestedRecords,\n        FeeSplitter _feeSplitter,\n        IWETH _weth,\n        address _operatorResolver\n    ) MixinOperatorResolver(_operatorResolver) {\n        nestedAsset = _nestedAsset;\n        nestedRecords = _nestedRecords;\n        feeSplitter = _feeSplitter;\n        weth = _weth;\n    }\n\n    /// @dev Reverts the transaction if the caller is not the token owner\n    /// @param _nftId The NFT Id\n    modifier onlyTokenOwner(uint256 _nftId) {\n        require(nestedAsset.ownerOf(_nftId) == _msgSender(), \"NestedFactory: Not the token owner\");\n        _;\n    }\n\n    /// @dev Reverts the transaction if the nft is locked (hold by design).\n    /// The block.timestamp must be greater than NFT record lock timestamp\n    /// @param _nftId The NFT Id\n    modifier isUnlocked(uint256 _nftId) {\n        require(block.timestamp > nestedRecords.getLockTimestamp(_nftId), \"NestedFactory: The NFT is currently locked\");\n        _;\n    }\n\n    /// @dev Receive function\n    receive() external payable {}\n\n    /// @notice Get the required operator addresses\n    function resolverAddressesRequired() public view override returns (bytes32[] memory addresses) {\n        return operators;\n    }\n\n    /// @inheritdoc INestedFactory\n    function addOperator(bytes32 operator) external override onlyOwner {\n        operators.push(operator);\n    }\n\n    /// @inheritdoc INestedFactory\n    function removeOperator(bytes32 operator) external override onlyOwner {\n        uint256 i = 0;\n        while (operators[i] != operator) {\n            i++;\n        }\n        require(i > 0, \"NestedFactory::removeOperator: Cant remove non-existent operator\");\n        delete operators[i];\n    }\n\n    /// @inheritdoc INestedFactory\n    function setReserve(NestedReserve _reserve) external override onlyOwner {\n        require(address(reserve) == address(0), \"NestedFactory::setReserve: Reserve is immutable\");\n        reserve = _reserve;\n        emit ReserveUpdated(address(_reserve));\n    }\n\n    /// @inheritdoc INestedFactory\n    function setFeeSplitter(FeeSplitter _feeSplitter) external override onlyOwner {\n        require(address(_feeSplitter) != address(0), \"NestedFactory::setFeeSplitter: Invalid feeSplitter address\");\n        feeSplitter = _feeSplitter;\n        emit FeeSplitterUpdated(address(_feeSplitter));\n    }\n\n    /// @inheritdoc INestedFactory\n    function create(\n        uint256 _originalTokenId,\n        IERC20 _sellToken,\n        uint256 _sellTokenAmount,\n        Order[] calldata _orders\n    ) external payable override nonReentrant {\n        require(_orders.length > 0, \"NestedFactory::create: Missing orders\");\n\n        uint256 nftId = nestedAsset.mint(_msgSender(), _originalTokenId);\n        (uint256 fees, IERC20 tokenSold) = _submitInOrders(nftId, _sellToken, _sellTokenAmount, _orders, true, false);\n\n        _transferFeeWithRoyalty(fees, tokenSold, nftId);\n        emit NftCreated(nftId, _originalTokenId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function addTokens(\n        uint256 _nftId,\n        IERC20 _sellToken,\n        uint256 _sellTokenAmount,\n        Order[] calldata _orders\n    ) external payable override nonReentrant onlyTokenOwner(_nftId) {\n        require(_orders.length > 0, \"NestedFactory::addTokens: Missing orders\");\n\n        (uint256 fees, IERC20 tokenSold) = _submitInOrders(_nftId, _sellToken, _sellTokenAmount, _orders, true, false);\n        _transferFeeWithRoyalty(fees, tokenSold, _nftId);\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function swapTokenForTokens(\n        uint256 _nftId,\n        IERC20 _sellToken,\n        uint256 _sellTokenAmount,\n        Order[] calldata _orders\n    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        require(_orders.length > 0, \"NestedFactory::swapTokenForTokens: Missing orders\");\n        require(\n            nestedRecords.getAssetReserve(_nftId) == address(reserve),\n            \"NestedFactory::swapTokenForTokens: Assets in different reserve\"\n        );\n\n        (uint256 fees, IERC20 tokenSold) = _submitInOrders(_nftId, _sellToken, _sellTokenAmount, _orders, true, true);\n        _transferFeeWithRoyalty(fees, tokenSold, _nftId);\n\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function sellTokensToNft(\n        uint256 _nftId,\n        IERC20 _buyToken,\n        uint256[] memory _sellTokensAmount,\n        Order[] calldata _orders\n    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        require(_orders.length > 0, \"NestedFactory::sellTokensToNft: Missing orders\");\n        require(_sellTokensAmount.length == _orders.length, \"NestedFactory::sellTokensToNft: Input lengths must match\");\n        require(\n            nestedRecords.getAssetReserve(_nftId) == address(reserve),\n            \"NestedFactory::sellTokensToNft: Assets in different reserve\"\n        );\n\n        (uint256 feesAmount, ) = _submitOutOrders(_nftId, _buyToken, _sellTokensAmount, _orders, true, true);\n        _transferFeeWithRoyalty(feesAmount, _buyToken, _nftId);\n\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function sellTokensToWallet(\n        uint256 _nftId,\n        IERC20 _buyToken,\n        uint256[] memory _sellTokensAmount,\n        Order[] calldata _orders\n    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        require(_orders.length > 0, \"NestedFactory::sellTokensToWallet: Missing orders\");\n        require(\n            _sellTokensAmount.length == _orders.length,\n            \"NestedFactory::sellTokensToWallet: Input lengths must match\"\n        );\n        require(\n            nestedRecords.getAssetReserve(_nftId) == address(reserve),\n            \"NestedFactory::sellTokensToWallet: Assets in different reserve\"\n        );\n\n        (uint256 feesAmount, uint256 amountBought) = _submitOutOrders(\n            _nftId,\n            _buyToken,\n            _sellTokensAmount,\n            _orders,\n            false,\n            true\n        );\n        _transferFeeWithRoyalty(feesAmount, _buyToken, _nftId);\n        _safeTransferAndUnwrap(_buyToken, amountBought - feesAmount, _msgSender());\n\n        emit NftUpdated(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function destroy(\n        uint256 _nftId,\n        IERC20 _buyToken,\n        Order[] calldata _orders\n    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\n        address[] memory tokens = nestedRecords.getAssetTokens(_nftId);\n        require(_orders.length > 0, \"NestedFactory::destroy: Missing orders\");\n        require(tokens.length == _orders.length, \"NestedFactory::destroy: Missing sell args\");\n        require(\n            nestedRecords.getAssetReserve(_nftId) == address(reserve),\n            \"NestedFactory::destroy: Assets in different reserve\"\n        );\n\n        uint256 buyTokenInitialBalance = _buyToken.balanceOf(address(this));\n\n        for (uint256 i = 0; i < tokens.length; i++) {\n            NestedRecords.Holding memory holding = nestedRecords.getAssetHolding(_nftId, tokens[i]);\n            reserve.withdraw(IERC20(holding.token), holding.amount);\n\n            _safeSubmitOrder(tokens[i], address(_buyToken), holding.amount, _nftId, _orders[i]);\n            nestedRecords.freeHolding(_nftId, tokens[i]);\n        }\n\n        // Amount calculation to send fees and tokens\n        uint256 amountBought = _buyToken.balanceOf(address(this)) - buyTokenInitialBalance;\n        uint256 amountFees = _calculateFees(_msgSender(), amountBought);\n        amountBought = amountBought - amountFees;\n\n        _transferFeeWithRoyalty(amountFees, _buyToken, _nftId);\n        _safeTransferAndUnwrap(_buyToken, amountBought, _msgSender());\n\n        // Burn NFT\n        nestedRecords.removeNFT(_nftId);\n        nestedAsset.burn(_msgSender(), _nftId);\n        emit NftBurned(_nftId);\n    }\n\n    /// @inheritdoc INestedFactory\n    function withdraw(uint256 _nftId, uint256 _tokenIndex)\n        external\n        override\n        nonReentrant\n        onlyTokenOwner(_nftId)\n        isUnlocked(_nftId)\n    {\n        uint256 assetTokensLength = nestedRecords.getAssetTokensLength(_nftId);\n        require(assetTokensLength > _tokenIndex, \"NestedFactory::withdraw: Invalid token index\");\n        // Use destroy instead if NFT has a single hol"
    }
  ]
}