{
  "Title": "[M-01] rageQuit() cannot transfer ERC1155 fungible tokens",
  "Content": "\n<https://github.com/code-423n4/2023-05-party/blob/f6f80dde81d86e397ba4f3dedb561e23d58ec884/contracts/party/PartyGovernanceNFT.sol#L332-L345>\n\nRage quitter loses his ERC1155 fungible tokens.\n\n### Proof of Concept\n\n`PartyGovernanceNFT` is PartyGovernance which is an `ERC1155Receiver`. But `rageQuit()` only sends ETH, with `call()`, and ERC20-tokens, with `transfer()`. ERC1155-tokens are transferred by `safeTransferFrom()` and its `balanceOf()`also takes an `uint256 _id` parameter. This means that the rage quitter cannot withdraw any of his fair share of ERC1155 fungible tokens.\n\n### Recommended Mitigation Steps\n\nInclude support for ERC1155 in `rageQuit()`.\n\n**[0xble (Party) acknowledged and commented](https://github.com/code-423n4/2023-05-party-findings/issues/23):**\n\n >This is by design, feel like this should be a QA.\n > \n >ERC1155 tokens are tricky because they sometimes behave like NFTs and other times like ERC20s. If they are not fungible, they shouldn't be allowed to be taken out of the treasury during rage quit so that makes allowing them to be rage-quitted dependent on how the 1155 is implemented.\n\n**[d3e4 (warden) commented](https://github.com/code-423n4/2023-05-party-findings/issues/23):**\n > @0xble - If the ERC1155 is non-fungible, the contract will only own a single token. Any share less than the whole will be rounded down to zero tokens sent when rage quitting. The same calculation can be used for ERC1155 tokens as for ERC20 tokens, without having to explicitly consider whether they are fungible or not.\n\n**[cccz (judge) increased severity to Medium and commented](https://github.com/code-423n4/2023-05-party-findings/issues/23):**\n > I would say this is an undocumented value leakage issue, the contract is designed to receive ERC1155, and the documentation says the user can withdraw fungible tokens on rage quit.\n\n**[0xble (Party) commented](https://github.com/code-423n4/2023-05-party-findings/issues/23):**\n > ERC1155s aren't always fungible and we knew this when designing it. Sometimes they behave like ERC20s and other times as ERC721s. If it was the latter, it would lead to a loss of funds.\n\n**[cccz (judge) commented](https://github.com/code-423n4/2023-05-party-findings/issues/23):**\n > Agree with you, but a value leak does exist here that meets the C4 medium risk criteria. And the following suggestion I think is appropriate:\n >\n >>ERC1155 tokens are tricky because they sometimes behave like NFTs and other times like ERC20s. If they are not fungible, they shouldn't be allowed to be taken out of the treasury during rage quit so that makes allowing them to be rage-quitted dependent on how the 1155 is implemented.\n >>\n >>If the ERC1155 is non-fungible the contract will only own a single token, so any share less than the whole will be rounded down to zero tokens sent when rage quitting. So exactly the same calculation can be used for ERC1155 tokens as for ERC20 tokens, without having to explicitly consider whether they are fungible or not.\n\n*Note: for full discussion, see [here](https://github.com/code-423n4/2023-05-party-findings/issues/23).*\n\n***\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-05-party",
  "Code": [
    {
      "filename": "contracts/party/PartyGovernanceNFT.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.20;\n\nimport \"../utils/ReadOnlyDelegateCall.sol\";\nimport \"../utils/LibSafeCast.sol\";\nimport \"../utils/LibAddress.sol\";\nimport \"openzeppelin/contracts/interfaces/IERC2981.sol\";\nimport \"../globals/IGlobals.sol\";\nimport \"../tokens/IERC721.sol\";\nimport \"../vendor/solmate/ERC721.sol\";\nimport \"./PartyGovernance.sol\";\nimport \"../renderers/RendererStorage.sol\";\n\n/// @notice ERC721 functionality built on top of `PartyGovernance`.\ncontract PartyGovernanceNFT is PartyGovernance, ERC721, IERC2981 {\n    using LibSafeCast for uint256;\n    using LibSafeCast for uint96;\n    using LibERC20Compat for IERC20;\n    using LibAddress for address payable;\n\n    error OnlyAuthorityError();\n    error OnlySelfError();\n    error UnauthorizedToBurnError();\n    error FixedRageQuitTimestampError(uint40 rageQuitTimestamp);\n    error CannotRageQuitError(uint40 rageQuitTimestamp);\n    error CannotDisableRageQuitAfterInitializationError();\n    error InvalidTokenOrderError();\n\n    event AuthorityAdded(address indexed authority);\n    event AuthorityRemoved(address indexed authority);\n    event RageQuitSet(uint40 oldRageQuitTimestamp, uint40 newRageQuitTimestamp);\n    event RageQuit(uint256[] indexed tokenIds, IERC20[] withdrawTokens, address receiver);\n\n    uint40 private constant ENABLE_RAGEQUIT_PERMANENTLY = 0x6b5b567bfe; // uint40(uint256(keccak256(\"ENABLE_RAGEQUIT_PERMANENTLY\")))\n    uint40 private constant DISABLE_RAGEQUIT_PERMANENTLY = 0xab2cb21860; // uint40(uint256(keccak256(\"DISABLE_RAGEQUIT_PERMANENTLY\")))\n\n    // Token address used to indicate ETH.\n    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    // The `Globals` contract storing global configuration values. This contract\n    // is immutable and its address will never change.\n    IGlobals private immutable _GLOBALS;\n\n    /// @notice The number of tokens that have been minted.\n    uint96 public tokenCount;\n    /// @notice The total minted voting power.\n    ///         Capped to `_governanceValues.totalVotingPower` unless minting\n    ///         party cards for initial crowdfund.\n    uint96 public mintedVotingPower;\n    /// @notice The timestamp until which ragequit is enabled. Can be set to the\n    ///         `ENABLE_RAGEQUIT_PERMANENTLY`/`DISABLE_RAGEQUIT_PERMANENTLY`\n    ///         values to enable/disable ragequit permanently.\n    ///         `DISABLE_RAGEQUIT_PERMANENTLY` can only be set during\n    ///         initialization.\n    uint40 public rageQuitTimestamp;\n    /// @notice The voting power of `tokenId`.\n    mapping(uint256 => uint256) public votingPowerByTokenId;\n    /// @notice Address with authority to mint cards and update voting power for the party.\n    mapping(address => bool) public isAuthority;\n\n    modifier onlyAuthority() {\n        if (!isAuthority[msg.sender]) {\n            revert OnlyAuthorityError();\n        }\n        _;\n    }\n\n    modifier onlySelf() {\n        if (msg.sender != address(this)) {\n            revert OnlySelfError();\n        }\n        _;\n    }\n\n    // Set the `Globals` contract. The name or symbol of ERC721 does not matter;\n    // it will be set in `_initialize()`.\n    constructor(IGlobals globals) payable PartyGovernance(globals) ERC721(\"\", \"\") {\n        _GLOBALS = globals;\n    }\n\n    // Initialize storage for proxy contracts.\n    function _initialize(\n        string memory name_,\n        string memory symbol_,\n        uint256 customizationPresetId,\n        PartyGovernance.GovernanceOpts memory governanceOpts,\n        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,\n        IERC721[] memory preciousTokens,\n        uint256[] memory preciousTokenIds,\n        address[] memory authorities,\n        uint40 rageQuitTimestamp_\n    ) internal {\n        PartyGovernance._initialize(\n            governanceOpts,\n            proposalEngineOpts,\n            preciousTokens,\n            preciousTokenIds\n        );\n        name = name_;\n        symbol = symbol_;\n        rageQuitTimestamp = rageQuitTimestamp_;\n        unchecked {\n            for (uint256 i; i < authorities.length; ++i) {\n                isAuthority[authorities[i]] = true;\n            }\n        }\n        if (customizationPresetId != 0) {\n            RendererStorage(_GLOBALS.getAddress(LibGlobals.GLOBAL_RENDERER_STORAGE))\n                .useCustomizationPreset(customizationPresetId);\n        }\n    }\n\n    /// @inheritdoc ERC721\n    function ownerOf(\n        uint256 tokenId\n    ) public view override(ERC721, ITokenDistributorParty) returns (address owner) {\n        return ERC721.ownerOf(tokenId);\n    }\n\n    /// @inheritdoc EIP165\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public pure override(PartyGovernance, ERC721, IERC165) returns (bool) {\n        return\n            PartyGovernance.supportsInterface(interfaceId) ||\n            ERC721.supportsInterface(interfaceId) ||\n            interfaceId == type(IERC2981).interfaceId;\n    }\n\n    /// @inheritdoc ERC721\n    function tokenURI(uint256) public view override returns (string memory) {\n        _delegateToRenderer();\n        return \"\"; // Just to make the compiler happy.\n    }\n\n    /// @notice Returns a URI for the storefront-level metadata for your contract.\n    function contractURI() external view returns (string memory) {\n        _delegateToRenderer();\n        return \"\"; // Just to make the compiler happy.\n    }\n\n    /// @notice Called with the sale price to determine how much royalty\n    //          is owed and to whom.\n    function royaltyInfo(uint256, uint256) external view returns (address, uint256) {\n        _delegateToRenderer();\n        return (address(0), 0); // Just to make the compiler happy.\n    }\n\n    /// @inheritdoc ITokenDistributorParty\n    function getDistributionShareOf(uint256 tokenId) public view returns (uint256) {\n        uint256 totalVotingPower = _governanceValues.totalVotingPower;\n\n        if (totalVotingPower == 0) {\n            return 0;\n        } else {\n            return (votingPowerByTokenId[tokenId] * 1e18) / totalVotingPower;\n        }\n    }\n\n    /// @notice Mint a governance NFT for `owner` with `votingPower` and\n    ///         immediately delegate voting power to `delegate.` Only callable\n    ///         by an authority.\n    /// @param owner The owner of the NFT.\n    /// @param votingPower The voting power of the NFT.\n    /// @param delegate The address to delegate voting power to.\n    function mint(\n        address owner,\n        uint256 votingPower,\n        address delegate\n    ) external onlyAuthority onlyDelegateCall returns (uint256 tokenId) {\n        uint96 mintedVotingPower_ = mintedVotingPower;\n        uint96 totalVotingPower = _governanceValues.totalVotingPower;\n\n        // Cap voting power to remaining unminted voting power supply.\n        uint96 votingPower_ = votingPower.safeCastUint256ToUint96();\n        // Allow minting past total voting power if minting party cards for\n        // initial crowdfund when there is no total voting power.\n        if (totalVotingPower != 0 && totalVotingPower - mintedVotingPower_ < votingPower_) {\n            votingPower_ = totalVotingPower - mintedVotingPower_;\n        }\n\n        // Update state.\n        unchecked {\n            tokenId = ++tokenCount;\n        }\n        mintedVotingPower += votingPower_;\n        votingPowerByTokenId[tokenId] = votingPower_;\n\n        // Use delegate from party over the one set during crowdfund.\n        address delegate_ = delegationsByVoter[owner];\n        if (delegate_ != address(0)) {\n            delegate = delegate_;\n        }\n\n        _adjustVotingPower(owner, votingPower_.safeCastUint96ToInt192(), delegate);\n        _safeMint(owner, tokenId);\n    }\n\n    /// @notice Add voting power to an existing NFT. Only callable by an\n    ///         authority.\n    /// @param tokenId The ID of the NFT to add voting power to.\n    /// @param votingPower The amount of voting power to add.\n    function addVotingPower(\n        uint256 tokenId,\n        uint256 votingPower\n    ) external onlyAuthority onlyDelegateCall {\n        uint96 mintedVotingPower_ = mintedVotingPower;\n        uint96 totalVotingPower = _governanceValues.totalVotingPower;\n        // Cap voting power to remaining unminted voting power supply.\n        uint96 votingPower_ = votingPower.safeCastUint256ToUint96();\n        // Allow minting past total voting power if minting party cards for\n        // initial crowdfund when there is no total voting power.\n        if (totalVotingPower != 0 && totalVotingPower - mintedVotingPower_ < votingPower_) {\n            votingPower_ = totalVotingPower - mintedVotingPower_;\n        }\n\n        // Update state.\n        mintedVotingPower += votingPower_;\n        votingPowerByTokenId[tokenId] += votingPower_;\n\n        _adjustVotingPower(ownerOf(tokenId), votingPower_.safeCastUint96ToInt192(), address(0));\n    }\n\n    /// @notice Update the total voting power of the party. Only callable by\n    ///         an authority.\n    /// @param newVotingPower The new total voting power to add.\n    function increaseTotalVotingPower(\n        uint96 newVotingPower\n    ) external onlyAuthority onlyDelegateCall {\n        _governanceValues.totalVotingPower += newVotingPower;\n    }\n\n    /// @notice Burn a governance NFT and remove its voting power.\n    /// @param tokenId The ID of the NFT to burn.\n    function burn(uint256 tokenId) public onlyDelegateCall {\n        address owner = ownerOf(tokenId);\n        uint96 totalVotingPower = _governanceValues.totalVotingPower;\n        bool authority = isAuthority[msg.sender];\n        if (\n            msg.sender != owner &&\n            getApproved[tokenId] != msg.sender &&\n            !isApprovedForAll[owner][msg.sender]\n        ) {\n            // Allow authority to burn cards if the total voting power has not yet\n            // been set (e.g. for initial crowdfunds) meaning the party has not\n            // yet started.\n            if (totalVotingPower != 0 || !authority) revert UnauthorizedToBurnError();\n        }\n\n        // Update last burn timestamp.\n        lastBurnTimestamp = uint40(block.timestamp);\n\n        uint96 votingPower = votingPowerByTokenId[tokenId].safeCastUint256ToUint96();\n        mintedVotingPower -= votingPower;\n        delete votingPowerByTokenId[tokenId];\n\n        if (totalVotingPower != 0) {\n            _governanceValues.totalVotingPower = totalVotingPower - votingPower;\n        } else {\n            if (!authority) revert OnlyAuthorityError();\n        }\n\n        _adjustVotingPower(owner, -votingPower.safeCastUint96ToInt192(), address(0));\n\n        _burn(tokenId);\n    }\n\n    /// @notice Set the timestamp until which ragequit is enabled.\n    /// @param newRageQuitTimestamp The new ragequit timestamp.\n    function setRageQuit(uint40 newRageQuitTimestamp) external onlyHost {\n        uint40 oldRageQuitTimestamp = rageQuitTimestamp;\n\n        // Prevent disabling ragequit after initialization.\n        if (newRageQuitTimestamp == DISABLE_RAGEQUIT_PERMANENTLY) {\n            revert CannotDisableRageQuitAfterInitializationError();\n        }\n\n        // Prevent setting timestamp if it is permanently enabled/disabled.\n        if (\n            oldRageQuitTimestamp == ENABLE_RAGEQUIT_PERMANENTLY ||\n            oldRageQuitTimestamp == DISABLE_RAGEQUIT_PERMANENTLY\n        ) {\n            revert FixedRageQuitTimestampError(oldRageQuitTimestamp);\n        }\n\n        emit RageQuitSet(oldRageQuitTimestamp, rageQuitTimestamp = newRageQuitTimestamp);\n    }\n\n    /// @notice Burn a governance NFT and withdraw a fair share of fungible tokens from the party.\n    /// @param tokenIds The IDs of the governance NFTs to burn.\n    /// @param withdrawTokens The fungible tokens to withdraw.\n    /// @param receiver The address to receive the withdrawn tokens.\n    function rageQuit(\n        uint256[] calldata tokenIds,\n        IERC20[] calldata withdrawTokens,\n        address receiver\n    ) external {\n        // Check if ragequit is allowed.\n        uint40 currentRageQuitTimestamp = rageQuitTimestamp;\n        if (currentRageQuitTimestamp != ENABLE_RAGEQUIT_PERMANENTLY) {\n            if (\n                currentRageQuitTimestamp == DISABLE_RAGEQUIT_PERMANENTLY ||\n                currentRageQuitTimestamp < block.timestamp\n            ) {\n                revert CannotRageQuitError(currentRageQuitTimestamp);\n            }\n        }\n\n        // Used as a reentrancy guard. Will be updated back after ragequit.\n        delete rageQuitTimestamp;\n\n        for (uint256 i; i < tokenIds.length; ++i) {\n            uint256 tokenId = tokenIds[i];\n\n            // Must be retrieved before burning the token.\n            uint256 shareOfVotingPower = getDistributionShareOf(tokenId);\n\n            // Burn caller's party card. This will revert if caller is not the owner\n            // of the card.\n            burn(tokenId);\n\n            // Withdraw fair share of tokens from the party.\n            IERC20 prevToken;\n            for (uint256 j; j < withdrawTokens.length; ++j) {\n                IERC20 token = withdrawTokens[j];\n\n                // Prevent null and duplicate transfers.\n                if (prevToken >= token) revert InvalidTokenOrderError();\n\n                prevToken = token;\n\n                // Check if token is ETH.\n                if (address(token) == ETH_ADDRESS) {\n                    // Transfer fair share of ETH to receiver.\n                    uint256 amount = (address(this).balance * shareOfVotingPower) / 1e18;\n                    if (amount != 0) {\n                        payable(receiver).transferEth(amount);\n                    }\n                } else {\n                    // Transfer fair share of tokens to receiver.\n                    uint256 amount = (token.balanceOf(address(this)) * shareOfVotingPower) / 1e18;\n                    if (amount != 0) {\n                        token.compatTransfer(receiver, amount);\n                    }\n                }\n            }\n        }\n\n        // Update ragequit timestamp back to before.\n        rageQuitTimestamp = currentRageQuitTimestamp;\n\n        emit RageQuit(tokenIds, withdrawTokens, receiver);\n    }\n\n    /// @inheritdoc ERC721\n    function transferFrom(\n        address owner,\n        address to,\n        uint256 tokenId\n    ) public override onlyDelegateCall {\n        // Transfer voting along with token.\n        _transferVotingPower(owner, to, votingPowerByTokenId[tokenId]);\n        super.transferFrom(owner, to, tokenId);\n    }\n\n    /// @inheritdoc ERC721\n    function safeTransferFrom(\n        address owner,\n        address to,\n        uint256 tokenId\n    ) public override onlyDelegateCall {\n        // super.safeTransferFrom() will call transferFrom() first which will\n        // transfer voting power.\n        super.safeTransferFrom(owner, to, tokenId);\n    }\n\n    /// @inheritdoc ERC721\n    function safeTransferFrom(\n        address owner,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) public override onlyDelegateCall {\n        // super.safeTransferFrom() will call transferFrom() first which will\n        // transfer voting power.\n        super.safeTransferFrom(owner, to, tokenId, data);\n    }\n\n    /// @notice Add a new authority.\n    /// @dev Used in `AddAuthorityProposal`. Only the party itself can add\n    ///      authorities to prevent it from being used anywhere else.\n    function addAuthority(address authority) external onlySelf onlyDelegateCall {\n        isAuthority[authority] = true;\n\n        emit AuthorityAdded(authority);\n    }\n\n    /// @notice Relinquish the authority role.\n    function abdicateAuthority() external onlyAuthority onlyDelegateCall {\n        delete isAuthority[msg.sender];\n\n        emit AuthorityRemoved(msg.sender);\n    }\n\n    function _delegateToRenderer() private view {\n        _readOnlyDelegateCall(\n            // Instance of IERC721Renderer.\n            _GLOBALS.getAddress(LibGlobals.GLOBAL_GOVERNANCE_NFT_RENDER_IMPL),\n            msg.data\n        );\n        assert(false); // Will not be reached.\n    }\n}"
    }
  ]
}