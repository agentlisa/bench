{
  "Title": "[N-10] Typos",
  "Content": "\n1.  File: contracts/interfaces/IAnatomyUpdater.sol (line [6](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/interfaces/IAnatomyUpdater.sol#L6))\n\n```solidity\n/// @notice Contains event for aatomy update\n```\n\naatomy\n\n2.  File: contracts/interfaces/IReweightableIndex.sol (line [5](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/interfaces/IReweightableIndex.sol#L5))\n\n```solidity\n/// @title Rewightable index interface\n```\n\nRewightable\n\n3.  File: contracts/libraries/FullMath.sol (line [101](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/libraries/FullMath.sol#L101))\n\n```solidity\n            // correct result modulo 2**256. Since the precoditions guarantee\n```\n\nprecoditions\n\n4.  File: contracts/vToken.sol (line [84](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/vToken.sol#L84))\n\nWhy is this one named `_shares` whereas the others are named `_amount`\n\n```solidity\n        uint _shares\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-04-phuture",
  "Code": [
    {
      "filename": "contracts/interfaces/IAnatomyUpdater.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity >=0.8.7;\n\n/// @title Anatomy Updater interface\n/// @notice Contains event for aatomy update\ninterface IAnatomyUpdater {\n    event UpdateAnatomy(address asset, uint8 weight);\n}"
    },
    {
      "filename": "contracts/interfaces/IReweightableIndex.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity >=0.8.7;\n\n/// @title Rewightable index interface\n/// @notice Contains reweighting logic\ninterface IReweightableIndex {\n    /// @notice Call index reweight process\n    function reweight() external;\n}"
    },
    {
      "filename": "contracts/libraries/FullMath.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4 <0.9.0;\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n    /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    function mulDiv(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = a * b\n            // Compute the product mod 2**256 and mod 2**256 - 1\n            // then use the Chinese Remainder Theorem to reconstruct\n            // the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2**256 + prod0\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(a, b, not(0))\n                prod0 := mul(a, b)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division\n            if (prod1 == 0) {\n                require(denominator > 0);\n                assembly {\n                    result := div(prod0, denominator)\n                }\n                return result;\n            }\n\n            // Make sure the result is less than 2**256.\n            // Also prevents denominator == 0\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0]\n            // Compute remainder using mulmod\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(a, b, denominator)\n            }\n            // Subtract 256 bit number from 512 bit number\n            assembly {\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator\n            // Compute largest power of two divisor of denominator.\n            // Always >= 1.\n            uint256 twos = (~denominator + 1) & denominator;\n            // Divide denominator by power of two\n            assembly {\n                denominator := div(denominator, twos)\n            }\n\n            // Divide [prod1 prod0] by the factors of two\n            assembly {\n                prod0 := div(prod0, twos)\n            }\n            // Shift in bits from prod1 into prod0. For this we need\n            // to flip `twos` such that it is 2**256 / twos.\n            // If twos is zero, then it becomes one\n            assembly {\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2**256\n            // Now that denominator is an odd number, it has an inverse\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n            // Compute the inverse by starting with a seed that is correct\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\n            uint256 inv = (3 * denominator) ^ 2;\n            // Now use Newton-Raphson iteration to improve the precision.\n            // Thanks to Hensel's lifting lemma, this also works in modular\n            // arithmetic, doubling the correct bits in each step.\n            inv *= 2 - denominator * inv; // inverse mod 2**8\n            inv *= 2 - denominator * inv; // inverse mod 2**16\n            inv *= 2 - denominator * inv; // inverse mod 2**32\n            inv *= 2 - denominator * inv; // inverse mod 2**64\n            inv *= 2 - denominator * inv; // inverse mod 2**128\n            inv *= 2 - denominator * inv; // inverse mod 2**256\n\n            // Because the division is now exact we can divide by multiplying\n            // with the modular inverse of denominator. This will give us the\n            // correct result modulo 2**256. Since the precoditions guarantee\n            // that the outcome is less than 2**256, this is the final result.\n            // We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inv;\n            return result;\n        }\n    }\n\n    /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    function mulDivRoundingUp(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            result = mulDiv(a, b, denominator);\n            if (mulmod(a, b, denominator) > 0) {\n                require(result < type(uint256).max);\n                result++;\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/vToken.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.8.7;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165CheckerUpgradeable.sol\";\n\nimport \"./libraries/BP.sol\";\nimport \"./libraries/NAV.sol\";\n\nimport \"./interfaces/IvToken.sol\";\nimport \"./interfaces/IIndexRegistry.sol\";\n\n/// @title Vault token\n/// @notice Contains logic for index's asset management\ncontract vToken is IvToken, Initializable, ReentrancyGuardUpgradeable, ERC165Upgradeable {\n    using NAV for NAV.Data;\n    using SafeERC20 for IERC20;\n    using ERC165CheckerUpgradeable for address;\n\n    /// @notice Index role\n    bytes32 private constant INDEX_ROLE = keccak256(\"INDEX_ROLE\");\n    /// @notice Oracle role\n    bytes32 private constant ORACLE_ROLE = keccak256(\"ORACLE_ROLE\");\n    /// @notice Orderer role\n    bytes32 private constant ORDERER_ROLE = keccak256(\"ORDERER_ROLE\");\n    /// @notice Role allows configure reserve related data/components\n    bytes32 private constant RESERVE_MANAGER_ROLE = keccak256(\"RESERVE_MANAGER_ROLE\");\n\n    /// @inheritdoc IvToken\n    address public override asset;\n    /// @inheritdoc IvToken\n    address public override registry;\n\n    /// @notice NAV library used to track contract shares between indexes\n    NAV.Data internal _NAV;\n\n    /// @notice Requires msg.sender to have `_role` role\n    /// @param _role Required role\n    modifier onlyRole(bytes32 _role) {\n        require(IAccessControl(registry).hasRole(_role, msg.sender), \"vToken: FORBIDDEN\");\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    /// @inheritdoc IvToken\n    /// @dev also sets initial values for public variables\n    function initialize(address _asset, address _registry) external override initializer {\n        bytes4[] memory interfaceIds = new bytes4[](2);\n        interfaceIds[0] = type(IAccessControl).interfaceId;\n        interfaceIds[1] = type(IIndexRegistry).interfaceId;\n        require(_registry.supportsAllInterfaces(interfaceIds), \"vToken: INTERFACE\");\n        require(_asset != address(0), \"vToken: ZERO\");\n\n        __ERC165_init();\n        __ReentrancyGuard_init();\n\n        asset = _asset;\n        registry = _registry;\n    }\n\n    /// @inheritdoc IvToken\n    function transferAsset(address _recipient, uint _amount) external override nonReentrant {\n        require(msg.sender == IIndexRegistry(registry).orderer(), \"vToken: FORBIDDEN\");\n        _transferAsset(_recipient, _amount);\n    }\n\n    /// @inheritdoc IvToken\n    function transfer(address _recipient, uint _amount) external override nonReentrant {\n        _transfer(msg.sender, _recipient, _amount);\n    }\n\n    /// @inheritdoc IvToken\n    function transferFrom(\n        address _from,\n        address _to,\n        uint _shares\n    ) external override nonReentrant onlyRole(ORDERER_ROLE) {\n        _transfer(_from, _to, _shares);\n    }\n\n    /// @inheritdoc IvToken\n    function mint() external override nonReentrant onlyRole(INDEX_ROLE) returns (uint shares) {\n        return _mint(msg.sender);\n    }\n\n    /// @inheritdoc IvToken\n    function burn(address _recipient) external override nonReentrant onlyRole(INDEX_ROLE) returns (uint amount) {\n        return _burn(_recipient);\n    }\n\n    /// @inheritdoc IvToken\n    function mintFor(address _recipient) external override nonReentrant onlyRole(ORDERER_ROLE) returns (uint) {\n        return _mint(_recipient);\n    }\n\n    /// @inheritdoc IvToken\n    function burnFor(address _recipient) external override nonReentrant onlyRole(ORDERER_ROLE) returns (uint) {\n        return _burn(_recipient);\n    }\n\n    /// @inheritdoc IvToken\n    function sync() external override nonReentrant {\n        _NAV.sync(totalAssetSupply());\n    }\n\n    /// @inheritdoc IvToken\n    function balanceOf(address _account) external view override returns (uint) {\n        return _NAV.balanceOf[_account];\n    }\n\n    /// @inheritdoc IvToken\n    function lastBalance() external view override returns (uint) {\n        return _NAV.lastBalance;\n    }\n\n    /// @inheritdoc IvToken\n    function mintableShares(uint _amount) external view override returns (uint) {\n        return _NAV.mintableShares(_amount);\n    }\n\n    /// @inheritdoc IvToken\n    function totalSupply() external view override returns (uint) {\n        return _NAV.totalSupply;\n    }\n\n    /// @inheritdoc IvToken\n    function lastAssetBalanceOf(address _account) external view override returns (uint) {\n        return _NAV.assetBalanceForShares(_NAV.balanceOf[_account], _NAV.lastBalance);\n    }\n\n    /// @inheritdoc IvToken\n    function assetBalanceOf(address _account) external view override returns (uint) {\n        return _NAV.assetBalanceForShares(_NAV.balanceOf[_account], totalAssetSupply());\n    }\n\n    /// @inheritdoc IvToken\n    function assetDataOf(address _account, uint _shares) external view override returns (AssetData memory) {\n        _shares = Math.min(_shares, _NAV.balanceOf[_account]);\n        uint amountInAsset = _NAV.assetBalanceForShares(_shares, totalAssetSupply());\n        return AssetData({ maxShares: _shares, amountInAsset: amountInAsset });\n    }\n\n    /// @inheritdoc IvToken\n    function shareChange(address _account, uint _amountInAsset)\n        external\n        view\n        override\n        returns (uint newShares, uint oldShares)\n    {\n        oldShares = _NAV.balanceOf[_account];\n        uint _totalSupply = _NAV.totalSupply;\n        if (_totalSupply > 0) {\n            uint _balance = _NAV.balanceOf[_account];\n            uint _assetBalance = totalAssetSupply();\n            uint availableAssets = (_balance * _assetBalance) / _totalSupply;\n            newShares = (_amountInAsset * (_totalSupply - oldShares)) / (_assetBalance - availableAssets);\n        } else {\n            newShares = _amountInAsset < NAV.INITIAL_QUANTITY ? 0 : _amountInAsset - NAV.INITIAL_QUANTITY;\n        }\n    }\n\n    /// @inheritdoc IvToken\n    function totalAssetSupply() public view override returns (uint) {\n        return IERC20(asset).balanceOf(address(this));\n    }\n\n    /// @inheritdoc ERC165Upgradeable\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return _interfaceId == type(IvToken).interfaceId || super.supportsInterface(_interfaceId);\n    }\n\n    /// @notice Mints shares to `_recipient` address\n    /// @param _recipient Shares recipient\n    /// @return shares Amount of minted shares\n    function _mint(address _recipient) internal returns (uint shares) {\n        uint _totalAssetSupply = totalAssetSupply();\n        shares = _NAV.mint(_totalAssetSupply, _recipient);\n        _NAV.sync(_totalAssetSupply);\n        emit VTokenTransfer(address(0), _recipient, shares);\n    }\n\n    /// @notice Burns shares from `_recipient` address\n    /// @param _recipient Recipient of assets from burnt shares\n    /// @return amount Amount of asset for burnt shares\n    function _burn(address _recipient) internal returns (uint amount) {\n        uint shares = _NAV.balanceOf[address(this)];\n        amount = _NAV.burn(totalAssetSupply());\n        _transferAsset(_recipient, amount);\n        _NAV.sync(totalAssetSupply());\n        emit VTokenTransfer(_recipient, address(0), shares);\n    }\n\n    /// @notice Transfers `_amount` of shares from one address to another\n    /// @param _from Address to transfer shares from\n    /// @param _to Address to transfer shares to\n    /// @param _amount Amount of shares to transfer\n    function _transfer(\n        address _from,\n        address _to,\n        uint _amount\n    ) internal {\n        _NAV.transfer(_from, _to, _amount);\n        emit VTokenTransfer(_from, _to, _amount);\n    }\n\n    /// @notice Transfers `_amount` of asset to `_recipient` address\n    /// @param _recipient Recipient of assets\n    /// @param _amount Amount of assets to transfer\n    function _transferAsset(address _recipient, uint _amount) internal {\n        uint balance = IERC20(asset).balanceOf(address(this));\n        IERC20(asset).safeTransfer(_recipient, Math.min(_amount, balance));\n    }\n\n    uint256[42] private __gap;\n}"
    }
  ]
}