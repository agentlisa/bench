{
  "Title": "H-1: Two Pyth prices can be used in the same transaction to attack the LP pools",
  "Content": "# Issue H-1: Two Pyth prices can be used in the same transaction to attack the LP pools \n\nSource: https://github.com/sherlock-audit/2024-02-perpetual-judging/issues/123 \n\nThe protocol has acknowledged this issue.\n\n## Found by \nBauer, IllIllI, PUSH0, jokr\n## Summary\n\nPyth oracles use a pull model, where the consumer of the price needs to provide a signed price from an offline provider. There are no guarantees that the price at the current time is the freshest price, which means an attacker can enter an LP position at one base price, and exit in another, all in the same transaction.\n\n\n## Vulnerability Detail\n\nThe OracleMaker and SpotHedgeBaseMaker both allow LPs to contribute funds in exchange for getting an LP position. Outside of the requirment that the current price is within the [maxAge](https://github.com/sherlock-audit/2024-02-perpetual/blob/main/perp-contract-v3/src/oracle/pythOracleAdapter/PythOracleAdapter.sol#L83), there are no other freshness checks. An attacker can create a contract which, given two signed base prices, calls [`updatePrice()`](https://github.com/sherlock-audit/2024-02-perpetual/blob/main/perp-contract-v3/src/oracle/pythOracleAdapter/PythOracleAdapter.sol#L51) and `deposit()`s at the lower price, then calls `updatePrice()` at the higher price, and calls `withdraw()` at the higher price, for a risk-free profit.\n\nFor both the OracleMaker and the SpotHedgeBaseMaker, there are no fees for doing `deposit()`/`withdraw()`, and a flash loan can be used to magnify the effect of any price difference between two oracle readings. While both makers support a having a whitelist for who is able to deposit/withdraw, the code [doesn't](https://github.com/sherlock-audit/2024-02-perpetual/blob/main/perp-contract-v3/src/maker/SpotHedgeBaseMaker.sol#L156) require one, the whitelist isn't mentioned in the contest readme, and the comments in [both](https://github.com/sherlock-audit/2024-02-perpetual/blob/main/perp-contract-v3/src/maker/SpotHedgeBaseMaker.sol#L270-L272) [makers](https://github.com/sherlock-audit/2024-02-perpetual/blob/main/perp-contract-v3/src/maker/OracleMaker.sol#L196-L198) anticipate having to deal with malicious LPs. It appears that the whitelist will be used to ensure [first-depositor inflation](https://github.com/sherlock-audit/2024-02-perpetual/blob/main/README.md?plain=1#L65) [attacks](https://duckduckgo.com/?q=ethereum+%22inflation+attack%22&ia=web) are mitigated until the pools contain sufficient capital.\n\nThe fact that there is a `maxAge` available does not prevent the issue, because Pyth updates are multiple times a second, whereas a block can only have one timestamp.\n\n\n## Impact\n\nValue accrual that should have gone to the existing LPs is siphoned off by the attacker.\n\n\n## Code Snippet\n\nThe number of shares given depends on whatever the most recently stored price is:\n```solidity\n// File: src/maker/OracleMaker.sol : OracleMaker.deposit()   #1\n\n189 @>             uint256 price = _getPrice();\n...    \n201 @>             uint256 vaultValueXShareDecimals = _getVaultValueSafe(vault, price).formatDecimals(\n202                    INTERNAL_DECIMALS,\n203                    shareDecimals\n204                );\n205                uint256 amountXShareDecimals = amountXCD.formatDecimals(collateralToken.decimals(), shareDecimals);\n206:@>             shares = (amountXShareDecimals * totalSupply()) / vaultValueXShareDecimals;\n```\nhttps://github.com/sherlock-audit/2024-02-perpetual/blob/main/perp-contract-v3/src/maker/OracleMaker.sol#L189-L206\n\n\nThe amount of collateral given back is based on whatever the most recently stored price is:\n```solidity\n// File: src/maker/OracleMaker.sol : OracleMaker.withdraw()   #2\n\n234            uint256 redeemedRatio = shares.divWad(totalSupply());\n...\n241            uint256 price = _getPrice();\n242 @>         uint256 vaultValue = _getVaultValueSafe(vault, price);\n243            IERC20Metadata collateralToken = IERC20Metadata(_getAsset());\n244 @>         uint256 withdrawnAmountXCD = vaultValue.mulWad(redeemedRatio).formatDecimals(\n245                INTERNAL_DECIMALS,\n246                collateralToken.decimals()\n247:           );\n```\nhttps://github.com/sherlock-audit/2024-02-perpetual/blob/main/perp-contract-v3/src/maker/OracleMaker.sol#L234-L247\n\n\nThe SpotHedgeBaseMaker has the [same](https://github.com/sherlock-audit/2024-02-perpetual/blob/main/perp-contract-v3/src/maker/SpotHedgeBaseMaker.sol#L274-L283) [issue](https://github.com/sherlock-audit/2024-02-perpetual/blob/main/perp-contract-v3/src/maker/SpotHedgeBaseMaker.sol#L320-L325).\n\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nRequire that LP deposits and withdrawals be done by the trusted relayers\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  The readMe says : \"Oracle (Pyth) is expected to accurately report the price of market\"\n\n\n\n**IllIllI000**\n\nThe [PR](https://github.com/perpetual-protocol/perp-contract-v3/pull/4/files) is unrelated to the issue and the issue is not addressed by any other PRs. The PR instead increases the precision of the LP shares-related calculations. The sponsor acknowledges that the submitted issue is not addressed. The sponsor plans to address the issue prior to changing from allowlisted LPs to permissionless ones.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/219",
  "Code": [
    {
      "filename": "perp-contract-v3/src/oracle/pythOracleAdapter/PythOracleAdapter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.0;\n\nimport { Ownable2Step, Ownable } from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport { IPyth } from \"pyth-sdk-solidity/IPyth.sol\";\nimport { AbstractPyth } from \"pyth-sdk-solidity/AbstractPyth.sol\";\nimport { PythStructs } from \"pyth-sdk-solidity/PythStructs.sol\";\nimport { IPythOracleAdapter } from \"./IPythOracleAdapter.sol\";\nimport { INTERNAL_DECIMALS } from \"../../common/LibConstant.sol\";\nimport { LibError } from \"../../common/LibError.sol\";\n\ncontract PythOracleAdapter is IPythOracleAdapter, Ownable2Step {\n    IPyth internal _pyth;\n    uint256 internal _maxPriceAge;\n\n    /// @notice Price outside of the adapter's acceptance range (ex. negative price, extreme decimals, etc.)\n    error IllegalPrice(PythStructs.Price price);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address pyth_) Ownable(msg.sender) {\n        _pyth = IPyth(pyth_);\n        _setMaxPriceAge(60);\n    }\n\n    function depositOracleFee() external payable {\n        emit OracleFeeDeposited(_msgSender(), msg.value);\n    }\n\n    function withdrawOracleFee() external onlyOwner {\n        // get the amount of Ether stored in this contract\n        uint256 amount = address(this).balance;\n\n        // send all Ether to owner\n        (bool success, ) = payable(owner()).call{ value: amount }(\"\");\n        if (!success) revert LibError.WithdrawOracleFeeFailed(amount);\n\n        emit OracleFeeWithdrawn(owner(), amount);\n    }\n\n    function setMaxPriceAge(uint256 maxPriceAge) external onlyOwner {\n        _setMaxPriceAge(maxPriceAge);\n    }\n\n    function _setMaxPriceAge(uint256 maxPriceAge) internal {\n        uint256 oldMaxPriceAge = _maxPriceAge;\n        _maxPriceAge = maxPriceAge;\n        emit MaxPriceAgeSet(maxPriceAge, oldMaxPriceAge);\n    }\n\n    /// @inheritdoc IPythOracleAdapter\n    function updatePrice(bytes32 priceFeedId, bytes memory signedData) external {\n        if (!priceFeedExists(priceFeedId)) revert LibError.IllegalPriceFeed(priceFeedId);\n\n        // Assume we always update only one oracle.\n        bytes[] memory pythUpdateData = new bytes[](1);\n        pythUpdateData[0] = signedData;\n\n        // Get fee amount to pay to Pyth\n        uint256 fee = _pyth.getUpdateFee(pythUpdateData);\n        uint256 balance = address(this).balance;\n        if (balance < fee) revert LibError.OracleFeeRequired(fee);\n\n        _pyth.updatePriceFeeds{ value: fee }(pythUpdateData);\n    }\n\n    function getPyth() external view returns (address) {\n        return address(_pyth);\n    }\n\n    //\n    // PUBLIC VIEW\n    //\n\n    /// @inheritdoc IPythOracleAdapter\n    function priceFeedExists(bytes32 priceFeedId) public view returns (bool) {\n        return AbstractPyth(address(_pyth)).priceFeedExists(priceFeedId);\n    }\n\n    /// @inheritdoc IPythOracleAdapter\n    function getPrice(bytes32 priceFeedId) public view returns (uint256, uint256) {\n        // We don't use pyth.getPrice(), so we can control when to revert with _maxPriceAge,\n        // reverted with StalePrice if price.publishTime exceeds _maxPriceAge\n        try _pyth.getPriceNoOlderThan(priceFeedId, _maxPriceAge) returns (PythStructs.Price memory price) {\n            // Assumes base price is against quote\n            return (_convertToUint256(price), price.publishTime);\n        } catch (bytes memory reason) {\n            revert LibError.OracleDataRequired(priceFeedId, reason);\n        }\n    }\n\n    function getMaxPriceAge() external view returns (uint256) {\n        return _maxPriceAge;\n    }\n\n    //\n    // INTERNAL PURE\n    //\n\n    function _convertToUint256(PythStructs.Price memory pythPrice) internal pure returns (uint256) {\n        // Remember to update the conversion formula below accordingly if you have changed the conditions.\n        // Note both calculations below rely on the conditions here to prevent from overflow.\n        // Be sure to double check if you change the conditions.\n        if (pythPrice.price < 0 || pythPrice.expo > 0 || pythPrice.expo < -int8(INTERNAL_DECIMALS))\n            revert IllegalPrice(pythPrice);\n\n        // .price = 181803\n        // .expo = -2\n        // decimal price = 181803 * 10^(-2) =  1818.03\n        // converted price = 181803 * 10^(18 - 2) = 1.81803e21\n\n        uint256 baseConversion = 10 ** uint256(int256(int8(INTERNAL_DECIMALS)) + pythPrice.expo);\n\n        return uint256(int256(pythPrice.price)) * baseConversion;\n    }\n}"
    },
    {
      "filename": "perp-contract-v3/src/maker/SpotHedgeBaseMaker.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.0;\n\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n// solhint-disable-next-line max-line-length\nimport { Ownable2StepUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\n// solhint-disable-next-line max-line-length\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { FixedPointMathLib } from \"solady/src/utils/FixedPointMathLib.sol\";\nimport { IAddressManager } from \"../addressManager/IAddressManager.sol\";\nimport { AddressResolverUpgradeable } from \"../addressResolver/AddressResolverUpgradeable.sol\";\nimport { LibAddressResolver } from \"../addressResolver/LibAddressResolver.sol\";\nimport { INTERNAL_DECIMALS, WAD } from \"../common/LibConstant.sol\";\nimport { IMaker } from \"./IMaker.sol\";\nimport { IVault } from \"../vault/IVault.sol\";\nimport { IUniswapV3Factory } from \"../external/uniswap-v3-core/contracts/interfaces/IUniswapV3Factory.sol\";\nimport { ISwapRouter } from \"../external/uniswap-v3-periphery/contracts/interfaces/ISwapRouter.sol\";\nimport { IQuoter } from \"../external/uniswap-v3-periphery/contracts/interfaces/IQuoter.sol\";\nimport { Path } from \"../external/uniswap-v3-periphery/contracts/libraries/Path.sol\";\nimport { BytesLib } from \"../external/uniswap-v3-periphery/contracts/libraries/BytesLib.sol\";\nimport { LibFormatter } from \"../common/LibFormatter.sol\";\nimport { LibError } from \"../common/LibError.sol\";\nimport { ContextBase } from \"../common/ContextBase.sol\";\nimport { IWhitelistLpManager } from \"./IWhitelistLpManager.sol\";\n\ncontract SpotHedgeBaseMaker is\n    ContextBase,\n    AddressResolverUpgradeable,\n    Ownable2StepUpgradeable,\n    ERC20Upgradeable,\n    IMaker\n{\n    using SafeERC20 for IERC20Metadata;\n    using BytesLib for bytes;\n    using Path for bytes;\n    using SafeCast for int256;\n    using SafeCast for uint256;\n    using LibFormatter for uint256;\n    using LibFormatter for int256;\n    using FixedPointMathLib for uint256;\n    using LibAddressResolver for IAddressManager;\n\n    //\n    // STRUCT\n    //\n\n    /// @custom:storage-location erc7201:perp.storage.spotHedgeBaseMaker\n    struct SpotHedgeBaseMakerStorage {\n        uint256 marketId;\n        IERC20Metadata baseToken;\n        IERC20Metadata quoteToken;\n        uint8 baseTokenDecimals;\n        uint8 quoteTokenDecimals;\n        // UniswapV3 related\n        ISwapRouter uniswapV3Router;\n        IUniswapV3Factory uniswapV3Factory;\n        IQuoter uniswapV3Quoter;\n        // Key is a function of (tokenIn, tokenOut).\n        // However, note that since Uniswap's SwapRouter.exactOutput() takes path in reversed order,\n        // one should switch the key's tokenIn and tokenOut when querying paths for exactOutput calls.\n        mapping(bytes32 => bytes) uniswapV3PathMap;\n        // Internal ledger\n        uint256 baseTokenLiability;\n        uint256 minMarginRatio; // Min. marign ratio required by the maker at all time.\n    }\n\n    struct UniswapV3ExactInputParams {\n        address tokenIn;\n        address tokenOut;\n        bytes path;\n        address recipient;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    struct UniswapV3ExactOutputParams {\n        address tokenIn;\n        address tokenOut;\n        bytes path;\n        address recipient;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    struct FillOrderCallbackData {\n        bool isBaseToQuote;\n        bool isExactInput;\n        uint256 amountXSpotDecimals;\n        uint256 oppositeAmountXSpotDecimals;\n    }\n\n    //\n    // Event\n    //\n\n    event Deposited(\n        address depositor,\n        uint256 shares, // Amount of share minted\n        uint256 underlying // Amount of underlying token deposited\n    );\n\n    event Withdrawn(\n        address withdrawer,\n        uint256 shares, // Amount of shares burnt\n        uint256 baseAmount, // Amount of base tokens withdrawn from maker contract\n        uint256 quoteAmount // Amount of quote tokens withdrawn from maker's Perp position\n    );\n\n    event UniswapV3RouterSet(address newUniswapV3Router, address oldUniswapV3Router);\n    event UniswapV3FactorySet(address newUniswapV3Factory, address oldUniswapV3Factory);\n    event UniswapV3QuoterSet(address newUniswapV3Quoter, address oldUniswapV3Quoter);\n\n    // solhint-disable-next-line max-line-length\n    // Forked from https://github.com/perpetual-protocol/kantaban-contract/blob/18e0c1fe16490ccc9cbf0d9514e2204964f31624/contracts/interface/IRouterEvent.sol#L6-L13\n    /**\n     * @dev Emitted when UniswapV3 multihop path of tokenIn/tokenOut pair is changed\n     * @param tokenIn The address of tokenIn\n     * @param tokenOut The address of tokenOut\n     * @param oldPath The old UniswapV3 multihop path\n     * @param newPath The new UniswapV3 multihop path\n     */\n    event UniswapV3PathSet(address tokenIn, address tokenOut, bytes newPath, bytes oldPath);\n\n    event MinMarginRatioSet(uint256 newMinMarginRatio, uint256 oldMinMarginRatio);\n\n    event SHMOrderFilled(\n        uint256 marketId,\n        bytes path,\n        bool isBaseToQuote,\n        bool isExactInput,\n        uint256 targetAmount, // in INTERNAL_DECIMALS\n        uint256 oppositeAmount, // in INTERNAL_DECIMALS\n        uint256 spread // In percentage (1e6 = 100%)\n    );\n\n    //\n    // STATE\n    //\n\n    // keccak256(abi.encode(uint256(keccak256(\"perp.storage.spotHedgeBaseMaker\")) - 1)) & ~bytes32(uint256(0xff));\n    bytes32 constant _SPOT_HEDGE_BASE_MAKER_STORAGE_LOCATION =\n        0xaa0ea57ca6018b18cb09d20625ac40a68ba646a22caa4398d37ac2dfe2dc7500;\n\n    //\n    // MODIFIER\n    //\n    modifier onlyClearingHouse() {\n        if (msg.sender != address(getAddressManager().getClearingHouse())) revert LibError.Unauthorized();\n        _;\n    }\n\n    modifier onlyWhitelistLp() {\n        IWhitelistLpManager whitelistManager = getAddressManager().getWhitelistLpManager();\n        if (address(whitelistManager) != address(0)) {\n            if (!whitelistManager.isLpWhitelisted(_sender())) revert LibError.Unauthorized();\n        }\n        _;\n    }\n\n    //\n    // EXTERNAL NON-VIEW\n    //\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        uint256 marketId_,\n        string memory name_,\n        string memory symbol_,\n        address addressManager_,\n        address uniswapV3Router_,\n        address uniswapV3Factory_,\n        address uniswapV3Quoter_,\n        address baseToken_,\n        uint256 minMarginRatio_\n    ) external initializer {\n        __AddressResolver_init(addressManager_);\n        __Ownable2Step_init();\n        __Ownable_init(msg.sender);\n        __ERC20_init(name_, symbol_);\n\n        SpotHedgeBaseMakerStorage storage $ = _getSpotHedgeBaseMakerStorage();\n\n        $.marketId = marketId_;\n\n        setUniswapV3Router(uniswapV3Router_);\n        setUniswapV3Factory(uniswapV3Factory_);\n        setUniswapV3Quoter(uniswapV3Quoter_);\n\n        $.baseToken = IERC20Metadata(baseToken_);\n        $.baseTokenDecimals = IERC20Metadata($.baseToken).decimals();\n        $.quoteToken = IERC20Metadata(_getVault().getCollateralToken());\n        $.quoteTokenDecimals = IERC20Metadata($.quoteToken).decimals();\n\n        setMinMarginRatio(minMarginRatio_);\n    }\n\n    function setUniswapV3Router(address _uniswapV3Router) public onlyOwner {\n        if (_uniswapV3Router == address(0)) revert LibError.ZeroAddress();\n\n        address oldUniswapV3Router = address(_getSpotHedgeBaseMakerStorage().uniswapV3Router);\n        _getSpotHedgeBaseMakerStorage().uniswapV3Router = ISwapRouter(_uniswapV3Router);\n\n        emit UniswapV3RouterSet(_uniswapV3Router, oldUniswapV3Router);\n    }\n\n    function setUniswapV3Factory(address _uniswapV3Factory) public onlyOwner {\n        if (_uniswapV3Factory == address(0)) revert LibError.ZeroAddress();\n\n        address oldUniswapV3Factory = address(_getSpotHedgeBaseMakerStorage().uniswapV3Factory);\n        _getSpotHedgeBaseMakerStorage().uniswapV3Factory = IUniswapV3Factory(_uniswapV3Factory);\n\n        emit UniswapV3FactorySet(_uniswapV3Factory, oldUniswapV3Factory);\n    }\n\n    function setUniswapV3Quoter(address _uniswapV3Quoter) public onlyOwner {\n        if (_uniswapV3Quoter == address(0)) revert LibError.ZeroAddress();\n\n        address oldUniswapV3Quoter = address(_getSpotHedgeBaseMakerStorage().uniswapV3Quoter);\n        _getSpotHedgeBaseMakerStorage().uniswapV3Quoter = IQuoter(_uniswapV3Quoter);\n\n        emit UniswapV3QuoterSet(_uniswapV3Quoter, oldUniswapV3Quoter);\n    }\n\n    // solhint-disable-next-line max-line-length\n    // Forked from https://github.com/perpetual-protocol/kantaban-contract/blob/18e0c1fe16490ccc9cbf0d9514e2204964f31624/contracts/Router.sol#L33-L45\n    function setUniswapV3Path(address tokenIn, address tokenOut, bytes calldata path) external onlyOwner {\n        _verifyPath(tokenIn, tokenOut, path);\n\n        bytes32 key = _getKey(tokenIn, tokenOut);\n        bytes memory oldPath = _getSpotHedgeBaseMakerStorage().uniswapV3PathMap[key];\n        _getSpotHedgeBaseMakerStorage().uniswapV3PathMap[key] = path;\n\n        emit UniswapV3PathSet(tokenIn, tokenOut, path, oldPath);\n    }\n\n    function setMinMarginRatio(uint256 _minMarginRatio) public onlyOwner {\n        if (_minMarginRatio > WAD) {\n            revert LibError.InvalidRatio(_minMarginRatio);\n        }\n        if (_minMarginRatio == 0) {\n            revert LibError.ZeroRatio();\n        }\n        uint256 oldMinMarginRatio = _getSpotHedgeBaseMakerStorage().minMarginRatio;\n        _getSpotHedgeBaseMakerStorage().minMarginRatio = _minMarginRatio;\n\n        emit MinMarginRatioSet(_minMarginRatio, oldMinMarginRatio);\n    }\n\n    function deposit(uint256 amountXBD) external onlyWhitelistLp returns (uint256) {\n        address lp = _sender();\n        address maker = address(this);\n\n        if (amountXBD == 0) revert LibError.ZeroAmount();\n\n        uint256 shares;\n        if (totalSupply() == 0) {\n            shares = amountXBD;\n        } else {\n            // TODO Should consider slippage once maker has spread or other pricing logic.\n            // For now, we will just get account value from ClearingHouse (assume no slippages).\n            // shares per asset = share (share token precision) / (accountValue (INTERNAL_DECIMALS) / basePrice (pyth precision) + baseBalance (base token precision))\n            // shares (share token precision) =  assets (base token precision) * shares per asset\n\n            // TODO: We should add protections to prevent attackers from manipulating the share price by manipulating oracle reported price.\n            // This is because the attacker could potentially mint large amount of shares by forcing the share price low.\n            // Possible protections like rate limiting share price, or any kind of volatility check.\n\n            uint8 shareDecimals = decimals();\n            uint256 vaultValueInBaseXShareDecimals = _getVaultValueInBaseSafe(_getVault(), _getPrice()).formatDecimals(\n                INTERNAL_DECIMALS,\n                shareDecimals\n            );\n\n            shares =\n                (amountXBD.formatDecimals(_getSpotHedgeBaseMakerStorage().baseTokenDecimals, shareDecimals) *\n                    totalSupply()) /\n                vaultValueInBaseXShareDecimals;\n        }\n\n        uint256 balanceBefore = _getSpotHedgeBaseMakerStorage().baseToken.balanceOf(maker);\n        _getSpotHedgeBaseMakerStorage().baseToken.safeTransferFrom(_sender(), maker, amountXBD);\n        uint256 transferredAmount = _getSpotHedgeBaseMakerStorage().baseToken.balanceOf(maker) - balanceBefore;\n\n        if (transferredAmount != amountXBD) {\n            revert LibError.WrongTransferAmount(transferredAmount, amountXBD);\n        }\n\n        _getSpotHedgeBaseMakerStorage().baseTokenLiability += amountXBD;\n\n        _mint(lp, shares);\n\n        emit Deposited(lp, shares, amountXBD);\n\n        return shares;\n    }\n\n    function withdraw(uint256 shares) external onlyWhitelistLp returns (uint256 baseAmount, uint256 quoteAmount) {\n        address lp = _sender();\n        address maker = address(this);\n        IVault vault = _getVault();\n\n        if (shares == 0) revert LibError.ZeroAmount();\n\n        // Must done before burn.\n        uint256 redeemedRatio = shares.divWad(totalSupply()); // in ratio decimals 18\n\n        // Revert early if shares amount exceeds balance\n        _burn(lp, shares);\n\n        _getSpotHedgeBaseMakerStorage().baseTokenLiability -= _getSpotHedgeBaseMakerStorage().baseTokenLiability.mulWad(\n            redeemedRatio\n        );\n\n        uint256 price = _getPrice();\n        uint256 vaultValueInBase = _getVaultValueInBaseSafe(vault, price);\n        uint256 withdrawnBaseAmount = vaultValueInBase.mulWad(redeemedRatio).formatDecimals(\n            INTERNAL_DECIMALS,\n            _getSpotHedgeBaseMakerStorage().baseTokenDecimals\n        );\n\n        uint256 withdrawnQuoteAmount = 0;\n\n        uint256 spotBaseBalance = _getSpotHedgeBaseMakerStorage().baseToken.balanceOf(maker);\n\n        if (withdrawnBaseAmount > spotBaseBalance) {\n            if (vault.getPositionSize(_getSpotHedgeBaseMakerStorage().marketId, maker) != 0) {\n                revert LibError.NotEnoughSpotBaseTokens(withdrawnBaseAmount, spotBaseBalance);\n            } else {\n                withdrawnQuoteAmount = (withdrawnBaseAmount - spotBaseBalance).mulWad(price).formatDecimals(\n                    _getSpotHedgeBaseMakerStorage().baseTokenDecimals,\n                    _getSpotHedgeBaseMakerStorage().quoteTokenDecimals\n                );\n                withdrawnBaseAmount = FixedPointMathLib.min(withdrawnBaseAmount, spotBaseBalance);\n            }\n        }\n\n        if (withdrawnBaseAmount > 0) {\n            _getSpotHedgeBaseMakerStorage().baseToken.safeTransfer(lp, withdrawnBaseAmount);\n        }\n        if (withdrawnQuoteAmount > 0) {\n            // withdrawnQuoteAmount is calculated base on freeCollateral, and since all conversions are round-down,\n            // we can safely assume withdrawnQuoteAmount <= freeCollateral and the withdraw should always pass.\n            // It may not be possible to withdraw the required amount, due to unsettledPnl that cannot be settled totally.\n            _withdraw(vault, _getSpotHedgeBaseMakerStorage().marketId, withdrawnQuoteAmount);\n            _getSpotHedgeBaseMakerStorage().quoteToken.safeTransfer(lp, withdrawnQuoteAmount);\n        }\n\n        emit Withdrawn(lp, shares, withdrawnBaseAmount, withdrawnQuoteAmount);\n\n        return (withdrawnBaseAmount, withdrawnQuoteAmount);\n    }\n\n    function fillOrderCallback(bytes calldata _data) external onlyClearingHouse {\n        FillOrderCallbackData memory data = abi.decode(_data, (FillOrderCallbackData));\n        _fillOrderCallback(data);\n        _checkMinMarginRatio(_getPrice());\n    }\n\n    function fillOrder(\n        bool isBaseToQuote,\n        bool isExactInput,\n        uint256 amount,\n        bytes calldata\n    ) external onlyClearingHouse returns (uint256, bytes memory) {\n        IVault vault = _getVault();\n        uint256 _marketId = _getSpotHedgeBaseMakerStorage().marketId;\n        address maker = address(this);\n\n        // Taker perp - maker uniswap matrix:\n        //\n        //                      perp B->Q                   perp Q->B\n        // perp exact input     spot B->Q exact input       spot Q->B exact input\n        // perp exact output    spot B->Q exact output      spot Q->B exact output\n\n        FillOrderCallbackData memory fillOrderCallbackData = FillOrderCallbackData({\n            isBaseToQuote: isBaseToQuote,\n            isExactInput: isExactInput,\n            amountXSpotDecimals: 0, // TBD\n            oppositeAmountXSpotDecimals: 0 // TBD\n        });\n\n        uint256 oppositeAmount;\n        bytes memory path;\n        if (isBaseToQuote) {\n            uint256 quoteTokenAcquired = 0;\n            path = _getPath(\n                address(_getSpotHedgeBaseMakerStorage().baseToken),\n                address(_getSpotHedgeBaseMakerStorage().quoteToken),\n                isExactInput\n            );\n\n            if (isExactInput) {\n                uint256 baseTokenRequired = _formatPerpToSpotBaseDecimals(amount);\n                quoteTokenAcquired = _uniswapV3ExactInput(\n                    UniswapV3ExactInputParams({\n                        tokenIn: address(_getSpotHedgeBaseMakerStorage().baseToken),\n                        tokenOut: address(_getSpotHedgeBaseMakerStorage().quoteToken),\n                        path: path,\n                        recipient: maker,\n                        amountIn: baseTokenRequired,\n                        amountOutMinimum: 0\n                    })\n                );\n                oppositeAmount = _formatSpotToPerpQuoteDecimals(quoteTokenAcquired);\n                // Currently we don't utilize fillOrderCallback for B2Q swaps,\n                // but we still populate the arguments anyways.\n                fillOrderCallbackData.amountXSpotDecimals = baseTokenRequired;\n                fillOrderCallbackData.oppositeAmountXSpotDecimals = quoteTokenAcquired;\n            } else {\n                quoteTokenAcquired = _formatPerpToSpotQuoteDecimals(amount);\n                uint256 oppositeAmountXSpotDecimals = _uniswapV3ExactOutput(\n                    UniswapV3ExactOutputParams({\n                        tokenIn: address(_getSpotHedgeBaseMakerStorage().baseToken),\n                        tokenOut: address(_getSpotHedgeBaseMakerStorage().quoteToken),\n                        path: path,\n                        recipient: maker,\n                        amountOut: quoteTokenAcquired,\n                        amountInMaximum: _getSpotHedgeBaseMakerStorage().baseToken.balanceOf(maker)\n                    })\n                );\n                oppositeAmount = _formatSpotToPerpBaseDecimals(oppositeAmountXSpotDecimals);\n                // Currently we don't utilize fillOrderCallback for B2Q swaps,\n                // but we still populate the arguments anyways.\n                fillOrderCallbackData.amountXSpotDecimals = quoteTokenAcquired;\n                fillOrderCallbackData.oppositeAmountXSpotDecimals = oppositeAmountXSpotDecimals;\n            }\n\n            // Deposit the acquired quote tokens to Vault.\n            _deposit(vault, _marketId, quoteTokenAcquired);\n        } else {\n            // Note we only quote amountIn/Out here and do the swap later in callback.\n            // It is because we are not sure how much USDC the maker could withdraw yet,\n            // because there are potential PnL to be realized after fillOrder(), after the positions are settled,\n            // which may change the maker's free USDC. If we withdraw now, chances are the maker could fall below\n            // margin requirement after PnLs are realized, or the maker might not have enough USDC to\n            // withdraw yet unless we wait until the PnLs are realized.\n            // The best solution is to defer the withdrawal to the callback and withdraw only after\n            // the positions are settled and PnLs are realized.\n            path = _getPath(\n                address(_getSpotHedgeBaseMakerStorage().quoteToken),\n                address(_getSpotHedgeBaseMakerStorage().baseToken),\n                isExactInput\n            );\n\n            if (isExactInput) {\n                uint256 quoteTokenRequired = _formatPerpToSpotQuoteDecimals(amount);\n                // get quote\n                uint256 oppositeAmountXSpotDecimals = _getSpotHedgeBaseMakerStorage().uniswapV3Quoter.quoteExactInput(\n                    path,\n                    quoteTokenRequired\n                );\n                oppositeAmount = _formatSpotToPerpBaseDecimals(oppositeAmountXSpotDecimals);\n\n                fillOrderCallbackData.amountXSpotDecimals = quoteTokenRequired;\n                fillOrderCallbackData.oppositeAmountXSpotDecimals = oppositeAmountXSpotDecimals;\n            } else {\n                uint256 baseTokenRequired = _formatPerpToSpotBaseDecimals(amount);\n                // get quote\n                uint256 oppositeAmountXSpotDecimals = _getSpotHedgeBaseMakerStorage().uniswapV3Quoter.quoteExactOutput(\n                    path,\n                    baseTokenRequired\n                );\n                oppositeAmount = _formatSpotToPerpQuoteDecimals(oppositeAmountXSpotDecimals);\n\n                fillOrderCallbackData.amountXSpotDecimals = baseTokenRequired;\n                fillOrderCallbackData.oppositeAmountXSpotDecimals = oppositeAmountXSpotDecimals;\n            }\n        }\n\n        emit SHMOrderFilled(\n            _getSpotHedgeBaseMakerStorage().marketId,\n            path,\n            isBaseToQuote,\n            isExactInput,\n            amount, // targetAmount\n            oppositeAmount,\n            0 // spread\n        );\n\n        return (oppositeAmount, abi.encode(fillOrderCallbackData));\n    }\n\n    //\n    // EXTERNAL VIEW\n    //\n\n    function getUniswapV3Path(address tokenIn, address tokenOut) external view returns (bytes memory) {\n        return _getSpotHedgeBaseMakerStorage().uniswapV3PathMap[_getKey(tokenIn, tokenOut)];\n    }\n\n    // Ratio decimals = INTERNAL_DECIMALS\n    function getUtilRatio() external view returns (uint256, uint256) {\n        if (_getSpotHedgeBaseMakerStorage().baseTokenLiability == 0) {\n            return (0, 0);\n        }\n\n        // shortCapacityRatio = BaseBalance / BaseLiability\n        uint256 shortCapacityRatio = (WAD * _getSpotHedgeBaseMakerStorage().baseToken.balanceOf(address(this))) /\n            _getSpotHedgeBaseMakerStorage().baseTokenLiability;\n\n        uint256 shortUtilRatio;\n        if ((WAD >= shortCapacityRatio)) {\n            shortUtilRatio = WAD - shortCapacityRatio;\n        }\n        return (0, shortUtilRatio);\n    }\n\n    function isValidSender(address) external pure override returns (bool) {\n        return true;\n    }\n\n    function getAsset() external view returns (address) {\n        return address(_getSpotHedgeBaseMakerStorage().baseToken);\n    }\n\n    function getTotalAssets(uint256 price) external view returns (int256) {\n        return\n            _getVaultValueInBase(_getVault(), price).formatDecimals(\n                INTERNAL_DECIMALS,\n                _getSpotHedgeBaseMakerStorage().baseToken.decimals()\n            );\n    }\n\n    // For backward-compatibility\n    function marketId() external view returns (uint256) {\n        return _getSpotHedgeBaseMakerStorage().marketId;\n    }\n\n    // For backward-compatibility\n    function baseToken() external view returns (IERC20Metadata) {\n        return _getSpotHedgeBaseMakerStorage().baseToken;\n    }\n\n    // For backward-compatibility\n    function quoteToken() external view returns (IERC20Metadata) {\n        return _getSpotHedgeBaseMakerStorage().quoteToken;\n    }\n\n    // For backward-compatibility\n    function baseTokenDecimals() external view returns (uint8) {\n        return _getSpotHedgeBaseMakerStorage().baseTokenDecimals;\n    }\n\n    // For backward-compatibility\n    function quoteTokenDecimals() external view returns (uint8) {\n        return _getSpotHedgeBaseMakerStorage().quoteTokenDecimals;\n    }\n\n    // For backward-compatibility\n    function baseTokenLiability() external view returns (uint256) {\n        return _getSpotHedgeBaseMakerStorage().baseTokenLiability;\n    }\n\n    // For backward-compatibility\n    function minMarginRatio() external view returns (uint256) {\n        return _getSpotHedgeBaseMakerStorage().minMarginRatio;\n    }\n\n    //\n    // INTERNAL NON-VIEW\n    //\n\n    function _deposit(IVault vault, uint256 _marketId, uint256 amount) internal {\n        _getSpotHedgeBaseMakerStorage().quoteToken.approve(address(vault), amount);\n        vault.deposit(address(this), amount);\n        vault.transferFundToMargin(_marketId, amount);\n    }\n\n    function _withdraw(IVault vault, uint256 _marketId, uint256 amount) internal {\n        vault.transferMarginToFund(_marketId, amount);\n        vault.withdraw(amount);\n    }\n\n    function _uniswapV3ExactInput(UniswapV3ExactInputParams memory params) internal returns (uint256 amountOut) {\n        IERC20Metadata(params.tokenIn).approve(\n            address(_getSpotHedgeBaseMakerStorage().uniswapV3Router),\n            params.amountIn\n        );\n\n        return\n            _getSpotHedgeBaseMakerStorage().uniswapV3Router.exactInput(\n                ISwapRouter.ExactInputParams({\n                    path: params.path,\n                    recipient: params.recipient, // transfer tokenOut directly to recipient\n                    deadline: block.timestamp,\n                    amountIn: params.amountIn,\n                    amountOutMinimum: params.amountOutMinimum\n                })\n            );\n    }\n\n    function _uniswapV3ExactOutput(UniswapV3ExactOutputParams memory params) internal returns (uint256 amountIn) {\n        IERC20Metadata tokenIn = IERC20Metadata(params.tokenIn);\n        tokenIn.approve(address(_getSpotHedgeBaseMakerStorage().uniswapV3Router), tokenIn.balanceOf(address(this)));\n\n        // might revert at this step, if amount in > free collateral\n        amountIn = _getSpotHedgeBaseMakerStorage().uniswapV3Router.exactOutput(\n            ISwapRouter.ExactOutputParams({\n                path: params.path,\n                recipient: params.recipient, // transfer tokenOut directly to recipient\n                deadline: block.timestamp,\n                amountOut: params.amountOut,\n                amountInMaximum: params.amountInMaximum\n            })\n        );\n\n        tokenIn.approve(address(_getSpotHedgeBaseMakerStorage().uniswapV3Router), 0);\n        return amountIn;\n    }\n\n    function _fillOrderCallback(FillOrderCallbackData memory data) internal {\n        if (data.isBaseToQuote) {\n            // do nothing\n            return;\n        }\n\n        (address tokenIn, address tokenOut) = (\n            address(_getSpotHedgeBaseMakerStorage().quoteToken),\n            address(_getSpotHedgeBaseMakerStorage().baseToken)\n        );\n        address maker = address(this);\n        uint256 _marketId = _getSpotHedgeBaseMakerStorage().marketId;\n        IVault vault = _getVault();\n\n        bytes memory path;\n        // Note we don't explicitly check maker's quote asset balance because\n        // if it is insufficient, it would revert in swap anyways.\n        if (data.isExactInput) {\n            _withdraw(vault, _marketId, data.amountXSpotDecimals);\n            path = _getPath(\n                tokenIn,\n                tokenOut,\n                true // isExactInput\n            );\n            _uniswapV3ExactInput(\n                UniswapV3ExactInputParams({\n                    tokenIn: tokenIn,\n                    tokenOut: tokenOut,\n                    path: path,\n                    recipient: maker,\n                    amountIn: data.amountXSpotDecimals,\n                    amountOutMinimum: data.oppositeAmountXSpotDecimals\n                })\n            );\n            return;\n        }\n\n        // else = if data.isExactOutput\n        _withdraw(vault, _marketId, data.oppositeAmountXSpotDecimals);\n        path = _getPath(\n            tokenIn,\n            tokenOut,\n            false // isExactInput\n        );\n        _uniswapV3ExactOutput(\n            UniswapV3ExactOutputParams({\n                tokenIn: tokenIn,\n                tokenOut: tokenOut,\n                path: path,\n                recipient: maker,\n                amountOut: data.amountXSpotDecimals,\n                amountInMaximum: data.oppositeAmountXSpotDecimals\n            })\n        );\n\n        uint256 remainQuoteTokenAmount = _getSpotHedgeBaseMakerStorage().quoteToken.balanceOf(maker);\n        if (remainQuoteTokenAmount > 0) {\n            _deposit(vault, _marketId, remainQuoteTokenAmount);\n        }\n    }\n\n    //\n    // INTERNAL VIEW\n    //\n    function _getVault() internal view returns (IVault) {\n        return getAddressManager().getVault();\n    }\n\n    function _checkMinMarginRatio(uint256 price) internal view {\n        int256 marginRatio = _getVault().getMarginRatio(_getSpotHedgeBaseMakerStorage().marke"
    }
  ]
}