{
  "Title": "[H-03] Absence of restrictions on the sender of the `twTAP.claimsReward()` function could enable attackers to freeze reward tokens within the Tap token contract",
  "Content": "\n<https://github.com/Tapioca-DAO/tap-token/blob/20a83b1d2d5577653610a6c3879dff9df4968345/contracts/governance/twTAP.sol#L396-L404> \n\nThe function `twTAP.claimRewards()` is utilized to claim the reward distributed to the position identified by `_tokenId`.\n\n```solidity\nfunction claimRewards(uint256 _tokenId, address _to)\n    external\n    nonReentrant\n    whenNotPaused\n    returns (uint256[] memory amounts_)\n{\n    _requireClaimPermission(_to, _tokenId);\n    amounts_ = _claimRewards(_tokenId, _to);\n}\n```\n\nThis function can be triggered by anyone, provided that the receiver of the claimed reward `_to` is either the owner of the position or an address approved by the position's owner.\n\nIn the function `TapTokenReceiver._claimTwpTapRewardsReceiver()`, the `twTAP.claimRewards()` function is invoked at [line 156](https://github.com/Tapioca-DAO/tap-token/blob/20a83b1d2d5577653610a6c3879dff9df4968345/contracts/tokens/TapTokenReceiver.sol#L156) to calculate the reward assigned to `_tokenId` and claim the reward to this contract before transferring it to the receiver on another chain. To achieve this, the position's owner must first approve this contract to access the position before executing the function.\n\n```solidity\nfunction _claimTwpTapRewardsReceiver(bytes memory _data) internal virtual twTapExists {\n    ClaimTwTapRewardsMsg memory claimTwTapRewardsMsg_ = TapTokenCodec.decodeClaimTwTapRewardsMsg(_data);\n    uint256[] memory claimedAmount_ = twTap.claimRewards(claimTwTapRewardsMsg_.tokenId, address(this));\n\n    ...\n}\n```\n\nHowever, between the call to grant approval to the contract and the execution of the `_claimTwpTapRewardsReceiver()` function, an attacker can insert a transaction calling `twTAP.claimRewards(_tokenId, TapTokenReceiver)`. By doing so, the rewards will be claimed to the `TapTokenReceiver` contract before the `_claimTwpTapRewardsReceiver()` function is invoked. Consequently, the return value of `claimedAmount_ = twTap.claimRewards(claimTwTapRewardsMsg_.tokenId, address(this))` within the function will be `0` for all elements, resulting in no rewards being claimed for the receiver. As a result, the reward tokens will become trapped in the contract.\n\nIn the event that the sender utilizes multiple LayerZero composed messages containing two messages:\n\n- Permit message: to approve permission of `_tokenId` to the `TapTokenReceiver` contract.\n- Claim reward message: to trigger the `_claimTwpTapRewardsReceiver()` function and claim the reward.\n\nThe attacker cannot insert any `twTAP.claimRewards()` between these two messages, as they are executed within the same transaction on the destination chain. However, the permit message can be triggered by anyone, not just the contract `TapTokenReceiver`. The attacker can thus trigger the permit message on the destination chain and subsequently call the `twTAP.claimRewards()` function before the `_claimTwpTapRewardsReceiver()` message is delivered on the destination chain.\n\n### Impact\n\nThe reward tokens will become trapped within the `TapTokenReceiver` contract.\n\n### Recommended Mitigation Steps\n\nConsider updating the function `twTAP.claimRewards()` as depicted below to impose restrictions on who can invoke this function:\n\n```solidity\nfunction claimRewards(uint256 _tokenId, address _to)\n    external\n    nonReentrant\n    whenNotPaused\n    returns (uint256[] memory amounts_)\n{\n    _requireClaimPermission(msg.sender, _tokenId);\n    _requireClaimPermission(_to, _tokenId);\n    amounts_ = _claimRewards(_tokenId, _to);\n}\n```\n\n**[0xRektora (Tapioca) confirmed via duplicate Issue #120](https://github.com/code-423n4/2024-02-tapioca-findings/issues/120#issuecomment-2016850113)**\n\n**[0xRektora (Tapioca) commented](https://github.com/code-423n4/2024-02-tapioca-findings/issues/142#issuecomment-2054134428):**\n > Just as reference, the proposed mitigation will not work, because in this context `msg.sender == _to`.\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2024-02-tapioca",
  "Code": [
    {
      "filename": "contracts/governance/twTAP.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ERC721} from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Tapioca\nimport {IPearlmit, PearlmitHandler} from \"tapioca-periph/Pearlmit/PearlmitHandler.sol\";\nimport {ERC721NftLoader} from \"tap-token/erc721NftLoader/ERC721NftLoader.sol\";\nimport {ERC721Permit} from \"tapioca-periph/utils/ERC721Permit.sol\";\nimport {ERC721PermitStruct} from \"tap-token/tokens/ITapToken.sol\";\nimport {TapToken} from \"tap-token/tokens/TapToken.sol\";\nimport {TWAML} from \"tap-token/options/twAML.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n// Justification for data sizes:\n// - 56 bits can represent over 2 billion years in seconds\n// - TAP has a maximum supply of 100 million, and a precision of 10^18. Any\n//   amount will therefore fit in (lg 10^26 = 87) bits.\n// - The multiplier has a maximum of 1 million; dMAX = 100 * 1e4, which fits\n//   in 20 bits.\n// - A week is 86400 * 7 = 604800 seconds; less than 2^20. Even if we start\n//   counting at the (Unix) epoch, we will run out of `expiry` before we\n//   saturate the week fields.\nstruct Participation {\n    uint256 averageMagnitude;\n    bool hasVotingPower;\n    bool divergenceForce; // 0 negative, 1 positive\n    bool tapReleased; // allow restaking while rewards may still accumulate\n    uint56 expiry; // expiry timestamp. Big enough for over 2 billion years..\n    uint88 tapAmount; // amount of TAP locked\n    uint24 multiplier; // Votes = multiplier * tapAmount\n    uint40 lastInactive; // One week BEFORE the staker gets a share of rewards\n    uint40 lastActive; // Last week that the staker shares in rewards\n}\n\nstruct TWAMLPool {\n    uint256 totalParticipants;\n    uint256 averageMagnitude;\n    uint256 totalDeposited;\n    uint256 cumulative;\n}\n\nstruct WeekTotals {\n    // For [0..currentWeek] this is a cumulative total: it consists of the\n    // active votes in the previous week, minus the votes known to expire this\n    // week. For future weeks, it is a negative number corresponding to the\n    // expiring votes.\n    int256 netActiveVotes;\n    // rewardTokens index -> amount\n    mapping(uint256 => uint256) totalDistPerVote;\n}\n\ncontract TwTAP is TWAML, ERC721, ERC721Permit, Ownable, PearlmitHandler, ERC721NftLoader, ReentrancyGuard, Pausable {\n    using SafeERC20 for IERC20;\n\n    TapToken public immutable tapOFT;\n\n    /// ===== TWAML ======\n    TWAMLPool public twAML; // sglAssetId => twAMLPool\n\n    mapping(uint256 => Participation) public participants; // tokenId => part.\n\n    /// @dev Virtual total amount to add to the total when computing twAML participation right. Default 10_000 * 1e18.\n    uint256 private VIRTUAL_TOTAL_AMOUNT = 10_000 ether;\n\n    uint256 MIN_WEIGHT_FACTOR = 1000; // In BPS, default 10%\n    uint256 constant dMAX = 1_000_000; // 100 * 1e4; 0% - 100% voting power multiplier\n    uint256 constant dMIN = 0;\n    uint256 public constant EPOCH_DURATION = 7 days;\n    uint256 public constant MAX_LOCK_DURATION = 100 * 365 days; // 100 years\n\n    // If we assume 128 bit balances for the reward token -- which fit 1e40\n    // \"tokens\" at the most commonly used 1e18 precision -- then we can use the\n    // other 128 bits to store the tokens allotted to a single vote more\n    // accurately. Votes in turn are proportional to the amount of TAP locked,\n    // weighted by a multiplier. This number is at most 107 bits long (see\n    // definition of `Participation` struct).\n    // the weight ranges from 10-100% where 1% = 1e4, so 1 million (20 bits).\n    // the multiplier is at most 100% = 1M (20 bits), so votes is at most a\n    // 107-bit number.\n    uint256 constant DIST_PRECISION = 2 ** 128; //2 ** 128;\n\n    IERC20[] public rewardTokens;\n    mapping(IERC20 => uint256) public rewardTokenIndex; // Index 0 is reserved with 0x0 address\n    uint256 public maxRewardTokens;\n\n    // tokenId -> rewardTokens index -> amount\n    mapping(uint256 => mapping(uint256 => uint256)) public claimed;\n\n    // The current week is determined by creation, but there are values that\n    // need to be updated weekly. If, for any reason whatsoever, this cannot\n    // be done in time, the `lastProcessedWeek` will be behind until this is\n    // done.\n    uint256 public mintedTWTap;\n    uint256 public creation; // Week 0 starts here\n    uint256 public lastProcessedWeek;\n    mapping(uint256 => WeekTotals) public weekTotals;\n\n    event LogMaxRewardsLength(uint256 indexed _oldLength, uint256 indexed _newLength, uint256 indexed _currentLength);\n\n    error NotAuthorized();\n    error AdvanceWeekFirst();\n    error NotValid();\n    error Registered();\n    error TokenLimitReached();\n    error NotApproved(uint256 tokenId, address spender);\n    error Duplicate();\n    error LockNotExpired();\n    error LockNotAWeek();\n    error LockTooLong();\n    error AdvanceEpochFirst();\n\n    /// =====-------======\n    constructor(address payable _tapOFT, IPearlmit _pearlmit, address _owner)\n        ERC721NftLoader(\"Time Weighted TAP\", \"twTAP\", _owner)\n        ERC721Permit(\"Time Weighted TAP\")\n        PearlmitHandler(_pearlmit)\n    {\n        tapOFT = TapToken(_tapOFT);\n        creation = block.timestamp;\n\n        rewardTokens.push(IERC20(address(0x0))); // 0 index is reserved\n\n        maxRewardTokens = 30;\n\n        // Seed the cumulative with 1 week of magnitude\n        twAML.cumulative = EPOCH_DURATION;\n    }\n\n    // ==========\n    //   EVENTS\n    // ==========\n    event Participate(address indexed participant, uint256 indexed tapAmount, uint256 indexed multiplier);\n    event AMLDivergence(\n        uint256 indexed cumulative, uint256 indexed averageMagnitude, uint256 indexed totalParticipants\n    );\n    event ExitPosition(uint256 indexed tokenId, uint256 indexed amount);\n\n    // ==========\n    //    READ\n    // ==========\n\n    /**\n     * @inheritdoc ERC721NftLoader\n     */\n    function tokenURI(uint256 tokenId) public view override(ERC721, ERC721NftLoader) returns (string memory) {\n        return ERC721NftLoader.tokenURI(tokenId);\n    }\n\n    /**\n     * @notice Return the address of reward tokens.\n     */\n    function getRewardTokens() external view returns (IERC20[] memory) {\n        return rewardTokens;\n    }\n\n    function currentWeek() public view returns (uint256) {\n        return (block.timestamp - creation) / EPOCH_DURATION;\n    }\n\n    /// @notice Return the participation of a token. Returns 0 votes for expired tokens.\n    function getParticipation(uint256 _tokenId) external view returns (Participation memory participant) {\n        participant = participants[_tokenId];\n        if (participant.expiry <= block.timestamp) {\n            participant.multiplier = 0;\n        }\n        return participant;\n    }\n\n    /**\n     * @notice Amount currently claimable for each reward token.\n     * @dev index 0 will ALWAYS return 0, as it's used by address(0x0).\n     * @dev Should be safe to claim even after position exit.\n     * @return claimable amounts mapped by reward token\n     */\n    function claimable(uint256 _tokenId) public view returns (uint256[] memory) {\n        uint256 len = rewardTokens.length;\n        uint256[] memory result = new uint256[](len);\n\n        Participation memory position = participants[_tokenId];\n        uint256 votes;\n        unchecked {\n            // Math is safe: Types fit\n            votes = uint256(position.tapAmount) * uint256(position.multiplier);\n        }\n\n        if (votes == 0) {\n            return result;\n        }\n\n        // If the \"last processed week\" is behind the actual week, rewards\n        // get processed as if it were earlier.\n        uint256 week = lastProcessedWeek;\n        if (week <= position.lastInactive) {\n            return result;\n        }\n        if (position.lastActive < week) {\n            week = position.lastActive;\n        }\n\n        WeekTotals storage cur = weekTotals[week];\n        WeekTotals storage prev = weekTotals[position.lastInactive];\n\n        for (uint256 i; i < len;) {\n            // Math is safe (but we do the checks anyway):\n            //\n            // -- The `totalDistPerVote[i]` values are increasing as a\n            //    function of weeks (see `advanceWeek()`), and if `week`\n            //    were not greater than `position.lastInactive`, this bit\n            //    of code would not be reached (see above). Therefore the\n            //    subtraction in the calculation of `net` cannot underflow.\n            //\n            // -- `votes * net` is at most the entire reward amount given\n            //    out, ever, in units of\n            //\n            //        (reward tokens) * DIST_PRECISION.\n            //\n            //    If this number were to exceed 256 bits, then\n            //    `distributeReward` would revert.\n            //\n            // -- `claimed[_tokenId][i]` is the sum of all (the i-th values\n            //    of) previous calls to the current function that were made\n            //    by `_claimRewards()`. Let there be n such calls, and let\n            //    r_j be `result[i]`, c_j be `claimed[_tokenId][i]`, and\n            //    net_j be `net` during that j-th call. Then, up to a\n            //    multiplication by votes / DIST_PRECISION:\n            //\n            //              c_1 = 0 <= net_1,\n            //\n            //    and, for n > 1:\n            //\n            //              c_n = r_(n-1) + r_(n-2) + ... + r_1\n            //                  = r_(n-1) + c_(n-1)\n            //                  = (net_(n-1) - c_(n-1) + c_(n-1)\n            //                  = net_(n-1)\n            //                  <= net_n,\n            //\n            //    so that the subtraction net_n - c_n does not underflow.\n            //    (The rounding the calculation favors the greater first\n            //    term).\n            //    (TODO: Word better?)\n            //\n            uint256 net = cur.totalDistPerVote[i] - prev.totalDistPerVote[i];\n            result[i] = ((votes * net) / DIST_PRECISION) - claimed[_tokenId][i];\n            unchecked {\n                ++i;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the hash of the struct used by the permit function.\n     * @param _permitData Struct containing permit data.\n     */\n    function getTypedDataHash(ERC721PermitStruct calldata _permitData) public view returns (bytes32) {\n        bytes32 permitTypeHash_ = keccak256(\"Permit(address spender,uint256 tokenId,uint256 nonce,uint256 deadline)\");\n\n        bytes32 structHash_ = keccak256(\n            abi.encode(\n                permitTypeHash_, _permitData.spender, _permitData.tokenId, _permitData.nonce, _permitData.deadline\n            )\n        );\n        return _hashTypedDataV4(structHash_);\n    }\n\n    // ===========\n    //    WRITE\n    // ===========\n\n    /// @notice Participate in twAML voting and mint an twTap position\n    /// @dev Requires a Pearlmit approval for the TAP amount\n    ///\n    /// @param _participant The address of the participant\n    /// @param _amount The amount of TAP to participate with\n    /// @param _duration The duration of the lock\n    function participate(address _participant, uint256 _amount, uint256 _duration)\n        external\n        whenNotPaused\n        nonReentrant\n        returns (uint256 tokenId)\n    {\n        if (_duration < EPOCH_DURATION) revert LockNotAWeek();\n        if (_duration > MAX_LOCK_DURATION) revert LockTooLong();\n        if (_timestampToWeek(block.timestamp) > currentWeek()) revert AdvanceEpochFirst();\n\n        // Transfer TAP to this contract\n        {\n            // tapOFT.transferFrom(msg.sender, address(this), _amount);\n            bool isErr = pearlmit.transferFromERC20(msg.sender, address(this), address(tapOFT), _amount);\n            if (isErr) revert NotAuthorized();\n        }\n\n        // Copy to memory\n        TWAMLPool memory pool = twAML;\n\n        uint256 magnitude = computeMagnitude(_duration, pool.cumulative);\n        // Revert if the lock 4x the cumulative\n        if (magnitude >= pool.cumulative * 4) revert NotValid();\n        uint256 multiplier = computeTarget(dMIN, dMAX, magnitude, pool.cumulative);\n\n        // Calculate twAML voting weight\n        bool divergenceForce;\n        bool hasVotingPower = _amount >= computeMinWeight(pool.totalDeposited + VIRTUAL_TOTAL_AMOUNT, MIN_WEIGHT_FACTOR);\n        if (hasVotingPower) {\n            pool.totalParticipants++; // Save participation\n            pool.averageMagnitude = (pool.averageMagnitude + magnitude) / pool.totalParticipants; // compute new average magnitude\n\n            // Compute and save new cumulative\n            divergenceForce = _duration >= pool.cumulative;\n\n            if (divergenceForce) {\n                pool.cumulative += pool.averageMagnitude;\n            } else {\n                // TODO: Strongly suspect this is never less. Prove it.\n                if (pool.cumulative > pool.averageMagnitude) {\n                    pool.cumulative -= pool.averageMagnitude;\n                } else {\n                    pool.cumulative = 0;\n                }\n            }\n\n            // Save new weight\n            pool.totalDeposited += _amount;\n\n            twAML = pool; // Save twAML participation\n            emit AMLDivergence(pool.cumulative, pool.averageMagnitude, pool.totalParticipants);\n        }\n\n        uint256 expiry = block.timestamp + _duration;\n        // Eligibility starts NEXT week, and lasts until the week that the lock\n        // expires. This is guaranteed to be at least one week later by the\n        // check on `_duration`.\n        // If a user locks right before the current week ends, and have a\n        // duration slightly over one week, straddling the two starting points,\n        // then that user is eligible for the rewards during both weeks; the\n        // price for this maneuver is a lower multiplier, and loss of voting\n        // power in the DAO after the lock expires.\n        uint256 w0 = currentWeek();\n        uint256 w1 = (expiry - creation) / EPOCH_DURATION;\n\n        // Save twAML participation\n        // Casts are safe: see struct definition\n        tokenId = ++mintedTWTap;\n        uint256 votes = _amount * multiplier;\n        participants[tokenId] = Participation({\n            averageMagnitude: pool.averageMagnitude,\n            hasVotingPower: hasVotingPower,\n            divergenceForce: divergenceForce,\n            tapReleased: false,\n            expiry: uint56(expiry),\n            tapAmount: uint88(_amount),\n            multiplier: uint24(multiplier),\n            lastInactive: uint40(w0),\n            lastActive: uint40(w1)\n        });\n\n        // w0 + 1 = lastInactive + 1 = first active\n        // w1 + 1 = lastActive + 1 = first inactive\n        // Cast is safe: `votes` is the product of a uint88 and a uint24\n        weekTotals[w0 + 1].netActiveVotes += int256(votes);\n        weekTotals[w1 + 1].netActiveVotes -= int256(votes);\n\n        // Mint twTAP position\n        _safeMint(_participant, tokenId);\n\n        emit Participate(_participant, _amount, multiplier);\n        // TODO: Mint event?\n    }\n\n    /**\n     * @notice claims all rewards distributed since token mint or last claim.\n     * @dev Should be safe to claim even after position exit.\n     *\n     * @param _tokenId tokenId whose rewards to claim\n     * @param _to address to receive the rewards\n     *\n     * @return amounts_ Claimed amount of each reward token.\n     */\n    function claimRewards(uint256 _tokenId, address _to)\n        external\n        nonReentrant\n        whenNotPaused\n        returns (uint256[] memory amounts_)\n    {\n        _requireClaimPermission(_to, _tokenId);\n        amounts_ = _claimRewards(_tokenId, _to);\n    }\n\n    /**\n     * @notice Exit a twAML participation, delete the voting power if existing and send the TAP to `_to`.\n     *\n     * @param _tokenId The tokenId of the twTAP position.\n     * @param _to address to receive the TAP.\n     *\n     * @return tapAmount_ The amount of TAP released.\n     */\n    function exitPosition(uint256 _tokenId, address _to)\n        external\n        nonReentrant\n        whenNotPaused\n        returns (uint256 tapAmount_)\n    {\n        {\n            address owner_ = ownerOf(_tokenId);\n            if (_to != owner_) {\n                _requireClaimPermission(_to, _tokenId);\n            }\n        }\n        tapAmount_ = _releaseTap(_tokenId, _to);\n    }\n\n    /// @notice Indicate that (a) week(s) have passed and update running totals\n    /// @notice Reverts if called in week 0. Let it.\n    /// @param _limit Maximum number of weeks to process in one call\n    function advanceWeek(uint256 _limit) public nonReentrant {\n        // TODO: Make whole function unchecked\n        uint256 week = lastProcessedWeek;\n        uint256 goal = currentWeek();\n        unchecked {\n            if (goal - week > _limit) {\n                goal = week + _limit;\n            }\n        }\n        uint256 len = rewardTokens.length;\n        while (week < goal) {\n            WeekTotals storage prev = weekTotals[week];\n            WeekTotals storage next = weekTotals[++week];\n            // TODO: Prove that math is safe\n            next.netActiveVotes += prev.netActiveVotes;\n            for (uint256 i; i < len;) {\n                next.totalDistPerVote[i] += prev.totalDistPerVote[i];\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n        lastProcessedWeek = goal;\n    }\n\n    /// @notice distributes a reward among all tokens, weighted by voting power\n    /// @notice The reward gets allocated to all positions that have locked in\n    /// @notice the current week. Fails, intentionally, if this number is zero.\n    /// @notice Total rewards cannot exceed 2^128 tokens.\n    /// @param _rewardTokenId index of the reward in `rewardTokens`\n    /// @param _amount amount of reward token to distribute.\n    function distributeReward(uint256 _rewardTokenId, uint256 _amount) external nonReentrant {\n        if (lastProcessedWeek != currentWeek()) revert AdvanceWeekFirst();\n        if (_amount == 0) revert NotValid();\n        if (_rewardTokenId == 0) revert NotValid(); // @dev rewardTokens[0] is 0x0\n\n        WeekTotals storage totals = weekTotals[lastProcessedWeek];\n        IERC20 rewardToken = rewardTokens[_rewardTokenId];\n        // If this is a DBZ then there are no positions to give the reward to.\n        // Since reward eligibility starts in the week after locking, there is\n        // no way to give out rewards THIS week.\n        // Cast is safe: `netActiveVotes` is at most zero by construction of\n        // weekly totals and the requirement that they are up to date.\n        // TODO: Word this better\n        totals.totalDistPerVote[_rewardTokenId] += (_amount * DIST_PRECISION) / uint256(totals.netActiveVotes);\n\n        rewardToken.safeTransferFrom(msg.sender, address(this), _amount);\n    }\n\n    // =========\n    //   OWNER\n    // =========\n\n    /**\n     * @notice Set the `VIRTUAL_TOTAL_AMOUNT` state variable.\n     * @param _virtualTotalAmount The new state variable value.\n     */\n    function setVirtualTotalAmount(uint256 _virtualTotalAmount) external onlyOwner {\n        VIRTUAL_TOTAL_AMOUNT = _virtualTotalAmount;\n    }\n\n    /**\n     * @notice Set the minimum weight factor.\n     * @param _minWeightFactor The new minimum weight factor.\n     */\n    function setMinWeightFactor(uint256 _minWeightFactor) external onlyOwner {\n        MIN_WEIGHT_FACTOR = _minWeightFactor;\n    }\n\n    function setMaxRewardTokensLength(uint256 _length) external onlyOwner {\n        emit LogMaxRewardsLength(maxRewardTokens, _length, rewardTokens.length);\n        maxRewardTokens = _length;\n    }\n\n    /**\n     * @notice Add a reward token to the list of reward tokens.\n     * @param _token The address of the reward token.\n     */\n    // TODO Check if it should be one type of token only? Like OFT?\n    function addRewardToken(IERC20 _token) external onlyOwner returns (uint256) {\n        if (rewardTokenIndex[_token] != 0) revert Registered();\n        if (rewardTokens.length + 1 > maxRewardTokens) {\n            revert TokenLimitReached();\n        }\n        rewardTokens.push(_token);\n\n        uint256 newTokenIndex = rewardTokens.length - 1;\n        rewardTokenIndex[_token] = newTokenIndex;\n\n        return newTokenIndex;\n    }\n\n    /**\n     * @notice Un/Pauses this contract.\n     */\n    function setPause(bool _pauseState) external onlyOwner {\n        if (_pauseState) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n\n    // ============\n    //   INTERNAL\n    // ============\n\n    /// @notice returns week for timestamp\n    function _timestampToWeek(uint256 timestamp) internal view returns (uint256) {\n        return ((timestamp - creation) / EPOCH_DURATION);\n    }\n\n    /**\n     * @dev Use `_isApprovedOrOwner()` internally.\n     */\n    function _requireClaimPermission(address _to, uint256 _tokenId) internal view {\n        if (!_isApprovedOrOwner(_to, _tokenId) && !isERC721Approved(_ownerOf(_tokenId), _to, address(this), _tokenId)) {\n            revert NotApproved(_tokenId, msg.sender);\n        }\n    }\n\n    /**\n     * @dev Claim rewards on a token.\n     * @return amounts_ Claimed amount of each reward token.\n     */\n    function _claimRewards(uint256 _tokenId, address _to) internal returns (uint256[] memory amounts_) {\n        amounts_ = claimable(_tokenId);\n        uint256 len = amounts_.length;\n        unchecked {\n            for (uint256 i; i < len; ++i) {\n                uint256 amount = amounts_[i];\n                if (amount > 0) {\n                    // Math is safe: `amount` calculated safely in `claimable()`\n                    claimed[_tokenId][i] += amount;\n                    rewardTokens[i].safeTransfer(_to, amount);\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Release the TAP locked in a position whose votes have expired.\n     * @dev Clean up the twAML participation and delete the voting power if existing.\n     * @dev !!!!!!!!!! Make sure to verify ownership of `_tokenId` and `_to` !!!!!!!!!!\n     *\n     * @param _tokenId tokenId whose locked TAP to claim\n     * @param _to address to receive the TAP\n     */\n    function _releaseTap(uint256 _tokenId, address _to) internal returns (uint256 releasedAmount) {\n        Participation memory position = participants[_tokenId];\n        if (position.expiry > block.timestamp) revert LockNotExpired();\n        if (position.tapReleased) {\n            return 0;\n        }\n\n        releasedAmount = position.tapAmount;\n\n        // Remove participation\n        if (position.hasVotingPower) {\n            TWAMLPool memory pool = twAML;\n            unchecked {\n                --pool.totalParticipants;\n            }\n\n            // Inverse of the participation. The participation entry tracks\n            // the average magnitude as it was at the time the participant\n            // entered. When going the other way around, this value matches the\n            // one in the pool, but here it does not.\n            if (position.divergenceForce) {\n                if (pool.cumulative > position.averageMagnitude) {\n                    pool.cumulative -= position.averageMagnitude;\n                } else {\n                    pool.cumulative = 0;\n                }\n            } else {\n                pool.cumulative += position.averageMagnitude;\n            }\n\n            // Save new weight\n            pool.totalDeposited -= position.tapAmount;\n\n            twAML = pool; // Save twAML exit\n            emit AMLDivergence(pool.cumulative, pool.averageMagnitude, pool.totalParticipants); // Register new voting power event\n        }\n\n        participants[_tokenId].tapReleased = true;\n        tapOFT.transfer(_to, releasedAmount);\n\n        emit ExitPosition(_tokenId, releasedAmount);\n    }\n\n    /// @notice Checks if an element is in an array\n    /// @param _check The element to check\n    /// @param _array The array to check in\n    function _existInArray(address _check, address[] memory _array) internal pure returns (bool) {\n        uint256 len = _array.length;\n        unchecked {\n            for (uint256 i; i < len; ++i) {\n                if (_array[i] == _check) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /// @notice Returns the chain ID of the current network.\n    /// @dev Used for dev purposes.\n    function _getChainId() internal view virtual returns (uint256) {\n        return block.chainid;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n}"
    },
    {
      "filename": "contracts/tokens/TapTokenReceiver.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// LZ\nimport {\n    MessagingReceipt, OFTReceipt, SendParam\n} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/interfaces/IOFT.sol\";\nimport {OFTMsgCodec} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/libs/OFTMsgCodec.sol\";\nimport {OFTCore} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/OFTCore.sol\";\nimport {Origin} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OApp.sol\";\nimport {OFT} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/OFT.sol\";\n\n// External\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n// Tapioca\nimport {\n    ERC721PermitApprovalMsg,\n    UnlockTwTapPositionMsg,\n    ERC20PermitApprovalMsg,\n    LockTwTapPositionMsg,\n    ClaimTwTapRewardsMsg,\n    RemoteTransferMsg,\n    LZSendParam\n} from \"./ITapToken.sol\";\nimport {TapiocaOmnichainReceiver} from \"tapioca-periph/tapiocaOmnichainEngine/TapiocaOmnichainReceiver.sol\";\nimport {IPearlmit} from \"tapioca-periph/interfaces/periph/IPearlmit.sol\";\nimport {TapTokenSender} from \"./TapTokenSender.sol\";\nimport {TapTokenCodec} from \"./TapTokenCodec.sol\";\nimport {BaseTapToken} from \"./BaseTapToken.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ncontract TapTokenReceiver is BaseTapToken, TapiocaOmnichainReceiver {\n    using OFTMsgCodec for bytes;\n    using OFTMsgCodec for bytes32;\n\n    /**\n     * @dev Used as a module for `TapToken`. Only delegate calls with `TapToken` state are used.\n     */\n    constructor(string memory _name, string memory _symbol, address _endpoint, address _delegate, address _extExec)\n        BaseTapToken(_name, _symbol, _endpoint, _delegate, _extExec, IPearlmit(address(0)))\n    {}\n\n    /// @dev twTAP lock operation received.\n    event LockTwTapReceived(address indexed user, uint96 duration, uint256 amount);\n    /// @dev twTAP unlock operation received.\n    event UnlockTwTapReceived(address indexed user, uint256 tokenId, uint256 amount);\n    event ClaimRewardReceived(address indexed token, address indexed to, uint256 amount);\n\n    // See `this._claimTwpTapRewardsReceiver()`. Triggered if the length of the claimed rewards are not equal to the length of the lzSendParam array.\n    error InvalidSendParamLength(uint256 expectedLength, uint256 actualLength);\n\n    // ********************* //\n    // ***** RECEIVERS ***** //\n    // ********************* //\n\n    /**\n     * @inheritdoc TapiocaOmnichainReceiver\n     */\n    function _lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor, /*_executor*/ // @dev unused in the default implementation.\n        bytes calldata _extraData /*_extraData*/ // @dev unused in the default implementation.\n    ) internal virtual override(OFTCore, TapiocaOmnichainReceiver) {\n        TapiocaOmnichainReceiver._lzReceive(_origin, _guid, _message, _executor, _extraData);\n    }\n\n    /**\n     * @inheritdoc TapiocaOmnichainReceiver\n     */\n    function _toeComposeReceiver(uint16 _msgType, address _srcChainSender, bytes memory _toeComposeMsg)\n        internal\n        override\n        returns (bool success)\n    {\n        if (_msgType == MSG_LOCK_TWTAP) {\n            _lockTwTapPositionReceiver(_srcChainSender, _toeComposeMsg);\n        } else if (_msgType == MSG_UNLOCK_TWTAP) {\n            _unlockTwTapPositionReceiver(_toeComposeMsg);\n        } else if (_msgType == MSG_CLAIM_REWARDS) {\n            _claimTwpTapRewardsReceiver(_toeComposeMsg);\n        } else {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Locks TAP for the user in the twTAP contract.\n     * @dev The user needs to have approved the TapToken contract to spend the TAP.\n     *\n     * @param _srcChainSender The address of the sender on the source chain.\n     * @param _data The call data containing info about the lock.\n     *          - user::address: Address of the user to lock the TAP for.\n     *          - duration::uint96: Amount of time to lock for.\n     *          - amount::uint256: Amount of TAP to lock.\n     */\n\n    // TODO sanitize the user to use approve on behalf of him\n    function _lockTwTapPositionReceiver(address _srcChainSender, bytes memory _data) internal virtual twTapExists {\n        LockTwTapPositionMsg memory lockTwTapPositionMsg_ = TapTokenCodec.decodeLockTwpTapDstMsg(_data);\n\n        /// @dev xChain owner needs to have approved dst srcChain `sendPacket()` msg.sender in a previous composedMsg. Or be the same address.\n        _internalTransferWithAllowance(lockTwTapPositionMsg_.user, _srcChainSender, lockTwTapPositionMsg_.amount);\n\n        // _approve(address(this), address(twTap), lockTwTapPositionMsg_.amount);\n        _approve(address(this), address(pearlmit), lockTwTapPositionMsg_.amount);\n        pearlmit.approve(\n            address(this), 0, address(twTap), uint200(lockTwTapPositionMsg_.amount), uint48(block.timestamp + 1)\n        );\n        twTap.participate(lockTwTapPositionMsg_.user, lockTwTapPositionMsg_.amount, lockTwTapPositionMsg_.duration);\n        _approve(address(this), address(pearlmit), 0);\n\n        emit LockTwTapReceived(lockTwTapPositionMsg_.user, lockTwTapPositionMsg_.duration, lockTwTapPositionMsg_.amount);\n    }\n\n    /**\n     * @dev Unlocks TAP for the user in the twTAP contract.\n     * @dev !!! The user needs to have given TwTAP allowance to this contract in order to exit  !!!\n     *\n     * @param _data The call data containing info about the lock.\n     *          - unlockTwTapPositionMsg_::UnlockTwTapPositionMsg: Unlocking data.\n     */\n    function _unlockTwTapPositionReceiver(bytes memory _data) internal virtual twTapExists {\n        UnlockTwTapPositionMsg memory unlockTwTapPositionMsg_ = TapTokenCodec.decodeUnlockTwTapPositionMsg(_data);\n\n        // Send TAP to the user address.\n        uint256 tapAmount_ = twTap.exitPosition(unlockTwTapPositionMsg_.tokenId, unlockTwTapPositionMsg_.user);\n\n        emit UnlockTwTapReceived(unlockTwTapPositionMsg_.user, unlockTwTapPositionMsg_.tokenId, tapAmount_);\n    }\n\n    /**\n     * @dev Transfers tokens from this contract to the recipient on the chain A. Flow of calls is: A->B->A.\n     * @dev !!! The user needs to have given TwTAP allowance to this contract  !!!\n     *\n     * @param _data The call data containing info about the transfer (LZSendParam).\n     */\n    function _claimTwpTapRewardsReceiver(bytes memory _data) internal virtual twTapExists {\n        ClaimTwTapRewardsMsg memory claimTwTapRewardsMsg_ = TapTokenCodec.decodeClaimTwTapRewardsMsg(_data);\n\n        // Claim rewards, make sure to have approved this contract on TwTap.\n        uint256[] memory claimedAmount_ = twTap.claimRewards(claimTwTapRewardsMsg_.tokenId, address(this));\n\n        // Check if the claimed amount is equal to the amount of sendParam\n        if (\n            (claimedAmount_.length - 1) // Remove 1 because the first index doesn't count.\n                != claimTwTapRewardsMsg_.sendParam.length\n        ) {\n            revert InvalidSendParamLength(claimedAmount_.length, claimTwTapRewardsMsg_.sendParam.length);\n        }\n\n        // Loop over the tokens, and send them."
    }
  ]
}