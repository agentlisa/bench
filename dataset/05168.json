{
  "Title": "[M-03] Fighter created by `mintFromMergingPool` can have arbitrary weight and element",
  "Content": "\n<https://github.com/code-423n4/2024-02-ai-arena/blob/main/src/FighterFarm.sol#L313-L331><br>\n<https://github.com/code-423n4/2024-02-ai-arena/blob/main/src/MergingPool.sol#L139-L167>\n\n*   Fighter created by mintFromMergingPool can have arbitrary weight and element like 0 or 2&ast;&ast;256 - 1\n*   Invalid weight and element could greatly affect AI Arena battles.\n\n### Proof of Concept\n\nWhen someone claim their nft rewards from MergingPool, they can input `customeAttributes` and create fighters with arbitrary values since currently there is no check on `customeAttributes` and it could varies from 0 to 2&ast;&ast;256 - 1 (type(uint256).max):\n\n<Details>\n\n```solidity\nfunction claimRewards(\n        string[] calldata modelURIs, \n        string[] calldata modelTypes,\n        uint256[2][] calldata customAttributes\n    ) \n        external \n    {\n     ....\n        \n             _fighterFarmInstance.mintFromMergingPool(\n                        msg.sender,\n                        modelURIs[claimIndex],\n                        modelTypes[claimIndex],\n                        customAttributes[claimIndex]\n                    );\n                   \n          \n    ....\n    }\n\nfunction mintFromMergingPool(\n        address to, \n        string calldata modelHash, \n        string calldata modelType, \n        uint256[2] calldata customAttributes\n    ) \n        public \n    {\n        require(msg.sender == _mergingPoolAddress);\n        _createNewFighter(\n            to, \n            uint256(keccak256(abi.encode(msg.sender, fighters.length))), \n            modelHash, \n            modelType,\n            0,\n            0,\n            customAttributes\n        );\n    }\n```\n</details>\n\nThis allow creating fighters with element and weight range from 0 to 2&ast;&ast;256 - 1 and can have negative impact on AI Arena matches according to the doc here <https://docs.aiarena.io/gaming-competition/nft-makeup>, for example:\n\n*   Weight is described in the doc as `used to calculate how far the fighter moves when being knocked back.`. If an nft has extremely large weight like 2&ast;&ast;256- 1, then it could never be knocked back\n*   Element can only be one of Fire, Electricity or Water, an nft with element outside of this list could be created.\n\nBelow is a POC, save the test case to contract `MergingPoolTest` under file `test/MergingPool.t.sol` and run it using command:\n`forge test --match-path test/MergingPool.t.sol --match-test testClaimRewardsArbitraryElementAndWeight -vvvv`\n\n<details>\n\n```solidity\nfunction testClaimRewardsArbitraryElementAndWeight() public {\n        _mintFromMergingPool(_ownerAddress);\n        _mintFromMergingPool(_DELEGATED_ADDRESS);\n        assertEq(_fighterFarmContract.ownerOf(0), _ownerAddress);\n        assertEq(_fighterFarmContract.ownerOf(1), _DELEGATED_ADDRESS);\n        uint256[] memory _winners = new uint256[](2);\n        _winners[0] = 0;\n        _winners[1] = 1;\n        // winners of roundId 0 are picked\n        _mergingPoolContract.pickWinner(_winners);\n        assertEq(_mergingPoolContract.isSelectionComplete(0), true);\n        assertEq(_mergingPoolContract.winnerAddresses(0, 0) == _ownerAddress, true);\n        // winner matches ownerOf tokenId\n        assertEq(_mergingPoolContract.winnerAddresses(0, 1) == _DELEGATED_ADDRESS, true);\n        string[] memory _modelURIs = new string[](2);\n        _modelURIs[0] = \"ipfs://bafybeiaatcgqvzvz3wrjiqmz2ivcu2c5sqxgipv5w2hzy4pdlw7hfox42m\";\n        _modelURIs[1] = \"ipfs://bafybeiaatcgqvzvz3wrjiqmz2ivcu2c5sqxgipv5w2hzy4pdlw7hfox42m\";\n        string[] memory _modelTypes = new string[](2);\n        _modelTypes[0] = \"original\";\n        _modelTypes[1] = \"original\";\n        uint256[2][] memory _customAttributes = new uint256[2][](2);\n        _customAttributes[0][0] = uint256(0);\n        _customAttributes[0][1] = uint256(type(uint256).max);\n        _customAttributes[1][0] = uint256(type(uint256).max);\n        _customAttributes[1][1] = uint256(0);\n        // winners of roundId 1 are picked\n        _mergingPoolContract.pickWinner(_winners);\n        // winner claims rewards for previous roundIds\n        _mergingPoolContract.claimRewards(_modelURIs, _modelTypes, _customAttributes);\n\n        // Fighter 2 has 2**256 weight and element = 0\n        (, ,uint256 weight , uint256 element , , , ) = _fighterFarmContract.getAllFighterInfo(2);\n        assertEq(weight, 2**256 - 1);\n        assertEq(element, 0);\n\n        // Fighter 3 has 0 weight and 2**256 element\n        (, , weight ,  element , , , ) = _fighterFarmContract.getAllFighterInfo(3);\n        assertEq(weight, 0);\n        assertEq(element, 2**256 - 1);\n\n    }\n```\n\n</details>\n\n### Recommended Mitigation Steps\n\nI recommend checking `customAttributes` in function `mintFromMergingPool` and only restrict `weight` and `element` in predefined ranges. For example, weight must be in range \\[65, 95], element must be in range \\[0,2].\n\n**[brandinho (AI Arena) confirmed via duplicate issue \\#1670](https://github.com/code-423n4/2024-02-ai-arena-findings/issues/1670#issuecomment-1985801932)**\n\n**[AI Arena mitigated](https://github.com/code-423n4/2024-04-ai-arena-mitigation?tab=readme-ov-file#scope):**\n> https://github.com/ArenaX-Labs/2024-02-ai-arena-mitigation/pull/16\n\n**Status:** Not fully mitigated. Full details in reports from [fnanni](https://github.com/code-423n4/2024-04-ai-arena-mitigation-findings/issues/8) and niser93 ([1](https://github.com/code-423n4/2024-04-ai-arena-mitigation-findings/issues/29), [2](https://github.com/code-423n4/2024-04-ai-arena-mitigation-findings/issues/13)), and also included in the [Mitigation Review](#mitigation-review) section below.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-02-ai-arena",
  "Code": [
    {
      "filename": "src/FighterFarm.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport { FighterOps } from \"./FighterOps.sol\";\nimport { Verification } from \"./Verification.sol\";\nimport { AAMintPass } from \"./AAMintPass.sol\";\nimport { AiArenaHelper } from \"./AiArenaHelper.sol\";\nimport { Neuron } from \"./Neuron.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\n\n/// @title AI Arena Fighter NFT\n/// @author ArenaX Labs Inc.\n/// @notice This contract manages the creation, ownership, and redemption of AI Arena Fighter NFTs,\n/// including the ability to mint new NFTs from a merging pool or through the redemption of mint passes.\ncontract FighterFarm is ERC721, ERC721Enumerable {\n\n    /*//////////////////////////////////////////////////////////////\n                                EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Event emitted when a fighter is locked and thus cannot be traded.\n    event Locked(uint256 tokenId);\n\n    /// @notice Event emitted when a fighter is unlocked and can be traded.\n    event Unlocked(uint256 tokenId);\n\n    /*//////////////////////////////////////////////////////////////\n                            STATE VARIABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The maximum amount of fighters owned by an address.\n    uint8 public constant MAX_FIGHTERS_ALLOWED = 10;\n\n    /// @notice The maximum amount of rerolls for each fighter.\n    uint8[2] public maxRerollsAllowed = [3, 3];\n\n    /// @notice The cost ($NRN) to reroll a fighter.\n    uint256 public rerollCost = 1000 * 10**18;    \n\n    /// @notice Stores the current generation for each fighter type.\n    uint8[2] public generation = [0, 0];\n\n    /// @notice Aggregate number of training sessions recorded.\n    uint32 public totalNumTrained;\n\n    /// @notice The address of treasury.\n    address public treasuryAddress;\n\n    /// The address that has owner privileges (initially the contract deployer).\n    address _ownerAddress;\n\n    /// The address responsible for setting token URIs and signing fighter claim messages.\n    address _delegatedAddress;\n\n    /// The address of the Merging Pool contract.\n    address _mergingPoolAddress;\n\n    /// @dev Instance of the AI Arena Helper contract.\n    AiArenaHelper _aiArenaHelperInstance;\n\n    /// @dev Instance of the AI Arena Mintpass contract (ERC721).\n    AAMintPass _mintpassInstance;\n\n    /// @dev Instance of the Neuron contract (ERC20).\n    Neuron _neuronInstance;\n\n    /// @notice List of all fighter structs, accessible by using tokenId as index.\n    FighterOps.Fighter[] public fighters;\n\n    /*//////////////////////////////////////////////////////////////\n                                MAPPINGS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mapping to keep track of whether a tokenId has staked or not.\n    mapping(uint256 => bool) public fighterStaked;\n\n    /// @notice Mapping to keep track of how many times an nft has been re-rolled.\n    mapping(uint256 => uint8) public numRerolls;\n\n    /// @notice Mapping to indicate which addresses are able to stake fighters.\n    mapping(address => bool) public hasStakerRole;\n\n    /// @notice Mapping of number elements by generation.\n    mapping(uint8 => uint8) public numElements;\n\n    /// @notice Maps address to fighter type to return the number of NFTs claimed.\n    mapping(address => mapping(uint8 => uint8)) public nftsClaimed;\n\n    /// @notice Mapping of tokenId to number of times trained.\n    mapping(uint256 => uint32) public numTrained;\n\n    /// @notice Mapping to keep track of tokenIds and their URI.\n    mapping(uint256 => string) private _tokenURIs;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Sets the owner address, the delegated address.\n    /// @param ownerAddress Address of contract deployer.\n    /// @param delegatedAddress Address of delegated signer for messages.\n    /// @param treasuryAddress_ Community treasury address.\n    constructor(address ownerAddress, address delegatedAddress, address treasuryAddress_)\n        ERC721(\"AI Arena Fighter\", \"FTR\")\n    {\n        _ownerAddress = ownerAddress;\n        _delegatedAddress = delegatedAddress;\n        treasuryAddress = treasuryAddress_;\n        numElements[0] = 3;\n    } \n\n    /*//////////////////////////////////////////////////////////////\n                            EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Transfers ownership from one address to another.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param newOwnerAddress The address of the new owner\n    function transferOwnership(address newOwnerAddress) external {\n        require(msg.sender == _ownerAddress);\n        _ownerAddress = newOwnerAddress;\n    }\n\n    /// @notice Increase the generation of the specified fighter type.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param fighterType Type of fighter either 0 or 1 (champion or dendroid).\n    /// @return Generation count of the fighter type.\n    function incrementGeneration(uint8 fighterType) external returns (uint8) {\n        require(msg.sender == _ownerAddress);\n        generation[fighterType] += 1;\n        maxRerollsAllowed[fighterType] += 1;\n        return generation[fighterType];\n    }\n\n    /// @notice Adds a new address that is allowed to stake fighters on behalf of users.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param newStaker The address of the new staker\n    function addStaker(address newStaker) external {\n        require(msg.sender == _ownerAddress);\n        hasStakerRole[newStaker] = true;\n    }\n\n    /// @notice Instantiates the ai arena helper contract.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param aiArenaHelperAddress Address of new helper contract.\n    function instantiateAIArenaHelperContract(address aiArenaHelperAddress) external {\n        require(msg.sender == _ownerAddress);\n        _aiArenaHelperInstance = AiArenaHelper(aiArenaHelperAddress);\n    }\n\n    /// @notice Instantiates the mint pass contract.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param mintpassAddress The address of the new AAMintPass contract instance.\n    function instantiateMintpassContract(address mintpassAddress) external {\n        require(msg.sender == _ownerAddress);\n        _mintpassInstance = AAMintPass(mintpassAddress);\n    }\n\n    /// @notice Instantiates the neuron contract.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param neuronAddress The address of the new Neuron contract instance.\n    function instantiateNeuronContract(address neuronAddress) external {\n        require(msg.sender == _ownerAddress);\n        _neuronInstance = Neuron(neuronAddress);\n    }\n\n    /// @notice Sets the merging pool contract address.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param mergingPoolAddress Address of the new Merging Pool contract.\n    function setMergingPoolAddress(address mergingPoolAddress) external {\n        require(msg.sender == _ownerAddress);\n        _mergingPoolAddress = mergingPoolAddress;\n    }\n\n    /// @notice Sets the tokenURI for the given tokenId.\n    /// @dev Only the delegated address is authorized to call this function.\n    /// @param tokenId The ID of the token to set the URI for.\n    /// @param newTokenURI The new URI to set for the given token.\n    function setTokenURI(uint256 tokenId, string calldata newTokenURI) external {\n        require(msg.sender == _delegatedAddress);\n        _tokenURIs[tokenId] = newTokenURI;\n    }\n\n    /// @notice Enables users to claim a pre-determined number of fighters. \n    /// @dev The function verifies the message signature is from the delegated address.\n    /// @param numToMint Array specifying the number of fighters to be claimed for each fighter type.\n    /// @param signature Signature of the claim message.\n    /// @param modelHashes Array of hashes representing the machine learning models for each fighter.\n    /// @param modelTypes Array of machine learning model types for each fighter.\n    function claimFighters(\n        uint8[2] calldata numToMint,\n        bytes calldata signature,\n        string[] calldata modelHashes,\n        string[] calldata modelTypes\n    ) \n        external \n    {\n        bytes32 msgHash = bytes32(keccak256(abi.encode(\n            msg.sender, \n            numToMint[0], \n            numToMint[1],\n            nftsClaimed[msg.sender][0],\n            nftsClaimed[msg.sender][1]\n        )));\n        require(Verification.verify(msgHash, signature, _delegatedAddress));\n        uint16 totalToMint = uint16(numToMint[0] + numToMint[1]);\n        require(modelHashes.length == totalToMint && modelTypes.length == totalToMint);\n        nftsClaimed[msg.sender][0] += numToMint[0];\n        nftsClaimed[msg.sender][1] += numToMint[1];\n        for (uint16 i = 0; i < totalToMint; i++) {\n            _createNewFighter(\n                msg.sender, \n                uint256(keccak256(abi.encode(msg.sender, fighters.length))),\n                modelHashes[i], \n                modelTypes[i],\n                i < numToMint[0] ? 0 : 1,\n                0,\n                [uint256(100), uint256(100)]\n            );\n        }\n    }\n\n    /// @notice Burns multiple mint passes in exchange for fighter NFTs.\n    /// @dev This function requires the length of all input arrays to be equal.\n    /// @dev Each input array must correspond to the same index, i.e., the first element in each \n    /// array belongs to the same mint pass, and so on.\n    /// @param mintpassIdsToBurn Array of mint pass IDs to be burned for each fighter to be minted.\n    /// @param mintPassDnas Array of DNA strings of the mint passes to be minted as fighters.\n    /// @param fighterTypes Array of fighter types corresponding to the fighters being minted.\n    /// @param modelHashes Array of ML model hashes corresponding to the fighters being minted. \n    /// @param modelTypes Array of ML model types corresponding to the fighters being minted.\n    function redeemMintPass(\n        uint256[] calldata mintpassIdsToBurn,\n        uint8[] calldata fighterTypes,\n        uint8[] calldata iconsTypes,\n        string[] calldata mintPassDnas,\n        string[] calldata modelHashes,\n        string[] calldata modelTypes\n    ) \n        external \n    {\n        require(\n            mintpassIdsToBurn.length == mintPassDnas.length && \n            mintPassDnas.length == fighterTypes.length && \n            fighterTypes.length == modelHashes.length &&\n            modelHashes.length == modelTypes.length\n        );\n        for (uint16 i = 0; i < mintpassIdsToBurn.length; i++) {\n            require(msg.sender == _mintpassInstance.ownerOf(mintpassIdsToBurn[i]));\n            _mintpassInstance.burn(mintpassIdsToBurn[i]);\n            _createNewFighter(\n                msg.sender, \n                uint256(keccak256(abi.encode(mintPassDnas[i]))), \n                modelHashes[i], \n                modelTypes[i],\n                fighterTypes[i],\n                iconsTypes[i],\n                [uint256(100), uint256(100)]\n            );\n        }\n    }\n\n    /// @notice Update the staking status of the fighter associated with the given token ID.\n    /// @dev Only addresses which have the staker role are authorized to call this function.\n    /// @param tokenId The ID of the fighter to update the staking status for.\n    /// @param stakingStatus The new staking status to set for the fighter.\n    function updateFighterStaking(uint256 tokenId, bool stakingStatus) external {\n        require(hasStakerRole[msg.sender]);\n        fighterStaked[tokenId] = stakingStatus;\n        if (stakingStatus) {\n            emit Locked(tokenId);\n        } else {\n            emit Unlocked(tokenId);\n        }\n    }\n\n    /// @notice Update the model for a token ID.\n    /// @dev Only the owner of the fighter can call this function.\n    /// @param tokenId The ID of the fighter to update the model for.\n    /// @param modelHash The hash of the machine learning model.\n    /// @param modelType The type of machine learning model.\n    function updateModel(\n        uint256 tokenId, \n        string calldata modelHash,\n        string calldata modelType\n    ) \n        external\n    {\n        require(msg.sender == ownerOf(tokenId));\n        fighters[tokenId].modelHash = modelHash;\n        fighters[tokenId].modelType = modelType;\n        numTrained[tokenId] += 1;\n        totalNumTrained += 1;\n    }\n\n    /// @notice Checks whether the given token ID exists.\n    /// @param tokenId The ID of the fighter to check for existence.\n    function doesTokenExist(uint256 tokenId) external view returns (bool) {\n        return _exists(tokenId);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            PUBLIC FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mints a new fighter from the merging pool.\n    /// @dev Only the merging pool contract address is authorized to call this function.\n    /// @param to The address that the new fighter will be assigned to.\n    /// @param modelHash The hash of the ML model associated with the fighter.\n    /// @param modelType The type of the ML model associated with the fighter.\n    /// @param customAttributes Array with [element, weight] of the newly created fighter.\n    function mintFromMergingPool(\n        address to, \n        string calldata modelHash, \n        string calldata modelType, \n        uint256[2] calldata customAttributes\n    ) \n        public \n    {\n        require(msg.sender == _mergingPoolAddress);\n        _createNewFighter(\n            to, \n            uint256(keccak256(abi.encode(msg.sender, fighters.length))), \n            modelHash, \n            modelType,\n            0,\n            0,\n            customAttributes\n        );\n    }\n\n    /// @notice Transfer NFT ownership from one address to another.\n    /// @dev Add a custom check for an ability to transfer the fighter.\n    /// @param from Address of the current owner.\n    /// @param to Address of the new owner.\n    /// @param tokenId ID of the fighter being transferred.\n    function transferFrom(\n        address from, \n        address to, \n        uint256 tokenId\n    ) \n        public \n        override(ERC721, IERC721)\n    {\n        require(_ableToTransfer(tokenId, to));\n        _transfer(from, to, tokenId);\n    }\n\n    /// @notice Safely transfers an NFT from one address to another.\n    /// @dev Add a custom check for an ability to transfer the fighter.\n    /// @param from Address of the current owner.\n    /// @param to Address of the new owner.\n    /// @param tokenId ID of the fighter being transferred.\n    function safeTransferFrom(\n        address from, \n        address to, \n        uint256 tokenId\n    ) \n        public \n        override(ERC721, IERC721)\n    {\n        require(_ableToTransfer(tokenId, to));\n        _safeTransfer(from, to, tokenId, \"\");\n    }\n\n    /// @notice Rolls a new fighter with random traits.\n    /// @param tokenId ID of the fighter being re-rolled.\n    /// @param fighterType The fighter type.\n    function reRoll(uint8 tokenId, uint8 fighterType) public {\n        require(msg.sender == ownerOf(tokenId));\n        require(numRerolls[tokenId] < maxRerollsAllowed[fighterType]);\n        require(_neuronInstance.balanceOf(msg.sender) >= rerollCost, \"Not enough NRN for reroll\");\n\n        _neuronInstance.approveSpender(msg.sender, rerollCost);\n        bool success = _neuronInstance.transferFrom(msg.sender, treasuryAddress, rerollCost);\n        if (success) {\n            numRerolls[tokenId] += 1;\n            uint256 dna = uint256(keccak256(abi.encode(msg.sender, tokenId, numRerolls[tokenId])));\n            (uint256 element, uint256 weight, uint256 newDna) = _createFighterBase(dna, fighterType);\n            fighters[tokenId].element = element;\n            fighters[tokenId].weight = weight;\n            fighters[tokenId].physicalAttributes = _aiArenaHelperInstance.createPhysicalAttributes(\n                newDna,\n                generation[fighterType],\n                fighters[tokenId].iconsType,\n                fighters[tokenId].dendroidBool\n            );\n            _tokenURIs[tokenId] = \"\";\n        }\n    }    \n\n    /// @notice Returns the URI where the contract metadata is stored.\n    /// @return URI where the contract metadata is stored.\n    function contractURI() public pure returns (string memory) {\n        return \"ipfs://bafybeifztjs4yuwhqi7bvzhw2ufksynkoiwxss2gnti6j4v25l7iwz7y44\";\n    }\n\n    /// @notice Returns the URI where the token metadata is stored.\n    /// @param tokenId The ID of the fighter.\n    /// @return URI where the token metadata is stored.\n    function tokenURI(uint256 tokenId) public view override(ERC721) returns (string memory) {\n        return _tokenURIs[tokenId];\n    }\n\n    /// @notice Returns whether a given interface is supported by this contract.\n    /// @dev Calls ERC721.supportsInterface.\n    /// @param _interfaceId The interface ID.\n    /// @return Bool whether the interface is supported by this contract.\n    function supportsInterface(bytes4 _interfaceId)\n        public\n        view\n        override(ERC721, ERC721Enumerable)\n        returns (bool)\n    {\n        return super.supportsInterface(_interfaceId);\n    }\n\n    /// @notice Returns all information related to the specified fighter token ID.\n    /// @param tokenId The unique identifier for the fighter token.\n    function getAllFighterInfo(\n        uint256 tokenId\n    )\n        public\n        view\n        returns (\n            address,\n            uint256[6] memory,\n            uint256,\n            uint256,\n            string memory,\n            string memory,\n            uint16\n        )\n    {\n        return FighterOps.viewFighterInfo(fighters[tokenId], ownerOf(tokenId));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Hook that is called before a token transfer.\n    /// @param from The address transferring the token.\n    /// @param to The address receiving the token.\n    /// @param tokenId The ID of the NFT being transferred.\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId)\n        internal\n        override(ERC721, ERC721Enumerable)\n    {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            PRIVATE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Creates the base attributes for the fighter.\n    /// @param dna The dna of the fighter.\n    /// @param fighterType The type of the fighter.\n    /// @return Attributes of the new fighter: element, weight, and dna.\n    function _createFighterBase(\n        uint256 dna, \n        uint8 fighterType\n    ) \n        private \n        view \n        returns (uint256, uint256, uint256) \n    {\n        uint256 element = dna % numElements[generation[fighterType]];\n        uint256 weight = dna % 31 + 65;\n        uint256 newDna = fighterType == 0 ? dna : uint256(fighterType);\n        return (element, weight, newDna);\n    }\n\n    /// @notice Creates a new fighter and mints an NFT to the specified address.\n    /// @param to The address to mint the new NFT to.\n    /// @param dna The DNA of the new fighter.\n    /// @param modelHash The hash of the ML model.\n    /// @param modelType The type of the ML model.\n    /// @param fighterType The type of fighter to create.\n    /// @param iconsType Type of icons fighter (0 means it's not an icon).\n    /// @param customAttributes Array with [element, weight] of the newly created fighter.\n    function _createNewFighter(\n        address to, \n        uint256 dna, \n        string memory modelHash,\n        string memory modelType, \n        uint8 fighterType,\n        uint8 iconsType,\n        uint256[2] memory customAttributes\n    ) \n        private \n    {  \n        require(balanceOf(to) < MAX_FIGHTERS_ALLOWED);\n        uint256 element; \n        uint256 weight;\n        uint256 newDna;\n        if (customAttributes[0] == 100) {\n            (element, weight, newDna) = _createFighterBase(dna, fighterType);\n        }\n        else {\n            element = customAttributes[0];\n            weight = customAttributes[1];\n            newDna = dna;\n        }\n        uint256 newId = fighters.length;\n\n        bool dendroidBool = fighterType == 1;\n        FighterOps.FighterPhysicalAttributes memory attrs = _aiArenaHelperInstance.createPhysicalAttributes(\n            newDna,\n            generation[fighterType],\n            iconsType,\n            dendroidBool\n        );\n        fighters.push(\n            FighterOps.Fighter(\n                weight,\n                element,\n                attrs,\n                newId,\n                modelHash,\n                modelType,\n                generation[fighterType],\n                iconsType,\n                dendroidBool\n            )\n        );\n        _safeMint(to, newId);\n        FighterOps.fighterCreatedEmitter(newId, weight, element, generation[fighterType]);\n    }\n\n    /// @notice Check if the transfer of a specific token is allowed.\n    /// @dev Cannot receive another fighter if the user already has the maximum amount.\n    /// @dev Additionally, users cannot trade fighters that are currently staked.\n    /// @param tokenId The token ID of the fighter being transferred.\n    /// @param to The address of the receiver.\n    /// @return Bool whether the transfer is allowed or not.\n    function _ableToTransfer(uint256 tokenId, address to) private view returns(bool) {\n        return (\n          _isApprovedOrOwner(msg.sender, tokenId) &&\n          balanceOf(to) < MAX_FIGHTERS_ALLOWED &&\n          !fighterStaked[tokenId]\n        );\n    }\n}"
    },
    {
      "filename": "src/MergingPool.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport { FighterFarm } from \"./FighterFarm.sol\";\n\n/// @title MergingPool\n/// @author ArenaX Labs Inc.\n/// @notice This contract allows users to potentially earn a new fighter NFT.\ncontract MergingPool {\n\n    /*//////////////////////////////////////////////////////////////\n                                EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Event emitted when merging pool points are added.\n    event PointsAdded(uint256 tokenId, uint256 points);\n\n    /// @notice Event emitted when claimed.\n    event Claimed(address claimer, uint32 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            STATE VARIABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Number of winners per period.\n    uint256 public winnersPerPeriod = 2;\n\n    /// @notice Current roundId.\n    uint256 public roundId = 0;\n\n    /// @notice Total points.\n    uint256 public totalPoints = 0;    \n\n    /// The address that has owner privileges (initially the contract deployer).\n    address _ownerAddress;\n\n    /// The address of the ranked battle contract.\n    address _rankedBattleAddress;\n\n    /// @dev The fighter farm contract instance.\n    FighterFarm _fighterFarmInstance;\n\n    /*//////////////////////////////////////////////////////////////\n                                MAPPINGS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Maps the user address to the number of rounds they've claimed for\n    mapping(address => uint32) public numRoundsClaimed;\n\n    /// @notice Mapping of address to fighter points.\n    mapping(uint256 => uint256) public fighterPoints;\n\n    /// @notice Mapping of roundId to winner addresses list.\n    mapping(uint256 => address[]) public winnerAddresses;    \n\n    /// @notice Mapping of round id to an indication of whether winners have been selected yet.\n    mapping(uint256 => bool) public isSelectionComplete;\n\n    /// @notice Mapping of address to admin status.\n    mapping(address => bool) public isAdmin;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Sets the address for the owner and ranked battle smart contract.\n    /// Instantiates the fighter farm contract and sets the owner to be an admin\n    /// @param ownerAddress Address of contract deployer.\n    /// @param rankedBattleAddress Address of ranked battle contract.\n    /// @param fighterFarmAddress Address of fighter farm contract.\n    constructor(\n        address ownerAddress, \n        address rankedBattleAddress, \n        address fighterFarmAddress\n    ) {\n        _ownerAddress = ownerAddress;\n        _rankedBattleAddress = rankedBattleAddress;\n        _fighterFarmInstance = FighterFarm(fighterFarmAddress);\n        isAdmin[_ownerAddress] = true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Transfers ownership from one address to another.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param newOwnerAddress The address of the new owner\n    function transferOwnership(address newOwnerAddress) external {\n        require(msg.sender == _ownerAddress);\n        _ownerAddress = newOwnerAddress;\n    }\n\n    /// @notice Adjusts admin access for a user.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param adminAddress The address of the admin.\n    /// @param access Whether the address has admin access or not.\n    function adjustAdminAccess(address adminAddress, bool access) external {\n        require(msg.sender == _ownerAddress);\n        isAdmin[adminAddress] = access;\n    }   \n\n    /// @notice Change the number of winners per competition period.\n    /// @dev Only admins are authorized to call this function.\n    /// @param newWinnersPerPeriodAmount The new number of winners per period.\n    function updateWinnersPerPeriod(uint256 newWinnersPerPeriodAmount) external {\n        require(isAdmin[msg.sender]);\n        winnersPerPeriod = newWinnersPerPeriodAmount;\n    }    \n\n    /// @notice Allows the admin to pick the winners for the current round.\n    /// @dev Only admins are authorized to call this function.\n    /// @dev The number of winners must match the expected number of winners per period.\n    /// @dev The function will check that there are no existing winners for the current round.\n    /// @dev The function will update the winnerAddresses mapping with the addresses of the winners.\n    /// @dev The function will also reset the fighterPoints of the winners to zero.\n    /// @param winners The array of token IDs representing the winners.\n    function pickWinner(uint256[] calldata winners) external {\n        require(isAdmin[msg.sender]);\n        require(winners.length == winnersPerPeriod, \"Incorrect number of winners\");\n        require(!isSelectionComplete[roundId], \"Winners are already selected\");\n        uint256 winnersLength = winners.length;\n        address[] memory currentWinnerAddresses = new address[](winnersLength);\n        for (uint256 i = 0; i < winnersLength; i++) {\n            currentWinnerAddresses[i] = _fighterFarmInstance.ownerOf(winners[i]);\n            totalPoints -= fighterPoints[winners[i]];\n            fighterPoints[winners[i]] = 0;\n        }\n        winnerAddresses[roundId] = currentWinnerAddresses;\n        isSelectionComplete[roundId] = true;\n        roundId += 1;\n    }\n\n    /// @notice Allows the user to batch claim rewards for multiple rounds.\n    /// @dev The user can only claim rewards once for each round.\n    /// @param modelURIs The array of model URIs corresponding to each round and winner address.\n    /// @param modelTypes The array of model types corresponding to each round and winner address.\n    /// @param customAttributes Array with [element, weight] of the newly created fighter.\n    function claimRewards(\n        string[] calldata modelURIs, \n        string[] calldata modelTypes,\n        uint256[2][] calldata customAttributes\n    ) \n        external \n    {\n        uint256 winnersLength;\n        uint32 claimIndex = 0;\n        uint32 lowerBound = numRoundsClaimed[msg.sender];\n        for (uint32 currentRound = lowerBound; currentRound < roundId; currentRound++) {\n            numRoundsClaimed[msg.sender] += 1;\n            winnersLength = winnerAddresses[currentRound].length;\n            for (uint32 j = 0; j < winnersLength; j++) {\n                if (msg.sender == winnerAddresses[currentRound][j]) {\n                    _fighterFarmInstance.mintFromMergingPool(\n                        msg.sender,\n                        modelURIs[claimIndex],\n                        modelTypes[claimIndex],\n                        customAttributes[claimIndex]\n                    );\n                    claimIndex += 1;\n                }\n            }\n        }\n        if (claimIndex > 0) {\n            emit Claimed(msg.sender, claimIndex);\n        }\n    }\n\n    /// @notice Gets the unclaimed rewards for a specific address.\n    /// @param claimer The address of the claimer.\n    /// @return numRewards The amount of unclaimed fighters.\n    function getUnclaimedRewards(address claimer) external view returns(uint256) {\n        uint256 winnersLength;\n        uint256 numRewards = 0;\n        uint32 lowerBound = numRoundsClaimed[claimer];\n        for (uint32 currentRound = lowerBound; currentRound < roundId; currentRound++) {\n            winnersLength = winnerAddresses[currentRound].length;\n            for (uint32 j = 0; j < winnersLength; j++) {\n                if (claimer == winnerAddresses[currentRound][j]) {\n                    numRewards += 1;\n                }\n            }\n        }\n        return numRewards;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            PUBLIC FUNCTIONS\n    //////////////////////////////////////////////////////////////*/    \n\n    /// @notice Add merging pool points to a fighter.\n    /// @dev Only the rankedBattle contract address can call this function.\n    /// @param tokenId The ID of the fighter token.\n    /// @param points The number of points to be added to the fighter.\n    function addPoints(uint256 tokenId, uint256 points) public {\n        require(msg.sender == _rankedBattleAddress, \"Not Ranked Battle contract address\");\n        fighterPoints[tokenId] += points;\n        totalPoints += points;\n        emit PointsAdded(tokenId, points);\n    }\n\n    /// @notice Retrieves the points for multiple fighters up to the specified maximum token ID.\n    /// @param maxId The maximum token ID up to which the points will be retrieved.\n    /// @return An array of points corresponding to the fighters' token IDs.\n    function getFighterPoints(uint256 maxId) public view returns(uint256[] memory) {\n        uint256[] memory points = new uint256[](1);\n        for (uint256 i = 0; i < maxId; i++) {\n            points[i] = fighterPoints[i];\n        }\n        return points;\n    }\n}"
    }
  ]
}