{
  "Title": "M-9: stake() missing set lastEpochClaimed when userBalance equal 0",
  "Content": "# Issue M-9: stake() missing set lastEpochClaimed when userBalance equal 0 \n\nSource: https://github.com/sherlock-audit/2023-06-bond-judging/issues/108 \n\n## Found by \nDelvir0, TrungOre, Yuki, berndartmueller, bin2chen, ctf\\_sec\n## Summary\nbecause `stake()` don't  set ` lastEpochClaimed[user] = last epoch` if `userBalance` equal 0\nSo all new stake user must loop from 0 to `last epoch` for `_claimRewards()`\nAs the epoch gets bigger and bigger it will waste a lot of GAS, which may eventually lead to `GAS_OUT`\n\n## Vulnerability Detail\nin `stake()`,  when the first-time stake() only `rewardsPerTokenClaimed[msg.sender]`\nbut don't set `lastEpochClaimed[msg.sender]`\n\n```solidity\n    function stake(\n        uint256 amount_,\n        bytes calldata proof_\n    ) external nonReentrant requireInitialized updateRewards tryNewEpoch {\n...\n        uint256 userBalance = stakeBalance[msg.sender];\n        if (userBalance > 0) {\n            // Claim outstanding rewards, this will update the rewards per token claimed\n            _claimRewards();\n        } else {\n            // Initialize the rewards per token claimed for the user to the stored rewards per token\n@>          rewardsPerTokenClaimed[msg.sender] = rewardsPerTokenStored;\n        }\n\n        // Increase the user's stake balance and the total balance\n        stakeBalance[msg.sender] = userBalance + amount_;\n        totalBalance += amount_;\n\n        // Transfer the staked tokens from the user to this contract\n        stakedToken.safeTransferFrom(msg.sender, address(this), amount_);\n    }\n```\n\nso every new staker , needs claims from 0 \n```solidity\n    function _claimRewards() internal returns (uint256) {\n        // Claims all outstanding rewards for the user across epochs\n        // If there are unclaimed rewards from epochs where the option token has expired, the rewards are lost\n\n        // Get the last epoch claimed by the user\n@>      uint48 userLastEpoch = lastEpochClaimed[msg.sender];\n\n        // If the last epoch claimed is equal to the current epoch, then only try to claim for the current epoch\n        if (userLastEpoch == epoch) return _claimEpochRewards(epoch);\n\n        // If not, then the user has not claimed all rewards\n        // Start at the last claimed epoch because they may not have completely claimed that epoch\n        uint256 totalRewardsClaimed;\n@>     for (uint48 i = userLastEpoch; i <= epoch; i++) {\n            // For each epoch that the user has not claimed rewards for, claim the rewards\n            totalRewardsClaimed += _claimEpochRewards(i);\n        }\n\n        return totalRewardsClaimed;\n    }\n```\nWith each new addition of epoch, the new stake must consumes a lot of useless loops, from loop 0 to `last epoch`\nWhen `epoch` reaches a large size, it will result in GAS_OUT and the method cannot be executed\n\n## Impact\nWhen the `epoch` gradually increases, the new take will waste a lot of GAS\nWhen it is very large, it will cause GAS_OUT\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-06-bond/blob/main/options/src/fixed-strike/liquidity-mining/OTLM.sol#L324-L327\n\n## Tool used\n\nManual Review\n\n## Recommendation\n```solidity\n    function stake(\n        uint256 amount_,\n        bytes calldata proof_\n    ) external nonReentrant requireInitialized updateRewards tryNewEpoch {\n...\n        if (userBalance > 0) {\n            // Claim outstanding rewards, this will update the rewards per token claimed\n            _claimRewards();\n        } else {\n            // Initialize the rewards per token claimed for the user to the stored rewards per token\n            rewardsPerTokenClaimed[msg.sender] = rewardsPerTokenStored;\n+           lastEpochClaimed[msg.sender] = epoch;\n        }\n```\n\n\n\n\n## Discussion\n\n**Oighty**\n\nAgree with the proposed solution.\n\n**ctf-sec**\n\nGreat finding, agree with medium severity\n\n**Oighty**\n\nFix implemented at https://github.com/Bond-Protocol/options/pull/5\n\n**ctf-sec**\n\nWill look into this, seems all the duplicate suggest the fix:\n\n```solidity\n lastEpochClaimed[msg.sender] = epoch;\n```\n\nbut the implemented fix is \n\n```solidity\n lastEpochClaimed[msg.sender] = epoch -1\n```\n\nmaybe testing can help as well, just want to make sure there is no off-by-one issue o(╥﹏╥)o\n\n**Oighty**\n\n> Will look into this, seems all the duplicate suggest the fix:\n> \n> ```solidity\n>  lastEpochClaimed[msg.sender] = epoch;\n> ```\n> \n> but the implemented fix is\n> \n> ```solidity\n>  lastEpochClaimed[msg.sender] = epoch -1\n> ```\n> \n> maybe testing can help as well, just want to make sure there is no off-by-one issue o(╥﹏╥)o\n\nThe reason to set lastEpochClaimed to `epoch - 1` is that you want the user state to appear like they have claimed everything before the epoch they started staking on. They haven't claimed any tokens for the current epoch yet, so that would be inaccurate.\n\n**Oighty**\n\n@ctf-sec did you have a chance to review this more?\n\n**ctf-sec**\n\nYes, fix looks good\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/99",
  "Code": [
    {
      "filename": "options/src/fixed-strike/liquidity-mining/OTLM.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.15;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {IBondOracle} from \"src/interfaces/IBondOracle.sol\";\nimport {IAllowlist} from \"src/interfaces/IAllowlist.sol\";\n\nimport {FixedStrikeOptionToken} from \"src/fixed-strike/FixedStrikeOptionToken.sol\";\nimport {IFixedStrikeOptionTeller} from \"src/interfaces/IFixedStrikeOptionTeller.sol\";\nimport {TransferHelper} from \"src/lib/TransferHelper.sol\";\n\n/// @dev The purpose of Option Token Liquidity Mining is to allow the protocol to\n///      re-capture some of the value from liquidity mining rewards when LPs realize profit.\n///      Additionally, it can cap the amount of sell pressure on a protocols token in a down\n///      market by limiting the profitability of exercising option tokens to above the strike price.\n///\n///      The OTLM contract implements a version of this using fixed strike call options.\n///      Protocols can deploy an OTLM contract with their specific configuration of staked\n///      token and option paramters. The contract implements epoch-based staking rewards to\n///      issue new option tokens at fixed time intervals and at a new strike price based on\n///      the configuration when an epoch transitions. The owner of the contract can update\n///      various staking and option token parameters over time to adjust their rewards program.\n///      The owner can also optionally designate an Allowlist contract to limit which users can\n///      can stake in the contract. The allowlist should conform to the IAllowlist interface.\n///\n///      Users can deposit the configured stakedToken into the contract to earn rewards.\n///      Rewards are continuously accrued based on the configured reward rate and the total\n///      balance of staked tokens in the contract. Any user action updates the reward calculations.\n///      Additionally, user actions can trigger a new epoch start, which will earn them additional\n///      option tokens in the form of the epoch transition reward for paying the extra gas.\n///      Users can claim their outstanding rewards from all epochs or from the next unclaimed epoch.\n///      If the option token for a specific epoch has expired, the user will not receive any rewards\n///      for that period since they are now worthless.\nabstract contract OTLM is Owned, ReentrancyGuard {\n    using TransferHelper for ERC20;\n\n    /* ========== ERRORS ========== */\n    error OTLM_InvalidParams();\n    error OTLM_InvalidAmount();\n    error OTLM_InvalidEpoch();\n    error OTLM_ZeroBalance();\n    error OTLM_PreviousUnclaimedEpoch();\n    error OTLM_AlreadyInitialized();\n    error OTLM_NotInitialized();\n    error OTLM_DepositsDisabled();\n    error OTLM_NotAllowed();\n\n    /* ========== EVENTS ========== */\n    event NewEpoch(uint48 indexed epoch_, FixedStrikeOptionToken optionToken_);\n\n    /* ========== STATE VARIABLES ========== */\n\n    // Staking parameters\n    /// @notice Token that is staked in the OTLM contract\n    ERC20 public immutable stakedToken;\n    uint8 internal immutable stakedTokenDecimals;\n\n    /// @notice Whether users can deposit staking tokens into the OTLM contract at the current time\n    bool public depositsEnabled;\n\n    /// @notice Whether the OTLM contract has been initialized\n    /// @dev    No settings can be changed or tokens deposited before the OTLM contract is initialized\n    bool public initialized;\n\n    // Allowlist\n    /// @notice (Optional) Address of the allowlist contract which determines which addresses are allowed to interact with the OTLM contract\n    IAllowlist public allowlist;\n\n    // Option Token Parameters\n    /// @notice Option Teller contract that is used to deploy and create option tokens\n    IFixedStrikeOptionTeller public immutable optionTeller;\n\n    /// @notice Token that stakers receive call options for\n    ERC20 public immutable payoutToken;\n\n    /// @notice Token that stakers must pay to exercise the call options they receive\n    ERC20 public quoteToken;\n\n    /// @notice Amount of time (in seconds) from option token deployment to when it can be exercised\n    uint48 public timeUntilEligible;\n\n    /// @notice Amount of time (in seconds) from when the option token is eligible to when it expires\n    uint48 public eligibleDuration;\n\n    /// @notice Address that will receive the quote tokens when an option is exercised\n    address public receiver;\n\n    // Staking epochs\n\n    /// @notice Current staking epoch\n    uint48 public epoch;\n\n    /// @notice Staking epoch duration\n    uint48 public epochDuration;\n\n    /// @notice Timestamp of the start of the current staking epoch\n    uint48 public epochStart;\n\n    // Staking rewards\n\n    /// @notice Amount of time (in seconds) that the reward rate is distributed over\n    uint48 public constant REWARD_PERIOD = uint48(1 days);\n\n    /// @notice Timestamp when the stored rewards per token was last updated\n    uint48 public lastRewardUpdate;\n\n    /// @notice Amount of option tokens rewarded per reward period\n    uint256 public rewardRate;\n\n    /// @notice Global reward distribution variable, used to calculate user rewards\n    uint256 public rewardsPerTokenStored;\n\n    /// @notice Amount of option tokens that are rewarded for starting a new epoch\n    uint256 public epochTransitionReward;\n\n    /// @notice Rewards Per Token value at the start of each epoch\n    mapping(uint48 => uint256) public epochRewardsPerTokenStart;\n\n    // Stake balances\n\n    /// @notice Total amount of staked tokens currently in the contract\n    uint256 public totalBalance;\n\n    /// @notice Mapping of staker address to their staked balance\n    mapping(address => uint256) public stakeBalance;\n\n    /// @notice Mapping of staker address to the rewards per token they have claimed\n    mapping(address => uint256) public rewardsPerTokenClaimed;\n\n    /// @notice Mapping of staker address to the last epoch they claimed rewards for\n    mapping(address => uint48) public lastEpochClaimed;\n\n    /// @notice Mapping of epochs to the option tokens that was rewarded for that epoch\n    mapping(uint48 => FixedStrikeOptionToken) public epochOptionTokens;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    /// @param owner_        Address of the owner of the OTLM contract\n    /// @param stakedToken_  Token that is staked in the OTLM contract\n    /// @param optionTeller_ Option Teller contract that is used by the OTLM contract to deploy and create option tokens\n    /// @param payoutToken_  Token that stakers receive call options for\n    constructor(\n        address owner_,\n        ERC20 stakedToken_,\n        IFixedStrikeOptionTeller optionTeller_,\n        ERC20 payoutToken_\n    ) Owned(owner_) {\n        // Validate parameters\n        if (\n            owner_ == address(0) ||\n            address(stakedToken_) == address(0) ||\n            address(stakedToken_).code.length == 0 ||\n            address(optionTeller_) == address(0) ||\n            address(optionTeller_).code.length == 0 ||\n            address(payoutToken_) == address(0) ||\n            address(payoutToken_).code.length == 0\n        ) revert OTLM_InvalidParams();\n\n        // Set staking token parameters\n        stakedToken = stakedToken_;\n        stakedTokenDecimals = stakedToken_.decimals();\n\n        // Set option token parameters\n        optionTeller = optionTeller_;\n        payoutToken = payoutToken_;\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    /// @notice Modifier that updates the stored rewards per token before a function is executed\n    /// @dev    This modifier should be placed on any function where rewards are claimed or staked tokens are deposited/withdrawn.\n    /// @dev    Additionally, it should be placed on any functions that modify the reward parameters of the OTLM contract.\n    modifier updateRewards() {\n        // Update the rewards per token and last reward timestamp\n        if (lastRewardUpdate != uint48(block.timestamp)) {\n            rewardsPerTokenStored = currentRewardsPerToken();\n            lastRewardUpdate = uint48(block.timestamp);\n        }\n        _;\n    }\n\n    /// @notice Modifier that tries to start a new epoch before a function is executed and rewards the caller for doing so\n    modifier tryNewEpoch() {\n        // If the epoch has ended, try to start a new one\n        if (uint48(block.timestamp) >= epochStart + epochDuration) {\n            _startNewEpoch();\n            // Issue reward to caller for starting the new epoch\n            payoutToken.approve(address(optionTeller), epochTransitionReward);\n            FixedStrikeOptionToken optionToken = epochOptionTokens[epoch];\n            optionTeller.create(optionToken, epochTransitionReward);\n            ERC20(address(optionToken)).safeTransfer(msg.sender, epochTransitionReward);\n        }\n        _;\n    }\n\n    /// @notice Modifier that requires the OTLM contract to be initialized before a function is executed\n    modifier requireInitialized() {\n        if (!initialized) revert OTLM_NotInitialized();\n        _;\n    }\n\n    /* ========== INITIALIZATION ========== */\n\n    /// @notice Initializes the OTLM contract\n    /// @notice Only owner\n    /// @dev    This function can only be called once.\n    /// @dev    When the function completes, the contract is live. Users can start staking and claiming rewards.\n    /// @param quoteToken_            Token that stakers must pay to exercise the call options they receive\n    /// @param timeUntilEligible_     Amount of time (in seconds) from option token deployment to when it can be exercised\n    /// @param eligibleDuration_      Amount of time (in seconds) from when the option token is eligible to when it expires\n    /// @param receiver_              Address that will receive the quote tokens when an option is exercised\n    ///                               IMPORTANT: receiver is the only address that can retrieve payout token collateral from expired options.\n    ///                               It must be able to call the `reclaim` function on the Option Teller contract.\n    /// @param epochDuration_         Staking epoch duration (in seconds)\n    /// @param epochTransitionReward_ Amount of option tokens that are rewarded for starting a new epoch\n    /// @param rewardRate_            Amount of option tokens rewarded per reward period (1 day)\n    /// @param allowlist_             Address of the allowlist contract that can be used to restrict who can stake in the OTLM contract.\n    ///                               If the zero address, then no allow list is used.\n    /// @param allowlistParams_       Parameters that are passed to the allowlist contract when this contract registers with it\n    /// @param other_                 Additional parameters that are required by specific implementations of the OTLM contract\n    function initialize(\n        ERC20 quoteToken_,\n        uint48 timeUntilEligible_,\n        uint48 eligibleDuration_,\n        address receiver_,\n        uint48 epochDuration_,\n        uint256 epochTransitionReward_,\n        uint256 rewardRate_,\n        IAllowlist allowlist_,\n        bytes calldata allowlistParams_,\n        bytes calldata other_\n    ) external onlyOwner {\n        // Revert if already initialized\n        if (initialized) revert OTLM_AlreadyInitialized();\n\n        // Validate parameters\n        // Quote token must be a contract and not the zero address\n        if (address(quoteToken_) == address(0) || address(quoteToken_).code.length == 0)\n            revert OTLM_InvalidParams();\n\n        // The eligible duration must be greater than the minimum option duration on the teller to be a valid option token\n        if (eligibleDuration_ < optionTeller.minOptionDuration()) revert OTLM_InvalidParams();\n\n        // The option token expiry must be greater than the epoch duration\n        if (timeUntilEligible_ + eligibleDuration_ < epochDuration_) revert OTLM_InvalidParams();\n\n        // The receiver cannot be the zero address\n        if (receiver_ == address(0)) revert OTLM_InvalidParams();\n\n        // If the allowlist is not the zero address, assume it's being used and register the contract\n        if (address(allowlist_) != address(0)) {\n            // Since an allowlist is being used, we must confirm it is a contract\n            if (address(allowlist_).code.length == 0) revert OTLM_InvalidParams();\n\n            // Store allowlist\n            allowlist = allowlist_;\n\n            // Register contract on allowlist, catch error if fails\n            try allowlist.register(allowlistParams_) {} catch {\n                revert OTLM_InvalidParams();\n            }\n        }\n\n        // Set option token parameters\n        quoteToken = quoteToken_;\n        timeUntilEligible = timeUntilEligible_;\n        eligibleDuration = eligibleDuration_;\n        receiver = receiver_;\n\n        // Set staking epoch parameters\n        epochDuration = epochDuration_;\n        epochTransitionReward = epochTransitionReward_;\n\n        // Set initial staking variables\n        // totalBalance = 0; // don't have to initialize to zero\n        // rewardsPerTokenStored = 0; // don't have to initialize to zero\n        depositsEnabled = true;\n        lastRewardUpdate = uint48(block.timestamp);\n        rewardRate = rewardRate_;\n\n        // Set initialized to true\n        initialized = true;\n\n        // Pass other parameters to initialize function for implementation specific logic\n        _initialize(other_);\n\n        // Starts the first epoch\n        _startNewEpoch();\n    }\n\n    // Override this function to add implementation specific initialization logic\n    function _initialize(bytes calldata params_) internal virtual;\n\n    /* ========== STAKING FUNCTIONS ========== */\n\n    /// @notice Deposit staking tokens into the contract to earn rewards\n    /// @notice Only callable if deposits are enabled\n    /// @notice Only callable if the user is allowed to stake per the allowlist\n    /// @notice May receive reward if calling triggers new epoch\n    /// @param amount_ Amount of staking tokens to deposit\n    /// @param proof_  Optional proof data for specific allowlist implementations\n    function stake(\n        uint256 amount_,\n        bytes calldata proof_\n    ) external nonReentrant requireInitialized updateRewards tryNewEpoch {\n        // Revert if deposits are disabled\n        if (!depositsEnabled) revert OTLM_DepositsDisabled();\n\n        // If allowlist configured, check if user is allowed to stake\n        if (address(allowlist) != address(0)) {\n            if (!allowlist.isAllowed(msg.sender, proof_)) revert OTLM_NotAllowed();\n        }\n\n        // Revert if deposit amount is zero to avoid zero transfers\n        if (amount_ == 0) revert OTLM_InvalidAmount();\n\n        // Get user balance, if non-zero, claim rewards before increasing stake\n        uint256 userBalance = stakeBalance[msg.sender];\n        if (userBalance > 0) {\n            // Claim outstanding rewards, this will update the rewards per token claimed\n            _claimRewards();\n        } else {\n            // Initialize the rewards per token claimed for the user to the stored rewards per token\n            rewardsPerTokenClaimed[msg.sender] = rewardsPerTokenStored;\n        }\n\n        // Increase the user's stake balance and the total balance\n        stakeBalance[msg.sender] = userBalance + amount_;\n        totalBalance += amount_;\n\n        // Transfer the staked tokens from the user to this contract\n        stakedToken.safeTransferFrom(msg.sender, address(this), amount_);\n    }\n\n    /// @notice Withdraw staking tokens from the contract\n    /// @notice May receive reward if calling triggers new epoch\n    /// @param amount_ Amount of staking tokens to withdraw\n    function unstake(uint256 amount_) external nonReentrant updateRewards tryNewEpoch {\n        // Get user balance and check that it's not zero\n        uint256 userBalance = stakeBalance[msg.sender];\n        if (userBalance == 0) revert OTLM_ZeroBalance();\n\n        // Check that amount_ is valid\n        if (amount_ > userBalance || amount_ == 0) revert OTLM_InvalidAmount();\n\n        // Claim rewards before decreasing stake\n        _claimRewards();\n\n        // Decrease the user's stake balance and the total balance\n        // Total balance cannot revert if the user value is valid\n        stakeBalance[msg.sender] = userBalance - amount_;\n        totalBalance -= amount_;\n\n        // Transfer the staked tokens from this contract to the user\n        stakedToken.safeTransfer(msg.sender, amount_);\n    }\n\n    /// @notice Withdraw entire balance of staking tokens from the contract\n    /// @notice May receive reward if calling triggers new epoch\n    function unstakeAll() external nonReentrant updateRewards tryNewEpoch {\n        // Get user balance and check that it's not zero\n        uint256 userBalance = stakeBalance[msg.sender];\n        if (userBalance == 0) revert OTLM_ZeroBalance();\n\n        // Claim rewards before decreasing stake\n        _claimRewards();\n\n        // Decrease the user's stake balance and the total balance\n        // Total balance cannot revert since all user balances are less than or equal to the total\n        stakeBalance[msg.sender] = 0;\n        totalBalance -= userBalance;\n\n        // Transfer the staked tokens from this contract to the user\n        stakedToken.safeTransfer(msg.sender, userBalance);\n    }\n\n    /// @notice Withdraw entire balance of staking tokens without updating or claiming outstanding rewards.\n    /// @notice Rewards will be lost if stake is withdrawn using this function. Only for emergency use.\n    function emergencyUnstakeAll() external nonReentrant {\n        // Get user balance and check that it's not zero\n        uint256 userBalance = stakeBalance[msg.sender];\n        if (userBalance == 0) revert OTLM_ZeroBalance();\n\n        // Rewards are not claimed and lost\n\n        // Decrease the user's stake balance and the total balance\n        // Total balance cannot revert since all user balances are less than or equal to the total\n        stakeBalance[msg.sender] = 0;\n        totalBalance -= userBalance;\n\n        // Transfer the staked tokens from this contract to the user\n        stakedToken.safeTransfer(msg.sender, userBalance);\n    }\n\n    /* ========== REWARD FUNCTIONS ========== */\n\n    /// @notice Claim all outstanding rewards for the user across epochs\n    function claimRewards() external nonReentrant updateRewards tryNewEpoch returns (uint256) {\n        // Revert if user has no stake\n        if (stakeBalance[msg.sender] == 0) revert OTLM_ZeroBalance();\n\n        // Claim all outstanding rewards\n        return _claimRewards();\n    }\n\n    function _claimRewards() internal returns (uint256) {\n        // Claims all outstanding rewards for the user across epochs\n        // If there are unclaimed rewards from epochs where the option token has expired, the rewards are lost\n\n        // Get the last epoch claimed by the user\n        uint48 userLastEpoch = lastEpochClaimed[msg.sender];\n\n        // If the last epoch claimed is equal to the current epoch, then only try to claim for the current epoch\n        if (userLastEpoch == epoch) return _claimEpochRewards(epoch);\n\n        // If not, then the user has not claimed all rewards\n        // Start at the last claimed epoch because they may not have completely claimed that epoch\n        uint256 totalRewardsClaimed;\n        for (uint48 i = userLastEpoch; i <= epoch; i++) {\n            // For each epoch that the user has not claimed rewards for, claim the rewards\n            totalRewardsClaimed += _claimEpochRewards(i);\n        }\n\n        return totalRewardsClaimed;\n    }\n\n    /// @notice Claim all outstanding rewards for the user for the next unclaimed epoch (and any remaining rewards from the previously claimed epoch)\n    function claimNextEpochRewards()\n        external\n        nonReentrant\n        updateRewards\n        tryNewEpoch\n        returns (uint256)\n    {\n        // Claims all outstanding rewards for the user on their next unclaimed epoch. Allows moving through epochs one txn at a time if desired or to avoid gas issues if a large number of epochs have passed.\n\n        // Revert if user has no stake\n        if (stakeBalance[msg.sender] == 0) revert OTLM_ZeroBalance();\n\n        // Get the last epoch claimed by the user\n        uint48 userLastEpoch = lastEpochClaimed[msg.sender];\n\n        // If the last epoch claimed is equal to the current epoch, then try to claim for the current epoch\n        if (userLastEpoch == epoch) return _claimEpochRewards(epoch);\n\n        // If not, then the user has not claimed rewards from the next epoch\n        // Check if the user has claimed all rewards from the last epoch first\n        uint256 userClaimedRewardsPerToken = rewardsPerTokenClaimed[msg.sender];\n        uint256 rewardsPerTokenEnd = epochRewardsPerTokenStart[userLastEpoch + 1];\n        if (userClaimedRewardsPerToken < rewardsPerTokenEnd) {\n            // If not, then claim the remaining rewards from the last epoch\n            uint256 remainingLastEpochRewards = _claimEpochRewards(userLastEpoch);\n            uint256 nextEpochRewards = _claimEpochRewards(userLastEpoch + 1);\n            return remainingLastEpochRewards + nextEpochRewards;\n        } else {\n            // If so, then claim the rewards from the next epoch\n            return _claimEpochRewards(userLastEpoch + 1);\n        }\n    }\n\n    function _claimEpochRewards(uint48 epoch_) internal returns (uint256) {\n        // Claims all outstanding rewards for the user for the specified epoch\n        // If the option token for the epoch has expired, the rewards are lost\n\n        // Check that the epoch is valid\n        if (epoch_ > epoch) revert OTLM_InvalidEpoch();\n\n        // Get the rewards per token claimed by the user\n        uint256 userRewardsClaimed = rewardsPerTokenClaimed[msg.sender];\n\n        // Get the rewards per token at the start of the epoch and the rewards per token at the end of the epoch (start of the next one)\n        // If the epoch is the current epoch, the rewards per token at the end of the epoch is the current rewards per token stored\n        uint256 rewardsPerTokenStart = epochRewardsPerTokenStart[epoch_];\n        uint256 rewardsPerTokenEnd = epoch_ == epoch\n            ? rewardsPerTokenStored\n            : epochRewardsPerTokenStart[epoch_ + 1];\n\n        // If the user hasn't claimed the rewards up to the start of this epoch, then they have a previous unclaimed epoch\n        // External functions protect against this by their ordering, but this makes it explicit\n        if (userRewardsClaimed < rewardsPerTokenStart) revert OTLM_PreviousUnclaimedEpoch();\n\n        // If user rewards claimed is greater than or equal to the rewards per token at the end of the epoch, then the user has already claimed all rewards for the epoch\n        if (userRewardsClaimed >= rewardsPerTokenEnd) return 0;\n\n        // If not, then the user has not claimed all rewards for the epoch\n\n        // Set the rewards per token claimed by the user to the rewards per token at the end of the epoch\n        rewardsPerTokenClaimed[msg.sender] = rewardsPerTokenEnd;\n        lastEpochClaimed[msg.sender] = epoch_;\n\n        // Get the option token for the epoch\n        FixedStrikeOptionToken optionToken = epochOptionTokens[epoch_];\n        // If the option token has expired, then the rewards are zero\n        if (uint256(optionToken.expiry()) < block.timestamp) return 0;\n\n        // If the option token is still valid, we need to issue rewards\n        uint256 rewards = ((rewardsPerTokenEnd - userRewardsClaimed) * stakeBalance[msg.sender]) /\n            10 ** stakedTokenDecimals;\n\n        // Mint the option token on the teller\n        // This transfers the reward amount of payout tokens to the option teller in exchange for the amount of option tokens\n        payoutToken.approve(address(optionTeller), rewards);\n        optionTeller.create(optionToken, rewards);\n\n        // Transfer rewards to sender\n        ERC20(address(optionToken)).safeTransfer(msg.sender, rewards);\n\n        // Return the amount of rewards claimed\n        return rewards;\n    }\n\n    function _startNewEpoch() internal {\n        // Starts a new epoch, assumes that a check has been performed that the epoch can start and that rewards were updated prior to calling\n        epoch++;\n        epochStart = uint48(block.timestamp);\n        epochRewardsPerTokenStart[epoch] = rewardsPerTokenStored;\n\n        // Deploy new option token and store against the epoch\n        FixedStrikeOptionToken optionToken = optionTeller.deploy(\n            payoutToken,\n            quoteToken,\n            uint48(block.timestamp) + timeUntilEligible,\n            uint48(block.timestamp) + timeUntilEligible + eligibleDuration,\n            receiver,\n            true,\n            nextStrikePrice()\n        );\n        epochOptionTokens[epoch] = optionToken;\n\n        // Emit event\n        emit NewEpoch(epoch, optionToken);\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    /// @notice Returns the current rewards per token value updated to the second\n    function currentRewardsPerToken() public view returns (uint256) {\n        // Rewards do not accrue if the total balance is zero\n        if (totalBalance == 0) return rewardsPerTokenStored;\n\n        // The number of rewards to apply is based on the reward rate and the amount of time that has passed since the last reward update\n        uint256 rewardsToApply = ((block.timestamp - lastRewardUpdate) * rewardRate) /\n            REWARD_PERIOD;\n\n        // The rewards per token is the current rewards per token plus the rewards to apply divided by the total staked balance\n        return rewardsPerTokenStored + (rewardsToApply * 10 ** stakedTokenDecimals) / totalBalance;\n    }\n\n    /// @notice Returns the strike price that would be used if a new epoch started right now\n    function nextStrikePrice() public view virtual returns (uint256);\n\n    /* ========== ADMIN FUNCTIONS ========== */\n\n    // Staking management\n\n    /// @notice Toggle whether deposits are enabled\n    /// @notice Only owner\n    /// @param depositsEnabled_ Whether deposits should be enabled\n    function setDepositsEnabled(bool depositsEnabled_) external onlyOwner requireInitialized {\n        // Set whether deposits are enabled\n        depositsEnabled = depositsEnabled_;\n    }\n\n    /// @notice Manually start a new epoch\n    /// @notice Only owner\n    function triggerNextEpoch() external onlyOwner requireInitialized updateRewards {\n        // Triggers the next epoch, allowing the owner to move through epochs manually if desired.\n        // This allows fixing configuration issues or adjusting for severe market events.\n        _startNewEpoch();\n    }\n\n    /// @notice Withdraw payout tokens that were deposited to the contract for rewards\n    /// @notice Only owner\n    /// @param to_     The address to withdraw to\n    /// @param amount_ The amount to withdraw\n    function withdrawPayoutTokens(address to_, uint256 amount_) external onlyOwner {\n        // Revert if the amount is greater than the balance\n        // Transfer will check this, but we provide a more helpful error message\n        if (amount_ > payoutToken.balanceOf(address(this)) || amount_ == 0)\n            revert OTLM_InvalidAmount();\n\n        // Withdraws payout tokens from the contract\n        payoutToken.safeTransfer(to_, amount_);\n    }\n\n    /// @notice Set the staking reward rate\n    /// @notice Only owner\n    /// @param rewardRate_ Amount of option tokens rewarded per reward period (1 day)\n    function setRewardRate(\n        uint256 rewardRate_\n    ) external onlyOwner requireInitialized updateRewards {\n        // Check if a new epoch needs to be started\n        // We do this to avoid bad state if the reward rate is changed when a new epoch should have started\n        if (block.timestamp >= epochStart + epochDuration) _startNewEpoch();\n\n        // Set the reward rate\n        rewardRate = rewardRate_;\n    }\n\n    /// @notice Set the epoch duration\n    /// @notice Only owner\n    /// @param epochDuration_ Staking epoch duration (in seconds)\n    function setEpochDuration(uint48 epochDuration_) external onlyOwner requireInitialized {\n        // The option token expiry must be greater than the epoch duration\n        if (timeUntilEligible + eligibleDuration < epochDuration_) revert OTLM_InvalidParams();\n\n        // Set the epoch duration\n        epochDuration = epochDuration_;\n    }\n\n    // Option token parameters\n\n    /// @notice Set the option receiver\n    /// @notice Only owner\n    /// @param receiver_ Address that will receive the quote tokens when an option is exercised\n    /// IMPORTANT: receiver is the only address that can retrieve payout token collateral from expired options.\n    /// It must be able to call the `reclaim` function on the Option Teller contract.\n    function setOptionReceiver(address receiver_) external onlyOwner requireInitialized {\n        // Set the receiver\n        receiver = receiver_;\n    }\n\n    /// @notice Set the option duration\n    /// @notice Only owner\n    /// @param timeUntilEligible_ Amount of time (in seconds) from option token deployment to when it can be exercised\n    /// @param eligibleDuration_  Amount of time (in seconds) from when the option token is eligible to when it expire\n    function setOptionDuration(\n        uint48 timeUntilEligible_,\n        uint48 eligibleDuration_\n    ) external onlyOwner requireInitialized {\n        // Validate parameters\n        // The eligible duration must be greater than the minimum option duration to be a valid option token\n        if (eligibleDuration_ < optionTeller.minOptionDuration()) revert OTLM_InvalidParams();\n\n        // The option token expiry must be greater than the epoch duration\n        if (timeUntilEligible_ + eligibleDuration_ < epochDuration) revert OTLM_InvalidParams();\n\n        // Set the time until eligible and the eligible duration\n        timeUntilEligible = timeUntilEligible_;\n        eligibleDuration = eligibleDuration_;\n    }\n\n    /// @notice Set the quote token that is used for the option tokens\n    /// @notice Only owner\n    /// @param quoteToken_ Token that stakers must pay to exercise the call options they receive\n    function setQuoteToken(ERC20 quoteToken_) external virtual onlyOwner requireInitialized {\n        // Revert if the quote token is the zero address or not a contract\n        if (address(quoteToken_) == address(0) || address(quoteToken_).code.length == 0)\n            revert OTLM_InvalidParams();\n\n        // Set the quote token\n        quoteToken = quoteToken_;\n    }\n\n    function setAllowlist(\n        IAllowlist allowlist_,\n        bytes calldata allowlistParams_\n    ) external onlyOwner requireInitialized {\n        // If the allowlist is not the zero address, assume it's being used and register the contract\n        if (address(allowlist_) != address(0)) {\n            // Since an allowlist is being used, we must confirm it is a contract\n            if (address(allowlist_).code.length == 0) revert OTLM_InvalidParams();\n\n            // Store allowlist\n            allowlist = allowlist_;\n\n            // Register contract on allowlist, catch error if fails\n            try allowlist.register(allowlistParams_) {} catch {\n                revert OTLM_InvalidParams();\n            }\n        } else {\n            // If the allowlist is the zero address, then remove the current allowlist\n            allowlist = IAllowlist(address(0));\n        }\n    }\n}\n\n// Implementations of different strike price setting mechanisms\n\n/// @title Manual Strike Option Token Liquidity Mining (OTLM)\n/// @dev The Manual Strike OTLM contract allows the owner to manually set the strike price that new option tokens are created with on epoch transition.\n/// @author Bond Protocol\ncontract ManualStrikeOTLM is OTLM {\n    /* ========== STATE VARIABLES ========== */\n\n    /// @notice Strike price to be used for new option tokens\n    uint256 public strikePrice;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    /// @param owner_        Address of the owner of the OTLM contract\n    /// @param stakedToken_  Token that is staked in the OTLM contract\n    /// @param optionTeller_ Option Teller contract that is used by the OTLM contract to deploy and create option tokens\n    /// @param payoutToken_  Token that stakers receive call options for\n    constructor(\n        address owner_,\n        ERC20 stakedToken_,\n        IFixedStrikeOptionTeller optionTeller_,\n        ERC20 payoutToken_\n    ) OTLM(owner_, stakedToken_, optionTeller_, payoutToken_) {}\n\n    /* ========== INITIALIZE ========== */\n\n    // Additional initialization logic for the manual strike price OTLM\n    /// @param params_"
    }
  ]
}