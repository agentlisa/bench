{
  "Title": "M-2: UbiquityPool::mintDollar/redeemDollar collateral depeg will encourage using UbiquityPool to swap for better collateral",
  "Content": "# Issue M-2: UbiquityPool::mintDollar/redeemDollar collateral depeg will encourage using UbiquityPool to swap for better collateral \n\nSource: https://github.com/sherlock-audit/2023-12-ubiquity-judging/issues/17 \n\n## Found by \ncducrest-brainbot, cergyk, fugazzi, ge6a, shaka\n## Summary\nIn the case of a depeg of an underlying collateral, UbiquityPool mechanism incentivises users to fill it up with the depegging collateral and taking out the better collateral. This means uAD ultimately depegs as well.\n\n## Vulnerability Detail\nChainlink price may be slightly outdated with regards to actual Dex state, and in that case users holding a depegging asset (let's consider `DAI` depegging) will use uAD to swap for the still pegged collateral: `LUSD`. By doing that they expect a better execution than on Dexes, because they swap at the price of chainlink minus the uAD fee:\nhttps://github.com/sherlock-audit/2023-12-ubiquity/blob/main/ubiquity-dollar/packages/contracts/src/dollar/libraries/LibUbiquityPool.sol#L358-L364\n\nThis in turn fills the reserves of UbiquityPool with the depegging collateral and depletes the reserves of `good` collateral.\n\n## Impact\nA depegging collateral will cause uAD to depeg because users are incentivised to use the pool to swap for the `better` asset\n\n## Code Snippet\n\n## Tool used\nManual Review\n\n## Recommendation\nMultiple solutions may be studied:\n- Enforce a ratio between different collateral reserves (somewhat like GMX pricing algo which also enables users to swap with zero slippage using chainlink feeds)\n- Use a safety minting ratio (LTV mechanism similar to borrowing protocols)\n- Force chainlink feeds to stay within acceptable thresholds for stable coins (revert operations on collateral if price is out of range)\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**auditsea** commented:\n> The issue describes about the protocol insolvancy in case of collateral depeg. It's not avoidable, that's why the protocol has borrowing function to get yield, take fees on mint and redeem, these features will hedge the risk from protocol insolvancy\n\n\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**auditsea** commented:\n> The issue describes about the protocol insolvancy in case of collateral depeg. It's not avoidable, that's why the protocol has borrowing function to get yield, take fees on mint and redeem, these features will hedge the risk from protocol insolvancy\n\n\n\n**gitcoindev**\n\n> 1 comment(s) were left on this issue during the judging contest.\n> \n> **auditsea** commented:\n> \n> > The issue describes about the protocol insolvancy in case of collateral depeg. It's not avoidable, that's why the protocol has borrowing function to get yield, take fees on mint and redeem, these features will hedge the risk from protocol insolvancy\n\nShould we also add 'Sponsor Disputed' label in this issue as well? @rndquu @pavlovcik @molecula451 \n\n**pavlovcik**\n\nIt probably makes more sense to ask @auditsea (not sure if this is the corresponding GitHub handle.)\n\n**rndquu**\n\nAs far as I understand this issue describes the following scenario:\n1. User1 mints 100 Dollar tokens and provides 100 DAI collateral\n2. User2 mints 100 Dollar tokens and provides 100 LUSD collateral\n3. DAI depegs\n4. User1 (who initially deposited DAI) redeems 100 Dollar tokens for 100 LUSD\n5. User2 (who initially deposited LUSD) is left only with depegged DAI pool\n\nIf DAI depegs then the Dollar token will also depeg mainly because DAI is used as an underlying collateral in the `Dollar-3CRVLP` curve's metapool. We shouldn't limit users in redeeming (i.e. burning) Dollar tokens anyhow because Dollar redeems bring back the `Dollar/USD` quote to `$1.00` peg. So it seems to be fine that users should be able to burn Dollars until the pools are empty no matter where they initially deposited to because this is the only way to maintain the Dollar token's USD peg.\n\nIn case of a collateral depeg the only way to hedge Dollar depeg to some extent is to acquire fees and yield from AMO minters. This is not a 100% guarantee but I guess that if chainlink works fine (i.e. provides not too stale data) and we have 5% overcollateralization (from fees and yield) the Dollar token should not depeg too much.\n\n> Force chainlink feeds to stay within acceptable thresholds for stable coins (revert operations on collateral if price is out of range)\n\nI don't understand how reverting on minting and redeeming helps. Reverting in this case means acquiring bad debt since all operations are paused and abritragers are not able to bring the Dollar token back to the USD peg by burning Dollars which makes the Dollar token to depeg with greater force.\n\n**pavlovcik**\n\n@rndquu as a heads up we should only start with accepting `LUSD` and then maybe, eventually, add `sUSD` next in case of future liquidity issues. `DAI` isn't part of the plan yet. \n\n**rndquu**\n\nInitially we plan to use only `LUSD` as collateral so there won't be the case with bad (i.e. depegging) and good collateral.\n\nI think we should:\n1. Create a separate issue for this one in our [repo](https://github.com/ubiquity/ubiquity-dollar/) and fix it later since it is not critical\n2. Mark the current issue as valid and \"won't fix\"\n\n@molecula451 @gitcoindev Help\n\n\n**0x3agle**\n\n> In the case of a depeg of an underlying collateral, UbiquityPool mechanism incentivises users to fill it up with the depegging collateral and taking out the better collateral.\n\n- If the uAD price is stable at $1 in the uAD-3CRV pool, then the mints (open if `uAD > $1.01`) or redeems (open if `uAD < 0.99`) won't be enabled. \n- The chainlink oracle - is used to get the price of collateral. This price is then used to determine the amount of uAD to mint or burn, proportional to the collateral\n- The TWAP price from the curve pool will decide whether to enable mints or enable redeems\n- Hence the collateral de-pegging doesn't affect the uAD price, because we get the uAD price from the Curve pool ([ref](https://github.com/sherlock-audit/2023-12-ubiquity/blob/main/ubiquity-dollar/packages/contracts/src/dollar/libraries/LibUbiquityPool.sol#L344C3-L349C11))\n\n\n\n**molecula451**\n\nThe above sceneario makes much more sense on the current issue, a fix won't happen, this is most likely an invalid\n\n**0xLogos**\n\nEscalate \nShould be invalid\nReverting redemption if one of the collateral depegs even greater evil because now no one can redeem uD as noticed by rndquu. I think collateral depeg is a very unpleasant event and you can’t simply get away with it without loss.\nEnforcing a ratio between different collateral reserves is not good solution as it has bad consequences for market efficiency throughout the life of the protocol and will barely (arguably) mitigate losses in case of depeg.\n\n**sherlock-admin2**\n\n> Escalate \n> Should be invalid\n> Reverting redemption if one of the collateral depegs even greater evil because now no one can redeem uD as noticed by rndquu. I think collateral depeg is a very unpleasant event and you can’t simply get away with it without loss.\n> Enforcing a ratio between different collateral reserves is not good solution as it has bad consequences for market efficiency throughout the life of the protocol and will barely (arguably) mitigate losses in case of depeg.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**evmboi32**\n\nIn my issue #144, I described that the pool can run out of collateral if the collateral gets de-pegged. This means that users cannot redeem their uAD tokens for the underlying collateral.\n\n**pavlovcik**\n\nI really feel like collateral performance is out of scope for the audit. For whatever its worth, the reason why we are starting with LUSD is because it seems to have the least points of failure out of all the stablecoins I'm aware of. The tradeoff is its slight volatility and limited ability to scale. \n\nTo me it comes across that you're saying that we need to include Liquity's entire protocol within our audit scope in order to confirm that a depeg isn't possible, and that our protocol will not fail. \n\nIf this is in scope, why not proceed with Ethereum blockchain failures? If the network gets taken over, then fraudulent transactions can be generated to withdraw all of our collateral, rendering the protocol insolvent. \n\netc\n\n**rndquu**\n\n> I really feel like collateral performance is out of scope for the audit. For whatever its worth, the reason why we are starting with LUSD is because it seems to have the least points of failure out of all the stablecoins I'm aware of. The tradeoff is its slight volatility and limited ability to scale.\n> \n> To me it comes across that you're saying that we need to include Liquity's entire protocol within our audit scope in order to confirm that a depeg isn't possible, and that our protocol will not fail.\n> \n> If this is in scope, why not proceed with Ethereum blockchain failures? If the network gets taken over, then fraudulent transactions can be generated to withdraw all of our collateral, rendering the protocol insolvent.\n> \n> etc\n\nCollateral depeg does harm the ubiquity protocol hence it is considered a valid issue (not sure what severity though)\n\n**0xLogos**\n\n> In my issue #144, I described that the pool can run out of collateral if the collateral gets de-pegged. This means that users cannot redeem their uAD tokens for the underlying collateral.\n\n@evmboi32 Ok, depeg happens, collateral's price is now out of min/max range and redemptions are now failing (proposed in #144 solution). Then what? Wait and hope the collateral to repeg? \n\n**nevillehuang**\n\n@CergyK Are you aware if Ubiquity has a circuit breaker for depeg events? \n\nTo me if they lack one, this will constitute as a valid medium severity finding as a depeg does directly undermine the protocols available collateral. This is in addition to the depeg scenario not being stated as an accepted risk by the protocol in the contest details (to my knowledge, most of the time, a stablecoin protocol would acknowledge the risks of a depeg scenario and even have a circuit breaker in place). \n\n**molecula451**\n\nno we don't have circuit breaker @nevillehuang \n\n**Czar102**\n\nThe maximum divergence of the market price from the oracle feed should be within the fee charged. Planning to accept the escalation and invalidate the issue.\n\n**pavlovcik**\n\nWe have our staking contract that allows us to manipulate single sided liquidity on our metapool to directly change the price right now. \n\n**Czar102**\n\nResult:\nInvalid\nHas duplicates\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [0xLogos](https://github.com/sherlock-audit/2023-12-ubiquity-judging/issues/17/#issuecomment-1912166358): accepted\n\n**gstoyanovbg**\n\n@Czar102 I don't understand the argument for invalidating this report, could you explain a little more?\n\nFrom my point of view, I submitted report #217  because when calculating the amount of collateral a user will receive when redeeming, the real price of the dollar token is not used, but it is assumed to always be $1. Let me give an example:\n\n1. User A mints 120 dollar tokens for 120 DAI\n2. User B mints 120 dollar tokens for 120 LUSD\n3. DAI depegs with 20%. Now collateral to dollar tokens ratio is (120 + 120*0.8) / 240 = 0.9\n4. User A redeems 100 dollar tokens for 120 DAI (because the price of DAI is $0.8) and 20 dollar tokens for 20 LUSD. After this operation, there are 120 dollar tokens in circulation and 100 LUSD collateral. Now the collateral to dollar tokens ratio is 100/120 = 0.83, less than the ratio at step 3. If there are more users, those who are last would not be able to get anything for their tokens because there will be no remaining collateral. This scenario is harmful to both the protocol and the users. I want to note that in redeemDollar() we only have upper bound for the dollar token price.\n\nWouldn't it be better to use the real price of the dollar token when determining the amount of collateral to be received in exchange for the dollar tokens? This way, each user will receive a proportional share of the available collateral, and there will not be a situation where there are dollar tokens in circulation without collateral behind them.\n\n**molecula451**\n\n> @Czar102 I don't understand the argument for invalidating this report, could you explain a little more?\n> \n> From my point of view, I submitted report #217 because when calculating the amount of collateral a user will receive when redeeming, the real price of the dollar token is not used, but it is assumed to always be $1. Let me give an example:\n> \n> 1. User A mints 120 dollar tokens for 120 DAI\n> 2. User B mints 120 dollar tokens for 120 LUSD\n> 3. DAI depegs with 20%. Now collateral to dollar tokens ratio is (120 + 120*0.8) / 240 = 0.9\n> 4. User A redeems 100 dollar tokens for 120 DAI (because the price of DAI is $0.8) and 20 dollar tokens for 20 LUSD. After this operation, there are 120 dollar tokens in circulation and 100 LUSD collateral. Now the collateral to dollar tokens ratio is 100/120 = 0.83, less than the ratio at step 3. If there are more users, those who are last would not be able to get anything for their tokens because there will be no remaining collateral. This scenario is harmful to both the protocol and the users. I want to note that in redeemDollar() we only have upper bound for the dollar token price.\n> \n> Wouldn't it be better to use the real price of the dollar token when determining the amount of collateral to be received in exchange for the dollar tokens? This way, each user will receive a proportional share of the available collateral, and there will not be a situation where there are dollar tokens in circulation without collateral behind them.\n\nwe will leavy it as invalid\n\n**Czar102**\n\n@gstoyanovbg thank you for the comment. We had an extensive internal discussion about this issue and some of the other ones, considerations about the exact behavior you are describing. There is a chance we may revert this escalation's resolution, if we determine that this has been a misjudgment.\n\nI would recommend looking at #60 as a core cause of this issue.\n\n**Czar102**\n\nWill consider this a valid Medium and change the escalation resolution status.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/138",
  "Code": [
    {
      "filename": "ubiquity-dollar/packages/contracts/src/dollar/libraries/LibUbiquityPool.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.19;\n\nimport {AggregatorV3Interface} from \"@chainlink/interfaces/AggregatorV3Interface.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {IDollarAmoMinter} from \"../interfaces/IDollarAmoMinter.sol\";\nimport {IERC20Ubiquity} from \"../interfaces/IERC20Ubiquity.sol\";\nimport {UBIQUITY_POOL_PRICE_PRECISION} from \"./Constants.sol\";\nimport {LibAppStorage} from \"./LibAppStorage.sol\";\nimport {LibTWAPOracle} from \"./LibTWAPOracle.sol\";\n\n/**\n * @notice Ubiquity pool library\n * @notice Allows users to:\n * - deposit collateral in exchange for Ubiquity Dollars\n * - redeem Ubiquity Dollars in exchange for the earlier provided collateral\n */\nlibrary LibUbiquityPool {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    /// @notice Storage slot used to store data for this library\n    bytes32 constant UBIQUITY_POOL_STORAGE_POSITION =\n        bytes32(\n            uint256(keccak256(\"ubiquity.contracts.ubiquity.pool.storage\")) - 1\n        );\n\n    /// @notice Struct used as a storage for this library\n    struct UbiquityPoolStorage {\n        //========\n        // Core\n        //========\n        // minter address -> is it enabled\n        mapping(address amoMinter => bool isEnabled) isAmoMinterEnabled;\n        //======================\n        // Collateral related\n        //======================\n        // available collateral tokens\n        address[] collateralAddresses;\n        // collateral address -> collateral index\n        mapping(address collateralAddress => uint256 collateralIndex) collateralIndex;\n        // collateral index -> chainlink price feed addresses\n        address[] collateralPriceFeedAddresses;\n        // collateral index -> threshold in seconds when chainlink answer should be considered stale\n        uint256[] collateralPriceFeedStalenessThresholds;\n        // collateral index -> collateral price\n        uint256[] collateralPrices;\n        // array collateral symbols\n        string[] collateralSymbols;\n        // collateral address -> is it enabled\n        mapping(address collateralAddress => bool isEnabled) isCollateralEnabled;\n        // Number of decimals needed to get to E18. collateral index -> missing decimals\n        uint256[] missingDecimals;\n        // Total across all collaterals. Accounts for missing_decimals\n        uint256[] poolCeilings;\n        //====================\n        // Redeem related\n        //====================\n        // user -> block number (collateral independent)\n        mapping(address => uint256) lastRedeemedBlock;\n        // 1010000 = $1.01\n        uint256 mintPriceThreshold;\n        // 990000 = $0.99\n        uint256 redeemPriceThreshold;\n        // address -> collateral index -> balance\n        mapping(address user => mapping(uint256 collateralIndex => uint256 amount)) redeemCollateralBalances;\n        // number of blocks to wait before being able to collectRedemption()\n        uint256 redemptionDelayBlocks;\n        // collateral index -> balance\n        uint256[] unclaimedPoolCollateral;\n        //================\n        // Fees related\n        //================\n        // minting fee of a particular collateral index, 1_000_000 = 100%\n        uint256[] mintingFee;\n        // redemption fee of a particular collateral index, 1_000_000 = 100%\n        uint256[] redemptionFee;\n        //=================\n        // Pause related\n        //=================\n        // whether borrowing collateral by AMO minters is paused for a particular collateral index\n        bool[] isBorrowPaused;\n        // whether minting is paused for a particular collateral index\n        bool[] isMintPaused;\n        // whether redeeming is paused for a particular collateral index\n        bool[] isRedeemPaused;\n    }\n\n    /// @notice Struct used for detailed collateral information\n    struct CollateralInformation {\n        uint256 index;\n        string symbol;\n        address collateralAddress;\n        address collateralPriceFeedAddress;\n        uint256 collateralPriceFeedStalenessThreshold;\n        bool isEnabled;\n        uint256 missingDecimals;\n        uint256 price;\n        uint256 poolCeiling;\n        bool isMintPaused;\n        bool isRedeemPaused;\n        bool isBorrowPaused;\n        uint256 mintingFee;\n        uint256 redemptionFee;\n    }\n\n    /**\n     * @notice Returns struct used as a storage for this library\n     * @return uPoolStorage Struct used as a storage\n     */\n    function ubiquityPoolStorage()\n        internal\n        pure\n        returns (UbiquityPoolStorage storage uPoolStorage)\n    {\n        bytes32 position = UBIQUITY_POOL_STORAGE_POSITION;\n        assembly {\n            uPoolStorage.slot := position\n        }\n    }\n\n    //===========\n    // Events\n    //===========\n\n    /// @notice Emitted when new AMO minter is added\n    event AmoMinterAdded(address amoMinterAddress);\n    /// @notice Emitted when AMO minter is removed\n    event AmoMinterRemoved(address amoMinterAddress);\n    /// @notice Emitted on setting a chainlink's collateral price feed params\n    event CollateralPriceFeedSet(\n        uint256 collateralIndex,\n        address priceFeedAddress,\n        uint256 stalenessThreshold\n    );\n    /// @notice Emitted on setting a collateral price\n    event CollateralPriceSet(uint256 collateralIndex, uint256 newPrice);\n    /// @notice Emitted on enabling/disabling a particular collateral token\n    event CollateralToggled(uint256 collateralIndex, bool newState);\n    /// @notice Emitted when fees are updated\n    event FeesSet(\n        uint256 collateralIndex,\n        uint256 newMintFee,\n        uint256 newRedeemFee\n    );\n    /// @notice Emitted on toggling pause for mint/redeem/borrow\n    event MintRedeemBorrowToggled(uint256 collateralIndex, uint8 toggleIndex);\n    /// @notice Emitted when new pool ceiling (i.e. max amount of collateral) is set\n    event PoolCeilingSet(uint256 collateralIndex, uint256 newCeiling);\n    /// @notice Emitted when mint and redeem price thresholds are updated (1_000_000 = $1.00)\n    event PriceThresholdsSet(\n        uint256 newMintPriceThreshold,\n        uint256 newRedeemPriceThreshold\n    );\n    /// @notice Emitted when a new redemption delay in blocks is set\n    event RedemptionDelayBlocksSet(uint256 redemptionDelayBlocks);\n\n    //=====================\n    // Modifiers\n    //=====================\n\n    /**\n     * @notice Checks whether collateral token is enabled (i.e. mintable and redeemable)\n     * @param collateralIndex Collateral token index\n     */\n    modifier collateralEnabled(uint256 collateralIndex) {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n        require(\n            poolStorage.isCollateralEnabled[\n                poolStorage.collateralAddresses[collateralIndex]\n            ],\n            \"Collateral disabled\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Checks whether a caller is the AMO minter address\n     */\n    modifier onlyAmoMinter() {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n        require(\n            poolStorage.isAmoMinterEnabled[msg.sender],\n            \"Not an AMO Minter\"\n        );\n        _;\n    }\n\n    //=====================\n    // Views\n    //=====================\n\n    /**\n     * @notice Returns all collateral addresses\n     * @return All collateral addresses\n     */\n    function allCollaterals() internal view returns (address[] memory) {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n        return poolStorage.collateralAddresses;\n    }\n\n    /**\n     * @notice Returns collateral information\n     * @param collateralAddress Address of the collateral token\n     * @return returnData Collateral info\n     */\n    function collateralInformation(\n        address collateralAddress\n    ) internal view returns (CollateralInformation memory returnData) {\n        // load the storage\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n\n        // validation\n        require(\n            poolStorage.isCollateralEnabled[collateralAddress],\n            \"Invalid collateral\"\n        );\n\n        // get the index\n        uint256 index = poolStorage.collateralIndex[collateralAddress];\n\n        returnData = CollateralInformation(\n            index,\n            poolStorage.collateralSymbols[index],\n            collateralAddress,\n            poolStorage.collateralPriceFeedAddresses[index],\n            poolStorage.collateralPriceFeedStalenessThresholds[index],\n            poolStorage.isCollateralEnabled[collateralAddress],\n            poolStorage.missingDecimals[index],\n            poolStorage.collateralPrices[index],\n            poolStorage.poolCeilings[index],\n            poolStorage.isMintPaused[index],\n            poolStorage.isRedeemPaused[index],\n            poolStorage.isBorrowPaused[index],\n            poolStorage.mintingFee[index],\n            poolStorage.redemptionFee[index]\n        );\n    }\n\n    /**\n     * @notice Returns USD value of all collateral tokens held in the pool, in E18\n     * @return balanceTally USD value of all collateral tokens\n     */\n    function collateralUsdBalance()\n        internal\n        view\n        returns (uint256 balanceTally)\n    {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n        uint256 collateralTokensCount = poolStorage.collateralAddresses.length;\n        balanceTally = 0;\n        for (uint256 i = 0; i < collateralTokensCount; i++) {\n            balanceTally += freeCollateralBalance(i)\n                .mul(10 ** poolStorage.missingDecimals[i])\n                .mul(poolStorage.collateralPrices[i])\n                .div(UBIQUITY_POOL_PRICE_PRECISION);\n        }\n    }\n\n    /**\n     * @notice Returns free collateral balance (i.e. that can be borrowed by AMO minters)\n     * @param collateralIndex collateral token index\n     * @return Amount of free collateral\n     */\n    function freeCollateralBalance(\n        uint256 collateralIndex\n    ) internal view returns (uint256) {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n        return\n            IERC20(poolStorage.collateralAddresses[collateralIndex])\n                .balanceOf(address(this))\n                .sub(poolStorage.unclaimedPoolCollateral[collateralIndex]);\n    }\n\n    /**\n     * @notice Returns Dollar value in collateral tokens\n     * @param collateralIndex collateral token index\n     * @param dollarAmount Amount of Dollars\n     * @return Value in collateral tokens\n     */\n    function getDollarInCollateral(\n        uint256 collateralIndex,\n        uint256 dollarAmount\n    ) internal view returns (uint256) {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n        return\n            dollarAmount\n                .mul(UBIQUITY_POOL_PRICE_PRECISION)\n                .div(10 ** poolStorage.missingDecimals[collateralIndex])\n                .div(poolStorage.collateralPrices[collateralIndex]);\n    }\n\n    /**\n     * @notice Returns Ubiquity Dollar token USD price (1e6 precision) from Curve Metapool (Ubiquity Dollar, Curve Tri-Pool LP)\n     * @return dollarPriceUsd USD price of Ubiquity Dollar\n     */\n    function getDollarPriceUsd()\n        internal\n        view\n        returns (uint256 dollarPriceUsd)\n    {\n        // get Dollar price from Curve Metapool (18 decimals)\n        uint256 dollarPriceUsdD18 = LibTWAPOracle.getTwapPrice();\n        // convert to 6 decimals\n        dollarPriceUsd = dollarPriceUsdD18\n            .mul(UBIQUITY_POOL_PRICE_PRECISION)\n            .div(1e18);\n    }\n\n    //====================\n    // Public functions\n    //====================\n\n    /**\n     * @notice Mints Dollars in exchange for collateral tokens\n     * @param collateralIndex Collateral token index\n     * @param dollarAmount Amount of dollars to mint\n     * @param dollarOutMin Min amount of dollars to mint (slippage protection)\n     * @param maxCollateralIn Max amount of collateral to send (slippage protection)\n     * @return totalDollarMint Amount of Dollars minted\n     * @return collateralNeeded Amount of collateral sent to the pool\n     */\n    function mintDollar(\n        uint256 collateralIndex,\n        uint256 dollarAmount,\n        uint256 dollarOutMin,\n        uint256 maxCollateralIn\n    )\n        internal\n        collateralEnabled(collateralIndex)\n        returns (uint256 totalDollarMint, uint256 collateralNeeded)\n    {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n\n        require(\n            poolStorage.isMintPaused[collateralIndex] == false,\n            \"Minting is paused\"\n        );\n\n        // update Dollar price from Curve's Dollar Metapool\n        LibTWAPOracle.update();\n        // prevent unnecessary mints\n        require(\n            getDollarPriceUsd() >= poolStorage.mintPriceThreshold,\n            \"Dollar price too low\"\n        );\n\n        // update collateral price\n        updateChainLinkCollateralPrice(collateralIndex);\n\n        // get amount of collateral for minting Dollars\n        collateralNeeded = getDollarInCollateral(collateralIndex, dollarAmount);\n\n        // subtract the minting fee\n        totalDollarMint = dollarAmount\n            .mul(\n                UBIQUITY_POOL_PRICE_PRECISION.sub(\n                    poolStorage.mintingFee[collateralIndex]\n                )\n            )\n            .div(UBIQUITY_POOL_PRICE_PRECISION);\n\n        // check slippages\n        require((totalDollarMint >= dollarOutMin), \"Dollar slippage\");\n        require((collateralNeeded <= maxCollateralIn), \"Collateral slippage\");\n\n        // check the pool ceiling\n        require(\n            freeCollateralBalance(collateralIndex).add(collateralNeeded) <=\n                poolStorage.poolCeilings[collateralIndex],\n            \"Pool ceiling\"\n        );\n\n        // take collateral first\n        IERC20(poolStorage.collateralAddresses[collateralIndex])\n            .safeTransferFrom(msg.sender, address(this), collateralNeeded);\n\n        // mint Dollars\n        IERC20Ubiquity ubiquityDollarToken = IERC20Ubiquity(\n            LibAppStorage.appStorage().dollarTokenAddress\n        );\n        ubiquityDollarToken.mint(msg.sender, totalDollarMint);\n    }\n\n    /**\n     * @notice Burns redeemable Ubiquity Dollars and sends back 1 USD of collateral token for every 1 Ubiquity Dollar burned\n     * @dev Redeem process is split in two steps:\n     * @dev 1. `redeemDollar()`\n     * @dev 2. `collectRedemption()`\n     * @dev This is done in order to prevent someone using a flash loan of a collateral token to mint, redeem, and collect in a single transaction/block\n     * @param collateralIndex Collateral token index being withdrawn\n     * @param dollarAmount Amount of Ubiquity Dollars being burned\n     * @param collateralOutMin Minimum amount of collateral tokens that'll be withdrawn, used to set acceptable slippage\n     * @return collateralOut Amount of collateral tokens ready for redemption\n     */\n    function redeemDollar(\n        uint256 collateralIndex,\n        uint256 dollarAmount,\n        uint256 collateralOutMin\n    )\n        internal\n        collateralEnabled(collateralIndex)\n        returns (uint256 collateralOut)\n    {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n\n        require(\n            poolStorage.isRedeemPaused[collateralIndex] == false,\n            \"Redeeming is paused\"\n        );\n\n        // update Dollar price from Curve's Dollar Metapool\n        LibTWAPOracle.update();\n        // prevent unnecessary redemptions that could adversely affect the Dollar price\n        require(\n            getDollarPriceUsd() <= poolStorage.redeemPriceThreshold,\n            \"Dollar price too high\"\n        );\n\n        uint256 dollarAfterFee = dollarAmount\n            .mul(\n                UBIQUITY_POOL_PRICE_PRECISION.sub(\n                    poolStorage.redemptionFee[collateralIndex]\n                )\n            )\n            .div(UBIQUITY_POOL_PRICE_PRECISION);\n\n        // update collateral price\n        updateChainLinkCollateralPrice(collateralIndex);\n\n        // get collateral output for incoming Dollars\n        collateralOut = getDollarInCollateral(collateralIndex, dollarAfterFee);\n\n        // checks\n        require(\n            collateralOut <=\n                (IERC20(poolStorage.collateralAddresses[collateralIndex]))\n                    .balanceOf(address(this))\n                    .sub(poolStorage.unclaimedPoolCollateral[collateralIndex]),\n            \"Insufficient pool collateral\"\n        );\n        require(collateralOut >= collateralOutMin, \"Collateral slippage\");\n\n        // account for the redeem delay\n        poolStorage.redeemCollateralBalances[msg.sender][\n            collateralIndex\n        ] = poolStorage\n        .redeemCollateralBalances[msg.sender][collateralIndex].add(\n                collateralOut\n            );\n        poolStorage.unclaimedPoolCollateral[collateralIndex] = poolStorage\n            .unclaimedPoolCollateral[collateralIndex]\n            .add(collateralOut);\n\n        poolStorage.lastRedeemedBlock[msg.sender] = block.number;\n\n        // burn Dollars\n        IERC20Ubiquity ubiquityDollarToken = IERC20Ubiquity(\n            LibAppStorage.appStorage().dollarTokenAddress\n        );\n        ubiquityDollarToken.burnFrom(msg.sender, dollarAmount);\n    }\n\n    /**\n     * @notice Used to collect collateral tokens after redeeming/burning Ubiquity Dollars\n     * @dev Redeem process is split in two steps:\n     * @dev 1. `redeemDollar()`\n     * @dev 2. `collectRedemption()`\n     * @dev This is done in order to prevent someone using a flash loan of a collateral token to mint, redeem, and collect in a single transaction/block\n     * @param collateralIndex Collateral token index being collected\n     * @return collateralAmount Amount of collateral tokens redeemed\n     */\n    function collectRedemption(\n        uint256 collateralIndex\n    ) internal returns (uint256 collateralAmount) {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n\n        require(\n            poolStorage.isRedeemPaused[collateralIndex] == false,\n            \"Redeeming is paused\"\n        );\n        require(\n            (\n                poolStorage.lastRedeemedBlock[msg.sender].add(\n                    poolStorage.redemptionDelayBlocks\n                )\n            ) <= block.number,\n            \"Too soon to collect redemption\"\n        );\n\n        bool sendCollateral = false;\n\n        if (\n            poolStorage.redeemCollateralBalances[msg.sender][collateralIndex] >\n            0\n        ) {\n            collateralAmount = poolStorage.redeemCollateralBalances[msg.sender][\n                collateralIndex\n            ];\n            poolStorage.redeemCollateralBalances[msg.sender][\n                collateralIndex\n            ] = 0;\n            poolStorage.unclaimedPoolCollateral[collateralIndex] = poolStorage\n                .unclaimedPoolCollateral[collateralIndex]\n                .sub(collateralAmount);\n            sendCollateral = true;\n        }\n\n        // send out the tokens\n        if (sendCollateral) {\n            IERC20(poolStorage.collateralAddresses[collateralIndex])\n                .safeTransfer(msg.sender, collateralAmount);\n        }\n    }\n\n    /**\n     * @notice Updates collateral token price in USD from ChainLink price feed\n     * @param collateralIndex Collateral token index\n     */\n    function updateChainLinkCollateralPrice(uint256 collateralIndex) internal {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n\n        AggregatorV3Interface priceFeed = AggregatorV3Interface(\n            poolStorage.collateralPriceFeedAddresses[collateralIndex]\n        );\n\n        // fetch latest price\n        (\n            ,\n            // roundId\n            int256 answer, // startedAt\n            ,\n            uint256 updatedAt,\n\n        ) = // answeredInRound\n            priceFeed.latestRoundData();\n\n        // fetch number of decimals in chainlink feed\n        uint256 priceFeedDecimals = priceFeed.decimals();\n\n        // validation\n        require(answer > 0, \"Invalid price\");\n        require(\n            block.timestamp - updatedAt <\n                poolStorage.collateralPriceFeedStalenessThresholds[\n                    collateralIndex\n                ],\n            \"Stale data\"\n        );\n\n        // convert chainlink price to 6 decimals\n        uint256 price = uint256(answer).mul(UBIQUITY_POOL_PRICE_PRECISION).div(\n            10 ** priceFeedDecimals\n        );\n\n        poolStorage.collateralPrices[collateralIndex] = price;\n\n        emit CollateralPriceSet(collateralIndex, price);\n    }\n\n    //=========================\n    // AMO minters functions\n    //=========================\n\n    /**\n     * @notice Allows AMO minters to borrow collateral to make yield in external\n     * protocols like Compound, Curve, erc...\n     * @dev Bypasses the gassy mint->redeem cycle for AMOs to borrow collateral\n     * @param collateralAmount Amount of collateral to borrow\n     */\n    function amoMinterBorrow(uint256 collateralAmount) internal onlyAmoMinter {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n\n        // checks the collateral index of the minter as an additional safety check\n        uint256 minterCollateralIndex = IDollarAmoMinter(msg.sender)\n            .collateralIndex();\n\n        // checks to see if borrowing is paused\n        require(\n            poolStorage.isBorrowPaused[minterCollateralIndex] == false,\n            \"Borrowing is paused\"\n        );\n\n        // ensure collateral is enabled\n        require(\n            poolStorage.isCollateralEnabled[\n                poolStorage.collateralAddresses[minterCollateralIndex]\n            ],\n            \"Collateral disabled\"\n        );\n\n        // transfer\n        IERC20(poolStorage.collateralAddresses[minterCollateralIndex])\n            .safeTransfer(msg.sender, collateralAmount);\n    }\n\n    //========================\n    // Restricted functions\n    //========================\n\n    /**\n     * @notice Adds a new AMO minter\n     * @param amoMinterAddress AMO minter address\n     */\n    function addAmoMinter(address amoMinterAddress) internal {\n        require(amoMinterAddress != address(0), \"Zero address detected\");\n\n        // make sure the AMO Minter has collateralDollarBalance()\n        uint256 collatValE18 = IDollarAmoMinter(amoMinterAddress)\n            .collateralDollarBalance();\n        require(collatValE18 >= 0, \"Invalid AMO\");\n\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n\n        poolStorage.isAmoMinterEnabled[amoMinterAddress] = true;\n\n        emit AmoMinterAdded(amoMinterAddress);\n    }\n\n    /**\n     * @notice Adds a new collateral token\n     * @param collateralAddress Collateral token address\n     * @param chainLinkPriceFeedAddress Chainlink's price feed address\n     * @param poolCeiling Max amount of available tokens for collateral\n     */\n    function addCollateralToken(\n        address collateralAddress,\n        address chainLinkPriceFeedAddress,\n        uint256 poolCeiling\n    ) internal {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n\n        uint256 collateralIndex = poolStorage.collateralAddresses.length;\n\n        // add collateral address to all collaterals\n        poolStorage.collateralAddresses.push(collateralAddress);\n\n        // for fast collateral address -> collateral idx lookups later\n        poolStorage.collateralIndex[collateralAddress] = collateralIndex;\n\n        // set collateral initially to disabled\n        poolStorage.isCollateralEnabled[collateralAddress] = false;\n\n        // add in the missing decimals\n        poolStorage.missingDecimals.push(\n            uint256(18).sub(ERC20(collateralAddress).decimals())\n        );\n\n        // add in the collateral symbols\n        poolStorage.collateralSymbols.push(ERC20(collateralAddress).symbol());\n\n        // initialize unclaimed pool collateral\n        poolStorage.unclaimedPoolCollateral.push(0);\n\n        // initialize paused prices to $1 as a backup\n        poolStorage.collateralPrices.push(UBIQUITY_POOL_PRICE_PRECISION);\n\n        // set fees to 0 by default\n        poolStorage.mintingFee.push(0);\n        poolStorage.redemptionFee.push(0);\n\n        // handle the pauses\n        poolStorage.isMintPaused.push(false);\n        poolStorage.isRedeemPaused.push(false);\n        poolStorage.isBorrowPaused.push(false);\n\n        // set pool ceiling\n        poolStorage.poolCeilings.push(poolCeiling);\n\n        // set price feed address\n        poolStorage.collateralPriceFeedAddresses.push(\n            chainLinkPriceFeedAddress\n        );\n\n        // set price feed staleness threshold in seconds\n        poolStorage.collateralPriceFeedStalenessThresholds.push(1 days);\n    }\n\n    /**\n     * @notice Removes AMO minter\n     * @param amoMinterAddress AMO minter address to remove\n     */\n    function removeAmoMinter(address amoMinterAddress) internal {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n\n        poolStorage.isAmoMinterEnabled[amoMinterAddress] = false;\n\n        emit AmoMinterRemoved(amoMinterAddress);\n    }\n\n    /**\n     * @notice Sets collateral ChainLink price feed params\n     * @param collateralAddress Collateral token address\n     * @param chainLinkPriceFeedAddress ChainLink price feed address\n     * @param stalenessThreshold Threshold in seconds when chainlink answer should be considered stale\n     */\n    function setCollateralChainLinkPriceFeed(\n        address collateralAddress,\n        address chainLinkPriceFeedAddress,\n        uint256 stalenessThreshold\n    ) internal {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n\n        uint256 collateralIndex = poolStorage.collateralIndex[\n            collateralAddress\n        ];\n\n        // set price feed address\n        poolStorage.collateralPriceFeedAddresses[\n            collateralIndex\n        ] = chainLinkPriceFeedAddress;\n\n        // set staleness threshold in seconds when chainlink answer should be considered stale\n        poolStorage.collateralPriceFeedStalenessThresholds[\n            collateralIndex\n        ] = stalenessThreshold;\n\n        emit CollateralPriceFeedSet(\n            collateralIndex,\n            chainLinkPriceFeedAddress,\n            stalenessThreshold\n        );\n    }\n\n    /**\n     * @notice Sets mint and redeem fees, 1_000_000 = 100%\n     * @param collateralIndex Collateral token index\n     * @param newMintFee New mint fee\n     * @param newRedeemFee New redeem fee\n     */\n    function setFees(\n        uint256 collateralIndex,\n        uint256 newMintFee,\n        uint256 newRedeemFee\n    ) internal {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n\n        poolStorage.mintingFee[collateralIndex] = newMintFee;\n        poolStorage.redemptionFee[collateralIndex] = newRedeemFee;\n\n        emit FeesSet(collateralIndex, newMintFee, newRedeemFee);\n    }\n\n    /**\n     * @notice Sets max amount of collateral for a particular collateral token\n     * @param collateralIndex Collateral token index\n     * @param newCeiling Max amount of collateral\n     */\n    function setPoolCeiling(\n        uint256 collateralIndex,\n        uint256 newCeiling\n    ) internal {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n\n        poolStorage.poolCeilings[collateralIndex] = newCeiling;\n\n        emit PoolCeilingSet(collateralIndex, newCeiling);\n    }\n\n    /**\n     * @notice Sets mint and redeem price thresholds, 1_000_000 = $1.00\n     * @param newMintPriceThreshold New mint price threshold\n     * @param newRedeemPriceThreshold New redeem price threshold\n     */\n    function setPriceThresholds(\n        uint256 newMintPriceThreshold,\n        uint256 newRedeemPriceThreshold\n    ) internal {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n\n        poolStorage.mintPriceThreshold = newMintPriceThreshold;\n        poolStorage.redeemPriceThreshold = newRedeemPriceThreshold;\n\n        emit PriceThresholdsSet(newMintPriceThreshold, newRedeemPriceThreshold);\n    }\n\n    /**\n     * @notice Sets a redemption delay in blocks\n     * @dev Redeeming is split in 2 actions:\n     * @dev 1. `redeemDollar()`\n     * @dev 2. `collectRedemption()`\n     * @dev `newRedemptionDelayBlocks` sets number of blocks that should be mined after which user can call `collectRedemption()`\n     * @param newRedemptionDelayBlocks Redemption delay in blocks\n     */\n    function setRedemptionDelayBlocks(\n        uint256 newRedemptionDelayBlocks\n    ) internal {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n\n        poolStorage.redemptionDelayBlocks = newRedemptionDelayBlocks;\n\n        emit RedemptionDelayBlocksSet(newRedemptionDelayBlocks);\n    }\n\n    /**\n     * @notice Toggles (i.e. enables/disables) a particular collateral token\n     * @param collateralIndex Collateral token index\n     */\n    function toggleCollateral(uint256 collateralIndex) internal {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n\n        address collateralAddress = poolStorage.collateralAddresses[\n            collateralIndex\n        ];\n        poolStorage.isCollateralEnabled[collateralAddress] = !poolStorage\n            .isCollateralEnabled[collateralAddress];\n\n        emit CollateralToggled(\n            collateralIndex,\n            poolStorage.isCollateralEnabled[collateralAddress]\n        );\n    }\n\n    /**\n     * @notice Toggles pause for mint/redeem/borrow methods\n     * @param collateralIndex Collateral token index\n     * @param toggleIndex Method index. 0 - toggle mint pause, 1 - toggle redeem pause, 2 - toggle borrow by AMO pause\n     */\n    function toggleMintRedeemBorrow(\n        uint256 collateralIndex,\n        uint8 toggleIndex\n    ) internal {\n        UbiquityPoolStorage storage poolStorage = ubiquityPoolStorage();\n\n        if (toggleIndex == 0)\n            poolStorage.isMintPaused[collateralIndex] = !poolStorage\n                .isMintPaused[collateralIndex];\n        else if (toggleIndex == 1)\n            poolStorage.isRedeemPaused[collateralIndex] = !poolStorage\n                .isRedeemPaused[collateralIndex];\n        else if (toggleIndex == 2)\n            poolStorage.isBorrowPaused[collateralIndex] = !poolStorage\n                .isBorrowPaused[collateralIndex];\n\n        emit MintRedeemBorrowToggled(collateralIndex, toggleIndex);\n    }\n}"
    },
    {
      "filename": "ubiquity-dollar/packages/contracts/src/dollar/libraries/LibUbiquityPool.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.19;\n\nimport {AggregatorV3Interface} from \"@chainlink/interfaces/AggregatorV3Interface.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {IDollarAmoMinter} from \"../interfaces/IDollarAmoMinter.sol\";\nimport {IERC20Ubiquity} from \"../interfaces/IERC20Ubiquity.sol\";\nimport {UBIQUITY_POOL_PRICE_PRECISION} from \"./Constants.sol\";\nimport {LibAppStorage} from \"./LibAppStorage.sol\";\nimport {LibTWAPOracle} from \"./LibTWAPOracle.sol\";\n\n/**\n * @notice Ubiquity pool library\n * @notice Allows users to:\n * - deposit collateral in exchange for Ubiquity Dollars\n * - redeem Ubiquity Dollars in exchange for the earlier provided collateral\n */\nlibrary LibUbiquityPool {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    /// @notice Storage slot used to store data for this library\n    bytes32 constant UBIQUITY_POOL_STORAGE_POSITION =\n        bytes32(\n            uint256(keccak256(\"ubiquity.contracts.ubiquity.pool.storage\")) - 1\n        );\n\n    /// @notice Struct used as a storage for this library\n    struct UbiquityPoolStorage {\n        //========\n        // Core\n        //========\n        // minter address -> is it enabled\n        mapping(address amoMinter => bool isEnabled) isAmoMinterEnabled;\n        //======================\n        // Collateral related\n        //======================\n        // available collateral tokens\n        address[] collateralAddresses;\n        // collateral address -> collateral index\n        mapping(address collateralAddress => uint256 collateralIndex) collateralIndex;\n        // collateral index -> chainlink price feed addresses\n        address[] collateralPriceFeedAddresses;\n        // collateral index -> threshold in seconds"
    }
  ]
}