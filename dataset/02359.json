{
  "Title": "Uninitialized implementation contract [samples]",
  "Content": "The `SimpleAccountFactory` [creates a new implementation contract](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/SimpleAccountFactory.sol#L19) but does not [initialize it](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/SimpleAccount.sol#L80). This means that anyone can initialize the implementation contract to become its owner.\n\n\nThe consequences depend on the version of OpenZeppelin contracts in use. The project [requires release 4.2](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/package.json#L57) and later, but [release 4.8](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/yarn.lock#L804) is locked. The `onlyProxy` modifier was introduced in release 4.3.2 to protect the upgrade mechanism. Without this modifier, the owner is [authorized](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/SimpleAccount.sol#L151) to call the upgrade functions on the implementation contract directly, [which lets them `selfdestruct` it](https://forum.openzeppelin.com/t/uupsupgradeable-vulnerability-post-mortem/15680).\n\n\nWith the locked version, the implementation owner can [execute arbitrary calls](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/SimpleAccount.sol#L56-L73) from the implementation contract, but should not be able to interfere with the operation of the proxies.\n\n\nNevertheless, to reduce the attack surface, consider restricting the versions of OpenZeppelin contracts that are supported and [disabling the initializer](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.8.0/contracts/proxy/utils/Initializable.sol#L144) in the constructor of the `SimpleAccount` contract, to prevent anyone from claiming ownership.\n\n\n***Update:** Resolved in [pull request #201](https://github.com/eth-infinitism/account-abstraction/pull/201) and merged at commit [`4004ebf`](https://github.com/eth-infinitism/account-abstraction/commit/4004ebf1fa615c94801605f042a20d7cf1146fee).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/samples/SimpleAccountFactory.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/utils/Create2.sol\";\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\n\nimport \"./SimpleAccount.sol\";\n\n/**\n * A sample factory contract for SimpleAccount\n * A UserOperations \"initCode\" holds the address of the factory, and a method call (to createAccount, in this sample factory).\n * The factory's createAccount returns the target account address even if it is already installed.\n * This way, the entryPoint.getSenderAddress() can be called either before or after the account is created.\n */\ncontract SimpleAccountFactory {\n    SimpleAccount public immutable accountImplementation;\n\n    constructor(IEntryPoint _entryPoint){\n        accountImplementation = new SimpleAccount(_entryPoint);\n    }\n\n    /**\n     * create an account, and return its address.\n     * returns the address even if the account is already deployed.\n     * Note that during UserOperation execution, this method is called only if the account is not deployed.\n     * This method returns an existing account address so that entryPoint.getSenderAddress() would work even after account creation\n     */\n    function createAccount(address owner, uint salt) public returns (SimpleAccount ret) {\n        address addr = getAddress(owner, salt);\n        uint codeSize = addr.code.length;\n        if (codeSize > 0) {\n            return SimpleAccount(payable(addr));\n        }\n        ret = SimpleAccount(payable(new ERC1967Proxy{salt : bytes32(salt)}(\n                address(accountImplementation),\n                abi.encodeCall(SimpleAccount.initialize, (owner))\n            )));\n    }\n\n    /**\n     * calculate the counterfactual address of this account as it would be returned by createAccount()\n     */\n    function getAddress(address owner, uint salt) public view returns (address) {\n        return Create2.computeAddress(bytes32(salt), keccak256(abi.encodePacked(\n                type(ERC1967Proxy).creationCode,\n                abi.encode(\n                    address(accountImplementation),\n                    abi.encodeCall(SimpleAccount.initialize, (owner))\n                )\n            )));\n    }\n}"
    },
    {
      "filename": "package.json",
      "content": "{\n  \"name\": \"accountabstraction\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"scripts\": {\n    \"clean\": \"rm -rf cache artifacts typechain typechain-types\",\n    \"compile\": \"./scripts/hh-wrapper compile\",\n    \"tsc\": \"tsc\",\n    \"lint\": \"yarn compile && yarn run lint:sol && yarn run lint:js \",\n    \"lint:js\": \"eslint -f unix .\",\n    \"lint-fix\": \"eslint -f unix . --fix\",\n    \"lint:sol\": \"solhint -f unix \\\"contracts/**/*.sol\\\" --max-warnings 0\",\n    \"gas-calc\": \"./scripts/gascalc\",\n    \"mocha-gascalc\": \"TS_NODE_TRANSPILE_ONLY=1 npx ts-mocha --bail gascalc/*\",\n    \"test\": \"./scripts/hh-wrapper test\",\n    \"coverage\": \"COVERAGE=1 hardhat coverage\",\n    \"deploy\": \"./scripts/hh-wrapper deploy\",\n    \"test-dev\": \"hardhat test --network dev\",\n    \"ci\": \"yarn compile && hardhat test && yarn run runop\",\n    \"ci-gas-calc\": \"yarn gas-calc && yarn check-gas-reports\",\n    \"check-gas-reports\": \"./scripts/check-gas-reports\",\n    \"runop\": \"hardhat run src/runop.ts \",\n    \"runop-goerli\": \"AA_URL=https://account-abstraction-goerli.nethermind.io yarn runop --network goerli\",\n    \"runop3\": \"hardhat run src/runop3.ts \"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"devDependencies\": {\n    \"@nomiclabs/hardhat-ethers\": \"^2.0.2\",\n    \"@nomiclabs/hardhat-waffle\": \"^2.0.1\",\n    \"@typechain/ethers-v5\": \"^10.1.0\",\n    \"@types/chai\": \"^4.2.21\",\n    \"@types/node\": \"^16.4.12\",\n    \"@typescript-eslint/eslint-plugin\": \"^5.30.5\",\n    \"@typescript-eslint/parser\": \"^5.30.5\",\n    \"chai\": \"^4.3.4\",\n    \"eslint\": \"^8.19.0\",\n    \"eslint-config-standard\": \"^17.0.0\",\n    \"eslint-config-standard-with-typescript\": \"^21.0.1\",\n    \"eslint-plugin-import\": \"^2.26.0\",\n    \"eslint-plugin-node\": \"^11.1.0\",\n    \"eslint-plugin-promise\": \"^6.0.0\",\n    \"eslint-plugin-standard\": \"^5.0.0\",\n    \"ethereum-waffle\": \"^3.4.0\",\n    \"ethers\": \"^5.4.2\",\n    \"hardhat\": \"^2.6.6\",\n    \"solhint\": \"^3.3.7\",\n    \"ts-generator\": \"^0.1.1\",\n    \"ts-mocha\": \"^10.0.0\",\n    \"ts-node\": \"^10.1.0\",\n    \"typechain\": \"^8.1.0\"\n  },\n  \"dependencies\": {\n    \"@gnosis.pm/safe-contracts\": \"^1.3.0\",\n    \"@nomiclabs/hardhat-etherscan\": \"^2.1.6\",\n    \"@openzeppelin/contracts\": \"^4.2.0\",\n    \"@thehubbleproject/bls\": \"^0.5.1\",\n    \"@typechain/hardhat\": \"^2.3.0\",\n    \"@types/mocha\": \"^9.0.0\",\n    \"ethereumjs-util\": \"^7.1.0\",\n    \"ethereumjs-wallet\": \"^1.0.1\",\n    \"hardhat-deploy\": \"^0.9.3\",\n    \"hardhat-deploy-ethers\": \"^0.3.0-beta.11\",\n    \"solidity-coverage\": \"^0.7.18\",\n    \"source-map-support\": \"^0.5.19\",\n    \"table\": \"^6.8.0\",\n    \"typescript\": \"^4.3.5\"\n  }\n}"
    },
    {
      "filename": "contracts/samples/SimpleAccount.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-inline-assembly */\n/* solhint-disable reason-string */\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\";\n\nimport \"../core/BaseAccount.sol\";\n\n/**\n  * minimal account.\n  *  this is sample minimal account.\n  *  has execute, eth handling methods\n  *  has a single signer that can send requests through the entryPoint.\n  */\ncontract SimpleAccount is BaseAccount, UUPSUpgradeable, Initializable {\n    using ECDSA for bytes32;\n\n    //explicit sizes of nonce, to fit a single storage cell with \"owner\"\n    uint96 private _nonce;\n    address public owner;\n\n    function nonce() public view virtual override returns (uint256) {\n        return _nonce;\n    }\n\n    function entryPoint() public view virtual override returns (IEntryPoint) {\n        return _entryPoint;\n    }\n\n    IEntryPoint private immutable _entryPoint;\n\n    event SimpleAccountInitialized(IEntryPoint indexed entryPoint, address indexed owner);\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n\n    constructor(IEntryPoint anEntryPoint) {\n        _entryPoint = anEntryPoint;\n    }\n\n    modifier onlyOwner() {\n        _onlyOwner();\n        _;\n    }\n\n    function _onlyOwner() internal view {\n        //directly from EOA owner, or through the entryPoint (which gets redirected through execFromEntryPoint)\n        require(msg.sender == owner || msg.sender == address(this), \"only owner\");\n    }\n\n    /**\n     * execute a transaction (called directly from owner, not by entryPoint)\n     */\n    function execute(address dest, uint256 value, bytes calldata func) external {\n        _requireFromEntryPointOrOwner();\n        _call(dest, value, func);\n    }\n\n    /**\n     * execute a sequence of transaction\n     */\n    function executeBatch(address[] calldata dest, bytes[] calldata func) external {\n        _requireFromEntryPointOrOwner();\n        require(dest.length == func.length, \"wrong array lengths\");\n        for (uint256 i = 0; i < dest.length; i++) {\n            _call(dest[i], 0, func[i]);\n        }\n    }\n\n    /**\n     * change entry-point:\n     * an account must have a method for replacing the entryPoint, in case the the entryPoint is\n     * upgraded to a newer version.\n     */\n    function initialize(address anOwner) public virtual initializer {\n        _initialize(anOwner);\n    }\n\n    function _initialize(address anOwner) internal virtual {\n        owner = anOwner;\n        emit SimpleAccountInitialized(_entryPoint, owner);\n    }\n\n    /**\n     * validate the userOp is correct.\n     * revert if it doesn't.\n     * - must only be called from the entryPoint.\n     * - make sure the signature is of our supported signer.\n     * - validate current nonce matches request nonce, and increment it.\n     * - pay prefund, in case current deposit is not enough\n     */\n    function _requireFromEntryPointOrOwner() internal view {\n        require(msg.sender == address(entryPoint()) || msg.sender == owner, \"account: not Owner or EntryPoint\");\n    }\n\n    /// implement template method of BaseAccount\n    function _validateAndUpdateNonce(UserOperation calldata userOp) internal override {\n        require(_nonce++ == userOp.nonce, \"account: invalid nonce\");\n    }\n\n    /// implement template method of BaseAccount\n    function _validateSignature(UserOperation calldata userOp, bytes32 userOpHash, address)\n    internal override virtual returns (uint256 sigTimeRange) {\n        bytes32 hash = userOpHash.toEthSignedMessageHash();\n        if (owner != hash.recover(userOp.signature))\n            return SIG_VALIDATION_FAILED;\n        return 0;\n    }\n\n    function _call(address target, uint256 value, bytes memory data) internal {\n        (bool success, bytes memory result) = target.call{value : value}(data);\n        if (!success) {\n            assembly {\n                revert(add(result, 32), mload(result))\n            }\n        }\n    }\n\n    /**\n     * check current account deposit in the entryPoint\n     */\n    function getDeposit() public view returns (uint256) {\n        return entryPoint().balanceOf(address(this));\n    }\n\n    /**\n     * deposit more funds for this account in the entryPoint\n     */\n    function addDeposit() public payable {\n\n        (bool req,) = address(entryPoint()).call{value : msg.value}(\"\");\n        require(req);\n    }\n\n    /**\n     * withdraw value from the account's deposit\n     * @param withdrawAddress target to send to\n     * @param amount to withdraw\n     */\n    function withdrawDepositTo(address payable withdrawAddress, uint256 amount) public onlyOwner {\n        entryPoint().withdrawTo(withdrawAddress, amount);\n    }\n\n    function _authorizeUpgrade(address newImplementation) internal view override {\n        (newImplementation);\n        _onlyOwner();\n    }\n}"
    },
    {
      "filename": "contracts/proxy/utils/Initializable.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Internal function that returns the initialized version. Returns `_initialized`\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Internal function that returns the initialized version. Returns `_initializing`\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}"
    }
  ]
}