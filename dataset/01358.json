{
  "Title": "Extract logic for the last element when looping over Stems in `EnrootFacet::enrootDeposits`",
  "Content": "Currently, the `i+1 == stems.length` [condition](https://github.com/BeanstalkFarms/Beanstalk/blob/c7a20e56a0a6659c09314a877b440198eff0cd81/protocol/contracts/beanstalk/silo/EnrootFacet.sol#L139) is checked during each iteration when looping over Stems in `EnrootFacet::enrootDeposits`. This can be modified to save gas, as shown below:\n\n```diff\n// EnrootFacet::enrootDeposits\n//...\n+       uint256 stemsLengthMinusOne = stems.length - 1;\n-       for (uint256 i; i < stems.length; ++i) {\n+       for (uint256 i; i < stems.stemsLengthMinusOne; ++i) {\n-           if (i+1 == stems.length) {\n-               // Ensure that a rounding error does not occur by using the\n-               // remainder BDV for the last Deposit.\n-               depositBdv = newTotalBdv.sub(bdvAdded);\n-           } else {\n                // depositBdv is a proportional amount of the total bdv.\n                // Cheaper than calling the BDV function multiple times.\n                depositBdv = amounts[i].mul(newTotalBdv).div(ar.tokensRemoved);\n-           }\n            LibTokenSilo.addDepositToAccount(\n                msg.sender,\n                token,\n                stems[i],\n                amounts[i],\n                depositBdv,\n                LibTokenSilo.Transfer.noEmitTransferSingle\n            );\n\n            stalkAdded = stalkAdded.add(\n                depositBdv.mul(_stalkPerBdv).add(\n                    LibSilo.stalkReward(\n                        stems[i],\n                        _lastStem,\n                        uint128(depositBdv)\n                    )\n                )\n            );\n\n            bdvAdded = bdvAdded.add(depositBdv);\n        }\n+       depositBdv = newTotalBdv.sub(bdvAdded);\n+       LibTokenSilo.addDepositToAccount(\n+           msg.sender,\n+           token,\n+           stems[stemsLengthMinusOne],\n+           amounts[stemsLengthMinusOne],\n+           depositBdv,\n+           LibTokenSilo.Transfer.noEmitTransferSingle\n+       );\n+\n+       stalkAdded = stalkAdded.add(\n+           depositBdv.mul(_stalkPerBdv).add(\n+               LibSilo.stalkReward(\n+                   stems[stemsLengthMinusOne],\n+                   _lastStem,\n+                   uint128(depositBdv)\n+               )\n+           )\n+       );\n+\n+       bdvAdded = bdvAdded.add(depositBdv);\n//...\n```",
  "Impact": "GAS",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/beanstalk/silo/EnrootFacet.sol",
      "content": "/**\n * SPDX-License-Identifier: MIT\n **/\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \"contracts/libraries/Silo/LibSilo.sol\";\nimport \"contracts/libraries/Silo/LibTokenSilo.sol\";\nimport \"./SiloFacet/Silo.sol\";\nimport \"contracts/libraries/LibSafeMath32.sol\";\nimport \"../ReentrancyGuard.sol\";\n\n\n/**\n * @author Publius\n * @title Enroot Facet handles enrooting Update Deposits\n **/\ncontract EnrootFacet is ReentrancyGuard {\n    using SafeMath for uint256;\n\n    event RemoveDeposit(\n        address indexed account,\n        address indexed token,\n        int128 stem,\n        uint256 amount,\n        uint256 bdv\n    );\n\n    event RemoveDeposits(\n        address indexed account,\n        address indexed token,\n        int96[] stems,\n        uint256[] amounts,\n        uint256 amount,\n        uint256[] bdvs\n    );\n\n    //////////////////////// UPDATE UNRIPE DEPOSITS ////////////////////////\n\n    /**\n     * @notice Update the BDV of an Unripe Deposit. Allows the user to claim\n     * Stalk as the BDV of Unripe tokens increases during the Barn\n     * Raise. This was introduced as a part of the Replant.\n     *\n     * @dev Should revert if `ogBDV > newBDV`. A user cannot lose BDV during an\n     * Enroot operation.\n     *\n     * Gas optimization: We neglect to check if `token` is whitelisted. If a\n     * token is not whitelisted, it cannot be Deposited, and thus cannot be Removed.\n     * \n     * {LibTokenSilo-removeDepositFromAccount} should revert if there isn't\n     * enough balance of `token` to remove.\n     * Because the amount and the stem of an Deposit does not change, \n     * an ERC1155 event does not need to be emitted.\n     */\n    function enrootDeposit(\n        address token,\n        int96 stem,\n        uint256 amount\n    ) external payable nonReentrant mowSender(token) {\n        require(s.u[token].underlyingToken != address(0), \"Silo: token not unripe\");\n        // First, remove Deposit and Redeposit with new BDV\n        uint256 ogBDV = LibTokenSilo.removeDepositFromAccount(\n            msg.sender,\n            token,\n            stem,\n            amount\n        );\n        emit RemoveDeposit(msg.sender, token, stem, amount, ogBDV); // Remove Deposit does not emit an event, while Add Deposit does.\n\n        // Calculate the current BDV for `amount` of `token` and add a Deposit.\n        uint256 newBDV = LibTokenSilo.beanDenominatedValue(token, amount);\n\n        LibTokenSilo.addDepositToAccount(\n            msg.sender, \n            token, \n            stem, \n            amount, \n            newBDV,\n            LibTokenSilo.Transfer.noEmitTransferSingle\n        ); // emits AddDeposit event\n\n        // Calculate the difference in BDV. Reverts if `ogBDV > newBDV`.\n        uint256 deltaBDV = newBDV.sub(ogBDV);\n        LibTokenSilo.incrementTotalDepositedBdv(token, deltaBDV);\n\n        // Mint Stalk associated with the new BDV.\n        uint256 deltaStalk = deltaBDV.mul(s.ss[token].stalkIssuedPerBdv).add(\n            LibSilo.stalkReward(stem,\n                                LibTokenSilo.stemTipForToken(token),\n                                uint128(deltaBDV))\n        );\n\n        LibSilo.mintStalk(msg.sender, deltaStalk);\n    }\n\n    modifier mowSender(address token) {\n       LibSilo._mow(msg.sender, token);\n        _;\n    }\n\n    /** \n     * @notice Update the BDV of Unripe Deposits. Allows the user to claim Stalk\n     * as the BDV of Unripe tokens increases during the Barn Raise.\n     * This was introduced as a part of the Replant.\n     *\n     * @dev Should revert if `ogBDV > newBDV`. A user cannot lose BDV during an\n     * Enroot operation.\n     *\n     * Gas optimization: We neglect to check if `token` is whitelisted. If a\n     * token is not whitelisted, it cannot be Deposited, and thus cannot be Removed.\n     * {removeDepositsFromAccount} should revert if there isn't enough balance of `token`\n     * to remove.\n     */\n    function enrootDeposits(\n        address token,\n        int96[] calldata stems,\n        uint256[] calldata amounts\n    ) external payable nonReentrant mowSender(token) {\n        require(s.u[token].underlyingToken != address(0), \"Silo: token not unripe\");\n        // First, remove Deposits because every deposit is in a different season,\n        // we need to get the total Stalk, not just BDV.\n        LibSilo.AssetsRemoved memory ar = LibSilo._removeDepositsFromAccount(msg.sender, token, stems, amounts);\n\n        // Get new BDV\n        uint256 newTotalBdv = LibTokenSilo.beanDenominatedValue(token, ar.tokensRemoved);\n        uint256 stalkAdded; uint256 bdvAdded;\n\n        //pulled these vars out because of \"CompilerError: Stack too deep, try removing local variables.\"\n        int96 _lastStem = LibTokenSilo.stemTipForToken(token); //need for present season\n        uint32 _stalkPerBdv = s.ss[token].stalkIssuedPerBdv;\n\n        uint256 depositBdv;\n\n        // Iterate through all stems, redeposit the tokens with new BDV and\n        // summate new Stalk.\n        for (uint256 i; i < stems.length; ++i) {\n            if (i+1 == stems.length) {\n                // Ensure that a rounding error does not occur by using the\n                // remainder BDV for the last Deposit.\n                depositBdv = newTotalBdv.sub(bdvAdded);\n            } else {\n                // depositBdv is a proportional amount of the total bdv.\n                // Cheaper than calling the BDV function multiple times.\n                depositBdv = amounts[i].mul(newTotalBdv).div(ar.tokensRemoved);\n            }\n            LibTokenSilo.addDepositToAccount(\n                msg.sender,\n                token,\n                stems[i],\n                amounts[i],\n                depositBdv,\n                LibTokenSilo.Transfer.noEmitTransferSingle\n            );\n            \n            stalkAdded = stalkAdded.add(\n                depositBdv.mul(_stalkPerBdv).add(\n                    LibSilo.stalkReward(\n                        stems[i],\n                        _lastStem,\n                        uint128(depositBdv)\n                    )\n                )\n            );\n\n            bdvAdded = bdvAdded.add(depositBdv);\n        }\n\n        LibTokenSilo.incrementTotalDepositedBdv(token, bdvAdded.sub(ar.bdvRemoved));\n\n        // Mint Stalk associated with the delta BDV.\n        LibSilo.mintStalk(\n            msg.sender,\n            stalkAdded.sub(ar.stalkRemoved)\n        );\n    }\n}"
    }
  ]
}