{
  "Title": "M-1: Pairs with \"MAX_FEE\" can revert due to rounding inconsistencies",
  "Content": "# Issue M-1: Pairs with \"MAX_FEE\" can revert due to rounding inconsistencies \n\nSource: https://github.com/sherlock-audit/2024-02-rubicon-finance-judging/issues/51 \n\n## Found by \nKingNFT, Kow, cawfree, mstpr-brainbot\n## Summary\nIf the pair has set the max fee by the fee controller admin which is \"1_000\" then depending on the amount to be swapped, the tx can revert due to rounding error. \n## Vulnerability Detail\nWhen the fee amount is calculated inside the RubiconFeeController, the fee amount is rounded down. \n```solidity\nuint256 feeAmount = fee.applyFee\n                ? order.outputs[i].amount.mulDivUp(fee.fee, DENOM)\n                : order.outputs[i].amount.mulDivUp(baseFee, DENOM);\n```\n\nthen, ProtocolFees abstract contract will do a double check on the fee taken as follows:\n\n```solidity\nif (feeOutput.amount > tokenValue.mulDivDown(MAX_FEE, DENOM)) {\n                revert FeeTooLarge(\n                    feeOutput.token,\n                    feeOutput.amount,\n                    feeOutput.recipient\n                );\n            }\n```\nAs we can see, it uses mulDivDown, so if the calculation in the FeeController rounds up, the transaction will revert.\n\n**Textual PoC:**\nSuppose the fee pair is set to \"1_000\" for tokens A and B.\nAlice sends an order to sell \"111111111111111111111\" (111.11 in 18 decimals) token A for token B.\n\nWithin the fee controller, the fee amount will be calculated as:\n111111111111111111111 * 1000 / 100_000 (roundUp) = 1111111111111111112\n\nSubsequently, during execution, within the ProtocolFees contract, the maximum fee amount will be computed as:\n111111111111111111111 * 1000 / 100_000 (roundDown) = 1111111111111111111\n\nConsequently, the transaction will revert because 1111111111111111111 > 1111111111111111112.\n\n**Coded PoC:**\n```solidity\n// forge test --match-contract GladiusReactorTest --match-test test_FeesRounding -vv\n    function test_FeesRounding(uint amount) external {\n        // @dev there will be plenty of values reverting this test. \n        vm.assume(amount <= type(uint128).max);\n        vm.assume(amount >= 1e6);\n\n        uint DENOM = 100_000;\n        uint FEE = 1_000;\n\n        uint resultDown = FixedPointMathLib.mulDivDown(amount, FEE, DENOM);\n        uint resultUp = FixedPointMathLib.mulDivUp(amount, FEE, DENOM);\n\n        assertEq(resultDown, resultUp);\n    }\n```\n## Impact\nAs stated in README:\n**Fee Controller Can DOS Trading Activity. Note, that, as said above, the resulting output shouldn't overflow MAX_FEE, but other possibilities of reverts are known/acceptable.** Any fee setting in range 0<MAX_FEE should not revert and if it reverts then its acceptable. Hence, I'll label this as medium.\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-02-rubicon-finance/blob/11cac67919e8a1303b3a3177291b88c0c70bf03b/gladius-contracts-internal/src/fee-controllers/RubiconFeeController.sol#L63-L116\n\nhttps://github.com/sherlock-audit/2024-02-rubicon-finance/blob/11cac67919e8a1303b3a3177291b88c0c70bf03b/gladius-contracts-internal/src/base/ProtocolFees.sol#L39-L105\n## Tool used\n\nManual Review\n\n## Recommendation\n\n\n\n## Discussion\n\n**sherlock-admin**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**0xAadi** commented:\n> \n\n\n\n**sherlock-admin2**\n\n> Escalate \n> \n> Invalid this already a known issue reported in the open zeppelin audit of uniswapx\n> https://github.com/Uniswap/UniswapX/blob/main/audit/v1.1/OpenZeppelin.pdf\n> Look for L-02\n> \n> from contest readme\n> > Please list any known issues/acceptable risks that should not result in a valid finding.\n> From OZ audit - https://github.com/Uniswap/UniswapX/blob/main/audit/v1.1/OpenZeppelin.pdf\n> \n> \n> The uniswapX decided to keep this issue as wont fix.\n> \n> also from rubicon readme\n> > GladiusReactor is based on UniswapXâ€™s ExclusiveDutchOrderReactor and intended to support ExclusiveDutchOrders.\n> \n> Changes in fee calculation may result in support for ExclusiveDutchOrders not working. Therefore this should be set as wont fix and also invalid.\n\nYou've deleted an escalation for this issue.\n\n**daoio**\n\nthe issue is valid, because the audit doc [specifically states](https://github.com/sherlock-audit/2024-02-rubicon-finance?tab=readme-ov-file#q-please-list-any-known-issuesacceptable-risks-that-should-not-result-in-a-valid-finding) that while a DoS possibility from a fee-controller is a known and acceptable issue, the possibility of the `MAX_FEE` overflow isn't acceptable. \nMoreover, it not only notes a likelihood of a rounding error, but the root of its occurency - an incosistency between calculations in `RubiconFeeController` and `ProtocolFees`, where *validation* of the fee calculation is performed with a different function call (`mulDivDown` instead of `mulDivUp`)\n\n**ArnieGod**\n\n@daoio you are right, oversight on my part will remove escalation.\n\n**sherlock-admin**\n\nThe protocol team fixed this issue in PR/commit https://github.com/RubiconDeFi/gladius-contracts-internal/pull/16.\n\n**sherlock-admin**\n\nThe Lead Senior Watson signed-off on the fix.\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/184",
  "Code": [
    {
      "filename": "gladius-contracts-internal/src/fee-controllers/RubiconFeeController.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {IProtocolFeeController} from \"../interfaces/IProtocolFeeController.sol\";\nimport {FixedPointMathLib} from \"solmate/src/utils/FixedPointMathLib.sol\";\nimport {ResolvedOrder, OutputToken} from \"../base/ReactorStructs.sol\";\nimport {GladiusReactor} from \"../reactors/GladiusReactor.sol\";\nimport {ProxyConstructor} from \"../lib/ProxyConstructor.sol\";\nimport {ERC20} from \"solmate/src/tokens/ERC20.sol\";\nimport {DSAuth} from \"../lib/DSAuth.sol\";\n\n/// @dev Fee controller, that's intended to be called by reactors.\n///      * By default applies constant 'BASE_FEE' on output token.\n///      * Dynamic pair-based fee can be enabled by calling 'setPairBasedFee'.\n///      * Both dynamic and base fee can be disabled by setting 'applyFee' to false.\ncontract RubiconFeeController is\n    IProtocolFeeController,\n    DSAuth,\n    ProxyConstructor\n{\n    using FixedPointMathLib for uint256;\n\n    uint256 private constant DENOM = 100_000;\n    uint256 public baseFee = 10;\n    address public feeRecipient;\n    GladiusReactor public gladiusReactor;\n\n    struct PairBasedFee {\n        bool applyFee;\n        uint256 fee;\n    }\n\n    /// @dev pair hash => pair-based fee\n    mapping(bytes32 => PairBasedFee) public fees;\n\n    /// @dev New fee isn't in correct boundaries.\n    error InvalidFee();\n\n    function initialize(\n        address _owner,\n        address _feeRecipient\n    ) external override {\n        if (initialized) revert AlreadyInitialized();\n        owner = _owner;\n        feeRecipient = _feeRecipient;\n\n        initialized = true;\n    }\n\n    /// @return hash - direction independent hash of the pair.\n    function getPairHash(\n        address tokenIn,\n        address tokenOut\n    ) public pure returns (bytes32 hash) {\n        address input = tokenIn > tokenOut ? tokenIn : tokenOut;\n        address output = input == tokenIn ? tokenOut : tokenIn;\n\n        hash = keccak256(bytes.concat(bytes20(input), bytes20(output)));\n    }\n\n    /// @inheritdoc IProtocolFeeController\n    /// @notice Applies fee on output values in the form of output[0].token.\n    function getFeeOutputs(\n        ResolvedOrder memory order\n    ) external view override returns (OutputToken[] memory result) {\t\n        /// @notice Right now the length is enforced by\n        ///         'GladiusReactor' to be equal to 1.\n        result = new OutputToken[](order.outputs.length);\n\n        address tokenIn = address(order.input.token);\n        uint256 feeCount;\n\n        for (uint256 i = 0; i < order.outputs.length; ++i) {\n            /// @dev Fee will be in the 'tokenOut' form.\n            address tokenOut = order.outputs[i].token;\n\n            PairBasedFee memory fee = fees[\n                getPairHash(address(tokenIn), tokenOut)\n            ];\n\n            uint256 feeAmount = fee.applyFee\n                ? order.outputs[i].amount.mulDivUp(fee.fee, DENOM)\n                : order.outputs[i].amount.mulDivUp(baseFee, DENOM);\n\n            /// @dev If fee is applied to pair.\n            if (feeAmount != 0) {\n                bool found;\n\n                for (uint256 j = 0; j < feeCount; ++j) {\n                    OutputToken memory feeOutput = result[j];\n\n                    if (feeOutput.token == tokenOut) {\n                        found = true;\n                        feeOutput.amount += feeAmount;\n                    }\n                }\n\n                if (!found) {\n                    result[feeCount] = OutputToken({\n                        token: tokenOut,\n                        amount: feeAmount,\n                        recipient: feeRecipient\n                    });\n                    feeCount++;\n                }\n            }\n        }\n\n        assembly {\n            // update array size to the actual number of unique fee outputs pairs\n            // since the array was initialized with an upper bound of the total number of outputs\n            // note: this leaves a few unused memory slots, but free memory pointer\n            // still points to the next fresh piece of memory\n            mstore(result, feeCount)\n        }\n    }\n\n    //---------------------------- ADMIN ----------------------------\n\n    function setPairBasedFee(\n        address tokenIn,\n        address tokenOut,\n        uint256 fee,\n        bool applyFee\n    ) external auth {\n\tif (fee > gladiusReactor.MAX_FEE())\n\t    revert InvalidFee();\n        bytes32 pairHash = getPairHash(tokenIn, tokenOut);\n        fees[pairHash] = PairBasedFee({applyFee: applyFee, fee: fee});\n    }\n\n    function setBaseFee(uint256 bFee) external auth {\n\tif (bFee == 0 || bFee > gladiusReactor.MAX_FEE())\n\t    revert InvalidFee();\n\tbaseFee = bFee;\n    }\n\n    function setFeeRecipient(address recipient) external auth {\n        feeRecipient = recipient;\n    }\n\n    function setGladiusReactor(address payable gr) external auth {\n\tgladiusReactor = GladiusReactor(gr);\n    }\n}"
    },
    {
      "filename": "gladius-contracts-internal/src/base/ProtocolFees.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {IProtocolFeeController} from \"../interfaces/IProtocolFeeController.sol\";\nimport {FixedPointMathLib} from \"solmate/src/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solmate/src/utils/SafeTransferLib.sol\";\nimport {ResolvedOrder, OutputToken} from \"../base/ReactorStructs.sol\";\nimport {CurrencyLibrary} from \"../lib/CurrencyLibrary.sol\";\nimport {ERC20} from \"solmate/src/tokens/ERC20.sol\";\nimport {DSAuth} from \"../lib/DSAuth.sol\";\n\n/// @notice Handling for protocol fees\nabstract contract ProtocolFees is DSAuth {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n    using CurrencyLibrary for address;\n\n    /// @notice thrown if two fee outputs have the same token\n    error DuplicateFeeOutput(address duplicateToken);\n    /// @notice thrown if a given fee output is greater than MAX_FEE_BPS of the order outputs\n    error FeeTooLarge(address token, uint256 amount, address recipient);\n    /// @notice thrown if a fee output token does not have a corresponding non-fee output\n    error InvalidFeeToken(address feeToken);\n\n    event ProtocolFeeControllerSet(\n        address oldFeeController,\n        address newFeeController\n    );\n\n    uint256 private constant DENOM = 100_000;\n    uint256 public constant MAX_FEE = 1_000;\n\n    /// @dev The address of the fee controller\n    IProtocolFeeController public feeController;\n\n    /// @notice Injects fees into an order\n    /// @dev modifies the orders to include protocol fee outputs\n    /// @param order The encoded order to inject fees into\n    function _injectFees(ResolvedOrder memory order) internal view {\n        if (address(feeController) == address(0)) {\n            return;\n        }\n\n        OutputToken[] memory feeOutputs = feeController.getFeeOutputs(order);\n        uint256 outputsLength = order.outputs.length;\n        uint256 feeOutputsLength = feeOutputs.length;\n\n        // apply fee outputs\n        // fill new outputs with old outputs\n        OutputToken[] memory newOutputs = new OutputToken[](\n            outputsLength + feeOutputsLength\n        );\n\n        unchecked {\n            for (uint256 i = 0; i < outputsLength; i++) {\n                newOutputs[i] = order.outputs[i];\n            }\n        }\n\n        for (uint256 i = 0; i < feeOutputsLength; ) {\n            OutputToken memory feeOutput = feeOutputs[i];\n            // assert no duplicates\n            unchecked {\n                for (uint256 j = 0; j < i; j++) {\n                    if (feeOutput.token == feeOutputs[j].token) {\n                        revert DuplicateFeeOutput(feeOutput.token);\n                    }\n                }\n            }\n\n            // assert not greater than MAX_FEE\n            uint256 tokenValue;\n            for (uint256 j = 0; j < outputsLength; ) {\n                OutputToken memory output = order.outputs[j];\n                if (output.token == feeOutput.token) {\n                    tokenValue += output.amount;\n                }\n                unchecked {\n                    j++;\n                }\n            }\n\n            // allow fee on input token as well\n            if (address(order.input.token) == feeOutput.token) {\n                tokenValue += order.input.amount;\n            }\n\n            if (tokenValue == 0) revert InvalidFeeToken(feeOutput.token);\n\t    \n            if (feeOutput.amount > tokenValue.mulDivDown(MAX_FEE, DENOM)) {\n                revert FeeTooLarge(\n                    feeOutput.token,\n                    feeOutput.amount,\n                    feeOutput.recipient\n                );\n            }\n            newOutputs[outputsLength + i] = feeOutput;\n\n            unchecked {\n                i++;\n            }\n        }\n\n        order.outputs = newOutputs;\n    }\n\n    /// @notice sets the protocol fee controller\n    /// @dev only callable by the owner\n    /// @param _newFeeController the new fee controller\n    function setProtocolFeeController(address _newFeeController) external auth {\n        address oldFeeController = address(feeController);\n        feeController = IProtocolFeeController(_newFeeController);\n        emit ProtocolFeeControllerSet(oldFeeController, _newFeeController);\n    }\n}"
    }
  ]
}