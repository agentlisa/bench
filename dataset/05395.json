{
  "Title": "[G-17] Optimize `computeTotalReward()` and `computePurchaseRewards` into one function to save gas",
  "Content": "\nBoth the functions below do the same computation, which is not required if the functions are combined into one. This will also prevent the rounding issue mentioned [here](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/protocol-rewards/src/abstract/RewardSplits.sol#L37).\n\nInstead of this:\n```solidity\nFile: RewardSplits.sol\n41:     function computeTotalReward(uint256 paymentAmountWei) public pure returns (uint256) {\n42:         if (paymentAmountWei <= minPurchaseAmount || paymentAmountWei >= maxPurchaseAmount) revert INVALID_ETH_AMOUNT();\n43: \n45:         return\n46:             (paymentAmountWei * BUILDER_REWARD_BPS) /\n47:             10_000 +\n48:             (paymentAmountWei * PURCHASE_REFERRAL_BPS) /\n49:             10_000 +\n50:             (paymentAmountWei * DEPLOYER_REWARD_BPS) /\n51:             10_000 +\n52:             (paymentAmountWei * REVOLUTION_REWARD_BPS) /\n53:             10_000;\n54:     }\n55: \n56:     function computePurchaseRewards(uint256 paymentAmountWei) public pure returns (RewardsSettings memory, uint256) {\n57:         return (\n58:             RewardsSettings({\n59:                 builderReferralReward: (paymentAmountWei * BUILDER_REWARD_BPS) / 10_000,\n60:                 purchaseReferralReward: (paymentAmountWei * PURCHASE_REFERRAL_BPS) / 10_000,\n61:                 deployerReward: (paymentAmountWei * DEPLOYER_REWARD_BPS) / 10_000,\n62:                 revolutionReward: (paymentAmountWei * REVOLUTION_REWARD_BPS) / 10_000\n63:             }),\n64:             computeTotalReward(paymentAmountWei)\n65:         );\n66:     }\n```\nUse this:\n\n```solidity\nFile: RewardSplits.sol\n41:     function computeTotalPurchaseRewards(uint256 paymentAmountWei) public pure returns (RewardsSettings memory, uint256) {\n42:         if (paymentAmountWei <= minPurchaseAmount || paymentAmountWei >= maxPurchaseAmount) revert INVALID_ETH_AMOUNT();\n43:         \n44:         uint256 br = (paymentAmountWei * BUILDER_REWARD_BPS) / 10_000;\n45:         uint256 pr = (paymentAmountWei * PURCHASE_REFERRAL_BPS) / 10_000;\n46:         uint256 dr = (paymentAmountWei * DEPLOYER_REWARD_BPS) / 10_000;\n47:         uint256 rr = (paymentAmountWei * REVOLUTION_REWARD_BPS) / 10_000;\n48:\n49:         return (\n50:             RewardsSettings({\n51:                 br,\n52:                 pr,\n53:                 dr,\n54:                 rr\n55:             }),\n56:             br + pr + dr + rr\n57:         );\n58:     }\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-12-revolutionprotocol",
  "Code": [
    {
      "filename": "packages/protocol-rewards/src/abstract/RewardSplits.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.22;\n\nimport { IRevolutionProtocolRewards } from \"../interfaces/IRevolutionProtocolRewards.sol\";\n\nstruct RewardsSettings {\n    uint256 builderReferralReward;\n    uint256 purchaseReferralReward;\n    uint256 deployerReward;\n    uint256 revolutionReward;\n}\n\n/// @notice Common logic for Revolution ERC20TokenEmitter contracts for protocol reward splits & deposits\nabstract contract RewardSplits {\n    error INVALID_ETH_AMOUNT();\n\n    // 2.5% total\n    uint256 internal constant DEPLOYER_REWARD_BPS = 25;\n    uint256 internal constant REVOLUTION_REWARD_BPS = 75;\n    uint256 internal constant BUILDER_REWARD_BPS = 100;\n    uint256 internal constant PURCHASE_REFERRAL_BPS = 50;\n\n    uint256 public constant minPurchaseAmount = 0.0000001 ether;\n    uint256 public constant maxPurchaseAmount = 50_000 ether;\n\n    address internal immutable revolutionRewardRecipient;\n    IRevolutionProtocolRewards internal immutable protocolRewards;\n\n    constructor(address _protocolRewards, address _revolutionRewardRecipient) payable {\n        if (_protocolRewards == address(0) || _revolutionRewardRecipient == address(0)) revert(\"Invalid Address Zero\");\n\n        protocolRewards = IRevolutionProtocolRewards(_protocolRewards);\n        revolutionRewardRecipient = _revolutionRewardRecipient;\n    }\n\n    /*\n     * @notice Sometimes has rounding errors vs. compute purchase rewards, use externally.\n     * @param _paymentAmountWei The amount of ETH being paid for the purchase\n     */\n    function computeTotalReward(uint256 paymentAmountWei) public pure returns (uint256) {\n        if (paymentAmountWei <= minPurchaseAmount || paymentAmountWei >= maxPurchaseAmount) revert INVALID_ETH_AMOUNT();\n\n        return\n            (paymentAmountWei * BUILDER_REWARD_BPS) /\n            10_000 +\n            (paymentAmountWei * PURCHASE_REFERRAL_BPS) /\n            10_000 +\n            (paymentAmountWei * DEPLOYER_REWARD_BPS) /\n            10_000 +\n            (paymentAmountWei * REVOLUTION_REWARD_BPS) /\n            10_000;\n    }\n\n    function computePurchaseRewards(uint256 paymentAmountWei) public pure returns (RewardsSettings memory, uint256) {\n        return (\n            RewardsSettings({\n                builderReferralReward: (paymentAmountWei * BUILDER_REWARD_BPS) / 10_000,\n                purchaseReferralReward: (paymentAmountWei * PURCHASE_REFERRAL_BPS) / 10_000,\n                deployerReward: (paymentAmountWei * DEPLOYER_REWARD_BPS) / 10_000,\n                revolutionReward: (paymentAmountWei * REVOLUTION_REWARD_BPS) / 10_000\n            }),\n            computeTotalReward(paymentAmountWei)\n        );\n    }\n\n    function _depositPurchaseRewards(\n        uint256 paymentAmountWei,\n        address builderReferral,\n        address purchaseReferral,\n        address deployer\n    ) internal returns (uint256) {\n        (RewardsSettings memory settings, uint256 totalReward) = computePurchaseRewards(paymentAmountWei);\n\n        if (builderReferral == address(0)) builderReferral = revolutionRewardRecipient;\n\n        if (deployer == address(0)) deployer = revolutionRewardRecipient;\n\n        if (purchaseReferral == address(0)) purchaseReferral = revolutionRewardRecipient;\n\n        protocolRewards.depositRewards{ value: totalReward }(\n            builderReferral,\n            settings.builderReferralReward,\n            purchaseReferral,\n            settings.purchaseReferralReward,\n            deployer,\n            settings.deployerReward,\n            revolutionRewardRecipient,\n            settings.revolutionReward\n        );\n\n        return totalReward;\n    }\n}"
    }
  ]
}