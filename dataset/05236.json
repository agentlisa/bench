{
  "Title": "[M-01] The user who withdraws liquidity from a particular pool is able to claim more rewards than they should by carefully selecting a `decreaseShareAmount` value such that the `virtualRewardsToRemove` is rounded down to zero",
  "Content": "\n<https://github.com/code-423n4/2024-01-salty/blob/main/src/staking/StakingRewards.sol#L113-L118> \n\n<https://github.com/code-423n4/2024-01-salty/blob/main/src/staking/StakingRewards.sol#L132-L133> \n\n<https://github.com/code-423n4/2024-01-salty/blob/main/src/staking/StakingRewards.sol#L99>\n\nThe `StakingRewards._decreaseUserShare` function is used to decrease a user's share for the pool and have any pending rewards sent to them. When the amount of pending rewards are calculated, initially the `virtualRewardsToRemove` are calculated as follows:\n\n    \tuint256 virtualRewardsToRemove = (user.virtualRewards * decreaseShareAmount) / user.userShare;\n\nThen the `virtualRewardsToRemove` is substracted from the `rewardsForAmount` value to calculate the `claimableRewards` amount as shown below:\n\n    \tif ( virtualRewardsToRemove < rewardsForAmount )\n    \t\tclaimableRewards = rewardsForAmount - virtualRewardsToRemove; \n\nBut the issue here is that the `virtualRewardsToRemove` calculation is rounded down in favor of the user and not in the favor of the protocol. Since the `virtualRewardsToRemove` is rounded down there is an opportunity to the user to call the `StakingRewards._decreaseUserShare` function with a very small `decreaseShareAmount` value such that the `virtualRewardsToRemove` will be rounded down to `0`. Providing a very small `decreaseShareAmount` value is possible since only input validation on `decreaseShareAmount` is `! = 0` as shown below:\n\n    \trequire( decreaseShareAmount != 0, \"Cannot decrease zero share\" );\n\nWhen the `claimableRewards` is calculated it will be equal to the `rewardsForAmount` value since the `virtualRewardsToRemove` will be `0`. This way the user can keep on removing his liquidity from a particular pool by withdrawing small `decreaseShareAmount` at a time such that keeping `virtualRewardsToRemove` at `0` due to rounding down.\n\nFurthermore the `decreaseShareAmount` value should be selected in such a way `rewardsForAmount` is calculated to a considerable amount after round down (not zero) and the `virtualRewardsToRemove` should round down to zero.\n\nHence as a result the `user` can withdraw all the `rewardsForAmount` as the `claimableRewards` even though some of those rewards are `virtual rewards` which should not be claimable as clearly stated by the following `natspec` comment:\n\n    \t// Some of the rewardsForAmount are actually virtualRewards and can't be claimed.\n\nHence as a result the user is able to get an undue advantage and claim more rewards for his liquidity during liquidity withdrawable. This happens because the `user` can bypass the `virtual reward` subtraction by making it round down to `0`. As a result the `virtualReward` amount of the `rewardsForAmount`, which should not be claimable is also claimed by the user unfairly.\n\n### Proof of Concept\n\n```solidity\n\t\t// Determine the share of the rewards for the amountToDecrease (will include previously added virtual rewards)\n\t\tuint256 rewardsForAmount = ( totalRewards[poolID] * decreaseShareAmount ) / totalShares[poolID];\n\n\t\t// For the amountToDecrease determine the proportion of virtualRewards (proportional to all virtualRewards for the user)\n\t\t// Round virtualRewards down in favor of the protocol\n\t\tuint256 virtualRewardsToRemove = (user.virtualRewards * decreaseShareAmount) / user.userShare;\n```\n\n<https://github.com/code-423n4/2024-01-salty/blob/main/src/staking/StakingRewards.sol#L113-L118>\n\n```solidity\n\t\tif ( virtualRewardsToRemove < rewardsForAmount )\n\t\t\tclaimableRewards = rewardsForAmount - virtualRewardsToRemove;\n```\n\n<https://github.com/code-423n4/2024-01-salty/blob/main/src/staking/StakingRewards.sol#L132-L133>\n\n```solidity\n\t\trequire( decreaseShareAmount != 0, \"Cannot decrease zero share\" );\n```\n\n<https://github.com/code-423n4/2024-01-salty/blob/main/src/staking/StakingRewards.sol#L99>\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\nHence it is recommended to round up the `virtualRewardsToRemove` value during its calculation such that it will not be rounded down to zero for a very small `decreaseShareAmount`. This way `user` is unable to claim the rewards which he is not eligible for and the rewards will be claimed after accounting for the `virtual rewards`.\n\n**[othernet-global (Salty.IO) confirmed and commented](https://github.com/code-423n4/2024-01-salty-findings/issues/1021#issuecomment-1953449327):**\n > virtualRewards now rounded up on _decreaseUserShare\n> \n> https://github.com/othernet-global/salty-io/commit/b3b8cb955db2b9f0e47a4964e1e4f833a447a72d\n\n**Status:** Mitigated with an Error. Full details in report from [t0x1c](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/25), and also included in the [Mitigation Review](#mitigation-review) section below.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-01-salty",
  "Code": [
    {
      "filename": "src/staking/StakingRewards.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport \"openzeppelin-contracts/contracts/utils/math/Math.sol\";\nimport \"../pools/interfaces/IPoolsConfig.sol\";\nimport \"../interfaces/IExchangeConfig.sol\";\nimport \"./interfaces/IStakingRewards.sol\";\nimport \"./interfaces/IStakingConfig.sol\";\nimport \"../interfaces/ISalt.sol\";\n\n// This contract allows users to receive rewards (as SALT tokens) for staking SALT or liquidity shares.\n// A user's reward is proportional to their share of the stake and is based on their share at the time that rewards are added.\n//\n// What staked shares represent is specific to the contracts that derive from StakingRewards.\n//\n// 1. Staking.sol: shares represent the amount of SALT staked (staked to the STAKED_SALT pool)\n// 2. Liquidity.sol: shares represent the amount of liquidity deposited and staked to specific pools\n\nabstract contract StakingRewards is IStakingRewards, ReentrancyGuard\n    {\n\tevent UserShareIncreased(address indexed wallet, bytes32 indexed poolID, uint256 amountIncreased);\n\tevent UserShareDecreased(address indexed wallet, bytes32 indexed poolID, uint256 amountDecreased, uint256 claimedRewards);\n\tevent RewardsClaimed(address indexed wallet, uint256 claimedRewards);\n\tevent SaltRewardsAdded(bytes32 indexed poolID, uint256 amountAdded);\n\n\tusing SafeERC20 for ISalt;\n\n\tISalt immutable public salt;\n\tIExchangeConfig immutable public exchangeConfig;\n    IStakingConfig immutable public stakingConfig;\n    IPoolsConfig immutable public poolsConfig;\n\n\t// A nested mapping that stores the UserShareInfo data for each user and each poolID.\n\tmapping(address=>mapping(bytes32=>UserShareInfo)) private _userShareInfo;\n\n    // A mapping that stores the total pending SALT rewards for each poolID.\n    mapping(bytes32=>uint256) public totalRewards;\n\n    // A mapping that stores the total shares for each poolID.\n    mapping(bytes32=>uint256) public totalShares;\n\n\n\t// Constructs a new StakingRewards contract with providing configs\n \tconstructor( IExchangeConfig _exchangeConfig, IPoolsConfig _poolsConfig, IStakingConfig _stakingConfig )\n\t\t{\n\t\texchangeConfig = _exchangeConfig;\n    \tpoolsConfig = _poolsConfig;\n\t\tstakingConfig = _stakingConfig;\n\n\t\tsalt = _exchangeConfig.salt(); // cached for efficiency\n        }\n\n\n\t// Increase a user's share for the given whitelisted pool.\n\tfunction _increaseUserShare( address wallet, bytes32 poolID, uint256 increaseShareAmount, bool useCooldown ) internal\n\t\t{\n\t\trequire( poolsConfig.isWhitelisted( poolID ), \"Invalid pool\" );\n\t\trequire( increaseShareAmount != 0, \"Cannot increase zero share\" );\n\n\t\tUserShareInfo storage user = _userShareInfo[wallet][poolID];\n\n\t\tif ( useCooldown )\n\t\tif ( msg.sender != address(exchangeConfig.dao()) ) // DAO doesn't use the cooldown\n\t\t\t{\n\t\t\trequire( block.timestamp >= user.cooldownExpiration, \"Must wait for the cooldown to expire\" );\n\n\t\t\t// Update the cooldown expiration for future transactions\n\t\t\tuser.cooldownExpiration = block.timestamp + stakingConfig.modificationCooldown();\n\t\t\t}\n\n\t\tuint256 existingTotalShares = totalShares[poolID];\n\n\t\t// Determine the amount of virtualRewards to add based on the current ratio of rewards/shares.\n\t\t// The ratio of virtualRewards/increaseShareAmount is the same as totalRewards/totalShares for the pool.\n\t\t// The virtual rewards will be deducted later when calculating the user's owed rewards.\n        if ( existingTotalShares != 0 ) // prevent / 0\n        \t{\n\t\t\t// Round up in favor of the protocol.\n\t\t\tuint256 virtualRewardsToAdd = Math.ceilDiv( totalRewards[poolID] * increaseShareAmount, existingTotalShares );\n\n\t\t\tuser.virtualRewards += uint128(virtualRewardsToAdd);\n\t        totalRewards[poolID] += uint128(virtualRewardsToAdd);\n\t        }\n\n\t\t// Update the deposit balances\n\t\tuser.userShare += uint128(increaseShareAmount);\n\t\ttotalShares[poolID] = existingTotalShares + increaseShareAmount;\n\n\t\temit UserShareIncreased(wallet, poolID, increaseShareAmount);\n\t\t}\n\n\n\t// Decrease a user's share for the pool and have any pending rewards sent to them.\n\t// Does not require the pool to be valid (in case the pool was recently unwhitelisted).\n\tfunction _decreaseUserShare( address wallet, bytes32 poolID, uint256 decreaseShareAmount, bool useCooldown ) internal\n\t\t{\n\t\trequire( decreaseShareAmount != 0, \"Cannot decrease zero share\" );\n\n\t\tUserShareInfo storage user = _userShareInfo[wallet][poolID];\n\t\trequire( decreaseShareAmount <= user.userShare, \"Cannot decrease more than existing user share\" );\n\n\t\tif ( useCooldown )\n\t\tif ( msg.sender != address(exchangeConfig.dao()) ) // DAO doesn't use the cooldown\n\t\t\t{\n\t\t\trequire( block.timestamp >= user.cooldownExpiration, \"Must wait for the cooldown to expire\" );\n\n\t\t\t// Update the cooldown expiration for future transactions\n\t\t\tuser.cooldownExpiration = block.timestamp + stakingConfig.modificationCooldown();\n\t\t\t}\n\n\t\t// Determine the share of the rewards for the amountToDecrease (will include previously added virtual rewards)\n\t\tuint256 rewardsForAmount = ( totalRewards[poolID] * decreaseShareAmount ) / totalShares[poolID];\n\n\t\t// For the amountToDecrease determine the proportion of virtualRewards (proportional to all virtualRewards for the user)\n\t\t// Round virtualRewards down in favor of the protocol\n\t\tuint256 virtualRewardsToRemove = (user.virtualRewards * decreaseShareAmount) / user.userShare;\n\n\t\t// Update totals\n\t\ttotalRewards[poolID] -= rewardsForAmount;\n\t\ttotalShares[poolID] -= decreaseShareAmount;\n\n\t\t// Update the user's share and virtual rewards\n\t\tuser.userShare -= uint128(decreaseShareAmount);\n\t\tuser.virtualRewards -= uint128(virtualRewardsToRemove);\n\n\t\tuint256 claimableRewards = 0;\n\n\t\t// Some of the rewardsForAmount are actually virtualRewards and can't be claimed.\n\t\t// In the event that virtualRewards are greater than actual rewards - claimableRewards will stay zero.\n\t\tif ( virtualRewardsToRemove < rewardsForAmount )\n\t\t\tclaimableRewards = rewardsForAmount - virtualRewardsToRemove;\n\n\t\t// Send the claimable rewards\n\t\tif ( claimableRewards != 0 )\n\t\t\tsalt.safeTransfer( wallet, claimableRewards );\n\n\t\temit UserShareDecreased(wallet, poolID, decreaseShareAmount, claimableRewards);\n\t\t}\n\n\n\t// ===== PUBLIC FUNCTIONS =====\n\n\t// Claim all available SALT rewards from multiple pools for the user.\n\t// The claimed rewards are added to the user's virtual rewards balance - so that they can't be claimed again later.\n     function claimAllRewards( bytes32[] calldata poolIDs ) external nonReentrant returns (uint256 claimableRewards)\n    \t{\n\t\tmapping(bytes32=>UserShareInfo) storage userInfo = _userShareInfo[msg.sender];\n\n\t\tclaimableRewards = 0;\n\t\tfor( uint256 i = 0; i < poolIDs.length; i++ )\n\t\t\t{\n\t\t\tbytes32 poolID = poolIDs[i];\n\n\t\t\tuint256 pendingRewards = userRewardForPool( msg.sender, poolID );\n\n\t\t\t// Increase the virtualRewards balance for the user to account for them receiving the rewards without withdrawing\n\t\t\tuserInfo[poolID].virtualRewards += uint128(pendingRewards);\n\n\t\t\tclaimableRewards += pendingRewards;\n\t\t\t}\n\n\t\tif ( claimableRewards > 0 )\n\t\t\t{\n\t\t\t// Send the actual rewards\n\t\t\tsalt.safeTransfer( msg.sender, claimableRewards );\n\n\t\t\temit RewardsClaimed(msg.sender, claimableRewards);\n\t\t\t}\n    \t}\n\n\n\t// Adds SALT rewards for specific whitelisted pools.\n\t// There is some risk of addSALTRewards being frontrun to hunt rewards, but there are multiple mechanisms in place to prevent this from being effective.\n\t// 1. There is a cooldown period of default one hour before shares can be withdrawn once deposited.\n\t// 2. Staked SALT has a default unstake period of 52 weeks.\n\t// 3. Rewards are first placed into a RewardsEmitter which deposits rewards via addSALTRewards at the default rate of 1% per day.\n\t// 4. Rewards are deposited fairly often, with outstanding rewards being transferred with a frequency proportional to the activity of the exchange.\n\t// Example: if $100k rewards were being deposited in a bulk transaction, it would only equate to $1000 (1%) the first day,\n\t// or $10 in claimable rewards during a 15 minute upkeep period.\n \tfunction addSALTRewards( AddedReward[] calldata addedRewards ) external nonReentrant\n\t\t{\n\t\tuint256 sum = 0;\n\t\tfor( uint256 i = 0; i < addedRewards.length; i++ )\n\t\t\t{\n\t\t\tAddedReward memory addedReward = addedRewards[i];\n\n\t\t\tbytes32 poolID = addedReward.poolID;\n\t\t\trequire( poolsConfig.isWhitelisted( poolID ), \"Invalid pool\" );\n\n\t\t\tuint256 amountToAdd = addedReward.amountToAdd;\n\n\t\t\ttotalRewards[ poolID ] += amountToAdd;\n\t\t\tsum = sum + amountToAdd;\n\n\t\t\temit SaltRewardsAdded(poolID, amountToAdd);\n\t\t\t}\n\n\t\t// Transfer in the SALT for all the specified rewards\n\t\tif ( sum > 0 )\n\t\t\t{\n\t\t\t// Transfer the SALT rewards from the sender\n\t\t\tsalt.safeTransferFrom( msg.sender, address(this), sum );\n\t\t\t}\n\t\t}\n\n\n\t// === VIEWS ===\n\n\t// Returns the total shares for specified pools.\n\tfunction totalSharesForPools( bytes32[] calldata poolIDs ) external view returns (uint256[] memory shares)\n\t\t{\n\t\tshares = new uint256[]( poolIDs.length );\n\n\t\tfor( uint256 i = 0; i < shares.length; i++ )\n\t\t\tshares[i] = totalShares[ poolIDs[i] ];\n\t\t}\n\n\n\t// Returns the total rewards for specified pools.\n\tfunction totalRewardsForPools( bytes32[] calldata poolIDs ) external view returns (uint256[] memory rewards)\n\t\t{\n\t\trewards = new uint256[]( poolIDs.length );\n\n\t\tfor( uint256 i = 0; i < rewards.length; i++ )\n\t\t\trewards[i] = totalRewards[ poolIDs[i] ];\n\t\t}\n\n\n\t// Returns the user's pending rewards for a specified pool.\n\tfunction userRewardForPool( address wallet, bytes32 poolID ) public view returns (uint256)\n\t\t{\n\t\t// If there are no shares for the pool, the user can't have any shares either and there can't be any rewards\n\t\tif ( totalShares[poolID] == 0 )\n\t\t\treturn 0;\n\n\t\tUserShareInfo memory user = _userShareInfo[wallet][poolID];\n\t\tif ( user.userShare == 0 )\n\t\t\treturn 0;\n\n\t\t// Determine the share of the rewards for the user based on their deposited share\n\t\tuint256 rewardsShare = ( totalRewards[poolID] * user.userShare ) / totalShares[poolID];\n\n\t\t// Reduce by the virtualRewards - as they were only added to keep the share / rewards ratio the same when the used added their share\n\n\t\t// In the event that virtualRewards exceeds rewardsShare due to precision loss - just return zero\n\t\tif ( user.virtualRewards > rewardsShare )\n\t\t\treturn 0;\n\n\t\treturn rewardsShare - user.virtualRewards;\n\t\t}\n\n\n\t// Returns the user's pending rewards for specified pools.\n\tfunction userRewardsForPools( address wallet, bytes32[] calldata poolIDs ) external view returns (uint256[] memory rewards)\n\t\t{\n\t\trewards = new uint256[]( poolIDs.length );\n\n\t\tfor( uint256 i = 0; i < rewards.length; i++ )\n\t\t\trewards[i] = userRewardForPool( wallet, poolIDs[i] );\n\t\t}\n\n\n\t// Get the user's shares for a specified pool.\n\tfunction userShareForPool( address wallet, bytes32 poolID ) public view returns (uint256)\n\t\t{\n\t\treturn _userShareInfo[wallet][poolID].userShare;\n\t\t}\n\n\n\t// Get the user's shares for specified pools.\n\tfunction userShareForPools( address wallet, bytes32[] calldata poolIDs ) external view returns (uint256[] memory shares)\n\t\t{\n\t\tshares = new uint256[]( poolIDs.length );\n\n\t\tfor( uint256 i = 0; i < shares.length; i++ )\n\t\t\tshares[i] = _userShareInfo[wallet][ poolIDs[i] ].userShare;\n\t\t}\n\n\n\t// Get the user's virtual rewards for a specified pool.\n\tfunction userVirtualRewardsForPool( address wallet, bytes32 poolID ) public view returns (uint256)\n\t\t{\n\t\treturn _userShareInfo[wallet][poolID].virtualRewards;\n\t\t}\n\n\n\t// Get the cooldown time remaining for the user for specified pools.\n\tfunction userCooldowns( address wallet, bytes32[] calldata poolIDs ) external view returns (uint256[] memory cooldowns)\n\t\t{\n\t\tcooldowns = new uint256[]( poolIDs.length );\n\n\t\tmapping(bytes32=>UserShareInfo) storage userInfo = _userShareInfo[wallet];\n\n\t\tfor( uint256 i = 0; i < cooldowns.length; i++ )\n\t\t\t{\n\t\t\tuint256 cooldownExpiration = userInfo[ poolIDs[i] ].cooldownExpiration;\n\n\t\t\tif ( block.timestamp >= cooldownExpiration )\n\t\t\t\tcooldowns[i] = 0;\n\t\t\telse\n\t\t\t\tcooldowns[i] = cooldownExpiration - block.timestamp;\n\t\t\t}\n\t\t}\n\t}"
    },
    {
      "filename": "src/staking/StakingRewards.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport \"openzeppelin-contracts/contracts/utils/math/Math.sol\";\nimport \"../pools/interfaces/IPoolsConfig.sol\";\nimport \"../interfaces/IExchangeConfig.sol\";\nimport \"./interfaces/IStakingRewards.sol\";\nimport \"./interfaces/IStakingConfig.sol\";\nimport \"../interfaces/ISalt.sol\";\n\n// This contract allows users to receive rewards (as SALT tokens) for staking SALT or liquidity shares.\n// A user's reward is proportional to their share of the stake and is based on their share at the time that rewards are added.\n//\n// What staked shares represent is specific to the contracts that derive from StakingRewards.\n//\n// 1. Staking.sol: shares represent the amount of SALT staked (staked to the STAKED_SALT pool)\n// 2. Liquidity.sol: shares represent the amount of liquidity deposited and staked to specific pools\n\nabstract contract StakingRewards is IStakingRewards, ReentrancyGuard\n    {\n\tevent UserShareIncreased(address indexed wallet, bytes32 indexed poolID, uint256 amountIncreased);\n\tevent UserShareDecreased(address indexed wallet, bytes32 indexed poolID, uint256 amountDecreased, uint256 claimedRewards);\n\tevent RewardsClaimed(address indexed wallet, uint256 claimedRewards);\n\tevent SaltRewardsAdded(bytes32 indexed poolID, uint256 amountAdded);\n\n\tusing SafeERC20 for ISalt;\n\n\tISalt immutable public salt;\n\tIExchangeConfig immutable public exchangeConfig;\n    IStakingConfig immutable public stakingConfig;\n    IPoolsConfig immutable public poolsConfig;\n\n\t// A nested mapping that stores the UserShareInfo data for each user and each poolID.\n\tmapping(address=>mapping(bytes32=>UserShareInfo)) private _userShareInfo;\n\n    // A mapping that stores the total pending SALT rewards for each poolID.\n    mapping(bytes32=>uint256) public totalRewards;\n\n    // A mapping that stores the total shares for each poolID.\n    mapping(bytes32=>uint256) public totalShares;\n\n\n\t// Constructs a new StakingRewards contract with providing configs\n \tconstructor( IExchangeConfig _exchangeConfig, IPoolsConfig _poolsConfig, IStakingConfig _stakingConfig )\n\t\t{\n\t\texchangeConfig = _exchangeConfig;\n    \tpoolsConfig = _poolsConfig;\n\t\tstakingConfig = _stakingConfig;\n\n\t\tsalt = _exchangeConfig.salt(); // cached for efficiency\n        }\n\n\n\t// Increase a user's share for the given whitelisted pool.\n\tfunction _increaseUserShare( address wallet, bytes32 poolID, uint256 increaseShareAmount, bool useCooldown ) internal\n\t\t{\n\t\trequire( poolsConfig.isWhitelisted( poolID ), \"Invalid pool\" );\n\t\trequire( increaseShareAmount != 0, \"Cannot increase zero share\" );\n\n\t\tUserShareInfo storage user = _userShareInfo[wallet][poolID];\n\n\t\tif ( useCooldown )\n\t\tif ( msg.sender != address(exchangeConfig.dao()) ) // DAO doesn't use the cooldown\n\t\t\t{\n\t\t\trequire( block.timestamp >= user.cooldownExpiration, \"Must wait for the cooldown to expire\" );\n\n\t\t\t// Update the cooldown expiration for future transactions\n\t\t\tuser.cooldownExpiration = block.timestamp + stakingConfig.modificationCooldown();\n\t\t\t}\n\n\t\tuint256 existingTotalShares = totalShares[poolID];\n\n\t\t// Determine the amount of virtualRewards to add based on the current ratio of rewards/shares.\n\t\t// The ratio of virtualRewards/increaseShareAmount is the same as totalRewards/totalShares for the pool.\n\t\t// The virtual rewards will be deducted later when calculating the user's owed rewards.\n        if ( existingTotalShares != 0 ) // prevent / 0\n        \t{\n\t\t\t// Round up in favor of the protocol.\n\t\t\tuint256 virtualRewardsToAdd = Math.ceilDiv( totalRewards[poolID] * increaseShareAmount, existingTotalShares );\n\n\t\t\tuser.virtualRewards += uint128(virtualRewardsToAdd);\n\t        totalRewards[poolID] += uint128(virtualRewardsToAdd);\n\t        }\n\n\t\t// Update the deposit balances\n\t\tuser.userShare += uint128(increaseShareAmount);\n\t\ttotalShares[poolID] = existingTotalShares + increaseShareAmount;\n\n\t\temit UserShareIncreased(wallet, poolID, increaseShareAmount);\n\t\t}\n\n\n\t// Decrease a user's share for the pool and have any pending rewards sent to them.\n\t// Does not require the pool to be valid (in case the pool was recently unwhitelisted).\n\tfunction _decreaseUserShare( address wallet, bytes32 poolID, uint256 decreaseShareAmount, bool useCooldown ) internal\n\t\t{\n\t\trequire( decreaseShareAmount != 0, \"Cannot decrease zero share\" );\n\n\t\tUserShareInfo storage user = _userShareInfo[wallet][poolID];\n\t\trequire( decreaseShareAmount <= user.userShare, \"Cannot decrease more than existing user share\" );\n\n\t\tif ( useCooldown )\n\t\tif ( msg.sender != address(exchangeConfig.dao()) ) // DAO doesn't use the cooldown\n\t\t\t{\n\t\t\trequire( block.timestamp >= user.cooldownExpiration, \"Must wait for the cooldown to expire\" );\n\n\t\t\t// Update the cooldown expiration for future transactions\n\t\t\tuser.cooldownExpiration = block.timestamp + stakingConfig.modificationCooldown();\n\t\t\t}\n\n\t\t// Determine the share of the rewards for the amountToDecrease (will include previously added virtual rewards)\n\t\tuint256 rewardsForAmount = ( totalRewards[poolID] * decreaseShareAmount ) / totalShares[poolID];\n\n\t\t// For the amountToDecrease determine the proportion of virtualRewards (proportional to all virtualRewards for the user)\n\t\t// Round virtualRewards down in favor of the protocol\n\t\tuint256 virtualRewardsToRemove = (user.virtualRewards * decreaseShareAmount) / user.userShare;\n\n\t\t// Update totals\n\t\ttotalRewards[poolID] -= rewardsForAmount;\n\t\ttotalShares[poolID] -= decreaseShareAmount;\n\n\t\t// Update the user's share and virtual rewards\n\t\tuser.userShare -= uint128(decreaseShareAmount);\n\t\tuser.virtualRewards -= uint128(virtualRewardsToRemove);\n\n\t\tuint256 claimableRewards = 0;\n\n\t\t// Some of the rewardsForAmount are actually virtualRewards and can't be claimed.\n\t\t// In the event that virtualRewards are greater than actual rewards - claimableRewards will stay zero.\n\t\tif ( virtualRewardsToRemove < rewardsForAmount )\n\t\t\tclaimableRewards = rewardsForAmount - virtualRewardsToRemove;\n\n\t\t// Send the claimable rewards\n\t\tif ( claimableRewards != 0 )\n\t\t\tsalt.safeTransfer( wallet, claimableRewards );\n\n\t\temit UserShareDecreased(wallet, poolID, decreaseShareAmount, claimableRewards);\n\t\t}\n\n\n\t// ===== PUBLIC FUNCTIONS =====\n\n\t// Claim all available SALT rewards from multiple pools for the user.\n\t// The claimed rewards are added to the user's virtual rewards balance - so that they can't be claimed again later.\n     function claimAllRewards( bytes32[] calldata poolIDs ) external nonReentrant returns (uint256 claimableRewards)\n    \t{\n\t\tmapping(bytes32=>UserShareInfo) storage userInfo = _userShareInfo[msg.sender];\n\n\t\tclaimableRewards = 0;\n\t\tfor( uint256 i = 0; i < poolIDs.length; i++ )\n\t\t\t{\n\t\t\tbytes32 poolID = poolIDs[i];\n\n\t\t\tuint256 pendingRewards = userRewardForPool( msg.sender, poolID );\n\n\t\t\t// Increase the virtualRewards balance for the user to account for them receiving the rewards without withdrawing\n\t\t\tuserInfo[poolID].virtualRewards += uint128(pendingRewards);\n\n\t\t\tclaimableRewards += pendingRewards;\n\t\t\t}\n\n\t\tif ( claimableRewards > 0 )\n\t\t\t{\n\t\t\t// Send the actual rewards\n\t\t\tsalt.safeTransfer( msg.sender, claimableRewards );\n\n\t\t\temit RewardsClaimed(msg.sender, claimableRewards);\n\t\t\t}\n    \t}\n\n\n\t// Adds SALT rewards for specific whitelisted pools.\n\t// There is some risk of addSALTRewards being frontrun to hunt rewards, but there are multiple mechanisms in place to prevent this from being effective.\n\t// 1. There is a cooldown period of default one hour before shares can be withdrawn once deposited.\n\t// 2. Staked SALT has a default unstake period of 52 weeks.\n\t// 3. Rewards are first placed into a RewardsEmitter which deposits rewards via addSALTRewards at the default rate of 1% per day.\n\t// 4. Rewards are deposited fairly often, with outstanding rewards being transferred with a frequency proportional to the activity of the exchange.\n\t// Example: if $100k rewards were being deposited in a bulk transaction, it would only equate to $1000 (1%) the first day,\n\t// or $10 in claimable rewards during a 15 minute upkeep period.\n \tfunction addSALTRewards( AddedReward[] calldata addedRewards ) external nonReentrant\n\t\t{\n\t\tuint256 sum = 0;\n\t\tfor( uint256 i = 0; i < addedRewards.length; i++ )\n\t\t\t{\n\t\t\tAddedReward memory addedReward = addedRewards[i];\n\n\t\t\tbytes32 poolID = addedReward.poolID;\n\t\t\trequire( poolsConfig.isWhitelisted( poolID ), \"Invalid pool\" );\n\n\t\t\tuint256 amountToAdd = addedReward.amountToAdd;\n\n\t\t\ttotalRewards[ poolID ] += amountToAdd;\n\t\t\tsum = sum + amountToAdd;\n\n\t\t\temit SaltRewardsAdded(poolID, amountToAdd);\n\t\t\t}\n\n\t\t// Transfer in the SALT for all the specified rewards\n\t\tif ( sum > 0 )\n\t\t\t{\n\t\t\t// Transfer the SALT rewards from the sender\n\t\t\tsalt.safeTransferFrom( msg.sender, address(this), sum );\n\t\t\t}\n\t\t}\n\n\n\t// === VIEWS ===\n\n\t// Returns the total shares for specified pools.\n\tfunction totalSharesForPools( bytes32[] calldata poolIDs ) external view returns (uint256[] memory shares)\n\t\t{\n\t\tshares = new uint256[]( poolIDs.length );\n\n\t\tfor( uint256 i = 0; i < shares.length; i++ )\n\t\t\tshares[i] = totalShares[ poolIDs[i] ];\n\t\t}\n\n\n\t// Returns the total rewards for specified pools.\n\tfunction totalRewardsForPools( bytes32[] calldata poolIDs ) external view returns (uint256[] memory rewards)\n\t\t{\n\t\trewards = new uint256[]( poolIDs.length );\n\n\t\tfor( uint256 i = 0; i < rewards.length; i++ )\n\t\t\trewards[i] = totalRewards[ poolIDs[i] ];\n\t\t}\n\n\n\t// Returns the user's pending rewards for a specified pool.\n\tfunction userRewardForPool( address wallet, bytes32 poolID ) public view returns (uint256)\n\t\t{\n\t\t// If there are no shares for the pool, the user can't have any shares either and there can't be any rewards\n\t\tif ( totalShares[poolID] == 0 )\n\t\t\treturn 0;\n\n\t\tUserShareInfo memory user = _userShareInfo[wallet][poolID];\n\t\tif ( user.userShare == 0 )\n\t\t\treturn 0;\n\n\t\t// Determine the share of the rewards for the user based on their deposited share\n\t\tuint256 rewardsShare = ( totalRewards[poolID] * user.userShare ) / totalShares[poolID];\n\n\t\t// Reduce by the virtualRewards - as they were only added to keep the share / rewards ratio the same when the used added their share\n\n\t\t// In the event that virtualRewards exceeds rewardsShare due to precision loss - just return zero\n\t\tif ( user.virtualRewards > rewardsShare )\n\t\t\treturn 0;\n\n\t\treturn rewardsShare - user.virtualRewards;\n\t\t}\n\n\n\t// Returns the user's pending rewards for specified pools.\n\tfunction userRewardsForPools( address wallet, bytes32[] calldata poolIDs ) external view returns (uint256[] memory rewards)\n\t\t{\n\t\trewards = new uint256[]( poolIDs.length );\n\n\t\tfor( uint256 i = 0; i < rewards.length; i++ )\n\t\t\trewards[i] = userRewardForPool( wallet, poolIDs[i] );\n\t\t}\n\n\n\t// Get the user's shares for a specified pool.\n\tfunction userShareForPool( address wallet, bytes32 poolID ) public view returns (uint256)\n\t\t{\n\t\treturn _userShareInfo[wallet][poolID].userShare;\n\t\t}\n\n\n\t// Get the user's shares for specified pools.\n\tfunction userShareForPools( address wallet, bytes32[] calldata poolIDs ) external view returns (uint256[] memory shares)\n\t\t{\n\t\tshares = new uint256[]( poolIDs.length );\n\n\t\tfor( uint256 i = 0; i < shares.length; i++ )\n\t\t\tshares[i] = _userShareInfo[wallet][ poolIDs[i] ].userShare;\n\t\t}\n\n\n\t// Get the user's virtual rewards for a specified pool.\n\tfunction userVirtualRewardsForPool( address wallet, bytes32 poolID ) public view returns (uint256)\n\t\t{\n\t\treturn _userShareInfo[wallet][poolID].virtualRewards;\n\t\t}\n\n\n\t// Get the cooldown time remaining for the user for specified pools.\n\tfunction userCooldowns( address wallet, bytes32[] calldata poolIDs ) external view returns (uint256[] memory cooldowns)\n\t\t{\n\t\tcooldowns = new uint256[]( poolIDs.length );\n\n\t\tmapping(bytes32=>UserShareInfo) storage userInfo = _userShareInfo[wallet];\n\n\t\tfor( uint256 i = 0; i < cooldowns.length; i++ )\n\t\t\t{\n\t\t\tuint256 cooldownExpiration = userInfo[ poolIDs[i] ].cooldownExpiration;\n\n\t\t\tif ( block.timestamp >= cooldownExpiration )\n\t\t\t\tcooldowns[i] = 0;\n\t\t\telse\n\t\t\t\tcooldowns[i] = cooldownExpiration - block.timestamp;\n\t\t\t}\n\t\t}\n\t}"
    },
    {
      "filename": "src/staking/StakingRewards.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport \"openzeppelin-contracts/contracts/utils/math/Math.sol\";\nimport \"../pools/interfaces/IPoolsConfig.sol\";\nimport \"../interfaces/IExchangeConfig.sol\";\nimport \"./interfaces/IStakingRewards.sol\";\nimport \"./interfaces/IStakingConfig.sol\";\nimport \"../interfaces/ISalt.sol\";\n\n// This contract allows users to receive rewards (as SALT tokens) for staking SALT or liquidity shares.\n// A user's reward is proportional to their share of the stake and is based on their share at the time that rewards are added.\n//\n// What staked shares represent is specific to the contracts that derive from StakingRewards.\n//\n// 1. Staking.sol: shares represent the amount of SALT staked (staked to the STAKED_SALT pool)\n// 2. Liquidity.sol: shares represent the amount of liquidity deposited and staked to specific pools\n\nabstract contract StakingRewards is IStakingRewards, ReentrancyGuard\n    {\n\tevent UserShareIncreased(address indexed wallet, bytes32 indexed poolID, uint256 amountIncreased);\n\tevent UserShareDecreased(address indexed wallet, bytes32 indexed poolID, uint256 amountDecreased, uint256 claimedRewards);\n\tevent RewardsClaimed(address indexed wallet, uint256 claimedRewards);\n\tevent SaltRewardsAdded(bytes32 indexed poolID, uint256 amountAdded);\n\n\tusing SafeERC20 for ISalt;\n\n\tISalt immutable public salt;\n\tIExchangeConfig immutable public exchangeConfig;\n    IStakingConfig immutable public stakingConfig;\n    IPoolsConfig immutable public poolsConfig;\n\n\t// A nested mapping that stores the UserShareInfo data for each user and each poolID.\n\tmapping(address=>mapping(bytes32=>UserShareInfo)) private _userShareInfo;\n\n    // A mapping that stores the total pending SALT rewards for each poolID.\n    mapping(bytes32=>uint256) public totalRewards;\n\n    // A mapping that stores the total shares for each poolID.\n    mapping(bytes32=>uint256) public totalShares;\n\n\n\t// Constructs a new StakingRewards contract with providing configs\n \tconstructor( IExchangeConfig _exchangeConfig, IPoolsConfig _poolsConfig, IStakingConfig _stakingConfig )\n\t\t{\n\t\texchangeConfig = _exchangeConfig;\n    \tpoolsConfig = _poolsConfig;\n\t\tstakingConfig = _stakingConfig;\n\n\t\tsalt = _exchangeConfig.salt(); // cached for efficiency\n        }\n\n\n\t// Increase a user's share for the given whitelisted pool.\n\tfunction _increaseUserShare( address wallet, bytes32 poolID, uint256 increaseShareAmount, bool useCooldown ) internal\n\t\t{\n\t\trequire( poolsConfig.isWhitelisted( poolID ), \"Invalid pool\" );\n\t\trequire( increaseShareAmount != 0, \"Cannot increase zero share\" );\n\n\t\tUserShareInfo storage user = _userShareInfo[wallet][poolID];\n\n\t\tif ( useCooldown )\n\t\tif ( msg.sender != address(exchangeConfig.dao()) ) // DAO doesn't use the cooldown\n\t\t\t{\n\t\t\trequire( block.timestamp >= user.cooldownExpiration, \"Must wait for the cooldown to expire\" );\n\n\t\t\t// Update the cooldown expiration for future transactions\n\t\t\tuser.cooldownExpiration = block.timestamp + stakingConfig.modificationCooldown();\n\t\t\t}\n\n\t\tuint256 existingTotalShares = totalShares[poolID];\n\n\t\t// Determine the amount of virtualRewards to add based on the current ratio of rewards/shares.\n\t\t// The ratio of virtualRewards/increaseShareAmount is the same as totalRewards/totalShares for the pool.\n\t\t// The virtual rewards will be deducted later when calculating the user's owed rewards.\n        if ( existingTotalShares != 0 ) // prevent / 0\n        \t{\n\t\t\t// Round up in favor of the protocol.\n\t\t\tuint256 virtualRewardsToAdd = Math.ceilDiv( totalRewards[poolID] * increaseShareAmount, existingTotalShares );\n\n\t\t\tuser.virtualRewards += uint128(virtualRewardsToAdd);\n\t        totalRewards[poolID] += uint128(virtualRewardsToAdd);\n\t        }\n\n\t\t// Update the deposit balances\n\t\tuser.userShare += uint128(increaseShareAmount);\n\t\ttotalShares[poolID] = existingTotalShares + increaseShareAmount;\n\n\t\temit UserShareIncreased(wallet, poolID, increaseShareAmount);\n\t\t}\n\n\n\t// Decrease a user's share for the pool and have any pending rewards sent to them.\n\t// Does not require the pool to be valid (in case the pool was recently unwhitelisted).\n\tfunction _decreaseUserShare( address wallet, bytes32 poolID, uint256 decreaseShareAmount, bool useCooldown ) internal\n\t\t{\n\t\trequire( decreaseShareAmount != 0, \"Cannot decrease zero share\" );\n\n\t\tUserShareInfo storage user = _userShareInfo[wallet][poolID];\n\t\trequire( decreaseShareAmount <= user.userShare, \"Cannot decrease more than existing user share\" );\n\n\t\tif ( useCooldown )\n\t\tif ( msg.sender != address(exchangeConfig.dao()) ) // DAO doesn't use the cooldown\n\t\t\t{\n\t\t\trequire( block.timestamp >= user.cooldownExpiration, \"Must wait for the cooldown to expire\" );\n\n\t\t\t// Update the cooldown expiration for future transactions\n\t\t\tuser.cooldownExpiration = block.timestamp + stakingConfig.modificationCooldown();\n\t\t\t}\n\n\t\t// Determine the share of the rewards for the amountToDecrease (will include previously added virtual rewards)\n\t\tuint256 rewardsForAmount = ( totalRewards[poolID] * decreaseShareAmount ) / totalShares[poolID];\n\n\t\t// For the amountToDecrease determine the proportion of virtualRewards (proportional to all virtualRewards for the user)\n\t\t// Round virtualRewards down in favor of the protocol\n\t\tuint256 virtualRewardsToRemove = (user.virtualRewards * decreaseShareAmount) / user.userShare;\n\n\t\t// Update totals\n\t\ttotalRewards[poolID] -= rewardsForAmount;\n\t\ttotalShares[poolID] -= decreaseShareAmount;\n\n\t\t// Update the user's share and virtual rewards\n\t\tuser.userShare -= uint128(decreaseShareAmount);\n\t\tuser.virtualRewards -= uint128(virtualRewardsToRemove);\n\n\t\tuint256 claimableRewards = 0;\n\n\t\t// Some of the rewardsForAmount are actually virtualRewards and can't be claimed.\n\t\t// In the event that virtualRewards are greater than actual rewards - claimableRewards will stay zero.\n\t\tif ( virtualRewardsToRemove < rewardsForAmount )\n\t\t\tclaimableRewards = rewardsForAmount - virtualRewardsToRemove;\n\n\t\t// Send the claimable rewards\n\t\tif ( claimableRewards != 0 )\n\t\t\tsalt.safeTransfer( wallet, claimableRewards );\n\n\t\temit UserShareDecreased(wallet, poolID, decreaseShareAmount, claimableRewards);\n\t\t}\n\n\n\t// ===== PUBLIC FUNCTIONS =====\n\n\t// Claim all available SALT rewards from multiple pools for the user.\n\t// The claimed rewards are added to the user's virtual rewards balance - so that they can't be claimed again later.\n     function claimAllRewards( bytes32[] calldata poolIDs ) external nonReentrant returns (uint256 claimableRewards)\n    \t{\n\t\tmapping(bytes32=>UserShareInfo) storage userInfo = _userShareInfo[msg.sender];\n\n\t\tclaimableRewards = 0;\n\t\tfor( uint256 i = 0; i < poolIDs.length; i++ )\n\t\t\t{\n\t\t\tbytes32 poolID = poolIDs[i];\n\n\t\t\tuint256 pendingRewards = userRewardForPool( msg.sender, poolID );\n\n\t\t\t// Increase the virtualRewards balance for the user to account for them receiving the rewards without withdrawing\n\t\t\tuserInfo[poolID].virtualRewards += uint128(pendingRewards);\n\n\t\t\tclaimableRewards += pendingRewards;\n\t\t\t}\n\n\t\tif ( claimableRewards > 0 )\n\t\t\t{\n\t\t\t// Send the actual rewards\n\t\t\tsalt.safeTransfer( msg.sender, claimableRewards );\n\n\t\t\temit RewardsClaimed(msg.sender, claimableRewards);\n\t\t\t}\n    \t}\n\n\n\t// Adds SALT rewards for specific whitelisted pools.\n\t// There is some risk of addSALTRewards being frontrun to hunt rewards, but there are multiple mechanisms in place to prevent this from being effective.\n\t// 1. There is a cooldown period of default one hour before shares can be withdrawn once deposited.\n\t// 2. Staked SALT has a default unstake period of 52 weeks.\n\t// 3. Rewards are first placed into a RewardsEmitter which deposits rewards via addSALTRewards at the default rate of 1% per day.\n\t// 4. Rewards are deposited fairly often, with outstanding rewards being transferred with a frequency proportional to the activity of the exchange.\n\t// Example: if $100k rewards were being deposited in a bulk transaction, it would only equate to $1000 (1%) the first day,\n\t// or $10 in claimable rewards during a 15 minute upkeep period.\n \tfunction addSALTRewards( AddedReward[] calldata addedRewards ) external nonReentrant\n\t\t{\n\t\tuint256 sum = 0;\n\t\tfor( uint256 i = 0; i < addedRewards.length; i++ )\n\t\t\t{\n\t\t\tAddedReward memory addedReward = addedRewards[i];\n\n\t\t\tbytes32 poolID = addedReward.poolID;\n\t\t\trequire( p"
    }
  ]
}