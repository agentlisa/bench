{
  "Title": "[M-09] Pending withdrawal batch debt cannot be paid by the borrower until the cycle ends",
  "Content": "\nThe borrower will have to pay the interest and fees until the end of the withdrawal cycle.\n\n### Proof of Concept\n\nTo repay a lender who has requested for withdrawal, the borrower is supposed to transfer the assets to the market and call the `updateState()` function. But the `_getUpdatedState()` function inside the `updateState` doesn't process the withdrawal batch with the latest available assets unless the batch has been expired. \n\n<https://github.com/code-423n4/2023-10-wildcat/blob/c5df665f0bc2ca5df6f06938d66494b11e7bdada/src/market/WildcatMarketBase.sol#L358-L388>\n\n```solidity\n  function _getUpdatedState() internal returns (MarketState memory state) {\n    state = _state;\n    // Handle expired withdrawal batch\n    if (state.hasPendingExpiredBatch()) {\n      uint256 expiry = state.pendingWithdrawalExpiry;\n      // Only accrue interest if time has passed since last update.\n      \n       ...... more code \n\n      _processExpiredWithdrawalBatch(state);\n    }\n\n    // Apply interest and fees accrued since last update (expiry or previous tx)\n    if (block.timestamp != state.lastInterestAccruedTimestamp) {\n      (uint256 baseInterestRay, uint256 delinquencyFeeRay, uint256 protocolFee) = state\n        .updateScaleFactorAndFees(\n          protocolFeeBips,\n          delinquencyFeeBips,\n          delinquencyGracePeriod,\n          block.timestamp\n        );\n      emit ScaleFactorUpdated(state.scaleFactor, baseInterestRay, delinquencyFeeRay, protocolFee);\n    }\n  }\n```\n\nThis will lead to the borrower paying the interest and fees, even though the pending withdrawal debt has been repaid to the market.\n\n### Demo\n\nAdd the following file in the test folder and run `forge test --mt testBorrowerHasToPayInterestTillTheCycleEndEvenAfterReturningAsset`:\n\n<details>\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport { MockERC20 } from 'solmate/test/utils/mocks/MockERC20.sol';\n\nimport './shared/Test.sol';\nimport './helpers/VmUtils.sol';\nimport './helpers/MockController.sol';\nimport './helpers/ExpectedStateTracker.sol';\nimport {MarketStateLib} from \"../src/libraries/MarketState.sol\";\n\ncontract TestPending is Test {\n  using stdStorage for StdStorage;\n  using FeeMath for MarketState;\n  using SafeCastLib for uint256;\n\n  MockERC20 internal asset;\n\n  function setUp() public {\n    setUpContracts(false);\n  }\n\n  function setUpContracts(bool disableControllerChecks) internal {\n    if (address(controller) == address(0)) {\n      deployController(borrower, false, disableControllerChecks);\n    }\n  }\n\n  MarketParameters internal parameters;\n\n  function testBorrowerHasToPayInterestTillTheCycleEndEvenAfterReturningAsset() public {\n    uint32 withdrawalBatchDuration =  DefaultWithdrawalBatchDuration; // 86400\n    uint16  delinquencyFee = DefaultDelinquencyFee;\n    uint32  gracePeriod =  DefaultGracePeriod;\n    \n    parameters =\n    MarketParameters({\n      asset: address(0),\n      namePrefix: 'Wildcat ',\n      symbolPrefix: 'WC',\n      borrower: borrower,\n      controller: address(0),\n      feeRecipient: feeRecipient,\n      sentinel: address(sanctionsSentinel),\n      maxTotalSupply: uint128(DefaultMaximumSupply),\n      protocolFeeBips: DefaultProtocolFeeBips,\n      annualInterestBips: DefaultInterest,\n      delinquencyFeeBips: delinquencyFee,\n      withdrawalBatchDuration: withdrawalBatchDuration,\n      reserveRatioBips: DefaultReserveRatio,\n      delinquencyGracePeriod: gracePeriod\n    });\n\n    parameters.controller = address(controller);\n    parameters.asset = address(asset = new MockERC20('Token', 'TKN', 18));\n    deployMarket(parameters);\n    _authorizeLender(alice);\n    asset.mint(alice, type(uint128).max);\n    asset.mint(bob, type(uint128).max);\n\n    _approve(alice, address(market), type(uint256).max);\n    _approve(bob, address(market), type(uint256).max);\n\n    \n        uint256 availableCollateral = market.borrowableAssets();\n        assertEq(availableCollateral, 0, 'borrowable should be 0');\n    \n        vm.prank(alice);\n        market.depositUpTo(50_000e18);\n        assertEq(market.borrowableAssets(), 40_000e18, 'borrowable should be 40k');\n        vm.prank(borrower);\n        market.borrow(40_000e18);\n        assertEq(asset.balanceOf(borrower), 40_000e18);\n      \n        // alice requests to withdraw the deposit\n        vm.prank(alice);\n        market.queueWithdrawal(50_000e18);\n\n        // 10_000 is filled with alices own amount. due to remaining the market has become delinquent\n        assertEq(market.currentState().isDelinquent,true);\n\n        uint128 normalizedUnclaimedWithdrawals = market.currentState().normalizedUnclaimedWithdrawals;        \n        uint256 pendingDebt = market.totalSupply();\n        assertEq(normalizedUnclaimedWithdrawals,10_000e18);\n        assertEq(pendingDebt,40_000e18);\n\n      // borrower deposits the debt back to avoid the delinquency fee. \n        vm.prank(borrower);\n        asset.transfer(address(market),40_000e18);\n        market.updateState();\n        \n        // but since not expired, the pending withdrawal debt is not closed making the borrower pay interest till the cycle end\n        assertEq(market.totalSupply(),pendingDebt); \n       \n        fastForward(withdrawalBatchDuration);\n        market.updateState();\n\n        // when expriy time passes the pending withdrawal debt will be matched with repayed debt and the protocol fee. but interest generated by this amount still remains\n        uint initialTotalAmount = normalizedUnclaimedWithdrawals + pendingDebt;\n        assertEq(market.currentState().normalizedUnclaimedWithdrawals + market.currentState().accruedProtocolFees,initialTotalAmount);\n        uint extraDebtFromInterestExculdingTheProtocolFee = market.totalSupply();\n\n        assertGt(extraDebtFromInterestExculdingTheProtocolFee,0);\n        \n  }\n\n  function _authorizeLender(address account) internal asAccount(parameters.borrower) {\n    address[] memory lenders = new address[](1);\n    lenders[0] = account;\n    controller.authorizeLenders(lenders);\n  }\n\n \n\n  function _approve(address from, address to, uint256 amount) internal asAccount(from) {\n    asset.approve(to, amount);\n  }\n}\n```\n</details>\n\n### Recommended Mitigation Steps\n\nUse `_applyWithdrawalBatchPayment()` in `_getUpdatedState()` similar to the implementation in `queueWithdrawal()`.\n\n### Assessed type\n\nTiming\n\n**[d1ll0n (Wildcat) acknowledged](https://github.com/code-423n4/2023-10-wildcat-findings/issues/365#issuecomment-1788824016)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-10-wildcat",
  "Code": [
    {
      "filename": "src/market/WildcatMarketBase.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport '../libraries/FeeMath.sol';\nimport '../libraries/Withdrawal.sol';\nimport { queryName, querySymbol } from '../libraries/StringQuery.sol';\nimport '../interfaces/IMarketEventsAndErrors.sol';\nimport '../interfaces/IWildcatMarketController.sol';\nimport '../interfaces/IWildcatSanctionsSentinel.sol';\nimport { IERC20, IERC20Metadata } from '../interfaces/IERC20Metadata.sol';\nimport '../ReentrancyGuard.sol';\nimport '../libraries/BoolUtils.sol';\n\ncontract WildcatMarketBase is ReentrancyGuard, IMarketEventsAndErrors {\n  using WithdrawalLib for MarketState;\n  using SafeCastLib for uint256;\n  using MathUtils for uint256;\n  using BoolUtils for bool;\n\n  // ==================================================================== //\n  //                       Market Config (immutable)                       //\n  // ==================================================================== //\n\n  string public constant version = '1.0';\n\n  /// @dev Account with blacklist control, used for blocking sanctioned addresses.\n  address public immutable sentinel;\n\n  /// @dev Account with authority to borrow assets from the market.\n  address public immutable borrower;\n\n  /// @dev Account that receives protocol fees.\n  address public immutable feeRecipient;\n\n  /// @dev Protocol fee added to interest paid by borrower.\n  uint256 public immutable protocolFeeBips;\n\n  /// @dev Penalty fee added to interest earned by lenders, does not affect protocol fee.\n  uint256 public immutable delinquencyFeeBips;\n\n  /// @dev Time after which delinquency incurs penalty fee.\n  uint256 public immutable delinquencyGracePeriod;\n\n  /// @dev Address of the Market Controller.\n  address public immutable controller;\n\n  /// @dev Address of the underlying asset.\n  address public immutable asset;\n\n  /// @dev Time before withdrawal batches are processed.\n  uint256 public immutable withdrawalBatchDuration;\n\n  /// @dev Token decimals (same as underlying asset).\n  uint8 public immutable decimals;\n\n  /// @dev Token name (prefixed name of underlying asset).\n  string public name;\n\n  /// @dev Token symbol (prefixed symbol of underlying asset).\n  string public symbol;\n\n  // ===================================================================== //\n  //                             Market State                               //\n  // ===================================================================== //\n\n  MarketState internal _state;\n\n  mapping(address => Account) internal _accounts;\n\n  WithdrawalData internal _withdrawalData;\n\n  // ===================================================================== //\n  //                             Constructor                               //\n  // ===================================================================== //\n\n  constructor() {\n    MarketParameters memory parameters = IWildcatMarketController(msg.sender).getMarketParameters();\n\n    if ((parameters.protocolFeeBips > 0).and(parameters.feeRecipient == address(0))) {\n      revert FeeSetWithoutRecipient();\n    }\n    if (parameters.annualInterestBips > BIP) {\n      revert InterestRateTooHigh();\n    }\n    if (parameters.reserveRatioBips > BIP) {\n      revert ReserveRatioBipsTooHigh();\n    }\n    if (parameters.protocolFeeBips > BIP) {\n      revert InterestFeeTooHigh();\n    }\n    if (parameters.delinquencyFeeBips > BIP) {\n      revert PenaltyFeeTooHigh();\n    }\n\n    // Set asset metadata\n    asset = parameters.asset;\n    name = string.concat(parameters.namePrefix, queryName(parameters.asset));\n    symbol = string.concat(parameters.symbolPrefix, querySymbol(parameters.asset));\n    decimals = IERC20Metadata(parameters.asset).decimals();\n\n    _state = MarketState({\n      isClosed: false,\n      maxTotalSupply: parameters.maxTotalSupply,\n      accruedProtocolFees: 0,\n      normalizedUnclaimedWithdrawals: 0,\n      scaledTotalSupply: 0,\n      scaledPendingWithdrawals: 0,\n      pendingWithdrawalExpiry: 0,\n      isDelinquent: false,\n      timeDelinquent: 0,\n      annualInterestBips: parameters.annualInterestBips,\n      reserveRatioBips: parameters.reserveRatioBips,\n      scaleFactor: uint112(RAY),\n      lastInterestAccruedTimestamp: uint32(block.timestamp)\n    });\n\n    sentinel = parameters.sentinel;\n    borrower = parameters.borrower;\n    controller = parameters.controller;\n    feeRecipient = parameters.feeRecipient;\n    protocolFeeBips = parameters.protocolFeeBips;\n    delinquencyFeeBips = parameters.delinquencyFeeBips;\n    delinquencyGracePeriod = parameters.delinquencyGracePeriod;\n    withdrawalBatchDuration = parameters.withdrawalBatchDuration;\n  }\n\n  // ===================================================================== //\n  //                              Modifiers                                //\n  // ===================================================================== //\n\n  modifier onlyBorrower() {\n    if (msg.sender != borrower) revert NotApprovedBorrower();\n    _;\n  }\n\n  modifier onlyController() {\n    if (msg.sender != controller) revert NotController();\n    _;\n  }\n\n  // ===================================================================== //\n  //                       Internal State Getters                          //\n  // ===================================================================== //\n\n  /**\n   * @dev Retrieve an account from storage.\n   *\n   *      Reverts if account is blocked.\n   */\n  function _getAccount(address accountAddress) internal view returns (Account memory account) {\n    account = _accounts[accountAddress];\n    if (account.approval == AuthRole.Blocked) {\n      revert AccountBlacklisted();\n    }\n  }\n\n  /**\n   * @dev Block an account and transfer its balance of market tokens\n   *      to an escrow contract.\n   *\n   *      If the account is already blocked, this function does nothing.\n   */\n  function _blockAccount(MarketState memory state, address accountAddress) internal {\n    Account memory account = _accounts[accountAddress];\n    if (account.approval != AuthRole.Blocked) {\n      uint104 scaledBalance = account.scaledBalance;\n      account.approval = AuthRole.Blocked;\n      emit AuthorizationStatusUpdated(accountAddress, AuthRole.Blocked);\n\n      if (scaledBalance > 0) {\n        account.scaledBalance = 0;\n        address escrow = IWildcatSanctionsSentinel(sentinel).createEscrow(\n          accountAddress,\n          borrower,\n          address(this)\n        );\n        emit Transfer(accountAddress, escrow, state.normalizeAmount(scaledBalance));\n        _accounts[escrow].scaledBalance += scaledBalance;\n        emit SanctionedAccountAssetsSentToEscrow(\n          accountAddress,\n          escrow,\n          state.normalizeAmount(scaledBalance)\n        );\n      }\n      _accounts[accountAddress] = account;\n    }\n  }\n\n  /**\n   * @dev Retrieve an account from storage and assert that it has at\n   *      least the required role.\n   *\n   *      If the account's role is not set, queries the controller to\n   *      determine if it is an approved lender; if it is, its role\n   *      is initialized to DepositAndWithdraw.\n   */\n  function _getAccountWithRole(\n    address accountAddress,\n    AuthRole requiredRole\n  ) internal returns (Account memory account) {\n    account = _getAccount(accountAddress);\n    // If account role is null, see if it is authorized on controller.\n    if (account.approval == AuthRole.Null) {\n      if (IWildcatMarketController(controller).isAuthorizedLender(accountAddress)) {\n        account.approval = AuthRole.DepositAndWithdraw;\n        emit AuthorizationStatusUpdated(accountAddress, AuthRole.DepositAndWithdraw);\n      }\n    }\n    // If account role is insufficient, revert.\n    if (uint256(account.approval) < uint256(requiredRole)) {\n      revert NotApprovedLender();\n    }\n  }\n\n  // ===================================================================== //\n  //                       External State Getters                          //\n  // ===================================================================== //\n\n  /**\n   * @dev Returns the amount of underlying assets the borrower is obligated\n   *      to maintain in the market to avoid delinquency.\n   */\n  function coverageLiquidity() external view nonReentrantView returns (uint256) {\n    return currentState().liquidityRequired();\n  }\n\n  /**\n   * @dev Returns the scale factor (in ray) used to convert scaled balances\n   *      to normalized balances.\n   */\n  function scaleFactor() external view nonReentrantView returns (uint256) {\n    return currentState().scaleFactor;\n  }\n\n  /**\n   * @dev Total balance in underlying asset.\n   */\n  function totalAssets() public view returns (uint256) {\n    return IERC20(asset).balanceOf(address(this));\n  }\n\n  /**\n   * @dev Returns the amount of underlying assets the borrower is allowed\n   *      to borrow.\n   *\n   *      This is the balance of underlying assets minus:\n   *      - pending (unpaid) withdrawals\n   *      - paid withdrawals\n   *      - reserve ratio times the portion of the supply not pending withdrawal\n   *      - protocol fees\n   */\n  function borrowableAssets() external view nonReentrantView returns (uint256) {\n    return currentState().borrowableAssets(totalAssets());\n  }\n\n  /**\n   * @dev Returns the amount of protocol fees (in underlying asset amount)\n   *      that have accrued and are pending withdrawal.\n   */\n  function accruedProtocolFees() external view nonReentrantView returns (uint256) {\n    return currentState().accruedProtocolFees;\n  }\n\n  /**\n   * @dev Returns the state of the market as of the last update.\n   */\n  function previousState() external view returns (MarketState memory) {\n    return _state;\n  }\n\n  /**\n   * @dev Return the state the market would have at the current block after applying\n   *      interest and fees accrued since the last update and processing the pending\n   *      withdrawal batch if it is expired.\n   */\n  function currentState() public view nonReentrantView returns (MarketState memory state) {\n    (state, , ) = _calculateCurrentState();\n  }\n\n  /**\n   * @dev Returns the scaled total supply the vaut would have at the current block\n   *      after applying interest and fees accrued since the last update and burning\n   *      market tokens for the pending withdrawal batch if it is expired.\n   */\n  function scaledTotalSupply() external view nonReentrantView returns (uint256) {\n    return currentState().scaledTotalSupply;\n  }\n\n  /**\n   * @dev Returns the scaled balance of `account`\n   */\n  function scaledBalanceOf(address account) external view nonReentrantView returns (uint256) {\n    return _accounts[account].scaledBalance;\n  }\n\n  /**\n   * @dev Returns current role of `account`.\n   */\n  function getAccountRole(address account) external view nonReentrantView returns (AuthRole) {\n    return _accounts[account].approval;\n  }\n\n  /**\n   * @dev Returns the amount of protocol fees that are currently\n   *      withdrawable by the fee recipient.\n   */\n  function withdrawableProtocolFees() external view returns (uint128) {\n    return currentState().withdrawableProtocolFees(totalAssets());\n  }\n\n  /**\n   * @dev Calculate effective interest rate currently paid by borrower.\n   *      Borrower pays base APR, protocol fee (on base APR) and delinquency\n   *      fee (if delinquent beyond grace period).\n   *\n   * @return apr paid by borrower in ray\n   */\n  function effectiveBorrowerAPR() external view returns (uint256) {\n    MarketState memory state = currentState();\n    // apr + (apr * protocolFee)\n    uint256 apr = MathUtils.bipToRay(state.annualInterestBips).bipMul(BIP + protocolFeeBips);\n    if (state.timeDelinquent > delinquencyGracePeriod) {\n      apr += MathUtils.bipToRay(delinquencyFeeBips);\n    }\n    return apr;\n  }\n\n  /**\n   * @dev Calculate effective interest rate currently earned by lenders.\n   *     Lenders earn base APR and delinquency fee (if delinquent beyond grace period)\n   *\n   * @return apr earned by lender in ray\n   */\n  function effectiveLenderAPR() external view returns (uint256) {\n    MarketState memory state = currentState();\n    uint256 apr = state.annualInterestBips;\n    if (state.timeDelinquent > delinquencyGracePeriod) {\n      apr += delinquencyFeeBips;\n    }\n    return MathUtils.bipToRay(apr);\n  }\n\n  // /*//////////////////////////////////////////////////////////////\n  //                     Internal State Handlers\n  // //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @dev Returns cached MarketState after accruing interest and delinquency / protocol fees\n   *      and processing expired withdrawal batch, if any.\n   *\n   *      Used by functions that make additional changes to `state`.\n   *\n   *      NOTE: Returned `state` does not match `_state` if interest is accrued\n   *            Calling function must update `_state` or revert.\n   *\n   * @return state Market state after interest is accrued.\n   */\n  function _getUpdatedState() internal returns (MarketState memory state) {\n    state = _state;\n    // Handle expired withdrawal batch\n    if (state.hasPendingExpiredBatch()) {\n      uint256 expiry = state.pendingWithdrawalExpiry;\n      // Only accrue interest if time has passed since last update.\n      // This will only be false if withdrawalBatchDuration is 0.\n      if (expiry != state.lastInterestAccruedTimestamp) {\n        (uint256 baseInterestRay, uint256 delinquencyFeeRay, uint256 protocolFee) = state\n          .updateScaleFactorAndFees(\n            protocolFeeBips,\n            delinquencyFeeBips,\n            delinquencyGracePeriod,\n            expiry\n          );\n        emit ScaleFactorUpdated(state.scaleFactor, baseInterestRay, delinquencyFeeRay, protocolFee);\n      }\n      _processExpiredWithdrawalBatch(state);\n    }\n    // Apply interest and fees accrued since last update (expiry or previous tx)\n    if (block.timestamp != state.lastInterestAccruedTimestamp) {\n      (uint256 baseInterestRay, uint256 delinquencyFeeRay, uint256 protocolFee) = state\n        .updateScaleFactorAndFees(\n          protocolFeeBips,\n          delinquencyFeeBips,\n          delinquencyGracePeriod,\n          block.timestamp\n        );\n      emit ScaleFactorUpdated(state.scaleFactor, baseInterestRay, delinquencyFeeRay, protocolFee);\n    }\n  }\n\n  /**\n   * @dev Calculate the current state, applying fees and interest accrued since\n   *      the last state update as well as the effects of withdrawal batch expiry\n   *      on the market state.\n   *      Identical to _getUpdatedState() except it does not modify storage or\n   *      or emit events.\n   *      Returns expired batch data, if any, so queries against batches have\n   *      access to the most recent data.\n   */\n  function _calculateCurrentState()\n    internal\n    view\n    returns (\n      MarketState memory state,\n      uint32 expiredBatchExpiry,\n      WithdrawalBatch memory expiredBatch\n    )\n  {\n    state = _state;\n    // Handle expired withdrawal batch\n    if (state.hasPendingExpiredBatch()) {\n      expiredBatchExpiry = state.pendingWithdrawalExpiry;\n      // Only accrue interest if time has passed since last update.\n      // This will only be false if withdrawalBatchDuration is 0.\n      if (expiredBatchExpiry != state.lastInterestAccruedTimestamp) {\n        state.updateScaleFactorAndFees(\n          protocolFeeBips,\n          delinquencyFeeBips,\n          delinquencyGracePeriod,\n          expiredBatchExpiry\n        );\n      }\n\n      expiredBatch = _withdrawalData.batches[expiredBatchExpiry];\n      uint256 availableLiquidity = expiredBatch.availableLiquidityForPendingBatch(\n        state,\n        totalAssets()\n      );\n      if (availableLiquidity > 0) {\n        _applyWithdrawalBatchPaymentView(expiredBatch, state, availableLiquidity);\n      }\n      state.pendingWithdrawalExpiry = 0;\n    }\n\n    if (state.lastInterestAccruedTimestamp != block.timestamp) {\n      state.updateScaleFactorAndFees(\n        protocolFeeBips,\n        delinquencyFeeBips,\n        delinquencyGracePeriod,\n        block.timestamp\n      );\n    }\n  }\n\n  /**\n   * @dev Writes the cached MarketState to storage and emits an event.\n   *      Used at the end of all functions which modify `state`.\n   */\n  function _writeState(MarketState memory state) internal {\n    bool isDelinquent = state.liquidityRequired() > totalAssets();\n    state.isDelinquent = isDelinquent;\n    _state = state;\n    emit StateUpdated(state.scaleFactor, isDelinquent);\n  }\n\n  /**\n   * @dev Handles an expired withdrawal batch:\n   *      - Retrieves the amount of underlying assets that can be used to pay for the batch.\n   *      - If the amount is sufficient to pay the full amount owed to the batch, the batch\n   *        is closed and the total withdrawal amount is reserved.\n   *      - If the amount is insufficient to pay the full amount owed to the batch, the batch\n   *        is recorded as an unpaid batch and the available assets are reserved.\n   *      - The assets reserved for the batch are scaled by the current scale factor and that\n   *        amount of scaled tokens is burned, ensuring borrowers do not continue paying interest\n   *        on withdrawn assets.\n   */\n  function _processExpiredWithdrawalBatch(MarketState memory state) internal {\n    uint32 expiry = state.pendingWithdrawalExpiry;\n    WithdrawalBatch memory batch = _withdrawalData.batches[expiry];\n\n    // Burn as much of the withdrawal batch as possible with available liquidity.\n    uint256 availableLiquidity = batch.availableLiquidityForPendingBatch(state, totalAssets());\n    if (availableLiquidity > 0) {\n      _applyWithdrawalBatchPayment(batch, state, expiry, availableLiquidity);\n    }\n\n    emit WithdrawalBatchExpired(\n      expiry,\n      batch.scaledTotalAmount,\n      batch.scaledAmountBurned,\n      batch.normalizedAmountPaid\n    );\n\n    if (batch.scaledAmountBurned < batch.scaledTotalAmount) {\n      _withdrawalData.unpaidBatches.push(expiry);\n    } else {\n      emit WithdrawalBatchClosed(expiry);\n    }\n\n    state.pendingWithdrawalExpiry = 0;\n\n    _withdrawalData.batches[expiry] = batch;\n  }\n\n  /**\n   * @dev Process withdrawal payment, burning market tokens and reserving\n   *      underlying assets so they are only available for withdrawals.\n   */\n  function _applyWithdrawalBatchPayment(\n    WithdrawalBatch memory batch,\n    MarketState memory state,\n    uint32 expiry,\n    uint256 availableLiquidity\n  ) internal {\n    uint104 scaledAvailableLiquidity = state.scaleAmount(availableLiquidity).toUint104();\n    uint104 scaledAmountOwed = batch.scaledTotalAmount - batch.scaledAmountBurned;\n    // Do nothing if batch is already paid\n    if (scaledAmountOwed == 0) {\n      return;\n    }\n    uint104 scaledAmountBurned = uint104(MathUtils.min(scaledAvailableLiquidity, scaledAmountOwed));\n    uint128 normalizedAmountPaid = state.normalizeAmount(scaledAmountBurned).toUint128();\n\n    batch.scaledAmountBurned += scaledAmountBurned;\n    batch.normalizedAmountPaid += normalizedAmountPaid;\n    state.scaledPendingWithdrawals -= scaledAmountBurned;\n\n    // Update normalizedUnclaimedWithdrawals so the tokens are only accessible for withdrawals.\n    state.normalizedUnclaimedWithdrawals += normalizedAmountPaid;\n\n    // Burn market tokens to stop interest accrual upon withdrawal payment.\n    state.scaledTotalSupply -= scaledAmountBurned;\n\n    // Emit transfer for external trackers to indicate burn.\n    emit Transfer(address(this), address(0), normalizedAmountPaid);\n    emit WithdrawalBatchPayment(expiry, scaledAmountBurned, normalizedAmountPaid);\n  }\n\n  function _applyWithdrawalBatchPaymentView(\n    WithdrawalBatch memory batch,\n    MarketState memory state,\n    uint256 availableLiquidity\n  ) internal pure {\n    uint104 scaledAvailableLiquidity = state.scaleAmount(availableLiquidity).toUint104();\n    uint104 scaledAmountOwed = batch.scaledTotalAmount - batch.scaledAmountBurned;\n    // Do nothing if batch is already paid\n    if (scaledAmountOwed == 0) {\n      return;\n    }\n    uint104 scaledAmountBurned = uint104(MathUtils.min(scaledAvailableLiquidity, scaledAmountOwed));\n    uint128 normalizedAmountPaid = state.normalizeAmount(scaledAmountBurned).toUint128();\n\n    batch.scaledAmountBurned += scaledAmountBurned;\n    batch.normalizedAmountPaid += normalizedAmountPaid;\n    state.scaledPendingWithdrawals -= scaledAmountBurned;\n\n    // Update normalizedUnclaimedWithdrawals so the tokens are only accessible for withdrawals.\n    state.normalizedUnclaimedWithdrawals += normalizedAmountPaid;\n\n    // Burn market tokens to stop interest accrual upon withdrawal payment.\n    state.scaledTotalSupply -= scaledAmountBurned;\n  }\n}"
    }
  ]
}