{
  "Title": "[M-03] `PartyGovernanceNFT` advertises but does not honor the ERC-4906 standard",
  "Content": "\n### Lines of code\n\n<https://github.com/code-423n4/2023-10-party/blob/b23c65d62a20921c709582b0b76b387f2bb9ebb5/contracts/party/PartyGovernanceNFT.sol#L208><br>\n<https://github.com/code-423n4/2023-10-party/blob/b23c65d62a20921c709582b0b76b387f2bb9ebb5/contracts/party/PartyGovernanceNFT.sol#L236><br>\n<https://github.com/code-423n4/2023-10-party/blob/b23c65d62a20921c709582b0b76b387f2bb9ebb5/contracts/party/PartyGovernanceNFT.sol#L247><br>\n<https://github.com/code-423n4/2023-10-party/blob/b23c65d62a20921c709582b0b76b387f2bb9ebb5/contracts/party/PartyGovernanceNFT.sol#L255>\n\n### Vulnerability details\n\nThe `PartyGovernanceNFT` contract inherits from PartyGovernance, and through it, it advertises support for the ERC-4906 standard:\n\n```Solidity\n    // PartyGovernance.sol:333\n\n    function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {\n        return\n            interfaceId == type(IERC721Receiver).interfaceId ||\n            interfaceId == type(ERC1155TokenReceiverBase).interfaceId ||\n            // ERC4906 interface ID\n            interfaceId == 0x49064906;\n    }\n```\n\nBecause of this, consumers like NFT marketplaces or block explorer expect updates from `PartyGovernanceNFT` in the form of `MetadataUpdate` or `BatchMetadataUpdate` events whenever the metadata of its NFTs changes.\n\nThe protocol has a default implementation of Party metadata, which, among other information, includes voting power:\n\n```Solidity\n                // PartyNFTRenderer.sol:292\n                string.concat(\n                    \"This membership represents \",\n                    generateVotingPowerPercentage(tokenId),\n                    \"% voting power in \",\n                    partyName,\n                    \". Head to \",\n                    generateExternalURL(),\n                    \" to view the Party's latest activity.\"\n                );\n```\n\nConsequently, the metadata is expected to change whenever a single NFT's voting power, or the contract's total voting power are updated.\nHowever, when this happens, no `MetadataUpdate` or `BatchMetadataUpdate` event is raised.\n\nThe following vote-share (and consequently metadata) changing functions have been identified, and none emits the required events:\n\n```Solidity\n    // PartyGovernanceNFT.sol:208\n    function increaseVotingPower(uint256 tokenId, uint96 votingPower) external {\n        // [...]\n        emit PartyCardIntrinsicVotingPowerSet(tokenId, newIntrinsicVotingPower);\n\n        _adjustVotingPower(ownerOf(tokenId), votingPower.safeCastUint96ToInt192(), address(0));\n    }\n```\n\n```Solidity\n    // PartyGovernanceNFT.sol:236\n    function decreaseVotingPower(uint256 tokenId, uint96 votingPower) external {\n        _assertAuthority();\n        mintedVotingPower -= votingPower;\n        votingPowerByTokenId[tokenId] -= votingPower;\n\n        _adjustVotingPower(ownerOf(tokenId), -votingPower.safeCastUint96ToInt192(), address(0));\n    }\n```\n\n```Solidity\n    // PartyGovernanceNFT.sol:247\n    function increaseTotalVotingPower(uint96 votingPower) external {\n        _assertAuthority();\n        _getSharedProposalStorage().governanceValues.totalVotingPower += votingPower;\n    }\n```\n\n```Solidity\n    // PartyGovernanceNFT.sol:255\n    function decreaseTotalVotingPower(uint96 votingPower) external {\n        _assertAuthority();\n        _getSharedProposalStorage().governanceValues.totalVotingPower -= votingPower;\n    }\n```\n\nAs a consequence, off-chain platforms like NFT marketplaces or block explorers may show stale metadata for the NFTs, and token holders can use this stale data to their advantage.\n\nTo add context, openness to having `PartyGovernanceNFT` tokens traded on a marketplace seems a reasonable use case since the team opted for implementing [the ERC-2981 standard](https://eips.ethereum.org/EIPS/eip-2981) for `PartyGovernanceNFT` tokens.\n\n### Impact\n\n`PartyGovernanceNFT` tokens may be exchanged for inflated prices on platforms showing stale data.\n\n### Proof of Concept\n\nStarting with a `PartyGovernanceNFT` (after crowdfunding is finalized) that delegates its `tokenURI` to a `PartyNFTRenderer` contract:\n\n- Create an NFT, and hash its `tokenURI`.\n- Call `increaseVotingPower` or `decreaseVotingPower` for the given NFT:\n    - Hash again the NFT `tokenURI` and observe how it's changed.\n    - However no `MetadataUpdate` was called.\n- Call `increaseTotalVotingPower` or `decreaseTotalVotingPower`.\n    - Hash again the NFT `tokenURI` and observe how it's changed.\n    - However no `BatchMetadataUpdate` was called.\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nConsider updating:\n\n- `PartyGovernanceNFT.increaseVotingPower` to emit a `MetadataUpdate` event.\n- `PartyGovernanceNFT.decreaseVotingPower` to emit a `MetadataUpdate` event.\n- `PartyGovernanceNFT.increaseTotalVotingPower` to emit a `BatchMetadataUpdate` event.\n- `PartyGovernanceNFT.decreaseTotalVotingPower` to emit a `BatchMetadataUpdate` event.\n\n### Assessed type\n\nERC721\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2023-10-party-findings/issues/340#issuecomment-1817923547):**\n > Judging as Med due to broken support of [ERC4960](https://github.com/code-423n4/2023-10-party/blob/b23c65d62a20921c709582b0b76b387f2bb9ebb5/README.md?plain=1#L120)\n> > - `PartyGovernance`: Should comply with `ERC4906`\n> \n\n**[0xble (Party) confirmed](https://github.com/code-423n4/2023-10-party-findings/issues/340#issuecomment-1821304549)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-10-party",
  "Code": [
    {
      "filename": "contracts/party/PartyGovernanceNFT.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.20;\n\nimport \"../utils/LibSafeCast.sol\";\nimport \"../utils/LibAddress.sol\";\nimport \"openzeppelin/contracts/interfaces/IERC2981.sol\";\nimport \"../globals/IGlobals.sol\";\nimport \"../tokens/IERC721.sol\";\nimport \"../vendor/solmate/ERC721.sol\";\nimport \"./PartyGovernance.sol\";\nimport \"../renderers/RendererStorage.sol\";\n\n/// @notice ERC721 functionality built on top of `PartyGovernance`.\ncontract PartyGovernanceNFT is PartyGovernance, ERC721, IERC2981 {\n    using LibSafeCast for uint256;\n    using LibSafeCast for uint96;\n    using LibERC20Compat for IERC20;\n    using LibAddress for address payable;\n\n    error FixedRageQuitTimestampError(uint40 rageQuitTimestamp);\n    error CannotRageQuitError(uint40 rageQuitTimestamp);\n    error CannotDisableRageQuitAfterInitializationError();\n    error InvalidTokenOrderError();\n    error BelowMinWithdrawAmountError(uint256 amount, uint256 minAmount);\n    error NothingToBurnError();\n\n    event AuthorityAdded(address indexed authority);\n    event AuthorityRemoved(address indexed authority);\n    event RageQuitSet(uint40 oldRageQuitTimestamp, uint40 newRageQuitTimestamp);\n    event Burn(address caller, uint256 tokenId, uint256 votingPower);\n    event RageQuit(address caller, uint256[] tokenIds, IERC20[] withdrawTokens, address receiver);\n    event PartyCardIntrinsicVotingPowerSet(uint256 indexed tokenId, uint256 intrinsicVotingPower);\n\n    uint40 private constant ENABLE_RAGEQUIT_PERMANENTLY = 0x6b5b567bfe; // uint40(uint256(keccak256(\"ENABLE_RAGEQUIT_PERMANENTLY\")))\n    uint40 private constant DISABLE_RAGEQUIT_PERMANENTLY = 0xab2cb21860; // uint40(uint256(keccak256(\"DISABLE_RAGEQUIT_PERMANENTLY\")))\n\n    // Token address used to indicate ETH.\n    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    // The `Globals` contract storing global configuration values. This contract\n    // is immutable and its address will never change.\n    IGlobals private immutable _GLOBALS;\n\n    /// @notice The number of tokens that have been minted.\n    uint96 public tokenCount;\n    /// @notice The total minted voting power.\n    ///         Capped to `_governanceValues.totalVotingPower` unless minting\n    ///         party cards for initial crowdfund.\n    uint96 public mintedVotingPower;\n    /// @notice The timestamp until which ragequit is enabled. Can be set to the\n    ///         `ENABLE_RAGEQUIT_PERMANENTLY`/`DISABLE_RAGEQUIT_PERMANENTLY`\n    ///         values to enable/disable ragequit permanently.\n    ///         `DISABLE_RAGEQUIT_PERMANENTLY` can only be set during\n    ///         initialization.\n    uint40 public rageQuitTimestamp;\n    /// @notice The voting power of `tokenId`.\n    mapping(uint256 => uint256) public votingPowerByTokenId;\n    /// @notice Address with authority to mint cards and update voting power for the party.\n    mapping(address => bool) public isAuthority;\n\n    function _assertAuthority() internal view {\n        if (!isAuthority[msg.sender]) {\n            revert NotAuthorized();\n        }\n    }\n\n    modifier onlySelf() {\n        if (msg.sender != address(this)) {\n            revert NotAuthorized();\n        }\n        _;\n    }\n\n    // Set the `Globals` contract. The name or symbol of ERC721 does not matter;\n    // it will be set in `_initialize()`.\n    constructor(IGlobals globals) payable PartyGovernance(globals) ERC721(\"\", \"\") {\n        _GLOBALS = globals;\n    }\n\n    // Initialize storage for proxy contracts.\n    function _initialize(\n        string memory name_,\n        string memory symbol_,\n        uint256 customizationPresetId,\n        PartyGovernance.GovernanceOpts memory governanceOpts,\n        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,\n        IERC721[] memory preciousTokens,\n        uint256[] memory preciousTokenIds,\n        address[] memory authorities,\n        uint40 rageQuitTimestamp_\n    ) internal {\n        PartyGovernance._initialize(\n            governanceOpts,\n            proposalEngineOpts,\n            preciousTokens,\n            preciousTokenIds\n        );\n        name = name_;\n        symbol = symbol_;\n        rageQuitTimestamp = rageQuitTimestamp_;\n        unchecked {\n            for (uint256 i; i < authorities.length; ++i) {\n                isAuthority[authorities[i]] = true;\n            }\n        }\n        if (customizationPresetId != 0) {\n            RendererStorage(_GLOBALS.getAddress(LibGlobals.GLOBAL_RENDERER_STORAGE))\n                .useCustomizationPreset(customizationPresetId);\n        }\n    }\n\n    /// @inheritdoc EIP165\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public pure override(PartyGovernance, ERC721, IERC165) returns (bool) {\n        return\n            PartyGovernance.supportsInterface(interfaceId) ||\n            ERC721.supportsInterface(interfaceId) ||\n            interfaceId == type(IERC2981).interfaceId;\n    }\n\n    /// @inheritdoc ERC721\n    function tokenURI(uint256) public view override returns (string memory) {\n        _delegateToRenderer();\n        return \"\"; // Just to make the compiler happy.\n    }\n\n    /// @notice Returns a URI for the storefront-level metadata for your contract.\n    function contractURI() external view returns (string memory) {\n        _delegateToRenderer();\n        return \"\"; // Just to make the compiler happy.\n    }\n\n    /// @notice Called with the sale price to determine how much royalty\n    //          is owed and to whom.\n    function royaltyInfo(uint256, uint256) external view returns (address, uint256) {\n        _delegateToRenderer();\n        return (address(0), 0); // Just to make the compiler happy.\n    }\n\n    /// @notice Return the distribution share amount of a token. Included as an alias\n    ///         for `votePowerByTokenId` for backwards compatibility with old\n    ///         `TokenDistributor` implementations.\n    /// @param tokenId The token ID to query.\n    /// @return share The distribution shares of `tokenId`.\n    function getDistributionShareOf(uint256 tokenId) external view returns (uint256) {\n        return votingPowerByTokenId[tokenId];\n    }\n\n    /// @notice Return the voting power share of a token. Denominated\n    ///         fractions of 1e18. I.e., 1e18 = 100%.\n    /// @param tokenId The token ID to query.\n    /// @return share The voting power percentage of `tokenId`.\n    function getVotingPowerShareOf(uint256 tokenId) public view returns (uint256) {\n        uint256 totalVotingPower = _getSharedProposalStorage().governanceValues.totalVotingPower;\n        return\n            totalVotingPower == 0 ? 0 : (votingPowerByTokenId[tokenId] * 1e18) / totalVotingPower;\n    }\n\n    /// @notice Mint a governance NFT for `owner` with `votingPower` and\n    ///         immediately delegate voting power to `delegate.` Only callable\n    ///         by an authority.\n    /// @param owner The owner of the NFT.\n    /// @param votingPower The voting power of the NFT.\n    /// @param delegate The address to delegate voting power to.\n    function mint(\n        address owner,\n        uint256 votingPower,\n        address delegate\n    ) external returns (uint256 tokenId) {\n        _assertAuthority();\n        uint96 mintedVotingPower_ = mintedVotingPower;\n        uint96 totalVotingPower = _getSharedProposalStorage().governanceValues.totalVotingPower;\n\n        // Cap voting power to remaining unminted voting power supply.\n        uint96 votingPower_ = votingPower.safeCastUint256ToUint96();\n        // Allow minting past total voting power if minting party cards for\n        // initial crowdfund when there is no total voting power.\n        if (totalVotingPower != 0 && totalVotingPower - mintedVotingPower_ < votingPower_) {\n            unchecked {\n                votingPower_ = totalVotingPower - mintedVotingPower_;\n            }\n        }\n\n        // Update state.\n        unchecked {\n            tokenId = ++tokenCount;\n        }\n        mintedVotingPower += votingPower_;\n        votingPowerByTokenId[tokenId] = votingPower_;\n\n        emit PartyCardIntrinsicVotingPowerSet(tokenId, votingPower_);\n\n        // Use delegate from party over the one set during crowdfund.\n        address delegate_ = delegationsByVoter[owner];\n        if (delegate_ != address(0)) {\n            delegate = delegate_;\n        }\n\n        _adjustVotingPower(owner, votingPower_.safeCastUint96ToInt192(), delegate);\n        _safeMint(owner, tokenId);\n    }\n\n    /// @notice Add voting power to an existing NFT. Only callable by an\n    ///         authority.\n    /// @param tokenId The ID of the NFT to add voting power to.\n    /// @param votingPower The amount of voting power to add.\n    function increaseVotingPower(uint256 tokenId, uint96 votingPower) external {\n        _assertAuthority();\n        uint96 mintedVotingPower_ = mintedVotingPower;\n        uint96 totalVotingPower = _getSharedProposalStorage().governanceValues.totalVotingPower;\n\n        // Cap voting power to remaining unminted voting power supply. Allow\n        // minting past total voting power if minting party cards for initial\n        // crowdfund when there is no total voting power.\n        if (totalVotingPower != 0 && totalVotingPower - mintedVotingPower_ < votingPower) {\n            unchecked {\n                votingPower = totalVotingPower - mintedVotingPower_;\n            }\n        }\n\n        // Update state.\n        mintedVotingPower += votingPower;\n        uint256 newIntrinsicVotingPower = votingPowerByTokenId[tokenId] + votingPower;\n        votingPowerByTokenId[tokenId] = newIntrinsicVotingPower;\n\n        emit PartyCardIntrinsicVotingPowerSet(tokenId, newIntrinsicVotingPower);\n\n        _adjustVotingPower(ownerOf(tokenId), votingPower.safeCastUint96ToInt192(), address(0));\n    }\n\n    /// @notice Remove voting power from an existing NFT. Only callable by an\n    ///         authority.\n    /// @param tokenId The ID of the NFT to remove voting power from.\n    /// @param votingPower The amount of voting power to remove.\n    function decreaseVotingPower(uint256 tokenId, uint96 votingPower) external {\n        _assertAuthority();\n        mintedVotingPower -= votingPower;\n        votingPowerByTokenId[tokenId] -= votingPower;\n\n        _adjustVotingPower(ownerOf(tokenId), -votingPower.safeCastUint96ToInt192(), address(0));\n    }\n\n    /// @notice Increase the total voting power of the party. Only callable by\n    ///         an authority.\n    /// @param votingPower The new total voting power to add.\n    function increaseTotalVotingPower(uint96 votingPower) external {\n        _assertAuthority();\n        _getSharedProposalStorage().governanceValues.totalVotingPower += votingPower;\n    }\n\n    /// @notice Decrease the total voting power of the party. Only callable by\n    ///         an authority.\n    /// @param votingPower The new total voting power to add.\n    function decreaseTotalVotingPower(uint96 votingPower) external {\n        _assertAuthority();\n        _getSharedProposalStorage().governanceValues.totalVotingPower -= votingPower;\n    }\n\n    /// @notice Burn governance NFTs and remove their voting power. Can only\n    ///         be called by an authority before the party has started.\n    /// @param tokenIds The IDs of the governance NFTs to burn.\n    function burn(uint256[] memory tokenIds) public {\n        _assertAuthority();\n        _burnAndUpdateVotingPower(tokenIds, false);\n    }\n\n    function _burnAndUpdateVotingPower(\n        uint256[] memory tokenIds,\n        bool checkIfAuthorizedToBurn\n    ) private returns (uint96 totalVotingPowerBurned) {\n        for (uint256 i; i < tokenIds.length; ++i) {\n            uint256 tokenId = tokenIds[i];\n            address owner = ownerOf(tokenId);\n\n            // Check if caller is authorized to burn the token.\n            if (checkIfAuthorizedToBurn) {\n                if (\n                    msg.sender != owner &&\n                    getApproved[tokenId] != msg.sender &&\n                    !isApprovedForAll[owner][msg.sender]\n                ) {\n                    revert NotAuthorized();\n                }\n            }\n\n            // Must be retrieved before updating voting power for token to be burned.\n            uint96 votingPower = votingPowerByTokenId[tokenId].safeCastUint256ToUint96();\n\n            totalVotingPowerBurned += votingPower;\n\n            // Update voting power for token to be burned.\n            delete votingPowerByTokenId[tokenId];\n            emit PartyCardIntrinsicVotingPowerSet(tokenId, 0);\n            _adjustVotingPower(owner, -votingPower.safeCastUint96ToInt192(), address(0));\n\n            // Burn token.\n            _burn(tokenId);\n\n            emit Burn(msg.sender, tokenId, votingPower);\n        }\n\n        // Update minted voting power.\n        mintedVotingPower -= totalVotingPowerBurned;\n    }\n\n    /// @notice Burn governance NFT and remove its voting power. Can only be\n    ///         called by an authority before the party has started.\n    /// @param tokenId The ID of the governance NFTs to burn.\n    function burn(uint256 tokenId) external {\n        uint256[] memory tokenIds = new uint256[](1);\n        tokenIds[0] = tokenId;\n        burn(tokenIds);\n    }\n\n    /// @notice Set the timestamp until which ragequit is enabled.\n    /// @param newRageQuitTimestamp The new ragequit timestamp.\n    function setRageQuit(uint40 newRageQuitTimestamp) external {\n        _assertHost();\n        // Prevent disabling ragequit after initialization.\n        if (newRageQuitTimestamp == DISABLE_RAGEQUIT_PERMANENTLY) {\n            revert CannotDisableRageQuitAfterInitializationError();\n        }\n\n        uint40 oldRageQuitTimestamp = rageQuitTimestamp;\n\n        // Prevent setting timestamp if it is permanently enabled/disabled.\n        if (\n            oldRageQuitTimestamp == ENABLE_RAGEQUIT_PERMANENTLY ||\n            oldRageQuitTimestamp == DISABLE_RAGEQUIT_PERMANENTLY\n        ) {\n            revert FixedRageQuitTimestampError(oldRageQuitTimestamp);\n        }\n\n        emit RageQuitSet(oldRageQuitTimestamp, rageQuitTimestamp = newRageQuitTimestamp);\n    }\n\n    /// @notice Burn a governance NFT and withdraw a fair share of fungible tokens from the party.\n    /// @param tokenIds The IDs of the governance NFTs to burn.\n    /// @param withdrawTokens The fungible tokens to withdraw. Specify the\n    ///                       `ETH_ADDRESS` value to withdraw ETH.\n    /// @param minWithdrawAmounts The minimum amount of to withdraw for each token.\n    /// @param receiver The address to receive the withdrawn tokens.\n    function rageQuit(\n        uint256[] calldata tokenIds,\n        IERC20[] calldata withdrawTokens,\n        uint256[] calldata minWithdrawAmounts,\n        address receiver\n    ) external {\n        if (tokenIds.length == 0) revert NothingToBurnError();\n\n        // Check if called by an authority.\n        bool isAuthority_ = isAuthority[msg.sender];\n\n        // Check if ragequit is allowed.\n        uint40 currentRageQuitTimestamp = rageQuitTimestamp;\n        if (!isAuthority_) {\n            if (currentRageQuitTimestamp != ENABLE_RAGEQUIT_PERMANENTLY) {\n                if (\n                    currentRageQuitTimestamp == DISABLE_RAGEQUIT_PERMANENTLY ||\n                    currentRageQuitTimestamp < block.timestamp\n                ) {\n                    revert CannotRageQuitError(currentRageQuitTimestamp);\n                }\n            }\n        }\n\n        // Used as a reentrancy guard. Will be updated back after ragequit.\n        rageQuitTimestamp = DISABLE_RAGEQUIT_PERMANENTLY;\n\n        // Update last rage quit timestamp.\n        lastRageQuitTimestamp = uint40(block.timestamp);\n\n        // Sum up total amount of each token to withdraw.\n        uint256[] memory withdrawAmounts = new uint256[](withdrawTokens.length);\n        {\n            IERC20 prevToken;\n            for (uint256 i; i < withdrawTokens.length; ++i) {\n                // Check if order of tokens to transfer is valid.\n                // Prevent null and duplicate transfers.\n                if (prevToken >= withdrawTokens[i]) revert InvalidTokenOrderError();\n\n                prevToken = withdrawTokens[i];\n\n                // Check token's balance.\n                uint256 balance = address(withdrawTokens[i]) == ETH_ADDRESS\n                    ? address(this).balance\n                    : withdrawTokens[i].balanceOf(address(this));\n\n                // Add fair share of tokens from the party to total.\n                for (uint256 j; j < tokenIds.length; ++j) {\n                    // Must be retrieved before burning the token.\n                    withdrawAmounts[i] += (balance * getVotingPowerShareOf(tokenIds[j])) / 1e18;\n                }\n            }\n        }\n        {\n            // Burn caller's party cards. This will revert if caller is not the\n            // the owner or approved for any of the card they are attempting to\n            // burn, not an authority, or if there are duplicate token IDs.\n            uint96 totalVotingPowerBurned = _burnAndUpdateVotingPower(tokenIds, !isAuthority_);\n\n            // Update total voting power of party.\n            _getSharedProposalStorage().governanceValues.totalVotingPower -= totalVotingPowerBurned;\n        }\n        {\n            uint16 feeBps_ = feeBps;\n            for (uint256 i; i < withdrawTokens.length; ++i) {\n                IERC20 token = withdrawTokens[i];\n                uint256 amount = withdrawAmounts[i];\n\n                // Take fee from amount.\n                uint256 fee = (amount * feeBps_) / 1e4;\n\n                if (fee > 0) {\n                    amount -= fee;\n\n                    // Transfer fee to fee recipient.\n                    if (address(token) == ETH_ADDRESS) {\n                        payable(feeRecipient).transferEth(fee);\n                    } else {\n                        token.compatTransfer(feeRecipient, fee);\n                    }\n                }\n\n                if (amount > 0) {\n                    uint256 minAmount = minWithdrawAmounts[i];\n\n                    // Check amount is at least minimum.\n                    if (amount < minAmount) {\n                        revert BelowMinWithdrawAmountError(amount, minAmount);\n                    }\n\n                    // Transfer token from party to recipient.\n                    if (address(token) == ETH_ADDRESS) {\n                        payable(receiver).transferEth(amount);\n                    } else {\n                        token.compatTransfer(receiver, amount);\n                    }\n                }\n            }\n        }\n\n        // Update ragequit timestamp back to before.\n        rageQuitTimestamp = currentRageQuitTimestamp;\n\n        emit RageQuit(msg.sender, tokenIds, withdrawTokens, receiver);\n    }\n\n    /// @inheritdoc ERC721\n    function transferFrom(address owner, address to, uint256 tokenId) public override {\n        // Transfer voting along with token.\n        _transferVotingPower(owner, to, votingPowerByTokenId[tokenId]);\n        super.transferFrom(owner, to, tokenId);\n    }\n\n    /// @inheritdoc ERC721\n    function safeTransferFrom(address owner, address to, uint256 tokenId) public override {\n        // super.safeTransferFrom() will call transferFrom() first which will\n        // transfer voting power.\n        super.safeTransferFrom(owner, to, tokenId);\n    }\n\n    /// @inheritdoc ERC721\n    function safeTransferFrom(\n        address owner,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) public override {\n        // super.safeTransferFrom() will call transferFrom() first which will\n        // transfer voting power.\n        super.safeTransferFrom(owner, to, tokenId, data);\n    }\n\n    /// @notice Add a new authority.\n    /// @dev Used in `AddAuthorityProposal`. Only the party itself can add\n    ///      authorities to prevent it from being used anywhere else.\n    function addAuthority(address authority) external onlySelf {\n        isAuthority[authority] = true;\n\n        emit AuthorityAdded(authority);\n    }\n\n    /// @notice Relinquish the authority role.\n    function abdicateAuthority() external {\n        _assertAuthority();\n        delete isAuthority[msg.sender];\n\n        emit AuthorityRemoved(msg.sender);\n    }\n\n    function _delegateToRenderer() private view {\n        _readOnlyDelegateCall(\n            // Instance of IERC721Renderer.\n            _GLOBALS.getAddress(LibGlobals.GLOBAL_GOVERNANCE_NFT_RENDER_IMPL),\n            msg.data\n        );\n        assert(false); // Will not be reached.\n    }\n}"
    },
    {
      "filename": "contracts/party/PartyGovernanceNFT.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.20;\n\nimport \"../utils/LibSafeCast.sol\";\nimport \"../utils/LibAddress.sol\";\nimport \"openzeppelin/contracts/interfaces/IERC2981.sol\";\nimport \"../globals/IGlobals.sol\";\nimport \"../tokens/IERC721.sol\";\nimport \"../vendor/solmate/ERC721.sol\";\nimport \"./PartyGovernance.sol\";\nimport \"../renderers/RendererStorage.sol\";\n\n/// @notice ERC721 functionality built on top of `PartyGovernance`.\ncontract PartyGovernanceNFT is PartyGovernance, ERC721, IERC2981 {\n    using LibSafeCast for uint256;\n    using LibSafeCast for uint96;\n    using LibERC20Compat for IERC20;\n    using LibAddress for address payable;\n\n    error FixedRageQuitTimestampError(uint40 rageQuitTimestamp);\n    error CannotRageQuitError(uint40 rageQuitTimestamp);\n    error CannotDisableRageQuitAfterInitializationError();\n    error InvalidTokenOrderError();\n    error BelowMinWithdrawAmountError(uint256 amount, uint256 minAmount);\n    error NothingToBurnError();\n\n    event AuthorityAdded(address indexed authority);\n    event AuthorityRemoved(address indexed authority);\n    event RageQuitSet(uint40 oldRageQuitTimestamp, uint40 newRageQuitTimestamp);\n    event Burn(address caller, uint256 tokenId, uint256 votingPower);\n    event RageQuit(address caller, uint256[] tokenIds, IERC20[] withdrawTokens, address receiver);\n    event PartyCardIntrinsicVotingPowerSet(uint256 indexed tokenId, uint256 intrinsicVotingPower);\n\n    uint40 private constant ENABLE_RAGEQUIT_PERMANENTLY = 0x6b5b567bfe; // uint40(uint256(keccak256(\"ENABLE_RAGEQUIT_PERMANENTLY\")))\n    uint40 private constant DISABLE_RAGEQUIT_PERMANENTLY = 0xab2cb21860; // uint40(uint256(keccak256(\"DISABLE_RAGEQUIT_PERMANENTLY\")))\n\n    // Token address used to indicate ETH.\n    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    // The `Globals` contract storing global configuration values. This contract\n    // is immutable and its address will never change.\n    IGlobals private immutable _GLOBALS;\n\n    /// @notice The number of tokens that have been minted.\n    uint96 public tokenCount;\n    /// @notice The total minted voting power.\n    ///         Capped to `_governanceValues.totalVotingPower` unless minting\n    ///         party cards for initial crowdfund.\n    uint96 public mintedVotingPower;\n    /// @notice The timestamp until which ragequit is enabled. Can be set to the\n    ///         `ENABLE_RAGEQUIT_PERMANENTLY`/`DISABLE_RAGEQUIT_PERMANENTLY`\n    ///         values to enable/disable ragequit permanently.\n    ///         `DISABLE_RAGEQUIT_PERMANENTLY` can only be set during\n    ///         initialization.\n    uint40 public rageQuitTimestamp;\n    /// @notice The voting power of `tokenId`.\n    mapping(uint256 => uint256) public votingPowerByTokenId;\n    /// @notice Address with authority to mint cards and update voting power for the party.\n    mapping(address => bool) public isAuthority;\n\n    function _assertAuthority() internal view {\n        if (!isAuthority[msg.sender]) {\n            revert NotAuthorized();\n        }\n    }\n\n    modifier onlySelf() {\n        if (msg.sender != address(this)) {\n            revert NotAuthorized();\n        }\n        _;\n    }\n\n    // Set the `Globals` contract. The name or symbol of ERC721 does not matter;\n    // it will be set in `_initialize()`.\n    constructor(IGlobals globals) payable PartyGovernance(globals) ERC721(\"\", \"\") {\n        _GLOBALS = globals;\n    }\n\n    // Initialize storage for proxy contracts.\n    function _initialize(\n        string memory name_,\n        string memory symbol_,\n        uint256 customizationPresetId,\n        PartyGovernance.GovernanceOpts memory governanceOpts,\n        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,\n        IERC721[] memory preciousTokens,\n        uint256[] memory preciousTokenIds,\n        address[] memory authorities,\n        uint40 rageQuitTimestamp_\n    ) internal {\n        PartyGovernance._initialize(\n            governanceOpts,\n            proposalEngineOpts,\n            preciousTokens,\n            preciousTokenIds\n        );\n        name = name_;\n        symbol = symbol_;\n        rageQuitTimestamp = rageQuitTimestamp_;\n        unchecked {\n            for (uint256 i; i < authorities.length; ++i) {\n                isAuthority[authorities[i]] = true;\n            }\n        }\n        if (customizationPresetId != 0) {\n            RendererStorage(_GLOBALS.getAddress(LibGlobals.GLOBAL_RENDERER_STORAGE))\n                .useCustomizationPreset(customizationPresetId);\n        }\n    }\n\n    /// @inheritdoc EIP165\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public pure override(PartyGovernance, ERC721, IERC165) returns (bool) {\n        return\n            PartyGovernance.supportsInterface(interfaceId) ||\n            ERC721.supportsInterface(interfaceId) ||\n            interfaceId == type(IERC2981).interfaceId;\n    }\n\n    /// @inheritdoc ERC721\n    function tokenURI(uint256) public view override returns (string memory) {\n        _delegateToRenderer();\n        return \"\"; // Just to make the compiler happy.\n    }\n\n    /// @notice Returns a URI for the storefront-level metadata for your contract.\n    function contractURI() external view returns (string memory) {\n        _delegateToRenderer();\n        return \"\"; // Just to make the compiler happy.\n    }\n\n    /// @notice Called with the sale price to determine how much royalty\n    //          is owed and to whom.\n    function royaltyInfo(uint256, uint256) external view returns (address, uint256) {\n        _delegateToRenderer();\n        return (address(0), 0); // Just to make the compiler happy.\n    }\n\n    /// @notice Return the distribution share amount of a token. Included as an alias\n    ///         for `votePowerByTokenId` for backwards compatibility with old\n    ///         `TokenDistributor` implementations.\n    /// @param tokenId The token ID to query.\n    /// @return share The distribution shares of `tokenId`.\n    function getDistributionShareOf(uint256 tokenId) external view returns (uint256) {\n        return votingPowerByTokenId[tokenId];\n    }\n\n    /// @notice Return the voting power share of a token. Denominated\n    ///         fractions of 1e18. I.e., 1e18 = 100%.\n    /// @param tokenId The token ID to query.\n    /// @return share The voting power percentage of `tokenId`.\n    function getVotingPowerShareOf(uint256 tokenId) public view returns (uint256) {\n        uint256 totalVotingPower = _getSharedProposalStorage().governanceValues.totalVotingPower;\n        return\n            totalVotingPower == 0 ? 0 : (votingPowerByTokenId[tokenId] * 1e18) / totalVotingPower;\n    }\n\n    /// @notice Mint a governance NFT for `owner` with `votingPower` and\n    ///         immediately delegate voting power to `delegate.` Only callable\n    ///         by an authority.\n    /// @param owner The owner of the NFT.\n    /// @param votingPower The voting power of the NFT.\n    /// @param delegate The address to delegate voting power to.\n    function mint(\n        address owner,\n        uint256 votingPower,\n        address delegate\n    ) external returns (uint256 tokenId) {\n        _assertAuthority();\n        uint96 mintedVotingPower_ = mintedVotingPower;\n        uint96 totalVotingPower = _getSharedProposalStorage().governanceValues.totalVotingPower;\n\n        // Cap voting power to remaining unminted voting power supply.\n        uint96 votingPower_ = votingPower.safeCastUint256ToUint96();\n        // Allow minting past total voting power if minting party cards for\n        // initial crowdfund when there is no total voting power.\n        if (totalVotingPower != 0 && totalVotingPower - mintedVotingPower_ < votingPower_) {\n            unchecked {\n                votingPower_ = totalVotingPower - mintedVotingPower_;\n            }\n        }\n\n        // Update state.\n        unchecked {\n            tokenId = ++tokenCount;\n        }\n        mintedVotingPower += votingPower_;\n        votingPowerByTokenId[tokenId] = votingPower_;\n\n        emit PartyCardIntrinsicVotingPowerSet(tokenId, votingPower_);\n\n        // Use delegate from party over the one set during crowdfund.\n        address delegate_ = delegationsByVoter[owner];\n        if (delegate_ != address(0)) {\n            delegate = delegate_;\n        }\n\n        _adjustVotingPower(owner, votingPower_.safeCastUint96ToInt192(), delegate);\n        _safeMint(owner, tokenId);\n    }\n\n    /// @notice Add voting power to an existing NFT. Only callable by an\n    ///         authority.\n    /// @param tokenId The ID of the NFT to add voting power to.\n    /// @param votingPower The amount of voting power to add.\n    function increaseVotingPower(uint256 tokenId, uint96 votingPower) external {\n        _assertAuthority();\n        uint96 mintedVotingPower_ = mintedVotingPower;\n        uint96 totalVotingPower = _getSharedProposalStorage().governanceValues.totalVotingPower;\n\n        // Cap voting power to remaining unminted voting power supply. Allow\n        // minting past total voting power if minting party cards for initial\n        // crowdfund when there is no total voting power.\n        if (totalVotingPower != 0 && totalVotingPower - mintedVotingPower_ < votingPower) {\n            unchecked {\n                votingPower = totalVotingPower - mintedVotingPower_;\n            }\n        }\n\n        // Update state.\n        mintedVotingPower += votingPower;\n        uint256 newIntrinsicVotingPower = votingPowerByTokenId[tokenId] + votingPower;\n        votingPowerByTokenId[tokenId] = newIntrinsicVotingPower;\n\n        emit PartyCardIntrinsicVotingPowerSet(tokenId, newIntrinsicVotingPower);\n\n        _adjustVotingPower(ownerOf(tokenId), votingPower.safeCastUint96ToInt192(), address(0));\n    }\n\n    /// @notice Remove voting power from an existing NFT. Only callable by an\n    ///         authority.\n    /// @param tokenId The ID of the NFT to remove voting power from.\n    /// @param votingPower The amount of voting power to remove.\n    function decreaseVotingPower(uint256 tokenId, uint96 votingPower) external {\n        _assertAuthority();\n        mintedVotingPower -= votingPower;\n        votingPowerByTokenId[tokenId] -= votingPower;\n\n        _adjustVotingPower(ownerOf(tokenId), -votingPower.safeCastUint96ToInt192(), address(0));\n    }\n\n    /// @notice Increase the total voting power of the party. Only callable by\n    ///         an authority.\n    /// @param votingPower The new total voting power to add.\n    function increaseTotalVotingPower(uint96 votingPower) external {\n        _assertAuthority();\n        _getSharedProposalStorage().governanceValues.totalVotingPower += votingPower;\n    }\n\n    /// @notice Decrease the total voting power of the party. Only callable by\n    ///         an authority.\n    /// @param votingPower The new total voting power to add.\n    function decreaseTotalVotingPower(uint96 votingPower) external {\n        _assertAuthority();\n        _getSharedProposalStorage().governanceValues.totalVotingPower -= votingPower;\n    }\n\n    /// @notice Burn governance NFTs and remove their voting power. Can only\n    ///         be called by an authority before the party has started.\n    /// @param tokenIds The IDs of the governance NFTs to burn.\n    function burn(uint256[] memory tokenIds) public {\n        _assertAuthority();\n        _burnAndUpdateVotingPower(tokenIds, false);\n    }\n\n    function _burnAndUpdateVotingPower(\n        uint256[] memory tokenIds,\n        bool checkIfAuthorizedToBurn\n    ) private returns (uint96 totalVotingPowerBurned) {\n        for (uint256 i; i < tokenIds.length; ++i) {\n            uint256 tokenId = tokenIds[i];\n            address owner = ownerOf(tokenId);\n\n            // Check if caller is authorized to burn the token.\n            if (checkIfAuthorizedToBurn) {\n                if (\n                    msg.sender != owner &&\n                    getApproved[tokenId] != msg.sender &&\n                    !isApprovedForAll[owner][msg.sender]\n                ) {\n                    revert NotAuthorized();\n                }\n            }\n\n            // Must be retrieved before updating voting power for token to be burned.\n            uint96 votingPower = votingPowerByTokenId[tokenId].safeCastUint256ToUint96();\n\n            totalVotingPowerBurned += vot"
    }
  ]
}