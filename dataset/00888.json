{
  "Title": "H-2: Incorrect scaling of the spot price",
  "Content": "# Issue H-2: Incorrect scaling of the spot price \n\nSource: https://github.com/sherlock-audit/2023-10-notional-judging/issues/79 \n\n## Found by \nmstpr-brainbot, xiaoming90\n## Summary\n\nThe incorrect scaling of the spot price leads to the incorrect spot price, which is later compared with the oracle price.\n\nIf the spot price is incorrect, it might potentially fail to detect the pool has been manipulated or result in unintended reverts due to false positives. In the worst-case scenario, the trade proceeds to execute against the manipulated pool, leading to a loss of assets.\n\n## Vulnerability Detail\n\nPer the comment and source code at Lines 97 to 103, the `SPOT_PRICE.getComposableSpotPrices` is expected to return the spot price in native decimals.\n\nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/vaults/BalancerComposableAuraVault.sol#L97\n\n```solidity\nFile: BalancerComposableAuraVault.sol\n090:     function _checkPriceAndCalculateValue() internal view override returns (uint256) {\n091:         (uint256[] memory balances, uint256[] memory spotPrices) = SPOT_PRICE.getComposableSpotPrices(\n092:             BALANCER_POOL_ID,\n093:             address(BALANCER_POOL_TOKEN),\n094:             PRIMARY_INDEX()\n095:         );\n096: \n097:         // Spot prices are returned in native decimals, convert them all to POOL_PRECISION\n098:         // as required in the _calculateLPTokenValue method.\n099:         (/* */, uint8[] memory decimals) = TOKENS();\n100:         for (uint256 i; i < spotPrices.length; i++) {\n101:             spotPrices[i] = spotPrices[i] * POOL_PRECISION() / 10 ** decimals[i];\n102:         }\n103: \n104:         return _calculateLPTokenValue(balances, spotPrices);\n105:     }\n```\n\nWithin the `getComposableSpotPrices` function, it will trigger the `_calculateStableMathSpotPrice` function. When the primary and secondary balances are passed into the `StableMath._calculateInvariant` and `StableMath._calcSpotPrice` functions, they are scaled up to 18 decimals precision as StableMath functions only work with balances that have been normalized to 18 decimals.\n\nAssuming that the following states:\n\n- Primary Token = USDC (6 decimals)\n- Secondary Token = DAI (18 decimals)\n- Primary Balance = 100 USDC (=100 * 1e6)\n- Secondary Balance = 100 DAI (=100 * 1e18)\n- scalingFactors[USDC] = 1e12 * Fixed.ONE (1e18) = 1e30\n- scalingFactors[DAI] = 1e0 * Fixed.ONE (1e18) = 1e18\n- The price between USDC and DAI is 1:1\n\nAfter scaling the primary and secondary balances, the scaled balances will be as follows:\n\n```solidity\nscaledPrimary = balances[USDC] * scalingFactors[USDC] / BALANCER_PRECISION\nscaledPrimary = 100 * 1e6 * 1e30 / 1e18\nscaledPrimary = 100 * 1e18\n\nscaledSecondary = balances[DAI] * scalingFactors[DAI] / BALANCER_PRECISION\nscaledSecondary = 100 * 1e18 * 1e18 / 1e18\nscaledSecondary = 100 * 1e18\n```\n\nThe spot price returned from the `StableMath._calcSpotPrice` function at Line 93 will be `1e18` (1:1).\n\nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/BalancerSpotPrice.sol#L93\n\n```solidity\nFile: BalancerSpotPrice.sol\n78:     function _calculateStableMathSpotPrice(\n79:         uint256 ampParam,\n80:         uint256[] memory scalingFactors,\n81:         uint256[] memory balances,\n82:         uint256 scaledPrimary,\n83:         uint256 primaryIndex,\n84:         uint256 index2\n85:     ) internal pure returns (uint256 spotPrice) {\n86:         // Apply scale factors\n87:         uint256 secondary = balances[index2] * scalingFactors[index2] / BALANCER_PRECISION;\n88: \n89:         uint256 invariant = StableMath._calculateInvariant(\n90:             ampParam, StableMath._balances(scaledPrimary, secondary), true // round up\n91:         );\n92: \n93:         spotPrice = StableMath._calcSpotPrice(ampParam, invariant, scaledPrimary, secondary);\n94: \n95:         // Remove scaling factors from spot price\n96:         spotPrice = spotPrice * scalingFactors[primaryIndex] / scalingFactors[index2];\n97:     }\n```\n\nSubsequently, in Line 96 above, the code attempts to remove the scaling factor from the spot price (1e18).\n\n```solidity\nspotPrice = spotPrice * scalingFactors[USDC] / scalingFactors[DAI];\nspotPrice = 1e18 * 1e30 / 1e18\nspotPrice = 1e30\nspotPrice = 1e12 * 1e18\n```\n\nThe `spotPrice[DAI-Secondary]` is not denominated in native precision after the scaling. The `SPOT_PRICE.getComposableSpotPrices` will return the following spot prices:\n\n```solidity\nspotPrice[USDC-Primary] = 0\nspotPrice[DAI-Secondary] = 1e12 * 1e18\n```\n\nThe returned spot prices will be scaled to POOL_PRECISION (1e18). After the scaling, the spot price remains the same:\n\n```solidity\nspotPrice[DAI-Secondary] = spotPrice[DAI-Secondary] * POOL_PRECISION / DAI_Decimal\nspotPrice[DAI-Secondary] = 1e12 * 1e18 * 1e18 / 1e18\nspotPrice[DAI-Secondary] = 1e12 * 1e18\n```\n\nThe converted spot prices will be passed into the `_calculateLPTokenValue` function. Within the `_calculateLPTokenValue` function, the oracle price for DAI<>USDC will be `1e18`. From here, the `spotPrice[DAI-Secondary]` (1e12 * 1e18) is significantly different from the oracle price (1e18), which will cause the [pool manipulation check](https://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/vaults/common/SingleSidedLPVaultBase.sol#L353) to revert.\n\nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/vaults/BalancerComposableAuraVault.sol#L97\n\n```solidity\nFile: BalancerComposableAuraVault.sol\n090:     function _checkPriceAndCalculateValue() internal view override returns (uint256) {\n091:         (uint256[] memory balances, uint256[] memory spotPrices) = SPOT_PRICE.getComposableSpotPrices(\n092:             BALANCER_POOL_ID,\n093:             address(BALANCER_POOL_TOKEN),\n094:             PRIMARY_INDEX()\n095:         );\n096: \n097:         // Spot prices are returned in native decimals, convert them all to POOL_PRECISION\n098:         // as required in the _calculateLPTokenValue method.\n099:         (/* */, uint8[] memory decimals) = TOKENS();\n100:         for (uint256 i; i < spotPrices.length; i++) {\n101:             spotPrices[i] = spotPrices[i] * POOL_PRECISION() / 10 ** decimals[i];\n102:         }\n103: \n104:         return _calculateLPTokenValue(balances, spotPrices);\n105:     }\n```\n\n## Impact\n\nThe spot price is used to verify if the pool has been manipulated before executing certain key vault actions (e.g. reinvest rewards). \n\nIf the spot price is incorrect, it might potentially result in the following:\n\n- Failure to detect the pool has been manipulated, resulting in the trade to execute against the manipulated pool, leading to a loss of assets.\n- Unintended reverts due to false positives, breaking core functionalities of the protocol that rely on the `_checkPriceAndCalculateValue` function.\n\nThe affected `_checkPriceAndCalculateValue` function was found to be used within the following functions:\n\n- `reinvestReward` - If the `_checkPriceAndCalculateValue` function is malfunctioning or reverts unexpectedly, the protocol will not be able to reinvest, leading to a loss of value for the vault shareholders.\n\n- `convertStrategyToUnderlying` - This function is used by Notional V3 for the purpose of computing the collateral values and the account's health factor. If the `_checkPriceAndCalculateValue` function reverts unexpectedly due to an incorrect invariant/spot price, many of Notional's core functions will break. In addition, the collateral values and the account's health factor might be inflated if it fails to detect a manipulated pool due to incorrect invariant/spot price, potentially allowing the malicious actors to drain the main protocol.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/vaults/BalancerComposableAuraVault.sol#L97\n\nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/BalancerSpotPrice.sol#L93\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe spot price returned from `StableMath._calcSpotPrice` is denominated in 1e18 (POOL_PRECISION) since the inputted balances are normalized to 18 decimals. The scaling factors are used to normalize a balance to 18 decimals. By dividing or scaling down the spot price by the scaling factor, the native spot price will be returned.\n\n```solidity\nspotPrice[DAI-Secondary] = spotPrice[DAI-Secondary] * Fixed.ONE / scalingFactors[DAI];\nspotPrice = 1e18 * Fixed.ONE / (1e0 * Fixed.ONE)\nspotPrice = 1e18 * 1e18 / (1e0 * 1e18)\nspotPrice = 1e18\n```\n\n\n\n## Discussion\n\n**jeffywu**\n\nValid issue\n\n**jeffywu**\n\nhttps://github.com/notional-finance/leveraged-vaults/pull/63\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/119",
  "Code": [
    {
      "filename": "leveraged-vaults/contracts/vaults/BalancerComposableAuraVault.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {NotionalProxy} from \"../../interfaces/notional/NotionalProxy.sol\";\nimport {Deployments} from \"../global/Deployments.sol\";\nimport {BalancerSpotPrice} from \"./balancer/BalancerSpotPrice.sol\";\nimport {\n    AuraStakingMixin,\n    AuraVaultDeploymentParams,\n    DeploymentParams\n} from \"./balancer/mixins/AuraStakingMixin.sol\";\nimport {IComposablePool} from \"../../interfaces/balancer/IBalancerPool.sol\";\nimport {IBalancerVault} from \"../../interfaces/balancer/IBalancerVault.sol\";\n\ncontract BalancerComposableAuraVault is AuraStakingMixin {\n    /// @notice Helper singleton function to calculate spot prices\n    BalancerSpotPrice immutable SPOT_PRICE;\n\n    constructor(\n        NotionalProxy notional_,\n        AuraVaultDeploymentParams memory params,\n        BalancerSpotPrice _spotPrice\n    ) AuraStakingMixin(notional_, params) {\n        // BPT_INDEX must be defined for a composable pool\n        require(BPT_INDEX != NOT_FOUND);\n        SPOT_PRICE = _spotPrice;\n    }\n\n    /// @notice strategy identifier\n    function strategy() external override pure returns (bytes4) {\n        return bytes4(keccak256(\"BalancerComposableAuraVault\"));\n    }\n\n    function _joinPoolAndStake(\n        uint256[] memory amounts, uint256 minPoolClaim\n    ) internal override returns (uint256 lpTokens) {\n        // Composable pool custom data does not include the BPT token amount so \n        // we loop here to remove it from the customData\n        uint256[] memory amountsWithoutBpt = new uint256[](amounts.length - 1);\n        uint256 j;\n        for (uint256 i; i < amounts.length; i++) {\n            if (i == BPT_INDEX) continue;\n            amountsWithoutBpt[j] = amounts[i];\n            j++;\n        }\n\n        bytes memory customData = abi.encode(\n            IBalancerVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,\n            amountsWithoutBpt,\n            minPoolClaim\n        );\n\n        lpTokens = _joinPoolExactTokensIn(amounts, customData);\n\n        // Transfer token to Aura protocol for boosted staking\n        bool success = AURA_BOOSTER.deposit(AURA_POOL_ID, lpTokens, true);\n        require(success);\n    }\n\n    function _unstakeAndExitPool(\n        uint256 poolClaim, uint256[] memory minAmounts, bool isSingleSided\n    ) internal override returns (uint256[] memory exitBalances) {\n        bool success = AURA_REWARD_POOL.withdrawAndUnwrap(poolClaim, false); // claimRewards = false\n        require(success);\n\n        bytes memory customData;\n        if (isSingleSided) {\n            // See this line here:\n            // https://github.com/balancer/balancer-v2-monorepo/blob/c7d4abbea39834e7778f9ff7999aaceb4e8aa048/pkg/pool-stable/contracts/ComposableStablePool.sol#L927\n            // While \"assets\" sent to the vault include the BPT token the tokenIndex passed in by this\n            // function does not include the BPT. primaryIndex in this code is inclusive of the BPT token in\n            // the assets array. Therefore, if primaryIndex > bptIndex subtract one to ensure that the primaryIndex\n            // does not include the BPT token here.\n            uint256 primaryIndex = PRIMARY_INDEX();\n            customData = abi.encode(\n                IBalancerVault.ComposableExitKind.EXACT_BPT_IN_FOR_ONE_TOKEN_OUT,\n                poolClaim,\n                primaryIndex < BPT_INDEX ?  primaryIndex : primaryIndex - 1\n            );\n        } else {\n            customData = abi.encode(\n                IBalancerVault.ComposableExitKind.EXACT_BPT_IN_FOR_ALL_TOKENS_OUT,\n                poolClaim\n            );\n        }\n\n        exitBalances = _exitPoolExactBPTIn(minAmounts, customData);\n    }\n \n    function _checkPriceAndCalculateValue() internal view override returns (uint256) {\n        (uint256[] memory balances, uint256[] memory spotPrices) = SPOT_PRICE.getComposableSpotPrices(\n            BALANCER_POOL_ID,\n            address(BALANCER_POOL_TOKEN),\n            PRIMARY_INDEX()\n        );\n\n        // Spot prices are returned in native decimals, convert them all to POOL_PRECISION\n        // as required in the _calculateLPTokenValue method.\n        (/* */, uint8[] memory decimals) = TOKENS();\n        for (uint256 i; i < spotPrices.length; i++) {\n            spotPrices[i] = spotPrices[i] * POOL_PRECISION() / 10 ** decimals[i];\n        }\n\n        return _calculateLPTokenValue(balances, spotPrices);\n    }\n\n    /// @notice Composable pools have a different method to get the total supply\n    function _totalPoolSupply() internal view override returns (uint256) {\n        return IComposablePool(address(BALANCER_POOL_TOKEN)).getActualSupply();\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/BalancerSpotPrice.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport \"forge-std/console.sol\";\nimport {Deployments} from \"../../global/Deployments.sol\";\nimport {StableMath} from \"./math/StableMath.sol\";\nimport {IComposablePool, IWeightedPool} from \"../../../interfaces/balancer/IBalancerPool.sol\";\nimport {IBalancerVault} from \"../../../interfaces/balancer/IBalancerVault.sol\";\n\n/**\n * @notice External, singleton helper contract deployed to calculate spot prices for Balancer pools.\n * Currently supports Composable pools with any number of tokens and Weighted2Token pools.\n */\ncontract BalancerSpotPrice {\n    uint256 internal constant BALANCER_PRECISION = 1e18;\n\n    /// @notice Returns the weighted pool spot price and balances. Only the spot price on the\n    /// secondary token is returned.\n    function getWeightedSpotPrices(\n        bytes32 poolId,\n        address poolAddress,\n        uint256 primaryIndex,\n        uint8 primaryDecimals\n    ) external view returns (uint256[] memory balances, uint256[] memory spotPrices) {\n        (/* */, balances, /* */) = Deployments.BALANCER_VAULT.getPoolTokens(poolId);\n        // Only two token pools are supported\n        require(balances.length == 2);\n        spotPrices = new uint256[](2);\n\n        uint256[] memory weights = IWeightedPool(poolAddress).getNormalizedWeights();\n\n        // Spot price calculation is specified at the link below. Do not account for swap fees\n        // because we're using this price to compare to the oracle price and adding swap fees\n        // would unnecessarily increase the price deviation.\n        // https://docs.balancer.fi/reference/math/weighted-math.html#typescript\n        // secondaryBalance * primaryWeight * primaryDecimals \n        // --------------------------------------------------- \n        //          primaryBalance * secondaryWeight\n        uint256 secondaryIndex = 1 - primaryIndex;\n\n        // There is a chance of a uint256 overflow if the balances[secondaryIndex] > 10**36\n        uint256 numerator = balances[secondaryIndex] * weights[primaryIndex] * (10 ** primaryDecimals);\n        uint256 denominator = balances[primaryIndex] * weights[secondaryIndex];\n        spotPrices[secondaryIndex] = numerator / denominator;\n    }\n\n    /// @notice Returns the composable pool spot price and balances. Pool token spot\n    /// prices are not returned, pool token balance is returned.\n    function getComposableSpotPrices(\n        bytes32 poolId,\n        address poolAddress,\n        uint256 primaryIndex\n    ) external view returns (uint256[] memory balances, uint256[] memory spotPrices) {\n        address[] memory tokens;\n        (tokens, balances, /* */) = Deployments.BALANCER_VAULT.getPoolTokens(poolId);\n        uint256[] memory scalingFactors = IComposablePool(poolAddress).getScalingFactors();\n\n        (\n            uint256 ampParam,\n            /* bool isUpdating */,\n            uint256 precision\n        ) = IComposablePool(poolAddress).getAmplificationParameter();\n        require(precision == StableMath._AMP_PRECISION);\n\n        // The primary index spot price is left as zero.\n        spotPrices = new uint256[](tokens.length);\n        uint256 scaledPrimary = balances[primaryIndex] * scalingFactors[primaryIndex] / BALANCER_PRECISION;\n        for (uint256 i; i < tokens.length; i++) {\n            if (i == primaryIndex) continue;\n            if (tokens[i] == poolAddress) continue;\n\n            spotPrices[i] = _calculateStableMathSpotPrice(\n                ampParam, scalingFactors, balances, scaledPrimary, primaryIndex, i\n            );\n        }\n    }\n\n    function _calculateStableMathSpotPrice(\n        uint256 ampParam,\n        uint256[] memory scalingFactors,\n        uint256[] memory balances,\n        uint256 scaledPrimary,\n        uint256 primaryIndex,\n        uint256 index2\n    ) internal pure returns (uint256 spotPrice) {\n        // Apply scale factors\n        uint256 secondary = balances[index2] * scalingFactors[index2] / BALANCER_PRECISION;\n\n        uint256 invariant = StableMath._calculateInvariant(\n            ampParam, StableMath._balances(scaledPrimary, secondary), true // round up\n        );\n\n        spotPrice = StableMath._calcSpotPrice(ampParam, invariant, scaledPrimary, secondary);\n\n        // Remove scaling factors from spot price\n        spotPrice = spotPrice * scalingFactors[primaryIndex] / scalingFactors[index2];\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/common/SingleSidedLPVaultBase.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\";\n\nimport {BaseStrategyVault} from \"./BaseStrategyVault.sol\";\nimport {Errors} from \"../../global/Errors.sol\";\nimport {Constants} from \"../../global/Constants.sol\";\nimport {TypeConvert} from \"../../global/TypeConvert.sol\";\nimport {TokenUtils} from \"../../utils/TokenUtils.sol\";\nimport {StrategyUtils} from \"./StrategyUtils.sol\";\nimport {VaultStorage} from \"./VaultStorage.sol\";\n\nimport {IERC20} from \"../../../interfaces/IERC20.sol\";\nimport {\n    ISingleSidedLPStrategyVault,\n    StrategyVaultSettings,\n    InitParams,\n    StrategyVaultState,\n    SingleSidedRewardTradeParams,\n    DepositParams,\n    DepositTradeParams,\n    RedeemParams,\n    TradeParams\n} from \"../../../interfaces/notional/ISingleSidedLPStrategyVault.sol\";\nimport {NotionalProxy} from \"../../../interfaces/notional/NotionalProxy.sol\";\nimport {ITradingModule, DexId} from \"../../../interfaces/trading/ITradingModule.sol\";\n\n/**\n * @notice Base contract for the SingleSidedLP strategy. This strategy deposits into an LP\n * pool given a single borrowed currency. Allows for users to trade via external exchanges\n * during entry and exit, but the general expected behavior is single sided entries and\n * exits. Inheriting contracts will fill in the implementation details for integration with\n * the external DEX pool.\n */\nabstract contract SingleSidedLPVaultBase is BaseStrategyVault, UUPSUpgradeable, ISingleSidedLPStrategyVault {\n    using TypeConvert for uint256;\n    using VaultStorage for StrategyVaultState;\n\n    uint256 internal constant MAX_TOKENS = 5;\n    uint8 internal constant NOT_FOUND = type(uint8).max;\n    /// @notice Bit mask for the 'LOCKED\" flag big\n    uint32 internal constant FLAG_LOCKED = 1 << 0;\n\n    /************************************************************************\n     * VIRTUAL FUNCTIONS                                                    *\n     * These virtual functions are used to isolate implementation specific  *\n     * behavior.                                                            *\n     ************************************************************************/\n\n    /// @notice Total number of tokens held by the LP token\n    function NUM_TOKENS() internal view virtual returns (uint256);\n\n    /// @notice Addresses of tokens held and decimal places of each token. ETH will always be\n    /// recorded in this array as Deployments.ETH_Address\n    function TOKENS() internal view virtual returns (IERC20[] memory, uint8[] memory decimals);\n\n    /// @notice Address of the LP token\n    function POOL_TOKEN() internal view virtual returns (IERC20);\n\n    /// @notice Index of the TOKENS() array that refers to the primary borrowed currency by the\n    /// leveraged vault. All valuations are done in terms of this currency.\n    function PRIMARY_INDEX() internal view virtual returns (uint256);\n\n    /// @notice Precision (i.e. 10 ** decimals) of the LP token.\n    function POOL_PRECISION() internal view virtual returns (uint256);\n\n    /// @notice Returns the value of one LP token in terms of the primary borrowed currency by this\n    /// strategy. Will revert if the spot price on the pool is not within some deviation tolerance of\n    /// the implied oracle price. This is intended to prevent any pool manipulation.\n    /// The value of the LP token is calculated as the value of the token if all the balance claims are\n    /// withdrawn proportionally and then converted to the primary currency at the oracle price. Slippage\n    /// from selling the tokens is not considered, any slippage effects will be captured by the maximum\n    /// leverage ratio allowed before liquidation.\n    function _checkPriceAndCalculateValue() internal view virtual returns (uint256 oneLPValueInPrimary);\n\n    /// @notice Called once during initialization to set the initial token approvals.\n    function _initialApproveTokens() internal virtual;\n\n    /// @notice Called to claim reward tokens\n    function _claimRewardTokens() internal virtual;\n\n    /// @notice Called during reward reinvestment to validate that the token being sold is not one\n    /// of the tokens that is required for the vault to function properly (i.e. one of the pool tokens\n    /// or any of the reward booster tokens).\n    function _isInvalidRewardToken(address token) internal view virtual returns (bool);\n\n    /// @notice Implementation specific wrapper for joining a pool with the given amounts. Will also\n    /// stake on the relevant booster protocol.\n    function _joinPoolAndStake(\n        uint256[] memory amounts, uint256 minPoolClaim\n    ) internal virtual returns (uint256 lpTokens);\n\n    /// @notice Implementation specific wrapper for unstaking from the booster protocol and withdrawing\n    /// funds from the LP pool\n    function _unstakeAndExitPool(\n        uint256 poolClaim, uint256[] memory minAmounts, bool isSingleSided\n    ) internal virtual returns (uint256[] memory exitBalances);\n\n    /// @notice Returns the total supply of the pool token. Is a virtual function because\n    /// ComposableStablePools use a \"virtual supply\" and a different method must be called\n    /// to get the actual total supply.\n    function _totalPoolSupply() internal view virtual returns (uint256) {\n        return POOL_TOKEN().totalSupply();\n    }\n\n    /************************************************************************\n     * CLASS FUNCTIONS                                                      *\n     * Below are class functions that represent the base implementation     *\n     * of the Single Sided LP strategy.                                     *\n     ************************************************************************/\n\n    constructor(NotionalProxy notional_, ITradingModule tradingModule_)\n        BaseStrategyVault(notional_, tradingModule_) {}\n\n    /************************************************************************\n     * EXTERNAL VIEW FUNCTIONS                                              *\n     ************************************************************************/\n\n    /// @notice Returns basic information about the vault for use in the user interface.\n    function getStrategyVaultInfo() external view override returns (SingleSidedLPStrategyVaultInfo memory) {\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n        return SingleSidedLPStrategyVaultInfo({\n            pool: address(POOL_TOKEN()),\n            singleSidedTokenIndex: uint8(PRIMARY_INDEX()),\n            totalLPTokens: state.totalPoolClaim,\n            totalVaultShares: state.totalVaultSharesGlobal\n        });\n    }\n\n    /// @notice Returns the current locked status of the vault\n    function isLocked() public view returns (bool) {\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n        return _hasFlag(state.flags, FLAG_LOCKED);\n    }\n\n    /// @notice Returns the current price of a vault share, even when there are no vault shares\n    /// in the strategy. Used by the user interface to collect historical valuation information.\n    function getExchangeRate(uint256 /* maturity */) external view override returns (int256) {\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n        uint256 oneLPValueInPrimary = _checkPriceAndCalculateValue();\n        // If inside an emergency exit, just report the one LP value in primary since the total\n        // pool claim will be 0\n        if (state.totalVaultSharesGlobal == 0 || isLocked()) {\n            return oneLPValueInPrimary.toInt();\n        } else {\n            uint256 lpTokensPerVaultShare = (uint256(Constants.INTERNAL_TOKEN_PRECISION) * state.totalPoolClaim)\n                / state.totalVaultSharesGlobal;\n            return (oneLPValueInPrimary * lpTokensPerVaultShare / POOL_PRECISION()).toInt();\n        }\n    }\n\n    /************************************************************************\n     * ADMIN FUNCTIONS                                                      *\n     * Administrative functions to set settings and initialize the vault.   *\n     * These methods are only callable by the Notional owner.               *\n     ************************************************************************/\n\n    /// @notice Allow Notional owner to upgrade the contract\n    function _authorizeUpgrade(\n        address /* newImplementation */\n    ) internal override onlyNotionalOwner {}\n\n    /// @notice Updates the vault settings include the maximum oracle deviation limit and the\n    /// maximum percent of the LP pool that the vault can hold.\n    function setStrategyVaultSettings(StrategyVaultSettings calldata settings) external onlyNotionalOwner {\n        // Validation occurs inside this method\n        VaultStorage.setStrategyVaultSettings(settings);\n    }\n\n    /// @notice Called to initialize the vault and set the initial approvals. All of the other vault\n    /// parameters are set via immutable parameters already.\n    function initialize(InitParams calldata params) external override initializer onlyNotionalOwner {\n        // Initialize the base vault\n        __INIT_VAULT(params.name, params.borrowCurrencyId);\n\n        // Settings are validated in setStrategyVaultSettings\n        VaultStorage.setStrategyVaultSettings(params.settings);\n\n        _initialApproveTokens();\n    }\n\n    /************************************************************************\n     * USER FUNCTIONS                                                       *\n     * These functions are called during normal usage of the vault.         *\n     * They allow for deposits and redemptions from the vault as well as a  *\n     * valuation check that is used by Notional to determine if the user is *\n     * properly collateralized.                                             *\n     ************************************************************************/\n\n    /// @notice This is a virtual function called by BaseStrategyVault which ensures that\n    /// this method is only called by Notional after an initial borrow has been made and\n    /// the deposit amount has been transferred to this vault. Will join the LP pool with\n    /// the funds given and then return the total vault shares minted.\n    function _depositFromNotional(\n        address /* account */, uint256 deposit, uint256 /* maturity */, bytes calldata data\n    ) internal override whenNotLocked returns (uint256 vaultSharesMinted) {\n        // Short circuit any zero deposit amounts\n        if (deposit == 0) return 0;\n\n        DepositParams memory params = abi.decode(data, (DepositParams));\n        uint256[] memory amounts = new uint256[](NUM_TOKENS());\n        amounts[PRIMARY_INDEX()] = deposit;\n\n        // If depositTrades are specified, then parts of the initial deposit are traded\n        // for corresponding amounts of the other pool tokens via external exchanges. If\n        // these amounts are not specified then the pool will just be joined single sided.\n        // Deposit trades are not automatically enabled on vaults since the trading module\n        // requires explicit permission for every token that can be sold by an address.\n        if (params.depositTrades.length > 0) {\n            (IERC20[] memory tokens, /* */) = TOKENS();\n            // This is an external library call so the memory location of amounts is\n            // different before and after the call.\n            amounts = StrategyUtils.executeDepositTrades(\n                tokens,\n                amounts,\n                params.depositTrades,\n                PRIMARY_INDEX()\n            );\n        }\n\n        uint256 lpTokens = _joinPoolAndStake(amounts, params.minPoolClaim);\n        return _mintVaultShares(lpTokens);\n    }\n\n    /// @notice Given a number of LP tokens minted, issues vault shares back to the holder. Vault\n    /// shares are claim on the LP tokens held by the vault. As rewards are reinvested, one vault\n    /// share is a claim on an increasing amount of LP tokens.\n    function _mintVaultShares(uint256 lpTokens) internal returns (uint256 vaultShares) {\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n        if (state.totalPoolClaim == 0) {\n            // Vault Shares are in 8 decimal precision\n            vaultShares = (lpTokens * uint256(Constants.INTERNAL_TOKEN_PRECISION)) / POOL_PRECISION();\n        } else {\n            vaultShares = (lpTokens * state.totalVaultSharesGlobal) / state.totalPoolClaim;\n        }\n\n        // Updates internal storage here\n        state.totalPoolClaim += lpTokens;\n        state.totalVaultSharesGlobal += vaultShares.toUint80();\n        state.setStrategyVaultState();\n\n        // Checks that the vault does not own too large of a portion of the pool. If this is the case,\n        // single sided exits may have a detrimental effect on the liquidity.\n        uint256 maxPoolShare = VaultStorage.getStrategyVaultSettings().maxPoolShare;\n        uint256 maxSupplyThreshold = (_totalPoolSupply() * maxPoolShare) / Constants.VAULT_PERCENT_BASIS;\n        if (maxSupplyThreshold < state.totalPoolClaim)\n            revert Errors.PoolShareTooHigh(state.totalPoolClaim, maxSupplyThreshold);\n    }\n\n    /// @notice This is a virtual function called by BaseStrategyVault which ensures that\n    /// this method is only called by Notional after an initial position has been made. Will\n    /// withdraw the LP tokens from the pool, either single sided or proportionally. On a\n    /// proportional exit, will trade all the tokens back to the primary in order to exit the pool.\n    /// @return finalPrimaryBalance which is the amount of funds that the vault will transfer back\n    /// to Notional and the account to repay debts and withdraw profits.\n    function _redeemFromNotional(\n        address /* account */, uint256 vaultShares, uint256 /* maturity */, bytes calldata data\n    ) internal override whenNotLocked returns (uint256 finalPrimaryBalance) {\n        // Short circuit any zero redemption amounts, this can occur during rolling positions\n        // or withdraw cash balances post liquidation.\n        if (vaultShares == 0) return 0;\n\n        // Updates internal account to deduct the vault shares.\n        uint256 poolClaim = _redeemVaultShares(vaultShares);\n        RedeemParams memory params = abi.decode(data, (RedeemParams));\n\n        bool isSingleSided = params.redemptionTrades.length == 0;\n        // Returns the amount of each token that has been withdrawn from the pool.\n        uint256[] memory exitBalances = _unstakeAndExitPool(poolClaim, params.minAmounts, isSingleSided);\n        if (!isSingleSided) {\n            // If not a single sided trade, will execute trades back to the primary token on\n            // external exchanges. This method will execute EXACT_IN trades to ensure that\n            // all of the balance in the other tokens is sold for primary.\n            (IERC20[] memory tokens, /* */) = TOKENS();\n            // Redemption trades are not automatically enabled on vaults since the trading module\n            // requires explicit permission for every token that can be sold by an address.\n            return StrategyUtils.executeRedemptionTrades(\n                tokens,\n                exitBalances,\n                params.redemptionTrades,\n                PRIMARY_INDEX()\n            );\n        } else {\n            // No explicit check is done here to ensure that the other balances are zero, assumed\n            // that the `_unstakeAndExitPool` method on the implementation is correct and will only\n            // ever withdraw to a single balance.\n            return exitBalances[PRIMARY_INDEX()];\n        }\n    }\n\n    /// @notice Updates internal account for vault share redemption.\n    function _redeemVaultShares(uint256 vaultShares) internal returns (uint256 poolClaim) {\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n        // Will revert on divide by zero, which is the correct behavior\n        poolClaim = (vaultShares * state.totalPoolClaim) / state.totalVaultSharesGlobal;\n\n        state.totalPoolClaim -= poolClaim;\n        // Will revert on underflow if vault shares is greater than total shares global\n        state.totalVaultSharesGlobal -= vaultShares.toUint80();\n        state.setStrategyVaultState();\n    }\n\n    /// @notice Converts the vault shares to an oracle value in underlying tokens. Used by Notional\n    /// to determine the collateral position of a vault user. If the vault is locked due to an\n    /// emergency exit, this function will revert which will prevent users from entering, exiting,\n    /// and being liquidated. During emergency exit, the vault will not be holding any LP tokens and\n    /// therefore this calculation will not be correct.\n    function convertStrategyToUnderlying(\n        address /* */, uint256 vaultShares, uint256 /* */\n    ) public view override whenNotLocked returns (int256 underlyingValue) {\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n        // Will revert on divide by zero, which is the correct behavior\n        uint256 lpTokens = (vaultShares * state.totalPoolClaim) / state.totalVaultSharesGlobal;\n        uint256 oneLPValueInPrimary = _checkPriceAndCalculateValue();\n\n        return (oneLPValueInPrimary * lpTokens / POOL_PRECISION()).toInt();\n    }\n\n    /// @notice Returns the pair price of two tokens via the TRADING_MODULE which holds a registry\n    /// of oracles. Will revert of the oracle pair is not listed.\n    function _getOraclePairPrice(address base, address quote) internal view returns (uint256) {\n        (int256 rate, int256 precision) = TRADING_MODULE.getOraclePrice(base, quote);\n        require(rate > 0);\n        require(precision > 0);\n        return uint256(rate) * POOL_PRECISION() / uint256(precision);\n    }\n\n    /// @notice Helper method called by _checkPriceAndCalculateValue which will supply the relevant\n    /// pool balances and spot prices. Calculates the claim of one LP token on relevant pool balances\n    /// and compares the oracle price to the spot price, reverting if the deviation is too high.\n    /// @return oneLPValueInPrimary the value of one LP token in terms of the primary borrowed currency\n    function _calculateLPTokenValue(\n        uint256[] memory balances,\n        uint256[] memory spotPrices\n    ) internal view returns (uint256 oneLPValueInPrimary) {\n        (IERC20[] memory tokens, uint8[] memory decimals) = TOKENS();\n        address primaryToken = address(tokens[PRIMARY_INDEX()]);\n        uint256 primaryDecimals = 10 ** decimals[PRIMARY_INDEX()];\n        uint256 totalSupply = _totalPoolSupply();\n        uint256 limit = VaultStorage.getStrategyVaultSettings().oraclePriceDeviationLimitPercent;\n\n        for (uint256 i; i < tokens.length; i++) {\n            // Skip the pool token if it is in the token list (i.e. ComposablePools)\n            if (address(tokens[i]) == address(POOL_TOKEN())) continue;\n            // This is the claim on the pool balance of 1 LP token.\n            uint256 tokenClaim = balances[i] * POOL_PRECISION() / totalSupply;\n            if (i == PRIMARY_INDEX()) {\n                oneLPValueInPrimary += tokenClaim;\n            } else {\n                uint256 price = _getOraclePairPrice(primaryToken, address(tokens[i]));\n\n                // Check that the spot price and the oracle price are near each other. If this is\n                // not true then we assume that the LP pool is being manipulated.\n                uint256 lowerLimit = price * (Constants.VAULT_PERCENT_BASIS - limit) / Constants.VAULT_PERCENT_BASIS;\n                uint256 upperLimit = price * (Constants.VAULT_PERCENT_BASIS + limit) / Constants.VAULT_PERCENT_BASIS;\n                if (spotPrices[i] < lowerLimit || upperLimit < spotPrices[i]) {\n                    revert Errors.InvalidPrice(price, spotPrices[i]);\n                }\n\n                // Convert the token claim to primary using the oracle pair price.\n                uint256 secondaryDecimals = 10 ** decimals[i];\n                oneLPValueInPrimary += (tokenClaim * POOL_PRECISION() * primaryDecimals) / \n                    (price * secondaryDecimals);\n            }\n        }\n    }\n\n    /************************************************************************\n     * REWARD REINVESTMENT                                                  *\n     * Methods used by bots to claim reward tokens and reinvest them as LP  *\n     * tokens which are donated to all vault users.                         *\n     ************************************************************************/\n\n    /// @notice Ensures that only whitelisted bots can claim reward tokens.\n    function claimRewardTokens() external override onlyRole(REWARD_REINVESTMENT_ROLE) {\n        _claimRewardTokens();\n    }\n\n    /// @notice Ensures that only whitelisted bots can reinvest rewards. Since rewards\n    /// are typically less liquid than pool tokens and lack oracles, reward reinvestment\n    /// is done using explicitly set slippage limits by the reinvestment bots. Reinvestment\n    /// will fail if the spot prices are not close to the oracle prices to ensure that\n    /// there is no front running the reinvestment.\n    function reinvestReward(\n        SingleSidedRewardTradeParams[] calldata trades,\n        uint256 minPoolClaim\n    ) external whenNotLocked onlyRole(REWARD_REINVESTMENT_ROLE) returns (\n        address rewardToken,\n        uint256 amountSold,\n        uint256 poolClaimAmount\n    ) {\n        // Will revert if spot prices are not in line with the oracle values\n        _checkPriceAndCalculateValue();\n\n        // Require one trade per token, if we do not want to buy any tokens at a\n        // given index then the amount should be set to zero. This applies to pool\n        // tokens like in the ComposableStablePool.\n        require(trades.length == NUM_TOKENS());\n        uint256[] memory amounts;\n        (rewardToken, amountSold, amounts) = _executeRewardTrades(trades);\n\n        poolClaimAmount = _joinPoolAndStake(amounts, minPoolClaim);\n\n        // Increase LP token amount without minting additional vault shares\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n        state.totalPoolClaim += poolClaimAmount;\n        state.setStrategyVaultState();\n\n        emit RewardReinvested(rewardToken, amountSold, poolClaimAmount);\n    }\n\n    function _executeRewardTrades(SingleSidedRewardTradeParams[] calldata trades) internal returns (\n        address rewardToken,\n        uint256 amountSold,\n        uint256[] memory amounts\n    ) {\n        // The sell token on all trades must be the same (checked inside executeRewardTrades) so\n        // just validate here that the sellToken is a valid reward token (i.e. none of the tokens\n        // used in the regular functioning of the vault).\n        rewardToken = trades[0].sellToken;\n        if (_isInvalidRewardToken(rewardToken)) revert Errors.InvalidRewardToken(rewardToken);\n        (IERC20[] memory tokens, /* */) = TOKENS();\n        (amounts, amountSold) = StrategyUtils.executeRewardTrades(\n            tokens, trades, rewardToken, address(POOL_TOKEN())\n        );\n    }\n\n    /************************************************************************\n     * EMERGENCY EXIT                                                       *\n     * In case of an emergency, will allow a whitelisted guardian to exit   *\n     * funds on the vault and locks the vault from further usage. The owner *\n     * can restore funds to the LP pool a"
    }
  ]
}