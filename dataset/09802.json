{
  "Title": "[M-16] Inappropriate support of EIP-2981",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/contracts/mixins/NFTMarketCreators.sol#L65-L82\n\n\n# Vulnerability details\n\nhttps://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/contracts/mixins/NFTMarketCreators.sol#L65-L82\n\n```solidity\nif (nftContract.supportsERC165Interface(type(IRoyaltyInfo).interfaceId)) {\n  try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (\n    address receiver,\n    uint256 /* royaltyAmount */\n  ) {\n    if (receiver != address(0)) {\n      recipients = new address payable[](1);\n      recipients[0] = payable(receiver);\n      // splitPerRecipientInBasisPoints is not relevant when only 1 recipient is defined\n      if (receiver == seller) {\n        return (recipients, splitPerRecipientInBasisPoints, true);\n      }\n    }\n  } catch // solhint-disable-next-line no-empty-blocks\n  {\n    // Fall through\n  }\n}\n```\n\nThe current implementation of EIP-2981 support will always pass a constant `BASIS_POINTS` as the `_salePrice`.\n\nAs a result, the recipients that are supposed to receive less than 1 BPS of the salePrice may end up not receiving any royalties.\n\nFurthermore, for the NFTs with the total royalties rate set less than 10% for some reason, the current implementation will scale it up to 10%.\n\n### Recommendation\n\n1. Instead of passing a constant of 10,000 as the `_salePrice`, we suggest using the actual `_salePrice`, so there the royalties can be paid for recipients with less than 1 BPS of the royalties.\n2. When the total royalties cut is lower than 10%, it should be honored.  it's capped at 10% only when the total royalties cut is higher than 10%.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-02-foundation-contest",
  "Code": [
    {
      "filename": "contracts/mixins/NFTMarketCreators.sol",
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport \"./OZ/ERC165Checker.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"./Constants.sol\";\n\nimport \"../interfaces/IGetFees.sol\";\nimport \"../interfaces/IGetRoyalties.sol\";\nimport \"../interfaces/IOwnable.sol\";\nimport \"../interfaces/IRoyaltyInfo.sol\";\nimport \"../interfaces/ITokenCreator.sol\";\nimport \"@manifoldxyz/royalty-registry-solidity/contracts/IRoyaltyRegistry.sol\";\n\nerror NFTMarketCreators_Address_Does_Not_Support_IRoyaltyRegistry();\n\n/**\n * @title A mixin for associating creators to NFTs.\n * @dev In the future this may store creators directly in order to support NFTs created on a different platform.\n */\nabstract contract NFTMarketCreators is\n  Constants,\n  ReentrancyGuardUpgradeable // Adding this unused mixin to help with linearization\n{\n  using ERC165Checker for address;\n\n  IRoyaltyRegistry private immutable royaltyRegistry;\n\n  /**\n   * @notice Configures the registry allowing for royalty overrides to be defined.\n   * @param _royaltyRegistry The registry to use for royalty overrides.\n   */\n  constructor(address _royaltyRegistry) {\n    if (!_royaltyRegistry.supportsInterface(type(IRoyaltyRegistry).interfaceId)) {\n      revert NFTMarketCreators_Address_Does_Not_Support_IRoyaltyRegistry();\n    }\n    royaltyRegistry = IRoyaltyRegistry(_royaltyRegistry);\n  }\n\n  /**\n   * @notice Looks up the royalty payment configuration for a given NFT.\n   * @dev This will check various royalty APIs on the NFT and the royalty override\n   * if one was registered with the royalty registry. This aims to send royalties\n   * in the manner requested by the NFT owner, regardless of where the NFT was minted.\n   */\n  // solhint-disable-next-line code-complexity\n  function _getCreatorPaymentInfo(\n    address nftContract,\n    uint256 tokenId,\n    address seller\n  )\n    internal\n    view\n    returns (\n      address payable[] memory recipients,\n      uint256[] memory splitPerRecipientInBasisPoints,\n      bool isCreator\n    )\n  {\n    // All NFTs implement 165 so we skip that check, individual interfaces should return false if 165 is not implemented\n\n    // 1st priority: ERC-2981\n    if (nftContract.supportsERC165Interface(type(IRoyaltyInfo).interfaceId)) {\n      try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (\n        address receiver,\n        uint256 /* royaltyAmount */\n      ) {\n        if (receiver != address(0)) {\n          recipients = new address payable[](1);\n          recipients[0] = payable(receiver);\n          // splitPerRecipientInBasisPoints is not relevant when only 1 recipient is defined\n          if (receiver == seller) {\n            return (recipients, splitPerRecipientInBasisPoints, true);\n          }\n        }\n      } catch // solhint-disable-next-line no-empty-blocks\n      {\n        // Fall through\n      }\n    }\n\n    // 2nd priority: getRoyalties\n    if (recipients.length == 0 && nftContract.supportsERC165Interface(type(IGetRoyalties).interfaceId)) {\n      try IGetRoyalties(nftContract).getRoyalties{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (\n        address payable[] memory _recipients,\n        uint256[] memory recipientBasisPoints\n      ) {\n        if (_recipients.length > 0 && _recipients.length == recipientBasisPoints.length) {\n          bool hasRecipient;\n          unchecked {\n            // The array length cannot overflow 256 bits.\n            for (uint256 i = 0; i < _recipients.length; ++i) {\n              if (_recipients[i] != address(0)) {\n                hasRecipient = true;\n                if (_recipients[i] == seller) {\n                  return (_recipients, recipientBasisPoints, true);\n                }\n              }\n            }\n          }\n          if (hasRecipient) {\n            recipients = _recipients;\n            splitPerRecipientInBasisPoints = recipientBasisPoints;\n          }\n        }\n      } catch // solhint-disable-next-line no-empty-blocks\n      {\n        // Fall through\n      }\n    }\n\n    /* Overrides must support ERC-165 when registered, except for overrides defined by the registry owner.\n       If that results in an override w/o 165 we may need to upgrade the market to support or ignore that override. */\n    // The registry requires overrides are not 0 and contracts when set.\n    // If no override is set, the nftContract address is returned.\n    if (recipients.length == 0) {\n      try royaltyRegistry.getRoyaltyLookupAddress{ gas: READ_ONLY_GAS_LIMIT }(nftContract) returns (\n        address overrideContract\n      ) {\n        if (overrideContract != nftContract) {\n          nftContract = overrideContract;\n\n          // The functions above are repeated here if an override is set.\n\n          // 3rd priority: ERC-2981 override\n          if (nftContract.supportsERC165Interface(type(IRoyaltyInfo).interfaceId)) {\n            try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (\n              address receiver,\n              uint256 /* royaltyAmount */\n            ) {\n              if (receiver != address(0)) {\n                recipients = new address payable[](1);\n                recipients[0] = payable(receiver);\n                // splitPerRecipientInBasisPoints is not relevant when only 1 recipient is defined\n                if (receiver == seller) {\n                  return (recipients, splitPerRecipientInBasisPoints, true);\n                }\n              }\n            } catch // solhint-disable-next-line no-empty-blocks\n            {\n              // Fall through\n            }\n          }\n\n          // 4th priority: getRoyalties override\n          if (recipients.length == 0 && nftContract.supportsERC165Interface(type(IGetRoyalties).interfaceId)) {\n            try IGetRoyalties(nftContract).getRoyalties{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (\n              address payable[] memory _recipients,\n              uint256[] memory recipientBasisPoints\n            ) {\n              if (_recipients.length > 0 && _recipients.length == recipientBasisPoints.length) {\n                bool hasRecipient;\n                for (uint256 i = 0; i < _recipients.length; ++i) {\n                  if (_recipients[i] != address(0)) {\n                    hasRecipient = true;\n                    if (_recipients[i] == seller) {\n                      return (_recipients, recipientBasisPoints, true);\n                    }\n                  }\n                }\n                if (hasRecipient) {\n                  recipients = _recipients;\n                  splitPerRecipientInBasisPoints = recipientBasisPoints;\n                }\n              }\n            } catch // solhint-disable-next-line no-empty-blocks\n            {\n              // Fall through\n            }\n          }\n        }\n      } catch // solhint-disable-next-line no-empty-blocks\n      {\n        // Ignore out of gas errors and continue using the nftContract address\n      }\n    }\n\n    // 5th priority: getFee* from contract or override\n    if (recipients.length == 0 && nftContract.supportsERC165Interface(type(IGetFees).interfaceId)) {\n      try IGetFees(nftContract).getFeeRecipients{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (\n        address payable[] memory _recipients\n      ) {\n        if (_recipients.length > 0) {\n          try IGetFees(nftContract).getFeeBps{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (\n            uint256[] memory recipientBasisPoints\n          ) {\n            if (_recipients.length == recipientBasisPoints.length) {\n              bool hasRecipient;\n              unchecked {\n                // The array length cannot overflow 256 bits.\n                for (uint256 i = 0; i < _recipients.length; ++i) {\n                  if (_recipients[i] != address(0)) {\n                    hasRecipient = true;\n                    if (_recipients[i] == seller) {\n                      return (_recipients, recipientBasisPoints, true);\n                    }\n                  }\n                }\n              }\n              if (hasRecipient) {\n                recipients = _recipients;\n                splitPerRecipientInBasisPoints = recipientBasisPoints;\n              }\n            }\n          } catch // solhint-disable-next-line no-empty-blocks\n          {\n            // Fall through\n          }\n        }\n      } catch // solhint-disable-next-line no-empty-blocks\n      {\n        // Fall through\n      }\n    }\n\n    // 6th priority: tokenCreator w/ or w/o requiring 165 from contract or override\n    try ITokenCreator(nftContract).tokenCreator{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (\n      address payable _creator\n    ) {\n      if (_creator != address(0)) {\n        if (recipients.length == 0) {\n          // Only pay the tokenCreator if there wasn't another royalty defined\n          recipients = new address payable[](1);\n          recipients[0] = _creator;\n          // splitPerRecipientInBasisPoints is not relevant when only 1 recipient is defined\n        }\n        return (recipients, splitPerRecipientInBasisPoints, _creator == seller);\n      }\n    } catch // solhint-disable-next-line no-empty-blocks\n    {\n      // Fall through\n    }\n\n    // 7th priority: owner from contract or override\n    try IOwnable(nftContract).owner{ gas: READ_ONLY_GAS_LIMIT }() returns (address owner) {\n      if (recipients.length == 0) {\n        // Only pay the owner if there wasn't another royalty defined\n        recipients = new address payable[](1);\n        recipients[0] = payable(owner);\n        // splitPerRecipientInBasisPoints is not relevant when only 1 recipient is defined\n      }\n      return (recipients, splitPerRecipientInBasisPoints, owner == seller);\n    } catch // solhint-disable-next-line no-empty-blocks\n    {\n      // Fall through\n    }\n\n    // If no valid payment address or creator is found, return 0 recipients\n  }\n\n  /**\n   * @notice Returns the address of the registry allowing for royalty configuration overrides.\n   * @return registry The address of the royalty registry contract.\n   */\n  function getRoyaltyRegistry() public view returns (address registry) {\n    return address(royaltyRegistry);\n  }\n\n  /**\n   * @notice This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   * @dev 500 slots were consumed with the addition of `SendValueWithFallbackWithdraw`.\n   */\n  uint256[500] private __gap;\n}"
    }
  ]
}