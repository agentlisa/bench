{
  "Title": "[G-08] In ``div 512`` function, ``quotient 0`` aggregate operation is used with unchecked to save gas",
  "Content": "\n```diff\npackages/v2-library/src/FullMath.sol:\n  158:     function div512(uint256 dividend0, uint256 dividend1, uint256 divisor, bool roundUp) internal pure returns (uint256 quotient0, uint256 quotient1) {\n  159:         (quotient0, quotient1) = div512(dividend0, dividend1, divisor);\n  160: \n  161:         if (roundUp) {\n  162:             (uint256 productA0, uint256 productA1) = mul512(quotient0, divisor);\n  163:             productA1 += (quotient1 * divisor);\n  164:             if (dividend1 > productA1 || dividend0 > productA0) {\n  165:                 if (quotient0 == type(uint256).max) {\n  166:                     quotient0 = 0;\n  167:                     quotient1++;\n- 168:                 } else quotient0++;\n+ 168:                 } else \n+                         unchecked {\n+                          quotient0++;\n+                         } \n  169:             }\n  170:         }\n  171:     }\n```\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-library/src/FullMath.sol#L165-L168\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-01-timeswap",
  "Code": [
    {
      "filename": "packages/v2-library/src/FullMath.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity =0.8.8;\n\nimport {Math} from \"./Math.sol\";\n\nlibrary FullMath {\n    using Math for uint256;\n\n    /// @dev Reverts when modulo by zero.\n    error ModuloByZero();\n\n    /// @dev Reverts when add512 overflows over uint512.\n    /// @param addendA0 The least significant part of first addend.\n    /// @param addendA1 The most significant part of first addend.\n    /// @param addendB0 The least significant part of second addend.\n    /// @param addendB1 The most significant part of second addend.\n    error AddOverflow(uint256 addendA0, uint256 addendA1, uint256 addendB0, uint256 addendB1);\n\n    /// @dev Reverts when sub512 underflows.\n    /// @param minuend0 The least significant part of minuend.\n    /// @param minuend1 The most significant part of minuend.\n    /// @param subtrahend0 The least significant part of subtrahend.\n    /// @param subtrahend1 The most significant part of subtrahend.\n    error SubUnderflow(uint256 minuend0, uint256 minuend1, uint256 subtrahend0, uint256 subtrahend1);\n\n    /// @dev Reverts when div512To256 overflows over uint256.\n    /// @param dividend0 The least significant part of dividend.\n    /// @param dividend1 The most significant part of dividend.\n    /// @param divisor The divisor.\n    error DivOverflow(uint256 dividend0, uint256 dividend1, uint256 divisor);\n\n    /// @dev Reverts when mulDiv overflows over uint256.\n    /// @param multiplicand The multiplicand.\n    /// @param multiplier The multiplier.\n    /// @param divisor The divisor.\n    error MulDivOverflow(uint256 multiplicand, uint256 multiplier, uint256 divisor);\n\n    /// @dev Calculates the sum of two uint512 numbers.\n    /// @notice Reverts on overflow over uint512.\n    /// @param addendA0 The least signficant part of addendA.\n    /// @param addendA1 The most significant part of addendA.\n    /// @param addendB0 The least significant part of addendB.\n    /// @param addendB1 The most significant part of addendB.\n    /// @return sum0 The least significant part of sum.\n    /// @return sum1 The most significant part of sum.\n    function add512(uint256 addendA0, uint256 addendA1, uint256 addendB0, uint256 addendB1) internal pure returns (uint256 sum0, uint256 sum1) {\n        assembly {\n            sum0 := add(addendA0, addendB0)\n            sum1 := add(add(addendA1, addendB1), lt(sum0, addendA0))\n        }\n        if (addendA1 > sum1) revert AddOverflow(addendA0, addendA1, addendB0, addendB1);\n    }\n\n    /// @dev Calculates the difference of two uint512 numbers.\n    /// @notice Reverts on underflow.\n    /// @param minuend0 The least significant part of minuend.\n    /// @param minuend1 The most significant part of minuend.\n    /// @param subtrahend0 The least significant part of subtrahend.\n    /// @param subtrahend1 The most significant part of subtrahend.\n    /// @return difference0 The least significant part of difference.\n    /// @return difference1 The most significant part of difference.\n    function sub512(uint256 minuend0, uint256 minuend1, uint256 subtrahend0, uint256 subtrahend1) internal pure returns (uint256 difference0, uint256 difference1) {\n        assembly {\n            difference0 := sub(minuend0, subtrahend0)\n            difference1 := sub(sub(minuend1, subtrahend1), lt(minuend0, subtrahend0))\n        }\n\n        if (subtrahend1 > minuend1 || (subtrahend1 == minuend1 && subtrahend0 > minuend0)) revert SubUnderflow(minuend0, minuend1, subtrahend0, subtrahend1);\n    }\n\n    /// @dev Calculate the product of two uint256 numbers that may result to uint512 product.\n    /// @notice Can never overflow.\n    /// @param multiplicand The multiplicand.\n    /// @param multiplier The multiplier.\n    /// @return product0 The least significant part of product.\n    /// @return product1 The most significant part of product.\n    function mul512(uint256 multiplicand, uint256 multiplier) internal pure returns (uint256 product0, uint256 product1) {\n        assembly {\n            let mm := mulmod(multiplicand, multiplier, not(0))\n            product0 := mul(multiplicand, multiplier)\n            product1 := sub(sub(mm, product0), lt(mm, product0))\n        }\n    }\n\n    /// @dev Divide 2 to 256 power by the divisor.\n    /// @dev Rounds down the result.\n    /// @notice Reverts when divide by zero.\n    /// @param divisor The divisor.\n    /// @return quotient The quotient.\n    function div256(uint256 divisor) private pure returns (uint256 quotient) {\n        if (divisor == 0) revert Math.DivideByZero();\n        assembly {\n            quotient := add(div(sub(0, divisor), divisor), 1)\n        }\n    }\n\n    /// @dev Compute 2 to 256 power modulo the given value.\n    /// @notice Reverts when modulo by zero.\n    /// @param value The given value.\n    /// @return result The result.\n    function mod256(uint256 value) private pure returns (uint256 result) {\n        if (value == 0) revert ModuloByZero();\n        assembly {\n            result := mod(sub(0, value), value)\n        }\n    }\n\n    /// @dev Divide a uint512 number by uint256 number to return a uint512 number.\n    /// @dev Rounds down the result.\n    /// @param dividend0 The least significant part of dividend.\n    /// @param dividend1 The most significant part of dividend.\n    /// @param divisor The divisor.\n    /// @param quotient0 The least significant part of quotient.\n    /// @param quotient1 The most significant part of quotient.\n    function div512(uint256 dividend0, uint256 dividend1, uint256 divisor) private pure returns (uint256 quotient0, uint256 quotient1) {\n        if (dividend1 == 0) quotient0 = dividend0.div(divisor, false);\n        else {\n            uint256 q = div256(divisor);\n            uint256 r = mod256(divisor);\n            while (dividend1 != 0) {\n                (uint256 t0, uint256 t1) = mul512(dividend1, q);\n                (quotient0, quotient1) = add512(quotient0, quotient1, t0, t1);\n                (t0, t1) = mul512(dividend1, r);\n                (dividend0, dividend1) = add512(t0, t1, dividend0, 0);\n            }\n            (quotient0, quotient1) = add512(quotient0, quotient1, dividend0.div(divisor, false), 0);\n        }\n    }\n\n    /// @dev Divide a uint512 number by a uint256 number.\n    /// @dev Reverts when result is greater than uint256.\n    /// @notice Skips div512 if dividend1 is zero.\n    /// @param dividend0 The least significant part of dividend.\n    /// @param dividend1 The most significant part of dividend.\n    /// @param divisor The divisor.\n    /// @param roundUp Round up the result when true. Round down if false.\n    /// @param quotient The quotient.\n    function div512To256(uint256 dividend0, uint256 dividend1, uint256 divisor, bool roundUp) internal pure returns (uint256 quotient) {\n        uint256 quotient1;\n        (quotient, quotient1) = div512(dividend0, dividend1, divisor);\n\n        if (quotient1 != 0) revert DivOverflow(dividend0, dividend1, divisor);\n\n        if (roundUp) {\n            (uint256 productA0, uint256 productA1) = mul512(quotient, divisor);\n            if (dividend1 > productA1 || dividend0 > productA0) quotient++;\n        }\n    }\n\n    /// @dev Divide a uint512 number by a uint256 number.\n    /// @notice Skips div512 if dividend1 is zero.\n    /// @param dividend0 The least significant part of dividend.\n    /// @param dividend1 The most significant part of dividend.\n    /// @param divisor The divisor.\n    /// @param roundUp Round up the result when true. Round down if false.\n    /// @param quotient0 The least significant part of quotient.\n    /// @param quotient1 The most significant part of quotient.\n    function div512(uint256 dividend0, uint256 dividend1, uint256 divisor, bool roundUp) internal pure returns (uint256 quotient0, uint256 quotient1) {\n        (quotient0, quotient1) = div512(dividend0, dividend1, divisor);\n\n        if (roundUp) {\n            (uint256 productA0, uint256 productA1) = mul512(quotient0, divisor);\n            productA1 += (quotient1 * divisor);\n            if (dividend1 > productA1 || dividend0 > productA0) {\n                if (quotient0 == type(uint256).max) {\n                    quotient0 = 0;\n                    quotient1++;\n                } else quotient0++;\n            }\n        }\n    }\n\n    /// @dev Multiply two uint256 number then divide it by a uint256 number.\n    /// @notice Skips mulDiv if product of multiplicand and multiplier is uint256 number.\n    /// @dev Reverts when result is greater than uint256.\n    /// @param multiplicand The multiplicand.\n    /// @param multiplier The multiplier.\n    /// @param divisor The divisor.\n    /// @param roundUp Round up the result when true. Round down if false.\n    /// @return result The result.\n    function mulDiv(uint256 multiplicand, uint256 multiplier, uint256 divisor, bool roundUp) internal pure returns (uint256 result) {\n        (uint256 product0, uint256 product1) = mul512(multiplicand, multiplier);\n\n        // Handle non-overflow cases, 256 by 256 division\n        if (product1 == 0) return result = product0.div(divisor, roundUp);\n\n        // Make sure the result is less than 2**256.\n        // Also prevents divisor == 0\n        if (divisor <= product1) revert MulDivOverflow(multiplicand, multiplier, divisor);\n\n        unchecked {\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [product1 product0]\n            // Compute remainder using mulmod\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(multiplicand, multiplier, divisor)\n            }\n            // Subtract 256 bit number from 512 bit number\n            assembly {\n                product1 := sub(product1, gt(remainder, product0))\n                product0 := sub(product0, remainder)\n            }\n\n            // Factor powers of two out of divisor\n            // Compute largest power of two divisor of divisor.\n            // Always >= 1.\n            uint256 twos;\n            twos = (0 - divisor) & divisor;\n            // Divide denominator by power of two\n            assembly {\n                divisor := div(divisor, twos)\n            }\n\n            // Divide [product1 product0] by the factors of two\n            assembly {\n                product0 := div(product0, twos)\n            }\n            // Shift in bits from product1 into product0. For this we need\n            // to flip `twos` such that it is 2**256 / twos.\n            // If twos is zero, then it becomes one\n            assembly {\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            product0 |= product1 * twos;\n\n            // Invert divisor mod 2**256\n            // Now that divisor is an odd number, it has an inverse\n            // modulo 2**256 such that divisor * inv = 1 mod 2**256.\n            // Compute the inverse by starting with a seed that is correct\n            // correct for four bits. That is, divisor * inv = 1 mod 2**4\n            uint256 inv;\n            inv = (3 * divisor) ^ 2;\n\n            // Now use Newton-Raphson iteration to improve the precision.\n            // Thanks to Hensel's lifting lemma, this also works in modular\n            // arithmetic, doubling the correct bits in each step.\n            inv *= 2 - divisor * inv; // inverse mod 2**8\n            inv *= 2 - divisor * inv; // inverse mod 2**16\n            inv *= 2 - divisor * inv; // inverse mod 2**32\n            inv *= 2 - divisor * inv; // inverse mod 2**64\n            inv *= 2 - divisor * inv; // inverse mod 2**128\n            inv *= 2 - divisor * inv; // inverse mod 2**256\n\n            // Because the division is now exact we can divide by multiplying\n            // with the modular inverse of divisor. This will give us the\n            // correct result modulo 2**256. Since the precoditions guarantee\n            // that the outcome is less than 2**256, this is the final result.\n            // We don't need to compute the high bits of the result and product1\n            // is no longer required.\n            result = product0 * inv;\n        }\n\n        if (roundUp && mulmod(multiplicand, multiplier, divisor) != 0) result++;\n    }\n\n    /// @dev Get the square root of a uint512 number.\n    /// @param value0 The least significant of the number.\n    /// @param value1 The most significant of the number.\n    /// @param roundUp Round up the result when true. Round down if false.\n    /// @return result The result.\n    function sqrt512(uint256 value0, uint256 value1, bool roundUp) internal pure returns (uint256 result) {\n        if (value1 == 0) result = value0.sqrt(roundUp);\n        else {\n            uint256 estimate = sqrt512Estimate(value0, value1, type(uint256).max);\n            result = type(uint256).max;\n            while (estimate < result) {\n                result = estimate;\n                estimate = sqrt512Estimate(value0, value1, estimate);\n            }\n\n            if (roundUp) {\n                (uint256 product0, uint256 product1) = mul512(result, result);\n                if (value1 > product1 || value0 > product0) result++;\n            }\n        }\n    }\n\n    /// @dev An iterative process of getting sqrt512 following Newtonian method.\n    /// @param value0 The least significant of the number.\n    /// @param value1 The most significant of the number.\n    /// @param currentEstimate The current estimate of the iteration.\n    /// @param estimate The new estimate of the iteration.\n    function sqrt512Estimate(uint256 value0, uint256 value1, uint256 currentEstimate) private pure returns (uint256 estimate) {\n        uint256 r0 = div512To256(value0, value1, currentEstimate, false);\n        uint256 r1;\n        (r0, r1) = add512(r0, 0, currentEstimate, 0);\n        estimate = div512To256(r0, r1, 2, false);\n    }\n}"
    }
  ]
}