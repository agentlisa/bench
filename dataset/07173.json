{
  "Title": "[G-13] Use nested if and, avoid multiple check combinations",
  "Content": "\nUsing nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports.\n\n19 results - 9 files:\n\n```solidity\npackages\\v2-library\\src\\CatchError.sol:\n  15:    if ((length - 4) % 32 == 0 && bytes4(reason) == selector) return BytesLib.slice(reason, 4, length - 4);\n```\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-library/src/CatchError.sol#L15\n\n```solidity\npackages\\v2-library\\src\\FullMath.sol:\n  257:   if (roundUp && mulmod(multiplicand, multiplier, divisor) != 0) result++;\n```\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-library/src/FullMath.sol#L257\n\n```solidity\npackages\\v2-library\\src\\Math.sol:\n  51:    if (roundUp && dividend % divisor != 0) quotient++;\n\n  62:    if (roundUp && dividend % (1 << divisorBit) != 0) quotient++;\n \n  81:    if (roundUp && value % result != 0) result++;\n```\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-library/src/Math.sol#L51\n\n```solidity\npackages\\v2-option\\src\\structs\\Param.sol:\n  111:   if (param.amount0 == 0 && param.amount1 == 0) Error.zeroInput();\n\n  124:   if (param.amount0 == 0 && param.amount1 == 0) Error.zeroInput();\n```\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-option/src/structs/Param.sol#L111\n\n```solidity\npackages\\v2-pool\\src\\TimeswapV2Pool.sol:\n  167:   if (long0Fees == 0 && long1Fees == 0 && shortFees == 0) Error.zeroInput();\n```\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-pool/src/TimeswapV2Pool.sol#L167\n\n```solidity\npackages\\v2-pool\\src\\libraries\\ConstantProduct.sol:\n  411:   if (a11 == 0 && a01.unsafeAdd(a10) >= a01) {\n```\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-pool/src/libraries/ConstantProduct.sol#L411\n\n```solidity\npackages\\v2-pool\\src\\structs\\Param.sol:\n  136:   if (param.long0Requested == 0 && param.long1Requested == 0 && param.shortRequested == 0 && param.strike == 0) Error.zeroInput();\n```\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-pool/src/structs/Param.sol#L136\n\n```solidity\npackages\\v2-token\\src\\base\\ERC1155Enumerable.sol:\n  60:    if (_idTotalSupply[id] == 0 && _additionalConditionAddTokenToAllTokensEnumeration(id)) _addTokenToAllTokensEnumeration(id);\n\n  64:    if (to != address(0) && to != from) {\n  \n  65:    if (balanceOf(to, id) == 0 && _additionalConditionAddTokenToOwnerEnumeration(to, id)) _addTokenToOwnerEnumeration(to, id);\n\n  94:    if (_idTotalSupply[id] == 0 && _additionalConditionRemoveTokenFromAllTokensEnumeration(id)) _removeTokenFromAllTokensEnumeration(id);\n\n  98:    if (from != address(0) && from != to) {\n  \n  99:    if (balanceOf(from, id) == 0 && _additionalConditionRemoveTokenFromOwnerEnumeration(from, id)) _removeTokenFromOwnerEnumeration(from, id);\n```\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-token/src/base/ERC1155Enumerable.sol#L60\n\n```solidity\npackages\\v2-token\\src\\structs\\Param.sol:\n  121:   if (param.long0Amount == 0 && param.long1Amount == 0 && param.shortAmount == 0) Error.zeroInput();\n\n  128:   if (param.long0Amount == 0 && param.long1Amount == 0 && param.shortAmount == 0) Error.zeroInput();\n\n  149:   if (param.long0FeesDesired == 0 && param.long1FeesDesired == 0 && param.shortFeesDesired == 0) Error.zeroInput();\n```\n\nhttps://github.com/code-423n4/2023-01-timeswap/blob/main/packages/v2-token/src/structs/Param.sol#L121\n\n**Recomendation Code:**\n\n```diff\nprotocol\\contracts\\plugins\\aave\\StaticATokenLM.sol#L422:\n- 149:   if (param.long0FeesDesired == 0 && param.long1FeesDesired == 0 && param.shortFeesDesired == 0) Error.zeroInput();\n+           if (param.long0FeesDesired == 0) {\n+               if (param.long1FeesDesired == 0) {\n+                   if (param.shortFeesDesired == 0) {\n+                       Error.zeroInput();\n+\t }\n+               }                                   \n+           }                                     \n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-01-timeswap",
  "Code": [
    {
      "filename": "packages/v2-library/src/CatchError.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity =0.8.8;\n\nimport {BytesLib} from \"./BytesLib.sol\";\n\nlibrary CatchError {\n    /// @dev Get the data passed from a given custom error.\n    /// @dev It checks that the first four bytes of the reason has the same selector.\n    /// @notice Will simply revert with the original error if the first four bytes is not the given selector.\n    /// @param reason The data being inquired upon.\n    /// @param selector The given conditional selector.\n    function catchError(bytes memory reason, bytes4 selector) internal pure returns (bytes memory) {\n        uint256 length = reason.length;\n\n        if ((length - 4) % 32 == 0 && bytes4(reason) == selector) return BytesLib.slice(reason, 4, length - 4);\n\n        assembly {\n            revert(reason, length)\n        }\n    }\n}"
    },
    {
      "filename": "packages/v2-library/src/FullMath.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity =0.8.8;\n\nimport {Math} from \"./Math.sol\";\n\nlibrary FullMath {\n    using Math for uint256;\n\n    /// @dev Reverts when modulo by zero.\n    error ModuloByZero();\n\n    /// @dev Reverts when add512 overflows over uint512.\n    /// @param addendA0 The least significant part of first addend.\n    /// @param addendA1 The most significant part of first addend.\n    /// @param addendB0 The least significant part of second addend.\n    /// @param addendB1 The most significant part of second addend.\n    error AddOverflow(uint256 addendA0, uint256 addendA1, uint256 addendB0, uint256 addendB1);\n\n    /// @dev Reverts when sub512 underflows.\n    /// @param minuend0 The least significant part of minuend.\n    /// @param minuend1 The most significant part of minuend.\n    /// @param subtrahend0 The least significant part of subtrahend.\n    /// @param subtrahend1 The most significant part of subtrahend.\n    error SubUnderflow(uint256 minuend0, uint256 minuend1, uint256 subtrahend0, uint256 subtrahend1);\n\n    /// @dev Reverts when div512To256 overflows over uint256.\n    /// @param dividend0 The least significant part of dividend.\n    /// @param dividend1 The most significant part of dividend.\n    /// @param divisor The divisor.\n    error DivOverflow(uint256 dividend0, uint256 dividend1, uint256 divisor);\n\n    /// @dev Reverts when mulDiv overflows over uint256.\n    /// @param multiplicand The multiplicand.\n    /// @param multiplier The multiplier.\n    /// @param divisor The divisor.\n    error MulDivOverflow(uint256 multiplicand, uint256 multiplier, uint256 divisor);\n\n    /// @dev Calculates the sum of two uint512 numbers.\n    /// @notice Reverts on overflow over uint512.\n    /// @param addendA0 The least signficant part of addendA.\n    /// @param addendA1 The most significant part of addendA.\n    /// @param addendB0 The least significant part of addendB.\n    /// @param addendB1 The most significant part of addendB.\n    /// @return sum0 The least significant part of sum.\n    /// @return sum1 The most significant part of sum.\n    function add512(uint256 addendA0, uint256 addendA1, uint256 addendB0, uint256 addendB1) internal pure returns (uint256 sum0, uint256 sum1) {\n        assembly {\n            sum0 := add(addendA0, addendB0)\n            sum1 := add(add(addendA1, addendB1), lt(sum0, addendA0))\n        }\n        if (addendA1 > sum1) revert AddOverflow(addendA0, addendA1, addendB0, addendB1);\n    }\n\n    /// @dev Calculates the difference of two uint512 numbers.\n    /// @notice Reverts on underflow.\n    /// @param minuend0 The least significant part of minuend.\n    /// @param minuend1 The most significant part of minuend.\n    /// @param subtrahend0 The least significant part of subtrahend.\n    /// @param subtrahend1 The most significant part of subtrahend.\n    /// @return difference0 The least significant part of difference.\n    /// @return difference1 The most significant part of difference.\n    function sub512(uint256 minuend0, uint256 minuend1, uint256 subtrahend0, uint256 subtrahend1) internal pure returns (uint256 difference0, uint256 difference1) {\n        assembly {\n            difference0 := sub(minuend0, subtrahend0)\n            difference1 := sub(sub(minuend1, subtrahend1), lt(minuend0, subtrahend0))\n        }\n\n        if (subtrahend1 > minuend1 || (subtrahend1 == minuend1 && subtrahend0 > minuend0)) revert SubUnderflow(minuend0, minuend1, subtrahend0, subtrahend1);\n    }\n\n    /// @dev Calculate the product of two uint256 numbers that may result to uint512 product.\n    /// @notice Can never overflow.\n    /// @param multiplicand The multiplicand.\n    /// @param multiplier The multiplier.\n    /// @return product0 The least significant part of product.\n    /// @return product1 The most significant part of product.\n    function mul512(uint256 multiplicand, uint256 multiplier) internal pure returns (uint256 product0, uint256 product1) {\n        assembly {\n            let mm := mulmod(multiplicand, multiplier, not(0))\n            product0 := mul(multiplicand, multiplier)\n            product1 := sub(sub(mm, product0), lt(mm, product0))\n        }\n    }\n\n    /// @dev Divide 2 to 256 power by the divisor.\n    /// @dev Rounds down the result.\n    /// @notice Reverts when divide by zero.\n    /// @param divisor The divisor.\n    /// @return quotient The quotient.\n    function div256(uint256 divisor) private pure returns (uint256 quotient) {\n        if (divisor == 0) revert Math.DivideByZero();\n        assembly {\n            quotient := add(div(sub(0, divisor), divisor), 1)\n        }\n    }\n\n    /// @dev Compute 2 to 256 power modulo the given value.\n    /// @notice Reverts when modulo by zero.\n    /// @param value The given value.\n    /// @return result The result.\n    function mod256(uint256 value) private pure returns (uint256 result) {\n        if (value == 0) revert ModuloByZero();\n        assembly {\n            result := mod(sub(0, value), value)\n        }\n    }\n\n    /// @dev Divide a uint512 number by uint256 number to return a uint512 number.\n    /// @dev Rounds down the result.\n    /// @param dividend0 The least significant part of dividend.\n    /// @param dividend1 The most significant part of dividend.\n    /// @param divisor The divisor.\n    /// @param quotient0 The least significant part of quotient.\n    /// @param quotient1 The most significant part of quotient.\n    function div512(uint256 dividend0, uint256 dividend1, uint256 divisor) private pure returns (uint256 quotient0, uint256 quotient1) {\n        if (dividend1 == 0) quotient0 = dividend0.div(divisor, false);\n        else {\n            uint256 q = div256(divisor);\n            uint256 r = mod256(divisor);\n            while (dividend1 != 0) {\n                (uint256 t0, uint256 t1) = mul512(dividend1, q);\n                (quotient0, quotient1) = add512(quotient0, quotient1, t0, t1);\n                (t0, t1) = mul512(dividend1, r);\n                (dividend0, dividend1) = add512(t0, t1, dividend0, 0);\n            }\n            (quotient0, quotient1) = add512(quotient0, quotient1, dividend0.div(divisor, false), 0);\n        }\n    }\n\n    /// @dev Divide a uint512 number by a uint256 number.\n    /// @dev Reverts when result is greater than uint256.\n    /// @notice Skips div512 if dividend1 is zero.\n    /// @param dividend0 The least significant part of dividend.\n    /// @param dividend1 The most significant part of dividend.\n    /// @param divisor The divisor.\n    /// @param roundUp Round up the result when true. Round down if false.\n    /// @param quotient The quotient.\n    function div512To256(uint256 dividend0, uint256 dividend1, uint256 divisor, bool roundUp) internal pure returns (uint256 quotient) {\n        uint256 quotient1;\n        (quotient, quotient1) = div512(dividend0, dividend1, divisor);\n\n        if (quotient1 != 0) revert DivOverflow(dividend0, dividend1, divisor);\n\n        if (roundUp) {\n            (uint256 productA0, uint256 productA1) = mul512(quotient, divisor);\n            if (dividend1 > productA1 || dividend0 > productA0) quotient++;\n        }\n    }\n\n    /// @dev Divide a uint512 number by a uint256 number.\n    /// @notice Skips div512 if dividend1 is zero.\n    /// @param dividend0 The least significant part of dividend.\n    /// @param dividend1 The most significant part of dividend.\n    /// @param divisor The divisor.\n    /// @param roundUp Round up the result when true. Round down if false.\n    /// @param quotient0 The least significant part of quotient.\n    /// @param quotient1 The most significant part of quotient.\n    function div512(uint256 dividend0, uint256 dividend1, uint256 divisor, bool roundUp) internal pure returns (uint256 quotient0, uint256 quotient1) {\n        (quotient0, quotient1) = div512(dividend0, dividend1, divisor);\n\n        if (roundUp) {\n            (uint256 productA0, uint256 productA1) = mul512(quotient0, divisor);\n            productA1 += (quotient1 * divisor);\n            if (dividend1 > productA1 || dividend0 > productA0) {\n                if (quotient0 == type(uint256).max) {\n                    quotient0 = 0;\n                    quotient1++;\n                } else quotient0++;\n            }\n        }\n    }\n\n    /// @dev Multiply two uint256 number then divide it by a uint256 number.\n    /// @notice Skips mulDiv if product of multiplicand and multiplier is uint256 number.\n    /// @dev Reverts when result is greater than uint256.\n    /// @param multiplicand The multiplicand.\n    /// @param multiplier The multiplier.\n    /// @param divisor The divisor.\n    /// @param roundUp Round up the result when true. Round down if false.\n    /// @return result The result.\n    function mulDiv(uint256 multiplicand, uint256 multiplier, uint256 divisor, bool roundUp) internal pure returns (uint256 result) {\n        (uint256 product0, uint256 product1) = mul512(multiplicand, multiplier);\n\n        // Handle non-overflow cases, 256 by 256 division\n        if (product1 == 0) return result = product0.div(divisor, roundUp);\n\n        // Make sure the result is less than 2**256.\n        // Also prevents divisor == 0\n        if (divisor <= product1) revert MulDivOverflow(multiplicand, multiplier, divisor);\n\n        unchecked {\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [product1 product0]\n            // Compute remainder using mulmod\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(multiplicand, multiplier, divisor)\n            }\n            // Subtract 256 bit number from 512 bit number\n            assembly {\n                product1 := sub(product1, gt(remainder, product0))\n                product0 := sub(product0, remainder)\n            }\n\n            // Factor powers of two out of divisor\n            // Compute largest power of two divisor of divisor.\n            // Always >= 1.\n            uint256 twos;\n            twos = (0 - divisor) & divisor;\n            // Divide denominator by power of two\n            assembly {\n                divisor := div(divisor, twos)\n            }\n\n            // Divide [product1 product0] by the factors of two\n            assembly {\n                product0 := div(product0, twos)\n            }\n            // Shift in bits from product1 into product0. For this we need\n            // to flip `twos` such that it is 2**256 / twos.\n            // If twos is zero, then it becomes one\n            assembly {\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            product0 |= product1 * twos;\n\n            // Invert divisor mod 2**256\n            // Now that divisor is an odd number, it has an inverse\n            // modulo 2**256 such that divisor * inv = 1 mod 2**256.\n            // Compute the inverse by starting with a seed that is correct\n            // correct for four bits. That is, divisor * inv = 1 mod 2**4\n            uint256 inv;\n            inv = (3 * divisor) ^ 2;\n\n            // Now use Newton-Raphson iteration to improve the precision.\n            // Thanks to Hensel's lifting lemma, this also works in modular\n            // arithmetic, doubling the correct bits in each step.\n            inv *= 2 - divisor * inv; // inverse mod 2**8\n            inv *= 2 - divisor * inv; // inverse mod 2**16\n            inv *= 2 - divisor * inv; // inverse mod 2**32\n            inv *= 2 - divisor * inv; // inverse mod 2**64\n            inv *= 2 - divisor * inv; // inverse mod 2**128\n            inv *= 2 - divisor * inv; // inverse mod 2**256\n\n            // Because the division is now exact we can divide by multiplying\n            // with the modular inverse of divisor. This will give us the\n            // correct result modulo 2**256. Since the precoditions guarantee\n            // that the outcome is less than 2**256, this is the final result.\n            // We don't need to compute the high bits of the result and product1\n            // is no longer required.\n            result = product0 * inv;\n        }\n\n        if (roundUp && mulmod(multiplicand, multiplier, divisor) != 0) result++;\n    }\n\n    /// @dev Get the square root of a uint512 number.\n    /// @param value0 The least significant of the number.\n    /// @param value1 The most significant of the number.\n    /// @param roundUp Round up the result when true. Round down if false.\n    /// @return result The result.\n    function sqrt512(uint256 value0, uint256 value1, bool roundUp) internal pure returns (uint256 result) {\n        if (value1 == 0) result = value0.sqrt(roundUp);\n        else {\n            uint256 estimate = sqrt512Estimate(value0, value1, type(uint256).max);\n            result = type(uint256).max;\n            while (estimate < result) {\n                result = estimate;\n                estimate = sqrt512Estimate(value0, value1, estimate);\n            }\n\n            if (roundUp) {\n                (uint256 product0, uint256 product1) = mul512(result, result);\n                if (value1 > product1 || value0 > product0) result++;\n            }\n        }\n    }\n\n    /// @dev An iterative process of getting sqrt512 following Newtonian method.\n    /// @param value0 The least significant of the number.\n    /// @param value1 The most significant of the number.\n    /// @param currentEstimate The current estimate of the iteration.\n    /// @param estimate The new estimate of the iteration.\n    function sqrt512Estimate(uint256 value0, uint256 value1, uint256 currentEstimate) private pure returns (uint256 estimate) {\n        uint256 r0 = div512To256(value0, value1, currentEstimate, false);\n        uint256 r1;\n        (r0, r1) = add512(r0, 0, currentEstimate, 0);\n        estimate = div512To256(r0, r1, 2, false);\n    }\n}"
    },
    {
      "filename": "packages/v2-library/src/Math.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity =0.8.8;\n\nlibrary Math {\n    /// @dev Reverts when divide by zero.\n    error DivideByZero();\n    error Overflow();\n\n    /// @dev Add two uint256.\n    /// @notice May overflow.\n    /// @param addend1 The first addend.\n    /// @param addend2 The second addend.\n    /// @return sum The sum.\n    function unsafeAdd(uint256 addend1, uint256 addend2) internal pure returns (uint256 sum) {\n        unchecked {\n            sum = addend1 + addend2;\n        }\n    }\n\n    /// @dev Subtract two uint256.\n    /// @notice May underflow.\n    /// @param minuend The minuend.\n    /// @param subtrahend The subtrahend.\n    /// @return difference The difference.\n    function unsafeSub(uint256 minuend, uint256 subtrahend) internal pure returns (uint256 difference) {\n        unchecked {\n            difference = minuend - subtrahend;\n        }\n    }\n\n    /// @dev Multiply two uint256.\n    /// @notice May overflow.\n    /// @param multiplicand The multiplicand.\n    /// @param multiplier The multiplier.\n    /// @return product The product.\n    function unsafeMul(uint256 multiplicand, uint256 multiplier) internal pure returns (uint256 product) {\n        unchecked {\n            product = multiplicand * multiplier;\n        }\n    }\n\n    /// @dev Divide two uint256.\n    /// @notice Reverts when divide by zero.\n    /// @param dividend The dividend.\n    /// @param divisor The divisor.\n    //// @param roundUp Round up the result when true. Round down if false.\n    /// @return quotient The quotient.\n    function div(uint256 dividend, uint256 divisor, bool roundUp) internal pure returns (uint256 quotient) {\n        quotient = dividend / divisor;\n\n        if (roundUp && dividend % divisor != 0) quotient++;\n    }\n\n    /// @dev Shift right a uint256 number.\n    /// @param dividend The dividend.\n    /// @param divisorBit The divisor in bits.\n    /// @param roundUp True if ceiling the result. False if floor the result.\n    /// @return quotient The quotient.\n    function shr(uint256 dividend, uint8 divisorBit, bool roundUp) internal pure returns (uint256 quotient) {\n        quotient = dividend >> divisorBit;\n\n        if (roundUp && dividend % (1 << divisorBit) != 0) quotient++;\n    }\n\n    /// @dev Gets the square root of a value.\n    /// @param value The value being square rooted.\n    /// @param roundUp Round up the result when true. Round down if false.\n    /// @return result The resulting value of the square root.\n    function sqrt(uint256 value, bool roundUp) internal pure returns (uint256 result) {\n        if (value == type(uint256).max) return result = type(uint128).max;\n        if (value == 0) return 0;\n        unchecked {\n            uint256 estimate = (value + 1) >> 1;\n            result = value;\n            while (estimate < result) {\n                result = estimate;\n                estimate = (value / estimate + estimate) >> 1;\n            }\n        }\n\n        if (roundUp && value % result != 0) result++;\n    }\n\n    /// @dev Gets the min of two uint256 number.\n    /// @param value1 The first value to be compared.\n    /// @param value2 The second value to be compared.\n    /// @return result The min result.\n    function min(uint256 value1, uint256 value2) internal pure returns (uint256 result) {\n        return value1 < value2 ? value1 : value2;\n    }\n}"
    },
    {
      "filename": "packages/v2-option/src/structs/Param.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity =0.8.8;\n\nimport {Error} from \"@timeswap-labs/v2-library/src/Error.sol\";\n\nimport {TimeswapV2OptionMint, TimeswapV2OptionBurn, TimeswapV2OptionSwap, TimeswapV2OptionCollect, TransactionLibrary} from \"../enums/Transaction.sol\";\n\n/// @dev The parameter to call the mint function.\n/// @param strike The strike of the option.\n/// @param maturity The maturity of the option.\n/// @param long0To The receipient of long0 positions.\n/// @param long1To The receipient of long1 positions.\n/// @param shortTo The receipient of short positions.\n/// @param transaction The type of mint transaction, more information in Transaction module.\n/// @param amount0 If transaction is givenTokensAndLongs, the amount of token0 deposited, and amount of long0 position minted.\n/// If transaction is givenShorts, the amount of short minted, where the equivalent strike converted amount is long0 positions.\n/// @param amount1 If transaction is givenTokensAndLongs, the amount of token1 deposited, and amount of long1 position minted.\n/// If transaction is givenShorts, the amount of short minted, where the equivalent strike converted amount is long1 positions.\n/// @param data The data to be sent to the function, which will go to the mint callback.\nstruct TimeswapV2OptionMintParam {\n    uint256 strike;\n    uint256 maturity;\n    address long0To;\n    address long1To;\n    address shortTo;\n    TimeswapV2OptionMint transaction;\n    uint256 amount0;\n    uint256 amount1;\n    bytes data;\n}\n\n/// @dev The parameter to call the burn function.\n/// @param strike The strike of the option.\n/// @param maturity The maturity of the option.\n/// @param token0To The receipient of token0 withdrawn.\n/// @param token1To The receipient of token1 withdrawn.\n/// @param transaction The type of burn transaction, more information in Transaction module.\n/// @param amount0 If transaction is givenTokensAndLongs, the amount of token0 withdrawn, and amount of long0 position burnt.\n/// If transaction is givenShorts, the amount of short burnt, where the equivalent strike converted amount is long0 positions.\n/// @param amount1 If transaction is givenTokensAndLongs, the amount of token1 withdrawn, and amount of long1 position burnt.\n/// If transaction is givenShorts, the amount of short burnt, where the equivalent strike converted amount is long1 positions.\n/// @param data The data to be sent to the function, which will go to the burn callback.\n/// @notice If data length is zero, skips the calback.\nstruct TimeswapV2OptionBurnParam {\n    uint256 strike;\n    uint256 maturity;\n    address token0To;\n    address token1To;\n    TimeswapV2OptionBurn transaction;\n    uint256 amount0;\n    uint256 amount1;\n    bytes data;\n}\n\n/// @dev The parameter to call the swap function.\n/// @param strike The strike of the option.\n/// @param maturity The maturity of the option.\n/// @param tokenTo The receipient of token0 when isLong0ToLong1 or token1 when isLong1ToLong0.\n/// @param longTo The receipient of long1 positions when isLong0ToLong1 or long0 when isLong1ToLong0.\n/// @param isLong0ToLong1 Transform long0 positions to long1 positions when true. Transform long1 positions to long0 positions when false.\n/// @param transaction The type of swap transaction, more information in Transaction module.\n/// @param amount If isLong0ToLong1 and transaction is GivenToken0AndLong0, this is the amount of token0 withdrawn, and the amount of long0 position burnt.\n/// If isLong1ToLong0 and transaction is GivenToken0AndLong0, this is the amount of token0 to be deposited, and the amount of long0 position minted.\n/// If isLong0ToLong1 and transaction is GivenToken1AndLong1, this is the amount of token1 to be deposited, and the amount of long1 position minted.\n/// If isLong1ToLong0 and transaction is GivenToken1AndLong1, this is the amount of token1 withdrawn, and the amount of long1 position burnt.\n/// @param data The data to be sent to the function, which will go to the swap callback.\nstruct TimeswapV2OptionSwapParam {\n    uint256 strike;\n    uint256 maturity;\n    address tokenTo;\n    address longTo;\n    bool isLong0ToLong1;\n    TimeswapV2OptionSwap transaction;\n    uint256 amount;\n    bytes data;\n}\n\n/// @dev The parameter to call the collect function.\n/// @param strike The strike of the option.\n/// @param maturity The maturity of the option.\n/// @param token0To The receipient of token0 withdrawn.\n/// @param token1To The receipient of token1 withdrawn.\n/// @param transaction The type of collect transaction, more information in Transaction module.\n/// @param amount If transaction is GivenShort, the amount of short position burnt.\n/// If transaction is GivenToken0, the amount of token0 withdrawn.\n/// If transaction is GivenToken1, the amount of token1 withdrawn.\n/// @param data The data to be sent to the function, which will go to the collect callback.\n/// @notice If data length is zero, skips the calback.\nstruct TimeswapV2OptionCollectParam {\n    uint256 strike;\n    uint256 maturity;\n    address token0To;\n    address token1To;\n    TimeswapV2OptionCollect transaction;\n    uint256 amount;\n    bytes data;\n}\n\nlibrary ParamLibrary {\n    /// @dev Sanity checks\n    /// @param param the parameter for mint transaction.\n    /// @param blockTimestamp the current block timestamp.\n    function check(TimeswapV2OptionMintParam memory param, uint96 blockTimestamp) internal pure {\n        if (param.strike == 0) Error.zeroInput();\n        if (param.maturity > type(uint96).max) Error.incorrectMaturity(param.maturity);\n        if (param.maturity <= blockTimestamp) Error.alreadyMatured(param.maturity, blockTimestamp);\n        if (param.shortTo == address(0)) Error.zeroAddress();\n        if (param.long0To == address(0)) Error.zeroAddress();\n        if (param.long1To == address(0)) Error.zeroAddress();\n        TransactionLibrary.check(param.transaction);\n        if (param.amount0 == 0 && param.amount1 == 0) Error.zeroInput();\n    }\n\n    /// @dev Sanity checks\n    /// @param param the parameter for burn transaction.\n    /// @param blockTimestamp the current block timestamp.\n    function check(TimeswapV2OptionBurnParam memory param, uint96 blockTimestamp) internal pure {\n        if (param.strike == 0) Error.zeroInput();\n        if (param.maturity > type(uint96).max) Error.incorrectMaturity(param.maturity);\n        if (param.maturity <= blockTimestamp) Error.alreadyMatured(param.maturity, blockTimestamp);\n        if (param.token0To == address(0)) Error.zeroAddress();\n        if (param.token1To == address(0)) Error.zeroAddress();\n        TransactionLibrary.check(param.transaction);\n        if (param.amount0 == 0 && param.amount1 == 0) Error.zeroInput();\n    }\n\n    /// @dev Sanity checks\n    /// @param param the parameter for swap transaction.\n    /// @param blockTimestamp the current block timestamp.\n    function check(TimeswapV2OptionSwapParam memory param, uint96 blockTimestamp) internal pure {\n        if (param.strike == 0) Error.zeroInput();\n        if (param.maturity > type(uint96).max) Error.incorrectMaturity(param.maturity);\n        if (param.maturity <= blockTimestamp) Error.alreadyMatured(param.maturity, blockTimestamp);\n        if (param.tokenTo == address(0)) Error.zeroAddress();\n        if (param.longTo == address(0)) Error.zeroAddress();\n        TransactionLibrary.check(param.transaction);\n        if (param.amount == 0) Error.zeroInput();\n    }\n\n    /// @dev Sanity checks\n    /// @param param the parameter for collect transaction.\n    /// @param blockTimestamp the current block timestamp.\n    function check(TimeswapV2OptionCollectParam memory param, uint96 blockTimestamp) internal pure {\n        if (param.strike == 0) Error.zeroInput();\n        if (param.maturity > type(uint96).max) Error.incorrectMaturity(param.maturity);\n        if (param.maturity > blockTimestamp) Error.stillActive(param.maturity, blockTimestamp);\n        if (param.token0To == address(0)) Error.zeroAddress();\n        if (param.token1To == address(0)) Error.zeroAddress();\n        TransactionLibrary.check(param.transaction);\n        if (param.amount == 0) Error.zeroInput();\n    }\n}"
    },
    {
      "filename": "packages/v2-pool/src/TimeswapV2Pool.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity =0.8.8;\n\nimport {Ownership} from \"@timeswap-labs/v2-library/src/Ownership.sol\";\n\nimport {Error} from \"@timeswap-labs/v2-library/src/Error.sol\";\n\nimport {ITimeswapV2Option} from \"@timeswap-labs/v2-option/src/interfaces/ITimeswapV2Option.sol\";\n\nimport {TimeswapV2OptionPosition} from \"@timeswap-labs/v2-option/src/enums/Position.sol\";\n\nimport {StrikeAndMaturity} from \"@timeswap-labs/v2-option/src/structs/StrikeAndMaturity.sol\";\n\nimport {NoDelegateCall} from \"./NoDelegateCall.sol\";\n\nimport {ITimeswapV2Pool} from \"./interfaces/ITimeswapV2Pool.sol\";\nimport {ITimeswapV2PoolFactory} from \"./interfaces/ITimeswapV2PoolFactory.sol\";\nimport {ITimeswapV2PoolDeployer} from \"./interfaces/ITimeswapV2PoolDeployer.sol\";\n\nimport {ITimeswapV2PoolMintCallback} from \"./interfaces/callbacks/ITimeswapV2PoolMintCallback.sol\";\nimport {ITimeswapV2PoolBurnCallback, ITimeswapV2PoolBurn2Callback} from \"./interfaces/callbacks/ITimeswapV2PoolBurnCallback.sol\";\nimport {ITimeswapV2PoolDeleverageCallback} from \"./interfaces/callbacks/ITimeswapV2PoolDeleverageCallback.sol\";\nimport {ITimeswapV2PoolLeverageCallback} from \"./interfaces/callbacks/ITimeswapV2PoolLeverageCallback.sol\";\nimport {ITimeswapV2PoolRebalanceCallback} from \"./interfaces/callbacks/ITimeswapV2PoolRebalanceCallback.sol\";\n\nimport {ReentrancyGuard} from \"./libraries/ReentrancyGuard.sol\";\n\nimport {LiquidityPosition, LiquidityPositionLibrary} from \"./structs/LiquidityPosition.sol\";\n\nimport {Pool, PoolLibrary} from \"./structs/Pool.sol\";\nimport {TimeswapV2PoolCollectParam, TimeswapV2PoolMintParam, TimeswapV2PoolBurnParam, TimeswapV2PoolDeleverageParam, TimeswapV2PoolLeverageParam, TimeswapV2PoolRebalanceParam, ParamLibrary} from \"./structs/Param.sol\";\nimport {TimeswapV2PoolMintChoiceCallbackParam, TimeswapV2PoolMintCallbackParam, TimeswapV2PoolBurnChoiceCallbackParam, TimeswapV2PoolBurnCallbackParam, TimeswapV2PoolDeleverageChoiceCallbackParam, TimeswapV2PoolDeleverageCallbackParam, TimeswapV2PoolLeverageCallbackParam, TimeswapV2PoolLeverageChoiceCallbackParam, TimeswapV2PoolRebalanceCallbackParam} from \"./structs/CallbackParam.sol\";\n\nimport {TimeswapV2PoolMint, TimeswapV2PoolBurn, TimeswapV2PoolDeleverage, TimeswapV2PoolLeverage, TimeswapV2PoolRebalance, TransactionLibrary} from \"./enums/Transaction.sol\";\n\ncontract TimeswapV2Pool is ITimeswapV2Pool, NoDelegateCall {\n    using PoolLibrary for Pool;\n    using Ownership for address;\n    using LiquidityPositionLibrary for LiquidityPosition;\n\n    /* ===== MODEL ===== */\n\n    /// @inheritdoc ITimeswapV2Pool\n    address public immutable override poolFactory;\n    /// @inheritdoc ITimeswapV2Pool\n    address public immutable override optionPair;\n    /// @inheritdoc ITimeswapV2Pool\n    uint256 public immutable override transactionFee;\n    /// @inheritdoc ITimeswapV2Pool\n    uint256 public immutable override protocolFee;\n\n    mapping(uint256 => mapping(uint256 => uint96)) private reentrancyGuards;\n    mapping(uint256 => mapping(uint256 => Pool)) private pools;\n\n    StrikeAndMaturity[] private listOfPools;\n\n    function addPoolEnumerationIfNecessary(uint256 strike, uint256 maturity) private {\n        if (reentrancyGuards[strike][maturity] == ReentrancyGuard.NOT_INTERACTED) {\n            reentrancyGuards[strike][maturity] = ReentrancyGuard.NOT_ENTERED;\n            listOfPools.push(StrikeAndMaturity({strike: strike, maturity: maturity}));\n        }\n    }\n\n    /* ===== MODIFIER ===== */\n\n    function raiseGuard(uint256 strike, uint256 maturity) private {\n        ReentrancyGuard.check(reentrancyGuards[strike][maturity]);\n        reentrancyGuards[strike][maturity] = ReentrancyGuard.ENTERED;\n    }\n\n    function lowerGuard(uint256 strike, uint256 maturity) private {\n        reentrancyGuards[strike][maturity] = ReentrancyGuard.NOT_ENTERED;\n    }\n\n    /* ===== INIT ===== */\n\n    constructor() NoDelegateCall() {\n        (poolFactory, optionPair, transactionFee, protocolFee) = ITimeswapV2PoolDeployer(msg.sender).parameter();\n    }\n\n    // Can be overidden for testing purposes.\n    function blockTimestamp(uint96 durationForward) internal view virtual returns (uint96) {\n        return uint96(block.timestamp + durationForward); // truncation is desired\n    }\n\n    /* ===== VIEW ===== */\n\n    /// @inheritdoc ITimeswapV2Pool\n    function getByIndex(uint256 id) external view override returns (StrikeAndMaturity memory) {\n        return listOfPools[id];\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function numberOfPools() external view override returns (uint256) {\n        return listOfPools.length;\n    }\n\n    function hasLiquidity(uint256 strike, uint256 maturity) private view {\n        if (pools[strike][maturity].liquidity == 0) Error.requireLiquidity();\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function totalLiquidity(uint256 strike, uint256 maturity) external view override returns (uint160) {\n        return pools[strike][maturity].liquidity;\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function sqrtInterestRate(uint256 strike, uint256 maturity) external view override returns (uint160) {\n        return pools[strike][maturity].sqrtInterestRate;\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function liquidityOf(uint256 strike, uint256 maturity, address owner) external view override returns (uint160) {\n        return pools[strike][maturity].liquidityPositions[owner].liquidity;\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function feeGrowth(uint256 strike, uint256 maturity) external view override returns (uint256 long0FeeGrowth, uint256 long1FeeGrowth, uint256 shortFeeGrowth) {\n        return pools[strike][maturity].feeGrowth();\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function feesEarnedOf(uint256 strike, uint256 maturity, address owner) external view override returns (uint256 long0Fees, uint256 long1Fees, uint256 shortFees) {\n        return pools[strike][maturity].feesEarnedOf(owner);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function protocolFeesEarned(uint256 strike, uint256 maturity) external view override returns (uint256 long0ProtocolFees, uint256 long1ProtocolFees, uint256 shortProtocolFees) {\n        return pools[strike][maturity].protocolFeesEarned();\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function totalLongBalance(uint256 strike, uint256 maturity) external view override returns (uint256 long0Amount, uint256 long1Amount) {\n        Pool storage pool = pools[strike][maturity];\n        long0Amount = pool."
    }
  ]
}