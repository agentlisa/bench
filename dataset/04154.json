{
  "Title": "[L12] Unnecessary require statements",
  "Content": "There are several instances in the code base where the `require` statements or conditional checks are unnecessary. For instance:\n\n\n* In the `OracleRelayer` contract, the `require` statement in the `modifyParameters` function at [line 189](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/OracleRelayer.sol#L189) checks if the input parameter `data &gt; 0`. This is unnecessary since the same condition is already checked in the `require` statement at [line 187](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/OracleRelayer.sol#L187).\n* In the `StabilityFeeTreasury` contract, the `require` statement in the `constructor` at [line 113](https://github.com/reflexer-labs/geb/blob/072f00ebd61a6704d7de66fea688479ed97628c3/src/StabilityFeeTreasury.sol#L113) checks if the input address `accountingEngine_` is not the same as `address(this)`. The scenario can happen only when the address of the `StabilityFeeTreasury` contract, that is going to be deployed, is precalculated and then passed to the constructor as the `accountingEngine_` address. Since the `StabilityFeeTreasury` contract is deployed by the governance, which is assumed to not be malicious, this check is unnecessary.\n\n\nTo simplify the code and prevent wastage of gas, consider removing the unnecessary checks.\n\n\n***Update:** Fixed in [pull request #85](https://github.com/reflexer-labs/geb/pull/85/files).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/OracleRelayer.sol",
      "content": "/// OracleRelayer.sol\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.7;\n\nabstract contract SAFEEngineLike {\n    function modifyParameters(bytes32, bytes32, uint) virtual external;\n}\n\nabstract contract OracleLike {\n    function getResultWithValidity() virtual public view returns (uint256, bool);\n}\n\ncontract OracleRelayer {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    /**\n     * @notice Add auth to an account\n     * @param account Account to add auth to\n     */\n    function addAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 1;\n        emit AddAuthorization(account);\n    }\n    /**\n     * @notice Remove auth from an account\n     * @param account Account to remove auth from\n     */\n    function removeAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 0;\n        emit RemoveAuthorization(account);\n    }\n    /**\n    * @notice Checks whether msg.sender can call an authed function\n    **/\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"OracleRelayer/account-not-authorized\");\n        _;\n    }\n\n    // --- Data ---\n    struct CollateralType {\n        // Usually an oracle security module that enforces delays to fresh price feeds\n        OracleLike orcl;\n        // CRatio used to compute the 'safePrice' - the price used when generating debt in SAFEEngine\n        uint256 safetyCRatio;\n        // CRatio used to compute the 'liquidationPrice' - the price used when liquidating SAFEs\n        uint256 liquidationCRatio;\n    }\n\n    // Data about each collateral type\n    mapping (bytes32 => CollateralType) public collateralTypes;\n\n    SAFEEngineLike public safeEngine;\n\n    // Whether this contract is enabled\n    uint256 public contractEnabled;\n    // Virtual redemption price (not the most updated value)\n    uint256 internal _redemptionPrice;                                                        // [ray]\n    // The force that changes the system users' incentives by changing the redemption price\n    uint256 public redemptionRate;                                                            // [ray]\n    // Last time when the redemption price was changed\n    uint256 public redemptionPriceUpdateTime;                                                 // [unix epoch time]\n    // Upper bound for the per-second redemption rate\n    uint256 public redemptionRateUpperBound;                                                  // [ray]\n    // Lower bound for the per-second redemption rate\n    uint256 public redemptionRateLowerBound;                                                  // [ray]\n\n    // --- Events ---\n    event AddAuthorization(address account);\n    event RemoveAuthorization(address account);\n    event DisableContract();\n    event ModifyParameters(\n        bytes32 collateralType,\n        bytes32 parameter,\n        address addr\n    );\n    event ModifyParameters(bytes32 parameter, uint data);\n    event ModifyParameters(\n        bytes32 collateralType,\n        bytes32 parameter,\n        uint data\n    );\n    event UpdateRedemptionPrice(uint redemptionPrice);\n    event UpdateCollateralPrice(\n      bytes32 collateralType,\n      uint256 priceFeedValue,\n      uint256 safetyPrice,\n      uint256 liquidationPrice\n    );\n\n    // --- Init ---\n    constructor(address safeEngine_) public {\n        authorizedAccounts[msg.sender] = 1;\n        safeEngine                 = SAFEEngineLike(safeEngine_);\n        _redemptionPrice           = RAY;\n        redemptionRate             = RAY;\n        redemptionPriceUpdateTime  = now;\n        redemptionRateUpperBound   = RAY * WAD;\n        redemptionRateLowerBound   = 1;\n        contractEnabled            = 1;\n        emit AddAuthorization(msg.sender);\n    }\n\n    // --- Math ---\n    uint constant WAD = 10 ** 18;\n    uint constant RAY = 10 ** 27;\n\n    function subtract(uint x, uint y) internal pure returns (uint z) {\n        z = x - y;\n        require(z <= x);\n    }\n    function multiply(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n    function rmultiply(uint x, uint y) internal pure returns (uint z) {\n        // alsites rounds down\n        z = multiply(x, y) / RAY;\n    }\n    function rdivide(uint x, uint y) internal pure returns (uint z) {\n        z = multiply(x, RAY) / y;\n    }\n    function rpower(uint x, uint n, uint base) internal pure returns (uint z) {\n        assembly {\n            switch x case 0 {switch n case 0 {z := base} default {z := 0}}\n            default {\n                switch mod(n, 2) case 0 { z := base } default { z := x }\n                let half := div(base, 2)  // for rounding.\n                for { n := div(n, 2) } n { n := div(n,2) } {\n                    let xx := mul(x, x)\n                    if iszero(eq(div(xx, x), x)) { revert(0,0) }\n                    let xxRound := add(xx, half)\n                    if lt(xxRound, xx) { revert(0,0) }\n                    x := div(xxRound, base)\n                    if mod(n,2) {\n                        let zx := mul(z, x)\n                        if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\n                        let zxRound := add(zx, half)\n                        if lt(zxRound, zx) { revert(0,0) }\n                        z := div(zxRound, base)\n                    }\n                }\n            }\n        }\n    }\n\n    // --- Administration ---\n    /**\n     * @notice Modify oracle price feed addresses\n     * @param collateralType Collateral who's oracle we change\n     * @param parameter Name of the parameter\n     * @param addr New oracle address\n     */\n    function modifyParameters(\n        bytes32 collateralType,\n        bytes32 parameter,\n        address addr\n    ) external isAuthorized {\n        require(contractEnabled == 1, \"OracleRelayer/contract-not-enabled\");\n        if (parameter == \"orcl\") collateralTypes[collateralType].orcl = OracleLike(addr);\n        else revert(\"OracleRelayer/modify-unrecognized-param\");\n        emit ModifyParameters(\n            collateralType,\n            parameter,\n            addr\n        );\n    }\n    /**\n     * @notice Modify redemption related parameters\n     * @param parameter Name of the parameter\n     * @param data New param value\n     */\n    function modifyParameters(bytes32 parameter, uint data) external isAuthorized {\n        require(contractEnabled == 1, \"OracleRelayer/contract-not-enabled\");\n        require(data > 0, \"OracleRelayer/null-data\");\n        if (parameter == \"redemptionPrice\") {\n          require(data > 0, \"OracleRelayer/null-redemption-price\");\n          _redemptionPrice = data;\n        }\n        else if (parameter == \"redemptionRate\") {\n          require(now == redemptionPriceUpdateTime, \"OracleRelayer/redemption-price-not-updated\");\n          uint256 adjustedRate = data;\n          if (data > redemptionRateUpperBound) {\n            adjustedRate = redemptionRateUpperBound;\n          } else if (data < redemptionRateLowerBound) {\n            adjustedRate = redemptionRateLowerBound;\n          }\n          redemptionRate = adjustedRate;\n        }\n        else if (parameter == \"redemptionRateUpperBound\") {\n          require(data > RAY, \"OracleRelayer/invalid-redemption-rate-upper-bound\");\n          redemptionRateUpperBound = data;\n        }\n        else if (parameter == \"redemptionRateLowerBound\") {\n          require(data < RAY, \"OracleRelayer/invalid-redemption-rate-lower-bound\");\n          redemptionRateLowerBound = data;\n        }\n        else revert(\"OracleRelayer/modify-unrecognized-param\");\n        emit ModifyParameters(\n            parameter,\n            data\n        );\n    }\n    /**\n     * @notice Modify CRatio related parameters\n     * @param collateralType Collateral who's parameters we change\n     * @param parameter Name of the parameter\n     * @param data New param value\n     */\n    function modifyParameters(\n        bytes32 collateralType,\n        bytes32 parameter,\n        uint data\n    ) external isAuthorized {\n        require(contractEnabled == 1, \"OracleRelayer/contract-not-enabled\");\n        if (parameter == \"safetyCRatio\") {\n          require(data >= collateralTypes[collateralType].liquidationCRatio, \"OracleRelayer/safety-lower-than-liquidation-cratio\");\n          collateralTypes[collateralType].safetyCRatio = data;\n        }\n        else if (parameter == \"liquidationCRatio\") {\n          require(data <= collateralTypes[collateralType].safetyCRatio, \"OracleRelayer/safety-lower-than-liquidation-cratio\");\n          collateralTypes[collateralType].liquidationCRatio = data;\n        }\n        else revert(\"OracleRelayer/modify-unrecognized-param\");\n        emit ModifyParameters(\n            collateralType,\n            parameter,\n            data\n        );\n    }\n\n    // --- Redemption Price Update ---\n    /**\n     * @notice Update the redemption price according to the current redemption rate\n     */\n    function updateRedemptionPrice() internal returns (uint) {\n        // Update redemption price\n        _redemptionPrice = rmultiply(\n          rpower(redemptionRate, subtract(now, redemptionPriceUpdateTime), RAY),\n          _redemptionPrice\n        );\n        if (_redemptionPrice == 0) _redemptionPrice = 1;\n        redemptionPriceUpdateTime = now;\n        emit UpdateRedemptionPrice(_redemptionPrice);\n        // Return updated redemption price\n        return _redemptionPrice;\n    }\n    /**\n     * @notice Fetch the latest redemption price by first updating it\n     */\n    function redemptionPrice() public returns (uint) {\n        if (now > redemptionPriceUpdateTime) return updateRedemptionPrice();\n        return _redemptionPrice;\n    }\n\n    // --- Update value ---\n    /**\n     * @notice Update the collateral price inside the system (inside SAFEEngine)\n     * @param collateralType The collateral we want to update prices (safety and liquidation prices) for\n     */\n    function updateCollateralPrice(bytes32 collateralType) external {\n        (uint256 priceFeedValue, bool hasValidValue) =\n          collateralTypes[collateralType].orcl.getResultWithValidity();\n        uint redemptionPrice_ = redemptionPrice();\n        uint256 safetyPrice_ = hasValidValue ? rdivide(rdivide(multiply(uint(priceFeedValue), 10 ** 9), redemptionPrice_), collateralTypes[collateralType].safetyCRatio) : 0;\n        uint256 liquidationPrice_ = hasValidValue ? rdivide(rdivide(multiply(uint(priceFeedValue), 10 ** 9), redemptionPrice_), collateralTypes[collateralType].liquidationCRatio) : 0;\n\n        safeEngine.modifyParameters(collateralType, \"safetyPrice\", safetyPrice_);\n        safeEngine.modifyParameters(collateralType, \"liquidationPrice\", liquidationPrice_);\n        emit UpdateCollateralPrice(collateralType, priceFeedValue, safetyPrice_, liquidationPrice_);\n    }\n\n    /**\n     * @notice Disable this contract (normally called by GlobalSettlement)\n     */\n    function disableContract() external isAuthorized {\n        contractEnabled = 0;\n        redemptionRate = RAY;\n        emit DisableContract();\n    }\n\n    /**\n     * @notice Fetch the safety CRatio of a specific collateral type\n     * @param collateralType The collateral price we want the safety CRatio for\n     */\n    function safetyCRatio(bytes32 collateralType) public view returns (uint256) {\n        return collateralTypes[collateralType].safetyCRatio;\n    }\n    /**\n     * @notice Fetch the liquidation CRatio of a specific collateral type\n     * @param collateralType The collateral price we want the liquidation CRatio for\n     */\n    function liquidationCRatio(bytes32 collateralType) public view returns (uint256) {\n        return collateralTypes[collateralType].liquidationCRatio;\n    }\n    /**\n     * @notice Fetch the oracle price feed of a specific collateral type\n     * @param collateralType The collateral price we want the oracle price feed for\n     */\n    function orcl(bytes32 collateralType) public view returns (address) {\n        return address(collateralTypes[collateralType].orcl);\n    }\n}"
    },
    {
      "filename": "src/StabilityFeeTreasury.sol",
      "content": "/// StabilityFeeTreasury.sol\n\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>, 2020 Reflexer Labs, INC\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.7;\n\nabstract contract SAFEEngineLike {\n    function approveSAFEModification(address) virtual external;\n    function denySAFEModification(address) virtual external;\n    function transferInternalCoins(address,address,uint) virtual external;\n    function coinBalance(address) virtual public view returns (uint);\n}\nabstract contract SystemCoinLike {\n    function balanceOf(address) virtual public view returns (uint);\n    function approve(address, uint) virtual public returns (uint);\n    function transfer(address,uint) virtual public returns (bool);\n    function transferFrom(address,address,uint) virtual public returns (bool);\n}\nabstract contract CoinJoinLike {\n    function systemCoin() virtual public view returns (address);\n    function join(address, uint) virtual external;\n    function exit(address, uint) virtual external;\n}\n\ncontract StabilityFeeTreasury {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    /**\n     * @notice Add auth to an account\n     * @param account Account to add auth to\n     */\n    function addAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 1;\n        emit AddAuthorization(account);\n    }\n    /**\n     * @notice Remove auth from an account\n     * @param account Account to remove auth from\n     */\n    function removeAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 0;\n        emit RemoveAuthorization(account);\n    }\n    /**\n    * @notice Checks whether msg.sender can call an authed function\n    **/\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"StabilityFeeTreasury/account-not-authorized\");\n        _;\n    }\n\n    // --- Events ---\n    event AddAuthorization(address account);\n    event RemoveAuthorization(address account);\n    event ModifyParameters(bytes32 parameter, address addr);\n    event ModifyParameters(bytes32 parameter, uint val);\n    event DisableContract();\n    event SetTotalAllowance(address account, uint rad);\n    event SetPerBlockAllowance(address account, uint rad);\n    event GiveFunds(address account, uint rad, uint expensesAccumulator);\n    event TakeFunds(address account, uint rad);\n    event PullFunds(address sender, address dstAccount, address token, uint rad, uint expensesAccumulator);\n    event TransferSurplusFunds(address accountingEngine, uint fundsToTransfer);\n\n    // --- Structs ---\n    struct Allowance {\n        uint total;\n        uint perBlock;\n    }\n\n    mapping(address => Allowance) private allowance;\n    mapping(address => mapping(uint => uint)) public pulledPerBlock;\n\n    SAFEEngineLike  public safeEngine;\n    SystemCoinLike  public systemCoin;\n    CoinJoinLike    public coinJoin;\n\n    address public accountingEngine;\n\n    uint256 public treasuryCapacity;           // max amount of SF that can be kept in treasury                        [rad]\n    uint256 public minimumFundsRequired;       // minimum amount of SF that must be kept in the treasury at all times  [rad]\n    uint256 public expensesMultiplier;         // multiplier for expenses                                              [hundred]\n    uint256 public surplusTransferDelay;       // minimum time between transferSurplusFunds calls                      [seconds]\n    uint256 public expensesAccumulator;        // expenses accumulator                                                 [rad]\n    uint256 public accumulatorTag;             // latest tagged accumulator price                                      [rad]\n    uint256 public latestSurplusTransferTime;  // latest timestamp when transferSurplusFunds was called                [seconds]\n    uint256 public contractEnabled;\n\n    modifier accountNotTreasury(address account) {\n        require(account != address(this), \"StabilityFeeTreasury/account-cannot-be-treasury\");\n        _;\n    }\n\n    constructor(\n        address safeEngine_,\n        address accountingEngine_,\n        address coinJoin_\n    ) public {\n        require(address(CoinJoinLike(coinJoin_).systemCoin()) != address(0), \"StabilityFeeTreasury/null-system-coin\");\n        require(accountingEngine_ != address(this), \"StabilityFeeTreasury/accounting-engine-cannot-be-treasury\");\n        authorizedAccounts[msg.sender] = 1;\n        safeEngine                = SAFEEngineLike(safeEngine_);\n        accountingEngine          = accountingEngine_;\n        coinJoin                  = CoinJoinLike(coinJoin_);\n        systemCoin                = SystemCoinLike(coinJoin.systemCoin());\n        latestSurplusTransferTime = now;\n        expensesMultiplier        = HUNDRED;\n        contractEnabled           = 1;\n        systemCoin.approve(address(coinJoin), uint(-1));\n        safeEngine.approveSAFEModification(address(coinJoin));\n        emit AddAuthorization(msg.sender);\n    }\n\n    // --- Math ---\n    uint256 constant HUNDRED = 10 ** 2;\n    uint256 constant RAY     = 10 ** 27;\n\n    function addition(uint x, uint y) internal pure returns (uint z) {\n        z = x + y;\n        require(z >= x);\n    }\n    function addition(int x, int y) internal pure returns (int z) {\n        z = x + y;\n        if (y <= 0) require(z <= x);\n        if (y  > 0) require(z > x);\n    }\n    function subtract(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x);\n    }\n    function subtract(int x, int y) internal pure returns (int z) {\n        z = x - y;\n        require(y <= 0 || z <= x);\n        require(y >= 0 || z >= x);\n    }\n    function multiply(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n    function divide(uint x, uint y) internal pure returns (uint z) {\n        require(y > 0);\n        z = x / y;\n        require(z <= x);\n    }\n\n    // --- Administration ---\n    /**\n     * @notice Modify contract addresses\n     * @param parameter The name of the contract whose address will be changed\n     * @param addr New address for the contract\n     */\n    function modifyParameters(bytes32 parameter, address addr) external isAuthorized {\n        require(contractEnabled == 1, \"StabilityFeeTreasury/contract-not-enabled\");\n        require(addr != address(0), \"StabilityFeeTreasury/null-addr\");\n        if (parameter == \"accountingEngine\") {\n          require(addr != address(this), \"StabilityFeeTreasury/accounting-engine-cannot-be-treasury\");\n          accountingEngine = addr;\n        }\n        else revert(\"StabilityFeeTreasury/modify-unrecognized-param\");\n        emit ModifyParameters(parameter, addr);\n    }\n    /**\n     * @notice Modify uint256 parameters\n     * @param parameter The name of the parameter to modify\n     * @param val New parameter value\n     */\n    function modifyParameters(bytes32 parameter, uint val) external isAuthorized {\n        require(contractEnabled == 1, \"StabilityFeeTreasury/not-live\");\n        if (parameter == \"expensesMultiplier\") expensesMultiplier = val;\n        else if (parameter == \"treasuryCapacity\") {\n          require(val >= minimumFundsRequired, \"StabilityFeeTreasury/capacity-lower-than-min-funds\");\n          treasuryCapacity = val;\n        }\n        else if (parameter == \"minimumFundsRequired\") {\n          require(val <= treasuryCapacity, \"StabilityFeeTreasury/min-funds-higher-than-capacity\");\n          minimumFundsRequired = val;\n        }\n        else if (parameter == \"surplusTransferDelay\") surplusTransferDelay = val;\n        else revert(\"StabilityFeeTreasury/modify-unrecognized-param\");\n        emit ModifyParameters(parameter, val);\n    }\n    /**\n     * @notice Disable this contract (normally called by GlobalSettlement)\n     */\n    function disableContract() external isAuthorized {\n        require(contractEnabled == 1, \"StabilityFeeTreasury/already-disabled\");\n        contractEnabled = 0;\n        if (systemCoin.balanceOf(address(this)) > 0) {\n          coinJoin.join(address(this), systemCoin.balanceOf(address(this)));\n        }\n        safeEngine.transferInternalCoins(address(this), accountingEngine, safeEngine.coinBalance(address(this)));\n        emit DisableContract();\n    }\n\n    // --- Utils ---\n    function either(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := or(x, y)}\n    }\n    function both(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := and(x, y)}\n    }\n    /**\n     * @notice Join all ERC20 system coins that the treasury has inside SAFEEngine\n     */\n    function joinAllCoins() internal {\n        if (systemCoin.balanceOf(address(this)) > 0) {\n          coinJoin.join(address(this), systemCoin.balanceOf(address(this)));\n        }\n    }\n\n    // --- Getters ---\n    function getAllowance(address account) public view returns (uint256, uint256) {\n        return (allowance[account].total, allowance[account].perBlock);\n    }\n\n    // --- SF Transfer Allowance ---\n    /**\n     * @notice Modify an address' total allowance in order to withdraw SF from the treasury\n     * @param account The approved address\n     * @param rad The total approved amount of SF to withdraw (number with 45 decimals)\n     */\n    function setTotalAllowance(address account, uint rad) external isAuthorized accountNotTreasury(account) {\n        require(account != address(0), \"StabilityFeeTreasury/null-account\");\n        allowance[account].total = rad;\n        emit SetTotalAllowance(account, rad);\n    }\n    /**\n     * @notice Modify an address' per block allowance in order to withdraw SF from the treasury\n     * @param account The approved address\n     * @param rad The per block approved amount of SF to withdraw (number with 45 decimals)\n     */\n    function setPerBlockAllowance(address account, uint rad) external isAuthorized accountNotTreasury(account) {\n        require(account != address(0), \"StabilityFeeTreasury/null-account\");\n        allowance[account].perBlock = rad;\n        emit SetPerBlockAllowance(account, rad);\n    }\n\n    // --- Stability Fee Transfer (Governance) ---\n    /**\n     * @notice Governance transfers SF to an address\n     * @param account Address to transfer SF to\n     * @param rad Amount of internal system coins to transfer (a number with 45 decimals)\n     */\n    function giveFunds(address account, uint rad) external isAuthorized accountNotTreasury(account) {\n        require(account != address(0), \"StabilityFeeTreasury/null-account\");\n\n        joinAllCoins();\n        require(safeEngine.coinBalance(address(this)) >= rad, \"StabilityFeeTreasury/not-enough-funds\");\n\n        if (account != accountingEngine) {\n          expensesAccumulator = addition(expensesAccumulator, rad);\n        }\n\n        safeEngine.transferInternalCoins(address(this), account, rad);\n        emit GiveFunds(account, rad, expensesAccumulator);\n    }\n    /**\n     * @notice Governance takes funds from an address\n     * @param account Address to take system coins from\n     * @param rad Amount of internal system coins to take from the account (a number with 45 decimals)\n     */\n    function takeFunds(address account, uint rad) external isAuthorized accountNotTreasury(account) {\n        safeEngine.transferInternalCoins(account, address(this), rad);\n        emit TakeFunds(account, rad);\n    }\n\n    // --- Stability Fee Transfer (Approved Accounts) ---\n    /**\n     * @notice Pull stability fees from the treasury (if your allowance permits)\n     * @param dstAccount Address to transfer funds to\n     * @param token Address of the token to transfer (in this case it must be the address of the ERC20 system coin).\n     *              Used only to adhere to a standard for automated, on-chain treasuries\n     * @param wad Amount of system coins (SF) to transfer (expressed as an 18 decimal number but the contract will transfer\n              internal system coins that have 45 decimals)\n     */\n    function pullFunds(address dstAccount, address token, uint wad) external {\n        if (dstAccount == address(this)) return;\n\t      require(allowance[msg.sender].total >= wad, \"StabilityFeeTreasury/not-allowed\");\n        require(dstAccount != address(0), \"StabilityFeeTreasury/null-dst\");\n        require(dstAccount != accountingEngine, \"StabilityFeeTreasury/dst-cannot-be-accounting\");\n        require(wad > 0, \"StabilityFeeTreasury/null-transfer-amount\");\n        require(token == address(systemCoin), \"StabilityFeeTreasury/token-unavailable\");\n        if (allowance[msg.sender].perBlock > 0) {\n          require(addition(pulledPerBlock[msg.sender][block.number], multiply(wad, RAY)) <= allowance[msg.sender].perBlock, \"StabilityFeeTreasury/per-block-limit-exceeded\");\n        }\n\n        pulledPerBlock[msg.sender][block.number] = addition(pulledPerBlock[msg.sender][block.number], multiply(wad, RAY));\n\n        joinAllCoins();\n        require(safeEngine.coinBalance(address(this)) >= multiply(wad, RAY), \"StabilityFeeTreasury/not-enough-funds\");\n\n        // Update allowance and accumulator\n        allowance[msg.sender].total = subtract(allowance[msg.sender].total, multiply(wad, RAY));\n        expensesAccumulator         = addition(expensesAccumulator, multiply(wad, RAY));\n\n        // Transfer money\n        safeEngine.transferInternalCoins(address(this), dstAccount, multiply(wad, RAY));\n\n        emit PullFunds(msg.sender, dstAccount, token, multiply(wad, RAY), expensesAccumulator);\n    }\n\n    // --- Treasury Maintenance ---\n    /**\n     * @notice Transfer surplus stability fees to the AccountingEngine. This is here to make sure that the treasury\n               doesn't accumulate too many fees that it doesn't even need in order to pay for allowances. It ensures\n               that there are enough funds left in the treasury to account for projected expenses (latest expenses multiplied\n               by an expense multiplier)\n     */\n    function transferSurplusFunds() external {\n        require(now >= addition(latestSurplusTransferTime, surplusTransferDelay), \"StabilityFeeTreasury/transfer-cooldown-not-passed\");\n        // Compute latest expenses\n        uint latestExpenses = subtract(expensesAccumulator, accumulatorTag);\n        // Check if we need to keep more funds than the total capacity\n        uint remainingFunds =\n          (treasuryCapacity <= divide(multiply(expensesMultiplier, latestExpenses), HUNDRED)) ?\n          divide(multiply(expensesMultiplier, latestExpenses), HUNDRED) : treasuryCapacity;\n        // Make sure to keep at least minimum funds\n        remainingFunds = (divide(multiply(expensesMultiplier, latestExpenses), HUNDRED) <= minimumFundsRequired) ?\n                   minimumFundsRequired : remainingFunds;\n        // Set internal vars\n        accumulatorTag            = expensesAccumulator;\n        latestSurplusTransferTime = now;\n        // Join all coins in system\n        joinAllCoins();\n        // Check if we have too much money\n        if (safeEngine.coinBalance(address(this)) > remainingFunds) {\n          // Make sure that we still keep min SF in treasury\n          uint fundsToTransfer = subtract(safeEngine.coinBalance(address(this)), remainingFunds);\n          // Transfer surplus to accounting engine\n          safeEngine.transferInternalCoins(address(this), accountingEngine, fundsToTransfer);\n          // Emit event\n          emit TransferSurplusFunds(accountingEngine, fundsToTransfer);\n        }\n    }\n}"
    }
  ]
}