{
  "Title": "Same value is calculated in every loop iteration",
  "Content": "##### Description\nValue of `decWant` is persistent during each iteration of loops at https://github.com/tonkers-kuma/strategy-ssb/blob/e49d07a64ea0eb4f5a199c2bf9ea4c8aee2b313f/contracts/Strategy.sol#L276 and at https://github.com/tonkers-kuma/strategy-ssb/blob/e49d07a64ea0eb4f5a199c2bf9ea4c8aee2b313f/contracts/Strategy.sol#L293 and therefore could be calculated outside the loop to save gas.\n##### Recommendation\nWe recommend to calculate value of `decWant` outside of loops in methods `harvestTrigger()` and `sellRewards()`.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/Strategy.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\n// Feel free to change the license, but this is what we use\n\n// Feel free to change this version of Solidity. We support >=0.6.0 <0.7.0;\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\n// These are the core Yearn libraries\nimport {BaseStrategy, StrategyParams} from \"@yearnvaults/contracts/BaseStrategy.sol\";\nimport {SafeERC20, SafeMath, IERC20, Address} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {Math} from \"@openzeppelin/contracts/math/Math.sol\";\nimport \"../interfaces/BalancerV2.sol\";\n\ninterface IName {\n    function name() external view returns (string memory);\n}\n\ncontract Strategy is BaseStrategy {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    IERC20 internal constant weth = IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2));\n    IBalancerVault public balancerVault;\n    IBalancerPool public bpt;\n    IERC20[] public rewardTokens;\n    IAsset[] internal assets;\n    SwapSteps[] internal swapSteps;\n    uint256[] internal minAmountsOut;\n    bytes32 public balancerPoolId;\n    uint8 public numTokens;\n    uint8 public tokenIndex;\n\n    struct SwapSteps {\n        bytes32[] poolIds;\n        IAsset[] assets;\n    }\n\n    uint256 internal constant max = type(uint256).max;\n\n    //1\t    0.01%\n    //5\t    0.05%\n    //10\t0.1%\n    //50\t0.5%\n    //100\t1%\n    //1000\t10%\n    //10000\t100%\n    uint256 public maxSlippageIn; // bips\n    uint256 public maxSlippageOut; // bips\n    uint256 public maxSingleDeposit;\n    uint256 public minDepositPeriod; // seconds\n    uint256 public lastDepositTime;\n    uint256 internal constant basisOne = 10000;\n    bool internal isOriginal = true;\n\n    constructor(\n        address _vault,\n        address _balancerVault,\n        address _balancerPool,\n        uint256 _maxSlippageIn,\n        uint256 _maxSlippageOut,\n        uint256 _maxSingleDeposit,\n        uint256 _minDepositPeriod)\n    public BaseStrategy(_vault){\n        _initializeStrat(_vault, _balancerVault, _balancerPool, _maxSlippageIn, _maxSlippageOut, _maxSingleDeposit, _minDepositPeriod);\n    }\n\n    function initialize(\n        address _vault,\n        address _strategist,\n        address _rewards,\n        address _keeper,\n        address _balancerVault,\n        address _balancerPool,\n        uint256 _maxSlippageIn,\n        uint256 _maxSlippageOut,\n        uint256 _maxSingleDeposit,\n        uint256 _minDepositPeriod\n    ) external {\n        _initialize(_vault, _strategist, _rewards, _keeper);\n        _initializeStrat(_vault, _balancerVault, _balancerPool, _maxSlippageIn, _maxSlippageOut, _maxSingleDeposit, _minDepositPeriod);\n    }\n\n    function _initializeStrat(\n        address _vault,\n        address _balancerVault,\n        address _balancerPool,\n        uint256 _maxSlippageIn,\n        uint256 _maxSlippageOut,\n        uint256 _maxSingleDeposit,\n        uint256 _minDepositPeriod)\n    internal {\n        require(address(bpt) == address(0x0), \"Strategy already initialized!\");\n        healthCheck = address(0xDDCea799fF1699e98EDF118e0629A974Df7DF012); // health.ychad.eth\n        bpt = IBalancerPool(_balancerPool);\n        balancerPoolId = bpt.getPoolId();\n        balancerVault = IBalancerVault(_balancerVault);\n        (IERC20[] memory tokens,,) = balancerVault.getPoolTokens(balancerPoolId);\n        numTokens = uint8(tokens.length);\n        assets = new IAsset[](numTokens);\n        tokenIndex = type(uint8).max;\n        for (uint8 i = 0; i < numTokens; i++) {\n            if (tokens[i] == want) {\n                tokenIndex = i;\n            }\n            assets[i] = IAsset(address(tokens[i]));\n        }\n        require(tokenIndex != type(uint8).max, \"token not supported in pool!\");\n\n        maxSlippageIn = _maxSlippageIn;\n        maxSlippageOut = _maxSlippageOut;\n        maxSingleDeposit = _maxSingleDeposit.mul(10 ** uint256(ERC20(address(want)).decimals()));\n        minAmountsOut = new uint256[](numTokens);\n        minDepositPeriod = _minDepositPeriod;\n\n        want.safeApprove(address(balancerVault), max);\n    }\n\n    event Cloned(address indexed clone);\n\n    function clone(\n        address _vault,\n        address _strategist,\n        address _rewards,\n        address _keeper,\n        address _balancerVault,\n        address _balancerPool,\n        uint256 _maxSlippageIn,\n        uint256 _maxSlippageOut,\n        uint256 _maxSingleDeposit,\n        uint256 _minDepositPeriod\n    ) external returns (address payable newStrategy) {\n        require(isOriginal);\n\n        bytes20 addressBytes = bytes20(address(this));\n\n        assembly {\n        // EIP-1167 bytecode\n            let clone_code := mload(0x40)\n            mstore(clone_code, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(clone_code, 0x14), addressBytes)\n            mstore(add(clone_code, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            newStrategy := create(0, clone_code, 0x37)\n        }\n\n        Strategy(newStrategy).initialize(\n            _vault, _strategist, _rewards, _keeper, _balancerVault, _balancerPool, _maxSlippageIn, _maxSlippageOut, _maxSingleDeposit, _minDepositPeriod\n        );\n\n        emit Cloned(newStrategy);\n    }\n\n\n    // ******** OVERRIDE THESE METHODS FROM BASE CONTRACT ************\n\n    function name() external view override returns (string memory) {\n        // Add your own name here, suggestion e.g. \"StrategyCreamYFI\"\n        return string(abi.encodePacked(\"SingleSidedBalancer \", bpt.symbol(), \"Pool \", ERC20(address(want)).symbol()));\n    }\n\n    function estimatedTotalAssets() public view override returns (uint256) {\n        return balanceOfWant().add(balanceOfPooled());\n    }\n\n    function prepareReturn(uint256 _debtOutstanding) internal override returns (uint256 _profit, uint256 _loss, uint256 _debtPayment){\n        if (_debtOutstanding > 0) {\n            (_debtPayment, _loss) = liquidatePosition(_debtOutstanding);\n        }\n\n        uint256 beforeWant = balanceOfWant();\n\n        // 2 forms of profit. Incentivized rewards (BAL+other) and pool fees (want)\n        collectTradingFees();\n        sellRewards();\n\n        uint256 afterWant = balanceOfWant();\n\n        _profit = afterWant.sub(beforeWant);\n        if (_profit > _loss) {\n            _profit = _profit.sub(_loss);\n            _loss = 0;\n        } else {\n            _loss = _loss.sub(_profit);\n            _profit = 0;\n        }\n    }\n\n    function adjustPosition(uint256 _debtOutstanding) internal override {\n        if (now - lastDepositTime < minDepositPeriod) {\n            return;\n        }\n\n        uint256 pooledBefore = balanceOfPooled();\n        uint256[] memory maxAmountsIn = new uint256[](numTokens);\n        uint256 amountIn = Math.min(maxSingleDeposit, balanceOfWant());\n        maxAmountsIn[tokenIndex] = amountIn;\n\n        if (maxAmountsIn[tokenIndex] > 0) {\n            uint256[] memory amountsIn = new uint256[](numTokens);\n            amountsIn[tokenIndex] = amountIn;\n            bytes memory userData = abi.encode(IBalancerVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT, amountsIn, 0);\n            IBalancerVault.JoinPoolRequest memory request = IBalancerVault.JoinPoolRequest(assets, maxAmountsIn, userData, false);\n            balancerVault.joinPool(balancerPoolId, address(this), address(this), request);\n\n            uint256 pooledDelta = balanceOfPooled().sub(pooledBefore);\n            uint256 joinSlipped = amountIn > pooledDelta ? amountIn.sub(pooledDelta) : 0;\n            uint256 maxLoss = amountIn.mul(maxSlippageIn).div(basisOne);\n\n            require(joinSlipped <= maxLoss, \"Exceeded maxSlippageIn!\");\n            lastDepositTime = now;\n        }\n    }\n\n    function liquidatePosition(uint256 _amountNeeded) internal override returns (uint256 _liquidatedAmount, uint256 _loss){\n        if (estimatedTotalAssets() < _amountNeeded) {\n            _liquidatedAmount = liquidateAllPositions();\n            return (_liquidatedAmount, _amountNeeded.sub(_liquidatedAmount));\n        }\n\n        uint256 looseAmount = balanceOfWant();\n        if (_amountNeeded > looseAmount) {\n            uint256 toExitAmount = _amountNeeded.sub(looseAmount);\n\n            _sellBptForExactToken(toExitAmount);\n\n            _liquidatedAmount = Math.min(balanceOfWant(), _amountNeeded);\n            _loss = _amountNeeded.sub(_liquidatedAmount);\n\n            _enforceSlippageOut(toExitAmount, _liquidatedAmount.sub(looseAmount));\n        } else {\n            _liquidatedAmount = _amountNeeded;\n        }\n    }\n\n    function liquidateAllPositions() internal override returns (uint256 liquidated) {\n        uint eta = estimatedTotalAssets();\n        uint256 bpts = balanceOfBpt();\n        if (bpts > 0) {\n            // exit entire position for single token. Could revert due to single exit limit enforced by balancer\n            bytes memory userData = abi.encode(IBalancerVault.ExitKind.EXACT_BPT_IN_FOR_ONE_TOKEN_OUT, bpts, tokenIndex);\n            IBalancerVault.ExitPoolRequest memory request = IBalancerVault.ExitPoolRequest(assets, minAmountsOut, userData, false);\n            balancerVault.exitPool(balancerPoolId, address(this), address(this), request);\n        }\n\n        liquidated = balanceOfWant();\n        _enforceSlippageOut(eta, liquidated);\n        return liquidated;\n    }\n\n    function prepareMigration(address _newStrategy) internal override {\n        bpt.transfer(_newStrategy, balanceOfBpt());\n        for (uint i = 0; i < rewardTokens.length; i++) {\n            IERC20 token = rewardTokens[i];\n            uint256 balance = token.balanceOf(address(this));\n            if (balance > 0) {\n                token.transfer(_newStrategy, balance);\n            }\n        }\n    }\n\n    function protectedTokens() internal view override returns (address[] memory){}\n\n    function ethToWant(uint256 _amtInWei) public view override returns (uint256){}\n\n    function tendTrigger(uint256 callCostInWei) public view override returns (bool) {\n        return now.sub(lastDepositTime) > minDepositPeriod && balanceOfWant() > 0;\n    }\n\n    function harvestTrigger(uint256 callCostInWei) public view override returns (bool){\n        bool hasRewards;\n        for (uint8 i = 0; i < rewardTokens.length; i++) {\n            ERC20 rewardToken = ERC20(address(rewardTokens[i]));\n\n            uint decReward = rewardToken.decimals();\n            uint decWant = ERC20(address(want)).decimals();\n            if (rewardToken.balanceOf(address(this)) > 10 ** (decReward > decWant ? decReward.sub(decWant) : 0)) {\n                hasRewards = true;\n                break;\n            }\n        }\n        return super.harvestTrigger(callCostInWei) && hasRewards;\n    }\n\n\n    // HELPERS //\n    function sellRewards() internal {\n        for (uint8 i = 0; i < rewardTokens.length; i++) {\n            ERC20 rewardToken = ERC20(address(rewardTokens[i]));\n            uint256 amount = rewardToken.balanceOf(address(this));\n\n            uint decReward = rewardToken.decimals();\n            uint decWant = ERC20(address(want)).decimals();\n\n            if (amount > 10 ** (decReward > decWant ? decReward.sub(decWant) : 0)) {\n                uint length = swapSteps[i].poolIds.length;\n                IBalancerVault.BatchSwapStep[] memory steps = new IBalancerVault.BatchSwapStep[](length);\n                int[] memory limits = new int[](length + 1);\n                limits[0] = int(amount);\n                for (uint j = 0; j < length; j++) {\n                    steps[j] = IBalancerVault.BatchSwapStep(swapSteps[i].poolIds[j],\n                        j,\n                        j + 1,\n                        j == 0 ? amount : 0,\n                        abi.encode(0)\n                    );\n                }\n                balancerVault.batchSwap(IBalancerVault.SwapKind.GIVEN_IN,\n                    steps,\n                    swapSteps[i].assets,\n                    IBalancerVault.FundManagement(address(this), false, address(this), false),\n                    limits,\n                    now + 10);\n            }\n        }\n    }\n\n    function collectTradingFees() internal {\n        uint256 total = estimatedTotalAssets();\n        uint256 debt = vault.strategies(address(this)).totalDebt;\n        if (total > debt) {\n            uint256 profit = total.sub(debt);\n            _sellBptForExactToken(profit);\n        }\n    }\n\n    function balanceOfWant() public view returns (uint256 _amount){\n        return want.balanceOf(address(this));\n    }\n\n    function balanceOfBpt() public view returns (uint256 _amount){\n        return bpt.balanceOf(address(this));\n    }\n\n    function balanceOfReward(uint256 index) public view returns (uint256 _amount){\n        return rewardTokens[index].balanceOf(address(this));\n    }\n\n    function balanceOfPooled() public view returns (uint256 _amount){\n        uint256 totalWantPooled;\n        (IERC20[] memory tokens,uint256[] memory totalBalances,uint256 lastChangeBlock) = balancerVault.getPoolTokens(balancerPoolId);\n        for (uint8 i = 0; i < numTokens; i++) {\n            uint256 tokenPooled = totalBalances[i].mul(balanceOfBpt()).div(bpt.totalSupply());\n            if (tokenPooled > 0) {\n                IERC20 token = tokens[i];\n                if (token != want) {\n                    IBalancerPool.SwapRequest memory request = _getSwapRequest(token, tokenPooled, lastChangeBlock);\n                    // now denomated in want\n                    tokenPooled = bpt.onSwap(request, totalBalances, i, tokenIndex);\n                }\n                totalWantPooled += tokenPooled;\n            }\n        }\n        return totalWantPooled;\n    }\n\n    function _getSwapRequest(IERC20 token, uint256 amount, uint256 lastChangeBlock) internal view returns (IBalancerPool.SwapRequest memory request){\n        return IBalancerPool.SwapRequest(IBalancerPool.SwapKind.GIVEN_IN,\n            token,\n            want,\n            amount,\n            balancerPoolId,\n            lastChangeBlock,\n            address(this),\n            address(this),\n            abi.encode(0)\n        );\n    }\n\n    function _sellBptForExactToken(uint256 _amountTokenOut) internal {\n        uint256[] memory amountsOut = new uint256[](numTokens);\n        amountsOut[tokenIndex] = _amountTokenOut;\n        bytes memory userData = abi.encode(IBalancerVault.ExitKind.BPT_IN_FOR_EXACT_TOKENS_OUT, amountsOut, balanceOfBpt());\n        IBalancerVault.ExitPoolRequest memory request = IBalancerVault.ExitPoolRequest(assets, minAmountsOut, userData, false);\n        balancerVault.exitPool(balancerPoolId, address(this), address(this), request);\n    }\n\n    // for partnership rewards like Lido or airdrops\n    function whitelistRewards(address _rewardToken, SwapSteps memory _steps) public onlyVaultManagers {\n        IERC20 token = IERC20(_rewardToken);\n        token.approve(address(balancerVault), max);\n        rewardTokens.push(token);\n        swapSteps.push(_steps);\n    }\n\n    function delistAllRewards() public onlyVaultManagers {\n        for (uint i = 0; i < rewardTokens.length; i++) {\n            rewardTokens[i].approve(address(balancerVault), 0);\n        }\n        IERC20[] memory noRewardTokens;\n        rewardTokens = noRewardTokens;\n        delete swapSteps;\n    }\n\n    function numRewards() public view returns (uint256 _num){\n        return rewardTokens.length;\n    }\n\n    function setParams(uint256 _maxSlippageIn, uint256 _maxSlippageOut, uint256 _maxSingleDeposit, uint256 _minDepositPeriod) public onlyVaultManagers {\n        require(_maxSlippageIn <= basisOne, \"maxSlippageIn too high\");\n        maxSlippageIn = _maxSlippageIn;\n\n        require(_maxSlippageOut <= basisOne, \"maxSlippageOut too high\");\n        maxSlippageOut = _maxSlippageOut;\n\n        maxSingleDeposit = _maxSingleDeposit;\n        minDepositPeriod = _minDepositPeriod;\n    }\n\n    function _enforceSlippageOut(uint _intended, uint _actual) internal {\n        // enforce that amount exited didn't slip beyond our tolerance\n        // just in case there's positive slippage\n        uint256 exitSlipped = _intended > _actual ? _intended.sub(_actual) : 0;\n        uint256 maxLoss = _intended.mul(maxSlippageOut).div(basisOne);\n        require(exitSlipped <= maxLoss, \"Exceeded maxSlippageOut!\");\n    }\n\n    function getSwapSteps() public view returns (SwapSteps[] memory){\n        return swapSteps;\n    }\n\n    receive() external payable {}\n}"
    }
  ]
}