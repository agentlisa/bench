{
  "Title": "[M-02] An attacker can leave the protocol in a \"drawing\" state for extended period of time",
  "Content": "\nhttps://github.com/code-423n4/2023-03-wenwin/blob/91b89482aaedf8b8feb73c771d11c257eed997e8/src/RNSourceController.sol#L106-L120\n\nhttps://github.com/code-423n4/2023-03-wenwin/blob/91b89482aaedf8b8feb73c771d11c257eed997e8/src/RNSourceController.sol#L60-L75\n\nhttps://github.com/code-423n4/2023-03-wenwin/blob/91b89482aaedf8b8feb73c771d11c257eed997e8/src/RNSourceController.sol#L89-L104\n\nThe current implementation of Random Number Generation uses Chainlink’s V2 Direct Funding Method (https://docs.chain.link/vrf/v2/direct-funding). \n\n`VRFv2RNSource.sol` (inherits Chainlink’s `VRFV2WrapperConsumerBase.sol`) is responsible for handling requests and responses for the Lottery system. The communicator between `VRFv2RNSource.sol` contract and `Lottery.sol` is `RNSourceController.sol`. The ideal flow of control is the following:\n\n1. **Any** user can call `executeDraw()` in `Lottery.sol` assuming that the current draw is past the scheduled time for registering tickets.\n2. `executeDraw()` puts the system in the state of `drawExecutionInProgress = true` and calls `requestRandomNumber()`.\n3. in `RNSourceController.sol` - `requestRandomNumber()` checks if the previous draw was completed and calls `requestRandomNumberFromSource()`.\n4. `requestRandomNumberFromSource()` records the timestamp of the request in `lastRequestTimestamp = block.timestamp` and sets `lastRequestFulfilled = false` i.e `executeDraw()` cannot be called until the draw is finished. Lastly `source.requestRandomNumber()` is invoked.\n5. Now `source.requestRandomNumber()` calls `requestRandomnessFromUnderlyingSource()` and that subsequently calls `requestRandomness()` to generate a RN from Chainlink VRF.\n6. Several blocks later Chainlink VRF has verified a RN and sends a callback call to `fulfillRandomWords()` that calls `fulfill()`, which calls `onRandomNumberFulfilled()` in the `RNSourceController.sol` that sets `lastRequestFulfilled = true` and lastly `receiveRandomNumber(randomNumber)` is invoked in `Lottery.sol` that sets `drawExecutionInProgress = false` and starts a new draw (increments `currentDraw` state variable).\n\nThe culprit for this issue is the implementation of `requestRandomNumberFromSource()` in `RNSourceController.sol`. After `lastRequestFulfilled = false` the invocation to `VRFv2RNSource.sol` is done in a `try{} catch{}` block - \n```     \n        lastRequestTimestamp = block.timestamp;\n        lastRequestFulfilled = false;\n\n        try source.requestRandomNumber() {\n            emit SuccessfulRNRequest(source);\n        } catch Error(string memory reason) {\n            emit FailedRNRequest(source, bytes(reason));\n        } catch (bytes memory reason) {\n            emit FailedRNRequest(source, reason);\n        }\n    }\n```\nThis is very problematic due to how `try{} catch{}` works - [OpenZeppelin article](https://forum.openzeppelin.com/t/a-brief-analysis-of-the-new-try-catch-functionality-in-solidity-0-6/2564). If the request to Chainlink VRF fails at any point then execution of the above block will not revert but will continue in the catch{} statements only emitting an event and leaving RNSourceController in the state `lastRequestFulfilled = false` and triggering the `maxRequestDelay` (currently 5 hours) until `retry()` becomes available to call to retry sending a RN request. This turns out to be dangerous since there is a trivial way of making Chainlink VRF revert - simply not supplying enough gas for the transaction either initially in calling `executeDraw()` or subsequently in `retry()` invocations with the attacker front-running the malicious transaction.\n\n### Proof of Concept\n1. Ticket registration closes, attacker calls `executeDraw()` with insufficient gas and Lottery is put in the Executing Draw State (drawExecutionInProgress = true).\n2. Attacker front-runs the transaction if there are other `executeDraw()` transactions.\n3. `RNSourceController.sol` calls `VRFv2RNSource.so` in a `try{} catch{}` block, VRF transaction reverts and `lastRequestFulfilled` remains equal to `false`.\n4. After “maxRequestDelay” time has past retry() becomes available that relies on the same `try{} catch{}` block in `requestRandomNumberFromSource()`.\n5. Attacker calls `retry()` with insufficient gas and front-runs the transaction if there are other `retry()` transactions.\n6. Attacker repeats steps 4 and 5 leaving the system in a Drawing state for extended period of time (5 hours for every `retry()` in the example implementation).\n\nMoreover, the attacker doesn’t have any incentive to deposit LINK himself since VRF will also revert on insufficient LINK tokens.\n\nThis Proof of Concept was also implemented and confirmed in a Remix environment, tested on the Ethereum Sepolia test network. A video walk-through can be provided on my behalf if requested by judge or sponsors.\n\n### Impact\nSystem is left for extended period of time in “Drawing” state without the possibility to execute further draws, user experience is damaged significantly.\n\n### Comment\n\nBuilding upon this issue, an obvious observation arises - there is the `swapSource()` method that becomes available ( only to the owner ) after a predefined number of failed `retry()` invocations - `maxFailedAttempts`. Therefore, potentially, admins of the protocol could replace the VRF solution with a better one that is resistant to the try catch exploit? It turns out that the current implementation of `swapSource()` introduces a new exploit that breaks the **fairness** of the protocol and an edge case could even be constructed that leads to an attacker stealing a jackpot.\n\n**[rand0c0des (Wenwin) confirmed and commented](https://github.com/code-423n4/2023-03-wenwin-findings/issues/521#issuecomment-1471487649):**\n > I communicated with warden. This is confirmed as an issue.\n\n**[cccz (judge) commented](https://github.com/code-423n4/2023-03-wenwin-findings/issues/521#issuecomment-1483809454):**\n > From alexxander (warden):\n> \n> > Hello, I looked deeper into Chainlink VRF implementation and it turns my reasoning behind why the vulnerability happens in the poc video is not correct. Chainlink does custom gas checks (in the callback) but not in computing the requests so indeed it reverts with out-of-gas, however there is a small detail that the caller always retains 1/64th of the gas as per the solidity documentation note on `try{} catch{}` - https://docs.soliditylang.org/en/v0.8.19/control-structures.html#try-catch - quoting:\n>\n>> “The reason behind a failed call can be manifold. Do not assume that the error message is coming directly from the called contract: The error might have happened deeper down in the call chain and the called contract just forwarded it. Also, it could be due to an out-of-gas situation and not a deliberate error condition: The caller always retains at least 1/64th of the gas in a call and thus even if the called contract goes out of gas, the caller still has some gas left.”\n>\n> > In short, depending on how much the gasLimit was set at, in some situations there will be enough gas left to finish the `catch{}` clause although the try{} threw a out-of-gas error.\n>\n> > I also found a Consensys auditor that has documented in principle the exact same issue as in the contest implementation and confirms it happens due to 1/64 gas retention -  https://twitter.com/cleanunicorn/status/1574808522130194432?lang=en\n>\n> > Finally, I notified Rando about what I further found and also sent him Foundry traces of a successful malicious tx that reverts with out-of-gas but finishes execution of the `catch{}` clause, emits an event and leaves the protocol with cooldown.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-03-wenwin-contest",
  "Code": [
    {
      "filename": "src/RNSourceController.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// slither-disable-next-line solc-version\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport \"src/interfaces/IRNSource.sol\";\nimport \"src/interfaces/IRNSourceController.sol\";\n\n/// @dev A contract that controls the list of random number sources and dispatches random number requests to them.\nabstract contract RNSourceController is Ownable2Step, IRNSourceController {\n    IRNSource public override source;\n\n    uint256 public override failedSequentialAttempts;\n    uint256 public override maxFailedAttemptsReachedAt;\n    uint256 public override lastRequestTimestamp;\n    bool public override lastRequestFulfilled = true;\n    uint256 public immutable override maxFailedAttempts;\n    uint256 public immutable override maxRequestDelay;\n    uint256 private constant MAX_MAX_FAILED_ATTEMPTS = 10;\n    uint256 private constant MAX_REQUEST_DELAY = 5 hours;\n\n    /// @dev Constructs a new random number source controller.\n    /// @param _maxFailedAttempts The maximum number of sequential failed attempts to use a random number source before\n    /// it is removed from the list of sources\n    /// @param _maxRequestDelay The maximum delay between random number request and its fulfillment\n    constructor(uint256 _maxFailedAttempts, uint256 _maxRequestDelay) {\n        if (_maxFailedAttempts > MAX_MAX_FAILED_ATTEMPTS) {\n            revert MaxFailedAttemptsTooBig();\n        }\n        if (_maxRequestDelay > MAX_REQUEST_DELAY) {\n            revert MaxRequestDelayTooBig();\n        }\n        maxFailedAttempts = _maxFailedAttempts;\n        maxRequestDelay = _maxRequestDelay;\n    }\n\n    /// @dev Requests a random number from the current random number source.\n    function requestRandomNumber() internal {\n        if (!lastRequestFulfilled) {\n            revert PreviousRequestNotFulfilled();\n        }\n\n        requestRandomNumberFromSource();\n    }\n\n    function onRandomNumberFulfilled(uint256 randomNumber) external override {\n        if (msg.sender != address(source)) {\n            revert RandomNumberFulfillmentUnauthorized();\n        }\n\n        lastRequestFulfilled = true;\n        failedSequentialAttempts = 0;\n        maxFailedAttemptsReachedAt = 0;\n\n        receiveRandomNumber(randomNumber);\n    }\n\n    function receiveRandomNumber(uint256 randomNumber) internal virtual;\n\n    function retry() external override {\n        if (lastRequestFulfilled) {\n            revert CannotRetrySuccessfulRequest();\n        }\n        if (block.timestamp - lastRequestTimestamp <= maxRequestDelay) {\n            revert CurrentRequestStillActive();\n        }\n\n        uint256 failedAttempts = ++failedSequentialAttempts;\n        if (failedAttempts == maxFailedAttempts) {\n            maxFailedAttemptsReachedAt = block.timestamp;\n        }\n\n        emit Retry(source, failedSequentialAttempts);\n        requestRandomNumberFromSource();\n    }\n\n    function initSource(IRNSource rnSource) external override onlyOwner {\n        if (address(rnSource) == address(0)) {\n            revert RNSourceZeroAddress();\n        }\n        if (address(source) != address(0)) {\n            revert AlreadyInitialized();\n        }\n\n        source = rnSource;\n        emit SourceSet(rnSource);\n    }\n\n    function swapSource(IRNSource newSource) external override onlyOwner {\n        if (address(newSource) == address(0)) {\n            revert RNSourceZeroAddress();\n        }\n        bool notEnoughRetryInvocations = failedSequentialAttempts < maxFailedAttempts;\n        bool notEnoughTimeReachingMaxFailedAttempts = block.timestamp < maxFailedAttemptsReachedAt + maxRequestDelay;\n        if (notEnoughRetryInvocations || notEnoughTimeReachingMaxFailedAttempts) {\n            revert NotEnoughFailedAttempts();\n        }\n        source = newSource;\n        failedSequentialAttempts = 0;\n        maxFailedAttemptsReachedAt = 0;\n\n        emit SourceSet(newSource);\n        requestRandomNumberFromSource();\n    }\n\n    function requestRandomNumberFromSource() private {\n        lastRequestTimestamp = block.timestamp;\n        lastRequestFulfilled = false;\n\n        // slither-disable-start uninitialized-local\n        // See Slither issue: https://github.com/crytic/slither/issues/511\n        try source.requestRandomNumber() {\n            emit SuccessfulRNRequest(source);\n        } catch Error(string memory reason) {\n            emit FailedRNRequest(source, bytes(reason));\n        } catch (bytes memory reason) {\n            emit FailedRNRequest(source, reason);\n        }\n        // slither-disable-end uninitialized-local\n    }\n}"
    },
    {
      "filename": "src/RNSourceController.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// slither-disable-next-line solc-version\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport \"src/interfaces/IRNSource.sol\";\nimport \"src/interfaces/IRNSourceController.sol\";\n\n/// @dev A contract that controls the list of random number sources and dispatches random number requests to them.\nabstract contract RNSourceController is Ownable2Step, IRNSourceController {\n    IRNSource public override source;\n\n    uint256 public override failedSequentialAttempts;\n    uint256 public override maxFailedAttemptsReachedAt;\n    uint256 public override lastRequestTimestamp;\n    bool public override lastRequestFulfilled = true;\n    uint256 public immutable override maxFailedAttempts;\n    uint256 public immutable override maxRequestDelay;\n    uint256 private constant MAX_MAX_FAILED_ATTEMPTS = 10;\n    uint256 private constant MAX_REQUEST_DELAY = 5 hours;\n\n    /// @dev Constructs a new random number source controller.\n    /// @param _maxFailedAttempts The maximum number of sequential failed attempts to use a random number source before\n    /// it is removed from the list of sources\n    /// @param _maxRequestDelay The maximum delay between random number request and its fulfillment\n    constructor(uint256 _maxFailedAttempts, uint256 _maxRequestDelay) {\n        if (_maxFailedAttempts > MAX_MAX_FAILED_ATTEMPTS) {\n            revert MaxFailedAttemptsTooBig();\n        }\n        if (_maxRequestDelay > MAX_REQUEST_DELAY) {\n            revert MaxRequestDelayTooBig();\n        }\n        maxFailedAttempts = _maxFailedAttempts;\n        maxRequestDelay = _maxRequestDelay;\n    }\n\n    /// @dev Requests a random number from the current random number source.\n    function requestRandomNumber() internal {\n        if (!lastRequestFulfilled) {\n            revert PreviousRequestNotFulfilled();\n        }\n\n        requestRandomNumberFromSource();\n    }\n\n    function onRandomNumberFulfilled(uint256 randomNumber) external override {\n        if (msg.sender != address(source)) {\n            revert RandomNumberFulfillmentUnauthorized();\n        }\n\n        lastRequestFulfilled = true;\n        failedSequentialAttempts = 0;\n        maxFailedAttemptsReachedAt = 0;\n\n        receiveRandomNumber(randomNumber);\n    }\n\n    function receiveRandomNumber(uint256 randomNumber) internal virtual;\n\n    function retry() external override {\n        if (lastRequestFulfilled) {\n            revert CannotRetrySuccessfulRequest();\n        }\n        if (block.timestamp - lastRequestTimestamp <= maxRequestDelay) {\n            revert CurrentRequestStillActive();\n        }\n\n        uint256 failedAttempts = ++failedSequentialAttempts;\n        if (failedAttempts == maxFailedAttempts) {\n            maxFailedAttemptsReachedAt = block.timestamp;\n        }\n\n        emit Retry(source, failedSequentialAttempts);\n        requestRandomNumberFromSource();\n    }\n\n    function initSource(IRNSource rnSource) external override onlyOwner {\n        if (address(rnSource) == address(0)) {\n            revert RNSourceZeroAddress();\n        }\n        if (address(source) != address(0)) {\n            revert AlreadyInitialized();\n        }\n\n        source = rnSource;\n        emit SourceSet(rnSource);\n    }\n\n    function swapSource(IRNSource newSource) external override onlyOwner {\n        if (address(newSource) == address(0)) {\n            revert RNSourceZeroAddress();\n        }\n        bool notEnoughRetryInvocations = failedSequentialAttempts < maxFailedAttempts;\n        bool notEnoughTimeReachingMaxFailedAttempts = block.timestamp < maxFailedAttemptsReachedAt + maxRequestDelay;\n        if (notEnoughRetryInvocations || notEnoughTimeReachingMaxFailedAttempts) {\n            revert NotEnoughFailedAttempts();\n        }\n        source = newSource;\n        failedSequentialAttempts = 0;\n        maxFailedAttemptsReachedAt = 0;\n\n        emit SourceSet(newSource);\n        requestRandomNumberFromSource();\n    }\n\n    function requestRandomNumberFromSource() private {\n        lastRequestTimestamp = block.timestamp;\n        lastRequestFulfilled = false;\n\n        // slither-disable-start uninitialized-local\n        // See Slither issue: https://github.com/crytic/slither/issues/511\n        try source.requestRandomNumber() {\n            emit SuccessfulRNRequest(source);\n        } catch Error(string memory reason) {\n            emit FailedRNRequest(source, bytes(reason));\n        } catch (bytes memory reason) {\n            emit FailedRNRequest(source, reason);\n        }\n        // slither-disable-end uninitialized-local\n    }\n}"
    },
    {
      "filename": "src/RNSourceController.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// slither-disable-next-line solc-version\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport \"src/interfaces/IRNSource.sol\";\nimport \"src/interfaces/IRNSourceController.sol\";\n\n/// @dev A contract that controls the list of random number sources and dispatches random number requests to them.\nabstract contract RNSourceController is Ownable2Step, IRNSourceController {\n    IRNSource public override source;\n\n    uint256 public override failedSequentialAttempts;\n    uint256 public override maxFailedAttemptsReachedAt;\n    uint256 public override lastRequestTimestamp;\n    bool public override lastRequestFulfilled = true;\n    uint256 public immutable override maxFailedAttempts;\n    uint256 public immutable override maxRequestDelay;\n    uint256 private constant MAX_MAX_FAILED_ATTEMPTS = 10;\n    uint256 private constant MAX_REQUEST_DELAY = 5 hours;\n\n    /// @dev Constructs a new random number source controller.\n    /// @param _maxFailedAttempts The maximum number of sequential failed attempts to use a random number source before\n    /// it is removed from the list of sources\n    /// @param _maxRequestDelay The maximum delay between random number request and its fulfillment\n    constructor(uint256 _maxFailedAttempts, uint256 _maxRequestDelay) {\n        if (_maxFailedAttempts > MAX_MAX_FAILED_ATTEMPTS) {\n            revert MaxFailedAttemptsTooBig();\n        }\n        if (_maxRequestDelay > MAX_REQUEST_DELAY) {\n            revert MaxRequestDelayTooBig();\n        }\n        maxFailedAttempts = _maxFailedAttempts;\n        maxRequestDelay = _maxRequestDelay;\n    }\n\n    /// @dev Requests a random number from the current random number source.\n    function requestRandomNumber() internal {\n        if (!lastRequestFulfilled) {\n            revert PreviousRequestNotFulfilled();\n        }\n\n        requestRandomNumberFromSource();\n    }\n\n    function onRandomNumberFulfilled(uint256 randomNumber) external override {\n        if (msg.sender != address(source)) {\n            revert RandomNumberFulfillmentUnauthorized();\n        }\n\n        lastRequestFulfilled = true;\n        failedSequentialAttempts = 0;\n        maxFailedAttemptsReachedAt = 0;\n\n        receiveRandomNumber(randomNumber);\n    }\n\n    function receiveRandomNumber(uint256 randomNumber) internal virtual;\n\n    function retry() external override {\n        if (lastRequestFulfilled) {\n            revert CannotRetrySuccessfulRequest();\n        }\n        if (block.timestamp - lastRequestTimestamp <= maxRequestDelay) {\n            revert CurrentRequestStillActive();\n        }\n\n        uint256 failedAttempts = ++failedSequentialAttempts;\n        if (failedAttempts == maxFailedAttempts) {\n            maxFailedAttemptsReachedAt = block.timestamp;\n        }\n\n        emit Retry(source, failedSequentialAttempts);\n        requestRandomNumberFromSource();\n    }\n\n    function initSource(IRNSource rnSource) external override onlyOwner {\n        if (address(rnSource) == address(0)) {\n            revert RNSourceZeroAddress();\n        }\n        if (address(source) != address(0)) {\n            revert AlreadyInitialized();\n        }\n\n        source = rnSource;\n        emit SourceSet(rnSource);\n    }\n\n    function swapSource(IRNSource newSource) external override onlyOwner {\n        if (address(newSource) == address(0)) {\n            revert RNSourceZeroAddress();\n        }\n        bool notEnoughRetryInvocations = failedSequentialAttempts < maxFailedAttempts;\n        bool notEnoughTimeReachingMaxFailedAttempts = block.timestamp < maxFailedAttemptsReachedAt + maxRequestDelay;\n        if (notEnoughRetryInvocations || notEnoughTimeReachingMaxFailedAttempts) {\n            revert NotEnoughFailedAttempts();\n        }\n        source = newSource;\n        failedSequentialAttempts = 0;\n        maxFailedAttemptsReachedAt = 0;\n\n        emit SourceSet(newSource);\n        requestRandomNumberFromSource();\n    }\n\n    function requestRandomNumberFromSource() private {\n        lastRequestTimestamp = block.timestamp;\n        lastRequestFulfilled = false;\n\n        // slither-disable-start uninitialized-local\n        // See Slither issue: https://github.com/crytic/slither/issues/511\n        try source.requestRandomNumber() {\n            emit SuccessfulRNRequest(source);\n        } catch Error(string memory reason) {\n            emit FailedRNRequest(source, bytes(reason));\n        } catch (bytes memory reason) {\n            emit FailedRNRequest(source, reason);\n        }\n        // slither-disable-end uninitialized-local\n    }\n}"
    }
  ]
}