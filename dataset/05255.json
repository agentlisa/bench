{
  "Title": "[M-25] Incorrect assumption in PoolMath.sol can cause underflow when zapping is used",
  "Content": "\n[\\_zapSwapAmount()](https://github.com/code-423n4/2024-01-salty/blob/main/src/pools/PoolMath.sol#L191-L192) assumes that:\n\n```js\n191:\t\t// r1 * z0 guaranteed to be greater than r0 * z1 per the conditional check in _determineZapSwapAmount\n192:        uint256 C = r0 * ( r1 * z0 - r0 * z1 ) / ( r1 + z1 );\n```\n\nThe protocol's assumption of `r1 * z0 guaranteed to be greater than r0 * z1` is based on the following check in [\\_determineZapSwapAmount()](https://github.com/code-423n4/2024-01-salty/blob/main/src/pools/PoolMath.sol#L214-L220):\n\n```js\n214:\t\t// zapAmountA / zapAmountB exceeds the ratio of reserveA / reserveB? - meaning too much zapAmountA\n215:\t\tif ( zapAmountA * reserveB > reserveA * zapAmountB )\n216:\t\t\t(swapAmountA, swapAmountB) = (_zapSwapAmount( reserveA, reserveB, zapAmountA, zapAmountB ), 0);\n217:\n218:\t\t// zapAmountA / zapAmountB is less than the ratio of reserveA / reserveB? - meaning too much zapAmountB\n219:\t\tif ( zapAmountA * reserveB < reserveA * zapAmountB )\n220:\t\t\t(swapAmountA, swapAmountB) = (0, _zapSwapAmount( reserveB, reserveA, zapAmountB, zapAmountA ));\n```\n\nThe assumption would had been true for all cases if not for this piece of logic inside [\\_zapSwapAmount()#L158-L168](https://github.com/code-423n4/2024-01-salty/blob/main/src/pools/PoolMath.sol#L158-L168) which right shifts the arguments if the `maximumMSB` is greater than 80:\n\n```js\n    \t// Assumes the largest number has more than 80 bits - but if not then shifts zero effectively as a straight assignment.\n    \t// C will be calculated as: C = r0 * ( r1 * z0 - r0 * z1 ) / ( r1 + z1 );\n    \t// Multiplying three 80 bit numbers will yield 240 bits - within the 256 bit limit.\n\t\tif ( maximumMSB > 80 )\n\t\t\tshift = maximumMSB - 80;\n\n    \t// Normalize the inputs to 80 bits.\n    \tuint256 r0 = reserve0 >> shift;\n\t\tuint256 r1 = reserve1 >> shift;\n\t\tuint256 z0 = zapAmount0 >> shift;\n\t\tuint256 z1 = zapAmount1 >> shift;\n```\n\nThis can lead to `z0` being reduced to `0` and hence causing underflow on [L192](https://github.com/code-423n4/2024-01-salty/blob/main/src/pools/PoolMath.sol#LL192). <br>\n\nSince `_determineZapSwapAmount()` is internally called whenever `depositLiquidityAndIncreaseShare()` is called with `useZapping = true`, it will cause a revert when a situation like the following exists:\n\n```js\n        uint256 reserveA = 1500000000;\n        uint256 reserveB = 2000000000 ether;\n        uint256 zapAmountA = 150;\n        uint256 zapAmountB = 100 ether;\n```\n\n`maximumMSB` in this case is `90` (for `reserveB`) and also an excess of `zapAmountA` is being provided as compared to the existing reserve ratio. Hence, right shift by `90 - 80 = 10` bits will occur resulting `z0` to be `0`.\n\n### Proof of Concept\n\nCreate a new file `src/stable/tests/BugPoolMath.t.sol` and add the following code. Run it via `forge test -vv --mt test_poolMath` to see the test revert:\n\n```js\n// SPDX-License-Identifier: Unlicensed\npragma solidity =0.8.22;\n\nimport \"../../pools/PoolMath.sol\";\nimport { console, Test } from \"forge-std/Test.sol\";\n\ncontract BugPoolMath is Test\n{\n    function test_poolMath() public view {\n        uint256 reserveA = 1500000000;\n        uint256 reserveB = 2000000000 ether;\n        uint256 zapAmountA = 150;\n        uint256 zapAmountB = 100 ether;\n\n        (uint256 swapAmountA, uint256 swapAmountB) = PoolMath._determineZapSwapAmount(reserveA, reserveB, zapAmountA, zapAmountB);\n        console.log(\"swapAmountA = %s, swapAmountB = %s\", swapAmountA, swapAmountB);\n    }\n}\n```\n\n### Tools used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nMake sure to check the assertion again:\n\n<details>\n\n```diff\n    function _zapSwapAmount( uint256 reserve0, uint256 reserve1, uint256 zapAmount0, uint256 zapAmount1 ) internal pure returns (uint256 swapAmount)\n    \t{\n    \tuint256 maximumMSB = _maximumMSB( reserve0, reserve1, zapAmount0, zapAmount1);\n\n\t\tuint256 shift = 0;\n\n    \t// Assumes the largest number has more than 80 bits - but if not then shifts zero effectively as a straight assignment.\n    \t// C will be calculated as: C = r0 * ( r1 * z0 - r0 * z1 ) / ( r1 + z1 );\n    \t// Multiplying three 80 bit numbers will yield 240 bits - within the 256 bit limit.\n\t\tif ( maximumMSB > 80 )\n\t\t\tshift = maximumMSB - 80;\n\n    \t// Normalize the inputs to 80 bits.\n    \tuint256 r0 = reserve0 >> shift;\n\t\tuint256 r1 = reserve1 >> shift;\n\t\tuint256 z0 = zapAmount0 >> shift;\n\t\tuint256 z1 = zapAmount1 >> shift;\n\n\t\t// In order to swap and zap, require that the reduced precision reserves and one of the zapAmounts exceed DUST.\n\t\t// Otherwise their value was too small and was crushed by the above precision reduction and we should just return swapAmounts of zero so that default addLiquidity will be attempted without a preceding swap.\n        if ( r0 < PoolUtils.DUST)\n        \treturn 0;\n\n        if ( r1 < PoolUtils.DUST)\n        \treturn 0;\n\n        if ( z0 < PoolUtils.DUST)\n        if ( z1 < PoolUtils.DUST)\n        \treturn 0;\n\n        // Components of the quadratic formula mentioned in the initial comment block: x = [-B + sqrt(B^2 - 4AC)] / 2A\n\t\tuint256 A = 1;\n        uint256 B = 2 * r0;\n\n\t\t// Here for reference\n//        uint256 C = r0 * ( r0 * z1 - r1 * z0 ) / ( r1 + z1 );\n//        uint256 discriminant = B * B - 4 * A * C;\n\n-\t\t// Negate C (from above) and add instead of subtract.\n-\t\t// r1 * z0 guaranteed to be greater than r0 * z1 per the conditional check in _determineZapSwapAmount\n-       uint256 C = r0 * ( r1 * z0 - r0 * z1 ) / ( r1 + z1 );\n-       uint256 discriminant = B * B + 4 * A * C;\n+       uint256 C;\n+       uint256 discriminant;\n+       if ((r1 * z0) >= (r0 * z1)) {\n+           C = r0 * ( r1 * z0 - r0 * z1 ) / ( r1 + z1 );\n+           discriminant = B * B + 4 * A * C;\n+       } else {\n+           C = r0 * ( r0 * z1 - r1 * z0 ) / ( r1 + z1 );\n+           discriminant = B * B - 4 * A * C;\n+       }\n\n        // Compute the square root of the discriminant.\n        uint256 sqrtDiscriminant = Math.sqrt(discriminant);\n\n\t\t// Safety check: make sure B is not greater than sqrtDiscriminant\n\t\tif ( B > sqrtDiscriminant )\n\t\t\treturn 0;\n\n        // Only use the positive sqrt of the discriminant from: x = (-B +/- sqrtDiscriminant) / 2A\n\t\tswapAmount = ( sqrtDiscriminant - B ) / ( 2 * A );\n\n\t\t// Denormalize from the 80 bit representation\n\t\tswapAmount <<= shift;\n    \t}\n```\n</details>\n\n**[othernet-global (Salty.IO) confirmed and commented](https://github.com/code-423n4/2024-01-salty-findings/issues/232#issuecomment-1947945544):**\n > Zapping no longer uses scaling:\n> \n> https://github.com/othernet-global/salty-io/commit/44320a8cc9b94de433e437e025f072aa850b995a\n\n**Status:** Mitigation confirmed. Full details in reports from [zzebra83](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/106), [0xpiken](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/86), and [t0x1c](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/22).\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-01-salty",
  "Code": [
    {
      "filename": "src/pools/PoolMath.sol",
      "content": "pragma solidity =0.8.22;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\";\nimport \"openzeppelin-contracts/contracts/utils/math/Math.sol\";\nimport \"./interfaces/IPools.sol\";\nimport \"./PoolUtils.sol\";\n\n/*\n\t=== DERIVATION ===\n\t// User will zap z0 of token0 and z1 of token1 into the pool\n    // Initial reserves: r0 and r1\n    // Assuming z0 in excess, determine how much z0 should be swapped to z1 first so that the resulting z0/z1 matches the resulting post-swap reserves ratio so that liquidity can be added with minimal leftover.\n\n    // Initial k\n    k = r0 * r1\n\n    // Swap s0 of token0 for s1 of token1\n    s1 = r1 - k / (r0 + s0)\n\n    // Substituting k\n    s1 = r1 - r0 * r1 / (r0 + s0)\n\n    // Updated reserves ratio after swap\n    (r0 + s0) / ( r1 - s1)\n\n    // Adjusted addLiquidity zap amounts after the swap\n    a0 = z0 - s0\n    a1 = z1 + s1\n\n    // Adjusted addLiquidity amounts need to have the token ratio of the current reserves\n    a0 / a1 = (r0 + s0) / ( r1 - s1)\n\n    // Substitute in a0 and a1 from above\n    (z0 - s0) / ( z1 + s1) = (r0 + s0) / ( r1 - s1)\n\n    // Substitute\n    x = s0         y = s1\n    a = r0         b = r1\n    c = z0         d = z1\n\n    (c-x)/(d+y) = (a+x)/(b-y)\n\n    // From s1 = r1 - r0 * r1 / (r0 + s0)\n    y = b - ab/(a+x)\n\n    // Solve for x\n    (c-x)/(d+y) = (a+x)/(b-y)\n\n    // Cross multiply\n    (c-x)(b-y) = (a+x)(d+y)\n\n    // Multiply binomials on both sides\n    bc - cy - bx + xy = ad + ay + dx + xy\n\n    // Cancel xy both sides\n    bc - cy - bx = ad + ay + dx\n\n    // Multiply both sides by -1\n    - bc + cy + bx = - ad - ay - dx\n\n    // Gather x and y on the left\n    bx + dx + ay + cy = bc - ad\n\n    // Factor x and y\n    x(b+d) + y(a+c) = bc - ad\n\n    // Substitute y = b - ab/(a+x)\n    x(b+d) + b(a+c) - ab(a+c)/(a+x) = bc - ad\n\n    // Multiply by (a+x)\n    x(b+d)(a+x) + b(a+c)(a+x) - ab(a+c) = (bc - ad)(a+x)\n\n    // Multiply all binomials\n    x(ab+bx+ad+dx) + b(aa+ax+ac+cx) - aab - abc = abc+bcx-aad-adx\n\n    // Distribute x and b\n    abx+bxx+adx+dxx + aab+abx+abc+bcx - aab - abc = abc+bcx-aad-adx\n\n    // Cancel abc (on left), bcx, aab\n    abx + bxx + adx + dxx + abx = abc - aad - adx\n\n    // Gather x on the left\n    bxx + dxx + abx + abx + adx + adx = abc - aad\n\n    // Factor xx and x\n    xx(b+d) + x(2ab + 2ad) = abc - aad\n\n    // Quadratic equation\n    xx(b+d) + x(2ab + 2ad) + (aad-abc) = 0\n\n    // Factor out 2a\n    xx(b+d) + x(2a)(b+d) + (aad-abc) = 0\n\n    // Divide by (b+d)\n    xx + x(2a) + (aad-abc)/(b+d) = 0\n\n    xxA + xB + C = 0\n\n    A = 1\n    B = 2a\n    C = a(ad - bc)/(b+d)\n\n    // Substitute back\n    a = r0         b = r1\n    c = z0         d = z1\n\n    A = 1\n    B = 2r0\n    C = r0(r0z1 - r1z0)/(r1 + z1)\n\n    x = [-B + sqrt(B^2 - 4AC)] / 2A\n*/\n\nlibrary PoolMath\n\t{\n\t// Determine the most significant bit of a non-zero number\n    function _mostSignificantBit(uint256 x) internal pure returns (uint256 msb)\n    \t{\n        if (x >= 2**128) { x >>= 128; msb += 128; }\n        if (x >= 2**64) { x >>= 64; msb += 64; }\n        if (x >= 2**32) { x >>= 32; msb += 32; }\n        if (x >= 2**16) { x >>= 16; msb += 16; }\n        if (x >= 2**8) { x >>= 8; msb += 8; }\n        if (x >= 2**4) { x >>= 4; msb += 4; }\n        if (x >= 2**2) { x >>= 2; msb += 2; }\n        if (x >= 2**1) { x >>= 1; msb += 1; }\n\t    }\n\n\n\t// Determine the maximum msb across the given values\n\tfunction _maximumMSB( uint256 r0, uint256 r1, uint256 z0, uint256 z1 ) internal pure returns (uint256 msb)\n\t\t{\n\t\tmsb = _mostSignificantBit(r0);\n\n\t\tuint256 m = _mostSignificantBit(r1);\n\t\tif ( m > msb )\n\t\t\tmsb = m;\n\n\t\tm = _mostSignificantBit(z0);\n\t\tif ( m > msb )\n\t\t\tmsb = m;\n\n\t\tm = _mostSignificantBit(z1);\n\t\tif ( m > msb )\n\t\t\tmsb = m;\n\t\t}\n\n\n\t// Given initial reserves, and that the user wants to zap specified token amounts into the pool as liquidity,\n\t// determine how much of token0 needs to be swapped to token1 such that the liquidity added has the same proportion as the reserves in the pool after that swap.\n\t// Assumes that token0 is in excess (in regards to the current reserve ratio).\n    function _zapSwapAmount( uint256 reserve0, uint256 reserve1, uint256 zapAmount0, uint256 zapAmount1 ) internal pure returns (uint256 swapAmount)\n    \t{\n    \tuint256 maximumMSB = _maximumMSB( reserve0, reserve1, zapAmount0, zapAmount1);\n\n\t\tuint256 shift = 0;\n\n    \t// Assumes the largest number has more than 80 bits - but if not then shifts zero effectively as a straight assignment.\n    \t// C will be calculated as: C = r0 * ( r1 * z0 - r0 * z1 ) / ( r1 + z1 );\n    \t// Multiplying three 80 bit numbers will yield 240 bits - within the 256 bit limit.\n\t\tif ( maximumMSB > 80 )\n\t\t\tshift = maximumMSB - 80;\n\n    \t// Normalize the inputs to 80 bits.\n    \tuint256 r0 = reserve0 >> shift;\n\t\tuint256 r1 = reserve1 >> shift;\n\t\tuint256 z0 = zapAmount0 >> shift;\n\t\tuint256 z1 = zapAmount1 >> shift;\n\n\t\t// In order to swap and zap, require that the reduced precision reserves and one of the zapAmounts exceed DUST.\n\t\t// Otherwise their value was too small and was crushed by the above precision reduction and we should just return swapAmounts of zero so that default addLiquidity will be attempted without a preceding swap.\n        if ( r0 < PoolUtils.DUST)\n        \treturn 0;\n\n        if ( r1 < PoolUtils.DUST)\n        \treturn 0;\n\n        if ( z0 < PoolUtils.DUST)\n        if ( z1 < PoolUtils.DUST)\n        \treturn 0;\n\n        // Components of the quadratic formula mentioned in the initial comment block: x = [-B + sqrt(B^2 - 4AC)] / 2A\n\t\tuint256 A = 1;\n        uint256 B = 2 * r0;\n\n\t\t// Here for reference\n//        uint256 C = r0 * ( r0 * z1 - r1 * z0 ) / ( r1 + z1 );\n//        uint256 discriminant = B * B - 4 * A * C;\n\n\t\t// Negate C (from above) and add instead of subtract.\n\t\t// r1 * z0 guaranteed to be greater than r0 * z1 per the conditional check in _determineZapSwapAmount\n        uint256 C = r0 * ( r1 * z0 - r0 * z1 ) / ( r1 + z1 );\n        uint256 discriminant = B * B + 4 * A * C;\n\n        // Compute the square root of the discriminant.\n        uint256 sqrtDiscriminant = Math.sqrt(discriminant);\n\n\t\t// Safety check: make sure B is not greater than sqrtDiscriminant\n\t\tif ( B > sqrtDiscriminant )\n\t\t\treturn 0;\n\n        // Only use the positive sqrt of the discriminant from: x = (-B +/- sqrtDiscriminant) / 2A\n\t\tswapAmount = ( sqrtDiscriminant - B ) / ( 2 * A );\n\n\t\t// Denormalize from the 80 bit representation\n\t\tswapAmount <<= shift;\n    \t}\n\n\n\t// Determine how much of either token needs to be swapped to give them a ratio equivalent to the reserves.\n\t// If (0,0) is returned it signifies that no swap should be done before the addLiquidity.\n\tfunction _determineZapSwapAmount( uint256 reserveA, uint256 reserveB, uint256 zapAmountA, uint256 zapAmountB ) internal pure returns (uint256 swapAmountA, uint256 swapAmountB )\n\t\t{\n\t\t// zapAmountA / zapAmountB exceeds the ratio of reserveA / reserveB? - meaning too much zapAmountA\n\t\tif ( zapAmountA * reserveB > reserveA * zapAmountB )\n\t\t\t(swapAmountA, swapAmountB) = (_zapSwapAmount( reserveA, reserveB, zapAmountA, zapAmountB ), 0);\n\n\t\t// zapAmountA / zapAmountB is less than the ratio of reserveA / reserveB? - meaning too much zapAmountB\n\t\tif ( zapAmountA * reserveB < reserveA * zapAmountB )\n\t\t\t(swapAmountA, swapAmountB) = (0, _zapSwapAmount( reserveB, reserveA, zapAmountB, zapAmountA ));\n\n\t\t// Ensure we are not swapping more than was specified for zapping\n\t\tif ( ( swapAmountA > zapAmountA ) || ( swapAmountB > zapAmountB ) )\n\t\t\treturn (0, 0);\n\n\t\treturn (swapAmountA, swapAmountB);\n\t\t}\n\t}"
    },
    {
      "filename": "src/pools/PoolMath.sol",
      "content": "pragma solidity =0.8.22;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\";\nimport \"openzeppelin-contracts/contracts/utils/math/Math.sol\";\nimport \"./interfaces/IPools.sol\";\nimport \"./PoolUtils.sol\";\n\n/*\n\t=== DERIVATION ===\n\t// User will zap z0 of token0 and z1 of token1 into the pool\n    // Initial reserves: r0 and r1\n    // Assuming z0 in excess, determine how much z0 should be swapped to z1 first so that the resulting z0/z1 matches the resulting post-swap reserves ratio so that liquidity can be added with minimal leftover.\n\n    // Initial k\n    k = r0 * r1\n\n    // Swap s0 of token0 for s1 of token1\n    s1 = r1 - k / (r0 + s0)\n\n    // Substituting k\n    s1 = r1 - r0 * r1 / (r0 + s0)\n\n    // Updated reserves ratio after swap\n    (r0 + s0) / ( r1 - s1)\n\n    // Adjusted addLiquidity zap amounts after the swap\n    a0 = z0 - s0\n    a1 = z1 + s1\n\n    // Adjusted addLiquidity amounts need to have the token ratio of the current reserves\n    a0 / a1 = (r0 + s0) / ( r1 - s1)\n\n    // Substitute in a0 and a1 from above\n    (z0 - s0) / ( z1 + s1) = (r0 + s0) / ( r1 - s1)\n\n    // Substitute\n    x = s0         y = s1\n    a = r0         b = r1\n    c = z0         d = z1\n\n    (c-x)/(d+y) = (a+x)/(b-y)\n\n    // From s1 = r1 - r0 * r1 / (r0 + s0)\n    y = b - ab/(a+x)\n\n    // Solve for x\n    (c-x)/(d+y) = (a+x)/(b-y)\n\n    // Cross multiply\n    (c-x)(b-y) = (a+x)(d+y)\n\n    // Multiply binomials on both sides\n    bc - cy - bx + xy = ad + ay + dx + xy\n\n    // Cancel xy both sides\n    bc - cy - bx = ad + ay + dx\n\n    // Multiply both sides by -1\n    - bc + cy + bx = - ad - ay - dx\n\n    // Gather x and y on the left\n    bx + dx + ay + cy = bc - ad\n\n    // Factor x and y\n    x(b+d) + y(a+c) = bc - ad\n\n    // Substitute y = b - ab/(a+x)\n    x(b+d) + b(a+c) - ab(a+c)/(a+x) = bc - ad\n\n    // Multiply by (a+x)\n    x(b+d)(a+x) + b(a+c)(a+x) - ab(a+c) = (bc - ad)(a+x)\n\n    // Multiply all binomials\n    x(ab+bx+ad+dx) + b(aa+ax+ac+cx) - aab - abc = abc+bcx-aad-adx\n\n    // Distribute x and b\n    abx+bxx+adx+dxx + aab+abx+abc+bcx - aab - abc = abc+bcx-aad-adx\n\n    // Cancel abc (on left), bcx, aab\n    abx + bxx + adx + dxx + abx = abc - aad - adx\n\n    // Gather x on the left\n    bxx + dxx + abx + abx + adx + adx = abc - aad\n\n    // Factor xx and x\n    xx(b+d) + x(2ab + 2ad) = abc - aad\n\n    // Quadratic equation\n    xx(b+d) + x(2ab + 2ad) + (aad-abc) = 0\n\n    // Factor out 2a\n    xx(b+d) + x(2a)(b+d) + (aad-abc) = 0\n\n    // Divide by (b+d)\n    xx + x(2a) + (aad-abc)/(b+d) = 0\n\n    xxA + xB + C = 0\n\n    A = 1\n    B = 2a\n    C = a(ad - bc)/(b+d)\n\n    // Substitute back\n    a = r0         b = r1\n    c = z0         d = z1\n\n    A = 1\n    B = 2r0\n    C = r0(r0z1 - r1z0)/(r1 + z1)\n\n    x = [-B + sqrt(B^2 - 4AC)] / 2A\n*/\n\nlibrary PoolMath\n\t{\n\t// Determine the most significant bit of a non-zero number\n    function _mostSignificantBit(uint256 x) internal pure returns (uint256 msb)\n    \t{\n        if (x >= 2**128) { x >>= 128; msb += 128; }\n        if (x >= 2**64) { x >>= 64; msb += 64; }\n        if (x >= 2**32) { x >>= 32; msb += 32; }\n        if (x >= 2**16) { x >>= 16; msb += 16; }\n        if (x >= 2**8) { x >>= 8; msb += 8; }\n        if (x >= 2**4) { x >>= 4; msb += 4; }\n        if (x >= 2**2) { x >>= 2; msb += 2; }\n        if (x >= 2**1) { x >>= 1; msb += 1; }\n\t    }\n\n\n\t// Determine the maximum msb across the given values\n\tfunction _maximumMSB( uint256 r0, uint256 r1, uint256 z0, uint256 z1 ) internal pure returns (uint256 msb)\n\t\t{\n\t\tmsb = _mostSignificantBit(r0);\n\n\t\tuint256 m = _mostSignificantBit(r1);\n\t\tif ( m > msb )\n\t\t\tmsb = m;\n\n\t\tm = _mostSignificantBit(z0);\n\t\tif ( m > msb )\n\t\t\tmsb = m;\n\n\t\tm = _mostSignificantBit(z1);\n\t\tif ( m > msb )\n\t\t\tmsb = m;\n\t\t}\n\n\n\t// Given initial reserves, and that the user wants to zap specified token amounts into the pool as liquidity,\n\t// determine how much of token0 needs to be swapped to token1 such that the liquidity added has the same proportion as the reserves in the pool after that swap.\n\t// Assumes that token0 is in excess (in regards to the current reserve ratio).\n    function _zapSwapAmount( uint256 reserve0, uint256 reserve1, uint256 zapAmount0, uint256 zapAmount1 ) internal pure returns (uint256 swapAmount)\n    \t{\n    \tuint256 maximumMSB = _maximumMSB( reserve0, reserve1, zapAmount0, zapAmount1);\n\n\t\tuint256 shift = 0;\n\n    \t// Assumes the largest number has more than 80 bits - but if not then shifts zero effectively as a straight assignment.\n    \t// C will be calculated as: C = r0 * ( r1 * z0 - r0 * z1 ) / ( r1 + z1 );\n    \t// Multiplying three 80 bit numbers will yield 240 bits - within the 256 bit limit.\n\t\tif ( maximumMSB > 80 )\n\t\t\tshift = maximumMSB - 80;\n\n    \t// Normalize the inputs to 80 bits.\n    \tuint256 r0 = reserve0 >> shift;\n\t\tuint256 r1 = reserve1 >> shift;\n\t\tuint256 z0 = zapAmount0 >> shift;\n\t\tuint256 z1 = zapAmount1 >> shift;\n\n\t\t// In order to swap and zap, require that the reduced precision reserves and one of the zapAmounts exceed DUST.\n\t\t// Otherwise their value was too small and was crushed by the above precision reduction and we should just return swapAmounts of zero so that default addLiquidity will be attempted without a preceding swap.\n        if ( r0 < PoolUtils.DUST)\n        \treturn 0;\n\n        if ( r1 < PoolUtils.DUST)\n        \treturn 0;\n\n        if ( z0 < PoolUtils.DUST)\n        if ( z1 < PoolUtils.DUST)\n        \treturn 0;\n\n        // Components of the quadratic formula mentioned in the initial comment block: x = [-B + sqrt(B^2 - 4AC)] / 2A\n\t\tuint256 A = 1;\n        uint256 B = 2 * r0;\n\n\t\t// Here for reference\n//        uint256 C = r0 * ( r0 * z1 - r1 * z0 ) / ( r1 + z1 );\n//        uint256 discriminant = B * B - 4 * A * C;\n\n\t\t// Negate C (from above) and add instead of subtract.\n\t\t// r1 * z0 guaranteed to be greater than r0 * z1 per the conditional check in _determineZapSwapAmount\n        uint256 C = r0 * ( r1 * z0 - r0 * z1 ) / ( r1 + z1 );\n        uint256 discriminant = B * B + 4 * A * C;\n\n        // Compute the square root of the discriminant.\n        uint256 sqrtDiscriminant = Math.sqrt(discriminant);\n\n\t\t// Safety check: make sure B is not greater than sqrtDiscriminant\n\t\tif ( B > sqrtDiscriminant )\n\t\t\treturn 0;\n\n        // Only use the positive sqrt of the discriminant from: x = (-B +/- sqrtDiscriminant) / 2A\n\t\tswapAmount = ( sqrtDiscriminant - B ) / ( 2 * A );\n\n\t\t// Denormalize from the 80 bit representation\n\t\tswapAmount <<= shift;\n    \t}\n\n\n\t// Determine how much of either token needs to be swapped to give them a ratio equivalent to the reserves.\n\t// If (0,0) is returned it signifies that no swap should be done before the addLiquidity.\n\tfunction _determineZapSwapAmount( uint256 reserveA, uint256 reserveB, uint256 zapAmountA, uint256 zapAmountB ) internal pure returns (uint256 swapAmountA, uint256 swapAmountB )\n\t\t{\n\t\t// zapAmountA / zapAmountB exceeds the ratio of reserveA / reserveB? - meaning too much zapAmountA\n\t\tif ( zapAmountA * reserveB > reserveA * zapAmountB )\n\t\t\t(swapAmountA, swapAmountB) = (_zapSwapAmount( reserveA, reserveB, zapAmountA, zapAmountB ), 0);\n\n\t\t// zapAmountA / zapAmountB is less than the ratio of reserveA / reserveB? - meaning too much zapAmountB\n\t\tif ( zapAmountA * reserveB < reserveA * zapAmountB )\n\t\t\t(swapAmountA, swapAmountB) = (0, _zapSwapAmount( reserveB, reserveA, zapAmountB, zapAmountA ));\n\n\t\t// Ensure we are not swapping more than was specified for zapping\n\t\tif ( ( swapAmountA > zapAmountA ) || ( swapAmountB > zapAmountB ) )\n\t\t\treturn (0, 0);\n\n\t\treturn (swapAmountA, swapAmountB);\n\t\t}\n\t}"
    },
    {
      "filename": "src/pools/PoolMath.sol",
      "content": "pragma solidity =0.8.22;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\";\nimport \"openzeppelin-contracts/contracts/utils/math/Math.sol\";\nimport \"./interfaces/IPools.sol\";\nimport \"./PoolUtils.sol\";\n\n/*\n\t=== DERIVATION ===\n\t// User will zap z0 of token0 and z1 of token1 into the pool\n    // Initial reserves: r0 and r1\n    // Assuming z0 in excess, determine how much z0 should be swapped to z1 first so that the resulting z0/z1 matches the resulting post-swap reserves ratio so that liquidity can be added with minimal leftover.\n\n    // Initial k\n    k = r0 * r1\n\n    // Swap s0 of token0 for s1 of token1\n    s1 = r1 - k / (r0 + s0)\n\n    // Substituting k\n    s1 = r1 - r0 * r1 / (r0 + s0)\n\n    // Updated reserves ratio after swap\n    (r0 + s0) / ( r1 - s1)\n\n    // Adjusted addLiquidity zap amounts after the swap\n    a0 = z0 - s0\n    a1 = z1 + s1\n\n    // Adjusted addLiquidity amounts need to have the token ratio of the current reserves\n    a0 / a1 = (r0 + s0) / ( r1 - s1)\n\n    // Substitute in a0 and a1 from above\n    (z0 - s0) / ( z1 + s1) = (r0 + s0) / ( r1 - s1)\n\n    // Substitute\n    x = s0         y = s1\n    a = r0         b = r1\n    c = z0         d = z1\n\n    (c-x)/(d+y) = (a+x)/(b-y)\n\n    // From s1 = r1 - r0 * r1 / (r0 + s0)\n    y = b - ab/(a+x)\n\n    // Solve for x\n    (c-x)/(d+y) = (a+x)/(b-y)\n\n    // Cross multiply\n    (c-x)(b-y) = (a+x)(d+y)\n\n    // Multiply binomials on both sides\n    bc - cy - bx + xy = ad + ay + dx + xy\n\n    // Cancel xy both sides\n    bc - cy - bx = ad + ay + dx\n\n    // Multiply both sides by -1\n    - bc + cy + bx = - ad - ay - dx\n\n    // Gather x and y on the left\n    bx + dx + ay + cy = bc - ad\n\n    // Factor x and y\n    x(b+d) + y(a+c) = bc - ad\n\n    // Substitute y = b - ab/(a+x)\n    x(b+d) + b(a+c) - ab(a+c)/(a+x) = bc - ad\n\n    // Multiply by (a+x)\n    x(b+d)(a+x) + b(a+c)(a+x) - ab(a+c) = (bc - ad)(a+x)\n\n    // Multiply all binomials\n    x(ab+bx+ad+dx) + b(aa+ax+ac+cx) - aab - abc = abc+bcx-aad-adx\n\n    // Distribute x and b\n    abx+bxx+adx+dxx + aab+abx+abc+bcx - aab - abc = abc+bcx-aad-adx\n\n    // Cancel abc (on left), bcx, aab\n    abx + bxx + adx + dxx + abx = abc - aad - adx\n\n    // Gather x on the left\n    bxx + dxx + abx + abx + adx + adx = abc - aad\n\n    // Factor xx and x\n    xx(b+d) + x(2ab + 2ad) = abc - aad\n\n    // Quadratic equation\n    xx(b+d) + x(2ab + 2ad) + (aad-abc) = 0\n\n    // Factor out 2a\n    xx(b+d) + x(2a)(b+d) + (aad-abc) = 0\n\n    // Divide by (b+d)\n    xx + x(2a) + (aad-abc)/(b+d) = 0\n\n    xxA + xB + C = 0\n\n    A = 1\n    B = 2a\n    C = a(ad - bc)/(b+d)\n\n    // Substitute back\n    a = r0         b = r1\n    c = z0         d = z1\n\n    A = 1\n    B = 2r0\n    C = r0(r0z1 - r1z0)/(r1 + z1)\n\n    x = [-B + sqrt(B^2 - 4AC)] / 2A\n*/\n\nlibrary PoolMath\n\t{\n\t// Determine the most significant bit of a non-zero number\n    function _mostSignificantBit(uint256 x) internal pure returns (uint256 msb)\n    \t{\n        if (x >= 2**128) { x >>= 128; msb += 128; }\n        if (x >= 2**64) { x >>= 64; msb += 64; }\n        if (x >= 2**32) { x >>= 32; msb += 32; }\n        if (x >= 2**16) { x >>= 16; msb += 16; }\n        if (x >= 2**8) { x >>= 8; msb += 8; }\n        if (x >= 2**4) { x >>= 4; msb += 4; }\n        if (x >= 2**2) { x >>= 2; msb += 2; }\n        if (x >= 2**1) { x >>= 1; msb += 1; }\n\t    }\n\n\n\t// Determine the maximum msb across the given values\n\tfunction _maximumMSB( uint256 r0, uint256 r1, uint256 z0, uint256 z1 ) internal pure returns (uint256 msb)\n\t\t{\n\t\tmsb = _mostSignificantBit(r0);\n\n\t\tuint256 m = _mostSignificantBit(r1);\n\t\tif ( m > msb )\n\t\t\tmsb = m;\n\n\t\tm = _mostSignificantBit(z0);\n\t\tif ( m > msb )\n\t\t\tmsb = m;\n\n\t\tm = _mostSignificantBit(z1);\n\t\tif ( m > msb )\n\t\t\tmsb = m;\n\t\t}\n\n\n\t// Given initial reserves, and that the user wants to zap specified token amounts into the pool as liquidity,\n\t// determine how much of token0 needs to be swapped to token1 such that the liquidity added has the same proportion as the reserves in the pool after that swap.\n\t// Assumes that token0 is in excess (in regards to the current reserve ratio).\n    function _zapSwapAmount( uint256 reserve0, uint256 reserve1, uint256 zapAmount0, uint256 zapAmount1 ) internal pure returns (uint256 swapAmount)\n    \t{\n    \tuint256 maximumMSB = _maximumMSB( reserve0, reserve1, zapAmount0, zapAmount1);\n\n\t\tuint256 shift = 0;\n\n    \t// Assumes the largest number has more than 80 bits - but if not then shifts zero effectively as a straight assignment.\n    \t// C will be calculated as: C = r0 * ( r1 * z0 - r0 * z1 ) / ( r1 + z1 );\n    \t// Multiplying three 80 bit numbers will yield 240 bits - within the 256 bit limit.\n\t\tif ( maximumMSB > 80 )\n\t\t\tshift = maximumMSB - 80;\n\n    \t// Normalize the inputs to 80 bits.\n    \tuint256 r0 = reserve0 >> shift;\n\t\tuint256 r1 = reserve1 >> shift;\n\t\tuint256 z0 = zapAmount0 >> shift;\n\t\tuint256 z1 = zapAmount1 >> shift;\n\n\t\t// In order to swap and zap, require that the reduced precision reserves and one of the zapAmounts exceed DUST.\n\t\t// Otherwise their value was too small and was crushed by the above precision reduction and we should just return swapAmounts of zero so that default addLiquidity will be attempted without a preceding swap.\n        if ( r0 < PoolUtils.DUST)\n        \treturn 0;\n\n        if ( r1 < PoolUtils.DUST)\n        \treturn 0;\n\n        if ( z0 < PoolUtils.DUST)\n        if ( z1 < PoolUtils.DUST)\n        \treturn 0;\n\n        // Components of the quadratic formula mentioned in the initial comment block: x = [-B + sqrt(B^2 - 4AC)] / 2A\n\t\tuint256 A = 1;\n        uint256 B = 2 * r0;\n\n\t\t// Here for reference\n//        uint256 C = r0 * ( r0 * z1 - r1 * z0 ) / ( r1 + z1 );\n//        uint256 discriminant = B * B - 4 * A * C;\n\n\t\t// Negate C (from above) and add instead of subtract.\n\t\t// r1 * z0 guaranteed to be greater than r0 * z1 per the conditional check in _determineZapSwapAmount\n        uint256 C = r0 * ( r1 * z0 - r0 * z1 ) / ( r1 + z1 );\n        uint256 discriminant = B * B + 4 * A * C;\n\n        // Compute the square root of the discriminant.\n        uint256 sqrtDiscriminant = Math.sqrt(discriminant);\n\n\t\t// Safety check: make sure B is not greater than sqrtDiscriminant\n\t\tif ( B > sqrtDiscriminant )\n\t\t\treturn 0;\n\n        // Only use the positive sqrt of the discriminant from: x = (-B +/- sqrtDiscriminant) / 2A\n\t\tswapAmount = ( sqrtDiscriminant - B ) / ( 2 * A );\n\n\t\t// Denormalize from the 80 bit representation\n\t\tswapAmount <<= shift;\n    \t}\n\n\n\t// Determine how much of either token needs to be swapped to give them a ratio equivalent to the reserves.\n\t// If (0,0) is returned it signifies that no swap should be done before the addLiquidity.\n\tfunction _determineZapSwapAmount( uint256 reserveA, uint256 reserveB, uint256 zapAmountA, uint256 zapAmountB ) internal pure returns (uint256 swapAmountA, uint256 swapAmountB )\n\t\t{\n\t\t// zapAmountA / zapAmountB exceeds the ratio of reserveA / reserveB? - meaning too much zapAmountA\n\t\tif ( zapAmountA * reserveB > reserveA * zapAmountB )\n\t\t\t(swapAmountA, swapAmountB) = (_zapSwapAmount( reserveA, reserveB, zapAmountA, zapAmountB ), 0);\n\n\t\t// zapAmountA / zapAmountB is less than the ratio of reserveA / reserveB? - meaning too much zapAmountB\n\t\tif ( zapAmountA * reserveB < reserveA * zapAmountB )\n\t\t\t(swapAmountA, swapAmountB) = (0, _zapSwapAmount( reserveB, reserveA, zapAmountB, zapAmountA ));\n\n\t\t// Ensure we are not swapping more than was specified for zapping\n\t\tif ( ( swapAmountA > zapAmountA ) || ( swapAmountB > zapAmountB ) )\n\t\t\treturn (0, 0);\n\n\t\treturn (swapAmountA, swapAmountB);\n\t\t}\n\t}"
    },
    {
      "filename": "src/pools/PoolMath.sol",
      "content": "pragma solidity =0.8.22;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\";\nimport \"openzeppelin-contracts/contracts/utils/math/Math.sol\";\nimport \"./interfaces/IPools.sol\";\nimport \"./PoolUtils.sol\";\n\n/*\n\t=== DERIVATION ===\n\t// User will zap z0 of token0 and z1 of token1 into the pool\n    // Initial reserves: r0 and r1\n    // Assuming z0 in excess, determine how much z0 should be swapped to z1 first so that the resulting z0/z1 matches the resulting post-swap reserves ratio so that liquidity can be added with minimal leftover.\n\n    // Initial k\n    k = r0 * r1\n\n    // Swap s0 of token0 for s1 of token1\n    s1 = r1 - k / (r0 + s0)\n\n    // Substituting k\n    s1 = r1 - r0 * r1 / (r0 + s0)\n\n    // Updated reserves ratio after swap\n    (r0 + s0) / ( r1 - s1)\n\n    // Adjusted addLiquidity zap amounts after the swap\n    a0 = z0 - s0\n    a1 = z1 + s1\n\n    // Adjusted addLiquidity amounts need to have the token ratio of the current reserves\n    a0 / a1 = (r0 + s0) / ( r1 - s1)\n\n    // Substitute in a0 and a1 from above\n    (z0 - s0) / ( z1 + s1) = (r0 + s0) / ( r1 - s1)\n\n    // Substitute\n    x = s0         y = s1\n    a = r0         b = r1\n    c = z0         d = z1\n\n    (c-x)/(d+y) = (a+x)/(b-y)\n\n    // From s1 = r1 - r0 * r1 / (r0 + s0)\n    y = b - ab/(a+x)\n\n    // Solve for x\n    (c-x)/(d+y) = (a+x)/(b-y)\n\n    // Cross multiply\n    (c-x)(b-y) = (a+x)(d+y)\n\n    // Multiply binomials on both sides\n    bc - cy - bx + xy = ad + ay + dx + xy\n\n    // Cancel xy both sides\n    bc - cy - bx = ad + ay + dx\n\n    // Multiply both sides by -1\n    - bc + cy + bx = - ad - ay - dx\n\n    // Gather x and y on the left\n    bx + dx + ay + cy = bc - ad\n\n    // Factor x and y\n    x(b+d) + y(a+c) = bc - ad\n\n    // Substitute y = b - ab/(a+x)\n    x(b+d) + b(a+c) - ab(a+c)/(a+x) = bc - ad\n\n    // Multiply by (a+x)\n    x(b+d)(a+x) + b(a+c)(a+x) - ab(a+c) = (bc - ad)(a+x)\n\n    // Multiply all binomials\n    x(ab+bx+ad+dx) + b(aa+ax+ac+cx) - aab - abc = abc+bcx-aad-adx\n\n    // Distribute x and b\n    abx+bxx+adx+dxx + aab+abx+abc+bcx - aab - abc = abc+bcx-aad-adx\n\n    // Cancel abc (on left), bcx, aab\n    abx + bxx + adx + dxx + abx = abc - aad - adx\n\n    // Gather x on the left\n    bxx + dxx + abx + abx + adx + adx = abc - aad\n\n    // Factor xx and x\n    xx(b+d) + x(2ab + 2ad) = abc - aad\n\n    // Quadratic equation\n    xx(b+d) + x(2ab + 2ad) + (aad-abc) = 0\n\n    // Factor out 2a\n    xx(b+d) + x(2a)(b+d) + (aad-abc) = 0\n\n    // Divide by (b+d)\n    xx + x(2a) + (aad-abc)/(b+d) = 0\n\n    xxA + xB + C = 0\n\n    A = 1\n    B = 2a\n    C = a(ad - bc)/(b+d)\n\n    // Substitute back\n    a = r0         b = r1\n    c = z0         d = z1\n\n    A = 1\n    B = 2r0\n    C = r0(r0z1 - r1z0)/(r1 + z1)\n\n    x = [-B + sqrt(B^2 - 4AC)] / 2A\n*/\n\nlibrary PoolMath\n\t{\n\t// Determine the most significant bit of a non-zero number\n    function _mostSignificantBit(uint256 x) internal pure returns (uint256 msb)\n    \t{\n        if (x >= 2**128) { x >>= 128; msb += 128; }\n        if (x >= 2**64) { x >>= 64; msb += 64; }\n        if (x >= 2**32) { x >>= 32; msb += 32; }\n        if (x >= 2**16) { x >>= 16; msb += 16; }\n        if (x >= 2**8) { x >>= 8; msb += 8; }\n        if (x >= 2**4) { x >>= 4; msb += 4; }\n        if (x >= 2**2) { x >>= 2; msb += 2; }\n        if (x >= 2**1) { x >>= 1; msb += 1; }\n\t    }\n\n\n\t// Determine the maximum msb across the given values\n\tfunction _maximumMSB( uint256 r0, uint256 r1, uint256 z0, uint256 z1 ) internal pure returns (uint256 msb)\n\t\t{\n\t\tmsb = _mostSignificantBit(r0);\n\n\t\tuint256 m = _mostSignificantBit(r1);\n\t\tif ( m > msb )\n\t\t\tmsb = m;\n\n\t\tm = _mostSignificantBit(z0);\n\t\tif ( m > msb )\n\t\t\tmsb = m;\n\n\t\tm = _mostSignificantBit(z1);\n\t\tif ( m > msb )\n\t\t\tmsb = m;\n\t\t}\n\n\n\t// Given initial reserves, and that the user wants to zap specified token amounts into the pool as liquidity,\n\t// determine how much of token0 needs to be swapped to token1 such that the liquidity added has the same proportion as the reserves in the pool after that swap.\n\t// Assumes that token0 is in excess (in regards to the current reserve ratio).\n    function _zapSwapAmount( uint256 reserve0, uint256 reserve1, uint256 zapAmount0, uint256 zapAmount1 ) internal pure returns (uint256 swapAmount)\n    \t{\n    \tuint256 maximumMSB = _maximumMSB( reserve0, reserve1, zapAmount0, zapAmount1);\n\n\t\tuint256 shift = 0;\n\n    \t// Assumes the largest number has more than 80 bits - but if not then shifts zero effectively as a straight assignment.\n    \t// C will be calculated as: C = r0 * ( r1 * z0 - r0 * z1 ) / ( r1 + z1 );\n    \t// Multiplying three 80 bit numbers will yield 240 bits - within the 256 bit limit.\n\t\tif ( maximumMSB > 80 )\n\t\t\tshift = maximumMSB - 80;\n\n    \t// Normalize the inputs to 80 bits.\n    \tuint256 r0 = reserve0 >> shift;\n\t\tuint256 r1 = reserve1 >> shift;\n\t\tuint256 z0 = zapAmount0 >> shift;\n\t\tuint256 z1 = zapAmount1 >> shift;\n\n\t\t// In order to swap and zap, require that the reduced precision reserves and one of the zapAmounts exceed DUST.\n\t\t// Otherwise their value was too small and was crushed by the above precision reduction and we should just return swapAmounts of zero so that default addLiquidity will be attempted without a preceding swap.\n        if ( r0 < PoolUtils.DUST)\n        \treturn 0;\n\n        if ( r1 < PoolUtils.DUST)\n        \treturn 0;\n\n        if ( z0 < PoolUtils.DUST)\n        if ( z1 < PoolUtils.DUST)\n        \treturn 0;\n\n        // Components of the quadratic formula mentioned in the initial comment block: x = [-B + sqrt(B^2 - 4AC)] / 2A\n\t\tuint256 A = 1;\n        uint256 B = 2 * r0;\n\n\t\t// Here for reference\n//        uint256 C = r0 * ( r0 * z1 - r1 * z0 ) / ( r1 + z1 );\n//        uint256 discriminant = B * B - 4 * A * C;\n\n\t\t// Negate C (from above) and add instead of subtract.\n\t\t// r1 * z0 guaranteed to be greater than r0 * z1 per the conditional check in _determineZapSwapAmount\n        uint256 C = r0 * ( r1 * z0 - r0 * z1 ) / ( r1 + z1 );\n        uint256 discriminant = B * B + 4 * A * C;\n\n        // Compute the square root of the discriminant.\n        uint256 sqrtDiscriminant = Math.sqrt(discriminant);\n\n\t\t// Safety check: make sure B is not greater than sqrtDiscriminant\n\t\tif ( B > sqrtDiscriminant )\n\t\t\treturn 0;\n\n        // Only use the positive sqrt of the discriminant from: x = (-B +/- sqrtDiscriminant) / 2A\n\t\tswapAmount = ( sqrtDiscriminant - B ) / ( 2 * A );\n\n\t\t// Denormalize from the 80 bit representation\n\t\tswapAmount <<= shift;\n    \t}\n\n\n\t// Determine how much of either token needs to be swapped to give them a ratio equivalent to the reserves.\n\t// If (0,0) is returned it signifies that no swap should be done before the addLiquidity.\n\tfunction _determineZapSwapAmount( uint256 reserveA, uint256 reserveB, uint256 zapAmountA, uint256 zapAmountB ) internal pure returns (uint256 swapAmountA, uint256 swapAmountB )\n\t\t{\n\t\t// zapAmountA / zapAmountB exceeds the ratio of reserveA / reserveB? - meaning too much zapAmountA\n\t\tif ( zapAmountA * reserveB > reserveA * zapAmountB )\n\t\t\t(swapAmountA, swapAmountB) = (_zapSwapAmount( reserveA, reserveB, zapAmountA, zapAmountB ), 0);\n\n\t\t// zapAmountA / zapAmountB is less than the ratio of reserveA / reserveB? - meaning too much zapAmountB\n\t\tif ( zapAmountA * reserveB < reserveA * zapAmountB )\n\t\t\t(swapAmountA, swapAmountB) = (0, _zapSwapAmount( reserveB, reserveA, zapAmountB, zapAmountA ));\n\n\t\t// Ensure we are not swapping more than was specified for zapping\n\t\tif ( ( swapAmountA > zapAmountA ) || ( swapAmountB > zapAmountB ) )\n\t\t\treturn (0, 0);\n\n\t\treturn (swapAmountA, swapAmountB);\n\t\t}\n\t}"
    }
  ]
}