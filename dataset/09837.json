{
  "Title": "[M-11] `money-market-contracts/contracts/market` `claim_rewards` may revert due to `spend_limit` set on `distributor`",
  "Content": "\nWhile `claim_rewards` from the `money-market`, it calls the `distributor_contract#spend()` to send the rewards.\n\n<https://github.com/code-423n4/2022-02-anchor/blob/7af353e3234837979a19ddc8093dc9ad3c63ab6b/contracts/money-market-contracts/contracts/market/src/borrow.rs#L216-L234>\n\n```rust\nlet messages: Vec<CosmosMsg> = if !claim_amount.is_zero() {\n    vec![CosmosMsg::Wasm(WasmMsg::Execute {\n        contract_addr: deps\n            .api\n            .addr_humanize(&config.distributor_contract)?\n            .to_string(),\n        funds: vec![],\n        msg: to_binary(&FaucetExecuteMsg::Spend {\n            recipient: if let Some(to) = to {\n                to.to_string()\n            } else {\n                borrower.to_string()\n            },\n            amount: claim_amount.into(),\n        })?,\n    })]\n} else {\n    vec![]\n};\n```\n\nHowever, the `distributor_contract#spend()` function have a `spend_limit` config and it will revert if the amount is larger than the `spend_limit`.\n\n<https://github.com/code-423n4/2022-02-anchor/blob/7af353e3234837979a19ddc8093dc9ad3c63ab6b/contracts/anchor-token-contracts/contracts/distributor/src/contract.rs#L153-L155>\n\n```rust\nif config.spend_limit < amount {\n    return Err(StdError::generic_err(\"Cannot spend more than spend_limit\"));\n}\n```\n\nAs a result, users won't be able to claim their rewards anymore once the amount of the rewards excess the `spend_limit` config on `distributor_contract`.\n\n### Recommended Mitigation Steps\n\nConsider removing the `spend_limit` or allowing users to specify an amount when `claim_rewards`.\n\n**[Alex the Entreprenerd (triage) commented](https://github.com/code-423n4/2022-02-anchor-findings/issues/46#issuecomment-1207280811):**\n > Loss of yield, conditional on reaching limit, consider reducing severity.\n\n**[Albert Chon (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-02-anchor-findings/issues/46#issuecomment-1251668446):**\n > Can be mitigated with a large spend limit, which likely exists to prevent catastrophic cases. The issue is correct though, that this is a bug. Downgrading to medium severity though, given the practicality. \n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-02-anchor-contest",
  "Code": [
    {
      "filename": "contracts/money-market-contracts/contracts/market/src/borrow.rs",
      "content": "use anchor_token::distributor::ExecuteMsg as FaucetExecuteMsg;\nuse cosmwasm_bignumber::{Decimal256, Uint256};\nuse cosmwasm_std::{\n    attr, to_binary, Addr, BankMsg, Coin, CosmosMsg, Deps, DepsMut, Env, MessageInfo, Response,\n    StdResult, WasmMsg,\n};\nuse moneymarket::interest_model::BorrowRateResponse;\nuse moneymarket::market::{BorrowerInfoResponse, BorrowerInfosResponse};\nuse moneymarket::overseer::BorrowLimitResponse;\nuse moneymarket::querier::{deduct_tax, query_balance, query_supply};\n\nuse crate::deposit::compute_exchange_rate_raw;\nuse crate::error::ContractError;\nuse crate::querier::{query_borrow_limit, query_borrow_rate, query_target_deposit_rate};\nuse crate::state::{\n    read_borrower_info, read_borrower_infos, read_config, read_state, store_borrower_info,\n    store_state, BorrowerInfo, Config, State,\n};\n\npub fn borrow_stable(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    borrow_amount: Uint256,\n    to: Option<Addr>,\n) -> Result<Response, ContractError> {\n    let config: Config = read_config(deps.storage)?;\n\n    let mut state: State = read_state(deps.storage)?;\n\n    let borrower = info.sender;\n    let borrower_raw = deps.api.addr_canonicalize(borrower.as_str())?;\n    let mut liability: BorrowerInfo = read_borrower_info(deps.storage, &borrower_raw);\n\n    // Compute interest\n    compute_interest(deps.as_ref(), &config, &mut state, env.block.height, None)?;\n    compute_borrower_interest(&state, &mut liability);\n\n    // Compute ANC reward\n    compute_reward(&mut state, env.block.height);\n    compute_borrower_reward(&state, &mut liability);\n\n    let overseer = deps.api.addr_humanize(&config.overseer_contract)?;\n    let borrow_limit_res: BorrowLimitResponse = query_borrow_limit(\n        deps.as_ref(),\n        overseer,\n        borrower.clone(),\n        Some(env.block.time.seconds()),\n    )?;\n\n    if borrow_limit_res.borrow_limit < borrow_amount + liability.loan_amount {\n        return Err(ContractError::BorrowExceedsLimit(\n            borrow_limit_res.borrow_limit.into(),\n        ));\n    }\n\n    let current_balance = query_balance(\n        deps.as_ref(),\n        env.contract.address,\n        config.stable_denom.to_string(),\n    )?;\n\n    // Assert borrow amount\n    assert_max_borrow_factor(&config, &state, current_balance, borrow_amount)?;\n\n    liability.loan_amount += borrow_amount;\n    state.total_liabilities += Decimal256::from_uint256(borrow_amount);\n    store_state(deps.storage, &state)?;\n    store_borrower_info(deps.storage, &borrower_raw, &liability)?;\n\n    Ok(Response::new()\n        .add_message(CosmosMsg::Bank(BankMsg::Send {\n            to_address: to.unwrap_or_else(|| borrower.clone()).to_string(),\n            amount: vec![deduct_tax(\n                deps.as_ref(),\n                Coin {\n                    denom: config.stable_denom,\n                    amount: borrow_amount.into(),\n                },\n            )?],\n        }))\n        .add_attributes(vec![\n            attr(\"action\", \"borrow_stable\"),\n            attr(\"borrower\", borrower),\n            attr(\"borrow_amount\", borrow_amount),\n        ]))\n}\n\npub fn repay_stable_from_liquidation(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    borrower: Addr,\n    prev_balance: Uint256,\n) -> Result<Response, ContractError> {\n    let config: Config = read_config(deps.storage)?;\n    if config.overseer_contract != deps.api.addr_canonicalize(info.sender.as_str())? {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    let cur_balance: Uint256 = query_balance(\n        deps.as_ref(),\n        env.contract.address.clone(),\n        config.stable_denom.to_string(),\n    )?;\n\n    // override env\n    let mut info = info;\n\n    info.sender = borrower;\n    info.funds = vec![Coin {\n        denom: config.stable_denom,\n        amount: (cur_balance - prev_balance).into(),\n    }];\n\n    repay_stable(deps, env, info)\n}\n\npub fn repay_stable(deps: DepsMut, env: Env, info: MessageInfo) -> Result<Response, ContractError> {\n    let config: Config = read_config(deps.storage)?;\n\n    // Check stable denom deposit\n    let amount: Uint256 = info\n        .funds\n        .iter()\n        .find(|c| c.denom == config.stable_denom)\n        .map(|c| Uint256::from(c.amount))\n        .unwrap_or_else(Uint256::zero);\n\n    // Cannot deposit zero amount\n    if amount.is_zero() {\n        return Err(ContractError::ZeroRepay(config.stable_denom));\n    }\n\n    let mut state: State = read_state(deps.storage)?;\n\n    let borrower = info.sender;\n    let borrower_raw = deps.api.addr_canonicalize(borrower.as_str())?;\n    let mut liability: BorrowerInfo = read_borrower_info(deps.storage, &borrower_raw);\n\n    // Compute interest\n    compute_interest(\n        deps.as_ref(),\n        &config,\n        &mut state,\n        env.block.height,\n        Some(amount),\n    )?;\n    compute_borrower_interest(&state, &mut liability);\n\n    // Compute ANC reward\n    compute_reward(&mut state, env.block.height);\n    compute_borrower_reward(&state, &mut liability);\n\n    let repay_amount: Uint256;\n    let mut messages: Vec<CosmosMsg> = vec![];\n    if liability.loan_amount < amount {\n        repay_amount = liability.loan_amount;\n        liability.loan_amount = Uint256::zero();\n\n        // Payback left repay amount to sender\n        messages.push(CosmosMsg::Bank(BankMsg::Send {\n            to_address: borrower.to_string(),\n            amount: vec![deduct_tax(\n                deps.as_ref(),\n                Coin {\n                    denom: config.stable_denom,\n                    amount: (amount - repay_amount).into(),\n                },\n            )?],\n        }));\n    } else {\n        repay_amount = amount;\n        liability.loan_amount = liability.loan_amount - repay_amount;\n    }\n\n    state.total_liabilities = state.total_liabilities - Decimal256::from_uint256(repay_amount);\n\n    store_borrower_info(deps.storage, &borrower_raw, &liability)?;\n    store_state(deps.storage, &state)?;\n\n    Ok(Response::new().add_messages(messages).add_attributes(vec![\n        attr(\"action\", \"repay_stable\"),\n        attr(\"borrower\", borrower),\n        attr(\"repay_amount\", repay_amount),\n    ]))\n}\n\npub fn claim_rewards(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    to: Option<Addr>,\n) -> Result<Response, ContractError> {\n    let config: Config = read_config(deps.storage)?;\n    let mut state: State = read_state(deps.storage)?;\n\n    let borrower = info.sender;\n    let borrower_raw = deps.api.addr_canonicalize(borrower.as_str())?;\n    let mut liability: BorrowerInfo = read_borrower_info(deps.storage, &borrower_raw);\n\n    // Compute interest\n    compute_interest(deps.as_ref(), &config, &mut state, env.block.height, None)?;\n    compute_borrower_interest(&state, &mut liability);\n\n    // Compute ANC reward\n    compute_reward(&mut state, env.block.height);\n    compute_borrower_reward(&state, &mut liability);\n\n    let claim_amount = liability.pending_rewards * Uint256::one();\n    liability.pending_rewards = liability.pending_rewards - Decimal256::from_uint256(claim_amount);\n\n    store_state(deps.storage, &state)?;\n    store_borrower_info(deps.storage, &borrower_raw, &liability)?;\n\n    let messages: Vec<CosmosMsg> = if !claim_amount.is_zero() {\n        vec![CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: deps\n                .api\n                .addr_humanize(&config.distributor_contract)?\n                .to_string(),\n            funds: vec![],\n            msg: to_binary(&FaucetExecuteMsg::Spend {\n                recipient: if let Some(to) = to {\n                    to.to_string()\n                } else {\n                    borrower.to_string()\n                },\n                amount: claim_amount.into(),\n            })?,\n        })]\n    } else {\n        vec![]\n    };\n\n    Ok(Response::new().add_messages(messages).add_attributes(vec![\n        attr(\"action\", \"claim_rewards\"),\n        attr(\"claim_amount\", claim_amount),\n    ]))\n}\n\n/// Compute interest and update state\n/// total liabilities and total reserves\npub fn compute_interest(\n    deps: Deps,\n    config: &Config,\n    state: &mut State,\n    block_height: u64,\n    deposit_amount: Option<Uint256>,\n) -> StdResult<()> {\n    if state.last_interest_updated >= block_height {\n        return Ok(());\n    }\n\n    let aterra_supply = query_supply(deps, deps.api.addr_humanize(&config.aterra_contract)?)?;\n    let balance: Uint256 = query_balance(\n        deps,\n        deps.api.addr_humanize(&config.contract_addr)?,\n        config.stable_denom.to_string(),\n    )? - deposit_amount.unwrap_or_else(Uint256::zero);\n\n    let borrow_rate_res: BorrowRateResponse = query_borrow_rate(\n        deps,\n        deps.api.addr_humanize(&config.interest_model)?,\n        balance,\n        state.total_liabilities,\n        state.total_reserves,\n    )?;\n\n    let target_deposit_rate: Decimal256 =\n        query_target_deposit_rate(deps, deps.api.addr_humanize(&config.overseer_contract)?)?;\n\n    compute_interest_raw(\n        state,\n        block_height,\n        balance,\n        aterra_supply,\n        borrow_rate_res.rate,\n        target_deposit_rate,\n    );\n\n    Ok(())\n}\n\n// CONTRACT: to use this function as state update purpose,\n// executor must update following three state after execution\n// * state.prev_aterra_supply\n// * state.prev_exchange_rate\n// * state.last_interest_updated\npub fn compute_interest_raw(\n    state: &mut State,\n    block_height: u64,\n    balance: Uint256,\n    aterra_supply: Uint256,\n    borrow_rate: Decimal256,\n    target_deposit_rate: Decimal256,\n) {\n    if state.last_interest_updated >= block_height {\n        return;\n    }\n\n    let passed_blocks = Decimal256::from_uint256(block_height - state.last_interest_updated);\n\n    let interest_factor = passed_blocks * borrow_rate;\n    let interest_accrued = state.total_liabilities * interest_factor;\n\n    state.global_interest_index =\n        state.global_interest_index * (Decimal256::one() + interest_factor);\n    state.total_liabilities += interest_accrued;\n\n    let mut exchange_rate = compute_exchange_rate_raw(state, aterra_supply, balance);\n    let effective_deposit_rate = exchange_rate / state.prev_exchange_rate;\n    let deposit_rate = (effective_deposit_rate - Decimal256::one()) / passed_blocks;\n\n    if deposit_rate > target_deposit_rate {\n        // excess_deposit_rate(_per_block)\n        let excess_deposit_rate = deposit_rate - target_deposit_rate;\n        let prev_deposits =\n            Decimal256::from_uint256(state.prev_aterra_supply * state.prev_exchange_rate);\n\n        // excess_yield = prev_deposits * excess_deposit_rate(_per_block) * blocks\n        let excess_yield = prev_deposits * passed_blocks * excess_deposit_rate;\n\n        state.total_reserves += excess_yield;\n        exchange_rate = compute_exchange_rate_raw(state, aterra_supply, balance);\n    }\n\n    state.prev_aterra_supply = aterra_supply;\n    state.prev_exchange_rate = exchange_rate;\n    state.last_interest_updated = block_height;\n}\n\n/// Compute new interest and apply to liability\npub(crate) fn compute_borrower_interest(state: &State, liability: &mut BorrowerInfo) {\n    liability.loan_amount =\n        liability.loan_amount * state.global_interest_index / liability.interest_index;\n    liability.interest_index = state.global_interest_index;\n}\n\n/// Compute distributed reward and update global index\npub fn compute_reward(state: &mut State, block_height: u64) {\n    if state.last_reward_updated >= block_height {\n        return;\n    }\n\n    let passed_blocks = Decimal256::from_uint256(block_height - state.last_reward_updated);\n    let reward_accrued = passed_blocks * state.anc_emission_rate;\n    let borrow_amount = state.total_liabilities / state.global_interest_index;\n\n    if !reward_accrued.is_zero() && !borrow_amount.is_zero() {\n        state.global_reward_index += reward_accrued / borrow_amount;\n    }\n\n    state.last_reward_updated = block_height;\n}\n\n/// Compute reward amount a borrower received\npub(crate) fn compute_borrower_reward(state: &State, liability: &mut BorrowerInfo) {\n    liability.pending_rewards += Decimal256::from_uint256(liability.loan_amount)\n        / state.global_interest_index\n        * (state.global_reward_index - liability.reward_index);\n    liability.reward_index = state.global_reward_index;\n}\n\npub fn query_borrower_info(\n    deps: Deps,\n    env: Env,\n    borrower: Addr,\n    block_height: Option<u64>,\n) -> StdResult<BorrowerInfoResponse> {\n    let mut borrower_info: BorrowerInfo = read_borrower_info(\n        deps.storage,\n        &deps.api.addr_canonicalize(borrower.as_str())?,\n    );\n\n    let block_height = if let Some(block_height) = block_height {\n        block_height\n    } else {\n        env.block.height\n    };\n\n    let config: Config = read_config(deps.storage)?;\n    let mut state: State = read_state(deps.storage)?;\n\n    compute_interest(deps, &config, &mut state, block_height, None)?;\n    compute_borrower_interest(&state, &mut borrower_info);\n\n    compute_reward(&mut state, block_height);\n    compute_borrower_reward(&state, &mut borrower_info);\n\n    Ok(BorrowerInfoResponse {\n        borrower: borrower.to_string(),\n        interest_index: borrower_info.interest_index,\n        reward_index: borrower_info.reward_index,\n        loan_amount: borrower_info.loan_amount,\n        pending_rewards: borrower_info.pending_rewards,\n    })\n}\n\npub fn query_borrower_infos(\n    deps: Deps,\n    start_after: Option<Addr>,\n    limit: Option<u32>,\n) -> StdResult<BorrowerInfosResponse> {\n    let start_after = if let Some(start_after) = start_after {\n        Some(deps.api.addr_canonicalize(start_after.as_str())?)\n    } else {\n        None\n    };\n\n    let borrower_infos: Vec<BorrowerInfoResponse> = read_borrower_infos(deps, start_after, limit)?;\n    Ok(BorrowerInfosResponse { borrower_infos })\n}\n\nfn assert_max_borrow_factor(\n    config: &Config,\n    state: &State,\n    current_balance: Uint256,\n    borrow_amount: Uint256,\n) -> Result<(), ContractError> {\n    let current_balance = Decimal256::from_uint256(current_balance);\n    let borrow_amount = Decimal256::from_uint256(borrow_amount);\n\n    // Assert max borrow factor\n    if state.total_liabilities + borrow_amount\n        > (current_balance + state.total_liabilities - state.total_reserves)\n            * config.max_borrow_factor\n    {\n        return Err(ContractError::MaxBorrowFactorReached(\n            config.stable_denom.clone(),\n        ));\n    }\n\n    // Assert available balance\n    if borrow_amount + state.total_reserves > current_balance {\n        return Err(ContractError::NoStableAvailable(\n            config.stable_denom.clone(),\n        ));\n    }\n\n    Ok(())\n}"
    },
    {
      "filename": "contracts/anchor-token-contracts/contracts/distributor/src/contract.rs",
      "content": "#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::entry_point;\n\nuse crate::state::{read_config, store_config, Config};\n\nuse cosmwasm_std::{\n    to_binary, Binary, CanonicalAddr, CosmosMsg, Deps, DepsMut, Env, MessageInfo, Response,\n    StdError, StdResult, Uint128, WasmMsg,\n};\n\nuse anchor_token::distributor::{ConfigResponse, ExecuteMsg, InstantiateMsg, MigrateMsg, QueryMsg};\n\nuse cw20::Cw20ExecuteMsg;\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    _env: Env,\n    _info: MessageInfo,\n    msg: InstantiateMsg,\n) -> StdResult<Response> {\n    let whitelist = msg\n        .whitelist\n        .into_iter()\n        .map(|w| deps.api.addr_canonicalize(&w))\n        .collect::<StdResult<Vec<CanonicalAddr>>>()?;\n\n    store_config(\n        deps.storage,\n        &Config {\n            gov_contract: deps.api.addr_canonicalize(&msg.gov_contract)?,\n            anchor_token: deps.api.addr_canonicalize(&msg.anchor_token)?,\n            whitelist,\n            spend_limit: msg.spend_limit,\n        },\n    )?;\n\n    Ok(Response::default())\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    msg: ExecuteMsg,\n) -> StdResult<Response> {\n    match msg {\n        ExecuteMsg::UpdateConfig { spend_limit } => update_config(deps, info, spend_limit),\n        ExecuteMsg::Spend { recipient, amount } => spend(deps, info, recipient, amount),\n        ExecuteMsg::AddDistributor { distributor } => add_distributor(deps, info, distributor),\n        ExecuteMsg::RemoveDistributor { distributor } => {\n            remove_distributor(deps, info, distributor)\n        }\n    }\n}\n\npub fn update_config(\n    deps: DepsMut,\n    info: MessageInfo,\n    spend_limit: Option<Uint128>,\n) -> StdResult<Response> {\n    let mut config: Config = read_config(deps.storage)?;\n    if config.gov_contract != deps.api.addr_canonicalize(info.sender.as_str())? {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\n    if let Some(spend_limit) = spend_limit {\n        config.spend_limit = spend_limit;\n    }\n\n    store_config(deps.storage, &config)?;\n\n    Ok(Response::new().add_attributes(vec![(\"action\", \"update_config\")]))\n}\n\npub fn add_distributor(\n    deps: DepsMut,\n    info: MessageInfo,\n    distributor: String,\n) -> StdResult<Response> {\n    let mut config: Config = read_config(deps.storage)?;\n    if config.gov_contract != deps.api.addr_canonicalize(info.sender.as_str())? {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\n    let distributor_raw = deps.api.addr_canonicalize(&distributor)?;\n    if config\n        .whitelist\n        .clone()\n        .into_iter()\n        .any(|w| w == distributor_raw)\n    {\n        return Err(StdError::generic_err(\"Distributor already registered\"));\n    }\n\n    config.whitelist.push(distributor_raw);\n    store_config(deps.storage, &config)?;\n\n    Ok(Response::new().add_attributes(vec![\n        (\"action\", \"add_distributor\"),\n        (\"distributor\", distributor.as_str()),\n    ]))\n}\n\npub fn remove_distributor(\n    deps: DepsMut,\n    info: MessageInfo,\n    distributor: String,\n) -> StdResult<Response> {\n    let mut config: Config = read_config(deps.storage)?;\n    if config.gov_contract != deps.api.addr_canonicalize(info.sender.as_str())? {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\n    let distributor_raw = deps.api.addr_canonicalize(&distributor)?;\n    let whitelist_len = config.whitelist.len();\n    let whitelist: Vec<CanonicalAddr> = config\n        .whitelist\n        .into_iter()\n        .filter(|w| *w != distributor_raw)\n        .collect();\n\n    if whitelist_len == whitelist.len() {\n        return Err(StdError::generic_err(\"Distributor not found\"));\n    }\n\n    config.whitelist = whitelist;\n    store_config(deps.storage, &config)?;\n\n    Ok(Response::new().add_attributes(vec![\n        (\"action\", \"remove_distributor\"),\n        (\"distributor\", distributor.as_str()),\n    ]))\n}\n\n/// Spend\n/// Owner can execute spend operation to send\n/// `amount` of MIR token to `recipient` for community purpose\npub fn spend(\n    deps: DepsMut,\n    info: MessageInfo,\n    recipient: String,\n    amount: Uint128,\n) -> StdResult<Response> {\n    let config: Config = read_config(deps.storage)?;\n    let sender_raw = deps.api.addr_canonicalize(info.sender.as_str())?;\n\n    if !config.whitelist.into_iter().any(|w| w == sender_raw) {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\n    if config.spend_limit < amount {\n        return Err(StdError::generic_err(\"Cannot spend more than spend_limit\"));\n    }\n\n    let anchor_token = deps.api.addr_humanize(&config.anchor_token)?.to_string();\n    Ok(Response::new()\n        .add_messages(vec![CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: anchor_token,\n            funds: vec![],\n            msg: to_binary(&Cw20ExecuteMsg::Transfer {\n                recipient: recipient.clone(),\n                amount,\n            })?,\n        })])\n        .add_attributes(vec![\n            (\"action\", \"spend\"),\n            (\"recipient\", recipient.as_str()),\n            (\"amount\", amount.to_string().as_str()),\n        ]))\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, _env: Env, msg: QueryMsg) -> StdResult<Binary> {\n    match msg {\n        QueryMsg::Config {} => to_binary(&query_config(deps)?),\n    }\n}\n\npub fn query_config(deps: Deps) -> StdResult<ConfigResponse> {\n    let state = read_config(deps.storage)?;\n    let resp = ConfigResponse {\n        gov_contract: deps.api.addr_humanize(&state.gov_contract)?.to_string(),\n        anchor_token: deps.api.addr_humanize(&state.anchor_token)?.to_string(),\n        whitelist: state\n            .whitelist\n            .into_iter()\n            .map(|w| match deps.api.addr_humanize(&w) {\n                Ok(addr) => Ok(addr.to_string()),\n                Err(e) => Err(e),\n            })\n            .collect::<StdResult<Vec<String>>>()?,\n        spend_limit: state.spend_limit,\n    };\n\n    Ok(resp)\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn migrate(_deps: DepsMut, _env: Env, _msg: MigrateMsg) -> StdResult<Response> {\n    Ok(Response::default())\n}"
    }
  ]
}