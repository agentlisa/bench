{
  "Title": "[G-17] Utilize post-incrementing to optimize `pushBack()` function",
  "Content": "\n**File:** `PriorityQueue.sol`\n\nThis issue is reported as separate finding, because proposed optimizations require code refactoring.\n\n[File: code/contracts/ethereum/contracts/state-transition/libraries/PriorityQueue.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/libraries/PriorityQueue.sol#L55)\n```solidity\n55:     function pushBack(Queue storage _queue, PriorityOperation memory _operation) internal {\n56:         // Save value into the stack to avoid double reading from the storage\n57:         uint256 tail = _queue.tail;\n58: \n59:         _queue.data[tail] = _operation;\n60:         _queue.tail = tail + 1;\n61:     }\n```\n\nWe can get rid of variable `tail` by using `_queue.tail++` directly in `_queue.data`:\n\n```\nfunction pushBack(Queue storage _queue, PriorityOperation memory _operation) internal {\n    _queue.data[_queue.tail++] = _operation;\n}\n```\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2024-03-zksync",
  "Code": [
    {
      "filename": "code/contracts/ethereum/contracts/state-transition/libraries/PriorityQueue.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\n/// @notice The structure that contains meta information of the L2 transaction that was requested from L1\n/// @dev The weird size of fields was selected specifically to minimize the structure storage size\n/// @param canonicalTxHash Hashed L2 transaction data that is needed to process it\n/// @param expirationTimestamp Expiration timestamp for this request (must be satisfied before)\n/// @param layer2Tip Additional payment to the validator as an incentive to perform the operation\nstruct PriorityOperation {\n    bytes32 canonicalTxHash;\n    uint64 expirationTimestamp;\n    uint192 layer2Tip;\n}\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @dev The library provides the API to interact with the priority queue container\n/// @dev Order of processing operations from queue - FIFO (Fist in - first out)\nlibrary PriorityQueue {\n    using PriorityQueue for Queue;\n\n    /// @notice Container that stores priority operations\n    /// @param data The inner mapping that saves priority operation by its index\n    /// @param head The pointer to the first unprocessed priority operation, equal to the tail if the queue is empty\n    /// @param tail The pointer to the free slot\n    struct Queue {\n        mapping(uint256 priorityOpId => PriorityOperation priorityOp) data;\n        uint256 tail;\n        uint256 head;\n    }\n\n    /// @notice Returns zero if and only if no operations were processed from the queue\n    /// @return Index of the oldest priority operation that wasn't processed yet\n    function getFirstUnprocessedPriorityTx(Queue storage _queue) internal view returns (uint256) {\n        return _queue.head;\n    }\n\n    /// @return The total number of priority operations that were added to the priority queue, including all processed ones\n    function getTotalPriorityTxs(Queue storage _queue) internal view returns (uint256) {\n        return _queue.tail;\n    }\n\n    /// @return The total number of unprocessed priority operations in a priority queue\n    function getSize(Queue storage _queue) internal view returns (uint256) {\n        return uint256(_queue.tail - _queue.head);\n    }\n\n    /// @return Whether the priority queue contains no operations\n    function isEmpty(Queue storage _queue) internal view returns (bool) {\n        return _queue.tail == _queue.head;\n    }\n\n    /// @notice Add the priority operation to the end of the priority queue\n    function pushBack(Queue storage _queue, PriorityOperation memory _operation) internal {\n        // Save value into the stack to avoid double reading from the storage\n        uint256 tail = _queue.tail;\n\n        _queue.data[tail] = _operation;\n        _queue.tail = tail + 1;\n    }\n\n    /// @return The first unprocessed priority operation from the queue\n    function front(Queue storage _queue) internal view returns (PriorityOperation memory) {\n        require(!_queue.isEmpty(), \"D\"); // priority queue is empty\n\n        return _queue.data[_queue.head];\n    }\n\n    /// @notice Remove the first unprocessed priority operation from the queue\n    /// @return priorityOperation that was popped from the priority queue\n    function popFront(Queue storage _queue) internal returns (PriorityOperation memory priorityOperation) {\n        require(!_queue.isEmpty(), \"s\"); // priority queue is empty\n\n        // Save value into the stack to avoid double reading from the storage\n        uint256 head = _queue.head;\n\n        priorityOperation = _queue.data[head];\n        delete _queue.data[head];\n        _queue.head = head + 1;\n    }\n}"
    }
  ]
}