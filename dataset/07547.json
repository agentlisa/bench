{
  "Title": "[M-18] Bad debt will likely incur when multiple NFTs are liquidated",
  "Content": "\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/libraries/logic/GenericLogic.sol#L394>\n\n\\_getUserBalanceForERC721() in GenericLogic gets the value of a user's specific ERC721 xToken. It is later used for determining the account's health factor. In case `isAtomicPrice` is false such as in ape NTokens, price is calculated using:\n\n        uint256 assetPrice = _getAssetPrice(\n            params.oracle,\n            vars.currentReserveAddress\n        );\n        totalValue =\n            ICollateralizableERC721(vars.xTokenAddress)\n                .collateralizedBalanceOf(params.user) *\n            assetPrice;\n\nIt is the number of apes multiplied by the floor price returns from \\_getAssetPrice. The issue is that this calculation does not account for slippage, and is unrealistic. If user's account is liquidated, it is very unlikely that releasing several multiples of precious NFTs will not bring the price down in some significant way.\n\nBy performing simple multiplication of NFT count and NFT price, protocol is introducing major bad debt risks and is not as conservative as it aims to be. Collateral value must take slippage risks into account.\n\n### Impact\n\nBad debt will likely incur when multiple NFTs are liquidated.\n\n### Recommended Mitigation Steps\n\nChange the calculation to account for slippage when NFT balance is above some threshold.\n\n**[WalidOfNow (Paraspace) commented](https://github.com/code-423n4/2022-11-paraspace-findings/issues/479#issuecomment-1404057265):**\n > There's no real issue here. Its pretty much saying that the design of the protocol is not good for certain market behaviours. This is more of a suggestion than an issue. On top of that, we actually account for this slippage by choosing low LTV and LT.\n\n**[Trust (warden) commented](https://github.com/code-423n4/2022-11-paraspace-findings/issues/479#issuecomment-1404106418):**\n > Regardless of the way we look at it, I've established assets are at risk under stated conditions which are not correctly taken into account in the protocol. That seems to meet the bar set for Medium level submissions.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-11-paraspace-contest",
  "Code": [
    {
      "filename": "paraspace-core/contracts/protocol/libraries/logic/GenericLogic.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {IERC20} from \"../../../dependencies/openzeppelin/contracts/IERC20.sol\";\nimport {IERC721Enumerable} from \"../../../dependencies/openzeppelin/contracts/IERC721Enumerable.sol\";\nimport {Math} from \"../../../dependencies/openzeppelin/contracts/Math.sol\";\nimport {IScaledBalanceToken} from \"../../../interfaces/IScaledBalanceToken.sol\";\nimport {INToken} from \"../../../interfaces/INToken.sol\";\nimport {ICollateralizableERC721} from \"../../../interfaces/ICollateralizableERC721.sol\";\nimport {IPriceOracleGetter} from \"../../../interfaces/IPriceOracleGetter.sol\";\nimport {ReserveConfiguration} from \"../configuration/ReserveConfiguration.sol\";\nimport {UserConfiguration} from \"../configuration/UserConfiguration.sol\";\nimport {PercentageMath} from \"../math/PercentageMath.sol\";\nimport {WadRayMath} from \"../math/WadRayMath.sol\";\nimport {DataTypes} from \"../types/DataTypes.sol\";\nimport {ReserveLogic} from \"./ReserveLogic.sol\";\nimport {INonfungiblePositionManager} from \"../../../dependencies/uniswap/INonfungiblePositionManager.sol\";\nimport {XTokenType} from \"../../../interfaces/IXTokenType.sol\";\n\n/**\n * @title GenericLogic library\n *\n * @notice Implements protocol-level logic to calculate and validate the state of a user\n */\nlibrary GenericLogic {\n    using ReserveLogic for DataTypes.ReserveData;\n    using WadRayMath for uint256;\n    using PercentageMath for uint256;\n    using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n    using UserConfiguration for DataTypes.UserConfigurationMap;\n\n    struct CalculateUserAccountDataVars {\n        uint256 assetPrice;\n        uint256 assetUnit;\n        DataTypes.ReserveConfigurationMap reserveConfiguration;\n        uint256 userBalanceInBaseCurrency;\n        uint256 decimals;\n        uint256 ltv;\n        uint256 liquidationThreshold;\n        uint256 liquidationBonus;\n        uint256 i;\n        uint256 healthFactor;\n        uint256 erc721HealthFactor;\n        uint256 totalERC721CollateralInBaseCurrency;\n        uint256 payableDebtByERC20Assets;\n        uint256 totalCollateralInBaseCurrency;\n        uint256 totalDebtInBaseCurrency;\n        uint256 avgLtv;\n        uint256 avgLiquidationThreshold;\n        uint256 avgERC721LiquidationThreshold;\n        address currentReserveAddress;\n        bool hasZeroLtvCollateral;\n        address xTokenAddress;\n        XTokenType xTokenType;\n    }\n\n    /**\n     * @notice Calculates the user data across the reserves.\n     * @dev It includes the total liquidity/collateral/borrow balances in the base currency used by the price feed,\n     * the average Loan To Value, the average Liquidation Ratio, and the Health factor.\n     * @param reservesData The state of all the reserves\n     * @param reservesList The addresses of all the active reserves\n     * @param params Additional parameters needed for the calculation\n     * @return The total collateral of the user in the base currency used by the price feed\n     * @return The total ERC721 collateral of the user in the base currency used by the price feed\n     * @return The total debt of the user in the base currency used by the price feed\n     * @return The average ltv of the user\n     * @return The average liquidation threshold of the user\n     * @return The payable debt by ERC20 assets\n     * @return The health factor of the user\n     * @return The ERC721 health factor of the user\n     * @return True if the ltv is zero, false otherwise\n     **/\n    function calculateUserAccountData(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        mapping(uint256 => address) storage reservesList,\n        DataTypes.CalculateUserAccountDataParams memory params\n    )\n        internal\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            bool\n        )\n    {\n        if (params.userConfig.isEmpty()) {\n            return (\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                type(uint256).max,\n                type(uint256).max,\n                false\n            );\n        }\n\n        CalculateUserAccountDataVars memory vars;\n\n        while (vars.i < params.reservesCount) {\n            if (!params.userConfig.isUsingAsCollateralOrBorrowing(vars.i)) {\n                unchecked {\n                    ++vars.i;\n                }\n                continue;\n            }\n\n            vars.currentReserveAddress = reservesList[vars.i];\n\n            if (vars.currentReserveAddress == address(0)) {\n                unchecked {\n                    ++vars.i;\n                }\n                continue;\n            }\n\n            DataTypes.ReserveData storage currentReserve = reservesData[\n                vars.currentReserveAddress\n            ];\n\n            vars.reserveConfiguration = currentReserve.configuration;\n\n            (\n                vars.ltv,\n                vars.liquidationThreshold,\n                vars.liquidationBonus,\n                vars.decimals,\n\n            ) = currentReserve.configuration.getParams();\n\n            unchecked {\n                vars.assetUnit = 10**vars.decimals;\n            }\n\n            vars.xTokenAddress = currentReserve.xTokenAddress;\n\n            if (\n                vars.reserveConfiguration.getAssetType() ==\n                DataTypes.AssetType.ERC20\n            ) {\n                vars.assetPrice = _getAssetPrice(\n                    params.oracle,\n                    vars.currentReserveAddress\n                );\n\n                if (\n                    (vars.liquidationThreshold != 0) &&\n                    params.userConfig.isUsingAsCollateral(vars.i)\n                ) {\n                    vars.userBalanceInBaseCurrency = _getUserBalanceForERC20(\n                        params.user,\n                        currentReserve,\n                        vars.xTokenAddress,\n                        vars.assetUnit,\n                        vars.assetPrice\n                    );\n\n                    vars.payableDebtByERC20Assets += vars\n                        .userBalanceInBaseCurrency\n                        .percentDiv(vars.liquidationBonus);\n\n                    vars.liquidationThreshold =\n                        vars.userBalanceInBaseCurrency *\n                        (vars.liquidationThreshold);\n                    vars.avgLtv += vars.userBalanceInBaseCurrency * vars.ltv;\n\n                    vars.totalCollateralInBaseCurrency += vars\n                        .userBalanceInBaseCurrency;\n\n                    if (vars.ltv == 0) {\n                        vars.hasZeroLtvCollateral = true;\n                    }\n\n                    vars.avgLiquidationThreshold += vars.liquidationThreshold;\n                }\n\n                if (params.userConfig.isBorrowing(vars.i)) {\n                    vars.totalDebtInBaseCurrency += _getUserDebtInBaseCurrency(\n                        params.user,\n                        currentReserve,\n                        vars.assetPrice,\n                        vars.assetUnit\n                    );\n                }\n            } else {\n                if (\n                    (vars.liquidationThreshold != 0) &&\n                    params.userConfig.isUsingAsCollateral(vars.i)\n                ) {\n                    vars.xTokenType = INToken(vars.xTokenAddress)\n                        .getXTokenType();\n                    if (vars.xTokenType == XTokenType.NTokenUniswapV3) {\n                        (\n                            vars.userBalanceInBaseCurrency,\n                            vars.ltv,\n                            vars.liquidationThreshold\n                        ) = _getUserBalanceForUniswapV3(\n                            reservesData,\n                            params,\n                            vars\n                        );\n                    } else {\n                        vars\n                            .userBalanceInBaseCurrency = _getUserBalanceForERC721(\n                            params,\n                            vars\n                        );\n\n                        vars.liquidationThreshold =\n                            vars.userBalanceInBaseCurrency *\n                            vars.liquidationThreshold;\n\n                        if (vars.ltv == 0) {\n                            vars.hasZeroLtvCollateral = true;\n                        }\n\n                        vars.ltv = vars.userBalanceInBaseCurrency * vars.ltv;\n                    }\n\n                    vars.avgERC721LiquidationThreshold += vars\n                        .liquidationThreshold;\n                    vars.totalERC721CollateralInBaseCurrency += vars\n                        .userBalanceInBaseCurrency;\n                    vars.totalCollateralInBaseCurrency += vars\n                        .userBalanceInBaseCurrency;\n                    vars.avgLtv += vars.ltv;\n                    vars.avgLiquidationThreshold += vars.liquidationThreshold;\n                }\n            }\n\n            unchecked {\n                ++vars.i;\n            }\n        }\n\n        unchecked {\n            vars.avgLtv = vars.totalCollateralInBaseCurrency != 0\n                ? vars.avgLtv / vars.totalCollateralInBaseCurrency\n                : 0;\n            vars.avgLiquidationThreshold = vars.totalCollateralInBaseCurrency !=\n                0\n                ? vars.avgLiquidationThreshold /\n                    vars.totalCollateralInBaseCurrency\n                : 0;\n\n            vars.avgERC721LiquidationThreshold = vars\n                .totalERC721CollateralInBaseCurrency != 0\n                ? vars.avgERC721LiquidationThreshold /\n                    vars.totalERC721CollateralInBaseCurrency\n                : 0;\n        }\n\n        vars.healthFactor = (vars.totalDebtInBaseCurrency == 0)\n            ? type(uint256).max\n            : (\n                vars.totalCollateralInBaseCurrency.percentMul(\n                    vars.avgLiquidationThreshold\n                )\n            ).wadDiv(vars.totalDebtInBaseCurrency);\n\n        vars.erc721HealthFactor = (vars.totalDebtInBaseCurrency == 0 ||\n            vars.payableDebtByERC20Assets >= vars.totalDebtInBaseCurrency)\n            ? type(uint256).max\n            : (\n                vars.totalERC721CollateralInBaseCurrency.percentMul(\n                    vars.avgERC721LiquidationThreshold\n                )\n            ).wadDiv(\n                    vars.totalDebtInBaseCurrency - vars.payableDebtByERC20Assets\n                );\n\n        return (\n            vars.totalCollateralInBaseCurrency,\n            vars.totalERC721CollateralInBaseCurrency,\n            vars.totalDebtInBaseCurrency,\n            vars.avgLtv,\n            vars.avgLiquidationThreshold,\n            vars.avgERC721LiquidationThreshold,\n            vars.payableDebtByERC20Assets,\n            vars.healthFactor,\n            vars.erc721HealthFactor,\n            vars.hasZeroLtvCollateral\n        );\n    }\n\n    /**\n     * @notice Calculates the maximum amount that can be borrowed depending on the available collateral, the total debt\n     * and the average Loan To Value\n     * @param totalCollateralInBaseCurrency The total collateral in the base currency used by the price feed\n     * @param totalDebtInBaseCurrency The total borrow balance in the base currency used by the price feed\n     * @param ltv The average loan to value\n     * @return The amount available to borrow in the base currency of the used by the price feed\n     **/\n    function calculateAvailableBorrows(\n        uint256 totalCollateralInBaseCurrency,\n        uint256 totalDebtInBaseCurrency,\n        uint256 ltv\n    ) internal pure returns (uint256) {\n        uint256 availableBorrowsInBaseCurrency = totalCollateralInBaseCurrency\n            .percentMul(ltv);\n\n        if (availableBorrowsInBaseCurrency < totalDebtInBaseCurrency) {\n            return 0;\n        }\n\n        availableBorrowsInBaseCurrency =\n            availableBorrowsInBaseCurrency -\n            totalDebtInBaseCurrency;\n        return availableBorrowsInBaseCurrency;\n    }\n\n    /**\n     * @notice Calculates total debt of the user in the based currency used to normalize the values of the assets\n     * @dev This fetches the `balanceOf` of the stable and variable debt tokens for the user. For gas reasons, the\n     * variable debt balance is calculated by fetching `scaledBalancesOf` normalized debt, which is cheaper than\n     * fetching `balanceOf`\n     * @param user The address of the user\n     * @param reserve The data of the reserve for which the total debt of the user is being calculated\n     * @param assetPrice The price of the asset for which the total debt of the user is being calculated\n     * @param assetUnit The value representing one full unit of the asset (10^decimals)\n     * @return The total debt of the user normalized to the base currency\n     **/\n    function _getUserDebtInBaseCurrency(\n        address user,\n        DataTypes.ReserveData storage reserve,\n        uint256 assetPrice,\n        uint256 assetUnit\n    ) private view returns (uint256) {\n        // fetching variable debt\n        uint256 userTotalDebt = IScaledBalanceToken(\n            reserve.variableDebtTokenAddress\n        ).scaledBalanceOf(user);\n        if (userTotalDebt != 0) {\n            userTotalDebt = userTotalDebt.rayMul(reserve.getNormalizedDebt());\n            userTotalDebt = assetPrice * userTotalDebt;\n\n            unchecked {\n                return userTotalDebt / assetUnit;\n            }\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Calculates total xToken balance of the user in the based currency used by the price oracle\n     * @dev For gas reasons, the xToken balance is calculated by fetching `scaledBalancesOf` normalized debt, which\n     * is cheaper than fetching `balanceOf`\n     * @return totalValue The total xToken balance of the user normalized to the base currency of the price oracle\n     **/\n    function _getUserBalanceForERC721(\n        DataTypes.CalculateUserAccountDataParams memory params,\n        CalculateUserAccountDataVars memory vars\n    ) private view returns (uint256 totalValue) {\n        INToken nToken = INToken(vars.xTokenAddress);\n        bool isAtomicPrice = nToken.getAtomicPricingConfig();\n        if (isAtomicPrice) {\n            uint256 totalBalance = nToken.balanceOf(params.user);\n\n            for (uint256 index = 0; index < totalBalance; index++) {\n                uint256 tokenId = nToken.tokenOfOwnerByIndex(\n                    params.user,\n                    index\n                );\n                if (\n                    ICollateralizableERC721(vars.xTokenAddress)\n                        .isUsedAsCollateral(tokenId)\n                ) {\n                    totalValue += _getTokenPrice(\n                        params.oracle,\n                        vars.currentReserveAddress,\n                        tokenId\n                    );\n                }\n            }\n        } else {\n            uint256 assetPrice = _getAssetPrice(\n                params.oracle,\n                vars.currentReserveAddress\n            );\n            totalValue =\n                ICollateralizableERC721(vars.xTokenAddress)\n                    .collateralizedBalanceOf(params.user) *\n                assetPrice;\n        }\n    }\n\n    function getLtvAndLTForUniswapV3(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        address uniswapV3Manager,\n        uint256 tokenId,\n        uint256 collectionLTV,\n        uint256 collectionLiquidationThreshold\n    ) internal view returns (uint256 ltv, uint256 liquidationThreshold) {\n        (\n            ,\n            ,\n            address token0,\n            address token1,\n            ,\n            ,\n            ,\n            ,\n            ,\n            ,\n            ,\n\n        ) = INonfungiblePositionManager(uniswapV3Manager).positions(tokenId);\n\n        DataTypes.ReserveConfigurationMap memory token0Configs = reservesData[\n            token0\n        ].configuration;\n        DataTypes.ReserveConfigurationMap memory token1Configs = reservesData[\n            token1\n        ].configuration;\n\n        (\n            uint256 token0Ltv,\n            uint256 token0LiquidationThreshold,\n            ,\n            ,\n\n        ) = token0Configs.getParams();\n        (\n            uint256 token1Ltv,\n            uint256 token1LiquidationThreshold,\n            ,\n            ,\n\n        ) = token1Configs.getParams();\n\n        ltv = Math.min(Math.min(token0Ltv, token1Ltv), collectionLTV);\n        liquidationThreshold = Math.min(\n            Math.min(token0LiquidationThreshold, token1LiquidationThreshold),\n            collectionLiquidationThreshold\n        );\n    }\n\n    function _getUserBalanceForUniswapV3(\n        mapping(address => DataTypes.ReserveData) storage reservesData,\n        DataTypes.CalculateUserAccountDataParams memory params,\n        CalculateUserAccountDataVars memory vars\n    )\n        private\n        view\n        returns (\n            uint256 totalValue,\n            uint256 totalLTV,\n            uint256 totalLiquidationThreshold\n        )\n    {\n        uint256 totalBalance = INToken(vars.xTokenAddress).balanceOf(\n            params.user\n        );\n        for (uint256 index = 0; index < totalBalance; index++) {\n            uint256 tokenId = IERC721Enumerable(vars.xTokenAddress)\n                .tokenOfOwnerByIndex(params.user, index);\n            if (\n                ICollateralizableERC721(vars.xTokenAddress).isUsedAsCollateral(\n                    tokenId\n                )\n            ) {\n                uint256 tokenPrice = _getTokenPrice(\n                    params.oracle,\n                    vars.currentReserveAddress,\n                    tokenId\n                );\n                totalValue += tokenPrice;\n\n                (\n                    uint256 tmpLTV,\n                    uint256 tmpLiquidationThreshold\n                ) = getLtvAndLTForUniswapV3(\n                        reservesData,\n                        vars.currentReserveAddress,\n                        tokenId,\n                        vars.ltv,\n                        vars.liquidationThreshold\n                    );\n\n                if (tmpLTV == 0) {\n                    vars.hasZeroLtvCollateral = true;\n                }\n\n                totalLTV += tmpLTV * tokenPrice;\n                totalLiquidationThreshold +=\n                    tmpLiquidationThreshold *\n                    tokenPrice;\n            }\n        }\n    }\n\n    /**\n     * @notice Calculates total xToken balance of the user in the based currency used by the price oracle\n     * @dev For gas reasons, the xToken balance is calculated by fetching `scaledBalancesOf` normalized debt, which\n     * is cheaper than fetching `balanceOf`\n     * @param user The address of the user\n     * @param assetUnit The value representing one full unit of the asset (10^decimals)\n     * @return The total xToken balance of the user normalized to the base currency of the price oracle\n     **/\n    function _getUserBalanceForERC20(\n        address user,\n        DataTypes.ReserveData storage reserve,\n        address xTokenAddress,\n        uint256 assetUnit,\n        uint256 assetPrice\n    ) private view returns (uint256) {\n        uint256 balance;\n\n        uint256 normalizedIncome = reserve.getNormalizedIncome();\n        balance =\n            (\n                IScaledBalanceToken(xTokenAddress).scaledBalanceOf(user).rayMul(\n                    normalizedIncome\n                )\n            ) *\n            assetPrice;\n\n        unchecked {\n            return (balance / assetUnit);\n        }\n    }\n\n    function _getAssetPrice(address oracle, address currentReserveAddress)\n        internal\n        view\n        returns (uint256)\n    {\n        return IPriceOracleGetter(oracle).getAssetPrice(currentReserveAddress);\n    }\n\n    function _getTokenPrice(\n        address oracle,\n        address currentReserveAddress,\n        uint256 tokenId\n    ) internal view returns (uint256) {\n        return\n            IPriceOracleGetter(oracle).getTokenPrice(\n                currentReserveAddress,\n                tokenId\n            );\n    }\n}"
    }
  ]
}