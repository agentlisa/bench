{
  "Title": "[M-06] Allowing `refreshReward()` to fail during minting or buring esLBR could result in gain or loss previously earned reward",
  "Content": "\n### Lines of code\n\n<https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/token/esLBR.sol#L33> <br><https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/token/esLBR.sol#L40>\n\n### Impact\n\nThe esLBR balance of users plays the most important role in staking reward calculation. Using a try-catch statement over `refreshReward()` in the `esLBR.mint()` and `esLBR.burn()` functions can have the following effects when `refreshReward()` becomes unavailable:\n\n*   Users can mint more esLBR, then manually call `refreshReward()` afterward for the contract to record the earned reward with the increased esLBR balance of the users. This results in users receiving more rewards than they should.\n*   Users can be back run by a searcher or someone else calling `refreshReward(victim)` for the contract to record the earned reward with the decreased esLBR balance of the users. This results in users losing some of their rightful pending rewards that have not yet been recorded to the latest timestamp.\n\n### Proof of Concept\n\nThe following is the coded PoC using [Foundry](https://github.com/foundry-rs/foundry).\n\n*Note: This PoC creates a mock reward contract. It has the same logic as the real one, but with added setter functions that serve only to simplify the test flow.*\n\n```solidity\nFile: test/esLBR.t.sol\n\n// SPDX-License-Identifier: Unlicensed\n\npragma solidity ^0.8.17;\n\nimport \"forge-std/Test.sol\";\nimport \"contract/lybra/configuration/LybraConfigurator.sol\";\nimport \"contract/lybra/governance/GovernanceTimelock.sol\";\nimport {esLBR} from \"contract/lybra/token/esLBR.sol\";\n\ncontract C4esLBRTest is Test {\n    Configurator configurator;\n    GovernanceTimelock govTimelock;\n    mockProtocolRewardsPool rewardsPool;\n    esLBR eslbr;\n\n    address exploiter = address(0xfff);\n    address victim = address(0xeee);\n\n    function setUp() public {\n        govTimelock = new GovernanceTimelock(0, new address[](0), new address[](0), address(0));\n        configurator = new Configurator(address(govTimelock), address(0));\n        rewardsPool = new mockProtocolRewardsPool();\n        eslbr = new esLBR(address(configurator));\n\n        rewardsPool.setTokenAddress(address(eslbr));\n\n        address[] memory minter = new address[](1);\n        minter[0] = address(this);\n        bool[] memory minterBool = new bool[](1);\n        minterBool[0] = true;\n        configurator.setTokenMiner(minter, minterBool); // set this contract as the esLBR minter\n        configurator.setProtocolRewardsPool(address(rewardsPool));\n\n        eslbr.mint(exploiter, 100 ether);\n        eslbr.mint(victim, 100 ether);\n        rewardsPool.setRewardPerTokenStored(1);\n    }\n\n    function testMintFailRefreshReward() public {\n        assertEq(eslbr.balanceOf(exploiter), eslbr.balanceOf(victim), \"Should start with equal esLBR balance\");\n        assertEq(rewardsPool.earned(exploiter), rewardsPool.earned(victim), \"Should start with equal rewards accrued\");\n\n        rewardsPool.setRewardPerTokenStored(2);\n\n        eslbr.mint(victim, 100 ether); // refreshReward should pass\n        rewardsPool.forceRevert(true); // Assume something occur, causing the refreshReward become unavailable\n        eslbr.mint(exploiter, 100 ether);\n\n        // Record earning rewards to latest rate\n        rewardsPool.forceRevert(false);\n        rewardsPool.refreshReward(exploiter);\n        rewardsPool.refreshReward(victim);\n\n        assertGt(rewardsPool.earned(exploiter), rewardsPool.earned(victim), \"Exploiter should have more reward by this flaw\");\n    }\n\n    function testBurnFailRefreshReward() public {\n        assertEq(eslbr.balanceOf(exploiter), eslbr.balanceOf(victim), \"Should start with equal esLBR balance\");\n        assertEq(rewardsPool.earned(exploiter), rewardsPool.earned(victim), \"Should start with equal rewards accrued\");\n\n        rewardsPool.forceRevert(true); // Assume something occur, causing the refreshReward become unavailable\n        eslbr.burn(victim, 100 ether); // The victim unstake during that time\n\n        // Record earning rewards to latest rate\n        rewardsPool.forceRevert(false);\n        rewardsPool.refreshReward(exploiter);\n        rewardsPool.refreshReward(victim);\n\n        assertGt(rewardsPool.earned(exploiter), rewardsPool.earned(victim), \"Victim should loss earned rewards by this flaw\");\n    }\n}\n\ncontract mockProtocolRewardsPool {\n    esLBR public eslbr;\n\n    // Sum of (reward ratio * dt * 1e18 / total supply)\n    uint public rewardPerTokenStored;\n    // User address => rewardPerTokenStored\n    mapping(address => uint) public userRewardPerTokenPaid;\n    // User address => rewards to be claimed\n    mapping(address => uint) public rewards;\n\n    bool isForceRevert; // for mockup reverting on refreshreward\n\n    function setTokenAddress(address _eslbr) external {\n        eslbr = esLBR(_eslbr);\n    }\n\n    // User address => esLBR balance\n    function stakedOf(address staker) internal view returns (uint256) {\n        return eslbr.balanceOf(staker);\n    }\n\n    function earned(address _account) public view returns (uint) {\n        return ((stakedOf(_account) * (rewardPerTokenStored - userRewardPerTokenPaid[_account])) / 1e18) + rewards[_account];\n    }\n\n    /**\n     * @dev Call this function when deposit or withdraw ETH on Lybra and update the status of corresponding user.\n     */\n    modifier updateReward(address account) {\n        if (isForceRevert) revert();\n        rewards[account] = earned(account);\n        userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        _;\n    }\n\n    function refreshReward(address _account) external updateReward(_account) {}\n\n    function forceRevert(bool _isForce) external {\n        isForceRevert = _isForce;\n    }\n\n    function setRewardPerTokenStored(uint value) external {\n        rewardPerTokenStored = value;\n    }\n}\n```\n\nThe test should pass without errors.\n\n```shell\nRunning 2 tests for test/esLBR.t.sol:C4esLBRTest\n[PASS] testBurnFailRefreshReward() (gas: 141678)\n[PASS] testMintFailRefreshReward() (gas: 188308)\nTest result: ok. 2 passed; 0 failed; finished in 2.50ms\n```\n\nPlease follow this [gist](https://gist.github.com/t-nero/e97d8b9c7c5067b1638fe2b929b45456) if you prefer my instructions on how I setup the audit repo with Foundry environment.\n\n### Tools Used\nManual review, Foundry\n\n### Recommended Mitigation Steps\n\nThe `refreshReward()` function should be a mandatory action inside either the `mint()` or `burn()` functions. The try-catch statement should be removed.\n\n**[LybraFinance confirmed](https://github.com/code-423n4/2023-06-lybra-findings/issues/794#issuecomment-1639626907)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-06-lybra",
  "Code": [
    {
      "filename": "contracts/lybra/token/esLBR.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.17;\n/**\n * @title esLBR is an ERC20-compliant token, but cannot be transferred and can only be minted through the esLBRMinter contract or redeemed for LBR by destruction.\n * - The maximum amount that can be minted through the esLBRMinter contract is 55 million.\n * - esLBR can be used for community governance voting.\n */\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol\";\nimport \"../interfaces/Iconfigurator.sol\";\n\ninterface IProtocolRewardsPool {\n    function refreshReward(address user) external;\n}\n\ncontract esLBR is ERC20Votes {\n    Iconfigurator public immutable configurator;\n\n    uint256 maxSupply = 100_000_000 * 1e18;\n\n    constructor(address _config) ERC20Permit(\"esLBR\") ERC20(\"esLBR\", \"esLBR\") {\n        configurator = Iconfigurator(_config);\n    }\n\n    function _transfer(address, address, uint256) internal virtual override {\n        revert(\"not authorized\");\n    }\n\n    function mint(address user, uint256 amount) external returns (bool) {\n        require(configurator.tokenMiner(msg.sender), \"not authorized\");\n        require(totalSupply() + amount <= maxSupply, \"exceeding the maximum supply quantity.\");\n        try IProtocolRewardsPool(configurator.getProtocolRewardsPool()).refreshReward(user) {} catch {}\n        _mint(user, amount);\n        return true;\n    }\n\n    function burn(address user, uint256 amount) external returns (bool) {\n        require(configurator.tokenMiner(msg.sender), \"not authorized\");\n        try IProtocolRewardsPool(configurator.getProtocolRewardsPool()).refreshReward(user) {} catch {}\n        _burn(user, amount);\n        return true;\n    }\n}"
    }
  ]
}