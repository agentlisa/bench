{
  "Title": "Unnecessary stack variable in `Governance::encodeGeneralPurposeGovernanceMessage`",
  "Content": "[`Governance::encodeGeneralPurposeGovernanceMessage`](https://github.com/wormhole-foundation/example-native-token-transfers/blob/f4e2277b358349dbfb8a654d19a925628d48a8af/evm/src/wormhole/Governance.sol#L126-L144) currently assigns the stack variable `callDataLength`; however, this is not necessary as the (already checked) downcast can be performed directly within the subsequent packed encoding.\n\n```solidity\nfunction encodeGeneralPurposeGovernanceMessage(GeneralPurposeGovernanceMessage memory m)\n    public\n    pure\n    returns (bytes memory encoded)\n{\n    if (m.callData.length > type(uint16).max) {\n        revert PayloadTooLong(m.callData.length);\n    }\n    uint16 callDataLength = uint16(m.callData.length);\n    return abi.encodePacked(\n        MODULE,\n        m.action,\n        m.chain,\n        m.governanceContract,\n        m.governedContract,\n        callDataLength,\n        m.callData\n    );\n}\n```\n\nConsider removing this stack variable to save gas.\n\n**Wormhole Foundation:** This is used as a view and is not called internally, so gas is not a concern.\n\n**Cyfrin:** Acknowledged.",
  "Impact": "GAS",
  "Source": "",
  "Code": [
    {
      "filename": "evm/src/wormhole/Governance.sol",
      "content": "// SPDX-License-Identifier: Apache 2\npragma solidity >=0.8.8 <0.9.0;\n\nimport \"wormhole-solidity-sdk/interfaces/IWormhole.sol\";\nimport \"wormhole-solidity-sdk/libraries/BytesParsing.sol\";\n\ncontract Governance {\n    using BytesParsing for bytes;\n\n    // \"GeneralPurposeGovernance\" (left padded)\n    bytes32 public constant MODULE =\n        0x000000000000000047656E6572616C507572706F7365476F7665726E616E6365;\n\n    enum GovernanceAction {\n        UNDEFINED,\n        EVM_CALL\n    }\n\n    IWormhole immutable wormhole;\n\n    error PayloadTooLong(uint256 size);\n    error InvalidModule(bytes32 module);\n    error InvalidAction(uint8 action);\n    error InvalidGovernanceChainId(uint16 chainId);\n    error InvalidGovernanceContract(bytes32 contractAddress);\n    error GovernanceActionAlreadyConsumed(bytes32 digest);\n\n    error NotRecipientChain(uint16 chainId);\n    error NotRecipientContract(address contractAddress);\n\n    bytes32 constant CONSUMED_GOVERNANCE_ACTIONS_SLOT =\n        bytes32(uint256(keccak256(\"governance.consumedGovernanceActions\")) - 1);\n\n    function _getConsumedGovernanceActionsStorage()\n        private\n        pure\n        returns (mapping(bytes32 => bool) storage $)\n    {\n        uint256 slot = uint256(CONSUMED_GOVERNANCE_ACTIONS_SLOT);\n        assembly (\"memory-safe\") {\n            $.slot := slot\n        }\n    }\n\n    /*\n    * @dev General purpose governance message to call arbitrary methods on a governed smart contract.\n    *      This message adheres to the Wormhole governance packet standard: https://github.com/wormhole-foundation/wormhole/blob/main/whitepapers/0002_governance_messaging.md\n    *      The wire format for this message is:\n    *      - MODULE - 32 bytes\n    *      - action - 1 byte\n    *      - chain - 2 bytes\n    *      - governanceContract - 20 bytes\n    *      - governedContract - 20 bytes\n    *      - callDataLength - 2 bytes\n    *      - callData - `callDataLength` bytes\n    */\n    struct GeneralPurposeGovernanceMessage {\n        uint8 action;\n        uint16 chain;\n        address governanceContract;\n        address governedContract;\n        bytes callData;\n    }\n\n    constructor(address _wormhole) {\n        wormhole = IWormhole(_wormhole);\n    }\n\n    function performGovernance(bytes calldata vaa) external {\n        IWormhole.VM memory verified = _verifyGovernanceVAA(vaa);\n        GeneralPurposeGovernanceMessage memory message =\n            parseGeneralPurposeGovernanceMessage(verified.payload);\n\n        if (message.action != uint8(GovernanceAction.EVM_CALL)) {\n            revert InvalidAction(message.action);\n        }\n\n        if (message.chain != wormhole.chainId()) {\n            revert NotRecipientChain(message.chain);\n        }\n\n        if (message.governanceContract != address(this)) {\n            revert NotRecipientContract(message.governanceContract);\n        }\n\n        // TODO: any other checks? the call is trusted (signed by guardians),\n        // but what's the worst that could happen to this contract?\n        (bool success, bytes memory returnData) = message.governedContract.call(message.callData);\n        if (!success) {\n            revert(string(returnData));\n        }\n    }\n\n    function _replayProtect(bytes32 digest) internal {\n        mapping(bytes32 => bool) storage $ = _getConsumedGovernanceActionsStorage();\n        if ($[digest]) {\n            revert GovernanceActionAlreadyConsumed(digest);\n        }\n        $[digest] = true;\n    }\n\n    function _verifyGovernanceVAA(bytes memory encodedVM)\n        internal\n        returns (IWormhole.VM memory parsedVM)\n    {\n        (IWormhole.VM memory vm, bool valid, string memory reason) =\n            wormhole.parseAndVerifyVM(encodedVM);\n\n        if (!valid) {\n            revert(reason);\n        }\n\n        if (vm.emitterChainId != wormhole.governanceChainId()) {\n            revert InvalidGovernanceChainId(vm.emitterChainId);\n        }\n\n        if (vm.emitterAddress != wormhole.governanceContract()) {\n            revert InvalidGovernanceContract(vm.emitterAddress);\n        }\n\n        _replayProtect(vm.hash);\n\n        return vm;\n    }\n\n    function encodeGeneralPurposeGovernanceMessage(GeneralPurposeGovernanceMessage memory m)\n        public\n        pure\n        returns (bytes memory encoded)\n    {\n        if (m.callData.length > type(uint16).max) {\n            revert PayloadTooLong(m.callData.length);\n        }\n        uint16 callDataLength = uint16(m.callData.length);\n        return abi.encodePacked(\n            MODULE,\n            m.action,\n            m.chain,\n            m.governanceContract,\n            m.governedContract,\n            callDataLength,\n            m.callData\n        );\n    }\n\n    function parseGeneralPurposeGovernanceMessage(bytes memory encoded)\n        public\n        pure\n        returns (GeneralPurposeGovernanceMessage memory message)\n    {\n        uint256 offset = 0;\n\n        bytes32 module;\n        (module, offset) = encoded.asBytes32Unchecked(offset);\n        if (module != MODULE) {\n            revert InvalidModule(module);\n        }\n\n        (message.action, offset) = encoded.asUint8Unchecked(offset);\n        (message.chain, offset) = encoded.asUint16Unchecked(offset);\n        (message.governanceContract, offset) = encoded.asAddressUnchecked(offset);\n        (message.governedContract, offset) = encoded.asAddressUnchecked(offset);\n        uint256 callDataLength;\n        (callDataLength, offset) = encoded.asUint16Unchecked(offset);\n        (message.callData, offset) = encoded.sliceUnchecked(offset, callDataLength);\n        encoded.checkLength(offset);\n    }\n}"
    }
  ]
}