{
  "Title": "M-3: Incompatability with deflationary / fee-on-transfer tokens",
  "Content": "# Issue M-3: Incompatability with deflationary / fee-on-transfer tokens \n\nSource: https://github.com/sherlock-audit/2022-09-harpie-judging/tree/main/005-M \n\n## Found by \nLambda, cccz, hansfriese, IEatBabyCarrots, rbserver, JohnSmith, minhquanym, Tomo, leastwood, dipp, defsec, HonorLt, IllIllI, saian, csanuragjain\n\n## Summary\n\nhttps://github.com/Harpieio/contracts/blob/97083d7ce8ae9d85e29a139b1e981464ff92b89e/contracts/Transfer.sol#L93-L100\n\nIn case ERC20 token is fee-on-transfer, Vault can loss funds when users withdraw\n\n## Vulnerability Detail\n\nIn `Transfer.transferERC20()` function, this function called `logIncomingERC20()` with the exact amount used when it called `safeTransferFrom()`. In case ERC20 token is fee-on-transfer, the actual amount that Vault received may be less than the amount is recorded in `logIncomingERC20()`. \n\nThe result is when a user withdraws his funds from `Vault`, Vault can be lost and it may make unable for later users to withdraw their funds.\n\n## Proof of Concept\n\nConsider the scenario\n1. Token X is fee-on-transfer and it took 10% for each transfer. Alice has 1000 token X and Bob has 2000 token X\n2. Assume that both Alice and Bob are attacked. Harpie transfers all token of Alice and Bob to Vault. It recorded that the amount stored for token X of Alice is 1000 and Bob is 2000. But since token X has 10% fee, Vault only receives 2700 token X.\n3. Now Bob withdraw his funds back. With `amountStored = 2000`, he will transfer 2000 token X out of the Vault and received 1800. \n4. Now the Vault only has 700 token X left and obviously it's unable for Alice to withdraw\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider calculating the actual amount Vault received to call `logIncomingERC20()`\nTransfer the tokens first and compare pre-/after token balances to compute the actual transferred amount.\n\n## Harpie Team\n\nUsing difference in balance in vault rather than token transfer amount. Fix [here](https://github.com/Harpieio/contracts/pull/4/commits/550065a5e9d625ef93a862bc5f74f140d57998fa).\n\n## Lead Senior Watson\n\nWhile it's true the fix does allow for compatabiliy with fee-on-transfer tokens, it does not correctly handle rebasing tokens. Might be useful to explicily note that rebasing tokens are not supported or instead you could adopt mint shares to represent the ownership over the vault's tokens.\n\n## Harpie Team\n\nOn rebasing tokens, we just won't be able to support them for now.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/3",
  "Code": [
    {
      "filename": "contracts/Transfer.sol",
      "content": "// contracts/delegator.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./Vault.sol\";\n\n/// @notice This contract is designed to move ERC20s and ERC721s from user wallets into the noncustodial Vault contract.\n/// After receiving user Approval, it uses server-side EOAs to call below functions when we detect malicious transactions.\ncontract Transfer {\n    /// @dev We use safeERC20 to work with noncompliant ERC20s\n    using SafeERC20 for IERC20; \n\n    /// @dev ERC20Details and ERC721Details are used to define an individual\n    /// token, along with its owner. these are used in our batchTransfer functions\n    /// @param ownerAddress The owner of the token\n    /// @param fee The fee we charge users as they recover their assets\n    struct ERC20Details {\n        address ownerAddress;\n        address erc20Address;\n        uint128 erc20Fee;\n    }\n    struct ERC721Details {\n        address ownerAddress;\n        address erc721Address;\n        uint128 erc721Fee;\n        uint256 erc721Id;\n    }\n\n    /// @notice We've hardcoded the address that this contract transfers tokens to,\n    /// so your Approved tokens can only move to our noncustodial vault\n    /// @dev vaultAddress is the address of our noncustodial Vault contract\n    address immutable private vaultAddress;\n\n    /// @dev transferEOASetter is an EOA that can set other EOAs as callers of the\n    /// Transfer functions below\n    address immutable private transferEOASetter;\n\n    /// @dev a mapping of all possible EOAs that can call Transfer functions\n    mapping(address => bool) private _transferEOAs;\n\n    /// @dev Immutables are set upon contract construction for safety\n    constructor(address _vaultAddress, address _transferEOASetter) {\n        vaultAddress = _vaultAddress;\n        transferEOASetter = _transferEOASetter;\n    } \n\n    /// @dev These events fire when a token transfer and subsequent logging is successful\n    event successfulERC721Transfer(address ownerAddress, address erc721Address, uint256 tokenId);\n    event successfulERC20Transfer(address ownerAddress, address erc20Address);\n\n    /// @dev These events fire when an individual Transfer in a batchTransfer fails\n    event failedERC721Transfer(address ownerAddress, address erc721Address, uint256 tokenId);\n    event failedERC20Transfer(address ownerAddress, address erc20Address);\n \n    /// @notice This function transfers ERC721s to a noncustodial vault contract.\n    function transferERC721(address _ownerAddress, address _erc721Address, uint256 _erc721Id, uint128 _fee) public returns (bool) {\n        require(_transferEOAs[msg.sender] == true || msg.sender == address(this), \"Caller must be an approved caller.\");\n        require(_erc721Address != address(this));\n        (bool transferSuccess, bytes memory transferResult) = address(_erc721Address).call(\n            abi.encodeCall(IERC721(_erc721Address).transferFrom, (_ownerAddress, vaultAddress, _erc721Id))\n        );\n        require(transferSuccess, string (transferResult));\n        (bool loggingSuccess, bytes memory loggingResult) = address(vaultAddress).call(\n            abi.encodeCall(Vault.logIncomingERC721, (_ownerAddress, _erc721Address, _erc721Id, _fee))\n        );\n        require(loggingSuccess, string (loggingResult));\n        emit successfulERC721Transfer(_ownerAddress, _erc721Address, _erc721Id);\n        return transferSuccess;\n    }\n\n    /// @notice Batch transfering ERC721s in case we need to handle a large set of addresses at once (ie. protocol attack)\n    /// @dev Care must be taken to pass good data, this function does not revert when a single transaction throws \n    function batchTransferERC721(ERC721Details[] memory _details) public returns (bool) {\n        require(_transferEOAs[msg.sender] == true, \"Caller must be an approved caller.\");\n        for (uint256 i=0; i<_details.length; i++ ) {\n            // If statement adds a bit more gas cost, but allows us to continue the loop even if a\n            // token is not in a user's wallet anymore, instead of reverting the whole batch\n            try this.transferERC721{gas:400e3}(_details[i].ownerAddress, _details[i].erc721Address, _details[i].erc721Id, _details[i].erc721Fee) {}\n            catch {\n                emit failedERC721Transfer(_details[i].ownerAddress, _details[i].erc721Address, _details[i].erc721Id);\n            }\n        }\n        return true;\n    }\n\n    /// @notice This function transfers ERC20s to a noncustodial vault contract.\n    function transferERC20(address _ownerAddress, address _erc20Address, uint128 _fee) public returns (bool) {\n        require (_transferEOAs[msg.sender] == true || msg.sender == address(this), \"Caller must be an approved caller.\");\n        require(_erc20Address != address(this));\n        // Do the functions after the following line occur if the following line fails? Does it revert? Test\n        uint256 balance = IERC20(_erc20Address).balanceOf(_ownerAddress);\n        IERC20(_erc20Address).safeTransferFrom(\n            _ownerAddress, \n            vaultAddress, \n            balance\n        );\n        (bool loggingSuccess, bytes memory loggingResult) = address(vaultAddress).call(\n            abi.encodeCall(Vault.logIncomingERC20, (_ownerAddress, _erc20Address, balance, _fee))\n        );\n        require(loggingSuccess, string (loggingResult));\n        emit successfulERC20Transfer(_ownerAddress, _erc20Address);\n        return loggingSuccess;\n    }\n\n    /// @notice Batch transfering ERC20s in case we need to handle a large set of addresses at once (ie. protocol attack)\n    /// @dev Care must be taken to pass good data, this function does not revert when a single transaction throws\n    function batchTransferERC20(ERC20Details[] memory _details) public returns (bool) {\n        require(_transferEOAs[msg.sender] == true, \"Caller must be an approved caller.\");\n        for (uint256 i=0; i<_details.length; i++ ) {\n            try this.transferERC20{gas:400e3}(_details[i].ownerAddress, _details[i].erc20Address, _details[i].erc20Fee) {}\n            catch {\n                emit failedERC20Transfer(_details[i].ownerAddress, _details[i].erc20Address);\n            }\n        }\n        return true;\n    }\n\n    /// @dev This adds or removes transferEOAs that can call the above functions\n    function setTransferEOA(address _newTransferEOA, bool _value) public {\n        require(msg.sender == transferEOASetter, \"Caller must be an approved caller.\");\n        _transferEOAs[_newTransferEOA] = _value;\n    }\n}"
    }
  ]
}