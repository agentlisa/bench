{
  "Title": "[G-20] Setting the *constructor* to `payable`",
  "Content": "\nYou can cut out 10 opcodes in the creation-time EVM bytecode if you declare a constructor payable. Making the constructor payable eliminates the need for an initial check of `msg.value == 0` and saves `13 gas` on deployment with no security risks.\n\n### Context\n4 results - 4 files:\n```solidity\ncontracts/smart-contract-wallet/Proxy.sol:\n  15:     constructor(address _implementation) {\n```\n[Proxy.sol#L15](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/Proxy.sol#L15)\n\n```solidity\ncontracts/smart-contract-wallet/SmartAccountFactory.sol:\n  17:     constructor(address _baseImpl) {\n```\n[SmartAccountFactory.sol#L17](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccountFactory.sol#L17)\n\n```solidity\ncontracts/smart-contract-wallet/libs/MultiSend.sol:\n  12:     constructor() {\n```\n[MultiSend.sol#L12](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/libs/MultiSend.sol#L12)\n\n```solidity\ncontracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol:\n  35:     constructor(IEntryPoint _entryPoint, address _verifyingSigner) BasePaymaster(_entryPoint) {\n```\n[VerifyingSingletonPaymaster.sol#L35](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol#L35)\n\n```solidity\ncontracts\\smart-contract-wallet\\paymasters\\BasePaymaster.sol:\n  20:     constructor(IEntryPoint _entryPoint) {\n```\n[BasePaymaster.sol#L20](https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/paymasters/BasePaymaster.sol#L20)\n\n### Recommendation\nSet the constructor to ```payable```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2023-01-biconomy-smart-contract-wallet-contest",
  "Code": [
    {
      "filename": "scw-contracts/contracts/smart-contract-wallet/Proxy.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\n/**\n * @title Proxy // This is the user's wallet\n * @notice Basic proxy that delegates all calls to a fixed implementing contract.\n */\ncontract Proxy {\n\n    /* This is the keccak-256 hash of \"biconomy.scw.proxy.implementation\" subtracted by 1, and is validated in the constructor */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x37722d148fb373b961a84120b6c8d209709b45377878a466db32bbc40d95af26;\n\n    event Received(uint indexed value, address indexed sender, bytes data);\n\n    constructor(address _implementation) {\n         assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"biconomy.scw.proxy.implementation\")) - 1));\n         assembly {\n             sstore(_IMPLEMENTATION_SLOT,_implementation) \n         }\n    }\n\n    fallback() external payable {\n        address target;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            target := sload(_IMPLEMENTATION_SLOT)\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(gas(), target, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            switch result\n            case 0 {revert(0, returndatasize())}\n            default {return (0, returndatasize())}\n        }\n    }\n\n    receive() external payable {\n        emit Received(msg.value, msg.sender, \"\");\n    }\n\n}"
    },
    {
      "filename": "scw-contracts/contracts/smart-contract-wallet/SmartAccountFactory.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.12;\n\nimport \"./Proxy.sol\";\nimport \"./BaseSmartAccount.sol\"; \n\ncontract SmartAccountFactory {\n    address immutable public _defaultImpl; \n\n    // EOA + Version tracking\n    string public constant VERSION = \"1.0.2\";\n\n    //states : registry\n    // review need and impact of this update wallet -> account\n    mapping (address => bool) public isAccountExist;\n\n    constructor(address _baseImpl) {\n        require(_baseImpl != address(0), \"base wallet address can not be zero\");\n        _defaultImpl = _baseImpl;\n    }\n\n    // event SmartAccountCreated(address indexed _proxy, address indexed _implementation, address indexed _owner);\n    // EOA + Version tracking\n    event SmartAccountCreated(address indexed _proxy, address indexed _implementation, address indexed _owner, string version, uint256 _index);\n\n    /**\n     * @notice Deploys wallet using create2 and points it to _defaultImpl\n     * @param _owner EOA signatory of the wallet\n     * @param _entryPoint AA 4337 entry point address\n     * @param _handler fallback handler address\n     * @param _index extra salt that allows to deploy more wallets if needed for same EOA (default 0)\n     */\n    function deployCounterFactualWallet(address _owner, address _entryPoint, address _handler, uint _index) public returns(address proxy){\n        bytes32 salt = keccak256(abi.encodePacked(_owner, address(uint160(_index))));\n        bytes memory deploymentData = abi.encodePacked(type(Proxy).creationCode, uint(uint160(_defaultImpl)));\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            proxy := create2(0x0, add(0x20, deploymentData), mload(deploymentData), salt)\n        }\n        require(address(proxy) != address(0), \"Create2 call failed\");\n        // EOA + Version tracking\n        emit SmartAccountCreated(proxy,_defaultImpl,_owner, VERSION, _index);\n        BaseSmartAccount(proxy).init(_owner, _entryPoint, _handler);\n        isAccountExist[proxy] = true;\n    }\n\n    /**\n     * @notice Deploys wallet using create and points it to _defaultImpl\n     * @param _owner EOA signatory of the wallet\n     * @param _entryPoint AA 4337 entry point address\n     * @param _handler fallback handler address\n    */ \n    function deployWallet(address _owner, address _entryPoint, address _handler) public returns(address proxy){ \n        bytes memory deploymentData = abi.encodePacked(type(Proxy).creationCode, uint(uint160(_defaultImpl)));\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            proxy := create(0x0, add(0x20, deploymentData), mload(deploymentData))\n        }\n        BaseSmartAccount(proxy).init(_owner, _entryPoint, _handler);\n        isAccountExist[proxy] = true;\n    }\n\n    /**\n     * @notice Allows to find out wallet address prior to deployment\n     * @param _owner EOA signatory of the wallet\n     * @param _index extra salt that allows to deploy more wallets if needed for same EOA (default 0)\n    */\n    function getAddressForCounterfactualWallet(address _owner, uint _index) external view returns (address _wallet) {\n       bytes memory code = abi.encodePacked(type(Proxy).creationCode, uint(uint160(_defaultImpl)));\n       bytes32 salt = keccak256(abi.encodePacked(_owner, address(uint160(_index))));\n       bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), salt, keccak256(code)));\n        _wallet = address(uint160(uint(hash)));\n    }\n\n}"
    },
    {
      "filename": "scw-contracts/contracts/smart-contract-wallet/libs/MultiSend.sol",
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.12;\n\n/// @title Multi Send - Allows to batch multiple transactions into one.\n/// @author Nick Dodson - <nick.dodson@consensys.net>\n/// @author Gonçalo Sá - <goncalo.sa@consensys.net>\n/// @author Stefan George - <stefan@gnosis.io>\n/// @author Richard Meissner - <richard@gnosis.io>\ncontract MultiSend {\n    address private immutable multisendSingleton;\n\n    constructor() {\n        multisendSingleton = address(this);\n    }\n\n    /// @dev Sends multiple transactions and reverts all if one fails.\n    /// @param transactions Encoded transactions. Each transaction is encoded as a packed bytes of\n    ///                     operation as a uint8 with 0 for a call or 1 for a delegatecall (=> 1 byte),\n    ///                     to as a address (=> 20 bytes),\n    ///                     value as a uint256 (=> 32 bytes),\n    ///                     data length as a uint256 (=> 32 bytes),\n    ///                     data as bytes.\n    ///                     see abi.encodePacked for more information on packed encoding\n    /// @notice This method is payable as delegatecalls keep the msg.value from the previous call\n    ///         If the calling method (e.g. execTransaction) received ETH this would revert otherwise\n    function multiSend(bytes memory transactions) public payable {\n        require(address(this) != multisendSingleton, \"MultiSend should only be called via delegatecall\");\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let length := mload(transactions)\n            let i := 0x20\n            for {\n                // Pre block is not used in \"while mode\"\n            } lt(i, length) {\n                // Post block is not used in \"while mode\"\n            } {\n                // First byte of the data is the operation.\n                // We shift by 248 bits (256 - 8 [operation byte]) it right since mload will always load 32 bytes (a word).\n                // This will also zero out unused data.\n                let operation := shr(0xf8, mload(add(transactions, i)))\n                // We offset the load address by 1 byte (operation byte)\n                // We shift it right by 96 bits (256 - 160 [20 address bytes]) to right-align the data and zero out unused data.\n                let to := shr(0x60, mload(add(transactions, add(i, 0x01))))\n                // We offset the load address by 21 byte (operation byte + 20 address bytes)\n                let value := mload(add(transactions, add(i, 0x15)))\n                // We offset the load address by 53 byte (operation byte + 20 address bytes + 32 value bytes)\n                let dataLength := mload(add(transactions, add(i, 0x35)))\n                // We offset the load address by 85 byte (operation byte + 20 address bytes + 32 value bytes + 32 data length bytes)\n                let data := add(transactions, add(i, 0x55))\n                let success := 0\n                switch operation\n                    case 0 {\n                        success := call(gas(), to, value, data, dataLength, 0, 0)\n                    }\n                    case 1 {\n                        success := delegatecall(gas(), to, data, dataLength, 0, 0)\n                    }\n                if eq(success, 0) {\n                    revert(0, 0)\n                }\n                // Next entry starts at 85 byte + data length\n                i := add(i, add(0x55, dataLength))\n            }\n        }\n    }\n}"
    },
    {
      "filename": "scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.12;\n\n/* solhint-disable reason-string */\nimport \"../../BasePaymaster.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../../PaymasterHelpers.sol\";\n// import \"../samples/Signatures.sol\";\n\n\n/**\n * A sample paymaster that uses external service to decide whether to pay for the UserOp.\n * The paymaster trusts an external signer to sign the transaction.\n * The calling user must pass the UserOp to that external signer first, which performs\n * whatever off-chain verification before signing the UserOp.\n * Note that this signature is NOT a replacement for wallet signature:\n * - the paymaster signs to agree to PAY for GAS.\n * - the wallet signs to prove identity and wallet ownership.\n */\ncontract VerifyingSingletonPaymaster is BasePaymaster {\n\n    using ECDSA for bytes32;\n    // possibly //  using Signatures for UserOperation;\n    using UserOperationLib for UserOperation;\n    using PaymasterHelpers for UserOperation;\n    using PaymasterHelpers for bytes;\n    using PaymasterHelpers for PaymasterData;\n\n    mapping(address => uint256) public paymasterIdBalances;\n\n    address public verifyingSigner;\n\n    constructor(IEntryPoint _entryPoint, address _verifyingSigner) BasePaymaster(_entryPoint) {\n        require(address(_entryPoint) != address(0), \"VerifyingPaymaster: Entrypoint can not be zero address\");\n        require(_verifyingSigner != address(0), \"VerifyingPaymaster: signer of paymaster can not be zero address\");\n        verifyingSigner = _verifyingSigner;\n    }\n\n    function deposit() public virtual override payable {\n        revert(\"Deposit must be for a paymasterId. Use depositFor\");\n    }\n\n    /**\n     * add a deposit for this paymaster and given paymasterId (Dapp Depositor address), used for paying for transaction fees\n     */\n    function depositFor(address paymasterId) public payable {\n        require(!Address.isContract(paymasterId), \"Paymaster Id can not be smart contract address\");\n        require(paymasterId != address(0), \"Paymaster Id can not be zero address\");\n        paymasterIdBalances[paymasterId] += msg.value;\n        entryPoint.depositTo{value : msg.value}(address(this));\n    }\n\n    function withdrawTo(address payable withdrawAddress, uint256 amount) public override {\n        uint256 currentBalance = paymasterIdBalances[msg.sender];\n        require(amount <= currentBalance, \"Insufficient amount to withdraw\");\n        paymasterIdBalances[msg.sender] -= amount;\n        entryPoint.withdrawTo(withdrawAddress, amount);\n    }\n    \n    /**\n    this function will let owner change signer\n    */\n    function setSigner( address _newVerifyingSigner) external onlyOwner{\n        require(_newVerifyingSigner != address(0), \"VerifyingPaymaster: new signer can not be zero address\");\n        verifyingSigner = _newVerifyingSigner;\n    }\n\n    /**\n     * return the hash we're going to sign off-chain (and validate on-chain)\n     * this method is called by the off-chain service, to sign the request.\n     * it is called on-chain from the validatePaymasterUserOp, to validate the signature.\n     * note that this signature covers all fields of the UserOperation, except the \"paymasterAndData\",\n     * which will carry the signature itself.\n     */\n    function getHash(UserOperation calldata userOp)\n    public pure returns (bytes32) {\n        //can't use userOp.hash(), since it contains also the paymasterAndData itself.\n        return keccak256(abi.encode(\n                userOp.getSender(),\n                userOp.nonce,\n                keccak256(userOp.initCode),\n                keccak256(userOp.callData),\n                userOp.callGasLimit,\n                userOp.verificationGasLimit,\n                userOp.preVerificationGas,\n                userOp.maxFeePerGas,\n                userOp.maxPriorityFeePerGas\n            ));\n    }\n\n    /**\n     * verify our external signer signed this request.\n     * the \"paymasterAndData\" is expected to be the paymaster and a signature over the entire request params\n     */\n    function validatePaymasterUserOp(UserOperation calldata userOp, bytes32 /*userOpHash*/, uint256 requiredPreFund)\n    external view override returns (bytes memory context, uint256 deadline) {\n        (requiredPreFund);\n        bytes32 hash = getHash(userOp);\n\n        PaymasterData memory paymasterData = userOp.decodePaymasterData();\n        uint256 sigLength = paymasterData.signatureLength;\n\n        //ECDSA library supports both 64 and 65-byte long signatures.\n        // we only \"require\" it here so that the revert reason on invalid signature will be of \"VerifyingPaymaster\", and not \"ECDSA\"\n        require(sigLength == 64 || sigLength == 65, \"VerifyingPaymaster: invalid signature length in paymasterAndData\");\n        require(verifyingSigner == hash.toEthSignedMessageHash().recover(paymasterData.signature), \"VerifyingPaymaster: wrong signature\");\n        require(requiredPreFund <= paymasterIdBalances[paymasterData.paymasterId], \"Insufficient balance for paymaster id\");\n        return (userOp.paymasterContext(paymasterData), 0);\n    }\n\n    /**\n   * @dev Executes the paymaster's payment conditions\n   * @param mode tells whether the op succeeded, reverted, or if the op succeeded but cause the postOp to revert\n   * @param context payment conditions signed by the paymaster in `validatePaymasterUserOp`\n   * @param actualGasCost amount to be paid to the entry point in wei\n   */\n  function _postOp(\n    PostOpMode mode,\n    bytes calldata context,\n    uint256 actualGasCost\n  ) internal virtual override {\n    (mode);\n    // (mode,context,actualGasCost); // unused params\n    PaymasterContext memory data = context.decodePaymasterContext();\n    address extractedPaymasterId = data.paymasterId;\n    paymasterIdBalances[extractedPaymasterId] -= actualGasCost;\n  }\n\n}"
    },
    {
      "filename": "scw-contracts/contracts/smart-contract-wallet/paymasters/BasePaymaster.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\n\n/* solhint-disable reason-string */\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@account-abstraction/contracts/interfaces/IPaymaster.sol\";\nimport \"@account-abstraction/contracts/interfaces/IEntryPoint.sol\";\n\n/**\n * Helper class for creating a paymaster.\n * provides helper methods for staking.\n * validates that the postOp is called only by the entryPoint\n */\nabstract contract BasePaymaster is IPaymaster, Ownable {\n\n    IEntryPoint public entryPoint;\n\n    constructor(IEntryPoint _entryPoint) {\n        setEntryPoint(_entryPoint);\n    }\n\n    function setEntryPoint(IEntryPoint _entryPoint) public onlyOwner {\n        entryPoint = _entryPoint;\n    }\n\n    function validatePaymasterUserOp(UserOperation calldata userOp, bytes32 userOpHash, uint256 maxCost)\n    external virtual override returns (bytes memory context, uint256 deadline);\n\n    function postOp(PostOpMode mode, bytes calldata context, uint256 actualGasCost) external override {\n        _requireFromEntryPoint();\n        _postOp(mode, context, actualGasCost);\n    }\n\n    /**\n     * post-operation handler.\n     * (verified to be called only through the entryPoint)\n     * @dev if subclass returns a non-empty context from validatePaymasterUserOp, it must also implement this method.\n     * @param mode enum with the following options:\n     *      opSucceeded - user operation succeeded.\n     *      opReverted  - user op reverted. still has to pay for gas.\n     *      postOpReverted - user op succeeded, but caused postOp (in mode=opSucceeded) to revert.\n     *                       Now this is the 2nd call, after user's op was deliberately reverted.\n     * @param context - the context value returned by validatePaymasterUserOp\n     * @param actualGasCost - actual gas used so far (without this postOp call).\n     */\n    function _postOp(PostOpMode mode, bytes calldata context, uint256 actualGasCost) internal virtual {\n\n        (mode,context,actualGasCost); // unused params\n        // subclass must override this method if validatePaymasterUserOp returns a context\n        revert(\"must override\");\n    }\n\n    /**\n     * add a deposit for this paymaster, used for paying for transaction fees\n     */\n    function deposit() public virtual payable {\n        entryPoint.depositTo{value : msg.value}(address(this));\n    }\n\n    /**\n     * withdraw value from the deposit\n     * @param withdrawAddress target to send to\n     * @param amount to withdraw\n     */\n    function withdrawTo(address payable withdrawAddress, uint256 amount) public virtual onlyOwner {\n        entryPoint.withdrawTo(withdrawAddress, amount);\n    }\n    /**\n     * add stake for this paymaster.\n     * This method can also carry eth value to add to the current stake.\n     * @param unstakeDelaySec - the unstake delay for this paymaster. Can only be increased.\n     */\n    function addStake(uint32 unstakeDelaySec) external payable onlyOwner {\n        entryPoint.addStake{value : msg.value}(unstakeDelaySec);\n    }\n\n    /**\n     * return current paymaster's deposit on the entryPoint.\n     */\n    function getDeposit() public view returns (uint256) {\n        return entryPoint.balanceOf(address(this));\n    }\n\n    /**\n     * unlock the stake, in order to withdraw it.\n     * The paymaster can't serve requests once unlocked, until it calls addStake again\n     */\n    function unlockStake() external onlyOwner {\n        entryPoint.unlockStake();\n    }\n\n    /**\n     * withdraw the entire paymaster's stake.\n     * stake must be unlocked first (and then wait for the unstakeDelay to be over)\n     * @param withdrawAddress the address to send withdrawn value.\n     */\n    function withdrawStake(address payable withdrawAddress) external onlyOwner {\n        entryPoint.withdrawStake(withdrawAddress);\n    }\n\n    /// validate the call is made from a valid entrypoint\n    function _requireFromEntryPoint() internal virtual {\n        require(msg.sender == address(entryPoint));\n    }\n}"
    }
  ]
}