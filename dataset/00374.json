{
  "Title": "H-2: If token does not oversell, users cannot claim tax refund on their tax free allocation.",
  "Content": "# Issue H-2: If token does not oversell, users cannot claim tax refund on their tax free allocation. \n\nSource: https://github.com/sherlock-audit/2024-03-zap-protocol-judging/issues/58 \n\nThe protocol has acknowledged this issue.\n\n## Found by \nbughuntoor, s1ce\n## Summary\nUsers may not be able to claim tax refund\n\n## Vulnerability Detail\nWithin TokenSale, upon depositing users, users have to pay tax. Then, users can receive a tax-free allocation - meaning they'll be refunded the tax they've paid on part of their deposit.\n\nThe problem is that due to a unnecessary require check, users cannot claim their tax refund, unless the token has oversold. \n```solidity\n function claim() external {\n        checkingEpoch();\n        require(\n            uint8(epoch) > 1 && !admin.blockClaim(address(this)),\n            \"TokenSale: Not time or not allowed\"\n        );\n\n        Staked storage s = stakes[msg.sender];\n        require(s.amount != 0, \"TokenSale: No Deposit\"); \n        require(!s.claimed, \"TokenSale: Already Claimed\");\n\n        uint256 left;\n        (s.share, left) = _claim(s);\n        require(left > 0, \"TokenSale: Nothing to claim\");  // @audit - problematic line \n        uint256 refundTaxAmount;\n        if (s.taxAmount > 0) {\n            uint256 tax = userTaxRate(s.amount, msg.sender);\n            uint256 taxFreeAllc = _maxTaxfreeAllocation(msg.sender) * PCT_BASE;\n            if (taxFreeAllc >= s.share) {\n                refundTaxAmount = s.taxAmount;\n            } else {\n                refundTaxAmount = (left * tax) / POINT_BASE; // tax refund is on the wrong amount \n            }\n            usdc.safeTransferFrom(marketingWallet, msg.sender, refundTaxAmount);\n        }\n        s.claimed = true;\n        usdc.safeTransfer(msg.sender, left);\n        emit Claim(msg.sender, left);\n    }\n```\n```solidity\n\n    function _claim(Staked memory _s) internal view returns (uint120, uint256) {\n        uint256 left;\n        if (state.totalPrivateSold > (state.totalSupplyInValue)) {\n            uint256 rate = (state.totalSupplyInValue * PCT_BASE) /\n                state.totalPrivateSold;\n            _s.share = uint120((uint256(_s.amount) * rate) / PCT_BASE);\n            left = uint256(_s.amount) - uint256(_s.share);\n        } else {\n            _s.share = uint120(_s.amount);\n        }\n\n        return (_s.share, left);\n    }\n```\n`left` only has value if the token has oversold. Meaning that even if the user has an infinite tax free allocation, if the token has not oversold, they won't be able to claim a tax refund. \n\n\n## Impact\nloss of funds\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-03-zap-protocol/blob/main/zap-contracts-labs/contracts/TokenSale.sol#L377\n\n## Tool used\n\nManual Review\n\n## Recommendation\nRemove the require check \n\n\n\n## Discussion\n\n**ZdravkoHr**\n\nEscalate\n\nThis should not be a valid issue. The idea of the `claim` function is to let investors claim the surplus amount that is left after the ICO has ended, i.e when tokens `oversell`.\n\n```solidity\n If the the demand is higher than supply, the number of tokens investors will receive is adjusted, and then the native token used to invest are partially refunded.\n```\n\nThe following claim stated in the report is also wrong: \n```Then, users can receive a tax-free allocation - meaning they'll be refunded the tax they've paid on part of their deposit.```\n\nTax free allocation does not mean users will pay all the taxes and will be refunded later for the tax free amount. They are just not charged for the given amount from the very beginning of the deposit process. So they should not receive any refund.\n\nThis is evident from the way the tax is calculated in[`TokenSale._processPrivate()`](https://github.com/sherlock-audit/2024-03-zap-protocol/blob/c2ad35aa844899fa24f6ed0cbfcf6c7e611b061a/zap-contracts-labs/contracts/TokenSale.sol#L231-L240)\n```solidity\n        if (sum > taxFreeAllcOfUser) {\n            uint256 userTxRate = userTaxRate(sum, _sender);\n            if (s.amount < taxFreeAllcOfUser) {\n                userTaxAmount =\n                    ((sum - taxFreeAllcOfUser) * userTxRate) /\n                    POINT_BASE;\n            } else {\n                userTaxAmount = (amount * userTxRate) / POINT_BASE;\n            }\n        }\n```\n\nThe reason why there is a tax refund logic in the `claim` function is because users that claim back `amount` of tokens will not have these tokens as deposited in the end of the ICO, therefore they should be refunded the tax they have paid for them.\n\n\n\n**sherlock-admin2**\n\n> Escalate\n> \n> This should not be a valid issue. The idea of the `claim` function is to let investors claim the surplus amount that is left after the ICO has ended, i.e when tokens `oversell`.\n> \n> ```solidity\n>  If the the demand is higher than supply, the number of tokens investors will receive is adjusted, and then the native token used to invest are partially refunded.\n> ```\n> \n> The following claim stated in the report is also wrong: \n> ```Then, users can receive a tax-free allocation - meaning they'll be refunded the tax they've paid on part of their deposit.```\n> \n> Tax free allocation does not mean users will pay all the taxes and will be refunded later for the tax free amount. They are just not charged for the given amount from the very beginning of the deposit process. So they should not receive any refund.\n> \n> This is evident from the way the tax is calculated in[`TokenSale._processPrivate()`](https://github.com/sherlock-audit/2024-03-zap-protocol/blob/c2ad35aa844899fa24f6ed0cbfcf6c7e611b061a/zap-contracts-labs/contracts/TokenSale.sol#L231-L240)\n> ```solidity\n>         if (sum > taxFreeAllcOfUser) {\n>             uint256 userTxRate = userTaxRate(sum, _sender);\n>             if (s.amount < taxFreeAllcOfUser) {\n>                 userTaxAmount =\n>                     ((sum - taxFreeAllcOfUser) * userTxRate) /\n>                     POINT_BASE;\n>             } else {\n>                 userTaxAmount = (amount * userTxRate) / POINT_BASE;\n>             }\n>         }\n> ```\n> \n> The reason why there is a tax refund logic in the `claim` function is because users that claim back `amount` of tokens will not have these tokens as deposited in the end of the ICO, therefore they should be refunded the tax they have paid for them.\n> \n> \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**koreanspicygarlic1**\n\nThis escalation is also plain wrong, watson has not properly understood the design of the system.\n\n**vsharma4394**\n\nIf the above reasoning is wrong then my issue #159  which has been invalidated becomes a valid issue,so can someone escalate that too. @Hash01011122 please look into it carefully please.\n\n**vsharma4394**\n\nHardcoding the value of taxfreeAllocation to zero implies that the protocol doesn't allow for taxFreeAllocation to occur as of now. So this directly implies that while claiming also taxFreeAmount should not be taken into consideration while refunding the amount to the user.\n\n\n**Hash01011122**\n\nWell I don't thoroughly understand the basis of this escalation as it is clearly mentioned in the codebase how tax system is calculated, where the tax-free allocation isn't zero. \n\n**vsharma4394**\n\n@Hash01011122 the following loc in _processPrivate function which is called when user deposits usdc has caused different understanding of he code \n```solidity\n uint256 taxFreeAllcOfUser = 0; // hardcode zero - all pools have ax\n\n        uint256 userTaxAmount;\n\n        if (sum > taxFreeAllcOfUser) {\n            uint256 userTxRate = userTaxRate(sum, _sender);\n            if (s.amount < taxFreeAllcOfUser) {\n                userTaxAmount =\n                    ((sum - taxFreeAllcOfUser) * userTxRate) /\n                    POINT_BASE;\n            } else {\n                userTaxAmount = (amount * userTxRate) / POINT_BASE;\n            }\n        }\n```\nDue to hardcoded value of taxFreeAllocation as zero ,user tax amount is calculated as follows\nuserTaxAmount = (amount * userTxRate) / POINT_BASE i.e while depositing users have to pay tax irrespective of having taxFreeAllocation. If logic is never executed. So while claiming also taxFreeAllocation should also not be taken into account so as be consistent with the code. (Making taxFreeAllocation to zero is intended design.)\n\nI think confusion has arised from considering taxFreeAllocation but it is considered as zero from starting due to hardcoded value of taxFreeAllocation as zero.\n\nAsking from sponsers is the best way to deal with all the issue related to claim function and tax related issue.\n\n**ZdravkoHr**\n\nThe issue is not that tax free allocation is 0. Even if it wasn't and the firsr if was entered, the user would not have been taxed for it. That's why I believe a refund should not be made\n\n**niketansainiantier**\n\nwe are not giving a refund for the tax if a sale does not reach the hard cap.\n\n**vsharma4394**\n\n@niketansainiantier so this issue should be invalid right?\n\n**Hash01011122**\n\nWell I agree with what @vsharma4394 has mentioned above and came to the same conclusion when I revisited codebase. @ZdravkoHr and even sponsors have confirmed this one. This is valid finding.\n\n**vsharma4394**\n\n@Hash01011122 i dont think that this issue is valid because @niketansainiantier clearly mentioned the following \n```we are taking the tax on the whole invested amount including all allocations, including the whitelist. So will refund the only tax on left amount(extra Amount).```\nNow if token oversells tax is refunded based on the extra amount which should not consider taxFreeAllocation as said by the sponsers. Thus in claim function \n```solidity\nif (s.taxAmount > 0) {\n            uint256 tax = userTaxRate(s.amount, msg.sender);\n            uint256 taxFreeAllc = _maxTaxfreeAllocation(msg.sender) * PCT_BASE;\n            if (taxFreeAllc >= s.share) {\n                refundTaxAmount = s.taxAmount;\n            } else {\n                refundTaxAmount = (left * tax) / POINT_BASE; // tax refund is on the wrong amount \n            }\n            usdc.safeTransferFrom(marketingWallet, msg.sender, refundTaxAmount);\n        }\n```\nRefundTaxAmount should always be  refundTaxAmount = (left * tax) / POINT_BASE because taxFreeAlloc is hardcoded as zero initially which clearly indicates protocol doesn't allow for taxFreeAllocation as of now.\n\n**Evert0x**\n\nI believe the escalation should be rejected the issue should stay as is.\n\nUsers should be able to get a tax refund on their tax-free allocation. \n\n> **Tax free allocation does not mean users will pay all the taxes and will be refunded later for the tax free amount.** They are just not charged for the given amount from the very beginning of the deposit process. So they should not receive any refund.\n\nThis is not true, would like to see a link to a public message or to a code comment as a counter argument \n\n**vsharma4394**\n\n> I believe the escalation should be rejected the issue should stay as is.\n> \n> Users should be able to get a tax refund on their tax-free allocation.\n> \n> > **Tax free allocation does not mean users will pay all the taxes and will be refunded later for the tax free amount.** They are just not charged for the given amount from the very beginning of the deposit process. So they should not receive any refund.\n> \n> This is not true, would like to see a link to a public message or to a code comment as a counter argument\n\n@Evert0x i agree the above reasoning is incorrect, please look at my reasoning and then decide\n\n**Evert0x**\n\n@vsharma4394  My understanding that the codebase is taxing all deposited and provide a tax-return on unallocated part + tax-free allocation. Which makes this issue a valid issue.\n\nSo if the token doesn't oversell, we should still take into account the tax free allocation. \n\nI don't understand how your previous comment provides an argument against that. \n\n**vsharma4394**\n\n> @vsharma4394 My understanding that the codebase is taxing all deposited and provide a tax-return on unallocated part + tax-free allocation. Which makes this issue a valid issue.\n> \n> So if the token doesn't oversell, we should still take into account the tax free allocation.\n> \n> I don't understand how your previous comment provides an argument against that.\n\nThis would most probably because of the protocol design @niketansainiantier  can answer it the best. \n\n**Evert0x**\n\nResult:\nHigh\nHas Duplicates\n\n**sherlock-admin3**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [ZdravkoHr](https://github.com/sherlock-audit/2024-03-zap-protocol-judging/issues/58/#issuecomment-2025286194): rejected\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/243",
  "Code": [
    {
      "filename": "zap-contracts-labs/contracts/TokenSale.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"./interfaces/ITokenSale.sol\";\nimport \"./interfaces/IAdmin.sol\";\nimport \"./interfaces/IAirdrops.sol\";\nimport \"./interfaces/IERC20D.sol\";\nimport \"./interfaces/IStaking.sol\";\nimport \"hardhat/console.sol\";\n\n/*\nA tokensale includes 3 stages: \n1. Private round. Only ion token holders can participate in this round. \n The Matic/USDC price is fixed in the beginning of the tokensale.\n All tokens available in the pre-sale will be made available through the private sale round. \n A single investor can purchase up to their maximum allowed investment defined by the tier.\n Investors can claim their tokens only when the private round is finished. \n If the total supply is higher than the total demand for this tokensale, investors purchase tokens up to their max allocation. \n If the the demand is higher than supply, the number of tokens investors will receive is adjusted, and then the native token used to invest are partially refunded.\n\n*/\n\n//TODO Change USDC address\n//TODO Change Marketing wallet address\n\ncontract TokenSale is Initializable, ITokenSale {\n    using SafeERC20 for IERC20D;\n\n    uint256 constant PCT_BASE = 10 ** 18;\n    uint256 constant POINT_BASE = 1000;\n    bytes32 constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    address public marketingWallet;\n\n    uint256 public maxAllocation; // in dollar with decimals\n    uint256 public globalTaxRate; // base 1000\n    uint256 public whitelistTxRate; // base 1000\n    bool public isKYCEnabled;\n\n    IStaking stakingContract;\n    Params params;\n    IERC20D public usdc;\n    IAdmin admin;\n    /**\n     * @dev current tokensale stage (epoch)\n     */\n    Epoch public override epoch;\n    bool isRaiseClaimed;\n    bool only;\n    bytes32 public constant OPERATOR = keccak256(\"OPERATOR\");\n    address[] public usersOnDeposit;\n\n    mapping(address => Staked) public override stakes;\n    mapping(address => uint256) public tokensaleTiers;\n    /** @dev Decrease result by 1 to access correct position */\n    mapping(address => uint256) public userDepositIndex;\n    mapping(address => bool) public isWhitelisted;\n\n    State state;\n\n    receive() external payable {}\n\n    function getState() external view returns (uint128, uint128) {\n        return (state.totalPrivateSold, state.totalSupplyInValue);\n    }\n\n    function initialize(\n        Params calldata _params,\n        address _stakingContract,\n        address _admin,\n        uint256 _maxAllocation,\n        uint256 _globalTaxRate,\n        bool _isKYC,\n        uint256 _whitelistTxRate\n    ) external initializer {\n        params = _params;\n        stakingContract = IStaking(_stakingContract);\n        admin = IAdmin(_admin);\n        state.totalSupplyInValue = uint128(\n            (uint256(_params.totalSupply) *\n                uint256(_params.privateTokenPrice)) / 10 ** 18\n            // removes USDB hardcode of six, awful\n        );\n        usdc = IERC20D(0xA9F81589Cc48Ff000166Bf03B3804A0d8Cec8114); //TODO change for mainnet\n        marketingWallet = 0x6507fFd283c32386B6065EA89744Ade21515e91E; //TODO change for mainnet\n        maxAllocation = _maxAllocation;\n        globalTaxRate = _globalTaxRate;\n        isKYCEnabled = _isKYC;\n        whitelistTxRate = _whitelistTxRate;\n    }\n\n    // allocation is amount in dollar without decimals\n    function userWhitelistAllocation(\n        address[] calldata users,\n        uint256[] calldata allocations\n    ) public {\n        require(admin.hasRole(OPERATOR, msg.sender), \"TokenSale: OnlyOperator\");\n        require(\n            users.length == allocations.length,\n            \"TokenSale: Invalid length\"\n        );\n        for (uint256 i = 0; i < users.length; i++) {\n            tokensaleTiers[users[i]] = allocations[i];\n        }\n    }\n\n    function whitelistUser(address[] calldata users) public {\n        require(admin.hasRole(OPERATOR, msg.sender), \"TokenSale: OnlyOperator\");\n        for (uint256 i = 0; i < users.length; i++) {\n            isWhitelisted[users[i]] = true;\n        }\n    }\n\n    function setAllocationAndTax(uint256[3] calldata _allocations) external {\n        require(block.timestamp <= params.privateStart, \"Time lapsed\");\n        require(admin.hasRole(OPERATOR, msg.sender), \"TokenSale: OnlyOperator\");\n        maxAllocation = _allocations[0];\n        globalTaxRate = _allocations[1];\n        whitelistTxRate = _allocations[2];\n    }\n\n    function setMarketingWallet(address _wallet) external {\n        _onlyAdmin();\n        marketingWallet = _wallet;\n    }\n\n    /**\n     * @dev setup the current tokensale stage (epoch)\n     */\n    function checkingEpoch() public {\n        uint256 time = block.timestamp;\n        if (\n            epoch != Epoch.Private &&\n            time >= params.privateStart &&\n            time <= params.privateEnd\n        ) {\n            epoch = Epoch.Private;\n            return;\n        }\n        if ((epoch != Epoch.Finished && (time > params.privateEnd))) {\n            epoch = Epoch.Finished;\n            return;\n        }\n    }\n\n    // to save size\n    function _onlyAdmin() internal view {\n        require(\n            admin.hasRole(DEFAULT_ADMIN_ROLE, msg.sender) ||\n                msg.sender == address(admin),\n            \"TokenSale: Onlyadmin\"\n        );\n    }\n\n    /**\n     * @dev invest usdc to the tokensale\n     */\n    function deposit(uint256 _amount) external {\n        console.log(\"kyc enabled\", isKYCEnabled);\n        if (isKYCEnabled) {\n            require(admin.isKYCDone(msg.sender) == true, \"KYC not done\");\n        }\n        address sender = msg.sender;\n        require(\n            !admin.blacklist(address(this), sender),\n            \"TokenSale: Blacklisted\"\n        );\n        checkingEpoch();\n\n        require(epoch == Epoch.Private, \"TokenSale: Incorrect time\");\n        require(_amount > 0, \"TokenSale: 0 deposit\");\n\n        if (userDepositIndex[sender] == 0) {\n            usersOnDeposit.push(sender);\n            userDepositIndex[sender] = usersOnDeposit.length;\n        }\n        if (epoch == Epoch.Private) {\n            _processPrivate(sender, _amount);\n        }\n    }\n\n    function destroy() external override {\n        _onlyAdmin();\n        uint256 amountUSDC = usdc.balanceOf(address(this));\n        if (amountUSDC > 0) {\n            usdc.safeTransfer(admin.wallet(), amountUSDC);\n        }\n        address payable wallet = payable(admin.wallet());\n        selfdestruct(wallet);\n    }\n\n    /**\n     * @notice withdraw accidently sent ERC20 tokens\n     * @param _tokenAddress address of token to withdraw\n     */\n    function removeOtherERC20Tokens(address _tokenAddress) external {\n        _onlyAdmin();\n        require(\n            _tokenAddress != address(usdc),\n            \"TokenSale: Can't withdraw usdc\"\n        );\n        uint256 balance = IERC20D(_tokenAddress).balanceOf(address(this));\n        IERC20D(_tokenAddress).safeTransfer(admin.wallet(), balance);\n\n        emit ERC20TokensRemoved(_tokenAddress, msg.sender, balance);\n    }\n\n    /**\n     * @dev processing usdc investment to the private round\n     * @param _sender - transaction sender\n     * @param _amount - investment amount in usdc\n     */\n    function _processPrivate(address _sender, uint256 _amount) internal {\n        require(_amount > 0, \"TokenSale: Too small\");\n\n        Staked storage s = stakes[_sender];\n        uint256 amount = _amount * PCT_BASE;\n        uint256 sum = s.amount + amount;\n\n        uint256 maxAllocationOfUser = (calculateMaxAllocation(_sender)) *\n            PCT_BASE;\n        require(sum <= maxAllocationOfUser, \"upto max allocation\");\n        uint256 taxFreeAllcOfUser = 0; // hardcode zero - all pools have ax\n\n        uint256 userTaxAmount;\n\n        if (sum > taxFreeAllcOfUser) {\n            uint256 userTxRate = userTaxRate(sum, _sender);\n            if (s.amount < taxFreeAllcOfUser) {\n                userTaxAmount =\n                    ((sum - taxFreeAllcOfUser) * userTxRate) /\n                    POINT_BASE;\n            } else {\n                userTaxAmount = (amount * userTxRate) / POINT_BASE;\n            }\n        }\n\n        if (userTaxAmount > 0) {\n            s.taxAmount += userTaxAmount;\n            usdc.safeTransferFrom(_sender, marketingWallet, userTaxAmount);\n        }\n        s.amount += uint128(amount);\n        state.totalPrivateSold += uint128(amount);\n        usdc.safeTransferFrom(_sender, address(this), amount);\n\n        /**@notice Forbid unstaking*/\n        // stakingContract.setPoolsEndTime(_sender, uint256(params.privateEnd)); // TODO: uncomment\n        emit DepositPrivate(_sender, _amount, address(this));\n    }\n\n    /**\n     * @dev sends the usdc raise to admin's wallet\n     */\n\n    function calculateMaxAllocation(address _sender) public returns (uint256) {\n        uint256 userMaxAllc = _maxTierAllc(_sender);\n\n        if (userMaxAllc > maxAllocation) {\n            return userMaxAllc;\n        } else {\n            return maxAllocation;\n        }\n    }\n\n    function _maxTaxfreeAllocation(address _sender) internal returns (uint256) {\n        uint256 userTierAllc = stakingContract.getAllocationOf(_sender);\n        uint256 giftedTierAllc = tokensaleTiers[_sender];\n\n        if (userTierAllc > giftedTierAllc) {\n            return userTierAllc;\n        } else {\n            return giftedTierAllc;\n        }\n    }\n\n    function _maxTierAllc(address _sender) internal returns (uint256) {\n        (uint256 userTier, uint256 userLockLvl, , ) = stakingContract\n            .getUserState(_sender);\n\n        uint256 giftedTierAllc = tokensaleTiers[_sender];\n\n        if (userTier == 0 && giftedTierAllc == 0) {\n            return 0;\n        }\n\n        uint256 userTierAllc = stakingContract.getAllocationOf(_sender);\n        uint256 nextTierAllc;\n        if (userLockLvl > 0 && userLockLvl < 4) {\n            nextTierAllc = stakingContract.getAllocations(\n                userLockLvl + 1,\n                userTier\n            );\n        } else {\n            nextTierAllc = stakingContract.getAllocations(\n                userLockLvl,\n                userTier + 1\n            );\n        }\n\n        if (nextTierAllc > userTierAllc) {\n            if (nextTierAllc > giftedTierAllc) {\n                return nextTierAllc;\n            } else {\n                return giftedTierAllc;\n            }\n        } else {\n            if (userTierAllc > giftedTierAllc) {\n                return userTierAllc;\n            } else {\n                return giftedTierAllc;\n            }\n        }\n    }\n\n    // _amount should be in dollar without decimals\n    function userTaxRate(\n        uint256 _amount,\n        address _sender\n    ) public returns (uint256) {\n        uint256 userTaxFreeAllc = 0;\n\n        if (_amount > userTaxFreeAllc) {\n            if (isWhitelisted[_sender]) {\n                return whitelistTxRate;\n            } else {\n                return globalTaxRate;\n            }\n        } else {\n            return 0;\n        }\n    }\n\n    function takeUSDCRaised() external override {\n        checkingEpoch();\n        require(epoch == Epoch.Finished, \"TokenSale: Not time yet\");\n        require(!isRaiseClaimed, \"TokenSale: Already paid\");\n\n        uint256 earned;\n\n        if (state.totalPrivateSold > state.totalSupplyInValue) {\n            earned = uint256(state.totalSupplyInValue);\n        } else {\n            earned = uint256(state.totalPrivateSold);\n        }\n\n        isRaiseClaimed = true;\n\n        if (earned > 0) {\n            uint256 bal = usdc.balanceOf(address(this));\n            uint256 returnValue = earned <= bal ? earned : bal;\n            usdc.safeTransfer(admin.wallet(), returnValue);\n        }\n\n        emit RaiseClaimed(admin.wallet(), earned);\n    }\n\n    /**\n     * @dev allows the participants of the private round to claim usdc left\n     */\n    function claim() external {\n        checkingEpoch();\n        require(\n            uint8(epoch) > 1 && !admin.blockClaim(address(this)),\n            \"TokenSale: Not time or not allowed\"\n        );\n\n        Staked storage s = stakes[msg.sender];\n        require(s.amount != 0, \"TokenSale: No Deposit\");\n        require(!s.claimed, \"TokenSale: Already Claimed\");\n\n        uint256 left;\n        (s.share, left) = _claim(s);\n        require(left > 0, \"TokenSale: Nothing to claim\");\n        uint256 refundTaxAmount;\n        if (s.taxAmount > 0) {\n            uint256 tax = userTaxRate(s.amount, msg.sender);\n            uint256 taxFreeAllc = _maxTaxfreeAllocation(msg.sender) * PCT_BASE;\n            if (taxFreeAllc >= s.share) {\n                refundTaxAmount = s.taxAmount;\n            } else {\n                refundTaxAmount = (left * tax) / POINT_BASE;\n            }\n            usdc.safeTransferFrom(marketingWallet, msg.sender, refundTaxAmount);\n        }\n        s.claimed = true;\n        usdc.safeTransfer(msg.sender, left);\n        emit Claim(msg.sender, left);\n    }\n\n    function _claim(Staked memory _s) internal view returns (uint120, uint256) {\n        uint256 left;\n        if (state.totalPrivateSold > (state.totalSupplyInValue)) {\n            uint256 rate = (state.totalSupplyInValue * PCT_BASE) /\n                state.totalPrivateSold;\n            _s.share = uint120((uint256(_s.amount) * rate) / PCT_BASE);\n            left = uint256(_s.amount) - uint256(_s.share);\n        } else {\n            _s.share = uint120(_s.amount);\n        }\n\n        return (_s.share, left);\n    }\n\n    function canClaim(address _user) external view returns (uint120, uint256) {\n        return _claim(stakes[_user]);\n    }\n\n    /**\n     * @dev sends Locked usdc to admin wallet\n     */\n\n    function takeLocked() external override {\n        _onlyAdmin();\n        require(\n            block.timestamp >= (params.privateEnd + 2592e3),\n            \"TokenSale: Not ended\"\n        );\n        uint256 amountUSDC = usdc.balanceOf(address(this));\n        if (amountUSDC > 0) {\n            usdc.safeTransfer(admin.wallet(), amountUSDC);\n        }\n    }\n\n    /**\n    @dev Total Tokens (in $) sold in IDO\n     */\n    function totalTokenSold() external view returns (uint128) {\n        return state.totalPrivateSold;\n    }\n}"
    },
    {
      "filename": "zap-contracts-labs/contracts/TokenSale.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"./interfaces/ITokenSale.sol\";\nimport \"./interfaces/IAdmin.sol\";\nimport \"./interfaces/IAirdrops.sol\";\nimport \"./interfaces/IERC20D.sol\";\nimport \"./interfaces/IStaking.sol\";\nimport \"hardhat/console.sol\";\n\n/*\nA tokensale includes 3 stages: \n1. Private round. Only ion token holders can participate in this round. \n The Matic/USDC price is fixed in the beginning of the tokensale.\n All tokens available in the pre-sale will be made available through the private sale round. \n A single investor can purchase up to their maximum allowed investment defined by the tier.\n Investors can claim their tokens only when the private round is finished. \n If the total supply is higher than the total demand for this tokensale, investors purchase tokens up to their max allocation. \n If the the demand is higher than supply, the number of tokens investors will receive is adjusted, and then the native token used to invest are partially refunded.\n\n*/\n\n//TODO Change USDC address\n//TODO Change Marketing wallet address\n\ncontract TokenSale is Initializable, ITokenSale {\n    using SafeERC20 for IERC20D;\n\n    uint256 constant PCT_BASE = 10 ** 18;\n    uint256 constant POINT_BASE = 1000;\n    bytes32 constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    address public marketingWallet;\n\n    uint256 public maxAllocation; // in dollar with decimals\n    uint256 public globalTaxRate; // base 1000\n    uint256 public whitelistTxRate; // base 1000\n    bool public isKYCEnabled;\n\n    IStaking stakingContract;\n    Params params;\n    IERC20D public usdc;\n    IAdmin admin;\n    /**\n     * @dev current tokensale stage (epoch)\n     */\n    Epoch public override epoch;\n    bool isRaiseClaimed;\n    bool only;\n    bytes32 public constant OPERATOR = keccak256(\"OPERATOR\");\n    address[] public usersOnDeposit;\n\n    mapping(address => Staked) public override stakes;\n    mapping(address => uint256) public tokensaleTiers;\n    /** @dev Decrease result by 1 to access correct position */\n    mapping(address => uint256) public userDepositIndex;\n    mapping(address => bool) public isWhitelisted;\n\n    State state;\n\n    receive() external payable {}\n\n    function getState() external view returns (uint128, uint128) {\n        return (state.totalPrivateSold, state.totalSupplyInValue);\n    }\n\n    function initialize(\n        Params calldata _params,\n        address _stakingContract,\n        address _admin,\n        uint256 _maxAllocation,\n        uint256 _globalTaxRate,\n        bool _isKYC,\n        uint256 _whitelistTxRate\n    ) external initializer {\n        params = _params;\n        stakingContract = IStaking(_stakingContract);\n        admin = IAdmin(_admin);\n        state.totalSupplyInValue = uint128(\n            (uint256(_params.totalSupply) *\n                uint256(_params.privateTokenPrice)) / 10 ** 18\n            // removes USDB hardcode of six, awful\n        );\n        usdc = IERC20D(0xA9F81589Cc48Ff000166Bf03B3804A0d8Cec8114); //TODO change for mainnet\n        marketingWallet = 0x6507fFd283c32386B6065EA89744Ade21515e91E; //TODO change for mainnet\n        maxAllocation = _maxAllocation;\n        globalTaxRate = _globalTaxRate;\n        isKYCEnabled = _isKYC;\n        whitelistTxRate = _whitelistTxRate;\n    }\n\n    // allocation is amount in dollar without decimals\n    function userWhitelistAllocation(\n        address[] calldata users,\n        uint256[] calldata allocations\n    ) public {\n        require(admin.hasRole(OPERATOR, msg.sender), \"TokenSale: OnlyOperator\");\n        require(\n            users.length == allocations.length,\n            \"TokenSale: Invalid length\"\n        );\n        for (uint256 i = 0; i < users.length; i++) {\n            tokensaleTiers[users[i]] = allocations[i];\n        }\n    }\n\n    function whitelistUser(address[] calldata users) public {\n        require(admin.hasRole(OPERATOR, msg.sender), \"TokenSale: OnlyOperator\");\n        for (uint256 i = 0; i < users.length; i++) {\n            isWhitelisted[users[i]] = true;\n        }\n    }\n\n    function setAllocationAndTax(uint256[3] calldata _allocations) external {\n        require(block.timestamp <= params.privateStart, \"Time lapsed\");\n        require(admin.hasRole(OPERATOR, msg.sender), \"TokenSale: OnlyOperator\");\n        maxAllocation = _allocations[0];\n        globalTaxRate = _allocations[1];\n        whitelistTxRate = _allocations[2];\n    }\n\n    function setMarketingWallet(address _wallet) external {\n        _onlyAdmin();\n        marketingWallet = _wallet;\n    }\n\n    /**\n     * @dev setup the current tokensale stage (epoch)\n     */\n    function checkingEpoch() public {\n        uint256 time = block.timestamp;\n        if (\n            epoch != Epoch.Private &&\n            time >= params.privateStart &&\n            time <= params.privateEnd\n        ) {\n            epoch = Epoch.Private;\n            return;\n        }\n        if ((epoch != Epoch.Finished && (time > params.privateEnd))) {\n            epoch = Epoch.Finished;\n            return;\n        }\n    }\n\n    // to save size\n    function _onlyAdmin() internal view {\n        require(\n            admin.hasRole(DEFAULT_ADMIN_ROLE, msg.sender) ||\n                msg.sender == address(admin),\n            \"TokenSale: Onlyadmin\"\n        );\n    }\n\n    /**\n     * @dev invest usdc to the tokensale\n     */\n    function deposit(uint256 _amount) external {\n        console.log(\"kyc enabled\", isKYCEnabled);\n        if (isKYCEnabled) {\n            require(admin.isKYCDone(msg.sender) == true, \"KYC not done\");\n        }\n        address sender = msg.sender;\n        require(\n            !admin.blacklist(address(this), sender),\n            \"TokenSale: Blacklisted\"\n        );\n        checkingEpoch();\n\n        require(epoch == Epoch.Private, \"TokenSale: Incorrect time\");\n        require(_amount > 0, \"TokenSale: 0 deposit\");\n\n        if (userDepositIndex[sender] == 0) {\n            usersOnDeposit.push(sender);\n            userDepositIndex[sender] = usersOnDeposit.length;\n        }\n        if (epoch == Epoch.Private) {\n            _processPrivate(sender, _amount);\n        }\n    }\n\n    function destroy() external override {\n        _onlyAdmin();\n        uint256 amountUSDC = usdc.balanceOf(address(this));\n        if (amountUSDC > 0) {\n            usdc.safeTransfer(admin.wallet(), amountUSDC);\n        }\n        address payable wallet = payable(admin.wallet());\n        selfdestruct(wallet);\n    }\n\n    /**\n     * @notice withdraw accidently sent ERC20 tokens\n     * @param _tokenAddress address of token to withdraw\n     */\n    function removeOtherERC20Tokens(address _tokenAddress) external {\n        _onlyAdmin();\n        require(\n            _tokenAddress != address(usdc),\n            \"TokenSale: Can't withdraw usdc\"\n        );\n        uint256 balance = IERC20D(_tokenAddress).balanceOf(address(this));\n        IERC20D(_tokenAddress).safeTransfer(admin.wallet(), balance);\n\n        emit ERC20TokensRemoved(_tokenAddress, msg.sender, balance);\n    }\n\n    /**\n     * @dev processing usdc investment to the private round\n     * @param _sender - transaction sender\n     * @param _amount - investment amount in usdc\n     */\n    function _processPrivate(address _sender, uint256 _amount) internal {\n        require(_amount > 0, \"TokenSale: Too small\");\n\n        Staked storage s = stakes[_sender];\n        uint256 amount = _amount * PCT_BASE;\n        uint256 sum = s.amount + amount;\n\n        uint256 maxAllocationOfUser = (calculateMaxAllocation(_sender)) *\n            PCT_BASE;\n        require(sum <= maxAllocationOfUser, \"upto max allocation\");\n        uint256 taxFreeAllcOfUser = 0; // hardcode zero - all pools have ax\n\n        uint256 userTaxAmount;\n\n        if (sum > taxFreeAllcOfUser) {\n            uint256 userTxRate = userTaxRate(sum, _sender);\n            if (s.amount < taxFreeAllcOfUser) {\n                userTaxAmount =\n                    ((sum - taxFreeAllcOfUser) * userTxRate) /\n                    POINT_BASE;\n            } else {\n                userTaxAmount = (amount * userTxRate) / POINT_BASE;\n            }\n        }\n\n        if (userTaxAmount > 0) {\n            s.taxAmount += userTaxAmount;\n            usdc.safeTransferFrom(_sender, marketingWallet, userTaxAmount);\n        }\n        s.amount += uint128(amount);\n        state.totalPrivateSold += uint128(amount);\n        usdc.safeTransferFrom(_sender, address(this), amount);\n\n        /**@notice Forbid unstaking*/\n        // stakingContract.setPoolsEndTime(_sender, uint256(params.privateEnd)); // TODO: uncomment\n        emit DepositPrivate(_sender, _amount, address(this));\n    }\n\n    /**\n     * @dev sends the usdc raise to admin's wallet\n     */\n\n    function calculateMaxAllocation(address _sender) public returns (uint256) {\n        uint256 userMaxAllc = _maxTierAllc(_sender);\n\n        if (userMaxAllc > maxAllocation) {\n            return userMaxAllc;\n        } else {\n            return maxAllocation;\n        }\n    }\n\n    function _maxTaxfreeAllocation(address _sender) internal returns (uint256) {\n        uint256 userTierAllc = stakingContract.getAllocationOf(_sender);\n        uint256 giftedTierAllc = tokensaleTiers[_sender];\n\n        if (userTierAllc > giftedTierAllc) {\n            return userTierAllc;\n        } else {\n            return giftedTierAllc;\n        }\n    }\n\n    function _maxTierAllc(address _sender) internal returns (uint256) {\n        (uint256 userTier, uint256 userLockLvl, , ) = stakingContract\n            .getUserState(_sender);\n\n        uint256 giftedTierAllc = tokensaleTiers[_sender];\n\n        if (userTier == 0 && giftedTierAllc == 0) {\n            return 0;\n        }\n\n        uint256 userTierAllc = stakingContract.getAllocationOf(_sender);\n        uint256 nextTierAllc;\n        if (userLockLvl > 0 && userLockLvl < 4) {\n            nextTierAllc = stakingContract.getAllocations(\n                userLockLvl + 1,\n                userTier\n            );\n        } else {\n            nextTierAllc = stakingContract.getAllocations(\n                userLockLvl,\n                userTier + 1\n            );\n        }\n\n        if (nextTierAllc > userTierAllc) {\n            if (nextTierAllc > giftedTierAllc) {\n                return nextTierAllc;\n            } else {\n                return giftedTierAllc;\n            }\n        } else {\n            if (userTierAllc > giftedTierAllc) {\n                return userTierAllc;\n            } else {\n                return giftedTierAllc;\n            }\n        }\n    }\n\n    // _amount should be in dollar without decimals\n    function userTaxRate(\n        uint256 _amount,\n        address _sender\n    ) public returns (uint256) {\n        uint256 userTaxFreeAllc = 0;\n\n        if (_amount > userTaxFreeAllc) {\n            if (isWhitelisted[_sender]) {\n                return whitelistTxRate;\n            } else {\n                return globalTaxRate;\n            }\n        } else {\n            return 0;\n        }\n    }\n\n    function takeUSDCRaised() external override {\n        checkingEpoch();\n        require(epoch == Epoch.Finished, \"TokenSale: Not time yet\");\n        require(!isRaiseClaimed, \"TokenSale: Already paid\");\n\n        uint256 earned;\n\n        if (state.totalPrivateSold > state.totalSupplyInValue) {\n            earned = uint256(state.totalSupplyInValue);\n        } else {\n            earned = uint256(state.totalPrivateSold);\n        }\n\n        isRaiseClaimed = true;\n\n        if (earned > 0) {\n            uint256 bal = usdc.balanceOf(address(this));\n            uint256 returnValue = earned <= bal ? earned : bal;\n            usdc.safeTransfer(admin.wallet(), returnValue);\n        }\n\n        emit RaiseClaimed(admin.wallet(), earned);\n    }\n\n    /**\n     * @dev allows the participants of the private round to claim usdc left\n     */\n    function claim() external {\n        checkingEpoch();\n        require(\n            uint8(epoch) > 1 && !admin.blockClaim(address(this)),\n            \"TokenSale: Not time or not allowed\"\n        );\n\n        Staked storage s = stakes[msg.sender];\n        require(s.amount != 0, \"TokenSale: No Deposit\");\n        require(!s.claimed, \"TokenSale: Already Claimed\");\n\n        uint256 left;\n        (s.share, left) = _claim(s);\n        require(left > 0, \"TokenSale: Nothing to claim\");\n        uint256 refundTaxAmount;\n        if (s.taxAmount > 0) {\n            uint256 tax = userTaxRate(s.amount, msg.sender);\n            uint256 taxFreeAllc = _maxTaxfreeAllocation(msg.sender) * PCT_BASE;\n            if (taxFreeAllc >= s.share) {\n                refundTaxAmount = s.taxAmount;\n            } else {\n                refundTaxAmount = (left * tax) / POINT_BASE;\n            }\n            usdc.safeTransferFrom(marketingWallet, msg.sender, refundTaxAmount);\n        }\n        s.claimed = true;\n        usdc.safeTransfer(msg.sender, left);\n        emit Claim(msg.sender, left);\n    }\n\n    function _claim(Staked memory _s) internal view returns (uint120, uint256) {\n        uint256 left;\n        if (state.totalPrivateSold > (state.totalSupplyInValue)) {\n            uint256 rate = (state.totalSupplyInValue * PCT_BASE) /\n                state.totalPrivateSold;\n            _s.share = uint120((uint256(_s.amount) * rate) / PCT_BASE);\n            left = uint256(_s.amount) - uint256(_s.share);\n        } else {\n            _s.share = uint120(_s.amount);\n        }\n\n        return (_s.share, left);\n    }\n\n    function canClaim(address _user) external view returns (uint120, uint256) {\n        return _claim(stakes[_user]);\n    }\n\n    /**\n     * @dev sends Locked usdc to admin wallet\n     */\n\n    function takeLocked() external override {\n        _onlyAdmin();\n        require(\n            block.timestamp >= (params.privateEnd + 2592e3),\n            \"TokenSale: Not ended\"\n        );\n        uint256 amountUSDC = usdc.balanceOf(address(this));\n        if (amountUSDC > 0) {\n            usdc.safeTransfer(admin.wallet(), amountUSDC);\n        }\n    }\n\n    /**\n    @dev Total Tokens (in $) sold in IDO\n     */\n    function totalTokenSold() external view returns (uint128) {\n        return state.totalPrivateSold;\n    }\n}"
    },
    {
      "filename": "zap-contracts-labs/contracts/TokenSale.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"./interfaces/ITokenSale.sol\";\nimport \"./interfaces/IAdmin.sol\";\nimport \"./interfaces/IAirdrops.sol\";\nimport \"./interfaces/IERC20D.sol\";\nimport \"./interfaces/IStaking.sol\";\nimport \"hardhat/console.sol\";\n\n/*\nA tokensale includes 3 stages: \n1. Private round. Only ion token holders can participate in this round. \n The Matic/USDC price is fixed in the beginning of the tokensale.\n All tokens available in the pre-sale will be made available through the private sale round. \n A single investor can purchase up to their maximum allowed investment defined by the tier.\n Investors can claim their tokens only when the private round is finished. \n If the total supply is higher than the total demand for this tokensale, investors purchase tokens up to their max allocation. \n If the the demand is higher than supply, the number of tokens investors will receive is adjusted, and then the native token used to invest are partially refunded.\n\n*/\n\n//TODO Change USDC address\n//TODO Change Marketing wallet address\n\ncontract TokenSale is Initializable, ITokenSale {\n    using SafeERC20 for IERC20D;\n\n    uint256 constant PCT_BASE = 10 ** 18;\n    uint256 constant POINT_BASE = 1000;\n    bytes32 constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    address public marketingWallet;\n\n    uint256 public maxAllocation; // in dollar with decimals\n    uint256 public globalTaxRate; // base 1000\n    uint256 public whitelistTxRate; // base 1000\n    bool public isKYCEnabled;\n\n    IStaking stakingContract;\n    Params params;\n    IERC20D public usdc;\n    IAdmin admin;\n    /**\n     * @dev current tokensale stage (epoch)\n     */\n    Epoch public override epoch;\n    bool isRaiseClaimed;\n    bool only;\n    bytes32 public constant OPERATOR = keccak256(\"OPERATOR\");\n    address[] public usersOnDeposit;\n\n    mapping(address => Staked) public override stakes;\n    mapping(address => uint256) public tokensaleTiers;\n    /** @dev Decrease result by 1 to access correct position */\n    mapping(address => uint256) public userDepositIndex;\n    mapping(address => bool) public isWhitelisted;\n\n    State state;\n\n    receive() external payable {}\n\n    function getState() external view returns (uint128, uint128) {\n        return (state.totalPrivateSold, state.totalSupplyInValue);\n    }\n\n    function initialize(\n        Params calldata _params,\n        address _stakingContract,\n        address _admin,\n        uint256 _maxAllocation,\n        uint256 _globalTaxRate,\n        bool _isKYC,\n        uint256 _whitelistTxRate\n    ) external initializer {\n        params = _params;\n        stakingContract = IStaking(_stakingContract);\n        admin = IAdmin(_admin);\n        state.totalSupplyInValue = uint128(\n            (uint256(_params.totalSupply) *\n                uint256(_params.privateTokenPrice)) / 10 ** 18\n            // removes USDB hardcode of six, awful\n        );\n        usdc = IERC20D(0xA9F81589Cc48Ff000166Bf03B3804A0d8Cec8114); //TODO change for mainnet\n        marketingWallet = 0x6507fFd283c32386B6065EA89744Ade21515e91E; //TODO change for mainnet\n        maxAllocation = _maxAllocation;\n        globalTaxRate = _globalTaxRate;\n        isKYCEnabled = _isKYC;\n        whitelistTxRate = _whitelistTxRate;\n    }\n\n    // allocation is amount in dollar without decimals\n    function userWhitelistAllocation(\n        address[] calldata users,\n        uint256[] calldata allocations\n    ) public {\n        require(admin.hasRole(OPERATOR, msg.sender), \"TokenSale: OnlyOperator\");\n        require(\n            users.length == allocations.length,\n            \"TokenSale: Invalid length\"\n        );\n        for (uint256 i = 0; i < users.length; i++) {\n            tokensaleTiers[users[i]] = allocations[i];\n        }\n    }\n\n    function whitelistUser(address[] calldata users) public {\n        require(admin.hasRole(OPERATOR, msg.sender), \"TokenSale: OnlyOperator\");\n        for (uint256 i ="
    }
  ]
}