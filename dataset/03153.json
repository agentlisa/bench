{
  "Title": "Not all params are there at the comment",
  "Content": "##### Description\nAfter line\nhttps://github.com/lidofinance/lido-dao/blob/801d3e854efb33ff33a59fe51187e187047a6be2/contracts/0.4.24/Lido.sol#L97\na description of the two parameters `_treasury` and `_insuranceFund` must be added.\n##### Recommendation\nIt is recommended to fix the code.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/0.4.24/Lido.sol",
      "content": "// SPDX-FileCopyrightText: 2020 Lido <info@lido.fi>\n\n// SPDX-License-Identifier: GPL-3.0\n\n/* See contracts/COMPILERS.md */\npragma solidity 0.4.24;\n\nimport \"@aragon/os/contracts/apps/AragonApp.sol\";\nimport \"@aragon/os/contracts/lib/math/SafeMath.sol\";\nimport \"@aragon/os/contracts/lib/math/SafeMath64.sol\";\nimport \"@aragon/os/contracts/common/IsContract.sol\";\nimport \"solidity-bytes-utils/contracts/BytesLib.sol\";\n\nimport \"./interfaces/ILido.sol\";\nimport \"./interfaces/INodeOperatorsRegistry.sol\";\nimport \"./interfaces/IDepositContract.sol\";\nimport \"./interfaces/ILidoMevTxFeeVault.sol\";\n\nimport \"./StETH.sol\";\n\n\n/**\n* @title Liquid staking pool implementation\n*\n* Lido is an Ethereum 2.0 liquid staking protocol solving the problem of frozen staked Ethers\n* until transfers become available in Ethereum 2.0.\n* Whitepaper: https://lido.fi/static/Lido:Ethereum-Liquid-Staking.pdf\n*\n* NOTE: the code below assumes moderate amount of node operators, e.g. up to 50.\n*\n* Since balances of all token holders change when the amount of total pooled Ether\n* changes, this token cannot fully implement ERC20 standard: it only emits `Transfer`\n* events upon explicit transfer between holders. In contrast, when Lido oracle reports\n* rewards, no Transfer events are generated: doing so would require emitting an event\n* for each token holder and thus running an unbounded loop.\n*/\ncontract Lido is ILido, IsContract, StETH, AragonApp {\n    using SafeMath for uint256;\n    using SafeMath64 for uint64;\n    using UnstructuredStorage for bytes32;\n\n    /// ACL\n    bytes32 constant public PAUSE_ROLE = keccak256(\"PAUSE_ROLE\");\n    bytes32 constant public MANAGE_FEE = keccak256(\"MANAGE_FEE\");\n    bytes32 constant public MANAGE_WITHDRAWAL_KEY = keccak256(\"MANAGE_WITHDRAWAL_KEY\");\n    bytes32 constant public SET_ORACLE = keccak256(\"SET_ORACLE\");\n    bytes32 constant public BURN_ROLE = keccak256(\"BURN_ROLE\");\n    bytes32 constant public SET_TREASURY = keccak256(\"SET_TREASURY\");\n    bytes32 constant public SET_INSURANCE_FUND = keccak256(\"SET_INSURANCE_FUND\");\n    bytes32 constant public DEPOSIT_ROLE = keccak256(\"DEPOSIT_ROLE\");\n    bytes32 constant public SET_MEV_TX_FEE_VAULT_ROLE = keccak256(\"SET_MEV_TX_FEE_VAULT_ROLE\");\n\n    uint256 constant public PUBKEY_LENGTH = 48;\n    uint256 constant public WITHDRAWAL_CREDENTIALS_LENGTH = 32;\n    uint256 constant public SIGNATURE_LENGTH = 96;\n\n    uint256 constant public DEPOSIT_SIZE = 32 ether;\n\n    uint256 internal constant DEPOSIT_AMOUNT_UNIT = 1000000000 wei;\n    uint256 internal constant TOTAL_BASIS_POINTS = 10000;\n\n    /// @dev default value for maximum number of Ethereum 2.0 validators registered in a single depositBufferedEther call\n    uint256 internal constant DEFAULT_MAX_DEPOSITS_PER_CALL = 150;\n\n    bytes32 internal constant FEE_POSITION = keccak256(\"lido.Lido.fee\");\n    bytes32 internal constant TREASURY_FEE_POSITION = keccak256(\"lido.Lido.treasuryFee\");\n    bytes32 internal constant INSURANCE_FEE_POSITION = keccak256(\"lido.Lido.insuranceFee\");\n    bytes32 internal constant NODE_OPERATORS_FEE_POSITION = keccak256(\"lido.Lido.nodeOperatorsFee\");\n\n    bytes32 internal constant DEPOSIT_CONTRACT_POSITION = keccak256(\"lido.Lido.depositContract\");\n    bytes32 internal constant ORACLE_POSITION = keccak256(\"lido.Lido.oracle\");\n    bytes32 internal constant NODE_OPERATORS_REGISTRY_POSITION = keccak256(\"lido.Lido.nodeOperatorsRegistry\");\n    bytes32 internal constant TREASURY_POSITION = keccak256(\"lido.Lido.treasury\");\n    bytes32 internal constant INSURANCE_FUND_POSITION = keccak256(\"lido.Lido.insuranceFund\");\n    bytes32 internal constant MEV_TX_FEE_VAULT_POSITION = keccak256(\"lido.Lido.mevTxFeeVault\");\n\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION = keccak256(\"lido.Lido.bufferedEther\");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION = keccak256(\"lido.Lido.depositedValidators\");\n    /// @dev total amount of Beacon-side Ether (sum of all the balances of Lido validators)\n    bytes32 internal constant BEACON_BALANCE_POSITION = keccak256(\"lido.Lido.beaconBalance\");\n    /// @dev number of Lido's validators available in the Beacon state\n    bytes32 internal constant BEACON_VALIDATORS_POSITION = keccak256(\"lido.Lido.beaconValidators\");\n\n    /// @dev Just a counter of total amount of MEV and transaction rewards received by Lido contract\n    /// Not used in the logic\n    bytes32 internal constant TOTAL_MEV_TX_FEE_COLLECTED_POSITION = keccak256(\"lido.Lido.totalMevTxFeeCollected\");\n\n    /// @dev Credentials which allows the DAO to withdraw Ether on the 2.0 side\n    bytes32 internal constant WITHDRAWAL_CREDENTIALS_POSITION = keccak256(\"lido.Lido.withdrawalCredentials\");\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    * @param _depositContract official ETH2 Deposit contract\n    * @param _oracle oracle contract\n    * @param _operators instance of Node Operators Registry\n    */\n    function initialize(\n        IDepositContract _depositContract,\n        address _oracle,\n        INodeOperatorsRegistry _operators,\n        address _treasury,\n        address _insuranceFund\n    )\n        public onlyInit\n    {\n        require(isContract(address(_operators)), \"NOT_A_CONTRACT\");\n        require(isContract(address(_depositContract)), \"NOT_A_CONTRACT\");\n\n        NODE_OPERATORS_REGISTRY_POSITION.setStorageAddress(_operators);\n        DEPOSIT_CONTRACT_POSITION.setStorageAddress(address(_depositContract));\n\n        _setOracle(_oracle);\n        _setTreasury(_treasury);\n        _setInsuranceFund(_insuranceFund);\n\n        initialized();\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Eth2.0 Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * depositBufferedEther() and pushes them to the ETH2 Deposit contract.\n    */\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, \"NON_EMPTY_DATA\");\n        _submit(0);\n    }\n\n    /**\n    * @notice A payable function supposed to be funded only by LidoMevTxFeeVault contract\n    * @dev We need a separate function because funds received by default payable function\n    * will go through entire deposit algorithm\n    */\n    function mevTxFeeReceiver() external payable {\n        require(msg.sender == MEV_TX_FEE_VAULT_POSITION.getStorageAddress());\n        emit MevTxFeeReceived(msg.value);\n    }\n\n    /**\n    * @notice Send funds to the pool with optional _referral parameter\n    * @dev This function is alternative way to submit funds. Supports optional referral address.\n    * @return Amount of StETH shares generated\n    */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n    * @notice A payable function for Mev Tx Fee rewards. Can be funded only by LidoMevTxFeeVault contract\n    * @dev We need a separate payable function because funds received by default payable function\n    * are considered as funds submitted for minting stETH\n    */\n    function receiveMevTxFee() external payable {\n        require(msg.sender == MEV_TX_FEE_VAULT_POSITION.getStorageAddress());\n\n        TOTAL_MEV_TX_FEE_COLLECTED_POSITION.setStorageUint256(\n            TOTAL_MEV_TX_FEE_COLLECTED_POSITION.getStorageUint256().add(msg.value));\n\n        emit MevTxFeeReceived(msg.value);\n    }\n\n    /**\n    * @notice Deposits buffered ethers to the official DepositContract.\n    * @dev This function is separated from submit() to reduce the cost of sending funds.\n    */\n    function depositBufferedEther() external auth(DEPOSIT_ROLE) {\n        return _depositBufferedEther(DEFAULT_MAX_DEPOSITS_PER_CALL);\n    }\n\n    /**\n      * @notice Deposits buffered ethers to the official DepositContract, making no more than `_maxDeposits` deposit calls.\n      * @dev This function is separated from submit() to reduce the cost of sending funds.\n      */\n    function depositBufferedEther(uint256 _maxDeposits) external auth(DEPOSIT_ROLE) {\n        return _depositBufferedEther(_maxDeposits);\n    }\n\n    function burnShares(address _account, uint256 _sharesAmount)\n        external\n        authP(BURN_ROLE, arr(_account, _sharesAmount))\n        returns (uint256 newTotalShares)\n    {\n        return _burnShares(_account, _sharesAmount);\n    }\n\n    /**\n      * @notice Stop pool routine operations\n      */\n    function stop() external auth(PAUSE_ROLE) {\n        _stop();\n    }\n\n    /**\n      * @notice Resume pool routine operations\n      */\n    function resume() external auth(PAUSE_ROLE) {\n        _resume();\n    }\n\n    /**\n      * @notice Set fee rate to `_feeBasisPoints` basis points. The fees are accrued when oracles report staking results\n      * @param _feeBasisPoints Fee rate, in basis points\n      */\n    function setFee(uint16 _feeBasisPoints) external auth(MANAGE_FEE) {\n        _setBPValue(FEE_POSITION, _feeBasisPoints);\n        emit FeeSet(_feeBasisPoints);\n    }\n\n    /**\n      * @notice Set fee distribution: `_treasuryFeeBasisPoints` basis points go to the treasury, `_insuranceFeeBasisPoints` basis points go to the insurance fund, `_operatorsFeeBasisPoints` basis points go to node operators. The sum has to be 10 000.\n      */\n    function setFeeDistribution(\n        uint16 _treasuryFeeBasisPoints,\n        uint16 _insuranceFeeBasisPoints,\n        uint16 _operatorsFeeBasisPoints\n    )\n        external auth(MANAGE_FEE)\n    {\n        require(\n            TOTAL_BASIS_POINTS == uint256(_treasuryFeeBasisPoints)\n            .add(uint256(_insuranceFeeBasisPoints))\n            .add(uint256(_operatorsFeeBasisPoints)),\n            \"FEES_DONT_ADD_UP\"\n        );\n\n        _setBPValue(TREASURY_FEE_POSITION, _treasuryFeeBasisPoints);\n        _setBPValue(INSURANCE_FEE_POSITION, _insuranceFeeBasisPoints);\n        _setBPValue(NODE_OPERATORS_FEE_POSITION, _operatorsFeeBasisPoints);\n\n        emit FeeDistributionSet(_treasuryFeeBasisPoints, _insuranceFeeBasisPoints, _operatorsFeeBasisPoints);\n    }\n\n    /**\n      * @notice Set authorized oracle contract address to `_oracle`\n      * @dev Contract specified here is allowed to make periodical updates of beacon states\n      * by calling handleOracleReport.\n      * @param _oracle oracle contract\n      */\n    function setOracle(address _oracle) external auth(SET_ORACLE) {\n        _setOracle(_oracle);\n        emit OracleSet(_oracle);\n    }\n\n    /**\n      * @notice Set treasury contract address to `_treasury`\n      * @dev Contract specified here is used to accumulate the protocol treasury fee.\n      * @param _treasury contract which accumulates treasury fee.\n      */\n    function setTreasury(address _treasury) external auth(SET_TREASURY) {\n        _setTreasury(_treasury);\n        emit TreasurySet(_treasury);\n    }\n\n    /**\n      * @notice Set insuranceFund contract address to `_insuranceFund`\n      * @dev Contract specified here is used to accumulate the protocol insurance fee.\n      * @param _insuranceFund contract which accumulates insurance fee.\n      */\n    function setInsuranceFund(address _insuranceFund) external auth(SET_INSURANCE_FUND) {\n        _setInsuranceFund(_insuranceFund);\n        emit InsuranceFundSet(_insuranceFund);\n    }\n\n    /**\n      * @notice Set credentials to withdraw ETH on ETH 2.0 side after the phase 2 is launched to `_withdrawalCredentials`\n      * @dev Note that setWithdrawalCredentials discards all unused signing keys as the signatures are invalidated.\n      * @param _withdrawalCredentials hash of withdrawal multisignature key as accepted by\n      *        the deposit_contract.deposit function\n      */\n    function setWithdrawalCredentials(bytes32 _withdrawalCredentials) external auth(MANAGE_WITHDRAWAL_KEY) {\n        WITHDRAWAL_CREDENTIALS_POSITION.setStorageBytes32(_withdrawalCredentials);\n        getOperators().trimUnusedKeys();\n\n        emit WithdrawalCredentialsSet(_withdrawalCredentials);\n    }\n\n    /**\n    * @dev Sets given address as the address of LidoMevTxFeeVault contract\n    * @param _mevTxFeeVault MEV and Tx Fees Vault contract address\n    */\n    function setMevTxFeeVault(address _mevTxFeeVault) external auth(SET_MEV_TX_FEE_VAULT_ROLE) {\n        require(isContract(_mevTxFeeVault), \"NOT_A_CONTRACT\");\n        MEV_TX_FEE_VAULT_POSITION.setStorageAddress(_mevTxFeeVault);\n\n        emit LidoMevTxFeeVaultSet(_mevTxFeeVault);\n    }\n\n    /**\n      * @notice Issues withdrawal request. Not implemented.\n      * @param _amount Amount of StETH to withdraw\n      * @param _pubkeyHash Receiving address\n      */\n    function withdraw(uint256 _amount, bytes32 _pubkeyHash) external whenNotStopped { /* solhint-disable-line no-unused-vars */\n        //will be upgraded to an actual implementation when withdrawals are enabled (Phase 1.5 or 2 of Eth2 launch, likely late 2021 or 2022).\n        //at the moment withdrawals are not possible in the beacon chain and there's no workaround\n        revert(\"NOT_IMPLEMENTED_YET\");\n    }\n\n    /**\n    * @notice Updates beacon states, collects rewards from MevTxFeeVault and distributes all rewards if beacon balance increased\n    * @dev periodically called by the Oracle contract\n    * @param _beaconValidators number of Lido's keys in the beacon state\n    * @param _beaconBalance summarized balance of Lido-controlled keys in wei\n    */\n    function handleOracleReport(uint256 _beaconValidators, uint256 _beaconBalance) external whenNotStopped {\n        require(msg.sender == getOracle(), \"APP_AUTH_FAILED\");\n\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_beaconValidators <= depositedValidators, \"REPORTED_MORE_DEPOSITED\");\n\n        uint256 beaconValidators = BEACON_VALIDATORS_POSITION.getStorageUint256();\n        // Since the calculation of funds in the ingress queue is based on the number of validators\n        // that are in a transient state (deposited but not seen on beacon yet), we can't decrease the previously\n        // reported number (we'll be unable to figure out who is in the queue and count them).\n        // See LIP-1 for details https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-1.md\n        require(_beaconValidators >= beaconValidators, \"REPORTED_LESS_VALIDATORS\");\n        uint256 appearedValidators = _beaconValidators.sub(beaconValidators);\n\n        // RewardBase is the amount of money that is not included in the reward calculation\n        // Just appeared validators * 32 added to the previously reported beacon balance\n        uint256 rewardBase = (appearedValidators.mul(DEPOSIT_SIZE)).add(BEACON_BALANCE_POSITION.getStorageUint256());\n\n        // Save the current beacon balance and validators to\n        // calcuate rewards on the next push\n        BEACON_BALANCE_POSITION.setStorageUint256(_beaconBalance);\n        BEACON_VALIDATORS_POSITION.setStorageUint256(_beaconValidators);\n\n        // If LidoMevTxFeeVault address is not set just do as if there were no mevTxFee rewards at all\n        // Otherwise withdraw all rewards and put them to the buffer\n        // Thus, MEV tx fees are handled the same way as beacon rewards\n        uint256 mevRewards = 0;\n        address mevVaultAddress = getMevTxFeeVault();\n        if (mevVaultAddress != address(0)) {\n            mevRewards = ILidoMevTxFeeVault(mevVaultAddress).withdrawRewards();\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().add(mevRewards));\n        }\n\n        // Donâ€™t mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when beacon chain balance delta is zero or negative).\n        // See ADR #3 for details: https://research.lido.fi/t/rewards-distribution-after-the-merge-architecture-decision-record/1535\n        if (_beaconBalance > rewardBase) {\n            uint256 rewards = _beaconBalance.sub(rewardBase);\n            distributeRewards(rewards.add(mevRewards));\n        }\n    }\n\n    /**\n      * @notice Send funds to recovery Vault. Overrides default AragonApp behaviour.\n      * @param _token Token to be sent to recovery vault.\n      */\n    function transferToVault(address _token) external {\n        require(allowRecoverability(_token), \"RECOVER_DISALLOWED\");\n        address vault = getRecoveryVault();\n        require(isContract(vault), \"RECOVER_VAULT_NOT_CONTRACT\");\n\n        uint256 balance;\n        if (_token == ETH) {\n            balance = _getUnaccountedEther();\n            // Transfer replaced by call to prevent transfer gas amount issue\n            require(vault.call.value(balance)(), \"RECOVER_TRANSFER_FAILED\");\n        } else {\n            ERC20 token = ERC20(_token);\n            balance = token.staticBalanceOf(this);\n            // safeTransfer comes from overriden default implementation\n            require(token.safeTransfer(vault, balance), \"RECOVER_TOKEN_TRANSFER_FAILED\");\n        }\n\n        emit RecoverToVault(vault, _token, balance);\n    }\n\n    /**\n      * @notice Returns staking rewards fee rate\n      */\n    function getFee() external view returns (uint16 feeBasisPoints) {\n        return _getFee();\n    }\n\n    /**\n      * @notice Returns fee distribution proportion\n      */\n    function getFeeDistribution()\n        external\n        view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        return _getFeeDistribution();\n    }\n\n    /**\n      * @notice Returns current credentials to withdraw ETH on ETH 2.0 side after the phase 2 is launched\n      */\n    function getWithdrawalCredentials() public view returns (bytes32) {\n        return WITHDRAWAL_CREDENTIALS_POSITION.getStorageBytes32();\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return uint256 of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n    * @notice Get total amount of MEV and transaction fees collected to Lido contract\n    * @dev Ether got through LidoMevTxFeeVault is kept on this contract's balance the same way\n    * as other buffered Ether is kept (until it gets deposited)\n    * @return uint256 of funds received as MEV and Transaction fees in wei\n    */\n    function getTotalMevTxFeeCollected() external view returns (uint256) {\n        return TOTAL_MEV_TX_FEE_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n      * @notice Gets deposit contract handle\n      */\n    function getDepositContract() public view returns (IDepositContract) {\n        return IDepositContract(DEPOSIT_CONTRACT_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Gets authorized oracle address\n    * @return address of oracle contract\n    */\n    function getOracle() public view returns (address) {\n        return ORACLE_POSITION.getStorageAddress();\n    }\n\n    /**\n      * @notice Gets node operators registry interface handle\n      */\n    function getOperators() public view returns (INodeOperatorsRegistry) {\n        return INodeOperatorsRegistry(NODE_OPERATORS_REGISTRY_POSITION.getStorageAddress());\n    }\n\n    /**\n      * @notice Returns the treasury address\n      */\n    function getTreasury() public view returns (address) {\n        return TREASURY_POSITION.getStorageAddress();\n    }\n\n    /**\n      * @notice Returns the insurance fund address\n      */\n    function getInsuranceFund() public view returns (address) {\n        return INSURANCE_FUND_POSITION.getStorageAddress();\n    }\n\n    /**\n    * @notice Returns the key values related to Beacon-side\n    * @return depositedValidators - number of deposited validators\n    * @return beaconValidators - number of Lido's validators visible in the Beacon state, reported by oracles\n    * @return beaconBalance - total amount of Beacon-side Ether (sum of all the balances of Lido validators)\n    */\n    function getBeaconStat() public view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = BEACON_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = BEACON_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n    * @notice Returns address of the contract set as LidoMevTxFeeVault\n    */\n    function getMevTxFeeVault() public view returns (address) {\n        return MEV_TX_FEE_VAULT_POSITION.getStorageAddress();\n    }\n\n    /**\n    * @dev Internal function to set authorized oracle address\n    * @param _oracle oracle contract\n    */\n    function _setOracle(address _oracle) internal {\n        require(isContract(_oracle), \"NOT_A_CONTRACT\");\n        ORACLE_POSITION.setStorageAddress(_oracle);\n    }\n\n    /**\n    *  @dev Internal function to set treasury address\n    *  @param _treasury treasury address\n    */\n    function _setTreasury(address _treasury) internal {\n        require(_treasury != address(0), \"SET_TREASURY_ZERO_ADDRESS\");\n        TREASURY_POSITION.setStorageAddress(_treasury);\n    }\n\n    /**\n    *  @dev Internal function to set insurance fund address\n    *  @param _insuranceFund insurance fund address\n    */\n    function _setInsuranceFund(address _insuranceFund) internal {\n        require(_insuranceFund != address(0), \"SET_INSURANCE_FUND_ZERO_ADDRESS\");\n        INSURANCE_FUND_POSITION.setStorageAddress(_insuranceFund);\n    }\n\n    /**\n    * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n    * @param _referral address of referral.\n    * @return amount of StETH shares generated\n    */\n    function _submit(address _referral) internal whenNotStopped returns (uint256) {\n        address sender = msg.sender;\n        uint256 deposit = msg.value;\n        require(deposit != 0, \"ZERO_DEPOSIT\");\n\n        uint256 sharesAmount = getSharesByPooledEth(deposit);\n        if (sharesAmount == 0) {\n            // totalControlledEther is 0: either the first-ever deposit or complete slashing\n            // assume that shares correspond to Ether 1-to-1\n            sharesAmount = deposit;\n        }\n\n        _mintShares(sender, sharesAmount);\n        _submitted(sender, deposit, _referral);\n        _emitTransferAfterMintingShares(sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events where `from` is 0 address. Indicates mint events.\n     */\n    function _emitTransferAfterMintingShares(address _to, uint256 _sharesAmount) internal {\n        emit Transfer(address(0), _to, getPooledEthByShares(_sharesAmount));\n        emit TransferShares(address(0), _to, _sharesAmount);\n    }\n\n    /**\n    * @dev Deposits buffered eth to the DepositContract and assigns chunked deposits to node operators\n    */\n    function _depositBufferedEther(uint256 _maxDeposits) internal whenNotStopped {\n        uint256 buffered = _getBufferedEther();\n        if (buffered >= DEPOSIT_SIZE) {\n            uint256 unaccounted = _getUnaccountedEther();\n            uint256 numDeposits = buffered.div(DEPOSIT_SIZE);\n            _markAsUnbuffered(_ETH2Deposit(numDeposits < _maxDeposits ? numDeposits : _maxDeposits));\n            assert(_getUnaccountedEther() == unaccounted);\n        }\n    }\n\n    /**\n    * @dev Performs deposits to the ETH 2.0 side\n    * @param _numDeposits Number of deposits to perform\n    * @return actually deposited Ether amount\n    */\n    function _ETH2Deposit(uint256 _numDeposits) internal returns (uint256) {\n        (bytes memory pubkeys, bytes memory signatures) = getOperators().assignNextSigningKeys(_numDeposits);\n\n        if (pubkeys.length == 0) {\n            return 0;\n        }\n\n        require(pubkeys.length.mod(PUBKEY_LENGTH) == 0, \"REGISTRY_INCONSISTENT_PUBKEYS_LEN\");\n        require(signatures.length.mod(SIGNATURE_LENGTH) == 0, \"REGISTRY_INCONSISTENT_SIG_LEN\");\n\n        uint256 numKeys = pubkeys.length.div(PUBKEY_LENGTH);\n        require(numKeys == signatures.length.div(SIGNATURE_LENGTH), \"REGISTRY_INCONSISTENT_SIG_COUNT\");\n\n        for (uint256 i = 0; i < numKeys; ++i) {\n            bytes memory pubkey = BytesLib.slice(pubkeys, i * PUBKEY_LENGTH, PUBKEY_LENGTH);\n            bytes memory signature = BytesLib.slice(signatures, i * SIGNATURE_LENGTH, SIGNATURE_LENGTH);\n            _stake(pubkey, signature);\n        }\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(\n            DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(numKeys)\n        );\n\n        return numKeys.mul(DEPOSIT_SIZE);\n    }\n\n    /**\n    * @dev Invokes a deposit call to the official Deposit contract\n    * @param _pubkey Validator to stake for\n    * @param _signature Signature of the deposit call\n    */\n    function _stake(bytes memory _pubkey, bytes memory _signature) internal {\n        bytes32 withdrawalCredentials = getWithdrawalCredentials();\n        require(withdrawalCredentials != 0, \"EMPTY_WITHDRAWAL_CREDENTIALS\");\n\n        uint256 value = DEPOSIT_SIZE;\n\n        // The following computations and Merkle tree-ization will make official Deposit contract happy\n        uint256 depositAmount = value.div(DEPOSIT_AMOUNT_UNIT);\n        assert(depositAmount.mul(DEPOSIT_AMOUNT_UNIT) == value);    // properly rounded\n\n        // Compute deposit data root (`DepositData` hash tree root) according to deposit_contract.sol\n        bytes32 pubkeyRoot = sha256(_pad64(_pubkey));\n        bytes32 signatureRoot = sha256(\n            abi.encodePacked(\n                sha256(BytesLib.slice(_signature, 0, 64)),\n                sha256(_pad64(BytesLib.slice(_signature, 64, SIGNATURE_LENGTH.sub(64))))\n            )\n        );\n\n        bytes32 depositDataRoot = sha256(\n            abi.encodePacked(\n                sha256(abi.encodePacked(pubkeyRoot, withdrawalCredentials)),\n                sha256(abi.encodePacked(_toLittleEndian64(depositAmount), signatureRoot))\n            )\n        );\n\n        uint256 targetBalance = address(this).balance.sub(value);\n\n        getDepositContract().deposit.value(value)(\n            _pubkey, abi.encodePacked(withdrawalCredentials), _signature, depositDataRoot);\n        require(address(this).balance == targetBalance, \"EXPECTING_DEPOSIT_TO_HAPPEN\");\n    }\n\n    /**\n    * @dev Distributes rewards by minting and distributing corresponding amount of liquid tokens.\n    * @param _totalRewards Total rewards accured on the Ethereum 2.0 side in wei\n    */\n    function distributeRewards(uint256 _totalRewards) internal {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we've increased totalPooledEther by _totalRewards (which is already\n        // performed by the time this function is called), the combined cost of all holders'\n        // shares has became _totalRewards StETH tokens more, effectively splitting the reward\n        // between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // shares2mint * newShareCost = (_totalRewards * feeBasis) / TOTAL_BASIS_POINTS\n        // newShareCost = newTotalPooledEther / (prevTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * feeBasis * prevTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (newTotalPooledEther * TOTAL_BASIS_POINTS) - (feeBasis * _totalRewards)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n        uint256 feeBasis = _getFee();\n        uint256 shares2mint = (\n            _totalRewards.mul(feeBasis).mul(_getTotalShares())\n            .div(\n                _getTotalPooledEther().mul(TOTAL_BASIS_POINTS)\n                .sub(feeBasis.mul(_totalRewards))\n            )\n        );\n\n        // Mint the calculated amount of shares to this contract address. This will reduce the\n        // balances of the holders, as if the fee was taken in parts from each of them.\n        _mintShares(address(this), shares2mint);\n\n        (,uint16 insuranceFeeBasisPoints, uint16 operatorsFeeBasisPoints) = _getFeeDistribution();\n\n        uint256 toInsuranceFund = shares2mint.mul(insuranceFeeBasisPoints).div(TOTAL_BASIS_POINTS);\n        address insuranceFund = getInsuranceFund();\n        _transferShares(address(this), insuranceFund, toInsuranceFund);\n        _emitTransferAfterMintingShares(insuranceFund, toInsuranceFund);\n\n        uint256 distributedToOperatorsShares = _distributeNodeOperatorsReward(\n            shares2mint.mul(operatorsFeeBasisPoints).div(TOTAL_BASIS_POINTS)\n        );\n\n        // Transfer the rest of the fee to treasury\n        uint256 toTreasury = shares2mint.sub(toInsuranceFund).sub(distributedToOperatorsShares);\n\n        address treasury = getTreasury();\n        _transferShares(address(this), treasury, toTreasury);\n        _emitTransferAfterMintingShares(treasury, toTreasury);\n    }\n\n    /**\n    *  @dev Internal function to distribute reward to node operators\n    *  @param _sharesToDistribute amount of shares to distribute\n    *  @return actual amount of shares that was transferred to node operators as a reward\n    */\n    function _distributeNodeOperatorsReward(uint256 _sharesToDistribute) internal returns (uint256 distributed) {\n        (address[] memory recipients, uint256[] memory shares) = getOperators().getRewardsDistribution(_sharesToDistribute);\n\n        assert(recipients.length == shares.length);\n\n        distributed = 0;\n        for (uint256 idx = 0; idx < recipients.length; ++idx) {\n            _transferShares(\n                address(this),\n                recipients[idx],\n                shares[idx]\n            );\n            _emitTransferAfterMintingShares(recipients[idx], shares[idx]);\n            distributed = distributed.add(shares[idx]);\n        }\n    }\n\n    /**\n    * @dev Records a deposit made by a user with optional referral\n    * @param _sender sender's address\n    * @param _value Deposit value in wei\n    * @param _referral address of the referral\n    */\n    function _submitted(address _sender, uint256 _value, address _referral) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().add(_value));\n\n        emit Submitted(_sender, _value, _referral);\n    }\n\n    /**\n      * @dev Records a deposit to the deposit_contract.deposit function.\n      * @param _amount Total amount deposited to the ETH 2.0 side\n      */\n    function _markAsUnbuffered(uint256 _amount) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(\n            BUFFERED_ETHER_POSITION.getStorageUint256().sub(_amount));\n\n        emit Unbuffered(_amount);\n    }\n\n    /**\n      * @dev Write a value nominated in basis points\n      */\n    function _setBPValue(bytes32 _slot, uint16 _value) internal {\n        require(_value <= TOTAL_BASIS_POINTS, \"VALUE_OVER_100_PERCENT\");\n        _slot.setStorageUint256(uint256(_value));\n    }\n\n    /**\n      * @dev Returns staking rewards fee rate\n      */\n    function _getFee() internal view returns (uint16) {\n        return _readBPValue(FEE_POSITION);\n    }\n\n    /**\n      * @dev Returns fee distribution proportion\n      */\n    function _getFeeDistribution() internal view\n        returns (uint16 treasuryFeeBasisPoints, uint16 insuranceFeeBasisPoints, uint16 operatorsFeeBasisPoints)\n    {\n        treasuryFeeBasisPoints = _readBPValue(TREASURY_FEE_POSITION);\n        insuranceFeeBasisPoints = _readBPValue(INSURANCE_FEE_POSITION);\n        operatorsFeeBasisPoints = _readBPValue(NODE_OPERATORS_FEE_POSITION);\n    }\n\n    /**\n      * @dev Read a value nominated in basis points\n      */\n    function _readBPValue(bytes32 _slot) internal view returns (uint16) {\n        uin"
    }
  ]
}