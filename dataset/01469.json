{
  "Title": "Missing event emissions in `AlgebraCommunityVault`",
  "Content": "##### Description\nCertain setters within the `AlgebraCommunityVault` contract do not emit events upon execution. Specific instances include:\nhttps://github.com/cryptoalgebra/Algebra/blob/6c22b64977e0b0266aec89470480df74977eb606/src/core/contracts/AlgebraCommunityVault.sol#L111\nhttps://github.com/cryptoalgebra/Algebra/blob/6c22b64977e0b0266aec89470480df74977eb606/src/core/contracts/AlgebraCommunityVault.sol#L123\nhttps://github.com/cryptoalgebra/Algebra/blob/6c22b64977e0b0266aec89470480df74977eb606/src/core/contracts/AlgebraCommunityVault.sol#L129.\t \n\n##### Recommendation\nTo enhance transparency and traceability, we recommend implementing appropriate event emissions for the above-mentioned functions.\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/core/contracts/AlgebraCommunityVault.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\nimport './libraries/SafeTransfer.sol';\nimport './libraries/FullMath.sol';\n\nimport './interfaces/IAlgebraFactory.sol';\nimport './interfaces/IAlgebraCommunityVault.sol';\n\n/// @title Algebra community fee vault\n/// @notice Community fee from pools is sent here, if it is enabled\n/// @dev Role system is used to withdraw tokens\n/// @dev Version: Algebra Integral\ncontract AlgebraCommunityVault is IAlgebraCommunityVault {\n  /// @dev The role can be granted in AlgebraFactory\n  bytes32 public constant COMMUNITY_FEE_WITHDRAWER_ROLE = keccak256('COMMUNITY_FEE_WITHDRAWER');\n  address private immutable factory;\n\n  /// @notice Address to which community fees are sent from vault\n  address public communityFeeReceiver;\n  /// @notice The percentage of the protocol fee that Algebra will receive\n  /// @dev Value in thousandths,i.e. 1e-3\n  uint16 public algebraFee;\n  /// @notice Represents whether there is a new Algebra fee proposal or not\n  bool public hasNewAlgebraFeeProposal;\n  /// @notice Suggested Algebra fee value\n  uint16 public proposedNewAlgebraFee;\n  /// @notice Address of recipient Algebra part of community fee\n  address public algebraFeeReceiver;\n  /// @notice Address of Algebra fee manager\n  address public algebraFeeManager;\n  address private _pendingAlgebraFeeManager;\n\n  uint16 constant ALGEBRA_FEE_DENOMINATOR = 1000;\n\n  modifier onlyFactoryOwner() {\n    require(msg.sender == IAlgebraFactory(factory).owner());\n    _;\n  }\n\n  modifier onlyWithdrawer() {\n    require(msg.sender == algebraFeeManager || IAlgebraFactory(factory).hasRoleOrOwner(COMMUNITY_FEE_WITHDRAWER_ROLE, msg.sender));\n    _;\n  }\n\n  modifier onlyAlgebraFeeManager() {\n    require(msg.sender == algebraFeeManager);\n    _;\n  }\n\n  constructor(address _algebraFeeManager) {\n    (factory, algebraFeeManager) = (msg.sender, _algebraFeeManager);\n  }\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function withdraw(address token, uint256 amount) external override onlyWithdrawer {\n    (uint16 _algebraFee, address _algebraFeeReceiver, address _communityFeeReceiver) = _readAndVerifyWithdrawSettings();\n    _withdraw(token, _communityFeeReceiver, amount, _algebraFee, _algebraFeeReceiver);\n  }\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function withdrawTokens(WithdrawTokensParams[] calldata params) external override onlyWithdrawer {\n    uint256 paramsLength = params.length;\n    (uint16 _algebraFee, address _algebraFeeReceiver, address _communityFeeReceiver) = _readAndVerifyWithdrawSettings();\n\n    unchecked {\n      for (uint256 i; i < paramsLength; ++i) _withdraw(params[i].token, _communityFeeReceiver, params[i].amount, _algebraFee, _algebraFeeReceiver);\n    }\n  }\n\n  function _readAndVerifyWithdrawSettings() private view returns (uint16 _algebraFee, address _algebraFeeReceiver, address _communityFeeReceiver) {\n    if ((_algebraFee = algebraFee) != 0) require((_algebraFeeReceiver = algebraFeeReceiver) != address(0), 'invalid algebra fee receiver');\n    require((_communityFeeReceiver = communityFeeReceiver) != address(0), 'invalid receiver');\n  }\n\n  function _withdraw(address token, address to, uint256 amount, uint16 _algebraFee, address _algebraFeeReceiver) private {\n    uint256 withdrawAmount = amount;\n    if (_algebraFee != 0) {\n      uint256 algebraFeeAmount = FullMath.mulDivRoundingUp(withdrawAmount, _algebraFee, ALGEBRA_FEE_DENOMINATOR);\n      withdrawAmount -= algebraFeeAmount;\n      SafeTransfer.safeTransfer(token, _algebraFeeReceiver, algebraFeeAmount);\n      emit AlgebraTokensWithdrawal(token, _algebraFeeReceiver, algebraFeeAmount);\n    }\n\n    SafeTransfer.safeTransfer(token, to, withdrawAmount);\n    emit TokensWithdrawal(token, to, withdrawAmount);\n  }\n\n  // ### algebra factory owner permissioned actions ###\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function acceptAlgebraFeeChangeProposal(uint16 newAlgebraFee) external override onlyFactoryOwner {\n    require(hasNewAlgebraFeeProposal, 'not proposed');\n    require(newAlgebraFee == proposedNewAlgebraFee, 'invalid new fee');\n\n    algebraFee = newAlgebraFee;\n    (proposedNewAlgebraFee, hasNewAlgebraFeeProposal) = (0, false);\n    emit AlgebraFee(newAlgebraFee);\n  }\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function changeCommunityFeeReceiver(address newCommunityFeeReceiver) external override onlyFactoryOwner {\n    require(newCommunityFeeReceiver != address(0));\n    communityFeeReceiver = newCommunityFeeReceiver;\n    emit CommunityFeeReceiver(newCommunityFeeReceiver);\n  }\n\n  // ### algebra fee manager permissioned actions ###\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function transferAlgebraFeeManagerRole(address _newAlgebraFeeManager) external override onlyAlgebraFeeManager {\n    _pendingAlgebraFeeManager = _newAlgebraFeeManager;\n  }\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function acceptAlgebraFeeManagerRole() external override {\n    require(msg.sender == _pendingAlgebraFeeManager);\n    (_pendingAlgebraFeeManager, algebraFeeManager) = (address(0), msg.sender);\n    emit AlgebraFeeManager(msg.sender);\n  }\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function proposeAlgebraFeeChange(uint16 newAlgebraFee) external override onlyAlgebraFeeManager {\n    require(newAlgebraFee <= ALGEBRA_FEE_DENOMINATOR);\n    (proposedNewAlgebraFee, hasNewAlgebraFeeProposal) = (newAlgebraFee, true);\n  }\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function cancelAlgebraFeeChangeProposal() external override onlyAlgebraFeeManager {\n    (proposedNewAlgebraFee, hasNewAlgebraFeeProposal) = (0, false);\n  }\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function changeAlgebraFeeReceiver(address newAlgebraFeeReceiver) external override onlyAlgebraFeeManager {\n    require(newAlgebraFeeReceiver != address(0));\n    algebraFeeReceiver = newAlgebraFeeReceiver;\n    emit AlgebraFeeReceiver(newAlgebraFeeReceiver);\n  }\n}"
    },
    {
      "filename": "src/core/contracts/AlgebraCommunityVault.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\nimport './libraries/SafeTransfer.sol';\nimport './libraries/FullMath.sol';\n\nimport './interfaces/IAlgebraFactory.sol';\nimport './interfaces/IAlgebraCommunityVault.sol';\n\n/// @title Algebra community fee vault\n/// @notice Community fee from pools is sent here, if it is enabled\n/// @dev Role system is used to withdraw tokens\n/// @dev Version: Algebra Integral\ncontract AlgebraCommunityVault is IAlgebraCommunityVault {\n  /// @dev The role can be granted in AlgebraFactory\n  bytes32 public constant COMMUNITY_FEE_WITHDRAWER_ROLE = keccak256('COMMUNITY_FEE_WITHDRAWER');\n  address private immutable factory;\n\n  /// @notice Address to which community fees are sent from vault\n  address public communityFeeReceiver;\n  /// @notice The percentage of the protocol fee that Algebra will receive\n  /// @dev Value in thousandths,i.e. 1e-3\n  uint16 public algebraFee;\n  /// @notice Represents whether there is a new Algebra fee proposal or not\n  bool public hasNewAlgebraFeeProposal;\n  /// @notice Suggested Algebra fee value\n  uint16 public proposedNewAlgebraFee;\n  /// @notice Address of recipient Algebra part of community fee\n  address public algebraFeeReceiver;\n  /// @notice Address of Algebra fee manager\n  address public algebraFeeManager;\n  address private _pendingAlgebraFeeManager;\n\n  uint16 constant ALGEBRA_FEE_DENOMINATOR = 1000;\n\n  modifier onlyFactoryOwner() {\n    require(msg.sender == IAlgebraFactory(factory).owner());\n    _;\n  }\n\n  modifier onlyWithdrawer() {\n    require(msg.sender == algebraFeeManager || IAlgebraFactory(factory).hasRoleOrOwner(COMMUNITY_FEE_WITHDRAWER_ROLE, msg.sender));\n    _;\n  }\n\n  modifier onlyAlgebraFeeManager() {\n    require(msg.sender == algebraFeeManager);\n    _;\n  }\n\n  constructor(address _algebraFeeManager) {\n    (factory, algebraFeeManager) = (msg.sender, _algebraFeeManager);\n  }\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function withdraw(address token, uint256 amount) external override onlyWithdrawer {\n    (uint16 _algebraFee, address _algebraFeeReceiver, address _communityFeeReceiver) = _readAndVerifyWithdrawSettings();\n    _withdraw(token, _communityFeeReceiver, amount, _algebraFee, _algebraFeeReceiver);\n  }\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function withdrawTokens(WithdrawTokensParams[] calldata params) external override onlyWithdrawer {\n    uint256 paramsLength = params.length;\n    (uint16 _algebraFee, address _algebraFeeReceiver, address _communityFeeReceiver) = _readAndVerifyWithdrawSettings();\n\n    unchecked {\n      for (uint256 i; i < paramsLength; ++i) _withdraw(params[i].token, _communityFeeReceiver, params[i].amount, _algebraFee, _algebraFeeReceiver);\n    }\n  }\n\n  function _readAndVerifyWithdrawSettings() private view returns (uint16 _algebraFee, address _algebraFeeReceiver, address _communityFeeReceiver) {\n    if ((_algebraFee = algebraFee) != 0) require((_algebraFeeReceiver = algebraFeeReceiver) != address(0), 'invalid algebra fee receiver');\n    require((_communityFeeReceiver = communityFeeReceiver) != address(0), 'invalid receiver');\n  }\n\n  function _withdraw(address token, address to, uint256 amount, uint16 _algebraFee, address _algebraFeeReceiver) private {\n    uint256 withdrawAmount = amount;\n    if (_algebraFee != 0) {\n      uint256 algebraFeeAmount = FullMath.mulDivRoundingUp(withdrawAmount, _algebraFee, ALGEBRA_FEE_DENOMINATOR);\n      withdrawAmount -= algebraFeeAmount;\n      SafeTransfer.safeTransfer(token, _algebraFeeReceiver, algebraFeeAmount);\n      emit AlgebraTokensWithdrawal(token, _algebraFeeReceiver, algebraFeeAmount);\n    }\n\n    SafeTransfer.safeTransfer(token, to, withdrawAmount);\n    emit TokensWithdrawal(token, to, withdrawAmount);\n  }\n\n  // ### algebra factory owner permissioned actions ###\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function acceptAlgebraFeeChangeProposal(uint16 newAlgebraFee) external override onlyFactoryOwner {\n    require(hasNewAlgebraFeeProposal, 'not proposed');\n    require(newAlgebraFee == proposedNewAlgebraFee, 'invalid new fee');\n\n    algebraFee = newAlgebraFee;\n    (proposedNewAlgebraFee, hasNewAlgebraFeeProposal) = (0, false);\n    emit AlgebraFee(newAlgebraFee);\n  }\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function changeCommunityFeeReceiver(address newCommunityFeeReceiver) external override onlyFactoryOwner {\n    require(newCommunityFeeReceiver != address(0));\n    communityFeeReceiver = newCommunityFeeReceiver;\n    emit CommunityFeeReceiver(newCommunityFeeReceiver);\n  }\n\n  // ### algebra fee manager permissioned actions ###\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function transferAlgebraFeeManagerRole(address _newAlgebraFeeManager) external override onlyAlgebraFeeManager {\n    _pendingAlgebraFeeManager = _newAlgebraFeeManager;\n  }\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function acceptAlgebraFeeManagerRole() external override {\n    require(msg.sender == _pendingAlgebraFeeManager);\n    (_pendingAlgebraFeeManager, algebraFeeManager) = (address(0), msg.sender);\n    emit AlgebraFeeManager(msg.sender);\n  }\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function proposeAlgebraFeeChange(uint16 newAlgebraFee) external override onlyAlgebraFeeManager {\n    require(newAlgebraFee <= ALGEBRA_FEE_DENOMINATOR);\n    (proposedNewAlgebraFee, hasNewAlgebraFeeProposal) = (newAlgebraFee, true);\n  }\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function cancelAlgebraFeeChangeProposal() external override onlyAlgebraFeeManager {\n    (proposedNewAlgebraFee, hasNewAlgebraFeeProposal) = (0, false);\n  }\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function changeAlgebraFeeReceiver(address newAlgebraFeeReceiver) external override onlyAlgebraFeeManager {\n    require(newAlgebraFeeReceiver != address(0));\n    algebraFeeReceiver = newAlgebraFeeReceiver;\n    emit AlgebraFeeReceiver(newAlgebraFeeReceiver);\n  }\n}"
    },
    {
      "filename": "src/core/contracts/AlgebraCommunityVault.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.20;\n\nimport './libraries/SafeTransfer.sol';\nimport './libraries/FullMath.sol';\n\nimport './interfaces/IAlgebraFactory.sol';\nimport './interfaces/IAlgebraCommunityVault.sol';\n\n/// @title Algebra community fee vault\n/// @notice Community fee from pools is sent here, if it is enabled\n/// @dev Role system is used to withdraw tokens\n/// @dev Version: Algebra Integral\ncontract AlgebraCommunityVault is IAlgebraCommunityVault {\n  /// @dev The role can be granted in AlgebraFactory\n  bytes32 public constant COMMUNITY_FEE_WITHDRAWER_ROLE = keccak256('COMMUNITY_FEE_WITHDRAWER');\n  address private immutable factory;\n\n  /// @notice Address to which community fees are sent from vault\n  address public communityFeeReceiver;\n  /// @notice The percentage of the protocol fee that Algebra will receive\n  /// @dev Value in thousandths,i.e. 1e-3\n  uint16 public algebraFee;\n  /// @notice Represents whether there is a new Algebra fee proposal or not\n  bool public hasNewAlgebraFeeProposal;\n  /// @notice Suggested Algebra fee value\n  uint16 public proposedNewAlgebraFee;\n  /// @notice Address of recipient Algebra part of community fee\n  address public algebraFeeReceiver;\n  /// @notice Address of Algebra fee manager\n  address public algebraFeeManager;\n  address private _pendingAlgebraFeeManager;\n\n  uint16 constant ALGEBRA_FEE_DENOMINATOR = 1000;\n\n  modifier onlyFactoryOwner() {\n    require(msg.sender == IAlgebraFactory(factory).owner());\n    _;\n  }\n\n  modifier onlyWithdrawer() {\n    require(msg.sender == algebraFeeManager || IAlgebraFactory(factory).hasRoleOrOwner(COMMUNITY_FEE_WITHDRAWER_ROLE, msg.sender));\n    _;\n  }\n\n  modifier onlyAlgebraFeeManager() {\n    require(msg.sender == algebraFeeManager);\n    _;\n  }\n\n  constructor(address _algebraFeeManager) {\n    (factory, algebraFeeManager) = (msg.sender, _algebraFeeManager);\n  }\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function withdraw(address token, uint256 amount) external override onlyWithdrawer {\n    (uint16 _algebraFee, address _algebraFeeReceiver, address _communityFeeReceiver) = _readAndVerifyWithdrawSettings();\n    _withdraw(token, _communityFeeReceiver, amount, _algebraFee, _algebraFeeReceiver);\n  }\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function withdrawTokens(WithdrawTokensParams[] calldata params) external override onlyWithdrawer {\n    uint256 paramsLength = params.length;\n    (uint16 _algebraFee, address _algebraFeeReceiver, address _communityFeeReceiver) = _readAndVerifyWithdrawSettings();\n\n    unchecked {\n      for (uint256 i; i < paramsLength; ++i) _withdraw(params[i].token, _communityFeeReceiver, params[i].amount, _algebraFee, _algebraFeeReceiver);\n    }\n  }\n\n  function _readAndVerifyWithdrawSettings() private view returns (uint16 _algebraFee, address _algebraFeeReceiver, address _communityFeeReceiver) {\n    if ((_algebraFee = algebraFee) != 0) require((_algebraFeeReceiver = algebraFeeReceiver) != address(0), 'invalid algebra fee receiver');\n    require((_communityFeeReceiver = communityFeeReceiver) != address(0), 'invalid receiver');\n  }\n\n  function _withdraw(address token, address to, uint256 amount, uint16 _algebraFee, address _algebraFeeReceiver) private {\n    uint256 withdrawAmount = amount;\n    if (_algebraFee != 0) {\n      uint256 algebraFeeAmount = FullMath.mulDivRoundingUp(withdrawAmount, _algebraFee, ALGEBRA_FEE_DENOMINATOR);\n      withdrawAmount -= algebraFeeAmount;\n      SafeTransfer.safeTransfer(token, _algebraFeeReceiver, algebraFeeAmount);\n      emit AlgebraTokensWithdrawal(token, _algebraFeeReceiver, algebraFeeAmount);\n    }\n\n    SafeTransfer.safeTransfer(token, to, withdrawAmount);\n    emit TokensWithdrawal(token, to, withdrawAmount);\n  }\n\n  // ### algebra factory owner permissioned actions ###\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function acceptAlgebraFeeChangeProposal(uint16 newAlgebraFee) external override onlyFactoryOwner {\n    require(hasNewAlgebraFeeProposal, 'not proposed');\n    require(newAlgebraFee == proposedNewAlgebraFee, 'invalid new fee');\n\n    algebraFee = newAlgebraFee;\n    (proposedNewAlgebraFee, hasNewAlgebraFeeProposal) = (0, false);\n    emit AlgebraFee(newAlgebraFee);\n  }\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function changeCommunityFeeReceiver(address newCommunityFeeReceiver) external override onlyFactoryOwner {\n    require(newCommunityFeeReceiver != address(0));\n    communityFeeReceiver = newCommunityFeeReceiver;\n    emit CommunityFeeReceiver(newCommunityFeeReceiver);\n  }\n\n  // ### algebra fee manager permissioned actions ###\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function transferAlgebraFeeManagerRole(address _newAlgebraFeeManager) external override onlyAlgebraFeeManager {\n    _pendingAlgebraFeeManager = _newAlgebraFeeManager;\n  }\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function acceptAlgebraFeeManagerRole() external override {\n    require(msg.sender == _pendingAlgebraFeeManager);\n    (_pendingAlgebraFeeManager, algebraFeeManager) = (address(0), msg.sender);\n    emit AlgebraFeeManager(msg.sender);\n  }\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function proposeAlgebraFeeChange(uint16 newAlgebraFee) external override onlyAlgebraFeeManager {\n    require(newAlgebraFee <= ALGEBRA_FEE_DENOMINATOR);\n    (proposedNewAlgebraFee, hasNewAlgebraFeeProposal) = (newAlgebraFee, true);\n  }\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function cancelAlgebraFeeChangeProposal() external override onlyAlgebraFeeManager {\n    (proposedNewAlgebraFee, hasNewAlgebraFeeProposal) = (0, false);\n  }\n\n  /// @inheritdoc IAlgebraCommunityVault\n  function changeAlgebraFeeReceiver(address newAlgebraFeeReceiver) external override onlyAlgebraFeeManager {\n    require(newAlgebraFeeReceiver != address(0));\n    algebraFeeReceiver = newAlgebraFeeReceiver;\n    emit AlgebraFeeReceiver(newAlgebraFeeReceiver);\n  }\n}"
    }
  ]
}