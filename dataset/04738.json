{
  "Title": "[L-07] Fixed execution gas amount might not work for all potential target chains",
  "Content": "\nIn [`_sendASD`(...)](https://github.com/code-423n4/2024-03-canto/blob/1516028017a34ccfb4b0b19f5c5f17f5fa4cad42/contracts/asd/asdRouter.sol#L151-L152), when `asD` is transferred to another chain via LayerZero, a fixed gas amount (in native tokens of the source chain, see also [documentation](https://docs.layerzero.network/v2/developers/evm/gas-settings/options#lzreceive-option)) of `200000` is provided for the execution of `lzReceive(...)` (on the destination chain).\n\n```solidity\n// create send params for the Layer Zero oapp\nbytes memory sendOptions = OptionsBuilder.addExecutorLzReceiveOption(OptionsBuilder.newOptions(), 200000, 0);\n```\n\nAt the time of writing, `200000 canto * 0.258 $CANTO = 5.16e-11 $` which might be insufficient to cover the gas fees for the execution of `lzReceive(...)` on most destination chains.\n\n### Recommendation\n\nCompute this value according to the destination chain or let the user specify it similar to `_payload._feeForSend`. Also, the [quoting mechanism](https://docs.layerzero.network/v2/developers/evm/gas-settings/tx-pricing#quote-mechanism) can help with that.\n\n**[dsudit01 (Canto) commented](https://github.com/code-423n4/2024-03-canto-findings/issues/9#issuecomment-2040298332):**\n > The message from `lzCompose` is a hardcoded length from the OFT contract itself. We can still check the length to be sure though.\n >\n > PR [here](https://github.com/Plex-Engineer/ASD-V2/pull/5).\n\n*Note: For full discussion, see [here](https://github.com/code-423n4/2024-03-canto-findings/issues/9).*\n\n***\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-03-canto",
  "Code": [
    {
      "filename": "contracts/asd/asdRouter.sol",
      "content": "pragma solidity ^0.8.22;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IOAppComposer} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/interfaces/IOAppComposer.sol\";\nimport {OFTComposeMsgCodec} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/libs/OFTComposeMsgCodec.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ASDOFT} from \"./asdOFT.sol\";\nimport {IOFT, SendParam, MessagingFee} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/interfaces/IOFT.sol\";\nimport {OptionsBuilder} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/libs/OptionsBuilder.sol\";\nimport {ICrocSwapDex, ICrocImpact} from \"../ambient/CrocInterfaces.sol\";\nimport {ASDUSDC} from \"./asdUSDC.sol\";\n\n/**\n * @title ASDRouter\n */\n\ncontract ASDRouter is IOAppComposer, Ownable {\n    // ambient params\n    address public crocSwapAddress;\n    address public crocImpactAddress;\n    uint public constant ambientPoolIdx = 36000;\n    // canto chain params\n    address public noteAddress;\n    uint32 public cantoLzEID;\n    // asdUSDC contract for swapping to $NOTE\n    address public asdUSDC;\n\n    struct OftComposeMessage {\n        uint32 _dstLzEid;\n        address _dstReceiver;\n        address _dstAsdAddress;\n        address _cantoAsdAddress;\n        uint256 _minAmountASD;\n        address _cantoRefundAddress;\n        uint256 _feeForSend;\n    }\n\n    event LZReceived(bytes32 indexed _guid, address _from, bytes _message, address _executor, bytes _extraData, uint _value);\n\n    event TokenRefund(bytes32 indexed _guid, address _tokenAddress, address _refundAddress, uint _amount, uint _nativeAmount, string _reason);\n\n    event ASDSent(bytes32 indexed _guid, address _to, address _asdAddress, uint _amount, uint32 _dstEid, bool _lzSend);\n\n    constructor(address _noteAddress, uint32 _cantoLzEID, address _crocSwapAddress, address _crocImpactAddress, address _asdUSDCAddress) {\n        noteAddress = _noteAddress;\n        cantoLzEID = _cantoLzEID;\n        crocSwapAddress = _crocSwapAddress;\n        crocImpactAddress = _crocImpactAddress;\n        asdUSDC = _asdUSDCAddress;\n    }\n\n    /**\n     * @notice Called by the LZ executor after sending OFT tokens to this contract.\n     * @param _from The address of the OFT on this chain.\n     * @param _guid The GUID of the message.\n     * @param _message The message payload from the executor formatted as an OFT composed message.\n     * @param _executor The address of the executor.\n     * @param _extraData Additional data supplied by the executor.\n     * @dev Cannot revert anywhere, must send the tokens to the intended receiver if something fails (token's will be lost otherwise)\n     */\n    function lzCompose(address _from, bytes32 _guid, bytes calldata _message, address _executor, bytes calldata _extraData) external payable {\n        /* log event */\n        emit LZReceived(_guid, _from, _message, _executor, _extraData, msg.value);\n\n        /* decode OFT composed message */\n        (, , uint256 amountLD, bytes32 composeFrom, bytes memory composeMsg) = _decodeOFTComposeMsg(_message);\n\n        /* decode composed message payload */\n\n        // check the composed message for proper formatting\n        if (composeMsg.length != 224) {\n            // return tokens to the address that sent them (composeFrom)\n            _refundToken(_guid, _from, OFTComposeMsgCodec.bytes32ToAddress(composeFrom), amountLD, msg.value, \"Invalid composeMsg length\");\n            return;\n        }\n        OftComposeMessage memory payload = abi.decode(composeMsg, (OftComposeMessage));\n\n        /* check if the OFT stable coin is whitelisted */\n        if (!ASDUSDC(asdUSDC).whitelistedUSDCVersions(_from)) {\n            // return tokens to the refund address on canto\n            _refundToken(_guid, _from, payload._cantoRefundAddress, amountLD, msg.value, \"not whitelisted\");\n            return;\n        }\n\n        /* deposit oft to receive asdUSDC for swapping */\n        IERC20(_from).approve(asdUSDC, amountLD);\n        uint amountUSDC = ASDUSDC(asdUSDC).deposit(_from, amountLD);\n\n        /* swap tokens for $NOTE (check minAmount for slippage) */\n        (uint amountNote, bool successfulSwap) = _swapOFTForNote(asdUSDC, amountUSDC, payload._minAmountASD);\n\n        // check if the swap was successful\n        if (!successfulSwap) {\n            // return tokens to the refund address on canto\n            _refundToken(_guid, asdUSDC, payload._cantoRefundAddress, amountUSDC, msg.value, \"swap failed\");\n            return;\n        }\n\n        /* deposit $NOTE to the correct asd vault to receive ASD tokens */\n        (bool successfulDeposit, string memory reason) = _depositNoteToASDVault(payload._cantoAsdAddress, amountNote);\n\n        // check if deposit was successful\n        if (!successfulDeposit) {\n            // return $NOTE to the refund address on canto since OFT was swapped already\n            _refundToken(_guid, noteAddress, payload._cantoRefundAddress, amountNote, msg.value, reason);\n            return;\n        }\n\n        /* transfer the ASD tokens to the destination receiver */\n        _sendASD(_guid, payload, amountNote);\n    }\n\n    /**\n     *\n     * @param _message The message payload from the executor formatted as an OFT composed message.\n     * @return _nonce The nonce value.\n     * @return _srcEid The source endpoint ID.\n     * @return _amountLD The amount in local decimals.\n     * @return _composeFrom The composeFrom value (msg.sender on from chain).\n     * @return _composeMsg The composed message.\n     */\n    function _decodeOFTComposeMsg(bytes calldata _message) internal pure returns (uint64 _nonce, uint32 _srcEid, uint256 _amountLD, bytes32 _composeFrom, bytes memory _composeMsg) {\n        _nonce = OFTComposeMsgCodec.nonce(_message);\n        _srcEid = OFTComposeMsgCodec.srcEid(_message);\n        _amountLD = OFTComposeMsgCodec.amountLD(_message);\n        _composeFrom = OFTComposeMsgCodec.composeFrom(_message);\n        _composeMsg = OFTComposeMsgCodec.composeMsg(_message);\n    }\n\n    /**\n     * @param _guid the GUID of the message from layer zero.\n     * @param _payload the payload of the message.\n     * @param _amount  the amount of ASD tokens to send.\n     */\n    function _sendASD(bytes32 _guid, OftComposeMessage memory _payload, uint _amount) internal {\n        /* transfer the ASD tokens to the destination receiver */\n        if (_payload._dstLzEid == cantoLzEID) {\n            // just transfer the ASD tokens to the destination receiver\n            emit ASDSent(_guid, _payload._dstReceiver, _payload._cantoAsdAddress, _amount, _payload._dstLzEid, false);\n            ASDOFT(_payload._cantoAsdAddress).transfer(_payload._dstReceiver, _amount);\n        } else {\n            // use Layer Zero oapp to send ASD tokens to the destination receiver on the destination chain\n\n            // make sure msg.value is enough to cover the fee or this transaction will revert\n            if (msg.value < _payload._feeForSend) {\n                // refund ASD tokens on canto\n                _refundToken(_guid, _payload._cantoAsdAddress, _payload._cantoRefundAddress, _amount, msg.value, \"insufficient msg.value for send fee\");\n                return;\n            }\n\n            // create send params for the Layer Zero oapp\n            bytes memory sendOptions = OptionsBuilder.addExecutorLzReceiveOption(OptionsBuilder.newOptions(), 200000, 0);\n            SendParam memory sendParams = SendParam({dstEid: _payload._dstLzEid, to: OFTComposeMsgCodec.addressToBytes32(_payload._dstReceiver), amountLD: _amount, minAmountLD: _amount, extraOptions: sendOptions, composeMsg: \"0x\", oftCmd: \"0x\"});\n            MessagingFee memory fee = MessagingFee({nativeFee: _payload._feeForSend, lzTokenFee: 0});\n\n            // send tokens\n            (bool successfulSend, bytes memory data) = payable(_payload._cantoAsdAddress).call{value: _payload._feeForSend}(abi.encodeWithSelector(IOFT.send.selector, sendParams, fee, _payload._cantoRefundAddress));\n\n            // check if the send was successful\n            if (!successfulSend) {\n                // refund ASD tokens on canto\n                _refundToken(_guid, _payload._cantoAsdAddress, _payload._cantoRefundAddress, _amount, msg.value, string(data));\n                return;\n            }\n            emit ASDSent(_guid, _payload._dstReceiver, _payload._cantoAsdAddress, _amount, _payload._dstLzEid, true);\n        }\n    }\n\n    /**\n     * @notice refunds tokens when lzCompose fails\n     * @param _guid The GUID of the message from layer zero.\n     * @param _tokenAddress address of token\n     * @param _refundAddress address to refund to on canto\n     * @param _amount amount to send\n     * @param _nativeAmount amount to send in native token\n     */\n    function _refundToken(bytes32 _guid, address _tokenAddress, address _refundAddress, uint _amount, uint _nativeAmount, string memory _reason) internal {\n        // emit event\n        emit TokenRefund(_guid, _tokenAddress, _refundAddress, _amount, _nativeAmount, _reason);\n        // transfer tokens to refund address\n        IERC20(_tokenAddress).transfer(_refundAddress, _amount);\n        // transfer native tokens to refund address and check that this value is less than or equal to msg.value\n        if (_nativeAmount > 0 && _nativeAmount <= msg.value) {\n            payable(_refundAddress).transfer(_nativeAmount);\n        }\n    }\n\n    /**\n     * @notice deposits $NOTE to the correct asd vault to receive ASD tokens\n     * @param _asdVault The address of the ASD vault to deposit to\n     * @param _amountNote The amount of $NOTE to deposit\n     */\n    function _depositNoteToASDVault(address _asdVault, uint _amountNote) internal returns (bool, string memory) {\n        // approve asd vault to spend $NOTE\n        IERC20(noteAddress).approve(_asdVault, _amountNote);\n        // deposit $NOTE to asd vault (use call, so this doesn't revert)\n        (bool success, bytes memory errReason) = _asdVault.call(abi.encodeWithSelector(ASDOFT.mint.selector, _amountNote));\n        return (success, string(errReason));\n    }\n\n    /**\n     * @notice swaps an OFT stable coin for $NOTE\n     * @dev only callable by the owner\n     * @param _oftAddress The address of the OFT stable coin contract\n     * @param _amount The amount of OFT stable coin to swap\n     * @param _minAmountNote The minimum amount of $NOTE to receive\n     * @return amount The amount of $NOTE received or error code\n     */\n    function _swapOFTForNote(address _oftAddress, uint _amount, uint _minAmountNote) internal returns (uint, bool) {\n        // sort tokens\n        address baseToken;\n        address quoteToken;\n        if (_oftAddress < noteAddress) {\n            baseToken = _oftAddress;\n            quoteToken = noteAddress;\n        } else {\n            baseToken = noteAddress;\n            quoteToken = _oftAddress;\n        }\n        // check if pool exists\n        if (ambientPoolFor(baseToken, quoteToken, ambientPoolIdx) == 0) {\n            // nothing swapped, swapped failed\n            return (0, false);\n        }\n\n        // convert amount to uint128\n        uint128 amountConverted = uint128(_amount);\n        // query impact to make sure user will receive at least _minAmountNote\n        bool isNoteBase = baseToken == noteAddress;\n        (int128 baseFlow, int128 quoteFlow, ) = ICrocImpact(crocImpactAddress).calcImpact(baseToken, quoteToken, ambientPoolIdx, !isNoteBase, !isNoteBase, amountConverted, 0, 0);\n\n        // check if amount note received is greater than or equal to _minAmountNote\n\n        int minAmountInt = int(_minAmountNote); // stack too deep fix\n        // flow is negative if it left the pool, so multiply by -1\n        if (isNoteBase && -baseFlow < minAmountInt) {\n            // nothing swapped, swapped failed\n            return (0, false);\n        } else if (!isNoteBase && -quoteFlow < minAmountInt) {\n            // nothing swapped, swapped failed\n            return (0, false);\n        }\n        // convert minAmount to uint for stack too deep fix\n        uint128 uintMinAmount = uint128(_minAmountNote);\n\n        // swap is good to make, use call just in case revert occurs\n        (bool successSwap, bytes memory data) = crocSwapAddress.call(abi.encodeWithSelector(ICrocSwapDex.swap.selector, baseToken, quoteToken, ambientPoolIdx, !isNoteBase, !isNoteBase, amountConverted, 0, 0, uintMinAmount, 0));\n        if (!successSwap) {\n            // nothing swapped, swapped failed\n            return (0, false);\n        }\n        // return amount of note received\n        (int128 baseUsed, int128 quoteUsed) = abi.decode(data, (int128, int128));\n        return (uint128(-1 * (isNoteBase ? baseUsed : quoteUsed)), true);\n    }\n\n    function ambientPoolFor(address _baseToken, address _quoteToken, uint256 _poolIdx) internal view returns (uint256) {\n        bytes32 poolKey = keccak256(abi.encode(_baseToken, _quoteToken, _poolIdx));\n        uint POOL_PARAM_SLOT = 65545;\n        bytes32 slot = keccak256(abi.encode(poolKey, POOL_PARAM_SLOT));\n        return ICrocSwapDex(crocSwapAddress).readSlot(uint256(slot));\n    }\n}"
    }
  ]
}