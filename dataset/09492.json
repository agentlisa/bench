{
  "Title": "[N-09] The `nonReentrant` `modifier` should occur before all other modifiers",
  "Content": "\nThis is a best-practice to protect against reentrancy in other modifiers\n\n1.  File: src/CitadelMinter.sol (line [173](https://github.com/code-423n4/2022-04-badger-citadel/blob/dab143a990a9c355578fbb15cd3c884614e33f42/src/CitadelMinter.sol#L173))\n\n```solidity\n        nonReentrant\n```\n\n2.  File: src/CitadelMinter.sol (line [254](https://github.com/code-423n4/2022-04-badger-citadel/blob/dab143a990a9c355578fbb15cd3c884614e33f42/src/CitadelMinter.sol#L254))\n\n```solidity\n        nonReentrant\n```\n\n3.  File: src/CitadelMinter.sol (line [298](https://github.com/code-423n4/2022-04-badger-citadel/blob/dab143a990a9c355578fbb15cd3c884614e33f42/src/CitadelMinter.sol#L298))\n\n```solidity\n    ) external onlyRole(POLICY_OPERATIONS_ROLE) gacPausable nonReentrant {\n```\n\n4.  File: src/Funding.sol (line [167](https://github.com/code-423n4/2022-04-badger-citadel/blob/dab143a990a9c355578fbb15cd3c884614e33f42/src/Funding.sol#L167))\n\n```solidity\n        nonReentrant\n```\n\n5.  File: src/Funding.sol (line [318](https://github.com/code-423n4/2022-04-badger-citadel/blob/dab143a990a9c355578fbb15cd3c884614e33f42/src/Funding.sol#L318))\n\n```solidity\n        nonReentrant\n```\n\n6.  File: src/KnightingRound.sol (line [402](https://github.com/code-423n4/2022-04-badger-citadel/blob/dab143a990a9c355578fbb15cd3c884614e33f42/src/KnightingRound.sol#L402))\n\n```solidity\n    function sweep(address _token) external gacPausable nonReentrant onlyRole(TREASURY_OPERATIONS_ROLE) {\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-04-badger-citadel",
  "Code": [
    {
      "filename": "src/CitadelMinter.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\npragma experimental ABIEncoderV2;\n\nimport {IERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {AddressUpgradeable} from \"openzeppelin-contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"openzeppelin-contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {EnumerableSetUpgradeable} from \"openzeppelin-contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\n\nimport \"./lib/GlobalAccessControlManaged.sol\";\n\nimport \"./interfaces/citadel/ISupplySchedule.sol\";\nimport \"./interfaces/citadel/ICitadelToken.sol\";\nimport \"./interfaces/badger/IVault.sol\";\nimport \"./interfaces/citadel/IStakedCitadelLocker.sol\";\n\n/**\nSupply schedules are defined in terms of Epochs\n*/\ncontract CitadelMinter is\n    GlobalAccessControlManaged,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    bytes32 public constant CONTRACT_GOVERNANCE_ROLE =\n        keccak256(\"CONTRACT_GOVERNANCE_ROLE\");\n    bytes32 public constant POLICY_OPERATIONS_ROLE =\n        keccak256(\"POLICY_OPERATIONS_ROLE\");\n\n    ICitadelToken public citadelToken;\n    IVault public xCitadel;\n    IStakedCitadelLocker public xCitadelLocker;\n    ISupplySchedule public supplySchedule;\n\n    uint256 public lastMintTimestamp;\n\n    uint256 constant MAX_BPS = 10000;\n\n    EnumerableSetUpgradeable.AddressSet internal fundingPools;\n    mapping(address => uint256) public fundingPoolWeights;\n    uint256 public totalFundingPoolWeight;\n\n    uint256 public fundingBps;\n    uint256 public stakingBps;\n    uint256 public lockingBps;\n\n    /// ==================\n    /// ===== Events =====\n    /// ==================\n\n    event FundingPoolWeightSet(\n        address pool,\n        uint256 weight,\n        uint256 totalFundingPoolWeight\n    );\n    event CitadelDistributionSplitSet(\n        uint256 fundingBps,\n        uint256 stakingBps,\n        uint256 lockingBps\n    );\n    event CitadelDistribution(\n        uint256 fundingAmount,\n        uint256 stakingAmount,\n        uint256 lockingAmount\n    );\n\n    event CitadelDistributionToFunding(\n        uint256 startTime,\n        uint256 endTime,\n        uint256 citadelAmount\n    );\n    event CitadelDistributionToFundingPool(\n        uint256 startTime,\n        uint256 endTime,\n        address pool,\n        uint256 citadelAmount\n    );\n    event CitadelDistributionToStaking(\n        uint256 startTime,\n        uint256 endTime,\n        uint256 citadelAmount\n    );\n    event CitadelDistributionToLocking(\n        uint256 startTime,\n        uint256 endTime,\n        uint256 citadelAmount,\n        uint256 xCitadelAmount\n    );\n\n    /// =======================\n    /// ===== Initializer =====\n    /// =======================\n\n    /**\n     * @notice Initializer\n     * @dev this contract must have the rights to mint the citadel token to function correctly\n     * @dev this contract is intended to be the only way citadel is minted, with the expection of the initial minting event\n     * @param _gac global access control which is pinged to allow / deny access to permissioned calls by role\n     * @param _citadelToken citadel token\n     * @param _xCitadel staked citadel\n     * @param _xCitadelLocker staked citadel locker\n     * @param _supplySchedule contract that determines how much citadel to mint at a given time\n     */\n    function initialize(\n        address _gac,\n        address _citadelToken,\n        address _xCitadel,\n        address _xCitadelLocker,\n        address _supplySchedule\n    ) external initializer {\n        require(_gac != address(0), \"address 0 invalid\");\n        require(_citadelToken != address(0), \"address 0 invalid\");\n        require(_xCitadel != address(0), \"address 0 invalid\");\n        require(_xCitadelLocker != address(0), \"address 0 invalid\");\n        require(_supplySchedule != address(0), \"address 0 invalid\");\n\n        __GlobalAccessControlManaged_init(_gac);\n        __ReentrancyGuard_init();\n\n        citadelToken = ICitadelToken(_citadelToken);\n        xCitadel = IVault(_xCitadel);\n        xCitadelLocker = IStakedCitadelLocker(_xCitadelLocker);\n\n        supplySchedule = ISupplySchedule(_supplySchedule);\n\n        // Approve xCitadel vault for use of citadel tokens\n        // NOTE: Using input params as those cost 3 to read vs 100 from storage\n        IERC20Upgradeable(_citadelToken).safeApprove(_xCitadel, type(uint256).max);\n\n        // Approve xCitadel for locker to use\n        IERC20Upgradeable(_xCitadel).safeApprove(_xCitadelLocker, type(uint256).max);\n    }\n\n    /// =======================\n    /// ===== Public view =====\n    /// =======================\n\n    function getFundingPoolWeights()\n        external\n        view\n        returns (address[] memory pools, uint256[] memory weights)\n    {\n        uint256 numPools = fundingPools.length();\n        pools = new address[](numPools);\n        weights = new uint256[](numPools);\n\n        for (uint256 i = 0; i < numPools; i++) {\n            address pool = fundingPools.at(i);\n            uint256 weight = fundingPoolWeights[pool];\n\n            pools[i] = pool;\n            weights[i] = weight;\n        }\n    }\n\n    /// ==============================\n    /// ===== Policy Ops actions =====\n    /// ==============================\n\n    /**\n     * @notice Update the state of citadel emissions by minting and distributing citadel tokens according to the emission schedule and proportional splits between destinations (e.g. funding pools, stakers, lockers)\n     * @dev In theory this call should be permissionless, and after sufficient security analysis this may be changed to be the case\n     */\n    function mintAndDistribute()\n        external\n        onlyRole(POLICY_OPERATIONS_ROLE)\n        gacPausable\n        nonReentrant\n    {\n        uint256 cachedLastMintTimestamp = lastMintTimestamp;\n\n        uint256 mintable = supplySchedule.getMintable(cachedLastMintTimestamp);\n        citadelToken.mint(address(this), mintable);\n\n        uint256 lockingAmount = 0;\n        uint256 stakingAmount = 0;\n        uint256 fundingAmount = 0;\n\n        // 3 gas to store + 3 to read\n        // Saves 100 gas for each time we xCitadel\n        IVault cachedXCitadel = xCitadel;\n\n        // Saves gas below if true\n        uint256 cachedLockingBps = lockingBps;\n        if (cachedLockingBps != 0) {\n            lockingAmount = (mintable * cachedLockingBps) / MAX_BPS;\n\n            uint256 beforeAmount = cachedXCitadel.balanceOf(address(this));\n\n            IVault(cachedXCitadel).deposit(lockingAmount);\n\n            uint256 afterAmount = cachedXCitadel.balanceOf(address(this));\n\n            uint256 xCitadelToLockers = afterAmount - beforeAmount;\n\n            xCitadelLocker.notifyRewardAmount(\n                address(cachedXCitadel),\n                xCitadelToLockers\n            );\n            emit CitadelDistributionToLocking(\n                cachedLastMintTimestamp,\n                block.timestamp,\n                lockingAmount,\n                xCitadelToLockers\n            );\n        }\n\n        uint256 cachedStakingBps = stakingBps;\n        if (cachedStakingBps != 0) {\n            stakingAmount = (mintable * cachedStakingBps) / MAX_BPS;\n\n            IERC20Upgradeable(address(citadelToken)).safeTransfer(address(cachedXCitadel), stakingAmount);\n            emit CitadelDistributionToStaking(\n                cachedLastMintTimestamp,\n                block.timestamp,\n                stakingAmount\n            );\n        }\n\n        /// Saves gas if the if is true, if it's not costs 6 extra gas\n        uint256 cachedFundingBps = fundingBps;\n        if (cachedFundingBps != 0) {\n            fundingAmount = (mintable * cachedFundingBps) / MAX_BPS;\n\n            _transferToFundingPools(fundingAmount);\n            emit CitadelDistributionToFunding(\n                cachedLastMintTimestamp,\n                block.timestamp,\n                fundingAmount\n            );\n        }\n\n        emit CitadelDistribution(fundingAmount, stakingAmount, lockingAmount);\n\n        lastMintTimestamp = block.timestamp;\n    }\n\n    /**\n     * @notice Set the funding weight for a given address.\n     * @dev If the pool does not exist and is assigned a weight\n     * @dev Setting the funding pool weight to 0 for an existing pool will delete it from the set\n     * @param _pool Address of funding pool contract to add\n     * @param _weight Weight to give to pool. Must be between 0 and 10000, inclusive\n     */\n    function setFundingPoolWeight(address _pool, uint256 _weight)\n        external\n        onlyRole(POLICY_OPERATIONS_ROLE)\n        gacPausable\n        nonReentrant\n    {\n        require(\n            address(_pool) != address(0),\n            \"CitadelMinter: address(0) check\"\n        );\n\n        bool poolExists = fundingPools.contains(_pool);\n\n        // NOTE: Could cachedTotalFundingPoolWeight but honestly logic is already messy enough\n\n        // Remove existing pool on 0 weight\n        if (_weight == 0 && poolExists) {\n            _removeFundingPool(_pool);\n\n            emit FundingPoolWeightSet(_pool, _weight, totalFundingPoolWeight);\n        } else if (_weight > 0) {\n            // Add new pool or modify existing pool\n            require(_weight <= 10000, \"exceed max funding pool weight\");\n            if (!poolExists) {\n                _addFundingPool(_pool);\n            }\n            uint256 _newTotalWeight = totalFundingPoolWeight;\n            _newTotalWeight = _newTotalWeight - fundingPoolWeights[_pool];\n            fundingPoolWeights[_pool] = _weight;\n            _newTotalWeight = _newTotalWeight + _weight;\n            totalFundingPoolWeight = _newTotalWeight;\n\n            emit FundingPoolWeightSet(_pool, _weight, _newTotalWeight);\n        }\n    }\n\n    /**\n     * @notice Set the proportions of newly minted citadel to go to funding pools, stakers, and lockers on mintAndDistribute() calls\n     * @dev This is decided according to the treasury / marketcap logic outlined in the tokenomics, and is intended to be automated on-chain when safe\n     * @dev Sum of basis point values supplied must exactly equal 10000 (100%)\n     * @param _fundingBps Percentage of newly minted citadel to be allocated to funding pools, in basis points\n     * @param _stakingBps Percentage of newly minted citadel to be allocated to stakers as auto-compounding xCitadel rewards, in basis points\n     * @param _lockingBps Percentage of newly minted citadel to be allocated to lockers as emitted xCitadel rewards, in basis points\n     */\n    function setCitadelDistributionSplit(\n        uint256 _fundingBps,\n        uint256 _stakingBps,\n        uint256 _lockingBps\n    ) external onlyRole(POLICY_OPERATIONS_ROLE) gacPausable nonReentrant {\n        require(\n            _fundingBps + _stakingBps + _lockingBps == MAX_BPS,\n            \"CitadelMinter: Sum of propvalues must be 10000 bps\"\n        );\n        fundingBps = _fundingBps;\n        stakingBps = _stakingBps;\n        lockingBps = _lockingBps;\n\n        emit CitadelDistributionSplitSet(_fundingBps, _stakingBps, _lockingBps);\n    }\n\n    /// ==============================\n    /// ===== Governance actions =====\n    /// ==============================\n\n    function initializeLastMintTimestamp()\n        external\n        onlyRole(CONTRACT_GOVERNANCE_ROLE)\n        gacPausable\n    {\n        require(\n            lastMintTimestamp == 0,\n            \"CitadelMinter: last mint timestamp already initialized\"\n        );\n        uint256 globalStartTimestamp = ISupplySchedule(supplySchedule)\n            .globalStartTimestamp();\n\n        require(\n            globalStartTimestamp != 0,\n            \"CitadelMinter: supply schedule start not initialized\"\n        );\n        lastMintTimestamp = globalStartTimestamp;\n    }\n\n    /// ==============================\n    /// ===== Internal Functions =====\n    /// ==============================\n\n    // === Funding Pool Management ===\n    function _transferToFundingPools(uint256 _citadelAmount) internal {\n        uint256 length = fundingPools.length();\n        // Use cached to save 96 gas per loop read\n        uint256 cachedTotalFundingPoolWeight = totalFundingPoolWeight;\n\n        require(length > 0, \"CitadelMinter: no funding pools\");\n        for (uint256 i; i < length; ++i) {\n            address pool = fundingPools.at(i);\n            uint256 weight = fundingPoolWeights[pool];\n\n            uint256 amount = (_citadelAmount * weight) /\n                cachedTotalFundingPoolWeight;\n\n            IERC20Upgradeable(address(citadelToken)).safeTransfer(pool, amount);\n\n            emit CitadelDistributionToFundingPool(\n                lastMintTimestamp,\n                block.timestamp,\n                pool,\n                amount\n            );\n        }\n    }\n\n    function _removeFundingPool(address _pool) internal {\n        uint256 currentPoolWeight = fundingPoolWeights[_pool];\n        totalFundingPoolWeight = totalFundingPoolWeight - currentPoolWeight;\n\n        fundingPoolWeights[_pool] = 0;\n\n        require(\n            fundingPools.remove(_pool),\n            \"CitadelMinter: funding pool does not exist for removal\"\n        );\n    }\n\n    function _addFundingPool(address _pool) internal {\n        require(\n            fundingPools.add(_pool),\n            \"CitadelMinter: funding pool already exists\"\n        );\n    }\n}"
    },
    {
      "filename": "src/CitadelMinter.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\npragma experimental ABIEncoderV2;\n\nimport {IERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {AddressUpgradeable} from \"openzeppelin-contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"openzeppelin-contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {EnumerableSetUpgradeable} from \"openzeppelin-contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\n\nimport \"./lib/GlobalAccessControlManaged.sol\";\n\nimport \"./interfaces/citadel/ISupplySchedule.sol\";\nimport \"./interfaces/citadel/ICitadelToken.sol\";\nimport \"./interfaces/badger/IVault.sol\";\nimport \"./interfaces/citadel/IStakedCitadelLocker.sol\";\n\n/**\nSupply schedules are defined in terms of Epochs\n*/\ncontract CitadelMinter is\n    GlobalAccessControlManaged,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    bytes32 public constant CONTRACT_GOVERNANCE_ROLE =\n        keccak256(\"CONTRACT_GOVERNANCE_ROLE\");\n    bytes32 public constant POLICY_OPERATIONS_ROLE =\n        keccak256(\"POLICY_OPERATIONS_ROLE\");\n\n    ICitadelToken public citadelToken;\n    IVault public xCitadel;\n    IStakedCitadelLocker public xCitadelLocker;\n    ISupplySchedule public supplySchedule;\n\n    uint256 public lastMintTimestamp;\n\n    uint256 constant MAX_BPS = 10000;\n\n    EnumerableSetUpgradeable.AddressSet internal fundingPools;\n    mapping(address => uint256) public fundingPoolWeights;\n    uint256 public totalFundingPoolWeight;\n\n    uint256 public fundingBps;\n    uint256 public stakingBps;\n    uint256 public lockingBps;\n\n    /// ==================\n    /// ===== Events =====\n    /// ==================\n\n    event FundingPoolWeightSet(\n        address pool,\n        uint256 weight,\n        uint256 totalFundingPoolWeight\n    );\n    event CitadelDistributionSplitSet(\n        uint256 fundingBps,\n        uint256 stakingBps,\n        uint256 lockingBps\n    );\n    event CitadelDistribution(\n        uint256 fundingAmount,\n        uint256 stakingAmount,\n        uint256 lockingAmount\n    );\n\n    event CitadelDistributionToFunding(\n        uint256 startTime,\n        uint256 endTime,\n        uint256 citadelAmount\n    );\n    event CitadelDistributionToFundingPool(\n        uint256 startTime,\n        uint256 endTime,\n        address pool,\n        uint256 citadelAmount\n    );\n    event CitadelDistributionToStaking(\n        uint256 startTime,\n        uint256 endTime,\n        uint256 citadelAmount\n    );\n    event CitadelDistributionToLocking(\n        uint256 startTime,\n        uint256 endTime,\n        uint256 citadelAmount,\n        uint256 xCitadelAmount\n    );\n\n    /// =======================\n    /// ===== Initializer =====\n    /// =======================\n\n    /**\n     * @notice Initializer\n     * @dev this contract must have the rights to mint the citadel token to function correctly\n     * @dev this contract is intended to be the only way citadel is minted, with the expection of the initial minting event\n     * @param _gac global access control which is pinged to allow / deny access to permissioned calls by role\n     * @param _citadelToken citadel token\n     * @param _xCitadel staked citadel\n     * @param _xCitadelLocker staked citadel locker\n     * @param _supplySchedule contract that determines how much citadel to mint at a given time\n     */\n    function initialize(\n        address _gac,\n        address _citadelToken,\n        address _xCitadel,\n        address _xCitadelLocker,\n        address _supplySchedule\n    ) external initializer {\n        require(_gac != address(0), \"address 0 invalid\");\n        require(_citadelToken != address(0), \"address 0 invalid\");\n        require(_xCitadel != address(0), \"address 0 invalid\");\n        require(_xCitadelLocker != address(0), \"address 0 invalid\");\n        require(_supplySchedule != address(0), \"address 0 invalid\");\n\n        __GlobalAccessControlManaged_init(_gac);\n        __ReentrancyGuard_init();\n\n        citadelToken = ICitadelToken(_citadelToken);\n        xCitadel = IVault(_xCitadel);\n        xCitadelLocker = IStakedCitadelLocker(_xCitadelLocker);\n\n        supplySchedule = ISupplySchedule(_supplySchedule);\n\n        // Approve xCitadel vault for use of citadel tokens\n        // NOTE: Using input params as those cost 3 to read vs 100 from storage\n        IERC20Upgradeable(_citadelToken).safeApprove(_xCitadel, type(uint256).max);\n\n        // Approve xCitadel for locker to use\n        IERC20Upgradeable(_xCitadel).safeApprove(_xCitadelLocker, type(uint256).max);\n    }\n\n    /// =======================\n    /// ===== Public view =====\n    /// =======================\n\n    function getFundingPoolWeights()\n        external\n        view\n        returns (address[] memory pools, uint256[] memory weights)\n    {\n        uint256 numPools = fundingPools.length();\n        pools = new address[](numPools);\n        weights = new uint256[](numPools);\n\n        for (uint256 i = 0; i < numPools; i++) {\n            address pool = fundingPools.at(i);\n            uint256 weight = fundingPoolWeights[pool];\n\n            pools[i] = pool;\n            weights[i] = weight;\n        }\n    }\n\n    /// ==============================\n    /// ===== Policy Ops actions =====\n    /// ==============================\n\n    /**\n     * @notice Update the state of citadel emissions by minting and distributing citadel tokens according to the emission schedule and proportional splits between destinations (e.g. funding pools, stakers, lockers)\n     * @dev In theory this call should be permissionless, and after sufficient security analysis this may be changed to be the case\n     */\n    function mintAndDistribute()\n        external\n        onlyRole(POLICY_OPERATIONS_ROLE)\n        gacPausable\n        nonReentrant\n    {\n        uint256 cachedLastMintTimestamp = lastMintTimestamp;\n\n        uint256 mintable = supplySchedule.getMintable(cachedLastMintTimestamp);\n        citadelToken.mint(address(this), mintable);\n\n        uint256 lockingAmount = 0;\n        uint256 stakingAmount = 0;\n        uint256 fundingAmount = 0;\n\n        // 3 gas to store + 3 to read\n        // Saves 100 gas for each time we xCitadel\n        IVault cachedXCitadel = xCitadel;\n\n        // Saves gas below if true\n        uint256 cachedLockingBps = lockingBps;\n        if (cachedLockingBps != 0) {\n            lockingAmount = (mintable * cachedLockingBps) / MAX_BPS;\n\n            uint256 beforeAmount = cachedXCitadel.balanceOf(address(this));\n\n            IVault(cachedXCitadel).deposit(lockingAmount);\n\n            uint256 afterAmount = cachedXCitadel.balanceOf(address(this));\n\n            uint256 xCitadelToLockers = afterAmount - beforeAmount;\n\n            xCitadelLocker.notifyRewardAmount(\n                address(cachedXCitadel),\n                xCitadelToLockers\n            );\n            emit CitadelDistributionToLocking(\n                cachedLastMintTimestamp,\n                block.timestamp,\n                lockingAmount,\n                xCitadelToLockers\n            );\n        }\n\n        uint256 cachedStakingBps = stakingBps;\n        if (cachedStakingBps != 0) {\n            stakingAmount = (mintable * cachedStakingBps) / MAX_BPS;\n\n            IERC20Upgradeable(address(citadelToken)).safeTransfer(address(cachedXCitadel), stakingAmount);\n            emit CitadelDistributionToStaking(\n                cachedLastMintTimestamp,\n                block.timestamp,\n                stakingAmount\n            );\n        }\n\n        /// Saves gas if the if is true, if it's not costs 6 extra gas\n        uint256 cachedFundingBps = fundingBps;\n        if (cachedFundingBps != 0) {\n            fundingAmount = (mintable * cachedFundingBps) / MAX_BPS;\n\n            _transferToFundingPools(fundingAmount);\n            emit CitadelDistributionToFunding(\n                cachedLastMintTimestamp,\n                block.timestamp,\n                fundingAmount\n            );\n        }\n\n        emit CitadelDistribution(fundingAmount, stakingAmount, lockingAmount);\n\n        lastMintTimestamp = block.timestamp;\n    }\n\n    /**\n     * @notice Set the funding weight for a given address.\n     * @dev If the pool does not exist and is assigned a weight\n     * @dev Setting the funding pool weight to 0 for an existing pool will delete it from the set\n     * @param _pool Address of funding pool contract to add\n     * @param _weight Weight to give to pool. Must be between 0 and 10000, inclusive\n     */\n    function setFundingPoolWeight(address _pool, uint256 _weight)\n        external\n        onlyRole(POLICY_OPERATIONS_ROLE)\n        gacPausable\n        nonReentrant\n    {\n        require(\n            address(_pool) != address(0),\n            \"CitadelMinter: address(0) check\"\n        );\n\n        bool poolExists = fundingPools.contains(_pool);\n\n        // NOTE: Could cachedTotalFundingPoolWeight but honestly logic is already messy enough\n\n        // Remove existing pool on 0 weight\n        if (_weight == 0 && poolExists) {\n            _removeFundingPool(_pool);\n\n            emit FundingPoolWeightSet(_pool, _weight, totalFundingPoolWeight);\n        } else if (_weight > 0) {\n            // Add new pool or modify existing pool\n            require(_weight <= 10000, \"exceed max funding pool weight\");\n            if (!poolExists) {\n                _addFundingPool(_pool);\n            }\n            uint256 _newTotalWeight = totalFundingPoolWeight;\n            _newTotalWeight = _newTotalWeight - fundingPoolWeights[_pool];\n            fundingPoolWeights[_pool] = _weight;\n            _newTotalWeight = _newTotalWeight + _weight;\n            totalFundingPoolWeight = _newTotalWeight;\n\n            emit FundingPoolWeightSet(_pool, _weight, _newTotalWeight);\n        }\n    }\n\n    /**\n     * @notice Set the proportions of newly minted citadel to go to funding pools, stakers, and lockers on mintAndDistribute() calls\n     * @dev This is decided according to the treasury / marketcap logic outlined in the tokenomics, and is intended to be automated on-chain when safe\n     * @dev Sum of basis point values supplied must exactly equal 10000 (100%)\n     * @param _fundingBps Percentage of newly minted citadel to be allocated to funding pools, in basis points\n     * @param _stakingBps Percentage of newly minted citadel to be allocated to stakers as auto-compounding xCitadel rewards, in basis points\n     * @param _lockingBps Percentage of newly minted citadel to be allocated to lockers as emitted xCitadel rewards, in basis points\n     */\n    function setCitadelDistributionSplit(\n        uint256 _fundingBps,\n        uint256 _stakingBps,\n        uint256 _lockingBps\n    ) external onlyRole(POLICY_OPERATIONS_ROLE) gacPausable nonReentrant {\n        require(\n            _fundingBps + _stakingBps + _lockingBps == MAX_BPS,\n            \"CitadelMinter: Sum of propvalues must be 10000 bps\"\n        );\n        fundingBps = _fundingBps;\n        stakingBps = _stakingBps;\n        lockingBps = _lockingBps;\n\n        emit CitadelDistributionSplitSet(_fundingBps, _stakingBps, _lockingBps);\n    }\n\n    /// ==============================\n    /// ===== Governance actions =====\n    /// ==============================\n\n    function initializeLastMintTimestamp()\n        external\n        onlyRole(CONTRACT_GOVERNANCE_ROLE)\n        gacPausable\n    {\n        require(\n            lastMintTimestamp == 0,\n            \"CitadelMinter: last mint timestamp already initialized\"\n        );\n        uint256 globalStartTimestamp = ISupplySchedule(supplySchedule)\n            .globalStartTimestamp();\n\n        require(\n            globalStartTimestamp != 0,\n            \"CitadelMinter: supply schedule start not initialized\"\n        );\n        lastMintTimestamp = globalStartTimestamp;\n    }\n\n    /// ==============================\n    /// ===== Internal Functions =====\n    /// ==============================\n\n    // === Funding Pool Management ===\n    function _transferToFundingPools(uint256 _citadelAmount) internal {\n        uint256 length = fundingPools.length();\n        // Use cached to save 96 gas per loop read\n        uint256 cachedTotalFundingPoolWeight = totalFundingPoolWeight;\n\n        require(length > 0, \"CitadelMinter: no funding pools\");\n        for (uint256 i; i < length; ++i) {\n            address pool = fundingPools.at(i);\n            uint256 weight = fundingPoolWeights[pool];\n\n            uint256 amount = (_citadelAmount * weight) /\n                cachedTotalFundingPoolWeight;\n\n            IERC20Upgradeable(address(citadelToken)).safeTransfer(pool, amount);\n\n            emit CitadelDistributionToFundingPool(\n                lastMintTimestamp,\n                block.timestamp,\n                pool,\n                amount\n            );\n        }\n    }\n\n    function _removeFundingPool(address _pool) internal {\n        uint256 currentPoolWeight = fundingPoolWeights[_pool];\n        totalFundingPoolWeight = totalFundingPoolWeight - currentPoolWeight;\n\n        fundingPoolWeights[_pool] = 0;\n\n        require(\n            fundingPools.remove(_pool),\n            \"CitadelMinter: funding pool does not exist for removal\"\n        );\n    }\n\n    function _addFundingPool(address _pool) internal {\n        require(\n            fundingPools.add(_pool),\n            \"CitadelMinter: funding pool already exists\"\n        );\n    }\n}"
    },
    {
      "filename": "src/CitadelMinter.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\npragma experimental ABIEncoderV2;\n\nimport {IERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {AddressUpgradeable} from \"openzeppelin-contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"openzeppelin-contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {EnumerableSetUpgradeable} from \"openzeppelin-contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\n\nimport \"./lib/GlobalAccessControlManaged.sol\";\n\nimport \"./interfaces/citadel/ISupplySchedule.sol\";\nimport \"./interfaces/citadel/ICitadelToken.sol\";\nimport \"./interfaces/badger/IVault.sol\";\nimport \"./interfaces/citadel/IStakedCitadelLocker.sol\";\n\n/**\nSupply schedules are defined in terms of Epochs\n*/\ncontract CitadelMinter is\n    GlobalAccessControlManaged,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    bytes32 public constant CONTRACT_GOVERNANCE_ROLE =\n        keccak256(\"CONTRACT_GOVERNANCE_ROLE\");\n    bytes32 public constant POLICY_OPERATIONS_ROLE =\n        keccak256(\"POLICY_OPERATIONS_ROLE\");\n\n    ICitadelToken public citadelToken;\n    IVault public xCitadel;\n    IStakedCitadelLocker public xCitadelLocker;\n    ISupplySchedule public supplySchedule;\n\n    uint256 public lastMintTimestamp;\n\n    uint256 constant MAX_BPS = 10000;\n\n    EnumerableSetUpgradeable.AddressSet internal fundingPools;\n    mapping(address => uint256) public fundingPoolWeights;\n    uint256 public totalFundingPoolWeight;\n\n    uint256 public fundingBps;\n    uint256 public stakingBps;\n    uint256 public lockingBps;\n\n    /// ==================\n    /// ===== Events =====\n    /// ==================\n\n    event FundingPoolWeightSet(\n        address pool,\n        uint256 weight,\n        uint256 totalFundingPoolWeight\n    );\n    event CitadelDistributionSplitSet(\n        uint256 fundingBps,\n        uint256 stakingBps,\n        uint256 lockingBps\n    );\n    event CitadelDistribution(\n        uint256 fundingAmount,\n        uint256 stakingAmount,\n        uint256 lockingAmount\n    );\n\n    event CitadelDistributionToFunding(\n        uint256 startTime,\n        uint256 endTime,\n        uint256 citadelAmount\n    );\n    event CitadelDistributionToFundingPool(\n        uint256 startTime,\n        uint256 endTime,\n        address pool,\n        uint256 citadelAmount\n    );\n    event CitadelDistributionToStaking(\n        uint256 startTime,\n        uint256 endTime,\n        uint256 citadelAmount\n    );\n    event CitadelDistributionToLocking(\n        uint256 startTime,\n        uint256 endTime,\n        uint256 citadelAmount,\n        uint256 xCitadelAmount\n    );\n\n    /// =======================\n    /// ===== Initializer =====\n    /// =======================\n\n    /**\n     * @notice Initializer\n     * @dev this contract must have the rights to mint the citadel token to function correctly\n     * @dev this contract is intended to be the only way citadel is minted, with the expection of the initial minting event\n     * @param _gac global access control which is pinged to allow / deny access to permissioned calls by role\n     * @param _citadelToken citadel token\n     * @param _xCitadel staked citadel\n     * @param _xCitadelLocker staked citadel locker\n     * @param _supplySchedule contract that determines how much citadel to mint at a given time\n     */\n    function initialize(\n        address _gac,\n        address _citadelToken,\n        address _xCitadel,\n        address _xCitadelLocker,\n        address _supplySchedule\n    ) external initializer {\n        require(_gac != address(0), \"address 0 invalid\");\n        require(_citadelToken != address(0), \"address 0 invalid\");\n        require(_xCitadel != address(0), \"address 0 invalid\");\n        require(_xCitadelLocker != address(0), \"address 0 invalid\");\n        require(_supplySchedule != address(0), \"address 0 invalid\");\n\n        __GlobalAccessControlManaged_init(_gac);\n        __ReentrancyGuard_init();\n\n        citadelToken = ICitadelToken(_citadelToken);\n        xCitadel = IVault(_xCitadel);\n        xCitadelLocker = IStakedCitadelLocker(_xCitadelLocker);\n\n        supplySchedule = ISupplySchedule(_supplySchedule);\n\n        // Approve xCitadel vault for use of citadel tokens\n        // NOTE: Using input params as those cost 3 to read vs 100 from storage\n        IERC20Upgradeable(_citadelToken).safeApprove(_xCitadel, type(uint256).max);\n\n        // Approve xCitadel for locker to use\n        IERC20Upgradeable(_xCitadel).safeApprove(_xCitadelLocker, type(uint256).max);\n    }\n\n    /// =======================\n    /// ===== Public view =====\n    /// =======================\n\n    function getFundingPoolWeights()\n        external\n        view\n        returns (address[] memory pools, uint256[] memory weights)\n    {\n        uint256 numPools = fundingPools.length();\n        pools = new address[](numPools);\n        weights = new uint256[](numPools);\n\n        for (uint256 i = 0; i < numPools; i++) {\n            address pool = fundingPools.at(i);\n            uint256 weight = fundingPoolWeights[pool];"
    }
  ]
}