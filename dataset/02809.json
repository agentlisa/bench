{
  "Title": "M-2: Converter cannot be changed in Redeemer",
  "Content": "# Issue M-2: Converter cannot be changed in Redeemer \n\nSource: https://github.com/sherlock-audit/2022-10-illuminate-judging/issues/223 \n\n## Found by \nRuhum, hyh\n\n## Summary\n\nRedeemer's setConverter() can be used to switch the converter contract, for example when new type of interest bearing token is introduced as Converter employs hard coded logic to deal with various types of IBTs. However new converter cannot be functional as there is no way to introduce the approvals needed, it can be done only once.\n\n## Vulnerability Detail\n\nUpgrading the converter contract is not fully implemented as switching the address without providing approvals isnâ€™t sufficient, while it is the only action that can be done now.\n\n## Impact\n\nIf there are some issues with converter or IBTs it covers there will not be possible to upgrade the contract.\n\nAlso, as currently the converter uses hard coded logic to cover Compound, Aave and Lido only, any new IBT cannot be introduced to the system as it requires new Converter to be rolled out for that.\n\nGiven that substantial part of Redeemer's logic is dependent on Converter's exchange from IBT to underlying that means the net impact can be up to massive fund freeze.\n\n## Code Snippet\n\nsetConverter() allows for changing the converter contract:\n\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Redeemer.sol#L145-L152\n\n```solidity\n    /// @notice sets the converter address\n    /// @param c address of the new converter\n    /// @return bool true if successful\n    function setConverter(address c) external authorized(admin) returns (bool) {\n        converter = c;\n        emit SetConverter(c);\n        return true;\n    }\n```\n\napprove() can provide the approvals needed, but it's `marketPlace` only:\n\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Redeemer.sol#L201-L207\n\n```solidity\n    /// @notice approves the converter to spend the compounding asset\n    /// @param i an interest bearing token that must be approved for conversion\n    function approve(address i) external authorized(marketPlace) {\n        if (i != address(0)) {\n            Safe.approve(IERC20(i), address(converter), type(uint256).max);\n        }\n    }\n```\n\nAnd there `approve` is run solely on the new market introduction, via createMarket():\n\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Marketplace.sol#L120-L201\n\n```solidity\n    /// @notice creates a new market for the given underlying token and maturity\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param t principal token addresses for this market\n    /// @param n name for the Illuminate token\n    /// @param s symbol for the Illuminate token\n    /// @param e address of the Element vault that corresponds to this market\n    /// @param a address of the APWine router that corresponds to this market\n    /// @return bool true if successful\n    function createMarket(\n        address u,\n        uint256 m,\n        address[8] calldata t,\n        string calldata n,\n        string calldata s,\n        address e,\n        address a\n    ) external authorized(admin) returns (bool) {\n        {\n            // Get the Illuminate principal token for this market (if one exists)\n            address illuminate = markets[u][m][\n                (uint256(Principals.Illuminate))\n            ];\n\n            // If illuminate PT already exists, a new market cannot be created\n            if (illuminate != address(0)) {\n                revert Exception(9, 0, 0, illuminate, address(0));\n            }\n        }\n\n        // Create an Illuminate principal token for the new market\n        address illuminateToken = address(\n            new ERC5095(\n            \t...\n            )\n        );\n\n        {\n        \t...\n\n            // Set the market\n            markets[u][m] = market;\n\n            // Have the lender contract approve the several contracts\n            ILender(lender).approve(u, e, a, t[7]);\n\n            // Have the redeemer contract approve the Pendle principal token\n            if (t[3] != address(0)) {\n                address underlyingYieldToken = IPendleToken(t[3])\n                    .underlyingYieldToken();\n                IRedeemer(redeemer).approve(underlyingYieldToken);\n            }\n\n            if (t[6] != address(0)) {\n                address futureVault = IAPWineToken(t[6]).futureVault();\n                address interestBearingToken = IAPWineFutureVault(futureVault)\n                    .getIBTAddress();\n                IRedeemer(redeemer).approve(interestBearingToken);\n            }\n\n            emit CreateMarket(u, m, market, e, a);\n        }\n        return true;\n    }\n```\n\nAnd via setPrincipal():\n\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Marketplace.sol#L203-L243\n\n```solidity\n    /// @notice allows the admin to set an individual market\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a address of the new principal token\n    /// @return bool true if the principal set, false otherwise\n    function setPrincipal(\n        uint8 p,\n        address u,\n        uint256 m,\n        address a\n    ) external authorized(admin) returns (bool) {\n        // Get the current principal token for the principal token being set\n        address market = markets[u][m][p];\n\n        // Verify that it has not already been set\n        if (market != address(0)) {\n            revert Exception(9, 0, 0, market, address(0));\n        }\n\n        // Set the principal token in the markets mapping\n        markets[u][m][p] = a;\n\n        if (p == uint8(Principals.Pendle)) {\n            // Principal token must be approved for Pendle's redeem\n            address underlyingYieldToken = IPendleToken(a)\n                .underlyingYieldToken();\n            IRedeemer(redeemer).approve(underlyingYieldToken);\n        } else if (p == uint8(Principals.Apwine)) {\n            address futureVault = IAPWineToken(a).futureVault();\n            address interestBearingToken = IAPWineFutureVault(futureVault)\n                .getIBTAddress();\n            IRedeemer(redeemer).approve(interestBearingToken);\n        } else if (p == uint8(Principals.Notional)) {\n            // Principal token must be approved for Notional's lend\n            ILender(lender).approve(address(0), address(0), address(0), a);\n        }\n\n        emit SetPrincipal(u, m, a, p);\n        return true;\n    }\n```\n\nIn both cases it's required that either Illuminate or `market` is `address(0)`, i.e. both functions cannot be run repeatedly.\n\nI.e. it's impossible to run approve if the market exists, so there is no way to approve and use new Converter as without approval it will not be functional, the corresponding Redeemer functions will be reverting as it's expected that converter can pull funds out of Redeemer.\n\nCurrently Converter functionality is fixed to deal with 3 types of IBTs:\n\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Converter.sol#L21-L51\n\n```solidity\n    function convert(\n        address c,\n        address u,\n        uint256 a\n    ) external {\n        // first receive the tokens from msg.sender\n        Safe.transferFrom(IERC20(c), msg.sender, address(this), a);\n\n        // get Aave pool\n        try IAaveAToken(c).POOL() returns (address pool) {\n            // Allow the pool to spend the funds\n            Safe.approve(IERC20(u), pool, a);\n            // withdraw from Aave\n            IAaveLendingPool(pool).withdraw(u, a, msg.sender);\n        } catch {\n            // attempt to redeem compound tokens to the underlying asset\n            try ICompoundToken(c).redeem(a) {\n                // get the balance of underlying assets redeemed\n                uint256 balance = IERC20(u).balanceOf(address(this));\n                // transfer the underlying back to the user\n                Safe.transfer(IERC20(u), msg.sender, balance);\n            } catch {\n                // get the current balance of wstETH\n                uint256 balance = IERC20(c).balanceOf(address(this));\n                // unwrap wrapped staked eth\n                uint256 unwrapped = ILido(c).unwrap(balance);\n                // Send the unwrapped staked ETH to the caller\n                Safe.transfer(IERC20(u), msg.sender, unwrapped);\n            }\n        }\n    }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider running the approvals setting on the introduction of the new Converter, i.e. run Marketplace's createMarket() approval logic as a part of Redeemer's setConverter(), also clearing the approvals for the old one.\n\n## Discussion\n\n**JTraversa**\n\nThough the issue is likely valid, along with Sherlock's scoring guide, this likely does not end up being accepted as a valid issue as no funds are at risk: https://docs.sherlock.xyz/audits/watsons/judging\n\nWhile the intention of the method is to allow an admin to set a new converter, this is simply a convenience/upgradability method meaning no funds are at risk for any deployments.\n\n**IllIllI000**\n\n@JTraversa Wouldn't funds be at risk since the Redeemer would be unable to convert PTs to underlying, for users to redeem their IPTs? Looking at some of the other issue comments though, I believe this would will fall under the admin input validation category, and would thus be classified as Low\n\n**JTraversa**\n\nFunds would be at risk _if_ we upgraded the converter contract and changed its implementation.\n\nThat said, this is not \"normal\" execution for the protocol, and the method `setConverter` was simply added at a later time for convenience if we should ever need to do so.\n\nSo the feature that is not operational is the upgradability of the converter, rather than any actual funds potentially lost from operation. \n\nThe converter should never need to be upgraded unless we add additional protocol integrations, and with the current implementation this would require a full redeployment given the static array of potentially integration principal tokens.\n\nSo I'd see this as a low severity issue impacting upgradability solely.\n\n\n\n**0x00052**\n\nEscalate for 1 USDC\n\nReminder @Evert0x \n\n**sherlock-admin**\n\n > Escalate for 1 USDC\n> \n> Reminder @Evert0x \n\nYou've created a valid escalation for 1 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/12",
  "Code": [
    {
      "filename": "src/Redeemer.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.16;\n\nimport 'src/MarketPlace.sol';\n\nimport 'src/lib/Safe.sol';\nimport 'src/errors/Exception.sol';\n\nimport 'src/interfaces/IERC5095.sol';\nimport 'src/interfaces/IERC20.sol';\nimport 'src/interfaces/ITempus.sol';\nimport 'src/interfaces/ITempusPool.sol';\nimport 'src/interfaces/ITempusToken.sol';\nimport 'src/interfaces/IAPWine.sol';\nimport 'src/interfaces/IAPWineController.sol';\nimport 'src/interfaces/IAPWineFutureVault.sol';\nimport 'src/interfaces/IAPWineToken.sol';\nimport 'src/interfaces/IAPWineAMMPool.sol';\nimport 'src/interfaces/ISwivel.sol';\nimport 'src/interfaces/ISwivelToken.sol';\nimport 'src/interfaces/IElementToken.sol';\nimport 'src/interfaces/IYieldToken.sol';\nimport 'src/interfaces/INotional.sol';\nimport 'src/interfaces/IPendle.sol';\nimport 'src/interfaces/IPendleForge.sol';\nimport 'src/interfaces/IPendleToken.sol';\nimport 'src/interfaces/ISenseDivider.sol';\nimport 'src/interfaces/ISenseAdapter.sol';\nimport 'src/interfaces/IYield.sol';\nimport 'src/interfaces/IConverter.sol';\n\nimport 'forge-std/Test.sol';\n\n/// @title Redeemer\n/// @author Sourabh Marathe, Julian Traversa, Rob Robbins\n/// @notice The Redeemer contract is used to redeem the underlying lent capital of a loan.\n/// @notice Users may redeem their ERC-5095 tokens for the underlying asset represented by that token after maturity.\ncontract Redeemer {\n    /// @notice address that is allowed to set fees and contracts, etc. It is commonly used in the authorized modifier.\n    address public admin;\n    /// @notice address of the MarketPlace contract, used to access the markets mapping\n    address public marketPlace;\n    /// @notice address that custodies principal tokens for all markets\n    address public lender;\n    /// @notice address that converts compounding tokens to their underlying\n    address public converter;\n\n    /// @notice third party contract needed to redeem Swivel PTs\n    address public immutable swivelAddr;\n    /// @notice third party contract needed to redeem Pendle PTs\n    address public immutable pendleAddr;\n    /// @notice third party contract needed to redeem Tempus PTs\n    address public immutable tempusAddr;\n\n    /// @notice this value determines the amount of fees paid on auto redemptions\n    uint256 public feenominator;\n    /// @notice represents a point in time where the feenominator may change\n    uint256 public feeChange;\n    /// @notice represents a minimum that the feenominator must exceed\n    uint256 public MIN_FEENOMINATOR = 500;\n\n    /// @notice mapping that indicates how much underlying has been redeemed by a market\n    mapping(address => mapping(uint256 => uint256)) public holdings;\n    /// @notice mapping that determines if a market's iPT can be redeemed\n    mapping(address => mapping(uint256 => bool)) public paused;\n\n    /// @notice emitted upon redemption of a loan\n    event Redeem(\n        uint8 principal,\n        address indexed underlying,\n        uint256 indexed maturity,\n        uint256 amount,\n        address sender\n    );\n    /// @notice emitted upon changing the admin\n    event SetAdmin(address indexed admin);\n    /// @notice emitted upon changing the converter\n    event SetConverter(address indexed converter);\n    /// @notice emitted upon setting the fee rate\n    event SetFee(uint256 indexed fee);\n\n    /// @notice ensures that only a certain address can call the function\n    /// @param a address that msg.sender must be to be authorized\n    modifier authorized(address a) {\n        if (msg.sender != a) {\n            revert Exception(0, 0, 0, msg.sender, a);\n        }\n        _;\n    }\n\n    /// @notice reverts on all markets where the paused mapping returns true\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    modifier unpaused(address u, uint256 m) {\n        if (paused[u][m]) {\n            revert Exception(17, m, 0, u, address(0));\n        }\n        _;\n    }\n\n    /// @notice Initializes the Redeemer contract\n    /// @param l the lender contract\n    /// @param s the Swivel contract\n    /// @param p the Pendle contract\n    /// @param t the Tempus contract\n    constructor(\n        address l,\n        address s,\n        address p,\n        address t\n    ) {\n        admin = msg.sender;\n        lender = l;\n        swivelAddr = s;\n        pendleAddr = p;\n        tempusAddr = t;\n        feenominator = 4000;\n    }\n\n    /// @notice sets the admin address\n    /// @param a Address of a new admin\n    /// @return bool true if successful\n    function setAdmin(address a) external authorized(admin) returns (bool) {\n        admin = a;\n        emit SetAdmin(a);\n        return true;\n    }\n\n    /// @notice sets the address of the marketplace contract which contains the addresses of all the fixed rate markets\n    /// @param m the address of the marketplace contract\n    /// @return bool true if the address was set\n    function setMarketPlace(address m)\n        external\n        authorized(admin)\n        returns (bool)\n    {\n        if (marketPlace != address(0)) {\n            revert Exception(5, 0, 0, marketPlace, address(0));\n        }\n        marketPlace = m;\n        return true;\n    }\n\n    /// @notice sets the converter address\n    /// @param c address of the new converter\n    /// @return bool true if successful\n    function setConverter(address c) external authorized(admin) returns (bool) {\n        converter = c;\n        emit SetConverter(c);\n        return true;\n    }\n\n    /// @notice sets the address of the lender contract which contains the addresses of all the fixed rate markets\n    /// @param l the address of the lender contract\n    /// @return bool true if the address was set\n    function setLender(address l) external authorized(admin) returns (bool) {\n        if (lender != address(0)) {\n            revert Exception(8, 0, 0, address(lender), address(0));\n        }\n        lender = l;\n        return true;\n    }\n\n    /// @notice sets the feenominator to the given value\n    /// @param f the new value of the feenominator, fees are not collected when the feenominator is 0\n    /// @return bool true if successful\n    function setFee(uint256 f) external authorized(admin) returns (bool) {\n        uint256 feeTime = feeChange;\n        if (feeTime == 0) {\n            revert Exception(23, 0, 0, address(0), address(0));\n        } else if (feeTime < block.timestamp) {\n            revert Exception(\n                24,\n                block.timestamp,\n                feeTime,\n                address(0),\n                address(0)\n            );\n        } else if (f < MIN_FEENOMINATOR) {\n            revert Exception(25, 0, 0, address(0), address(0));\n        }\n        feenominator = f;\n        delete feeChange;\n        emit SetFee(f);\n        return true;\n    }\n\n    /// @notice allows admin to stop redemptions of Illuminate PTs for a given market\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param b true to pause, false to unpause\n    function pauseRedemptions(\n        address u,\n        uint256 m,\n        bool b\n    ) external authorized(admin) {\n        paused[u][m] = b;\n    }\n\n    /// @notice approves the converter to spend the compounding asset\n    /// @param i an interest bearing token that must be approved for conversion\n    function approve(address i) external authorized(marketPlace) {\n        if (i != address(0)) {\n            Safe.approve(IERC20(i), address(converter), type(uint256).max);\n        }\n    }\n\n    /// @notice redeem method for Swivel, Yield, Element, Pendle, APWine, Tempus and Notional protocols\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @return bool true if the redemption was successful\n    function redeem(\n        uint8 p,\n        address u,\n        uint256 m\n    ) external returns (bool) {\n        // Get the principal token that is being redeemed by the user\n        address principal = IMarketPlace(marketPlace).token(u, m, p);\n\n        // Get the maturity for the given principal token\n        uint256 maturity;\n        if (p == uint8(MarketPlace.Principals.Swivel)) {\n            maturity = ISwivelToken(principal).maturity();\n        } else if (p == uint8(MarketPlace.Principals.Yield)) {\n            maturity = IYieldToken(principal).maturity();\n        } else if (p == uint8(MarketPlace.Principals.Element)) {\n            maturity = IElementToken(principal).unlockTimestamp();\n        } else if (p == uint8(MarketPlace.Principals.Pendle)) {\n            maturity = IPendleToken(principal).expiry();\n        } else if (p == uint8(MarketPlace.Principals.Tempus)) {\n            maturity = ITempusPool(ITempusToken(principal).pool())\n                .maturityTime();\n        } else if (p == uint8(MarketPlace.Principals.Apwine)) {\n            // APWine's maturity is retrieved indirectly via the PT's\n            // futureVault and Controller\n            address futureVault = IAPWineToken(principal).futureVault();\n\n            address controller = IAPWineFutureVault(futureVault)\n                .getControllerAddress();\n\n            uint256 duration = IAPWineFutureVault(futureVault)\n                .PERIOD_DURATION();\n\n            maturity = IAPWineController(controller).getNextPeriodStart(\n                duration\n            );\n        } else if (p == uint8(MarketPlace.Principals.Notional)) {\n            maturity = INotional(principal).getMaturity();\n        } else {\n            revert Exception(6, p, 0, address(0), address(0));\n        }\n\n        // Verify that the token has matured\n        if (maturity > block.timestamp) {\n            revert Exception(7, maturity, 0, address(0), address(0));\n        }\n\n        // Cache the lender to save gas on sload\n        address cachedLender = lender;\n\n        // Get the amount to be redeemed\n        uint256 amount = IERC20(principal).balanceOf(cachedLender);\n\n        // Receive the principal token from the lender contract\n        Safe.transferFrom(\n            IERC20(principal),\n            cachedLender,\n            address(this),\n            amount\n        );\n\n        // Get the starting balance of the underlying held by the redeemer\n        uint256 starting = IERC20(u).balanceOf(address(this));\n\n        if (p == uint8(MarketPlace.Principals.Swivel)) {\n            // Redeems principal tokens from Swivel\n            if (!ISwivel(swivelAddr).redeemZcToken(u, maturity, amount)) {\n                revert Exception(15, 0, 0, address(0), address(0));\n            }\n        } else if (p == uint8(MarketPlace.Principals.Yield)) {\n            // Redeems principal tokens from Yield\n            IYieldToken(principal).redeem(address(this), amount);\n        } else if (p == uint8(MarketPlace.Principals.Element)) {\n            // Redeems principal tokens from Element\n            IElementToken(principal).withdrawPrincipal(amount, address(this));\n        } else if (p == uint8(MarketPlace.Principals.Pendle)) {\n            // Get the forge contract for the principal token\n            address forge = IPendleToken(principal).forge();\n\n            // Get the forge ID of the principal token\n            bytes32 forgeId = IPendleForge(forge).forgeId();\n\n            // Redeem the tokens from the Pendle contract\n            IPendle(pendleAddr).redeemAfterExpiry(forgeId, u, maturity);\n\n            // Get the compounding asset for this market\n            address compounding = IPendleToken(principal)\n                .underlyingYieldToken();\n\n            // Redeem the compounding to token to the underlying\n            IConverter(converter).convert(\n                compounding,\n                u,\n                IERC20(compounding).balanceOf(address(this))\n            );\n        } else if (p == uint8(MarketPlace.Principals.Tempus)) {\n            // Retrieve the pool for the principal token\n            address pool = ITempusToken(principal).pool();\n\n            // Redeems principal tokens from Tempus\n            ITempus(tempusAddr).redeemToBacking(pool, amount, 0, address(this));\n        } else if (p == uint8(MarketPlace.Principals.Apwine)) {\n            apwineWithdraw(principal, u, amount);\n        } else if (p == uint8(MarketPlace.Principals.Notional)) {\n            // Redeems principal tokens from Notional\n            INotional(principal).redeem(\n                INotional(principal).maxRedeem(address(this)),\n                address(this),\n                address(this)\n            );\n        }\n\n        // Calculate how much underlying was redeemed\n        uint256 redeemed = IERC20(u).balanceOf(address(this)) - starting;\n\n        // Update the holding for this market\n        holdings[u][m] = holdings[u][m] + redeemed;\n\n        emit Redeem(p, u, m, redeemed, msg.sender);\n        return true;\n    }\n\n    /// @notice redeem method signature for Sense\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param s Sense's maturity is needed to extract the pt address\n    /// @param a Sense's adapter for this market\n    /// @return bool true if the redemption was successful\n    function redeem(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 s,\n        address a\n    ) external returns (bool) {\n        // Check the principal is Sense\n        if (p != uint8(MarketPlace.Principals.Sense)) {\n            revert Exception(6, p, 0, address(0), address(0));\n        }\n\n        // Get Sense's principal token for this market\n        IERC20 token = IERC20(IMarketPlace(marketPlace).token(u, m, p));\n\n        // Cache the lender to save on SLOAD operations\n        address cachedLender = lender;\n\n        // Get the balance of tokens to be redeemed by the user\n        uint256 amount = token.balanceOf(cachedLender);\n\n        // Transfer the user's tokens to the redeem contract\n        Safe.transferFrom(token, cachedLender, address(this), amount);\n\n        // Get the starting balance to verify the amount received afterwards\n        uint256 starting = IERC20(u).balanceOf(address(this));\n\n        // Get the divider from the adapter\n        ISenseDivider divider = ISenseDivider(ISenseAdapter(a).divider());\n\n        // Redeem the tokens from the Sense contract\n        ISenseDivider(divider).redeem(a, s, amount);\n\n        // Get the compounding token that is redeemed by Sense\n        address compounding = ISenseAdapter(a).target();\n\n        // Redeem the compounding token back to the underlying\n        IConverter(converter).convert(\n            compounding,\n            u,\n            IERC20(compounding).balanceOf(address(this))\n        );\n\n        // Get the amount received\n        uint256 redeemed = IERC20(u).balanceOf(address(this)) - starting;\n\n        // Verify that underlying are received 1:1 - cannot trust the adapter\n        if (redeemed < amount) {\n            revert Exception(13, 0, 0, address(0), address(0));\n        }\n\n        // Update the holdings for this market\n        holdings[u][m] = holdings[u][m] + redeemed;\n\n        emit Redeem(p, u, m, redeemed, msg.sender);\n        return true;\n    }\n\n    /// @notice burns Illuminate principal tokens and sends underlying to user\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    function redeem(address u, uint256 m) external unpaused(u, m) {\n        // Get Illuminate's principal token for this market\n        IERC5095 token = IERC5095(\n            IMarketPlace(marketPlace).token(\n                u,\n                m,\n                uint8(MarketPlace.Principals.Illuminate)\n            )\n        );\n\n        // Verify the token has matured\n        if (block.timestamp < token.maturity()) {\n            revert Exception(7, block.timestamp, m, address(0), address(0));\n        }\n\n        // Get the amount of tokens to be redeemed from the sender\n        uint256 amount = token.balanceOf(msg.sender);\n\n        // Calculate how many tokens the user should receive\n        uint256 redeemed = (amount * holdings[u][m]) / token.totalSupply();\n\n        // Update holdings of underlying\n        holdings[u][m] = holdings[u][m] - redeemed;\n\n        // Burn the user's principal tokens\n        token.authBurn(msg.sender, amount);\n\n        // Transfer the original underlying token back to the user\n        Safe.transfer(IERC20(u), msg.sender, redeemed);\n\n        emit Redeem(0, u, m, redeemed, msg.sender);\n    }\n\n    /// @notice implements the redeem method for the contract to fulfill the ERC-5095 interface\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param f address from where the underlying asset will be burned\n    /// @param t address to where the underlying asset will be transferred\n    /// @param a amount of the Illuminate PT to be burned and redeemed\n    /// @return uint256 amount of the underlying asset that was burned\n    function authRedeem(\n        address u,\n        uint256 m,\n        address f,\n        address t,\n        uint256 a\n    )\n        external\n        authorized(IMarketPlace(marketPlace).token(u, m, 0))\n        returns (uint256)\n    {\n        // Get the principal token for the given market\n        IERC5095 pt = IERC5095(IMarketPlace(marketPlace).token(u, m, 0));\n\n        // Make sure the market has matured\n        uint256 maturity = pt.maturity();\n        if (block.timestamp < maturity) {\n            revert Exception(7, maturity, 0, address(0), address(0));\n        }\n\n        // Calculate the amount redeemed\n        uint256 redeemed = (a * holdings[u][m]) / pt.totalSupply();\n\n        // Update holdings of underlying\n        holdings[u][m] = holdings[u][m] - redeemed;\n\n        // Burn the user's principal tokens\n        pt.authBurn(f, a);\n\n        // Transfer the original underlying token back to the user\n        Safe.transfer(IERC20(u), t, redeemed);\n\n        emit Redeem(0, u, m, redeemed, msg.sender);\n        return a;\n    }\n\n    /// @notice implements a redeem method to enable third-party redemptions\n    /// @dev expects approvals from owners to redeemer\n    /// @param u address of the underlying asset\n    /// @param m maturity of the market\n    /// @param f address from where the principal token will be burned\n    /// @return uint256 amount of underlying yielded as a fee\n    function autoRedeem(\n        address u,\n        uint256 m,\n        address[] calldata f\n    ) external returns (uint256) {\n        // Get the principal token for the given market\n        IERC5095 pt = IERC5095(IMarketPlace(marketPlace).token(u, m, 0));\n\n        // Make sure the market has matured\n        uint256 maturity = pt.maturity();\n        if (block.timestamp < maturity) {\n            revert Exception(7, maturity, 0, address(0), address(0));\n        }\n\n        // Retrieve the underlying\n        IERC20 uToken = IERC20(u);\n\n        // Sum up the fees received by the caller\n        uint256 incentiveFee;\n\n        // Get the number of owners to loop through\n        uint256 length = f.length;\n\n        // Loop through the provided arrays and mature each individual position\n        for (uint256 i; i != length; ) {\n            // Fetch the allowance set by the holder of the principal tokens\n            uint256 allowance = uToken.allowance(f[i], address(this));\n\n            // Get the amount of tokens held by the owner\n            uint256 amount = pt.balanceOf(f[i]);\n\n            // Calculate how many tokens the user should receive\n            uint256 redeemed = (amount * holdings[u][m]) / pt.totalSupply();\n\n            // Calculate the fees to be received (currently .025%)\n            uint256 fee = redeemed / feenominator;\n\n            // Verify allowance\n            if (allowance < amount) {\n                revert Exception(20, allowance, amount, address(0), address(0));\n            }\n\n            // Burn the tokens from the user\n            pt.authBurn(f[i], amount);\n\n            // Update the holdings for this market\n            holdings[u][m] = holdings[u][m] - redeemed;\n\n            // Transfer the underlying to the user\n            Safe.transfer(uToken, f[i], redeemed - fee);\n\n            unchecked {\n                // Track the fees gained by the caller\n                incentiveFee += fee;\n\n                ++i;\n            }\n        }\n\n        // Transfer the fee to the caller\n        Safe.transfer(uToken, msg.sender, incentiveFee);\n\n        return incentiveFee;\n    }\n\n    /// @notice Execute the business logic for conducting an APWine redemption\n    function apwineWithdraw(\n        address p,\n        address u,\n        uint256 a\n    ) internal {\n        // Retrieve the vault which executes the redemption in APWine\n        address futureVault = IAPWineToken(p).futureVault();\n\n        // Retrieve the controller that will execute the withdrawal\n        address controller = IAPWineFutureVault(futureVault)\n            .getControllerAddress();\n\n        // Retrieve the next period index\n        uint256 index = IAPWineFutureVault(futureVault).getCurrentPeriodIndex();\n\n        // Get the FYT address for the current period\n        address fyt = IAPWineFutureVault(futureVault).getFYTofPeriod(index);\n\n        // Trigger claim to FYTs by executing transfer\n        // Safe.transferFrom(IERC20(fyt), address(lender), address(this), a);\n        ILender(lender).transferFYTs(fyt, a);\n\n        // Redeem the underlying token from APWine to Illuminate\n        IAPWineController(controller).withdraw(futureVault, a);\n\n        // Retrieve the interest bearing token\n        address ibt = IAPWineFutureVault(futureVault).getIBTAddress();\n\n        // Convert the interest bearing token to underlying\n        IConverter(converter).convert(\n            IAPWineFutureVault(futureVault).getIBTAddress(),\n            u,\n            IERC20(ibt).balanceOf(address(this))\n        );\n    }\n}"
    },
    {
      "filename": "src/Redeemer.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.16;\n\nimport 'src/MarketPlace.sol';\n\nimport 'src/lib/Safe.sol';\nimport 'src/errors/Exception.sol';\n\nimport 'src/interfaces/IERC5095.sol';\nimport 'src/interfaces/IERC20.sol';\nimport 'src/interfaces/ITempus.sol';\nimport 'src/interfaces/ITempusPool.sol';\nimport 'src/interfaces/ITempusToken.sol';\nimport 'src/interfaces/IAPWine.sol';\nimport 'src/interfaces/IAPWineController.sol';\nimport 'src/interfaces/IAPWineFutureVault.sol';\nimport 'src/interfaces/IAPWineToken.sol';\nimport 'src/interfaces/IAPWineAMMPool.sol';\nimport 'src/interfaces/ISwivel.sol';\nimport 'src/interfaces/ISwivelToken.sol';\nimport 'src/interfaces/IElementToken.sol';\nimport 'src/interfaces/IYieldToken.sol';\nimport 'src/interfaces/INotional.sol';\nimport 'src/interfaces/IPendle.sol';\nimport 'src/interfaces/IPendleForge.sol';\nimport 'src/interfaces/IPendleToken.sol';\nimport 'src/interfaces/ISenseDivider.sol';\nimport 'src/interfaces/ISenseAdapter.sol';\nimport 'src/interfaces/IYield.sol';\nimport 'src/interfaces/IConverter.sol';\n\nimport 'forge-std/Test.sol';\n\n/// @title Redeemer\n/// @author Sourabh Marathe, Julian Traversa, Rob Robbins\n/// @notice The Redeemer contract is used to redeem the underlying lent capital of a loan.\n/// @notice Users may redeem their ERC-5095 tokens for the underlying asset represented by that token after maturity.\ncontract Redeemer {\n    /// @notice address that is allowed to set fees and contracts, etc. It is commonly used in the authorized modifier.\n    address public admin;\n    /// @notice address of the MarketPlace contract, used to access the markets mapping\n    address public marketPlace;\n    /// @notice address that custodies principal tokens for all markets\n    address public lender;\n    /// @notice address that converts compounding tokens to their underlying\n    address public converter;\n\n    /// @notice third party contract needed to redeem Swivel PTs\n    address public immutable swivelAddr;\n    /// @notice third party contract needed to redeem Pendle PTs\n    address public immutable pendleAddr;\n    /// @notice third party contract needed to redeem Tempus PTs\n    address public immutable tempusAddr;\n\n    /// @notice this value determines the amount of fees paid on auto redemptions\n    uint256 public feenominator;\n    /// @notice represents a point in time where the feenominator may change\n    uint256 public feeChange;\n    /// @notice represents a minimum that the feenominator must exceed\n    uint256 public MIN_FEENOMINATOR = 500;\n\n    /// @notice mapping that indicates how much underlying has been redeemed by a market\n    mapping(address => mapping(uint256 => uint256)) public holdings;\n    /// @notice mapping that determines if a market's iPT can be redeemed\n    mapping(address => mapping(uint256 => bool)) public paused;\n\n    /// @notice emitted upon redemption of a loan\n    event Redeem(\n        uint8 principal,\n        address indexed underlying,\n        uint256 indexed maturity,\n        uint256 amount,\n        address sender\n    );\n    /// @notice emitted upon changing the admin\n    event SetAdmin(address indexed admin);\n    /// @notice emitted upon changing the converter\n    event SetConverter(address indexed converter);\n    /// @notice emitted upon setting the fee rate\n    event SetFee(uint256 indexed fee);\n\n    /// @notice ensures that only a certain address can call the function\n    /// @param a address that msg.sender must be to be authorized\n    modifier authorized(address a) {\n        if (msg.sender != a) {\n            revert Exception(0, 0, 0, msg.sender, a);\n        }\n        _;\n    }\n\n    /// @notice reverts on all markets where the paused mapping returns true\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    modifier unpaused(address u, uint256 m) {\n        if (paused[u][m]) {\n            revert Exception(17, m, 0, u, address(0));\n        }\n        _;\n    }\n\n    /// @notice Initializes the Redeemer contract\n    /// @param l the lender contract\n    /// @param s the Swivel contract\n    /// @param p the Pendle contract\n    /// @param t the Tempus contract\n    constructor(\n        address l,\n        address s,\n        address p,\n        address t\n    ) {\n        admin = msg.sender;\n        lender = l;\n        swivelAddr = s;\n        pendleAddr = p;\n        tempusAddr = t;\n        feenominator = 4000;\n    }\n\n    /// @notice sets the admin address\n    /// @param a Address of a new admin\n    /// @return bool true if successful\n    function setAdmin(address a) external authorized(admin) returns (bool) {\n        admin = a;\n        emit SetAdmin(a);\n        return true;\n    }\n\n    /// @notice sets the address of the marketplace contract which contains the addresses of all the fixed rate markets\n    /// @param m the address of the marketplace contract\n    /// @return bool true if the address was set\n    function setMarketPlace(address m)\n        external\n        authorized(admin)\n        returns (bool)\n    {\n        if (marketPlace != address(0)) {\n            revert Exception(5, 0, 0, marketPlace, address(0));\n        }\n        marketPlace = m;\n        return true;\n    }\n\n    /// @notice sets the converter address\n    /// @param c address of the new converter\n    /// @return bool true if successful\n    function setConverter(address c) external authorized(admin) returns (bool) {\n        converter = c;\n        emit SetConverter(c);\n        return true;\n    }\n\n    /// @notice sets the address of the lender contract which contains the addresses of all the fixed rate markets\n    /// @param l the address of the lender contract\n    /// @return bool true if the address was set\n    function setLender(address l) external authorized(admin) returns (bool) {\n        if (lender != address(0)) {\n            revert Exception(8, 0, 0, address(lender), address(0));\n        }\n        lender = l;\n        return true;\n    }\n\n    /// @notice sets the feenominator to the given value\n    /// @param f the new value of the feenominator, fees are not collected when the feenominator is 0\n    /// @return bool true if successful\n    function setFee(uint256 f) external authorized(admin) returns (bool) {\n        uint256 feeTime = feeChange;\n        if (feeTime == 0) {\n            revert Exception(23, 0, 0, address(0), address(0));\n        } else if (feeTime < block.timestamp) {\n            revert Exception(\n                24,\n                block.timestamp,\n                feeTime,\n                address(0),\n                address(0)\n            );\n        } else if (f < MIN_FEENOMINATOR) {\n            revert Exception(25, 0, 0, address(0), address(0));\n        }\n        feenominator = f;\n        delete feeChange;\n        emit SetFee(f);\n        return true;\n    }\n\n    /// @notice allows admin to stop redemptions of Illuminate PTs for a given market\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param b true to pause, false to unpause\n    function pauseRedemptions(\n        address u,\n        uint256 m,\n        bool b\n    ) external authorized(admin) {\n        paused[u][m] = b;\n    }\n\n    /// @notice approves the converter to spend the compounding asset\n    /// @param i an interest bearing token that must be approved for conversion\n    function approve(address i) external authorized(marketPlace) {\n        if (i != address(0)) {\n            Safe.approve(IERC20(i), address(converter), type(uint256).max);\n        }\n    }\n\n    /// @notice redeem method for Swivel, Yield, Element, Pendle, APWine, Tempus and Notional protocols\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @return bool true if the redemption was successful\n    function redeem(\n        uint8 p,\n        address u,\n        uint256 m\n    ) external returns (bool) {\n        // Get the principal token that is being redeemed by the user\n        address principal = IMarketPlace(marketPlace).token(u, m, p);\n\n        // Get the maturity for the given principal token\n        uint256 maturity;\n        if (p == uint8(MarketPlace.Principals.Swivel)) {\n            maturity = ISwivelToken(principal).maturity();\n        } else if (p == uint8(MarketPlace.Principals.Yield)) {\n            maturity = IYieldToken(principal).maturity();\n        } else if (p == uint8(MarketPlace.Principals.Element)) {\n            maturity = IElementToken(principal).unlockTimestamp();\n        } else if (p == uint8(MarketPlace.Principals.Pendle)) {\n            maturity = IPendleToken(principal).expiry();\n        } else if (p == uint8(MarketPlace.Principals.Tempus)) {\n            maturity = ITempusPool(ITempusToken(principal).pool())\n                .maturityTime();\n        } else if (p == uint8(MarketPlace.Principals.Apwine)) {\n            // APWine's maturity is retrieved indirectly via the PT's\n            // futureVault and Controller\n            address futureVault = IAPWineToken(principal).futureVault();\n\n            address controller = IAPWineFutureVault(futureVault)\n                .getControllerAddress();\n\n            uint256 duration = IAPWineFutureVault(futureVault)\n                .PERIOD_DURATION();\n\n            maturity = IAPWineController(controller).getNextPeriodStart(\n                duration\n            );\n        } else if (p == uint8(MarketPlace.Principals.Notional)) {\n            maturity = INotional(principal).getMaturity();\n        } else {\n            revert Exception(6, p, 0, address(0), address(0));\n        }\n\n        // Verify that the token has matured\n        if (maturity > block.timestamp) {\n            revert Exception(7, maturity, 0, address(0), address(0));\n        }\n\n        // Cache the lender to save gas on sload\n        address cachedLender = lender;\n\n        // Get the amount to be redeemed\n        uint256 amount = IERC20(principal).balanceOf(cachedLender);\n\n        // Receive the principal token from the lender contract\n        Safe.transferFrom(\n            IERC20(principal),\n            cachedLender,\n            address(this),\n            amount\n        );\n\n        // Get the starting balance of the underlying held by the redeemer\n        uint256 starting = IERC20(u).balanceOf(address(this));\n\n        if (p == uint8(MarketPlace.Principals.Swivel)) {\n            // Redeems principal tokens from Swivel\n            if (!ISwivel(swivelAddr).redeemZcToken(u, maturity, amount)) {\n                revert Exception(15, 0, 0, address(0), address(0));\n            }\n        } else if (p == uint8(MarketPlace.Principals.Yield)) {\n            // Redeems principal tokens from Yield\n            IYieldToken(principal).redeem(address(this), amount);\n        } e"
    }
  ]
}