{
  "Title": "[N-16] setMaxAllowance should be called in the constructor",
  "Content": "\n### BeefyVaultOperator.sol\n\n**deposit: setMaxAllowance should be called in the constructor**\n\nIn the `deposit` function on [line 48](https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/operators/Beefy/BeefyVaultOperator.sol#L48), we call `ExchangeHelpers.setMaxAllowance(token, vault);` to allow the vault to spend token.<br>\n\nEach time assets are deposited in the vault, we shouldn't have to allow it to spend the token again.<br>\n\nI recommend to call `ExchangeHelpers.setMaxAllowance(token, vault)` only once in the constructor for each vault and token. I also recommend to add a `setMaxAllowance` function only callable by the owner of the operator that would allow to set the max allowance in case the allowance has decreased.\n\n**Recommendation**\n\n```solidity\nfor (uint256 i; i < vaultsLength; i++) {\n    operatorStorage.addVault(vaults[i], tokens[i]);\n    ExchangeHelpers.setMaxAllowance(tokens[i], vaults[i]);\n}\n```\n\n### BeefyZapBiswapLPVaultOperator.sol and BeefyZapUniswapLPVaultOperator.sol\n\n**zapAndStakeLp: setMaxAllowance should be called in the constructor**\n\nIn the `_zapAndStakeLp` function on [line 189](https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L189) and subsequently on [line 194](https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L194) and [195](https://github.com/code-423n4/2022-06-nested/blob/b253ed80f67d1bb2a04e1702f5796fd96a7c521e/contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol#L195) we call `ExchangeHelpers.setMaxAllowance();` to allow the vault to spend token.\n\nEach time assets are deposited in the vault, we shouldn't have to allow it to spend the token again.<br>\nI recommend to call `ExchangeHelpers.setMaxAllowance()` only once in the constructor for each vault and token. I also recommend to add a setMaxAllowance function only callable by the owner of the operator that would allow to set the max allowance in case the allowance has decreased.\n\nThis will also avoid calling `ExchangeHelpers.setMaxAllowance(IERC20(swapToken), router);` in the `_withdrawAndSwap` function on line 162.\n\n**Recommendation**\n\n```solidity\nfor (uint256 i; i < vaultsLength; i++) {\n    operatorStorage.addVault(vaults[i], routers[i]);\n\n    IBiswapPair pair = IBiswapPair(IBeefyVaultV6(vaults[i]).want());\n\n    ExchangeHelpers.setMaxAllowance(IERC20(address(pair)), address(vaults[i]));\n    ExchangeHelpers.setMaxAllowance(IERC20(pair.token0()), routers[i]);\n    ExchangeHelpers.setMaxAllowance(IERC20(pair.token1()), routers[i]);\n}\n```\n\n### YearnCurveVaultOperator.sol\n\n**depositETH: setMaxAllowance should be called in the constructor**\n\nIn the `depositETH` function on line [78](https://github.com/code-423n4/2022-06-nested/blob/0dc44d779eaca8f40b7526aabdd81a098dcebf25/contracts/operators/Yearn/YearnCurveVaultOperator.sol#L78), we call `ExchangeHelpers.setMaxAllowance(IERC20(address(weth)), address(withdrawer));` to allow the withdrawer to spend weth.\n\nEach time assets are deposited in the vault, we shouldn't have to allow the withdrawer to spend weth again.<br>\nI recommend to call `ExchangeHelpers.setMaxAllowance(IERC20(address(weth)), address(withdrawer))` only once in the constructor. I also recommend to add a `setMaxAllowance` function only callable by the owner of the operator that would allow to set the max allowance in case the allowance has decreased.\n\n**Recommendation**\n\n```solidity\nExchangeHelpers.setMaxAllowance(IERC20(_weth), address(_withdrawer));\n```\n\n### StakingLPVaultHelpers.sol\n\n**addLiquidityAndDepositETH: setMaxAllowance should be called in addVault**\n\nIn the `addLiquidityAndDepositETH` function on [line 45](https://github.com/code-423n4/2022-06-nested/blob/0dc44d779eaca8f40b7526aabdd81a098dcebf25/contracts/libraries/StakingLPVaultHelpers.sol#L45), we call `ExchangeHelpers.setMaxAllowance(lpToken, vault);` to allow the vault to spend lpToken.\n\nEach time assets are deposited in the vault, we shouldn't have to allow the vault to spend lpToken again.<br>\nI recommend to call `ExchangeHelpers.setMaxAllowance(lpToken, vault);` only once in the addVault function of the YearnVaultStorage. I also recommend to add a setMaxAllowance function only callable by the owner that would allow to set the max allowance in case the allowance has decreased.\n\nThis will also avoid calling it in the `_addLiquidityAndDeposit` function on line [77](https://github.com/code-423n4/2022-06-nested/blob/0dc44d779eaca8f40b7526aabdd81a098dcebf25/contracts/libraries/StakingLPVaultHelpers.sol#L77)\n\n**Recommendation**\n\n```solidity\nExchangeHelpers.setMaxAllowance(curvePool.lpToken, vault);\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-06-nested",
  "Code": [
    {
      "filename": "contracts/operators/Beefy/BeefyVaultOperator.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"./BeefyVaultStorage.sol\";\nimport \"./../../libraries/ExchangeHelpers.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title Beefy Single Vault Operator\n/// @notice Deposit/Withdraw in a Beefy vault (native or non-native).\ncontract BeefyVaultOperator {\n    BeefyVaultStorage public immutable operatorStorage;\n\n    constructor(address[] memory vaults, address[] memory tokens) {\n        uint256 vaultsLength = vaults.length;\n        require(vaultsLength == tokens.length, \"BVO: INVALID_VAULTS_LENGTH\");\n        operatorStorage = new BeefyVaultStorage();\n\n        for (uint256 i; i < vaultsLength; i++) {\n            operatorStorage.addVault(vaults[i], tokens[i]);\n        }\n\n        operatorStorage.transferOwnership(msg.sender);\n    }\n\n    /// @notice Deposit the asset in the Beefy vault and receive\n    ///         the vault token (moo).\n    /// @param vault The vault address to deposit into\n    /// @param amount The token amount to deposit\n    /// @param minVaultAmount The minimum vault token amount expected\n    /// @return amounts Array of amounts :\n    ///         - [0] : The vault token received amount\n    ///         - [1] : The token deposited amount\n    /// @return tokens Array of token addresses\n    ///         - [0] : The vault token received address\n    ///         - [1] : The token deposited address\n    function deposit(\n        address vault,\n        uint256 amount,\n        uint256 minVaultAmount\n    ) external payable returns (uint256[] memory amounts, address[] memory tokens) {\n        require(amount != 0, \"BVO: INVALID_AMOUNT\");\n        IERC20 token = IERC20(operatorStorage.vaults(vault));\n        require(address(token) != address(0), \"BVO: INVALID_VAULT\");\n\n        uint256 vaultBalanceBefore = IERC20(vault).balanceOf(address(this));\n        uint256 tokenBalanceBefore = token.balanceOf(address(this));\n\n        ExchangeHelpers.setMaxAllowance(token, vault);\n        (bool success, ) = vault.call(abi.encodeWithSignature(\"deposit(uint256)\", amount));\n        require(success, \"BVO: DEPOSIT_CALL_FAILED\");\n\n        uint256 vaultAmount = IERC20(vault).balanceOf(address(this)) - vaultBalanceBefore;\n        uint256 tokenAmount = tokenBalanceBefore - token.balanceOf(address(this));\n        require(vaultAmount != 0 && vaultAmount >= minVaultAmount, \"BVO: INVALID_AMOUNT_RECEIVED\");\n        require(amount == tokenAmount, \"BVO: INVALID_AMOUNT_DEPOSITED\");\n\n        amounts = new uint256[](2);\n        tokens = new address[](2);\n\n        // Output amounts\n        amounts[0] = vaultAmount;\n        amounts[1] = tokenAmount;\n\n        // Output token\n        tokens[0] = vault;\n        tokens[1] = address(token);\n    }\n\n    /// @notice Withdraw the vault token (moo) from Beefy and receive\n    ///         the underlying token.\n    /// @param vault The vault address to withdraw from\n    /// @param amount The vault token amount to withdraw\n    /// @return amounts Array of amounts :\n    ///         - [0] : The token received amount\n    ///         - [1] : The vault token deposited amount\n    /// @return tokens Array of token addresses\n    ///         - [0] : The token received address\n    ///         - [1] : The vault token deposited address\n    function withdraw(address vault, uint256 amount)\n        external\n        returns (uint256[] memory amounts, address[] memory tokens)\n    {\n        require(amount != 0, \"BVO: INVALID_AMOUNT\");\n        IERC20 token = IERC20(operatorStorage.vaults(vault));\n        require(address(token) != address(0), \"BVO: INVALID_VAULT\");\n\n        uint256 tokenBalanceBefore = token.balanceOf(address(this));\n        uint256 vaultBalanceBefore = IERC20(vault).balanceOf(address(this));\n\n        (bool success, ) = vault.call(abi.encodeWithSignature(\"withdraw(uint256)\", amount));\n        require(success, \"BVO: WITHDRAW_CALL_FAILED\");\n\n        uint256 tokenAmount = token.balanceOf(address(this)) - tokenBalanceBefore;\n        uint256 vaultAmount = vaultBalanceBefore - IERC20(vault).balanceOf(address(this));\n        require(vaultAmount == amount, \"BVO: INVALID_AMOUNT_WITHDRAWED\");\n        require(tokenAmount != 0, \"BVO: INVALID_AMOUNT\");\n\n        amounts = new uint256[](2);\n        tokens = new address[](2);\n\n        // Output amounts\n        amounts[0] = tokenAmount;\n        amounts[1] = amount;\n\n        // Output token\n        tokens[0] = address(token);\n        tokens[1] = vault;\n    }\n}"
    },
    {
      "filename": "contracts/operators/Beefy/lp/BeefyZapBiswapLPVaultOperator.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"../BeefyVaultStorage.sol\";\nimport \"./../../../libraries/ExchangeHelpers.sol\";\nimport \"./../../../interfaces/external/IBeefyVaultV6.sol\";\nimport \"./../../../interfaces/external/IBiswapRouter02.sol\";\nimport \"./../../../interfaces/external/IBiswapPair.sol\";\nimport \"@uniswap/lib/contracts/libraries/Babylonian.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @title (Zapper) Beefy Biswap LP Vault Operator.\n/// @notice Deposit/Withdraw in a Beefy Biswap LP vault using zapper\n/// Note: \"Zap\" means that the asset is converted for the LP Token by\n///       swapping and adding liquidity.\ncontract BeefyZapBiswapLPVaultOperator {\n    using SafeERC20 for IERC20;\n\n    BeefyVaultStorage public immutable operatorStorage;\n\n    constructor(address[] memory vaults, address[] memory routers) {\n        uint256 vaultsLength = vaults.length;\n        require(vaultsLength == routers.length, \"BLVO: INVALID_VAULTS_LENGTH\");\n\n        operatorStorage = new BeefyVaultStorage();\n\n        for (uint256 i; i < vaultsLength; i++) {\n            operatorStorage.addVault(vaults[i], routers[i]);\n        }\n\n        operatorStorage.transferOwnership(msg.sender);\n    }\n\n    /// @notice Zap one of the paired tokens for the LP Token, deposit the\n    ///         asset in the Beefy vault and receive the vault token (moo).\n    /// @param vault The vault address to deposit into\n    /// @param token The token to zap\n    /// @param amountToDeposit The token amount to deposit\n    /// @param minVaultAmount The minimum vault token amount expected\n    /// @return amounts Array of amounts :\n    ///         - [0] : The vault token received amount\n    ///         - [1] : The token deposited amount\n    /// @return tokens Array of token addresses\n    ///         - [0] : The vault token received address\n    ///         - [1] : The token deposited address\n    function deposit(\n        address vault,\n        IERC20 token,\n        uint256 amountToDeposit,\n        uint256 minVaultAmount\n    ) external payable returns (uint256[] memory amounts, address[] memory tokens) {\n        require(amountToDeposit != 0, \"BLVO: INVALID_AMOUNT\");\n        address router = operatorStorage.vaults(vault);\n        require(router != address(0), \"BLVO: INVALID_VAULT\");\n\n        uint256 vaultBalanceBefore = IERC20(vault).balanceOf(address(this));\n        uint256 tokenBalanceBefore = token.balanceOf(address(this));\n\n        _zapAndStakeLp(router, IBeefyVaultV6(vault), address(token), amountToDeposit);\n\n        uint256 vaultAmount = IERC20(vault).balanceOf(address(this)) - vaultBalanceBefore;\n        uint256 depositedAmount = tokenBalanceBefore - token.balanceOf(address(this));\n\n        require(vaultAmount != 0 && vaultAmount >= minVaultAmount, \"BLVO: INVALID_AMOUNT_RECEIVED\");\n        require(depositedAmount != 0 && amountToDeposit >= depositedAmount, \"BLVO: INVALID_AMOUNT_DEPOSITED\");\n\n        amounts = new uint256[](2);\n        tokens = new address[](2);\n\n        // Output amounts\n        amounts[0] = vaultAmount;\n        amounts[1] = depositedAmount;\n\n        // Output token\n        tokens[0] = vault;\n        tokens[1] = address(token);\n    }\n\n    /// @notice Withdraw the vault token (moo) from Beefy and receive\n    ///         one of the paired tokens\n    /// @param vault The vault address to withdraw from\n    /// @param amount The vault token amount to withdraw\n    /// @param token One of the paired token\n    /// @param minTokenAmount The minimum token amount expected\n    /// @return amounts Array of amounts :\n    ///         - [0] : The token received amount\n    ///         - [1] : The vault token deposited amount\n    /// @return tokens Array of token addresses\n    ///         - [0] : The token received address\n    ///         - [1] : The vault token deposited address\n    function withdraw(\n        address vault,\n        uint256 amount,\n        IERC20 token,\n        uint256 minTokenAmount\n    ) external returns (uint256[] memory amounts, address[] memory tokens) {\n        require(amount != 0, \"BLVO: INVALID_AMOUNT\");\n        address router = operatorStorage.vaults(vault);\n        require(router != address(0), \"BLVO: INVALID_VAULT\");\n\n        uint256 tokenBalanceBefore = token.balanceOf(address(this));\n        uint256 vaultBalanceBefore = IERC20(vault).balanceOf(address(this));\n\n        _withdrawAndSwap(router, vault, amount, address(token));\n\n        uint256 tokenAmount = token.balanceOf(address(this)) - tokenBalanceBefore;\n        uint256 vaultAmount = vaultBalanceBefore - IERC20(vault).balanceOf(address(this));\n        require(vaultAmount == amount, \"BLVO: INVALID_AMOUNT_WITHDRAWED\");\n        require(tokenAmount >= minTokenAmount, \"BLVO: INVALID_OUTPUT_AMOUNT\");\n\n        amounts = new uint256[](2);\n        tokens = new address[](2);\n\n        // Output amounts\n        amounts[0] = tokenAmount;\n        amounts[1] = amount;\n\n        // Output token\n        tokens[0] = address(token);\n        tokens[1] = vault;\n    }\n\n    /// @notice Perform a vault token withdraw (moo) from Beefy, and\n    ///         transfer the rest as one of the paired token\n    /// @param router The Uniswap v2 router address to use for swapping and adding liquidity\n    /// @param vault The vault address to withdraw from\n    /// @param amount The vault token amount to withdraw\n    /// @param token One of the paired token\n    function _withdrawAndSwap(\n        address router,\n        address vault,\n        uint256 amount,\n        address token\n    ) private {\n        address pair = IBeefyVaultV6(vault).want();\n\n        uint256 pairBalanceBefore = IERC20(pair).balanceOf(address(this));\n        IBeefyVaultV6(vault).withdraw(amount);\n\n        address token0 = IUniswapV2Pair(pair).token0();\n        address token1 = IUniswapV2Pair(pair).token1();\n        require(token0 == token || token1 == token, \"BLVO: INVALID_TOKEN\");\n\n        // LP Tokens needs to be sent back to the pair address to be burned\n        IERC20(pair).safeTransfer(pair, IERC20(pair).balanceOf(address(this)) - pairBalanceBefore);\n\n        // Remove liquidity by burning the LP Token and not\n        // by calling `removeLiquidity` since we are checking the final\n        // output amount (minTokenAmount).\n        (uint256 amount0, uint256 amount1) = IUniswapV2Pair(pair).burn(address(this));\n        uint256 tokenAmountIn;\n\n        address swapToken;\n        if (token1 == token) {\n            swapToken = token0;\n            tokenAmountIn = amount0;\n        } else {\n            swapToken = token1;\n            tokenAmountIn = amount1;\n        }\n\n        ExchangeHelpers.setMaxAllowance(IERC20(swapToken), router);\n\n        address[] memory path = new address[](2);\n        path[0] = swapToken;\n        path[1] = token;\n\n        // Slippage 100% since we are checking the final amount (minTokenAmount) for the slippage\n        IBiswapRouter02(router).swapExactTokensForTokens(tokenAmountIn, 0, path, address(this), block.timestamp);\n    }\n\n    /// @dev Zap one of the paired tokens for the LP Token, deposit the\n    ///         asset in the Beefy vault and receive the vault token (moo)\n    /// @param router The Uniswap v2 router address to use for swapping and adding liquidity\n    /// @param vault The vault address to deposit into\n    /// @param token The token to zap\n    /// @param amount The token amount to deposit\n    function _zapAndStakeLp(\n        address router,\n        IBeefyVaultV6 vault,\n        address token,\n        uint256 amount\n    ) private {\n        IBiswapRouter02 biswapRouter = IBiswapRouter02(router);\n        IBiswapPair pair = IBiswapPair(vault.want());\n\n        require(pair.factory() == biswapRouter.factory(), \"BLVO: INVALID_VAULT\");\n\n        ExchangeHelpers.setMaxAllowance(IERC20(address(pair)), address(vault));\n\n        address cachedToken0 = pair.token0();\n        address cachedToken1 = pair.token1();\n\n        ExchangeHelpers.setMaxAllowance(IERC20(cachedToken0), router);\n        ExchangeHelpers.setMaxAllowance(IERC20(cachedToken1), router);\n\n        bool isInput0 = cachedToken0 == token;\n        require(isInput0 || cachedToken1 == token, \"BLVO: INVALID_INPUT_TOKEN\");\n\n        address[] memory path = new address[](2);\n        path[0] = token;\n\n        if (isInput0) {\n            path[1] = cachedToken1;\n        } else {\n            path[1] = cachedToken0;\n        }\n\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n\n        // The amount of input token to swap\n        // to get the same value of output token\n        uint256 swapAmountIn;\n        if (isInput0) {\n            swapAmountIn = _getOptimalSwapAmount(amount, reserve0, reserve1, biswapRouter, pair);\n        } else {\n            swapAmountIn = _getOptimalSwapAmount(amount, reserve1, reserve0, biswapRouter, pair);\n        }\n\n        uint256 lpAmount = _swapAndAddLiquidity(amount, swapAmountIn, path, biswapRouter);\n        vault.deposit(lpAmount);\n    }\n\n    /// @dev Swap input tokenA into TokenB to get the same value in tokenA\n    ///         as in tokenB to then add liquidity and store the obtained LP\n    ///         token in the vault beefy.\n    /// Note : path.length must be equal to 2 with path[0] = tokenA and path[1] = tokenB\n    /// @param amount The amount of tokenA to invest\n    /// @param swapAmountIn The amount of tokenA to swap for tokenB\n    /// @param path An array of the two paired token addresses\n    /// @param biswapRouter The uniswapV2 router to be used for swap and liquidity addition\n    function _swapAndAddLiquidity(\n        uint256 amount,\n        uint256 swapAmountIn,\n        address[] memory path,\n        IBiswapRouter02 biswapRouter\n    ) private returns (uint256 mintedLpAmount) {\n        uint256[] memory swappedAmounts = biswapRouter.swapExactTokensForTokens(\n            swapAmountIn,\n            1,\n            path,\n            address(this),\n            block.timestamp\n        );\n\n        (, , mintedLpAmount) = biswapRouter.addLiquidity(\n            path[0],\n            path[1],\n            amount - swappedAmounts[0],\n            swappedAmounts[1],\n            1,\n            1,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    /// @dev Calculate the optimal amount of tokenA to swap to obtain\n    ///         the same market value of tokenB after the trade.\n    ///         This allows to add as many tokensA and tokensB as possible\n    ///         to the liquidity to minimize the remaining amount.\n    /// @param investmentA The total amount of tokenA to invest\n    /// @param pair The IBiswapPair to be used\n    function _getOptimalSwapAmount(\n        uint256 investmentA,\n        uint256 reserveA,\n        uint256 reserveB,\n        IBiswapRouter02 router,\n        IBiswapPair pair\n    ) private view returns (uint256 swapAmount) {\n        require(reserveA > 1000, \"BLVO: PAIR_RESERVE_TOO_LOW\");\n        require(reserveB > 1000, \"BLVO: PAIR_RESERVE_TOO_LOW\");\n\n        // The initial plan is to swap half of tokenA total amount to add liquidity\n        uint256 halfInvestment = investmentA / 2;\n\n        // Get the tokenB output for swapping tokenA (with the given reserves)\n        uint256 nominator = router.getAmountOut(halfInvestment, reserveA, reserveB, pair.swapFee());\n\n        // Get the amount of reserveB token representing equivalent value after swapping\n        // tokenA for tokenB (previous operation).\n        uint256 denominator = router.quote(halfInvestment, reserveA + halfInvestment, reserveB - nominator);\n\n        // Equivalent of the simplification of a quadratic equation (ax² + bx + c = 0)\n        // See : \"optimal swap amount\" in readme\n        swapAmount = investmentA - Babylonian.sqrt((halfInvestment * halfInvestment * nominator) / denominator);\n    }\n}"
    },
    {
      "filename": "contracts/operators/Yearn/YearnCurveVaultOperator.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"./../../Withdrawer.sol\";\nimport \"./YearnVaultStorage.sol\";\n\nimport \"./../../libraries/OperatorHelpers.sol\";\nimport \"./../../libraries/ExchangeHelpers.sol\";\nimport \"./../../interfaces/external/IWETH.sol\";\nimport \"../../libraries/StakingLPVaultHelpers.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./../../libraries/CurveHelpers/CurveHelpers.sol\";\nimport \"./../../interfaces/external/ICurvePool/ICurvePoolETH.sol\";\nimport \"./../../interfaces/external/IStakingVault/IYearnVault.sol\";\nimport \"./../../interfaces/external/ICurvePool/ICurvePoolNonETH.sol\";\n\n/// @title Yearn Curve Vault Operator\n/// @notice Deposit/Withdraw in a Yearn Curve vault.\ncontract YearnCurveVaultOperator {\n    YearnVaultStorage public immutable operatorStorage;\n\n    /// @dev ETH address\n    address public immutable eth;\n\n    /// @dev WETH contract\n    IWETH private immutable weth;\n\n    /// @dev Withdrawer\n    Withdrawer private immutable withdrawer;\n\n    constructor(\n        address[] memory vaults,\n        CurvePool[] memory pools,\n        Withdrawer _withdrawer,\n        address _eth,\n        address _weth\n    ) {\n        uint256 vaultsLength = vaults.length;\n        require(vaultsLength == pools.length, \"YCVO: INVALID_VAULTS_LENGTH\");\n        operatorStorage = new YearnVaultStorage();\n\n        for (uint256 i; i < vaultsLength; i++) {\n            operatorStorage.addVault(vaults[i], pools[i]);\n        }\n\n        operatorStorage.transferOwnership(msg.sender);\n\n        eth = _eth;\n        weth = IWETH(_weth);\n        withdrawer = _withdrawer;\n    }\n\n    /// @notice Add liquidity in a Curve pool that includes ETH,\n    ///         deposit the LP token in a Yearn vault and receive\n    ///         the Yearn vault shares\n    /// @param vault The Yearn vault address to deposit into\n    /// @param amount The amount of token to add liquidity\n    /// @param minVaultAmount The minimum of Yearn vault shares expected\n    /// @return amounts Array of amounts :\n    ///         - [0] : The vault token received amount\n    ///         - [1] : The token deposited amount\n    /// @return tokens Array of token addresses\n    ///         - [0] : The vault token received address\n    ///         - [1] : The token deposited address\n    function depositETH(\n        address vault,\n        uint256 amount,\n        uint256 minVaultAmount\n    ) external payable returns (uint256[] memory amounts, address[] memory tokens) {\n        require(amount != 0, \"YCVO: INVALID_AMOUNT\");\n\n        (address pool, uint96 poolCoinAmount, address lpToken) = operatorStorage.vaults(vault);\n        require(pool != address(0), \"YCVO: INVALID_VAULT\");\n\n        uint256 vaultBalanceBefore = IERC20(vault).balanceOf(address(this));\n        uint256 ethBalanceBefore = weth.balanceOf(address(this));\n\n        ExchangeHelpers.setMaxAllowance(IERC20(address(weth)), address(withdrawer));\n\n        // withdraw ETH from WETH\n        withdrawer.withdraw(amount);\n\n        StakingLPVaultHelpers._addLiquidityAndDepositETH(\n            vault,\n            ICurvePoolETH(pool),\n            IERC20(lpToken),\n            poolCoinAmount,\n            eth,\n            amount\n        );\n\n        (amounts, tokens) = OperatorHelpers.getOutputAmounts(\n            IERC20(address(weth)),\n            ethBalanceBefore,\n            amount,\n            IERC20(vault),\n            vaultBalanceBefore,\n            minVaultAmount\n        );\n    }\n\n    /// @notice Add liquidity in a Curve pool, deposit\n    ///         the LP token in a Yearn vault and receive\n    ///         the Yearn vault shares\n    /// @param vault The Yearn vault address to deposit into\n    /// @param token The token to add liquidity\n    /// @param amount The amount of token to add liquidity\n    /// @param minVaultAmount The minimum of Yearn vault shares expected\n    /// @return amounts Array of amounts :\n    ///         - [0] : The vault token received amount\n    ///         - [1] : The token deposited amount\n    /// @return tokens Array of token addresses\n    ///         - [0] : The vault token received address\n    ///         - [1] : The token deposited address\n    function deposit(\n        address vault,\n        address token,\n        uint256 amount,\n        uint256 minVaultAmount\n    ) external payable returns (uint256[] memory amounts, address[] memory tokens) {\n        require(amount != 0, \"YCVO: INVALID_AMOUNT\");\n        (address pool, uint96 poolCoinAmount, address lpToken) = operatorStorage.vaults(vault);\n        require(pool != address(0), \"YCVO: INVALID_VAULT\");\n\n        uint256 vaultBalanceBefore = IERC20(vault).balanceOf(address(this));\n        uint256 tokenBalanceBefore = IERC20(token).balanceOf(address(this));\n\n        StakingLPVaultHelpers._addLiquidityAndDeposit(\n            vault,\n            ICurvePoolNonETH(pool),\n            IERC20(lpToken),\n            poolCoinAmount,\n            token,\n            amount\n        );\n\n        (amounts, tokens) = OperatorHelpers.getOutputAmounts(\n            IERC20(token),\n            tokenBalanceBefore,\n            amount,\n            IERC20(vault),\n            vaultBalanceBefore,\n            minVaultAmount\n        );\n    }\n\n    /// @notice Withdraw the LP token from the Yearn vault,\n    ///         remove ETH liquidity from the Curve pool\n    ///         and receive one of the curve pool token\n    /// @param vault The Yearn vault address to withdraw from\n    /// @param amount The amount to withdraw\n    /// @param minAmountOut The minimum of output token expected\n    /// @return amounts Array of amounts :\n    ///         - [0] : The token received amount\n    ///         - [1] : The vault token deposited amount\n    /// @return tokens Array of token addresses\n    ///         - [0] : The token received address\n    ///         - [1] : The vault token deposited address\n    function withdrawETH(\n        address vault,\n        uint256 amount,\n        uint256 minAmountOut\n    ) external payable returns (uint256[] memory amounts, address[] memory tokens) {\n        require(amount != 0, \"YCVO: INVALID_AMOUNT\");\n\n        (address pool, uint96 poolCoinAmount, address lpToken) = operatorStorage.vaults(vault);\n        require(pool != address(0), \"YCVO: INVALID_VAULT\");\n\n        uint256 vaultBalanceBefore = IERC20(vault).balanceOf(address(this));\n        uint256 tokenBalanceBefore = weth.balanceOf(address(this));\n\n        StakingLPVaultHelpers._withdrawAndRemoveLiquidity128(\n            vault,\n            amount,\n            ICurvePool(pool),\n            IERC20(lpToken),\n            poolCoinAmount,\n            eth\n        );\n\n        (amounts, tokens) = OperatorHelpers.getOutputAmounts(\n            IERC20(vault),\n            vaultBalanceBefore,\n            amount,\n            IERC20(address(weth)),\n            tokenBalanceBefore,\n            minAmountOut\n        );\n    }\n\n    /// @notice Withdraw the LP token from the Yearn vault,\n    ///         remove the liquidity from the Curve pool\n    ///         (using int128 for the curvePool.remove_liquidity_one_coin\n    ///         coin index parameter) and receive one of the\n    ///         curve pool token\n    /// @param vault The Yearn vault address to withdraw from\n    /// @param amount The amount to withdraw\n    /// @param outputToken Output token to receive\n    /// @param minAmountOut The minimum of output token expected\n    /// @return amounts Array of amounts :\n    ///         - [0] : The token received amount\n    ///         - [1] : The vault token deposited amount\n    /// @return tokens Array of token addresses\n    ///         - [0] : The token received address\n    ///         - [1] : The vault token deposited address\n    function withdraw128(\n        address vault,\n        uint256 amount,\n        IERC20 outputToken,\n        uint256 minAmountOut\n    ) external payable returns (uint256[] memory amounts, address[] memory tokens) {\n        require(amount != 0, \"YCVO: INVALID_AMOUNT\");\n\n        (address pool, uint96 poolCoinAmount, address lpToken) = operatorStorage.vaults(vault);\n        require(pool != address(0), \"YCVO: INVALID_VAULT\");\n\n        uint256 vaultBalanceBefore = IERC20(vault).balanceOf(address(this));\n        uint256 tokenBalanceBefore = outputToken.balanceOf(address(this));\n\n        StakingLPVaultHelpers._withdrawAndRemoveLiquidity128(\n            vault,\n            amount,\n            ICurvePool(pool),\n            IERC20(lpToken),\n            poolCoinAmount,\n            address(outputToken)\n        );\n\n        (amounts, tokens) = OperatorHelpers.getOutputAmounts(\n            IERC20(vault),\n            vaultBalanceBefore,\n            amount,\n            outputToken,\n            tokenBalanceBefore,\n            minAmountOut\n        );\n    }\n\n    /// @notice Withdraw the LP token from the Yearn vault,\n    ///         remove the liquidity from the Curve pool\n    ///         (using uint256 for the curvePool.remove_liquidity_one_coin\n    ///         coin index parameter) and receive one of the\n    ///         curve pool token\n    /// @param vault The Yearn vault address to withdraw from\n    /// @param amount The amount to withdraw\n    /// @param outputToken Output token to receive\n    /// @param minAmountOut The minimum of output token expected\n    /// @return amounts Array of amounts :\n    ///         - [0] : The token received amount\n    ///         - [1] : The vault token deposited amount\n    /// @return tokens Array of token addresses\n    ///         - [0] : The token received address\n    ///         - [1] : The vault token deposited address\n    function withdraw256(\n        address vault,\n        uint256 amount,\n        IERC20 outputToken,\n        uint256 minAmountOut\n    ) external payable returns (uint256[] memory amounts, address[] memory tokens) {\n        require(amount != 0, \"YCVO: INVALID_AMOUNT\");\n\n        (address pool, uint96 poolCoinAmount, address lpToken) = operatorStorage.vaults(vault);\n        require(pool != address(0), \"YCVO: INVALID_VAULT\");\n\n        uint256 vaultBalanceBefore = IERC20(vault).balanceOf(address(this));\n        uint256 tokenBalanceBefore = outputToken.balanceOf(address(this));\n\n        StakingLPVaultHelpers._withdrawAndRemoveLiquidity256(\n            vault,\n            amount,\n            ICurvePoolNonETH(pool),\n            IERC20(lpToken),\n            poolCoinAmount,\n            address(outputToken)\n        );\n\n        (amounts, tokens) = OperatorHelpers.getOutputAmounts(\n            IERC20(vault),\n            vaultBalanceBefore,\n            amount,\n            outputToken,\n            tokenBalanceBefore,\n            minAmountOut\n        );\n    }\n}"
    },
    {
      "filename": "contracts/libraries/StakingLPVaultHelpers.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.14;\n\nimport \"./../Withdrawer.sol\";\nimport \"./../libraries/ExchangeHelpers.sol\";\nimport \"./../libraries/CurveHelpers/CurveHelpers.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./../interfaces/external/ICurvePool/ICurvePool.sol\";\nimport \"./../interfaces/external/ICurvePool/ICurvePoolETH.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./../interfaces/external/IStakingVault/IStakingVault.sol\";\nimport \"./../interfaces/external/ICurvePool/ICurvePoolNonETH.sol\";\n\n/// @notice Library for LP Staking Vaults deposit/withdraw\nlibrary StakingLPVaultHelpers {\n    using SafeERC20 for IERC20;\n\n    /// @dev  Add liquidity in a Curve pool with ETH and deposit\n    ///       the LP token in a staking vault\n    /// @param vault The staking vault address to deposit into\n    /// @param pool The Curve pool to add liquitiy in\n    /// @param lpToken The Curve pool LP token\n    /// @param poolCoinAmount The number of token in the Curve pool\n    /// @param eth ETH address\n    /// @param amount ETH amount to add in the Curve pool\n    function _addLiquidityAndDepositETH(\n        address vault,\n        ICurvePoolETH pool,\n        IERC20 lpToken,\n        uint256 poolCoinAmount,\n        address eth,\n        uint256 amount\n    ) internal {\n        uint256 lpTokenBalanceBefore = lpToken.balanceOf(address(this));\n\n        if (poolCoinAmount == 2) {\n            pool.add_liquidity{ value: amount }(CurveHelpers.getAmounts2Coins(pool, eth, amount), 0);\n        } else if (poolCoinAmount == 3) {\n            pool.add_liquidity{ value: amount }(CurveHelpers.getAmounts3Coins(pool, eth, amount), 0);\n        } else {\n            pool.add_liquidity{ value: amount }(CurveHelpers.getAmounts4Coins(pool, eth, amount), 0);\n        }\n\n        uint256 lpTokenToDeposit = lpToken.balanceOf(address(this)) - lpTokenBalanceBefore;\n        ExchangeHelpers.setMaxAllowance(lpToken, vault);\n        IStakingVault(vault).deposit(lpTokenToDeposit);\n    }\n\n    /// @dev  Add liquidity in a Curve pool and deposit\n    ///       the LP token in a staking vault\n    /// @param vault The staking vault address to deposit into\n    /// @param pool The Curve pool to add liquitiy in\n    /// @param lpToken The Curve pool lpToken\n    /// @param poolCoinAmount The number of token in the Curve pool\n    /// @param token Token to add in the Curve pool liquidity\n    /// @param amount Token amount to add in the Curve pool\n    function _addLiquidityAndDeposit(\n        address vault,\n        ICurvePoolNonETH pool,\n        IERC20 lpToken,\n        uint256 poolCoinAmount,\n        address token,\n        uint256 amount\n    ) internal {\n        uint256 lpTokenBalanceBefore = lpToken.balanceOf(address(this));\n        ExchangeHelpers.setMaxAllowance(IERC20(token), address(pool));\n\n        if (poolCoinAmount == 2) {\n            pool.add_liquidity(CurveHelpers.getAmounts2Coins(pool, token, amount), 0);\n        } else if (poolCoinAmount == 3) {\n            pool.add_liquidity(CurveHelpers.getAmounts3Coins(pool, token, amount), 0);\n        } else {\n            pool.add_liquidity(CurveHelpers.getAmounts4Coins(pool, token, amount), 0);\n        }\n\n        uint256 lpTokenToDeposit = lpToken.balanceOf(address(this)) - lpTokenBalanceBefore;\n        ExchangeHelpers.setMaxAllowance(lpToken, vault);\n        IStakingVault(vault).deposit(lpTokenToDeposit);\n    }\n\n    /// @dev Withdraw the LP token from the staking vault and\n    ///      remove the liquidity from the Curve pool\n    /// @param vault The staking vault address to withdraw from\n    /// @param amount The amount to withdraw\n    /// @param pool The Curve pool to remove liquitiy from\n    /// @param lpToken The Curve pool LP token\n    /// @param poolCoinAmount The number of token in the Curve pool\n    /// @param outputToken Output token to receive\n    function _withdrawAndRemoveLiquidity128(\n        address vault,\n        uint256 amount,\n        ICurvePool pool,\n        IERC20 lpToken,\n        uint256 poolCoinAmount,\n        address outputToken\n    ) internal {\n        uint256 lpTokenBalanceBefore = lpToken.balanceOf(address(this));\n        IStakingVault(vault).withdraw(amount);\n\n        bool success = CurveHelpers.removeLiquidityOneCoin(\n            pool,\n            lpToken.balanceOf(address(this)) - lpTokenBalanceBefore,\n            outputToken,\n            poolCoinAmount,\n            bytes4(keccak256(bytes(\"remove_liquidity_one_coin(uint256,int128,uint256)\")))\n        );\n\n        require(success, \"SDCSO: CURVE_RM_LIQUIDITY_FAILED\");\n    }\n\n    /// @dev Withdraw the LP token from the staking vault and\n    ///      remove the liquidity from the Curve pool\n    /// @param vault The staking vault address to withdraw from\n    /// @param amount The amount to withdraw\n    /// @param pool The Curve pool to remove liquitiy from\n    /// @param lpToken The Curve pool LP token\n    /// @param poolCoinAmount The number of token in the Curve pool\n    /// @param outputToken Output token to receive\n    function _withdrawAndRemoveLiquidity256(\n        address vault,\n        uint256 amount,\n        ICurvePool pool,\n        IERC20 lpToken,\n        uint256 poolCoinAmount,\n        address outputToken\n    ) internal {\n        uint256 lpTokenBalanceBefore = lpToken.balanceOf(address(this));\n        IStakingVault(vault).withdraw(amount);\n\n        bool success = CurveHelpers.removeLiquidityOneCoin(\n            pool,\n            lpToken.balanceOf(address(this)) - lpTokenBalanceBefore,\n            outputToken,\n            poolCoinAmount,\n            bytes4(keccak256(bytes(\"remove_liquidity_one_coin(uint256,uint256,uint256)\""
    }
  ]
}