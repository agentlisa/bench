{
  "Title": "M-7: Medium5-CrossChainWETHSwapFeesChargedUnnecesarily",
  "Content": "# Issue M-7: Medium5-CrossChainWETHSwapFeesChargedUnnecesarily \n\nSource: https://github.com/sherlock-audit/2024-03-woofi-swap-judging/issues/95 \n\n## Found by \ncharles\\_\\_cheerful\n### by [CarlosAlegreUr](https://github.com/CarlosAlegreUr)\n\n## Summary\n\nWhen doing a cross-chain transfer with any valid `fromToken`, using `sgETH` as `bridgeToken` and **WETH** as `toToken` via the\n`WooRouterV2` swap on destination chain. The user is charged an unnecessary fee. \n\n## Vulnerability Detail\n\nWhen receiving a cross-chain swap trhough `sgReceive()` at `WooCrossChainRouterV4`, if the `bridgeToken` is **sgETH** then the `_handleNativeReceived()` will be called. This function if `toToken != ETH_PLACEHOLDER_ADDR` will perform a swap to change the eth used as `bridgeToken` for the `toToken` using, for example, the very same `WooRouterV2`. And for exchanging ETH it needs to be wrapped up as **WETH** which it does by calling `IWETH(weth).deposit{value: bridgedAmount}();`.\n\nThe problem comes when the `toToken` desired is **WETH**, then a ***WETH to WETH*** swap will be carried out by the `WooRouterV2` which will result in a fee being charged to the user due to a swap which makes no sense but would execute. So the user is losing unnecessary unexpected money.\n\nYou can see that `WooRouterV2` allows for swaps where `from` and `to` tokens are the same token exeuting the following code:\n\n<details>\n<summary>See swap the same `from` and `to` tokens via WooRouterV2 üëÅÔ∏è</summary>\n\nTo run the code copy paste it inside the `./test/typesript/WooRouterV2.test.sol` file, then inside the `describe(\"Swap Functions\", () => {})`, and then after the `beforeEach(\"Deploy WooRouterV2\", async () => {})`, and then run:\n\n```bash\nnpx hardhat test test/typescript/WooRouterV2.test.ts\n```\n\n```typescript\n    it.only(\"swap btc -> btc\", async () => {\n      await btcToken.mint(user.address, ONE.mul(5));\n      console.log(\"POOL BTC BALANCE\", await utils.formatEther(await btcToken.balanceOf(wooPP.address)));\n      console.log(\"Swap: btc -> btc\");\n      const fromAmount = ONE.mul(2);\n      const minToAmount = ONE.mul(1);\n      await btcToken.connect(user).approve(wooRouter.address, fromAmount);\n      await wooRouter\n        .connect(user)\n        .swap(btcToken.address, btcToken.address, fromAmount, minToAmount, user.address, ZERO_ADDR);\n      console.log(\"POOL BTC BALANCE\", await utils.formatEther(await btcToken.balanceOf(wooPP.address)));\n      console.log(\"That means from the 2 BTC user sent only 0.002 were left as fee.\");\n      console.log(\"What matters for our issue is that the tx succeeded and a fee was taken.\");\n    });\n```\n\n</details>\n\n> üìò **Note** ‚ÑπÔ∏è: The cross-chain tx described is feasible as there is no kind of `require(toToken != WETH && brdigeToken != sgETH)` anywhere.\n\n> üöß **Note** ‚ö†Ô∏è: I'm not sure what would happen if choosing **1inch** option. If the swaps go through this problem would apply. But if the tx reverts this problem wouldn't apply as the swapping fee of **1inch** wouldn't be applied and the transfer of `bridgeAmount`\nwould take place as expected. Due to personal lack of time I let this question open. Anyway the recommendation proposed would fix the problem too in case **1inch** also allows execution of the unnecessary swap.\n\n## Impact\n\nUsers lose unnecessary money when doing a cross-chain transfer with `sgETH` as `bridgeToken` and **WETH** as `toToken` via the `WooRouterV2` swap on detination chain.\n\n## Code Snippet\n\n- [_handleNativeReceived() deposit WETH to later perform swap](https://github.com/sherlock-audit/2024-03-woofi-swap/blob/main/WooPoolV2/contracts/CrossChain/WooCrossChainRouterV4.sol#L299)\n\n- [_handleNativeReceived() can execute swap through router](https://github.com/sherlock-audit/2024-03-woofi-swap/blob/main/WooPoolV2/contracts/CrossChain/WooCrossChainRouterV4.sol#L349)\n\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAt `_handleNativeReceived()`. In the case of bridging with **sgETH**, after the  `if(toToken == ETH_PLACEHOLDER_ADDR){}`, add an extra if that checks if **toToken != WETH**, and if they are indeed different proceed with the swap.\n\n```diff\n       if (toToken == ETH_PLACEHOLDER_ADDR) {\n         // code for when no swap required...\n        }\n\n        IWETH(weth).deposit{value: bridgedAmount}();\n\n+       if (toToken != WETH) {\n            // Swap required!\n            // Swap logic...\n+        }else{\n+           // send the WETH\n+       }\n```\n\n            \n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**WangAudit** commented:\n> technically yes; it's WETH to WETH; but the user want to exchange another token (e.g.sgETH) to WETH; therefore; the fees are taken cause the user initially swaps not-WETH to WETH\n\n\n\n**CarlosAlegreUr**\n\nEscalate\n\nI think I undertand where your point comes from, but I think it's wrong for the following reasons.\n\nThe way your comment is wrong is that actually if using `sgEth` as `bridgeToken`, even though its a token and thus a swap should be made to WETH and thus charge the fee and thus be valid as you say, even though that, the thing is that bridged `sgEth` doesnt arrive to the `CrossChainRouterV4` contract as a token but already as a native coin in `msg.value`. Thus when using `sgETH` as `bridgeToken`\nyou are, a bit confusingly, not actually receiving a ERC20 token but native coin. You can see that this is true carefully looking at the code:\n\nWhen `sgReceive()` is called and `bridgedToken=sgETH` we can see that the value being sent is not actualy sgETH token but pure ETH as `msg.value`.\n\nThat is why the code does the following, first in `sgReceive()`:\n[See code in repo click here](https://github.com/sherlock-audit/2024-03-woofi-swap/blob/main/WooPoolV2/contracts/CrossChain/WooCrossChainRouterV4.sol#L174)\n[Notice the dev team added a comment pointing out what I'm trying to explain here. Click to see.](https://github.com/sherlock-audit/2024-03-woofi-swap/blob/main/WooPoolV2/contracts/CrossChain/WooCrossChainRouterV4.sol#L175)\n```solidity\nif (bridgedToken == sgInfo.sgETHs(sgInfo.sgChainIdLocal())) {\n            // üü¢ The comment below this one was added by the dev team and also informs that when sgETH, native token (coin) is received\n            // bridgedToken is SGETH, received native token\n            _handleNativeReceived(refId, to, toToken, amountLD, minToAmount, dst1inch);\n}\n```\nIf `sgEth` is used, `_handleNativeReceived()` is called, and then inside `_handleNativeReceived()`:\n\n[See code in repo click here](https://github.com/sherlock-audit/2024-03-woofi-swap/blob/main/WooPoolV2/contracts/CrossChain/WooCrossChainRouterV4.sol#L279)\n\n```solidity\n   ) internal {\n        address msgSender = _msgSender();\n\n        if (toToken == ETH_PLACEHOLDER_ADDR) {\n            // Directly transfer ETH\n            TransferHelper.safeTransferETH(to, bridgedAmount);\n            emit WooCrossSwapOnDstChain(/*event args*/);\n            return;\n        }\n    // (rest of code...)\n```\n\nYou can see that the very first action taken is to check if you wanted native coin on destination chain, and if so, transfer it to you and then `return;`. This is because the `sgETH` is sent to the router as already native coin in `msg.value` and not as a token itself.\n\nThat is why there is no **sgETH -> WETH** swap and thus the unnecesarry **WETH -> WETH** swap in WooFi will execute as explained in the issue thus charging valid users fees that shouldnt be charged.\n\n**sherlock-admin2**\n\n> Escalate\n> \n> I think I undertand where your point comes from, but I think it's wrong for the following reasons.\n> \n> The way your comment is wrong is that actually if using `sgEth` as `bridgeToken`, even though its a token and thus a swap should be made to WETH and thus charge the fee and thus be valid as you say, even though that, the thing is that bridged `sgEth` doesnt arrive to the `CrossChainRouterV4` contract as a token but already as a native coin in `msg.value`. Thus when using `sgETH` as `bridgeToken`\n> you are, a bit confusingly, not actually receiving a ERC20 token but native coin. You can see that this is true carefully looking at the code:\n> \n> When `sgReceive()` is called and `bridgedToken=sgETH` we can see that the value being sent is not actualy sgETH token but pure ETH as `msg.value`.\n> \n> That is why the code does the following, first in `sgReceive()`:\n> [See code in repo click here](https://github.com/sherlock-audit/2024-03-woofi-swap/blob/main/WooPoolV2/contracts/CrossChain/WooCrossChainRouterV4.sol#L174)\n> [Notice the dev team added a comment pointing out what I'm trying to explain here. Click to see.](https://github.com/sherlock-audit/2024-03-woofi-swap/blob/main/WooPoolV2/contracts/CrossChain/WooCrossChainRouterV4.sol#L175)\n> ```solidity\n> if (bridgedToken == sgInfo.sgETHs(sgInfo.sgChainIdLocal())) {\n>             // üü¢ The comment below this one was added by the dev team and also informs that when sgETH, native token (coin) is received\n>             // bridgedToken is SGETH, received native token\n>             _handleNativeReceived(refId, to, toToken, amountLD, minToAmount, dst1inch);\n> }\n> ```\n> If `sgEth` is used, `_handleNativeReceived()` is called, and then inside `_handleNativeReceived()`:\n> \n> [See code in repo click here](https://github.com/sherlock-audit/2024-03-woofi-swap/blob/main/WooPoolV2/contracts/CrossChain/WooCrossChainRouterV4.sol#L279)\n> \n> ```solidity\n>    ) internal {\n>         address msgSender = _msgSender();\n> \n>         if (toToken == ETH_PLACEHOLDER_ADDR) {\n>             // Directly transfer ETH\n>             TransferHelper.safeTransferETH(to, bridgedAmount);\n>             emit WooCrossSwapOnDstChain(/*event args*/);\n>             return;\n>         }\n>     // (rest of code...)\n> ```\n> \n> You can see that the very first action taken is to check if you wanted native coin on destination chain, and if so, transfer it to you and then `return;`. This is because the `sgETH` is sent to the router as already native coin in `msg.value` and not as a token itself.\n> \n> That is why there is no **sgETH -> WETH** swap and thus the unnecesarry **WETH -> WETH** swap in WooFi will execute as explained in the issue thus charging valid users fees that shouldnt be charged.\n\nThe escalation could not be created because you are not exceeding the escalation threshold.\n\nYou can view the required number of additional valid issues/judging contest payouts in your Profile page,\nin the [Sherlock webapp](https://app.sherlock.xyz/audits/).\n\n\n**WangSecurity**\n\nEscalate\n\nAfter additional discussions in discord, I admit that there is something I miss about this one. Therefore, escalating on behalf of @CarlosAlegreUr , after he provides additional comments from discord, I will give my reasons why it should remain invalid and leave the decision to the head of judging.\n\n**sherlock-admin2**\n\n> Escalate\n> \n> After additional discussions in discord, I admit that there is something I miss about this one. Therefore, escalating on behalf of @CarlosAlegreUr , after he provides additional comments from discord, I will give my reasons why it should remain invalid and leave the decision to the head of judging.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**CarlosAlegreUr**\n\n> Escalate\n> \n> After additional discussions in discord, I admit that there is something I miss about this one. Therefore, escalating on behalf of @CarlosAlegreUr , after he provides additional comments from discord, I will give my reasons why it should remain invalid and leave the decision to the head of judging.\n\n#95 Final escalation and thanks WangSecurity for your time, effort and kindness.\n\nSumming up discord discussion with WangSecurity (lead judge) and Tapir (another contestant).\n\nThere are 4 main reasons why this issue has been considered invalid (from discord chat):\n\n1. To me it looks like design advice honestly. It's a good find honestly, but it's an issue about improving user experience.\n2. The loss is small and finite. \n3. It's just complicating the code.\n4. Using WETH as `toToken` swap might not be a \"core\" functonality.\n\nI disagree reagarding 1, I potentially agree with number 2 but it depends on how Serlok defines small and finite, I disagree with 3 && 4. The counterarguments and reasons why I disagree are written after the summary of the issue.\n\n---\n\nFirst lets summarize the issue: The issue is that the user will be charged a fee he shouldn't when chosing to cross-swap `WETH` as `toToken` using `WooPP` as the exchange for the final swap in **dstChain** and `sgEth` as `bridgeToken`.\n\n(from discord chat)\nMmmm I will try to explain it again.\n\nFirst when receiving `sgETH` the contract doesn't receive the ERC20 but diretly receives, from the bridge, native coin through `msg.value`.\n\nNow lets remember the inputs:\n\n`fromToken` => any\n`birdgeToken` => `sgEth`\n`toToken` => `WETH`\n`dst1inch.swapRouter` = WooPP pool\n\n\nBecause `bridgeToken` is `sgETH` the `_handleNativeReceived()` function will be executed as you can see in this if statement [here](https://github.com/sherlock-audit/2024-03-woofi-swap/blob/65185691c91541e33f84b77d4c6290182f137092/WooPoolV2/contracts/CrossChain/WooCrossChainRouterV4.sol#L174).\n\nNow inside `_handleNativeReceived()` there are two possible main paths, whether you want native coin and [this block of code](https://github.com/sherlock-audit/2024-03-woofi-swap/blob/65185691c91541e33f84b77d4c6290182f137092/WooPoolV2/contracts/CrossChain/WooCrossChainRouterV4.sol#L279) gets executed and transfers `msg.value` to you and returns, OR, the `msg.value` is wrapped up latter to procced with the swap `bridgeToken => toToken`.\n\nWrap happens after the if, [here](https://github.com/sherlock-audit/2024-03-woofi-swap/blob/65185691c91541e33f84b77d4c6290182f137092/WooPoolV2/contracts/CrossChain/WooCrossChainRouterV4.sol#L299).\n\nHere is the KEY PART, we are not using 1inch for the swap and we specified WooPP pool as the exchange to use. So [this block of code](https://github.com/sherlock-audit/2024-03-woofi-swap/blob/65185691c91541e33f84b77d4c6290182f137092/WooPoolV2/contracts/CrossChain/WooCrossChainRouterV4.sol#L347) will be executed.\n\nThe swap will be `WETH => toToken` as you can see in the [next line](https://github.com/sherlock-audit/2024-03-woofi-swap/blob/65185691c91541e33f84b77d4c6290182f137092/WooPoolV2/contracts/CrossChain/WooCrossChainRouterV4.sol#L349). But `toToken` can also be WETH.\n\nAnd as the in the code I added to my [original issue](https://github.com/sherlock-audit/2024-03-woofi-swap-judging/issues/95), inside the: ***See swap the same `from` and `to` tokens via WooRouterV2 üëÅÔ∏è*** section. The WooPP pool allows for execution of \"same-token\" swaps even if they dont make sense. Like our now `WETH => WETH` swap.\n\nIn those executions you can see in the code I provided that a fee is also charged in the WooPP pool. This fee is the one that makes no sense to charge to the user as they already have the `toTokend` desired which is `WETH`.\n\nFinally add that this makes sense if you are bridging for example to Arbitrum, a chain supported by the protocol.\n\nThe key points you might be missing are:\n\n1. The swap is not done via 1inch but via WooPP pool. And this allows for the \"same-token\" WETH => WETH unnecessary swap that involves the fee any swap on WooPP is charged.\n\n2. `sgEth` is given by the bridge to the corss-chain-router, but not as an ERC20 but as native coin through `msg.value`. That is why is later wrapped up to `WETH` to proceed with the swap in case you specified an ERC20 as `toToken`, but this `toToken` can be WETH and then the extra fee is charged.\n\n---\n\n## 1. \n(from discrod chat)\nI don't agree on it is a UX problem. I couldn't find anywhere where it says you can't bridge `WETH` uing `sgETH` as `bridgeToken` using `WooPP` for the destination swap. The only limits on tokens you can use according to the protocol are the ones on their `IntegrationHelper` contract and the ones supported by the external brige they use (Stargate).\n\nAnd WETH is supported in WooPP pool and can be bridged to Arbitrum (supported by the protocol) via stargate. As you can see in their [contract deployed](https://arbiscan.io/address/0x28D2B949024FE50627f1EbC5f0Ca3Ca721148E40#readContract) on `getSupportedTokens()`, [the WETH Arbitrum address](https://arbiscan.io/token/0x82af49447d8a07e3bd95bd0d56f35241523fbab1) is among them. The only restriction I could find in bridging is that you can't use the native coin as `bridgeToken`, you gotta use sgETH or sgVersion. So, under all restrictions the protocol and team set, this is a valid user interaction which results in loss of funds due to unnecessary fee.\n\nI will make an analogy with a car. If you buy a car and the seller tells you that the car can drive in uneven pavements but then you drive it in uneven pavement made of sand and the car gets some damange then it's not your UX fault because as far as you were told, the car works on uneven pavements. It said nothing about the sand, in fact is a family car and it is expected to probably go on beach holidays some times.\n\nSo to sum up I don't agree with the argument that it is a UX problem becaues the developers never said they forbid swapping WETH in their pool or bridging it as `toToken`. In fact all indicates this is expected because WETH is approved as a token to be used in the WooPP and there are no filters for forbiding it in the bridge function either.\n\n## 2.\n(from discrod chat)\nAbout the it's a small and finite amount. It depends what you consider small and finite. The WooPP pool charges a % fee, and depending on the size of the swap the % might be small but the absolute amount can be considered big.  \n \nThis is very similar to what I wrote before in [issue 97 comment section 2](https://github.com/sherlock-audit/2024-03-woofi-swap-judging/issues/97#issuecomment-2041615772), adapted for this issue would be: My agreement with the argument of small defined loss depends on how sherlok defines a small finite loss. This could be considered small in terms of percentage as the loss will be as big as the protocols' fee charged for swapping on WooPP pool, which is a small % (lets say 1% or even 0.05%). \n\nNow despite of that a 1% loss on let's imagine a traded amount of 1 million dollars would be 10K of loss which is quite an amount of money to lose (or 5K in the 0.05% case). So idk how Sherlok defines finite small loss, in absolute terms or proportional terms.\n\nIf it is in proportional termns then okay it's a small loss, you lost 10K while managing 1 million due to code issues. But if it is absolute terms I do not think 10K or 5K is a small loss.\n\nAs it is a percentage of the swapped amount, it can be considered proportionally low. But in absolute terms the amount lost can be seen as big, like the 10K loss explained. Also if we add the time factor, over time, all people using this option of bridging where this swap is unnecesarily done the amount of money lost will be accumulating and can get big. Anyway to sum up, depending on the nuance of how you define small and finite loss I would agree or disagree with the argument.\n\n## 3.\n(from discrod chat)\nI don't think fixing the issue adds a lot of complexity. As it can seen in the ***Recommendation*** section a simple `if` statement would fix the issue. As much, the `if` with a comment saying, if the `toToken` desired was `WETH` there is no need to swap and just send the token.\n\n## 4.\n(from discrod chat)\nI understand as \"core functionalities\" of this audit: their WooPP pool usage with the sPMM algorithm and cross-chain swaps. This is a valid cross-chain swap. Otherwise why would they bother to add the cross-chain contracts to the audit.\n\nThese are all the arguments and counterarguments given on discord for this issue.\n\n**WangSecurity**\n\nThank you for such an insightful comment!\n\nThe reasons why I still think it should remain low since it's essentially works as it should be.\n\nThe inputs that the Watson uses in his examples are:\n\nfromToken => any\nbirdgeToken => sgEth\ntoToken => WETH\ndst1inch.swapRouter = WooPP pool\n\nTherefore, I assume that we charge the fee here as expected since sgETH and WETH are technically different tokens even tho we can say they're quite the same. Therefore, I believe it would be nice to not charge the fee in that case, but I cannot say anything it broken here.\n\nMoreover, I think the rule of financial loss to exceed small and finite amounts can be applied here since it's a small percentage of the swap (but I may be applying it here incorrectly). Therefore, I think it in facts work as expected, but the report is improving the protocol a bit. Don't get me wrong, it's a nice finding, but I don't see it as medium, unfortunately.\n\nI admit that I may be wrong in my assumptions and will take any decision from the head of Judging, but I believe it's not sufficient to be medium (thank you for such and insightful explanation G, it looks very good).\n\n**Czar102**\n\nI believe the current system may work suboptimally with sgETH and WETH, and the recommendation would remove that suboptimal behavior. But design improvements aren't security issues, and I consider this report to be informational.\n\nAs @WangSecurity mentioned:\n> Therefore, I assume that we charge the fee here as expected since sgETH and WETH are technically different tokens even tho we can say they're quite the same. Therefore, I believe it would be nice to not charge the fee in that case, but I cannot say anything it broken here.\n\nPlanning to reject the escalation and leave the issue as is.\n\n**CarlosAlegreUr**\n\n> I believe the current system may work suboptimally with sgETH and WETH, and the recommendation would remove that suboptimal behavior. But design improvements aren't security issues, and I consider this report to be informational.\n> \n> As @WangSecurity mentioned:\n> \n> > Therefore, I assume that we charge the fee here as expected since sgETH and WETH are technically different tokens even tho we can say they're quite the same. Therefore, I believe it would be nice to not charge the fee in that case, but I cannot say anything it broken here.\n> \n> Planning to reject the escalation and leave the issue as is.\n\n@Czar102 and @WangSecurity , thanks for your point of view, but I still don't agree, these are my reasons:\n\n## 1.\n\nWhen `msg.value` is used, the native coin, lets say ether in **Arbitrum** example. In that case there is no fee charged, even if the native coin ***ether***. We can also say about **ether** to be: \"technically different tokens even tho we can say they're quite the same\".\n\nThus we can see that when receiving the same or similar a asset to **sgEth** in **dstChain** no swap is expected to be performed by the code. Thus same would apply to WETH.\n\n\n## 2.\n\nLets say that, doesnt matter if they are similar, they are in fact different tokens and a swap fee should be taken. In that case the swap fee taken should be because of a swap `sgETH => WETH`, and not `WETH => WETH`. This is problematic as differnet swaps gather differents amount of fees thus even in this path, the user would be charged something he didn't pay for.\n\n**WooPP** pool does not allow for `sgETH` to be swapped. As we cann see [sgEth on Arbitrum](https://arbiscan.io/address/0x82cbecf39bee528b5476fe6d1550af59a9db6fc0) is not expected in the [supported tokens](https://arbiscan.io/address/0x28D2B949024FE50627f1EbC5f0Ca3Ca721148E40#readContract) function mentioned during the dicussions. But even if they indeed supported it, in **WooPP** [different tokens](https://github.com/sherlock-audit/2024-03-woofi-swap/blob/main/WooPoolV2/contracts/WooPPV2.sol#L83) have [different feeRates](https://github.com/sherlock-audit/2024-03-woofi-swap/blob/main/WooPoolV2/contracts/WooPPV2.sol#L64) so, for example swaping `ValidToken1 => ValidToken2` is no the same as swapping `ValidToken2 => ValidToken3`. So it would actually matter if the swap is `sgETH => WETH` or `WETH => WETH`, thus the code would still be charging incorrect amounts to clients.\n\nIn the other hand, in case of using **1inch** same applies, nothing guarantees that the fee charged for a swap `sgETH => WETH` is the same as the fee charged for a swap `WETH => WETH` (if the latter is posible in 1inch) so users would be charged incorrect amount of fees in this case. Although this case `sgETH => WETH` can't be executed because the [WETH address is hardoced](https://github.com/sherlock-audit/2024-03-woofi-swap/blob/main/WooPoolV2/contracts/CrossChain/WooCrossChainRouterV4.sol#L309) in both swaps, whether trhough **1inch** or [WooPP swap](https://github.com/sherlock-audit/2024-03-woofi-swap/blob/main/WooPoolV2/contracts/CrossChain/WooCrossChainRouterV4.sol#L349).\n\n## Sum-up\n\nNo matter what, the conclusion I take is that fee should not be charged. First because I think the code clearly treats \"quite the same\" tokens as no need to swap. And second, even if lets say we must swap, the fees would be incorrect.\n\nI don't see it as suboptimal behaviour but as an issue in the code charging fees that it should not charge and that didn't expect.\n\n**Czar102**\n\n@CarlosAlegreUr I don't quite understand your second point. Could you explain it in a different way? Preferably as a short summary?\n\n**CarlosAlegreUr**\n\n> @CarlosAlegreUr I don't quite understand your second point. Could you explain it in a different way? Preferably as a short summary?\n\n@Czar102 \n\nSo, I don't think a fee should be charged if from bridged `sgEth` we eventually want `WETH` because I think the code is not meant to do that for the reasons mentioned in point **1** in the comment above.\n\nBut, assusming your position of a fee should be charged, there would still be a problem. As the swap made in the code would be `WETH => WETH` and not `sgEth => WETH`. The protocol's pool **WooPP** charges different fees for different assets swaped, so the fee for `WETH => WETH` would be different than the fee for `sgEth => WETH`. So, even if we assume a fee should be charged, the code would still be charging incorrect fees. (a similar thing appliess to **1inch** swap)\n\nThus, `sgEth` as `bridgeToken` and `WETH` as `toToken` would still have incorrect fee behaviour.\n\n**WangSecurity**\n\nDo I understand correctly that when it comes to [`handleNativeReceive`](https://github.com/sherlock-audit/2024-03-woofi-swap/blob/65185691c91541e33f84b77d4c6290182f137092/WooPoolV2/contracts/CrossChain/WooCrossChainRouterV4.sol#L269), we skip the first check `if (toToken == ETH_PLACEHOLDER_ADDR)` at L279, cause our toToken is not ETH. \n\nAfter it at line 299 we wrap msg.value into WETH and then at lines 306 or 349 we swap WETH to WETH, even tho the bridge token was sgETH, the function still wraps it into WETH before swapping into WETH. Correct?\n\nAnd another question, can you forward to lines of code where it handles swap from sgETH to WETH and WETH to WETH to see how the fees differ (sorry if you already sent it, cannot find). \n\n**CarlosAlegreUr**\n\n> Do I understand correctly that when it comes to [`handleNativeReceive`](https://github.com/sherlock-audit/2024-03-woofi-swap/blob/65185691c91541e33f84b77d4c6290182f137092/WooPoolV2/contracts/CrossChain/WooCrossChainRouterV4.sol#L269), we skip the first check `if (toToken == ETH_PLACEHOLDER_ADDR)` at L279, cause our toToken is not ETH.\n> \n> After it at line 299 we wrap msg.value into WETH and then at lines 306 or 349 we swap WETH to WETH, even tho the bridge token was sgETH, the function still wraps it into WETH before swapping into WETH. Correct?\n> \n> And another question, can you forward to lines of code where it handles swap from sgETH to WETH and WETH to WETH to see how the fees differ (sorry if you already sent it, cannot find).\n\nYour understanding and description are right indeed.:\n\n> After it at line 299 we wrap msg.value into WETH and then at lines 306 or 349 we swap WETH to WETH, even tho the bridge token >\n> was sgETH, the function still wraps it into WETH before swapping into WETH. Correct?\n\nSecond, the code does not do that. I was describing a hypothetical scenario trying to show that even if actually a fee had to be charged, the fee would be incorrect as **WooPP** charges different fees according to the token type. I added a link to the storage variables that handle this: [tokenInfos](https://github.com/sherlock-audit/2024-03-woofi-swap/blob/main/WooPoolV2/contracts/WooPPV2.sol#L83) storage, which points to a [TokenInfo](https://github.com/sherlock-audit/2024-03-woofi-swap/blob/main/WooPoolV2/contracts/WooPPV2.sol#L64) struct with a [feeRate](https://github.com/sherlock-audit/2024-03-woofi-swap/blob/main/WooPoolV2/contracts/WooPPV2.sol#L66). By the way in `feeRate` don't get confused with the comment nex to it: `// 1 in 100000; 10 = 1bp = 0.01%; max = 65535`, this doesnt mean that the `feeRate` value is 1 in 100000, it is just how devs marked the decimals of precision.\n\nSo even in the hypothetical scenario that the code actually expects a swap (which I dont think it does by the resons provided earlier), the fee charged would be incorrect as it would be a `WETH => WETH` swap fee and not a `sgETH => WETH` swap fee.\n\n**WangSecurity**\n\nThen, as I've said earlier the only problem for me here is I don't really see it exceed small and finite amounts. It's not clear how to interpret this rule, cause hypothetically the fee will be around 0.05 - 0.1% as the Watson said earlier. Therefore, it seems to be small amout. But if it's 1M swap then the fee will be quite high, even tho it's only 0.05-0.1%. \n\nThus, if the head of judging decides that it should be valid, I will agree and accept the decision. I see where incorrect fees are taken the only problem is that I'm unsure we can say it exceeds small and finite amounts as the rules for medium say. Also, I guess it may be considered core functionality break, since we account not the fees we have to account. And for that, I also rely on the head of judging, cause I'm unsure how we should interpret the rules in that specific case.\n\nAnd for the Watson, thank you for being so polite and calm, giving such thorough responses! It's a pleasure.\n\n**fb-alexcq**\n\nOkay. `toToken` could not be WETH in our server logic, and it won't happen. Also it's pretty hard to manually construct the param and interact with smart contract directly.\n\nHowever, in technically aspect, when `toToken` is WETH, our current contract will fail the TX, and we need manually refund the user. So the issue posted here makes sense, but I'll let judges decide the priority level.\n\n**WangSecurity**\n\nBased on the comment by the sponsor above, as I understand the issue should indeed remain low/info since it'll be user mistake. Looping in the watson @CarlosAlegreUr if they can provide their opinion. But based on above, I believe it should remain low.\n\n**CarlosAlegreUr**\n\n> Based on the comment by the sponsor above, as I understand the issue should indeed remain low/info since it'll be user mistake. Looping in the watson @CarlosAlegreUr if they can provide their opinion. But based on above, I believe it should remain low.\n\nBased on @fb-alexcq comments. I understand that their server and/or UI won't have by default the option of **WETH** as `toToken`. So it won't be an worry if the user uses the official site I guess. \n\nSo only apps building on top of the protocol would be affected by this as there are no warnings or restrictions in the system's interface, docs or code to the WETH case. And, in my opinion, protocols that build on top of yours are also valid users doing valid actions and in this time, with invalid results.\n\nI don't see it as a user mistake, I see it as a failed promise from the protocol's side that can cost, specially to apps building on top of the protocol, some money. So if user mistake is the reason for it to be a Low, as I don't think it is a user mistake, I don't think it is a Low.\n\n**Evert0x**\n\nResult:\nMedium\nUnique\n\n---\n\nMedium as it's clear that ANY token (including WETH) is supported, the unnecessary swap fee (0.05 - 0.1%) is pretty significant loss for users. \n\n\n**sherlock-admin4**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [WangSecurity](https://github.com/sherlock-audit/2024-03-woofi-swap-judging/issues/95/#issuecomment-2041585464): accepted\n\n**WangSecurity**\n\n@CarlosAlegreUr want to again thank you for being very responsive and allocating so much time to correctly resolve this escalation. Great finding honestly, just wasn't sure how to correctly interpret it. Thank you very much again!\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/277",
  "Code": [
    {
      "filename": "WooPoolV2/contracts/CrossChain/WooCrossChainRouterV4.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.14;\n\n// OpenZeppelin Contracts\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\n// Local Contracts\nimport {IWETH} from \"../interfaces/IWETH.sol\";\nimport {IWooCrossChainRouterV3} from \"../interfaces/CrossChain/IWooCrossChainRouterV3.sol\";\nimport {IWooRouterV2} from \"../interfaces/IWooRouterV2.sol\";\nimport {IStargateEthVault} from \"../interfaces/Stargate/IStargateEthVault.sol\";\nimport {IStargateRouter} from \"../interfaces/Stargate/IStargateRouter.sol\";\nimport {ILzApp} from \"../interfaces/LayerZero/ILzApp.sol\";\nimport {ISgInfo} from \"../interfaces/CrossChain/ISgInfo.sol\";\n\nimport {TransferHelper} from \"@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\";\n\n/// @title cross chain router implementation, version 3.\n/// @notice Router for stateless execution of cross chain swap against WOOFi or 1inch swap.\n/// @custom:stargate-contracts https://stargateprotocol.gitbook.io/stargate/developers/contract-addresses/mainnet\ncontract WooCrossChainRouterV4 is IWooCrossChainRouterV3, Ownable, Pausable, ReentrancyGuard {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /* ----- Constants ----- */\n\n    address public constant ETH_PLACEHOLDER_ADDR = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /* ----- Variables ----- */\n\n    IWooRouterV2 public wooRouter;\n    ISgInfo public sgInfo;\n\n    address public immutable weth;\n    address public feeAddr;\n    uint256 public bridgeSlippage; // 1 in 10000th: default 1%\n\n    uint16 public srcExternalFeeRate; // unit: 0.1 bps (1e6 = 100%, 25 = 2.5 bps)\n    uint16 public dstExternalFeeRate; // unit: 0.1 bps (1e6 = 100%, 25 = 2.5 bps)\n    uint256 public constant FEE_BASE = 1e5;\n\n    mapping(uint16 => address) public wooCrossRouters; // chainId => WooCrossChainRouterV3 address\n\n    receive() external payable {}\n\n    constructor(\n        address _weth,\n        address _wooRouter,\n        address _sgInfo\n    ) {\n        weth = _weth;\n        wooRouter = IWooRouterV2(_wooRouter);\n        sgInfo = ISgInfo(_sgInfo);\n\n        bridgeSlippage = 100;\n\n        srcExternalFeeRate = 25;\n        dstExternalFeeRate = 25;\n    }\n\n    /* ----- Functions ----- */\n\n    function crossSwap(\n        uint256 refId,\n        address payable to,\n        SrcInfos memory srcInfos,\n        DstInfos calldata dstInfos,\n        Src1inch calldata src1inch,\n        Dst1inch calldata dst1inch\n    ) external payable whenNotPaused nonReentrant {\n        require(srcInfos.fromToken != address(0), \"WooCrossChainRouterV3: !srcInfos.fromToken\");\n        require(\n            dstInfos.toToken != address(0) && dstInfos.toToken != sgInfo.sgETHs(dstInfos.chainId),\n            \"WooCrossChainRouterV3: !dstInfos.toToken\"\n        );\n        require(to != address(0), \"WooCrossChainRouterV3: !to\");\n\n        uint256 msgValue = msg.value;\n        uint256 bridgeAmount;\n        uint256 fee = 0;\n\n        {\n            // Step 1: transfer\n            if (srcInfos.fromToken == ETH_PLACEHOLDER_ADDR) {\n                require(srcInfos.fromAmount <= msgValue, \"WooCrossChainRouterV3: !srcInfos.fromAmount\");\n                srcInfos.fromToken = weth;\n                IWETH(weth).deposit{value: srcInfos.fromAmount}();\n                msgValue -= srcInfos.fromAmount;\n            } else {\n                TransferHelper.safeTransferFrom(srcInfos.fromToken, msg.sender, address(this), srcInfos.fromAmount);\n            }\n\n            // Step 2: local swap by 1inch router\n            if (srcInfos.fromToken != srcInfos.bridgeToken) {\n                TransferHelper.safeApprove(srcInfos.fromToken, address(wooRouter), srcInfos.fromAmount);\n                if (src1inch.swapRouter != address(0)) {\n                    // external swap via 1inch\n                    bridgeAmount = wooRouter.externalSwap(\n                        src1inch.swapRouter,\n                        src1inch.swapRouter,\n                        srcInfos.fromToken,\n                        srcInfos.bridgeToken,\n                        srcInfos.fromAmount,\n                        srcInfos.minBridgeAmount,\n                        payable(address(this)),\n                        src1inch.data\n                    );\n                    fee = (bridgeAmount * srcExternalFeeRate) / FEE_BASE;\n                } else {\n                    // swap via WOOFi\n                    bridgeAmount = wooRouter.swap(\n                        srcInfos.fromToken,\n                        srcInfos.bridgeToken,\n                        srcInfos.fromAmount,\n                        srcInfos.minBridgeAmount,\n                        payable(address(this)),\n                        to\n                    );\n                }\n            } else {\n                require(\n                    srcInfos.fromAmount == srcInfos.minBridgeAmount,\n                    \"WooCrossChainRouterV3: !srcInfos.minBridgeAmount\"\n                );\n                bridgeAmount = srcInfos.fromAmount;\n            }\n\n            require(\n                bridgeAmount <= IERC20(srcInfos.bridgeToken).balanceOf(address(this)),\n                \"WooCrossChainRouterV3: !bridgeAmount\"\n            );\n        }\n\n        // Step 3: deduct the swap fee\n        bridgeAmount -= fee;\n\n        // Step 4: cross chain swap by StargateRouter\n        _bridgeByStargate(refId, to, msgValue, bridgeAmount, srcInfos, dstInfos, dst1inch);\n\n        emit WooCrossSwapOnSrcChain(\n            refId,\n            _msgSender(),\n            to,\n            srcInfos.fromToken,\n            srcInfos.fromAmount,\n            srcInfos.bridgeToken,\n            srcInfos.minBridgeAmount,\n            bridgeAmount,\n            src1inch.swapRouter == address(0) ? 0 : 1,\n            fee\n        );\n    }\n\n    function sgReceive(\n        uint16, // srcChainId\n        bytes memory, // srcAddress\n        uint256, // nonce\n        address bridgedToken,\n        uint256 amountLD,\n        bytes memory payload\n    ) external {\n        require(msg.sender == sgInfo.sgRouter(), \"WooCrossChainRouterV3: INVALID_CALLER\");\n\n        // make sure the same order to abi.encode when decode payload\n        (uint256 refId, address to, address toToken, uint256 minToAmount, Dst1inch memory dst1inch) = abi.decode(\n            payload,\n            (uint256, address, address, uint256, Dst1inch)\n        );\n\n        // toToken won't be SGETH, and bridgedToken won't be ETH_PLACEHOLDER_ADDR\n        if (bridgedToken == sgInfo.sgETHs(sgInfo.sgChainIdLocal())) {\n            // bridgedToken is SGETH, received native token\n            _handleNativeReceived(refId, to, toToken, amountLD, minToAmount, dst1inch);\n        } else {\n            // bridgedToken is not SGETH, received ERC20 token\n            _handleERC20Received(refId, to, toToken, bridgedToken, amountLD, minToAmount, dst1inch);\n        }\n    }\n\n    function quoteLayerZeroFee(\n        uint256 refId,\n        address to,\n        DstInfos calldata dstInfos,\n        Dst1inch calldata dst1inch\n    ) external view returns (uint256, uint256) {\n        bytes memory payload = abi.encode(refId, to, dstInfos.toToken, dstInfos.minToAmount, dst1inch);\n        IStargateRouter.lzTxObj memory obj = IStargateRouter.lzTxObj(\n            dstInfos.dstGasForCall,\n            dstInfos.airdropNativeAmount,\n            abi.encodePacked(to)\n        );\n        IStargateRouter stargateRouter = IStargateRouter(sgInfo.sgRouter());\n        return\n            stargateRouter.quoteLayerZeroFee(\n                dstInfos.chainId,\n                1, // https://stargateprotocol.gitbook.io/stargate/developers/function-types\n                obj.dstNativeAddr,\n                payload,\n                obj\n            );\n    }\n\n    /// @dev OKAY to be public method\n    function claimFee(address token) external nonReentrant {\n        require(feeAddr != address(0), \"WooCrossChainRouterV3: !feeAddr\");\n        uint256 amount = _generalBalanceOf(token, address(this));\n        if (amount > 0) {\n            if (token == ETH_PLACEHOLDER_ADDR) {\n                TransferHelper.safeTransferETH(feeAddr, amount);\n            } else {\n                TransferHelper.safeTransfer(token, feeAddr, amount);\n            }\n        }\n    }\n\n    function _bridgeByStargate(\n        uint256 refId,\n        address payable to,\n        uint256 msgValue,\n        uint256 bridgeAmount,\n        SrcInfos memory srcInfos,\n        DstInfos calldata dstInfos,\n        Dst1inch calldata dst1inch\n    ) internal {\n        require(\n            sgInfo.sgPoolIds(sgInfo.sgChainIdLocal(), srcInfos.bridgeToken) > 0,\n            \"WooCrossChainRouterV3: !srcInfos.bridgeToken\"\n        );\n        require(\n            sgInfo.sgPoolIds(dstInfos.chainId, dstInfos.bridgeToken) > 0,\n            \"WooCrossChainRouterV3: !dstInfos.bridgeToken\"\n        );\n\n        bytes memory payload = abi.encode(refId, to, dstInfos.toToken, dstInfos.minToAmount, dst1inch);\n\n        uint256 dstMinBridgeAmount = (bridgeAmount * (10000 - bridgeSlippage)) / 10000;\n        bytes memory dstWooCrossChainRouter = abi.encodePacked(wooCrossRouters[dstInfos.chainId]);\n\n        IStargateRouter.lzTxObj memory obj = IStargateRouter.lzTxObj(\n            dstInfos.dstGasForCall,\n            dstInfos.airdropNativeAmount,\n            abi.encodePacked(to)\n        );\n        IStargateRouter stargateRouter = IStargateRouter(sgInfo.sgRouter());\n\n        if (srcInfos.bridgeToken == weth) {\n            IWETH(weth).withdraw(bridgeAmount);\n            msgValue += bridgeAmount;\n        } else {\n            TransferHelper.safeApprove(srcInfos.bridgeToken, sgInfo.sgRouter(), bridgeAmount);\n        }\n\n        stargateRouter.swap{value: msgValue}(\n            dstInfos.chainId, // dst chain id\n            sgInfo.sgPoolIds(sgInfo.sgChainIdLocal(), srcInfos.bridgeToken), // bridge token's pool id on src chain\n            sgInfo.sgPoolIds(dstInfos.chainId, dstInfos.bridgeToken), // bridge token's pool id on dst chain\n            payable(_msgSender()), // rebate address\n            bridgeAmount, // swap amount on src chain\n            dstMinBridgeAmount, // min received amount on dst chain\n            obj, // config: dstGasForCall, dstAirdropNativeAmount, dstReceiveAirdropNativeTokenAddr\n            dstWooCrossChainRouter, // smart contract to call on dst chain\n            payload // payload to piggyback\n        );\n    }\n\n    function _handleNativeReceived(\n        uint256 refId,\n        address to,\n        address toToken,\n        uint256 bridgedAmount,\n        uint256 minToAmount,\n        Dst1inch memory dst1inch\n    ) internal {\n        address msgSender = _msgSender();\n\n        if (toToken == ETH_PLACEHOLDER_ADDR) {\n            // Directly transfer ETH\n            TransferHelper.safeTransferETH(to, bridgedAmount);\n            emit WooCrossSwapOnDstChain(\n                refId,\n                msgSender,\n                to,\n                weth,\n                bridgedAmount,\n                toToken,\n                ETH_PLACEHOLDER_ADDR,\n                minToAmount,\n                bridgedAmount,\n                dst1inch.swapRouter == address(0) ? 0 : 1,\n                0\n            );\n            return;\n        }\n\n        // Swap required!\n        IWETH(weth).deposit{value: bridgedAmount}();\n\n        if (dst1inch.swapRouter != address(0)) {\n            uint256 fee = (bridgedAmount * dstExternalFeeRate) / FEE_BASE;\n            uint256 swapAmount = bridgedAmount - fee;\n            TransferHelper.safeApprove(weth, address(wooRouter), swapAmount);\n            try\n                wooRouter.externalSwap(\n                    dst1inch.swapRouter,\n                    dst1inch.swapRouter,\n                    weth,\n                    toToken,\n                    swapAmount,\n                    minToAmount,\n                    payable(to),\n                    dst1inch.data\n                )\n            returns (uint256 realToAmount) {\n                emit WooCrossSwapOnDstChain(\n                    refId,\n                    msgSender,\n                    to,\n                    weth,\n                    swapAmount,\n                    toToken,\n                    toToken,\n                    minToAmount,\n                    realToAmount,\n                    dst1inch.swapRouter == address(0) ? 0 : 1,\n                    fee\n                );\n            } catch {\n                TransferHelper.safeApprove(weth, address(wooRouter), 0);\n                TransferHelper.safeTransfer(weth, to, bridgedAmount);\n                emit WooCrossSwapOnDstChain(\n                    refId,\n                    msgSender,\n                    to,\n                    weth,\n                    bridgedAmount,\n                    toToken,\n                    weth,\n                    minToAmount,\n                    bridgedAmount,\n                    dst1inch.swapRouter == address(0) ? 0 : 1,\n                    0\n                );\n            }\n        } else {\n            TransferHelper.safeApprove(weth, address(wooRouter), bridgedAmount);\n            try wooRouter.swap(weth, toToken, bridgedAmount, minToAmount, payable(to), to) returns (\n                uint256 realToAmount\n            ) {\n                emit WooCrossSwapOnDstChain(\n                    refId,\n                    msgSender,\n                    to,\n                    weth,\n                    bridgedAmount,\n                    toToken,\n                    toToken,\n                    minToAmount,\n                    realToAmount,\n                    dst1inch.swapRouter == address(0) ? 0 : 1,\n                    0\n                );\n            } catch {\n                TransferHelper.safeApprove(weth, address(wooRouter), 0);\n                TransferHelper.safeTransfer(weth, to, bridgedAmount);\n                emit WooCrossSwapOnDstChain(\n                    refId,\n                    msgSender,\n                    to,\n                    weth,\n                    bridgedAmount,\n                    toToken,\n                    weth,\n                    minToAmount,\n                    bridgedAmount,\n                    dst1inch.swapRouter == address(0) ? 0 : 1,\n                    0\n                );\n            }\n        }\n    }\n\n    function _handleERC20Received(\n        uint256 refId,\n        address to,\n        address toToken,\n        address bridgedToken,\n        uint256 bridgedAmount,\n        uint256 minToAmount,\n        Dst1inch memory dst1inch\n    ) internal {\n        address msgSender = _msgSender();\n\n        if (toToken == bridgedToken) {\n            TransferHelper.safeTransfer(bridgedToken, to, bridgedAmount);\n            emit WooCrossSwapOnDstChain(\n                refId,\n                msgSender,\n                to,\n                bridgedToken,\n                bridgedAmount,\n                toToken,\n                toToken,\n                minToAmount,\n                bridgedAmount,\n                dst1inch.swapRouter == address(0) ? 0 : 1,\n                0\n            );\n        } else {\n            // Deduct the external swap fee\n            uint256 fee = (bridgedAmount * dstExternalFeeRate) / FEE_BASE;\n            bridgedAmount -= fee;\n\n            TransferHelper.safeApprove(bridgedToken, address(wooRouter), bridgedAmount);\n            if (dst1inch.swapRouter != address(0)) {\n                try\n                    wooRouter.externalSwap(\n                        dst1inch.swapRouter,\n                        dst1inch.swapRouter,\n                        bridgedToken,\n                        toToken,\n                        bridgedAmount,\n                        minToAmount,\n                        payable(to),\n                        dst1inch.data\n                    )\n                returns (uint256 realToAmount) {\n                    emit WooCrossSwapOnDstChain(\n                        refId,\n                        msgSender,\n                        to,\n                        bridgedToken,\n                        bridgedAmount,\n                        toToken,\n                        toToken,\n                        minToAmount,\n                        realToAmount,\n                        dst1inch.swapRouter == address(0) ? 0 : 1,\n                        fee\n                    );\n                } catch {\n                    bridgedAmount += fee;\n                    TransferHelper.safeTransfer(bridgedToken, to, bridgedAmount);\n                    emit WooCrossSwapOnDstChain(\n                        refId,\n                        msgSender,\n                        to,\n                        bridgedToken,\n                        bridgedAmount,\n                        toToken,\n                        bridgedToken,\n                        minToAmount,\n                        bridgedAmount,\n                        dst1inch.swapRouter == address(0) ? 0 : 1,\n                        0\n                    );\n                }\n            } else {\n                try wooRouter.swap(bridgedToken, toToken, bridgedAmount, minToAmount, payable(to), to) returns (\n                    uint256 realToAmount\n                ) {\n                    emit WooCrossSwapOnDstChain(\n                        refId,\n                        msgSender,\n                        to,\n                        bridgedToken,\n                        bridgedAmount,\n                        toToken,\n                        toToken,\n                        minToAmount,\n                        realToAmount,\n                        dst1inch.swapRouter == address(0) ? 0 : 1,\n                        0\n                    );\n                } catch {\n                    TransferHelper.safeTransfer(bridgedToken, to, bridgedAmount);\n                    emit WooCrossSwapOnDstChain(\n                        refId,\n                        msgSender,\n                        to,\n                        bridgedToken,\n                        bridgedAmount,\n                        toToken,\n                        bridgedToken,\n                        minToAmount,\n                        bridgedAmount,\n                        dst1inch.swapRouter == address(0) ? 0 : 1,\n                        0\n                    );\n                }\n            }\n        }\n    }\n\n    function _generalBalanceOf(address token, address who) internal view returns (uint256) {\n        return token == ETH_PLACEHOLDER_ADDR ? who.balance : IERC20(token).balanceOf(who);\n    }\n\n    /* ----- Owner & Admin Functions ----- */\n\n    function setFeeAddr(address _feeAddr) external onlyOwner {\n        feeAddr = _feeAddr;\n    }\n\n    function setWooRouter(address _wooRouter) external onlyOwner {\n        require(_wooRouter != address(0), \"WooCrossChainRouterV3: !_wooRouter\");\n        wooRouter = IWooRouterV2(_wooRouter);\n    }\n\n    function setBridgeSlippage(uint256 _bridgeSlippage) external onlyOwner {\n        require(_bridgeSlippage <= 10000, \"WooCrossChainRouterV3: !_bridgeSlippage\");\n        bridgeSlippage = _bridgeSlippage;\n    }\n\n    function setWooCrossRouter(uint16 _chainId, address _crossRouter) external onlyOwner {\n        require(_crossRouter != address(0), \"WooCrossChainRouterV3: !_crossRouter\");\n        wooCrossRouters[_chainId] = _crossRouter;\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function inCaseTokenGotStuck(address stuckToken) external onlyOwner {\n        if (stuckToken == ETH_PLACEHOLDER_ADDR) {\n            TransferHelper.safeTransferETH(msg.sender, address(this).balance);\n        } else {\n            uint256 amount = IERC20(stuckToken).balanceOf(address(this));\n            TransferHelper.safeTransfer(stuckToken, msg.sender, amount);\n        }\n    }\n}"
    },
    {
      "filename": "WooPoolV2/contracts/CrossChain/WooCrossChainRouterV4.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.14;\n\n// OpenZeppelin Contracts\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\n// Local Contracts\nimport {IWETH} from \"../interfaces/IWETH.sol\";\nimport {IWooCrossChainRouterV3} from \"../interfaces/CrossChain/IWooCrossChainRouterV3.sol\";\nimport {IWooRouterV2} from \"../interfaces/IWooRouterV2.sol\";\nimport {IStargateEthVault} from \"../interfaces/Stargate/IStargateEthVault.sol\";\nimport {IStargateRouter} from \"../interfaces/Stargate/IStargateRouter.sol\";\nimport {ILzApp} from \"../interfaces/LayerZero/ILzApp.sol\";\nimport {ISgInfo} from \"../interfaces/CrossChain/ISgInfo.sol\";\n\nimport {TransferHelper} from \"@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\";\n\n/// @title cross chain router implementation, version 3.\n/// @notice Router for stateless execution of cross chain swap against WOOFi or 1inch swap.\n/// @custom:stargate-contracts https://stargateprotocol.gitbook.io/stargate/developers/contract-addresses/mainnet\ncontract WooCrossChainRouterV4 is IWooCrossChainRouterV3, Ownable, Pausable, ReentrancyGuard {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /* ----- Constants ----- */\n\n    address public constant ETH_PLACEHOLDER_ADDR = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /* ----- Variables ----- */\n\n    IWooRouterV2 public wooRouter;\n    ISgInfo public sgInfo;\n\n    address public immutable weth;\n    address public feeAddr;\n    uint256 public bridgeSlippage; // 1 in 10000th: default 1%\n\n    uint16 public srcExternalFeeRate; // unit: 0.1 bps (1e6 = 100%, 25 = 2.5 bps)\n    uint16 public dstExternalFeeRate; // unit: 0.1 bps (1e6 = 100%, 25 = 2.5 bps)\n    uint256 public constant FEE_BASE = 1e5;\n\n    mapping(uint16 => address) public wooCrossRouters; // chainId => WooCrossChainRouterV3 address\n\n    receive() external payable {}\n\n    constructor(\n        address _weth,\n        address _wooRouter,\n        address _sgInfo\n    ) {\n        weth = _weth;\n        wooRouter = IWooRouterV2(_wooRouter);\n        sgInfo = ISgInfo(_sgInfo);\n\n        bridgeSlippage = 100;\n\n        srcExternalFeeRate = 25;\n        dstExternalFeeRate = 25;\n    }\n\n    /* ----- Functions ----- */\n\n    function crossSwap(\n        uint256 refId,\n        address payable to,\n        SrcInfos memory srcInfos,\n        DstInfos calldata dstInfos,\n        Src1inch calldata src1inch,\n        Dst1inch calldata dst1inch\n    ) external payable whenNotPaused nonReentrant {\n        require(srcInfos.fromToken != address(0), \"WooCrossChainRouterV3: !srcInfos.fromToken\");\n        require(\n            dstInfos.toToken != address(0) && dstInfos.toToken != sgInfo.sgETHs(dstInfos.chainId),\n            \"WooCrossChainRouterV3: !dstInfos.toToken\"\n        );\n        require(to != address(0), \"WooCrossChainRouterV3: !to\");\n\n        uint256 msgValue = msg.value;\n        uint256 bridgeAmount;\n        uint256 fee = 0;\n\n        {\n            // Step 1: transfer\n            if (srcInfos.fromToken == ETH_PLACEHOLDER_ADDR) {\n                require(srcInfos.fromAmount <= msgValue, \"WooCrossChainRouterV3: !srcInfos.fromAmount\");\n                srcInfos.fromToken = weth;\n                IWETH(weth).deposit{value: srcInfos.fromAmount}();\n                msgValue -= srcInfos.fromAmount;\n            } else {\n                TransferHelper.safeTransferFrom(srcInfos.fromToken, msg.sender, address(this), srcInfos.fromAmount);\n            }\n\n            // Step 2: local swap by 1inch router\n            if (srcInfos.fromToken != srcInfos.bridgeToken) {\n                TransferHelper.safeApprove(srcInfos.fromToken, address(wooRouter), srcInfos.fromAmount);\n                if (src1inch.swapRouter != address(0)) {\n                    // external swap via 1inch\n                    bridgeAmount = wooRouter.externalSwap(\n                        src1inch.swapRouter,\n                        src1inch.swapRouter,\n                        srcInfos.fromToken,\n                        srcInfos.bridgeToken,\n                        srcInfos.fromAmount,\n                        srcInfos.minBridgeAmount,\n                        payable(address(this)),\n                        src1inch.data\n                    );\n                    fee = (bridgeAmount * srcExternalFeeRate) / FEE_BASE;\n                } else {\n                    // swap via WOOFi\n                    bridgeAmount = wooRouter.swap(\n                        srcInfos.fromToken,\n                        srcInfos.bridgeToken,\n                        srcInfos.fromAmount,\n                        srcInfos.minBridgeAmount,\n                        payable(address(this)),\n                        to\n                    );\n                }\n            } else {\n                require(\n                    srcInfos.fromAmount == srcInfos.minBridgeAmount,\n                    \"WooCrossChainRouterV3: !srcInfos.minBridgeAmount\"\n                );\n                bridgeAmount = srcInfos.fromAmount;\n            }\n\n            require(\n                bridgeAmount <= IERC20(srcInfos.bridgeToken).balanceOf(address(this)),\n                \"WooCrossChainRouterV3: !bridgeAmount\"\n            );\n        }\n\n        // Step 3: deduct the swap fee\n        bridgeAmount -= fee;\n\n        // Step 4: cross chain swap by StargateRouter\n        _bridgeByStargate(refId, to, msgValue, bridgeAmount, srcInfos, dstInfos, dst1inch);\n\n        emit WooCrossSwapOnSrcChain(\n            refId,\n            _msgSender(),\n            to,\n            srcInfos.fromToken,\n            srcInfos.fromAmount,\n            srcInfos.bridgeToken,\n            srcInfos.minBridgeAmount,\n            bridgeAmount,\n            src1inch.swapRouter == address(0) ? 0 : 1,\n            fee\n        );\n    }\n\n    function sgReceive(\n        uint16, // srcChainId\n        bytes memory, // srcAddress\n        uint256, // nonce\n        address bridgedToken,\n        uint256 amountLD,\n        bytes memory payload\n    ) external {\n        require(msg.sender == sgInfo.sgRouter(), \"WooCrossChainRouterV3: INVALID_CALLER\");\n\n        // make sure the same order to abi.encode when decode payload\n        (uint256 refId, address to, address toToken, uint256 minToAmount, Dst1inch memory dst1inch) = abi.decode(\n            payload,\n            (uint256, address, address, uint256, Dst1inch)\n        );\n\n        // toToken won't be SGETH, and bridgedToken won't be ETH_PLACEHOLDER_ADDR\n        if (bridgedToken == sgInfo.sgETHs(sgInfo.sgChainIdLocal())) {\n            // bridgedToken is SGETH, received native token\n            _handleNativeReceived(refId, to, toToken, amountLD, minToAmount, dst1inch);\n        } else {\n            // bridgedToken is not SGETH, received ERC20 token\n            _handleERC20Received(refId, to, toToken, bridgedToken, amountLD, minToAmount, dst1inch);\n        }\n    }\n\n    function quoteLayerZeroFee(\n        uint256 refId,\n        address to,\n        DstInfos calldata dstInfos,\n        Dst1inch calldata dst1inch\n    ) external view returns (uint256, uint256) {\n        bytes memory payload = abi.encode(refId, to, dstInfos.toToken, dstInfos.minToAmount, dst1inch);\n        IStargateRouter.lzTxObj memory obj = IStargateRouter.lzTxObj(\n            dstInfos.dstGasForCall,\n            dstInfos.airdropNativeAmount,\n            abi.encodePacked(to)\n        );\n        IStargateRouter stargateRouter = IStargateRouter(sgInfo.sgRouter());\n        return\n            stargateRouter.quoteLayerZeroFee(\n                dstInfos.chainId,\n                1, // https://stargateprotocol.gitbook.io/stargate/developers/function-types\n                obj.dstNativeAddr,\n                payload,\n                obj\n            );\n    }\n\n    /// @dev OKAY to be public method\n    function claimFee(address token) external nonReentrant {\n        require(feeAddr != address(0), \"WooCrossChainRouterV3: !feeAddr\");\n        uint256 amount = _generalBalanceOf(token, address(this));\n        if (amount > 0) {\n            if (token == ETH_PLACEHOLDER_ADDR) {\n                TransferHelper.safeTransferETH(feeAddr, amount);\n            } else {\n                TransferHelper.safeTransfer(token, feeAddr, amount);\n            }\n        }\n    }\n\n    function _bridgeByStargate(\n        uint256 refId,\n        address payable to,\n        uint256 msgValue,\n        uint256 bridgeAmount,\n        SrcInfos memory srcInfos,\n        DstInfos calldata dstInfos,\n        Dst1inch calldata dst1inch\n    ) internal {\n        require(\n            sgInfo.sgPoolIds(sgInfo.sgChainIdLocal(), srcInfos.bridgeToken) > 0,\n            \"WooCrossChainRouterV3: !srcInfos.bridgeToken\"\n        );\n        require(\n            sgInfo.sgPoolIds(dstInfos.chainId, dstInfos.bridgeToken) > 0,\n            \"WooCrossChainRouterV3: !dstInfos.bridgeToken\"\n        );\n\n        bytes memory payload = abi.encode(refId, to, dstInfos.toToken, dstInfos.minToAmount, dst1inch);\n\n        uint256 dstMinBridgeAmount = (bridgeAmount * (10000 - bridgeSlippage)) / 10000;\n        bytes memory dstWooCrossChainRouter = abi.encodePacked(wooCrossRouters[dstInfos.chainId]);\n\n        IStargateRouter.lzTxObj memory obj = IStargateRouter.lzTxObj(\n            dstInfos.dstGasForCall,\n            dstInfos.airdropNativeAmount,\n            abi.encodePacked(to)\n        );\n        IStargateRouter stargateRouter = IStargateRouter(sgInfo.sgRouter());\n\n        if (srcInfos.bridgeToken == weth) {\n            IWETH(weth).withdraw(bridgeAmount);\n            msgValue += bridgeAmount;\n        } else {\n            TransferHelper.safeApprove(srcInfos.bridgeToken, sgInfo.sgRouter(), bridgeAmount);\n        }\n\n        stargateRouter.swap{value: msgValue}(\n            dstInfos.chainId, // dst chain id\n            sgInfo.sgPoolIds(sgInfo.sgChainIdLocal(), srcInfos.bridgeToken), // bridge token's pool id on src chain\n            sgInfo.sgPoolIds(dstInfos.chainId, dstInfos.bridgeToken), // bridge token's pool id on dst chain\n            payable(_msgSender()), // rebate address\n            bridgeAmount, // swap amount on src chain\n            dstMinBridgeAmount, // min received amount on dst chain\n            obj, // config: dstGasForCall, dstAirdropNativeAmount, dstReceiveAirdropNativeTokenAddr\n            dstWooCrossChainRouter, // smart contract to call on dst chain\n            payload // payload to piggyback\n        );\n    }\n\n    function _handleNativeReceived(\n        uint256 refId,\n        address to,\n        address toToken,\n        uint256 bridgedAmount,\n        uint256 minToAmount,\n        Dst1inch memory dst1inch\n    ) internal {\n        address msgSender = _msgSender();\n\n        if (toToken == ETH_PLACEHOLDER_ADDR) {\n            // Directly transfer ETH\n            TransferHelper.safeTransferETH(to, bridgedAmount);\n            emit WooCrossSwapOnDstChain(\n                refId,\n                msgSender,\n                to,\n                weth,\n                bridgedAmount,\n                toToken,\n                ETH_PLACEHOLDER_ADDR,\n                minToAmount,\n                bridgedAmount,\n                dst1inch.swapRouter == address(0) ? 0 : 1,\n                0\n            );\n            return;\n        }\n\n        // Swap required!\n        IWETH(weth).deposit{value: bridgedAmount}();\n\n        if (dst1inch.swapRouter != address(0)) {\n            uint256 fee = (bridgedAmount * dstExternalFeeRate) / FEE_BASE;\n            uint256 swapAmount = bridgedAmount - fee;\n            TransferHelper.safeApprove(weth, address(wooRouter), swapAmount);\n            try\n                wooRouter.externalSwap(\n                    dst1inch.swapRouter,\n                    dst1inch.swapRouter,\n                    weth,\n                    toToken,\n                    swapAmount,\n                    minToAmount,\n                    payable(to),\n                    dst1inch.data\n                )\n            returns (uint256 realToAmount) {\n                emit WooCrossSwapOnDstChain(\n                    refId,\n                    msgSender,\n                    to,\n                    weth,\n                    swapAmount,\n                    toToken,\n                    toToken,\n                    minToAmount,\n                    realToAmount,\n                    dst1inch.swapRouter == address(0) ? 0 : 1,\n                    fee\n                );\n            } catch {\n                TransferHelper.safeApprove(weth, address(wooRouter), 0);\n                TransferHelper.safeTransfer(weth, to, bridgedAmount);"
    }
  ]
}