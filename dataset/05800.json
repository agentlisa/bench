{
  "Title": "[H-01] Intrinsic arbitrage from price discrepancy",
  "Content": "\nThe up to 2 % price discrepancy from Chainlink creates an intrinsic arbitrage. Especially, it makes withdrawals worth more than deposits in the sense that one can immediately withdraw more than just deposited.\n\n### Proof of Concept\n\nWhen [depositing ETH into AfEth](https://github.com/code-423n4/2023-09-asymmetry/blob/6b4867491350f8327d0ac4f496f263642cf3c1be/contracts/AfEth.sol#L148-L169), the ETH is split according to `ratio` and sold for safEth and vAfEth. The received share of afEth is then determined by the value in ETH of the resulting amounts of safEth and vAfEth. Note that there are two prices involved here: the true price at which ETH is traded for safEth and vAfEth (in `sellCvx()` and `buyCvx()`), and the estimated value in ETH that safEth and vAfEth is considered to have (`ISafEth.approxPrice()` and `VotiumStrategy.price()`). These are not necessarily the same.\n\nIf the ratio by which the deposited ETH is split is not the same as the ratio of the true values of the underlying assets, this implies that a deposit implicitly makes a trade between safEth and vAfEth according to the estimated price which may thus differ from the true price obtained when withdrawing. This presents an arbitrage opportunity.\nNote that if all prices were the same it would not matter if safEth is \"traded\" for vAfEth within a deposit as the trade then makes no change in the total value deposited.\n\nThe conditions for this issue is thus that `VotiumStrategy.price()` is different from the price obtained by `sellCvx()` and `buyCvx()`, and that the deposit ratio is not the same as the withdrawal ratio.\n\n[`VotiumStrategy.price()`](https://github.com/code-423n4/2023-09-asymmetry/blob/6b4867491350f8327d0ac4f496f263642cf3c1be/contracts/strategies/votium/VotiumStrategy.sol#L31-L33) in particular is [based on a Chainlink oracle](https://github.com/code-423n4/2023-09-asymmetry/blob/6b4867491350f8327d0ac4f496f263642cf3c1be/contracts/strategies/votium/VotiumStrategyCore.sol#L156-L186) with a [2 % deviation threshold](https://data.chain.link/ethereum/mainnet/crypto-eth/cvx-eth), which means that the true price is allowed to deviate up to 2 %, within 24 hours, from the reported price. `ISafEth.approxPrice()` may perhaps be similarly inaccurate (I have not looked into this).\n\nThe ratio can skew in this way for two reasons. One is when the `ratio` is different from the ratio of the underlying balances, such as when `ratio` is changed. Deposits are made according to `ratio` but withdrawals are made proportionally from the extant balances. In this case the implicit trade between safEth and vAfEth can happen in either direction, either beneficial or detrimental to the depositor (if there is a price discrepancy).\nThe other is caused by the price discrepancy itself when depositing. In this case it is always beneficial to the depositor (and detrimental to the holders).\n\n**Example 1a - reconverging ratio, vAfEth is actually more expensive**\nSuppose the contract holds 100 safEth and 0 vAfEth, but that the `ratio` has now been changed to 0. Further suppose that the contract thinks all prices are 1, but that 100 ETH actually trades for 102 vAfEth.\nThen depositing 100 ETH will convert it to 102 vAfEth, which will be valued as 102 ETH. This mints 102 afEth.\nThe balances are now 100 safEth and 102 vAfEth and the total supply is 202 afEth.\nWithdrawing 102 afEth converts 102/202 of the underlying, i.e. 50.495 safEth and 51.505 vAfEth, into 50.495 + 51.505/1.02 = 100.99 ETH.\n\n**Example 1b - reconverging ratio, vAfEth is actually cheaper**\nSuppose the contract holds 100 safEth and 0 vAfEth, but that the `ratio` has now been changed to 0. Further suppose that the contract thinks all prices are 1, but that 100 ETH actually trades for 98 vAfEth.\nThen depositing 100 ETH will convert it to 98 vAfEth, which will be valued as 98 ETH. This mints 98 afEth.\nThe balances are now 100 safEth and 98 vAfEth and the total supply is 198 afEth.\nWithdrawing 98 afEth converts 98/198 of the underlying, i.e. 49.495 safEth and 48.505 vAfEth, into 49.495 + 48.505/0.98 = 98.99 ETH.\n\n**Example 2a - stable ratio, vAfEth is actually more expensive**\nSuppose the contract holds 50 safEth and 50 vAfEth and that the `ratio` is 0.5. Further suppose that the contract thinks all prices are 1 but that 50 ETH actually trades for 51 vAfEth.\nThen depositing 100 ETH will convert 50 ETH to 50 safEth and 50 ETH to 51 vAfEth, which will be valued as 101 ETH. This mints 101 afEth.\nThe balances are now 100 safEth and 101 vAfEth and the total supply is 201 afEth.\nWithdrawing 101 afEth converts 101/201 of the underlying, i.e. 50.249 safEth and 50.751 vAfEth, into 50.249 + 50.751/1.02 = 100.005 ETH.\n\n**Example 2b - stable ratio, vAfEth is actually cheaper**\nSuppose the contract holds 50 safEth and 50 vAfEth and that the `ratio` is 0.5. Further suppose that the contract thinks all prices are 1 but that 50 ETH actually trades for 49 vAfEth.\nThen depositing 100 ETH will convert 50 ETH to 50 safEth and 50 ETH to 49 vAfEth, which will be valued as 99 ETH. This mints 99 afEth.\nThe balances are now 100 safEth and 99 vAfEth and the total supply is 199 afEth.\nWithdrawing 99 afEth converts 99/199 of the underlying, i.e. 49.749 safEth and 49.251 vAfEth, into 49.749 + 49.251/0.98 = 100.005 ETH.\n\nThus one can make a profit by depositing and immediately withdrawing. Immediate withdrawals are possible at the moment locks expire (and before they have been relocked), but it may be enough to just immediately request a withdrawal if the true price is the same (or better) when eventually withdrawn.\n\nThe price discrepancy will appear whenever there are price fluctuations of up to 2 % within 24 hours, which seems quite likely.\n\nRegarding the case where the underlying is reconverging after a change of `ratio` it is worth noting that convergence is quite slow. Several times the entire balances must be traded before the new ratio is approached.\n\n### Recommended Mitigation Steps\nWe want a  to not diminish the value of previous deposits. That is, withdrawing $w$ shares should return at least as much if withdrawn after a deposit which mints $m$ shares as if withdrawn before.\n\nNote that letting a share represent each underlying in equal proportions is the only way to guarantee fairness and fungibility, so we must leave the withdrawal calculation as it is.\n \nLet $d_s$ and $d_v$ be the ether amounts deposited in SafEth and VotiumStrategy, respectively. Let $B_s$ and $B_v$ be the respective balances in AfEth and $T$ the total supply of afEth. Let $P_s(x)$ be the amount of safEth obtained by selling $x$ ether for safEth, and $P_s^{-1}(y)$ the amount of ether obtained by selling safEth for ether (note the abuse of notation and that $P_s^{-1}(P_s(x)) \\leq x$ because of fees, spread, slippage etc.), and similarly $P_v$ and $P_v^{-1}$ for vAfEth.\n\nWithdrawing $w$ now should return at most what it would return after a deposit of $d_s + d_v$, i.e.\n \n```math\nP_s^{-1}(\\frac{w}{T}B_s) + P_v^{-1}(\\frac{w}{T}B_v) \\leq \nP_s^{-1}(\\frac{w}{T+m}(B_s + P_s(d_s))) + P_v^{-1}(\\frac{w}{T+m}(B_v + P_v(d_v)))\n```\n\nFor small deposits and withdrawals the price functions are approximately linear and we can write e.g. $P_s(d_s)$ as $P_s d_s$, i.e. $P_s$ is just a price point, and we get\n```math\n\\frac{1}{T}(P_s^{-1}B_s + P_v^{-1}B_v) \\leq \n\\frac{1}{T+m}(P_s^{-1}(B_s + P_s d_s) + P_v^{-1}(B_v + P_v d_v))$\n```\n\nSolving for $m$ we get\n```math\nm \\leq \\frac{P_s^{-1}P_s d_s + P_v^{-1}P_v d_v}{P_s^{-1}B_s + P_v^{-1}B_v}T\n```\n\nThe difference from the current implementation is that instead of the true prices $P_s^{-1}$ and $P_v^{-1}$, the oracle prices, which we will denote $\\hat{P}^{-1}_s$ and $\\hat{P}^{-1}_v$, are used instead, i.e.\n```math\nm = \\frac{\\hat{P}^{-1}_s P_s d_s + \\hat{P}^{-1}_v P_v d_v}\n{\\hat{P}^{-1}_s B_s + \\hat{P}^{-1}_v B_v}T\n```\n\nSince we know the true prices up to within certain bounds, we can minimise $m$, as a function of $P_s^{-1}$ and $P_v^{-1}$, within these bounds.\nThe gradient of $m(P_s^{-1}, P_v^{-1})$ is\n```math\n\\frac{P_s d_s B_v - P_v d_v B_s}\n{(P^{-1}_s B_s + P^{-1}_v B_v)^2}\n(P^{-1}_v, -P^{-1}_s)\n```\n\nso if $P_s d_s B_v - P_v d_v B_s > 0$ we pick the lower right corner (maximal $P_s^{-1}$, minimal $P_v^{-1}$), and if $P_s d_s B_v - P_v d_v B_s < 0$ we pick the upper left corner (minimal $P_s^{-1}$, maximal $P_v^{-1}$).\nIn the case of equality we can use any (non-zero) prices.\n\nWe minimise within the bounds, but we of course want the bounds to be as tight as possible, so that this minimum is as high as possible.\n\nThe oracle prices provide us with good bounds, namely $P_s^{-1} \\in [0.98 \\cdot \\hat{P}^{-1}_s, 1.02 \\cdot \\hat{P}^{-1}_s]$ and $P_v^{-1} \\in [0.98 \\cdot \\hat{P}^{-1}_v, 1.02 \\cdot \\hat{P}^{-1}_v]$.\n\nThere are a few ways to further improve the bounds. During the deposit we learn $P_s$ and $P_v$, from which we can infer $P_s^{-1} \\leq 1/P_s$ and $P_v^{-1} \\leq 1/P_v$ (equality in the case of no exchange losses). If we know that there is some minimum percentage lost (e.g. exchange fees, slippage, spread) we can refine these to $P_s^{-1} \\leq k_s/P_s$ and $P_v^{-1} \\leq k_v/P_v$, where $k_s, k_v < 1$ is some factor adjusting for these losses (e.g. $k_s = 0.99$ if there is at least (another) 1 \\% lost when selling for ether).\n\nIf the trading losses are significant it may be necessary to take these into account even for the bounds from the oracle prices, such that both upper and lower bounds are slightly reduced.\n\n**[elmutt (Asymmetry) confirmed](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/62#issuecomment-1746998418)**\n\n**[adriro (Warden) commented](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/62#issuecomment-1752039853):**\n > @0xleastwood - I'm really sorry to do this at this stage, but did you have the chance to go through these scenarios? Seems there are lot of suppositions, some of which the same warden is confusingly invalidating in other discussions.\n> \n> I think examples 1a and 1b have invalid assumptions (\"the contract holds 100 safEth and 0 vAfEth, but that the ratio has now been changed to 0\"). In 2a and 2b, what is \"the contract thinks all prices are..\"? How is the contract thinking prices?\n> \n> It seems this has nothing to do with the stated impact. The chainlink response is used to price vAfEth, but the core here is a discrepancy of the ratio with the underlying assets (which again confusingly the author is trying to invalidate in other issues). Furthermore the deposit/withdraw cycle can't be executed without exposure to the underlying assets due to the locking mechanism.\n\n**[0xleastwood (Judge) commented](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/62#issuecomment-1752158668):**\n> @adriro - I'll look into these, I do believe it is possible to deposit and withdraw atomically as long as there is an unlocked amount of tokens in the votium strategy contract. That would be the extent at which a withdrawal could be made \"instantly\".\n>\n> I do agree that example 1a and 1b are somewhat infeasible because the protocol team has already stated that such a ratio would not exist in the first place. However, there is validity in the other examples.\n\n**[Asymmetry commented](https://github.com/code-423n4/2023-10-asymmetry-mitigation?tab=readme-ov-file#individual-prs):**\n > After days of research we decided that this was acceptable. See the comments in [issue 62](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/62#issuecomment-1760305328) for more information.\n\n**Status**: Unmitigated. Full details in reports from adriro ([1](https://github.com/code-423n4/2023-10-asymmetry-mitigation-findings/issues/26), [2](https://github.com/code-423n4/2023-10-asymmetry-mitigation-findings/issues/45)) and [d3e4](https://github.com/code-423n4/2023-10-asymmetry-mitigation-findings/issues/12), and also included in the [Mitigation Review](#mitigation-review) section below.\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-09-asymmetry",
  "Code": [
    {
      "filename": "contracts/AfEth.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"contracts/strategies/votium/VotiumStrategy.sol\";\nimport \"contracts/external_interfaces/IVotiumStrategy.sol\";\nimport \"contracts/strategies/AbstractStrategy.sol\";\n\n// AfEth is the strategy manager for safEth and votium strategies\ncontract AfEth is Initializable, OwnableUpgradeable, ERC20Upgradeable {\n    uint256 public ratio;\n    uint256 public protocolFee;\n    address public feeAddress;\n    address public constant SAF_ETH_ADDRESS =\n        0x6732Efaf6f39926346BeF8b821a04B6361C4F3e5;\n    address public vEthAddress; // Votium Strategy Address\n    uint256 public latestWithdrawId;\n\n    struct WithdrawInfo {\n        address owner;\n        uint256 amount;\n        uint256 safEthWithdrawAmount;\n        uint256 vEthWithdrawId;\n        uint256 withdrawTime;\n    }\n\n    mapping(uint256 => WithdrawInfo) public withdrawIdInfo;\n    bool public pauseDeposit;\n    bool public pauseWithdraw;\n\n    error StrategyAlreadyAdded();\n    error StrategyNotFound();\n    error InsufficientBalance();\n    error InvalidStrategy();\n    error InvalidFee();\n    error CanNotWithdraw();\n    error NotOwner();\n    error FailedToSend();\n    error FailedToDeposit();\n    error Paused();\n    error BelowMinOut();\n\n    event WithdrawRequest(\n        address indexed account,\n        uint256 amount,\n        uint256 withdrawId,\n        uint256 withdrawTime\n    );\n\n    address private constant CVX_ADDRESS =\n        0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B;\n    address private constant VLCVX_ADDRESS =\n        0x72a19342e8F1838460eBFCCEf09F6585e32db86E;\n\n    uint256 public pendingSafEthWithdraws;\n\n    modifier onlyWithdrawIdOwner(uint256 withdrawId) {\n        if (withdrawIdInfo[withdrawId].owner != msg.sender) revert NotOwner();\n        _;\n    }\n\n    // As recommended by https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n        @notice - Initialize values for the contracts\n        @dev - This replaces the constructor for upgradeable contracts\n    */\n    function initialize() external initializer {\n        _transferOwnership(msg.sender);\n        ratio = 5e17;\n    }\n\n    /**\n     * @notice - Sets the strategy addresses for safEth and votium\n     * @param _vEthAddress - vEth strategy address\n     */\n    function setStrategyAddress(address _vEthAddress) external onlyOwner {\n        vEthAddress = _vEthAddress;\n    }\n\n    /**\n        @notice - Sets the target ratio of safEth to votium. \n        @notice target ratio is maintained by directing rewards into either safEth or votium strategy\n        @param _newRatio - New ratio of safEth to votium\n    */\n    function setRatio(uint256 _newRatio) public onlyOwner {\n        ratio = _newRatio;\n    }\n\n    /**\n        @notice - Sets the protocol fee address which takes a percentage of the rewards.\n        @param _newFeeAddress - New protocol fee address to collect rewards\n    */\n    function setFeeAddress(address _newFeeAddress) public onlyOwner {\n        feeAddress = _newFeeAddress;\n    }\n\n    /**\n        @notice - Sets the protocol fee which takes a percentage of the rewards.\n        @param _newFee - New protocol fee\n    */\n    function setProtocolFee(uint256 _newFee) public onlyOwner {\n        if (_newFee > 1e18) revert InvalidFee();\n        protocolFee = _newFee;\n    }\n\n    /**\n        @notice - Enables/Disables depositing\n        @param _pauseDeposit - Bool to set pauseDeposit\n\n    */\n    function setPauseDeposit(bool _pauseDeposit) external onlyOwner {\n        pauseDeposit = _pauseDeposit;\n    }\n\n    /**\n        @notice - Enables/Disables withdrawing & requesting to withdraw\n        @param _pauseWithdraw - Bool to set pauseWithdraw\n    */\n    function setPauseWithdraw(bool _pauseWithdraw) external onlyOwner {\n        pauseWithdraw = _pauseWithdraw;\n    }\n\n    /**\n        @notice - Get's the price of afEth\n        @dev - Checks each strategy and calculates the total value in ETH divided by supply of afETH tokens\n        @return - Price of afEth\n    */\n    function price() public view returns (uint256) {\n        if (totalSupply() == 0) return 1e18;\n        AbstractStrategy vEthStrategy = AbstractStrategy(vEthAddress);\n        uint256 safEthValueInEth = (ISafEth(SAF_ETH_ADDRESS).approxPrice(true) *\n            safEthBalanceMinusPending()) / 1e18;\n        uint256 vEthValueInEth = (vEthStrategy.price() *\n            vEthStrategy.balanceOf(address(this))) / 1e18;\n        return ((vEthValueInEth + safEthValueInEth) * 1e18) / totalSupply();\n    }\n\n    /**\n        @notice - Deposits into each strategy\n        @dev - This is the entry into the protocol\n        @param _minout - Minimum amount of afEth to mint\n    */\n    function deposit(uint256 _minout) external payable virtual {\n        if (pauseDeposit) revert Paused();\n        uint256 amount = msg.value;\n        uint256 priceBeforeDeposit = price();\n        uint256 totalValue;\n\n        AbstractStrategy vStrategy = AbstractStrategy(vEthAddress);\n\n        uint256 sValue = (amount * ratio) / 1e18;\n        uint256 sMinted = sValue > 0\n            ? ISafEth(SAF_ETH_ADDRESS).stake{value: sValue}(0)\n            : 0;\n        uint256 vValue = (amount * (1e18 - ratio)) / 1e18;\n        uint256 vMinted = vValue > 0 ? vStrategy.deposit{value: vValue}() : 0;\n        totalValue +=\n            (sMinted * ISafEth(SAF_ETH_ADDRESS).approxPrice(true)) +\n            (vMinted * vStrategy.price());\n        if (totalValue == 0) revert FailedToDeposit();\n        uint256 amountToMint = totalValue / priceBeforeDeposit;\n        if (amountToMint < _minout) revert BelowMinOut();\n        _mint(msg.sender, amountToMint);\n    }\n\n    /**\n        @notice - Request to close position\n        @param _amount - Amount of afEth to withdraw\n    */\n    function requestWithdraw(uint256 _amount) external virtual {\n        uint256 withdrawTimeBefore = withdrawTime(_amount);\n        if (pauseWithdraw) revert Paused();\n        latestWithdrawId++;\n\n        // ratio of afEth being withdrawn to totalSupply\n        // we are transfering the afEth to the contract when we requestWithdraw\n        // we shouldn't include that in the withdrawRatio\n        uint256 afEthBalance = balanceOf(address(this));\n        uint256 withdrawRatio = (_amount * 1e18) /\n            (totalSupply() - afEthBalance);\n\n        _transfer(msg.sender, address(this), _amount);\n\n        uint256 votiumBalance = IERC20(vEthAddress).balanceOf(address(this));\n        uint256 votiumWithdrawAmount = (withdrawRatio * votiumBalance) / 1e18;\n        uint256 vEthWithdrawId = AbstractStrategy(vEthAddress).requestWithdraw(\n            votiumWithdrawAmount\n        );\n\n        uint256 safEthBalance = safEthBalanceMinusPending();\n\n        uint256 safEthWithdrawAmount = (withdrawRatio * safEthBalance) / 1e18;\n\n        pendingSafEthWithdraws += safEthWithdrawAmount;\n\n        withdrawIdInfo[latestWithdrawId]\n            .safEthWithdrawAmount = safEthWithdrawAmount;\n        withdrawIdInfo[latestWithdrawId].vEthWithdrawId = vEthWithdrawId;\n\n        withdrawIdInfo[latestWithdrawId].owner = msg.sender;\n        withdrawIdInfo[latestWithdrawId].amount = _amount;\n        withdrawIdInfo[latestWithdrawId].withdrawTime = withdrawTimeBefore;\n\n        emit WithdrawRequest(\n            msg.sender,\n            _amount,\n            latestWithdrawId,\n            withdrawTimeBefore\n        );\n    }\n\n    /**\n        @notice - Checks if withdraw can be executed from withdrawId\n        @param _withdrawId - Id of the withdraw request for SafEth\n        @return - Bool if withdraw can be executed\n    */\n    function canWithdraw(uint256 _withdrawId) public view returns (bool) {\n        return\n            AbstractStrategy(vEthAddress).canWithdraw(\n                withdrawIdInfo[_withdrawId].vEthWithdrawId\n            );\n    }\n\n    /**\n        @notice - Get's the withdraw time for an amount of AfEth\n        @param _amount - Amount of afETH to withdraw\n        @return - Highest withdraw time of the strategies\n    */\n    function withdrawTime(uint256 _amount) public view returns (uint256) {\n        return AbstractStrategy(vEthAddress).withdrawTime(_amount);\n    }\n\n    /**\n        @notice - Withdraw from each strategy\n        @param _withdrawId - Id of the withdraw request\n        @param _minout - Minimum amount of ETH to receive\n    */\n    function withdraw(\n        uint256 _withdrawId,\n        uint256 _minout\n    ) external virtual onlyWithdrawIdOwner(_withdrawId) {\n        if (pauseWithdraw) revert Paused();\n        uint256 ethBalanceBefore = address(this).balance;\n        WithdrawInfo memory withdrawInfo = withdrawIdInfo[_withdrawId];\n        if (!canWithdraw(_withdrawId)) revert CanNotWithdraw();\n\n        ISafEth(SAF_ETH_ADDRESS).unstake(withdrawInfo.safEthWithdrawAmount, 0);\n        AbstractStrategy(vEthAddress).withdraw(withdrawInfo.vEthWithdrawId);\n\n        _burn(address(this), withdrawIdInfo[_withdrawId].amount);\n        uint256 ethBalanceAfter = address(this).balance;\n        uint256 ethReceived = ethBalanceAfter - ethBalanceBefore;\n\n        pendingSafEthWithdraws -= withdrawInfo.safEthWithdrawAmount;\n\n        if (ethReceived < _minout) revert BelowMinOut();\n        // solhint-disable-next-line\n        (bool sent, ) = msg.sender.call{value: ethReceived}(\"\");\n        if (!sent) revert FailedToSend();\n    }\n\n    /**\n     * @notice - sells _amount of eth from votium contract\n     * @dev - puts it into safEthStrategy or votiumStrategy, whichever is underweight.\\\n     * @param _amount - amount of eth to sell\n     */\n    function depositRewards(uint256 _amount) public payable {\n        IVotiumStrategy votiumStrategy = IVotiumStrategy(vEthAddress);\n        uint256 feeAmount = (_amount * protocolFee) / 1e18;\n        if (feeAmount > 0) {\n            // solhint-disable-next-line\n            (bool sent, ) = feeAddress.call{value: feeAmount}(\"\");\n            if (!sent) revert FailedToSend();\n        }\n        uint256 amount = _amount - feeAmount;\n        uint256 safEthTvl = (ISafEth(SAF_ETH_ADDRESS).approxPrice(true) *\n            safEthBalanceMinusPending()) / 1e18;\n        uint256 votiumTvl = ((votiumStrategy.cvxPerVotium() *\n            votiumStrategy.ethPerCvx(true)) *\n            IERC20(vEthAddress).balanceOf(address(this))) / 1e36;\n        uint256 totalTvl = (safEthTvl + votiumTvl);\n        uint256 safEthRatio = (safEthTvl * 1e18) / totalTvl;\n        if (safEthRatio < ratio) {\n            ISafEth(SAF_ETH_ADDRESS).stake{value: amount}(0);\n        } else {\n            votiumStrategy.depositRewards{value: amount}(amount);\n        }\n    }\n\n    function safEthBalanceMinusPending() public view returns (uint256) {\n        return\n            IERC20(SAF_ETH_ADDRESS).balanceOf(address(this)) -\n            pendingSafEthWithdraws;\n    }\n\n    receive() external payable {}\n}"
    },
    {
      "filename": "contracts/strategies/votium/VotiumStrategy.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport \"../AbstractStrategy.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"./VotiumStrategyCore.sol\";\n\n/// @title Votium Strategy Token\n/// @author Asymmetry Finance\ncontract VotiumStrategy is VotiumStrategyCore, AbstractStrategy {\n    event WithdrawRequest(\n        address indexed user,\n        uint256 amount,\n        uint256 withdrawId\n    );\n\n    struct WithdrawRequestInfo {\n        uint256 cvxOwed;\n        bool withdrawn;\n        uint256 epoch;\n        address owner;\n    }\n\n    mapping(uint256 => WithdrawRequestInfo)\n        public withdrawIdToWithdrawRequestInfo;\n\n    /**\n     * @notice Gets price in eth\n     * @return Price of token in eth\n     */\n    function price() external view override returns (uint256) {\n        return (cvxPerVotium() * ethPerCvx(false)) / 1e18;\n    }\n\n    /**\n     * @notice Deposit eth to mint this token at current price\n     * @return mintAmount Amount of tokens minted\n     */\n    function deposit() public payable override returns (uint256 mintAmount) {\n        uint256 priceBefore = cvxPerVotium();\n        uint256 cvxAmount = buyCvx(msg.value);\n        IERC20(CVX_ADDRESS).approve(VLCVX_ADDRESS, cvxAmount);\n        ILockedCvx(VLCVX_ADDRESS).lock(address(this), cvxAmount, 0);\n        mintAmount = ((cvxAmount * 1e18) / priceBefore);\n        _mint(msg.sender, mintAmount);\n    }\n\n    /**\n     * @notice Request to withdraw from strategy emits event with eligible withdraw epoch\n     * @notice Burns afEth tokens and determines equivilent amount of cvx to start unlocking\n     * @param _amount Amount to request withdraw\n     * @return withdrawId Id of withdraw request\n     */\n    function requestWithdraw(\n        uint256 _amount\n    ) public override returns (uint256 withdrawId) {\n        latestWithdrawId++;\n        uint256 _priceInCvx = cvxPerVotium();\n\n        _burn(msg.sender, _amount);\n\n        uint256 currentEpoch = ILockedCvx(VLCVX_ADDRESS).findEpochId(\n            block.timestamp\n        );\n        (\n            ,\n            uint256 unlockable,\n            ,\n            ILockedCvx.LockedBalance[] memory lockedBalances\n        ) = ILockedCvx(VLCVX_ADDRESS).lockedBalances(address(this));\n        uint256 cvxAmount = (_amount * _priceInCvx) / 1e18;\n        cvxUnlockObligations += cvxAmount;\n\n        uint256 totalLockedBalancePlusUnlockable = unlockable +\n            IERC20(CVX_ADDRESS).balanceOf(address(this));\n\n        for (uint256 i = 0; i < lockedBalances.length; i++) {\n            totalLockedBalancePlusUnlockable += lockedBalances[i].amount;\n            // we found the epoch at which there is enough to unlock this position\n            if (totalLockedBalancePlusUnlockable >= cvxUnlockObligations) {\n                (, uint32 currentEpochStartingTime) = ILockedCvx(VLCVX_ADDRESS)\n                    .epochs(currentEpoch);\n                uint256 timeDifference = lockedBalances[i].unlockTime -\n                    currentEpochStartingTime;\n                uint256 epochOffset = timeDifference /\n                    ILockedCvx(VLCVX_ADDRESS).rewardsDuration();\n                uint256 withdrawEpoch = currentEpoch + epochOffset;\n                withdrawIdToWithdrawRequestInfo[\n                    latestWithdrawId\n                ] = WithdrawRequestInfo({\n                    cvxOwed: cvxAmount,\n                    withdrawn: false,\n                    epoch: withdrawEpoch,\n                    owner: msg.sender\n                });\n\n                emit WithdrawRequest(msg.sender, cvxAmount, latestWithdrawId);\n                return latestWithdrawId;\n            }\n        }\n        // should never get here\n        revert InvalidLockedAmount();\n    }\n\n    /**\n     * @notice Withdraws from requested withdraw if eligible epoch has passed\n     * @param _withdrawId Id of withdraw request\n     */\n    function withdraw(uint256 _withdrawId) external override {\n        if (withdrawIdToWithdrawRequestInfo[_withdrawId].owner != msg.sender)\n            revert NotOwner();\n        if (!this.canWithdraw(_withdrawId)) revert WithdrawNotReady();\n\n        if (withdrawIdToWithdrawRequestInfo[_withdrawId].withdrawn)\n            revert AlreadyWithdrawn();\n\n        relock();\n\n        uint256 cvxWithdrawAmount = withdrawIdToWithdrawRequestInfo[_withdrawId]\n            .cvxOwed;\n\n        uint256 ethReceived = sellCvx(cvxWithdrawAmount);\n        cvxUnlockObligations -= cvxWithdrawAmount;\n        withdrawIdToWithdrawRequestInfo[_withdrawId].withdrawn = true;\n\n        // solhint-disable-next-line\n        (bool sent, ) = msg.sender.call{value: ethReceived}(\"\");\n        if (!sent) revert FailedToSend();\n    }\n\n    /**\n     * @notice Relocks cvx while ensuring there is enough to cover all withdraw requests\n     * @dev This happens automatically on withdraw but will need to be manually called if no withdraws happen in an epoch where locks are expiring\n     */\n    function relock() public {\n        (, uint256 unlockable, , ) = ILockedCvx(VLCVX_ADDRESS).lockedBalances(\n            address(this)\n        );\n        if (unlockable > 0)\n            ILockedCvx(VLCVX_ADDRESS).processExpiredLocks(false);\n        uint256 cvxBalance = IERC20(CVX_ADDRESS).balanceOf(address(this));\n        uint256 cvxAmountToRelock = cvxBalance > cvxUnlockObligations\n            ? cvxBalance - cvxUnlockObligations\n            : 0;\n        if (cvxAmountToRelock > 0) {\n            IERC20(CVX_ADDRESS).approve(VLCVX_ADDRESS, cvxAmountToRelock);\n            ILockedCvx(VLCVX_ADDRESS).lock(address(this), cvxAmountToRelock, 0);\n        }\n    }\n\n    /**\n     * @notice Checks if withdraw request is eligible to be withdrawn\n     * @param _withdrawId Id of withdraw request\n     */\n    function canWithdraw(\n        uint256 _withdrawId\n    ) external view virtual override returns (bool) {\n        uint256 currentEpoch = ILockedCvx(VLCVX_ADDRESS).findEpochId(\n            block.timestamp\n        );\n        return\n            withdrawIdToWithdrawRequestInfo[_withdrawId].epoch <= currentEpoch;\n    }\n\n    /**\n     * @notice Checks how long it will take to withdraw a given amount\n     * @param _amount Amount of afEth to check how long it will take to withdraw\n     * @return When it would be withdrawable based on the amount\n     */\n    function withdrawTime(\n        uint256 _amount\n    ) external view virtual override returns (uint256) {\n        uint256 _priceInCvx = cvxPerVotium();\n        (\n            ,\n            uint256 unlockable,\n            ,\n            ILockedCvx.LockedBalance[] memory lockedBalances\n        ) = ILockedCvx(VLCVX_ADDRESS).lockedBalances(address(this));\n        uint256 cvxAmount = (_amount * _priceInCvx) / 1e18;\n        uint256 totalLockedBalancePlusUnlockable = unlockable +\n            IERC20(CVX_ADDRESS).balanceOf(address(this));\n\n        for (uint256 i = 0; i < lockedBalances.length; i++) {\n            totalLockedBalancePlusUnlockable += lockedBalances[i].amount;\n            // we found the epoch at which there is enough to unlock this position\n            if (\n                totalLockedBalancePlusUnlockable >=\n                cvxUnlockObligations + cvxAmount\n            ) {\n                return lockedBalances[i].unlockTime;\n            }\n        }\n        revert InvalidLockedAmount();\n    }\n}"
    }
  ]
}