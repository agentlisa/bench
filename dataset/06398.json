{
  "Title": "[G-01] At `toColl()` and `toAsset()` use the mapping to check if asset exists",
  "Content": "Savings: ~2.1K per call\n\nNotice this is a function that's being called frequently, and many times per tx.\n\n**Overall this can save a few thousands of gas units per tx for the most common txs (e.g. issuance, redemption)**\n\nhttps://github.com/reserve-protocol/protocol/blob/c4ec2473bbcb4831d62af55d275368e73e16b984/contracts/p1/AssetRegistry.sol#L120-L132\n\nAt `toColl()` and `toAsset()` instead of using the EnumberableSet to check that the erc20 is registered just check that the value returned from the mapping isn't zero (this is supposed to be equivalent as long as the governance doesn't register the zero address as an asset contract - maybe add a check for that at `register()`).\n\nProposed changes:\n```solidity\n\n    /// Return the Asset registered for erc20; revert if erc20 is not registered.\n    // checks: erc20 in assets\n    // returns: assets[erc20]\n    function toAsset(IERC20 erc20) external view returns (IAsset) {\n        IAsset asset = assets[erc20];\n        require(asset != IAsset(address(0)), \"erc20 unregistered\");\n        return asset;\n    }\n\n    /// Return the Collateral registered for erc20; revert if erc20 is not registered as Collateral\n    // checks: erc20 in assets, assets[erc20].isCollateral()\n    // returns: assets[erc20]\n    function toColl(IERC20 erc20) external view returns (ICollateral) {\n        IAsset coll = assets[erc20];\n        require(coll != IAsset(address(0)), \"erc20 unregistered\");\n        require(coll.isCollateral(), \"erc20 is not collateral\");\n        return ICollateral(address(coll));\n    }\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-06-reserve",
  "Code": [
    {
      "filename": "contracts/p1/AssetRegistry.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"../interfaces/IAssetRegistry.sol\";\nimport \"../interfaces/IMain.sol\";\nimport \"./mixins/Component.sol\";\n\n/// The AssetRegistry provides the mapping from ERC20 to Asset, allowing the rest of Main\n/// to think in terms of ERC20 tokens and target/ref units.\ncontract AssetRegistryP1 is ComponentP1, IAssetRegistry {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 public constant GAS_TO_RESERVE = 900000; // just enough to disable basket on n=128\n\n    // Peer-component addresses\n    IBasketHandler private basketHandler;\n    IBackingManager private backingManager;\n\n    // Registered ERC20s\n    EnumerableSet.AddressSet private _erc20s;\n\n    // Registered Assets\n    mapping(IERC20 => IAsset) private assets;\n\n    // === 3.0.0 ===\n\n    uint48 public lastRefresh; // {s}\n\n    /* ==== Contract Invariants ====\n       The contract state is just the mapping assets; _erc20s is ignored in properties.\n\n       invariant: _erc20s == keys(assets)\n       invariant: addr == assets[addr].erc20()\n           where: addr in assets\n     */\n\n    /// Initialize the AssetRegistry with assets\n    // effects: assets' = {a.erc20(): a for a in assets_}\n    function init(IMain main_, IAsset[] calldata assets_) external initializer {\n        __Component_init(main_);\n        basketHandler = main_.basketHandler();\n        backingManager = main_.backingManager();\n        uint256 length = assets_.length;\n        for (uint256 i = 0; i < length; ++i) {\n            _register(assets_[i]);\n        }\n    }\n\n    /// Update the state of all assets\n    /// @custom:refresher\n    // actions:\n    //   calls refresh(c) for c in keys(assets) when c.isCollateral()\n    //   tracks basket status on basketHandler\n    function refresh() public {\n        // It's a waste of gas to require notPausedOrFrozen because assets can be updated directly\n        uint256 length = _erc20s.length();\n        for (uint256 i = 0; i < length; ++i) {\n            assets[IERC20(_erc20s.at(i))].refresh();\n        }\n\n        basketHandler.trackStatus();\n        lastRefresh = uint48(block.timestamp); // safer to do this at end than start, actually\n    }\n\n    /// Register `asset`\n    /// If either the erc20 address or the asset was already registered, fail\n    /// @return true if the erc20 address was not already registered.\n    /// @custom:governance\n    // checks: asset.erc20() not in keys(assets) or assets[asset.erc20] == asset\n    // effects: assets' = assets.set(asset.erc20(), asset)\n    // returns: (asset.erc20 not in keys(assets))\n    function register(IAsset asset) external governance returns (bool) {\n        return _register(asset);\n    }\n\n    /// Register `asset` if and only if its erc20 address is already registered.\n    /// If the erc20 address was not registered, revert.\n    /// @return swapped If the asset was swapped for a previously-registered asset\n    /// @custom:governance\n    // contract\n    // checks: asset.erc20() in assets\n    // effects: assets' = assets + {asset.erc20(): asset}\n    // actions: if asset.erc20() is in basketHandler's basket then basketHandler.disableBasket()\n    function swapRegistered(IAsset asset) external governance returns (bool swapped) {\n        require(_erc20s.contains(address(asset.erc20())), \"no ERC20 collision\");\n\n        try basketHandler.quantity{ gas: _reserveGas() }(asset.erc20()) returns (uint192 quantity) {\n            if (quantity > 0) basketHandler.disableBasket(); // not an interaction\n        } catch {\n            basketHandler.disableBasket();\n        }\n\n        swapped = _registerIgnoringCollisions(asset);\n    }\n\n    /// Unregister an asset, requiring that it is already registered\n    /// @custom:governance\n    // checks: assets[asset.erc20()] == asset\n    // effects: assets' = assets - {asset.erc20():_} + {asset.erc20(), asset}\n    function unregister(IAsset asset) external governance {\n        require(_erc20s.contains(address(asset.erc20())), \"no asset to unregister\");\n        require(assets[asset.erc20()] == asset, \"asset not found\");\n\n        try basketHandler.quantity{ gas: _reserveGas() }(asset.erc20()) returns (uint192 quantity) {\n            if (quantity > 0) basketHandler.disableBasket(); // not an interaction\n        } catch {\n            basketHandler.disableBasket();\n        }\n\n        _erc20s.remove(address(asset.erc20()));\n        assets[asset.erc20()] = IAsset(address(0));\n        emit AssetUnregistered(asset.erc20(), asset);\n    }\n\n    /// Return the Asset registered for erc20; revert if erc20 is not registered.\n    // checks: erc20 in assets\n    // returns: assets[erc20]\n    function toAsset(IERC20 erc20) external view returns (IAsset) {\n        require(_erc20s.contains(address(erc20)), \"erc20 unregistered\");\n        return assets[erc20];\n    }\n\n    /// Return the Collateral registered for erc20; revert if erc20 is not registered as Collateral\n    // checks: erc20 in assets, assets[erc20].isCollateral()\n    // returns: assets[erc20]\n    function toColl(IERC20 erc20) external view returns (ICollateral) {\n        require(_erc20s.contains(address(erc20)), \"erc20 unregistered\");\n        require(assets[erc20].isCollateral(), \"erc20 is not collateral\");\n        return ICollateral(address(assets[erc20]));\n    }\n\n    /// Returns true if erc20 is registered.\n    // returns: (erc20 in assets)\n    function isRegistered(IERC20 erc20) external view returns (bool) {\n        return _erc20s.contains(address(erc20));\n    }\n\n    /// Returns keys(assets) as a (duplicate-free) list.\n    // returns: [keys(assets)] without duplicates.\n    function erc20s() external view returns (IERC20[] memory erc20s_) {\n        uint256 length = _erc20s.length();\n        erc20s_ = new IERC20[](length);\n        for (uint256 i = 0; i < length; ++i) {\n            erc20s_[i] = IERC20(_erc20s.at(i));\n        }\n    }\n\n    /// Returns keys(assets), values(assets) as (duplicate-free) lists.\n    // returns: [keys(assets)], [values(assets)] without duplicates.\n    /// @return reg The list of registered ERC20s and Assets, in the same order\n    function getRegistry() external view returns (Registry memory reg) {\n        uint256 length = _erc20s.length();\n        reg.erc20s = new IERC20[](length);\n        reg.assets = new IAsset[](length);\n        for (uint256 i = 0; i < length; ++i) {\n            reg.erc20s[i] = IERC20(_erc20s.at(i));\n            reg.assets[i] = assets[IERC20(_erc20s.at(i))];\n        }\n    }\n\n    /// @return The number of registered ERC20s\n    function size() external view returns (uint256) {\n        return _erc20s.length();\n    }\n\n    /// Register an asset\n    /// Forbids registering a different asset for an ERC20 that is already registered\n    /// @return registered If the asset was moved from unregistered to registered\n    // checks: (asset.erc20() not in assets) or (assets[asset.erc20()] == asset)\n    // effects: assets' = assets.set(asset.erc20(), asset)\n    // returns: assets.erc20() not in assets\n    function _register(IAsset asset) internal returns (bool registered) {\n        require(\n            !_erc20s.contains(address(asset.erc20())) || assets[asset.erc20()] == asset,\n            \"duplicate ERC20 detected\"\n        );\n\n        registered = _registerIgnoringCollisions(asset);\n    }\n\n    /// Register an asset, unregistering any previous asset with the same ERC20.\n    // effects: assets' = assets.set(asset.erc20(), asset)\n    // returns: assets[asset.erc20()] != asset\n    function _registerIgnoringCollisions(IAsset asset) private returns (bool swapped) {\n        IERC20Metadata erc20 = asset.erc20();\n        if (_erc20s.contains(address(erc20))) {\n            if (assets[erc20] == asset) return false;\n            else emit AssetUnregistered(erc20, assets[erc20]);\n        } else {\n            _erc20s.add(address(erc20));\n        }\n\n        assets[erc20] = asset;\n        emit AssetRegistered(erc20, asset);\n\n        // Refresh to ensure it does not revert, and to save a recent lastPrice\n        asset.refresh();\n\n        if (!main.frozen()) {\n            backingManager.grantRTokenAllowance(erc20);\n        }\n\n        return true;\n    }\n\n    function _reserveGas() private view returns (uint256) {\n        uint256 gas = gasleft();\n        require(gas > GAS_TO_RESERVE, \"not enough gas to unregister safely\");\n        return gas - GAS_TO_RESERVE;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[46] private __gap;\n}"
    }
  ]
}