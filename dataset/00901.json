{
  "Title": "M-9: Leverage Vault on sidechains that support Curve V2 pools is broken",
  "Content": "# Issue M-9: Leverage Vault on sidechains that support Curve V2 pools is broken \n\nSource: https://github.com/sherlock-audit/2023-10-notional-judging/issues/88 \n\n## Found by \nxiaoming90\n## Summary\n\nNo users will be able to deposit to the Leverage Vault on Arbitrum and Optimism that supports Curve V2 pools, leading to the core contract functionality of a vault being broken and a loss of revenue for the protocol.\n\n## Vulnerability Detail\n\nFollowing are examples of some Curve V2 pools in Arbitum:\n\n- fETH/ETH/xETH (https://curve.fi/#/arbitrum/pools/factory-tricrypto-2/deposit)\n- tricrypto (https://curve.fi/#/arbitrum/pools/tricrypto/deposit)\n- eursusd (https://curve.fi/#/arbitrum/pools/eursusd/deposit)\n\nThe code from Line 64 to Line 71 is only executed if the contract resides on Ethereum. As a result, for Arbitrum and Optimism sidechains, the `IS_CURVE_V2` variable is always false.\n\nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/vaults/curve/Curve2TokenPoolMixin.sol#L73\n\n```solidity\nFile: Curve2TokenPoolMixin.sol\n56:     constructor(\n57:         NotionalProxy notional_,\n58:         DeploymentParams memory params\n59:     ) SingleSidedLPVaultBase(notional_, params.tradingModule) {\n60:         CURVE_POOL = params.pool;\n61: \n62:         bool isCurveV2 = false;\n63:         if (Deployments.CHAIN_ID == Constants.CHAIN_ID_MAINNET) {\n64:             address[10] memory handlers = \n65:                 Deployments.CURVE_META_REGISTRY.get_registry_handlers_from_pool(address(CURVE_POOL));\n66: \n67:             require(\n68:                 handlers[0] == Deployments.CURVE_V1_HANDLER ||\n69:                 handlers[0] == Deployments.CURVE_V2_HANDLER\n70:             ); // @dev unknown Curve version\n71:             isCurveV2 = (handlers[0] == Deployments.CURVE_V2_HANDLER);\n72:         }\n73:         IS_CURVE_V2 = isCurveV2;\n```\n\nAs a result, code within the `_joinPoolAndStake` function will always call the Curve V1's `add_liquidity` function that does not define the `use_eth` parameter.\n\nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/vaults/Curve2TokenConvexVault.sol#L51\n\n```solidity\nFile: Curve2TokenConvexVault.sol\n26:     function _joinPoolAndStake(\n..SNIP..\n45:         // Slightly different method signatures in v1 and v2\n46:         if (IS_CURVE_V2) {\n47:             lpTokens = ICurve2TokenPoolV2(CURVE_POOL).add_liquidity{value: msgValue}(\n48:                 amounts, minPoolClaim, 0 < msgValue // use_eth = true if msgValue > 0\n49:             );\n50:         } else {\n51:             lpTokens = ICurve2TokenPoolV1(CURVE_POOL).add_liquidity{value: msgValue}(\n52:                 amounts, minPoolClaim\n53:             );\n54:         }\n```\n\nIf the `use_eth` parameter is not defined, it will default to `False`. As a result, the Curve pool expects the caller to transfer over the WETH to the pool and the pool will call `WETH.withdraw` to unwrap the WETH to Native ETH as shown in the code below.\n\nHowever, Notional's leverage vault only works with Native ETH, and if one of the pool tokens is WETH, it will explicitly convert the address to either the `Deployments.ALT_ETH_ADDRESS` (0xEeeee) or `Deployments.ETH_ADDRESS` (address(0)) during deployment and initialization.\n\nThe implementation of the above `_joinPoolAndStake` function will forward Native ETH to the Curve Pool, while the pool expects the vault to transfer in WETH. As a result, a revert will occur since the pool did not receive the WETH it required during the unwrap process.\n\nhttps://arbiscan.io/address/0xf7fed8ae0c5b78c19aadd68b700696933b0cefd9#code#L509 (Taken from Curve V2 fETH/ETH/xETH pool)\n\n```python\ndef add_liquidity(\n    amounts: uint256[N_COINS],\n    min_mint_amount: uint256,\n    use_eth: bool = False,\n    receiver: address = msg.sender\n) -> uint256:\n    \"\"\"\n    @notice Adds liquidity into the pool.\n    @param amounts Amounts of each coin to add.\n    @param min_mint_amount Minimum amount of LP to mint.\n    @param use_eth True if native token is being added to the pool.\n    @param receiver Address to send the LP tokens to. Default is msg.sender\n    @return uint256 Amount of LP tokens received by the `receiver\n    \"\"\"\n..SNIP..\n    # --------------------- Get prices, balances -----------------------------\n..SNIP..\n    # -------------------------------------- Update balances and calculate xp.\n..SNIP...\n    # ---------------- transferFrom token into the pool ----------------------\n\n    for i in range(N_COINS):\n\n        if amounts[i] > 0:\n\n            if coins[i] == WETH20:\n\n                self._transfer_in(\n                    coins[i],\n                    amounts[i],\n                    0,  # <-----------------------------------\n                    msg.value,  #                             | No callbacks\n                    empty(address),  # <----------------------| for\n                    empty(bytes32),  # <----------------------| add_liquidity.\n                    msg.sender,  #                            |\n                    empty(address),  # <-----------------------\n                    use_eth\n                )\n```\n\n```python\ndef _transfer_in(\n..SNIP..\n    use_eth: bool\n):\n..SNIP..\n    @params use_eth True if the transfer is ETH, False otherwise.\n    \"\"\"\n\n    if use_eth and _coin == WETH20:\n        assert mvalue == dx  # dev: incorrect eth amount\n    else:\n..SNIP..\n        if _coin == WETH20:\n            WETH(WETH20).withdraw(dx)  # <--------- if WETH was transferred in\n            #           previous step and `not use_eth`, withdraw WETH to ETH.\n```\n\n## Impact\n\nNo users will be able to deposit to the Leverage Vault on Arbitrum and Optimism that supports Curve V2 pools. The deposit function is a core function of any vault. Thus, this issue breaks the core contract functionality of a vault.\n\nIn addition, if the affected vaults cannot be used, it leads to a loss of revenue for the protocol.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/vaults/curve/Curve2TokenPoolMixin.sol#L73\n\nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/vaults/Curve2TokenConvexVault.sol#L51\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nEnsure the `IS_CURVE_V2` variable is initialized on the Arbitrum and Optimism side chains according to the Curve Pool's version.\n\nIf there is a limitation on the existing approach to determining a pool is V1 or V2 on Arbitrum and Optimsim, an alternative approach might be to use the presence of a `gamma()` function as an indicator of pool type\n\n\n\n## Discussion\n\n**jeffywu**\n\nIt should be noted that none of the pools are available on Convex either:\nhttps://www.convexfinance.com/stake\n\nFurthermore, the Convex vault is only explicitly written for 2 token vaults, which the ones auditor listed are not. So therefore they could not be listed as structured Arbitrum in any case. I would range this as a medium severity, if anything.\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/119",
  "Code": [
    {
      "filename": "leveraged-vaults/contracts/vaults/curve/Curve2TokenPoolMixin.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {IERC20} from \"../../../interfaces/IERC20.sol\";\nimport {Deployments} from \"../../global/Deployments.sol\";\nimport {Constants} from \"../../global/Constants.sol\";\nimport {TokenUtils} from \"../../utils/TokenUtils.sol\";\nimport {NotionalProxy} from \"../../../interfaces/notional/NotionalProxy.sol\";\nimport {\n    ICurvePool,\n    ICurvePoolV1,\n    ICurvePoolV2,\n    ICurve2TokenPool\n} from \"../../../interfaces/curve/ICurvePool.sol\";\nimport {SingleSidedLPVaultBase} from \"../common/SingleSidedLPVaultBase.sol\";\nimport {ITradingModule} from \"../../../interfaces/trading/ITradingModule.sol\";\n\nstruct DeploymentParams {\n    uint16 primaryBorrowCurrencyId;\n    address pool;\n    ITradingModule tradingModule;\n    bool isSelfLPToken;\n}\n\nabstract contract Curve2TokenPoolMixin is SingleSidedLPVaultBase {\n    uint256 internal constant _NUM_TOKENS = 2;\n    uint256 internal constant CURVE_PRECISION = 1e18;\n\n    address internal immutable CURVE_POOL;\n    IERC20 internal immutable CURVE_POOL_TOKEN;\n    bool internal immutable IS_CURVE_V2;\n\n    uint8 internal immutable _PRIMARY_INDEX;\n    uint8 internal immutable SECONDARY_INDEX;\n    address internal immutable TOKEN_1;\n    address internal immutable TOKEN_2;\n    uint8 internal immutable DECIMALS_1;\n    uint8 internal immutable DECIMALS_2;\n    uint8 internal immutable PRIMARY_DECIMALS;\n    uint8 internal immutable SECONDARY_DECIMALS;\n\n    function NUM_TOKENS() internal pure override returns (uint256) { return _NUM_TOKENS; }\n    function PRIMARY_INDEX() internal view override returns (uint256) { return _PRIMARY_INDEX; }\n    function POOL_TOKEN() internal view override returns (IERC20) { return CURVE_POOL_TOKEN; }\n    function POOL_PRECISION() internal pure override returns (uint256) { return CURVE_PRECISION; }\n    function TOKENS() internal view override returns (IERC20[] memory, uint8[] memory) {\n        IERC20[] memory tokens = new IERC20[](_NUM_TOKENS);\n        uint8[] memory decimals = new uint8[](_NUM_TOKENS);\n\n        (tokens[0], decimals[0]) = (IERC20(TOKEN_1), DECIMALS_1);\n        (tokens[1], decimals[1]) = (IERC20(TOKEN_2), DECIMALS_2);\n\n        return (tokens, decimals);\n    }\n\n    constructor(\n        NotionalProxy notional_,\n        DeploymentParams memory params\n    ) SingleSidedLPVaultBase(notional_, params.tradingModule) {\n        CURVE_POOL = params.pool;\n\n        bool isCurveV2 = false;\n        if (Deployments.CHAIN_ID == Constants.CHAIN_ID_MAINNET) {\n            address[10] memory handlers = \n                Deployments.CURVE_META_REGISTRY.get_registry_handlers_from_pool(address(CURVE_POOL));\n\n            require(\n                handlers[0] == Deployments.CURVE_V1_HANDLER ||\n                handlers[0] == Deployments.CURVE_V2_HANDLER\n            ); // @dev unknown Curve version\n            isCurveV2 = (handlers[0] == Deployments.CURVE_V2_HANDLER);\n        }\n        IS_CURVE_V2 = isCurveV2;\n        CURVE_POOL_TOKEN = params.isSelfLPToken ? IERC20(CURVE_POOL) : (\n            IS_CURVE_V2 ? \n                IERC20(ICurvePoolV2(address(CURVE_POOL)).token()) :\n                IERC20(ICurvePoolV1(address(CURVE_POOL)).lp_token())\n        );\n\n        address primaryToken = _getNotionalUnderlyingToken(params.primaryBorrowCurrencyId);\n\n        // We interact with curve pools directly so we never pass the token addresses back\n        // to the curve pools. The amounts are passed back based on indexes instead. Therefore\n        // we can rewrite the token addresses from ALT Eth (0xeeee...) back to (0x0000...) which\n        // is used by the vault internally to represent ETH.\n        TOKEN_1 = _rewriteAltETH(ICurvePool(CURVE_POOL).coins(0));\n        TOKEN_2 = _rewriteAltETH(ICurvePool(CURVE_POOL).coins(1));\n        _PRIMARY_INDEX = TOKEN_1 == primaryToken ? 0 : 1;\n        SECONDARY_INDEX = 1 - _PRIMARY_INDEX;\n        \n        DECIMALS_1 = TokenUtils.getDecimals(TOKEN_1);\n        DECIMALS_2 = TokenUtils.getDecimals(TOKEN_2);\n        PRIMARY_DECIMALS = _PRIMARY_INDEX == 0 ? DECIMALS_1 : DECIMALS_2;\n        SECONDARY_DECIMALS = _PRIMARY_INDEX == 0 ? DECIMALS_2 : DECIMALS_1;\n    }\n\n    function _rewriteAltETH(address token) private pure returns (address) {\n        return token == address(Deployments.ALT_ETH_ADDRESS) ? Deployments.ETH_ADDRESS : address(token);\n    }\n\n    function _checkReentrancyContext() internal override {\n        // We need to set the LP token amount to 1 for Curve V2 pools to bypass\n        // the underflow check\n        uint256[2] memory minAmounts;\n        ICurve2TokenPool(address(CURVE_POOL)).remove_liquidity(IS_CURVE_V2 ? 1 : 0, minAmounts);\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/Curve2TokenConvexVault.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {Deployments} from \"../global/Deployments.sol\";\nimport {Constants} from \"../global/Constants.sol\";\nimport {IERC20} from \"../utils/TokenUtils.sol\";\nimport {ConvexStakingMixin, ConvexVaultDeploymentParams} from \"./curve/ConvexStakingMixin.sol\";\nimport {NotionalProxy} from \"../../interfaces/notional/NotionalProxy.sol\";\nimport {IConvexBooster, IConvexBoosterArbitrum} from \"../../interfaces/convex/IConvexBooster.sol\";\nimport {IConvexRewardPool, IConvexRewardPoolArbitrum} from \"../../interfaces/convex/IConvexRewardPool.sol\";\nimport {\n    ICurvePool,\n    ICurve2TokenPool,\n    ICurve2TokenPoolV1,\n    ICurve2TokenPoolV2\n} from \"../../interfaces/curve/ICurvePool.sol\";\n\ncontract Curve2TokenConvexVault is ConvexStakingMixin {\n    constructor(NotionalProxy notional_, ConvexVaultDeploymentParams memory params) \n        ConvexStakingMixin(notional_, params) {}\n\n    function strategy() external override pure returns (bytes4) {\n        return bytes4(keccak256(\"Curve2TokenConvexVault\"));\n    }\n\n    function _joinPoolAndStake(\n        uint256[] memory _amounts, uint256 minPoolClaim\n    ) internal override returns (uint256 lpTokens) {\n        // Only two tokens are ever allowed in this strategy, remaps the array\n        // into a fixed length array here.\n        uint256[2] memory amounts;\n        amounts[0] = _amounts[0];\n        amounts[1] = _amounts[1];\n\n        // Although Curve uses ALT_ETH to represent native ETH, it is rewritten in the Curve2TokenPoolMixin\n        // to the Deployments.ETH_ADDRESS which we use internally.\n        (IERC20[] memory tokens, /* */) = TOKENS();\n        uint256 msgValue;\n        if (address(tokens[0]) == Deployments.ETH_ADDRESS) {\n            msgValue = amounts[0];\n        } else if (address(tokens[1]) == Deployments.ETH_ADDRESS) {\n            msgValue = amounts[1];\n        }\n\n        // Slightly different method signatures in v1 and v2\n        if (IS_CURVE_V2) {\n            lpTokens = ICurve2TokenPoolV2(CURVE_POOL).add_liquidity{value: msgValue}(\n                amounts, minPoolClaim, 0 < msgValue // use_eth = true if msgValue > 0\n            );\n        } else {\n            lpTokens = ICurve2TokenPoolV1(CURVE_POOL).add_liquidity{value: msgValue}(\n                amounts, minPoolClaim\n            );\n        }\n\n        // Method signatures are slightly different on mainnet and arbitrum\n        bool success;\n        if (Deployments.CHAIN_ID == Constants.CHAIN_ID_MAINNET) {\n            success = IConvexBooster(CONVEX_BOOSTER).deposit(CONVEX_POOL_ID, lpTokens, true);\n        } else if (Deployments.CHAIN_ID == Constants.CHAIN_ID_ARBITRUM) {\n            success = IConvexBoosterArbitrum(CONVEX_BOOSTER).deposit(CONVEX_POOL_ID, lpTokens);\n        }\n        require(success);\n    }\n\n    function _unstakeAndExitPool(\n        uint256 poolClaim, uint256[] memory _minAmounts, bool isSingleSided\n    ) internal override returns (uint256[] memory exitBalances) {\n        bool success;\n        // Do not claim rewards when unstaking\n        if (Deployments.CHAIN_ID == Constants.CHAIN_ID_MAINNET) {\n            success = IConvexRewardPool(CONVEX_REWARD_POOL).withdrawAndUnwrap(poolClaim, false);\n        } else if (Deployments.CHAIN_ID == Constants.CHAIN_ID_ARBITRUM) {\n            success = IConvexRewardPoolArbitrum(CONVEX_REWARD_POOL).withdraw(poolClaim, false);\n        }\n        require(success);\n\n        ICurve2TokenPool pool = ICurve2TokenPool(CURVE_POOL);\n        exitBalances = new uint256[](2);\n        if (isSingleSided) {\n            // Redeem single-sided\n            exitBalances[_PRIMARY_INDEX] = pool.remove_liquidity_one_coin(\n                poolClaim, int8(_PRIMARY_INDEX), _minAmounts[_PRIMARY_INDEX]\n            );\n        } else {\n            // Redeem proportionally, min amounts are rewritten to a fixed length array\n            uint256[2] memory minAmounts;\n            minAmounts[0] = _minAmounts[0];\n            minAmounts[1] = _minAmounts[1];\n\n            uint256[2] memory _exitBalances = pool.remove_liquidity(poolClaim, minAmounts);\n            exitBalances[0] = _exitBalances[0];\n            exitBalances[1] = _exitBalances[1];\n        }\n    }\n\n    function _checkPriceAndCalculateValue() internal view override returns (uint256 oneLPValueInPrimary) {\n        uint256[] memory balances = new uint256[](2);\n        balances[0] = ICurvePool(CURVE_POOL).balances(0);\n        balances[1] = ICurvePool(CURVE_POOL).balances(1);\n\n        // The primary index spot price is left as zero.\n        uint256[] memory spotPrices = new uint256[](2);\n        uint256 primaryPrecision = 10 ** PRIMARY_DECIMALS;\n        uint256 secondaryPrecision = 10 ** SECONDARY_DECIMALS;\n\n        // `get_dy` returns the price of one unit of the primary token\n        // converted to the secondary token. The spot price is in secondary\n        // precision and then we convert it to POOL_PRECISION.\n        spotPrices[SECONDARY_INDEX] = ICurvePool(CURVE_POOL).get_dy(\n            int8(_PRIMARY_INDEX), int8(SECONDARY_INDEX), primaryPrecision\n        ) * POOL_PRECISION() / secondaryPrecision;\n\n        return _calculateLPTokenValue(balances, spotPrices);\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/curve/Curve2TokenPoolMixin.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {IERC20} from \"../../../interfaces/IERC20.sol\";\nimport {Deployments} from \"../../global/Deployments.sol\";\nimport {Constants} from \"../../global/Constants.sol\";\nimport {TokenUtils} from \"../../utils/TokenUtils.sol\";\nimport {NotionalProxy} from \"../../../interfaces/notional/NotionalProxy.sol\";\nimport {\n    ICurvePool,\n    ICurvePoolV1,\n    ICurvePoolV2,\n    ICurve2TokenPool\n} from \"../../../interfaces/curve/ICurvePool.sol\";\nimport {SingleSidedLPVaultBase} from \"../common/SingleSidedLPVaultBase.sol\";\nimport {ITradingModule} from \"../../../interfaces/trading/ITradingModule.sol\";\n\nstruct DeploymentParams {\n    uint16 primaryBorrowCurrencyId;\n    address pool;\n    ITradingModule tradingModule;\n    bool isSelfLPToken;\n}\n\nabstract contract Curve2TokenPoolMixin is SingleSidedLPVaultBase {\n    uint256 internal constant _NUM_TOKENS = 2;\n    uint256 internal constant CURVE_PRECISION = 1e18;\n\n    address internal immutable CURVE_POOL;\n    IERC20 internal immutable CURVE_POOL_TOKEN;\n    bool internal immutable IS_CURVE_V2;\n\n    uint8 internal immutable _PRIMARY_INDEX;\n    uint8 internal immutable SECONDARY_INDEX;\n    address internal immutable TOKEN_1;\n    address internal immutable TOKEN_2;\n    uint8 internal immutable DECIMALS_1;\n    uint8 internal immutable DECIMALS_2;\n    uint8 internal immutable PRIMARY_DECIMALS;\n    uint8 internal immutable SECONDARY_DECIMALS;\n\n    function NUM_TOKENS() internal pure override returns (uint256) { return _NUM_TOKENS; }\n    function PRIMARY_INDEX() internal view override returns (uint256) { return _PRIMARY_INDEX; }\n    function POOL_TOKEN() internal view override returns (IERC20) { return CURVE_POOL_TOKEN; }\n    function POOL_PRECISION() internal pure override returns (uint256) { return CURVE_PRECISION; }\n    function TOKENS() internal view override returns (IERC20[] memory, uint8[] memory) {\n        IERC20[] memory tokens = new IERC20[](_NUM_TOKENS);\n        uint8[] memory decimals = new uint8[](_NUM_TOKENS);\n\n        (tokens[0], decimals[0]) = (IERC20(TOKEN_1), DECIMALS_1);\n        (tokens[1], decimals[1]) = (IERC20(TOKEN_2), DECIMALS_2);\n\n        return (tokens, decimals);\n    }\n\n    constructor(\n        NotionalProxy notional_,\n        DeploymentParams memory params\n    ) SingleSidedLPVaultBase(notional_, params.tradingModule) {\n        CURVE_POOL = params.pool;\n\n        bool isCurveV2 = false;\n        if (Deployments.CHAIN_ID == Constants.CHAIN_ID_MAINNET) {\n            address[10] memory handlers = \n                Deployments.CURVE_META_REGISTRY.get_registry_handlers_from_pool(address(CURVE_POOL));\n\n            require(\n                handlers[0] == Deployments.CURVE_V1_HANDLER ||\n                handlers[0] == Deployments.CURVE_V2_HANDLER\n            ); // @dev unknown Curve version\n            isCurveV2 = (handlers[0] == Deployments.CURVE_V2_HANDLER);\n        }\n        IS_CURVE_V2 = isCurveV2;\n        CURVE_POOL_TOKEN = params.isSelfLPToken ? IERC20(CURVE_POOL) : (\n            IS_CURVE_V2 ? \n                IERC20(ICurvePoolV2(address(CURVE_POOL)).token()) :\n                IERC20(ICurvePoolV1(address(CURVE_POOL)).lp_token())\n        );\n\n        address primaryToken = _getNotionalUnderlyingToken(params.primaryBorrowCurrencyId);\n\n        // We interact with curve pools directly so we never pass the token addresses back\n        // to the curve pools. The amounts are passed back based on indexes instead. Therefore\n        // we can rewrite the token addresses from ALT Eth (0xeeee...) back to (0x0000...) which\n        // is used by the vault internally to represent ETH.\n        TOKEN_1 = _rewriteAltETH(ICurvePool(CURVE_POOL).coins(0));\n        TOKEN_2 = _rewriteAltETH(ICurvePool(CURVE_POOL).coins(1));\n        _PRIMARY_INDEX = TOKEN_1 == primaryToken ? 0 : 1;\n        SECONDARY_INDEX = 1 - _PRIMARY_INDEX;\n        \n        DECIMALS_1 = TokenUtils.getDecimals(TOKEN_1);\n        DECIMALS_2 = TokenUtils.getDecimals(TOKEN_2);\n        PRIMARY_DECIMALS = _PRIMARY_INDEX == 0 ? DECIMALS_1 : DECIMALS_2;\n        SECONDARY_DECIMALS = _PRIMARY_INDEX == 0 ? DECIMALS_2 : DECIMALS_1;\n    }\n\n    function _rewriteAltETH(address token) private pure returns (address) {\n        return token == address(Deployments.ALT_ETH_ADDRESS) ? Deployments.ETH_ADDRESS : address(token);\n    }\n\n    function _checkReentrancyContext() internal override {\n        // We need to set the LP token amount to 1 for Curve V2 pools to bypass\n        // the underflow check\n        uint256[2] memory minAmounts;\n        ICurve2TokenPool(address(CURVE_POOL)).remove_liquidity(IS_CURVE_V2 ? 1 : 0, minAmounts);\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/Curve2TokenConvexVault.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {Deployments} from \"../global/Deployments.sol\";\nimport {Constants} from \"../global/Constants.sol\";\nimport {IERC20} from \"../utils/TokenUtils.sol\";\nimport {ConvexStakingMixin, ConvexVaultDeploymentParams} from \"./curve/ConvexStakingMixin.sol\";\nimport {NotionalProxy} from \"../../interfaces/notional/NotionalProxy.sol\";\nimport {IConvexBooster, IConvexBoosterArbitrum} from \"../../interfaces/convex/IConvexBooster.sol\";\nimport {IConvexRewardPool, IConvexRewardPoolArbitrum} from \"../../interfaces/convex/IConvexRewardPool.sol\";\nimport {\n    ICurvePool,\n    ICurve2TokenPool,\n    ICurve2TokenPoolV1,\n    ICurve2TokenPoolV2\n} from \"../../interfaces/curve/ICurvePool.sol\";\n\ncontract Curve2TokenConvexVault is ConvexStakingMixin {\n    constructor(NotionalProxy notional_, ConvexVaultDeploymentParams memory params) \n        ConvexStakingMixin(notional_, params) {}\n\n    function strategy() external override pure returns (bytes4) {\n        return bytes4(keccak256(\"Curve2TokenConvexVault\"));\n    }\n\n    function _joinPoolAndStake(\n        uint256[] memory _amounts, uint256 minPoolClaim\n    ) internal override returns (uint256 lpTokens) {\n        // Only two tokens are ever allowed in this strategy, remaps the array\n        // into a fixed length array here.\n        uint256[2] memory amounts;\n        amounts[0] = _amounts[0];\n        amounts[1] = _amounts[1];\n\n        // Although Curve uses ALT_ETH to represent native ETH, it is rewritten in the Curve2TokenPoolMixin\n        // to the Deployments.ETH_ADDRESS which we use internally.\n        (IERC20[] memory tokens, /* */) = TOKENS();\n        uint256 msgValue;\n        if (address(tokens[0]) == Deployments.ETH_ADDRESS) {\n            msgValue = amounts[0];\n        } else if (address(tokens[1]) == Deployments.ETH_ADDRESS) {\n            msgValue = amounts[1];\n        }\n\n        // Slightly different method signatures in v1 and v2\n        if (IS_CURVE_V2) {\n            lpTokens = ICurve2TokenPoolV2(CURVE_POOL).add_liquidity{value: msgValue}(\n                amounts, minPoolClaim, 0 < msgValue // use_eth = true if msgValue > 0\n            );\n        } else {\n            lpTokens = ICurve2TokenPoolV1(CURVE_POOL).add_liquidity{value: msgValue}(\n                amounts, minPoolClaim\n            );\n        }\n\n        // Method signatures are slightly different on mainnet and arbitrum\n        bool success;\n        if (Deployments.CHAIN_ID == Constants.CHAIN_ID_MAINNET) {\n            success = IConvexBooster(CONVEX_BOOSTER).deposit(CONVEX_POOL_ID, lpTokens, true);\n        } else if (Deployments.CHAIN_ID == Constants.CHAIN_ID_ARBITRUM) {\n            success = IConvexBoosterArbitrum(CONVEX_BOOSTER).deposit(CONVEX_POOL_ID, lpTokens);\n        }\n        require(success);\n    }\n\n    function _unstakeAndExitPool(\n        uint256 poolClaim, uint256[] memory _minAmounts, bool isSingleSided\n    ) internal override returns (uint256[] memory exitBalances) {\n        bool success;\n        // Do not claim rewards when unstaking\n        if (Deployments.CHAIN_ID == Constants.CHAIN_ID_MAINNET) {\n            success = IConvexRewardPool(CONVEX_REWARD_POOL).withdrawAndUnwrap(poolClaim, false);\n        } else if (Deployments.CHAIN_ID == Constants.CHAIN_ID_ARBITRUM) {\n            success = IConvexRewardPoolArbitrum(CONVEX_REWARD_POOL).withdraw(poolClaim, false);\n        }\n        require(success);\n\n        ICurve2TokenPool pool = ICurve2TokenPool(CURVE_POOL);\n        exitBalances = new uint256[](2);\n        if (isSingleSided) {\n            // Redeem single-sided\n            exitBalances[_PRIMARY_INDEX] = pool.remove_liquidity_one_coin(\n                poolClaim, int8(_PRIMARY_INDEX), _minAmounts[_PRIMARY_INDEX]\n            );\n        } else {\n            // Redeem proportionally, min amounts are rewritten to a fixed length array\n            uint256[2] memory minAmounts;\n            minAmounts[0] = _minAmounts[0];\n            minAmounts[1] = _minAmounts[1];\n\n            uint256[2] memory _exitBalances = pool.remove_liquidity(poolClaim, minAmounts);\n            exitBalances[0] = _exitBalances[0];\n            exitBalances[1] = _exitBalances[1];\n        }\n    }\n\n    function _checkPriceAndCalculateValue() internal view override returns (uint256 oneLPValueInPrimary) {\n        uint256[] memory balances = new uint256[](2);\n        balances[0] = ICurvePool(CURVE_POOL).balances(0);\n        balances[1] = ICurvePool(CURVE_POOL).balances(1);\n\n        // The primary index spot price is left as zero.\n        uint256[] memory spotPrices = new uint256[](2);\n        uint256 primaryPrecision = 10 ** PRIMARY_DECIMALS;\n        uint256 secondaryPrecision = 10 ** SECONDARY_DECIMALS;\n\n        // `get_dy` returns the price of one unit of the primary token\n        // converted to the secondary token. The spot price is in secondary\n        // precision and then we convert it to POOL_PRECISION.\n        spotPrices[SECONDARY_INDEX] = ICurvePool(CURVE_POOL).get_dy(\n            int8(_PRIMARY_INDEX), int8(SECONDARY_INDEX), primaryPrecision\n        ) * POOL_PRECISION() / secondaryPrecision;\n\n        return _calculateLPTokenValue(balances, spotPrices);\n    }\n}"
    }
  ]
}