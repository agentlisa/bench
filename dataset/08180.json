{
  "Title": "[N-10]  Event is missing `indexed` fields",
  "Content": "Index event fields make the field more quickly accessible to off-chain tools that parse events. However, note that each index field costs extra gas during emission, so it's not necessarily best to index the maximum allowed per event (three fields). Each `event` should use three `indexed` fields if there are three or more fields, and gas usage is not particularly of concern for the events in question. If there are fewer than three fields, all of the fields should be indexed.\n\n*There are 21 instances of this issue:*\n```solidity\nFile: contracts/base/ERC721Checkpointable.sol\n\n73:       event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n```\nhttps://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/base/ERC721Checkpointable.sol#L73\n\n```solidity\nFile: contracts/governance/NounsDAOInterfaces.sol\n\n37        event ProposalCreated(\n38            uint256 id,\n39            address proposer,\n40            address[] targets,\n41            uint256[] values,\n42            string[] signatures,\n43            bytes[] calldatas,\n44            uint256 startBlock,\n45            uint256 endBlock,\n46            string description\n47:       );\n\n50        event ProposalCreatedWithRequirements(\n51            uint256 id,\n52            address proposer,\n53            address[] targets,\n54            uint256[] values,\n55            string[] signatures,\n56            bytes[] calldatas,\n57            uint256 startBlock,\n58            uint256 endBlock,\n59            uint256 proposalThreshold,\n60            uint256 quorumVotes,\n61            string description\n62:       );\n\n70:       event VoteCast(address indexed voter, uint256 proposalId, uint8 support, uint256 votes, string reason);\n\n73:       event ProposalCanceled(uint256 id);\n\n76:       event ProposalQueued(uint256 id, uint256 eta);\n\n79:       event ProposalExecuted(uint256 id);\n\n82:       event ProposalVetoed(uint256 id);\n\n85:       event VotingDelaySet(uint256 oldVotingDelay, uint256 newVotingDelay);\n\n88:       event VotingPeriodSet(uint256 oldVotingPeriod, uint256 newVotingPeriod);\n\n91:       event NewImplementation(address oldImplementation, address newImplementation);\n\n94:       event ProposalThresholdBPSSet(uint256 oldProposalThresholdBPS, uint256 newProposalThresholdBPS);\n\n97:       event QuorumVotesBPSSet(uint256 oldQuorumVotesBPS, uint256 newQuorumVotesBPS);\n\n100:      event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n103:      event NewAdmin(address oldAdmin, address newAdmin);\n\n106:      event NewVetoer(address oldVetoer, address newVetoer);\n\n111:      event MinQuorumVotesBPSSet(uint16 oldMinQuorumVotesBPS, uint16 newMinQuorumVotesBPS);\n\n114:      event MaxQuorumVotesBPSSet(uint16 oldMaxQuorumVotesBPS, uint16 newMaxQuorumVotesBPS);\n\n117:      event QuorumCoefficientSet(uint32 oldQuorumCoefficient, uint32 newQuorumCoefficient);\n\n120:      event RefundableVote(address indexed voter, uint256 refundAmount, bool refundSent);\n\n123:      event Withdraw(uint256 amount, bool sent);\n\n```\nhttps://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOInterfaces.sol#L37-L47\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-08-nounsdao",
  "Code": [
    {
      "filename": "contracts/base/ERC721Checkpointable.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\n/// @title Vote checkpointing for an ERC-721 token\n\n/*********************************\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░██░░░████░░██░░░████░░░ *\n * ░░██████░░░████████░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n *********************************/\n\n// LICENSE\n// ERC721Checkpointable.sol uses and modifies part of Compound Lab's Comp.sol:\n// https://github.com/compound-finance/compound-protocol/blob/ae4388e780a8d596d97619d9704a931a2752c2bc/contracts/Governance/Comp.sol\n//\n// Comp.sol source code Copyright 2020 Compound Labs, Inc. licensed under the BSD-3-Clause license.\n// With modifications by Nounders DAO.\n//\n// Additional conditions of BSD-3-Clause can be found here: https://opensource.org/licenses/BSD-3-Clause\n//\n// MODIFICATIONS\n// Checkpointing logic from Comp.sol has been used with the following modifications:\n// - `delegates` is renamed to `_delegates` and is set to private\n// - `delegates` is a public function that uses the `_delegates` mapping look-up, but unlike\n//   Comp.sol, returns the delegator's own address if there is no delegate.\n//   This avoids the delegator needing to \"delegate to self\" with an additional transaction\n// - `_transferTokens()` is renamed `_beforeTokenTransfer()` and adapted to hook into OpenZeppelin's ERC721 hooks.\n\npragma solidity ^0.8.6;\n\nimport './ERC721Enumerable.sol';\n\nabstract contract ERC721Checkpointable is ERC721Enumerable {\n    /// @notice Defines decimals as per ERC-20 convention to make integrations with 3rd party governance platforms easier\n    uint8 public constant decimals = 0;\n\n    /// @notice A record of each accounts delegate\n    mapping(address => address) private _delegates;\n\n    /// @notice A checkpoint for marking number of votes from a given block\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint96 votes;\n    }\n\n    /// @notice A record of votes checkpoints for each account, by index\n    mapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\n\n    /// @notice The number of checkpoints for each account\n    mapping(address => uint32) public numCheckpoints;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256('EIP712Domain(string name,uint256 chainId,address verifyingContract)');\n\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\n    bytes32 public constant DELEGATION_TYPEHASH =\n        keccak256('Delegation(address delegatee,uint256 nonce,uint256 expiry)');\n\n    /// @notice A record of states for signing / validating signatures\n    mapping(address => uint256) public nonces;\n\n    /// @notice An event thats emitted when an account changes its delegate\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /// @notice An event thats emitted when a delegate account's vote balance changes\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n    /**\n     * @notice The votes a delegator can delegate, which is the current balance of the delegator.\n     * @dev Used when calling `_delegate()`\n     */\n    function votesToDelegate(address delegator) public view returns (uint96) {\n        return safe96(balanceOf(delegator), 'ERC721Checkpointable::votesToDelegate: amount exceeds 96 bits');\n    }\n\n    /**\n     * @notice Overrides the standard `Comp.sol` delegates mapping to return\n     * the delegator's own address if they haven't delegated.\n     * This avoids having to delegate to oneself.\n     */\n    function delegates(address delegator) public view returns (address) {\n        address current = _delegates[delegator];\n        return current == address(0) ? delegator : current;\n    }\n\n    /**\n     * @notice Adapted from `_transferTokens()` in `Comp.sol` to update delegate votes.\n     * @dev hooks into OpenZeppelin's `ERC721._transfer`\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        /// @notice Differs from `_transferTokens()` to use `delegates` override method to simulate auto-delegation\n        _moveDelegates(delegates(from), delegates(to), 1);\n    }\n\n    /**\n     * @notice Delegate votes from `msg.sender` to `delegatee`\n     * @param delegatee The address to delegate votes to\n     */\n    function delegate(address delegatee) public {\n        if (delegatee == address(0)) delegatee = msg.sender;\n        return _delegate(msg.sender, delegatee);\n    }\n\n    /**\n     * @notice Delegates votes from signatory to `delegatee`\n     * @param delegatee The address to delegate votes to\n     * @param nonce The contract state required to match the signature\n     * @param expiry The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        bytes32 domainSeparator = keccak256(\n            abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name())), getChainId(), address(this))\n        );\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\n        bytes32 digest = keccak256(abi.encodePacked('\\x19\\x01', domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), 'ERC721Checkpointable::delegateBySig: invalid signature');\n        require(nonce == nonces[signatory]++, 'ERC721Checkpointable::delegateBySig: invalid nonce');\n        require(block.timestamp <= expiry, 'ERC721Checkpointable::delegateBySig: signature expired');\n        return _delegate(signatory, delegatee);\n    }\n\n    /**\n     * @notice Gets the current votes balance for `account`\n     * @param account The address to get votes balance\n     * @return The number of current votes for `account`\n     */\n    function getCurrentVotes(address account) external view returns (uint96) {\n        uint32 nCheckpoints = numCheckpoints[account];\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n    }\n\n    /**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param account The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorVotes(address account, uint256 blockNumber) public view returns (uint96) {\n        require(blockNumber < block.number, 'ERC721Checkpointable::getPriorVotes: not yet determined');\n\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[account][nCheckpoints - 1].votes;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].fromBlock > blockNumber) {\n            return 0;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.votes;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[account][lower].votes;\n    }\n\n    function _delegate(address delegator, address delegatee) internal {\n        /// @notice differs from `_delegate()` in `Comp.sol` to use `delegates` override method to simulate auto-delegation\n        address currentDelegate = delegates(delegator);\n\n        _delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        uint96 amount = votesToDelegate(delegator);\n\n        _moveDelegates(currentDelegate, delegatee, amount);\n    }\n\n    function _moveDelegates(\n        address srcRep,\n        address dstRep,\n        uint96 amount\n    ) internal {\n        if (srcRep != dstRep && amount > 0) {\n            if (srcRep != address(0)) {\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n                uint96 srcRepNew = sub96(srcRepOld, amount, 'ERC721Checkpointable::_moveDelegates: amount underflows');\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n            }\n\n            if (dstRep != address(0)) {\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n                uint96 dstRepNew = add96(dstRepOld, amount, 'ERC721Checkpointable::_moveDelegates: amount overflows');\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n            }\n        }\n    }\n\n    function _writeCheckpoint(\n        address delegatee,\n        uint32 nCheckpoints,\n        uint96 oldVotes,\n        uint96 newVotes\n    ) internal {\n        uint32 blockNumber = safe32(\n            block.number,\n            'ERC721Checkpointable::_writeCheckpoint: block number exceeds 32 bits'\n        );\n\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n        } else {\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n            numCheckpoints[delegatee] = nCheckpoints + 1;\n        }\n\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n    }\n\n    function safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\n        require(n < 2**32, errorMessage);\n        return uint32(n);\n    }\n\n    function safe96(uint256 n, string memory errorMessage) internal pure returns (uint96) {\n        require(n < 2**96, errorMessage);\n        return uint96(n);\n    }\n\n    function add96(\n        uint96 a,\n        uint96 b,\n        string memory errorMessage\n    ) internal pure returns (uint96) {\n        uint96 c = a + b;\n        require(c >= a, errorMessage);\n        return c;\n    }\n\n    function sub96(\n        uint96 a,\n        uint96 b,\n        string memory errorMessage\n    ) internal pure returns (uint96) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    function getChainId() internal view returns (uint256) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId;\n    }\n}"
    },
    {
      "filename": "contracts/governance/NounsDAOInterfaces.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\n/// @title Nouns DAO Logic interfaces and events\n\n/*********************************\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░██░░░████░░██░░░████░░░ *\n * ░░██████░░░████████░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░██░░██░░░████░░██░░░████░░░ *\n * ░░░░░░█████████░░█████████░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n * ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ *\n *********************************/\n\n// LICENSE\n// NounsDAOInterfaces.sol is a modified version of Compound Lab's GovernorBravoInterfaces.sol:\n// https://github.com/compound-finance/compound-protocol/blob/b9b14038612d846b83f8a009a82c38974ff2dcfe/contracts/Governance/GovernorBravoInterfaces.sol\n//\n// GovernorBravoInterfaces.sol source code Copyright 2020 Compound Labs, Inc. licensed under the BSD-3-Clause license.\n// With modifications by Nounders DAO.\n//\n// Additional conditions of BSD-3-Clause can be found here: https://opensource.org/licenses/BSD-3-Clause\n//\n// MODIFICATIONS\n// NounsDAOEvents, NounsDAOProxyStorage, NounsDAOStorageV1 add support for changes made by Nouns DAO to GovernorBravo.sol\n// See NounsDAOLogicV1.sol for more details.\n// NounsDAOStorageV1Adjusted and NounsDAOStorageV2 add support for a dynamic vote quorum.\n// See NounsDAOLogicV2.sol for more details.\n\npragma solidity ^0.8.6;\n\ncontract NounsDAOEvents {\n    /// @notice An event emitted when a new proposal is created\n    event ProposalCreated(\n        uint256 id,\n        address proposer,\n        address[] targets,\n        uint256[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        uint256 startBlock,\n        uint256 endBlock,\n        string description\n    );\n\n    /// @notice An event emitted when a new proposal is created, which includes additional information\n    event ProposalCreatedWithRequirements(\n        uint256 id,\n        address proposer,\n        address[] targets,\n        uint256[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        uint256 startBlock,\n        uint256 endBlock,\n        uint256 proposalThreshold,\n        uint256 quorumVotes,\n        string description\n    );\n\n    /// @notice An event emitted when a vote has been cast on a proposal\n    /// @param voter The address which casted a vote\n    /// @param proposalId The proposal id which was voted on\n    /// @param support Support value for the vote. 0=against, 1=for, 2=abstain\n    /// @param votes Number of votes which were cast by the voter\n    /// @param reason The reason given for the vote by the voter\n    event VoteCast(address indexed voter, uint256 proposalId, uint8 support, uint256 votes, string reason);\n\n    /// @notice An event emitted when a proposal has been canceled\n    event ProposalCanceled(uint256 id);\n\n    /// @notice An event emitted when a proposal has been queued in the NounsDAOExecutor\n    event ProposalQueued(uint256 id, uint256 eta);\n\n    /// @notice An event emitted when a proposal has been executed in the NounsDAOExecutor\n    event ProposalExecuted(uint256 id);\n\n    /// @notice An event emitted when a proposal has been vetoed by vetoAddress\n    event ProposalVetoed(uint256 id);\n\n    /// @notice An event emitted when the voting delay is set\n    event VotingDelaySet(uint256 oldVotingDelay, uint256 newVotingDelay);\n\n    /// @notice An event emitted when the voting period is set\n    event VotingPeriodSet(uint256 oldVotingPeriod, uint256 newVotingPeriod);\n\n    /// @notice Emitted when implementation is changed\n    event NewImplementation(address oldImplementation, address newImplementation);\n\n    /// @notice Emitted when proposal threshold basis points is set\n    event ProposalThresholdBPSSet(uint256 oldProposalThresholdBPS, uint256 newProposalThresholdBPS);\n\n    /// @notice Emitted when quorum votes basis points is set\n    event QuorumVotesBPSSet(uint256 oldQuorumVotesBPS, uint256 newQuorumVotesBPS);\n\n    /// @notice Emitted when pendingAdmin is changed\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n    /// @notice Emitted when pendingAdmin is accepted, which means admin is updated\n    event NewAdmin(address oldAdmin, address newAdmin);\n\n    /// @notice Emitted when vetoer is changed\n    event NewVetoer(address oldVetoer, address newVetoer);\n}\n\ncontract NounsDAOEventsV2 is NounsDAOEvents {\n    /// @notice Emitted when minQuorumVotesBPS is set\n    event MinQuorumVotesBPSSet(uint16 oldMinQuorumVotesBPS, uint16 newMinQuorumVotesBPS);\n\n    /// @notice Emitted when maxQuorumVotesBPS is set\n    event MaxQuorumVotesBPSSet(uint16 oldMaxQuorumVotesBPS, uint16 newMaxQuorumVotesBPS);\n\n    /// @notice Emitted when quorumCoefficient is set\n    event QuorumCoefficientSet(uint32 oldQuorumCoefficient, uint32 newQuorumCoefficient);\n\n    /// @notice Emitted when a voter cast a vote requesting a gas refund.\n    event RefundableVote(address indexed voter, uint256 refundAmount, bool refundSent);\n\n    /// @notice Emitted when admin withdraws the DAO's balance.\n    event Withdraw(uint256 amount, bool sent);\n}\n\ncontract NounsDAOProxyStorage {\n    /// @notice Administrator for this contract\n    address public admin;\n\n    /// @notice Pending administrator for this contract\n    address public pendingAdmin;\n\n    /// @notice Active brains of Governor\n    address public implementation;\n}\n\n/**\n * @title Storage for Governor Bravo Delegate\n * @notice For future upgrades, do not change NounsDAOStorageV1. Create a new\n * contract which implements NounsDAOStorageV1 and following the naming convention\n * NounsDAOStorageVX.\n */\ncontract NounsDAOStorageV1 is NounsDAOProxyStorage {\n    /// @notice Vetoer who has the ability to veto any proposal\n    address public vetoer;\n\n    /// @notice The delay before voting on a proposal may take place, once proposed, in blocks\n    uint256 public votingDelay;\n\n    /// @notice The duration of voting on a proposal, in blocks\n    uint256 public votingPeriod;\n\n    /// @notice The basis point number of votes required in order for a voter to become a proposer. *DIFFERS from GovernerBravo\n    uint256 public proposalThresholdBPS;\n\n    /// @notice The basis point number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed. *DIFFERS from GovernerBravo\n    uint256 public quorumVotesBPS;\n\n    /// @notice The total number of proposals\n    uint256 public proposalCount;\n\n    /// @notice The address of the Nouns DAO Executor NounsDAOExecutor\n    INounsDAOExecutor public timelock;\n\n    /// @notice The address of the Nouns tokens\n    NounsTokenLike public nouns;\n\n    /// @notice The official record of all proposals ever proposed\n    mapping(uint256 => Proposal) public proposals;\n\n    /// @notice The latest proposal for each proposer\n    mapping(address => uint256) public latestProposalIds;\n\n    struct Proposal {\n        /// @notice Unique id for looking up a proposal\n        uint256 id;\n        /// @notice Creator of the proposal\n        address proposer;\n        /// @notice The number of votes needed to create a proposal at the time of proposal creation. *DIFFERS from GovernerBravo\n        uint256 proposalThreshold;\n        /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed at the time of proposal creation. *DIFFERS from GovernerBravo\n        uint256 quorumVotes;\n        /// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\n        uint256 eta;\n        /// @notice the ordered list of target addresses for calls to be made\n        address[] targets;\n        /// @notice The ordered list of values (i.e. msg.value) to be passed to the calls to be made\n        uint256[] values;\n        /// @notice The ordered list of function signatures to be called\n        string[] signatures;\n        /// @notice The ordered list of calldata to be passed to each call\n        bytes[] calldatas;\n        /// @notice The block at which voting begins: holders must delegate their votes prior to this block\n        uint256 startBlock;\n        /// @notice The block at which voting ends: votes must be cast prior to this block\n        uint256 endBlock;\n        /// @notice Current number of votes in favor of this proposal\n        uint256 forVotes;\n        /// @notice Current number of votes in opposition to this proposal\n        uint256 againstVotes;\n        /// @notice Current number of votes for abstaining for this proposal\n        uint256 abstainVotes;\n        /// @notice Flag marking whether the proposal has been canceled\n        bool canceled;\n        /// @notice Flag marking whether the proposal has been vetoed\n        bool vetoed;\n        /// @notice Flag marking whether the proposal has been executed\n        bool executed;\n        /// @notice Receipts of ballots for the entire set of voters\n        mapping(address => Receipt) receipts;\n    }\n\n    /// @notice Ballot receipt record for a voter\n    struct Receipt {\n        /// @notice Whether or not a vote has been cast\n        bool hasVoted;\n        /// @notice Whether or not the voter supports the proposal or abstains\n        uint8 support;\n        /// @notice The number of votes the voter had, which were cast\n        uint96 votes;\n    }\n\n    /// @notice Possible states that a proposal may be in\n    enum ProposalState {\n        Pending,\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed,\n        Vetoed\n    }\n}\n\n/**\n * @title Extra fields added to the `Proposal` struct from NounsDAOStorageV1\n * @notice The following fields were added to the `Proposal` struct:\n * - `Proposal.totalSupply`\n * - `Proposal.creationBlock`\n */\ncontract NounsDAOStorageV1Adjusted is NounsDAOProxyStorage {\n    /// @notice Vetoer who has the ability to veto any proposal\n    address public vetoer;\n\n    /// @notice The delay before voting on a proposal may take place, once proposed, in blocks\n    uint256 public votingDelay;\n\n    /// @notice The duration of voting on a proposal, in blocks\n    uint256 public votingPeriod;\n\n    /// @notice The basis point number of votes required in order for a voter to become a proposer. *DIFFERS from GovernerBravo\n    uint256 public proposalThresholdBPS;\n\n    /// @notice The basis point number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed. *DIFFERS from GovernerBravo\n    uint256 public quorumVotesBPS;\n\n    /// @notice The total number of proposals\n    uint256 public proposalCount;\n\n    /// @notice The address of the Nouns DAO Executor NounsDAOExecutor\n    INounsDAOExecutor public timelock;\n\n    /// @notice The address of the Nouns tokens\n    NounsTokenLike public nouns;\n\n    /// @notice The official record of all proposals ever proposed\n    mapping(uint256 => Proposal) internal _proposals;\n\n    /// @notice The latest proposal for each proposer\n    mapping(address => uint256) public latestProposalIds;\n\n    struct Proposal {\n        /// @notice Unique id for looking up a proposal\n        uint256 id;\n        /// @notice Creator of the proposal\n        address proposer;\n        /// @notice The number of votes needed to create a proposal at the time of proposal creation. *DIFFERS from GovernerBravo\n        uint256 proposalThreshold;\n        /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed at the time of proposal creation. *DIFFERS from GovernerBravo\n        uint256 quorumVotes;\n        /// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\n        uint256 eta;\n        /// @notice the ordered list of target addresses for calls to be made\n        address[] targets;\n        /// @notice The ordered list of values (i.e. msg.value) to be passed to the calls to be made\n        uint256[] values;\n        /// @notice The ordered list of function signatures to be called\n        string[] signatures;\n        /// @notice The ordered list of calldata to be passed to each call\n        bytes[] calldatas;\n        /// @notice The block at which voting begins: holders must delegate their votes prior to this block\n        uint256 startBlock;\n        /// @notice The block at which voting ends: votes must be cast prior to this block\n        uint256 endBlock;\n        /// @notice Current number of votes in favor of this proposal\n        uint256 forVotes;\n        /// @notice Current number of votes in opposition to this proposal\n        uint256 againstVotes;\n        /// @notice Current number of votes for abstaining for this proposal\n        uint256 abstainVotes;\n        /// @notice Flag marking whether the proposal has been canceled\n        bool canceled;\n        /// @notice Flag marking whether the proposal has been vetoed\n        bool vetoed;\n        /// @notice Flag marking whether the proposal has been executed\n        bool executed;\n        /// @notice Receipts of ballots for the entire set of voters\n        mapping(address => Receipt) receipts;\n        /// @notice The total supply at the time of proposal creation\n        uint256 totalSupply;\n        /// @notice The block at which this proposal was created\n        uint256 creationBlock;\n    }\n\n    /// @notice Ballot receipt record for a voter\n    struct Receipt {\n        /// @notice Whether or not a vote has been cast\n        bool hasVoted;\n        /// @notice Whether or not the voter supports the proposal or abstains\n        uint8 support;\n        /// @notice The number of votes the voter had, which were cast\n        uint96 votes;\n    }\n\n    /// @notice Possible states that a proposal may be in\n    enum ProposalState {\n        Pending,\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed,\n        Vetoed\n    }\n}\n\n/**\n * @title Storage for Governor Bravo Delegate\n * @notice For future upgrades, do not change NounsDAOStorageV2. Create a new\n * contract which implements NounsDAOStorageV2 and following the naming convention\n * NounsDAOStorageVX.\n */\ncontract NounsDAOStorageV2 is NounsDAOStorageV1Adjusted {\n    DynamicQuorumParamsCheckpoint[] public quorumParamsCheckpoints;\n\n    struct DynamicQuorumParams {\n        /// @notice The minimum basis point number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed.\n        uint16 minQuorumVotesBPS;\n        /// @notice The maximum basis point number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed.\n        uint16 maxQuorumVotesBPS;\n        /// @notice The dynamic quorum coefficient\n        /// @dev Assumed to be fixed point integer with 6 decimals, i.e 0.2 is represented as 0.2 * 1e6 = 200000\n        uint32 quorumCoefficient;\n    }\n\n    /// @notice A checkpoint for storing dynamic quorum params from a given block\n    struct DynamicQuorumParamsCheckpoint {\n        /// @notice The block at which the new values were set\n        uint32 fromBlock;\n        /// @notice The parameter values of this checkpoint\n        DynamicQuorumParams params;\n    }\n\n    struct ProposalCondensed {\n        /// @notice Unique id for looking up a proposal\n        uint256 id;\n        /// @notice Creator of the proposal\n        address proposer;\n        /// @notice The number of votes needed to create a proposal at the time of proposal creation. *DIFFERS from GovernerBravo\n        uint256 proposalThreshold;\n        /// @notice The minimum number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed at the time of proposal creation. *DIFFERS from GovernerBravo\n        uint256 quorumVotes;\n        /// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\n        uint256 eta;\n        /// @notice The block at which voting begins: holders must delegate their votes prior to this block\n        uint256 startBlock;\n        /// @notice The block at which voting ends: votes must be cast prior to this block\n        uint256 endBlock;\n        /// @notice Current number of votes in favor of this proposal\n        uint256 forVotes;\n        /// @notice Current number of votes in opposition to this proposal\n        uint256 againstVotes;\n        /// @notice Current number of votes for abstaining for this proposal\n        uint256 abstainVotes;\n        /// @notice Flag marking whether the proposal has been canceled\n        bool canceled;\n        /// @notice Flag marking whether the proposal has been vetoed\n        bool vetoed;\n        /// @notice Flag marking whether the proposal has been executed\n        bool executed;\n        /// @notice The total supply at the time of proposal creation\n        uint256 totalSupply;\n        /// @notice The block at which this proposal was created\n        uint256 creationBlock;\n    }\n}\n\ninterface INounsDAOExecutor {\n    function delay() external view returns (uint256);\n\n    function GRACE_PERIOD() external view returns (uint256);\n\n    function acceptAdmin() external;\n\n    function queuedTransactions(bytes32 hash) external view returns (bool);\n\n    function queueTransaction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 eta\n    ) external returns (bytes32);\n\n    function cancelTransaction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 eta\n    ) external;\n\n    function executeTransaction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 eta\n    ) external payable returns (bytes memory);\n}\n\ninterface NounsTokenLike {\n    function getPriorVotes(address account, uint256 blockNumber) external view returns (uint96);\n\n    function totalSupply() external view returns (uint96);\n}"
    }
  ]
}