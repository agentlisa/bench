{
  "Title": "H-6: Unable to reinvest if the reward token equals one of the pool tokens",
  "Content": "# Issue H-6: Unable to reinvest if the reward token equals one of the pool tokens \n\nSource: https://github.com/sherlock-audit/2023-10-notional-judging/issues/84 \n\n## Found by \ncoffiasd, mstpr-brainbot, xiaoming90\n## Summary\n\nIf the reward token is the same as one of the pool tokens, the protocol would not be able to reinvest such a reward token. Thus leading to a loss of assets for the vault shareholders.\n\n## Vulnerability Detail\n\nDuring the reinvestment process, the `reinvestReward` function will be executed once for each reward token. The length of the `trades` listing defined in the payload must be the same as the number of tokens in the pool per Line 339 below.\n\nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/vaults/common/SingleSidedLPVaultBase.sol#L385\n\n```solidity\nFile: SingleSidedLPVaultBase.sol\n385:     function reinvestReward(\n386:         SingleSidedRewardTradeParams[] calldata trades,\n387:         uint256 minPoolClaim\n388:     ) external whenNotLocked onlyRole(REWARD_REINVESTMENT_ROLE) returns (\n389:         address rewardToken,\n390:         uint256 amountSold,\n391:         uint256 poolClaimAmount\n392:     ) {\n393:         // Will revert if spot prices are not in line with the oracle values\n394:         _checkPriceAndCalculateValue();\n395: \n396:         // Require one trade per token, if we do not want to buy any tokens at a\n397:         // given index then the amount should be set to zero. This applies to pool\n398:         // tokens like in the ComposableStablePool.\n399:         require(trades.length == NUM_TOKENS());\n400:         uint256[] memory amounts;\n401:         (rewardToken, amountSold, amounts) = _executeRewardTrades(trades);\n```\n\nIn addition, due to the requirement at Line 105, each element in the `trades` listing must be a token within a pool and must be ordered in sequence according to the token index of the pool.\n\nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/vaults/common/StrategyUtils.sol#L90\n\n```solidity\nFile: StrategyUtils.sol\n090:     function executeRewardTrades(\n091:         IERC20[] memory tokens,\n092:         SingleSidedRewardTradeParams[] calldata trades,\n093:         address rewardToken,\n094:         address poolToken\n095:     ) external returns(uint256[] memory amounts, uint256 amountSold) {\n096:         amounts = new uint256[](trades.length);\n097:         for (uint256 i; i < trades.length; i++) {\n098:             // All trades must sell the same token.\n099:             require(trades[i].sellToken == rewardToken);\n100:             // Bypass certain invalid trades\n101:             if (trades[i].amount == 0) continue;\n102:             if (trades[i].buyToken == poolToken) continue;\n103: \n104:             // The reward trade can only purchase tokens that go into the pool\n105:             require(trades[i].buyToken == address(tokens[i]));\n```\n\nAssuming the TriCRV Curve pool (crvUSD+WETH+CRV) has two reward tokens (CRV & CVX). This example is taken from a live Curve pool on Ethereum ([Reference 1](https://curve.fi/#/ethereum/pools/factory-tricrypto-4/deposit) [Reference 2](https://www.convexfinance.com/stake/ethereum/211))\n\nThe pool will consist of the following tokens:\n\n```solidity\ntokens[0] = crvUSD\ntokens[1] = WETH\ntokens[2] = CRV\n```\n\nThus, if the protocol receives 3000 CVX reward tokens and it intends to sell 1000 CVX for crvUSD and 1000 CVX for WETH.\n\nThe `trades` list has to be defined as below.\n\n```solidity\ntrades[0].sellToken[0] = CRV (rewardToken) | trades[0].buyToken = crvUSD | trades[0].amount = 1000\ntrades[1].sellToken[1] = CRV (rewardToken) | trades[1].buyToken = WETH    | trades[0].amount = 1000\ntrades[1].sellToken[2] = CRV (rewardToken) | trades[1].buyToken = CRV    | trades[0].amount = 0\n```\n\nThe same issue also affects the Balancer pools. Thus, the example is omitted for brevity. One of the affected Balancer pools is as follows, where the reward token is also one of the pool tokens.\n\n- WETH-AURA - [Reference 1](https://app.balancer.fi/#/ethereum/pool/0xcfca23ca9ca720b6e98e3eb9b6aa0ffc4a5c08b9000200000000000000000274) [Reference 2](https://app.aura.finance/#/1/pool/100) (Reward Tokens = [BAL, AURA])\n\nHowever, the issue is that the `_isInvalidRewardToken` function within the `_executeRewardTrades` will always revert.\n\nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/vaults/common/SingleSidedLPVaultBase.sol#L413\n\n```solidity\nFile: SingleSidedLPVaultBase.sol\n413:     function _executeRewardTrades(SingleSidedRewardTradeParams[] calldata trades) internal returns (\n414:         address rewardToken,\n415:         uint256 amountSold,\n416:         uint256[] memory amounts\n417:     ) {\n418:         // The sell token on all trades must be the same (checked inside executeRewardTrades) so\n419:         // just validate here that the sellToken is a valid reward token (i.e. none of the tokens\n420:         // used in the regular functioning of the vault).\n421:         rewardToken = trades[0].sellToken;\n422:         if (_isInvalidRewardToken(rewardToken)) revert Errors.InvalidRewardToken(rewardToken);\n423:         (IERC20[] memory tokens, /* */) = TOKENS();\n424:         (amounts, amountSold) = StrategyUtils.executeRewardTrades(\n425:             tokens, trades, rewardToken, address(POOL_TOKEN())\n426:         );\n427:     }\n```\n\nThe reason is that within the `_isInvalidRewardToken` function it checks if the reward token to be sold is any of the pool tokens. In this case, the condition will be evaluated to be true, and a revert will occur. As a result, the protocol would not be able to reinvest such reward tokens.\n\nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/mixins/AuraStakingMixin.sol#L38\n\n```solidity\nFile: AuraStakingMixin.sol\n38:     function _isInvalidRewardToken(address token) internal override view returns (bool) {\n39:         return (\n40:             token == TOKEN_1 ||\n41:             token == TOKEN_2 ||\n42:             token == TOKEN_3 ||\n43:             token == TOKEN_4 ||\n44:             token == TOKEN_5 ||\n45:             token == address(AURA_BOOSTER) ||\n46:             token == address(AURA_REWARD_POOL) ||\n47:             token == address(Deployments.WETH)\n48:         );\n49:     }\n```\n\nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/vaults/curve/ConvexStakingMixin.sol#L60\n\n```solidity\nFile: ConvexStakingMixin.sol\n60:     function _isInvalidRewardToken(address token) internal override view returns (bool) {\n61:         return (\n62:             token == TOKEN_1 ||\n63:             token == TOKEN_2 ||\n64:             token == address(CURVE_POOL_TOKEN) ||\n65:             token == address(CONVEX_REWARD_POOL) ||\n66:             token == address(CONVEX_BOOSTER) ||\n67:             token == Deployments.ALT_ETH_ADDRESS\n68:         );\n69:     }\n```\n\n## Impact\n\nThe reinvestment of reward tokens is a critical component of the vault. The value per vault share increases when reward tokens are sold for the pool tokens and reinvested back into the Curve/Balancer pool to obtain more LP tokens. If this feature does not work as intended, it will lead to a loss of assets for the vault shareholders.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/vaults/common/SingleSidedLPVaultBase.sol#L385\n\nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/mixins/AuraStakingMixin.sol#L38\n\nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/vaults/curve/ConvexStakingMixin.sol#L60\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider tracking the number of pool tokens received during an emergency exit, and segregate these tokens with the reward tokens. For instance, the vault has 3000 CVX, 1000 of them are received during the emergency exit, while the rest are reward tokens emitted from Convex/Aura. In this case, the protocol can sell all CVX on the vault except for the 1000 CVX reserved.\n\n\n\n## Discussion\n\n**jeffywu**\n\nFair point, we will need to make some accommodations in these cases.\n\n**jeffywu**\n\nhttps://github.com/notional-finance/leveraged-vaults/pull/73\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/119",
  "Code": [
    {
      "filename": "leveraged-vaults/contracts/vaults/common/SingleSidedLPVaultBase.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\";\n\nimport {BaseStrategyVault} from \"./BaseStrategyVault.sol\";\nimport {Errors} from \"../../global/Errors.sol\";\nimport {Constants} from \"../../global/Constants.sol\";\nimport {TypeConvert} from \"../../global/TypeConvert.sol\";\nimport {TokenUtils} from \"../../utils/TokenUtils.sol\";\nimport {StrategyUtils} from \"./StrategyUtils.sol\";\nimport {VaultStorage} from \"./VaultStorage.sol\";\n\nimport {IERC20} from \"../../../interfaces/IERC20.sol\";\nimport {\n    ISingleSidedLPStrategyVault,\n    StrategyVaultSettings,\n    InitParams,\n    StrategyVaultState,\n    SingleSidedRewardTradeParams,\n    DepositParams,\n    DepositTradeParams,\n    RedeemParams,\n    TradeParams\n} from \"../../../interfaces/notional/ISingleSidedLPStrategyVault.sol\";\nimport {NotionalProxy} from \"../../../interfaces/notional/NotionalProxy.sol\";\nimport {ITradingModule, DexId} from \"../../../interfaces/trading/ITradingModule.sol\";\n\n/**\n * @notice Base contract for the SingleSidedLP strategy. This strategy deposits into an LP\n * pool given a single borrowed currency. Allows for users to trade via external exchanges\n * during entry and exit, but the general expected behavior is single sided entries and\n * exits. Inheriting contracts will fill in the implementation details for integration with\n * the external DEX pool.\n */\nabstract contract SingleSidedLPVaultBase is BaseStrategyVault, UUPSUpgradeable, ISingleSidedLPStrategyVault {\n    using TypeConvert for uint256;\n    using VaultStorage for StrategyVaultState;\n\n    uint256 internal constant MAX_TOKENS = 5;\n    uint8 internal constant NOT_FOUND = type(uint8).max;\n    /// @notice Bit mask for the 'LOCKED\" flag big\n    uint32 internal constant FLAG_LOCKED = 1 << 0;\n\n    /************************************************************************\n     * VIRTUAL FUNCTIONS                                                    *\n     * These virtual functions are used to isolate implementation specific  *\n     * behavior.                                                            *\n     ************************************************************************/\n\n    /// @notice Total number of tokens held by the LP token\n    function NUM_TOKENS() internal view virtual returns (uint256);\n\n    /// @notice Addresses of tokens held and decimal places of each token. ETH will always be\n    /// recorded in this array as Deployments.ETH_Address\n    function TOKENS() internal view virtual returns (IERC20[] memory, uint8[] memory decimals);\n\n    /// @notice Address of the LP token\n    function POOL_TOKEN() internal view virtual returns (IERC20);\n\n    /// @notice Index of the TOKENS() array that refers to the primary borrowed currency by the\n    /// leveraged vault. All valuations are done in terms of this currency.\n    function PRIMARY_INDEX() internal view virtual returns (uint256);\n\n    /// @notice Precision (i.e. 10 ** decimals) of the LP token.\n    function POOL_PRECISION() internal view virtual returns (uint256);\n\n    /// @notice Returns the value of one LP token in terms of the primary borrowed currency by this\n    /// strategy. Will revert if the spot price on the pool is not within some deviation tolerance of\n    /// the implied oracle price. This is intended to prevent any pool manipulation.\n    /// The value of the LP token is calculated as the value of the token if all the balance claims are\n    /// withdrawn proportionally and then converted to the primary currency at the oracle price. Slippage\n    /// from selling the tokens is not considered, any slippage effects will be captured by the maximum\n    /// leverage ratio allowed before liquidation.\n    function _checkPriceAndCalculateValue() internal view virtual returns (uint256 oneLPValueInPrimary);\n\n    /// @notice Called once during initialization to set the initial token approvals.\n    function _initialApproveTokens() internal virtual;\n\n    /// @notice Called to claim reward tokens\n    function _claimRewardTokens() internal virtual;\n\n    /// @notice Called during reward reinvestment to validate that the token being sold is not one\n    /// of the tokens that is required for the vault to function properly (i.e. one of the pool tokens\n    /// or any of the reward booster tokens).\n    function _isInvalidRewardToken(address token) internal view virtual returns (bool);\n\n    /// @notice Implementation specific wrapper for joining a pool with the given amounts. Will also\n    /// stake on the relevant booster protocol.\n    function _joinPoolAndStake(\n        uint256[] memory amounts, uint256 minPoolClaim\n    ) internal virtual returns (uint256 lpTokens);\n\n    /// @notice Implementation specific wrapper for unstaking from the booster protocol and withdrawing\n    /// funds from the LP pool\n    function _unstakeAndExitPool(\n        uint256 poolClaim, uint256[] memory minAmounts, bool isSingleSided\n    ) internal virtual returns (uint256[] memory exitBalances);\n\n    /// @notice Returns the total supply of the pool token. Is a virtual function because\n    /// ComposableStablePools use a \"virtual supply\" and a different method must be called\n    /// to get the actual total supply.\n    function _totalPoolSupply() internal view virtual returns (uint256) {\n        return POOL_TOKEN().totalSupply();\n    }\n\n    /************************************************************************\n     * CLASS FUNCTIONS                                                      *\n     * Below are class functions that represent the base implementation     *\n     * of the Single Sided LP strategy.                                     *\n     ************************************************************************/\n\n    constructor(NotionalProxy notional_, ITradingModule tradingModule_)\n        BaseStrategyVault(notional_, tradingModule_) {}\n\n    /************************************************************************\n     * EXTERNAL VIEW FUNCTIONS                                              *\n     ************************************************************************/\n\n    /// @notice Returns basic information about the vault for use in the user interface.\n    function getStrategyVaultInfo() external view override returns (SingleSidedLPStrategyVaultInfo memory) {\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n        return SingleSidedLPStrategyVaultInfo({\n            pool: address(POOL_TOKEN()),\n            singleSidedTokenIndex: uint8(PRIMARY_INDEX()),\n            totalLPTokens: state.totalPoolClaim,\n            totalVaultShares: state.totalVaultSharesGlobal\n        });\n    }\n\n    /// @notice Returns the current locked status of the vault\n    function isLocked() public view returns (bool) {\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n        return _hasFlag(state.flags, FLAG_LOCKED);\n    }\n\n    /// @notice Returns the current price of a vault share, even when there are no vault shares\n    /// in the strategy. Used by the user interface to collect historical valuation information.\n    function getExchangeRate(uint256 /* maturity */) external view override returns (int256) {\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n        uint256 oneLPValueInPrimary = _checkPriceAndCalculateValue();\n        // If inside an emergency exit, just report the one LP value in primary since the total\n        // pool claim will be 0\n        if (state.totalVaultSharesGlobal == 0 || isLocked()) {\n            return oneLPValueInPrimary.toInt();\n        } else {\n            uint256 lpTokensPerVaultShare = (uint256(Constants.INTERNAL_TOKEN_PRECISION) * state.totalPoolClaim)\n                / state.totalVaultSharesGlobal;\n            return (oneLPValueInPrimary * lpTokensPerVaultShare / POOL_PRECISION()).toInt();\n        }\n    }\n\n    /************************************************************************\n     * ADMIN FUNCTIONS                                                      *\n     * Administrative functions to set settings and initialize the vault.   *\n     * These methods are only callable by the Notional owner.               *\n     ************************************************************************/\n\n    /// @notice Allow Notional owner to upgrade the contract\n    function _authorizeUpgrade(\n        address /* newImplementation */\n    ) internal override onlyNotionalOwner {}\n\n    /// @notice Updates the vault settings include the maximum oracle deviation limit and the\n    /// maximum percent of the LP pool that the vault can hold.\n    function setStrategyVaultSettings(StrategyVaultSettings calldata settings) external onlyNotionalOwner {\n        // Validation occurs inside this method\n        VaultStorage.setStrategyVaultSettings(settings);\n    }\n\n    /// @notice Called to initialize the vault and set the initial approvals. All of the other vault\n    /// parameters are set via immutable parameters already.\n    function initialize(InitParams calldata params) external override initializer onlyNotionalOwner {\n        // Initialize the base vault\n        __INIT_VAULT(params.name, params.borrowCurrencyId);\n\n        // Settings are validated in setStrategyVaultSettings\n        VaultStorage.setStrategyVaultSettings(params.settings);\n\n        _initialApproveTokens();\n    }\n\n    /************************************************************************\n     * USER FUNCTIONS                                                       *\n     * These functions are called during normal usage of the vault.         *\n     * They allow for deposits and redemptions from the vault as well as a  *\n     * valuation check that is used by Notional to determine if the user is *\n     * properly collateralized.                                             *\n     ************************************************************************/\n\n    /// @notice This is a virtual function called by BaseStrategyVault which ensures that\n    /// this method is only called by Notional after an initial borrow has been made and\n    /// the deposit amount has been transferred to this vault. Will join the LP pool with\n    /// the funds given and then return the total vault shares minted.\n    function _depositFromNotional(\n        address /* account */, uint256 deposit, uint256 /* maturity */, bytes calldata data\n    ) internal override whenNotLocked returns (uint256 vaultSharesMinted) {\n        // Short circuit any zero deposit amounts\n        if (deposit == 0) return 0;\n\n        DepositParams memory params = abi.decode(data, (DepositParams));\n        uint256[] memory amounts = new uint256[](NUM_TOKENS());\n        amounts[PRIMARY_INDEX()] = deposit;\n\n        // If depositTrades are specified, then parts of the initial deposit are traded\n        // for corresponding amounts of the other pool tokens via external exchanges. If\n        // these amounts are not specified then the pool will just be joined single sided.\n        // Deposit trades are not automatically enabled on vaults since the trading module\n        // requires explicit permission for every token that can be sold by an address.\n        if (params.depositTrades.length > 0) {\n            (IERC20[] memory tokens, /* */) = TOKENS();\n            // This is an external library call so the memory location of amounts is\n            // different before and after the call.\n            amounts = StrategyUtils.executeDepositTrades(\n                tokens,\n                amounts,\n                params.depositTrades,\n                PRIMARY_INDEX()\n            );\n        }\n\n        uint256 lpTokens = _joinPoolAndStake(amounts, params.minPoolClaim);\n        return _mintVaultShares(lpTokens);\n    }\n\n    /// @notice Given a number of LP tokens minted, issues vault shares back to the holder. Vault\n    /// shares are claim on the LP tokens held by the vault. As rewards are reinvested, one vault\n    /// share is a claim on an increasing amount of LP tokens.\n    function _mintVaultShares(uint256 lpTokens) internal returns (uint256 vaultShares) {\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n        if (state.totalPoolClaim == 0) {\n            // Vault Shares are in 8 decimal precision\n            vaultShares = (lpTokens * uint256(Constants.INTERNAL_TOKEN_PRECISION)) / POOL_PRECISION();\n        } else {\n            vaultShares = (lpTokens * state.totalVaultSharesGlobal) / state.totalPoolClaim;\n        }\n\n        // Updates internal storage here\n        state.totalPoolClaim += lpTokens;\n        state.totalVaultSharesGlobal += vaultShares.toUint80();\n        state.setStrategyVaultState();\n\n        // Checks that the vault does not own too large of a portion of the pool. If this is the case,\n        // single sided exits may have a detrimental effect on the liquidity.\n        uint256 maxPoolShare = VaultStorage.getStrategyVaultSettings().maxPoolShare;\n        uint256 maxSupplyThreshold = (_totalPoolSupply() * maxPoolShare) / Constants.VAULT_PERCENT_BASIS;\n        if (maxSupplyThreshold < state.totalPoolClaim)\n            revert Errors.PoolShareTooHigh(state.totalPoolClaim, maxSupplyThreshold);\n    }\n\n    /// @notice This is a virtual function called by BaseStrategyVault which ensures that\n    /// this method is only called by Notional after an initial position has been made. Will\n    /// withdraw the LP tokens from the pool, either single sided or proportionally. On a\n    /// proportional exit, will trade all the tokens back to the primary in order to exit the pool.\n    /// @return finalPrimaryBalance which is the amount of funds that the vault will transfer back\n    /// to Notional and the account to repay debts and withdraw profits.\n    function _redeemFromNotional(\n        address /* account */, uint256 vaultShares, uint256 /* maturity */, bytes calldata data\n    ) internal override whenNotLocked returns (uint256 finalPrimaryBalance) {\n        // Short circuit any zero redemption amounts, this can occur during rolling positions\n        // or withdraw cash balances post liquidation.\n        if (vaultShares == 0) return 0;\n\n        // Updates internal account to deduct the vault shares.\n        uint256 poolClaim = _redeemVaultShares(vaultShares);\n        RedeemParams memory params = abi.decode(data, (RedeemParams));\n\n        bool isSingleSided = params.redemptionTrades.length == 0;\n        // Returns the amount of each token that has been withdrawn from the pool.\n        uint256[] memory exitBalances = _unstakeAndExitPool(poolClaim, params.minAmounts, isSingleSided);\n        if (!isSingleSided) {\n            // If not a single sided trade, will execute trades back to the primary token on\n            // external exchanges. This method will execute EXACT_IN trades to ensure that\n            // all of the balance in the other tokens is sold for primary.\n            (IERC20[] memory tokens, /* */) = TOKENS();\n            // Redemption trades are not automatically enabled on vaults since the trading module\n            // requires explicit permission for every token that can be sold by an address.\n            return StrategyUtils.executeRedemptionTrades(\n                tokens,\n                exitBalances,\n                params.redemptionTrades,\n                PRIMARY_INDEX()\n            );\n        } else {\n            // No explicit check is done here to ensure that the other balances are zero, assumed\n            // that the `_unstakeAndExitPool` method on the implementation is correct and will only\n            // ever withdraw to a single balance.\n            return exitBalances[PRIMARY_INDEX()];\n        }\n    }\n\n    /// @notice Updates internal account for vault share redemption.\n    function _redeemVaultShares(uint256 vaultShares) internal returns (uint256 poolClaim) {\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n        // Will revert on divide by zero, which is the correct behavior\n        poolClaim = (vaultShares * state.totalPoolClaim) / state.totalVaultSharesGlobal;\n\n        state.totalPoolClaim -= poolClaim;\n        // Will revert on underflow if vault shares is greater than total shares global\n        state.totalVaultSharesGlobal -= vaultShares.toUint80();\n        state.setStrategyVaultState();\n    }\n\n    /// @notice Converts the vault shares to an oracle value in underlying tokens. Used by Notional\n    /// to determine the collateral position of a vault user. If the vault is locked due to an\n    /// emergency exit, this function will revert which will prevent users from entering, exiting,\n    /// and being liquidated. During emergency exit, the vault will not be holding any LP tokens and\n    /// therefore this calculation will not be correct.\n    function convertStrategyToUnderlying(\n        address /* */, uint256 vaultShares, uint256 /* */\n    ) public view override whenNotLocked returns (int256 underlyingValue) {\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n        // Will revert on divide by zero, which is the correct behavior\n        uint256 lpTokens = (vaultShares * state.totalPoolClaim) / state.totalVaultSharesGlobal;\n        uint256 oneLPValueInPrimary = _checkPriceAndCalculateValue();\n\n        return (oneLPValueInPrimary * lpTokens / POOL_PRECISION()).toInt();\n    }\n\n    /// @notice Returns the pair price of two tokens via the TRADING_MODULE which holds a registry\n    /// of oracles. Will revert of the oracle pair is not listed.\n    function _getOraclePairPrice(address base, address quote) internal view returns (uint256) {\n        (int256 rate, int256 precision) = TRADING_MODULE.getOraclePrice(base, quote);\n        require(rate > 0);\n        require(precision > 0);\n        return uint256(rate) * POOL_PRECISION() / uint256(precision);\n    }\n\n    /// @notice Helper method called by _checkPriceAndCalculateValue which will supply the relevant\n    /// pool balances and spot prices. Calculates the claim of one LP token on relevant pool balances\n    /// and compares the oracle price to the spot price, reverting if the deviation is too high.\n    /// @return oneLPValueInPrimary the value of one LP token in terms of the primary borrowed currency\n    function _calculateLPTokenValue(\n        uint256[] memory balances,\n        uint256[] memory spotPrices\n    ) internal view returns (uint256 oneLPValueInPrimary) {\n        (IERC20[] memory tokens, uint8[] memory decimals) = TOKENS();\n        address primaryToken = address(tokens[PRIMARY_INDEX()]);\n        uint256 primaryDecimals = 10 ** decimals[PRIMARY_INDEX()];\n        uint256 totalSupply = _totalPoolSupply();\n        uint256 limit = VaultStorage.getStrategyVaultSettings().oraclePriceDeviationLimitPercent;\n\n        for (uint256 i; i < tokens.length; i++) {\n            // Skip the pool token if it is in the token list (i.e. ComposablePools)\n            if (address(tokens[i]) == address(POOL_TOKEN())) continue;\n            // This is the claim on the pool balance of 1 LP token.\n            uint256 tokenClaim = balances[i] * POOL_PRECISION() / totalSupply;\n            if (i == PRIMARY_INDEX()) {\n                oneLPValueInPrimary += tokenClaim;\n            } else {\n                uint256 price = _getOraclePairPrice(primaryToken, address(tokens[i]));\n\n                // Check that the spot price and the oracle price are near each other. If this is\n                // not true then we assume that the LP pool is being manipulated.\n                uint256 lowerLimit = price * (Constants.VAULT_PERCENT_BASIS - limit) / Constants.VAULT_PERCENT_BASIS;\n                uint256 upperLimit = price * (Constants.VAULT_PERCENT_BASIS + limit) / Constants.VAULT_PERCENT_BASIS;\n                if (spotPrices[i] < lowerLimit || upperLimit < spotPrices[i]) {\n                    revert Errors.InvalidPrice(price, spotPrices[i]);\n                }\n\n                // Convert the token claim to primary using the oracle pair price.\n                uint256 secondaryDecimals = 10 ** decimals[i];\n                oneLPValueInPrimary += (tokenClaim * POOL_PRECISION() * primaryDecimals) / \n                    (price * secondaryDecimals);\n            }\n        }\n    }\n\n    /************************************************************************\n     * REWARD REINVESTMENT                                                  *\n     * Methods used by bots to claim reward tokens and reinvest them as LP  *\n     * tokens which are donated to all vault users.                         *\n     ************************************************************************/\n\n    /// @notice Ensures that only whitelisted bots can claim reward tokens.\n    function claimRewardTokens() external override onlyRole(REWARD_REINVESTMENT_ROLE) {\n        _claimRewardTokens();\n    }\n\n    /// @notice Ensures that only whitelisted bots can reinvest rewards. Since rewards\n    /// are typically less liquid than pool tokens and lack oracles, reward reinvestment\n    /// is done using explicitly set slippage limits by the reinvestment bots. Reinvestment\n    /// will fail if the spot prices are not close to the oracle prices to ensure that\n    /// there is no front running the reinvestment.\n    function reinvestReward(\n        SingleSidedRewardTradeParams[] calldata trades,\n        uint256 minPoolClaim\n    ) external whenNotLocked onlyRole(REWARD_REINVESTMENT_ROLE) returns (\n        address rewardToken,\n        uint256 amountSold,\n        uint256 poolClaimAmount\n    ) {\n        // Will revert if spot prices are not in line with the oracle values\n        _checkPriceAndCalculateValue();\n\n        // Require one trade per token, if we do not want to buy any tokens at a\n        // given index then the amount should be set to zero. This applies to pool\n        // tokens like in the ComposableStablePool.\n        require(trades.length == NUM_TOKENS());\n        uint256[] memory amounts;\n        (rewardToken, amountSold, amounts) = _executeRewardTrades(trades);\n\n        poolClaimAmount = _joinPoolAndStake(amounts, minPoolClaim);\n\n        // Increase LP token amount without minting additional vault shares\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n        state.totalPoolClaim += poolClaimAmount;\n        state.setStrategyVaultState();\n\n        emit RewardReinvested(rewardToken, amountSold, poolClaimAmount);\n    }\n\n    function _executeRewardTrades(SingleSidedRewardTradeParams[] calldata trades) internal returns (\n        address rewardToken,\n        uint256 amountSold,\n        uint256[] memory amounts\n    ) {\n        // The sell token on all trades must be the same (checked inside executeRewardTrades) so\n        // just validate here that the sellToken is a valid reward token (i.e. none of the tokens\n        // used in the regular functioning of the vault).\n        rewardToken = trades[0].sellToken;\n        if (_isInvalidRewardToken(rewardToken)) revert Errors.InvalidRewardToken(rewardToken);\n        (IERC20[] memory tokens, /* */) = TOKENS();\n        (amounts, amountSold) = StrategyUtils.executeRewardTrades(\n            tokens, trades, rewardToken, address(POOL_TOKEN())\n        );\n    }\n\n    /************************************************************************\n     * EMERGENCY EXIT                                                       *\n     * In case of an emergency, will allow a whitelisted guardian to exit   *\n     * funds on the vault and locks the vault from further usage. The owner *\n     * can restore funds to the LP pool and reinstante vault usage. If the  *\n     * vault cannot be fully restored after an exit, the vault will need to *\n     * be upgraded and unwound manually to ensure that debts are repaid and *\n     * users can withdraw their funds.                                      *\n     ************************************************************************/\n\n    /// @notice Allows the function to execute only when the vault is not locked\n    modifier whenNotLocked() {\n        if (isLocked()) revert Errors.VaultLocked();\n        _;\n    }\n\n    /// @notice Allows the function to execute only when the vault is locked\n    modifier whenLocked() {\n        if (!isLocked()) revert Errors.VaultNotLocked();\n        _;\n    }\n\n    /// @notice Checks if a flag bit is set\n    function _hasFlag(uint32 flags, uint32 flagID) private pure returns (bool) {\n        return (flags & flagID) == flagID;\n    }\n\n    /// @notice Locks the vault, preventing deposits and redemptions. Used during\n    /// emergency exit\n    function _lockVault() internal {\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n        // Set locked flag\n        state.flags = state.flags | FLAG_LOCKED;\n        VaultStorage.setStrategyVaultState(state);\n        emit VaultLocked();\n    }\n\n    /// @notice Unlocks the vault, called during restore vault.\n    function _unlockVault() internal {\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n        // Remove locked flag\n        state.flags = state.flags & ~FLAG_LOCKED;\n        VaultStorage.setStrategyVaultState(state);\n        emit VaultUnlocked();\n    }\n\n    /// @notice Allows the emergency exit role to trigger an emergency exit on the vault.\n    /// In this situation, the `claimToExit` is withdrawn proportionally to the underlying\n    /// tokens and held on the vault. The vault is locked so that no entries, exits or\n    /// valuations of vaultShares can be performed.\n    /// @param claimToExit if this is set to zero, the entire pool claim is withdrawn\n    function emergencyExit(\n        uint256 claimToExit, bytes calldata /* data */\n    ) external override onlyRole(EMERGENCY_EXIT_ROLE) {\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n        if (claimToExit == 0) claimToExit = state.totalPoolClaim;\n\n        // By setting min amounts to zero, we will accept whatever tokens come from the pool\n        // in a proportional exit. Front running will not have an effect since no trading will\n        // occur during a proportional exit.\n        _unstakeAndExitPool(claimToExit, new uint256[](NUM_TOKENS()), true);\n\n        state.totalPoolClaim = state.totalPoolClaim - claimToExit;\n        state.setStrategyVaultState();\n\n        emit EmergencyExit(claimToExit);\n        _lockVault();\n    }\n\n    /// @notice Restores withdrawn tokens from emergencyExit back into the vault proportionally.\n    /// Unlocks the vault after restoration so that normal functionality is restored.\n    /// @param minPoolClaim slippage limit to prevent front running\n    function restoreVault(\n        uint256 minPoolClaim, bytes calldata /* data */\n    ) external override whenLocked onlyNotionalOwner {\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n\n        (IERC20[] memory tokens, /* */) = TOKENS();\n        uint256[] memory amounts = new uint256[](tokens.length);\n\n        // All balances held by the vault are assumed to be used to re-enter\n        // the pool. Since the vault has been locked no other users should have\n        // been able to enter the pool.\n        for (uint256 i; i < tokens.length; i++) {\n            if (address(tokens[i]) == address(POOL_TOKEN())) continue;\n            amounts[i] = TokenUtils.tokenBalance(address(tokens[i]));\n        }\n\n        // No trades are specified so this joins proportionally using the\n        // amounts specified.\n        uint256 poolTokens = _joinPoolAndStake(amounts, minPoolClaim);\n\n        state.totalPoolClaim = state.totalPoolClaim + poolTokens;\n        state.setStrategyVaultState();\n\n        _unlockVault();\n    }\n\n    // Storage gap for future potential upgrades\n    uint256[100] private __gap;\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/common/StrategyUtils.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {IERC20} from \"../../../interfaces/IERC20.sol\";\nimport {\n    TradeParams,\n    DepositTradeParams,\n    RedeemParams,\n    SingleSidedRewardTradeParams\n} from \"../../../interfaces/notional/ISingleSidedLPStrategyVault.sol\";\nimport {TradeHandler} from \"../../trading/TradeHandler.sol\";\nimport {Deployments} from \"../../global/Deployments.sol\";\nimport {Constants} from \"../../global/Constants.sol\";\nimport {Errors} from \"../../global/Errors.sol\";\nimport {ITradingModule, Trade, TradeType, DexId} from \"../../../interfaces/trading/ITradingModule.sol\";\n\n/**\n * @notice External library deployed for the purposes of handling SingleSidedLP trades. All\n * the methods in this library are called inside a `delegateCall` context which ensures that\n * the library has access to the calling vault's token balances\n */\nlibrary StrategyUtils {\n    using TradeHandler for Trade;\n\n    /// @notice Trades the amount of primary token into other secondary tokens prior\n    /// to entering a pool.\n    function executeDepositTrades(\n        IERC20[] memory tokens,\n        uint256[] memory amounts,\n        DepositTradeParams[] memory depositTrades,\n        uint256 primaryIndex\n    ) external returns (uint256[] memory) {\n        address primaryToken = address(tokens[primaryIndex]);\n\n        for (uint256 i; i < amounts.length; i++) {\n            if (i == primaryIndex) continue;\n            DepositTradeParams memory t = depositTrades[i];\n            // Do not allow ZERO_EX trading in this method since we cannot validate\n            // the arbitrary exchange data.\n            if (DexId(t.tradeParams.dexId) == DexId.ZERO_EX) revert Errors.InvalidDexId(uint256(DexId.ZERO_EX));\n\n            if (t.tradeAmount > 0) {\n                // Always selling the primaryToken and buying the secondary token.\n                (uint256 amountSold, uint256 amountBought) = _executeDynamicSlippageTradeExactIn(\n                    Deployments.TRADING_MODULE, t.tradeParams, primaryToken, address(tokens[i]), t.tradeAmount\n                );\n\n                amounts[i] = amountBought;\n                // Will revert on underflow if over-selling the primary borrowed\n                amounts[primaryIndex] -= amountSold;\n            }\n        }\n\n        return amounts;\n    }\n\n    /// @notice Trades the amount of secondary tokens into the primary token after\n    /// exiting a pool.\n    function executeRedemptionTrades(\n        IERC20[] memory tokens,\n        uint256[] memory exitBalances,\n        TradeParams[] memory redemptionTrades,\n        uint256 primaryIndex\n    ) external returns (uint256 finalPrimaryBalance) {\n        address primaryToken = address(tokens[primaryIndex]);\n\n        for (uint256 i; i < exitBalances.length; i++) {\n            if (i == primaryIndex) {\n                finalPrimaryBalance += exitBalances[i];\n                continue;\n            }\n\n            TradeParams memory t = redemptionTrades[i];\n            // Do not allow ZERO_EX trading in this method since we cannot validate\n            // the arbitrary exchange data.\n            if (DexId(t.dexId) == DexId.ZERO_EX) revert Errors.InvalidDexId(uint256(DexId.ZERO_EX));\n\n            // Always sell the entire exit balance to the primary token\n            if (exitBalances[i] > 0) {\n                (/* */, uint256 amountBought) = _executeDynamicSlippageTradeExactIn(\n                    Deployments.TRADING_MODULE, t, address(tokens[i]), primaryToken, exitBalances[i]\n                );\n\n                finalPrimaryBalance += amountBought;\n            }\n        }\n    }\n\n    /// @notice Executes a set of trades to sell the reward token for constituent pool tokens.\n    function executeRewardTrades(\n        IERC20[] memory tokens,\n        SingleSidedRewardTradeParams[] calldata trades,\n        address rewardToken,\n        address poolToken\n    ) external returns(uint256[] memory amounts, uint256 amountSold) {\n        amounts = new uint256[](trades.length);\n        for (uint256 i; i < trades.length; i++) {\n            // All trades must sell the same token.\n            require(trades[i].sellToken == rewardToken);\n            // Bypass certain invalid trades\n            if (trades[i].amount == 0) continue;\n            if (trades[i].buyToken == poolToken) continue;\n\n            // The reward trade can only purchase tokens that go into the pool\n            require(trades[i].buyToken == address(tokens[i]));\n\n            // It may be possible that the entire balance of reward tokens is not sold by the vault,\n            // but that is ok.\n            (uint256 sold, uint256 bought) = _executeTradeWithStaticSlippage(\n                Deployments.TRADING_MODULE, trades[i].tradeParams, rewardToken, trades[i].buyToken, trades[i].amount\n            );\n            amounts[i] = bought;\n            amountSold += sold;\n        }\n    }\n\n    /// @notice Executes a trade that uses a d"
    }
  ]
}