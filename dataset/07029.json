{
  "Title": "[M-02] Multiple accounts can have the same identity",
  "Content": "\n[AddressRegistry.sol#L47](https://github.com/code-423n4/2023-01-canto-identity/blob/dff8e74c54471f5f3b84c217848234d474477d82/src/AddressRegistry.sol#L47)\n\nUsers can register their on-chain identity (ie their CID NFT) by calling `AddressRegistry.register()`\n\n```solidity\nFile: src/AddressRegistry.sol\n42:     function register(uint256 _cidNFTID) external {\n43:         if (ERC721(cidNFT).ownerOf(_cidNFTID) != msg.sender)\n44:             // We only guarantee that a CID NFT is owned by the user at the time of registration\n45:             // ownerOf reverts if non-existing ID is provided\n46:             revert NFTNotOwnedByUser(_cidNFTID, msg.sender);\n47:         cidNFTs[msg.sender] = _cidNFTID;\n48:         emit CIDNFTAdded(msg.sender, _cidNFTID);\n49:     }\n```\n\nThis overwrites `cidNFTs[msg.sender]` with the `cidNFTID` provided by the caller.\n\nThe issue is that there is nothing preventing several (2 or more) accounts to point to the same `cidNFTID`, ie have `cidNFTs[userA] == cidNFTs[userB]`\n\nNote: the README mentioned that\n\n    Transferring CID NFTs that are still referenced in the address registry: CID NFTs are transferrable on purpose and a user can transfer his CID NFT while it is still registered to his address if he wants to do so.\n\nThe issue described in this report is not that the CID NFT is transferrable, but that several accounts can point to the same CIDNFT id, which lead to several problems outlined below.\n\n### Impact\n\nQuoting the README:\n\n    Canto Identity NFTs (CID NFTs) represent individual on-chain identities\n\nHere, several accounts can point to the same on-chain identity, breaking the requirement that the said identity should be **individual**.\n\nTo illustrate the consequences of this, let us look at `CidNFT.add()`, which adds a new entry for the given subprotocol to the provided CID NFT:\n\n*   data is added by transferring a subprotocol NFT to the contract, which will write the NFT id in `cidData[_cidNFTID][_subprotocolName]`\n*   This NFT id represents traits that will be associated with the identity.\n\nBecause of the issue outlined above, the identity system can be abused:\n\n*   Alice registers her CIDNft by calling `addressRegistry.register(N)`\n*   she transfers it to Bob, who then proceeds to call `addressRegistry.register(N)` to register it.\n*   at this point, `cidNFT` of id `N` points to both Alice and Bob: `addressRegistry.getCID(Alice) == addressRegistry.getCID(Bob)`\n*   Bob calls `CidNFT.add()` to add a subProtocol NFT X to his identity `N` . Because Alice is also associated to the `CIDNFT` `N`, she essentially added this trait for free (assuming subprotocols will monetize their tokens, Bob had to pay the cost of the subProtocol NFT X, but Alice did not).\n*   This can also have further consequences depending on what can be done with these traits (e.g: a protocol giving rewards for users with a trait of the subProtocol NFT X, Bob could be front run by Alice and not receive a reward he was entitled to)\n\nOverall, because this issue impacts a key aspect of the protocol (identities are not individual) and can lead to a form of `theft` in certain conditions (in the scenario above, Alice got a trait added to her identity for \"free\"), the Medium severity seems appropriate.\n\n### Proof Of Concept\n\nThis test shows how two users can point to the same `CID`.<br>\nAdd it to `AddressRegistry.t.sol`\n\n```solidity\nfunction testTwoUsersSameCID() public {\n    uint256 nftIdOne = 1;\n    address Alice = users[0];\n    address Bob = users[1];\n\n    // 1 - Alice mints NFT\n    vm.startPrank(Alice);\n    bytes[] memory addList;\n    cidNFT.mint(addList);\n    assertEq(cidNFT.ownerOf(nftIdOne), Alice);\n\n    // 2 - Alice registers the NFT\n    addressRegistry.register(nftIdOne);\n\n    // 3 - Alice transfers the CID NFT to Bob\n    cidNFT.transferFrom(Alice, Bob, nftIdOne);\n    vm.stopPrank();\n\n    // 4 - Bob registers the nft\n    vm.startPrank(Bob);\n    addressRegistry.register(nftIdOne);\n\n    // 5 - Alice and Bob have the same identity\n    uint256 cidAlice = addressRegistry.getCID(Alice);\n    uint256 cidBob = addressRegistry.getCID(Bob);\n    assertEq(cidAlice, cidBob);\n}\n```\n\n### Tools Used\n\nManual Analysis, Foundry\n\n### Mitigation\n\n`AddressRegistry` should have an additional mapping to track the account associated with a given `cifNTFID`.\n\n```diff\nFile: src/AddressRegistry.sol\n20:     /// @notice Stores the mappings of users to their CID NFT\n21:     mapping(address => uint256) private cidNFTs;\n+       mapping(uint256 => address) private accounts;\n```\n\nWhen registering, the code would check if the `cidNFTID` has an account associated with it.\nIf that is the case, `cidNFTs` for this user would be set to 0, preventing several users from having the same identity.\n\n```diff\nFile: src/AddressRegistry.sol\n42: function register(uint256 _cidNFTID) external {\n43:         if (ERC721(cidNFT).ownerOf(_cidNFTID) != msg.sender)\n44:             // We only guarantee that a CID NFT is owned by the user at the time of registration\n45:             // ownerOf reverts if non-existing ID is provided\n46:             revert NFTNotOwnedByUser(_cidNFTID, msg.sender);\n+           if (accounts[_cidNFTID] != address(0)) {\n+                 delete cidNFTs[accounts[_cidNFTID]];\n+                 emit CIDNFTRemoved(accounts[_cidNFTID], _cidNFTID);\n+}\n47:         cidNFTs[msg.sender] = _cidNFTID;\n+           accounts[_cidNFTID] = msg.sender;\n48:         emit CIDNFTAdded(msg.sender, _cidNFTID);\n49:     }\n```\n\n**[OpenCoreCH (Canto Identity) confirmed and commented](https://github.com/code-423n4/2023-01-canto-identity-findings/issues/177#issuecomment-1431920998):**\n > I first thought that this is intended behaviour because the same identity/person can have multiple wallets. But after seeing the examples in the findings and discussing this internally, it will be changed such that registrations are removed on transfer.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-01-canto-identity-protocol-contest",
  "Code": [
    {
      "filename": "src/AddressRegistry.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\nimport \"solmate/tokens/ERC721.sol\";\n\n/// @title Address Registry\n/// @notice Allows users to register their CID NFT\ncontract AddressRegistry {\n    /*//////////////////////////////////////////////////////////////\n                                 ADDRESSES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Address of the CID NFT\n    address public immutable cidNFT;\n\n    /*//////////////////////////////////////////////////////////////\n                                 STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Stores the mappings of users to their CID NFT\n    mapping(address => uint256) private cidNFTs;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    event CIDNFTAdded(address indexed user, uint256 indexed cidNFTID);\n    event CIDNFTRemoved(address indexed user, uint256 indexed cidNFTID);\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error NFTNotOwnedByUser(uint256 cidNFTID, address caller);\n    error NoCIDNFTRegisteredForUser(address caller);\n\n    /// @param _cidNFT Address of the CID NFT contract\n    constructor(address _cidNFT) {\n        cidNFT = _cidNFT;\n    }\n\n    /// @notice Register a CID NFT to the address of the caller. NFT has to be owned by the caller\n    /// @dev Will overwrite existing registration if any exists\n    function register(uint256 _cidNFTID) external {\n        if (ERC721(cidNFT).ownerOf(_cidNFTID) != msg.sender)\n            // We only guarantee that a CID NFT is owned by the user at the time of registration\n            // ownerOf reverts if non-existing ID is provided\n            revert NFTNotOwnedByUser(_cidNFTID, msg.sender);\n        cidNFTs[msg.sender] = _cidNFTID;\n        emit CIDNFTAdded(msg.sender, _cidNFTID);\n    }\n\n    /// @notice Remove the current registration of the caller\n    function remove() external {\n        uint256 cidNFTID = cidNFTs[msg.sender];\n        if (cidNFTID == 0) revert NoCIDNFTRegisteredForUser(msg.sender);\n        delete cidNFTs[msg.sender];\n        emit CIDNFTRemoved(msg.sender, cidNFTID);\n    }\n\n    /// @notice Get the CID NFT ID that is registered for the provided user\n    /// @param _user Address to query\n    /// @return cidNFTID The registered CID NFT ID. 0 when no CID NFT is registered for the given address\n    function getCID(address _user) external view returns (uint256 cidNFTID) {\n        cidNFTID = cidNFTs[_user];\n    }\n}"
    }
  ]
}