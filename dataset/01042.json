{
  "Title": "Unnecessary approve",
  "Content": "##### Description\nThe current implementation of the Factory grants approves tokens to newly created pools, which is unnecessary:\nhttps://github.com/curvefi/stableswap-ng/blob/8c78731ed43c22e6bcdcb5d39b0a7d02f8cb0386/contracts/main/CurveStableSwapFactoryNG.vy#L550-L557\nhttps://github.com/curvefi/stableswap-ng/blob/8c78731ed43c22e6bcdcb5d39b0a7d02f8cb0386/contracts/main/CurveStableSwapFactoryNG.vy#L661.\n\n##### Recommendation\nWe recommend removing approves granting from the Factory to newly created pools.\n\n\n***\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/main/CurveStableSwapFactoryNG.vy",
      "content": "# @version 0.3.9\n\"\"\"\n@title CurveStableswapFactoryNG\n@author Curve.Fi\n@license Copyright (c) Curve.Fi, 2023 - all rights reserved\n@notice Permissionless pool deployer and registry\n\"\"\"\n\nstruct PoolArray:\n    base_pool: address\n    implementation: address\n    liquidity_gauge: address\n    coins: DynArray[address, MAX_COINS]\n    decimals: DynArray[uint256, MAX_COINS]\n    n_coins: uint256\n    asset_types: DynArray[uint8, MAX_COINS]\n\nstruct BasePoolArray:\n    lp_token: address\n    coins: DynArray[address, MAX_COINS]\n    decimals: uint256\n    n_coins: uint256\n    asset_types: DynArray[uint8, MAX_COINS]\n\n\ninterface AddressProvider:\n    def admin() -> address: view\n\ninterface ERC20:\n    def balanceOf(_addr: address) -> uint256: view\n    def decimals() -> uint256: view\n    def totalSupply() -> uint256: view\n    def approve(_spender: address, _amount: uint256): nonpayable\n\ninterface CurvePool:\n    def A() -> uint256: view\n    def fee() -> uint256: view\n    def admin_fee() -> uint256: view\n    def balances(i: uint256) -> uint256: view\n    def admin_balances(i: uint256) -> uint256: view\n    def get_virtual_price() -> uint256: view\n    def exchange(\n        i: int128,\n        j: int128,\n        dx: uint256,\n        min_dy: uint256,\n        _receiver: address,\n    ) -> uint256: nonpayable\n\ninterface CurveFactoryMetapool:\n    def coins(i :uint256) -> address: view\n    def decimals() -> uint256: view\n\n\nevent BasePoolAdded:\n    base_pool: address\n\nevent PlainPoolDeployed:\n    coins: DynArray[address, MAX_COINS]\n    A: uint256\n    fee: uint256\n    deployer: address\n\nevent MetaPoolDeployed:\n    coin: address\n    base_pool: address\n    A: uint256\n    fee: uint256\n    deployer: address\n\nevent LiquidityGaugeDeployed:\n    pool: address\n    gauge: address\n\nMAX_COINS: constant(uint256) = 8\nADDRESS_PROVIDER: constant(address) = 0x0000000022D53366457F9d5E68Ec105046FC4383\n\nMAX_FEE: constant(uint256) = 5 * 10 ** 9\nFEE_DENOMINATOR: constant(uint256) = 10 ** 10\n\nadmin: public(address)\nfuture_admin: public(address)\n\npool_list: public(address[4294967296])   # master list of pools\npool_count: public(uint256)              # actual length of pool_list\npool_data: HashMap[address, PoolArray]\n\nbase_pool_list: public(address[4294967296])   # master list of pools\nbase_pool_count: public(uint256)         # actual length of pool_list\nbase_pool_data: public(HashMap[address, BasePoolArray])\n\n# asset -> is used in a metapool?\nbase_pool_assets: public(HashMap[address, bool])\n\n# index -> implementation address\npool_implementations: public(HashMap[uint256, address])\nmetapool_implementations: public(HashMap[uint256, address])\nmath_implementation: public(address)\ngauge_implementation: public(address)\nviews_implementation: public(address)\n\n# fee receiver for all pools\nfee_receiver: public(address)\n\n# mapping of coins -> pools for trading\n# a mapping key is generated for each pair of addresses via\n# `bitwise_xor(convert(a, uint256), convert(b, uint256))`\nmarkets: HashMap[uint256, address[4294967296]]\nmarket_counts: HashMap[uint256, uint256]\n\n\n@external\ndef __init__(_fee_receiver: address, _owner: address):\n\n    self.fee_receiver = _fee_receiver\n    self.admin = _owner\n\n# <--- Factory Getters --->\n\n\n@view\n@external\ndef find_pool_for_coins(_from: address, _to: address, i: uint256 = 0) -> address:\n    \"\"\"\n    @notice Find an available pool for exchanging two coins\n    @param _from Address of coin to be sent\n    @param _to Address of coin to be received\n    @param i Index value. When multiple pools are available\n            this value is used to return the n'th address.\n    @return Pool address\n    \"\"\"\n    key: uint256 = (convert(_from, uint256) ^ convert(_to, uint256))\n    return self.markets[key][i]\n\n\n# <--- Pool Getters --->\n\n@view\n@external\ndef get_base_pool(_pool: address) -> address:\n    \"\"\"\n    @notice Get the base pool for a given factory metapool\n    @param _pool Metapool address\n    @return Address of base pool\n    \"\"\"\n    return self.pool_data[_pool].base_pool\n\n\n@view\n@external\ndef get_n_coins(_pool: address) -> (uint256):\n    \"\"\"\n    @notice Get the number of coins in a pool\n    @param _pool Pool address\n    @return Number of coins\n    \"\"\"\n    return self.pool_data[_pool].n_coins\n\n\n@view\n@external\ndef get_meta_n_coins(_pool: address) -> (uint256, uint256):\n    \"\"\"\n    @notice Get the number of coins in a metapool\n    @param _pool Pool address\n    @return Number of wrapped coins, number of underlying coins\n    \"\"\"\n    base_pool: address = self.pool_data[_pool].base_pool\n    return 2, self.base_pool_data[base_pool].n_coins + 1\n\n\n@view\n@external\ndef get_coins(_pool: address) -> DynArray[address, MAX_COINS]:\n    \"\"\"\n    @notice Get the coins within a pool\n    @param _pool Pool address\n    @return List of coin addresses\n    \"\"\"\n    return self.pool_data[_pool].coins\n\n\n@view\n@external\ndef get_underlying_coins(_pool: address) -> DynArray[address, MAX_COINS]:\n    \"\"\"\n    @notice Get the underlying coins within a pool\n    @dev Reverts if a pool does not exist or is not a metapool\n    @param _pool Pool address\n    @return List of coin addresses\n    \"\"\"\n    coins: DynArray[address, MAX_COINS] = empty(DynArray[address, MAX_COINS])\n    base_pool: address = self.pool_data[_pool].base_pool\n    assert base_pool != empty(address)  # dev: pool is not metapool\n\n    coins.append(self.pool_data[_pool].coins[0])\n    base_pool_n_coins: uint256 = len(self.base_pool_data[base_pool].coins)\n    for i in range(1, MAX_COINS):\n        if i - 1 == base_pool_n_coins:\n            break\n\n        coins.append(self.base_pool_data[base_pool].coins[i - 1])\n\n    return coins\n\n\n@view\n@external\ndef get_decimals(_pool: address) -> DynArray[uint256, MAX_COINS]:\n    \"\"\"\n    @notice Get decimal places for each coin within a pool\n    @param _pool Pool address\n    @return uint256 list of decimals\n    \"\"\"\n    return self.pool_data[_pool].decimals\n\n\n@view\n@external\ndef get_underlying_decimals(_pool: address) -> DynArray[uint256, MAX_COINS]:\n    \"\"\"\n    @notice Get decimal places for each underlying coin within a pool\n    @param _pool Pool address\n    @return uint256 list of decimals\n    \"\"\"\n    # decimals are tightly packed as a series of uint8 within a little-endian bytes32\n    # the packed value is stored as uint256 to simplify unpacking via shift and modulo\n    pool_decimals: DynArray[uint256, MAX_COINS] = empty(DynArray[uint256, MAX_COINS])\n    pool_decimals = self.pool_data[_pool].decimals\n    decimals: DynArray[uint256, MAX_COINS] = empty(DynArray[uint256, MAX_COINS])\n    decimals.append(pool_decimals[0])\n    base_pool: address = self.pool_data[_pool].base_pool\n    packed_decimals: uint256 = self.base_pool_data[base_pool].decimals\n\n    for i in range(MAX_COINS):\n        unpacked: uint256 = (packed_decimals >> 8 * i) % 256\n        if unpacked == 0:\n            break\n\n        decimals.append(unpacked)\n\n    return decimals\n\n\n@view\n@external\ndef get_metapool_rates(_pool: address) -> DynArray[uint256, MAX_COINS]:\n    \"\"\"\n    @notice Get rates for coins within a metapool\n    @param _pool Pool address\n    @return Rates for each coin, precision normalized to 10**18\n    \"\"\"\n    rates: DynArray[uint256, MAX_COINS] = [10**18, 0]\n    rates[1] = CurvePool(self.pool_data[_pool].base_pool).get_virtual_price()\n    return rates\n\n\n@view\n@external\ndef get_balances(_pool: address) -> DynArray[uint256, MAX_COINS]:\n    \"\"\"\n    @notice Get balances for each coin within a pool\n    @dev For pools using lending, these are the wrapped coin balances\n    @param _pool Pool address\n    @return uint256 list of balances\n    \"\"\"\n    balances: DynArray[uint256, MAX_COINS] = empty(DynArray[uint256, MAX_COINS])\n\n    if self.pool_data[_pool].base_pool != empty(address):\n        balances.append(CurvePool(_pool).balances(0))\n        balances.append(CurvePool(_pool).balances(1))\n        return balances\n\n    n_coins: uint256 = self.pool_data[_pool].n_coins\n    for i in range(MAX_COINS):\n\n        if i == n_coins:\n            break\n\n        balances.append(CurvePool(_pool).balances(i))\n\n\n    return balances\n\n\n@view\n@external\ndef get_underlying_balances(_pool: address) -> DynArray[uint256, MAX_COINS]:\n    \"\"\"\n    @notice Get balances for each underlying coin within a metapool\n    @param _pool Metapool address\n    @return uint256 list of underlying balances\n    \"\"\"\n\n    base_pool: address = self.pool_data[_pool].base_pool\n    assert base_pool != empty(address)  # dev: pool is not a metapool\n\n    underlying_balances: DynArray[uint256, MAX_COINS] = empty(DynArray[uint256, MAX_COINS])\n    underlying_balances[0] = CurvePool(_pool).balances(0)\n\n    base_total_supply: uint256 = ERC20(self.pool_data[_pool].coins[1]).totalSupply()\n    if base_total_supply > 0:\n        underlying_pct: uint256 = CurvePool(_pool).balances(1) * 10**36 / base_total_supply\n        n_coins: uint256 = self.base_pool_data[base_pool].n_coins\n        for i in range(MAX_COINS):\n            if i == n_coins:\n                break\n            underlying_balances[i + 1] = CurvePool(base_pool).balances(i) * underlying_pct / 10**36\n\n    return underlying_balances\n\n\n@view\n@external\ndef get_A(_pool: address) -> uint256:\n    \"\"\"\n    @notice Get the amplfication co-efficient for a pool\n    @param _pool Pool address\n    @return uint256 A\n    \"\"\"\n    return CurvePool(_pool).A()\n\n\n@view\n@external\ndef get_fees(_pool: address) -> (uint256, uint256):\n    \"\"\"\n    @notice Get the fees for a pool\n    @dev Fees are expressed as integers\n    @return Pool fee and admin fee as uint256 with 1e10 precision\n    \"\"\"\n    return CurvePool(_pool).fee(), CurvePool(_pool).admin_fee()\n\n\n@view\n@external\ndef get_admin_balances(_pool: address) -> DynArray[uint256, MAX_COINS]:\n    \"\"\"\n    @notice Get the current admin balances (uncollected fees) for a pool\n    @param _pool Pool address\n    @return List of uint256 admin balances\n    \"\"\"\n    n_coins: uint256 = self.pool_data[_pool].n_coins\n    admin_balances: DynArray[uint256, MAX_COINS] = empty(DynArray[uint256, MAX_COINS])\n    for i in range(MAX_COINS):\n        if i == n_coins:\n            break\n        admin_balances.append(CurvePool(_pool).admin_balances(i))\n    return admin_balances\n\n\n@view\n@external\ndef get_coin_indices(\n    _pool: address,\n    _from: address,\n    _to: address\n) -> (int128, int128, bool):\n    \"\"\"\n    @notice Convert coin addresses to indices for use with pool methods\n    @param _pool Pool address\n    @param _from Coin address to be used as `i` within a pool\n    @param _to Coin address to be used as `j` within a pool\n    @return int128 `i`, int128 `j`, boolean indicating if `i` and `j` are underlying coins\n    \"\"\"\n    coin: address = self.pool_data[_pool].coins[0]\n    base_pool: address = self.pool_data[_pool].base_pool\n    if coin in [_from, _to] and base_pool != empty(address):\n        base_lp_token: address = self.pool_data[_pool].coins[1]\n        if base_lp_token in [_from, _to]:\n            # True and False convert to 1 and 0 - a bit of voodoo that\n            # works because we only ever have 2 non-underlying coins if base pool is empty(address)\n            return convert(_to == coin, int128), convert(_from == coin, int128), False\n\n    found_market: bool = False\n    i: uint256 = 0\n    j: uint256 = 0\n    for x in range(MAX_COINS):\n        if base_pool == empty(address):\n            if x >= MAX_COINS:\n                raise \"No available market\"\n            if x != 0:\n                coin = self.pool_data[_pool].coins[x]\n        else:\n            if x != 0:\n                coin = self.base_pool_data[base_pool].coins[x-1]\n        if coin == empty(address):\n            raise \"No available market\"\n        if coin == _from:\n            i = x\n        elif coin == _to:\n            j = x\n        else:\n            continue\n        if found_market:\n            # the second time we find a match, break out of the loop\n            break\n        # the first time we find a match, set `found_market` to True\n        found_market = True\n\n    return convert(i, int128), convert(j, int128), True\n\n\n@view\n@external\ndef get_gauge(_pool: address) -> address:\n    \"\"\"\n    @notice Get the address of the liquidity gauge contract for a factory pool\n    @dev Returns `empty(address)` if a gauge has not been deployed\n    @param _pool Pool address\n    @return Implementation contract address\n    \"\"\"\n    return self.pool_data[_pool].liquidity_gauge\n\n\n@view\n@external\ndef get_implementation_address(_pool: address) -> address:\n    \"\"\"\n    @notice Get the address of the implementation contract used for a factory pool\n    @param _pool Pool address\n    @return Implementation contract address\n    \"\"\"\n    return self.pool_data[_pool].implementation\n\n\n@view\n@external\ndef is_meta(_pool: address) -> bool:\n    \"\"\"\n    @notice Verify `_pool` is a metapool\n    @param _pool Pool address\n    @return True if `_pool` is a metapool\n    \"\"\"\n    return self.pool_data[_pool].base_pool != empty(address)\n\n\n@view\n@external\ndef get_pool_asset_types(_pool: address) -> DynArray[uint8, MAX_COINS]:\n    \"\"\"\n    @notice Query the asset type of `_pool`\n    @param _pool Pool Address\n    @return Integer indicating the pool asset type\n    \"\"\"\n    return self.pool_data[_pool].asset_types\n\n\n# <--- Pool Deployers --->\n\n@external\ndef deploy_plain_pool(\n    _name: String[32],\n    _symbol: String[10],\n    _coins: DynArray[address, MAX_COINS],\n    _A: uint256,\n    _fee: uint256,\n    _offpeg_fee_multiplier: uint256,\n    _ma_exp_time: uint256,\n    _implementation_idx: uint256,\n    _asset_types: DynArray[uint8, MAX_COINS],\n    _method_ids: DynArray[bytes4, MAX_COINS],\n    _oracles: DynArray[address, MAX_COINS],\n) -> address:\n    \"\"\"\n    @notice Deploy a new plain pool\n    @param _name Name of the new plain pool\n    @param _symbol Symbol for the new plain pool - will be\n                   concatenated with factory symbol\n    @param _coins List of addresses of the coins being used in the pool.\n    @param _A Amplification co-efficient - a lower value here means\n              less tolerance for imbalance within the pool's assets.\n              Suggested values include:\n               * Uncollateralized algorithmic stablecoins: 5-10\n               * Non-redeemable, collateralized assets: 100\n               * Redeemable assets: 200-400\n    @param _fee Trade fee, given as an integer with 1e10 precision. The\n                the maximum is 1% (100000000).\n                50% of the fee is distributed to veCRV holders.\n    @param _ma_exp_time Averaging window of oracle. Set as time_in_seconds / ln(2)\n                        Example: for 10 minute EMA, _ma_exp_time is 600 / ln(2) ~= 866\n    @param _implementation_idx Index of the implementation to use\n    @param _asset_types Asset types for pool, as an integer\n    @param _method_ids Array of first four bytes of the Keccak-256 hash of the function signatures\n                       of the oracle addresses that gives rate oracles.\n                       Calculated as: keccak(text=event_signature.replace(\" \", \"\"))[:4]\n    @param _oracles Array of rate oracle addresses.\n    @return Address of the deployed pool\n    \"\"\"\n    assert len(_coins) == len(_method_ids), \"All coin arrays should be same length\"\n    assert len(_coins) ==  len(_oracles), \"All coin arrays should be same length\"\n    assert len(_coins) ==  len(_asset_types), \"All coin arrays should be same length\"\n    assert _fee <= 100000000, \"Invalid fee\"\n    assert _offpeg_fee_multiplier * _fee <= MAX_FEE * FEE_DENOMINATOR\n\n    n_coins: uint256 = len(_coins)\n    _rate_multipliers: DynArray[uint256, MAX_COINS] = empty(DynArray[uint256, MAX_COINS])\n    decimals: DynArray[uint256, MAX_COINS] = empty(DynArray[uint256, MAX_COINS])\n\n    for i in range(MAX_COINS):\n        if i == n_coins:\n            break\n\n        coin: address = _coins[i]\n\n        decimals.append(ERC20(coin).decimals())\n        assert decimals[i] < 19, \"Max 18 decimals for coins\"\n\n        _rate_multipliers.append(10 ** (36 - decimals[i]))\n\n        for j in range(i, i + MAX_COINS):\n            if (j + 1) == n_coins:\n                break\n            assert coin != _coins[j+1], \"Duplicate coins\"\n\n    implementation: address = self.pool_implementations[_implementation_idx]\n    assert implementation != empty(address), \"Invalid implementation index\"\n\n    pool: address = create_from_blueprint(\n        implementation,\n        _name,                                          # _name: String[32]\n        _symbol,                                        # _symbol: String[10]\n        _A,                                             # _A: uint256\n        _fee,                                           # _fee: uint256\n        _offpeg_fee_multiplier,                         # _offpeg_fee_multiplier: uint256\n        _ma_exp_time,                                   # _ma_exp_time: uint256\n        _coins,                                         # _coins: DynArray[address, MAX_COINS]\n        _rate_multipliers,                              # _rate_multipliers: DynArray[uint256, MAX_COINS]\n        _asset_types,                                   # _asset_types: DynArray[uint8, MAX_COINS]\n        _method_ids,                                    # _method_ids: DynArray[bytes4, MAX_COINS]\n        _oracles,                                       # _oracles: DynArray[address, MAX_COINS]\n        code_offset=3\n    )\n\n    length: uint256 = self.pool_count\n    self.pool_list[length] = pool\n    self.pool_count = length + 1\n    self.pool_data[pool].decimals = decimals\n    self.pool_data[pool].n_coins = n_coins\n    self.pool_data[pool].base_pool = empty(address)\n    self.pool_data[pool].implementation = implementation\n    self.pool_data[pool].asset_types = _asset_types\n\n    for i in range(MAX_COINS):\n        if i == n_coins:\n            break\n\n        coin: address = _coins[i]\n        self.pool_data[pool].coins.append(coin)\n        raw_call(\n            coin,\n            concat(\n                method_id(\"approve(address,uint256)\"),\n                convert(pool, bytes32),\n                convert(max_value(uint256), bytes32)\n            )\n        )\n        for j in range(i, i + MAX_COINS):\n            if (j + 1) == n_coins:\n                break\n            swappable_coin: address = _coins[j + 1]\n            key: uint256 = (convert(coin, uint256) ^ convert(swappable_coin, uint256))\n            length = self.market_counts[key]\n            self.markets[key][length] = pool\n            self.market_counts[key] = length + 1\n\n    log PlainPoolDeployed(_coins, _A, _fee, msg.sender)\n    return pool\n\n\n@external\ndef deploy_metapool(\n    _base_pool: address,\n    _name: String[32],\n    _symbol: String[10],\n    _coin: address,\n    _A: uint256,\n    _fee: uint256,\n    _offpeg_fee_multiplier: uint256,\n    _ma_exp_time: uint256,\n    _implementation_idx: uint256,\n    _asset_type: uint8,\n    _method_id: bytes4,\n    _oracle: address,\n) -> address:\n    \"\"\"\n    @notice Deploy a new metapool\n    @param _base_pool Address of the base pool to use\n                      within the metapool\n    @param _name Name of the new metapool\n    @param _symbol Symbol for the new metapool - will be\n                   concatenated with the base pool symbol\n    @param _coin Address of the coin being used in the metapool\n    @param _A Amplification co-efficient - a higher value here means\n              less tolerance for imbalance within the pool's assets.\n              Suggested values include:\n               * Uncollateralized algorithmic stablecoins: 5-10\n               * Non-redeemable, collateralized assets: 100\n               * Redeemable assets: 200-400\n    @param _fee Trade fee, given as an integer with 1e10 precision. The\n                the maximum is 1% (100000000).\n                50% of the fee is distributed to veCRV holders.\n    @param _ma_exp_time Averaging window of oracle. Set as time_in_seconds / ln(2)\n                        Example: for 10 minute EMA, _ma_exp_time is 600 / ln(2) ~= 866\n    @param _implementation_idx Index of the implementation to use\n    @param _asset_type Asset type for token, as an integer\n    @param _method_id  First four bytes of the Keccak-256 hash of the function signatures\n                       of the oracle addresses that gives rate oracles.\n                       Calculated as: keccak(text=event_signature.replace(\" \", \"\"))[:4]\n    @param _oracle Rate oracle address.\n    @return Address of the deployed pool\n    \"\"\"\n    assert not self.base_pool_assets[_coin], \"Invalid asset: Cannot pair base pool asset with base pool's LP token\"\n    assert _fee <= 100000000, \"Invalid fee\"\n    assert _offpeg_fee_multiplier * _fee <= MAX_FEE * FEE_DENOMINATOR\n\n\n    base_pool_n_coins: uint256 = len(self.base_pool_data[_base_pool].coins)\n    assert base_pool_n_coins != 0, \"Base pool is not added\"\n\n    implementation: address = self.metapool_implementations[_implementation_idx]\n    assert implementation != empty(address), \"Invalid implementation index\"\n\n    # things break if a token has >18 decimals\n    decimals: uint256 = ERC20(_coin).decimals()\n    assert decimals < 19, \"Max 18 decimals for coins\"\n\n    # combine _coins's _asset_type and basepool coins _asset_types:\n    base_pool_asset_types: DynArray[uint8, MAX_COINS] = self.base_pool_data[_base_pool].asset_types\n    asset_types: DynArray[uint8, MAX_COINS]  = [_asset_type, 0]\n\n    for i in range(0, MAX_COINS):\n        if i == base_pool_n_coins:\n            break\n        asset_types.append(base_pool_asset_types[i])\n\n    _coins: DynArray[address, MAX_COINS] = [_coin, self.base_pool_data[_base_pool].lp_token]\n    _rate_multipliers: DynArray[uint256, MAX_COINS] = [10 ** (36 - decimals), 10 ** 18]\n    _method_ids: DynArray[bytes4, MAX_COINS] = [_method_id, empty(bytes4)]\n    _oracles: DynArray[address, MAX_COINS] = [_oracle, empty(address)]\n\n    pool: address = create_from_blueprint(\n        implementation,\n        _name,                                          # _name: String[32]\n        _symbol,                                        # _symbol: String[10]\n        _A,                                             # _A: uint256\n        _fee,                                           # _fee: uint256\n        _offpeg_fee_multiplier,                         # _offpeg_fee_multiplier: uint256\n        _ma_exp_time,                                   # _ma_exp_time: uint256\n        self.math_implementation,                       # _math_implementation: address\n        _base_pool,                                     # _base_pool: address\n        _coins,                                         # _coins: DynArray[address, MAX_COINS]\n        self.base_pool_data[_base_pool].coins,          # base_coins: DynArray[address, MAX_COINS]\n        _rate_multipliers,                              # _rate_multipliers: DynArray[uint256, MAX_COINS]\n        asset_types,                                    # asset_types: DynArray[uint8, MAX_COINS]\n        _method_ids,                                    # _method_ids: DynArray[bytes4, MAX_COINS]\n        _oracles,                                       # _oracles: DynArray[address, MAX_COINS]\n        code_offset=3\n    )\n\n    ERC20(_coin).approve(pool, max_value(uint256))\n\n    # add pool to pool_list\n    length: uint256 = self.pool_count\n    self.pool_list[length] = pool\n    self.pool_count = length + 1\n\n    base_lp_token: address = self.base_pool_data[_base_pool].lp_token\n\n    self.pool_data[pool].decimals = [decimals, 18, 0, 0, 0, 0, 0, 0]\n    self.pool_data[pool].n_coins = 2\n    self.pool_data[pool].base_pool = _base_pool\n    self.pool_data[pool].coins = [_coin, self.base_pool_data[_base_pool].lp_token]\n    self.pool_data[pool].implementation = implementation\n\n    is_finished: bool = False\n    swappable_coin: address = empty(address)\n    for i in range(MAX_COINS):\n        if i < len(self.base_pool_data[_base_pool].coins):\n            swappable_coin = self.base_pool_data[_base_pool].coins[i]\n        else:\n            is_finished = True\n            swappable_coin = base_lp_token\n\n        key: uint256 = (convert(_coin, uint256) ^ convert(swappable_coin, uint256))\n        length = self.market_counts[key]\n        self.markets[key][length] = pool\n        self.market_counts[key] = length + 1\n\n        if is_finished:\n            break\n\n    log MetaPoolDeployed(_coin, _base_pool, _A, _fee, msg.sender)\n    return pool\n\n\n@external\ndef deploy_gauge(_pool: address) -> address:\n    \"\"\"\n    @notice Deploy a liquidity gauge for a factory pool\n    @param _pool Factory pool address to deploy a gauge for\n    @return Address of the deployed gauge\n    \"\"\"\n    assert self.pool_data[_pool].coins[0] != empty(address), \"Unknown pool\"\n    assert self.pool_data[_pool].liquidity_gauge == empty(address), \"Gauge already deployed\"\n    implementation: address = self.gauge_implementation\n    assert implementation != empty(address), \"Gauge implementation not set\"\n\n    gauge: address = create_from_blueprint(self.gauge_implementation, _pool, code_offset=3)\n    self.pool_data[_pool].liquidity_gauge = gauge\n\n    log LiquidityGaugeDeployed(_pool, gauge)\n    return gauge\n\n\n# <--- Admin / Guarded Functionality --->\n\n@external\ndef add_base_pool(\n    _base_pool: address,\n    _base_lp_token: address,\n    _coins: DynArray[address, MAX_COINS],\n    _asset_types: DynArray[uint8, MAX_COINS],\n    _n_coins: uint256,\n):\n    \"\"\"\n    @notice Add a base pool to the registry, which may be used in factory metapools\n    @dev Only callable by admin\n    @param _base_pool Pool address to add\n    @param _asset_types Asset type for pool, as an integer\n    \"\"\"\n    assert msg.sender == self.admin  # dev: admin-only function\n    assert len(self.base_pool_data[_base_pool].coins) == 0  # dev: pool exists\n    assert _n_coins < MAX_COINS  # dev: base pool can only have (MAX_COINS - 1) coins.\n\n    # add pool to pool_list\n    length: uint256 = self.base_pool_count\n    self.base_pool_list[length] = _base_pool\n    self.base_pool_count = length + 1\n    self.base_pool_data[_base_pool].lp_token = _base_lp_token\n    self.base_pool_data[_base_pool].n_coins = _n_coins\n    self.base_pool_data[_base_pool].asset_types = _asset_types\n\n    decimals: uint256 = 0\n    coins: DynArray[address, MAX_COINS] = _coins\n    for i in range(MAX_COINS):\n        if i == _n_coins:\n            break\n        coin: address = coins[i]\n        self.base_pool_data[_base_pool].coins.append(coin)\n        self.base_pool_data[_base_pool].asset_types.append(_asset_types[i])\n        self.base_pool_assets[coin] = True\n        decimals += (ERC20(coin).decimals() << i*8)\n    self.base_pool_data[_base_pool].decimals = decimals\n\n    log BasePoolAdded(_base_pool)\n\n\n@external\ndef set_pool_implementations(\n    _implementation_index: uint256,\n    _implementation: address,\n):\n    \"\"\"\n    @notice Set implementation contracts for pools\n    @dev Only callable by admin\n    @param _implementation_index Implementation index where implementation is stored\n    @param _implementation Implementation address to use when deploying plain pools\n    \"\"\"\n    assert msg.sender == self.admin  # dev: admin-only function\n    self.pool_implementations[_implementation_index] = _implementation\n\n\n@external\ndef set_metapool_implementations(\n    _implementation_index: uint256,\n    _implementation: address,\n):\n    \"\"\"\n    @notice Set implementation contracts for metapools\n    @dev Only callable by admin\n    @param _implementation_index Implementation index where implementation is stored\n    @param _implementation Implementation address to use when deploying meta pools\n    \"\"\"\n    assert msg.sender == self.admin  # dev: admin-only function\n    self.metapool_implementations[_implementation_index] = _implementation\n\n\n@external\ndef set_math_implementation(_math_implementation: address):\n    \"\"\"\n    @notice Set implementation contracts for StableSwap Math\n    @dev Only callable by admin\n    @param _math_implementation Address of the math implementation contract\n    \"\"\"\n    assert msg.sender == self.admin  # dev: admin-only function\n    self.math_implementation = _math_implementation\n\n\n@external\ndef set_gauge_implementation(_gauge_implementation: address):\n    \"\"\"\n    @notice Set implementation contracts for liquidity gauge\n    @dev Only callable by admin\n    @param _gauge_implementation Address of the gauge blueprint implementation contract\n    \"\"\"\n    assert msg.sender == self.admin  # dev: admin-only function\n    self.gauge_implementation = _gauge_implementation\n\n\n@external\ndef set_views_implementation(_views_implementation: address):\n    \"\"\"\n    @notice Set implementation contracts for Views methods\n    @dev Only callable by admin\n    @param _views_implementation Implementation address of views contract\n    \"\"\"\n    assert msg.sender == self.admin  # dev: admin-only function\n    self.views_implementation = _views_implementation\n\n\n@external\ndef commit_transfer_ownership(_addr: address):\n    \"\"\"\n    @notice Transfer ownership of this contract to `addr`\n    @param _addr Address of the new owner\n    \"\"\"\n    assert msg.sender == self.admin  # dev: admin only\n    self.future_admin = _addr\n\n\n@external\ndef accept_transfer_ownership():\n    \"\"\"\n    @notice Accept a pending ownership transfer\n    @dev Only callable by the new owner\n    \"\"\"\n    _admin: address = self.future_admin\n    assert msg.sender == _admin  # dev: future admin only\n\n    self.admin = _admin\n    self.future_admin = empty(address)\n\n\n@external\ndef set_fee_receiver(_pool: address, _fee_receiver: address):\n    \"\"\"\n    @notice Set fee receiver for all pools\n    @param _pool Address of  pool to set fee receiver for.\n    @param _fee_receiver Address that fees are sent to\n    \"\"\"\n    assert msg.sender == self.admin  # dev: admin only\n    self.fee_receiver = _fee_receiver"
    },
    {
      "filename": "contracts/main/CurveStableSwapFactoryNG.vy",
      "content": "# @version 0.3.9\n\"\"\"\n@title CurveStableswapFactoryNG\n@author Curve.Fi\n@license Copyright (c) Curve.Fi, 2023 - all rights reserved\n@notice Permissionless pool deployer and registry\n\"\"\"\n\nstruct PoolArray:\n    base_pool: address\n    implementation: address\n    liquidity_gauge: address\n    coins: DynArray[address, MAX_COINS]\n    decimals: DynArray[uint256, MAX_COINS]\n    n_coins: uint256\n    asset_types: DynArray[uint8, MAX_COINS]\n\nstruct BasePoolArray:\n    lp_token: address\n    coins: DynArray[address, MAX_COINS]\n    decimals: uint256\n    n_coins: uint256\n    asset_types: DynArray[uint8, MAX_COINS]\n\n\ninterface AddressProvider:\n    def admin() -> address: view\n\ninterface ERC20:\n    def balanceOf(_addr: address) -> uint256: view\n    def decimals() -> uint256: view\n    def totalSupply() -> uint256: view\n    def approve(_spender: address, _amount: uint256): nonpayable\n\ninterface CurvePool:\n    def A() -> uint256: view\n    def fee() -> uint256: view\n    def admin_fee() -> uint256: view\n    def balances(i: uint256) -> uint256: view\n    def admin_balances(i: uint256) -> uint256: view\n    def get_virtual_price() -> uint256: view\n    def exchange(\n        i: int128,\n        j: int128,\n        dx: uint256,\n        min_dy: uint256,\n        _receiver: address,\n    ) -> uint256: nonpayable\n\ninterface CurveFactoryMetapool:\n    def coins(i :uint256) -> address: view\n    def decimals() -> uint256: view\n\n\nevent BasePoolAdded:\n    base_pool: address\n\nevent PlainPoolDeployed:\n    coins: DynArray[address, MAX_COINS]\n    A: uint256\n    fee: uint256\n    deployer: address\n\nevent MetaPoolDeployed:\n    coin: address\n    base_pool: address\n    A: uint256\n    fee: uint256\n    deployer: address\n\nevent LiquidityGaugeDeployed:\n    pool: address\n    gauge: address\n\nMAX_COINS: constant(uint256) = 8\nADDRESS_PROVIDER: constant(address) = 0x0000000022D53366457F9d5E68Ec105046FC4383\n\nMAX_FEE: constant(uint256) = 5 * 10 ** 9\nFEE_DENOMINATOR: constant(uint256) = 10 ** 10\n\nadmin: public(address)\nfuture_admin: public(address)\n\npool_list: public(address[4294967296])   # master list of pools\npool_count: public(uint256)              # actual length of pool_list\npool_data: HashMap[address, PoolArray]\n\nbase_pool_list: public(address[4294967296])   # master list of pools\nbase_pool_count: public(uint256)         # actual length of pool_list\nbase_pool_data: public(HashMap[address, BasePoolArray])\n\n# asset -> is used in a metapool?\nbase_pool_assets: public(HashMap[address, bool])\n\n# index -> implementation address\npool_implementations: public(HashMap[uint256, address])\nmetapool_implementations: public(HashMap[uint256, address])\nmath_implementation: public(address)\ngauge_implementation: public(address)\nviews_implementation: public(address)\n\n# fee receiver for all pools\nfee_receiver: public(address)\n\n# mapping of coins -> pools for trading\n# a mapping key is generated for each pair of addresses via\n# `bitwise_xor(convert(a, uint256), convert(b, uint256))`\nmarkets: HashMap[uint256, address[4294967296]]\nmarket_counts: HashMap[uint256, uint256]\n\n\n@external\ndef __init__(_fee"
    }
  ]
}