{
  "Title": "[M-07] EIP-712 typehash is incorrect for several functions in `MetaTxLib`",
  "Content": "\nIn `LensHub.sol`, the second parameter of `setProfileMetadataURIWithSig()` is declared as `metadataURI`:\n\n[LensHub.sol#L119-L123](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/LensHub.sol#L119-L123)\n\n```solidity\n    function setProfileMetadataURIWithSig(\n        uint256 profileId,\n        string calldata metadataURI,\n        Types.EIP712Signature calldata signature\n    ) external override whenNotPaused onlyProfileOwnerOrDelegatedExecutor(signature.signer, profileId) {\n```\n\nHowever, its [EIP-712](https://eips.ethereum.org/EIPS/eip-712) typehash stores the parameter as `metadata` instead:\n\n[Typehash.sol#L33](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/libraries/constants/Typehash.sol#L33)\n\n```solidity\nbytes32 constant SET_PROFILE_METADATA_URI = keccak256('SetProfileMetadataURI(uint256 profileId,string metadata,uint256 nonce,uint256 deadline)');\n```\n\nThe `PostParams` struct (which is used for [`postWithSig()`](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/LensHub.sol#L235-L244)) has `address[] actionModules` and `bytes[] actionModulesInitDatas` as its third and fourth fields:\n\n[Types.sol#L178-L185](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/libraries/constants/Types.sol#L178-L185)\n\n```solidity\n    struct PostParams {\n        uint256 profileId;\n        string contentURI;\n        address[] actionModules;\n        bytes[] actionModulesInitDatas;\n        address referenceModule;\n        bytes referenceModuleInitData;\n    }\n```\n\nHowever, the third and fourth fields in its typehash are declared as `address collectModule` and `bytes collectModuleInitData` instead:\n\n[Typehash.sol#L23](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/libraries/constants/Typehash.sol#L23)\n\n```solidity\nbytes32 constant POST = keccak256('Post(uint256 profileId,string contentURI,address collectModule,bytes collectModuleInitData,address referenceModule,bytes referenceModuleInitData,uint256 nonce,uint256 deadline)');\n```\n\nThis occurs for the [`commentWithSig()`](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/LensHub.sol#L258-L267) and [`quoteWithSig()`](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/LensHub.sol#L303-L313) functions as well:\n\n[Typehash.sol#L25](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/libraries/constants/Typehash.sol#L25)\n\n```solidity\nbytes32 constant QUOTE = keccak256('Quote(uint256 profileId,string contentURI,uint256 pointedProfileId,uint256 pointedPubId,uint256[] referrerProfileIds,uint256[] referrerPubIds,bytes referenceModuleData,address collectModule,bytes collectModuleInitData,address referenceModule,bytes referenceModuleInitData,uint256 nonce,uint256 deadline)');\n```\n\n[Typehash.sol#L15](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/libraries/constants/Typehash.sol#L15)\n\n```solidity\nbytes32 constant COMMENT = keccak256('Comment(uint256 profileId,string contentURI,uint256 pointedProfileId,uint256 pointedPubId,uint256[] referrerProfileIds,uint256[] referrerPubIds,bytes referenceModuleData,address collectModule,bytes collectModuleInitData,address referenceModule,bytes referenceModuleInitData,uint256 nonce,uint256 deadline)');\n```\n\nThe fourth and fifth fields in the `MirrorParams` struct (which is used for [`mirrorWithSig()`](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/LensHub.sol#L281-L290)) are declared as `referrerProfileIds` and `referrerPubIds`:\n\n[Types.sol#L282-L289](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/libraries/constants/Types.sol#L282-L289)\n\n```solidity\n    struct MirrorParams {\n        uint256 profileId;\n        uint256 pointedProfileId;\n        uint256 pointedPubId;\n        uint256[] referrerProfileIds;\n        uint256[] referrerPubIds;\n        bytes referenceModuleData;\n    }\n```\n\nHowever, its EIP-712 typehash declares these fields as `referrerProfileId` and `referrerPubId` instead:\n\n[Typehash.sol#L21](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/libraries/constants/Typehash.sol#L21)\n\n```solidity\nbytes32 constant MIRROR = keccak256('Mirror(uint256 profileId,uint256 pointedProfileId,uint256 pointedPubId,uint256[] referrerProfileId,uint256[] referrerPubId,bytes referenceModuleData,uint256 nonce,uint256 deadline)');\n```\n\n### Impact\n\nDue to the use of incorrect typehashes, the signature verification in the functions listed above is not [EIP-712](https://eips.ethereum.org/EIPS/eip-712) compliant.\n\nContracts or dapps/backends that use \"correct\" typehashes that match the parameters of these functions will end up generating different signatures, causing them to revert when called.\n\n### Recommended Mitigation\n\nAmend the typehashes shown above to have matching parameters with their respective functions.\n\n### Assessed type\n\nError\n\n**[donosonaumczuk (Lens) disagreed with severity and commented](https://github.com/code-423n4/2023-07-lens-findings/issues/141#issuecomment-1669811529):**\n > We accept it, but we consider it Low severity instead. \"Assets are not at risk, function incorrect as to spec\".\n\n**[Picodes (judge) commented](https://github.com/code-423n4/2023-07-lens-findings/issues/141#issuecomment-1695727736):**\n > Keeping this under Medium severity as this breaks the EIP712 compliance, so can be seen as an instance of \"function of the protocol or its availability could be impacted\"\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-07-lens",
  "Code": [
    {
      "filename": "contracts/LensHub.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\n// Interfaces\nimport {ILensProtocol} from 'contracts/interfaces/ILensProtocol.sol';\nimport {IFollowNFT} from 'contracts/interfaces/IFollowNFT.sol';\n\n// Constants\nimport {Types} from 'contracts/libraries/constants/Types.sol';\nimport {Errors} from 'contracts/libraries/constants/Errors.sol';\n\n// Lens Hub Components\nimport {LensHubStorage} from 'contracts/base/LensHubStorage.sol';\nimport {LensImplGetters} from 'contracts/base/LensImplGetters.sol';\nimport {LensGovernable} from 'contracts/base/LensGovernable.sol';\nimport {LensProfiles} from 'contracts/base/LensProfiles.sol';\nimport {LensHubEventHooks} from 'contracts/base/LensHubEventHooks.sol';\n\n// Libraries\nimport {ActionLib} from 'contracts/libraries/ActionLib.sol';\nimport {LegacyCollectLib} from 'contracts/libraries/LegacyCollectLib.sol';\nimport {FollowLib} from 'contracts/libraries/FollowLib.sol';\nimport {MetaTxLib} from 'contracts/libraries/MetaTxLib.sol';\nimport {ProfileLib} from 'contracts/libraries/ProfileLib.sol';\nimport {PublicationLib} from 'contracts/libraries/PublicationLib.sol';\nimport {StorageLib} from 'contracts/libraries/StorageLib.sol';\nimport {ValidationLib} from 'contracts/libraries/ValidationLib.sol';\n\n// Lens Migrations V1 to V2\nimport {LensV2Migration} from 'contracts/misc/LensV2Migration.sol';\n\n/**\n * @title LensHub\n * @author Lens Protocol\n *\n * @notice This is the main entry point of the Lens Protocol. It contains governance functionality as well as\n * publishing and profile interaction functionality.\n *\n * NOTE: The Lens Protocol is unique in that frontend operators need to track a potentially overwhelming\n * number of NFT contracts and interactions at once. For that reason, we've made two quirky design decisions:\n *      1. Both Follow & Collect NFTs invoke a LensHub callback on transfer with the sole purpose of emitting an event.\n *      2. Almost every event in the protocol emits the current block timestamp, reducing the need to fetch it manually.\n */\ncontract LensHub is\n    LensProfiles,\n    LensGovernable,\n    LensV2Migration,\n    LensImplGetters,\n    LensHubEventHooks,\n    LensHubStorage,\n    ILensProtocol\n{\n    modifier onlyProfileOwnerOrDelegatedExecutor(address expectedOwnerOrDelegatedExecutor, uint256 profileId) {\n        ValidationLib.validateAddressIsProfileOwnerOrDelegatedExecutor(expectedOwnerOrDelegatedExecutor, profileId);\n        _;\n    }\n\n    modifier whenPublishingEnabled() {\n        if (StorageLib.getState() != Types.ProtocolState.Unpaused) {\n            revert Errors.PublishingPaused();\n        }\n        _;\n    }\n\n    constructor(\n        address moduleGlobals,\n        address followNFTImpl,\n        address collectNFTImpl, // We still pass the deprecated CollectNFTImpl for legacy Collects to work\n        address lensHandlesAddress,\n        address tokenHandleRegistryAddress,\n        address legacyFeeFollowModule,\n        address legacyProfileFollowModule,\n        address newFeeFollowModule,\n        uint256 tokenGuardianCooldown\n    )\n        LensProfiles(moduleGlobals, tokenGuardianCooldown)\n        LensV2Migration(\n            legacyFeeFollowModule,\n            legacyProfileFollowModule,\n            newFeeFollowModule,\n            lensHandlesAddress,\n            tokenHandleRegistryAddress\n        )\n        LensImplGetters(followNFTImpl, collectNFTImpl)\n    {}\n\n    /// @inheritdoc ILensProtocol\n    function createProfile(Types.CreateProfileParams calldata createProfileParams)\n        external\n        override\n        whenNotPaused\n        returns (uint256)\n    {\n        ValidationLib.validateProfileCreatorWhitelisted(msg.sender);\n        unchecked {\n            uint256 profileId = ++_profileCounter;\n            _mint(createProfileParams.to, profileId);\n            ProfileLib.createProfile(createProfileParams, profileId);\n            return profileId;\n        }\n    }\n\n    ///////////////////////////////////////////\n    ///        PROFILE OWNER FUNCTIONS      ///\n    ///////////////////////////////////////////\n\n    /// @inheritdoc ILensProtocol\n    function setProfileMetadataURI(uint256 profileId, string calldata metadataURI)\n        external\n        override\n        whenNotPaused\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, profileId)\n    {\n        ProfileLib.setProfileMetadataURI(profileId, metadataURI);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function setProfileMetadataURIWithSig(\n        uint256 profileId,\n        string calldata metadataURI,\n        Types.EIP712Signature calldata signature\n    ) external override whenNotPaused onlyProfileOwnerOrDelegatedExecutor(signature.signer, profileId) {\n        MetaTxLib.validateSetProfileMetadataURISignature(signature, profileId, metadataURI);\n        ProfileLib.setProfileMetadataURI(profileId, metadataURI);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function setFollowModule(\n        uint256 profileId,\n        address followModule,\n        bytes calldata followModuleInitData\n    ) external override whenNotPaused onlyProfileOwnerOrDelegatedExecutor(msg.sender, profileId) {\n        ProfileLib.setFollowModule(profileId, followModule, followModuleInitData);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function setFollowModuleWithSig(\n        uint256 profileId,\n        address followModule,\n        bytes calldata followModuleInitData,\n        Types.EIP712Signature calldata signature\n    ) external override whenNotPaused onlyProfileOwnerOrDelegatedExecutor(signature.signer, profileId) {\n        MetaTxLib.validateSetFollowModuleSignature(signature, profileId, followModule, followModuleInitData);\n        ProfileLib.setFollowModule(profileId, followModule, followModuleInitData);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function changeDelegatedExecutorsConfig(\n        uint256 delegatorProfileId,\n        address[] calldata delegatedExecutors,\n        bool[] calldata approvals,\n        uint64 configNumber,\n        bool switchToGivenConfig\n    ) external override whenNotPaused onlyProfileOwner(msg.sender, delegatorProfileId) {\n        ProfileLib.changeGivenDelegatedExecutorsConfig(\n            delegatorProfileId,\n            delegatedExecutors,\n            approvals,\n            configNumber,\n            switchToGivenConfig\n        );\n    }\n\n    function changeDelegatedExecutorsConfig(\n        uint256 delegatorProfileId,\n        address[] calldata delegatedExecutors,\n        bool[] calldata approvals\n    ) external override whenNotPaused onlyProfileOwner(msg.sender, delegatorProfileId) {\n        ProfileLib.changeDelegatedExecutorsConfig(delegatorProfileId, delegatedExecutors, approvals);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function changeDelegatedExecutorsConfigWithSig(\n        uint256 delegatorProfileId,\n        address[] calldata delegatedExecutors,\n        bool[] calldata approvals,\n        uint64 configNumber,\n        bool switchToGivenConfig,\n        Types.EIP712Signature calldata signature\n    ) external override whenNotPaused onlyProfileOwner(signature.signer, delegatorProfileId) {\n        MetaTxLib.validateChangeDelegatedExecutorsConfigSignature(\n            signature,\n            delegatorProfileId,\n            delegatedExecutors,\n            approvals,\n            configNumber,\n            switchToGivenConfig\n        );\n        ProfileLib.changeGivenDelegatedExecutorsConfig(\n            delegatorProfileId,\n            delegatedExecutors,\n            approvals,\n            configNumber,\n            switchToGivenConfig\n        );\n    }\n\n    /// @inheritdoc ILensProtocol\n    function setProfileImageURI(uint256 profileId, string calldata imageURI)\n        external\n        override\n        whenNotPaused\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, profileId)\n    {\n        ProfileLib.setProfileImageURI(profileId, imageURI);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function setProfileImageURIWithSig(\n        uint256 profileId,\n        string calldata imageURI,\n        Types.EIP712Signature calldata signature\n    ) external override whenNotPaused onlyProfileOwnerOrDelegatedExecutor(signature.signer, profileId) {\n        MetaTxLib.validateSetProfileImageURISignature(signature, profileId, imageURI);\n        ProfileLib.setProfileImageURI(profileId, imageURI);\n    }\n\n    ////////////////////////////////////////\n    ///        PUBLISHING FUNCTIONS      ///\n    ////////////////////////////////////////\n\n    /// @inheritdoc ILensProtocol\n    function post(Types.PostParams calldata postParams)\n        external\n        override\n        whenPublishingEnabled\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, postParams.profileId)\n        returns (uint256)\n    {\n        return PublicationLib.post({postParams: postParams, transactionExecutor: msg.sender});\n    }\n\n    /// @inheritdoc ILensProtocol\n    function postWithSig(Types.PostParams calldata postParams, Types.EIP712Signature calldata signature)\n        external\n        override\n        whenPublishingEnabled\n        onlyProfileOwnerOrDelegatedExecutor(signature.signer, postParams.profileId)\n        returns (uint256)\n    {\n        MetaTxLib.validatePostSignature(signature, postParams);\n        return PublicationLib.post({postParams: postParams, transactionExecutor: signature.signer});\n    }\n\n    /// @inheritdoc ILensProtocol\n    function comment(Types.CommentParams calldata commentParams)\n        external\n        override\n        whenPublishingEnabled\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, commentParams.profileId)\n        returns (uint256)\n    {\n        return PublicationLib.comment({commentParams: commentParams, transactionExecutor: msg.sender});\n    }\n\n    /// @inheritdoc ILensProtocol\n    function commentWithSig(Types.CommentParams calldata commentParams, Types.EIP712Signature calldata signature)\n        external\n        override\n        whenPublishingEnabled\n        onlyProfileOwnerOrDelegatedExecutor(signature.signer, commentParams.profileId)\n        returns (uint256)\n    {\n        MetaTxLib.validateCommentSignature(signature, commentParams);\n        return PublicationLib.comment({commentParams: commentParams, transactionExecutor: signature.signer});\n    }\n\n    /// @inheritdoc ILensProtocol\n    function mirror(Types.MirrorParams calldata mirrorParams)\n        external\n        override\n        whenPublishingEnabled\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, mirrorParams.profileId)\n        returns (uint256)\n    {\n        return PublicationLib.mirror({mirrorParams: mirrorParams, transactionExecutor: msg.sender});\n    }\n\n    /// @inheritdoc ILensProtocol\n    function mirrorWithSig(Types.MirrorParams calldata mirrorParams, Types.EIP712Signature calldata signature)\n        external\n        override\n        whenPublishingEnabled\n        onlyProfileOwnerOrDelegatedExecutor(signature.signer, mirrorParams.profileId)\n        returns (uint256)\n    {\n        MetaTxLib.validateMirrorSignature(signature, mirrorParams);\n        return PublicationLib.mirror({mirrorParams: mirrorParams, transactionExecutor: signature.signer});\n    }\n\n    /// @inheritdoc ILensProtocol\n    function quote(Types.QuoteParams calldata quoteParams)\n        external\n        override\n        whenPublishingEnabled\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, quoteParams.profileId)\n        returns (uint256)\n    {\n        return PublicationLib.quote({quoteParams: quoteParams, transactionExecutor: msg.sender});\n    }\n\n    /// @inheritdoc ILensProtocol\n    function quoteWithSig(Types.QuoteParams calldata quoteParams, Types.EIP712Signature calldata signature)\n        external\n        override\n        whenPublishingEnabled\n        onlyProfileOwnerOrDelegatedExecutor(signature.signer, quoteParams.profileId)\n        returns (uint256)\n    {\n        MetaTxLib.validateQuoteSignature(signature, quoteParams);\n        return PublicationLib.quote({quoteParams: quoteParams, transactionExecutor: signature.signer});\n    }\n\n    /////////////////////////////////////////////////\n    ///        PROFILE INTERACTION FUNCTIONS      ///\n    /////////////////////////////////////////////////\n\n    /// @inheritdoc ILensProtocol\n    function follow(\n        uint256 followerProfileId,\n        uint256[] calldata idsOfProfilesToFollow,\n        uint256[] calldata followTokenIds,\n        bytes[] calldata datas\n    )\n        external\n        override\n        whenNotPaused\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, followerProfileId)\n        returns (uint256[] memory)\n    {\n        return\n            FollowLib.follow({\n                followerProfileId: followerProfileId,\n                idsOfProfilesToFollow: idsOfProfilesToFollow,\n                followTokenIds: followTokenIds,\n                followModuleDatas: datas,\n                transactionExecutor: msg.sender\n            });\n    }\n\n    /// @inheritdoc ILensProtocol\n    function followWithSig(\n        uint256 followerProfileId,\n        uint256[] calldata idsOfProfilesToFollow,\n        uint256[] calldata followTokenIds,\n        bytes[] calldata datas,\n        Types.EIP712Signature calldata signature\n    )\n        external\n        override\n        whenNotPaused\n        onlyProfileOwnerOrDelegatedExecutor(signature.signer, followerProfileId)\n        returns (uint256[] memory)\n    {\n        MetaTxLib.validateFollowSignature(signature, followerProfileId, idsOfProfilesToFollow, followTokenIds, datas);\n        return\n            FollowLib.follow({\n                followerProfileId: followerProfileId,\n                idsOfProfilesToFollow: idsOfProfilesToFollow,\n                followTokenIds: followTokenIds,\n                followModuleDatas: datas,\n                transactionExecutor: signature.signer\n            });\n    }\n\n    /// @inheritdoc ILensProtocol\n    function unfollow(uint256 unfollowerProfileId, uint256[] calldata idsOfProfilesToUnfollow)\n        external\n        override\n        whenNotPaused\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, unfollowerProfileId)\n    {\n        FollowLib.unfollow({\n            unfollowerProfileId: unfollowerProfileId,\n            idsOfProfilesToUnfollow: idsOfProfilesToUnfollow,\n            transactionExecutor: msg.sender\n        });\n    }\n\n    /// @inheritdoc ILensProtocol\n    function unfollowWithSig(\n        uint256 unfollowerProfileId,\n        uint256[] calldata idsOfProfilesToUnfollow,\n        Types.EIP712Signature calldata signature\n    ) external override whenNotPaused onlyProfileOwnerOrDelegatedExecutor(signature.signer, unfollowerProfileId) {\n        MetaTxLib.validateUnfollowSignature(signature, unfollowerProfileId, idsOfProfilesToUnfollow);\n\n        FollowLib.unfollow({\n            unfollowerProfileId: unfollowerProfileId,\n            idsOfProfilesToUnfollow: idsOfProfilesToUnfollow,\n            transactionExecutor: signature.signer\n        });\n    }\n\n    /// @inheritdoc ILensProtocol\n    function setBlockStatus(\n        uint256 byProfileId,\n        uint256[] calldata idsOfProfilesToSetBlockStatus,\n        bool[] calldata blockStatus\n    ) external override whenNotPaused onlyProfileOwnerOrDelegatedExecutor(msg.sender, byProfileId) {\n        return ProfileLib.setBlockStatus(byProfileId, idsOfProfilesToSetBlockStatus, blockStatus);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function setBlockStatusWithSig(\n        uint256 byProfileId,\n        uint256[] calldata idsOfProfilesToSetBlockStatus,\n        bool[] calldata blockStatus,\n        Types.EIP712Signature calldata signature\n    ) external override whenNotPaused onlyProfileOwnerOrDelegatedExecutor(signature.signer, byProfileId) {\n        MetaTxLib.validateSetBlockStatusSignature(signature, byProfileId, idsOfProfilesToSetBlockStatus, blockStatus);\n        return ProfileLib.setBlockStatus(byProfileId, idsOfProfilesToSetBlockStatus, blockStatus);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function collect(Types.CollectParams calldata collectParams)\n        external\n        override\n        whenNotPaused\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, collectParams.collectorProfileId)\n        returns (uint256)\n    {\n        return\n            LegacyCollectLib.collect({\n                collectParams: collectParams,\n                transactionExecutor: msg.sender,\n                collectorProfileOwner: ownerOf(collectParams.collectorProfileId),\n                collectNFTImpl: this.getCollectNFTImpl()\n            });\n    }\n\n    /// @inheritdoc ILensProtocol\n    function collectWithSig(Types.CollectParams calldata collectParams, Types.EIP712Signature calldata signature)\n        external\n        override\n        whenNotPaused\n        onlyProfileOwnerOrDelegatedExecutor(signature.signer, collectParams.collectorProfileId)\n        returns (uint256)\n    {\n        MetaTxLib.validateLegacyCollectSignature(signature, collectParams);\n        return\n            LegacyCollectLib.collect({\n                collectParams: collectParams,\n                transactionExecutor: signature.signer,\n                collectorProfileOwner: ownerOf(collectParams.collectorProfileId),\n                collectNFTImpl: this.getCollectNFTImpl()\n            });\n    }\n\n    /// @inheritdoc ILensProtocol\n    function act(Types.PublicationActionParams calldata publicationActionParams)\n        external\n        override\n        whenNotPaused\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, publicationActionParams.actorProfileId)\n        returns (bytes memory)\n    {\n        return\n            ActionLib.act({\n                publicationActionParams: publicationActionParams,\n                transactionExecutor: msg.sender,\n                actorProfileOwner: ownerOf(publicationActionParams.actorProfileId)\n            });\n    }\n\n    /// @inheritdoc ILensProtocol\n    function actWithSig(\n        Types.PublicationActionParams calldata publicationActionParams,\n        Types.EIP712Signature calldata signature\n    )\n        external\n        override\n        whenNotPaused\n        onlyProfileOwnerOrDelegatedExecutor(signature.signer, publicationActionParams.actorProfileId)\n        returns (bytes memory)\n    {\n        MetaTxLib.validateActSignature(signature, publicationActionParams);\n        return\n            ActionLib.act({\n                publicationActionParams: publicationActionParams,\n                transactionExecutor: signature.signer,\n                actorProfileOwner: ownerOf(publicationActionParams.actorProfileId)\n            });\n    }\n\n    ///////////////////////////////////////////\n    ///        EXTERNAL VIEW FUNCTIONS      ///\n    ///////////////////////////////////////////\n\n    /// @inheritdoc ILensProtocol\n    function isFollowing(uint256 followerProfileId, uint256 followedProfileId) external view returns (bool) {\n        address followNFT = _profiles[followedProfileId].followNFT;\n        return followNFT != address(0) && IFollowNFT(followNFT).isFollowing(followerProfileId);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function isDelegatedExecutorApproved(\n        uint256 delegatorProfileId,\n        address delegatedExecutor,\n        uint64 configNumber\n    ) external view returns (bool) {\n        return StorageLib.getDelegatedExecutorsConfig(delegatorProfileId).isApproved[configNumber][delegatedExecutor];\n    }\n\n    /// @inheritdoc ILensProtocol\n    function isDelegatedExecutorApproved(uint256 delegatorProfileId, address delegatedExecutor)\n        external\n        view\n        returns (bool)\n    {\n        return ProfileLib.isExecutorApproved(delegatorProfileId, delegatedExecutor);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function getDelegatedExecutorsConfigNumber(uint256 delegatorProfileId) external view returns (uint64) {\n        return StorageLib.getDelegatedExecutorsConfig(delegatorProfileId).configNumber;\n    }\n\n    /// @inheritdoc ILensProtocol\n    function getDelegatedExecutorsPrevConfigNumber(uint256 delegatorProfileId) external view returns (uint64) {\n        return StorageLib.getDelegatedExecutorsConfig(delegatorProfileId).prevConfigNumber;\n    }\n\n    /// @inheritdoc ILensProtocol\n    function getDelegatedExecutorsMaxConfigNumberSet(uint256 delegatorProfileId) external view returns (uint64) {\n        return StorageLib.getDelegatedExecutorsConfig(delegatorProfileId).maxConfigNumberSet;\n    }\n\n    /// @inheritdoc ILensProtocol\n    function isBlocked(uint256 profileId, uint256 byProfileId) external view returns (bool) {\n        return _blockedStatus[byProfileId][profileId];\n    }\n\n    /// @inheritdoc ILensProtocol\n    function getContentURI(uint256 profileId, uint256 pubId) external view override returns (string memory) {\n        // This function is used by the Collect NFTs' tokenURI function.\n        return PublicationLib.getContentURI(profileId, pubId);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function getProfile(uint256 profileId) external view override returns (Types.Profile memory) {\n        return _profiles[profileId];\n    }\n\n    /// @inheritdoc ILensProtocol\n    function getPublication(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (Types.Publication memory)\n    {\n        return _publications[profileId][pubId];\n    }\n\n    /// @inheritdoc ILensProtocol\n    function getPublicationType(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (Types.PublicationType)\n    {\n        return PublicationLib.getPublicationType(profileId, pubId);\n    }\n\n    function getActionModuleById(uint256 id) external view override returns (address) {\n        return _actionModules[id];\n    }\n}"
    },
    {
      "filename": "contracts/libraries/constants/Typehash.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\nlibrary Typehash {\n\n    bytes32 constant ACT = keccak256('Act(uint256 publicationActedProfileId,uint256 publicationActedId,uint256 actorProfileId,uint256[] referrerProfileIds,uint256[] referrerPubIds,address actionModuleAddress,bytes actionModuleData,uint256 nonce,uint256 deadline)');\n\n    bytes32 constant BURN = keccak256('Burn(uint256 tokenId,uint256 nonce,uint256 deadline)');\n\n    bytes32 constant CHANGE_DELEGATED_EXECUTORS_CONFIG = keccak256('ChangeDelegatedExecutorsConfig(uint256 delegatorProfileId,address[] delegatedExecutors,bool[] approvals,uint64 configNumber,bool switchToGivenConfig,uint256 nonce,uint256 deadline)');\n\n    bytes32 constant LEGACY_COLLECT = keccak256('Collect(uint256 publicationCollectedProfileId,uint256 publicationCollectedId,uint256 collectorProfileId,uint256 referrerProfileId,uint256 referrerPubId,bytes collectModuleData,uint256 nonce,uint256 deadline)');\n\n    bytes32 constant COMMENT = keccak256('Comment(uint256 profileId,string contentURI,uint256 pointedProfileId,uint256 pointedPubId,uint256[] referrerProfileIds,uint256[] referrerPubIds,bytes referenceModuleData,address collectModule,bytes collectModuleInitData,address referenceModule,bytes referenceModuleInitData,uint256 nonce,uint256 deadline)');\n\n    bytes32 constant EIP712_DOMAIN = keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)');\n\n    bytes32 constant FOLLOW = keccak256('Follow(uint256 followerProfileId,uint256[] idsOfProfilesToFollow,uint256[] followTokenIds,bytes[] datas,uint256 nonce,uint256 deadline)');\n\n    bytes32 constant MIRROR = keccak256('Mirror(uint256 profileId,uint256 pointedProfileId,uint256 pointedPubId,uint256[] referrerProfileId,uint256[] referrerPubId,bytes referenceModuleData,uint256 nonce,uint256 deadline)');\n\n    bytes32 constant POST = keccak256('Post(uint256 profileId,string contentURI,address collectModule,bytes collectModuleInitData,address referenceModule,bytes referenceModuleInitData,uint256 nonce,uint256 deadline)');\n\n    bytes32 constant QUOTE = keccak256('Quote(uint256 profileId,string contentURI,uint256 pointedProfileId,uint256 pointedPubId,uint256[] referrerProfileIds,uint256[] referrerPubIds,bytes referenceModuleData,address collectModule,bytes collectModuleInitData,address referenceModule,bytes referenceModuleInitData,uint256 nonce,uint256 deadline)');\n\n    bytes32 constant SET_BLOCK_STATUS = keccak256('SetBlockStatus(uint256 byProfileId,uint256[] idsOfProfilesToSetBlockStatus,bool[] blockStatus,uint256 nonce,uint256 deadline)');\n\n    bytes32 constant SET_FOLLOW_MODULE = keccak256('SetFollowModule(uint256 profileId,address followModule,bytes followModuleInitData,uint256 nonce,uint256 deadline)');\n\n    bytes32 constant SET_PROFILE_IMAGE_URI = keccak256('SetProfileImageURI(uint256 profileId,string imageURI,uint256 nonce,uint256 deadline)');\n\n    bytes32 constant SET_PROFILE_METADATA_URI = keccak256('SetProfileMetadataURI(uint256 profileId,string metadata,uint256 nonce,uint256 deadline)');\n\n    bytes32 constant UNFOLLOW = keccak256('Unfollow(uint256 unfollowerProfileId,uint256[] idsOfProfilesToUnfollow,uint256 nonce,uint256 deadline)');\n}"
    },
    {
      "filename": "contracts/LensHub.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\n// Interfaces\nimport {ILensProtocol} from 'contracts/interfaces/ILensProtocol.sol';\nimport {IFollowNFT} from 'contracts/interfaces/IFollowNFT.sol';\n\n// Constants\nimport {Types} from 'contracts/libraries/constants/Types.sol';\nimport {Errors} from 'contracts/libraries/constants/Errors.sol';\n\n// Lens Hub Components\nimport {LensHubStorage} from 'contracts/base/LensHubStorage.sol';\nimport {LensImplGetters} from 'contracts/base/LensImplGetters.sol';\nimport {LensGovernable} from 'contracts/base/LensGovernable.sol';\nimport {LensProfiles} from 'contracts/base/LensProfiles.sol';\nimport {LensHubEventHooks} from 'contracts/base/LensHubEventHooks.sol';\n\n// Libraries\nimport {ActionLib} from 'contracts/libraries/ActionLib.sol';\nimport {LegacyCollectLib} from 'contracts/libraries/LegacyCollectLib.sol';\nimport {FollowLib} from 'contracts/libraries/FollowLib.sol';\nimport {MetaTxLib} from 'contracts/libraries/MetaTxLib.sol';\nimport {ProfileLib} from 'contracts/libraries/ProfileLib.sol';\nimport {PublicationLib} from 'contracts/libraries/PublicationLib.sol';\nimport {StorageLib} from 'contracts/libraries/StorageLib.sol';\nimport {ValidationLib} from 'contracts/libraries/ValidationLib.sol';\n\n// Lens Migrations V1 to V2\nimport {LensV2Migration} from 'contracts/misc/LensV2Migration.sol';\n\n/**\n * @title LensHub\n * @author Lens Protocol\n *\n * @notice This is the main entry point of the Lens Protocol. It contains governance functionality as well as\n * publishing and profile interaction functionality.\n *\n * NOTE: The Lens Protocol is unique in that frontend operators need to track a potentially overwhelming\n * number of NFT contracts and interactions at once. For that reason, we've made two quirky design decisions:\n *      1. Both Follow & Collect NFTs invoke a LensHub callback on transfer with the sole purpose of emitting an event.\n *      2. Almost every event in the protocol emits the current block timestamp, reducing the need to fetch it manually.\n */\ncontract LensHub is\n    LensProfiles,\n    LensGovernable,\n    LensV2Migration,\n    LensImplGetters,\n    LensHubEventHooks,\n    LensHubStorage,\n    ILensProtocol\n{\n    modifier onlyProfileOwnerOrDelegatedExecutor(address expectedOwnerOrDelegatedExecutor, uint256 profileId) {\n        ValidationLib.validateAddressIsProfileOwnerOrDelegatedExecutor(expectedOwnerOrDelegatedExecutor, profileId);\n        _;\n    }\n\n    modifier whenPublishingEnabled() {\n        if (StorageLib.getState() != Types.ProtocolState.Unpaused) {\n            revert Errors.PublishingPaused();\n        }\n        _;\n    }\n\n    constructor(\n        address moduleGlobals,\n        address followNFTImpl,\n        address collectNFTImpl, // We still pass the deprecated CollectNFTImpl for legacy Collects to work\n        address lensHandlesAddress,\n        address tokenHandleRegistryAddress,\n        address legacyFeeFollowModule,\n        address legacyProfileFollowModule,\n        address newFeeFollowModule,\n        uint256 tokenGuardianCooldown\n    )\n        LensProfiles(moduleGlobals, tokenGuardianCooldown)\n        LensV2Migration(\n            legacyFeeFollowModule,\n            legacyProfileFollowModule,\n            newFeeFollowModule,\n            lensHandlesAddress,\n            tokenHandleRegistryAddress\n        )\n        LensImplGetters(followNFTImpl, collectNFTImpl)\n    {}\n\n    /// @inheritdoc ILensProtocol\n    function createProfile(Types.CreateProfileParams calldata createProfileParams)\n        external\n        override\n        whenNotPaused\n        returns (uint256)\n    {\n        ValidationLib.validateProfileCreatorWhitelisted(msg.sender);\n        unchecked {\n            uint256 profileId = ++_profileCounter;\n            _mint(createProfileParams.to, profileId);\n            ProfileLib.createProfile(createProfileParams, profileId);\n            return profileId;\n        }\n    }\n\n    ///////////////////////////////////////////\n    ///        PROFILE OWNER FUNCTIONS      ///\n    ///////////////////////////////////////////\n\n    /// @inheritdoc ILensProtocol\n    function setProfileMetadataURI(uint256 profileId, string calldata metadataURI)\n        external\n        override\n        whenNotPaused\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, profileId)\n    {\n        ProfileLib.setProfileMetadataURI(profileId, metadataURI);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function setProfileMetadataURIWithSig(\n        uint256 profileId,\n        string calldata metadataURI,\n        Types.EIP712Signature calldata signature\n    ) external override whenNotPaused onlyProfileOwnerOrDelegatedExecutor(signature.signer, profileId) {\n        MetaTxLib.validateSetProfileMetadataURISignature(signature, profileId, metadataURI);\n        ProfileLib.setProfileMetadataURI(profileId, metadataURI);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function setFollowModule(\n        uint256 profileId,\n        address followModule,\n        bytes calldata followModuleInitData\n    ) external override whenNotPaused onlyProfileOwnerOrDelegatedExecutor(msg.sender, profileId) {\n        ProfileLib.setFollowModule(profileId, followModule, followModuleInitData);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function setFollowModuleWithSig(\n        uint256 profileId,\n        address followModule,\n        bytes calldata followModuleInitData,\n        Types.EIP712Signature calldata signature\n    ) external override whenNotPaused onlyProfileOwnerOrDelegatedExecutor(signature.signer, profileId) {\n        MetaTxLib.validateSetFollowModuleSignature(signature, profileId, followModule, followModuleInitData);\n        ProfileLib.setFollowModule(profileId, followModule, followModuleInitData);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function changeDelegatedExecutorsConfig(\n        uint256 delegatorProfileId,\n        address[] calldata delegatedExecutors,\n        bool[] calldata approvals,\n        uint64 configNumber,\n        bool switchToGivenConfig\n    ) external override whenNotPaused onlyProfileOwner(msg.sender, delegatorProfileId) {\n        ProfileLib.changeGivenDelegatedExecutorsConfig(\n            delegatorProfileId,\n            delegatedExecutors,\n            approvals,\n            configNumber,\n            switchToGivenConfig\n        );\n    }\n\n    function changeDelegatedExecutorsConfig(\n        uint256 delegatorProfileId,\n        address[] calldata delegatedExecutors,\n        bool[] calldata approvals\n    ) external override whenNotPaused onlyProfileOwner(msg.sender, delegatorProfileId) {\n        ProfileLib.changeDelegatedExecutorsConfig(delegatorProfileId, delegatedExecutors, approvals);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function changeDelegatedExecutorsConfigWithSig(\n        uint256 delegatorProfileId,\n        address[] calldata delegatedExecutors,\n        bool[] calldata approvals,\n        uint64 configNumber,\n        bool switchToGivenConfig,\n        Types.EIP712Signature calldata signature\n    ) external override whenNotPaused onlyProfileOwner(signature.signer, delegatorProfileId) {\n        MetaTxLib.validateChangeDelegatedExecutorsConfigSignature(\n            signature,\n            delegatorProfileId,\n            delegatedExecutors,\n            approvals,\n            configNumber,\n            switchToGivenConfig\n        );\n        ProfileLib.changeGivenDelegatedExecutorsConfig(\n            delegatorProfileId,\n            delegatedExecutors,\n            approvals,\n            configNumber,\n            switchToGivenConfig\n        );\n    }\n\n    /// @inheritdoc ILensProtocol\n    function setProfileImageURI(uint256 profileId, string calldata imageURI)\n        external\n        override\n        whenNotPaused\n        onlyProfileOwnerOrDelegatedExecutor(msg.sender, profileId)\n    {\n        ProfileLib.setProfileImageURI(profileId, imageURI);\n    }\n\n    /// @inheritdoc ILensProtocol\n    function setProfileImageURIWithSig(\n        uint256 profileId,\n        string calldata imageURI,\n        Types."
    }
  ]
}