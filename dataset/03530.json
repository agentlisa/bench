{
  "Title": "[L07] Not using SafeMath functions",
  "Content": "Although several parts of the codebase employs its custom SafeMath methods where appropriate, there are still a few instances of regular Solidity arithmetic operators being used. Some examples are:\n\n\n* On [line 191 of `GovernorAlpha.sol`](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/GovernorAlpha.sol#L191) a `+` is used.\n* On [line 56 of `Reservoir.sol`](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/Reservoir.sol#L56) a `-` is used.\n* On [line 221 of `NoteERC20.sol`](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/NoteERC20.sol#L221) a `-` is used.\n* On [line 244 of `NoteERC20.sol`](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/NoteERC20.sol#L244) a `-` is used.\n* On [line 245 of `NoteERC20.sol`](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/NoteERC20.sol#L245) a `-` is used.\n* On [line 254 of `NoteERC20.sol`](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/NoteERC20.sol#L254) a `-` is used.\n* On [line 361 of `NoteERC20.sol`](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/NoteERC20.sol#L361) a `-` is used.\n* On [line 365 of `NoteERC20.sol`](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/contracts/external/governance/NoteERC20.sol#L365) a `+` is used.\n\n\nAlthough these cases do not represent a security risk per se, consider always performing arithmetic operations with methods that protect the system from such possibilities, like the [math libraries of OpenZeppelin contracts](https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/math).\n\n\n***Update:** Acknowledged, and will not fix. Notional’s statement for this issue:*\n\n\n\n> \n> *Won’t fix, overflow in any of these cases is highly unlikely*\n> \n> \n> \n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/external/governance/GovernorAlpha.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../global/Constants.sol\";\nimport \"@openzeppelin/contracts/access/TimelockController.sol\";\n\n/**\n * @title Notional Governor Alpha\n * Fork of Compound Governor Alpha at commit hash\n * https://github.com/compound-finance/compound-protocol/commit/9bcff34a5c9c76d51e51bcb0ca1139588362ef96\n */\ncontract GovernorAlpha is TimelockController {\n    /// @notice The name of this contract\n    string public constant name = \"Notional Governor Alpha\";\n\n    /// @notice The address of the Notional governance token\n    NoteInterface public immutable note;\n\n    /// @notice The maximum number of actions that can be included in a proposal\n    uint8 public constant proposalMaxOperations = 10;\n\n    /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\n    uint96 public quorumVotes;\n\n    /// @notice The number of votes required in order for a voter to become a proposer\n    uint96 public proposalThreshold;\n\n    /// @notice The delay before voting on a proposal may take place, once proposed\n    uint32 public votingDelayBlocks;\n\n    /// @notice The duration of voting on a proposal, in blocks\n    uint32 public votingPeriodBlocks;\n\n    /// @notice The address of the Governor Guardian\n    address public guardian;\n\n    /// @notice The total number of proposals\n    uint256 public proposalCount;\n\n    struct Proposal {\n        // Unique id for looking up a proposal\n        uint256 id;\n        // The timestamp at which voting begins: holders must delegate their votes prior to this block\n        uint32 startBlock;\n        // The timestamp at which voting ends: votes must be cast prior to this block\n        uint32 endBlock;\n        // Current number of votes in favor of this proposal\n        uint96 forVotes;\n        // Current number of votes in opposition to this proposal\n        uint96 againstVotes;\n        // Creator of the proposal\n        address proposer;\n        // Flag marking whether the proposal has been canceled\n        bool canceled;\n        // Flag marking whether the proposal has been executed\n        bool executed;\n        // Hash of the operation to reduce storage cost\n        bytes32 operationHash;\n    }\n\n    // Ballot receipt record for a voter\n    struct Receipt {\n        // Whether or not a vote has been cast\n        bool hasVoted;\n        // Whether or not the voter supports the proposal\n        bool support;\n        // The number of votes the voter had, which were cast\n        uint96 votes;\n    }\n\n    // Possible states that a proposal may be in\n    enum ProposalState {Pending, Active, Canceled, Defeated, Succeeded, Queued, Executed}\n\n    /// @notice The official record of all proposals ever proposed\n    mapping(uint256 => Proposal) public proposals;\n\n    /// @notice Receipts of ballots for the entire set of voters\n    mapping(uint256 => mapping(address => Receipt)) public receipts;\n\n    /// @notice The latest proposal for each proposer\n    mapping(address => uint256) public latestProposalIds;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the ballot struct uComp by the contract\n    bytes32 public constant BALLOT_TYPEHASH = keccak256(\"Ballot(uint256 proposalId,bool support)\");\n\n    /// @notice An event emitted when a new proposal is created\n    event ProposalCreated(\n        uint256 id,\n        address proposer,\n        address[] targets,\n        uint256[] values,\n        bytes[] calldatas,\n        uint256 startBlock,\n        uint256 endBlock\n    );\n\n    /// @notice An event emitted when a vote has been cast on a proposal\n    event VoteCast(address voter, uint256 proposalId, bool support, uint256 votes);\n\n    /// @notice An event emitted when a proposal has been canceled\n    event ProposalCanceled(uint256 id);\n\n    /// @notice An event emitted when a proposal has been queued in the Timelock\n    event ProposalQueued(uint256 id, uint256 eta);\n\n    /// @notice An event emitted when a proposal has been executed in the Timelock\n    event ProposalExecuted(uint256 id);\n\n    /// @notice An event emitted when amount of quorum votes required is updated\n    event UpdateQuorumVotes(uint96 newQuorumVotes);\n\n    /// @notice An event emitted when a new proposal threshold has been set\n    event UpdateProposalThreshold(uint96 newProposalThreshold);\n\n    /// @notice An event emitted when a new voting delay in blocks has been set\n    event UpdateVotingDelayBlocks(uint32 newVotingDelayBlocks);\n\n    /// @notice An event emitted when a new voting period in blocks has been set\n    event UpdateVotingPeriodBlocks(uint32 newVotingPeriodBlocks);\n\n    constructor(\n        uint96 quorumVotes_,\n        uint96 proposalThreshold_,\n        uint32 votingDelayBlocks_,\n        uint32 votingPeriodBlocks_,\n        address note_,\n        address guardian_,\n        uint256 minDelay_\n    ) TimelockController(minDelay_, new address[](0), new address[](0)) {\n        quorumVotes = quorumVotes_;\n        proposalThreshold = proposalThreshold_;\n        votingDelayBlocks = votingDelayBlocks_;\n        votingPeriodBlocks = votingPeriodBlocks_;\n        note = NoteInterface(note_);\n        guardian = guardian_;\n\n        // Only the external methods can be used to execute governance\n        grantRole(PROPOSER_ROLE, address(this));\n        grantRole(EXECUTOR_ROLE, address(this));\n        revokeRole(TIMELOCK_ADMIN_ROLE, msg.sender);\n    }\n\n    /// @notice Proposes a new governance action\n    /// @param targets an array of addresses to take actions on\n    /// @param values an array of ether amounts to send to respective target address\n    /// @param calldatas an array of calldata bytes to call respective target address with\n    /// @dev emit:ProposalCreated\n    /// @return newly created proposal id\n    function propose(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata calldatas\n    ) external returns (uint256) {\n        uint256 blockNumber = block.number;\n        require(blockNumber > 0 && blockNumber < type(uint32).max);\n\n        require(\n            note.getPriorVotes(msg.sender, blockNumber - 1) > proposalThreshold,\n            \"GovernorAlpha::propose: proposer votes below proposal threshold\"\n        );\n        require(\n            targets.length == values.length && targets.length == calldatas.length,\n            \"GovernorAlpha::propose: proposal function information arity mismatch\"\n        );\n        require(targets.length != 0, \"GovernorAlpha::propose: must provide actions\");\n        require(\n            targets.length <= proposalMaxOperations,\n            \"GovernorAlpha::propose: too many actions\"\n        );\n\n        {\n            uint256 latestProposalId = latestProposalIds[msg.sender];\n            if (latestProposalId != 0) {\n                ProposalState proposersLatestProposalState = state(latestProposalId);\n                require(\n                    proposersLatestProposalState != ProposalState.Active,\n                    \"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\"\n                );\n                require(\n                    proposersLatestProposalState != ProposalState.Pending,\n                    \"GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal\"\n                );\n            }\n        }\n\n        uint256 newProposalId = proposalCount + 1;\n        proposalCount = newProposalId;\n\n        uint32 startBlock = _add32(uint32(blockNumber), votingDelayBlocks);\n        uint32 endBlock = _add32(startBlock, votingPeriodBlocks);\n        bytes32 operationHash = _computeHash(targets, values, calldatas, newProposalId);\n\n        Proposal memory newProposal =\n            Proposal({\n                id: newProposalId,\n                proposer: msg.sender,\n                startBlock: startBlock,\n                endBlock: endBlock,\n                forVotes: 0,\n                againstVotes: 0,\n                canceled: false,\n                executed: false,\n                operationHash: operationHash\n            });\n\n        proposals[newProposal.id] = newProposal;\n        latestProposalIds[newProposal.proposer] = newProposal.id;\n\n        emit ProposalCreated(\n            newProposal.id,\n            msg.sender,\n            targets,\n            values,\n            calldatas,\n            startBlock,\n            endBlock\n        );\n        return newProposal.id;\n    }\n\n    /// @dev Helper method required to clear the stack for hashing operations\n    function _computeHash(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata calldatas,\n        uint256 proposalId\n    ) private pure returns (bytes32) {\n        return hashOperationBatch(targets, values, calldatas, \"\", bytes32(proposalId));\n    }\n\n    /// @notice Adds a proposal to the timelock queue only after its vote has passed, `targets`,\n    /// `values`, and `calldatas` provided must hash back to the original proposal. All proposals\n    /// will automatically be delayed `getMinDelay()` seconds.\n    /// @param proposalId unique identifier for the proposal\n    /// @param targets an array of addresses to take actions on\n    /// @param values an array of ether amounts to send to respective target address\n    /// @param calldatas an array of calldata bytes to call respective target address with\n    /// @dev emit:ProposalQueued emit:CallScheduled (per call)\n    function queueProposal(\n        uint256 proposalId,\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata calldatas\n    ) external {\n        require(state(proposalId) == ProposalState.Succeeded, \"Proposal must be success\");\n        bytes32 computedOperationHash = _computeHash(targets, values, calldatas, proposalId);\n        {\n            Proposal storage proposal = proposals[proposalId];\n            require(computedOperationHash == proposal.operationHash, \"Operation hash mismatch\");\n        }\n\n        _scheduleBatch(targets, values, calldatas, proposalId);\n\n        emit ProposalQueued(proposalId, getMinDelay());\n    }\n\n    /// @dev Required to clear the stack for calling the timelock controller\n    function _scheduleBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata calldatas,\n        uint256 proposalId\n    ) private {\n        // NOTE: this will also emit events\n        this.scheduleBatch(targets, values, calldatas, \"\", bytes32(proposalId), getMinDelay());\n    }\n\n    /// @notice Executes a proposal in the timelock queue after its delay has passed, `targets`,\n    /// `values`, and `calldatas` provided must hash back to the original proposal.\n    /// @param proposalId unique identifier for the proposal\n    /// @param targets an array of addresses to take actions on\n    /// @param values an array of ether amounts to send to respective target address\n    /// @param calldatas an array of calldata bytes to call respective target address with\n    /// @dev emit:ProposalExecuted emit:CallExecuted (per call)\n    function executeProposal(\n        uint256 proposalId,\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata calldatas\n    ) external payable {\n        Proposal storage proposal = proposals[proposalId];\n        proposal.executed = true;\n\n        bytes32 computedOperationHash = _computeHash(targets, values, calldatas, proposalId);\n        require(computedOperationHash == proposal.operationHash, \"Operation hash mismatch\");\n        // Execute batch will revert if the call has not been scheduled\n        _executeBatch(targets, values, calldatas, proposalId);\n\n        emit ProposalExecuted(proposalId);\n    }\n\n    /// @dev Helper function to clear the stack for the timelock controller call\n    function _executeBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata calldatas,\n        uint256 proposalId\n    ) private {\n        this.executeBatch(targets, values, calldatas, \"\", bytes32(proposalId));\n    }\n\n    /// @notice Cancels a proposal after it has been created. Can only be done if the proposer\n    /// no longer has sufficient votes (i.e. they made a proposal and then sold their tokens) or\n    /// by a guardian address if it exists.\n    /// @param proposalId unique identifier for the proposal\n    /// @dev emit:ProposalCanceled emit:Cancelled\n    function cancelProposal(uint256 proposalId) public {\n        ProposalState proposalState = state(proposalId);\n        require(proposalState != ProposalState.Executed, \"Proposal already executed\");\n\n        Proposal storage proposal = proposals[proposalId];\n        uint256 blockNumber = block.number;\n        require(blockNumber > 0);\n        require(\n            msg.sender == guardian ||\n                note.getPriorVotes(proposal.proposer, blockNumber - 1) < proposalThreshold,\n            \"GovernorAlpha::cancel: proposer above threshold\"\n        );\n\n        proposal.canceled = true;\n        // Removes the operation hash from the timelock controller if pending.\n        if (isOperationPending(proposal.operationHash)) this.cancel(proposal.operationHash);\n\n        emit ProposalCanceled(proposalId);\n    }\n\n    /// @notice Returns the voting receipt for a voter on a proposal\n    /// @param proposalId unique identifier for the proposal\n    /// @param voter address of the voter\n    function getReceipt(uint256 proposalId, address voter) public view returns (Receipt memory) {\n        return receipts[proposalId][voter];\n    }\n\n    /// @notice Returns the current state of a proposal\n    /// @param proposalId unique identifier for the proposal\n    /// @return ProposalState\n    function state(uint256 proposalId) public view returns (ProposalState) {\n        require(\n            proposalCount >= proposalId && proposalId > 0,\n            \"GovernorAlpha::state: invalid proposal id\"\n        );\n        Proposal memory proposal = proposals[proposalId];\n        uint256 blockNumber = block.number;\n\n        if (proposal.canceled) {\n            return ProposalState.Canceled;\n        } else if (blockNumber <= proposal.startBlock) {\n            return ProposalState.Pending;\n        } else if (blockNumber <= proposal.endBlock) {\n            return ProposalState.Active;\n        } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < quorumVotes) {\n            return ProposalState.Defeated;\n        } else if (proposal.executed) {\n            return ProposalState.Executed;\n        } else if (\n            proposal.forVotes > proposal.againstVotes &&\n            proposal.forVotes > quorumVotes &&\n            blockNumber >= proposal.endBlock\n        ) {\n            return ProposalState.Succeeded;\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n\n    /// @notice Cast a vote for a proposal\n    /// @param proposalId unique identifier for the proposal\n    /// @param support true if votes are for the proposal, false if against\n    /// @dev emit:VoteCast\n    function castVote(uint256 proposalId, bool support) public {\n        return _castVote(msg.sender, proposalId, support);\n    }\n\n    /// @notice Cast a vote for a proposal via signature\n    /// @param proposalId unique identifier for the proposal\n    /// @param support true if votes are for the proposal, false if against\n    /// @param v signature component\n    /// @param r signature component\n    /// @param s signature component\n    /// @dev emit:VoteCast\n    function castVoteBySig(\n        uint256 proposalId,\n        bool support,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        bytes32 domainSeparator =\n            keccak256(\n                abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), _getChainId(), address(this))\n            );\n        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \"GovernorAlpha::castVoteBySig: invalid signature\");\n        return _castVote(signatory, proposalId, support);\n    }\n\n    /// @dev Registers a vote, calls the NOTE token to get the voting power for the voter\n    function _castVote(\n        address voter,\n        uint256 proposalId,\n        bool support\n    ) internal {\n        require(\n            state(proposalId) == ProposalState.Active,\n            \"GovernorAlpha::_castVote: voting is closed\"\n        );\n        Proposal storage proposal = proposals[proposalId];\n        Receipt storage receipt = receipts[proposalId][voter];\n        require(receipt.hasVoted == false, \"GovernorAlpha::_castVote: voter already voted\");\n        uint96 votes = note.getPriorVotes(voter, proposal.startBlock);\n\n        if (support) {\n            proposal.forVotes = _add96(proposal.forVotes, votes);\n        } else {\n            proposal.againstVotes = _add96(proposal.againstVotes, votes);\n        }\n\n        receipt.hasVoted = true;\n        receipt.support = support;\n        receipt.votes = votes;\n\n        emit VoteCast(voter, proposalId, support, votes);\n    }\n\n    function updateQuorumVotes(uint96 newQuorumVotes) external {\n        require(msg.sender == address(this), \"Unauthorized caller\");\n        quorumVotes = newQuorumVotes;\n        emit UpdateQuorumVotes(newQuorumVotes);\n    }\n\n    function updateProposalThreshold(uint96 newProposalThreshold) external {\n        require(msg.sender == address(this), \"Unauthorized caller\");\n        proposalThreshold = newProposalThreshold;\n        emit UpdateProposalThreshold(newProposalThreshold);\n    }\n\n    function updateVotingDelayBlocks(uint32 newVotingDelayBlocks) external {\n        require(msg.sender == address(this), \"Unauthorized caller\");\n        votingDelayBlocks = newVotingDelayBlocks;\n        emit UpdateVotingDelayBlocks(newVotingDelayBlocks);\n    }\n\n    function updateVotingPeriodBlocks(uint32 newVotingPeriodBlocks) external {\n        require(msg.sender == address(this), \"Unauthorized caller\");\n        votingPeriodBlocks = newVotingPeriodBlocks;\n        emit UpdateVotingPeriodBlocks(newVotingPeriodBlocks);\n    }\n\n    /// @dev Hidden public method\n    function __abdicate() public {\n        require(msg.sender == guardian, \"GovernorAlpha::__abdicate: sender must be gov guardian\");\n        guardian = address(0);\n    }\n\n    /// @dev Overflow check for adding votes\n    function _add96(uint96 a, uint96 b) private pure returns (uint96) {\n        uint96 c = a + b;\n        require(c >= a, \"addition overflow\");\n        return c;\n    }\n\n    /// @dev Overflow check for adding block numbers\n    function _add32(uint32 a, uint32 b) private pure returns (uint32) {\n        uint32 c = a + b;\n        require(c >= a, \"addition overflow\");\n        return c;\n    }\n\n    /// @dev Helper method for signature check\n    function _getChainId() private pure returns (uint256) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId;\n    }\n}\n\ninterface NoteInterface {\n    function getPriorVotes(address account, uint256 blockNumber) external view returns (uint96);\n}"
    },
    {
      "filename": "contracts/external/governance/Reservoir.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.7.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title Reservoir Contract\n/// @notice Distributes a token to a different contract at a fixed rate. Though not entirely\n/// necessary this contract does give some measure of safety against the Notional contract's token\n/// reserves being drained by an attack. The goal should be to set up a reservoir such that the\n/// Notional contract's target reserves are maintained at some reasonable level.\n/// @dev This contract must be poked via the `drip()` function every so often.\n/// @author Compound, modified by Notional\ncontract Reservoir {\n    using SafeMath for uint256;\n\n    /// @notice The timestamp when the Reservoir started\n    uint256 public immutable DRIP_START;\n\n    /// @notice Tokens per second that to drip to target\n    uint256 public immutable DRIP_RATE;\n\n    /// @notice Reference to token to drip\n    IERC20 public immutable TOKEN;\n\n    /// @notice Target to receive dripped tokens\n    address public immutable TARGET;\n\n    /// @notice Amount that has already been dripped\n    uint256 public dripped;\n\n    /// @notice Constructs a Reservoir\n    /// @param dripRate_ Number of tokens per block to drip\n    /// @param token_ The token to drip\n    /// @param target_ The recipient of dripped tokens\n    constructor(\n        uint256 dripRate_,\n        IERC20 token_,\n        address target_\n    ) {\n        DRIP_START = block.timestamp;\n        DRIP_RATE = dripRate_;\n        TOKEN = token_;\n        TARGET = target_;\n        dripped = 0;\n    }\n\n    /// @notice Drips the maximum amount of tokens to match the drip rate since inception\n    /// @dev emit:Transfer\n    /// @return amountToDrip tokens dripped\n    function drip() public returns (uint256 amountToDrip) {\n        uint256 reservoirBalance = TOKEN.balanceOf(address(this));\n        require(reservoirBalance > 0, \"Reservoir empty\");\n        uint256 blockTime = block.timestamp;\n\n        amountToDrip = DRIP_RATE.mul(blockTime - DRIP_START).sub(dripped);\n        if (amountToDrip > reservoirBalance) amountToDrip = reservoirBalance;\n\n        // Finally, write new `dripped` value and transfer tokens to target\n        dripped = dripped.add(amountToDrip);\n        // No need to do special checking for return codes, here we know that the token\n        // will be compliant because it is the NOTE contract\n        bool success = TOKEN.transfer(TARGET, amountToDrip);\n        require(success, \"Transfer failed\");\n    }\n}"
    },
    {
      "filename": "contracts/external/governance/NoteERC20.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"interfaces/notional/NotionalProxy.sol\";\nimport \"@openzeppelin/contracts/proxy/Initializable.sol\";\n\n/// @title Note ERC20 Token\n/// Fork of Compound Comp token at commit hash\n/// https://github.com/compound-finance/compound-protocol/commit/9bcff34a5c9c76d51e51bcb0ca1139588362ef96\ncontract NoteERC20 is Initializable {\n    /// @notice EIP-20 token name for this token\n    string public constant name = \"Notional\";\n\n    /// @notice EIP-20 token symbol for this token\n    string public constant symbol = \"NOTE\";\n\n    /// @notice EIP-20 token decimals for this token\n    uint8 public constant decimals = 8;\n\n    /// @notice Total number of tokens in circulation (100 million NOTE)\n    uint256 public constant totalSupply = 100000000e8;\n\n    /// @notice Notional router address\n    NotionalProxy public notionalProxy;\n\n    // Allowance amounts on behalf of others\n    mapping(address => mapping(address => uint96)) internal allowances;\n\n    // Official record of token balances for each account\n    mapping(address => uint96) internal balances;\n\n    /// @notice A record of each accounts delegate\n    mapping(address => address) public delegates;\n\n    /// @notice A checkpoint for marking number of votes from a given block\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint96 votes;\n    }\n\n    /// @notice A record of votes checkpoints for each account, by index\n    mapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\n\n    /// @notice The number of checkpoints for each account\n    mapping(address => uint32) public numCheckpoints;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\n    bytes32 public constant DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    /// @notice A record of states for signing / validating signatures\n    mapping(address => uint256) public nonces;\n\n    /// @notice An event thats emitted when an account changes its delegate\n    event DelegateChanged(\n        address indexed delegator,\n        address indexed fromDelegate,\n        address indexed toDelegate\n    );\n\n    /// @notice An event thats emitted when a delegate account's vote balance changes\n    event DelegateVotesChanged(\n        address indexed delegate,\n        uint256 previousBalance,\n        uint256 newBalance\n    );\n\n    /// @notice The standard EIP-20 transfer event\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    /// @notice The standard EIP-20 approval event\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /// @notice Initialize note token with initial grants\n    /// @param initialAccounts initial address to grant tokens to\n    /// @param initialGrantAmount amount to grant address initially\n    /// @param notionalProxy_ address of notional proxy\n    function initialize(\n        address[] calldata initialAccounts,\n        uint96[] calldata initialGrantAmount,\n        NotionalProxy notionalProxy_\n    ) public initializer {\n        require(initialGrantAmount.length == initialAccounts.length);\n\n        notionalProxy = notionalProxy_;\n        uint96 totalGrants;\n        for (uint256 i; i < initialGrantAmount.length; i++) {\n            totalGrants = _add96(totalGrants, initialGrantAmount[i], \"\");\n            balances[initialAccounts[i]] = initialGrantAmount[i];\n\n            emit Transfer(address(0), initialAccounts[i], initialGrantAmount[i]);\n        }\n\n        require(totalGrants == totalSupply);\n    }\n\n    /// @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\n    /// @param account The address of the account holding the funds\n    /// @param spender The address of the account spending the funds\n    /// @return The number of tokens approved\n    function allowance(address account, address spender) external view returns (uint256) {\n        return allowances[account][spender];\n    }\n\n    /// @notice Approve `spender` to transfer up to `amount` from `src`\n    /// @dev This will overwrite the approval amount for `spender`\n    ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n    ///  emit:Approval\n    /// @param spender The address of the account which may transfer tokens\n    /// @param rawAmount The number of tokens that are approved (2^256-1 means infinite)\n    /// @return Whether or not the approval succeeded\n    function approve(address spender, uint256 rawAmount) external returns (bool) {\n        uint96 amount;\n        if (rawAmount == uint256(-1)) {\n            amount = uint96(-1);\n        } else {\n            amount = _safe96(rawAmount, \"Note::approve: amount exceeds 96 bits\");\n        }\n\n        allowances[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    /// @notice Get the number of tokens held by the `account`\n    /// @param account The address of the account to get the balance of\n    /// @return The number of tokens held\n    function balanceOf(address account) external view returns (uint256) {\n        return balances[account];\n    }\n\n    /// @notice Transfer `amount` tokens from `msg.sender` to `dst`\n    /// @dev emit:Transfer\n    /// @param dst The address of the destination account\n    /// @param rawAmount The number of tokens to transfer\n    /// @return Whether or not the transfer succeeded\n    function transfer(address dst, uint256 rawAmount) external returns (bool) {\n        uint96 amount = _safe96(rawAmount, \"Note::transfer: amount exceeds 96 bits\");\n        _transferTokens(msg.sender, dst, amount);\n        return true;\n    }\n\n    /// @notice Transfer `amount` tokens from `src` to `dst`\n    /// @dev emit:Transfer emit:Approval\n    /// @param src The address of the source account\n    /// @param dst The address of the destination account\n    /// @param rawAmount The number of tokens to transfer\n    /// @return Whether or not the transfer succeeded\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 rawAmount\n    ) external returns (bool) {\n        address spender = msg.sender;\n        uint96 spenderAllowance = allowances[src][spender];\n        uint96 amount = _safe96(rawAmount, \"Note::approve: amount exceeds 96 bits\");\n\n        if (spender != src && spenderAllowance != uint96(-1)) {\n            uint96 newAllowance =\n                _sub96(\n                    spenderAllowance,\n                    amount,\n                    \"Note::transferFrom: transfer amount exceeds spender allowance\"\n                );\n            allowances[src][spender] = newAllowance;\n\n            emit Approval(src, spender, newAllowance);\n        }\n\n        _transferTokens(src, dst, amount);\n        return true;\n    }\n\n    /// @notice Delegate votes from `msg.sender` to `delegatee`\n    /// @param delegatee The address to delegate votes to\n    /// @dev emit:DelegatesChanged\n    function delegate(address delegatee) public {\n        return _delegate(msg.sender, delegatee);\n    }\n\n    /// @notice Delegates votes from signatory to `delegatee`\n    /// @dev emit:DelegatesChanged\n    /// @param delegatee The address to delegate votes to\n    /// @param nonce The contract state required to match the signature\n    /// @param expiry The time at which to expire the signature\n    /// @param v The recovery byte of the signature\n    /// @param r Half of the ECDSA signature pair\n    /// @param s Half of the ECDSA signature pair\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        bytes32 domainSeparator =\n            keccak256(\n                abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), _getChainId(), address(this))\n            );\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \"Note::delegateBySig: invalid signature\");\n        require(nonce == nonces[signatory]++, \"Note::delegateBySig: invalid nonce\");\n        require(block.timestamp <= expiry, \"Note::delegateBySig: signature expired\");\n        return _delegate(signatory, delegatee);\n    }\n\n    /// @notice Gets the current votes balance for `account`\n    /// @param account The address to get votes balance\n    /// @return The number of current votes for `account`\n    function getCurrentVotes(address account) external view returns (uint96) {\n        uint32 nCheckpoints = numCheckpoints[account];\n        uint96 currentVotes = nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n        return\n            _add96(\n                currentVotes,\n                getUnclaimedVotes(account),\n                \"Note::getCurrentVotes: uint96 overflow\"\n            );\n    }\n\n    /// @notice Determine the prior number of votes for an account as of a block number\n    /// @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n    /// @param account The address of the account to check\n    /// @param blockNumber The block number to get the vote balance at\n    /// @return The number of votes the account had as of the given block\n    function getPriorVotes(address account, uint256 blockNumber) public view returns (uint96) {\n        require(blockNumber < block.number, \"Note::getPriorVotes: not yet determined\");\n\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[account][nCheckpoints - 1].votes;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].fromBlock > blockNumber) {\n            return 0;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) {"
    }
  ]
}