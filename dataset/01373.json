{
  "Title": "M-3: Position value can fall below minimum acceptable quote value when partially closing positions requested to be closed in full",
  "Content": "# Issue M-3: Position value can fall below minimum acceptable quote value when partially closing positions requested to be closed in full \n\nSource: https://github.com/sherlock-audit/2023-08-symmetrical-judging/issues/12 \n\n## Found by \npanprog\n\nThis is [issue 248](https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/248) from previous audit contest, which was fixed incorrectly.\nWhen PartyA requests to close LIMIT position in full, but partyB closes it partially, the remaining open quote can be below `minAcceptableQuoteValue`, breaking important protocol invariant, which can cause different problems, such as not enough incentive to liquidate dust positions.\n\n## Vulnerability Detail\n\nIn `LibQuote.closeQuote` there is a requirement to have the remaining quote value to not be less than `minAcceptableQuoteValue`:\n```solidity\nif (LibQuote.quoteOpenAmount(quote) != quote.quantityToClose) {\n    require(quote.lockedValues.total() >= symbolLayout.symbols[quote.symbolId].minAcceptableQuoteValue,\n        \"LibQuote: Remaining quote value is low\");\n}\n```\n\nNotice the condition when this require happens:\n- `LibQuote.quoteOpenAmount(quote)` is remaining open amount\n- `quote.quantityToClose` is requested amount to close\n\nThis means that this check is ignored if partyA has requested to close amount equal to full remaining quote value, but enforced when it's not (even if closing fully). For example, a quote with opened amount = 100 is requested to be closed in full (amount = 100): this check is ignored. But PartyB can fill the request partially, for example fill 99 out of 100, and the remainder (1) is not checked to confirm to `minAcceptableQuoteValue`.\n\nThe following execution paths are possible if PartyA has open position size = 100 and `minAcceptableQuoteValue` = 5:\n- `requestToClosePosition(99)` -> revert\n- `requestToClosePosition(100)` -> `fillCloseRequest(99)` -> pass (remaining quote = 1)\n\n## Impact\n\nThere can be multiple reasons why the protocol enforces `minAcceptableQuoteValue`, one of them might be the efficiency of the liquidation mechanism: when quote value is too small (and liquidation value too small too), liquidators will not have enough incentive to liquidate these positions in case they become insolvent. Both partyA and partyB might also not have enough incentive to close or respond to request to close such small positions, possibly resulting in a loss of funds and greater market risk for either user.\n\n## Proof of Concept\n\nAdd this to any test, for example to `ClosePosition.behavior.ts`.\n\n```solidity\nit(\"Close position with remainder below minAcceptableQuoteValue\", async function () {\n  const context: RunContext = this.context;\n\n  this.user_allocated = decimal(1000);\n  this.hedger_allocated = decimal(1000);\n\n  this.user = new User(this.context, this.context.signers.user);\n  await this.user.setup();\n  await this.user.setBalances(this.user_allocated, this.user_allocated, this.user_allocated);\n\n  this.hedger = new Hedger(this.context, this.context.signers.hedger);\n  await this.hedger.setup();\n  await this.hedger.setBalances(this.hedger_allocated, this.hedger_allocated);\n\n  await this.user.sendQuote(limitQuoteRequestBuilder()\n    .quantity(decimal(100))\n    .price(decimal(1))\n    .cva(decimal(10)).lf(decimal(5)).mm(decimal(15))\n    .build()\n  );\n  await this.hedger.lockQuote(1, 0, decimal(5, 17));\n  await this.hedger.openPosition(1, limitOpenRequestBuilder().filledAmount(decimal(100)).openPrice(decimal(1)).price(decimal(1)).build());\n\n  // now try to close full position (100)\n  await this.user.requestToClosePosition(\n    1,\n    limitCloseRequestBuilder().quantityToClose(decimal(100)).closePrice(decimal(1)).build(),\n  );\n\n  // now partyA cancels request\n  //await this.user.requestToCancelCloseRequest(1);\n\n  // partyB can fill 99\n  await this.hedger.fillCloseRequest(\n    1,\n    limitFillCloseRequestBuilder()\n      .filledAmount(decimal(99))\n      .closedPrice(decimal(1))\n      .build(),\n  );\n\n  var q = await context.viewFacet.getQuote(1);\n  console.log(\"quote quantity: \" + q.quantity.div(decimal(1)) + \" closed: \" + q.closedAmount.div(decimal(1)));\n\n});\n```\n\nConsole execution result:\n```js\nquote quantity: 100 closed: 99\n```\n\n## Code Snippet\n\nNotice the condition to perform the `minAcceptableQuoteValue` check:\nhttps://github.com/sherlock-audit/2023-08-symmetrical/blob/main/symmio-core/contracts/libraries/LibQuote.sol#L155-L158\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe condition should be to ignore the `minAcceptableQuoteValue` if request is filled in full (filledAmount == quantityToClose):\n```solidity\n-       if (LibQuote.quoteOpenAmount(quote) != quote.quantityToClose) {\n+       if (filledAmount != quote.quantityToClose) {\n            require(quote.lockedValues.total() >= symbolLayout.symbols[quote.symbolId].minAcceptableQuoteValue,\n                \"LibQuote: Remaining quote value is low\");\n        }\n```\n\n\n\n## Discussion\n\n**MoonKnightDev**\n\nFixed Code PR: https://github.com/SYMM-IO/symmio-core/pull/31\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/108",
  "Code": [
    {
      "filename": "symmio-core/contracts/libraries/LibQuote.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"./LibLockedValues.sol\";\nimport \"../storages/QuoteStorage.sol\";\nimport \"../storages/AccountStorage.sol\";\nimport \"../storages/GlobalAppStorage.sol\";\nimport \"../storages/SymbolStorage.sol\";\nimport \"../storages/MAStorage.sol\";\n\nlibrary LibQuote {\n    using LockedValuesOps for LockedValues;\n\n    function getAmountToLockOfQuote(Quote storage quote) internal view returns (uint256) {\n        return quote.lockedValues.total();\n    }\n\n    function quoteOpenAmount(Quote storage quote) internal view returns (uint256) {\n        return quote.quantity - quote.closedAmount;\n    }\n\n    function getIndexOfItem(\n        uint256[] storage array_,\n        uint256 item\n    ) internal view returns (uint256) {\n        for (uint256 index = 0; index < array_.length; index++) {\n            if (array_[index] == item) return index;\n        }\n        return type(uint256).max;\n    }\n\n    function removeFromArray(uint256[] storage array_, uint256 item) internal {\n        uint256 index = getIndexOfItem(array_, item);\n        require(index != type(uint256).max, \"LibQuote: Item not Found\");\n        array_[index] = array_[array_.length - 1];\n        array_.pop();\n    }\n\n    function removeFromPartyAPendingQuotes(Quote storage quote) internal {\n        removeFromArray(QuoteStorage.layout().partyAPendingQuotes[quote.partyA], quote.id);\n    }\n\n    function removeFromPartyBPendingQuotes(Quote storage quote) internal {\n        removeFromArray(\n            QuoteStorage.layout().partyBPendingQuotes[quote.partyB][quote.partyA],\n            quote.id\n        );\n    }\n\n    function removeFromPendingQuotes(Quote storage quote) internal {\n        removeFromPartyAPendingQuotes(quote);\n        removeFromPartyBPendingQuotes(quote);\n    }\n\n    function addToOpenPositions(uint256 quoteId) internal {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        Quote storage quote = quoteLayout.quotes[quoteId];\n\n        quoteLayout.partyAOpenPositions[quote.partyA].push(quote.id);\n        quoteLayout.partyBOpenPositions[quote.partyB][quote.partyA].push(quote.id);\n\n        quoteLayout.partyAPositionsIndex[quote.id] = quoteLayout.partyAPositionsCount[quote.partyA];\n        quoteLayout.partyBPositionsIndex[quote.id] = quoteLayout.partyBPositionsCount[quote.partyB][\n                        quote.partyA\n            ];\n\n        quoteLayout.partyAPositionsCount[quote.partyA] += 1;\n        quoteLayout.partyBPositionsCount[quote.partyB][quote.partyA] += 1;\n    }\n\n    function removeFromOpenPositions(uint256 quoteId) internal {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        Quote storage quote = quoteLayout.quotes[quoteId];\n        uint256 indexOfPartyAPosition = quoteLayout.partyAPositionsIndex[quote.id];\n        uint256 indexOfPartyBPosition = quoteLayout.partyBPositionsIndex[quote.id];\n        uint256 lastOpenPositionIndex = quoteLayout.partyAPositionsCount[quote.partyA] - 1;\n        quoteLayout.partyAOpenPositions[quote.partyA][indexOfPartyAPosition] = quoteLayout\n            .partyAOpenPositions[quote.partyA][lastOpenPositionIndex];\n        quoteLayout.partyAPositionsIndex[\n        quoteLayout.partyAOpenPositions[quote.partyA][lastOpenPositionIndex]\n        ] = indexOfPartyAPosition;\n        quoteLayout.partyAOpenPositions[quote.partyA].pop();\n\n        lastOpenPositionIndex = quoteLayout.partyBPositionsCount[quote.partyB][quote.partyA] - 1;\n        quoteLayout.partyBOpenPositions[quote.partyB][quote.partyA][\n        indexOfPartyBPosition\n        ] = quoteLayout.partyBOpenPositions[quote.partyB][quote.partyA][lastOpenPositionIndex];\n        quoteLayout.partyBPositionsIndex[\n        quoteLayout.partyBOpenPositions[quote.partyB][quote.partyA][lastOpenPositionIndex]\n        ] = indexOfPartyBPosition;\n        quoteLayout.partyBOpenPositions[quote.partyB][quote.partyA].pop();\n\n        quoteLayout.partyAPositionsIndex[quote.id] = 0;\n        quoteLayout.partyBPositionsIndex[quote.id] = 0;\n    }\n\n    function getValueOfQuoteForPartyA(\n        uint256 currentPrice,\n        uint256 filledAmount,\n        Quote storage quote\n    ) internal view returns (bool hasMadeProfit, uint256 pnl) {\n        if (currentPrice > quote.openedPrice) {\n            if (quote.positionType == PositionType.LONG) {\n                hasMadeProfit = true;\n            } else {\n                hasMadeProfit = false;\n            }\n            pnl = ((currentPrice - quote.openedPrice) * filledAmount) / 1e18;\n        } else {\n            if (quote.positionType == PositionType.LONG) {\n                hasMadeProfit = false;\n            } else {\n                hasMadeProfit = true;\n            }\n            pnl = ((quote.openedPrice - currentPrice) * filledAmount) / 1e18;\n        }\n    }\n\n    function getTradingFee(uint256 quoteId) internal view returns (uint256 fee) {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        Quote storage quote = quoteLayout.quotes[quoteId];\n        if (quote.orderType == OrderType.LIMIT) {\n            fee =\n                (LibQuote.quoteOpenAmount(quote) * quote.requestedOpenPrice * quote.tradingFee) /\n                1e36;\n        } else {\n            fee = (LibQuote.quoteOpenAmount(quote) * quote.marketPrice * quote.tradingFee) / 1e36;\n        }\n    }\n\n    function closeQuote(Quote storage quote, uint256 filledAmount, uint256 closedPrice) internal {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        SymbolStorage.Layout storage symbolLayout = SymbolStorage.layout();\n        require(quote.lockedValues.cva * filledAmount / LibQuote.quoteOpenAmount(quote) > 0, \"LibQuote: Low filled amount\");\n        require(quote.lockedValues.mm * filledAmount / LibQuote.quoteOpenAmount(quote) > 0, \"LibQuote: Low filled amount\");\n        require(quote.lockedValues.lf * filledAmount / LibQuote.quoteOpenAmount(quote) > 0, \"LibQuote: Low filled amount\");\n        LockedValues memory lockedValues = LockedValues(\n            quote.lockedValues.cva -\n            ((quote.lockedValues.cva * filledAmount) / (LibQuote.quoteOpenAmount(quote))),\n            quote.lockedValues.mm -\n            ((quote.lockedValues.mm * filledAmount) / (LibQuote.quoteOpenAmount(quote))),\n            quote.lockedValues.lf -\n            ((quote.lockedValues.lf * filledAmount) / (LibQuote.quoteOpenAmount(quote)))\n        );\n        accountLayout.lockedBalances[quote.partyA].subQuote(quote).add(lockedValues);\n        accountLayout.partyBLockedBalances[quote.partyB][quote.partyA].subQuote(quote).add(\n            lockedValues\n        );\n        quote.lockedValues = lockedValues;\n\n        if (LibQuote.quoteOpenAmount(quote) != quote.quantityToClose) {\n            require(quote.lockedValues.total() >= symbolLayout.symbols[quote.symbolId].minAcceptableQuoteValue,\n                \"LibQuote: Remaining quote value is low\");\n        }\n\n        (bool hasMadeProfit, uint256 pnl) = LibQuote.getValueOfQuoteForPartyA(\n            closedPrice,\n            filledAmount,\n            quote\n        );\n        if (hasMadeProfit) {\n            accountLayout.allocatedBalances[quote.partyA] += pnl;\n            accountLayout.partyBAllocatedBalances[quote.partyB][quote.partyA] -= pnl;\n        } else {\n            accountLayout.allocatedBalances[quote.partyA] -= pnl;\n            accountLayout.partyBAllocatedBalances[quote.partyB][quote.partyA] += pnl;\n        }\n\n        quote.avgClosedPrice =\n            (quote.avgClosedPrice * quote.closedAmount + filledAmount * closedPrice) /\n            (quote.closedAmount + filledAmount);\n\n        quote.closedAmount += filledAmount;\n        quote.quantityToClose -= filledAmount;\n\n        if (quote.closedAmount == quote.quantity) {\n            quote.statusModifyTimestamp = block.timestamp;\n            quote.quoteStatus = QuoteStatus.CLOSED;\n            quote.requestedClosePrice = 0;\n            removeFromOpenPositions(quote.id);\n            quoteLayout.partyAPositionsCount[quote.partyA] -= 1;\n            quoteLayout.partyBPositionsCount[quote.partyB][quote.partyA] -= 1;\n        } else if (\n            quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING || quote.quantityToClose == 0\n        ) {\n            quote.quoteStatus = QuoteStatus.OPENED;\n            quote.statusModifyTimestamp = block.timestamp;\n            quote.requestedClosePrice = 0;\n            quote.quantityToClose = 0; // for CANCEL_CLOSE_PENDING status\n        }\n    }\n\n    function expireQuote(uint256 quoteId) internal returns (QuoteStatus result) {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        Quote storage quote = quoteLayout.quotes[quoteId];\n        require(block.timestamp > quote.deadline, \"LibQuote: Quote isn't expired\");\n        require(\n            quote.quoteStatus == QuoteStatus.PENDING ||\n            quote.quoteStatus == QuoteStatus.CANCEL_PENDING ||\n            quote.quoteStatus == QuoteStatus.LOCKED ||\n            quote.quoteStatus == QuoteStatus.CLOSE_PENDING ||\n            quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING,\n            \"LibQuote: Invalid state\"\n        );\n        require(\n            !MAStorage.layout().liquidationStatus[quote.partyA],\n            \"LibQuote: PartyA isn't solvent\"\n        );\n        require(\n            !MAStorage.layout().partyBLiquidationStatus[quote.partyB][quote.partyA],\n            \"LibQuote: PartyB isn't solvent\"\n        );\n        if (\n            quote.quoteStatus == QuoteStatus.PENDING ||\n            quote.quoteStatus == QuoteStatus.LOCKED ||\n            quote.quoteStatus == QuoteStatus.CANCEL_PENDING\n        ) {\n            quote.statusModifyTimestamp = block.timestamp;\n            accountLayout.pendingLockedBalances[quote.partyA].subQuote(quote);\n            // send trading Fee back to partyA\n            accountLayout.allocatedBalances[quote.partyA] += LibQuote.getTradingFee(quote.id);\n            removeFromPartyAPendingQuotes(quote);\n            if (\n                quote.quoteStatus == QuoteStatus.LOCKED ||\n                quote.quoteStatus == QuoteStatus.CANCEL_PENDING\n            ) {\n                accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].subQuote(\n                    quote\n                );\n                removeFromPartyBPendingQuotes(quote);\n            }\n            quote.quoteStatus = QuoteStatus.EXPIRED;\n            result = QuoteStatus.EXPIRED;\n        } else if (\n            quote.quoteStatus == QuoteStatus.CLOSE_PENDING ||\n            quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING\n        ) {\n            quote.statusModifyTimestamp = block.timestamp;\n            quote.requestedClosePrice = 0;\n            quote.quantityToClose = 0;\n            quote.quoteStatus = QuoteStatus.OPENED;\n            result = QuoteStatus.OPENED;\n        }\n    }\n}"
    }
  ]
}