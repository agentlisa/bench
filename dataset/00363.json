{
  "Title": "`Chainlink` oracle returns stale price due to `CHAINLINK_TIMEOUT` variable in `LibChainlinkOracle` being set to 4 hours",
  "Content": "# `Chainlink` oracle returns stale price due to `CHAINLINK_TIMEOUT` variable in `LibChainlinkOracle` being set to 4 hours\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2024-02-Beanstalk-1/blob/a3658861af8f5126224718af494d02352fbb3ea5/protocol/contracts/libraries/Oracle/LibChainlinkOracle.sol#L22\">https://github.com/Cyfrin/2024-02-Beanstalk-1/blob/a3658861af8f5126224718af494d02352fbb3ea5/protocol/contracts/libraries/Oracle/LibChainlinkOracle.sol#L22</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2024-02-Beanstalk-1/blob/a3658861af8f5126224718af494d02352fbb3ea5/protocol/contracts/libraries/Oracle/LibChainlinkOracle.sol#L138-L149\">https://github.com/Cyfrin/2024-02-Beanstalk-1/blob/a3658861af8f5126224718af494d02352fbb3ea5/protocol/contracts/libraries/Oracle/LibChainlinkOracle.sol#L138-L149</a>\n\n\n## Summary\n\nThe `LibChainlinkOracle` library utilizes a `CHAINLINK_TIMEOUT` constant set to `14400` seconds (4 hours). This duration is four times longer than the `Chainlink` heartbeat that is `3600` seconds (1 hour), potentially introducing a significant delay in recognizing stale or outdated price data.\n\n## Vulnerability Details\n\nThe `LibChainlinkOracle::checkForInvalidTimestampOrAnswer` function accepts three input arguments: `timestamp`, `answer` and `currentTimestamp` and check if the return answer from `Chainlinlink Oracle` or the timestamp is invalid:\n\n```javascript\n\n    function checkForInvalidTimestampOrAnswer(\n        uint256 timestamp,\n        int256 answer,\n        uint256 currentTimestamp\n    ) private pure returns (bool) {\n        // Check for an invalid timeStamp that is 0, or in the future\n        if (timestamp == 0 || timestamp > currentTimestamp) return true;\n        // Check if Chainlink's price feed has timed out\n        if (currentTimestamp.sub(timestamp) > CHAINLINK_TIMEOUT) return true;\n        // Check for non-positive price\n        if (answer <= 0) return true;\n    }\n\n```\n\nThe function also checks if the difference between the `currentTimestamp` and the `timestamp` is greater then `CHAINLINK_TIMEOUT`. The `CHAINLINK_TIMEOUT` is defined to be `4 hours`:\n\n```javascript\n\n uint256 public constant CHAINLINK_TIMEOUT = 14400; // 4 hours: 60 * 60 * 4\n\n```\n\n## Impact\n\nThe `Chainlink` heartbeat indicates the expected frequency of updates from the oracle. The `Chainlink` heartbeat on Ethereum for `Eth/Usd` is `3600` seconds (1 hour).\n\nhttps://docs.chain.link/data-feeds/price-feeds/addresses?network=ethereum&page=1&search=0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419\n\nBut the defined `CHAINLINK_TIMEOUT` in the `LibChainlinkOracle` is `14400` seconds (4 hours).\n\nA `CHAINLINK_TIMEOUT` that is significantly longer than the heartbeat can lead to scenarios where the `LibChainlinkOracle` library accepts data that may no longer reflect current market conditions. Also, in volatile markets, a 4-hour window leads to accepting outdated prices, increasing the risk of price slippage.\n\n## Tools Used\n\nManual Review\n\n## Recommendations\n\nConsider reducing the `CHAINLINK_TIMEOUT` to align more closely with the `Chainlink` heartbeat on Ethereum, enhancing the relevance of the price data.",
  "Impact": "MEDIUM",
  "Source": "https://www.codehawks.com/contests/clsxlpte900074r5et7x6kh96",
  "Code": [
    {
      "filename": "protocol/contracts/libraries/Oracle/LibChainlinkOracle.sol",
      "content": "/**\n * SPDX-License-Identifier: MIT\n **/\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {C} from \"contracts/C.sol\";\nimport {IChainlinkAggregator} from \"contracts/interfaces/chainlink/IChainlinkAggregator.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n/**\n * @title Chainlink Oracle Library\n * @notice Contains functionalty to fetch prices from Chainlink price feeds.\n * @dev currently supports:\n * - ETH/USD price feed\n **/\nlibrary LibChainlinkOracle {\n    using SafeMath for uint256;\n\n    // Uses the same timeout as Liquity's Chainlink timeout.\n    uint256 public constant CHAINLINK_TIMEOUT = 14400; // 4 hours: 60 * 60 * 4\n\n    IChainlinkAggregator constant priceAggregator =\n        IChainlinkAggregator(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\n    uint256 constant PRECISION = 1e6; // use 6 decimal precision.\n\n    /**\n     * @dev Returns the most recently reported ETH/USD price from the Chainlink Oracle.\n     * Return value has 6 decimal precision.\n     * Returns 0 if Chainlink's price feed is broken or frozen.\n     **/\n    function getEthUsdPrice() internal view returns (uint256 price) {\n        // First, try to get current decimal precision:\n        uint8 decimals;\n        try priceAggregator.decimals() returns (uint8 _decimals) {\n            // If call to Chainlink succeeds, record the current decimal precision\n            decimals = _decimals;\n        } catch {\n            // If call to Chainlink aggregator reverts, return a price of 0 indicating failure\n            return 0;\n        }\n\n        // Secondly, try to get latest price data:\n        try priceAggregator.latestRoundData() returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 /* startedAt */,\n            uint256 timestamp,\n            uint80 /* answeredInRound */\n        ) {\n            // Check for an invalid roundId that is 0\n            if (roundId == 0) return 0;\n            if (checkForInvalidTimestampOrAnswer(timestamp, answer, block.timestamp)) {\n                return 0;\n            }\n            // Adjust to 6 decimal precision.\n            return uint256(answer).mul(PRECISION).div(10 ** decimals);\n        } catch {\n            // If call to Chainlink aggregator reverts, return a price of 0 indicating failure\n            return 0;\n        }\n    }\n\n    /**\n     * @dev Returns the TWAP ETH/USD price from the Chainlink Oracle over the past `lookback` seconds.\n     * Return value has 6 decimal precision.\n     * Returns 0 if Chainlink's price feed is broken or frozen.\n     **/\n    function getEthUsdTwap(uint256 lookback) internal view returns (uint256 price) {\n        // First, try to get current decimal precision:\n        uint8 decimals;\n        try priceAggregator.decimals() returns (uint8 _decimals) {\n            // If call to Chainlink succeeds, record the current decimal precision\n            decimals = _decimals;\n        } catch {\n            // If call to Chainlink aggregator reverts, return a price of 0 indicating failure\n            return 0;\n        }\n\n        // Secondly, try to get latest price data:\n        try priceAggregator.latestRoundData() returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 /* startedAt */,\n            uint256 timestamp,\n            uint80 /* answeredInRound */\n        ) {\n            // Check for an invalid roundId that is 0\n            if (roundId == 0) return 0;\n            if (checkForInvalidTimestampOrAnswer(timestamp, answer, block.timestamp)) {\n                return 0;\n            }\n\n            uint256 endTimestamp = block.timestamp.sub(lookback);\n            // Check if last round was more than `lookback` ago.\n            if (timestamp <= endTimestamp) {\n                return uint256(answer).mul(PRECISION).div(10 ** decimals);\n            } else {\n                uint256 cumulativePrice;\n                uint256 lastTimestamp = block.timestamp;\n                // Loop through previous rounds and compute cumulative sum until\n                // a round at least `lookback` seconds ago is reached.\n                while (timestamp > endTimestamp) {\n                    cumulativePrice = cumulativePrice.add(\n                        uint256(answer).mul(lastTimestamp.sub(timestamp))\n                    );\n                    roundId -= 1;\n                    try priceAggregator.getRoundData(roundId) returns (\n                        uint80 /* roundId */,\n                        int256 _answer,\n                        uint256 /* startedAt */,\n                        uint256 _timestamp,\n                        uint80 /* answeredInRound */\n                    ) {\n                        if (checkForInvalidTimestampOrAnswer(_timestamp, _answer, timestamp)) {\n                            return 0;\n                        }\n                        lastTimestamp = timestamp;\n                        timestamp = _timestamp;\n                        answer = _answer;\n                    } catch {\n                        // If call to Chainlink aggregator reverts, return a price of 0 indicating failure\n                        return 0;\n                    }\n                }\n                cumulativePrice = cumulativePrice.add(\n                    uint256(answer).mul(lastTimestamp.sub(endTimestamp))\n                );\n                return cumulativePrice.mul(PRECISION).div(10 ** decimals).div(lookback);\n            }\n        } catch {\n            // If call to Chainlink aggregator reverts, return a price of 0 indicating failure\n            return 0;\n        }\n    }\n\n    function checkForInvalidTimestampOrAnswer(\n        uint256 timestamp,\n        int256 answer,\n        uint256 currentTimestamp\n    ) private pure returns (bool) {\n        // Check for an invalid timeStamp that is 0, or in the future\n        if (timestamp == 0 || timestamp > currentTimestamp) return true;\n        // Check if Chainlink's price feed has timed out\n        if (currentTimestamp.sub(timestamp) > CHAINLINK_TIMEOUT) return true;\n        // Check for non-positive price\n        if (answer <= 0) return true;\n    }\n}"
    },
    {
      "filename": "protocol/contracts/libraries/Oracle/LibChainlinkOracle.sol",
      "content": "/**\n * SPDX-License-Identifier: MIT\n **/\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {C} from \"contracts/C.sol\";\nimport {IChainlinkAggregator} from \"contracts/interfaces/chainlink/IChainlinkAggregator.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n/**\n * @title Chainlink Oracle Library\n * @notice Contains functionalty to fetch prices from Chainlink price feeds.\n * @dev currently supports:\n * - ETH/USD price feed\n **/\nlibrary LibChainlinkOracle {\n    using SafeMath for uint256;\n\n    // Uses the same timeout as Liquity's Chainlink timeout.\n    uint256 public constant CHAINLINK_TIMEOUT = 14400; // 4 hours: 60 * 60 * 4\n\n    IChainlinkAggregator constant priceAggregator =\n        IChainlinkAggregator(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\n    uint256 constant PRECISION = 1e6; // use 6 decimal precision.\n\n    /**\n     * @dev Returns the most recently reported ETH/USD price from the Chainlink Oracle.\n     * Return value has 6 decimal precision.\n     * Returns 0 if Chainlink's price feed is broken or frozen.\n     **/\n    function getEthUsdPrice() internal view returns (uint256 price) {\n        // First, try to get current decimal precision:\n        uint8 decimals;\n        try priceAggregator.decimals() returns (uint8 _decimals) {\n            // If call to Chainlink succeeds, record the current decimal precision\n            decimals = _decimals;\n        } catch {\n            // If call to Chainlink aggregator reverts, return a price of 0 indicating failure\n            return 0;\n        }\n\n        // Secondly, try to get latest price data:\n        try priceAggregator.latestRoundData() returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 /* startedAt */,\n            uint256 timestamp,\n            uint80 /* answeredInRound */\n        ) {\n            // Check for an invalid roundId that is 0\n            if (roundId == 0) return 0;\n            if (checkForInvalidTimestampOrAnswer(timestamp, answer, block.timestamp)) {\n                return 0;\n            }\n            // Adjust to 6 decimal precision.\n            return uint256(answer).mul(PRECISION).div(10 ** decimals);\n        } catch {\n            // If call to Chainlink aggregator reverts, return a price of 0 indicating failure\n            return 0;\n        }\n    }\n\n    /**\n     * @dev Returns the TWAP ETH/USD price from the Chainlink Oracle over the past `lookback` seconds.\n     * Return value has 6 decimal precision.\n     * Returns 0 if Chainlink's price feed is broken or frozen.\n     **/\n    function getEthUsdTwap(uint256 lookback) internal view returns (uint256 price) {\n        // First, try to get current decimal precision:\n        uint8 decimals;\n        try priceAggregator.decimals() returns (uint8 _decimals) {\n            // If call to Chainlink succeeds, record the current decimal precision\n            decimals = _decimals;\n        } catch {\n            // If call to Chainlink aggregator reverts, return a price of 0 indicating failure\n            return 0;\n        }\n\n        // Secondly, try to get latest price data:\n        try priceAggregator.latestRoundData() returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 /* startedAt */,\n            uint256 timestamp,\n            uint80 /* answeredInRound */\n        ) {\n            // Check for an invalid roundId that is 0\n            if (roundId == 0) return 0;\n            if (checkForInvalidTimestampOrAnswer(timestamp, answer, block.timestamp)) {\n                return 0;\n            }\n\n            uint256 endTimestamp = block.timestamp.sub(lookback);\n            // Check if last round was more than `lookback` ago.\n            if (timestamp <= endTimestamp) {\n                return uint256(answer).mul(PRECISION).div(10 ** decimals);\n            } else {\n                uint256 cumulativePrice;\n                uint256 lastTimestamp = block.timestamp;\n                // Loop through previous rounds and compute cumulative sum until\n                // a round at least `lookback` seconds ago is reached.\n                while (timestamp > endTimestamp) {\n                    cumulativePrice = cumulativePrice.add(\n                        uint256(answer).mul(lastTimestamp.sub(timestamp))\n                    );\n                    roundId -= 1;\n                    try priceAggregator.getRoundData(roundId) returns (\n                        uint80 /* roundId */,\n                        int256 _answer,\n                        uint256 /* startedAt */,\n                        uint256 _timestamp,\n                        uint80 /* answeredInRound */\n                    ) {\n                        if (checkForInvalidTimestampOrAnswer(_timestamp, _answer, timestamp)) {\n                            return 0;\n                        }\n                        lastTimestamp = timestamp;\n                        timestamp = _timestamp;\n                        answer = _answer;\n                    } catch {\n                        // If call to Chainlink aggregator reverts, return a price of 0 indicating failure\n                        return 0;\n                    }\n                }\n                cumulativePrice = cumulativePrice.add(\n                    uint256(answer).mul(lastTimestamp.sub(endTimestamp))\n                );\n                return cumulativePrice.mul(PRECISION).div(10 ** decimals).div(lookback);\n            }\n        } catch {\n            // If call to Chainlink aggregator reverts, return a price of 0 indicating failure\n            return 0;\n        }\n    }\n\n    function checkForInvalidTimestampOrAnswer(\n        uint256 timestamp,\n        int256 answer,\n        uint256 currentTimestamp\n    ) private pure returns (bool) {\n        // Check for an invalid timeStamp that is 0, or in the future\n        if (timestamp == 0 || timestamp > currentTimestamp) return true;\n        // Check if Chainlink's price feed has timed out\n        if (currentTimestamp.sub(timestamp) > CHAINLINK_TIMEOUT) return true;\n        // Check for non-positive price\n        if (answer <= 0) return true;\n    }\n}"
    }
  ]
}