{
  "Title": "[G-08] `RankedBattle._addResultPoints()` can put code inside an existing conditional statement to avoid incrementing storage variables by zero",
  "Content": "\n### Links\n\nhttps://github.com/code-423n4/2024-02-ai-arena/blob/main/src/RankedBattle.sol#L466-L471\n\n### Description\n\nSee the following code from the `RankedBattle._addResultPoints()` below. The `points` variable can be zero, such as if the player's `mergingFactor` is 100. The lines updating storage variables with `points` should be put inside the `if` block.\n\n```solidity\n            accumulatedPointsPerFighter[tokenId][roundId] += points;\n            accumulatedPointsPerAddress[fighterOwner][roundId] += points;\n            totalAccumulatedPoints[roundId] += points;\n            if (points > 0) {\n                emit PointsChanged(tokenId, points, true);\n            }\n```\n\n### Recommended Fix\n\n```diff\n-           accumulatedPointsPerFighter[tokenId][roundId] += points;\n-           accumulatedPointsPerAddress[fighterOwner][roundId] += points;\n-           totalAccumulatedPoints[roundId] += points;\n            if (points > 0) {\n+               accumulatedPointsPerFighter[tokenId][roundId] += points;\n+               accumulatedPointsPerAddress[fighterOwner][roundId] += points;\n+               totalAccumulatedPoints[roundId] += points;\n                emit PointsChanged(tokenId, points, true);\n            }\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2024-02-ai-arena",
  "Code": [
    {
      "filename": "src/RankedBattle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport { FighterFarm } from \"./FighterFarm.sol\";\nimport { VoltageManager } from \"./VoltageManager.sol\";\nimport { MergingPool } from \"./MergingPool.sol\";\nimport { Neuron } from \"./Neuron.sol\";\nimport { StakeAtRisk } from \"./StakeAtRisk.sol\";\nimport { FixedPointMathLib } from './FixedPointMathLib.sol';\n\n/// @title RankedBattle\n/// @author ArenaX Labs Inc.\n/// @notice This contract provides functionality for staking NRN tokens on fighters, \n/// tracking battle records, calculating and distributing rewards based on battle outcomes \n/// and staked amounts, and allowing claiming of accumulated rewards.\ncontract RankedBattle {\n\n    /// @dev Extend functionality of the FixedPointMathLib library to the uint data type.\n    using FixedPointMathLib for uint;\n\n    /*//////////////////////////////////////////////////////////////\n                                EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Event emitted when staked.\n    event Staked(address from, uint256 amount);\n\n    /// @notice Event emitted when unstaked.\n    event Unstaked(address from, uint256 amount);\n\n    /// @notice Event emitted when claimed.\n    event Claimed(address claimer, uint256 amount);\n\n    /// @notice Event emitted when points are added or subtracted from a fighter.\n    event PointsChanged(uint256 tokenId, uint256 points, bool increased);    \n\n    /*//////////////////////////////////////////////////////////////\n                                STRUCTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Struct for battle record.\n    struct BattleRecord {\n        uint32 wins;\n        uint32 ties;\n        uint32 loses;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            STATE VARIABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Voltage cost per match initiated\n    uint8 public constant VOLTAGE_COST = 10;\n\n    /// @notice Number of total battles.\n    uint256 public totalBattles = 0;\n\n    /// @notice Number of overall staked amount.\n    uint256 public globalStakedAmount = 0;\n\n    /// @notice Current round number.\n    uint256 public roundId = 0;\n\n    /// @notice Amount of basis points that get taken away from a player's stake when they lose in \n    /// a point deficit.\n    uint256 public bpsLostPerLoss = 10;\n\n    /// The StakeAtRisk contract address.\n    address _stakeAtRiskAddress;\n\n    /// The address that has owner privileges (initially the contract deployer).\n    address _ownerAddress;\n\n    /// @notice The address in charge of updating battle records.\n    address _gameServerAddress;\n\n    /*//////////////////////////////////////////////////////////////\n                            CONTRACT INSTANCES\n    //////////////////////////////////////////////////////////////*/ \n\n    /// @notice The neuron contract instance.\n    Neuron _neuronInstance;\n\n    /// @notice The fighter farm contract instance.\n    FighterFarm _fighterFarmInstance;\n\n    /// @notice The voltage manager contract instance.\n    VoltageManager _voltageManagerInstance;\n\n    /// @notice The merging pool contract instance.\n    MergingPool _mergingPoolInstance;\n\n    /// @notice The stake at risk contract instance.\n    StakeAtRisk _stakeAtRiskInstance;\n\n    /*//////////////////////////////////////////////////////////////\n                                MAPPINGS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Maps addresses that are admins.\n    mapping(address => bool) public isAdmin;\n\n    /// @notice Mapping of token id to battle record struct.\n    mapping(uint256 => BattleRecord) public fighterBattleRecord;\n\n    /// @notice Mapping of address to the amount of NRNs they have claimed.\n    mapping(address => uint256) public amountClaimed;\n\n    /// @notice Maps the user address to the number of rounds they've claimed for\n    mapping(address => uint32) public numRoundsClaimed;\n\n    /// @notice Maps address to round ID to track accumulated points.\n    mapping(address => mapping(uint256 => uint256)) public accumulatedPointsPerAddress;\n\n    /// @notice Maps token ID to round ID to track accumulated points.\n    mapping(uint256 => mapping(uint256 => uint256)) public accumulatedPointsPerFighter;\n\n    /// @notice Maps round ID to total accumulated points.\n    mapping(uint256 => uint256) public totalAccumulatedPoints;\n\n    /// @notice Mapping of roundID to nrn distribution amount for a ranked period.\n    mapping(uint256 => uint256) public rankedNrnDistribution;\n\n    /// @notice Maps the token ID to the round ID and indicates whether it is Unstaked or not.\n    mapping(uint256 => mapping(uint256 => bool)) public hasUnstaked;\n\n    /// @notice Mapping of token id to staked amount.\n    mapping(uint256 => uint256) public amountStaked;\n\n    /// @notice Mapping of token id to staking factor.\n    mapping(uint256 => uint256) public stakingFactor;\n\n    /// @notice Indicates whether we have calculated the staking factor for a given round and token.\n    mapping(uint256 => mapping(uint256 => bool)) _calculatedStakingFactor;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Initializes the contract by setting various addresses and instantiating \n    /// contract instances. It also designates the owner address as an admin. \n    /// @param ownerAddress Address of contract deployer.\n    /// @param gameServerAddress The game server address.\n    /// @param fighterFarmAddress Address of the FighterFarm contract.\n    /// @param voltageManagerAddress Address of the VoltageManager contract.\n    constructor(\n      address ownerAddress, \n      address gameServerAddress,\n      address fighterFarmAddress,\n      address voltageManagerAddress\n    ) {\n        _ownerAddress = ownerAddress;\n        _gameServerAddress = gameServerAddress;\n        _fighterFarmInstance = FighterFarm(fighterFarmAddress);\n        _voltageManagerInstance = VoltageManager(voltageManagerAddress);\n        isAdmin[_ownerAddress] = true;\n        rankedNrnDistribution[0] = 5000 * 10**18;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Transfers ownership from one address to another.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param newOwnerAddress The address of the new owner\n    function transferOwnership(address newOwnerAddress) external {\n        require(msg.sender == _ownerAddress);\n        _ownerAddress = newOwnerAddress;\n    }\n\n    /// @notice Adjusts admin access for a user.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param adminAddress The address of the admin.\n    /// @param access Whether the address has admin access or not.\n    function adjustAdminAccess(address adminAddress, bool access) external {\n        require(msg.sender == _ownerAddress);\n        isAdmin[adminAddress] = access;\n    }  \n\n    /// @notice Sets the game server address.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param gameServerAddress The game server address.\n    function setGameServerAddress(address gameServerAddress) external {\n        require(msg.sender == _ownerAddress);\n        _gameServerAddress = gameServerAddress;\n    }\n\n    /// @notice Sets the Stake at Risk contract address and instantiates the contract.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param stakeAtRiskAddress The address of the Stake At Risk contract.\n    function setStakeAtRiskAddress(address stakeAtRiskAddress) external {\n        require(msg.sender == _ownerAddress);\n        _stakeAtRiskAddress = stakeAtRiskAddress;\n        _stakeAtRiskInstance = StakeAtRisk(_stakeAtRiskAddress);\n    }\n\n    /// @notice Instantiates the neuron contract.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param nrnAddress The address of the Neuron contract.\n    function instantiateNeuronContract(address nrnAddress) external {\n        require(msg.sender == _ownerAddress);\n        _neuronInstance = Neuron(nrnAddress);\n    }\n\n    /// @notice Instantiates the merging pool contract.\n    /// @dev Only the owner address is authorized to call this function.\n    /// @param mergingPoolAddress The address of the MergingPool contract.\n    function instantiateMergingPoolContract(address mergingPoolAddress) external {\n        require(msg.sender == _ownerAddress);\n        _mergingPoolInstance = MergingPool(mergingPoolAddress);\n    }\n\n    /// @notice Sets the ranked nrn distribution amount for the current round.\n    /// @dev Only admins are authorized to change the ranked NRN distribution.\n    /// @dev newDistribution is NOT denominated in wei. As such, it is multiplied by 10**18.\n    /// @param newDistribution The new distribution amount.\n    function setRankedNrnDistribution(uint256 newDistribution) external {\n        require(isAdmin[msg.sender]);\n        rankedNrnDistribution[roundId] = newDistribution * 10**18;\n    }\n\n    /// @notice Sets the basis points lost per ranked match lost while in a point deficit.\n    /// @dev Only admins are authorized to call this function.\n    /// @param bpsLostPerLoss_ The basis points lost per loss.\n    function setBpsLostPerLoss(uint256 bpsLostPerLoss_) external {\n        require(isAdmin[msg.sender]);\n        bpsLostPerLoss = bpsLostPerLoss_;\n    }\n\n    /// @notice Sets a new round, making claiming available for that round.\n    /// @dev Only admins are authorized to move the round forward.\n    function setNewRound() external {\n        require(isAdmin[msg.sender]);\n        require(totalAccumulatedPoints[roundId] > 0);\n        roundId += 1;\n        _stakeAtRiskInstance.setNewRound(roundId);\n        rankedNrnDistribution[roundId] = rankedNrnDistribution[roundId - 1];\n    }\n\n    /// @notice Stakes NRN tokens.\n    /// @param amount The amount of NRN tokens to stake.\n    /// @param tokenId The ID of the fighter to stake.\n    function stakeNRN(uint256 amount, uint256 tokenId) external {\n        require(amount > 0, \"Amount cannot be 0\");\n        require(_fighterFarmInstance.ownerOf(tokenId) == msg.sender, \"Caller does not own fighter\");\n        require(_neuronInstance.balanceOf(msg.sender) >= amount, \"Stake amount exceeds balance\");\n        require(hasUnstaked[tokenId][roundId] == false, \"Cannot add stake after unstaking this round\");\n\n        _neuronInstance.approveStaker(msg.sender, address(this), amount);\n        bool success = _neuronInstance.transferFrom(msg.sender, address(this), amount);\n        if (success) {\n            if (amountStaked[tokenId] == 0) {\n                _fighterFarmInstance.updateFighterStaking(tokenId, true);\n            }\n            amountStaked[tokenId] += amount;\n            globalStakedAmount += amount;\n            stakingFactor[tokenId] = _getStakingFactor(\n                tokenId, \n                _stakeAtRiskInstance.getStakeAtRisk(tokenId)\n            );\n            _calculatedStakingFactor[tokenId][roundId] = true;\n            emit Staked(msg.sender, amount);\n        }\n    }\n\n    /// @notice Unstakes NRN tokens.\n    /// @param amount The amount of NRN tokens to unstake.\n    /// @param tokenId The ID of the token to unstake.\n    function unstakeNRN(uint256 amount, uint256 tokenId) external {\n        require(_fighterFarmInstance.ownerOf(tokenId) == msg.sender, \"Caller does not own fighter\");\n        if (amount > amountStaked[tokenId]) {\n            amount = amountStaked[tokenId];\n        }\n        amountStaked[tokenId] -= amount;\n        globalStakedAmount -= amount;\n        stakingFactor[tokenId] = _getStakingFactor(\n            tokenId, \n            _stakeAtRiskInstance.getStakeAtRisk(tokenId)\n        );\n        _calculatedStakingFactor[tokenId][roundId] = true;\n        hasUnstaked[tokenId][roundId] = true;\n        bool success = _neuronInstance.transfer(msg.sender, amount);\n        if (success) {\n            if (amountStaked[tokenId] == 0) {\n                _fighterFarmInstance.updateFighterStaking(tokenId, false);\n            }\n            emit Unstaked(msg.sender, amount);\n        }\n    }\n\n    /// @notice Claims NRN tokens for the specified rounds.\n    /// @dev Caller can only claim once per round.\n    function claimNRN() external {\n        require(numRoundsClaimed[msg.sender] < roundId, \"Already claimed NRNs for this period\");\n        uint256 claimableNRN = 0;\n        uint256 nrnDistribution;\n        uint32 lowerBound = numRoundsClaimed[msg.sender];\n        for (uint32 currentRound = lowerBound; currentRound < roundId; currentRound++) {\n            nrnDistribution = getNrnDistribution(currentRound);\n            claimableNRN += (\n                accumulatedPointsPerAddress[msg.sender][currentRound] * nrnDistribution   \n            ) / totalAccumulatedPoints[currentRound];\n            numRoundsClaimed[msg.sender] += 1;\n        }\n        if (claimableNRN > 0) {\n            amountClaimed[msg.sender] += claimableNRN;\n            _neuronInstance.mint(msg.sender, claimableNRN);\n            emit Claimed(msg.sender, claimableNRN);\n        }\n    }\n\n    /// @notice Updates the battle record for a fighter.\n    /// @dev Only the game server address is authorized to update the battle record.\n    /// @dev Only the fighter that initiates the battle expends voltage on the match.\n    /// @dev Only fighters that have NRN staked are able to earn points.\n    /// @param tokenId The ID of the fighter.\n    /// @param mergingPortion The portion of points that get redirected to the merging pool.\n    /// @param battleResult The result of the battle.\n    /// @param eloFactor Multiple derived from ELO to be applied to the base points earned.\n    /// @param initiatorBool Whether this was the fighter that initiated the battle or not\n    function updateBattleRecord(\n        uint256 tokenId, \n        uint256 mergingPortion,\n        uint8 battleResult,\n        uint256 eloFactor,\n        bool initiatorBool\n    ) \n        external \n    {   \n        require(msg.sender == _gameServerAddress);\n        require(mergingPortion <= 100);\n        address fighterOwner = _fighterFarmInstance.ownerOf(tokenId);\n        require(\n            !initiatorBool ||\n            _voltageManagerInstance.ownerVoltageReplenishTime(fighterOwner) <= block.timestamp || \n            _voltageManagerInstance.ownerVoltage(fighterOwner) >= VOLTAGE_COST\n        );\n\n        _updateRecord(tokenId, battleResult);\n        uint256 stakeAtRisk = _stakeAtRiskInstance.getStakeAtRisk(tokenId);\n        if (amountStaked[tokenId] + stakeAtRisk > 0) {\n            _addResultPoints(battleResult, tokenId, eloFactor, mergingPortion, fighterOwner);\n        }\n        if (initiatorBool) {\n            _voltageManagerInstance.spendVoltage(fighterOwner, VOLTAGE_COST);\n        }\n        totalBattles += 1;\n    }\n\n    /// @notice Gets the battle record for a token.\n    /// @param tokenId The ID of the token.\n    /// @return Record which is comprised of wins, ties, and losses for the token.\n    function getBattleRecord(uint256 tokenId) external view returns(uint32, uint32, uint32) {\n      return (\n          fighterBattleRecord[tokenId].wins, \n          fighterBattleRecord[tokenId].ties, \n          fighterBattleRecord[tokenId].loses\n      );\n    }\n\n    /// @notice Gets the staking data for a token.\n    /// @return Round id, nrns to be distributed, and total point tally\n    function getCurrentStakingData() external view returns(uint256, uint256, uint256) {\n      return (\n          roundId,\n          rankedNrnDistribution[roundId], \n          totalAccumulatedPoints[roundId]\n      );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            PUBLIC FUNCTIONS\n    //////////////////////////////////////////////////////////////*/    \n\n    /// @notice Retrieves the nrn distribution amount for the given round ID.\n    /// @param roundId_ The round ID for which to get the nrn distribution.\n    /// @return Distribution amount for the specified round ID.\n    function getNrnDistribution(uint256 roundId_) public view returns(uint256) {\n        return rankedNrnDistribution[roundId_];\n    }\n\n    /// @notice Gets the unclaimed NRN tokens for a specific address.\n    /// @param claimer The address of the claimer.\n    /// @return The amount of unclaimed NRN tokens.\n    function getUnclaimedNRN(address claimer) public view returns(uint256) {\n        uint256 claimableNRN = 0;\n        uint256 nrnDistribution;   \n        uint32 lowerBound = numRoundsClaimed[claimer];\n        for (uint32 i = lowerBound; i < roundId; i++) {\n            nrnDistribution = getNrnDistribution(i);\n            claimableNRN += (\n                accumulatedPointsPerAddress[claimer][i] * nrnDistribution\n            ) / totalAccumulatedPoints[i];\n        }\n        return claimableNRN;\n    } \n\n    /*//////////////////////////////////////////////////////////////\n                            PRIVATE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Adds result points for a battle, based on the battle result, ELO factor, and merging portion.\n    /// @dev This function is called internally and is not accessible externally.\n    /// @dev There are 5 scenarios to be aware of:\n    /// @dev 1) Win + no stake-at-risk = Increase points balance\n    /// @dev 2) Win + stake-at-risk = Reclaim some of the stake that is at risk\n    /// @dev 3) Lose + positive point balance = Deduct from the point balance\n    /// @dev 4) Lose + no points = Move some of their NRN staked to the Stake At Risk contract\n    /// @dev 5) Tie = no consequence\n    /// @param battleResult The result of the battle (0: win, 1: tie, 2: loss).\n    /// @param tokenId The ID of the token participating in the battle.\n    /// @param eloFactor Multiple derived from ELO to be applied to the base points earned.\n    /// @param mergingPortion The portion of points that get redirected to the merging pool.\n    /// @param fighterOwner The address which owns the fighter whos points are being altered.\n    function _addResultPoints(\n        uint8 battleResult, \n        uint256 tokenId, \n        uint256 eloFactor, \n        uint256 mergingPortion,\n        address fighterOwner\n    ) \n        private \n    {\n        uint256 stakeAtRisk;\n        uint256 curStakeAtRisk;\n        uint256 points = 0;\n\n        /// Check how many NRNs the fighter has at risk\n        stakeAtRisk = _stakeAtRiskInstance.getStakeAtRisk(tokenId);\n\n        /// Calculate the staking factor if it has not already been calculated for this round \n        if (_calculatedStakingFactor[tokenId][roundId] == false) {\n            stakingFactor[tokenId] = _getStakingFactor(tokenId, stakeAtRisk);\n            _calculatedStakingFactor[tokenId][roundId] = true;\n        }\n\n        /// Potential amount of NRNs to put at risk or retrieve from the stake-at-risk contract\n        curStakeAtRisk = (bpsLostPerLoss * (amountStaked[tokenId] + stakeAtRisk)) / 10**4;\n        if (battleResult == 0) {\n            /// If the user won the match\n\n            /// If the user has no NRNs at risk, then they can earn points\n            if (stakeAtRisk == 0) {\n                points = stakingFactor[tokenId] * eloFactor;\n            }\n\n            /// Divert a portion of the points to the merging pool\n            uint256 mergingPoints = (points * mergingPortion) / 100;\n            points -= mergingPoints;\n            _mergingPoolInstance.addPoints(tokenId, mergingPoints);\n\n            /// Do not allow users to reclaim more NRNs than they have at risk\n            if (curStakeAtRisk > stakeAtRisk) {\n                curStakeAtRisk = stakeAtRisk;\n            }\n\n            /// If the user has stake-at-risk for their fighter, reclaim a portion\n            /// Reclaiming stake-at-risk puts the NRN back into their staking pool\n            if (curStakeAtRisk > 0) {\n                _stakeAtRiskInstance.reclaimNRN(curStakeAtRisk, tokenId, fighterOwner);\n                amountStaked[tokenId] += curStakeAtRisk;\n            }\n\n            /// Add points to the fighter for this round\n            accumulatedPointsPerFighter[tokenId][roundId] += points;\n            accumulatedPointsPerAddress[fighterOwner][roundId] += points;\n            totalAccumulatedPoints[roundId] += points;\n            if (points > 0) {\n                emit PointsChanged(tokenId, points, true);\n            }\n        } else if (battleResult == 2) {\n            /// If the user lost the match\n\n            /// Do not allow users to lose more NRNs than they have in their staking pool\n            if (curStakeAtRisk > amountStaked[tokenId]) {\n                curStakeAtRisk = amountStaked[tokenId];\n            }\n            if (accumulatedPointsPerFighter[tokenId][roundId] > 0) {\n                /// If the fighter has a positive point balance for this round, deduct points \n                points = stakingFactor[tokenId] * eloFactor;\n                if (points > accumulatedPointsPerFighter[tokenId][roundId]) {\n                    points = accumulatedPointsPerFighter[tokenId][roundId];\n                }\n                accumulatedPointsPerFighter[tokenId][roundId] -= points;\n                accumulatedPointsPerAddress[fighterOwner][roundId] -= points;\n                totalAccumulatedPoints[roundId] -= points;\n                if (points > 0) {\n                    emit PointsChanged(tokenId, points, false);\n                }\n            } else {\n                /// If the fighter does not have any points for this round, NRNs become at risk of being lost\n                bool success = _neuronInstance.transfer(_stakeAtRiskAddress, curStakeAtRisk);\n                if (success) {\n                    _stakeAtRiskInstance.updateAtRiskRecords(curStakeAtRisk, tokenId, fighterOwner);\n                    amountStaked[tokenId] -= curStakeAtRisk;\n                }\n            }\n        }\n    }\n\n    /// @notice Updates the battle record for a token.\n    /// @param tokenId The ID of the token.\n    /// @param battleResult The result of the battle.\n    function _updateRecord(uint256 tokenId, uint8 battleResult) private {\n        if (battleResult == 0) {\n            fighterBattleRecord[tokenId].wins += 1;\n        } else if (battleResult == 1) {\n            fighterBattleRecord[tokenId].ties += 1;\n        } else if (battleResult == 2) {\n            fighterBattleRecord[tokenId].loses += 1;\n        }\n    }\n\n    /// @notice Gets the staking factor for a token.\n    /// @param tokenId The ID of the token.\n    /// @param stakeAtRisk The amount of stake they have at risk.\n    /// @return Staking factor.\n    function _getStakingFactor(\n        uint256 tokenId, \n        uint256 stakeAtRisk\n    ) \n        private \n        view \n        returns (uint256) \n    {\n      uint256 stakingFactor_ = FixedPointMathLib.sqrt(\n          (amountStaked[tokenId] + stakeAtRisk) / 10**18\n      );\n      if (stakingFactor_ == 0) {\n        stakingFactor_ = 1;\n      }\n      return stakingFactor_;\n    }    \n}"
    }
  ]
}