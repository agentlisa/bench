{
  "Title": "[M01][Fixed] oToken can be created with a non-whitelisted collateral asset",
  "Content": "A product consists of a set of assets and an option type. Each product has to be whitelisted by the admin using the [`whitelistProduct` function](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/Whitelist.sol#L131) from the `Whitelist` contract.\n\n\nThen, a user can call the [`createOtoken` function](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/OtokenFactory.sol#L55) from the `OtokenFactory` with the same assets and option type, and because the product is whitelisted, the [requirement on line 70](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/OtokenFactory.sol#L70-L78) will succeed.\n\n\nHowever, although the product has been whitelisted, the collateral itself may not be approved. This is because the `whitelistProduct` function does not check against the [`isWhitelistedCollateral` function](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/Whitelist.sol#L100) if that collateral is allowed in the platform or not. Therefore, the first engagement with the collateral will appear on [line 613](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/Controller.sol#L613) from `Controller.sol`, where the transaction will revert when the user wants to deposit some collateral in their vault.\n\n\nConsider validating if the assets involved in a product have been already whitelisted before allowing the creation of oTokens.\n\n\n**Update:** *Fixed in [PR#290](https://github.com/opynfinance/GammaProtocol/pull/290) where the collateral asset is required to be whitelisted during the process of whitelisting the product.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/Whitelist.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.10;\n\nimport \"./interfaces/AddressBookInterface.sol\";\nimport \"./packages/oz/Ownable.sol\";\n\n/**\n * @author Opyn Team\n * @title Whitelist Module\n * @notice The whitelist module keeps track of all valid oToken addresses, product hashes, collateral addresses, and callee addresses.\n */\ncontract Whitelist is Ownable {\n    /// @notice AddressBook module address\n    address public addressBook;\n    /// @dev mapping to track whitelisted products\n    mapping(bytes32 => bool) internal whitelistedProduct;\n    /// @dev mapping to track whitelisted collateral\n    mapping(address => bool) internal whitelistedCollateral;\n    /// @dev mapping to track whitelisted oTokens\n    mapping(address => bool) internal whitelistedOtoken;\n    /// @dev mapping to track whitelisted callee addresses for the call action\n    mapping(address => bool) internal whitelistedCallee;\n\n    /**\n     * @dev constructor\n     * @param _addressBook AddressBook module address\n     */\n    constructor(address _addressBook) public {\n        require(_addressBook != address(0), \"Invalid address book\");\n\n        addressBook = _addressBook;\n    }\n\n    /// @notice emits an event a product is whitelisted by the owner address\n    event ProductWhitelisted(\n        bytes32 productHash,\n        address indexed underlying,\n        address indexed strike,\n        address indexed collateral,\n        bool isPut\n    );\n    /// @notice emits an event a product is blacklisted by the owner address\n    event ProductBlacklisted(\n        bytes32 productHash,\n        address indexed underlying,\n        address indexed strike,\n        address indexed collateral,\n        bool isPut\n    );\n    /// @notice emits an event when a collateral address is whitelisted by the owner address\n    event CollateralWhitelisted(address indexed collateral);\n    /// @notice emits an event when a collateral address is blacklist by the owner address\n    event CollateralBlacklisted(address indexed collateral);\n    /// @notice emits an event when an oToken is whitelisted by the OtokenFactory module\n    event OtokenWhitelisted(address indexed otoken);\n    /// @notice emits an event when an oToken is blacklisted by the OtokenFactory module\n    event OtokenBlacklisted(address indexed otoken);\n    /// @notice emits an event when a callee address is whitelisted by the owner address\n    event CalleeWhitelisted(address indexed _callee);\n    /// @notice emits an event when a callee address is blacklisted by the owner address\n    event CalleeBlacklisted(address indexed _callee);\n\n    /**\n     * @notice check if the sender is the oTokenFactory module\n     */\n    modifier onlyFactory() {\n        require(\n            msg.sender == AddressBookInterface(addressBook).getOtokenFactory(),\n            \"Whitelist: Sender is not OtokenFactory\"\n        );\n\n        _;\n    }\n\n    /**\n     * @notice check if a product is whitelisted\n     * @dev product is the hash of underlying asset, strike asset, collateral asset, and isPut\n     * @param _underlying asset that the option references\n     * @param _strike asset that the strike price is denominated in\n     * @param _collateral asset that is held as collateral against short/written options\n     * @param _isPut True if a put option, False if a call option\n     * @return boolean, True if product is whitelisted\n     */\n    function isWhitelistedProduct(\n        address _underlying,\n        address _strike,\n        address _collateral,\n        bool _isPut\n    ) external view returns (bool) {\n        bytes32 productHash = keccak256(abi.encode(_underlying, _strike, _collateral, _isPut));\n\n        return whitelistedProduct[productHash];\n    }\n\n    /**\n     * @notice check if a collateral asset is whitelisted\n     * @param _collateral asset that is held as collateral against short/written options\n     * @return boolean, True if the collateral is whitelisted\n     */\n    function isWhitelistedCollateral(address _collateral) external view returns (bool) {\n        return whitelistedCollateral[_collateral];\n    }\n\n    /**\n     * @notice check if an oToken is whitelisted\n     * @param _otoken oToken address\n     * @return boolean, True if the oToken is whitelisted\n     */\n    function isWhitelistedOtoken(address _otoken) external view returns (bool) {\n        return whitelistedOtoken[_otoken];\n    }\n\n    /**\n     * @notice check if a callee address is whitelisted for the call action\n     * @param _callee callee destination address\n     * @return boolean, True if the address is whitelisted\n     */\n    function isWhitelistedCallee(address _callee) external view returns (bool) {\n        return whitelistedCallee[_callee];\n    }\n\n    /**\n     * @notice allows the owner to whitelist a product\n     * @dev product is the hash of underlying asset, strike asset, collateral asset, and isPut\n     * can only be called from the owner address\n     * @param _underlying asset that the option references\n     * @param _strike asset that the strike price is denominated in\n     * @param _collateral asset that is held as collateral against short/written options\n     * @param _isPut True if a put option, False if a call option\n     */\n    function whitelistProduct(\n        address _underlying,\n        address _strike,\n        address _collateral,\n        bool _isPut\n    ) external onlyOwner {\n        bytes32 productHash = keccak256(abi.encode(_underlying, _strike, _collateral, _isPut));\n\n        whitelistedProduct[productHash] = true;\n\n        emit ProductWhitelisted(productHash, _underlying, _strike, _collateral, _isPut);\n    }\n\n    /**\n     * @notice allow the owner to blacklist a product\n     * @dev product is the hash of underlying asset, strike asset, collateral asset, and isPut\n     * can only be called from the owner address\n     * @param _underlying asset that the option references\n     * @param _strike asset that the strike price is denominated in\n     * @param _collateral asset that is held as collateral against short/written options\n     * @param _isPut True if a put option, False if a call option\n     */\n    function blacklistProduct(\n        address _underlying,\n        address _strike,\n        address _collateral,\n        bool _isPut\n    ) external onlyOwner {\n        bytes32 productHash = keccak256(abi.encode(_underlying, _strike, _collateral, _isPut));\n\n        whitelistedProduct[productHash] = false;\n\n        emit ProductBlacklisted(productHash, _underlying, _strike, _collateral, _isPut);\n    }\n\n    /**\n     * @notice allows the owner to whitelist a collateral address\n     * @dev can only be called from the owner address\n     * @param _collateral collateral asset address\n     */\n    function whitelistCollateral(address _collateral) external onlyOwner {\n        whitelistedCollateral[_collateral] = true;\n\n        emit CollateralWhitelisted(_collateral);\n    }\n\n    /**\n     * @notice allows the owner to blacklist a collateral address\n     * @dev can only be called from the owner address\n     * @param _collateral collateral asset address\n     */\n    function blacklistCollateral(address _collateral) external onlyOwner {\n        whitelistedCollateral[_collateral] = false;\n\n        emit CollateralBlacklisted(_collateral);\n    }\n\n    /**\n     * @notice allows the OtokenFactory module to whitelist a new option\n     * @dev can only be called from the OtokenFactory address\n     * @param _otokenAddress oToken\n     */\n    function whitelistOtoken(address _otokenAddress) external onlyFactory {\n        whitelistedOtoken[_otokenAddress] = true;\n\n        emit OtokenWhitelisted(_otokenAddress);\n    }\n\n    /**\n     * @notice allows the owner to blacklist an option\n     * @dev can only be called from the owner address\n     * @param _otokenAddress oToken\n     */\n    function blacklistOtoken(address _otokenAddress) external onlyOwner {\n        whitelistedOtoken[_otokenAddress] = false;\n\n        emit OtokenBlacklisted(_otokenAddress);\n    }\n\n    /**\n     * @notice allows the owner to whitelist a destination address for the call action\n     * @dev can only be called from the owner address\n     * @param _callee callee address\n     */\n    function whitelisteCallee(address _callee) external onlyOwner {\n        whitelistedCallee[_callee] = true;\n\n        emit CalleeWhitelisted(_callee);\n    }\n\n    /**\n     * @notice allows the owner to blacklist a destination address for the call action\n     * @dev can only be called from the owner address\n     * @param _callee callee address\n     */\n    function blacklistCallee(address _callee) external onlyOwner {\n        whitelistedCallee[_callee] = false;\n\n        emit CalleeBlacklisted(_callee);\n    }\n}"
    },
    {
      "filename": "contracts/OtokenFactory.sol",
      "content": "pragma solidity =0.6.10;\n\nimport {OtokenSpawner} from \"./OtokenSpawner.sol\";\nimport {SafeMath} from \"./packages/oz/SafeMath.sol\";\nimport {AddressBookInterface} from \"./interfaces/AddressBookInterface.sol\";\nimport {OtokenInterface} from \"./interfaces/OtokenInterface.sol\";\nimport {WhitelistInterface} from \"./interfaces/WhitelistInterface.sol\";\n\n/**\n * SPDX-License-Identifier: UNLICENSED\n * @title A factory to create Opyn oTokens\n * @author Opyn Team\n * @notice Create new oTokens and keep track of all created tokens\n * @dev Calculate contract address before each creation with CREATE2\n * and deploy eip-1167 minimal proxies for oToken logic contract\n */\ncontract OtokenFactory is OtokenSpawner {\n    using SafeMath for uint256;\n    /// @notice Opyn AddressBook contract that records the address of the Whitelist module and the Otoken impl address. */\n    address public addressBook;\n\n    /// @notice array of all created otokens */\n    address[] public otokens;\n\n    /// @dev mapping from parameters hash to its deployed address\n    mapping(bytes32 => address) private idToAddress;\n\n    constructor(address _addressBook) public {\n        addressBook = _addressBook;\n    }\n\n    /// @notice emitted when the factory creates a new Option\n    event OtokenCreated(\n        address indexed tokenAddress,\n        address indexed creator,\n        address underlying,\n        address strike,\n        address collateral,\n        uint256 strikePrice,\n        uint256 expiry,\n        bool isPut\n    );\n\n    /**\n     * @notice create new oTokens\n     * @dev deploy an eip-1167 minimal proxy with CREATE2 and register it to the whitelist module\n     * @param _underlyingAsset asset that the option references\n     * @param _strikeAsset asset that the strike price is denominated in\n     * @param _collateralAsset asset that is held as collateral against short/written options\n     * @param _strikePrice strike price with decimals = 18\n     * @param _expiry expiration timestamp as a unix timestamp\n     * @param _isPut True if a put option, False if a call option\n     * @return newOtoken address of the newly created option\n     */\n    function createOtoken(\n        address _underlyingAsset,\n        address _strikeAsset,\n        address _collateralAsset,\n        uint256 _strikePrice,\n        uint256 _expiry,\n        bool _isPut\n    ) external returns (address) {\n        require(_expiry > now, \"OtokenFactory: Can't create expired option\");\n        require(_expiry < 11865398400, \"OtokenFactory: Can't create option with expiry > 2345/12/31\");\n        require(_expiry.sub(28800).mod(86400) == 0, \"OtokenFactory: Option has to expire 08:00 UTC\");\n        bytes32 id = _getOptionId(_underlyingAsset, _strikeAsset, _collateralAsset, _strikePrice, _expiry, _isPut);\n        require(idToAddress[id] == address(0), \"OtokenFactory: Option already created\");\n\n        address whitelist = AddressBookInterface(addressBook).getWhitelist();\n        require(\n            WhitelistInterface(whitelist).isWhitelistedProduct(\n                _underlyingAsset,\n                _strikeAsset,\n                _collateralAsset,\n                _isPut\n            ),\n            \"OtokenFactory: Unsupported Product\"\n        );\n\n        require(!_isPut || _strikePrice > 0, \"OtokenFactory: Can't create a $0 strike put option\");\n\n        address otokenImpl = AddressBookInterface(addressBook).getOtokenImpl();\n\n        bytes memory initializationCalldata = abi.encodeWithSelector(\n            OtokenInterface(otokenImpl).init.selector,\n            addressBook,\n            _underlyingAsset,\n            _strikeAsset,\n            _collateralAsset,\n            _strikePrice,\n            _expiry,\n            _isPut\n        );\n\n        address newOtoken = _spawn(otokenImpl, initializationCalldata);\n\n        idToAddress[id] = newOtoken;\n        otokens.push(newOtoken);\n        WhitelistInterface(whitelist).whitelistOtoken(newOtoken);\n\n        emit OtokenCreated(\n            newOtoken,\n            msg.sender,\n            _underlyingAsset,\n            _strikeAsset,\n            _collateralAsset,\n            _strikePrice,\n            _expiry,\n            _isPut\n        );\n\n        return newOtoken;\n    }\n\n    /**\n     * @notice get the total oTokens created by the factory\n     * @return length of the oTokens array\n     */\n    function getOtokensLength() external view returns (uint256) {\n        return otokens.length;\n    }\n\n    /**\n     * @notice get the oToken address for an already created oToken, if no oToken has been created with these parameters, it will return address(0)\n     * @param _underlyingAsset asset that the option references\n     * @param _strikeAsset asset that the strike price is denominated in\n     * @param _collateralAsset asset that is held as collateral against short/written options\n     * @param _strikePrice strike price with decimals = 18\n     * @param _expiry expiration timestamp as a unix timestamp\n     * @param _isPut True if a put option, False if a call option\n     * @return the address of target otoken.\n     */\n    function getOtoken(\n        address _underlyingAsset,\n        address _strikeAsset,\n        address _collateralAsset,\n        uint256 _strikePrice,\n        uint256 _expiry,\n        bool _isPut\n    ) external view returns (address) {\n        bytes32 id = _getOptionId(_underlyingAsset, _strikeAsset, _collateralAsset, _strikePrice, _expiry, _isPut);\n        return idToAddress[id];\n    }\n\n    /**\n     * @notice get the address at which a new oToken with these parameters would be deployed\n     * @dev return the exact address that will be deployed at with _computeAddress\n     * @param _underlyingAsset asset that the option references\n     * @param _strikeAsset asset that the strike price is denominated in\n     * @param _collateralAsset asset that is held as collateral against short/written options\n     * @param _strikePrice strike price with decimals = 18\n     * @param _expiry expiration timestamp as a unix timestamp\n     * @param _isPut True if a put option, False if a call option\n     * @return targetAddress the address this oToken would be deployed at\n     */\n    function getTargetOtokenAddress(\n        address _underlyingAsset,\n        address _strikeAsset,\n        address _collateralAsset,\n        uint256 _strikePrice,\n        uint256 _expiry,\n        bool _isPut\n    ) external view returns (address) {\n        address otokenImpl = AddressBookInterface(addressBook).getOtokenImpl();\n        bytes memory initializationCalldata = abi.encodeWithSelector(\n            OtokenInterface(otokenImpl).init.selector,\n            addressBook,\n            _underlyingAsset,\n            _strikeAsset,\n            _collateralAsset,\n            _strikePrice,\n            _expiry,\n            _isPut\n        );\n        return _computeAddress(AddressBookInterface(addressBook).getOtokenImpl(), initializationCalldata);\n    }\n\n    /**\n     * @dev hash oToken parameters and return a unique option id\n     * @param _underlyingAsset asset that the option references\n     * @param _strikeAsset asset that the strike price is denominated in\n     * @param _collateralAsset asset that is held as collateral against short/written options\n     * @param _strikePrice strike price with decimals = 18\n     * @param _expiry expiration timestamp as a unix timestamp\n     * @param _isPut True if a put option, False if a call option\n     * @return id the unique id of an oToken\n     */\n    function _getOptionId(\n        address _underlyingAsset,\n        address _strikeAsset,\n        address _collateralAsset,\n        uint256 _strikePrice,\n        uint256 _expiry,\n        bool _isPut\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(_underlyingAsset, _strikeAsset, _collateralAsset, _strikePrice, _expiry, _isPut)\n            );\n    }\n}"
    },
    {
      "filename": "contracts/Whitelist.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.10;\n\nimport \"./interfaces/AddressBookInterface.sol\";\nimport \"./packages/oz/Ownable.sol\";\n\n/**\n * @author Opyn Team\n * @title Whitelist Module\n * @notice The whitelist module keeps track of all valid oToken addresses, product hashes, collateral addresses, and callee addresses.\n */\ncontract Whitelist is Ownable {\n    /// @notice AddressBook module address\n    address public addressBook;\n    /// @dev mapping to track whitelisted products\n    mapping(bytes32 => bool) internal whitelistedProduct;\n    /// @dev mapping to track whitelisted collateral\n    mapping(address => bool) internal whitelistedCollateral;\n    /// @dev mapping to track whitelisted oTokens\n    mapping(address => bool) internal whitelistedOtoken;\n    /// @dev mapping to track whitelisted callee addresses for the call action\n    mapping(address => bool) internal whitelistedCallee;\n\n    /**\n     * @dev constructor\n     * @param _addressBook AddressBook module address\n     */\n    constructor(address _addressBook) public {\n        require(_addressBook != address(0), \"Invalid address book\");\n\n        addressBook = _addressBook;\n    }\n\n    /// @notice emits an event a product is whitelisted by the owner address\n    event ProductWhitelisted(\n        bytes32 productHash,\n        address indexed underlying,\n        address indexed strike,\n        address indexed collateral,\n        bool isPut\n    );\n    /// @notice emits an event a product is blacklisted by the owner address\n    event ProductBlacklisted(\n        bytes32 productHash,\n        address indexed underlying,\n        address indexed strike,\n        address indexed collateral,\n        bool isPut\n    );\n    /// @notice emits an event when a collateral address is whitelisted by the owner address\n    event CollateralWhitelisted(address indexed collateral);\n    /// @notice emits an event when a collateral address is blacklist by the owner address\n    event CollateralBlacklisted(address indexed collateral);\n    /// @notice emits an event when an oToken is whitelisted by the OtokenFactory module\n    event OtokenWhitelisted(address indexed otoken);\n    /// @notice emits an event when an oToken is blacklisted by the OtokenFactory module\n    event OtokenBlacklisted(address indexed otoken);\n    /// @notice emits an event when a callee address is whitelisted by the owner address\n    event CalleeWhitelisted(address indexed _callee);\n    /// @notice emits an event when a callee address is blacklisted by the owner address\n    event CalleeBlacklisted(address indexed _callee);\n\n    /**\n     * @notice check if the sender is the oTokenFactory module\n     */\n    modifier onlyFactory() {\n        require(\n            msg.sender == AddressBookInterface(addressBook).getOtokenFactory(),\n            \"Whitelist: Sender is not OtokenFactory\"\n        );\n\n        _;\n    }\n\n    /**\n     * @notice check if a product is whitelisted\n     * @dev product is the hash of underlying asset, strike asset, collateral asset, and isPut\n     * @param _underlying asset that the option references\n     * @param _strike asset that the strike price is denominated in\n     * @param _collateral asset that is held as collateral against short/written options\n     * @param _isPut True if a put option, False if a call option\n     * @return boolean, True if product is whitelisted\n     */\n    function isWhitelistedProduct(\n        address _underlying,\n        address _strike,\n        address _collateral,\n        bool _isPut\n    ) external view returns (bool) {\n        bytes32 productHash = keccak256(abi.encode(_underlying, _strike, _collateral, _isPut));\n\n        return whitelistedProduct[productHash];\n    }\n\n    /**\n     * @notice check if a collateral asset is whitelisted\n     * @param _collateral asset that is held as collateral against short/written options\n     * @return boolean, True if the collateral is whitelisted\n     */\n    function isWhitelistedCollateral(address _collateral) external view returns (bool) {\n        return whitelistedCollateral[_collateral];\n    }\n\n    /**\n     * @notice check if an oToken is whitelisted\n     * @param _otoken oToken address\n     * @return boolean, True if the oToken is whitelisted\n     */\n    function isWhitelistedOtoken(address _otoken) external view returns (bool) {\n        return whitelistedOtoken[_otoken];\n    }\n\n    /**\n     * @notice check if a callee address is whitelisted for the call action\n     * @param _callee callee destination address\n     * @return boolean, True if the address is whitelisted\n     */\n    function isWhitelistedCallee(address _callee) external view returns (bool) {\n        return whitelistedCallee[_callee];\n    }\n\n    /**\n     * @notice allows the owner to whitelist a product\n     * @dev product is the hash of underlying asset, strike asset, collateral asset, and isPut\n     * can only be called from the owner address\n     * @param _underlying asset that the option references\n     * @param _strike asset that the strike price is denominated in\n     * @param _collateral asset that is held as collateral against short/written options\n     * @param _isPut True if a put option, False if a call option\n     */\n    function whitelistProduct(\n        address _underlying,\n        address _strike,\n        address _collateral,\n        bool _isPut\n    ) external onlyOwner {\n        bytes32 productHash = keccak256(abi.encode(_underlying, _strike, _collateral, _isPut));\n\n        whitelistedProduct[productHash] = true;\n\n        emit ProductWhitelisted(productHash, _underlying, _strike, _collateral, _isPut);\n    }\n\n    /**\n     * @notice allow the owner to blacklist a product\n     * @dev product is the hash of underlying asset, strike asset, collateral asset, and isPut\n     * can only be called from the owner address\n     * @param _underlying asset that the option references\n     * @param _strike asset that the strike price is denominated in\n     * @param _collateral asset that is held as collateral against short/written options\n     * @param _isPut True if a put option, False if a call option\n     */\n    function blacklistProduct(\n        address _underlying,\n        address _strike,\n        address _collateral,\n        bool _isPut\n    ) external onlyOwner {\n        bytes32 productHash = keccak256(abi.encode(_underlying, _strike, _collateral, _isPut));\n\n        whitelistedProduct[productHash] = false;\n\n        emit ProductBlacklisted(productHash, _underlying, _strike, _collateral, _isPut);\n    }\n\n    /**\n     * @notice allows the owner to whitelist a collateral address\n     * @dev can only be called from the owner address\n     * @param _collateral collateral asset address\n     */\n    function whitelistCollateral(address _collateral) external onlyOwner {\n        whitelistedCollateral[_collateral] = true;\n\n        emit CollateralWhitelisted(_collateral);\n    }\n\n    /**\n     * @notice allows the owner to blacklist a collateral address\n     * @dev can only be called from the owner address\n     * @param _collateral collateral asset address\n     */\n    function blacklistCollateral(address _collateral) external onlyOwner {\n        whitelistedCollateral[_collateral] = false;\n\n        emit CollateralBlacklisted(_collateral);\n    }\n\n    /**\n     * @notice allows the OtokenFactory module to whitelist a new option\n     * @dev can only be called from the OtokenFactory address\n     * @param _otokenAddress oToken\n     */\n    function whitelistOtoken(address _otokenAddress) external onlyFactory {\n        whitelistedOtoken[_otokenAddress] = true;\n\n        emit OtokenWhitelisted(_otokenAddress);\n    }\n\n    /**\n     * @notice allows the owner to blacklist an option\n     * @dev can only be called from the owner address\n     * @param _otokenAddress oToken\n     */\n    function blacklistOtoken(address _otokenAddress) external onlyOwner {\n        whitelistedOtoken[_otokenAddress] = false;\n\n        emit OtokenBlacklisted(_otokenAddress);\n    }\n\n    /**\n     * @notice allows the owner to whitelist a destination address for the call action\n     * @dev can only be called from the owner address\n     * @param _callee callee address\n     */\n    function whitelisteCallee(address _callee) external onlyOwner {\n        whitelistedCallee[_callee] = true;\n\n        emit CalleeWhitelisted(_callee);\n    }\n\n    /**\n     * @notice allows the owner to blacklist a destination address for the call action\n     * @dev can only be called from the owner address\n     * @param _callee callee address\n     */\n    function blacklistCallee(address _callee) external onlyOwner {\n        whitelistedCallee[_callee] = false;\n\n        emit CalleeBlacklisted(_callee);\n    }\n}"
    }
  ]
}