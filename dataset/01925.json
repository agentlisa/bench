{
  "Title": "[M-01] New proposals can be DOS'd by frontrunning",
  "Content": "To create a new proposal using the `ApprovalVotingModule`, the Manager of the governor contract calls `proposeWithModule()`:\n\n```solidity\nfunction proposeWithModule(VotingModule module, bytes memory proposalData, string memory description)\npublic\nonlyManager\nreturns (uint256)\n{\nrequire(\ngetVotes(_msgSender(), block.number - 1) >= proposalThreshold(),\n\"Governor: proposer votes below proposal threshold\"\n);\n\nuint256 proposalId = hashProposalWithModule(address(module), proposalData, keccak256(bytes(description)));\n\nProposalCore storage proposal = _proposals[proposalId];\nrequire(proposal.voteStart.isUnset(), \"Governor: proposal already exists\");\n\nuint64 snapshot = block.number.toUint64() + votingDelay().toUint64();\nuint64 deadline = snapshot + votingPeriod().toUint64();\n\nproposal.voteStart.setDeadline(snapshot);\nproposal.voteEnd.setDeadline(deadline);\nproposal.votingModule = address(module);\n\nemit ProposalCreated(proposalId, _msgSender(), address(module), proposalData, snapshot, deadline, description);\n\nmodule.propose(proposalId, proposalData);\n\nreturn proposalId;\n}\n```\n\n[OptimismGovernorV5.sol#L77-L104](https://github.com/voteagora/optimism-gov/blob/35f441738bd7864bd37949a40842486bc0ac51b0/src/OptimismGovernorV5.sol#L77-L104)\n\nThe `proposalId` is set using the `hashProposalWithModule()` function:\n\n```solidity\nfunction hashProposalWithModule(address module, bytes memory proposalData, bytes32 descriptionHash)\npublic\nview\nvirtual\nreturns (uint256)\n{\nreturn uint256(keccak256(abi.encode(address(this), module, proposalData, descriptionHash)));\n}\n```\n\n[OptimismGovernorV5.sol#L279-L286](https://github.com/voteagora/optimism-gov/blob/35f441738bd7864bd37949a40842486bc0ac51b0/src/OptimismGovernorV5.sol#L279-L286)\n\nIf we follow the call to `module.propose()`, we see the following:\n\n```solidity\nfunction propose(uint256 proposalId, bytes memory proposalData) external override {\nif (_proposals[proposalId].governor != address(0)) revert ExistingProposal();\n...\n}\n```\n\n[ApprovalVotingModule.sol#L107-L109](https://github.com/voteagora/optimism-gov/blob/35f441738bd7864bd37949a40842486bc0ac51b0/src/modules/ApprovalVotingModule.sol#L107-L109)\n\nThis function allows any address (presumably a governor) to call `propose()` and confirms that the `proposalId` has not been used before. Since the hash includes the address of the governor, it is assumed that this hash will be unique across governors using the `ApprovalVotingModule`.\n\nHowever, there is no check that the `proposalId` submitted is actually equal to the output of `hashProposalWithModule`, nor are there any protections on who can call this function.\n\nAs a result, a malicious user can watch the mempool for new calls to `proposeWithModule()`, calculate the `proposalId` from the data, and frontrun the call to `module.propose()` with the same `proposalId`.\n\nThe result is that a proposal will be created on the `ApprovalVotingModule` with the malicious user set as the governor, and the legitimate call from the governor will revert.\n\nThis can be continued endlessly, blocking any proposals from being created.\n\n**Recommendation**\n\nThe uniqueness of the `proposalId` should be enforced on the `ApprovalVotingModule` side, rather than on the governor side.\n\nRather than simply passing the `proposalId` to the module, the module should take in the underlying data and compute the `proposalId` itself.\n\nTo ensure that `proposalId`s match between the governor and the module, the safest option is to pass the `proposalId` as well as all necessary values to compute it and check on the module that they align, as follows:\n\n```solidity\nfunction propose(uint256 proposalId, bytes memory proposalData, bytes32 descriptionHash) external override {\nif (\nproposalId != uint256(keccak256(abi.encode(msg.sender, address(this), proposalData, descriptionHash)))\n) revert WrongProposalId();\n\nif (_proposals[proposalId].governor != address(0)) revert ExistingProposal();\n\n...\n}\n```\n\nThis serves the purpose of ensuring that the `msg.sender` is equal to the governor address value that should be included in the hash, and blocks the ability for arbitrary users to submit `proposalId`s they should not be able to create.\n\n[Note that there is also the (very unlikely) case that two governors may use different hash functions to determine their `proposalId`s and could end up colliding that way, and this fix addresses this risk as well.]\n\n**Review**\n\nFixed as recommended in [20e645198d10646c6923e8a9caafb05e536d8fe3](https://github.com/voteagora/optimism-gov/commit/20e645198d10646c6923e8a9caafb05e536d8fe3).",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "src/OptimismGovernorV5.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {GovernorUpgradeableV2} from \"./lib/v2/GovernorUpgradeableV2.sol\";\nimport {GovernorCountingSimpleUpgradeableV2} from \"./lib/v2/GovernorCountingSimpleUpgradeableV2.sol\";\nimport {GovernorVotesQuorumFractionUpgradeableV2} from \"./lib/v2/GovernorVotesQuorumFractionUpgradeableV2.sol\";\nimport {GovernorVotesUpgradeableV2} from \"./lib/v2/GovernorVotesUpgradeableV2.sol\";\nimport {GovernorSettingsUpgradeableV2} from \"./lib/v2/GovernorSettingsUpgradeableV2.sol\";\nimport {IGovernorUpgradeable} from \"@openzeppelin/contracts-upgradeable/governance/IGovernorUpgradeable.sol\";\nimport {IVotesUpgradeable} from \"@openzeppelin/contracts-upgradeable/governance/utils/IVotesUpgradeable.sol\";\nimport {TimersUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/TimersUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {SafeCastUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\nimport {VotingModule} from \"./modules/VotingModule.sol\";\n\n/**\n * Introduces support for voting modules.\n */\ncontract OptimismGovernorV5 is\n    Initializable,\n    GovernorUpgradeableV2,\n    GovernorCountingSimpleUpgradeableV2,\n    GovernorVotesUpgradeableV2,\n    GovernorVotesQuorumFractionUpgradeableV2,\n    GovernorSettingsUpgradeableV2\n{\n    /*//////////////////////////////////////////////////////////////\n                               LIBRARIES\n    //////////////////////////////////////////////////////////////*/\n\n    using SafeCastUpgradeable for uint256;\n    using TimersUpgradeable for TimersUpgradeable.BlockNumber;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * Emitted when a proposal with module is created.\n     */\n    event ProposalCreated(\n        uint256 proposalId,\n        address proposer,\n        address votingModule,\n        bytes proposalData,\n        uint256 startBlock,\n        uint256 endBlock,\n        string description\n    );\n    event ProposalDeadlineUpdated(uint256 proposalId, uint64 deadline);\n\n    /*//////////////////////////////////////////////////////////////\n                                STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    address public manager;\n\n    /*//////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            WRITE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * Create a new proposal with a custom voting module. See {IGovernor-propose}.\n     *\n     * @param module The address of the voting module to use for this proposal.\n     * @param proposalData The proposal data to pass to the voting module.\n     * @param description A human readable description of the proposal.\n     */\n    function proposeWithModule(VotingModule module, bytes memory proposalData, string memory description)\n        public\n        onlyManager\n        returns (uint256)\n    {\n        require(\n            getVotes(_msgSender(), block.number - 1) >= proposalThreshold(),\n            \"Governor: proposer votes below proposal threshold\"\n        );\n\n        uint256 proposalId = hashProposalWithModule(address(module), proposalData, keccak256(bytes(description)));\n\n        ProposalCore storage proposal = _proposals[proposalId];\n        require(proposal.voteStart.isUnset(), \"Governor: proposal already exists\");\n\n        uint64 snapshot = block.number.toUint64() + votingDelay().toUint64();\n        uint64 deadline = snapshot + votingPeriod().toUint64();\n\n        proposal.voteStart.setDeadline(snapshot);\n        proposal.voteEnd.setDeadline(deadline);\n        proposal.votingModule = address(module);\n\n        emit ProposalCreated(proposalId, _msgSender(), address(module), proposalData, snapshot, deadline, description);\n\n        module.propose(proposalId, proposalData);\n\n        return proposalId;\n    }\n\n    /**\n     * Executes a proposal via a custom voting module. See {IGovernor-execute}.\n     *\n     * @param module The address of the voting module to use for this proposal.\n     * @param proposalData The proposal data to pass to the voting module.\n     * @param descriptionHash The hash of the proposal description.\n     */\n    function executeWithModule(VotingModule module, bytes memory proposalData, bytes32 descriptionHash)\n        public\n        payable\n        returns (uint256)\n    {\n        uint256 proposalId = hashProposalWithModule(address(module), proposalData, descriptionHash);\n\n        ProposalState status = state(proposalId);\n        require(\n            status == ProposalState.Succeeded || status == ProposalState.Queued, \"Governor: proposal not successful\"\n        );\n        _proposals[proposalId].executed = true;\n\n        emit ProposalExecuted(proposalId);\n\n        (address[] memory targets, uint256[] memory values, bytes[] memory calldatas) =\n            module._formatExecuteParams(proposalId, proposalData);\n\n        _beforeExecute(proposalId, targets, values, calldatas, descriptionHash);\n        _execute(proposalId, targets, values, calldatas, descriptionHash);\n        _afterExecute(proposalId, targets, values, calldatas, descriptionHash);\n\n        return proposalId;\n    }\n\n    /**\n     * Cancel a proposal with a custom voting module. See {IGovernor-_cancel}.\n     *\n     * @param module The address of the voting module to use for this proposal.\n     * @param proposalData The proposal data to pass to the voting module.\n     * @param descriptionHash The hash of the proposal description.\n     */\n    function cancelWithModule(VotingModule module, bytes memory proposalData, bytes32 descriptionHash)\n        public\n        onlyManager\n        returns (uint256)\n    {\n        uint256 proposalId = hashProposalWithModule(address(module), proposalData, descriptionHash);\n        ProposalState status = state(proposalId);\n\n        require(\n            status != ProposalState.Canceled && status != ProposalState.Expired && status != ProposalState.Executed,\n            \"Governor: proposal not active\"\n        );\n        _proposals[proposalId].canceled = true;\n\n        emit ProposalCanceled(proposalId);\n\n        return proposalId;\n    }\n\n    /**\n     * @dev Updated internal vote casting mechanism which allows delegating logic to custom voting module. See {IGovernor-_castVote}.\n     */\n    function _castVote(uint256 proposalId, address account, uint8 support, string memory reason, bytes memory params)\n        internal\n        override\n        returns (uint256)\n    {\n        ProposalCore memory proposal = _proposals[proposalId];\n        require(state(proposalId) == ProposalState.Active, \"Governor: vote not currently active\");\n\n        uint256 weight = _getVotes(account, proposal.voteStart.getDeadline(), params);\n\n        if (proposal.votingModule != address(0)) {\n            VotingModule(proposal.votingModule)._countVote(proposalId, account, support, weight, params);\n        } else {\n            _countVote(proposalId, account, support, weight, params);\n        }\n\n        if (params.length == 0) {\n            emit VoteCast(account, proposalId, support, weight, reason);\n        } else {\n            emit VoteCastWithParams(account, proposalId, support, weight, reason, params);\n        }\n\n        return weight;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * COUNTING_MODE with added `params=modules` options to indicate support for external voting modules. See {IGovernor-COUNTING_MODE}.\n     */\n    function COUNTING_MODE()\n        public\n        pure\n        virtual\n        override(GovernorCountingSimpleUpgradeableV2, IGovernorUpgradeable)\n        returns (string memory)\n    {\n        return \"support=bravo&quorum=against,for,abstain&params=modules\";\n    }\n\n    /**\n     * @dev Updated `hasVoted` which allows delegating logic to custom voting module. See {IGovernor-hasVoted}.\n     */\n    function hasVoted(uint256 proposalId, address account)\n        public\n        view\n        virtual\n        override(GovernorCountingSimpleUpgradeableV2, IGovernorUpgradeable)\n        returns (bool)\n    {\n        address votingModule = _proposals[proposalId].votingModule;\n        if (votingModule != address(0)) {\n            return VotingModule(votingModule).hasVoted(proposalId, account);\n        }\n\n        return super.hasVoted(proposalId, account);\n    }\n\n    /**\n     * @dev Updated `_quorumReached` which allows delegating logic to custom voting module. See {IGovernor-_quorumReached}.\n     */\n    function _quorumReached(uint256 proposalId)\n        internal\n        view\n        virtual\n        override(GovernorCountingSimpleUpgradeableV2, GovernorUpgradeableV2)\n        returns (bool)\n    {\n        ProposalCore memory proposal = _proposals[proposalId];\n        if (proposal.votingModule != address(0)) {\n            return\n                VotingModule(proposal.votingModule)._quorumReached(proposalId, quorum(proposal.voteStart.getDeadline()));\n        }\n\n        (uint256 againstVotes, uint256 forVotes, uint256 abstainVotes) = proposalVotes(proposalId);\n\n        return quorum(proposalSnapshot(proposalId)) <= againstVotes + forVotes + abstainVotes;\n    }\n\n    /**\n     * @dev Updated `_voteSucceeded` which allows delegating logic to custom voting module. See {Governor-_voteSucceeded}.\n     */\n    function _voteSucceeded(uint256 proposalId)\n        internal\n        view\n        virtual\n        override(GovernorCountingSimpleUpgradeableV2, GovernorUpgradeableV2)\n        returns (bool)\n    {\n        address votingModule = _proposals[proposalId].votingModule;\n        if (votingModule != address(0)) {\n            return VotingModule(votingModule)._voteSucceeded(proposalId);\n        }\n\n        return super._voteSucceeded(proposalId);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * Calculate `proposalId` hashing similarly to `hashProposal` but based on `module` and `proposalData`.\n     * See {IGovernor-hashProposal}.\n     *\n     * @param module The address of the voting module to use for this proposal.\n     * @param proposalData The proposal data to pass to the voting module.\n     * @param descriptionHash The hash of the proposal description.\n     * @return The id of the proposal.\n     */\n    function hashProposalWithModule(address module, bytes memory proposalData, bytes32 descriptionHash)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        return uint256(keccak256(abi.encode(address(this), module, proposalData, descriptionHash)));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                   V2\n    //////////////////////////////////////////////////////////////*/\n\n    modifier onlyManager() {\n        require(msg.sender == manager, \"Only the manager can call this function\");\n        _;\n    }\n\n    function initialize(IVotesUpgradeable _votingToken, address _manager) public initializer {\n        __Governor_init(\"Optimism\");\n        __GovernorCountingSimple_init();\n        __GovernorVotes_init(_votingToken);\n        __GovernorVotesQuorumFraction_init({quorumNumeratorValue: 30});\n        __GovernorSettings_init({initialVotingDelay: 6575, initialVotingPeriod: 46027, initialProposalThreshold: 0});\n\n        manager = _manager;\n    }\n\n    function _execute(\n        uint256, /* proposalId */\n        address[] memory, /* targets */\n        uint256[] memory, /* values */\n        bytes[] memory, /* calldatas */\n        bytes32 /*descriptionHash*/\n    ) internal view override onlyManager {\n        // Execution is skipped\n    }\n\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public override onlyManager returns (uint256) {\n        return super.propose(targets, values, calldatas, description);\n    }\n\n    function proposalThreshold()\n        public\n        view\n        override(GovernorSettingsUpgradeableV2, GovernorUpgradeableV2)\n        returns (uint256)\n    {\n        return GovernorSettingsUpgradeableV2.proposalThreshold();\n    }\n\n    function quorumDenominator() public view virtual override returns (uint256) {\n        // Configurable to 3 decimal points of percentage\n        return 100_000;\n    }\n\n    function setProposalDeadline(uint256 proposalId, uint64 deadline) public onlyManager {\n        _proposals[proposalId].voteEnd.setDeadline(deadline);\n        emit ProposalDeadlineUpdated(proposalId, deadline);\n    }\n\n    function setVotingDelay(uint256 newVotingDelay) public override onlyManager {\n        _setVotingDelay(newVotingDelay);\n    }\n\n    function setVotingPeriod(uint256 newVotingPeriod) public override onlyManager {\n        _setVotingPeriod(newVotingPeriod);\n    }\n\n    function setProposalThreshold(uint256 newProposalThreshold) public override onlyManager {\n        _setProposalThreshold(newProposalThreshold);\n    }\n\n    function updateQuorumNumerator(uint256 newQuorumNumerator) external override onlyManager {\n        _updateQuorumNumerator(newQuorumNumerator);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                   V3\n    //////////////////////////////////////////////////////////////*/\n\n    function cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public onlyManager returns (uint256) {\n        return _cancel(targets, values, calldatas, descriptionHash);\n    }\n}"
    },
    {
      "filename": "src/OptimismGovernorV5.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {GovernorUpgradeableV2} from \"./lib/v2/GovernorUpgradeableV2.sol\";\nimport {GovernorCountingSimpleUpgradeableV2} from \"./lib/v2/GovernorCountingSimpleUpgradeableV2.sol\";\nimport {GovernorVotesQuorumFractionUpgradeableV2} from \"./lib/v2/GovernorVotesQuorumFractionUpgradeableV2.sol\";\nimport {GovernorVotesUpgradeableV2} from \"./lib/v2/GovernorVotesUpgradeableV2.sol\";\nimport {GovernorSettingsUpgradeableV2} from \"./lib/v2/GovernorSettingsUpgradeableV2.sol\";\nimport {IGovernorUpgradeable} from \"@openzeppelin/contracts-upgradeable/governance/IGovernorUpgradeable.sol\";\nimport {IVotesUpgradeable} from \"@openzeppelin/contracts-upgradeable/governance/utils/IVotesUpgradeable.sol\";\nimport {TimersUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/TimersUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {SafeCastUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\nimport {VotingModule} from \"./modules/VotingModule.sol\";\n\n/**\n * Introduces support for voting modules.\n */\ncontract OptimismGovernorV5 is\n    Initializable,\n    GovernorUpgradeableV2,\n    GovernorCountingSimpleUpgradeableV2,\n    GovernorVotesUpgradeableV2,\n    GovernorVotesQuorumFractionUpgradeableV2,\n    GovernorSettingsUpgradeableV2\n{\n    /*//////////////////////////////////////////////////////////////\n                               LIBRARIES\n    //////////////////////////////////////////////////////////////*/\n\n    using SafeCastUpgradeable for uint256;\n    using TimersUpgradeable for TimersUpgradeable.BlockNumber;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * Emitted when a proposal with module is created.\n     */\n    event ProposalCreated(\n        uint256 proposalId,\n        address proposer,\n        address votingModule,\n        bytes proposalData,\n        uint256 startBlock,\n        uint256 endBlock,\n        string description\n    );\n    event ProposalDeadlineUpdated(uint256 proposalId, uint64 deadline);\n\n    /*//////////////////////////////////////////////////////////////\n                                STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    address public manager;\n\n    /*//////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            WRITE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * Create a new proposal with a custom voting module. See {IGovernor-propose}.\n     *\n     * @param module The address of the voting module to use for this proposal.\n     * @param proposalData The proposal data to pass to the voting module.\n     * @param description A human readable description of the proposal.\n     */\n    function proposeWithModule(VotingModule module, bytes memory proposalData, string memory description)\n        public\n        onlyManager\n        returns (uint256)\n    {\n        require(\n            getVotes(_msgSender(), block.number - 1) >= proposalThreshold(),\n            \"Governor: proposer votes below proposal threshold\"\n        );\n\n        uint256 proposalId = hashProposalWithModule(address(module), proposalData, keccak256(bytes(description)));\n\n        ProposalCore storage proposal = _proposals[proposalId];\n        require(proposal.voteStart.isUnset(), \"Governor: proposal already exists\");\n\n        uint64 snapshot = block.number.toUint64() + votingDelay().toUint64();\n        uint64 deadline = snapshot + votingPeriod().toUint64();\n\n        proposal.voteStart.setDeadline(snapshot);\n        proposal.voteEnd.setDeadline(deadline);\n        proposal.votingModule = address(module);\n\n        emit ProposalCreated(proposalId, _msgSender(), address(module), proposalData, snapshot, deadline, description);\n\n        module.propose(proposalId, proposalData);\n\n        return proposalId;\n    }\n\n    /**\n     * Executes a proposal via a custom voting module. See {IGovernor-execute}.\n     *\n     * @param module The address of the voting module to use for this proposal.\n     * @param proposalData The proposal data to pass to the voting module.\n     * @param descriptionHash The hash of the proposal description.\n     */\n    function executeWithModule(VotingModule module, bytes memory proposalData, bytes32 descriptionHash)\n        public\n        payable\n        returns (uint256)\n    {\n        uint256 proposalId = hashProposalWithModule(address(module), proposalData, descriptionHash);\n\n        ProposalState status = state(proposalId);\n        require(\n            status == ProposalState.Succeeded || status == ProposalState.Queued, \"Governor: proposal not successful\"\n        );\n        _proposals[proposalId].executed = true;\n\n        emit ProposalExecuted(proposalId);\n\n        (address[] memory targets, uint256[] memory values, bytes[] memory calldatas) =\n            module._formatExecuteParams(proposalId, proposalData);\n\n        _beforeExecute(proposalId, targets, values, calldatas, descriptionHash);\n        _execute(proposalId, targets, values, calldatas, descriptionHash);\n        _afterExecute(proposalId, targets, values, calldatas, descriptionHash);\n\n        return proposalId;\n    }\n\n    /**\n     * Cancel a proposal with a custom voting module. See {IGovernor-_cancel}.\n     *\n     * @param module The address of the voting module to use for this proposal.\n     * @param proposalData The proposal data to pass to the voting module.\n     * @param descriptionHash The hash of the proposal description.\n     */\n    function cancelWithModule(VotingModule module, bytes memory proposalData, bytes32 descriptionHash)\n        public\n        onlyManager\n        returns (uint256)\n    {\n        uint256 proposalId = hashProposalWithModule(address(module), proposalData, descriptionHash);\n        ProposalState status = state(proposalId);\n\n        require(\n            status != ProposalState.Canceled && status != ProposalState.Expired && status != ProposalState.Executed,\n            \"Governor: proposal not active\"\n        );\n        _proposals[proposalId].canceled = true;\n\n        emit ProposalCanceled(proposalId);\n\n        return proposalId;\n    }\n\n    /**\n     * @dev Updated internal vote casting mechanism which allows delegating logic to custom voting module. See {IGovernor-_castVote}.\n     */\n    function _castVote(uint256 proposalId, address account, uint8 support, string memory reason, bytes memory params)\n        internal\n        override\n        returns (uint256)\n    {\n        ProposalCore memory proposal = _proposals[proposalId];\n        require(state(proposalId) == ProposalState.Active, \"Governor: vote not currently active\");\n\n        uint256 weight = _getVotes(account, proposal.voteStart.getDeadline(), params);\n\n        if (proposal.votingModule != address(0)) {\n            VotingModule(proposal.votingModule)._countVote(proposalId, account, support, weight, params);\n        } else {\n            _countVote(proposalId, account, support, weight, params);\n        }\n\n        if (params.length == 0) {\n            emit VoteCast(account, proposalId, support, weight, reason);\n        } else {\n            emit VoteCastWithParams(account, proposalId, support, weight, reason, params);\n        }\n\n        return weight;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * COUNTING_MODE with added `params=modules` options to indicate support for external voting modules. See {IGovernor-COUNTING_MODE}.\n     */\n    function COUNTING_MODE()\n        public\n        pure\n        virtual\n        override(GovernorCountingSimpleUpgradeableV2, IGovernorUpgradeable)\n        returns (string memory)\n    {\n        return \"support=bravo&quorum=against,for,abstain&params=modules\";\n    }\n\n    /**\n     * @dev Updated `hasVoted` which allows delegating logic to custom voting module. See {IGovernor-hasVoted}.\n     */\n    function hasVoted(uint256 proposalId, address account)\n        public\n        view\n        virtual\n        override(GovernorCountingSimpleUpgradeableV2, IGovernorUpgradeable)\n        returns (bool)\n    {\n        address votingModule = _proposals[proposalId].votingModule;\n        if (votingModule != address(0)) {\n            return VotingModule(votingModule).hasVoted(proposalId, account);\n        }\n\n        return super.hasVoted(proposalId, account);\n    }\n\n    /**\n     * @dev Updated `_quorumReached` which allows delegating logic to custom voting module. See {IGovernor-_quorumReached}.\n     */\n    function _quorumReached(uint256 proposalId)\n        internal\n        view\n        virtual\n        override(GovernorCountingSimpleUpgradeableV2, GovernorUpgradeableV2)\n        returns (bool)\n    {\n        ProposalCore memory proposal = _proposals[proposalId];\n        if (proposal.votingModule != address(0)) {\n            return\n                VotingModule(proposal.votingModule)._quorumReached(proposalId, quorum(proposal.voteStart.getDeadline()));\n        }\n\n        (uint256 againstVotes, uint256 forVotes, uint256 abstainVotes) = proposalVotes(proposalId);\n\n        return quorum(proposalSnapshot(proposalId)) <= againstVotes + forVotes + abstainVotes;\n    }\n\n    /**\n     * @dev Updated `_voteSucceeded` which allows delegating logic to custom voting module. See {Governor-_voteSucceeded}.\n     */\n    function _voteSucceeded(uint256 proposalId)\n        internal\n        view\n        virtual\n        override(GovernorCountingSimpleUpgradeableV2, GovernorUpgradeableV2)\n        returns (bool)\n    {\n        address votingModule = _proposals[proposalId].votingModule;\n        if (votingModule != address(0)) {\n            return VotingModule(votingModule)._voteSucceeded(proposalId);\n        }\n\n        return super._voteSucceeded(proposalId);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * Calculate `proposalId` hashing similarly to `hashProposal` but based on `module` and `proposalData`.\n     * See {IGovernor-hashProposal}.\n     *\n     * @param module The address of the voting module to use for this proposal.\n     * @param proposalData The proposal data to pass to the voting module.\n     * @param descriptionHash The hash of the proposal description.\n     * @return The id of the proposal.\n     */\n    function hashProposalWithModule(address module, bytes memory proposalData, bytes32 descriptionHash)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        return uint256(keccak256(abi.encode(address(this), module, proposalData, descriptionHash)));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                   V2\n    //////////////////////////////////////////////////////////////*/\n\n    modifier onlyManager() {\n        require(msg.sender == manager, \"Only the manager can call this function\");\n        _;\n    }\n\n    function initialize(IVotesUpgradeable _votingToken, address _manager) public initializer {\n        __Governor_init(\"Optimism\");\n        __GovernorCountingSimple_init();\n        __GovernorVotes_init(_votingToken);\n        __GovernorVotesQuorumFraction_init({quorumNumeratorValue: 30});\n        __GovernorSettings_init({initialVotingDelay: 6575, initialVotingPeriod: 46027, initialProposalThreshold: 0});\n\n        manager = _manager;\n    }\n\n    function _execute(\n        uint256, /* proposalId */\n        address[] memory, /* targets */\n        uint256[] memory, /* values */\n        bytes[] memory, /* calldatas */\n        bytes32 /*descriptionHash*/\n    ) internal view override onlyManager {\n        // Execution is skipped\n    }\n\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public override onlyManager returns (uint256) {\n        return super.propose(targets, values, calldatas, description);\n    }\n\n    function proposalThreshold()\n        public\n        view\n        override(GovernorSettingsUpgradeableV2, GovernorUpgradeableV2)\n        returns (uint256)\n    {\n        return GovernorSettingsUpgradeableV2.proposalThreshold();\n    }\n\n    function quorumDenominator() public view virtual override returns (uint256) {\n        // Configurable to 3 decimal points of percentage\n        return 100_000;\n    }\n\n    function setProposalDeadline(uint256 proposalId, uint64 deadline) public onlyManager {\n        _proposals[proposalId].voteEnd.setDeadline(deadline);\n        emit ProposalDeadlineUpdated(proposalId, deadline);\n    }\n\n    function setVotingDelay(uint256 newVotingDelay) public override onlyManager {\n        _setVotingDelay(newVotingDelay);\n    }\n\n    function setVotingPeriod(uint256 newVotingPeriod) public override onlyManager {\n        _setVotingPeriod(newVotingPeriod);\n    }\n\n    function setProposalThreshold(uint256 newProposalThreshold) public override onlyManager {\n        _setProposalThreshold(newProposalThreshold);\n    }\n\n    function updateQuorumNumerator(uint256 newQuorumNumerator) external override onlyManager {\n        _updateQuorumNumerator(newQuorumNumerator);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                   V3\n    //////////////////////////////////////////////////////////////*/\n\n    function cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public onlyManager returns (uint256) {\n        return _cancel(targets, values, calldatas, descriptionHash);\n    }\n}"
    },
    {
      "filename": "src/modules/ApprovalVotingModule.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {VotingModule} from \"./VotingModule.sol\";\nimport {SafeCastLib} from \"@solady/utils/SafeCastLib.sol\";\n\nenum VoteType {\n    For,\n    Abstain\n}\n\nenum PassingCriteria {\n    Threshold,\n    TopChoices\n}\n\nstruct ExecuteParams {\n    address targets;\n    uint256 values;\n    bytes calldatas;\n}\n\nstruct ProposalVotes {\n    uint128 forVotes;\n    uint128 abstainVotes;\n}\n\nstruct ProposalSettings {\n    uint8 maxApprovals;\n    uint8 criteria;\n    address budgetToken;\n    uint128 criteriaValue;\n    uint128 budgetAmount;\n}\n\nstruct ProposalOption {\n    address[] targets;\n    uint256[] values;\n    bytes[] calldatas;\n    string description;\n}\n\nstruct Proposal {\n    address governor;\n    uint128[] optionVotes;\n    ProposalVotes votes;\n    ProposalOption[] options;\n    ProposalSettings settings;\n}\n\ncontract ApprovalVotingModule is VotingModule {\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    error MaxChoicesExceeded();\n    error MaxApprovalsExceeded();\n    error OptionsNotStrictlyAscending();\n\n    /*//////////////////////////////////////////////////////////////\n                               LIBRARIES\n    //////////////////////////////////////////////////////////////*/\n\n    using SafeCastLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                           IMMUTABLE STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * Defines the encoding for the expected `proposalData` in `propose`.\n     * Encoding: `(ProposalOption[], ProposalSettings)`\n     *\n     * @dev Can be used by clients to interact with modules programmatically without prior knowledge\n     * on expected types.\n     */\n    string public constant override PROPOSAL_DATA_ENCODING =\n        \"((address[] targets,uint256[] values,bytes[] calldatas,string description)[] proposalOptions,(uint8 maxApprovals,uint8 criteria,address budgetToken,uint128 criteriaValue,uint128 budgetAmount) proposalSettings)\";\n\n    /**\n     * Defines the encoding for the expected `params` in `_countVote`.\n     * Encoding: `uint256[]`\n     *\n     * @dev Can be used by clients to interact with modules programmatically without prior knowledge\n     * on expected types.\n     */\n    string public constant override VOTE_PARAMS_ENCODING = \"uint256[] options\";\n\n    /*//////////////////////////////////////////////////////////////\n                                STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 proposalId => Proposal) public _proposals;\n    mapping(uint256 proposalId => mapping(address account => uint8 votes)) public _accountVotes;\n\n    /*//////////////////////////////////////////////////////////////\n                            WRITE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * Save settings and options for a new proposal.\n     *\n     * @param proposalId The id of the proposal.\n     * @param proposalData The proposal data encoded as `PROPOSAL_DATA_ENCODING`.\n     */\n    function propose(uint256 proposalId, bytes memory proposalData) external override {\n        if (_proposals[proposalId].governor != address(0)) revert ExistingProposal();\n\n        (ProposalOption[] memory proposalOptions, ProposalSettings memory proposalSettings) =\n            abi.decode(proposalData, (ProposalOption[], ProposalSettings));\n\n        uint256 optionsLength = proposalOptions.length;\n        if (optionsLength == 0 || optionsLength > type(uint8).max) revert InvalidParams();\n        if (proposalSettings.criteria == uint8(PassingCriteria.TopChoices)) {\n            if (proposalSettings.criteriaValue > optionsLength) revert MaxChoicesExceeded();\n        }\n\n        unchecked {\n            // Ensure proposal params of each option have the same length between themselves\n            ProposalOption memory option;\n            for (uint256 i; i < optionsLength; ++i) {\n                option = proposalOptions[i];\n                if (option.targets.length != option.values.length || option.targets.length != option.calldatas.length) {\n                    revert InvalidParams();"
    }
  ]
}