{
  "Title": "Allowed non-standard ERC20 tokens should be explicitly specified",
  "Content": "Since non-standard ERC20 tokens are allowed to be used in markets, the behavior of these tokens should be explicitly specified in comments or the README. All ERC20 tokens that make up markets should abide by these specified conditions in order to be accepted as a market. Certain non-standard implementations may cause undesired effects on the dYdX contracts.\n\n\nAs mentioned in the comments in the code, “a custom ERC20 interface is used in order to deal with tokens that don’t adhere strictly to the ERC20 standard (for example tokens that don’t return a boolean value on success)”. Because of this lack of return value, the code allows for a number of non-standard ERC20 implementations, rather than just the one mentioned in the comments.\n\n\nAn example of potentially vulnerable code can be found in [Token.sol](https://github.com/dydxprotocol/solo/blob/17df84db351d5438e1b7437572722b4f52c8b2b4/contracts/protocol/lib/Token.sol#L140). `checkSuccess()` will return `true` if the specific ERC20 implementation neither throws nor returns `false` on `transfer()`, `transferFrom()`, or `approve()`, regardless of the outcome of the transaction.\n\n\nThis ERC20 implementation would cause issues with Dapps other than dYdX, so it is expected that this type of token never makes it into production on the main Ethereum network. Nevertheless, we suggest being explicit about the types of tokens that are allowed to make up a market and checking that tokens meet these conditions prior to being accepted as a market.\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/protocol/lib/Token.sol",
      "content": "/*\n\n    Copyright 2018 dYdX Trading Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.4;\n\nimport { Require } from \"./Require.sol\";\nimport { IErc20 } from \"../interfaces/IErc20.sol\";\n\n\n/**\n * @title Token\n * @author dYdX\n *\n * This library contains basic functions for interacting with ERC20 tokens. Modified to work with\n * tokens that don't adhere strictly to the ERC20 standard (for example tokens that don't return a\n * boolean value on success).\n */\nlibrary Token {\n\n    // ============ Constants ============\n\n    bytes32 constant FILE = \"Token\";\n\n    // ============ Library Functions ============\n\n    function balanceOf(\n        address token,\n        address owner\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        return IErc20(token).balanceOf(owner);\n    }\n\n    function allowance(\n        address token,\n        address owner,\n        address spender\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        return IErc20(token).allowance(owner, spender);\n    }\n\n    function approve(\n        address token,\n        address spender,\n        uint256 amount\n    )\n        internal\n    {\n        IErc20(token).approve(spender, amount);\n\n        Require.that(\n            checkSuccess(),\n            FILE,\n            \"Approve failed\"\n        );\n    }\n\n    function approveMax(\n        address token,\n        address spender\n    )\n        internal\n    {\n        approve(\n            token,\n            spender,\n            uint256(-1)\n        );\n    }\n\n    function transfer(\n        address token,\n        address to,\n        uint256 amount\n    )\n        internal\n    {\n        if (amount == 0 || to == address(this)) {\n            return;\n        }\n\n        IErc20(token).transfer(to, amount);\n\n        Require.that(\n            checkSuccess(),\n            FILE,\n            \"Transfer failed\"\n        );\n    }\n\n    function transferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 amount\n    )\n        internal\n    {\n        if (amount == 0 || to == from) {\n            return;\n        }\n\n        IErc20(token).transferFrom(from, to, amount);\n\n        Require.that(\n            checkSuccess(),\n            FILE,\n            \"TransferFrom failed\"\n        );\n    }\n\n    // ============ Private Functions ============\n\n    /**\n     * Checks the return value of the previous function up to 32 bytes. Returns true if the previous\n     * function returned 0 bytes or 32 bytes that are not all-zero.\n     */\n    function checkSuccess(\n    )\n        private\n        pure\n        returns (bool)\n    {\n        uint256 returnValue = 0;\n\n        /* solium-disable-next-line security/no-inline-assembly */\n        assembly {\n            // check number of bytes returned from last function call\n            switch returndatasize\n\n            // no bytes returned: assume success\n            case 0x0 {\n                returnValue := 1\n            }\n\n            // 32 bytes returned: check if non-zero\n            case 0x20 {\n                // copy 32 bytes into scratch space\n                returndatacopy(0x0, 0x0, 0x20)\n\n                // load those bytes into returnValue\n                returnValue := mload(0x0)\n            }\n\n            // not sure what was returned: dont mark as success\n            default { }\n        }\n\n        return returnValue != 0;\n    }\n}"
    }
  ]
}