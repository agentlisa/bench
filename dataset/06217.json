{
  "Title": "[H-06] BalancerStrategy `_withdraw` uses `BPT_IN_FOR_EXACT_TOKENS_OUT` which can be attack to cause loss to all depositors",
  "Content": "\nWithdrawals can be manipulated to cause complete loss of all tokens.\n\nThe BalancerStrategy accounts for user deposits in terms of the BPT shares they contributed, however, for withdrawals, it estimates the amount of BPT to burn based on the amount of ETH to withdraw, which can be manipulated to cause a total loss to the Strategy.\n\nDeposits of weth are done via userData.joinKind set to `1`, which is extracted here in the generic Pool Logic:<br>\n<https://etherscan.io/address/0x5c6ee304399dbdb9c8ef030ab642b10820db8f56#code#F24#L49>\n\nThe interpretation (by convention is shown here):<br>\n<https://etherscan.io/address/0x5c6ee304399dbdb9c8ef030ab642b10820db8f56#code#F24#L49>\n```\n    enum JoinKind { INIT, EXACT_TOKENS_IN_FOR_BPT_OUT, TOKEN_IN_FOR_EXACT_BPT_OUT }\n```\n\nWhich means that the deposit is using `EXACT_TOKENS_IN_FOR_BPT_OUT` which is safe in most circumstances (Pool Properly Balanced, with minimum liquidity).\n\n### `BPT_IN_FOR_EXACT_TOKENS_OUT` is vulnerable to manipulation\n\n`_vaultWithdraw` uses the following logic to determine how many BPT to burn:\n\n<https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/05ba7108a83c66dada98bc5bc75cf18004f2a49b/contracts/balancer/BalancerStrategy.sol#L224-L242>\n\n```solidity\nuint256[] memory minAmountsOut = new uint256[](poolTokens.length);\n        for (uint256 i = 0; i < poolTokens.length; i++) {\n            if (poolTokens[i] == address(wrappedNative)) {\n                minAmountsOut[i] = amount;\n                index = int256(i);\n            } else {\n                minAmountsOut[i] = 0;\n            }\n        }\n\n        IBalancerVault.ExitPoolRequest memory exitRequest;\n        exitRequest.assets = poolTokens;\n        exitRequest.minAmountsOut = minAmountsOut;\n        exitRequest.toInternalBalance = false;\n        exitRequest.userData = abi.encode(\n            2,\n            exitRequest.minAmountsOut,\n            pool.balanceOf(address(this))\n        );\n```\n\nThis query logic is using `2`, which Maps out to `BPT_IN_FOR_EXACT_TOKENS_OUT` which means Exact Out, with any (all) BPT IN, this means that the swapper is willing to burn all tokens:<br>\n<https://etherscan.io/address/0x5c6ee304399dbdb9c8ef030ab642b10820db8f56#code#F24#L51>\n```\n        enum ExitKind { EXACT_BPT_IN_FOR_ONE_TOKEN_OUT, EXACT_BPT_IN_FOR_TOKENS_OUT, BPT_IN_FOR_EXACT_TOKENS_OUT }\n```\n\nThis meets the 2 prerequisite for stealing value from the vault by socializing loss due to single sided exposure:\n\n*   1.  The request is for at least `amount` `WETH`\n*   2.  The request is using `BPT_IN_FOR_EXACT_TOKENS_OUT`\n\nWhich means the strategy will accept any slippage, in this case 100%, causing it to take a total loss for the goal of allowing a withdrawal, at the advantage of the attacker and the detriment of all other depositors.\n\n### POC\n\nThe requirement to trigger the loss are as follows:\n\n*   Deposit to have some amount of BPTs deposited into the strategy\n*   Imbalance the Pool to cause pro-rata amount of single token to require burning a lot more BPTs\n*   Withdraw from the strategy, the strategy will burn all of the BPTs it owns (more than the shares)\n*   Rebalance the pool with the excess value burned from the strategy\n\n### Further Details\n\nSpecifically, in withdrawing one Depositor Shares, the request would end up burning EVERYONEs shares, causing massive loss to everyone.\n\nThis has already been exploited and explained in Yearns Disclosure:\n\n<https://github.com/yearn/yearn-security/blob/master/disclosures/2022-01-30.md>\n\nMore specifically this finding can cause a total loss, while trying to withdraw tokens for a single user, meaning that an attacker can setup the pool to cause a complete loss to all other stakers.\n\n### Mitigation Step\n\nUse `EXACT_BPT_IN_FOR_TOKENS_OUT` and denominate the Strategy in LP tokens to avoid being attacked via single sided exposure.\n\n**[cryptotechmaker (Tapioca) confirmed](https://github.com/code-423n4/2023-07-tapioca-findings/issues/1449#issuecomment-1707830222)**\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-07-tapioca",
  "Code": [
    {
      "filename": "contracts/balancer/BalancerStrategy.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"@boringcrypto/boring-solidity/contracts/BoringOwnable.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\n\nimport \"tapioca-sdk/dist/contracts/YieldBox/contracts/strategies/BaseStrategy.sol\";\nimport \"./interfaces/IBalancerVault.sol\";\nimport \"./interfaces/IBalancerPool.sol\";\nimport \"./interfaces/IBalancerHelpers.sol\";\n\n/*\n\n__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\\\\\____/\\\\\\\\\\\\\\\\\\\\\\_______/\\\\\\\\\\_____________/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\____        \n _\\///////\\\\\\/////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__\\/\\\\\\/////////\\\\\\_\\/////\\\\\\///______/\\\\\\///\\\\\\________/\\\\\\////////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__       \n  _______\\/\\\\\\________/\\\\\\/////////\\\\\\_\\/\\\\\\_______\\/\\\\\\_____\\/\\\\\\_______/\\\\\\/__\\///\\\\\\____/\\\\\\/____________/\\\\\\/////////\\\\\\_      \n   _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/______\\/\\\\\\______/\\\\\\______\\//\\\\\\__/\\\\\\_____________\\/\\\\\\_______\\/\\\\\\_     \n    _______\\/\\\\\\_______\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\/////////________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_____________\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_    \n     _______\\/\\\\\\_______\\/\\\\\\/////////\\\\\\_\\/\\\\\\_________________\\/\\\\\\_____\\//\\\\\\______/\\\\\\__\\//\\\\\\____________\\/\\\\\\/////////\\\\\\_   \n      _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_________________\\/\\\\\\______\\///\\\\\\__/\\\\\\_____\\///\\\\\\__________\\/\\\\\\_______\\/\\\\\\_  \n       _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\______________/\\\\\\\\\\\\\\\\\\\\\\____\\///\\\\\\\\\\/________\\////\\\\\\\\\\\\\\\\\\_\\/\\\\\\_______\\/\\\\\\_ \n        _______\\///________\\///________\\///__\\///______________\\///////////_______\\/////_____________\\/////////__\\///________\\///__\n*/\n\ncontract BalancerStrategy is BaseERC20Strategy, BoringOwnable, ReentrancyGuard {\n    using BoringERC20 for IERC20;\n\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n    IERC20 public immutable wrappedNative;\n    IERC20 public immutable bal;\n\n    bytes32 public poolId;\n    IBalancerVault public immutable vault;\n    IBalancerPool public immutable pool; //lp token\n    IBalancerHelpers public immutable helpers;\n    address[] public rewardTokens;\n\n    /// @notice Queues tokens up to depositThreshold\n    /// @dev When the amount of tokens is greater than the threshold, a deposit operation to Yearn is performed\n    uint256 public depositThreshold;\n\n    uint256 private _cachedCalculatedAmount;\n\n    // ************** //\n    // *** EVENTS *** //\n    // ************** //\n    event RewardTokens(uint256 _count);\n    event DepositThreshold(uint256 _old, uint256 _new);\n    event AmountQueued(uint256 amount);\n    event AmountDeposited(uint256 amount);\n    event AmountWithdrawn(address indexed to, uint256 amount);\n\n    constructor(\n        IYieldBox _yieldBox,\n        address _token,\n        address _vault,\n        bytes32 _poolId,\n        address _bal,\n        address _helpers\n    ) BaseERC20Strategy(_yieldBox, _token) {\n        wrappedNative = IERC20(_token);\n        bal = IERC20(_bal);\n\n        vault = IBalancerVault(_vault);\n        poolId = _poolId;\n\n        (address _stablePool, ) = vault.getPool(_poolId);\n        pool = IBalancerPool(_stablePool);\n\n        helpers = IBalancerHelpers(_helpers);\n\n        wrappedNative.approve(_vault, type(uint256).max);\n        IERC20(address(pool)).approve(_vault, type(uint256).max);\n    }\n\n    // ********************** //\n    // *** VIEW FUNCTIONS *** //\n    // ********************** //\n    /// @notice Returns the name of this strategy\n    function name() external pure override returns (string memory name_) {\n        return \"Balancer\";\n    }\n\n    /// @notice Returns the description of this strategy\n    function description()\n        external\n        pure\n        override\n        returns (string memory description_)\n    {\n        return \"Balancer strategy for wrapped native assets\";\n    }\n\n    /// @notice returns compounded amounts in wrappedNative\n    function compoundAmount() external pure returns (uint256 result) {\n        return 0;\n    }\n\n    // *********************** //\n    // *** OWNER FUNCTIONS *** //\n    // *********************** //\n    /// @notice Sets the deposit threshold\n    /// @param amount The new threshold amount\n    function setDepositThreshold(uint256 amount) external onlyOwner {\n        emit DepositThreshold(depositThreshold, amount);\n        depositThreshold = amount;\n    }\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n    function compound(bytes memory) public {}\n\n    /// @notice withdraws everythig from the strategy\n    function emergencyWithdraw() external onlyOwner returns (uint256 result) {\n        uint256 toWithdraw = updateCache();\n        toWithdraw = toWithdraw - (toWithdraw * 50) / 10_000; //0.5%\n\n        result = _vaultWithdraw(toWithdraw);\n    }\n\n    // ************************* //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n    function _currentBalance() internal view override returns (uint256 amount) {\n        uint256 queued = wrappedNative.balanceOf(address(this));\n\n        return _cachedCalculatedAmount + queued;\n    }\n\n    /// @dev deposits to Balancer or queues tokens if the 'depositThreshold' has not been met yet\n    ///      - when depositing to Balancer, cToken is minted to this contract\n    function _deposited(uint256 amount) internal override nonReentrant {\n        uint256 queued = wrappedNative.balanceOf(address(this));\n        if (queued > depositThreshold) {\n            _vaultDeposit(queued);\n            emit AmountDeposited(queued);\n        }\n        emit AmountQueued(amount);\n\n        updateCache();\n    }\n\n    function _vaultDeposit(uint256 amount) private {\n        uint256 lpBalanceBefore = pool.balanceOf(address(this));\n\n        (address[] memory poolTokens, , ) = vault.getPoolTokens(poolId);\n\n        int256 index = -1;\n        uint256[] memory maxAmountsIn = new uint256[](poolTokens.length);\n        for (uint256 i = 0; i < poolTokens.length; i++) {\n            if (poolTokens[i] == address(wrappedNative)) {\n                maxAmountsIn[i] = amount;\n                index = int256(i);\n            } else {\n                maxAmountsIn[i] = 0;\n            }\n        }\n\n        IBalancerVault.JoinPoolRequest memory joinPoolRequest;\n        joinPoolRequest.assets = poolTokens;\n        joinPoolRequest.maxAmountsIn = maxAmountsIn;\n        joinPoolRequest.fromInternalBalance = false;\n        joinPoolRequest.userData = abi.encode(1, maxAmountsIn);\n\n        (uint256 bptOut, ) = helpers.queryJoin(\n            poolId,\n            address(this),\n            address(this),\n            joinPoolRequest\n        );\n        bptOut = bptOut - (bptOut * 50) / 10_000; //0.5%\n\n        joinPoolRequest.userData = abi.encode(2, bptOut, uint256(index));\n\n        vault.joinPool(poolId, address(this), address(this), joinPoolRequest);\n        uint256 lpBalanceAfter = pool.balanceOf(address(this));\n\n        require(\n            lpBalanceAfter > lpBalanceBefore,\n            \"BalancerStrategy: vault deposit failed\"\n        );\n    }\n\n    /// @dev burns yToken in exchange of Token and withdraws from Yearn Vault\n    function _withdraw(\n        address to,\n        uint256 amount\n    ) internal override nonReentrant {\n        uint256 available = _currentBalance();\n        require(available >= amount, \"BalancerStrategy: amount not valid\");\n\n        uint256 queued = wrappedNative.balanceOf(address(this));\n        if (amount > queued) {\n            uint256 pricePerShare = pool.getRate();\n            uint256 decimals = IStrictERC20(address(pool)).decimals();\n            uint256 toWithdraw = (((amount - queued) * (10 ** decimals)) /\n                pricePerShare);\n\n            _vaultWithdraw(toWithdraw);\n        }\n\n        require(\n            amount <= wrappedNative.balanceOf(address(this)),\n            \"BalancerStrategy: not enough\"\n        );\n        wrappedNative.safeTransfer(to, amount);\n        updateCache();\n\n        emit AmountWithdrawn(to, amount);\n    }\n\n    function _vaultWithdraw(uint256 amount) private returns (uint256) {\n        uint256 wrappedNativeBalanceBefore = wrappedNative.balanceOf(\n            address(this)\n        );\n        (address[] memory poolTokens, , ) = vault.getPoolTokens(poolId);\n        int256 index = -1;\n        uint256[] memory minAmountsOut = new uint256[](poolTokens.length);\n        for (uint256 i = 0; i < poolTokens.length; i++) {\n            if (poolTokens[i] == address(wrappedNative)) {\n                minAmountsOut[i] = amount;\n                index = int256(i);\n            } else {\n                minAmountsOut[i] = 0;\n            }\n        }\n\n        IBalancerVault.ExitPoolRequest memory exitRequest;\n        exitRequest.assets = poolTokens;\n        exitRequest.minAmountsOut = minAmountsOut;\n        exitRequest.toInternalBalance = false;\n        exitRequest.userData = abi.encode(\n            2,\n            exitRequest.minAmountsOut,\n            pool.balanceOf(address(this))\n        );\n\n        (uint256 bptIn, ) = helpers.queryExit(\n            poolId,\n            address(this),\n            payable(this),\n            exitRequest\n        );\n        bptIn = bptIn + (bptIn * 250) / 10_000; //2.5%\n        uint256 maxBpt = pool.balanceOf(address(this));\n        if (bptIn > maxBpt) {\n            bptIn = maxBpt;\n        }\n        exitRequest.userData = abi.encode(0, bptIn, index);\n\n        vault.exitPool(poolId, address(this), payable(this), exitRequest);\n\n        uint256 wrappedNativeBalanceAfter = wrappedNative.balanceOf(\n            address(this)\n        );\n\n        require(\n            wrappedNativeBalanceAfter > wrappedNativeBalanceBefore,\n            \"BalancerStrategy: vault withdrawal failed\"\n        );\n\n        return wrappedNativeBalanceAfter - wrappedNativeBalanceBefore;\n    }\n\n    function updateCache() public returns (uint256) {\n        uint256 lpBalance = pool.balanceOf(address(this));\n\n        (address[] memory poolTokens, , ) = vault.getPoolTokens(poolId);\n        uint256 index;\n        uint256[] memory minAmountsOut = new uint256[](poolTokens.length);\n        for (uint256 i = 0; i < poolTokens.length; i++) {\n            if (poolTokens[i] == address(wrappedNative)) {\n                index = i;\n            }\n            minAmountsOut[i] = 0;\n        }\n\n        IBalancerVault.ExitPoolRequest memory exitRequest;\n        exitRequest.assets = poolTokens;\n        exitRequest.minAmountsOut = minAmountsOut;\n        exitRequest.toInternalBalance = false;\n        exitRequest.userData = abi.encode(0, lpBalance, index);\n\n        (, uint256[] memory amountsOut) = helpers.queryExit(\n            poolId,\n            address(this),\n            address(this),\n            exitRequest\n        );\n\n        _cachedCalculatedAmount = amountsOut[index];\n        return amountsOut[index];\n    }\n\n    receive() external payable {}\n}"
    }
  ]
}