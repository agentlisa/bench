{
  "Title": "[M-01] Ether can be locked in the `PoolFactory` contract without a way to retrieve it",
  "Content": "_Submitted by broccolirob_\n\nIf a borrower calls the `createPool` function with a non-zero value, but also includes an ERC20 token address for `_collateralToken`, then the Ether value sent will be locked in the `PoolFactory` contract forever.\n\n*   [createPool L260-317](https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/Pool/PoolFactory.sol#L260-L317)\n\nIn the `_createPool` function, a `_collateralToken` address other than the zero address will set the `amount` variable to zero. That `amount` variable will be passed to `create2` which will send 0 wei to the newly created `Pool` contract.\n\n```solidity\n// _createPool L349\nuint256 amount = _collateralToken == address(0) ? _collateralAmount : 0;\n```\n\n#### Impact\n\nA borrower can accidentally lock Ether in the `PoolFactory` without the ability to retrieve it.\n\n#### Proof of Concept\n\nA borrower reuses a script they made to create a pool and deposit collateral. They intend to deposit Ether as collateral so they send value with the transaction, but forget to change the `_collateralToken` address to address(0). The `Pool` contract will be deployed using the `_collateralToken`, and will lock the Ether sent in the `PoolFactory`\n\n#### Tools Used\n\nManual analysis and Hardhat.\n\n#### Recommended Mitigation Steps\n\nIf msg.value is greater than 0, make sure the `_collateralToken` address is set to address(0).\n\n\n**[ritik99 (Sublime) disputed and disagreed with severity](https://github.com/code-423n4/2021-12-sublime-findings/issues/168#issuecomment-1001018859):**\n > We will add this check but the scenario laid out is more about sanity checks on the side of the end-user. Assets are not stolen or compromised directly but because of user error. Such cases are better handled via UI/UX. We would suggest a (1) Low rating given the likelihood\n\n**[0xean (judge) commented](https://github.com/code-423n4/2021-12-sublime-findings/issues/168#issuecomment-1018049928):**\n > Marking down to medium risk based on the c4 documentation and some external requirements on how this would have to occur. \n> \n> `\n> 2 â€” Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n> `\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2021-12-sublime-contest",
  "Code": [
    {
      "filename": "contracts/Pool/PoolFactory.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport '../Proxy.sol';\nimport '../interfaces/IPoolFactory.sol';\nimport '../interfaces/IPool.sol';\nimport '../interfaces/IVerification.sol';\nimport '../interfaces/IStrategyRegistry.sol';\nimport '../interfaces/IRepayment.sol';\nimport '../interfaces/IPriceOracle.sol';\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\n\n/**\n * @title Pool Factory contract with methods for handling different pools\n * @notice Implements the functions related to Pool (CRUD)\n * @author Sublime\n */\ncontract PoolFactory is Initializable, OwnableUpgradeable, IPoolFactory {\n    /*\n     * @notice Used to define limits for the Pool parameters\n     * @param min the minimum threshold for the parameter\n     * @param max the maximum threshold for the parameter\n     */\n    struct Limits {\n        uint256 min;\n        uint256 max;\n    }\n\n    /**\n     * @notice function definition of the pool contract\n     */\n    bytes4 public poolInitFuncSelector; //  bytes4(keccak256(\"initialize(uint256,address,address,address,uint256,uint256,uint256,uint256,bool)\"))\n\n    /**\n     * @notice address of the latest implementation of the pool logic\n     */\n    address public poolImpl;\n\n    /**\n     * @notice address of the contract storing the user registry\n     */\n    address public override userRegistry;\n\n    /**\n     * @notice address of the contract storing the strategy registry\n     */\n    address public strategyRegistry;\n\n    /**\n     * @notice address of the latest implementation of the extension logic\n     */\n    address public override extension;\n\n    /**\n     * @notice address of the latest implementation of the repayment logic\n     */\n    address public override repaymentImpl;\n\n    /**\n     * @notice address of the latest implementation of the pool logic\n     */\n    address public override priceOracle;\n\n    /**\n     * @notice address of the savings account used\n     */\n    address public override savingsAccount;\n\n    /**\n     * @notice the time interval for the lenders to make contributions to pool\n     */\n    uint256 public override collectionPeriod;\n\n    /**\n     * @notice the time interval for the borrower to withdraw the loan from pool\n     */\n    uint256 public override loanWithdrawalDuration;\n\n    /**\n     * @notice the time interval for the active stage of the margin call\n     */\n    uint256 public override marginCallDuration;\n\n    /**\n     * @notice Fraction of the requested amount for pool below which pool is cancelled\n     */\n    uint256 public override minBorrowFraction;\n\n    /**\n     * @notice the fraction used for calculating the liquidator reward\n     */\n    uint256 public override liquidatorRewardFraction;\n\n    /**\n     * @notice the fraction used for calculating the penalty when the pool is cancelled\n     */\n    uint256 public override poolCancelPenaltyMultiple;\n\n    /**\n     * @notice Contract Address of no yield\n     */\n    address public override noStrategyAddress;\n\n    uint256 protocolFeeFraction;\n    address protocolFeeCollector;\n\n    /*\n     * @notice Used to mark assets supported for borrowing\n     */\n    mapping(address => bool) isBorrowToken;\n\n    /*\n     * @notice Used to mark supported collateral assets\n     */\n    mapping(address => bool) isCollateralToken;\n\n    /**\n     * @notice Used to keep track of valid pool addresses\n     */\n    mapping(address => bool) public override poolRegistry;\n\n    /*\n     * @notice Used to set the min/max borrow amount for Pools\n     */\n    Limits poolSizeLimit;\n\n    /*\n     * @notice Used to set the min/max collateral ratio for Pools\n     */\n    Limits idealCollateralRatioLimit;\n\n    /*\n     * @notice Used to set the min/max borrow rates (interest rate provided by borrower) for Pools\n     */\n    Limits borrowRateLimit;\n\n    /*\n     * @notice used to set the min/max repayment interval for Pools\n     */\n    Limits repaymentIntervalLimit;\n\n    /*\n     * @notice used to set the min/max number of repayment intervals for Pools\n     */\n    Limits noOfRepaymentIntervalsLimit;\n\n    /**\n     * @notice functions affected by this modifier can only be invoked by the Pool\n     */\n    modifier onlyPool() {\n        require(poolRegistry[msg.sender], 'PoolFactory::onlyPool - Only pool can destroy itself');\n        _;\n    }\n\n    /**\n     * @notice functions affected by this modifier can only be invoked by the borrow of the Pool\n     */\n    modifier onlyBorrower(address _verifier) {\n        require(\n            IVerification(userRegistry).isUser(msg.sender, _verifier),\n            'PoolFactory::onlyBorrower - Only a valid Borrower can create Pool'\n        );\n        _;\n    }\n\n    /**\n     * @notice returns the owner of the pool\n     */\n    function owner() public view override(IPoolFactory, OwnableUpgradeable) returns (address) {\n        return OwnableUpgradeable.owner();\n    }\n\n    /**\n     * @notice used to initialize the pool factory\n     * @dev initializer can only be run once\n     * @param _admin address of admin\n     * @param _collectionPeriod period for which lenders can lend for pool\n     * @param _loanWithdrawalDuration period for which lent tokens can be withdrawn after pool starts\n     * @param _marginCallDuration duration of margin call before which collateral ratio has to be maintained\n     * @param _poolInitFuncSelector function signature for initializing pool\n     * @param _liquidatorRewardFraction fraction of liquidation amount which is given to liquidator as reward multiplied by 10**30\n     * @param _poolCancelPenaltyMultiple multiple of borrow rate of pool as penality for cancellation of pool multiplied by 10**30\n     * @param _minBorrowFraction amountCollected/amountRequested for a pool, if less than fraction by pool start time then pool can be cancelled without penality multiplied by 10**30\n     * @param _protocolFeeFraction fraction of amount borrowed in pool which is collected as protocol fee\n     * @param _protocolFeeCollector address where protocol fee is collected\n     * @param _noStrategy address of the no strategy address\n     */\n    function initialize(\n        address _admin,\n        uint256 _collectionPeriod,\n        uint256 _loanWithdrawalDuration,\n        uint256 _marginCallDuration,\n        bytes4 _poolInitFuncSelector,\n        uint256 _liquidatorRewardFraction,\n        uint256 _poolCancelPenaltyMultiple,\n        uint256 _minBorrowFraction,\n        uint256 _protocolFeeFraction,\n        address _protocolFeeCollector,\n        address _noStrategy\n    ) external initializer {\n        {\n            OwnableUpgradeable.__Ownable_init();\n            OwnableUpgradeable.transferOwnership(_admin);\n        }\n        _updateCollectionPeriod(_collectionPeriod);\n        _updateLoanWithdrawalDuration(_loanWithdrawalDuration);\n        _updateMarginCallDuration(_marginCallDuration);\n        _updatepoolInitFuncSelector(_poolInitFuncSelector);\n        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);\n        _updatePoolCancelPenaltyMultiple(_poolCancelPenaltyMultiple);\n        _updateMinBorrowFraction(_minBorrowFraction);\n        _updateProtocolFeeFraction(_protocolFeeFraction);\n        _updateProtocolFeeCollector(_protocolFeeCollector);\n        _updateNoStrategy(_noStrategy);\n    }\n\n    /**\n     * @notice used to setImplementation addresses\n     * @dev used to set some of the contracts pool factory interacts with. only admin can invoke\n     * @param _poolImpl address of the implementation address of pool\n     * @param _repaymentImpl address of the implementation address of repayments\n     * @param _userRegistry address of the user registry where users are verified\n     * @param _strategyRegistry address of the startegy registry where strategies are whitelisted\n     * @param _priceOracle address of the price oracle\n     * @param _savingsAccount address of the savings account contract\n     * @param _extension address of the extension contract for pools\n     */\n    function setImplementations(\n        address _poolImpl,\n        address _repaymentImpl,\n        address _userRegistry,\n        address _strategyRegistry,\n        address _priceOracle,\n        address _savingsAccount,\n        address _extension\n    ) external onlyOwner {\n        _updatePoolLogic(_poolImpl);\n        _updateRepaymentImpl(_repaymentImpl);\n        _updateSavingsAccount(_savingsAccount);\n        _updatedExtension(_extension);\n        _updateUserRegistry(_userRegistry);\n        _updateStrategyRegistry(_strategyRegistry);\n        _updatePriceoracle(_priceOracle);\n    }\n\n    /**\n     * @notice invoked when a new borrow pool is created. deploys a new pool for every borrow request\n     * @param _poolSize loan amount requested\n     * @param _borrowToken borrow asset requested\n     * @param _collateralToken collateral asset requested\n     * @param _idealCollateralRatio ideal pool collateral ratio set by the borrower\n     * @param _borrowRate interest rate provided by the borrower\n     * @param _repaymentInterval interval between the last dates of two repayment cycles\n     * @param _noOfRepaymentIntervals number of repayments to be made during the duration of the loan\n     * @param _poolSavingsStrategy savings strategy selected for the pool collateral\n     * @param _collateralAmount collateral amount deposited\n     * @param _transferFromSavingsAccount if true, initial collateral is transferred from borrower's savings account, if false, borrower transfers initial collateral deposit from wallet\n     * @param _salt random and unique initial seed\n     */\n    function createPool(\n        uint256 _poolSize,\n        uint256 _borrowRate,\n        address _borrowToken,\n        address _collateralToken,\n        uint256 _idealCollateralRatio,\n        uint256 _repaymentInterval,\n        uint256 _noOfRepaymentIntervals,\n        address _poolSavingsStrategy,\n        uint256 _collateralAmount,\n        bool _transferFromSavingsAccount,\n        bytes32 _salt,\n        address _verifier,\n        address _lenderVerifier\n    ) external payable onlyBorrower(_verifier) {\n        if (_collateralToken == address(0)) {\n            require(msg.value == _collateralAmount, 'PoolFactory::createPool - Ether send is different from collateral amount specified');\n        }\n        require(_borrowToken != _collateralToken, 'PoolFactory::createPool - cant borrow the asset put in as collateralToken');\n        require(isBorrowToken[_borrowToken], 'PoolFactory::createPool - Invalid borrow token type');\n        require(isCollateralToken[_collateralToken], 'PoolFactory::createPool - Invalid collateral token type');\n        require(\n            IPriceOracle(priceOracle).doesFeedExist(_collateralToken, _borrowToken),\n            \"PoolFactory::createPool - Price feed doesn't support token pair\"\n        );\n        require(IStrategyRegistry(strategyRegistry).registry(_poolSavingsStrategy), 'PoolFactory::createPool - Invalid strategy');\n        require(isWithinLimits(_poolSize, poolSizeLimit.min, poolSizeLimit.max), 'PoolFactory::createPool - PoolSize not within limits');\n        require(\n            isWithinLimits(_idealCollateralRatio, idealCollateralRatioLimit.min, idealCollateralRatioLimit.max),\n            'PoolFactory::createPool - Collateral Ratio not within limits'\n        );\n        require(\n            isWithinLimits(_borrowRate, borrowRateLimit.min, borrowRateLimit.max),\n            'PoolFactory::createPool - Borrow rate not within limits'\n        );\n        require(\n            isWithinLimits(_noOfRepaymentIntervals, noOfRepaymentIntervalsLimit.min, noOfRepaymentIntervalsLimit.max),\n            'PoolFactory::createPool - Loan duration not within limits'\n        );\n        require(\n            isWithinLimits(_repaymentInterval, repaymentIntervalLimit.min, repaymentIntervalLimit.max),\n            'PoolFactory::createPool - Repayment interval not within limits'\n        );\n        _createPool(\n            _poolSize,\n            _borrowRate,\n            _borrowToken,\n            _collateralToken,\n            _idealCollateralRatio,\n            _repaymentInterval,\n            _noOfRepaymentIntervals,\n            _poolSavingsStrategy,\n            _collateralAmount,\n            _transferFromSavingsAccount,\n            _salt,\n            _lenderVerifier\n        );\n    }\n\n    // @dev These functions are used to avoid stack too deep\n    function _createPool(\n        uint256 _poolSize,\n        uint256 _borrowRate,\n        address _borrowToken,\n        address _collateralToken,\n        uint256 _idealCollateralRatio,\n        uint256 _repaymentInterval,\n        uint256 _noOfRepaymentIntervals,\n        address _poolSavingsStrategy,\n        uint256 _collateralAmount,\n        bool _transferFromSavingsAccount,\n        bytes32 _salt,\n        address _lenderVerifier\n    ) internal {\n        bytes memory data = _encodePoolInitCall(\n            _poolSize,\n            _borrowRate,\n            _borrowToken,\n            _collateralToken,\n            _idealCollateralRatio,\n            _repaymentInterval,\n            _noOfRepaymentIntervals,\n            _poolSavingsStrategy,\n            _collateralAmount,\n            _transferFromSavingsAccount,\n            _lenderVerifier\n        );\n        bytes32 salt = keccak256(abi.encodePacked(_salt, msg.sender));\n        bytes memory bytecode = abi.encodePacked(type(SublimeProxy).creationCode, abi.encode(poolImpl, address(0x01), data));\n        uint256 amount = _collateralToken == address(0) ? _collateralAmount : 0;\n\n        address pool = _deploy(amount, salt, bytecode);\n\n        poolRegistry[pool] = true;\n        emit PoolCreated(pool, msg.sender);\n    }\n\n    // @dev These functions are used to avoid stack too deep\n    function _encodePoolInitCall(\n        uint256 _poolSize,\n        uint256 _borrowRate,\n        address _borrowToken,\n        address _collateralToken,\n        uint256 _idealCollateralRatio,\n        uint256 _repaymentInterval,\n        uint256 _noOfRepaymentIntervals,\n        address _poolSavingsStrategy,\n        uint256 _collateralAmount,\n        bool _transferFromSavingsAccount,\n        address _lenderVerifier\n    ) internal view returns (bytes memory data) {\n        data = abi.encodeWithSelector(\n            poolInitFuncSelector,\n            _poolSize,\n            _borrowRate,\n            msg.sender,\n            _borrowToken,\n            _collateralToken,\n            _idealCollateralRatio,\n            _repaymentInterval,\n            _noOfRepaymentIntervals,\n            _poolSavingsStrategy,\n            _collateralAmount,\n            _transferFromSavingsAccount,\n            _lenderVerifier,\n            loanWithdrawalDuration,\n            collectionPeriod\n        );\n    }\n\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function _deploy(\n        uint256 amount,\n        bytes32 salt,\n        bytes memory bytecode\n    ) internal returns (address addr) {\n        require(bytecode.length != 0, 'Create2: bytecode length is zero');\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        require(addr != address(0), 'Create2: Failed on deploy');\n    }\n\n    /**\n     * @notice invoked to check if pool parameters are within thresholds\n     * @param _value supplied value of the parameter\n     * @param _min minimum threshold of the parameter\n     * @param _max maximum threshold of the parameter\n     */\n    function isWithinLimits(\n        uint256 _value,\n        uint256 _min,\n        uint256 _max\n    ) internal pure returns (bool) {\n        if (_min != 0 && _max != 0) {\n            return (_value >= _min && _value <= _max);\n        } else if (_min != 0) {\n            return (_value >= _min);\n        } else if (_max != 0) {\n            return (_value <= _max);\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @notice used to update the list of supported borrow tokens\n     * @param _borrowToken address of the borrow asset\n     * @param _isSupported true if _borrowToken is a valid borrow asset, false if _borrowToken is an invalid borrow asset\n     */\n    function updateSupportedBorrowTokens(address _borrowToken, bool _isSupported) external onlyOwner {\n        _updateSupportedBorrowTokens(_borrowToken, _isSupported);\n    }\n\n    function _updateSupportedBorrowTokens(address _borrowToken, bool _isSupported) internal {\n        isBorrowToken[_borrowToken] = _isSupported;\n        emit BorrowTokenUpdated(_borrowToken, _isSupported);\n    }\n\n    /**\n     * @notice used to update the list of supported Collateral tokens\n     * @param _collateralToken address of the Collateral asset\n     * @param _isSupported true if _collateralToken is a valid Collateral asset, false if _collateralToken is an invalid Collateral asset\n     */\n    function updateSupportedCollateralTokens(address _collateralToken, bool _isSupported) external onlyOwner {\n        _updateSupportedCollateralTokens(_collateralToken, _isSupported);\n    }\n\n    function _updateSupportedCollateralTokens(address _collateralToken, bool _isSupported) internal {\n        isCollateralToken[_collateralToken] = _isSupported;\n        emit CollateralTokenUpdated(_collateralToken, _isSupported);\n    }\n\n    /**\n     * @notice used to update the pointer to Initializer function of the proxy pool contract\n     * @param _functionId updated function definition of the proxy pool contract\n     */\n    function updatepoolInitFuncSelector(bytes4 _functionId) external onlyOwner {\n        _updatepoolInitFuncSelector(_functionId);\n    }\n\n    function _updatepoolInitFuncSelector(bytes4 _functionId) internal {\n        poolInitFuncSelector = _functionId;\n        emit PoolInitSelectorUpdated(_functionId);\n    }\n\n    /**\n     * @notice used to update the Pool.sol logic\n     * @param _poolLogic the address of the new Pool logic contract\n     */\n    function updatePoolLogic(address _poolLogic) external onlyOwner {\n        _updatePoolLogic(_poolLogic);\n    }\n\n    function _updatePoolLogic(address _poolLogic) internal {\n        poolImpl = _poolLogic;\n        emit PoolLogicUpdated(_poolLogic);\n    }\n\n    /**\n     * @notice used to update the user registry\n     * @param _userRegistry address of the contract storing the user registry\n     */\n    function updateUserRegistry(address _userRegistry) external onlyOwner {\n        _updateUserRegistry(_userRegistry);\n    }\n\n    function _updateUserRegistry(address _userRegistry) internal {\n        userRegistry = _userRegistry;\n        emit UserRegistryUpdated(_userRegistry);\n    }\n\n    /**\n     * @notice used to update the strategy registry\n     * @param _strategyRegistry address of the contract storing the strategy registry\n     */\n    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {\n        _updateStrategyRegistry(_strategyRegistry);\n    }\n\n    function _updateStrategyRegistry(address _strategyRegistry) internal {\n        strategyRegistry = _strategyRegistry;\n        emit StrategyRegistryUpdated(_strategyRegistry);\n    }\n\n    /**\n     * @notice used to update the implementation of the repayment logic\n     * @param _repaymentImpl address of the updated repayment.sol contract\n     */\n    function updateRepaymentImpl(address _repaymentImpl) external onlyOwner {\n        _updateRepaymentImpl(_repaymentImpl);\n    }\n\n    function _updateRepaymentImpl(address _repaymentImpl) internal {\n        repaymentImpl = _repaymentImpl;\n        emit RepaymentImplUpdated(_repaymentImpl);\n    }\n\n    /**\n     * @notice used to update contract address of nostrategy contract\n     * @param _noStrategy address of the updated noYield.sol contract\n     */\n    function updateNoStrategy(address _noStrategy) external onlyOwner {\n        _updateNoStrategy(_noStrategy);\n    }\n\n    function _updateNoStrategy(address _noStrategy) internal {\n        noStrategyAddress = _noStrategy;\n        emit NoStrategyUpdated(_noStrategy);\n    }\n\n    /**\n     * @notice used to update the implementation of the price oracle logic\n     * @param _priceOracle address of the updated price oracle contract\n     */\n    function updatePriceoracle(address _priceOracle) external onlyOwner {\n        _updatePriceoracle(_priceOracle);\n    }\n\n    function _updatePriceoracle(address _priceOracle) internal {\n        priceOracle = _priceOracle;\n        emit PriceOracleUpdated(_priceOracle);\n    }\n\n    /**\n     * @notice used to update the extensions contract\n     * @param _extension address of the updated extensions contract\n     */\n    function updatedExtension(address _extension) external onlyOwner {\n        _updatedExtension(_extension);\n    }\n\n    function _updatedExtension(address _extension) internal {\n        extension = _extension;\n        emit ExtensionImplUpdated(_extension);\n    }\n\n    /**\n     * @notice used to update the savings account contract\n     * @param _savingsAccount address of the updated savings account contract\n     */\n    function updateSavingsAccount(address _savingsAccount) external onlyOwner {\n        _updateSavingsAccount(_savingsAccount);\n    }\n\n    function _updateSavingsAccount(address _savingsAccount) internal {\n        savingsAccount = _savingsAccount;\n        emit SavingsAccountUpdated(_savingsAccount);\n    }\n\n    /**\n     * @notice used to update the collection period of the Pool\n     * @param _collectionPeriod updated value of the collection period\n     */\n    function updateCollectionPeriod(uint256 _collectionPeriod) external onlyOwner {\n        _updateCollectionPeriod(_collectionPeriod);\n    }\n\n    function _updateCollectionPeriod(uint256 _collectionPeriod) internal {\n        collectionPeriod = _collectionPeriod;\n        emit CollectionPeriodUpdated(_collectionPeriod);\n    }\n\n    /**\n     * @notice used to update the loan withdrawal duration by owner\n     * @param _loanWithdrawalDuration updated value of loanWithdrawalDuration\n     */\n    function updateLoanWithdrawalDuration(uint256 _loanWithdrawalDuration) external onlyOwner {\n        _updateLoanWithdrawalDuration(_loanWithdrawalDuration);\n    }\n\n    function _updateLoanWithdrawalDuration(uint256 _loanWithdrawalDuration) internal {\n        loanWithdrawalDuration = _loanWithdrawalDuration;\n        emit LoanWithdrawalDurationUpdated(_loanWithdrawalDuration);\n    }\n\n    /**\n     * @notice used to update the active stage of the margin call of the Pool\n     * @param _marginCallDuration updated value of the margin call duration\n     */\n    function updateMarginCallDuration(uint256 _marginCallDuration) external onlyOwner {\n        _updateMarginCallDuration(_marginCallDuration);\n    }\n\n    function _updateMarginCallDuration(uint256 _marginCallDuration) internal {\n        marginCallDuration = _marginCallDuration;\n        emit MarginCallDurationUpdated(_marginCallDuration);\n    }\n\n    /**\n     * @notice used to update the min borrow fraction by owner\n     * @param _minBorrowFraction updated value of min borrow fraction multiplied by 10**30\n     */\n    function updateMinBorrowFraction(uint256 _minBorrowFraction) external onlyOwner {\n        _updateMinBorrowFraction(_minBorrowFraction);\n    }\n\n    function _updateMinBorrowFraction(uint256 _minBorrowFraction) internal {\n        minBorrowFraction = _minBorrowFraction;\n        emit MinBorrowFractionUpdated(_minBorrowFraction);\n    }\n\n    /**\n     * @notice used to update the reward fraction for liquidation of the Pool\n     * @param _liquidatorRewardFraction updated value of the reward fraction for liquidation multiplied by 10**30\n     */\n    function updateLiquidatorRewardFraction(uint256 _liquidatorRewardFraction) external onlyOwner {\n        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);\n    }\n\n    function _updateLiquidatorRewardFraction(uint256 _liquidatorRewardFraction) internal {\n        liquidatorRewardFraction = _liquidatorRewardFraction;\n        emit LiquidatorRewardFractionUpdated(_liquidatorRewardFraction);\n    }\n\n    /**\n     * @notice used to update the pool cancel penalty multiple\n     * @param _poolCancelPenaltyMultiple updated value of the pool cancel penalty multiple multiplied by 10**30\n     */\n    function updatePoolCancelPenaltyMultiple(uint256 _poolCancelPenaltyMultiple) external onlyOwner {\n        _updatePoolCancelPenaltyMultiple(_poolCancelPenaltyMultiple);\n    }\n\n    function _updatePoolCancelPenaltyMultiple(uint256 _poolCancelPenaltyMultiple) internal {\n        poolCancelPenaltyMultiple = _poolCancelPenaltyMultiple;\n        emit PoolCancelPenaltyMultipleUpdated(_poolCancelPenaltyMultiple);\n    }\n\n    /**\n     * @notice used to update the fraction of borrowed amount charged as protocol fee\n     * @param _protocolFee updated value of protocol fee fraction multiplied by 10**30\n     */\n    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {\n        _updateProtocolFeeFraction(_protocolFee);\n    }\n\n    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {\n        protocolFeeFraction = _protocolFee;\n        emit ProtocolFeeFractionUpdated(_protocolFee);\n    }\n\n    /**\n     * @notice used to update the address in which protocol fee is collected\n     * @param _protocolFeeCollector updated address of protocol fee collector\n     */\n    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {\n        _updateProtocolFeeCollector(_protocolFeeCollector);\n    }\n\n    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {\n        protocolFeeCollector = _protocolFeeCollector;\n        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);\n    }\n\n    /**\n     * @notice used to update the thresholds of the pool size of the Pool\n     * @param _min updated value of the minimum threshold value of the pool size\n     * @param _max updated value of the maximum threshold value of the pool size\n     */\n    function updatePoolSizeLimit(uint256 _min, uint256 _max) external onlyOwner {\n        poolSizeLimit = Limits(_min, _max);\n        emit LimitsUpdated('PoolSize', _min, _max);\n    }\n\n    /**\n     * @notice used to update the thresholds of the collateral ratio of the Pool\n     * @param _min updated value of the minimum threshold value of the collateral ratio\n     * @param _max updated value of the maximum threshold value of the collateral ratio\n     */\n    function updateidealCollateralRatioLimit(uint256 _min, uint256 _max) external onlyOwner {\n        idealCollateralRatioLimit = Limits(_min, _max);\n        emit LimitsUpdated('CollateralRatio', _min, _max);\n    }\n\n    /**\n     * @notice used to update the thresholds of the borrow rate of the Pool\n     * @param _min updated value of the minimum threshold value of the borrow rate\n     * @param _max updated value of the maximum threshold value of the borrow rate\n     */\n    function updateBorrowRateLimit(uint256 _min, uint256 _max) external onlyOwner {\n        borrowRateLimit = Limits(_min, _max);\n        emit LimitsUpdated('BorrowRate', _min, _max);\n    }\n\n    /**\n     * @notice used to update the thresholds of the repayment interval of the Pool\n     * @param _min updated value of the minimum threshold value of the repayment interval\n     * @param _max updated value of the maximum threshold value of the repayment interval\n     */\n    function updateRepaymentIntervalLimit(uint256 _min, uint256 _max) external onlyOwner {\n        repaymentIntervalLimit = Limits(_min, _max);\n        emit LimitsUpdated('RepaymentInterval', _min, _max);\n    }\n\n    /**\n     * @notice used to update the thresholds of the number of repayment intervals of the Pool\n     * @param _min updated value of the minimum threshold value of the number of repayment intervals\n     * @param _max updated value of the maximum threshold value of the number of repayment intervals\n     */\n    function updateNoOfRepaymentIntervalsLimit(uint256 _min, uint256 _max) external onlyOwner {\n        noOfRepaymentIntervalsLimit = Limits(_min, _max);\n        emit LimitsUpdated('NoOfRepaymentIntervals', _min, _max);\n    }\n\n    /**\n     * @notice used to query protocol fee fraction and address of the collector\n     * @return protocolFee Fraction multiplied by 10**30\n     * @return address of protocol fee collector\n     */\n    function getProtocolFeeData() external view override returns (uint256, address) {\n        return (protocolFeeFraction, protocolFeeCollector);\n    }\n}"
    }
  ]
}