{
  "Title": "Incorrect Initialization of ERC20Permit",
  "Content": "In the OpenZeppelin Upgradeable contracts, unchained functions are [used to mitigate potential double initialization problems](https://docs.openzeppelin.com/contracts/4.x/upgradeable#multiple-inheritance). However, because of the simple inheritance structure in the [`EscrowedEXA`](https://github.com/exactly/protocol/blob/1dfca200ff82a964ed34b7429656a05b013dfb5d/contracts/periphery/EscrowedEXA.sol) contract, double initialization is not a concern in the current implementation.\n\n\nUsing [`__ERC20Permit_init_unchained`](https://github.com/exactly/protocol/blob/1dfca200ff82a964ed34b7429656a05b013dfb5d/contracts/periphery/EscrowedEXA.sol#L45) instead of `__ERC20Permit_init` is not necessary, and leaves the [`EIP712Upgradeable` contract's](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/utils/cryptography/EIP712Upgradeable.sol) name and version uninitialized. This is not consistent with the [EIP-712 domain separator specification](https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator), and will lead to issues when integrating with signatures that fully comply with EIP-712.\n\n\nConsider using the `__ERC20Permit_init` function in order to correctly initialize the EIP-712 domain separator.\n\n\n***Update:** Resolved in [pull request #674](https://github.com/exactly/protocol/pull/674) at commit [1725765](https://github.com/exactly/protocol/commit/17257655f5bb9455e65a3db3c28c4f9db739a962).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/periphery/EscrowedEXA.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.17;\n\nimport {\n  ERC20VotesUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol\";\nimport { SafeERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport { AccessControlUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport { FixedPointMathLib } from \"solmate/src/utils/FixedPointMathLib.sol\";\nimport { EXA } from \"./EXA.sol\";\n\n/// @title EscrowedEXA.\n/// @notice ERC20 token that can be used to escrow EXA and vest it linearly using Sablier.\ncontract EscrowedEXA is ERC20VotesUpgradeable, AccessControlUpgradeable {\n  using SafeERC20Upgradeable for EXA;\n  using FixedPointMathLib for uint128;\n\n  /// @notice Role that can redeem esEXA for EXA.\n  bytes32 public constant REDEEMER_ROLE = keccak256(\"REDEEMER_ROLE\");\n  /// @notice Role that can receive or transfer esEXA.\n  bytes32 public constant TRANSFERRER_ROLE = keccak256(\"TRANSFERRER_ROLE\");\n  /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n  EXA public immutable exa;\n  /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n  ISablierV2LockupLinear public immutable sablier;\n  /// @notice Ratio of EXA to reserve when vesting, represented with 18 decimals.\n  uint256 public reserveRatio;\n  /// @notice Duration of vesting period.\n  uint40 public vestingPeriod;\n  /// @notice Mapping of streamId to reserve amount.\n  mapping(uint256 => uint256) public reserves;\n\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor(EXA exa_, ISablierV2LockupLinear sablier_) {\n    exa = exa_;\n    sablier = sablier_;\n\n    _disableInitializers();\n  }\n\n  /// @notice Initializes the contract.\n  /// @dev can only be called once.\n  function initialize(uint40 vestingPeriod_, uint256 reserveRatio_) external initializer {\n    __ERC20_init(\"escrowed EXA\", \"esEXA\");\n    __ERC20Permit_init_unchained(\"escrowed EXA\");\n    __ERC20Votes_init_unchained();\n    __AccessControl_init_unchained();\n\n    _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    /// @dev address(0) holds the TRANSFERRER_ROLE so the token can be minted or burnt.\n    _grantRole(TRANSFERRER_ROLE, address(0));\n\n    setVestingPeriod(vestingPeriod_);\n    setReserveRatio(reserveRatio_);\n    exa.safeApprove(address(sablier), type(uint256).max);\n  }\n\n  /// @notice ERC20 transfer override to only allow transfers from/to TRANSFERRER_ROLE holders.\n  function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\n    if (!hasRole(TRANSFERRER_ROLE, from) && !hasRole(TRANSFERRER_ROLE, to)) revert Untransferable();\n    super._beforeTokenTransfer(from, to, amount);\n  }\n\n  /// @notice Mints esEXA for EXA.\n  /// @param amount Amount of EXA to mint.\n  /// @param to Address to send esEXA to.\n  function mint(uint256 amount, address to) external {\n    assert(amount != 0);\n    exa.safeTransferFrom(msg.sender, address(this), amount);\n    _mint(to, amount);\n  }\n\n  /// @notice Redeems esEXA for EXA.\n  /// @param amount Amount of esEXA to redeem.\n  /// @param to Address to send EXA to.\n  /// @dev Caller must have REDEEMER_ROLE.\n  function redeem(uint256 amount, address to) external onlyRole(REDEEMER_ROLE) {\n    assert(amount != 0);\n    _burn(msg.sender, amount);\n    exa.safeTransfer(to, amount);\n  }\n\n  /// @notice Starts a vesting stream.\n  /// @param amount Amount of EXA to vest.\n  /// @param to Address to vest to.\n  /// @return streamId of the vesting stream.\n  function vest(uint128 amount, address to) public returns (uint256 streamId) {\n    assert(amount != 0);\n    _burn(msg.sender, amount);\n    uint256 reserve = amount.mulWadDown(reserveRatio);\n    exa.safeTransferFrom(msg.sender, address(this), reserve);\n    streamId = sablier.createWithDurations(\n      CreateWithDurations({\n        asset: exa,\n        sender: address(this),\n        recipient: to,\n        totalAmount: amount,\n        cancelable: true,\n        durations: Durations({ cliff: 0, total: vestingPeriod }),\n        broker: Broker({ account: address(0), fee: 0 })\n      })\n    );\n    reserves[streamId] = reserve;\n    emit Vest(msg.sender, to, streamId, amount);\n  }\n\n  /// @notice Starts a vesting stream using a permit.\n  /// @param amount Amount of EXA to vest.\n  /// @param to Address to vest to.\n  /// @param p Permit for the EXA reserve.\n  /// @return streamId of the vesting stream.\n  function vest(uint128 amount, address to, Permit calldata p) external returns (uint256 streamId) {\n    exa.safePermit(msg.sender, address(this), p.value, p.deadline, p.v, p.r, p.s);\n    return vest(amount, to);\n  }\n\n  /// @notice Cancels vesting streams.\n  /// @param streamIds Array of streamIds to cancel.\n  /// @return streamsReserves Amount of EXA in reserves that is returned to the cancelled stream holders.\n  function cancel(uint256[] memory streamIds) external returns (uint256 streamsReserves) {\n    uint128 refundableAmount;\n    (streamsReserves, refundableAmount) = _cancel(streamIds);\n    _mint(msg.sender, refundableAmount);\n    exa.safeTransfer(msg.sender, streamsReserves);\n  }\n\n  /// @notice Cancels vesting streams and withdraws the remaining EXA.\n  /// @param streamIds Array of streamIds to cancel.\n  /// @return streamsReserves Amount of EXA in reserves that is returned to the cancelled streams holder.\n  /// @dev the caller must be the recepient of the streamIds.\n  function _cancel(uint256[] memory streamIds) internal returns (uint256 streamsReserves, uint128 refundableAmount) {\n    for (uint256 i = 0; i < streamIds.length; ++i) {\n      uint256 streamId = streamIds[i];\n      assert(msg.sender == sablier.getRecipient(streamId));\n      streamsReserves += reserves[streamId];\n      delete reserves[streamId];\n      refundableAmount += sablier.refundableAmountOf(streamId);\n      withdrawMax(streamId);\n      sablier.cancel(streamId);\n    }\n    emit Cancel(msg.sender, streamIds);\n  }\n\n  /// @notice Withdraws the EXA from the vesting streamIds. If a stream is depleted, its reserve is returned.\n  /// @param streamIds Array of streamIds to withdraw from.\n  function withdrawMax(uint256[] memory streamIds) public {\n    for (uint256 i = 0; i < streamIds.length; ++i) {\n      uint256 streamId = streamIds[i];\n      assert(msg.sender == sablier.getRecipient(streamId));\n      withdrawMax(streamId);\n    }\n  }\n\n  /// @notice Withdraws the EXA from the vesting streamId. If the stream is depleted, the reserve is returned.\n  /// @param streamId streamId to withdraw from.\n  function withdrawMax(uint256 streamId) internal {\n    if (sablier.withdrawableAmountOf(streamId) != 0) sablier.withdrawMax(streamId, msg.sender);\n    if (sablier.isDepleted(streamId)) {\n      uint256 reserve = reserves[streamId];\n      delete reserves[streamId];\n      exa.safeTransfer(msg.sender, reserve);\n    }\n  }\n\n  /// @notice Hook called when a recipient cancels a stream.\n  /// @notice Mints esEXA to the recipient with the remaining EXA received from the canceled stream.\n  /// @param recipient recipient of the cancelled stream.\n  /// @param senderAmount amount of EXA sent to the recipient.\n  function onStreamCanceled(uint256, address recipient, uint128 senderAmount, uint128) external {\n    assert(msg.sender == address(sablier));\n    _mint(recipient, senderAmount);\n  }\n\n  /// @notice Sets the vesting period.\n  /// @param vestingPeriod_ New vesting period.\n  /// @dev Caller must have DEFAULT_ADMIN_ROLE.\n  function setVestingPeriod(uint40 vestingPeriod_) public onlyRole(DEFAULT_ADMIN_ROLE) {\n    vestingPeriod = vestingPeriod_;\n    emit VestingPeriodSet(vestingPeriod_);\n  }\n\n  /// @notice Sets the reserve ratio.\n  /// @param reserveRatio_ New reserve ratio.\n  /// @dev Caller must have DEFAULT_ADMIN_ROLE.\n  function setReserveRatio(uint256 reserveRatio_) public onlyRole(DEFAULT_ADMIN_ROLE) {\n    reserveRatio = reserveRatio_;\n    emit ReserveRatioSet(reserveRatio_);\n  }\n\n  function clock() public view override returns (uint48) {\n    return exa.clock();\n  }\n\n  // solhint-disable-next-line func-name-mixedcase\n  function CLOCK_MODE() public view override returns (string memory) {\n    return exa.CLOCK_MODE();\n  }\n\n  /// @notice Event emitted when the reserve ratio is set.\n  event ReserveRatioSet(uint256 reserveRatio);\n  /// @notice Event emitted when the vesting period is set.\n  event VestingPeriodSet(uint256 vestingPeriod);\n  /// @notice Event emitted when vesting streams are cancelled.\n  event Cancel(address indexed account, uint256[] streamIds);\n  /// @notice Event emitted when a vesting stream is created.\n  event Vest(address indexed caller, address indexed account, uint256 indexed streamId, uint256 amount);\n}\n\nerror Untransferable();\n\ninterface ISablierV2LockupLinear {\n  function cancel(uint256 streamId) external;\n\n  function withdrawMax(uint256 streamId, address to) external;\n\n  function isDepleted(uint256 streamId) external view returns (bool result);\n\n  function getRecipient(uint256 streamId) external view returns (address recipient);\n\n  function refundableAmountOf(uint256 streamId) external view returns (uint128 refundableAmount);\n\n  function withdrawableAmountOf(uint256 streamId) external view returns (uint128 withdrawableAmount);\n\n  function createWithDurations(CreateWithDurations calldata params) external returns (uint256 streamId);\n}\n\nstruct Durations {\n  uint40 cliff;\n  uint40 total;\n}\n\nstruct Broker {\n  address account;\n  uint256 fee;\n}\n\nstruct CreateWithDurations {\n  address sender;\n  address recipient;\n  uint128 totalAmount;\n  EXA asset;\n  bool cancelable;\n  Durations durations;\n  Broker broker;\n}\n\nstruct Permit {\n  uint256 value;\n  uint256 deadline;\n  uint8 v;\n  bytes32 r;\n  bytes32 s;\n}"
    }
  ]
}