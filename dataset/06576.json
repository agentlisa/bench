{
  "Title": "[L-03] `grantRole` operation in `setAMO` function may incorrectly check role access",
  "Content": "\nhttps://github.com/code-423n4/2023-05-xeth/blob/main/src/xETH.sol#L54\n\nInstead of using the internal `_grantRole` function, the `setAMO` function present in the xETH is using the `grantRole` function of the OpenZeppelin AccessControl library, which includes a validation that the caller has the admin role for the role being granted (`MINTER_ROLE` in this case):\n\nhttps://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/AccessControl.sol#L145-L147\n\n```solidity\nfunction grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n    _grantRole(role, account);\n}\n```\n\nThis should be ok as long as the admin role for `MINTER_ROLE` is not defined. Currently, the `setAMO` function will be called by the `DEFAULT_ADMIN_ROLE` which is the default admin role for the `MINTER_ROLE` role. But if the role admin for the `MINTER_ROLE` is defined, then the default admin role will not be the admin role for the `MINTER_ROLE` and the operation will be reverted.\n\nThe recommendation is to change `grantRole` for the internal variant `_grantRole`.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-05-xeth",
  "Code": [
    {
      "filename": "src/xETH.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport \"@openzeppelin-contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin-contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport \"@openzeppelin-contracts/security/Pausable.sol\";\nimport \"@openzeppelin-contracts/access/AccessControl.sol\";\n\ncontract xETH is ERC20, ERC20Burnable, Pausable, AccessControl {\n    /* --------------------------------- Errors --------------------------------- */\n    error AddressZeroProvided();\n    error AmountZeroProvided();\n\n    /* -------------------------- Constants and Storage ------------------------- */\n    /// @dev authentication role for pausing and unpausing the contract\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n    /// @dev authentication role for minting and burning tokens\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n    /// @dev address of the AMO contract that controls the supply of xETH\n    address public curveAMO;\n\n    /* ------------------------------- Constructor ------------------------------ */\n    constructor() ERC20(\"xEther\", \"xETH\") {\n        /// @dev grant the DEFAULT_ADMIN_ROLE to the contract deployer\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        /// @dev grant the PAUSER_ROLE to the contract deployer\n        _grantRole(PAUSER_ROLE, msg.sender);\n    }\n\n    /* --------------------------- External functions --------------------------- */\n\n    /// @dev setAMO allows for initialising the AMO address and granting it the MINTER_ROLE\n    /// @notice this function can also be used to update the AMO address\n    /// @notice this function can only be called by the DEFAULT_ADMIN_ROLE\n    /// @param newAMO address of the new curveAMO contract\n    function setAMO(address newAMO) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        /// @dev if the new AMO is address(0), revert\n        if (newAMO == address(0)) {\n            revert AddressZeroProvided();\n        }\n\n        /// @dev if there was a previous AMO, revoke it's powers\n        if (curveAMO != address(0)) {\n            _revokeRole(MINTER_ROLE, curveAMO);\n        }\n\n        // @todo call marker method to check if amo is responding\n\n        /// @dev set the new AMO\n        curveAMO = newAMO;\n\n        /// @dev grant it the MINTER_ROLE\n        grantRole(MINTER_ROLE, curveAMO);\n    }\n\n    /// @dev mintShares allows for minting new xETH tokens\n    /// @notice this function can only mint tokens if the contract is not paused\n    /// @notice this function can only be called by the MINTER_ROLE\n    /// @param amount amount of xETH to be minted, it cannot be 0\n    function mintShares(\n        uint256 amount\n    ) public onlyRole(MINTER_ROLE) whenNotPaused {\n        /// @dev if the amount to be minted is 0, revert.\n        if (amount == 0) revert AmountZeroProvided();\n        _mint(msg.sender, amount);\n    }\n\n    /// @dev burnShares allows for burning xETH tokens\n    /// @dev this function can only burn tokens if the contract is not paused\n    /// @dev this function can only be called by the MINTER_ROLE\n    /// @param amount amount of xETH to be burned, it cannot be 0\n    function burnShares(\n        uint256 amount\n    ) public onlyRole(MINTER_ROLE) whenNotPaused {\n        /// @dev if the amount to be burned is 0, revert.\n        if (amount == 0) revert AmountZeroProvided();\n        _burn(msg.sender, amount);\n    }\n\n    /* ---------------------------- Utility functions --------------------------- */\n\n    /// @dev pause allows for pausing the contract\n    /// @notice this function can only be called by the PAUSER_ROLE\n    /// @notice this function can only be called if the contract is not paused\n    function pause() external whenNotPaused onlyRole(PAUSER_ROLE) {\n        _pause();\n    }\n\n    /// @dev unpause allows for unpausing the contract\n    /// @notice this function can only be called by the PAUSER_ROLE\n    /// @notice this function can only be called if the contract is paused\n    function unpause() external whenPaused onlyRole(PAUSER_ROLE) {\n        _unpause();\n    }\n\n    /* ---------------------------- Overridden functions --------------------------- */\n\n    /// @dev overrides the default ERC20 _beforeTokenTransfer hook\n    /// @dev so that transfers can only happen if the contract is not paused\n    /// @param from address of the sender\n    /// @param to address of the recipient\n    /// @param amount amount of tokens to be transferred\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override whenNotPaused {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n}"
    },
    {
      "filename": "contracts/access/AccessControl.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"./IAccessControl.sol\";\nimport {Context} from \"../utils/Context.sol\";\nimport {ERC165} from \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}"
    }
  ]
}