{
  "Title": "[M-03] When Convex pool is shut down while collateral type is `CurveLPStakedOnConvex`, users unable to deposit that asset and protocol lose the ability to accept the asset as collateral further",
  "Content": "\n<https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/VaultController.sol#L376-L412><br>\n<https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/Vault.sol#L93-L105><br>\n<https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/Vault.sol#L111-L133><br>\n<https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/VaultController.sol#L676-L679>\n\nWhen Convex pool of an asset that has `CurveLPStakedOnConvex` collateral type is shut down, users can no longer deposit that asset into vault since it would always revert on Convex booster `deposit` function, called during vaultâ€™s `depositERC20` process. With lack of method to update it, protocol would the ability to accept it as collateral even as plain LP without staking. Also users that use the asset as collateral may face risk of being liquidated.\nThis is also applicable when Convex itself shutdown their booster contract.\n\n### Proof of Concept\n\nBased on project's e2e test, extending `CommonE2EBase` contract. The test showed that `depositERC20` is bricked when Convex pool is shut down.\n\n```\nimport {CommonE2EBase} from '@test/e2e/Common.sol';\n\nimport {IERC20} from 'isolmate/interfaces/tokens/IERC20.sol';\nimport {IVault} from '@interfaces/core/IVault.sol';\n\ninterface IBoosterAdmin {\n  function poolManager() external view returns (address);\n  function shutdownPool(uint256 _pid) external;\n}\n\ncontract VaultCollateralTypeVulnPoC is CommonE2EBase {\n  function setUp() public override {\n    super.setUp();\n  }\n\n  function testCannotDepositWhenConvexPoolIsShutDown() public {\n    // Prepare Convex LP for user\n    deal(USDT_LP_ADDRESS, bob, 2 ether);\n\n    // User mints vault\n    IVault bobVault = IVault(vaultController.vaultIdVaultAddress(_mintVault(bob)));\n\n    // User deposit Convex LP to vault\n    vm.startPrank(bob);\n    IERC20(USDT_LP_ADDRESS).approve(address(bobVault), 1 ether);\n    bobVault.depositERC20(USDT_LP_ADDRESS, 1 ether);\n    vm.stopPrank();\n\n    // Convex pool of the asset is shut down\n    vm.prank(IBoosterAdmin(address(BOOSTER)).poolManager());\n    IBoosterAdmin(address(BOOSTER)).shutdownPool(1);\n\n    // User can no longer deposit that LP to vault\n    vm.startPrank(bob);\n    IERC20(USDT_LP_ADDRESS).approve(address(bobVault), 1 ether);\n    vm.expectRevert('pool is closed');\n    bobVault.depositERC20(USDT_LP_ADDRESS, 1 ether);\n    vm.stopPrank();\n  }\n}\n\n```\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nThe fix requires 2 modifications\n\n1.  Allow updating collateral type to `Single` and pool id to 0 when pool or booster contract is shutting down. By updating collateral type to `Single` during `depositERC20` deposit to Convex would be skipped. Updating pool id to 0 prevents users from staking it manually.\n\n```\n\n      function updateRegisteredErc20(\n        address _tokenAddress,\n        uint256 _ltv,\n        address _oracleAddress,\n        uint256 _liquidationIncentive,\n        uint256 _cap,\n        uint256 _poolId,\n        bool _shutdown\n      ) external override onlyOwner {\n        ...\n        if (_poolId != 0) {\n          (address _lpToken,,, address _crvRewards,,) = BOOSTER.poolInfo(_poolId);\n          if (_lpToken != _tokenAddress) revert VaultController_TokenAddressDoesNotMatchLpAddress();\n          _collateral.collateralType = CollateralType.CurveLPStakedOnConvex;\n          _collateral.crvRewardsContract = IBaseRewardPool(_crvRewards);\n          _collateral.poolId = _poolId;\n        } else if (_shutdown) {\n          (,,,,,bool _isPoolShutdown) = BOOSTER.poolInfo(_poolId);\n          if (!_isPoolShutdown || !BOOSTER.isShutdown()) revert VaultController_NotShutdown();\n          _collateral.collateralType = CollateralType.Single;\n          // keep `crvRewardsContract` for withdrawal\n          _collateral.poolId = 0;\n        }\n        ...\n      }\n```\n\n2.  Update vault's `withdrawERC20` to update state variable `isTokenStaked` to false when withdraw all of that asset. This is important because if the asset is deposited again without actually being staked but `isTokenStaked` is still true, the vault will not be liquidated due to trying to withdraw while nothing is staked.\n\nFailed liquidation if state is not reflected correctly\n\n      function liquidateVault(\n        ...\n      ) external override paysInterest whenNotPaused returns (uint256 _toLiquidate) {\n        ...\n        // withdraw from convex\n        CollateralInfo memory _assetInfo = tokenAddressCollateralInfo[_assetAddress];\n        // @audit if the flag is not updated accordingly this would fail\n        if (_vault.isTokenStaked(_assetAddress)) {\n          _vault.controllerWithdrawAndUnwrap(_assetInfo.crvRewardsContract, _tokensToLiquidate);\n        }\n        ...\n      }\n\nThe fix\n\n      function withdrawERC20(address _tokenAddress, uint256 _amount) external override onlyMinter {\n        ...\n        if (isTokenStaked[_tokenAddress]) {\n          if (!CONTROLLER.tokenCrvRewardsContract(_tokenAddress).withdrawAndUnwrap(_amount, false)) {\n            revert Vault_WithdrawAndUnstakeOnConvexFailed();\n            // @audit if withdraw all, reset flag to false\n          } else if (_amount == balances[_tokenAddress]) {\n            isTokenStaked[_tokenAddress] = false;\n          }\n        }\n        ...\n      }\n\n**[0xShaito (Amphora) disagreed with severity and commented](https://github.com/code-423n4/2023-07-amphora-findings/issues/90#issuecomment-1667510422):**\n > While true, this needs the action of a third party (convex) and is not an attack that someone can do. We consider this to be of medium severity.\n> \n> User deposits are also safe in case this happens but the collateral gets bricked for new deposits. \n\n**[LSDan (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-07-amphora-findings/issues/90#issuecomment-1677286454):**\n > I agree with the sponsor here. Medium is more appropriate. There are clear external factors.\n\n**[0xShaito (Amphora) confirmed](https://github.com/code-423n4/2023-07-amphora-findings/issues/90#issuecomment-1679065063)**\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-07-amphora",
  "Code": [
    {
      "filename": "core/solidity/contracts/core/VaultController.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {ExponentialNoError} from '@contracts/utils/ExponentialNoError.sol';\nimport {CurveMaster} from '@contracts/periphery/CurveMaster.sol';\n\nimport {IUSDA} from '@interfaces/core/IUSDA.sol';\nimport {IVault} from '@interfaces/core/IVault.sol';\nimport {IVaultController} from '@interfaces/core/IVaultController.sol';\nimport {IOracleRelay} from '@interfaces/periphery/IOracleRelay.sol';\nimport {IBooster} from '@interfaces/utils/IBooster.sol';\nimport {IBaseRewardPool} from '@interfaces/utils/IBaseRewardPool.sol';\nimport {IAMPHClaimer} from '@interfaces/core/IAMPHClaimer.sol';\nimport {IVaultDeployer} from '@interfaces/core/IVaultDeployer.sol';\n\nimport {IERC20, IERC20Metadata} from '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {Pausable} from '@openzeppelin/contracts/security/Pausable.sol';\n\n/// @notice Controller of all vaults in the USDA borrow/lend system\n///         VaultController contains all business logic for borrowing and lending through the protocol.\n///         It is also in charge of accruing interest.\ncontract VaultController is Pausable, IVaultController, ExponentialNoError, Ownable {\n  /// @dev The max decimals allowed for a listed token\n  uint8 public constant MAX_DECIMALS = 18;\n\n  /// @dev The max allowed to be set as borrowing fee\n  uint192 public constant MAX_INIT_BORROWING_FEE = 0.05e18;\n\n  /// @dev The convex booster interface\n  IBooster public immutable BOOSTER;\n\n  /// @dev The vault deployer interface\n  IVaultDeployer public immutable VAULT_DEPLOYER;\n\n  /// @dev Mapping of vault id to vault address\n  mapping(uint96 => address) public vaultIdVaultAddress;\n\n  /// @dev Mapping of wallet address to vault IDs arrays\n  mapping(address => uint96[]) public walletVaultIDs;\n\n  /// @dev Mapping of token address to collateral info\n  mapping(address => CollateralInfo) public tokenAddressCollateralInfo;\n\n  /// @dev Array of enabled tokens addresses\n  address[] public enabledTokens;\n\n  /// @dev The curve master contract\n  CurveMaster public curveMaster;\n\n  /// @dev The interest contract\n  Interest public interest;\n\n  /// @dev The usda interface\n  IUSDA public usda;\n\n  /// @dev The amphora claimer interface\n  IAMPHClaimer public claimerContract;\n\n  /// @dev Total number of minted vaults\n  uint96 public vaultsMinted;\n  /// @dev Total number of tokens registered\n  uint256 public tokensRegistered;\n  /// @dev Total base liability\n  uint192 public totalBaseLiability;\n  /// @dev The protocol's fee\n  uint192 public protocolFee;\n  /// @dev The initial borrowing fee (1e18 == 100%)\n  uint192 public initialBorrowingFee;\n  /// @dev The fee taken from the liquidator profit (1e18 == 100%)\n  uint192 public liquidationFee;\n\n  /// @notice Any function with this modifier will call the _payInterest() function before\n  modifier paysInterest() {\n    _payInterest();\n    _;\n  }\n\n  ///@notice Any function with this modifier can be paused or unpaused by USDA._pauser() in the case of an emergency\n  modifier onlyPauser() {\n    if (_msgSender() != usda.pauser()) revert VaultController_OnlyPauser();\n    _;\n  }\n\n  /// @notice Can initialize collaterals from an older vault controller\n  /// @param _oldVaultController The old vault controller\n  /// @param _tokenAddresses The addresses of the collateral we want to take information for\n  /// @param _claimerContract The claimer contract\n  /// @param _vaultDeployer The deployer contract\n  /// @param _initialBorrowingFee The initial borrowing fee\n  /// @param _booster The convex booster address\n  /// @param _liquidationFee The liquidation fee\n  constructor(\n    IVaultController _oldVaultController,\n    address[] memory _tokenAddresses,\n    IAMPHClaimer _claimerContract,\n    IVaultDeployer _vaultDeployer,\n    uint192 _initialBorrowingFee,\n    address _booster,\n    uint192 _liquidationFee\n  ) {\n    VAULT_DEPLOYER = _vaultDeployer;\n    interest = Interest(uint64(block.timestamp), 1 ether);\n    protocolFee = 1e14;\n    initialBorrowingFee = _initialBorrowingFee;\n    liquidationFee = _liquidationFee;\n\n    claimerContract = _claimerContract;\n\n    BOOSTER = IBooster(_booster);\n\n    if (address(_oldVaultController) != address(0)) _migrateCollateralsFrom(_oldVaultController, _tokenAddresses);\n  }\n\n  /// @notice Returns the latest interest factor\n  /// @return _interestFactor The latest interest factor\n  function interestFactor() external view override returns (uint192 _interestFactor) {\n    _interestFactor = interest.factor;\n  }\n\n  /// @notice Returns the block timestamp when pay interest was last called\n  /// @return _lastInterestTime The block timestamp when pay interest was last called\n  function lastInterestTime() external view override returns (uint64 _lastInterestTime) {\n    _lastInterestTime = interest.lastTime;\n  }\n\n  /// @notice Returns an array of all the vault ids a specific wallet has\n  /// @param _wallet The address of the wallet to target\n  /// @return _vaultIDs The ids of the vaults the wallet has\n  function vaultIDs(address _wallet) external view override returns (uint96[] memory _vaultIDs) {\n    _vaultIDs = walletVaultIDs[_wallet];\n  }\n\n  /// @notice Returns an array of all enabled tokens\n  /// @return _enabledTokens The array containing the token addresses\n  function getEnabledTokens() external view override returns (address[] memory _enabledTokens) {\n    _enabledTokens = enabledTokens;\n  }\n\n  /// @notice Returns the token id given a token's address\n  /// @param _tokenAddress The address of the token to target\n  /// @return _tokenId The id of the token\n  function tokenId(address _tokenAddress) external view override returns (uint256 _tokenId) {\n    _tokenId = tokenAddressCollateralInfo[_tokenAddress].tokenId;\n  }\n\n  /// @notice Returns the oracle given a token's address\n  /// @param _tokenAddress The id of the token\n  /// @return _oracle The address of the token's oracle\n  function tokensOracle(address _tokenAddress) external view override returns (IOracleRelay _oracle) {\n    _oracle = tokenAddressCollateralInfo[_tokenAddress].oracle;\n  }\n\n  /// @notice Returns the ltv of a given token address\n  /// @param _tokenAddress The address of the token\n  /// @return _ltv The loan-to-value of a token\n  function tokenLTV(address _tokenAddress) external view override returns (uint256 _ltv) {\n    _ltv = tokenAddressCollateralInfo[_tokenAddress].ltv;\n  }\n\n  /// @notice Returns the liquidation incentive of an accepted token collateral\n  /// @param _tokenAddress The address of the token\n  /// @return _liquidationIncentive The liquidation incentive of the token\n  function tokenLiquidationIncentive(address _tokenAddress)\n    external\n    view\n    override\n    returns (uint256 _liquidationIncentive)\n  {\n    _liquidationIncentive = tokenAddressCollateralInfo[_tokenAddress].liquidationIncentive;\n  }\n\n  /// @notice Returns the cap of a given token address\n  /// @param _tokenAddress The address of the token\n  /// @return _cap The cap of the token\n  function tokenCap(address _tokenAddress) external view override returns (uint256 _cap) {\n    _cap = tokenAddressCollateralInfo[_tokenAddress].cap;\n  }\n\n  /// @notice Returns the total deposited of a given token address\n  /// @param _tokenAddress The address of the token\n  /// @return _totalDeposited The total deposited of a token\n  function tokenTotalDeposited(address _tokenAddress) external view override returns (uint256 _totalDeposited) {\n    _totalDeposited = tokenAddressCollateralInfo[_tokenAddress].totalDeposited;\n  }\n\n  /// @notice Returns the collateral type of a token\n  /// @param _tokenAddress The address of the token\n  /// @return _type The collateral type of a token\n  function tokenCollateralType(address _tokenAddress) external view override returns (CollateralType _type) {\n    _type = tokenAddressCollateralInfo[_tokenAddress].collateralType;\n  }\n\n  /// @notice Returns the address of the crvRewards contract\n  /// @param _tokenAddress The address of the token\n  /// @return _crvRewardsContract The address of the crvRewards contract\n  function tokenCrvRewardsContract(address _tokenAddress)\n    external\n    view\n    override\n    returns (IBaseRewardPool _crvRewardsContract)\n  {\n    _crvRewardsContract = tokenAddressCollateralInfo[_tokenAddress].crvRewardsContract;\n  }\n\n  /// @notice Returns the pool id of a curve LP type token\n  /// @dev    If the token is not of type CurveLPStakedOnConvex then it returns 0\n  /// @param _tokenAddress The address of the token\n  /// @return _poolId The pool id of a curve LP type token\n  function tokenPoolId(address _tokenAddress) external view override returns (uint256 _poolId) {\n    _poolId = tokenAddressCollateralInfo[_tokenAddress].poolId;\n  }\n\n  /// @notice Returns the collateral info of a given token address\n  /// @param _tokenAddress The address of the token\n  /// @return _collateralInfo The complete collateral info of the token\n  function tokenCollateralInfo(address _tokenAddress)\n    external\n    view\n    override\n    returns (CollateralInfo memory _collateralInfo)\n  {\n    _collateralInfo = tokenAddressCollateralInfo[_tokenAddress];\n  }\n\n  /// @notice Returns the selected collaterals info. Will iterate from `_start` (included) until `_end` (not included)\n  /// @param _start The start number to loop on the array\n  /// @param _end The end number to loop on the array\n  /// @return _collateralsInfo The array containing all the collateral info\n  function getCollateralsInfo(\n    uint256 _start,\n    uint256 _end\n  ) external view override returns (CollateralInfo[] memory _collateralsInfo) {\n    // check if `_end` is bigger than the tokens length\n    uint256 _enabledTokensLength = enabledTokens.length;\n    _end = _enabledTokensLength < _end ? _enabledTokensLength : _end;\n\n    _collateralsInfo = new CollateralInfo[](_end - _start);\n\n    for (uint256 _i = _start; _i < _end;) {\n      _collateralsInfo[_i - _start] = tokenAddressCollateralInfo[enabledTokens[_i]];\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /// @notice Migrates all collateral information from previous vault controller\n  /// @param _oldVaultController The address of the vault controller to take the information from\n  /// @param _tokenAddresses The addresses of the tokens we want to target\n  function _migrateCollateralsFrom(IVaultController _oldVaultController, address[] memory _tokenAddresses) internal {\n    uint256 _tokenId;\n    uint256 _tokensRegistered;\n    for (uint256 _i; _i < _tokenAddresses.length;) {\n      _tokenId = _oldVaultController.tokenId(_tokenAddresses[_i]);\n      if (_tokenId == 0) revert VaultController_WrongCollateralAddress();\n      _tokensRegistered++;\n\n      CollateralInfo memory _collateral = _oldVaultController.tokenCollateralInfo(_tokenAddresses[_i]);\n      _collateral.tokenId = _tokensRegistered;\n      _collateral.totalDeposited = 0;\n\n      enabledTokens.push(_tokenAddresses[_i]);\n      tokenAddressCollateralInfo[_tokenAddresses[_i]] = _collateral;\n\n      unchecked {\n        ++_i;\n      }\n    }\n    tokensRegistered += _tokensRegistered;\n\n    emit CollateralsMigratedFrom(_oldVaultController, _tokenAddresses);\n  }\n\n  /// @notice Creates a new vault and returns it's address\n  /// @return _vaultAddress The address of the newly created vault\n  function mintVault() public override whenNotPaused returns (address _vaultAddress) {\n    // increment  minted vaults\n    vaultsMinted += 1;\n    // mint the vault itself, deploying the contract\n    _vaultAddress = _createVault(vaultsMinted, _msgSender());\n    // add the vault to our system\n    vaultIdVaultAddress[vaultsMinted] = _vaultAddress;\n\n    //push new vault ID onto mapping\n    walletVaultIDs[_msgSender()].push(vaultsMinted);\n\n    // emit the event\n    emit NewVault(_vaultAddress, vaultsMinted, _msgSender());\n  }\n\n  /// @notice Pauses the functionality of the contract\n  function pause() external override onlyPauser {\n    _pause();\n  }\n\n  /// @notice Unpauses the functionality of the contract\n  function unpause() external override onlyPauser {\n    _unpause();\n  }\n\n  /// @notice Registers the USDA contract\n  /// @param _usdaAddress The address to register as USDA\n  function registerUSDA(address _usdaAddress) external override onlyOwner {\n    usda = IUSDA(_usdaAddress);\n    emit RegisterUSDA(_usdaAddress);\n  }\n\n  /// @notice Emited when the owner registers a curve master\n  /// @param _masterCurveAddress The address of the curve master\n  function registerCurveMaster(address _masterCurveAddress) external override onlyOwner {\n    curveMaster = CurveMaster(_masterCurveAddress);\n    emit RegisterCurveMaster(_masterCurveAddress);\n  }\n\n  /// @notice Updates the protocol fee\n  /// @param _newProtocolFee The new protocol fee in terms of 1e18=100%\n  function changeProtocolFee(uint192 _newProtocolFee) external override onlyOwner {\n    if (_newProtocolFee >= 1e18) revert VaultController_FeeTooLarge();\n    protocolFee = _newProtocolFee;\n    emit NewProtocolFee(_newProtocolFee);\n  }\n\n  /// @notice Register a new token to be used as collateral\n  /// @param _tokenAddress The address of the token to register\n  /// @param _ltv The ltv of the token, 1e18=100%\n  /// @param _oracleAddress The address of oracle to fetch the price of the token\n  /// @param _liquidationIncentive The liquidation penalty for the token, 1e18=100%\n  /// @param _cap The maximum amount to be deposited\n  function registerErc20(\n    address _tokenAddress,\n    uint256 _ltv,\n    address _oracleAddress,\n    uint256 _liquidationIncentive,\n    uint256 _cap,\n    uint256 _poolId\n  ) external override onlyOwner {\n    CollateralInfo storage _collateral = tokenAddressCollateralInfo[_tokenAddress];\n    if (_collateral.tokenId != 0) revert VaultController_TokenAlreadyRegistered();\n    uint8 _tokenDecimals = IERC20Metadata(_tokenAddress).decimals();\n    if (_tokenDecimals > MAX_DECIMALS) revert VaultController_TooManyDecimals();\n    if (_poolId != 0) {\n      (address _lpToken,,, address _crvRewards,,) = BOOSTER.poolInfo(_poolId);\n      if (_lpToken != _tokenAddress) revert VaultController_TokenAddressDoesNotMatchLpAddress();\n      _collateral.collateralType = CollateralType.CurveLPStakedOnConvex;\n      _collateral.crvRewardsContract = IBaseRewardPool(_crvRewards);\n      _collateral.poolId = _poolId;\n    } else {\n      _collateral.collateralType = CollateralType.Single;\n      _collateral.crvRewardsContract = IBaseRewardPool(address(0));\n      _collateral.poolId = 0;\n    }\n    // ltv must be compatible with liquidation incentive\n    if (_ltv >= (EXP_SCALE - _liquidationIncentive)) revert VaultController_LTVIncompatible();\n    // increment the amount of registered token\n    tokensRegistered = tokensRegistered + 1;\n    // set & give the token an id\n    _collateral.tokenId = tokensRegistered;\n    // set the token's oracle\n    _collateral.oracle = IOracleRelay(_oracleAddress);\n    // set the token's ltv\n    _collateral.ltv = _ltv;\n    // set the token's liquidation incentive\n    _collateral.liquidationIncentive = _liquidationIncentive;\n    // set the cap\n    _collateral.cap = _cap;\n    // save the decimals\n    _collateral.decimals = _tokenDecimals;\n    // finally, add the token to the array of enabled tokens\n    enabledTokens.push(_tokenAddress);\n\n    emit RegisteredErc20(_tokenAddress, _ltv, _oracleAddress, _liquidationIncentive, _cap);\n  }\n\n  /// @notice Updates an existing collateral with new collateral parameters\n  /// @param _tokenAddress The address of the token to modify\n  /// @param _ltv The new loan-to-value of the token, 1e18=100%\n  /// @param _oracleAddress The address of oracle to modify for the price of the token\n  /// @param _liquidationIncentive The new liquidation penalty for the token, 1e18=100%\n  /// @param _cap The maximum amount to be deposited\n  /// @param _poolId The convex pool id of a crv lp token\n  function updateRegisteredErc20(\n    address _tokenAddress,\n    uint256 _ltv,\n    address _oracleAddress,\n    uint256 _liquidationIncentive,\n    uint256 _cap,\n    uint256 _poolId\n  ) external override onlyOwner {\n    CollateralInfo storage _collateral = tokenAddressCollateralInfo[_tokenAddress];\n    if (_collateral.tokenId == 0) revert VaultController_TokenNotRegistered();\n    // _ltv must be compatible with liquidation incentive\n    if (_ltv >= (EXP_SCALE - _liquidationIncentive)) revert VaultController_LTVIncompatible();\n    if (_poolId != 0) {\n      (address _lpToken,,, address _crvRewards,,) = BOOSTER.poolInfo(_poolId);\n      if (_lpToken != _tokenAddress) revert VaultController_TokenAddressDoesNotMatchLpAddress();\n      _collateral.collateralType = CollateralType.CurveLPStakedOnConvex;\n      _collateral.crvRewardsContract = IBaseRewardPool(_crvRewards);\n      _collateral.poolId = _poolId;\n    }\n    // set the oracle of the token\n    _collateral.oracle = IOracleRelay(_oracleAddress);\n    // set the ltv of the token\n    _collateral.ltv = _ltv;\n    // set the liquidation incentive of the token\n    _collateral.liquidationIncentive = _liquidationIncentive;\n    // set the cap\n    _collateral.cap = _cap;\n\n    emit UpdateRegisteredErc20(_tokenAddress, _ltv, _oracleAddress, _liquidationIncentive, _cap, _poolId);\n  }\n\n  /// @notice Change the claimer contract, used to exchange a fee from curve lp rewards for AMPH tokens\n  /// @param _newClaimerContract The new claimer contract\n  function changeClaimerContract(IAMPHClaimer _newClaimerContract) external override onlyOwner {\n    IAMPHClaimer _oldClaimerContract = claimerContract;\n    claimerContract = _newClaimerContract;\n\n    emit ChangedClaimerContract(_oldClaimerContract, _newClaimerContract);\n  }\n\n  /// @notice Change the initial borrowing fee\n  /// @param _newBorrowingFee The new borrowing fee\n  function changeInitialBorrowingFee(uint192 _newBorrowingFee) external override onlyOwner {\n    if (_newBorrowingFee >= MAX_INIT_BORROWING_FEE) revert VaultController_FeeTooLarge();\n    uint192 _oldBorrowingFee = initialBorrowingFee;\n    initialBorrowingFee = _newBorrowingFee;\n\n    emit ChangedInitialBorrowingFee(_oldBorrowingFee, _newBorrowingFee);\n  }\n\n  /// @notice Change the liquidation fee\n  /// @param _newLiquidationFee The new liquidation fee\n  function changeLiquidationFee(uint192 _newLiquidationFee) external override onlyOwner {\n    if (_newLiquidationFee >= 1e18) revert VaultController_FeeTooLarge();\n    uint192 _oldLiquidationFee = liquidationFee;\n    liquidationFee = _newLiquidationFee;\n\n    emit ChangedLiquidationFee(_oldLiquidationFee, _newLiquidationFee);\n  }\n\n  /// @notice Check a vault for over-collateralization\n  /// @dev This function calls peekVaultBorrowingPower so no state change is done\n  /// @param _id The id of vault we want to target\n  /// @return _overCollateralized Returns true if vault over-collateralized; false if vault under-collaterlized\n  function peekCheckVault(uint96 _id) public view override returns (bool _overCollateralized) {\n    // grab the vault by id if part of our system. revert if not\n    IVault _vault = _getVault(_id);\n    // calculate the total value of the vault's liquidity\n    uint256 _totalLiquidityValue = _peekVaultBorrowingPower(_vault);\n    // calculate the total liability of the vault\n    uint256 _usdaLiability = _truncate((_vault.baseLiability() * interest.factor));\n    // if the ltv >= liability, the vault is solvent\n    _overCollateralized = (_totalLiquidityValue >= _usdaLiability);\n  }\n\n  /// @notice Check a vault for over-collateralization\n  /// @dev This function calls getVaultBorrowingPower to allow state changes to happen if an oracle need them\n  /// @param _id The id of vault we want to target\n  /// @return _overCollateralized Returns true if vault over-collateralized; false if vault under-collaterlized\n  function checkVault(uint96 _id) public returns (bool _overCollateralized) {\n    // grab the vault by id if part of our system. revert if not\n    IVault _vault = _getVault(_id);\n    // calculate the total value of the vault's liquidity\n    uint256 _totalLiquidityValue = _getVaultBorrowingPower(_vault);\n    // calculate the total liability of the vault\n    uint256 _usdaLiability = _truncate((_vault.baseLiability() * interest.factor));\n    // if the ltv >= liability, the vault is solvent\n    _overCollateralized = (_totalLiquidityValue >= _usdaLiability);\n  }\n\n  /// @notice Borrows USDA from a vault. Only the vault minter may borrow from their vault\n  /// @param _id The id of vault we want to target\n  /// @param _amount The amount of USDA to borrow\n  function borrowUSDA(uint96 _id, uint192 _amount) external override {\n    _borrow(_id, _amount, _msgSender(), true);\n  }\n\n  /// @notice Borrows USDA from a vault and send the USDA to a specific address\n  /// @param _id The id of vault we want to target\n  /// @param _amount The amount of USDA to borrow\n  /// @param _target The address to receive borrowed USDA\n  function borrowUSDAto(uint96 _id, uint192 _amount, address _target) external override {\n    _borrow(_id, _amount, _target, true);\n  }\n\n  /// @notice Borrows sUSD directly from reserve, liability is still in USDA, and USDA must be repaid\n  /// @param _id The id of vault we want to target\n  /// @param _susdAmount The amount of sUSD to borrow\n  /// @param _target The address to receive borrowed sUSD\n  function borrowsUSDto(uint96 _id, uint192 _susdAmount, address _target) external override {\n    _borrow(_id, _susdAmount, _target, false);\n  }\n\n  /// @notice Returns the initial borrowing fee\n  /// @param _amount The base amount\n  /// @return _fee The fee calculated based on a base amount\n  function getBorrowingFee(uint192 _amount) public view override returns (uint192 _fee) {\n    // _amount * (100% + initialBorrowingFee)\n    _fee = _safeu192(_truncate(uint256(_amount * (1e18 + initialBorrowingFee)))) - _amount;\n  }\n\n  /// @notice Returns the liquidation fee\n  /// @param _tokensToLiquidate The collateral amount\n  /// @param _assetAddress The collateral address to liquidate\n  /// @return _fee The fee calculated based on amount\n  function getLiquidationFee(\n    uint192 _tokensToLiquidate,\n    address _assetAddress\n  ) public view override returns (uint192 _fee) {\n    uint256 _liquidationIncentive = tokenAddressCollateralInfo[_assetAddress].liquidationIncentive;\n    // _tokensToLiquidate * (100% + _liquidationIncentive)\n    uint192 _liquidatorExpectedProfit =\n      _safeu192(_truncate(uint256(_tokensToLiquidate * (1e18 + _liquidationIncentive)))) - _tokensToLiquidate;\n    // _liquidatorExpectedProfit * (100% + liquidationFee)\n    _fee =\n      _safeu192(_truncate(uint256(_liquidatorExpectedProfit * (1e18 + liquidationFee)))) - _liquidatorExpectedProfit;\n  }\n\n  /// @notice Business logic to perform the USDA loan\n  /// @dev Pays interest\n  /// @param _id The vault's id to borrow against\n  /// @param _amount The amount of USDA to borrow\n  /// @param _target The address to receive borrowed USDA\n  /// @param _isUSDA Boolean indicating if the borrowed asset is USDA (if FALSE is sUSD)\n  function _borrow(uint96 _id, uint192 _amount, address _target, bool _isUSDA) internal paysInterest whenNotPaused {\n    // grab the vault by id if part of our system. revert if not\n    IVault _vault = _getVault(_id);\n    // only the minter of the vault may borrow from their vault\n    if (_msgSender() != _vault.minter()) revert VaultController_OnlyMinter();\n    // add the fee\n    uint192 _fee = getBorrowingFee(_amount);\n    // the base amount is the amount of USDA they wish to borrow divided by the interest factor, accounting for the fee\n    uint192 _baseAmount = _safeu192(uint256((_amount + _fee) * EXP_SCALE) / uint256(interest.factor));\n    // _baseLiability should contain the vault's new liability, in terms of base units\n    // true indicates that we are adding to the liability\n    uint256 _baseLiability = _vault.modifyLiability(true, _baseAmount);\n    // increase the total base liability by the _baseAmount\n    // the same amount we added to the vault's liability\n    totalBaseLiability += _baseAmount;\n    // now take the vault's total base liability and multiply it by the interest factor\n    uint256 _usdaLiability = _truncate(uint256(interest.factor) * _baseLiability);\n    // now get the ltv of the vault, aka their borrowing power, in usda\n    uint256 _totalLiquidityValue = _getVaultBorrowingPower(_vault);\n    // the ltv must be above the newly calculated _usdaLiability, else revert\n    if (_totalLiquidityValue < _usdaLiability) revert VaultController_VaultInsolvent();\n\n    if (_isUSDA) {\n      // now send usda to the target, equal to the amount they are owed\n      usda.vaultControllerMint(_target, _amount);\n    } else {\n      // send sUSD to the target from reserve instead of mint\n      usda.vaultControllerTransfer(_target, _amount);\n    }\n\n    // also send the fee to the treasury\n    if (_fee > 0) usda.vaultControllerMint(owner(), _fee);\n\n    // emit the event\n    emit BorrowUSDA(_id, address(_vault), _amount, _fee);\n  }\n\n  /// @notice Repays a vault's USDA loan. Anyone may repay\n  /// @dev Pays interest\n  /// @param _id The id of vault we want to target\n  /// @param _amount The amount of USDA to repay\n  function repayUSDA(uint96 _id, uint192 _amount) external override {\n    _repay(_id, _amount, false);\n  }\n\n  /// @notice Repays all of a vault's USDA. Anyone may repay a vault's liabilities\n  /// @dev Pays interest\n  /// @param _id The id of vault we want to target\n  function repayAllUSDA(uint96 _id) external override {\n    _repay(_id, 0, true);\n  }\n\n  /// @notice Business logic to perform the USDA repay\n  /// @dev Pays interest\n  /// @param _id The vault's id to repay\n  /// @param _amountInUSDA The amount of USDA to borrow\n  /// @param _repayAll Boolean if TRUE, repay all debt\n  function _repay(uint96 _id, uint192 _amountInUSDA, bool _repayAll) internal paysInterest whenNotPaused {\n    // grab the vault by id if part of our system. revert if not\n    IVault _vault = _getVault(_id);\n    uint192 _baseAmount;\n\n    // if _repayAll == TRUE, repay total liability\n    if (_repayAll) {\n      // store the vault baseLiability in memory\n      _baseAmount = _safeu192(_vault.baseLiability());\n      // get the total USDA liability, equal to the interest factor * vault's base liabilty\n      _amountInUSDA = _safeu192(_truncate(interest.factor * _baseAmount));\n    } else {\n      // the base amount is the amount of USDA entered divided by the interest factor\n      _baseAmount = _safeu192((_amountInUSDA * EXP_SCALE) / interest.factor);\n    }\n    // decrease the total base liability by the calculated base amount\n    totalBaseLiability -= _baseAmount;\n    // ensure that _baseAmount is lower than the vault's base liability.\n    // this may not be needed, since modifyLiability *should* revert if is not true\n    if (_baseAmount > _vault.baseLiability()) revert VaultController_RepayTooMuch();\n    // decrease the vault's liability by the calculated base amount\n    _vault.modifyLiability(false, _baseAmount);\n    // burn the amount of USDA submitted from the sender\n    usda.vaultControllerBurn(_msgSender(), _amountInUSDA);\n\n    emit RepayUSDA(_id, address(_vault), _amountInUSDA);\n  }\n\n  /// @notice Simulates the liquidation of an underwater vault\n  /// @dev Returns all zeros if vault is solvent\n  /// @param _id The id of vault we want to target\n  /// @param _assetAddress The address of the token the liquidator wishes to liquidate\n  /// @param _tokensToLiquidate The number of tokens to liquidate\n  /// @return _collateralLiquidated The number of collateral tokens the liquidator will receive\n  /// @return _usdaPaid The amount of USDA the liquidator will have to pay\n  function simulateLiquidateVault(\n    uint96 _id,\n    address _assetAddress,\n    uint256 _tokensToLiquidate\n  ) external view override returns (uint256 _collateralLiquidated, uint256 _usdaPaid) {\n    // cannot liquidate 0\n    if (_tokensToLiquidate == 0) revert VaultController_LiquidateZeroTokens();\n    // check for registered asset\n    if (tokenAddressCollateralInfo[_assetAddress].tokenId == 0) revert VaultController_TokenNotRegistered();\n\n    // calculate the amount to liquidate and the 'bad fill price' using liquidationMath\n    // see _liquidationMath for more detailed explaination of the math\n    (uint256 _tokenAmount, uint256 _badFillPrice) = _peekLiquidationMath(_id, _assetAddress, _tokensToLiquidate);\n    // set _tokensToLiquidate to this calculated amount if the function does not fail\n    _collateralLiquidated = _tokenAmount != 0 ? _tokenAmount : _tokensToLiquidate;\n    // the USDA to repurchase is equal to the bad fill price multiplied by the amount of tokens to liquidate\n    _usdaPaid = _truncate(_badFillPrice * _collateralLiquidated);\n    // extract fee\n    _collateralLiquidated -= getLiquidationFee(uint192(_collateralLiquidated), _assetAddress);\n  }\n\n  /// @notice Liquidates an underwater vault\n  /// @dev Pays interest before liquidation. Vaults may be liquidated up to the point where they are exactly solvent\n  /// @param _id The id of vault we want to target\n  /// @param _assetAddress The address of the token the liquidator wishes to liquidate\n  /// @param _tokensToLiquidate The number of tokens to liquidate\n  /// @return _toLiquidate The number of tokens that got liquidated\n  function liquidateVault(\n    uint96 _id,\n    address _assetAddress,\n    uint256 _tokensToLiquidate\n  ) external override paysInterest whenNotPaused returns (uint256 _toLiquidate) {\n    // cannot liquidate 0\n    if (_tokensToLiquidate == 0) revert VaultController_LiquidateZeroTokens();\n    // check for registered asset\n    if (tokenAddressCollateralInfo[_assetAddress].tokenId == 0) revert VaultController_TokenNotRegistered();\n\n    // calculate the amount to liquidate and the 'bad fill price' using liquidationMath\n    // see _liquidationMath for more detailed explaination of the math\n    (uint256 _tokenAmount, uint256 _badFillPrice) = _liquidationMath(_id, _assetAddress, _tokensToLiquidate);\n    // set _tokensToLiquidate to this calculated amount if the function does not fail\n    if (_tokenAmount > 0) _tokensToLiquidate = _tokenAmount;\n    // the USDA to repurchase is equal to the bad fill price multiplied by the amount of tokens to liquidate\n    uint256 _usdaToRepurchase = _truncate(_badFillPrice * _tokensToLiquidate);\n    // get the vault that the liquidator wishes to liquidate\n    IVault _vault = _getVault(_id);\n\n    // decrease the vault's liability\n    _vault.modifyLiability(false, (_usdaToRepurchase * 1e18) / interest.factor);\n\n    // decrease the total base liability\n    totalBaseLiability -= _safeu192((_usdaToRepurchase * 1e18) / interest.factor);\n\n    // decrease liquidator's USDA balance\n    usda.vaultControllerBurn(_msgSender(), _usdaToRepurchase);\n\n    // withdraw from convex\n    CollateralInfo memory _assetInfo = tokenAddressCollateralInfo[_assetAddress];\n    if (_vault.isTokenStaked(_assetAddress)) {\n      _vault.controllerWithdrawAndUnwrap(_assetInfo.crvRewardsContract, _tokensToLiquidate);\n    }\n\n    uint192 _liquidationFee = getLiquidationFee(uint192(_tokensToLiquidate), _assetAddress);\n\n    // finally, deliver tokens to liquidator\n    _vault.controllerTransfer(_assetAddress, _msgSender(), _tokensToLiquidate - _liquidationFee);\n    // and the fee to the treasury\n    _vault.controllerTransfer(_assetAddress, owner(), _liquidationFee);\n    // and reduces total\n    _modifyTotalDeposited(_tokensToLiquidate, _assetAddress, false);\n\n    // this mainly prevents reentrancy\n    if (_getVaultBorrowingPower(_vault) > _vaultLiability(_id)) revert VaultController_OverLiquidation();\n\n    // emit the event\n    emit Liquidate(_id, _assetAddress, _usdaToRepurchase, _tokensToLiquidate - _liquidationFee, _liquidationFee);\n    // return the amount of tokens liquidated (including fee)\n    _toLiquidate = _tokensToLiquidate;\n  }\n\n  /// @notice Returns the calculated amount of tokens to liquidate for a vault\n  /// @dev The amount of tokens owed is a moving target and changes with each block as payInterest is called\n  ///      This function can serve to give an indication of how many tokens can be liquidated\n  ///      All this function does is call _liquidationMath with 2**256-1 as the amount\n  /// @param _id The id of vault we want to target\n  /// @param _assetAddress The address of token to calculate how many tokens to liquidate\n  /// @return _tokensToLiquidate The amount of tokens liquidatable\n  function tokensToLiquidate(\n    uint96 _id,\n    address _assetAddress\n  ) external view override returns (uint256 _tokensToLiquidate) {\n    (\n      _tokensToLiquidate, // bad fill price\n    ) = _peekLiquidationMath(_id, _assetAddress, 2 ** 256 - 1);\n  }\n\n  /// @notice Internal function with business logic for liquidation math without any state changes\n  /// @param _id The vault to get info for"
    }
  ]
}