{
  "Title": "Initialization Performed Outside of Initialization Function",
  "Content": "The [`updateMessenger` function](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L2/predeploys/L2MessageQueue.sol#L47) in `L2MessageQueue` can only be called before any message is appended, otherwise it will revert since [`nextMessageIndex`](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L2/predeploys/L2MessageQueue.sol#L48) is sequentially increased. Therefore, the `updateMessenger` logic aligns closer with the purpose of the [`initialize` function](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L2/predeploys/L2MessageQueue.sol#L27-L29), rather than a standalone function.\n\n\nConsider moving the logic of `updateMessenger` into the `initialize` function with the `onlyOwner` modifier. This can be done since the predeployed contracts should exist before `L2ScrollMessenger`.\n\n\n***Update:** Resolved in [pull request #652](https://github.com/scroll-tech/scroll/pull/652) at commit [dd9d880](https://github.com/scroll-tech/scroll/pull/652/commits/dd9d880c2ae867ec2eb21f4ac3f42a902d72f929).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/src/L2/predeploys/L2MessageQueue.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {AppendOnlyMerkleTree} from \"../../libraries/common/AppendOnlyMerkleTree.sol\";\nimport {OwnableBase} from \"../../libraries/common/OwnableBase.sol\";\n\n/// @title L2MessageQueue\n/// @notice The original idea is from Optimism, see [OVM_L2ToL1MessagePasser](https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts/contracts/L2/predeploys/OVM_L2ToL1MessagePasser.sol).\n/// The L2 to L1 Message Passer is a utility contract which facilitate an L1 proof of the\n/// of a message on L2. The L1 Cross Domain Messenger performs this proof in its\n/// _verifyStorageProof function, which verifies the existence of the transaction hash in this\n/// contract's `sentMessages` mapping.\ncontract L2MessageQueue is AppendOnlyMerkleTree, OwnableBase {\n    /// @notice Emitted when a new message is added to the merkle tree.\n    /// @param index The index of the corresponding message.\n    /// @param messageHash The hash of the corresponding message.\n    event AppendMessage(uint256 index, bytes32 messageHash);\n\n    /// @notice The address of L2ScrollMessenger contract.\n    address public messenger;\n\n    constructor(address _owner) {\n        _transferOwnership(_owner);\n    }\n\n    function initialize() external {\n        _initializeMerkleTree();\n    }\n\n    /// @notice record the message to merkle tree and compute the new root.\n    /// @param _messageHash The hash of the new added message.\n    function appendMessage(bytes32 _messageHash) external returns (bytes32) {\n        require(msg.sender == messenger, \"only messenger\");\n\n        (uint256 _currentNonce, bytes32 _currentRoot) = _appendMessageHash(_messageHash);\n\n        // We can use the event to compute the merkle tree locally.\n        emit AppendMessage(_currentNonce, _messageHash);\n\n        return _currentRoot;\n    }\n\n    /// @notice Update the address of messenger.\n    /// @dev You are not allowed to update messenger when there are some messages appended.\n    /// @param _messenger The address of messenger to update.\n    function updateMessenger(address _messenger) external onlyOwner {\n        require(nextMessageIndex == 0, \"cannot update messenger\");\n\n        messenger = _messenger;\n    }\n}"
    }
  ]
}