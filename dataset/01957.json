{
  "Title": "[H-01] AURA token will not be accounted for in `tokensIn`",
  "Content": "When the controller sees a call to Aura's `getReward()` function, it uses the following logic to set `tokensOut` and `tokensIn`:\n```solidity\nfunction canCallGetReward(address target) internal view returns (bool, address[] memory, address[] memory) {\n    uint256 rewardLength = IRewards(target).extraRewardsLength();\n    address[] memory tokensIn = new address[](rewardLength + 1);\n    for (uint256 i = 0; i < rewardLength; i++) {\n        tokensIn[i] = IRewards(IRewards(target).extraRewards(i)).rewardToken();\n    }\n    tokensIn[rewardLength] = IRewards(target).rewardToken();\n    return (true, tokensIn, new address[](0));\n}\n```\nThis sets the `tokensIn` to equal an array with all the `extraRewards` tokens, as well as the target contract's `rewardToken`.\n\nHowever, if we examine the code itself, we will see that `getReward()` sends out all the tokens we accounted for (the `rewardToken` as well as all the `extraRewards`) and also makes the following call:\n```solidity\nIDeposit(operator).rewardClaimed(pid, _account, reward);\n```\nhttps://github.com/convex-eth/platform/blob/b93b7b77169777f3d508feffc646042709e40ef7/contracts/contracts/BaseRewardPool.sol#L263-L279\n\nFollowing that logic, we find the following function in the `Booster.sol` contract:\n```solidity\nfunction rewardClaimed(uint256 _pid, address _address, uint256 _amount) external returns(bool){\n    address rewardContract = poolInfo[_pid].crvRewards;\n    require(msg.sender == rewardContract || msg.sender == lockRewards, \"!auth\");\n\n    //mint reward tokens\n    ITokenMinter(minter).mint(_address,_amount);\n\n    return true;\n}\n```\nhttps://github.com/convex-eth/platform/blob/b93b7b77169777f3d508feffc646042709e40ef7/contracts/contracts/Booster.sol#L458C12-L466\n\nAs we can see, this additional call mints the `AURA` token to the `receiver`.\n\nThis token is not accounted for in `tokensIn`, which means it will not contribute to an account's balance in Sentiment. As a result, the account could be unfairly liquidated due to the missing balance.\n\n**Recommendation**\n\nAdd the `AURA` token to the `tokensIn` array. If the deployment on Arbitrum matches Mainnet, it can be accessed as follows:\n```solidity\nIBooster(IRewards(target).operator()).minter();\n```\n\n**Review**\n\nFixed in [commit 49db04366e255568f0cab1e6e083b9fff808b384](https://github.com/sentimentxyz/controller/pull/64/commits/49db04366e255568f0cab1e6e083b9fff808b384) as recommended.",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/contracts/BaseRewardPool.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n/**\n *Submitted for verification at Etherscan.io on 2020-07-17\n */\n\n/*\n   ____            __   __        __   _\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\n _\\ \\ / // // _ \\/ __// _ \\/ -_)/ __// / \\ \\ /\n/___/ \\_, //_//_/\\__//_//_/\\__/ \\__//_/ /_\\_\\\n     /___/\n\n* Synthetix: BaseRewardPool.sol\n*\n* Docs: https://docs.synthetix.io/\n*\n*\n* MIT License\n* ===========\n*\n* Copyright (c) 2020 Synthetix\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n*/\n\nimport \"./Interfaces.sol\";\nimport \"./interfaces/MathUtil.sol\";\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/utils/Address.sol';\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\n\n\n\ncontract BaseRewardPool {\n     using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 public rewardToken;\n    IERC20 public stakingToken;\n    uint256 public constant duration = 7 days;\n\n    address public operator;\n    address public rewardManager;\n\n    uint256 public pid;\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    uint256 public queuedRewards = 0;\n    uint256 public currentRewards = 0;\n    uint256 public historicalRewards = 0;\n    uint256 public constant newRewardRatio = 830;\n    uint256 private _totalSupply;\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n    mapping(address => uint256) private _balances;\n\n    address[] public extraRewards;\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n\n    constructor(\n        uint256 pid_,\n        address stakingToken_,\n        address rewardToken_,\n        address operator_,\n        address rewardManager_\n    ) public {\n        pid = pid_;\n        stakingToken = IERC20(stakingToken_);\n        rewardToken = IERC20(rewardToken_);\n        operator = operator_;\n        rewardManager = rewardManager_;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function extraRewardsLength() external view returns (uint256) {\n        return extraRewards.length;\n    }\n\n    function addExtraReward(address _reward) external returns(bool){\n        require(msg.sender == rewardManager, \"!authorized\");\n        require(_reward != address(0),\"!reward setting\");\n\n        extraRewards.push(_reward);\n        return true;\n    }\n    function clearExtraRewards() external{\n        require(msg.sender == rewardManager, \"!authorized\");\n        delete extraRewards;\n    }\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return MathUtil.min(block.timestamp, periodFinish);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalSupply() == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable()\n                    .sub(lastUpdateTime)\n                    .mul(rewardRate)\n                    .mul(1e18)\n                    .div(totalSupply())\n            );\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return\n            balanceOf(account)\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e18)\n                .add(rewards[account]);\n    }\n\n    function stake(uint256 _amount)\n        public\n        updateReward(msg.sender)\n        returns(bool)\n    {\n        require(_amount > 0, 'RewardPool : Cannot stake 0');\n        \n        //also stake to linked rewards\n        for(uint i=0; i < extraRewards.length; i++){\n            IRewards(extraRewards[i]).stake(msg.sender, _amount);\n        }\n\n        _totalSupply = _totalSupply.add(_amount);\n        _balances[msg.sender] = _balances[msg.sender].add(_amount);\n\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n        emit Staked(msg.sender, _amount);\n\n        \n        return true;\n    }\n\n    function stakeAll() external returns(bool){\n        uint256 balance = stakingToken.balanceOf(msg.sender);\n        stake(balance);\n        return true;\n    }\n\n    function stakeFor(address _for, uint256 _amount)\n        public\n        updateReward(_for)\n        returns(bool)\n    {\n        require(_amount > 0, 'RewardPool : Cannot stake 0');\n        \n        //also stake to linked rewards\n        for(uint i=0; i < extraRewards.length; i++){\n            IRewards(extraRewards[i]).stake(_for, _amount);\n        }\n\n        //give to _for\n        _totalSupply = _totalSupply.add(_amount);\n        _balances[_for] = _balances[_for].add(_amount);\n\n        //take away from sender\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n        emit Staked(_for, _amount);\n        \n        return true;\n    }\n\n\n    function withdraw(uint256 amount, bool claim)\n        public\n        updateReward(msg.sender)\n        returns(bool)\n    {\n        require(amount > 0, 'RewardPool : Cannot withdraw 0');\n\n        //also withdraw from linked rewards\n        for(uint i=0; i < extraRewards.length; i++){\n            IRewards(extraRewards[i]).withdraw(msg.sender, amount);\n        }\n\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n\n        stakingToken.safeTransfer(msg.sender, amount);\n        emit Withdrawn(msg.sender, amount);\n     \n        if(claim){\n            getReward(msg.sender,true);\n        }\n\n        return true;\n    }\n\n    function withdrawAll(bool claim) external{\n        withdraw(_balances[msg.sender],claim);\n    }\n\n    function withdrawAndUnwrap(uint256 amount, bool claim) public updateReward(msg.sender) returns(bool){\n\n        //also withdraw from linked rewards\n        for(uint i=0; i < extraRewards.length; i++){\n            IRewards(extraRewards[i]).withdraw(msg.sender, amount);\n        }\n        \n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n\n        //tell operator to withdraw from here directly to user\n        IDeposit(operator).withdrawTo(pid,amount,msg.sender);\n        emit Withdrawn(msg.sender, amount);\n\n        //get rewards too\n        if(claim){\n            getReward(msg.sender,true);\n        }\n        return true;\n    }\n\n    function withdrawAllAndUnwrap(bool claim) external{\n        withdrawAndUnwrap(_balances[msg.sender],claim);\n    }\n\n    function getReward(address _account, bool _claimExtras) public updateReward(_account) returns(bool){\n        uint256 reward = earned(_account);\n        if (reward > 0) {\n            rewards[_account] = 0;\n            rewardToken.safeTransfer(_account, reward);\n            IDeposit(operator).rewardClaimed(pid, _account, reward);\n            emit RewardPaid(_account, reward);\n        }\n\n        //also get rewards from linked rewards\n        if(_claimExtras){\n            for(uint i=0; i < extraRewards.length; i++){\n                IRewards(extraRewards[i]).getReward(_account);\n            }\n        }\n        return true;\n    }\n\n    function getReward() external returns(bool){\n        getReward(msg.sender,true);\n        return true;\n    }\n\n    function donate(uint256 _amount) external returns(bool){\n        IERC20(rewardToken).safeTransferFrom(msg.sender, address(this), _amount);\n        queuedRewards = queuedRewards.add(_amount);\n    }\n\n    function queueNewRewards(uint256 _rewards) external returns(bool){\n        require(msg.sender == operator, \"!authorized\");\n\n        _rewards = _rewards.add(queuedRewards);\n\n        if (block.timestamp >= periodFinish) {\n            notifyRewardAmount(_rewards);\n            queuedRewards = 0;\n            return true;\n        }\n\n        //et = now - (finish-duration)\n        uint256 elapsedTime = block.timestamp.sub(periodFinish.sub(duration));\n        //current at now: rewardRate * elapsedTime\n        uint256 currentAtNow = rewardRate * elapsedTime;\n        uint256 queuedRatio = currentAtNow.mul(1000).div(_rewards);\n\n        //uint256 queuedRatio = currentRewards.mul(1000).div(_rewards);\n        if(queuedRatio < newRewardRatio){\n            notifyRewardAmount(_rewards);\n            queuedRewards = 0;\n        }else{\n            queuedRewards = _rewards;\n        }\n        return true;\n    }\n\n    function notifyRewardAmount(uint256 reward)\n        internal\n        updateReward(address(0))\n    {\n        historicalRewards = historicalRewards.add(reward);\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(duration);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            reward = reward.add(leftover);\n            rewardRate = reward.div(duration);\n        }\n        currentRewards = reward;\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp.add(duration);\n        emit RewardAdded(reward);\n    }\n}"
    },
    {
      "filename": "contracts/contracts/Booster.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"./Interfaces.sol\";\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/utils/Address.sol';\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\n\n\ncontract Booster{\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    address public constant crv = address(0xD533a949740bb3306d119CC777fa900bA034cd52);\n    address public constant registry = address(0x0000000022D53366457F9d5E68Ec105046FC4383);\n    uint256 public constant distributionAddressId = 4;\n    address public constant voteOwnership = address(0xE478de485ad2fe566d49342Cbd03E49ed7DB3356);\n    address public constant voteParameter = address(0xBCfF8B0b9419b9A88c44546519b1e909cF330399);\n\n    uint256 public lockIncentive = 1000; //incentive to crv stakers\n    uint256 public stakerIncentive = 450; //incentive to native token stakers\n    uint256 public earmarkIncentive = 50; //incentive to users who spend gas to make calls\n    uint256 public platformFee = 0; //possible fee to build treasury\n    uint256 public constant MaxFees = 2000;\n    uint256 public constant FEE_DENOMINATOR = 10000;\n\n    address public owner;\n    address public feeManager;\n    address public poolManager;\n    address public immutable staker;\n    address public immutable minter;\n    address public rewardFactory;\n    address public stashFactory;\n    address public tokenFactory;\n    address public rewardArbitrator;\n    address public voteDelegate;\n    address public treasury;\n    address public stakerRewards; //cvx rewards\n    address public lockRewards; //cvxCrv rewards(crv)\n    address public lockFees; //cvxCrv vecrv fees\n    address public feeDistro;\n    address public feeToken;\n\n    bool public isShutdown;\n\n    struct PoolInfo {\n        address lptoken;\n        address token;\n        address gauge;\n        address crvRewards;\n        address stash;\n        bool shutdown;\n    }\n\n    //index(pid) -> pool\n    PoolInfo[] public poolInfo;\n    mapping(address => bool) public gaugeMap;\n\n    event Deposited(address indexed user, uint256 indexed poolid, uint256 amount);\n    event Withdrawn(address indexed user, uint256 indexed poolid, uint256 amount);\n\n    constructor(address _staker, address _minter) public {\n        isShutdown = false;\n        staker = _staker;\n        owner = msg.sender;\n        voteDelegate = msg.sender;\n        feeManager = msg.sender;\n        poolManager = msg.sender;\n        feeDistro = address(0); //address(0xA464e6DCda8AC41e03616F95f4BC98a13b8922Dc);\n        feeToken = address(0); //address(0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490);\n        treasury = address(0);\n        minter = _minter;\n    }\n\n\n    /// SETTER SECTION ///\n\n    function setOwner(address _owner) external {\n        require(msg.sender == owner, \"!auth\");\n        owner = _owner;\n    }\n\n    function setFeeManager(address _feeM) external {\n        require(msg.sender == feeManager, \"!auth\");\n        feeManager = _feeM;\n    }\n\n    function setPoolManager(address _poolM) external {\n        require(msg.sender == poolManager, \"!auth\");\n        poolManager = _poolM;\n    }\n\n    function setFactories(address _rfactory, address _sfactory, address _tfactory) external {\n        require(msg.sender == owner, \"!auth\");\n        \n        //reward factory only allow this to be called once even if owner\n        //removes ability to inject malicious staking contracts\n        //token factory can also be immutable\n        if(rewardFactory == address(0)){\n            rewardFactory = _rfactory;\n            tokenFactory = _tfactory;\n        }\n\n        //stash factory should be considered more safe to change\n        //updating may be required to handle new types of gauges\n        stashFactory = _sfactory;\n    }\n\n    function setArbitrator(address _arb) external {\n        require(msg.sender==owner, \"!auth\");\n        rewardArbitrator = _arb;\n    }\n\n    function setVoteDelegate(address _voteDelegate) external {\n        require(msg.sender==voteDelegate, \"!auth\");\n        voteDelegate = _voteDelegate;\n    }\n\n    function setRewardContracts(address _rewards, address _stakerRewards) external {\n        require(msg.sender == owner, \"!auth\");\n        \n        //reward contracts are immutable or else the owner\n        //has a means to redeploy and mint cvx via rewardClaimed()\n        if(lockRewards == address(0)){\n            lockRewards = _rewards;\n            stakerRewards = _stakerRewards;\n        }\n    }\n\n    // Set reward token and claim contract, get from Curve's registry\n    function setFeeInfo() external {\n        require(msg.sender==feeManager, \"!auth\");\n        \n        feeDistro = IRegistry(registry).get_address(distributionAddressId);\n        address _feeToken = IFeeDistro(feeDistro).token();\n        if(feeToken != _feeToken){\n            //create a new reward contract for the new token\n            lockFees = IRewardFactory(rewardFactory).CreateTokenRewards(_feeToken,lockRewards,address(this));\n            feeToken = _feeToken;\n        }\n    }\n\n    function setFees(uint256 _lockFees, uint256 _stakerFees, uint256 _callerFees, uint256 _platform) external{\n        require(msg.sender==feeManager, \"!auth\");\n\n        uint256 total = _lockFees.add(_stakerFees).add(_callerFees).add(_platform);\n        require(total <= MaxFees, \">MaxFees\");\n\n        //values must be within certain ranges     \n        if(_lockFees >= 1000 && _lockFees <= 1500\n            && _stakerFees >= 300 && _stakerFees <= 600\n            && _callerFees >= 10 && _callerFees <= 100\n            && _platform <= 200){\n            lockIncentive = _lockFees;\n            stakerIncentive = _stakerFees;\n            earmarkIncentive = _callerFees;\n            platformFee = _platform;\n        }\n    }\n\n    function setTreasury(address _treasury) external {\n        require(msg.sender==feeManager, \"!auth\");\n        treasury = _treasury;\n    }\n\n    /// END SETTER SECTION ///\n\n\n    function poolLength() external view returns (uint256) {\n        return poolInfo.length;\n    }\n\n    //create a new pool\n    function addPool(address _lptoken, address _gauge, uint256 _stashVersion) external returns(bool){\n        require(msg.sender==poolManager && !isShutdown, \"!add\");\n        require(_gauge != address(0) && _lptoken != address(0),\"!param\");\n\n        //the next pool's pid\n        uint256 pid = poolInfo.length;\n\n        //create a tokenized deposit\n        address token = ITokenFactory(tokenFactory).CreateDepositToken(_lptoken);\n        //create a reward contract for crv rewards\n        address newRewardPool = IRewardFactory(rewardFactory).CreateCrvRewards(pid,token);\n        //create a stash to handle extra incentives\n        address stash = IStashFactory(stashFactory).CreateStash(pid,_gauge,staker,_stashVersion);\n\n        //add the new pool\n        poolInfo.push(\n            PoolInfo({\n                lptoken: _lptoken,\n                token: token,\n                gauge: _gauge,\n                crvRewards: newRewardPool,\n                stash: stash,\n                shutdown: false\n            })\n        );\n        gaugeMap[_gauge] = true;\n        //give stashes access to rewardfactory and voteproxy\n        //   voteproxy so it can grab the incentive tokens off the contract after claiming rewards\n        //   reward factory so that stashes can make new extra reward contracts if a new incentive is added to the gauge\n        if(stash != address(0)){\n            poolInfo[pid].stash = stash;\n            IStaker(staker).setStashAccess(stash,true);\n            IRewardFactory(rewardFactory).setAccess(stash,true);\n        }\n        return true;\n    }\n\n    //shutdown pool\n    function shutdownPool(uint256 _pid) external returns(bool){\n        require(msg.sender==poolManager, \"!auth\");\n        PoolInfo storage pool = poolInfo[_pid];\n\n        //withdraw from gauge\n        try IStaker(staker).withdrawAll(pool.lptoken,pool.gauge){\n        }catch{}\n\n        pool.shutdown = true;\n        gaugeMap[pool.gauge] = false;\n        return true;\n    }\n\n    //shutdown this contract.\n    //  unstake and pull all lp tokens to this address\n    //  only allow withdrawals\n    function shutdownSystem() external{\n        require(msg.sender == owner, \"!auth\");\n        isShutdown = true;\n\n        for(uint i=0; i < poolInfo.length; i++){\n            PoolInfo storage pool = poolInfo[i];\n            if (pool.shutdown) continue;\n\n            address token = pool.lptoken;\n            address gauge = pool.gauge;\n\n            //withdraw from gauge\n            try IStaker(staker).withdrawAll(token,gauge){\n                pool.shutdown = true;\n            }catch{}\n        }\n    }\n\n\n    //deposit lp tokens and stake\n    function deposit(uint256 _pid, uint256 _amount, bool _stake) public returns(bool){\n        require(!isShutdown,\"shutdown\");\n        PoolInfo storage pool = poolInfo[_pid];\n        require(pool.shutdown == false, \"pool is closed\");\n\n        //send to proxy to stake\n        address lptoken = pool.lptoken;\n        IERC20(lptoken).safeTransferFrom(msg.sender, staker, _amount);\n\n        //stake\n        address gauge = pool.gauge;\n        require(gauge != address(0),\"!gauge setting\");\n        IStaker(staker).deposit(lptoken,gauge);\n\n        //some gauges claim rewards when depositing, stash them in a seperate contract until next claim\n        address stash = pool.stash;\n        if(stash != address(0)){\n            IStash(stash).stashRewards();\n        }\n\n        address token = pool.token;\n        if(_stake){\n            //mint here and send to rewards on user behalf\n            ITokenMinter(token).mint(address(this),_amount);\n            address rewardContract = pool.crvRewards;\n            IERC20(token).safeApprove(rewardContract,0);\n            IERC20(token).safeApprove(rewardContract,_amount);\n            IRewards(rewardContract).stakeFor(msg.sender,_amount);\n        }else{\n            //add user balance directly\n            ITokenMinter(token).mint(msg.sender,_amount);\n        }\n\n        \n        emit Deposited(msg.sender, _pid, _amount);\n        return true;\n    }\n\n    //deposit all lp tokens and stake\n    function depositAll(uint256 _pid, bool _stake) external returns(bool){\n        address lptoken = poolInfo[_pid].lptoken;\n        uint256 balance = IERC20(lptoken).balanceOf(msg.sender);\n        deposit(_pid,balance,_stake);\n        return true;\n    }\n\n    //withdraw lp tokens\n    function _withdraw(uint256 _pid, uint256 _amount, address _from, address _to) internal {\n        PoolInfo storage pool = poolInfo[_pid];\n        address lptoken = pool.lptoken;\n        address gauge = pool.gauge;\n\n        //remove lp balance\n        address token = pool.token;\n        ITokenMinter(token).burn(_from,_amount);\n\n        //pull from gauge if not shutdown\n        // if shutdown tokens will be in this contract\n        if (!pool.shutdown) {\n            IStaker(staker).withdraw(lptoken,gauge, _amount);\n        }\n\n        //some gauges claim rewards when withdrawing, stash them in a seperate contract until next claim\n        //do not call if shutdown since stashes wont have access\n        address stash = pool.stash;\n        if(stash != address(0) && !isShutdown && !pool.shutdown){\n            IStash(stash).stashRewards();\n        }\n        \n        //return lp tokens\n        IERC20(lptoken).safeTransfer(_to, _amount);\n\n        emit Withdrawn(_to, _pid, _amount);\n    }\n\n    //withdraw lp tokens\n    function withdraw(uint256 _pid, uint256 _amount) public returns(bool){\n        _withdraw(_pid,_amount,msg.sender,msg.sender);\n        return true;\n    }\n\n    //withdraw all lp tokens\n    function withdrawAll(uint256 _pid) public returns(bool){\n        address token = poolInfo[_pid].token;\n        uint256 userBal = IERC20(token).balanceOf(msg.sender);\n        withdraw(_pid, userBal);\n        return true;\n    }\n\n    //allow reward contracts to send here and withdraw to user\n    function withdrawTo(uint256 _pid, uint256 _amount, address _to) external returns(bool){\n        address rewardContract = poolInfo[_pid].crvRewards;\n        require(msg.sender == rewardContract,\"!auth\");\n\n        _withdraw(_pid,_amount,msg.sender,_to);\n        return true;\n    }\n\n\n    //delegate address votes on dao\n    function vote(uint256 _voteId, address _votingAddress, bool _support) external returns(bool){\n        require(msg.sender == voteDelegate, \"!auth\");\n        require(_votingAddress == voteOwnership || _votingAddress == voteParameter, \"!voteAddr\");\n        \n        IStaker(staker).vote(_voteId,_votingAddress,_support);\n        return true;\n    }\n\n    function voteGaugeWeight(address[] calldata _gauge, uint256[] calldata _weight ) external returns(bool){\n        require(msg.sender == voteDelegate, \"!auth\");\n\n        for(uint256 i = 0; i < _gauge.length; i++){\n            IStaker(staker).voteGaugeWeight(_gauge[i],_weight[i]);\n        }\n        return true;\n    }\n\n    function claimRewards(uint256 _pid, address _gauge) external returns(bool){\n        address stash = poolInfo[_pid].stash;\n        require(msg.sender == stash,\"!auth\");\n\n        IStaker(staker).claimRewards(_gauge);\n        return true;\n    }\n\n    function setGaugeRedirect(uint256 _pid) external returns(bool){\n        address stash = poolInfo[_pid].stash;\n        require(msg.sender == stash,\"!auth\");\n        address gauge = poolInfo[_pid].gauge;\n        bytes memory data = abi.encodeWithSelector(bytes4(keccak256(\"set_rewards_receiver(address)\")), stash);\n        IStaker(staker).execute(gauge,uint256(0),data);\n        return true;\n    }\n\n    //claim crv and extra rewards and disperse to reward contracts\n    function _earmarkRewards(uint256 _pid) internal {\n        PoolInfo storage pool = poolInfo[_pid];\n        require(pool.shutdown == false, \"pool is closed\");\n\n        address gauge = pool.gauge;\n\n        //claim crv\n        IStaker(staker).claimCrv(gauge);\n\n        //check if there are extra rewards\n        address stash = pool.stash;\n        if(stash != address(0)){\n            //claim extra rewards\n            IStash(stash).claimRewards();\n            //process extra rewards\n            IStash(stash).processStash();\n        }\n\n        //crv balance\n        uint256 crvBal = IERC20(crv).balanceOf(address(this));\n\n        if (crvBal > 0) {\n            uint256 _lockIncentive = crvBal.mul(lockIncentive).div(FEE_DENOMINATOR);\n            uint256 _stakerIncentive = crvBal.mul(stakerIncentive).div(FEE_DENOMINATOR);\n            uint256 _callIncentive = crvBal.mul(earmarkIncentive).div(FEE_DENOMINATOR);\n            \n            //send treasury\n            if(treasury != address(0) && treasury != address(this) && platformFee > 0){\n                //only subtract after address condition check\n                uint256 _platform = crvBal.mul(platformFee).div(FEE_DENOMINATOR);\n                crvBal = crvBal.sub(_platform);\n                IERC20(crv).safeTransfer(treasury, _platform);\n            }\n\n            //remove incentives from balance\n            crvBal = crvBal.sub(_lockIncentive).sub(_callIncentive).sub(_stakerIncentive);\n\n            //send incentives for calling\n            IERC20(crv).safeTransfer(msg.sender, _callIncentive);          \n\n            //send crv to lp provider reward contract\n            address rewardContract = pool.crvRewards;\n            IERC20(crv).safeTransfer(rewardContract, crvBal);\n            IRewards(rewardContract).queueNewRewards(crvBal);\n\n            //send lockers' share of crv to reward contract\n            IERC20(crv).safeTransfer(lockRewards, _lockIncentive);\n            IRewards(lockRewards).queueNewRewards(_lockIncentive);\n\n            //send stakers's share of crv to reward contract\n            IERC20(crv).safeTransfer(stakerRewards, _stakerIncentive);\n            IRewards(stakerRewards).queueNewRewards(_stakerIncentive);\n        }\n    }\n\n    function earmarkRewards(uint256 _pid) external returns(bool){\n        require(!isShutdown,\"shutdown\");\n        _earmarkRewards(_pid);\n        return true;\n    }\n\n    //claim fees from curve distro contract, put in lockers' reward contract\n    function earmarkFees() external returns(bool){\n        //claim fee rewards\n        IStaker(staker).claimFees(feeDistro, feeToken);\n        //send fee rewards to reward contract\n        uint256 _balance = IERC20(feeToken).balanceOf(address(this));\n        IERC20(feeToken).safeTransfer(lockFees, _balance);\n        IRewards(lockFees).queueNewRewards(_balance);\n        return true;\n    }\n\n    //callback from reward contract when crv is received.\n    function rewardClaimed(uint256 _pid, address _address, uint256 _amount) external returns(bool){\n        address rewardContract = poolInfo[_pid].crvRewards;\n        require(msg.sender == rewardContract || msg.sender == lockRewards, \"!auth\");\n\n        //mint reward tokens\n        ITokenMinter(minter).mint(_address,_amount);\n        \n        return true;\n    }\n\n}"
    }
  ]
}