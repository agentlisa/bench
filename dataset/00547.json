{
  "Title": "M-9: `swapUnderlyingForYt` revert due to rounding issues",
  "Content": "# Issue M-9: `swapUnderlyingForYt` revert due to rounding issues \n\nSource: https://github.com/sherlock-audit/2024-01-napier-judging/issues/101 \n\n## Found by \nxiaoming90\n## Summary\n\nThe core function (`swapUnderlyingForYt`) of the Router will revert due to rounding issues. Users who intend to swap underlying assets to YT tokens via the Router will be unable to do so.\n\n## Vulnerability Detail\n\nThe `swapUnderlyingForYt` allows users to swap underlying assets to a specific number of YT tokens they desire.\n\nhttps://github.com/sherlock-audit/2024-01-napier/blob/main/v1-pool/src/NapierRouter.sol#L353\n\n```solidity\nFile: NapierRouter.sol\n297:     function swapUnderlyingForYt(\n298:         address pool,\n299:         uint256 index,\n300:         uint256 ytOutDesired,\n301:         uint256 underlyingInMax,\n302:         address recipient,\n303:         uint256 deadline\n304:     ) external payable override nonReentrant checkDeadline(deadline) returns (uint256) {\n..SNIP..\n330:             // Variable Definitions:\n331:             // - `uDeposit`: The amount of underlying asset that needs to be deposited to issue PT and YT.\n332:             // - `ytOutDesired`: The desired amount of PT and YT to be issued.\n333:             // - `cscale`: Current scale of the Tranche.\n334:             // - `maxscale`: Maximum scale of the Tranche (denoted as 'S' in the formula).\n335:             // - `issuanceFee`: Issuance fee in basis points. (10000 =100%).\n336: \n337:             // Formula for `Tranche.issue`:\n338:             // ```\n339:             // shares = uDeposit / s\n340:             // fee = shares * issuanceFeeBps / 10000\n341:             // pyIssue = (shares - fee) * S\n342:             // ```\n343: \n344:             // Solving for `uDeposit`:\n345:             // ```\n346:             // uDeposit = (pyIssue * s / S) / (1 - issuanceFeeBps / 10000)\n347:             // ```\n348:             // Hack:\n349:             // Buffer is added to the denominator.\n350:             // This ensures that at least `ytOutDesired` amount of PT and YT are issued.\n351:             // If maximum scale and current scale are significantly different or `ytOutDesired` is small, the function might fail.\n352:             // Without this buffer, any rounding errors that reduce the issued PT and YT could lead to an insufficient amount of PT to be repaid to the pool.\n353:             uint256 uDepositNoFee = cscale * ytOutDesired / maxscale;\n354:             uDeposit = uDepositNoFee * MAX_BPS / (MAX_BPS - (series.issuanceFee + 1)); // 0.01 bps buffer\n```\n\nLine 353-354 above compute the number of underlying deposits needed to send to the Tranche to issue the amount of YT token the users desired. It attempts to add a buffer of 0.01 bps buffer to prevent rounding errors that could lead to insufficient PT being repaid to the pool and result in a revert. During the audit, it was found that this buffer is ineffective in achieving its purpose.\n\nThe following example/POC demonstrates a revert could still occur due to insufficient PT being repaid despite having a buffer:\n\nLet the state be the following:\n\n- cscale = 1.2e18\n- maxScale = 1.25e18\n- ytOutDesired = 123\n- issuanceFee = 0% (For simplicity's sake, the fee is set to zero. Having fee or not does not affect the validity of this issue as this is a math problem)\n\nThe following computes the number of underlying assets to be transferred to the Tranche to mint/issue PY + YT\n\n```solidity\nuDepositNoFee = cscale * ytOutDesired / maxscale;\nuDepositNoFee = 1.2e18 * 123 / 1.25e18 = 118.08 = 118 (Round down)\n\nuDeposit = uDepositNoFee * MAX_BPS / (MAX_BPS - (series.issuanceFee + 1))\nuDeposit = 118 * 10000 / (10000 - (0 + 1)) = 118.0118012 = 118 (Round down)\n```\n\nSubsequently, the code will perform a flash-swap via the `swapPtForUnderlying` function. It will borrow 123 PT from the pool, which must be repaid later.\n\nIn the swap callback function, the code will transfer 118 underlying assets to the Tranche and execute the `Tranche.issue` function to mint/issue PY + YT.\n\nWithin the `Tranche.issue` function, it will trigger the `adapter.prefundedDeposit()` function to mint the estETH/shares. The following is the number of estETH/shares minted:\n\n```solidity\nshares = assets * (total supply/total assets)\nsahres = 118 * 100e18 / 120e18 = 98.33333333 = 98 shares\n```\n\nNext, Line 219 below of the `Tranche.issue` function will compute the number of PY+YT to be issued/minted\n\n```solidity\nissued = (sharesUsed - fee).mulWadDown(_maxscale);\nissued = (sharesUsed - 0).mulWadDown(_maxscale);\nissued = sharesUsed.mulWadDown(_maxscale);\n\nissued = sharesUsed * _maxscale / WAD\nissued = 98 * 1.25e18 / 1e18 = 122.5 = 122 PT (Round down)\n```\n\nhttps://github.com/sherlock-audit/2024-01-napier/blob/main/napier-v1/src/Tranche.sol#L219\n\n```solidity\nFile: Tranche.sol\n179:     function issue(\n180:         address to,\n181:         uint256 underlyingAmount\n182:     ) external nonReentrant whenNotPaused notExpired returns (uint256 issued) {\n..SNIP..\n217:         uint256 sharesUsed = sharesMinted + accruedInTarget;\n218:         uint256 fee = sharesUsed.mulDivUp(issuanceFeeBps, MAX_BPS);\n219:         issued = (sharesUsed - fee).mulWadDown(_maxscale);\n```\n\nAt the end of the `Tranche.issue` function, 122 PY + YT is issued/minted back to the Router.\n\nNote that 123 PT was flash-loaned earlier, and 123 PT needs to be repaid. Otherwise, the code at Line 164 below will revert. The main problem is that only 122 PY was issued/minted (a shortfall of 1 PY). Thus, the swap TX will revert at the end.\n\nhttps://github.com/sherlock-audit/2024-01-napier/blob/main/v1-pool/src/NapierRouter.sol#L164\n\n```solidity\nFile: NapierRouter.sol\n085:     function swapCallback(int256 underlyingDelta, int256 ptDelta, bytes calldata data) external override {\n..SNIP..\n161:             uint256 pyIssued = params.pt.issue({to: address(this), underlyingAmount: params.underlyingDeposit});\n162: \n163:             // Repay the PT to Napier pool\n164:             if (pyIssued < pyDesired) revert Errors.RouterInsufficientPtRepay();\n```\n\n## Impact\n\nThe core function (swapUnderlyingForYt) of the Router will break. Users who intend to swap underlying assets to YT tokens via the Router will not be able to do so.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-01-napier/blob/main/v1-pool/src/NapierRouter.sol#L353\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe buffer does not appear to be the correct approach to manage this rounding error. One could increase the buffer from 0.01% to 1% and solve the issue in the above example, but a different or larger number might cause a rounding error to surface again. Also, a larger buffer means that many unnecessary PTs will be issued. \n\nThus, it is recommended that a round-up division be performed when computing the `uDepositNoFee` and `uDeposit` using functions such as `divWadUp` so that the issued/minted PT can cover the debt.\n\n\n\n## Discussion\n\n**sherlock-admin**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  valid: rounding error: medium(7)\n\n\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/napierfi/v1-pool/pull/158.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/171",
  "Code": [
    {
      "filename": "v1-pool/src/NapierRouter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.10;\n\n// external interfaces\nimport {IERC20} from \"@openzeppelin/contracts@4.9.3/token/ERC20/IERC20.sol\";\nimport {IWETH9} from \"./interfaces/external/IWETH9.sol\";\nimport {CurveTricryptoOptimizedWETH} from \"./interfaces/external/CurveTricryptoOptimizedWETH.sol\";\nimport {ITranche} from \"@napier/napier-v1/src/interfaces/ITranche.sol\";\nimport {IBaseAdapter} from \"@napier/napier-v1/src/interfaces/IBaseAdapter.sol\";\nimport {INapierPool} from \"./interfaces/INapierPool.sol\";\nimport {IPoolFactory} from \"./interfaces/IPoolFactory.sol\";\n// implements\nimport {INapierRouter} from \"./interfaces/INapierRouter.sol\";\nimport {INapierMintCallback} from \"./interfaces/INapierMintCallback.sol\";\nimport {INapierSwapCallback} from \"./interfaces/INapierSwapCallback.sol\";\n\n// libraries\nimport {SafeERC20} from \"@openzeppelin/contracts@4.9.3/token/ERC20/utils/SafeERC20.sol\";\nimport {CallbackDataTypes, CallbackType} from \"./libs/CallbackDataTypes.sol\";\nimport {PoolAddress} from \"./libs/PoolAddress.sol\";\nimport {MAX_BPS} from \"@napier/napier-v1/src/Constants.sol\";\nimport {Errors} from \"./libs/Errors.sol\";\n\n// inherits\nimport {PeripheryImmutableState} from \"./base/PeripheryImmutableState.sol\";\nimport {PeripheryPayments} from \"./base/PeripheryPayments.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts@4.9.3/security/ReentrancyGuard.sol\";\nimport {Multicallable} from \"./base/Multicallable.sol\";\n\n/// @notice Router for Napier pools\n/// @dev This contract provides a single entry point for Napier pools. Accepts native ETH.\n/// @dev Multicallable is used to batch multiple operations. E.g. Swap Principal Tokens for WETH and unwrap WETH to ETH with a single transaction.\n/// See each function for more details.\ncontract NapierRouter is\n    INapierRouter,\n    INapierSwapCallback,\n    INapierMintCallback,\n    PeripheryPayments,\n    ReentrancyGuard,\n    Multicallable\n{\n    using SafeERC20 for IERC20;\n    using SafeERC20 for ITranche;\n\n    /// @notice Napier Pool Factory\n    /// @dev pool passed as functions parameter must be deployed by this factory\n    IPoolFactory public immutable factory;\n\n    bytes32 internal immutable POOL_CREATION_HASH;\n\n    /// @notice If the transaction is too old, revert.\n    /// @param deadline Transaction deadline in unix timestamp\n    modifier checkDeadline(uint256 deadline) {\n        if (block.timestamp > deadline) revert Errors.RouterTransactionTooOld();\n        _;\n    }\n\n    constructor(IPoolFactory _factory, IWETH9 _WETH9) PeripheryImmutableState(_WETH9) {\n        factory = _factory;\n        POOL_CREATION_HASH = _factory.POOL_CREATION_HASH();\n    }\n\n    /// @dev Revert if `msg.sender` is not a Napier pool.\n    function _verifyCallback(address basePool, address underlying) internal view {\n        if (\n            PoolAddress.computeAddress(basePool, underlying, POOL_CREATION_HASH, address(factory))\n                != INapierPool(msg.sender)\n        ) revert Errors.RouterCallbackNotNapierPool();\n    }\n\n    function mintCallback(uint256 underlyingDelta, uint256 baseLptDelta, bytes calldata data) external override {\n        // `data` is encoded as follows:\n        // [0x00: 0x20] CallbackType (uint8)\n        // [0x20:  ~  ] Custom data (based on CallbackType)\n        CallbackDataTypes.AddLiquidityData memory params = abi.decode(data[0x20:], (CallbackDataTypes.AddLiquidityData));\n        _verifyCallback(params.basePool, params.underlying);\n\n        // In all addLiquidity functions of router, underlying tokens are saved in payer and baseLpTokens are saved in router.\n        // So in this callback function, we don't need to get CallbackTypes.\n        // If this contract holds enough ETH, wrap it. Otherwise, transfer from the caller.\n        _pay(params.underlying, params.payer, msg.sender, underlyingDelta);\n        IERC20(params.basePool).safeTransfer(msg.sender, baseLptDelta);\n    }\n\n    function swapCallback(int256 underlyingDelta, int256 ptDelta, bytes calldata data) external override {\n        // `data` is encoded as follows:\n        // [0x00: 0x20] CallbackType (uint8)\n        // [0x20: 0x40] Underlying (address)\n        // [0x40: 0x60] BasePool (address)\n        // [0x60:  ~  ] Custom data (based on CallbackType)\n        (address underlying, address basePool) = abi.decode(data[0x20:0x60], (address, address));\n        _verifyCallback(basePool, underlying);\n\n        CallbackType _type = CallbackDataTypes.getCallbackType(data);\n\n        if (_type == CallbackType.SwapPtForUnderlying) {\n            CallbackDataTypes.SwapPtForUnderlyingData memory params =\n                abi.decode(data[0x60:], (CallbackDataTypes.SwapPtForUnderlyingData));\n            params.pt.safeTransferFrom(params.payer, msg.sender, uint256(-ptDelta));\n        } else if (_type == CallbackType.SwapUnderlyingForPt) {\n            // Decode callback data\n            CallbackDataTypes.SwapUnderlyingForPtData memory params =\n                abi.decode(data[0x60:], (CallbackDataTypes.SwapUnderlyingForPtData));\n\n            // Check slippage. Revert if exceeded max underlying in\n            if (uint256(-underlyingDelta) > params.underlyingInMax) revert Errors.RouterExceededLimitUnderlyingIn();\n            _pay(underlying, params.payer, msg.sender, uint256(-underlyingDelta));\n        } else if (_type == CallbackType.SwapYtForUnderlying) {\n            // Decode callback data\n            CallbackDataTypes.SwapYtForUnderlyingData memory params =\n                abi.decode(data[0x60:], (CallbackDataTypes.SwapYtForUnderlyingData));\n\n            uint256 uRepay = uint256(-underlyingDelta); // unsafe cast is okay because always negative in this branch\n            uint256 pyRedeem; // amount of PT (YT) to be redeemed\n            // Assign the minimum amount of (ytIn, ptDelta) to `pyRedeem`\n            if (params.ytIn >= uint256(ptDelta)) {\n                // If the actual amount of PT received is less than the requested amount, use the actual amount\n                pyRedeem = uint256(ptDelta);\n            } else {\n                pyRedeem = params.ytIn;\n                // Surplus of `ptDelta` - `params.ytIn` should be refunded to the payer\n                // no underflow because of the if statement above\n                IERC20(params.pt).safeTransfer(params.payer, uint256(ptDelta) - params.ytIn); // non-zero\n            }\n\n            // Transfer YT from caller to this contract\n            IERC20(params.pt.yieldToken()).safeTransferFrom(params.payer, address(this), pyRedeem);\n\n            // Optimistically redeem any amount of PT and YT for underlying\n            // Later, we will check if the amount of underlying redeemed is enough to cover the underlying to be repaid\n            uint256 uRedeemed = params.pt.redeemWithYT({\n                pyAmount: pyRedeem,\n                to: address(this),\n                from: address(this) // At this point, the YT is already in this contract\n            });\n            if (uRedeemed < uRepay) revert Errors.RouterInsufficientUnderlyingRepay();\n            // Check slippage\n            uint256 underlyingToRecipient = uRedeemed - uRepay; // no underflow because of the if statement above\n            if (underlyingToRecipient < params.underlyingOutMin) revert Errors.RouterInsufficientUnderlyingOut();\n\n            // Repay underlying to Napier pool and transfer the rest to recipient\n            IERC20(underlying).safeTransfer(msg.sender, uRepay);\n            IERC20(underlying).safeTransfer(params.recipient, underlyingToRecipient);\n        } else if (_type == CallbackType.SwapUnderlyingForYt) {\n            // Decode callback data\n            CallbackDataTypes.SwapUnderlyingForYtData memory params =\n                abi.decode(data[0x60:], (CallbackDataTypes.SwapUnderlyingForYtData));\n\n            uint256 uReceived = uint256(underlyingDelta); // unsafe cast is okay because always positive in this branch.\n            uint256 pyDesired = uint256(-ptDelta); // principal token to be repaid and yield token to be issued\n\n            // Pull underlying from payer.\n            // Economically, it's almost unlikely that the payer doesn't need to pay underlying asset.\n            // But if the above case happens, it would be reverted.\n            if (params.underlyingDeposit <= uReceived) revert Errors.RouterNonSituationSwapUnderlyingForYt();\n            uint256 uPull = params.underlyingDeposit - uReceived;\n            if (uPull > params.maxUnderlyingPull) revert Errors.RouterExceededLimitUnderlyingIn();\n            _pay(underlying, params.payer, address(this), uPull);\n\n            IERC20(underlying).forceApprove(address(params.pt), params.underlyingDeposit);\n            uint256 pyIssued = params.pt.issue({to: address(this), underlyingAmount: params.underlyingDeposit});\n\n            // Repay the PT to Napier pool\n            if (pyIssued < pyDesired) revert Errors.RouterInsufficientPtRepay();\n            params.pt.safeTransfer(msg.sender, pyDesired);\n            // Transfer the remaining PT to payer\n            params.pt.safeTransfer(params.payer, pyIssued - pyDesired);\n            // Transfer the YT to recipient\n            params.yt.safeTransfer(params.recipient, pyIssued);\n        }\n    }\n\n    /// @inheritdoc INapierRouter\n    /// @notice Swap exact amount of Principal Token (PT) for Underlying.\n    /// @notice Caller must approve the router to spend PTs prior to calling this method.\n    /// @notice Revert if the pool is not deployed by the factory set in the constructor.\n    /// @notice Revert if maturity has passed for the pool.\n    /// @notice Revert if deadline has passed.\n    /// @notice Revert if the amount of underlying asset received is less than the minimum amount specified.\n    /// @param pool The address of the pool.\n    /// @param index The index of the PT. (0, 1, 2)\n    /// @param ptInDesired The amount of PT to swap.\n    /// @param underlyingOutMin The minimum amount of underlying asset to receive.\n    /// @param recipient The recipient of the swapped underlying asset.\n    /// @param deadline The deadline for the swap.\n    /// @return The amount of underlying asset received.\n    function swapPtForUnderlying(\n        address pool,\n        uint256 index,\n        uint256 ptInDesired,\n        uint256 underlyingOutMin,\n        address recipient,\n        uint256 deadline\n    ) external override nonReentrant checkDeadline(deadline) returns (uint256) {\n        // dev: Optimistically call to the `pool` provided by the untrusted caller.\n        // And then verify the pool using CREATE2.\n        (address underlying, address basePool) = INapierPool(pool).getAssets();\n\n        // if `pool` doesn't matched, it would be reverted.\n        if (INapierPool(pool) != PoolAddress.computeAddress(basePool, underlying, POOL_CREATION_HASH, address(factory)))\n        {\n            revert Errors.RouterPoolNotFound();\n        }\n\n        address pt = address(INapierPool(pool).principalTokens()[index]);\n\n        // Abi encode callback data to be used in swapCallback\n        bytes memory data = new bytes(0xa0);\n\n        uint256 callbackType = uint256(CallbackType.SwapPtForUnderlying);\n        assembly {\n            // Equivanlent to:\n            // data = abi.encode(CallbackType.SwapUnderlyingForPt, underlying, basePool, CallbackDataTypes.SwapUnderlyingForPtData({payer: msg.sender, underlyingInMax: underlyingInMax}))\n            mstore(add(data, 0x20), callbackType)\n            mstore(add(data, 0x40), underlying)\n            mstore(add(data, 0x60), basePool)\n            mstore(add(data, 0x80), caller()) // dev: Ensure 'payer' is always 'msg.sender' to prevent allowance theft on callback.\n            mstore(add(data, 0xa0), pt)\n        }\n        uint256 underlyingOut = INapierPool(pool).swapPtForUnderlying(index, ptInDesired, recipient, data);\n        if (underlyingOut < underlyingOutMin) revert Errors.RouterInsufficientUnderlyingOut();\n\n        return underlyingOut;\n    }\n\n    /// @inheritdoc INapierRouter\n    /// @notice Swap underlying for PT.\n    /// @notice Caller must approve the router to spend underlying asset prior to calling this method.\n    /// @dev If caller calls with ether, the ether will be wrapped to WETH9.\n    /// Note: the remaining ether is NOT returned automatically. Caller must call refundETH to get the remaining ether back.\n    /// @dev Revert conditions are the same as swapPtForUnderlying.\n    /// @param pool The address of the pool.\n    /// @param index The index of the PT.\n    /// @param ptOutDesired The amount of PT to receive.\n    /// @param underlyingInMax The maximum amount of underlying asset to spend.\n    /// @param recipient The recipient of the PT.\n    /// @param deadline The deadline for the swap.\n    /// @return The amount of underlying asset spent.\n    function swapUnderlyingForPt(\n        address pool,\n        uint256 index,\n        uint256 ptOutDesired,\n        uint256 underlyingInMax,\n        address recipient,\n        uint256 deadline\n    ) external payable override nonReentrant checkDeadline(deadline) returns (uint256) {\n        // dev: Optimistically call to the `pool` provided by the untrusted caller.\n        // And then verify the pool using CREATE2.\n        (address underlying, address basePool) = INapierPool(pool).getAssets();\n\n        // if `pool` doesn't matched, it would be reverted.\n        if (INapierPool(pool) != PoolAddress.computeAddress(basePool, underlying, POOL_CREATION_HASH, address(factory)))\n        {\n            revert Errors.RouterPoolNotFound();\n        }\n\n        IERC20 pt = INapierPool(pool).principalTokens()[index];\n\n        // Abi encode callback data to be used in swapCallback\n        bytes memory data = new bytes(0xa0);\n        {\n            uint256 callbackType = uint256(CallbackType.SwapUnderlyingForPt);\n            assembly {\n                // Equivanlent to:\n                // data = abi.encode(CallbackType.SwapUnderlyingForPt, underlying, basePool, CallbackDataTypes.SwapUnderlyingForPtData({payer: msg.sender, underlyingInMax: underlyingInMax}))\n                mstore(add(data, 0x20), callbackType)\n                mstore(add(data, 0x40), underlying)\n                mstore(add(data, 0x60), basePool)\n                mstore(add(data, 0x80), caller()) // dev: Ensure 'payer' is always 'msg.sender' to prevent allowance theft on callback.\n                mstore(add(data, 0xa0), underlyingInMax)\n            }\n        }\n\n        uint256 prevBalance = pt.balanceOf(address(this));\n        uint256 underlyingUsed = INapierPool(pool).swapUnderlyingForPt(\n            index,\n            ptOutDesired,\n            address(this), // this contract will receive principal token from pool\n            data\n        );\n\n        pt.safeTransfer(recipient, pt.balanceOf(address(this)) - prevBalance);\n        return underlyingUsed;\n    }\n\n    /// @inheritdoc INapierRouter\n    /// @notice Swap underlying asset for YT.\n    /// @dev Under the hood, Router receives underlying asset from `pool` with flash swap and issues PT and YT.\n    /// After that, pay back the PT to `pool` and transfer the issued YT to `recipient`.\n    /// @param pool The address of the pool.\n    /// @param index The index of principal token / yield token.\n    /// @param ytOutDesired The amount of YT to receive. (at least `ytOutDesired` amount of PT and YT should be issued)\n    /// @param underlyingInMax The maximum amount of underlying asset to spend.\n    /// @param recipient The recipient of the YT.\n    /// @param deadline The deadline for the swap.\n    /// @return The amount of underlying asset recipient spent.\n    function swapUnderlyingForYt(\n        address pool,\n        uint256 index,\n        uint256 ytOutDesired,\n        uint256 underlyingInMax,\n        address recipient,\n        uint256 deadline\n    ) external payable override nonReentrant checkDeadline(deadline) returns (uint256) {\n        // dev: Optimistically call to the `pool` provided by the untrusted caller.\n        // And then verify the pool using CREATE2.\n        (address underlying, address basePool) = INapierPool(pool).getAssets();\n\n        // if `pool` doesn't matched, it would be reverted.\n        if (INapierPool(pool) != PoolAddress.computeAddress(basePool, underlying, POOL_CREATION_HASH, address(factory)))\n        {\n            revert Errors.RouterPoolNotFound();\n        }\n\n        ITranche pt = ITranche(address(INapierPool(pool).principalTokens()[index]));\n\n        uint256 uDeposit; // underlying asset to be deposited to Tranche\n        {\n            // This section of code aims to calculate the amount of underlying asset (`uDeposit`) required to issue a specific amount of PT and YT (`ytOutDesired`).\n            // The calculations are based on the formula used in the `Tranche.issue` function.\n\n            ITranche.Series memory series = pt.getSeries();\n\n            // Update maxscale if current scale is greater than maxscale\n            uint256 maxscale = series.maxscale;\n            uint256 cscale = IBaseAdapter(series.adapter).scale();\n            if (cscale > maxscale) {\n                maxscale = cscale;\n            }\n            // Variable Definitions:\n            // - `uDeposit`: The amount of underlying asset that needs to be deposited to issue PT and YT.\n            // - `ytOutDesired`: The desired amount of PT and YT to be issued.\n            // - `cscale`: Current scale of the Tranche.\n            // - `maxscale`: Maximum scale of the Tranche (denoted as 'S' in the formula).\n            // - `issuanceFee`: Issuance fee in basis points. (10000 =100%).\n\n            // Formula for `Tranche.issue`:\n            // ```\n            // shares = uDeposit / s\n            // fee = shares * issuanceFeeBps / 10000\n            // pyIssue = (shares - fee) * S\n            // ```\n\n            // Solving for `uDeposit`:\n            // ```\n            // uDeposit = (pyIssue * s / S) / (1 - issuanceFeeBps / 10000)\n            // ```\n            // Hack:\n            // Buffer is added to the denominator.\n            // This ensures that at least `ytOutDesired` amount of PT and YT are issued.\n            // If maximum scale and current scale are significantly different or `ytOutDesired` is small, the function might fail.\n            // Without this buffer, any rounding errors that reduce the issued PT and YT could lead to an insufficient amount of PT to be repaid to the pool.\n            uint256 uDepositNoFee = cscale * ytOutDesired / maxscale;\n            uDeposit = uDepositNoFee * MAX_BPS / (MAX_BPS - (series.issuanceFee + 1)); // 0.01 bps buffer\n        }\n\n        // Abi encode callback data to be used in swapCallback\n        bytes memory data = new bytes(0x120);\n        {\n            uint256 callbackType = uint256(CallbackType.SwapUnderlyingForYt);\n            address yt = pt.yieldToken();\n            assembly {\n                // Equivanlent to:\n                // abi.encode(CallbackType.SwapUnderlyingForYt, underlying, basePool, CallbackDataTypes.SwapUnderlyingForYtData({pt: pt, yt: yt, payer: msg.sender, recipient: recipient, underlyingDeposit: uDeposit, maxUnderlyingPull: underlyingInMax}))\n                mstore(add(data, 0x20), callbackType)\n                mstore(add(data, 0x40), underlying)\n                mstore(add(data, 0x60), basePool)\n                mstore(add(data, 0x80), caller()) // dev: Ensure 'payer' is always 'msg.sender' to prevent allowance theft on callback.\n                mstore(add(data, 0xa0), pt)\n                mstore(add(data, 0xc0), yt)\n                mstore(add(data, 0xe0), recipient)\n                mstore(add(data, 0x100), uDeposit)\n                mstore(add(data, 0x120), underlyingInMax)\n            }\n        }\n        uint256 received = INapierPool(pool).swapPtForUnderlying(\n            index,\n            ytOutDesired, // ptInDesired\n            address(this), // this contract will receive underlying token from pool\n            data\n        );\n\n        // Underlying pulled = underlying deposited - underlying received from swap\n        return uDeposit - received;\n    }\n\n    /// @inheritdoc INapierRouter\n    /// @notice Swap YT for underlying asset.\n    /// @dev Under the hood, Router receives principal token from `pool` with flash swap and redeem it with YT for underlying asset.\n    /// After that, pay back the underlying asset to `pool` and transfer the remaining underlying asset to `recipient`.\n    /// @param pool The address of the pool.\n    /// @param index The index of the YT.\n    /// @param ytIn The amount of YT to swap.\n    /// @param underlyingOutMin The minimum amount of underlying asset to receive.\n    /// @param recipient The recipient of the underlying asset.\n    /// @param deadline The deadline for the swap.\n    /// @return The amount of underlying asset recipient received.\n    function swapYtForUnderlying(\n        address pool,\n        uint256 index,\n        uint256 ytIn,\n        uint256 underlyingOutMin,\n        address recipient,\n        uint256 deadline\n    ) external override nonReentrant checkDeadline(deadline) returns (uint256) {\n        // dev: Optimistically call to the `pool` provided by the untrusted caller.\n        // And then verify the pool using CREATE2.\n        (address underlying, address basePool) = INapierPool(pool).getAssets();\n\n        // if `pool` doesn't matched, it would be reverted.\n        if (INapierPool(pool) != PoolAddress.computeAddress(basePool, underlying, POOL_CREATION_HASH, address(factory)))\n        {\n            revert Errors.RouterPoolNotFound();\n        }\n\n        ITranche pt = ITranche(address(INapierPool(pool).principalTokens()[index]));\n\n        uint256 prevBalance = IERC20(underlying).balanceOf(recipient);\n\n        // Abi encode callback data to be used in swapCallback\n        bytes memory data = new bytes(0x100);\n        uint256 callbackType = uint256(CallbackType.SwapYtForUnderlying);\n        assembly {\n            // Equivanlent to:\n            // data = abi.encode(CallbackType.SwapYtForUnderlying, underlying, basePool, CallbackDataTypes.SwapYtForUnderlyingData({pt: pt, payer: msg.sender, ytIn: ytIn, recipient: recipient, underlyingOutMin: underlyingOutMin}))\n            mstore(add(data, 0x20), callbackType)\n            mstore(add(data, 0x40), underlying)\n            mstore(add(data, 0x60), basePool)\n            mstore(add(data, 0x80), caller()) // dev: Ensure 'payer' is always 'msg.sender' to prevent allowance theft on callback.\n            mstore(add(data, 0xa0), pt)\n            mstore(add(data, 0xc0), ytIn)\n            mstore(add(data, 0xe0), recipient)\n            mstore(add(data, 0x100), underlyingOutMin)\n        }\n        // Note: swap for PT approximate equal to `ytIn`\n        INapierPool(pool).swapUnderlyingForPt(\n            index,\n            ytIn, // ptOutDesired\n            address(this), // this contract will receive principal token from pool\n            data\n        );\n\n        // Underlying received = balance after swap - balance before swap\n        return IERC20(underlying).balanceOf(recipient) - prevBalance;\n    }\n\n    /// @inheritdoc INapierRouter\n    /// @notice Caller must approve the router to spend underlying asset and PTs prior to calling this method.\n    /// @notice Revert if the pool is not deployed by the factory set in the constructor\n    /// @notice Revert if maturity has passed for the pool\n    /// @notice Revert if deadline has passed\n    /// @notice Revert if the amount of liquidity tokens received is less than the minimum amount specified\n    /// @notice It will refund the remaining tokens (Native ETH or Base LP token) to the caller if any.\n    /// @param pool The address of the pool.\n    /// @param underlyingIn The amount of underlying asset to deposit.\n    /// @param ptsIn The amounts of PTs to deposit. Can be zero but at least one must be non-zero. Otherwise, revert in the Curve pool.\n    /// @param liquidityMin The minimum amount of liquidity tokens to receive.\n    /// @param recipient The recipient of the liquidity tokens.\n    /// @param deadline The deadline for adding liquidity.\n    /// @return The amount of liquidity tokens received.\n    function addLiquidity(\n        address pool,\n        uint256 underlyingIn,\n        uint256[3] calldata ptsIn,\n        uint256 liquidityMin,\n        address recipient,\n        uint256 deadline\n    ) external payable override nonReentrant checkDeadline(deadline) returns (uint256) {\n        // dev: Optimistically call to the `pool` provided by the untrusted caller.\n        // And then verify the pool using CREATE2.\n        (address underlying, address basePool) = INapierPool(pool).getAssets();\n\n        // if `pool` doesn't matched, it would be reverted.\n        if (INapierPool(pool) != PoolAddress.computeAddress(basePool, underlying, POOL_CREATION_HASH, address(factory)))\n        {\n            revert Errors.RouterPoolNotFound();\n        }\n\n        IERC20[3] memory pts = INapierPool(pool).principalTokens();\n\n        // Loop unrolling for gas optimization\n        pts[0].safeTransferFrom(msg.sender, address(this), ptsIn[0]);\n        pts[1].safeTransferFrom(msg.sender, address(this), ptsIn[1]);\n        pts[2].safeTransferFrom(msg.sender, address(this), ptsIn[2]);\n        // approve max to Tricrypto pool\n        if (pts[0].allowance(address(this), basePool) < ptsIn[0]) pts[0].approve(basePool, type(uint256).max); // dev: Principal token will revert if failed to approve\n        if (pts[1].allowance(address(this), basePool) < ptsIn[1]) pts[1].approve(basePool, type(uint256).max);\n        if (pts[2].allowance(address(this), basePool) < ptsIn[2]) pts[2].approve(basePool, type(uint256).max);\n\n        uint256 baseLptIn = CurveTricryptoOptimizedWETH(basePool).add_liquidity(ptsIn, 0);\n        // Add liquidity to Napier pool\n        uint256 liquidity = INapierPool(pool).addLiquidity(\n            underlyingIn,\n            baseLptIn,\n            recipient,\n            abi.encode(\n                CallbackType.AddLiquidityPts,\n                CallbackDataTypes.AddLiquidityData({payer: msg.sender, underlying: underlying, basePool: basePool})\n            )\n        );\n        if (liquidity < liquidityMin) revert Errors.RouterInsufficientLpOut();\n\n        // Sweep remaining tokens if any.\n        uint256 bBalance = IERC20(basePool).balanceOf(address(this));\n        if (bBalance > 0) IERC20(basePool).safeTransfer(msg.sender, bBalance);\n        // If WETH or ERC20 tokens are used, the exact amount is pulled from the caller. So, no need to sweep.\n        // If caller sent native ETH, make sure to send remaining ETH back to caller.\n        if (address(this).balance > 0) _safeTransferETH(msg.sender, address(this).balance);\n\n        return liquidity;\n    }\n\n    /// @inheritdoc INapierRouter\n    /// @notice Add liquidity to Napier pool from one principal token proportionally as possible as it can.\n    /// @notice Deadline should be tightly set.\n    /// @notice Caller must approve the router to spend PT prior to calling this method.\n    /// @dev Caller must specify the amount of base LP token to be swapped for underlying asset using off-chain calculation.\n    /// @dev Remaining base LP token and underlying asset are swept to the caller if any.\n    /// @param pool The address of the pool.\n    /// @param index The index of the PT.\n    /// @param amountIn The amount of PT to deposit.\n    /// @param liquidityMin The minimum amount of liquidity tokens to receive.\n    /// @param recipient The recipient of the liquidity tokens.\n    /// @param deadline The deadline for adding liquidity.\n    /// @param baseLpTokenSwap The estimated baseLpt amount to swap with underlying tokens.\n    /// @return The amount of liquidity tokens received.\n    function addLiquidityOnePt(\n        address pool,\n        uint256 index,\n        uint256 amountIn,\n        uint256 liquidityMin,\n        address recipient,\n        uint256 deadline,\n        uint256 baseLpTokenSwap\n    ) external override nonReentrant checkDeadline(deadline) returns (uint256) {\n        // dev: Optimistically call to the `pool` provided by the untrusted caller.\n        // And then verify the pool using CREATE2.\n        (address underlying, address basePool) = INapierPool(pool).getAssets();\n\n        // if `pool` doesn't matched, it would be reverted.\n        if (INapierPool(pool) != PoolAddress.computeAddress(basePool, underlying, POOL_CREATION_HASH, address(factory)))\n        {\n            revert Errors.RouterPoolNotFound();\n        }\n\n        IERC20[3] memory pts = INapierPool(pool).principalTokens();\n        pts[index].safeTransferFrom(msg.sender, address(this), amountIn);\n        if (pts[index].allowance(address(this), basePool) < amountIn) pts[index].approve(basePool, type(uint256).max);\n\n        uint256[3] memory ptsIn;\n        ptsIn[index] = amountIn;\n        uint256 baseLptIn = CurveTricryptoOptimizedWETH(basePool).add_liquidity(ptsIn, 0);\n        IERC20(basePool).forceApprove(address(pool), baseLptIn);\n\n        // Swap some base LP token for underlying\n        uint256 underlyingIn = INapierPool(pool).swapExactBaseLpTokenForUnderlying(baseLpTokenSwap, address(this));\n\n        // Add liquidity to Napier pool\n        uint256 liquidity = INapierPool(pool).addLiquidity(\n            underlyingIn,\n            baseLptIn - baseLpTokenSwap,\n            recipient,\n            abi.encode(\n                CallbackType.AddLiquidityOnePt,\n                CallbackDataTypes.AddLiquidityData({\n                    payer: address(this), // Router has already had both tokens at this point\n                    underlying: underlying,\n                    basePool: basePool\n                })\n            )\n        );\n        if (liquidity < liquidityMin) revert Errors.RouterInsufficientLpOut();\n\n        // Sweep remaining tokens if any.\n        uint256 bBalance = IERC20(basePool).balanceOf(address(this));\n        if (bBalance > 0) IERC20(basePool).safeTransfer(msg.sender, bBalance);\n        uint256 uBalance = IERC20(underlying).balanceOf(address(this));\n        if (uBalance > 0) IERC20(underlying).safeTransfer(msg.sender, uBalance);\n\n        return liquidity;\n    }\n\n    /// @inheritdoc INapierRouter\n    /// @notice Add liquidity to NapierPool with one underlying asset.\n    /// @notice Deadline should be tightly set.\n    /// @notice Caller must approve the router to spend underlying asset prior to calling this method.\n    /// @dev Under the hood, router swap some underlying asset for Base pool LP token.\n    /// @dev Caller must specify the amount of base LP token to be swapped for underlying asset using off-chain calculation.\n    /// @dev Remaining base LP token and underlying asset are swept to the caller if any.\n    /// @param pool The address of the pool.\n    /// @param underlyingIn The amount of underlying asset to deposit.\n    /// @param liquidityMin The minimum amount of liquidity tokens to receive.\n    /// @param recipient The recipient of the liquidity tokens.\n    /// @param deadline The deadline for adding liquidity.\n    /// @param baseLpTokenSwap The estimated baseLpTokenSwap amount to swap with underlying tokens.\n    /// @return The amount of liquidity tokens received.\n    function addLiquidityOneUnderlying(\n        address pool,\n        uint256 underlyingIn,\n        uint256 liquidityMin,\n        address recipient,\n        uint256 deadline,\n        uint256 baseLpTokenSwap\n    ) external override nonReentrant checkDeadline(deadline) returns (uint256) {\n        // dev: Optimistically call to the `pool` provided by the untrusted caller.\n        // And then verify the pool using CREATE2.\n        (address underlying, address basePool) = INapierPool(pool).getAssets();\n\n        // if `pool` doesn't matched, it would be reverted.\n        if (INapierPool(pool) != PoolAddress.computeAddress(basePool, underlying, POOL_CREATION_HASH, address(factory)))\n        {\n            revert Errors.RouterPoolNotFound();\n        }\n\n        IERC20(underlying).safeTransferFrom(msg.sender, address(this), underlyingIn);\n\n        // Swap some underlying for baseLpt\n        // At this point, Router doesn't know how much underlying is needed to get `baseLpTokenSwap` amount of base LP token.\n        // So, Router just approve pool to spend all underlying asset and let pool to spend as much as it needs.\n        // approve max\n        if (IERC20(underlying).allowance(address(this), pool) < underlyingIn) {\n            IERC20(underlying).forceApprove(pool, type(uint256).max);\n        }\n        uint256 uSpent = INapierPool(pool).swapUnderlyingForExactBaseLpToken(baseLpTokenSwap, address(this));\n\n        // Add liquidity to Napier pool\n        uint256 liquidity = INapierPool(pool).addLiquidity(\n            underlyingIn - uSpent, // remaining underlying asset\n            baseLpTokenSwap, // base LP token from swap\n            recipient,\n            abi.encode("
    }
  ]
}