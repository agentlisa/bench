{
  "Title": "The function returns a public variable",
  "Content": "##### Description\nFor the https://github.com/sushiswap/bentobox/blob/c2e150b16b8764ebfe2e1e6e267ae14e10738065/contracts/LendingPair.sol#L243 line, the `updateExchangeRate()` function returns a value.\nLines https://github.com/sushiswap/bentobox/blob/c2e150b16b8764ebfe2e1e6e267ae14e10738065/contracts/LendingPair.sol#L155 and https://github.com/sushiswap/bentobox/blob/c2e150b16b8764ebfe2e1e6e267ae14e10738065/contracts/LendingPair.sol#L457 call this function.\nBut the return value is not processed.\nThe `updateExchangeRate()` function changes the `exchangeRate` public variable. There is no need to return a public variable.\n\n##### Recommendation\nChange the logic of the `updateExchangeRate()` function so that it did not return a public variable.\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/LendingPair.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\n// Medium Risk LendingPair\r\n\r\n// ▄▄▌  ▄▄▄ . ▐ ▄ ·▄▄▄▄  ▪   ▐ ▄  ▄▄ •  ▄▄▄· ▄▄▄· ▪  ▄▄▄\r\n// ██•  ▀▄.▀·•█▌▐███▪ ██ ██ •█▌▐█▐█ ▀ ▪▐█ ▄█▐█ ▀█ ██ ▀▄ █·\r\n// ██▪  ▐▀▀▪▄▐█▐▐▌▐█· ▐█▌▐█·▐█▐▐▌▄█ ▀█▄ ██▀·▄█▀▀█ ▐█·▐▀▀▄\r\n// ▐█▌▐▌▐█▄▄▌██▐█▌██. ██ ▐█▌██▐█▌▐█▄▪▐█▐█▪·•▐█ ▪▐▌▐█▌▐█•█▌\r\n// .▀▀▀  ▀▀▀ ▀▀ █▪▀▀▀▀▀• ▀▀▀▀▀ █▪·▀▀▀▀ .▀    ▀  ▀ ▀▀▀.▀  ▀\r\n\r\n// Copyright (c) 2020 BoringCrypto - All rights reserved\r\n// Twitter: @Boring_Crypto\r\n\r\n// Special thanks to:\r\n// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations\r\n\r\n// WARNING!!! DO NOT USE!!! BEING AUDITED!!!\r\n\r\n// solhint-disable avoid-low-level-calls\r\n\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"./libraries/BoringMath.sol\";\r\nimport \"./interfaces/IOracle.sol\";\r\nimport \"./Ownable.sol\";\r\nimport \"./ERC20.sol\";\r\nimport \"./interfaces/IMasterContract.sol\";\r\nimport \"./interfaces/ISwapper.sol\";\r\nimport \"./interfaces/IWETH.sol\";\r\n\r\n// TODO: check all reentrancy paths\r\n// TODO: what to do when the entire pool is underwater?\r\n// TODO: check that all actions on a users funds can only be initiated by that user as msg.sender\r\n\r\ncontract LendingPair is ERC20, Ownable, IMasterContract {\r\n    using BoringMath for uint256;\r\n    using BoringMath128 for uint128;\r\n\r\n    // MasterContract variables\r\n    IBentoBox public immutable bentoBox;\r\n    LendingPair public immutable masterContract;\r\n    address public feeTo;\r\n    address public dev;\r\n    mapping(ISwapper => bool) public swappers;\r\n\r\n    // Per clone variables\r\n    // Clone settings\r\n    IERC20 public collateral;\r\n    IERC20 public asset;\r\n    IOracle public oracle;\r\n    bytes public oracleData;\r\n\r\n    // User balances\r\n    mapping(address => uint256) public userCollateralAmount;\r\n    // userAssetFraction is called balanceOf for ERC20 compatibility\r\n    mapping(address => uint256) public userBorrowFraction;\r\n\r\n    struct TokenTotals {\r\n        uint128 amount;\r\n        uint128 fraction;\r\n    }\r\n\r\n    // Total amounts\r\n    uint256 public totalCollateralAmount;\r\n    TokenTotals public totalAsset; // The total assets belonging to the suppliers (including any borrowed amounts).\r\n    TokenTotals public totalBorrow; // Total units of asset borrowed\r\n\r\n    // totalSupply for ERC20 compatibility\r\n    function totalSupply() public view returns(uint256) {\r\n        return totalAsset.fraction;\r\n    }\r\n\r\n    // Exchange and interest rate tracking\r\n    uint256 public exchangeRate;\r\n\r\n    struct AccrueInfo {\r\n        uint64 interestPerBlock;\r\n        uint64 lastBlockAccrued;\r\n        uint128 feesPendingAmount;\r\n    }\r\n    AccrueInfo public accrueInfo;\r\n\r\n    // ERC20 'variables'\r\n    function symbol() public view returns(string memory) {\r\n        (bool success, bytes memory data) = address(asset).staticcall(abi.encodeWithSelector(0x95d89b41));\r\n        string memory assetSymbol = success && data.length > 0 ? abi.decode(data, (string)) : \"???\";\r\n\r\n        (success, data) = address(collateral).staticcall(abi.encodeWithSelector(0x95d89b41));\r\n        string memory collateralSymbol = success && data.length > 0 ? abi.decode(data, (string)) : \"???\";\r\n\r\n        return string(abi.encodePacked(\"bm\", collateralSymbol, \">\", assetSymbol, \"-\", oracle.symbol(oracleData)));\r\n    }\r\n\r\n    function name() public view returns(string memory) {\r\n        (bool success, bytes memory data) = address(asset).staticcall(abi.encodeWithSelector(0x06fdde03));\r\n        string memory assetName = success && data.length > 0 ? abi.decode(data, (string)) : \"???\";\r\n\r\n        (success, data) = address(collateral).staticcall(abi.encodeWithSelector(0x06fdde03));\r\n        string memory collateralName = success && data.length > 0 ? abi.decode(data, (string)) : \"???\";\r\n\r\n        return string(abi.encodePacked(\"Bento Med Risk \", collateralName, \">\", assetName, \"-\", oracle.symbol(oracleData)));\r\n    }\r\n\r\n    function decimals() public view returns (uint8) {\r\n        (bool success, bytes memory data) = address(asset).staticcall(abi.encodeWithSelector(0x313ce567));\r\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\r\n    }\r\n\r\n    event LogExchangeRate(uint256 rate);\r\n    event LogAccrue(uint256 accruedAmount, uint256 feeAmount, uint256 rate, uint256 utilization);\r\n    event LogAddCollateral(address indexed user, uint256 amount);\r\n    event LogAddAsset(address indexed user, uint256 amount, uint256 fraction);\r\n    event LogAddBorrow(address indexed user, uint256 amount, uint256 fraction);\r\n    event LogRemoveCollateral(address indexed user, uint256 amount);\r\n    event LogRemoveAsset(address indexed user, uint256 amount, uint256 fraction);\r\n    event LogRemoveBorrow(address indexed user, uint256 amount, uint256 fraction);\r\n    event LogFeeTo(address indexed newFeeTo);\r\n    event LogDev(address indexed newDev);\r\n    event LogWithdrawFees();\r\n\r\n    constructor(IBentoBox bentoBox_) public {\r\n        bentoBox = bentoBox_;\r\n        masterContract = LendingPair(this);\r\n        dev = msg.sender;\r\n        feeTo = msg.sender;\r\n        emit LogDev(msg.sender);\r\n        emit LogFeeTo(msg.sender);\r\n    }\r\n\r\n    // Settings for the Medium Risk LendingPair\r\n    uint256 public constant CLOSED_COLLATERIZATION_RATE = 75000; // 75%\r\n    uint256 public constant OPEN_COLLATERIZATION_RATE = 77000; // 77%\r\n    uint256 public constant MINIMUM_TARGET_UTILIZATION = 7e17; // 70%\r\n    uint256 public constant MAXIMUM_TARGET_UTILIZATION = 8e17; // 80%\r\n\r\n    uint256 public constant STARTING_INTEREST_PER_BLOCK = 4566210045; // approx 1% APR\r\n    uint256 public constant MINIMUM_INTEREST_PER_BLOCK = 1141552511; // approx 0.25% APR\r\n    uint256 public constant MAXIMUM_INTEREST_PER_BLOCK = 4566210045000;  // approx 1000% APR\r\n    uint256 public constant INTEREST_ELASTICITY = 2000e36; // Half or double in 2000 blocks (approx 8 hours)\r\n\r\n    uint256 public constant LIQUIDATION_MULTIPLIER = 112000; // add 12%\r\n\r\n    // Fees\r\n    uint256 public constant PROTOCOL_FEE = 10000; // 10%\r\n    uint256 public constant DEV_FEE = 10000; // 10% of the PROTOCOL_FEE = 1%\r\n    uint256 public constant BORROW_OPENING_FEE = 50; // 0.05%\r\n\r\n    // Serves as the constructor, as clones can't have a regular constructor\r\n    function init(bytes calldata data) public override {\r\n        require(address(collateral) == address(0), \"LendingPair: already initialized\");\r\n        (collateral, asset, oracle, oracleData) = abi.decode(data, (IERC20, IERC20, IOracle, bytes));\r\n\r\n        accrueInfo.interestPerBlock = uint64(STARTING_INTEREST_PER_BLOCK);  // 1% APR, with 1e18 being 100%\r\n        updateExchangeRate();\r\n    }\r\n\r\n    function getInitData(IERC20 collateral_, IERC20 asset_, IOracle oracle_, bytes calldata oracleData_) public pure returns(bytes memory data) {\r\n        return abi.encode(collateral_, asset_, oracle_, oracleData_);\r\n    }\r\n\r\n    // Accrues the interest on the borrowed tokens and handles the accumulation of fees\r\n    function accrue() public {\r\n        AccrueInfo memory info = accrueInfo;\r\n        // Number of blocks since accrue was called\r\n        uint256 blocks = block.number - info.lastBlockAccrued;\r\n        if (blocks == 0) {return;}\r\n        info.lastBlockAccrued = uint64(block.number);\r\n\r\n        uint256 extraAmount;\r\n        uint256 feeAmount;\r\n\r\n        TokenTotals memory _totalBorrow = totalBorrow;\r\n        TokenTotals memory _totalAsset = totalAsset;\r\n        if (_totalBorrow.amount > 0) {\r\n            // Accrue interest\r\n            extraAmount = uint256(_totalBorrow.amount).mul(info.interestPerBlock).mul(blocks) / 1e18;\r\n            feeAmount = extraAmount.mul(PROTOCOL_FEE) / 1e5; // % of interest paid goes to fee\r\n            _totalBorrow.amount = _totalBorrow.amount.add(extraAmount.to128());\r\n            totalBorrow = _totalBorrow;\r\n            _totalAsset.amount = _totalAsset.amount.add(extraAmount.sub(feeAmount).to128());\r\n            totalAsset = _totalAsset;\r\n            info.feesPendingAmount = info.feesPendingAmount.add(feeAmount.to128());\r\n        }\r\n\r\n        if (_totalAsset.amount == 0) {\r\n            if (info.interestPerBlock != STARTING_INTEREST_PER_BLOCK) {\r\n                info.interestPerBlock = uint64(STARTING_INTEREST_PER_BLOCK);\r\n                emit LogAccrue(extraAmount, feeAmount, STARTING_INTEREST_PER_BLOCK, 0);\r\n            }\r\n            accrueInfo = info; return;\r\n        }\r\n\r\n        // Update interest rate\r\n        uint256 utilization = uint256(_totalBorrow.amount).mul(1e18) / _totalAsset.amount;\r\n        uint256 newInterestPerBlock;\r\n        if (utilization < MINIMUM_TARGET_UTILIZATION) {\r\n            uint256 underFactor = MINIMUM_TARGET_UTILIZATION.sub(utilization).mul(1e18) / MINIMUM_TARGET_UTILIZATION;\r\n            uint256 scale = INTEREST_ELASTICITY.add(underFactor.mul(underFactor).mul(blocks));\r\n            newInterestPerBlock = uint256(info.interestPerBlock).mul(INTEREST_ELASTICITY) / scale;\r\n            if (newInterestPerBlock < MINIMUM_INTEREST_PER_BLOCK) {newInterestPerBlock = MINIMUM_INTEREST_PER_BLOCK;} // 0.25% APR minimum\r\n       } else if (utilization > MAXIMUM_TARGET_UTILIZATION) {\r\n            uint256 overFactor = utilization.sub(MAXIMUM_TARGET_UTILIZATION).mul(1e18) / uint256(1e18).sub(MAXIMUM_TARGET_UTILIZATION);\r\n            uint256 scale = INTEREST_ELASTICITY.add(overFactor.mul(overFactor).mul(blocks));\r\n            newInterestPerBlock = uint256(info.interestPerBlock).mul(scale) / INTEREST_ELASTICITY;\r\n            if (newInterestPerBlock > MAXIMUM_INTEREST_PER_BLOCK) {newInterestPerBlock = MAXIMUM_INTEREST_PER_BLOCK;} // 1000% APR maximum\r\n        } else {\r\n            emit LogAccrue(extraAmount, feeAmount, info.interestPerBlock, utilization);\r\n            accrueInfo = info; return;\r\n        }\r\n\r\n        info.interestPerBlock = uint64(newInterestPerBlock);\r\n        emit LogAccrue(extraAmount, feeAmount, newInterestPerBlock, utilization);\r\n        accrueInfo = info;\r\n    }\r\n\r\n    // Checks if the user is solvent.\r\n    // Has an option to check if the user is solvent in an open/closed liquidation case.\r\n    function isSolvent(address user, bool open) public view returns (bool) {\r\n        // accrue must have already been called!\r\n        if (userBorrowFraction[user] == 0) return true;\r\n        if (totalCollateralAmount == 0) return false;\r\n\r\n        TokenTotals memory _totalBorrow = totalBorrow;\r\n\r\n        return userCollateralAmount[user].mul(1e13).mul(open ? OPEN_COLLATERIZATION_RATE : CLOSED_COLLATERIZATION_RATE)\r\n            >= (userBorrowFraction[user].mul(_totalBorrow.amount) / _totalBorrow.fraction).mul(exchangeRate);\r\n    }\r\n\r\n    function peekExchangeRate() public view returns (bool, uint256) {\r\n        return oracle.peek(oracleData);\r\n    }\r\n\r\n    // Gets the exchange rate. How much collateral to buy 1e18 asset.\r\n    function updateExchangeRate() public returns (uint256) {\r\n        (bool success, uint256 rate) = oracle.get(oracleData);\r\n\r\n        // TODO: How to deal with unsuccessful fetch\r\n        if (success) {\r\n            exchangeRate = rate;\r\n            emit LogExchangeRate(rate);\r\n        }\r\n        return exchangeRate;\r\n    }\r\n\r\n    // Handles internal variable updates when collateral is deposited\r\n    function _addCollateralAmount(address user, uint256 amount) private {\r\n        // Adds this amount to user\r\n        userCollateralAmount[user] = userCollateralAmount[user].add(amount);\r\n        // Adds the amount deposited to the total of collateral\r\n        totalCollateralAmount = totalCollateralAmount.add(amount);\r\n        emit LogAddCollateral(msg.sender, amount);\r\n    }\r\n\r\n    // Handles internal variable updates when supply (the borrowable token) is deposited\r\n    function _addAssetAmount(address user, uint256 amount) private {\r\n        TokenTotals memory _totalAsset = totalAsset;\r\n        // Calculates what amount of the pool the user gets for the amount deposited\r\n        uint256 newFraction = _totalAsset.fraction == 0 ? amount : amount.mul(_totalAsset.fraction) / _totalAsset.amount;\r\n        // Adds this amount to user\r\n        balanceOf[user] = balanceOf[user].add(newFraction);\r\n        // Adds this amount to the total of supply amounts\r\n        _totalAsset.fraction = _totalAsset.fraction.add(newFraction.to128());\r\n        // Adds the amount deposited to the total of supply\r\n        _totalAsset.amount = _totalAsset.amount.add(amount.to128());\r\n        totalAsset = _totalAsset;\r\n        emit LogAddAsset(msg.sender, amount, newFraction);\r\n    }\r\n\r\n    // Handles internal variable updates when supply (the borrowable token) is borrowed\r\n    function _addBorrowAmount(address user, uint256 amount) private {\r\n        TokenTotals memory _totalBorrow = totalBorrow;\r\n        // Calculates what amount of the borrowed funds the user gets for the amount borrowed\r\n        uint256 newFraction = _totalBorrow.fraction == 0 ? amount : amount.mul(_totalBorrow.fraction) / _totalBorrow.amount;\r\n        // Adds this amount to the user\r\n        userBorrowFraction[user] = userBorrowFraction[user].add(newFraction);\r\n        // Adds amount borrowed to the total amount borrowed\r\n        _totalBorrow.fraction = _totalBorrow.fraction.add(newFraction.to128());\r\n        // Adds amount borrowed to the total amount borrowed\r\n        _totalBorrow.amount = _totalBorrow.amount.add(amount.to128());\r\n        totalBorrow = _totalBorrow;\r\n        emit LogAddBorrow(msg.sender, amount, newFraction);\r\n    }\r\n\r\n    // Handles internal variable updates when collateral is withdrawn and returns the amount of collateral withdrawn\r\n    function _removeCollateralAmount(address user, uint256 amount) private {\r\n        // Subtracts the amount from user\r\n        userCollateralAmount[user] = userCollateralAmount[user].sub(amount);\r\n        // Subtracts the amount from the total of collateral\r\n        totalCollateralAmount = totalCollateralAmount.sub(amount);\r\n        emit LogRemoveCollateral(msg.sender, amount);\r\n    }\r\n\r\n    // Handles internal variable updates when supply is withdrawn and returns the amount of supply withdrawn\r\n    function _removeAssetFraction(address user, uint256 fraction) private returns (uint256 amount) {\r\n        TokenTotals memory _totalAsset = totalAsset;\r\n        // Subtracts the fraction from user\r\n        balanceOf[user] = balanceOf[user].sub(fraction);\r\n        // Calculates the amount of tokens to withdraw\r\n        amount = fraction.mul(_totalAsset.amount) / _totalAsset.fraction;\r\n        // Subtracts the calculated fraction from the total of supply\r\n        _totalAsset.fraction = _totalAsset.fraction.sub(fraction.to128());\r\n        // Subtracts the amount from the total of supply amounts\r\n        _totalAsset.amount = _totalAsset.amount.sub(amount.to128());\r\n        totalAsset = _totalAsset;\r\n        emit LogRemoveAsset(msg.sender, amount, fraction);\r\n    }\r\n\r\n    // Handles internal variable updates when supply is repaid\r\n    function _removeBorrowFraction(address user, uint256 fraction) private returns (uint256 amount) {\r\n        TokenTotals memory _totalBorrow = totalBorrow;\r\n        // Subtracts the fraction from user\r\n        userBorrowFraction[user] = userBorrowFraction[user].sub(fraction);\r\n        // Calculates the amount of tokens to repay\r\n        amount = fraction.mul(_totalBorrow.amount) / _totalBorrow.fraction;\r\n        // Subtracts the fraction from the total of amounts borrowed\r\n        _totalBorrow.fraction = _totalBorrow.fraction.sub(fraction.to128());\r\n        // Subtracts the calculated amount from the total amount borrowed\r\n        _totalBorrow.amount = _totalBorrow.amount.sub(amount.to128());\r\n        totalBorrow = _totalBorrow;\r\n        emit LogRemoveBorrow(msg.sender, amount, fraction);\r\n    }\r\n\r\n    // Deposits an amount of collateral from the caller\r\n    function addCollateral(uint256 amount) public payable { addCollateralTo(amount, msg.sender); }\r\n    function addCollateralTo(uint256 amount, address to) public payable {\r\n        _addCollateralAmount(to, amount);\r\n        bentoBox.deposit{value: msg.value}(collateral, msg.sender, amount);\r\n    }\r\n\r\n    function addCollateralFromBento(uint256 amount) public { addCollateralFromBentoTo(amount, msg.sender); }\r\n    function addCollateralFromBentoTo(uint256 amount, address to) public {\r\n        _addCollateralAmount(to, amount);\r\n        bentoBox.transferFrom(collateral, msg.sender, address(this), amount);\r\n    }\r\n\r\n    // Deposits an amount of supply (the borrowable token) from the caller\r\n    function addAsset(uint256 amount) public payable { addAssetTo(amount, msg.sender); }\r\n    function addAssetTo(uint256 amount, address to) public payable {\r\n        // Accrue interest before calculating pool amounts in _addAssetAmount\r\n        accrue();\r\n        _addAssetAmount(to, amount);\r\n        bentoBox.deposit{value: msg.value}(asset, msg.sender, amount);\r\n    }\r\n\r\n    function addAssetFromBento(uint256 amount) public payable { addAssetFromBentoTo(amount, msg.sender); }\r\n    function addAssetFromBentoTo(uint256 amount, address to) public payable {\r\n        // Accrue interest before calculating pool amounts in _addAssetAmount\r\n        accrue();\r\n        _addAssetAmount(to, amount);\r\n        bentoBox.transferFrom(asset, msg.sender, address(this), amount);\r\n    }\r\n\r\n    // Withdraws a amount of collateral of the caller to the specified address\r\n    function removeCollateral(uint256 amount, address to) public {\r\n        accrue();\r\n        _removeCollateralAmount(msg.sender, amount);\r\n        // Only allow withdrawing if user is solvent (in case of a closed liquidation)\r\n        require(isSolvent(msg.sender, false), \"LendingPair: user insolvent\");\r\n        bentoBox.withdraw(collateral, to, amount);\r\n    }\r\n\r\n    function removeCollateralToBento(uint256 amount, address to) public {\r\n        accrue();\r\n        _removeCollateralAmount(msg.sender, amount);\r\n        // Only allow withdrawing if user is solvent (in case of a closed liquidation)\r\n        require(isSolvent(msg.sender, false), \"LendingPair: user insolvent\");\r\n        bentoBox.transfer(collateral, to, amount);\r\n    }\r\n\r\n    // Withdraws a amount of supply (the borrowable token) of the caller to the specified address\r\n    function removeAsset(uint256 fraction, address to) public {\r\n        // Accrue interest before calculating pool amounts in _removeAssetFraction\r\n        accrue();\r\n        uint256 amount = _removeAssetFraction(msg.sender, fraction);\r\n        bentoBox.withdraw(asset, to, amount);\r\n    }\r\n\r\n    function removeAssetToBento(uint256 fraction, address to) public {\r\n        // Accrue interest before calculating pool amounts in _removeAssetFraction\r\n        accrue();\r\n        uint256 amount = _removeAssetFraction(msg.sender, fraction);\r\n        bentoBox.transfer(asset, to, amount);\r\n    }\r\n\r\n    // Borrows the given amount from the supply to the specified address\r\n    function borrow(uint256 amount, address to) public {\r\n        accrue();\r\n        uint256 feeAmount = amount.mul(BORROW_OPENING_FEE) / 1e5; // A flat % fee is charged for any borrow\r\n        _addBorrowAmount(msg.sender, amount.add(feeAmount));\r\n        totalAsset.amount = totalAsset.amount.add(feeAmount.to128());\r\n        bentoBox.withdraw(asset, to, amount);\r\n        require(isSolvent(msg.sender, false), \"LendingPair: user insolvent\");\r\n    }\r\n\r\n    function borrowToBento(uint256 amount, address to) public {\r\n        accrue();\r\n        uint256 feeAmount = amount.mul(BORROW_OPENING_FEE) / 1e5; // A flat % fee is charged for any borrow\r\n        _addBorrowAmount(msg.sender, amount.add(feeAmount));\r\n        totalAsset.amount = totalAsset.amount.add(feeAmount.to128());\r\n        bentoBox.transfer(asset, to, amount);\r\n        require(isSolvent(msg.sender, false), \"LendingPair: user insolvent\");\r\n    }\r\n\r\n    // Repays the given fraction\r\n    function repay(uint256 fraction) public { repayFor(fraction, msg.sender); }\r\n    function repayFor(uint256 fraction, address beneficiary) public {\r\n        accrue();\r\n        uint256 amount = _removeBorrowFraction(beneficiary, fraction);\r\n        bentoBox.deposit(asset, msg.sender, amount);\r\n    }\r\n\r\n    function repayFromBento(uint256 fraction) public { repayFromBentoTo(fraction, msg.sender); }\r\n    function repayFromBentoTo(uint256 fraction, address beneficiary) public {\r\n        accrue();\r\n        uint256 amount = _removeBorrowFraction(beneficiary, fraction);\r\n        bentoBox.transferFrom(asset, msg.sender, address(this), amount);\r\n    }\r\n\r\n    // Handles shorting with an approved swapper\r\n    function short(ISwapper swapper, uint256 assetAmount, uint256 minCollateralAmount) public {\r\n        require(masterContract.swappers(swapper), \"LendingPair: Invalid swapper\");\r\n        accrue();\r\n        _addBorrowAmount(msg.sender, assetAmount);\r\n        bentoBox.transferFrom(asset, address(this), address(swapper), assetAmount);\r\n\r\n        // Swaps the borrowable asset for collateral\r\n        swapper.swap(asset, collateral, assetAmount, minCollateralAmount);\r\n        uint256 returnedCollateralAmount = bentoBox.skim(collateral); // TODO: Reentrancy issue? Should we take a before and after balance?\r\n        require(returnedCollateralAmount >= minCollateralAmount, \"LendingPair: not enough\");\r\n        _addCollateralAmount(msg.sender, returnedCollateralAmount);\r\n\r\n        require(isSolvent(msg.sender, false), \"LendingPair: user insolvent\");\r\n    }\r\n\r\n    // Handles unwinding shorts with an approved swapper\r\n    function unwind(ISwapper swapper, uint256 borrowFraction, uint256 maxAmountCollateral) public {\r\n        require(masterContract.swappers(swapper), \"LendingPair: Invalid swapper\");\r\n        accrue();\r\n        bentoBox.transferFrom(collateral, address(this), address(swapper), maxAmountCollateral);\r\n\r\n        uint256 borrowAmount = _removeBorrowFraction(msg.sender, borrowFraction);\r\n\r\n        // Swaps the collateral back for the borrowal asset\r\n        uint256 usedAmount = swapper.swapExact(collateral, asset, maxAmountCollateral, borrowAmount, address(this));\r\n        uint256 returnedAssetAmount = bentoBox.skim(asset); // TODO: Reentrancy issue? Should we take a before and after balance?\r\n        require(returnedAssetAmount >= borrowAmount, \"LendingPair: Not enough\");\r\n\r\n        _removeCollateralAmount(msg.sender, maxAmountCollateral.sub(usedAmount));\r\n\r\n        require(isSolvent(msg.sender, false), \"LendingPair: user insolvent\");\r\n    }\r\n\r\n    // Handles the liquidation of users' balances, once the users' amount of collateral is too low\r\n    function liquidate(address[] calldata users, uint256[] calldata borrowFractions, address to, ISwapper swapper, bool open) public {\r\n        accrue();\r\n        updateExchangeRate();\r\n\r\n        uint256 allCollateralAmount;\r\n        uint256 allBorrowAmount;\r\n        uint256 allBorrowFraction;\r\n        TokenTotals memory _totalBorrow = totalBorrow;\r\n        for (uint256 i = 0; i < users.length; i++) {\r\n            address user = users[i];\r\n            if (!isSolvent(user, open)) {\r\n                // Gets the user's amount of the total borrowed amount\r\n                uint256 borrowFraction = borrowFractions[i];\r\n                // Calculates the user's amount borrowed\r\n                uint256 borrowAmount = borrowFraction.mul(_totalBorrow.amount) / _totalBorrow.fraction;\r\n                // Calculates the amount of collateral that's going to be swapped for the asset\r\n                uint256 collateralAmount = borrowAmount.mul(LIQUIDATION_MULTIPLIER).mul(exchangeRate) / 1e23;\r\n\r\n                // Removes the amount of collateral from the user's balance\r\n                userCollateralAmount[user] = userCollateralAmount[user].sub(collateralAmount);\r\n                // Removes the amount of user's borrowed tokens from the user\r\n                userBorrowFraction[user] = userBorrowFraction[user].sub(borrowFraction);\r\n                emit LogRemoveCollateral(user, collateralAmount);\r\n                emit LogRemoveBorrow(user, borrowAmount, borrowFraction);\r\n\r\n                // Keep totals\r\n                allCollateralAmount = allCollateralAmount.add(collateralAmount);\r\n                allBorrowAmount = allBorrowAmount.add(borrowAmount);\r\n                allBorrowFraction = allBorrowFraction.add(borrowFraction);\r\n            }\r\n        }\r\n        require(allBorrowAmount != 0, \"LendingPair: all are solvent\");\r\n        _totalBorrow.amount = _totalBorrow.amount.sub(allBorrowAmount.to128());\r\n        _totalBorrow.fraction = _totalBorrow.fraction.sub(allBorrowFraction.to128());\r\n        totalBorrow = _totalBorrow;\r\n        totalCollateralAmount = totalCollateralAmount.sub(allCollateralAmount);\r\n\r\n        if (!open) {\r\n            // Closed liquidation using a pre-approved swapper for the benefit of the LPs\r\n            require(masterContract.swappers(swapper), \"LendingPair: Invalid swapper\");\r\n\r\n            // Swaps the users' collateral for the borrowed asset\r\n            bentoBox.transferFrom(collateral, address(this), address(swapper), allCollateralAmount);\r\n            swapper.swap(collateral, asset, allCollateralAmount, allBorrowAmount);\r\n            uint256 returnedAssetAmount = bentoBox.skim(asset); // TODO: Reentrancy issue? Should we take a before and after balance?\r\n            uint256 extraAssetAmount = returnedAssetAmount.sub(allBorrowAmount);\r\n\r\n            // The extra asset gets added to the pool\r\n            uint256 feeAmount = extraAssetAmount.mul(PROTOCOL_FEE) / 1e5; // % of profit goes to fee\r\n            accrueInfo.feesPendingAmount = accrueInfo.feesPendingAmount.add(feeAmount.to128());\r\n            totalAsset.amount = totalAsset.amount.add(extraAssetAmount.sub(feeAmount).to128());\r\n            emit LogAddAsset(address(0), extraAssetAmount, 0);\r\n        } else if (address(swapper) == address(0)) {\r\n            // Open liquidation directly using the caller's funds, without swapping using token transfers\r\n            bentoBox.deposit(asset, msg.sender, allBorrowAmount);\r\n            bentoBox.withdraw(collateral, to, allCollateralAmount);\r\n        } else if (address(swapper) == address(1)) {\r\n            // Open liquidation directly using the caller's funds, without swapping using funds in BentoBox\r\n            bentoBox.transferFrom(asset, msg.sender, address(this), allBorrowAmount);\r\n            bentoBox.transfer(collateral, to, allCollateralAmount);\r\n        } else {\r\n            // Swap using a swapper freely chosen by the caller\r\n            // Open (flash) liquidation: get proceeds first and provide the borrow after\r\n            bentoBox.transferFrom(collateral, address(this), address(swapper), allCollateralAmount);\r\n            swapper.swap(collateral, asset, allCollateralAmount, allBorrowAmount);\r\n            uint256 returnedAssetAmount = bentoBox.skim(asset); // TODO: Reentrancy issue? Should we take a before and after balance?\r\n            uint256 extraAssetAmount = returnedAssetAmount.sub(allBorrowAmount);\r\n\r\n            totalAsset.amount = totalAsset.amount.add(extraAssetAmount.to128());\r\n            emit LogAddAsset(address(0), extraAssetAmount, 0);\r\n        }\r\n    }\r\n\r\n    function batch(bytes[] calldata calls, bool revertOnFail) external payable returns(bool[] memory, bytes[] memory) {\r\n        bool[] memory successes = new bool[](calls.length);\r\n        bytes[] memory results = new bytes[](calls.length);\r\n        for (uint256 i = 0; i < calls.length; i++) {\r\n            (bool success, bytes memory result) = address(this).delegatecall(calls[i]);\r\n            require(success || !revertOnFail, \"LendingPair: Transaction failed\");\r\n            successes[i] = success;\r\n            results[i] = result;\r\n        }\r\n        return (successes, results);\r\n    }\r\n\r\n    // Withdraws the fees accumulated\r\n    function withdrawFees() public {\r\n        accrue();\r\n        address _feeTo = masterContract.feeTo();\r\n        address _dev = masterContract.dev();\r\n        uint256 feeAmount = accrueInfo.feesPendingAmount.sub(1);\r\n        uint256 devFeeAmount = _dev == address(0) ? 0 : feeAmount.mul(DEV_FEE) / 1e5;\r\n        accrueInfo.feesPendingAmount = 1; // Don't set it to 0 as that would increase the gas cost for the next accrue called by a user.\r\n        bentoBox.withdraw(asset, _feeTo, feeAmount.sub(devFeeAmount));\r\n        if (devFeeAmount > 0) {\r\n            bentoBox.withdraw(asset, _dev, devFeeAmount);\r\n        }\r\n        emit LogWithdrawFees();\r\n    }\r\n\r\n    // MasterContract Only Admin functions\r\n    function setSwapper(ISwapper swapper, bool enable) public onlyOwner {\r\n        swappers[swapper] = enable;\r\n    }\r\n\r\n    function setFeeTo(address newFeeTo) public onlyOwner\r\n    {\r\n        feeTo = newFeeTo;\r\n        emit LogFeeTo(newFeeTo);\r\n    }\r\n\r\n    function setDev(address newDev) public\r\n    {\r\n        require(msg.sender == dev, \"LendingPair: Not dev\");\r\n        dev = newDev;\r\n        emit LogDev(newDev);\r\n    }\r\n\r\n    // Clone contract Admin functions\r\n    function swipe(IERC20 token) public {\r\n        require(msg.sender == masterContract.owner(), \"LendingPair: caller is not owner\");\r\n\r\n        if (address(token) == address(0)) {\r\n            uint256 balanceETH = address(this).balance;\r\n            if (balanceETH > 0) {\r\n                (bool success,) = msg.sender.call{value: balanceETH}(new bytes(0));\r\n                require(success, \"LendingPair: ETH transfer failed\");\r\n            }\r\n        } else if (address(token) != address(asset) && address(token) != address(collateral)) {\r\n            uint256 balanceAmount = token.balanceOf(address(this));\r\n            if (balanceAmount > 0) {\r\n                (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0xa9059cbb, msg.sender, balanceAmount));\r\n                require(success && (data.length == 0 || abi.decode(data, (bool))), \"LendingPair: Transfer failed\");\r\n            }\r\n        } else {\r\n            uint256 excessAmount = bentoBox.balanceOf(token, address(this)).sub(token == asset ? totalAsset.amount : totalCollateralAmount);\r\n            bentoBox.transfer(token, msg.sender, excessAmount);\r\n        }\r\n    }\r\n}"
    },
    {
      "filename": "contracts/LendingPair.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\n// Medium Risk LendingPair\r\n\r\n// ▄▄▌  ▄▄▄ . ▐ ▄ ·▄▄▄▄  ▪   ▐ ▄  ▄▄ •  ▄▄▄· ▄▄▄· ▪  ▄▄▄\r\n// ██•  ▀▄.▀·•█▌▐███▪ ██ ██ •█▌▐█▐█ ▀ ▪▐█ ▄█▐█ ▀█ ██ ▀▄ █·\r\n// ██▪  ▐▀▀▪▄▐█▐▐▌▐█· ▐█▌▐█·▐█▐▐▌▄█ ▀█▄ ██▀·▄█▀▀█ ▐█·▐▀▀▄\r\n// ▐█▌▐▌▐█▄▄▌██▐█▌██. ██ ▐█▌██▐█▌▐█▄▪▐█▐█▪·•▐█ ▪▐▌▐█▌▐█•█▌\r\n// .▀▀▀  ▀▀▀ ▀▀ █▪▀▀▀▀▀• ▀▀▀▀▀ █▪·▀▀▀▀ .▀    ▀  ▀ ▀▀▀.▀  ▀\r\n\r\n// Copyright (c) 2020 BoringCrypto - All rights reserved\r\n// Twitter: @Boring_Crypto\r\n\r\n// Special thanks to:\r\n// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations\r\n\r\n// WARNING!!! DO NOT USE!!! BEING AUDITED!!!\r\n\r\n// solhint-disable avoid-low-level-calls\r\n\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"./libraries/BoringMath.sol\";\r\nimport \"./interfaces/IOracle.sol\";\r\nimport \"./Ownable.sol\";\r\nimport \"./ERC20.sol\";\r\nimport \"./interfaces/IMasterContract.sol\";\r\nimport \"./interfaces/ISwapper.sol\";\r\nimport \"./interfaces/IWETH.sol\";\r\n\r\n// TODO: check all reentrancy paths\r\n// TODO: what to do when the entire pool is underwater?\r\n// TODO: check that all actions on a users funds can only be initiated by that user as msg.sender\r\n\r\ncontract LendingPair is ERC20, Ownable, IMasterContract {\r\n    using BoringMath for uint256;\r\n    using BoringMath128 for uint128;\r\n\r\n    // MasterContract variables\r\n    IBentoBox public immutable bentoBox;\r\n    LendingPair public immutable masterContract;\r\n    address public feeTo;\r\n    address public dev;\r\n    mapping(ISwapper => bool) public swappers;\r\n\r\n    // Per clone variables\r\n    // Clone settings\r\n    IERC20 public collateral;\r\n    IERC20 public asset;\r\n    IOracle public oracle;\r\n    bytes public oracleData;\r\n\r\n    // User balances\r\n    mapping(address => uint256) public userCollateralAmount;\r\n    // userAssetFraction is called balanceOf for ERC20 compatibility\r\n    mapping(address => uint256) public userBorrowFraction;\r\n\r\n    struct TokenTotals {\r\n        uint128 amount;\r\n        uint128 fraction;\r\n    }\r\n\r\n    // Total amounts\r\n    uint256 public totalCollateralAmount;\r\n    TokenTotals public totalAsset; // The total assets belonging to the suppliers (including any borrowed amounts).\r\n    TokenTotals public totalBorrow; // Total units of asset borrowed\r\n\r\n    // totalSupply for ERC20 compatibility\r\n    function totalSupply() public view returns(uint256) {\r\n        return totalAsset.fraction;\r\n    }\r\n\r\n    // Exchange and interest rate tracking\r\n    uint256 public exchangeRate;\r\n\r\n    struct AccrueInfo {\r\n        uint64 interestPerBlock;\r\n        uint64 lastBlockAccrued;\r\n        uint128 feesPendingAmount;\r\n    }\r\n    AccrueInfo public accrueInfo;\r\n\r\n    // ERC20 'variables'\r\n    function symbol() public view returns(string memory)"
    }
  ]
}