{
  "Title": "[N-17] Non-library/interface files should use fixed compiler versions, not floating ones",
  "Content": "\n*There are 12 instances of this issue:*\n\n```solidity\nFile: contracts/AuraClaimZap.sol\n\n2:    pragma solidity ^0.8.11;\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/AuraClaimZap.sol#L2>\n\n```solidity\nFile: contracts/AuraMinter.sol\n\n2:    pragma solidity ^0.8.11;\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/AuraMinter.sol#L2>\n\n```solidity\nFile: contracts/ExtraRewardsDistributor.sol\n\n2:    pragma solidity ^0.8.11;\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/ExtraRewardsDistributor.sol#L2>\n\n```solidity\nFile: contracts/AuraMerkleDrop.sol\n\n2:    pragma solidity ^0.8.11;\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/AuraMerkleDrop.sol#L2>\n\n```solidity\nFile: contracts/AuraPenaltyForwarder.sol\n\n2:    pragma solidity ^0.8.11;\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/AuraPenaltyForwarder.sol#L2>\n\n```solidity\nFile: contracts/AuraBalRewardPool.sol\n\n2:    pragma solidity ^0.8.11;\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/AuraBalRewardPool.sol#L2>\n\n```solidity\nFile: contracts/AuraLocker.sol\n\n2:    pragma solidity ^0.8.11;\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/AuraLocker.sol#L2>\n\n```solidity\nFile: contracts/ClaimFeesHelper.sol\n\n2:    pragma solidity ^0.8.11;\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/ClaimFeesHelper.sol#L2>\n\n```solidity\nFile: contracts/Aura.sol\n\n2:    pragma solidity ^0.8.11;\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/Aura.sol#L2>\n\n```solidity\nFile: contracts/AuraStakingProxy.sol\n\n2:    pragma solidity ^0.8.11;\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/AuraStakingProxy.sol#L2>\n\n```solidity\nFile: contracts/AuraVestedEscrow.sol\n\n2:    pragma solidity ^0.8.11;\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/AuraVestedEscrow.sol#L2>\n\n```solidity\nFile: contracts/BalLiquidityProvider.sol\n\n2:    pragma solidity ^0.8.11;\n```\n\n<https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/BalLiquidityProvider.sol#L2>\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-05-aura",
  "Code": [
    {
      "filename": "contracts/AuraClaimZap.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport { AuraMath } from \"./AuraMath.sol\";\nimport \"./Interfaces.sol\";\nimport \"@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol\";\n\ninterface IBasicRewards {\n    function getReward(address _account, bool _claimExtras) external;\n\n    function getReward(address _account) external;\n\n    function getReward(address _account, address _token) external;\n\n    function stakeFor(address, uint256) external;\n}\n\ninterface ICrvDepositorWrapper {\n    function deposit(\n        uint256,\n        uint256,\n        bool,\n        address\n    ) external;\n}\n\n/**\n * @title   ClaimZap\n * @author  ConvexFinance -> AuraFinance\n * @notice  Claim zap to bundle various reward claims\n * @dev     Claims from all pools, and stakes cvxCrv and CVX if wanted.\n *          v2:\n *           - change exchange to use curve pool\n *           - add getReward(address,token) type\n *           - add option to lock cvx\n *           - add option use all funds in wallet\n */\ncontract AuraClaimZap {\n    using SafeERC20 for IERC20;\n    using AuraMath for uint256;\n\n    address public immutable crv;\n    address public immutable cvx;\n    address public immutable cvxCrv;\n    address public immutable crvDepositWrapper;\n    address public immutable cvxCrvRewards;\n    address public immutable locker;\n    address public immutable owner;\n\n    enum Options {\n        ClaimCvxCrv, //1\n        ClaimLockedCvx, //2\n        ClaimLockedCvxStake, //4\n        LockCrvDeposit, //8\n        UseAllWalletFunds, //16\n        LockCvx //32\n    }\n\n    /**\n     * @param _crv                CRV token (0xD533a949740bb3306d119CC777fa900bA034cd52);\n     * @param _cvx                CVX token (0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);\n     * @param _cvxCrv             cvxCRV token (0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);\n     * @param _crvDepositWrapper  crvDepositWrapper (0x8014595F2AB54cD7c604B00E9fb932176fDc86Ae);\n     * @param _cvxCrvRewards      cvxCrvRewards (0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e);\n     * @param _locker             vlCVX (0xD18140b4B819b895A3dba5442F959fA44994AF50);\n     */\n    constructor(\n        address _crv,\n        address _cvx,\n        address _cvxCrv,\n        address _crvDepositWrapper,\n        address _cvxCrvRewards,\n        address _locker\n    ) {\n        crv = _crv;\n        cvx = _cvx;\n        cvxCrv = _cvxCrv;\n        crvDepositWrapper = _crvDepositWrapper;\n        cvxCrvRewards = _cvxCrvRewards;\n        locker = _locker;\n        owner = msg.sender;\n    }\n\n    function getName() external pure returns (string memory) {\n        return \"ClaimZap V2.0\";\n    }\n\n    /**\n     * @notice Approve spending of:\n     *          crv     -> crvDepositor\n     *          cvxCrv  -> cvxCrvRewards\n     *          cvx     -> Locker\n     */\n    function setApprovals() external {\n        require(msg.sender == owner, \"!auth\");\n\n        IERC20(crv).safeApprove(crvDepositWrapper, 0);\n        IERC20(crv).safeApprove(crvDepositWrapper, type(uint256).max);\n\n        IERC20(cvxCrv).safeApprove(cvxCrvRewards, 0);\n        IERC20(cvxCrv).safeApprove(cvxCrvRewards, type(uint256).max);\n\n        IERC20(cvx).safeApprove(locker, 0);\n        IERC20(cvx).safeApprove(locker, type(uint256).max);\n    }\n\n    /**\n     * @notice Use bitmask to check if option flag is set\n     */\n    function _checkOption(uint256 _mask, uint256 _flag) internal pure returns (bool) {\n        return (_mask & (1 << _flag)) != 0;\n    }\n\n    /**\n     * @notice Claim all the rewards\n     * @param rewardContracts       Array of addresses for LP token rewards\n     * @param extraRewardContracts  Array of addresses for extra rewards\n     * @param tokenRewardContracts  Array of addresses for token rewards e.g vlCvxExtraRewardDistribution\n     * @param tokenRewardTokens     Array of token reward addresses to use with tokenRewardContracts\n     * @param depositCrvMaxAmount   The max amount of CRV to deposit if converting to crvCvx\n     * @param minAmountOut          The min amount out for crv:cvxCrv swaps if swapping. Set this to zero if you\n     *                              want to use CrvDepositor instead of balancer swap\n     * @param depositCvxMaxAmount   The max amount of CVX to deposit if locking CVX\n     * @param options               Claim options\n     */\n    function claimRewards(\n        address[] calldata rewardContracts,\n        address[] calldata extraRewardContracts,\n        address[] calldata tokenRewardContracts,\n        address[] calldata tokenRewardTokens,\n        uint256 depositCrvMaxAmount,\n        uint256 minAmountOut,\n        uint256 depositCvxMaxAmount,\n        uint256 options\n    ) external {\n        require(tokenRewardContracts.length == tokenRewardTokens.length, \"!parity\");\n\n        uint256 crvBalance = IERC20(crv).balanceOf(msg.sender);\n        uint256 cvxBalance = IERC20(cvx).balanceOf(msg.sender);\n\n        //claim from main curve LP pools\n        for (uint256 i = 0; i < rewardContracts.length; i++) {\n            IBasicRewards(rewardContracts[i]).getReward(msg.sender, true);\n        }\n        //claim from extra rewards\n        for (uint256 i = 0; i < extraRewardContracts.length; i++) {\n            IBasicRewards(extraRewardContracts[i]).getReward(msg.sender);\n        }\n        //claim from multi reward token contract\n        for (uint256 i = 0; i < tokenRewardContracts.length; i++) {\n            IBasicRewards(tokenRewardContracts[i]).getReward(msg.sender, tokenRewardTokens[i]);\n        }\n\n        // claim others/deposit/lock/stake\n        _claimExtras(depositCrvMaxAmount, minAmountOut, depositCvxMaxAmount, crvBalance, cvxBalance, options);\n    }\n\n    /**\n     * @notice  Claim additional rewards from:\n     *          - cvxCrvRewards\n     *          - cvxLocker\n     * @param depositCrvMaxAmount see claimRewards\n     * @param minAmountOut        see claimRewards\n     * @param depositCvxMaxAmount see claimRewards\n     * @param removeCrvBalance    crvBalance to ignore and not redeposit (starting Crv balance)\n     * @param removeCvxBalance    cvxBalance to ignore and not redeposit (starting Cvx balance)\n     * @param options             see claimRewards\n     */\n    // prettier-ignore\n    function _claimExtras( // solhint-disable-line \n        uint256 depositCrvMaxAmount,\n        uint256 minAmountOut,\n        uint256 depositCvxMaxAmount,\n        uint256 removeCrvBalance,\n        uint256 removeCvxBalance,\n        uint256 options\n    ) internal {\n        //claim from cvxCrv rewards\n        if (_checkOption(options, uint256(Options.ClaimCvxCrv))) {\n            IBasicRewards(cvxCrvRewards).getReward(msg.sender, true);\n        }\n\n        //claim from locker\n        if (_checkOption(options, uint256(Options.ClaimLockedCvx))) {\n            IAuraLocker(locker).getReward(msg.sender, _checkOption(options, uint256(Options.ClaimLockedCvxStake)));\n        }\n\n        //reset remove balances if we want to also stake/lock funds already in our wallet\n        if (_checkOption(options, uint256(Options.UseAllWalletFunds))) {\n            removeCrvBalance = 0;\n            removeCvxBalance = 0;\n        }\n\n        //lock upto given amount of crv and stake\n        if (depositCrvMaxAmount > 0) {\n            uint256 crvBalance = IERC20(crv).balanceOf(msg.sender).sub(removeCrvBalance);\n            crvBalance = AuraMath.min(crvBalance, depositCrvMaxAmount);\n\n            if (crvBalance > 0) {\n                //pull crv\n                IERC20(crv).safeTransferFrom(msg.sender, address(this), crvBalance);\n                //deposit\n                ICrvDepositorWrapper(crvDepositWrapper).deposit(\n                    crvBalance,\n                    minAmountOut,\n                    _checkOption(options, uint256(Options.LockCrvDeposit)),\n                    address(0)\n                );\n\n                uint256 cvxCrvBalance = IERC20(cvxCrv).balanceOf(address(this));\n                //stake for msg.sender\n                IBasicRewards(cvxCrvRewards).stakeFor(msg.sender, cvxCrvBalance);\n            }\n        }\n\n        //stake up to given amount of cvx\n        if (depositCvxMaxAmount > 0) {\n            uint256 cvxBalance = IERC20(cvx).balanceOf(msg.sender).sub(removeCvxBalance);\n            cvxBalance = AuraMath.min(cvxBalance, depositCvxMaxAmount);\n            if (cvxBalance > 0) {\n                //pull cvx\n                IERC20(cvx).safeTransferFrom(msg.sender, address(this), cvxBalance);\n                if (_checkOption(options, uint256(Options.LockCvx))) {\n                    IAuraLocker(locker).lock(msg.sender, cvxBalance);\n                }\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/AuraMinter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport { Ownable } from \"@openzeppelin/contracts-0.8/access/Ownable.sol\";\nimport { AuraToken } from \"./Aura.sol\";\n\n/**\n * @title   AuraMinter\n * @notice  Wraps the AuraToken minterMint function and protects from inflation until\n *          4 years have passed.\n * @dev     Ownership initially owned by the DAO, but likely transferred to smart contract\n *          wrapper or additional value system at some stage as directed by token holders.\n */\ncontract AuraMinter is Ownable {\n    /// @dev Aura token\n    AuraToken public immutable aura;\n    /// @dev Timestamp upon which minting will be possible\n    uint256 public immutable inflationProtectionTime;\n\n    constructor(address _aura, address _dao) Ownable() {\n        aura = AuraToken(_aura);\n        _transferOwnership(_dao);\n        inflationProtectionTime = block.timestamp + 156 weeks;\n    }\n\n    /**\n     * @dev Mint function allows the owner of the contract to inflate AURA post protection time\n     * @param _to Recipient address\n     * @param _amount Amount of tokens\n     */\n    function mint(address _to, uint256 _amount) external onlyOwner {\n        require(block.timestamp > inflationProtectionTime, \"Inflation protected for now\");\n        aura.minterMint(_to, _amount);\n    }\n}"
    },
    {
      "filename": "contracts/ExtraRewardsDistributor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport { IExtraRewardsDistributor, IAuraLocker } from \"./Interfaces.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts-0.8/security/ReentrancyGuard.sol\";\n\n/**\n * @title   ExtraRewardsDistributor\n * @author  adapted from ConvexFinance\n * @notice  Allows anyone to distribute rewards to the AuraLocker at a given epoch.\n */\ncontract ExtraRewardsDistributor is ReentrancyGuard, IExtraRewardsDistributor {\n    using SafeERC20 for IERC20;\n\n    IAuraLocker public immutable auraLocker;\n\n    // token -> epoch -> amount\n    mapping(address => mapping(uint256 => uint256)) public rewardData;\n    // token -> epochList\n    mapping(address => uint256[]) public rewardEpochs;\n    // token -> account -> last claimed epoch index\n    mapping(address => mapping(address => uint256)) public userClaims;\n\n    /* ========== EVENTS ========== */\n\n    event RewardAdded(address indexed token, uint256 indexed epoch, uint256 reward);\n    event RewardPaid(address indexed user, address indexed token, uint256 reward, uint256 index);\n    event RewardForfeited(address indexed user, address indexed token, uint256 index);\n\n    /**\n     * @dev Simple constructoor\n     * @param _auraLocker Aura Locker address\n     */\n    constructor(address _auraLocker) {\n        auraLocker = IAuraLocker(_auraLocker);\n    }\n\n    /* ========== ADD REWARDS ========== */\n\n    /**\n     * @notice Add a reward to the current epoch. can be called multiple times for the same reward token\n     * @param _token    Reward token address\n     * @param _amount   Amount of reward tokenÏ€\n     */\n    function addReward(address _token, uint256 _amount) external {\n        auraLocker.checkpointEpoch();\n\n        uint256 latestEpoch = auraLocker.epochCount() - 1;\n        _addReward(_token, _amount, latestEpoch);\n    }\n\n    /**\n     * @notice Add reward token to a specific epoch\n     * @param _token    Reward token address\n     * @param _amount   Amount of reward tokens to add\n     * @param _epoch    Which epoch to add to (must be less than the previous epoch)\n     */\n    function addRewardToEpoch(\n        address _token,\n        uint256 _amount,\n        uint256 _epoch\n    ) external {\n        auraLocker.checkpointEpoch();\n\n        uint256 latestEpoch = auraLocker.epochCount() - 1;\n        require(_epoch <= latestEpoch, \"Cannot assign to the future\");\n\n        if (_epoch == latestEpoch) {\n            _addReward(_token, _amount, latestEpoch);\n        } else {\n            uint256 len = rewardEpochs[_token].length;\n            require(len == 0 || rewardEpochs[_token][len - 1] < _epoch, \"Cannot backdate to this epoch\");\n\n            _addReward(_token, _amount, _epoch);\n        }\n    }\n\n    /**\n     * @notice  Transfer reward tokens from sender to contract for vlCVX holders\n     * @dev     Add reward token for specific epoch\n     * @param _token    Reward token address\n     * @param _amount   Amount of reward tokens\n     * @param _epoch    Epoch to add tokens to\n     */\n    function _addReward(\n        address _token,\n        uint256 _amount,\n        uint256 _epoch\n    ) internal nonReentrant {\n        // Pull before reward accrual\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n\n        //convert to reward per token\n        uint256 supply = auraLocker.totalSupplyAtEpoch(_epoch);\n        uint256 rPerT = (_amount * 1e20) / supply;\n        rewardData[_token][_epoch] += rPerT;\n\n        //add epoch to list\n        uint256 len = rewardEpochs[_token].length;\n        if (len == 0 || rewardEpochs[_token][len - 1] < _epoch) {\n            rewardEpochs[_token].push(_epoch);\n        }\n\n        //event\n        emit RewardAdded(_token, _epoch, _amount);\n    }\n\n    /* ========== GET REWARDS ========== */\n\n    /**\n     * @notice Claim rewards for a specific token since the first epoch.\n     * @param _account  Address of vlCVX holder\n     * @param _token    Reward token address\n     */\n    function getReward(address _account, address _token) public {\n        _getReward(_account, _token, 0);\n    }\n\n    /**\n     * @notice Claim rewards for a specific token at a specific epoch\n     * @param _account      Address of vlCVX holder\n     * @param _token        Reward token address\n     * @param _startIndex   Index of rewardEpochs[_token] to start checking for rewards from\n     */\n    function getReward(\n        address _account,\n        address _token,\n        uint256 _startIndex\n    ) public {\n        _getReward(_account, _token, _startIndex);\n    }\n\n    /**\n     * @notice Claim rewards for a specific token at a specific epoch\n     * @param _account     Address of vlCVX holder\n     * @param _token       Reward token address\n     * @param _startIndex  Index of rewardEpochs[_token] to start checking for rewards from\n     */\n    function _getReward(\n        address _account,\n        address _token,\n        uint256 _startIndex\n    ) public {\n        //get claimable tokens\n        (uint256 claimableTokens, uint256 index) = _allClaimableRewards(_account, _token, _startIndex);\n\n        if (claimableTokens > 0) {\n            //set claim checkpoint\n            userClaims[_token][_account] = index;\n\n            //send\n            IERC20(_token).safeTransfer(_account, claimableTokens);\n\n            //event\n            emit RewardPaid(_account, _token, claimableTokens, index);\n        }\n    }\n\n    /**\n     * @notice  Allow a user to set their claimed index forward without claiming rewards\n     *          Because claims cycle through all periods that a specific reward was given\n     *          there becomes a situation where, for example, a new user could lock\n     *          2 years from now and try to claim a token that was given out every week prior.\n     *          This would result in a 2mil gas checkpoint.(about 20k gas * 52 weeks * 2 years)\n     * @param _token  Reward token to forfeit\n     * @param _index  Epoch index to forfeit from\n     */\n    function forfeitRewards(address _token, uint256 _index) external {\n        require(_index > 0 && _index < rewardEpochs[_token].length - 1, \"!past\");\n        require(_index >= userClaims[_token][msg.sender], \"already claimed\");\n\n        //set claim checkpoint. next claim starts from index+1\n        userClaims[_token][msg.sender] = _index + 1;\n\n        emit RewardForfeited(msg.sender, _token, _index);\n    }\n\n    /* ========== VIEW REWARDS ========== */\n\n    /**\n     * @notice Get claimable rewards (rewardToken) for vlCVX holder\n     * @param _account  Address of vlCVX holder\n     * @param _token    Reward token address\n     */\n    function claimableRewards(address _account, address _token) external view returns (uint256) {\n        (uint256 rewards, ) = _allClaimableRewards(_account, _token, 0);\n        return rewards;\n    }\n\n    /**\n     * @notice Get claimable rewards for a token at a specific epoch\n     * @param _account     Address of vlCVX holder\n     * @param _token       Reward token address\n     * @param _epoch       The epoch to check for rewards\n     */\n    function claimableRewardsAtEpoch(\n        address _account,\n        address _token,\n        uint256 _epoch\n    ) external view returns (uint256) {\n        return _claimableRewards(_account, _token, _epoch);\n    }\n\n    /**\n     * @notice  Get all claimable rewards by looping through each epoch starting with the latest\n     *          saved epoch the user last claimed from\n     * @param _account  Address of vlCVX holder\n     * @param _token    Reward token\n     * @param _startIndex  Index of rewardEpochs[_token] to start checking for rewards from\n     */\n    function _allClaimableRewards(\n        address _account,\n        address _token,\n        uint256 _startIndex\n    ) internal view returns (uint256, uint256) {\n        uint256 latestEpoch = auraLocker.epochCount() - 1;\n        // e.g. tokenEpochs = 31, 21\n        uint256 tokenEpochs = rewardEpochs[_token].length;\n\n        // e.g. epochIndex = 0\n        uint256 epochIndex = userClaims[_token][_account];\n        // e.g. epochIndex = 27 > 0 ? 27 : 0 = 27\n        epochIndex = _startIndex > epochIndex ? _startIndex : epochIndex;\n\n        if (epochIndex >= tokenEpochs) {\n            return (0, tokenEpochs);\n        }\n\n        uint256 claimableTokens = 0;\n\n        for (uint256 i = epochIndex; i < tokenEpochs; i++) {\n            //only claimable after rewards are \"locked in\"\n            if (rewardEpochs[_token][i] < latestEpoch) {\n                claimableTokens += _claimableRewards(_account, _token, rewardEpochs[_token][i]);\n                //return index user claims should be set to\n                epochIndex = i + 1;\n            }\n        }\n        return (claimableTokens, epochIndex);\n    }\n\n    /**\n     * @notice Get claimable rewards for a token at a specific epoch\n     * @param _account     Address of vlCVX holder\n     * @param _token       Reward token address\n     * @param _epoch       The epoch to check for rewards\n     */\n    function _claimableRewards(\n        address _account,\n        address _token,\n        uint256 _epoch\n    ) internal view returns (uint256) {\n        //get balance and calc share\n        uint256 balance = auraLocker.balanceAtEpochOf(_epoch, _account);\n        return (balance * rewardData[_token][_epoch]) / 1e20;\n    }\n\n    /**\n     * @notice Simply gets the current epoch count for a given reward token\n     * @param _token    Reward token address\n     * @return _epochs  Number of epochs\n     */\n    function rewardEpochsCount(address _token) external view returns (uint256) {\n        return rewardEpochs[_token].length;\n    }\n}"
    },
    {
      "filename": "contracts/AuraMerkleDrop.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport { MerkleProof } from \"@openzeppelin/contracts-0.8/utils/cryptography/MerkleProof.sol\";\nimport { IAuraLocker } from \"./Interfaces.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts-0.8/security/ReentrancyGuard.sol\";\n\n/**\n * @title   AuraMerkleDrop\n * @dev     Forked from convex-platform/contracts/contracts/MerkleAirdrop.sol. Changes:\n *            - solc 0.8.11 & OpenZeppelin MerkleDrop\n *            - Delayed start w/ trigger\n *            - EndTime for withdrawal to treasuryDAO\n *            - Penalty on claim & AuraLocker lock (only if address(auraLocker) != 0)\n *            - Non custodial (cannot change root)\n */\ncontract AuraMerkleDrop {\n    using SafeERC20 for IERC20;\n\n    address public dao;\n    bytes32 public merkleRoot;\n\n    IERC20 public immutable aura;\n    IAuraLocker public auraLocker;\n\n    address public immutable penaltyForwarder;\n    uint256 public pendingPenalty = 0;\n\n    uint256 public startTime;\n    uint256 public immutable expiryTime;\n\n    mapping(address => bool) public hasClaimed;\n\n    event DaoSet(address newDao);\n    event RootSet(bytes32 newRoot);\n    event StartedEarly();\n    event ExpiredWithdrawn(uint256 amount);\n    event LockerSet(address newLocker);\n    event Claimed(address addr, uint256 amt, bool locked);\n    event PenaltyForwarded(uint256 amount);\n\n    /**\n     * @param _dao              The Aura Dao\n     * @param _merkleRoot       Merkle root\n     * @param _aura             Aura token\n     * @param _auraLocker       Aura locker contract\n     * @param _penaltyForwarder PenaltyForwarded contract\n     * @param _startDelay       Delay until claim is live\n     * @param _expiresAfter     Timestamp claim expires\n     */\n    constructor(\n        address _dao,\n        bytes32 _merkleRoot,\n        address _aura,\n        address _auraLocker,\n        address _penaltyForwarder,\n        uint256 _startDelay,\n        uint256 _expiresAfter\n    ) {\n        dao = _dao;\n        merkleRoot = _merkleRoot;\n        aura = IERC20(_aura);\n        auraLocker = IAuraLocker(_auraLocker);\n        penaltyForwarder = _penaltyForwarder;\n        startTime = block.timestamp + _startDelay;\n\n        require(_expiresAfter > 2 weeks, \"!expiry\");\n        expiryTime = startTime + _expiresAfter;\n    }\n\n    /***************************************\n                    CONFIG\n    ****************************************/\n\n    function setDao(address _newDao) external {\n        require(msg.sender == dao, \"!auth\");\n        dao = _newDao;\n        emit DaoSet(_newDao);\n    }\n\n    function setRoot(bytes32 _merkleRoot) external {\n        require(msg.sender == dao, \"!auth\");\n        require(merkleRoot == bytes32(0), \"already set\");\n        merkleRoot = _merkleRoot;\n        emit RootSet(_merkleRoot);\n    }\n\n    function startEarly() external {\n        require(msg.sender == dao, \"!auth\");\n        startTime = block.timestamp;\n        emit StartedEarly();\n    }\n\n    function withdrawExpired() external {\n        require(msg.sender == dao, \"!auth\");\n        require(block.timestamp > expiryTime, \"!expired\");\n        uint256 amt = aura.balanceOf(address(this));\n        aura.safeTransfer(dao, amt);\n        emit ExpiredWithdrawn(amt);\n    }\n\n    function setLocker(address _newLocker) external {\n        require(msg.sender == dao, \"!auth\");\n        auraLocker = IAuraLocker(_newLocker);\n        emit LockerSet(_newLocker);\n    }\n\n    /***************************************\n                    CLAIM\n    ****************************************/\n\n    function claim(\n        bytes32[] calldata _proof,\n        uint256 _amount,\n        bool _lock\n    ) public returns (bool) {\n        require(merkleRoot != bytes32(0), \"!root\");\n        require(block.timestamp > startTime, \"!started\");\n        require(block.timestamp < expiryTime, \"!active\");\n        require(_amount > 0, \"!amount\");\n        require(hasClaimed[msg.sender] == false, \"already claimed\");\n\n        bytes32 leaf = keccak256(abi.encodePacked(msg.sender, _amount));\n        require(MerkleProof.verify(_proof, merkleRoot, leaf), \"invalid proof\");\n\n        hasClaimed[msg.sender] = true;\n\n        if (_lock) {\n            aura.safeApprove(address(auraLocker), 0);\n            aura.safeApprove(address(auraLocker), _amount);\n            auraLocker.lock(msg.sender, _amount);\n        } else {\n            // If there is an address for auraLocker, and not locking, apply 20% penalty\n            uint256 penalty = address(auraLocker) == address(0) ? 0 : (_amount * 2) / 10;\n            pendingPenalty += penalty;\n            aura.safeTransfer(msg.sender, _amount - penalty);\n        }\n\n        emit Claimed(msg.sender, _amount, _lock);\n        return true;\n    }\n\n    /***************************************\n                    FORWARD\n    ****************************************/\n\n    function forwardPenalty() public {\n        uint256 toForward = pendingPenalty;\n        pendingPenalty = 0;\n        require(penaltyForwarder != address(0), \"!forwarder\");\n        aura.safeTransfer(penaltyForwarder, toForward);\n        emit PenaltyForwarded(toForward);\n    }\n}"
    },
    {
      "filename": "contracts/AuraPenaltyForwarder.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport { IExtraRewardsDistributor } from \"./Interfaces.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title AuraPenaltyForwarder\n * @dev Receives a given token and forwards it on to a distribution contract. Used during\n *      the bootstrapping period to forward AURA rewards to the extra rewards distributor.\n */\ncontract AuraPenaltyForwarder {\n    using SafeERC20 for IERC20;\n\n    IExtraRewardsDistributor public immutable distributor;\n    IERC20 public immutable token;\n\n    uint256 public immutable distributionDelay;\n    uint256 public lastDistribution;\n\n    event Forwarded(uint256 amount);\n\n    /**\n     * @dev During deployment approves the distributor to spend all tokens\n     * @param _distributor  Contract that will distribute tokens\n     * @param _token        Token to be distributed\n     * @param _delay        Delay between each distribution trigger\n     */\n    constructor(\n        address _distributor,\n        address _token,\n        uint256 _delay\n    ) {\n        distributor = IExtraRewardsDistributor(_distributor);\n        token = IERC20(_token);\n        distributionDelay = _delay;\n\n        lastDistribution = block.timestamp;\n\n        token.safeApprove(address(distributor), type(uint256).max);\n    }\n\n    /**\n     * @dev Forwards the complete balance of token in this contract to the distributor\n     */\n    function forward() public {\n        require(block.timestamp > lastDistribution + distributionDelay, \"!elapsed\");\n        lastDistribution = block.timestamp;\n\n        uint256 bal = token.balanceOf(address(this));\n        require(bal > 0, \"!empty\");\n\n        distributor.addReward(address(token), bal);\n\n        emit Forwarded(bal);\n    }\n}"
    },
    {
      "filename": "contracts/AuraBalRewardPool.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport { AuraMath } from \"./AuraMath.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts-0.8/utils/math/SafeMath.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol\";\n\nimport { IAuraLocker } from \"./Interfaces.sol\";\n\n/**\n * @title   AuraBalRewardPool\n * @author  Synthetix -> ConvexFinance -> adapted\n * @notice  This AuraBalRewardPool is deployed to support auraBAL deposits during the first 2\n *          weeks of system operation. After which, the BaseRewardPool hooked into the Booster (lockRewards)\n *          will be used for auraBAL farming.\n * @dev     Modifications from convex-platform/contracts/contracts/BaseRewardPool.sol:\n *            - Delayed start (tokens transferred then delay is enforced before notification)\n *            - One time duration of 14 days\n *            - Remove child reward contracts\n *            - Penalty on claim at 20%\n */\ncontract AuraBalRewardPool {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable rewardToken;\n    IERC20 public immutable stakingToken;\n    uint256 public constant duration = 14 days;\n\n    address public immutable rewardManager;\n\n    IAuraLocker public immutable auraLocker;\n    address public immutable penaltyForwarder;\n    uint256 public pendingPenalty = 0;\n    uint256 public immutable startTime;\n\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    uint256 private _totalSupply;\n\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n    mapping(address => uint256) private _balances;\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward, bool locked);\n    event PenaltyForwarded(uint256 amount);\n\n    /**\n     * @dev Simple constructoor\n     * @param _stakingToken  Pool LP token\n     * @param _rewardToken   $AURA\n     * @param _rewardManager Depositor\n     * @param _auraLocker    $AURA lock contract\n     * @param _penaltyForwarder Address to which penalties are sent\n     */\n    constructor(\n        address _stakingToken,\n        address _rewardToken,\n        address _rewardManager,\n        address _auraLocker,\n        address _penaltyForwarder,\n        uint256 _startDelay\n    ) {\n        stakingToken = IERC20(_stakingToken);\n        rewardToken = IERC20(_rewardToken);\n        rewardManager = _rewardManager;\n        auraLocker = IAuraLocker(_auraLocker);\n        penaltyForwarder = _penaltyForwarder;\n        rewardToken.safeApprove(_auraLocker, type(uint256).max);\n\n        require(_startDelay < 2 weeks, \"!delay\");\n        startTime = block.timestamp + _startDelay;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return AuraMath.min(block.timestamp, periodFinish);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalSupply() == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRate).mul(1e18).div(totalSupply())\n            );\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return\n            balanceOf(account).mul(rewardPerToken().sub(userRewardPerTokenPaid[account])).div(1e18).add(\n                rewards[account]\n            );\n    }\n\n    function stake(uint256 _amount) public updateReward(msg.sender) returns (bool) {\n        require(_amount > 0, \"RewardPool : Cannot stake 0\");\n\n        _totalSupply = _totalSupply.add(_amount);\n        _balances[msg.sender] = _balances[msg.sender].add(_amount);\n\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n        emit Staked(msg.sender, _amount);\n\n        return true;\n    }\n\n    function stakeAll() external returns (bool) {\n        uint256 balance = stakingToken.balanceOf(msg.sender);\n        stake(balance);\n        return true;\n    }\n\n    function stakeFor(address _for, uint256 _amount) public updateReward(_for) returns (bool) {\n        require(_amount > 0, \"RewardPool : Cannot stake 0\");\n\n        //give to _for\n        _totalSupply = _totalSupply.add(_amount);\n        _balances[_for] = _balances[_for].add(_amount);\n\n        //take away from sender\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n        emit Staked(_for, _amount);\n\n        return true;\n    }\n\n    function withdraw(\n        uint256 amount,\n        bool claim,\n        bool lock\n    ) public updateReward(msg.sender) returns (bool) {\n        require(amount > 0, \"RewardPool : Cannot withdraw 0\");\n\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n\n        stakingToken.safeTransfer(msg.sender, amount);\n        emit Withdrawn(msg.sender, amount);"
    }
  ]
}