{
  "Title": "[G-15] Expressions for constant values such as a call to `keccak256()`, should use `immutable` rather than `constant`",
  "Content": "\nSee [this](https://github.com/ethereum/solidity/issues/9232) issue for a detail description of the issue\n\n1.  File: contracts/BaseIndex.sol (line [25](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/BaseIndex.sol#L25))\n\n```solidity\n    bytes32 internal constant INDEX_MANAGER_ROLE = keccak256(\"INDEX_MANAGER_ROLE\");\n```\n\n2.  File: contracts/ChainlinkPriceOracle.sol (line [29](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/ChainlinkPriceOracle.sol#L29))\n\n```solidity\n    bytes32 private constant ASSET_MANAGER_ROLE = keccak256(\"ASSET_MANAGER_ROLE\");\n```\n\n3.  File: contracts/IndexLogic.sol (line [25](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/IndexLogic.sol#L25))\n\n```solidity\n    bytes32 internal constant ASSET_ROLE = keccak256(\"ASSET_ROLE\");\n```\n\n4.  File: contracts/IndexLogic.sol (line [27](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/IndexLogic.sol#L27))\n\n```solidity\n    bytes32 internal constant SKIPPED_ASSET_ROLE = keccak256(\"SKIPPED_ASSET_ROLE\");\n```\n\n5.  File: contracts/ManagedIndexReweightingLogic.sol (line [25](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/ManagedIndexReweightingLogic.sol#L25))\n\n```solidity\n    bytes32 internal constant ASSET_ROLE = keccak256(\"ASSET_ROLE\");\n```\n\n6.  File: contracts/PhuturePriceOracle.sol (line [21](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/PhuturePriceOracle.sol#L21))\n\n```solidity\n    bytes32 private constant ASSET_MANAGER_ROLE = keccak256(\"ASSET_MANAGER_ROLE\");\n```\n\n7.  File: contracts/TopNMarketCapIndex.sol (line [18](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/TopNMarketCapIndex.sol#L18))\n\n```solidity\n    bytes32 internal constant ORDERER_ROLE = keccak256(\"ORDERER_ROLE\");\n```\n\n8.  File: contracts/TopNMarketCapReweightingLogic.sol (line [27](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/TopNMarketCapReweightingLogic.sol#L27))\n\n```solidity\n    bytes32 internal constant ASSET_ROLE = keccak256(\"ASSET_ROLE\");\n```\n\n9.  File: contracts/TrackedIndexReweightingLogic.sol (line [25](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/TrackedIndexReweightingLogic.sol#L25))\n\n```solidity\n    bytes32 internal constant ASSET_ROLE = keccak256(\"ASSET_ROLE\");\n```\n\n10. File: contracts/TrackedIndex.sol (line [17](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/TrackedIndex.sol#L17))\n\n```solidity\n    bytes32 internal constant ORDERER_ROLE = keccak256(\"ORDERER_ROLE\");\n```\n\n11. File: contracts/vToken.sol (line [27](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/vToken.sol#L27))\n\n```solidity\n    bytes32 private constant INDEX_ROLE = keccak256(\"INDEX_ROLE\");\n```\n\n12. File: contracts/vToken.sol (line [29](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/vToken.sol#L29))\n\n```solidity\n    bytes32 private constant ORACLE_ROLE = keccak256(\"ORACLE_ROLE\");\n```\n\n13. File: contracts/vToken.sol (line [31](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/vToken.sol#L31))\n\n```solidity\n    bytes32 private constant ORDERER_ROLE = keccak256(\"ORDERER_ROLE\");\n```\n\n14. File: contracts/vToken.sol (line [33](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/vToken.sol#L33))\n\n```solidity\n    bytes32 private constant RESERVE_MANAGER_ROLE = keccak256(\"RESERVE_MANAGER_ROLE\");\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-04-phuture-finance-contest",
  "Code": [
    {
      "filename": "contracts/BaseIndex.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.8.7;\n\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\n\nimport \"./libraries/IndexLibrary.sol\";\n\nimport \"./interfaces/IIndex.sol\";\nimport \"./interfaces/IIndexLogic.sol\";\nimport \"./interfaces/IIndexFactory.sol\";\nimport \"./interfaces/IPhuturePriceOracle.sol\";\n\nimport \"./PhutureIndex.sol\";\n\n/// @title Base index\n/// @notice Contains common logic for all indices\nabstract contract BaseIndex is PhutureIndex, ReentrancyGuard, IIndex {\n    using ERC165Checker for address;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @notice Role allows configure index related data/components\n    bytes32 internal constant INDEX_MANAGER_ROLE = keccak256(\"INDEX_MANAGER_ROLE\");\n\n    /// @notice Checks if msg.sender has the given role's permission\n    modifier onlyRole(bytes32 role) {\n        require(IAccessControl(registry).hasRole(role, msg.sender), \"GovernableIndex: FORBIDDEN\");\n        _;\n    }\n\n    constructor(address _factory) {\n        require(_factory.supportsInterface(type(IIndexFactory).interfaceId), \"BaseIndex: INTERFACE\");\n\n        factory = _factory;\n        lastTransferTime = block.timestamp;\n        registry = IIndexFactory(_factory).registry();\n        vTokenFactory = IIndexFactory(_factory).vTokenFactory();\n    }\n\n    /// @inheritdoc IIndex\n    function mint(address _recipient) external override nonReentrant {\n        (bool success, bytes memory data) = IIndexRegistry(registry).indexLogic().delegatecall(\n            abi.encodeWithSelector(IIndexLogic.mint.selector, _recipient)\n        );\n        if (!success) {\n            if (data.length == 0) {\n                revert(\"BaseIndex: MINT_FAILED\");\n            } else {\n                assembly {\n                    revert(add(32, data), mload(data))\n                }\n            }\n        }\n    }\n\n    /// @inheritdoc IIndex\n    function burn(address _recipient) external override nonReentrant {\n        (bool success, bytes memory data) = IIndexRegistry(registry).indexLogic().delegatecall(\n            abi.encodeWithSelector(IIndexLogic.burn.selector, _recipient)\n        );\n        if (!success) {\n            if (data.length == 0) {\n                revert(\"BaseIndex: BURN_FAILED\");\n            } else {\n                assembly {\n                    revert(add(32, data), mload(data))\n                }\n            }\n        }\n    }\n\n    /// @inheritdoc IIndex\n    function anatomy() external view override returns (address[] memory _assets, uint8[] memory _weights) {\n        _assets = assets.values();\n        _weights = new uint8[](_assets.length);\n        for (uint i; i < _assets.length; ++i) {\n            _weights[i] = weightOf[_assets[i]];\n        }\n    }\n\n    /// @inheritdoc IIndex\n    function inactiveAnatomy() external view override returns (address[] memory _assets) {\n        _assets = inactiveAssets.values();\n    }\n\n    /// @inheritdoc ERC165\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return _interfaceId == type(IIndex).interfaceId || super.supportsInterface(_interfaceId);\n    }\n}"
    },
    {
      "filename": "contracts/ChainlinkPriceOracle.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity >=0.8.7;\n\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\";\n\nimport \"./libraries/FullMath.sol\";\nimport \"./libraries/FixedPoint112.sol\";\n\nimport \"./interfaces/IChainlinkPriceOracle.sol\";\n\n/// @title Chainlink price oracle\n/// @notice Contains logic for getting asset's price from Chainlink data feed\n/// @dev Oracle works through base asset which is set in initialize function\ncontract ChainlinkPriceOracle is IChainlinkPriceOracle, ERC165 {\n    using FullMath for uint;\n\n    struct AssetInfo {\n        AggregatorV2V3Interface aggregator;\n        uint8 answerDecimals;\n        uint8 decimals;\n        uint lastAssetPerBaseInUQ;\n    }\n\n    /// @notice Role allows configure asset related data/components\n    bytes32 private constant ASSET_MANAGER_ROLE = keccak256(\"ASSET_MANAGER_ROLE\");\n\n    /// @notice Index registry address\n    IAccessControl private immutable registry;\n\n    /// @notice Chainlink aggregator for the base asset\n    AggregatorV2V3Interface private immutable baseAggregator;\n\n    /// @notice Number of decimals in base asset answer\n    uint8 private immutable baseDecimals;\n\n    /// @notice Number of decimals in base asset answer\n    uint8 private immutable baseAnswerDecimals;\n\n    /// @notice Infos of added assets\n    mapping(address => AssetInfo) private assetInfoOf;\n\n    constructor(\n        address _registry,\n        address _base,\n        address _baseAggregator\n    ) {\n        require(_baseAggregator != address(0) && _base != address(0), \"ChainlinkPriceOracle: ZERO\");\n\n        registry = IAccessControl(_registry);\n        baseAnswerDecimals = AggregatorV2V3Interface(_baseAggregator).decimals();\n        baseDecimals = IERC20Metadata(_base).decimals();\n        baseAggregator = AggregatorV2V3Interface(_baseAggregator);\n    }\n\n    /// @inheritdoc IChainlinkPriceOracle\n    function addAsset(address _asset, address _assetAggregator) external override {\n        require(registry.hasRole(ASSET_MANAGER_ROLE, msg.sender), \"ChainlinkPriceOracle: FORBIDDEN\");\n        require(_asset != address(0), \"ChainlinkPriceOracle: ZERO\");\n\n        assetInfoOf[_asset] = AssetInfo({\n            aggregator: AggregatorV2V3Interface(_assetAggregator),\n            answerDecimals: AggregatorV2V3Interface(_assetAggregator).decimals(),\n            decimals: IERC20Metadata(_asset).decimals(),\n            lastAssetPerBaseInUQ: 0\n        });\n\n        refreshedAssetPerBaseInUQ(_asset);\n    }\n\n    /// @inheritdoc IPriceOracle\n    function lastAssetPerBaseInUQ(address _asset) external view override returns (uint) {\n        return assetInfoOf[_asset].lastAssetPerBaseInUQ;\n    }\n\n    /// @inheritdoc IPriceOracle\n    function refreshedAssetPerBaseInUQ(address _asset) public override returns (uint) {\n        AssetInfo storage assetInfo = assetInfoOf[_asset];\n\n        (, int basePrice, , , ) = baseAggregator.latestRoundData();\n        (, int quotePrice, , , ) = assetInfo.aggregator.latestRoundData();\n\n        require(basePrice > 0 && quotePrice > 0, \"ChainlinkPriceOracle: NEGATIVE\");\n\n        uint assetPerBaseInUQ = ((uint(basePrice) * 10**assetInfo.decimals).mulDiv(\n            FixedPoint112.Q112,\n            (uint(quotePrice) * 10**baseDecimals)\n        ) * 10**assetInfo.answerDecimals) / 10**baseAnswerDecimals;\n        assetInfo.lastAssetPerBaseInUQ = assetPerBaseInUQ;\n        return assetPerBaseInUQ;\n    }\n\n    /// @inheritdoc ERC165\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return\n            _interfaceId == type(IChainlinkPriceOracle).interfaceId ||\n            _interfaceId == type(IPriceOracle).interfaceId ||\n            super.supportsInterface(_interfaceId);\n    }\n}"
    },
    {
      "filename": "contracts/IndexLogic.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.8.7;\n\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\n\nimport \"./libraries/BP.sol\";\nimport \"./libraries/IndexLibrary.sol\";\n\nimport \"./interfaces/IvToken.sol\";\nimport \"./interfaces/IOrderer.sol\";\nimport \"./interfaces/IIndexLogic.sol\";\nimport \"./interfaces/IvTokenFactory.sol\";\nimport \"./interfaces/IPhuturePriceOracle.sol\";\n\nimport \"./PhutureIndex.sol\";\n\n/// @title Index logic\n/// @notice Contains common logic for index minting and burning\ncontract IndexLogic is PhutureIndex, IIndexLogic {\n    using FullMath for uint;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @notice Asset role\n    bytes32 internal constant ASSET_ROLE = keccak256(\"ASSET_ROLE\");\n    /// @notice Role granted for asset which should be skipped during burning\n    bytes32 internal constant SKIPPED_ASSET_ROLE = keccak256(\"SKIPPED_ASSET_ROLE\");\n\n    /// @notice Mints index to `_recipient` address\n    /// @param _recipient Recipient address\n    function mint(address _recipient) external override {\n        address feePool = IIndexRegistry(registry).feePool();\n        _chargeAUMFee(feePool);\n\n        IPhuturePriceOracle oracle = IPhuturePriceOracle(IIndexRegistry(registry).priceOracle());\n\n        uint lastAssetBalanceInBase;\n        uint minAmountInBase = type(uint).max;\n        for (uint i; i < assets.length(); ++i) {\n            require(IAccessControl(registry).hasRole(ASSET_ROLE, assets.at(i)), \"Index: INVALID_ASSET\");\n            if (weightOf[assets.at(i)] == 0) {\n                continue;\n            }\n            uint assetPerBaseInUQ = oracle.refreshedAssetPerBaseInUQ(assets.at(i));\n            // Q_b * w_i * p_i = Q_i\n            // Q_b = Q_i / (w_i * p_i)\n            IvToken vToken = IvToken(IvTokenFactory(vTokenFactory).createOrReturnVTokenOf(assets.at(i)));\n            uint amountInAsset = IERC20(assets.at(i)).balanceOf(address(vToken)) - vToken.lastBalance();\n            uint weightedPrice = assetPerBaseInUQ * weightOf[assets.at(i)];\n            uint _minAmountInBase = amountInAsset.mulDiv(FixedPoint112.Q112 * IndexLibrary.MAX_WEIGHT, weightedPrice);\n            if (_minAmountInBase < minAmountInBase) {\n                minAmountInBase = _minAmountInBase;\n            }\n            uint lastBalanceInAsset = vToken.lastAssetBalanceOf(address(this));\n            vToken.mint();\n            uint balanceInBase = lastBalanceInAsset.mulDiv(FixedPoint112.Q112, assetPerBaseInUQ);\n            lastAssetBalanceInBase += balanceInBase;\n        }\n\n        for (uint i; i < inactiveAssets.length(); ++i) {\n            if (!IAccessControl(registry).hasRole(SKIPPED_ASSET_ROLE, inactiveAssets.at(i))) {\n                uint lastBalanceInAsset = IvToken(\n                    IvTokenFactory(vTokenFactory).createOrReturnVTokenOf(inactiveAssets.at(i))\n                ).lastAssetBalanceOf(address(this));\n                lastAssetBalanceInBase += lastBalanceInAsset.mulDiv(\n                    FixedPoint112.Q112,\n                    oracle.refreshedAssetPerBaseInUQ(inactiveAssets.at(i))\n                );\n            }\n        }\n\n        assert(minAmountInBase != type(uint).max);\n\n        uint value;\n        if (totalSupply() != 0) {\n            require(lastAssetBalanceInBase > 0, \"Index: INSUFFICIENT_AMOUNT\");\n            value =\n                (oracle.convertToIndex(minAmountInBase, decimals()) * totalSupply()) /\n                oracle.convertToIndex(lastAssetBalanceInBase, decimals());\n        } else {\n            value = oracle.convertToIndex(minAmountInBase, decimals()) - IndexLibrary.INITIAL_QUANTITY;\n            _mint(address(0xdead), IndexLibrary.INITIAL_QUANTITY);\n        }\n\n        uint fee = (value * IFeePool(feePool).mintingFeeInBPOf(address(this))) / BP.DECIMAL_FACTOR;\n        if (fee > 0) {\n            _mint(feePool, fee);\n            value -= fee;\n        }\n\n        _mint(_recipient, value);\n    }\n\n    /// @notice Burns index and transfers assets to `_recipient` address\n    /// @param _recipient Recipient address\n    function burn(address _recipient) external override {\n        uint value = balanceOf(address(this));\n        require(value > 0, \"Index: INSUFFICIENT_AMOUNT\");\n        uint length = assets.length();\n\n        bool containsBlacklistedAssets;\n        for (uint i; i < length; ++i) {\n            if (!IAccessControl(registry).hasRole(ASSET_ROLE, assets.at(i))) {\n                containsBlacklistedAssets = true;\n                break;\n            }\n        }\n\n        if (!containsBlacklistedAssets) {\n            address feePool = IIndexRegistry(registry).feePool();\n\n            uint fee = (value * IFeePool(feePool).burningFeeInBPOf(address(this))) / BP.DECIMAL_FACTOR;\n\n            if (fee > 0) {\n                // AUM charged in _transfer method\n                _transfer(address(this), feePool, fee);\n                value -= fee;\n            } else {\n                _chargeAUMFee(feePool);\n            }\n        }\n\n        address orderer = IIndexRegistry(registry).orderer();\n        uint lastOrderId = IOrderer(orderer).lastOrderIdOf(address(this));\n        for (uint i; i < length + inactiveAssets.length(); ++i) {\n            address asset = i < length ? assets.at(i) : inactiveAssets.at(i - length);\n            if (containsBlacklistedAssets && IAccessControl(registry).hasRole(SKIPPED_ASSET_ROLE, asset)) {\n                continue;\n            }\n\n            IvToken vToken = IvToken(IvTokenFactory(vTokenFactory).vTokenOf(asset));\n            uint indexAssetBalance = vToken.balanceOf(address(this));\n            uint accountBalance = (value * indexAssetBalance) / totalSupply();\n            if (accountBalance == 0) {\n                continue;\n            }\n\n            // calculate index value in vault to be burned\n            vToken.transfer(address(vToken), accountBalance);\n            vToken.burn(_recipient);\n            if (lastOrderId > 0) {\n                IOrderer(orderer).reduceOrderAsset(asset, totalSupply() - value, totalSupply());\n            }\n        }\n\n        _burn(address(this), value);\n    }\n}"
    },
    {
      "filename": "contracts/IndexLogic.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.8.7;\n\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\n\nimport \"./libraries/BP.sol\";\nimport \"./libraries/IndexLibrary.sol\";\n\nimport \"./interfaces/IvToken.sol\";\nimport \"./interfaces/IOrderer.sol\";\nimport \"./interfaces/IIndexLogic.sol\";\nimport \"./interfaces/IvTokenFactory.sol\";\nimport \"./interfaces/IPhuturePriceOracle.sol\";\n\nimport \"./PhutureIndex.sol\";\n\n/// @title Index logic\n/// @notice Contains common logic for index minting and burning\ncontract IndexLogic is PhutureIndex, IIndexLogic {\n    using FullMath for uint;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @notice Asset role\n    bytes32 internal constant ASSET_ROLE = keccak256(\"ASSET_ROLE\");\n    /// @notice Role granted for asset which should be skipped during burning\n    bytes32 internal constant SKIPPED_ASSET_ROLE = keccak256(\"SKIPPED_ASSET_ROLE\");\n\n    /// @notice Mints index to `_recipient` address\n    /// @param _recipient Recipient address\n    function mint(address _recipient) external override {\n        address feePool = IIndexRegistry(registry).feePool();\n        _chargeAUMFee(feePool);\n\n        IPhuturePriceOracle oracle = IPhuturePriceOracle(IIndexRegistry(registry).priceOracle());\n\n        uint lastAssetBalanceInBase;\n        uint minAmountInBase = type(uint).max;\n        for (uint i; i < assets.length(); ++i) {\n            require(IAccessControl(registry).hasRole(ASSET_ROLE, assets.at(i)), \"Index: INVALID_ASSET\");\n            if (weightOf[assets.at(i)] == 0) {\n                continue;\n            }\n            uint assetPerBaseInUQ = oracle.refreshedAssetPerBaseInUQ(assets.at(i));\n            // Q_b * w_i * p_i = Q_i\n            // Q_b = Q_i / (w_i * p_i)\n            IvToken vToken = IvToken(IvTokenFactory(vTokenFactory).createOrReturnVTokenOf(assets.at(i)));\n            uint amountInAsset = IERC20(assets.at(i)).balanceOf(address(vToken)) - vToken.lastBalance();\n            uint weightedPrice = assetPerBaseInUQ * weightOf[assets.at(i)];\n            uint _minAmountInBase = amountInAsset.mulDiv(FixedPoint112.Q112 * IndexLibrary.MAX_WEIGHT, weightedPrice);\n            if (_minAmountInBase < minAmountInBase) {\n                minAmountInBase = _minAmountInBase;\n            }\n            uint lastBalanceInAsset = vToken.lastAssetBalanceOf(address(this));\n            vToken.mint();\n            uint balanceInBase = lastBalanceInAsset.mulDiv(FixedPoint112.Q112, assetPerBaseInUQ);\n            lastAssetBalanceInBase += balanceInBase;\n        }\n\n        for (uint i; i < inactiveAssets.length(); ++i) {\n            if (!IAccessControl(registry).hasRole(SKIPPED_ASSET_ROLE, inactiveAssets.at(i))) {\n                uint lastBalanceInAsset = IvToken(\n                    IvTokenFactory(vTokenFactory).createOrReturnVTokenOf(inactiveAssets.at(i))\n                ).lastAssetBalanceOf(address(this));\n                lastAssetBalanceInBase += lastBalanceInAsset.mulDiv(\n                    FixedPoint112.Q112,\n                    oracle.refreshedAssetPerBaseInUQ(inactiveAssets.at(i))\n                );\n            }\n        }\n\n        assert(minAmountInBase != type(uint).max);\n\n        uint value;\n        if (totalSupply() != 0) {\n            require(lastAssetBalanceInBase > 0, \"Index: INSUFFICIENT_AMOUNT\");\n            value =\n                (oracle.convertToIndex(minAmountInBase, decimals()) * totalSupply()) /\n                oracle.convertToIndex(lastAssetBalanceInBase, decimals());\n        } else {\n            value = oracle.convertToIndex(minAmountInBase, decimals()) - IndexLibrary.INITIAL_QUANTITY;\n            _mint(address(0xdead), IndexLibrary.INITIAL_QUANTITY);\n        }\n\n        uint fee = (value * IFeePool(feePool).mintingFeeInBPOf(address(this))) / BP.DECIMAL_FACTOR;\n        if (fee > 0) {\n            _mint(feePool, fee);\n            value -= fee;\n        }\n\n        _mint(_recipient, value);\n    }\n\n    /// @notice Burns index and transfers assets to `_recipient` address\n    /// @param _recipient Recipient address\n    function burn(address _recipient) external override {\n        uint value = balanceOf(address(this));\n        require(value > 0, \"Index: INSUFFICIENT_AMOUNT\");\n        uint length = assets.length();\n\n        bool containsBlacklistedAssets;\n        for (uint i; i < length; ++i) {\n            if (!IAccessControl(registry).hasRole(ASSET_ROLE, assets.at(i))) {\n                containsBlacklistedAssets = true;\n                break;\n            }\n        }\n\n        if (!containsBlacklistedAssets) {\n            address feePool = IIndexRegistry(registry).feePool();\n\n            uint fee = (value * IFeePool(feePool).burningFeeInBPOf(address(this))) / BP.DECIMAL_FACTOR;\n\n            if (fee > 0) {\n                // AUM charged in _transfer method\n                _transfer(address(this), feePool, fee);\n                value -= fee;\n            } else {\n                _chargeAUMFee(feePool);\n            }\n        }\n\n        address orderer = IIndexRegistry(registry).orderer();\n        uint lastOrderId = IOrderer(orderer).lastOrderIdOf(address(this));\n        for (uint i; i < length + inactiveAssets.length(); ++i) {\n            address asset = i < length ? assets.at(i) : inactiveAssets.at(i - length);\n            if (containsBlacklistedAssets && IAccessControl(registry).hasRole(SKIPPED_ASSET_ROLE, asset)) {\n                continue;\n            }\n\n            IvToken vToken = IvToken(IvTokenFactory(vTokenFactory).vTokenOf(asset));\n            uint indexAssetBalance = vToken.balanceOf(address(this));\n            uint accountBalance = (value * indexAssetBalance) / totalSupply();\n            if (accountBalance == 0) {\n                continue;\n            }\n\n            // calculate index value in vault to be burned\n            vToken.transfer(address(vToken), accountBalance);\n            vToken.burn(_recipient);\n            if (lastOrderId > 0) {\n                IOrderer(orderer).reduceOrderAsset(asset, totalSupply() - value, totalSupply());\n            }\n        }\n\n        _burn(address(this), value);\n    }\n}"
    },
    {
      "filename": "contracts/ManagedIndexReweightingLogic.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.8.7;\n\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nimport \"./libraries/IndexLibrary.sol\";\n\nimport \"./interfaces/IvToken.sol\";\nimport \"./interfaces/IOrderer.sol\";\nimport \"./interfaces/IvTokenFactory.sol\";\nimport \"./interfaces/IIndexRegistry.sol\";\nimport \"./interfaces/IManagedIndexReweightingLogic.sol\";\n\nimport \"./IndexLayout.sol\";\n\n/// @title ManagedIndex reweighting logic\n/// @notice Contains reweighting logic\ncontract ManagedIndexReweightingLogic is IndexLayout, IManagedIndexReweightingLogic, ERC165 {\n    using FullMath for uint;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @notice Asset role\n    bytes32 internal constant ASSET_ROLE = keccak256(\"ASSET_ROLE\");\n\n    /// @inheritdoc IManagedIndexReweightingLogic\n    function reweight(address[] calldata _updatedAssets, uint8[] calldata _updatedWeights) external override {\n        require(\n            _updatedAssets.length > 1 &&\n                _updatedWeights.length == _updatedAssets.length &&\n                _updatedAssets.length <= IIndexRegistry(registry).maxComponents(),\n            \"ManagedIndex: INVALID\"\n        );\n\n        uint virtualEvaluationInBase;\n        IPhuturePriceOracle oracle = IPhuturePriceOracle(IIndexRegistry(registry).priceOracle());\n        for (uint i; i < assets.length(); ++i) {\n            uint priceAssetPerBaseInUQ = oracle.refreshedAssetPerBaseInUQ(assets.at(i));\n            uint availableAssets = IvToken(IvTokenFactory(vTokenFactory).createOrReturnVTokenOf(assets.at(i)))\n                .assetBalanceOf(address(this));\n            virtualEvaluationInBase += availableAssets.mulDiv(FixedPoint112.Q112, priceAssetPerBaseInUQ);\n        }\n\n        IOrderer orderer = IOrderer(IIndexRegistry(registry).orderer());\n        uint orderId = orderer.placeOrder();\n\n        uint _totalWeight = IndexLibrary.MAX_WEIGHT;\n\n        for (uint i; i < _updatedAssets.length; ++i) {\n            address asset = _updatedAssets[i];\n            require(asset != address(0), \"ManagedIndex: ZERO\");\n\n            uint8 newWeight = _updatedWeights[i];\n\n            if (i > 0) {\n                // makes sure that there are no duplicate assets\n                require(_updatedAssets[i - 1] < asset, \"ManagedIndex: SORT\");\n            }\n\n            if (newWeight > 0) {\n                require(IAccessControl(registry).hasRole(ASSET_ROLE, asset), \"ManagedIndex: INVALID_ASSET\");\n                assets.add(asset);\n                inactiveAssets.remove(asset);\n\n                uint8 prevWeight = weightOf[asset];\n                if (prevWeight != newWeight) {\n                    emit UpdateAnatomy(asset, newWeight);\n                }\n\n                _totalWeight = _totalWeight + newWeight - prevWeight;\n                weightOf[asset] = newWeight;\n\n                uint amountInBase = (virtualEvaluationInBase * weightOf[asset]) / IndexLibrary.MAX_WEIGHT;\n                uint amountInAsset = amountInBase.mulDiv(oracle.refreshedAssetPerBaseInUQ(asset), FixedPoint112.Q112);\n                (uint newShares, uint oldShares) = IvToken(IvTokenFactory(vTokenFactory).createOrReturnVTokenOf(asset))\n                    .shareChange(address(this), amountInAsset);\n\n                if (newShares > oldShares) {\n                    orderer.addOrderDetails(orderId, asset, newShares - oldShares, IOrderer.OrderSide.Buy);\n                } else if (oldShares > newShares) {\n                    orderer.addOrderDetails(orderId, asset, oldShares - newShares, IOrderer.OrderSide.Sell);\n                }\n            } else {\n                require(assets.remove(asset), \"ManagedIndex: INVALID\");\n                inactiveAssets.add(asset);\n\n                _totalWeight -= weightOf[asset];\n\n                delete weightOf[asset];\n\n                emit UpdateAnatomy(asset, 0);\n            }\n        }\n        address[] memory _inactiveAssets = inactiveAssets.values();\n        for (uint i; i < _inactiveAssets.length; ++i) {\n            uint shares = IvToken(IvTokenFactory(vTokenFactory).vTokenOf(_inactiveAssets[i])).balanceOf(address(this));\n            if (shares > 0) {\n                orderer.addOrderDetails(orderId, _inactiveAssets[i], shares, IOrderer.OrderSide.Sell);\n            } else {\n                inactiveAssets.remove(_inactiveAssets[i]);\n            }\n        }\n        require(_totalWeight == IndexLibrary.MAX_WEIGHT, \"ManagedIndex: MAX\");\n    }\n\n    /// @inheritdoc ERC165\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return _interfaceId == type(IManagedIndexReweightingLogic).interfaceId || super.supportsInterface(_interfaceId);\n    }\n}"
    },
    {
      "filename": "contracts/PhuturePriceOracle.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.8.7;\n\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\n\nimport \"./libraries/FixedPoint112.sol\";\n\nimport \"./interfaces/IPriceOracle.sol\";\nimport \"./interfaces/IIndexRegistry.sol\";\nimport \"./interfaces/IPhuturePriceOracle.sol\";\n\n/// @title Phuture price oracle\n/// @notice Aggregates all price oracles and works with them through IPriceOracle interface\ncontract PhuturePriceOracle is IPhuturePriceOracle {\n    using ERC165Checker for address;\n\n    /// @notice Role allows configure asset related data/components\n    bytes32 private constant ASSET_MANAGER_ROLE = keccak256(\"ASSET_MANAGER_ROLE\");\n\n    /// @notice Base asset address\n    address public base;\n\n    /// @notice Index registry address\n    address public registry;\n\n    /// @inheritdoc IPhuturePriceOracle\n    mapping(address => address) public override priceOracleOf;\n\n    /// @notice Decimals of base asset\n    uint8 private baseDecimals;\n\n    /// @notice Requires msg.sender to have `_role` role\n    /// @param _role Required role\n    modifier onlyRole(bytes32 _role) {\n        require(IAccessControl(registry).hasRole(_role, msg.sender), \"PhuturePriceOracle: FORBIDDEN\");\n        _;\n    }\n\n    constructor(address _registry, address _base) {\n        bytes4[] memory interfaceIds = new bytes4[](2);\n        interfaceIds[0] = type(IAccessControl).interfaceId;\n        interfaceIds[1] = type(IIndexRegistry).interfaceId;\n        require(_registry.supportsAllInterfaces(interfaceIds), \"PhuturePriceOracle: INTERFACE\");\n        require(_base != address(0), \"PhuturePriceOracle: ZERO\");\n\n        base = _base;\n        baseDecimals = IERC20Metadata(_base).decimals();\n        registry = _registry;\n    }\n\n    /// @inheritdoc IPhuturePriceOracle\n    function setOracleOf(address _asset, address _oracle) external override onlyRole(ASSET_MANAGER_ROLE) {\n        require(_oracle.supportsInterface(type(IPriceOracle).interfaceId), \"PhuturePriceOracle: INTERFACE\");\n\n        priceOracleOf[_asset] = _oracle;\n    }\n\n    /// @inheritdoc IPhuturePriceOracle\n    function removeOracleOf(address _asset) external override onlyRole(ASSET_MANAGER_ROLE) {\n        require(priceOracleOf[_asset] != address(0), \"PhuturePriceOracle: UNSET\");\n        delete priceOracleOf[_asset];\n    }\n\n    /// @inheritdoc IPhuturePriceOracle\n    function convertToIndex(uint _baseAmount, uint8 _indexDecimals) external view override returns (uint) {\n        return (_baseAmount * 10**_indexDecimals) / 10**baseDecimals;\n    }\n\n    /// @inheritdoc IPhuturePriceOracle\n    function containsOracleOf(address _asset) external view override returns (bool) {\n        return priceOracleOf[_asset] != address(0) || _asset == base;\n    }\n\n    /// @inheritdoc IPriceOracle\n    function refreshedAssetPerBaseInUQ(address _asset) public override returns (uint) {\n        if (_asset == base) {\n            return FixedPoint112.Q112;\n        }\n\n        require(priceOracleOf[_asset] != address(0), \"PhuturePriceOracle: UNSET\");\n        return IPriceOracle(priceOracleOf[_asset]).refreshedAssetPerBaseInUQ(_asset);\n    }\n\n    /// @inheritdoc IPriceOracle\n    function lastAssetPerBaseInUQ(address _asset) public view override returns (uint) {\n        if (_asset == base) {\n            return FixedPoint112.Q112;\n        }\n\n        require(priceOracleOf[_asset] != address(0), \"PhuturePriceOracle: UNSET\");\n        return IPriceOracle(priceOracleOf[_asset]).lastAssetPerBaseInUQ(_asset);\n    }\n}"
    },
    {
      "filename": "contracts/TopNMarketCapIndex.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.8.7;\n\nimport \"./interfaces/IIndexFactory.sol\";\nimport \"./interfaces/IReweightableIndex.sol\";\nimport \"./interfaces/ITopNMarketCapIndexReweightingLogic.sol\";\n\nimport \"./BaseIndex.sol\";\n\n/// @title Top N market capitalization index\n/// @notice Contains initialization and reweighting logic\n/// @dev This index reweighs according to the latest data from the TopNMarketCapCategories contract\ncontract TopNMarketCapIndex is IReweightableIndex, BaseIndex {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @notice Orderer role\n    bytes32 internal constant ORDERER_ROLE = keccak256(\"ORDERER_ROLE\");\n\n    /// @notice Number of assets used in the index\n    uint8 public topN;\n    /// @notice Category identifier used for the given index\n    uint public category;\n\n    /// @notice Latest category snapshot to track diff\n    uint private snapshot;\n\n    constructor() BaseIndex(msg.sender) {}\n\n    /// @notice Initializes index with provided set of parameters\n    /// @param _topN Number of assets used in the index\n    /// @param _category Category identifier used for the given index\n    /// @param _snapshot Initial snapshot from the category\n    /// @param _assets Assets list\n    /// @param _capitalizations List of corresponding assets capitalizations\n    /// @param _totalCapitalization Total capitalization of assets\n    function initialize(\n        uint8 _topN,\n        uint _category,\n        uint _snapshot,\n        address[] calldata _assets,\n        uint[] calldata _capitalizations,\n        uint _totalCapitalization\n    ) external {\n        require(msg.sender == factory, \"TopNMarketCapIndex: FORBIDDEN\");\n\n        uint8 _totalWeight;\n        for (uint i; i < _assets.length; ++i) {\n            uint _i = _assets.length - 1 - i;\n            address asset = _assets[_i];\n            uint8 weight = _i == 0\n                ? IndexLibrary.MAX_WEIGHT - _totalWeight\n                : uint8((_capitalizations[_i] * type(uint8).max) / _totalCapitalization);\n            weightOf[asset] = weight;\n            require(asset != address(0), \"TopNMarketCapIndex: ZERO\");\n            if (weight > 0) {\n                assets.add(asset);\n                _totalWeight += weight;\n                emit UpdateAnatomy(asset, weight);\n            }\n        }\n        snapshot = _snapshot;\n        category = _category;\n        topN = _topN;\n    }\n\n    /// @notice Reweighs index assets according to the latest market cap data for specified category\n    function reweight() external override onlyRole(ORDERER_ROLE) {\n        (bool success, bytes memory data) = IIndexFactory(factory).reweightingLogic().delegatecall(\n            abi.encodeWithSelector(ITopNMarketCapIndexReweightingLogic.reweight.selector, category, snapshot, topN)\n        );\n        if (!success) {\n            if (data.length == 0) {\n                revert(\"TopNMarketCapIndex: REWEIGH_FAILED\");\n            } else {\n                assembly {\n                    revert(add(32, data), mload(data))\n                }\n            }\n        }\n        snapshot = abi.decode(data, (uint));\n    }\n\n    /// @inheritdoc ERC165\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return _interfaceId == type(IReweightableIndex).interfaceId || super.supportsInterface(_interfaceId);\n    }\n}"
    },
    {
      "filename": "contracts/TopNMarketCapReweightingLogic.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.8.7;\n\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nimport \"./libraries/IndexLibrary.sol\";\n\nimport \"./interfaces/IvToken.sol\";\nimport \"./interfaces/IOrderer.sol\";\nimport \"./interfaces/IvTokenFactory.sol\";\nimport \"./interfaces/IIndexRegistry.sol\";\nimport \"./interfaces/ITopNMarketCapCategories.sol\";\nimport \"./interfaces/ITopNMarketCapIndexFactory.sol\";\nimport \"./interfaces/ITopNMarketCapIndexReweightingLogic.sol\";\n\nimport \"./IndexLayout.sol\";\n\n/// @title TopNMarketCapIndex reweighing logic\n/// @notice Contains reweighting logic\ncontract TopNMarketCapIndexReweightingLogic is IndexLayout, ITopNMarketCapIndexReweightingLogic, ERC165 {\n    using FullMath for uint;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @notice Asset role\n    bytes32 internal constant ASSET_ROLE = keccak256(\"ASSET_ROLE\");\n\n    /// @inheritdoc ITopNMarketCapIndexReweightingLogic\n    function reweight(\n        uint _category,\n        uint _snapshotId,\n        uint _topN\n    ) external override returns (uint) {\n        IPhuturePriceOracle oracle = IPhuturePriceOracle(IIndexRegistry(registry).priceOracle());\n        uint virtualEvaluationInBase;\n        for (uint i; i < assets.length(); ++i) {\n            uint priceAssetPerBaseIn"
    }
  ]
}