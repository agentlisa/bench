{
  "Title": "Improper Bit-Length Validation in Reserve Configuration",
  "Content": "##### Description\n\nhttps://github.com/aave/protocol-v2/blob/f435b2fa0ac589852ca3dd6ae2b0fbfbc7079d54/contracts/libraries/configuration/ReserveConfiguration.sol#L46\n\nhttps://github.com/aave/protocol-v2/blob/f435b2fa0ac589852ca3dd6ae2b0fbfbc7079d54/contracts/libraries/configuration/ReserveConfiguration.sol#L63\n\nhttps://github.com/aave/protocol-v2/blob/f435b2fa0ac589852ca3dd6ae2b0fbfbc7079d54/contracts/libraries/configuration/ReserveConfiguration.sol#L84\n\nhttps://github.com/aave/protocol-v2/blob/f435b2fa0ac589852ca3dd6ae2b0fbfbc7079d54/contracts/libraries/configuration/ReserveConfiguration.sol#L106\n\nhttps://github.com/aave/protocol-v2/blob/f435b2fa0ac589852ca3dd6ae2b0fbfbc7079d54/contracts/libraries/configuration/ReserveConfiguration.sol#L128\n\nBit lengths of the provided values are not checked against bit lengths of the corresponding fields in the `data`.\n\nFor example, here\n\n```solidity\nfunction setLtv(ReserveConfiguration.Map memory self, uint256 ltv) internal pure {\n    self.data = (self.data & LTV_MASK) | ltv;\n```\n\nproviding a value greater than `65535` as `ltv` will result in a corruption of the liquidation threshold field. \n\n##### Recommendation\nWe recommend making sure that passed values fit in the corresponding fields.\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/libraries/configuration/ReserveConfiguration.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.6.8;\n\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {ReserveLogic} from '../logic/ReserveLogic.sol';\nimport {WadRayMath} from '../math/WadRayMath.sol';\nimport {IPriceOracleGetter} from '../../interfaces/IPriceOracleGetter.sol';\n\n/**\n * @title ReserveConfiguration library\n * @author Aave\n * @notice Implements the bitmap logic to handle the reserve configuration\n */\nlibrary ReserveConfiguration {\n  uint256 constant LTV_MASK = 0xFFFFFFFFFFFFFFFF0000;\n  uint256 constant LIQUIDATION_THRESHOLD_MASK = 0xFFFFFFFFFFFF0000FFFF;\n  uint256 constant LIQUIDATION_BONUS_MASK = 0xFFFFFFF0000FFFFFFFF;\n  uint256 constant DECIMALS_MASK = 0xFFFFFF00FFFFFFFFFFFF;\n  uint256 constant ACTIVE_MASK = 0xFFFFFEFFFFFFFFFFFFFF;\n  uint256 constant FROZEN_MASK = 0xFFFFFDFFFFFFFFFFFFFF;\n  uint256 constant BORROWING_MASK = 0xFFFFFBFFFFFFFFFFFFFF;\n  uint256 constant STABLE_BORROWING_MASK = 0xFFFF07FFFFFFFFFFFFFF;\n  uint256 constant RESERVE_FACTOR_MASK = 0xFFFFFFFFFFFFFFFF;\n\n  struct Map {\n    //bit 0-15: LTV\n    //bit 16-31: Liq. threshold\n    //bit 32-47: Liq. bonus\n    //bit 48-55: Decimals\n    //bit 56: Reserve is active\n    //bit 57: reserve is freezed\n    //bit 58: borrowing is enabled\n    //bit 59: stable rate borrowing enabled\n    //bit 64-79: reserve factor\n    uint256 data;\n  }\n\n  /**\n   * @dev sets the reserve factor of the reserve\n   * @param self the reserve configuration\n   * @param reserveFactor the reserve factor\n   **/\n  function setReserveFactor(ReserveConfiguration.Map memory self, uint256 reserveFactor) internal pure {\n \n    self.data = (self.data & RESERVE_FACTOR_MASK) | reserveFactor << 64;\n  }\n\n  /**\n   * @dev gets the reserve factor of the reserve\n   * @param self the reserve configuration\n   * @return the reserve factor\n   **/\n  function getReserveFactor(ReserveConfiguration.Map storage self) internal view returns (uint256) {\n    return (self.data & ~RESERVE_FACTOR_MASK) >> 64;\n  }\n  /**\n   * @dev sets the Loan to Value of the reserve\n   * @param self the reserve configuration\n   * @param ltv the new ltv\n   **/\n  function setLtv(ReserveConfiguration.Map memory self, uint256 ltv) internal pure {\n    self.data = (self.data & LTV_MASK) | ltv;\n  }\n\n  /**\n   * @dev gets the Loan to Value of the reserve\n   * @param self the reserve configuration\n   * @return the loan to value\n   **/\n  function getLtv(ReserveConfiguration.Map storage self) internal view returns (uint256) {\n    return self.data & ~LTV_MASK;\n  }\n\n  /**\n   * @dev sets the liquidation threshold of the reserve\n   * @param self the reserve configuration\n   * @param threshold the new liquidation threshold\n   **/\n  function setLiquidationThreshold(ReserveConfiguration.Map memory self, uint256 threshold)\n    internal\n    pure\n  {\n    self.data = (self.data & LIQUIDATION_THRESHOLD_MASK) | (threshold << 16);\n  }\n\n  /**\n   * @dev gets the Loan to Value of the reserve\n   * @param self the reserve configuration\n   * @return the liquidation threshold\n   **/\n  function getLiquidationThreshold(ReserveConfiguration.Map storage self)\n    internal\n    view\n    returns (uint256)\n  {\n    return (self.data & ~LIQUIDATION_THRESHOLD_MASK) >> 16;\n  }\n\n  /**\n   * @dev sets the liquidation bonus of the reserve\n   * @param self the reserve configuration\n   * @param bonus the new liquidation bonus\n   **/\n  function setLiquidationBonus(ReserveConfiguration.Map memory self, uint256 bonus) internal pure {\n    self.data = (self.data & LIQUIDATION_BONUS_MASK) | (bonus << 32);\n  }\n\n  /**\n   * @dev gets the liquidation bonus of the reserve\n   * @param self the reserve configuration\n   * @return the liquidation bonus\n   **/\n  function getLiquidationBonus(ReserveConfiguration.Map storage self)\n    internal\n    view\n    returns (uint256)\n  {\n    return (self.data & ~LIQUIDATION_BONUS_MASK) >> 32;\n  }\n\n  /**\n   * @dev sets the decimals of the underlying asset of the reserve\n   * @param self the reserve configuration\n   * @param decimals the decimals\n   **/\n  function setDecimals(ReserveConfiguration.Map memory self, uint256 decimals) internal pure {\n    self.data = (self.data & DECIMALS_MASK) | (decimals << 48);\n  }\n\n  /**\n   * @dev gets the decimals of the underlying asset of the reserve\n   * @param self the reserve configuration\n   * @return the decimals of the asset\n   **/\n  function getDecimals(ReserveConfiguration.Map storage self) internal view returns (uint256) {\n    return (self.data & ~DECIMALS_MASK) >> 48;\n  }\n\n  /**\n   * @dev sets the active state of the reserve\n   * @param self the reserve configuration\n   * @param active the active state\n   **/\n  function setActive(ReserveConfiguration.Map memory self, bool active) internal pure {\n    self.data = (self.data & ACTIVE_MASK) | (uint256(active ? 1 : 0) << 56);\n  }\n\n  /**\n   * @dev gets the active state of the reserve\n   * @param self the reserve configuration\n   * @return the active state\n   **/\n  function getActive(ReserveConfiguration.Map storage self) internal view returns (bool) {\n    return ((self.data & ~ACTIVE_MASK) >> 56) != 0;\n  }\n\n  /**\n   * @dev sets the frozen state of the reserve\n   * @param self the reserve configuration\n   * @param frozen the frozen state\n   **/\n  function setFrozen(ReserveConfiguration.Map memory self, bool frozen) internal pure {\n    self.data = (self.data & FROZEN_MASK) | (uint256(frozen ? 1 : 0) << 57);\n  }\n\n  /**\n   * @dev gets the frozen state of the reserve\n   * @param self the reserve configuration\n   * @return the frozen state\n   **/\n  function getFrozen(ReserveConfiguration.Map storage self) internal view returns (bool) {\n    return ((self.data & ~FROZEN_MASK) >> 57) != 0;\n  }\n\n  /**\n   * @dev enables or disables borrowing on the reserve\n   * @param self the reserve configuration\n   * @param enabled true if the borrowing needs to be enabled, false otherwise\n   **/\n  function setBorrowingEnabled(ReserveConfiguration.Map memory self, bool enabled) internal pure {\n    self.data = (self.data & BORROWING_MASK) | (uint256(enabled ? 1 : 0) << 58);\n  }\n\n  /**\n   * @dev gets the borrowing state of the reserve\n   * @param self the reserve configuration\n   * @return the borrowing state\n   **/\n  function getBorrowingEnabled(ReserveConfiguration.Map storage self) internal view returns (bool) {\n    return ((self.data & ~BORROWING_MASK) >> 58) != 0;\n  }\n\n  /**\n   * @dev enables or disables stable rate borrowing on the reserve\n   * @param self the reserve configuration\n   * @param enabled true if the stable rate borrowing needs to be enabled, false otherwise\n   **/\n  function setStableRateBorrowingEnabled(ReserveConfiguration.Map memory self, bool enabled)\n    internal pure\n  {\n    self.data = (self.data & STABLE_BORROWING_MASK) | (uint256(enabled ? 1 : 0) << 59);\n  }\n\n  /**\n   * @dev gets the stable rate borrowing state of the reserve\n   * @param self the reserve configuration\n   * @return the stable rate borrowing state\n   **/\n  function getStableRateBorrowingEnabled(ReserveConfiguration.Map storage self)\n    internal\n    view\n    returns (bool)\n  {\n    return ((self.data & ~STABLE_BORROWING_MASK) >> 59) != 0;\n  }\n\n  /**\n   * @dev gets the configuration flags of the reserve\n   * @param self the reserve configuration\n   * @return the state flags representing active, freezed, borrowing enabled, stableRateBorrowing enabled\n   **/\n  function getFlags(ReserveConfiguration.Map storage self)\n    internal\n    view\n    returns (\n      bool,\n      bool,\n      bool,\n      bool\n    )\n  {\n    uint256 dataLocal = self.data;\n\n    return (\n      (dataLocal & ~ACTIVE_MASK) >> 56 != 0,\n      (dataLocal & ~FROZEN_MASK) >> 57 != 0,\n      (dataLocal & ~BORROWING_MASK) >> 58 != 0,\n      (dataLocal & ~STABLE_BORROWING_MASK) >> 59 != 0\n    );\n  }\n\n  /**\n   * @dev gets the configuration paramters of the reserve\n   * @param self the reserve configuration\n   * @return the state params representing ltv, liquidation threshold, liquidation bonus, the reserve decimals\n   **/\n  function getParams(ReserveConfiguration.Map storage self)\n    internal\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    uint256 dataLocal = self.data;\n\n    return (\n      dataLocal & ~LTV_MASK,\n      (dataLocal & ~LIQUIDATION_THRESHOLD_MASK) >> 16,\n      (dataLocal & ~LIQUIDATION_BONUS_MASK) >> 32,\n      (dataLocal & ~DECIMALS_MASK) >> 48\n    );\n  }\n}"
    },
    {
      "filename": "contracts/libraries/configuration/ReserveConfiguration.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.6.8;\n\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {ReserveLogic} from '../logic/ReserveLogic.sol';\nimport {WadRayMath} from '../math/WadRayMath.sol';\nimport {IPriceOracleGetter} from '../../interfaces/IPriceOracleGetter.sol';\n\n/**\n * @title ReserveConfiguration library\n * @author Aave\n * @notice Implements the bitmap logic to handle the reserve configuration\n */\nlibrary ReserveConfiguration {\n  uint256 constant LTV_MASK = 0xFFFFFFFFFFFFFFFF0000;\n  uint256 constant LIQUIDATION_THRESHOLD_MASK = 0xFFFFFFFFFFFF0000FFFF;\n  uint256 constant LIQUIDATION_BONUS_MASK = 0xFFFFFFF0000FFFFFFFF;\n  uint256 constant DECIMALS_MASK = 0xFFFFFF00FFFFFFFFFFFF;\n  uint256 constant ACTIVE_MASK = 0xFFFFFEFFFFFFFFFFFFFF;\n  uint256 constant FROZEN_MASK = 0xFFFFFDFFFFFFFFFFFFFF;\n  uint256 constant BORROWING_MASK = 0xFFFFFBFFFFFFFFFFFFFF;\n  uint256 constant STABLE_BORROWING_MASK = 0xFFFF07FFFFFFFFFFFFFF;\n  uint256 constant RESERVE_FACTOR_MASK = 0xFFFFFFFFFFFFFFFF;\n\n  struct Map {\n    //bit 0-15: LTV\n    //bit 16-31: Liq. threshold\n    //bit 32-47: Liq. bonus\n    //bit 48-55: Decimals\n    //bit 56: Reserve is active\n    //bit 57: reserve is freezed\n    //bit 58: borrowing is enabled\n    //bit 59: stable rate borrowing enabled\n    //bit 64-79: reserve factor\n    uint256 data;\n  }\n\n  /**\n   * @dev sets the reserve factor of the reserve\n   * @param self the reserve configuration\n   * @param reserveFactor the reserve factor\n   **/\n  function setReserveFactor(ReserveConfiguration.Map memory self, uint256 reserveFactor) internal pure {\n \n    self.data = (self.data & RESERVE_FACTOR_MASK) | reserveFactor << 64;\n  }\n\n  /**\n   * @dev gets the reserve factor of the reserve\n   * @param self the reserve configuration\n   * @return the reserve factor\n   **/\n  function getReserveFactor(ReserveConfiguration.Map storage self) internal view returns (uint256) {\n    return (self.data & ~RESERVE_FACTOR_MASK) >> 64;\n  }\n  /**\n   * @dev sets the Loan to Value of the reserve\n   * @param self the reserve configuration\n   * @param ltv the new ltv\n   **/\n  function setLtv(ReserveConfiguration.Map memory self, uint256 ltv) internal pure {\n    self.data = (self.data & LTV_MASK) | ltv;\n  }\n\n  /**\n   * @dev gets the Loan to Value of the reserve\n   * @param self the reserve configuration\n   * @return the loan to value\n   **/\n  function getLtv(ReserveConfiguration.Map storage self) internal view returns (uint256) {\n    return self.data & ~LTV_MASK;\n  }\n\n  /**\n   * @dev sets the liquidation threshold of the reserve\n   * @param self the reserve configuration\n   * @param threshold the new liquidation threshold\n   **/\n  function setLiquidationThreshold(ReserveConfiguration.Map memory self, uint256 threshold)\n    internal\n    pure\n  {\n    self.data = (self.data & LIQUIDATION_THRESHOLD_MASK) | (threshold << 16);\n  }\n\n  /**\n   * @dev gets the Loan to Value of the reserve\n   * @param self the reserve configuration\n   * @return the liquidation threshold\n   **/\n  function getLiquidationThreshold(ReserveConfiguration.Map storage self)\n    internal\n    view\n    returns (uint256)\n  {\n    return (self.data & ~LIQUIDATION_THRESHOLD_MASK) >> 16;\n  }\n\n  /**\n   * @dev sets the liquidation bonus of the reserve\n   * @param self the reserve configuration\n   * @param bonus the new liquidation bonus\n   **/\n  function setLiquidationBonus(ReserveConfiguration.Map memory self, uint256 bonus) internal pure {\n    self.data = (self.data & LIQUIDATION_BONUS_MASK) | (bonus << 32);\n  }\n\n  /**\n   * @dev gets the liquidation bonus of the reserve\n   * @param self the reserve configuration\n   * @return the liquidation bonus\n   **/\n  function getLiquidationBonus(ReserveConfiguration.Map storage self)\n    internal\n    view\n    returns (uint256)\n  {\n    return (self.data & ~LIQUIDATION_BONUS_MASK) >> 32;\n  }\n\n  /**\n   * @dev sets the decimals of the underlying asset of the reserve\n   * @param self the reserve configuration\n   * @param decimals the decimals\n   **/\n  function setDecimals(ReserveConfiguration.Map memory self, uint256 decimals) internal pure {\n    self.data = (self.data & DECIMALS_MASK) | (decimals << 48);\n  }\n\n  /**\n   * @dev gets the decimals of the underlying asset of the reserve\n   * @param self the reserve configuration\n   * @return the decimals of the asset\n   **/\n  function getDecimals(ReserveConfiguration.Map storage self) internal view returns (uint256) {\n    return (self.data & ~DECIMALS_MASK) >> 48;\n  }\n\n  /**\n   * @dev sets the active state of the reserve\n   * @param self the reserve configuration\n   * @param active the active state\n   **/\n  function setActive(ReserveConfiguration.Map memory self, bool active) internal pure {\n    self.data = (self.data & ACTIVE_MASK) | (uint256(active ? 1 : 0) << 56);\n  }\n\n  /**\n   * @dev gets the active state of the reserve\n   * @param self the reserve configuration\n   * @return the active state\n   **/\n  function getActive(ReserveConfiguration.Map storage self) internal view returns (bool) {\n    return ((self.data & ~ACTIVE_MASK) >> 56) != 0;\n  }\n\n  /**\n   * @dev sets the frozen state of the reserve\n   * @param self the reserve configuration\n   * @param frozen the frozen state\n   **/\n  function setFrozen(ReserveConfiguration.Map memory self, bool frozen) internal pure {\n    self.data = (self.data & FROZEN_MASK) | (uint256(frozen ? 1 : 0) << 57);\n  }\n\n  /**\n   * @dev gets the frozen state of the reserve\n   * @param self the reserve configuration\n   * @return the frozen state\n   **/\n  function getFrozen(ReserveConfiguration.Map storage self) internal view returns (bool) {\n    return ((self.data & ~FROZEN_MASK) >> 57) != 0;\n  }\n\n  /**\n   * @dev enables or disables borrowing on the reserve\n   * @param self the reserve configuration\n   * @param enabled true if the borrowing needs to be enabled, false otherwise\n   **/\n  function setBorrowingEnabled(ReserveConfiguration.Map memory self, bool enabled) internal pure {\n    self.data = (self.data & BORROWING_MASK) | (uint256(enabled ? 1 : 0) << 58);\n  }\n\n  /**\n   * @dev gets the borrowing state of the reserve\n   * @param self the reserve configuration\n   * @return the borrowing state\n   **/\n  function getBorrowingEnabled(ReserveConfiguration.Map storage self) internal view returns (bool) {\n    return ((self.data & ~BORROWING_MASK) >> 58) != 0;\n  }\n\n  /**\n   * @dev enables or disables stable rate borrowing on the reserve\n   * @param self the reserve configuration\n   * @param enabled true if the stable rate borrowing needs to be enabled, false otherwise\n   **/\n  function setStableRateBorrowingEnabled(ReserveConfiguration.Map memory self, bool enabled)\n    internal pure\n  {\n    self.data = (self.data & STABLE_BORROWING_MASK) | (uint256(enabled ? 1 : 0) << 59);\n  }\n\n  /**\n   * @dev gets the stable rate borrowing state of the reserve\n   * @param self the reserve configuration\n   * @return the stable rate borrowing state\n   **/\n  function getStableRateBorrowingEnabled(ReserveConfiguration.Map storage self)\n    internal\n    view\n    returns (bool)\n  {\n    return ((self.data & ~STABLE_BORROWING_MASK) >> 59) != 0;\n  }\n\n  /**\n   * @dev gets the configuration flags of the reserve\n   * @param self the reserve configuration\n   * @return the state flags representing active, freezed, borrowing enabled, stableRateBorrowing enabled\n   **/\n  function getFlags(ReserveConfiguration.Map storage self)\n    internal\n    view\n    returns (\n      bool,\n      bool,\n      bool,\n      bool\n    )\n  {\n    uint256 dataLocal = self.data;\n\n    return (\n      (dataLocal & ~ACTIVE_MASK) >> 56 != 0,\n      (dataLocal & ~FROZEN_MASK) >> 57 != 0,\n      (dataLocal & ~BORROWING_MASK) >> 58 != 0,\n      (dataLocal & ~STABLE_BORROWING_MASK) >> 59 != 0\n    );\n  }\n\n  /**\n   * @dev gets the configuration paramters of the reserve\n   * @param self the reserve configuration\n   * @return the state params representing ltv, liquidation threshold, liquidation bonus, the reserve decimals\n   **/\n  function getParams(ReserveConfiguration.Map storage self)\n    internal\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    uint256 dataLocal = self.data;\n\n    return (\n      dataLocal & ~LTV_MASK,\n      (dataLocal & ~LIQUIDATION_THRESHOLD_MASK) >> 16,\n      (dataLocal & ~LIQUIDATION_BONUS_MASK) >> 32,\n      (dataLocal & ~DECIMALS_MASK) >> 48\n    );\n  }\n}"
    },
    {
      "filename": "contracts/libraries/configuration/ReserveConfiguration.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.6.8;\n\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {ReserveLogic} from '../logic/ReserveLogic.sol';\nimport {WadRayMath} from '../math/WadRayMath.sol';\nimport {IPriceOracleGetter} from '../../interfaces/IPriceOracleGetter.sol';\n\n/**\n * @title ReserveConfiguration library\n * @author Aave\n * @notice Implements the bitmap logic to handle the reserve configuration\n */\nlibrary ReserveConfiguration {\n  uint256 constant LTV_MASK = 0xFFFFFFFFFFFFFFFF0000;\n  uint256 constant LIQUIDATION_THRESHOLD_MASK = 0xFFFFFFFFFFFF0000FFFF;\n  uint256 constant LIQUIDATION_BONUS_MASK = 0xFFFFFFF0000FFFFFFFF;\n  uint256 constant DECIMALS_MASK = 0xFFFFFF00FFFFFFFFFFFF;\n  uint256 constant ACTIVE_MASK = 0xFFFFFEFFFFFFFFFFFFFF;\n  uint256 constant FROZEN_MASK = 0xFFFFFDFFFFFFFFFFFFFF;\n  uint256 constant BORROWING_MASK = 0xFFFFFBFFFFFFFFFFFFFF;\n  uint256 constant STABLE_BORROWING_MASK = 0xFFFF07FFFFFFFFFFFFFF;\n  uint256 constant RESERVE_FACTOR_MASK = 0xFFFFFFFFFFFFFFFF;\n\n  struct Map {\n    //bit 0-15: LTV\n    //bit 16-31: Liq. threshold\n    //bit 32-47: Liq. bonus\n    //bit 48-55: Decimals\n    //bit 56: Reserve is active\n    //bit 57: reserve is freezed\n    //bit 58: borrowing is enabled\n    //bit 59: stable rate borrowing enabled\n    //bit 64-79: reserve factor\n    uint256 data;\n  }\n\n  /**\n   * @dev sets the reserve factor of the reserve\n   * @param self the reserve configuration\n   * @param reserveFactor the reserve factor\n   **/\n  function setReserveFactor(ReserveConfiguration.Map memory self, uint256 reserveFactor) internal pure {\n \n    self.data = (self.data & RESERVE_FACTOR_MASK) | reserveFactor << 64;\n  }\n\n  /**\n   * @dev gets the reserve factor of the reserve\n   * @param self the reserve configuration\n   * @return the reserve factor\n   **/\n  function getReserveFactor(ReserveConfiguration.Map storage self) internal view returns (uint256) {\n    return (self.data & ~RESERVE_FACTOR_MASK) >> 64;\n  }\n  /**\n   * @dev sets the Loan to Value of the reserve\n   * @param self the reserve configuration\n   * @param ltv the new ltv\n   **/\n  function setLtv(ReserveConfiguration.Map memory self, uint256 ltv) internal pure {\n    self.data = (self.data & LTV_MASK) | ltv;\n  }\n\n  /**\n   * @dev gets the Loan to Value of the reserve\n   * @param self the reserve configuration\n   * @return the loan to value\n   **/\n  function getLtv(ReserveConfiguration.Map storage self) internal view returns (uint256) {\n    return self.data & ~LTV_MASK;\n  }\n\n  /**\n   * @dev sets the liquidation threshold of the reserve\n   * @param self the reserve configuration\n   * @param threshold the new liquidation threshold\n   **/\n  function setLiquidationThreshold(ReserveConfiguration.Map memory self, uint256 threshold)\n    internal\n    pure\n  {\n    self.data = (self.data & LIQUIDATION_THRESHOLD_MASK) | (threshold << 16);\n  }\n\n  /**\n   * @dev gets the Loan to Value of the reserve\n   * @param self the reserve configuration\n   * @return the liquidation threshold\n   **/\n  function getLiquidationThreshold(ReserveConfiguration.Map storage self)\n    internal\n    view\n    returns (uint256)\n  {\n    return (self.data & ~LIQUIDATION_THRESHOLD_MASK) >> 16;\n  }\n\n  /**\n   * @dev sets the liquidation bonus of the reserve\n   * @param self the reserve configuration\n   * @param bonus the new liquidation bonus\n   **/\n  function setLiquidationBonus(ReserveConfiguration.Map memory self, uint256 bonus) internal pure {\n    self.data = (self.data & LIQUIDATION_BONUS_MASK) | (bonus << 32);\n  }\n\n  /**\n   * @dev gets the liquidation bonus of the reserve\n   * @param self the reserve configuration\n   * @return the liquidation bonus\n   **/\n  function getLiquidationBonus(ReserveConfiguration.Map storage self)\n    internal\n    view\n    returns (uint256)\n  {\n    return (self.data & ~LIQUIDATION_BONUS_MASK) >> 32;\n  }\n\n  /**\n   * @dev sets the decimals of the underlying asset of the reserve\n   * @param self the reserve configuration\n   * @param decimals the decimals\n   **/\n  function setDecimals(ReserveConfiguration.Map memory self, uint256 decimals) internal pure {\n    self.data = (self.data & DECIMALS_MASK) | (decimals << 48);\n  }\n\n  /**\n   * @dev gets the decimals of the underlying asset of the reserve\n   * @param self the reserve configuration\n   * @return the decimals of the asset\n   **/\n  function getDecimals(ReserveConfiguration.Map storage self) internal view returns (uint256) {\n    return (self.data & ~DECIMALS_MASK) >> 48;\n  }\n\n  /**\n   * @dev sets the active state of the reserve\n   * @param self the reserve configuration\n   * @param active the active state\n   **/\n  function setActive(ReserveConfiguration.Map memory self, bool active) internal pure {\n    self.data = (self.data & ACTIVE_MASK) | (uint256(active ? 1 : 0) << 56);\n  }\n\n  /**\n   * @dev gets the active state of the reserve\n   * @param self the reserve configuration\n   * @return the active state\n   **/\n  function getActive(ReserveConfiguration.Map storage self) internal view returns (bool) {\n    return ((self.data & ~ACTIVE_MASK) >> 56) != 0;\n  }\n\n  /**\n   * @dev sets the frozen state of the reserve\n   * @param self the reserve configuration\n   * @param frozen the frozen state\n   **/\n  function setFrozen(ReserveConfiguration.Map memory self, bool frozen) internal pure {\n    self.data = (self.data & FROZEN_MASK) | (uint256(frozen ? 1 : 0) << 57);\n  }\n\n  /**\n   * @dev gets the frozen state of the reserve\n   * @param self the reserve configuration\n   * @return the frozen state\n   **/\n  function getFrozen(ReserveConfiguration.Map storage self) internal view returns (bool) {\n    return ((self.data & ~FROZEN_MASK) >> 57) != 0;\n  }\n\n  /**\n   * @dev enables or disables borrowing on the reserve\n   * @param self the reserve configuration\n   * @param enabled true if the borrowing needs to be enabled, false otherwise\n   **/\n  function setBorrowingEnabled(ReserveConfiguration.Map memory self, bool enabled) internal pure {\n    self.data = (self.data & BORROWING_MASK) | (uint256(enabled ? 1 : 0) << 58);\n  }\n\n  /**\n   * @dev gets the borrowing state of the reserve\n   * @param self the reserve configuration\n   * @return the borrowing state\n   **/\n  function getBorrowingEnabled(ReserveConfiguration.Map storage self) internal view returns (bool) {\n    return ((self.data & ~BORROWING_MASK) >> 58) != 0;\n  }\n\n  /**\n   * @dev enables or disables stable rate borrowing on the reserve\n   * @param self the reserve configuration\n   * @param enabled true if the stable rate borrowing needs to be enabled, false otherwise\n   **/\n  function setStableRateBorrowingEnabled(ReserveConfiguration.Map memory self, bool enabled)\n    internal pure\n  {\n    self.data = (self.data & STABLE_BORROWING_MASK) | (uint256(enabled ? 1 : 0) << 59);\n  }\n\n  /**\n   * @dev gets the stable rate borrowing state of the reserve\n   * @param self the reserve configuration\n   * @return the stable rate borrowing state\n   **/\n  function getStableRateBorrowingEnabled(ReserveConfiguration.Map storage self)\n    internal\n    view\n    returns (bool)\n  {\n    return ((self.data & ~STABLE_BORROWING_MASK) >> 59) != 0;\n  }\n\n  /**\n   * @dev gets the configuration flags of the reserve\n   * @param self the reserve configuration\n   * @return the state flags representing active, freezed, borrowing enabled, stableRateBorrowing enabled\n   **/\n  function getFlags(ReserveConfiguration.Map storage self)\n    internal\n    view\n    returns (\n      bool,\n      bool,\n      bool,\n      bool\n    )\n  {\n    uint256 dataLocal = self.data;\n\n    return (\n      (dataLocal & ~ACTIVE_MASK) >> 56 != 0,\n      (dataLocal & ~FROZEN_MASK) >> 57 != 0,\n      (dataLocal & ~BORROWING_MASK) >> 58 != 0,\n      (dataLocal & ~STABLE_BORROWING_MASK) >> 59 != 0\n    );\n  }\n\n  /**\n   * @dev gets the configuration paramters of the reserve\n   * @param self the reserve configuration\n   * @return the state params representing ltv, liquidation threshold, liquidation bonus, the reserve decimals\n   **/\n  function getParams(ReserveConfiguration.Map storage self)\n    internal\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    uint256 dataLocal = self.data;\n\n    return (\n      dataLocal & ~LTV_MASK,\n      (dataLocal & ~LIQUIDATION_THRESHOLD_MASK) >> 16,\n      (dataLocal & ~LIQUIDATION_BONUS_MASK) >> 32,\n      (dataLocal & ~DECIMALS_MASK) >> 48\n    );\n  }\n}"
    },
    {
      "filename": "contracts/libraries/configuration/ReserveConfiguration.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.6.8;\n\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {ReserveLogic} from '../logic/ReserveLogic.sol';\nimport {WadRayMath} from '../math/WadRayMath.sol';\nimport {IPriceOracleGetter} from '../../interfaces/IPriceOracleGetter.sol';\n\n/**\n * @title ReserveConfiguration library\n * @author Aave\n * @notice Implements the bitmap logic to handle the reserve configuration\n */\nlibrary ReserveConfiguration {\n  uint256 constant LTV_MASK = 0xFFFFFFFFFFFFFFFF0000;\n  uint256 constant LIQUIDATION_THRESHOLD_MASK = 0xFFFFFFFFFFFF0000FFFF;\n  uint256 constant LIQUIDATION_BONUS_MASK = 0xFFFFFFF0000FFFFFFFF;\n  uint256 constant DECIMALS_MASK = 0xFFFFFF00FFFFFFFFFFFF;\n  uint256 constant ACTIVE_MASK = 0xFFFFFEFFFFFFFFFFFFFF;\n  uint256 constant FROZEN_MASK = 0xFFFFFDFFFFFFFFFFFFFF;\n  uint256 constant BORROWING_MASK = 0xFFFFFBFFFFFFFFFFFFFF;\n  uint256 constant STABLE_BORROWING_MASK = 0xFFFF07FFFFFFFFFFFFFF;\n  uint256 constant RESERVE_FACTOR_MASK = 0xFFFFFFFFFFFFFFFF;\n\n  struct Map {\n    //bit 0-15: LTV\n    //bit 16-31: Liq. threshold\n    //bit 32-47: Liq. bonus\n    //bit 48-55: Decimals\n    //bit 56: Reserve is active\n    //bit 57: reserve is freezed\n    //bit 58: borrowing is enabled\n    //bit 59: stable rate borrowing enabled\n    //bit 64-79: reserve factor\n    uint256 data;\n  }\n\n  /**\n   * @dev sets the reserve factor of the reserve\n   * @param self the reserve configuration\n   * @param reserveFactor the reserve factor\n   **/\n  function setReserveFactor(ReserveConfiguration.Map memory self, uint256 reserveFactor) internal pure {\n \n    self.data = (self.data & RESERVE_FACTOR_MASK) | reserveFactor << 64;\n  }\n\n  /**\n   * @dev gets the reserve factor of the reserve\n   * @param self the reserve configuration\n   * @return the reserve factor\n   **/\n  function getReserveFactor(ReserveConfiguration.Map storage self) internal view returns (uint256) {\n    return (self.data & ~RESERVE_FACTOR_MASK) >> 64;\n  }\n  /**\n   * @dev sets the Loan to Value of the reserve\n   * @param self the reserve configuration\n   * @param ltv the new ltv\n   **/\n  function setLtv(ReserveConfiguration.Map memory self, uint256 ltv) internal pure {\n    self.data = (self.data & LTV_MASK) | ltv;\n  }\n\n  /**\n   * @dev gets the Loan to Value of the reserve\n   * @param self the reserve configuration\n   * @return the loan to value\n   **/\n  function getLtv(ReserveConfiguration.Map storage self) internal view returns (uint256) {\n    return self.data & ~LTV_MASK;\n  }\n\n  /**\n   * @dev sets the liquidation threshold of the reserve\n   * @param self the reserve configuration\n   * @param threshold the new liquidation threshold\n   **/\n  function setLiquidationThreshold(ReserveConfiguration.Map memory self, uint256 threshold)\n    internal\n    pure\n  {\n    self.data = (self.data & LIQUIDATION_THRESHOLD_MASK) | (threshold << 16);\n  }\n\n  /**\n   * @dev gets the Loan to Value of the reserve\n   * @param self the reserve configuration\n   * @return the liquidation threshold\n   **/\n  function getLiquidationThreshold(ReserveConfiguration.Map storage self)\n    internal\n    view\n    returns (uint256)\n  {\n    return (self.data & ~LIQUIDATION_THRESHOLD_MASK) >> 16;\n  }\n\n  /**\n   * @dev sets the liquidation bonus of the reserve\n   * @param self the reserve configuration\n   * @param bonus the new liquidation bonus\n   **/\n  function setLiquidationBonus(ReserveConfiguration.Map memory self, uint256 bonus) internal pure {\n    self.data = (self.data & LIQUIDATION_BONUS_MASK) | (bonus << 32);\n  }\n\n  /**\n   * @dev gets the liquidation bonus of the reserve\n   * @param self the reserve configuration\n   * @return the liquidation bonus\n   **/\n  function getLiquidationBonus(ReserveConfiguration.Map storage self)\n    internal\n    view\n    returns (uint256)\n  {\n    return (self.data & ~LIQUIDATION_BONUS_MASK) >> 32;\n  }\n\n  /**\n   * @dev sets the decimals of the underlying asset of the reserve\n   * @param self the reserve configuration\n   * @param decimals the decimals\n   **/\n  function setDecimals(ReserveConfiguration.Map memory self, uint256 decimals) internal pure {\n    self.data = (self.data & DECIMALS_MASK) | (decimals << 48);\n  }\n\n  /**\n   * @dev gets the decimals of the underlying asset of the reserve\n   * @param self the reserve configuration\n   * @return the decimals of the asset\n   **/\n  function getDecimals(ReserveConfiguration.Map storage self) internal view returns (uint256) {\n    return (self.data & ~DECIMALS_MASK) >> 48;\n  }\n\n  /**\n   * @dev sets the active state of the reserve\n   * @param self the reserve configuration\n   * @param active the active state\n   **/\n  function setActive(ReserveConfiguration.Map memory self, bool active) internal pure {\n    self.data = (self.data & ACTIVE_MASK) | (uint256(active ? 1 : 0) << 56);\n  }\n\n  /**\n   * @dev gets the active state of the reserve\n   * @param self the reserve configuration\n   * @return the active state\n   **/\n  function getActive(ReserveConfiguration.Map storage self) internal view returns (bool) {\n    return ((self.data & ~ACTIVE_MASK) >> 56) != 0;\n  }\n\n  /**\n   * @dev sets the frozen state of the reserve\n   * @param self the reserve configuration\n   * @param frozen the frozen state\n   **/\n  function setFrozen(ReserveConfiguration.Map memory self, bool frozen) internal pure {\n    self.data = (self.data & FROZEN_MASK) | (uint256(frozen ? 1 : 0) << 57);\n  }\n\n  /**\n   * @dev gets the frozen state of the reserve\n   * @param self the reserve configuration\n   * @return the frozen state\n   **/\n  function getFrozen(ReserveConfiguration.Map storage self) internal view returns (bool) {\n    return ((self.data & ~FROZEN_MASK) >> 57) != 0;\n  }\n\n  /**\n   * @dev enables or disables borrowing on the reserve\n   * @param self the reserve configuration\n   * @param enabled true if the borrowing needs to be enabled, false otherwise\n   **/\n  function setBorrowingEnabled(ReserveConfiguration.Map memory self, bool enabled) internal pure {\n    self.data = (self.data & BORROWING_MASK) | (uint256(enabled ? 1 : 0) << 58);\n  }\n\n  /**\n   * @dev gets the borrowing state of the reserve\n   * @param self the reserve configuration\n   * @return the borrowing state\n   **/\n  function getBorrowingEnabled(ReserveConfiguration.Map storage self) internal view returns (bool) {\n    return ((self.data & ~BORROWING_MASK) >> 58) != 0;\n  }\n\n  /**\n   * @dev enables or disables stable rate borrowing on the reserve\n   * @param self the reserve configuration\n   * @param enabled true if the stable rate borrowing needs to be enabled, false otherwise\n   **/\n  function setStableRateBorrowingEnabled(ReserveConfiguration.Map memory self, bool enabled)\n    internal pure\n  {\n    self.data = (self.data & STABLE_BORROWING_MASK) | (uint256(enabled ? 1 : 0) << 59);\n  }\n\n  /**\n   * @dev gets the stable rate borrowing state of the reserve\n   * @param self the reserve configuration\n   * @return the stable rate borrowing state\n   **/\n  function getStableRateBorrowingEnabled(ReserveConfiguration.Map storage self)\n    internal\n    view\n    returns (bool)\n  {\n    return ((self.dat"
    }
  ]
}