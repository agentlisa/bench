{
  "Title": "[M-02] `KUMAFeeCollector.changePayees()` executes incorrectly when newPayees contains duplicate items",
  "Content": "\nWhen calling [KUMAFeeCollector.changePayees()](https://github.com/code-423n4/2023-02-kuma/blob/3f3d2269fcb3437a9f00ffdd67b5029487435b95/src/kuma-protocol/KUMAFeeCollector.sol#L152) with duplicate payees in `newPayees`, the call is not reverted and the result state will be incorrect.\n\n### Proof of Concept\n\nContract [KUMAFeeCollector](https://github.com/code-423n4/2023-02-kuma/blob/3f3d2269fcb3437a9f00ffdd67b5029487435b95/src/kuma-protocol/KUMAFeeCollector.sol#L14) does not support duplicate payees. The transaction will revert when trying to add duplicate payees in [addPayee()](https://github.com/code-423n4/2023-02-kuma/blob/3f3d2269fcb3437a9f00ffdd67b5029487435b95/src/kuma-protocol/KUMAFeeCollector.sol#L77):\n\n    function addPayee(address payee, uint256 share) external override onlyManager {\n        if (_payees.contains(payee)) {\n            revert Errors.PAYEE_ALREADY_EXISTS();\n        }\n        ...\n    }\n\nBut, function [KUMAFeeCollector.changePayees()](https://github.com/code-423n4/2023-02-kuma/blob/3f3d2269fcb3437a9f00ffdd67b5029487435b95/src/kuma-protocol/KUMAFeeCollector.sol#L152) forgets this constraint, which allows duplicate payees to be passed in `newPayees`. This will cause the contract to record an incorrect state and not work properly.\n\nFor example, if `newPayees` contains duplicate payee A, all of its shares will be added to `_totalShares`, but `_shares[A]` will only record the last one.\n\nAs a result, the sum of all recorded `_shares` will be less than `_totalShares`.\n\nTest code for PoC:\n\n    diff --git a/test/kuma-protocol/KUMAFeeCollector.t.sol b/test/kuma-protocol/KUMAFeeCollector.t.sol\n    index f34d9ff..0b3fe46 100644\n    --- a/test/kuma-protocol/KUMAFeeCollector.t.sol\n    +++ b/test/kuma-protocol/KUMAFeeCollector.t.sol\n    @@ -40,6 +40,39 @@ contract KUMAFeeCollectorTest is BaseSetUp {\n             );\n         }\n\n    +    function test_DuplicatePayees() public {\n    +        address[] memory newPayees = new address[](4);\n    +        uint256[] memory newShares = new uint256[](4);\n    +\n    +        newPayees[0] = vm.addr(10);\n    +        newPayees[1] = vm.addr(10);\n    +        newPayees[2] = vm.addr(11);\n    +        newPayees[3] = vm.addr(12);\n    +        newShares[0] = 25;\n    +        newShares[1] = 25;\n    +        newShares[2] = 25;\n    +        newShares[3] = 25;\n    +\n    +        _KUMAFeeCollector.changePayees(newPayees, newShares);\n    +\n    +        // only 3 payees\n    +        assertEq(_KUMAFeeCollector.getPayees().length, 3);\n    +        // newPayees[0] and newPayees[1] are identical and both are added as payees[0]\n    +        address[] memory payees = _KUMAFeeCollector.getPayees();\n    +        assertEq(payees[0], newPayees[1]);\n    +        assertEq(payees[1], newPayees[2]);\n    +        assertEq(payees[2], newPayees[3]);\n    +\n    +        uint256 countedTotalShares = 0;\n    +        for (uint i; i < payees.length; i++) {\n    +            countedTotalShares += _KUMAFeeCollector.getShare(payees[i]);\n    +        }\n    +        // Counted totalShares is 75 (100 - 25)\n    +        assertEq(countedTotalShares, 75);\n    +        // Recorded totalShares is 100\n    +        assertEq(_KUMAFeeCollector.getTotalShares(), 100);\n    +    }\n    +\n         function test_initialize() public {\n             assertEq(address(_KUMAFeeCollector.getKUMAAddressProvider()), address(_KUMAAddressProvider));\n             assertEq(_KUMAFeeCollector.getRiskCategory(), _RISK_CATEGORY);\n\nOutputs:\n\n    forge test -m test_DuplicatePayees\n    [â ”] Compiling...\n    No files changed, compilation skipped\n\n    Running 1 test for test/kuma-protocol/KUMAFeeCollector.t.sol:KUMAFeeCollectorTest\n    [PASS] test_DuplicatePayees() (gas: 259689)\n    Test result: ok. 1 passed; 0 failed; finished in 7.39ms\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\n[KUMAFeeCollector.changePayees()](https://github.com/code-423n4/2023-02-kuma/blob/3f3d2269fcb3437a9f00ffdd67b5029487435b95/src/kuma-protocol/KUMAFeeCollector.sol#L152) should revert if there are duplicates in `newPayees`:\n\n```\ndiff --git a/src/kuma-protocol/KUMAFeeCollector.sol b/src/kuma-protocol/KUMAFeeCollector.sol\nindex 402cf71..1a9d86d 100644\n--- a/src/kuma-protocol/KUMAFeeCollector.sol\n+++ b/src/kuma-protocol/KUMAFeeCollector.sol\n@@ -180,7 +180,9 @@ contract KUMAFeeCollector is IKUMAFeeCollector, UUPSUpgradeable, Initializable {\n             }\n\n             address payee = newPayees[i];\n-            _payees.add(payee);\n+            if (!_payees.add(payee)) {\n+                revert Errors.PAYEE_ALREADY_EXISTS();\n+            }\n             _shares[payee] = newShares[i];\n             _totalShares += newShares[i];\n\n```\n\n**[m19 (KUMA) confirmed and commented](https://github.com/code-423n4/2023-02-kuma-findings/issues/13#issuecomment-1447498281):**\n > We confirm this issue and intend to fix it.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-02-kuma-findings/issues/13#issuecomment-1448246343):**\n > The Warden has shown how, due to a lack of checks, an inconsistent setting could be achieved, where the total sum of shares would be higher than what would be effectively distributed.\n> \n> While the issue can be solved by changing again, because the finding shows a reasonable way to achieve an inconsistent state, which can cause loss of tokens, I agree with Medium Severity.\n\n**[m19 (KUMA) mitigated](https://github.com/code-423n4/2023-02-kuma-findings/issues/3#issuecomment-1447507612):**\n > https://github.com/code-423n4/2023-02-kuma/pull/5 \n>\n **Status:** Mitigation confirmed by [0xsomeone](https://github.com/code-423n4/2023-03-kuma-mitigation-contest-findings/issues/20), [0x52](https://github.com/code-423n4/2023-03-kuma-mitigation-contest-findings/issues/13), and [hihen](https://github.com/code-423n4/2023-03-kuma-mitigation-contest-findings/issues/3).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-02-kuma",
  "Code": [
    {
      "filename": "src/kuma-protocol/KUMAFeeCollector.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {Errors} from \"./libraries/Errors.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport {IKUMAAddressProvider} from \"./interfaces/IKUMAAddressProvider.sol\";\nimport {IKUMAFeeCollector} from \"./interfaces/IKUMAFeeCollector.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport {Roles} from \"./libraries/Roles.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\";\n\ncontract KUMAFeeCollector is IKUMAFeeCollector, UUPSUpgradeable, Initializable {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using SafeERC20 for IERC20;\n\n    IKUMAAddressProvider private _KUMAAddressProvider;\n    bytes32 private _riskCategory;\n    EnumerableSet.AddressSet private _payees;\n    uint256 private _totalShares;\n\n    mapping(address => uint256) private _shares;\n\n    modifier onlyManager() {\n        if (!_KUMAAddressProvider.getAccessController().hasRole(Roles.KUMA_MANAGER_ROLE, msg.sender)) {\n            revert Errors.ACCESS_CONTROL_ACCOUNT_IS_MISSING_ROLE(msg.sender, Roles.KUMA_MANAGER_ROLE);\n        }\n        _;\n    }\n\n    constructor() initializer {}\n\n    function initialize(IKUMAAddressProvider KUMAAddressProvider, bytes4 currency, bytes4 country, uint64 term)\n        external\n        override\n        initializer\n    {\n        if (address(KUMAAddressProvider) == address(0)) {\n            revert Errors.CANNOT_SET_TO_ADDRESS_ZERO();\n        }\n        if (currency == bytes4(0) || country == bytes4(0) || term == 0) {\n            revert Errors.WRONG_RISK_CATEGORY();\n        }\n        _KUMAAddressProvider = KUMAAddressProvider;\n        _riskCategory = keccak256(abi.encode(currency, country, term));\n\n        emit KUMAAddressProviderSet(address(KUMAAddressProvider));\n        emit RiskCategorySet(_riskCategory);\n    }\n\n    /**\n     * @notice Releases the accumulated fee income to the payees.\n     * @dev Uses _totalShares to calculate correct share.\n     */\n    function release() external override {\n        IERC20 KIBToken = IERC20(_KUMAAddressProvider.getKIBToken(_riskCategory));\n        uint256 availableIncome = KIBToken.balanceOf(address(this));\n\n        if (availableIncome == 0) {\n            revert Errors.NO_AVAILABLE_INCOME();\n        }\n        if (_payees.length() == 0) {\n            revert Errors.NO_PAYEES();\n        }\n\n        _release(KIBToken, availableIncome);\n    }\n\n    /**\n     * @notice Adds a payee.\n     * @dev Will update totalShares and therefore reduce the relative share of all other payees.\n     * @dev Will release existing fees before the update.\n     * @param payee The address of the payee to add.\n     * @param share The number of shares owned by the payee.\n     */\n    function addPayee(address payee, uint256 share) external override onlyManager {\n        if (_payees.contains(payee)) {\n            revert Errors.PAYEE_ALREADY_EXISTS();\n        }\n        if (payee == address(0)) {\n            revert Errors.CANNOT_SET_TO_ADDRESS_ZERO();\n        }\n        if (share == 0) {\n            revert Errors.SHARE_CANNOT_BE_ZERO();\n        }\n\n        _releaseIfAvailableIncome();\n\n        _payees.add(payee);\n        _shares[payee] = share;\n        _totalShares += share;\n\n        emit PayeeAdded(payee, share);\n    }\n\n    /**\n     * @notice Removes a payee.\n     * @dev Will update totalShares and therefore increase the relative share of all other payees.\n     * @dev Will release existing fees before the update.\n     * @param payee The address of the payee to add.\n     */\n    function removePayee(address payee) external override onlyManager {\n        if (!_payees.contains(payee)) {\n            revert Errors.PAYEE_DOES_NOT_EXIST();\n        }\n\n        _releaseIfAvailableIncome();\n\n        _payees.remove(payee);\n        _totalShares -= _shares[payee];\n        delete _shares[payee];\n\n        emit PayeeRemoved(payee);\n    }\n\n    /**\n     * @notice Updates an existing payee's share.\n     * @dev Will release existing fees before the update.\n     * @param payee Payee's address.\n     * @param share New payee's share.\n     */\n    function updatePayeeShare(address payee, uint256 share) external onlyManager {\n        if (!_payees.contains(payee)) {\n            revert Errors.PAYEE_DOES_NOT_EXIST();\n        }\n        if (share == 0) {\n            revert Errors.SHARE_CANNOT_BE_ZERO();\n        }\n\n        _releaseIfAvailableIncome();\n\n        uint256 currentShare = _shares[payee];\n\n        if (currentShare < share) {\n            _totalShares += share - currentShare;\n        } else if (currentShare > share) {\n            _totalShares -= currentShare - share;\n        }\n\n        _shares[payee] = share;\n\n        emit ShareUpdated(payee, share);\n    }\n\n    /**\n     * @notice Updates the payee configuration to a new one.\n     * @dev Will release existing fees before the update.\n     * @param newPayees Array of  new payees\n     * @param newShares Array of shares for each new payee\n     */\n    function changePayees(address[] calldata newPayees, uint256[] calldata newShares) external override onlyManager {\n        if (newPayees.length != newShares.length) {\n            revert Errors.PAYEES_AND_SHARES_MISMATCHED(newPayees.length, newShares.length);\n        }\n        if (newPayees.length == 0) {\n            revert Errors.NO_PAYEES();\n        }\n\n        _releaseIfAvailableIncome();\n\n        uint256 payeesLength = _payees.length();\n\n        if (payeesLength > 0) {\n            for (uint256 i = payeesLength; i > 0; i--) {\n                address payee = _payees.at(i - 1);\n                _payees.remove(payee);\n                delete _shares[payee];\n                emit PayeeRemoved(payee);\n            }\n            _totalShares = 0;\n        }\n\n        for (uint256 i; i < newPayees.length; i++) {\n            if (newPayees[i] == address(0)) {\n                revert Errors.CANNOT_SET_TO_ADDRESS_ZERO();\n            }\n            if (newShares[i] == 0) {\n                revert Errors.SHARE_CANNOT_BE_ZERO();\n            }\n\n            address payee = newPayees[i];\n            _payees.add(payee);\n            _shares[payee] = newShares[i];\n            _totalShares += newShares[i];\n\n            emit PayeeAdded(payee, newShares[i]);\n        }\n    }\n\n    function getKUMAAddressProvider() external view returns (IKUMAAddressProvider) {\n        return _KUMAAddressProvider;\n    }\n\n    function getRiskCategory() external view returns (bytes32) {\n        return _riskCategory;\n    }\n\n    /**\n     * @notice Internal helper function to release an available income to a all payees.\n     * @dev Uses totalShares to calculate correct share\n     * @param KIBToken Cached KIBToken for gas savings.\n     * @param availableIncome Available income to release to payees.\n     */\n    function _release(IERC20 KIBToken, uint256 availableIncome) private {\n        uint256 totalShares = _totalShares;\n\n        for (uint256 i; i < _payees.length(); i++) {\n            address payee = _payees.at(i);\n            KIBToken.safeTransfer(payee, availableIncome * _shares[payee] / totalShares);\n        }\n\n        emit FeeReleased(availableIncome);\n    }\n\n    /**\n     * @notice Internal helper function to release an available income to a all payees if there is an availble income.\n     */\n    function _releaseIfAvailableIncome() private {\n        IERC20 KIBToken = IERC20(_KUMAAddressProvider.getKIBToken(_riskCategory));\n        uint256 availableIncome = KIBToken.balanceOf(address(this));\n\n        if (availableIncome > 0) {\n            _release(KIBToken, availableIncome);\n        }\n    }\n\n    /**\n     * @return Array of current payees.\n     */\n    function getPayees() external view returns (address[] memory) {\n        return _payees.values();\n    }\n\n    /**\n     * @return Total shares.\n     */\n    function getTotalShares() external view returns (uint256) {\n        return _totalShares;\n    }\n\n    /**\n     * @return Share of specific payee.\n     */\n    function getShare(address payee) external view returns (uint256) {\n        return _shares[payee];\n    }\n\n    function _authorizeUpgrade(address newImplementation) internal override onlyManager {}\n}"
    },
    {
      "filename": "src/kuma-protocol/KUMAFeeCollector.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {Errors} from \"./libraries/Errors.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport {IKUMAAddressProvider} from \"./interfaces/IKUMAAddressProvider.sol\";\nimport {IKUMAFeeCollector} from \"./interfaces/IKUMAFeeCollector.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport {Roles} from \"./libraries/Roles.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\";\n\ncontract KUMAFeeCollector is IKUMAFeeCollector, UUPSUpgradeable, Initializable {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using SafeERC20 for IERC20;\n\n    IKUMAAddressProvider private _KUMAAddressProvider;\n    bytes32 private _riskCategory;\n    EnumerableSet.AddressSet private _payees;\n    uint256 private _totalShares;\n\n    mapping(address => uint256) private _shares;\n\n    modifier onlyManager() {\n        if (!_KUMAAddressProvider.getAccessController().hasRole(Roles.KUMA_MANAGER_ROLE, msg.sender)) {\n            revert Errors.ACCESS_CONTROL_ACCOUNT_IS_MISSING_ROLE(msg.sender, Roles.KUMA_MANAGER_ROLE);\n        }\n        _;\n    }\n\n    constructor() initializer {}\n\n    function initialize(IKUMAAddressProvider KUMAAddressProvider, bytes4 currency, bytes4 country, uint64 term)\n        external\n        override\n        initializer\n    {\n        if (address(KUMAAddressProvider) == address(0)) {\n            revert Errors.CANNOT_SET_TO_ADDRESS_ZERO();\n        }\n        if (currency == bytes4(0) || country == bytes4(0) || term == 0) {\n            revert Errors.WRONG_RISK_CATEGORY();\n        }\n        _KUMAAddressProvider = KUMAAddressProvider;\n        _riskCategory = keccak256(abi.encode(currency, country, term));\n\n        emit KUMAAddressProviderSet(address(KUMAAddressProvider));\n        emit RiskCategorySet(_riskCategory);\n    }\n\n    /**\n     * @notice Releases the accumulated fee income to the payees.\n     * @dev Uses _totalShares to calculate correct share.\n     */\n    function release() external override {\n        IERC20 KIBToken = IERC20(_KUMAAddressProvider.getKIBToken(_riskCategory));\n        uint256 availableIncome = KIBToken.balanceOf(address(this));\n\n        if (availableIncome == 0) {\n            revert Errors.NO_AVAILABLE_INCOME();\n        }\n        if (_payees.length() == 0) {\n            revert Errors.NO_PAYEES();\n        }\n\n        _release(KIBToken, availableIncome);\n    }\n\n    /**\n     * @notice Adds a payee.\n     * @dev Will update totalShares and therefore reduce the relative share of all other payees.\n     * @dev Will release existing fees before the update.\n     * @param payee The address of the payee to add.\n     * @param share The number of shares owned by the payee.\n     */\n    function addPayee(address payee, uint256 share) external override onlyManager {\n        if (_payees.contains(payee)) {\n            revert Errors.PAYEE_ALREADY_EXISTS();\n        }\n        if (payee == address(0)) {\n            revert Errors.CANNOT_SET_TO_ADDRESS_ZERO();\n        }\n        if (share == 0) {\n            revert Errors.SHARE_CANNOT_BE_ZERO();\n        }\n\n        _releaseIfAvailableIncome();\n\n        _payees.add(payee);\n        _shares[payee] = share;\n        _totalShares += share;\n\n        emit PayeeAdded(payee, share);\n    }\n\n    /**\n     * @notice Removes a payee.\n     * @dev Will update totalShares and therefore increase the relative share of all other payees.\n     * @dev Will release existing fees before the update.\n     * @param payee The address of the payee to add.\n     */\n    function removePayee(address payee) external override onlyManager {\n        if (!_payees.contains(payee)) {\n            revert Errors.PAYEE_DOES_NOT_EXIST();\n        }\n\n        _releaseIfAvailableIncome();\n\n        _payees.remove(payee);\n        _totalShares -= _shares[payee];\n        delete _shares[payee];\n\n        emit PayeeRemoved(payee);\n    }\n\n    /**\n     * @notice Updates an existing payee's share.\n     * @dev Will release existing fees before the update.\n     * @param payee Payee's address.\n     * @param share New payee's share.\n     */\n    function updatePayeeShare(address payee, uint256 share) external onlyManager {\n        if (!_payees.contains(payee)) {\n            revert Errors.PAYEE_DOES_NOT_EXIST();\n        }\n        if (share == 0) {\n            revert Errors.SHARE_CANNOT_BE_ZERO();\n        }\n\n        _releaseIfAvailableIncome();\n\n        uint256 currentShare = _shares[payee];\n\n        if (currentShare < share) {\n            _totalShares += share - currentShare;\n        } else if (currentShare > share) {\n            _totalShares -= currentShare - share;\n        }\n\n        _shares[payee] = share;\n\n        emit ShareUpdated(payee, share);\n    }\n\n    /**\n     * @notice Updates the payee configuration to a new one.\n     * @dev Will release existing fees before the update.\n     * @param newPayees Array of  new payees\n     * @param newShares Array of shares for each new payee\n     */\n    function changePayees(address[] calldata newPayees, uint256[] calldata newShares) external override onlyManager {\n        if (newPayees.length != newShares.length) {\n            revert Errors.PAYEES_AND_SHARES_MISMATCHED(newPayees.length, newShares.length);\n        }\n        if (newPayees.length == 0) {\n            revert Errors.NO_PAYEES();\n        }\n\n        _releaseIfAvailableIncome();\n\n        uint256 payeesLength = _payees.length();\n\n        if (payeesLength > 0) {\n            for (uint256 i = payeesLength; i > 0; i--) {\n                address payee = _payees.at(i - 1);\n                _payees.remove(payee);\n                delete _shares[payee];\n                emit PayeeRemoved(payee);\n            }\n            _totalShares = 0;\n        }\n\n        for (uint256 i; i < newPayees.length; i++) {\n            if (newPayees[i] == address(0)) {\n                revert Errors.CANNOT_SET_TO_ADDRESS_ZERO();\n            }\n            if (newShares[i] == 0) {\n                revert Errors.SHARE_CANNOT_BE_ZERO();\n            }\n\n            address payee = newPayees[i];\n            _payees.add(payee);\n            _shares[payee] = newShares[i];\n            _totalShares += newShares[i];\n\n            emit PayeeAdded(payee, newShares[i]);\n        }\n    }\n\n    function getKUMAAddressProvider() external view returns (IKUMAAddressProvider) {\n        return _KUMAAddressProvider;\n    }\n\n    function getRiskCategory() external view returns (bytes32) {\n        return _riskCategory;\n    }\n\n    /**\n     * @notice Internal helper function to release an available income to a all payees.\n     * @dev Uses totalShares to calculate correct share\n     * @param KIBToken Cached KIBToken for gas savings.\n     * @param availableIncome Available income to release to payees.\n     */\n    function _release(IERC20 KIBToken, uint256 availableIncome) private {\n        uint256 totalShares = _totalShares;\n\n        for (uint256 i; i < _payees.length(); i++) {\n            address payee = _payees.at(i);\n            KIBToken.safeTransfer(payee, availableIncome * _shares[payee] / totalShares);\n        }\n\n        emit FeeReleased(availableIncome);\n    }\n\n    /**\n     * @notice Internal helper function to release an available income to a all payees if there is an availble income.\n     */\n    function _releaseIfAvailableIncome() private {\n        IERC20 KIBToken = IERC20(_KUMAAddressProvider.getKIBToken(_riskCategory));\n        uint256 availableIncome = KIBToken.balanceOf(address(this));\n\n        if (availableIncome > 0) {\n            _release(KIBToken, availableIncome);\n        }\n    }\n\n    /**\n     * @return Array of current payees.\n     */\n    function getPayees() external view returns (address[] memory) {\n        return _payees.values();\n    }\n\n    /**\n     * @return Total shares.\n     */\n    function getTotalShares() external view returns (uint256) {\n        return _totalShares;\n    }\n\n    /**\n     * @return Share of specific payee.\n     */\n    function getShare(address payee) external view returns (uint256) {\n        return _shares[payee];\n    }\n\n    function _authorizeUpgrade(address newImplementation) internal override onlyManager {}\n}"
    },
    {
      "filename": "src/kuma-protocol/KUMAFeeCollector.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {Errors} from \"./libraries/Errors.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport {IKUMAAddressProvider} from \"./interfaces/IKUMAAddressProvider.sol\";\nimport {IKUMAFeeCollector} from \"./interfaces/IKUMAFeeCollector.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport {Roles} from \"./libraries/Roles.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\";\n\ncontract KUMAFeeCollector is IKUMAFeeCollector, UUPSUpgradeable, Initializable {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using SafeERC20 for IERC20;\n\n    IKUMAAddressProvider private _KUMAAddressProvider;\n    bytes32 private _riskCategory;\n    EnumerableSet.AddressSet private _payees;\n    uint256 private _totalShares;\n\n    mapping(address => uint256) private _shares;\n\n    modifier onlyManager() {\n        if (!_KUMAAddressProvider.getAccessController().hasRole(Roles.KUMA_MANAGER_ROLE, msg.sender)) {\n            revert Errors.ACCESS_CONTROL_ACCOUNT_IS_MISSING_ROLE(msg.sender, Roles.KUMA_MANAGER_ROLE);\n        }\n        _;\n    }\n\n    constructor() initializer {}\n\n    function initialize(IKUMAAddressProvider KUMAAddressProvider, bytes4 currency, bytes4 country, uint64 term)\n        external\n        override\n        initializer\n    {\n        if (address(KUMAAddressProvider) == address(0)) {\n            revert Errors.CANNOT_SET_TO_ADDRESS_ZERO();\n        }\n        if (currency == bytes4(0) || country == bytes4(0) || term == 0) {\n            revert Errors.WRONG_RISK_CATEGORY();\n        }\n        _KUMAAddressProvider = KUMAAddressProvider;\n        _riskCategory = keccak256(abi.encode(currency, country, term));\n\n        emit KUMAAddressProviderSet(address(KUMAAddressProvider));\n        emit RiskCategorySet(_riskCategory);\n    }\n\n    /**\n     * @notice Releases the accumulated fee income to the payees.\n     * @dev Uses _totalShares to calculate correct share.\n     */\n    function release() external override {\n        IERC20 KIBToken = IERC20(_KUMAAddressProvider.getKIBToken(_riskCategory));\n        uint256 availableIncome = KIBToken.balanceOf(address(this));\n\n        if (availableIncome == 0) {\n            revert Errors.NO_AVAILABLE_INCOME();\n        }\n        if (_payees.length() == 0) {\n            revert Errors.NO_PAYEES();\n        }\n\n        _release(KIBToken, availableIncome);\n    }\n\n    /**\n     * @notice Adds a payee.\n     * @dev Will update totalShares and therefore reduce the relative share of all other payees.\n     * @dev Will release existing fees before the update.\n     * @param payee The address of the payee to add.\n     * @param share The number of shares owned by the payee.\n     */\n    function addPayee(address payee, uint256 share) external override onlyManager {\n        if (_payees.contains(payee)) {\n            revert Errors.PAYEE_ALREADY_EXISTS();\n        }\n        if (payee == address(0)) {\n            revert Errors.CANNOT_SET_TO_ADDRESS_ZERO();\n        }\n        if (share == 0) {\n            revert Errors.SHARE_CANNOT_BE_ZERO();\n        }\n\n        _releaseIfAvailableIncome();\n\n        _payees.add(payee);\n        _shares[payee] = share;\n        _totalShares += share;\n\n        emit PayeeAdded(payee, share);\n    }\n\n    /**\n     * @notice Removes a payee.\n     * @dev Will update totalShares and therefore increase the relative share of all other payees.\n     * @dev Will release existing fees before the update.\n     * @param payee The address of the payee to add.\n     */\n    function removePayee(address payee) external override onlyManager {\n        if (!_payees.contains(payee)) {\n            revert Errors.PAYEE_DOES_NOT_EXIST();\n        }\n\n        _releaseIfAvailableIncome();\n\n        _payees.remove(payee);\n        _totalShares -= _shares[payee];\n        delete _shares[payee];\n\n        emit PayeeRemoved(payee);\n    }\n\n    /**\n     * @notice Updates an existing payee's share.\n     * @dev Will release existing fees before the update.\n     * @param payee Payee's address.\n     * @param share New payee's share.\n     */\n    function updatePayeeShare(address payee, uint256 share) external onlyManager {\n        if (!_payees.contains(payee)) {\n            revert Errors.PAYEE_DOES_NOT_EXIST();\n        }\n        if (share == 0) {\n            revert Errors.SHARE_CANNOT_BE_ZERO();\n        }\n\n        _releaseIfAvailableIncome();\n\n        uint256 currentShare = _shares[payee];\n\n        if (currentShare < share) {\n            _totalShares += share - currentShare;\n        } else if (currentShare > share) {\n            _totalShares -= currentShare - share;\n        }\n\n        _shares[payee] = share;\n\n        emit ShareUpdated(payee, share);\n    }\n\n    /**\n     * @notice Updates the payee configuration to a new one.\n     * @dev Will release existing fees before the update.\n     * @param newPayees Array of  new payees\n     * @param newShares Array of shares for each new payee\n     */\n    function changePayees(address[] calldata newPayees, uint256[] calldata newShares) external override onlyManager {\n        if (newPayees.length != newShares.length) {\n            revert Errors.PAYEES_AND_SHARES_MISMATCHED(newPayees.length, newShares.length);\n        }\n        if (newPayees.length == 0) {\n            revert Errors.NO_PAYEES();\n        }\n\n        _releaseIfAvailableIncome();\n\n        uint256 payeesLength = _payees.length();\n\n        if (payeesLength > 0) {\n            for (uint256 i = payeesLength; i > 0; i--) {\n                address payee = _payees.at(i - 1);\n                _payees.remove(payee);\n                delete _shares[payee];\n                emit PayeeRemoved(payee);\n            }\n            _totalShares = 0;\n        }\n\n        for (uint256 i; i < newPayees.length; i++) {\n            if (newPayees[i] == address(0)) {\n                revert Errors.CANNOT_SET_TO_ADDRESS_ZERO();\n            }\n            if (newShares[i] == 0) {\n                revert Errors.SHARE_CANNOT_BE_ZERO();\n            }\n\n            address payee = newPayees[i];\n            _payees.add(payee);\n            _shares[payee] = newShares[i];\n            _totalShares += newShares[i];\n\n            emit PayeeAdded(payee, newShares[i]);\n        }\n    }\n\n    function getKUMAAddressProvider() external view returns (IKUMAAddressProvider) {\n        return _KUMAAddressProvider;\n    }\n\n    function getRiskCategory() external view returns (bytes32) {\n        return _riskCategory;\n    }\n\n    /**\n     * @notice Internal helper function to release an available income to a all payees.\n     * @dev Uses totalShares to calculate correct share\n     * @param KIBToken Cached KIBToken for gas savings.\n     * @param availableIncome Available income to release to payees.\n     */\n    function _release(IERC20 KIBToken, uint256 availableIncome) private {\n        uint256 totalShares = _totalShares;\n\n        for (uint256 i; i < _payees.length(); i++) {\n            address payee = _payees.at(i);\n            KIBToken.safeTransfer(payee, availableIncome * _shares[payee] / totalShares);\n        }\n\n        emit FeeReleased(availableIncome);\n    }\n\n    /**\n     * @notice Internal helper function to release an available income to a all payees if there is an availble income.\n     */\n    function _releaseIfAvailableIncome() private {\n        IERC20 KIBToken = IERC20(_KUMAAddressProvider.getKIBToken(_riskCategory));\n        uint256 availableIncome = KIBToken.balanceOf(address(this));\n\n        if (availableIncome > 0) {\n            _release(KIBToken, availableIncome);\n        }\n    }\n\n    /**\n     * @return Array of current payees.\n     */\n    function getPayees() external view returns (address[] memory) {\n        return _payees.values();\n    }\n\n    /**\n     * @return Total shares.\n     */\n    function getTotalShares() external view returns (uint256) {\n        return _totalShares;\n    }\n\n    /**\n     * @return Share of specific payee.\n     */\n    function getShare(address payee) external view returns (uint256) {\n        return _shares[payee];\n    }\n\n    function _authorizeUpgrade(address newImplementation) internal override onlyManager {}\n}"
    },
    {
      "filename": "src/kuma-protocol/KUMAFeeCollector.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {Errors} from \"./libraries/Errors.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport {IKUMAAddressProvider} from \"./interfaces/IKUMAAddressProvider.sol\";\nimport {IKUMAFeeCollector} from \"./interfaces/IKUMAFeeCollector.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport {Roles} from \"./libraries/Roles.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\";\n\ncontract KUMAFeeCollector is IKUMAFeeCollector, UUPSUpgradeable, Initializable {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using SafeERC20 for IERC20;\n\n    IKUMAAddressProvider private _KUMAAddressProvider;\n    bytes32 private _riskCategory;\n    EnumerableSet.AddressSet private _payees;\n    uint256 private _totalShares;\n\n    mapping(address => uint256) private _shares;\n\n    modifier onlyManager() {\n        if (!_KUMAAddressProvider.getAccessController().hasRole(Roles.KUMA_MANAGER_ROLE, msg.sender)) {\n            revert Errors.ACCESS_CONTROL_ACCOUNT_IS_MISSING_ROLE(msg.sender, Roles.KUMA_MANAGER_ROLE);\n        }\n        _;\n    }\n\n    constructor() initializer {}\n\n    function initialize(IKUMAAddressProvider KUMAAddressProvider, bytes4 currency, bytes4 country, uint64 term)\n        external\n        override\n        initializer\n    {\n        if (address(KUMAAddressProvider) == address(0)) {\n            revert Errors.CANNOT_SET_TO_ADDRESS_ZERO();\n        }\n        if (currency == bytes4(0) || country == bytes4(0) || term == 0) {\n            revert Errors.WRONG_RISK_CATEGORY();\n        }\n        _KUMAAddressProvider = KUMAAddressProvider;\n        _riskCategory = keccak256(abi.encode(currency, country, term));\n\n        emit KUMAAddressProviderSet(address(KUMAAddressProvider));\n        emit RiskCategorySet(_riskCategory);\n    }\n\n    /**\n     * @notice Releases the accumulated fee income to the payees.\n     * @dev Uses _totalShares to calculate correct share.\n     */\n    function release() external override {\n        IERC20 KIBToken = IERC20(_KUMAAddressProvider.getKIBToken(_riskCategory));\n        uint256 availableIncome = KIBToken.balanceOf(address(this));\n\n        if (availableIncome == 0) {\n            revert Errors.NO_AVAILABLE_INCOME();\n        }\n        if (_payees.length() == 0) {\n            revert Errors.NO_PAYEES();\n        }\n\n        _release(KIBToken, availableIncome);\n    }\n\n    /**\n     * @notice Adds a payee.\n     * @dev Will update totalShares and therefore reduce the relative share of all other payees.\n     * @dev Will release existing fees before the update.\n     * @param payee The address of the payee to add.\n     * @param share The number of shares owned by the payee.\n     */\n    function addPayee(address payee, uint256 share) external override onlyManager {\n        if (_payees.contains(payee)) {\n            revert Errors.PAYEE_ALREADY_EXISTS();\n        }\n        if (payee == address(0)) {\n            revert Errors.CANNOT_SET_TO_ADDRESS_ZERO();\n        }\n        if (share == 0) {\n            revert Errors.SHARE_CANNOT_BE_ZERO();\n        }\n\n        _releaseIfAvailableIncome();\n\n        _payees.add(payee);\n        _shares[payee] = share;\n        _totalShares += share;\n\n        emit PayeeAdded(payee, share);\n    }\n\n    /**\n     * @notice Removes a payee.\n     * @dev Will update totalShares and therefore increase the relative share of all other payees.\n     * @dev Will release existing fees before the update.\n     * @param payee The address of the payee to add.\n     */\n    function removePayee(address payee) external override onlyManager {\n        if (!_payees.contains(payee)) {\n            revert Errors.PAYEE_DOES_NOT_EXIST();\n        }\n\n        _releaseIfAvailableIncome();\n\n        _payees.remove(payee);\n        _totalShares -= _shares[payee];\n        delete _shares[payee];\n\n        emit PayeeRemoved(payee);\n    }\n\n    /**\n     * @notice Updates an existing payee's share.\n     * @dev Will release existing fees before the update.\n     * @param payee Payee's address.\n     * @param share New payee's share.\n     */\n    function updatePayeeShare(address payee, uint256 share) external onlyManager {\n        if (!_payees.contains(payee)) {\n            revert Errors.PAYEE_DOES_NOT_EXIST();\n        }\n        if (share == 0) {\n            revert Errors.SHARE_CANNOT_BE_ZERO();\n        }\n\n        _releaseIfAvailableIncome();\n\n        uint256 currentShare = _shares[payee];\n\n        if (currentShare < share) {\n            _totalShares += share - currentShare;\n        } else if (currentShare > share) {\n            _totalShares -= currentShare - share;\n        }\n\n        _shares[payee] = share;\n\n        emit ShareUpdated(payee, share);\n    }\n\n    /**\n     * @notice Updates the payee configuration to a new one.\n     * @dev Will release existing fees before the update.\n     * @param newPayees Array of  new payees\n     * @param newShares Array of shares for each new payee\n     */\n    function changePayees(address[] calldata newPayees, uint256[] calldata newShares) external override onlyManager {\n        if (newPayees.length != newShares.length) {\n            revert Errors.PAYEES_AND_SHARES_MISMATCHED(newPayees.length, newShares.length);\n        }\n        if (newPayees.length == 0) {\n            revert Errors.NO_PAYEES();\n        }\n\n        _releaseIfAvailableIncome();\n\n        uint256 payeesLength = _payees.length();\n\n        if (payeesLength > 0) {\n            for (uint256 i = payeesLength; i > 0; i--) {\n                address payee = _payees.at(i - 1);\n                _payees.remove(payee);\n                delete _shares[payee];\n                emit PayeeRemoved(payee);\n            }\n            _totalShares = 0;\n        }\n\n        for (uint256 i; i < newPayees.length; i++) {\n            if (newPayees[i] == address(0)) {\n                revert Errors.CANNOT_SET_TO_ADDRESS_ZERO();\n            }\n            if (newShares[i] == 0) {\n                revert Errors.SHARE_CANNOT_BE_ZERO();\n            }\n\n            address payee = newPayees[i];\n            _payees.add(payee);\n            _shares[payee] = newShares[i];\n            _totalShares += newShares[i];\n\n            emit PayeeAdded(payee, newShares[i]);\n        }\n    }\n\n    function getKUMAAddressProvider() external view returns (IKUMAAddressProvider) {\n        return _KUMAAddressProvider;\n    }\n\n    function getRiskCategory() external view returns (bytes32) {\n        return _riskCategory;\n    }\n\n    /**\n     * @notice Internal helper function to release an available income to a all payees.\n     * @dev Uses totalShares to calculate correct share\n     * @param KIBToken Cached KIBToken for gas savings.\n     * @param availableIncome Available income to release to payees.\n     */\n    function _release(IERC20 KIBToken, uint256 availableIncome) private {\n        uint256 totalShares = _totalShares;\n\n        for (uint256 i; i < _payees.length(); i++) {\n            address payee = _payees.at(i);\n            KIBToken.safeTransfer(payee, availableIncome * _shares[payee] / totalShares);\n        }\n\n        emit FeeReleased(availableIncome);\n    }\n\n    /**\n     * @notice Internal helper function to release an available income to a all payees if there is an availble income.\n     */\n    function _releaseIfAvailableIncome() private {\n        IERC20 KIBToken = IERC"
    }
  ]
}