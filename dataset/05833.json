{
  "Title": "[M-03] Cached `DOMAIN_SEPARATOR` is incorrect for tranche tokens potentially breaking permit integrations",
  "Content": "\nAttempts to interact with tranche tokens via `permit` may always revert.\n\n### Proof of Concept\n\nWhen new tranche tokens are deployed, the initial `DOMAIN_SEPARATOR` is calculated and cached in the constructor.<br>\n<https://github.com/code-423n4/2023-09-centrifuge/blob/512e7a71ebd9ae76384f837204216f26380c9f91/src/token/ERC20.sol#L42-L49>\n\n```solidity\n    constructor(uint8 decimals_) {\n        ...\n        deploymentChainId = block.chainid;\n        _DOMAIN_SEPARATOR = _calculateDomainSeparator(block.chainid);\n    }\n```\n\nThis uses an empty string since `name` is only set after deployment.<br>\n<https://github.com/code-423n4/2023-09-centrifuge/blob/512e7a71ebd9ae76384f837204216f26380c9f91/src/util/Factory.sol#L81-L109>\n\n```solidity\n    function newTrancheToken(\n        uint64 poolId,\n        bytes16 trancheId,\n        string memory name,\n        string memory symbol,\n        uint8 decimals,\n        address[] calldata trancheTokenWards,\n        address[] calldata restrictionManagerWards\n    ) public auth returns (address) {\n        ...\n        TrancheToken token = new TrancheToken{salt: salt}(decimals);\n\n        token.file(\"name\", name);\n        ...\n    }\n```\n\nConsequently, the domain separator is incorrect (when `block.chainid == deploymentChainId` where the domain separator is not recalculated) and will cause reverts when signatures for `permit` are attempted to be constructed using the tranche token's `name` (which will not be empty).\n\nIt should also be noted that the tranche token `name` could be changed by a call to `updateTranchTokenMetadata` which may also introduce complications with the domain separator.\n\n### Recommended Mitigation Steps\n\nConsider setting the name in the constructor before the cached domain separator is calculated.\n\n**[hieronx (Centrifuge) confirmed and commented](https://github.com/code-423n4/2023-09-centrifuge-findings/issues/146#issuecomment-1745025208):**\n > Mitigated in https://github.com/centrifuge/liquidity-pools/pull/142\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-09-centrifuge",
  "Code": [
    {
      "filename": "src/token/ERC20.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n// Copyright (C) 2017, 2018, 2019 dbrock, rain, mrchico\n// Copyright (C) 2021-2022 Foundation\npragma solidity 0.8.21;\n\nimport {Context} from \"../util/Context.sol\";\n\ninterface IERC1271 {\n    function isValidSignature(bytes32, bytes memory) external view returns (bytes4);\n}\n\n/// @title  ERC20\n/// @notice Standard ERC20 implementation, with mint/burn functionality and permit logic.\n///         Includes ERC1271 context support to allow multiple liquidity pools\n/// @dev    Adapted from https://github.com/makerdao/xdomain-dss/blob/master/src/Dai.sol\ncontract ERC20 is Context {\n    mapping(address => uint256) public wards;\n\n    string public name;\n    string public symbol;\n    string public constant version = \"3\";\n    uint8 public immutable decimals;\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    mapping(address => uint256) public nonces;\n\n    // --- EIP712 niceties ---\n    uint256 public immutable deploymentChainId;\n    bytes32 private immutable _DOMAIN_SEPARATOR;\n    bytes32 public constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    // --- Events ---\n    event Rely(address indexed user);\n    event Deny(address indexed user);\n    event File(bytes32 indexed what, string data);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    constructor(uint8 decimals_) {\n        decimals = decimals_;\n        wards[_msgSender()] = 1;\n        emit Rely(_msgSender());\n\n        deploymentChainId = block.chainid;\n        _DOMAIN_SEPARATOR = _calculateDomainSeparator(block.chainid);\n    }\n\n    modifier auth() {\n        // Custom auth modifier that uses _msgSender()\n        require(wards[_msgSender()] == 1, \"Auth/not-authorized\");\n        _;\n    }\n\n    function rely(address user) external auth {\n        wards[user] = 1;\n        emit Rely(user);\n    }\n\n    function deny(address user) external auth {\n        wards[user] = 0;\n        emit Deny(user);\n    }\n\n    function _calculateDomainSeparator(uint256 chainId) private view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                keccak256(bytes(name)),\n                keccak256(bytes(version)),\n                chainId,\n                address(this)\n            )\n        );\n    }\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return block.chainid == deploymentChainId ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(block.chainid);\n    }\n\n    function file(bytes32 what, string memory data) external auth {\n        if (what == \"name\") name = data;\n        else if (what == \"symbol\") symbol = data;\n        else revert(\"ERC20/file-unrecognized-param\");\n        emit File(what, data);\n    }\n\n    // --- ERC20 Mutations ---\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        require(to != address(0) && to != address(this), \"ERC20/invalid-address\");\n        uint256 balance = balanceOf[_msgSender()];\n        require(balance >= value, \"ERC20/insufficient-balance\");\n\n        unchecked {\n            balanceOf[_msgSender()] = balance - value;\n            balanceOf[to] += value;\n        }\n\n        emit Transfer(_msgSender(), to, value);\n\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        require(to != address(0) && to != address(this), \"ERC20/invalid-address\");\n        uint256 balance = balanceOf[from];\n        require(balance >= value, \"ERC20/insufficient-balance\");\n\n        if (from != _msgSender()) {\n            uint256 allowed = allowance[from][_msgSender()];\n            if (allowed != type(uint256).max) {\n                require(allowed >= value, \"ERC20/insufficient-allowance\");\n                unchecked {\n                    allowance[from][_msgSender()] = allowed - value;\n                }\n            }\n        }\n\n        unchecked {\n            balanceOf[from] = balance - value;\n            balanceOf[to] += value;\n        }\n\n        emit Transfer(from, to, value);\n\n        return true;\n    }\n\n    function approve(address spender, uint256 value) external returns (bool) {\n        allowance[_msgSender()][spender] = value;\n\n        emit Approval(_msgSender(), spender, value);\n\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {\n        uint256 newValue = allowance[_msgSender()][spender] + addedValue;\n        allowance[_msgSender()][spender] = newValue;\n\n        emit Approval(_msgSender(), spender, newValue);\n\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool) {\n        uint256 allowed = allowance[_msgSender()][spender];\n        require(allowed >= subtractedValue, \"ERC20/insufficient-allowance\");\n        unchecked {\n            allowed = allowed - subtractedValue;\n        }\n        allowance[_msgSender()][spender] = allowed;\n\n        emit Approval(_msgSender(), spender, allowed);\n\n        return true;\n    }\n\n    // --- Mint/Burn ---\n    function mint(address to, uint256 value) public virtual auth {\n        require(to != address(0) && to != address(this), \"ERC20/invalid-address\");\n        unchecked {\n            balanceOf[to] = balanceOf[to] + value; // note: we don't need an overflow check here b/c balanceOf[to] <= totalSupply and there is an overflow check below\n        }\n        totalSupply = totalSupply + value;\n\n        emit Transfer(address(0), to, value);\n    }\n\n    function burn(address from, uint256 value) external auth {\n        uint256 balance = balanceOf[from];\n        require(balance >= value, \"ERC20/insufficient-balance\");\n\n        if (from != _msgSender()) {\n            uint256 allowed = allowance[from][_msgSender()];\n            if (allowed != type(uint256).max) {\n                require(allowed >= value, \"ERC20/insufficient-allowance\");\n\n                unchecked {\n                    allowance[from][_msgSender()] = allowed - value;\n                }\n            }\n        }\n\n        unchecked {\n            balanceOf[from] = balance - value; // note: we don't need overflow checks b/c require(balance >= value) and balance <= totalSupply\n            totalSupply = totalSupply - value;\n        }\n\n        emit Transfer(from, address(0), value);\n    }\n\n    // --- Approve by signature ---\n    function _isValidSignature(address signer, bytes32 digest, bytes memory signature) internal view returns (bool) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            if (signer == ecrecover(digest, v, r, s)) {\n                return true;\n            }\n        }\n\n        (bool success, bytes memory result) =\n            signer.staticcall(abi.encodeWithSelector(IERC1271.isValidSignature.selector, digest, signature));\n        return (success && result.length == 32 && abi.decode(result, (bytes4)) == IERC1271.isValidSignature.selector);\n    }\n\n    function permit(address owner, address spender, uint256 value, uint256 deadline, bytes memory signature) public {\n        require(block.timestamp <= deadline, \"ERC20/permit-expired\");\n        require(owner != address(0), \"ERC20/invalid-owner\");\n\n        uint256 nonce;\n        unchecked {\n            nonce = nonces[owner]++;\n        }\n\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                block.chainid == deploymentChainId ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(block.chainid),\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonce, deadline))\n            )\n        );\n\n        require(_isValidSignature(owner, digest, signature), \"ERC20/invalid-permit\");\n\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n        external\n    {\n        permit(owner, spender, value, deadline, abi.encodePacked(r, s, v));\n    }\n}"
    },
    {
      "filename": "src/util/Factory.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.21;\n\nimport {LiquidityPool} from \"../LiquidityPool.sol\";\nimport {TrancheToken} from \"../token/Tranche.sol\";\nimport {RestrictionManager} from \"../token/RestrictionManager.sol\";\nimport {Auth} from \"./Auth.sol\";\n\ninterface RootLike {\n    function escrow() external view returns (address);\n}\n\ninterface LiquidityPoolFactoryLike {\n    function newLiquidityPool(\n        uint64 poolId,\n        bytes16 trancheId,\n        address currency,\n        address trancheToken,\n        address investmentManager,\n        address[] calldata wards\n    ) external returns (address);\n}\n\n/// @title  Liquidity Pool Factory\n/// @dev    Utility for deploying new liquidity pool contracts\ncontract LiquidityPoolFactory is Auth {\n    address immutable root;\n\n    constructor(address _root) {\n        root = _root;\n\n        wards[msg.sender] = 1;\n        emit Rely(msg.sender);\n    }\n\n    function newLiquidityPool(\n        uint64 poolId,\n        bytes16 trancheId,\n        address currency,\n        address trancheToken,\n        address investmentManager,\n        address[] calldata wards\n    ) public auth returns (address) {\n        LiquidityPool liquidityPool = new LiquidityPool(poolId, trancheId, currency, trancheToken, investmentManager);\n\n        liquidityPool.rely(root);\n        for (uint256 i = 0; i < wards.length; i++) {\n            liquidityPool.rely(wards[i]);\n        }\n        liquidityPool.deny(address(this));\n        return address(liquidityPool);\n    }\n}\n\ninterface TrancheTokenFactoryLike {\n    function newTrancheToken(\n        uint64 poolId,\n        bytes16 trancheId,\n        string memory name,\n        string memory symbol,\n        uint8 decimals,\n        address[] calldata trancheTokenWards,\n        address[] calldata restrictionManagerWards\n    ) external returns (address);\n}\n\n/// @title  Tranche Token Factory\n/// @dev    Utility for deploying new tranche token contracts\n///         Ensures the addresses are deployed at a deterministic address\n///         based on the pool id and tranche id.\ncontract TrancheTokenFactory is Auth {\n    address immutable root;\n\n    constructor(address _root) {\n        root = _root;\n\n        wards[msg.sender] = 1;\n        emit Rely(msg.sender);\n    }\n\n    function newTrancheToken(\n        uint64 poolId,\n        bytes16 trancheId,\n        string memory name,\n        string memory symbol,\n        uint8 decimals,\n        address[] calldata trancheTokenWards,\n        address[] calldata restrictionManagerWards\n    ) public auth returns (address) {\n        address restrictionManager = _newRestrictionManager(restrictionManagerWards);\n\n        // Salt is hash(poolId + trancheId)\n        // same tranche token address on every evm chain\n        bytes32 salt = keccak256(abi.encodePacked(poolId, trancheId));\n\n        TrancheToken token = new TrancheToken{salt: salt}(decimals);\n\n        token.file(\"name\", name);\n        token.file(\"symbol\", symbol);\n        token.file(\"restrictionManager\", restrictionManager);\n\n        token.rely(root);\n        for (uint256 i = 0; i < trancheTokenWards.length; i++) {\n            token.rely(trancheTokenWards[i]);\n        }\n        token.deny(address(this));\n\n        return address(token);\n    }\n\n    function _newRestrictionManager(address[] calldata restrictionManagerWards) internal returns (address memberList) {\n        RestrictionManager restrictionManager = new RestrictionManager();\n\n        restrictionManager.updateMember(RootLike(root).escrow(), type(uint256).max);\n\n        restrictionManager.rely(root);\n        for (uint256 i = 0; i < restrictionManagerWards.length; i++) {\n            restrictionManager.rely(restrictionManagerWards[i]);\n        }\n        restrictionManager.deny(address(this));\n\n        return (address(restrictionManager));\n    }\n}"
    }
  ]
}