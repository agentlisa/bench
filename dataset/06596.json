{
  "Title": "[01] `PoolRegistry.supportMarket()` cannot be paused",
  "Content": "\nMost actions in `PoolRegistry` can be paused, e.g. `_addToMarket()`, `exitMarket()`, `preMintHook()` etc.\n\nConsider adding a \"support\" field in the enum Action and allowing `supportMarket()` to be paused. Not allowing `supportMarket()` to be paused could result in irregular behavior if everything else (mint, redeeming, borrowing enter market, exit market, etc) is paused but `supportMarket()` is open.\n\nhttps://github.com/code-423n4/2023-05-venus/blob/main/contracts/Comptroller.sol#L801-L824\n\nhttps://github.com/code-423n4/2023-05-venus/blob/main/contracts/Comptroller.sol#L1177\n\nhttps://github.com/code-423n4/2023-05-venus/blob/main/contracts/Comptroller.sol#L188\n\nhttps://github.com/code-423n4/2023-05-venus/blob/main/contracts/Comptroller.sol#L254\n\nhttps://github.com/code-423n4/2023-05-venus/blob/main/contracts/ComptrollerStorage.sol#L44-L54\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-05-venus",
  "Code": [
    {
      "filename": "contracts/Comptroller.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\n\nimport \"./VToken.sol\";\nimport \"@venusprotocol/oracle/contracts/PriceOracle.sol\";\nimport \"./ComptrollerInterface.sol\";\nimport \"./ComptrollerStorage.sol\";\nimport \"./Rewards/RewardsDistributor.sol\";\nimport \"@venusprotocol/governance-contracts/contracts/Governance/AccessControlManager.sol\";\nimport \"./MaxLoopsLimitHelper.sol\";\n\n/**\n * @title Comptroller Contract\n */\ncontract Comptroller is\n    Ownable2StepUpgradeable,\n    AccessControlledV8,\n    ComptrollerStorage,\n    ComptrollerInterface,\n    ExponentialNoError,\n    MaxLoopsLimitHelper\n{\n    // PoolRegistry, immutable to save on gas\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address public immutable poolRegistry;\n\n    /// @notice Emitted when an account enters a market\n    event MarketEntered(VToken vToken, address account);\n\n    /// @notice Emitted when an account exits a market\n    event MarketExited(VToken vToken, address account);\n\n    /// @notice Emitted when close factor is changed by admin\n    event NewCloseFactor(uint256 oldCloseFactorMantissa, uint256 newCloseFactorMantissa);\n\n    /// @notice Emitted when a collateral factor is changed by admin\n    event NewCollateralFactor(VToken vToken, uint256 oldCollateralFactorMantissa, uint256 newCollateralFactorMantissa);\n\n    /// @notice Emitted when liquidation threshold is changed by admin\n    event NewLiquidationThreshold(\n        VToken vToken,\n        uint256 oldLiquidationThresholdMantissa,\n        uint256 newLiquidationThresholdMantissa\n    );\n\n    /// @notice Emitted when liquidation incentive is changed by admin\n    event NewLiquidationIncentive(uint256 oldLiquidationIncentiveMantissa, uint256 newLiquidationIncentiveMantissa);\n\n    /// @notice Emitted when price oracle is changed\n    event NewPriceOracle(PriceOracle oldPriceOracle, PriceOracle newPriceOracle);\n\n    /// @notice Emitted when an action is paused on a market\n    event ActionPausedMarket(VToken vToken, Action action, bool pauseState);\n\n    /// @notice Emitted when borrow cap for a vToken is changed\n    event NewBorrowCap(VToken indexed vToken, uint256 newBorrowCap);\n\n    /// @notice Emitted when the collateral threshold (in USD) for non-batch liquidations is changed\n    event NewMinLiquidatableCollateral(uint256 oldMinLiquidatableCollateral, uint256 newMinLiquidatableCollateral);\n\n    /// @notice Emitted when supply cap for a vToken is changed\n    event NewSupplyCap(VToken indexed vToken, uint256 newSupplyCap);\n\n    /// @notice Emitted when a rewards distributor is added\n    event NewRewardsDistributor(address indexed rewardsDistributor);\n\n    /// @notice Emitted when a market is supported\n    event MarketSupported(VToken vToken);\n\n    /// @notice Thrown when collateral factor exceeds the upper bound\n    error InvalidCollateralFactor();\n\n    /// @notice Thrown when liquidation threshold exceeds the collateral factor\n    error InvalidLiquidationThreshold();\n\n    /// @notice Thrown when the action is only available to specific sender, but the real sender was different\n    error UnexpectedSender(address expectedSender, address actualSender);\n\n    /// @notice Thrown when the oracle returns an invalid price for some asset\n    error PriceError(address vToken);\n\n    /// @notice Thrown if VToken unexpectedly returned a nonzero error code while trying to get account snapshot\n    error SnapshotError(address vToken, address user);\n\n    /// @notice Thrown when the market is not listed\n    error MarketNotListed(address market);\n\n    /// @notice Thrown when a market has an unexpected comptroller\n    error ComptrollerMismatch();\n\n    /**\n     * @notice Throwed during the liquidation if user's total collateral amount is lower than\n     *   a predefined threshold. In this case only batch liquidations (either liquidateAccount\n     *   or healAccount) are available.\n     */\n    error MinimalCollateralViolated(uint256 expectedGreaterThan, uint256 actual);\n    error CollateralExceedsThreshold(uint256 expectedLessThanOrEqualTo, uint256 actual);\n    error InsufficientCollateral(uint256 collateralToSeize, uint256 availableCollateral);\n\n    /// @notice Thrown when the account doesn't have enough liquidity to redeem or borrow\n    error InsufficientLiquidity();\n\n    /// @notice Thrown when trying to liquidate a healthy account\n    error InsufficientShortfall();\n\n    /// @notice Thrown when trying to repay more than allowed by close factor\n    error TooMuchRepay();\n\n    /// @notice Thrown if the user is trying to exit a market in which they have an outstanding debt\n    error NonzeroBorrowBalance();\n\n    /// @notice Thrown when trying to perform an action that is paused\n    error ActionPaused(address market, Action action);\n\n    /// @notice Thrown when trying to add a market that is already listed\n    error MarketAlreadyListed(address market);\n\n    /// @notice Thrown if the supply cap is exceeded\n    error SupplyCapExceeded(address market, uint256 cap);\n\n    /// @notice Thrown if the borrow cap is exceeded\n    error BorrowCapExceeded(address market, uint256 cap);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address poolRegistry_) {\n        require(poolRegistry_ != address(0), \"invalid pool registry address\");\n\n        poolRegistry = poolRegistry_;\n        _disableInitializers();\n    }\n\n    /**\n     * @param loopLimit Limit for the loops can iterate to avoid the DOS\n     * @param accessControlManager Access control manager contract address\n     */\n    function initialize(uint256 loopLimit, address accessControlManager) external initializer {\n        __Ownable2Step_init();\n        __AccessControlled_init_unchained(accessControlManager);\n\n        _setMaxLoopsLimit(loopLimit);\n    }\n\n    /**\n     * @notice Add assets to be included in account liquidity calculation; enabling them to be used as collateral\n     * @param vTokens The list of addresses of the vToken markets to be enabled\n     * @return errors An array of NO_ERROR for compatibility with Venus core tooling\n     * @custom:event MarketEntered is emitted for each market on success\n     * @custom:error ActionPaused error is thrown if entering any of the markets is paused\n     * @custom:error MarketNotListed error is thrown if any of the markets is not listed\n     * @custom:access Not restricted\n     */\n    function enterMarkets(address[] memory vTokens) external override returns (uint256[] memory) {\n        uint256 len = vTokens.length;\n\n        uint256 accountAssetsLen = accountAssets[msg.sender].length;\n\n        _ensureMaxLoops(accountAssetsLen + len);\n\n        uint256[] memory results = new uint256[](len);\n        for (uint256 i; i < len; ++i) {\n            VToken vToken = VToken(vTokens[i]);\n\n            _addToMarket(vToken, msg.sender);\n            results[i] = NO_ERROR;\n        }\n\n        return results;\n    }\n\n    /**\n     * @notice Removes asset from sender's account liquidity calculation; disabling them as collateral\n     * @dev Sender must not have an outstanding borrow balance in the asset,\n     *  or be providing necessary collateral for an outstanding borrow.\n     * @param vTokenAddress The address of the asset to be removed\n     * @return error Always NO_ERROR for compatibility with Venus core tooling\n     * @custom:event MarketExited is emitted on success\n     * @custom:error ActionPaused error is thrown if exiting the market is paused\n     * @custom:error NonzeroBorrowBalance error is thrown if the user has an outstanding borrow in this market\n     * @custom:error MarketNotListed error is thrown when the market is not listed\n     * @custom:error InsufficientLiquidity error is thrown if exiting the market would lead to user's insolvency\n     * @custom:error SnapshotError is thrown if some vToken fails to return the account's supply and borrows\n     * @custom:error PriceError is thrown if the oracle returns an incorrect price for some asset\n     * @custom:access Not restricted\n     */\n    function exitMarket(address vTokenAddress) external override returns (uint256) {\n        _checkActionPauseState(vTokenAddress, Action.EXIT_MARKET);\n        VToken vToken = VToken(vTokenAddress);\n        /* Get sender tokensHeld and amountOwed underlying from the vToken */\n        (uint256 tokensHeld, uint256 amountOwed, ) = _safeGetAccountSnapshot(vToken, msg.sender);\n\n        /* Fail if the sender has a borrow balance */\n        if (amountOwed != 0) {\n            revert NonzeroBorrowBalance();\n        }\n\n        /* Fail if the sender is not permitted to redeem all of their tokens */\n        _checkRedeemAllowed(vTokenAddress, msg.sender, tokensHeld);\n\n        Market storage marketToExit = markets[address(vToken)];\n\n        /* Return true if the sender is not already ‘in’ the market */\n        if (!marketToExit.accountMembership[msg.sender]) {\n            return NO_ERROR;\n        }\n\n        /* Set vToken account membership to false */\n        delete marketToExit.accountMembership[msg.sender];\n\n        /* Delete vToken from the account’s list of assets */\n        // load into memory for faster iteration\n        VToken[] memory userAssetList = accountAssets[msg.sender];\n        uint256 len = userAssetList.length;\n\n        uint256 assetIndex = len;\n        for (uint256 i; i < len; ++i) {\n            if (userAssetList[i] == vToken) {\n                assetIndex = i;\n                break;\n            }\n        }\n\n        // We *must* have found the asset in the list or our redundant data structure is broken\n        assert(assetIndex < len);\n\n        // copy last item in list to location of item to be removed, reduce length by 1\n        VToken[] storage storedList = accountAssets[msg.sender];\n        storedList[assetIndex] = storedList[storedList.length - 1];\n        storedList.pop();\n\n        emit MarketExited(vToken, msg.sender);\n\n        return NO_ERROR;\n    }\n\n    /*** Policy Hooks ***/\n\n    /**\n     * @notice Checks if the account should be allowed to mint tokens in the given market\n     * @param vToken The market to verify the mint against\n     * @param minter The account which would get the minted tokens\n     * @param mintAmount The amount of underlying being supplied to the market in exchange for tokens\n     * @custom:error ActionPaused error is thrown if supplying to this market is paused\n     * @custom:error MarketNotListed error is thrown when the market is not listed\n     * @custom:error SupplyCapExceeded error is thrown if the total supply exceeds the cap after minting\n     * @custom:access Not restricted\n     */\n    function preMintHook(\n        address vToken,\n        address minter,\n        uint256 mintAmount\n    ) external override {\n        _checkActionPauseState(vToken, Action.MINT);\n\n        if (!markets[vToken].isListed) {\n            revert MarketNotListed(address(vToken));\n        }\n\n        uint256 supplyCap = supplyCaps[vToken];\n        // Skipping the cap check for uncapped coins to save some gas\n        if (supplyCap != type(uint256).max) {\n            uint256 vTokenSupply = VToken(vToken).totalSupply();\n            Exp memory exchangeRate = Exp({ mantissa: VToken(vToken).exchangeRateStored() });\n            uint256 nextTotalSupply = mul_ScalarTruncateAddUInt(exchangeRate, vTokenSupply, mintAmount);\n            if (nextTotalSupply > supplyCap) {\n                revert SupplyCapExceeded(vToken, supplyCap);\n            }\n        }\n\n        // Keep the flywheel moving\n        uint256 rewardDistributorsCount = rewardsDistributors.length;\n\n        for (uint256 i; i < rewardDistributorsCount; ++i) {\n            rewardsDistributors[i].updateRewardTokenSupplyIndex(vToken);\n            rewardsDistributors[i].distributeSupplierRewardToken(vToken, minter);\n        }\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to redeem tokens in the given market\n     * @param vToken The market to verify the redeem against\n     * @param redeemer The account which would redeem the tokens\n     * @param redeemTokens The number of vTokens to exchange for the underlying asset in the market\n     * @custom:error ActionPaused error is thrown if withdrawals are paused in this market\n     * @custom:error MarketNotListed error is thrown when the market is not listed\n     * @custom:error InsufficientLiquidity error is thrown if the withdrawal would lead to user's insolvency\n     * @custom:error SnapshotError is thrown if some vToken fails to return the account's supply and borrows\n     * @custom:error PriceError is thrown if the oracle returns an incorrect price for some asset\n     * @custom:access Not restricted\n     */\n    function preRedeemHook(\n        address vToken,\n        address redeemer,\n        uint256 redeemTokens\n    ) external override {\n        _checkActionPauseState(vToken, Action.REDEEM);\n        oracle.updatePrice(vToken);\n        _checkRedeemAllowed(vToken, redeemer, redeemTokens);\n\n        // Keep the flywheel moving\n        uint256 rewardDistributorsCount = rewardsDistributors.length;\n\n        for (uint256 i; i < rewardDistributorsCount; ++i) {\n            rewardsDistributors[i].updateRewardTokenSupplyIndex(vToken);\n            rewardsDistributors[i].distributeSupplierRewardToken(vToken, redeemer);\n        }\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\n     * @param vToken The market to verify the borrow against\n     * @param borrower The account which would borrow the asset\n     * @param borrowAmount The amount of underlying the account would borrow\n     * @custom:error ActionPaused error is thrown if borrowing is paused in this market\n     * @custom:error MarketNotListed error is thrown when the market is not listed\n     * @custom:error InsufficientLiquidity error is thrown if there is not enough collateral to borrow\n     * @custom:error BorrowCapExceeded is thrown if the borrow cap will be exceeded should this borrow succeed\n     * @custom:error SnapshotError is thrown if some vToken fails to return the account's supply and borrows\n     * @custom:error PriceError is thrown if the oracle returns an incorrect price for some asset\n     * @custom:access Not restricted if vToken is enabled as collateral, otherwise only vToken\n     */\n    /// disable-eslint\n    function preBorrowHook(\n        address vToken,\n        address borrower,\n        uint256 borrowAmount\n    ) external override {\n        _checkActionPauseState(vToken, Action.BORROW);\n\n        oracle.updatePrice(vToken);\n\n        if (!markets[vToken].isListed) {\n            revert MarketNotListed(address(vToken));\n        }\n\n        if (!markets[vToken].accountMembership[borrower]) {\n            // only vTokens may call borrowAllowed if borrower not in market\n            _checkSenderIs(vToken);\n\n            // attempt to add borrower to the market or revert\n            _addToMarket(VToken(msg.sender), borrower);\n        }\n\n        if (oracle.getUnderlyingPrice(vToken) == 0) {\n            revert PriceError(address(vToken));\n        }\n\n        uint256 borrowCap = borrowCaps[vToken];\n        // Skipping the cap check for uncapped coins to save some gas\n        if (borrowCap != type(uint256).max) {\n            uint256 totalBorrows = VToken(vToken).totalBorrows();\n            uint256 nextTotalBorrows = totalBorrows + borrowAmount;\n            if (nextTotalBorrows > borrowCap) {\n                revert BorrowCapExceeded(vToken, borrowCap);\n            }\n        }\n\n        AccountLiquiditySnapshot memory snapshot = _getHypotheticalLiquiditySnapshot(\n            borrower,\n            VToken(vToken),\n            0,\n            borrowAmount,\n            _getCollateralFactor\n        );\n\n        if (snapshot.shortfall > 0) {\n            revert InsufficientLiquidity();\n        }\n\n        Exp memory borrowIndex = Exp({ mantissa: VToken(vToken).borrowIndex() });\n\n        // Keep the flywheel moving\n        uint256 rewardDistributorsCount = rewardsDistributors.length;\n\n        for (uint256 i; i < rewardDistributorsCount; ++i) {\n            rewardsDistributors[i].updateRewardTokenBorrowIndex(vToken, borrowIndex);\n            rewardsDistributors[i].distributeBorrowerRewardToken(vToken, borrower, borrowIndex);\n        }\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to repay a borrow in the given market\n     * @param vToken The market to verify the repay against\n     * @param borrower The account which would borrowed the asset\n     * @custom:error ActionPaused error is thrown if repayments are paused in this market\n     * @custom:error MarketNotListed error is thrown when the market is not listed\n     * @custom:access Not restricted\n     */\n    function preRepayHook(address vToken, address borrower) external override {\n        _checkActionPauseState(vToken, Action.REPAY);\n\n        oracle.updatePrice(vToken);\n\n        if (!markets[vToken].isListed) {\n            revert MarketNotListed(address(vToken));\n        }\n\n        // Keep the flywheel moving\n        uint256 rewardDistributorsCount = rewardsDistributors.length;\n\n        for (uint256 i; i < rewardDistributorsCount; ++i) {\n            Exp memory borrowIndex = Exp({ mantissa: VToken(vToken).borrowIndex() });\n            rewardsDistributors[i].updateRewardTokenBorrowIndex(vToken, borrowIndex);\n            rewardsDistributors[i].distributeBorrowerRewardToken(vToken, borrower, borrowIndex);\n        }\n    }\n\n    /**\n     * @notice Checks if the liquidation should be allowed to occur\n     * @param vTokenBorrowed Asset which was borrowed by the borrower\n     * @param vTokenCollateral Asset which was used as collateral and will be seized\n     * @param borrower The address of the borrower\n     * @param repayAmount The amount of underlying being repaid\n     * @param skipLiquidityCheck Allows the borrow to be liquidated regardless of the account liquidity\n     * @custom:error ActionPaused error is thrown if liquidations are paused in this market\n     * @custom:error MarketNotListed error is thrown if either collateral or borrowed token is not listed\n     * @custom:error TooMuchRepay error is thrown if the liquidator is trying to repay more than allowed by close factor\n     * @custom:error MinimalCollateralViolated is thrown if the users' total collateral is lower than the threshold for non-batch liquidations\n     * @custom:error InsufficientShortfall is thrown when trying to liquidate a healthy account\n     * @custom:error SnapshotError is thrown if some vToken fails to return the account's supply and borrows\n     * @custom:error PriceError is thrown if the oracle returns an incorrect price for some asset\n     */\n    function preLiquidateHook(\n        address vTokenBorrowed,\n        address vTokenCollateral,\n        address borrower,\n        uint256 repayAmount,\n        bool skipLiquidityCheck\n    ) external override {\n        // Pause Action.LIQUIDATE on BORROWED TOKEN to prevent liquidating it.\n        // If we want to pause liquidating to vTokenCollateral, we should pause\n        // Action.SEIZE on it\n        _checkActionPauseState(vTokenBorrowed, Action.LIQUIDATE);\n\n        oracle.updatePrice(vTokenBorrowed);\n        oracle.updatePrice(vTokenCollateral);\n\n        if (!markets[vTokenBorrowed].isListed) {\n            revert MarketNotListed(address(vTokenBorrowed));\n        }\n        if (!markets[vTokenCollateral].isListed) {\n            revert MarketNotListed(address(vTokenCollateral));\n        }\n\n        uint256 borrowBalance = VToken(vTokenBorrowed).borrowBalanceStored(borrower);\n\n        /* Allow accounts to be liquidated if the market is deprecated or it is a forced liquidation */\n        if (skipLiquidityCheck || isDeprecated(VToken(vTokenBorrowed))) {\n            if (repayAmount > borrowBalance) {\n                revert TooMuchRepay();\n            }\n            return;\n        }\n\n        /* The borrower must have shortfall and collateral > threshold in order to be liquidatable */\n        AccountLiquiditySnapshot memory snapshot = _getCurrentLiquiditySnapshot(borrower, _getLiquidationThreshold);\n\n        if (snapshot.totalCollateral <= minLiquidatableCollateral) {\n            /* The liquidator should use either liquidateAccount or healAccount */\n            revert MinimalCollateralViolated(minLiquidatableCollateral, snapshot.totalCollateral);\n        }\n\n        if (snapshot.shortfall == 0) {\n            revert InsufficientShortfall();\n        }\n\n        /* The liquidator may not repay more than what is allowed by the closeFactor */\n        uint256 maxClose = mul_ScalarTruncate(Exp({ mantissa: closeFactorMantissa }), borrowBalance);\n        if (repayAmount > maxClose) {\n            revert TooMuchRepay();\n        }\n    }\n\n    /**\n     * @notice Checks if the seizing of assets should be allowed to occur\n     * @param vTokenCollateral Asset which was used as collateral and will be seized\n     * @param seizerContract Contract that tries to seize the asset (either borrowed vToken or Comptroller)\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @custom:error ActionPaused error is thrown if seizing this type of collateral is paused\n     * @custom:error MarketNotListed error is thrown if either collateral or borrowed token is not listed\n     * @custom:error ComptrollerMismatch error is when seizer contract or seized asset belong to different pools\n     * @custom:access Not restricted\n     */\n    function preSeizeHook(\n        address vTokenCollateral,\n        address seizerContract,\n        address liquidator,\n        address borrower\n    ) external override {\n        // Pause Action.SEIZE on COLLATERAL to prevent seizing it.\n        // If we want to pause liquidating vTokenBorrowed, we should pause\n        // Action.LIQUIDATE on it\n        _checkActionPauseState(vTokenCollateral, Action.SEIZE);\n\n        if (!markets[vTokenCollateral].isListed) {\n            revert MarketNotListed(vTokenCollateral);\n        }\n\n        if (seizerContract == address(this)) {\n            // If Comptroller is the seizer, just check if collateral's comptroller\n            // is equal to the current address\n            if (address(VToken(vTokenCollateral).comptroller()) != address(this)) {\n                revert ComptrollerMismatch();\n            }\n        } else {\n            // If the seizer is not the Comptroller, check that the seizer is a\n            // listed market, and that the markets' comptrollers match\n            if (!markets[seizerContract].isListed) {\n                revert MarketNotListed(seizerContract);\n            }\n            if (VToken(vTokenCollateral).comptroller() != VToken(seizerContract).comptroller()) {\n                revert ComptrollerMismatch();\n            }\n        }\n\n        // Keep the flywheel moving\n        uint256 rewardDistributorsCount = rewardsDistributors.length;\n\n        for (uint256 i; i < rewardDistributorsCount; ++i) {\n            rewardsDistributors[i].updateRewardTokenSupplyIndex(vTokenCollateral);\n            rewardsDistributors[i].distributeSupplierRewardToken(vTokenCollateral, borrower);\n            rewardsDistributors[i].distributeSupplierRewardToken(vTokenCollateral, liquidator);\n        }\n    }\n\n    /**\n     * @notice Checks if the account should be allowed to transfer tokens in the given market\n     * @param vToken The market to verify the transfer against\n     * @param src The account which sources the tokens\n     * @param dst The account which receives the tokens\n     * @param transferTokens The number of vTokens to transfer\n     * @custom:error ActionPaused error is thrown if withdrawals are paused in this market\n     * @custom:error MarketNotListed error is thrown when the market is not listed\n     * @custom:error InsufficientLiquidity error is thrown if the withdrawal would lead to user's insolvency\n     * @custom:error SnapshotError is thrown if some vToken fails to return the account's supply and borrows\n     * @custom:error PriceError is thrown if the oracle returns an incorrect price for some asset\n     * @custom:access Not restricted\n     */\n    function preTransferHook(\n        address vToken,\n        address src,\n        address dst,\n        uint256 transferTokens\n    ) external override {\n        _checkActionPauseState(vToken, Action.TRANSFER);\n\n        oracle.updatePrice(vToken);\n\n        // Currently the only consideration is whether or not\n        //  the src is allowed to redeem this many tokens\n        _checkRedeemAllowed(vToken, src, transferTokens);\n\n        // Keep the flywheel moving\n        uint256 rewardDistributorsCount = rewardsDistributors.length;\n\n        for (uint256 i; i < rewardDistributorsCount; ++i) {\n            rewardsDistributors[i].updateRewardTokenSupplyIndex(vToken);\n            rewardsDistributors[i].distributeSupplierRewardToken(vToken, src);\n            rewardsDistributors[i].distributeSupplierRewardToken(vToken, dst);\n        }\n    }\n\n    /*** Pool-level operations ***/\n\n    /**\n     * @notice Seizes all the remaining collateral, makes msg.sender repay the existing\n     *   borrows, and treats the rest of the debt as bad debt (for each market).\n     *   The sender has to repay a certain percentage of the debt, computed as\n     *   collateral / (borrows * liquidationIncentive).\n     * @param user account to heal\n     * @custom:error CollateralExceedsThreshold error is thrown when the collateral is too big for healing\n     * @custom:error SnapshotError is thrown if some vToken fails to return the account's supply and borrows\n     * @custom:error PriceError is thrown if the oracle returns an incorrect price for some asset\n     * @custom:access Not restricted\n     */\n    function healAccount(address user) external {\n        VToken[] memory userAssets = accountAssets[user];\n        uint256 userAssetsCount = userAssets.length;\n\n        address liquidator = msg.sender;\n        // We need all user's markets to be fresh for the computations to be correct\n        for (uint256 i; i < userAssetsCount; ++i) {\n            userAssets[i].accrueInterest();\n            oracle.updatePrice(address(userAssets[i]));\n        }\n\n        AccountLiquiditySnapshot memory snapshot = _getCurrentLiquiditySnapshot(user, _getLiquidationThreshold);\n\n        if (snapshot.totalCollateral > minLiquidatableCollateral) {\n            revert CollateralExceedsThreshold(minLiquidatableCollateral, snapshot.totalCollateral);\n        }\n\n        if (snapshot.shortfall == 0) {\n            revert InsufficientShortfall();\n        }\n\n        // percentage = collateral / (borrows * liquidation incentive)\n        Exp memory collateral = Exp({ mantissa: snapshot.totalCollateral });\n        Exp memory scaledBorrows = mul_(\n            Exp({ mantissa: snapshot.borrows }),\n            Exp({ mantissa: liquidationIncentiveMantissa })\n        );\n\n        Exp memory percentage = div_(collateral, scaledBorrows);\n        if (lessThanExp(Exp({ mantissa: mantissaOne }), percentage)) {\n            revert CollateralExceedsThreshold(scaledBorrows.mantissa, collateral.mantissa);\n        }\n\n        for (uint256 i; i < userAssetsCount; ++i) {\n            VToken market = userAssets[i];\n\n            (uint256 tokens, uint256 borrowBalance, ) = _safeGetAccountSnapshot(market, user);\n            uint256 repaymentAmount = mul_ScalarTruncate(percentage, borrowBalance);\n\n            // Seize the entire collateral\n            if (tokens != 0) {\n                market.seize(liquidator, user, tokens);\n            }\n            // Repay a certain percentage of the borrow, forgive the rest\n            if (borrowBalance != 0) {\n                market.healBorrow(liquidator, user, repaymentAmount);\n            }\n        }\n    }\n\n    /**\n     * @notice Liquidates all borrows of the borrower. Callable only if the collateral is less than\n     *   a predefined threshold, and the account collateral can be seized to cover all borrows. If\n     *   the collateral is higher than the threshold, use regular liquidations. If the collateral is\n     *   below the threshold, and the account is insolvent, use healAccount.\n     * @param borrower the borrower address\n     * @param orders an array of liquidation orders\n     * @custom:error CollateralExceedsThreshold error is thrown when the collateral is too big for a batch liquidation\n     * @custom:error InsufficientCollateral error is thrown when there is not enough collateral to cover the debt\n     * @custom:error SnapshotError is thrown if some vToken fails to return the account's supply and borrows\n     * @custom:error PriceError is thrown if the oracle returns an incorrect price for some asset\n     * @custom:access Not restricted\n     */\n    function liquidateAccount(address borrower, LiquidationOrder[] calldata orders) external {\n        // We will accrue interest and update the oracle prices later during the liquidation\n\n        AccountLiquiditySnapshot memory snapshot = _getCurrentLiquiditySnapshot(borrower, _getLiquidationThreshold);\n\n        if (snapshot.totalCollateral > minLiquidatableCollateral) {\n            // You should use the regular vToken.liquidateBorrow(...) call\n            revert CollateralExceedsThreshold(minLiquidatableCollateral, snapshot.totalCollateral);\n        }\n\n        uint256 collateralToSeize = mul_ScalarTruncate(\n            Exp({ mantissa: liquidationIncentiveMantissa }),\n            snapshot.borrows\n        );\n        if (collateralToSeize >= snapshot.totalCollateral) {\n            // There is not enough collateral to seize. Use healBorrow to repay some part of the borrow\n            // and record bad debt.\n            revert InsufficientCollateral(collateralToSeize, snapshot.totalCollateral);\n        }\n\n        if (snapshot.shortfall == 0) {\n            revert InsufficientShortfall();\n        }\n\n        uint256 ordersCount = orders.length;\n\n        _ensureMaxLoops(ordersCount);\n\n        for (uint256 i; i < ordersCount; ++i) {\n            if (!markets[address(orders[i].vTokenBorrowed)].isListed) {\n                revert MarketNotListed(address(orders[i].vTokenBorrowed));\n            }\n            if (!markets[address(orders[i].vTokenCollateral)].isListed) {\n                revert MarketNotListed(address(orders[i].vTokenCollateral));\n            }\n\n            LiquidationOrder calldata order = orders[i];\n            order.vTokenBorrowed.forceLiquidateBorrow(\n                msg.sender,\n                borrower,\n                order.repayAmount,\n                order.vTokenCollateral,\n                true\n            );\n        }\n\n        VToken[] memory borrowMarkets = accountAssets[borrower];\n        uint256 marketsCount = borrowMarkets.length;\n\n        for (uint256 i; i < marketsCount; ++i) {\n            (, uint256 borrowBalance, ) = _safeGetAccountSnapshot(borrowMarkets[i], borrower);\n            require(borrowBalance == 0, \"Nonzero borrow balance after liquidation\");\n        }\n    }\n\n    /**\n     * @notice Sets the closeFactor to use when liquidating borrows\n     * @param newCloseFactorMantissa New close factor, scaled by 1e18\n     * @custom:event Emits NewCloseFactor on success\n     * @custom:access Only Governance\n     */\n    function setCloseFactor(uint256 newCloseFactorMantissa) external {\n        _checkAccessAllowed(\"setCloseFactor(uint256)\");\n        require(closeFactorMaxMantissa >= newCloseFactorMantissa, \"Close factor greater than maximum close factor\");\n        require(closeFactorMinMantissa <= newCloseFactorMantissa, \"Close factor smaller than minimum close factor\");\n\n        uint256 oldCloseFactorMantissa = closeFactorMantissa;\n        closeFactorMantissa = newCloseFactorMantissa;\n        emit NewCloseFactor(oldCloseFactorMantissa, closeFactorMantissa);\n    }\n\n    /**\n     * @notice Sets the collateralFactor for a market\n     * @dev This function is restricted by the AccessControlManager\n     * @param vToken The market to set the factor on\n     * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18\n     * @param newLiquidationThresholdMantissa The new liquidation threshold, scaled by 1e18\n     * @custom:event Emits NewCollateralFactor when collateral factor is updated\n     *    and NewLiquidationThreshold when liquidation threshold is updated\n     * @custom:error MarketNotListed error is thrown when the market is not listed\n     * @custom:error InvalidCollateralFactor error is thrown when collateral factor is too high\n     * @custom:error InvalidLiquidationThreshold error is thrown when liquidation threshold is lower than collateral factor\n     * @custom:error PriceError is thrown when the oracle returns an invalid price for the asset\n     * @custom:access Controlled by AccessControlManager\n     */\n    function setCollateralFac"
    }
  ]
}