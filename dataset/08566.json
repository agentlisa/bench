{
  "Title": "[N-04] Assembly Within `Supply.sol` and `Transfer.sol`",
  "Content": "\nThe following functions were implemented in assembly:\n\n*   [`Supply .mint`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Supply.sol#L23)\n*   [`Supply.burn`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Supply.sol#L113)\n*   [`Transfer.ERC20Transfer`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Transfer.sol#L18)\n*   [`Transfer.ERC721TransferFrom`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Transfer.sol#L222)\n*   [`Transfer.ERC1155TransferFrom`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Transfer.sol#L341)\n*   [`Transfer.ERC1155BatchTransferFrom`](https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/targets/Transfer.sol#L474)\n\nEven though assembly code was used for gas optimization, it reduces the readability (and future updatability) of the code.\n\n### Recommendation\n\nConsider eliminating all assembly code and re-implement them in Solidity to make the code significantly more clean.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-07-fractional",
  "Code": [
    {
      "filename": "src/targets/Supply.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {ISupply} from \"../interfaces/ISupply.sol\";\nimport {IVaultRegistry} from \"../interfaces/IVaultRegistry.sol\";\nimport \"../constants/Supply.sol\";\n\n/// @title Supply\n/// @author Fractional Art\n/// @notice Target contract for minting and burning fractional tokens\ncontract Supply is ISupply {\n    /// @notice Address of VaultRegistry contract\n    address immutable registry;\n\n    /// @notice Initializes registry contract\n    constructor(address _registry) {\n        registry = _registry;\n    }\n\n    /// @notice Mints fractional tokens\n    /// @param _to Target address\n    /// @param _value Transfer amount\n    function mint(address _to, uint256 _value) external {\n        // Utilize assembly to perform an optimized Vault Registry mint\n        address _registry = registry;\n\n        assembly {\n            // Write calldata to the free memory pointer, but restore it later.\n            let memPointer := mload(FREE_MEMORY_POINTER_SLOT)\n\n            // Write calldata into memory, starting with the function selector\n            mstore(REGISTRY_MINT_SIG_PTR, REGISTRY_MINT_SIGNATURE)\n            mstore(REGISTRY_MINT_TO_PRT, _to) // Append the \"_to\" argument\n            mstore(REGISTRY_MINT_VALUE_PTR, _value) // Append the \"_value\" argument\n\n            let success := call(\n                gas(),\n                _registry,\n                0,\n                REGISTRY_MINT_SIG_PTR,\n                REGISTRY_MINT_LENGTH,\n                0,\n                0\n            )\n\n            // If the mint reverted\n            if iszero(success) {\n                // If it returned a message, bubble it up as long as sufficient\n                // gas remains to do so:\n                if returndatasize() {\n                    // Ensure that sufficient gas is available to copy\n                    // returndata while expanding memory where necessary. Start\n                    // by computing word size of returndata & allocated memory.\n                    let returnDataWords := div(returndatasize(), ONE_WORD)\n\n                    // Note: use the free memory pointer in place of msize() to\n                    // work around a Yul warning that prevents accessing msize\n                    // directly when the IR pipeline is activated.\n                    let msizeWords := div(memPointer, ONE_WORD)\n\n                    // Next, compute the cost of the returndatacopy.\n                    let cost := mul(COST_PER_WORD, returnDataWords)\n\n                    // Then, compute cost of new memory allocation.\n                    if gt(returnDataWords, msizeWords) {\n                        cost := add(\n                            cost,\n                            add(\n                                mul(\n                                    sub(returnDataWords, msizeWords),\n                                    COST_PER_WORD\n                                ),\n                                div(\n                                    sub(\n                                        mul(returnDataWords, returnDataWords),\n                                        mul(msizeWords, msizeWords)\n                                    ),\n                                    MEMORY_EXPANSION_COEFFICIENT\n                                )\n                            )\n                        )\n                    }\n\n                    // Finally, add a small constant and compare to gas\n                    // remaining; bubble up the revert data if enough gas is\n                    // still available.\n                    if lt(add(cost, EXTRA_GAS_BUFFER), gas()) {\n                        // Copy returndata to memory; overwrite existing memory.\n                        returndatacopy(0, 0, returndatasize())\n\n                        // Revert, giving memory region with copied returndata.\n                        revert(0, returndatasize())\n                    }\n                }\n\n                // Otherwise revert with a generic error message\n                mstore(MINT_ERROR_SIG_PTR, MINT_ERROR_SIGNATURE)\n                mstore(MINT_ERROR_ACCOUNT_PTR, _to)\n                revert(MINT_ERROR_SIG_PTR, MINT_ERROR_LENGTH)\n            }\n\n            // Restore the original free memory pointer.\n            mstore(FREE_MEMORY_POINTER_SLOT, memPointer)\n\n            // Restore the zero slot to zero.\n            mstore(ZERO_SLOT, 0)\n        }\n    }\n\n    /// @notice Burns fractional tokens\n    /// @param _from Source address\n    /// @param _value Burn amount\n    function burn(address _from, uint256 _value) external {\n        // Utilize assembly to perform an optimized Vault Registry burn\n        address _registry = registry;\n\n        assembly {\n            // Write calldata to the free memory pointer, but restore it later.\n            let memPointer := mload(FREE_MEMORY_POINTER_SLOT)\n\n            // Write calldata into memory, starting with the function selector\n            mstore(REGISTRY_BURN_SIG_PTR, REGISTRY_BURN_SIGNATURE)\n            mstore(REGISTRY_BURN_FROM_PTR, _from) // Append the \"_from\" argument\n            mstore(REGISTRY_BURN_VALUE_PTR, _value) // Append the \"_value\" argument\n\n            let success := call(\n                gas(),\n                _registry,\n                0,\n                REGISTRY_BURN_SIG_PTR,\n                REGISTRY_BURN_LENGTH,\n                0,\n                0\n            )\n\n            // If the mint reverted\n            if iszero(success) {\n                // If it returned a message, bubble it up as long as sufficient\n                // gas remains to do so:\n                if returndatasize() {\n                    // Ensure that sufficient gas is available to copy\n                    // returndata while expanding memory where necessary. Start\n                    // by computing word size of returndata & allocated memory.\n                    let returnDataWords := div(returndatasize(), ONE_WORD)\n\n                    // Note: use the free memory pointer in place of msize() to\n                    // work around a Yul warning that prevents accessing msize\n                    // directly when the IR pipeline is activated.\n                    let msizeWords := div(memPointer, ONE_WORD)\n\n                    // Next, compute the cost of the returndatacopy.\n                    let cost := mul(COST_PER_WORD, returnDataWords)\n\n                    // Then, compute cost of new memory allocation.\n                    if gt(returnDataWords, msizeWords) {\n                        cost := add(\n                            cost,\n                            add(\n                                mul(\n                                    sub(returnDataWords, msizeWords),\n                                    COST_PER_WORD\n                                ),\n                                div(\n                                    sub(\n                                        mul(returnDataWords, returnDataWords),\n                                        mul(msizeWords, msizeWords)\n                                    ),\n                                    MEMORY_EXPANSION_COEFFICIENT\n                                )\n                            )\n                        )\n                    }\n\n                    // Finally, add a small constant and compare to gas\n                    // remaining; bubble up the revert data if enough gas is\n                    // still available.\n                    if lt(add(cost, EXTRA_GAS_BUFFER), gas()) {\n                        // Copy returndata to memory; overwrite existing memory.\n                        returndatacopy(0, 0, returndatasize())\n\n                        // Revert, giving memory region with copied returndata.\n                        revert(0, returndatasize())\n                    }\n                }\n\n                // Otherwise revert with a generic error message\n                mstore(BURN_ERROR_SIG_PTR, BURN_ERROR_SIGNATURE)\n                mstore(BURN_ERROR_ACCOUNT_PTR, _from)\n                revert(BURN_ERROR_SIG_PTR, BURN_ERROR_LENGTH)\n            }\n\n            // Restore the original free memory pointer.\n            mstore(FREE_MEMORY_POINTER_SLOT, memPointer)\n\n            // Restore the zero slot to zero.\n            mstore(ZERO_SLOT, 0)\n        }\n    }\n}"
    },
    {
      "filename": "src/targets/Supply.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {ISupply} from \"../interfaces/ISupply.sol\";\nimport {IVaultRegistry} from \"../interfaces/IVaultRegistry.sol\";\nimport \"../constants/Supply.sol\";\n\n/// @title Supply\n/// @author Fractional Art\n/// @notice Target contract for minting and burning fractional tokens\ncontract Supply is ISupply {\n    /// @notice Address of VaultRegistry contract\n    address immutable registry;\n\n    /// @notice Initializes registry contract\n    constructor(address _registry) {\n        registry = _registry;\n    }\n\n    /// @notice Mints fractional tokens\n    /// @param _to Target address\n    /// @param _value Transfer amount\n    function mint(address _to, uint256 _value) external {\n        // Utilize assembly to perform an optimized Vault Registry mint\n        address _registry = registry;\n\n        assembly {\n            // Write calldata to the free memory pointer, but restore it later.\n            let memPointer := mload(FREE_MEMORY_POINTER_SLOT)\n\n            // Write calldata into memory, starting with the function selector\n            mstore(REGISTRY_MINT_SIG_PTR, REGISTRY_MINT_SIGNATURE)\n            mstore(REGISTRY_MINT_TO_PRT, _to) // Append the \"_to\" argument\n            mstore(REGISTRY_MINT_VALUE_PTR, _value) // Append the \"_value\" argument\n\n            let success := call(\n                gas(),\n                _registry,\n                0,\n                REGISTRY_MINT_SIG_PTR,\n                REGISTRY_MINT_LENGTH,\n                0,\n                0\n            )\n\n            // If the mint reverted\n            if iszero(success) {\n                // If it returned a message, bubble it up as long as sufficient\n                // gas remains to do so:\n                if returndatasize() {\n                    // Ensure that sufficient gas is available to copy\n                    // returndata while expanding memory where necessary. Start\n                    // by computing word size of returndata & allocated memory.\n                    let returnDataWords := div(returndatasize(), ONE_WORD)\n\n                    // Note: use the free memory pointer in place of msize() to\n                    // work around a Yul warning that prevents accessing msize\n                    // directly when the IR pipeline is activated.\n                    let msizeWords := div(memPointer, ONE_WORD)\n\n                    // Next, compute the cost of the returndatacopy.\n                    let cost := mul(COST_PER_WORD, returnDataWords)\n\n                    // Then, compute cost of new memory allocation.\n                    if gt(returnDataWords, msizeWords) {\n                        cost := add(\n                            cost,\n                            add(\n                                mul(\n                                    sub(returnDataWords, msizeWords),\n                                    COST_PER_WORD\n                                ),\n                                div(\n                                    sub(\n                                        mul(returnDataWords, returnDataWords),\n                                        mul(msizeWords, msizeWords)\n                                    ),\n                                    MEMORY_EXPANSION_COEFFICIENT\n                                )\n                            )\n                        )\n                    }\n\n                    // Finally, add a small constant and compare to gas\n                    // remaining; bubble up the revert data if enough gas is\n                    // still available.\n                    if lt(add(cost, EXTRA_GAS_BUFFER), gas()) {\n                        // Copy returndata to memory; overwrite existing memory.\n                        returndatacopy(0, 0, returndatasize())\n\n                        // Revert, giving memory region with copied returndata.\n                        revert(0, returndatasize())\n                    }\n                }\n\n                // Otherwise revert with a generic error message\n                mstore(MINT_ERROR_SIG_PTR, MINT_ERROR_SIGNATURE)\n                mstore(MINT_ERROR_ACCOUNT_PTR, _to)\n                revert(MINT_ERROR_SIG_PTR, MINT_ERROR_LENGTH)\n            }\n\n            // Restore the original free memory pointer.\n            mstore(FREE_MEMORY_POINTER_SLOT, memPointer)\n\n            // Restore the zero slot to zero.\n            mstore(ZERO_SLOT, 0)\n        }\n    }\n\n    /// @notice Burns fractional tokens\n    /// @param _from Source address\n    /// @param _value Burn amount\n    function burn(address _from, uint256 _value) external {\n        // Utilize assembly to perform an optimized Vault Registry burn\n        address _registry = registry;\n\n        assembly {\n            // Write calldata to the free memory pointer, but restore it later.\n            let memPointer := mload(FREE_MEMORY_POINTER_SLOT)\n\n            // Write calldata into memory, starting with the function selector\n            mstore(REGISTRY_BURN_SIG_PTR, REGISTRY_BURN_SIGNATURE)\n            mstore(REGISTRY_BURN_FROM_PTR, _from) // Append the \"_from\" argument\n            mstore(REGISTRY_BURN_VALUE_PTR, _value) // Append the \"_value\" argument\n\n            let success := call(\n                gas(),\n                _registry,\n                0,\n                REGISTRY_BURN_SIG_PTR,\n                REGISTRY_BURN_LENGTH,\n                0,\n                0\n            )\n\n            // If the mint reverted\n            if iszero(success) {\n                // If it returned a message, bubble it up as long as sufficient\n                // gas remains to do so:\n                if returndatasize() {\n                    // Ensure that sufficient gas is available to copy\n                    // returndata while expanding memory where necessary. Start\n                    // by computing word size of returndata & allocated memory.\n                    let returnDataWords := div(returndatasize(), ONE_WORD)\n\n                    // Note: use the free memory pointer in place of msize() to\n                    // work around a Yul warning that prevents accessing msize\n                    // directly when the IR pipeline is activated.\n                    let msizeWords := div(memPointer, ONE_WORD)\n\n                    // Next, compute the cost of the returndatacopy.\n                    let cost := mul(COST_PER_WORD, returnDataWords)\n\n                    // Then, compute cost of new memory allocation.\n                    if gt(returnDataWords, msizeWords) {\n                        cost := add(\n                            cost,\n                            add(\n                                mul(\n                                    sub(returnDataWords, msizeWords),\n                                    COST_PER_WORD\n                                ),\n                                div(\n                                    sub(\n                                        mul(returnDataWords, returnDataWords),\n                                        mul(msizeWords, msizeWords)\n                                    ),\n                                    MEMORY_EXPANSION_COEFFICIENT\n                                )\n                            )\n                        )\n                    }\n\n                    // Finally, add a small constant and compare to gas\n                    // remaining; bubble up the revert data if enough gas is\n                    // still available.\n                    if lt(add(cost, EXTRA_GAS_BUFFER), gas()) {\n                        // Copy returndata to memory; overwrite existing memory.\n                        returndatacopy(0, 0, returndatasize())\n\n                        // Revert, giving memory region with copied returndata.\n                        revert(0, returndatasize())\n                    }\n                }\n\n                // Otherwise revert with a generic error message\n                mstore(BURN_ERROR_SIG_PTR, BURN_ERROR_SIGNATURE)\n                mstore(BURN_ERROR_ACCOUNT_PTR, _from)\n                revert(BURN_ERROR_SIG_PTR, BURN_ERROR_LENGTH)\n            }\n\n            // Restore the original free memory pointer.\n            mstore(FREE_MEMORY_POINTER_SLOT, memPointer)\n\n            // Restore the zero slot to zero.\n            mstore(ZERO_SLOT, 0)\n        }\n    }\n}"
    },
    {
      "filename": "src/targets/Transfer.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IERC20} from \"../interfaces/IERC20.sol\";\nimport {IERC721} from \"../interfaces/IERC721.sol\";\nimport {IERC1155} from \"../interfaces/IERC1155.sol\";\nimport {ITransfer} from \"../interfaces/ITransfer.sol\";\nimport \"../constants/Transfer.sol\";\n\n/// @title Transfer\n/// @author Fractional Art\n/// @notice Target contract for transferring fungible and non-fungible tokens\ncontract Transfer is ITransfer {\n    /// @notice Transfers an ERC-20 token\n    /// @param _token Address of the token\n    /// @param _to Target address\n    /// @param _amount Transfer amount\n    function ERC20Transfer(\n        address _token,\n        address _to,\n        uint256 _amount\n    ) external {\n        // Utilize assembly to perform an optimized ERC20 token transfer.\n        assembly {\n            // Write calldata to the free memory pointer, but restore it later.\n            let memPointer := mload(FREE_MEMORY_POINTER_SLOT)\n\n            // Write calldata into memory, starting with function selector.\n            mstore(ERC20_TRANSFER_SIG_PTR, ERC20_TRANSFER_SIGNATURE)\n            mstore(ERC20_TRANSFER_TO_PTR, _to) // Append the \"_to\" argument.\n            mstore(ERC20_TRANSFER_AMOUNT_PTR, _amount) // Append the \"_amount\" argument.\n\n            // Make call & copy up to 32 bytes of return data to scratch space.\n            // Scratch space does not need to be cleared ahead of time, as the\n            // subsequent check will ensure that either at least a full word of\n            // return data is received (in which case it will be overwritten) or\n            // that no data is received (in which case scratch space will be\n            // ignored) on a successful call to the given token.\n            let callStatus := call(\n                gas(),\n                _token,\n                0,\n                ERC20_TRANSFER_SIG_PTR,\n                ERC20_TRANSFER_LENGTH,\n                0,\n                ONE_WORD\n            )\n\n            // Determine whether transfer was successful using status & result.\n            let success := and(\n                // Set success to whether the call reverted, if not check it\n                // either returned exactly 1 (can't just be non-zero data), or\n                // had no return data.\n                or(\n                    and(eq(mload(0), 1), gt(returndatasize(), 31)),\n                    iszero(returndatasize())\n                ),\n                callStatus\n            )\n\n            // If the transfer failed or it returned nothing:\n            // Group these because they should be uncommon.\n            // Equivalent to `or(iszero(success), iszero(returndatasize()))`\n            // but after it's inverted for JUMPI this expression is cheaper.\n            if iszero(and(success, iszero(iszero(returndatasize())))) {\n                // If the token has no code or the transfer failed:\n                // Equivalent to `or(iszero(success), iszero(extcodesize(token)))`\n                // but after it's inverted for JUMPI this expression is cheaper.\n                if iszero(and(iszero(iszero(extcodesize(_token))), success)) {\n                    if iszero(success) {\n                        // If it was due to a revert:\n                        if iszero(callStatus) {\n                            // If it returned a message, bubble it up as long as\n                            // sufficient gas remains to do so:\n                            if returndatasize() {\n                                // Ensure that sufficient gas is available to\n                                // copy returndata while expanding memory where\n                                // necessary. Start by computing the word size\n                                // of returndata and allocated memory.\n                                let returnDataWords := div(\n                                    add(returndatasize(), ALMOST_ONE_WORD),\n                                    ONE_WORD\n                                )\n\n                                // Note: use the free memory pointer in place of\n                                // msize() to work around a Yul warning that\n                                // prevents accessing msize directly when the IR\n                                // pipeline is activated.\n                                let msizeWords := div(memPointer, ONE_WORD)\n\n                                // Next, compute the cost of the returndatacopy.\n                                let cost := mul(COST_PER_WORD, returnDataWords)\n\n                                // Then, compute cost of new memory allocation.\n                                if gt(returnDataWords, msizeWords) {\n                                    cost := add(\n                                        cost,\n                                        add(\n                                            mul(\n                                                sub(\n                                                    returnDataWords,\n                                                    msizeWords\n                                                ),\n                                                COST_PER_WORD\n                                            ),\n                                            div(\n                                                sub(\n                                                    mul(\n                                                        returnDataWords,\n                                                        returnDataWords\n                                                    ),\n                                                    mul(msizeWords, msizeWords)\n                                                ),\n                                                MEMORY_EXPANSION_COEFFICIENT\n                                            )\n                                        )\n                                    )\n                                }\n\n                                // Finally, add a small constant and compare to\n                                // gas remaining; bubble up the revert data if\n                                // enough gas is still available.\n                                if lt(add(cost, EXTRA_GAS_BUFFER), gas()) {\n                                    // Copy returndata to memory; overwrite\n                                    // existing memory.\n                                    returndatacopy(0, 0, returndatasize())\n\n                                    // Revert, specifying memory region with\n                                    // copied returndata.\n                                    revert(0, returndatasize())\n                                }\n                            }\n\n                            // Otherwise revert with a generic error message.\n                            mstore(\n                                TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_SIG_PTR,\n                                TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_SIGNATURE\n                            )\n                            mstore(\n                                TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_TOKEN_PTR,\n                                _token\n                            )\n                            // replace \"from\" argument with msg.sender\n                            mstore(\n                                TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_FROM_PTR,\n                                caller()\n                            )\n                            mstore(\n                                TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_TO_PTR,\n                                _to\n                            )\n                            mstore(\n                                TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_ID_PTR,\n                                0\n                            )\n                            mstore(\n                                TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_AMOUNT_PTR,\n                                _amount\n                            )\n                            revert(\n                                TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_SIG_PTR,\n                                TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_LENGTH\n                            )\n                        }\n\n                        // Otherwise revert with a message about the token\n                        // returning false.\n                        mstore(\n                            BAD_RETURN_VALUE_FROM_ERC20_ON_TRANSFER_ERROR_SIG_PTR,\n                            BAD_RETURN_VALUE_FROM_ERC20_ON_TRANSFER_ERROR_SIGNATURE\n                        )\n                        mstore(\n                            BAD_RETURN_VALUE_FROM_ERC20_ON_TRANSFER_ERROR_TOKEN_PTR,\n                            _token\n                        )\n                        // replace \"from\" argument with msg.sender\n                        mstore(\n                            BAD_RETURN_VALUE_FROM_ERC20_ON_TRANSFER_ERROR_FROM_PTR,\n                            caller()\n                        )\n                        mstore(\n                            BAD_RETURN_VALUE_FROM_ERC20_ON_TRANSFER_ERROR_TO_PTR,\n                            _to\n                        )\n                        mstore(\n                            BAD_RETURN_VALUE_FROM_ERC20_ON_TRANSFER_ERROR_AMOUNT_PTR,\n                            _amount\n                        )\n                        revert(\n                            BAD_RETURN_VALUE_FROM_ERC20_ON_TRANSFER_ERROR_SIG_PTR,\n                            BAD_RETURN_VALUE_FROM_ERC20_ON_TRANSFER_ERROR_LENGTH\n                        )\n                    }\n\n                    // Otherwise revert with error about token not having code:\n                    mstore(\n                        NO_CONTRACT_ERROR_SIG_PTR,\n                        NO_CONTRACT_ERROR_SIGNATURE\n                    )\n                    mstore(NO_CONTRACT_ERROR_TOKEN_PTR, _token)\n                    revert(NO_CONTRACT_ERROR_SIG_PTR, NO_CONTRACT_ERROR_LENGTH)\n                }\n\n                // Otherwise the token just returned nothing but otherwise\n                // succeeded; no need to optimize for this as it's not\n                // technically ERC20 compliant.\n            }\n\n            // Restore the original free memory pointer.\n            mstore(FREE_MEMORY_POINTER_SLOT, memPointer)\n\n            // Restore the zero slot to zero.\n            mstore(ZERO_SLOT, 0)\n        }\n    }\n\n    /// @notice Transfers an ERC-721 token\n    /// @param _token Address of the token\n    /// @param _from Source address\n    /// @param _to Target address\n    /// @param _tokenId ID of the token\n    function ERC721TransferFrom(\n        address _token,\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) external {\n        // Utilize assembly to perform an optimized ERC721 token transfer.\n        assembly {\n            // If the token has no code, revert.\n            if iszero(extcodesize(_token)) {\n                mstore(NO_CONTRACT_ERROR_SIG_PTR, NO_CONTRACT_ERROR_SIGNATURE)\n                mstore(NO_CONTRACT_ERROR_TOKEN_PTR, _token)\n                revert(NO_CONTRACT_ERROR_SIG_PTR, NO_CONTRACT_ERROR_LENGTH)\n            }\n\n            // Write calldata to free memory pointer (restore it later).\n            let memPointer := mload(FREE_MEMORY_POINTER_SLOT)\n\n            // Write calldata to memory starting with function selector.\n            mstore(ERC721_TRANSFER_SIG_PTR, ERC721_TRANSFER_FROM_SIGNATURE)\n            mstore(ERC721_TRANSFER_FROM_PTR, _from)\n            mstore(ERC721_TRANSFER_TO_PTR, _to)\n            mstore(ERC721_TRANSFER_ID_PTR, _tokenId)\n\n            // Perform the call, ignoring return data.\n            let success := call(\n                gas(),\n                _token,\n                0,\n                ERC721_TRANSFER_SIG_PTR,\n                ERC721_TRANSFER_LENGTH,\n                0,\n                0\n            )\n\n            // If the transfer reverted:\n            if iszero(success) {\n                // If it returned a message, bubble it up as long as sufficient\n                // gas remains to do so:\n                if returndatasize() {\n                    // Ensure that sufficient gas is available to copy\n                    // returndata while expanding memory where necessary. Start\n                    // by computing word size of returndata & allocated memory.\n                    // Round up to the nearest full word.\n                    let returnDataWords := div(\n                        add(returndatasize(), ALMOST_ONE_WORD),\n                        ONE_WORD\n                    )\n\n                    // Note: use the free memory pointer in place of msize() to\n                    // work around a Yul warning that prevents accessing msize\n                    // directly when the IR pipeline is activated.\n                    let msizeWords := div(memPointer, ONE_WORD)\n\n                    // Next, compute the cost of the returndatacopy.\n                    let cost := mul(COST_PER_WORD, returnDataWords)\n\n                    // Then, compute cost of new memory allocation.\n                    if gt(returnDataWords, msizeWords) {\n                        cost := add(\n                            cost,\n                            add(\n                                mul(\n                                    sub(returnDataWords, msizeWords),\n                                    COST_PER_WORD\n                                ),\n                                div(\n                                    sub(\n                                        mul(returnDataWords, returnDataWords),\n                                        mul(msizeWords, msizeWords)\n                                    ),\n                                    MEMORY_EXPANSION_COEFFICIENT\n                                )\n                            )\n                        )\n                    }\n\n                    // Finally, add a small constant and compare to gas\n                    // remaining; bubble up the revert data if enough gas is\n                    // still available.\n                    if lt(add(cost, EXTRA_GAS_BUFFER), gas()) {\n                        // Copy returndata to memory; overwrite existing memory.\n                        returndatacopy(0, 0, returndatasize())\n\n                        // Revert, giving memory region with copied returndata.\n                        revert(0, returndatasize())\n                    }\n                }\n\n                // Otherwise revert with a generic error message.\n                mstore(\n                    TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_SIG_PTR,\n                    TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_SIGNATURE\n                )\n                mstore(TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_TOKEN_PTR, _token)\n                mstore(TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_FROM_PTR, _from)\n                mstore(TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_TO_PTR, _to)\n                mstore(TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_ID_PTR, _tokenId)\n                mstore(TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_AMOUNT_PTR, 1)\n                revert(\n                    TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_SIG_PTR,\n                    TOKEN_TRANSFER_GENERTIC_FAILURE_ERROR_LENGTH\n                )\n            }\n\n            // Restore the original free memory pointer.\n            mstore(FREE_MEMORY_POINTER_SLOT, memPointer)\n\n            // Restore the zero slot to zero.\n            mstore(ZERO_SLOT, 0)\n        }\n    }\n\n    /// @notice Transfers an ERC-1155 token\n    /// @param _token token to transfer\n    /// @param _from Source address\n    /// @param _to Target address\n    /// @param _tokenId ID of the token type\n    /// @param _amount Transfer amount\n    function ERC1155TransferFrom(\n        address _token,\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        uint256 _amount\n    ) external {\n        // Utilize assembly to perform an optimized ERC1155 token transfer.\n        assembly {\n            // If the token has no code, revert.\n            if iszero(extcodesize(_token)) {\n                mstore(NO_CONTRACT_ERROR_S"
    }
  ]
}