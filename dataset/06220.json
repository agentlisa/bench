{
  "Title": "[H-09] `TricryptoLPStrategy.compoundAmount` always returns 0 because it's using staticall vs call",
  "Content": "\n[`compoundAmount`](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/05ba7108a83c66dada98bc5bc75cf18004f2a49b/contracts/curve/TricryptoLPStrategy.sol#L104-L107) will always try to sell 0 tokens because the `staticall` will revert since the function changes storage in `checkpoint`\n\nThis causes the `compoundAmount` to always return 0, which means that the Strategy is underpriced at all times allowing to Steal all Rewards via:\n\n*   Deposit to own a high % of ownerhsip in the strategy (shares are underpriced)\n*   Compound (shares socialize the yield to new total supply, we get the majority of that)\n*   Withdraw (lock in immediate profits without contributing to the Yield)\n\n### POC\n\nThis Test is done on the Arbitrum Tricrypto Gauge with Foundry\n\n1 is the flag value for a revert\n0 is the expected value\n\nWe get 1 when we use staticcall since the call reverts internally\nWe get 0 when we use call since the call doesn't\n\nThe comment in the Gauge Code is meant for usage off-chain, onChain you must accrue (or you could use a Accrue Then Revert Pattern, similar to UniV3 Quoter)\n\nNOTE: The code for Mainnet is the same, so it will result in the same impact <br><https://etherscan.io/address/0xDeFd8FdD20e0f34115C7018CCfb655796F6B2168#code#L375>\n\n### Foundry POC\n\n    forge test --match-test test_callWorks --rpc-url https://arb-mainnet.g.alchemy.com/v2/ALCHEMY_KEY\n\nWhich will revert since `checkpoint` is a non-view function and staticall reverts if any state is changed\n\n<https://arbiscan.io/address/0x555766f3da968ecbefa690ffd49a2ac02f47aa5f#code#L168>\n\n<details>\n\n```solidity\n\n// SPDX-License Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"forge-std/console2.sol\";\n\n\n\ncontract GaugeCallTest is Test {\n    \n    // Arb Tricrypto Gauge\n    address lpGauge = 0x555766f3da968ecBefa690Ffd49A2Ac02f47aa5f;\n\n    function setUp() public {}\n\n    function doTheCallView() internal returns (uint256) {\n        (bool success, bytes memory response) = address(lpGauge).staticcall(\n            abi.encodeWithSignature(\"claimable_tokens(address)\", address(this))\n        );\n\n        uint256 claimable = 1;\n        if (success) {\n            claimable = abi.decode(response, (uint256));\n        }\n\n        return claimable;\n    }\n    function doTheCallCall() internal returns (uint256) {\n        (bool success, bytes memory response) = address(lpGauge).call(\n            abi.encodeWithSignature(\"claimable_tokens(address)\", address(this))\n        );\n\n        uint256 claimable = 1;\n        if (success) {\n            claimable = abi.decode(response, (uint256));\n        }\n\n        return claimable;\n    }\n\n    function test_callWorks() public {\n        uint256 claimableView = doTheCallView();\n\n        assertEq(claimableView, 1); // Return 1 which is our flag for failure\n\n        uint256 claimableNonView = doTheCallCall();\n\n        assertEq(claimableNonView, 0); // Return 0 which means we read the proper value\n    }\n}\n```\n\n</details>\n\n### Mitigation Step\n\nYou should use a non-view function like inÂ `compound`\n\n**[cryptotechmaker (Tapioca) confirmed](https://github.com/code-423n4/2023-07-tapioca-findings/issues/1428#issuecomment-1707821609)**\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-07-tapioca",
  "Code": [
    {
      "filename": "contracts/curve/TricryptoLPStrategy.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"@boringcrypto/boring-solidity/contracts/BoringOwnable.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\n\nimport \"tapioca-sdk/dist/contracts/YieldBox/contracts/strategies/BaseStrategy.sol\";\nimport \"../../tapioca-periph/contracts/interfaces/ISwapper.sol\";\n\nimport \"./interfaces/ITricryptoLPGetter.sol\";\nimport \"./interfaces/ITricryptoLPGauge.sol\";\nimport \"./interfaces/ICurveMinter.sol\";\n\n/*\n\n__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\\\\\____/\\\\\\\\\\\\\\\\\\\\\\_______/\\\\\\\\\\_____________/\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\____        \n _\\///////\\\\\\/////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__\\/\\\\\\/////////\\\\\\_\\/////\\\\\\///______/\\\\\\///\\\\\\________/\\\\\\////////____/\\\\\\\\\\\\\\\\\\\\\\\\\\__       \n  _______\\/\\\\\\________/\\\\\\/////////\\\\\\_\\/\\\\\\_______\\/\\\\\\_____\\/\\\\\\_______/\\\\\\/__\\///\\\\\\____/\\\\\\/____________/\\\\\\/////////\\\\\\_      \n   _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/______\\/\\\\\\______/\\\\\\______\\//\\\\\\__/\\\\\\_____________\\/\\\\\\_______\\/\\\\\\_     \n    _______\\/\\\\\\_______\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\/////////________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_____________\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_    \n     _______\\/\\\\\\_______\\/\\\\\\/////////\\\\\\_\\/\\\\\\_________________\\/\\\\\\_____\\//\\\\\\______/\\\\\\__\\//\\\\\\____________\\/\\\\\\/////////\\\\\\_   \n      _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\_________________\\/\\\\\\______\\///\\\\\\__/\\\\\\_____\\///\\\\\\__________\\/\\\\\\_______\\/\\\\\\_  \n       _______\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\_\\/\\\\\\______________/\\\\\\\\\\\\\\\\\\\\\\____\\///\\\\\\\\\\/________\\////\\\\\\\\\\\\\\\\\\_\\/\\\\\\_______\\/\\\\\\_ \n        _______\\///________\\///________\\///__\\///______________\\///////////_______\\/////_____________\\/////////__\\///________\\///__\n*/\n\ncontract TricryptoLPStrategy is\n    BaseERC20Strategy,\n    BoringOwnable,\n    ReentrancyGuard\n{\n    using BoringERC20 for IERC20;\n\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n    IERC20 public immutable lpToken;\n    IERC20 public immutable wrappedNative;\n    ISwapper public swapper;\n\n    ITricryptoLPGauge public immutable lpGauge;\n    ICurveMinter public immutable minter;\n    ITricryptoLPGetter public lpGetter;\n    IERC20 public immutable rewardToken; //CRV token\n\n    /// @notice Queues tokens up to depositThreshold\n    /// @dev When the amount of tokens is greater than the threshold, a deposit operation to Curve is performed\n    uint256 public depositThreshold;\n\n    // ************** //\n    // *** EVENTS *** //\n    // ************** //\n    event MultiSwapper(address indexed _old, address indexed _new);\n    event DepositThreshold(uint256 _old, uint256 _new);\n    event LPGetterSet(address indexed _old, address indexed _new);\n    event AmountQueued(uint256 amount);\n    event AmountDeposited(uint256 amount);\n    event AmountWithdrawn(address indexed to, uint256 amount);\n\n    constructor(\n        IYieldBox _yieldBox,\n        address _token,\n        address _lpGauge,\n        address _lpGetter,\n        address _minter,\n        address _multiSwapper\n    ) BaseERC20Strategy(_yieldBox, ITricryptoLPGetter(_lpGetter).lpToken()) {\n        wrappedNative = IERC20(_token);\n        swapper = ISwapper(_multiSwapper);\n        lpGetter = ITricryptoLPGetter(_lpGetter);\n        lpGauge = ITricryptoLPGauge(_lpGauge);\n        minter = ICurveMinter(_minter);\n        lpToken = IERC20(lpGetter.lpToken());\n        rewardToken = IERC20(lpGauge.crv_token());\n\n        lpToken.approve(_lpGauge, type(uint256).max);\n        lpToken.approve(_lpGetter, type(uint256).max);\n        rewardToken.approve(_multiSwapper, type(uint256).max);\n        wrappedNative.approve(_lpGetter, type(uint256).max);\n    }\n\n    // ********************** //\n    // *** VIEW FUNCTIONS *** //\n    // ********************** //\n    /// @notice Returns the name of this strategy\n    function name() external pure override returns (string memory name_) {\n        return \"Curve-Tricrypto-LP\";\n    }\n\n    /// @notice Returns the description of this strategy\n    function description()\n        external\n        pure\n        override\n        returns (string memory description_)\n    {\n        return \"Curve-Tricrypto strategy for TricryptoLP\";\n    }\n\n    /// @notice returns compounded amounts in wrappedNative\n    function compoundAmount() public view returns (uint256 result) {\n        (bool success, bytes memory response) = address(lpGauge).staticcall(\n            abi.encodeWithSignature(\"claimable_tokens(address)\", address(this))\n        );\n        result = 0;\n        uint256 claimable = 0;\n        if (success) {\n            claimable = abi.decode(response, (uint256));\n        }\n        if (claimable > 0) {\n            // claim reward, compute swap to wrappedNative and then compute LP amount\n            // --\n            ISwapper.SwapData memory swapData = swapper.buildSwapData(\n                address(rewardToken),\n                address(wrappedNative),\n                claimable,\n                0,\n                false,\n                false\n            );\n            result = swapper.getOutputAmount(swapData, \"\");\n            result = lpGetter.calcWethToLp(result);\n        }\n    }\n\n    // *********************** //\n    // *** OWNER FUNCTIONS *** //\n    // *********************** //\n    /// @notice Sets the deposit threshold\n    /// @param amount The new threshold amount\n    function setDepositThreshold(uint256 amount) external onlyOwner {\n        emit DepositThreshold(depositThreshold, amount);\n        depositThreshold = amount;\n    }\n\n    /// @notice Sets the Swapper address\n    /// @param _swapper The new swapper address\n    function setMultiSwapper(address _swapper) external onlyOwner {\n        emit MultiSwapper(address(swapper), _swapper);\n        rewardToken.approve(address(swapper), 0);\n        rewardToken.approve(_swapper, type(uint256).max);\n        swapper = ISwapper(_swapper);\n    }\n\n    /// @notice Sets the Tricrypto LP Getter\n    /// @param _lpGetter the new address\n    function setTricryptoLPGetter(address _lpGetter) external onlyOwner {\n        emit LPGetterSet(address(lpGetter), _lpGetter);\n        wrappedNative.approve(address(lpGetter), 0);\n        lpGetter = ITricryptoLPGetter(_lpGetter);\n        wrappedNative.approve(_lpGetter, type(uint256).max);\n    }\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n    function compound(bytes memory) public {\n        uint256 claimable = lpGauge.claimable_tokens(address(this));\n        if (claimable > 0) {\n            uint256 crvBalanceBefore = rewardToken.balanceOf(address(this));\n            minter.mint(address(lpGauge));\n            uint256 crvBalanceAfter = rewardToken.balanceOf(address(this));\n\n            if (crvBalanceAfter > crvBalanceBefore) {\n                uint256 crvAmount = crvBalanceAfter - crvBalanceBefore;\n\n                ISwapper.SwapData memory swapData = swapper.buildSwapData(\n                    address(rewardToken),\n                    address(wrappedNative),\n                    crvAmount,\n                    0,\n                    false,\n                    false\n                );\n                uint256 calcAmount = swapper.getOutputAmount(swapData, \"\");\n                uint256 minAmount = calcAmount - (calcAmount * 50) / 10_000; //0.5%\n                swapper.swap(swapData, minAmount, address(this), \"\");\n\n                uint256 wrappedNativeAmount = wrappedNative.balanceOf(\n                    address(this)\n                );\n                calcAmount = lpGetter.calcWethToLp(wrappedNativeAmount);\n                minAmount = calcAmount - (calcAmount * 50) / 10_000; //0.5%\n                uint256 lpAmount = lpGetter.addLiquidityWeth(\n                    wrappedNativeAmount,\n                    minAmount\n                );\n                lpGauge.deposit(lpAmount, address(this), false);\n\n                emit AmountDeposited(lpAmount);\n            }\n        }\n    }\n\n    /// @notice withdraws everythig from the strategy\n    function emergencyWithdraw() external onlyOwner returns (uint256 result) {\n        compound(\"\");\n\n        result = lpGauge.balanceOf(address(this));\n        lpGauge.withdraw(result, true);\n    }\n\n    // ************************* //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n    /// @dev queries Curve-Tricrypto Liquidity Pool\n    function _currentBalance() internal view override returns (uint256 amount) {\n        uint256 lpBalance = lpGauge.balanceOf(address(this));\n        uint256 queued = lpToken.balanceOf(address(this));\n        uint256 _compoundAmount = compoundAmount();\n        return lpBalance + queued + _compoundAmount;\n    }\n\n    /// @dev deposits to Curve Tricrypto or queues tokens if the 'depositThreshold' has not been met yet\n    function _deposited(uint256 amount) internal override nonReentrant {\n        uint256 queued = lpToken.balanceOf(address(this));\n        if (queued > depositThreshold) {\n            lpGauge.deposit(queued, address(this), false);\n            emit AmountDeposited(queued);\n            return;\n        }\n        emit AmountQueued(amount);\n    }\n\n    /// @dev withdraws from Curve Tricrypto\n    function _withdraw(\n        address to,\n        uint256 amount\n    ) internal override nonReentrant {\n        uint256 available = _currentBalance();\n        require(available >= amount, \"TricryptoLPStrategy: amount not valid\");\n\n        uint256 queued = lpToken.balanceOf(address(this));\n        if (amount > queued) {\n            compound(\"\");\n            uint256 lpBalance = lpGauge.balanceOf(address(this));\n            lpGauge.withdraw(lpBalance, true);\n        }\n        require(\n            lpToken.balanceOf(address(this)) >= amount,\n            \"TricryptoLPStrategy: not enough\"\n        );\n        lpToken.safeTransfer(to, amount);\n\n        queued = lpToken.balanceOf(address(this));\n        if (queued > 0) {\n            lpGauge.deposit(queued, address(this), false);\n        }\n\n        emit AmountWithdrawn(to, amount);\n    }\n}"
    }
  ]
}