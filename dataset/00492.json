{
  "Title": "M-5: PositionManager will revert when trying to return back to user excess of the premium transferred from the user when minting position",
  "Content": "# Issue M-5: PositionManager will revert when trying to return back to user excess of the premium transferred from the user when minting position \n\nSource: https://github.com/sherlock-audit/2024-02-smilee-finance-judging/issues/40 \n\n## Found by \njuan, panprog\n## Summary\n\n`PositionManager.mint` calculates preliminary premium to be paid for buying the option and transfers it from the user. The actual premium paid may differ, and if it's smaller, excess is returned back to user. However, it is returned using the `safeTransferFrom`:\n```solidity\n    if (obtainedPremium > premium) {\n        baseToken.safeTransferFrom(address(this), msg.sender, obtainedPremium - premium);\n    }\n```\n\nThe problem is that `PositionManager` doesn't approve itself to transfer baseToken to `msg.sender`, and USDC `transferFrom` implementation requires approval even if address is transferring from its own address. Thus the transfer will revert and user will be unable to open position.\n\n## Vulnerability Detail\n\nBoth `transferFrom` implementations in USDC on Arbitrum (USDC and USDC.e) require approval from any address, including when doing transfers from your own address.\nhttps://arbiscan.io/address/0x1efb3f88bc88f03fd1804a5c53b7141bbef5ded8#code\n```solidity\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n```\n\nhttps://arbiscan.io/address/0x86e721b43d4ecfa71119dd38c0f938a75fdb57b3#code\n```solidity\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    )\n        external\n        override\n        whenNotPaused\n        notBlacklisted(msg.sender)\n        notBlacklisted(from)\n        notBlacklisted(to)\n        returns (bool)\n    {\n        require(\n            value <= allowed[from][msg.sender],\n            \"ERC20: transfer amount exceeds allowance\"\n        );\n        _transfer(from, to, value);\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(value);\n        return true;\n    }\n```\n\n`PositionManager` doesn't approve itself to do transfers anywhere, so `baseToken.safeTransferFrom(address(this), msg.sender, obtainedPremium - premium);` will always revert, preventing the user from opening position via `PositionManager`, breaking important protocol function.\n\n## Impact\n\nUser is unable to open positions via `PositionManager` in certain situations as all such transactions will revert, breaking important protocol functionality and potentially losing user funds / profit due to failure to open position.\n\n## Code Snippet\n\n`PositionManager.mint` transfers base token back to `msg.sender` via `safeTransferFrom`:\nhttps://github.com/sherlock-audit/2024-02-smilee-finance/blob/main/smilee-v2-contracts/src/periphery/PositionManager.sol#L139-L141\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider using `safeTransfer` instead of `safeTransferFrom` when transferring token from self.\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n2 comment(s) were left on this issue during the judging contest.\n\n**santipu_** commented:\n> Invalid - code will never execute bc actual premium is always >= obtainedPremium due to using the worst price between oracle and swap.\n\n**takarez** commented:\n>  valid, medium(2)\n\n\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/dverso/smilee-v2-contracts/commit/84174d20544970309c862a2bf35ccfa3046d6bd9.\n\n**panprog**\n\nFix review: Fixed\n\n**sherlock-admin4**\n\nThe Lead Senior Watson signed off on the fix.\n\n**santipu03**\n\nEscalate\n\nThis issue is LOW because the bug will never be triggered. \n\n`PositionManager` calculates the variable `obtainedPremium` calling `DVP.premium`, that uses the oracle price to calculate the premium:\n\nhttps://github.com/sherlock-audit/2024-02-smilee-finance/blob/main/smilee-v2-contracts/src/IG.sol#L104\n```solidity\npremium_ = _getMarketValue(financeParameters.currentStrike, amount_, true, price);\n```\n\nLater, when minting the position, the actual premium is calculated on `DVP._mint`, using the oracle price and the swap price:\n\nhttps://github.com/sherlock-audit/2024-02-smilee-finance/blob/main/smilee-v2-contracts/src/DVP.sol#L155\n```solidity\nuint256 swapPrice = _deltaHedgePosition(strike, amount, true);\nuint256 premiumOrac = _getMarketValue(strike, amount, true, IPriceOracle(_getPriceOracle()).getPrice(sideToken, baseToken));\nuint256 premiumSwap = _getMarketValue(strike, amount, true, swapPrice);\npremium_ = premiumSwap > premiumOrac ? premiumSwap : premiumOrac;\n```\n\nThe actual premium to pay will be the result of the higher value between the swap-priced premium and the oracle-priced premium. So, in the scenario where the swap price is lower than the oracle price, the oracle price will be used to compute the final premium. \n\nTherefore, it's not possible that the final premium is a lower value than `obtainedPremium`, so the bug will never be triggered because the condition `obtainedPremium > premium` will never be true. \n\n**sherlock-admin2**\n\n> Escalate\n> \n> This issue is LOW because the bug will never be triggered. \n> \n> `PositionManager` calculates the variable `obtainedPremium` calling `DVP.premium`, that uses the oracle price to calculate the premium:\n> \n> https://github.com/sherlock-audit/2024-02-smilee-finance/blob/main/smilee-v2-contracts/src/IG.sol#L104\n> ```solidity\n> premium_ = _getMarketValue(financeParameters.currentStrike, amount_, true, price);\n> ```\n> \n> Later, when minting the position, the actual premium is calculated on `DVP._mint`, using the oracle price and the swap price:\n> \n> https://github.com/sherlock-audit/2024-02-smilee-finance/blob/main/smilee-v2-contracts/src/DVP.sol#L155\n> ```solidity\n> uint256 swapPrice = _deltaHedgePosition(strike, amount, true);\n> uint256 premiumOrac = _getMarketValue(strike, amount, true, IPriceOracle(_getPriceOracle()).getPrice(sideToken, baseToken));\n> uint256 premiumSwap = _getMarketValue(strike, amount, true, swapPrice);\n> premium_ = premiumSwap > premiumOrac ? premiumSwap : premiumOrac;\n> ```\n> \n> The actual premium to pay will be the result of the higher value between the swap-priced premium and the oracle-priced premium. So, in the scenario where the swap price is lower than the oracle price, the oracle price will be used to compute the final premium. \n> \n> Therefore, it's not possible that the final premium is a lower value than `obtainedPremium`, so the bug will never be triggered because the condition `obtainedPremium > premium` will never be true. \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**panprog**\n\nYes, the way it is now, it can never actually happen but that's only due to another issue which makes it revert if any DEX slippage occurs. When it works as intended, the remainder has to be transferred back to the sender.\n\nSo yeah, up to judge to decide. I consider it borderline, because if we isolate \"how it is supposed to work\", returning back the remainder should be possible, it's impossible only due to a different issue.\n\n**cvetanovv**\n\nIt seems that the report is invalid. I think we should judge according to the code that is at the moment, not if it works properly.\n\n**nevillehuang**\n\nBased on head of judging [comments](https://github.com/sherlock-audit/2023-12-jojo-exchange-update-judging/issues/30#issuecomment-1936076314) in a previous contest for such issues, I believe this should remain valid.\n\n**Czar102**\n\nI agree with @panprog and @nevillehuang â€“ the fix to the other issue will not fix this one. Hence, these are separate issues and both of them may be valid since they present discrepancies from the expected behavior of the contracts.\n\nI'm planning to reject the escalation and leave the issue as is.\n\n**Czar102**\n\nResult:\nMedium\nHas duplicates\n\n**sherlock-admin3**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [santipu03](https://github.com/sherlock-audit/2024-02-smilee-finance-judging/issues/40/#issuecomment-2004278583): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/180",
  "Code": [
    {
      "filename": "smilee-v2-contracts/src/periphery/PositionManager.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.15;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IDVP} from \"../interfaces/IDVP.sol\";\nimport {IPositionManager} from \"../interfaces/IPositionManager.sol\";\nimport {Position} from \"../lib/Position.sol\";\nimport {Epoch} from \"../lib/EpochController.sol\";\nimport {ERC721} from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport {ERC721Enumerable} from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract PositionManager is ERC721Enumerable, Ownable, IPositionManager {\n    using SafeERC20 for IERC20;\n\n    struct ManagedPosition {\n        address dvpAddr;\n        uint256 strike;\n        uint256 expiry;\n        uint256 notionalUp;\n        uint256 notionalDown;\n        uint256 premium;\n        uint256 leverage;\n        uint256 cumulatedPayoff;\n    }\n\n    /// @dev Stored data by position ID\n    mapping(uint256 => ManagedPosition) internal _positions;\n\n    /// @dev The ID of the next token that will be minted. Skips 0\n    uint256 private _nextId;\n\n    // Used by TheGraph for frontend needs:\n    event Buy(address dvp, uint256 epoch, uint256 premium, address creditor);\n    event Sell(address dvp, uint256 epoch, uint256 payoff);\n\n    error CantBurnMoreThanMinted();\n    error InvalidTokenID();\n    error NotOwner();\n    error PositionExpired();\n    error AsymmetricAmount();\n\n    constructor() ERC721Enumerable() ERC721(\"Smilee V0 Trade Positions\", \"SMIL-V0-TRAD\") Ownable() {\n        _nextId = 1;\n    }\n\n    modifier isOwner(uint256 tokenId) {\n        if (ownerOf(tokenId) != msg.sender) {\n            revert NotOwner();\n        }\n        _;\n    }\n\n    // modifier isAuthorizedForToken(uint256 tokenId) {\n    //     if (!_isApprovedOrOwner(msg.sender, tokenId)) {\n    //         revert NotApproved();\n    //     }\n    //     _;\n    // }\n\n    /// @inheritdoc IPositionManager\n    function positionDetail(uint256 tokenId) external view override returns (IPositionManager.PositionDetail memory) {\n        ManagedPosition memory position = _positions[tokenId];\n        if (position.dvpAddr == address(0)) {\n            revert InvalidTokenID();\n        }\n\n        IDVP dvp = IDVP(position.dvpAddr);\n\n        Epoch memory epoch = dvp.getEpoch();\n\n        return\n            IPositionManager.PositionDetail({\n                dvpAddr: position.dvpAddr,\n                baseToken: dvp.baseToken(),\n                sideToken: dvp.sideToken(),\n                dvpFreq: epoch.frequency,\n                dvpType: dvp.optionType(),\n                strike: position.strike,\n                expiry: position.expiry,\n                premium: position.premium,\n                leverage: position.leverage,\n                notionalUp: position.notionalUp,\n                notionalDown: position.notionalDown,\n                cumulatedPayoff: position.cumulatedPayoff\n            });\n    }\n\n    /// @inheritdoc IPositionManager\n    function mint(\n        IPositionManager.MintParams calldata params\n    ) external override returns (uint256 tokenId, uint256 premium) {\n        IDVP dvp = IDVP(params.dvpAddr);\n\n        if (params.tokenId != 0) {\n            tokenId = params.tokenId;\n            ManagedPosition storage position = _positions[tokenId];\n\n            if (ownerOf(tokenId) != msg.sender) {\n                revert NotOwner();\n            }\n            // Check token compatibility:\n            if (position.dvpAddr != params.dvpAddr || position.strike != params.strike) {\n                revert InvalidTokenID();\n            }\n            Epoch memory epoch = dvp.getEpoch();\n            if (position.expiry != epoch.current) {\n                revert PositionExpired();\n            }\n        }\n        if ((params.notionalUp > 0 && params.notionalDown > 0) && (params.notionalUp != params.notionalDown)) {\n            // If amount is a smile, it must be balanced:\n            revert AsymmetricAmount();\n        }\n\n        uint256 obtainedPremium;\n        uint256 fee;\n        (obtainedPremium, fee) = dvp.premium(params.strike, params.notionalUp, params.notionalDown);\n\n        // Transfer premium:\n        // NOTE: The PositionManager is just a middleman between the user and the DVP\n        IERC20 baseToken = IERC20(dvp.baseToken());\n        baseToken.safeTransferFrom(msg.sender, address(this), obtainedPremium);\n\n        // Premium already include fee\n        baseToken.safeApprove(params.dvpAddr, obtainedPremium);\n\n        premium = dvp.mint(\n            address(this),\n            params.strike,\n            params.notionalUp,\n            params.notionalDown,\n            params.expectedPremium,\n            params.maxSlippage,\n            params.nftAccessTokenId\n        );\n\n        if (obtainedPremium > premium) {\n            baseToken.safeTransferFrom(address(this), msg.sender, obtainedPremium - premium);\n        }\n\n        if (params.tokenId == 0) {\n            // Mint token:\n            tokenId = _nextId++;\n            _mint(params.recipient, tokenId);\n\n            Epoch memory epoch = dvp.getEpoch();\n\n            // Save position:\n            _positions[tokenId] = ManagedPosition({\n                dvpAddr: params.dvpAddr,\n                strike: params.strike,\n                expiry: epoch.current,\n                premium: premium,\n                leverage: (params.notionalUp + params.notionalDown) / premium,\n                notionalUp: params.notionalUp,\n                notionalDown: params.notionalDown,\n                cumulatedPayoff: 0\n            });\n        } else {\n            ManagedPosition storage position = _positions[tokenId];\n            // Increase position:\n            position.premium += premium;\n            position.notionalUp += params.notionalUp;\n            position.notionalDown += params.notionalDown;\n            /* NOTE:\n                When, within the same epoch, a user wants to buy, sell partially\n                and then buy again, the leverage computation can fail due to\n                decreased notional; in order to avoid this issue, we have to\n                also adjust (decrease) the premium in the burn flow.\n             */\n            position.leverage = (position.notionalUp + position.notionalDown) / position.premium;\n        }\n\n        emit BuyDVP(tokenId, _positions[tokenId].expiry, params.notionalUp + params.notionalDown);\n        emit Buy(params.dvpAddr, _positions[tokenId].expiry, premium, params.recipient);\n    }\n\n    function payoff(\n        uint256 tokenId,\n        uint256 notionalUp,\n        uint256 notionalDown\n    ) external view returns (uint256 payoff_, uint256 fee) {\n        ManagedPosition storage position = _positions[tokenId];\n        return IDVP(position.dvpAddr).payoff(position.expiry, position.strike, notionalUp, notionalDown);\n    }\n\n    function sell(SellParams calldata params) external isOwner(params.tokenId) returns (uint256 payoff_) {\n        payoff_ = _sell(\n            params.tokenId,\n            params.notionalUp,\n            params.notionalDown,\n            params.expectedMarketValue,\n            params.maxSlippage\n        );\n    }\n\n    function sellAll(SellParams[] calldata params) external returns (uint256 totalPayoff_) {\n        uint256 paramsLength = params.length;\n        for (uint256 i = 0; i < paramsLength; i++) {\n            if (ownerOf(params[i].tokenId) != msg.sender) {\n                revert NotOwner();\n            }\n            totalPayoff_ += _sell(\n                params[i].tokenId,\n                params[i].notionalUp,\n                params[i].notionalDown,\n                params[i].expectedMarketValue,\n                params[i].maxSlippage\n            );\n        }\n    }\n\n    function _sell(\n        uint256 tokenId,\n        uint256 notionalUp,\n        uint256 notionalDown,\n        uint256 expectedMarketValue,\n        uint256 maxSlippage\n    ) internal returns (uint256 payoff_) {\n        ManagedPosition storage position = _positions[tokenId];\n        // NOTE: as the positions within the DVP are all of the PositionManager, we must replicate this check here.\n        if (notionalUp > position.notionalUp || notionalDown > position.notionalDown) {\n            revert CantBurnMoreThanMinted();\n        }\n\n        if ((notionalUp > 0 && notionalDown > 0) && (notionalUp != notionalDown)) {\n            // If amount is a smile, it must be balanced:\n            revert AsymmetricAmount();\n        }\n\n        // NOTE: the DVP already checks that the burned notional is lesser or equal to the position notional.\n        // NOTE: the payoff is transferred directly from the DVP\n        payoff_ = IDVP(position.dvpAddr).burn(\n            position.expiry,\n            msg.sender,\n            position.strike,\n            notionalUp,\n            notionalDown,\n            expectedMarketValue,\n            maxSlippage\n        );\n\n        // NOTE: premium fix for the leverage issue annotated in the mint flow.\n        // notional : position.notional = fix : position.premium\n        uint256 premiumFix = ((notionalUp + notionalDown) * position.premium) /\n            (position.notionalUp + position.notionalDown);\n        position.premium -= premiumFix;\n        position.cumulatedPayoff += payoff_;\n        position.notionalUp -= notionalUp;\n        position.notionalDown -= notionalDown;\n\n        if (position.notionalUp == 0 && position.notionalDown == 0) {\n            delete _positions[tokenId];\n            _burn(tokenId);\n        }\n\n        emit SellDVP(tokenId, (notionalUp + notionalDown), payoff_);\n        emit Sell(position.dvpAddr, position.expiry, payoff_);\n    }\n}"
    },
    {
      "filename": "smilee-v2-contracts/src/IG.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.19;\n\nimport {IDVP} from \"./interfaces/IDVP.sol\";\nimport {IDVPAccessNFT} from \"./interfaces/IDVPAccessNFT.sol\";\nimport {IFeeManager} from \"./interfaces/IFeeManager.sol\";\nimport {IMarketOracle} from \"./interfaces/IMarketOracle.sol\";\nimport {IPriceOracle} from \"./interfaces/IPriceOracle.sol\";\nimport {IVault} from \"./interfaces/IVault.sol\";\nimport {Amount, AmountHelper} from \"./lib/Amount.sol\";\nimport {Epoch, EpochController} from \"./lib/EpochController.sol\";\nimport {Finance} from \"./lib/Finance.sol\";\nimport {FinanceParameters, FinanceIG, TimeLockedFinanceValues} from \"./lib/FinanceIG.sol\";\nimport {Notional} from \"./lib/Notional.sol\";\nimport {DVP} from \"./DVP.sol\";\nimport {EpochControls} from \"./EpochControls.sol\";\n\ncontract IG is DVP {\n    using AmountHelper for Amount;\n    using EpochController for Epoch;\n    using Notional for Notional.Info;\n\n    FinanceParameters public financeParameters;\n\n    /// @notice A flag to tell if this DVP is currently bound to check access for trade\n    bool public nftAccessFlag = false;\n\n    error NFTAccessDenied();\n\n    // Used by TheGraph for frontend needs:\n    event EpochStrike(uint256 epoch, uint256 strike);\n    event PausedForFinanceApproximation();\n    event ChangedFinanceParameters();\n\n    constructor(address vault_, address addressProvider_) DVP(vault_, false, addressProvider_) {\n        _setParameters(\n            TimeLockedFinanceValues({\n                sigmaMultiplier: 3e18,\n                tradeVolatilityUtilizationRateFactor: 2e18,\n                tradeVolatilityTimeDecay: 0.25e18,\n                volatilityPriceDiscountFactor: 0.9e18,\n                useOracleImpliedVolatility: true\n            })\n        );\n    }\n\n    /**\n        @notice Allows the contract's owner to enable or disable the nft access to trade operations\n     */\n    function setNftAccessFlag(bool flag) external {\n        _checkRole(ROLE_ADMIN);\n\n        nftAccessFlag = flag;\n    }\n\n    /// @notice Common strike price for all impermanent gain positions in this DVP, set at epoch start\n    function currentStrike() external view returns (uint256 strike_) {\n        strike_ = financeParameters.currentStrike;\n    }\n\n    /// @inheritdoc IDVP\n    function mint(\n        address recipient,\n        uint256 strike,\n        uint256 amountUp,\n        uint256 amountDown,\n        uint256 expectedPremium,\n        uint256 maxSlippage,\n        uint256 nftAccessTokenId\n    ) external override returns (uint256 premium_) {\n        strike;\n        _checkNFTAccess(nftAccessTokenId, recipient, amountUp + amountDown);\n        Amount memory amount_ = Amount({up: amountUp, down: amountDown});\n\n        premium_ = _mint(recipient, financeParameters.currentStrike, amount_, expectedPremium, maxSlippage);\n    }\n\n    /// @inheritdoc IDVP\n    function burn(\n        uint256 epoch,\n        address recipient,\n        uint256 strike,\n        uint256 amountUp,\n        uint256 amountDown,\n        uint256 expectedMarketValue,\n        uint256 maxSlippage\n    ) external override returns (uint256 paidPayoff) {\n        Amount memory amount_ = Amount({up: amountUp, down: amountDown});\n\n        paidPayoff = _burn(epoch, recipient, strike, amount_, expectedMarketValue, maxSlippage);\n    }\n\n    /// @inheritdoc IDVP\n    function premium(\n        uint256 strike,\n        uint256 amountUp,\n        uint256 amountDown\n    ) public view virtual override returns (uint256 premium_, uint256 fee) {\n        strike;\n\n        uint256 price = IPriceOracle(_getPriceOracle()).getPrice(sideToken, baseToken);\n        Amount memory amount_ = Amount({up: amountUp, down: amountDown});\n\n        premium_ = _getMarketValue(financeParameters.currentStrike, amount_, true, price);\n        (fee, ) = IFeeManager(_getFeeManager()).tradeBuyFee(\n            address(this),\n            getEpoch().current,\n            amountUp + amountDown,\n            premium_,\n            _baseTokenDecimals\n        );\n        premium_ += fee;\n    }\n\n    /// @inheritdoc IDVP\n    function getUtilizationRate() public view returns (uint256) {\n        Notional.Info storage liquidity = _liquidity[financeParameters.maturity];\n        (uint256 used, uint256 total) = liquidity.utilizationRateFactors(financeParameters.currentStrike);\n\n        return Finance.getUtilizationRate(used, total, _baseTokenDecimals);\n    }\n\n    /// @inheritdoc DVP\n    function _getMarketValue(\n        uint256 strike,\n        Amount memory amount,\n        bool tradeIsBuy,\n        uint256 swapPrice\n    ) internal view virtual override returns (uint256 marketValue) {\n        marketValue = FinanceIG.getMarketValue(\n            financeParameters,\n            amount,\n            getPostTradeVolatility(strike, amount, tradeIsBuy),\n            swapPrice,\n            IMarketOracle(_getMarketOracle()).getRiskFreeRate(baseToken),\n            _baseTokenDecimals\n        );\n    }\n\n    function notional()\n        external\n        view\n        returns (uint256 bearNotional, uint256 bullNotional, uint256 bearAvailNotional, uint256 bullAvailNotional)\n    {\n        Notional.Info storage liquidity = _liquidity[financeParameters.maturity];\n\n        Amount memory initial = liquidity.getInitial(financeParameters.currentStrike);\n        Amount memory available = liquidity.available(financeParameters.currentStrike);\n\n        return (initial.down, initial.up, available.down, available.up);\n    }\n\n    // NOTE: public for frontend usage\n    /**\n        @notice Get the estimated implied volatility from a given trade.\n        @param strike The trade strike.\n        @param amount The trade notional.\n        @param tradeIsBuy positive for buy, negative for sell.\n        @return sigma The estimated implied volatility.\n        @dev The oracle must provide an updated baseline volatility, computed just before the start of the epoch.\n        @dev it reverts if there's no previous epoch\n     */\n    function getPostTradeVolatility(\n        uint256 strike,\n        Amount memory amount,\n        bool tradeIsBuy\n    ) public view returns (uint256 sigma) {\n        strike;\n\n        Notional.Info storage liquidity = _liquidity[financeParameters.maturity];\n        uint256 ur = liquidity.postTradeUtilizationRate(\n            financeParameters.currentStrike,\n            amount,\n            tradeIsBuy,\n            _baseTokenDecimals\n        );\n        uint256 t0 = getEpoch().current - getEpoch().frequency;\n\n        return FinanceIG.getPostTradeVolatility(financeParameters, ur, t0);\n    }\n\n    /// @inheritdoc DVP\n    function _deltaHedgePosition(\n        uint256 strike,\n        Amount memory amount,\n        bool tradeIsBuy\n    ) internal virtual override returns (uint256 swapPrice) {\n        uint256 oraclePrice = IPriceOracle(_getPriceOracle()).getPrice(sideToken, baseToken);\n\n        Notional.Info storage liquidity = _liquidity[financeParameters.maturity];\n\n        // Also update the epoch volatility with the trade effect:\n        uint256 ur = liquidity.postTradeUtilizationRate(\n            financeParameters.currentStrike,\n            amount,\n            tradeIsBuy,\n            _baseTokenDecimals\n        );\n        FinanceIG.updateVolatilityOnTrade(financeParameters, oraclePrice, ur);\n\n        Amount memory availableLiquidity = liquidity.available(strike);\n        (, uint256 sideTokensAmount) = IVault(vault).balances();\n\n        int256 tokensToSwap;\n        tokensToSwap = FinanceIG.getDeltaHedgeAmount(\n            financeParameters,\n            amount,\n            tradeIsBuy,\n            oraclePrice,\n            sideTokensAmount,\n            availableLiquidity,\n            _baseTokenDecimals,\n            _sideTokenDecimals\n        );\n\n        if (tokensToSwap == 0) {\n            return oraclePrice;\n        }\n\n        // NOTE: We negate the value because the protocol will sell side tokens when `h` is positive.\n        uint256 exchangedBaseTokens = IVault(vault).deltaHedge(-tokensToSwap);\n\n        swapPrice = Finance.getSwapPrice(tokensToSwap, exchangedBaseTokens, _sideTokenDecimals, _baseTokenDecimals);\n    }\n\n    /// @inheritdoc DVP\n    function _residualPayoffPerc(\n        uint256 strike,\n        uint256 price\n    ) internal view virtual override returns (uint256, uint256) {\n        strike;\n        return FinanceIG.getPayoffPercentages(financeParameters, price);\n    }\n\n    /// @inheritdoc DVP\n    function _residualPayoff() internal view virtual override returns (uint256 residualPayoff) {\n        Notional.Info storage liquidity = _liquidity[financeParameters.maturity];\n\n        residualPayoff = liquidity.getAccountedPayoff(financeParameters.currentStrike).getTotal();\n    }\n\n    /// @inheritdoc DVP\n    function _accountResidualPayoffs(uint256 price) internal virtual override {\n        _accountResidualPayoff(financeParameters.currentStrike, price);\n    }\n\n    /// @inheritdoc EpochControls\n    function _afterRollEpoch() internal virtual override {\n        Epoch memory epoch = getEpoch();\n\n        financeParameters.maturity = epoch.current;\n        financeParameters.currentStrike = IPriceOracle(_getPriceOracle()).getPrice(sideToken, baseToken);\n        financeParameters.internalVolatilityParameters.epochStart = epoch.current - epoch.frequency; // Not using epoch.previous because epoch may be skipped\n\n        emit EpochStrike(epoch.current, financeParameters.currentStrike);\n\n        {\n            uint256 iv = IMarketOracle(_getMarketOracle()).getImpliedVolatility(\n                baseToken,\n                sideToken,\n                financeParameters.currentStrike,\n                epoch.frequency\n            );\n            FinanceIG.updateParameters(financeParameters, iv);\n        }\n\n        super._afterRollEpoch();\n\n        if (FinanceIG.checkFinanceApprox(financeParameters)) {\n            _pause();\n            emit PausedForFinanceApproximation();\n        }\n\n        // NOTE: initial liquidity is allocated by the DVP call\n        Notional.Info storage liquidity = _liquidity[financeParameters.maturity];\n        financeParameters.initialLiquidity = liquidity.getInitial(financeParameters.currentStrike);\n    }\n\n    /// @inheritdoc DVP\n    function _allocateLiquidity(uint256 initialCapital) internal virtual override {\n        // The initialCapital is split 50:50 on the two strategies:\n        uint256 halfInitialCapital = initialCapital / 2;\n        Amount memory allocation = Amount({up: halfInitialCapital, down: initialCapital - halfInitialCapital});\n\n        Notional.Info storage liquidity = _liquidity[financeParameters.maturity];\n\n        // The impermanent gain (IG) DVP only has one strike:\n        liquidity.setInitial(financeParameters.currentStrike, allocation);\n    }\n\n    /// @dev parameters must be defined in Wad\n    /// @dev aggregated in order to limit contract size\n    function setParameters(TimeLockedFinanceValues calldata params) external {\n        _checkRole(ROLE_ADMIN);\n        _setParameters(params);\n\n        emit ChangedFinanceParameters();\n    }\n\n    /// @dev parameters must be defined in Wad\n    /// @dev aggregated in order to limit contract size\n    function _setParameters(TimeLockedFinanceValues memory params) internal {\n        uint256 timeToValidity = getEpoch().timeToNextEpoch();\n        FinanceIG.updateTimeLockedParameters(financeParameters.timeLocked, params, timeToValidity);\n    }\n\n    /// @dev Checks if given trade is allowed to be made using nft.checkCap callback func\n    function _checkNFTAccess(uint256 accessTokenId, address receiver, uint256 notionalAmount) internal {\n        if (nftAccessFlag) {\n            IDVPAccessNFT nft = IDVPAccessNFT(_addressProvider.dvpAccessNFT());\n            if (accessTokenId == 0 || nft.ownerOf(accessTokenId) != receiver) {\n                revert NFTAccessDenied();\n            }\n            nft.checkCap(accessTokenId, notionalAmount);\n        }\n    }\n}"
    },
    {
      "filename": "smilee-v2-contracts/src/DVP.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.19;\n\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport {IAddressProvider} from \"./interfaces/IAddressProvider.sol\";\nimport {IDVP, IDVPImmutables} from \"./interfaces/IDVP.sol\";\nimport {IEpochControls} from \"./interfaces/IEpochControls.sol\";\nimport {IFeeManager} from \"./interfaces/IFeeManager.sol\";\nimport {IPriceOracle} from \"./interfaces/IPriceOracle.sol\";\nimport {IVault} from \"./interfaces/IVault.sol\";\nimport {Amount, AmountHelper} from \"./lib/Amount.sol\";\nimport {Epoch} from \"./lib/EpochController.sol\";\nimport {Finance} from \"./lib/Finance.sol\";\nimport {Notional} from \"./lib/Notional.sol\";\nimport {Position} from \"./lib/Position.sol\";\nimport {EpochControls} from \"./EpochControls.sol\";\nimport {VaultLib} from \"./lib/VaultLib.sol\";\n\nabstract contract DVP is IDVP, EpochControls, AccessControl, Pausable {\n    using AmountHelper for Amount;\n    using Position for Position.Info;\n    using Notional for Notional.Info;\n    using SafeERC20 for IERC20Metadata;\n\n    /// @inheritdoc IDVPImmutables\n    address public immutable override baseToken;\n    /// @inheritdoc IDVPImmutables\n    address public immutable override sideToken;\n    /// @inheritdoc IDVPImmutables\n    bool public immutable override optionType;\n    /// @inheritdoc IDVP\n    address public immutable override vault;\n\n    IAddressProvider internal immutable _addressProvider;\n    uint8 internal immutable _baseTokenDecimals;\n    uint8 internal immutable _sideTokenDecimals;\n\n    bytes32 public constant ROLE_GOD = keccak256(\"ROLE_GOD\");\n    bytes32 public constant ROLE_ADMIN = keccak256(\"ROLE_ADMIN\");\n    bytes32 public constant ROLE_EPOCH_ROLLER = keccak256(\"ROLE_EPOCH_ROLLER\");\n\n    /**\n        @notice liquidity for options indexed by epoch\n        @dev mapping epoch -> Notional.Info\n     */\n    mapping(uint256 => Notional.Info) internal _liquidity;\n\n    /**\n        @notice Users positions\n        @dev mapping epoch -> Position.getID(...) -> Position.Info\n        @dev There is an index by epoch in order to further avoid collisions within the hash of the position ID.\n     */\n    mapping(uint256 => mapping(bytes32 => Position.Info)) internal _epochPositions;\n\n    error NotEnoughNotional();\n    error PositionNotFound();\n    error CantBurnMoreThanMinted();\n    error MissingMarketOracle();\n    error MissingPriceOracle();\n    error MissingFeeManager();\n    error SlippedMarketValue();\n    error PayoffTooLow();\n    error VaultDead();\n    error OnlyPositionManager();\n\n    /**\n        @notice Emitted when option is minted for a given position\n        @param sender The address that minted the option\n        @param owner The owner of the option\n     */\n    event Mint(address sender, address indexed owner);\n\n    /**\n        @notice Emitted when a position's option is destroyed\n        @param owner The owner of the position that is being burnt\n     */\n    event Burn(address indexed owner);\n\n    event ChangedPauseState(bool paused);\n\n    constructor(\n        address vault_,\n        bool optionType_,\n        address addressProvider_\n    )\n        EpochControls(IEpochControls(vault_).getEpoch().frequency, IEpochControls(vault_).getEpoch().firstEpochTimespan)\n        AccessControl()\n        Pausable()\n    {\n        optionType = optionType_;\n        vault = vault_;\n        IVault vaultCt = IVault(vault);\n        baseToken = vaultCt.baseToken();\n        sideToken = vaultCt.sideToken();\n        _baseTokenDecimals = IERC20Metadata(baseToken).decimals();\n        _sideTokenDecimals = IERC20Metadata(sideToken).decimals();\n        _addressProvider = IAddressProvider(addressProvider_);\n\n        _setRoleAdmin(ROLE_GOD, ROLE_GOD);\n        _setRoleAdmin(ROLE_ADMIN, ROLE_GOD);\n        _setRoleAdmin(ROLE_EPOCH_ROLLER, ROLE_ADMIN);\n\n        _grantRole(ROLE_GOD, msg.sender);\n    }\n\n    /**\n        @notice Creates a new, or increases an existing, position\n        @param recipient The wallet of the recipient for the position\n        @param strike The strike of the position to mint\n        @param amount The notional of the position to mint\n        @param expectedPremium The expected premium, assumed to not consider fees, used to check against the actual premium, only known at the end of the trade\n        @param maxSlippage The maximum slippage percentage accepted between the given expected premium and the actual one\n        @return premium_ The actual paid premium\n        @dev The client must approve the expected premium + slippage percentage, if actual premium will result in more than this quantity it will revert\n     */\n    function _mint(\n        address recipient,\n        uint256 strike,\n        Amount memory amount,\n        uint256 expectedPremium,\n        uint256 maxSlippage\n    ) internal returns (uint256 premium_) {\n        _checkEpochNotFinished();\n        _requireNotPaused();\n        if (IVault(vault).dead()) {\n            revert VaultDead();\n        }\n        if (amount.up == 0 && amount.down == 0) {\n            revert AmountZero();\n        }\n        if ((amount.up > 0 && amount.down > 0) && (amount.up != amount.down)) {\n            // If amount is an unbalanced smile, only the position manager is allowed to proceed:\n            if (msg.sender != _addressProvider.dvpPositionManager()) {\n                revert OnlyPositionManager();\n            }\n        }\n\n        Epoch memory epoch = getEpoch();\n        Notional.Info storage liquidity = _liquidity[epoch.current];\n\n        // Check available liquidity:\n        Amount memory availableLiquidity = liquidity.available(strike);\n        if (availableLiquidity.up < amount.up || availableLiquidity.down < amount.down) {\n            revert NotEnoughNotional();\n        }\n\n        {\n            uint256 swapPrice = _deltaHedgePosition(strike, amount, true);\n            uint256 premiumOrac = _getMarketValue(strike, amount, true, IPriceOracle(_getPriceOracle()).getPrice(sideToken, baseToken));\n            uint256 premiumSwap = _getMarketValue(strike, amount, true, swapPrice);\n            premium_ = premiumSwap > premiumOrac ? premiumSwap : premiumOrac;\n        }\n\n        IFeeManager feeManager = IFeeManager(_getFeeManager());\n        (uint256 fee, uint256 vaultFee) = feeManager.tradeBuyFee(\n            address(this),\n            epoch.current,\n            amount.up + amount.down,\n            premium_,\n            _baseTokenDecimals\n        );\n\n        // Revert if actual price exceeds the previewed premium\n        // NOTE: cannot use the approved premium as a reference due to the PositionManager...\n        _checkSlippage(premium_ + fee, expectedPremium, maxSlippage, true);\n\n        // Get fees from sender:\n        IERC20Metadata(baseToken).safeTransferFrom(msg.sender, address(this), fee - vaultFee);\n        IERC20Metadata(baseToken).safeApprove(address(feeManager), fee - vaultFee);\n        feeManager.receiveFee(fee - vaultFee);\n\n        // Get base premium from sender:\n        IERC20Metadata(baseToken).safeTransferFrom(msg.sender, vault, premium_ + vaultFee);\n        feeManager.trackVaultFee(address(vault), vaultFee);\n\n        // Update user premium:\n        premium_ += fee;\n\n        // Decrease available liquidity:\n        liquidity.increaseUsage(strike, amount);\n\n        // Create or update position:\n        Position.Info storage position = _getPosition(epoch.current, recipient, strike);\n        position.premium += premium_;\n        position.epoch = epoch.current;\n        position.strike = strike;\n        position.amountUp += amount.up;\n        position.amountDown += amount.down;\n\n        emit Mint(msg.sender, recipient);\n    }\n\n    function _checkSlippage(\n        uint256 premium,\n        uint256 expectedpremium,\n        uint256 maxSlippage,\n        bool tradeIsBuy\n    ) internal pure {\n        if (!Finance.checkSlippage(premium, expectedpremium, maxSlippage, tradeIsBuy)) {\n            revert SlippedMarketValue();\n        }\n    }\n\n    /**\n        @notice It attempts to flat the DVP's delta by selling/buying an amount of side tokens in order to hedge the position.\n        @notice By hedging the position, we avoid the impermanent loss.\n        @param strike The position strike.\n        @param amount The position notional.\n        @param tradeIsBuy Positive if buyed by a user, negative otherwise.\n     */\n    function _deltaHedgePosition(\n        uint256 strike,\n        Amount memory amount,\n        bool tradeIsBuy\n    ) internal virtual returns (uint256 swapPrice);\n\n    /**\n        @notice Burn or decrease a position.\n        @param expiry The expiry timestamp of the position.\n        @param recipient The wallet of the recipient for the opened position.\n        @param strike The strike\n        @param amount The notional.\n        @param expectedMarketValue The expected market value when the epoch is the current one.\n        @param maxSlippage The maximum slippage percentage.\n        @return paidPayoff The paid payoff.\n     */\n    function _burn(\n        uint256 expiry,\n        address recipient,\n        uint256 strike,\n        Amount memory amount,\n        uint256 expectedMarketValue,\n        uint256 maxSlippage\n    ) internal returns (uint256 paidPayoff) {\n        _requireNotPaused();\n        Position.Info storage position = _getPosition(expiry, msg.sender, strike);\n        if (!position.exists()) {\n            revert PositionNotFound();\n        }\n\n        // // If the position reached maturity, the user must close the entire position\n        // // NOTE: we have to avoid this due to the PositionManager that holds positions for multiple tokens.\n        // if (position.epoch != epoch.current) {\n        //     amount = position.amount;\n        // }\n        if (amount.up == 0 && amount.down == 0) {\n            // NOTE: a zero amount may have some parasite effect, henct we proactively protect against it.\n            revert AmountZero();\n        }\n        if (amount.up > position.amountUp || amount.down > position.amountDown) {\n            revert CantBurnMoreThanMinted();\n        }\n        if ((amount.up > 0 && amount.down > 0) && (amount.up != amount.down)) {\n            // If amount is an unbalanced smile, only the position manager is allowed to proceed:\n            if (msg.sender != _addressProvider.dvpPositionManager()) {\n                revert OnlyPositionManager();\n            }\n        }\n\n        bool expired = expiry != getEpoch().current;\n        if (!expired) {\n            // NOTE: checked only here as expired positions needs to be burned even if the vault was killed.\n            _checkEpochNotFinished();\n\n            uint256 swapPrice = _deltaHedgePosition(strike, amount, false);\n            uint256 payoffOrac = _getMarketValue(strike, amount, false, IPriceOracle(_getPriceOracle()).getPrice(sideToken, baseToken));\n            uint256"
    }
  ]
}