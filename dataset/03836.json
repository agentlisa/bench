{
  "Title": "Difficult calculation of uint max",
  "Content": "##### Description\nSee these lines: \n- https://github.com/RealityCards/RealityCards-Contracts/tree/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/RCMarket.sol#L29 \n- https://github.com/RealityCards/RealityCards-Contracts/tree/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/RCMarket.sol#L30\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/bridgeproxies/RCProxyMainnet.sol#L91\n\nBoth of this values are worked out by strange way. E.g. 2**256 for uint256 will get 0.\nBut there are simpler ways to calculate the maximum value. For example:\n- `uint256 public constant MAX_UINT256 = uint256(-1);`\n- `uint256 public constant MAX_UINT256 = type(uint256).max;`\n\n##### Recommendation\nIt is recommended to make it clearer.\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/bridgeproxies/RCProxyMainnet.sol",
      "content": "pragma solidity 0.5.13;\n\nimport \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport '../interfaces/IRealitio.sol';\nimport '../interfaces/IRCProxyXdai.sol';\nimport '../interfaces/IBridge.sol';\nimport '../interfaces/IAlternateReceiverBridge.sol';\nimport '../interfaces/IERC20Dai.sol';\nimport '../interfaces/IERC721.sol';\n\n/// @title Reality Cards Proxy- Mainnet side\n/// @author Andrew Stanger & Marvin Kruse\n/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!\ncontract RCProxyMainnet is Ownable\n{\n    ////////////////////////////////////\n    //////// VARIABLES /////////////////\n    ////////////////////////////////////\n\n    /// @dev contract variables\n    IRealitio public realitio;\n    IBridge public bridge;\n    IAlternateReceiverBridge public alternateReceiverBridge;\n    IERC20Dai public dai;\n    IERC721 public nfthub;\n\n    /// @dev governance variables\n    address public proxyXdaiAddress;\n    address public nftHubAddress;\n    address public arbitrator;\n    uint32 public timeout;\n    \n    /// @dev market resolution variables\n    mapping (address => bytes32) public questionIds;\n\n    /// @dev dai deposits\n    uint256 internal depositNonce;\n    bool depositsEnabled = true;\n\n    ////////////////////////////////////\n    ////////// CONSTRUCTOR /////////////\n    ////////////////////////////////////\n\n    constructor(address _bridgeMainnetAddress, address _realitioAddress, address _nftHubAddress, address _alternateReceiverAddress, address _daiAddress) public {\n        setBridgeMainnetAddress(_bridgeMainnetAddress);\n        setRealitioAddress(_realitioAddress);\n        setNftHubAddress(_nftHubAddress);\n        setAlternateReceiverAddress(_alternateReceiverAddress);\n        setDaiAddress(_daiAddress); \n        setArbitrator(0xd47f72a2d1d0E91b0Ec5e5f5d02B2dc26d00A14D); // kleros\n        setTimeout(86400); // 24 hours\n    }\n\n    ////////////////////////////////////\n    //////////// EVENTS ////////////////\n    ////////////////////////////////////\n\n    event LogQuestionPostedToOracle(address indexed marketAddress, bytes32 indexed questionId);\n    event DaiDeposited(address indexed user, uint256 amount, uint256 nonce);\n\n    ////////////////////////////////////\n    /////// GOVERNANCE - SETUP /////////\n    ////////////////////////////////////\n    \n    /// @dev address of xdai oracle proxy, called by the xdai side of the arbitrary message bridge\n    /// @dev not set in constructor, address not known at deployment\n    function setProxyXdaiAddress(address _newAddress) onlyOwner external {\n        proxyXdaiAddress = _newAddress;\n    }\n\n    /// @dev address of arbitrary message bridge, mainnet side\n    function setBridgeMainnetAddress(address _newAddress) onlyOwner public {\n        bridge = IBridge(_newAddress);\n    }\n\n    /// @dev address of alternate receiver bridge, mainnet side\n    function setNftHubAddress(address _newAddress) onlyOwner public {\n        nfthub = IERC721(_newAddress);\n    }\n\n    /// @dev address of alternate receiver bridge, mainnet side\n    function setAlternateReceiverAddress(address _newAddress) onlyOwner public {\n        alternateReceiverBridge = IAlternateReceiverBridge(_newAddress);\n    }\n\n    /// @dev address of dai contract, must also approve the ARB\n    function setDaiAddress(address _newAddress) onlyOwner public {\n        dai = IERC20Dai(_newAddress);\n        dai.approve(address(alternateReceiverBridge), 2**256 - 1);\n    }\n\n    ////////////////////////////////////\n    /////// GOVERNANCE - ORACLE ////////\n    ////////////////////////////////////\n\n    /// @dev address reality.eth contracts\n    function setRealitioAddress(address _newAddress) onlyOwner public {\n        realitio = IRealitio(_newAddress);\n    }\n\n    /// @dev address of arbitrator, in case of continued disputes on reality.eth\n    function setArbitrator(address _newAddress) onlyOwner public {\n        arbitrator = _newAddress;\n    }\n\n    /// @dev how long reality.eth waits for disputes before finalising\n    function setTimeout(uint32 _newTimeout) onlyOwner public {\n        timeout = _newTimeout;\n    }\n\n    /// @dev admin can post question if not already posted\n    /// @dev for situations where bridge failed\n    function postQuestionToOracleAdmin(address _marketAddress, string calldata _question, uint32 _oracleResolutionTime) onlyOwner external {\n        require(questionIds[_marketAddress] == 0, \"Already posted\");\n        bytes32 _questionId = realitio.askQuestion(2, _question, arbitrator, timeout, _oracleResolutionTime, 0);\n        questionIds[_marketAddress] = _questionId;\n        emit LogQuestionPostedToOracle(_marketAddress, _questionId);\n    }\n\n    ////////////////////////////////////\n    //// GOVERNANCE - NFT UPGRADES /////\n    ////////////////////////////////////\n\n    /// @dev admin can create NFTs\n    /// @dev for situations where bridge failed\n    function upgradeCardAdmin(uint256 _newTokenId, string calldata _tokenUri, address _owner) onlyOwner external {\n        nfthub.mintNft(_newTokenId, _tokenUri, _owner);\n    }  \n\n    ////////////////////////////////////\n    ///// GOVERNANCE - DAI BRIDGE //////\n    ////////////////////////////////////\n\n    function enableOrDisableDeposits() onlyOwner external {\n        depositsEnabled = depositsEnabled ? false : true;\n    }\n    \n    ////////////////////////////////////\n    ///// CORE FUNCTIONS - ORACLE //////\n    ////////////////////////////////////\n    \n    ///@notice called by xdai proxy via bridge, posts question to Oracle\n    function postQuestionToOracle(address _marketAddress, string calldata _question, uint32 _oracleResolutionTime) external {\n        require(msg.sender == address(bridge), \"Not bridge\");\n        require(bridge.messageSender() == proxyXdaiAddress, \"Not proxy\");\n        require(questionIds[_marketAddress] == 0, \"Already posted\");\n        bytes32 _questionId = realitio.askQuestion(2, _question, arbitrator, timeout, _oracleResolutionTime, 0);\n        questionIds[_marketAddress] = _questionId;\n        emit LogQuestionPostedToOracle(_marketAddress, _questionId);\n    }\n\n    /// @notice has the oracle finalised \n    function isFinalized(address _marketAddress) public view returns(bool) {\n        bytes32 _questionId = questionIds[_marketAddress];\n        bool _isFinalized = realitio.isFinalized(_questionId);\n        return _isFinalized;\n    }\n\n    /// @dev can be called by anyone, reads winner from Oracle and sends to xdai proxy via bridge\n    /// @dev can be called more than once in case bridge fails, xdai proxy will reject a second successful call\n    function getWinnerFromOracle(address _marketAddress) external {\n        require(isFinalized(_marketAddress), \"Oracle not finalised\");\n        bytes32 _questionId = questionIds[_marketAddress];\n        bytes32 _winningOutcome = realitio.resultFor(_questionId);\n        bytes4 _methodSelector = IRCProxyXdai(address(0)).setWinner.selector;\n        bytes memory data = abi.encodeWithSelector(_methodSelector, _marketAddress, _winningOutcome);\n        bridge.requireToPassMessage(proxyXdaiAddress,data,400000);\n    }\n\n    ////////////////////////////////////\n    /// CORE FUNCTIONS - NFT UPGRADES //\n    ////////////////////////////////////\n\n    /// @notice mints NFT with metadata as sent by proxy\n    function upgradeCard(uint256 _newTokenId, string calldata _tokenUri, address _owner) external {\n        require(msg.sender == address(bridge), \"Not bridge\");\n        require(bridge.messageSender() == proxyXdaiAddress, \"Not proxy\");\n        nfthub.mintNft(_newTokenId, _tokenUri, _owner);\n    }  \n\n    ////////////////////////////////////\n    //// CORE FUNCTIONS - DAI BRIDGE ///\n    ////////////////////////////////////\n\n    /// @dev user deposit assuming prior approval\n    function depositDai(uint256 _amount) external {\n        _depositDai(msg.sender, _amount); \n    }\n\n    /// @dev user deposit without prior approval\n    function permitAndDepositDai(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s, uint256 _amount) external {\n        require(allowed, \"only possible if allowance is set\");\n        dai.permit(holder, spender, nonce, expiry, allowed, v, r, s);\n        _depositDai(holder, _amount);\n    }\n\n    /// @dev send Dai to xDai proxy and emit event for offchain validator \n    function _depositDai(address _sender, uint256 _amount) internal {\n        require(depositsEnabled, \"Deposits disabled\");\n        require(dai.transferFrom(_sender, address(this), _amount), \"Token transfer failed\");\n        alternateReceiverBridge.relayTokens(address(this), proxyXdaiAddress, _amount);\n        emit DaiDeposited(_sender, _amount, depositNonce++);\n    }\n}"
    }
  ]
}