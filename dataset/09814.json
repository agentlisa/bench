{
  "Title": "[M-10] LockedBalance library should drop parameters to 96/32 bits",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/contracts/libraries/LockedBalance.sol#L56\n\n\n# Vulnerability details\n\n## Impact\nThe `LockedBalance` contract takes 256-bit amount values but performs bit math on them as if they were 96 bit values.\nBits could spill over to a different locked balance in the `else` part (`lockedBalance` stores **two** 128-bit locked balances in one 256-bit storage field):\n\n```solidity\nfunction set(\n  Lockups storage lockups,\n  uint256 index,\n  uint256 expiration,\n  uint256 totalAmount\n) internal {\n  unchecked {\n    // @audit-issue should drop totalAmount to 96, expiration to 128-96=32\n    uint256 lockedBalanceBits = totalAmount | (expiration << 96);\n    if (index % 2 == 0) {\n      // set first 128 bits.\n      index /= 2;\n      // @audit-info clears upper bits, then sets them\n      lockups.lockups[index] = (lockups.lockups[index] & last128BitsMask) | (lockedBalanceBits << 128);\n    } else {\n      // set last 128 bits.\n      index /= 2;\n      // @audit-info clears lower bits, then sets them\n      // @audit-issue sets entire 256-bit lockedBalanceBits instead of just 128-bit\n      lockups.lockups[index] = (lockups.lockups[index] & first128BitsMask) | lockedBalanceBits;\n    }\n  }\n}\n```\n\nIt could then increase the other, unrelated locked balance's amount leading to stealing funds from the protocol.\nAll callers of this function currently seem to ensure that `totalAmount` is indeed less than 96 bits but the `LockedBalance` library should be self-contained and not depend on the calling side to perform all checks.\nIf the code is ever extended and more calls to these functions are performed, it'll likely cause issues.\n\n> The same issue happens in `setTotalAmount`\n\n## Recommended Mitigation Steps\nMake sure that there are only 96/32 bits set in `totalAmount` and `expiration` by dropping them to their respective types.\n\n```diff\nfunction set(\n  Lockups storage lockups,\n  uint256 index,\n  uint256 expiration,\n  uint256 totalAmount\n) internal {\n  unchecked {\n-    uint256 lockedBalanceBits = totalAmount | (expiration << 96);\n+    // cast it to uint256 again for the << 96 to work on 256-bits\n+    uint256 lockedBalanceBits = uint256(uint96(totalAmount)) | (uint256(uint32(expiration)) << 96);\n    \n    ...\n  }\n}\n```\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-02-foundation-contest",
  "Code": [
    {
      "filename": "contracts/libraries/LockedBalance.sol",
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\n/**\n * @title Library that handles locked balances efficiently using bit packing.\n */\nlibrary LockedBalance {\n  /// @dev Tracks an account's total lockup per expiration time.\n  struct Lockup {\n    uint32 expiration;\n    uint96 totalAmount;\n  }\n\n  struct Lockups {\n    /// @dev Mapping from key to lockups.\n    /// i) A key represents 2 lockups. The key for a lockup is `index / 2`.\n    ///     For instance, elements with index 25 and 24 would map to the same key.\n    /// ii) The `value` for the `key` is split into two 128bits which are used to store the metadata for a lockup.\n    mapping(uint256 => uint256) lockups;\n  }\n\n  // Masks used to split a uint256 into two equal pieces which represent two individual Lockups.\n  uint256 private constant last128BitsMask = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n  uint256 private constant first128BitsMask = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000000000000000000000000000;\n\n  // Masks used to retrieve or set the totalAmount value of a single Lockup.\n  uint256 private constant firstAmountBitsMask = 0xFFFFFFFF000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n  uint256 private constant secondAmountBitsMask = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000;\n\n  /**\n   * @notice Clears the lockup at the index.\n   */\n  function del(Lockups storage lockups, uint256 index) internal {\n    unchecked {\n      if (index % 2 == 0) {\n        index /= 2;\n        lockups.lockups[index] = (lockups.lockups[index] & last128BitsMask);\n      } else {\n        index /= 2;\n        lockups.lockups[index] = (lockups.lockups[index] & first128BitsMask);\n      }\n    }\n  }\n\n  /**\n   * @notice Sets the Lockup at the provided index.\n   */\n  function set(\n    Lockups storage lockups,\n    uint256 index,\n    uint256 expiration,\n    uint256 totalAmount\n  ) internal {\n    unchecked {\n      uint256 lockedBalanceBits = totalAmount | (expiration << 96);\n      if (index % 2 == 0) {\n        // set first 128 bits.\n        index /= 2;\n        lockups.lockups[index] = (lockups.lockups[index] & last128BitsMask) | (lockedBalanceBits << 128);\n      } else {\n        // set last 128 bits.\n        index /= 2;\n        lockups.lockups[index] = (lockups.lockups[index] & first128BitsMask) | lockedBalanceBits;\n      }\n    }\n  }\n\n  /**\n   * @notice Sets only the totalAmount for a lockup at the index.\n   */\n  function setTotalAmount(\n    Lockups storage lockups,\n    uint256 index,\n    uint256 totalAmount\n  ) internal {\n    unchecked {\n      if (index % 2 == 0) {\n        index /= 2;\n        lockups.lockups[index] = (lockups.lockups[index] & firstAmountBitsMask) | (totalAmount << 128);\n      } else {\n        index /= 2;\n        lockups.lockups[index] = (lockups.lockups[index] & secondAmountBitsMask) | totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the Lockup at the provided index.\n   * @dev To get the lockup stored in the *first* 128 bits (first slot/lockup):\n   *       - we remove the last 128 bits (done by >> 128)\n   *      To get the lockup stored in the *last* 128 bits (second slot/lockup):\n   *       - we take the last 128 bits (done by % (2**128))\n   *      Once the lockup is obtained:\n   *       - get `expiration` by peaking at the first 32 bits (done by >> 96)\n   *       - get `totalAmount` by peaking at the last 96 bits (done by % (2**96))\n   */\n  function get(Lockups storage lockups, uint256 index) internal view returns (Lockup memory balance) {\n    unchecked {\n      uint256 lockupMetadata = lockups.lockups[index / 2];\n      if (lockupMetadata == 0) {\n        return balance;\n      }\n      uint128 lockedBalanceBits;\n      if (index % 2 == 0) {\n        // use first 128 bits.\n        lockedBalanceBits = uint128(lockupMetadata >> 128);\n      } else {\n        // use last 128 bits.\n        lockedBalanceBits = uint128(lockupMetadata % (2**128));\n      }\n      // unpack the bits to retrieve the Lockup.\n      balance.expiration = uint32(lockedBalanceBits >> 96);\n      balance.totalAmount = uint96(lockedBalanceBits % (2**96));\n    }\n  }\n}"
    }
  ]
}