{
  "Title": "[M-02] Badger rewards from Hidden Hand can permanently prevent Strategy from receiving bribes",
  "Content": "_Submitted by scaraven, also found by berndartmueller, cccz, dipp, GimelSec, kenzo, kirk-baird, and unforgiven_\n\n<https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L428-L430>\n\n<https://github.com/Badger-Finance/badger-vaults-1.5/blob/3c96bd83e9400671256b235422f63644f1ae3d2a/contracts/BaseStrategy.sol#L351>\n\n<https://github.com/Badger-Finance/vested-aura/blob/d504684e4f9b56660a9e6c6dfb839dcebac3c174/contracts/MyStrategy.sol#L407-L408>\n\n### Impact\n\nIf the contract receives rewards from the hidden hand marketplace in BADGER then the contract tries to transfer the same amount of tokens twice to two different accounts, once with `_sendBadgerToTree()` in `MyStrategy` and again with `_processExtraToken()` in the `BasicStrategy` contract. As it is very likely that the strategy will not start with any BADGER tokens, the second transfer will revert (as we are using safeTransfer). This means that `claimBribesFromHiddenHand()` will always revert preventing any other bribes from being received.\n\n### Proof of Concept\n\n1.  `claimBribesFromHiddenHand()` is called by strategist\n2.  Multiple bribes are sent to the strategy including BADGER. For example lets say 50 USDT And 50 BADGER\n3.  Strategy receives BADGER and calls `_handleRewardTransfer()` which calls `_sendBadgerToTree()`. 50 BADGER is sent to the Badger Tree so balance has dropped to 0.\n4.  50 Badger is then again sent to Vault however balance is 0 so the command fails and reverts\n5.  No more tokens can be claimed anymore\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\n`_processExtraToken()` eventually sends the badger to the badger tree through the `Vault` contract. Change\n\n        function _sendBadgerToTree(uint256 amount) internal {\n            IERC20Upgradeable(BADGER).safeTransfer(BADGER_TREE, amount);\n            _processExtraToken(address(BADGER), amount);\n        }\n\nto\n\n        function _sendBadgerToTree(uint256 amount) internal {\n            _processExtraToken(address(BADGER), amount);\n        }\n\n**[Alex the Entreprenerd (BadgerDAO) confirmed and commented](https://github.com/code-423n4/2022-06-badger-findings/issues/111#issuecomment-1159591891):**\n > Developer oversight yeah.\n\n**[shuklaayush (BadgerDAO) commented](https://github.com/code-423n4/2022-06-badger-findings/issues/111#issuecomment-1160811781):**\n > Yeah, badger bribes can't be claimed. Not sure if I'll call it high risk but definitely an oversight.\n\n **[jack-the-pug (judge) validated and decreased severity to Medium](https://github.com/code-423n4/2022-06-badger-findings/issues/111)** \n\n**[Alex the Entreprenerd (BadgerDAO) commented](https://github.com/code-423n4/2022-06-badger-findings/issues/111#issuecomment-1183746419):**\n > We mitigated by fixing the mistake.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-06-badger-vested-aura-contest",
  "Code": [
    {
      "filename": "contracts/MyStrategy.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {IERC20Upgradeable} from \"@openzeppelin-contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin-contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport {SafeMathUpgradeable} from \"@openzeppelin-contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin-contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\";\nimport {BaseStrategy} from \"@badger-finance/BaseStrategy.sol\";\n\nimport {IVault} from \"../interfaces/badger/IVault.sol\";\nimport {IAsset} from \"../interfaces/balancer/IAsset.sol\";\nimport {ExitKind, IBalancerVault} from \"../interfaces/balancer/IBalancerVault.sol\";\nimport {IAuraLocker} from \"../interfaces/aura/IAuraLocker.sol\";\nimport {IRewardDistributor} from \"../interfaces/hiddenhand/IRewardDistributor.sol\";\nimport {IBribesProcessor} from \"../interfaces/badger/IBribesProcessor.sol\";\nimport {IWeth} from \"../interfaces/weth/IWeth.sol\";\n\ncontract MyStrategy is BaseStrategy, ReentrancyGuardUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SafeMathUpgradeable for uint256;\n\n    bool public withdrawalSafetyCheck;\n    // If nothing is unlocked, processExpiredLocks will revert\n    bool public processLocksOnReinvest;\n\n    bool private isClaimingBribes;\n\n    IBribesProcessor public bribesProcessor;\n\n    IBalancerVault public constant BALANCER_VAULT = IBalancerVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);\n\n    address public constant BADGER = 0x3472A5A71965499acd81997a54BBA8D852C6E53d;\n    address public constant BADGER_TREE = 0x660802Fc641b154aBA66a62137e71f331B6d787A;\n\n    IAuraLocker public constant LOCKER = IAuraLocker(0x3Fa73f1E5d8A792C80F426fc8F84FBF7Ce9bBCAC);\n\n    IERC20Upgradeable public constant BAL = IERC20Upgradeable(0xba100000625a3754423978a60c9317c58a424e3D);\n    IERC20Upgradeable public constant WETH = IERC20Upgradeable(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    IERC20Upgradeable public constant AURA = IERC20Upgradeable(0xC0c293ce456fF0ED870ADd98a0828Dd4d2903DBF);\n    IERC20Upgradeable public constant AURABAL = IERC20Upgradeable(0x616e8BfA43F920657B3497DBf40D6b1A02D4608d);\n    IERC20Upgradeable public constant BALETH_BPT = IERC20Upgradeable(0x5c6Ee304399DBdB9C8Ef030aB642B10820DB8F56);\n\n    bytes32 public constant AURABAL_BALETH_BPT_POOL_ID = 0x3dd0843a028c86e0b760b1a76929d1c5ef93a2dd000200000000000000000249;\n    bytes32 public constant BAL_ETH_POOL_ID = 0x5c6ee304399dbdb9c8ef030ab642b10820db8f56000200000000000000000014;\n    bytes32 public constant AURA_ETH_POOL_ID = 0xc29562b045d80fd77c69bec09541f5c16fe20d9d000200000000000000000251;\n\n    uint256 private constant BPT_WETH_INDEX = 1;\n\n    event RewardsCollected(address token, uint256 amount);\n\n    /// @dev Initialize the Strategy with security settings as well as tokens\n    /// @notice Proxies will set any non constant variable you declare as default value\n    /// @dev add any extra changeable variable at end of initializer as shown\n    function initialize(address _vault) public initializer {\n        assert(IVault(_vault).token() == address(AURA));\n\n        __BaseStrategy_init(_vault);\n\n        want = address(AURA);\n\n        /// @dev do one off approvals here\n        // Permissions for Locker\n        AURA.safeApprove(address(LOCKER), type(uint256).max);\n\n        AURABAL.safeApprove(address(BALANCER_VAULT), type(uint256).max);\n        WETH.safeApprove(address(BALANCER_VAULT), type(uint256).max);\n\n        // Set Safe Defaults\n        withdrawalSafetyCheck = true;\n\n        // Process locks on reinvest is best left false as gov can figure out if they need to save that gas\n    }\n\n    /// ===== Extra Functions =====\n\n    /// @dev Change Delegation to another address\n    function manualSetDelegate(address delegate) external {\n        _onlyGovernance();\n        // Set delegate is enough as it will clear previous delegate automatically\n        LOCKER.delegate(delegate);\n    }\n\n    ///@dev Should we check if the amount requested is more than what we can return on withdrawal?\n    function setWithdrawalSafetyCheck(bool newWithdrawalSafetyCheck) external {\n        _onlyGovernance();\n        withdrawalSafetyCheck = newWithdrawalSafetyCheck;\n    }\n\n    ///@dev Should we processExpiredLocks during reinvest?\n    function setProcessLocksOnReinvest(bool newProcessLocksOnReinvest) external {\n        _onlyGovernance();\n        processLocksOnReinvest = newProcessLocksOnReinvest;\n    }\n\n     ///@dev Change the contract that handles bribes\n    function setBribesProcessor(IBribesProcessor newBribesProcessor) external {\n        _onlyGovernance();\n        bribesProcessor = newBribesProcessor;\n    }\n\n    /// @dev Function to move rewards that are not protected\n    /// @notice Only not protected, moves the whole amount using _handleRewardTransfer\n    /// @notice because token paths are hardcoded, this function is safe to be called by anyone\n    /// @notice Will not notify the BRIBES_PROCESSOR as this could be triggered outside bribes\n    function sweepRewardToken(address token) public nonReentrant {\n        _onlyGovernanceOrStrategist();\n        _onlyNotProtectedTokens(token);\n\n        uint256 toSend = IERC20Upgradeable(token).balanceOf(address(this));\n        _handleRewardTransfer(token, toSend);\n    }\n\n    /// @dev Bulk function for sweepRewardToken\n    function sweepRewards(address[] calldata tokens) external {\n        uint256 length = tokens.length;\n        for(uint i = 0; i < length; i++){\n            sweepRewardToken(tokens[i]);\n        }\n    }\n\n   /// ===== View Functions =====\n\n    /// @dev Return the name of the strategy\n    function getName() external pure override returns (string memory) {\n        return \"vlAURA Voting Strategy\";\n    }\n\n    /// @dev Specify the version of the Strategy, for upgrades\n    function version() external pure returns (string memory) {\n        return \"1.0\";\n    }\n\n    /// @dev Does this function require `tend` to be called?\n    function _isTendable() internal pure override returns (bool) {\n        return false; // Change to true if the strategy should be tended\n    }\n\n    /// @dev Return the balance (in want) that the strategy has invested somewhere\n    function balanceOfPool() public view override returns (uint256) {\n        // Return the balance in locker\n        IAuraLocker.Balances memory balances = LOCKER.balances(address(this));\n        return balances.locked;\n    }\n\n    /// @dev Return the balance of rewards that the strategy has accrued\n    /// @notice Used for offChain APY and Harvest Health monitoring\n    function balanceOfRewards() external view override returns (TokenAmount[] memory rewards) {\n        IAuraLocker.EarnedData[] memory earnedData = LOCKER.claimableRewards(address(this));\n        uint256 numRewards = earnedData.length;\n        rewards = new TokenAmount[](numRewards);\n        for (uint256 i; i < numRewards; ++i) {\n            rewards[i] = TokenAmount(earnedData[i].token, earnedData[i].amount);\n        }\n    }\n\n    /// @dev Return a list of protected tokens\n    /// @notice It's very important all tokens that are meant to be in the strategy to be marked as protected\n    /// @notice this provides security guarantees to the depositors they can't be sweeped away\n    function getProtectedTokens() public view virtual override returns (address[] memory) {\n        address[] memory protectedTokens = new address[](2);\n        protectedTokens[0] = want; // AURA\n        protectedTokens[1] = address(AURABAL);\n        return protectedTokens;\n    }\n\n    /// ===== Internal Core Implementations =====\n\n    /// @dev Deposit `_amount` of want, investing it to earn yield\n    function _deposit(uint256 _amount) internal override {\n        // Lock tokens for 16 weeks, send credit to strat\n        LOCKER.lock(address(this), _amount);\n    }\n\n    /// @dev utility function to withdraw all AURA that we can from the lock\n    function prepareWithdrawAll() external {\n        manualProcessExpiredLocks();\n    }\n\n    /// @dev Withdraw all funds, this is used for migrations, most of the time for emergency reasons\n    function _withdrawAll() internal override {\n        //NOTE: This probably will always fail unless we have all tokens expired\n        require(\n            balanceOfPool() == 0 && LOCKER.balanceOf(address(this)) == 0,\n            \"You have to wait for unlock or have to manually rebalance out of it\"\n        );\n\n        // Make sure to call prepareWithdrawAll before _withdrawAll\n    }\n\n    /// @dev Withdraw `_amount` of want, so that it can be sent to the vault / depositor\n    /// @notice just unlock the funds and return the amount you could unlock\n    function _withdrawSome(uint256 _amount) internal override returns (uint256) {\n        uint256 max = balanceOfWant();\n\n        if (_amount > max) {\n            // Try to unlock, as much as possible\n            // @notice Reverts if no locks expired\n            LOCKER.processExpiredLocks(false);\n            max = balanceOfWant();\n        }\n\n        if (withdrawalSafetyCheck) {\n            require(max >= _amount.mul(9_980).div(MAX_BPS), \"Withdrawal Safety Check\"); // 20 BP of slippage\n        }\n\n        if (_amount > max) {\n            return max;\n        }\n\n        return _amount;\n    }\n\n    /// @notice Autocompound auraBAL rewards into AURA.\n    /// @dev Anyone can claim bribes for this contract from hidden hands with \n    ///      the correct merkle proof. Therefore, only tokens that are gained\n    ///      after claiming rewards or swapping are auto-compunded.\n    function _harvest() internal override returns (TokenAmount[] memory harvested) {\n        uint256 auraBalBalanceBefore = AURABAL.balanceOf(address(this));\n\n        // Claim auraBAL from locker\n        LOCKER.getReward(address(this));\n\n        harvested = new TokenAmount[](1);\n        harvested[0].token = address(AURA);\n\n        uint256 auraBalEarned = AURABAL.balanceOf(address(this)).sub(auraBalBalanceBefore);\n        // auraBAL -> BAL/ETH BPT -> WETH -> AURA\n        if (auraBalEarned > 0) {\n            // Common structs for swaps\n            IBalancerVault.SingleSwap memory singleSwap;\n            IBalancerVault.FundManagement memory fundManagement = IBalancerVault.FundManagement({\n                sender: address(this),\n                fromInternalBalance: false,\n                recipient: payable(address(this)),\n                toInternalBalance: false\n            });\n\n            // Swap auraBal -> BAL/ETH BPT\n            singleSwap = IBalancerVault.SingleSwap({\n                poolId: AURABAL_BALETH_BPT_POOL_ID,\n                kind: IBalancerVault.SwapKind.GIVEN_IN,\n                assetIn: IAsset(address(AURABAL)),\n                assetOut: IAsset(address(BALETH_BPT)),\n                amount: auraBalEarned,\n                userData: new bytes(0)\n            });\n            uint256 balEthBptEarned = BALANCER_VAULT.swap(singleSwap, fundManagement, 0, type(uint256).max);\n\n            // Withdraw BAL/ETH BPT -> WETH\n            uint256 wethBalanceBefore = WETH.balanceOf(address(this));\n\n            IAsset[] memory assets = new IAsset[](2);\n            assets[0] = IAsset(address(BAL));\n            assets[1] = IAsset(address(WETH));\n            IBalancerVault.ExitPoolRequest memory exitPoolRequest = IBalancerVault.ExitPoolRequest({\n                assets: assets,\n                minAmountsOut: new uint256[](2),\n                userData: abi.encode(ExitKind.EXACT_BPT_IN_FOR_ONE_TOKEN_OUT, balEthBptEarned, BPT_WETH_INDEX),\n                toInternalBalance: false\n            });\n            BALANCER_VAULT.exitPool(BAL_ETH_POOL_ID, address(this), payable(address(this)), exitPoolRequest);\n\n            // Swap WETH -> AURA\n            uint256 wethEarned = WETH.balanceOf(address(this)).sub(wethBalanceBefore);\n            singleSwap = IBalancerVault.SingleSwap({\n                poolId: AURA_ETH_POOL_ID,\n                kind: IBalancerVault.SwapKind.GIVEN_IN,\n                assetIn: IAsset(address(WETH)),\n                assetOut: IAsset(address(AURA)),\n                amount: wethEarned,\n                userData: new bytes(0)\n            });\n            harvested[0].amount = BALANCER_VAULT.swap(singleSwap, fundManagement, 0, type(uint256).max);\n        }\n\n        _reportToVault(harvested[0].amount);\n        if (harvested[0].amount > 0) {\n            _deposit(harvested[0].amount);\n        }\n    }\n\n    // TODO: Hardcode claim.account = address(this)?\n    /// @dev allows claiming of multiple bribes, badger is sent to tree\n    /// @notice Hidden hand only allows to claim all tokens at once, not individually.\n    ///         Allows claiming any token as it uses the difference in balance\n    function claimBribesFromHiddenHand(IRewardDistributor hiddenHandDistributor, IRewardDistributor.Claim[] calldata _claims) external nonReentrant {\n        _onlyGovernanceOrStrategist();\n        require(address(bribesProcessor) != address(0), \"Bribes processor not set\");\n\n        uint256 beforeVaultBalance = _getBalance();\n        uint256 beforePricePerFullShare = _getPricePerFullShare();\n\n        // Hidden hand uses BRIBE_VAULT address as a substitute for ETH\n        address hhBribeVault = hiddenHandDistributor.BRIBE_VAULT();\n\n        // Track token balances before bribes claim\n        uint256[] memory beforeBalance = new uint256[](_claims.length);\n        for (uint256 i = 0; i < _claims.length; i++) {\n            (address token, , , ) = hiddenHandDistributor.rewards(_claims[i].identifier);\n            if (token == hhBribeVault) {\n                beforeBalance[i] = address(this).balance;\n            } else {\n                beforeBalance[i] = IERC20Upgradeable(token).balanceOf(address(this));\n            }\n        }\n\n        // Claim bribes\n        isClaimingBribes = true;\n        hiddenHandDistributor.claim(_claims);\n        isClaimingBribes = false;\n\n        bool nonZeroDiff; // Cached value but also to check if we need to notifyProcessor\n        // Ultimately it's proof of non-zero which is good enough\n\n        for (uint256 i = 0; i < _claims.length; i++) {\n            (address token, , , ) = hiddenHandDistributor.rewards(_claims[i].identifier);\n\n            if (token == hhBribeVault) {\n                // ETH\n                uint256 difference = address(this).balance.sub(beforeBalance[i]);\n                if (difference > 0) {\n                    IWeth(address(WETH)).deposit{value: difference}();\n                    nonZeroDiff = true;\n                    _handleRewardTransfer(address(WETH), difference);\n                }\n            } else {\n                uint256 difference = IERC20Upgradeable(token).balanceOf(address(this)).sub(beforeBalance[i]);\n                if (difference > 0) {\n                    nonZeroDiff = true;\n                    _handleRewardTransfer(token, difference);\n                }\n            }\n        }\n\n        if (nonZeroDiff) {\n            _notifyBribesProcessor();\n        }\n\n        require(beforeVaultBalance == _getBalance(), \"Balance can't change\");\n        require(beforePricePerFullShare == _getPricePerFullShare(), \"Ppfs can't change\");\n    }\n\n    // Example tend is a no-op which returns the values, could also just revert\n    function _tend() internal override returns (TokenAmount[] memory tended) {\n        revert(\"no op\");\n    }\n\n    /// MANUAL FUNCTIONS ///\n\n    /// @dev manual function to reinvest all Aura that was locked\n    function reinvest() external whenNotPaused returns (uint256) {\n        _onlyGovernance();\n\n        if (processLocksOnReinvest) {\n            // Withdraw all we can\n            LOCKER.processExpiredLocks(false);\n        }\n\n        // Redeposit all into vlAURA\n        uint256 toDeposit = IERC20Upgradeable(want).balanceOf(address(this));\n\n        // Redeposit into vlAURA\n        _deposit(toDeposit);\n\n        return toDeposit;\n    }\n\n    /// @dev process all locks, to redeem\n    /// @notice No Access Control Checks, anyone can unlock an expired lock\n    function manualProcessExpiredLocks() public whenNotPaused {\n        // Unlock vlAURA that is expired and redeem AURA back to this strat\n        LOCKER.processExpiredLocks(false);\n    }\n\n    /// @dev Send all available Aura to the Vault\n    /// @notice you can do this so you can earn again (re-lock), or just to add to the redemption pool\n    function manualSendAuraToVault() external whenNotPaused {\n        _onlyGovernance();\n        uint256 auraAmount = balanceOfWant();\n        _transferToVault(auraAmount);\n    }\n\n    function checkUpkeep(bytes calldata checkData) external view returns (bool upkeepNeeded, bytes memory performData) {\n        (, uint256 unlockable, ,) = LOCKER.lockedBalances(address(this));\n        upkeepNeeded = unlockable > 0;\n    }\n\n    /// @dev Function for ChainLink Keepers to automatically process expired locks\n    function performUpkeep(bytes calldata performData) external {\n        // Works like this because it reverts if lock is not expired\n        LOCKER.processExpiredLocks(false);\n    }\n\n    function _getBalance() internal returns (uint256) {\n        return IVault(vault).balance();\n    }\n\n    function _getPricePerFullShare() internal returns (uint256) {\n        return IVault(vault).getPricePerFullShare();\n    }\n\n    /// *** Handling of rewards ***\n    function _handleRewardTransfer(address token, uint256 amount) internal {\n        // NOTE: BADGER is emitted through the tree\n        if (token == BADGER) {\n            _sendBadgerToTree(amount);\n        } else {\n            // NOTE: All other tokens are sent to bribes processor\n            _sendTokenToBribesProcessor(token, amount);\n        }\n    }\n\n    /// @dev Notify the BribesProcessor that a new round of bribes has happened\n    function _notifyBribesProcessor() internal {\n        bribesProcessor.notifyNewRound();\n    }\n\n    /// @dev Send funds to the bribes receiver\n    function _sendTokenToBribesProcessor(address token, uint256 amount) internal {\n        // TODO: Too many SLOADs\n        IERC20Upgradeable(token).safeTransfer(address(bribesProcessor), amount);\n        emit RewardsCollected(token, amount);\n    }\n\n    /// @dev Send the BADGER token to the badgerTree\n    function _sendBadgerToTree(uint256 amount) internal {\n        IERC20Upgradeable(BADGER).safeTransfer(BADGER_TREE, amount);\n        _processExtraToken(address(BADGER), amount);\n    }\n\n    /// PAYABLE FUNCTIONS ///\n\n    /// @dev Can only receive ether from Hidden Hand\n    receive() external payable {\n        require(isClaimingBribes, \"onlyWhileClaiming\");\n    }\n}"
    },
    {
      "filename": "contracts/BaseStrategy.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin-contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin-contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin-contracts-upgradeable/math/MathUpgradeable.sol\";\nimport \"@openzeppelin-contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin-contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport \"@openzeppelin-contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin-contracts-upgradeable/proxy/Initializable.sol\";\n\nimport \"../interfaces/badger/IVault.sol\";\n\n/*\n    ===== Badger Base Strategy =====\n    Common base class for all Sett strategies\n\n    Changelog\n    V1.1\n    - Verify amount unrolled from strategy positions on withdraw() is within a threshold relative to the requested amount as a sanity check\n    - Add version number which is displayed with baseStrategyVersion(). If a strategy does not implement this function, it can be assumed to be 1.0\n\n    V1.2\n    - Remove idle want handling from base withdraw() function. This should be handled as the strategy sees fit in _withdrawSome()\n\n    V1.5\n    - No controller as middleman. The Strategy directly interacts with the vault\n    - withdrawToVault would withdraw all the funds from the strategy and move it into vault\n    - strategy would take the actors from the vault it is connected to\n        - SettAccessControl removed\n    - fees calculation for autocompounding rewards moved to vault\n    - autoCompoundRatio param added to keep a track in which ratio harvested rewards are being autocompounded\n*/\n\n\n\nabstract contract BaseStrategy is PausableUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressUpgradeable for address;\n    using SafeMathUpgradeable for uint256;\n\n    uint256 public constant MAX_BPS = 10_000; // MAX_BPS in terms of BPS = 100%\n\n    address public want; // Token used for deposits\n    address public vault; // address of the vault the strategy is connected to\n    uint256 public withdrawalMaxDeviationThreshold; // max allowed slippage when withdrawing\n\n    /// @notice percentage of rewards converted to want\n    /// @dev converting of rewards to want during harvest should take place in this ratio\n    /// @dev change this ratio if rewards are converted in a different percentage\n    /// value ranges from 0 to 10_000\n    /// 0: keeping 100% harvest in reward tokens\n    /// 10_000: converting all rewards tokens to want token\n    uint256 public autoCompoundRatio; // NOTE: I believe this is unused\n\n    // NOTE: You have to set autoCompoundRatio in the initializer of your strategy\n\n    event SetWithdrawalMaxDeviationThreshold(uint256 newMaxDeviationThreshold);\n\n    // Return value for harvest, tend and balanceOfRewards\n    struct TokenAmount {\n        address token;\n        uint256 amount;\n    }\n\n    /// @notice Initializes BaseStrategy. Can only be called once. \n    ///         Make sure to call it from the initializer of the derived strategy.\n    /// @param _vault Address of the vault that the strategy reports to.\n    function __BaseStrategy_init(address _vault) public initializer whenNotPaused {\n        require(_vault != address(0), \"Address 0\");\n        __Pausable_init();\n\n        vault = _vault;\n\n        withdrawalMaxDeviationThreshold = 50; // BPS\n        // NOTE: See above\n        autoCompoundRatio = 10_000;\n    }\n\n    // ===== Modifiers =====\n\n    /// @notice Checks whether a call is from governance. \n    /// @dev For functions that only the governance should be able to call \n    ///      Most of the time setting setters, or to rescue/sweep funds\n    function _onlyGovernance() internal view {\n        require(msg.sender == governance(), \"onlyGovernance\");\n    }\n\n    /// @notice Checks whether a call is from strategist or governance. \n    /// @dev For functions that only known benign entities should call\n    function _onlyGovernanceOrStrategist() internal view {\n        require(msg.sender == strategist() || msg.sender == governance(), \"onlyGovernanceOrStrategist\");\n    }\n\n    /// @notice Checks whether a call is from keeper or governance. \n    /// @dev For functions that only known benign entities should call\n    function _onlyAuthorizedActors() internal view {\n        require(msg.sender == keeper() || msg.sender == governance(), \"onlyAuthorizedActors\");\n    }\n\n    /// @notice Checks whether a call is from the vault. \n    /// @dev For functions that only the vault should use\n    function _onlyVault() internal view {\n        require(msg.sender == vault, \"onlyVault\");\n    }\n\n    /// @notice Checks whether a call is from keeper, governance or the vault. \n    /// @dev Modifier used to check if the function is being called by a benign entity\n    function _onlyAuthorizedActorsOrVault() internal view {\n        require(msg.sender == keeper() || msg.sender == governance() || msg.sender == vault, \"onlyAuthorizedActorsOrVault\");\n    }\n\n    /// @notice Checks whether a call is from guardian or governance.\n    /// @dev Modifier used exclusively for pausing\n    function _onlyAuthorizedPausers() internal view {\n        require(msg.sender == guardian() || msg.sender == governance(), \"onlyPausers\");\n    }\n\n    /// ===== View Functions =====\n    /// @notice Used to track the deployed version of BaseStrategy.\n    /// @return Current version of the contract.\n    function baseStrategyVersion() external pure returns (string memory) {\n        return \"1.5\";\n    }\n\n    /// @notice Gives the balance of want held idle in the Strategy.\n    /// @dev Public because used internally for accounting\n    /// @return Balance of want held idle in the strategy.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20Upgradeable(want).balanceOf(address(this));\n    }\n\n    /// @notice Gives the total balance of want managed by the strategy.\n    ///         This includes all want deposited to active strategy positions as well as any idle want in the strategy.\n    /// @return Total balance of want managed by the strategy.\n    function balanceOf() external view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    /// @notice Tells whether the strategy is supposed to be tended.\n    /// @dev This is usually a constant. The harvest keeper would only call `tend` if this is true.\n    /// @return Boolean indicating whether strategy is supposed to be tended or not.\n    function isTendable() external pure returns (bool) {\n        return _isTendable();\n    }\n\n    function _isTendable() internal virtual pure returns (bool);\n\n    /// @notice Checks whether a token is a protected token.\n    ///         Protected tokens are managed by the strategy and can't be transferred/sweeped.\n    /// @return Boolean indicating whether the token is a protected token.\n    function isProtectedToken(address token) public view returns (bool) {\n        require(token != address(0), \"Address 0\");\n\n        address[] memory protectedTokens = getProtectedTokens();\n        for (uint256 i = 0; i < protectedTokens.length; i++) {\n            if (token == protectedTokens[i]) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /// @notice Fetches the governance address from the vault.\n    /// @return The governance address.\n    function governance() public view returns (address) {\n        return IVault(vault).governance();\n    }\n\n    /// @notice Fetches the strategist address from the vault.\n    /// @return The strategist address.\n    function strategist() public view returns (address) {\n        return IVault(vault).strategist();\n    }\n\n    /// @notice Fetches the keeper address from the vault.\n    /// @return The keeper address.\n    function keeper() public view returns (address) {\n        return IVault(vault).keeper();\n    }\n\n    /// @notice Fetches the guardian address from the vault.\n    /// @return The guardian address.\n    function guardian() public view returns (address) {\n        return IVault(vault).guardian();\n    }\n\n    /// ===== Permissioned Actions: Governance =====\n    \n    /// @notice Sets the max withdrawal deviation (percentage loss) that is acceptable to the strategy.\n    ///         This can only be called by governance.\n    /// @dev This is used as a slippage check against the actual funds withdrawn from strategy positions.\n    ///      See `withdraw`.\n    function setWithdrawalMaxDeviationThreshold(uint256 _threshold) external {\n        _onlyGovernance();\n        require(_threshold <= MAX_BPS, \"_threshold should be <= MAX_BPS\");\n        withdrawalMaxDeviationThreshold = _threshold;\n        emit SetWithdrawalMaxDeviationThreshold(_threshold);\n    }\n\n    /// @notice Deposits any idle want in the strategy into positions.\n    ///         This can be called by either the vault, keeper or governance.\n    ///         Note that deposits don't work when the strategy is paused. \n    /// @dev See `deposit`.\n    function earn() external whenNotPaused {\n        deposit();\n    }\n\n    /// @notice Deposits any idle want in the strategy into positions.\n    ///         This can be called by either the vault, keeper or governance.\n    ///         Note that deposits don't work when the strategy is paused. \n    /// @dev Is basically the same as tend, except without custom code for it \n    function deposit() public whenNotPaused {\n        _onlyAuthorizedActorsOrVault();\n        uint256 _amount = IERC20Upgradeable(want).balanceOf(address(this));\n        if (_amount > 0) {\n            _deposit(_amount);\n        }\n    }\n\n    // ===== Permissioned Actions: Vault =====\n\n    /// @notice Withdraw all funds from the strategy to the vault, unrolling all positions.\n    ///         This can only be called by the vault.\n    /// @dev This can be called even when paused, and strategist can trigger this via the vault.\n    ///      The idea is that this can allow recovery of funds back to the strategy faster.\n    ///      The risk is that if _withdrawAll causes a loss, this can be triggered.\n    ///      However the loss could only be triggered once (just like if governance called)\n    ///      as pausing the strats would prevent earning again.\n    function withdrawToVault() external {\n        _onlyVault();\n\n        _withdrawAll();\n\n        uint256 balance = IERC20Upgradeable(want).balanceOf(address(this));\n        _transferToVault(balance);\n    }\n\n    /// @notice Withdraw partial funds from the strategy to the vault, unrolling from strategy positions as necessary.\n    ///         This can only be called by the vault.\n    ///         Note that withdraws don't work when the strategy is paused. \n    /// @dev If the strategy fails to recover sufficient funds (defined by `withdrawalMaxDeviationThreshold`), \n    ///      the withdrawal would fail so that this unexpected behavior can be investigated.\n    /// @param _amount Amount of funds required to be withdrawn.\n    function withdraw(uint256 _amount) external whenNotPaused {\n        _onlyVault();\n        require(_amount != 0, \"Amount 0\");\n\n        // Withdraw from strategy positions, typically taking from any idle want first.\n        _withdrawSome(_amount);\n        uint256 _postWithdraw = IERC20Upgradeable(want).balanceOf(address(this));\n\n        // Sanity check: Ensure we were able to retrieve sufficient want from strategy positions\n        // If we end up with less than the amount requested, make sure it does not deviate beyond a maximum threshold\n        if (_postWithdraw < _amount) {\n            uint256 diff = _diff(_amount, _postWithdraw);\n\n            // Require that difference between expected and actual values is less than the deviation threshold percentage\n            require(diff <= _amount.mul(withdrawalMaxDeviationThreshold).div(MAX_BPS), \"withdraw-exceed-max-deviation-threshold\");\n        }\n\n        // Return the amount actually withdrawn if less than amount requested\n        uint256 _toWithdraw = MathUpgradeable.min(_postWithdraw, _amount);\n\n        // Transfer remaining to Vault to handle withdrawal\n        _transferToVault(_toWithdraw);\n    }\n\n    // Discussion: https://discord.com/channels/785315893960900629/837083557557305375\n    /// @notice Sends balance of any extra token earned by the strategy (from airdrops, donations etc.) to the vault.\n    ///         The `_token` should be different from any tokens managed by the strategy.\n    ///         This can only be called by the vault.\n    /// @dev This is a counterpart to `_processExtraToken`.\n    ///      This is for tokens that the strategy didn't expect to receive. Instead of sweeping, we can directly\n    ///      emit them via the badgerTree. This saves time while offering security guarantees.\n    ///      No address(0) check because _onlyNotProtectedTokens does it.\n    ///      This is not a rug vector as it can't use protected tokens.\n    /// @param _token Address of the token to be emitted.\n    function emitNonProtectedToken(address _token) external {\n        _onlyVault();\n        _onlyNotProtectedTokens(_token);\n        IERC20Upgradeable(_token).safeTransfer(vault, IERC20Upgradeable(_token).balanceOf(address(this)));\n        IVault(vault).reportAdditionalToken(_token);\n    }\n\n    /// @notice Withdraw the balance of a non-protected token to the vault.\n    ///         This can only be called by the vault.\n    /// @dev Should only be used in an emergency to sweep any asset.\n    ///      This is the version that sends the assets to governance.\n    ///      No address(0) check because _onlyNotProtectedTokens does it.\n    /// @param _asset Address of the token to be withdrawn.\n    function withdrawOther(address _asset) external {\n        _onlyVault();\n        _onlyNotProtectedTokens(_asset);\n        IERC20Upgradeable(_asset).safeTransfer(vault, IERC20Upgradeable(_asset).balanceOf(address(this)));\n    }\n\n    /// ===== Permissioned Actions: Authorized Contract Pausers =====\n\n    /// @notice Pauses the strategy.\n    ///         This can be called by either guardian or governance.\n    /// @dev Check the `onlyWhenPaused` modifier for functionality that is blocked when pausing\n    function p"
    }
  ]
}