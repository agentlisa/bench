{
  "Title": "[G-04] Use a more recent version of solidity",
  "Content": "\nUse a solidity version of at least 0.8.10 to have external calls skip contract existence checks if the external call has a return value\n\n1.  File: contracts/pcv/PCVDeposit.sol (line [2](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/pcv/PCVDeposit.sol#L2))\n\n```solidity\npragma solidity ^0.8.4;\n```\n\n2.  File: contracts/oracle/OraclePassThrough.sol (line [2](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/oracle/OraclePassThrough.sol#L2))\n\n```solidity\npragma solidity ^0.8.4;\n```\n\n3.  File: contracts/oracle/ScalingPriceOracle.sol (line [2](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/oracle/ScalingPriceOracle.sol#L2))\n\n```solidity\npragma solidity ^0.8.4;\n```\n\n4.  File: contracts/utils/Timed.sol (line [2](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/utils/Timed.sol#L2))\n\n```solidity\npragma solidity ^0.8.4;\n```\n\n5.  File: contracts/utils/Deviation.sol (line [2](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/utils/Deviation.sol#L2))\n\n```solidity\npragma solidity ^0.8.4;\n```\n\n6.  File: contracts/utils/GlobalRateLimitedMinter.sol (line [2](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/utils/GlobalRateLimitedMinter.sol#L2))\n\n```solidity\npragma solidity ^0.8.4;\n```\n\n7.  File: contracts/utils/MultiRateLimited.sol (line [2](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/utils/MultiRateLimited.sol#L2))\n\n```solidity\npragma solidity ^0.8.4;\n```\n\n8.  File: contracts/utils/RateLimited.sol (line [2](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/utils/RateLimited.sol#L2))\n\n```solidity\npragma solidity ^0.8.4;\n```\n\n9.  File: contracts/volt/Volt.sol (line [2](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/volt/Volt.sol#L2))\n\n```solidity\npragma solidity ^0.8.4;\n```\n\n10. File: contracts/refs/OracleRef.sol (line [2](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/refs/OracleRef.sol#L2))\n\n```solidity\npragma solidity ^0.8.4;\n```\n\n11. File: contracts/refs/CoreRef.sol (line [2](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/refs/CoreRef.sol#L2))\n\n```solidity\npragma solidity ^0.8.4;\n```\n\n12. File: contracts/core/Core.sol (line [2](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/core/Core.sol#L2))\n\n```solidity\npragma solidity ^0.8.4;\n```\n\n13. File: contracts/core/TribeRoles.sol (line [2](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/core/TribeRoles.sol#L2))\n\n```solidity\npragma solidity ^0.8.4;\n```\n\n14. File: contracts/core/Permissions.sol (line [2](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/core/Permissions.sol#L2))\n\n```solidity\npragma solidity ^0.8.4;\n```\n\n15. File: contracts/peg/NonCustodialPSM.sol (line [2](https://github.com/code-423n4/2022-03-volt/blob/f1210bf3151095e4d371c9e9d7682d9031860bbd/contracts/peg/NonCustodialPSM.sol#L2))\n\n```solidity\npragma solidity ^0.8.4;\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-03-volt-protocol-contest",
  "Code": [
    {
      "filename": "contracts/pcv/PCVDeposit.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"../refs/CoreRef.sol\";\nimport \"./IPCVDeposit.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @title abstract contract for withdrawing ERC-20 tokens using a PCV Controller\n/// @author Fei Protocol\nabstract contract PCVDeposit is IPCVDeposit, CoreRef {\n    using SafeERC20 for IERC20;\n\n    /// @notice withdraw ERC20 from the contract\n    /// @param token address of the ERC20 to send\n    /// @param to address destination of the ERC20\n    /// @param amount quantity of ERC20 to send\n    function withdrawERC20(\n        address token,\n        address to,\n        uint256 amount\n    ) public virtual override onlyPCVController {\n        _withdrawERC20(token, to, amount);\n    }\n\n    function _withdrawERC20(\n        address token,\n        address to,\n        uint256 amount\n    ) internal {\n        IERC20(token).safeTransfer(to, amount);\n        emit WithdrawERC20(msg.sender, token, to, amount);\n    }\n\n    /// @notice withdraw ETH from the contract\n    /// @param to address to send ETH\n    /// @param amountOut amount of ETH to send\n    function withdrawETH(address payable to, uint256 amountOut)\n        external\n        virtual\n        override\n        onlyPCVController\n    {\n        Address.sendValue(to, amountOut);\n        emit WithdrawETH(msg.sender, to, amountOut);\n    }\n\n    function balance() public view virtual override returns (uint256);\n\n    function resistantBalanceAndVolt()\n        public\n        view\n        virtual\n        override\n        returns (uint256, uint256)\n    {\n        return (balance(), 0);\n    }\n}"
    },
    {
      "filename": "contracts/oracle/OraclePassThrough.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport {Decimal} from \"../external/Decimal.sol\";\nimport {CoreRef} from \"./../refs/CoreRef.sol\";\nimport {IScalingPriceOracle} from \"./IScalingPriceOracle.sol\";\nimport {IOraclePassThrough} from \"./IOraclePassThrough.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/// @notice contract that passes all price calls to the Scaling Price Oracle\n/// The Scaling Price Oracle can be changed if there is a decision to change how data is interpolated\n/// without needing all contracts in the system to be upgraded, only this contract will have to change where it points\n/// @author Elliot Friedman\ncontract OraclePassThrough is IOraclePassThrough, Ownable {\n    using Decimal for Decimal.D256;\n\n    /// @notice reference to the scaling price oracle\n    IScalingPriceOracle public override scalingPriceOracle;\n\n    constructor(IScalingPriceOracle _scalingPriceOracle) Ownable() {\n        scalingPriceOracle = _scalingPriceOracle;\n    }\n\n    /// @notice updates the oracle price\n    /// @dev no-op, ScalingPriceOracle is updated automatically\n    /// added for backwards compatibility with OracleRef\n    function update() public {}\n\n    // ----------- Getters -----------\n\n    /// @notice function to get the current oracle price for the OracleRef contract\n    function read()\n        external\n        view\n        override\n        returns (Decimal.D256 memory price, bool valid)\n    {\n        uint256 currentPrice = scalingPriceOracle.getCurrentOraclePrice();\n\n        price = Decimal.from(currentPrice).div(1e18);\n        valid = true;\n    }\n\n    /// @notice function to get the current oracle price for the entire system\n    function getCurrentOraclePrice() external view override returns (uint256) {\n        return scalingPriceOracle.getCurrentOraclePrice();\n    }\n\n    // ----------- Governance only state changing api -----------\n\n    /// @notice function to update the pointer to the scaling price oracle\n    /// requires approval from all parties on multisig to update\n    function updateScalingPriceOracle(IScalingPriceOracle newScalingPriceOracle)\n        external\n        override\n        onlyOwner\n    {\n        IScalingPriceOracle oldScalingPriceOracle = scalingPriceOracle;\n        scalingPriceOracle = newScalingPriceOracle;\n\n        emit ScalingPriceOracleUpdate(\n            oldScalingPriceOracle,\n            newScalingPriceOracle\n        );\n    }\n}"
    },
    {
      "filename": "contracts/oracle/ScalingPriceOracle.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport {Timed} from \"./../utils/Timed.sol\";\nimport {CoreRef} from \"./../refs/CoreRef.sol\";\nimport {Decimal} from \"../external/Decimal.sol\";\nimport {Constants} from \"./../Constants.sol\";\nimport {Deviation} from \"./../utils/Deviation.sol\";\nimport {IScalingPriceOracle} from \"./IScalingPriceOracle.sol\";\nimport {BokkyPooBahsDateTimeContract} from \"./../external/calendar/BokkyPooBahsDateTimeContract.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {ERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {ChainlinkClient, Chainlink} from \"@chainlink/contracts/src/v0.8/ChainlinkClient.sol\";\n\n/// @notice contract that receives a chainlink price feed and then linearly interpolates that rate over\n/// a 28 day period into the VOLT price. Interest is compounded monthly when the rate is updated\n/// @author Elliot Friedman\ncontract ScalingPriceOracle is\n    Timed,\n    ChainlinkClient,\n    IScalingPriceOracle,\n    BokkyPooBahsDateTimeContract\n{\n    using SafeCast for *;\n    using Deviation for *;\n    using Decimal for Decimal.D256;\n    using Chainlink for Chainlink.Request;\n\n    /// ---------- Mutable Price Variables ----------\n\n    /// @notice current amount that oracle price is inflating/deflating by monthly in basis points\n    int256 public override monthlyChangeRateBasisPoints;\n\n    /// @notice oracle price. starts off at 1e18 and compounds monthly\n    uint256 public override oraclePrice = 1e18;\n\n    /// ---------- Mutable CPI Variables Packed Into Single Storage Slot to Save an SSTORE & SLOAD ----------\n\n    /// @notice the current month's CPI data\n    uint128 public currentMonth;\n\n    /// @notice the previous month's CPI data\n    uint128 public previousMonth;\n\n    /// ---------- Immutable Variables ----------\n\n    /// @notice the time frame over which all changes in CPI data are applied\n    /// 28 days was chosen as that is the shortest length of a month\n    uint256 public constant override TIMEFRAME = 28 days;\n\n    /// @notice the maximum allowable deviation in basis points for a new chainlink oracle update\n    /// only allow price changes by 20% in a month.\n    /// Any change over this threshold in either direction will be rejected\n    uint256 public constant override MAXORACLEDEVIATION = 2_000;\n\n    /// @notice address of chainlink oracle to send request\n    address public immutable oracle;\n\n    /// @notice job id that retrieves the latest CPI data\n    bytes32 public immutable jobId;\n\n    /// @notice amount in LINK paid to node operator for each request\n    uint256 public immutable fee;\n\n    /// @param _oracle address of chainlink data provider\n    /// @param _jobid job id\n    /// @param _fee maximum fee paid to chainlink data provider\n    /// @param _currentMonth current month's inflation data\n    /// @param _previousMonth previous month's inflation data\n    constructor(\n        address _oracle,\n        bytes32 _jobid,\n        uint256 _fee,\n        uint128 _currentMonth,\n        uint128 _previousMonth\n    ) Timed(TIMEFRAME) {\n        uint256 chainId;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            chainId := chainid()\n        }\n\n        if (chainId == 1 || chainId == 42) {\n            setPublicChainlinkToken();\n        }\n\n        oracle = _oracle;\n        jobId = _jobid;\n        fee = _fee;\n\n        currentMonth = _currentMonth;\n        previousMonth = _previousMonth;\n\n        _initTimed();\n\n        /// calculate new monthly CPI-U rate in basis points based on current and previous month\n        int256 aprBasisPoints = getMonthlyAPR();\n\n        /// store data and apply the change rate over the next month to the VOLT price\n        _oracleUpdateChangeRate(aprBasisPoints);\n    }\n\n    // ----------- Getters -----------\n\n    /// @notice get the current scaled oracle price\n    /// applies the change smoothly over a 28 day period\n    /// scaled by 18 decimals\n    // prettier-ignore\n    function getCurrentOraclePrice() public view override returns (uint256) {\n        int256 oraclePriceInt = oraclePrice.toInt256();\n\n        int256 timeDelta = Math.min(block.timestamp - startTime, TIMEFRAME).toInt256();\n        int256 pricePercentageChange = oraclePriceInt * monthlyChangeRateBasisPoints / Constants.BP_INT;\n        int256 priceDelta = pricePercentageChange * timeDelta / TIMEFRAME.toInt256();\n\n        return (oraclePriceInt + priceDelta).toUint256();\n    }\n\n    /// @notice get APR from chainlink data by measuring (current month - previous month) / previous month\n    /// @return percentageChange percentage change in basis points over past month\n    function getMonthlyAPR() public view returns (int256 percentageChange) {\n        int256 delta = int128(currentMonth) - int128(previousMonth);\n        percentageChange = (delta * Constants.BP_INT) / int128(previousMonth);\n    }\n\n    /// ------------- Public API To Request Chainlink Data -------------\n\n    /// @notice Create a Chainlink request to retrieve API response, find the target\n    /// data, then multiply by 1000 (to remove decimal places from data).\n    /// @return requestId for this request\n    /// only allows 1 request per month after the 14th day\n    /// callable by anyone after time period and 14th day of the month\n    function requestCPIData()\n        external\n        afterTimeInit\n        returns (bytes32 requestId)\n    {\n        require(\n            getDay(block.timestamp) > 14,\n            \"ScalingPriceOracle: cannot request data before the 15th\"\n        );\n\n        Chainlink.Request memory request = buildChainlinkRequest(\n            jobId,\n            address(this),\n            this.fulfill.selector\n        );\n\n        return sendChainlinkRequestTo(oracle, request, fee);\n    }\n\n    /// ------------- Chainlink Node Operator API -------------\n\n    /// @notice Receive the response in the form of uint256\n    /// @param _requestId of the chainlink request\n    /// @param _cpiData latest CPI data from BLS\n    /// called by the chainlink oracle\n    function fulfill(bytes32 _requestId, uint256 _cpiData)\n        external\n        recordChainlinkFulfillment(_requestId)\n    {\n        _updateCPIData(_cpiData);\n    }\n\n    // ----------- Internal state changing api -----------\n\n    /// @notice helper function to store and validate new chainlink data\n    /// @param _cpiData latest CPI data from BLS\n    /// update will fail if new values exceed deviation threshold of 20% monthly\n    function _updateCPIData(uint256 _cpiData) internal {\n        require(\n            MAXORACLEDEVIATION.isWithinDeviationThreshold(\n                currentMonth.toInt256(),\n                _cpiData.toInt256()\n            ),\n            \"ScalingPriceOracle: Chainlink data outside of deviation threshold\"\n        );\n\n        /// store CPI data, removes stale data\n        _addNewMonth(uint128(_cpiData));\n\n        /// calculate new monthly CPI-U rate in basis points\n        int256 aprBasisPoints = getMonthlyAPR();\n\n        /// pass data to VOLT Price Oracle\n        _oracleUpdateChangeRate(aprBasisPoints);\n    }\n\n    /// @notice function for chainlink oracle to be able to call in and change the rate\n    /// @param newChangeRateBasisPoints the new monthly interest rate applied to the chainlink oracle price\n    ///\n    /// function effects:\n    ///   compounds interest accumulated over period\n    ///   set new change rate in basis points for next period\n    function _oracleUpdateChangeRate(int256 newChangeRateBasisPoints) internal {\n        /// compound the interest with the current rate\n        oraclePrice = getCurrentOraclePrice();\n\n        int256 currentChangeRateBasisPoints = monthlyChangeRateBasisPoints; /// save 1 SSLOAD\n\n        /// emit even if there isn't an update\n        emit CPIMonthlyChangeRateUpdate(\n            currentChangeRateBasisPoints,\n            newChangeRateBasisPoints\n        );\n\n        /// if the oracle change rate is the same as last time, save an SSTORE\n        if (newChangeRateBasisPoints == currentChangeRateBasisPoints) {\n            return;\n        }\n\n        monthlyChangeRateBasisPoints = newChangeRateBasisPoints;\n    }\n\n    /// @notice this is the only method needed as we will be storing the most recent 2 months of data\n    /// @param newMonth the new month to store\n    function _addNewMonth(uint128 newMonth) internal {\n        previousMonth = currentMonth;\n\n        currentMonth = newMonth;\n    }\n}"
    },
    {
      "filename": "contracts/utils/Timed.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\n/// @title an abstract contract for timed events\n/// @author Fei Protocol\nabstract contract Timed {\n    /// @notice the start timestamp of the timed period\n    uint256 public startTime;\n\n    /// @notice the duration of the timed period\n    uint256 public duration;\n\n    event DurationUpdate(uint256 oldDuration, uint256 newDuration);\n\n    event TimerReset(uint256 startTime);\n\n    constructor(uint256 _duration) {\n        _setDuration(_duration);\n    }\n\n    modifier duringTime() {\n        require(isTimeStarted(), \"Timed: time not started\");\n        require(!isTimeEnded(), \"Timed: time ended\");\n        _;\n    }\n\n    modifier afterTime() {\n        require(isTimeEnded(), \"Timed: time not ended\");\n        _;\n    }\n\n    modifier afterTimeInit() {\n        require(isTimeEnded(), \"Timed: time not ended, init\");\n        _;\n        _initTimed();\n    }\n\n    /// @notice return true if time period has ended\n    function isTimeEnded() public view returns (bool) {\n        return remainingTime() == 0;\n    }\n\n    /// @notice number of seconds remaining until time is up\n    /// @return remaining\n    function remainingTime() public view returns (uint256) {\n        return duration - timeSinceStart(); // duration always >= timeSinceStart which is on [0,d]\n    }\n\n    /// @notice number of seconds since contract was initialized\n    /// @return timestamp\n    /// @dev will be less than or equal to duration\n    function timeSinceStart() public view returns (uint256) {\n        if (!isTimeStarted()) {\n            return 0; // uninitialized\n        }\n        uint256 _duration = duration;\n        uint256 timePassed = block.timestamp - startTime; // block timestamp always >= startTime\n        return timePassed > _duration ? _duration : timePassed;\n    }\n\n    function isTimeStarted() public view returns (bool) {\n        return startTime != 0;\n    }\n\n    function _initTimed() internal {\n        startTime = block.timestamp;\n\n        emit TimerReset(block.timestamp);\n    }\n\n    function _setDuration(uint256 newDuration) internal {\n        require(newDuration != 0, \"Timed: zero duration\");\n\n        uint256 oldDuration = duration;\n        duration = newDuration;\n        emit DurationUpdate(oldDuration, newDuration);\n    }\n}"
    },
    {
      "filename": "contracts/utils/Deviation.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport {Constants} from \"./../Constants.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n/// @title contract that determines whether or not a new value is within\n/// an acceptable deviation threshold\n/// @author Elliot Friedman, FEI Protocol\nlibrary Deviation {\n    using SafeCast for *;\n\n    /// @notice event that is emitted when the threshold is changed\n    event DeviationThresholdUpdate(uint256 oldThreshold, uint256 newThreshold);\n\n    /// @notice return the percent deviation between a and b in basis points terms\n    function calculateDeviationThresholdBasisPoints(int256 a, int256 b)\n        internal\n        pure\n        returns (uint256)\n    {\n        int256 delta = a - b;\n        int256 basisPoints = (delta * Constants.BP_INT) / a;\n\n        return (basisPoints < 0 ? basisPoints * -1 : basisPoints).toUint256();\n    }\n\n    /// @notice function to return whether or not the new price is within\n    /// the acceptable deviation threshold\n    function isWithinDeviationThreshold(\n        uint256 maxDeviationThresholdBasisPoints,\n        int256 oldValue,\n        int256 newValue\n    ) internal pure returns (bool) {\n        return\n            maxDeviationThresholdBasisPoints >=\n            calculateDeviationThresholdBasisPoints(oldValue, newValue);\n    }\n}"
    },
    {
      "filename": "contracts/utils/GlobalRateLimitedMinter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport {MultiRateLimited} from \"./MultiRateLimited.sol\";\nimport {IGlobalRateLimitedMinter} from \"./IGlobalRateLimitedMinter.sol\";\nimport {CoreRef} from \"./../refs/CoreRef.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/// @notice global contract to handle rate limited minting of VOLT on a global level\n/// allows whitelisted minters to call in and specify the address to mint VOLT to within\n/// that contract's limits\ncontract GlobalRateLimitedMinter is MultiRateLimited, IGlobalRateLimitedMinter {\n    /// @param coreAddress address of the core contract\n    /// @param _globalMaxRateLimitPerSecond maximum amount of VOLT that can replenish per second ever, this amount cannot be changed by governance\n    /// @param _perAddressRateLimitMaximum maximum rate limit per second per address\n    /// @param _maxRateLimitPerSecondPerAddress maximum rate limit per second per address in multi rate limited\n    /// @param _maxBufferCap maximum buffer cap in multi rate limited contract\n    /// @param _globalBufferCap maximum global buffer cap\n    constructor(\n        address coreAddress,\n        uint256 _globalMaxRateLimitPerSecond,\n        uint256 _perAddressRateLimitMaximum,\n        uint256 _maxRateLimitPerSecondPerAddress,\n        uint256 _maxBufferCap,\n        uint256 _globalBufferCap\n    )\n        CoreRef(coreAddress)\n        MultiRateLimited(\n            _globalMaxRateLimitPerSecond,\n            _perAddressRateLimitMaximum,\n            _maxRateLimitPerSecondPerAddress,\n            _maxBufferCap,\n            _globalBufferCap\n        )\n    {}\n\n    /// @notice mint VOLT to the target address and deplete the buffer\n    /// pausable and depletes the msg.sender's buffer\n    /// @param to the recipient address of the minted VOLT\n    /// @param amount the amount of VOLT to mint\n    function mintVolt(address to, uint256 amount)\n        external\n        virtual\n        override\n        whenNotPaused\n    {\n        _depleteIndividualBuffer(msg.sender, amount);\n        _mintVolt(to, amount);\n    }\n\n    /// @notice mint VOLT to the target address and deplete the whole rate limited\n    ///  minter's buffer, pausable and completely depletes the msg.sender's buffer\n    /// @param to the recipient address of the minted VOLT\n    /// mints all VOLT that msg.sender has in the buffer\n    function mintMaxAllowableVolt(address to)\n        external\n        virtual\n        override\n        whenNotPaused\n    {\n        uint256 amount = Math.min(individualBuffer(msg.sender), buffer());\n\n        _depleteIndividualBuffer(msg.sender, amount);\n        _mintVolt(to, amount);\n    }\n}"
    },
    {
      "filename": "contracts/utils/MultiRateLimited.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport {CoreRef} from \"../refs/CoreRef.sol\";\nimport {TribeRoles} from \"./../core/TribeRoles.sol\";\nimport {RateLimited} from \"./RateLimited.sol\";\nimport {IMultiRateLimited} from \"./IMultiRateLimited.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n/// @title abstract contract for putting a rate limit on how fast an address can perform an action e.g. Minting\n/// there are two buffers, one buffer which is each individual addresses's current buffer,\n/// and then there is a global buffer which is the buffer that each individual address must respect as well\n/// @author Elliot Friedman, Fei Protocol\n/// this contract was made abstract so that other contracts that already construct an instance of CoreRef\n/// do not collide with this one\nabstract contract MultiRateLimited is RateLimited, IMultiRateLimited {\n    using SafeCast for *;\n\n    /// @notice the struct containing all information per rate limited address\n    struct RateLimitData {\n        uint32 lastBufferUsedTime;\n        uint112 bufferCap;\n        uint112 bufferStored;\n        uint112 rateLimitPerSecond;\n    }\n\n    /// @notice rate limited address information\n    mapping(address => RateLimitData) public rateLimitPerAddress;\n\n    /// @notice max rate limit per second allowable by non governor per contract\n    uint256 public individualMaxRateLimitPerSecond;\n\n    /// @notice max buffer cap allowable by non governor per contract\n    uint256 public individualMaxBufferCap;\n\n    /// @param _maxRateLimitPerSecond maximum amount of fei that can replenish per second ever, this amount cannot be changed by governance\n    /// @param _rateLimitPerSecond maximum rate limit per second per address\n    /// @param _individualMaxRateLimitPerSecond maximum rate limit per second per address in multi rate limited\n    /// @param _individualMaxBufferCap maximum buffer cap in multi rate limited\n    /// @param _globalBufferCap maximum global buffer cap\n    constructor(\n        uint256 _maxRateLimitPerSecond,\n        uint256 _rateLimitPerSecond,\n        uint256 _individualMaxRateLimitPerSecond,\n        uint256 _individualMaxBufferCap,\n        uint256 _globalBufferCap\n    )\n        RateLimited(\n            _maxRateLimitPerSecond,\n            _rateLimitPerSecond,\n            _globalBufferCap,\n            false\n        )\n    {\n        require(\n            _individualMaxBufferCap < _globalBufferCap,\n            \"MultiRateLimited: max buffer cap invalid\"\n        );\n\n        individualMaxRateLimitPerSecond = _individualMaxRateLimitPerSecond;\n        individualMaxBufferCap = _individualMaxBufferCap;\n    }\n\n    modifier addressIsRegistered(address rateLimitedAddress) {\n        require(\n            rateLimitPerAddress[rateLimitedAddress].lastBufferUsedTime != 0,\n            \"MultiRateLimited: rate limit address does not exist\"\n        );\n        _;\n    }\n\n    // ----------- Governor and Admin only state changing api -----------\n\n    /// @notice update the ADD_MINTER_ROLE rate limit per second\n    /// @param newRateLimitPerSecond new maximum rate limit per second for add minter role\n    function updateMaxRateLimitPerSecond(uint256 newRateLimitPerSecond)\n        external\n        virtual\n        override\n        onlyGovernor\n    {\n        require(\n            newRateLimitPerSecond <= MAX_RATE_LIMIT_PER_SECOND,\n            \"MultiRateLimited: exceeds global max rate limit per second\"\n        );\n\n        uint256 oldMaxRateLimitPerSecond = individualMaxRateLimitPerSecond;\n        individualMaxRateLimitPerSecond = newRateLimitPerSecond;\n\n        emit MultiMaxRateLimitPerSecondUpdate(\n            oldMaxRateLimitPerSecond,\n            newRateLimitPerSecond\n        );\n    }\n\n    /// @notice update the ADD_MINTER_ROLE max buffer cap\n    /// @param newBufferCap new buffer cap for ADD_MINTER_ROLE added addresses\n    function updateMaxBufferCap(uint256 newBufferCap)\n        external\n        virtual\n        override\n        onlyGovernor\n    {\n        require(\n            newBufferCap <= bufferCap,\n            \"MultiRateLimited: exceeds global buffer cap\"\n        );\n\n        uint256 oldBufferCap = individualMaxBufferCap;\n        individualMaxBufferCap = newBufferCap;\n\n        emit MultiBufferCapUpdate(oldBufferCap, newBufferCap);\n    }\n\n    /// @notice add an authorized rateLimitedAddress contract\n    /// @param rateLimitedAddress the new address to add as a rateLimitedAddress\n    /// @param _rateLimitPerSecond the rate limit per second for this rateLimitedAddress\n    /// @param _bufferCap  the buffer cap for this rateLimitedAddress\n    function addAddress(\n        address rateLimitedAddress,\n        uint112 _rateLimitPerSecond,\n        uint112 _bufferCap\n    ) external virtual override onlyGovernor {\n        _addAddress(rateLimitedAddress, _rateLimitPerSecond, _bufferCap);\n    }\n\n    /// @notice add an authorized rateLimitedAddress contract\n    /// @param rateLimitedAddress the address whose buffer and rate limit per second will be set\n    /// @param _rateLimitPerSecond the new rate limit per second for this rateLimitedAddress\n    /// @param _bufferCap  the new buffer cap for this rateLimitedAddress\n    function updateAddress(\n        address rateLimitedAddress,\n        uint112 _rateLimitPerSecond,\n        uint112 _bufferCap\n    )\n        external\n        virtual\n        override\n        addressIsRegistered(rateLimitedAddress)\n        hasAnyOfTwoRoles(TribeRoles.ADD_MINTER_ROLE, TribeRoles.GOVERNOR)\n    {\n        if (core().hasRole(TribeRoles.ADD_MINTER_ROLE, msg.sender)) {\n            require(\n                _rateLimitPerSecond <= individualMaxRateLimitPerSecond,\n                \"MultiRateLimited: rate limit per second exceeds non governor allowable amount\"\n            );\n            require(\n                _bufferCap <= individualMaxBufferCap,\n                \"MultiRateLimited: max buffer cap exceeds non governor allowable amount\"\n            );\n        }\n        require(\n            _bufferCap <= bufferCap,\n            \"MultiRateLimited: buffercap too high\"\n        );\n\n        _updateAddress(rateLimitedAddress, _rateLimitPerSecond, _bufferCap);\n    }\n\n    /// @notice add an authorized rateLimitedAddress contract\n    /// @param rateLimitedAddress the new address to add as a rateLimitedAddress\n    /// gives the newly added contract the maximum allowable rate limit per second and buffer cap\n    function addAddressWithCaps(address rateLimitedAddress)\n        external\n        virtual\n        override\n        onlyTribeRole(TribeRoles.ADD_MINTER_ROLE)\n    {\n        _addAddress(\n            rateLimitedAddress,\n            uint112(individualMaxRateLimitPerSecond),\n            uint112(individualMaxBufferCap)\n        );\n    }\n\n    /// @notice remove an authorized rateLimitedAddress contract\n    /// @param rateLimitedAddress the address to remove from the whitelist of addresses\n    function removeAddress(address rateLimitedAddress)\n        external\n        virtual\n        override\n        addressIsRegistered(rateLimitedAddress)\n        onlyGuardianOrGovernor\n    {\n        uint256 oldRateLimitPerSecond = rateLimitPerAddress[rateLimitedAddress]\n            .rateLimitPerSecond;\n\n        delete rateLimitPerAddress[rateLimitedAddress];\n\n        emit IndividualRateLimitPerSecondUpdate(\n            rateLimitedAddress,\n            oldRateLimitPerSecond,\n            0\n        );\n    }\n\n    // ----------- Getters -----------\n\n    /// @notice the amount of action used before hitting limit\n    /// @dev replenishes at rateLimitPerSecond per second up to bufferCap\n    /// @param rateLimitedAddress the address whose buffer will be returned\n    /// @return the buffer of the specified rate limited address\n    function individualBuffer(address rateLimitedAddress)\n        public\n        view\n        override\n        returns (uint112)\n    {\n        RateLimitData memory rateLimitData = rateLimitPerAddress[\n            rateLimitedAddress\n        ];\n\n        uint256 elapsed = block.timestamp - rateLimitData.lastBufferUsedTime;\n        return\n            uint112(\n                Math.min(\n                    rateLimitData.bufferStored +\n                        (rateLimitData.rateLimitPerSecond * elapsed),\n                    rateLimitData.bufferCap\n                )\n            );\n    }\n\n    /// @notice the rate per second for each address\n    function getRateLimitPerSecond(address limiter)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return rateLimitPerAddress[limiter].rateLimitPerSecond;\n    }\n\n    /// @notice the last time the buffer was used by each address\n    function getLastBufferUsedTime(address limiter)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return rateLimitPerAddress[limiter].lastBufferUsedTime;\n    }\n\n    /// @notice the cap of the buffer that can be used at once\n    function getBufferCap(address limiter)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return rateLimitPerAddress[limiter].bufferCap;\n    }\n\n    // ----------- Helper Methods -----------\n\n    function _updateAddress(\n        address rateLimitedAddress,\n        uint112 _rateLimitPerSecond,\n        uint112 _bufferCap\n    ) internal {\n        RateLimitData storage rateLimitData = rateLimitPerAddress[\n            rateLimitedAddress\n        ];\n\n        require(\n            rateLimitData.lastBufferUsedTime != 0,\n            \"MultiRateLimited: rate limit address does not exist\"\n        );\n        require(\n            _rateLimitPerSecond <= MAX_RATE_LIMIT_PER_SECOND,\n            \"MultiRateLimited: rateLimitPerSecond too high\"\n        );\n\n        uint112 oldRateLimitPerSecond = rateLimitData.rateLimitPerSecond;\n\n        rateLimitData.lastBufferUsedTime = block.timestamp.toUint32();\n        rateLimitData.bufferCap = _bufferCap;\n        rateLimitData.rateLimitPerSecond = _rateLimitPerSecond;\n        rateLimitData.bufferStored = _bufferCap;\n\n        emit IndividualRateLimitPerSecondUpdate(\n            rateLimitedAddress,\n            oldRateLimitPerSecond,\n            _rateLimitPerSecond\n        );\n    }\n\n    /// @param rateLimitedAddress the new address to add as a rateLimitedAddress\n    /// @param _rateLimitPerSecond the rate limit per second for this rateLimitedAddress\n    /// @param _bufferCap  the buffer cap for this rateLimitedAddress\n    function _addAddress(\n        address rateLimitedAddress,\n        uint112 _rateLimitPerSecond,\n        uint112 _bufferCap\n    ) internal {\n        require(\n            _bufferCap <= bufferCap,\n            \"MultiRateLimited: new buffercap too high\"\n        );\n        require(\n            rateLimitPerAddress[rateLimitedAddress].lastBufferUsedTime == 0,\n            \"MultiRateLimited: address already added\"\n        );\n        require(\n            _rateLimitPerSecond <= MAX_RATE_LIMIT_PER_SECOND,\n            \"MultiRateLimited: rateLimitPerSecond too high\"\n        );\n\n        RateLimitData memory rateLimitData = RateLimitData({\n            lastBufferUsedTime: block.timestamp.toUint32(),\n            bufferCap: _bufferCap,\n            rateLimitPerSecond: _rateLimitPerSecond,\n            bufferStored: _bufferCap\n        });\n\n        rateLimitPerAddress[rateLimitedAddress] = rateLimitData;\n\n        emit IndividualRateLimitPerSecondUpdate(\n            rateLimitedAddress,\n            0,\n            _rateLimitPerSecond\n        );\n    }\n\n    /// @notice the method that enforces the rate limit. Decreases buffer by \"amount\".\n    /// @param rateLimitedAddress the address whose buffer will be depleted\n    /// @param amount the amount to remove from the rateLimitedAddress's buffer\n    function _depleteIndividualBuffer(\n        address rateLimitedAddress,\n        uint256 amount\n    ) internal returns (uint256) {\n        _depleteBuffer(amount);\n\n        uint256 newBuffer = individualBuffer(rateLimitedAddress);\n\n        require(newBuffer != 0, \"MultiRateLimited: no rate limit buffer\");\n        require(amount <= newBuffer, \"MultiRateLimited: rate limit hit\");\n\n        rateLimitPerAddress[rateLimitedAddress].bufferStored = uint112(\n            newBuffer - amount\n        );\n\n        rateLimitPerAddress[rateLimitedAddress].lastBufferUsedTime = block\n            .timestamp\n            .toUint32();\n\n        emit IndividualBufferUsed(\n            rateLimitedAddress,\n            amount,\n            newBuffer - amount\n        );\n\n        return amount;\n    }\n}"
    },
    {
      "filename": "contracts/utils/RateLimited.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"../refs/CoreRef.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/// @title abstract contract for putting a rate limit on how fast a contract can perform an action e.g. Minting\n/// @author Fei Protocol\nabstract contract RateLimited is CoreRef {\n    /// @notice maximum rate limit per second governance can set for this contract\n    uint256 public immutable MAX_RATE_LIMIT_PER_SECOND;\n\n    /// @notice the rate per second for this contract\n    uint256 public rateLimitPerSecond;\n\n    /// @notice the last time the buffer was used by the contract\n    uint256 public lastBufferUsedTime;\n\n    /// @notice the cap of the buffer that can be used at once\n    uint256 public bufferCap;\n\n    /// @notice a flag for whether to allow partial actions to complete if the buffer is less than amount\n    bool public doPartialAction;\n\n    /// @notice the buffer at the"
    }
  ]
}