{
  "Title": "[M-02] Unsafe implementation of `fundLoan()` allows attacker to steal collateral from an unfunded loan",
  "Content": "_Submitted by WatchPug_\n\n[`MapleLoanInternals.sol` L257-L273](https://github.com/maple-labs/loan/blob/9684bcef06481e493d060974b1777a4517c4e792/contracts/MapleLoanInternals.sol#L257-L273)\n\n```solidity\nuint256 treasuryFee = (fundsLent_ * ILenderLike(lender_).treasuryFee() * _paymentInterval * _paymentsRemaining) / uint256(365 days * 10_000);\n\n// Transfer delegate fee, if any, to the pool delegate, and decrement drawable funds.\nuint256 delegateFee = (fundsLent_ * ILenderLike(lender_).investorFee() * _paymentInterval * _paymentsRemaining) / uint256(365 days * 10_000);\n\n// Drawable funds is the amount funded, minus any fees.\n_drawableFunds = fundsLent_ - treasuryFee - delegateFee;\n\nrequire(\n    treasuryFee == uint256(0) || ERC20Helper.transfer(_fundsAsset, ILenderLike(lender_).mapleTreasury(), treasuryFee),\n    \"MLI:FL:T_TRANSFER_FAILED\"\n);\n\nrequire(\n    delegateFee == uint256(0) || ERC20Helper.transfer(_fundsAsset, ILenderLike(lender_).poolDelegate(), delegateFee),\n    \"MLI:FL:PD_TRANSFER_FAILED\"\n    );\n```\n\nIn the current implementation, `mapleTreasury`, `poolDelegate` and `treasuryFee` are taken from user input `lender_`, which can be faked by setting up a contract with `ILenderLike` interfaces.\n\nThis allows the attacker to set very high fees, making `_drawableFunds` near 0.\n\nSince `mapleTreasury` and `poolDelegate` are also read from `lender_`, `treasuryFee` and `investorFee` can be retrieved back to the attacker.\n\nAs a result, the borrower won't get any `_drawableFunds` while also being unable to remove collateral.\n\n##### PoC\n\nGiven:\n\n*   `_collateralRequired` = 10 BTC\n*   `_principalRequested` = 1,000,000 USDC\n*   `_paymentInterval` = 1 day\n*   `_paymentsRemaining` = 10\n*   `_gracePeriod` = 1 day\n\n1.  Alice (borrower) calls `postCollateral()` and added `10 BTC` as `_collateralAsset`;\n2.  The attacker calls `fundLoan()` by taking `1,000,000 USDC` of flashloan and using a fake `lender`contract;\n3.  Alice calls `drawdownFunds()` with any amount > 0 will fail;\n4.  Alice calls `removeCollateral()` with any amount > 0 will get \"MLI:DF:INSUFFICIENT_COLLATERAL\" error;\n5.  Unless Alice make payment (which is meaningless), after 2 day, the attacker can call `repossess()` and get `10 BTC`.\n\n##### Recommendation\n\nConsider reading `treasuryFee`, `investorFee`, `mapleTreasury`, `poolDelegate` from an authoritative source instead.\n\n**[lucas-manuel (Maple) confirmed and disagreed with severity](https://github.com/code-423n4/2021-12-maple-findings/issues/47#issuecomment-989304172):**\n > We would consider this medium risk, since a borrower would never post collateral before a loan is funded. We can enforce this on the smart contracts level though by adding a require to the `postCollateral` function to assert that the principal amount is greater than zero.\n\n**[pauliax (judge) commented](https://github.com/code-423n4/2021-12-maple-findings/issues/47#issuecomment-997435819):**\n > Great find. As per the sponsor's recommendation, this scenario is not very likely, so I am marking this issue as of medium severity.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2021-12-maple",
  "Code": [
    {
      "filename": "contracts/MapleLoanInternals.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.7;\n\nimport { IERC20 } from \"../modules/erc20/src/interfaces/IERC20.sol\";\n\nimport { ERC20Helper }  from \"../modules/erc20-helper/src/ERC20Helper.sol\";\nimport { MapleProxied } from \"../modules/maple-proxy-factory/contracts/MapleProxied.sol\";\n\nimport { ILenderLike } from \"./interfaces/Interfaces.sol\";\n\n/// @title MapleLoanInternals defines the storage layout and internal logic of MapleLoan.\ncontract MapleLoanInternals is MapleProxied {\n\n    uint256 private constant SCALED_ONE = uint256(10 ** 18);\n\n    // Roles\n    address internal _borrower;         // The address of the borrower.\n    address internal _lender;           // The address of the lender.\n    address internal _pendingBorrower;  // The address of the pendingBorrower, the only address that can accept the borrower role.\n    address internal _pendingLender;    // The address of the pendingLender, the only address that can accept the lender role.\n\n    // Assets\n    address internal _collateralAsset;  // The address of the asset used as collateral.\n    address internal _fundsAsset;       // The address of the asset used as funds.\n\n    // Loan Term Parameters\n    uint256 internal _gracePeriod;      // The number of seconds a payment can be late.\n    uint256 internal _paymentInterval;  // The number of seconds between payments.\n\n    // Rates\n    uint256 internal _interestRate;         // The annualized interest rate of the loan.\n    uint256 internal _earlyFeeRate;         // The fee rate for prematurely closing loans.\n    uint256 internal _lateFeeRate;          // The fee rate for late payments.\n    uint256 internal _lateInterestPremium;  // The amount to increase the interest rate by for late payments.\n\n    // Requested Amounts\n    uint256 internal _collateralRequired;  // The collateral the borrower is expected to put up to draw down all _principalRequested.\n    uint256 internal _principalRequested;  // The funds the borrowers wants to borrow.\n    uint256 internal _endingPrincipal;     // The principal to remain at end of loan.\n\n    // State\n    uint256 internal _drawableFunds;       // The amount of funds that can be drawn down.\n    uint256 internal _claimableFunds;      // The amount of funds that the lender can claim (principal repayments, interest, etc).\n    uint256 internal _collateral;          // The amount of collateral, in collateral asset, that is currently posted.\n    uint256 internal _nextPaymentDueDate;  // The timestamp of due date of next payment.\n    uint256 internal _paymentsRemaining;   // The number of payments remaining.\n    uint256 internal _principal;           // The amount of principal yet to be paid down.\n\n    // Refinance\n    bytes32 internal _refinanceCommitment;\n\n    /**********************************/\n    /*** Internal General Functions ***/\n    /**********************************/\n\n    /// @dev Clears all state variables to end a loan, but keep borrower and lender withdrawal functionality intact.\n    function _clearLoanAccounting() internal {\n        _gracePeriod     = uint256(0);\n        _paymentInterval = uint256(0);\n\n        _interestRate        = uint256(0);\n        _earlyFeeRate        = uint256(0);\n        _lateFeeRate         = uint256(0);\n        _lateInterestPremium = uint256(0);\n\n        _endingPrincipal = uint256(0);\n\n        _nextPaymentDueDate = uint256(0);\n        _paymentsRemaining  = uint256(0);\n        _principal          = uint256(0);\n    }\n\n    /**\n     *  @dev   Initializes the loan.\n     *  @param borrower_   The address of the borrower.\n     *  @param assets_     Array of asset addresses.\n     *                         [0]: collateralAsset,\n     *                         [1]: fundsAsset.\n     *  @param termDetails_ Array of loan parameters:\n     *                         [0]: gracePeriod,\n     *                         [1]: paymentInterval,\n     *                         [2]: payments,\n     *  @param amounts_    Requested amounts:\n     *                         [0]: collateralRequired,\n     *                         [1]: principalRequested,\n     *                         [2]: endingPrincipal.\n     *  @param rates_      Fee parameters:\n     *                         [0]: interestRate,\n     *                         [1]: earlyFeeRate,\n     *                         [2]: lateFeeRate,\n     *                         [3]: lateInterestPremium.\n     */\n    function _initialize(\n        address borrower_,\n        address[2] memory assets_,\n        uint256[3] memory termDetails_,\n        uint256[3] memory amounts_,\n        uint256[4] memory rates_\n    )\n        internal\n    {\n        // Principal requested need to be non-zero (see `_getCollateralRequiredFor` math).\n        require(amounts_[1] > uint256(0), \"MLI:I:INVALID_PRINCIPAL\");\n\n        // Ending principal needs to be less than or equal to principal requested.\n        require(amounts_[2] <= amounts_[1], \"MLI:I:INVALID_ENDING_PRINCIPAL\");\n\n        _borrower = borrower_;\n\n        _collateralAsset = assets_[0];\n        _fundsAsset      = assets_[1];\n\n        _gracePeriod       = termDetails_[0];\n        _paymentInterval   = termDetails_[1];\n        _paymentsRemaining = termDetails_[2];\n\n        _collateralRequired = amounts_[0];\n        _principalRequested = amounts_[1];\n        _endingPrincipal    = amounts_[2];\n\n        _interestRate        = rates_[0];\n        _earlyFeeRate        = rates_[1];\n        _lateFeeRate         = rates_[2];\n        _lateInterestPremium = rates_[3];\n    }\n\n    /**************************************/\n    /*** Internal Borrow-side Functions ***/\n    /**************************************/\n\n    /// @dev Prematurely ends a loan by making all remaining payments.\n    function _closeLoan() internal returns (uint256 principal_, uint256 interest_) {\n        require(block.timestamp <= _nextPaymentDueDate, \"MLI:CL:PAYMENT_IS_LATE\");\n\n        ( principal_, interest_ ) = _getEarlyPaymentBreakdown();\n\n        uint256 totalPaid_ = principal_ + interest_;\n\n        // The drawable funds are increased by the extra funds in the contract, minus the total needed for payment.\n        _drawableFunds = _drawableFunds + _getUnaccountedAmount(_fundsAsset) - totalPaid_;\n\n        _claimableFunds += totalPaid_;\n\n        _clearLoanAccounting();\n    }\n\n    /// @dev Sends `amount_` of `_drawableFunds` to `destination_`.\n    function _drawdownFunds(uint256 amount_, address destination_) internal {\n        _drawableFunds -= amount_;\n\n        require(ERC20Helper.transfer(_fundsAsset, destination_, amount_), \"MLI:DF:TRANSFER_FAILED\");\n        require(_isCollateralMaintained(),                                \"MLI:DF:INSUFFICIENT_COLLATERAL\");\n    }\n\n    /// @dev Makes a payment to progress the loan closer to maturity.\n    function _makePayment() internal returns (uint256 principal_, uint256 interest_) {\n        ( principal_, interest_ ) = _getNextPaymentBreakdown();\n\n        uint256 totalPaid_ = principal_ + interest_;\n\n        // The drawable funds are increased by the extra funds in the contract, minus the total needed for payment.\n        // NOTE: This line will revert if not enough funds were added for the full payment amount.\n        _drawableFunds = (_drawableFunds + _getUnaccountedAmount(_fundsAsset)) - totalPaid_;\n\n        _claimableFunds += totalPaid_;\n\n        if (_paymentsRemaining == uint256(1)) {\n            _clearLoanAccounting();  // Assumes `_getNextPaymentBreakdown` returns a `principal_` that is `_principal`.\n        } else {\n            _nextPaymentDueDate += _paymentInterval;\n            _principal          -= principal_;\n            _paymentsRemaining--;\n        }\n    }\n\n    /// @dev Registers the delivery of an amount of collateral to be posted.\n    function _postCollateral() internal returns (uint256 collateralPosted_) {\n        _collateral += (collateralPosted_ = _getUnaccountedAmount(_collateralAsset));\n    }\n\n    /// @dev Sets refinance commitment given refinance operations.\n    function _proposeNewTerms(address refinancer_, bytes[] calldata calls_) internal returns (bytes32 proposedRefinanceCommitment_) {\n        // NOTE: There is no way to invalidate the `refinanceCommitment` (i.e. bytes32(0)) without explicitly setting it if `calls_.length` is 0.\n        return _refinanceCommitment =\n            calls_.length > uint256(0)\n                ? _getRefinanceCommitment(refinancer_, calls_)\n                : bytes32(0);\n    }\n\n    /// @dev Sends `amount_` of `_collateral` to `destination_`.\n    function _removeCollateral(uint256 amount_, address destination_) internal {\n        _collateral -= amount_;\n\n        require(ERC20Helper.transfer(_collateralAsset, destination_, amount_), \"MLI:RC:TRANSFER_FAILED\");\n        require(_isCollateralMaintained(),                                     \"MLI:RC:INSUFFICIENT_COLLATERAL\");\n    }\n\n    /// @dev Registers the delivery of an amount of funds to be returned as `_drawableFunds`.\n    function _returnFunds() internal returns (uint256 fundsReturned_) {\n        _drawableFunds += (fundsReturned_ = _getUnaccountedAmount(_fundsAsset));\n    }\n\n    /************************************/\n    /*** Internal Lend-side Functions ***/\n    /************************************/\n\n    /// @dev Processes refinance operations.\n    function _acceptNewTerms(address refinancer_, bytes[] calldata calls_) internal returns (bytes32 acceptedRefinanceCommitment_) {\n        // NOTE: A zero refinancer address and/or empty calls array will never (probabilistically) match a refinance commitment in storage.\n        require(_refinanceCommitment == (acceptedRefinanceCommitment_ = _getRefinanceCommitment(refinancer_, calls_)), \"MLI:ANT:COMMITMENT_MISMATCH\");\n\n        uint256 size;\n\n        assembly {\n            size := extcodesize(refinancer_)\n        }\n\n        require(size != uint256(0), \"MLI:ANT:INVALID_REFINANCER\");\n\n        // Clear refinance commitment to prevent implications of re-acceptance of another call to `_acceptNewTerms`.\n        _refinanceCommitment = bytes32(0);\n\n        uint256 callCount = calls_.length;\n\n        for (uint256 i; i < callCount; ++i) {\n            ( bool success, ) = refinancer_.delegatecall(calls_[i]);\n            require(success, \"MLI:ANT:FAILED\");\n        }\n\n        // Ensure that collateral is maintained after changes made.\n        require(_isCollateralMaintained(), \"MLI:ANT:INSUFFICIENT_COLLATERAL\");\n    }\n\n    /// @dev Sends `amount_` of `_claimableFunds` to `destination_`.\n    /// @dev If `amount_` is higher than `_claimableFunds` the transaction will underflow and revert.\n    function _claimFunds(uint256 amount_, address destination_) internal {\n        _claimableFunds -= amount_;\n\n        require(ERC20Helper.transfer(_fundsAsset, destination_, amount_), \"MLI:CF:TRANSFER_FAILED\");\n    }\n\n    /// @dev Fund the loan and kick off the repayment requirements.\n    function _fundLoan(address lender_) internal returns (uint256 fundsLent_) {\n        // Can only fund loan if there are payments remaining (as defined by the initialization) and no payment is due yet (as set by a funding).\n        require((_nextPaymentDueDate == uint256(0)) && (_paymentsRemaining != uint256(0)), \"MLI:FL:LOAN_ACTIVE\");\n\n        _lender             = lender_;\n        _nextPaymentDueDate = block.timestamp + _paymentInterval;\n\n        // Amount funded and principal are as requested.\n        fundsLent_ = _principal = _principalRequested;\n\n        // Cannot under-fund loan, but over-funding results in additional funds left unaccounted for.\n        require(_getUnaccountedAmount(_fundsAsset) >= fundsLent_, \"MLI:FL:WRONG_FUND_AMOUNT\");\n\n        // Transfer the annualized treasury fee, if any, to the Maple treasury, and decrement drawable funds.\n        uint256 treasuryFee = (fundsLent_ * ILenderLike(lender_).treasuryFee() * _paymentInterval * _paymentsRemaining) / uint256(365 days * 10_000);\n\n        // Transfer delegate fee, if any, to the pool delegate, and decrement drawable funds.\n        uint256 delegateFee = (fundsLent_ * ILenderLike(lender_).investorFee() * _paymentInterval * _paymentsRemaining) / uint256(365 days * 10_000);\n\n        // Drawable funds is the amount funded, minus any fees.\n        _drawableFunds = fundsLent_ - treasuryFee - delegateFee;\n\n        require(\n            treasuryFee == uint256(0) || ERC20Helper.transfer(_fundsAsset, ILenderLike(lender_).mapleTreasury(), treasuryFee),\n            \"MLI:FL:T_TRANSFER_FAILED\"\n        );\n\n        require(\n            delegateFee == uint256(0) || ERC20Helper.transfer(_fundsAsset, ILenderLike(lender_).poolDelegate(), delegateFee),\n            \"MLI:FL:PD_TRANSFER_FAILED\"\n        );\n    }\n\n    /// @dev Reset all state variables in order to release funds and collateral of a loan in default.\n    function _repossess(address destination_) internal returns (uint256 collateralRepossessed_, uint256 fundsRepossessed_) {\n        uint256 nextPaymentDueDate = _nextPaymentDueDate;\n\n        require(\n            nextPaymentDueDate != uint256(0) && (block.timestamp > nextPaymentDueDate + _gracePeriod),\n            \"MLI:R:NOT_IN_DEFAULT\"\n        );\n\n        _clearLoanAccounting();\n\n        // Uniquely in `_repossess`, stop accounting for all funds so that they can be swept.\n        _collateral     = uint256(0);\n        _claimableFunds = uint256(0);\n        _drawableFunds  = uint256(0);\n\n        // Either there is no collateral to repossess, or the transfer of the collateral succeeds.\n        require(\n            (collateralRepossessed_ = _getUnaccountedAmount(_collateralAsset)) == uint256(0) ||\n            ERC20Helper.transfer(_collateralAsset, destination_, collateralRepossessed_),\n            \"MLI:R:C_TRANSFER_FAILED\"\n        );\n\n        // Either there are no funds to repossess, or the transfer of the funds succeeds.\n        require(\n            (fundsRepossessed_ = _getUnaccountedAmount(_fundsAsset)) == uint256(0) ||\n            ERC20Helper.transfer(_fundsAsset, destination_, fundsRepossessed_),\n            \"MLI:R:F_TRANSFER_FAILED\"\n        );\n    }\n\n    /*******************************/\n    /*** Internal View Functions ***/\n    /*******************************/\n\n    /// @dev Returns whether the amount of collateral posted is commensurate with the amount of drawn down (outstanding) principal.\n    function _isCollateralMaintained() internal view returns (bool isMaintained_) {\n        return _collateral >= _getCollateralRequiredFor(_principal, _drawableFunds, _principalRequested, _collateralRequired);\n    }\n\n    /// @dev Get principal and interest breakdown for paying off the entire loan early.\n    function _getEarlyPaymentBreakdown() internal view returns (uint256 principal_, uint256 interest_) {\n        principal_ = _principal;\n        interest_  = (_principal * _earlyFeeRate) / SCALED_ONE;\n    }\n\n    /// @dev Get principal and interest breakdown for next standard payment.\n    function _getNextPaymentBreakdown() internal view returns (uint256 principal_, uint256 interest_) {\n        ( principal_, interest_ ) = _getPaymentBreakdown(\n            block.timestamp,\n            _nextPaymentDueDate,\n            _paymentInterval,\n            _principal,\n            _endingPrincipal,\n            _paymentsRemaining,\n            _interestRate,\n            _lateFeeRate,\n            _lateInterestPremium\n        );\n    }\n\n    /// @dev Returns the amount of an `asset_` that this contract owns, which is not currently accounted for by its state variables.\n    function _getUnaccountedAmount(address asset_) internal view virtual returns (uint256 unaccountedAmount_) {\n        return IERC20(asset_).balanceOf(address(this))\n            - (asset_ == _collateralAsset ? _collateral : uint256(0))                   // `_collateral` is `_collateralAsset` accounted for.\n            - (asset_ == _fundsAsset ? _claimableFunds + _drawableFunds : uint256(0));  // `_claimableFunds` and `_drawableFunds` are `_fundsAsset` accounted for.\n    }\n\n    /*******************************/\n    /*** Internal Pure Functions ***/\n    /*******************************/\n\n    /// @dev Returns the total collateral to be posted for some drawn down (outstanding) principal and overall collateral ratio requirement.\n    function _getCollateralRequiredFor(\n        uint256 principal_,\n        uint256 drawableFunds_,\n        uint256 principalRequested_,\n        uint256 collateralRequired_\n    )\n        internal pure returns (uint256 collateral_)\n    {\n        // Where (collateral / outstandingPrincipal) should be greater or equal to (collateralRequired / principalRequested).\n        // NOTE: principalRequested_ cannot be 0, which is reasonable, since it means this was never a loan.\n        return (collateralRequired_ * (principal_ > drawableFunds_ ? principal_ - drawableFunds_ : uint256(0))) / principalRequested_;\n    }\n\n    /// @dev Returns principal and interest portions of a payment instalment, given generic, stateless loan parameters.\n    function _getInstallment(uint256 principal_, uint256 endingPrincipal_, uint256 interestRate_, uint256 paymentInterval_, uint256 totalPayments_)\n        internal pure virtual returns (uint256 principalAmount_, uint256 interestAmount_)\n    {\n        /*************************************************************************************************\\\n         *                             |                                                                 *\n         * A = installment amount      |      /                         \\     /           R           \\  *\n         * P = principal remaining     |     |  /                 \\      |   | ----------------------- | *\n         * R = interest rate           | A = | | P * ( 1 + R ) ^ N | - E | * |   /             \\       | *\n         * N = payments remaining      |     |  \\                 /      |   |  | ( 1 + R ) ^ N | - 1  | *\n         * E = ending principal target |      \\                         /     \\  \\             /      /  *\n         *                             |                                                                 *\n         *                             |---------------------------------------------------------------- *\n         *                                                                                               *\n         * - Where R           is `periodicRate`                                                         *\n         * - Where (1 + R) ^ N is `raisedRate`                                                           *\n         * - Both of these rates are scaled by 1e18 (e.g., 12% => 0.12 * 10 ** 18)                       *\n        \\*************************************************************************************************/\n\n        uint256 periodicRate = _getPeriodicInterestRate(interestRate_, paymentInterval_);\n        uint256 raisedRate   = _scaledExponent(SCALED_ONE + periodicRate, totalPayments_, SCALED_ONE);\n\n        // NOTE: If a lack of precision in `_scaledExponent` results in a `raisedRate` smaller than one, assume it to be one and simplify the equation.\n        if (raisedRate <= SCALED_ONE) return ((principal_ - endingPrincipal_) / totalPayments_, uint256(0));\n\n        uint256 total = ((((principal_ * raisedRate) / SCALED_ONE) - endingPrincipal_) * periodicRate) / (raisedRate - SCALED_ONE);\n\n        interestAmount_  = _getInterest(principal_, interestRate_, paymentInterval_);\n        principalAmount_ = total >= interestAmount_ ? total - interestAmount_ : uint256(0);\n    }\n\n    /// @dev Returns an amount by applying an annualized and scaled interest rate, to a principal, over an interval of time.\n    function _getInterest(uint256 principal_, uint256 interestRate_, uint256 interval_) internal pure virtual returns (uint256 interest_) {\n        return (principal_ * _getPeriodicInterestRate(interestRate_, interval_)) / SCALED_ONE;\n    }\n\n    /// @dev Returns total principal and interest portion of a number of payments, given generic, stateless loan parameters and loan state.\n    function _getPaymentBreakdown(\n        uint256 currentTime_,\n        uint256 nextPaymentDueDate_,\n        uint256 paymentInterval_,\n        uint256 principal_,\n        uint256 endingPrincipal_,\n        uint256 paymentsRemaining_,\n        uint256 interestRate_,\n        uint256 lateFeeRate_,\n        uint256 lateInterestPremium_\n    )\n        internal pure virtual\n        returns (uint256 principalAmount_, uint256 interestAmount_)\n    {\n        ( principalAmount_,interestAmount_ ) = _getInstallment(\n            principal_,\n            endingPrincipal_,\n            interestRate_,\n            paymentInterval_,\n            paymentsRemaining_\n        );\n\n        principalAmount_ = paymentsRemaining_ == uint256(1) ? principal_ : principalAmount_;\n\n        if (currentTime_ > nextPaymentDueDate_) {\n            interestAmount_ += _getInterest(principal_, interestRate_ + lateInterestPremium_, currentTime_ - nextPaymentDueDate_);\n            interestAmount_ += (lateFeeRate_ * principal_) / SCALED_ONE;\n        }\n    }\n\n    /// @dev Returns the interest rate over an interval, given an annualized interest rate.\n    function _getPeriodicInterestRate(uint256 interestRate_, uint256 interval_) internal pure virtual returns (uint256 periodicInterestRate_) {\n        return (interestRate_ * interval_) / uint256(365 days);\n    }\n\n    /// @dev Returns refinance commitment given refinance parameters.\n    function _getRefinanceCommitment(address refinancer_, bytes[] calldata calls_) internal pure returns (bytes32 refinanceCommitment_) {\n        return keccak256(abi.encode(refinancer_, calls_));\n    }\n\n    /**\n     *  @dev Returns exponentiation of a scaled base value.\n     *\n     *       Walk through example:\n     *       LINE  |  base_          |  exponent_  |  one_  |  result_\n     *             |  3_00           |  18         |  1_00  |  0_00\n     *        A    |  3_00           |  18         |  1_00  |  1_00\n     *        B    |  3_00           |  9          |  1_00  |  1_00\n     *        C    |  9_00           |  9          |  1_00  |  1_00\n     *        D    |  9_00           |  9          |  1_00  |  9_00\n     *        B    |  9_00           |  4          |  1_00  |  9_00\n     *        C    |  81_00          |  4          |  1_00  |  9_00\n     *        B    |  81_00          |  2          |  1_00  |  9_00\n     *        C    |  6_561_00       |  2          |  1_00  |  9_00\n     *        B    |  6_561_00       |  1          |  1_00  |  9_00\n     *        C    |  43_046_721_00  |  1          |  1_00  |  9_00\n     *        D    |  43_046_721_00  |  1          |  1_00  |  387_420_489_00\n     *        B    |  43_046_721_00  |  0          |  1_00  |  387_420_489_00\n     *\n     * Another implementation of this algorithm can be found in Dapphub's DSMath contract:\n     * https://github.com/dapphub/ds-math/blob/ce67c0fa9f8262ecd3d76b9e4c026cda6045e96c/src/math.sol#L77\n     */\n    function _scaledExponent(uint256 base_, uint256 exponent_, uint256 one_) internal pure returns (uint256 result_) {\n        // If exponent_ is odd, set result_ to base_, else set to one_.\n        result_ = exponent_ & uint256(1) != uint256(0) ? base_ : one_;          // A\n\n        // Divide exponent_ by 2 (overwriting itself) and proceed if not zero.\n        while ((exponent_ >>= uint256(1)) != uint256(0)) {                      // B\n            base_ = (base_ * base_) / one_;                                     // C\n\n            // If exponent_ is even, go back to top.\n            if (exponent_ & uint256(1) == uint256(0)) continue;\n\n            // If exponent_ is odd, multiply result_ is multiplied by base_.\n            result_ = (result_ * base_) / one_;                                 // D\n        }\n    }\n\n}"
    }
  ]
}