{
  "Title": "Unnecessary type casts of proxied storage slots from `bytes32` to `uint256`",
  "Content": "There are multiple instances where proxied storage slots are cast from type `bytes32` to `uint256`; however, this is not necessary as the EVM uses 32-byte words, meaning that these types are interchangeable when considering the subsequent inline assembly assignment. One example can be found in [`Governance::_getConsumedGovernanceActionsStorage`](https://github.com/wormhole-foundation/example-native-token-transfers/blob/f4e2277b358349dbfb8a654d19a925628d48a8af/evm/src/wormhole/Governance.sol#L34-L43):\n\n```solidity\nfunction _getConsumedGovernanceActionsStorage()\n    private\n    pure\n    returns (mapping(bytes32 => bool) storage $)\n{\n    uint256 slot = uint256(CONSUMED_GOVERNANCE_ACTIONS_SLOT);\n    assembly (\"memory-safe\") {\n        $.slot := slot\n    }\n}\n```\n\nConsider [removing this type cast](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/789ba4f167cc94088e305d78e4ae6f3c1ec2e6f1/contracts/utils/PausableUpgradeable.sol#L25-L31) to save gas.\n\n**Wormhole Foundation:** To do this we could have to precompute the constants since this otherwise leads to a compiler error.\n\n**Cyfrin:** Acknowledged.",
  "Impact": "GAS",
  "Source": "",
  "Code": [
    {
      "filename": "evm/src/wormhole/Governance.sol",
      "content": "// SPDX-License-Identifier: Apache 2\npragma solidity >=0.8.8 <0.9.0;\n\nimport \"wormhole-solidity-sdk/interfaces/IWormhole.sol\";\nimport \"wormhole-solidity-sdk/libraries/BytesParsing.sol\";\n\ncontract Governance {\n    using BytesParsing for bytes;\n\n    // \"GeneralPurposeGovernance\" (left padded)\n    bytes32 public constant MODULE =\n        0x000000000000000047656E6572616C507572706F7365476F7665726E616E6365;\n\n    enum GovernanceAction {\n        UNDEFINED,\n        EVM_CALL\n    }\n\n    IWormhole immutable wormhole;\n\n    error PayloadTooLong(uint256 size);\n    error InvalidModule(bytes32 module);\n    error InvalidAction(uint8 action);\n    error InvalidGovernanceChainId(uint16 chainId);\n    error InvalidGovernanceContract(bytes32 contractAddress);\n    error GovernanceActionAlreadyConsumed(bytes32 digest);\n\n    error NotRecipientChain(uint16 chainId);\n    error NotRecipientContract(address contractAddress);\n\n    bytes32 constant CONSUMED_GOVERNANCE_ACTIONS_SLOT =\n        bytes32(uint256(keccak256(\"governance.consumedGovernanceActions\")) - 1);\n\n    function _getConsumedGovernanceActionsStorage()\n        private\n        pure\n        returns (mapping(bytes32 => bool) storage $)\n    {\n        uint256 slot = uint256(CONSUMED_GOVERNANCE_ACTIONS_SLOT);\n        assembly (\"memory-safe\") {\n            $.slot := slot\n        }\n    }\n\n    /*\n    * @dev General purpose governance message to call arbitrary methods on a governed smart contract.\n    *      This message adheres to the Wormhole governance packet standard: https://github.com/wormhole-foundation/wormhole/blob/main/whitepapers/0002_governance_messaging.md\n    *      The wire format for this message is:\n    *      - MODULE - 32 bytes\n    *      - action - 1 byte\n    *      - chain - 2 bytes\n    *      - governanceContract - 20 bytes\n    *      - governedContract - 20 bytes\n    *      - callDataLength - 2 bytes\n    *      - callData - `callDataLength` bytes\n    */\n    struct GeneralPurposeGovernanceMessage {\n        uint8 action;\n        uint16 chain;\n        address governanceContract;\n        address governedContract;\n        bytes callData;\n    }\n\n    constructor(address _wormhole) {\n        wormhole = IWormhole(_wormhole);\n    }\n\n    function performGovernance(bytes calldata vaa) external {\n        IWormhole.VM memory verified = _verifyGovernanceVAA(vaa);\n        GeneralPurposeGovernanceMessage memory message =\n            parseGeneralPurposeGovernanceMessage(verified.payload);\n\n        if (message.action != uint8(GovernanceAction.EVM_CALL)) {\n            revert InvalidAction(message.action);\n        }\n\n        if (message.chain != wormhole.chainId()) {\n            revert NotRecipientChain(message.chain);\n        }\n\n        if (message.governanceContract != address(this)) {\n            revert NotRecipientContract(message.governanceContract);\n        }\n\n        // TODO: any other checks? the call is trusted (signed by guardians),\n        // but what's the worst that could happen to this contract?\n        (bool success, bytes memory returnData) = message.governedContract.call(message.callData);\n        if (!success) {\n            revert(string(returnData));\n        }\n    }\n\n    function _replayProtect(bytes32 digest) internal {\n        mapping(bytes32 => bool) storage $ = _getConsumedGovernanceActionsStorage();\n        if ($[digest]) {\n            revert GovernanceActionAlreadyConsumed(digest);\n        }\n        $[digest] = true;\n    }\n\n    function _verifyGovernanceVAA(bytes memory encodedVM)\n        internal\n        returns (IWormhole.VM memory parsedVM)\n    {\n        (IWormhole.VM memory vm, bool valid, string memory reason) =\n            wormhole.parseAndVerifyVM(encodedVM);\n\n        if (!valid) {\n            revert(reason);\n        }\n\n        if (vm.emitterChainId != wormhole.governanceChainId()) {\n            revert InvalidGovernanceChainId(vm.emitterChainId);\n        }\n\n        if (vm.emitterAddress != wormhole.governanceContract()) {\n            revert InvalidGovernanceContract(vm.emitterAddress);\n        }\n\n        _replayProtect(vm.hash);\n\n        return vm;\n    }\n\n    function encodeGeneralPurposeGovernanceMessage(GeneralPurposeGovernanceMessage memory m)\n        public\n        pure\n        returns (bytes memory encoded)\n    {\n        if (m.callData.length > type(uint16).max) {\n            revert PayloadTooLong(m.callData.length);\n        }\n        uint16 callDataLength = uint16(m.callData.length);\n        return abi.encodePacked(\n            MODULE,\n            m.action,\n            m.chain,\n            m.governanceContract,\n            m.governedContract,\n            callDataLength,\n            m.callData\n        );\n    }\n\n    function parseGeneralPurposeGovernanceMessage(bytes memory encoded)\n        public\n        pure\n        returns (GeneralPurposeGovernanceMessage memory message)\n    {\n        uint256 offset = 0;\n\n        bytes32 module;\n        (module, offset) = encoded.asBytes32Unchecked(offset);\n        if (module != MODULE) {\n            revert InvalidModule(module);\n        }\n\n        (message.action, offset) = encoded.asUint8Unchecked(offset);\n        (message.chain, offset) = encoded.asUint16Unchecked(offset);\n        (message.governanceContract, offset) = encoded.asAddressUnchecked(offset);\n        (message.governedContract, offset) = encoded.asAddressUnchecked(offset);\n        uint256 callDataLength;\n        (callDataLength, offset) = encoded.asUint16Unchecked(offset);\n        (message.callData, offset) = encoded.sliceUnchecked(offset, callDataLength);\n        encoded.checkLength(offset);\n    }\n}"
    },
    {
      "filename": "contracts/utils/PausableUpgradeable.sol",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.Pausable\n    struct PausableStorage {\n        bool _paused;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Pausable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant PausableStorageLocation = 0xcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300;\n\n    function _getPausableStorage() private pure returns (PausableStorage storage $) {\n        assembly {\n            $.slot := PausableStorageLocation\n        }\n    }\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        PausableStorage storage $ = _getPausableStorage();\n        return $._paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n        emit Unpaused(_msgSender());\n    }\n}"
    }
  ]
}