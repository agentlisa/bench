{
  "Title": "[G-05]  Calldata instead of memory for RO function parameters",
  "Content": "\nIf a reference type function parameter is read-only, it is cheaper in gas to use calldata instead of memory.\n\nCalldata is a non-modifiable, non-persistent area where function arguments are stored, and behaves mostly like memory,but it alleviates the compiler from the `abi.decode()` step that copies each index of the calldata to the memory index, each iteration costing `60` gas.\n\n### Proof of Concept\n\n20 instances:\n\n##### src/FERC1155.sol\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L68>\n\n```cpp\n68:     function emitSetURI(uint256 _id, string memory _uri) \n```\n\n##### src/Vault.sol\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L73>\n\n```cpp\n73:     function install(bytes4[] memory _selectors, address[] memory _plugins)\n```\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L101>\n\n```cpp\n101:     function uninstall(bytes4[] memory _selectors)\n```\n\n##### src/VaultRegistry.sol\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultRegistry.sol#L53>\n\n```cpp\n53:         address[] memory _plugins\n54:         bytes4[] memory _selectors\n```\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultRegistry.sol#L70>\n\n```cpp\n70:         address[] memory _plugins\n71:         bytes4[] memory _selectors\n```\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultRegistry.sol#L85>\n\n```cpp\n85:         address[] memory _plugins\n86:         bytes4[] memory _selectors\n```\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultRegistry.sol#L105>\n\n```cpp\n105:         address[] memory _plugins\n106:         bytes4[] memory _selectors\n```\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultRegistry.sol#L150>\n\n```cpp\n150:         address[] memory _plugins\n151:         bytes4[] memory _selectors\n```\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultRegistry.sol#L168>\n\n```cpp\n168:         address[] memory _plugins\n169:         bytes4[] memory _selectors\n```\n\n##### src/modules/Migration.sol\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L487>\n\n```cpp\n487:     function generateMerkleTree(address[] memory _modules)\n```\n\n##### src/utils/MerkleBase.sol\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L44>\n\n```cpp\n44:     function verifyProof(bytes32[] memory _proof)\n```\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/MerkleBase.sol#L125>\n\n```cpp\n125:     function hashLevel(bytes32[] memory _data)\n```\n\n##### src/utils/Metadata.sol\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/utils/Metadata.sol#L24>\n\n```cpp\n24:     function setURI(uint256 _id, string memory _uri) \n```\n\n### Recommended Mitigation Steps\n\nReplace `memory` with `calldata`.\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-07-fractional-v2-contest",
  "Code": [
    {
      "filename": "src/FERC1155.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {Clone} from \"clones-with-immutable-args/src/Clone.sol\";\nimport {ERC1155} from \"@rari-capital/solmate/src/tokens/ERC1155.sol\";\nimport {IFERC1155} from \"./interfaces/IFERC1155.sol\";\nimport {INFTReceiver} from \"./interfaces/INFTReceiver.sol\";\nimport \"./constants/Permit.sol\";\n\n/// @title FERC1155\n/// @author Fractional Art\n/// @notice An ERC-1155 implementation for Fractions\ncontract FERC1155 is Clone, ERC1155, IFERC1155 {\n    /// @notice Name of the token contract\n    string public constant NAME = \"FERC1155\";\n    /// @notice Version number of the token contract\n    string public constant VERSION = \"1\";\n    /// @notice Address that can deploy new vaults for this collection, manage metadata, etc\n    address internal _controller;\n    /// @notice URI of contract metadata\n    string public contractURI;\n    /// @notice Mapping of token type approvals owner => operator => tokenId => approved\n    mapping(address => mapping(address => mapping(uint256 => bool)))\n        public isApproved;\n    /// @notice Mapping of metadata contracts for token ID types => metadata address\n    mapping(uint256 => address) public metadata;\n    /// @notice Mapping to track account nonces for metadata txs owner => nonces\n    mapping(address => uint256) public nonces;\n    /// @notice Mapping to track total supply for token ID types => totalSupply\n    mapping(uint256 => uint256) public totalSupply;\n    /// @notice Mapping to track royalty receivers for token ID types => royaltyAddress\n    mapping(uint256 => address) private royaltyAddress;\n    /// @notice Mapping to track the royalty percent for token ID types => royaltyPercent\n    mapping(uint256 => uint256) private royaltyPercent;\n\n    /// @notice Modifier for restricting function calls to the controller account\n    modifier onlyController() {\n        address controller_ = controller();\n        if (msg.sender != controller_)\n            revert InvalidSender(controller_, msg.sender);\n        _;\n    }\n\n    /// @notice Modifier for restricting function calls to the VaultRegistry\n    modifier onlyRegistry() {\n        address vaultRegistry = VAULT_REGISTRY();\n        if (msg.sender != vaultRegistry)\n            revert InvalidSender(vaultRegistry, msg.sender);\n        _;\n    }\n\n    /// @notice Burns fractions for an ID\n    /// @param _from Address to burn fraction tokens from\n    /// @param _id Token ID to burn\n    /// @param _amount Number of tokens to burn\n    function burn(\n        address _from,\n        uint256 _id,\n        uint256 _amount\n    ) external onlyRegistry {\n        _burn(_from, _id, _amount);\n        totalSupply[_id] -= _amount;\n    }\n\n    /// @notice Hook to emit the URI update when setting the metadata or updating\n    /// @param _id Token ID metadata was updated for\n    /// @param _uri URI of metadata\n    function emitSetURI(uint256 _id, string memory _uri) external {\n        if (msg.sender != metadata[_id])\n            revert InvalidSender(metadata[_id], msg.sender);\n        emit URI(_uri, _id);\n    }\n\n    /// @notice Mints new fractions for an ID\n    /// @param _to Address to mint fraction tokens to\n    /// @param _id Token ID to mint\n    /// @param _amount Number of tokens to mint\n    /// @param _data Extra calldata to include in the mint\n    function mint(\n        address _to,\n        uint256 _id,\n        uint256 _amount,\n        bytes memory _data\n    ) external onlyRegistry {\n        _mint(_to, _id, _amount, _data);\n        totalSupply[_id] += _amount;\n    }\n\n    /// @notice Permit function that approves an operator for token type with a valid signature\n    /// @param _owner Address of the owner of the token type\n    /// @param _operator Address of the spender of the token type\n    /// @param _id ID of the token type\n    /// @param _approved Approval status for the token type\n    /// @param _deadline Expiration of the signature\n    /// @param _v The recovery ID (129th byte and chain ID) of the signature used to recover the signer\n    /// @param _r The first 64 bytes of the signature\n    /// @param _s Bytes 64-128 of the signature\n    function permit(\n        address _owner,\n        address _operator,\n        uint256 _id,\n        bool _approved,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external {\n        if (block.timestamp > _deadline)\n            revert SignatureExpired(block.timestamp, _deadline);\n\n        // cannot realistically overflow on human timescales\n        unchecked {\n            bytes32 structHash = _computePermitStructHash(\n                _owner,\n                _operator,\n                _id,\n                _approved,\n                _deadline\n            );\n\n            bytes32 digest = _computeDigest(\n                _computeDomainSeparator(),\n                structHash\n            );\n\n            address signer = ecrecover(digest, _v, _r, _s);\n\n            if (signer == address(0) || signer != _owner)\n                revert InvalidSignature(signer, _owner);\n        }\n\n        isApproved[_owner][_operator][_id] = _approved;\n\n        emit SingleApproval(_owner, _operator, _id, _approved);\n    }\n\n    /// @notice Permit function that approves an operator for all token types with a valid signature\n    /// @param _owner Address of the owner of the token type\n    /// @param _operator Address of the spender of the token type\n    /// @param _approved Approval status for the token type\n    /// @param _deadline Expiration of the signature\n    /// @param _v The recovery ID (129th byte and chain ID) of the signature used to recover the signer\n    /// @param _r The first 64 bytes of the signature\n    /// @param _s Bytes 64-128 of the signature\n    function permitAll(\n        address _owner,\n        address _operator,\n        bool _approved,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external {\n        if (block.timestamp > _deadline)\n            revert SignatureExpired(block.timestamp, _deadline);\n\n        // cannot realistically overflow on human timescales\n        unchecked {\n            bytes32 structHash = _computePermitAllStructHash(\n                _owner,\n                _operator,\n                _approved,\n                _deadline\n            );\n\n            bytes32 digest = _computeDigest(\n                _computeDomainSeparator(),\n                structHash\n            );\n\n            address signer = ecrecover(digest, _v, _r, _s);\n\n            if (signer == address(0) || signer != _owner)\n                revert InvalidSignature(signer, _owner);\n        }\n\n        isApprovedForAll[_owner][_operator] = _approved;\n\n        emit ApprovalForAll(_owner, _operator, _approved);\n    }\n\n    /// @notice Scoped approvals allow us to eliminate some of the risks associated with setting the approval for an entire collection\n    /// @param _operator Address of spender account\n    /// @param _id ID of the token type\n    /// @param _approved Approval status for operator(spender) account\n    function setApprovalFor(\n        address _operator,\n        uint256 _id,\n        bool _approved\n    ) external {\n        isApproved[msg.sender][_operator][_id] = _approved;\n\n        emit SingleApproval(msg.sender, _operator, _id, _approved);\n    }\n\n    /// @notice Sets the contract metadata\n    /// @param _uri URI of metadata\n    function setContractURI(string calldata _uri) external onlyController {\n        contractURI = _uri;\n    }\n\n    /// @notice Sets the token metadata contract\n    /// @param _metadata Address for metadata contract\n    /// @param _id Token ID to set the metadata for\n    function setMetadata(address _metadata, uint256 _id)\n        external\n        onlyController\n    {\n        metadata[_id] = _metadata;\n        emit SetMetadata(_metadata, _id);\n    }\n\n    /// @notice Sets the token royalties\n    /// @param _id Token ID royalties are being updated for\n    /// @param _receiver Address to receive royalties\n    /// @param _percentage Percentage of royalties on secondary sales\n    function setRoyalties(\n        uint256 _id,\n        address _receiver,\n        uint256 _percentage\n    ) external onlyController {\n        royaltyAddress[_id] = _receiver;\n        royaltyPercent[_id] = _percentage;\n        emit SetRoyalty(_receiver, _id, _percentage);\n    }\n\n    /// @notice Updates the controller address for the FERC1155 token contract\n    /// @param _newController Address of new controlling entity\n    function transferController(address _newController)\n        external\n        onlyController\n    {\n        if (_newController == address(0)) revert ZeroAddress();\n        _controller = _newController;\n        emit ControllerTransferred(_newController);\n    }\n\n    /// @notice Sets the token royalties\n    /// @param _id Token ID royalties are being updated for\n    /// @param _salePrice Sale price to calculate the royalty for\n    function royaltyInfo(uint256 _id, uint256 _salePrice)\n        external\n        view\n        returns (address receiver, uint256 royaltyAmount)\n    {\n        receiver = royaltyAddress[_id];\n        royaltyAmount = (_salePrice * royaltyPercent[_id]) / 100;\n    }\n\n    /// @notice Transfer an amount of a token type between two accounts\n    /// @param _from Source address for an amount of tokens\n    /// @param _to Destination address for an amount of tokens\n    /// @param _id ID of the token type\n    /// @param _amount The amount of tokens being transferred\n    /// @param _data Additional calldata\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _id,\n        uint256 _amount,\n        bytes memory _data\n    ) public override(ERC1155, IFERC1155) {\n        require(\n            msg.sender == _from ||\n                isApprovedForAll[_from][msg.sender] ||\n                isApproved[_from][msg.sender][_id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        balanceOf[_from][_id] -= _amount;\n        balanceOf[_to][_id] += _amount;\n\n        emit TransferSingle(msg.sender, _from, _to, _id, _amount);\n\n        require(\n            _to.code.length == 0\n                ? _to != address(0)\n                : INFTReceiver(_to).onERC1155Received(\n                    msg.sender,\n                    _from,\n                    _id,\n                    _amount,\n                    _data\n                ) == INFTReceiver.onERC1155Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /// @notice Getter for URI of a token type\n    /// @param _id ID of the token type\n    function uri(uint256 _id)\n        public\n        view\n        override(ERC1155, IFERC1155)\n        returns (string memory)\n    {\n        require(metadata[_id] != address(0), \"NO METADATA\");\n        return IFERC1155(metadata[_id]).uri(_id);\n    }\n\n    /// @notice Getter for controller account\n    function controller() public view returns (address controllerAddress) {\n        _controller == address(0)\n            ? controllerAddress = INITIAL_CONTROLLER()\n            : controllerAddress = _controller;\n    }\n\n    /// @notice Getter for initial controller account immutable argument stored in calldata\n    function INITIAL_CONTROLLER() public pure returns (address) {\n        return _getArgAddress(0);\n    }\n\n    /// @notice VaultRegistry address that is allowed to call mint() and burn()\n    function VAULT_REGISTRY() public pure returns (address) {\n        return _getArgAddress(20);\n    }\n\n    /// @dev Computes hash of permit struct\n    /// @param _owner Address of the owner of the token type\n    /// @param _operator Address of the spender of the token type\n    /// @param _id ID of the token type\n    /// @param _approved Approval status for the token type\n    /// @param _deadline Expiration of the signature\n    function _computePermitStructHash(\n        address _owner,\n        address _operator,\n        uint256 _id,\n        bool _approved,\n        uint256 _deadline\n    ) internal returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    PERMIT_TYPEHASH,\n                    _owner,\n                    _operator,\n                    _id,\n                    _approved,\n                    nonces[_owner]++,\n                    _deadline\n                )\n            );\n    }\n\n    /// @dev Computes hash of permit all struct\n    /// @param _owner Address of the owner of the token type\n    /// @param _operator Address of the spender of the token type\n    /// @param _approved Approval status for the token type\n    /// @param _deadline Expiration of the signature\n    function _computePermitAllStructHash(\n        address _owner,\n        address _operator,\n        bool _approved,\n        uint256 _deadline\n    ) internal returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    PERMIT_ALL_TYPEHASH,\n                    _owner,\n                    _operator,\n                    _approved,\n                    nonces[_owner]++,\n                    _deadline\n                )\n            );\n    }\n\n    /// @dev Computes domain separator to prevent signature collisions\n    /// @return Hash of the contract-specific fields\n    function _computeDomainSeparator() internal view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    DOMAIN_TYPEHASH,\n                    keccak256(bytes(NAME)),\n                    keccak256(bytes(VERSION)),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /// @dev Computes digest of domain separator and struct hash\n    /// @param _domainSeparator Hash of contract-specific fields\n    /// @param _structHash Hash of signature fields struct\n    /// @return Hash of the signature digest\n    function _computeDigest(bytes32 _domainSeparator, bytes32 _structHash)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encodePacked(\"\\x19\\x01\", _domainSeparator, _structHash)\n            );\n    }\n}"
    },
    {
      "filename": "src/Vault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IVault} from \"./interfaces/IVault.sol\";\nimport {MerkleProof} from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport {NFTReceiver} from \"./utils/NFTReceiver.sol\";\n\n/// @title Vault\n/// @author Fractional Art\n/// @notice Proxy contract for storing fractionalized assets\ncontract Vault is IVault, NFTReceiver {\n    /// @notice Address of vault owner\n    address public owner;\n    /// @notice Merkle root hash of vault permissions\n    bytes32 public merkleRoot;\n    /// @notice Initializer value\n    uint256 public nonce;\n    /// @dev Minimum reserve of gas units\n    uint256 private constant MIN_GAS_RESERVE = 5_000;\n    /// @notice Mapping of function selector to plugin address\n    mapping(bytes4 => address) public methods;\n\n    /// @dev Initializes nonce and proxy owner\n    function init() external {\n        if (nonce != 0) revert Initialized(owner, msg.sender, nonce);\n        nonce = 1;\n        owner = msg.sender;\n        emit TransferOwnership(address(0), msg.sender);\n    }\n\n    /// @dev Callback for receiving Ether when the calldata is empty\n    receive() external payable {}\n\n    /// @dev Callback for handling plugin transactions\n    /// @param _data Transaction data\n    /// @return response Return data from executing plugin\n    // prettier-ignore\n    fallback(bytes calldata _data) external payable returns (bytes memory response) {\n        address plugin = methods[msg.sig];\n        (,response) = _execute(plugin, _data);\n    }\n\n    /// @notice Executes vault transactions through delegatecall\n    /// @param _target Target address\n    /// @param _data Transaction data\n    /// @param _proof Merkle proof of permission hash\n    /// @return success Result status of delegatecall\n    /// @return response Return data of delegatecall\n    function execute(\n        address _target,\n        bytes calldata _data,\n        bytes32[] calldata _proof\n    ) external payable returns (bool success, bytes memory response) {\n        bytes4 selector;\n        assembly {\n            selector := calldataload(_data.offset)\n        }\n\n        // Generate leaf node by hashing module, target and function selector.\n        bytes32 leaf = keccak256(abi.encode(msg.sender, _target, selector));\n        // Check that the caller is either a module with permission to call or the owner.\n        if (!MerkleProof.verify(_proof, merkleRoot, leaf)) {\n            if (msg.sender != owner)\n                revert NotAuthorized(msg.sender, _target, selector);\n        }\n\n        (success, response) = _execute(_target, _data);\n    }\n\n    /// @notice Installs plugin by setting function selector to contract address\n    /// @param _selectors List of function selectors\n    /// @param _plugins Addresses of plugin contracts\n    function install(bytes4[] memory _selectors, address[] memory _plugins)\n        external\n    {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        uint256 length = _selectors.length;\n        for (uint256 i = 0; i < length; i++) {\n            methods[_selectors[i]] = _plugins[i];\n        }\n        emit InstallPlugin(_selectors, _plugins);\n    }\n\n    /// @notice Sets merkle root of vault permissions\n    /// @param _rootHash Hash of merkle root\n    function setMerkleRoot(bytes32 _rootHash) external {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        merkleRoot = _rootHash;\n    }\n\n    /// @notice Transfers ownership to given account\n    /// @param _newOwner Address of new owner\n    function transferOwnership(address _newOwner) external {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        owner = _newOwner;\n        emit TransferOwnership(msg.sender, _newOwner);\n    }\n\n    /// @notice Uninstalls plugin by setting function selector to zero address\n    /// @param _selectors List of function selectors\n    function uninstall(bytes4[] memory _selectors) external {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        uint256 length = _selectors.length;\n        for (uint256 i = 0; i < length; i++) {\n            methods[_selectors[i]] = address(0);\n        }\n        emit UninstallPlugin(_selectors);\n    }\n\n    /// @notice Executes plugin transactions through delegatecall\n    /// @param _target Target address\n    /// @param _data Transaction data\n    /// @return success Result status of delegatecall\n    /// @return response Return data of delegatecall\n    function _execute(address _target, bytes calldata _data)\n        internal\n        returns (bool success, bytes memory response)\n    {\n        // Check that the target is a valid contract\n        uint256 codeSize;\n        assembly {\n            codeSize := extcodesize(_target)\n        }\n        if (codeSize == 0) revert TargetInvalid(_target);\n        // Save the owner address in memory to ensure that it cannot be modified during the DELEGATECALL\n        address owner_ = owner;\n        // Reserve some gas to ensure that the function has enough to finish the execution\n        uint256 stipend = gasleft() - MIN_GAS_RESERVE;\n\n        // Delegate call to the target contract\n        (success, response) = _target.delegatecall{gas: stipend}(_data);\n        if (owner_ != owner) revert OwnerChanged(owner_, owner);\n\n        // Revert if execution was unsuccessful\n        if (!success) {\n            if (response.length == 0) revert ExecutionReverted();\n            _revertedWithReason(response);\n        }\n    }\n\n    /// @notice Reverts transaction with reason\n    function _revertedWithReason(bytes memory _response) internal pure {\n        assembly {\n            let returndata_size := mload(_response)\n            revert(add(32, _response), returndata_size)\n        }\n    }\n}"
    },
    {
      "filename": "src/Vault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IVault} from \"./interfaces/IVault.sol\";\nimport {MerkleProof} from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport {NFTReceiver} from \"./utils/NFTReceiver.sol\";\n\n/// @title Vault\n/// @author Fractional Art\n/// @notice Proxy contract for storing fractionalized assets\ncontract Vault is IVault, NFTReceiver {\n    /// @notice Address of vault owner\n    address public owner;\n    /// @notice Merkle root hash of vault permissions\n    bytes32 public merkleRoot;\n    /// @notice Initializer value\n    uint256 public nonce;\n    /// @dev Minimum reserve of gas units\n    uint256 private constant MIN_GAS_RESERVE = 5_000;\n    /// @notice Mapping of function selector to plugin address\n    mapping(bytes4 => address) public methods;\n\n    /// @dev Initializes nonce and proxy owner\n    function init() external {\n        if (nonce != 0) revert Initialized(owner, msg.sender, nonce);\n        nonce = 1;\n        owner = msg.sender;\n        emit TransferOwnership(address(0), msg.sender);\n    }\n\n    /// @dev Callback for receiving Ether when the calldata is empty\n    receive() external payable {}\n\n    /// @dev Callback for handling plugin transactions\n    /// @param _data Transaction data\n    /// @return response Return data from executing plugin\n    // prettier-ignore\n    fallback(bytes calldata _data) external payable returns (bytes memory response) {\n        address plugin = methods[msg.sig];\n        (,response) = _execute(plugin, _data);\n    }\n\n    /// @notice Executes vault transactions through delegatecall\n    /// @param _target Target address\n    /// @param _data Transaction data\n    /// @param _proof Merkle proof of permission hash\n    /// @return success Result status of delegatecall\n    /// @return response Return data of delegatecall\n    function execute(\n        address _target,\n        bytes calldata _data,\n        bytes32[] calldata _proof\n    ) external payable returns (bool success, bytes memory response) {\n        bytes4 selector;\n        assembly {\n            selector := calldataload(_data.offset)\n        }\n\n        // Generate leaf node by hashing module, target and function selector.\n        bytes32 leaf = keccak256(abi.encode(msg.sender, _target, selector));\n        // Check that the caller is either a module with permission to call or the owner.\n        if (!MerkleProof.verify(_proof, merkleRoot, leaf)) {\n            if (msg.sender != owner)\n                revert NotAuthorized(msg.sender, _target, selector);\n        }\n\n        (success, response) = _execute(_target, _data);\n    }\n\n    /// @notice Installs plugin by setting function selector to contract address\n    /// @param _selectors List of function selectors\n    /// @param _plugins Addresses of plugin contracts\n    function install(bytes4[] memory _selectors, address[] memory _plugins)\n        external\n    {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        uint256 length = _selectors.length;\n        for (uint256 i = 0; i < length; i++) {\n            methods[_selectors[i]] = _plugins[i];\n        }\n        emit InstallPlugin(_selectors, _plugins);\n    }\n\n    /// @notice Sets merkle root of vault permissions\n    /// @param _rootHash Hash of merkle root\n    function setMerkleRoot(bytes32 _rootHash) external {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        merkleRoot = _rootHash;\n    }\n\n    /// @notice Transfers ownership to given account\n    /// @param _newOwner Address of new owner\n    function transferOwnership(address _newOwner) external {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        owner = _newOwner;\n        emit TransferOwnership(msg.sender, _newOwner);\n    }\n\n    /// @notice Uninstalls plugin by setting function selector to zero address\n    /// @param _selectors List of function selectors\n    function uninstall(bytes4[] memory _selectors) external {\n        if (owner != msg.sender) revert NotOwner(owner, msg.sender);\n        uint256 length = _selectors.length;\n        for (uint256 i = 0; i < length; i++) {\n            methods[_selectors[i]] = address(0);\n        }\n        emit UninstallPlugin(_selectors);\n    }\n\n    /// @notice Executes plugin transactions through delegatecall\n    /// @param _target Target address\n    /// @param _data Transaction data\n    /// @return success Result status of delegatecall\n    /// @return response Return data of delegatecall\n    function _execute(address _target, bytes calldata _data)\n        internal\n        returns (bool success, bytes memory response)\n    {\n        // Check that the target is a valid contract\n        uint256 codeSize;\n        assembly {\n            codeSize := extcodesize(_target)\n        }\n        if (codeSize == 0) revert TargetInvalid(_target);\n        // Save the owner address in memory to ensure that it cannot be modified during the DELEGATECALL\n        address owner_ = owner;\n        // Reserve some gas to ensure that the function has enough to finish the execution\n        uint256 stipend = gasleft() - MIN_GAS_RESERVE;\n\n        // Delegate call to the target contract\n        (success, response) = _target.delegatecall{gas: stipend}(_data);\n        if (owner_ != owner) revert OwnerChanged(owner_, owner);\n\n        // Revert if execution was unsuccessful\n        if (!success) {\n            if (response.length == 0) revert ExecutionReverted();\n            _revertedWithReason(response);\n        }\n    }\n\n    /// @notice Reverts transaction with reason\n    function _revertedWithReason(bytes memory _response) internal pure {\n        assembly {\n            let returndata_size := mload(_response)\n            revert(add(32, _response), returndata_size)\n        }\n    }\n}"
    },
    {
      "filename": "src/VaultRegistry.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {ClonesWithImmutableArgs} from \"clones-with-immutable-args/src/ClonesWithImmutableArgs.sol\";\nimport {FERC1155} from \"./FERC1155.sol\";\nimport {IVault} from \"./interfaces/IVault.sol\";\nimport {IVaultRegistry, VaultInfo} from \"./interfaces/IVaultRegistry.sol\";\nimport {VaultFactory} from \"./VaultFactory.sol\";\n\n/// @title Vault Registry\n/// @author Fractional Art\n/// @notice Registry contract for tracking all fractional vaults\ncontract VaultRegistry is IVaultRegistry {\n    /// @dev Use clones library with address types\n    using ClonesWithImmutableArgs for address;\n    /// @notice Address of VaultFactory contract\n    address public immutable factory;\n    /// @notice Address of FERC1155 token contract\n    address public immutable fNFT;\n    /// @notice Address of Implementation for FERC1155 token contract\n    address public immutable fNFTImplementation;\n    /// @notice Mapping of collection address to next token ID type\n    mapping(address => uint256) public nextId;\n    /// @notice Mapping of vault address to vault information\n    mapping(address => VaultInfo) public vaultToToken;\n\n    /// @notice Initializes factory, implementation, and token contracts\n    constructor() {\n        factory = address(new VaultFactory());\n        fNFTImplementation = address(new FERC1155());\n        fNFT = fNFTImplementation.clone(\n            abi.encodePacked(msg.sender, address(this))\n        );\n    }\n\n    /// @notice Burns vault tokens\n    /// @param _from Source address\n    /// @param _value Amount of tokens\n    function burn(address _from, uint256 _value) external {\n        VaultInfo memory info = vaultToToken[msg.sender];\n        uint256 id = info.id;\n        if (id == 0) revert UnregisteredVault(msg.sender);\n        FERC1155(info.token).burn(_from, id, _value);\n    }\n\n    /// @notice Creates a new vault with permissions and plugins\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    function create(\n        bytes32 _merkleRoot,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) external returns (address vault) {\n        vault = _deployVault(_merkleRoot, address(fNFT), _plugins, _selectors);\n    }\n\n    /// @notice Creates a new vault with permissions and plugins, and transfers ownership to a given owner\n    /// @dev This should only be done in limited cases i.e. if you're okay with a trusted individual(s)\n    /// having control over the vault. Ideally, execution would be locked behind a Multisig wallet.\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _owner Address of the vault owner\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    function createFor(\n        bytes32 _merkleRoot,\n        address _owner,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) external returns (address vault) {\n        vault = _deployVault(_merkleRoot, address(fNFT), _plugins, _selectors);\n        IVault(vault).transferOwnership(_owner);\n    }\n\n    /// @notice Creates a new vault with permissions and plugins for the message sender\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    /// @return token Address of FERC1155 contract\n    function createCollection(\n        bytes32 _merkleRoot,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) external returns (address vault, address token) {\n        (vault, token) = createCollectionFor(\n            _merkleRoot,\n            msg.sender,\n            _plugins,\n            _selectors\n        );\n    }\n\n    /// @notice Creates a new vault with permissions and plugins for an existing collection\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _token Address of FERC1155 contract\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    function createInCollection(\n        bytes32 _merkleRoot,\n        address _token,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) external returns (address vault) {\n        address controller = FERC1155(_token).controller();\n        if (controller != msg.sender)\n            revert InvalidController(controller, msg.sender);\n        vault = _deployVault(_merkleRoot, _token, _plugins, _selectors);\n    }\n\n    /// @notice Mints vault tokens\n    /// @param _to Target address\n    /// @param _value Amount of tokens\n    function mint(address _to, uint256 _value) external {\n        VaultInfo memory info = vaultToToken[msg.sender];\n        uint256 id = info.id;\n        if (id == 0) revert UnregisteredVault(msg.sender);\n        FERC1155(info.token).mint(_to, id, _value, \"\");\n    }\n\n    /// @notice Gets the total supply for a token and ID associated with a vault\n    /// @param _vault Address of the vault\n    /// @return Total supply\n    function totalSupply(address _vault) external view returns (uint256) {\n        VaultInfo memory info = vaultToToken[_vault];\n        return FERC1155(info.token).totalSupply(info.id);\n    }\n\n    /// @notice Gets the uri for a given token and ID associated with a vault\n    /// @param _vault Address of the vault\n    /// @return URI of token\n    function uri(address _vault) external view returns (string memory) {\n        VaultInfo memory info = vaultToToken[_vault];\n        return FERC1155(info.token).uri(info.id);\n    }\n\n    /// @notice Creates a new vault with permissions and plugins for a given controller\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _controller Address of token controller\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    /// @return token Address of FERC1155 contract\n    function createCollectionFor(\n        bytes32 _merkleRoot,\n        address _controller,\n        address[] memory _plugins,\n        bytes4[] memory _selectors\n    ) public returns (address vault, address token) {\n        token = fNFTImplementation.clone(\n            abi.encodePacked(_controller, address(this))\n        );\n        vault = _deployVault(_merkleRoot, token, _plugins, _selectors);\n    }\n\n    /// @dev Deploys new vault for specified token, sets merkle root, and installs plugins\n    /// @param _merkleRoot Hash of merkle root for vault permissions\n    /// @param _token Address of FERC1155 contract\n    /// @param _plugins Addresses of plugin contracts\n    /// @param _selectors List of function selectors\n    /// @return vault Address of Proxy contract\n    function _deployVault(\n        bytes32 _merkleRoot,\n        address _token,\n        address[] memory"
    }
  ]
}