{
  "Title": "[L-01] `initNXTP` can be initialized multiple times.",
  "Content": "\n[L33-37](https://github.com/code-423n4/2022-03-lifinance/blob/main/src/Facets/NXTPFacet.sol#L33-L37)\n\n    function initNXTP(ITransactionManager _txMgrAddr) external {\n            Storage storage s = getStorage();\n            LibDiamond.enforceIsContractOwner();\n            s.nxtpTxManager = _txMgrAddr;\n        }\n\nThe function `initNXTP` has init in its name, suggesting that it should only be called once to intiliaze the `nxtpTxManager`. However, it can be called multiple times to overwrite the address.\n\nRecommend setting the address in a `constructor` or reverting if address is already set. Third option would be changing the name from `initNXTP` to something like `setNXTP` to better align function names with their functionality.\n\nNote: Same issue is present in `initHop` and `initCbridge`.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-03-lifinance",
  "Code": [
    {
      "filename": "src/Facets/NXTPFacet.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport { ITransactionManager } from \"../Interfaces/ITransactionManager.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport \"./Swapper.sol\";\n\n/**\n * @title NXTP (Connext) Facet\n * @author Li.Finance (https://li.finance)\n * @notice Provides functionality for bridging through NXTP (Connext)\n */\ncontract NXTPFacet is ILiFi, Swapper {\n    /* ========== Storage ========== */\n\n    bytes32 internal constant NAMESPACE = keccak256(\"com.lifi.facets.nxtp\");\n    struct Storage {\n        ITransactionManager nxtpTxManager;\n    }\n\n    /* ========== Events ========== */\n\n    event NXTPBridgeStarted(\n        bytes32 indexed lifiTransactionId,\n        bytes32 nxtpTransactionId,\n        ITransactionManager.TransactionData txData\n    );\n\n    /* ========== Init ========== */\n\n    function initNXTP(ITransactionManager _txMgrAddr) external {\n        Storage storage s = getStorage();\n        LibDiamond.enforceIsContractOwner();\n        s.nxtpTxManager = _txMgrAddr;\n    }\n\n    /* ========== Public Bridge Functions ========== */\n\n    /**\n     * @notice This function starts a cross-chain transaction using the NXTP protocol\n     * @param _lifiData data used purely for tracking and analytics\n     * @param _nxtpData data needed to complete an NXTP cross-chain transaction\n     */\n    function startBridgeTokensViaNXTP(LiFiData memory _lifiData, ITransactionManager.PrepareArgs memory _nxtpData)\n        public\n        payable\n    {\n        // Ensure sender has enough to complete the bridge transaction\n        address sendingAssetId = _nxtpData.invariantData.sendingAssetId;\n        if (sendingAssetId == address(0)) require(msg.value == _nxtpData.amount, \"ERR_INVALID_AMOUNT\");\n        else {\n            uint256 _sendingAssetIdBalance = LibAsset.getOwnBalance(sendingAssetId);\n            LibAsset.transferFromERC20(sendingAssetId, msg.sender, address(this), _nxtpData.amount);\n            require(\n                LibAsset.getOwnBalance(sendingAssetId) - _sendingAssetIdBalance == _nxtpData.amount,\n                \"ERR_INVALID_AMOUNT\"\n            );\n        }\n\n        // Start the bridge process\n        _startBridge(_lifiData.transactionId, _nxtpData);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @notice This function performs a swap or multiple swaps and then starts a cross-chain transaction\n     *         using the NXTP protocol.\n     * @param _lifiData data used purely for tracking and analytics\n     * @param _swapData array of data needed for swaps\n     * @param _nxtpData data needed to complete an NXTP cross-chain transaction\n     */\n    function swapAndStartBridgeTokensViaNXTP(\n        LiFiData memory _lifiData,\n        LibSwap.SwapData[] calldata _swapData,\n        ITransactionManager.PrepareArgs memory _nxtpData\n    ) public payable {\n        address sendingAssetId = _nxtpData.invariantData.sendingAssetId;\n        uint256 _sendingAssetIdBalance = LibAsset.getOwnBalance(sendingAssetId);\n\n        // Swap\n        _executeSwaps(_lifiData, _swapData);\n\n        uint256 _postSwapBalance = LibAsset.getOwnBalance(sendingAssetId) - _sendingAssetIdBalance;\n\n        require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n\n        _nxtpData.amount = _postSwapBalance;\n\n        _startBridge(_lifiData.transactionId, _nxtpData);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @notice Completes a cross-chain transaction on the receiving chain using the NXTP protocol.\n     * @param _lifiData data used purely for tracking and analytics\n     * @param assetId token received on the receiving chain\n     * @param receiver address that will receive the tokens\n     * @param amount number of tokens received\n     */\n    function completeBridgeTokensViaNXTP(\n        LiFiData memory _lifiData,\n        address assetId,\n        address receiver,\n        uint256 amount\n    ) public payable {\n        if (LibAsset.isNativeAsset(assetId)) {\n            require(msg.value == amount, \"INVALID_ETH_AMOUNT\");\n        } else {\n            require(msg.value == 0, \"ETH_WITH_ERC\");\n            LibAsset.transferFromERC20(assetId, msg.sender, address(this), amount);\n        }\n\n        LibAsset.transferAsset(assetId, payable(receiver), amount);\n\n        emit LiFiTransferCompleted(_lifiData.transactionId, assetId, receiver, amount, block.timestamp);\n    }\n\n    /**\n     * @notice Performs a swap before completing a cross-chain transaction\n     *         on the receiving chain using the NXTP protocol.\n     * @param _lifiData data used purely for tracking and analytics\n     * @param _swapData array of data needed for swaps\n     * @param finalAssetId token received on the receiving chain\n     * @param receiver address that will receive the tokens\n     */\n    function swapAndCompleteBridgeTokensViaNXTP(\n        LiFiData memory _lifiData,\n        LibSwap.SwapData[] calldata _swapData,\n        address finalAssetId,\n        address receiver\n    ) public payable {\n        uint256 startingBalance = LibAsset.getOwnBalance(finalAssetId);\n\n        // Swap\n        _executeSwaps(_lifiData, _swapData);\n\n        uint256 postSwapBalance = LibAsset.getOwnBalance(finalAssetId);\n\n        uint256 finalBalance;\n\n        if (postSwapBalance > startingBalance) {\n            finalBalance = postSwapBalance - startingBalance;\n            LibAsset.transferAsset(finalAssetId, payable(receiver), finalBalance);\n        }\n\n        emit LiFiTransferCompleted(_lifiData.transactionId, finalAssetId, receiver, finalBalance, block.timestamp);\n    }\n\n    /* ========== Internal Functions ========== */\n\n    function _startBridge(bytes32 _transactionId, ITransactionManager.PrepareArgs memory _nxtpData) internal {\n        Storage storage s = getStorage();\n        IERC20 sendingAssetId = IERC20(_nxtpData.invariantData.sendingAssetId);\n\n        // Give Connext approval to bridge tokens\n        LibAsset.approveERC20(IERC20(sendingAssetId), address(s.nxtpTxManager), _nxtpData.amount);\n\n        uint256 value = LibAsset.isNativeAsset(address(sendingAssetId)) ? _nxtpData.amount : 0;\n\n        // Initiate bridge transaction on sending chain\n        ITransactionManager.TransactionData memory result = s.nxtpTxManager.prepare{ value: value }(_nxtpData);\n\n        emit NXTPBridgeStarted(_transactionId, result.transactionId, result);\n    }\n\n    function getStorage() internal pure returns (Storage storage s) {\n        bytes32 namespace = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            s.slot := namespace\n        }\n    }\n\n    /* ========== Getter Functions ========== */\n\n    /**\n     * @notice show the NXTP transaction manager contract address\n     */\n    function getNXTPTransactionManager() external view returns (address) {\n        Storage storage s = getStorage();\n        return address(s.nxtpTxManager);\n    }\n}"
    }
  ]
}