{
  "Title": "H-2: `StrategyUtils::_executeDynamicTradeExactIn` does not wrap steth",
  "Content": "# Issue H-2: `StrategyUtils::_executeDynamicTradeExactIn` does not wrap steth \n\nSource: https://github.com/sherlock-audit/2022-09-notional-judging/issues/99 \n\n## Found by \n0x52, lemonmon\n\n## Summary\n\n`StrategyUtils::_executeDynamicTradeExactIn` will return bought steth value instead of wrapped steth. Also, steth is not wrapped as it is supposed to be.\n\n## Vulnerability Detail\n\nIn the `StrategyUtils::_executeDynamicTradeExactIn`, if `params.tradeUnwrapped` is true, and `buyToken` is `WRAPPED_STETH`, the `buyToken` will be updated to be `WRAPPED_STETH.stETH()`, which is basically `STHETH` (not wrapped). (line 62 in StrategyUtils). So, it buys `stETH` in the trade, and the `amountBought` will be the amount of `stETH` bought. But the `amountBought` was expected to be the `WRAPPED_STETH` amount, as the buyToken given as `WRAPPED_STETH`. The `WRAPPED_STETH` and `STETH` are not 1 to 1, so an user can get more amountBought or less amountBought depending on the market than what is actually bought in `WRAPPED_STETH`.\n\nLater in the same function (line 80-90), if `params.tradeUnwrapped` is true and `buyToken` is `WRAPPED_STETH` and the `amountBought` is bigger than zero, it will wrap the bought stETH to `WARPPED_STETH` and update the `amountBought` to the `WRAPPED_STETH` value. However, this code will be never reached, because if the first two conditions are met, the buyToken would be updated to the `stETH` in the above (line 62).\n\nFor example, 100 Wrapped steth will give 108 steth. So, If I choose trade unwrapped to be true, I will get 108 steth, which will be 100 wrapped steth, and get 100 amountBought. But, since my steth bought will not be wrapped, the amountBought returned will be 108, with the buyToken wrapped steth.\n\n## Impact\n\n`StrategyUtils::_executeDynamicTradeExactIn` will return not correct `amountBought`, which will be used in other parts of contract.\nIf `WRAPPED_STETH` is more expensive, which appears to be the case currently, then an attacker can get more than what is actually sold.\n\nAlso, the steth is not wrapped as it is supposed to be, and it leads to accounting error.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/internal/strategy/StrategyUtils.sol?plain=1#L41-L91\n\n```solidity\nFILE: StrategyUtils.sol\n\n 41     function _executeDynamicTradeExactIn(\n 42         DynamicTradeParams memory params,\n 43         ITradingModule tradingModule,\n 44         address sellToken,\n 45         address buyToken,\n 46         uint256 amount\n 47     ) internal returns (uint256 amountSold, uint256 amountBought) {\n 48         require(\n 49             params.tradeType == TradeType.EXACT_IN_SINGLE || params.tradeType == TradeType.EXACT_IN_BATCH\n 50         );\n 51\n 52         // stETH generally has deeper liquidity than wstETH, setting tradeUnwrapped\n 53         // to lets the contract trade in stETH instead of wstETH\n 54         if (params.tradeUnwrapped && sellToken == address(Deployments.WRAPPED_STETH)) {\n 55             sellToken = Deployments.WRAPPED_STETH.stETH();\n 56             uint256 unwrappedAmount = IERC20(sellToken).balanceOf(address(this));\n 57             // NOTE: the amount returned by unwrap is not always accurate for some reason\n 58             Deployments.WRAPPED_STETH.unwrap(amount);\n 59             amount = IERC20(sellToken).balanceOf(address(this)) - unwrappedAmount;\n 60         }\n 61         if (params.tradeUnwrapped && buyToken == address(Deployments.WRAPPED_STETH)) {\n 62             buyToken = Deployments.WRAPPED_STETH.stETH();\n 63         }\n 64\n 65         // Sell residual secondary balance\n 66         Trade memory trade = Trade(\n 67             params.tradeType,\n 68             sellToken,\n 69             buyToken,\n 70             amount,\n 71             0,\n 72             block.timestamp, // deadline\n 73             params.exchangeData\n 74         );\n 75\n 76         (amountSold, amountBought) = trade._executeTradeWithDynamicSlippage(\n 77             params.dexId, tradingModule, params.oracleSlippagePercent\n 78         );\n 79\n 80         if (\n 81             params.tradeUnwrapped &&\n 82             buyToken == address(Deployments.WRAPPED_STETH) &&\n 83             amountBought > 0\n 84         ) {\n 85             IERC20(buyToken).checkApprove(address(Deployments.WRAPPED_STETH), amountBought);\n 86             uint256 wrappedAmount = Deployments.WRAPPED_STETH.balanceOf(address(this));\n 87             /// @notice the amount returned by wrap is not always accurate for some reason\n 88             Deployments.WRAPPED_STETH.wrap(amountBought);\n 89             amountBought = Deployments.WRAPPED_STETH.balanceOf(address(this)) - wrappedAmount;\n 90         }\n 91     }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nRather than overwriting the buyToken, use a new local variable for the stEth, to differentiate when `tradeUnwrapped` is true and buyToken was steth, vs `tradeUnwrapped` is true and buyToken was wrapped steth, which was then overwritten to steth.\nOnly when `tradeUnwrapped` is true and the original `buyToken` is wrapped steth, convert bought steth to wrapped steth.\n\nOr do not allow `tradeUnwrapped` to be true when buyToken is steth, and overwrite buyToken as steth. Then, if tradeUnwrapped is true and buyToken is steth, wrap the bought steth.\n\n\n## Discussion\n\n**jeffywu**\n\n@weitianjie2000 \n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/2",
  "Code": [
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/internal/strategy/StrategyUtils.sol?plain=1",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.15;\n\nimport { StrategyContext, DynamicTradeParams } from \"../../BalancerVaultTypes.sol\";\nimport {TokenUtils, IERC20} from \"../../../../utils/TokenUtils.sol\";\nimport {TradeHandler} from \"../../../../trading/TradeHandler.sol\";\nimport {BalancerUtils} from \"../pool/BalancerUtils.sol\";\nimport {Deployments} from \"../../../../global/Deployments.sol\";\nimport {Constants} from \"../../../../global/Constants.sol\";\nimport {BalancerConstants} from \"../BalancerConstants.sol\";\nimport {ITradingModule, Trade, TradeType} from \"../../../../../interfaces/trading/ITradingModule.sol\";\n\nlibrary StrategyUtils {\n    using TradeHandler for Trade;\n    using TokenUtils for IERC20;\n\n    /// @notice Converts strategy tokens to BPT\n    function _convertStrategyTokensToBPTClaim(StrategyContext memory context, uint256 strategyTokenAmount)\n        internal pure returns (uint256 bptClaim) {\n        require(strategyTokenAmount <= context.vaultState.totalStrategyTokenGlobal);\n        if (context.vaultState.totalStrategyTokenGlobal > 0) {\n            bptClaim = (strategyTokenAmount * context.totalBPTHeld) / context.vaultState.totalStrategyTokenGlobal;\n        }\n    }\n\n    /// @notice Converts BPT to strategy tokens\n    function _convertBPTClaimToStrategyTokens(StrategyContext memory context, uint256 bptClaim)\n        internal pure returns (uint256 strategyTokenAmount) {\n        if (context.totalBPTHeld == 0) {\n            // Strategy tokens are in 8 decimal precision, BPT is in 18. Scale the minted amount down.\n            return (bptClaim * uint256(Constants.INTERNAL_TOKEN_PRECISION)) / \n                BalancerConstants.BALANCER_PRECISION;\n        }\n\n        // BPT held in maturity is calculated before the new BPT tokens are minted, so this calculation\n        // is the tokens minted that will give the account a corresponding share of the new bpt balance held.\n        // The precision here will be the same as strategy token supply.\n        strategyTokenAmount = (bptClaim * context.vaultState.totalStrategyTokenGlobal) / context.totalBPTHeld;\n    }\n\n    function _executeDynamicTradeExactIn(\n        DynamicTradeParams memory params,\n        ITradingModule tradingModule,\n        address sellToken,\n        address buyToken,\n        uint256 amount\n    ) internal returns (uint256 amountSold, uint256 amountBought) {\n        require(\n            params.tradeType == TradeType.EXACT_IN_SINGLE || params.tradeType == TradeType.EXACT_IN_BATCH\n        );\n\n        // stETH generally has deeper liquidity than wstETH, setting tradeUnwrapped\n        // to lets the contract trade in stETH instead of wstETH\n        if (params.tradeUnwrapped && sellToken == address(Deployments.WRAPPED_STETH)) {\n            sellToken = Deployments.WRAPPED_STETH.stETH();\n            uint256 unwrappedAmount = IERC20(sellToken).balanceOf(address(this));\n            // NOTE: the amount returned by unwrap is not always accurate for some reason\n            Deployments.WRAPPED_STETH.unwrap(amount);\n            amount = IERC20(sellToken).balanceOf(address(this)) - unwrappedAmount;\n        }\n        if (params.tradeUnwrapped && buyToken == address(Deployments.WRAPPED_STETH)) {\n            buyToken = Deployments.WRAPPED_STETH.stETH();\n        }\n\n        // Sell residual secondary balance\n        Trade memory trade = Trade(\n            params.tradeType,\n            sellToken,\n            buyToken,\n            amount,\n            0,\n            block.timestamp, // deadline\n            params.exchangeData\n        );\n\n        (amountSold, amountBought) = trade._executeTradeWithDynamicSlippage(\n            params.dexId, tradingModule, params.oracleSlippagePercent\n        );\n\n        if (\n            params.tradeUnwrapped && \n            buyToken == address(Deployments.WRAPPED_STETH) && \n            amountBought > 0\n        ) {\n            IERC20(buyToken).checkApprove(address(Deployments.WRAPPED_STETH), amountBought);\n            uint256 wrappedAmount = Deployments.WRAPPED_STETH.balanceOf(address(this));\n            /// @notice the amount returned by wrap is not always accurate for some reason\n            Deployments.WRAPPED_STETH.wrap(amountBought);\n            amountBought = Deployments.WRAPPED_STETH.balanceOf(address(this)) - wrappedAmount;\n        }\n    }\n}"
    }
  ]
}