{
  "Title": "Inability to cancel transactions with long expiration times after owner replacement",
  "Content": "##### Description\nIn the current implementation, when owners are replaced, transactions with the previously set long `_expirationTime` values continue to remain in the list of pending transactions. New owners are unable to cancel these transactions, potentially allowing malicious transactions to be executed in the future. This poses a security risk, as new owners may not have the desired control over pending transactions submitted by previous owners.\n\n- https://github.com/cloudwalk/brlc-multisig/blob/b5d6c2b6273162d5666d48649890b15a113df7a7/contracts/base/MultiSigWalletBase.sol#L314\n\nNote, that the `revoke()` function cannot help in that case, because it only revokes a single approval of a specific owner and cannot revoke old approvals if the owners are changed.\n\n- https://github.com/cloudwalk/brlc-multisig/blob/b5d6c2b6273162d5666d48649890b15a113df7a7/contracts/base/MultiSigWalletBase.sol#L387\n\n##### Recommendation\n\nTo address this vulnerability, implement a mechanism to either automatically cancel or invalidate all pending transactions when owners are replaced. Alternatively, allow new owners to cancel or reject transactions, providing them with the necessary control over the contract's pending transactions. This will help prevent the execution of unwanted or malicious transactions submitted by the previous owners and ensure that only transactions approved by the current set of owners are executed.\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/base/MultiSigWalletBase.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport { IMultiSigWallet } from \"./IMultiSigWallet.sol\";\nimport { MultiSigWalletStorage } from \"./MultiSigWalletStorage.sol\";\n\n/**\n * @title MultiSigWalletBase contract\n * @author CloudWalk Inc.\n * @dev The base of the multi-signature wallet contract.\n */\nabstract contract MultiSigWalletBase is MultiSigWalletStorage, IMultiSigWallet {\n    // --------------------------- Errors ---------------------------\n\n    /// @dev An unauthorized account called a function.\n    error UnauthorizedCaller();\n\n    /// @dev A transaction with the specified Id does not exist.\n    error TransactionNotExist();\n\n    /// @dev A transaction with the specified Id is already executed.\n    error TransactionAlreadyExecuted();\n\n    /// @dev A transaction with the specified Id must be approved by the caller.\n    error TransactionNotApproved();\n\n    /// @dev A transaction with the specified Id is already approved by the caller.\n    error TransactionAlreadyApproved();\n\n    /// @dev An empty array of addresses was passed when configuring the wallet owners.\n    error EmptyOwnersArray();\n\n    /// @dev The zero address was passed within the owners array when configuring the wallet owners.\n    error ZeroOwnerAddress();\n\n    /// @dev A duplicate address was passed within the owners array when configuring the wallet owners.\n    error DuplicateOwnerAddress();\n\n    /// @dev An invalid number of required approvals was passed when configuring the wallet owners.\n    error InvalidRequiredApprovals();\n\n    /// @dev The number of approvals for a given transaction is less than the required minimum.\n    error NotEnoughApprovals();\n\n    /// @dev A low level call/transaction to the transaction receiver failed.\n    error InternalTransactionFailed(bytes data);\n\n    /// @dev A transaction with the specified Id has already expired.\n    error TransactionExpired();\n\n    /// @dev A transaction with the specified Id is on cooldown.\n    error CooldownNotEnded();\n\n    // ------------------------- Modifiers --------------------------\n\n    /**\n     * @dev Throws if called by any account other than a wallet owner.\n     */\n    modifier onlyOwner() {\n        if (!_isOwner[msg.sender]) {\n            revert UnauthorizedCaller();\n        }\n        _;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the contract itself.\n     */\n    modifier onlySelfCall() {\n        if (msg.sender != address(this)) {\n            revert UnauthorizedCaller();\n        }\n        _;\n    }\n\n    // ------------------------- Functions --------------------------\n\n    /**\n     * @dev Called when native tokens are sent to the contract.\n     *\n     * Emits a {Deposit} event.\n     */\n    receive() external payable {\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-submit}.\n     *\n     * Requirements:\n     *\n     * - The caller must be a wallet owner.\n     */\n    function submit(\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) external onlyOwner {\n        _submit(to, value, data);\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-submitAndApprove}.\n     *\n     * Requirements:\n     *\n     * - The caller must be a wallet owner.\n     */\n    function submitAndApprove(\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) external onlyOwner {\n        _approve(_submit(to, value, data));\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-approve}.\n     *\n     * Requirements:\n     *\n     * - The caller must be a wallet owner.\n     * - The transaction with the given Id must exist.\n     * - The transaction with the given Id must not be expired.\n     * - The transaction with the given Id must not be executed.\n     * - The transaction with the given Id must not be already approved by the caller.\n     */\n    function approve(uint256 txId) external onlyOwner {\n        _approve(txId);\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-approveAndExecute}.\n     *\n     * Requirements:\n     *\n     * - The caller must be a wallet owner.\n     * - The transaction with the given Id must exist.\n     * - The transaction with the given Id must not be expired.\n     * - The transaction with the given Id must not be executed.\n     * - The transaction with the given Id must not be on cooldown.\n     * - The transaction with the given Id must not be already approved by the caller.\n     * - The transaction with the given Id must have at least the required number of approvals minus one.\n     */\n    function approveAndExecute(uint256 txId) external onlyOwner {\n        _approve(txId);\n        _execute(txId);\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-execute}.\n     *\n     * Requirements:\n     *\n     * - The caller must be a wallet owner.\n     * - The transaction with the given Id must exist.\n     * - The transaction with the given Id must not be expired.\n     * - The transaction with the given Id must not be executed.\n     * - The transaction with the given Id must not be on cooldown.\n     * - The transaction with the given Id must have at least the required number of approvals.\n     */\n    function execute(uint256 txId) external onlyOwner {\n        _execute(txId);\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-revoke}.\n     *\n     * Requirements:\n     *\n     * - The caller must be a wallet owner.\n     * - The transaction with the given Id must exist.\n     * - The transaction with the given Id must not be expired.\n     * - The transaction with the given Id must not be executed.\n     * - The transaction with the given Id must be approved by the caller.\n     */\n    function revoke(uint256 txId) external onlyOwner {\n        _revoke(txId);\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-configureOwners}\n     *\n     * Requirements:\n     *\n     * - The array of wallet owners must not be empty.\n     * - The number of required approvals must not be zero and must not exceed the length of the wallet owners array.\n     */\n    function configureOwners(address[] memory newOwners, uint16 newRequiredApprovals) external onlySelfCall {\n        _configureOwners(newOwners, newRequiredApprovals);\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-configureExpirationTime}\n     */\n    function configureExpirationTime(uint120 newExpirationTime) external onlySelfCall {\n        _configureExpirationTime(newExpirationTime);\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-configureCooldownTime}\n     */\n    function configureCooldownTime(uint120 newCooldownTime) external onlySelfCall {\n        _configureCooldownTime(newCooldownTime);\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-getApprovalCount}.\n     */\n    function getApprovalCount(uint256 txId) external view returns (uint256) {\n        return _approvalCount[txId];\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-getApprovalStatus}.\n     */\n    function getApprovalStatus(uint256 txId, address owner) external view returns (bool) {\n        return _approvalStatus[txId][owner];\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-getTransaction}.\n     */\n    function getTransaction(uint256 txId) external view returns (Transaction memory) {\n        if (txId >= _transactions.length) {\n            revert TransactionNotExist();\n        }\n        return _transactions[txId];\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-getTransactions}.\n     *\n     * The total number of returned transactions will not exceed the provided limit, but may be less.\n     * The function will return an empty array if there is no transaction with the given Id or if the limit is zero.\n     * The empty transaction array will be returned if the transaction with the provided Id does not exist or the\n     * provided limit is zero.\n     */\n    function getTransactions(uint256 txId, uint256 limit) external view returns (Transaction[] memory txs) {\n        uint256 len = _transactions.length;\n        if (len <= txId || limit == 0) {\n            txs = new Transaction[](0);\n        } else {\n            len -= txId;\n            if (len > limit) {\n                len = limit;\n            }\n            txs = new Transaction[](len);\n            for (uint256 i = 0; i < len; i++) {\n                txs[i] = _transactions[txId];\n                txId++;\n            }\n        }\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-owners}.\n     */\n    function owners() external view returns (address[] memory) {\n        return _owners;\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-isOwner}.\n     */\n    function isOwner(address account) external view returns (bool) {\n        return _isOwner[account];\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-requiredApprovals}.\n     */\n    function requiredApprovals() external view returns (uint256) {\n        return _requiredApprovals;\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-transactionCount}.\n     */\n    function transactionCount() external view returns (uint256) {\n        return _transactions.length;\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-expirationTime}.\n     */\n    function expirationTime() external view returns (uint120) {\n        return _expirationTime;\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-cooldownTime}.\n     */\n    function cooldownTime() external view returns (uint120) {\n        return _cooldownTime;\n    }\n\n    /**\n     * @dev See {MultiSigWallet-submit}.\n     */\n    function _submit(\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) internal returns (uint256 txId) {\n        uint128 blockTimestamp = toUint128(block.timestamp);\n\n        _transactions.push(\n            Transaction({\n                to: to,\n                executed: false,\n                cooldown: blockTimestamp + _cooldownTime,\n                expiration: blockTimestamp + _cooldownTime + _expirationTime,\n                value: value,\n                data: data\n            })\n        );\n\n        txId = _transactions.length - 1;\n\n        emit Submit(msg.sender, txId);\n    }\n\n    /**\n     * @dev See {MultiSigWallet-approve}.\n     */\n    function _approve(uint256 txId) internal {\n        if (txId >= _transactions.length) {\n            revert TransactionNotExist();\n        }\n        if (_approvalStatus[txId][msg.sender]) {\n            revert TransactionAlreadyApproved();\n        }\n\n        Transaction memory transaction = _transactions[txId];\n\n        if (transaction.executed) {\n            revert TransactionAlreadyExecuted();\n        }\n        if (transaction.expiration < block.timestamp) {\n            revert TransactionExpired();\n        }\n\n        _approvalCount[txId] += 1;\n        _approvalStatus[txId][msg.sender] = true;\n\n        emit Approve(msg.sender, txId);\n    }\n\n    /**\n     * @dev See {MultiSigWallet-execute}.\n     */\n    function _execute(uint256 txId) internal {\n        if (txId >= _transactions.length) {\n            revert TransactionNotExist();\n        }\n\n        Transaction storage transaction = _transactions[txId];\n\n        if (transaction.executed) {\n            revert TransactionAlreadyExecuted();\n        }\n        if (transaction.cooldown > block.timestamp) {\n            revert CooldownNotEnded();\n        }\n        if (transaction.expiration < block.timestamp) {\n            revert TransactionExpired();\n        }\n        if (_approvalCount[txId] < _requiredApprovals) {\n            revert NotEnoughApprovals();\n        }\n\n        transaction.executed = true;\n\n        emit Execute(msg.sender, txId);\n\n        (bool success, bytes memory data) = transaction.to.call{ value: transaction.value }(transaction.data);\n        if (!success) {\n            revert InternalTransactionFailed(data);\n        }\n    }\n\n    /**\n     * @dev See {MultiSigWallet-revoke}.\n     */\n    function _revoke(uint256 txId) internal {\n        if (txId >= _transactions.length) {\n            revert TransactionNotExist();\n        }\n        if (!_approvalStatus[txId][msg.sender]) {\n            revert TransactionNotApproved();\n        }\n\n        Transaction storage transaction = _transactions[txId];\n\n        if (transaction.executed) {\n            revert TransactionAlreadyExecuted();\n        }\n        if (transaction.expiration < block.timestamp) {\n            revert TransactionExpired();\n        }\n\n        _approvalCount[txId] -= 1;\n        _approvalStatus[txId][msg.sender] = false;\n\n        emit Revoke(msg.sender, txId);\n    }\n\n    /**\n     * @dev See {MultiSigWallet-configureOwners}.\n     */\n    function _configureOwners(address[] memory newOwners, uint16 newRequiredApprovals) internal {\n        if (newOwners.length == 0) {\n            revert EmptyOwnersArray();\n        }\n        if (newRequiredApprovals == 0) {\n            revert InvalidRequiredApprovals();\n        }\n        if (newRequiredApprovals > newOwners.length) {\n            revert InvalidRequiredApprovals();\n        }\n\n        uint256 len;\n        if (_owners.length != 0) {\n            len = _owners.length;\n            for (uint256 i = 0; i < len; i++) {\n                _isOwner[_owners[i]] = false;\n            }\n        }\n\n        address owner;\n        len = newOwners.length;\n        for (uint256 i = 0; i < len; i++) {\n            owner = newOwners[i];\n\n            if (owner == address(0)) {\n                revert ZeroOwnerAddress();\n            }\n            if (_isOwner[owner]) {\n                revert DuplicateOwnerAddress();\n            }\n\n            _isOwner[owner] = true;\n        }\n\n        _owners = newOwners;\n        _requiredApprovals = newRequiredApprovals;\n\n        emit ConfigureOwners(newOwners, newRequiredApprovals);\n    }\n\n    /**\n     * @dev See {MultiSigWallet-configureExpirationTime}.\n     */\n    function _configureExpirationTime(uint120 newExpirationTime) internal {\n        _expirationTime = newExpirationTime;\n        emit ConfigureExpirationTime(newExpirationTime);\n    }\n\n    /**\n     * @dev See {MultiSigWallet-configureCooldownTime}.\n     */\n    function _configureCooldownTime(uint120 newCooldownTime) internal {\n        _cooldownTime = newCooldownTime;\n        emit ConfigureCooldownTime(newCooldownTime);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n}"
    },
    {
      "filename": "contracts/base/MultiSigWalletBase.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport { IMultiSigWallet } from \"./IMultiSigWallet.sol\";\nimport { MultiSigWalletStorage } from \"./MultiSigWalletStorage.sol\";\n\n/**\n * @title MultiSigWalletBase contract\n * @author CloudWalk Inc.\n * @dev The base of the multi-signature wallet contract.\n */\nabstract contract MultiSigWalletBase is MultiSigWalletStorage, IMultiSigWallet {\n    // --------------------------- Errors ---------------------------\n\n    /// @dev An unauthorized account called a function.\n    error UnauthorizedCaller();\n\n    /// @dev A transaction with the specified Id does not exist.\n    error TransactionNotExist();\n\n    /// @dev A transaction with the specified Id is already executed.\n    error TransactionAlreadyExecuted();\n\n    /// @dev A transaction with the specified Id must be approved by the caller.\n    error TransactionNotApproved();\n\n    /// @dev A transaction with the specified Id is already approved by the caller.\n    error TransactionAlreadyApproved();\n\n    /// @dev An empty array of addresses was passed when configuring the wallet owners.\n    error EmptyOwnersArray();\n\n    /// @dev The zero address was passed within the owners array when configuring the wallet owners.\n    error ZeroOwnerAddress();\n\n    /// @dev A duplicate address was passed within the owners array when configuring the wallet owners.\n    error DuplicateOwnerAddress();\n\n    /// @dev An invalid number of required approvals was passed when configuring the wallet owners.\n    error InvalidRequiredApprovals();\n\n    /// @dev The number of approvals for a given transaction is less than the required minimum.\n    error NotEnoughApprovals();\n\n    /// @dev A low level call/transaction to the transaction receiver failed.\n    error InternalTransactionFailed(bytes data);\n\n    /// @dev A transaction with the specified Id has already expired.\n    error TransactionExpired();\n\n    /// @dev A transaction with the specified Id is on cooldown.\n    error CooldownNotEnded();\n\n    // ------------------------- Modifiers --------------------------\n\n    /**\n     * @dev Throws if called by any account other than a wallet owner.\n     */\n    modifier onlyOwner() {\n        if (!_isOwner[msg.sender]) {\n            revert UnauthorizedCaller();\n        }\n        _;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the contract itself.\n     */\n    modifier onlySelfCall() {\n        if (msg.sender != address(this)) {\n            revert UnauthorizedCaller();\n        }\n        _;\n    }\n\n    // ------------------------- Functions --------------------------\n\n    /**\n     * @dev Called when native tokens are sent to the contract.\n     *\n     * Emits a {Deposit} event.\n     */\n    receive() external payable {\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-submit}.\n     *\n     * Requirements:\n     *\n     * - The caller must be a wallet owner.\n     */\n    function submit(\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) external onlyOwner {\n        _submit(to, value, data);\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-submitAndApprove}.\n     *\n     * Requirements:\n     *\n     * - The caller must be a wallet owner.\n     */\n    function submitAndApprove(\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) external onlyOwner {\n        _approve(_submit(to, value, data));\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-approve}.\n     *\n     * Requirements:\n     *\n     * - The caller must be a wallet owner.\n     * - The transaction with the given Id must exist.\n     * - The transaction with the given Id must not be expired.\n     * - The transaction with the given Id must not be executed.\n     * - The transaction with the given Id must not be already approved by the caller.\n     */\n    function approve(uint256 txId) external onlyOwner {\n        _approve(txId);\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-approveAndExecute}.\n     *\n     * Requirements:\n     *\n     * - The caller must be a wallet owner.\n     * - The transaction with the given Id must exist.\n     * - The transaction with the given Id must not be expired.\n     * - The transaction with the given Id must not be executed.\n     * - The transaction with the given Id must not be on cooldown.\n     * - The transaction with the given Id must not be already approved by the caller.\n     * - The transaction with the given Id must have at least the required number of approvals minus one.\n     */\n    function approveAndExecute(uint256 txId) external onlyOwner {\n        _approve(txId);\n        _execute(txId);\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-execute}.\n     *\n     * Requirements:\n     *\n     * - The caller must be a wallet owner.\n     * - The transaction with the given Id must exist.\n     * - The transaction with the given Id must not be expired.\n     * - The transaction with the given Id must not be executed.\n     * - The transaction with the given Id must not be on cooldown.\n     * - The transaction with the given Id must have at least the required number of approvals.\n     */\n    function execute(uint256 txId) external onlyOwner {\n        _execute(txId);\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-revoke}.\n     *\n     * Requirements:\n     *\n     * - The caller must be a wallet owner.\n     * - The transaction with the given Id must exist.\n     * - The transaction with the given Id must not be expired.\n     * - The transaction with the given Id must not be executed.\n     * - The transaction with the given Id must be approved by the caller.\n     */\n    function revoke(uint256 txId) external onlyOwner {\n        _revoke(txId);\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-configureOwners}\n     *\n     * Requirements:\n     *\n     * - The array of wallet owners must not be empty.\n     * - The number of required approvals must not be zero and must not exceed the length of the wallet owners array.\n     */\n    function configureOwners(address[] memory newOwners, uint16 newRequiredApprovals) external onlySelfCall {\n        _configureOwners(newOwners, newRequiredApprovals);\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-configureExpirationTime}\n     */\n    function configureExpirationTime(uint120 newExpirationTime) external onlySelfCall {\n        _configureExpirationTime(newExpirationTime);\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-configureCooldownTime}\n     */\n    function configureCooldownTime(uint120 newCooldownTime) external onlySelfCall {\n        _configureCooldownTime(newCooldownTime);\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-getApprovalCount}.\n     */\n    function getApprovalCount(uint256 txId) external view returns (uint256) {\n        return _approvalCount[txId];\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-getApprovalStatus}.\n     */\n    function getApprovalStatus(uint256 txId, address owner) external view returns (bool) {\n        return _approvalStatus[txId][owner];\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-getTransaction}.\n     */\n    function getTransaction(uint256 txId) external view returns (Transaction memory) {\n        if (txId >= _transactions.length) {\n            revert TransactionNotExist();\n        }\n        return _transactions[txId];\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-getTransactions}.\n     *\n     * The total number of returned transactions will not exceed the provided limit, but may be less.\n     * The function will return an empty array if there is no transaction with the given Id or if the limit is zero.\n     * The empty transaction array will be returned if the transaction with the provided Id does not exist or the\n     * provided limit is zero.\n     */\n    function getTransactions(uint256 txId, uint256 limit) external view returns (Transaction[] memory txs) {\n        uint256 len = _transactions.length;\n        if (len <= txId || limit == 0) {\n            txs = new Transaction[](0);\n        } else {\n            len -= txId;\n            if (len > limit) {\n                len = limit;\n            }\n            txs = new Transaction[](len);\n            for (uint256 i = 0; i < len; i++) {\n                txs[i] = _transactions[txId];\n                txId++;\n            }\n        }\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-owners}.\n     */\n    function owners() external view returns (address[] memory) {\n        return _owners;\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-isOwner}.\n     */\n    function isOwner(address account) external view returns (bool) {\n        return _isOwner[account];\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-requiredApprovals}.\n     */\n    function requiredApprovals() external view returns (uint256) {\n        return _requiredApprovals;\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-transactionCount}.\n     */\n    function transactionCount() external view returns (uint256) {\n        return _transactions.length;\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-expirationTime}.\n     */\n    function expirationTime() external view returns (uint120) {\n        return _expirationTime;\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-cooldownTime}.\n     */\n    function cooldownTime() external view returns (uint120) {\n        return _cooldownTime;\n    }\n\n    /**\n     * @dev See {MultiSigWallet-submit}.\n     */\n    function _submit(\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) internal returns (uint256 txId) {\n        uint128 blockTimestamp = toUint128(block.timestamp);\n\n        _transactions.push(\n            Transaction({\n                to: to,\n                executed: false,\n                cooldown: blockTimestamp + _cooldownTime,\n                expiration: blockTimestamp + _cooldownTime + _expirationTime,\n                value: value,\n                data: data\n            })\n        );\n\n        txId = _transactions.length - 1;\n\n        emit Submit(msg.sender, txId);\n    }\n\n    /**\n     * @dev See {MultiSigWallet-approve}.\n     */\n    function _approve(uint256 txId) internal {\n        if (txId >= _transactions.length) {\n            revert TransactionNotExist();\n        }\n        if (_approvalStatus[txId][msg.sender]) {\n            revert TransactionAlreadyApproved();\n        }\n\n        Transaction memory transaction = _transactions[txId];\n\n        if (transaction.executed) {\n            revert TransactionAlreadyExecuted();\n        }\n        if (transaction.expiration < block.timestamp) {\n            revert TransactionExpired();\n        }\n\n        _approvalCount[txId] += 1;\n        _approvalStatus[txId][msg.sender] = true;\n\n        emit Approve(msg.sender, txId);\n    }\n\n    /**\n     * @dev See {MultiSigWallet-execute}.\n     */\n    function _execute(uint256 txId) internal {\n        if (txId >= _transactions.length) {\n            revert TransactionNotExist();\n        }\n\n        Transaction storage transaction = _transactions[txId];\n\n        if (transaction.executed) {\n            revert TransactionAlreadyExecuted();\n        }\n        if (transaction.cooldown > block.timestamp) {\n            revert CooldownNotEnded();\n        }\n        if (transaction.expiration < block.timestamp) {\n            revert TransactionExpired();\n        }\n        if (_approvalCount[txId] < _requiredApprovals) {\n            revert NotEnoughApprovals();\n        }\n\n        transaction.executed = true;\n\n        emit Execute(msg.sender, txId);\n\n        (bool success, bytes memory data) = transaction.to.call{ value: transaction.value }(transaction.data);\n        if (!success) {\n            revert InternalTransactionFailed(data);\n        }\n    }\n\n    /**\n     * @dev See {MultiSigWallet-revoke}.\n     */\n    function _revoke(uint256 txId) internal {\n        if (txId >= _transactions.length) {\n            revert TransactionNotExist();\n        }\n        if (!_approvalStatus[txId][msg.sender]) {\n            revert TransactionNotApproved();\n        }\n\n        Transaction storage transaction = _transactions[txId];\n\n        if (transaction.executed) {\n            revert TransactionAlreadyExecuted();\n        }\n        if (transaction.expiration < block.timestamp) {\n            revert TransactionExpired();\n        }\n\n        _approvalCount[txId] -= 1;\n        _approvalStatus[txId][msg.sender] = false;\n\n        emit Revoke(msg.sender, txId);\n    }\n\n    /**\n     * @dev See {MultiSigWallet-configureOwners}.\n     */\n    function _configureOwners(address[] memory newOwners, uint16 newRequiredApprovals) internal {\n        if (newOwners.length == 0) {\n            revert EmptyOwnersArray();\n        }\n        if (newRequiredApprovals == 0) {\n            revert InvalidRequiredApprovals();\n        }\n        if (newRequiredApprovals > newOwners.length) {\n            revert InvalidRequiredApprovals();\n        }\n\n        uint256 len;\n        if (_owners.length != 0) {\n            len = _owners.length;\n            for (uint256 i = 0; i < len; i++) {\n                _isOwner[_owners[i]] = false;\n            }\n        }\n\n        address owner;\n        len = newOwners.length;\n        for (uint256 i = 0; i < len; i++) {\n            owner = newOwners[i];\n\n            if (owner == address(0)) {\n                revert ZeroOwnerAddress();\n            }\n            if (_isOwner[owner]) {\n                revert DuplicateOwnerAddress();\n            }\n\n            _isOwner[owner] = true;\n        }\n\n        _owners = newOwners;\n        _requiredApprovals = newRequiredApprovals;\n\n        emit ConfigureOwners(newOwners, newRequiredApprovals);\n    }\n\n    /**\n     * @dev See {MultiSigWallet-configureExpirationTime}.\n     */\n    function _configureExpirationTime(uint120 newExpirationTime) internal {\n        _expirationTime = newExpirationTime;\n        emit ConfigureExpirationTime(newExpirationTime);\n    }\n\n    /**\n     * @dev See {MultiSigWallet-configureCooldownTime}.\n     */\n    function _configureCooldownTime(uint120 newCooldownTime) internal {\n        _cooldownTime = newCooldownTime;\n        emit ConfigureCooldownTime(newCooldownTime);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n}"
    }
  ]
}