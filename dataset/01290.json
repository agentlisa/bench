{
  "Title": "H-3: `Registry.sol` generate clone `Anchor.sol` never work. Profile owner cannot use their `Anchor` wallet",
  "Content": "# Issue H-3: `Registry.sol` generate clone `Anchor.sol` never work. Profile owner cannot use their `Anchor` wallet \n\nSource: https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/380 \n\n## Found by \n0xG0P1, 0xnirlin, Arz, KingNFT, VAD37, niluk, pinalikefruit, zach030\nUser create new profile through `Registry`. Each profile have its own unique `Anchor` clone contract to handle transactions as a wallet.\nNew clone `Anchor.sol` contract never work because `registry` address setup in `Anchor` constructor point to wrong address.\nThis broke `Anchor` contract. Profile owner cannot use their wallet `Anchor`. All funds send to this `Anchor` contract will be lost forever.\n\n## Vulnerability Detail\n\nAdd this test to `Registry.t.sol` test file to reproduce the issue.\n\n```js\n    function test_Audit_createProfile() public {\n        // create profile\n        bytes32 newProfileId = registry().createProfile(nonce, name, metadata, profile1_owner(), profile1_members());\n        Registry.Profile memory profile = registry().getProfileById(newProfileId);\n        Anchor _anchor = Anchor(payable(profile.anchor));\n\n        console.log(\"registry address: %s\", address(registry()));\n        console.log(\"anchor address: %s\", profile.anchor);\n        console.log(\"anchor.registry: %s\", address(_anchor.registry()));\n\n        emit log_named_bytes32(\"profile.id\", profile.id);\n        emit log_named_bytes32(\"anchor.profile.id\", _anchor.profileId());\n\n        Anchor _anchor_proxy = Anchor(payable(address( _anchor.registry())));\n        assertEq(address(registry()),address(_anchor.registry()) ,\"wrong anchor registry\");\n    }\n```\n\nWhat happen with `Anchor.sol` is it expect `msg.sender` is `Registry` contract. But in reality `msg.sender` is a proxy contract generated by Solady during `CREATE3` operation.\n\n```solidity\n    constructor(bytes32 _profileId) {\n        registry = Registry(msg.sender);//@audit H Registry address here is not Registry. msg.sender is a proxy contract. Create3 deploy 2 contract. one is proxy. other is actual bytecode.\n        profileId = _profileId;\n    }\n```\n\nThis can be seen with Solady comment for proxy contract. `msg.sender` above is middleman proxy contract. Not `Registry` contract. Solady generate 2 contract during CREATE3 operation. [One is proxy](https://github.com/Vectorized/solady/blob/62301983801a898fcfaad6fa492f21350d31b5aa/src/utils/CREATE3.sol#L34) contract. [Second is actual bytecode](https://github.com/Vectorized/solady/blob/62301983801a898fcfaad6fa492f21350d31b5aa/src/utils/CREATE3.sol#L72).\n\n## Impact\n\n`Anchor.execute()` function will not work because `registry` address point to empty proxy contract and not actual `Registry` so all call will revert.\n```solidity\nFile: allo-v2\\contracts\\core\\Anchor.sol\n70:     function execute(address _target, uint256 _value, bytes memory _data) external returns (bytes memory) {\n71:         // Check if the caller is the owner of the profile and revert if not\n72:         if (!registry.isOwnerOfProfile(profileId, msg.sender)) revert UNAUTHORIZED();\n```\nProfile owner cannot use their wallet `Anchor`. All funds send to this `Anchor` contract will be lost forever.\n## Code Snippet\n\n\nhttps://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/core/Registry.sol#L350\nhttps://github.com/sherlock-audit/2023-09-Gitcoin/blob/main/allo-v2/contracts/core/Anchor.sol#L55-L58\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nMove `msg.sender` into constructor parameter\n```solidity\nFile: allo-v2\\contracts\\core\\Registry.sol\n347:             bytes memory creationCode = abi.encodePacked(type(Anchor).creationCode, abi.encode(_profileId, address(this))); //@audit fix creation code\n348: \n349:             // Use CREATE3 to deploy the anchor contract\n350:             anchor = CREATE3.deploy(salt, creationCode, 0); \nFile: allo-v2\\contracts\\core\\Anchor.sol\n55:     constructor(bytes32 _profileId, address _registry) {\n56:         registry = Registry(_registry);\n57:         profileId = _profileId;\n58:     }\n```\n\n\n\n## Discussion\n\n**jkoppel**\n\nEscalate.\n\nThis should be a medium because the error would be detected upon the first use of Anchor, with minimal funds lost. The owner would simply redeploy the Anchor and Registry contracts and call updateRegistry on Allo.\n\n**sherlock-admin2**\n\n > Escalate.\n> \n> This should be a medium because the error would be detected upon the first use of Anchor, with minimal funds lost. The owner would simply redeploy the Anchor and Registry contracts and call updateRegistry on Allo.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**0xArz**\n\n@jkoppel This should be a high because execute is not payable and the users will have to send ether to the Anchor which will then get stuck and this doesnt have to be detected upon the first use, many users can create an Anchor and deposit ether and only later call execute. A normal user cant just detect this issue if the execute reverts, he might think that its an error on his side. We dont know how fast this will be fixed, how many users will deposit and how much but its def not minimal loss of funds here.  \n\n**jkoppel**\n\nI didn't say no funds would get stuck. I just said that little would.\n\n**AhmadDecoded**\n\nAssumption that little funds will be completely arbitrary.\n\n**neeksec**\n\nSuggest to keep high.\n\nAgree with @0xArz and @AhmadDecoded's comments. The lost amount is not foreseeable and could be high.\n\n**MLON33**\n\nhttps://github.com/allo-protocol/allo-v2/pull/348\n\n**Evert0x**\n\nPlanning to reject escalation and keep issue state as is.\n\n**Evert0x**\n\nResult:\nHigh\nHas Duplicates\n\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [jkoppel](https://github.com/sherlock-audit/2023-09-Gitcoin-judging/issues/380/#issuecomment-1762884703): rejected\n\n**jack-the-pug**\n\nFixed.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/109",
  "Code": [
    {
      "filename": "src/utils/CREATE3.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Deploy to deterministic addresses without an initcode factor.\n/// @author Solady (https://github.com/vectorized/solmady/blob/main/src/utils/CREATE3.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/CREATE3.sol)\n/// @author Modified from 0xSequence (https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol)\nlibrary CREATE3 {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        CUSTOM ERRORS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Unable to deploy the contract.\n    error DeploymentFailed();\n\n    /// @dev Unable to initialize the contract.\n    error InitializationFailed();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      BYTECODE CONSTANTS                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * -------------------------------------------------------------------+\n     * Opcode      | Mnemonic         | Stack        | Memory             |\n     * -------------------------------------------------------------------|\n     * 36          | CALLDATASIZE     | cds          |                    |\n     * 3d          | RETURNDATASIZE   | 0 cds        |                    |\n     * 3d          | RETURNDATASIZE   | 0 0 cds      |                    |\n     * 37          | CALLDATACOPY     |              | [0..cds): calldata |\n     * 36          | CALLDATASIZE     | cds          | [0..cds): calldata |\n     * 3d          | RETURNDATASIZE   | 0 cds        | [0..cds): calldata |\n     * 34          | CALLVALUE        | value 0 cds  | [0..cds): calldata |\n     * f0          | CREATE           | newContract  | [0..cds): calldata |\n     * -------------------------------------------------------------------|\n     * Opcode      | Mnemonic         | Stack        | Memory             |\n     * -------------------------------------------------------------------|\n     * 67 bytecode | PUSH8 bytecode   | bytecode     |                    |\n     * 3d          | RETURNDATASIZE   | 0 bytecode   |                    |\n     * 52          | MSTORE           |              | [0..8): bytecode   |\n     * 60 0x08     | PUSH1 0x08       | 0x08         | [0..8): bytecode   |\n     * 60 0x18     | PUSH1 0x18       | 0x18 0x08    | [0..8): bytecode   |\n     * f3          | RETURN           |              | [0..8): bytecode   |\n     * -------------------------------------------------------------------+\n     */\n\n    /// @dev The proxy bytecode.\n    uint256 private constant _PROXY_BYTECODE = 0x67363d3d37363d34f03d5260086018f3;\n\n    /// @dev Hash of the `_PROXY_BYTECODE`.\n    /// Equivalent to `keccak256(abi.encodePacked(hex\"67363d3d37363d34f03d5260086018f3\"))`.\n    bytes32 private constant _PROXY_BYTECODE_HASH =\n        0x21c35dbe1b344a2488cf3321d6ce542f8e9f305544ff09e4993a62319a497c1f;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      CREATE3 OPERATIONS                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Deploys `creationCode` deterministically with a `salt`.\n    /// The deployed contract is funded with `value` (in wei) ETH.\n    /// Returns the deterministic address of the deployed contract,\n    /// which solely depends on `salt`.\n    function deploy(bytes32 salt, bytes memory creationCode, uint256 value)\n        internal\n        returns (address deployed)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Store the `_PROXY_BYTECODE` into scratch space.\n            mstore(0x00, _PROXY_BYTECODE)\n            // Deploy a new contract with our pre-made bytecode via CREATE2.\n            let proxy := create2(0, 0x10, 0x10, salt)\n\n            // If the result of `create2` is the zero address, revert.\n            if iszero(proxy) {\n                // Store the function selector of `DeploymentFailed()`.\n                mstore(0x00, 0x30116425)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // Store the proxy's address.\n            mstore(0x14, proxy)\n            // 0xd6 = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x01).\n            // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex).\n            mstore(0x00, 0xd694)\n            // Nonce of the proxy contract (1).\n            mstore8(0x34, 0x01)\n\n            deployed := keccak256(0x1e, 0x17)\n\n            // If the `call` fails, revert.\n            if iszero(\n                call(\n                    gas(), // Gas remaining.\n                    proxy, // Proxy's address.\n                    value, // Ether value.\n                    add(creationCode, 0x20), // Start of `creationCode`.\n                    mload(creationCode), // Length of `creationCode`.\n                    0x00, // Offset of output.\n                    0x00 // Length of output.\n                )\n            ) {\n                // Store the function selector of `InitializationFailed()`.\n                mstore(0x00, 0x19b991a8)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // If the code size of `deployed` is zero, revert.\n            if iszero(extcodesize(deployed)) {\n                // Store the function selector of `InitializationFailed()`.\n                mstore(0x00, 0x19b991a8)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Returns the deterministic address for `salt`.\n    function getDeployed(bytes32 salt) internal view returns (address deployed) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cache the free memory pointer.\n            let m := mload(0x40)\n            // Store `address(this)`.\n            mstore(0x00, address())\n            // Store the prefix.\n            mstore8(0x0b, 0xff)\n            // Store the salt.\n            mstore(0x20, salt)\n            // Store the bytecode hash.\n            mstore(0x40, _PROXY_BYTECODE_HASH)\n\n            // Store the proxy's address.\n            mstore(0x14, keccak256(0x0b, 0x55))\n            // Restore the free memory pointer.\n            mstore(0x40, m)\n            // 0xd6 = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x01).\n            // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex).\n            mstore(0x00, 0xd694)\n            // Nonce of the proxy contract (1).\n            mstore8(0x34, 0x01)\n\n            deployed := keccak256(0x1e, 0x17)\n        }\n    }\n}"
    },
    {
      "filename": "allo-v2/contracts/core/Registry.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\n// External Libraries\nimport {AccessControl} from \"openzeppelin-contracts/contracts/access/AccessControl.sol\";\nimport \"openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\";\nimport {CREATE3} from \"solady/src/utils/CREATE3.sol\";\nimport {ERC20} from \"solady/src/tokens/ERC20.sol\";\n// Interfaces\nimport \"./interfaces/IRegistry.sol\";\n// Internal Libraries\nimport {Anchor} from \"./Anchor.sol\";\nimport {Errors} from \"./libraries/Errors.sol\";\nimport {Metadata} from \"./libraries/Metadata.sol\";\nimport \"./libraries/Native.sol\";\nimport \"./libraries/Transfer.sol\";\n\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⢿⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⡟⠘⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⣀⣴⣾⣿⣿⣿⣿⣾⠻⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⡿⠀⠀⠸⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⢀⣠⣴⣴⣶⣶⣶⣦⣦⣀⡀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⣿⡿⠃⠀⠙⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠁⠀⠀⠀⢻⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⡀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠘⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⠃⠀⠀⠀⠀⠈⢿⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⣰⣿⣿⣿⡿⠋⠁⠀⠀⠈⠘⠹⣿⣿⣿⣿⣆⠀⠀⠀\n// ⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡀⠀⠀\n// ⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣟⠀⡀⢀⠀⡀⢀⠀⡀⢈⢿⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⡇⠀⠀\n// ⠀⠀⣠⣿⣿⣿⣿⣿⣿⡿⠋⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⡿⢿⠿⠿⠿⠿⠿⠿⠿⠿⠿⢿⣿⣿⣿⣷⡀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠸⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠂⠀⠀\n// ⠀⠀⠙⠛⠿⠻⠻⠛⠉⠀⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣧⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⢻⣿⣿⣿⣷⣀⢀⠀⠀⠀⡀⣰⣾⣿⣿⣿⠏⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣧⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠹⢿⣿⣿⣿⣿⣾⣾⣷⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠙⠋⠛⠙⠋⠛⠙⠋⠛⠙⠋⠃⠀⠀⠀⠀⠀⠀⠀⠀⠠⠿⠻⠟⠿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⠟⠿⠟⠿⠆⠀⠸⠿⠿⠟⠯⠀⠀⠀⠸⠿⠿⠿⠏⠀⠀⠀⠀⠀⠈⠉⠻⠻⡿⣿⢿⡿⡿⠿⠛⠁⠀⠀⠀⠀⠀⠀\n//                    allo.gitcoin.co\n\n/// @title Registry Contract\n/// @author @thelostone-mc <aditya@gitcoin.co>, @0xKurt <kurt@gitcoin.co>, @codenamejason <jason@gitcoin.co>, @0xZakk <zakk@gitcoin.co>, @nfrgosselin <nate@gitcoin.co>\n/// @notice Registry contract for creating and managing profiles\n/// @dev This contract is used to create and manage profiles for the Allo protocol\n///      It is also used to deploy the anchor contract for each profile which acts as a proxy\n///      for the profile and is used to receive funds and execute transactions on behalf of the profile\n///      The Registry is also used to add and remove members from a profile and update the profile 'Metadata'\ncontract Registry is IRegistry, Native, AccessControl, Transfer, Initializable, Errors {\n    /// ==========================\n    /// === Storage Variables ====\n    /// ==========================\n\n    /// @notice This maps the anchor address to the profile ID\n    /// @dev anchor -> Profile.id\n    mapping(address => bytes32) public anchorToProfileId;\n\n    /// @notice This maps the profile ID to the profile details\n    /// @dev Profile.id -> Profile\n    mapping(bytes32 => Profile) public profilesById;\n\n    /// @notice This maps the profile ID to the pending owner\n    /// @dev Profile.id -> pending owner\n    mapping(bytes32 => address) public profileIdToPendingOwner;\n\n    /// @notice Allo Owner Role for fund recovery\n    bytes32 public constant ALLO_OWNER = keccak256(\"ALLO_OWNER\");\n\n    /// ====================================\n    /// =========== Modifier ===============\n    /// ====================================\n\n    /// @notice Checks if the caller is the profile owner\n    /// @dev Reverts `UNAUTHORIZED()` if the caller is not the profile owner\n    /// @param _profileId The ID of the profile\n    modifier onlyProfileOwner(bytes32 _profileId) {\n        _checkOnlyProfileOwner(_profileId);\n        _;\n    }\n\n    // ====================================\n    // =========== Initializer =============\n    // ====================================\n\n    /// @notice Initializes the contract after an upgrade\n    /// @dev During upgrade -> a higher version should be passed to reinitializer. Reverts if the '_owner' is the 'address(0)'\n    /// @param _owner The owner of the contract\n    function initialize(address _owner) external reinitializer(1) {\n        // Make sure the owner is not 'address(0)'\n        if (_owner == address(0)) revert ZERO_ADDRESS();\n\n        // Grant the role to the owner\n        _grantRole(ALLO_OWNER, _owner);\n    }\n\n    /// ====================================\n    /// ==== External/Public Functions =====\n    /// ====================================\n\n    /// @notice Retrieve profile by profileId\n    /// @dev Used when you have the 'profileId' and want to retrieve the profile\n    /// @param _profileId The ID of the profile\n    /// @return The Profile details for the `_profileId`\n    function getProfileById(bytes32 _profileId) external view returns (Profile memory) {\n        return profilesById[_profileId];\n    }\n\n    /// @notice Retrieve profile by anchor\n    /// @dev Used when you have the 'anchor' address and want to retrieve the profile\n    /// @param _anchor The anchor of the profile\n    /// @return Profile details for the `_anchor`\n    function getProfileByAnchor(address _anchor) external view returns (Profile memory) {\n        bytes32 profileId = anchorToProfileId[_anchor];\n        return profilesById[profileId];\n    }\n\n    /// @notice Creates a new profile\n    /// @dev This will also generate the 'profileId' and 'anchor' address, emits a 'ProfileCreated()' event\n    /// Note: The 'nonce' is used to generate the 'profileId' and should be unique for each profile\n    /// Note: The 'name' and 'profileId' are used to generate the 'anchor' address\n    /// @param _nonce Nonce used to generate profileId. Can be any integer, but should be unique\n    ///               for each profile.\n    /// @param _name The name of the profile\n    /// @param _metadata The metadata of the profile\n    /// @param _owner The owner of the profile\n    /// @param _members The members of the profile\n    /// @return The ID for the created profile\n    function createProfile(\n        uint256 _nonce,\n        string memory _name,\n        Metadata memory _metadata,\n        address _owner,\n        address[] memory _members\n    ) external returns (bytes32) {\n        // Generate a profile ID using a nonce and the msg.sender\n        bytes32 profileId = _generateProfileId(_nonce);\n\n        // Make sure the nonce is available\n        if (profilesById[profileId].anchor != address(0)) revert NONCE_NOT_AVAILABLE();\n\n        // Make sure the owner is not the zero address\n        if (_owner == address(0)) revert ZERO_ADDRESS();\n\n        // Create a new Profile instance, also generates the anchor address\n        Profile memory profile = Profile({\n            id: profileId,\n            nonce: _nonce,\n            name: _name,\n            metadata: _metadata,\n            owner: _owner,\n            anchor: _generateAnchor(profileId, _name)\n        });\n\n        profilesById[profileId] = profile;\n        anchorToProfileId[profile.anchor] = profileId;\n\n        // Assign roles for the profile members\n        uint256 memberLength = _members.length;\n        for (uint256 i; i < memberLength;) {\n            address member = _members[i];\n\n            // Will revert if any of the addresses are a zero address\n            if (member == address(0)) revert ZERO_ADDRESS();\n\n            // Grant the role to the member and emit the event for each member\n            _grantRole(profileId, member);\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Emit the event that the profile was created\n        emit ProfileCreated(profileId, profile.nonce, profile.name, profile.metadata, profile.owner, profile.anchor);\n\n        // Return the profile ID\n        return profileId;\n    }\n\n    /// @notice Updates the name of the profile and generates new anchor.\n    ///         Emits a 'ProfileNameUpdated()' event.\n    /// @dev Use caution when updating your profile name as it will generate a new anchor address. You can always update the name\n    ///      back to the original name to get the original anchor address. 'msg.sender' must be the owner of the profile.\n    /// @param _profileId The profileId of the profile\n    /// @param _name The new name of the profile\n    /// @return anchor The new anchor\n    function updateProfileName(bytes32 _profileId, string memory _name)\n        external\n        onlyProfileOwner(_profileId)\n        returns (address anchor)\n    {\n        // Generate a new anchor address\n        anchor = _generateAnchor(_profileId, _name);\n\n        // Get the profile using the profileId from the mapping\n        Profile storage profile = profilesById[_profileId];\n\n        // Set the new name\n        profile.name = _name;\n\n        // Remove old anchor\n        anchorToProfileId[profile.anchor] = bytes32(0);\n\n        // Set the new anchor\n        profile.anchor = anchor;\n        anchorToProfileId[anchor] = _profileId;\n\n        // Emit the event that the name was updated with the new data\n        emit ProfileNameUpdated(_profileId, _name, anchor);\n\n        // Return the new anchor\n        return anchor;\n    }\n\n    /// @notice Update the 'Metadata' of the profile. Emits a 'ProfileMetadataUpdated()' event.\n    /// @dev 'msg.sender' must be the owner of the profile.\n    /// @param _profileId The ID of the profile\n    /// @param _metadata The new 'Metadata' of the profile\n    function updateProfileMetadata(bytes32 _profileId, Metadata memory _metadata)\n        external\n        onlyProfileOwner(_profileId)\n    {\n        // Get the profile using the 'profileId' from the mapping and update the 'Metadata' value\n        profilesById[_profileId].metadata = _metadata;\n\n        // Emit the event that the 'Metadata' was updated\n        emit ProfileMetadataUpdated(_profileId, _metadata);\n    }\n\n    /// @notice Checks if the address is an owner or member of the profile\n    /// @param _profileId The ID of the profile\n    /// @param _account The address to check\n    /// @return 'true' if the address is an owner or member of the profile, otherwise 'false'\n    function isOwnerOrMemberOfProfile(bytes32 _profileId, address _account) external view returns (bool) {\n        return _isOwnerOfProfile(_profileId, _account) || _isMemberOfProfile(_profileId, _account);\n    }\n\n    /// @notice Checks if the given address is an owner of the profile\n    /// @param _profileId The ID of the profile\n    /// @param _owner The address to check\n    /// @return 'true' if the address is an owner of the profile, otherwise 'false'\n    function isOwnerOfProfile(bytes32 _profileId, address _owner) external view returns (bool) {\n        return _isOwnerOfProfile(_profileId, _owner);\n    }\n\n    /// @notice Checks if the given address is a member of the profile\n    /// @param _profileId The ID of the profile\n    /// @param _member The address to check\n    /// @return 'true' if the address is a member of the profile, otherwise 'false'\n    function isMemberOfProfile(bytes32 _profileId, address _member) external view returns (bool) {\n        return _isMemberOfProfile(_profileId, _member);\n    }\n\n    /// @notice Updates the pending owner of the profile. Emits a 'ProfilePendingOwnership()' event.\n    /// @dev 'msg.sender' must be the owner of the profile. [1]*This is step one of two when transferring ownership.\n    /// @param _profileId The ID of the profile\n    /// @param _pendingOwner The new pending owner\n    function updateProfilePendingOwner(bytes32 _profileId, address _pendingOwner)\n        external\n        onlyProfileOwner(_profileId)\n    {\n        // Set the pending owner to the profile\n        profileIdToPendingOwner[_profileId] = _pendingOwner;\n\n        // Emit the event that the pending owner was updated\n        emit ProfilePendingOwnerUpdated(_profileId, _pendingOwner);\n    }\n\n    /// @notice Transfers the ownership of the profile to the pending owner and Emits a 'ProfileOwnerUdpated()' event.\n    /// @dev 'msg.sender' must be the pending owner of the profile. [2]*This is step two of two when transferring ownership.\n    /// @param _profileId The ID of the profile\n    function acceptProfileOwnership(bytes32 _profileId) external {\n        // Get the profile from the mapping\n        Profile storage profile = profilesById[_profileId];\n\n        // Get the pending owner from the mapping that was set when the owner was updated\n        address newOwner = profileIdToPendingOwner[_profileId];\n\n        // Revert if the 'msg.sender' is not the pending owner\n        if (msg.sender != newOwner) revert NOT_PENDING_OWNER();\n\n        // Set the new owner and delete the pending owner from the mapping\n        profile.owner = newOwner;\n        delete profileIdToPendingOwner[_profileId];\n\n        // Emit the event that the owner was accepted and updated\n        emit ProfileOwnerUpdated(_profileId, profile.owner);\n    }\n\n    /// @notice Adds members to the profile\n    /// @dev 'msg.sender' must be the owner of the profile.\n    /// @param _profileId The ID of the profile\n    /// @param _members The members to add\n    function addMembers(bytes32 _profileId, address[] memory _members) external onlyProfileOwner(_profileId) {\n        uint256 memberLength = _members.length;\n\n        // Loop through the members and add them to the profile by granting the role\n        for (uint256 i; i < memberLength;) {\n            address member = _members[i];\n\n            // Will revert if any of the addresses are a zero address\n            if (member == address(0)) revert ZERO_ADDRESS();\n\n            // Grant the role to the member and emit the event for each member\n            _grantRole(_profileId, member);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Removes members from the profile\n    /// @dev 'msg.sender' must be the pending owner of the profile.\n    /// @param _profileId The ID of the profile\n    /// @param _members The members to remove\n    function removeMembers(bytes32 _profileId, address[] memory _members) external onlyProfileOwner(_profileId) {\n        uint256 memberLength = _members.length;\n\n        // Loop through the members and remove them from the profile by revoking the role\n        for (uint256 i; i < memberLength;) {\n            // Revoke the role from the member and emit the event for each member\n            _revokeRole(_profileId, _members[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// ====================================\n    /// ======== Internal Functions ========\n    /// ====================================\n\n    /// @notice Checks if the caller is the owner of the profile\n    /// @dev Internal function used by modifier 'onlyProfileOwner'\n    /// @param _profileId The ID of the profile\n    function _checkOnlyProfileOwner(bytes32 _profileId) internal view {\n        if (!_isOwnerOfProfile(_profileId, msg.sender)) revert UNAUTHORIZED();\n    }\n\n    /// @notice Generates and deploys the anchor for the given 'profileId' and name\n    /// @dev Internal function used by 'createProfile()' and 'updateProfileName()' to create and anchor.\n    /// @param _profileId The ID of the profile\n    /// @param _name The name of the profile\n    /// @return anchor The address of the deployed anchor contract\n    function _generateAnchor(bytes32 _profileId, string memory _name) internal returns (address anchor) {\n        bytes32 salt = keccak256(abi.encodePacked(_profileId, _name));\n\n        address preCalculatedAddress = CREATE3.getDeployed(salt);\n\n        // check if the contract already exists and if the profileId matches\n        if (preCalculatedAddress.code.length > 0) {\n            if (Anchor(payable(preCalculatedAddress)).profileId() != _profileId) revert ANCHOR_ERROR();\n\n            anchor = preCalculatedAddress;\n        } else {\n            // check if the contract has already been deployed by checking code size of address\n            bytes memory creationCode = abi.encodePacked(type(Anchor).creationCode, abi.encode(_profileId));\n\n            // Use CREATE3 to deploy the anchor contract\n            anchor = CREATE3.deploy(salt, creationCode, 0);\n        }\n    }\n\n    /// @notice Generates the 'profileId' based on msg.sender and nonce\n    /// @dev Internal function used by 'createProfile()' to generate profileId.\n    /// @param _nonce Nonce provided by the caller to generate 'profileId'\n    /// @return 'profileId' The ID of the profile\n    function _generateProfileId(uint256 _nonce) internal view returns (bytes32) {\n        return keccak256(abi.encodePacked(_nonce, msg.sender));\n    }\n\n    /// @notice Checks if an address is the owner of the profile\n    /// @dev Internal function used to determine if an address is the profile owner\n    /// @param _profileId The 'profileId' of the profile\n    /// @param _owner The address to check\n    /// @return 'true' if the address is an owner of the profile, otherwise 'false'\n    function _isOwnerOfProfile(bytes32 _profileId, address _owner) internal view returns (bool) {\n        return profilesById[_profileId].owner == _owner;\n    }\n\n    /// @notice Checks if an address is a member of the profile\n    /// @dev Internal function used to determine if an address is a member of the profile\n    /// @param _profileId The 'profileId' of the profile\n    /// @param _member The address to check\n    /// @return 'true' if the address is a member of the profile, otherwise 'false'\n    function _isMemberOfProfile(bytes32 _profileId, address _member) internal view returns (bool) {\n        return hasRole(_profileId, _member);\n    }\n\n    /// @notice Transfers any fund balance in Allo to the recipient\n    /// @dev 'msg.sender' must be the Allo owner\n    /// @param _token The address of the token to transfer\n    /// @param _recipient The address of the recipient\n    function recoverFunds(address _token, address _recipient) external onlyRole(ALLO_OWNER) {\n        if (_recipient == address(0)) revert ZERO_ADDRESS();\n\n        uint256 amount = _token == NATIVE ? address(this).balance : ERC20(_token).balanceOf(address(this));\n        _transferAmount(_token, _recipient, amount);\n    }\n}"
    },
    {
      "filename": "allo-v2/contracts/core/Anchor.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n\n// Core Contracts\nimport {Registry} from \"./Registry.sol\";\n\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⢿⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⡟⠘⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⣀⣴⣾⣿⣿⣿⣿⣾⠻⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⡿⠀⠀⠸⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠀⠀⢀⣠⣴⣴⣶⣶⣶⣦⣦⣀⡀⠀⠀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⣿⡿⠃⠀⠙⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠁⠀⠀⠀⢻⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⡀⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠘⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⠃⠀⠀⠀⠀⠈⢿⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⣰⣿⣿⣿⡿⠋⠁⠀⠀⠈⠘⠹⣿⣿⣿⣿⣆⠀⠀⠀\n// ⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⡀⠀⠀\n// ⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣟⠀⡀⢀⠀⡀⢀⠀⡀⢈⢿⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⡇⠀⠀\n// ⠀⠀⣠⣿⣿⣿⣿⣿⣿⡿⠋⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⡿⢿⠿⠿⠿⠿⠿⠿⠿⠿⠿⢿⣿⣿⣿⣷⡀⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠸⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⠂⠀⠀\n// ⠀⠀⠙⠛⠿⠻⠻⠛⠉⠀⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣧⠀⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⢻⣿⣿⣿⣷⣀⢀⠀⠀⠀⡀⣰⣾⣿⣿⣿⠏⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣧⠀⠀⢸⣿⣿⣿⣗⠀⠀⠀⢸⣿⣿⣿⡯⠀⠀⠀⠀⠹⢿⣿⣿⣿⣿⣾⣾⣷⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀\n// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠙⠋⠛⠙⠋⠛⠙⠋⠛⠙⠋⠃⠀⠀⠀⠀⠀⠀⠀⠀⠠⠿⠻⠟⠿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⠟⠿⠟⠿⠆⠀⠸⠿⠿⠟⠯⠀⠀⠀⠸⠿⠿⠿⠏⠀⠀⠀⠀⠀⠈⠉⠻⠻⡿⣿⢿⡿⡿⠿⠛⠁⠀⠀⠀⠀⠀⠀\n//                    allo.gitcoin.co\n\n/// @title Anchor contract\n/// @author @thelostone-mc <aditya@gitcoin.co>, @0xKurt <kurt@gitcoin.co>, @codenamejason <jason@gitcoin.co>, @0xZakk <zakk@gitcoin.co>, @nfrgosselin <nate@gitcoin.co>\n/// @notice Anchors are associated with profiles and are accessible exclusively by the profile owner. This contract ensures secure\n///         and authorized interaction with external addresses, enhancing the capabilities of profiles and enabling controlled\n///         execution of operations. The contract leverages the `Registry` contract for ownership verification and access control.\ncontract Anchor {\n    /// ==========================\n    /// === Storage Variables ====\n    /// ==========================\n\n    /// @notice The registry contract on any given network/chain\n    Registry public immutable registry;\n\n    /// @notice The profileId of the allowed profile to execute calls\n    bytes32 public immutable profileId;\n\n    /// ==========================\n    /// ======== Errors ==========\n    /// ==========================\n\n    /// @notice Throws when the caller is not the owner of the profile\n    error UNAUTHORIZED();\n\n    /// @notice Throws when the call to the target address fails\n    error CALL_FAILED();\n\n    /// ==========================\n    /// ======= Constructor ======\n    /// ==========================\n\n    /// @notice Constructor\n    /// @dev We create an instance of the 'Registry' contract using the 'msg.sender' and set the profileId.\n    /// @param _profileId The ID of the allowed profile to execute calls\n    constructor(bytes32 _profileId) {\n        registry = Registry(msg.sender);\n        profileId = _profileId;\n    }\n\n    /// ==========================\n    /// ======== External ========\n    /// ==========================\n\n    /// @notice Execute a call to a target address\n    /// @dev 'msg.sender' must be profile owner\n    /// @param _target The target address to call\n    /// @param _value The amount of native token to send\n    /// @param _data The data to send to the target address\n    /// @return Data returned from the target address\n    function execute(address _target, uint256 _value, bytes memory _data) external returns (bytes memory) {\n        // Check if the caller is the owner of the profile and revert if not\n        if (!registry.isOwnerOfProfile(profileId, msg.sender)) revert UNAUTHORIZED();\n\n        // Check if the target address is the zero address and revert if it is\n        if (_target == address(0)) revert CALL_FAILED();\n\n        // Call the target address and return the data\n        (bool success, bytes memory data) = _target.call{value: _value}(_data);\n\n        // Check if the call was successful and revert if not\n        if (!success) revert CALL_FAILED();\n\n        return data;\n    }\n\n    /// @notice This contract should be able to receive native token\n    receive() external payable {}\n}"
    }
  ]
}