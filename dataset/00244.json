{
  "Title": "Data With Id 1 Cannot Be Retrieved From Mantle DA",
  "Content": "The [`RetrievalFramesFromDa`](https://github.com/mantlenetworkio/mantle-v2/blob/e29d360904db5e5ec81888885f7b7250f8255895/op-node/rollup/da/datastore.go#L119-L171) function of [OP-Node](https://github.com/mantlenetworkio/mantle-v2/blob/e29d360904db5e5ec81888885f7b7250f8255895/op-node/rollup/da/datastore.go) implements the logic for retrieving frames from Mantle DA. It requires a `dataStoreId` value, which undergoes a check to verify if [it is equal to or smaller than 0](https://github.com/mantlenetworkio/mantle-v2/blob/e29d360904db5e5ec81888885f7b7250f8255895/op-node/rollup/da/datastore.go#L127-L130). As the `calldata_source` calls `RetrievalFramesFromDa` with the [`dataStoreId` decreased by 1](https://github.com/mantlenetworkio/mantle-v2/blob/e29d360904db5e5ec81888885f7b7250f8255895/op-node/rollup/derive/calldata_source.go#L222), attempting to retrieve data from Mantle DA with a `dataStoreId` equal to 1 becomes impossible.\n\n\nConsider removing [the check](https://github.com/mantlenetworkio/mantle-v2/blob/e29d360904db5e5ec81888885f7b7250f8255895/op-node/rollup/da/datastore.go#L127-L130) from the `RetrievalFramesFromDa` function to permit the processing of a `dataStoreId` with a value of 0. In addition, since the `dataStoreId` is of type `uint32` and so cannot be smaller than 0, the check becomes unnecessary.\n\n\n***Update:** Resolved in [pull request #117](https://github.com/mantlenetworkio/mantle-v2/pull/117).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "op-node/rollup/da/datastore.go",
      "content": "package da\n\nimport (\n\t\"context\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"github.com/pkg/errors\"\n\t\"github.com/shurcooL/graphql\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\n\t\"github.com/Layr-Labs/datalayr/common/graphView\"\n\tpb \"github.com/Layr-Labs/datalayr/common/interfaces/interfaceRetrieverServer\"\n\n\t\"github.com/ethereum/go-ethereum/common/hexutil\"\n\t\"github.com/ethereum/go-ethereum/log\"\n)\n\nconst (\n\tPOLLING_INTERVAL     = 1 * time.Second\n\tMAX_RPC_MESSAGE_SIZE = 1024 * 1024 * 300\n)\n\ntype MantleDataStoreConfig struct {\n\tRetrieverSocket          string\n\tRetrieverTimeout         time.Duration\n\tGraphProvider            string\n\tDataStorePollingDuration time.Duration\n\tMantleDaIndexerSocket    string\n\tMantleDAIndexerEnable    bool\n}\n\ntype MantleDataStore struct {\n\tCtx           context.Context\n\tCfg           *MantleDataStoreConfig\n\tGraphClient   *graphView.GraphClient\n\tGraphqlClient *graphql.Client\n}\n\nfunc NewMantleDataStore(ctx context.Context, cfg *MantleDataStoreConfig) (*MantleDataStore, error) {\n\tgraphClient := graphView.NewGraphClient(cfg.GraphProvider, nil)\n\tgraphqlClient := graphql.NewClient(graphClient.GetEndpoint(), nil)\n\tmDatastore := &MantleDataStore{\n\t\tCtx:           ctx,\n\t\tCfg:           cfg,\n\t\tGraphClient:   graphClient,\n\t\tGraphqlClient: graphqlClient,\n\t}\n\treturn mDatastore, nil\n}\n\nfunc (mda *MantleDataStore) getDataStoreById(dataStoreId uint32) (*graphView.DataStore, error) {\n\tvar query struct {\n\t\tDataStore graphView.DataStoreGql `graphql:\"dataStore(id: $storeId)\"`\n\t}\n\tvariables := map[string]interface{}{\n\t\t\"storeId\": graphql.String(strconv.FormatUint(uint64(dataStoreId), 10)),\n\t}\n\terr := mda.GraphqlClient.Query(mda.Ctx, &query, variables)\n\tif err != nil {\n\t\tlog.Error(\"Query subgraph fail\", \"err\", err)\n\t\treturn nil, err\n\t}\n\tlog.Debug(\"Query dataStore success\",\n\t\t\"DurationDataStoreId\", query.DataStore.DurationDataStoreId,\n\t\t\"Confirmed\", query.DataStore.Confirmed,\n\t\t\"ConfirmTxHash\", query.DataStore.ConfirmTxHash)\n\tdataStore, err := query.DataStore.Convert()\n\tif err != nil {\n\t\tlog.Warn(\"DataStoreGql convert to DataStore fail\", \"err\", err)\n\t\treturn nil, err\n\t}\n\treturn dataStore, nil\n}\n\nfunc (mda *MantleDataStore) getFramesByDataStoreId(dataStoreId uint32) ([]byte, error) {\n\tconn, err := grpc.Dial(mda.Cfg.RetrieverSocket, grpc.WithTransportCredentials(insecure.NewCredentials()))\n\tif err != nil {\n\t\tlog.Error(\"Connect to da retriever fail\", \"err\", err)\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\tclient := pb.NewDataRetrievalClient(conn)\n\topt := grpc.MaxCallRecvMsgSize(MAX_RPC_MESSAGE_SIZE)\n\trequest := &pb.FramesAndDataRequest{\n\t\tDataStoreId: dataStoreId,\n\t}\n\treply, err := client.RetrieveFramesAndData(mda.Ctx, request, opt)\n\tif err != nil {\n\t\tlog.Error(\"Retrieve frames and data fail\", \"err\", err)\n\t\treturn nil, err\n\t}\n\tlog.Debug(\"Get reply data success\", \"replyLength\", len(reply.GetData()))\n\treturn reply.GetData(), nil\n}\n\nfunc (mda *MantleDataStore) getFramesFromIndexerByDataStoreId(dataStoreId uint32) ([]byte, error) {\n\tconn, err := grpc.Dial(mda.Cfg.MantleDaIndexerSocket, grpc.WithTransportCredentials(insecure.NewCredentials()))\n\tif err != nil {\n\t\tlog.Error(\"Connect to mantle da index retriever fail\", \"err\", err)\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\tclient := pb.NewDataRetrievalClient(conn)\n\topt := grpc.MaxCallRecvMsgSize(MAX_RPC_MESSAGE_SIZE)\n\trequest := &pb.FramesAndDataRequest{\n\t\tDataStoreId: dataStoreId,\n\t}\n\treply, err := client.RetrieveFramesAndData(mda.Ctx, request, opt)\n\tif err != nil {\n\t\tlog.Error(\"Retrieve frames and data fail\", \"err\", err)\n\t\treturn nil, err\n\t}\n\tlog.Debug(\"Get reply data from mantle da success\", \"replyLength\", len(reply.GetData()))\n\treturn reply.GetData(), nil\n}\n\nfunc (mda *MantleDataStore) RetrievalFramesFromDa(dataStoreId uint32) ([]byte, error) {\n\tpollingTimeout := time.NewTimer(mda.Cfg.DataStorePollingDuration)\n\tdefer pollingTimeout.Stop()\n\tintervalTicker := time.NewTicker(POLLING_INTERVAL)\n\tdefer intervalTicker.Stop()\n\tfor {\n\t\tselect {\n\t\tcase <-intervalTicker.C:\n\t\t\tif dataStoreId <= 0 {\n\t\t\t\tlog.Error(\"DataStoreId less than zero\", \"dataStoreId\", dataStoreId)\n\t\t\t\treturn nil, errors.New(\"dataStoreId less than 0\")\n\t\t\t}\n\t\t\tdataStore, err := mda.getDataStoreById(dataStoreId)\n\t\t\tif err != nil {\n\t\t\t\tlog.Warn(\"Get datastore by id fail\", \"err\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tlog.Info(\"Get dataStore success\",\n\t\t\t\t\"DurationDataStoreId\", dataStore.DurationDataStoreId,\n\t\t\t\t\"Confirmed\", dataStore.Confirmed,\n\t\t\t\t\"ConfirmTxHash\", hexutil.Encode(dataStore.ConfirmTxHash[:]))\n\t\t\tif !dataStore.Confirmed {\n\t\t\t\tlog.Warn(\"This batch is not confirmed\")\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tvar frames []byte\n\t\t\tif mda.Cfg.MantleDAIndexerEnable { // from mantle da indexer\n\t\t\t\tlog.Info(\"sync block data from mantle da indexer\")\n\t\t\t\tframes, err = mda.getFramesFromIndexerByDataStoreId(dataStoreId)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Warn(\"Get frames from indexer fail\", \"err\", err)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t} else { // from mantle da retriever\n\t\t\t\tlog.Info(\"sync block data from mantle da retriever\")\n\t\t\t\tframes, err = mda.getFramesByDataStoreId(dataStoreId)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Warn(\"Get frames from mantle da retriever fail\", \"err\", err)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t\tif frames == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn frames, nil\n\t\tcase <-pollingTimeout.C:\n\t\t\treturn nil, errors.New(\"Get frame ticker exit\")\n\t\tcase err := <-mda.Ctx.Done():\n\t\t\tlog.Warn(\"Retrieval service shutting down\", \"err\", err)\n\t\t\treturn nil, errors.New(\"Retrieval service shutting down\")\n\t\t}\n\t}\n}"
    },
    {
      "filename": "op-node/rollup/da/datastore.go",
      "content": "package da\n\nimport (\n\t\"context\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"github.com/pkg/errors\"\n\t\"github.com/shurcooL/graphql\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\n\t\"github.com/Layr-Labs/datalayr/common/graphView\"\n\tpb \"github.com/Layr-Labs/datalayr/common/interfaces/interfaceRetrieverServer\"\n\n\t\"github.com/ethereum/go-ethereum/common/hexutil\"\n\t\"github.com/ethereum/go-ethereum/log\"\n)\n\nconst (\n\tPOLLING_INTERVAL     = 1 * time.Second\n\tMAX_RPC_MESSAGE_SIZE = 1024 * 1024 * 300\n)\n\ntype MantleDataStoreConfig struct {\n\tRetrieverSocket          string\n\tRetrieverTimeout         time.Duration\n\tGraphProvider            string\n\tDataStorePollingDuration time.Duration\n\tMantleDaIndexerSocket    string\n\tMantleDAIndexerEnable    bool\n}\n\ntype MantleDataStore struct {\n\tCtx           context.Context\n\tCfg           *MantleDataStoreConfig\n\tGraphClient   *graphView.GraphClient\n\tGraphqlClient *graphql.Client\n}\n\nfunc NewMantleDataStore(ctx context.Context, cfg *MantleDataStoreConfig) (*MantleDataStore, error) {\n\tgraphClient := graphView.NewGraphClient(cfg.GraphProvider, nil)\n\tgraphqlClient := graphql.NewClient(graphClient.GetEndpoint(), nil)\n\tmDatastore := &MantleDataStore{\n\t\tCtx:           ctx,\n\t\tCfg:           cfg,\n\t\tGraphClient:   graphClient,\n\t\tGraphqlClient: graphqlClient,\n\t}\n\treturn mDatastore, nil\n}\n\nfunc (mda *MantleDataStore) getDataStoreById(dataStoreId uint32) (*graphView.DataStore, error) {\n\tvar query struct {\n\t\tDataStore graphView.DataStoreGql `graphql:\"dataStore(id: $storeId)\"`\n\t}\n\tvariables := map[string]interface{}{\n\t\t\"storeId\": graphql.String(strconv.FormatUint(uint64(dataStoreId), 10)),\n\t}\n\terr := mda.GraphqlClient.Query(mda.Ctx, &query, variables)\n\tif err != nil {\n\t\tlog.Error(\"Query subgraph fail\", \"err\", err)\n\t\treturn nil, err\n\t}\n\tlog.Debug(\"Query dataStore success\",\n\t\t\"DurationDataStoreId\", query.DataStore.DurationDataStoreId,\n\t\t\"Confirmed\", query.DataStore.Confirmed,\n\t\t\"ConfirmTxHash\", query.DataStore.ConfirmTxHash)\n\tdataStore, err := query.DataStore.Convert()\n\tif err != nil {\n\t\tlog.Warn(\"DataStoreGql convert to DataStore fail\", \"err\", err)\n\t\treturn nil, err\n\t}\n\treturn dataStore, nil\n}\n\nfunc (mda *MantleDataStore) getFramesByDataStoreId(dataStoreId uint32) ([]byte, error) {\n\tconn, err := grpc.Dial(mda.Cfg.RetrieverSocket, grpc.WithTransportCredentials(insecure.NewCredentials()))\n\tif err != nil {\n\t\tlog.Error(\"Connect to da retriever fail\", \"err\", err)\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\tclient := pb.NewDataRetrievalClient(conn)\n\topt := grpc.MaxCallRecvMsgSize(MAX_RPC_MESSAGE_SIZE)\n\trequest := &pb.FramesAndDataRequest{\n\t\tDataStoreId: dataStoreId,\n\t}\n\treply, err := client.RetrieveFramesAndData(mda.Ctx, request, opt)\n\tif err != nil {\n\t\tlog.Error(\"Retrieve frames and data fail\", \"err\", err)\n\t\treturn nil, err\n\t}\n\tlog.Debug(\"Get reply data success\", \"replyLength\", len(reply.GetData()))\n\treturn reply.GetData(), nil\n}\n\nfunc (mda *MantleDataStore) getFramesFromIndexerByDataStoreId(dataStoreId uint32) ([]byte, error) {\n\tconn, err := grpc.Dial(mda.Cfg.MantleDaIndexerSocket, grpc.WithTransportCredentials(insecure.NewCredentials()))\n\tif err != nil {\n\t\tlog.Error(\"Connect to mantle da index retriever fail\", \"err\", err)\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\tclient := pb.NewDataRetrievalClient(conn)\n\topt := grpc.MaxCallRecvMsgSize(MAX_RPC_MESSAGE_SIZE)\n\trequest := &pb.FramesAndDataRequest{\n\t\tDataStoreId: dataStoreId,\n\t}\n\treply, err := client.RetrieveFramesAndData(mda.Ctx, request, opt)\n\tif err != nil {\n\t\tlog.Error(\"Retrieve frames and data fail\", \"err\", err)\n\t\treturn nil, err\n\t}\n\tlog.Debug(\"Get reply data from mantle da success\", \"replyLength\", len(reply.GetData()))\n\treturn reply.GetData(), nil\n}\n\nfunc (mda *MantleDataStore) RetrievalFramesFromDa(dataStoreId uint32) ([]byte, error) {\n\tpollingTimeout := time.NewTimer(mda.Cfg.DataStorePollingDuration)\n\tdefer pollingTimeout.Stop()\n\tintervalTicker := time.NewTicker(POLLING_INTERVAL)\n\tdefer intervalTicker.Stop()\n\tfor {\n\t\tselect {\n\t\tcase <-intervalTicker.C:\n\t\t\tif dataStoreId <= 0 {\n\t\t\t\tlog.Error(\"DataStoreId less than zero\", \"dataStoreId\", dataStoreId)\n\t\t\t\treturn nil, errors.New(\"dataStoreId less than 0\")\n\t\t\t}\n\t\t\tdataStore, err := mda.getDataStoreById(dataStoreId)\n\t\t\tif err != nil {\n\t\t\t\tlog.Warn(\"Get datastore by id fail\", \"err\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tlog.Info(\"Get dataStore success\",\n\t\t\t\t\"DurationDataStoreId\", dataStore.DurationDataStoreId,\n\t\t\t\t\"Confirmed\", dataStore.Confirmed,\n\t\t\t\t\"ConfirmTxHash\", hexutil.Encode(dataStore.ConfirmTxHash[:]))\n\t\t\tif !dataStore.Confirmed {\n\t\t\t\tlog.Warn(\"This batch is not confirmed\")\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tvar frames []byte\n\t\t\tif mda.Cfg.MantleDAIndexerEnable { // from mantle da indexer\n\t\t\t\tlog.Info(\"sync block data from mantle da indexer\")\n\t\t\t\tframes, err = mda.getFramesFromIndexerByDataStoreId(dataStoreId)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Warn(\"Get frames from indexer fail\", \"err\", err)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t} else { // from mantle da retriever\n\t\t\t\tlog.Info(\"sync block data from mantle da retriever\")\n\t\t\t\tframes, err = mda.getFramesByDataStoreId(dataStoreId)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Warn(\"Get frames from mantle da retriever fail\", \"err\", err)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t\tif frames == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn frames, nil\n\t\tcase <-pollingTimeout.C:\n\t\t\treturn nil, errors.New(\"Get frame ticker exit\")\n\t\tcase err := <-mda.Ctx.Done():\n\t\t\tlog.Warn(\"Retrieval service shutting down\", \"err\", err)\n\t\t\treturn nil, errors.New(\"Retrieval service shutting down\")\n\t\t}\n\t}\n}"
    }
  ]
}