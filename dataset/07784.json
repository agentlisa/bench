{
  "Title": "[G-05] There's no need to set default values for variables",
  "Content": "\nIf a variable is not set/initialized, the default value is assumed (0, `false`, 0x0 ... depending on the data type). You are simply wasting gas if you directly initialize it with its default value.\n\n**Proof of concept (*without optimizations*):**\n\n```javascript\npragma solidity 0.8.15;\n\ncontract TesterA {\nfunction testInit() public view returns (uint) { uint a = 0; return a; }\n}\n\ncontract TesterB {\nfunction testNoInit() public view returns (uint) { uint a; return a; }\n}\n```\n\nGas saving executing: **8 per entry**\n\n    TesterA.testInit:   21392\n    TesterB.testNoInit: 21384\n\n**Affected source code:**\n\n*   [L1EthBridge.sol:33](https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/ethereum/contracts/bridge/L1EthBridge.sol#L33)\n*   [L2ETHBridge.sol:28](https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/zksync/contracts/bridge/L2ETHBridge.sol#L28)\n\n### Total gas saved: **8 &ast; 2 = 16**\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-10-zksync-v2-contest",
  "Code": [
    {
      "filename": "ethereum/contracts/bridge/L1EthBridge.sol",
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport \"./interfaces/IL1Bridge.sol\";\nimport \"./interfaces/IL2Bridge.sol\";\n\nimport \"../common/interfaces/IAllowList.sol\";\nimport \"../common/AllowListed.sol\";\nimport \"../common/libraries/UnsafeBytes.sol\";\nimport \"../common/L2ContractHelper.sol\";\nimport \"../common/ReentrancyGuard.sol\";\n\n/// @author Matter Labs\n/// @notice Default bridge for the native ether to zkSync 2.0.\n/// @notice This smart contracts is the only one way to get native ether inside the L2.\ncontract L1EthBridge is IL1Bridge, AllowListed, ReentrancyGuard {\n    /// @dev The smart contract that manages the list with permission to call contract functions\n    IAllowList immutable allowList;\n\n    /// @dev zkSync smart contract used to interact with L2 via asynchronous L2 <-> L1 communication\n    IMailbox immutable zkSyncMailbox;\n\n    /// @dev Ergs limit for requesting L2 deposit finalization transaction\n    /// NOTE: constant is not calculated accurately, because ergs count in L2 is not stable yet\n    uint256 constant DEPOSIT_ERGS_LIMIT = 2097152;\n\n    /// @dev Ergs limit for requesting L1 -> L2 transaction of deploying L2 bridge instance\n    /// NOTE: constant is not calculated accurately, because ergs count in L2 is not stable yet\n    uint256 constant DEPLOY_L2_BRIDGE_COUNTERPART_ERGS_LIMIT = 2097152;\n\n    /// @dev Ether native coin has no real address on L1, so a conventional zero address is used.\n    address constant CONVENTIONAL_ETH_ADDRESS = address(0);\n\n    /// @dev A mapping L2 block number => message number => flag\n    /// @dev Used to indicate that zkSync L2 -> L1 message was already processed\n    mapping(uint256 => mapping(uint256 => bool)) public isWithdrawalFinalized;\n\n    /// @dev A mapping account => L1 token address => L2 deposit transaction hash => amount\n    /// @dev Used for saving the number of deposited funds, to claim them in case the deposit transaction will fail\n    mapping(address => mapping(bytes32 => uint256)) depositAmount;\n\n    /// @dev The address of deployed L2 bridge counterpart\n    address public l2Bridge;\n\n    /// @dev Contract is expected to be used as proxy implementation.\n    /// @dev Initialize the implementation to prevent Parity hack.\n    constructor(IMailbox _mailbox, IAllowList _allowList) reentrancyGuardInitializer {\n        zkSyncMailbox = _mailbox;\n        allowList = _allowList;\n    }\n\n    /// @dev Initializes a contract bridge for later use. Expected to be used in the proxy.\n    /// @dev Deploys L2 bridge counterpart during initialization.\n    /// @param _l2BridgeBytecode a raw bytecode of the L2 bridge contract, that will be deployed on L2.\n    function initialize(bytes calldata _l2BridgeBytecode) external reentrancyGuardInitializer {\n        bytes32 create2Salt = bytes32(0);\n        bytes memory create2Input = abi.encode(address(this));\n        bytes32 l2BridgeBytecodeHash = L2ContractHelper.hashL2Bytecode(_l2BridgeBytecode);\n        bytes memory deployL2BridgeCalldata = abi.encodeCall(\n            IContractDeployer.create2,\n            (create2Salt, l2BridgeBytecodeHash, create2Input)\n        );\n\n        l2Bridge = L2ContractHelper.computeCreate2Address(\n            address(this),\n            create2Salt,\n            l2BridgeBytecodeHash,\n            keccak256(create2Input)\n        );\n        bytes[] memory factoryDeps = new bytes[](1);\n        factoryDeps[0] = _l2BridgeBytecode;\n        zkSyncMailbox.requestL2Transaction(\n            DEPLOYER_SYSTEM_CONTRACT_ADDRESS,\n            0,\n            deployL2BridgeCalldata,\n            DEPLOY_L2_BRIDGE_COUNTERPART_ERGS_LIMIT,\n            factoryDeps\n        );\n    }\n\n    /// @notice Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where ether would be minted\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited. Always should be equal to zero\n    /// @param _amount The total amount of ether to be bridged\n    /// @return txHash The L2 transaction hash of deposit finalization\n    function deposit(\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount\n    ) external payable nonReentrant senderCanCallFunction(allowList) returns (bytes32 txHash) {\n        require(_l1Token == CONVENTIONAL_ETH_ADDRESS, \"bx\");\n\n        // Will revert if msg.value is less than the amount of the deposit\n        uint256 zkSyncFee = msg.value - _amount;\n        bytes memory l2TxCalldata = _getDepositL2Calldata(msg.sender, _l2Receiver, _amount);\n        txHash = zkSyncMailbox.requestL2Transaction{value: zkSyncFee}(\n            l2Bridge,\n            0, // L2 msg.value\n            l2TxCalldata,\n            DEPOSIT_ERGS_LIMIT,\n            new bytes[](0)\n        );\n\n        // Save the deposit amount, to claim funds back if the L2 transaction will failed\n        depositAmount[msg.sender][txHash] = _amount;\n\n        emit DepositInitiated(msg.sender, _l2Receiver, _l1Token, _amount);\n    }\n\n    /// @dev Serialize the transaction calldata for the L2 bridge counterpart\n    function _getDepositL2Calldata(\n        address _l1Sender,\n        address _l2Receiver,\n        uint256 _amount\n    ) internal pure returns (bytes memory txCalldata) {\n        txCalldata = abi.encodeCall(\n            IL2Bridge.finalizeDeposit,\n            (_l1Sender, _l2Receiver, CONVENTIONAL_ETH_ADDRESS, _amount, hex\"\")\n        );\n    }\n\n    /// @dev Withdraw funds from the initiated deposit, that failed when finalizing on L2\n    /// @param _depositSender The address of the deposit initiator\n    /// @param _l1Token The address of the deposited L1 token (should always be zero)\n    /// @param _l2TxHash The L2 transaction hash of the deposit finalization\n    /// @param _l2BlockNumber The L2 block number where the deposit finalization was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBlock The L2 transaction number in a block, in which the log was sent\n    /// @param _merkleProof The Merkle proof of the processing L1 -> L2 transaction with deposit finalization\n    function claimFailedDeposit(\n        address _depositSender,\n        address _l1Token,\n        bytes32 _l2TxHash,\n        uint256 _l2BlockNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBlock,\n        bytes32[] calldata _merkleProof\n    ) external override nonReentrant senderCanCallFunction(allowList) {\n        require(_l1Token == CONVENTIONAL_ETH_ADDRESS, \"sj\");\n\n        // Checks\n        uint256 amount = depositAmount[_depositSender][_l2TxHash];\n        require(amount != 0);\n\n        // Bootloader sends an L2 -> L1 log only after processing the L1 -> L2 transaction.\n        // Thus, we can verify that the deposit (L1 -> L2 transaction) was included in the L2 block with failed status.\n        //\n        // The semantics of such L2 -> L1 log is always:\n        // - sender = BOOTLOADER_ADDRESS\n        // - key = hash(L1ToL2Transaction)\n        // - value = status of the processing transaction (1 - success & 0 for fail)\n        // - isService = true (just a conventional value)\n        // - l2ShardId = 0 (means that L1 -> L2 transaction was processed in a rollup shard, other shards are not available yet anyway)\n        // - txNumberInBlock = number of transaction in the block\n        L2Log memory l2Log = L2Log({\n            l2ShardId: 0,\n            isService: true,\n            txNumberInBlock: _l2TxNumberInBlock,\n            sender: BOOTLOADER_ADDRESS,\n            key: _l2TxHash,\n            value: bytes32(0)\n        });\n        bool success = zkSyncMailbox.proveL2LogInclusion(_l2BlockNumber, _l2MessageIndex, l2Log, _merkleProof);\n        require(success, \"ju\");\n\n        // Effects\n        delete depositAmount[_depositSender][_l2TxHash];\n        // Interactions\n        _withdrawFunds(_depositSender, amount);\n\n        emit ClaimedFailedDeposit(_depositSender, _l1Token, amount);\n    }\n\n    /// @notice Finalize the withdrawal and release funds\n    /// @param _l2BlockNumber The L2 block number where the withdrawal was processed\n    /// @param _l2MessageIndex The position in the L2 logs Merkle tree of the l2Log that was sent with the message\n    /// @param _l2TxNumberInBlock The L2 transaction number in a block, in which the log was sent\n    /// @param _message The L2 withdraw data, stored in an L2 -> L1 message\n    /// @param _merkleProof The Merkle proof of the inclusion L2 -> L1 message about withdrawal initialization\n    function finalizeWithdrawal(\n        uint256 _l2BlockNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBlock,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external override nonReentrant senderCanCallFunction(allowList) {\n        require(!isWithdrawalFinalized[_l2BlockNumber][_l2MessageIndex], \"jj\");\n\n        L2Message memory l2ToL1Message = L2Message({\n            txNumberInBlock: _l2TxNumberInBlock,\n            sender: l2Bridge,\n            data: _message\n        });\n\n        (address l1Receiver, uint256 amount) = _parseL2WithdrawalMessage(_message);\n\n        bool success = zkSyncMailbox.proveL2MessageInclusion(\n            _l2BlockNumber,\n            _l2MessageIndex,\n            l2ToL1Message,\n            _merkleProof\n        );\n        require(success, \"rj\");\n\n        isWithdrawalFinalized[_l2BlockNumber][_l2MessageIndex] = true;\n        _withdrawFunds(l1Receiver, amount);\n\n        emit WithdrawalFinalized(l1Receiver, CONVENTIONAL_ETH_ADDRESS, amount);\n    }\n\n    /// @dev Decode the withdraw message that came from L2\n    function _parseL2WithdrawalMessage(bytes memory _message)\n        internal\n        pure\n        returns (address l1Receiver, uint256 amount)\n    {\n        // Check that the message length is correct.\n        // It should be equal to the length of the function signature + address + uint256 = 4 + 20 + 32 = 56 (bytes).\n        require(_message.length == 56);\n\n        (uint32 functionSignature, uint256 offset) = UnsafeBytes.readUint32(_message, 0);\n        require(bytes4(functionSignature) == this.finalizeWithdrawal.selector);\n\n        (l1Receiver, offset) = UnsafeBytes.readAddress(_message, offset);\n        (amount, offset) = UnsafeBytes.readUint256(_message, offset);\n    }\n\n    /// @notice Transfer ether from the contract to the receiver\n    /// @dev Reverts only if the transfer call failed\n    function _withdrawFunds(address _to, uint256 _amount) internal {\n        bool callSuccess;\n        // Low-level assembly call, to avoid any memory copying (save gas)\n        assembly {\n            callSuccess := call(gas(), _to, _amount, 0, 0, 0, 0)\n        }\n        require(callSuccess);\n    }\n\n    /// @notice The L2 token address that would be minted for deposit of the given L1 token\n    /// @dev Ignore function input and always return zero address as a only one token that the bridge process\n    function l2TokenAddress(address) public pure returns (address) {\n        return CONVENTIONAL_ETH_ADDRESS;\n    }\n}"
    },
    {
      "filename": "zksync/contracts/bridge/L2ETHBridge.sol",
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport {L2ContractHelper} from \"../L2ContractHelper.sol\";\n\nimport \"./interfaces/IL1Bridge.sol\";\nimport \"./interfaces/IL2Bridge.sol\";\nimport \"./interfaces/IL2EthInitializable.sol\";\nimport \"./interfaces/IL2StandardToken.sol\";\n\n/// @author Matter Labs\n/// @dev This contract is used for bridging the ether from L1.\ncontract L2ETHBridge is IL2Bridge {\n    /// @dev The total amount of tokens that have been minted\n    uint256 public totalSupply;\n\n    /// @dev Mapping of address to the balance\n    mapping(address => uint256) public balanceOf;\n\n    /// @dev Address of the L1 bridge counterpart\n    address public override l1Bridge;\n\n    /// @dev System contract that is responsible for storing and changing ether balances\n    IL2StandardToken constant ETH_TOKEN_SYSTEM_CONTRACT_ADDRESS = IL2StandardToken(address(0x800a));\n\n    /// @dev Ether native coin has no real address on L1, so a conventional zero address is used\n    address constant CONVENTIONAL_ETH_ADDRESS = address(0);\n\n    constructor(address _l1Bridge) {\n        l1Bridge = _l1Bridge;\n\n        IL2EthInitializable(address(ETH_TOKEN_SYSTEM_CONTRACT_ADDRESS)).initialization(address(this));\n    }\n\n    /// @dev Finalize the deposit and mint ether to the deposited address\n    /// @param _l1Sender The account address that initiate the deposit on L1\n    /// @param _l2Receiver The account address that would receive minted ether\n    /// @param _l1Token The address of the token that was locked on the L1. Always should be equal to zero (conventional value)\n    /// @param _amount Total amount of ether deposited from L1\n    function finalizeDeposit(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        bytes calldata // _data\n    ) external {\n        // Only L1 bridge counterpart can initiate and finalize the deposit\n        require(msg.sender == l1Bridge, \"ni\");\n        require(_l1Token == CONVENTIONAL_ETH_ADDRESS);\n\n        ETH_TOKEN_SYSTEM_CONTRACT_ADDRESS.bridgeMint(_l2Receiver, _amount);\n\n        emit FinalizeDeposit(_l1Sender, _l2Receiver, CONVENTIONAL_ETH_ADDRESS, _amount);\n    }\n\n    /// @dev Initiate withdrawal ethers from L2 contract to the L1\n    /// NOTE: In order to get funds on L1, receiver should finalise deposit on L1 counterpart\n    function withdraw(\n        address _l1Receiver,\n        address _l2Token,\n        uint256 _amount\n    ) external override {\n        require(_l2Token == CONVENTIONAL_ETH_ADDRESS, \"zn\");\n\n        ETH_TOKEN_SYSTEM_CONTRACT_ADDRESS.bridgeBurn(msg.sender, _amount);\n        bytes memory message = _getL1WithdrawMessage(_l1Receiver, _amount);\n        L2ContractHelper.sendMessageToL1(message);\n\n        emit WithdrawalInitiated(msg.sender, _l1Receiver, CONVENTIONAL_ETH_ADDRESS, _amount);\n    }\n\n    /// @dev Get the \"withdrawal initialized\" fact message to be sent on L1\n    function _getL1WithdrawMessage(address _to, uint256 _amount) internal pure returns (bytes memory) {\n        return abi.encodePacked(IL1Bridge.finalizeWithdrawal.selector, _to, _amount);\n    }\n\n    /// @notice Address of the L2 token by its L1 couterpart\n    function l2TokenAddress(address) public pure returns (address) {\n        return CONVENTIONAL_ETH_ADDRESS;\n    }\n\n    /// @notice Address of the L1 token by its L2 couterpart\n    function l1TokenAddress(address) public pure override returns (address) {\n        return CONVENTIONAL_ETH_ADDRESS;\n    }\n}"
    }
  ]
}