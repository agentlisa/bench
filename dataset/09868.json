{
  "Title": "[G-01] `refundGasByUser` function can use unchecked directory and slight refactor may reduce gas fee.",
  "Content": "\nBy refactoring following code, it can reduce gas cost of `CommunityPool.sol`.\n<https://github.com/skalenetwork/ima-c4-audit/blob/main/contracts/mainnet/CommunityPool.sol#L97-L111>\n\n    uint amount = tx.gasprice * gas;\n    if (amount > _userWallets[user][schainHash]) {\n        amount = _userWallets[user][schainHash];\n    }\n    _userWallets[user][schainHash] = _userWallets[user][schainHash] - amount;\n    if (!_balanceIsSufficient(schainHash, user, 0)) {\n        activeUsers[user][schainHash] = false;\n        messageProxy.postOutgoingMessage(\n            schainHash,\n            schainLinks[schainHash],\n            Messages.encodeLockUserMessage(user)\n        );\n    }\n    node.sendValue(amount);\n    return (tx.gasprice * gas - amount) / tx.gasprice;\n\nFirst, `_userWallets[user][schainHash] - amount` will never be less than 0 so can be wrapped by unchecked, since `amount` is always equal to or less than `_userWallets[user][schainHash]`.\nSecond, `(tx.gasprice * gas - amount) / tx.gasprice` will not underflown so can be wrapped by unchecked directory, since `tx.gasprice * gas - amount` will be equal to or more than 0.\n\nHere is an example of the modified code:\n\n    uint amount = tx.gasprice * gas;\n    if (amount > _userWallets[user][schainHash]) {\n        amount = _userWallets[user][schainHash];\n    }\n    unchecked {\n        _userWallets[user][schainHash] = _userWallets[user][schainHash] - amount;\n    }\n    if (!_balanceIsSufficient(schainHash, user, 0)) {\n        activeUsers[user][schainHash] = false;\n        messageProxy.postOutgoingMessage(\n            schainHash,\n            schainLinks[schainHash],\n            Messages.encodeLockUserMessage(user)\n        );\n    }\n    node.sendValue(amount);\n    unchecked {\n        return (tx.gasprice * gas - amount) / tx.gasprice;\n    }\n\nIt simply wraps the above mentioned code with unchecked directory.\n\nHere is the comparison of the gas cost at CommunityPool.sol\n\n*   Before: 2114911\n*   After: 2100269\n*   Before - After: 14642 (About 0.6% reduction)\n\n***\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-02-skale-contest",
  "Code": [
    {
      "filename": "contracts/mainnet/CommunityPool.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    CommunityPool.sol - SKALE Manager\n    Copyright (C) 2021-Present SKALE Labs\n    @author Dmytro Stebaiev\n    @author Artem Payvin\n    @author Vadim Yavorsky\n\n    SKALE Manager is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity 0.8.6;\n\nimport \"@skalenetwork/ima-interfaces/mainnet/ICommunityPool.sol\";\nimport \"@skalenetwork/skale-manager-interfaces/IWallets.sol\";\n\nimport \"../Messages.sol\";\nimport \"./Twin.sol\";\n\n\n/**\n * @title CommunityPool\n * @dev Contract contains logic to perform automatic self-recharging ETH for nodes.\n */\ncontract CommunityPool is Twin, ICommunityPool {\n\n    using AddressUpgradeable for address payable;\n\n    bytes32 public constant CONSTANT_SETTER_ROLE = keccak256(\"CONSTANT_SETTER_ROLE\");\n\n    // address of user => schainHash => balance of gas wallet in ETH\n    mapping(address => mapping(bytes32 => uint)) private _userWallets;\n\n    // address of user => schainHash => true if unlocked for transferring\n    mapping(address => mapping(bytes32 => bool)) public activeUsers;\n\n    uint public minTransactionGas;    \n\n    /**\n     * @dev Emitted when minimal value in gas for transactions from schain to mainnet was changed \n     */\n    event MinTransactionGasWasChanged(\n        uint oldValue,\n        uint newValue\n    );\n\n    function initialize(\n        IContractManager contractManagerOfSkaleManagerValue,\n        ILinker linker,\n        IMessageProxyForMainnet messageProxyValue\n    )\n        external\n        override\n        initializer\n    {\n        Twin.initialize(contractManagerOfSkaleManagerValue, messageProxyValue);\n        _setupRole(LINKER_ROLE, address(linker));\n        minTransactionGas = 1e6;\n    }\n\n    /**\n     * @dev Allows MessageProxyForMainnet to reimburse gas for transactions \n     * that transfer funds from schain to mainnet.\n     * \n     * Requirements:\n     * \n     * - User that receives funds should have enough funds in their gas wallet.\n     * - Address that should be reimbursed for executing transaction must not be null.\n     */\n    function refundGasByUser(\n        bytes32 schainHash,\n        address payable node,\n        address user,\n        uint gas\n    )\n        external\n        override\n        onlyMessageProxy\n        returns (uint)\n    {\n        require(node != address(0), \"Node address must be set\");\n        if (!activeUsers[user][schainHash]) {\n            return gas;\n        }\n        uint amount = tx.gasprice * gas;\n        if (amount > _userWallets[user][schainHash]) {\n            amount = _userWallets[user][schainHash];\n        }\n        _userWallets[user][schainHash] = _userWallets[user][schainHash] - amount;\n        if (!_balanceIsSufficient(schainHash, user, 0)) {\n            activeUsers[user][schainHash] = false;\n            messageProxy.postOutgoingMessage(\n                schainHash,\n                schainLinks[schainHash],\n                Messages.encodeLockUserMessage(user)\n            );\n        }\n        node.sendValue(amount);\n        return (tx.gasprice * gas - amount) / tx.gasprice;\n    }\n\n    function refundGasBySchainWallet(\n        bytes32 schainHash,\n        address payable node,\n        uint gas\n    )\n        external\n        override\n        onlyMessageProxy\n        returns (bool)\n    {\n        if (gas > 0) {\n            IWallets(contractManagerOfSkaleManager.getContract(\"Wallets\")).refundGasBySchain(\n                schainHash,\n                node,\n                gas,\n                false\n            );\n        }\n        return true;\n    }\n\n    /**\n     * @dev Allows `msg.sender` to recharge their wallet for further gas reimbursement.\n     * \n     * Requirements:\n     * \n     * - 'msg.sender` should recharge their gas wallet for amount that enough to reimburse any \n     *   transaction from schain to mainnet.\n     */\n    function rechargeUserWallet(string calldata schainName, address user) external payable override {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        require(\n            _balanceIsSufficient(schainHash, user, msg.value),\n            \"Not enough ETH for transaction\"\n        );\n        _userWallets[user][schainHash] = _userWallets[user][schainHash] + msg.value;\n        if (!activeUsers[user][schainHash]) {\n            activeUsers[user][schainHash] = true;\n            messageProxy.postOutgoingMessage(\n                schainHash,\n                schainLinks[schainHash],\n                Messages.encodeActivateUserMessage(user)\n            );\n        }\n    }\n\n    /**\n     * @dev Allows `msg.sender` to withdraw funds from their gas wallet.\n     * If `msg.sender` withdraws too much funds,\n     * then he will no longer be able to transfer their tokens on ETH from schain to mainnet.\n     * \n     * Requirements:\n     * \n     * - 'msg.sender` must have sufficient amount of ETH on their gas wallet.\n     */\n    function withdrawFunds(string calldata schainName, uint amount) external override {\n        bytes32 schainHash = keccak256(abi.encodePacked(schainName));\n        require(amount <= _userWallets[msg.sender][schainHash], \"Balance is too low\");\n        require(!messageProxy.messageInProgress(), \"Message is in progress\");\n        _userWallets[msg.sender][schainHash] = _userWallets[msg.sender][schainHash] - amount;\n        if (\n            !_balanceIsSufficient(schainHash, msg.sender, 0) &&\n            activeUsers[msg.sender][schainHash]\n        ) {\n            activeUsers[msg.sender][schainHash] = false;\n            messageProxy.postOutgoingMessage(\n                schainHash,\n                schainLinks[schainHash],\n                Messages.encodeLockUserMessage(msg.sender)\n            );\n        }\n        payable(msg.sender).sendValue(amount);\n    }\n\n    /**\n     * @dev Allows `msg.sender` set the amount of gas that should be \n     * enough for reimbursing any transaction from schain to mainnet.\n     * \n     * Requirements:\n     * \n     * - 'msg.sender` must have sufficient amount of ETH on their gas wallet.\n     */\n    function setMinTransactionGas(uint newMinTransactionGas) external override {\n        require(hasRole(CONSTANT_SETTER_ROLE, msg.sender), \"CONSTANT_SETTER_ROLE is required\");\n        emit MinTransactionGasWasChanged(minTransactionGas, newMinTransactionGas);\n        minTransactionGas = newMinTransactionGas;\n    }\n\n    /**\n     * @dev Returns the amount of ETH on gas wallet for particular user.\n     */\n    function getBalance(address user, string calldata schainName) external view override returns (uint) {\n        return _userWallets[user][keccak256(abi.encodePacked(schainName))];\n    }\n\n    /**\n     * @dev Checks whether user is active and wallet was recharged for sufficient amount.\n     */\n    function checkUserBalance(bytes32 schainHash, address receiver) external view override returns (bool) {\n        return activeUsers[receiver][schainHash] && _balanceIsSufficient(schainHash, receiver, 0);\n    }\n\n    /**\n     * @dev Checks whether user wallet was recharged for sufficient amount.\n     */\n    function _balanceIsSufficient(bytes32 schainHash, address receiver, uint256 delta) private view returns (bool) {\n        return delta + _userWallets[receiver][schainHash] >= minTransactionGas * tx.gasprice;\n    } \n}"
    }
  ]
}