{
  "Title": "[04] Data corruption handled in different ways",
  "Content": "\nThe function `_whenSending()` sometimes returns an error string when it encounters corrupt data. Sometimes it reverts when the corruption is detected in `generateSentAssetKeys()`.\n\n### Proof of Concept\n[LSP1UniversalReceiverDelegateUP.sol#L201-L252](https://github.com/lukso-network/lsp-smart-contracts/blob/v0.10.2/contracts/LSP1UniversalReceiver/LSP1UniversalReceiverDelegateUP/LSP1UniversalReceiverDelegateUP.sol#L201-L252)\n```solidity\nfunction _whenSending(...) ... {\n    if (typeId != _TYPEID_LSP9_OwnershipTransferred_SenderNotification) {\n        ...\n        (dataKeys, dataValues) = LSP5Utils.generateSentAssetKeys(...); // reverts on corrupt data\n        if (dataKeys.length == 0 && dataValues.length == 0)\n            return \"LSP1: asset data corrupted\"; // returns on corrupt data\n        }\n    }\n}\n```\n[LSP5ReceivedAssets/LSP5Utils.sol#L117-L137](https://github.com/lukso-network/lsp-smart-contracts/blob/v0.10.2/contracts/LSP5ReceivedAssets/LSP5Utils.sol#L117-L137)\n```solidity\nfunction generateSentAssetKeys(...) ... {\n    ...\n    bytes memory lsp5ReceivedAssetsCountValue = getLSP5ReceivedAssetsCount(account);\n    if (lsp5ReceivedAssetsCountValue.length != 16) {\n        revert InvalidLSP5ReceivedAssetsArrayLength(...);\n    }\n}\n```\n\n### Recommended Mitigation Steps\nConsider handling all cases of data corruption in the same way.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-06-lukso",
  "Code": [
    {
      "filename": "contracts/LSP1UniversalReceiver/LSP1UniversalReceiverDelegateUP/LSP1UniversalReceiverDelegateUP.sol",
      "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity ^0.8.4;\n\n// interfaces\nimport {\n    IERC725Y\n} from \"@erc725/smart-contracts/contracts/interfaces/IERC725Y.sol\";\nimport {ILSP1UniversalReceiver} from \"../ILSP1UniversalReceiver.sol\";\nimport {ILSP7DigitalAsset} from \"../../LSP7DigitalAsset/ILSP7DigitalAsset.sol\";\n\n// modules\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\n// libraries\nimport {\n    ERC165Checker\n} from \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport {LSP1Utils} from \"../LSP1Utils.sol\";\nimport {LSP2Utils} from \"../../LSP2ERC725YJSONSchema/LSP2Utils.sol\";\nimport {LSP5Utils} from \"../../LSP5ReceivedAssets/LSP5Utils.sol\";\nimport {LSP10Utils} from \"../../LSP10ReceivedVaults/LSP10Utils.sol\";\n\n// constants\nimport \"../LSP1Constants.sol\";\nimport \"../../LSP0ERC725Account/LSP0Constants.sol\";\nimport \"../../LSP6KeyManager/LSP6Constants.sol\";\nimport \"../../LSP9Vault/LSP9Constants.sol\";\nimport \"../../LSP10ReceivedVaults/LSP10Constants.sol\";\nimport \"../../LSP14Ownable2Step/LSP14Constants.sol\";\n\n// errors\nimport \"../LSP1Errors.sol\";\n\n/**\n * @title Implementation of a UniversalReceiverDelegate for LSP0ERC725Account\n * @author Fabian Vogelsteller, Yamen Merhi, Jean Cavallera\n * @dev This UniversalReceiverDelegate follows the {LSP1-UniversalReceiver} standards and is designed\n * for LSP0ERC725Account contracts.\n *\n * @dev Handles two cases:\n * - Registers the address of received assets (exclusively LSP7 and LSP8) and vaults (exclusively LSP9) according\n *   to {LSP5-ReceivedAssets} and {LSP10-ReceivedVaults} respectively\n *\n *   https://github.com/lukso-network/LIPs/blob/main/LSPs/LSP-5-ReceivedAssets.md\n *   https://github.com/lukso-network/LIPs/blob/main/LSPs/LSP-10-ReceivedVaults.md\n *\n * - Removes the address of registered assets and vaults when the full balance is sent from the LSP0ERC725Account contract\n *\n * Requirements:\n * - The contract should be able to setData the LSP5 and LSP10 data Keys according to the logic of the owner\n *    of the LSP0ERC725Account.\n *\n * For example, for contracts that are owned by an LSP6KeyManager, this contract should be granted\n * the SUPER/SETDATA and REENTRANCY Permission.\n *\n * Assets and Vaults that are compliant with this version of the UniversalReceiverDelegate are:\n *\n * - LSP7-DigitalAsset: https://github.com/lukso-network/LIPs/blob/main/LSPs/LSP-7-DigitalAsset.md\n * - LSP8-IdentifiableDigitalAsset: https://github.com/lukso-network/LIPs/blob/main/LSPs/LSP-8-IdentifiableDigitalAsset.md\n * - LSP9-Vault: https://github.com/lukso-network/LIPs/blob/main/LSPs/LSP-9-Vault.md\n */\ncontract LSP1UniversalReceiverDelegateUP is ERC165, ILSP1UniversalReceiver {\n    using ERC165Checker for address;\n\n    /**\n     * @dev Handles two cases:\n     * - Registers the address of received assets (exclusively LSP7 and LSP8) and vaults (exclusively LSP9) according\n     *   to {LSP5-ReceivedAssets} and {LSP10-ReceivedVaults} respectively\n     *\n     * - Removes the address of registered assets and vaults when the full balance is sent from the LSP0ERC725Account contract\n     *\n     * Requirements:\n     * - The contract should be able to setData the LSP5 and LSP10 data Keys according to the logic of the owner\n     *    of the LSP0ERC725Account.\n     *\n     * - Cannot accept native tokens\n     */\n    function universalReceiver(\n        bytes32 typeId,\n        bytes memory /* data */\n    ) public payable virtual returns (bytes memory result) {\n        if (msg.value != 0) revert NativeTokensNotAccepted();\n\n        // This contract acts like a UniversalReceiverDelegate of an LSP0ERC725Account where we append the\n        // address and the value, sent to the universalReceiver function of the LSP0, to the msg.data\n        // Check https://github.com/lukso-network/LIPs/blob/main/LSPs/LSP-0-ERC725Account.md#universalreceiver\n        address notifier = address(bytes20(msg.data[msg.data.length - 52:]));\n\n        // Get the supposed mapPrefix and interfaceId based on the typeID\n        (\n            bool invalid,\n            bytes10 mapPrefix,\n            bytes4 interfaceID,\n            bool isReceiving\n        ) = LSP1Utils.getTransferDetails(typeId);\n\n        // If it's a typeId different than LSP7/LSP8/LSP9 typeIds\n        if (invalid) return \"LSP1: typeId out of scope\";\n\n        // The notifier is supposed to be either the LSP7 or LSP8 or LSP9 contract\n        // If it's EOA we revert to avoid registering the EOA as asset or vault (spam protection)\n        // solhint-disable avoid-tx-origin\n        if (notifier == tx.origin) revert CannotRegisterEOAsAsAssets(notifier);\n\n        // Generate the LSP5ReceivedAssetsMap/LSP10VaultsMap based on the prefix and the notifier\n        bytes32 notifierMapKey = LSP2Utils.generateMappingKey(\n            mapPrefix,\n            bytes20(notifier)\n        );\n\n        // Query the ERC725Y storage of the LSP0-ERC725Account\n        bytes memory notifierMapValue = IERC725Y(msg.sender).getData(\n            notifierMapKey\n        );\n\n        bool isMapValueSet = bytes20(notifierMapValue) != bytes20(0);\n\n        if (isReceiving) {\n            // If the mapValue is set, we assume that all other data keys relevant to the asset/vault\n            // are registered in the account, we don't need to re register the asset being received\n            if (isMapValueSet)\n                return \"LSP1: asset received is already registered\";\n\n            return\n                _whenReceiving(typeId, notifier, notifierMapKey, interfaceID);\n        } else {\n            // If the mapValue is not set, we assume that all other data keys relevant to the asset/vault\n            // are not registered in the account, we cannot remove non-existing data keys for the asset being sent\n            if (!isMapValueSet) return \"LSP1: asset sent is not registered\";\n\n            // if the value under the `LSP5ReceivedAssetsMap:<asset-address>` or `LSP10VaultsMap:<vault-address>`\n            // is not a valid tuple as `(bytes4,uint128)`\n            if (notifierMapValue.length < 20)\n                return \"LSP1: asset data corrupted\";\n\n            // Identify where the asset/vault is located in the `LSP5ReceivedAssets[]` / `LSP10Vaults[]` Array\n            // by extracting the index from the tuple value `(bytes4,uint128)`\n            // fetched under the `LSP5ReceivedAssetsMap` / `LSP10VaultsMap` data key\n            uint128 arrayIndex = uint128(uint160(bytes20(notifierMapValue)));\n\n            return _whenSending(typeId, notifier, notifierMapKey, arrayIndex);\n        }\n    }\n\n    // --- Internal functions\n\n    /**\n     * @dev To avoid stack too deep error\n     * Generate the keys/values of the asset/vault received to set and set them\n     * on the account depending on the type of the transfer (asset/vault)\n     */\n    function _whenReceiving(\n        bytes32 typeId,\n        address notifier,\n        bytes32 notifierMapKey,\n        bytes4 interfaceID\n    ) internal virtual returns (bytes memory) {\n        bytes32[] memory dataKeys;\n        bytes[] memory dataValues;\n\n        // if it's a token transfer (LSP7/LSP8)\n        if (typeId != _TYPEID_LSP9_OwnershipTransferred_RecipientNotification) {\n            // CHECK balance only when the Token contract is already deployed,\n            // not when tokens are being transferred on deployment through the `constructor`\n            if (notifier.code.length > 0) {\n                // if the amount sent is 0, then do not update the keys\n                uint256 balance = ILSP7DigitalAsset(notifier).balanceOf(\n                    msg.sender\n                );\n                if (balance == 0) return \"LSP1: balance not updated\";\n            }\n\n            (dataKeys, dataValues) = LSP5Utils.generateReceivedAssetKeys(\n                msg.sender,\n                notifier,\n                notifierMapKey,\n                interfaceID\n            );\n\n            // Set the LSP5 generated data keys on the account\n            IERC725Y(msg.sender).setDataBatch(dataKeys, dataValues);\n            return \"\";\n        } else {\n            (dataKeys, dataValues) = LSP10Utils.generateReceivedVaultKeys(\n                msg.sender,\n                notifier,\n                notifierMapKey\n            );\n\n            // Set the LSP10 generated data keys on the account\n            IERC725Y(msg.sender).setDataBatch(dataKeys, dataValues);\n            return \"\";\n        }\n    }\n\n    /**\n     * @dev To avoid stack too deep error\n     * Generate the keys/values of the asset/vault sent to set and set them\n     * on the account depending on the type of the transfer (asset/vault)\n     */\n    function _whenSending(\n        bytes32 typeId,\n        address notifier,\n        bytes32 notifierMapKey,\n        uint128 arrayIndex\n    ) internal virtual returns (bytes memory) {\n        bytes32[] memory dataKeys;\n        bytes[] memory dataValues;\n\n        // if it's a token transfer (LSP7/LSP8)\n        if (typeId != _TYPEID_LSP9_OwnershipTransferred_SenderNotification) {\n            // if the amount sent is not the full balance, then do not update the keys\n            uint256 balance = ILSP7DigitalAsset(notifier).balanceOf(msg.sender);\n            if (balance != 0) return \"LSP1: full balance is not sent\";\n\n            (dataKeys, dataValues) = LSP5Utils.generateSentAssetKeys(\n                msg.sender,\n                notifierMapKey,\n                arrayIndex\n            );\n\n            /**\n             * `generateSentAssetKeys(...)` returns empty arrays in the following cases:\n             * - the index returned from the data key `notifierMapKey` is bigger than\n             * the length of the `LSP5ReceivedAssets[]`, meaning, index is out of bounds.\n             */\n            if (dataKeys.length == 0 && dataValues.length == 0)\n                return \"LSP1: asset data corrupted\";\n\n            // Set the LSP5 generated data keys on the account\n            IERC725Y(msg.sender).setDataBatch(dataKeys, dataValues);\n            return \"\";\n        } else {\n            (dataKeys, dataValues) = LSP10Utils.generateSentVaultKeys(\n                msg.sender,\n                notifierMapKey,\n                arrayIndex\n            );\n\n            /**\n             * `generateSentAssetKeys(...)` returns empty arrays in the following cases:\n             * - the index returned from the data key `notifierMapKey` is bigger than\n             * the length of the `LSP10Vaults[]`, meaning, index is out of bounds.\n             */\n            if (dataKeys.length == 0 && dataValues.length == 0)\n                return \"LSP1: asset data corrupted\";\n\n            // Set the LSP10 generated data keys on the account\n            IERC725Y(msg.sender).setDataBatch(dataKeys, dataValues);\n            return \"\";\n        }\n    }\n\n    // --- Overrides\n\n    /**\n     * @inheritdoc ERC165\n     */\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override returns (bool) {\n        return\n            interfaceId == _INTERFACEID_LSP1 ||\n            super.supportsInterface(interfaceId);\n    }\n}"
    },
    {
      "filename": "contracts/LSP5ReceivedAssets/LSP5Utils.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.4;\n\n// interfaces\nimport {\n    IERC725Y\n} from \"@erc725/smart-contracts/contracts/interfaces/IERC725Y.sol\";\n\n// libraries\nimport {BytesLib} from \"solidity-bytes-utils/contracts/BytesLib.sol\";\nimport {LSP2Utils} from \"../LSP2ERC725YJSONSchema/LSP2Utils.sol\";\n\n// constants\nimport \"../LSP5ReceivedAssets/LSP5Constants.sol\";\nimport \"../LSP7DigitalAsset/LSP7Constants.sol\";\n\n/**\n * @dev reverts when the value stored under the 'LSP5ReceivedAssets[]' data key is not valid.\n *      The value stored under this data key should be exactly 16 bytes long.\n *\n *      Only possible valid values are:\n *      - any valid uint128 values\n *          i.e. 0x00000000000000000000000000000000 (zero), empty array, no assets received.\n *          i.e. 0x00000000000000000000000000000005 (non-zero), 5 array elements, 5 assets received.\n *\n *      - 0x (nothing stored under this data key, equivalent to empty array)\n *\n * @param invalidValueStored the invalid value stored under the LSP5ReceivedAssets[] data key\n * @param invalidValueLength the invalid number of bytes stored under the LSP5ReceivedAssets[] data key (MUST be exactly 16 bytes long)\n */\nerror InvalidLSP5ReceivedAssetsArrayLength(\n    bytes invalidValueStored,\n    uint256 invalidValueLength\n);\n\n/**\n * @dev reverts when the `LSP5ReceivedAssets[]` array reaches its maximum limit (max(uint128))\n * @param notRegisteredAsset the address of the asset that could not be registered\n */\nerror MaxLSP5ReceivedAssetsCountReached(address notRegisteredAsset);\n\n/**\n * @dev reverts when the received assets index is superior to uint128\n * @param index the received assets index\n */\nerror ReceivedAssetsIndexSuperiorToUint128(uint256 index);\n\n/**\n * @title LSP5Utils\n * @author Yamen Merhi <YamenMerhi>, Jean Cavallera <CJ42>\n * @dev LSP5Utils is a library of functions that are used to register and manage assets received by an ERC725Y smart contract\n *      based on the LSP5 - Received Assets standard\n *      https://github.com/lukso-network/LIPs/blob/main/LSPs/LSP-5-ReceivedAssets.md\n */\nlibrary LSP5Utils {\n    /**\n     * @dev Generating the data keys/values to be set on the receiver address after receiving assets\n     * @param receiver The address receiving the asset and where the Keys should be added\n     * @param asset The address of the asset being received\n     * @param assetMapKey The map key of the asset being received containing the interfaceId of the\n     * asset and the index in the array\n     * @param interfaceID The interfaceID of the asset being received\n     */\n    function generateReceivedAssetKeys(\n        address receiver,\n        address asset,\n        bytes32 assetMapKey,\n        bytes4 interfaceID\n    ) internal view returns (bytes32[] memory keys, bytes[] memory values) {\n        keys = new bytes32[](3);\n        values = new bytes[](3);\n\n        IERC725Y account = IERC725Y(receiver);\n        bytes memory encodedArrayLength = getLSP5ReceivedAssetsCount(account);\n\n        // CHECK it's either the first asset received,\n        // or the storage is already set with a valid `uint128` value\n        if (encodedArrayLength.length != 0 && encodedArrayLength.length != 16) {\n            revert InvalidLSP5ReceivedAssetsArrayLength({\n                invalidValueStored: encodedArrayLength,\n                invalidValueLength: encodedArrayLength.length\n            });\n        }\n\n        uint128 oldArrayLength = uint128(bytes16(encodedArrayLength));\n\n        if (oldArrayLength == type(uint128).max) {\n            revert MaxLSP5ReceivedAssetsCountReached({\n                notRegisteredAsset: asset\n            });\n        }\n\n        // store the number of received assets incremented by 1\n        keys[0] = _LSP5_RECEIVED_ASSETS_ARRAY_KEY;\n        values[0] = bytes.concat(bytes16(oldArrayLength + 1));\n\n        // store the address of the asset under the element key in the array\n        keys[1] = LSP2Utils.generateArrayElementKeyAtIndex(\n            _LSP5_RECEIVED_ASSETS_ARRAY_KEY,\n            oldArrayLength\n        );\n        values[1] = bytes.concat(bytes20(asset));\n\n        // store the interfaceId and the location in the array of the asset\n        // under the LSP5ReceivedAssetMap key\n        keys[2] = assetMapKey;\n        values[2] = bytes.concat(interfaceID, bytes16(oldArrayLength));\n    }\n\n    /**\n     * @dev Generating the data keys/values to be set on the sender address after sending assets\n     * @param sender The address sending the asset and where the Keys should be updated\n     * @param assetMapKey The map key of the asset being received containing the interfaceId of the\n     * asset and the index in the array\n     * @param assetIndex The index in the LSP5ReceivedAssets[] array\n     */\n    function generateSentAssetKeys(\n        address sender,\n        bytes32 assetMapKey,\n        uint128 assetIndex\n    ) internal view returns (bytes32[] memory keys, bytes[] memory values) {\n        IERC725Y account = IERC725Y(sender);\n        bytes memory lsp5ReceivedAssetsCountValue = getLSP5ReceivedAssetsCount(\n            account\n        );\n\n        if (lsp5ReceivedAssetsCountValue.length != 16) {\n            revert InvalidLSP5ReceivedAssetsArrayLength({\n                invalidValueStored: lsp5ReceivedAssetsCountValue,\n                invalidValueLength: lsp5ReceivedAssetsCountValue.length\n            });\n        }\n\n        uint128 oldArrayLength = uint128(bytes16(lsp5ReceivedAssetsCountValue));\n\n        // Updating the number of the received assets (decrementing by 1\n        uint128 newArrayLength = oldArrayLength - 1;\n\n        // Generate the element key in the array of the asset\n        bytes32 assetInArrayKey = LSP2Utils.generateArrayElementKeyAtIndex(\n            _LSP5_RECEIVED_ASSETS_ARRAY_KEY,\n            assetIndex\n        );\n\n        // If the asset to remove is the last element in the array\n        if (assetIndex == newArrayLength) {\n            /**\n             * We will be updating/removing 3 keys:\n             * - Keys[0]: [Update] The arrayLengthKey to contain the new number of the received assets\n             * - Keys[1]: [Remove] The element in arrayKey (Remove the address of the asset sent)\n             * - Keys[2]: [Remove] The mapKey (Remove the interfaceId and the index of the asset sent)\n             */\n            keys = new bytes32[](3);\n            values = new bytes[](3);\n\n            // store the number of received assets decremented by 1\n            keys[0] = _LSP5_RECEIVED_ASSETS_ARRAY_KEY;\n            values[0] = bytes.concat(bytes16(newArrayLength));\n\n            // remove the address of the asset from the element key\n            keys[1] = assetInArrayKey;\n            values[1] = \"\";\n\n            // remove the interfaceId and the location in the array of the asset\n            keys[2] = assetMapKey;\n            values[2] = \"\";\n\n            // Swapping last element in ArrayKey with the element in ArrayKey to remove || {Swap and pop} method;\n            // check https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/EnumerableSet.sol#L80\n        } else if (assetIndex < newArrayLength) {\n            /**\n             * We will be updating/removing 5 keys:\n             * - Keys[0]: [Update] The arrayLengthKey to contain the new number of the received assets\n             * - Keys[1]: [Remove] The mapKey of the asset to remove (Remove the interfaceId and the index of the asset sent)\n             * - Keys[2]: [Update] The element in arrayKey to remove (Swap with the address of the last element in Array)\n             * - Keys[3]: [Remove] The last element in arrayKey (Remove (pop) the address of the last element as it's already swapped)\n             * - Keys[4]: [Update] The mapKey of the last element in array (Update the new index and the interfaceID)\n             */\n            keys = new bytes32[](5);\n            values = new bytes[](5);\n\n            // store the number of received assets decremented by 1\n            keys[0] = _LSP5_RECEIVED_ASSETS_ARRAY_KEY;\n            values[0] = bytes.concat(bytes16(newArrayLength));\n\n            // remove the interfaceId and the location in the array of the asset\n            keys[1] = assetMapKey;\n            values[1] = \"\";\n\n            if (newArrayLength >= type(uint128).max) {\n                revert ReceivedAssetsIndexSuperiorToUint128(newArrayLength);\n            }\n\n            // Generate all data Keys/values of the last element in Array to swap\n            // with data Keys/values of the asset to remove\n\n            // Generate the element key of the last asset in the array\n            bytes32 lastAssetInArrayKey = LSP2Utils\n                .generateArrayElementKeyAtIndex(\n                    _LSP5_RECEIVED_ASSETS_ARRAY_KEY,\n                    newArrayLength\n                );\n\n            // Get the address of the asset from the element key of the last asset in the array\n            bytes20 lastAssetInArrayAddress = bytes20(\n                account.getData(lastAssetInArrayKey)\n            );\n\n            // Generate the map key of the last asset in the array\n            bytes32 lastAssetInArrayMapKey = LSP2Utils.generateMappingKey(\n                _LSP5_RECEIVED_ASSETS_MAP_KEY_PREFIX,\n                lastAssetInArrayAddress\n            );\n\n            // Get the interfaceId and the location in the array of the last asset\n            bytes memory lastAssetInterfaceIdAndIndex = account.getData(\n                lastAssetInArrayMapKey\n            );\n            bytes memory interfaceID = BytesLib.slice(\n                lastAssetInterfaceIdAndIndex,\n                0,\n                4\n            );\n\n            // Set the address of the last asset instead of the asset to be sent\n            // under the element data key in the array\n            keys[2] = assetInArrayKey;\n            values[2] = bytes.concat(lastAssetInArrayAddress);\n\n            // Remove the address swapped from the last element data key in the array\n            keys[3] = lastAssetInArrayKey;\n            values[3] = \"\";\n\n            // Update the index and the interfaceId of the address swapped (last element in the array)\n            // to point to the new location in the LSP5ReceivedAssets array\n            keys[4] = lastAssetInArrayMapKey;\n            values[4] = bytes.concat(interfaceID, bytes16(assetIndex));\n        } else {\n            // If index is bigger than the array length, out of bounds\n            return (keys, values);\n        }\n    }\n\n    function getLSP5ReceivedAssetsCount(\n        IERC725Y account\n    ) internal view returns (bytes memory) {\n        return account.getData(_LSP5_RECEIVED_ASSETS_ARRAY_KEY);\n    }\n}"
    }
  ]
}