{
  "Title": "[M04] Incomplete set of unit tests",
  "Content": "No tests were found for several parts of the features implemented in the contracts and some unit tests were completely empty after its declaration, such as the ones in the [`test_governance.py` file](https://github.com/notional-finance/contracts-v2/blob/c37c89c9729b830637558a09b6f22fc6a735da64/tests/governance/test_governance.py#L213). This is considered a major shortcoming in the project, as there is no way to determine if the current implementation matches the systemâ€™s expected behavior. Thorough unit tests aiming at 95% coverage are in order for the security of the project to be assessed in a future audit. Integrating test coverage reports in every single pull request of the project is also highly advisable.\n\n\n***Update:** Partially fixed in [pull request 33](https://github.com/notional-finance/contracts-v2/pull/33/files). The test file no longer has empty units of tests, although no further cases have been tested.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "tests/governance/test_governance.py",
      "content": "import brownie\nimport pytest\nfrom brownie.network import web3\nfrom brownie.network.state import Chain\nfrom scripts.config import GovernanceConfig\nfrom scripts.deployment import TestEnvironment\n\nchain = Chain()\n\n\n@pytest.fixture(scope=\"module\", autouse=True)\ndef environment(accounts):\n    env = TestEnvironment(accounts[0], withGovernance=True, multisig=accounts[1])\n    return env\n\n\n@pytest.fixture(autouse=True)\ndef isolation(fn_isolation):\n    pass\n\n\ndef execute_proposal(environment, targets, values, calldatas):\n    environment.governor.propose(targets, values, calldatas, {\"from\": environment.multisig})\n    chain.mine(1)\n    environment.governor.castVote(1, True, {\"from\": environment.multisig})\n    chain.mine(GovernanceConfig[\"governorConfig\"][\"votingPeriodBlocks\"])\n\n    assert environment.governor.state(1) == 4  # success\n    delay = environment.governor.getMinDelay()\n    environment.governor.queueProposal(1, targets, values, calldatas)\n    chain.mine(1, timestamp=chain.time() + delay)\n    txn = environment.governor.executeProposal(1, targets, values, calldatas)\n    return txn\n\n\ndef test_note_token_initial_balances(environment, accounts):\n    assert environment.noteERC20.balanceOf(environment.deployer.address) == 0\n    assert (\n        environment.noteERC20.balanceOf(environment.governor.address)\n        == GovernanceConfig[\"initialBalances\"][\"DAO\"]\n    )\n    assert (\n        environment.noteERC20.balanceOf(environment.multisig.address)\n        == GovernanceConfig[\"initialBalances\"][\"MULTISIG\"]\n    )\n\n    assert (\n        environment.noteERC20.balanceOf(environment.notional.address)\n        == GovernanceConfig[\"initialBalances\"][\"NOTIONAL\"]\n    )\n\n    assert (\n        GovernanceConfig[\"initialBalances\"][\"DAO\"]\n        + GovernanceConfig[\"initialBalances\"][\"MULTISIG\"]\n        + GovernanceConfig[\"initialBalances\"][\"NOTIONAL\"]\n        == environment.noteERC20.totalSupply()\n    )\n\n\ndef test_note_token_cannot_reinitialize(environment, accounts):\n    with brownie.reverts():\n        environment.noteERC20.initialize(\n            [accounts[2].address],\n            [100_000_000e8],\n            accounts[2].address,\n            {\"from\": environment.deployer},\n        )\n\n\ndef test_governor_must_update_parameters_via_governance(environment, accounts):\n    with brownie.reverts():\n        environment.governor.updateQuorumVotes(0, {\"from\": environment.deployer})\n\n    with brownie.reverts():\n        environment.governor.updateProposalThreshold(0, {\"from\": environment.deployer})\n\n    with brownie.reverts():\n        environment.governor.updateVotingDelayBlocks(0, {\"from\": environment.deployer})\n\n    with brownie.reverts():\n        environment.governor.updateVotingPeriodBlocks(0, {\"from\": environment.deployer})\n\n    with brownie.reverts():\n        environment.governor.updateDelay(0, {\"from\": environment.deployer})\n\n\ndef test_update_governance_parameters(environment, accounts):\n    environment.noteERC20.delegate(environment.multisig, {\"from\": environment.multisig})\n\n    targets = [environment.governor.address] * 5\n    values = [0] * 5\n    calldatas = [\n        web3.eth.contract(abi=environment.governor.abi).encodeABI(\n            fn_name=\"updateQuorumVotes\", args=[0]\n        ),\n        web3.eth.contract(abi=environment.governor.abi).encodeABI(\n            fn_name=\"updateProposalThreshold\", args=[0]\n        ),\n        web3.eth.contract(abi=environment.governor.abi).encodeABI(\n            fn_name=\"updateVotingDelayBlocks\", args=[0]\n        ),\n        web3.eth.contract(abi=environment.governor.abi).encodeABI(\n            fn_name=\"updateVotingPeriodBlocks\", args=[0]\n        ),\n        web3.eth.contract(abi=environment.governor.abi).encodeABI(fn_name=\"updateDelay\", args=[0]),\n    ]\n\n    txn = execute_proposal(environment, targets, values, calldatas)\n\n    assert txn.events[\"UpdateQuorumVotes\"][\"newQuorumVotes\"] == 0\n    assert txn.events[\"UpdateProposalThreshold\"][\"newProposalThreshold\"] == 0\n    assert txn.events[\"UpdateVotingDelayBlocks\"][\"newVotingDelayBlocks\"] == 0\n    assert txn.events[\"UpdateVotingPeriodBlocks\"][\"newVotingPeriodBlocks\"] == 0\n\n    assert environment.governor.quorumVotes() == 0\n    assert environment.governor.proposalThreshold() == 0\n    assert environment.governor.votingDelayBlocks() == 0\n    assert environment.governor.votingPeriodBlocks() == 0\n    assert environment.governor.getMinDelay() == 0\n\n\ndef test_note_token_transfer_to_reservoir_and_drip(environment, accounts, Reservoir):\n    # TODO: where should this go?\n    environment.noteERC20.delegate(environment.multisig, {\"from\": environment.multisig})\n\n    reservoir = Reservoir.deploy(\n        1e8,\n        environment.noteERC20.address,\n        environment.proxy.address,\n        {\"from\": environment.deployer},\n    )\n\n    transferToReservoir = web3.eth.contract(abi=environment.noteERC20.abi).encodeABI(\n        fn_name=\"transfer\", args=[reservoir.address, int(1_000_000e8)]\n    )\n\n    targets = [environment.noteERC20.address]\n    values = [0]\n    calldatas = [transferToReservoir]\n\n    execute_proposal(environment, targets, values, calldatas)\n\n    assert environment.noteERC20.balanceOf(reservoir.address) == 1_000_000e8\n\n    proxyBalanceBefore = environment.noteERC20.balanceOf(environment.proxy.address)\n    blockTime = chain.time()\n    reservoir.drip()\n    proxyBalanceAfter = environment.noteERC20.balanceOf(environment.proxy.address)\n    assert proxyBalanceAfter - proxyBalanceBefore == (blockTime - reservoir.DRIP_START()) * 1e8\n\n    blockTime2 = chain.time()\n    reservoir.drip()\n    proxyBalanceAfterSecondDrip = environment.noteERC20.balanceOf(environment.proxy.address)\n    assert proxyBalanceAfterSecondDrip - proxyBalanceAfter == (blockTime2 - blockTime) * 1e8\n\n\ndef test_cancel_proposal_non_pending(environment, accounts):\n    environment.noteERC20.delegate(environment.multisig, {\"from\": environment.multisig})\n\n    transferTokens = web3.eth.contract(abi=environment.noteERC20.abi).encodeABI(\n        fn_name=\"transfer\", args=[accounts[3].address, int(1_000_000e8)]\n    )\n\n    targets = [environment.noteERC20.address]\n    values = [0]\n    calldatas = [transferTokens]\n\n    environment.governor.propose(targets, values, calldatas, {\"from\": environment.multisig})\n    environment.governor.cancelProposal(1, {\"from\": environment.multisig})\n    assert environment.governor.state(1) == 2  # canceled\n    assert not environment.governor.isOperation(environment.governor.proposals(1)[-1])\n\n    delay = environment.governor.getMinDelay()\n    chain.mine(1, timestamp=chain.time() + delay)\n\n    with brownie.reverts():\n        # This cannot occur, proposal cancelled\n        environment.governor.executeProposal(1, targets, values, calldatas)\n\n\ndef test_cancel_proposal_pending(environment, accounts):\n    environment.noteERC20.delegate(environment.multisig, {\"from\": environment.multisig})\n\n    transferTokens = web3.eth.contract(abi=environment.noteERC20.abi).encodeABI(\n        fn_name=\"transfer\", args=[accounts[3].address, int(1_000_000e8)]\n    )\n\n    targets = [environment.noteERC20.address]\n    values = [0]\n    calldatas = [transferTokens]\n\n    environment.governor.propose(targets, values, calldatas, {\"from\": environment.multisig})\n    chain.mine(1)\n    environment.governor.castVote(1, True, {\"from\": environment.multisig})\n    chain.mine(GovernanceConfig[\"governorConfig\"][\"votingPeriodBlocks\"])\n\n    assert environment.governor.state(1) == 4  # success\n    environment.governor.queueProposal(1, targets, values, calldatas)\n    assert environment.governor.isOperation(environment.governor.proposals(1)[-1])\n\n    environment.governor.cancelProposal(1, {\"from\": environment.multisig})\n    assert environment.governor.state(1) == 2  # canceled\n    assert not environment.governor.isOperation(environment.governor.proposals(1)[-1])\n\n    delay = environment.governor.getMinDelay()\n    chain.mine(1, timestamp=chain.time() + delay * 2)\n\n    with brownie.reverts():\n        # This cannot occur, proposal cancelled\n        environment.governor.executeProposal(1, targets, values, calldatas)\n\n\ndef test_note_token_reservoir_fails_on_zero(environment, accounts):\n    pass\n\n\ndef test_upgrade_router_contract(environment, accounts):\n    pass\n\n\ndef test_upgrade_governance_contract(environment, accounts):\n    pass\n\n\ndef test_delegation(environment, accounts):\n    pass"
    }
  ]
}