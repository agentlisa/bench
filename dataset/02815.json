{
  "Title": "M-8: The Pendle version of `lend()` uses the wrong function for swapping fee-on-transfer tokens",
  "Content": "# Issue M-8: The Pendle version of `lend()` uses the wrong function for swapping fee-on-transfer tokens \n\nSource: https://github.com/sherlock-audit/2022-10-illuminate-judging/issues/105 \n\n## Found by \nIllIllI\n\n## Summary\n\nThe Pendle version of `lend()` uses the wrong function for swapping fee-on-transfer tokens\n\n\n## Vulnerability Detail\nThe Pendle version of `lend()` is not able to handle fee-on-transfer tokens properly (USDT is a fee-on-transfer token which is [supported](https://github.com/sherlock-audit/2022-10-illuminate/blob/main/test/fork/Contracts.sol#L61-L62)) and pulls out the contract's fee balance (I've filed this issue separately). Once that is fixed there still is the fact that the Pendle version uses the wrong Sushiswap function (the Pendle router is a Sushiswap router). The function uses `swapExactTokensForTokens()` when it should use [`swapExactTokensForTokensSupportingFeeOnTransferTokens()`](https://github.com/sushiswap/sushiswap/blob/99c16c262f70a1ea8b6583c08c51f176eeb8f521/protocols/sushiswap/contracts/UniswapV2Router02.sol#L340-L346) instead.\n\n\n## Impact\n_Smart contract unable to operate due to lack of token funds_\n\nUsers will be unable to use the Pendle version of `lend()` when the underlying is a fee-on-transfer token with the fee turned on (USDT currently has the fee turned off, but they can turn it on at any moment).\n\n## Code Snippet\n\nThe pulling in of the amount by `IPendle` will either take part of the Illuminate protocol fees, or will revert if there is not enough underlying after the fee is applied for the Sushiswap transfer (depending on which fee-on-transfer fix is applied for the other issue I filed):\n```solidity\n// File: src/Lender.sol : Lender.lend()   #1\n\n541                address[] memory path = new address[](2);\n542                path[0] = u;\n543                path[1] = principal;\n544    \n545                // Swap on the Pendle Router using the provided market and params\n546 @>             returned = IPendle(pendleAddr).swapExactTokensForTokens(\n547 @>                 a - fee,\n548 @>                 r,\n549 @>                 path,\n550 @>                 address(this),\n551 @>                 d\n552 @>             )[1];\n553            }\n554    \n555            // Mint Illuminate zero coupons\n556            IERC5095(principalToken(u, m)).authMint(msg.sender, returned);\n557    \n558            emit Lend(p, u, m, returned, a, msg.sender);\n559            return returned;\n560:       }\n```\nhttps://github.com/sherlock-audit/2022-10-illuminate/blob/main/src/Lender.sol#L536-L560\n\n\n## Tool used\n\nManual Review\n\n## Recommendation\nUse `swapExactTokensForTokensSupportingFeeOnTransferTokens()`\n\n## Discussion\n\n**JTraversa**\n\nSame as #116 \n\n**0x00052**\n\nEscalate for 1 USDC\n\nReminder @Evert0x \n\n**sherlock-admin**\n\n > Escalate for 1 USDC\n> \n> Reminder @Evert0x \n\nYou've created a valid escalation for 1 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/12",
  "Code": [
    {
      "filename": "test/fork/Contracts.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.16;\n\nlibrary Contracts {\n    // Sent to the lender contract constructor\n    // Swivel.sol v2 deployed contract\n    address constant SWIVEL = 0x093e4D20D9b2c3c8f68E8a20262D8Fb8EBCE08FA;\n    // Sushiswap router (https://docs.sushi.com/docs/Developers/Deployment%20Addresses)\n    // note used on lender\n    address constant PENDLE = 0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F;\n    // note used on redeemer\n    address constant PENDLE_ROUTER = 0x1b6d3E5Da9004668E14Ca39d1553E9a46Fe842B3;\n    // https://docs.tempus.finance/docs/deployed-contracts (controller)\n    address constant TEMPUS = 0xdB5fD0678eED82246b599da6BC36B56157E4beD8;\n\n    // Prinicpal Tokens---------------------------------------------------------\n    // Notional deployed contracts: https://docs.notional.finance/developer-documentation/\n    // NOTE this is the DAI wrapped-fcash address\n    address constant NOTIONAL_TOKEN =\n        0xfcB060E09e452EEFf142949Bec214c187CDF25fA;\n    // Via the marketplace's markets call with USDC underlying and a maturity of 1664550000 (v2)\n    address constant SWIVEL_TOKEN = 0xC812c7aA52c97FacdE14b7FfFf4e0A9b1a1Dd179;\n    // Via sushi swap market (Dec 2022 - https://app.pendle.finance/market)\n    address constant PENDLE_TOKEN = 0x8fcb1783bF4b71A51F702aF0c266729C4592204a;\n    // via contracts.json (https://etherscan.io/address/0x53C2a1bA37FF3cDaCcb3EA030DB3De39358e5593#readContract)\n    address constant YIELD_TOKEN = 0x53C2a1bA37FF3cDaCcb3EA030DB3De39358e5593;\n    // (principal share) https://etherscan.io/address/0xb3ec7facb30b163b1375285ea7ebfeefc41920b9#readContract\n    address constant TEMPUS_TOKEN = 0xB3EC7FACb30b163b1375285EA7EbfEeFc41920B9;\n    // NOTE for apwine, we have to use the amm pool to get the APWine token. From there, we use the PT that the\n    // amm points to in order to continue with verification purposes\n    // AMM Registry -> getFutureVaultAt(futureVaultAt via ProtocolRegistry) -> getFutureAMMPool\n    address constant APWINE_AMM_POOL =\n        0xb932c4801240753604c768c991eb640BCD7C06EB;\n    // (element token) https://app.element.fi/fixedrates/0xCFe60a1535ecc5B0bc628dC97111C8bb01637911\n    address constant ELEMENT_TOKEN = 0xf38c3E836Be9cD35072055Ff6a9Ba570e0B70797;\n    // (sense adapter)\n    // NOTE for sense, we have to use the adapter contract to verify the underlying/maturity\n    // NOTE also we had to use the wsteth pools.... (maturity: 1659312000)\n    address constant SENSE_ADAPTER = 0x880E5caBB22D24F3E278C4C760e763f239AccA95;\n\n    // Misc. contracts/values --------------------------------------------------\n    // found via etherscan via contracts.json or something\n    address constant YIELD_POOL_USDC =\n        0xf5Fd5A9Db9CcCc6dc9f5EF1be3A859C39983577C;\n    address constant YIELD_POOL_USDC_2 = // DEC 22\n        0xB2fff7FEA1D455F0BCdd38DA7DeE98af0872a13a;\n    address constant YIELD_POOL_DAI =\n        0x6BaC09a67Ed1e1f42c29563847F77c28ec3a04FC;\n    // (amm) https://etherscan.io/address/0x811f4F0241A9A4583C052c08BDA7F6339DBb13f7#readContract\n    address constant TEMPUS_AMM = 0x811f4F0241A9A4583C052c08BDA7F6339DBb13f7;\n    // (pool) https://etherscan.io/address/0x443297de16c074fdee19d2c9ecf40fde2f5f62c2#readContract\n    address constant TEMPUS_POOL = 0x443297DE16C074fDeE19d2C9eCF40fdE2f5F62C2;\n\n    // (pool) https://etherscan.io/address/0xf5ba2E5DdED276fc0f7a7637A61157a4be79C626#writeProxyContract\n    address constant APWINE_ROUTER = 0xf5ba2E5DdED276fc0f7a7637A61157a4be79C626;\n    // (pool id) via getFutureVaultAt in Protocol Registry (https://docs.apwine.fi/dev/introduction/deployed-contracts)\n    // APWINE POOL ID is 4 (for tests)\n    // (controller, used to call getNextPeriodStart (for maturity check))\n    address constant APWINE_CONTROLLER =\n        0x4bA30FA240047c17FC557b8628799068d4396790;\n    // (apwine PT - USDT market) https://etherscan.io/address/0x2b8692963c8ec4cdf30047a20f12c43e4d9aef6c\n    address constant APWINE_TOKEN = 0x2d31591f7a650579125bC9BC1622E07fFD219033;\n    address constant APWINE_FUTURE_VAULT = 0xb524c16330A76182Ef617F08F5E6996f577AC64A;\n    // (element router)\n    address constant ELEMENT_VAULT = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;\n    // (element USDC pool) https://raw.githubusercontent.com/element-fi/elf-deploy/main/changelog/releases/mainnet/v1.1.0:7/addresses.json\n    // tranches -> usdc -> ptPool -> poolId\n    bytes32 constant ELEMENT_POOL_ID =\n        0x787546bf2c05e3e19e2b6bde57a203da7f682eff00020000000000000000007c;\n\n    // aUSDC in this case\n    address constant PENDLE_UNDERLYING_YIELD_TOKEN =\n        0xBcca60bB61934080951369a648Fb03DF4F96263C;\n\n    // (sense periphery (executes swap)) https://docs.sense.finance/developers/deployed-contracts/\n    address constant SENSE_PERIPHERY =\n        0xFff11417a58781D3C72083CB45EF54d79Cd02437;\n    address constant SENSE_TOKEN = 0x6BEf7922EBA9fDd6BEca781cD21E3a25f872Aa97;\n    uint256 constant SENSE_MATURITY = 1659312000;\n    address constant SENSE_DIVIDER = 0x86bA3E96Be68563E41c2f5769F1AF9fAf758e6E0;\n    uint256 constant SENSE_VALID_SETTLEMENT_TS = 1659322801;\n\n    // Underlyings--------------------------------------------------------------\n    address constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n    // https://api-main.swivel.exchange/v2/markets?status=active\n    address constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    // Foundry specific\n    address constant DEPLOYER = 0xb4c79daB8f259C7Aee6E5b2Aa729821864227e84;\n\n    // converter tokens\n    address constant AUSDC = 0xBcca60bB61934080951369a648Fb03DF4F96263C;\n    address constant CUSDC = 0x39AA39c021dfbaE8faC545936693aC917d5E7563;\n    address constant AAVE_POOL = 0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9;\n    address constant WSTETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;\n    address constant STETH = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;\n    address constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n    address constant CDAI = 0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643;\n\n    address constant EUDAI = 0xe025E3ca2bE02316033184551D4d3Aa22024D9DC;\n}"
    },
    {
      "filename": "src/Lender.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.16;\n\nimport 'src/MarketPlace.sol'; // library of MarketPlace specific constructs\nimport 'src/lib/Swivel.sol'; // library of Swivel specific constructs\nimport 'src/lib/Element.sol'; // library of Element specific constructs\nimport 'src/lib/Safe.sol';\nimport 'src/lib/Cast.sol';\nimport 'src/lib/RevertMsgExtractor.sol';\nimport 'src/errors/Exception.sol';\n\nimport 'src/interfaces/ITempus.sol';\nimport 'src/interfaces/ITempusAMM.sol';\nimport 'src/interfaces/ITempusPool.sol';\nimport 'src/interfaces/ITempusToken.sol';\nimport 'src/interfaces/IERC20.sol';\nimport 'src/interfaces/IERC5095.sol';\nimport 'src/interfaces/ISensePeriphery.sol';\nimport 'src/interfaces/ISenseAdapter.sol';\nimport 'src/interfaces/ISenseDivider.sol';\nimport 'src/interfaces/IERC20.sol';\nimport 'src/interfaces/IYield.sol';\nimport 'src/interfaces/IYieldToken.sol';\nimport 'src/interfaces/ISwivel.sol';\nimport 'src/interfaces/IElementToken.sol';\nimport 'src/interfaces/IElementVault.sol';\nimport 'src/interfaces/ISwivel.sol';\nimport 'src/interfaces/IAPWineAMMPool.sol';\nimport 'src/interfaces/IAPWineRouter.sol';\nimport 'src/interfaces/IAPWineToken.sol';\nimport 'src/interfaces/IAPWineFutureVault.sol';\nimport 'src/interfaces/IAPWineController.sol';\nimport 'src/interfaces/INotional.sol';\nimport 'src/interfaces/IPendle.sol';\nimport 'src/interfaces/IPendleToken.sol';\n\n/// @title Lender\n/// @author Sourabh Marathe, Julian Traversa, Rob Robbins\n/// @notice The lender contract executes loans on behalf of users\n/// @notice The contract holds the principal tokens and mints an ERC-5095 tokens to users to represent their loans\ncontract Lender {\n    /// @notice minimum wait before the admin may withdraw funds or change the fee rate\n    uint256 public constant HOLD = 3 days;\n\n    /// @notice address that is allowed to set and withdraw fees, disable principals, etc. It is commonly used in the authorized modifier.\n    address public admin;\n    /// @notice address of the MarketPlace contract, used to access the markets mapping\n    address public marketPlace;\n    /// @notice mapping that determines if a principal token has been paused by the admin\n    mapping(address => mapping(uint256 => bool[9])) public paused;\n\n    /// @notice contract used to execute swaps on Swivel's exchange\n    address public immutable swivelAddr;\n    /// @notice a SushiSwap router used by Pendle to execute swaps\n    address public immutable pendleAddr;\n\n    /// @notice this value determines the amount of fees paid on loans\n    uint256 public feenominator;\n    /// @notice represents a point in time where the feenominator may change\n    uint256 public feeChange;\n    /// @notice represents a minimum that the feenominator must exceed\n    uint256 public constant MIN_FEENOMINATOR = 500;\n\n    /// @notice maps underlying tokens to the amount of fees accumulated for that token\n    mapping(address => uint256) public fees;\n    /// @notice maps a token address to a point in time, a hold, after which a withdrawal can be made\n    mapping(address => uint256) public withdrawals;\n\n    /// @notice emitted upon lending to a protocol\n    event Lend(\n        uint8 principal,\n        address indexed underlying,\n        uint256 indexed maturity,\n        uint256 returned,\n        uint256 spent,\n        address sender\n    );\n    /// @notice emitted upon minting Illuminate principal tokens\n    event Mint(\n        uint8 principal,\n        address indexed underlying,\n        uint256 indexed maturity,\n        uint256 amount\n    );\n    /// @notice emitted upon scheduling a withdrawal\n    event ScheduleWithdrawal(address indexed token, uint256 hold);\n    /// @notice emitted upon blocking a scheduled withdrawal\n    event BlockWithdrawal(address indexed token);\n    /// @notice emitted upon changing the admin\n    event SetAdmin(address indexed admin);\n    /// @notice emitted upon setting the fee rate\n    event SetFee(uint256 indexed fee);\n    /// @notice emitted upon scheduling a fee change\n    event ScheduleFeeChange(uint256 when);\n    /// @notice emitted upon blocking a scheduled fee change\n    event BlockFeeChange();\n    /// @notice emitted upon pausing or unpausing of a principal token\n    event PauseMarket(\n        uint8 principal,\n        address indexed underlying,\n        uint256 indexed maturity,\n        address token,\n        bool indexed state\n    );\n\n    /// @notice ensures that only a certain address can call the function\n    /// @param a address that msg.sender must be to be authorized\n    modifier authorized(address a) {\n        if (msg.sender != a) {\n            revert Exception(0, 0, 0, msg.sender, a);\n        }\n        _;\n    }\n\n    /// @notice reverts on all markets where the paused mapping returns true\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    modifier unpaused(\n        address u,\n        uint256 m,\n        uint8 p\n    ) {\n        if (paused[u][m][p]) {\n            revert Exception(1, p, 0, address(0), address(0));\n        }\n        _;\n    }\n\n    /// @notice initializes the Lender contract\n    /// @param s the Swivel contract\n    /// @param p the Pendle contract\n    constructor(address s, address p) {\n        admin = msg.sender;\n        swivelAddr = s;\n        pendleAddr = p;\n        feenominator = 1000;\n    }\n\n    /// @notice approves the redeemer contract to spend the principal tokens held by the lender contract.\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param r the address being approved, in this case the redeemer contract\n    /// @return bool true if the approval was successful\n    function approve(\n        address u,\n        uint256 m,\n        address r\n    ) external authorized(admin) returns (bool) {\n        // approve the underlying for max per given principal\n        for (uint8 i; i != 9; ) {\n            // get the principal token's address\n            address token = IMarketPlace(marketPlace).token(u, m, i);\n            // check that the token is defined for this particular market\n            if (token != address(0)) {\n                // max approve the token\n                Safe.approve(IERC20(token), r, type(uint256).max);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        return true;\n    }\n\n    /// @notice bulk approves the usage of addresses at the given ERC20 addresses.\n    /// @dev the lengths of the inputs must match because the arrays are paired by index\n    /// @param u array of ERC20 token addresses that will be approved on\n    /// @param a array of addresses that will be approved\n    /// @return true if successful\n    function approve(address[] calldata u, address[] calldata a)\n        external\n        authorized(admin)\n        returns (bool)\n    {\n        for (uint256 i; i != u.length; ) {\n            IERC20 uToken = IERC20(u[i]);\n            if (address(0) != (address(uToken))) {\n                Safe.approve(uToken, a[i], type(uint256).max);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        return true;\n    }\n\n    /// @notice approves market contracts that require lender approval\n    /// @param u address of an underlying asset\n    /// @param a APWine's router contract\n    /// @param e Element's vault contract\n    /// @param n Notional's token contract\n    function approve(\n        address u,\n        address a,\n        address e,\n        address n\n    ) external authorized(marketPlace) {\n        uint256 max = type(uint256).max;\n        IERC20 uToken = IERC20(u);\n        if (a != address(0)) {\n            Safe.approve(uToken, a, max);\n        }\n        if (e != address(0)) {\n            Safe.approve(uToken, e, max);\n        }\n        if (n != address(0)) {\n            Safe.approve(uToken, n, max);\n        }\n        if (IERC20(u).allowance(address(this), swivelAddr) == 0) {\n            Safe.approve(uToken, swivelAddr, max);\n        }\n    }\n\n    /// @notice sets the admin address\n    /// @param a address of a new admin\n    /// @return bool true if successful\n    function setAdmin(address a) external authorized(admin) returns (bool) {\n        admin = a;\n        emit SetAdmin(a);\n        return true;\n    }\n\n    /// @notice sets the feenominator to the given value\n    /// @param f the new value of the feenominator, fees are not collected when the feenominator is 0\n    /// @return bool true if successful\n    function setFee(uint256 f) external authorized(admin) returns (bool) {\n        uint256 feeTime = feeChange;\n        if (feeTime == 0) {\n            revert Exception(23, 0, 0, address(0), address(0));\n        } else if (block.timestamp < feeTime) {\n            revert Exception(\n                24,\n                block.timestamp,\n                feeTime,\n                address(0),\n                address(0)\n            );\n        } else if (f < MIN_FEENOMINATOR) {\n            revert Exception(25, 0, 0, address(0), address(0));\n        }\n        feenominator = f;\n        delete feeChange;\n        emit SetFee(f);\n        return true;\n    }\n\n    /// @notice sets the address of the marketplace contract which contains the addresses of all the fixed rate markets\n    /// @param m the address of the marketplace contract\n    /// @return bool true if the address was set\n    function setMarketPlace(address m)\n        external\n        authorized(admin)\n        returns (bool)\n    {\n        if (marketPlace != address(0)) {\n            revert Exception(5, 0, 0, marketPlace, address(0));\n        }\n        marketPlace = m;\n        return true;\n    }\n\n    /// @notice mint swaps the sender's principal tokens for Illuminate's ERC5095 tokens in effect, this opens a new fixed rate position for the sender on Illuminate\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount being minted\n    /// @return bool true if the mint was successful\n    function mint(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a\n    ) external unpaused(u, m, p) returns (bool) {\n        // Fetch the desired principal token\n        address principal = IMarketPlace(marketPlace).token(u, m, p);\n\n        // Transfer the users principal tokens to the lender contract\n        Safe.transferFrom(IERC20(principal), msg.sender, address(this), a);\n\n        // Mint the tokens received from the user\n        IERC5095(principalToken(u, m)).authMint(msg.sender, a);\n\n        emit Mint(p, u, m, a);\n\n        return true;\n    }\n\n    /// @notice lend method for the Illuminate and Yield protocols\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying tokens to lend\n    /// @param y Yield Space Pool for the principal token\n    /// @param minimum slippage limit, minimum amount to PTs to buy\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        address y,\n        uint256 minimum\n    ) external unpaused(u, m, p) returns (uint256) {\n        // Check that the principal is Illuminate or Yield\n        if (\n            p != uint8(MarketPlace.Principals.Illuminate) &&\n            p != uint8(MarketPlace.Principals.Yield)\n        ) {\n            revert Exception(6, 0, 0, address(0), address(0));\n        }\n\n        // Get principal token for this market\n        address principal = IMarketPlace(marketPlace).token(u, m, p);\n\n        // Extract fee\n        fees[u] = fees[u] + a / feenominator;\n\n        // Transfer underlying from user to the lender contract\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        if (p == uint8(MarketPlace.Principals.Yield)) {\n            // Make sure the Yield Space Pool matches principal token\n            address fyToken = IYield(y).fyToken();\n            if (IYield(y).fyToken() != principal) {\n                revert Exception(12, 0, 0, fyToken, principal);\n            }\n        }\n\n        // Swap underlying for PTs to lender\n        uint256 returned = yield(\n            u,\n            y,\n            a - a / feenominator,\n            address(this),\n            principal,\n            minimum\n        );\n\n        // Mint Illuminate PTs to msg.sender\n        IERC5095(principalToken(u, m)).authMint(msg.sender, returned);\n\n        emit Lend(p, u, m, returned, a, msg.sender);\n\n        return returned;\n    }\n\n    /// @notice lend method signature for Swivel\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a array of amounts of underlying tokens lent to each order in the orders array\n    /// @param y Yield Space Pool for the Illuminate PT in this market\n    /// @param o array of Swivel orders being filled\n    /// @param s array of signatures for each order in the orders array\n    /// @param e flag to indicate if returned funds should be swapped in Yield Space Pool\n    /// @param premiumSlippage slippage limit, minimum amount to PTs to buy\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256[] memory a,\n        address y,\n        Swivel.Order[] calldata o,\n        Swivel.Components[] calldata s,\n        bool e,\n        uint256 premiumSlippage\n    ) external unpaused(u, m, p) returns (uint256) {\n        {\n            // Check that the principal is Swivel\n            if (p != uint8(MarketPlace.Principals.Swivel)) {\n                revert Exception(\n                    6,\n                    p,\n                    uint8(MarketPlace.Principals.Swivel),\n                    address(0),\n                    address(0)\n                );\n            }\n\n            // Lent represents the total amount of underlying to be lent\n            uint256 lent = swivelAmount(a);\n\n            // Transfer underlying token from user to Illuminate\n            Safe.transferFrom(IERC20(u), msg.sender, address(this), lent);\n\n            // Get the underlying balance prior to calling initiate\n            uint256 starting = IERC20(u).balanceOf(address(this));\n\n            // Verify and collect the fee\n            {\n                // Calculate fee for the total amount to be lent\n                uint256 fee = lent / feenominator;\n\n                // Get last order to be processed's index\n                uint256 lastIndex = a.length - 1;\n\n                // Add the accumulated fees to the total\n                a[lastIndex] = a[lastIndex] - fee; // Revert here if fee not paid\n\n                // Extract fee\n                fees[u] += fee;\n            }\n\n            uint256 received;\n            {\n                // Get the starting amount of principal tokens\n                uint256 startingZcTokens = IERC20(\n                    IMarketPlace(marketPlace).token(u, m, p)\n                ).balanceOf(address(this));\n\n                // Fill the given orders on Swivel\n                ISwivel(swivelAddr).initiate(o, a, s);\n\n                if (e) {\n                    // Calculate the premium\n                    uint256 premium = IERC20(u).balanceOf(address(this)) -\n                        starting;\n\n                    // Swap the premium for Illuminate principal tokens\n                    swivelLendPremium(u, m, y, premium, premiumSlippage);\n                }\n\n                // Compute how many principal tokens were received\n                received =\n                    IERC20(IMarketPlace(marketPlace).token(u, m, p)).balanceOf(\n                        address(this)\n                    ) -\n                    startingZcTokens;\n            }\n\n            // Mint Illuminate principal tokens to the user\n            IERC5095(principalToken(u, m)).authMint(msg.sender, received);\n\n            {\n                emit Lend(\n                    uint8(MarketPlace.Principals.Swivel),\n                    u,\n                    m,\n                    received,\n                    lent,\n                    msg.sender\n                );\n            }\n            return received;\n        }\n    }\n\n    /// @notice lend method signature for Element\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying tokens to lend\n    /// @param r slippage limit, minimum amount to PTs to buy\n    /// @param d deadline is a timestamp by which the swap must be executed\n    /// @param e Element pool that is lent to\n    /// @param i the id of the pool\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 r,\n        uint256 d,\n        address e,\n        bytes32 i\n    ) external unpaused(u, m, p) returns (uint256) {\n        // Get the principal token for this market for Element\n        address principal = IMarketPlace(marketPlace).token(u, m, p);\n\n        // Transfer underlying token from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        // Track the accumulated fees\n        fees[u] = fees[u] + a / feenominator;\n\n        uint256 purchased;\n        {\n            // Calculate the amount to be lent\n            uint256 lent = a - a / feenominator;\n\n            // Create the variables needed to execute an Element swap\n            Element.FundManagement memory fund = Element.FundManagement({\n                sender: address(this),\n                recipient: payable(address(this)),\n                fromInternalBalance: false,\n                toInternalBalance: false\n            });\n\n            Element.SingleSwap memory swap = Element.SingleSwap({\n                poolId: i,\n                amount: lent,\n                kind: Element.SwapKind.GIVEN_IN,\n                assetIn: IAny(u),\n                assetOut: IAny(principal),\n                userData: '0x00000000000000000000000000000000000000000000000000000000000000'\n            });\n\n            // Conduct the swap on Element\n            purchased = elementSwap(e, swap, fund, r, d);\n        }\n\n        // Mint tokens to the user\n        IERC5095(principalToken(u, m)).authMint(msg.sender, purchased);\n\n        emit Lend(p, u, m, purchased, a, msg.sender);\n        return purchased;\n    }\n\n    /// @notice lend method signature for Pendle\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying tokens to lend\n    /// @param r slippage limit, minimum amount to PTs to buy\n    /// @param d deadline is a timestamp by which the swap must be executed\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 r,\n        uint256 d\n    ) external unpaused(u, m, p) returns (uint256) {\n        // Instantiate market and tokens\n        address principal = IMarketPlace(marketPlace).token(u, m, p);\n\n        // Transfer funds from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        uint256 returned;\n        {\n            // Add the accumulated fees to the total\n            uint256 fee = a / feenominator;\n            fees[u] = fees[u] + fee;\n\n            address[] memory path = new address[](2);\n            path[0] = u;\n            path[1] = principal;\n\n            // Swap on the Pendle Router using the provided market and params\n            returned = IPendle(pendleAddr).swapExactTokensForTokens(\n                a - fee,\n                r,\n                path,\n                address(this),\n                d\n            )[1];\n        }\n\n        // Mint Illuminate zero coupons\n        IERC5095(principalToken(u, m)).authMint(msg.sender, returned);\n\n        emit Lend(p, u, m, returned, a, msg.sender);\n        return returned;\n    }\n\n    /// @notice lend method signature for APWine\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying tokens to lend\n    /// @param r slippage limit, minimum amount to PTs to buy\n    /// @param d deadline is a timestamp by which the swap must be executed\n    /// @param x APWine router that executes the swap\n    /// @param pool the AMM pool used by APWine to execute the swap\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 r,\n        uint256 d,\n        address x,\n        address pool\n    ) external unpaused(u, m, p) returns (uint256) {\n        address principal = IMarketPlace(marketPlace).token(u, m, p);\n\n        // Transfer funds from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        uint256 lent;\n        {\n            // Add the accumulated fees to the total\n            uint256 fee = a / feenominator;\n            fees[u] = fees[u] + fee;\n\n            // Calculate amount to be lent out\n            lent = a - fee;\n        }\n\n        // Get the starting APWine token balance\n        uint256 starting = IERC20(principal).balanceOf(address(this));\n\n        // Swap on the APWine Pool using the provided market and params\n        IAPWineRouter(x).swapExactAmountIn(\n            pool,\n            apwinePairPath(),\n            apwineTokenPath(),\n            lent,\n            r,\n            address(this),\n            d,\n            address(0)\n        );\n\n        // Calculate the amount of APWine principal tokens received after the swap\n        uint256 received = IERC20(principal).balanceOf(address(this)) -\n            starting;\n\n        // Mint Illuminate zero coupons\n        IERC5095(principalToken(u, m)).authMint(msg.sender, received);\n\n        emit Lend(p, u, m, received, a, msg.sender);\n        return received;\n    }\n\n    /// @notice lend method signature for Tempus\n    /// @param p value of a specific principal according to the Illuminate Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of principal tokens to lend\n    /// @param r minimum amount to return when executing the swap (sets a limit to slippage)\n    /// @param d deadline is a timestamp by which the swap must be executed\n    /// @param x Tempus AMM that executes the swap\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 r,\n        uint256 d,\n        address x\n    ) external unpaused(u, m, p) returns (uint256) {\n        address principal = IMarketPlace(marketPlace).token(u, m, p);\n\n        // Transfer funds from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        uint256 lent;\n        {\n            // Add the accumulated fees to the total\n            uint256 fee = a / feenominator;\n            fees[u] = fees[u] + fee;\n\n            // Calculate amount to be lent out\n            lent = a - fee;\n        }\n\n        // Get the starting balance of the principal token\n        uint256 start = IERC20(principal).balanceOf(address(this));\n\n        // Get the Tempus Router from the principal token\n        address controller = ITempusPool(ITempusToken(principal).pool())\n            .controller();\n\n        // Swap on the Tempus Router using the provided market and params\n        ITempus(controller).depositAndFix(x, lent, true, r, d);\n\n        // Calculate the amount of Tempus principal tokens received after the deposit\n        uint256 received = IERC20(principal).balanceOf(address(this)) - start;\n\n        // Verify that a minimum number of principal tokens were received\n        if (received < r) {\n            revert Exception(11, received, r, address(0), address(0));\n        }\n\n        // Mint Illuminate zero coupons\n        IERC5095(principalToken(u, m)).authMint(msg.sender, received);\n\n        emit Lend(p, u, m, received, a, msg.sender);\n        return received;\n    }\n\n    /// @notice lend method signature for Sense\n    /// @dev this method can be called before maturity to lend to Sense while minting Illuminate tokens\n    /// @dev Sense provides a [divider] contract that splits [target] assets (underlying) into PTs and YTs. Each [target] asset has a [series] of contracts, each identifiable by their [maturity].\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying tokens to lend\n    /// @param r slippage limit, minimum amount to PTs to buy\n    /// @param x AMM that is used to conduct the swap\n    /// @param s Sense's maturity for the given market\n    /// @param adapter Sense's adapter necessary to facilitate the swap\n    /// @return uint256 the amount of principal tokens lent out\n    function lend(\n        uint8 p,\n        address u,\n        uint256 m,\n        uint128 a,\n        uint256 r,\n        address x,\n        uint256 s,\n        address adapter\n    ) external unpaused(u, m, p) returns (uint256) {\n        // Retrieve the principal token for this market\n        IERC20 token = IERC20(IMarketPlace(marketPlace).token(u, m, p));\n\n        // Transfer funds from user to Illuminate\n        Safe.transferFrom(IERC20(u), msg.sender, address(this), a);\n\n        // Determine the fee\n        uint256 fee = a / feenominator;\n\n        // Add the accumulated fees to the total\n        fees[u] = fees[u] + fee;\n\n        // Determine lent amount after fees\n        uint256 lent = a - fee;\n\n        // Stores the amount of principal tokens received in swap for underlying\n        uint256 received;\n        {\n            // Get the starting balance of the principal token\n            uint256 starting = token.balanceOf(address(this));\n\n            // Swap those t"
    }
  ]
}