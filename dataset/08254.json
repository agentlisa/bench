{
  "Title": "[7] contracts/mixins/nftDropMarket/NFTDropMarketFixedPriceSale.sol",
  "Content": "\nIn `mintFromFixedPriceSale` we can avoid the nested `if` blocks on lines [182-189](https://github.com/code-423n4/2022-08-foundation/blob/792e00df42/contracts/mixins/nftDropMarket/NFTDropMarketFixedPriceSale.sol#L182-L189). This would improve readability and analyze and it would have the same effect. On the plus side, it will also save gas for a reverting call where `saleConfig.limitPerAccount` is zero by avoiding the outer `if` block in the original code.\n\n```solidity\n// Confirm that the collection has a sale in progress.\nif (saleConfig.limitPerAccount == 0) {\n\trevert NFTDropMarketFixedPriceSale_Must_Have_Sale_In_Progress();\n}\n// Confirm that the buyer will not exceed the limit specified after minting.\nif (IERC721(nftContract).balanceOf(msg.sender) + count > saleConfig.limitPerAccount) {\t\n\trevert NFTDropMarketFixedPriceSale_Cannot_Buy_More_Than_Limit(saleConfig.limitPerAccount);\n}\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-08-foundation",
  "Code": [
    {
      "filename": "contracts/mixins/nftDropMarket/NFTDropMarketFixedPriceSale.sol",
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\n\nimport \"../../interfaces/INFTDropCollectionMint.sol\";\n\nimport \"../shared/Constants.sol\";\nimport \"../shared/MarketFees.sol\";\n\n/// @param limitPerAccount The limit of tokens an account can purchase.\nerror NFTDropMarketFixedPriceSale_Cannot_Buy_More_Than_Limit(uint256 limitPerAccount);\nerror NFTDropMarketFixedPriceSale_Limit_Per_Account_Must_Be_Set();\nerror NFTDropMarketFixedPriceSale_Mint_Permission_Required();\nerror NFTDropMarketFixedPriceSale_Must_Buy_At_Least_One_Token();\nerror NFTDropMarketFixedPriceSale_Must_Have_Sale_In_Progress();\nerror NFTDropMarketFixedPriceSale_Must_Not_Be_Sold_Out();\nerror NFTDropMarketFixedPriceSale_Must_Not_Have_Pending_Sale();\nerror NFTDropMarketFixedPriceSale_Must_Support_Collection_Mint_Interface();\nerror NFTDropMarketFixedPriceSale_Only_Callable_By_Collection_Owner();\n/// @param mintCost The total cost for this purchase.\nerror NFTDropMarketFixedPriceSale_Too_Much_Value_Provided(uint256 mintCost);\n\n/**\n * @title Allows creators to list a drop collection for sale at a fixed price point.\n * @dev Listing a collection for sale in this market requires the collection to implement\n * the functions in `INFTDropCollectionMint` and to register that interface with ERC165.\n * Additionally the collection must implement access control, or more specifically:\n * `hasRole(bytes32(0), msg.sender)` must return true when called from the creator or admin's account\n * and `hasRole(keccak256(\"MINTER_ROLE\", address(this)))` must return true for this market's address.\n */\nabstract contract NFTDropMarketFixedPriceSale is MarketFees {\n  using AddressUpgradeable for address;\n  using AddressUpgradeable for address payable;\n  using ERC165Checker for address;\n\n  /**\n   * @notice Configuration for the terms of the sale.\n   * @dev This structure is packed in order to consume just a single slot.\n   */\n  struct FixedPriceSaleConfig {\n    /**\n     * @notice The seller for the drop.\n     */\n    address payable seller;\n    /**\n     * @notice The fixed price per NFT in the collection.\n     * @dev The maximum price that can be set on an NFT is ~1.2M (2^80/10^18) ETH.\n     */\n    uint80 price;\n    /**\n     * @notice The max number of NFTs an account may have while minting.\n     */\n    uint16 limitPerAccount;\n  }\n\n  /**\n   * @notice Stores the current sale information for all drop contracts.\n   */\n  mapping(address => FixedPriceSaleConfig) private nftContractToFixedPriceSaleConfig;\n\n  /**\n   * @notice The `role` type used to validate drop collections have granted this market access to mint.\n   * @return `keccak256(\"MINTER_ROLE\")`\n   */\n  bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n  /**\n   * @notice Emitted when a collection is listed for sale.\n   * @param nftContract The address of the NFT drop collection.\n   * @param seller The address for the seller which listed this for sale.\n   * @param price The price per NFT minted.\n   * @param limitPerAccount The max number of NFTs an account may have while minting.\n   */\n  event CreateFixedPriceSale(\n    address indexed nftContract,\n    address indexed seller,\n    uint256 price,\n    uint256 limitPerAccount\n  );\n\n  /**\n   * @notice Emitted when NFTs are minted from the drop.\n   * @dev The total price paid by the buyer is `totalFees + creatorRev`.\n   * @param nftContract The address of the NFT drop collection.\n   * @param buyer The address of the buyer.\n   * @param firstTokenId The tokenId for the first NFT minted.\n   * The other minted tokens are assigned sequentially, so `firstTokenId` - `firstTokenId + count - 1` were minted.\n   * @param count The number of NFTs minted.\n   * @param totalFees The amount of ETH that was sent to Foundation & referrals for this sale.\n   * @param creatorRev The amount of ETH that was sent to the creator for this sale.\n   */\n  event MintFromFixedPriceDrop(\n    address indexed nftContract,\n    address indexed buyer,\n    uint256 indexed firstTokenId,\n    uint256 count,\n    uint256 totalFees,\n    uint256 creatorRev\n  );\n\n  /**\n   * @notice Create a fixed price sale drop.\n   * @param nftContract The address of the NFT drop collection.\n   * @param price The price per NFT minted.\n   * Set price to 0 for a first come first serve airdrop-like drop.\n   * @param limitPerAccount The max number of NFTs an account may have while minting.\n   * @dev Notes:\n   *   a) The sale is final and can not be updated or canceled.\n   *   b) The sale is immediately kicked off.\n   *   c) Any collection that abides by `INFTDropCollectionMint` and `IAccessControl` is supported.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function createFixedPriceSale(\n    address nftContract,\n    uint80 price,\n    uint16 limitPerAccount\n  ) external {\n    // Confirm the drop collection is supported\n    if (!nftContract.supportsInterface(type(INFTDropCollectionMint).interfaceId)) {\n      revert NFTDropMarketFixedPriceSale_Must_Support_Collection_Mint_Interface();\n    }\n    if (INFTDropCollectionMint(nftContract).numberOfTokensAvailableToMint() == 0) {\n      revert NFTDropMarketFixedPriceSale_Must_Not_Be_Sold_Out();\n    }\n\n    // Use the AccessControl interface to confirm the msg.sender has permissions to list.\n    if (!IAccessControl(nftContract).hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) {\n      revert NFTDropMarketFixedPriceSale_Only_Callable_By_Collection_Owner();\n    }\n    // And that this contract has permission to mint.\n    if (!IAccessControl(nftContract).hasRole(MINTER_ROLE, address(this))) {\n      revert NFTDropMarketFixedPriceSale_Mint_Permission_Required();\n    }\n\n    // Validate input params.\n    if (limitPerAccount == 0) {\n      revert NFTDropMarketFixedPriceSale_Limit_Per_Account_Must_Be_Set();\n    }\n    // Any price is supported, including 0.\n\n    // Confirm this collection has not already been listed.\n    FixedPriceSaleConfig storage saleConfig = nftContractToFixedPriceSaleConfig[nftContract];\n    if (saleConfig.seller != payable(0)) {\n      revert NFTDropMarketFixedPriceSale_Must_Not_Have_Pending_Sale();\n    }\n\n    // Save the sale details.\n    saleConfig.seller = payable(msg.sender);\n    saleConfig.price = price;\n    saleConfig.limitPerAccount = limitPerAccount;\n    emit CreateFixedPriceSale(nftContract, saleConfig.seller, saleConfig.price, saleConfig.limitPerAccount);\n  }\n\n  /**\n   * @notice Used to mint `count` number of NFTs from the collection.\n   * @param nftContract The address of the NFT drop collection.\n   * @param count The number of NFTs to mint.\n   * @param buyReferrer The address which referred this purchase, or address(0) if n/a.\n   * @return firstTokenId The tokenId for the first NFT minted.\n   * The other minted tokens are assigned sequentially, so `firstTokenId` - `firstTokenId + count - 1` were minted.\n   * @dev This call may revert if the collection has sold out, has an insufficient number of tokens available,\n   * or if the market's minter permissions were removed.\n   * If insufficient msg.value is included, the msg.sender's available FETH token balance will be used.\n   */\n  function mintFromFixedPriceSale(\n    address nftContract,\n    uint16 count,\n    address payable buyReferrer\n  ) external payable returns (uint256 firstTokenId) {\n    // Validate input params.\n    if (count == 0) {\n      revert NFTDropMarketFixedPriceSale_Must_Buy_At_Least_One_Token();\n    }\n\n    FixedPriceSaleConfig memory saleConfig = nftContractToFixedPriceSaleConfig[nftContract];\n\n    // Confirm that the buyer will not exceed the limit specified after minting.\n    if (IERC721(nftContract).balanceOf(msg.sender) + count > saleConfig.limitPerAccount) {\n      if (saleConfig.limitPerAccount == 0) {\n        // Provide a more targeted error if the collection has not been listed.\n        revert NFTDropMarketFixedPriceSale_Must_Have_Sale_In_Progress();\n      }\n      revert NFTDropMarketFixedPriceSale_Cannot_Buy_More_Than_Limit(saleConfig.limitPerAccount);\n    }\n\n    // Calculate the total cost, considering the `count` requested.\n    uint256 mintCost;\n    unchecked {\n      // Can not overflow as 2^80 * 2^16 == 2^96 max which fits in 256 bits.\n      mintCost = uint256(saleConfig.price) * count;\n    }\n\n    // The sale price is immutable so the buyer is aware of how much they will be paying when their tx is broadcasted.\n    if (msg.value > mintCost) {\n      // Since price is known ahead of time, if too much ETH is sent then something went wrong.\n      revert NFTDropMarketFixedPriceSale_Too_Much_Value_Provided(mintCost);\n    }\n    // Withdraw from the user's available FETH balance if insufficient msg.value was included.\n    _tryUseFETHBalance(mintCost, false);\n\n    // Mint the NFTs.\n    firstTokenId = INFTDropCollectionMint(nftContract).mintCountTo(count, msg.sender);\n\n    // Distribute revenue from this sale.\n    (uint256 totalFees, uint256 creatorRev, ) = _distributeFunds(\n      nftContract,\n      firstTokenId,\n      saleConfig.seller,\n      mintCost,\n      buyReferrer\n    );\n\n    emit MintFromFixedPriceDrop(nftContract, msg.sender, firstTokenId, count, totalFees, creatorRev);\n  }\n\n  /**\n   * @notice Returns the max number of NFTs a given account may mint.\n   * @param nftContract The address of the NFT drop collection.\n   * @param user The address of the user which will be minting.\n   * @return numberThatCanBeMinted How many NFTs the user can mint.\n   */\n  function getAvailableCountFromFixedPriceSale(address nftContract, address user)\n    external\n    view\n    returns (uint256 numberThatCanBeMinted)\n  {\n    (, , uint256 limitPerAccount, uint256 numberOfTokensAvailableToMint, bool marketCanMint) = getFixedPriceSale(\n      nftContract\n    );\n    if (!marketCanMint) {\n      // No one can mint in the current state.\n      return 0;\n    }\n    uint256 currentBalance = IERC721(nftContract).balanceOf(user);\n    if (currentBalance >= limitPerAccount) {\n      // User has exhausted their limit.\n      return 0;\n    }\n\n    uint256 availableToMint = limitPerAccount - currentBalance;\n    if (availableToMint > numberOfTokensAvailableToMint) {\n      // User has more tokens available than the collection has available.\n      return numberOfTokensAvailableToMint;\n    }\n\n    return availableToMint;\n  }\n\n  /**\n   * @notice Returns details for a drop collection's fixed price sale.\n   * @param nftContract The address of the NFT drop collection.\n   * @return seller The address of the seller which listed this drop for sale.\n   * This value will be address(0) if the collection is not listed or has sold out.\n   * @return price The price per NFT minted.\n   * @return limitPerAccount The max number of NFTs an account may have while minting.\n   * @return numberOfTokensAvailableToMint The total number of NFTs that may still be minted.\n   * @return marketCanMint True if this contract has permissions to mint from the given collection.\n   */\n  function getFixedPriceSale(address nftContract)\n    public\n    view\n    returns (\n      address payable seller,\n      uint256 price,\n      uint256 limitPerAccount,\n      uint256 numberOfTokensAvailableToMint,\n      bool marketCanMint\n    )\n  {\n    try INFTDropCollectionMint(nftContract).numberOfTokensAvailableToMint() returns (uint256 count) {\n      if (count != 0) {\n        try IAccessControl(nftContract).hasRole(MINTER_ROLE, address(this)) returns (bool hasRole) {\n          marketCanMint = hasRole;\n        } catch {\n          // The contract is not supported - return default values.\n          return (payable(0), 0, 0, 0, false);\n        }\n\n        FixedPriceSaleConfig memory saleConfig = nftContractToFixedPriceSaleConfig[nftContract];\n        seller = saleConfig.seller;\n        price = saleConfig.price;\n        limitPerAccount = saleConfig.limitPerAccount;\n        numberOfTokensAvailableToMint = count;\n      }\n      // Else minted completed -- return default values.\n    } catch // solhint-disable-next-line no-empty-blocks\n    {\n      // Contract not supported or self destructed - return default values\n    }\n  }\n\n  /**\n   * @inheritdoc MarketSharedCore\n   * @dev Returns the seller for a collection if listed and not already sold out.\n   */\n  function _getSellerOf(\n    address nftContract,\n    uint256 /* tokenId */\n  ) internal view virtual override returns (address payable seller) {\n    (seller, , , , ) = getFixedPriceSale(nftContract);\n  }\n\n  /**\n   * @notice This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   */\n  uint256[1000] private __gap;\n}"
    }
  ]
}