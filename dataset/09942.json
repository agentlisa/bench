{
  "Title": "[M-04] Name squatting",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-02-aave-lens/blob/aaf6c116345f3647e11a35010f28e3b90e7b4862/contracts/core/LensHub.sol#L142\n\n\n# Vulnerability details\n\n## Impact\nCreating profiles through `LensHub/PublishingLogic.createProfile` does not cost anything and will therefore result in \"name squatting\".\nA whitelisted profile creator will create many handles that are in demand, even if they don't need them, just to flip them for a profit later.\nThis ruins the experience for many high-profile users that can't get their desired handle.\n\n## Recommended Mitigation Steps\nConsider auctioning off handles to the highest bidder or at least taking a fee such that the cost of name squatting is not zero.\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-02-aave-lens-contest",
  "Code": [
    {
      "filename": "contracts/core/LensHub.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.10;\n\nimport {ILensHub} from '../interfaces/ILensHub.sol';\nimport {Events} from '../libraries/Events.sol';\nimport {Helpers} from '../libraries/Helpers.sol';\nimport {DataTypes} from '../libraries/DataTypes.sol';\nimport {Errors} from '../libraries/Errors.sol';\nimport {PublishingLogic} from '../libraries/PublishingLogic.sol';\nimport {InteractionLogic} from '../libraries/InteractionLogic.sol';\nimport {LensNFTBase} from './base/LensNFTBase.sol';\nimport {LensMultiState} from './base/LensMultiState.sol';\nimport {LensHubStorage} from './storage/LensHubStorage.sol';\nimport {VersionedInitializable} from '../upgradeability/VersionedInitializable.sol';\n\n/**\n * @title LensHub\n * @author Lens Protocol\n *\n * @notice This is the main entrypoint of the Lens Protocol. It contains governance functionality as well as\n * publishing and profile interaction functionality.\n *\n * NOTE: The Lens Protocol is unique in that frontend operators need to track a potentially overwhelming\n * number of NFT contracts and interactions at once. For that reason, we've made two quirky design decisions:\n *      1. Both Follow & Collect NFTs invoke an LensHub callback on transfer with the sole purpose of emitting an event.\n *      2. Almost every event in the protocol emits the current block timestamp, reducing the need to fetch it manually.\n */\ncontract LensHub is ILensHub, LensNFTBase, VersionedInitializable, LensMultiState, LensHubStorage {\n    uint256 internal constant REVISION = 1;\n\n    address internal immutable FOLLOW_NFT_IMPL;\n    address internal immutable COLLECT_NFT_IMPL;\n\n    /**\n     * @dev This modifier reverts if the caller is not the configured governance address.\n     */\n    modifier onlyGov() {\n        _validateCallerIsGovernance();\n        _;\n    }\n\n    /**\n     * @dev This modifier reverts if the caller is not a whitelisted profile creator address.\n     */\n    modifier onlyWhitelistedProfileCreator() {\n        _validateCallerIsWhitelistedProfileCreator();\n        _;\n    }\n\n    /**\n     * @dev The constructor sets the immutable follow & collect NFT implementations.\n     *\n     * @param followNFTImpl The follow NFT implementation address.\n     * @param collectNFTImpl The collect NFT implementation address.\n     */\n    constructor(address followNFTImpl, address collectNFTImpl) {\n        FOLLOW_NFT_IMPL = followNFTImpl;\n        COLLECT_NFT_IMPL = collectNFTImpl;\n    }\n\n    /// @inheritdoc ILensHub\n    function initialize(\n        string calldata name,\n        string calldata symbol,\n        address newGovernance\n    ) external override initializer {\n        super._initialize(name, symbol);\n        _setState(DataTypes.ProtocolState.Paused);\n        _setGovernance(newGovernance);\n    }\n\n    /// ***********************\n    /// *****GOV FUNCTIONS*****\n    /// ***********************\n\n    /// @inheritdoc ILensHub\n    function setGovernance(address newGovernance) external override onlyGov {\n        _setGovernance(newGovernance);\n    }\n\n    /// @inheritdoc ILensHub\n    function setEmergencyAdmin(address newEmergencyAdmin) external override onlyGov {\n        address prevEmergencyAdmin = _emergencyAdmin;\n        _emergencyAdmin = newEmergencyAdmin;\n        emit Events.EmergencyAdminSet(\n            msg.sender,\n            prevEmergencyAdmin,\n            newEmergencyAdmin,\n            block.timestamp\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function setState(DataTypes.ProtocolState newState) external override {\n        if (msg.sender != _governance && msg.sender != _emergencyAdmin)\n            revert Errors.NotGovernanceOrEmergencyAdmin();\n        _setState(newState);\n    }\n\n    ///@inheritdoc ILensHub\n    function whitelistProfileCreator(address profileCreator, bool whitelist)\n        external\n        override\n        onlyGov\n    {\n        _profileCreatorWhitelisted[profileCreator] = whitelist;\n        emit Events.ProfileCreatorWhitelisted(profileCreator, whitelist, block.timestamp);\n    }\n\n    /// @inheritdoc ILensHub\n    function whitelistFollowModule(address followModule, bool whitelist) external override onlyGov {\n        _followModuleWhitelisted[followModule] = whitelist;\n        emit Events.FollowModuleWhitelisted(followModule, whitelist, block.timestamp);\n    }\n\n    /// @inheritdoc ILensHub\n    function whitelistReferenceModule(address referenceModule, bool whitelist)\n        external\n        override\n        onlyGov\n    {\n        _referenceModuleWhitelisted[referenceModule] = whitelist;\n        emit Events.ReferenceModuleWhitelisted(referenceModule, whitelist, block.timestamp);\n    }\n\n    /// @inheritdoc ILensHub\n    function whitelistCollectModule(address collectModule, bool whitelist)\n        external\n        override\n        onlyGov\n    {\n        _collectModuleWhitelisted[collectModule] = whitelist;\n        emit Events.CollectModuleWhitelisted(collectModule, whitelist, block.timestamp);\n    }\n\n    /// *********************************\n    /// *****PROFILE OWNER FUNCTIONS*****\n    /// *********************************\n\n    /// @inheritdoc ILensHub\n    function createProfile(DataTypes.CreateProfileData calldata vars)\n        external\n        override\n        whenNotPaused\n        onlyWhitelistedProfileCreator\n    {\n        uint256 profileId = ++_profileCounter;\n        _mint(vars.to, profileId);\n        PublishingLogic.createProfile(\n            vars,\n            profileId,\n            _profileIdByHandleHash,\n            _profileById,\n            _followModuleWhitelisted\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function setFollowModule(\n        uint256 profileId,\n        address followModule,\n        bytes calldata followModuleData\n    ) external override whenNotPaused {\n        _validateCallerIsProfileOwner(profileId);\n        PublishingLogic.setFollowModule(\n            profileId,\n            followModule,\n            followModuleData,\n            _profileById[profileId],\n            _followModuleWhitelisted\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function setFollowModuleWithSig(DataTypes.SetFollowModuleWithSigData calldata vars)\n        external\n        override\n        whenNotPaused\n    {\n        address owner = ownerOf(vars.profileId);\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            SET_FOLLOW_MODULE_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            vars.followModule,\n                            keccak256(vars.followModuleData),\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, owner, vars.sig);\n        PublishingLogic.setFollowModule(\n            vars.profileId,\n            vars.followModule,\n            vars.followModuleData,\n            _profileById[vars.profileId],\n            _followModuleWhitelisted\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function setDispatcher(uint256 profileId, address dispatcher) external override whenNotPaused {\n        _validateCallerIsProfileOwner(profileId);\n        _setDispatcher(profileId, dispatcher);\n    }\n\n    /// @inheritdoc ILensHub\n    function setDispatcherWithSig(DataTypes.SetDispatcherWithSigData calldata vars)\n        external\n        override\n        whenNotPaused\n    {\n        address owner = ownerOf(vars.profileId);\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            SET_DISPATCHER_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            vars.dispatcher,\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, owner, vars.sig);\n        _setDispatcher(vars.profileId, vars.dispatcher);\n    }\n\n    /// @inheritdoc ILensHub\n    function setProfileImageURI(uint256 profileId, string calldata imageURI)\n        external\n        override\n        whenNotPaused\n    {\n        _validateCallerIsProfileOwnerOrDispatcher(profileId);\n        _setProfileImageURI(profileId, imageURI);\n    }\n\n    /// @inheritdoc ILensHub\n    function setProfileImageURIWithSig(DataTypes.SetProfileImageURIWithSigData calldata vars)\n        external\n        override\n        whenNotPaused\n    {\n        address owner = ownerOf(vars.profileId);\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            SET_PROFILE_IMAGE_URI_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            keccak256(bytes(vars.imageURI)),\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, owner, vars.sig);\n        _setProfileImageURI(vars.profileId, vars.imageURI);\n    }\n\n    /// @inheritdoc ILensHub\n    function setFollowNFTURI(uint256 profileId, string calldata followNFTURI)\n        external\n        override\n        whenNotPaused\n    {\n        _validateCallerIsProfileOwnerOrDispatcher(profileId);\n        _setFollowNFTURI(profileId, followNFTURI);\n    }\n\n    /// @inheritdoc ILensHub\n    function setFollowNFTURIWithSig(DataTypes.SetFollowNFTURIWithSigData calldata vars)\n        external\n        override\n        whenNotPaused\n    {\n        address owner = ownerOf(vars.profileId);\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            SET_FOLLOW_NFT_URI_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            keccak256(bytes(vars.followNFTURI)),\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, owner, vars.sig);\n        _setFollowNFTURI(vars.profileId, vars.followNFTURI);\n    }\n\n    /// @inheritdoc ILensHub\n    function post(DataTypes.PostData calldata vars) external override whenPublishingEnabled {\n        _validateCallerIsProfileOwnerOrDispatcher(vars.profileId);\n        _createPost(\n            vars.profileId,\n            vars.contentURI,\n            vars.collectModule,\n            vars.collectModuleData,\n            vars.referenceModule,\n            vars.referenceModuleData\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function postWithSig(DataTypes.PostWithSigData calldata vars)\n        external\n        override\n        whenPublishingEnabled\n    {\n        address owner = ownerOf(vars.profileId);\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            POST_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            keccak256(bytes(vars.contentURI)),\n                            vars.collectModule,\n                            keccak256(vars.collectModuleData),\n                            vars.referenceModule,\n                            keccak256(vars.referenceModuleData),\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, owner, vars.sig);\n        _createPost(\n            vars.profileId,\n            vars.contentURI,\n            vars.collectModule,\n            vars.collectModuleData,\n            vars.referenceModule,\n            vars.referenceModuleData\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function comment(DataTypes.CommentData calldata vars) external override whenPublishingEnabled {\n        _validateCallerIsProfileOwnerOrDispatcher(vars.profileId);\n        _createComment(vars);\n    }\n\n    /// @inheritdoc ILensHub\n    function commentWithSig(DataTypes.CommentWithSigData calldata vars)\n        external\n        override\n        whenPublishingEnabled\n    {\n        address owner = ownerOf(vars.profileId);\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            COMMENT_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            keccak256(bytes(vars.contentURI)),\n                            vars.profileIdPointed,\n                            vars.pubIdPointed,\n                            vars.collectModule,\n                            keccak256(vars.collectModuleData),\n                            vars.referenceModule,\n                            keccak256(vars.referenceModuleData),\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, owner, vars.sig);\n        _createComment(\n            DataTypes.CommentData(\n                vars.profileId,\n                vars.contentURI,\n                vars.profileIdPointed,\n                vars.pubIdPointed,\n                vars.collectModule,\n                vars.collectModuleData,\n                vars.referenceModule,\n                vars.referenceModuleData\n            )\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function mirror(DataTypes.MirrorData calldata vars) external override whenPublishingEnabled {\n        _validateCallerIsProfileOwnerOrDispatcher(vars.profileId);\n        _createMirror(\n            vars.profileId,\n            vars.profileIdPointed,\n            vars.pubIdPointed,\n            vars.referenceModule,\n            vars.referenceModuleData\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function mirrorWithSig(DataTypes.MirrorWithSigData calldata vars)\n        external\n        override\n        whenPublishingEnabled\n    {\n        address owner = ownerOf(vars.profileId);\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            MIRROR_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            vars.profileIdPointed,\n                            vars.pubIdPointed,\n                            vars.referenceModule,\n                            keccak256(vars.referenceModuleData),\n                            sigNonces[owner]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, owner, vars.sig);\n        _createMirror(\n            vars.profileId,\n            vars.profileIdPointed,\n            vars.pubIdPointed,\n            vars.referenceModule,\n            vars.referenceModuleData\n        );\n    }\n\n    /**\n     * @notice Burns a profile, this maintains the profile data struct, but deletes the\n     * handle hash to profile ID mapping value.\n     *\n     * NOTE: This overrides the LensNFTBase contract's `burn()` function and calls it to fully burn\n     * the NFT.\n     */\n    function burn(uint256 tokenId) public override whenNotPaused {\n        super.burn(tokenId);\n        _clearHandleHash(tokenId);\n    }\n\n    /**\n     * @notice Burns a profile with a signature, this maintains the profile data struct, but deletes the\n     * handle hash to profile ID mapping value.\n     *\n     * NOTE: This overrides the LensNFTBase contract's `burnWithSig()` function and calls it to fully burn\n     * the NFT.\n     */\n    function burnWithSig(uint256 tokenId, DataTypes.EIP712Signature calldata sig)\n        public\n        override\n        whenNotPaused\n    {\n        super.burnWithSig(tokenId, sig);\n        _clearHandleHash(tokenId);\n    }\n\n    /// ***************************************\n    /// *****PROFILE INTERACTION FUNCTIONS*****\n    /// ***************************************\n\n    /// @inheritdoc ILensHub\n    function follow(uint256[] calldata profileIds, bytes[] calldata datas)\n        external\n        override\n        whenNotPaused\n    {\n        InteractionLogic.follow(\n            msg.sender,\n            profileIds,\n            datas,\n            FOLLOW_NFT_IMPL,\n            _profileById,\n            _profileIdByHandleHash\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function followWithSig(DataTypes.FollowWithSigData calldata vars)\n        external\n        override\n        whenNotPaused\n    {\n        bytes32[] memory dataHashes = new bytes32[](vars.datas.length);\n        for (uint256 i = 0; i < vars.datas.length; ++i) {\n            dataHashes[i] = keccak256(vars.datas[i]);\n        }\n\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            FOLLOW_WITH_SIG_TYPEHASH,\n                            keccak256(abi.encodePacked(vars.profileIds)),\n                            keccak256(abi.encodePacked(dataHashes)),\n                            sigNonces[vars.follower]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, vars.follower, vars.sig);\n        InteractionLogic.follow(\n            vars.follower,\n            vars.profileIds,\n            vars.datas,\n            FOLLOW_NFT_IMPL,\n            _profileById,\n            _profileIdByHandleHash\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function collect(\n        uint256 profileId,\n        uint256 pubId,\n        bytes calldata data\n    ) external override whenNotPaused {\n        InteractionLogic.collect(\n            msg.sender,\n            profileId,\n            pubId,\n            data,\n            COLLECT_NFT_IMPL,\n            _pubByIdByProfile,\n            _profileById\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function collectWithSig(DataTypes.CollectWithSigData calldata vars)\n        external\n        override\n        whenNotPaused\n    {\n        bytes32 digest;\n        unchecked {\n            digest = keccak256(\n                abi.encodePacked(\n                    '\\x19\\x01',\n                    _calculateDomainSeparator(),\n                    keccak256(\n                        abi.encode(\n                            COLLECT_WITH_SIG_TYPEHASH,\n                            vars.profileId,\n                            vars.pubId,\n                            keccak256(vars.data),\n                            sigNonces[vars.collector]++,\n                            vars.sig.deadline\n                        )\n                    )\n                )\n            );\n        }\n\n        _validateRecoveredAddress(digest, vars.collector, vars.sig);\n        InteractionLogic.collect(\n            vars.collector,\n            vars.profileId,\n            vars.pubId,\n            vars.data,\n            COLLECT_NFT_IMPL,\n            _pubByIdByProfile,\n            _profileById\n        );\n    }\n\n    /// @inheritdoc ILensHub\n    function emitFollowNFTTransferEvent(\n        uint256 profileId,\n        uint256 followNFTId,\n        address from,\n        address to\n    ) external override {\n        address expectedFollowNFT = _profileById[profileId].followNFT;\n        if (msg.sender != expectedFollowNFT) revert Errors.CallerNotFollowNFT();\n        emit Events.FollowNFTTransferred(profileId, followNFTId, from, to, block.timestamp);\n    }\n\n    /// @inheritdoc ILensHub\n    function emitCollectNFTTransferEvent(\n        uint256 profileId,\n        uint256 pubId,\n        uint256 collectNFTId,\n        address from,\n        address to\n    ) external override {\n        address expectedCollectNFT = _pubByIdByProfile[profileId][pubId].collectNFT;\n        if (msg.sender != expectedCollectNFT) revert Errors.CallerNotCollectNFT();\n        emit Events.CollectNFTTransferred(\n            profileId,\n            pubId,\n            collectNFTId,\n            from,\n            to,\n            block.timestamp\n        );\n    }\n\n    /// *********************************\n    /// *****EXTERNAL VIEW FUNCTIONS*****\n    /// *********************************\n\n    /// @inheritdoc ILensHub\n    function isProfileCreatorWhitelisted(address profileCreator)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return _profileCreatorWhitelisted[profileCreator];\n    }\n\n    /// @inheritdoc ILensHub\n    function isFollowModuleWhitelisted(address followModule) external view override returns (bool) {\n        return _followModuleWhitelisted[followModule];\n    }\n\n    /// @inheritdoc ILensHub\n    function isReferenceModuleWhitelisted(address referenceModule)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return _referenceModuleWhitelisted[referenceModule];\n    }\n\n    /// @inheritdoc ILensHub\n    function isCollectModuleWhitelisted(address collectModule)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return _collectModuleWhitelisted[collectModule];\n    }\n\n    /// @inheritdoc ILensHub\n    function getGovernance() external view override returns (address) {\n        return _governance;\n    }\n\n    /// @inheritdoc ILensHub\n    function getDispatcher(uint256 profileId) external view override returns (address) {\n        return _dispatcherByProfile[profileId];\n    }\n\n    /// @inheritdoc ILensHub\n    function getPubCount(uint256 profileId) external view override returns (uint256) {\n        return _profileById[profileId].pubCount;\n    }\n\n    /// @inheritdoc ILensHub\n    function getFollowNFT(uint256 profileId) external view override returns (address) {\n        return _profileById[profileId].followNFT;\n    }\n\n    /// @inheritdoc ILensHub\n    function getFollowNFTURI(uint256 profileId) external view override returns (string memory) {\n        return _profileById[profileId].followNFTURI;\n    }\n\n    /// @inheritdoc ILensHub\n    function getCollectNFT(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (address)\n    {\n        return _pubByIdByProfile[profileId][pubId].collectNFT;\n    }\n\n    /// @inheritdoc ILensHub\n    function getFollowModule(uint256 profileId) external view override returns (address) {\n        return _profileById[profileId].followModule;\n    }\n\n    /// @inheritdoc ILensHub\n    function getCollectModule(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (address)\n    {\n        return _pubByIdByProfile[profileId][pubId].collectModule;\n    }\n\n    /// @inheritdoc ILensHub\n    function getReferenceModule(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (address)\n    {\n        return _pubByIdByProfile[profileId][pubId].referenceModule;\n    }\n\n    /// @inheritdoc ILensHub\n    function getHandle(uint256 profileId) external view override returns (string memory) {\n        return _profileById[profileId].handle;\n    }\n\n    /// @inheritdoc ILensHub\n    function getPubPointer(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (uint256, uint256)\n    {\n        uint256 profileIdPointed = _pubByIdByProfile[profileId][pubId].profileIdPointed;\n        uint256 pubIdPointed = _pubByIdByProfile[profileId][pubId].pubIdPointed;\n        return (profileIdPointed, pubIdPointed);\n    }\n\n    /// @inheritdoc ILensHub\n    function getContentURI(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (string memory)\n    {\n        (uint256 rootProfileId, uint256 rootPubId, ) = Helpers.getPointedIfMirror(\n            profileId,\n            pubId,\n            _pubByIdByProfile\n        );\n        return _pubByIdByProfile[rootProfileId][rootPubId].contentURI;\n    }\n\n    /// @inheritdoc ILensHub\n    function getProfileIdByHandle(string calldata handle) external view override returns (uint256) {\n        bytes32 handleHash = keccak256(bytes(handle));\n        return _profileIdByHandleHash[handleHash];\n    }\n\n    /// @inheritdoc ILensHub\n    function getProfile(uint256 profileId)\n        external\n        view\n        override\n        returns (DataTypes.ProfileStruct memory)\n    {\n        return _profileById[profileId];\n    }\n\n    /// @inheritdoc ILensHub\n    function getPub(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (DataTypes.PublicationStruct memory)\n    {\n        return _pubByIdByProfile[profileId][pubId];\n    }\n\n    /// @inheritdoc ILensHub\n    function getPubType(uint256 profileId, uint256 pubId)\n        external\n        view\n        override\n        returns (DataTypes.PubType)\n    {\n        if (pubId == 0 || _profileById[profileId].pubCount < pubId) {\n            return DataTypes.PubType.Nonexistent;\n        } else if (_pubByIdByProfile[profileId][pubId].collectModule == address(0)) {\n            return DataTypes.PubType.Mirror;\n        } else {\n            if (_pubByIdByProfile[profileId][pubId].profileIdPointed == 0) {\n                return DataTypes.PubType.Post;\n            } else {\n                return DataTypes.PubType.Comment;\n            }\n        }\n    }\n\n    /**\n     * @dev Overrides the ERC721 tokenURI function to return the associated URI with a given profile.\n     */\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        return _profileById[tokenId].imageURI; // temp\n    }\n\n    /// ****************************\n    /// *****INTERNAL FUNCTIONS*****\n    /// ****************************\n\n    function _setGovernance(address newGovernance) internal {\n        address prevGovernance = _governance;\n        _governance = newGovernance;\n        emit Events.GovernanceSet(msg.sender, prevGovernance, newGovernance, block.timestamp);\n    }\n\n    function _createPost(\n        uint256 profileId,\n        string memory contentURI,\n        address collectModule,\n        bytes memory collectModuleData,\n        address referenceModule,\n        bytes memory referenceModuleData\n    ) internal {\n        PublishingLogic.createPost(\n            profileId,\n            contentURI,\n            collectModule,\n            collectModuleData,\n            referenceModule,\n            referenceModuleData,\n            ++_profileById[profileId].pubCount,\n            _pubByIdByProfile,\n            _collectModuleWhitelisted,\n            _referenceModuleWhitelisted\n        );\n    }\n\n    function _createComment(DataTypes.CommentData memory vars) internal {\n        PublishingLogic.createComment(\n            vars,\n            _profileById[vars.profileId].pubCount + 1,\n            _profileById,\n            _pubByIdByProfile,\n            _collectModuleWhitelisted,\n            _referenceModuleWhitelisted\n        );\n        _profileById[vars.profileId].pubCount++;\n    }\n\n    function _createMirror(\n        uint256 profileId,\n        uint256 profileIdPointed,\n        uint256 pubIdPointed,\n        address referenceModule,\n        bytes calldata referenceModuleData\n    ) internal {\n        PublishingLogic.createMirror(\n            profileId,\n            profileIdPointed,\n            pubIdPointed,\n            referenceModule,\n            referenceModuleData,\n            ++_profileById[profileId].pubCount,\n            _pubByIdByProfile,\n            _referenceModuleWhitelisted\n        );\n    }\n\n    function _setDispatcher(uint256 profileId, address dispatcher) internal {\n        _dispatcherByProfile[profileId] = dispatcher;\n        emit Events.DispatcherSet(profileId, dispatcher, block.timestamp);\n    }\n\n    function _setProfileImageURI(uint256 profileId, string memory imageURI) internal {\n        _profileById[profileId].imageURI = imageURI;\n        emit Events.ProfileImageURISet(profileId, imageURI, block.timestamp);\n    }\n\n    function _setFollowNFTURI(uint256 profileId, string memory followNFTURI) internal {\n        _profileById[profileId].followNFTURI = followNFTURI;\n        emit Events.FollowNFTURISet(profileId, followNFTURI, block.timestamp);\n    }\n\n    function _clearHandleHash(uint256 profileId) internal {\n        bytes32 handleHash = keccak256(bytes(_profileById[profileId].handle));\n        _profileIdByHandleHash[handleHash] = 0;\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal override {\n        if (_dispatcherByProfile[tokenId] != address(0)) {\n            _setDispatcher(tokenId, address(0));\n        }\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    function _validateCallerIsProfileOwnerOrDispatcher(uint256 profileId) internal view {\n        if (msg.sender != ownerOf(profileId) && msg.sender != _dispatcherByProfile[profileId])\n            revert Errors.NotProfileOwnerOrDispatcher();\n    }\n\n    function _validateCallerIsProfileOwner(uint256 profileId) internal view {\n        if (msg.sender != ownerOf(profileId)) revert Errors.NotProfileOwner();\n    }\n\n    function _validateCallerIsGovernance() internal view {\n        if (msg.sender != _governance) revert Errors.NotGovernance();\n    }\n\n    function _validateCallerIsWhitelistedProfileCreator() internal view {\n        if (!_profileCreatorWhitelisted[msg.sender]) revert Errors.ProfileCreatorNotWhitelisted();\n    }\n\n    function getRevision() internal pure virtual override returns (uint256) {\n        return REVISION;\n    }\n}"
    }
  ]
}