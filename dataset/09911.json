{
  "Title": "[M-11] Depositor can spend funds of another Depositor",
  "Content": "_Submitted by csanuragjain_\n\n1.  One depositor can spend funds of another depositor\n2.  Depositor can deposit in expired proposal\n3.  rewardIdentifier and bribeIdentifier can point to different rounds/tokens\n\n### Proof of Concept\n\nOne depositor can spend funds of another depositor:\n\n1.  Malicious depositor can call depositBribeERC20 at BribeVault.sol#L164 with briber as User B (Malicious user can generate bribeIdentifier with his own proposal)\n\n2.  Assume this User B has approved amount x to this contract\n\n3.  BribeVault.sol#L187 (IERC20(token).safeTransferFrom(briber, address(this), amount);) will transfer this amount x to the contract due to call at step 1. All this happen without User B knowledge\n\nExpired Proposal:\n\n1.  Malicious depositor can generate bribeIdentifier of an expired proposal (proposalDeadlines\\[proposal] < block.timestamp) using generateBribeVaultIdentifier at TokemakBribe.sol#L166\n\n2.  Malicious depositor can then simply call depositBribeERC20 at BribeVault.sol#L164\n\n3.  Since there is no deadline check and this function blindly trusts bribeIdentifier, user deposit will be success even though the associated proposal already expired\n\nRewardIdentifier and bribeIdentifier can point to different rounds/tokens:\n\n1.  Similar to expired proposal, depositor can generate bribeIdentifier and RewardIdentifier with different tokens and rounds.\n\n2.  Depositor now calls epositBribeERC20 at BribeVault.sol#L164 with the generated bribeIdentifier and RewardIdentifier\n\n3.  rewardToBribes\\[rewardIdentifier].push(bribeIdentifier); will update reward for round x and bribeIdentifier will point to round y which is incorrect\n\n### Recommended Mitigation Steps\n\ndepositBribeERC20 at [BribeVault.sol#L164](https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L164) should only be allowed to be called via TokemakBribe.sol\n\n**[kphed (Redacted Cartel) disputed and commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/11#issuecomment-1040409839):**\n > > depositBribeERC20 at BribeVault.sol#L164 should only be allowed to be called via TokemakBribe.sol\n> \n> Only those with the \"depositor\" role can call the deposit bribe methods (`depositBribeERC20` and `depositBribe`). We only grant the role to bribe contracts we own such as TokemakBribe.sol.\n> \n> Thanks again for participating in our contest csanuragjain, looking forward to more feedback/suggestions/comments.\n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/11#issuecomment-1059804225):**\n > While the finding is similar to M-02, I believe this more eloquently shows the specific types of admin privileges that the `DEPOSITOR_ROLE` has for the function `depositBribeERC20`.\n> \n> Ultimately the finding is highlighting how things can go wrong and how the `DEPOSITOR_ROLE` provides a high level of admin privilege.\n> \n> Because this is contingent on a malicious admin, I believe Medium Severity to be more appropriate.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-02-redacted-cartel-contest",
  "Code": [
    {
      "filename": "contracts/BribeVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Common} from \"./libraries/Common.sol\";\n\ninterface IRewardDistributor {\n    function updateRewardsMetadata(\n        Common.Distribution[] calldata _distributions\n    ) external;\n}\n\ncontract BribeVault is AccessControl {\n    using SafeERC20 for IERC20;\n\n    struct Bribe {\n        address token;\n        uint256 amount;\n    }\n\n    uint256 public fee; // 5000 = 0.5%\n    address public feeRecipient; // Protocol treasury\n    address public distributor; // RewardDistributor contract\n    uint256 public constant feeDivisor = 1000000;\n    bytes32 public constant DEPOSITOR_ROLE = keccak256(\"DEPOSITOR_ROLE\");\n\n    // Bribe identifiers mapped to Bribe structs\n    // A bribe identifier is composed of different info (e.g. protocol, voting round, etc.)\n    mapping(bytes32 => Bribe) public bribes;\n\n    // Protocol-specific reward identifiers mapped to bribe identifiers\n    // Allows us to group bribes by reward tokens (one token may be used across many bribes)\n    mapping(bytes32 => bytes32[]) public rewardToBribes;\n\n    event GrantDepositorRole(address depositor);\n    event RevokeDepositorRole(address depositor);\n    event SetFee(uint256 _fee);\n    event SetFeeRecipient(address _feeRecipient);\n    event SetDistributor(address _distributor);\n    event DepositBribe(\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier,\n        address token,\n        uint256 amount,\n        uint256 totalAmount,\n        address briber\n    );\n    event TransferBribe(\n        bytes32 rewardIdentifier,\n        address token,\n        bytes32 proof,\n        uint256 feeAmount,\n        uint256 distributorAmount\n    );\n    event EmergencyWithdrawal(address token, uint256 amount, address admin);\n\n    constructor(\n        uint256 _fee,\n        address _feeRecipient,\n        address _distributor\n    ) {\n        require(_fee <= feeDivisor, \"Invalid fee\");\n        fee = _fee;\n\n        require(_feeRecipient != address(0), \"Invalid feeRecipient\");\n        feeRecipient = _feeRecipient;\n\n        require(_distributor != address(0), \"Invalid distributor\");\n        distributor = _distributor;\n\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    /**\n        @notice Grant the depositor role to an address\n        @param  depositor  address  Address to grant the depositor role\n     */\n    function grantDepositorRole(address depositor)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(depositor != address(0), \"Invalid depositor\");\n        _grantRole(DEPOSITOR_ROLE, depositor);\n\n        emit GrantDepositorRole(depositor);\n    }\n\n    /**\n        @notice Revoke the depositor role from an address\n        @param  depositor  address  Address to revoke the depositor role\n     */\n    function revokeDepositorRole(address depositor)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(hasRole(DEPOSITOR_ROLE, depositor), \"Invalid depositor\");\n        _revokeRole(DEPOSITOR_ROLE, depositor);\n\n        emit RevokeDepositorRole(depositor);\n    }\n\n    /**\n        @notice Set the fee collected by the protocol\n        @param  _fee  uint256  Fee\n     */\n    function setFee(uint256 _fee) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(_fee <= feeDivisor, \"Invalid _fee\");\n        fee = _fee;\n\n        emit SetFee(_fee);\n    }\n\n    /**\n        @notice Set the protocol address where fees will be transferred\n        @param  _feeRecipient  address  Fee recipient\n     */\n    function setFeeRecipient(address _feeRecipient)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(_feeRecipient != address(0), \"Invalid feeRecipient\");\n        feeRecipient = _feeRecipient;\n\n        emit SetFeeRecipient(_feeRecipient);\n    }\n\n    /**\n        @notice Set the RewardDistributor contract address\n        @param  _distributor  address  Distributor\n     */\n    function setDistributor(address _distributor)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(_distributor != address(0), \"Invalid distributor\");\n        distributor = _distributor;\n\n        emit SetDistributor(_distributor);\n    }\n\n    /**\n        @notice Get bribe information based on the specified identifier\n        @param  bribeIdentifier  bytes32  The specified bribe identifier\n     */\n    function getBribe(bytes32 bribeIdentifier)\n        external\n        view\n        returns (address token, uint256 amount)\n    {\n        Bribe memory b = bribes[bribeIdentifier];\n        return (b.token, b.amount);\n    }\n\n    /**\n        @notice Deposit bribe (ERC20 only)\n        @param  bribeIdentifier   bytes32  Unique identifier related to bribe\n        @param  rewardIdentifier  bytes32  Unique identifier related to reward\n        @param  token             address  Bribe token\n        @param  amount            uint256  Bribe token amount\n        @param  briber            address  Address that originally called the depositor contract\n     */\n    function depositBribeERC20(\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier,\n        address token,\n        uint256 amount,\n        address briber\n    ) external onlyRole(DEPOSITOR_ROLE) {\n        require(bribeIdentifier.length > 0, \"Invalid bribeIdentifier\");\n        require(rewardIdentifier.length > 0, \"Invalid rewardIdentifier\");\n        require(token != address(0), \"Invalid token\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(briber != address(0), \"Invalid briber\");\n\n        Bribe storage b = bribes[bribeIdentifier];\n        address currentToken = b.token;\n        require(\n            // If bribers want to bribe with a different token they need a new identifier\n            currentToken == address(0) || currentToken == token,\n            \"Cannot change token\"\n        );\n\n        // Since this method is called by a depositor contract, we must transfer from the account\n        // that called the depositor contract - amount must be approved beforehand\n        IERC20(token).safeTransferFrom(briber, address(this), amount);\n\n        b.amount += amount; // Allow bribers to increase bribe\n\n        // Only set the token address and update the reward-to-bribe mapping if not yet set\n        if (currentToken == address(0)) {\n            b.token = token;\n            rewardToBribes[rewardIdentifier].push(bribeIdentifier);\n        }\n\n        emit DepositBribe(\n            bribeIdentifier,\n            rewardIdentifier,\n            token,\n            amount,\n            b.amount,\n            briber\n        );\n    }\n\n    /**\n        @notice Deposit bribe (native token only)\n        @param  bribeIdentifier   bytes32 Unique identifier related to bribe\n        @param  rewardIdentifier  bytes32 Unique identifier related to reward\n        @param  briber            address  Address that originally called the depositor contract\n     */\n    function depositBribe(\n        bytes32 bribeIdentifier,\n        bytes32 rewardIdentifier,\n        address briber\n    ) external payable onlyRole(DEPOSITOR_ROLE) {\n        require(bribeIdentifier.length > 0, \"Invalid bribeIdentifier\");\n        require(rewardIdentifier.length > 0, \"Invalid rewardIdentifier\");\n        require(briber != address(0), \"Invalid briber\");\n        require(msg.value > 0, \"Value must be greater than 0\");\n\n        Bribe storage b = bribes[bribeIdentifier];\n        address currentToken = b.token;\n        require(\n            // For native tokens, the token address is set to this contract to prevent\n            // overwriting storage - the address can be anything but address(this) safer\n            currentToken == address(0) || currentToken == address(this),\n            \"Cannot change token\"\n        );\n\n        b.amount += msg.value; // Allow bribers to increase bribe\n\n        // Only set the token address and update the reward-to-bribe mapping if not yet set\n        if (currentToken == address(0)) {\n            b.token = address(this);\n            rewardToBribes[rewardIdentifier].push(bribeIdentifier);\n        }\n\n        emit DepositBribe(\n            bribeIdentifier,\n            rewardIdentifier,\n            b.token,\n            msg.value,\n            b.amount,\n            briber\n        );\n    }\n\n    /**\n        @notice Transfer fees to fee recipient and bribes to distributor and update rewards metadata\n        @param  distributions    Distribution[] List of distribution details\n        @param  amounts          uint256[] List of amounts for distributor\n        @param  fees             uint256[] List of fee amounts for fee recipient\n     */\n    function transferBribes(\n        Common.Distribution[] calldata distributions,\n        uint256[] calldata amounts,\n        uint256[] calldata fees\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(distributions.length > 0, \"Invalid distributions\");\n        require(\n            distributions.length == amounts.length &&\n                distributions.length == fees.length,\n            \"Distributions, amounts, and fees must contain the same # of elements\"\n        );\n\n        // Transfer the bribe funds to fee recipient and reward distributor\n        for (uint256 i = 0; i < distributions.length; i++) {\n            bytes32 rewardIdentifier = distributions[i].rewardIdentifier;\n            uint256 distributorAmount = amounts[i];\n            uint256 feeAmount = fees[i];\n            address token = distributions[i].token;\n            require(\n                rewardToBribes[rewardIdentifier].length > 0,\n                \"Invalid reward identifier\"\n            );\n            require(token != address(0), \"Invalid token address\");\n            require(distributorAmount > 0, \"Invalid pending reward amount\");\n\n            // Check whether it's a native token reward\n            if (token == address(this)) {\n                (bool sentFeeRecipient, ) = feeRecipient.call{value: feeAmount}(\n                    \"\"\n                );\n                require(\n                    sentFeeRecipient,\n                    \"Failed to transfer to fee recipient\"\n                );\n\n                (bool sentDistributor, ) = distributor.call{\n                    value: distributorAmount\n                }(\"\");\n                require(sentDistributor, \"Failed to transfer to distributor\");\n            } else {\n                IERC20(token).transfer(feeRecipient, feeAmount);\n                IERC20(token).transfer(distributor, distributorAmount);\n            }\n\n            emit TransferBribe(\n                rewardIdentifier,\n                token,\n                distributions[i].proof,\n                feeAmount,\n                distributorAmount\n            );\n        }\n\n        // Update the rewards' metadata\n        IRewardDistributor(distributor).updateRewardsMetadata(distributions);\n    }\n\n    /**\n        @notice Update the rewards metadata of the specified identifiers (only if absolutely needed)\n        @param  distributions    Distribution[] List of distribution details\n     */\n    function updateRewardsMetadata(Common.Distribution[] calldata distributions)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(distributions.length > 0, \"Invalid distributions\");\n        IRewardDistributor(distributor).updateRewardsMetadata(distributions);\n    }\n\n    /**\n        @notice Withdraw ERC20 tokens to the admin address\n        @param  token   address  Token address\n        @param  amount  uint256  Token amount\n     */\n    function emergencyWithdrawERC20(address token, uint256 amount)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(token != address(0), \"Invalid token\");\n        require(amount > 0, \"Invalid amount\");\n\n        IERC20(token).transfer(msg.sender, amount);\n\n        emit EmergencyWithdrawal(token, amount, msg.sender);\n    }\n\n    /**\n        @notice Withdraw native tokens to the admin address\n        @param  amount  uint256  Token amount\n     */\n    function emergencyWithdraw(uint256 amount)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(amount > 0, \"Invalid amount\");\n\n        (bool sentAdmin, ) = msg.sender.call{value: amount}(\"\");\n        require(sentAdmin, \"Failed to withdraw\");\n\n        emit EmergencyWithdrawal(address(this), amount, msg.sender);\n    }\n}"
    }
  ]
}