{
  "Title": "M-4: Unable to liquidate USDC blacklisted user's loan due to transferring leftover collateral back in USDC",
  "Content": "# Issue M-4: Unable to liquidate USDC blacklisted user's loan due to transferring leftover collateral back in USDC \n\nSource: https://github.com/sherlock-audit/2023-04-jojo-judging/issues/206 \n\n## Found by \nInspex, jprod15, m9800, monrel, peakbolt\n\n## Summary\nDuring the loan liquidation process, any remaining collateral will be swapped to USDC tokens and transferred to the liquidated user. However, if the USDC contract blacklists the liquidated user, the liquidation transaction will be revert. As a result, the user's loan will be unable to be liquidated if they have been blacklisted by the USDC token contract.\n\n\n## Vulnerability Detail\n\nDuring the liquidation process, any remaining tokens will be transferred to the owner of the loan. However, if the loan owner has been blacklisted by USDC token, this flow will be reverted due to the code shown below.\n\nhttps://github.com/sherlock-audit/2023-04-jojo/blob/main/JUSDV1/src/Impl/JUSDBank.sol#L199-L204\n\nAs a result, users who have been blacklisted by USDC will be unable to liquidate their loan positions during the period of the blacklisting.\n\n## Impact\nThe liquidation process might DoS due to its reliance on paying back remaining tokens in USDC only. This will error where transferring USDC tokens to blacklisted users can cause the transaction to be reverted, disrupting the liquidation flow. This will result in a bad debt for the platform.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-04-jojo/blob/main/JUSDV1/src/Impl/JUSDBank.sol#L199-L204\n\n## Tool used\n\nManual Review\n\n## Recommendation\nWe suggest implementing one or all of the following solutions:\n1. Prevent USDC blacklisted users from opening a loan position until they are no longer blacklisted. This can be done by implementing a blacklist check during the borrowing process.\n2. Remove the transfer of remaining USDC tokens to the liquidated user during the liquidation flow. Instead, allow the user to withdraw their remaining USDC tokens on their own after the liquidation process is complete.\n\n\n\n## Discussion\n\n**JoscelynFarr**\n\nWe will allow partial liquidation to avoid this happened.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/70",
  "Code": [
    {
      "filename": "JUSDV1/src/Impl/JUSDBank.sol",
      "content": "/*\n    Copyright 2022 JOJO Exchange\n    SPDX-License-Identifier: BUSL-1.1*/\npragma solidity 0.8.9;\n\nimport \"../Interface/IJUSDBank.sol\";\nimport \"../Interface/IFlashLoanReceive.sol\";\nimport \"./JUSDBankStorage.sol\";\nimport \"./JUSDOperation.sol\";\nimport \"./JUSDView.sol\";\nimport \"./JUSDMulticall.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@JOJO/contracts/intf/IDealer.sol\";\nimport {IPriceChainLink} from \"../Interface/IPriceChainLink.sol\";\n\ncontract JUSDBank is IJUSDBank, JUSDOperation, JUSDView, JUSDMulticall {\n    using DecimalMath for uint256;\n    using SafeERC20 for IERC20;\n\n    constructor(\n        uint256 _maxReservesNum,\n        address _insurance,\n        address _JUSD,\n        address _JOJODealer,\n        uint256 _maxPerAccountBorrowAmount,\n        uint256 _maxTotalBorrowAmount,\n        uint256 _borrowFeeRate,\n        address _primaryAsset\n    ) {\n        maxReservesNum = _maxReservesNum;\n        JUSD = _JUSD;\n        JOJODealer = _JOJODealer;\n        insurance = _insurance;\n        maxPerAccountBorrowAmount = _maxPerAccountBorrowAmount;\n        maxTotalBorrowAmount = _maxTotalBorrowAmount;\n        borrowFeeRate = _borrowFeeRate;\n        t0Rate = JOJOConstant.ONE;\n        primaryAsset = _primaryAsset;\n        lastUpdateTimestamp = uint32(block.timestamp);\n    }\n\n    // --------------------------event-----------------------\n\n    event HandleBadDebt(address indexed liquidatedTrader, uint256 borrowJUSDT0);\n    event Deposit(\n        address indexed collateral,\n        address indexed from,\n        address indexed to,\n        address operator,\n        uint256 amount\n    );\n    event Borrow(\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bool isDepositToJOJO\n    );\n    event Repay(address indexed from, address indexed to, uint256 amount);\n    event Withdraw(\n        address indexed collateral,\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bool ifInternal\n    );\n    event Liquidate(\n        address indexed collateral,\n        address indexed liquidator,\n        address indexed liquidated,\n        address operator,\n        uint256 collateralAmount,\n        uint256 liquidatedAmount,\n        uint256 insuranceFee\n    );\n    event FlashLoan(address indexed collateral, uint256 amount);\n\n    /// @notice to ensure msg.sender is from account or msg.sender is the sub account of from\n    /// so that msg.sender can send the transaction\n    modifier isValidOperator(address operator, address client) {\n        require(\n            msg.sender == client || operatorRegistry[client][operator],\n            JUSDErrors.CAN_NOT_OPERATE_ACCOUNT\n        );\n        _;\n    }\n    modifier isLiquidator(address liquidator) {\n        if(isLiquidatorWhitelistOpen){\n            require(isLiquidatorWhiteList[liquidator], \"liquidator is not in the liquidator white list\");\n        }\n        _;\n    }\n\n    function deposit(\n        address from,\n        address collateral,\n        uint256 amount,\n        address to\n    ) external override nonReentrant isValidOperator(msg.sender, from) {\n        DataTypes.ReserveInfo storage reserve = reserveInfo[collateral];\n        DataTypes.UserInfo storage user = userInfo[to];\n        //        deposit\n        _deposit(reserve, user, amount, collateral, to, from);\n    }\n\n    function borrow(\n        uint256 amount,\n        address to,\n        bool isDepositToJOJO\n    ) external override nonReentrant nonFlashLoanReentrant{\n        //     t0BorrowedAmount = borrowedAmount /  getT0Rate\n        DataTypes.UserInfo storage user = userInfo[msg.sender];\n        _borrow(user, isDepositToJOJO, to, amount, msg.sender);\n        require(\n            _isAccountSafeAfterBorrow(user, getTRate()),\n            JUSDErrors.AFTER_BORROW_ACCOUNT_IS_NOT_SAFE\n        );\n    }\n\n    function repay(\n        uint256 amount,\n        address to\n    ) external override nonReentrant returns (uint256) {\n        DataTypes.UserInfo storage user = userInfo[to];\n        uint256 tRate = getTRate();\n        return _repay(user, msg.sender, to, amount, tRate);\n    }\n\n    function withdraw(\n        address collateral,\n        uint256 amount,\n        address to,\n        bool isInternal\n    ) external override nonReentrant nonFlashLoanReentrant{\n        DataTypes.UserInfo storage user = userInfo[msg.sender];\n        _withdraw(amount, collateral, to, msg.sender, isInternal);\n        uint256 tRate = getTRate();\n        require(\n            _isAccountSafe(user, tRate),\n            JUSDErrors.AFTER_WITHDRAW_ACCOUNT_IS_NOT_SAFE\n        );\n    }\n\n    function liquidate(\n        address liquidated,\n        address collateral,\n        address liquidator,\n        uint256 amount,\n        bytes memory afterOperationParam,\n        uint256 expectPrice\n    )\n        external\n        override\n        isValidOperator(msg.sender, liquidator)\n        nonFlashLoanReentrant\n        returns (DataTypes.LiquidateData memory liquidateData)\n    {\n        uint256 JUSDBorrowedT0 = userInfo[liquidated].t0BorrowBalance;\n        uint256 primaryLiquidatedAmount = IERC20(primaryAsset).balanceOf(\n            liquidated\n        );\n        uint256 primaryInsuranceAmount = IERC20(primaryAsset).balanceOf(\n            insurance\n        );\n        isValidLiquidator(liquidated, liquidator);\n        // 1. calculate the liquidate amount\n        liquidateData = _calculateLiquidateAmount(\n            liquidated,\n            collateral,\n            amount\n        );\n        require(\n        // condition: actual liquidate price < max buy price,\n        // price lower, better\n            (liquidateData.insuranceFee + liquidateData.actualLiquidated).decimalDiv(liquidateData.actualCollateral)\n                <= expectPrice,\n            JUSDErrors.LIQUIDATION_PRICE_PROTECTION\n        );\n        // 2. after liquidation flashloan operation\n        _afterLiquidateOperation(\n            afterOperationParam,\n            amount,\n            collateral,\n            liquidated,\n            liquidateData\n        );\n\n        // 3. price protect\n        require(\n            JUSDBorrowedT0 - userInfo[liquidated].t0BorrowBalance >=\n                liquidateData.actualLiquidatedT0,\n            JUSDErrors.REPAY_AMOUNT_NOT_ENOUGH\n        );\n        require(\n            IERC20(primaryAsset).balanceOf(insurance) -\n                primaryInsuranceAmount >=\n                liquidateData.insuranceFee,\n            JUSDErrors.INSURANCE_AMOUNT_NOT_ENOUGH\n        );\n        require(\n            IERC20(primaryAsset).balanceOf(liquidated) -\n                primaryLiquidatedAmount >=\n                liquidateData.liquidatedRemainUSDC,\n            JUSDErrors.LIQUIDATED_AMOUNT_NOT_ENOUGH\n        );\n        emit Liquidate(\n            collateral,\n            liquidator,\n            liquidated,\n            msg.sender,\n            liquidateData.actualCollateral,\n            liquidateData.actualLiquidated,\n            liquidateData.insuranceFee\n        );\n    }\n\n    function handleDebt(\n        address[] calldata liquidatedTraders\n    ) external onlyOwner {\n        for (uint256 i; i < liquidatedTraders.length; i = i + 1) {\n            _handleBadDebt(liquidatedTraders[i]);\n        }\n    }\n\n    function flashLoan(\n        address receiver,\n        address collateral,\n        uint256 amount,\n        address to,\n        bytes memory param\n    ) external nonFlashLoanReentrant {\n        DataTypes.UserInfo storage user = userInfo[msg.sender];\n        _withdraw(amount, collateral, receiver, msg.sender, false);\n        // repay\n        IFlashLoanReceive(receiver).JOJOFlashLoan(\n            collateral,\n            amount,\n            to,\n            param\n        );\n        require(\n            _isAccountSafe(user, getTRate()),\n            JUSDErrors.AFTER_FLASHLOAN_ACCOUNT_IS_NOT_SAFE\n        );\n        emit FlashLoan(collateral, amount);\n    }\n\n    function _deposit(\n        DataTypes.ReserveInfo storage reserve,\n        DataTypes.UserInfo storage user,\n        uint256 amount,\n        address collateral,\n        address to,\n        address from\n    ) internal {\n        require(reserve.isDepositAllowed, JUSDErrors.RESERVE_NOT_ALLOW_DEPOSIT);\n        require(amount != 0, JUSDErrors.DEPOSIT_AMOUNT_IS_ZERO);\n        IERC20(collateral).safeTransferFrom(from, address(this), amount);\n        _addCollateralIfNotExists(user, collateral);\n        user.depositBalance[collateral] += amount;\n        reserve.totalDepositAmount += amount;\n        require(\n            user.depositBalance[collateral] <=\n                reserve.maxDepositAmountPerAccount,\n            JUSDErrors.EXCEED_THE_MAX_DEPOSIT_AMOUNT_PER_ACCOUNT\n        );\n        require(\n            reserve.totalDepositAmount <= reserve.maxTotalDepositAmount,\n            JUSDErrors.EXCEED_THE_MAX_DEPOSIT_AMOUNT_TOTAL\n        );\n        emit Deposit(collateral, from, to, msg.sender, amount);\n    }\n\n    //    Pass parameter checking, excluding checking legality\n    function _borrow(\n        DataTypes.UserInfo storage user,\n        bool isDepositToJOJO,\n        address to,\n        uint256 tAmount,\n        address from\n    ) internal {\n        uint256 tRate = getTRate();\n        //        tAmount % tRate ？ tAmount / tRate + 1 ： tAmount % tRate\n        uint256 t0Amount = tAmount.decimalRemainder(tRate)\n            ? tAmount.decimalDiv(tRate)\n            : tAmount.decimalDiv(tRate) + 1;\n        user.t0BorrowBalance += t0Amount;\n        t0TotalBorrowAmount += t0Amount;\n        if (isDepositToJOJO) {\n            IERC20(JUSD).approve(address(JOJODealer), tAmount);\n            IDealer(JOJODealer).deposit(0, tAmount, to);\n        } else {\n            IERC20(JUSD).safeTransfer(to, tAmount);\n        }\n        // Personal account hard cap\n        require(\n            user.t0BorrowBalance.decimalMul(tRate) <= maxPerAccountBorrowAmount,\n            JUSDErrors.EXCEED_THE_MAX_BORROW_AMOUNT_PER_ACCOUNT\n        );\n        // Global account hard cap\n        require(\n            t0TotalBorrowAmount.decimalMul(tRate) <= maxTotalBorrowAmount,\n            JUSDErrors.EXCEED_THE_MAX_BORROW_AMOUNT_TOTAL\n        );\n        emit Borrow(from, to, tAmount, isDepositToJOJO);\n    }\n\n    function _repay(\n        DataTypes.UserInfo storage user,\n        address payer,\n        address to,\n        uint256 amount,\n        uint256 tRate\n    ) internal returns (uint256) {\n        require(amount != 0, JUSDErrors.REPAY_AMOUNT_IS_ZERO);\n        uint256 JUSDBorrowed = user.t0BorrowBalance.decimalMul(tRate);\n        uint256 tBorrowAmount;\n        uint256 t0Amount;\n        if (JUSDBorrowed <= amount) {\n            tBorrowAmount = JUSDBorrowed;\n            t0Amount = user.t0BorrowBalance;\n        } else {\n            tBorrowAmount = amount;\n            t0Amount = amount.decimalDiv(tRate);\n        }\n        IERC20(JUSD).safeTransferFrom(payer, address(this), tBorrowAmount);\n        user.t0BorrowBalance -= t0Amount;\n        t0TotalBorrowAmount -= t0Amount;\n        emit Repay(payer, to, tBorrowAmount);\n        return tBorrowAmount;\n    }\n\n    function _withdraw(\n        uint256 amount,\n        address collateral,\n        address to,\n        address from,\n        bool isInternal\n    ) internal {\n        DataTypes.ReserveInfo storage reserve = reserveInfo[collateral];\n        DataTypes.UserInfo storage fromAccount = userInfo[from];\n        require(amount != 0, JUSDErrors.WITHDRAW_AMOUNT_IS_ZERO);\n        require(\n            amount <= fromAccount.depositBalance[collateral],\n            JUSDErrors.WITHDRAW_AMOUNT_IS_TOO_BIG\n        );\n\n        fromAccount.depositBalance[collateral] -= amount;\n        if (isInternal) {\n            DataTypes.UserInfo storage toAccount = userInfo[to];\n            _addCollateralIfNotExists(toAccount, collateral);\n            toAccount.depositBalance[collateral] += amount;\n            require(\n                toAccount.depositBalance[collateral] <=\n                    reserve.maxDepositAmountPerAccount,\n                JUSDErrors.EXCEED_THE_MAX_DEPOSIT_AMOUNT_PER_ACCOUNT\n            );\n        } else {\n            reserve.totalDepositAmount -= amount;\n            IERC20(collateral).safeTransfer(to, amount);\n        }\n        emit Withdraw(collateral, from, to, amount, isInternal);\n        _removeEmptyCollateral(fromAccount, collateral);\n    }\n\n    function isValidLiquidator(address liquidated, address liquidator) internal view {\n        require(\n            liquidator != liquidated,\n            JUSDErrors.SELF_LIQUIDATION_NOT_ALLOWED\n        );\n        if(isLiquidatorWhitelistOpen){\n            require(isLiquidatorWhiteList[liquidator], JUSDErrors.LIQUIDATOR_NOT_IN_THE_WHITELIST);\n        }\n    }\n\n    /// @notice liquidate is divided into three steps,\n    // 1. determine whether liquidatedTrader is safe\n    // 2. calculate the collateral amount actually liquidated\n    // 3. transfer the insurance fee\n    function _calculateLiquidateAmount(\n        address liquidated,\n        address collateral,\n        uint256 amount\n    ) internal view returns (DataTypes.LiquidateData memory liquidateData) {\n        DataTypes.UserInfo storage liquidatedInfo = userInfo[liquidated];\n        require(amount != 0, JUSDErrors.LIQUIDATE_AMOUNT_IS_ZERO);\n        require(\n            amount <= liquidatedInfo.depositBalance[collateral],\n            JUSDErrors.LIQUIDATE_AMOUNT_IS_TOO_BIG\n        );\n        uint256 tRate = getTRate();\n        require(\n            _isStartLiquidation(liquidatedInfo, tRate),\n            JUSDErrors.ACCOUNT_IS_SAFE\n        );\n        DataTypes.ReserveInfo memory reserve = reserveInfo[collateral];\n        uint256 price = IPriceChainLink(reserve.oracle).getAssetPrice();\n        uint256 priceOff = price.decimalMul(\n            DecimalMath.ONE - reserve.liquidationPriceOff\n        );\n        uint256 liquidateAmount = amount.decimalMul(priceOff).decimalMul(\n            JOJOConstant.ONE - reserve.insuranceFeeRate\n        );\n        uint256 JUSDBorrowed = liquidatedInfo.t0BorrowBalance.decimalMul(tRate);\n        /*\n        liquidateAmount <= JUSDBorrowed\n        liquidateAmount = amount * priceOff * (1-insuranceFee)\n        actualJUSD = actualCollateral * priceOff\n        insuranceFee = actualCollateral * priceOff * insuranceFeeRate\n        */\n        if (liquidateAmount <= JUSDBorrowed) {\n            liquidateData.actualCollateral = amount;\n            liquidateData.insuranceFee = amount.decimalMul(priceOff).decimalMul(\n                reserve.insuranceFeeRate\n            );\n            liquidateData.actualLiquidatedT0 = liquidateAmount.decimalDiv(\n                tRate\n            );\n            liquidateData.actualLiquidated = liquidateAmount;\n        } else {\n            //            actualJUSD = actualCollateral * priceOff\n            //            = JUSDBorrowed * priceOff / priceOff * (1-insuranceFeeRate)\n            //            = JUSDBorrowed / (1-insuranceFeeRate)\n            //            insuranceFee = actualJUSD * insuranceFeeRate\n            //            = actualCollateral * priceOff * insuranceFeeRate\n            //            = JUSDBorrowed * insuranceFeeRate / (1- insuranceFeeRate)\n            liquidateData.actualCollateral = JUSDBorrowed\n                .decimalDiv(priceOff)\n                .decimalDiv(JOJOConstant.ONE - reserve.insuranceFeeRate);\n            liquidateData.insuranceFee = JUSDBorrowed\n                .decimalMul(reserve.insuranceFeeRate)\n                .decimalDiv(JOJOConstant.ONE - reserve.insuranceFeeRate);\n            liquidateData.actualLiquidatedT0 = liquidatedInfo.t0BorrowBalance;\n            liquidateData.actualLiquidated = JUSDBorrowed;\n        }\n\n        liquidateData.liquidatedRemainUSDC = (amount -\n            liquidateData.actualCollateral).decimalMul(price);\n    }\n\n    function _addCollateralIfNotExists(\n        DataTypes.UserInfo storage user,\n        address collateral\n    ) internal {\n        if (!user.hasCollateral[collateral]) {\n            user.hasCollateral[collateral] = true;\n            user.collateralList.push(collateral);\n        }\n    }\n\n    function _removeEmptyCollateral(\n        DataTypes.UserInfo storage user,\n        address collateral\n    ) internal {\n        if (user.depositBalance[collateral] == 0) {\n            user.hasCollateral[collateral] = false;\n            address[] storage collaterals = user.collateralList;\n            for (uint256 i; i < collaterals.length; i = i + 1) {\n                if (collaterals[i] == collateral) {\n                    collaterals[i] = collaterals[collaterals.length - 1];\n                    collaterals.pop();\n                    break;\n                }\n            }\n        }\n    }\n\n    function _afterLiquidateOperation(\n        bytes memory afterOperationParam,\n        uint256 flashloanAmount,\n        address collateral,\n        address liquidated,\n        DataTypes.LiquidateData memory liquidateData\n    ) internal {\n        (address flashloanAddress, bytes memory param) = abi.decode(\n            afterOperationParam,\n            (address, bytes)\n        );\n        _withdraw(\n            flashloanAmount,\n            collateral,\n            flashloanAddress,\n            liquidated,\n            false\n        );\n        param = abi.encode(liquidateData, param);\n        IFlashLoanReceive(flashloanAddress).JOJOFlashLoan(\n            collateral,\n            flashloanAmount,\n            liquidated,\n            param\n        );\n    }\n\n    /// @notice handle the bad debt\n    /// @param liquidatedTrader need to be liquidated\n    function _handleBadDebt(address liquidatedTrader) internal {\n        DataTypes.UserInfo storage liquidatedTraderInfo = userInfo[\n            liquidatedTrader\n        ];\n        uint256 tRate = getTRate();\n        if (\n            liquidatedTraderInfo.collateralList.length == 0 &&\n            _isStartLiquidation(liquidatedTraderInfo, tRate)\n        ) {\n            DataTypes.UserInfo storage insuranceInfo = userInfo[insurance];\n            uint256 borrowJUSDT0 = liquidatedTraderInfo.t0BorrowBalance;\n            insuranceInfo.t0BorrowBalance += borrowJUSDT0;\n            liquidatedTraderInfo.t0BorrowBalance = 0;\n            emit HandleBadDebt(liquidatedTrader, borrowJUSDT0);\n        }\n    }\n}"
    },
    {
      "filename": "JUSDV1/src/Impl/JUSDBank.sol",
      "content": "/*\n    Copyright 2022 JOJO Exchange\n    SPDX-License-Identifier: BUSL-1.1*/\npragma solidity 0.8.9;\n\nimport \"../Interface/IJUSDBank.sol\";\nimport \"../Interface/IFlashLoanReceive.sol\";\nimport \"./JUSDBankStorage.sol\";\nimport \"./JUSDOperation.sol\";\nimport \"./JUSDView.sol\";\nimport \"./JUSDMulticall.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@JOJO/contracts/intf/IDealer.sol\";\nimport {IPriceChainLink} from \"../Interface/IPriceChainLink.sol\";\n\ncontract JUSDBank is IJUSDBank, JUSDOperation, JUSDView, JUSDMulticall {\n    using DecimalMath for uint256;\n    using SafeERC20 for IERC20;\n\n    constructor(\n        uint256 _maxReservesNum,\n        address _insurance,\n        address _JUSD,\n        address _JOJODealer,\n        uint256 _maxPerAccountBorrowAmount,\n        uint256 _maxTotalBorrowAmount,\n        uint256 _borrowFeeRate,\n        address _primaryAsset\n    ) {\n        maxReservesNum = _maxReservesNum;\n        JUSD = _JUSD;\n        JOJODealer = _JOJODealer;\n        insurance = _insurance;\n        maxPerAccountBorrowAmount = _maxPerAccountBorrowAmount;\n        maxTotalBorrowAmount = _maxTotalBorrowAmount;\n        borrowFeeRate = _borrowFeeRate;\n        t0Rate = JOJOConstant.ONE;\n        primaryAsset = _primaryAsset;\n        lastUpdateTimestamp = uint32(block.timestamp);\n    }\n\n    // --------------------------event-----------------------\n\n    event HandleBadDebt(address indexed liquidatedTrader, uint256 borrowJUSDT0);\n    event Deposit(\n        address indexed collateral,\n        address indexed from,\n        address indexed to,\n        address operator,\n        uint256 amount\n    );\n    event Borrow(\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bool isDepositToJOJO\n    );\n    event Repay(address indexed from, address indexed to, uint256 amount);\n    event Withdraw(\n        address indexed collateral,\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bool ifInternal\n    );\n    event Liquidate(\n        address indexed collateral,\n        address indexed liquidator,\n        address indexed liquidated,\n        address operator,\n        uint256 collateralAmount,\n        uint256 liquidatedAmount,\n        uint256 insuranceFee\n    );\n    event FlashLoan(address indexed collateral, uint256 amount);\n\n    /// @notice to ensure msg.sender is from account or msg.sender is the sub account of from\n    /// so that msg.sender can send the transaction\n    modifier isValidOperator(address operator, address client) {\n        require(\n            msg.sender == client || operatorRegistry[client][operator],\n            JUSDErrors.CAN_NOT_OPERATE_ACCOUNT\n        );\n        _;\n    }\n    modifier isLiquidator(address liquidator) {\n        if(isLiquidatorWhitelistOpen){\n            require(isLiquidatorWhiteList[liquidator], \"liquidator is not in the liquidator white list\");\n        }\n        _;\n    }\n\n    function deposit(\n        address from,\n        address collateral,\n        uint256 amount,\n        address to\n    ) external override nonReentrant isValidOperator(msg.sender, from) {\n        DataTypes.ReserveInfo storage reserve = reserveInfo[collateral];\n        DataTypes.UserInfo storage user = userInfo[to];\n        //        deposit\n        _deposit(reserve, user, amount, collateral, to, from);\n    }\n\n    function borrow(\n        uint256 amount,\n        address to,\n        bool isDepositToJOJO\n    ) external override nonReentrant nonFlashLoanReentrant{\n        //     t0BorrowedAmount = borrowedAmount /  getT0Rate\n        DataTypes.UserInfo storage user = userInfo[msg.sender];\n        _borrow(user, isDepositToJOJO, to, amount, msg.sender);\n        require(\n            _isAccountSafeAfterBorrow(user, getTRate()),\n            JUSDErrors.AFTER_BORROW_ACCOUNT_IS_NOT_SAFE\n        );\n    }\n\n    function repay(\n        uint256 amount,\n        address to\n    ) external override nonReentrant returns (uint256) {\n        DataTypes.UserInfo storage user = userInfo[to];\n        uint256 tRate = getTRate();\n        return _repay(user, msg.sender, to, amount, tRate);\n    }\n\n    function withdraw(\n        address collateral,\n        uint256 amount,\n        address to,\n        bool isInternal\n    ) external override nonReentrant nonFlashLoanReentrant{\n        DataTypes.UserInfo storage user = userInfo[msg.sender];\n        _withdraw(amount, collateral, to, msg.sender, isInternal);\n        uint256 tRate = getTRate();\n        require(\n            _isAccountSafe(user, tRate),\n            JUSDErrors.AFTER_WITHDRAW_ACCOUNT_IS_NOT_SAFE\n        );\n    }\n\n    function liquidate(\n        address liquidated,\n        address collateral,\n        address liquidator,\n        uint256 amount,\n        bytes memory afterOperationParam,\n        uint256 expectPrice\n    )\n        external\n        override\n        isValidOperator(msg.sender, liquidator)\n        nonFlashLoanReentrant\n        returns (DataTypes.LiquidateData memory liquidateData)\n    {\n        uint256 JUSDBorrowedT0 = userInfo[liquidated].t0BorrowBalance;\n        uint256 primaryLiquidatedAmount = IERC20(primaryAsset).balanceOf(\n            liquidated\n        );\n        uint256 primaryInsuranceAmount = IERC20(primaryAsset).balanceOf(\n            insurance\n        );\n        isValidLiquidator(liquidated, liquidator);\n        // 1. calculate the liquidate amount\n        liquidateData = _calculateLiquidateAmount(\n            liquidated,\n            collateral,\n            amount\n        );\n        require(\n        // condition: actual liquidate price < max buy price,\n        // price lower, better\n            (liquidateData.insuranceFee + liquidateData.actualLiquidated).decimalDiv(liquidateData.actualCollateral)\n                <= expectPrice,\n            JUSDErrors.LIQUIDATION_PRICE_PROTECTION\n        );\n        // 2. after liquidation flashloan operation\n        _afterLiquidateOperation(\n            afterOperationParam,\n            amount,\n            collateral,\n            liquidated,\n            liquidateData\n        );\n\n        // 3. price protect\n        require(\n            JUSDBorrowedT0 - userInfo[liquidated].t0BorrowBalance >=\n                liquidateData.actualLiquidatedT0,\n            JUSDErrors.REPAY_AMOUNT_NOT_ENOUGH\n        );\n        require(\n            IERC20(primaryAsset).balanceOf(insurance) -\n                primaryInsuranceAmount >=\n                liquidateData.insuranceFee,\n            JUSDErrors.INSURANCE_AMOUNT_NOT_ENOUGH\n        );\n        require(\n            IERC20(primaryAsset).balanceOf(liquidated) -\n                primaryLiquidatedAmount >=\n                liquidateData.liquidatedRemainUSDC,\n            JUSDErrors.LIQUIDATED_AMOUNT_NOT_ENOUGH\n        );\n        emit Liquidate(\n            collateral,\n            liquidator,\n            liquidated,\n            msg.sender,\n            liquidateData.actualCollateral,\n            liquidateData.actualLiquidated,\n            liquidateData.insuranceFee\n        );\n    }\n\n    function handleDebt(\n        address[] calldata liquidatedTraders\n    ) external onlyOwner {\n        for (uint256 i; i < liquidatedTraders.length; i = i + 1) {\n            _handleBadDebt(liquidatedTraders[i]);\n        }\n    }\n\n    function flashLoan(\n        address receiver,\n        address collateral,\n        uint256 amount,\n        address to,\n        bytes memory param\n    ) external nonFlashLoanReentrant {\n        DataTypes.UserInfo storage user = userInfo[msg.sender];\n        _withdraw(amount, collateral, receiver, msg.sender, false);\n        // repay\n        IFlashLoanReceive(receiver).JOJOFlashLoan(\n            collateral,\n            amount,\n            to,\n            param\n        );\n        require(\n            _isAccountSafe(user, getTRate()),\n            JUSDErrors.AFTER_FLASHLOAN_ACCOUNT_IS_NOT_SAFE\n        );\n        emit FlashLoan(collateral, amount);\n    }\n\n    function _deposit(\n        DataTypes.ReserveInfo storage reserve,\n        DataTypes.UserInfo storage user,\n        uint256 amount,\n        address collateral,\n        address to,\n        address from\n    ) internal {\n        require(reserve.isDepositAllowed, JUSDErrors.RESERVE_NOT_ALLOW_DEPOSIT);\n        require(amount != 0, JUSDErrors.DEPOSIT_AMOUNT_IS_ZERO);\n        IERC20(collateral).safeTransferFrom(from, address(this), amount);\n        _addCollateralIfNotExists(user, collateral);\n        user.depositBalance[collateral] += amount;\n        reserve.totalDepositAmount += amount;\n        require(\n            user.depositBalance[collateral] <=\n                reserve.maxDepositAmountPerAccount,\n            JUSDErrors.EXCEED_THE_MAX_DEPOSIT_AMOUNT_PER_ACCOUNT\n        );\n        require(\n            reserve.totalDepositAmount <= reserve.maxTotalDepositAmount,\n            JUSDErrors.EXCEED_THE_MAX_DEPOSIT_AMOUNT_TOTAL\n        );\n        emit Deposit(collateral, from, to, msg.sender, amount);\n    }\n\n    //    Pass parameter checking, excluding checking legality\n    function _borrow(\n        DataTypes.UserInfo storage user,\n        bool isDepositToJOJO,\n        address to,\n        uint256 tAmount,\n        address from\n    ) internal {\n        uint256 tRate = getTRate();\n        //        tAmount % tRate ？ tAmount / tRate + 1 ： tAmount % tRate\n        uint256 t0Amount = tAmount.decimalRemainder(tRate)\n            ? tAmount.decimalDiv(tRate)\n            : tAmount.decimalDiv(tRate) + 1;\n        user.t0BorrowBalance += t0Amount;\n        t0TotalBorrowAmount += t0Amount;\n        if (isDepositToJOJO) {\n            IERC20(JUSD).approve(address(JOJODealer), tAmount);\n            IDealer(JOJODealer).deposit(0, tAmount, to);\n        } else {\n            IERC20(JUSD).safeTransfer(to, tAmount);\n        }\n        // Personal account hard cap\n        require(\n            user.t0BorrowBalance.decimalMul(tRate) <= maxPerAccountBorrowAmount,\n            JUSDErrors.EXCEED_THE_MAX_BORROW_AMOUNT_PER_ACCOUNT\n        );\n        // Global account hard cap\n        require(\n            t0TotalBorrowAmount.decimalMul(tRate) <= maxTotalBorrowAmount,\n            JUSDErrors.EXCEED_THE_MAX_BORROW_AMOUNT_TOTAL\n        );\n        emit Borrow(from, to, tAmount, isDepositToJOJO);\n    }\n\n    function _repay(\n        DataTypes.UserInfo storage user,\n        address payer,\n        address to,\n        uint256 amount,\n        uint256 tRate\n    ) internal returns (uint256) {\n        require(amount != 0, JUSDErrors.REPAY_AMOUNT_IS_ZERO);\n        uint256 JUSDBorrowed = user.t0BorrowBalance.decimalMul(tRate);\n        uint256 tBorrowAmount;\n        uint256 t0Amount;\n        if (JUSDBorrowed <= amount) {\n            tBorrowAmount = JUSDBorrowed;\n            t0Amount = user.t0BorrowBalance;\n        } else {\n            tBorrowAmount = amount;\n            t0Amount = amount.decimalDiv(tRate);\n        }\n        IERC20(JUSD).safeTransferFrom(payer, address(this), tBorrowAmount);\n        user.t0BorrowBalance -= t0Amount;\n        t0TotalBorrowAmount -= t0Amount;\n        emit Repay(payer, to, tBorrowAmount);\n        return tBorrowAmount;\n    }\n\n    function _withdraw(\n        uint256 amount,\n        address collateral,\n        address to,\n        address from,\n        bool isInternal\n    ) internal {\n        DataTypes.ReserveInfo storage reserve = reserveInfo[collateral];\n        DataTypes.UserInfo storage fromAccount = userInfo[from];\n        require(amount != 0, JUSDErrors.WITHDRAW_AMOUNT_IS_ZERO);\n        require(\n            amount <= fromAccount.depositBalance[collateral],\n            JUSDErrors.WITHDRAW_AMOUNT_IS_TOO_BIG\n        );\n\n        fromAccount.depositBalance[collateral] -= amount;\n        if (isInternal) {\n            DataTypes.UserInfo storage toAccount = userInfo[to];\n            _addCollateralIfNotExists(toAccount, collateral);\n            toAccount.depositBalance[collateral] += amount;\n            require(\n                toAccount.depositBalance[collateral] <=\n                    reserve.maxDepositAmountPerAccount,\n                JUSDErrors.EXCEED_THE_MAX_DEPOSIT_AMOUNT_PER_ACCOUNT\n            );\n        } else {\n            reserve.totalDepositAmount -= amount;\n            IERC20(collateral).safeTransfer(to, amount);\n        }\n        emit Withdraw(collateral, from, to, amount, isInternal);\n        _removeEmptyCollateral(fromAccount, collateral);\n    }\n\n    function isValidLiquidator(address liquidated, address liquidator) internal view {\n        require(\n            liquidator != liquidated,\n            JUSDErrors.SELF_LIQUIDATION_NOT_ALLOWED\n        );\n        if(isLiquidatorWhitelistOpen){\n            require(isLiquidatorWhiteList[liquidator], JUSDErrors.LIQUIDATOR_NOT_IN_THE_WHITELIST);\n        }\n    }\n\n    /// @notice liquidate is divided into three steps,\n    // 1. determine whether liquidatedTrader is safe\n    // 2. calculate the collateral amount actually liquidated\n    // 3. transfer the insurance fee\n    function _calculateLiquidateAmount(\n        address liquidated,\n        address collateral,\n        uint256 amount\n    ) internal view returns (DataTypes.LiquidateData memory liquidateData) {\n        DataTypes.UserInfo storage liquidatedInfo = userInfo[liquidated];\n        require(amount != 0, JUSDErrors.LIQUIDATE_AMOUNT_IS_ZERO);\n        require(\n            amount <= liquidatedInfo.depositBalance[collateral],\n            JUSDErrors.LIQUIDATE_AMOUNT_IS_TOO_BIG\n        );\n        uint256 tRate = getTRate();\n        require(\n            _isStartLiquidation(liquidatedInfo, tRate),\n            JUSDErrors.ACCOUNT_IS_SAFE\n        );\n        DataTypes.ReserveInfo memory reserve = reserveInfo[collateral];\n        uint256 price = IPriceChainLink(reserve.oracle).getAssetPrice();\n        uint256 priceOff = price.decimalMul(\n            DecimalMath.ONE - reserve.liquidationPriceOff\n        );\n        uint256 liquidateAmount = amount.decimalMul(priceOff).decimalMul(\n            JOJOConstant.ONE - reserve.insuranceFeeRate\n        );\n        uint256 JUSDBorrowed = liquidatedInfo.t0BorrowBalance.decimalMul(tRate);\n        /*\n        liquidateAmount <= JUSDBorrowed\n        liquidateAmount = amount * priceOff * (1-insuranceFee)\n        actualJUSD = actualCollateral * priceOff\n        insuranceFee = actualCollateral * priceOff * insuranceFeeRate\n        */\n        if (liquidateAmount <= JUSDBorrowed) {\n            liquidateData.actualCollateral = amount;\n            liquidateData.insuranceFee = amount.decimalMul(priceOff).decimalMul(\n                reserve.insuranceFeeRate\n            );\n            liquidateData.actualLiquidatedT0 = liquidateAmount.decimalDiv("
    }
  ]
}