{
  "Title": "The approval value obtained in the constructor may not be enough for the long term of the smart contract",
  "Content": "##### Description\nAt lines: https://github.com/jmonteer/yearnV2-strat-SNX-staking/blob/91b839df4a350d80cb583795bccafe0836fdb732/contracts/Strategy.sol#L79-L85\nthe smart contract constructor call `safeApproveA()` functions for different tokens. But in the process of work, the obtained value will only decrease. If this value decreases to zero, then the tokens will remain locked in the contract forever.\n  \n##### Recommendation\nIt is recommended to add a function to increase the value of approvals.\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/Strategy.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {BaseStrategy, VaultAPI} from \"@yearnvaults/contracts/BaseStrategy.sol\";\nimport {\n    SafeERC20,\n    SafeMath,\n    IERC20,\n    Address\n} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\n\nimport \"../interfaces/ISynthetix.sol\";\nimport \"../interfaces/IIssuer.sol\";\nimport \"../interfaces/IFeePool.sol\";\nimport \"../interfaces/IReadProxy.sol\";\nimport \"../interfaces/IAddressResolver.sol\";\nimport \"../interfaces/IExchangeRates.sol\";\nimport \"../interfaces/IRewardEscrowV2.sol\";\n\nimport \"../interfaces/IVault.sol\";\nimport \"../interfaces/ISushiRouter.sol\";\n\ncontract Strategy is BaseStrategy {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    uint256 public constant MIN_ISSUE = 50 * 1e18;\n    uint256 public ratioThreshold = 1e15;\n    uint256 public constant MAX_RATIO = type(uint256).max;\n    uint256 public constant MAX_BPS = 10_000;\n\n    address public constant susd =\n        address(0x57Ab1ec28D129707052df4dF418D58a2D46d5f51);\n    IReadProxy public constant readProxy =\n        IReadProxy(address(0x4E3b31eB0E5CB73641EE1E65E7dCEFe520bA3ef2));\n    address public constant WETH =\n        address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    ISushiRouter public constant sushiswap =\n        ISushiRouter(address(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F));\n    ISushiRouter public constant uniswap =\n        ISushiRouter(address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D));\n    ISushiRouter public router =\n        ISushiRouter(address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D));\n\n    uint256 public targetRatioMultiplier = 12_500;\n    IVault public susdVault;\n\n    // to keep track of next entry to vest\n    uint256 public entryIDIndex = 0;\n    // entryIDs of escrow rewards claimed and to be claimed by the Strategy\n    uint256[] public entryIDs;\n\n    bytes32 private constant CONTRACT_SYNTHETIX = \"Synthetix\";\n    bytes32 private constant CONTRACT_EXRATES = \"ExchangeRates\";\n    bytes32 private constant CONTRACT_REWARDESCROW_V2 = \"RewardEscrowV2\";\n    bytes32 private constant CONTRACT_ISSUER = \"Issuer\";\n    bytes32 private constant CONTRACT_FEEPOOL = \"FeePool\";\n\n    // ********************** EVENTS **********************\n\n    event RepayDebt(uint256 repaidAmount, uint256 debtAfterRepayment);\n\n    // ********************** CONSTRUCTOR **********************\n\n    constructor(address _vault, address _susdVault)\n        public\n        BaseStrategy(_vault)\n    {\n        susdVault = IVault(_susdVault);\n\n        // max time between harvest to collect rewards from each epoch\n        maxReportDelay = 7 * 24 * 3600;\n\n        // To deposit sUSD in the sUSD vault\n        IERC20(susd).safeApprove(address(_susdVault), type(uint256).max);\n        // To exchange sUSD for SNX\n        IERC20(susd).safeApprove(address(uniswap), type(uint256).max);\n        IERC20(susd).safeApprove(address(sushiswap), type(uint256).max);\n        // To exchange SNX for sUSD\n        IERC20(want).safeApprove(address(uniswap), type(uint256).max);\n        IERC20(want).safeApprove(address(sushiswap), type(uint256).max);\n    }\n\n    // ********************** SETTERS **********************\n    function setRouter(uint256 _isSushi) external onlyAuthorized {\n        if (_isSushi == uint256(1)) {\n            router = sushiswap;\n        } else if (_isSushi == uint256(0)) {\n            router = uniswap;\n        } else {\n            revert(\"!invalid-arg. Use 1 for sushi. 0 for uni\");\n        }\n    }\n\n    function setTargetRatioMultiplier(uint256 _targetRatioMultiplier) external {\n        require(\n            msg.sender == governance() ||\n                msg.sender == VaultAPI(address(vault)).management()\n        );\n        targetRatioMultiplier = _targetRatioMultiplier;\n    }\n\n    function setRatioThreshold(uint256 _ratioThreshold)\n        external\n        onlyStrategist\n    {\n        ratioThreshold = _ratioThreshold;\n    }\n\n    // This method is used to migrate the vault where we deposit the sUSD for yield. It should be rarely used\n    function migrateSusdVault(IVault newSusdVault, uint256 maxLoss)\n        external\n        onlyGovernance\n    {\n        // we tolerate losses to avoid being locked in the vault if things don't work out\n        // governance must take this into account before migrating\n        susdVault.withdraw(\n            susdVault.balanceOf(address(this)),\n            address(this),\n            maxLoss\n        );\n        IERC20(susd).safeApprove(address(susdVault), 0);\n\n        susdVault = newSusdVault;\n        IERC20(susd).safeApprove(address(newSusdVault), type(uint256).max);\n        newSusdVault.deposit();\n    }\n\n    // ********************** MANUAL **********************\n\n    function manuallyRepayDebt(uint256 amount) external onlyAuthorized {\n        // To be used in case of emergencies, to operate the vault manually\n        repayDebt(amount);\n    }\n\n    // ********************** YEARN STRATEGY **********************\n\n    function name() external view override returns (string memory) {\n        return \"StrategySynthetixSusdMinter\";\n    }\n\n    function estimatedTotalAssets() public view override returns (uint256) {\n        uint256 totalAssets =\n            balanceOfWant().add(estimatedProfit()).add(\n                sUSDToWant(balanceOfSusdInVault().add(balanceOfSusd()))\n            );\n        uint256 totalLiabilities = sUSDToWant(balanceOfDebt());\n        // NOTE: the ternary operator is required because debt can be higher than assets\n        // due to i) increase in debt or ii) losses in invested assets\n        return\n            totalAssets > totalLiabilities\n                ? totalAssets.sub(totalLiabilities)\n                : 0;\n    }\n\n    function prepareReturn(uint256 _debtOutstanding)\n        internal\n        override\n        returns (\n            uint256 _profit,\n            uint256 _loss,\n            uint256 _debtPayment\n        )\n    {\n        uint256 totalDebt = vault.strategies(address(this)).totalDebt;\n\n        claimProfits();\n        vestNextRewardsEntry();\n\n        uint256 totalAssetsAfterProfit = estimatedTotalAssets();\n\n        _profit = totalAssetsAfterProfit > totalDebt\n            ? totalAssetsAfterProfit.sub(totalDebt)\n            : 0;\n\n        // if the vault is claiming repayment of debt\n        if (_debtOutstanding > 0) {\n            uint256 _amountFreed = 0;\n            (_amountFreed, _loss) = liquidatePosition(_debtOutstanding);\n            _debtPayment = Math.min(_debtOutstanding, _amountFreed);\n\n            if (_loss > 0) {\n                _profit = 0;\n            }\n        }\n    }\n\n    function adjustPosition(uint256 _debtOutstanding) internal override {\n        if (emergencyExit) {\n            return;\n        }\n\n        if (_debtOutstanding >= balanceOfWant()) {\n            return;\n        }\n\n        // compare current ratio with target ratio\n        uint256 _currentRatio = getCurrentRatio();\n        // NOTE: target debt ratio is over 20% to maximize APY\n        uint256 _targetRatio = getTargetRatio();\n        uint256 _issuanceRatio = getIssuanceRatio();\n        // burn debt (sUSD) if the ratio is too high\n        // collateralisation_ratio = debt / collat\n\n        if (\n            _currentRatio > _targetRatio &&\n            _currentRatio.sub(_targetRatio) >= ratioThreshold\n        ) {\n            // NOTE: min threshold to act on differences = 1e16 (ratioThreshold)\n            // current debt ratio might be unhealthy\n            // we need to repay some debt to get back to the optimal range\n            uint256 _debtToRepay =\n                balanceOfDebt().sub(getTargetDebt(_collateral()));\n            repayDebt(_debtToRepay);\n        } else if (\n            _issuanceRatio > _currentRatio &&\n            _issuanceRatio.sub(_currentRatio) >= ratioThreshold\n        ) {\n            // NOTE: min threshold to act on differences = 1e16 (ratioThreshold)\n            // if there is enough collateral to issue Synth, issue it\n            // this should put the c-ratio around 500% (i.e. debt ratio around 20%)\n            uint256 _maxSynths = _synthetix().maxIssuableSynths(address(this));\n            uint256 _debtBalance = balanceOfDebt();\n            // only issue new debt if it is going to be used\n            if (\n                _maxSynths > _debtBalance &&\n                _maxSynths.sub(_debtBalance) >= MIN_ISSUE\n            ) {\n                _synthetix().issueMaxSynths();\n            }\n        }\n\n        // If there is susd in the strategy, send it to the susd vault\n        // We do MIN_ISSUE instead of 0 since it might be dust\n        if (balanceOfSusd() >= MIN_ISSUE) {\n            susdVault.deposit();\n        }\n    }\n\n    function liquidatePosition(uint256 _amountNeeded)\n        internal\n        override\n        returns (uint256 _liquidatedAmount, uint256 _loss)\n    {\n        // if unlocked collateral balance is not enough, repay debt to unlock\n        // enough `want` to repay debt.\n        // unlocked collateral includes profit just claimed in `prepareReturn`\n        uint256 unlockedWant = _unlockedWant();\n        if (unlockedWant < _amountNeeded) {\n            // NOTE: we use _unlockedWant because `want` balance is the total amount of staked + unstaked want (SNX)\n            reduceLockedCollateral(_amountNeeded.sub(unlockedWant));\n        }\n\n        // Fetch the unlocked collateral for a second time\n        // to update after repaying debt\n        unlockedWant = _unlockedWant();\n        // if not enough want in balance, it means the strategy lost `want`\n        if (_amountNeeded > unlockedWant) {\n            _liquidatedAmount = unlockedWant;\n            _loss = _amountNeeded.sub(unlockedWant);\n        } else {\n            _liquidatedAmount = _amountNeeded;\n        }\n    }\n\n    function prepareMigration(address _newStrategy) internal override {\n        liquidatePosition(vault.strategies(address(this)).totalDebt);\n    }\n\n    // ********************** OPERATIONS FUNCTIONS **********************\n\n    function reduceLockedCollateral(uint256 amountToFree) internal {\n        // amountToFree cannot be higher than the amount that is unlockable\n        amountToFree = Math.min(amountToFree, _unlockableWant());\n\n        if (amountToFree == 0) {\n            return;\n        }\n\n        uint256 _currentDebt = balanceOfDebt();\n        uint256 _newCollateral = _lockedCollateral().sub(amountToFree);\n        uint256 _targetDebt = _newCollateral.mul(getIssuanceRatio()).div(1e18);\n        // NOTE: _newCollateral will always be < _lockedCollateral() so _targetDebt will always be < _currentDebt\n        uint256 _amountToRepay = _currentDebt.sub(_targetDebt);\n\n        repayDebt(_amountToRepay);\n    }\n\n    function repayDebt(uint256 amountToRepay) internal {\n        // debt can grow over the amount of sUSD minted (see Synthetix docs)\n        // if that happens, we might not have enough sUSD to repay debt\n        // if we withdraw in this situation, we need to sell `want` to repay debt and would have losses\n        // this can only be done if c-Ratio is over 272% (otherwise there is not enough unlocked)\n        if (amountToRepay == 0) {\n            return;\n        }\n        uint256 repaidAmount = 0;\n        uint256 _debtBalance = balanceOfDebt();\n        // max amount to be repaid is the total balanceOfDebt\n        amountToRepay = Math.min(_debtBalance, amountToRepay);\n\n        // in case the strategy is going to repay almost all debt, it should repay the total amount of debt\n        if (\n            _debtBalance > amountToRepay &&\n            _debtBalance.sub(amountToRepay) <= MIN_ISSUE\n        ) {\n            amountToRepay = _debtBalance;\n        }\n\n        uint256 currentSusdBalance = balanceOfSusd();\n        if (amountToRepay > currentSusdBalance) {\n            // there is not enough balance in strategy to repay debt\n\n            // we withdraw from susdvault\n            uint256 _withdrawAmount = amountToRepay.sub(currentSusdBalance);\n            withdrawFromSUSDVault(_withdrawAmount);\n            // we fetch sUSD balance for a second time and check if now there is enough\n            currentSusdBalance = balanceOfSusd();\n            if (amountToRepay > currentSusdBalance) {\n                // there was not enough balance in strategy and sUSDvault to repay debt\n\n                // debt is too high to be repaid using current funds, the strategy should:\n                // 1. repay max amount of debt\n                // 2. sell unlocked want to buy required sUSD to pay remaining debt\n                // 3. repay debt\n\n                if (currentSusdBalance > 0) {\n                    // we burn the full sUSD balance to unlock `want` (SNX) in order to sell\n                    if (burnSusd(currentSusdBalance)) {\n                        // subject to minimumStakePeriod\n                        // if successful burnt, update remaining amountToRepay\n                        // repaidAmount is previous debt minus current debt\n                        repaidAmount = _debtBalance.sub(balanceOfDebt());\n                    }\n                }\n                // buy enough sUSD to repay outstanding debt, selling `want` (SNX)\n                // or maximum sUSD with `want` available\n                uint256 amountToBuy =\n                    Math.min(\n                        _getSusdForWant(_unlockedWant()),\n                        amountToRepay.sub(repaidAmount)\n                    );\n                if (amountToBuy > 0) {\n                    buySusdWithWant(amountToBuy);\n                }\n                // amountToRepay should equal balanceOfSusd() (we just bought `amountToRepay` sUSD)\n            }\n        }\n\n        // repay sUSD debt by burning the synth\n        if (amountToRepay > repaidAmount) {\n            burnSusd(amountToRepay.sub(repaidAmount)); // this method is subject to minimumStakePeriod (see Synthetix docs)\n            repaidAmount = amountToRepay;\n        }\n        emit RepayDebt(repaidAmount, _debtBalance.sub(repaidAmount));\n    }\n\n    // two profit sources: Synthetix protocol and Yearn sUSD Vault\n    function claimProfits() internal returns (bool) {\n        uint256 feesAvailable;\n        uint256 rewardsAvailable;\n        (feesAvailable, rewardsAvailable) = _getFeesAvailable();\n\n        if (feesAvailable > 0 || rewardsAvailable > 0) {\n            // claim fees from Synthetix\n            // claim fees (in sUSD) and rewards (in want (SNX))\n            // Synthetix protocol requires issuers to have a c-ratio above 500%\n            // to be able to claim fees so we need to burn some sUSD\n\n            // NOTE: we use issuanceRatio because that is what will put us on 500% c-ratio (i.e. 20% debt ratio)\n            uint256 _targetDebt =\n                getIssuanceRatio().mul(wantToSUSD(_collateral())).div(1e18);\n            uint256 _balanceOfDebt = balanceOfDebt();\n            bool claim = true;\n\n            if (_balanceOfDebt > _targetDebt) {\n                uint256 _requiredPayment = _balanceOfDebt.sub(_targetDebt);\n                uint256 _maxCash =\n                    balanceOfSusd().add(balanceOfSusdInVault()).mul(50).div(\n                        100\n                    );\n                // only claim rewards if the required payment to burn debt up to c-ratio 500%\n                // is less than 50% of available cash (both in strategy and in sUSD vault)\n                claim = _requiredPayment <= _maxCash;\n            }\n\n            if (claim) {\n                // we need to burn sUSD to target\n                burnSusdToTarget();\n\n                // if a vesting entry is going to be created,\n                // we save its ID to keep track of its vesting\n                if (rewardsAvailable > 0) {\n                    entryIDs.push(_rewardEscrowV2().nextEntryId());\n                }\n                // claimFees() will claim both sUSD fees and put SNX rewards in the escrow (in the prev. saved entry)\n                _feePool().claimFees();\n            }\n        }\n\n        // claim profits from Yearn sUSD Vault\n        if (balanceOfDebt() < balanceOfSusdInVault()) {\n            // balance\n            uint256 _valueToWithdraw =\n                balanceOfSusdInVault().sub(balanceOfDebt());\n            withdrawFromSUSDVault(_valueToWithdraw);\n        }\n\n        // sell profits in sUSD for want (SNX) using router\n        uint256 _balance = balanceOfSusd();\n        if (_balance > 0) {\n            buyWantWithSusd(_balance);\n        }\n    }\n\n    function vestNextRewardsEntry() internal {\n        // Synthetix protocol sends SNX staking rewards to a escrow contract that keeps them 52 weeks, until they vest\n        // each time we claim the SNX rewards, a VestingEntry is created in the escrow contract for the amount that was owed\n        // we need to keep track of those VestingEntries to know when they vest and claim them\n        // after they vest and we claim them, we will receive them in our balance (strategy's balance)\n        if (entryIDs.length == 0) {\n            return;\n        }\n\n        // The strategy keeps track of the next VestingEntry expected to vest and only when it has vested, it checks the next one\n        // this works because the VestingEntries record has been saved in chronological order and they will vest in chronological order too\n        IRewardEscrowV2 re = _rewardEscrowV2();\n        uint256 nextEntryID = entryIDs[entryIDIndex];\n        uint256 _claimable =\n            re.getVestingEntryClaimable(address(this), nextEntryID);\n        // check if we need to vest\n        if (_claimable == 0) {\n            return;\n        }\n\n        // vest entryID\n        uint256[] memory params = new uint256[](1);\n        params[0] = nextEntryID;\n        re.vest(params);\n\n        // we update the nextEntryID to point to the next VestingEntry\n        entryIDIndex++;\n    }\n\n    function tendTrigger(uint256 callCost) public view override returns (bool) {\n        uint256 _currentRatio = getCurrentRatio(); // debt / collateral\n        uint256 _targetRatio = getTargetRatio(); // max debt ratio. over this number, we consider debt unhealthy\n        uint256 _issuanceRatio = getIssuanceRatio(); // preferred debt ratio by Synthetix (See protocol docs)\n\n        if (_currentRatio < _issuanceRatio) {\n            // strategy needs to take more debt\n            // only return true if the difference is greater than a threshold\n            return _issuanceRatio.sub(_currentRatio) >= ratioThreshold;\n        } else if (_currentRatio <= _targetRatio) {\n            // strategy is in optimal range (a bit undercollateralised)\n            return false;\n        } else if (_currentRatio > _targetRatio) {\n            // the strategy needs to repay debt to exit the danger zone\n            // only return true if the difference is greater than a threshold\n            return _currentRatio.sub(_targetRatio) >= ratioThreshold;\n        }\n\n        return false;\n    }\n\n    function protectedTokens()\n        internal\n        view\n        override\n        returns (address[] memory)\n    {}\n\n    // ********************** SUPPORT FUNCTIONS  **********************\n\n    function burnSusd(uint256 _amount) internal returns (bool) {\n        // returns false if unsuccessful\n        if (_issuer().canBurnSynths(address(this))) {\n            _synthetix().burnSynths(_amount);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function burnSusdToTarget() internal returns (uint256) {\n        // we use this method to be able to avoid the waiting period\n        // (see Synthetix Protocol)\n        // it burns enough Synths to get back to 500% c-ratio\n        // we need to have enough sUSD to burn to target\n        uint256 _debtBalance = balanceOfDebt();\n        // NOTE: amount of synths at 500% c-ratio (with current collateral)\n        uint256 _maxSynths = _synthetix().maxIssuableSynths(address(this));\n        if (_debtBalance <= _maxSynths) {\n            // we are over the 500% c-ratio (i.e. below 20% debt ratio), we don't need to burn sUSD\n            return 0;\n        }\n        uint256 _amountToBurn = _debtBalance.sub(_maxSynths);\n        uint256 _balance = balanceOfSusd();\n        if (_balance < _amountToBurn) {\n            // if we do not have enough in balance, we withdraw funds from sUSD vault\n            withdrawFromSUSDVault(_amountToBurn.sub(_balance));\n        }\n\n        if (_amountToBurn > 0) _synthetix().burnSynthsToTarget();\n        return _amountToBurn;\n    }\n\n    function withdrawFromSUSDVault(uint256 _amount) internal {\n        // Don't leave less than MIN_ISSUE sUSD in the vault\n        if (\n            _amount > balanceOfSusdInVault() ||\n            balanceOfSusdInVault().sub(_amount) <= MIN_ISSUE\n        ) {\n            susdVault.withdraw();\n        } else {\n            uint256 _sharesToWithdraw =\n                _amount.mul(1e18).div(susdVault.pricePerShare());\n            susdVault.withdraw(_sharesToWithdraw);\n        }\n    }\n\n    function buyWantWithSusd(uint256 _amount) internal {\n        if (_amount == 0) {\n            return;\n        }\n\n        address[] memory path = new address[](3);\n        path[0] = address(susd);\n        path[1] = address(WETH);\n        path[2] = address(want);\n\n        router.swapExactTokensForTokens(_amount, 0, path, address(this), now);\n    }\n\n    function buySusdWithWant(uint256 _amount) internal {\n        if (_amount == 0) {\n            return;\n        }\n\n        address[] memory path = new address[](3);\n        path[0] = address(want);\n        path[1] = address(WETH);\n        path[2] = address(susd);\n\n        // we use swapTokensForExactTokens because we need an exact sUSD amount\n        router.swapTokensForExactTokens(\n            _amount,\n            type(uint256).max,\n            path,\n            address(this),\n            now\n        );\n    }\n\n    // ********************** CALCS **********************\n\n    function estimatedProfit() public view returns (uint256) {\n        uint256 availableFees; // in sUSD\n\n        (availableFees, ) = _getFeesAvailable();\n\n        return sUSDToWant(availableFees);\n    }\n\n    function getTargetDebt(uint256 _targetCollateral)\n        internal\n        returns (uint256)\n    {\n        uint256 _targetRatio = getTargetRatio();\n        uint256 _collateralInSUSD = wantToSUSD(_targetCollateral);\n        return _targetRatio.mul(_collateralInSUSD).div(1e18);\n    }\n\n    function sUSDToWant(uint256 _amount) internal view returns (uint256) {\n        if (_amount == 0) {\n            return 0;\n        }\n\n        return _amount.mul(1e18).div(_exchangeRates().rateForCurrency(\"SNX\"));\n    }\n\n    function wantToSUSD(uint256 _amount) internal view returns (uint256) {\n        if (_amount == 0) {\n            return 0;\n        }\n\n        return _amount.mul(_exchangeRates().rateForCurrency(\"SNX\")).div(1e18);\n    }\n\n    function _getSusdForWant(uint256 _wantAmount)\n        internal\n        view\n        returns (uint256)\n    {\n        if (_wantAmount == 0) {\n            return 0;\n        }\n        address[] memory path = new address[](3);\n        path[0] = address(want);\n        path[1] = address(WETH);\n        path[2] = address(susd);\n\n        uint256[] memory amounts = router.getAmountsOut(_wantAmount, path);\n        return amounts[amounts.length - 1];\n    }\n\n    // ********************** BALANCES & RATIOS **********************\n    function _lockedCollateral() internal view returns (uint256) {\n        // collateral includes `want` balance (both locked and unlocked) AND escrowed balance\n        uint256 _collateral = _synthetix().collateral(address(this));\n\n        return _collateral.sub(_unlockedWant());\n    }\n\n    // amount of `want` (SNX) that can be transferred, sold, ...\n    function _unlockedWant() internal view returns (uint256) {\n        return _synthetix().transferableSynthetix(address(this));\n    }\n\n    function _unlockableWant() internal view returns (uint256) {\n        // collateral includes escrowed SNX, we may not be able to unlock the full\n        // we can only unlock this by repaying debt\n        return balanceOfWant().sub(_unlockedWant());\n    }\n\n    function _collateral() internal view returns (uint256) {\n        return _synthetix().collateral(address(this));\n    }\n\n    // returns fees and rewards\n    function _getFeesAvailable() internal view returns (uint256, uint256) {\n        // fees in sUSD\n        // rewards in `want` (SNX)\n        return _feePool().feesAvailable(address(this));\n    }\n\n    function getCurrentRatio() public view returns (uint256) {\n        // ratio = debt / collateral\n        // i.e. ratio is 0 if debt is 0\n        // NOTE: collateral includes SNX in account + escrowed balance\n        return _issuer().collateralisationRatio(address(this));\n    }\n\n    function getIssuanceRatio() public view returns (uint256) {\n        return _issuer().issuanceRatio();\n    }\n\n    function getTargetRatio() public view returns (uint256) {\n        return getIssuanceRatio().mul(targetRatioMultiplier).div(MAX_BPS);\n    }\n\n    function balanceOfEscrowedWant() public view returns (uint256) {\n        return _rewardEscrowV2().balanceOf(address(this));\n    }\n\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    function balanceOfSusd() public view returns (uint256) {\n        return IERC20(susd).balanceOf(address(this));\n    }\n\n    function balanceOfDebt() public view returns (uint256) {\n        return _synthetix().debtBalanceOf(address(this), \"sUSD\");\n    }\n\n    function balanceOfSusdInVault() public view returns (uint256) {\n        return\n            susdVault\n                .balanceOf(address(this))\n                .mul(susdVault.pricePerShare())\n                .div(1e18);\n    }\n\n    // ********************** ADDRESS RESOLVER SHORTCUTS **********************\n\n    function resolver() public view returns (IAddressResolver) {\n        return IAddressResolver(readProxy.target());\n    }\n\n    function _synthetix() internal view returns (ISynthetix) {\n        return ISynthetix(resolver().getAddress(CONTRACT_SYNTHETIX));\n    }\n\n    function _feePool() internal view returns (IFeePool) {\n        return IFeePool(resolver().getAddress(CONTRACT_FEEPOOL));\n    }\n\n    function _issuer() internal view returns (IIssuer) {\n        return IIssuer(resolver().getAddress(CONTRACT_ISSUER));\n    }\n\n    function _exchangeRates() internal view returns (IExchangeRates) {\n        return IExchangeRates(resolver().getAddress(CONTRACT_EXRATES));\n    }\n\n    function _rewardEscrowV2() internal view returns (IRewardEscrowV2) {\n        return IRewardEscrowV2(resolver().getAddress(CONTRACT_REWARDESCROW_V2));\n    }\n}"
    }
  ]
}