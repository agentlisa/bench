{
  "Title": "Rounding-up of user's `cRatio` causes loss for the protocol",
  "Content": "# Rounding-up of user's `cRatio` causes loss for the protocol\n\n### Severity\nHigh Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/libraries/LibShortRecord.sol#L34\">https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/libraries/LibShortRecord.sol#L34</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/facets/MarginCallPrimaryFacet.sol#L54\">https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/facets/MarginCallPrimaryFacet.sol#L54</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/facets/YieldFacet.sol#L108\">https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/facets/YieldFacet.sol#L108</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/facets/MarginCallSecondaryFacet.sol#L144\">https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/facets/MarginCallSecondaryFacet.sol#L144</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/facets/MarginCallSecondaryFacet.sol#L53-L54\">https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/facets/MarginCallSecondaryFacet.sol#L53-L54</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/facets/ShortRecordFacet.sol#L181-L182\">https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/facets/ShortRecordFacet.sol#L181-L182</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/libraries/LibOrders.sol#L847\">https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/libraries/LibOrders.sol#L847</a>\n\n\n## Summary\nAt multiple places in the code, user's collateral ratio has been calculated in a manner which causes loss of precision (rounding-up) due to **division before multiplication**. This causes potential loss for the DittoETH protocol, among other problems.\n\n## Root Cause\nUse of the following piece of code causes rounding-up:<br>\n- Style 1\n```js\nuint256 cRatio = short.getCollateralRatioSpotPrice(LibOracle.getSavedOrSpotOraclePrice(asset));\n```\n- Style 2\n```js\nuint256 oraclePrice = LibOracle.getOraclePrice(asset); // or uint256 oraclePrice = LibOracle.getSavedOrSpotOraclePrice(asset); // or uint256 oraclePrice = LibOracle.getPrice(asset);\n ...\n ...\n ...\nuint256 cRatio = short.getCollateralRatioSpotPrice(oraclePrice);\n```\n\n<br>\n\n## Vulnerability Details\nLet's break the issue down into 4 smaller parts:<br>\n### PART 1:\nLet us first look inside [getOraclePrice()](https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/libraries/LibOracle.sol#L20):\n```js\n  File: contracts/libraries/LibOracle.sol\n\n  20            function getOraclePrice(address asset) internal view returns (uint256) {\n  21                AppStorage storage s = appStorage();\n  22                AggregatorV3Interface baseOracle = AggregatorV3Interface(s.baseOracle);\n  23                uint256 protocolPrice = getPrice(asset);\n  24                // prettier-ignore\n  25                (\n  26                    uint80 baseRoundID,\n  27                    int256 basePrice,\n  28                    /*uint256 baseStartedAt*/\n  29                    ,\n  30                    uint256 baseTimeStamp,\n  31                    /*uint80 baseAnsweredInRound*/\n  32                ) = baseOracle.latestRoundData();\n  33\n  34                AggregatorV3Interface oracle = AggregatorV3Interface(s.asset[asset].oracle);\n  35                if (address(oracle) == address(0)) revert Errors.InvalidAsset();\n  36\n  37  @>            if (oracle == baseOracle) {\n  38                    //@dev multiply base oracle by 10**10 to give it 18 decimals of precision\n  39                    uint256 basePriceInEth = basePrice > 0\n  40  @>                    ? uint256(basePrice * Constants.BASE_ORACLE_DECIMALS).inv()\n  41                        : 0;\n  42                    basePriceInEth = baseOracleCircuitBreaker(\n  43                        protocolPrice, baseRoundID, basePrice, baseTimeStamp, basePriceInEth\n  44                    );\n  45  @>                return basePriceInEth;\n  46                } else {\n  47                    // prettier-ignore\n  48                    (\n  49                        uint80 roundID,\n  50                        int256 price,\n  51                        /*uint256 startedAt*/\n  52                        ,\n  53                        uint256 timeStamp,\n  54                        /*uint80 answeredInRound*/\n  55                    ) = oracle.latestRoundData();\n  56  @>                uint256 priceInEth = uint256(price).div(uint256(basePrice));\n  57                    oracleCircuitBreaker(\n  58                        roundID, baseRoundID, price, basePrice, timeStamp, baseTimeStamp\n  59                    );\n  60  @>                return priceInEth;\n  61                }\n  62            }\n```\nBased on whether the `oracle` is `baseOracle` or not, the function returns either `basePriceEth` or `priceInEth`.<br>\n- `basePriceEth` can be `uint256(basePrice * Constants.BASE_ORACLE_DECIMALS).inv()` which is basically `1e36 / (basePrice * Constants.BASE_ORACLE_DECIMALS)` or simply written, of the form `oracleN / oracleD` where `oracleN` is the numerator with value 1e36 (as defined [here](https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/libraries/PRBMathHelper.sol#L27)) and `oracleD` is the denominator.<br>\n- `priceInEth` is given as `uint256 priceInEth = uint256(price).div(uint256(basePrice))` which again is of the form `oracleN / oracleD`.\n\n<br>\n\n### PART 2:\n[getSavedOrSpotOraclePrice()](https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/libraries/LibOracle.sol#L153) too internally calls the above `getOraclePrice()` function, if it has been equal to or more than 15 minutes since the last time `LibOrders.getOffsetTime()` was set:\n```js\n  File: contracts/libraries/LibOracle.sol\n\n  153           function getSavedOrSpotOraclePrice(address asset) internal view returns (uint256) {\n  154               if (LibOrders.getOffsetTime() - getTime(asset) < 15 minutes) {\n  155                   return getPrice(asset);\n  156               } else {\n  157 @>                return getOraclePrice(asset);\n  158               }\n  159           }\n```\n<br>\n\n### PART 3:\n[getCollateralRatioSpotPrice()](https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/libraries/LibShortRecord.sol#L30) calculates `cRatio` as:\n```js\n  File: contracts/libraries/LibShortRecord.sol\n\n  30            function getCollateralRatioSpotPrice(\n  31                STypes.ShortRecord memory short,\n  32                uint256 oraclePrice\n  33            ) internal pure returns (uint256 cRatio) {\n  34  @>            return short.collateral.div(short.ercDebt.mul(oraclePrice));\n  35            }\n```\n<br>\n\n### PART 4 (FINAL PART):\nThere are multiple places in the code (mentioned below under ***Impacts*** section) which compare the user's `cRatio` to `initialCR` or `LibAsset.primaryLiquidationCR(_asset)` in the following manner:\n```js\nif (short.getCollateralRatioSpotPrice(LibOracle.getSavedOrSpotOraclePrice(asset)) < LibAsset.primaryLiquidationCR(asset))\n```\n<br>\n\nCalling `short.getCollateralRatioSpotPrice(LibOracle.getSavedOrSpotOraclePrice(asset))` means the value returned from it would be:\n```diff\n      // @audit-issue : Potential precision loss. Division before multiplication should not be done.\n      shortCollateral / (shortErcDebt * (oracleN / oracleD))           // return short.collateral.div(short.ercDebt.mul(oraclePrice));\n```\nwhich has the potential for precision loss (rounding-up) due to division before multiplication. The correct style ought to be:\n```diff\n+  @>    (shortCollateral * oracleD) / (shortErcDebt * oracleN)\n```\n<br>\n\n## Impacts\n- Impact #1: User gets more `dittoYieldShares` than expected due to [code logic](https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/facets/YieldFacet.sol#L108):\n```js\n  File: contracts/facets/YieldFacet.sol\n\n  76            function _distributeYield(address asset)\n  77                private\n  78                onlyValidAsset(asset)\n  79                returns (uint88 yield, uint256 dittoYieldShares)\n  80            {\n  81                uint256 vault = s.asset[asset].vault;\n  82                // Last updated zethYieldRate for this vault\n  83                uint80 zethYieldRate = s.vault[vault].zethYieldRate;\n  84                // Protocol time\n  85                uint256 timestamp = LibOrders.getOffsetTimeHours();\n  86                // Last saved oracle price\n  87  @>            uint256 oraclePrice = LibOracle.getPrice(asset);\n  88                // CR of shortRecord collateralized at initialMargin for this asset\n  89                uint256 initialCR = LibAsset.initialMargin(asset) + 1 ether;\n  90                // Retrieve first non-HEAD short\n  91                uint8 id = s.shortRecords[asset][msg.sender][Constants.HEAD].nextId;\n  92                // Loop through all shorter's shorts of this asset\n  93                while (true) {\n  94                    // One short of one shorter in this market\n  95                    STypes.ShortRecord storage short = s.shortRecords[asset][msg.sender][id];\n  96                    // To prevent flash loans or loans where they want to deposit to claim yield immediately\n  97                    bool isNotRecentlyModified =\n  98                        timestamp - short.updatedAt > Constants.YIELD_DELAY_HOURS;\n  99                    // Check for cancelled short\n  100                   if (short.status != SR.Cancelled && isNotRecentlyModified) {\n  101                       uint88 shortYield =\n  102                           short.collateral.mulU88(zethYieldRate - short.zethYieldRate);\n  103                       // Yield earned by this short\n  104                       yield += shortYield;\n  105                       // Update zethYieldRate for this short\n  106                       short.zethYieldRate = zethYieldRate;\n  107                       // Calculate CR to modify ditto rewards\n  108 @>                    uint256 cRatio = short.getCollateralRatioSpotPrice(oraclePrice);\n  109 @>                    if (cRatio <= initialCR) {\n  110 @>                        dittoYieldShares += shortYield;\n  111                       } else {\n  112                           // Reduce amount of yield credited for ditto rewards proportional to CR\n  113                           dittoYieldShares += shortYield.mul(initialCR).div(cRatio);\n  114                       }\n  115                   }\n  116                   // Move to next short unless this is the last one\n  117                   if (short.nextId > Constants.HEAD) {\n  118                       id = short.nextId;\n  119                   } else {\n  120                       break;\n  121                   }\n  122               }\n  123           }\n```\nThis rounding-up can lead to user's `cRatio` to be considered as `>initialCR` even when it's slightly lower. This results in greater `dittoYieldShares` being calculated.\n<br>\n\n- Impact #2: [Short can escape being flagged](https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/facets/MarginCallPrimaryFacet.sol#L54-L55) by a Flagger even when actual cRatio is slightly less than `primaryLiquidationCR`:\n```js\n  File: contracts/facets/MarginCallPrimaryFacet.sol\n\n  43            function flagShort(address asset, address shorter, uint8 id, uint16 flaggerHint)\n  44                external\n  45                isNotFrozen(asset)\n  46                nonReentrant\n  47                onlyValidShortRecord(asset, shorter, id)\n  48            {\n  49                if (msg.sender == shorter) revert Errors.CannotFlagSelf();\n  50                STypes.ShortRecord storage short = s.shortRecords[asset][shorter][id];\n  51                short.updateErcDebt(asset);\n  52\n  53                if (\n  54  @>                short.getCollateralRatioSpotPrice(LibOracle.getSavedOrSpotOraclePrice(asset))\n  55  @>                    >= LibAsset.primaryLiquidationCR(asset)      // @audit-issue : this will evaluate to `true` due to rounding-up and the short will not be eligible for flagging\n  56                ) {\n  57                    revert Errors.SufficientCollateral();\n  58                }\n  59\n  60                uint256 adjustedTimestamp = LibOrders.getOffsetTimeHours();\n  61\n  62                // check if already flagged\n  63                if (short.flaggerId != 0) {\n  64                    uint256 timeDiff = adjustedTimestamp - short.updatedAt;\n  65                    uint256 resetLiquidationTime = LibAsset.resetLiquidationTime(asset);\n  66\n  67                    if (timeDiff <= resetLiquidationTime) {\n  68                        revert Errors.MarginCallAlreadyFlagged();\n  69                    }\n  70                }\n  71\n  72                short.setFlagger(cusd, flaggerHint);\n  73                emit Events.FlagShort(asset, shorter, id, msg.sender, adjustedTimestamp);\n  74            }\n```\n<br>\n\n- Impact #3: `m.cRatio` of a `MTypes.MarginCallSecondary m` is [set after incorrect rounding-up](https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/facets/MarginCallSecondaryFacet.sol#L144). Note that this happens when someone calls [liquidateSecondary()](https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/facets/MarginCallSecondaryFacet.sol#L53-L54)\n```js\n  File: contracts/facets/MarginCallSecondaryFacet.sol\n\n  38            function liquidateSecondary(\n  39                address asset,\n  40                MTypes.BatchMC[] memory batches,\n  41                uint88 liquidateAmount,\n  42                bool isWallet\n  43            ) external onlyValidAsset(asset) isNotFrozen(asset) nonReentrant {\n  44                STypes.AssetUser storage AssetUser = s.assetUser[asset][msg.sender];\n  45                MTypes.MarginCallSecondary memory m;\n  46                uint256 minimumCR = LibAsset.minimumCR(asset);\n  47                uint256 oraclePrice = LibOracle.getSavedOrSpotOraclePrice(asset);\n  48                uint256 secondaryLiquidationCR = LibAsset.secondaryLiquidationCR(asset);\n  49\n  50                uint88 liquidatorCollateral;\n  51                uint88 liquidateAmountLeft = liquidateAmount;\n  52                for (uint256 i; i < batches.length;) {\n  53  @>                m = _setMarginCallStruct(\n  54                        asset, batches[i].shorter, batches[i].shortId, minimumCR, oraclePrice\n  55                    );\n  56\n\n                ......\n                ......\n                ......\n\n\n  129           function _setMarginCallStruct(\n  130               address asset,\n  131               address shorter,\n  132               uint8 id,\n  133               uint256 minimumCR,\n  134               uint256 oraclePrice\n  135           ) private returns (MTypes.MarginCallSecondary memory) {\n  136               LibShortRecord.updateErcDebt(asset, shorter, id);\n  137\n  138               MTypes.MarginCallSecondary memory m;\n  139               m.asset = asset;\n  140               m.short = s.shortRecords[asset][shorter][id];\n  141               m.vault = s.asset[asset].vault;\n  142               m.shorter = shorter;\n  143               m.minimumCR = minimumCR;\n  144 @>            m.cRatio = m.short.getCollateralRatioSpotPrice(oraclePrice);\n  145               return m;\n  146           }\n\n```\n<br>\n\n- Impact #4: While combining shorts, say `short1` and `short2`, if short2 was flagged by a flagger, then the protocol checks if [the combined new short has a cRatio above primaryLiquidationCR or not](https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/facets/ShortRecordFacet.sol#L178-L186). The rounding-up allows the shorter to combine shorts even if he is just below the required c-ratio.\n```js\n  File: contracts/facets/ShortRecordFacet.sol\n\n  117           function combineShorts(address asset, uint8[] memory ids)\n  118               external\n  119               isNotFrozen(asset)\n  120               nonReentrant\n  121               onlyValidShortRecord(asset, msg.sender, ids[0])\n  122           {\n  123               if (ids.length < 2) revert Errors.InsufficientNumberOfShorts();\n  124               // First short in the array\n  125               STypes.ShortRecord storage firstShort = s.shortRecords[asset][msg.sender][ids[0]];\n  \n                ......\n                ......\n                ......\n\n  174\n  175               // Merge all short records into the short at position id[0]\n  176               firstShort.merge(ercDebt, ercDebtSocialized, collateral, yield, c.shortUpdatedAt);\n  177\n  178               // If at least one short was flagged, ensure resulting c-ratio > primaryLiquidationCR\n  179               if (c.shortFlagExists) {\n  180                   if (\n  181 @>                    firstShort.getCollateralRatioSpotPrice(\n  182 @>                        LibOracle.getSavedOrSpotOraclePrice(_asset)\n  183 @>                    ) < LibAsset.primaryLiquidationCR(_asset)\n  184                   ) revert Errors.InsufficientCollateral();\n  185                   // Resulting combined short has sufficient c-ratio to remove flag\n  186                   firstShort.resetFlag();\n  187               }\n  188               emit Events.CombineShorts(asset, msg.sender, ids);\n  189           }\n```\n\n<br>\n\n***NOTE:*** \n<br>\nWhile the operation done in [this piece of code](https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/libraries/LibOrders.sol#L847) is a bit different from the above analysis, I am clubbing it with this bug report as the underlying issue is the same (and the resolution would be similar): _Multiplication and division operations should not be done directly on top of fetched oracle price, without paying attention to new order of evaluation:_\n\n```js\n  File: contracts/libraries/LibOrders.sol\n\n  812           function _updateOracleAndStartingShort(address asset, uint16[] memory shortHintArray)\n  813               private\n  814           {\n  815               AppStorage storage s = appStorage();\n  815               uint256 oraclePrice = LibOracle.getOraclePrice(asset);\n  \n                ......\n                ......\n                ......\n\n  845                       //@dev: force hint to be within 1% of oracleprice\n  846                       bool startingShortWithinOracleRange = shortPrice\n  847 @>                        <= oraclePrice.mul(1.01 ether)                     // @audit-issue : division before multiplication\n  848                           && s.shorts[asset][prevId].price >= oraclePrice;\n  \n                ......\n                ......\n                ......\n\n  866           }\n```\n\n<br>\n\nThe effective calculation being done above is:\n\n```js\n    (oracleN / oracleD) * (1.01 ether)        // division before multiplication\n```\n<br>\n\nWhich should have been:\n\n```js\n    (oracleN * 1.01 ether) / oracle\n```\n<br>\n\nSimilar multiplication or division operations have been done on `price` at various places throughout the code, which can be clubbed under this root cause itself.\n<br>\n\n## PoC\n\n_Have attempted to keep all values in close proximity to the ones present in forked mainnet tests._<br><br>\n\nLet's assume some values for numerator & denominator and other variables:\n```js\n    uint256 private short_collateral = 100361729669569000000; // ~ 100 ether\n    uint256 private short_ercDebt = 100000000000000000000000; // 100_000 ether\n    uint256 private price = 99995505; // oracleN\n    uint256 private basePrice = 199270190598; // oracleD\n    uint256 private primaryLiquidationCR = 2000000000000000000; // 2 ether (as on forked mainnet)\n\n// For this example, we assume that oracle != baseOracle, so that the below calculation would be done by the protocol\nSo calculated priceInEth = price.div(basePrice) = 501808648347845  // ~ 0.0005 ether\n```\n<br>\n\nLet's calculate for the scenario of `flagShort()` where the [code logic](https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/facets/MarginCallPrimaryFacet.sol#L54-L55) says:\n```js\n  53                if (\n  54  @>                short.getCollateralRatioSpotPrice(LibOracle.getSavedOrSpotOraclePrice(asset))\n  55  @>                    >= LibAsset.primaryLiquidationCR(asset)      // @audit-issue : this will evaluate to `true`, then revert, due to rounding-up and the short will incorrectly escape flagging\n  56                ) {\n  57                    revert Errors.SufficientCollateral();\n  58                }\n```\n<br>\n\nCreate a file named `test/IncorrectCRatioCheck.t.sol` and paste the following code in it. Some mock functions are included here which mirror protocol's calculation style:\n```js\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256} from \"contracts/libraries/PRBMathHelper.sol\";\nimport {OBFixture} from \"test/utils/OBFixture.sol\";\nimport {console} from \"contracts/libraries/console.sol\";\n\ncontract IncorrectCRatioCheck is OBFixture {\n    using U256 for uint256;\n\n    uint256 private short_collateral = 85307470219133700000; // ~ 85.3 ether\n    uint256 private short_ercDebt = 100000000000000000000000; // 100_000 ether\n    uint256 private price = 99995505; // oracleN\n    uint256 private basePrice = 199270190598; // (as on forked mainnet)  // oracleD\n    uint256 private primaryLiquidationCR = 1700000000000000000; // 1.7 ether (as on forked mainnet)\n\n    function _getSavedOrSpotOraclePrice() internal view returns (uint256) {\n        uint256 priceInEth = price.div(basePrice);\n        return priceInEth; // will return 501808648347845 =~ 0.0005 ether  // (as on forked mainnet)\n    }\n\n    function getCollateralRatioSpotPrice_IncorrectStyle_As_In_Existing_DittoProtocol(\n        uint256 oraclePrice\n    ) internal view returns (uint256) {\n        return short_collateral.div(short_ercDebt.mul(oraclePrice));\n    }\n\n    function getCollateralRatioSpotPrice_CorrectStyle(uint256 oracleN, uint256 oracleD)\n        internal\n        view\n        returns (uint256)\n    {\n        return (short_collateral.mul(oracleD)).div(short_ercDebt.mul(oracleN));\n    }\n\n    /* solhint-disable no-console */\n    function test_GetCollateralRatioSpotPrice_IncorrectStyle_As_In_Existing_DittoProtocol(\n    ) public view {\n        uint256 cRatio =\n        getCollateralRatioSpotPrice_IncorrectStyle_As_In_Existing_DittoProtocol(\n            _getSavedOrSpotOraclePrice()\n        );\n        console.log(\"cRatio calculated (existing style) =\", cRatio);\n        if (cRatio >= primaryLiquidationCR) {\n            console.log(\"Errors.SufficientCollateral; can not be flagged\");\n        } else {\n            console.log(\"InsufficientCollateral; can be flagged\");\n        }\n    }\n\n    /* solhint-disable no-console */\n    function test_GetCollateralRatioSpotPrice_CorrectStyle() public view {\n        uint256 cRatio = getCollateralRatioSpotPrice_CorrectStyle(price, basePrice);\n        console.log(\"cRatio calculated (correct style) =\", cRatio);\n        if (cRatio >= primaryLiquidationCR) {\n            console.log(\"Errors.SufficientCollateral; can not be flagged\");\n        } else {\n            console.log(\"InsufficientCollateral; can be flagged\");\n        }\n    }\n}\n``` \n<br>\n\n- First, let's see the output as per protocol's calculation. Run `forge test --mt test_GetCollateralRatioSpotPrice_IncorrectStyle_As_In_Existing_DittoProtocol -vv`:\n```js\nLogs:\n  cRatio calculated (existing style) = 1700000000000000996\n  Errors.SufficientCollateral; can not be flagged\n```\nSo the short can not be flagged as `cRatio > primaryLiquidationCR` of 1700000000000000000.\n<br>\n<br>\n\n- Now, let's see the output as per the correct calculation. Run `forge test --mt test_GetCollateralRatioSpotPrice_CorrectStyle -vv`:\n```js\nLogs:\n  cRatio calculated (correct style) = 1699999999999899995\n  InsufficientCollateral; can be flagged\n```\nShort's cRatio is actually below primaryLiquidationCR. Should have been flagged ideally.\n\n<br>\n\n## Tools Used\nManual review, forge test.\n\n## Recommendations\nThese steps need to be taken to fix the issue. Developer may have to make some additional changes since `.mul`, `.div`, etc are being used from the `PRBMathHelper.sol` library. Following is the general workflow required:<br>\n- Create additional functions to fetch oracle parameters instead of price: Create copies of `getOraclePrice()` and `getSavedOrSpotOraclePrice()`, but these ones return `oracleN` & `oracleD` instead of the calculated price. Let's assume the new names to be `getOraclePriceParams()` and `getSavedOrSpotOraclePriceParams()`.\n- Create a new function to calculate cRatio which will be used in place of the above occurences of `getCollateralRatioSpotPrice()`: \n```js\n    function getCollateralRatioSpotPriceFromOracleParams(\n        STypes.ShortRecord memory short,\n        uint256 oracleN,\n        uint256 oracleD\n    ) internal pure returns (uint256 cRatio) {\n        return (short.collateral.mul(oracleD)).div(short.ercDebt.mul(oracleN));\n    }\n```\n\n<br>\n\n- For fixing the last issue of `oraclePrice.mul(1.01 ether)` on [L847](https://github.com/Cyfrin/2023-09-ditto/blob/main/contracts/libraries/LibOrders.sol#L847), first call `getOraclePriceParams()` to get `oracleN` & `oracleD` and then:\n```diff\n  845                       //@dev: force hint to be within 1% of oracleprice\n  846                       bool startingShortWithinOracleRange = shortPrice\n- 847                           <= oraclePrice.mul(1.01 ether)\n+ 847                           <= (oracleN.mul(1.01 ether)).div(oracleD)\n  848                           && s.shorts[asset][prevId].price >= oraclePrice;\n``` \n",
  "Impact": "MEDIUM",
  "Source": "https://www.codehawks.com/contests/clm871gl00001mp081mzjdlwc",
  "Code": [
    {
      "filename": "contracts/libraries/LibShortRecord.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, U88, U80} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {STypes, SR} from \"contracts/libraries/DataTypes.sol\";\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {AppStorage, appStorage} from \"contracts/libraries/AppStorage.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\nimport {LibAsset} from \"contracts/libraries/LibAsset.sol\";\nimport {LibOrders} from \"contracts/libraries/LibOrders.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\nlibrary LibShortRecord {\n    using U256 for uint256;\n    using U88 for uint88;\n    using U80 for uint80;\n\n    function getCollateralRatio(STypes.ShortRecord memory short, address asset)\n        internal\n        view\n        returns (uint256 cRatio)\n    {\n        return short.collateral.div(short.ercDebt.mul(LibOracle.getPrice(asset)));\n    }\n\n    function getCollateralRatioSpotPrice(\n        STypes.ShortRecord memory short,\n        uint256 oraclePrice\n    ) internal pure returns (uint256 cRatio) {\n        return short.collateral.div(short.ercDebt.mul(oraclePrice));\n    }\n\n    /**\n     * @notice Returns number of active shortRecords\n     *\n     * @param asset The market that will be impacted\n     * @param shorter Shorter address\n     *\n     * @return shortRecordCount\n     */\n    function getShortRecordCount(address asset, address shorter)\n        internal\n        view\n        returns (uint256 shortRecordCount)\n    {\n        AppStorage storage s = appStorage();\n\n        // Retrieve first non-HEAD short\n        uint8 id = s.shortRecords[asset][shorter][Constants.HEAD].nextId;\n        if (id <= Constants.HEAD) {\n            return 0;\n        }\n\n        while (true) {\n            shortRecordCount++;\n            // One short of one shorter in this order book\n            STypes.ShortRecord storage currentShort = s.shortRecords[asset][shorter][id];\n            // Move to next short unless this is the last one\n            if (currentShort.nextId > Constants.HEAD) {\n                id = currentShort.nextId;\n            } else {\n                return shortRecordCount;\n            }\n        }\n    }\n\n    function createShortRecord(\n        address asset,\n        address shorter,\n        SR status,\n        uint88 collateral,\n        uint88 ercAmount,\n        uint64 ercDebtRate,\n        uint80 zethYieldRate,\n        uint40 tokenId\n    ) internal returns (uint8 id) {\n        AppStorage storage s = appStorage();\n\n        // ensure the tokenId can be downcasted to 40 bits\n        if (tokenId > type(uint40).max) revert Errors.InvalidTokenId();\n\n        uint8 nextId;\n        (id, nextId) = setShortRecordIds(asset, shorter);\n\n        if (id <= Constants.SHORT_MAX_ID) {\n            s.shortRecords[asset][shorter][id] = STypes.ShortRecord({\n                prevId: Constants.HEAD,\n                id: id,\n                nextId: nextId,\n                status: status,\n                collateral: collateral,\n                ercDebt: ercAmount,\n                ercDebtRate: ercDebtRate,\n                zethYieldRate: zethYieldRate,\n                flaggerId: 0,\n                tokenId: tokenId,\n                updatedAt: LibOrders.getOffsetTimeHours()\n            });\n            emit Events.CreateShortRecord(asset, shorter, id);\n        } else {\n            // All shortRecordIds used, combine into max shortRecordId\n            id = Constants.SHORT_MAX_ID;\n            fillShortRecord(\n                asset,\n                shorter,\n                id,\n                status,\n                collateral,\n                ercAmount,\n                ercDebtRate,\n                zethYieldRate\n            );\n        }\n    }\n\n    function transferShortRecord(\n        address asset,\n        address from,\n        address to,\n        uint40 tokenId,\n        STypes.NFT memory nft\n    ) internal {\n        AppStorage storage s = appStorage();\n        STypes.ShortRecord storage short = s.shortRecords[asset][from][nft.shortRecordId];\n        if (short.status == SR.Cancelled) revert Errors.OriginalShortRecordCancelled();\n        if (short.flaggerId != 0) revert Errors.CannotTransferFlaggedShort();\n\n        deleteShortRecord(asset, from, nft.shortRecordId);\n\n        uint8 id = createShortRecord(\n            asset,\n            to,\n            SR.FullyFilled,\n            short.collateral,\n            short.ercDebt,\n            short.ercDebtRate,\n            short.zethYieldRate,\n            tokenId\n        );\n\n        if (id == Constants.SHORT_MAX_ID) {\n            revert Errors.ReceiverExceededShortRecordLimit();\n        }\n\n        s.nftMapping[tokenId].owner = to;\n        s.nftMapping[tokenId].shortRecordId = id;\n    }\n\n    function fillShortRecord(\n        address asset,\n        address shorter,\n        uint8 shortId,\n        SR status,\n        uint88 collateral,\n        uint88 ercAmount,\n        uint256 ercDebtRate,\n        uint256 zethYieldRate\n    ) internal {\n        AppStorage storage s = appStorage();\n\n        uint256 ercDebtSocialized = ercAmount.mul(ercDebtRate);\n        uint256 yield = collateral.mul(zethYieldRate);\n\n        STypes.ShortRecord storage short = s.shortRecords[asset][shorter][shortId];\n        if (short.status == SR.Cancelled) {\n            short.ercDebt = short.collateral = 0;\n        }\n\n        short.status = status;\n        LibShortRecord.merge(\n            short,\n            ercAmount,\n            ercDebtSocialized,\n            collateral,\n            yield,\n            LibOrders.getOffsetTimeHours()\n        );\n    }\n\n    function deleteShortRecord(address asset, address shorter, uint8 id) internal {\n        AppStorage storage s = appStorage();\n\n        STypes.ShortRecord storage shortRecord = s.shortRecords[asset][shorter][id];\n        // Because of the onlyValidShortRecord modifier, only cancelShort can pass SR.Cancelled\n        // Don't recycle shortRecord id 254 so it can be used for all overflow uint8 ids\n        if (shortRecord.status != SR.PartialFill && id < Constants.SHORT_MAX_ID) {\n            // remove the links of ID in the market\n            // @dev (ID) is exiting, [ID] is inserted\n            // BEFORE: PREV <-> (ID) <-> NEXT\n            // AFTER : PREV <----------> NEXT\n            s.shortRecords[asset][shorter][shortRecord.prevId].nextId = shortRecord.nextId;\n            if (shortRecord.nextId != Constants.HEAD) {\n                s.shortRecords[asset][shorter][shortRecord.nextId].prevId =\n                    shortRecord.prevId;\n            }\n            // Make reuseable for future short records\n            uint8 prevHEAD = s.shortRecords[asset][shorter][Constants.HEAD].prevId;\n            s.shortRecords[asset][shorter][Constants.HEAD].prevId = id;\n            // Move the cancelled ID behind HEAD to re-use it\n            // note: C_IDs (cancelled ids) only need to point back (set prevId, can retain nextId)\n            // BEFORE: .. C_ID2 <- C_ID1 <--------- HEAD <-> ... [ID]\n            // AFTER1: .. C_ID2 <- C_ID1 <- [ID] <- HEAD <-> ...\n            if (prevHEAD > Constants.HEAD) {\n                shortRecord.prevId = prevHEAD;\n            } else {\n                // if this is the first ID cancelled\n                // HEAD.prevId needs to be HEAD\n                // and one of the cancelled id.prevID should point to HEAD\n                // BEFORE: HEAD <--------- HEAD <-> ... [ID]\n                // AFTER1: HEAD <- [ID] <- HEAD <-> ...\n                shortRecord.prevId = Constants.HEAD;\n            }\n\n            //Event for delete SR is emitted here and not at the top level because\n            //SR may be cancelled, but there might tied to an active short order\n            //The code above is hit when that SR id is ready for reuse\n            emit Events.DeleteShortRecord(asset, shorter, id);\n        }\n\n        shortRecord.status = SR.Cancelled;\n    }\n\n    function setShortRecordIds(address asset, address shorter)\n        private\n        returns (uint8 id, uint8 nextId)\n    {\n        AppStorage storage s = appStorage();\n\n        STypes.ShortRecord storage guard = s.shortRecords[asset][shorter][Constants.HEAD];\n        STypes.AssetUser storage AssetUser = s.assetUser[asset][shorter];\n        // Initialize HEAD in case of first short createShortRecord\n        if (AssetUser.shortRecordId == 0) {\n            AssetUser.shortRecordId = Constants.SHORT_STARTING_ID;\n            guard.prevId = Constants.HEAD;\n            guard.nextId = Constants.HEAD;\n        }\n        // BEFORE: HEAD <-> .. <-> PREV <--------------> NEXT\n        // AFTER1: HEAD <-> .. <-> PREV <-> (NEW ID) <-> NEXT\n        // place created short next to HEAD\n        nextId = guard.nextId;\n        uint8 canceledId = guard.prevId;\n        // @dev (ID) is exiting, [ID] is inserted\n        // in this case, the protocol re-uses (ID) and moves it to [ID]\n        // check if a previously closed short exists\n        if (canceledId > Constants.HEAD) {\n            // BEFORE: CancelledID <- (ID) <- HEAD <-> .. <-> PREV <----------> NEXT\n            // AFTER1: CancelledID <--------- HEAD <-> .. <-> PREV <-> [ID] <-> NEXT\n            uint8 prevCanceledId = s.shortRecords[asset][shorter][canceledId].prevId;\n            if (prevCanceledId > Constants.HEAD) {\n                guard.prevId = prevCanceledId;\n            } else {\n                // BEFORE: HEAD <- (ID) <- HEAD <-> .. <-> PREV <----------> NEXT\n                // AFTER1: HEAD <--------- HEAD <-> .. <-> PREV <-> [ID] <-> NEXT\n                guard.prevId = Constants.HEAD;\n            }\n            // re-use the previous order's id\n            id = canceledId;\n        } else {\n            // BEFORE: HEAD <-> .. <-> PREV <--------------> NEXT\n            // AFTER1: HEAD <-> .. <-> PREV <-> (NEW ID) <-> NEXT\n            // otherwise just increment to a new short record id\n            // and the short record grows in height/size\n            id = AssetUser.shortRecordId;\n            // Avoids overflow revert, prevents DOS on uint8\n            if (id < type(uint8).max) {\n                AssetUser.shortRecordId += 1;\n            } else {\n                // If max id reached, match into max shortRecordId\n                return (id, nextId);\n            }\n        }\n\n        if (nextId > Constants.HEAD) {\n            s.shortRecords[asset][shorter][nextId].prevId = id;\n        }\n        guard.nextId = id;\n    }\n\n    function updateErcDebt(address asset, address shorter, uint8 shortId) internal {\n        AppStorage storage s = appStorage();\n\n        STypes.ShortRecord storage short = s.shortRecords[asset][shorter][shortId];\n\n        // Distribute ercDebt\n        uint64 ercDebtRate = s.asset[asset].ercDebtRate;\n        uint88 ercDebt = short.ercDebt.mulU88(ercDebtRate - short.ercDebtRate);\n\n        if (ercDebt > 0) {\n            short.ercDebt += ercDebt;\n            short.ercDebtRate = ercDebtRate;\n        }\n    }\n\n    function updateErcDebt(STypes.ShortRecord storage short, address asset) internal {\n        AppStorage storage s = appStorage();\n\n        // Distribute ercDebt\n        uint64 ercDebtRate = s.asset[asset].ercDebtRate;\n        uint88 ercDebt = short.ercDebt.mulU88(ercDebtRate - short.ercDebtRate);\n\n        if (ercDebt > 0) {\n            short.ercDebt += ercDebt;\n            short.ercDebtRate = ercDebtRate;\n        }\n    }\n\n    function merge(\n        STypes.ShortRecord storage short,\n        uint88 ercDebt,\n        uint256 ercDebtSocialized,\n        uint88 collateral,\n        uint256 yield,\n        uint24 creationTime\n    ) internal {\n        // Resolve ercDebt\n        ercDebtSocialized += short.ercDebt.mul(short.ercDebtRate);\n        short.ercDebt += ercDebt;\n        short.ercDebtRate = ercDebtSocialized.divU64(short.ercDebt);\n        // Resolve zethCollateral\n        yield += short.collateral.mul(short.zethYieldRate);\n        short.collateral += collateral;\n        short.zethYieldRate = yield.divU80(short.collateral);\n        // Assign updatedAt\n        short.updatedAt = creationTime;\n    }\n\n    function disburseCollateral(\n        address asset,\n        address shorter,\n        uint88 collateral,\n        uint256 zethYieldRate,\n        uint24 updatedAt\n    ) internal {\n        AppStorage storage s = appStorage();\n\n        STypes.Asset storage Asset = s.asset[asset];\n        uint256 vault = Asset.vault;\n        STypes.Vault storage Vault = s.vault[vault];\n\n        Vault.zethCollateral -= collateral;\n        Asset.zethCollateral -= collateral;\n        // Distribute yield\n        uint88 yield = collateral.mulU88(Vault.zethYieldRate - zethYieldRate);\n        if (yield > 0) {\n            /*\n            @dev If somebody exits a short, gets margin called, decreases their collateral before YIELD_DELAY_HOURS duration is up,\n            they lose their yield to the TAPP\n            */\n            bool isNotRecentlyModified =\n                LibOrders.getOffsetTimeHours() - updatedAt > Constants.YIELD_DELAY_HOURS;\n            if (isNotRecentlyModified) {\n                s.vaultUser[vault][shorter].ethEscrowed += yield;\n            } else {\n                s.vaultUser[vault][address(this)].ethEscrowed += yield;\n            }\n        }\n    }\n\n    function burnNFT(uint256 tokenId) internal {\n        //@dev No need to check downcast tokenId because it is handled in function that calls burnNFT\n        AppStorage storage s = appStorage();\n        STypes.NFT storage nft = s.nftMapping[tokenId];\n        if (nft.owner == address(0)) revert Errors.NotMinted();\n        address asset = s.assetMapping[nft.assetId];\n        STypes.ShortRecord storage short =\n            s.shortRecords[asset][nft.owner][nft.shortRecordId];\n        delete s.nftMapping[tokenId];\n        delete s.getApproved[tokenId];\n        delete short.tokenId;\n        emit Events.Transfer(nft.owner, address(0), tokenId);\n    }\n\n    function setFlagger(\n        STypes.ShortRecord storage short,\n        address cusd,\n        uint16 flaggerHint\n    ) internal {\n        AppStorage storage s = appStorage();\n        STypes.AssetUser storage flagStorage = s.assetUser[cusd][msg.sender];\n\n        //@dev Whenever a new flagger flags, use the flaggerIdCounter.\n        if (flagStorage.g_flaggerId == 0) {\n            address flaggerToReplace = s.flagMapping[flaggerHint];\n\n            uint256 timeDiff = flaggerToReplace != address(0)\n                ? LibOrders.getOffsetTimeHours()\n                    - s.assetUser[cusd][flaggerToReplace].g_updatedAt\n                : 0;\n            //@dev re-use an inactive flaggerId\n            if (timeDiff > LibAsset.firstLiquidationTime(cusd)) {\n                delete s.assetUser[cusd][flaggerToReplace].g_flaggerId;\n                short.flaggerId = flagStorage.g_flaggerId = flaggerHint;\n            } else if (s.flaggerIdCounter < type(uint16).max) {\n                //@dev generate brand new flaggerId\n                short.flaggerId = flagStorage.g_flaggerId = s.flaggerIdCounter;\n                s.flaggerIdCounter++;\n            } else {\n                revert Errors.InvalidFlaggerHint();\n            }\n            s.flagMapping[short.flaggerId] = msg.sender;\n        } else {\n            //@dev re-use flaggerId if flagger has an existing one\n            short.flaggerId = flagStorage.g_flaggerId;\n        }\n        short.updatedAt = flagStorage.g_updatedAt = LibOrders.getOffsetTimeHours();\n    }\n\n    //@dev reset flag info if new cratio is above primaryLiquidationCR\n    function maybeResetFlag(STypes.ShortRecord storage short, address asset) internal {\n        if (short.flaggerId != 0) {\n            if (\n                LibShortRecord.getCollateralRatio(short, asset)\n                    >= LibAsset.primaryLiquidationCR(asset)\n            ) {\n                LibShortRecord.resetFlag(short);\n            }\n        }\n    }\n\n    function resetFlag(STypes.ShortRecord storage shortRecord) internal {\n        delete shortRecord.flaggerId;\n        shortRecord.updatedAt = LibOrders.getOffsetTimeHours();\n    }\n}"
    },
    {
      "filename": "contracts/facets/MarginCallPrimaryFacet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {U256, U96, U88, U80} from \"contracts/libraries/PRBMathHelper.sol\";\n\nimport {IDiamond} from \"interfaces/IDiamond.sol\";\n\nimport {Errors} from \"contracts/libraries/Errors.sol\";\nimport {Events} from \"contracts/libraries/Events.sol\";\nimport {STypes, MTypes, SR, OF} from \"contracts/libraries/DataTypes.sol\";\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {LibAsset} from \"contracts/libraries/LibAsset.sol\";\nimport {LibOrders} from \"contracts/libraries/LibOrders.sol\";\nimport {LibOracle} from \"contracts/libraries/LibOracle.sol\";\nimport {LibShortRecord} from \"contracts/libraries/LibShortRecord.sol\";\nimport {Constants} from \"contracts/libraries/Constants.sol\";\n\n// import {console} from \"contracts/libraries/console.sol\";\n\ncontract MarginCallPrimaryFacet is Modifiers {\n    using LibShortRecord for STypes.ShortRecord;\n    using U256 for uint256;\n    using U96 for uint96;\n    using U88 for uint88;\n    using U80 for uint80;\n\n    address private immutable cusd;\n\n    constructor(address _cusd) {\n        cusd = _cusd;\n    }\n\n    /**\n     * @notice Flags short under primaryLiquidationCR to be eligible for liquidation after time has passed\n     * @dev Used to flag for primary liquidation method\n     *\n     * @param asset The market that will be impacted\n     * @param shorter Shorter getting liquidated\n     * @param id id of short getting liquidated\n     * @param flaggerHint Hint ID for gas-optimized update of short flagger\n     *\n     */\n    function flagShort(address asset, address shorter, uint8 id, uint16 flaggerHint)\n        external\n        isNotFrozen(asset)\n        nonReentrant\n        onlyValidShortRecord(asset, shorter, id)\n    {\n        if (msg.sender == shorter) revert Errors.CannotFlagSelf();\n        STypes.ShortRecord storage short = s.shortRecords[asset][shorter][id];\n        short.updateErcDebt(asset);\n\n        if (\n            short.getCollateralRatioSpotPrice(LibOracle.getSavedOrSpotOraclePrice(asset))\n                >= LibAsset.primaryLiquidationCR(asset)\n        ) {\n            revert Errors.SufficientCollateral();\n        }\n\n        uint256 adjustedTimestamp = LibOrders.getOffsetTimeHours();\n\n        // check if already flagged\n        if (short.flaggerId != 0) {\n            uint256 timeDiff = adjustedTimestamp - short.updatedAt;\n            uint256 resetLiquidationTime = LibAsset.resetLiquidationTime(asset);\n\n            if (timeDiff <= resetLiquidationTime) {\n                revert Errors.MarginCallAlreadyFlagged();\n            }\n        }\n\n        short.setFlagger(cusd, flaggerHint);\n        emit Events.FlagShort(asset, shorter, id, msg.sender, adjustedTimestamp);\n    }\n\n    /**\n     * @notice Liquidates short by forcing shorter to place bid on market\n     * @dev Primary liquidation method. Requires flag\n     * @dev Shorter will bear the cost of forcedBid on market\n     *\n     * @param asset The market that will be impacted\n     * @param shorter Shorter getting liquidated\n     * @param id Id of short getting liquidated\n     * @param shortHintArray Array of hintId for the id to start matching against shorts since you can't match a short < oracle price\n     *\n     * @return gasFee Estimated cost of gas for the forcedBid\n     * @return ethFilled Amount of eth filled in forcedBid\n     */\n    function liquidate(\n        address asset,\n        address shorter,\n        uint8 id,\n        uint16[] memory shortHintArray\n    )\n        external\n        isNotFrozen(asset)\n        nonReentrant\n        onlyValidShortRecord(asset, shorter, id)\n        returns (uint88, uint88)\n    {\n        if (msg.sender == shorter) revert Errors.CannotLiquidateSelf();\n\n        //@dev marginCall requires more up-to-date oraclePrice (15 min vs createLimitBid's 1 hour)\n        LibOrders.updateOracleAndStartingShortViaTimeBidOnly(\n            asset, OF.FifteenMinutes, shortHintArray\n        );\n\n        MTypes.MarginCallPrimary memory m = _setMarginCallStruct(asset, shorter, id);\n\n        if (m.cRatio >= LibAsset.primaryLiquidationCR(m.asset)) {\n            revert Errors.SufficientCollateral();\n        }\n\n        // revert if no asks, or price too high\n        _checklowestSell(m);\n\n        // check if within margin call time window\n        if (!_canLiquidate(m)) {\n            STypes.ShortRecord storage shortRecord = s.shortRecords[asset][shorter][id];\n            shortRecord.resetFlag();\n            return (0, 0);\n        }\n\n        _performForcedBid(m, shortHintArray);\n\n        _marginFeeHandler(m);\n\n        _fullorPartialLiquidation(m);\n        emit Events.Liquidate(asset, shorter, id, msg.sender, m.ercDebtMatched);\n\n        return (m.gasFee, m.ethFilled);\n    }\n\n    //PRIVATE FUNCTIONS\n\n    // Reverts if no eligible sells, or if lowest sell price is too high\n    // @dev startingShortId is updated via updateOracleAndStartingShortViaTimeBidOnly() prior to call\n    function _checklowestSell(MTypes.MarginCallPrimary memory m) private view {\n        uint16 lowestAskKey = s.asks[m.asset][Constants.HEAD].nextId;\n        uint16 startingShortId = s.asset[m.asset].startingShortId;\n        uint256 bufferPrice = m.oraclePrice.mul(m.forcedBidPriceBuffer);\n        if (\n            // Checks for no eligible asks\n            (\n                lowestAskKey == Constants.TAIL\n                    || s.asks[m.asset][lowestAskKey].price > bufferPrice\n            )\n            // Checks for no eligible shorts\n            && (\n                startingShortId == Constants.HEAD // means no short >= oracleprice\n                    || s.shorts[m.asset][startingShortId].price > bufferPrice\n            )\n        ) {\n            revert Errors.NoSells();\n        }\n    }\n\n    /**\n     * @notice Sets the memory struct m with initial data\n     *\n     * @param asset The market that will be impacted\n     * @param shorter Shorter getting liquidated\n     * @param id Id of short getting liquidated\n     *\n     * @return m Memory struct used throughout MarginCallPrimaryFacet.sol\n     */\n\n    function _setMarginCallStruct(address asset, address shorter, uint8 id)\n        private\n        returns (MTypes.MarginCallPrimary memory)\n    {\n        LibShortRecord.updateErcDebt(asset, shorter, id);\n        {\n            MTypes.MarginCallPrimary memory m;\n            m.asset = asset;\n            m.short = s.shortRecords[asset][shorter][id];\n            m.vault = s.asset[asset].vault;\n            m.shorter = shorter;\n            m.minimumCR = LibAsset.minimumCR(asset);\n            m.oraclePrice = LibOracle.getPrice(asset);\n            m.cRatio = m.short.getCollateralRatio(asset);\n            m.forcedBidPriceBuffer = LibAsset.forcedBidPriceBuffer(asset);\n            m.callerFeePct = LibAsset.callerFeePct(m.asset);\n            m.tappFeePct = LibAsset.tappFeePct(m.asset);\n            m.ethDebt = m.short.ercDebt.mul(m.oraclePrice).mul(m.forcedBidPriceBuffer).mul(\n                1 ether + m.tappFeePct + m.callerFeePct\n            ); // ethDebt accounts for forcedBidPriceBuffer and potential fees\n            return m;\n        }\n    }\n\n    /**\n     * @notice Handles the set up and execution of making a forcedBid\n     * @dev Shorter will bear the cost of forcedBid on market\n     * @dev Depending on shorter's cRatio, the TAPP can attempt to fund bid\n     *\n     * @param m Memory struct used throughout MarginCallPrimaryFacet.sol\n     * @param shortHintArray Array of hintId for the id to start matching against shorts since you can't match a short < oracle price\n     *\n     */\n\n    function _performForcedBid(\n        MTypes.MarginCallPrimary memory m,\n        uint16[] memory shortHintArray\n    ) private {\n        uint256 startGas = gasleft();\n        uint88 ercAmountLeft;\n\n        //@dev Provide higher price to better ensure it can fully fill the margin call\n        uint80 _bidPrice = m.oraclePrice.mulU80(m.forcedBidPriceBuffer);\n\n        // Shorter loses leftover collateral to TAPP when unable to maintain CR above the minimum\n        m.loseCollateral = m.cRatio <= m.minimumCR;\n\n        //@dev Increase ethEscrowed by shorter's full collateral for forced bid\n        s.vaultUser[m.vault][address(this)].ethEscrowed += m.short.collateral;\n\n        // Check ability of TAPP plus short collateral to pay back ethDebt\n        if (s.vaultUser[m.vault][address(this)].ethEscrowed < m.ethDebt) {\n            uint96 ercDebtPrev = m.short.ercDebt;\n            if (s.asset[m.asset].ercDebt <= ercDebtPrev) {\n                // Occurs when only one shortRecord in the asset (market)\n                revert Errors.CannotSocializeDebt();\n            }\n            m.loseCollateral = true;\n            // @dev Max ethDebt can only be the ethEscrowed in the TAPP\n            m.ethDebt = s.vaultUser[m.vault][address(this)].ethEscrowed;\n            // Reduce ercDebt proportional to ethDebt\n            m.short.ercDebt = uint88(\n                m.ethDebt.div(_bidPrice.mul(1 ether + m.callerFeePct + m.tappFeePct))\n            ); // @dev(safe-cast)\n            uint96 ercDebtSocialized = ercDebtPrev - m.short.ercDebt;\n            // Update ercDebtRate to socialize loss (increase debt) to other shorts\n            s.asset[m.asset].ercDebtRate +=\n                ercDebtSocialized.divU64(s.asset[m.asset].ercDebt - ercDebtPrev);\n        }\n\n        // @dev MarginCall contract will be the caller. Virtual accounting done later for shorter or TAPP\n        (m.ethFilled, ercAmountLeft) = IDiamond(payable(address(this))).createForcedBid(\n            address(this), m.asset, _bidPrice, m.short.ercDebt, shortHintArray\n        );\n\n        m.ercDebtMatched = m.short.ercDebt - ercAmountLeft;\n\n        //@dev virtually burning the repurchased debt\n        s.assetUser[m.asset][address(this)].ercEscrowed -= m.ercDebtMatched;\n        s.asset[m.asset].ercDebt -= m.ercDebtMatched;\n\n        uint256 gasUsed = startGas - gasleft();\n        //@dev manually setting basefee to 1,000,000 in foundry.toml;\n        //@dev By basing gasFee off of baseFee instead of priority, adversaries are prevent from draining the TAPP\n        m.gasFee = uint88(gasUsed * block.basefee); // @dev(safe-cast)\n    }\n\n    /**\n     * @notice Handles the distribution of marginFee\n     * @dev MarginFee is taken into consideration when determining black swan\n     *\n     * @param m Memory struct used throughout MarginCallPrimaryFacet.sol\n     *\n     */\n    function _marginFeeHandler(MTypes.MarginCallPrimary memory m) private {\n        STypes.VaultUser storage VaultUser = s.vaultUser[m.vault][msg.sender];\n        STypes.VaultUser storage TAPP = s.vaultUser[m.vault][address(this)];\n        // distribute fees to TAPP and caller\n        uint88 tappFee = m.ethFilled.mulU88(m.tappFeePct);\n        uint88 callerFee = m.ethFilled.mulU88(m.callerFeePct) + m.gasFee;\n\n        m.totalFee += tappFee + callerFee;\n        //@dev TAPP already received the gasFee for being the forcedBid caller. tappFee nets out.\n        if (TAPP.ethEscrowed >= callerFee) {\n            TAPP.ethEscrowed -= callerFee;\n            VaultUser.ethEscrowed += callerFee;\n        } else {\n            // Give caller (portion of?) tappFee instead of gasFee\n            VaultUser.ethEscrowed += callerFee - m.gasFee + tappFee;\n            m.totalFee -= m.gasFee;\n            TAPP.ethEscrowed -= m.totalFee;\n        }\n    }\n\n    function min88(uint256 a, uint88 b) private pure returns (uint88) {\n        if (a > type(uint88).max) revert Errors.InvalidAmount();\n        return a < b ? uint88(a) : b;\n    }\n\n    /**\n     * @notice Handles accounting in event of full or partial liquidations\n     *\n     * @param m Memory struct used throughout MarginCallPrimaryFacet.sol\n     *\n     */\n    function _fullorPartialLiquidation(MTypes.MarginCallPrimary memory m) private {\n        uint88 decreaseCol = min88(m.totalFee + m.ethFilled, m.short.collateral);\n\n        if (m.short.ercDebt == m.ercDebtMatched) {\n            // Full liquidation\n            LibShortRecord.disburseCollateral(\n                m.asset,\n                m.shorter,\n                m.short.collateral,\n                m.short.zethYieldRate,\n                m.short.updatedAt\n            );\n            LibShortRecord.deleteShortRecord(m.asset, m.shorter, m.short.id);\n            if (!m.loseCollateral) {\n                m.short.collateral -= decreaseCol;\n                s.vaultUser[m.vault][m.shorter].ethEscrowed += m.short.collateral;\n                s.vaultUser[m.vault][address(this)].ethEscrowed -= m.short.collateral;\n            }\n        } else {\n            // Partial liquidation\n            m.short.ercDebt -= m.ercDebtMatched;\n            m.short.collateral -= decreaseCol;\n            s.shortRecords[m.asset][m.shorter][m.short.id] = m.short;\n\n            s.vaultUser[m.vault][address(this)].ethEscrowed -= m.short.collateral;\n            LibShortRecord.disburseCollateral(\n                m.asset, m.shorter, decreaseCol, m.short.zethYieldRate, m.short.updatedAt\n            );\n\n            // TAPP absorbs leftover short, unless it already owns the short\n            if (m.loseCollateral && m.shorter != address(this)) {\n                // Delete partially liquidated short\n                LibShortRecord.deleteShortRecord(m.asset, m.shorter, m.short.id);\n                // Absorb leftovers into TAPP short\n                LibShortRecord.fillShortRecord(\n                    m.asset,\n                    address(this),\n                    Constants.SHORT_STARTING_ID,\n                    SR.FullyFilled,\n                    m.short.collateral,\n                    m.short.ercDebt,\n                    s.asset[m.asset].ercDebtRate,\n                    m.short.zethYieldRate\n                );\n            }\n        }\n    }\n\n    /**\n     * @notice Helper that evaluates if a short is eligible for liquidation (i.e. flagged and within appropriate time frame)\n     * @dev Shorter has 10 hours after initial flag to bring cRatio up above maintainence margin...\n     * @dev ...After that, the flagger has 2 hours to liquidate the shorter. If short is not liquidated by shorter within that time, ANYBODY can then liquidate...\n     * @dev ...After 16 total hours have passed and the short has not been liquidated, the flag gets reset and the flagging process begins anew\n     *\n     * @param m Memory struct used throughout MarginCallPrimaryFacet.sol\n     *\n     */\n    // check if within margin call time window\n    function _canLiquidate(MTypes.MarginCallPrimary memory m)\n        private\n        view\n        returns (bool)\n    {\n        //@dev if cRatio is below the minimumCR, allow liquidation regardless of flagging\n        if (m.cRatio < m.minimumCR) return true;\n\n        //@dev Only check if flagger is empty, not updatedAt\n        if (m.short.flaggerId == 0) {\n            revert Errors.ShortNotFlagged();\n        }\n\n        /*\n         * Timeline: \n         * \n         * updatedAt (~0 hrs)\n         * ..\n         * [Errors.MarginCallIneligibleWindow]\n         * ..\n         * firstLiquidationTime (~10hrs, +10 hrs)\n         * ..\n         * [return msg.sender == short.flagger]\n         * ..\n         * secondLiquidationTime (~12hrs, +2 hrs)\n         * ..\n         * [return true (msg.sender is anyone)]\n         * ..\n         * resetLiquidationTime (~16hrs, +4 hrs)\n         * ..\n         * [return false (reset flag)]\n        */\n\n        uint256 timeDiff = LibOrders.getOffsetTimeHours() - m.short.updatedAt;\n        uint256 resetLiquidationTime = LibAsset.resetLiquidationTime(m.asset);\n\n        if (timeDiff >= resetLiquidationTime) {\n            return false;\n        } else {\n            uint256 secondLiquidationTime = LibAsset.secondLiquidationTime(m.asset);\n            bool isBetweenFirstAndSecondLiquidationTime = timeDiff\n                > LibAsset.firstLiquidationTime(m.asset) && timeDiff <= secondLiquidationTime\n                && s.flagMapping[m.short.flaggerId] == msg.sender;\n            bool isBetweenSecondAndResetLiquidationTime =\n                timeDiff > secondLiquidationTime && timeDiff <= resetLiquidationTime;\n            if (\n                !(\n                    (isBetweenFirstAndSecondLiquidationTime)\n                        || (isBetweenSecondAndResetLiquidationTime)\n                )\n            ) {\n                revert Errors.MarginCallIneligibleWindow();\n            }\n\n            return true;\n        }\n    }\n}"
    },
    {
      "filename": "contracts/facets/YieldFacet.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.21;\n\nimport {IAsset} from \"interfaces/IAsset.sol\";\n\nimport {STypes, SR} from \"contracts/libraries/DataTypes.sol\";\nimport {Modifiers} from \"contracts/libraries/AppStorage.sol\";\nimport {LibAsset} from"
    }
  ]
}