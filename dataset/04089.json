{
  "Title": "Global Protection of malicious backward calls in raw methods execution",
  "Content": "##### Description\nAt the lines: https://github.com/pie-dao/ExperiPie/blob/0.0.2/contracts/callManagers/LendingManager/LendingManager.sol#L44, https://github.com/pie-dao/ExperiPie/blob/0.0.2/contracts/callManagers/LendingManager/LendingManager.sol#L70, https://github.com/pie-dao/ExperiPie/blob/0.0.2/contracts/callManagers/LendingManager/LendingManager.sol#L102, https://github.com/pie-dao/ExperiPie/blob/0.0.2/contracts/callManagers/LendingManager/LendingManager.sol#L114, https://github.com/pie-dao/ExperiPie/blob/0.0.2/contracts/callManagers/RSIManager.sol#94, https://github.com/pie-dao/ExperiPie/blob/0.0.2/contracts/callManagers/RSIManager.sol#131 anything can happen in target methods execution.\n\nWe expect one-way class methods execution-graph like:\n```\nA.method1 -> B.method2 -> C.method3\n```\nSo it is better to ensure it.\n\n##### Recommendation\nWith growing complexity and cross-dependency of SmartContracts such mistaken or malicious case can occure and it will not be easy to track. So it is better to place protection against unexpected calls, e.g. place a `totalCallsCount` class-level variable. Increase it every time, any class-method was called.\nAnd do something like:\n\n```\n   totalCallsCountBefore = totalCallsCount;\n   call(target, bytes)\n   require(totalCallsCount == totalCallsCountBefore)\n```\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/callManagers/LendingManager/LendingManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.7.1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"./LendingRegistry.sol\";\nimport \"../../interfaces/IExperiPie.sol\";\n\ncontract LendingManager is Ownable {\n    using Math for uint256;\n\n    LendingRegistry public lendingRegistry;\n    IExperiPie public basket;\n\n    event Lend(address indexed underlying, uint256 amount, bytes32 indexed protocol);\n    event UnLend(address indexed wrapped, uint256 amount);\n    /**\n        @notice Constructor\n        @param _lendingRegistry Address of the lendingRegistry contract\n        @param _basket Address of the pool/pie/basket to manage\n    */\n    constructor(address _lendingRegistry, address _basket) public {\n        lendingRegistry = LendingRegistry(_lendingRegistry);\n        basket = IExperiPie(_basket);\n    }\n\n    /**\n        @notice Move underlying to a lending protocol\n        @param _underlying Address of the underlying token\n        @param _amount Amount of underlying to lend\n        @param _protocol Bytes32 protocol key to lend to\n    */\n    function lend(address _underlying, uint256 _amount, bytes32 _protocol) public onlyOwner {\n        // _amount or actual balance, whatever is less\n        uint256 amount = _amount.min(IERC20(_underlying).balanceOf(address(basket)));\n\n        //lend token\n        (\n            address[] memory _targets,\n            bytes[] memory _data\n        ) = lendingRegistry.getLendTXData(_underlying, amount, _protocol);\n\n        basket.callNoValue(_targets, _data);\n\n        // if needed remove underlying from basket\n        removeToken(_underlying);\n\n        // add wrapped token\n        addToken(lendingRegistry.underlyingToProtocolWrapped(_underlying, _protocol));\n\n        emit Lend(_underlying, _amount, _protocol);\n    }\n\n    /**\n        @notice Unlend wrapped token from its lending protocol\n        @param _wrapped Address of the wrapped token\n        @param _amount Amount of the wrapped token to unlend\n    */\n    function unlend(address _wrapped, uint256 _amount) public onlyOwner {\n        // unlend token\n         // _amount or actual balance, whatever is less\n        uint256 amount = _amount.min(IERC20(_wrapped).balanceOf(address(basket)));\n\n        //Unlend token\n        (\n            address[] memory _targets,\n            bytes[] memory _data\n        ) = lendingRegistry.getUnlendTXData(_wrapped, amount);\n        basket.callNoValue(_targets, _data);\n\n        // if needed add underlying\n        addToken(lendingRegistry.wrappedToUnderlying(_wrapped));\n\n        // if needed remove wrapped\n        removeToken(_wrapped);\n\n        emit UnLend(_wrapped, _amount);\n    }\n\n    /**\n        @notice Unlend and immediately lend in a different protocol\n        @param _wrapped Address of the wrapped token to bounce to another protocol\n        @param _amount Amount of the wrapped token to bounce to the other protocol\n        @param _toProtocol Protocol to deposit bounced tokens in\n    */\n    function bounce(address _wrapped, uint256 _amount, bytes32 _toProtocol) external {\n       unlend(_wrapped, _amount);\n       // Bounce all to new protocol\n       lend(lendingRegistry.wrappedToUnderlying(_wrapped), uint256(-1), _toProtocol);\n    }\n\n    function removeToken(address _token) internal {\n        uint256 balance = basket.balance(_token);\n        bool inPool = basket.getTokenInPool(_token);\n        //if there is a token balance of the token is not in the pool, skip\n        if(balance != 0 || !inPool) {\n            return;\n        }\n\n        // remove token\n        basket.singleCall(address(basket), abi.encodeWithSelector(basket.removeToken.selector, _token), 0);\n    }\n\n    function addToken(address _token) internal {\n        uint256 balance = basket.balance(_token);\n        bool inPool = basket.getTokenInPool(_token);\n        // If token has no balance or is already in the pool, skip\n        if(balance == 0 || inPool) {\n            return;\n        }\n\n        // add token\n        basket.singleCall(address(basket), abi.encodeWithSelector(basket.addToken.selector, _token), 0);\n    }\n \n}"
    }
  ]
}