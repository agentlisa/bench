{
  "Title": "Checking for Unused Attribute in Contract Macro",
  "Content": "In the [`consume_traits`](https://github.com/Brushfam/openbrush-contracts/blob/553347354de6d0ead6a335ba4c197bdd01fb2d12/lang/codegen/src/contract.rs#L66) function of the `contract` macro, `ItemTrait`s are matched against the provided input and [checked](https://github.com/Brushfam/openbrush-contracts/blob/553347354de6d0ead6a335ba4c197bdd01fb2d12/lang/codegen/src/contract.rs#L70) for the `trait_definition` attribute. However, the structure of the contracts do not have `TraitItem`s with this attribute inside the contract module due to the way that the `implementation` is [generated](https://github.com/Brushfam/openbrush-contracts/blob/553347354de6d0ead6a335ba4c197bdd01fb2d12/lang/codegen/src/implementation.rs). Hence, [the code block is never entered](https://github.com/Brushfam/openbrush-contracts/blob/553347354de6d0ead6a335ba4c197bdd01fb2d12/lang/codegen/src/contract.rs#L71-L82). Consider refactoring the contract macro by removing unused code to improve efficiency and readability.\n\n\n***Update:** Acknowledged, not resolved. The Brushfam team stated:*\n\n\n\n> *The `consume_traits` function is desired to work if some `trait_definition` is described inside contract module, so it is better to leave it there.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "lang/codegen/src/contract.rs",
      "content": "// Copyright (c) 2012-2022 Supercolony\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\"Software\"),\n// to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nuse crate::{\n    internal,\n    internal::*,\n    metadata::LockedTrait,\n    trait_definition,\n};\nuse proc_macro2::TokenStream;\nuse quote::{\n    quote,\n    ToTokens,\n};\nuse syn::Item;\n\npub fn generate(_attrs: TokenStream, ink_module: TokenStream) -> TokenStream {\n    if internal::skip() {\n        return quote! {}\n    }\n    let input: TokenStream = ink_module;\n    let attrs: TokenStream = _attrs;\n    let mut module = syn::parse2::<syn::ItemMod>(input).expect(\"Can't parse contract module\");\n    let (braces, mut items) = match module.content {\n        Some((brace, items)) => (brace, items),\n        None => {\n            panic!(\n                \"{}\",\n                \"out-of-line openbrush modules are not supported, use `#[openbrush::contract] mod name {{ ... }}`\",\n            )\n        }\n    };\n\n    // First, we need to consume all traits and update metadata file.\n    // After, we can consume all other stuff.\n    items = consume_traits(items);\n\n    let generated_items = generate_impls(items);\n\n    module.content = Some((braces, generated_items));\n\n    quote! {\n        #[::ink::contract(#attrs)]\n        #module\n    }\n}\n\nfn consume_traits(items: Vec<syn::Item>) -> Vec<syn::Item> {\n    let mut result: Vec<syn::Item> = vec![];\n    items.into_iter().for_each(|mut item| {\n        if let Item::Trait(item_trait) = &mut item {\n            if is_attr(&item_trait.attrs, \"trait_definition\") {\n                item_trait.attrs = remove_attr(&item_trait.attrs, \"trait_definition\");\n\n                let stream: TokenStream = trait_definition::generate(TokenStream::new(), item_trait.to_token_stream());\n                let mod_item = syn::parse2::<syn::ItemMod>(quote! {\n                    mod jora {\n                        #stream\n                    }\n                })\n                .expect(\"Can't parse generated trait definitions\");\n\n                let (_, mut generated_items) = mod_item.content.unwrap();\n                result.append(&mut generated_items);\n            } else {\n                result.push(item);\n            }\n        } else {\n            result.push(item);\n        }\n    });\n\n    result\n}\n\nfn generate_impls(mut items: Vec<syn::Item>) -> Vec<syn::Item> {\n    let mut generated_items: Vec<syn::Item> = vec![];\n    items.iter_mut().for_each(|mut item| {\n        if let Item::Impl(item_impl) = &mut item {\n            if let Some((_, trait_path, _)) = item_impl.trait_.clone() {\n                let trait_ident = trait_path.segments.last().expect(\"Trait path is empty\").ident.clone();\n                let trait_lock = LockedTrait::new(trait_ident.to_string());\n                if let Some(trait_definition) = &trait_lock.trait_definition {\n                    let mut generated_impls =\n                        internal::impl_external_trait(item_impl.clone(), &trait_path, trait_definition);\n                    generated_items.append(&mut generated_impls);\n                    return\n                }\n            }\n\n            generated_items.push(syn::Item::from(item_impl.clone()));\n        } else {\n            generated_items.push(item.clone());\n        }\n    });\n\n    generated_items\n}"
    }
  ]
}