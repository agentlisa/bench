{
  "Title": "[15] upgrades are automatically immediately possible instead of being able to have a kick in time in the future",
  "Content": "\n### Proof of Concept\n\nTake a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/state-transition/StateTransitionManager.sol#L177-L228\n\n```solidity\n    function _setChainIdUpgrade(uint256 _chainId, address _chainContract) internal {\n        bytes memory systemContextCalldata = abi.encodeCall(ISystemContext.setChainId, (_chainId));\n        uint256[] memory uintEmptyArray;\n        bytes[] memory bytesEmptyArray;\n\n        L2CanonicalTransaction memory l2ProtocolUpgradeTx = L2CanonicalTransaction({\n            txType: SYSTEM_UPGRADE_L2_TX_TYPE,\n            from: uint256(uint160(L2_FORCE_DEPLOYER_ADDR)),\n            to: uint256(uint160(L2_SYSTEM_CONTEXT_SYSTEM_CONTRACT_ADDR)),\n            gasLimit: $(PRIORITY_TX_MAX_GAS_LIMIT),\n            gasPerPubdataByteLimit: REQUIRED_L2_GAS_PRICE_PER_PUBDATA,\n            maxFeePerGas: uint256(0),\n            maxPriorityFeePerGas: uint256(0),\n            paymaster: uint256(0),\n            // Note, that the priority operation id is used as \"nonce\" for L1->L2 transactions\n            nonce: protocolVersion,\n            value: 0,\n            reserved: [uint256(0), 0, 0, 0],\n            data: systemContextCalldata,\n            signature: new bytes(0),\n            factoryDeps: uintEmptyArray,\n            paymasterInput: new bytes(0),\n            reservedDynamic: new bytes(0)\n        });\n\n        ProposedUpgrade memory proposedUpgrade = ProposedUpgrade({\n            l2ProtocolUpgradeTx: l2ProtocolUpgradeTx,\n            factoryDeps: bytesEmptyArray,\n            bootloaderHash: bytes32(0),\n            defaultAccountHash: bytes32(0),\n            verifier: address(0),\n            verifierParams: VerifierParams({\n                recursionNodeLevelVkHash: bytes32(0),\n                recursionLeafLevelVkHash: bytes32(0),\n                recursionCircuitsSetVksHash: bytes32(0)\n            }),\n            l1ContractsUpgradeCalldata: new bytes(0),\n            postUpgradeCalldata: new bytes(0),\n            upgradeTimestamp: 0,\n            newProtocolVersion: protocolVersion\n        });\n\n        Diamond.FacetCut[] memory emptyArray;\n        Diamond.DiamondCutData memory cutData = Diamond.DiamondCutData({\n            facetCuts: emptyArray,\n            initAddress: genesisUpgrade,\n            initCalldata: abi.encodeCall(IDefaultUpgrade.upgrade, (proposedUpgrade))\n        });\n\n        IAdmin(_chainContract).executeUpgrade(cutData);\n        emit SetChainIdUpgrade(_chainContract, l2ProtocolUpgradeTx, protocolVersion);\n    }\n```\n\nConsidering this is the logic, for setting chain upgrades, what to note here is the setting applied to the `ProposedUpgrade` struct, navigating here https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/upgrades/BaseZkSyncUpgrade.sol#L14-L40, we can see all the necessities, attached to this struct, i.e most members of the struct are to kept as `0` in order not to be updated which is rightly, but the logic for `upgradeTimestamp` and `newProtocolVersion` is wrong.\n\nFor `upgradeTimestamp`, this value should be set as the timestamp after which the upgrade can be executed, i.e in the future or at least it shouldn't be hardcoded to `0`.\n\nFor `newProtocolVersion` the version needs to be greater than the previous protocol version, but execution instead just queries the current version which is wrong, since [the attempt to upgrade the version from BaseZkSyncUpgrade.sol would revert](https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/upgrades/BaseZkSyncUpgrade.sol#L238-L241) if the version is not greater than the current one.\n\nAdditionally note that this comment: \"Note, that the priority operation id is used as \"nonce\" for L1->L2 transactions\" in this case is invalid as the operation is not a `PRIORITY_OPERATION_L2_TX_TYPE` but rather a `SYSTEM_UPGRADE_L2_TX_TYPE`.\n\n### Impact\n\nThe logic of having an upgrade be scheduled in the future is non-existent, due to the hardcodes, upgrading all upgrades are automatically immediately possible contrary to protocol's intention, this is also heavily dependent on the documentations around this, as generally for `GenesisUpgrade`, the upgradeTimestamp 0 is an ok value, as it can and should be executed immediately after chain genesis, but that's not the case for all instances\n\n### Recommended Mitigation Steps\n\nConsider allowing `upgradeTimestamp` to be set to a different value other than `0`, additionally consider allowing `protocolVersion` to be a passed in value.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-03-zksync",
  "Code": [
    {
      "filename": "code/contracts/ethereum/contracts/state-transition/StateTransitionManager.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {Diamond} from \"./libraries/Diamond.sol\";\nimport {DiamondProxy} from \"./chain-deps/DiamondProxy.sol\";\nimport {IAdmin} from \"./chain-interfaces/IAdmin.sol\";\nimport {IDefaultUpgrade} from \"../upgrades/IDefaultUpgrade.sol\";\nimport {IDiamondInit} from \"./chain-interfaces/IDiamondInit.sol\";\nimport {IExecutor} from \"./chain-interfaces/IExecutor.sol\";\nimport {IStateTransitionManager, StateTransitionManagerInitializeData} from \"./IStateTransitionManager.sol\";\nimport {ISystemContext} from \"./l2-deps/ISystemContext.sol\";\nimport {IZkSyncStateTransition} from \"./chain-interfaces/IZkSyncStateTransition.sol\";\nimport {L2_SYSTEM_CONTEXT_SYSTEM_CONTRACT_ADDR, L2_FORCE_DEPLOYER_ADDR} from \"../common/L2ContractAddresses.sol\";\nimport {L2CanonicalTransaction} from \"../common/Messaging.sol\";\nimport {Ownable2Step} from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport {ProposedUpgrade} from \"../upgrades/BaseZkSyncUpgrade.sol\";\nimport {ReentrancyGuard} from \"../common/ReentrancyGuard.sol\";\nimport {REQUIRED_L2_GAS_PRICE_PER_PUBDATA, L2_TO_L1_LOG_SERIALIZE_SIZE, DEFAULT_L2_LOGS_TREE_ROOT_HASH, EMPTY_STRING_KECCAK, SYSTEM_UPGRADE_L2_TX_TYPE, ERA_DIAMOND_PROXY, ERA_CHAIN_ID} from \"../common/Config.sol\";\nimport {VerifierParams} from \"./chain-interfaces/IVerifier.sol\";\n\n/// @title StateTransition contract\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\ncontract StateTransitionManager is IStateTransitionManager, ReentrancyGuard, Ownable2Step {\n    /// @notice Address of the bridgehub\n    address public immutable bridgehub;\n\n    /// @notice chainId => chainContract\n    mapping(uint256 => address) public stateTransition;\n\n    /// @dev Batch hash zero, calculated at initialization\n    bytes32 public storedBatchZero;\n\n    /// @dev Stored cutData for diamond cut\n    bytes32 public initialCutHash;\n\n    /// @dev genesisUpgrade contract address, used to setChainId\n    address public genesisUpgrade;\n\n    /// @dev current protocolVersion\n    uint256 public protocolVersion;\n\n    /// @dev validatorTimelock contract address, used to setChainId\n    address public validatorTimelock;\n\n    /// @dev Stored cutData for upgrade diamond cut. protocolVersion => cutHash\n    mapping(uint256 => bytes32) public upgradeCutHash;\n\n    /// @dev used to manage non critical updates\n    address public admin;\n\n    /// @dev used to accept the admin role\n    address private pendingAdmin;\n\n    /// @dev Contract is expected to be used as proxy implementation.\n    /// @dev Initialize the implementation to prevent Parity hack.\n    constructor(address _bridgehub) reentrancyGuardInitializer {\n        bridgehub = _bridgehub;\n    }\n\n    /// @notice only the bridgehub can call\n    modifier onlyBridgehub() {\n        require(msg.sender == bridgehub, \"StateTransition: only bridgehub\");\n        _;\n    }\n\n    /// @notice the admin can call, for non-critical updates\n    modifier onlyOwnerOrAdmin() {\n        require(msg.sender == admin || msg.sender == owner(), \"Bridgehub: not owner or admin\");\n        _;\n    }\n\n    function getChainAdmin(uint256 _chainId) external view override returns (address) {\n        return IZkSyncStateTransition(stateTransition[_chainId]).getAdmin();\n    }\n\n    /// @dev initialize\n    function initialize(\n        StateTransitionManagerInitializeData calldata _initializeData\n    ) external reentrancyGuardInitializer {\n        require(_initializeData.governor != address(0), \"StateTransition: governor zero\");\n        _transferOwnership(_initializeData.governor);\n\n        genesisUpgrade = _initializeData.genesisUpgrade;\n        protocolVersion = _initializeData.protocolVersion;\n        validatorTimelock = _initializeData.validatorTimelock;\n\n        // We need to initialize the state hash because it is used in the commitment of the next batch\n        IExecutor.StoredBatchInfo memory batchZero = IExecutor.StoredBatchInfo(\n            0,\n            _initializeData.genesisBatchHash,\n            _initializeData.genesisIndexRepeatedStorageChanges,\n            0,\n            EMPTY_STRING_KECCAK,\n            DEFAULT_L2_LOGS_TREE_ROOT_HASH,\n            0,\n            _initializeData.genesisBatchCommitment\n        );\n        storedBatchZero = keccak256(abi.encode(batchZero));\n\n        initialCutHash = keccak256(abi.encode(_initializeData.diamondCut));\n\n        // While this does not provide a protection in the production, it is needed for local testing\n        // Length of the L2Log encoding should not be equal to the length of other L2Logs' tree nodes preimages\n        assert(L2_TO_L1_LOG_SERIALIZE_SIZE != 2 * 32);\n    }\n\n    /// @inheritdoc IStateTransitionManager\n    function setPendingAdmin(address _newPendingAdmin) external onlyOwnerOrAdmin {\n        // Save previous value into the stack to put it into the event later\n        address oldPendingAdmin = pendingAdmin;\n        // Change pending admin\n        pendingAdmin = _newPendingAdmin;\n        emit NewPendingAdmin(oldPendingAdmin, _newPendingAdmin);\n    }\n\n    /// @inheritdoc IStateTransitionManager\n    function acceptAdmin() external {\n        address currentPendingAdmin = pendingAdmin;\n        require(msg.sender == currentPendingAdmin, \"n42\"); // Only proposed by current admin address can claim the admin rights\n\n        address previousAdmin = admin;\n        admin = currentPendingAdmin;\n        delete pendingAdmin;\n\n        emit NewPendingAdmin(currentPendingAdmin, address(0));\n        emit NewAdmin(previousAdmin, pendingAdmin);\n    }\n\n    /// @dev set validatorTimelock. Cannot do it an initialization, as validatorTimelock is deployed after STM\n    function setValidatorTimelock(address _validatorTimelock) external onlyOwnerOrAdmin {\n        validatorTimelock = _validatorTimelock;\n    }\n\n    /// @dev set initial cutHash\n    function setInitialCutHash(Diamond.DiamondCutData calldata _diamondCut) external onlyOwner {\n        initialCutHash = keccak256(abi.encode(_diamondCut));\n    }\n\n    /// @dev set New Version with upgrade from old version\n    function setNewVersionUpgrade(\n        Diamond.DiamondCutData calldata _cutData,\n        uint256 _oldProtocolVersion,\n        uint256 _newProtocolVersion\n    ) external onlyOwner {\n        upgradeCutHash[_oldProtocolVersion] = keccak256(abi.encode(_cutData));\n        protocolVersion = _newProtocolVersion;\n    }\n\n    /// @dev set upgrade for some protocolVersion\n    function setUpgradeDiamondCut(\n        Diamond.DiamondCutData calldata _cutData,\n        uint256 _oldProtocolVersion\n    ) external onlyOwner {\n        upgradeCutHash[_oldProtocolVersion] = keccak256(abi.encode(_cutData));\n    }\n\n    /// @dev freezes the specified chain\n    function freezeChain(uint256 _chainId) external onlyOwner {\n        IZkSyncStateTransition(stateTransition[_chainId]).freezeDiamond();\n    }\n\n    /// @dev freezes the specified chain\n    function unfreezeChain(uint256 _chainId) external onlyOwner {\n        IZkSyncStateTransition(stateTransition[_chainId]).freezeDiamond();\n    }\n\n    /// @dev reverts batches on the specified chain\n    function revertBatches(uint256 _chainId, uint256 _newLastBatch) external onlyOwnerOrAdmin {\n        IZkSyncStateTransition(stateTransition[_chainId]).revertBatches(_newLastBatch);\n    }\n\n    /// registration\n\n    /// @dev we have to set the chainId at genesis, as blockhashzero is the same for all chains with the same chainId\n    function _setChainIdUpgrade(uint256 _chainId, address _chainContract) internal {\n        bytes memory systemContextCalldata = abi.encodeCall(ISystemContext.setChainId, (_chainId));\n        uint256[] memory uintEmptyArray;\n        bytes[] memory bytesEmptyArray;\n\n        L2CanonicalTransaction memory l2ProtocolUpgradeTx = L2CanonicalTransaction({\n            txType: SYSTEM_UPGRADE_L2_TX_TYPE,\n            from: uint256(uint160(L2_FORCE_DEPLOYER_ADDR)),\n            to: uint256(uint160(L2_SYSTEM_CONTEXT_SYSTEM_CONTRACT_ADDR)),\n            gasLimit: $(PRIORITY_TX_MAX_GAS_LIMIT),\n            gasPerPubdataByteLimit: REQUIRED_L2_GAS_PRICE_PER_PUBDATA,\n            maxFeePerGas: uint256(0),\n            maxPriorityFeePerGas: uint256(0),\n            paymaster: uint256(0),\n            // Note, that the priority operation id is used as \"nonce\" for L1->L2 transactions\n            nonce: protocolVersion,\n            value: 0,\n            reserved: [uint256(0), 0, 0, 0],\n            data: systemContextCalldata,\n            signature: new bytes(0),\n            factoryDeps: uintEmptyArray,\n            paymasterInput: new bytes(0),\n            reservedDynamic: new bytes(0)\n        });\n\n        ProposedUpgrade memory proposedUpgrade = ProposedUpgrade({\n            l2ProtocolUpgradeTx: l2ProtocolUpgradeTx,\n            factoryDeps: bytesEmptyArray,\n            bootloaderHash: bytes32(0),\n            defaultAccountHash: bytes32(0),\n            verifier: address(0),\n            verifierParams: VerifierParams({\n                recursionNodeLevelVkHash: bytes32(0),\n                recursionLeafLevelVkHash: bytes32(0),\n                recursionCircuitsSetVksHash: bytes32(0)\n            }),\n            l1ContractsUpgradeCalldata: new bytes(0),\n            postUpgradeCalldata: new bytes(0),\n            upgradeTimestamp: 0,\n            newProtocolVersion: protocolVersion\n        });\n\n        Diamond.FacetCut[] memory emptyArray;\n        Diamond.DiamondCutData memory cutData = Diamond.DiamondCutData({\n            facetCuts: emptyArray,\n            initAddress: genesisUpgrade,\n            initCalldata: abi.encodeCall(IDefaultUpgrade.upgrade, (proposedUpgrade))\n        });\n\n        IAdmin(_chainContract).executeUpgrade(cutData);\n        emit SetChainIdUpgrade(_chainContract, l2ProtocolUpgradeTx, protocolVersion);\n    }\n\n    function registerAlreadyDeployedStateTransition(\n        uint256 _chainId,\n        address _stateTransitionContract\n    ) external onlyOwner {\n        stateTransition[_chainId] = _stateTransitionContract;\n        emit StateTransitionNewChain(_chainId, _stateTransitionContract);\n    }\n\n    /// @notice called by Bridgehub when a chain registers\n    function createNewChain(\n        uint256 _chainId,\n        address _baseToken,\n        address _sharedBridge,\n        address _admin,\n        bytes calldata _diamondCut\n    ) external onlyBridgehub {\n        if (stateTransition[_chainId] != address(0)) {\n            // StateTransition chain already registered\n            return;\n        }\n\n        // check not registered\n        Diamond.DiamondCutData memory diamondCut = abi.decode(_diamondCut, (Diamond.DiamondCutData));\n\n        // check input\n        bytes32 cutHashInput = keccak256(_diamondCut);\n        require(cutHashInput == initialCutHash, \"StateTransition: initial cutHash mismatch\");\n\n        // construct init data\n        bytes memory initData;\n        /// all together 4+9*32=292 bytes\n        initData = bytes.concat(\n            IDiamondInit.initialize.selector,\n            bytes32(_chainId),\n            bytes32(uint256(uint160(bridgehub))),\n            bytes32(uint256(uint160(address(this)))),\n            bytes32(uint256(protocolVersion)),\n            bytes32(uint256(uint160(_admin))),\n            bytes32(uint256(uint160(validatorTimelock))),\n            bytes32(uint256(uint160(_baseToken))),\n            bytes32(uint256(uint160(_sharedBridge))),\n            bytes32(storedBatchZero),\n            diamondCut.initCalldata\n        );\n\n        diamondCut.initCalldata = initData;\n        // deploy stateTransitionContract\n        DiamondProxy stateTransitionContract = new DiamondProxy{salt: bytes32(0)}(block.chainid, diamondCut);\n\n        // save data\n        address stateTransitionAddress = address(stateTransitionContract);\n\n        stateTransition[_chainId] = stateTransitionAddress;\n\n        // set chainId in VM\n        _setChainIdUpgrade(_chainId, stateTransitionAddress);\n\n        emit StateTransitionNewChain(_chainId, stateTransitionAddress);\n    }\n}"
    },
    {
      "filename": "code/contracts/ethereum/contracts/upgrades/BaseZkSyncUpgrade.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {ZkSyncStateTransitionBase} from \"../state-transition/chain-deps/facets/ZkSyncStateTransitionBase.sol\";\nimport {IMailbox} from \"../state-transition/chain-interfaces/IMailbox.sol\";\nimport {VerifierParams} from \"../state-transition/chain-interfaces/IVerifier.sol\";\nimport {IVerifier} from \"../state-transition/chain-interfaces/IVerifier.sol\";\nimport {L2ContractHelper} from \"../common/libraries/L2ContractHelper.sol\";\nimport {TransactionValidator} from \"../state-transition/libraries/TransactionValidator.sol\";\nimport {MAX_NEW_FACTORY_DEPS, SYSTEM_UPGRADE_L2_TX_TYPE, MAX_ALLOWED_PROTOCOL_VERSION_DELTA} from \"../common/Config.sol\";\nimport {L2CanonicalTransaction} from \"../common/Messaging.sol\";\n\n/// @notice The struct that represents the upgrade proposal.\n/// @param l2ProtocolUpgradeTx The system upgrade transaction.\n/// @param factoryDeps The list of factory deps for the l2ProtocolUpgradeTx.\n/// @param bootloaderHash The hash of the new bootloader bytecode. If zero, it will not be updated.\n/// @param defaultAccountHash The hash of the new default account bytecode. If zero, it will not be updated.\n/// @param verifier The address of the new verifier. If zero, the verifier will not be updated.\n/// @param verifierParams The new verifier params. If all of its fields are 0, the params will not be updated.\n/// @param l1ContractsUpgradeCalldata Custom calldata for L1 contracts upgrade, it may be interpreted differently\n/// in each upgrade. Usually empty.\n/// @param postUpgradeCalldata Custom calldata for post upgrade hook, it may be interpreted differently in each\n/// upgrade. Usually empty.\n/// @param upgradeTimestamp The timestamp after which the upgrade can be executed.\n/// @param newProtocolVersion The new version number for the protocol after this upgrade. Should be greater than\n/// the previous protocol version.\nstruct ProposedUpgrade {\n    L2CanonicalTransaction l2ProtocolUpgradeTx;\n    bytes[] factoryDeps;\n    bytes32 bootloaderHash;\n    bytes32 defaultAccountHash;\n    address verifier;\n    VerifierParams verifierParams;\n    bytes l1ContractsUpgradeCalldata;\n    bytes postUpgradeCalldata;\n    uint256 upgradeTimestamp;\n    uint256 newProtocolVersion;\n}\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice Interface to which all the upgrade implementations should adhere\nabstract contract BaseZkSyncUpgrade is ZkSyncStateTransitionBase {\n    /// @notice Changes the protocol version\n    event NewProtocolVersion(uint256 indexed previousProtocolVersion, uint256 indexed newProtocolVersion);\n\n    /// @notice 小hanges to the bytecode that is used in L2 as a bootloader (start program)\n    event NewL2BootloaderBytecodeHash(bytes32 indexed previousBytecodeHash, bytes32 indexed newBytecodeHash);\n\n    /// @notice 小hanges to the bytecode that is used in L2 as a default account\n    event NewL2DefaultAccountBytecodeHash(bytes32 indexed previousBytecodeHash, bytes32 indexed newBytecodeHash);\n\n    /// @notice Verifier address changed\n    event NewVerifier(address indexed oldVerifier, address indexed newVerifier);\n\n    /// @notice Verifier parameters changed\n    event NewVerifierParams(VerifierParams oldVerifierParams, VerifierParams newVerifierParams);\n\n    /// @notice Notifies about complete upgrade\n    event UpgradeComplete(uint256 indexed newProtocolVersion, bytes32 indexed l2UpgradeTxHash, ProposedUpgrade upgrade);\n\n    /// @notice The main function that will be provided by the upgrade proxy\n    /// @dev This is a virtual function and should be overridden by custom upgrade implementations.\n    /// @param _proposedUpgrade The upgrade to be executed.\n    /// @return txHash The hash of the L2 system contract upgrade transaction.\n    function upgrade(ProposedUpgrade calldata _proposedUpgrade) public virtual returns (bytes32 txHash) {\n        // Note that due to commitment delay, the timestamp of the L2 upgrade batch may be earlier than the timestamp\n        // of the L1 block at which the upgrade occurred. This means that using timestamp as a signifier of \"upgraded\"\n        // on the L2 side would be inaccurate. The effects of this \"back-dating\" of L2 upgrade batches will be reduced\n        // as the permitted delay window is reduced in the future.\n        require(block.timestamp >= _proposedUpgrade.upgradeTimestamp, \"Upgrade is not ready yet\");\n\n        _setNewProtocolVersion(_proposedUpgrade.newProtocolVersion);\n        _upgradeL1Contract(_proposedUpgrade.l1ContractsUpgradeCalldata);\n        _upgradeVerifier(_proposedUpgrade.verifier, _proposedUpgrade.verifierParams);\n        _setBaseSystemContracts(_proposedUpgrade.bootloaderHash, _proposedUpgrade.defaultAccountHash);\n\n        txHash = _setL2SystemContractUpgrade(\n            _proposedUpgrade.l2ProtocolUpgradeTx,\n            _proposedUpgrade.factoryDeps,\n            _proposedUpgrade.newProtocolVersion\n        );\n\n        _postUpgrade(_proposedUpgrade.postUpgradeCalldata);\n\n        emit UpgradeComplete(_proposedUpgrade.newProtocolVersion, txHash, _proposedUpgrade);\n    }\n\n    /// @notice Change default account bytecode hash, that is used on L2\n    /// @param _l2DefaultAccountBytecodeHash The hash of default account L2 bytecode\n    function _setL2DefaultAccountBytecodeHash(bytes32 _l2DefaultAccountBytecodeHash) private {\n        if (_l2DefaultAccountBytecodeHash == bytes32(0)) {\n            return;\n        }\n\n        L2ContractHelper.validateBytecodeHash(_l2DefaultAccountBytecodeHash);\n\n        // Save previous value into the stack to put it into the event later\n        bytes32 previousDefaultAccountBytecodeHash = s.l2DefaultAccountBytecodeHash;\n\n        // Change the default account bytecode hash\n        s.l2DefaultAccountBytecodeHash = _l2DefaultAccountBytecodeHash;\n        emit NewL2DefaultAccountBytecodeHash(previousDefaultAccountBytecodeHash, _l2DefaultAccountBytecodeHash);\n    }\n\n    /// @notice Change bootloader bytecode hash, that is used on L2\n    /// @param _l2BootloaderBytecodeHash The hash of bootloader L2 bytecode\n    function _setL2BootloaderBytecodeHash(bytes32 _l2BootloaderBytecodeHash) private {\n        if (_l2BootloaderBytecodeHash == bytes32(0)) {\n            return;\n        }\n\n        L2ContractHelper.validateBytecodeHash(_l2BootloaderBytecodeHash);\n\n        // Save previous value into the stack to put it into the event later\n        bytes32 previousBootloaderBytecodeHash = s.l2BootloaderBytecodeHash;\n\n        // Change the bootloader bytecode hash\n        s.l2BootloaderBytecodeHash = _l2BootloaderBytecodeHash;\n        emit NewL2BootloaderBytecodeHash(previousBootloaderBytecodeHash, _l2BootloaderBytecodeHash);\n    }\n\n    /// @notice Change the address of the verifier smart contract\n    /// @param _newVerifier Verifier smart contract address\n    function _setVerifier(IVerifier _newVerifier) private {\n        // An upgrade to the verifier must be done carefully to ensure there aren't batches in the committed state\n        // during the transition. If verifier is upgraded, it will immediately be used to prove all committed batches.\n        // Batches committed expecting the old verifier will fail. Ensure all commited batches are finalized before the\n        // verifier is upgraded.\n        if (_newVerifier == IVerifier(address(0))) {\n            return;\n        }\n\n        IVerifier oldVerifier = s.verifier;\n        s.verifier = _newVerifier;\n        emit NewVerifier(address(oldVerifier), address(_newVerifier));\n    }\n\n    /// @notice Change the verifier parameters\n    /// @param _newVerifierParams New parameters for the verifier\n    function _setVerifierParams(VerifierParams calldata _newVerifierParams) private {\n        // An upgrade to the verifier params must be done carefully to ensure there aren't batches in the committed state\n        // during the transition. If verifier is upgraded, it will immediately be used to prove all committed batches.\n        // Batches committed expecting the old verifier params will fail. Ensure all commited batches are finalized before the\n        // verifier is upgraded.\n        if (\n            _newVerifierParams.recursionNodeLevelVkHash == bytes32(0) &&\n            _newVerifierParams.recursionLeafLevelVkHash == bytes32(0) &&\n            _newVerifierParams.recursionCircuitsSetVksHash == bytes32(0)\n        ) {\n            return;\n        }\n\n        VerifierParams memory oldVerifierParams = s.verifierParams;\n        s.verifierParams = _newVerifierParams;\n        emit NewVerifierParams(oldVerifierParams, _newVerifierParams);\n    }\n\n    /// @notice Updates the verifier and the verifier params\n    /// @param _newVerifier The address of the new verifier. If 0, the verifier will not be updated.\n    /// @param _verifierParams The new verifier params. If all of the fields are 0, the params will not be updated.\n    function _upgradeVerifier(address _newVerifier, VerifierParams calldata _verifierParams) internal {\n        _setVerifier(IVerifier(_newVerifier));\n        _setVerifierParams(_verifierParams);\n    }\n\n    /// @notice Updates the bootloader hash and the hash of the default account\n    /// @param _bootloaderHash The hash of the new bootloader bytecode. If zero, it will not be updated.\n    /// @param _defaultAccountHash The hash of the new default account bytecode. If zero, it will not be updated.\n    function _setBaseSystemContracts(bytes32 _bootloaderHash, bytes32 _defaultAccountHash) internal {\n        _setL2BootloaderBytecodeHash(_bootloaderHash);\n        _setL2DefaultAccountBytecodeHash(_defaultAccountHash);\n    }\n\n    /// @notice Sets the hash of the L2 system contract upgrade transaction for the next batch to be committed\n    /// @dev If the transaction is noop (i.e. its type is 0) it does nothing and returns 0.\n    /// @param _l2ProtocolUpgradeTx The L2 system contract upgrade transaction.\n    /// @return System contracts upgrade transaction hash. Zero if no upgrade transaction is set.\n    function _setL2SystemContractUpgrade(\n        L2CanonicalTransaction calldata _l2ProtocolUpgradeTx,\n        bytes[] calldata _factoryDeps,\n        uint256 _newProtocolVersion\n    ) internal returns (bytes32) {\n        // If the type is 0, it is considered as noop and so will not be required to be executed.\n        if (_l2ProtocolUpgradeTx.txType == 0) {\n            return bytes32(0);\n        }\n\n        require(_l2ProtocolUpgradeTx.txType == SYSTEM_UPGRADE_L2_TX_TYPE, \"L2 system upgrade tx type is wrong\");\n\n        bytes memory encodedTransaction = abi.encode(_l2ProtocolUpgradeTx);\n\n        TransactionValidator.validateL1ToL2Transaction(\n            _l2ProtocolUpgradeTx,\n            encodedTransaction,\n            s.priorityTxMaxGasLimit,\n            s.feeParams.priorityTxMaxPubdata\n        );\n\n        TransactionValidator.validateUpgradeTransaction(_l2ProtocolUpgradeTx);\n\n        // We want the hashes of l2 system upgrade transactions to be unique.\n        // This is why we require that the `nonce` field is unique to each upgrade.\n        require(\n            _l2ProtocolUpgradeTx.nonce == _newProtocolVersion,\n            \"The new protocol version should be included in the L2 system upgrade tx\"\n        );\n\n        _verifyFactoryDeps(_factoryDeps, _l2ProtocolUpgradeTx.factoryDeps);\n\n        bytes32 l2ProtocolUpgradeTxHash = keccak256(encodedTransaction);\n\n        s.l2SystemContractsUpgradeTxHash = l2ProtocolUpgradeTxHash;\n\n        return l2ProtocolUpgradeTxHash;\n    }\n\n    /// @notice Verifies that the factory deps correspond to the proper hashes\n    /// @param _factoryDeps The list of factory deps\n    /// @param _expectedHashes The list of expected bytecode hashes\n    function _verifyFactoryDeps(bytes[] calldata _factoryDeps, uint256[] calldata _expectedHashes) private pure {\n        require(_factoryDeps.length == _expectedHashes.length, \"Wrong number of factory deps\");\n        require(_factoryDeps.length <= MAX_NEW_FACTORY_DEPS, \"Factory deps can be at most 32\");\n\n        for (uint256 i = 0; i < _factoryDeps.length; ++i) {\n            require(\n                L2ContractHelper.hashL2Bytecode(_factoryDeps[i]) == bytes32(_expectedHashes[i]),\n                \"Wrong factory dep hash\"\n            );\n        }\n    }\n\n    /// @notice Changes the protocol version\n    /// @param _newProtocolVersion The new protocol version\n    function _setNewProtocolVersion(uint256 _newProtocolVersion) internal virtual {\n        uint256 previousProtocolVersion = s.protocolVersion;\n        require(\n            _newProtocolVersion > previousProtocolVersion,\n            \"New protocol version is not greater than the current one\"\n        );\n        require(\n            _newProtocolVersion - previousProtocolVersion <= MAX_ALLOWED_PROTOCOL_VERSION_DELTA,\n            \"Too big protocol version difference\"\n        );\n\n        // If the previous upgrade had an L2 system upgrade transaction, we require that it is finalized.\n        // Note it is important to keep this check, as otherwise hyperchains might skip upgrades by overwriting\n        require(s.l2SystemContractsUpgradeTxHash == bytes32(0), \"Previous upgrade has not been finalized\");\n        require(\n            s.l2SystemContractsUpgradeBatchNumber == 0,\n            \"The batch number of the previous upgrade has not been cleaned\"\n        );\n\n        s.protocolVersion = _newProtocolVersion;\n        emit NewProtocolVersion(previousProtocolVersion, _newProtocolVersion);\n    }\n\n    /// @notice Placeholder function for custom logic for upgrading L1 contract.\n    /// Typically this function will never be used.\n    /// @param _customCallDataForUpgrade Custom data for an upgrade, which may be interpreted differently for each\n    /// upgrade.\n    function _upgradeL1Contract(bytes calldata _customCallDataForUpgrade) internal virtual {}\n\n    /// @notice placeholder function for custom logic for post-upgrade logic.\n    /// Typically this function will never be used.\n    /// @param _customCallDataForUpgrade Custom data for an upgrade, which may be interpreted differently for each\n    /// upgrade.\n    function _postUpgrade(bytes calldata _customCallDataForUpgrade) internal virtual {}\n}"
    },
    {
      "filename": "code/contracts/ethereum/contracts/upgrades/BaseZkSyncUpgrade.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {ZkSyncStateTransitionBase} from \"../state-transition/chain-deps/facets/ZkSyncStateTransitionBase.sol\";\nimport {IMailbox} from \"../state-transition/chain-interfaces/IMailbox.sol\";\nimport {VerifierParams} from \"../state-transition/chain-interfaces/IVerifier.sol\";\nimport {IVerifier} from \"../state-transition/chain-interfaces/IVerifier.sol\";\nimport {L2ContractHelper} from \"../common/libraries/L2ContractHelper.sol\";\nimport {TransactionValidator} from \"../state-transition/libraries/TransactionValidator.sol\";\nimport {MAX_NEW_FACTORY_DEPS, SYSTEM_UPGRADE_L2_TX_TYPE, MAX_ALLOWED_PROTOCOL_VERSION_DELTA} from \"../common/Config.sol\";\nimport {L2CanonicalTransaction} from \"../common/Messaging.sol\";\n\n/// @notice The struct that represents the upgrade proposal.\n/// @param l2ProtocolUpgradeTx The system upgrade transaction.\n/// @param factoryDeps The list of factory deps for the l2ProtocolUpgradeTx.\n/// @param bootloaderHash The hash of the new bootloader bytecode. If zero, it will not be updated.\n/// @param defaultAccountHash The hash of the new default account bytecode. If zero, it will not be updated.\n/// @param verifier The address of the new verifier. If zero, the verifier will not be updated.\n/// @param verifierParams The new verifier params. If all of its fields are 0, the params will not be updated.\n/// @param l1ContractsUpgradeCalldata Custom calldata for L1 contracts upgrade, it may be interpreted differently\n/// in each upgrade. Usually empty.\n/// @param postUpgradeCalldata Custom calldata for post upgrade hook, it may be interpreted differently in each\n/// upgrade. Usually empty.\n/// @param upgradeTimestamp The timestamp after which the upgrade can be executed.\n/// @param newProtocolVersion The new version number for the protocol after this upgrade. Should be greater than\n/// the previous protocol version.\nstruct ProposedUpgrade {\n    L2CanonicalTransaction l2ProtocolUpgradeTx;\n    bytes[] factoryDeps;\n    bytes32 bootloaderHash;\n    bytes32 defaultAccountHash;\n    address verifier;\n    VerifierParams verifierParams;\n    bytes l1ContractsUpgradeCalldata;\n    bytes postUpgradeCalldata;\n    uint256 upgradeTimestamp;\n    uint256 newProtocolVersion;\n}\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice Interface to which all the upgrade implementations should adhere\nabstract contract BaseZkSyncUpgrade is ZkSyncStateTransitionBase {\n    /// @notice Changes the protocol version\n    event NewProtocolVersion(uint256 indexed previousProtocolVersion, uint256 indexed newProtocolVersion);\n\n    /// @notice 小hanges to the bytecode that is used in L2 as a bootloader (start program)\n    event NewL2BootloaderBytecodeHash(bytes32 indexed previousBytecodeHash, bytes32 indexed newBytecodeHash);\n\n    /// @notice 小hanges to the bytecode that is used in L2 as a default account\n    event NewL2DefaultAccountBytecodeHash(bytes32 indexed previousBytecodeHash, bytes32 indexed newBytecodeHash);\n\n    /// @notice Verifier address changed\n    event NewVerifier(address indexed oldVerifier, address indexed newVerifier);\n\n    /// @notice Verifier parameters changed\n    event NewVerifierParams(VerifierParams oldVerifierParams, VerifierParams newVerifierParams);\n\n    /// @notice Notifies about complete upgrade\n    event UpgradeComplete(uint256 indexed newProtocolVersion, bytes32 indexed l2UpgradeTxHash, ProposedUpgrade upgrade);\n\n    /// @notice The main function that will be provided by the upgrade proxy\n    /// @dev This is a virtual function and should be overridden by custom upgrade implementations.\n    /// @param _proposedUpgrade The upgrade to be executed.\n    /// @return txHash The hash of the L2 system contract upgrade transaction.\n    function upgrade(ProposedUpgrade calldata _proposedUpgrade) public virtual returns (bytes32 txHash) {\n        // Note that due to commitment delay, the timestamp of the L2 upgrade batch may be earlier than the timestamp\n        // of the L1 block at which the upgrade occurred. This means that using timestamp as a signifier of \"upgraded\"\n        // on the L2 side would be inaccurate. The effects of this \"back-dating\" of L2 upgrade batches will be reduced\n        // as the permitted delay window is reduced in the future.\n        require(block.timestamp >= _proposedUpgrade.upgradeTimestamp, \"Upgrade is not ready yet\");\n\n        _setNewProtocolVersion(_proposedUpgrade.newProtocolVersion);\n        _upgradeL1Contract(_proposedUpgrade.l1ContractsUpgradeCalldata);\n        _upgradeVerifier(_proposedUpgrade.verifier, _proposedUpgrade.verifierParams);\n        _setBaseSystemContracts(_proposedUpgrade.bootloaderHash, _proposedUpgrade.defaultAccountHash);\n\n        txHash = _setL2SystemContractUpgrade(\n            _proposedUpgrade.l2ProtocolUpgradeTx,\n            _proposedUpgrade.factoryDeps,\n            _proposedUpgrade.newProtocolVersion\n        );\n\n        _postUpgrade(_proposedUpgrade.postUpgradeCalldata);\n\n        emit UpgradeComplete(_proposedUpgrade.newProtocolVersion, txHash, _proposedUpgrade);\n    }\n\n    /// @notice Change default account bytecode hash, that is used on L2\n    /// @param _l2DefaultAccountBytecodeHash The hash of default account L2 bytecode\n    function _setL2DefaultAccountBytecodeHash(bytes32 _l2DefaultAccountBytecodeHash) private {\n        if (_l2DefaultAccountBytecodeHash == bytes32(0)) {\n            return;\n        }\n\n        L2ContractHelper.validateBytecodeHash(_l2DefaultAccountBytecodeHash);\n\n        // Save previous value into the stack to put it into the event later\n        bytes32 previousDefaultAccountBytecodeHash = s.l2DefaultAccountBytecodeHash;\n\n        // Change the default account bytecode hash\n        s.l2DefaultAccountBytecodeHash = _l2DefaultAccountBytecodeHash;\n        emit NewL2DefaultAccountBytecodeHash(previousDefaultAccountBytecodeHash, _l2DefaultAccountBytecodeHash);\n    }\n\n    /// @notice Change bootloader bytecode hash, that is used on L2\n    /// @param _l2BootloaderBytecodeHash The hash of bootloader L2 bytecode\n    function _setL2BootloaderBytecodeHash(bytes32 _l2BootloaderBytecodeHash) private {\n        if (_l2BootloaderBytecodeHash == bytes32(0)) {\n            return;\n        }\n\n        L2ContractHelper.validateBytecodeHash(_l2BootloaderBytecodeHash);\n\n        // Save previous value into the stack to put it into the event later\n        bytes32 previousBootloaderBytecodeHash = s.l2BootloaderBytecodeHash;\n\n        // Change"
    }
  ]
}