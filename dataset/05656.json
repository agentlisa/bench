{
  "Title": "[L-02] Governance check is commented out",
  "Content": "\n- https://github.com/code-423n4/2023-10-canto/blob/main/canto_ambient/contracts/callpaths/LiquidityMiningPath.sol#L66\n- https://github.com/code-423n4/2023-10-canto/blob/main/canto_ambient/contracts/callpaths/LiquidityMiningPath.sol#L75\n\nBoth `setConcRewards()` and `setAmbRewards()` have a privilege check that is commented out and currently ignored:\n\n```solidity\n// require(msg.sender == governance_, \"Only callable by governance\");\n```\n\nThese functions are called as protocol commands, which undergo a privilege check in the entry point (see [here](https://github.com/code-423n4/2023-10-canto/blob/main/canto_ambient/contracts/CrocSwapDex.sol#L104)), hence the low severity of this issue. \n\nHowever, it is not clear if there's a missing additional check to ensure these are called by the governance. Consider either removing the lines or un-commenting the check.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-10-canto",
  "Code": [
    {
      "filename": "canto_ambient/contracts/callpaths/LiquidityMiningPath.sol",
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\n\nimport \"../libraries/SafeCast.sol\";\nimport \"../mixins/StorageLayout.sol\";\nimport \"../mixins/LiquidityMining.sol\";\nimport \"../libraries/ProtocolCmd.sol\";\n\n/* @title Liquidity mining callpath sidecar.\n * @notice Defines a proxy sidecar contract that's used to move code outside the \n *         main contract to avoid Ethereum's contract code size limit. Contains\n *         components related to CANTO liquidity mining.\n * \n * @dev    This exists as a standalone contract but will only ever contain proxy code,\n *         not state. As such it should never be called directly or externally, and should\n *         only be invoked with DELEGATECALL so that it operates on the contract state\n *         within the primary CrocSwap contract.\n * @dev Since this contract is a proxy sidecar, entrypoints need to be marked\n *      payable even though it doesn't directly handle msg.value. Otherwise it will\n *      fail on any. Because of this, this contract should never be used in any other\n *      context besides a proxy sidecar to CrocSwapDex. */\ncontract LiquidityMiningPath is LiquidityMining {\n    /* @notice Consolidated method for protocol control related commands. \n     *         Used to set reward rates */\n    function protocolCmd(bytes calldata cmd) public virtual {\n        (uint8 code, bytes32 poolHash, uint32 weekFrom, uint32 weekTo, uint64 weeklyReward) =\n            abi.decode(cmd, (uint8, bytes32, uint32, uint32, uint64));\n\n        if (code == ProtocolCmd.SET_CONC_REWARDS_CODE) {\n            setConcRewards(poolHash, weekFrom, weekTo, weeklyReward);\n        } else if (code == ProtocolCmd.SET_AMB_REWARDS_CODE) {\n            setAmbRewards(poolHash, weekFrom, weekTo, weeklyReward);\n        } else {\n            revert(\"Invalid protocol command\");\n        }\n    }\n\n    /* @notice Consolidated method for user commands.\n     *         Used for claiming liquidity mining rewards. */\n    function userCmd(bytes calldata input) public payable {\n        (uint8 code, bytes32 poolHash, int24 lowerTick, int24 upperTick, uint32[] memory weeksToClaim) =\n            abi.decode(input, (uint8, bytes32, int24, int24, uint32[]));\n\n        if (code == UserCmd.CLAIM_CONC_REWARDS_CODE) {\n            claimConcentratedRewards(poolHash, lowerTick, upperTick, weeksToClaim);\n        } else if (code == UserCmd.CLAIM_AMB_REWARDS_CODE) {\n            claimAmbientRewards(poolHash, weeksToClaim);\n        } else {\n            revert(\"Invalid user command\");\n        }\n    }\n\n    function claimConcentratedRewards(bytes32 poolIdx, int24 lowerTick, int24 upperTick, uint32[] memory weeksToClaim)\n        public\n        payable\n    {\n        claimConcentratedRewards(payable(msg.sender), poolIdx, lowerTick, upperTick, weeksToClaim);\n    }\n\n    function claimAmbientRewards(bytes32 poolIdx, uint32[] memory weeksToClaim) public payable {\n        claimAmbientRewards(payable(msg.sender), poolIdx, weeksToClaim);\n    }\n\n    function setConcRewards(bytes32 poolIdx, uint32 weekFrom, uint32 weekTo, uint64 weeklyReward) public payable {\n        // require(msg.sender == governance_, \"Only callable by governance\");\n        require(weekFrom % WEEK == 0 && weekTo % WEEK == 0, \"Invalid weeks\");\n        while (weekFrom <= weekTo) {\n            concRewardPerWeek_[poolIdx][weekFrom] = weeklyReward;\n            weekFrom += uint32(WEEK);\n        }\n    }\n\n    function setAmbRewards(bytes32 poolIdx, uint32 weekFrom, uint32 weekTo, uint64 weeklyReward) public payable {\n        // require(msg.sender == governance_, \"Only callable by governance\");\n        require(weekFrom % WEEK == 0 && weekTo % WEEK == 0, \"Invalid weeks\");\n        while (weekFrom <= weekTo) {\n            ambRewardPerWeek_[poolIdx][weekFrom] = weeklyReward;\n            weekFrom += uint32(WEEK);\n        }\n    }\n\n    /* @notice Used at upgrade time to verify that the contract is a valid Croc sidecar proxy and used\n     *         in the correct slot. */\n    function acceptCrocProxyRole(address, uint16 slot) public pure returns (bool) {\n        return slot == CrocSlots.LIQUIDITY_MINING_PROXY_IDX;\n    }\n}"
    },
    {
      "filename": "canto_ambient/contracts/callpaths/LiquidityMiningPath.sol",
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\n\nimport \"../libraries/SafeCast.sol\";\nimport \"../mixins/StorageLayout.sol\";\nimport \"../mixins/LiquidityMining.sol\";\nimport \"../libraries/ProtocolCmd.sol\";\n\n/* @title Liquidity mining callpath sidecar.\n * @notice Defines a proxy sidecar contract that's used to move code outside the \n *         main contract to avoid Ethereum's contract code size limit. Contains\n *         components related to CANTO liquidity mining.\n * \n * @dev    This exists as a standalone contract but will only ever contain proxy code,\n *         not state. As such it should never be called directly or externally, and should\n *         only be invoked with DELEGATECALL so that it operates on the contract state\n *         within the primary CrocSwap contract.\n * @dev Since this contract is a proxy sidecar, entrypoints need to be marked\n *      payable even though it doesn't directly handle msg.value. Otherwise it will\n *      fail on any. Because of this, this contract should never be used in any other\n *      context besides a proxy sidecar to CrocSwapDex. */\ncontract LiquidityMiningPath is LiquidityMining {\n    /* @notice Consolidated method for protocol control related commands. \n     *         Used to set reward rates */\n    function protocolCmd(bytes calldata cmd) public virtual {\n        (uint8 code, bytes32 poolHash, uint32 weekFrom, uint32 weekTo, uint64 weeklyReward) =\n            abi.decode(cmd, (uint8, bytes32, uint32, uint32, uint64));\n\n        if (code == ProtocolCmd.SET_CONC_REWARDS_CODE) {\n            setConcRewards(poolHash, weekFrom, weekTo, weeklyReward);\n        } else if (code == ProtocolCmd.SET_AMB_REWARDS_CODE) {\n            setAmbRewards(poolHash, weekFrom, weekTo, weeklyReward);\n        } else {\n            revert(\"Invalid protocol command\");\n        }\n    }\n\n    /* @notice Consolidated method for user commands.\n     *         Used for claiming liquidity mining rewards. */\n    function userCmd(bytes calldata input) public payable {\n        (uint8 code, bytes32 poolHash, int24 lowerTick, int24 upperTick, uint32[] memory weeksToClaim) =\n            abi.decode(input, (uint8, bytes32, int24, int24, uint32[]));\n\n        if (code == UserCmd.CLAIM_CONC_REWARDS_CODE) {\n            claimConcentratedRewards(poolHash, lowerTick, upperTick, weeksToClaim);\n        } else if (code == UserCmd.CLAIM_AMB_REWARDS_CODE) {\n            claimAmbientRewards(poolHash, weeksToClaim);\n        } else {\n            revert(\"Invalid user command\");\n        }\n    }\n\n    function claimConcentratedRewards(bytes32 poolIdx, int24 lowerTick, int24 upperTick, uint32[] memory weeksToClaim)\n        public\n        payable\n    {\n        claimConcentratedRewards(payable(msg.sender), poolIdx, lowerTick, upperTick, weeksToClaim);\n    }\n\n    function claimAmbientRewards(bytes32 poolIdx, uint32[] memory weeksToClaim) public payable {\n        claimAmbientRewards(payable(msg.sender), poolIdx, weeksToClaim);\n    }\n\n    function setConcRewards(bytes32 poolIdx, uint32 weekFrom, uint32 weekTo, uint64 weeklyReward) public payable {\n        // require(msg.sender == governance_, \"Only callable by governance\");\n        require(weekFrom % WEEK == 0 && weekTo % WEEK == 0, \"Invalid weeks\");\n        while (weekFrom <= weekTo) {\n            concRewardPerWeek_[poolIdx][weekFrom] = weeklyReward;\n            weekFrom += uint32(WEEK);\n        }\n    }\n\n    function setAmbRewards(bytes32 poolIdx, uint32 weekFrom, uint32 weekTo, uint64 weeklyReward) public payable {\n        // require(msg.sender == governance_, \"Only callable by governance\");\n        require(weekFrom % WEEK == 0 && weekTo % WEEK == 0, \"Invalid weeks\");\n        while (weekFrom <= weekTo) {\n            ambRewardPerWeek_[poolIdx][weekFrom] = weeklyReward;\n            weekFrom += uint32(WEEK);\n        }\n    }\n\n    /* @notice Used at upgrade time to verify that the contract is a valid Croc sidecar proxy and used\n     *         in the correct slot. */\n    function acceptCrocProxyRole(address, uint16 slot) public pure returns (bool) {\n        return slot == CrocSlots.LIQUIDITY_MINING_PROXY_IDX;\n    }\n}"
    },
    {
      "filename": "canto_ambient/contracts/CrocSwapDex.sol",
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\n\nimport './libraries/Directives.sol';\nimport './libraries/Encoding.sol';\nimport './libraries/TokenFlow.sol';\nimport './libraries/PriceGrid.sol';\nimport './mixins/MarketSequencer.sol';\nimport './mixins/SettleLayer.sol';\nimport './mixins/PoolRegistry.sol';\nimport './mixins/MarketSequencer.sol';\nimport './interfaces/ICrocMinion.sol';\nimport './callpaths/ColdPath.sol';\nimport './callpaths/BootPath.sol';\nimport './callpaths/WarmPath.sol';\nimport './callpaths/HotPath.sol';\nimport './callpaths/LongPath.sol';\nimport './callpaths/KnockoutPath.sol';\nimport './callpaths/MicroPaths.sol';\nimport './callpaths/SafeModePath.sol';\n\n/* @title CrocSwap exchange contract\n * @notice Top-level CrocSwap contract. Contains all public facing methods and state\n *         for the entire dex across every pool.\n *\n * @dev    Sidecar proxy contracts exist to contain code that doesn't fit in the Ethereum\n *         limit, but this is the only contract that users need to directly interface \n *         with. */\ncontract CrocSwapDex is HotPath, ICrocMinion {\n\n    using SafeCast for uint128;\n    using TokenFlow for TokenFlow.PairSeq;\n    using CurveMath for CurveMath.CurveState;\n    using Chaining for Chaining.PairFlow;\n\n    constructor() {\n        // Authority is originally set to deployer address, which can then transfer to\n        // proper governance contract (if deployer already isn't)\n        authority_ = msg.sender;\n        hotPathOpen_ = true;\n        proxyPaths_[CrocSlots.BOOT_PROXY_IDX] = address(new BootPath());\n    }\n\n    /* @notice Swaps between two tokens within a single liquidity pool.\n     *\n     * @dev This is the most gas optimized swap call, since it avoids calling out to any\n     *      proxy contract. However there's a possibility in the future that this call \n     *      path could be disabled to support upgraded logic. In which case the caller \n     *      should be able to swap through using a userCmd() call on the HOT_PATH proxy\n     *      call path.\n     * \n     * @param base The base-side token of the pair. (For native Ethereum use 0x0)\n     * @param quote The quote-side token of the pair.\n     * @param poolIdx The index of the pool type to execute on.\n     * @param isBuy If true the direction of the swap is for the user to send base tokens\n     *              and receive back quote tokens.\n     * @param inBaseQty If true the quantity is denominated in base-side tokens. If not\n     *                  use quote-side tokens.\n     * @param qty The quantity of tokens to swap. End result could be less if the pool \n     *            price reaches limitPrice before exhausting.\n     * @param tip A user-designated liquidity fee paid to the LPs in the pool. If set to\n     *            0, just defaults to the standard pool rate. Otherwise represents the\n     *            proposed LP fee in units of 1/1,000,000. Not used in standard swap \n     *            calls, but may be used in certain permissioned or dynamic fee pools.\n     * @param limitPrice The worse price the user is willing to pay on the margin. Swap\n     *                   will execute up to this price, but not any worse. Average fill \n     *                   price will always be equal or better, because this is calculated\n     *                   at the marginal unit of quantity.\n     * @param minOut The minimum output the user expects from the swap. If less is \n     *               returned, the transaction will revert. (Alternatively if the swap\n     *               is fixed in terms of output, this is the maximum input.)\n     * @param reserveFlags Bitwise flags to indicate if the user wants to pay/receive in\n     *                     terms of surplus collateral balance held at the dex contract.\n     *                          0x1 - Base token is paid/received from surplus collateral\n     *                          0x2 - Quote token is paid/received from surplus collateral\n     * @return The token base and quote token flows associated with this swap action. \n     *         (Negative indicates a credit paid to the user, positive a debit collected\n     *         from the user) */\n    function swap (address base, address quote,\n                   uint256 poolIdx, bool isBuy, bool inBaseQty, uint128 qty, uint16 tip,\n                   uint128 limitPrice, uint128 minOut,\n                   uint8 reserveFlags) reEntrantLock public payable\n        returns (int128 baseQuote, int128 quoteFlow) {\n        // By default the embedded hot-path is enabled, but protocol governance can\n        // disable by toggling the force proxy flag. If so, users should point to\n        // swapProxy.\n        require(hotPathOpen_);\n        return swapExecute(base, quote, poolIdx, isBuy, inBaseQty, qty, tip,\n                           limitPrice, minOut, reserveFlags);\n    }\n\n    /* @notice Consolidated method for protocol control related commands.\n     * @dev    We consolidate multiple protocol control types into a single method to \n     *         reduce the contract size in the main contract by paring down methods.\n     * \n     * @param callpath The proxy sidecar callpath called into. (Calls into proxyCmd() on\n     *                 the respective sidecare contract)\n     * @param cmd      The arbitrary byte calldata corresponding to the command. Format\n     *                 dependent on the specific callpath.\n     * @param sudo     If true, indicates that the command should be called with elevated\n     *                 privileges. */\n    function protocolCmd (uint16 callpath, bytes calldata cmd, bool sudo)\n        protocolOnly(sudo) public payable override {\n        callProtocolCmd(callpath, cmd);\n    }\n\n    /* @notice Calls an arbitrary command on one of the sidecar proxy contracts at a specific\n     *         index. Not all proxy slots may have a contract attached. If so, this call will\n     *         fail.\n     *\n     * @param callpath The index of the proxy sidecar the command is being called on.\n     * @param cmd The arbitrary call data the client is calling the proxy sidecar.\n     * @return Arbitrary byte data (if any) returned by the command. */\n    function userCmd (uint16 callpath, bytes calldata cmd) reEntrantLock\n        public payable returns (bytes memory) {\n        return callUserCmd(callpath, cmd);\n    }\n\n    /* @notice Calls an arbitrary command on behalf of another user who has signed an \n     *         EIP-712 off-chain transaction. Same general call logic as userCmd(), but\n     *         with additional args for conditions, and relayer payment.\n     *\n     * @param callpath The index of the proxy sidecar the command is being called on.\n     * @param cmd The arbitrary call data the client is calling the proxy sidecar.\n     * @param conds An ABI encoded list of evaluation conditions that are required for \n     *              this command to execute. See AgentMask.sol for format of this data.\n     * @param relayerTip An ABI encoded directive for tipping the relayer on behalf of\n     *                   the underlying client, for having mined the transaction. If this\n     *                   byte array is empty no calldata. See AgentMask.sol for format \n     *                   details.\n     * @param signature The ERC-712 signature of the above parameters signed by the \n     *                  private key of the public address the command is being executed \n     *                  for.\n     * @return Arbitrary byte data (if any) returned by the command. */\n    function userCmdRelayer (uint16 callpath, bytes calldata cmd,\n                             bytes calldata conds, bytes calldata relayerTip, \n                             bytes calldata signature)\n        reEntrantAgent(CrocRelayerCall(callpath, cmd, conds, relayerTip), signature)\n        public payable returns (bytes memory output) {\n        output = callUserCmd(callpath, cmd);\n        tipRelayer(relayerTip);\n    }\n\n    /* @notice Calls an arbitrary command on behalf of a user from a (pre-approved) \n     *         external router contract acting as an agent on the user's behalf.\n     *\n     * @dev This can only be called when the underlying user has previously approved the\n     *      msg.sender address as a router on its behalf.\n     *\n     * @param callpath The index of the proxy sidecar the command is being called on.\n     * @param cmd The arbitrary call data the client is calling the proxy sidecar.\n     * @param client The address of the client the router is calling on behalf of.\n     * @return Arbitrary byte data (if any) returned by the command. */\n    function userCmdRouter (uint16 callpath, bytes calldata cmd, address client)\n        reEntrantApproved(client, callpath) public payable\n        returns (bytes memory) {\n        return callUserCmd(callpath, cmd);\n    }\n\n    /* @notice General purpose query fuction for reading arbitrary data from the dex.\n     * @dev    This function is bare bones, because we're trying to keep the size \n     *         footprint of CrocSwapDex down. See SlotLocations.sol and QueryHelper.sol \n     *         for syntactic sugar around accessing/parsing specific data. */\n    function readSlot (uint256 slot) public view returns (uint256 data) {\n        assembly {\n        data := sload(slot)\n        }\n    }\n\n    /* @notice Validation function used by external contracts to verify an address is\n     *         a valid CrocSwapDex contract. */\n    function acceptCrocDex() pure public returns (bool) { return true; }\n}\n\n\n/* @notice Alternative constructor to CrocSwapDex that's more convenient. However\n *     the deploy transaction is several hundred kilobytes and will get droppped by \n *     geth. Useful for testing environments though. */\ncontract CrocSwapDexSeed  is CrocSwapDex {\n    \n    constructor() {\n        proxyPaths_[CrocSlots.LP_PROXY_IDX] = address(new WarmPath());\n        proxyPaths_[CrocSlots.COLD_PROXY_IDX] = address(new ColdPath());\n        proxyPaths_[CrocSlots.LONG_PROXY_IDX] = address(new LongPath());\n        proxyPaths_[CrocSlots.MICRO_PROXY_IDX] = address(new MicroPaths());\n        proxyPaths_[CrocSlots.FLAG_CROSS_PROXY_IDX] = address(new KnockoutFlagPath());\n        proxyPaths_[CrocSlots.KNOCKOUT_LP_PROXY_IDX] = address(new KnockoutLiqPath());\n        proxyPaths_[CrocSlots.SAFE_MODE_PROXY_PATH] = address(new SafeModePath());\n    }\n}"
    }
  ]
}