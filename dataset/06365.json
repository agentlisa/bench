{
  "Title": "[M-09] There is no mechanism that prevents from minting less than `esLBR` maximum supply in `StakingRewardsV2`",
  "Content": "\n### Lines of code\n\n<https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/token/esLBR.sol#L30-L32> <br><https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/token/esLBR.sol#L20> <br><https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/miner/ProtocolRewardsPool.sol#L73-L77>\n\n### Vulnerability details\n\nI'm assuming that esLBR is distributed as a reward in `StakingRewardsV2` - it's not clear from the docs. But `rewardsToken` is of type `IesLBR` and in order to calculate boost for rewards `esLBRBoost` contract is used, so I think that it's a reasonable assumption.\n\nThe esLBR token has a total supply of `100 000 000` and this is enforced in the `esLBR` contract:\n\n```solidity\nfunction mint(address user, uint256 amount) external returns (bool) {\n        require(configurator.tokenMiner(msg.sender), \"not authorized\");\n        require(totalSupply() + amount <= maxSupply, \"exceeding the maximum supply quantity.\");\n```\n\nHowever, the `StakingRewardsV2` contract which is approved to mint new esLBR tokens doesn't enforce that new tokens can always be minted.\n\nEither due to admin mistake (it's possible to call `StakingRewardsV2::notifyRewardAmount` with arbitrarily high `_amount`, which is not validated; it's also possible to set `duration` to an arbitrarily low value, so `rewardRatio` may be very high), or by normal protocol functioning, `100 000 000` of esLBR may be finally minted.\n\nIf that happens, no user will be able to claim their reward via `getReward`, since `mint` will revert. It also won't be possible to stake esLBR tokens in `ProtocolRewardsPool` or call any functions that use `esLBR.mint` underneath.\n\n### Impact\n\nLack of the possibility to stake esLBR is impacting important functionality of the protocol, while no possibility to withdraw earned rewards, this is a loss of assets for users.\n\nFrom Code4Rena docs:\n\n    3 - High: Assets can be stolen/lost/compromised directly (or indirectly if there is a valid attack path that does not have hand-wavy hypotheticals).\n\nHere, assets definitely can be lost. Also, while it could happen because of a misconfiguration by the admin, it can also happen naturally, since esLBR is inflationary and there is no mechanism that enforces the supply being far enough from the max supply. The only thing that could be done to prevent it is that the admin would have to calculate the current supply, analyse the number of stakers, control staking boosts, and set reward ratio accordingly, which is hard to do and error prone.\nSince assets can be lost and there aren't any needed external requirements here (and it doesn't have hand-wavy hypotheticals, in my opinion), I'm submitting this finding as High.\n\n### Proof of Concept\n\nNumber of reward tokens that users get is calculated here: <br><https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/miner/stakerewardV2pool.sol#L106-L108>\n\nUsers can get their rewards by calling `getReward`: <br><https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/miner/stakerewardV2pool.sol#L111-L118>\n\nThere is no mechanism preventing too high `rewardRatio` when it's set: <br><https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/miner/stakerewardV2pool.sol#L132-L145>\n\n`mint` will fail on too high supply: <br><https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/token/esLBR.sol#L30-L36>\n\nUsers won't be able to claim acquired rewards, which is a loss of assets for them.\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\nDo one of the following:\n\n*   Introduce some mechanism that will enforce that esLBR max supply will never be achieved (something similar to Bitcoin halving, for example).\n*   Do not set esLBR max supply (still do your best to limit it to `100 000 000`, but if it goes above that number, users will still be able to claim their acquired rewards).\n\n### Assessed type\n\nERC20\n\n**[LybraFinance acknowledged](https://github.com/code-423n4/2023-06-lybra-findings/issues/647#issuecomment-1635562951)**\n\n**[0xean (judge) decreased severity to Low and commented](https://github.com/code-423n4/2023-06-lybra-findings/issues/647#issuecomment-1650696059):**\n > This comes down to input sanitization, which is typically awarded as QA.\n\n**[0xean (judge) increased severity to Medium and commented](https://github.com/code-423n4/2023-06-lybra-findings/issues/647#issuecomment-1650696940):**\n > Thought about this one a bit more and since there is a possibility of the inputs being correct, but the emissions exceeding the max supply. M feels like the right severity. \n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-06-lybra",
  "Code": [
    {
      "filename": "contracts/lybra/token/esLBR.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.17;\n/**\n * @title esLBR is an ERC20-compliant token, but cannot be transferred and can only be minted through the esLBRMinter contract or redeemed for LBR by destruction.\n * - The maximum amount that can be minted through the esLBRMinter contract is 55 million.\n * - esLBR can be used for community governance voting.\n */\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol\";\nimport \"../interfaces/Iconfigurator.sol\";\n\ninterface IProtocolRewardsPool {\n    function refreshReward(address user) external;\n}\n\ncontract esLBR is ERC20Votes {\n    Iconfigurator public immutable configurator;\n\n    uint256 maxSupply = 100_000_000 * 1e18;\n\n    constructor(address _config) ERC20Permit(\"esLBR\") ERC20(\"esLBR\", \"esLBR\") {\n        configurator = Iconfigurator(_config);\n    }\n\n    function _transfer(address, address, uint256) internal virtual override {\n        revert(\"not authorized\");\n    }\n\n    function mint(address user, uint256 amount) external returns (bool) {\n        require(configurator.tokenMiner(msg.sender), \"not authorized\");\n        require(totalSupply() + amount <= maxSupply, \"exceeding the maximum supply quantity.\");\n        try IProtocolRewardsPool(configurator.getProtocolRewardsPool()).refreshReward(user) {} catch {}\n        _mint(user, amount);\n        return true;\n    }\n\n    function burn(address user, uint256 amount) external returns (bool) {\n        require(configurator.tokenMiner(msg.sender), \"not authorized\");\n        try IProtocolRewardsPool(configurator.getProtocolRewardsPool()).refreshReward(user) {} catch {}\n        _burn(user, amount);\n        return true;\n    }\n}"
    }
  ]
}