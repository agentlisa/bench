{
  "Title": "[M-10] Voted votes cannot change after the user is issued new votes or the user's old votes are revoked during voting",
  "Content": "_Submitted by rbserver, also found by &#95;&#95;141345&#95;&#95;, cccz, csanuragjain, GalloDaSballo, Guardian, Lambda, m9800, and zzzitron_\n\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L240-L262><br>\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/VoterRegistration.sol#L45-L48><br>\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/VoterRegistration.sol#L53-L56><br>\n\nA user can call the following `vote` function to vote for a proposal. During voting, the voter admin can still call the `issueVotesTo` and `revokeVotesFrom` functions below to issue new votes or revoke old votes for the user, which also changes the votes' total supply during the overall voting. Because each user can only call `vote` once for a proposal due to the `userVotesForProposal[activeProposal.proposalId][msg.sender] > 0` conditional check, the old voted votes, resulted from the `vote` call by the user, will be used to compare against the new total supply of the votes, resulted from the `issueVotesTo` and `revokeVotesFrom` calls during the overall voting, when determining whether the proposal can be executed or not. Because of this inconsistency, the result on whether the proposal can be executed might not be reliable.\n\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/Governance.sol#L240-L262>\n\n```solidity\n    function vote(bool for_) external {\n        uint256 userVotes = VOTES.balanceOf(msg.sender);\n\n        if (activeProposal.proposalId == 0) {\n            revert NoActiveProposalDetected();\n        }\n\n        if (userVotesForProposal[activeProposal.proposalId][msg.sender] > 0) {\n            revert UserAlreadyVoted();\n        }\n\n        if (for_) {\n            yesVotesForProposal[activeProposal.proposalId] += userVotes;\n        } else {\n            noVotesForProposal[activeProposal.proposalId] += userVotes;\n        }\n\n        userVotesForProposal[activeProposal.proposalId][msg.sender] = userVotes;\n\n        VOTES.transferFrom(msg.sender, address(this), userVotes);\n\n        emit WalletVoted(activeProposal.proposalId, msg.sender, for_, userVotes);\n    }\n```\n\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/VoterRegistration.sol#L45-L48>\n\n```solidity\n    function issueVotesTo(address wallet_, uint256 amount_) external onlyRole(\"voter_admin\") {\n        // Issue the votes in the VOTES module\n        VOTES.mintTo(wallet_, amount_);\n    }\n```\n\n<https://github.com/code-423n4/2022-08-olympus/blob/main/src/policies/VoterRegistration.sol#L53-L56>\n\n```solidity\n    function revokeVotesFrom(address wallet_, uint256 amount_) external onlyRole(\"voter_admin\") {\n        // Revoke the votes in the VOTES module\n        VOTES.burnFrom(wallet_, amount_);\n    }\n```\n\n### Proof of Concept\n\nPlease add the following code in `src\\test\\policies\\Governance.t.sol`.\n\nFirst, please add the following code for `stdError`.\n\n```solidity\nimport {Test, stdError} from \"forge-std/Test.sol\";    // @audit import stdError for testing purpose\n```\n\nThen, please append the following tests. These tests will pass to demonstrate the described scenarios.\n\n```solidity\n    function testScenario_UserCannotVoteAgainWithNewlyMintedVotes() public {\n        _createActiveProposal();\n\n        // voter3 votes for the proposal\n        vm.prank(voter3);\n        governance.vote(true);\n\n        assertEq(governance.yesVotesForProposal(1), 300);\n        assertEq(governance.noVotesForProposal(1), 0);\n\n        assertEq(governance.userVotesForProposal(1, voter3), 300);\n        assertEq(VOTES.balanceOf(voter3), 0);\n        assertEq(VOTES.balanceOf(address(governance)), 300);\n\n        // to simulate calling VoterRegistration.issueVotesTo that mints votes to voter3, VOTES.mintTo is called by godmode here\n        vm.prank(godmode);\n        VOTES.mintTo(voter3, 500);\n        assertEq(VOTES.balanceOf(voter3), 500);\n\n        // calling vote function again by voter3 reverts, which means that voter3 cannot additionally vote with the 500 newly minted votes\n        vm.expectRevert(UserAlreadyVoted.selector);\n        vm.prank(voter3);\n        governance.vote(true);\n    }\n```\n\n```solidity\n    function testScenario_RevokeVotesAfterUserFinishsOwnVoting() public {\n        _createActiveProposal();\n\n        // voter3 votes for the proposal\n        vm.prank(voter3);\n        governance.vote(true);\n\n        assertEq(governance.yesVotesForProposal(1), 300);\n        assertEq(governance.noVotesForProposal(1), 0);\n\n        assertEq(governance.userVotesForProposal(1, voter3), 300);\n        assertEq(VOTES.balanceOf(voter3), 0);\n        assertEq(VOTES.balanceOf(address(governance)), 300);\n\n        // To simulate calling VoterRegistration.revokeVotesFrom that burns voter3's votes, VOTES.burnFrom is called by godmode here.\n        // However, calling VOTES.burnFrom will revert due to arithmetic underflow.\n        vm.prank(godmode);\n        vm.expectRevert(stdError.arithmeticError);\n        VOTES.burnFrom(voter3, 300);\n\n        // the proposal is still voted with voter3's previous votes afterwards\n        assertEq(governance.userVotesForProposal(1, voter3), 300);\n        assertEq(VOTES.balanceOf(voter3), 0);\n        assertEq(VOTES.balanceOf(address(governance)), 300);\n    }\n```\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\nWhen `issueVotesTo` and `revokeVotesFrom` are called during voting, the corresponding votes need to be added to or removed from the proposal's voted votes for the user. Alternatively, `issueVotesTo` and `revokeVotesFrom` can be disabled when an active proposal exists.\n\n**[fullyallocated (Olympus) confirmed and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/275#issuecomment-1236238446):**\n > This is the best written answer. \n>\n > Originally votes were locked so that users cannot constantly change their vote to manipulate the outcome but the warden makes a good point about how the quorum thresholds can be changed and the affects on how consensus is calculated.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-08-olympus-dao-contest",
  "Code": [
    {
      "filename": "src/policies/Governance.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// The Governance Policy submits & activates instructions in a INSTR module\n\nimport {OlympusInstructions} from \"modules/INSTR.sol\";\nimport {OlympusVotes} from \"modules/VOTES.sol\";\nimport \"src/Kernel.sol\";\n\n// proposing\nerror NotEnoughVotesToPropose();\n\n// endorsing\nerror CannotEndorseNullProposal();\nerror CannotEndorseInvalidProposal();\n\n// activating\nerror NotAuthorizedToActivateProposal();\nerror NotEnoughEndorsementsToActivateProposal();\nerror ProposalAlreadyActivated();\nerror ActiveProposalNotExpired();\nerror SubmittedProposalHasExpired();\n\n// voting\nerror NoActiveProposalDetected();\nerror UserAlreadyVoted();\n\n// executing\nerror NotEnoughVotesToExecute();\nerror ExecutionTimelockStillActive();\n\n// claiming\nerror VotingTokensAlreadyReclaimed();\nerror CannotReclaimTokensForActiveVote();\nerror CannotReclaimZeroVotes();\n\nstruct ProposalMetadata {\n    bytes32 title;\n    address submitter;\n    uint256 submissionTimestamp;\n    string proposalURI;\n}\n\nstruct ActivatedProposal {\n    uint256 proposalId;\n    uint256 activationTimestamp;\n}\n\n/// @notice OlympusGovernance\n/// @dev The Governor Policy is also the Kernel's Executor.\ncontract OlympusGovernance is Policy {\n    /////////////////////////////////////////////////////////////////////////////////\n    //                         Kernel Policy Configuration                         //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    OlympusInstructions public INSTR;\n    OlympusVotes public VOTES;\n\n    constructor(Kernel kernel_) Policy(kernel_) {}\n\n    function configureDependencies() external override returns (Keycode[] memory dependencies) {\n        dependencies = new Keycode[](2);\n        dependencies[0] = toKeycode(\"INSTR\");\n        dependencies[1] = toKeycode(\"VOTES\");\n\n        INSTR = OlympusInstructions(getModuleAddress(dependencies[0]));\n        VOTES = OlympusVotes(getModuleAddress(dependencies[1]));\n    }\n\n    function requestPermissions()\n        external\n        view\n        override\n        onlyKernel\n        returns (Permissions[] memory requests)\n    {\n        requests = new Permissions[](2);\n        requests[0] = Permissions(INSTR.KEYCODE(), INSTR.store.selector);\n        requests[1] = Permissions(VOTES.KEYCODE(), VOTES.transferFrom.selector);\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                             Policy Variables                                //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    event ProposalSubmitted(uint256 proposalId);\n    event ProposalEndorsed(uint256 proposalId, address voter, uint256 amount);\n    event ProposalActivated(uint256 proposalId, uint256 timestamp);\n    event WalletVoted(uint256 proposalId, address voter, bool for_, uint256 userVotes);\n    event ProposalExecuted(uint256 proposalId);\n\n    /// @notice The currently activated proposal in the governance system.\n    ActivatedProposal public activeProposal;\n\n    /// @notice Return a proposal metadata object for a given proposal id.\n    mapping(uint256 => ProposalMetadata) public getProposalMetadata;\n\n    /// @notice Return the total endorsements for a proposal id.\n    mapping(uint256 => uint256) public totalEndorsementsForProposal;\n\n    /// @notice Return the number of endorsements a user has given a proposal id.\n    mapping(uint256 => mapping(address => uint256)) public userEndorsementsForProposal;\n\n    /// @notice Return whether a proposal id has been activated. Once this is true, it should never be flipped false.\n    mapping(uint256 => bool) public proposalHasBeenActivated;\n\n    /// @notice Return the total yes votes for a proposal id used in calculating net votes.\n    mapping(uint256 => uint256) public yesVotesForProposal;\n\n    /// @notice Return the total no votes for a proposal id used in calculating net votes.\n    mapping(uint256 => uint256) public noVotesForProposal;\n\n    /// @notice Return the amount of votes a user has applied to a proposal id. This does not record how the user voted.\n    mapping(uint256 => mapping(address => uint256)) public userVotesForProposal;\n\n    /// @notice Return the amount of tokens reclaimed by a user after voting on a proposal id.\n    mapping(uint256 => mapping(address => bool)) public tokenClaimsForProposal;\n\n    /// @notice The amount of votes a proposer needs in order to submit a proposal as a percentage of total supply (in basis points).\n    /// @dev    This is set to 1% of the total supply.\n    uint256 public constant SUBMISSION_REQUIREMENT = 100;\n\n    /// @notice Amount of time a submitted proposal has to activate before it expires.\n    uint256 public constant ACTIVATION_DEADLINE = 2 weeks;\n\n    /// @notice Amount of time an activated proposal must stay up before it can be replaced by a new activated proposal.\n    uint256 public constant GRACE_PERIOD = 1 weeks;\n\n    /// @notice Endorsements required to activate a proposal as percentage of total supply.\n    uint256 public constant ENDORSEMENT_THRESHOLD = 20;\n\n    /// @notice Net votes required to execute a proposal on chain as a percentage of total supply.\n    uint256 public constant EXECUTION_THRESHOLD = 33;\n\n    /// @notice Required time for a proposal to be active before it can be executed.\n    /// @dev    This amount should be greater than 0 to prevent flash loan attacks.\n    uint256 public constant EXECUTION_TIMELOCK = 3 days;\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                               User Actions                                  //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Return the metadata for a proposal.\n    /// @dev    Used to return & access the entire metadata struct in solidity\n    function getMetadata(uint256 proposalId_) public view returns (ProposalMetadata memory) {\n        return getProposalMetadata[proposalId_];\n    }\n\n    /// @notice Return the currently active proposal in governance.\n    /// @dev    Used to return & access the entire struct active proposal struct in solidity.\n    function getActiveProposal() public view returns (ActivatedProposal memory) {\n        return activeProposal;\n    }\n\n    /// @notice Submit an on chain governance proposal.\n    /// @param  instructions_ - an array of Instruction objects each containing a Kernel Action and a target Contract address.\n    /// @param  title_ - a human-readable title of the proposal — i.e. \"OIP XX - My Proposal Title\".\n    /// @param  proposalURI_ - an arbitrary url linking to a human-readable description of the proposal - i.e. Snapshot, Discourse, Google Doc.\n    function submitProposal(\n        Instruction[] calldata instructions_,\n        bytes32 title_,\n        string memory proposalURI_\n    ) external {\n        if (VOTES.balanceOf(msg.sender) * 10000 < VOTES.totalSupply() * SUBMISSION_REQUIREMENT)\n            revert NotEnoughVotesToPropose();\n\n        uint256 proposalId = INSTR.store(instructions_);\n        getProposalMetadata[proposalId] = ProposalMetadata(\n            title_,\n            msg.sender,\n            block.timestamp,\n            proposalURI_\n        );\n\n        emit ProposalSubmitted(proposalId);\n    }\n\n    /// @notice Endorse a proposal.\n    /// @param  proposalId_ - The ID of the proposal being endorsed.\n    function endorseProposal(uint256 proposalId_) external {\n        uint256 userVotes = VOTES.balanceOf(msg.sender);\n\n        if (proposalId_ == 0) {\n            revert CannotEndorseNullProposal();\n        }\n\n        Instruction[] memory instructions = INSTR.getInstructions(proposalId_);\n        if (instructions.length == 0) {\n            revert CannotEndorseInvalidProposal();\n        }\n\n        // undo any previous endorsement the user made on these instructions\n        uint256 previousEndorsement = userEndorsementsForProposal[proposalId_][msg.sender];\n        totalEndorsementsForProposal[proposalId_] -= previousEndorsement;\n\n        // reapply user endorsements with most up-to-date votes\n        userEndorsementsForProposal[proposalId_][msg.sender] = userVotes;\n        totalEndorsementsForProposal[proposalId_] += userVotes;\n\n        emit ProposalEndorsed(proposalId_, msg.sender, userVotes);\n    }\n\n    /// @notice Activate a proposal.\n    /// @param  proposalId_ - The ID of the proposal being activated.\n    function activateProposal(uint256 proposalId_) external {\n        ProposalMetadata memory proposal = getProposalMetadata[proposalId_];\n\n        if (msg.sender != proposal.submitter) {\n            revert NotAuthorizedToActivateProposal();\n        }\n\n        if (block.timestamp > proposal.submissionTimestamp + ACTIVATION_DEADLINE) {\n            revert SubmittedProposalHasExpired();\n        }\n\n        if (\n            (totalEndorsementsForProposal[proposalId_] * 100) <\n            VOTES.totalSupply() * ENDORSEMENT_THRESHOLD\n        ) {\n            revert NotEnoughEndorsementsToActivateProposal();\n        }\n\n        if (proposalHasBeenActivated[proposalId_] == true) {\n            revert ProposalAlreadyActivated();\n        }\n\n        if (block.timestamp < activeProposal.activationTimestamp + GRACE_PERIOD) {\n            revert ActiveProposalNotExpired();\n        }\n\n        activeProposal = ActivatedProposal(proposalId_, block.timestamp);\n\n        proposalHasBeenActivated[proposalId_] = true;\n\n        emit ProposalActivated(proposalId_, block.timestamp);\n    }\n\n    /// @notice Cast a vote for the currently active proposal.\n    /// @param  for_ - A boolean representing the vote: true for yes, false for no.\n    function vote(bool for_) external {\n        uint256 userVotes = VOTES.balanceOf(msg.sender);\n\n        if (activeProposal.proposalId == 0) {\n            revert NoActiveProposalDetected();\n        }\n\n        if (userVotesForProposal[activeProposal.proposalId][msg.sender] > 0) {\n            revert UserAlreadyVoted();\n        }\n\n        if (for_) {\n            yesVotesForProposal[activeProposal.proposalId] += userVotes;\n        } else {\n            noVotesForProposal[activeProposal.proposalId] += userVotes;\n        }\n\n        userVotesForProposal[activeProposal.proposalId][msg.sender] = userVotes;\n\n        VOTES.transferFrom(msg.sender, address(this), userVotes);\n\n        emit WalletVoted(activeProposal.proposalId, msg.sender, for_, userVotes);\n    }\n\n    /// @notice Execute the currently active proposal.\n    function executeProposal() external {\n        uint256 netVotes = yesVotesForProposal[activeProposal.proposalId] -\n            noVotesForProposal[activeProposal.proposalId];\n        if (netVotes * 100 < VOTES.totalSupply() * EXECUTION_THRESHOLD) {\n            revert NotEnoughVotesToExecute();\n        }\n\n        if (block.timestamp < activeProposal.activationTimestamp + EXECUTION_TIMELOCK) {\n            revert ExecutionTimelockStillActive();\n        }\n\n        Instruction[] memory instructions = INSTR.getInstructions(activeProposal.proposalId);\n\n        for (uint256 step; step < instructions.length; ) {\n            kernel.executeAction(instructions[step].action, instructions[step].target);\n            unchecked {\n                ++step;\n            }\n        }\n\n        emit ProposalExecuted(activeProposal.proposalId);\n\n        // deactivate the active proposal\n        activeProposal = ActivatedProposal(0, 0);\n    }\n\n    /// @notice Reclaim locked votes from the contract after the proposal is no longer active.\n    /// @dev    The governance contract locks casted votes into the contract until the proposal\n    ///         is no longer active to prevent repeated voting with the same tokens.\n    /// @param  proposalId_ - The proposal that the user is reclaiming tokens for.\n    function reclaimVotes(uint256 proposalId_) external {\n        uint256 userVotes = userVotesForProposal[proposalId_][msg.sender];\n\n        if (userVotes == 0) {\n            revert CannotReclaimZeroVotes();\n        }\n\n        if (proposalId_ == activeProposal.proposalId) {\n            revert CannotReclaimTokensForActiveVote();\n        }\n\n        if (tokenClaimsForProposal[proposalId_][msg.sender] == true) {\n            revert VotingTokensAlreadyReclaimed();\n        }\n\n        tokenClaimsForProposal[proposalId_][msg.sender] = true;\n\n        VOTES.transferFrom(address(this), msg.sender, userVotes);\n    }\n}"
    },
    {
      "filename": "src/policies/VoterRegistration.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {OlympusVotes} from \"modules/VOTES.sol\";\nimport \"src/Kernel.sol\";\n\n/// @notice Policy to mint and burn votes to arbitrary addresses\n/// @dev A policy to distribute votes for OlympusGovernance\ncontract VoterRegistration is Policy {\n    OlympusVotes public VOTES;\n\n    /*//////////////////////////////////////////////////////////////\n                            POLICY INTERFACE\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(Kernel kernel_) Policy(kernel_) {}\n\n    /// @inheritdoc Policy\n    function configureDependencies() external override returns (Keycode[] memory dependencies) {\n        dependencies = new Keycode[](1);\n        dependencies[0] = toKeycode(\"VOTES\");\n\n        VOTES = OlympusVotes(getModuleAddress(dependencies[0]));\n    }\n\n    /// @inheritdoc Policy\n    function requestPermissions()\n        external\n        view\n        override\n        returns (Permissions[] memory permissions)\n    {\n        permissions = new Permissions[](2);\n        permissions[0] = Permissions(VOTES.KEYCODE(), VOTES.mintTo.selector);\n        permissions[1] = Permissions(VOTES.KEYCODE(), VOTES.burnFrom.selector);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CORE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Issue votes to a wallet\n    /// @param  wallet_ - The address receiving the votes.\n    /// @param  amount_ - The amount of votes to mint to the wallet.\n    function issueVotesTo(address wallet_, uint256 amount_) external onlyRole(\"voter_admin\") {\n        // Issue the votes in the VOTES module\n        VOTES.mintTo(wallet_, amount_);\n    }\n\n    /// @notice Burn votes from a wallet\n    /// @param  wallet_ - The address losing the votes.\n    /// @param  amount_ - The amount of votes to burn from the wallet.\n    function revokeVotesFrom(address wallet_, uint256 amount_) external onlyRole(\"voter_admin\") {\n        // Revoke the votes in the VOTES module\n        VOTES.burnFrom(wallet_, amount_);\n    }\n}"
    },
    {
      "filename": "src/policies/VoterRegistration.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {OlympusVotes} from \"modules/VOTES.sol\";\nimport \"src/Kernel.sol\";\n\n/// @notice Policy to mint and burn votes to arbitrary addresses\n/// @dev A policy to distribute votes for OlympusGovernance\ncontract VoterRegistration is Policy {\n    OlympusVotes public VOTES;\n\n    /*//////////////////////////////////////////////////////////////\n                            POLICY INTERFACE\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(Kernel kernel_) Policy(kernel_) {}\n\n    /// @inheritdoc Policy\n    function configureDependencies() external override returns (Keycode[] memory dependencies) {\n        dependencies = new Keycode[](1);\n        dependencies[0] = toKeycode(\"VOTES\");\n\n        VOTES = OlympusVotes(getModuleAddress(dependencies[0]));\n    }\n\n    /// @inheritdoc Policy\n    function requestPermissions()\n        external\n        view\n        override\n        returns (Permissions[] memory permissions)\n    {\n        permissions = new Permissions[](2);\n        permissions[0] = Permissions(VOTES.KEYCODE(), VOTES.mintTo.selector);\n        permissions[1] = Permissions(VOTES.KEYCODE(), VOTES.burnFrom.selector);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CORE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Issue votes to a wallet\n    /// @param  wallet_ - The address receiving the votes.\n    /// @param  amount_ - The amount of votes to mint to the wallet.\n    function issueVotesTo(address wallet_, uint256 amount_) external onlyRole(\"voter_admin\") {\n        // Issue the votes in the VOTES module\n        VOTES.mintTo(wallet_, amount_);\n    }\n\n    /// @notice Burn votes from a wallet\n    /// @param  wallet_ - The address losing the votes.\n    /// @param  amount_ - The amount of votes to burn from the wallet.\n    function revokeVotesFrom(address wallet_, uint256 amount_) external onlyRole(\"voter_admin\") {\n        // Revoke the votes in the VOTES module\n        VOTES.burnFrom(wallet_, amount_);\n    }\n}"
    },
    {
      "filename": "src/policies/Governance.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// The Governance Policy submits & activates instructions in a INSTR module\n\nimport {OlympusInstructions} from \"modules/INSTR.sol\";\nimport {OlympusVotes} from \"modules/VOTES.sol\";\nimport \"src/Kernel.sol\";\n\n// proposing\nerror NotEnoughVotesToPropose();\n\n// endorsing\nerror CannotEndorseNullProposal();\nerror CannotEndorseInvalidProposal();\n\n// activating\nerror NotAuthorizedToActivateProposal();\nerror NotEnoughEndorsementsToActivateProposal();\nerror ProposalAlreadyActivated();\nerror ActiveProposalNotExpired();\nerror SubmittedProposalHasExpired();\n\n// voting\nerror NoActiveProposalDetected();\nerror UserAlreadyVoted();\n\n// executing\nerror NotEnoughVotesToExecute();\nerror ExecutionTimelockStillActive();\n\n// claiming\nerror VotingTokensAlreadyReclaimed();\nerror CannotReclaimTokensForActiveVote();\nerror CannotReclaimZeroVotes();\n\nstruct ProposalMetadata {\n    bytes32 title;\n    address submitter;\n    uint256 submissionTimestamp;\n    string proposalURI;\n}\n\nstruct ActivatedProposal {\n    uint256 proposalId;\n    uint256 activationTimestamp;\n}\n\n/// @notice OlympusGovernance\n/// @dev The Governor Policy is also the Kernel's Executor.\ncontract OlympusGovernance is Policy {\n    /////////////////////////////////////////////////////////////////////////////////\n    //                         Kernel Policy Configuration                         //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    OlympusInstructions public INSTR;\n    OlympusVotes public VOTES;\n\n    constructor(Kernel kernel_) Policy(kernel_) {}\n\n    function configureDependencies() external override returns (Keycode[] memory dependencies) {\n        dependencies = new Keycode[](2);\n        dependencies[0] = toKeycode(\"INSTR\");\n        dependencies[1] = toKeycode(\"VOTES\");\n\n        INSTR = OlympusInstructions(getModuleAddress(dependencies[0]));\n        VOTES = OlympusVotes(getModuleAddress(dependencies[1]));\n    }\n\n    function requestPermissions()\n        external\n        view\n        override\n        onlyKernel\n        returns (Permissions[] memory requests)\n    {\n        requests = new Permissions[](2);\n        requests[0] = Permissions(INSTR.KEYCODE(), INSTR.store.selector);\n        requests[1] = Permissions(VOTES.KEYCODE(), VOTES.transferFrom.selector);\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                             Policy Variables                                //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    event ProposalSubmitted(uint256 proposalId);\n    event ProposalEndorsed(uint256 proposalId, address voter, uint256 amount);\n    event ProposalActivated(uint256 proposalId, uint256 timestamp);\n    event WalletVoted(uint256 proposalId, address voter, bool for_, uint256 userVotes);\n    event ProposalExecuted(uint256 proposalId);\n\n    /// @notice The currently activated proposal in the governance system.\n    ActivatedProposal public activeProposal;\n\n    /// @notice Return a proposal metadata object for a given proposal id.\n    mapping(uint256 => ProposalMetadata) public getProposalMetadata;\n\n    /// @notice Return the total endorsements for a proposal id.\n    mapping(uint256 => uint256) public totalEndorsementsForProposal;\n\n    /// @notice Return the number of endorsements a user has given a proposal id.\n    mapping(uint256 => mapping(address => uint256)) public userEndorsementsForProposal;\n\n    /// @notice Return whether a proposal id has been activated. Once this is true, it should never be flipped false.\n    mapping(uint256 => bool) public proposalHasBeenActivated;\n\n    /// @notice Return the total yes votes for a proposal id used in calculating net votes.\n    mapping(uint256 => uint256) public yesVotesForProposal;\n\n    /// @notice Return the total no votes for a proposal id used in calculating net votes.\n    mapping(uint256 => uint256) public noVotesForProposal;\n\n    /// @notice Return the amount of votes a user has applied to a proposal id. This does not record how the user voted.\n    mapping(uint256 => mapping(address => uint256)) public userVotesForProposal;\n\n    /// @notice Return the amount of tokens reclaimed by a user after voting on a proposal id.\n    mapping(uint256 => mapping(address => bool)) public tokenClaimsForProposal;\n\n    /// @notice The amount of votes a proposer needs in order to submit a proposal as a percentage of total supply (in basis points).\n    /// @dev    This is set to 1% of the total supply.\n    uint256 public constant SUBMISSION_REQUIREMENT = 100;\n\n    /// @notice Amount of time a submitted proposal has to activate before it expires.\n    uint256 public constant ACTIVATION_DEADLINE = 2 weeks;\n\n    /// @notice Amount of time an activated proposal must stay up before it can be replaced by a new activated proposal.\n    uint256 public constant GRACE_PERIOD = 1 weeks;\n\n    /// @notice Endorsements required to activate a proposal as percentage of total supply.\n    uint256 public constant ENDORSEMENT_THRESHOLD = 20;\n\n    /// @notice Net votes required to execute a proposal on chain as a percentage of total supply.\n    uint256 public constant EXECUTION_THRESHOLD = 33;\n\n    /// @notice Required time for a proposal to be active before it can be executed.\n    /// @dev    This amount should be greater than 0 to prevent flash loan attacks.\n    uint256 public constant EXECUTION_TIMELOCK = 3 days;\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                               User Actions                                  //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Return the metadata for a proposal.\n    /// @dev    Used to return & access the entire metadata struct in solidity\n    function getMetadata(uint256 proposalId_) public view returns (ProposalMetadata memory) {\n        return getProposalMetadata[proposalId_];\n    }\n\n    /// @notice Return the currently active proposal in governance.\n    /// @dev    Used to return & access the entire struct active proposal struct in solidity.\n    function getActiveProposal() public view returns (ActivatedProposal memory) {\n        return activeProposal;\n    }\n\n    /// @notice Submit an on chain governance proposal.\n    /// @param  instructions_ - an array of Instruction objects each containing a Kernel Action and a target Contract address.\n    /// @param  title_ - a human-readable title of the proposal — i.e. \"OIP XX - My Proposal Title\".\n    /// @param  proposalURI_ - an arbitrary url linking to a human-readable description of the proposal - i.e. Snapshot, Discourse, Google Doc.\n    function submitProposal(\n        Instruction[] calldata instructions_,\n        bytes32 title_,\n        string memory proposalURI_\n    ) external {\n        if (VOTES.balanceOf(msg.sender) * 10000 < VOTES.totalSupply() * SUBMISSION_REQUIREMENT)\n            revert NotEnoughVotesToPropose();\n\n        uint256 proposalId = INSTR.store(instructions_);\n        getProposalMetadata[proposalId] = ProposalMetadata(\n            title_,\n            msg.sender,\n            block.timestamp,\n            proposalURI_\n        );\n\n        emit ProposalSubmitted(proposalId);\n    }\n\n    /// @notice Endorse a proposal.\n    /// @param  proposalId_ - The ID of the proposal being endorsed.\n    function endorseProposal(uint256 proposalId_) external {\n        uint256 userVotes = VOTES.balanceOf(msg.sender);\n\n        if (proposalId_ == 0) {\n            revert CannotEndorseNullProposal();\n        }\n\n        Instruction[] memory instructions = INSTR.getInstructions(proposalId_);\n        if (instructions.length == 0) {\n            revert CannotEndorseInvalidProposal();\n        }\n\n        // undo any previous endorsement the user made on these instructions\n        uint256 previousEndorsement = userEndorsementsForProposal[proposalId_][msg.sender];\n        totalEndorsementsForProposal[proposalId_] -= previousEndorsement;\n\n        // reapply user endorsements with most up-to-date votes\n        userEndorsementsForProposal[proposalId_][msg.sender] = userVotes;\n        totalEndorsementsForProposal[proposalId_] += userVotes;\n\n        emit ProposalEndorsed(proposalId_, msg.sender, userVotes);\n    }\n\n    /// @notice Activate a proposal.\n    /// @param  proposalId_ - The ID of the proposal being activated.\n    function activateProposal(uint256 proposalId_) external {\n        ProposalMetadata memory proposal = getProposalMetadata[proposalId_];\n\n        if (msg.sender != proposal.submitter) {\n            revert NotAuthorizedToActivateProposal();\n        }\n\n        if (block.timestamp > proposal.submissionTimestamp + ACTIVATION_DEADLINE) {\n            revert SubmittedProposalHasExpired();\n        }\n\n        if (\n            (totalEndorsementsForProposal[proposalId_] * 100) <\n            VOTES.totalSupply() * ENDORSEMENT_THRESHOLD\n        ) {\n            revert NotEnoughEndorsementsToActivateProposal();\n        }\n\n        if (proposalHasBeenActivated[proposalId_] == true) {\n            revert ProposalAlreadyActivated();\n        }\n\n        if (block.timestamp < activeProposal.activationTimestamp + GRACE_PERIOD) {\n            revert ActiveProposalNotExpired();\n        }\n\n        activeProposal = ActivatedProposal(proposalId_, block.timestamp);\n\n        proposalHasBeenActivated[proposalId_] = true;\n\n        emit ProposalActivated(proposalId_, block.timestamp);\n    }\n\n    /// @notice Cast a vote for the currently active proposal.\n    /// @param  for_ - A boolean representing the vote: true for yes, false for no.\n    function vote(bool for_) external {\n        uint256 userVotes = VOTES.balanceOf(msg.sender);\n\n        if (activeProposal.proposalId == 0) {\n            revert NoActiveProposalDetected();\n        }\n\n        if (userVotesForProposal[activeProposal.proposalId][msg.sender] > 0) {\n            revert UserAlreadyVoted();\n        }\n\n        if (for_) {\n            yesVotesForProposal[activeProposal.proposalId] += userVotes;\n        } else {\n            noVotesForProposal[activeProposal.proposalId] += userVotes;\n        }\n\n        userVotesForProposal[activeProposal.proposalId][msg.sender] = userVotes;\n\n        VOTES.transferFrom(msg.sender, address(this), userVotes);\n\n        emit WalletVoted(activeProposal.proposalId, msg.sender, for_, userVotes);\n    }\n\n    /// @notice Execute the currently active proposal.\n    function executeProposal() external {\n        uint256 netVotes = yesVotesForProposal[activeProposal.proposalId] -\n            noVotesForProposal[activeProposal.proposalId];\n        if (netVotes * 100 < VOTES.totalSupply() * EXECUTION_THRESHOLD) {\n            revert NotEnoughVotesToExecute();\n        }\n\n        if (block.timestamp < activeProposal.activationTimestamp + EXECUTION_TIMELOCK) {\n            revert ExecutionTimelockStillActive();\n        }\n\n        Instruction[] memory instructions = INSTR.getInstructions(activeProposal.proposalId);\n\n        for (uint256 step; step < instructions.length; ) {\n            kernel.executeAction(instructions[step].action, instructions[step].target);\n            unchecked {\n                ++step;\n            }\n        }\n\n        emit ProposalExecuted(activeProposal.proposalId);\n\n        // deactivate the active proposal\n        activeProposal = ActivatedProposal(0, 0);\n    }\n\n    /// @notice Reclaim locked votes from the contract after the proposal is no longer active.\n    /// @dev    The governance contract locks casted votes into the contract until the proposal\n    ///         is no longer active to prevent repeated voting with the same tokens.\n    /// @param  proposalId_ - The proposal that the user is reclaiming tokens for.\n    function reclaimVotes(uint256 proposalId_) external {\n        uint256 userVotes = userVotesForProposal[proposalId_][msg.sender];\n\n        if (userVotes == 0) {\n            revert CannotReclaimZeroVotes();\n        }\n\n        if (proposalId_ == activeProposal.proposalId) {\n            revert CannotReclaimTokensForActiveVote();\n        }\n\n        if (tokenClaimsForProposal[proposalId_][msg.sender] == true) {\n            revert VotingTokensAlreadyReclaimed();\n        }\n\n        tokenClaimsForProposal[proposalId_][msg.sender] = true;\n\n        VOTES.transferFrom(address(this), msg.sender, userVotes);\n    }\n}"
    },
    {
      "filename": "src/policies/VoterRegistration.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {OlympusVotes} from \"modules/VOTES.sol\";\nimport \"src/Kernel.sol\";\n\n/// @notice Policy to mint and burn votes to arbitrary addresses\n/// @dev A policy to distribute votes for OlympusGovernance\ncontract VoterRegistration is Policy {\n    OlympusVotes public VOTES;\n\n    /*//////////////////////////////////////////////////////////////\n                            POLICY INTERFACE\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(Kernel kernel_) Policy(kernel_) {}\n\n    /// @inheritdoc Policy\n    function configureDependencies() external override returns (Keycode[] memory dependencies) {\n        dependencies = new Keycode[](1);\n        dependencies[0] = toKeycode(\"VOTES\");\n\n        VOTES = OlympusVotes(getModuleAddress(dependencies[0]));\n    }\n\n    /// @inheritdoc Policy\n    function requestPermissions()\n        external\n        view\n        override\n        returns (Permissions[] memory permissions)\n    {\n        permissions = new Permissions[](2);\n        permissions[0] = Permissions(VOTES.KEYCODE(), VOTES.mintTo.selector);\n        permissions[1] = Permissions(VOTES.KEYCODE(), VOTES.burnFrom.selector);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CORE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Issue votes to a wallet\n    /// @param  wallet_ - The address receiving the votes.\n    /// @param  amount_ - The amount of votes to mint to the wallet.\n    function issueVotesTo(address wallet_, uint256 amount_) external onlyRole(\"voter_admin\") {\n        // Issue the votes in the VOTES module\n        VOTES.mintTo(wallet_, amount_);\n    }\n\n    /// @notice Burn votes from a wallet\n    /// @param  wallet_ - The address losing the votes.\n    /// @param  amount_ - The amount of votes to burn from the wallet.\n    function revokeVotesFrom(address wallet_, uint256 amount_) external onlyRole(\"voter_admin\") {\n        // Revoke the votes in the VOTES module\n        VOTES.burnFrom(wallet_, amount_);\n    }\n}"
    },
    {
      "filename": "src/policies/VoterRegistration.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {OlympusVotes} from \"modules/VOTES.sol\";\nimport \"src/Kernel.sol\";\n\n/// @notice Policy to mint and burn votes to arbitrary addresses\n/// @dev A policy to distribute votes for OlympusGovernance\ncontract VoterRegistration is Policy {\n    OlympusVotes public VOTES;\n\n    /*//////////////////////////////////////////////////////////////\n                            POLICY INTERFACE\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(Kernel kernel_) Policy(kernel_) {}\n\n    /// @inheritdoc Policy\n    function configureDependencies() external override returns (Keycode[] memory dependencies) {\n        dependencies = new Keycode[](1);\n        dependencies[0] = toKeycode(\"VOTES\");\n\n        VOTES = OlympusVotes(getModuleAddress(dependencies[0]));\n    }\n\n    /// @inheritdoc Policy\n    function requestPermissions()\n        external\n        view\n        override\n        returns (Permissions[] memory permissions)\n    {\n        permissions = new Permissions[](2);\n        permissions[0] = Permissions(VOTES.KEYCODE(), VOTES.mintTo.selector);\n        permissions[1] = Permissions(VOTES.KEYCODE(), VOTES.burnFrom.selector);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CORE LOGIC\n    ////////////////////////////"
    }
  ]
}