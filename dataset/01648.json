{
  "Title": "M-6: parseAllPrice not support the tokens whose decimal is greater than 18",
  "Content": "# Issue M-6: parseAllPrice not support the tokens whose decimal is greater than 18 \n\nSource: https://github.com/sherlock-audit/2023-06-dodo-judging/issues/154 \n\n## Found by \nkutugu\n## Summary\n\n`parseAllPrice` not support the token decimal is greater than 18, such as NEAR with 24 decimal.\nSince `buyToken / sellToken` is dependent on `parseAllPrice`, so users can't trade tokens larger than 18 decimal, but DODOv3 is intended to be compatible with all standard ERC20, which is not expected.\n\n## Vulnerability Detail\n\n```solidity\n        // fix price decimal\n        if (tokenDecimal != 18) {\n            uint256 fixDecimal = 18 - tokenDecimal;\n            bidDownPrice = bidDownPrice / (10 ** fixDecimal);\n            bidUpPrice = bidUpPrice / (10 ** fixDecimal);\n            askDownPrice = askDownPrice * (10 ** fixDecimal);\n            askUpPrice = askUpPrice * (10 ** fixDecimal);\n        }\n```\n\nIf `tokenDecimal > 18`, `18 - tokenDecimal` will revert\n\n## Impact\n\nDODOv3 is not compatible the tokens whose decimal is greater than 18, users can't trade them.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-06-dodo/blob/a8d30e611acc9762029f8756d6a5b81825faf348/new-dodo-v3/contracts/DODOV3MM/lib/MakerTypes.sol#L99-L106\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nFix decimal to 36 instead of 18\n\n\n\n\n\n## Discussion\n\n**traceurl**\n\nfixed in https://github.com/DODOEX/new-dodo-v3/pull/32\nnow use parseRealAmount() in Types.sol to deal with token whose decimals is not 18\n\n**KuTuGu**\n\nEscalate\nThere are two questions:\n1. This issue does not seem to be the repeat of the other two issues, they refer to overflows where the sum of two oracle token decimals is greater than 36, while this issue targets overflows where a single token decimal is greater than 18\n2. Sponsor indicates that it is mainly for chainlink tokens, and there are tokens greater than 18 decimals on the main network: NEAR: 24 decimals, address: https://etherscan.io/token/0x85f17cf997934a597031b2e18a9ab6ebd4b9f6a4, oracle: https://etherscan.io/address/0xC12A6d1D827e23318266Ef16Ba6F397F2F91dA9b\n\n \n\n**sherlock-admin2**\n\n > Escalate\n> There are two questions:\n> 1. This issue does not seem to be the repeat of the other two issues, they refer to overflows where the sum of two oracle token decimals is greater than 36, while this issue targets overflows where a single token decimal is greater than 18\n> 2. Sponsor indicates that it is mainly for chainlink tokens, and there are tokens greater than 18 decimals on the main network: NEAR: 24 decimals, address: https://etherscan.io/token/0x85f17cf997934a597031b2e18a9ab6ebd4b9f6a4, oracle: https://etherscan.io/address/0xC12A6d1D827e23318266Ef16Ba6F397F2F91dA9b\n> \n>  \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**maarcweiss**\n\nI agree with escalation. As > 18 decimals tokens are more than just one specific non standard erc20, and the likelihood is higher, I would agree with a medium\n\n**hrishibhat**\n\nResult:\nMedium\nUnique\nConsidering this a valid medium \n\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [kutugu](https://github.com/sherlock-audit/2023-06-dodo-judging/issues/154/#issuecomment-1647792286): accepted\n\n**traceurl**\n\nWe will not support tokens whose decimals are greater than 18, like NEAR. We use D3Oracle to whitelist tokens. Even if a token has chainlink price feed, if it's decimals are greater than 18, we will not add it to D3Oracle. \n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/89",
  "Code": [
    {
      "filename": "new-dodo-v3/contracts/DODOV3MM/lib/MakerTypes.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.16;\n\nimport {DecimalMath} from \"./DecimalMath.sol\";\n\nlibrary MakerTypes {\n    struct MakerState {\n        HeartBeat heartBeat;\n        // price list to package prices in one slot\n        PriceListInfo priceListInfo;\n        // =============== Swap Storage =================\n        mapping(address => TokenMMInfoWithoutCum) tokenMMInfoMap;\n    }\n\n    struct TokenMMInfoWithoutCum {\n        // [mid price(16) | mid price decimal(8) | fee rate(16) | ask up rate (16) | bid down rate(16)]\n        // midprice unit is 1e18\n        // all rate unit is 10000\n        uint80 priceInfo;\n        // [ask amounts(16) | ask amounts decimal(8) | bid amounts(16) | bid amounts decimal(8) ]\n        uint64 amountInfo;\n        // k is [0, 10000]\n        uint16 kAsk;\n        uint16 kBid;\n        uint8 decimal;\n        uint8 tokenIndex;\n    }\n\n    // package three token price in one slot\n    struct PriceListInfo {\n        // to avoid reset the same token, tokenIndexMap record index from 1, but actualIndex = tokenIndex[address] - 1\n        // odd for none-stable, even for stable,  true index = actualIndex / 2 = (tokenIndex[address] - 1) / 2\n        mapping(address => uint256) tokenIndexMap;\n        uint256 numberOfNS; // quantity of not stable token\n        uint256 numberOfStable; // quantity of stable token\n        // [mid price(16) | mid price decimal(8) | fee rate(16) | ask up rate (16) | bid down rate(16)] = 72 bit\n        // one slot contain = 72 * 3, 3 token price\n        // [2 | 1 | 0]\n        uint256[] tokenPriceNS; // not stable token price\n        uint256[] tokenPriceStable; // stable token price\n    }\n\n    struct HeartBeat {\n        uint256 lastHeartBeat;\n        uint256 maxInterval;\n    }\n\n    uint16 internal constant ONE_PRICE_BIT = 72;\n    uint256 internal constant PRICE_QUANTITY_IN_ONE_SLOT = 3;\n    uint16 internal constant ONE_AMOUNT_BIT = 24;\n    uint256 internal constant ONE = 10 ** 18;\n\n    // [ask amounts(16) | ask amounts decimal(8) | bid amounts(16) | bid amounts decimal(8) ]\n    function parseAskAmount(uint64 amountInfo) internal pure returns (uint256 amountWithDecimal) {\n        uint256 askAmount = (amountInfo >> (ONE_AMOUNT_BIT + 8)) & 0xffff;\n        uint256 askAmountDecimal = (amountInfo >> ONE_AMOUNT_BIT) & 255;\n        amountWithDecimal = askAmount * (10 ** askAmountDecimal);\n    }\n\n    // [ask amounts(16) | ask amounts decimal(8) | bid amounts(16) | bid amounts decimal(8) ]\n    function parseBidAmount(uint64 amountInfo) internal pure returns (uint256 amountWithDecimal) {\n        uint256 bidAmount = (amountInfo >> 8) & 0xffff;\n        uint256 bidAmountDecimal = amountInfo & 255;\n        amountWithDecimal = bidAmount * (10 ** bidAmountDecimal);\n    }\n\n    function parseAllPrice(uint80 priceInfo, uint256 tokenDecimal, uint256 mtFeeRate)\n        internal\n        pure\n        returns (uint256 askUpPrice, uint256 askDownPrice, uint256 bidUpPrice, uint256 bidDownPrice, uint256 swapFee)\n    {\n        {\n        uint256 midPrice = (priceInfo >> 56) & 0xffff;\n        uint256 midPriceDecimal = (priceInfo >> 48) & 255;\n        uint256 midPriceWithDecimal = midPrice * (10 ** midPriceDecimal);\n\n        uint256 swapFeeRate = (priceInfo >> 32) & 0xffff;\n        uint256 askUpRate = (priceInfo >> 16) & 0xffff;\n        uint256 bidDownRate = priceInfo & 0xffff;\n\n        // swap fee rate standarlize\n        swapFee = swapFeeRate * (10 ** 14) + mtFeeRate;\n        uint256 swapFeeSpread = DecimalMath.mul(midPriceWithDecimal, swapFee);\n\n        // ask price standarlize\n        askDownPrice = midPriceWithDecimal + swapFeeSpread;\n        askUpPrice = midPriceWithDecimal + midPriceWithDecimal * askUpRate / (10 ** 4);\n        require(askDownPrice <= askUpPrice, \"ask price invalid\");\n\n        // bid price standarlize\n        uint reversalBidUp = midPriceWithDecimal - swapFeeSpread;\n        uint reversalBidDown = midPriceWithDecimal - midPriceWithDecimal * bidDownRate / (10 ** 4);\n        require(reversalBidDown <= reversalBidUp, \"bid price invalid\");\n        bidDownPrice = DecimalMath.reciprocalCeil(reversalBidUp);\n        bidUpPrice = DecimalMath.reciprocalCeil(reversalBidDown);\n        }\n\n        // fix price decimal\n        if (tokenDecimal != 18) {\n            uint256 fixDecimal = 18 - tokenDecimal;\n            bidDownPrice = bidDownPrice / (10 ** fixDecimal);\n            bidUpPrice = bidUpPrice / (10 ** fixDecimal);\n            askDownPrice = askDownPrice * (10 ** fixDecimal);\n            askUpPrice = askUpPrice * (10 ** fixDecimal);\n        }\n    }\n\n    function parseK(uint16 originK) internal pure returns (uint256) {\n        return uint256(originK) * (10 ** 14);\n    }\n}"
    }
  ]
}