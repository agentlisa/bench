{
  "Title": "[M-10] Change of `fundingDuration` causes \"time travel\" of `PerpetualAtlanticVault.nextFundingPaymentTimestamp()`",
  "Content": "\nThe return value of [PerpetualAtlanticVault.nextFundingPaymentTimestamp()](https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/perp-vault/PerpetualAtlanticVault.sol#L562-L569), which marks the beginning of the next funding epoch, scales linearly with the current `fundingDuration`. (Note that `latestFundingPaymentPointer` is strictly monotonically increasing with each epoch.)\\\nTherefore, epochs are separated by a period of `fundingDuration`.\n\n```solidity\n  function nextFundingPaymentTimestamp()\n    public\n    view\n    returns (uint256 timestamp)\n  {\n    return genesis + (latestFundingPaymentPointer * fundingDuration);\n  }\n```\n\nHowever, the owner can change the `fundingDuration` at any time via [PerpetualAtlanticVault.updateFundingDuration(...)](https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/perp-vault/PerpetualAtlanticVault.sol#L233-L241) which is an **intended feature** of the contract, otherwise the funding duration would be **immutable**.\n\n### First order consequences\n\nAssume the owner changes the `fundingDuration` by a value `delta`, such that: `new fundingDuration = old fundingDuration + delta`.\nAs a result, the return value of [PerpetualAtlanticVault.nextFundingPaymentTimestamp()](https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/perp-vault/PerpetualAtlanticVault.sol#L562-L569) moves by a value of `latestFundingPaymentPointer  * delta` into the **future** or **past** (depending on the sign of `delta`).\n\n*Numerical example:*\nThe `fundingDuration = 7 days` and is slightly reduced by `delta = -1 hour`.\\\nThe protocol is alread live for nearly 2 years, therefore `latestFundingPaymentPointer = 96`.\\\nConsequently, the next funding epoch \"begins\" `latestFundingPaymentPointer  * delta = -96 hours = -4 days` in the **past**.\n\nThe [PerpetualAtlanticVault.nextFundingPaymentTimestamp()](https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/perp-vault/PerpetualAtlanticVault.sol#L562-L569) is called at **14 instances** throughout the `PerpetualAtlanticVault` contract and once by the `RdpxV2Core` contract for bonding cost calculation, see [RdpxV2Core.calculateBondCost(...)](https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/core/RdpxV2Core.sol#L1192-L1194).\n\n### Second order consequences\n\nDue the scattered impacts of the present bug, there arise multiple problems. Nevertheless, this report solely focuses on the following consquences in order to emphasize the severity of this issue.\n\n### [PerpetualAtlanticVault.updateFundingPaymentPointer()](https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/perp-vault/PerpetualAtlanticVault.sol#L461-L496)\n\nThis helper method is (implicitly) called by the `updateFunding()`, `purchase(...)`, `settle(...)` and `calculateFunding(...)` methods, but not by the `payFunding()` method of the contract.\\\nIt is responsible for iteratively bringing the `latestFundingPaymentPointer` into the present while funding the LP with collateral for each epoch.\n\nIn case of \"time travel\" by changing the `fundingDuration` it will do the following:\n\n*   `nextFundingPaymentTimestamp()` lies in the past: It will iterarte until `nextFundingPaymentTimestamp()` lies in the future, thereby **immediately** ending the current epoch and skipping the following ones, see PoC.\n*   `nextFundingPaymentTimestamp()` lies in the future: Once the overly long epoch `old fundingDuration + delta * latestFundingPaymentPointer` expires, it will **overpay** collateral for this epoch to the LP, see [L473-L477](https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/perp-vault/PerpetualAtlanticVault.sol#L473-L477).\n\n### [PerpetualAtlanticVault.purchase(...)](https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/perp-vault/PerpetualAtlanticVault.sol#L254-L312)\n\nThis method is called by the core contract when bonding in order to buy options. Thereby the option premium is heavily dependent on the return value of `nextFundingPaymentTimestamp()`, see [L283-L286](https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/perp-vault/PerpetualAtlanticVault.sol#L283-L286).\n\nIn case of an overly long epoch `old fundingDuration + delta * latestFundingPaymentPointer` due to an increase of the `fundingDuration` by `delta`, the option premium is excessively increased leading to a loss of funds for the user/protocol by using up a great part of the reserve WETH for the option, see core contract [L918-L924](https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/core/RdpxV2Core.sol#L918-L924) and PoC.\\\nSubsequently the bonding gets more expensive, i.e. the user has to supply more WETH, see also [RdpxV2Core.calculateBondCost(...)](https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/core/RdpxV2Core.sol#L1192-L1198).\n\nFor reference, the correct epoch duration in this case should be `old fundingDuration + delta`.\\\nThe affected entry point methods are [RdpxV2Core.bond(...)](https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/core/RdpxV2Core.sol#L887-L933) and [RdpxV2Core.bondWithDelegate(...)](https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/core/RdpxV2Core.sol#L810-L885).\\\nThis is also time critical in another way, since the user cannot know if the `fundingDuration` was changed **after** calculating the bonding cost via [RdpxV2Core.calculateBondCost(...)](https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/core/RdpxV2Core.sol#L1192-L1198), but **before** his bonding transaction.\n\n### Conclusion\n\nThe resulting funding period / epoch inconsistencies by jumping in time, as well as the execessivley overpriced options, which do lead to loss of funds when bought during that epoch, are sufficient to strongly disincentivize users from bonding. This consequently endagers the peg which can be considered the most valuable asset of the protocol.\n\nFuthermore, the user cannot know if the `fundingDuration` was changed before his transaction is executed which poses an additional risk.\n\n### Proof of Concept\n\nIn order to prove the above claims, three new test cases were added. The last assertion in each of those cases fails in order to demonstrate the issues.\n\n*   `testUpdateFundingPaymentPointerPast()`: The return value of `nextFundingPaymentTimestamp()` lies in the past and multiple epochs are skipped on `updateFundingPaymentPointer()`.\n*   `testUpdateFundingPaymentPointerPast()`: The return value of `nextFundingPaymentTimestamp()` lies in the future, therefore the current epoch is overly long and won't change on `updateFundingPaymentPointer()` after waiting for `new fundingDuration`.\n*   `testPurchaseExtendedEpoch()`: Shows the excessive increase in option premium on a slight increase of `fundingDuration`, i.e. unjustified overuse/loss of funds.\n\nJust apply the *diff* below and run the test cases with `forge test -vv --match-test testUpdateFundingPaymentPointer` and `forge test -vv --match-test testPurchaseExtendedEpoch`:\n\n<details>\n\n```diff\ndiff --git a/contracts/mocks/MockOptionPricing.sol b/contracts/mocks/MockOptionPricing.sol\nindex 5b77b16..c8e92f1 100644\n--- a/contracts/mocks/MockOptionPricing.sol\n+++ b/contracts/mocks/MockOptionPricing.sol\n@@ -8,8 +8,8 @@ contract MockOptionPricing is IOptionPricing {\n     uint256,\n     uint256,\n     uint256,\n-    uint256\n+    uint256 timeToExpiry\n   ) external pure override returns (uint256) {\n-    return 5e6; // 0.05 weth\n+    return 5e6 * timeToExpiry / 1 days; // 0.05 weth\n   }\n }\ndiff --git a/tests/perp-vault/Unit.t.sol b/tests/perp-vault/Unit.t.sol\nindex c8016e0..dcfd72a 100644\n--- a/tests/perp-vault/Unit.t.sol\n+++ b/tests/perp-vault/Unit.t.sol\n@@ -108,6 +108,33 @@ contract Unit is ERC721Holder, Setup {\n     vault.purchase(300 ether, address(this));\n   }\n \n+  function testPurchaseExtendedEpoch() external {\n+    testDeposit();\n+\n+    skip(vault.fundingDuration() * 10); // expire 10 epochs\n+    vault.updateFundingPaymentPointer();\n+\n+    uint256 timeTillExpiry = vault.nextFundingPaymentTimestamp() -\n+      block.timestamp;\n+\n+    // uses calculates expected option premium\n+    uint256 expectedPremium = vault.calculatePremium(\n+      0.015 gwei,\n+      500 ether,\n+      timeTillExpiry,\n+      0.02 gwei\n+    );\n+    \n+    // owner happends to extend funding duration --> severely increases option premium\n+    vault.updateFundingDuration(vault.fundingDuration() + 1 hours);  // comment this line to see test case pass\n+\n+    // user doesn't know about the bug and funding duration change --> overpays for option\n+    (uint256 paidPremium, ) = vault.purchase(500 ether, address(this));\n+\n+    assertEq(paidPremium, expectedPremium);\n+  }\n+\n+\n   function testCalculatePremium() external {\n     uint256 pnl = vault.calculatePnl(0.01 gwei, 0.015 gwei, 1 ether);\n     assertEq(pnl, 0.05 ether);\n@@ -291,6 +318,47 @@ contract Unit is ERC721Holder, Setup {\n     assertEq(pointer, 2);\n   }\n \n+  function testUpdateFundingPaymentPointerPast() external {\n+    uint256 pointer = vault.latestFundingPaymentPointer();\n+    assertEq(pointer, 0);\n+    skip(vault.fundingDuration()); // expire\n+    vault.updateFundingPaymentPointer();\n+    pointer = vault.latestFundingPaymentPointer();\n+    assertEq(pointer, 1);\n+\n+    skip(vault.fundingDuration()*95);\n+    purchaseOneOption(); // updates payment pointer if block.timestamp > nextFundingPaymentTimestamp\n+    pointer = vault.latestFundingPaymentPointer();\n+    assertEq(pointer, 96);\n+\n+    vault.updateFundingDuration(vault.fundingDuration() - 1 hours); // reduce funding duration by 1 hour\n+    skip(vault.fundingDuration()); // expire\n+    vault.updateFundingPaymentPointer();  // updates payment pointer if block.timestamp > nextFundingPaymentTimestamp\n+    pointer = vault.latestFundingPaymentPointer();\n+    assertEq(pointer, 97); // fails: we would expect 97 but actually skipped 4 epochs due to \"time traveling\"\n+  }\n+\n+  function testUpdateFundingPaymentPointerFuture() external {\n+    uint256 pointer = vault.latestFundingPaymentPointer();\n+    assertEq(pointer, 0);\n+    skip(vault.fundingDuration()); // expire\n+    vault.updateFundingPaymentPointer();\n+    pointer = vault.latestFundingPaymentPointer();\n+    assertEq(pointer, 1);\n+\n+    skip(vault.fundingDuration()*95);\n+    purchaseOneOption(); // updates payment pointer if block.timestamp > nextFundingPaymentTimestamp\n+    pointer = vault.latestFundingPaymentPointer();\n+    assertEq(pointer, 96);\n+\n+    vault.updateFundingDuration(vault.fundingDuration() + 1 hours); // increase funding duration by 1 hour\n+    skip(vault.fundingDuration()); // expire\n+    vault.updateFundingPaymentPointer();  // updates payment pointer if block.timestamp > nextFundingPaymentTimestamp\n+    pointer = vault.latestFundingPaymentPointer();\n+    assertEq(pointer, 97); // fails: we would expect 97 but it's still 96 because the next epoch lies 4 days in the future\n+  }\n+\n+\n   function testMockups() external {\n     deposit(1 ether, address(this));\n     assertEq(vaultLp.totalCollateral(), 1 ether);\n\n```\n\n</details>\n\n### Recommended Mitigation Steps\n\nOption 1 - Complete Fix:\nReconsider if it is really necessary for the protocol to change the funding duration throughout its lifecycle. If no, declare the `fundingDuration` as `immutable`.\n\nOption 2 - Mitigation:\nStore the `lastFundingPaymentTimestamp` and incease it by `fundingDuration` in `updateFundingPaymentPointer()` on each new epoch to accomplish the expected timing behaviour.\\\nNote that the scaling issue does not only appear in [PerpetualAtlanticVault.nextFundingPaymentTimestamp()](https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/perp-vault/PerpetualAtlanticVault.sol#L562-L569), but also in [L426-427](https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/perp-vault/PerpetualAtlanticVault.sol#L426-L427).\n\n**[Alex the Entreprenerd (Judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-08-dopex-findings/issues/850#issuecomment-1772543256):**\n > Good discussion of consequences + POC.\n\n**[witherblock (Dopex) confirmed via duplicate issue 980](https://github.com/code-423n4/2023-08-dopex-findings/issues/980)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-08-dopex",
  "Code": [
    {
      "filename": "contracts/perp-vault/PerpetualAtlanticVault.sol",
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\n// Libraries\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n// Contracts\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { ERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { ERC721Enumerable } from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport { ERC721Burnable } from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol\";\nimport { ERC4626 } from \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\nimport { AccessControl } from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport { Counters } from \"@openzeppelin/contracts/utils/Counters.sol\";\nimport { IPerpetualAtlanticVaultLP } from \"./IPerpetualAtlanticVaultLP.sol\";\nimport { ContractWhitelist } from \"../helper/ContractWhitelist.sol\";\nimport { Pausable } from \"../helper/Pausable.sol\";\n\n// Interfaces\nimport { IPerpetualAtlanticVault } from \"./IPerpetualAtlanticVault.sol\";\nimport { IERC20WithBurn } from \"../interfaces/IERC20WithBurn.sol\";\nimport { IOptionPricing } from \"../interfaces/IOptionPricing.sol\";\nimport { IRdpxEthOracle } from \"../interfaces/IRdpxEthOracle.sol\";\nimport { IVolatilityOracle } from \"../interfaces/IVolatilityOracle.sol\";\n\n/// @title Contract to offer perpetual atlantic rDPX PUT options to the rdpxV2Core contract\n/// @dev Option tokens are in erc20 18 decimals & Strikes are in 1e8 precision\ncontract PerpetualAtlanticVault is\n  IPerpetualAtlanticVault,\n  ReentrancyGuard,\n  Pausable,\n  ERC721,\n  ERC721Enumerable,\n  ERC721Burnable,\n  AccessControl,\n  ContractWhitelist\n{\n  using SafeERC20 for IERC20WithBurn;\n  using Counters for Counters.Counter;\n\n  /// @dev Token ID counter for write positions\n  Counters.Counter private _tokenIdCounter;\n\n  /// @dev Manager role which handles bootstrapping\n  bytes32 public constant MANAGER_ROLE = keccak256(\"MANAGER_ROLE\");\n\n  /// @dev Rdpx v2 core role which can purchase and settle options\n  bytes32 public constant RDPXV2CORE_ROLE = keccak256(\"RDPXV2CORE_ROLE\");\n\n  /// @dev Underlying assets symbol\n  string public underlyingSymbol;\n\n  /// @dev Contract addresses\n  Addresses public addresses;\n\n  /// @dev Collateral Token\n  IERC20WithBurn public collateralToken;\n\n  /// @dev The precision of the collateral token\n  uint256 public collateralPrecision;\n\n  /// @dev tokenId => OptionPosition\n  mapping(uint256 => OptionPosition) public optionPositions;\n\n  /// @dev number of options funding has been accounted for the epoch\n  mapping(uint256 => uint256) public fundingPaymentsAccountedFor;\n\n  /// @dev the funding accounted for the epoch and strike\n  mapping(uint256 => mapping(uint256 => uint256))\n    public fundingPaymentsAccountedForPerStrike;\n\n  /// @dev the total funding for the epoch\n  mapping(uint256 => uint256) public totalFundingForEpoch;\n\n  /// @dev amount of options per strike\n  mapping(uint256 => uint256) public optionsPerStrike;\n\n  /// @dev latest funding update per strike\n  mapping(uint256 => uint256) public latestFundingPerStrike;\n\n  // @dev Funding rate for the epoch\n  mapping(uint256 => uint256) public fundingRates;\n\n  /// @dev the pointer to the lattest funding payment timestamp\n  /// @notice Explain to an end user what this does\n  /// @dev Explain to a developer any extra details\n  /// @return Documents the return variables of a contract’s function state variable\n  /// @inheritdoc\tIPerpetualAtlanticVault\n  uint256 public latestFundingPaymentPointer = 0;\n\n  /// @dev the total number of active options\n  uint256 public totalActiveOptions;\n\n  /// @dev genesis timestamp\n  uint256 public genesis;\n\n  /// @dev the timestamp of the last update where funding was paid for\n  uint256 public lastUpdateTime;\n\n  /// @dev the duration between funding payments\n  uint256 public fundingDuration = 7 days;\n\n  /// @dev the precision to round up to\n  uint256 public roundingPrecision = 1e6;\n\n  // ================================ CONSTRUCTOR ================================ //\n\n  /// @notice Contract constructor\n  /// @param _name ERC721 name\n  /// @param _symbol ERC721 symbol\n  /// @param _collateralToken Collateral token of the perpetual atlantic vault\n  /// @param _gensis Gensis time for funding calculation\n  constructor(\n    string memory _name,\n    string memory _symbol,\n    address _collateralToken,\n    uint256 _gensis\n  ) ERC721(_name, _symbol) {\n    _validate(_collateralToken != address(0), 1);\n\n    collateralToken = IERC20WithBurn(_collateralToken);\n    underlyingSymbol = collateralToken.symbol();\n    collateralPrecision = 10 ** collateralToken.decimals();\n    genesis = _gensis;\n\n    _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    _setupRole(MANAGER_ROLE, msg.sender);\n  }\n\n  // ================================ ADMIN FUNCTIONS ================================ //\n\n  /**\n   * @notice Pauses the vault for emergency cases\n   * @dev    Can only be called by the owner\n   **/\n  function pause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _pause();\n  }\n\n  /**\n   * @notice Unpauses the vault\n   * @dev    Can only be called by the owner\n   **/\n  function unpause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _unpause();\n  }\n\n  /**\n   * @notice Add a contract to the whitelist\n   * @dev    Can only be called by the owner\n   * @param  _contract Address of the contract that needs to be added to the whitelist\n   **/\n  function addToContractWhitelist(\n    address _contract\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _addToContractWhitelist(_contract);\n  }\n\n  /**\n   * @notice Remove a contract to the whitelist\n   * @dev    Can only be called by the owner\n   * @param  _contract Address of the contract that needs to be removed from the whitelist\n   **/\n  function removeFromContractWhitelist(\n    address _contract\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _removeFromContractWhitelist(_contract);\n  }\n\n  /**\n   * @notice Sets (adds) a list of addresses to the address list\n   * @dev    Can only be called by the owner\n   * @param  _optionPricing Address of the option pricing contract\n   * @param  _assetPriceOracle Address of the asset price oracle contract\n   * @param  _volatilityOracle Address of the volatility oracle contract\n   * @param  _feeDistributor Address of the fee distributor contract\n   * @param  _rdpx Address of the rdpx contract\n   * @param  _perpetualAtlanticVaultLP Address of the perpetual atlantic vault lp contract\n   * @param  _rdpxV2Core Address of the rdpx v2 rdpxV2Core contract\n   **/\n  function setAddresses(\n    address _optionPricing,\n    address _assetPriceOracle,\n    address _volatilityOracle,\n    address _feeDistributor,\n    address _rdpx,\n    address _perpetualAtlanticVaultLP,\n    address _rdpxV2Core\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _validate(_optionPricing != address(0), 1);\n    _validate(_assetPriceOracle != address(0), 1);\n    _validate(_volatilityOracle != address(0), 1);\n    _validate(_feeDistributor != address(0), 1);\n    _validate(_rdpx != address(0), 1);\n    _validate(_perpetualAtlanticVaultLP != address(0), 1);\n    _validate(_rdpxV2Core != address(0), 1);\n\n    addresses = Addresses({\n      optionPricing: _optionPricing,\n      assetPriceOracle: _assetPriceOracle,\n      volatilityOracle: _volatilityOracle,\n      feeDistributor: _feeDistributor,\n      rdpx: _rdpx,\n      perpetualAtlanticVaultLP: _perpetualAtlanticVaultLP,\n      rdpxV2Core: _rdpxV2Core\n    });\n    collateralToken.safeApprove(\n      addresses.perpetualAtlanticVaultLP,\n      type(uint256).max\n    );\n    emit AddressesSet(addresses);\n  }\n\n  /**\n   * @notice Transfers all funds to msg.sender\n   * @dev    Can only be called by the owner\n   * @param  tokens The list of erc20 tokens to withdraw\n   **/\n  function emergencyWithdraw(\n    address[] calldata tokens\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _whenPaused();\n    IERC20WithBurn token;\n\n    for (uint256 i = 0; i < tokens.length; i++) {\n      token = IERC20WithBurn(tokens[i]);\n      token.safeTransfer(msg.sender, token.balanceOf(address(this)));\n    }\n\n    emit EmergencyWithdraw(msg.sender, tokens);\n  }\n\n  /**\n   * @notice Updates the funding duration\n   * @dev    Can only be called by the owner\n   **/\n  function updateFundingDuration(\n    uint256 _fundingDuration\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    fundingDuration = _fundingDuration;\n  }\n\n  function setLpAllowance(bool increase) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    increase\n      ? collateralToken.approve(\n        addresses.perpetualAtlanticVaultLP,\n        type(uint256).max\n      )\n      : collateralToken.approve(addresses.perpetualAtlanticVaultLP, 0);\n  }\n\n  // ================================ TREASURY FUNCTIONS ================================ //\n\n  /// @inheritdoc\tIPerpetualAtlanticVault\n  function purchase(\n    uint256 amount,\n    address to\n  )\n    external\n    nonReentrant\n    onlyRole(RDPXV2CORE_ROLE)\n    returns (uint256 premium, uint256 tokenId)\n  {\n    _whenNotPaused();\n    _validate(amount > 0, 2);\n\n    updateFunding();\n\n    uint256 currentPrice = getUnderlyingPrice(); // price of underlying wrt collateralToken\n    uint256 strike = roundUp(currentPrice - (currentPrice / 4)); // 25% below the current price\n    IPerpetualAtlanticVaultLP perpetualAtlanticVaultLp = IPerpetualAtlanticVaultLP(\n        addresses.perpetualAtlanticVaultLP\n      );\n\n    // Check if vault has enough collateral to write the options\n    uint256 requiredCollateral = (amount * strike) / 1e8;\n\n    _validate(\n      requiredCollateral <= perpetualAtlanticVaultLp.totalAvailableCollateral(),\n      3\n    );\n\n    uint256 timeToExpiry = nextFundingPaymentTimestamp() - block.timestamp;\n\n    // Get total premium for all options being purchased\n    premium = calculatePremium(strike, amount, timeToExpiry, 0);\n\n    // Transfer premium from msg.sender to PerpetualAtlantics vault\n    collateralToken.safeTransferFrom(msg.sender, address(this), premium);\n\n    perpetualAtlanticVaultLp.lockCollateral(requiredCollateral);\n    _updateFundingRate(premium);\n\n    // Mint the option tokens\n    tokenId = _mintOptionToken();\n    optionPositions[tokenId] = OptionPosition({\n      strike: strike,\n      amount: amount,\n      positionId: tokenId\n    });\n\n    totalActiveOptions += amount;\n    fundingPaymentsAccountedFor[latestFundingPaymentPointer] += amount;\n    optionsPerStrike[strike] += amount;\n\n    // record the number of options funding has been accounted for the epoch and strike\n    fundingPaymentsAccountedForPerStrike[latestFundingPaymentPointer][\n      strike\n    ] += amount;\n\n    emit Purchase(strike, amount, premium, to, msg.sender);\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVault\n  function settle(\n    uint256[] memory optionIds\n  )\n    external\n    nonReentrant\n    onlyRole(RDPXV2CORE_ROLE)\n    returns (uint256 ethAmount, uint256 rdpxAmount)\n  {\n    _whenNotPaused();\n    _isEligibleSender();\n\n    updateFunding();\n\n    for (uint256 i = 0; i < optionIds.length; i++) {\n      uint256 strike = optionPositions[optionIds[i]].strike;\n      uint256 amount = optionPositions[optionIds[i]].amount;\n\n      // check if strike is ITM\n      _validate(strike >= getUnderlyingPrice(), 7);\n\n      ethAmount += (amount * strike) / 1e8;\n      rdpxAmount += amount;\n      optionsPerStrike[strike] -= amount;\n      totalActiveOptions -= amount;\n\n      // Burn option tokens from user\n      _burn(optionIds[i]);\n\n      optionPositions[optionIds[i]].strike = 0;\n    }\n\n    // Transfer collateral token from perpetual vault to rdpx rdpxV2Core\n    collateralToken.safeTransferFrom(\n      addresses.perpetualAtlanticVaultLP,\n      addresses.rdpxV2Core,\n      ethAmount\n    );\n    // Transfer rdpx from rdpx rdpxV2Core to perpetual vault\n    IERC20WithBurn(addresses.rdpx).safeTransferFrom(\n      addresses.rdpxV2Core,\n      addresses.perpetualAtlanticVaultLP,\n      rdpxAmount\n    );\n\n    IPerpetualAtlanticVaultLP(addresses.perpetualAtlanticVaultLP).subtractLoss(\n      ethAmount\n    );\n    IPerpetualAtlanticVaultLP(addresses.perpetualAtlanticVaultLP)\n      .unlockLiquidity(ethAmount);\n    IPerpetualAtlanticVaultLP(addresses.perpetualAtlanticVaultLP).addRdpx(\n      rdpxAmount\n    );\n\n    emit Settle(ethAmount, rdpxAmount, optionIds);\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVault\n  function payFunding() external onlyRole(RDPXV2CORE_ROLE) returns (uint256) {\n    _whenNotPaused();\n    _isEligibleSender();\n\n    _validate(\n      totalActiveOptions ==\n        fundingPaymentsAccountedFor[latestFundingPaymentPointer],\n      6\n    );\n\n    collateralToken.safeTransferFrom(\n      addresses.rdpxV2Core,\n      address(this),\n      totalFundingForEpoch[latestFundingPaymentPointer]\n    );\n    _updateFundingRate(totalFundingForEpoch[latestFundingPaymentPointer]);\n\n    emit PayFunding(\n      msg.sender,\n      totalFundingForEpoch[latestFundingPaymentPointer],\n      latestFundingPaymentPointer\n    );\n\n    return (totalFundingForEpoch[latestFundingPaymentPointer]);\n  }\n\n  // ================================ PUBLIC/EXTERNAL FUNCTIONS ================================ //\n\n  /**\n   * @notice Function to calculate the funding of options for the next epoch\n   * @param  strikes array of strikes to calculate the funding for\n   * @return fundingAmount the funding of options\n   **/\n  function calculateFunding(\n    uint256[] memory strikes\n  ) external nonReentrant returns (uint256 fundingAmount) {\n    _whenNotPaused();\n    _isEligibleSender();\n\n    updateFundingPaymentPointer();\n\n    for (uint256 i = 0; i < strikes.length; i++) {\n      _validate(optionsPerStrike[strikes[i]] > 0, 4);\n      _validate(\n        latestFundingPerStrike[strikes[i]] != latestFundingPaymentPointer,\n        5\n      );\n      uint256 strike = strikes[i];\n\n      uint256 amount = optionsPerStrike[strike] -\n        fundingPaymentsAccountedForPerStrike[latestFundingPaymentPointer][\n          strike\n        ];\n\n      uint256 timeToExpiry = nextFundingPaymentTimestamp() -\n        (genesis + ((latestFundingPaymentPointer - 1) * fundingDuration));\n\n      uint256 premium = calculatePremium(\n        strike,\n        amount,\n        timeToExpiry,\n        getUnderlyingPrice()\n      );\n\n      latestFundingPerStrike[strike] = latestFundingPaymentPointer;\n      fundingAmount += premium;\n\n      // Record number of options that funding payments were accounted for, for this epoch\n      fundingPaymentsAccountedFor[latestFundingPaymentPointer] += amount;\n\n      // record the number of options funding has been accounted for the epoch and strike\n      fundingPaymentsAccountedForPerStrike[latestFundingPaymentPointer][\n        strike\n      ] += amount;\n\n      // Record total funding for this epoch\n      // This does not need to be done in purchase() since it's already accounted for using `addProceeds()`\n      totalFundingForEpoch[latestFundingPaymentPointer] += premium;\n\n      emit CalculateFunding(\n        msg.sender,\n        amount,\n        strike,\n        premium,\n        latestFundingPaymentPointer\n      );\n    }\n  }\n\n  /// @dev Helper function that updates the latest funding payment pointer based on current timestamp\n  function updateFundingPaymentPointer() public {\n    while (block.timestamp >= nextFundingPaymentTimestamp()) {\n      if (lastUpdateTime < nextFundingPaymentTimestamp()) {\n        uint256 currentFundingRate = fundingRates[latestFundingPaymentPointer];\n\n        uint256 startTime = lastUpdateTime == 0\n          ? (nextFundingPaymentTimestamp() - fundingDuration)\n          : lastUpdateTime;\n\n        lastUpdateTime = nextFundingPaymentTimestamp();\n\n        collateralToken.safeTransfer(\n          addresses.perpetualAtlanticVaultLP,\n          (currentFundingRate * (nextFundingPaymentTimestamp() - startTime)) /\n            1e18\n        );\n\n        IPerpetualAtlanticVaultLP(addresses.perpetualAtlanticVaultLP)\n          .addProceeds(\n            (currentFundingRate * (nextFundingPaymentTimestamp() - startTime)) /\n              1e18\n          );\n\n        emit FundingPaid(\n          msg.sender,\n          ((currentFundingRate * (nextFundingPaymentTimestamp() - startTime)) /\n            1e18),\n          latestFundingPaymentPointer\n        );\n      }\n\n      latestFundingPaymentPointer += 1;\n      emit FundingPaymentPointerUpdated(latestFundingPaymentPointer);\n    }\n  }\n\n  /**\n   * @notice function to transfer funding into the LP in a drip-vested manner\n   * @dev    addProceeds() is invoked to update totalCollateral in LP\n   **/\n  function updateFunding() public {\n    updateFundingPaymentPointer();\n    uint256 currentFundingRate = fundingRates[latestFundingPaymentPointer];\n    uint256 startTime = lastUpdateTime == 0\n      ? (nextFundingPaymentTimestamp() - fundingDuration)\n      : lastUpdateTime;\n    lastUpdateTime = block.timestamp;\n\n    collateralToken.safeTransfer(\n      addresses.perpetualAtlanticVaultLP,\n      (currentFundingRate * (block.timestamp - startTime)) / 1e18\n    );\n\n    IPerpetualAtlanticVaultLP(addresses.perpetualAtlanticVaultLP).addProceeds(\n      (currentFundingRate * (block.timestamp - startTime)) / 1e18\n    );\n\n    emit FundingPaid(\n      msg.sender,\n      ((currentFundingRate * (block.timestamp - startTime)) / 1e18),\n      latestFundingPaymentPointer\n    );\n  }\n\n  // ================================ VIEWS ================================ //\n\n  /// @inheritdoc\tIPerpetualAtlanticVault\n  function getUnderlyingPrice() public view returns (uint256) {\n    return IRdpxEthOracle(addresses.assetPriceOracle).getRdpxPriceInEth();\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVault\n  function getVolatility(uint256 _strike) public view returns (uint256) {\n    return IVolatilityOracle(addresses.volatilityOracle).getVolatility(_strike);\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVault\n  function calculatePremium(\n    uint256 _strike,\n    uint256 _amount,\n    uint256 timeToExpiry,\n    uint256 _price\n  ) public view returns (uint256 premium) {\n    premium = ((IOptionPricing(addresses.optionPricing).getOptionPrice(\n      _strike,\n      _price > 0 ? _price : getUnderlyingPrice(),\n      getVolatility(_strike),\n      timeToExpiry\n    ) * _amount) / 1e8);\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVault\n  function calculatePnl(\n    uint256 price,\n    uint256 strike,\n    uint256 amount\n  ) public pure returns (uint256) {\n    return strike > price ? ((strike - price) * amount) / 1e8 : 0;\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVault\n  function nextFundingPaymentTimestamp()\n    public\n    view\n    returns (uint256 timestamp)\n  {\n    return genesis + (latestFundingPaymentPointer * fundingDuration);\n  }\n\n  /**\n   * @dev Function to round up a value to the roundingPrecision.\n   * @param _strike the strike\n   * @return strike rounded up to the nearest roundingPrecision\n   **/\n  function roundUp(uint256 _strike) public view returns (uint256 strike) {\n    uint256 remainder = _strike % roundingPrecision;\n    if (remainder == 0) {\n      return _strike;\n    } else {\n      return _strike - remainder + roundingPrecision;\n    }\n  }\n\n  // ================================ PRIVATE/HELPER FUNCTIONS ================================ //\n\n  /// @dev Internal function to mint a option token\n  function _mintOptionToken() private returns (uint256 tokenId) {\n    tokenId = _tokenIdCounter.current();\n    _tokenIdCounter.increment();\n    _mint(addresses.rdpxV2Core, tokenId);\n  }\n\n  function _updateFundingRate(uint256 amount) private {\n    if (fundingRates[latestFundingPaymentPointer] == 0) {\n      uint256 startTime;\n      if (lastUpdateTime > nextFundingPaymentTimestamp() - fundingDuration) {\n        startTime = lastUpdateTime;\n      } else {\n        startTime = nextFundingPaymentTimestamp() - fundingDuration;\n      }\n      uint256 endTime = nextFundingPaymentTimestamp();\n      fundingRates[latestFundingPaymentPointer] =\n        (amount * 1e18) /\n        (endTime - startTime);\n    } else {\n      uint256 startTime = lastUpdateTime;\n      uint256 endTime = nextFundingPaymentTimestamp();\n      if (endTime == startTime) return;\n      fundingRates[latestFundingPaymentPointer] =\n        fundingRates[latestFundingPaymentPointer] +\n        ((amount * 1e18) / (endTime - startTime));\n    }\n  }\n\n  /**\n   * @dev    internal function to validate checks\n   * @param  _clause the boolean clause to validate\n   * @param  _errorCode error code for error mapping below\n   **/\n  function _validate(bool _clause, uint256 _errorCode) private pure {\n    if (!_clause) revert PerpetualAtlanticVaultError(_errorCode);\n  }\n\n  // ================================ ERRORS ================================ //\n\n  /**\n   * @dev  Custom Error used to validate checks within the contract's functions.\n   *       The uint256 error code corresponds to an error message.\n   **/\n  error PerpetualAtlanticVaultError(uint256);\n\n  // ================================ Solidity Required Overrides ================================ //\n\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 tokenId,\n    uint256 batchSize\n  ) internal override(ERC721, ERC721Enumerable) {\n    _whenNotPaused();\n    super._beforeTokenTransfer(from, to, tokenId, batchSize);\n  }\n\n  function supportsInterface(\n    bytes4 interfaceId\n  )\n    public\n    view\n    override(ERC721, ERC721Enumerable, AccessControl)\n    returns (bool)\n  {\n    return super.supportsInterface(interfaceId);\n  }\n}\n\n// ERROR CODES\n// E1: \"Zero address\",\n// E2: \"Amount must be greater than 0\",\n// E3: \"Insufficient collateral for purchase\",\n// E4: \"No options for strike\",\n// E5: \"Option strike already funded\",\n// E6: \"All funding payments must be accounted for\",\n// E7: \"Option is not ITM\""
    },
    {
      "filename": "contracts/perp-vault/PerpetualAtlanticVault.sol",
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.19;\n\n// Libraries\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n// Contracts\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { ERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { ERC721Enumerable } from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport { ERC721Burnable } from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol\";\nimport { ERC4626 } from \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\nimport { AccessControl } from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport { Counters } from \"@openzeppelin/contracts/utils/Counters.sol\";\nimport { IPerpetualAtlanticVaultLP } from \"./IPerpetualAtlanticVaultLP.sol\";\nimport { ContractWhitelist } from \"../helper/ContractWhitelist.sol\";\nimport { Pausable } from \"../helper/Pausable.sol\";\n\n// Interfaces\nimport { IPerpetualAtlanticVault } from \"./IPerpetualAtlanticVault.sol\";\nimport { IERC20WithBurn } from \"../interfaces/IERC20WithBurn.sol\";\nimport { IOptionPricing } from \"../interfaces/IOptionPricing.sol\";\nimport { IRdpxEthOracle } from \"../interfaces/IRdpxEthOracle.sol\";\nimport { IVolatilityOracle } from \"../interfaces/IVolatilityOracle.sol\";\n\n/// @title Contract to offer perpetual atlantic rDPX PUT options to the rdpxV2Core contract\n/// @dev Option tokens are in erc20 18 decimals & Strikes are in 1e8 precision\ncontract PerpetualAtlanticVault is\n  IPerpetualAtlanticVault,\n  ReentrancyGuard,\n  Pausable,\n  ERC721,\n  ERC721Enumerable,\n  ERC721Burnable,\n  AccessControl,\n  ContractWhitelist\n{\n  using SafeERC20 for IERC20WithBurn;\n  using Counters for Counters.Counter;\n\n  /// @dev Token ID counter for write positions\n  Counters.Counter private _tokenIdCounter;\n\n  /// @dev Manager role which handles bootstrapping\n  bytes32 public constant MANAGER_ROLE = keccak256(\"MANAGER_ROLE\");\n\n  /// @dev Rdpx v2 core role which can purchase and settle options\n  bytes32 public constant RDPXV2CORE_ROLE = keccak256(\"RDPXV2CORE_ROLE\");\n\n  /// @dev Underlying assets symbol\n  string public underlyingSymbol;\n\n  /// @dev Contract addresses\n  Addresses public addresses;\n\n  /// @dev Collateral Token\n  IERC20WithBurn public collateralToken;\n\n  /// @dev The precision of the collateral token\n  uint256 public collateralPrecision;\n\n  /// @dev tokenId => OptionPosition\n  mapping(uint256 => OptionPosition) public optionPositions;\n\n  /// @dev number of options funding has been accounted for the epoch\n  mapping(uint256 => uint256) public fundingPaymentsAccountedFor;\n\n  /// @dev the funding accounted for the epoch and strike\n  mapping(uint256 => mapping(uint256 => uint256))\n    public fundingPaymentsAccountedForPerStrike;\n\n  /// @dev the total funding for the epoch\n  mapping(uint256 => uint256) public totalFundingForEpoch;\n\n  /// @dev amount of options per strike\n  mapping(uint256 => uint256) public optionsPerStrike;\n\n  /// @dev latest funding update per strike\n  mapping(uint256 => uint256) public latestFundingPerStrike;\n\n  // @dev Funding rate for the epoch\n  mapping(uint256 => uint256) public fundingRates;\n\n  /// @dev the pointer to the lattest funding payment timestamp\n  /// @notice Explain to an end user what this does\n  /// @dev Explain to a developer any extra details\n  /// @return Documents the return variables of a contract’s function state variable\n  /// @inheritdoc\tIPerpetualAtlanticVault\n  uint256 public latestFundingPaymentPointer = 0;\n\n  /// @dev the total number of active options\n  uint256 public totalActiveOptions;\n\n  /// @dev genesis timestamp\n  uint256 public genesis;\n\n  /// @dev the timestamp of the last update where funding was paid for\n  uint256 public lastUpdateTime;\n\n  /// @dev the duration between funding payments\n  uint256 public fundingDuration = 7 days;\n\n  /// @dev the precision to round up to\n  uint256 public roundingPrecision = 1e6;\n\n  // ================================ CONSTRUCTOR ================================ //\n\n  /// @notice Contract constructor\n  /// @param _name ERC721 name\n  /// @param _symbol ERC721 symbol\n  /// @param _collateralToken Collateral token of the perpetual atlantic vault\n  /// @param _gensis Gensis time for funding calculation\n  constructor(\n    string memory _name,\n    string memory _symbol,\n    address _collateralToken,\n    uint256 _gensis\n  ) ERC721(_name, _symbol) {\n    _validate(_collateralToken != address(0), 1);\n\n    collateralToken = IERC20WithBurn(_collateralToken);\n    underlyingSymbol = collateralToken.symbol();\n    collateralPrecision = 10 ** collateralToken.decimals();\n    genesis = _gensis;\n\n    _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    _setupRole(MANAGER_ROLE, msg.sender);\n  }\n\n  // ================================ ADMIN FUNCTIONS ================================ //\n\n  /**\n   * @notice Pauses the vault for emergency cases\n   * @dev    Can only be called by the owner\n   **/\n  function pause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _pause();\n  }\n\n  /**\n   * @notice Unpauses the vault\n   * @dev    Can only be called by the owner\n   **/\n  function unpause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _unpause();\n  }\n\n  /**\n   * @notice Add a contract to the whitelist\n   * @dev    Can only be called by the owner\n   * @param  _contract Address of the contract that needs to be added to the whitelist\n   **/\n  function addToContractWhitelist(\n    address _contract\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _addToContractWhitelist(_contract);\n  }\n\n  /**\n   * @notice Remove a contract to the whitelist\n   * @dev    Can only be called by the owner\n   * @param  _contract Address of the contract that needs to be removed from the whitelist\n   **/\n  function removeFromContractWhitelist(\n    address _contract\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _removeFromContractWhitelist(_contract);\n  }\n\n  /**\n   * @notice Sets (adds) a list of addresses to the address list\n   * @dev    Can only be called by the owner\n   * @param  _optionPricing Address of the option pricing contract\n   * @param  _assetPriceOracle Address of the asset price oracle contract\n   * @param  _volatilityOracle Address of the volatility oracle contract\n   * @param  _feeDistributor Address of the fee distributor contract\n   * @param  _rdpx Address of the rdpx contract\n   * @param  _perpetualAtlanticVaultLP Address of the perpetual atlantic vault lp contract\n   * @param  _rdpxV2Core Address of the rdpx v2 rdpxV2Core contract\n   **/\n  function setAddresses(\n    address _optionPricing,\n    address _assetPriceOracle,\n    address _volatilityOracle,\n    address _feeDistributor,\n    address _rdpx,\n    address _perpetualAtlanticVaultLP,\n    address _rdpxV2Core\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _validate(_optionPricing != address(0), 1);\n    _validate(_assetPriceOracle != address(0), 1);\n    _validate(_volatilityOracle != address(0), 1);\n    _validate(_feeDistributor != address(0), 1);\n    _validate(_rdpx != address(0), 1);\n    _validate(_perpetualAtlanticVaultLP != address(0), 1);\n    _validate(_rdpxV2Core != address(0), 1);\n\n    addresses = Addresses({\n      optionPricing: _optionPricing,\n      assetPriceOracle: _assetPriceOracle,\n      volatilityOracle: _volatilityOracle,\n      feeDistributor: _feeDistributor,\n      rdpx: _rdpx,\n      perpetualAtlanticVaultLP: _perpetualAtlanticVaultLP,\n      rdpxV2Core: _rdpxV2Core\n    });\n    collateralToken.safeApprove(\n      addresses.perpetualAtlanticVaultLP,\n      type(uint256).max\n    );\n    emit AddressesSet(addresses);\n  }\n\n  /**\n   * @notice Transfers all funds to msg.sender\n   * @dev    Can only be called by the owner\n   * @param  tokens The list of erc20 tokens to withdraw\n   **/\n  function emergencyWithdraw(\n    address[] calldata tokens\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _whenPaused();\n    IERC20WithBurn token;\n\n    for (uint256 i = 0; i < tokens.length; i++) {\n      token = IERC20WithBurn(tokens[i]);\n      token.safeTransfer(msg.sender, token.balanceOf(address(this)));\n    }\n\n    emit EmergencyWithdraw(msg.sender, tokens);\n  }\n\n  /**\n   * @notice Updates the funding duration\n   * @dev    Can only be called by the owner\n   **/\n  function updateFundingDuration(\n    uint256 _fundingDuration\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    fundingDuration = _fundingDuration;\n  }\n\n  function setLpAllowance(bool increase) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    increase\n      ? collateralToken.approve(\n        addresses.perpetualAtlanticVaultLP,\n        type(uint256).max\n      )\n      : collateralToken.approve(addresses.perpetualAtlanticVaultLP, 0);\n  }\n\n  // ================================ TREASURY FUNCTIONS ================================ //\n\n  /// @inheritdoc\tIPerpetualAtlanticVault\n  function purchase(\n    uint256 amount,\n    address to\n  )\n    external\n    nonReentrant\n    onlyRole(RDPXV2CORE_ROLE)\n    returns (uint256 premium, uint256 tokenId)\n  {\n    _whenNotPaused();\n    _validate(amount > 0, 2);\n\n    updateFunding();\n\n    uint256 currentPrice = getUnderlyingPrice(); // price of underlying wrt collateralToken\n    uint256 strike = roundUp(currentPrice - (currentPrice / 4)); // 25% below the current price\n    IPerpetualAtlanticVaultLP perpetualAtlanticVaultLp = IPerpetualAtlanticVaultLP(\n        addresses.perpetualAtlanticVaultLP\n      );\n\n    // Check if vault has enough collateral to write the options\n    uint256 requiredCollateral = (amount * strike) / 1e8;\n\n    _validate(\n      requiredCollateral <= perpetualAtlanticVaultLp.totalAvailableCollateral(),\n      3\n    );\n\n    uint256 timeToExpiry = nextFundingPaymentTimestamp() - block.timestamp;\n\n    // Get total premium for all options being purchased\n    premium = calculatePremium(strike, amount, timeToExpiry, 0);\n\n    // Transfer premium from msg.sender to PerpetualAtlantics vault\n    collateralToken.safeTransferFrom(msg.sender, address(this), premium);\n\n    perpetualAtlanticVaultLp.lockCollateral(requiredCollateral);\n    _updateFundingRate(premium);\n\n    // Mint the option tokens\n    tokenId = _mintOptionToken();\n    optionPositions[tokenId] = OptionPosition({\n      strike: strike,\n      amount: amount,\n      positionId: tokenId\n    });\n\n    totalActiveOptions += amount;\n    fundingPaymentsAccountedFor[latestFundingPaymentPointer] += amount;\n    optionsPerStrike[strike] += amount;\n\n    // record the number of options funding has been accounted for the epoch and strike\n    fundingPaymentsAccountedForPerStrike[latestFundingPaymentPointer][\n      strike\n    ] += amount;\n\n    emit Purchase(strike, amount, premium, to, msg.sender);\n  }\n\n  /// @inheritdoc\tIPerpetualAtlanticVault\n  function settle(\n    uint256[] memory optionIds\n  )\n    external\n    nonReentrant\n    onlyRole(RDPXV2CORE_ROLE)\n    returns (uint256 ethAmount, uint256 rdpxAmount)\n  {\n    _whenNotPaused();\n    _isEligibleSender();\n\n    updateFunding();\n\n    for (uint256 i = 0; i < optionIds.length; i++) {\n      uint256 strike = optionPositions[optionIds[i]].strike;\n      uint256 amount = optionPositions[optionIds[i]].amount;"
    }
  ]
}