{
  "Title": "[G-06]  Avoid zero transfers",
  "Content": "In Solidity, performing unnecessary operations can consume more gas than needed, leading to cost inefficiencies. For instance, if a transfer function doesn't have a zero amount check and someone calls it with a zero amount, unnecessary gas will be consumed in executing the function, even though the state of the contract remains the same. By implementing a zero amount check, such unnecessary function calls can be avoided, thereby saving gas and making the contract more efficient. Amounts should be checked for 0 before calling a transfer\nChecking non-zero transfer values can avoid an expensive external call and save gas. I suggest adding a non-zero-value.\n\n### Please note this instance was not included in the bots reports.\n\n### 1 Instance\n1. ### Refactor `veOLAS.withdraw()` function to avoid making zero transfers\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/governance/contracts/veOLAS.sol#L534\n\na check for if `amount` == 0 should be introduced to `veOLAS.withdraw()` function so as to prevent making unnecessary transfer that does not change state of the contract in scenarios where `amount = 0`. The diff below shows how `veOLAS.withdraw() function could be refactored.\n\n<details>\n\n```solidity\nfile: governance/contracts/veOLAS.sol\n\n510:    function withdraw() external {\n511:        LockedBalance memory lockedBalance = mapLockedBalances[msg.sender];\n512:        if (lockedBalance.endTime > block.timestamp) {\n513:            revert LockNotExpired(msg.sender, lockedBalance.endTime, block.timestamp);\n514:        }\n515:        uint256 amount = uint256(lockedBalance.amount);\n516:\n517:        mapLockedBalances[msg.sender] = LockedBalance(0, 0);\n518:        uint256 supplyBefore = supply;\n519:        uint256 supplyAfter;\n520:        // The amount cannot be less than the total supply\n521:        unchecked {\n522:            supplyAfter = supplyBefore - amount;\n523:            supply = supplyAfter;\n524:        }\n525:        // oldLocked can have either expired <= timestamp or zero end\n526:        // lockedBalance has only 0 end\n527:        // Both can have >= 0 amount\n528:        _checkpoint(msg.sender, lockedBalance, LockedBalance(0, 0), uint128(supplyAfter));\n528:\n529:        emit Withdraw(msg.sender, amount, block.timestamp);\n530:        emit Supply(supplyBefore, supplyAfter);\n531:\n532:        // OLAS is a solmate-based ERC20 token with optimized transfer() that either returns true or reverts\n533:        IERC20(token).transfer(msg.sender, amount); //@audit should check for amount == 0 before transfer\n534:    }\n```\n\n```diff\ndiff --git a/governance/contracts/veOLAS.sol b/governance/contracts/veOLAS.sol\nindex 6f14419..4ab19b5 100644\n--- a/governance/contracts/veOLAS.sol\n+++ b/governance/contracts/veOLAS.sol\n@@ -531,7 +531,10 @@ contract veOLAS is IErrors, IVotes, IERC20, IERC165 {\n         emit Supply(supplyBefore, supplyAfter);\n\n         // OLAS is a solmate-based ERC20 token with optimized transfer() that either returns true or reverts\n-        IERC20(token).transfer(msg.sender, amount);\n+        if (amount > 0) {\n+            IERC20(token).transfer(msg.sender, amount);\n+        }\n+\n     }\n\n     /// @dev Finds a closest point that has a specified block number.\n```\n```\nEstimated gas saved: 100 gas units\n```\n\n</details>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-12-autonolas",
  "Code": [
    {
      "filename": "governance/contracts/veOLAS.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"@openzeppelin/contracts/governance/utils/IVotes.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"./interfaces/IErrors.sol\";\n\n/**\nVotes have a weight depending on time, so that users are committed to the future of (whatever they are voting for).\nVote weight decays linearly over time. Lock time cannot be more than `MAXTIME` (4 years).\nVoting escrow has time-weighted votes derived from the amount of tokens locked. The maximum voting power can be\nachieved with the longest lock possible. This way the users are incentivized to lock tokens for more time.\n# w ^ = amount * time_locked / MAXTIME\n# 1 +        /\n#   |      /\n#   |    /\n#   |  /\n#   |/\n# 0 +--------+------> time\n#       maxtime (4 years?)\n\nWe cannot really do block numbers per se because slope is per time, not per block, and per block could be fairly bad\nbecause Ethereum changes its block times. What we can do is to extrapolate ***At functions.\n*/\n\n/// @title Voting Escrow OLAS - the workflow is ported from Curve Finance Vyper implementation\n/// @author Aleksandr Kuperman - <aleksandr.kuperman@valory.xyz>\n/// Code ported from: https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy\n/// and: https://github.com/solidlyexchange/solidly/blob/master/contracts/ve.sol\n\n/* This VotingEscrow is based on the OLAS token that has the following specifications:\n*  - For the first 10 years there will be the cap of 1 billion (1e27) tokens;\n*  - After 10 years, the inflation rate is 2% per year.\n* The maximum number of tokens for each year then can be calculated from the formula: 2^n = 1e27 * (1.02)^x,\n* where n is the specified number of bits that is sufficient to store and not overflow the total supply,\n* and x is the number of years. We limit n by 128, thus it would take 1340+ years to reach that total supply.\n* The amount for each locker is eventually cannot overcome this number as well, and thus uint128 is sufficient.\n*\n* We then limit the time in seconds to last until the value of 2^64 - 1, or for the next 583+ billion years.\n* The number of blocks is essentially cannot be bigger than the number of seconds, and thus it is safe to assume\n* that uint64 for the number of blocks is also sufficient.\n*\n* We also limit the individual deposit amount to be no bigger than 2^96 - 1, or the value of total supply in 220+ years.\n* This limitation is dictated by the fact that there will be at least several accounts with locked tokens, and the\n* sum of all of them cannot be bigger than the total supply. Checking the limit of deposited / increased amount\n* allows us to perform the unchecked operation on adding the amounts.\n*\n* The rest of calculations throughout the contract do not go beyond specified limitations. The contract was checked\n* by echidna and the results can be found in the audit section of the repository.\n*\n* These specified limits allowed us to have storage-added structs to be bound by 2*256 and 1*256 bit sizes\n* respectively, thus limiting the gas amount compared to using bigger variable sizes.\n*\n* Note that after 220 years it is no longer possible to deposit / increase the locked amount to be bigger than 2^96 - 1.\n* It is going to be not safe to use this contract for governance after 1340 years.\n*/\n\n// Struct for storing balance and unlock time\n// The struct size is one storage slot of uint256 (128 + 64 + padding)\nstruct LockedBalance {\n    // Token amount. It will never practically be bigger. Initial OLAS cap is 1 bn tokens, or 1e27.\n    // After 10 years, the inflation rate is 2% per year. It would take 1340+ years to reach 2^128 - 1\n    uint128 amount;\n    // Unlock time. It will never practically be bigger\n    uint64 endTime;\n}\n\n// Structure for voting escrow points\n// The struct size is two storage slots of 2 * uint256 (128 + 128 + 64 + 64 + 128)\nstruct PointVoting {\n    // w(i) = at + b (bias)\n    int128 bias;\n    // dw / dt = a (slope)\n    int128 slope;\n    // Timestamp. It will never practically be bigger than 2^64 - 1\n    uint64 ts;\n    // Block number. It will not be bigger than the timestamp\n    uint64 blockNumber;\n    // Token amount. It will never practically be bigger. Initial OLAS cap is 1 bn tokens, or 1e27.\n    // After 10 years, the inflation rate is 2% per year. It would take 1340+ years to reach 2^128 - 1\n    uint128 balance;\n}\n\n/// @notice This token supports the ERC20 interface specifications except for transfers and approvals.\ncontract veOLAS is IErrors, IVotes, IERC20, IERC165 {\n    enum DepositType {\n        DEPOSIT_FOR_TYPE,\n        CREATE_LOCK_TYPE,\n        INCREASE_LOCK_AMOUNT,\n        INCREASE_UNLOCK_TIME\n    }\n\n    event Deposit(address indexed account, uint256 amount, uint256 locktime, DepositType depositType, uint256 ts);\n    event Withdraw(address indexed account, uint256 amount, uint256 ts);\n    event Supply(uint256 previousSupply, uint256 currentSupply);\n\n    // 1 week time\n    uint64 internal constant WEEK = 1 weeks;\n    // Maximum lock time (4 years)\n    uint256 internal constant MAXTIME = 4 * 365 * 86400;\n    // Maximum lock time (4 years) in int128\n    int128 internal constant IMAXTIME = 4 * 365 * 86400;\n    // Number of decimals\n    uint8 public constant decimals = 18;\n\n    // Token address\n    address public immutable token;\n    // Total token supply\n    uint256 public supply;\n    // Mapping of account address => LockedBalance\n    mapping(address => LockedBalance) public mapLockedBalances;\n\n    // Total number of economical checkpoints (starting from zero)\n    uint256 public totalNumPoints;\n    // Mapping of point Id => point\n    mapping(uint256 => PointVoting) public mapSupplyPoints;\n    // Mapping of account address => PointVoting[point Id]\n    mapping(address => PointVoting[]) public mapUserPoints;\n    // Mapping of time => signed slope change\n    mapping(uint64 => int128) public mapSlopeChanges;\n\n    // Voting token name\n    string public name;\n    // Voting token symbol\n    string public symbol;\n\n    /// @dev Contract constructor\n    /// @param _token Token address.\n    /// @param _name Token name.\n    /// @param _symbol Token symbol.\n    constructor(address _token, string memory _name, string memory _symbol)\n    {\n        token = _token;\n        name = _name;\n        symbol = _symbol;\n        // Create initial point such that default timestamp and block number are not zero\n        // See cast specification in the PointVoting structure\n        mapSupplyPoints[0] = PointVoting(0, 0, uint64(block.timestamp), uint64(block.number), 0);\n    }\n\n    /// @dev Gets the most recently recorded user point for `account`.\n    /// @param account Account address.\n    /// @return pv Last checkpoint.\n    function getLastUserPoint(address account) external view returns (PointVoting memory pv) {\n        uint256 lastPointNumber = mapUserPoints[account].length;\n        if (lastPointNumber > 0) {\n            pv = mapUserPoints[account][lastPointNumber - 1];\n        }\n    }\n\n    /// @dev Gets the number of user points.\n    /// @param account Account address.\n    /// @return accountNumPoints Number of user points.\n    function getNumUserPoints(address account) external view returns (uint256 accountNumPoints) {\n        accountNumPoints = mapUserPoints[account].length;\n    }\n\n    /// @dev Gets the checkpoint structure at number `idx` for `account`.\n    /// @notice The out of bound condition is treated by the default code generation check.\n    /// @param account User wallet address.\n    /// @param idx User point number.\n    /// @return The requested checkpoint.\n    function getUserPoint(address account, uint256 idx) external view returns (PointVoting memory) {\n        return mapUserPoints[account][idx];\n    }\n\n    /// @dev Record global and per-user data to checkpoint.\n    /// @param account Account address. User checkpoint is skipped if the address is zero.\n    /// @param oldLocked Previous locked amount / end lock time for the user.\n    /// @param newLocked New locked amount / end lock time for the user.\n    /// @param curSupply Current total supply (to avoid using a storage total supply variable)\n    function _checkpoint(\n        address account,\n        LockedBalance memory oldLocked,\n        LockedBalance memory newLocked,\n        uint128 curSupply\n    ) internal {\n        PointVoting memory uOld;\n        PointVoting memory uNew;\n        int128 oldDSlope;\n        int128 newDSlope;\n        uint256 curNumPoint = totalNumPoints;\n\n        if (account != address(0)) {\n            // Calculate slopes and biases\n            // Kept at zero when they have to\n            if (oldLocked.endTime > block.timestamp && oldLocked.amount > 0) {\n                uOld.slope = int128(oldLocked.amount) / IMAXTIME;\n                uOld.bias = uOld.slope * int128(uint128(oldLocked.endTime - uint64(block.timestamp)));\n            }\n            if (newLocked.endTime > block.timestamp && newLocked.amount > 0) {\n                uNew.slope = int128(newLocked.amount) / IMAXTIME;\n                uNew.bias = uNew.slope * int128(uint128(newLocked.endTime - uint64(block.timestamp)));\n            }\n\n            // Reads values of scheduled changes in the slope\n            // oldLocked.endTime can be in the past and in the future\n            // newLocked.endTime can ONLY be in the FUTURE unless everything is expired: then zeros\n            oldDSlope = mapSlopeChanges[oldLocked.endTime];\n            if (newLocked.endTime > 0) {\n                if (newLocked.endTime == oldLocked.endTime) {\n                    newDSlope = oldDSlope;\n                } else {\n                    newDSlope = mapSlopeChanges[newLocked.endTime];\n                }\n            }\n        }\n\n        PointVoting memory lastPoint;\n        if (curNumPoint > 0) {\n            lastPoint = mapSupplyPoints[curNumPoint];\n        } else {\n            // If no point is created yet, we take the actual time and block parameters\n            lastPoint = PointVoting(0, 0, uint64(block.timestamp), uint64(block.number), 0);\n        }\n        uint64 lastCheckpoint = lastPoint.ts;\n        // initialPoint is used for extrapolation to calculate the block number and save them\n        // as we cannot figure that out in exact values from inside of the contract\n        PointVoting memory initialPoint = lastPoint;\n        uint256 block_slope; // dblock/dt\n        if (block.timestamp > lastPoint.ts) {\n            // This 1e18 multiplier is needed for the numerator to be bigger than the denominator\n            // We need to calculate this in > uint64 size (1e18 is > 2^59 multiplied by 2^64).\n            block_slope = (1e18 * uint256(block.number - lastPoint.blockNumber)) / uint256(block.timestamp - lastPoint.ts);\n        }\n        // If last point is already recorded in this block, slope == 0, but we know the block already in this case\n        // Go over weeks to fill in the history and (or) calculate what the current point is\n        {\n            // The timestamp is rounded by a week and < 2^64-1\n            uint64 tStep = (lastCheckpoint / WEEK) * WEEK;\n            for (uint256 i = 0; i < 255; ++i) {\n                // Hopefully it won't happen that this won't get used in 5 years!\n                // If it does, users will be able to withdraw but vote weight will be broken\n                // This is always practically < 2^64-1\n                unchecked {\n                    tStep += WEEK;\n                }\n                int128 dSlope;\n                if (tStep > block.timestamp) {\n                    tStep = uint64(block.timestamp);\n                } else {\n                    dSlope = mapSlopeChanges[tStep];\n                }\n                lastPoint.bias -= lastPoint.slope * int128(int64(tStep - lastCheckpoint));\n                lastPoint.slope += dSlope;\n                if (lastPoint.bias < 0) {\n                    // This could potentially happen, but fuzzer didn't find available \"real\" combinations\n                    lastPoint.bias = 0;\n                }\n                if (lastPoint.slope < 0) {\n                    // This cannot happen - just in case. Again, fuzzer didn't reach this\n                    lastPoint.slope = 0;\n                }\n                lastCheckpoint = tStep;\n                lastPoint.ts = tStep;\n                // After division by 1e18 the uint64 size can be reclaimed\n                lastPoint.blockNumber = initialPoint.blockNumber + uint64((block_slope * uint256(tStep - initialPoint.ts)) / 1e18);\n                lastPoint.balance = initialPoint.balance;\n                // In order for the overflow of total number of economical checkpoints (starting from zero)\n                // The _checkpoint() call must happen n >(2^256 -1)/255 or n > ~1e77/255 > ~1e74 times\n                unchecked {\n                    curNumPoint += 1;    \n                }\n                if (tStep == block.timestamp) {\n                    lastPoint.blockNumber = uint64(block.number);\n                    lastPoint.balance = curSupply;\n                    break;\n                } else {\n                    mapSupplyPoints[curNumPoint] = lastPoint;\n                }\n            }\n        }\n\n        totalNumPoints = curNumPoint;\n\n        // Now mapSupplyPoints is filled until current time\n        if (account != address(0)) {\n            // If last point was in this block, the slope change has been already applied. In such case we have 0 slope(s)\n            lastPoint.slope += (uNew.slope - uOld.slope);\n            lastPoint.bias += (uNew.bias - uOld.bias);\n            if (lastPoint.slope < 0) {\n                lastPoint.slope = 0;\n            }\n            if (lastPoint.bias < 0) {\n                lastPoint.bias = 0;\n            }\n        }\n\n        // Record the last updated point\n        mapSupplyPoints[curNumPoint] = lastPoint;\n\n        if (account != address(0)) {\n            // Schedule the slope changes (slope is going down)\n            // We subtract new_user_slope from [newLocked.endTime]\n            // and add old_user_slope to [oldLocked.endTime]\n            if (oldLocked.endTime > block.timestamp) {\n                // oldDSlope was <something> - uOld.slope, so we cancel that\n                oldDSlope += uOld.slope;\n                if (newLocked.endTime == oldLocked.endTime) {\n                    oldDSlope -= uNew.slope; // It was a new deposit, not extension\n                }\n                mapSlopeChanges[oldLocked.endTime] = oldDSlope;\n            }\n\n            if (newLocked.endTime > block.timestamp && newLocked.endTime > oldLocked.endTime) {\n                newDSlope -= uNew.slope; // old slope disappeared at this point\n                mapSlopeChanges[newLocked.endTime] = newDSlope;\n                // else: we recorded it already in oldDSlope\n            }\n            // Now handle user history\n            uNew.ts = uint64(block.timestamp);\n            uNew.blockNumber = uint64(block.number);\n            uNew.balance = newLocked.amount;\n            mapUserPoints[account].push(uNew);\n        }\n    }\n\n    /// @dev Record global data to checkpoint.\n    function checkpoint() external {\n        _checkpoint(address(0), LockedBalance(0, 0), LockedBalance(0, 0), uint128(supply));\n    }\n\n    /// @dev Deposits and locks tokens for a specified account.\n    /// @param account Target address for the locked amount.\n    /// @param amount Amount to deposit.\n    /// @param unlockTime New time when to unlock the tokens, or 0 if unchanged.\n    /// @param lockedBalance Previous locked amount / end time.\n    /// @param depositType Deposit type.\n    function _depositFor(\n        address account,\n        uint256 amount,\n        uint256 unlockTime,\n        LockedBalance memory lockedBalance,\n        DepositType depositType\n    ) internal {\n        uint256 supplyBefore = supply;\n        uint256 supplyAfter;\n        // Cannot overflow because the total supply << 2^128-1\n        unchecked {\n            supplyAfter = supplyBefore + amount;\n            supply = supplyAfter;\n        }\n        // Get the old locked data\n        LockedBalance memory oldLocked;\n        (oldLocked.amount, oldLocked.endTime) = (lockedBalance.amount, lockedBalance.endTime);\n        // Adding to the existing lock, or if a lock is expired - creating a new one\n        // This cannot be larger than the total supply\n        unchecked {\n            lockedBalance.amount += uint128(amount);\n        }\n        if (unlockTime > 0) {\n            lockedBalance.endTime = uint64(unlockTime);\n        }\n        mapLockedBalances[account] = lockedBalance;\n\n        // Possibilities:\n        // Both oldLocked.endTime could be current or expired (>/< block.timestamp)\n        // amount == 0 (extend lock) or amount > 0 (add to lock or extend lock)\n        // lockedBalance.endTime > block.timestamp (always)\n        _checkpoint(account, oldLocked, lockedBalance, uint128(supplyAfter));\n        if (amount > 0) {\n            // OLAS is a solmate-based ERC20 token with optimized transferFrom() that either returns true or reverts\n            IERC20(token).transferFrom(msg.sender, address(this), amount);\n        }\n\n        emit Deposit(account, amount, lockedBalance.endTime, depositType, block.timestamp);\n        emit Supply(supplyBefore, supplyAfter);\n    }\n\n    /// @dev Deposits `amount` tokens for `account` and adds to the lock.\n    /// @dev Anyone (even a smart contract) can deposit for someone else, but\n    ///      cannot extend their locktime and deposit for a brand new user.\n    /// @param account Account address.\n    /// @param amount Amount to add.\n    function depositFor(address account, uint256 amount) external {\n        LockedBalance memory lockedBalance = mapLockedBalances[account];\n        // Check if the amount is zero\n        if (amount == 0) {\n            revert ZeroValue();\n        }\n        // The locked balance must already exist\n        if (lockedBalance.amount == 0) {\n            revert NoValueLocked(account);\n        }\n        // Check the lock expiry\n        if (lockedBalance.endTime < (block.timestamp + 1)) {\n            revert LockExpired(msg.sender, lockedBalance.endTime, block.timestamp);\n        }\n        // Since in the _depositFor() we have the unchecked sum of amounts, this is needed to prevent unsafe behavior.\n        // After 10 years, the inflation rate is 2% per year. It would take 220+ years to reach 2^96 - 1 total supply\n        if (amount > type(uint96).max) {\n            revert Overflow(amount, type(uint96).max);\n        }\n\n        _depositFor(account, amount, 0, lockedBalance, DepositType.DEPOSIT_FOR_TYPE);\n    }\n\n    /// @dev Deposits `amount` tokens for `msg.sender` and locks for `unlockTime`.\n    /// @param amount Amount to deposit.\n    /// @param unlockTime Time when tokens unlock, rounded down to a whole week.\n    function createLock(uint256 amount, uint256 unlockTime) external {\n        _createLockFor(msg.sender, amount, unlockTime);\n    }\n\n    /// @dev Deposits `amount` tokens for `account` and locks for `unlockTime`.\n    /// @notice Tokens are taken from `msg.sender`'s balance.\n    /// @param account Account address.\n    /// @param amount Amount to deposit.\n    /// @param unlockTime Time when tokens unlock, rounded down to a whole week.\n    function createLockFor(address account, uint256 amount, uint256 unlockTime) external {\n        // Check if the account address is zero\n        if (account == address(0)) {\n            revert ZeroAddress();\n        }\n\n        _createLockFor(account, amount, unlockTime);\n    }\n\n    /// @dev Deposits `amount` tokens for `account` and locks for `unlockTime`.\n    /// @notice Tokens are taken from `msg.sender`'s balance.\n    /// @param account Account address.\n    /// @param amount Amount to deposit.\n    /// @param unlockTime Time when tokens unlock, rounded down to a whole week.\n    function _createLockFor(address account, uint256 amount, uint256 unlockTime) private {\n        // Check if the amount is zero\n        if (amount == 0) {\n            revert ZeroValue();\n        }\n        // Lock time is rounded down to weeks\n        // Cannot practically overflow because block.timestamp + unlockTime (max 4 years) << 2^64-1\n        unchecked {\n            unlockTime = ((block.timestamp + unlockTime) / WEEK) * WEEK;\n        }\n        LockedBalance memory lockedBalance = mapLockedBalances[account];\n        // The locked balance must be zero in order to start the lock\n        if (lockedBalance.amount > 0) {\n            revert LockedValueNotZero(account, uint256(lockedBalance.amount));\n        }\n        // Check for the lock time correctness\n        if (unlockTime < (block.timestamp + 1)) {\n            revert UnlockTimeIncorrect(account, block.timestamp, unlockTime);\n        }\n        // Check for the lock time not to exceed the MAXTIME\n        if (unlockTime > block.timestamp + MAXTIME) {\n            revert MaxUnlockTimeReached(account, block.timestamp + MAXTIME, unlockTime);\n        }\n        // After 10 years, the inflation rate is 2% per year. It would take 220+ years to reach 2^96 - 1 total supply\n        if (amount > type(uint96).max) {\n            revert Overflow(amount, type(uint96).max);\n        }\n\n        _depositFor(account, amount, unlockTime, lockedBalance, DepositType.CREATE_LOCK_TYPE);\n    }\n\n    /// @dev Deposits `amount` additional tokens for `msg.sender` without modifying the unlock time.\n    /// @param amount Amount of tokens to deposit and add to the lock.\n    function increaseAmount(uint256 amount) external {\n        LockedBalance memory lockedBalance = mapLockedBalances[msg.sender];\n        // Check if the amount is zero\n        if (amount == 0) {\n            revert ZeroValue();\n        }\n        // The locked balance must already exist\n        if (lockedBalance.amount == 0) {\n            revert NoValueLocked(msg.sender);\n        }\n        // Check the lock expiry\n        if (lockedBalance.endTime < (block.timestamp + 1)) {\n            revert LockExpired(msg.sender, lockedBalance.endTime, block.timestamp);\n        }\n        // Check the max possible amount to add, that must be less than the total supply\n        // After 10 years, the inflation rate is 2% per year. It would take 220+ years to reach 2^96 - 1 total supply\n        if (amount > type(uint96).max) {\n            revert Overflow(amount, type(uint96).max);\n        }\n\n        _depositFor(msg.sender, amount, 0, lockedBalance, DepositType.INCREASE_LOCK_AMOUNT);\n    }\n\n    /// @dev Extends the unlock time.\n    /// @param unlockTime New tokens unlock time.\n    function increaseUnlockTime(uint256 unlockTime) external {\n        LockedBalance memory lockedBalance = mapLockedBalances[msg.sender];\n        // Cannot practically overflow because block.timestamp + unlockTime (max 4 years) << 2^64-1\n        unchecked {\n            unlockTime = ((block.timestamp + unlockTime) / WEEK) * WEEK;\n        }\n        // The locked balance must already exist\n        if (lockedBalance.amount == 0) {\n            revert NoValueLocked(msg.sender);\n        }\n        // Check the lock expiry\n        if (lockedBalance.endTime < (block.timestamp + 1)) {\n            revert LockExpired(msg.sender, lockedBalance.endTime, block.timestamp);\n        }\n        // Check for the lock time correctness\n        if (unlockTime < (lockedBalance.endTime + 1)) {\n            revert UnlockTimeIncorrect(msg.sender, lockedBalance.endTime, unlockTime);\n        }\n        // Check for the lock time not to exceed the MAXTIME\n        if (unlockTime > block.timestamp + MAXTIME) {\n            revert MaxUnlockTimeReached(msg.sender, block.timestamp + MAXTIME, unlockTime);\n        }\n\n        _depositFor(msg.sender, 0, unlockTime, lockedBalance, DepositType.INCREASE_UNLOCK_TIME);\n    }\n\n    /// @dev Withdraws all tokens for `msg.sender`. Only possible if the lock has expired.\n    function withdraw() external {\n        LockedBalance memory lockedBalance = mapLockedBalances[msg.sender];\n        if (lockedBalance.endTime > block.timestamp) {\n            revert LockNotExpired(msg.sender, lockedBalance.endTime, block.timestamp);\n        }\n        uint256 amount = uint256(lockedBalance.amount);\n\n        mapLockedBalances[msg.sender] = LockedBalance(0, 0);\n        uint256 supplyBefore = supply;\n        uint256 supplyAfter;\n        // The amount cannot be less than the total supply\n        unchecked {\n            supplyAfter = supplyBefore - amount;\n            supply = supplyAfter;\n        }\n        // oldLocked can have either expired <= timestamp or zero end\n        // lockedBalance has only 0 end\n        // Both can have >= 0 amount\n        _checkpoint(msg.sender, lockedBalance, LockedBalance(0, 0), uint128(supplyAfter));\n\n        emit Withdraw(msg.sender, amount, block.timestamp);\n        emit Supply(supplyBefore, supplyAfter);\n\n        // OLAS is a solmate-based ERC20 token with optimized transfer() that either returns true or reverts\n        IERC20(token).transfer(msg.sender, amount);\n    }\n\n    /// @dev Finds a closest point that has a specified block number.\n    /// @param blockNumber Block to find.\n    /// @param account Account address for user points.\n    /// @return point Point with the approximate index number for the specified block.\n    /// @return minPointNumber Point number.\n    function _findPointByBlock(uint256 blockNumber, address account) internal view\n        returns (PointVoting memory point, uint256 minPointNumber)\n    {\n        // Get the last available point number\n        uint256 maxPointNumber;\n        if (account == address(0)) {\n            maxPointNumber = totalNumPoints;\n        } else {\n            maxPointNumber = mapUserPoints[account].length;\n            if (maxPointNumber == 0) {\n                return (point, minPointNumber);\n            }\n            // Already checked for > 0 in this case\n            unchecked {\n                maxPointNumber -= 1;\n            }\n        }\n\n        // Binary search that will be always enough for 128-bit numbers\n        for (uint256 i = 0; i < 128; ++i) {\n            if ((minPointNumber + 1) > maxPointNumber) {\n                break;\n            }\n            uint256 mid = (minPointNumber + maxPointNumber + 1) / 2;\n\n            // Choose the source of points\n            if (account == address(0)) {\n                point = mapSupplyPoints[mid];\n            } else {\n                point = mapUserPoints[account][mid];\n            }\n\n            if (point.blockNumber < (blockNumber + 1)) {\n                minPointNumber = mid;\n            } else {\n                maxPointNumber = mid - 1;\n            }\n        }\n\n        // Get the found point\n        if (account == address(0)) {\n            point = mapSupplyPoints[minPointNumber];\n        } else {\n            point = mapUserPoints[account][minPointNumber];\n        }\n    }\n\n    /// @dev Gets the voting power for an `account` at time `ts`.\n    /// @param account Account address.\n    /// @param ts Time to get voting power at.\n    /// @return vBalance Account voting power.\n    function _balanceOfLocked(address account, uint64 ts) internal view returns (uint256 vBalance) {\n        uint256 pointNumber = mapUserPoints[account].length;\n        if (pointNumber > 0) {\n            PointVoting memory uPoint = mapUserPoints[account][pointNumber - 1];\n            uPoint.bias -= uPoint.slope * int128(int64(ts) - int64(uPoint.ts));\n            if (uPoint.bias > 0) {\n                vBalance = uint256(int256(uPoint.bias));\n            }\n        }\n    }\n\n    /// @dev Gets the account balance in native token.\n    /// @param account Account address.\n    /// @return balance Account balance.\n    function balanceOf(address account) public view override returns (uint256 balance) {\n        balance = uint256(mapLockedBalances[account].amount);\n    }\n\n    /// @dev Gets the `account`'s lock end time.\n    /// @param account Account address.\n    /// @return unlockTime Lock end time.\n    function lockedEnd(address account) external view returns (uint256 unlockTime) {\n        unlockTime = uint256(mapLockedBalances[account].endTime);\n    }\n\n    /// @dev Gets the account balance at a specific block number.\n    /// @param account Account address.\n    /// @param blockNumber Block number.\n    /// @return balance Account balance.\n    function balanceOfAt(address account, uint256 blockNumber) external view returns (uint256 balance) {\n        // Find point with the closest block number to the provided one\n        (PointVoting memory uPoint, ) = _findPointByBlock(blockNumber, account);\n        // If the block number at the point index is bigger than the specified block number, the balance was zero\n        if (uPoint.blockNumber < (blockNumber + 1)) {\n            balance = uint256(uPoint.balance);\n        }\n    }\n\n    /// @dev Gets the voting power.\n    /// @param account Account address.\n    function getVotes(address account) public view override returns (uint256) {\n        return _balanceOfLocked(account, uint64(block.timestamp));\n    }\n\n    /// @dev Gets the block time adjustment for two neighboring points.\n    /// @notice `blockNumber` must not be lower than the contract deployment block number,\n    ///         as the behavior and the return value is undefined.\n    /// @param blockNumber Block number.\n    /// @return point Point with the specified block number (or closest to it).\n    /// @return blockTime Adjusted block time of the neighboring point.\n    function _getBlockTime(uint256 blockNumber) internal view returns (PointVoting memory point, uint256 blockTime) {\n        // Check the block number to be in the past or equal to the current block\n        if (blockNumber > block.number) {\n            revert WrongBlockNumber(blockNumber, block.number);\n        }\n        // Get the minimum historical point with the provided block number\n        uint256 minPointNumber;\n        (point, minPointNumber) = _findPointByBlock(blockNumber, address(0));\n\n        uint256 dBlock;\n        uint256 dt;\n        if (minPointNumber < totalNumPoints) {\n            PointVoting memory pointNext = mapSupplyPoints[minPointNumber + 1];\n            dBlock = pointNext.blockNumber - point.blockNumber;\n            dt = pointNext.ts - point.ts;\n        } else {\n            dBlock = block.number - point.blockNumber;\n            dt = block.timestamp - point.ts;\n        }\n        blockTime = point.ts;\n        if (dBlock > 0) {\n            blockTime += (dt * (blockNumber - point.blockNumber)) / dBlock;\n        }\n    }\n\n    /// @dev Gets voting power at a specific block number.\n    /// @param account Account address.\n    /// @param blockNumber Block number.\n    /// @return balance Voting balance / power.\n    function getPastVotes(address account, uint256 blockNumber) public view override returns (uint256 balance) {\n        // Find the user point for the provided block number\n        (PointVoting memory uPoint, ) = _findPointByBlock(blockNumber, account);\n\n        // Get block time adjustment.\n        (, uint256 blockTime) = _getBlockTime(blockNumber);\n\n        // Calculate bias based on a block time\n        uPoint.bias -= uPoint.slope * int128(int64(uint64(blockTime)) - int64(uPoint.ts));\n        if (uPoint.bias > 0) {\n            balance = uint256(uint128(uPoint.bias));\n        }\n    }\n\n    /// @dev Calculate total voting power at some point in the past.\n    /// @param lastPoint The point (bias/slope) to start the search from.\n    /// @param ts Time to calculate the total voting power at.\n    /// @return vSupply Total voting power at that time.\n    function _supplyLockedAt(PointVoting memory lastPoint, uint64 ts) internal view returns (uint256 vSupply) {\n        // The timestamp is rounded and < 2^64-1\n        uint64 tStep = (lastPoint.ts / WEEK) * WEEK;\n        for (uint256 i = 0; i < 255; ++i) {\n            // This is always practically < 2^64-1\n            unchecked {\n                tStep += WEEK;\n            }\n            int128 dSlope;\n            if (tStep > ts) {\n                tStep = ts;\n            } else {\n                dSlope = mapSlopeChanges[tStep];\n            }\n            lastPoint.bias -= lastPoint.slope * int128(int64(tStep) - int64(lastPoint.ts));\n            if (tStep == ts) {\n                break;\n            }\n            lastPoint.slope += dSlope;\n            lastPoint.ts = tStep;\n        }\n\n        if (lastPoint.bias > 0) {\n            vSupply = uint256(uint128(lastPoint.bias));\n        }\n    }\n\n    /// @dev Gets total token supply.\n    /// @return Total token supply.\n    function totalSupply() public view override returns (uint256) {\n        return supply;\n    }\n\n    /// @dev Gets total token supply at a specific block number.\n    /// @param blockNumber Block number.\n    /// @return supplyAt Supply at the specified block number.\n    functi"
    }
  ]
}