{
  "Title": "M-2: Makers can lose funds from price movement even when no long and short positions are opened, due to incorrect distribution of adiabatic fees exposure between makers",
  "Content": "# Issue M-2: Makers can lose funds from price movement even when no long and short positions are opened, due to incorrect distribution of adiabatic fees exposure between makers \n\nSource: https://github.com/sherlock-audit/2024-02-perennial-v2-3-judging/issues/9 \n\n## Found by \npanprog\n## Summary\n\nAdiabatic fees introduced in this new update of the protocol (v2.3) were introduced to solve the problem of adiabatic fees netting out to 0 in market token's rather than in USD terms. With the new versions, this problem is solved and adiabatic fees now net out to 0 in USD terms. However, they net out to 0 only for the whole makers pool, but each individual maker can have profit or loss from adiabatic fees at different price levels all else being equal. This creates unexpected risk of loss of funds from adiabatic fees for individual makers, which can be significant, up to several percents of the amount invested.\n\n## Vulnerability Detail\n\nThe issue is demonstrated in the following scenario:\n- price = 1\n- Alice open `maker = 10` (`collateral = +0.9` from adiabatic fee)\n- Bob opens `maker = 10` (`collateral = +0.7` from adiabatic fee)\n- Path A. `price = 1`. Bob closes (final collateral = +0), Alice closes (final collaterral = +0)\n- Path B. `price = 2`. Bob closes (final collateral = +0.1), Alice closes (final collaterral = -0.1)\n- Path C. `price = 0.5`. Bob closes (final collateral = -0.05), Alice closes (final collateral = +0.05)\n\nNotice that both Alice and Bob are the only makers, there are 0 longs and 0 shorts, but still both Alice and Bob pnl depends on the market price due to pnl from adiabatic fees. Adiabatic fees net out to 0 for all makers aggregated (Alice + Bob), but not for individual makers. Individual makers pnl from adiabatic fees is more or less random depending on the other makers who have opened.\n\nIf Alice were the only maker, then:\n- price = 1\n- Alice opens `maker = 10` (`collateral = +0.9`)\n- price = 2: exposure adjusted +0.9 (Alice `collateral = +1.8`)\n- Alice closes `maker = 10` (adiabatic fees = `-1.8`, Alice final collateral = 0)\n\nFor the lone maker there is no such problem, final collateral is 0 regardless of price. The core of the issue lies in the fact that the maker's adiabatic fees exposure adjustment is weighted by makers open maker amount. So in the first example:\n- price = 1. Alice `maker = 10, exposure = +0.9`, Bob `maker = 10, exposure = +0.7`\n- price = 2. Total exposure is adjusted by +1.6, split evenly between Alice and Bob (+0.8 for each)\n- Alice new exposure = 0.9 + 0.8 = +1.7 (but adiabatic fees paid to close = -1.8)\n- Bob new exposure = 0.7 + 0.8 = +1.5 (but adiabatic fees paid to close = -1.4)\n\nIf maker exposure adjustment was weighted by individual makers exposure, then all is correct:\n- price = 1. Alice `maker = 10, exposure = +0.9`, Bob `maker = 10, exposure = +0.7`\n- price = 2. Total exposure is adjusted by +1.6, split 0.9:0.7 between Alice and Bob, e.g. +0.9 for Alice, +0.7 for Bob\n- Alice new exposure = 0.9 + 0.9 = +1.8 (adiabatic fees paid to close = -1.8, net out to 0)\n- Bob new exposure = 0.7 + 0.7 = +1.4 (adiabatic fees paid to close = -1.4, net out to 0)\n\nIn the worst case, in the example above, if Bob opens `maker = 40` (adiabatic fees `scale = 50`), then at `price = 2`, Alice's final collateral is `-0.4` due to adiabatic fees. Given that Alice's position is 10 at `price = 2` (`notional = 20`), a loss of `-0.4` is a loss of `-2%` at 1x leverage, which is quite significant.\n\n## Impact\n\nIndividual makers bear an additional undocumented price risk due to adiabatic fees, which is quite significant (can be several percentages of the notional).\n\n## Proof of concept\n\nThe scenario above is demonstrated in the test, change the following test in test/unit/market/Market.test.ts:\n```ts\nit('adiabatic fee', async () => {\n  function setupOracle(price: string, timestamp : number, nextTimestamp : number) {\n    const oracleVersion = {\n      price: parse6decimal(price),\n      timestamp: timestamp,\n      valid: true,\n    }\n    oracle.at.whenCalledWith(oracleVersion.timestamp).returns(oracleVersion)\n    oracle.status.returns([oracleVersion, nextTimestamp])\n    oracle.request.returns()\n  }\n\n  async function showInfo() {\n    await market.settle(user.address);\n    await market.settle(userB.address);\n    await market.settle(userC.address);\n    var sum : BigNumber = BigNumber.from('0');\n    var info = await market.locals(user.address);\n    console.log(\"user collateral = \" + info.collateral);\n    sum = sum.add(info.collateral);\n    var info = await market.locals(userB.address);\n    sum = sum.add(info.collateral);\n    console.log(\"userB collateral = \" + info.collateral);\n    var info = await market.locals(userC.address);\n    sum = sum.add(info.collateral);\n  }\n\n  async function showVer(ver : number) {\n    var v = await market.versions(ver);\n    console.log(\"ver\" + ver + \": makerValue=\" + v.makerValue + \" longValue=\" + v.longValue + \n    \" makerPosFee=\" + v.makerPosFee + \" makerNegFee=\" + v.makerNegFee +\n    \" takerPosFee=\" + v.takerPosFee + \" takerNegFee=\" + v.takerNegFee\n    );\n  }\n\n  const riskParameter = { ...(await market.riskParameter()) }\n  const riskParameterMakerFee = { ...riskParameter.makerFee }\n  riskParameterMakerFee.linearFee = parse6decimal('0.00')\n  riskParameterMakerFee.proportionalFee = parse6decimal('0.00')\n  riskParameterMakerFee.adiabaticFee = parse6decimal('0.01')\n  riskParameterMakerFee.scale = parse6decimal('50.0')\n  riskParameter.makerFee = riskParameterMakerFee\n  const riskParameterTakerFee = { ...riskParameter.takerFee }\n  riskParameterTakerFee.linearFee = parse6decimal('0.00')\n  riskParameterTakerFee.proportionalFee = parse6decimal('0.00')\n  riskParameterTakerFee.adiabaticFee = parse6decimal('0.01')\n  riskParameterTakerFee.scale = parse6decimal('50.0')\n  riskParameter.takerFee = riskParameterTakerFee\n  await market.connect(owner).updateRiskParameter(riskParameter)\n\n  marketParameter = {\n    fundingFee: parse6decimal('0.0'),\n    interestFee: parse6decimal('0.0'),\n    oracleFee: parse6decimal('0.0'),\n    riskFee: parse6decimal('0.0'),\n    positionFee: parse6decimal('0.0'),\n    maxPendingGlobal: 5,\n    maxPendingLocal: 3,\n    settlementFee: 0,\n    makerCloseAlways: false,\n    takerCloseAlways: false,\n    closed: false,\n    settle: false,\n  }\n  await market.connect(owner).updateParameter(beneficiary.address, coordinator.address, marketParameter)\n\n  var time = TIMESTAMP;\n\n  setupOracle('1', time, time + 100);\n  await market.connect(user)\n      ['update(address,uint256,uint256,uint256,int256,bool)'](user.address, POSITION, 0, 0, COLLATERAL, false);\n  await showInfo()\n  await showVer(time)\n\n  time += 100;\n  setupOracle('1', time, time + 100);\n  await market.connect(userB)\n      ['update(address,uint256,uint256,uint256,int256,bool)'](userB.address, POSITION, 0, 0, COLLATERAL, false);\n  await showInfo()\n  await showVer(time)\n\n  time += 100;\n  setupOracle('1', time, time + 100);\n  await showInfo()\n  await showVer(time)\n\n  time += 100;\n  setupOracle('2', time, time + 100);\n  await market.connect(userB)\n      ['update(address,uint256,uint256,uint256,int256,bool)'](userB.address, 0, 0, 0, 0, false);\n  await showInfo()\n  await showVer(time)\n\n  time += 100;\n  setupOracle('2', time, time + 100);\n  await market.connect(user)\n      ['update(address,uint256,uint256,uint256,int256,bool)'](user.address, 0, 0, 0, 0, false);\n  await showInfo()\n  await showVer(time)\n\n  time += 100;\n  setupOracle('0.5', time, time + 100);\n  await showInfo()\n  await showVer(time)\n})\n```\n\nConsole log:\n```solidity\nuser collateral = 10000000000\nuserB collateral = 0\nver1636401093: makerValue=0 longValue=0 makerPosFee=0 makerNegFee=0 takerPosFee=0 takerNegFee=0\nuser collateral = 10000090000\nuserB collateral = 10000000000\nver1636401193: makerValue=0 longValue=0 makerPosFee=9000 makerNegFee=0 takerPosFee=0 takerNegFee=0\nuser collateral = 10000090000\nuserB collateral = 10000070000\nver1636401293: makerValue=0 longValue=0 makerPosFee=7000 makerNegFee=0 takerPosFee=0 takerNegFee=0\nuser collateral = 10000170000\nuserB collateral = 10000150000\nver1636401393: makerValue=8000 longValue=0 makerPosFee=0 makerNegFee=0 takerPosFee=0 takerNegFee=0\nuser collateral = 10000170000\nuserB collateral = 10000010000\nver1636401493: makerValue=8000 longValue=0 makerPosFee=0 makerNegFee=-14000 takerPosFee=0 takerNegFee=0\nuser collateral = 9999990000\nuserB collateral = 10000010000\nver1636401593: makerValue=-5500 longValue=0 makerPosFee=0 makerNegFee=-4500 takerPosFee=0 takerNegFee=0\n```\n\nNotice, that final user balance is -0.1 and final userB balance is +0.1\n\n## Code Snippet\n\nMaker exposure is applied to `makerValue`, meaning it's weighted by maker position size:\nhttps://github.com/sherlock-audit/2024-02-perennial-v2-3/blob/main/perennial-v2/packages/perennial/contracts/libs/VersionLib.sol#L314\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nSplit the total maker exposure by individual maker's exposure rather than by their position size. To do this:\n- Add another accumulator to track total exposure\n- Add individual maker `exposure` to user's `Local` storage\n- When accumulating local storage in the checkpoint, account global accumulator exposure weighted by individual user's exposure.\n\n\n\n## Discussion\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/equilibria-xyz/perennial-v2/pull/300\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/254",
  "Code": [
    {
      "filename": "perennial-v2/packages/perennial/contracts/libs/VersionLib.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/accumulator/types/Accumulator6.sol\";\nimport \"@equilibria/root/accumulator/types/UAccumulator6.sol\";\nimport \"../types/ProtocolParameter.sol\";\nimport \"../types/MarketParameter.sol\";\nimport \"../types/RiskParameter.sol\";\nimport \"../types/Global.sol\";\nimport \"../types/Position.sol\";\nimport \"../types/Version.sol\";\n\n/// @dev Individual accumulation values\nstruct VersionAccumulationResult {\n    UFixed6 positionFee;\n    UFixed6 positionFeeMaker;\n    UFixed6 positionFeeProtocol;\n    UFixed6 positionFeeSubtractive;\n    Fixed6 positionFeeExposure;\n    Fixed6 positionFeeExposureMaker;\n    Fixed6 positionFeeExposureProtocol;\n    Fixed6 positionFeeImpact;\n\n    Fixed6 fundingMaker;\n    Fixed6 fundingLong;\n    Fixed6 fundingShort;\n    UFixed6 fundingFee;\n\n    Fixed6 interestMaker;\n    Fixed6 interestLong;\n    Fixed6 interestShort;\n    UFixed6 interestFee;\n\n    Fixed6 pnlMaker;\n    Fixed6 pnlLong;\n    Fixed6 pnlShort;\n\n    UFixed6 settlementFee;\n    UFixed6 liquidationFee;\n}\n\n/// @title VersionLib\n/// @notice Manages the logic for the global order accumualation\nlibrary VersionLib {\n    struct AccumulationContext {\n        Global global;\n        Position fromPosition;\n        Order order;\n        OracleVersion fromOracleVersion;\n        OracleVersion toOracleVersion;\n        MarketParameter marketParameter;\n        RiskParameter riskParameter;\n    }\n\n    /// @notice Accumulates the global state for the period from `fromVersion` to `toOracleVersion`\n    /// @param self The Version object to update\n    /// @param global The global state\n    /// @param fromPosition The previous latest position\n    /// @param order The new order\n    /// @param fromOracleVersion The previous latest oracle version\n    /// @param toOracleVersion The next latest oracle version\n    /// @param marketParameter The market parameter\n    /// @param riskParameter The risk parameter\n    /// @return next The accumulated version\n    /// @return nextGlobal The next global state\n    /// @return result The accumulation result\n    function accumulate(\n        Version memory self,\n        Global memory global,\n        Position memory fromPosition,\n        Order memory order,\n        OracleVersion memory fromOracleVersion,\n        OracleVersion memory toOracleVersion,\n        MarketParameter memory marketParameter,\n        RiskParameter memory riskParameter\n    ) external pure returns (Version memory next, Global memory nextGlobal, VersionAccumulationResult memory result) {\n        AccumulationContext memory context = AccumulationContext(\n            global,\n            fromPosition,\n            order,\n            fromOracleVersion,\n            toOracleVersion,\n            marketParameter,\n            riskParameter\n        );\n\n        // setup next accumulators\n        _next(self, next);\n\n        // record validity\n        next.valid = toOracleVersion.valid;\n\n        // accumulate settlement fee\n        result.settlementFee = _accumulateSettlementFee(next, context);\n\n        // accumulate liquidation fee\n        result.liquidationFee = _accumulateLiquidationFee(next, context);\n\n        // accumulate linear fee\n        _accumulateLinearFee(next, context, result);\n\n        // accumulate proportional fee\n        _accumulateProportionalFee(next, context, result);\n\n        // accumulate adiabatic fee\n        _accumulateAdiabaticFee(next, context, result);\n\n        // if closed, don't accrue anything else\n        if (marketParameter.closed) return (next, global, result);\n\n        // accumulate funding\n        (result.fundingMaker, result.fundingLong, result.fundingShort, result.fundingFee) =\n            _accumulateFunding(next, context);\n\n        // accumulate interest\n        (result.interestMaker, result.interestLong, result.interestShort, result.interestFee) =\n            _accumulateInterest(next, context);\n\n        // accumulate P&L\n        (result.pnlMaker, result.pnlLong, result.pnlShort) = _accumulatePNL(next, context);\n\n        return (next, global, result);\n    }\n\n    /// @notice Copies over the version-over-version accumulators to prepare the next version\n    /// @param self The Version object to update\n    function _next(Version memory self, Version memory next) internal pure {\n        next.makerValue._value = self.makerValue._value;\n        next.longValue._value = self.longValue._value;\n        next.shortValue._value = self.shortValue._value;\n    }\n\n    /// @notice Globally accumulates settlement fees since last oracle update\n    /// @param next The Version object to update\n    /// @param context The accumulation context\n    function _accumulateSettlementFee(\n        Version memory next,\n        AccumulationContext memory context\n    ) private pure returns (UFixed6 settlementFee) {\n        settlementFee = context.order.orders == 0 ? UFixed6Lib.ZERO : context.marketParameter.settlementFee;\n        next.settlementFee.decrement(Fixed6Lib.from(settlementFee), UFixed6Lib.from(context.order.orders));\n    }\n\n    /// @notice Globally accumulates hypothetical liquidation fee since last oracle update\n    /// @param next The Version object to update\n    /// @param context The accumulation context\n    function _accumulateLiquidationFee(\n        Version memory next,\n        AccumulationContext memory context\n    ) private pure returns (UFixed6 liquidationFee) {\n        liquidationFee = context.toOracleVersion.valid ? context.riskParameter.liquidationFee : UFixed6Lib.ZERO;\n        next.liquidationFee.decrement(Fixed6Lib.from(liquidationFee), UFixed6Lib.ONE);\n    }\n\n    /// @notice Globally accumulates linear fees since last oracle update\n    /// @param next The Version object to update\n    /// @param context The accumulation context\n    function _accumulateLinearFee(\n        Version memory next,\n        AccumulationContext memory context,\n        VersionAccumulationResult memory result\n    ) private pure {\n        (UFixed6 makerLinearFee, UFixed6 makerSubtractiveFee) = _accumulateSubtractiveFee(\n            context.riskParameter.makerFee.linear(\n                Fixed6Lib.from(context.order.makerTotal()),\n                context.toOracleVersion.price.abs()\n            ),\n            context.order.makerTotal(),\n            context.order.makerReferral,\n            next.makerLinearFee\n        );\n\n        (UFixed6 takerLinearFee, UFixed6 takerSubtractiveFee) = _accumulateSubtractiveFee(\n            context.riskParameter.takerFee.linear(\n                Fixed6Lib.from(context.order.takerTotal()),\n                context.toOracleVersion.price.abs()\n            ),\n            context.order.takerTotal(),\n            context.order.takerReferral,\n            next.takerLinearFee\n        );\n\n        UFixed6 linearFee = makerLinearFee.add(takerLinearFee);\n\n        UFixed6 protocolFee = context.fromPosition.maker.isZero() ?\n            linearFee :\n            context.marketParameter.positionFee.mul(linearFee);\n        UFixed6 positionFeeMaker = linearFee.sub(protocolFee);\n        next.makerValue.increment(Fixed6Lib.from(positionFeeMaker), context.fromPosition.maker);\n\n        result.positionFee = result.positionFee.add(linearFee);\n        result.positionFeeMaker = result.positionFeeMaker.add(positionFeeMaker);\n        result.positionFeeProtocol = result.positionFeeProtocol.add(protocolFee);\n        result.positionFeeSubtractive = result.positionFeeSubtractive.add(makerSubtractiveFee).add(takerSubtractiveFee);\n    }\n\n    /// @notice Globally accumulates subtractive fees since last oracle update\n    /// @param linearFee The linear fee to accumulate\n    /// @param total The total order size for the fee\n    /// @param referral The referral size for the fee\n    /// @param linearFeeAccumulator The accumulator for the linear fee\n    /// @return newLinearFee The new linear fee after subtractive fees\n    /// @return subtractiveFee The total subtractive fee\n    function _accumulateSubtractiveFee(\n        UFixed6 linearFee,\n        UFixed6 total,\n        UFixed6 referral,\n        Accumulator6 memory linearFeeAccumulator\n    ) private pure returns (UFixed6 newLinearFee, UFixed6 subtractiveFee) {\n        linearFeeAccumulator.decrement(Fixed6Lib.from(linearFee), total);\n        subtractiveFee = total.isZero() ? UFixed6Lib.ZERO : linearFee.muldiv(referral, total);\n        newLinearFee = linearFee.sub(subtractiveFee);\n    }\n\n    /// @notice Globally accumulates proportional fees since last oracle update\n    /// @param next The Version object to update\n    /// @param context The accumulation context\n    function _accumulateProportionalFee(\n        Version memory next,\n        AccumulationContext memory context,\n        VersionAccumulationResult memory result\n    ) private pure {\n        UFixed6 makerProportionalFee = context.riskParameter.makerFee.proportional(\n            Fixed6Lib.from(context.order.makerTotal()),\n            context.toOracleVersion.price.abs()\n        );\n        next.makerProportionalFee.decrement(Fixed6Lib.from(makerProportionalFee), context.order.makerTotal());\n\n        UFixed6 takerProportionalFee = context.riskParameter.takerFee.proportional(\n            Fixed6Lib.from(context.order.takerTotal()),\n            context.toOracleVersion.price.abs()\n        );\n        next.takerProportionalFee.decrement(Fixed6Lib.from(takerProportionalFee), context.order.takerTotal());\n\n        UFixed6 proportionalFee = makerProportionalFee.add(takerProportionalFee);\n        UFixed6 protocolFee = context.fromPosition.maker.isZero() ?\n            proportionalFee :\n            context.marketParameter.positionFee.mul(proportionalFee);\n        UFixed6 positionFeeMaker = proportionalFee.sub(protocolFee);\n        next.makerValue.increment(Fixed6Lib.from(positionFeeMaker), context.fromPosition.maker);\n\n        result.positionFee = result.positionFee.add(proportionalFee);\n        result.positionFeeMaker = result.positionFeeMaker.add(positionFeeMaker);\n        result.positionFeeProtocol = result.positionFeeProtocol.add(protocolFee);\n    }\n\n    /// @notice Globally accumulates adiabatic fees since last oracle update\n    /// @param next The Version object to update\n    /// @param context The accumulation context\n    function _accumulateAdiabaticFee(\n        Version memory next,\n        AccumulationContext memory context,\n        VersionAccumulationResult memory result\n    ) private pure {\n        Fixed6 exposure = context.riskParameter.takerFee.exposure(context.fromPosition.skew())\n            .add(context.riskParameter.makerFee.exposure(context.fromPosition.maker));\n\n        _accumulatePositionFeeComponentExposure(next, context, result, exposure);\n\n        Fixed6 adiabaticFee;\n\n        // position fee from positive skew taker orders\n        adiabaticFee = context.riskParameter.takerFee.adiabatic(\n            context.fromPosition.skew(),\n            Fixed6Lib.from(context.order.takerPos()),\n            context.toOracleVersion.price.abs()\n        );\n        next.takerPosFee.decrement(adiabaticFee, context.order.takerPos());\n        result.positionFeeImpact = result.positionFeeImpact.add(adiabaticFee);\n\n        // position fee from negative skew taker orders\n        adiabaticFee = context.riskParameter.takerFee.adiabatic(\n            context.fromPosition.skew().add(Fixed6Lib.from(context.order.takerPos())),\n            Fixed6Lib.from(-1, context.order.takerNeg()),\n            context.toOracleVersion.price.abs()\n        );\n        next.takerNegFee.decrement(adiabaticFee, context.order.takerNeg());\n        result.positionFeeImpact = result.positionFeeImpact.add(adiabaticFee);\n\n        // position fee from negative skew maker orders\n        adiabaticFee = context.riskParameter.makerFee.adiabatic(\n            context.fromPosition.maker,\n            Fixed6Lib.from(-1, context.order.makerNeg),\n            context.toOracleVersion.price.abs()\n        );\n        next.makerNegFee.decrement(adiabaticFee, context.order.makerNeg);\n        result.positionFeeImpact = result.positionFeeImpact.add(adiabaticFee);\n\n        // position fee from positive skew maker orders\n        adiabaticFee = context.riskParameter.makerFee.adiabatic(\n            context.fromPosition.maker.sub(context.order.makerNeg),\n            Fixed6Lib.from(context.order.makerPos),\n            context.toOracleVersion.price.abs()\n        );\n        next.makerPosFee.decrement(adiabaticFee, context.order.makerPos);\n        result.positionFeeImpact = result.positionFeeImpact.add(adiabaticFee);\n    }\n\n    /// @notice Globally accumulates single component of the position fees exposure since last oracle update\n    /// @param next The Version object to update\n    /// @param context The accumulation context\n    /// @param result The accumulation result\n    /// @param latestExposure The latest exposure\n    function _accumulatePositionFeeComponentExposure(\n        Version memory next,\n        AccumulationContext memory context,\n        VersionAccumulationResult memory result,\n        Fixed6 latestExposure\n    ) private pure {\n        Fixed6 impactExposure = context.toOracleVersion.price.sub(context.fromOracleVersion.price).mul(latestExposure);\n        Fixed6 impactExposureMaker = impactExposure.mul(Fixed6Lib.NEG_ONE);\n        Fixed6 impactExposureProtocol = context.fromPosition.maker.isZero() ? impactExposureMaker : Fixed6Lib.ZERO;\n        impactExposureMaker = impactExposureMaker.sub(impactExposureProtocol);\n        next.makerValue.increment(impactExposureMaker, context.fromPosition.maker);\n\n        result.positionFeeExposure = impactExposure;\n        result.positionFeeExposureProtocol = impactExposureProtocol;\n        result.positionFeeExposureMaker = impactExposureMaker;\n    }\n\n    /// @notice Globally accumulates all long-short funding since last oracle update\n    /// @param next The Version object to update\n    /// @param context The accumulation context\n    /// @return fundingMaker The total funding accrued by makers\n    /// @return fundingLong The total funding accrued by longs\n    /// @return fundingShort The total funding accrued by shorts\n    /// @return fundingFee The total fee accrued from funding accumulation\n    function _accumulateFunding(Version memory next, AccumulationContext memory context) private pure returns (\n        Fixed6 fundingMaker,\n        Fixed6 fundingLong,\n        Fixed6 fundingShort,\n        UFixed6 fundingFee\n    ) {\n        Fixed6 toSkew = context.toOracleVersion.valid ?\n            context.fromPosition.skew().add(context.order.long()).sub(context.order.short()) :\n            context.fromPosition.skew();\n\n        // Compute long-short funding rate\n        Fixed6 funding = context.global.pAccumulator.accumulate(\n            context.riskParameter.pController,\n            toSkew.unsafeDiv(Fixed6Lib.from(context.riskParameter.takerFee.scale)).min(Fixed6Lib.ONE).max(Fixed6Lib.NEG_ONE),\n            context.fromOracleVersion.timestamp,\n            context.toOracleVersion.timestamp,\n            context.fromPosition.takerSocialized().mul(context.fromOracleVersion.price.abs())\n        );\n\n        // Handle maker receive-only status\n        if (context.riskParameter.makerReceiveOnly && funding.sign() != context.fromPosition.skew().sign())\n            funding = funding.mul(Fixed6Lib.NEG_ONE);\n\n        // Initialize long and short funding\n        (fundingLong, fundingShort) = (Fixed6Lib.NEG_ONE.mul(funding), funding);\n\n        // Compute fee spread\n        fundingFee = funding.abs().mul(context.marketParameter.fundingFee);\n        Fixed6 fundingSpread = Fixed6Lib.from(fundingFee).div(Fixed6Lib.from(2));\n\n        // Adjust funding with spread\n        (fundingLong, fundingShort) = (\n            fundingLong.sub(Fixed6Lib.from(fundingFee)).add(fundingSpread),\n            fundingShort.sub(fundingSpread)\n        );\n\n        // Redirect net portion of minor's side to maker\n        if (context.fromPosition.long.gt(context.fromPosition.short)) {\n            fundingMaker = fundingShort.mul(Fixed6Lib.from(context.fromPosition.socializedMakerPortion()));\n            fundingShort = fundingShort.sub(fundingMaker);\n        }\n        if (context.fromPosition.short.gt(context.fromPosition.long)) {\n            fundingMaker = fundingLong.mul(Fixed6Lib.from(context.fromPosition.socializedMakerPortion()));\n            fundingLong = fundingLong.sub(fundingMaker);\n        }\n\n        next.makerValue.increment(fundingMaker, context.fromPosition.maker);\n        next.longValue.increment(fundingLong, context.fromPosition.long);\n        next.shortValue.increment(fundingShort, context.fromPosition.short);\n    }\n\n    /// @notice Globally accumulates all maker interest since last oracle update\n    /// @param next The Version object to update\n    /// @param context The accumulation context\n    /// @return interestMaker The total interest accrued by makers\n    /// @return interestLong The total interest accrued by longs\n    /// @return interestShort The total interest accrued by shorts\n    /// @return interestFee The total fee accrued from interest accumulation\n    function _accumulateInterest(\n        Version memory next,\n        AccumulationContext memory context\n    ) private pure returns (Fixed6 interestMaker, Fixed6 interestLong, Fixed6 interestShort, UFixed6 interestFee) {\n        UFixed6 notional = context.fromPosition.long.add(context.fromPosition.short).min(context.fromPosition.maker).mul(context.fromOracleVersion.price.abs());\n\n        // Compute maker interest\n        UFixed6 interest = context.riskParameter.utilizationCurve.accumulate(\n            context.fromPosition.utilization(context.riskParameter),\n            context.fromOracleVersion.timestamp,\n            context.toOracleVersion.timestamp,\n            notional\n        );\n\n        // Compute fee\n        interestFee = interest.mul(context.marketParameter.interestFee);\n\n        // Adjust long and short funding with spread\n        interestLong = Fixed6Lib.from(\n            context.fromPosition.major().isZero() ?\n            interest :\n            interest.muldiv(context.fromPosition.long, context.fromPosition.long.add(context.fromPosition.short))\n        );\n        interestShort = Fixed6Lib.from(interest).sub(interestLong);\n        interestMaker = Fixed6Lib.from(interest.sub(interestFee));\n\n        interestLong = interestLong.mul(Fixed6Lib.NEG_ONE);\n        interestShort = interestShort.mul(Fixed6Lib.NEG_ONE);\n        next.makerValue.increment(interestMaker, context.fromPosition.maker);\n        next.longValue.increment(interestLong, context.fromPosition.long);\n        next.shortValue.increment(interestShort, context.fromPosition.short);\n    }\n\n    /// @notice Globally accumulates position profit & loss since last oracle update\n    /// @param next The Version object to update\n    /// @param context The accumulation context\n    /// @return pnlMaker The total pnl accrued by makers\n    /// @return pnlLong The total pnl accrued by longs\n    /// @return pnlShort The total pnl accrued by shorts\n    function _accumulatePNL(\n        Version memory next,\n        AccumulationContext memory context\n    ) private pure returns (Fixed6 pnlMaker, Fixed6 pnlLong, Fixed6 pnlShort) {\n        pnlLong = context.toOracleVersion.price.sub(context.fromOracleVersion.price)\n            .mul(Fixed6Lib.from(context.fromPosition.longSocialized()));\n        pnlShort = context.fromOracleVersion.price.sub(context.toOracleVersion.price)\n            .mul(Fixed6Lib.from(context.fromPosition.shortSocialized()));\n        pnlMaker = pnlLong.add(pnlShort).mul(Fixed6Lib.NEG_ONE);\n\n        next.longValue.increment(pnlLong, context.fromPosition.long);\n        next.shortValue.increment(pnlShort, context.fromPosition.short);\n        next.makerValue.increment(pnlMaker, context.fromPosition.maker);\n    }\n}"
    }
  ]
}