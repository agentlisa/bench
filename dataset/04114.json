{
  "Title": "Overestimation of Liquidity in Interest Rate Update.",
  "Content": "##### Description\nhttps://github.com/aave/protocol-v2/blob/f435b2fa0ac589852ca3dd6ae2b0fbfbc7079d54/contracts/lendingpool/LendingPool.sol#L582\n\n```solidity\nIERC20(asset).safeTransferFrom(receiverAddress, vars.aTokenAddress, vars.amountPlusPremium);\n\nreserve.updateState();\nreserve.cumulateToLiquidityIndex(IERC20(vars.aTokenAddress).totalSupply(), vars.premium);\nreserve.updateInterestRates(asset, vars.aTokenAddress, vars.premium, 0);\n```\n\nhttps://github.com/aave/protocol-v2/blob/f435b2fa0ac589852ca3dd6ae2b0fbfbc7079d54/contracts/lendingpool/LendingPoolCollateralManager.sol#L521\n\n```solidity\nIERC20(toAsset).safeTransferFrom(\n    receiverAddress,\n    address(vars.toReserveAToken),\n    vars.amountToReceive\n);\n\nif (vars.toReserveAToken.balanceOf(msg.sender) == 0) {\n    _usersConfig[msg.sender].setUsingAsCollateral(toReserve.id, true);\n}\n\nvars.toReserveAToken.mint(msg.sender, vars.amountToReceive, toReserve.liquidityIndex);\ntoReserve.updateInterestRates(\n    toAsset,\n    address(vars.toReserveAToken),\n    vars.amountToReceive,\n    0\n);\n```\n\n`updateInterestRates` needs to be called with `liquidityAdded` set to `0` since liquidity was already transferred to the pool's balance. Otherwise, overestimated liquidity would lead to too low debt interest rates.\n\n##### Recommendation\n\nIt is recommended to call `updateInterestRates` with `liquidityAdded` set to `0`.\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/lendingpool/LendingPool.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.6.8;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from '@openzeppelin/contracts/math/SafeMath.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {\n  VersionedInitializable\n} from '../libraries/openzeppelin-upgradeability/VersionedInitializable.sol';\nimport {ILendingPoolAddressesProvider} from '../interfaces/ILendingPoolAddressesProvider.sol';\nimport {IAToken} from '../tokenization/interfaces/IAToken.sol';\nimport {Helpers} from '../libraries/helpers/Helpers.sol';\nimport {Errors} from '../libraries/helpers/Errors.sol';\nimport {WadRayMath} from '../libraries/math/WadRayMath.sol';\nimport {PercentageMath} from '../libraries/math/PercentageMath.sol';\nimport {ReserveLogic} from '../libraries/logic/ReserveLogic.sol';\nimport {GenericLogic} from '../libraries/logic/GenericLogic.sol';\nimport {ValidationLogic} from '../libraries/logic/ValidationLogic.sol';\nimport {ReserveConfiguration} from '../libraries/configuration/ReserveConfiguration.sol';\nimport {UserConfiguration} from '../libraries/configuration/UserConfiguration.sol';\nimport {IStableDebtToken} from '../tokenization/interfaces/IStableDebtToken.sol';\nimport {IVariableDebtToken} from '../tokenization/interfaces/IVariableDebtToken.sol';\nimport {DebtTokenBase} from '../tokenization/base/DebtTokenBase.sol';\nimport {IFlashLoanReceiver} from '../flashloan/interfaces/IFlashLoanReceiver.sol';\nimport {ISwapAdapter} from '../interfaces/ISwapAdapter.sol';\nimport {LendingPoolCollateralManager} from './LendingPoolCollateralManager.sol';\nimport {IPriceOracleGetter} from '../interfaces/IPriceOracleGetter.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport {ILendingPool} from '../interfaces/ILendingPool.sol';\nimport {LendingPoolStorage} from './LendingPoolStorage.sol';\nimport {IReserveInterestRateStrategy} from '../interfaces/IReserveInterestRateStrategy.sol';\n/**\n * @title LendingPool contract\n * @notice Implements the actions of the LendingPool, and exposes accessory methods to fetch the users and reserve data\n * @author Aave\n **/\ncontract LendingPool is VersionedInitializable, ILendingPool, LendingPoolStorage {\n  using SafeMath for uint256;\n  using WadRayMath for uint256;\n  using PercentageMath for uint256;\n  using SafeERC20 for IERC20;\n\n  //main configuration parameters\n  uint256 public constant REBALANCE_UP_LIQUIDITY_RATE_THRESHOLD = 4000;\n  uint256 public constant REBALANCE_UP_USAGE_RATIO_THRESHOLD = 0.95 * 1e27; //usage ratio of 95%\n  uint256 public constant MAX_STABLE_RATE_BORROW_SIZE_PERCENT = 2500;\n  uint256 public constant FLASHLOAN_PREMIUM_TOTAL = 9;\n  uint256 public constant MAX_NUMBER_RESERVES = 128;\n  uint256 public constant LENDINGPOOL_REVISION = 0x2;\n\n  /**\n   * @dev only lending pools configurator can use functions affected by this modifier\n   **/\n  function _onlyLendingPoolConfigurator() internal view {\n    require(\n      _addressesProvider.getLendingPoolConfigurator() == msg.sender,\n      Errors.CALLER_NOT_LENDING_POOL_CONFIGURATOR\n    );\n  }\n  /**\n   * @dev Function to make a function callable only when the contract is not paused.\n   *\n   * Requirements:\n   *\n   * - The contract must not be paused.\n   */\n  function _whenNotPaused() internal view {\n    require(!_paused, Errors.IS_PAUSED);\n  }\n\n  function getRevision() internal override pure returns (uint256) {\n    return LENDINGPOOL_REVISION;\n  }\n\n  /**\n   * @dev this function is invoked by the proxy contract when the LendingPool contract is added to the\n   * AddressesProvider.\n   * @param provider the address of the LendingPoolAddressesProvider registry\n   **/\n  function initialize(ILendingPoolAddressesProvider provider) public initializer {\n    _addressesProvider = provider;\n  }\n\n  /**\n   * @dev deposits The underlying asset into the reserve. A corresponding amount of the overlying asset (aTokens)\n   * is minted.\n   * @param asset the address of the reserve\n   * @param amount the amount to be deposited\n   * @param referralCode integrators are assigned a referral code and can potentially receive rewards.\n   **/\n  function deposit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external override {\n    _whenNotPaused();\n    ReserveLogic.ReserveData storage reserve = _reserves[asset];\n\n    ValidationLogic.validateDeposit(reserve, amount);\n\n    address aToken = reserve.aTokenAddress;\n\n    reserve.updateState();\n    reserve.updateInterestRates(asset, aToken, amount, 0);\n\n    bool isFirstDeposit = IAToken(aToken).balanceOf(onBehalfOf) == 0;\n    if (isFirstDeposit) {\n      _usersConfig[onBehalfOf].setUsingAsCollateral(reserve.id, true);\n    }\n\n    IAToken(aToken).mint(onBehalfOf, amount, reserve.liquidityIndex);\n\n    //transfer to the aToken contract\n    IERC20(asset).safeTransferFrom(msg.sender, aToken, amount);\n\n    emit Deposit(asset, msg.sender, onBehalfOf, amount, referralCode);\n  }\n\n  /**\n   * @dev withdraws the _reserves of user.\n   * @param asset the address of the reserve\n   * @param amount the underlying amount to be redeemed\n   **/\n  function withdraw(address asset, uint256 amount) external override {\n    _whenNotPaused();\n    ReserveLogic.ReserveData storage reserve = _reserves[asset];\n\n    address aToken = reserve.aTokenAddress;\n\n    uint256 userBalance = IAToken(aToken).balanceOf(msg.sender);\n\n    uint256 amountToWithdraw = amount;\n\n    //if amount is equal to uint(-1), the user wants to redeem everything\n    if (amount == type(uint256).max) {\n      amountToWithdraw = userBalance;\n    }\n\n    ValidationLogic.validateWithdraw(\n      asset,\n      amountToWithdraw,\n      userBalance,\n      _reserves,\n      _usersConfig[msg.sender],\n      _reservesList,\n      _addressesProvider.getPriceOracle()\n    );\n\n    reserve.updateState();\n\n    reserve.updateInterestRates(asset, aToken, 0, amountToWithdraw);\n\n    if (amountToWithdraw == userBalance) {\n      _usersConfig[msg.sender].setUsingAsCollateral(reserve.id, false);\n    }\n\n    IAToken(aToken).burn(msg.sender, msg.sender, amountToWithdraw, reserve.liquidityIndex);\n\n    emit Withdraw(asset, msg.sender, amount);\n  }\n\n  /**\n   * @dev returns the borrow allowance of the user\n   * @param asset The underlying asset of the debt token\n   * @param fromUser The user to giving allowance\n   * @param toUser The user to give allowance to\n   * @param interestRateMode Type of debt: 1 for stable, 2 for variable\n   * @return the current allowance of toUser\n   **/\n  function getBorrowAllowance(\n    address fromUser,\n    address toUser,\n    address asset,\n    uint256 interestRateMode\n  ) external override view returns (uint256) {\n    return\n      _borrowAllowance[_reserves[asset].getDebtTokenAddress(interestRateMode)][fromUser][toUser];\n  }\n\n  /**\n   * @dev Sets allowance to borrow on a certain type of debt asset for a certain user address\n   * @param asset The underlying asset of the debt token\n   * @param user The user to give allowance to\n   * @param interestRateMode Type of debt: 1 for stable, 2 for variable\n   * @param amount Allowance amount to borrow\n   **/\n  function delegateBorrowAllowance(\n    address asset,\n    address user,\n    uint256 interestRateMode,\n    uint256 amount\n  ) external override {\n    _whenNotPaused();\n    address debtToken = _reserves[asset].getDebtTokenAddress(interestRateMode);\n\n    _borrowAllowance[debtToken][msg.sender][user] = amount;\n    emit BorrowAllowanceDelegated(asset, msg.sender, user, interestRateMode, amount);\n  }\n\n  /**\n   * @dev Allows users to borrow a specific amount of the reserve currency, provided that the borrower\n   * already deposited enough collateral.\n   * @param asset the address of the reserve\n   * @param amount the amount to be borrowed\n   * @param interestRateMode the interest rate mode at which the user wants to borrow. Can be 0 (STABLE) or 1 (VARIABLE)\n   * @param referralCode a referral code for integrators\n   * @param onBehalfOf address of the user who will receive the debt\n   **/\n  function borrow(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    uint16 referralCode,\n    address onBehalfOf\n  ) external override {\n    _whenNotPaused();\n    ReserveLogic.ReserveData storage reserve = _reserves[asset];\n\n    if (onBehalfOf != msg.sender) {\n      address debtToken = reserve.getDebtTokenAddress(interestRateMode);\n\n      _borrowAllowance[debtToken][onBehalfOf][msg\n        .sender] = _borrowAllowance[debtToken][onBehalfOf][msg.sender].sub(\n        amount,\n        Errors.BORROW_ALLOWANCE_ARE_NOT_ENOUGH\n      );\n    }\n    _executeBorrow(\n      ExecuteBorrowParams(\n        asset,\n        msg.sender,\n        onBehalfOf,\n        amount,\n        interestRateMode,\n        reserve.aTokenAddress,\n        referralCode,\n        true\n      )\n    );\n  }\n\n  /**\n   * @notice repays a borrow on the specific reserve, for the specified amount (or for the whole amount, if uint256(-1) is specified).\n   * @dev the target user is defined by onBehalfOf. If there is no repayment on behalf of another account,\n   * onBehalfOf must be equal to msg.sender.\n   * @param asset the address of the reserve on which the user borrowed\n   * @param amount the amount to repay, or uint256(-1) if the user wants to repay everything\n   * @param onBehalfOf the address for which msg.sender is repaying.\n   **/\n  function repay(\n    address asset,\n    uint256 amount,\n    uint256 rateMode,\n    address onBehalfOf\n  ) external override {\n    _whenNotPaused();\n\n    ReserveLogic.ReserveData storage reserve = _reserves[asset];\n\n    (uint256 stableDebt, uint256 variableDebt) = Helpers.getUserCurrentDebt(onBehalfOf, reserve);\n\n    ReserveLogic.InterestRateMode interestRateMode = ReserveLogic.InterestRateMode(rateMode);\n\n    //default to max amount\n    uint256 paybackAmount = interestRateMode == ReserveLogic.InterestRateMode.STABLE\n      ? stableDebt\n      : variableDebt;\n\n    if (amount != type(uint256).max && amount < paybackAmount) {\n      paybackAmount = amount;\n    }\n\n    ValidationLogic.validateRepay(\n      reserve,\n      amount,\n      interestRateMode,\n      onBehalfOf,\n      stableDebt,\n      variableDebt\n    );\n\n    reserve.updateState();\n\n    //burns an equivalent amount of debt tokens\n    if (interestRateMode == ReserveLogic.InterestRateMode.STABLE) {\n      IStableDebtToken(reserve.stableDebtTokenAddress).burn(onBehalfOf, paybackAmount);\n    } else {\n      IVariableDebtToken(reserve.variableDebtTokenAddress).burn(\n        onBehalfOf,\n        paybackAmount,\n        reserve.variableBorrowIndex\n      );\n    }\n\n    address aToken = reserve.aTokenAddress;\n    reserve.updateInterestRates(asset, aToken, paybackAmount, 0);\n\n    if (stableDebt.add(variableDebt).sub(paybackAmount) == 0) {\n      _usersConfig[onBehalfOf].setBorrowing(reserve.id, false);\n    }\n\n    IERC20(asset).safeTransferFrom(msg.sender, aToken, paybackAmount);\n\n    emit Repay(asset, onBehalfOf, msg.sender, paybackAmount);\n  }\n\n  /**\n   * @dev borrowers can user this function to swap between stable and variable borrow rate modes.\n   * @param asset the address of the reserve on which the user borrowed\n   * @param rateMode the rate mode that the user wants to swap\n   **/\n  function swapBorrowRateMode(address asset, uint256 rateMode) external override {\n    _whenNotPaused();\n    ReserveLogic.ReserveData storage reserve = _reserves[asset];\n\n    (uint256 stableDebt, uint256 variableDebt) = Helpers.getUserCurrentDebt(msg.sender, reserve);\n\n    ReserveLogic.InterestRateMode interestRateMode = ReserveLogic.InterestRateMode(rateMode);\n\n    ValidationLogic.validateSwapRateMode(\n      reserve,\n      _usersConfig[msg.sender],\n      stableDebt,\n      variableDebt,\n      interestRateMode\n    );\n\n    reserve.updateState();\n\n    if (interestRateMode == ReserveLogic.InterestRateMode.STABLE) {\n      //burn stable rate tokens, mint variable rate tokens\n      IStableDebtToken(reserve.stableDebtTokenAddress).burn(msg.sender, stableDebt);\n      IVariableDebtToken(reserve.variableDebtTokenAddress).mint(\n        msg.sender,\n        stableDebt,\n        reserve.variableBorrowIndex\n      );\n    } else {\n      //do the opposite\n      IVariableDebtToken(reserve.variableDebtTokenAddress).burn(\n        msg.sender,\n        variableDebt,\n        reserve.variableBorrowIndex\n      );\n      IStableDebtToken(reserve.stableDebtTokenAddress).mint(\n        msg.sender,\n        variableDebt,\n        reserve.currentStableBorrowRate\n      );\n    }\n\n    reserve.updateInterestRates(asset, reserve.aTokenAddress, 0, 0);\n\n    emit Swap(asset, msg.sender);\n  }\n\n  /**\n   * @dev rebalances the stable interest rate of a user if current liquidity rate > user stable rate.\n   * this is regulated by Aave to ensure that the protocol is not abused, and the user is paying a fair\n   * rate. Anyone can call this function.\n   * @param asset the address of the reserve\n   * @param user the address of the user to be rebalanced\n   **/\n  function rebalanceStableBorrowRate(address asset, address user) external override {\n    \n    _whenNotPaused();\n    \n    ReserveLogic.ReserveData storage reserve = _reserves[asset];\n\n    IERC20 stableDebtToken = IERC20(reserve.stableDebtTokenAddress);\n    IERC20 variableDebtToken = IERC20(reserve.variableDebtTokenAddress);\n    address aTokenAddress = reserve.aTokenAddress;\n\n    uint256 stableBorrowBalance = IERC20(stableDebtToken).balanceOf(user);\n\n    //if the utilization rate is below 95%, no rebalances are needed\n    uint256 totalBorrows = stableDebtToken.totalSupply().add(variableDebtToken.totalSupply()).wadToRay();\n    uint256 availableLiquidity = IERC20(asset).balanceOf(aTokenAddress).wadToRay();\n    uint256 usageRatio = totalBorrows == 0\n      ? 0\n      : totalBorrows.rayDiv(availableLiquidity.add(totalBorrows));\n\n    //if the liquidity rate is below REBALANCE_UP_THRESHOLD of the max variable APR at 95% usage,\n    //then we allow rebalancing of the stable rate positions.\n\n    uint256 currentLiquidityRate = reserve.currentLiquidityRate;\n    uint256 maxVariableBorrowRate = IReserveInterestRateStrategy(\n      reserve\n        .interestRateStrategyAddress\n    )\n      .getMaxVariableBorrowRate();\n\n    require(\n      usageRatio >= REBALANCE_UP_USAGE_RATIO_THRESHOLD &&\n      currentLiquidityRate <=\n        maxVariableBorrowRate.percentMul(REBALANCE_UP_LIQUIDITY_RATE_THRESHOLD),\n      Errors.INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET\n    );\n\n    reserve.updateState();\n\n    IStableDebtToken(address(stableDebtToken)).burn(user, stableBorrowBalance);\n    IStableDebtToken(address(stableDebtToken)).mint(user, stableBorrowBalance, reserve.currentStableBorrowRate);\n\n    reserve.updateInterestRates(asset, aTokenAddress, 0, 0);\n\n    emit RebalanceStableBorrowRate(asset, user);\n\n  }\n\n  /**\n   * @dev allows depositors to enable or disable a specific deposit as collateral.\n   * @param asset the address of the reserve\n   * @param useAsCollateral true if the user wants to user the deposit as collateral, false otherwise.\n   **/\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external override {\n    _whenNotPaused();\n    ReserveLogic.ReserveData storage reserve = _reserves[asset];\n\n    ValidationLogic.validateSetUseReserveAsCollateral(\n      reserve,\n      asset,\n      _reserves,\n      _usersConfig[msg.sender],\n      _reservesList,\n      _addressesProvider.getPriceOracle()\n    );\n\n    _usersConfig[msg.sender].setUsingAsCollateral(reserve.id, useAsCollateral);\n\n    if (useAsCollateral) {\n      emit ReserveUsedAsCollateralEnabled(asset, msg.sender);\n    } else {\n      emit ReserveUsedAsCollateralDisabled(asset, msg.sender);\n    }\n  }\n\n  /**\n   * @dev users can invoke this function to liquidate an undercollateralized position.\n   * @param asset the address of the collateral to liquidated\n   * @param asset the address of the principal reserve\n   * @param user the address of the borrower\n   * @param purchaseAmount the amount of principal that the liquidator wants to repay\n   * @param receiveAToken true if the liquidators wants to receive the aTokens, false if\n   * he wants to receive the underlying asset directly\n   **/\n  function liquidationCall(\n    address collateral,\n    address asset,\n    address user,\n    uint256 purchaseAmount,\n    bool receiveAToken\n  ) external override {\n    _whenNotPaused();\n    address collateralManager = _addressesProvider.getLendingPoolCollateralManager();\n\n    //solium-disable-next-line\n    (bool success, bytes memory result) = collateralManager.delegatecall(\n      abi.encodeWithSignature(\n        'liquidationCall(address,address,address,uint256,bool)',\n        collateral,\n        asset,\n        user,\n        purchaseAmount,\n        receiveAToken\n      )\n    );\n    require(success, Errors.LIQUIDATION_CALL_FAILED);\n\n    (uint256 returnCode, string memory returnMessage) = abi.decode(result, (uint256, string));\n\n    if (returnCode != 0) {\n      //error found\n      revert(string(abi.encodePacked(returnMessage)));\n    }\n  }\n\n  /**\n   * @dev flashes the underlying collateral on an user to swap for the owed asset and repay\n   * - Both the owner of the position and other liquidators can execute it\n   * - The owner can repay with his collateral at any point, no matter the health factor\n   * - Other liquidators can only use this function below 1 HF. To liquidate 50% of the debt > HF 0.98 or the whole below\n   * @param collateral The address of the collateral asset\n   * @param principal The address of the owed asset\n   * @param user Address of the borrower\n   * @param principalAmount Amount of the debt to repay. type(uint256).max to repay the maximum possible\n   * @param receiver Address of the contract receiving the collateral to swap\n   * @param params Variadic bytes param to pass with extra information to the receiver\n   **/\n  function repayWithCollateral(\n    address collateral,\n    address principal,\n    address user,\n    uint256 principalAmount,\n    address receiver,\n    bytes calldata params\n  ) external override {\n    _whenNotPaused();\n    require(!_flashLiquidationLocked, Errors.REENTRANCY_NOT_ALLOWED);\n    _flashLiquidationLocked = true;\n\n    address collateralManager = _addressesProvider.getLendingPoolCollateralManager();\n\n    //solium-disable-next-line\n    (bool success, bytes memory result) = collateralManager.delegatecall(\n      abi.encodeWithSignature(\n        'repayWithCollateral(address,address,address,uint256,address,bytes)',\n        collateral,\n        principal,\n        user,\n        principalAmount,\n        receiver,\n        params\n      )\n    );\n    require(success, Errors.FAILED_REPAY_WITH_COLLATERAL);\n\n    (uint256 returnCode, string memory returnMessage) = abi.decode(result, (uint256, string));\n\n    if (returnCode != 0) {\n      revert(string(abi.encodePacked(returnMessage)));\n    }\n\n    _flashLiquidationLocked = false;\n  }\n\n  struct FlashLoanLocalVars {\n    uint256 premium;\n    uint256 amountPlusPremium;\n    IFlashLoanReceiver receiver;\n    address aTokenAddress;\n    address oracle;\n  }\n\n  /**\n   * @dev allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned. NOTE There are security concerns for developers of flashloan receiver contracts\n   * that must be kept into consideration. For further details please visit https://developers.aave.com\n   * @param receiverAddress The address of the contract receiving the funds. The receiver should implement the IFlashLoanReceiver interface.\n   * @param asset The address of the principal reserve\n   * @param amount The amount requested for this flashloan\n   * @param mode Type of the debt to open if the flash loan is not returned. 0 -> Don't open any debt, just revert, 1 -> stable, 2 -> variable\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode Referral code of the flash loan\n   **/\n  function flashLoan(\n    address receiverAddress,\n    address asset,\n    uint256 amount,\n    uint256 mode,\n    bytes calldata params,\n    uint16 referralCode\n  ) external override {\n    _whenNotPaused();\n    ReserveLogic.ReserveData storage reserve = _reserves[asset];\n    FlashLoanLocalVars memory vars;\n\n    vars.aTokenAddress = reserve.aTokenAddress;\n\n    vars.premium = amount.mul(FLASHLOAN_PREMIUM_TOTAL).div(10000);\n\n    ValidationLogic.validateFlashloan(mode, vars.premium);\n\n    ReserveLogic.InterestRateMode debtMode = ReserveLogic.InterestRateMode(mode);\n\n    vars.receiver = IFlashLoanReceiver(receiverAddress);\n\n    //transfer funds to the receiver\n    IAToken(vars.aTokenAddress).transferUnderlyingTo(receiverAddress, amount);\n\n    //execute action of the receiver\n    vars.receiver.executeOperation(asset, amount, vars.premium, params);\n\n    vars.amountPlusPremium = amount.add(vars.premium);\n\n    if (debtMode == ReserveLogic.InterestRateMode.NONE) {\n      IERC20(asset).safeTransferFrom(receiverAddress, vars.aTokenAddress, vars.amountPlusPremium);\n\n      reserve.updateState();\n      reserve.cumulateToLiquidityIndex(IERC20(vars.aTokenAddress).totalSupply(), vars.premium);\n      reserve.updateInterestRates(asset, vars.aTokenAddress, vars.premium, 0);\n\n      emit FlashLoan(receiverAddress, asset, amount, vars.premium, referralCode);\n    } else {\n     //if the user didn't choose to return the funds, the system checks if there\n     //is enough collateral and eventually open a position\n      _executeBorrow(\n        ExecuteBorrowParams(\n          asset,\n          msg.sender,\n          msg.sender,\n          vars.amountPlusPremium,\n          mode,\n          vars.aTokenAddress,\n          referralCode,\n          false\n        )\n      );\n    }\n  }\n\n  /**\n   * @dev Allows an user to release one of his assets deposited in the protocol, even if it is used as collateral, to swap for another.\n   * - It's not possible to release one asset to swap for the same\n   * @param receiverAddress The address of the contract receiving the funds. The receiver should implement the ISwapAdapter interface\n   * @param fromAsset Asset to swap from\n   * @param toAsset Asset to swap to\n   * @param params a bytes array to be sent (if needed) to the receiver contract with extra data\n   **/\n  function swapLiquidity(\n    address receiverAddress,\n    address fromAsset,\n    address toAsset,\n    uint256 amountToSwap,\n    bytes calldata params\n  ) external override {\n    _whenNotPaused();\n    address collateralManager = _addressesProvider.getLendingPoolCollateralManager();\n\n    //solium-disable-next-line\n    (bool success, bytes memory result) = collateralManager.delegatecall(\n      abi.encodeWithSignature(\n        'swapLiquidity(address,address,address,uint256,bytes)',\n        receiverAddress,\n        fromAsset,\n        toAsset,\n        amountToSwap,\n        params\n      )\n    );\n    require(success, Errors.FAILED_COLLATERAL_SWAP);\n\n    (uint256 returnCode, string memory returnMessage) = abi.decode(result, (uint256, string));\n\n    if (returnCode != 0) {\n      revert(string(abi.encodePacked(returnMessage)));\n    }\n  }\n\n  /**\n   * @dev accessory functions to fetch data from the core contract\n   **/\n\n  function getReserveConfigurationData(address asset)\n    external\n    override\n    view\n    returns (\n      uint256 decimals,\n      uint256 ltv,\n      uint256 liquidationThreshold,\n      uint256 liquidationBonus,\n      uint256 reserveFactor,\n      address interestRateStrategyAddress,\n      bool usageAsCollateralEnabled,\n      bool borrowingEnabled,\n      bool stableBorrowRateEnabled,\n      bool isActive,\n      bool isFreezed\n    )\n  {\n    ReserveLogic.ReserveData storage reserve = _reserves[asset];\n\n    return (\n      reserve.configuration.getDecimals(),\n      reserve.configuration.getLtv(),\n      reserve.configuration.getLiquidationThreshold(),\n      reserve.configuration.getLiquidationBonus(),\n      reserve.configuration.getReserveFactor(),\n      reserve.interestRateStrategyAddress,\n      reserve.configuration.getLtv() != 0,\n      reserve.configuration.getBorrowingEnabled(),\n      reserve.configuration.getStableRateBorrowingEnabled(),\n      reserve.configuration.getActive(),\n      reserve.configuration.getFrozen()\n    );\n  }\n\n  function getReserveTokensAddresses(address asset)\n    external\n    override\n    view\n    returns (\n      address aTokenAddress,\n      address stableDebtTokenAddress,\n      address variableDebtTokenAddress\n    )\n  {\n    ReserveLogic.ReserveData storage reserve = _reserves[asset];\n\n    return (\n      reserve.aTokenAddress,\n      reserve.stableDebtTokenAddress,\n      reserve.variableDebtTokenAddress\n    );\n  }\n\n  function getReserveData(address asset)\n    external\n    override\n    view\n    returns (\n      uint256 availableLiquidity,\n      uint256 totalStableDebt,\n      uint256 totalVariableDebt,\n      uint256 liquidityRate,\n      uint256 variableBorrowRate,\n      uint256 stableBorrowRate,\n      uint256 averageStableBorrowRate,\n      uint256 liquidityIndex,\n      uint256 variableBorrowIndex,\n      uint40 lastUpdateTimestamp\n    )\n  {\n    ReserveLogic.ReserveData memory reserve = _reserves[asset];\n\n    return (\n      IERC20(asset).balanceOf(reserve.aTokenAddress),\n      IERC20(reserve.stableDebtTokenAddress).totalSupply(),\n      IERC20(reserve.variableDebtTokenAddress).totalSupply(),\n      reserve.currentLiquidityRate,\n      reserve.currentVariableBorrowRate,\n      reserve.currentStableBorrowRate,\n      IStableDebtToken(reserve.stableDebtTokenAddress).getAverageStableRate(),\n      reserve.liquidityIndex,\n      reserve.variableBorrowIndex,\n      reserve.lastUpdateTimestamp\n    );\n  }\n\n  function getUserAccountData(address user)\n    external\n    override\n    view\n    returns (\n      uint256 totalCollateralETH,\n      uint256 totalBorrowsETH,\n      uint256 availableBorrowsETH,\n      uint256 currentLiquidationThreshold,\n      uint256 ltv,\n      uint256 healthFactor\n    )\n  {\n    (\n      totalCollateralETH,\n      totalBorrowsETH,\n      ltv,\n      currentLiquidationThreshold,\n      healthFactor\n    ) = GenericLogic.calculateUserAccountData(\n      user,\n      _reserves,\n      _usersConfig[user],\n      _reservesList,\n      _addressesProvider.getPriceOracle()\n    );\n    \n    availableBorrowsETH = GenericLogic.calculateAvailableBorrowsETH(\n      totalCollateralETH,\n      totalBorrowsETH,\n      ltv\n    );\n  }\n\n  function getUserReserveData(address asset, address user)\n    external\n    override\n    view\n    returns (\n      uint256 currentATokenBalance,\n      uint256 currentStableDebt,\n      uint256 currentVariableDebt,\n      uint256 principalStableDebt,\n      uint256 scaledVariableDebt,\n      uint256 stableBorrowRate,\n      uint256 liquidityRate,\n      uint40 stableRateLastUpdated,\n      bool usageAsCollateralEnabled\n    )\n  {\n    ReserveLogic.ReserveData storage reserve = _reserves[asset];\n\n    currentATokenBalance = IERC20(reserve.aTokenAddress).balanceOf(user);\n    (currentStableDebt, currentVariableDebt) = Helpers.getUserCurrentDebt(user, reserve);\n    principalStableDebt = IStableDebtToken(reserve.stableDebtTokenAddress).principalBalanceOf(user);\n    scaledVariableDebt = IVariableDebtToken(reserve.variableDebtTokenAddress).scaledBalanceOf(user);\n    liquidityRate = reserve.currentLiquidityRate;\n    stableBorrowRate = IStableDebtToken(reserve.stableDebtTokenAddress).getUserStableRate(user);\n    stableRateLastUpdated = IStableDebtToken(reserve.stableDebtTokenAddress).getUserLastUpdated(\n      user\n    );\n    usageAsCollateralEnabled = _usersConfig[user].isUsingAsCollateral(reserve.id);\n  }\n\n  function getReserves() external override view returns (address[] memory) {\n    return _reservesList;\n  }\n\n  receive() external payable {\n    revert();\n  }\n\n  /**\n   * @dev initializes a reserve\n   * @param asset the address of the reserve\n   * @param aTokenAddress the address of the overlying aToken contract\n   * @param interestRateStrategyAddress the address of the interest rate strategy contract\n   **/\n  function initReserve(\n    address asset,\n    address aTokenAddress,\n    address stableDebtAddress,\n    address variableDebtAddress,\n    address interestRateStrategyAddress\n  ) external override {\n    _onlyLendingPoolConfigurator();\n    _reserves[asset].init(\n      aTokenAddress,\n      stableDebtAddress,\n      variableDebtAddress,\n      interestRateStrategyAddress\n    );\n    _addReserveToList(asset);\n  }\n\n  /**\n   * @dev updates the address of the interest rate strategy contract\n   * @param asset the address of the reserve\n   * @param rateStrategyAddress the address of the interest rate strategy contract\n   **/\n\n  function setReserveInterestRateStrategyAddress(address asset, address rateStrategyAddress)\n    external\n    override\n  {\n    _onlyLendingPoolConfigurator();\n    _reserves[asset].interestRateStrategyAddress = rateStrategyAddress;\n  }\n\n  function setConfiguration(address asset, uint256 configuration) external override {\n    _onlyLendingPoolConfigurator();\n    _reserves[asset].configuration.data = configuration;\n  }\n\n  function getConfiguration(address asset)\n    external\n    override\n    view\n    returns (ReserveConfiguration.Map memory)\n  {\n    return _reserves[asset].configuration;\n  }\n\n  // internal functions\n\n  struct ExecuteBorrowParams {\n    address asset;\n    address user;\n    address onBehalfOf;\n    uint256 amount;\n    uint256 interestRateMode;\n    address aTokenAddress;\n    uint16 referralCode;\n    bool releaseUnderlying;\n  }\n\n  /**\n   * @dev Internal function to execute a borrowing action, allowing to transfer or not the underlying\n   * @param vars Input struct for the borrowing action, in order to avoid STD errors\n   **/\n  function _executeBorrow(ExecuteBorrowParams memory vars) internal {\n    ReserveLogic.ReserveData storage reserve = _reserves[vars.asset];\n    UserConfiguration.Map storage userConfig = _usersConfig[vars.onBehalfOf];\n\n    address oracle = _addressesProvider.getPriceOracle();\n\n    uint256 amountInETH = IPriceOracleGetter(oracle).getAssetPrice(vars.asset).mul(vars.amount).div(\n      10**reserve.configuration.getDecimals()\n    );\n\n    ValidationLogic.validateBorrow(\n      reserve,\n      vars.onBehalfOf,\n      vars.amount,\n      amountInETH,\n      vars.interestRateMode,\n      MAX_STABLE_RATE_BORROW_SIZE_PERCENT,\n      _reserves,\n      userConfig,\n      _reservesList,\n      oracle\n    );\n\n    uint256 reserveId = reserve.id;\n    if (!userConfig.isBorrowing(reserveId)) {\n      userConfig.setBorrowing(reserveId, true);\n    }\n\n    reserve.updateState();\n\n    //caching the current stable borrow rate\n    uint256 currentStableRate = 0;\n\n    if (\n      ReserveLogic.InterestRateMode(vars.interestRateMode) == ReserveLogic.InterestRateMode.STABLE\n    ) {\n      currentStableRate = reserve.currentStableBorrowRate;\n\n      IStableDebtToken(reserve.stableDebtTokenAddress).mint(\n        vars.onBehalfOf,\n        vars.amount,\n        currentStableRate\n      );\n    } else {\n      IVariableDebtToken(reserve.variableDebtTokenAddress).mint(\n        vars.onBehalfOf,\n        vars.amount,\n        reserve.variableBorrowIndex\n      );\n    }\n\n    reserve.updateInterestRates(\n      vars.asset,\n      vars.aTokenAddress,\n      0,\n      vars.releaseUnderlying ? vars.amount : 0\n    );\n\n    if (vars.releaseUnderlying) {\n      IAToken(vars.aTokenAddress).transferUnderlyingTo(vars.user, vars.amount);\n    }\n\n    emit Borrow(\n      vars.asset,\n      vars.user,\n      vars.onBehalfOf,\n      vars.amount,\n      vars.interestRateMode,\n      ReserveLogic.InterestRateMode(vars.interestRateMode) == ReserveLogic.InterestRateMode.STABLE\n        ? currentStableRate\n        : reserve.currentVariableBorrowRate,\n      vars.referralCode\n    );\n  }\n\n  /**\n   * @dev adds a reserve to the array of the _reserves address\n   **/\n  function _addReserveToList(address asset) internal {\n    bool reserveAlreadyAdded = false;\n    require(_reservesList.length < MAX_NUMBER_RESERVES, Errors.NO_MORE_RESERVES_ALLOWED);\n    for (uint256 i = 0; i < _reservesList.length; i++)\n      if (_reservesList[i] == asset) {\n        reserveAlreadyAdded = true;\n      }\n    if (!reserveAlreadyAdded) {\n      _reserves[asset].id = uint8(_reservesList.length);\n      _reservesList.push(asset);\n    }\n  }\n\n  /**\n   * @dev returns the normalized income per unit of asset\n   * @param asset the address of the reserve\n   * @return the reserve normalized income\n   */\n  function getReserveNormalizedIncome(address asset) external override view returns (uint256) {\n    return _reserves[asset].getNormalizedIncome();\n  }\n\n  /**\n   * @dev returns the normalized variable debt per unit of asset\n   * @param asset the address of the reserve\n   * @return the reserve normalized debt\n   */\n  function getReserveNormalizedVariableDebt(address asset)\n    external\n    override\n    view\n    returns (uint256)\n  {\n    return _reserves[asset].getNormalizedD"
    }
  ]
}