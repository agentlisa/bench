{
  "Title": "[G-01] State variables can be packed into fewer storage slots by reducing their sizes (*Instances missed by bot*)",
  "Content": "\nThe EVM works with 32 byte words. Variables less than 32 bytes can be declared next to each other in storage and this will pack the values together into a single 32 byte storage slot (if values combined are `<=` 32 bytes). If the variables packed together are retrieved together in functions (more likely with structs), we will effectively save ~2000 gas with every subsequent SLOAD for that storage slot. This is due to us incurring a Gwarmaccess (100 gas) versus a Gcoldsload (2100 gas).\n\nSAVE: ~8000 GAS, 4 SLOT.\n\n### `multiplierPerSecondX96`, `baseRatePerSecondX96` and `jumpMultiplierPerSecondX96` can be packed in single slot by reducing their sizes to `uint80` each SAVES: ~4000 Gas, 2 SLOT\n\nAll these three variables are set inside only `setValues` function where a check is implemented for passed function params and then after dividing by `YEAR_SECS` constant values are assigned into these state variables. It will make sure that `multiplierPerSecondX96`, `baseRatePerSecondX96` and `jumpMultiplierPerSecondX96` maximum values can be `MAX_MULTIPLIER_X96 / YEAR_SECS`, `MAX_BASE_RATE_X96 / YEAR_SECS` and `MAX_MULTIPLIER_X96 / YEAR_SECS` respectively not more than that.\n\nSince these constants are defined in same contract. So their approximate values are:\n\n- `MAX_MULTIPLIER_X96 / YEAR_SECS` `< 10**22`\n- `MAX_BASE_RATE_X96 / YEAR_SECS` `< 7.5*10**20`\n\nWhile `uint80` can hold `> ~10**24 ` \nSo we can easily say that `uint80` is sufficient to hold these max values So we can safely reduce the above mentioned storage var. sizes to each `uint80` to pack all three into 1 slot and saves 2 storage slots.\n\n```solidity\nFile : InterestRateModel.sol\n\n23:    uint256 public multiplierPerSecondX96;\n24:    uint256 public baseRatePerSecondX96;\n25:    uint256 public jumpMultiplierPerSecondX96;\n```\n\n[InterestRateModel.sol#L23-L25](https://github.com/code-423n4/2024-03-revert-lend/blob/main/src/InterestRateModel.sol#L23-L25)\n\nRelevant code to prove why these state variable can be truncated:\n\n```solidity\nFile : InterestRateModel.sol\n\n13:  uint256 public constant YEAR_SECS = 31557600; // taking into account leap years\n14:\n15:  uint256 public constant MAX_BASE_RATE_X96 = Q96 / 10; // 10%\n16:  uint256 public constant MAX_MULTIPLIER_X96 = Q96 * 2; // 200%\n...\n...\n\n82:  function setValues(\n         uint256 baseRatePerYearX96,\n         uint256 multiplierPerYearX96,\n         uint256 jumpMultiplierPerYearX96,\n         uint256 _kinkX96\n87:     ) public onlyOwner {\n88:    if (\n89:        baseRatePerYearX96 > MAX_BASE_RATE_X96 || multiplierPerYearX96 > MAX_MULTIPLIER_X96\n90:             || jumpMultiplierPerYearX96 > MAX_MULTIPLIER_X96\n91:        ) {\n92:            revert InvalidConfig();\n93:        }\n94:\n95:  baseRatePerSecondX96 = baseRatePerYearX96 / YEAR_SECS;\n96:  multiplierPerSecondX96 = multiplierPerYearX96 / YEAR_SECS;\n97:  jumpMultiplierPerSecondX96 = jumpMultiplierPerYearX96 / YEAR_SECS;\n```\n\n[InterestRateModel.sol#L13-L16](https://github.com/code-423n4/2024-03-revert-lend/blob/main/src/InterestRateModel.sol#L13-L16), [InterestRateModel.sol#L88-L97](https://github.com/code-423n4/2024-03-revert-lend/blob/main/src/InterestRateModel.sol#L88-L97)\n\n### Recommended Mitigation Steps\n\n```diff\nFile : InterestRateModel.sol\n\n-23:    uint256 public multiplierPerSecondX96;\n-24:    uint256 public baseRatePerSecondX96;\n-25:    uint256 public jumpMultiplierPerSecondX96;\n+23:    uint80 public multiplierPerSecondX96;\n+24:    uint80 public baseRatePerSecondX96;\n+25:    uint80 public jumpMultiplierPerSecondX96;\n```\n\n### `dailyLendIncreaseLimitLastReset` and `dailyDebtIncreaseLimitLastReset` can be packed with `reserveProtectionFactorX32` SAVES: ~4000 Gas, 2 Slot\n\nSince values in these variables are only assigned in `_resetDailyLendIncreaseLimit` and `_resetDailyDebtIncreaseLimit` functions respectively with the value of `block.timestamp/1 Days` for both. So it is sufficient to hold these values in `uint32`. Reduce those variable sizes to uint32 each and pack with `reserveProtectionFactorX32`. Saves 2 storage slots.\n\n```solidity\nFile : V3Vault.sol\n\n\n121: uint32 public reserveProtectionFactorX32 = MIN_RESERVE_PROTECTION_FACTOR_X32;\n...\n...\n140: uint256 public dailyLendIncreaseLimitLastReset = 0;\n...\n145: uint256 public dailyDebtIncreaseLimitLastReset = 0;\n```\n\n[V3Vault.sol#L121](https://github.com/code-423n4/2024-03-revert-lend/blob/main/src/V3Vault.sol#L121), [V3Vault.sol#L140-L145](https://github.com/code-423n4/2024-03-revert-lend/blob/main/src/V3Vault.sol#L140-L145)\n\n### Recommended Mitigation Steps\n\n```diff\nFile : V3Vault.sol\n\n\n121: uint32 public reserveProtectionFactorX32 = MIN_RESERVE_PROTECTION_FACTOR_X32;\n+140: uint32 public dailyLendIncreaseLimitLastReset = 0;\n+145: uint32 public dailyDebtIncreaseLimitLastReset = 0;\n...\n...\n-140: uint256 public dailyLendIncreaseLimitLastReset = 0;\n...\n-145: uint256 public dailyDebtIncreaseLimitLastReset = 0;\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2024-03-revert-lend",
  "Code": [
    {
      "filename": "src/InterestRateModel.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./interfaces/IInterestRateModel.sol\";\nimport \"./interfaces/IErrors.sol\";\n\n/// @title Model for interest rate calculation used in Vault\n/// @notice Calculates both borrow and supply rate\ncontract InterestRateModel is Ownable, IInterestRateModel, IErrors {\n    uint256 private constant Q96 = 2 ** 96;\n    uint256 public constant YEAR_SECS = 31557600; // taking into account leap years\n\n    uint256 public constant MAX_BASE_RATE_X96 = Q96 / 10; // 10%\n    uint256 public constant MAX_MULTIPLIER_X96 = Q96 * 2; // 200%\n\n    event SetValues(\n        uint256 baseRatePerYearX96, uint256 multiplierPerYearX96, uint256 jumpMultiplierPerYearX96, uint256 kinkX96\n    );\n\n    // all values are multiplied by Q96\n    uint256 public multiplierPerSecondX96;\n    uint256 public baseRatePerSecondX96;\n    uint256 public jumpMultiplierPerSecondX96;\n    uint256 public kinkX96;\n\n    /// @notice Creates interest rate model\n    /// @param baseRatePerYearX96 Base rate per year multiplied by Q96\n    /// @param multiplierPerYearX96 Multiplier for utilization rate below kink multiplied by Q96\n    /// @param jumpMultiplierPerYearX96 Multiplier for utilization rate above kink multiplied by Q96\n    /// @param _kinkX96 Kink percentage multiplied by Q96\n    constructor(\n        uint256 baseRatePerYearX96,\n        uint256 multiplierPerYearX96,\n        uint256 jumpMultiplierPerYearX96,\n        uint256 _kinkX96\n    ) {\n        setValues(baseRatePerYearX96, multiplierPerYearX96, jumpMultiplierPerYearX96, _kinkX96);\n    }\n\n    /// @notice Returns utilization rate X96 given cash and debt\n    /// @param cash Current available cash \n    /// @param debt Current debt\n    /// @return Utilization rate between 0 and Q96\n    function getUtilizationRateX96(uint256 cash, uint256 debt) public pure returns (uint256) {\n        if (debt == 0) {\n            return 0;\n        }\n        return debt * Q96 / (cash + debt);\n    }\n\n    /// @notice Returns interest rates X96 given cash and debt\n    /// @param cash Current available cash \n    /// @param debt Current debt\n    /// @return borrowRateX96 borrow rate multiplied by Q96\n    /// @return supplyRateX96 supply rate multiplied by Q96\n    function getRatesPerSecondX96(uint256 cash, uint256 debt)\n        public\n        view\n        override\n        returns (uint256 borrowRateX96, uint256 supplyRateX96)\n    {\n        uint256 utilizationRateX96 = getUtilizationRateX96(cash, debt);\n\n        if (utilizationRateX96 <= kinkX96) {\n            borrowRateX96 = (utilizationRateX96 * multiplierPerSecondX96 / Q96) + baseRatePerSecondX96;\n        } else {\n            uint256 normalRateX96 = (kinkX96 * multiplierPerSecondX96 / Q96) + baseRatePerSecondX96;\n            uint256 excessUtilX96 = utilizationRateX96 - kinkX96;\n            borrowRateX96 = (excessUtilX96 * jumpMultiplierPerSecondX96 / Q96) + normalRateX96;\n        }\n\n        supplyRateX96 = utilizationRateX96 * borrowRateX96 / Q96;\n    }\n\n    /// @notice Update interest rate values (onlyOwner)\n    /// @param baseRatePerYearX96 Base rate per year multiplied by Q96\n    /// @param multiplierPerYearX96 Multiplier for utilization rate below kink multiplied by Q96\n    /// @param jumpMultiplierPerYearX96 Multiplier for utilization rate above kink multiplied by Q96\n    /// @param _kinkX96 Kink percentage multiplied by Q96\n    function setValues(\n        uint256 baseRatePerYearX96,\n        uint256 multiplierPerYearX96,\n        uint256 jumpMultiplierPerYearX96,\n        uint256 _kinkX96\n    ) public onlyOwner {\n        if (\n            baseRatePerYearX96 > MAX_BASE_RATE_X96 || multiplierPerYearX96 > MAX_MULTIPLIER_X96\n                || jumpMultiplierPerYearX96 > MAX_MULTIPLIER_X96\n        ) {\n            revert InvalidConfig();\n        }\n\n        baseRatePerSecondX96 = baseRatePerYearX96 / YEAR_SECS;\n        multiplierPerSecondX96 = multiplierPerYearX96 / YEAR_SECS;\n        jumpMultiplierPerSecondX96 = jumpMultiplierPerYearX96 / YEAR_SECS;\n        kinkX96 = _kinkX96;\n\n        emit SetValues(baseRatePerYearX96, multiplierPerYearX96, jumpMultiplierPerYearX96, _kinkX96);\n    }\n}"
    },
    {
      "filename": "src/InterestRateModel.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./interfaces/IInterestRateModel.sol\";\nimport \"./interfaces/IErrors.sol\";\n\n/// @title Model for interest rate calculation used in Vault\n/// @notice Calculates both borrow and supply rate\ncontract InterestRateModel is Ownable, IInterestRateModel, IErrors {\n    uint256 private constant Q96 = 2 ** 96;\n    uint256 public constant YEAR_SECS = 31557600; // taking into account leap years\n\n    uint256 public constant MAX_BASE_RATE_X96 = Q96 / 10; // 10%\n    uint256 public constant MAX_MULTIPLIER_X96 = Q96 * 2; // 200%\n\n    event SetValues(\n        uint256 baseRatePerYearX96, uint256 multiplierPerYearX96, uint256 jumpMultiplierPerYearX96, uint256 kinkX96\n    );\n\n    // all values are multiplied by Q96\n    uint256 public multiplierPerSecondX96;\n    uint256 public baseRatePerSecondX96;\n    uint256 public jumpMultiplierPerSecondX96;\n    uint256 public kinkX96;\n\n    /// @notice Creates interest rate model\n    /// @param baseRatePerYearX96 Base rate per year multiplied by Q96\n    /// @param multiplierPerYearX96 Multiplier for utilization rate below kink multiplied by Q96\n    /// @param jumpMultiplierPerYearX96 Multiplier for utilization rate above kink multiplied by Q96\n    /// @param _kinkX96 Kink percentage multiplied by Q96\n    constructor(\n        uint256 baseRatePerYearX96,\n        uint256 multiplierPerYearX96,\n        uint256 jumpMultiplierPerYearX96,\n        uint256 _kinkX96\n    ) {\n        setValues(baseRatePerYearX96, multiplierPerYearX96, jumpMultiplierPerYearX96, _kinkX96);\n    }\n\n    /// @notice Returns utilization rate X96 given cash and debt\n    /// @param cash Current available cash \n    /// @param debt Current debt\n    /// @return Utilization rate between 0 and Q96\n    function getUtilizationRateX96(uint256 cash, uint256 debt) public pure returns (uint256) {\n        if (debt == 0) {\n            return 0;\n        }\n        return debt * Q96 / (cash + debt);\n    }\n\n    /// @notice Returns interest rates X96 given cash and debt\n    /// @param cash Current available cash \n    /// @param debt Current debt\n    /// @return borrowRateX96 borrow rate multiplied by Q96\n    /// @return supplyRateX96 supply rate multiplied by Q96\n    function getRatesPerSecondX96(uint256 cash, uint256 debt)\n        public\n        view\n        override\n        returns (uint256 borrowRateX96, uint256 supplyRateX96)\n    {\n        uint256 utilizationRateX96 = getUtilizationRateX96(cash, debt);\n\n        if (utilizationRateX96 <= kinkX96) {\n            borrowRateX96 = (utilizationRateX96 * multiplierPerSecondX96 / Q96) + baseRatePerSecondX96;\n        } else {\n            uint256 normalRateX96 = (kinkX96 * multiplierPerSecondX96 / Q96) + baseRatePerSecondX96;\n            uint256 excessUtilX96 = utilizationRateX96 - kinkX96;\n            borrowRateX96 = (excessUtilX96 * jumpMultiplierPerSecondX96 / Q96) + normalRateX96;\n        }\n\n        supplyRateX96 = utilizationRateX96 * borrowRateX96 / Q96;\n    }\n\n    /// @notice Update interest rate values (onlyOwner)\n    /// @param baseRatePerYearX96 Base rate per year multiplied by Q96\n    /// @param multiplierPerYearX96 Multiplier for utilization rate below kink multiplied by Q96\n    /// @param jumpMultiplierPerYearX96 Multiplier for utilization rate above kink multiplied by Q96\n    /// @param _kinkX96 Kink percentage multiplied by Q96\n    function setValues(\n        uint256 baseRatePerYearX96,\n        uint256 multiplierPerYearX96,\n        uint256 jumpMultiplierPerYearX96,\n        uint256 _kinkX96\n    ) public onlyOwner {\n        if (\n            baseRatePerYearX96 > MAX_BASE_RATE_X96 || multiplierPerYearX96 > MAX_MULTIPLIER_X96\n                || jumpMultiplierPerYearX96 > MAX_MULTIPLIER_X96\n        ) {\n            revert InvalidConfig();\n        }\n\n        baseRatePerSecondX96 = baseRatePerYearX96 / YEAR_SECS;\n        multiplierPerSecondX96 = multiplierPerYearX96 / YEAR_SECS;\n        jumpMultiplierPerSecondX96 = jumpMultiplierPerYearX96 / YEAR_SECS;\n        kinkX96 = _kinkX96;\n\n        emit SetValues(baseRatePerYearX96, multiplierPerYearX96, jumpMultiplierPerYearX96, _kinkX96);\n    }\n}"
    },
    {
      "filename": "src/V3Vault.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"v3-core/interfaces/IUniswapV3Factory.sol\";\nimport \"v3-core/interfaces/IUniswapV3Pool.sol\";\nimport \"v3-core/libraries/TickMath.sol\";\nimport \"v3-core/libraries/FixedPoint128.sol\";\n\nimport \"v3-periphery/libraries/LiquidityAmounts.sol\";\nimport \"v3-periphery/interfaces/INonfungiblePositionManager.sol\";\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/utils/Multicall.sol\";\n\nimport \"permit2/interfaces/IPermit2.sol\";\n\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IV3Oracle.sol\";\nimport \"./interfaces/IInterestRateModel.sol\";\nimport \"./interfaces/IErrors.sol\";\n\n/// @title Revert Lend Vault for token lending / borrowing using Uniswap V3 LP positions as collateral\n/// @notice The vault manages ONE ERC20 (eg. USDC) asset for lending / borrowing, but collateral positions can be composed of any 2 tokens configured each with a collateralFactor > 0\n/// Vault implements IERC4626 Vault Standard and is itself a ERC20 which represent shares of total lending pool\ncontract V3Vault is ERC20, Multicall, Ownable, IVault, IERC721Receiver, IErrors {\n    using Math for uint256;\n\n    uint256 private constant Q32 = 2 ** 32;\n    uint256 private constant Q96 = 2 ** 96;\n\n    uint32 public constant MAX_COLLATERAL_FACTOR_X32 = uint32(Q32 * 90 / 100); // 90%\n\n    uint32 public constant MIN_LIQUIDATION_PENALTY_X32 = uint32(Q32 * 2 / 100); // 2%\n    uint32 public constant MAX_LIQUIDATION_PENALTY_X32 = uint32(Q32 * 10 / 100); // 10%\n\n    uint32 public constant MIN_RESERVE_PROTECTION_FACTOR_X32 = uint32(Q32 / 100); //1%\n\n    uint32 public constant MAX_DAILY_LEND_INCREASE_X32 = uint32(Q32 / 10); //10%\n    uint32 public constant MAX_DAILY_DEBT_INCREASE_X32 = uint32(Q32 / 10); //10%\n\n    /// @notice Uniswap v3 position manager\n    INonfungiblePositionManager public immutable nonfungiblePositionManager;\n\n    /// @notice Uniswap v3 factory\n    IUniswapV3Factory public immutable factory;\n\n    /// @notice interest rate model implementation\n    IInterestRateModel public immutable interestRateModel;\n\n    /// @notice oracle implementation\n    IV3Oracle public immutable oracle;\n\n    /// @notice permit2 contract\n    IPermit2 public immutable permit2;\n\n    /// @notice underlying asset for lending / borrowing\n    address public immutable override asset;\n\n    /// @notice decimals of underlying token (are the same as ERC20 share token)\n    uint8 private immutable assetDecimals;\n\n    // events\n    event ApprovedTransform(uint256 indexed tokenId, address owner, address target, bool isActive);\n\n    event Add(uint256 indexed tokenId, address owner, uint256 oldTokenId); // when a token is added replacing another token - oldTokenId > 0\n    event Remove(uint256 indexed tokenId, address recipient);\n\n    event ExchangeRateUpdate(uint256 debtExchangeRateX96, uint256 lendExchangeRateX96);\n    // Deposit and Withdraw events are defined in IERC4626\n    event WithdrawCollateral(\n        uint256 indexed tokenId, address owner, address recipient, uint128 liquidity, uint256 amount0, uint256 amount1\n    );\n    event Borrow(uint256 indexed tokenId, address owner, uint256 assets, uint256 shares);\n    event Repay(uint256 indexed tokenId, address repayer, address owner, uint256 assets, uint256 shares);\n    event Liquidate(\n        uint256 indexed tokenId,\n        address liquidator,\n        address owner,\n        uint256 value,\n        uint256 cost,\n        uint256 amount0,\n        uint256 amount1,\n        uint256 reserve,\n        uint256 missing\n    ); // shows exactly how liquidation amounts were divided\n\n    // admin events\n    event WithdrawReserves(uint256 amount, address receiver);\n    event SetTransformer(address transformer, bool active);\n    event SetLimits(\n        uint256 minLoanSize,\n        uint256 globalLendLimit,\n        uint256 globalDebtLimit,\n        uint256 dailyLendIncreaseLimitMin,\n        uint256 dailyDebtIncreaseLimitMin\n    );\n    event SetReserveFactor(uint32 reserveFactorX32);\n    event SetReserveProtectionFactor(uint32 reserveProtectionFactorX32);\n    event SetTokenConfig(address token, uint32 collateralFactorX32, uint32 collateralValueLimitFactorX32);\n\n    event SetEmergencyAdmin(address emergencyAdmin);\n\n    // configured tokens\n    struct TokenConfig {\n        uint32 collateralFactorX32; // how much this token is valued as collateral\n        uint32 collateralValueLimitFactorX32; // how much asset equivalent may be lent out given this collateral\n        uint192 totalDebtShares; // how much debt shares are theoretically backed by this collateral\n    }\n\n    mapping(address => TokenConfig) public tokenConfigs;\n\n    // percentage of interest which is kept in the protocol for reserves\n    uint32 public reserveFactorX32 = 0;\n\n    // percentage of lend amount which needs to be in reserves before withdrawn\n    uint32 public reserveProtectionFactorX32 = MIN_RESERVE_PROTECTION_FACTOR_X32;\n\n    // total of debt shares - increases when borrow - decreases when repay\n    uint256 public debtSharesTotal = 0;\n\n    // exchange rates are Q96 at the beginning - 1 share token per 1 asset token\n    uint256 public lastExchangeRateUpdate = 0;\n    uint256 public lastDebtExchangeRateX96 = Q96;\n    uint256 public lastLendExchangeRateX96 = Q96;\n\n    uint256 public globalDebtLimit = 0;\n    uint256 public globalLendLimit = 0;\n\n    // minimal size of loan (to protect from non-liquidatable positions because of gas-cost)\n    uint256 public minLoanSize = 0;\n\n    // daily lend increase limit handling\n    uint256 public dailyLendIncreaseLimitMin = 0;\n    uint256 public dailyLendIncreaseLimitLeft = 0;\n    uint256 public dailyLendIncreaseLimitLastReset = 0;\n\n    // daily debt increase limit handling\n    uint256 public dailyDebtIncreaseLimitMin = 0;\n    uint256 public dailyDebtIncreaseLimitLeft = 0;\n    uint256 public dailyDebtIncreaseLimitLastReset = 0;\n\n    // lender balances are handled with ERC-20 mint/burn\n\n    // loans are handled with this struct\n    struct Loan {\n        uint256 debtShares;\n    }\n\n    mapping(uint256 => Loan) public loans; // tokenID -> loan mapping\n\n    // storage variables to handle enumerable token ownership\n    mapping(address => uint256[]) private ownedTokens; // Mapping from owner address to list of owned token IDs\n    mapping(uint256 => uint256) private ownedTokensIndex; // Mapping from token ID to index of the owner tokens list (for removal without loop)\n    mapping(uint256 => address) private tokenOwner; // Mapping from token ID to owner\n\n    uint256 private transformedTokenId = 0; // transient storage (when available in dencun)\n\n    mapping(address => bool) public transformerAllowList; // contracts allowed to transform positions (selected audited contracts e.g. V3Utils)\n    mapping(address => mapping(uint256 => mapping(address => bool))) public transformApprovals; // owners permissions for other addresses to call transform on owners behalf (e.g. AutoRange contract)\n\n    // address which can call special emergency actions without timelock\n    address public emergencyAdmin;\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        address _asset,\n        INonfungiblePositionManager _nonfungiblePositionManager,\n        IInterestRateModel _interestRateModel,\n        IV3Oracle _oracle,\n        IPermit2 _permit2\n    ) ERC20(name, symbol) {\n        asset = _asset;\n        assetDecimals = IERC20Metadata(_asset).decimals();\n        nonfungiblePositionManager = _nonfungiblePositionManager;\n        factory = IUniswapV3Factory(_nonfungiblePositionManager.factory());\n        interestRateModel = _interestRateModel;\n        oracle = _oracle;\n        permit2 = _permit2;\n    }\n\n    ////////////////// EXTERNAL VIEW FUNCTIONS\n\n    /// @notice Retrieves global information about the vault\n    /// @return debt Total amount of debt asset tokens\n    /// @return lent Total amount of lent asset tokens\n    /// @return balance Balance of asset token in contract\n    /// @return available Available balance of asset token in contract (balance - reserves)\n    /// @return reserves Amount of reserves\n    function vaultInfo()\n        external\n        view\n        override\n        returns (\n            uint256 debt,\n            uint256 lent,\n            uint256 balance,\n            uint256 available,\n            uint256 reserves,\n            uint256 debtExchangeRateX96,\n            uint256 lendExchangeRateX96\n        )\n    {\n        (debtExchangeRateX96, lendExchangeRateX96) = _calculateGlobalInterest();\n        (balance, available, reserves) = _getAvailableBalance(debtExchangeRateX96, lendExchangeRateX96);\n\n        debt = _convertToAssets(debtSharesTotal, debtExchangeRateX96, Math.Rounding.Up);\n        lent = _convertToAssets(totalSupply(), lendExchangeRateX96, Math.Rounding.Up);\n    }\n\n    /// @notice Retrieves lending information for a specified account.\n    /// @param account The address of the account for which lending info is requested.\n    /// @return amount Amount of lent assets for the account\n    function lendInfo(address account) external view override returns (uint256 amount) {\n        (, uint256 newLendExchangeRateX96) = _calculateGlobalInterest();\n        amount = _convertToAssets(balanceOf(account), newLendExchangeRateX96, Math.Rounding.Down);\n    }\n\n    /// @notice Retrieves details of a loan identified by its token ID.\n    /// @param tokenId The unique identifier of the loan - which is the corresponding UniV3 Position\n    /// @return debt Amount of debt for this position\n    /// @return fullValue Current value of the position priced as asset token\n    /// @return collateralValue Current collateral value of the position priced as asset token\n    /// @return liquidationCost If position is liquidatable - cost to liquidate position - otherwise 0\n    /// @return liquidationValue If position is liquidatable - the value of the (partial) position which the liquidator recieves - otherwise 0\n    function loanInfo(uint256 tokenId)\n        external\n        view\n        override\n        returns (\n            uint256 debt,\n            uint256 fullValue,\n            uint256 collateralValue,\n            uint256 liquidationCost,\n            uint256 liquidationValue\n        )\n    {\n        (uint256 newDebtExchangeRateX96,) = _calculateGlobalInterest();\n\n        debt = _convertToAssets(loans[tokenId].debtShares, newDebtExchangeRateX96, Math.Rounding.Up);\n\n        bool isHealthy;\n        (isHealthy, fullValue, collateralValue,) = _checkLoanIsHealthy(tokenId, debt);\n\n        if (!isHealthy) {\n            (liquidationValue, liquidationCost,) = _calculateLiquidation(debt, fullValue, collateralValue);\n        }\n    }\n\n    /// @notice Retrieves owner of a loan\n    /// @param tokenId The unique identifier of the loan - which is the corresponding UniV3 Position\n    /// @return owner Owner of the loan\n    function ownerOf(uint256 tokenId) external view override returns (address owner) {\n        return tokenOwner[tokenId];\n    }\n\n    /// @notice Retrieves count of loans for owner (for enumerating owners loans)\n    /// @param owner Owner address\n    function loanCount(address owner) external view override returns (uint256) {\n        return ownedTokens[owner].length;\n    }\n\n    /// @notice Retrieves tokenid of loan at given index for owner (for enumerating owners loans)\n    /// @param owner Owner address\n    /// @param index Index\n    function loanAtIndex(address owner, uint256 index) external view override returns (uint256) {\n        return ownedTokens[owner][index];\n    }\n\n    ////////////////// OVERRIDDEN EXTERNAL VIEW FUNCTIONS FROM ERC20\n    /// @inheritdoc IERC20Metadata\n    function decimals() public view override(IERC20Metadata, ERC20) returns (uint8) {\n        return assetDecimals;\n    }\n\n    ////////////////// OVERRIDDEN EXTERNAL VIEW FUNCTIONS FROM ERC4626\n\n    /// @inheritdoc IERC4626\n    function totalAssets() public view override returns (uint256) {\n        return IERC20(asset).balanceOf(address(this));\n    }\n\n    /// @inheritdoc IERC4626\n    function convertToShares(uint256 assets) external view override returns (uint256 shares) {\n        (, uint256 lendExchangeRateX96) = _calculateGlobalInterest();\n        return _convertToShares(assets, lendExchangeRateX96, Math.Rounding.Down);\n    }\n\n    /// @inheritdoc IERC4626\n    function convertToAssets(uint256 shares) external view override returns (uint256 assets) {\n        (, uint256 lendExchangeRateX96) = _calculateGlobalInterest();\n        return _convertToAssets(shares, lendExchangeRateX96, Math.Rounding.Down);\n    }\n\n    /// @inheritdoc IERC4626\n    function maxDeposit(address) external view override returns (uint256) {\n        (, uint256 lendExchangeRateX96) = _calculateGlobalInterest();\n        uint256 value = _convertToAssets(totalSupply(), lendExchangeRateX96, Math.Rounding.Up);\n        if (value >= globalLendLimit) {\n            return 0;\n        } else {\n            return globalLendLimit - value;\n        }\n    }\n\n    /// @inheritdoc IERC4626\n    function maxMint(address) external view override returns (uint256) {\n        (, uint256 lendExchangeRateX96) = _calculateGlobalInterest();\n        uint256 value = _convertToAssets(totalSupply(), lendExchangeRateX96, Math.Rounding.Up);\n        if (value >= globalLendLimit) {\n            return 0;\n        } else {\n            return _convertToShares(globalLendLimit - value, lendExchangeRateX96, Math.Rounding.Down);\n        }\n    }\n\n    /// @inheritdoc IERC4626\n    function maxWithdraw(address owner) external view override returns (uint256) {\n        (, uint256 lendExchangeRateX96) = _calculateGlobalInterest();\n        return _convertToAssets(balanceOf(owner), lendExchangeRateX96, Math.Rounding.Down);\n    }\n\n    /// @inheritdoc IERC4626\n    function maxRedeem(address owner) external view override returns (uint256) {\n        return balanceOf(owner);\n    }\n\n    /// @inheritdoc IERC4626\n    function previewDeposit(uint256 assets) public view override returns (uint256) {\n        (, uint256 lendExchangeRateX96) = _calculateGlobalInterest();\n        return _convertToShares(assets, lendExchangeRateX96, Math.Rounding.Down);\n    }\n\n    /// @inheritdoc IERC4626\n    function previewMint(uint256 shares) public view override returns (uint256) {\n        (, uint256 lendExchangeRateX96) = _calculateGlobalInterest();\n        return _convertToAssets(shares, lendExchangeRateX96, Math.Rounding.Up);\n    }\n\n    /// @inheritdoc IERC4626\n    function previewWithdraw(uint256 assets) public view override returns (uint256) {\n        (, uint256 lendExchangeRateX96) = _calculateGlobalInterest();\n        return _convertToShares(assets, lendExchangeRateX96, Math.Rounding.Up);\n    }\n\n    /// @inheritdoc IERC4626\n    function previewRedeem(uint256 shares) public view override returns (uint256) {\n        (, uint256 lendExchangeRateX96) = _calculateGlobalInterest();\n        return _convertToAssets(shares, lendExchangeRateX96, Math.Rounding.Down);\n    }\n\n    ////////////////// OVERRIDDEN EXTERNAL FUNCTIONS FROM ERC4626\n\n    /// @inheritdoc IERC4626\n    function deposit(uint256 assets, address receiver) external override returns (uint256) {\n        (, uint256 shares) = _deposit(receiver, assets, false, \"\");\n        return shares;\n    }\n\n    /// @inheritdoc IERC4626\n    function mint(uint256 shares, address receiver) external override returns (uint256) {\n        (uint256 assets,) = _deposit(receiver, shares, true, \"\");\n        return assets;\n    }\n\n    /// @inheritdoc IERC4626\n    function withdraw(uint256 assets, address receiver, address owner) external override returns (uint256) {\n        (, uint256 shares) = _withdraw(receiver, owner, assets, false);\n        return shares;\n    }\n\n    /// @inheritdoc IERC4626\n    function redeem(uint256 shares, address receiver, address owner) external override returns (uint256) {\n        (uint256 assets,) = _withdraw(receiver, owner, shares, true);\n        return assets;\n    }\n\n    // deposit using permit2 data\n    function deposit(uint256 assets, address receiver, bytes calldata permitData) external override returns (uint256) {\n        (, uint256 shares) = _deposit(receiver, assets, false, permitData);\n        return shares;\n    }\n\n    // mint using permit2 data\n    function mint(uint256 shares, address receiver, bytes calldata permitData) external override returns (uint256) {\n        (uint256 assets,) = _deposit(receiver, shares, true, permitData);\n        return assets;\n    }\n\n    ////////////////// EXTERNAL FUNCTIONS\n\n    /// @notice Creates a new collateralized position (transfer approved position)\n    /// @param tokenId The token ID associated with the new position.\n    /// @param recipient Address to recieve the position in the vault\n    function create(uint256 tokenId, address recipient) external override {\n        nonfungiblePositionManager.safeTransferFrom(msg.sender, address(this), tokenId, abi.encode(recipient));\n    }\n\n    /// @notice Creates a new collateralized position with a permit for token spending (transfer position with permit)\n    /// @param tokenId The token ID associated with the new position.\n    /// @param owner Current owner of the position (signature owner)\n    /// @param recipient Address to recieve the position in the vault\n    /// @param deadline Timestamp until which the permit is valid.\n    /// @param v, r, s Components of the signature for the permit.\n    function createWithPermit(\n        uint256 tokenId,\n        address owner,\n        address recipient,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        if (msg.sender != owner) {\n            revert Unauthorized();\n        }\n\n        nonfungiblePositionManager.permit(address(this), tokenId, deadline, v, r, s);\n        nonfungiblePositionManager.safeTransferFrom(owner, address(this), tokenId, abi.encode(recipient));\n    }\n\n    /// @notice Whenever a token is recieved it either creates a new loan, or modifies an existing one when in transform mode.\n    /// @inheritdoc IERC721Receiver\n    function onERC721Received(address, address from, uint256 tokenId, bytes calldata data)\n        external\n        override\n        returns (bytes4)\n    {\n        // only Uniswap v3 NFTs allowed - sent from other contract\n        if (msg.sender != address(nonfungiblePositionManager) || from == address(this)) {\n            revert WrongContract();\n        }\n\n        (uint256 debtExchangeRateX96, uint256 lendExchangeRateX96) = _updateGlobalInterest();\n\n        if (transformedTokenId == 0) {\n            address owner = from;\n            if (data.length > 0) {\n                owner = abi.decode(data, (address));\n            }\n            loans[tokenId] = Loan(0);\n\n            _addTokenToOwner(owner, tokenId);\n            emit Add(tokenId, owner, 0);\n        } else {\n            uint256 oldTokenId = transformedTokenId;\n\n            // if in transform mode - and a new position is sent - current position is replaced and returned\n            if (tokenId != oldTokenId) {\n                address owner = tokenOwner[oldTokenId];\n\n                // set transformed token to new one\n                transformedTokenId = tokenId;\n\n                // copy debt to new token\n                loans[tokenId] = Loan(loans[oldTokenId].debtShares);\n\n                _addTokenToOwner(owner, tokenId);\n                emit Add(tokenId, owner, oldTokenId);\n\n                // clears data of old loan\n                _cleanupLoan(oldTokenId, debtExchangeRateX96, lendExchangeRateX96, owner);\n\n                // sets data of new loan\n                _updateAndCheckCollateral(\n                    tokenId, debtExchangeRateX96, lendExchangeRateX96, 0, loans[tokenId].debtShares\n                );\n            }\n        }\n\n        return IERC721Receiver.onERC721Received.selector;\n    }\n\n    /// @notice Allows another address to call transform on behalf of owner (on a given token)\n    /// @param tokenId The token to be permitted\n    /// @param target The address to be allowed\n    /// @param isActive If it allowed or not\n    function approveTransform(uint256 tokenId, address target, bool isActive) external override {\n        if (tokenOwner[tokenId] != msg.sender) {\n            revert Unauthorized();\n        }\n        transformApprovals[msg.sender][tokenId][target] = isActive;\n\n        emit ApprovedTransform(tokenId, msg.sender, target, isActive);\n    }\n\n    /// @notice Method which allows a contract to transform a loan by changing it (and only at the end checking collateral)\n    /// @param tokenId The token ID to be processed\n    /// @param transformer The address of a whitelisted transformer contract\n    /// @param data Encoded transformation params\n    /// @return newTokenId Final token ID (may be different than input token ID when the position was replaced by transformation)\n    function transform(uint256 tokenId, address transformer, bytes calldata data)\n        external\n        override\n        returns (uint256 newTokenId)\n    {\n        if (tokenId == 0 || !transformerAllowList[transformer]) {\n            revert TransformNotAllowed();\n        }\n        if (transformedTokenId > 0) {\n            revert Reentrancy();\n        }\n        transformedTokenId = tokenId;\n\n        (uint256 newDebtExchangeRateX96,) = _updateGlobalInterest();\n\n        address loanOwner = tokenOwner[tokenId];\n\n        // only the owner of the loan, the vault itself or any approved caller can call this\n        if (loanOwner != msg.sender && !transformApprovals[loanOwner][tokenId][msg.sender]) {\n            revert Unauthorized();\n        }\n\n        // give access to transformer\n        nonfungiblePositionManager.approve(transformer, tokenId);\n\n        (bool success,) = transformer.call(data);\n        if (!success) {\n            revert TransformFailed();\n        }\n\n        // may have changed in the meantime\n        tokenId = transformedTokenId;\n\n        // check owner not changed (NEEDED because token could have been moved somewhere else in the meantime)\n        address owner = nonfungiblePositionManager.ownerOf(tokenId);\n        if (owner != address(this)) {\n            revert Unauthorized();\n        }\n\n        // remove access for transformer\n        nonfungiblePositionManager.approve(address(0), tokenId);\n\n        uint256 debt = _convertToAssets(loans[tokenId].debtShares, newDebtExchangeRateX96, Math.Rounding.Up);\n        _requireLoanIsHealthy(tokenId, debt);\n\n        transformedTokenId = 0;\n\n        return tokenId;\n    }\n\n    /// @notice Borrows specified amount using token as collateral\n    /// @param tokenId The token ID to use as collateral\n    /// @param assets How much assets to borrow\n    function borrow(uint256 tokenId, uint256 assets) external override {\n        bool isTransformMode =\n            transformedTokenId > 0 && transformedTokenId == tokenId && transformerAllowList[msg.sender];\n\n        (uint256 newDebtExchangeRateX96, uint256 newLendExchangeRateX96) = _updateGlobalInterest();\n\n        _resetDailyDebtIncreaseLimit(newLendExchangeRateX96, false);\n\n        Loan storage loan = loans[tokenId];\n\n        // if not in transfer mode - must be called from owner or the vault itself\n        if (!isTransformMode && tokenOwner[tokenId] != msg.sender && address(this) != msg.sender) {\n            revert Unauthorized();\n        }\n\n        uint256 shares = _convertToShares(assets, newDebtExchangeRateX96, Math.Rounding.Up);\n\n        uint256 loanDebtShares = loan.debtShares + shares;\n        loan.debtShares = loanDebtShares;\n        debtSharesTotal += shares;\n\n        if (debtSharesTotal > _convertToShares(globalDebtLimit, newDebtExchangeRateX96, Math.Rounding.Down)) {\n            revert GlobalDebtLimit();\n        }\n        if (assets > dailyDebtIncreaseLimitLeft) {\n            revert DailyDebtIncreaseLimit();\n        } else {\n            dailyDebtIncreaseLimitLeft -= assets;\n        }\n\n        _updateAndCheckCollateral(\n            tokenId, newDebtExchangeRateX96, newLendExchangeRateX96, loanDebtShares - shares, loanDe"
    }
  ]
}