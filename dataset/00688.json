{
  "Title": "Documentation Mismatch",
  "Content": "Throughout the codebase, there are several documentation mismatches:\n\n\n1. In the `Governance.sol` contract, specifically within the [`cancel` method](https://github.com/matter-labs/era-contracts/blob/2e0734b1ff9cbf3a88aadba6a19c4c4bc8645d33/ethereum/contracts/governance/Governance.sol#L154), the documentation indicates that both the owner and the `securityCouncil` have the ability to cancel. However, the implementation restricts this action solely to the owner through the `onlyOwner` modifier. This means in the event of the owner account getting compromised, the `securityCouncil` cannot intervene.\n2. In the `L2ContractHelper` contract, the `IL2Messenger` interface is described for sending arbitrary-length messages from L2 to L1. It describes the four parameters `senderAddress`, `isService`, `key`, and `value` of the underlying operation, but then [refers to `isService` as `marker`](https://github.com/matter-labs/era-contracts/blob/2e0734b1ff9cbf3a88aadba6a19c4c4bc8645d33/zksync/contracts/L2ContractHelper.sol#L14). Consider sticking to one word for consistency.\n3. In `LibMap.sol`, the [`_index` parameter](https://github.com/matter-labs/era-contracts/blob/2e0734b1ff9cbf3a88aadba6a19c4c4bc8645d33/ethereum/contracts/zksync/libraries/LibMap.sol#L34) of the `set` function is inaccurately described. The documentation states \"The index of the uint32 value to retrieve\", whereas it is used for setting the value.\n4. [The documentation](https://github.com/matter-labs/era-contracts/blob/2e0734b1ff9cbf3a88aadba6a19c4c4bc8645d33/ethereum/contracts/upgrades/BaseZkSyncUpgrade.sol#L22) of the `verifierParams` element of the `ProposedUpgrade` struct says that \"If either of its fields is 0, the params will not be updated\". However, in the [`_setVerifierParams` function](https://github.com/matter-labs/era-contracts/blob/2e0734b1ff9cbf3a88aadba6a19c4c4bc8645d33/ethereum/contracts/upgrades/BaseZkSyncUpgrade.sol#L122), the action of setting new parameters is only skipped when *all* parameters are zero. Consider correcting the documentation to match the implementation.\n\n\n***Update:** Resolved in [pull request #142](https://github.com/matter-labs/era-contracts/pull/142) at commit [a320b9b](https://github.com/matter-labs/era-contracts/pull/142/commits/a320b9b4e55b6f58e74dc79a4bd9cd39e44b174f).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "ethereum/contracts/governance/Governance.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {Ownable2Step} from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport {IGovernance} from \"./IGovernance.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @dev Contract design is inspired by OpenZeppelin TimelockController and in-house Diamond Proxy upgrade mechanism.\n/// @notice This contract manages operations (calls with preconditions) for governance tasks.\n/// The contract allows for operations to be scheduled, executed, and canceled with\n/// appropriate permissions and delays. It is used for managing and coordinating upgrades\n/// and changes in all zkSync Era governed contracts.\n///\n/// Operations can be proposed as either fully transparent upgrades with on-chain data,\n/// or \"shadow\" upgrades where upgrade data is not published on-chain before execution. Proposed operations\n/// are subject to a delay before they can be executed, but they can be executed instantly\n/// with the security council’s permission.\ncontract Governance is IGovernance, Ownable2Step {\n    /// @notice A constant representing the timestamp for completed operations.\n    uint256 internal constant EXECUTED_PROPOSAL_TIMESTAMP = uint256(1);\n\n    /// @notice The address of the security council.\n    /// @dev It is supposed to be multisig contract.\n    address public securityCouncil;\n\n    /// @notice A mapping to store timestamps where each operation will be ready for execution.\n    /// @dev - 0 means the operation is not created.\n    /// @dev - 1 (EXECUTED_PROPOSAL_TIMESTAMP) means the operation is already executed.\n    /// @dev - any other value means timestamp in seconds when the operation will be ready for execution.\n    mapping(bytes32 => uint256) public timestamps;\n\n    /// @notice The minimum delay in seconds for operations to be ready for execution.\n    uint256 public minDelay;\n\n    /// @notice Initializes the contract with the admin address, security council address, and minimum delay.\n    /// @param _admin The address to be assigned as the admin of the contract.\n    /// @param _securityCouncil The address to be assigned as the security council of the contract.\n    /// @param _minDelay The initial minimum delay (in seconds) to be set for operations.\n    constructor(address _admin, address _securityCouncil, uint256 _minDelay) {\n        require(_admin != address(0), \"Admin should be non zero address\");\n\n        _transferOwnership(_admin);\n\n        securityCouncil = _securityCouncil;\n        emit ChangeSecurityCouncil(address(0), _securityCouncil);\n\n        minDelay = _minDelay;\n        emit ChangeMinDelay(0, _minDelay);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Checks that the message sender is contract itself.\n    modifier onlySelf() {\n        require(msg.sender == address(this), \"Only governance contract itself allowed to call this function\");\n        _;\n    }\n\n    /// @notice Checks that the message sender is an active security council.\n    modifier onlySecurityCouncil() {\n        require(msg.sender == securityCouncil, \"Only security council allowed to call this function\");\n        _;\n    }\n\n    /// @notice Checks that the message sender is an active owner or an active security council.\n    modifier onlyOwnerOrSecurityCouncil() {\n        require(\n            msg.sender == owner() || msg.sender == securityCouncil,\n            \"Only the owner and security council are allowed to call this function\"\n        );\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            OPERATION GETTERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Returns whether an id corresponds to a registered operation. This\n    /// includes both Waiting, Ready, and Done operations.\n    function isOperation(bytes32 _id) public view returns (bool) {\n        return getOperationState(_id) != OperationState.Unset;\n    }\n\n    /// @dev Returns whether an operation is pending or not. Note that a \"pending\" operation may also be \"ready\".\n    function isOperationPending(bytes32 _id) public view returns (bool) {\n        OperationState state = getOperationState(_id);\n        return state == OperationState.Waiting || state == OperationState.Ready;\n    }\n\n    /// @dev Returns whether an operation is ready for execution. Note that a \"ready\" operation is also \"pending\".\n    function isOperationReady(bytes32 _id) public view returns (bool) {\n        return getOperationState(_id) == OperationState.Ready;\n    }\n\n    /// @dev Returns whether an operation is done or not.\n    function isOperationDone(bytes32 _id) public view returns (bool) {\n        return getOperationState(_id) == OperationState.Done;\n    }\n\n    /// @dev Returns operation state.\n    function getOperationState(bytes32 _id) public view returns (OperationState) {\n        uint256 timestamp = timestamps[_id];\n        if (timestamp == 0) {\n            return OperationState.Unset;\n        } else if (timestamp == EXECUTED_PROPOSAL_TIMESTAMP) {\n            return OperationState.Done;\n        } else if (timestamp > block.timestamp) {\n            return OperationState.Waiting;\n        } else {\n            return OperationState.Ready;\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            SCHEDULING CALLS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Propose a fully transparent upgrade, providing upgrade data on-chain.\n    /// @notice The owner will be able to execute the proposal either:\n    /// - With a `delay` timelock on its own.\n    /// - With security council instantly.\n    /// @dev Only the current owner can propose an upgrade.\n    /// @param _operation The operation parameters will be executed with the upgrade.\n    /// @param _delay The delay time (in seconds) after which the proposed upgrade can be executed by the owner.\n    function scheduleTransparent(Operation calldata _operation, uint256 _delay) external onlyOwner {\n        bytes32 id = hashOperation(_operation);\n        _schedule(id, _delay);\n        emit TransparentOperationScheduled(id, _delay, _operation);\n    }\n\n    /// @notice Propose \"shadow\" upgrade, upgrade data is not publishing on-chain.\n    /// @notice The owner will be able to execute the proposal either:\n    /// - With a `delay` timelock on its own.\n    /// - With security council instantly.\n    /// @dev Only the current owner can propose an upgrade.\n    /// @param _id The operation hash (see `hashOperation` function)\n    /// @param _delay The delay time (in seconds) after which the proposed upgrade may be executed by the owner.\n    function scheduleShadow(bytes32 _id, uint256 _delay) external onlyOwner {\n        _schedule(_id, _delay);\n        emit ShadowOperationScheduled(_id, _delay);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            CANCELING CALLS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Cancel the scheduled operation.\n    /// @dev Both the owner and security council may cancel an operation.\n    /// @param _id Proposal id value (see `hashOperation`)\n    function cancel(bytes32 _id) external onlyOwner {\n        require(isOperationPending(_id), \"Operation must be pending\");\n        delete timestamps[_id];\n        emit OperationCancelled(_id);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            EXECUTING CALLS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Executes the scheduled operation after the delay passed.\n    /// @dev Both the owner and security council may execute delayed operations.\n    /// @param _operation The operation parameters will be executed with the upgrade.\n    function execute(Operation calldata _operation) external payable onlyOwnerOrSecurityCouncil {\n        bytes32 id = hashOperation(_operation);\n        // Check if the predecessor operation is completed.\n        _checkPredecessorDone(_operation.predecessor);\n        // Ensure that the operation is ready to proceed.\n        require(isOperationReady(id), \"Operation must be ready before execution\");\n        // Execute operation.\n        _execute(_operation.calls);\n        // Reconfirming that the operation is still ready after execution.\n        // This is needed to avoid unexpected reentrancy attacks of re-executing the same operation.\n        require(isOperationReady(id), \"Operation must be ready after execution\");\n        // Set operation to be done\n        timestamps[id] = EXECUTED_PROPOSAL_TIMESTAMP;\n        emit OperationExecuted(id);\n    }\n\n    /// @notice Executes the scheduled operation with the security council instantly.\n    /// @dev Only the security council may execute an operation instantly.\n    /// @param _operation The operation parameters will be executed with the upgrade.\n    function executeInstant(Operation calldata _operation) external payable onlySecurityCouncil {\n        bytes32 id = hashOperation(_operation);\n        // Check if the predecessor operation is completed.\n        _checkPredecessorDone(_operation.predecessor);\n        // Ensure that the operation is in a pending state before proceeding.\n        require(isOperationPending(id), \"Operation must be pending before execution\");\n        // Execute operation.\n        _execute(_operation.calls);\n        // Reconfirming that the operation is still pending before execution.\n        // This is needed to avoid unexpected reentrancy attacks of re-executing the same operation.\n        require(isOperationPending(id), \"Operation must be pending after execution\");\n        // Set operation to be done\n        timestamps[id] = EXECUTED_PROPOSAL_TIMESTAMP;\n        emit OperationExecuted(id);\n    }\n\n    /// @dev Returns the identifier of an operation.\n    /// @param _operation The operation object to compute the identifier for.\n    function hashOperation(Operation calldata _operation) public pure returns (bytes32) {\n        return keccak256(abi.encode(_operation));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Schedule an operation that is to become valid after a given delay.\n    /// @param _id The operation hash (see `hashOperation` function)\n    /// @param _delay The delay time (in seconds) after which the proposed upgrade can be executed by the owner.\n    function _schedule(bytes32 _id, uint256 _delay) internal {\n        require(!isOperation(_id), \"Operation with this proposal id already exists\");\n        require(_delay >= minDelay, \"Proposed delay is less than minimum delay\");\n\n        timestamps[_id] = block.timestamp + _delay;\n    }\n\n    /// @dev Execute an operation's calls.\n    /// @param _calls The array of calls to be executed.\n    function _execute(Call[] calldata _calls) internal {\n        for (uint256 i = 0; i < _calls.length; ++i) {\n            (bool success, bytes memory returnData) = _calls[i].target.call{value: _calls[i].value}(_calls[i].data);\n            if (!success) {\n                // Propage an error if the call fails.\n                assembly {\n                    revert(add(returnData, 0x20), mload(returnData))\n                }\n            }\n        }\n    }\n\n    /// @notice Verifies if the predecessor operation is completed.\n    /// @param _predecessorId The hash of the operation that should be completed.\n    /// @dev Doesn't check the operation to be complete if the input is zero.\n    function _checkPredecessorDone(bytes32 _predecessorId) internal view {\n        require(_predecessorId == bytes32(0) || isOperationDone(_predecessorId), \"Predecessor operation not completed\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            SELF UPGRADES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Changes the minimum timelock duration for future operations.\n    /// @param _newDelay The new minimum delay time (in seconds) for future operations.\n    function updateDelay(uint256 _newDelay) external onlySelf {\n        emit ChangeMinDelay(minDelay, _newDelay);\n        minDelay = _newDelay;\n    }\n\n    /// @dev Updates the address of the security council.\n    /// @param _newSecurityCouncil The address of the new security council.\n    function updateSecurityCouncil(address _newSecurityCouncil) external onlySelf {\n        emit ChangeSecurityCouncil(securityCouncil, _newSecurityCouncil);\n        securityCouncil = _newSecurityCouncil;\n    }\n\n    /// @dev Contract might receive/hold ETH as part of the maintenance process.\n    receive() external payable {}\n}"
    },
    {
      "filename": "zksync/contracts/L2ContractHelper.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\n/**\n * @author Matter Labs\n * @custom:security-contact security@matterlabs.dev\n * @notice Smart contract for sending arbitrary length messages to L1\n * @dev by default ZkSync can send fixed-length messages on L1.\n * A fixed length message has 4 parameters `senderAddress` `isService`, `key`, `value`,\n * the first one is taken from the context, the other three are chosen by the sender.\n * @dev To send a variable-length message we use this trick:\n * - This system contract accepts an arbitrary length message and sends a fixed length message with\n * parameters `senderAddress == this`, `marker == true`, `key == msg.sender`, `value == keccak256(message)`.\n * - The contract on L1 accepts all sent messages and if the message came from this system contract\n * it requires that the preimage of `value` be provided.\n */\ninterface IL2Messenger {\n    /// @notice Sends an arbitrary length message to L1.\n    /// @param _message The variable length message to be sent to L1.\n    /// @return Returns the keccak256 hashed value of the message.\n    function sendToL1(bytes memory _message) external returns (bytes32);\n}\n\n/**\n * @author Matter Labs\n * @custom:security-contact security@matterlabs.dev\n * @notice Interface for the contract that is used to deploy contracts on L2.\n */\ninterface IContractDeployer {\n    /// @notice A struct that describes a forced deployment on an address.\n    /// @param bytecodeHash The bytecode hash to put on an address.\n    /// @param newAddress The address on which to deploy the bytecodehash to.\n    /// @param callConstructor Whether to run the constructor on the force deployment.\n    /// @param value The `msg.value` with which to initialize a contract.\n    /// @param input The constructor calldata.\n    struct ForceDeployment {\n        bytes32 bytecodeHash;\n        address newAddress;\n        bool callConstructor;\n        uint256 value;\n        bytes input;\n    }\n\n    /// @notice This method is to be used only during an upgrade to set bytecodes on specific addresses.\n    /// @param _deployParams A set of parameters describing force deployment.\n    function forceDeployOnAddresses(ForceDeployment[] calldata _deployParams) external payable;\n\n    /// @notice Creates a new contract at a determined address using the `CREATE2` salt on L2\n    /// @param _salt a unique value to create the deterministic address of the new contract\n    /// @param _bytecodeHash the bytecodehash of the new contract to be deployed\n    /// @param _input the calldata to be sent to the constructor of the new contract\n    function create2(bytes32 _salt, bytes32 _bytecodeHash, bytes calldata _input) external returns (address);\n}\n\n/**\n * @author Matter Labs\n * @custom:security-contact security@matterlabs.dev\n * @notice Interface for the contract that is used to simulate ETH on L2.\n */\ninterface IEthToken {\n    /// @notice Allows the withdrawal of ETH to a given L1 receiver along with an additional message.\n    /// @param _l1Receiver The address on L1 to receive the withdrawn ETH.\n    /// @param _additionalData Additional message or data to be sent alongside the withdrawal.\n    function withdrawWithMessage(address _l1Receiver, bytes memory _additionalData) external payable;\n}\n\nuint160 constant SYSTEM_CONTRACTS_OFFSET = 0x8000; // 2^15\n\naddress constant BOOTLOADER_ADDRESS = address(SYSTEM_CONTRACTS_OFFSET + 0x01);\naddress constant MSG_VALUE_SYSTEM_CONTRACT = address(SYSTEM_CONTRACTS_OFFSET + 0x09);\naddress constant DEPLOYER_SYSTEM_CONTRACT = address(SYSTEM_CONTRACTS_OFFSET + 0x06);\n\nIL2Messenger constant L2_MESSENGER = IL2Messenger(address(SYSTEM_CONTRACTS_OFFSET + 0x08));\n\nIEthToken constant L2_ETH_ADDRESS = IEthToken(address(SYSTEM_CONTRACTS_OFFSET + 0x0a));\n\n/**\n * @author Matter Labs\n * @custom:security-contact security@matterlabs.dev\n * @notice Helper library for working with L2 contracts on L1.\n */\nlibrary L2ContractHelper {\n    /// @dev The prefix used to create CREATE2 addresses.\n    bytes32 constant CREATE2_PREFIX = keccak256(\"zksyncCreate2\");\n\n    /// @notice Sends L2 -> L1 arbitrary-long message through the system contract messenger.\n    /// @param _message Data to be sent to L1.\n    /// @return keccak256 hash of the sent message.\n    function sendMessageToL1(bytes memory _message) internal returns (bytes32) {\n        return L2_MESSENGER.sendToL1(_message);\n    }\n\n    /// @notice Computes the create2 address for a Layer 2 contract.\n    /// @param _sender The address of the contract creator.\n    /// @param _salt The salt value to use in the create2 address computation.\n    /// @param _bytecodeHash The contract bytecode hash.\n    /// @param _constructorInputHash The keccak256 hash of the constructor input data.\n    /// @return The create2 address of the contract.\n    /// NOTE: L2 create2 derivation is different from L1 derivation!\n    function computeCreate2Address(\n        address _sender,\n        bytes32 _salt,\n        bytes32 _bytecodeHash,\n        bytes32 _constructorInputHash\n    ) internal pure returns (address) {\n        bytes32 senderBytes = bytes32(uint256(uint160(_sender)));\n        bytes32 data = keccak256(\n            bytes.concat(CREATE2_PREFIX, senderBytes, _salt, _bytecodeHash, _constructorInputHash)\n        );\n\n        return address(uint160(uint256(data)));\n    }\n}\n\n/// @notice Structure used to represent zkSync transaction.\nstruct Transaction {\n    // The type of the transaction.\n    uint256 txType;\n    // The caller.\n    uint256 from;\n    // The callee.\n    uint256 to;\n    // The gasLimit to pass with the transaction.\n    // It has the same meaning as Ethereum's gasLimit.\n    uint256 gasLimit;\n    // The maximum amount of gas the user is willing to pay for a byte of pubdata.\n    uint256 gasPerPubdataByteLimit;\n    // The maximum fee per gas that the user is willing to pay.\n    // It is akin to EIP1559's maxFeePerGas.\n    uint256 maxFeePerGas;\n    // The maximum priority fee per gas that the user is willing to pay.\n    // It is akin to EIP1559's maxPriorityFeePerGas.\n    uint256 maxPriorityFeePerGas;\n    // The transaction's paymaster. If there is no paymaster, it is equal to 0.\n    uint256 paymaster;\n    // The nonce of the transaction.\n    uint256 nonce;\n    // The value to pass with the transaction.\n    uint256 value;\n    // In the future, we might want to add some\n    // new fields to the struct. The `txData` struct\n    // is to be passed to account and any changes to its structure\n    // would mean a breaking change to these accounts. In order to prevent this,\n    // we should keep some fields as \"reserved\".\n    // It is also recommended that their length is fixed, since\n    // it would allow easier proof integration (in case we will need\n    // some special circuit for preprocessing transactions).\n    uint256[4] reserved;\n    // The transaction's calldata.\n    bytes data;\n    // The signature of the transaction.\n    bytes signature;\n    // The properly formatted hashes of bytecodes that must be published on L1\n    // with the inclusion of this transaction. Note, that a bytecode has been published\n    // before, the user won't pay fees for its republishing.\n    bytes32[] factoryDeps;\n    // The input to the paymaster.\n    bytes paymasterInput;\n    // Reserved dynamic type for the future use-case. Using it should be avoided,\n    // But it is still here, just in case we want to enable some additional functionality.\n    bytes reservedDynamic;\n}"
    },
    {
      "filename": "ethereum/contracts/zksync/libraries/LibMap.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\n/// @notice Library for storage of packed unsigned integers.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibMap.sol)\nlibrary LibMap {\n    /// @dev A uint32 map in storage.\n    struct Uint32Map {\n        mapping(uint256 => uint256) map;\n    }\n\n    /// @dev Retrieves the uint32 value at a specific index from the Uint32Map.\n    /// @param _map The Uint32Map instance containing the packed uint32 values.\n    /// @param _index The index of the uint32 value to retrieve.\n    /// @return result The uint32 value at the specified index.\n    function get(Uint32Map storage _map, uint256 _index) internal view returns (uint32 result) {\n        unchecked {\n            // Each storage slot can store 256 bits of data.\n            // As uint32 is 32 bits long, 8 uint32s can be packed into one storage slot.\n            // Hence, `_index / 8` is done to find the storage slot that contains the required uint32.\n            uint256 mapValue = _map.map[_index / 8];\n\n            // First three bits of the original `_index` denotes the position of the uint32 in that slot.\n            // So, '(_index & 7) * 32' is done to find the bit position of the uint32 in that storage slot.\n            uint256 bitOffset = (_index & 7) * 32;\n\n            // Shift the bits to the right and retrieve the uint32 value.\n            result = uint32(mapValue >> bitOffset);\n        }\n    }\n\n    /// @dev Updates the uint32 value at `_index` in `map`.\n    /// @param _map The Uint32Map instance containing the packed uint32 values.\n    /// @param _index The index of the uint32 value to retrieve.\n    /// @param _value The new value at the specified index.\n    function set(Uint32Map storage _map, uint256 _index, uint32 _value) internal {\n        unchecked {\n            // Each storage slot can store 256 bits of data.\n            // As uint32 is 32 bits long, 8 uint32s can be packed into one storage slot.\n            // Hence, `_index / 8` is done to find the storage slot that contains the required uint32.\n            uint256 mapIndex = _index / 8;\n            uint256 mapValue = _map.map[mapIndex];\n\n            // First three bits of the original `_index` denotes the position of the uint32 in that slot.\n            // So, '(_index & 7) * 32' is done to find the bit position of the uint32 in that storage slot.\n            uint256 bitOffset = (_index & 7) * 32;\n\n            // XORing a value A with B, and then with A again, gives the original value B.\n            // We will use this property to update the uint32 value in the slot.\n\n            // Shift the bits to the right and retrieve the uint32 value.\n            uint32 oldValue = uint32(mapValue >> bitOffset);\n\n            // Calculate the XOR of the new value and the existing value.\n            uint256 newValueXorOldValue = uint256(oldValue ^ _value);\n\n            // Finally, we XOR the slot with the XOR of the new value and the existing value,\n            // shifted to its proper position. The XOR operation will effectively replace the old value with the new value.\n            _map.map[mapIndex] = (newValueXorOldValue << bitOffset) ^ mapValue;\n        }\n    }\n}"
    },
    {
      "filename": "ethereum/contracts/upgrades/BaseZkSyncUpgrade.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport \"../zksync/facets/Base.sol\";\nimport \"../zksync/interfaces/IMailbox.sol\";\nimport \"../zksync/interfaces/IVerifier.sol\";\nimport \"../common/libraries/L2ContractHelper.sol\";\nimport \"../zksync/libraries/TransactionValidator.sol\";\nimport {SYSTEM_UPGRADE_L2_TX_TYPE, MAX_NEW_FACTORY_DEPS, MAX_ALLOWED_PROTOCOL_VERSION_DELTA} from \"../zksync/Config.sol\";\n\n/// @author Matter Labs\n/// @custom:security-contact security@matterlabs.dev\n/// @notice Interface to which all the upgrade implementations should adhere\nabstract contract BaseZkSyncUpgrade is Base {\n    /// @notice The struct that represents the upgrade proposal.\n    /// @param l2ProtocolUpgradeTx The system upgrade transaction.\n    /// @param factoryDeps The list of factory deps for the l2ProtocolUpgradeTx.\n    /// @param bootloaderHash The hash of the new bootloader bytecode. If zero, it will not be updated.\n    /// @param defaultAccountHash The hash of the new default account bytecode. If zero, it will not be updated.\n    /// @param verifier The address of the new verifier. If zero, the verifier will not be updated.\n    /// @param verifierParams The new verifier params. If either of its fields is 0, the params will not be updated.\n    /// @param l1ContractsUpgradeCalldata Custom calldata for L1 contracts upgrade, it may be interpreted differently\n    /// in each upgrade. Usually empty.\n    /// @param postUpgradeCalldata Custom calldata for post upgrade hook, it may be interpreted differently in each\n    /// upgrade. Usually empty.\n    /// @param upgradeTimestamp The timestamp after which the upgrade can be executed.\n    /// @param newProtocolVersion The new version number for the protocol after this upgrade. Should be greater than\n    /// the previous protocol version.\n    struct ProposedUpgrade {\n        IMailbox.L2CanonicalTransaction l2ProtocolUpgradeTx;\n        bytes[] factoryDeps;\n        bytes32 bootloaderHash;\n        bytes32 defaultAccountHash;\n        address verifier;\n        VerifierParams verifierParams;\n        bytes l1ContractsUpgradeCalldata;\n        bytes postUpgradeCalldata;\n        uint256 upgradeTimestamp;\n        uint256 newProtocolVersion;\n    }\n\n    /// @notice Changes the protocol version\n    event NewProtocolVersion(uint256 indexed previousProtocolVersion, uint256 indexed newProtocolVersion);\n\n    /// @notice Сhanges to the bytecode that is used in L2 as a bootloader (start program)\n    event NewL2BootloaderBytecodeHash(bytes32 indexed previousBytecodeHash, bytes32 indexed newBytecodeHash);\n\n    /// @notice Сhanges to the bytecode that is used in L2 as a default account\n    event NewL2DefaultAccountBytecodeHash(bytes32 indexed previousBytecodeHash, bytes32 indexed newBytecodeHash);\n\n    /// @notice Verifier address changed\n    event NewVerifier(address indexed oldVerifier, address indexed newVerifier);\n\n    /// @notice Verifier parameters changed\n    event NewVerifierParams(VerifierParams oldVerifierParams, VerifierParams newVerifierParams);\n\n    /// @notice Notifies about complete upgrade\n    event UpgradeComplete(uint256 indexed newProtocolVersion, bytes32 indexed l2UpgradeTxHash, ProposedUpgrade upgrade);\n\n    /// @notice The main function that will be provided by the upgrade proxy\n    function upgrade(ProposedUpgrade calldata _proposedUpgrade) public virtual returns (bytes32) {\n        // Note that due to commitment delay, the timestamp of the L2 upgrade batch may be earlier than the timestamp\n        // of the L1 block at which the upgrade occured. This means that using timestamp as a signifier of \"upgraded\"\n        // on the L2 side would be inaccurate. The effects of this \"back-dating\" of L2 upgrade batches will be reduced\n        // as the permitted delay window is reduced in the future.\n        require(block.timestamp >= _proposedUpgrade.upgradeTimestamp, \"Upgrade is not ready yet\");\n    }\n\n    /// @notice Change default account bytecode hash, that is used on L2\n    /// @param _l2DefaultAccountBytecodeHash The hash of default account L2 bytecode\n    function _setL2DefaultAccountBytecodeHash(bytes32 _l2DefaultAccountBytecodeHash) private {\n        if (_l2DefaultAccountBytecodeHash == bytes32(0)) {\n            return;\n        }\n\n        L2ContractHelper.validateBytecodeHash(_l2DefaultAccountBytecodeHash);\n\n        // Save previous value into the stack to put it into the event later\n        bytes32 previousDefaultAccountBytecodeHash = s.l2DefaultAccountBytecodeHash;\n\n        // Change the default account bytecode hash\n        s.l2DefaultAccountBytecodeHash = _l2DefaultAccountBytecodeHash;\n        emit NewL2DefaultAccountBytecodeHash(previousDefaultAccountBytecodeHash, _l2DefaultAccountBytecodeHash);\n    }\n\n    /// @notice Change bootloader bytecode hash, that is used on L2\n    /// @param _l2BootloaderBytecodeHash The hash of bootloader L2 bytecode\n    function _setL2BootloaderBytecodeHash(bytes32 _l2BootloaderBytecodeHash) private {\n        if (_l2BootloaderBytecodeHash == bytes32(0)) {\n            return;\n        }\n\n        L2ContractHelper.validateBytecodeHash(_l2BootloaderBytecodeHash);\n\n        // Save previous value into the stack to put it into the event later\n        bytes32 previousBootloaderBytecodeHash = s.l2BootloaderBytecodeHash;\n\n        // Change the bootloader bytecode hash\n        s.l2BootloaderBytecodeHash = _l2BootloaderBytecodeHash;\n        emit NewL2BootloaderBytecodeHash(previousBootloaderBytecodeHash, _l2BootloaderBytecodeHash);\n    }\n\n    /// @notice Change the address of the verifier smart contract\n    /// @param _newVerifier Verifier smart contract address\n    function _setVerifier(IVerifier _newVerifier) private {\n        // An upgrade to the verifier must be done carefully to ensure there aren't batches in the committed state\n        // during the transition. If verifier is upgraded, it will immediately be used to prove all committed batches.\n        // Batches committed expecting the old verifier will fail. Ensure all commited batches are finalized before the\n        // verifier is upgraded.\n        if (_newVerifier == IVerifier(address(0))) {\n            return;\n        }\n\n        IVerifier oldVerifier = s.verifier;\n        s.verifier = _newVerifier;\n        emit NewVerifier(address(oldVerifier), address(_newVerifier));\n    }\n\n    /// @notice Change the verifier parameters\n    /// @param _newVerifierParams New parameters for the verifier\n    function _setVerifierParams(VerifierParams calldata _newVerifierParams) private {\n        if (\n            _newVerifierParams.recursionNodeLevelVkHash == bytes32(0) &&\n            _newVerifierParams.recursionLeafLevelVkHash == bytes32(0) &&\n            _newVerifierParams.recursionCircuitsSetVksHash == bytes32(0)\n        ) {\n            return;\n        }\n\n        VerifierParams memory oldVerifierParams = s.verifierParams;\n        s.verifierParams = _newVerifierParams;\n        emit NewVerifierParams(oldVerifierParams, _newVerifierParams);\n    }\n\n    /// @notice Updates the verifier and the verifier params\n    /// @param _newVerifier The address of the new verifier. If 0, the verifier will not be updated.\n    /// @param _verifierParams The new verifier params. If either of the fields is 0, the params will not be updated.\n    function _upgradeVerifier(address _newVerifier, VerifierParams calldata _verifierParams) internal {\n        _setVerifier(IVerifier(_newVerifier));\n        _setVerifierParams(_verifierParams);\n    }\n\n    /// @notice Updates the bootloader hash and the hash of the default account\n    /// @param _bootloaderHash The hash of the new bootloader bytecode. If zero, it will not be updated.\n    /// @param _defaultAccountHash The hash of the new default account bytecode. If zero, it will not be updated.\n    function _setBaseSystemContracts(bytes32 _bootloaderHash, bytes32 _defaultAccountHash) internal {\n        _setL2BootloaderBytecodeHash(_bootloaderHash);\n        _setL2DefaultAccountBytecodeHash(_defaultAccountHash);\n    }\n\n    /// @notice Sets the hash of the L2 system contract upgrade transaction for the next batch to be committed\n    /// @dev If the transaction is noop (i.e. its type is 0) it does nothing and returns 0.\n    /// @param _l2ProtocolUpgradeTx The L2 system contract upgrade transaction.\n    /// @return System contracts upgrade transaction hash. Zero if no upgrade transaction is set.\n    function _setL2SystemContractUpgrade(\n        IMailbox.L2CanonicalTransaction calldata _l2ProtocolUpgradeTx,\n        bytes[] calldata _factoryDeps,\n        uint256 _newProtocolVersion\n    ) internal returns (bytes32) {\n        // If the type is 0, it is considered as noop and so will not be required to be executed.\n        if (_l2ProtocolUpgradeTx.txType == 0) {\n            return bytes32(0);\n        }\n\n        require(_l2ProtocolUpgradeTx.txType == SYSTEM_UPGRADE_L2_TX_TYPE, \"L2 system upgrade tx type is wrong\");\n\n        bytes memory encodedTransaction = abi.encode(_l2ProtocolUpgradeTx);\n\n        TransactionVali"
    }
  ]
}