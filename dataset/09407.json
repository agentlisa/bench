{
  "Title": "[L-04] Front-runable initializer",
  "Content": "\nIf the initializer is not executed in the same transaction as the constructor, a malicious user can front-run the `initialize()` call, forcing the contract to be redeployed. Most other initializers in this project are protected, but this one appears not to be.\n\n```solidity\nFile: backd/contracts/AddressProvider.sol   #1\n\n53    function initialize(address roleManager) external initializer {\n54        AddressProviderMeta.Meta memory meta = AddressProviderMeta.Meta(true, true);\n55        _addressKeyMetas.set(AddressProviderKeys._ROLE_MANAGER_KEY, meta.toUInt());\n56        _setConfig(AddressProviderKeys._ROLE_MANAGER_KEY, roleManager);\n57    }\n```\n\n<https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/AddressProvider.sol#L53-L57>\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2022-04-backd-contest",
  "Code": [
    {
      "filename": "backd/contracts/AddressProvider.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport \"../interfaces/IGasBank.sol\";\nimport \"../interfaces/IAddressProvider.sol\";\nimport \"../interfaces/IStakerVault.sol\";\nimport \"../interfaces/oracles/IOracleProvider.sol\";\n\nimport \"../libraries/EnumerableExtensions.sol\";\nimport \"../libraries/EnumerableMapping.sol\";\nimport \"../libraries/AddressProviderKeys.sol\";\nimport \"../libraries/AddressProviderMeta.sol\";\nimport \"../libraries/Roles.sol\";\n\nimport \"./access/AuthorizationBase.sol\";\nimport \"./utils/Preparable.sol\";\n\n// solhint-disable ordering\n\ncontract AddressProvider is IAddressProvider, AuthorizationBase, Initializable, Preparable {\n    using EnumerableMapping for EnumerableMapping.AddressToAddressMap;\n    using EnumerableMapping for EnumerableMapping.Bytes32ToUIntMap;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using EnumerableExtensions for EnumerableSet.AddressSet;\n    using EnumerableExtensions for EnumerableSet.Bytes32Set;\n    using EnumerableExtensions for EnumerableMapping.AddressToAddressMap;\n    using EnumerableExtensions for EnumerableMapping.Bytes32ToUIntMap;\n    using AddressProviderMeta for AddressProviderMeta.Meta;\n\n    // LpToken -> stakerVault\n    EnumerableMapping.AddressToAddressMap internal _stakerVaults;\n\n    EnumerableSet.AddressSet internal _whiteListedFeeHandlers;\n\n    // value is encoded as (bool freezable, bool frozen)\n    EnumerableMapping.Bytes32ToUIntMap internal _addressKeyMetas;\n\n    EnumerableSet.AddressSet internal _actions; // list of all actions ever registered\n\n    EnumerableSet.AddressSet internal _vaults; // list of all active vaults\n\n    EnumerableMapping.AddressToAddressMap internal _tokenToPools;\n\n    constructor(address treasury) {\n        AddressProviderMeta.Meta memory meta = AddressProviderMeta.Meta(true, false);\n        _addressKeyMetas.set(AddressProviderKeys._TREASURY_KEY, meta.toUInt());\n        _setConfig(AddressProviderKeys._TREASURY_KEY, treasury);\n    }\n\n    function initialize(address roleManager) external initializer {\n        AddressProviderMeta.Meta memory meta = AddressProviderMeta.Meta(true, true);\n        _addressKeyMetas.set(AddressProviderKeys._ROLE_MANAGER_KEY, meta.toUInt());\n        _setConfig(AddressProviderKeys._ROLE_MANAGER_KEY, roleManager);\n    }\n\n    function getKnownAddressKeys() external view returns (bytes32[] memory) {\n        return _addressKeyMetas.keysArray();\n    }\n\n    function addFeeHandler(address feeHandler) external onlyGovernance returns (bool) {\n        require(!_whiteListedFeeHandlers.contains(feeHandler), Error.ADDRESS_WHITELISTED);\n        _whiteListedFeeHandlers.add(feeHandler);\n        return true;\n    }\n\n    function removeFeeHandler(address feeHandler) external onlyGovernance returns (bool) {\n        require(_whiteListedFeeHandlers.contains(feeHandler), Error.ADDRESS_NOT_WHITELISTED);\n        _whiteListedFeeHandlers.remove(feeHandler);\n        return true;\n    }\n\n    /**\n     * @notice Adds action.\n     * @param action Address of action to add.\n     */\n    function addAction(address action) external onlyGovernance returns (bool) {\n        bool result = _actions.add(action);\n        if (result) {\n            emit ActionListed(action);\n        }\n        return result;\n    }\n\n    /**\n     * @notice Adds pool.\n     * @param pool Address of pool to add.\n     */\n    function addPool(address pool)\n        external\n        override\n        onlyRoles2(Roles.POOL_FACTORY, Roles.GOVERNANCE)\n    {\n        require(pool != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n\n        ILiquidityPool ipool = ILiquidityPool(pool);\n        address poolToken = ipool.getLpToken();\n        require(poolToken != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n        if (_tokenToPools.set(poolToken, pool)) {\n            address vault = address(ipool.getVault());\n            if (vault != address(0)) {\n                _vaults.add(vault);\n            }\n            emit PoolListed(pool);\n        }\n    }\n\n    /**\n     * @notice Delists pool.\n     * @param pool Address of pool to delist.\n     * @return `true` if successful.\n     */\n    function removePool(address pool) external override onlyRole(Roles.CONTROLLER) returns (bool) {\n        address lpToken = ILiquidityPool(pool).getLpToken();\n        bool removed = _tokenToPools.remove(lpToken);\n        if (removed) {\n            address vault = address(ILiquidityPool(pool).getVault());\n            if (vault != address(0)) {\n                _vaults.remove(vault);\n            }\n            emit PoolDelisted(pool);\n        }\n\n        return removed;\n    }\n\n    /** Vault functions  */\n\n    /**\n     * @notice returns all the registered vaults\n     */\n    function allVaults() external view returns (address[] memory) {\n        return _vaults.toArray();\n    }\n\n    /**\n     * @notice returns the vault at the given index\n     */\n    function getVaultAtIndex(uint256 index) external view returns (address) {\n        return _vaults.at(index);\n    }\n\n    /**\n     * @notice returns the number of vaults\n     */\n    function vaultsCount() external view returns (uint256) {\n        return _vaults.length();\n    }\n\n    function isVault(address vault) external view returns (bool) {\n        return _vaults.contains(vault);\n    }\n\n    function updateVault(address previousVault, address newVault) external onlyRole(Roles.POOL) {\n        if (previousVault != address(0)) {\n            _vaults.remove(previousVault);\n        }\n        if (newVault != address(0)) {\n            _vaults.add(newVault);\n        }\n        emit VaultUpdated(previousVault, newVault);\n    }\n\n    /**\n     * @notice Returns the address for the given key\n     */\n    function getAddress(bytes32 key) public view returns (address) {\n        require(_addressKeyMetas.contains(key), Error.ADDRESS_DOES_NOT_EXIST);\n        return currentAddresses[key];\n    }\n\n    /**\n     * @notice Returns the address for the given key\n     * @dev if `checkExists` is true, it will fail if the key does not exist\n     */\n    function getAddress(bytes32 key, bool checkExists) public view returns (address) {\n        require(!checkExists || _addressKeyMetas.contains(key), Error.ADDRESS_DOES_NOT_EXIST);\n        return currentAddresses[key];\n    }\n\n    /**\n     * @notice returns the address metadata for the given key\n     */\n    function getAddressMeta(bytes32 key) public view returns (AddressProviderMeta.Meta memory) {\n        (bool exists, uint256 metadata) = _addressKeyMetas.tryGet(key);\n        require(exists, Error.ADDRESS_DOES_NOT_EXIST);\n        return AddressProviderMeta.fromUInt(metadata);\n    }\n\n    function initializeAddress(bytes32 key, address initialAddress) external {\n        initializeAddress(key, initialAddress, false);\n    }\n\n    /**\n     * @notice Initializes an address\n     * @param key Key to initialize\n     * @param initialAddress Address for `key`\n     */\n    function initializeAddress(\n        bytes32 key,\n        address initialAddress,\n        bool freezable\n    ) public override onlyGovernance {\n        AddressProviderMeta.Meta memory meta = AddressProviderMeta.Meta(freezable, false);\n        _initializeAddress(key, initialAddress, meta);\n    }\n\n    /**\n     * @notice Initializes and freezes address\n     * @param key Key to initialize\n     * @param initialAddress Address for `key`\n     */\n    function initializeAndFreezeAddress(bytes32 key, address initialAddress)\n        external\n        override\n        onlyGovernance\n    {\n        AddressProviderMeta.Meta memory meta = AddressProviderMeta.Meta(true, true);\n        _initializeAddress(key, initialAddress, meta);\n    }\n\n    /**\n     * @notice Freezes a configuration key, making it immutable\n     * @param key Key to feeze\n     */\n    function freezeAddress(bytes32 key) external override onlyGovernance {\n        AddressProviderMeta.Meta memory meta = getAddressMeta(key);\n        require(!meta.frozen, Error.ADDRESS_FROZEN);\n        require(meta.freezable, Error.INVALID_ARGUMENT);\n        meta.frozen = true;\n        _addressKeyMetas.set(key, meta.toUInt());\n    }\n\n    /**\n     * @notice Prepare update of an address\n     * @param key Key to update\n     * @param newAddress New address for `key`\n     * @return `true` if successful.\n     */\n    function prepareAddress(bytes32 key, address newAddress)\n        external\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        AddressProviderMeta.Meta memory meta = getAddressMeta(key);\n        require(!meta.frozen, Error.ADDRESS_FROZEN);\n        return _prepare(key, newAddress);\n    }\n\n    /**\n     * @notice Execute update of `key`\n     * @return New address.\n     */\n    function executeAddress(bytes32 key) external override returns (address) {\n        AddressProviderMeta.Meta memory meta = getAddressMeta(key);\n        require(!meta.frozen, Error.ADDRESS_FROZEN);\n        return _executeAddress(key);\n    }\n\n    /**\n     * @notice Reset `key`\n     * @return true if it was reset\n     */\n    function resetAddress(bytes32 key) external onlyGovernance returns (bool) {\n        return _resetAddressConfig(key);\n    }\n\n    /**\n     * @notice Add a new staker vault and add it's lpGauge if set in vault.\n     * @dev This fails if the token of the staker vault is the token of an existing staker vault.\n     * @param stakerVault Vault to add.\n     * @return `true` if successful.\n     */\n    function addStakerVault(address stakerVault)\n        external\n        override\n        onlyRole(Roles.CONTROLLER)\n        returns (bool)\n    {\n        address token = IStakerVault(stakerVault).getToken();\n        require(token != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n        require(!_stakerVaults.contains(token), Error.STAKER_VAULT_EXISTS);\n        _stakerVaults.set(token, stakerVault);\n        emit StakerVaultListed(stakerVault);\n        return true;\n    }\n\n    function isWhiteListedFeeHandler(address feeHandler) external view override returns (bool) {\n        return _whiteListedFeeHandlers.contains(feeHandler);\n    }\n\n    /**\n     * @notice Get the liquidity pool for a given token\n     * @dev Does not revert if the pool deos not exist\n     * @param token Token for which to get the pool.\n     * @return Pool address.\n     */\n    function safeGetPoolForToken(address token) external view override returns (address) {\n        (, address poolAddress) = _tokenToPools.tryGet(token);\n        return poolAddress;\n    }\n\n    /**\n     * @notice Get the liquidity pool for a given token\n     * @dev Reverts if the pool deos not exist\n     * @param token Token for which to get the pool.\n     * @return Pool address.\n     */\n    function getPoolForToken(address token) external view override returns (ILiquidityPool) {\n        (bool exists, address poolAddress) = _tokenToPools.tryGet(token);\n        require(exists, Error.ADDRESS_NOT_FOUND);\n        return ILiquidityPool(poolAddress);\n    }\n\n    /**\n     * @notice Get list of all action addresses.\n     * @return Array with action addresses.\n     */\n    function allActions() external view override returns (address[] memory) {\n        return _actions.toArray();\n    }\n\n    /**\n     * @notice Check whether an address is an action.\n     * @param action Address to check whether it is action.\n     * @return True if address is an action.\n     */\n    function isAction(address action) external view override returns (bool) {\n        return _actions.contains(action);\n    }\n\n    /**\n     * @notice Check whether an address is an pool.\n     * @param pool Address to check whether it is a pool.\n     * @return True if address is a pool.\n     */\n    function isPool(address pool) external view returns (bool) {\n        address lpToken = ILiquidityPool(pool).getLpToken();\n        (bool exists, address poolAddress) = _tokenToPools.tryGet(lpToken);\n        return exists && pool == poolAddress;\n    }\n\n    /**\n     * @notice Get list of all pool addresses.\n     * @return Array with pool addresses.\n     */\n    function allPools() external view override returns (address[] memory) {\n        return _tokenToPools.valuesArray();\n    }\n\n    /**\n     * @notice returns the pool at the given index\n     */\n    function getPoolAtIndex(uint256 index) external view returns (address) {\n        return _tokenToPools.valueAt(index);\n    }\n\n    /**\n     * @notice returns the number of pools\n     */\n    function poolsCount() external view returns (uint256) {\n        return _tokenToPools.length();\n    }\n\n    /**\n     * @notice Returns all the staker vaults.\n     */\n    function allStakerVaults() external view override returns (address[] memory) {\n        return _stakerVaults.valuesArray();\n    }\n\n    /**\n     * @notice Get the staker vault for a given token\n     * @dev There can only exist one staker vault per unique token.\n     * @param token Token for which to get the vault.\n     * @return Vault address.\n     */\n    function getStakerVault(address token) external view override returns (address) {\n        return _stakerVaults.get(token);\n    }\n\n    /**\n     * @notice Tries to get the staker vault for a given token but does not throw if it does not exist\n     * @return A boolean set to true if the vault exists and the vault address.\n     */\n    function tryGetStakerVault(address token) external view override returns (bool, address) {\n        return _stakerVaults.tryGet(token);\n    }\n\n    /**\n     * @notice Check if a vault is registered (exists).\n     * @param stakerVault Address of staker vault to check.\n     * @return `true` if registered, `false` if not.\n     */\n    function isStakerVaultRegistered(address stakerVault) external view override returns (bool) {\n        address token = IStakerVault(stakerVault).getToken();\n        return isStakerVault(stakerVault, token);\n    }\n\n    function isStakerVault(address stakerVault, address token) public view override returns (bool) {\n        (bool exists, address vault) = _stakerVaults.tryGet(token);\n        return exists && vault == stakerVault;\n    }\n\n    function _roleManager() internal view override returns (IRoleManager) {\n        return IRoleManager(getAddress(AddressProviderKeys._ROLE_MANAGER_KEY));\n    }\n\n    function _initializeAddress(\n        bytes32 key,\n        address initialAddress,\n        AddressProviderMeta.Meta memory meta\n    ) internal {\n        require(!_addressKeyMetas.contains(key), Error.INVALID_ARGUMENT);\n        _addKnownAddressKey(key, meta);\n        _setConfig(key, initialAddress);\n    }\n\n    function _addKnownAddressKey(bytes32 key, AddressProviderMeta.Meta memory meta) internal {\n        require(_addressKeyMetas.set(key, meta.toUInt()), Error.INVALID_ARGUMENT);\n        emit KnownAddressKeyAdded(key);\n    }\n}"
    }
  ]
}