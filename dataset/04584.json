{
  "Title": "Unclear semantics for Transfer",
  "Content": "The [ERC20 token standard](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md) specifies the [`Transfer`](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#transfer-1) event to log transfers. The specification is informal, and there is not an exact characterization of when the event should be emitted. However, since this event is relied on by applications, it is in the interest of the project to try to respect the semantics that applications expect. This will pay off in a better user experience, and probably lower operational costs.\n\n\nThe `Transfer` event is used throughout `FuelToken` in unexpected and inconsistent ways. When vested tokens are released (via [`releaseVanbexTeamTokens`](https://github.com/etherparty/FUEL-Contracts/blob/3717b751bb2fa57ae300776a93ee4d7d7beb2c07/contracts/FuelToken.sol#L179)), a [transfer from the token contract itself](https://github.com/etherparty/FUEL-Contracts/blob/3717b751bb2fa57ae300776a93ee4d7d7beb2c07/contracts/FuelToken.sol#L182) is logged. This is conflicting with the expected semantics of the event, because the token contract didn’t have those tokens as part of its balance to begin with. In [`transferFromCrowdfund`](https://github.com/etherparty/FUEL-Contracts/blob/3717b751bb2fa57ae300776a93ee4d7d7beb2c07/contracts/FuelToken.sol#L169), the event is emitted [with the crowdfund as the source](https://github.com/etherparty/FUEL-Contracts/blob/3717b751bb2fa57ae300776a93ee4d7d7beb2c07/contracts/FuelToken.sol#L174), but there was never a `Transfer` event with the crowdfund as the destination.\n\n\nConsider emitting this event with the zero address as the `from` field, which is the [accepted way](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#transfer) to log creation of tokens.\n\n\n***Update:** Fixed in [`759557a`](https://github.com/etherparty/FUEL-Contracts/commit/759557a4d5ba55b26f7f55fed514129633d9cca3) and [`a363180`](https://github.com/etherparty/FUEL-Contracts/commit/a363180b96141e8fdba2affa896c56bc0cbb1c9a).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/FuelToken.sol",
      "content": "pragma solidity ^0.4.15;\n\nimport \"zeppelin-solidity/contracts/math/SafeMath.sol\";\nimport 'zeppelin-solidity/contracts/ownership/Ownable.sol';\nimport 'zeppelin-solidity/contracts/token/ERC20.sol';\nimport \"./helpers/NonZero.sol\";\n\n\ncontract FuelToken is ERC20, Ownable, NonZero {\n\n    using SafeMath for uint;\n\n/////////////////////// TOKEN INFORMATION ///////////////////////\n    string public constant name = \"Fuel Token\";\n    string public constant symbol = \"FUEL\";\n\n    uint8 public decimals = 18;\n    \n    // Mapping to keep user's balances\n    mapping (address => uint256) balances;\n    // Mapping to keep user's allowances\n    mapping (address => mapping (address => uint256)) allowed;\n\n/////////////////////// VARIABLE INITIALIZATION ///////////////////////\n    \n    // Total FUEL allocated at a given time\n    uint256 public totalAllocatedTokens;\n    // Allocation for the Vanbex Team\n    uint256 public vanbexTeamSupply;\n    // Etherparty platform supply\n    uint256 public platformSupply;\n    // Total amount of Public FUEL that will be allocated\n    uint256 public amountOfPublicTokensToAllocate;\n    // Amount of FUEL for the presale\n    uint256 public presaleSupply;\n    // Amount of presale tokens remaining at a given time\n    uint256 public presaleAmountRemaining;\n    // Total ICO supply\n    uint256 public icoSupply;\n    // Community incentivisation supply\n    uint256 public incentivisingEffortsSupply;\n    // Crowdsale End Timestamp\n    uint256 public crowdfundEndsAt;\n    // Vesting period for the Vanbex Team allocation\n    uint256 public vanbexTeamVestingPeriod;\n\n    // Crowdfund Address\n    address public crowdfundAddress;\n    // Vanbex team address\n    address public vanbexTeamAddress;\n    // Etherparty platform address\n    address public platformAddress;\n    // Community incentivisation address\n    address public incentivisingEffortsAddress;\n    // Etherparty Address\n    address public etherpartyAddress;\n\n    // Flag keeping track of presale status. Ensures functions can only be called once\n    bool public presaleFinalized = false;\n    // Flag keeping track of crowdsale status. Ensures functions can only be called once\n    bool public crowdfundFinalized = false;\n\n/////////////////////// EVENTS ///////////////////////\n\n    // Event called when crowdfund is done\n    event CrowdfundFinalized(uint tokens);\n    // Event called when presale is done\n    event PresaleFinalized(uint tokens);\n\n/////////////////////// MODIFIERS ///////////////////////\n\n    // Ensure actions can only happen after crowdfund ends\n    modifier notBeforeCrowdfundEnds(){\n        require(now >= crowdfundEndsAt);\n        _;\n    }\n\n    // Ensure vesting period is over\n    modifier checkVanbexTeamVestingPeriod() {\n        assert(now >= vanbexTeamVestingPeriod);\n        _;\n    }\n\n    // Ensure only crowdfund can call the function\n    modifier onlyCrowdfund() {\n        require(msg.sender == crowdfundAddress);\n        _;\n    }\n\n/////////////////////// ERC20 FUNCTIONS ///////////////////////\n\n    // Transfer\n    function transfer(address _to, uint256 _amount) notBeforeCrowdfundEnds nonZeroAmount(_amount) returns (bool success) {\n        require(balanceOf(msg.sender) >= _amount);\n        addToBalance(_to, _amount);\n        decrementBalance(msg.sender, _amount);\n        Transfer(msg.sender, _to, _amount);\n        return true;\n    }\n\n    // Transfer from one address to another (need allowance to be called first)\n    function transferFrom(address _from, address _to, uint256 _amount) notBeforeCrowdfundEnds nonZeroAmount(_amount) returns (bool success) {\n        require(allowance(_from, msg.sender) >= _amount);\n        addToBalance(_to, _amount);\n        decrementBalance(_from, _amount);\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\n        Transfer(_from, _to, _amount);\n        return true;\n    }\n\n    // Approve another address a certain amount of FUEL\n    function approve(address _spender, uint256 _value) returns (bool success) {\n        require((_value == 0) || (allowance(msg.sender, _spender) == 0));\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    // Get an address's FUEL allowance\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    // Get the FUEL balance of any address\n    function balanceOf(address _owner) constant returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n/////////////////////// TOKEN FUNCTIONS ///////////////////////\n\n    // Constructor\n    function FuelToken() {\n        crowdfundEndsAt = 1507852800;                                               // Oct 13, 00:00:00 UTC  - 1507852800\n        vanbexTeamVestingPeriod = crowdfundEndsAt.add(183 * 1 days);                // 6 months vesting period\n\n        totalSupply = 1 * 10**27;                                                   // 100% - 1 billion total FUEL tokens with 18 decimals\n        vanbexTeamSupply = 5 * 10**25;                                              // 5% - 50 million for etherparty team\n        platformSupply = 5 * 10**25;                                                // 5% - 50 million to be sold on the etherparty platform in-app\n        incentivisingEffortsSupply = 1 * 10**26;                                    // 10% - 100 million for incentivising efforts\n        presaleSupply = 54 * 10**25;                                                // 540,000,000 fuel tokens available for presale with overflow for bonus included\n        icoSupply = 26 * 10**25;                                                    // 260 million fuel tokens for ico with potential for extra after finalizing presale\n       \n        amountOfPublicTokensToAllocate = presaleSupply + icoSupply;                 // Total amount of tokens available to the public\n        presaleAmountRemaining = presaleSupply;                                     // Decreased over the course of the pre-sale\n        vanbexTeamAddress = 0x413ea1484137526f3b1bd412e2f897c94c8e198d;             // Vanbex Team Address\n        platformAddress = 0xa1602060f4630ef560009a3377a6b788d2b90484;               // Platform Address\n        incentivisingEffortsAddress = 0xc82fe29c67e63df7a09902140c5354fd6279c86c;   // Community incentivisation address\n\n        addToBalance(incentivisingEffortsAddress, incentivisingEffortsSupply);     \n        addToBalance(platformAddress, platformSupply);                              \n\n        allocateTokens(incentivisingEffortsSupply);\n        allocateTokens(platformSupply);\n    }\n\n    // Sets the crowdfund address, can only be done once\n    function setCrowdfundAddress(address _crowdfundAddress) external onlyOwner nonZeroAddress(_crowdfundAddress) {\n        require(crowdfundAddress == 0x0);\n        crowdfundAddress = _crowdfundAddress;\n        addToBalance(crowdfundAddress, icoSupply); \n    }\n\n    // Sets the Etherparty address\n    function setEtherpartyAddress(address _etherpartyAddress) external onlyOwner nonZeroAddress(_etherpartyAddress) {\n        etherpartyAddress = _etherpartyAddress;  \n    }\n\n    // Function for the Crowdfund to transfer tokens\n    function transferFromCrowdfund(address _to, uint256 _amount) onlyCrowdfund nonZeroAmount(_amount) nonZeroAddress(_to) returns (bool success) {\n        require(balanceOf(crowdfundAddress) >= _amount);\n        decrementBalance(crowdfundAddress, _amount);\n        addToBalance(_to, _amount);\n        allocateTokens(_amount);\n        Transfer(crowdfundAddress, _to, _amount);\n        return true;\n    }\n\n    // Release Vanbex team supply after vesting period is finished.\n    function releaseVanbexTeamTokens() checkVanbexTeamVestingPeriod onlyOwner returns(bool success) {\n        require(vanbexTeamSupply > 0);\n        addToBalance(vanbexTeamAddress, vanbexTeamSupply);\n        Transfer(this, vanbexTeamAddress, vanbexTeamSupply);\n        allocateTokens(vanbexTeamSupply);\n        vanbexTeamSupply = 0;\n        return true;\n    }\n\n    // Finalize presale. If there are leftover FUEL, let them overflow to the crowdfund\n    function finalizePresale() external onlyOwner returns (bool success) {\n        require(presaleFinalized == false);\n        uint256 amount = presaleAmountRemaining;\n        if (amount != 0) {\n            presaleAmountRemaining = 0;\n            addToBalance(crowdfundAddress, amount);\n        }\n        presaleFinalized = true;\n        PresaleFinalized(amount);\n        return true;\n    }\n\n    // Finalize crowdfund. If there are leftover FUEL, let them overflow to the be sold at 1$ on the platform\n    function finalizeCrowdfund() external onlyCrowdfund notBeforeCrowdfundEnds returns (bool success) {\n        require(crowdfundFinalized == false);\n        uint256 amount = balanceOf(crowdfundAddress);\n        if (amount > 0) {\n            balances[crowdfundAddress] = 0;\n            addToBalance(platformAddress, amount);\n            Transfer(crowdfundAddress, platformAddress, amount);\n        }\n        crowdfundFinalized = true;\n        CrowdfundFinalized(amount);\n        return true;\n    }\n\n\n    // Function to send FUEL to presale investors\n    function deliverPresaleFuelBalances(address[] _batchOfAddresses, uint[] _amountOfFuel) external onlyOwner returns (bool success) {\n        for (uint256 i = 0; i < _batchOfAddresses.length; i++) {\n            deliverPresaleFuelBalance(_batchOfAddresses[i], _amountOfFuel[i]);            \n        }\n        return true;\n    }\n\n    // All presale purchases will be delivered. If one address has contributed more than once,\n    // his contribution will be aggregated\n    function deliverPresaleFuelBalance(address _accountHolder, uint _amountOfBoughtFuel) internal onlyOwner {\n        require(balanceOf(_accountHolder) == 0 && presaleAmountRemaining > 0); \n        addToBalance(_accountHolder, _amountOfBoughtFuel);\n        Transfer(this, _accountHolder, _amountOfBoughtFuel);\n        presaleAmountRemaining = presaleAmountRemaining.sub(_amountOfBoughtFuel);\n        allocateTokens(_amountOfBoughtFuel);        \n    }\n\n    // Add to balance\n    function addToBalance(address _address, uint _amount) internal {\n    \tbalances[_address] = balances[_address].add(_amount);\n    }\n\n    // Remove from balance\n    function decrementBalance(address _address, uint _amount) internal {\n    \tbalances[_address] = balances[_address].sub(_amount);\n    }\n\n    // Add to totalAllocatedTokens\n    function allocateTokens(uint _amount) internal {\n    \ttotalAllocatedTokens = totalAllocatedTokens.add(_amount);\n    }\n\n    // Reject any value transfer to this contract\n    function () {\n        revert();\n    }\n}"
    }
  ]
}