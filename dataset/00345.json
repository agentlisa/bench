{
  "Title": "M-3: Unsold tokens from a FPAM auction, will be stuck in the protocol, after the auction concludes",
  "Content": "# Issue M-3: Unsold tokens from a FPAM auction, will be stuck in the protocol, after the auction concludes \n\nSource: https://github.com/sherlock-audit/2024-03-axis-finance-judging/issues/94 \n\n## Found by \nAymen0909, FindEverythingX, cu5t0mPe0, dimulski, ether\\_sky, hash, jecikpo, qbs, seeques, ydlee\n## Summary\nThe ``Axis-Finance`` protocol allows sellers to create two types of auctions: **FPAM** & **EMPAM**. An **FPAM** auction allows sellers to set a price, and a maxPayout, as well as create a prefunded auction. The seller of a **FPAM** auction can cancel it while it is still active by calling the [cancel](https://github.com/sherlock-audit/2024-03-axis-finance/blob/main/moonraker/src/bases/Auctioneer.sol#L301-L342) function which in turn calls the [cancelAuction()](https://github.com/sherlock-audit/2024-03-axis-finance/blob/main/moonraker/src/modules/Auction.sol#L351-L364) function. If the auction is prefunded, and canceled while still active, all remaining funds will be transferred back to the seller. The problem arises if an **FPAM** prefunded auction is created, not all of the prefunded supply is bought by users, and the auction concludes. There is no way for the ``baseTokens`` still in the contract, to be withdrawn from the protocol, and they will be forever stuck in the ``Axis-Finance`` protocol. As can be seen from the below code snippet [cancelAuction()](https://github.com/sherlock-audit/2024-03-axis-finance/blob/main/moonraker/src/modules/Auction.sol#L351-L364) function checks if an auction is concluded, and if it is the function reverts.\n\n```solidity\n    function _revertIfLotConcluded(uint96 lotId_) internal view virtual {\n        // Beyond the conclusion time\n        if (lotData[lotId_].conclusion < uint48(block.timestamp)) {\n            revert Auction_MarketNotActive(lotId_);\n        }\n\n        // Capacity is sold-out, or cancelled\n        if (lotData[lotId_].capacity == 0) revert Auction_MarketNotActive(lotId_);\n    }\n```\n## Vulnerability Detail\n[Gist](https://gist.github.com/AtanasDimulski/a47112fc7ae473fd69b42ba997819726)\nAfter following the steps in the above mentioned [gist](https://gist.github.com/AtanasDimulski/a47112fc7ae473fd69b42ba997819726) add the following test to the ``AuditorTests.t.sol`` file\n\n```solidity\nfunction test_FundedPriceAuctionStuckFunds() public {\n        vm.startPrank(alice);\n        Veecode veecode = fixedPriceAuctionModule.VEECODE();\n        Keycode keycode = keycodeFromVeecode(veecode);\n        bytes memory _derivativeParams = \"\";\n        uint96 lotCapacity = 75_000_000_000e18; // this is 75 billion tokens\n        mockBaseToken.mint(alice, lotCapacity);\n        mockBaseToken.approve(address(auctionHouse), type(uint256).max);\n\n        FixedPriceAuctionModule.FixedPriceParams  memory myStruct = FixedPriceAuctionModule.FixedPriceParams({\n            price: uint96(1e18), \n            maxPayoutPercent: uint24(1e5)\n        });\n\n        Auctioneer.RoutingParams memory routingA = Auctioneer.RoutingParams({\n            auctionType: keycode,\n            baseToken: mockBaseToken,\n            quoteToken: mockQuoteToken,\n            curator: curator,\n            callbacks: ICallback(address(0)),\n            callbackData: abi.encode(\"\"),\n            derivativeType: toKeycode(\"\"),\n            derivativeParams: _derivativeParams,\n            wrapDerivative: false,\n            prefunded: true\n        });\n\n        Auction.AuctionParams memory paramsA = Auction.AuctionParams({\n            start: 0,\n            duration: 1 days,\n            capacityInQuote: false,\n            capacity: lotCapacity,\n            implParams: abi.encode(myStruct)\n        });\n\n        string memory infoHashA;\n        auctionHouse.auction(routingA, paramsA, infoHashA);       \n        vm.stopPrank();\n\n        vm.startPrank(bob);\n        uint96 fundingBeforePurchase;\n        uint96 fundingAfterPurchase;\n        (,fundingBeforePurchase,,,,,,,) = auctionHouse.lotRouting(0);\n        console2.log(\"Here is the funding normalized before purchase: \", fundingBeforePurchase/1e18);\n        mockQuoteToken.mint(bob, 10_000_000_000e18);\n        mockQuoteToken.approve(address(auctionHouse), type(uint256).max);\n        Router.PurchaseParams memory purchaseParams = Router.PurchaseParams({\n            recipient: bob,\n            referrer: address(0),\n            lotId: 0,\n            amount: 10_000_000_000e18,\n            minAmountOut: 10_000_000_000e18,\n            auctionData: abi.encode(0),\n            permit2Data: \"\"\n        });\n        bytes memory callbackData = \"\";\n        auctionHouse.purchase(purchaseParams, callbackData);\n        (,fundingAfterPurchase,,,,,,,) = auctionHouse.lotRouting(0);\n        console2.log(\"Here is the funding normalized after purchase: \", fundingAfterPurchase/1e18);\n        console2.log(\"Balance of seler of quote tokens: \", mockQuoteToken.balanceOf(alice)/1e18);\n        console2.log(\"Balance of bob in base token: \", mockBaseToken.balanceOf(bob)/1e18);\n        console2.log(\"Balance of auction house in base token: \", mockBaseToken.balanceOf(address(auctionHouse)) /1e18);\n        skip(86401);\n        vm.stopPrank();\n\n        vm.startPrank(alice);\n        vm.expectRevert(\n            abi.encodeWithSelector(Auction.Auction_MarketNotActive.selector, 0)\n        );\n        auctionHouse.cancel(uint96(0), callbackData);\n        vm.stopPrank();\n    }\n```\n\n```solidity\nLogs:\n  Here is the funding normalized before purchase:  75000000000\n  Here is the funding normalized after purchase:  65000000000\n  Balance of seler of quote tokens:  10000000000\n  Balance of bob in base token:  10000000000\n  Balance of auction house in base token:  65000000000\n```\n\nTo run the test use: ``forge test -vvv --mt test_FundedPriceAuctionStuckFunds``\n## Impact\nIf a prefunded **FPAM** auction concludes and there are still tokens, not bought from the users, they will be stuck in the ``Axis-Finance`` protocol.\n\n## Code Snippet\n\n## Tool used\nManual Review & Foundry\n\n## Recommendation\nImplement a function, that allows sellers to withdraw the amount left for a prefunded **FPAM** auction they have created, once the auction has concluded. \n\n\n\n## Discussion\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/Axis-Fi/moonraker/pull/132\n\n\n**10xhash**\n\n> The protocol team fixed this issue in the following PRs/commits: [Axis-Fi/moonraker#132](https://github.com/Axis-Fi/moonraker/pull/132)\n\nFixed\nNow FPAM auctions are not prefunded\n\n**sherlock-admin4**\n\nThe Lead Senior Watson signed off on the fix.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/206",
  "Code": [
    {
      "filename": "moonraker/src/bases/Auctioneer.sol",
      "content": "/// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.19;\n\nimport {ERC20} from \"lib/solmate/src/tokens/ERC20.sol\";\nimport {Transfer} from \"src/lib/Transfer.sol\";\nimport {ReentrancyGuard} from \"lib/solmate/src/utils/ReentrancyGuard.sol\";\n\nimport {fromKeycode, Keycode, Veecode, Module, WithModules} from \"src/modules/Modules.sol\";\n\nimport {Auction, AuctionModule} from \"src/modules/Auction.sol\";\n\nimport {DerivativeModule} from \"src/modules/Derivative.sol\";\n\nimport {ICallback} from \"src/interfaces/ICallback.sol\";\nimport {Callbacks} from \"src/lib/Callbacks.sol\";\n\n/// @title  Auctioneer\n/// @notice The Auctioneer handles the following:\n///         - Creating new auction lots\n///         - Cancelling auction lots\n///         - Storing information about how to handle inputs and outputs for auctions (\"routing\")\nabstract contract Auctioneer is WithModules, ReentrancyGuard {\n    using Callbacks for ICallback;\n\n    // ========= ERRORS ========= //\n\n    error InvalidParams();\n    error InvalidLotId(uint96 id_);\n    error InvalidState();\n    error InvalidCallback();\n\n    /// @notice     Used when the caller is not permitted to perform that action\n    error NotPermitted(address caller_);\n\n    // ========= EVENTS ========= //\n\n    /// @notice         Emitted when a new auction lot is created\n    ///\n    /// @param          lotId       ID of the auction lot\n    /// @param          auctionRef  Auction module, represented by its Veecode\n    /// @param          infoHash    IPFS hash of the auction information\n    event AuctionCreated(uint96 indexed lotId, Veecode indexed auctionRef, string infoHash);\n\n    /// @notice         Emitted when an auction lot is cancelled\n    ///\n    /// @param          lotId       ID of the auction lot\n    /// @param          auctionRef  Auction module, represented by its Veecode\n    event AuctionCancelled(uint96 indexed lotId, Veecode indexed auctionRef);\n\n    /// @notice         Emitted when a curator accepts curation of an auction lot\n    ///\n    /// @param          lotId       ID of the auction lot\n    /// @param          curator     Address of the curator\n    event Curated(uint96 indexed lotId, address indexed curator);\n\n    // ========= DATA STRUCTURES ========== //\n\n    /// @notice     Auction routing information for a lot\n    ///\n    /// @param      auctionReference    Auction module, represented by its Veecode\n    /// @param      seller              Lot seller\n    /// @param      baseToken           Token provided by seller\n    /// @param      quoteToken          Token to accept as payment\n    /// @param      callbacks           (optional) Callbacks implementation for extended functionality\n    /// @param      derivativeReference (optional) Derivative module, represented by its Veecode\n    /// @param      derivativeParams    (optional) abi-encoded data to be used to create payout derivatives on a purchase\n    /// @param      wrapDerivative      (optional) Whether to wrap the derivative in a ERC20 token instead of the native ERC6909 format\n    /// @param      funding             The amount of base tokens in funding remaining\n    struct Routing {\n        address seller; // 20 bytes\n        uint96 funding; // 12 bytes\n        ERC20 baseToken; // 20 bytes\n        Veecode auctionReference; // 7 bytes\n        ERC20 quoteToken; // 20 bytes\n        ICallback callbacks; // 20 bytes\n        Veecode derivativeReference; // 7 bytes\n        bool wrapDerivative; // 1 byte\n        bytes derivativeParams;\n    }\n\n    /// @notice     Fee information for a lot\n    /// @dev        This is split into a separate struct, otherwise the Routing struct would be too large\n    ///             and would throw a \"stack too deep\" error.\n    ///\n    ///             The curator information is stored when curation is approved by the curator.\n    ///             The protocol and referrer fees are set at the time of lot settlement.\n    ///             The fees are cached in order to prevent:\n    ///             - Reducing the amount of base tokens available for payout to the winning bidders\n    ///             - Reducing the amount of quote tokens available for payment to the seller\n    ///\n    /// @param      curator     Address of the proposed curator\n    /// @param      curated     Whether the curator has approved the auction\n    /// @param      curatorFee  The fee charged by the curator\n    /// @param      protocolFee The fee charged by the protocol\n    /// @param      referrerFee The fee charged by the referrer\n    struct FeeData {\n        address curator; // 20 bytes\n        bool curated; // 1 byte\n        uint48 curatorFee; // 6 bytes\n        uint48 protocolFee; // 6 bytes\n        uint48 referrerFee; // 6 bytes\n    }\n\n    /// @notice     Auction routing information provided as input parameters\n    /// @dev        After validation, this information is stored in the Routing struct\n    ///\n    /// @param      auctionType         Auction type, represented by the Keycode for the auction submodule\n    /// @param      baseToken           Token provided by seller\n    /// @param      quoteToken          Token to accept as payment\n    /// @param      curator             (optional) Address of the proposed curator\n    /// @param      callbacks           (optional) Callbacks implementation for extended functionality\n    /// @param      callbackData        (optional) abi-encoded data to be sent to the onCreate callback function\n    /// @param      derivativeType      (optional) Derivative type, represented by the Keycode for the derivative submodule\n    /// @param      derivativeParams    (optional) abi-encoded data to be used to create payout derivatives on a purchase. The format of this is dependent on the derivative module.\n    /// @param      prefunded           Whether the auction should be pre-funded. Must be true for batch auctions.\n    struct RoutingParams {\n        Keycode auctionType;\n        ERC20 baseToken;\n        ERC20 quoteToken;\n        address curator;\n        ICallback callbacks;\n        bytes callbackData;\n        Keycode derivativeType;\n        bytes derivativeParams;\n        bool wrapDerivative;\n        bool prefunded;\n    }\n\n    // ========= STATE ========== //\n\n    /// @notice     Counter for auction lots\n    uint96 public lotCounter;\n\n    /// @notice     Mapping of lot IDs to their auction type (represented by the Keycode for the auction submodule)\n    mapping(uint96 lotId => Routing) public lotRouting;\n\n    /// @notice     Mapping of lot IDs to their fee information\n    mapping(uint96 lotId => FeeData) public lotFees;\n\n    // ========== AUCTION MANAGEMENT ========== //\n\n    /// @notice     Creates a new auction lot\n    /// @dev        The function reverts if:\n    ///             - The module for the auction type is not installed\n    ///             - The auction type is sunset\n    ///             - The base token or quote token decimals are not within the required range\n    ///             - The value of `RoutingParams.prefunded` is incorrect for the auction type\n    ///             - Validation for the auction parameters fails\n    ///             - The module for the optional specified derivative type is not installed\n    ///             - Validation for the optional specified derivative type fails\n    ///             - Registration for the optional allowlist fails\n    ///             - The optional specified hooks contract is not a contract\n    ///             - The condenser module is not installed or is sunset\n    ///             - re-entrancy is detected\n    ///\n    /// @param      routing_    Routing information for the auction lot\n    /// @param      params_     Auction parameters for the auction lot\n    /// @param      infoHash_   IPFS hash of the auction information\n    /// @return     lotId       ID of the auction lot\n    function auction(\n        RoutingParams calldata routing_,\n        Auction.AuctionParams calldata params_,\n        string calldata infoHash_\n    ) external nonReentrant returns (uint96 lotId) {\n        // Check that the module for the auction type is valid\n        // Validate routing parameters\n\n        // Tokens must not be the zero address\n        if (address(routing_.baseToken) == address(0) || address(routing_.quoteToken) == address(0))\n        {\n            revert InvalidParams();\n        }\n\n        Routing storage routing = lotRouting[lotId];\n\n        bool requiresPrefunding;\n        uint96 lotCapacity;\n        {\n            // Load auction type module, this checks that it is installed.\n            // We load it here vs. later to avoid two checks.\n            AuctionModule auctionModule =\n                AuctionModule(_getLatestModuleIfActive(routing_.auctionType));\n\n            // Confirm tokens are within the required decimal range\n            uint8 baseTokenDecimals = routing_.baseToken.decimals();\n            uint8 quoteTokenDecimals = routing_.quoteToken.decimals();\n\n            if (\n                auctionModule.TYPE() != Module.Type.Auction || baseTokenDecimals < 6\n                    || baseTokenDecimals > 18 || quoteTokenDecimals < 6 || quoteTokenDecimals > 18\n            ) revert InvalidParams();\n\n            // Increment lot count and get ID\n            lotId = lotCounter++;\n\n            // Call module auction function to store implementation-specific data\n            (lotCapacity) =\n                auctionModule.auction(lotId, params_, quoteTokenDecimals, baseTokenDecimals);\n            routing.auctionReference = auctionModule.VEECODE();\n\n            // Prefunding is required for batch auctions\n            // Check that this is not incorrectly overridden\n            if (auctionModule.auctionType() == Auction.AuctionType.Batch && !routing_.prefunded) {\n                revert InvalidParams();\n            }\n\n            requiresPrefunding = routing_.prefunded;\n        }\n\n        // Store routing information\n        routing.seller = msg.sender;\n        routing.baseToken = routing_.baseToken;\n        routing.quoteToken = routing_.quoteToken;\n\n        // Store curation information\n        {\n            FeeData storage fees = lotFees[lotId];\n            fees.curator = routing_.curator;\n            fees.curated = false;\n        }\n\n        // Derivative\n        if (fromKeycode(routing_.derivativeType) != bytes5(\"\")) {\n            // Load derivative module, this checks that it is installed.\n            DerivativeModule derivativeModule =\n                DerivativeModule(_getLatestModuleIfActive(routing_.derivativeType));\n\n            // Check that the module for the derivative type is valid\n            // Call module validate function to validate implementation-specific data\n            if (\n                derivativeModule.TYPE() != Module.Type.Derivative\n                    || !derivativeModule.validate(address(routing.baseToken), routing_.derivativeParams)\n            ) {\n                revert InvalidParams();\n            }\n\n            // Store derivative information\n            routing.derivativeReference = derivativeModule.VEECODE();\n            routing.derivativeParams = routing_.derivativeParams;\n            routing.wrapDerivative = routing_.wrapDerivative;\n        }\n\n        // Validate callbacks address and store if provided\n        // This does not check whether the callbacks contract is implemented properly\n        // Certain functions may revert later. TODO need to think about security with this.\n        if (!Callbacks.isValidCallbacksAddress(routing_.callbacks)) revert InvalidParams();\n        // The zero address passes the isValidCallbackAddress check since we allow auctions to not use a callbacks contract\n        if (address(routing_.callbacks) != address(0)) routing.callbacks = routing_.callbacks;\n\n        // Perform pre-funding, if needed\n        // It does not make sense to pre-fund the auction if the capacity is in quote tokens\n        if (requiresPrefunding == true) {\n            // Capacity must be in base token for auctions that require pre-funding\n            if (params_.capacityInQuote) revert InvalidParams();\n\n            // Store pre-funding information\n            routing.funding = lotCapacity;\n\n            // Handle funding from callback or seller as configured\n            if (routing_.callbacks.hasPermission(Callbacks.SEND_BASE_TOKENS_FLAG)) {\n                uint256 balanceBefore = routing_.baseToken.balanceOf(address(this));\n\n                // The onCreate callback should transfer the base token to this contract\n                _onCreateCallback(routing_, lotId, lotCapacity, true);\n\n                // Check that the hook transferred the expected amount of base tokens\n                if (routing_.baseToken.balanceOf(address(this)) < balanceBefore + lotCapacity) {\n                    revert InvalidCallback();\n                }\n            }\n            // Otherwise fallback to a standard ERC20 transfer and then call the onCreate callback\n            else {\n                Transfer.transferFrom(\n                    routing_.baseToken, msg.sender, address(this), lotCapacity, true\n                );\n                _onCreateCallback(routing_, lotId, lotCapacity, false);\n            }\n        } else {\n            // Call onCreate callback with no prefunding\n            _onCreateCallback(routing_, lotId, lotCapacity, false);\n        }\n\n        emit AuctionCreated(lotId, routing.auctionReference, infoHash_);\n    }\n\n    /// @notice     Cancels an auction lot\n    /// @dev        This function performs the following:\n    ///             - Checks that the lot ID is valid\n    ///             - Checks that caller is the seller\n    ///             - Calls the auction module to validate state, update records and determine the amount to be refunded\n    ///             - If prefunded, sends the refund of payout tokens to the seller\n    ///\n    ///             The function reverts if:\n    ///             - The lot ID is invalid\n    ///             - The caller is not the seller\n    ///             - The respective auction module reverts\n    ///             - The transfer of payout tokens fails\n    ///             - re-entrancy is detected\n    ///\n    /// @param      lotId_      ID of the auction lot\n    function cancel(uint96 lotId_, bytes calldata callbackData_) external nonReentrant {\n        // Validation\n        _isLotValid(lotId_);\n\n        Routing storage routing = lotRouting[lotId_];\n\n        // Check ownership\n        if (msg.sender != routing.seller) revert NotPermitted(msg.sender);\n\n        // Cancel the auction on the module\n        _getModuleForId(lotId_).cancelAuction(lotId_);\n\n        // If the auction is prefunded and supported, transfer the remaining capacity to the seller\n        if (routing.funding > 0) {\n            uint96 funding = routing.funding;\n\n            // Set to 0 before transfer to avoid re-entrancy\n            routing.funding = 0;\n\n            // Transfer the base tokens to the appropriate contract\n            Transfer.transfer(\n                routing.baseToken,\n                _getAddressGivenCallbackBaseTokenFlag(routing.callbacks, routing.seller),\n                funding,\n                false\n            );\n\n            // Call the callback to transfer the base token to the owner\n            Callbacks.onCancel(\n                routing.callbacks,\n                lotId_,\n                funding,\n                routing.callbacks.hasPermission(Callbacks.SEND_BASE_TOKENS_FLAG),\n                callbackData_\n            );\n        } else {\n            // Call the callback to notify of the cancellation\n            Callbacks.onCancel(routing.callbacks, lotId_, 0, false, callbackData_);\n        }\n\n        emit AuctionCancelled(lotId_, routing.auctionReference);\n    }\n\n    // ========== INTERNAL HELPER FUNCTIONS ========== //\n\n    /// @notice         Gets the module for a given lot ID\n    /// @dev            The function assumes:\n    ///                 - The lot ID is valid\n    ///\n    /// @param lotId_   ID of the auction lot\n    /// @return         AuctionModule\n    function _getModuleForId(uint96 lotId_) internal view returns (AuctionModule) {\n        // Load module, will revert if not installed\n        return AuctionModule(_getModuleIfInstalled(lotRouting[lotId_].auctionReference));\n    }\n\n    /// @notice     Gets the module for a given lot ID\n    /// @dev        The function reverts if:\n    ///             - The lot ID is invalid\n    ///             - The module for the auction type is not installed\n    ///\n    /// @param      lotId_      ID of the auction lot\n    function getModuleForId(uint96 lotId_) external view returns (AuctionModule) {\n        _isLotValid(lotId_);\n\n        return _getModuleForId(lotId_);\n    }\n\n    function _onCreateCallback(\n        RoutingParams calldata routing_,\n        uint96 lotId_,\n        uint96 capacity_,\n        bool preFund_\n    ) internal {\n        Callbacks.onCreate(\n            routing_.callbacks,\n            lotId_,\n            msg.sender,\n            address(routing_.baseToken),\n            address(routing_.quoteToken),\n            capacity_,\n            preFund_,\n            routing_.callbackData\n        );\n    }\n\n    function _getAddressGivenCallbackBaseTokenFlag(\n        ICallback callbacks_,\n        address seller_\n    ) internal pure returns (address) {\n        return callbacks_.hasPermission(Callbacks.SEND_BASE_TOKENS_FLAG)\n            ? address(callbacks_)\n            : seller_;\n    }\n\n    // ========= VALIDATION FUNCTIONS ========= //\n\n    /// @notice     Checks that the lot ID is valid\n    /// @dev        Reverts if the lot ID is invalid\n    ///\n    /// @param      lotId_  ID of the auction lot\n    function _isLotValid(uint96 lotId_) internal view {\n        if (lotId_ >= lotCounter) revert InvalidLotId(lotId_);\n    }\n}"
    }
  ]
}