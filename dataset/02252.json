{
  "Title": "M-29: User should not receive rewards for the rebalance period, when protocol was blacklisted, because of unpredicted behaviour of protocol price",
  "Content": "# Issue M-29: User should not receive rewards for the rebalance period, when protocol was blacklisted, because of unpredicted behaviour of protocol price \n\nSource: https://github.com/sherlock-audit/2023-01-derby-judging/issues/145 \n\n## Found by \nBauer, Ch\\_301, evan, immeas, rvierdiiev\n\n## Summary\nUser should not receive rewards for the rebalance period, when protocol was blacklisted, because of unpredicted behaviour of protocol price.\n## Vulnerability Detail\nWhen user allocates derby tokens to some underlying protocol, he receive rewards according to the exchange price of that protocols token. This reward can be positive or negative.\nRewards of protocol are set to `Game` contract inside [`settleRewards` function](https://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Game.sol#L498-L504) and they are accumulated for user, once he calls `rebalanceBasket`.\n\nLet's check how they are calculated.\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Vault.sol#L226-L245\n```solidity\n  function storePriceAndRewards(uint256 _totalUnderlying, uint256 _protocolId) internal {\n    uint256 currentPrice = price(_protocolId);\n    if (lastPrices[_protocolId] == 0) {\n      lastPrices[_protocolId] = currentPrice;\n      return;\n    }\n\n\n    int256 priceDiff = int256(currentPrice - lastPrices[_protocolId]);\n    int256 nominator = (int256(_totalUnderlying * performanceFee) * priceDiff);\n    int256 totalAllocatedTokensRounded = totalAllocatedTokens / 1E18;\n    int256 denominator = totalAllocatedTokensRounded * int256(lastPrices[_protocolId]) * 100; // * 100 cause perfFee is in percentages\n\n\n    if (totalAllocatedTokensRounded == 0) {\n      rewardPerLockedToken[rebalancingPeriod][_protocolId] = 0;\n    } else {\n      rewardPerLockedToken[rebalancingPeriod][_protocolId] = nominator / denominator;\n    }\n\n\n    lastPrices[_protocolId] = currentPrice;\n  }\n```\nEvery time, previous price of protocol is compared with current price.\n\nIn case if some protocol is hacked, there is `Vault.blacklistProtocol` function, that should withdraw reserves from protocol and mark it as blacklisted. \nThe problem is that because of the hack it's not possible to determine what will happen with exhange rate of protocol. It can be 0, ot it can be very small or it can be high for any reasons.\nBut protocol still accrues rewards per token for protocol, even that it is blacklisted. Because of that, user that allocated to that protocol can face with accruing very big negative or positive rewards. Both this cases are bad.\n\nSo i believe that in case if protocol is blacklisted, it's better to set rewards as 0 for it.\n\nExample.\n1.User allocated 100 derby tokens for protocol A\n2.Before `Vault.rebalance` call, protocol A was hacked which made it exchangeRate to be not real.\n3.Derby team has blacklisted that protocol A.\n4.`Vault.rebalance` is called which used new(incorrect) exchangeRate of protocol A in order to calculate `rewardPerLockedToken`\n5.When user calls rebalance basket next time, his rewards are accumulated with extremely high/low value.\n## Impact\nUser's rewards calculation is unpredictable.\n## Code Snippet\nProvided above\n## Tool used\n\nManual Review\n\n## Recommendation\nIn case if protocol is blacklisted, then set `rewardPerLockedToken` to 0 inside `storePriceAndRewards` function.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/13",
  "Code": [
    {
      "filename": "derby-yield-optimiser/contracts/Game.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Derby Finance - 2022\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"./DerbyToken.sol\";\n\nimport \"./Interfaces/IVault.sol\";\nimport \"./Interfaces/IController.sol\";\nimport \"./Interfaces/IXProvider.sol\";\n\ncontract Game is ERC721, ReentrancyGuard {\n  using SafeERC20 for IERC20;\n\n  struct Basket {\n    // the vault number for which this Basket was created\n    uint256 vaultNumber;\n    // last period when this Basket got rebalanced\n    uint256 lastRebalancingPeriod;\n    // nr of total allocated tokens\n    int256 nrOfAllocatedTokens;\n    // total build up rewards\n    int256 totalUnRedeemedRewards;\n    // total redeemed rewards\n    int256 totalRedeemedRewards;\n    // (basket => vaultNumber => chainId => allocation)\n    mapping(uint256 => mapping(uint256 => int256)) allocations;\n  }\n\n  struct vaultInfo {\n    // rebalance period of vault, upped at vault rebalance\n    uint256 rebalancingPeriod;\n    // (chainId => vaultAddress)\n    mapping(uint32 => address) vaultAddress;\n    // (chainId => deltaAllocation)\n    mapping(uint256 => int256) deltaAllocationChain;\n    // (chainId => protocolNumber => deltaAllocation)\n    mapping(uint256 => mapping(uint256 => int256)) deltaAllocationProtocol;\n    // (chainId => rebalancing period => protocol id => rewardPerLockedToken).\n    mapping(uint32 => mapping(uint256 => mapping(uint256 => int256))) rewardPerLockedToken;\n  }\n\n  address private dao;\n  address private guardian;\n  address public xProvider;\n  address public homeVault;\n\n  IController public controller;\n  IERC20 public derbyToken;\n\n  // latest basket id\n  uint256 private latestBasketId;\n\n  // array of chainIds e.g [10, 100, 1000];\n  uint32[] public chainIds;\n\n  // interval in Unix timeStamp\n  uint256 public rebalanceInterval; // SHOULD BE REPLACED FOR REALISTIC NUMBER\n\n  // last rebalance timeStamp\n  uint256 public lastTimeStamp;\n\n  // threshold in vaultCurrency e.g USDC for when user tokens will be sold / burned. Must be negative\n  int256 internal negativeRewardThreshold;\n  // percentage of tokens that will be sold at negative rewards\n  uint256 internal negativeRewardFactor;\n\n  // baskets, maps tokenID from BasketToken NFT contract to the Basket struct in this contract.\n  // (basketTokenId => basket struct):\n  mapping(uint256 => Basket) private baskets;\n\n  // (chainId => latestProtocolId): latestProtocolId set by dao\n  mapping(uint256 => uint256) public latestProtocolId;\n\n  // (vaultNumber => vaultInfo struct)\n  mapping(uint256 => vaultInfo) internal vaults;\n\n  // (vaultNumber => chainid => bool): true when vault/ chainid is cross-chain rebalancing\n  mapping(uint256 => mapping(uint32 => bool)) public isXChainRebalancing;\n\n  event PushProtocolAllocations(uint32 chain, address vault, int256[] deltas);\n\n  event PushedAllocationsToController(uint256 vaultNumber, int256[] deltas);\n\n  event BasketId(address owner, uint256 basketId);\n\n  modifier onlyDao() {\n    require(msg.sender == dao, \"Game: only DAO\");\n    _;\n  }\n\n  modifier onlyBasketOwner(uint256 _basketId) {\n    require(msg.sender == ownerOf(_basketId), \"Game: Not the owner of the basket\");\n    _;\n  }\n\n  modifier onlyXProvider() {\n    require(msg.sender == xProvider, \"Game: only xProvider\");\n    _;\n  }\n\n  modifier onlyGuardian() {\n    require(msg.sender == guardian, \"Game: only Guardian\");\n    _;\n  }\n\n  constructor(\n    string memory name_,\n    string memory symbol_,\n    address _derbyToken,\n    address _dao,\n    address _guardian,\n    address _controller\n  ) ERC721(name_, symbol_) {\n    derbyToken = IERC20(_derbyToken);\n    controller = IController(_controller);\n    dao = _dao;\n    guardian = _guardian;\n    lastTimeStamp = block.timestamp;\n  }\n\n  /// @notice Setter for delta allocation in a particulair chainId\n  /// @param _vaultNumber number of vault\n  /// @param _chainId number of chainId\n  /// @param _deltaAllocation delta allocation\n  function addDeltaAllocationChain(\n    uint256 _vaultNumber,\n    uint256 _chainId,\n    int256 _deltaAllocation\n  ) internal {\n    vaults[_vaultNumber].deltaAllocationChain[_chainId] += _deltaAllocation;\n  }\n\n  /// @notice Getter for delta allocation in a particulair chainId\n  /// @param _vaultNumber number of vault\n  /// @param _chainId number of chainId\n  /// @return allocation delta allocation\n  function getDeltaAllocationChain(\n    uint256 _vaultNumber,\n    uint256 _chainId\n  ) public view returns (int256) {\n    return vaults[_vaultNumber].deltaAllocationChain[_chainId];\n  }\n\n  /// @notice Setter for the delta allocation in Protocol vault e.g compound_usdc_01\n  /// @dev Allocation can be negative\n  /// @param _vaultNumber number of vault\n  /// @param _chainId number of chainId\n  /// @param _protocolNum Protocol number linked to an underlying vault e.g compound_usdc_01\n  /// @param _deltaAllocation Delta allocation in tokens\n  function addDeltaAllocationProtocol(\n    uint256 _vaultNumber,\n    uint256 _chainId,\n    uint256 _protocolNum,\n    int256 _deltaAllocation\n  ) internal {\n    vaults[_vaultNumber].deltaAllocationProtocol[_chainId][_protocolNum] += _deltaAllocation;\n  }\n\n  /// @notice Getter for the delta allocation in Protocol vault e.g compound_usdc_01\n  /// @param _vaultNumber number of vault\n  /// @param _chainId number of chainId\n  /// @param _protocolNum Protocol number linked to an underlying vault e.g compound_usdc_01\n  /// @return allocation Delta allocation in tokens\n  function getDeltaAllocationProtocol(\n    uint256 _vaultNumber,\n    uint256 _chainId,\n    uint256 _protocolNum\n  ) public view returns (int256) {\n    return vaults[_vaultNumber].deltaAllocationProtocol[_chainId][_protocolNum];\n  }\n\n  /// @notice Setter to set the total number of allocated tokens. Only the owner of the basket can set this.\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract.\n  /// @param _allocation Number of derby tokens that are allocated towards protocols.\n  function setBasketTotalAllocatedTokens(\n    uint256 _basketId,\n    int256 _allocation\n  ) internal onlyBasketOwner(_basketId) {\n    baskets[_basketId].nrOfAllocatedTokens += _allocation;\n    require(basketTotalAllocatedTokens(_basketId) >= 0, \"Basket: underflow\");\n  }\n\n  /// @notice function to see the total number of allocated tokens. Only the owner of the basket can view this.\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract.\n  /// @return int256 Number of derby tokens that are allocated towards protocols.\n  function basketTotalAllocatedTokens(uint256 _basketId) public view returns (int256) {\n    return baskets[_basketId].nrOfAllocatedTokens;\n  }\n\n  /// @notice Setter to set the allocation of a specific protocol by a basketId. Only the owner of the basket can set this.\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract.\n  /// @param _chainId number of chainId.\n  /// @param _protocolId Id of the protocol of which the allocation is queried.\n  /// @param _allocation Number of derby tokens that are allocated towards this specific protocol.\n  function setBasketAllocationInProtocol(\n    uint256 _basketId,\n    uint256 _chainId,\n    uint256 _protocolId,\n    int256 _allocation\n  ) internal onlyBasketOwner(_basketId) {\n    baskets[_basketId].allocations[_chainId][_protocolId] += _allocation;\n    require(basketAllocationInProtocol(_basketId, _chainId, _protocolId) >= 0, \"Basket: underflow\");\n  }\n\n  /// @notice function to see the allocation of a specific protocol by a basketId. Only the owner of the basket can view this\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract\n  /// @param _chainId number of chainId\n  /// @param _protocolId Id of the protocol of which the allocation is queried\n  /// @return int256 Number of derby tokens that are allocated towards this specific protocol\n  function basketAllocationInProtocol(\n    uint256 _basketId,\n    uint256 _chainId,\n    uint256 _protocolId\n  ) public view onlyBasketOwner(_basketId) returns (int256) {\n    return baskets[_basketId].allocations[_chainId][_protocolId];\n  }\n\n  /// @notice Setter for rebalancing period of the basket, used to calculate the rewards\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract\n  /// @param _vaultNumber number of vault\n  function setBasketRebalancingPeriod(\n    uint256 _basketId,\n    uint256 _vaultNumber\n  ) internal onlyBasketOwner(_basketId) {\n    baskets[_basketId].lastRebalancingPeriod = vaults[_vaultNumber].rebalancingPeriod + 1;\n  }\n\n  /// @notice function to see the total unredeemed rewards the basket has built up. Only the owner of the basket can view this.\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract.\n  /// @return int256 Total unredeemed rewards.\n  function basketUnredeemedRewards(\n    uint256 _basketId\n  ) external view onlyBasketOwner(_basketId) returns (int256) {\n    return baskets[_basketId].totalUnRedeemedRewards;\n  }\n\n  /// @notice function to see the total reeemed rewards from the basket. Only the owner of the basket can view this.\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract.\n  /// @return int256 Total redeemed rewards.\n  function basketRedeemedRewards(\n    uint256 _basketId\n  ) external view onlyBasketOwner(_basketId) returns (int) {\n    return baskets[_basketId].totalRedeemedRewards;\n  }\n\n  /// @notice Mints a new NFT with a Basket of allocations.\n  /// @dev The basket NFT is minted for a specific vault, starts with a zero allocation and the tokens are not locked here.\n  /// @param _vaultNumber Number of the vault. Same as in Router.\n  /// @return basketId The basket Id the user has minted.\n  function mintNewBasket(uint256 _vaultNumber) external returns (uint256) {\n    // mint Basket with nrOfUnAllocatedTokens equal to _lockedTokenAmount\n    baskets[latestBasketId].vaultNumber = _vaultNumber;\n    baskets[latestBasketId].lastRebalancingPeriod = vaults[_vaultNumber].rebalancingPeriod + 1;\n    _safeMint(msg.sender, latestBasketId);\n    latestBasketId++;\n\n    emit BasketId(msg.sender, latestBasketId - 1);\n    return latestBasketId - 1;\n  }\n\n  /// @notice Function to lock xaver tokens to a basket. They start out to be unallocated.\n  /// @param _lockedTokenAmount Amount of xaver tokens to lock inside this contract.\n  function lockTokensToBasket(uint256 _lockedTokenAmount) internal {\n    uint256 balanceBefore = derbyToken.balanceOf(address(this));\n    derbyToken.safeTransferFrom(msg.sender, address(this), _lockedTokenAmount);\n    uint256 balanceAfter = derbyToken.balanceOf(address(this));\n\n    require((balanceAfter - balanceBefore - _lockedTokenAmount) == 0, \"Error lock: under/overflow\");\n  }\n\n  /// @notice Function to unlock xaver tokens. If tokens are still allocated to protocols they first hevae to be unallocated.\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract.\n  /// @param _unlockedTokenAmount Amount of derby tokens to unlock and send to the user.\n  function unlockTokensFromBasket(uint256 _basketId, uint256 _unlockedTokenAmount) internal {\n    uint256 tokensBurned = redeemNegativeRewards(_basketId, _unlockedTokenAmount);\n    uint256 tokensToUnlock = _unlockedTokenAmount -= tokensBurned;\n\n    uint256 balanceBefore = derbyToken.balanceOf(address(this));\n    derbyToken.safeTransfer(msg.sender, tokensToUnlock);\n    uint256 balanceAfter = derbyToken.balanceOf(address(this));\n\n    require((balanceBefore - balanceAfter - tokensToUnlock) == 0, \"Error unlock: under/overflow\");\n  }\n\n  /// @notice IMPORTANT: The negativeRewardFactor takes in account an approximation of the price of derby tokens by the dao\n  /// @notice IMPORTANT: This will change to an exact price when there is a derby token liquidity pool\n  /// @notice Calculates if there are any negative rewards and how many tokens to burn\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract\n  /// @param _unlockedTokens Amount of derby tokens to unlock and send to user\n  /// @return tokensToBurn Amount of derby tokens that are burned\n  function redeemNegativeRewards(\n    uint256 _basketId,\n    uint256 _unlockedTokens\n  ) internal returns (uint256) {\n    int256 unredeemedRewards = baskets[_basketId].totalUnRedeemedRewards;\n    if (unredeemedRewards > negativeRewardThreshold) return 0;\n\n    uint256 tokensToBurn = (uint(-unredeemedRewards) * negativeRewardFactor) / 100;\n    tokensToBurn = tokensToBurn < _unlockedTokens ? tokensToBurn : _unlockedTokens;\n\n    baskets[_basketId].totalUnRedeemedRewards += int((tokensToBurn * 100) / negativeRewardFactor);\n\n    IERC20(derbyToken).safeTransfer(homeVault, tokensToBurn);\n\n    return tokensToBurn;\n  }\n\n  /// @notice rebalances an existing Basket\n  /// @dev First calculates the rewards the basket has built up, then sets the new allocations and communicates the deltas to the vault\n  /// @dev Finally it locks or unlocks tokens\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract.\n  /// @param _deltaAllocations delta allocations set by the user of the basket. Allocations are scaled (so * 1E18).\n  function rebalanceBasket(\n    uint256 _basketId,\n    int256[][] memory _deltaAllocations\n  ) external onlyBasketOwner(_basketId) nonReentrant {\n    uint256 vaultNumber = baskets[_basketId].vaultNumber;\n    for (uint k = 0; k < chainIds.length; k++) {\n      require(!isXChainRebalancing[vaultNumber][chainIds[k]], \"Game: vault is xChainRebalancing\");\n    }\n\n    addToTotalRewards(_basketId);\n    int256 totalDelta = settleDeltaAllocations(_basketId, vaultNumber, _deltaAllocations);\n\n    lockOrUnlockTokens(_basketId, totalDelta);\n    setBasketTotalAllocatedTokens(_basketId, totalDelta);\n    setBasketRebalancingPeriod(_basketId, vaultNumber);\n  }\n\n  /// @notice Internal helper to calculate and settle the delta allocations from baskets\n  /// @dev Sets the total allocations per ChainId, used in XChainController\n  /// @dev Sets the total allocations per protocol number, used in Vaults\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract\n  /// @param _vaultNumber number of vault\n  /// @param _deltaAllocations delta allocations set by the user of the basket. Allocations are scaled (so * 1E18)\n  /// @return totalDelta total delta allocated tokens of the basket, used in lockOrUnlockTokens\n  function settleDeltaAllocations(\n    uint256 _basketId,\n    uint256 _vaultNumber,\n    int256[][] memory _deltaAllocations\n  ) internal returns (int256 totalDelta) {\n    for (uint256 i = 0; i < _deltaAllocations.length; i++) {\n      int256 chainTotal;\n      uint32 chain = chainIds[i];\n      uint256 latestProtocol = latestProtocolId[chain];\n      require(_deltaAllocations[i].length == latestProtocol, \"Invalid allocation length\");\n\n      for (uint256 j = 0; j < latestProtocol; j++) {\n        int256 allocation = _deltaAllocations[i][j];\n        if (allocation == 0) continue;\n        chainTotal += allocation;\n        addDeltaAllocationProtocol(_vaultNumber, chain, j, allocation);\n        setBasketAllocationInProtocol(_basketId, chain, j, allocation);\n      }\n\n      totalDelta += chainTotal;\n      addDeltaAllocationChain(_vaultNumber, chain, chainTotal);\n    }\n  }\n\n  /// @notice rewards are calculated here.\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract.\n  function addToTotalRewards(uint256 _basketId) internal onlyBasketOwner(_basketId) {\n    if (baskets[_basketId].nrOfAllocatedTokens == 0) return;\n\n    uint256 vaultNum = baskets[_basketId].vaultNumber;\n    uint256 currentRebalancingPeriod = vaults[vaultNum].rebalancingPeriod;\n    uint256 lastRebalancingPeriod = baskets[_basketId].lastRebalancingPeriod;\n\n    if (currentRebalancingPeriod <= lastRebalancingPeriod) return;\n\n    for (uint k = 0; k < chainIds.length; k++) {\n      uint32 chain = chainIds[k];\n      uint256 latestProtocol = latestProtocolId[chain];\n      for (uint i = 0; i < latestProtocol; i++) {\n        int256 allocation = basketAllocationInProtocol(_basketId, chain, i) / 1E18;\n        if (allocation == 0) continue;\n\n        int256 lastRebalanceReward = getRewardsPerLockedToken(\n          vaultNum,\n          chain,\n          lastRebalancingPeriod,\n          i\n        );\n        int256 currentReward = getRewardsPerLockedToken(\n          vaultNum,\n          chain,\n          currentRebalancingPeriod,\n          i\n        );\n        baskets[_basketId].totalUnRedeemedRewards +=\n          (currentReward - lastRebalanceReward) *\n          allocation;\n      }\n    }\n  }\n\n  /// @notice Internal helper to lock or unlock tokens from the game contract\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract\n  /// @param _totalDelta total delta allocated tokens of the basket, calculated in settleDeltaAllocations\n  function lockOrUnlockTokens(uint256 _basketId, int256 _totalDelta) internal {\n    if (_totalDelta > 0) {\n      lockTokensToBasket(uint256(_totalDelta));\n    }\n    if (_totalDelta < 0) {\n      int256 oldTotal = basketTotalAllocatedTokens(_basketId);\n      int256 newTotal = oldTotal + _totalDelta;\n      int256 tokensToUnlock = oldTotal - newTotal;\n      require(oldTotal >= tokensToUnlock, \"Not enough tokens locked\");\n\n      unlockTokensFromBasket(_basketId, uint256(tokensToUnlock));\n    }\n  }\n\n  /// @notice Step 1 trigger; Game pushes totalDeltaAllocations to xChainController\n  /// @notice Trigger for Dao to push delta allocations to the xChainController\n  /// @param _vaultNumber Number of vault\n  /// @dev Sends over an array that should match the IDs in chainIds array\n  function pushAllocationsToController(uint256 _vaultNumber) external payable {\n    require(rebalanceNeeded(), \"No rebalance needed\");\n    for (uint k = 0; k < chainIds.length; k++) {\n      require(\n        getVaultAddress(_vaultNumber, chainIds[k]) != address(0),\n        \"Game: not a valid vaultnumber\"\n      );\n      require(\n        !isXChainRebalancing[_vaultNumber][chainIds[k]],\n        \"Game: vault is already rebalancing\"\n      );\n      isXChainRebalancing[_vaultNumber][chainIds[k]] = true;\n    }\n\n    int256[] memory deltas = allocationsToArray(_vaultNumber);\n    IXProvider(xProvider).pushAllocations{value: msg.value}(_vaultNumber, deltas);\n\n    lastTimeStamp = block.timestamp;\n    vaults[_vaultNumber].rebalancingPeriod++;\n\n    emit PushedAllocationsToController(_vaultNumber, deltas);\n  }\n\n  /// @notice Creates delta allocation array for chains matching IDs in chainIds array\n  /// @notice Resets deltaAllocation for chainIds\n  /// @return deltas Array with delta Allocations for all chainIds\n  function allocationsToArray(uint256 _vaultNumber) internal returns (int256[] memory deltas) {\n    deltas = new int[](chainIds.length);\n\n    for (uint256 i = 0; i < chainIds.length; i++) {\n      uint32 chain = chainIds[i];\n      deltas[i] = getDeltaAllocationChain(_vaultNumber, chain);\n      vaults[_vaultNumber].deltaAllocationChain[chain] = 0;\n    }\n  }\n\n  /// @notice Step 6 trigger; Game pushes deltaAllocations to vaults\n  /// @notice Trigger to push delta allocations in protocols to cross chain vaults\n  /// @param _vaultNumber Number of vault\n  /// @param _chain Chain id of the vault where the allocations need to be sent\n  /// @dev Sends over an array where the index is the protocolId\n  function pushAllocationsToVaults(uint256 _vaultNumber, uint32 _chain) external payable {\n    address vault = getVaultAddress(_vaultNumber, _chain);\n    require(vault != address(0), \"Game: not a valid vaultnumber\");\n    require(isXChainRebalancing[_vaultNumber][_chain], \"Vault is not rebalancing\");\n\n    int256[] memory deltas = protocolAllocationsToArray(_vaultNumber, _chain);\n\n    IXProvider(xProvider).pushProtocolAllocationsToVault{value: msg.value}(_chain, vault, deltas);\n\n    emit PushProtocolAllocations(_chain, getVaultAddress(_vaultNumber, _chain), deltas);\n\n    isXChainRebalancing[_vaultNumber][_chain] = false;\n  }\n\n  /// @notice Creates array with delta allocations in protocols for given chainId\n  /// @return deltas Array with allocations where the index matches the protocolId\n  function protocolAllocationsToArray(\n    uint256 _vaultNumber,\n    uint32 _chainId\n  ) internal returns (int256[] memory deltas) {\n    uint256 latestId = latestProtocolId[_chainId];\n    deltas = new int[](latestId);\n\n    for (uint256 i = 0; i < latestId; i++) {\n      deltas[i] = getDeltaAllocationProtocol(_vaultNumber, _chainId, i);\n      vaults[_vaultNumber].deltaAllocationProtocol[_chainId][i] = 0;\n    }\n  }\n\n  /// @notice See settleRewardsInt below\n  /// @param _vaultNumber Number of the vault\n  /// @param _chainId Number of chain used\n  /// @param _rewards Rewards per locked token per protocol (each protocol is an element in the array)\n  function settleRewards(\n    uint256 _vaultNumber,\n    uint32 _chainId,\n    int256[] memory _rewards\n  ) external onlyXProvider {\n    settleRewardsInt(_vaultNumber, _chainId, _rewards);\n  }\n\n  // basket should not be able to rebalance before this step\n  /// @notice Step 8 end; Vaults push rewardsPerLockedToken to game\n  /// @notice Loops through the array and fills the rewardsPerLockedToken mapping with the values\n  /// @param _vaultNumber Number of the vault\n  /// @param _chainId Number of chain used\n  /// @param _rewards Array with rewardsPerLockedToken of all protocols in vault => index matches protocolId\n  function settleRewardsInt(\n    uint256 _vaultNumber,\n    uint32 _chainId,\n    int256[] memory _rewards\n  ) internal {\n    uint256 rebalancingPeriod = vaults[_vaultNumber].rebalancingPeriod;\n\n    for (uint256 i = 0; i < _rewards.length; i++) {\n      int256 lastReward = getRewardsPerLockedToken(\n        _vaultNumber,\n        _chainId,\n        rebalancingPeriod - 1,\n        i\n      );\n      vaults[_vaultNumber].rewardPerLockedToken[_chainId][rebalancingPeriod][i] =\n        lastReward +\n        _rewards[i];\n    }\n  }\n\n  /// @notice Getter for rewardsPerLockedToken for given vaultNumber => chainId => rebalancingPeriod => protocolId\n  function getRewardsPerLockedToken(\n    uint256 _vaultNumber,\n    uint32 _chainId,\n    uint256 _rebalancingPeriod,\n    uint256 _protocolId\n  ) internal view returns (int256) {\n    return vaults[_vaultNumber].rewardPerLockedToken[_chainId][_rebalancingPeriod][_protocolId];\n  }\n\n  /// @notice redeem funds from basket in the game.\n  /// @dev makes a call to the vault to make the actual transfer because the vault holds the funds.\n  /// @param _basketId Basket ID (tokenID) in the BasketToken (NFT) contract.\n  function redeemRewards(uint256 _basketId) external onlyBasketOwner(_basketId) {\n    int256 amount = baskets[_basketId].totalUnRedeemedRewards;\n    require(amount > 0, \"Nothing to claim\");\n\n    baskets[_basketId].totalRedeemedRewards += amount;\n    baskets[_basketId].totalUnRedeemedRewards = 0;\n\n    IVault(homeVault).redeemRewardsGame(uint256(amount), msg.sender);\n  }\n\n  /// @notice Checks if a rebalance is needed based on the set interval\n  /// @return bool True of rebalance is needed, false if not\n  function rebalanceNeeded() public view returns (bool) {\n    return (block.timestamp - lastTimeStamp) > rebalanceInterval || msg.sender == guardian;\n  }\n\n  /// @notice getter for vault address linked to a chainId\n  function getVaultAddress(uint256 _vaultNumber, uint32 _chainId) internal view returns (address) {\n    return vaults[_vaultNumber].vaultAddress[_chainId];\n  }\n\n  /// @notice Getter for dao address\n  function getDao() public view returns (address) {\n    return dao;\n  }\n\n  /// @notice Getter for guardian address\n  function getGuardian() public view returns (address) {\n    return guardian;\n  }\n\n  /// @notice Getter for chainId array\n  function getChainIds() public view returns (uint32[] memory) {\n    return chainIds;\n  }\n\n  /// @notice Getter for rebalancing period for a vault\n  function getRebalancingPeriod(uint256 _vaultNumber) public view returns (uint256) {\n    return vaults[_vaultNumber].rebalancingPeriod;\n  }\n\n  /*\n  Only Dao functions\n  */\n\n  /// @notice Setter for xProvider address\n  /// @param _xProvider new address of xProvider on this chain\n  function setXProvider(address _xProvider) external onlyDao {\n    xProvider = _xProvider;\n  }\n\n  /// @notice Setter for homeVault address\n  /// @param _homeVault new address of homeVault on this chain\n  function setHomeVault(address _homeVault) external onlyDao {\n    homeVault = _homeVault;\n  }\n\n  /// @notice Set minimum interval for the rebalance function\n  /// @param _timestampInternal UNIX timestamp\n  function setRebalanceInterval(uint256 _timestampInternal) external onlyDao {\n    rebalanceInterval = _timestampInternal;\n  }\n\n  /// @notice Setter for DAO address\n  /// @param _dao DAO address\n  function setDao(address _dao) external onlyDao {\n    dao = _dao;\n  }\n\n  /// @notice Setter for guardian address\n  /// @param _guardian new address of the guardian\n  function setGuardian(address _guardian) external onlyDao {\n    guardian = _guardian;\n  }\n\n  /// @notice Setter Derby token address\n  /// @param _derbyToken new address of Derby token\n  function setDerbyToken(address _derbyToken) external onlyDao {\n    derbyToken = IERC20(_derbyToken);\n  }\n\n  /// @notice Setter for threshold at which user tokens will be sold / burned\n  /// @param _threshold treshold in vaultCurrency e.g USDC, must be negative\n  function setNegativeRewardThreshold(int256 _threshold) external onlyDao {\n    negativeRewardThreshold = _threshold;\n  }\n\n  /// @notice Setter for negativeRewardFactor\n  /// @param _factor percentage of tokens that will be sold / burned\n  function setNegativeRewardFactor(uint256 _factor) external onlyDao {\n    negativeRewardFactor = _factor;\n  }\n\n  /*\n  Only Guardian functions\n  */\n\n  /// @notice setter to link a chainId to a vault address for cross chain functions\n  function setVaultAddress(\n    uint256 _vaultNumber,\n    uint32 _chainId,\n    address _address\n  ) external onlyGuardian {\n    vaults[_vaultNumber].vaultAddress[_chainId] = _address;\n  }\n\n  /// @notice Setter for latest protocol Id for given chainId.\n  /// @param _chainId number of chain id set in chainIds array\n  /// @param _latestProtocolId latest protocol Id aka number of supported protocol vaults, starts at 0\n  function setLatestProtocolId(uint32 _chainId, uint256 _latestProtocolId) external onlyGuardian {\n    latestProtocolId[_chainId] = _latestProtocolId;\n  }\n\n  /// @notice Setter for chainId array\n  /// @param _chainIds array of all the used chainIds\n  function setChainIds(uint32[] memory _chainIds) external onlyGuardian {\n    chainIds = _chainIds;\n  }\n\n  /// @notice Guardian function to set state when vault gets stuck for whatever reason\n  function setRebalancingState(\n    uint256 _vaultNumber,\n    uint32 _chain,\n    bool _state\n  ) external onlyGuardian {\n    isXChainRebalancing[_vaultNumber][_chain] = _state;\n  }\n\n  /// @notice Guardian function to set rebalancing period for vaultNumber\n  function setRebalancingPeriod(uint256 _vaultNumber, uint256 _period) external onlyGuardian {\n    vaults[_vaultNumber].rebalancingPeriod = _period;\n  }\n\n  /// @notice Step 8: Guardian function\n  function settleRewardsGuard(\n    uint256 _vaultNumber,\n    uint32 _chainId,\n    int256[] memory _rewards\n  ) external onlyGuardian {\n    settleRewardsInt(_vaultNumber, _chainId, _rewards);\n  }\n}"
    },
    {
      "filename": "derby-yield-optimiser/contracts/Vault.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Derby Finance - 2022\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"./Interfaces/IController.sol\";\nimport \"./Interfaces/IProvider.sol\";\n\nimport \"./VaultToken.sol\";\nimport \"./libraries/Swap.sol\";\n\ncontract Vault is ReentrancyGuard {\n  using SafeERC20 for IERC20;\n\n  // state 0 Rebalance done and ready for xController to rebalance again\n  // state 1 Allocation amount received and ready to send funds over to xController\n  // state 2 Allocation amount 0 received => will receive funds from xController\n  // state 3 Allocation amount sent or received and ready to rebalance the vault itself\n  enum State {\n    Idle,\n    PushedUnderlying,\n    SendingFundsXChain,\n    WaitingForFunds,\n    RebalanceVault,\n    SendRewardsPerToken\n  }\n\n  IERC20 internal vaultCurrency;\n  IController internal controller;\n  State public state;\n\n  bool public deltaAllocationsReceived;\n\n  address private dao;\n  address private guardian;\n  address public vaultCurrencyAddr;\n  address public xController;\n\n  uint256 public vaultNumber;\n  uint256 public liquidityPerc;\n  uint256 public performanceFee;\n  uint256 public rebalancingPeriod;\n  uint256 public uScale;\n  uint256 public minimumPull;\n  int256 public marginScale;\n\n  // UNIX timestamp\n  uint256 public rebalanceInterval;\n  uint256 public lastTimeStamp;\n\n  // total underlying of all protocols in vault, excluding vault balance\n  uint256 public savedTotalUnderlying;\n\n  // total amount of funds the vault reserved for users that made a withdrawalRequest\n  uint256 internal reservedFunds;\n\n  // total number of allocated Derby tokens currently\n  int256 public totalAllocatedTokens;\n  // delta of the total number of Derby tokens allocated on next rebalancing\n  int256 private deltaAllocatedTokens;\n\n  string internal stateError = \"Wrong state\";\n\n  // (protocolNumber => currentAllocation): current allocations over the protocols\n  mapping(uint256 => int256) internal currentAllocations;\n\n  // (protocolNumber => deltaAllocation): delta of the portfolio on next rebalancing\n  mapping(uint256 => int256) internal deltaAllocations;\n\n  // historical reward per protocol per token, formula: TVL * yield * perfFee / totalLockedTokens\n  // (rebalancingPeriod => protocolId => rewardPerLockedToken)\n  mapping(uint256 => mapping(uint256 => int256)) public rewardPerLockedToken;\n\n  // (protocolNumber => lastPrice): last price of underlying protocol vault\n  mapping(uint256 => uint256) public lastPrices;\n\n  modifier onlyDao() {\n    require(msg.sender == dao, \"Vault: only DAO\");\n    _;\n  }\n\n  modifier onlyGuardian() {\n    require(msg.sender == guardian, \"only Guardian\");\n    _;\n  }\n\n  constructor(\n    uint256 _vaultNumber,\n    address _dao,\n    address _controller,\n    address _vaultCurrency,\n    uint256 _uScale\n  ) {\n    controller = IController(_controller);\n    vaultCurrency = IERC20(_vaultCurrency);\n\n    vaultNumber = _vaultNumber;\n    dao = _dao;\n    uScale = _uScale;\n    lastTimeStamp = block.timestamp;\n    minimumPull = 1_000_000;\n  }\n\n  /// @notice Withdraw from protocols on shortage in Vault\n  /// @dev Keeps on withdrawing until the Vault balance > _value\n  /// @param _value The total value of vaultCurrency an user is trying to withdraw.\n  /// @param _value The (value - current underlying value of this vault) is withdrawn from the underlying protocols.\n  function pullFunds(uint256 _value) internal {\n    uint256 latestID = controller.latestProtocolId(vaultNumber);\n    for (uint i = 0; i < latestID; i++) {\n      if (currentAllocations[i] == 0) continue;\n\n      uint256 shortage = _value - vaultCurrency.balanceOf(address(this));\n      uint256 balanceProtocol = balanceUnderlying(i);\n\n      uint256 amountToWithdraw = shortage > balanceProtocol ? balanceProtocol : shortage;\n      savedTotalUnderlying -= amountToWithdraw;\n\n      if (amountToWithdraw < minimumPull) break;\n      withdrawFromProtocol(i, amountToWithdraw);\n\n      if (_value <= vaultCurrency.balanceOf(address(this))) break;\n    }\n  }\n\n  /// @notice Step 7 trigger, end; Vaults rebalance\n  /// @notice Rebalances i.e deposit or withdraw from all underlying protocols\n  /// @dev amountToProtocol = totalAmount * currentAllocation / totalAllocatedTokens\n  /// @dev amountToDeposit = amountToProtocol - currentBalanceProtocol\n  /// @dev if amountToDeposit < 0 => withdraw\n  /// @dev Execute all withdrawals before deposits\n  function rebalance() external nonReentrant {\n    require(state == State.RebalanceVault, stateError);\n    require(deltaAllocationsReceived, \"!Delta allocations\");\n\n    rebalancingPeriod++;\n\n    claimTokens();\n    settleDeltaAllocation();\n\n    uint256 underlyingIncBalance = calcUnderlyingIncBalance();\n    uint256[] memory protocolToDeposit = rebalanceCheckProtocols(underlyingIncBalance);\n\n    executeDeposits(protocolToDeposit);\n    setTotalUnderlying();\n\n    if (reservedFunds > vaultCurrency.balanceOf(address(this))) pullFunds(reservedFunds);\n\n    state = State.SendRewardsPerToken;\n    deltaAllocationsReceived = false;\n  }\n\n  /// @notice Helper to return underlying balance plus totalUnderlying - liquidty for the vault\n  /// @ret"
    }
  ]
}