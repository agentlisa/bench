{
  "Title": "[M-20] Some functions in the Talos contracts do not allow user to supply `slippage` and `deadline`, which may cause swap revert",
  "Content": "\nIn the following functions, except `TalosBaseStrategy.redeem()`, the minimum `slippage` is still hardcoded to `0`, not allowing the user to specify their own slippage parameters. This can expose users to sandwich attacks due to unlimited slippage.\n\nAdditionally, it also does not allow users to supply their own `deadline`, as the `deadline` parameter is simply passed in currently as `block.timestamp`, in which the transaction occurs. This effectively means, that the transaction has no deadline; which means that a swap transaction may be included anytime by validators and remain pending in `mempool`, potentially exposing users to sandwich attacks by attackers or MEV bots.\n\n- `TalosBaseStrategy.redeem()` [Link](https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/base/TalosBaseStrategy.sol#L269)\n- `TalosStrategyVanilla._compoundFees()` [Link](https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/TalosStrategyVanilla.sol#L148)\n- `TalosBaseStrategy.init()` [Link](https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/base/TalosBaseStrategy.sol#L147)\n- `TaloseBaseStrategy.deposit()` [Link](https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/base/TalosBaseStrategy.sol#L208)\n- `TaloseBaseStrategy._withdrawAll()` [Link](https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/base/TalosBaseStrategy.sol#L359)\n\n### Proof of Concept\n\nConsider the following scenario:\n\n1. Alice wants to swap 30 BNB tokens for 1 BNB and later sell the 1 BNB for 300 DAI. They sign the transaction calling `TalosBaseStrategy.redeem()` with `inputAmount = 30 vBNB` and `amountOutmin = 0.99 BNB` (`$`1 slippage).\n\n2. The transaction is submitted to the `mempool`; however, Alice chose a transaction fee that is too low for validators to be interested in including their transaction in a block. The transaction stays pending in the `mempool` for extended periods, which could be hours, days, weeks, or even longer.\n\n3. When the average gas fee drops far enough for Alice's transaction to become interesting again for miners to include it, their swap will be executed. In the meantime, the price of BNB could have drastically decreased. They will still at least get 0.99 BNB due to `amountOutmin`, but the DAI value of that output might be significantly lower. They have unknowingly performed a bad trade due to the pending transaction they forgot about.\n\nAn even worse way, is this issue can be maliciously exploited is through MEV:\n\n1. The swap transaction is still pending in the `mempool`. Average fees are still too high for validators to be interested in it. The price of BNB has gone up significantly since the transaction was signed, meaning Alice would receive a lot more ETH when the swap is executed. But that also means that their `minOutput` value is outdated and would allow for significant slippage.\n\n2. A MEV bot detects the pending transaction. Since the outdated `minOut` now allows for high slippage, the bot sandwiches Alice, resulting in significant profit for the bot and significant loss for Alice.\n\nThe above scenario could be made worse for other functions where slippage is not allowed to be user-specified. When combined with the lack of a deadline check, MEV bots can simply immediately sandwich users.\n\n### Recommendation\n\nAllow users to supply their own `slippage` and `deadline` parameters within the stated functions. The `deadline` modifier can then be checked via a modifier or check, which has already been implemented via the `checkDeadline()` modifier.\n\n### Assessed type\n\nTiming\n\n**[0xLightt (Maia) confirmed](https://github.com/code-423n4/2023-05-maia-findings/issues/504#issuecomment-1655668398)**\n\n**[0xLightt (Maia) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/504#issuecomment-1709165574):**\n > Addressed [here](https://github.com/Maia-DAO/eco-c4-contest/tree/577-57-504-658-583-730).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/talos/base/TalosBaseStrategy.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Logic inspired by Popsicle Finance Contracts (PopsicleV3Optimizer/contracts/popsicle-v3-optimizer/PopsicleV3Optimizer.sol)\npragma solidity >=0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\n\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\nimport {IUniswapV3Pool} from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport {INonfungiblePositionManager} from \"@uniswap/v3-periphery/contracts/interfaces/INonfungiblePositionManager.sol\";\n\nimport {PoolVariables} from \"../libraries/PoolVariables.sol\";\n\nimport {ITalosBaseStrategy} from \"../interfaces/ITalosBaseStrategy.sol\";\nimport {ITalosOptimizer} from \"../interfaces/ITalosOptimizer.sol\";\n\n/// @title Tokenized Vault implementation for Uniswap V3 Non Fungible Positions.\nabstract contract TalosBaseStrategy is Ownable, ERC20, ReentrancyGuard, ITalosBaseStrategy {\n    using SafeTransferLib for address;\n    using FixedPointMathLib for uint256;\n    using FixedPointMathLib for uint128;\n    using SafeCastLib for uint256;\n    using SafeCastLib for uint128;\n    using PoolVariables for IUniswapV3Pool;\n\n    /*//////////////////////////////////////////////////////////////\n                        TALOS BASE STRATEGY STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ITalosBaseStrategy\n    uint256 public override tokenId;\n    /// @inheritdoc ITalosBaseStrategy\n    uint128 public override liquidity;\n\n    /// @inheritdoc ITalosBaseStrategy\n    uint256 public protocolFees0;\n    /// @inheritdoc ITalosBaseStrategy\n    uint256 public protocolFees1;\n\n    /// @notice Current tick lower of Optimizer pool position\n    /// @inheritdoc ITalosBaseStrategy\n    int24 public override tickLower;\n    /// @notice Current tick higher of Optimizer pool position\n    /// @inheritdoc ITalosBaseStrategy\n    int24 public override tickUpper;\n\n    /// @inheritdoc ITalosBaseStrategy\n    bool public initialized;\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ITalosBaseStrategy\n    ERC20 public immutable override token0;\n    /// @inheritdoc ITalosBaseStrategy\n    ERC20 public immutable override token1;\n    /// @inheritdoc ITalosBaseStrategy\n    int24 public immutable override tickSpacing;\n    /// @inheritdoc ITalosBaseStrategy\n    uint24 public immutable override poolFee;\n    /// @inheritdoc ITalosBaseStrategy\n    IUniswapV3Pool public immutable override pool;\n    /// @inheritdoc ITalosBaseStrategy\n    ITalosOptimizer public immutable override optimizer;\n    /// @inheritdoc ITalosBaseStrategy\n    address public immutable strategyManager;\n    /// @inheritdoc ITalosBaseStrategy\n    INonfungiblePositionManager public immutable override nonfungiblePositionManager;\n\n    uint24 internal constant MULTIPLIER = 1e6;\n\n    constructor(\n        IUniswapV3Pool _pool,\n        ITalosOptimizer _optimizer,\n        INonfungiblePositionManager _nonfungiblePositionManager,\n        address _strategyManager,\n        address _owner\n    ) ERC20(\"TALOS LP\", \"TLP\", 18) {\n        _initializeOwner(_owner);\n        optimizer = _optimizer;\n        nonfungiblePositionManager = _nonfungiblePositionManager;\n        strategyManager = _strategyManager;\n        pool = _pool;\n        token0 = ERC20(_pool.token0());\n        token1 = ERC20(_pool.token1());\n        tickSpacing = _pool.tickSpacing();\n        poolFee = _pool.fee();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            INITIALIZATION\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ITalosBaseStrategy\n    function init(uint256 amount0Desired, uint256 amount1Desired, address receiver)\n        external\n        virtual\n        nonReentrant\n        returns (uint256 shares, uint256 amount0, uint256 amount1)\n    {\n        if (initialized) revert AlreadyInitialized();\n\n        {\n            // Own Scope to avoid stack to deep\n            int24 _tickSpacing = tickSpacing; // Saves an extra SLOAD\n            int24 baseThreshold = _tickSpacing * optimizer.tickRangeMultiplier();\n            (, int24 currentTick,,,,,) = pool.slot0();\n            int24 tickFloor = PoolVariables.floor(currentTick, _tickSpacing);\n\n            int24 _tickLower = tickFloor - baseThreshold; // Saves an extra SLOAD\n            int24 _tickUpper = tickFloor + baseThreshold; // Saves an extra SLOAD\n            PoolVariables.checkRange(_tickLower, _tickUpper); // Check ticks also for overflow/underflow\n            tickLower = _tickLower;\n            tickUpper = _tickUpper;\n        }\n\n        (ERC20 _token0, ERC20 _token1) = (token0, token1);\n        address(_token0).safeTransferFrom(msg.sender, address(this), amount0Desired);\n        address(_token1).safeTransferFrom(msg.sender, address(this), amount1Desired);\n\n        INonfungiblePositionManager _nonfungiblePositionManager = nonfungiblePositionManager; // Saves an extra SLOAD\n\n        address(_token0).safeApprove(address(_nonfungiblePositionManager), type(uint256).max);\n        address(_token1).safeApprove(address(_nonfungiblePositionManager), type(uint256).max);\n\n        uint128 _liquidity;\n        uint256 _tokenId;\n        (_tokenId, _liquidity, amount0, amount1) = _nonfungiblePositionManager.mint(\n            INonfungiblePositionManager.MintParams({\n                token0: address(_token0),\n                token1: address(_token1),\n                fee: poolFee,\n                tickLower: tickLower,\n                tickUpper: tickUpper,\n                amount0Desired: amount0Desired,\n                amount1Desired: amount1Desired,\n                amount0Min: 0,\n                amount1Min: 0,\n                recipient: address(this),\n                deadline: block.timestamp\n            })\n        );\n\n        if (amount0 == 0 && amount1 == 0) revert AmountsAreZero();\n\n        shares = _liquidity * MULTIPLIER;\n        liquidity = _liquidity;\n        tokenId = _tokenId;\n\n        _mint(receiver, shares);\n        if (totalSupply > optimizer.maxTotalSupply()) revert ExceedingMaxTotalSupply();\n\n        emit Initialize(tokenId, msg.sender, receiver, amount0, amount1, shares);\n\n        afterDeposit(_tokenId);\n        initialized = true;\n\n        // Refund in both assets.\n        if (amount0 < amount0Desired) {\n            uint256 refund0 = amount0Desired - amount0;\n            address(_token0).safeTransfer(msg.sender, refund0);\n        }\n\n        if (amount1 < amount1Desired) {\n            uint256 refund1 = amount1Desired - amount1;\n            address(_token1).safeTransfer(msg.sender, refund1);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ITalosBaseStrategy\n    function deposit(uint256 amount0Desired, uint256 amount1Desired, address receiver)\n        public\n        virtual\n        override\n        nonReentrant\n        checkDeviation\n        returns (uint256 shares, uint256 amount0, uint256 amount1)\n    {\n        uint256 _tokenId = tokenId;\n\n        beforeDeposit(_tokenId, receiver);\n\n        (ERC20 _token0, ERC20 _token1) = (token0, token1);\n\n        address(_token0).safeTransferFrom(msg.sender, address(this), amount0Desired);\n        address(_token1).safeTransferFrom(msg.sender, address(this), amount1Desired);\n\n        uint128 liquidityDifference;\n\n        (liquidityDifference, amount0, amount1) = nonfungiblePositionManager.increaseLiquidity(\n            INonfungiblePositionManager.IncreaseLiquidityParams({\n                tokenId: _tokenId,\n                amount0Desired: amount0Desired,\n                amount1Desired: amount1Desired,\n                amount0Min: 0,\n                amount1Min: 0,\n                deadline: block.timestamp\n            })\n        );\n\n        if (amount0 == 0 && amount1 == 0) revert AmountsAreZero();\n\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n        shares = supply == 0 ? liquidityDifference * MULTIPLIER : (liquidityDifference * supply) / liquidity;\n        liquidity += liquidityDifference;\n\n        _mint(receiver, shares);\n        if (totalSupply > optimizer.maxTotalSupply()) revert ExceedingMaxTotalSupply();\n\n        emit Deposit(msg.sender, receiver, amount0, amount1, shares);\n\n        afterDeposit(_tokenId);\n\n        // Refund in both assets.\n        if (amount0 < amount0Desired) {\n            uint256 refund0 = amount0Desired - amount0;\n            address(_token0).safeTransfer(msg.sender, refund0);\n        }\n\n        if (amount1 < amount1Desired) {\n            uint256 refund1 = amount1Desired - amount1;\n            address(_token1).safeTransfer(msg.sender, refund1);\n        }\n    }\n\n    /// @inheritdoc ITalosBaseStrategy\n    function redeem(uint256 shares, uint256 amount0Min, uint256 amount1Min, address receiver, address _owner)\n        public\n        virtual\n        override\n        nonReentrant\n        checkDeviation\n        returns (uint256 amount0, uint256 amount1)\n    {\n        if (msg.sender != _owner) {\n            uint256 allowed = allowance[_owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[_owner][msg.sender] = allowed - shares;\n        }\n\n        if (shares == 0) revert RedeemingZeroShares();\n        if (receiver == address(0)) revert ReceiverIsZeroAddress();\n\n        uint256 _tokenId = tokenId;\n\n        beforeRedeem(_tokenId, receiver);\n\n        INonfungiblePositionManager _nonfungiblePositionManager = nonfungiblePositionManager; // Saves an extra SLOAD\n        {\n            uint128 liquidityToDecrease = uint128((liquidity * shares) / totalSupply);\n\n            (amount0, amount1) = _nonfungiblePositionManager.decreaseLiquidity(\n                INonfungiblePositionManager.DecreaseLiquidityParams({\n                    tokenId: _tokenId,\n                    liquidity: liquidityToDecrease,\n                    amount0Min: amount0Min,\n                    amount1Min: amount1Min,\n                    deadline: block.timestamp\n                })\n            );\n\n            if (amount0 == 0 && amount1 == 0) revert AmountsAreZero();\n\n            _burn(_owner, shares);\n\n            liquidity -= liquidityToDecrease;\n        }\n        emit Redeem(msg.sender, receiver, _owner, amount0, amount1, shares);\n\n        (amount0, amount1) = _nonfungiblePositionManager.collect(\n            INonfungiblePositionManager.CollectParams({\n                tokenId: _tokenId,\n                recipient: receiver,\n                amount0Max: type(uint128).max,\n                amount1Max: type(uint128).max\n            })\n        );\n\n        afterRedeem(_tokenId);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        RERANGE/REBALANCE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ITalosBaseStrategy\n    function rerange() external virtual override nonReentrant checkDeviation onlyStrategyManager {\n        uint256 _tokenId = tokenId;\n        beforeRerange(_tokenId);\n        // Redeem all liquidity from pool to rerange for Optimizer's balances.\n        _withdrawAll(_tokenId);\n\n        (uint256 amount0, uint256 amount1) = doRerange();\n        emit Rerange(tokenId, tickLower, tickUpper, amount0, amount1);\n\n        afterRerange(tokenId); // tokenId changed in doRerange\n    }\n\n    /// @inheritdoc ITalosBaseStrategy\n    function rebalance() external virtual override nonReentrant checkDeviation onlyStrategyManager {\n        uint256 _tokenId = tokenId;\n        beforeRerange(_tokenId);\n        // Redeem all liquidity from pool to rerange for Optimizer's balances.\n        _withdrawAll(_tokenId);\n\n        (uint256 amount0, uint256 amount1) = doRebalance();\n        emit Rerange(tokenId, tickLower, tickUpper, amount0, amount1);\n\n        afterRerange(tokenId); // tokenId changed in doRerange\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            EXTERNAL HOOKS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC721Receiver\n    function onERC721Received(address, address, uint256, bytes calldata) external pure override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    /// @inheritdoc ITalosBaseStrategy\n    function uniswapV3SwapCallback(int256 amount0, int256 amount1, bytes calldata _data) external {\n        if (msg.sender != address(pool)) revert CallerIsNotPool();\n        if (amount0 == 0 && amount1 == 0) revert AmountsAreZero();\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n        bool zeroForOne = data.zeroForOne;\n\n        if (zeroForOne) address(token0).safeTransfer(msg.sender, uint256(amount0));\n        else address(token1).safeTransfer(msg.sender, uint256(amount1));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Redeems all liquidity for a specific tokenId\n    /// @param _tokenId position to withdraw liquidity from\n    function _withdrawAll(uint256 _tokenId) internal {\n        uint128 _liquidity = liquidity; // Saves an extra SLOAD if totalSupply is non-zero.\n        if (_liquidity == 0) return;\n        INonfungiblePositionManager _nonfungiblePositionManager = nonfungiblePositionManager;\n        _nonfungiblePositionManager.decreaseLiquidity(\n            INonfungiblePositionManager.DecreaseLiquidityParams({\n                tokenId: _tokenId,\n                liquidity: _liquidity,\n                amount0Min: 0,\n                amount1Min: 0,\n                deadline: block.timestamp\n            })\n        );\n        liquidity = 0;\n        _nonfungiblePositionManager.collect(\n            INonfungiblePositionManager.CollectParams({\n                tokenId: _tokenId,\n                recipient: address(this),\n                amount0Max: type(uint128).max,\n                amount1Max: type(uint128).max\n            })\n        );\n    }\n\n    function beforeDeposit(uint256 _tokenId, address _receiver) internal virtual;\n\n    function afterDeposit(uint256 _tokenId) internal virtual;\n\n    function beforeRedeem(uint256 _tokenId, address _owner) internal virtual;\n\n    function afterRedeem(uint256 _tokenId) internal virtual;\n\n    function beforeRerange(uint256 _tokenId) internal virtual;\n\n    function afterRerange(uint256 _tokenId) internal virtual;\n\n    function doRerange() internal virtual returns (uint256 amount0, uint256 amount1);\n\n    function doRebalance() internal virtual returns (uint256 amount0, uint256 amount1);\n\n    /*//////////////////////////////////////////////////////////////\n                            ADMIN FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ITalosBaseStrategy\n    function collectProtocolFees(uint256 amount0, uint256 amount1) external nonReentrant onlyOwner {\n        uint256 _protocolFees0 = protocolFees0;\n        uint256 _protocolFees1 = protocolFees1;\n\n        if (amount0 > _protocolFees0) {\n            revert Token0AmountIsBiggerThanProtocolFees();\n        }\n        if (amount1 > _protocolFees1) {\n            revert Token1AmountIsBiggerThanProtocolFees();\n        }\n        ERC20 _token0 = token0;\n        ERC20 _token1 = token1;\n        uint256 balance0 = _token0.balanceOf(address(this));\n        uint256 balance1 = _token1.balanceOf(address(this));\n        require(balance0 >= amount0 && balance1 >= amount1);\n        if (amount0 > 0) _token0.transfer(msg.sender, amount0);\n        if (amount1 > 0) _token1.transfer(msg.sender, amount1);\n\n        protocolFees0 = _protocolFees0 - amount0;\n        protocolFees1 = _protocolFees1 - amount1;\n        emit RewardPaid(msg.sender, amount0, amount1);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Function modifier that checks if price has not moved a lot recently.\n    /// This mitigates price manipulation during rebalance and also prevents placing orders when it's too volatile.\n    modifier checkDeviation() {\n        ITalosOptimizer _optimizer = optimizer;\n        pool.checkDeviation(_optimizer.maxTwapDeviation(), _optimizer.twapDuration());\n        _;\n    }\n\n    /// @notice Function modifier that checks if msg.sender is the strategy manager.\n    modifier onlyStrategyManager() {\n        if (msg.sender != strategyManager) revert NotStrategyManager();\n        _;\n    }\n}"
    },
    {
      "filename": "src/talos/TalosStrategyVanilla.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Logic inspired by Popsicle Finance Contracts (PopsicleV3Optimizer/contracts/popsicle-v3-optimizer/PopsicleV3Optimizer.sol)\npragma solidity >=0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IUniswapV3Pool} from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\n\nimport {INonfungiblePositionManager} from \"@uniswap/v3-periphery/contracts/interfaces/INonfungiblePositionManager.sol\";\n\nimport {ITalosOptimizer} from \"./interfaces/ITalosOptimizer.sol\";\nimport {PoolVariables} from \"./libraries/PoolVariables.sol\";\n\nimport {TalosStrategySimple, TalosBaseStrategy} from \"./strategies/TalosStrategySimple.sol\";\n\n/// @title Deploy Vanilla\n/// @notice This library deploys talos vanilla strategies\nlibrary DeployVanilla {\n    function createTalosV3Vanilla(\n        IUniswapV3Pool pool,\n        ITalosOptimizer optimizer,\n        INonfungiblePositionManager nonfungiblePositionManager,\n        address strategyManager,\n        address owner\n    ) public returns (TalosBaseStrategy) {\n        return new TalosStrategyVanilla(\n                pool,\n                optimizer,\n                nonfungiblePositionManager,\n                strategyManager,\n                owner\n            );\n    }\n}\n\n/// @notice Tokenized Vault implementation for Uniswap V3 Non Fungible Positions.\n/// @author Maia DAO (https://github.com/Maia-DAO)\ncontract TalosStrategyVanilla is TalosStrategySimple {\n    using FixedPointMathLib for uint256;\n    using FixedPointMathLib for uint128;\n    using PoolVariables for IUniswapV3Pool;\n\n    /// @notice The protocol's fee in hundredths of a bip, i.e. 1e-6\n    uint24 private constant protocolFee = 2 * 1e5; //20%\n    uint24 private constant GLOBAL_DIVISIONER = 1e6;\n\n    /**\n     * @notice Constructs a new TalosStrategyVanilla contract.\n     * @param _pool The Uniswap V3 pool to manage.\n     * @param _optimizer The optimizer contract to use.\n     * @param _nonfungiblePositionManager The Uniswap V3 Non Fungible Position Manager contract.\n     * @param _strategyManager The strategy manager contract.\n     * @param _owner The owner of the contract.\n     */\n    constructor(\n        IUniswapV3Pool _pool,\n        ITalosOptimizer _optimizer,\n        INonfungiblePositionManager _nonfungiblePositionManager,\n        address _strategyManager,\n        address _owner\n    ) TalosStrategySimple(_pool, _optimizer, _nonfungiblePositionManager, _strategyManager, _owner) {}\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Performs the necessary actions before a withdraw can take place\n    /// @param _tokenId position id that the user is trying to withdraw from\n    function beforeRedeem(uint256 _tokenId, address) internal override {\n        _earnFees(_tokenId);\n        _compoundFees(_tokenId);\n    }\n\n    /// @notice Performs the necessary actions after a withdraw takes place\n    /// @param _tokenId position id that the user is trying to withdraw from\n    function afterRedeem(uint256 _tokenId) internal override {}\n\n    /// @notice Performs the necessary actions before a deposit can take place\n    /// @param _tokenId position id that the user wants to deposit in\n    function beforeDeposit(uint256 _tokenId, address) internal override {\n        _earnFees(_tokenId);\n        _compoundFees(_tokenId);\n    }\n\n    /// @notice Performs the necessary actions after a deposit takes place\n    /// @param _tokenId position id that the user wants to deposit in\n    function afterDeposit(uint256 _tokenId) internal override {}\n\n    /// @notice Performs the necessary actions before a re-range can take place\n    /// @param _tokenId position id that the user wants to re-range\n    function beforeRerange(uint256 _tokenId) internal override {\n        _earnFees(_tokenId);\n    }\n\n    /// @notice Performs the necessary actions after a re-range takes place\n    /// @param _tokenId position id that the user wants to deposit in\n    function afterRerange(uint256 _tokenId) internal override {}\n\n    /// @notice Collects fees from the pool to the protocol.\n    /// @param _tokenId position id that the user wants to collect fees from\n    function _earnFees(uint256 _tokenId) internal {\n        if (liquidity == 0) return; // no fees to collect when liquidity is zero\n\n        (uint256 collect0, uint256 collect1) = nonfungiblePositionManager.collect(\n            INonfungiblePositionManager.CollectParams({\n                tokenId: _tokenId,\n                recipient: address(this),\n                amount0Max: type(uint128).max,\n                amount1Max: type(uint128).max\n            })\n        );\n\n        uint24 _protocolFee = protocolFee;\n        uint24 _GLOBAL_DIVISIONER = GLOBAL_DIVISIONER;\n\n        // Calculate protocol's fees\n        uint256 earnedProtocolFees0 = (collect0 * _protocolFee) / _GLOBAL_DIVISIONER;\n        uint256 earnedProtocolFees1 = (collect1 * _protocolFee) / _GLOBAL_DIVISIONER;\n        protocolFees0 += earnedProtocolFees0;\n        protocolFees1 += earnedProtocolFees1;\n        emit CollectFees(earnedProtocolFees0, earnedProtocolFees1, collect0, collect1);\n    }\n\n    /// @notice Compounds fees from the pool from a user prespective\n    /// @param _tokenId position id that the user wants to compound fees from\n    function _compoundFees(uint256 _tokenId) internal returns (uint256 amount0, uint256 amount1) {\n        uint256 balance0 = token0.balanceOf(address(this)) - protocolFees0;\n        uint256 balance1 = token1.balanceOf(address(this)) - protocolFees1;\n\n        emit Snapshot(balance0, balance1);\n\n        //Get Liquidity for Optimizer's balances\n        uint128 _liquidity = pool.liquidityForAmounts(balance0, balance1, tickLower, tickUpper);\n\n        // Add liquidity to the pool\n        if (_liquidity > 0) {\n            uint128 liquidityDifference;\n            (liquidityDifference, amount0, amount1) = nonfungiblePositionManager.increaseLiquidity(\n                INonfungiblePositionManager.IncreaseLiquidityParams({\n                    tokenId: _tokenId,\n                    amount0Desired: balance0,\n                    amount1Desired: balance1,\n                    amount0Min: 0,\n                    amount1Min: 0,\n                    deadline: block.timestamp\n                })\n            );\n            liquidity += liquidityDifference;\n            emit CompoundFees(amount0, amount1);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Emitted when fees was collected from the pool\n    /// @param feesFromPool0 Total amount of fees collected in terms of token 0\n    /// @param feesFromPool1 Total amount of fees collected in terms of token 1\n    /// @param usersFees0 Total amount of fees collected by users in terms of token 0\n    /// @param usersFees1 Total amount of fees collected by users in terms of token 1\n    event CollectFees(uint256 feesFromPool0, uint256 feesFromPool1, uint256 usersFees0, uint256 usersFees1);\n\n    /// @notice Emitted when fees was compuonded to the pool\n    /// @param amount0 Total amount of fees compounded in terms of token 0\n    /// @param amount1 Total amount of fees compounded in terms of token 1\n    event CompoundFees(uint256 amount0, uint256 amount1);\n}"
    },
    {
      "filename": "src/talos/base/TalosBaseStrategy.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Logic inspired by Popsicle Finance Contracts (PopsicleV3Optimizer/contracts/popsicle-v3-optimizer/PopsicleV3Optimizer.sol)\npragma solidity >=0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\n\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\nimport {IUniswapV3Pool} from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport {INonfungiblePositionManager} from \"@uniswap/v3-periphery/contracts/interfaces/INonfungiblePositionManager.sol\";\n\nimport {PoolVariables} from \"../libraries/PoolVariables.sol\";\n\nimport {ITalosBaseStrategy} from \"../interfaces/ITalosBaseStrategy.sol\";\nimport {ITalosOptimizer} from \"../interfaces/ITalosOptimizer.sol\";\n\n/// @title Tokenized Vault implementation for Uniswap V3 Non Fungible Positions.\nabstract contract TalosBaseStrategy is Ownable, ERC20, ReentrancyGuard, ITalosBaseStrategy {\n    using SafeTransferLib for address;\n    using FixedPointMathLib for uint256;\n    using FixedPointMathLib for uint128;\n    using SafeCastLib for uint256;\n    using SafeCastLib for uint128;\n    using PoolVariables for IUniswapV3Pool;\n\n    /*//////////////////////////////////////////////////////////////\n                        TALOS BASE STRATEGY STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ITalosBaseStrategy\n    uint256 public override tokenId;\n    /// @inheritdoc ITalosBaseStrategy\n    uint128 public override liquidity;\n\n    /// @inheritdoc ITalosBaseStrategy\n    uint256 public protocolFees0;\n    /// @inheritdoc ITalosBaseStrategy\n    uint256 public protocolFees1;\n\n    /// @notice Current tick lower of Optimizer pool position\n    /// @inheritdoc ITalosBaseStrategy\n    int24 public override tickLower;\n    /// @notice Current tick higher of Optimizer pool position\n    /// @inheritdoc ITalosBaseStrategy\n    int24 public override tickUpper;\n\n    /// @inheritdoc ITalosBaseStrategy\n    bool public initialized;\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ITalosBaseStrategy\n    ERC20 public immutable override token0;\n    /// @inheritdoc ITalosBaseStrategy\n    ERC20 public immutable override token1;\n    /// @inheritdoc ITalosBaseStrategy\n    int24 public immutable override tickSpacing;\n    /// @inheritdoc ITalosBaseStrategy\n    uint24 public immutable override poolFee;\n    /// @inheritdoc ITalosBaseStrategy\n    IUniswapV3Pool public immutable override pool;\n    /// @inheritdoc ITalosBaseStrategy\n    ITalosOptimizer public immutable override optimizer;\n    /// @inheritdoc ITalosBaseStrategy\n    address public immutable strategyManager;\n    /// @inheritdoc ITalosBaseStrategy\n    INonfungiblePositionManager public immutable override nonfungiblePositionManager;\n\n    uint24 internal constant MULTIPLIER = 1e6;\n\n    constructor(\n        IUniswapV3Pool _pool,\n        ITalosOptimizer _optimizer,\n        INonfungiblePositionManager _nonfungiblePositionManager,\n        address _strategyManager,\n        address _owner\n    ) ERC20(\"TALOS LP\", \"TLP\", 18) {\n        _initializeOwner(_owner);\n        optimizer = _optimizer;\n        nonfungiblePositionManager = _nonfungiblePositionManager;\n        strategyManager = _strategyManager;\n        pool = _pool;\n        token0 = ERC20(_pool.token0());\n        token1 = ERC20(_pool.token1());\n        tickSpacing = _pool.tickSpacing();\n        poolFee = _pool.fee();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            INITIALIZATION\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ITalosBaseStrategy\n    function init(uint256 amount0Desired, uint256 amount1Desired, address receiver)\n        external\n        virtual\n        nonReentrant\n        returns (uint256 shares, uint256 amount0, uint256 amount1)\n    {\n        if (initialized) revert AlreadyInitialized();\n\n        {\n            // Own Scope to avoid stack to deep\n            int24 _tickSpacing = tickSpacing; // Saves an extra SLOAD\n            int24 baseThreshold = _tickSpacing * optimizer.tickRangeMultiplier();\n            (, int24 currentTick,,,,,) = pool.slot0();\n            int24 tickFloor = PoolVariables.floor(currentTick, _tickSpacing);\n\n            int24 _tickLower = tickFloor - baseThreshold; // Saves an extra SLOAD\n            int24 _tickUpper = tickFloor + baseThreshold; // Saves an extra SLOAD\n            PoolVariables.checkRange(_tickLower, _tickUpper); // Check ticks also for overflow/underflow\n            tickLower = _tickLower;\n            tickUpper = _tickUpper;\n        }\n\n        (ERC20 _token0, ERC20 _token1) = (token0, token1);\n        address(_token0).safeTransferFrom(msg.sender, address(this), amount0Desired);\n        address(_token1).safeTransferFrom(msg.sender, address(this), amount1Desired);\n\n        INonfungiblePositionManager _nonfungiblePositionManager = nonfungiblePositionManager; // Saves an extra SLOAD\n\n        address(_token0).safeApprove(address(_nonfungiblePositionManager), type(uint256).max);\n        address(_token1).safeApprove(address(_nonfungiblePositionManager), type(uint256).max);\n\n        uint128 _liquidity;\n        uint256 _tokenId;\n        (_tokenId, _liquidity, amount0, amount1) = _nonfungiblePositionManager.mint(\n            INonfungiblePositionManager.MintParams({\n                token0: address(_token0),\n                token1: address(_token1),\n                fee: poolFee,\n                tickLower: tickLower,\n                tickUpper: tickUpper,\n                amount0Desired: amount0Desired,\n                amount1Desired: amount1Desired,\n                amount0Min: 0,\n                amount1Min: 0,\n                recipient: address(this),\n                deadline: block.timestamp\n            })\n        );\n\n        if (amount0 == 0 && amount1 == 0) revert AmountsAreZero();\n\n        shares = _liquidity * MULTIPLIER;\n        liquidity = _liquidity;\n        tokenId = _tokenId;\n\n        _mint(receiver, shares);\n        if (totalSupply > optimizer.maxTotalSupply()) revert ExceedingMaxTotalSupply();\n\n        emit Initialize(tokenId, msg.sender, receiver, amount0, amount1, shares);\n\n        afterDeposit(_tokenId);\n        initialized = true;\n\n        // Refund in both assets.\n        if (amount0 < amount0Desired) {\n            uint256 refund0 = amount0Desired - amount0;\n            address(_token0).safeTransfer(msg.sender, refund0);\n        }\n\n        if (amount1 < amount1Desired) {\n            uint256 refund1 = amount1Desired - amount1;\n            address(_token1).safeTransfer(msg.sender, refund1);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ITalosBaseStrategy\n    function deposit(uint256 amount0Desired, uint256 amount1Desired, address receiver)\n        public\n        virtual\n        override\n        nonReentrant\n        checkDeviation\n        returns (uint256 shares, uint256 amount0, uint256 amount1)\n    {\n        uint256 _tokenId = tokenId;\n\n        beforeDeposit(_tokenId, receiver);\n\n        (ERC20 _token0, ERC20 _token1) = (token0, token1);\n\n        address(_token0).safeTransferFrom(msg.sender, address(this), amount0Desired);\n        address(_token1).safeTransferFrom(msg.sender, address(this), amount1Desired);\n\n        uint128 liquidityDifference;\n\n        (liquidityDifference, amount0, amo"
    }
  ]
}