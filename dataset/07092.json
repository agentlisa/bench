{
  "Title": "[N-16]  Contract does not follow the Solidity style guide's suggested layout ordering",
  "Content": "\nThe [style guide](https://docs.soliditylang.org/en/v0.8.16/style-guide.html#order-of-layout) says that, within a contract, the ordering should be 1) Type declarations, 2) State variables, 3) Events, 4) Modifiers, and 5) Functions, but the contract(s) below do not follow this ordering\n\n*There are 35 instances of this issue:*\n\n```solidity\nFile: src/utils/MultiRewardEscrow.sol\n\n/// @audit function getEscrows came earlier\n64      mapping(bytes32 => Escrow) public escrows;\n65    \n66      // User => Escrows\n67      mapping(address => bytes32[]) public userEscrowIds;\n68      // User => RewardsToken => Escrows\n69:     mapping(address => mapping(IERC20 => bytes32[])) public userEscrowIdsByToken;\n\n/// @audit function lock came earlier\n136:    event RewardsClaimed(IERC20 indexed token, address indexed account, uint256 amount);\n\n/// @audit function _getClaimableAmount came earlier\n191:    address public feeRecipient;\n\n```\nhttps://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/utils/MultiRewardEscrow.sol#L64-L69\n\n```solidity\nFile: src/utils/MultiRewardStaking.sol\n\n/// @audit function _transfer came earlier\n157:    IMultiRewardEscrow public escrow;\n\n/// @audit function _lockToken came earlier\n208:    IERC20[] public rewardTokens;\n\n/// @audit function getAllRewardsTokens came earlier\n371     modifier accrueRewards(address _caller, address _receiver) {\n372       IERC20[] memory _rewardTokens = rewardTokens;\n373       for (uint8 i; i < _rewardTokens.length; i++) {\n374         IERC20 rewardToken = _rewardTokens[i];\n375         RewardInfo memory rewards = rewardInfos[rewardToken];\n376   \n377         if (rewards.rewardsPerSecond > 0) _accrueRewards(rewardToken, _accrueStatic(rewards));\n378         _accrueUser(_receiver, rewardToken);\n379   \n380         // If a deposit/withdraw operation gets called for another user we should accrue for both of them to avoid potential issues like in the Convex-Vulnerability\n381         if (_receiver != _caller) _accrueUser(_caller, rewardToken);\n382       }\n383       _;\n384:    }\n\n/// @audit function _accrueUser came earlier\n438:    uint256 internal INITIAL_CHAIN_ID;\n\n```\nhttps://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/utils/MultiRewardStaking.sol#L157\n\n```solidity\nFile: src/vault/adapter/abstracts/AdapterBase.sol\n\n/// @audit function _withdraw came earlier\n241:      uint256 internal underlyingBalance;\n\n/// @audit function maxMint came earlier\n427:      IStrategy public strategy;\n\n/// @audit function _verifyAndSetupStrategy came earlier\n489:      uint256 public harvestCooldown;\n\n/// @audit function setHarvestCooldown came earlier\n513:      uint256 public performanceFee;\n\n/// @audit function setPerformanceFee came earlier\n559       modifier takeFees() {\n560           _;\n561   \n562           uint256 fee = accruedPerformanceFee();\n563           if (fee > 0) _mint(FEE_RECIPIENT, convertToShares(fee));\n564   \n565           uint256 shareValue = convertToAssets(1e18);\n566           if (shareValue > highWaterMark) highWaterMark = shareValue;\n567:      }\n\n/// @audit function supportsInterface came earlier\n625:      uint256 internal INITIAL_CHAIN_ID;\n\n```\nhttps://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/adapter/abstracts/AdapterBase.sol#L241\n\n```solidity\nFile: src/vault/CloneFactory.sol\n\n/// @audit function constructor came earlier\n29:     event Deployment(address indexed clone);\n\n```\nhttps://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/CloneFactory.sol#L29\n\n```solidity\nFile: src/vault/CloneRegistry.sol\n\n/// @audit function constructor came earlier\n28:     mapping(address => bool) public cloneExists;\n\n```\nhttps://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/CloneRegistry.sol#L28\n\n```solidity\nFile: src/vault/PermissionRegistry.sol\n\n/// @audit function constructor came earlier\n26:     mapping(address => Permission) public permissions;\n\n```\nhttps://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/PermissionRegistry.sol#L26\n\n```solidity\nFile: src/vault/TemplateRegistry.sol\n\n/// @audit function constructor came earlier\n31      mapping(bytes32 => mapping(bytes32 => Template)) public templates;\n32      mapping(bytes32 => bytes32[]) public templateIds;\n33      mapping(bytes32 => bool) public templateExists;\n34    \n35:     mapping(bytes32 => bool) public templateCategoryExists;\n\n/// @audit function addTemplate came earlier\n88      event TemplateEndorsementToggled(\n89        bytes32 templateCategory,\n90        bytes32 templateId,\n91        bool oldEndorsement,\n92        bool newEndorsement\n93:     );\n\n```\nhttps://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/TemplateRegistry.sol#L31-L35\n\n```solidity\nFile: src/vault/VaultController.sol\n\n/// @audit function constructor came earlier\n76:     event VaultDeployed(address indexed vault, address indexed staking, address indexed adapter);\n\n/// @audit function changeVaultFees came earlier\n387:    IVaultRegistry public vaultRegistry;\n\n/// @audit function fundStakingRewards came earlier\n535:    IMultiRewardEscrow public escrow;\n\n/// @audit function _verifyEqualArrayLength came earlier\n704     modifier canCreate() {\n705       if (\n706         permissionRegistry.endorsed(address(1))\n707           ? !permissionRegistry.endorsed(msg.sender)\n708           : permissionRegistry.rejected(msg.sender)\n709       ) revert NotAllowed(msg.sender);\n710       _;\n711:    }\n\n/// @audit modifier canCreate came earlier\n717:    IAdminProxy public adminProxy;\n\n/// @audit function acceptAdminProxyOwnership came earlier\n739:    uint256 public performanceFee;\n\n/// @audit function setAdapterPerformanceFees came earlier\n779:    uint256 public harvestCooldown;\n\n/// @audit function setAdapterHarvestCooldowns came earlier\n819:    IDeploymentController public deploymentController;\n\n/// @audit function _setDeploymentController came earlier\n851:    mapping(bytes32 => bytes32) public activeTemplateId;\n\n```\nhttps://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/VaultController.sol#L76\n\n```solidity\nFile: src/vault/VaultRegistry.sol\n\n/// @audit function constructor came earlier\n28      mapping(address => VaultMetadata) public metadata;\n29    \n30      // asset to vault addresses\n31:     mapping(address => address[]) public vaultsByAsset;\n\n```\nhttps://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/VaultRegistry.sol#L28-L31\n\n```solidity\nFile: src/vault/Vault.sol\n\n/// @audit function decimals came earlier\n108       event Deposit(\n109           address indexed caller,\n110           address indexed owner,\n111           uint256 assets,\n112           uint256 shares\n113:      );\n\n/// @audit function accruedPerformanceFee came earlier\n466:      uint256 public highWaterMark = 1e18;\n\n/// @audit function takeManagementAndPerformanceFees came earlier\n480       modifier takeFees() {\n481           uint256 managementFee = accruedManagementFee();\n482           uint256 totalFee = managementFee + accruedPerformanceFee();\n483           uint256 currentAssets = totalAssets();\n484           uint256 shareValue = convertToAssets(1e18);\n485   \n486           if (shareValue > highWaterMark) highWaterMark = shareValue;\n487   \n488           if (managementFee > 0) feesUpdatedAt = block.timestamp;\n489   \n490           if (totalFee > 0 && currentAssets > 0)\n491               _mint(feeRecipient, convertToShares(totalFee));\n492   \n493           _;\n494:      }\n\n/// @audit modifier syncFeeCheckpoint came earlier\n505:      VaultFees public fees;\n\n/// @audit function setFeeRecipient came earlier\n565:      IERC4626 public adapter;\n\n/// @audit function changeAdapter came earlier\n619:      uint256 public quitPeriod = 3 days;\n\n/// @audit function unpause came earlier\n657:      uint256 internal INITIAL_CHAIN_ID;\n\n```\nhttps://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/Vault.sol#L108-L113\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-01-popcorn",
  "Code": [
    {
      "filename": "src/utils/MultiRewardEscrow.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n// Docgen-SOLC: 0.8.15\n\npragma solidity ^0.8.15;\n\nimport { SafeERC20Upgradeable as SafeERC20 } from \"openzeppelin-contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport { IERC20Upgradeable as IERC20 } from \"openzeppelin-contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport { Math } from \"openzeppelin-contracts/utils/math/Math.sol\";\nimport { Owned } from \"./Owned.sol\";\nimport { SafeCastLib } from \"solmate/utils/SafeCastLib.sol\";\nimport { Fee, Escrow } from \"../interfaces/IMultiRewardEscrow.sol\";\n\n/**\n * @title   MultiRewardEscrow\n * @author  RedVeil\n * @notice  Permissionlessly escrow tokens for a specific period of time.\n *\n * Anyone can create an escrow for any token and any user.\n * The owner can only decide to take fees on the creation of escrows with certain tokens.\n */\ncontract MultiRewardEscrow is Owned {\n  using SafeERC20 for IERC20;\n  using SafeCastLib for uint256;\n\n  /**\n   * @notice Constructor for the Escrow contract.\n   * @param _owner Owner of the contract. Controls management functions.\n   * @param _feeRecipient Receiver of all fees.\n   */\n  constructor(address _owner, address _feeRecipient) Owned(_owner) {\n    feeRecipient = _feeRecipient;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                            GET ESCROW VIEWS\n    //////////////////////////////////////////////////////////////*/\n\n  function getEscrowIdsByUser(address account) external view returns (bytes32[] memory) {\n    return userEscrowIds[account];\n  }\n\n  function getEscrowIdsByUserAndToken(address account, IERC20 token) external view returns (bytes32[] memory) {\n    return userEscrowIdsByToken[account][token];\n  }\n\n  /**\n   * @notice Returns an array of Escrows.\n   * @param escrowIds Array of escrow ids.\n   * @dev there is no check to ensure that all escrows are owned by the same account. Make sure to account for this either by only sending ids for a specific account or by filtering the Escrows by account later on.\n   */\n  function getEscrows(bytes32[] calldata escrowIds) external view returns (Escrow[] memory) {\n    Escrow[] memory selectedEscrows = new Escrow[](escrowIds.length);\n    for (uint256 i = 0; i < escrowIds.length; i++) {\n      selectedEscrows[i] = escrows[escrowIds[i]];\n    }\n    return selectedEscrows;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                            LOCK LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  // EscrowId => Escrow\n  mapping(bytes32 => Escrow) public escrows;\n\n  // User => Escrows\n  mapping(address => bytes32[]) public userEscrowIds;\n  // User => RewardsToken => Escrows\n  mapping(address => mapping(IERC20 => bytes32[])) public userEscrowIdsByToken;\n\n  uint256 internal nonce;\n\n  event Locked(IERC20 indexed token, address indexed account, uint256 amount, uint32 duration, uint32 offset);\n\n  error ZeroAddress();\n  error ZeroAmount();\n\n  /**\n   * @notice Locks funds for escrow.\n   * @param token The token to be locked.\n   * @param account Recipient of the escrowed funds.\n   * @param amount Amount of tokens to be locked.\n   * @param duration Duration of the escrow. Every escrow unlocks token linearly.\n   * @param offset A cliff before the escrow starts.\n   * @dev This creates a separate escrow structure which can later be iterated upon to unlock the escrowed funds.\n   * @dev The Owner may decide to add a fee to the escrowed amount.\n   */\n  function lock(\n    IERC20 token,\n    address account,\n    uint256 amount,\n    uint32 duration,\n    uint32 offset\n  ) external {\n    if (token == IERC20(address(0))) revert ZeroAddress();\n    if (account == address(0)) revert ZeroAddress();\n    if (amount == 0) revert ZeroAmount();\n    if (duration == 0) revert ZeroAmount();\n\n    token.safeTransferFrom(msg.sender, address(this), amount);\n\n    nonce++;\n\n    bytes32 id = keccak256(abi.encodePacked(token, account, amount, nonce));\n\n    uint256 feePerc = fees[token].feePerc;\n    if (feePerc > 0) {\n      uint256 fee = Math.mulDiv(amount, feePerc, 1e18);\n\n      amount -= fee;\n      token.safeTransfer(feeRecipient, fee);\n    }\n\n    uint32 start = block.timestamp.safeCastTo32() + offset;\n\n    escrows[id] = Escrow({\n      token: token,\n      start: start,\n      end: start + duration,\n      lastUpdateTime: start,\n      initialBalance: amount,\n      balance: amount,\n      account: account\n    });\n\n    userEscrowIds[account].push(id);\n    userEscrowIdsByToken[account][token].push(id);\n\n    emit Locked(token, account, amount, duration, offset);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                            CLAIM LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  event RewardsClaimed(IERC20 indexed token, address indexed account, uint256 amount);\n\n  error NotClaimable(bytes32 escrowId);\n\n  function isClaimable(bytes32 escrowId) external view returns (bool) {\n    return escrows[escrowId].lastUpdateTime != 0 && escrows[escrowId].balance > 0;\n  }\n\n  function getClaimableAmount(bytes32 escrowId) external view returns (uint256) {\n    return _getClaimableAmount(escrows[escrowId]);\n  }\n\n  /**\n   * @notice Claim rewards for multiple escrows.\n   * @param escrowIds Array of escrow ids.\n   * @dev Uses the `vaultIds` at the specified indices of `userEscrows`.\n   * @dev Prevention for gas overflow should be handled in the frontend\n   */\n  function claimRewards(bytes32[] memory escrowIds) external {\n    for (uint256 i = 0; i < escrowIds.length; i++) {\n      bytes32 escrowId = escrowIds[i];\n      Escrow memory escrow = escrows[escrowId];\n\n      uint256 claimable = _getClaimableAmount(escrow);\n      if (claimable == 0) revert NotClaimable(escrowId);\n\n      escrows[escrowId].balance -= claimable;\n      escrows[escrowId].lastUpdateTime = block.timestamp.safeCastTo32();\n\n      escrow.token.safeTransfer(escrow.account, claimable);\n      emit RewardsClaimed(escrow.token, escrow.account, claimable);\n    }\n  }\n\n  function _getClaimableAmount(Escrow memory escrow) internal view returns (uint256) {\n    if (\n      escrow.lastUpdateTime == 0 ||\n      escrow.end == 0 ||\n      escrow.balance == 0 ||\n      block.timestamp.safeCastTo32() < escrow.start\n    ) {\n      return 0;\n    }\n    return\n      Math.min(\n        (escrow.balance * (block.timestamp - uint256(escrow.lastUpdateTime))) /\n          (uint256(escrow.end) - uint256(escrow.lastUpdateTime)),\n        escrow.balance\n      );\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                            FEE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  address public feeRecipient;\n\n  // escrowToken => feeAmount\n  mapping(IERC20 => Fee) public fees;\n\n  event FeeSet(IERC20 indexed token, uint256 amount);\n\n  error ArraysNotMatching(uint256 length1, uint256 length2);\n  error DontGetGreedy(uint256 fee);\n  error NoFee(IERC20 token);\n\n  /**\n   * @notice Set fees for multiple tokens. Caller must be the owner.\n   * @param tokens Array of tokens.\n   * @param tokenFees Array of fees for `tokens` in 1e18. (1e18 = 100%, 1e14 = 1 BPS)\n   */\n  function setFees(IERC20[] memory tokens, uint256[] memory tokenFees) external onlyOwner {\n    if (tokens.length != tokenFees.length) revert ArraysNotMatching(tokens.length, tokenFees.length);\n\n    for (uint256 i = 0; i < tokens.length; i++) {\n      if (tokenFees[i] >= 1e17) revert DontGetGreedy(tokenFees[i]);\n\n      fees[tokens[i]].feePerc = tokenFees[i];\n      emit FeeSet(tokens[i], tokenFees[i]);\n    }\n  }\n}"
    },
    {
      "filename": "src/utils/MultiRewardStaking.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n// Docgen-SOLC: 0.8.15\n\npragma solidity ^0.8.15;\n\nimport { SafeERC20Upgradeable as SafeERC20 } from \"openzeppelin-contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport { ERC4626Upgradeable, ERC20Upgradeable, IERC20Upgradeable as IERC20, IERC20MetadataUpgradeable as IERC20Metadata } from \"openzeppelin-contracts-upgradeable/token/ERC20/extensions/ERC4626Upgradeable.sol\";\nimport { MathUpgradeable as Math } from \"openzeppelin-contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport { SafeCastLib } from \"solmate/utils/SafeCastLib.sol\";\nimport { OwnedUpgradeable } from \"./OwnedUpgradeable.sol\";\nimport { IMultiRewardEscrow } from \"../interfaces/IMultiRewardEscrow.sol\";\nimport { RewardInfo, EscrowInfo } from \"../interfaces/IMultiRewardStaking.sol\";\n\n/**\n * @title   MultiRewardStaking\n * @author  RedVeil\n * @notice  See the following for the full EIP-4626 specification https://eips.ethereum.org/EIPS/eip-4626.\n *\n * An ERC4626 compliant implementation of a staking contract which allows rewards in multiple tokens.\n * Only one token can be staked but rewards can be added in any token.\n * Rewards can be paid out over time or instantly.\n * Only the owner can add new tokens as rewards. Once added they cant be removed or changed. RewardsSpeed can only be adjusted if the rewardsSpeed is not 0.\n * Anyone can fund existing rewards.\n * Based on the flywheel implementation of fei-protocol https://github.com/fei-protocol/flywheel-v2\n */\ncontract MultiRewardStaking is ERC4626Upgradeable, OwnedUpgradeable {\n  using SafeERC20 for IERC20;\n  using SafeCastLib for uint256;\n  using Math for uint256;\n\n  string private _name;\n  string private _symbol;\n  uint8 private _decimals;\n\n  /**\n   * @notice Initialize a new MultiRewardStaking contract.\n   * @param _stakingToken The token to be staked.\n   * @param _escrow An optional escrow contract which can be used to lock rewards on claim.\n   * @param _owner Owner of the contract. Controls management functions.\n   */\n  function initialize(\n    IERC20 _stakingToken,\n    IMultiRewardEscrow _escrow,\n    address _owner\n  ) external initializer {\n    __ERC4626_init(IERC20Metadata(address(_stakingToken)));\n    __Owned_init(_owner);\n\n    _name = string(abi.encodePacked(\"Staked \", IERC20Metadata(address(_stakingToken)).name()));\n    _symbol = string(abi.encodePacked(\"pst-\", IERC20Metadata(address(_stakingToken)).symbol()));\n    _decimals = IERC20Metadata(address(_stakingToken)).decimals();\n\n    escrow = _escrow;\n\n    INITIAL_CHAIN_ID = block.chainid;\n    INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n  }\n\n  function name() public view override(ERC20Upgradeable, IERC20Metadata) returns (string memory) {\n    return _name;\n  }\n\n  function symbol() public view override(ERC20Upgradeable, IERC20Metadata) returns (string memory) {\n    return _symbol;\n  }\n\n  function decimals() public view override(ERC20Upgradeable, IERC20Metadata) returns (uint8) {\n    return _decimals;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                    ERC4626 MUTATIVE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n  function deposit(uint256 _amount) external returns (uint256) {\n    return deposit(_amount, msg.sender);\n  }\n\n  function mint(uint256 _amount) external returns (uint256) {\n    return mint(_amount, msg.sender);\n  }\n\n  function withdraw(uint256 _amount) external returns (uint256) {\n    return withdraw(_amount, msg.sender, msg.sender);\n  }\n\n  function redeem(uint256 _amount) external returns (uint256) {\n    return redeem(_amount, msg.sender, msg.sender);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                        ERC4626 OVERRIDES\n    //////////////////////////////////////////////////////////////*/\n\n  error ZeroAddressTransfer(address from, address to);\n  error InsufficentBalance();\n\n  function _convertToShares(uint256 assets, Math.Rounding) internal pure override returns (uint256) {\n    return assets;\n  }\n\n  function _convertToAssets(uint256 shares, Math.Rounding) internal pure override returns (uint256) {\n    return shares;\n  }\n\n  /// @notice Internal deposit function used by `deposit()` and `mint()`. Accrues rewards for the `caller` and `receiver`.\n  function _deposit(\n    address caller,\n    address receiver,\n    uint256 assets,\n    uint256 shares\n  ) internal override accrueRewards(caller, receiver) {\n    IERC20(asset()).safeTransferFrom(caller, address(this), assets);\n\n    _mint(receiver, shares);\n\n    emit Deposit(caller, receiver, assets, shares);\n  }\n\n  /// @notice Internal withdraw function used by `withdraw()` and `redeem()`. Accrues rewards for the `caller` and `receiver`.\n  function _withdraw(\n    address caller,\n    address receiver,\n    address owner,\n    uint256 assets,\n    uint256 shares\n  ) internal override accrueRewards(caller, receiver) {\n    if (caller != owner) _approve(owner, msg.sender, allowance(owner, msg.sender) - shares);\n\n    _burn(owner, shares);\n    IERC20(asset()).safeTransfer(receiver, assets);\n\n    emit Withdraw(caller, receiver, owner, assets, shares);\n  }\n\n  /// @notice Internal transfer function used by `transfer()` and `transferFrom()`. Accrues rewards for `from` and `to`.\n  function _transfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal override accrueRewards(from, to) {\n    if (from == address(0) || to == address(0)) revert ZeroAddressTransfer(from, to);\n\n    uint256 fromBalance = balanceOf(from);\n    if (fromBalance < amount) revert InsufficentBalance();\n\n    _burn(from, amount);\n    _mint(to, amount);\n\n    emit Transfer(from, to, amount);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                            CLAIM LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  IMultiRewardEscrow public escrow;\n\n  event RewardsClaimed(address indexed user, IERC20 rewardToken, uint256 amount, bool escrowed);\n\n  error ZeroRewards(IERC20 rewardToken);\n\n  /**\n   * @notice Claim rewards for a user in any amount of rewardTokens.\n   * @param user User for which rewards should be claimed.\n   * @param _rewardTokens Array of rewardTokens for which rewards should be claimed.\n   * @dev This function will revert if any of the rewardTokens have zero rewards accrued.\n   * @dev A percentage of each reward can be locked in an escrow contract if this was previously configured.\n   */\n  function claimRewards(address user, IERC20[] memory _rewardTokens) external accrueRewards(msg.sender, user) {\n    for (uint8 i; i < _rewardTokens.length; i++) {\n      uint256 rewardAmount = accruedRewards[user][_rewardTokens[i]];\n\n      if (rewardAmount == 0) revert ZeroRewards(_rewardTokens[i]);\n\n      EscrowInfo memory escrowInfo = escrowInfos[_rewardTokens[i]];\n\n      if (escrowInfo.escrowPercentage > 0) {\n        _lockToken(user, _rewardTokens[i], rewardAmount, escrowInfo);\n        emit RewardsClaimed(user, _rewardTokens[i], rewardAmount, true);\n      } else {\n        _rewardTokens[i].transfer(user, rewardAmount);\n        emit RewardsClaimed(user, _rewardTokens[i], rewardAmount, false);\n      }\n\n      accruedRewards[user][_rewardTokens[i]] = 0;\n    }\n  }\n\n  /// @notice Locks a percentage of a reward in an escrow contract. Pays out the rest to the user.\n  function _lockToken(\n    address user,\n    IERC20 rewardToken,\n    uint256 rewardAmount,\n    EscrowInfo memory escrowInfo\n  ) internal {\n    uint256 escrowed = rewardAmount.mulDiv(uint256(escrowInfo.escrowPercentage), 1e18, Math.Rounding.Down);\n    uint256 payout = rewardAmount - escrowed;\n\n    rewardToken.safeTransfer(user, payout);\n    escrow.lock(rewardToken, user, escrowed, escrowInfo.escrowDuration, escrowInfo.offset);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                    REWARDS MANAGEMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  IERC20[] public rewardTokens;\n\n  // rewardToken -> RewardInfo\n  mapping(IERC20 => RewardInfo) public rewardInfos;\n  // rewardToken -> EscrowInfo\n  mapping(IERC20 => EscrowInfo) public escrowInfos;\n\n  // user => rewardToken -> rewardsIndex\n  mapping(address => mapping(IERC20 => uint256)) public userIndex;\n  // user => rewardToken -> accruedRewards\n  mapping(address => mapping(IERC20 => uint256)) public accruedRewards;\n\n  event RewardInfoUpdate(IERC20 rewardToken, uint160 rewardsPerSecond, uint32 rewardsEndTimestamp);\n\n  error RewardTokenAlreadyExist(IERC20 rewardToken);\n  error RewardTokenDoesntExist(IERC20 rewardToken);\n  error RewardTokenCantBeStakingToken();\n  error ZeroAmount();\n  error NotSubmitter(address submitter);\n  error RewardsAreDynamic(IERC20 rewardToken);\n  error ZeroRewardsSpeed();\n\n  /**\n   * @notice Adds a new rewardToken which can be earned via staking. Caller must be owner.\n   * @param rewardToken Token that can be earned by staking.\n   * @param rewardsPerSecond The rate in which `rewardToken` will be accrued.\n   * @param amount Initial funding amount for this reward.\n   * @param useEscrow Bool if the rewards should be escrowed on claim.\n   * @param escrowPercentage The percentage of the reward that gets escrowed in 1e18. (1e18 = 100%, 1e14 = 1 BPS)\n   * @param escrowDuration The duration of the escrow.\n   * @param offset A cliff after claim before the escrow starts.\n   * @dev The `rewardsEndTimestamp` gets calculated based on `rewardsPerSecond` and `amount`.\n   * @dev If `rewardsPerSecond` is 0 the rewards will be paid out instantly. In this case `amount` must be 0.\n   * @dev If `useEscrow` is `false` the `escrowDuration`, `escrowPercentage` and `offset` will be ignored.\n   */\n  function addRewardToken(\n    IERC20 rewardToken,\n    uint160 rewardsPerSecond,\n    uint256 amount,\n    bool useEscrow,\n    uint192 escrowPercentage,\n    uint32 escrowDuration,\n    uint32 offset\n  ) external onlyOwner {\n    if (asset() == address(rewardToken)) revert RewardTokenCantBeStakingToken();\n\n    RewardInfo memory rewards = rewardInfos[rewardToken];\n    if (rewards.lastUpdatedTimestamp > 0) revert RewardTokenAlreadyExist(rewardToken);\n\n    if (amount > 0) {\n      if (rewardsPerSecond == 0) revert ZeroRewardsSpeed();\n      rewardToken.safeTransferFrom(msg.sender, address(this), amount);\n    }\n\n    // Add the rewardToken to all existing rewardToken\n    rewardTokens.push(rewardToken);\n\n    if (useEscrow) {\n      escrowInfos[rewardToken] = EscrowInfo({\n        escrowPercentage: escrowPercentage,\n        escrowDuration: escrowDuration,\n        offset: offset\n      });\n      rewardToken.safeApprove(address(escrow), type(uint256).max);\n    }\n\n    uint64 ONE = (10**IERC20Metadata(address(rewardToken)).decimals()).safeCastTo64();\n    uint32 rewardsEndTimestamp = rewardsPerSecond == 0\n      ? block.timestamp.safeCastTo32()\n      : _calcRewardsEnd(0, rewardsPerSecond, amount);\n\n    rewardInfos[rewardToken] = RewardInfo({\n      ONE: ONE,\n      rewardsPerSecond: rewardsPerSecond,\n      rewardsEndTimestamp: rewardsEndTimestamp,\n      index: ONE,\n      lastUpdatedTimestamp: block.timestamp.safeCastTo32()\n    });\n\n    emit RewardInfoUpdate(rewardToken, rewardsPerSecond, rewardsEndTimestamp);\n  }\n\n  /**\n   * @notice Changes rewards speed for a rewardToken. This works only for rewards that accrue over time. Caller must be owner.\n   * @param rewardToken Token that can be earned by staking.\n   * @param rewardsPerSecond The rate in which `rewardToken` will be accrued.\n   * @dev The `rewardsEndTimestamp` gets calculated based on `rewardsPerSecond` and `amount`.\n   */\n  function changeRewardSpeed(IERC20 rewardToken, uint160 rewardsPerSecond) external onlyOwner {\n    RewardInfo memory rewards = rewardInfos[rewardToken];\n\n    if (rewardsPerSecond == 0) revert ZeroAmount();\n    if (rewards.lastUpdatedTimestamp == 0) revert RewardTokenDoesntExist(rewardToken);\n    if (rewards.rewardsPerSecond == 0) revert RewardsAreDynamic(rewardToken);\n\n    _accrueRewards(rewardToken, _accrueStatic(rewards));\n\n    uint256 remainder = rewardToken.balanceOf(address(this));\n\n    uint32 prevEndTime = rewards.rewardsEndTimestamp;\n    uint32 rewardsEndTimestamp = _calcRewardsEnd(\n      prevEndTime > block.timestamp ? prevEndTime : block.timestamp.safeCastTo32(),\n      rewardsPerSecond,\n      remainder\n    );\n    rewardInfos[rewardToken].rewardsPerSecond = rewardsPerSecond;\n    rewardInfos[rewardToken].rewardsEndTimestamp = rewardsEndTimestamp;\n  }\n\n  /**\n   * @notice Funds rewards for a rewardToken.\n   * @param rewardToken Token that can be earned by staking.\n   * @param amount The amount of rewardToken that will fund this reward.\n   * @dev The `rewardsEndTimestamp` gets calculated based on `rewardsPerSecond` and `amount`.\n   * @dev If `rewardsPerSecond` is 0 the rewards will be paid out instantly.\n   */\n  function fundReward(IERC20 rewardToken, uint256 amount) external {\n    if (amount == 0) revert ZeroAmount();\n\n    // Cache RewardInfo\n    RewardInfo memory rewards = rewardInfos[rewardToken];\n\n    // Make sure that the reward exists\n    if (rewards.lastUpdatedTimestamp == 0) revert RewardTokenDoesntExist(rewardToken);\n\n    // Transfer additional rewardToken to fund rewards of this vault\n    rewardToken.safeTransferFrom(msg.sender, address(this), amount);\n\n    uint256 accrued = rewards.rewardsPerSecond == 0 ? amount : _accrueStatic(rewards);\n\n    // Update the index of rewardInfo before updating the rewardInfo\n    _accrueRewards(rewardToken, accrued);\n    uint32 rewardsEndTimestamp = rewards.rewardsEndTimestamp;\n    if (rewards.rewardsPerSecond > 0) {\n      rewardsEndTimestamp = _calcRewardsEnd(rewards.rewardsEndTimestamp, rewards.rewardsPerSecond, amount);\n      rewardInfos[rewardToken].rewardsEndTimestamp = rewardsEndTimestamp;\n    }\n\n    rewardInfos[rewardToken].lastUpdatedTimestamp = block.timestamp.safeCastTo32();\n\n    emit RewardInfoUpdate(rewardToken, rewards.rewardsPerSecond, rewardsEndTimestamp);\n  }\n\n  function _calcRewardsEnd(\n    uint32 rewardsEndTimestamp,\n    uint160 rewardsPerSecond,\n    uint256 amount\n  ) internal returns (uint32) {\n    if (rewardsEndTimestamp > block.timestamp)\n      amount += uint256(rewardsPerSecond) * (rewardsEndTimestamp - block.timestamp);\n\n    return (block.timestamp + (amount / uint256(rewardsPerSecond))).safeCastTo32();\n  }\n\n  function getAllRewardsTokens() external view returns (IERC20[] memory) {\n    return rewardTokens;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                      REWARDS ACCRUAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  /// @notice Accrue rewards for up to 2 users for all available reward tokens.\n  modifier accrueRewards(address _caller, address _receiver) {\n    IERC20[] memory _rewardTokens = rewardTokens;\n    for (uint8 i; i < _rewardTokens.length; i++) {\n      IERC20 rewardToken = _rewardTokens[i];\n      RewardInfo memory rewards = rewardInfos[rewardToken];\n\n      if (rewards.rewardsPerSecond > 0) _accrueRewards(rewardToken, _accrueStatic(rewards));\n      _accrueUser(_receiver, rewardToken);\n\n      // If a deposit/withdraw operation gets called for another user we should accrue for both of them to avoid potential issues like in the Convex-Vulnerability\n      if (_receiver != _caller) _accrueUser(_caller, rewardToken);\n    }\n    _;\n  }\n\n  /**\n   * @notice Accrue rewards over time.\n   * @dev Based on https://github.com/fei-protocol/flywheel-v2/blob/main/src/rewards/FlywheelStaticRewards.sol\n   */\n  function _accrueStatic(RewardInfo memory rewards) internal view returns (uint256 accrued) {\n    uint256 elapsed;\n    if (rewards.rewardsEndTimestamp > block.timestamp) {\n      elapsed = block.timestamp - rewards.lastUpdatedTimestamp;\n    } else if (rewards.rewardsEndTimestamp > rewards.lastUpdatedTimestamp) {\n      elapsed = rewards.rewardsEndTimestamp - rewards.lastUpdatedTimestamp;\n    }\n\n    accrued = uint256(rewards.rewardsPerSecond * elapsed);\n  }\n\n  /// @notice Accrue global rewards for a rewardToken\n  function _accrueRewards(IERC20 _rewardToken, uint256 accrued) internal {\n    uint256 supplyTokens = totalSupply();\n    uint224 deltaIndex;\n    if (supplyTokens != 0)\n      deltaIndex = accrued.mulDiv(uint256(10**decimals()), supplyTokens, Math.Rounding.Down).safeCastTo224();\n\n    rewardInfos[_rewardToken].index += deltaIndex;\n    rewardInfos[_rewardToken].lastUpdatedTimestamp = block.timestamp.safeCastTo32();\n  }\n\n  /// @notice Sync a user's rewards for a rewardToken with the global reward index for that token\n  function _accrueUser(address _user, IERC20 _rewardToken) internal {\n    RewardInfo memory rewards = rewardInfos[_rewardToken];\n\n    uint256 oldIndex = userIndex[_user][_rewardToken];\n\n    // If user hasn't yet accrued rewards, grant them interest from the strategy beginning if they have a balance\n    // Zero balances will have no effect other than syncing to global index\n    if (oldIndex == 0) {\n      oldIndex = rewards.ONE;\n    }\n\n    uint256 deltaIndex = rewards.index - oldIndex;\n\n    // Accumulate rewards by multiplying user tokens by rewardsPerToken index and adding on unclaimed\n    uint256 supplierDelta = balanceOf(_user).mulDiv(deltaIndex, uint256(rewards.ONE), Math.Rounding.Down);\n\n    userIndex[_user][_rewardToken] = rewards.index;\n\n    accruedRewards[_user][_rewardToken] += supplierDelta;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                            PERMIT LOGC\n    //////////////////////////////////////////////////////////////*/\n\n  uint256 internal INITIAL_CHAIN_ID;\n  bytes32 internal INITIAL_DOMAIN_SEPARATOR;\n  mapping(address => uint256) public nonces;\n\n  error PermitDeadlineExpired(uint256 deadline);\n  error InvalidSigner(address signer);\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public virtual {\n    if (deadline < block.timestamp) revert PermitDeadlineExpired(deadline);\n\n    // Unchecked because the only math done is incrementing\n    // the owner's nonce which cannot realistically overflow.\n    unchecked {\n      address recoveredAddress = ecrecover(\n        keccak256(\n          abi.encodePacked(\n            \"\\x19\\x01\",\n            DOMAIN_SEPARATOR(),\n            keccak256(\n              abi.encode(\n                keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"),\n                owner,\n                spender,\n                value,\n                nonces[owner]++,\n                deadline\n              )\n            )\n          )\n        ),\n        v,\n        r,\n        s\n      );\n\n      if (recoveredAddress == address(0) || recoveredAddress != owner) revert InvalidSigner(recoveredAddress);\n\n      _approve(recoveredAddress, spender, value);\n    }\n  }\n\n  function DOMAIN_SEPARATOR() public view returns (bytes32) {\n    return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n  }\n\n  function computeDomainSeparator() internal view virtual returns (bytes32) {\n    return\n      keccak256(\n        abi.encode(\n          keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n          keccak256(bytes(name())),\n          keccak256(\"1\"),\n          block.chainid,\n          address(this)\n        )\n      );\n  }\n}"
    },
    {
      "filename": "src/vault/adapter/abstracts/AdapterBase.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n// Docgen-SOLC: 0.8.15\n\npragma solidity ^0.8.15;\n\nimport {ERC4626Upgradeable, IERC20Upgradeable as IERC20, IERC20MetadataUpgradeable as IERC20Metadata, ERC20Upgradeable as ERC20} from \"openzeppelin-contracts-upgradeable/token/ERC20/extensions/ERC4626Upgradeable.sol\";\nimport {SafeERC20Upgradeable as SafeERC20} from \"openzeppelin-contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"openzeppelin-contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {MathUpgradeable as Math} from \"openzeppelin-contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport {PausableUpgradeable} from \"openzeppelin-contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {IStrategy} from \"../../../interfaces/vault/IStrategy.sol\";\nimport {IAdapter} from \"../../../interfaces/vault/IAdapter.sol\";\nimport {EIP165} from \"../../../utils/EIP165.sol\";\nimport {OnlyStrategy} from \"./OnlyStrategy.sol\";\nimport {OwnedUpgradeable} from \"../../../utils/OwnedUpgradeable.sol\";\n\n/**\n * @title   AdapterBase\n * @author  RedVeil\n * @notice  See the following for the full EIP-4626 specification https://eips.ethereum.org/EIPS/eip-4626.\n *\n * The ERC4626 compliant base contract for all adapter contracts.\n * It allows interacting with an underlying protocol.\n * All specific interactions for the underlying protocol need to be overriden in the actual implementation.\n * The adapter can be initialized with a strategy that can perform additional operations. (Leverage, Compounding, etc.)\n */\nabstract contract AdapterBase is\n    ERC4626Upgradeable,\n    PausableUpgradeable,\n    OwnedUpgradeable,\n    ReentrancyGuardUpgradeable,\n    EIP165,\n    OnlyStrategy\n{\n    using SafeERC20 for IERC20;\n    using Math for uint256;\n\n    uint8 internal _decimals;\n\n    error StrategySetupFailed();\n\n    /**\n     * @notice Initialize a new Adapter.\n     * @param popERC4626InitData Encoded data for the base adapter initialization.\n     * @dev `asset` - The underlying asset\n     * @dev `_owner` - Owner of the contract. Controls management functions.\n     * @dev `_strategy` - An optional strategy to enrich the adapter with additional functionality.\n     * @dev `_harvestCooldown` - Cooldown period between harvests.\n     * @dev `_requiredSigs` - Function signatures required by the strategy (EIP-165)\n     * @dev `_strategyConfig` - Additional data which can be used by the strategy on `harvest()`\n     * @dev This function is called by the factory contract when deploying a new vault.\n     * @dev Each Adapter implementation should implement checks to make sure that the adapter is wrapping the underlying protocol correctly.\n     * @dev If a strategy is provided, it will be verified to make sure it implements the required functions.\n     */\n    function __AdapterBase_init(bytes memory popERC4626InitData)\n        internal\n        onlyInitializing\n    {\n        (\n            address asset,\n            address _owner,\n            address _strategy,\n            uint256 _harvestCooldown,\n            bytes4[8] memory _requiredSigs,\n            bytes memory _strategyConfig\n        ) = abi.decode(\n                popERC4626InitData,\n                (address, address, address, uint256, bytes4[8], bytes)\n            );\n        __Owned_init(_owner);\n        __Pausable_init();\n        __ERC4626_init(IERC20Metadata(asset));\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n\n        _decimals = IERC20Metadata(asset).decimals();\n\n        strategy = IStrategy(_strategy);\n        strategyConfig = _strategyConfig;\n        harvestCooldown = _harvestCooldown;\n\n        if (_strategy != address(0)) _verifyAndSetupStrategy(_requiredSigs);\n\n        highWaterMark = 1e18;\n        lastHarvest = block.timestamp;\n    }\n\n    function decimals()\n        public\n        view\n        override(IERC20Metadata, ERC20)\n        returns (uint8)\n    {\n        return _decimals;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    error MaxError(uint256 amount);\n    error ZeroAmount();\n\n    /**\n     * @notice Deposits assets into the underlying protocol and mints vault shares to `receiver`.\n     * @param assets Amount of assets to deposit.\n     * @param receiver Receiver of the shares.\n     */\n    function deposit(uint256 assets, address receiver)\n        public\n        virtual\n        override\n        returns (uint256)\n    {\n        if (assets > maxDeposit(receiver)) revert MaxError(assets);\n\n        uint256 shares = _previewDeposit(assets);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return shares;\n    }\n\n    /**\n     * @notice Mints vault shares to `receiver` and deposits assets into the underlying protocol.\n     * @param shares Amount of shares to mint.\n     * @param receiver Receiver of the shares.\n     */\n    function mint(uint256 shares, address receiver)\n        public\n        virtual\n        override\n        returns (uint256)\n    {\n        if (shares > maxMint(receiver)) revert MaxError(shares);\n\n        uint256 assets = _previewMint(shares);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return assets;\n    }\n\n    /**\n     * @notice Deposit `assets` into the underlying protocol and mints vault shares to `receiver`.\n     * @dev Executes harvest if `harvestCooldown` is passed since last invocation.\n     */\n    function _deposit(\n        address caller,\n        address receiver,\n        uint256 assets,\n        uint256 shares\n    ) internal nonReentrant virtual override {\n        IERC20(asset()).safeTransferFrom(caller, a"
    }
  ]
}