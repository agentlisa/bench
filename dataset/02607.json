{
  "Title": "Reentrancy risk in depositing to the queue",
  "Content": "The internal [`_deposit`](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/vaults/BaseVault.sol#L407) function handles user deposits, transferring a specified amount of `stETH` from `msg.sender` to the vault. Before moving the funds, it adds the deposit to the queue, which is processed later by the [`processQueuedDeposits`](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/vaults/BaseVault.sol#L371) function.\n\n\nAs the underlying token could have hooks that allow the token sender to execute code before the transfer (e.g., ERC777 standard), a malicious user could use those hooks to re-enter the `deposit` function multiple times.\n\n\nThis re-entrancy will result in an increment in the receiver balance on the queue, even though this balance will not correspond to the actual amount deposited into the vault.\n\n\nIn the current implementation, the `_deposit` function in the `BaseVault` contract is overridden by the [implementation in the `STETHVault`](https://github.com/pods-finance/yield-contracts/blob/9389ab46e9ecdd1ea1fd7228c9d9c6821c00f057/contracts/vaults/STETHVault.sol#L113-L126), which has the correct order of operation. However, the `BaseVault` is likely to be inherited by future vaults, so it is crucial to have the correct `_deposit` implementation in this contract in case it is not overridden.\n\n\nConsider reordering the calls, doing the transfer first, and then adding the receiver to the queue to prevent this reentrancy scenario. Also, consider using [OpenZeppelin’s ERC4626 implementation](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/ERC4626.sol), which already has this solution implemented.\n\n\n**Update:** *Fixed in [PR#41](https://github.com/pods-finance/yield-contracts/pull/41), with commit `2ffcb1e` being the last one added.*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/vaults/BaseVault.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../interfaces/IConfigurationManager.sol\";\nimport \"../interfaces/IVault.sol\";\nimport \"../libs/AuxMath.sol\";\nimport \"../libs/DepositQueueLib.sol\";\nimport \"../libs/CastUint.sol\";\nimport \"../mixins/Capped.sol\";\n\n/**\n * @title A Vault that tokenize shares of strategy\n * @author Pods Finance\n */\nabstract contract BaseVault is IVault, ERC20Permit, Capped {\n    using SafeERC20 for IERC20Metadata;\n    using AuxMath for uint256;\n    using CastUint for uint256;\n    using DepositQueueLib for DepositQueueLib.DepositQueue;\n\n    IConfigurationManager public immutable configuration;\n    IERC20Metadata internal immutable _asset;\n\n    uint256 public currentRoundId;\n    bool public isProcessingDeposits = false;\n\n    /*\n    DENOMINATOR represents the precision for the following system variables:\n    - MAX_WITHDRAW_FEE\n    - InvestorRatio\n    */\n\n    uint256 public constant DENOMINATOR = 10000;\n    /*\n    MAX_WITDRAW_FEE is a safe check in case the ConfiguratorManager sets\n    a fee high enough that can be used as a way to drain funds. \n    The precision of this number is set by constant DENOMINATOR.\n    */\n    uint256 public constant MAX_WITHDRAW_FEE = 1000;\n    uint256 public constant EMERGENCY_INTERVAL = 604800;\n    uint256 public processedDeposits = 0;\n    uint256 private _lastEndRound;\n\n    DepositQueueLib.DepositQueue internal depositQueue;\n\n    constructor(IConfigurationManager _configuration, IERC20Metadata _asset_)\n        ERC20(\n            string(abi.encodePacked(\"Pods Yield \", _asset_.symbol())),\n            string(abi.encodePacked(\"py\", _asset_.symbol()))\n        )\n        ERC20Permit(string(abi.encodePacked(\"Pods Yield \", _asset_.symbol())))\n        Capped(_configuration)\n    {\n        configuration = _configuration;\n        _asset = _asset_;\n\n        // Vault starts in `start` state\n        emit StartRound(currentRoundId, 0);\n        _lastEndRound = block.timestamp;\n    }\n\n    modifier onlyController() {\n        if (msg.sender != controller()) revert IVault__CallerIsNotTheController();\n        _;\n    }\n\n    modifier onlyRoundStarter() {\n        bool lastRoundEndedAWeekAgo = block.timestamp >= _lastEndRound + EMERGENCY_INTERVAL;\n\n        if (!lastRoundEndedAWeekAgo && msg.sender != controller()) {\n            revert IVault__CallerIsNotTheController();\n        }\n        _;\n    }\n\n    /**\n     * @inheritdoc ERC20\n     */\n    function decimals() public view override returns (uint8) {\n        return _asset.decimals();\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function asset() public view returns (address) {\n        return address(_asset);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function deposit(uint256 assets, address receiver) external virtual override returns (uint256 shares) {\n        if (isProcessingDeposits) revert IVault__ForbiddenWhileProcessingDeposits();\n        shares = previewDeposit(assets);\n\n        if (shares == 0) revert IVault__ZeroShares();\n        _deposit(assets, shares, receiver);\n    }\n\n    function depositWithPermit(\n        uint256 assets,\n        address receiver,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 shares) {\n        if (isProcessingDeposits) revert IVault__ForbiddenWhileProcessingDeposits();\n        shares = previewDeposit(assets);\n\n        if (shares == 0) revert IVault__ZeroShares();\n        IERC20Permit(address(_asset)).permit(msg.sender, address(this), assets, deadline, v, r, s);\n        _deposit(assets, shares, receiver);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function mint(uint256 shares, address receiver) external virtual override returns (uint256 assets) {\n        if (isProcessingDeposits) revert IVault__ForbiddenWhileProcessingDeposits();\n        assets = previewMint(shares);\n        assets = _deposit(assets, shares, receiver);\n    }\n\n    function mintWithPermit(\n        uint256 shares,\n        address receiver,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public returns (uint256 assets) {\n        if (isProcessingDeposits) revert IVault__ForbiddenWhileProcessingDeposits();\n        assets = previewMint(shares);\n        IERC20Permit(address(_asset)).permit(msg.sender, address(this), assets, deadline, v, r, s);\n        assets = _deposit(assets, shares, receiver);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual override returns (uint256 assets) {\n        if (isProcessingDeposits) revert IVault__ForbiddenWhileProcessingDeposits();\n        assets = convertToAssets(shares);\n\n        if (assets == 0) revert IVault__ZeroAssets();\n        (assets, ) = _withdraw(assets, shares, receiver, owner);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external virtual override returns (uint256 shares) {\n        if (isProcessingDeposits) revert IVault__ForbiddenWhileProcessingDeposits();\n        shares = convertToShares(assets);\n        (, shares) = _withdraw(assets, shares, receiver, owner);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function totalAssets() public view virtual returns (uint256);\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function previewDeposit(uint256 assets) public view override returns (uint256 shares) {\n        return convertToShares(assets);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function previewMint(uint256 shares) public view override returns (uint256 assets) {\n        uint256 supply = totalSupply();\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function previewWithdraw(uint256 assets) public view override returns (uint256 shares) {\n        shares = convertToShares(assets);\n        uint256 invertedFee = DENOMINATOR - withdrawFeeRatio();\n        return shares.mulDivUp(DENOMINATOR, invertedFee);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function previewRedeem(uint256 shares) public view override returns (uint256 assets) {\n        assets = convertToAssets(shares);\n        return assets - _getFee(assets);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function convertToShares(uint256 assets) public view override returns (uint256 shares) {\n        uint256 supply = totalSupply();\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function convertToAssets(uint256 shares) public view override returns (uint256 assets) {\n        uint256 supply = totalSupply();\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function maxDeposit(address) public pure override returns (uint256 assets) {\n        return type(uint256).max;\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function maxMint(address) public pure override returns (uint256 shares) {\n        return type(uint256).max;\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function maxWithdraw(address owner) public view override returns (uint256 assets) {\n        return previewRedeem(balanceOf(owner));\n    }\n\n    /**\n     * @inheritdoc IERC4626\n     */\n    function maxRedeem(address owner) public view override returns (uint256 shares) {\n        return balanceOf(owner);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function withdrawFeeRatio() public view override returns (uint256) {\n        uint256 _withdrawFeeRatio = configuration.getParameter(address(this), \"WITHDRAW_FEE_RATIO\");\n        // Fee is limited to MAX_WITHDRAW_FEE\n        return AuxMath.min(_withdrawFeeRatio, MAX_WITHDRAW_FEE);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function idleAssetsOf(address owner) public view virtual returns (uint256) {\n        return depositQueue.balanceOf(owner);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function assetsOf(address owner) public view virtual returns (uint256) {\n        uint256 supply = totalSupply();\n        uint256 shares = balanceOf(owner);\n        uint256 committedAssets = supply == 0 ? 0 : shares.mulDivDown(_asset.balanceOf(address(this)), supply);\n        return convertToAssets(shares) + idleAssetsOf(owner) + committedAssets;\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function totalIdleAssets() public view virtual returns (uint256) {\n        return depositQueue.totalDeposited;\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function depositQueueSize() public view returns (uint256) {\n        return depositQueue.size();\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function controller() public view returns (address) {\n        return configuration.getParameter(address(this), \"VAULT_CONTROLLER\").toAddress();\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function startRound() external virtual onlyRoundStarter returns (uint256 roundId) {\n\n        if (!isProcessingDeposits) revert IVault__NotProcessingDeposits();\n\n        isProcessingDeposits = false;\n\n        _afterRoundStart(processedDeposits);\n        emit StartRound(currentRoundId, processedDeposits);\n        processedDeposits = 0;\n\n        return currentRoundId;\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function endRound() external virtual onlyController {\n        if (isProcessingDeposits) revert IVault__AlreadyProcessingDeposits();\n\n        isProcessingDeposits = true;\n        _afterRoundEnd();\n        _lastEndRound = block.timestamp;\n\n        emit EndRound(currentRoundId++);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function refund() external returns (uint256 assets) {\n        assets = depositQueue.balanceOf(msg.sender);\n        if (assets == 0) revert IVault__ZeroAssets();\n\n        for (uint256 i = 0; i < depositQueue.size(); i++) {\n            DepositQueueLib.DepositEntry memory depositEntry = depositQueue.get(i);\n            if (depositEntry.owner == msg.sender) {\n                depositQueue.remove(i, i + 1);\n                break;\n            }\n        }\n\n        emit DepositRefunded(msg.sender, currentRoundId, assets);\n        _asset.safeTransfer(msg.sender, assets);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function migrate(IVault newVault) external override {\n        if (address(_asset) != newVault.asset() || !configuration.isVaultAllowed(address(newVault))) {\n            revert IVault__MigrationNotAllowed();\n        }\n\n        // Redeem owner assets from this Vault\n        uint256 shares = balanceOf(msg.sender);\n        uint256 assets = redeem(shares, address(this), msg.sender);\n\n        // Deposit assets to `newVault`\n        _asset.safeApprove(address(newVault), assets);\n        newVault.deposit(assets, msg.sender);\n\n        emit Migrated(msg.sender, address(this), address(newVault), assets, shares);\n    }\n\n    /**\n     * @inheritdoc IVault\n     */\n    function processQueuedDeposits(uint256 startIndex, uint256 endIndex) external {\n        if (!isProcessingDeposits) revert IVault__NotProcessingDeposits();\n\n        uint256 _totalAssets = totalAssets();\n        for (uint256 i = startIndex; i < endIndex; i++) {\n            uint256 currentAssets = _totalAssets + processedDeposits;\n            DepositQueueLib.DepositEntry memory depositEntry = depositQueue.get(i);\n            _processDeposit(depositEntry, currentAssets);\n            processedDeposits += depositEntry.amount;\n        }\n        depositQueue.remove(startIndex, endIndex);\n    }\n\n    /** Internals **/\n\n    /**\n     * @notice Mint new shares, effectively representing user participation in the Vault.\n     */\n    function _processDeposit(DepositQueueLib.DepositEntry memory depositEntry, uint256 currentAssets) internal virtual {\n        uint256 supply = totalSupply();\n        uint256 assets = depositEntry.amount;\n        uint256 shares = currentAssets == 0 || supply == 0 ? assets : assets.mulDivUp(supply, currentAssets);\n        _mint(depositEntry.owner, shares);\n        emit DepositProcessed(depositEntry.owner, currentRoundId, assets, shares);\n    }\n\n    /**\n     * @notice Calculate the fee amount on withdraw.\n     */\n    function _getFee(uint256 assets) internal view returns (uint256) {\n        return assets.mulDivDown(withdrawFeeRatio(), DENOMINATOR);\n    }\n\n    /**\n     * @dev Pull assets from the caller and create shares to the receiver\n     */\n    function _deposit(\n        uint256 assets,\n        uint256 shares,\n        address receiver\n    ) internal virtual returns (uint256 depositedAssets) {\n        _spendCap(shares);\n\n        depositQueue.push(DepositQueueLib.DepositEntry(receiver, assets));\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n        _asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        return assets;\n    }\n\n    /**\n     * @dev Burn shares from the caller and release assets to the receiver\n     */\n    function _withdraw(\n        uint256 assets,\n        uint256 shares,\n        address receiver,\n        address owner\n    ) internal virtual returns (uint256 receiverAssets, uint256 receiverShares) {\n        if (msg.sender != owner) {\n            _spendAllowance(owner, msg.sender, shares);\n        }\n\n        _burn(owner, shares);\n        _restoreCap(shares);\n\n        // Apply custom withdraw logic\n        _beforeWithdraw(shares, assets);\n\n        uint256 fee = _getFee(assets);\n        receiverAssets = assets - fee;\n        receiverShares = shares;\n\n        emit Withdraw(msg.sender, receiver, owner, receiverAssets, shares);\n        _asset.safeTransfer(receiver, receiverAssets);\n\n        if (fee > 0) {\n            emit FeeCollected(fee);\n            _asset.safeTransfer(controller(), fee);\n        }\n    }\n\n    /** Hooks **/\n\n    // solhint-disable-next-line no-empty-blocks\n    /* This hook should be implemented in the contract implementation.\n        It will trigger after the shares were burned\n    */\n    function _beforeWithdraw(uint256 shares, uint256 assets) internal virtual {}\n\n    // solhint-disable-next-line no-empty-blocks\n    /* This hook should be implemented in the contract implementation.\n        It will trigger after setting isProcessingDeposits to false\n    */\n    function _afterRoundStart(uint256 assets) internal virtual {}\n\n    // solhint-disable-next-line no-empty-blocks\n    /* This hook should be implemented in the contract implementation.\n        It will trigger after setting isProcessingDeposits to true\n    */\n    function _afterRoundEnd() internal virtual {}\n}"
    },
    {
      "filename": "contracts/vaults/STETHVault.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity 0.8.9;\n\nimport \"./BaseVault.sol\";\n\n/**\n * @title A Vault that use variable weekly yields to buy calls\n * @author Pods Finance\n */\ncontract STETHVault is BaseVault {\n    using SafeERC20 for IERC20Metadata;\n    using AuxMath for uint256;\n    using AuxMath for AuxMath.Fractional;\n    using DepositQueueLib for DepositQueueLib.DepositQueue;\n\n    uint8 public immutable sharePriceDecimals;\n    uint256 public lastRoundAssets;\n    AuxMath.Fractional public lastSharePrice;\n\n    /*\n     @dev investorRatio is the proportion that the weekly yield will be splitted\n     The precision of this number is set by the variable DENOMINATOR. 5000 is equivalent to 50%\n    */\n    uint256 public constant investorRatio = 5000;\n    address public immutable investor;\n\n    event StartRoundData(uint256 indexed roundId, uint256 lastRoundAssets, uint256 sharePrice);\n    event EndRoundData(\n        uint256 indexed roundId,\n        uint256 roundAccruedInterest,\n        uint256 investmentYield,\n        uint256 idleAssets\n    );\n    event SharePrice(uint256 indexed roundId, uint256 startSharePrice, uint256 endSharePrice);\n\n    constructor(\n        IConfigurationManager _configuration,\n        IERC20Metadata _asset,\n        address _investor\n    ) BaseVault(_configuration, _asset) {\n        investor = _investor;\n        sharePriceDecimals = _asset.decimals();\n    }\n\n    /**\n     * @inheritdoc ERC20\n     */\n    function name() public view override returns (string memory) {\n        return string(abi.encodePacked(_asset.symbol(), \" Volatility Vault\"));\n    }\n\n    /**\n     * @inheritdoc ERC20\n     */\n    function symbol() public view override returns (string memory) {\n        return string(abi.encodePacked(_asset.symbol(), \"vv\"));\n    }\n\n    function _afterRoundStart(uint256) internal override {\n        uint256 supply = totalSupply();\n\n        lastRoundAssets = totalAssets();\n        lastSharePrice = AuxMath.Fractional({ numerator: supply == 0 ? 0 : lastRoundAssets, denominator: supply });\n\n        uint256 sharePrice = lastSharePrice.denominator == 0 ? 0 : lastSharePrice.mulDivDown(10**sharePriceDecimals);\n        emit StartRoundData(currentRoundId, lastRoundAssets, sharePrice);\n    }\n\n    function _afterRoundEnd() internal override {\n        uint256 roundAccruedInterest = 0;\n        uint256 endSharePrice = 0;\n        uint256 investmentYield = _asset.balanceOf(investor);\n        uint256 supply = totalSupply();\n\n        if (supply != 0) {\n            roundAccruedInterest = totalAssets() - lastRoundAssets;\n            uint256 investmentAmount = (roundAccruedInterest * investorRatio) / DENOMINATOR;\n\n            // Pulls the yields from investor\n            if (investmentYield > 0) {\n                _asset.safeTransferFrom(investor, address(this), investmentYield);\n            }\n\n            if (investmentAmount > 0) {\n                _asset.safeTransfer(investor, investmentAmount);\n            }\n\n            // End Share price needs to be calculated after the transfers between investor and vault\n            endSharePrice = (totalAssets()).mulDivDown(10**sharePriceDecimals, supply);\n        }\n        uint256 startSharePrice = lastSharePrice.denominator == 0\n            ? 0\n            : lastSharePrice.mulDivDown(10**sharePriceDecimals);\n\n        emit EndRoundData(currentRoundId, roundAccruedInterest, investmentYield, totalIdleAssets());\n        emit SharePrice(currentRoundId, startSharePrice, endSharePrice);\n    }\n\n    function _beforeWithdraw(uint256 shares, uint256) internal override {\n        lastRoundAssets -= shares.mulDivDown(lastSharePrice);\n    }\n\n    /**\n     * @dev See {BaseVault-totalAssets}.\n     */\n    function totalAssets() public view override returns (uint256) {\n        return _asset.balanceOf(address(this)) - totalIdleAssets();\n    }\n\n    /**\n     * @dev Pull assets from the caller and create shares to the receiver\n     */\n    function _deposit(\n        uint256 assets,\n        uint256 shares,\n        address receiver\n    ) internal override returns (uint256 depositedAssets) {\n        _spendCap(shares);\n\n        assets = _stETHTransferFrom(msg.sender, address(this), assets);\n        depositQueue.push(DepositQueueLib.DepositEntry(receiver, assets));\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        return assets;\n    }\n\n    function _withdraw(\n        uint256 assets,\n        uint256 shares,\n        address receiver,\n        address owner\n    ) internal virtual override returns (uint256 receiverAssets, uint256 receiverShares) {\n        if (msg.sender != owner) {\n            _spendAllowance(owner, msg.sender, shares);\n        }\n\n        _burn(owner, shares);\n        _restoreCap(shares);\n\n        // Apply custom withdraw logic\n        _beforeWithdraw(shares, assets);\n\n        uint256 fee = _getFee(assets);\n        receiverAssets = assets - fee;\n        receiverShares = shares;\n\n        emit Withdraw(msg.sender, receiver, owner, receiverAssets, shares);\n\n        _asset.safeTransfer(receiver, receiverAssets);\n\n        if (fee > 0) {\n            emit FeeCollected(fee);\n            _asset.safeTransfer(controller(), fee);\n        }\n    }\n\n    /**\n     * @dev Moves `amount` of stETH from `from` to `to` using the\n     * allowance mechanism.\n     *\n     * Note that due to division rounding, not always is not possible to move\n     * the entire amount, hence transfer is attempted, returning the\n     * `effectiveAmount` transferred.\n     *\n     * For more information refer to: https://docs.lido.fi/guides/steth-integration-guide#1-wei-corner-case\n     */\n    function _stETHTransferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) internal returns (uint256 effectiveAmount) {\n        uint256 balanceBefore = _asset.balanceOf(to);\n        if (from == address(this)) {\n            _asset.safeTransfer(to, amount);\n        } else {\n            _asset.safeTransferFrom(from, to, amount);\n        }\n        return _asset.balanceOf(to) - balanceBefore;\n    }\n}"
    }
  ]
}