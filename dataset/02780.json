{
  "Title": "M-3: Funding Rate calculation is not correct",
  "Content": "# Issue M-3: Funding Rate calculation is not correct \n\nSource: https://github.com/sherlock-audit/2022-11-float-capital-judging/issues/33 \n\n## Found by \nobront\n\n## Summary\n\nAccording to the docs, the Funding Rate is intended to correspond to the gap between long and short positions that the Float Pool is required to make up. However, as its implemented, the `totalFunding` is calculated only on the size of the overbalanced position, leading to some unexpected situations.\n\n## Vulnerability Detail\n\nAccording to the comments, `totalFunding` is meant to be calculated as follows:\n\n> totalFunding is calculated on the notional of between long and short liquidity and 2x long and short liquidity. \n\nThis makes sense. The purpose of the funding rate is to compensate the Float Pool for the liquidity provided to balance the market.\n\nHowever, the implementation of this function does not accomplish this. Instead, `totalFunding` is based only on the size of the `overbalancedValue`:\n\n```solidity\nuint256 totalFunding = (2 * overbalancedValue * fundingRateMultiplier * oracleManager.EPOCH_LENGTH()) / (365.25 days * 10000);\n```\nThis can be summarized as `2 * overbalancedValue * funding rate percentage * epochs / yr`.\n\nThis formula can cause problems, because the size of the overbalanced value doesn't necessarily correspond to the balancing required for the Float Pool. \n\nFor these examples, let's set:\n- `fundingRateMultiplier = 100` (1%)\n- `EPOCH_LENGTH() = 3.6525 days` (1% of a year)\n\nSITUATION A:\n- Overbalanced: LONG\n- Long Effective Liquidity: 1_000_000 ether\n- Short Effective Liquidity: 999_999 ether\n- `totalFunding = 2 * 1_000_000 ether * 1% * 1% = 200 ether`\n- Amount of balancing supplied by Float = 1mm - 999,999 = 1 ether\n\nSITUATION B:\n- Overbalanced: LONG\n- Long Effective Liquidity: 1_000 ether\n- Short Effective Liquidity: 100 ether\n- `totalFunding = 2 * 1_000 ether * 1% * 1% = 0.2 ether`\n- Amount of balancing supplied by Float = 1000 - 100 = 900 ether\n\nWe can see that in Situation B, Float supplied 900X more liquidity to the system, and earned 1000X less fees.\n\n## Impact\n\nFunding Rates will not accomplish the stated objective, and will serve to incentivize pools that rely heavily on Float for balancing, while disincentivizing large, balanced markets.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-float-capital/blob/main/contracts/market/template/MarketCore.sol#L46-L58\n\n## Tool used\n\nManual Review, Foundry\n\n## Recommendation\n\nAdjust the `totalFunding` formula to represent the stated outcome. A simple example of how that might be accomplished is below, but I'm sure there are better implementations:\n\n```solidity\nuint256 totalFunding = ((overbalancedValue - underbalancedValue) * fundingRateMultiplier * oracle.EPOCH_LENGTH()) / (365.25 days * 10_000);\n```\n\n## Discussion\n\n**JasoonS**\n\nIt is acknowledged that this funding rate equation is just a placeholder for now.\n\nThis typo of funding rate equation is desired if we want to incentivise market makers to always keep liquidity in the Float pool regardless of market balance.\n\nOur initial implementation was EXACTLY the same as what you wrote in the recommendation (and it is exactly what has been deployed live for the alpha version of the protocol for the last year). But after talks with market makers it became clear that they want 'guaranteed' returns of sorts even if the market is balanced to keep their funds there.\n\nWe have (since audit) refined an updated equation that is a hybrid of the two extremes. This is some of the core logic that we'll have to keep iterating on to make float work. It is the magic sauce.\n\nApologies for that mistake in the comments. The comments also say: `This modular function is logical but naive implementation that will likely change somewhat upon more indepth modelling results that are still pending.`\n\nTLDR - this is as intended and the shortcomings are known.\n\n**Evert0x**\n\nDowngrading to informational as the docs on which this issue is based also indicate that it's a placeholder. Issue doesn't make a case for med/high in case the formula makes it to production.\n\n**zobront**\n\nEscalate for 5 USDC\n\nIt seems like quite a stretch to claim that the current implementation is a placeholder. The exact quote in the docs is:\n\n> This modular function is logical but naive implementation that will likely change somewhat upon more indepth modelling results that are still pending.\n\nThis clearly states that the function is supposed to accomplish what they state it will accomplish. They acknowledge it may change, but specifically lay out what the function should do and claim that it does it.\n\nIf saying “this is right but may change somewhat” disqualifies valid issues, then anything that says that should not be in scope. So I feel it is very clear that the report does find a real issue in the code.\n\nNow, I understand that if this was just an issue with the docs, it’d be informational. That’s fair.\n\nBut the actual implementation isn’t an “alternative”. It’s a totally invalid way to implement the function that would cause harm to the platform.\n\nThe goal of the function is to ensure the Float pool is compensated for the real risk that it is taking on. If it is substantially underpaid (as it would be in many cases with the erroneous formula), it can easily cause the pool to lose funds. The formula doesn't accomplish the objective that is needed from it, and it puts the protocol's own funds at risk.\n\nThe fact that, since the audit, they have updated the equation seems to imply that they agree that the implementation in the audit code was untenable. \n\nSo it seems clear to me that:\na) the issue is a real mismatch between explicitly intended behavior and the code\nb) it would cause real harm if it was deployed as written\n\nTherefore, I believe a severity of Medium is justified.\n\n**sherlock-admin**\n\n > Escalate for 5 USDC\n> \n> It seems like quite a stretch to claim that the current implementation is a placeholder. The exact quote in the docs is:\n> \n> > This modular function is logical but naive implementation that will likely change somewhat upon more indepth modelling results that are still pending.\n> \n> This clearly states that the function is supposed to accomplish what they state it will accomplish. They acknowledge it may change, but specifically lay out what the function should do and claim that it does it.\n> \n> If saying “this is right but may change somewhat” disqualifies valid issues, then anything that says that should not be in scope. So I feel it is very clear that the report does find a real issue in the code.\n> \n> Now, I understand that if this was just an issue with the docs, it’d be informational. That’s fair.\n> \n> But the actual implementation isn’t an “alternative”. It’s a totally invalid way to implement the function that would cause harm to the platform.\n> \n> The goal of the function is to ensure the Float pool is compensated for the real risk that it is taking on. If it is substantially underpaid (as it would be in many cases with the erroneous formula), it can easily cause the pool to lose funds. The formula doesn't accomplish the objective that is needed from it, and it puts the protocol's own funds at risk.\n> \n> The fact that, since the audit, they have updated the equation seems to imply that they agree that the implementation in the audit code was untenable. \n> \n> So it seems clear to me that:\n> a) the issue is a real mismatch between explicitly intended behavior and the code\n> b) it would cause real harm if it was deployed as written\n> \n> Therefore, I believe a severity of Medium is justified.\n\nYou've created a valid escalation for 5 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation accepted. \n\n\n\n**sherlock-admin**\n\n> Escalation accepted. \n> \n> \n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/15",
  "Code": [
    {
      "filename": "contracts/market/template/MarketCore.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.17;\n\nimport \"./MarketStorage.sol\";\n\n/// @title Main market contract with all the main functionality\ncontract MarketCore is AccessControlledAndUpgradeableModifiers, IMarketCommon, IMarketCore, MarketStorage, ProxyNonPayable {\n  using SafeERC20 for IERC20;\n  using MathUintFloat for uint256;\n  using MathIntFloat for int256;\n\n  /*╔═════════════════════════════╗\n    ║          MODIFIERS          ║\n    ╚═════════════════════════════╝*/\n\n  function gemCollectingModifierLogic(address user) internal {\n    IGEMS(gems).gm(user);\n  }\n\n  modifier gemCollecting(address user) {\n    gemCollectingModifierLogic(user);\n    _;\n  }\n\n  modifier checkMarketNotDeprecated() {\n    if (marketDeprecated) revert MarketDeprecated();\n    _;\n  }\n\n  /*╔═══════════════════════════════╗\n    ║     UPDATING SYSTEM STATE     ║\n    ╚═══════════════════════════════╝*/\n\n  /// @notice This calculates the value transfer from the overbalanced to underbalanced side (i.e. the funding rate)\n  /// This is a further incentive measure to balanced markets. This may be present on some and not other pool token markets.\n  /// @param overbalancedIndex poolType with more liquidity.\n  /// @param overbalancedValue Side with more liquidity.\n  /// @param underbalancedValue Side with less liquidity.\n  /// @return fundingAmount The amount the overbalanced side needs to pay the underbalanced.\n  function _calculateFundingAmount(\n    uint256 overbalancedIndex,\n    uint256 overbalancedValue,\n    uint256 underbalancedValue\n  ) internal view returns (int256[2] memory fundingAmount) {\n    /*\n    totalFunding is calculated on the notional of between long and short liquidity and 2x long and short liquidity. \n    The notional on which funding is calculated increaseas as the imbalance increases.\n    The split of funding paid between underbalanced and overbalanced is 50/50 when long = short liq and moves\n    linearly to 100% paid by the overbalanced beyong the point where liquidity is 2:1 ratio\n    (liquidity in overbalanced side is more than double liquidity in underbalanced side)\n    This modular function is logical but naive implementation that will likely change somewhat upon more indepth \n    modelling results that are still pending. \n    */\n\n    // fundingRateMultiplier is in basis points so need to divide by 10,000.\n    uint256 totalFunding = (2 * overbalancedValue * fundingRateMultiplier * oracleManager.EPOCH_LENGTH()) / (365.25 days * 10000);\n\n    uint256 overbalancedFunding = Math.min(\n      totalFunding,\n      (totalFunding * ((2 * overbalancedValue) - underbalancedValue)) / (overbalancedValue + underbalancedValue)\n    );\n    uint256 underbalancedFunding = totalFunding - overbalancedFunding;\n\n    if (overbalancedIndex == SHORT_TYPE) fundingAmount = [-int256(overbalancedFunding), int256(underbalancedFunding)];\n    else fundingAmount = [-int256(underbalancedFunding), int256(overbalancedFunding)];\n  }\n\n  function _getValueChangeAndFunding(\n    uint256 effectiveValueLong,\n    uint256 effectiveValueShort,\n    int256 previousPrice,\n    int256 currentPrice\n  ) internal view returns (int256 floatPoolLeverage, ValueChangeAndFunding memory params) {\n    uint256 floatPoolLiquidity = pools[PoolType.FLOAT][0].value;\n    // We set the floating tranche leverage to the exact leverage that ensure effectiveValueLong = effectiveValueShort when taking\n    //     into the floating liquidity added the underbalanced side.\n    floatPoolLeverage = (int256(effectiveValueShort) - int256(effectiveValueLong)).div(int256(floatPoolLiquidity));\n\n    // If there is a large diff between long and short liquidity or little floatPoolLiquidity, then the float pool leverage\n    // may be set to a very high amount. Here we cap it such that floatPoolLeverage is between -5x and 5x.\n    // This give Market Makers who deposit in the floatPool certain garuntees on the maximum delta they will be exposed to.\n    if (floatPoolLeverage > 5e18) floatPoolLeverage = 5e18;\n    else if (floatPoolLeverage < -5e18) floatPoolLeverage = -5e18;\n\n    // NOTE - we are dividing by previous price before multiplying this value again in _rebalancePoolsAndExecuteBatchedActions - this means some accuracy is lost - however we deem this insignificant.\n    int256 priceMovement_e18 = (currentPrice - previousPrice).div(previousPrice);\n\n    // A really large price movement could bankrupt a 5x leveraged pool. We contrain the price movement to a max percentage\n    // that ensure no pool will be underwater. This limimts the gain/loss on any single price movement. In practice\n    // maxPercentChange is about 20% for a 5x pool, and we don't expect to see 20% price changes in one epoch, but if we do,\n    // The system is able to tolerate it.\n    if (priceMovement_e18 > maxPercentChange) priceMovement_e18 = maxPercentChange;\n    else if (priceMovement_e18 < -maxPercentChange) priceMovement_e18 = -maxPercentChange;\n\n    // Value change (amount to transfer between Short and Long pools) is based on the price movement multiplied by the\n    // Notional value of the smaller side (long or short). Given the float pool should in most cases make the liquidity of long and short\n    // exactly equal, the only case where long and short liquidity is different is when the float pool leverage is constrained to its 5x or -5x cap.\n    // If this is the case, the side with greater liquidity will have a reduced exposure or delta of their position. I.e. If $1m long and $500k short,\n    // Longs will only get 50% ($500k) long exposure.\n    if (effectiveValueShort > effectiveValueLong) {\n      params.fundingAmount = _calculateFundingAmount(SHORT_TYPE, effectiveValueShort, effectiveValueLong);\n      params.valueChange = priceMovement_e18.mul(int256(effectiveValueLong + uint256(floatPoolLeverage).mul(floatPoolLiquidity)));\n      params.underBalancedSide = LONG_TYPE;\n    } else {\n      params.fundingAmount = _calculateFundingAmount(LONG_TYPE, effectiveValueLong, effectiveValueShort);\n      params.valueChange = priceMovement_e18.mul(int256(effectiveValueShort + uint256(-floatPoolLeverage).mul(floatPoolLiquidity)));\n      params.underBalancedSide = SHORT_TYPE;\n    }\n  }\n\n  /// @notice Reblances the pool given the epoch execution information and can also perform batched actions from the epoch.\n  /// @param epochIndex The index of the epoch to execute\n  /// @param totalEffectiveLiquidityPoolType Effective liquidity of short (0) and long (1) pools\n  /// @param params Compact struct with all parameters needed for rebalance\n  /// @return nextTotalEffectiveLiquidityPoolType Updated short and long liquidities\n  /// @return poolStates Compact struct of pool states after rebalance\n  function _rebalancePoolsAndExecuteBatchedActions(\n    uint32 epochIndex,\n    uint128[2] memory totalEffectiveLiquidityPoolType,\n    int256 floatPoolLeverage,\n    ValueChangeAndFunding memory params\n  ) internal returns (uint128[2] memory nextTotalEffectiveLiquidityPoolType, PoolState[] memory poolStates) {\n    poolStates = new PoolState[](_totalNumberOfPoolTiers);\n    uint8 currentPoolStateIndex;\n\n    // Correctly account for liquidity in long and short by adding the float liquidity to the underbalanced side.\n    totalEffectiveLiquidityPoolType[params.underBalancedSide] += uint128(uint256(pools[PoolType.FLOAT][0].value).mul(floatPoolLeverage.abs()));\n\n    // For every pool (long pools, short pools and float pool)\n    // 1) Adjust poolValue based on price movements and funding (and fees for float pool)\n    // 2) Batch process all new entries and exits in pool\n    for (uint256 poolType = SHORT_TYPE; poolType < POOL_TYPE_UPPER_BOUND; ++poolType) {\n      for (uint256 poolTier = 0; poolTier < _numberOfPoolsOfType[poolType]; ++poolTier) {\n        int256 poolValue = int256(pools[PoolType(poolType)][poolTier].value);\n        PoolFixedConfig memory poolFixedConfig = pools[PoolType(poolType)][poolTier].fixedConfig;\n\n        if (poolType != FLOAT_TYPE) {\n          // To correctly apportion funding owed for the underblananced tiers, we need to remove the float liquidity contribution\n          int256 actualTotalEffectiveLiquidityForPoolType = int256(\n            (uint256(totalEffectiveLiquidityPoolType[poolType]) -\n              (poolType == params.underBalancedSide ? uint256(pools[PoolType.FLOAT][0].value).mul(floatPoolLeverage.abs()) : 0))\n          );\n\n          // Long and short pools both pay funding\n          poolValue +=\n            (((poolValue * poolFixedConfig.leverage * params.valueChange) / int128(totalEffectiveLiquidityPoolType[poolType])) -\n              ((poolValue * poolFixedConfig.leverage * params.fundingAmount[poolType]) / (actualTotalEffectiveLiquidityForPoolType))) /\n            1e18;\n        } else {\n          // Float pool recieves all funding and fees.\n          poolValue +=\n            ((poolValue * floatPoolLeverage * params.valueChange) /\n              (int256(uint256(totalEffectiveLiquidityPoolType[params.underBalancedSide])) * 1e18)) +\n            -params.fundingAmount[SHORT_TYPE] + // funding value is negative for short side (double negative to add it)\n            params.fundingAmount[LONG_TYPE] +\n            int256(feesToDistribute[epochIndex & 1]);\n\n          feesToDistribute[epochIndex & 1] = 0;\n        }\n\n        uint256 tokenSupply = IPoolToken(poolFixedConfig.token).totalSupply();\n        uint256 price = uint256(poolValue).div(tokenSupply);\n\n        // All entries and exits to the pool are processed at latest price based on newly calculated poolValue\n        poolValue += _processAllBatchedEpochActions(epochIndex, PoolType(poolType), poolTier, price, poolFixedConfig.token);\n\n        // We calculate the new total liquidity always excluding the floating tranche.\n        if (poolType != FLOAT_TYPE)\n          nextTotalEffectiveLiquidityPoolType[poolType] += uint128(uint256(poolValue).mul(int256(poolFixedConfig.leverage).abs()));\n\n        pools[PoolType(poolType)][poolTier].value = uint256(poolValue);\n\n        // Token price snapshot for this epoch is used to calculate amount individual token allocation retrospectively for entrants/exits\n        poolToken_priceSnapshot[epochIndex][PoolType(poolType)][poolTier] = price;\n\n        // This structure is purely to emit event info as easily as possible for the indexer.\n        poolStates[currentPoolStateIndex++] = PoolState({\n          poolId: MarketHelpers.packPoolId(PoolType(poolType), uint8(poolTier)),\n          tokenPrice: price,\n          value: poolValue\n        });\n      }\n    }\n  }\n\n  /// @notice System state update function that verifies (instead of trying to find) oracle prices\n  /// @param oracleRoundIdsToExecute The oracle prices that will be the prices for each epoch\n  function updateSystemStateUsingValidatedOracleRoundIds(uint80[] memory oracleRoundIdsToExecute) external checkMarketNotDeprecated {\n    uint32 latestExecutedEpochIndex = epochInfo.latestExecutedEpochIndex;\n    (int256 previousPrice, int256[] memory epochPrices) = oracleManager.validateAndReturnMissedEpochInformation(\n      latestExecutedEpochIndex,\n      epochInfo.latestExecutedOracleRoundId,\n      oracleRoundIdsToExecute\n    );\n\n    uint256 numberOfEpochsToExecute = epochPrices.length;\n\n    uint128[2] memory totalEffectiveLiquidityPoolType = effectiveLiquidityForPoolType;\n\n    for (uint256 i = 0; i < numberOfEpochsToExecute; ) {\n      /* i is incremented later in scope*/\n      (int256 floatPoolLeverage, ValueChangeAndFunding memory rebalanceParams) = _getValueChangeAndFunding(\n        totalEffectiveLiquidityPoolType[LONG_TYPE],\n        totalEffectiveLiquidityPoolType[SHORT_TYPE],\n        // this is the previous execution price, not the previous oracle update price\n        previousPrice,\n        epochPrices[i]\n      );\n\n      previousPrice = epochPrices[i];\n\n      PoolState[] memory poolStates;\n      (totalEffectiveLiquidityPoolType, poolStates) = _rebalancePoolsAndExecuteBatchedActions(\n        latestExecutedEpochIndex + uint32(++i),\n        totalEffectiveLiquidityPoolType,\n        floatPoolLeverage,\n        rebalanceParams\n      );\n\n      emit EpochUpdated(latestExecutedEpochIndex + uint32(i), previousPrice, rebalanceParams.valueChange, rebalanceParams.fundingAmount, poolStates);\n    }\n\n    // Saving the final state of liquidity and info once all epochs have been executed.\n    // In practive, keepers should ensure that the above loop length is only ever 1,\n    // and we are never catching up multiple epochs. This arcitecture is built such that the\n    // the system can gracefully handle missed upkeep fairly.\n    effectiveLiquidityForPoolType = totalEffectiveLiquidityPoolType;\n    epochInfo = EpochInfo({\n      latestExecutedEpochIndex: latestExecutedEpochIndex + uint32(numberOfEpochsToExecute),\n      latestExecutedOracleRoundId: oracleRoundIdsToExecute[oracleRoundIdsToExecute.length - 1]\n    });\n  }\n\n  /*╔═══════════════════════════╗\n    ║       MINT POSITION       ║\n    ╚═══════════════════════════╝*/\n\n  /// @notice Calculates the fees for the mint amount depending on the market\n  /// @param amount Amount of payment tokens in that token's lowest denomination for which to mint pool token assets at next price.\n  function _calculateStabilityFees(uint256 amount) internal view returns (uint256 amountFees) {\n    // stability fee is based on effectiveLiquidity added (takes into account leverage)\n    amountFees = (amount * stabilityFee_basisPoints) / (10000);\n  }\n\n  /// @notice Allows users to mint pool token assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.\n  /// @dev We have to check market not deprecated after system state update because that is the function that determines whether the market should be deprecated.\n  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint pool token assets at next price.\n  /// @param poolType an enum representing the type of poolTier for eg. LONG or SHORT.\n  /// @param poolTier leveraged poolTier index\n  function _mint(\n    uint112 amount,\n    address user,\n    PoolType poolType,\n    uint256 poolTier\n  ) internal {\n    // ASIDE: This check also checks that the poolType is valid - since if it is invalid it will be zero - and no uint can be less than zero\n    if (uint256(poolTier) >= _numberOfPoolsOfType[uint256(poolType)]) revert InvalidPool();\n\n    if (mintingPaused) revert MintingPaused();\n\n    // Due to get amount of payment token calculation we must have amount * 1e18 > poolTokenPriceInPaymentTokens otherwise we get 0\n    // In fact, all the decimals of amount * 1e18 that are less than poolTokenPriceInPaymentTokens get cut off\n    if (amount < 1e18) revert InvalidActionAmount(amount);\n\n    IERC20(paymentToken).safeTransferFrom(msg.sender, liquidityManager, amount);\n\n    uint256 fees = _calculateStabilityFees(uint256(amount).mul(int256(pools[poolType][poolTier].fixedConfig.leverage).abs()));\n    amount -= uint112(fees);\n\n    uint32 currentEpoch = uint32(oracleManager.getCurrentEpochIndex());\n\n    // Actions cannot take place if upkeep has fallen behind and there are already 2 oustanding epochs needing to be executed\n    if (currentEpoch > epochInfo.latestExecutedEpochIndex + 2)\n      revert MarketStale({currentEpoch: currentEpoch, latestExecutedEpoch: epochInfo.latestExecutedEpochIndex});\n\n    // Before minting we ensure user recieves tokens from any already executed mints in previous epochs.\n    // This ensures the userAction_depositPaymentToken[user][poolType][poolTier] struct will be up to date\n    // and correctly handle to new mint.\n    settlePoolUserMints(user, poolType, poolTier);\n\n    UserAction memory userAction = userAction_depositPaymentToken[user][poolType][poolTier];\n\n    /// NOTE: userAction.amount > 0 IFF userAction.correspondingEpoch <= currentEpoch - this check is redundant for safety.\n    if (userAction.amount > 0 && userAction.correspondingEpoch < currentEpoch) {\n      // This case occurs when a user minted in the previous epoch and upkeep has still not yet\n      // occured and therefore this previous order has not been processed.\n      // This is likely to happen if the user mints early on in a new epoch when enough time has not\n      // passed (see MEWT) for the previous epoch to be executed.\n      userAction.nextEpochAmount += amount;\n    } else {\n      userAction.amount += amount;\n      userAction.correspondingEpoch = currentEpoch;\n    }\n\n    // NOTE: `currentEpoch & 1` and `currentEpoch % 2` are equivalent, but the former is more efficient using bitwise operations.\n    // Since there can only ever be oustanding mint and redeem orders in two consecutive epochs (cannot have oustanding orders in 3 epochs etc)\n    // We use an odd even batch scheme to easily batch orders.\n    pools[poolType][poolTier].batchedAmount[currentEpoch & 1].paymentToken_deposit += amount;\n    feesToDistribute[currentEpoch & 1] += fees;\n\n    userAction_depositPaymentToken[user][poolType][poolTier] = userAction;\n\n    emit Deposit(MarketHelpers.packPoolId(poolType, uint8(poolTier)), amount, fees, user, currentEpoch);\n  }\n\n  /// @notice Allows users to mint long pool token assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @param poolTier leveraged poolTier index\n  /// @param amount Amount of payment tokens in that token's lowest denomination for which to mint pool token assets at next price.\n  function mintLong(uint256 poolTier, uint112 amount) external gemCollecting(msg.sender) {\n    _mint(amount, msg.sender, PoolType.LONG, poolTier);\n  }\n\n  /// @notice Allows users to mint short pool token assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @param poolTier leveraged poolTier index\n  /// @param amount Amount of payment tokens in that token's lowest denomination for which to mint pool token assets at next price.\n  function mintShort(uint256 poolTier, uint112 amount) external gemCollecting(msg.sender) {\n    _mint(amount, msg.sender, PoolType.SHORT, poolTier);\n  }\n\n  /// @notice Allows users to mint float pool token assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @param amount Amount of payment tokens in that token's lowest denomination for which to mint pool token assets at next price.\n  function mintFloatPool(uint112 amount) external {\n    _checkRole(FLOAT_POOL_ROLE, msg.sender);\n    _mint(amount, msg.sender, PoolType.FLOAT, 0); // There is always only one float pool at poolTier index 0\n  }\n\n  /// @notice Allows mint long pool token assets for a market on behalf of some user. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @param poolTier leveraged poolTier index\n  /// @param amount Amount of payment tokens in that token's lowest denomination for which to mint pool token assets at next price.\n  /// @param user Address of the user.\n  function mintLongFor(\n    uint256 poolTier,\n    uint112 amount,\n    address user\n  ) external override gemCollecting(user) {\n    _mint(amount, user, PoolType.LONG, poolTier);\n  }\n\n  /// @notice Allows mint short pool token assets for a market on behalf of some user. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @param poolTier leveraged poolTier index\n  /// @param amount Amount of payment tokens in that token's lowest denomination for which to mint pool token assets at next price.\n  /// @param user Address of the user.\n  function mintShortFor(\n    uint256 poolTier,\n    uint112 amount,\n    address user\n  ) external gemCollecting(user) {\n    _mint(amount, user, PoolType.SHORT, poolTier);\n  }\n\n  /*╔═══════════════════════════╗\n    ║       REDEEM POSITION     ║\n    ╚═══════════════════════════╝*/\n\n  /// @notice Allows users to mint pool token assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.\n  /// @dev We have to check market not deprecated after system state update because that is the function that determines whether the market should be deprecated.\n  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint pool token assets at next price.\n  /// @param poolType an enum representing the type of poolTier for eg. LONG or SHORT.\n  /// @param poolTier leveraged poolTier index\n  function _redeem(\n    uint112 amount,\n    address user,\n    PoolType poolType,\n    uint256 poolTier\n  ) internal checkMarketNotDeprecated {\n    // In this function, amount refers to the amount of poolToken.\n    // In the _mint function amount refers to the amount of paymentToken\n    // This function is very similar to _mint. See _mint for comprehensive commenting\n    if (amount < 1e12) revert InvalidActionAmount(amount);\n\n    uint32 currentEpoch = uint32(oracleManager.getCurrentEpochIndex());\n    if (currentEpoch > epochInfo.latestExecutedEpochIndex + 2)\n      revert MarketStale({currentEpoch: currentEpoch, latestExecutedEpoch: epochInfo.latestExecutedEpochIndex});\n\n    settlePoolUserRedeems(user, poolType, poolTier);\n\n    //slither-disable-next-line unchecked-transfer\n    // If an invalid poolType and poolTier is passed, this will revert.\n    IPoolToken(pools[poolType][poolTier].fixedConfig.token).transferFrom(user, address(this), amount);\n\n    UserAction memory userAction = userAction_redeemPoolToken[user][poolType][poolTier];\n\n    if (userAction.amount > 0 && userAction.correspondingEpoch < currentEpoch) {\n      userAction.nextEpochAmount += amount;\n    } else {\n      userAction.amount += amount;\n      userAction.correspondingEpoch = currentEpoch;\n    }\n\n    // NOTE: `currentEpoch & 1` and `currentEpoch % 2` are equivalent, but the former is more efficient using bitwise operations.\n    pools[poolType][poolTier].batchedAmount[currentEpoch & 1].poolToken_redeem += amount;\n\n    userAction_redeemPoolToken[user][poolType][poolTier] = userAction;\n\n    emit Redeem(MarketHelpers.packPoolId(poolType, uint8(poolTier)), amount, user, currentEpoch);\n  }\n\n  /// @notice Allows users to mint long pool token assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.\n  /// @param poolTier leveraged poolTier index\n  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint pool token assets at next price.\n  function redeemLong(uint256 poolTier, uint112 amount) external gemCollecting(msg.sender) {\n    _redeem(amount, msg.sender, PoolType.LONG, poolTier);\n  }\n\n  /// @notice Allows users to redeem short pool token assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.\n  /// @param poolTier leveraged poolTier index\n  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to redeem pool token assets at next price.\n  function redeemShort(uint256 poolTier, uint112 amount) external gemCollecting(msg.sender) {\n    _redeem(amount, msg.sender, PoolType.SHORT, poolTier);\n  }\n\n  /// @notice Allows users to redeem float pool token assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.\n  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to redeem pool token assets at next price.\n  function redeemFloatPool(uint112 amount) external {\n    _redeem(amount, msg.sender, PoolType.FLOAT, 0);\n  }\n\n  /*╔═════════════════════╗\n    ║  USER SETTLEMENTS   ║\n    ╚═════════════════════╝*/\n\n  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their mints during that epoch to that user.\n  /// @param user Address of the user.\n  /// @param poolType an enum representing the type of poolTier for eg. LONG or SHORT.\n  /// @param poolTier leveraged poolTier index\n  function settlePoolUserMints(\n    address user,\n    PoolType poolType,\n    uint256 poolTier\n  ) public {\n    /*\n      NOTE: please reflect any changes made to this function to the `getUsersConfirmedButNotSettledPoolTokenBalance` function too.\n\n     Users can have mints in two consecutive epochs (with both not yet being executed). In this case we say both there primary,\n     and seconday order slot are full. Once upkeep has been performed on those epochs, this function can be called at a later stage,\n     asynchronusly (generally when a user mints again or uses their tokens), in order to calculate and send the tokens owed to the user\n     based on their mints in the primiary and secondary slot (the secondary slot may not always exist).\n\n     Corresponding epoch refers to the epoch associated with the primary slot action.\n    */\n\n    UserAction memory userAction = userAction_depositPaymentToken[user][poolType][poolTier];\n\n    // Case if the primary order can be executed.\n    if (userAction.correspondingEpoch != 0 && userAction.correspondingEpoch <= epochInfo.latestExecutedEpochIndex) {\n      uint256 poolToken_price = poolToken_priceSnapshot[userAction.correspondingEpoch][poolType][poolTier];\n      uint256 amountPoolTokenToMint = uint256(userAction.amount).div(poolToken_price);\n\n      // If secondary order exists\n      if (userAction.nextEpochAmount > 0) {\n        uint32 secondaryOrderEpoch = userAction.correspondingEpoch + 1;\n\n        // If its possible to also execute the secondary order slot\n        if (secondaryOrderEpoch <= epochInfo.latestExecutedEpochIndex) {\n          // then also execute\n          poolToken_price = poolToken_priceSnapshot[secondaryOrderEpoch][poolType][poolTier];\n          amountPoolTokenToMint += uint256(userAction.nextEpochAmount).div(poolToken_price);\n\n          userAction.amount = 0;\n          userAction.correspondingEpoch = 0;\n        } else {\n          // If secondary order cannot be executed, bump it to the primary slot.\n          userAction.amount = userAction.nextEpochAmount;\n          userAction.correspondingEpoch = secondaryOrderEpoch;\n        }\n        // has to zero as either executed or bumped to primary slot\n        userAction.nextEpochAmount = 0;\n      } else {\n        // If user has no pending mints then simply wipe\n        userAction.amount = 0;\n        userAction.correspondingEpoch = 0;\n      }\n\n      //slither-disable-next-line unchecked-transfer\n      IPoolToken(pools[poolType][poolTier].fixedConfig.token).transfer(user, amountPoolTokenToMint);\n\n      userAction_depositPaymentToken[user][poolType][poolTier] = userAction;\n\n      emit ExecuteEpochSettlementMintUser(\n        MarketHelpers.packPoolId(poolType, uint8(poolTier)),\n        user,\n        epochInfo.latestExecutedEpochIndex,\n        amountPoolTokenToMint\n      );\n    }\n  }\n\n  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their redeems during that epoch to that user.\n  /// @param user Address of the user.\n  /// @param poolType an enum representing the type of poolTier for eg. LONG or SHORT.\n  /// @param poolTier leveraged poolTier index\n  function settlePoolUserRedeems(\n    address user,\n    PoolType poolType,\n    uint256 poolTier\n  ) public {\n    // Functions almost identically to settlePoolUserMints. See settlePoolUserMints for comprehensive comments.\n    UserAction memory userAction = userAction_redeemPoolToken[user][poolType][poolTier];\n\n    // Case if the primary order can be executed.\n    if (userAction.amount > 0 && userAction.correspondingEpoch <= epochInfo.latestExecutedEpochIndex) {\n      uint256 poolToken_price = poolToken_priceSnapshot[userAction.correspondingEpoch][poolType][poolTier];\n\n      uint256 amountPaymentTokenToSend = uint256(userAction.amount).mul(poolToken_price);\n\n      if (userAction.nextEpochAmount > 0) {\n        uint32 secondaryOrderEpoch = userAction.correspondingEpoch + 1;\n\n        if (secondaryOrderEpoch <= epochInfo.latestExecutedEpochIndex) {\n          poolToken_price = poolToken_priceSnapshot[secondaryOrderEpoch][poolType][poolTier];\n          amountPaymentTokenToSend += uint256(userAction.nextEpochAmount).mul(poolToken_price);\n\n          userAction.amount = 0;\n          userAction.correspondingEpoch = 0;\n        } else {\n          userAction.amount = userAction.nextEpochAmount;\n          userAction.correspondingEpoch = secondaryOrderEpoch;\n        }\n        // has to zero as either executed or bumped to primary slot\n        userAction.nextEpochAmount = 0;\n      } else {\n        // If user has no pending redeems then simply wipe\n        userAction.amount = 0;\n        userAction.correspondingEpoch = 0;\n      }\n\n      userAction_redeemPoolToken[user][poolType][poolTier] = userAction;\n\n      ILiquidityManager(liquidityManager).transferPaymentTokensToUser(user, amountPaymentTokenToSend);\n\n      emit ExecuteEpochSettlementRedeemUser(\n        MarketHelpers.packPoolId(poolType, uint8(poolTier)),\n        user,\n        epochInfo.latestExecutedEpochIndex,\n        amountPaymentTokenToSend\n      );\n    }\n  }\n\n  /*╔═══════════════════╗\n    ║   BATCH ACTIONS   ║\n    ╚═══════════════════╝*/\n\n  /// @notice Either mints or burns pool token supply.\n  /// @param poolToken Address of the pool token.\n  /// @param changeInPoolTokensTotalSupply Positive indicates amount to be minted and negative indicates amount to be burned.\n  function _handleChangeInPoolTokensTotalSupply(address poolToken, int256 changeInPoolTokensTotalSupply) internal {\n    if (changeInPoolTokensTotalSupply > 0) {\n      IPoolToken(poolToken).mint(address(this), uint256(changeInPoolTokensTotalSupply));\n    } else if (changeInPoolTokensTotalSupply < 0) {\n      IPoolToken(poolToken).burn(uint256(-changeInPoolTokensTotalSupply));\n    }\n  }\n\n  /// @notice For a given pool, updates the value depending on the batched deposits and redeems that took place during the epoch\n  /// @param associatedEpochIndex Index of epoch where the batched actions were performed.\n  /// @param poolType an enum representing the type of poolTier for eg. LONG or SHORT.\n  /// @param poolTier leveraged poolTier index.\n  /// @param price Price of the pool token.\n  function _processAllBatchedEpochActions(\n    uint256 associatedEpochIndex,\n    PoolType poolType,\n    uint256 poolTier,\n    uint256 price,\n    address poolToken\n  ) internal returns (int256 changeInMarketValue_inPaymentToken) {\n    // QUESTION: is it worth the gas saving this storage pointer - we only use 'pool' twice in this function.\n    Pool storage pool = pools[poolType][poolTier];\n\n    BatchedActions memory batch = pool.batchedAmount[associatedEpochIndex & 1];\n\n    // Only if mints or redeems exist is it necessary to adjust supply and collateral.\n    if (batch.paymentToken_deposit > 0 || batch.poolToken_redeem > 0) {\n      changeInMarketValue_inPaymentToken = int128(batch.paymentToken_deposit) - int256(uint256(batch.poolToken_redeem).mul(price));\n\n      int256 changeInSupply_poolToken = int256(uint256(batch.paymentToken_deposit).div(price)) - int128(batch.poolToken_redeem);\n\n      pool.batchedAmount[associatedEpochIndex & 1] = BatchedActions(0, 0);\n\n      _handleChangeInPoolTokensTotalSupply(poolToken, changeInSupply_poolToken);\n    }\n  }\n\n  /*╔═══════════════════════════╗\n    ║ DEPRECATED MARKET ACTIONS ║\n    ╚═══════════════════════════╝*/\n\n  /*\n  In the case that upkeep contiously fails (could be because of chainlink failing, the chain going offline etc.),\n  which will most likely happen if no chainlink price is recieved within an epoch, therefore no valid price is available\n  to execute and process all oustanding orders and value transfer - The markets gracefully go into a state of deprecation. \n  When this happens, all normal mints and redeems are suspended. It is only possible to burn all poolTokens and redeem collateral. \n  The tokens will no longer change value according any price feed, or pay funding etc, the token price will simply stay constant.\n  This seems the safest way to handle a blackswan event. That being said EPOCH_LENGTH will be set to ensure its highly unlikely\n  price events don't ocur during an epoch.\n  */\n\n  /// @notice Place the market in a state where no more price updates or mints are allowed\n  function _deprecateMarket() internal {\n    ValueChangeAndFunding memory emptyValueChangeAndFunding;\n\n    uint128[2] memory newEffectiveLiquidity = effectiveLiquidityForPoolType;\n\n    // Here we rebalance the ma"
    }
  ]
}