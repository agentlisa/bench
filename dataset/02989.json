{
  "Title": "M-10: Balancer Vault Will Receive Fewer Assets As The Current Design Does Not Serve The Interest Of Vault Shareholders",
  "Content": "# Issue M-10: Balancer Vault Will Receive Fewer Assets As The Current Design Does Not Serve The Interest Of Vault Shareholders \n\nSource: https://github.com/sherlock-audit/2022-09-notional-judging/issues/76 \n\n## Found by \nxiaoming90\n\n## Summary\n\nThe current implementation of reinvesting reward function does not benefit the vault shareholders as the current design does not serve the vault shareholder's interest well. Thus, this will result in Balancer vaults receiving fewer assets.\n\n## Vulnerability Detail\n\nThe `reinvestReward` function of the Balancer Vaults (MetaStable2TokenAuraVault and Boosted3TokenAuraVault) is permissionless and can be called by anyone. By calling `reinvestReward` function, the vault will trade the reward tokens received by the vault for tokens that are accepted by the balancer pool, and deposit them to the pool to obtain more BPT tokens for the vault shareholders. By continuously reinvesting the reward tokens into the pool, the vault shareholders will be able to lay claim to more BPT tokens per share over time.\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/external/MetaStable2TokenAuraHelper.sol#L114\n\n```solidity\nFile: MetaStable2TokenAuraHelper.sol\n114:     function reinvestReward(\n115:         MetaStable2TokenAuraStrategyContext calldata context,\n116:         ReinvestRewardParams calldata params\n117:     ) external {\n```\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/external/Boosted3TokenAuraHelper.sol#L115\n\n\n```solidity\nFile: Boosted3TokenAuraHelper.sol\n115:     function reinvestReward(\n116:         Boosted3TokenAuraStrategyContext calldata context,\n117:         ReinvestRewardParams calldata params\n118:     ) external {        \n```\n\nThe caller of the `reinvestReward` function can specify the trading configuration such as the DEX (e.g. Uniswap, Curve) that the trade should be executed and the slippage (`params.tradeParams.oracleSlippagePercent`). Note that the slippage defined must be equal to or less than the ` strategyContext.vaultSettings.maxRewardTradeSlippageLimitPercent` setting that is currently set to 5% within the test scripts.\n\nNotional Vaults support trading in multiple DEX protocols (Curve, Balancer V2, Uniswap V2 & V3 and 0x). Since `reinvestReward` function is callable by anyone, the liquidity provider of the supported DEX protocols will want the trade to be executed on the DEX pool that they invested on. This will allow them to earn an additional transaction fee from the trade. The amount of transaction fee earned will be significant if the volume is large when there are many vaults and reward tokens to be reinvested. In addition, the caller will set the slippage to the maximum configurable threshold (e.g. 5% in this example) to maximize the profit. Therefore, this will end up having various liquidity providers front-running each other to ensure that their `reinvestReward` transaction gets executed in order to extract value.\n\n## Impact\n\nThis does not serve the vault shareholder's interest well as the caller of the `reinvestReward` function will not be trading and reinvesting in an optimal way that maximizes the value of the shareholder's assets in the vaults. There is a misalignment in the objective between the vault shareholders and callers. Therefore, the vault and its users will end up on the losing end and receive fewer assets than they should.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/external/MetaStable2TokenAuraHelper.sol#L114\nhttps://github.com/sherlock-audit/2022-09-notional/blob/main/leveraged-vaults/contracts/vaults/balancer/external/Boosted3TokenAuraHelper.sol#L115\n\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIt is recommended to implement access control on the `reinvestReward` function to ensure that this function can only be triggered by Notional who has the best interest of its vault users.\n\nAlso, consider sending the `reinvestReward` transaction as a private transaction via Flashbot so that the attacker cannot perform any kind of sandwich attack on the reinvest rewards transaction.\n\n## Discussion\n\n**jeffywu**\n\nThere is some balance between centralization and decentralization here, but the auditor does bring up some valid points that we can consider.\n\nIf re-invest rewards is called at a predictable cadence the amount of fees generated by trading will likely not be significant enough to generate profits for MEV.\n\n**T-Woodward**\n\nYeah I think this is a legitimate issue. We are permissioning reward reinvestment.\n\n\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/2",
  "Code": [
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/external/MetaStable2TokenAuraHelper.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {\n    MetaStable2TokenAuraStrategyContext,\n    StableOracleContext,\n    StrategyContext,\n    TwoTokenPoolContext,\n    RedeemParams,\n    ReinvestRewardParams,\n    StrategyVaultSettings,\n    StrategyVaultState\n} from \"../BalancerVaultTypes.sol\";\nimport {BalancerEvents} from \"../BalancerEvents.sol\";\nimport {SettlementUtils} from \"../internal/settlement/SettlementUtils.sol\";\nimport {StrategyUtils} from \"../internal/strategy/StrategyUtils.sol\";\nimport {TwoTokenPoolUtils} from \"../internal/pool/TwoTokenPoolUtils.sol\";\nimport {TwoTokenAuraRewardUtils} from \"../internal/reward/TwoTokenAuraRewardUtils.sol\";\nimport {Stable2TokenOracleMath} from \"../internal/math/Stable2TokenOracleMath.sol\";\nimport {BalancerVaultStorage} from \"../internal/BalancerVaultStorage.sol\";\nimport {IERC20} from \"../../../../interfaces/IERC20.sol\";\n\nlibrary MetaStable2TokenAuraHelper {\n    using TwoTokenAuraRewardUtils for TwoTokenPoolContext;\n    using TwoTokenPoolUtils for TwoTokenPoolContext;\n    using Stable2TokenOracleMath for StableOracleContext;\n    using StrategyUtils for StrategyContext;\n    using SettlementUtils for StrategyContext;\n    using BalancerVaultStorage for StrategyVaultSettings;\n\n    function settleVault(\n        MetaStable2TokenAuraStrategyContext calldata context,\n        uint256 maturity,\n        uint256 strategyTokensToRedeem,\n        RedeemParams memory params\n    ) external {\n        uint256 bptToSettle = context.baseStrategy._convertStrategyTokensToBPTClaim(strategyTokensToRedeem);\n        \n        _executeSettlement({\n            strategyContext: context.baseStrategy,\n            oracleContext: context.oracleContext,\n            poolContext: context.poolContext,\n            maturity: maturity,\n            bptToSettle: bptToSettle,\n            redeemStrategyTokenAmount: strategyTokensToRedeem,\n            params: params\n        });\n\n        emit BalancerEvents.VaultSettlement(maturity, bptToSettle, strategyTokensToRedeem);\n    }\n\n    function settleVaultEmergency(\n        MetaStable2TokenAuraStrategyContext calldata context, \n        uint256 maturity, \n        bytes calldata data\n    ) external {\n        RedeemParams memory params = SettlementUtils._decodeParamsAndValidate(\n            context.baseStrategy.vaultSettings.emergencySettlementSlippageLimitPercent,\n            data\n        );\n\n        uint256 bptToSettle = context.baseStrategy._getEmergencySettlementParams({\n            poolContext: context.poolContext.basePool, \n            maturity: maturity, \n            totalBPTSupply: IERC20(context.poolContext.basePool.pool).totalSupply()\n        });\n\n        uint256 redeemStrategyTokenAmount = \n            context.baseStrategy._convertBPTClaimToStrategyTokens(bptToSettle);\n\n        _executeSettlement({\n            strategyContext: context.baseStrategy,\n            oracleContext: context.oracleContext,\n            poolContext: context.poolContext,\n            maturity: maturity,\n            bptToSettle: bptToSettle,\n            redeemStrategyTokenAmount: redeemStrategyTokenAmount,\n            params: params\n        });\n\n        emit BalancerEvents.EmergencyVaultSettlement(maturity, bptToSettle, redeemStrategyTokenAmount);\n    }\n\n    function _executeSettlement(\n        StrategyContext calldata strategyContext,\n        StableOracleContext calldata oracleContext,\n        TwoTokenPoolContext calldata poolContext,\n        uint256 maturity,\n        uint256 bptToSettle,\n        uint256 redeemStrategyTokenAmount,\n        RedeemParams memory params\n    ) private {\n        /// @notice params.minPrimary and params.minSecondary are not required for this strategy vault\n        (params.minPrimary, params.minSecondary) = oracleContext._getMinExitAmounts({\n            poolContext: poolContext,\n            strategyContext: strategyContext,\n            bptAmount: bptToSettle\n        });\n\n        int256 expectedUnderlyingRedeemed = poolContext._convertStrategyToUnderlying({\n            strategyContext: strategyContext,\n            oracleContext: oracleContext.baseOracle,\n            strategyTokenAmount: redeemStrategyTokenAmount\n        });\n\n        strategyContext._executeSettlement({\n            maturity: maturity,\n            expectedUnderlyingRedeemed: expectedUnderlyingRedeemed,\n            redeemStrategyTokenAmount: redeemStrategyTokenAmount,\n            params: params\n        });\n    }\n\n    function reinvestReward(\n        MetaStable2TokenAuraStrategyContext calldata context,\n        ReinvestRewardParams calldata params\n    ) external {\n        StrategyContext calldata strategyContext = context.baseStrategy;\n        TwoTokenPoolContext calldata poolContext = context.poolContext; \n        StableOracleContext calldata oracleContext = context.oracleContext;\n\n        (\n            address rewardToken, \n            uint256 primaryAmount, \n            uint256 secondaryAmount\n        ) = poolContext._executeRewardTrades(\n            context.stakingContext,\n            strategyContext.tradingModule,\n            params.tradeData,\n            strategyContext.vaultSettings.maxRewardTradeSlippageLimitPercent\n        );\n\n        // Make sure we are joining with the right proportion to minimize slippage\n        oracleContext._validateSpotPriceAndPairPrice({\n            poolContext: poolContext,\n            strategyContext: strategyContext,\n            primaryAmount: primaryAmount,\n            secondaryAmount: secondaryAmount\n        });\n\n        uint256 bptAmount = poolContext._joinPoolAndStake({\n            strategyContext: strategyContext,\n            stakingContext: context.stakingContext,\n            primaryAmount: primaryAmount,\n            secondaryAmount: secondaryAmount,\n            /// @notice minBPT is not required to be set by the caller because primaryAmount\n            /// and secondaryAmount are already validated\n            minBPT: params.minBPT        \n        });\n\n        emit BalancerEvents.RewardReinvested(rewardToken, primaryAmount, secondaryAmount, bptAmount); \n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/external/Boosted3TokenAuraHelper.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {\n    Boosted3TokenAuraStrategyContext, \n    StrategyContext,\n    RedeemParams,\n    ReinvestRewardParams,\n    ThreeTokenPoolContext,\n    StrategyContext,\n    AuraStakingContext,\n    BoostedOracleContext,\n    StrategyVaultSettings,\n    StrategyVaultState\n} from \"../BalancerVaultTypes.sol\";\nimport {BalancerConstants} from \"../internal/BalancerConstants.sol\";\nimport {BalancerEvents} from \"../BalancerEvents.sol\";\nimport {SettlementUtils} from \"../internal/settlement/SettlementUtils.sol\";\nimport {StrategyUtils} from \"../internal/strategy/StrategyUtils.sol\";\nimport {Boosted3TokenPoolUtils} from \"../internal/pool/Boosted3TokenPoolUtils.sol\";\nimport {Boosted3TokenAuraRewardUtils} from \"../internal/reward/Boosted3TokenAuraRewardUtils.sol\";\nimport {BalancerVaultStorage} from \"../internal/BalancerVaultStorage.sol\";\nimport {StableMath} from \"../internal/math/StableMath.sol\";\n\nlibrary Boosted3TokenAuraHelper {\n    using Boosted3TokenAuraRewardUtils for ThreeTokenPoolContext;\n    using Boosted3TokenPoolUtils for ThreeTokenPoolContext;\n    using StrategyUtils for StrategyContext;\n    using SettlementUtils for StrategyContext;\n    using BalancerVaultStorage for StrategyVaultSettings;\n\n    function settleVault(\n        Boosted3TokenAuraStrategyContext calldata context,\n        uint256 maturity,\n        uint256 strategyTokensToRedeem,\n        RedeemParams memory params\n    ) external {\n        uint256 bptToSettle = context.baseStrategy._convertStrategyTokensToBPTClaim(strategyTokensToRedeem);\n\n        _executeSettlement({\n            strategyContext: context.baseStrategy,\n            oracleContext: context.oracleContext,\n            poolContext: context.poolContext,\n            maturity: maturity,\n            bptToSettle: bptToSettle,\n            redeemStrategyTokenAmount: strategyTokensToRedeem,\n            params: params\n        });\n\n        emit BalancerEvents.VaultSettlement(maturity, bptToSettle, strategyTokensToRedeem);\n    }\n\n    function settleVaultEmergency(\n        Boosted3TokenAuraStrategyContext calldata context, \n        uint256 maturity, \n        bytes calldata data\n    ) external {\n        RedeemParams memory params = SettlementUtils._decodeParamsAndValidate(\n            context.baseStrategy.vaultSettings.emergencySettlementSlippageLimitPercent,\n            data\n        );\n\n        uint256 bptToSettle = context.baseStrategy._getEmergencySettlementParams({\n            poolContext: context.poolContext.basePool.basePool, \n            maturity: maturity, \n            totalBPTSupply: context.poolContext._getVirtualSupply(context.oracleContext)\n        });\n\n        uint256 redeemStrategyTokenAmount \n            = context.baseStrategy._convertBPTClaimToStrategyTokens(bptToSettle);\n        \n        _executeSettlement({\n            strategyContext: context.baseStrategy,\n            oracleContext: context.oracleContext,\n            poolContext: context.poolContext,\n            maturity: maturity,\n            bptToSettle: bptToSettle,\n            redeemStrategyTokenAmount: redeemStrategyTokenAmount,\n            params: params\n        });\n\n        emit BalancerEvents.EmergencyVaultSettlement(maturity, bptToSettle, redeemStrategyTokenAmount);\n    }\n\n    function _executeSettlement(\n        StrategyContext calldata strategyContext,\n        BoostedOracleContext calldata oracleContext,\n        ThreeTokenPoolContext calldata poolContext,\n        uint256 maturity,\n        uint256 bptToSettle,\n        uint256 redeemStrategyTokenAmount,\n        RedeemParams memory params\n    ) private {\n        // Calculate minPrimary using Chainlink oracle data\n        params.minPrimary = poolContext._getTimeWeightedPrimaryBalance(\n            oracleContext, strategyContext, bptToSettle\n        );\n        params.minPrimary = params.minPrimary * strategyContext.vaultSettings.balancerPoolSlippageLimitPercent / \n            uint256(BalancerConstants.VAULT_PERCENT_BASIS);\n\n        int256 expectedUnderlyingRedeemed = poolContext._convertStrategyToUnderlying({\n            strategyContext: strategyContext,\n            oracleContext: oracleContext,\n            strategyTokenAmount: redeemStrategyTokenAmount\n        });\n\n        strategyContext._executeSettlement({\n            maturity: maturity,\n            expectedUnderlyingRedeemed: expectedUnderlyingRedeemed,\n            redeemStrategyTokenAmount: redeemStrategyTokenAmount,\n            params: params\n        });\n    }\n\n    function reinvestReward(\n        Boosted3TokenAuraStrategyContext calldata context,\n        ReinvestRewardParams calldata params\n    ) external {        \n        StrategyContext calldata strategyContext = context.baseStrategy;\n        BoostedOracleContext calldata oracleContext = context.oracleContext;\n        AuraStakingContext calldata stakingContext = context.stakingContext;\n\n        (address rewardToken, uint256 primaryAmount) = context.poolContext._executeRewardTrades({\n            stakingContext: stakingContext,\n            tradingModule: strategyContext.tradingModule,\n            data: params.tradeData,\n            slippageLimit: strategyContext.vaultSettings.maxRewardTradeSlippageLimitPercent\n        });\n\n        uint256 minBPT = context.poolContext._getMinBPT(\n            oracleContext, strategyContext, primaryAmount\n        );\n\n        uint256 bptAmount = context.poolContext._joinPoolAndStake({\n            strategyContext: strategyContext,\n            stakingContext: stakingContext,\n            oracleContext: oracleContext,\n            deposit: primaryAmount,\n            minBPT: minBPT\n        });\n\n        emit BalancerEvents.RewardReinvested(rewardToken, primaryAmount, 0, bptAmount); \n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/external/MetaStable2TokenAuraHelper.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {\n    MetaStable2TokenAuraStrategyContext,\n    StableOracleContext,\n    StrategyContext,\n    TwoTokenPoolContext,\n    RedeemParams,\n    ReinvestRewardParams,\n    StrategyVaultSettings,\n    StrategyVaultState\n} from \"../BalancerVaultTypes.sol\";\nimport {BalancerEvents} from \"../BalancerEvents.sol\";\nimport {SettlementUtils} from \"../internal/settlement/SettlementUtils.sol\";\nimport {StrategyUtils} from \"../internal/strategy/StrategyUtils.sol\";\nimport {TwoTokenPoolUtils} from \"../internal/pool/TwoTokenPoolUtils.sol\";\nimport {TwoTokenAuraRewardUtils} from \"../internal/reward/TwoTokenAuraRewardUtils.sol\";\nimport {Stable2TokenOracleMath} from \"../internal/math/Stable2TokenOracleMath.sol\";\nimport {BalancerVaultStorage} from \"../internal/BalancerVaultStorage.sol\";\nimport {IERC20} from \"../../../../interfaces/IERC20.sol\";\n\nlibrary MetaStable2TokenAuraHelper {\n    using TwoTokenAuraRewardUtils for TwoTokenPoolContext;\n    using TwoTokenPoolUtils for TwoTokenPoolContext;\n    using Stable2TokenOracleMath for StableOracleContext;\n    using StrategyUtils for StrategyContext;\n    using SettlementUtils for StrategyContext;\n    using BalancerVaultStorage for StrategyVaultSettings;\n\n    function settleVault(\n        MetaStable2TokenAuraStrategyContext calldata context,\n        uint256 maturity,\n        uint256 strategyTokensToRedeem,\n        RedeemParams memory params\n    ) external {\n        uint256 bptToSettle = context.baseStrategy._convertStrategyTokensToBPTClaim(strategyTokensToRedeem);\n        \n        _executeSettlement({\n            strategyContext: context.baseStrategy,\n            oracleContext: context.oracleContext,\n            poolContext: context.poolContext,\n            maturity: maturity,\n            bptToSettle: bptToSettle,\n            redeemStrategyTokenAmount: strategyTokensToRedeem,\n            params: params\n        });\n\n        emit BalancerEvents.VaultSettlement(maturity, bptToSettle, strategyTokensToRedeem);\n    }\n\n    function settleVaultEmergency(\n        MetaStable2TokenAuraStrategyContext calldata context, \n        uint256 maturity, \n        bytes calldata data\n    ) external {\n        RedeemParams memory params = SettlementUtils._decodeParamsAndValidate(\n            context.baseStrategy.vaultSettings.emergencySettlementSlippageLimitPercent,\n            data\n        );\n\n        uint256 bptToSettle = context.baseStrategy._getEmergencySettlementParams({\n            poolContext: context.poolContext.basePool, \n            maturity: maturity, \n            totalBPTSupply: IERC20(context.poolContext.basePool.pool).totalSupply()\n        });\n\n        uint256 redeemStrategyTokenAmount = \n            context.baseStrategy._convertBPTClaimToStrategyTokens(bptToSettle);\n\n        _executeSettlement({\n            strategyContext: context.baseStrategy,\n            oracleContext: context.oracleContext,\n            poolContext: context.poolContext,\n            maturity: maturity,\n            bptToSettle: bptToSettle,\n            redeemStrategyTokenAmount: redeemStrategyTokenAmount,\n            params: params\n        });\n\n        emit BalancerEvents.EmergencyVaultSettlement(maturity, bptToSettle, redeemStrategyTokenAmount);\n    }\n\n    function _executeSettlement(\n        StrategyContext calldata strategyContext,\n        StableOracleContext calldata oracleContext,\n        TwoTokenPoolContext calldata poolContext,\n        uint256 maturity,\n        uint256 bptToSettle,\n        uint256 redeemStrategyTokenAmount,\n        RedeemParams memory params\n    ) private {\n        /// @notice params.minPrimary and params.minSecondary are not required for this strategy vault\n        (params.minPrimary, params.minSecondary) = oracleContext._getMinExitAmounts({\n            poolContext: poolContext,\n            strategyContext: strategyContext,\n            bptAmount: bptToSettle\n        });\n\n        int256 expectedUnderlyingRedeemed = poolContext._convertStrategyToUnderlying({\n            strategyContext: strategyContext,\n            oracleContext: oracleContext.baseOracle,\n            strategyTokenAmount: redeemStrategyTokenAmount\n        });\n\n        strategyContext._executeSettlement({\n            maturity: maturity,\n            expectedUnderlyingRedeemed: expectedUnderlyingRedeemed,\n            redeemStrategyTokenAmount: redeemStrategyTokenAmount,\n            params: params\n        });\n    }\n\n    function reinvestReward(\n        MetaStable2TokenAuraStrategyContext calldata context,\n        ReinvestRewardParams calldata params\n    ) external {\n        StrategyContext calldata strategyContext = context.baseStrategy;\n        TwoTokenPoolContext calldata poolContext = context.poolContext; \n        StableOracleContext calldata oracleContext = context.oracleContext;\n\n        (\n            address rewardToken, \n            uint256 primaryAmount, \n            uint256 secondaryAmount\n        ) = poolContext._executeRewardTrades(\n            context.stakingContext,\n            strategyContext.tradingModule,\n            params.tradeData,\n            strategyContext.vaultSettings.maxRewardTradeSlippageLimitPercent\n        );\n\n        // Make sure we are joining with the right proportion to minimize slippage\n        oracleContext._validateSpotPriceAndPairPrice({\n            poolContext: poolContext,\n            strategyContext: strategyContext,\n            primaryAmount: primaryAmount,\n            secondaryAmount: secondaryAmount\n        });\n\n        uint256 bptAmount = poolContext._joinPoolAndStake({\n            strategyContext: strategyContext,\n            stakingContext: context.stakingContext,\n            primaryAmount: primaryAmount,\n            secondaryAmount: secondaryAmount,\n            /// @notice minBPT is not required to be set by the caller because primaryAmount\n            /// and secondaryAmount are already validated\n            minBPT: params.minBPT        \n        });\n\n        emit BalancerEvents.RewardReinvested(rewardToken, primaryAmount, secondaryAmount, bptAmount); \n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/balancer/external/Boosted3TokenAuraHelper.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {\n    Boosted3TokenAuraStrategyContext, \n    StrategyContext,\n    RedeemParams,\n    ReinvestRewardParams,\n    ThreeTokenPoolContext,\n    StrategyContext,\n    AuraStakingContext,\n    BoostedOracleContext,\n    StrategyVaultSettings,\n    StrategyVaultState\n} from \"../BalancerVaultTypes.sol\";\nimport {BalancerConstants} from \"../internal/BalancerConstants.sol\";\nimport {BalancerEvents} from \"../BalancerEvents.sol\";\nimport {SettlementUtils} from \"../internal/settlement/SettlementUtils.sol\";\nimport {StrategyUtils} from \"../internal/strategy/StrategyUtils.sol\";\nimport {Boosted3TokenPoolUtils} from \"../internal/pool/Boosted3TokenPoolUtils.sol\";\nimport {Boosted3TokenAuraRewardUtils} from \"../internal/reward/Boosted3TokenAuraRewardUtils.sol\";\nimport {BalancerVaultStorage} from \"../internal/BalancerVaultStorage.sol\";\nimport {StableMath} from \"../internal/math/StableMath.sol\";\n\nlibrary Boosted3TokenAuraHelper {\n    using Boosted3TokenAuraRewardUtils for ThreeTokenPoolContext;\n    using Boosted3TokenPoolUtils for ThreeTokenPoolContext;\n    using StrategyUtils for StrategyContext;\n    using SettlementUtils for StrategyContext;\n    using BalancerVaultStorage for StrategyVaultSettings;\n\n    function settleVault(\n        Boosted3TokenAuraStrategyContext calldata context,\n        uint256 maturity,\n        uint256 strategyTokensToRedeem,\n        RedeemParams memory params\n    ) external {\n        uint256 bptToSettle = context.baseStrategy._convertStrategyTokensToBPTClaim(strategyTokensToRedeem);\n\n        _executeSettlement({\n            strategyContext: context.baseStrategy,\n            oracleContext: context.oracleContext,\n            poolContext: context.poolContext,\n            maturity: maturity,\n            bptToSettle: bptToSettle,\n            redeemStrategyTokenAmount: strategyTokensToRedeem,\n            params: params\n        });\n\n        emit BalancerEvents.VaultSettlement(maturity, bptToSettle, strategyTokensToRedeem);\n    }\n\n    function settleVaultEmergency(\n        Boosted3TokenAuraStrategyContext calldata context, \n        uint256 maturity, \n        bytes calldata data\n    ) external {\n        RedeemParams memory params = SettlementUtils._decodeParamsAndValidate(\n            context.baseStrategy.vaultSettings.emergencySettlementSlippageLimitPercent,\n            data\n        );\n\n        uint256 bptToSettle = context.baseStrategy._getEmergencySettlementParams({\n            poolContext: context.poolContext.basePool.basePool, \n            maturity: maturity, \n            totalBPTSupply: context.poolContext._getVirtualSupply(context.oracleContext)\n        });\n\n        uint256 redeemStrategyTokenAmount \n            = context.baseStrategy._convertBPTClaimToStrategyTokens(bptToSettle);\n        \n        _executeSettlement({\n            strategyContext: context.baseStrategy,\n            oracleContext: context.oracleContext,\n            poolContext: context.poolContext,\n            maturity: maturity,\n            bptToSettle: bptToSettle,\n            redeemStrategyTokenAmount: redeemStrategyTokenAmount,\n            params: params\n        });\n\n        emit BalancerEvents.EmergencyVaultSettlement(maturity, bptToSettle, redeemStrategyTokenAmount);\n    }\n\n    function _executeSettlement(\n        StrategyContext calldata strategyContext,\n        BoostedOracleContext calldata oracleContext,\n        ThreeTokenPoolContext calldata poolContext,\n        uint256 maturity,\n        uint256 bptToSettle,\n        uint256 redeemStrategyTokenAmount,\n        RedeemParams memory params\n    ) private {\n        // Calculate minPrimary using Chainlink oracle data\n        params.minPrimary = poolContext._getTimeWeightedPrimaryBalance(\n            oracleContext, strategyContext, bptToSettle\n        );\n        params.minPrimary = params.minPrimary * strategyContext.vaultSettings.balancerPoolSlippageLimitPercent / \n            uint256(BalancerConstants.VAULT_PERCENT_BASIS);\n\n        int256 expectedUnderlyingRedeemed = poolContext._convertStrategyToUnderlying({\n            strategyContext: strategyContext,\n            oracleContext: oracleContext,\n            strategyTokenAmount: redeemStrategyTokenAmount\n        });\n\n        strategyContext._executeSettlement({\n            maturity: maturity,\n            expectedUnderlyingRedeemed: expectedUnderlyingRedeemed,\n            redeemStrategyTokenAmount: redeemStrategyTokenAmount,\n            params: params\n        });\n    }\n\n    function reinvestReward(\n        Boosted3TokenAuraStrategyContext calldata context,\n        ReinvestRewardParams calldata params\n    ) external {        \n        StrategyContext calldata strategyContext = context.baseStrategy;\n        BoostedOracleContext calldata oracleContext = context.oracleContext;\n        AuraStakingContext calldata stakingContext = context.stakingContext;\n\n        (address rewardToken, uint256 primaryAmount) = context.poolContext._executeRewardTrades({\n            stakingContext: stakingContext,\n            tradingModule: strategyContext.tradingModule,\n            data: params.tradeData,\n            slippageLimit: strategyContext.vaultSettings.maxRewardTradeSlippageLimitPercent\n        });\n\n        uint256 minBPT = context.poolContext._getMinBPT(\n            oracleContext, strategyContext, primaryAmount\n        );\n\n        uint256 bptAmount = context.poolContext._joinPoolAndStake({\n            strategyContext: strategyContext,\n            stakingContext: stakingContext,\n            oracleContext: oracleContext,\n            deposit: primaryAmount,\n            minBPT: minBPT\n        });\n\n        emit BalancerEvents.RewardReinvested(rewardToken, primaryAmount, 0, bptAmount); \n    }\n}"
    }
  ]
}