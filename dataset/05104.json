{
  "Title": "[M-14] Current heartbeat implementation may lead to a prolonged DoS for Chainlink Oracles",
  "Content": "\nCurrently, if there are 50 fast updates followed by no updates, a Chainlink Oracle will be considered dead, even though it's normal behavior. Chainlink Oracles update either after some time has passed or upon a price change.\n\n### Vulnerability Details\n\n**How it will revert:**\n\nThere is a `_chainLinkIsDead` function that returns true if the last update took longer than the heartbeat. See [here](<https://github.com/code-423n4/2024-02-wise-lending/blob/1240a22a3bbffc13d5f8ae6300ef45de5edc7c19/contracts/WiseOracleHub/OracleHelper.sol#L579-L585>).\n\n```solidity\nunchecked {\n\tupd = block.timestamp < upd\n\t\t? block.timestamp\n\t\t: block.timestamp - upd;\n\n\treturn upd > heartBeat[_tokenAddress];\n}\n```\n\nIt's essentially called on every request to the Chainlink Oracle, before the actual call, to ensure the price is up to date.\n\n**How does recalibrate work?**\n\n`heartBeat` is updated when `recalibrate`/`recalibrateBulk` is called. Anyone can call them. Both of these functions call `_recalibrate`. See [here](<https://github.com/code-423n4/2024-02-wise-lending/blob/1240a22a3bbffc13d5f8ae6300ef45de5edc7c19/contracts/WiseOracleHub/OracleHelper.sol#L512-L514>).\n\n```solidity\n        heartBeat[_tokenAddress] = _recalibratePreview(\n            _tokenAddress\n        );\n```\n\nIn [`_recalibratePreview`](https://github.com/code-423n4/2024-02-wise-lending/blob/1240a22a3bbffc13d5f8ae6300ef45de5edc7c19/contracts/WiseOracleHub/OracleHelper.sol#L651), we see that `currentSecondBiggest` is returned, representing the second-largest difference between updates. Thus, `heartBeat` is set to the second-largest time difference between two consecutive updates in the last 50 updates. `iterationCount` is capped by `MAX_ROUND_COUNT` in `_getIterationCount`, which is set to 50.\n\n**[How do Chainlink updates work](https://docs.chain.link/architecture-overview/architecture-decentralized-model?parent=dataFeeds#aggregator)?**\n\n> Aggregators receive updates from the Oracle network only when the **Deviation Threshold** or **Heartbeat Threshold** triggers an update during an aggregation round. The first condition that is met triggers an update to the data.\n>\n> - Deviation Threshold: A new aggregation round starts when a node identifies that the off-chain values deviate by more than the defined deviation threshold from the onchain value. Individual nodes monitor one or more data providers for each feed.\n> - Heartbeat Threshold: A new aggregation round starts after a specified amount of time from the last update.\n\nIf you check \"Show more details\" [here](https://docs.chain.link/data-feeds/price-feeds/addresses?network=ethereum\\&page=1), you can see that for most feeds, deviation is set to 1-2% and heartbeat is `86400s = 24` hours. However, some feeds are set to 0.5% or even less.\n\nIf there's a period of high volatility followed by no volatility, it's possible that `heartBeat` in Wise will be set to a low value. Consequently, the Chainlink feed will be considered dead after a short period of no updates.\n\nE.g., if there are 50 updates, once every minute, followed by 10 hours of no updates, and then no updates for an additional 24 hours, the `heartBeat` will be set to 1 minute in Wise. Consequently, the Oracle will be considered dead after 1 minute of no updates. This means it will be considered dead for the initial 10 hours, then considered alive for 1 minute, and then considered dead again for the following 24 hours.\n\nExamples demonstrating similar events in the wild can be seen in [this Dune dashboard](<https://dune.com/00xsev/answer-updated-counters>).\n\n### Impact\n\nThe Chainlink Oracle is considered dead for a substantial amount of time, affecting liquidations, deposits, withdrawals, and all other functions using this Oracle.\n\nThe attacker can disable the entire market that uses the Oracle by calling recalibrate. This can lead to bad debt (the price changes rapidly, but the Oracle still reverts after the first update), griefing (users cannot use the protocol), etc.\n\nIt can be even worse if combined with block stuffing or when the gas price is too high and Chainlink does not update. The updates stop coming as often as usual, and the feed is considered dead long enough to accrue bad debt. For example, if the last 50 updates occurred every minute, a sudden spike in demand for block space could make updates come only once an hour, preventing liquidations for 1-2 hours.\n\n### Proof of Concept\n\n`forge test -f https://mainnet.infura.io/v3/YOUR_KEY -vvv --mt testOne --mc ChainlinkDies$`\n\n`contracts/Tests/ChainlinkDies.t.sol`\n\n<details>\n\n```solidity\npragma solidity =0.8.24;\n\nimport \"forge-std/console.sol\";\nimport \"forge-std/Test.sol\";\nimport \"../WiseOracleHub/OracleHelper.sol\";\n\n\ncontract OracleHelperMock is OracleHelper {\n    constructor(\n        address _wethAddress,\n        address _ethPriceFeed,\n        address _uniswapV3Factory\n    ) Declarations(_wethAddress, _ethPriceFeed, _uniswapV3Factory) {\n        \n    }\n\n    function addOracle(\n        address _tokenAddress,\n        IPriceFeed _priceFeedAddress,\n        address[] calldata _underlyingFeedTokens\n    ) external {\n        _addOracle(\n            _tokenAddress,\n            _priceFeedAddress,\n            _underlyingFeedTokens\n        );\n    }\n\n    function recalibrate(\n        address _tokenAddress\n    )\n        external\n    {\n        _recalibrate(_tokenAddress);\n    }\n\n    function chainLinkIsDead(\n        address _tokenAddress\n    )\n        external\n        view\n        returns (bool)\n    {\n       return _chainLinkIsDead(_tokenAddress);\n    }\n}\n\ninterface PartialAccessControlledOffchainAggregator is IPriceFeed {\n    function disableAccessCheck() external;\n    function owner() external returns (address);\n    function checkEnabled() external returns (bool);\n}\n\ncontract ChainlinkDies is Test {\n    address WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address ETH_PRICE_FEED = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419;\n    address UNISWAP_V3_FACTORY = 0x1F98431c8aD98523631AE4a59f267346ea31F984;\n\n    address FEI = 0x956F47F50A910163D8BF957Cf5846D573E7f87CA;\n    PartialAccessControlledOffchainAggregator FEI_ETH_FEED = \n        PartialAccessControlledOffchainAggregator(0x4bE991B4d560BBa8308110Ed1E0D7F8dA60ACf6A);\n\n    uint LAST_NORMAL_BLOCK = 16_866_049;\n    // one block before the update after no updates for a day\n    uint TARGET_BLOCK = 16_872_122; \n\n    function testOne() external {\n        OracleHelperMock sut = _test(LAST_NORMAL_BLOCK);\n        assertFalse(sut.chainLinkIsDead(FEI));\n\n        sut = _test(TARGET_BLOCK);\n        assert(sut.chainLinkIsDead(FEI));\n    }\n\n    function _test(uint blockNumber) internal returns (OracleHelperMock) {\n        vm.rollFork(blockNumber);\n\n        vm.prank(FEI_ETH_FEED.owner());\n        FEI_ETH_FEED.disableAccessCheck();\n        assertFalse(FEI_ETH_FEED.checkEnabled());\n\n        OracleHelperMock sut = new OracleHelperMock(WETH_ADDRESS, ETH_PRICE_FEED, UNISWAP_V3_FACTORY);\n        // make sure recalibrate works\n        sut.addOracle( {\n            _tokenAddress: FEI,\n            _priceFeedAddress: FEI_ETH_FEED,\n            _underlyingFeedTokens: new address[](0)\n        } );\n        sut.recalibrate(FEI);\n        console.log(\"block:\", blockNumber);\n        console.log(\"chainLinkIsDead:\", sut.chainLinkIsDead(FEI));\n\n        return sut;\n    }\n\n\n}\n```\n\n</details>\n\n### Recommended Mitigation Steps\n\nConsider setting Chainlink's native heartbeat instead. Also consider adding access control to `recalibrate` functions and only calling it when it will not lead to DoS.\n\n### Assessed type\n\nOracle\n\n**[vonMangoldt (Wise Lending) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/87#issuecomment-2009125717):**\n > It takes second highest out of last 50 rounds if you recalibrate. If it takes forever to update for chainlink it means there is no volatility. So dismissed.\n\n**[Trust (judge) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/87#issuecomment-2020987565):**\n > Warden discussed a potential scenario when the Oracle would be considered dead after just one minute of inactivity. \n\n**[vm06007 (Wise Lending) commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/87#issuecomment-2032193902):**\n > @Trust - it depends on the expected heartbeat, if it's one minute, and latest data does not come within that frame then Oracle SHOULD be considered dead.\n> \n> Example: `recalibrate()` looks for second longest time gap between latest 50 (or 500 depending on chain) rounds, by analyzing timegaps between reported prices in last 50/500 rounds contract chooses appropriate expected timeframe when Oracle needs to answer before considered dead. If the time frame is too short this is only because that what was picked up from latest round data and should be honored (unlike this finding).\n> \n> Note that it can be recalibrated to increase the expected time if needed.\n\n**[Wise Lending commented](https://github.com/code-423n4/2024-02-wise-lending-findings/issues/87#issuecomment-2082921804):**\n> Mitigated [here](https://github.com/wise-foundation/lending-audit/commit/ac68b5a93976969d582301fee9f873ecec606df9).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-02-wise-lending",
  "Code": [
    {
      "filename": "contracts/WiseOracleHub/OracleHelper.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\nimport \"./Declarations.sol\";\n\nabstract contract OracleHelper is Declarations {\n\n    /**\n     * @dev Adds priceFeed for a given token.\n     */\n    function _addOracle(\n        address _tokenAddress,\n        IPriceFeed _priceFeedAddress,\n        address[] calldata _underlyingFeedTokens\n    )\n        internal\n    {\n        if (priceFeed[_tokenAddress] > ZERO_FEED) {\n            revert OracleAlreadySet();\n        }\n\n        priceFeed[_tokenAddress] = _priceFeedAddress;\n\n        _tokenDecimals[_tokenAddress] = IERC20(\n            _tokenAddress\n        ).decimals();\n\n        underlyingFeedTokens[_tokenAddress] = _underlyingFeedTokens;\n    }\n\n    function _addAggregator(\n        address _tokenAddress\n    )\n        internal\n    {\n        IAggregator tokenAggregator = IAggregator(\n            priceFeed[_tokenAddress].aggregator()\n        );\n\n        if (tokenAggregatorFromTokenAddress[_tokenAddress] > ZERO_AGGREGATOR) {\n            revert AggregatorAlreadySet();\n        }\n\n        if (_checkFunctionExistence(address(tokenAggregator)) == false) {\n            revert FunctionDoesntExist();\n        }\n\n        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[\n            _tokenAddress\n        ];\n\n        if (uniTwapPoolInfoStruct.oracle > ZERO_ADDRESS) {\n            revert AggregatorNotNecessary();\n        }\n\n        tokenAggregatorFromTokenAddress[_tokenAddress] = tokenAggregator;\n    }\n\n    function _checkFunctionExistence(\n        address _tokenAggregator\n    )\n        internal\n        returns (bool)\n    {\n        uint256 size;\n\n        assembly {\n            size := extcodesize(\n                _tokenAggregator\n            )\n        }\n\n        if (size == 0) {\n            return false;\n        }\n\n        (bool success, ) = _tokenAggregator.call(\n            abi.encodeWithSignature(\n                \"maxAnswer()\"\n            )\n        );\n\n        return success;\n    }\n\n    function _compareMinMax(\n        IAggregator _tokenAggregator,\n        int192 _answer\n    )\n        internal\n        view\n    {\n        int192 maxAnswer = _tokenAggregator.maxAnswer();\n        int192 minAnswer = _tokenAggregator.minAnswer();\n\n        if (_answer > maxAnswer || _answer < minAnswer) {\n            revert OracleIsDead();\n        }\n    }\n\n    /**\n     * @dev Returns Twaps latest USD value\n     * by passing the underlying token address.\n     */\n    function latestResolverTwap(\n        address _tokenAddress\n    )\n        public\n        view\n        returns (uint256)\n    {\n        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[\n            _tokenAddress\n        ];\n\n        if (uniTwapPoolInfoStruct.isUniPool == true) {\n\n            return _getTwapPrice(\n                _tokenAddress,\n                uniTwapPoolInfoStruct.oracle\n            ) / 10 ** (_decimalsWETH - decimals(_tokenAddress));\n        }\n\n        return _getTwapDerivatePrice(\n            _tokenAddress,\n            uniTwapPoolInfoStruct\n        ) / 10 ** (_decimalsWETH - decimals(_tokenAddress));\n    }\n\n    function _validateAnswer(\n        address _tokenAddress\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[\n            _tokenAddress\n        ];\n\n        uint256 fetchTwapValue;\n\n        if (uniTwapPoolInfoStruct.oracle > ZERO_ADDRESS) {\n            fetchTwapValue = latestResolverTwap(\n                _tokenAddress\n            );\n        }\n\n        uint256 answer = _getChainlinkAnswer(\n            _tokenAddress\n        );\n\n        if (tokenAggregatorFromTokenAddress[_tokenAddress] > ZERO_AGGREGATOR) {\n            _compareMinMax(\n                tokenAggregatorFromTokenAddress[_tokenAddress],\n                int192(uint192(answer))\n            );\n        }\n\n        if (fetchTwapValue > 0) {\n\n            uint256 relativeDifference = _getRelativeDifference(\n                answer,\n                fetchTwapValue\n            );\n\n            _compareDifference(\n                relativeDifference\n            );\n        }\n\n        return answer;\n    }\n\n    /**\n     * @dev Adds uniTwapPoolInfo for a given token.\n     */\n    function _writeUniTwapPoolInfoStruct(\n        address _tokenAddress,\n        address _oracle,\n        bool _isUniPool\n    )\n        internal\n    {\n        uniTwapPoolInfo[_tokenAddress] = UniTwapPoolInfo({\n            oracle: _oracle,\n            isUniPool: _isUniPool\n        });\n    }\n\n    /**\n     * @dev Adds uniTwapPoolInfo for a given token and its derivative.\n     */\n    function _writeUniTwapPoolInfoStructDerivative(\n        address _tokenAddress,\n        address _partnerTokenAddress,\n        address _oracleAddress,\n        address _partnerOracleAddress,\n        bool _isUniPool\n    )\n        internal\n    {\n        _writeUniTwapPoolInfoStruct(\n            _tokenAddress,\n            _oracleAddress,\n            _isUniPool\n        );\n\n        derivativePartnerTwap[_tokenAddress] = DerivativePartnerInfo(\n            _partnerTokenAddress,\n            _partnerOracleAddress\n        );\n    }\n\n    function _getRelativeDifference(\n        uint256 _answerUint256,\n        uint256 _fetchTwapValue\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        if (_answerUint256 > _fetchTwapValue) {\n            return _answerUint256\n                * PRECISION_FACTOR_E4\n                / _fetchTwapValue;\n        }\n\n        return _fetchTwapValue\n            * PRECISION_FACTOR_E4\n            / _answerUint256;\n    }\n\n    function _compareDifference(\n        uint256 _relativeDifference\n    )\n        internal\n        view\n    {\n        if (_relativeDifference > ALLOWED_DIFFERENCE) {\n            revert OraclesDeviate();\n        }\n    }\n\n    function _getChainlinkAnswer(\n        address _tokenAddress\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        (\n            ,\n            int256 answer,\n            ,\n            ,\n        ) = priceFeed[_tokenAddress].latestRoundData();\n\n        return uint256(\n            answer\n        );\n    }\n\n    function getETHPriceInUSD()\n        public\n        view\n        returns (uint256)\n    {\n        if (_chainLinkIsDead(ETH_USD_PLACEHOLDER) == true) {\n            revert OracleIsDead();\n        }\n\n        return _validateAnswer(\n            ETH_USD_PLACEHOLDER\n        );\n    }\n\n    /**\n    * @dev Retrieves the pool address for given\n    * tokens and fee from Uniswap V3 Factory.\n    */\n    function _getPool(\n        address _token0,\n        address _token1,\n        uint24 _fee\n    )\n        internal\n        view\n        returns (address pool)\n    {\n        return UNI_V3_FACTORY.getPool(\n            _token0,\n            _token1,\n            _fee\n        );\n    }\n\n    /**\n    * @dev Validates if the given token address\n    * is one of the two specified token addresses.\n    */\n    function _validateTokenAddress(\n        address _tokenAddress,\n        address _token0,\n        address _token1\n    )\n        internal\n        pure\n    {\n        if (_tokenAddress == ZERO_ADDRESS) {\n            revert ZeroAddressNotAllowed();\n        }\n\n        if (_tokenAddress != _token0 && _tokenAddress != _token1) {\n            revert TokenAddressMismatch();\n        }\n    }\n\n    /**\n    * @dev Validates if the given pool\n    * address matches the expected pool address.\n    */\n    function _validatePoolAddress(\n        address _pool,\n        address _expectedPool\n    )\n        internal\n        pure\n    {\n        if (_pool == ZERO_ADDRESS) {\n            revert PoolDoesNotExist();\n        }\n\n        if (_pool != _expectedPool) {\n            revert PoolAddressMismatch();\n        }\n    }\n\n    /**\n    * @dev Validates if the price feed for\n    * a given token address is set.\n    */\n    function _validatePriceFeed(\n        address _tokenAddress\n    )\n        internal\n        view\n    {\n        if (priceFeed[_tokenAddress] == ZERO_FEED) {\n            revert ChainLinkOracleNotSet();\n        }\n    }\n\n    /**\n    * @dev Validates if the TWAP oracle for\n    * a given token address is already set.\n    */\n    function _validateTwapOracle(\n        address _tokenAddress\n    )\n        internal\n        view\n    {\n        if (uniTwapPoolInfo[_tokenAddress].oracle > ZERO_ADDRESS) {\n            revert TwapOracleAlreadySet();\n        }\n    }\n\n    /**\n     * @dev Returns twapPrice by passing\n     * the underlying token address.\n     */\n    function _getTwapPrice(\n        address _tokenAddress,\n        address _oracle\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        return OracleLibrary.getQuoteAtTick(\n            _getAverageTick(\n                _oracle\n            ),\n            _getOneUnit(\n                _tokenAddress\n            ),\n            _tokenAddress,\n            WETH_ADDRESS\n        );\n    }\n\n    function _getOneUnit(\n        address _tokenAddress\n    )\n        internal\n        view\n        returns (uint128)\n    {\n        return uint128(\n            10 ** _tokenDecimals[_tokenAddress]\n        );\n    }\n\n    function _getAverageTick(\n        address _oracle\n    )\n        internal\n        view\n        returns (int24)\n    {\n        uint32[] memory secondsAgo = new uint32[](\n            2\n        );\n\n        secondsAgo[0] = TWAP_PERIOD;\n        secondsAgo[1] = 0;\n\n        (\n            int56[] memory tickCumulatives\n            ,\n        ) = IUniswapV3Pool(_oracle).observe(\n            secondsAgo\n        );\n\n        int56 twapPeriodInt56 = int56(\n            int32(TWAP_PERIOD)\n        );\n\n        int56 tickCumulativesDelta = tickCumulatives[1]\n            - tickCumulatives[0];\n\n        int24 tick = int24(\n            tickCumulativesDelta\n            / twapPeriodInt56\n        );\n\n        if (tickCumulativesDelta < 0 && (tickCumulativesDelta % twapPeriodInt56 != 0)) {\n            tick--;\n        }\n\n        return tick;\n    }\n\n    /**\n     * @dev Returns priceFeed decimals by\n     * passing the underlying token address.\n     */\n    function decimals(\n        address _tokenAddress\n    )\n        public\n        view\n        returns (uint8)\n    {\n        return priceFeed[_tokenAddress].decimals();\n    }\n\n    function _getTwapDerivatePrice(\n        address _tokenAddress,\n        UniTwapPoolInfo memory _uniTwapPoolInfo\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        DerivativePartnerInfo memory partnerInfo = derivativePartnerTwap[\n            _tokenAddress\n        ];\n\n        uint256 firstQuote = OracleLibrary.getQuoteAtTick(\n            _getAverageTick(\n                _uniTwapPoolInfo.oracle\n            ),\n            _getOneUnit(\n                partnerInfo.partnerTokenAddress\n            ),\n            partnerInfo.partnerTokenAddress,\n            WETH_ADDRESS\n        );\n\n        uint256 secondQuote = OracleLibrary.getQuoteAtTick(\n            _getAverageTick(\n                partnerInfo.partnerOracleAddress\n            ),\n            _getOneUnit(\n                _tokenAddress\n            ),\n            _tokenAddress,\n            partnerInfo.partnerTokenAddress\n        );\n\n        return firstQuote\n            * secondQuote\n            / uint256(\n                _getOneUnit(\n                    partnerInfo.partnerTokenAddress\n                )\n            );\n    }\n\n    /**\n     * @dev Stores expected heartbeat\n     * value for a pricing feed token.\n     */\n    function _recalibrate(\n        address _tokenAddress\n    )\n        internal\n    {\n        heartBeat[_tokenAddress] = _recalibratePreview(\n            _tokenAddress\n        );\n    }\n\n    /**\n     * @dev Check if chainLink\n     * squencer is wroking.\n     */\n    function sequencerIsDead()\n        public\n        view\n        returns (bool)\n    {\n        if (IS_ARBITRUM_CHAIN == false) {\n            return false;\n        }\n\n        (\n            ,\n            int256 answer,\n            uint256 startedAt,\n            ,\n        ) = SEQUENCER.latestRoundData();\n\n        if (answer == 1) {\n            return true;\n        }\n\n        uint256 timeSinceUp = block.timestamp\n            - startedAt;\n\n        if (timeSinceUp <= GRACE_PEROID) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * @dev Check if chainLink feed was\n     * updated within expected timeFrame\n     * for single {_tokenAddress}.\n     */\n    function _chainLinkIsDead(\n        address _tokenAddress\n    )\n        internal\n        view\n        returns (bool)\n    {\n        // @TODO: Add a check for TWAP comparison on 2.5%\n        // if TWAP exists for the token.\n\n        if (heartBeat[_tokenAddress] == 0) {\n            revert HeartBeatNotSet();\n        }\n\n        uint80 latestRoundId = getLatestRoundId(\n            _tokenAddress\n        );\n\n        uint256 upd = _getRoundTimestamp(\n            _tokenAddress,\n            latestRoundId\n        );\n\n        unchecked {\n            upd = block.timestamp < upd\n                ? block.timestamp\n                : block.timestamp - upd;\n\n            return upd > heartBeat[_tokenAddress];\n        }\n    }\n\n    /**\n     * @dev Recalibrates expected\n     * heartbeat for a pricing feed.\n     */\n    function _recalibratePreview(\n        address _tokenAddress\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint80 latestRoundId = getLatestRoundId(\n            _tokenAddress\n        );\n\n        uint256 latestTimestamp = _getRoundTimestamp(\n            _tokenAddress,\n            latestRoundId\n        );\n\n        uint80 iterationCount = _getIterationCount(\n            latestRoundId\n        );\n\n        if (iterationCount < MIN_ITERATION_COUNT) {\n            revert SampleTooSmall(\n                {\n                    size: iterationCount\n                }\n            );\n        }\n\n        uint80 i = 1;\n        uint256 currentDiff;\n        uint256 currentBiggest;\n        uint256 currentSecondBiggest;\n\n        while (i < iterationCount) {\n\n            uint256 currentTimestamp = _getRoundTimestamp(\n                _tokenAddress,\n                latestRoundId - i\n            );\n\n            currentDiff = latestTimestamp\n                - currentTimestamp;\n\n            latestTimestamp = currentTimestamp;\n\n            if (currentDiff >= currentBiggest) {\n\n                currentSecondBiggest = currentBiggest;\n                currentBiggest = currentDiff;\n\n            } else if (currentDiff > currentSecondBiggest) {\n                currentSecondBiggest = currentDiff;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return currentSecondBiggest;\n    }\n\n    /**\n     * @dev Determines number of iterations\n     * needed during heartbeat recalibration.\n     */\n    function _getIterationCount(\n        uint80 _latestAggregatorRoundId\n    )\n        internal\n        pure\n        returns (uint80 res)\n    {\n        res = _latestAggregatorRoundId < MAX_ROUND_COUNT\n            ? _latestAggregatorRoundId\n            : MAX_ROUND_COUNT;\n    }\n\n    /**\n     * @dev Fetches timestamp of a byteshifted\n     * aggregatorRound with specific _roundId.\n     */\n    function _getRoundTimestamp(\n        address _tokenAddress,\n        uint80 _roundId\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        (\n            ,\n            ,\n            ,\n            uint256 timestamp\n            ,\n        ) = priceFeed[_tokenAddress].getRoundData(\n                _roundId\n            );\n\n        return timestamp;\n    }\n\n    /**\n     * @dev Routing latest round data from chainLink.\n     * Returns latestRoundData by passing underlying token address.\n     */\n    function getLatestRoundId(\n        address _tokenAddress\n    )\n        public\n        view\n        returns (\n            uint80 roundId\n        )\n    {\n        (\n            roundId\n            ,\n            ,\n            ,\n            ,\n        ) = priceFeed[_tokenAddress].latestRoundData();\n    }\n}"
    },
    {
      "filename": "contracts/WiseOracleHub/OracleHelper.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\nimport \"./Declarations.sol\";\n\nabstract contract OracleHelper is Declarations {\n\n    /**\n     * @dev Adds priceFeed for a given token.\n     */\n    function _addOracle(\n        address _tokenAddress,\n        IPriceFeed _priceFeedAddress,\n        address[] calldata _underlyingFeedTokens\n    )\n        internal\n    {\n        if (priceFeed[_tokenAddress] > ZERO_FEED) {\n            revert OracleAlreadySet();\n        }\n\n        priceFeed[_tokenAddress] = _priceFeedAddress;\n\n        _tokenDecimals[_tokenAddress] = IERC20(\n            _tokenAddress\n        ).decimals();\n\n        underlyingFeedTokens[_tokenAddress] = _underlyingFeedTokens;\n    }\n\n    function _addAggregator(\n        address _tokenAddress\n    )\n        internal\n    {\n        IAggregator tokenAggregator = IAggregator(\n            priceFeed[_tokenAddress].aggregator()\n        );\n\n        if (tokenAggregatorFromTokenAddress[_tokenAddress] > ZERO_AGGREGATOR) {\n            revert AggregatorAlreadySet();\n        }\n\n        if (_checkFunctionExistence(address(tokenAggregator)) == false) {\n            revert FunctionDoesntExist();\n        }\n\n        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[\n            _tokenAddress\n        ];\n\n        if (uniTwapPoolInfoStruct.oracle > ZERO_ADDRESS) {\n            revert AggregatorNotNecessary();\n        }\n\n        tokenAggregatorFromTokenAddress[_tokenAddress] = tokenAggregator;\n    }\n\n    function _checkFunctionExistence(\n        address _tokenAggregator\n    )\n        internal\n        returns (bool)\n    {\n        uint256 size;\n\n        assembly {\n            size := extcodesize(\n                _tokenAggregator\n            )\n        }\n\n        if (size == 0) {\n            return false;\n        }\n\n        (bool success, ) = _tokenAggregator.call(\n            abi.encodeWithSignature(\n                \"maxAnswer()\"\n            )\n        );\n\n        return success;\n    }\n\n    function _compareMinMax(\n        IAggregator _tokenAggregator,\n        int192 _answer\n    )\n        internal\n        view\n    {\n        int192 maxAnswer = _tokenAggregator.maxAnswer();\n        int192 minAnswer = _tokenAggregator.minAnswer();\n\n        if (_answer > maxAnswer || _answer < minAnswer) {\n            revert OracleIsDead();\n        }\n    }\n\n    /**\n     * @dev Returns Twaps latest USD value\n     * by passing the underlying token address.\n     */\n    function latestResolverTwap(\n        address _tokenAddress\n    )\n        public\n        view\n        returns (uint256)\n    {\n        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[\n            _tokenAddress\n        ];\n\n        if (uniTwapPoolInfoStruct.isUniPool == true) {\n\n            return _getTwapPrice(\n                _tokenAddress,\n                uniTwapPoolInfoStruct.oracle\n            ) / 10 ** (_decimalsWETH - decimals(_tokenAddress));\n        }\n\n        return _getTwapDerivatePrice(\n            _tokenAddress,\n            uniTwapPoolInfoStruct\n        ) / 10 ** (_decimalsWETH - decimals(_tokenAddress));\n    }\n\n    function _validateAnswer(\n        address _tokenAddress\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[\n            _tokenAddress\n        ];\n\n        uint256 fetchTwapValue;\n\n        if (uniTwapPoolInfoStruct.oracle > ZERO_ADDRESS) {\n            fetchTwapValue = latestResolverTwap(\n                _tokenAddress\n            );\n        }\n\n        uint256 answer = _getChainlinkAnswer(\n            _tokenAddress\n        );\n\n        if (tokenAggregatorFromTokenAddress[_tokenAddress] > ZERO_AGGREGATOR) {\n            _compareMinMax(\n                tokenAggregatorFromTokenAddress[_tokenAddress],\n                int192(uint192(answer))\n            );\n        }\n\n        if (fetchTwapValue > 0) {\n\n            uint256 relativeDifference = _getRelativeDifference(\n                answer,\n                fetchTwapValue\n            );\n\n            _compareDifference(\n                relativeDifference\n            );\n        }\n\n        return answer;\n    }\n\n    /**\n     * @dev Adds uniTwapPoolInfo for a given token.\n     */\n    function _writeUniTwapPoolInfoStruct(\n        address _tokenAddress,\n        address _oracle,\n        bool _isUniPool\n    )\n        internal\n    {\n        uniTwapPoolInfo[_tokenAddress] = UniTwapPoolInfo({\n            oracle: _oracle,\n            isUniPool: _isUniPool\n        });\n    }\n\n    /**\n     * @dev Adds uniTwapPoolInfo for a given token and its derivative.\n     */\n    function _writeUniTwapPoolInfoStructDerivative(\n        address _tokenAddress,\n        address _partnerTokenAddress,\n        address _oracleAddress,\n        address _partnerOracleAddress,\n        bool _isUniPool\n    )\n        internal\n    {\n        _writeUniTwapPoolInfoStruct(\n            _tokenAddress,\n            _oracleAddress,\n            _isUniPool\n        );\n\n        derivativePartnerTwap[_tokenAddress] = DerivativePartnerInfo(\n            _partnerTokenAddress,\n            _partnerOracleAddress\n        );\n    }\n\n    function _getRelativeDifference(\n        uint256 _answerUint256,\n        uint256 _fetchTwapValue\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        if (_answerUint256 > _fetchTwapValue) {\n            return _answerUint256\n                * PRECISION_FACTOR_E4\n                / _fetchTwapValue;\n        }\n\n        return _fetchTwapValue\n            * PRECISION_FACTOR_E4\n            / _answerUint256;\n    }\n\n    function _compareDifference(\n        uint256 _relativeDifference\n    )\n        internal\n        view\n    {\n        if (_relativeDifference > ALLOWED_DIFFERENCE) {\n            revert OraclesDeviate();\n        }\n    }\n\n    function _getChainlinkAnswer(\n        address _tokenAddress\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        (\n            ,\n            int256 answer,\n            ,\n            ,\n        ) = priceFeed[_tokenAddress].latestRoundData();\n\n        return uint256(\n            answer\n        );\n    }\n\n    function getETHPriceInUSD()\n        public\n        view\n        returns (uint256)\n    {\n        if (_chainLinkIsDead(ETH_USD_PLACEHOLDER) == true) {\n            revert OracleIsDead();\n        }\n\n        return _validateAnswer(\n            ETH_USD_PLACEHOLDER\n        );\n    }\n\n    /**\n    * @dev Retrieves the pool address for given\n    * tokens and fee from Uniswap V3 Factory.\n    */\n    function _getPool(\n        address _token0,\n        address _token1,\n        uint24 _fee\n    )\n        internal\n        view\n        returns (address pool)\n    {\n        return UNI_V3_FACTORY.getPool(\n            _token0,\n            _token1,\n            _fee\n        );\n    }\n\n    /**\n    * @dev Validates if the given token address\n    * is one of the two specified token addresses.\n    */\n    function _validateTokenAddress(\n        address _tokenAddress,\n        address _token0,\n        address _token1\n    )\n        internal\n        pure\n    {\n        if (_tokenAddress == ZERO_ADDRESS) {\n            revert ZeroAddressNotAllowed();\n        }\n\n        if (_tokenAddress != _token0 && _tokenAddress != _token1) {\n            revert TokenAddressMismatch();\n        }\n    }\n\n    /**\n    * @dev Validates if the given pool\n    * address matches the expected pool address.\n    */\n    function _validatePoolAddress(\n        address _pool,\n        address _expectedPool\n    )\n        internal\n        pure\n    {\n        if (_pool == ZERO_ADDRESS) {\n            revert PoolDoesNotExist();\n        }\n\n        if (_pool != _expectedPool) {\n            revert PoolAddressMismatch();\n        }\n    }\n\n    /**\n    * @dev Validates if the price feed for\n    * a given token address is set.\n    */\n    function _validatePriceFeed(\n        address _tokenAddress\n    )\n        internal\n        view\n    {\n        if (priceFeed[_tokenAddress] == ZERO_FEED) {\n            revert ChainLinkOracleNotSet();\n        }\n    }\n\n    /**\n    * @dev Validates if the TWAP oracle for\n    * a given token address is already set.\n    */\n    function _validateTwapOracle(\n        address _tokenAddress\n    )\n        internal\n        view\n    {\n        if (uniTwapPoolInfo[_tokenAddress].oracle > ZERO_ADDRESS) {\n            revert TwapOracleAlreadySet();\n        }\n    }\n\n    /**\n     * @dev Returns twapPrice by passing\n     * the underlying token address.\n     */\n    function _getTwapPrice(\n        address _tokenAddress,\n        address _oracle\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        return OracleLibrary.getQuoteAtTick(\n            _getAverageTick(\n                _oracle\n            ),\n            _getOneUnit(\n                _tokenAddress\n            ),\n            _tokenAddress,\n            WETH_ADDRESS\n        );\n    }\n\n    function _getOneUnit(\n        address _tokenAddress\n    )\n        internal\n        view\n        returns (uint128)\n    {\n        return uint128(\n            10 ** _tokenDecimals[_tokenAddress]\n        );\n    }\n\n    function _getAverageTick(\n        address _oracle\n    )\n        internal\n        view\n        returns (int24)\n    {\n        uint32[] memory secondsAgo = new uint32[](\n            2\n        );\n\n        secondsAgo[0] = TWAP_PERIOD;\n        secondsAgo[1] = 0;\n\n        (\n            int56[] memory tickCumulatives\n            ,\n        ) = IUniswapV3Pool(_oracle).observe(\n            secondsAgo\n        );\n\n        int56 twapPeriodInt56 = int56(\n            int32(TWAP_PERIOD)\n        );\n\n        int56 tickCumulativesDelta = tickCumulatives[1]\n            - tickCumulatives[0];\n\n        int24 tick = int24(\n            tickCumulativesDelta\n            / twapPeriodInt56\n        );\n\n        if (tickCumulativesDelta < 0 && (tickCumulativesDelta % twapPeriodInt56 != 0)) {\n            tick--;\n        }\n\n        return tick;\n    }\n\n    /**\n     * @dev Returns priceFeed decimals by\n     * passing the underlying token address.\n     */\n    function decimals(\n        address _tokenAddress\n    )\n        public\n        view\n        returns (uint8)\n    {\n        return priceFeed[_tokenAddress].decimals();\n    }\n\n    function _getTwapDerivatePrice(\n        address _tokenAddress,\n        UniTwapPoolInfo memory _uniTwapPoolInfo\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        DerivativePartnerInfo memory partnerInfo = derivativePartnerTwap[\n            _tokenAddress\n        ];\n\n        uint256 firstQuote = OracleLibrary.getQuoteAtTick(\n            _getAverageTick(\n                _uniTwapPoolInfo.oracle\n            ),\n            _getOneUnit(\n                partnerInfo.partnerTokenAddress\n            ),\n            partnerInfo.partnerTokenAddress,\n            WETH_ADDRESS\n        );\n\n        uint256 secondQuote = OracleLibrary.getQuoteAtTick(\n            _getAverageTick(\n                partnerInfo.partnerOracleAddress\n            ),\n            _getOneUnit(\n                _tokenAddress\n            ),\n            _tokenAddress,\n            partnerInfo.partnerTokenAddress\n        );\n\n        return firstQuote\n            * secondQuote\n            / uint256(\n                _getOneUnit(\n                    partnerInfo.partnerTokenAddress\n                )\n            );\n    }\n\n    /**\n     * @dev Stores expected heartbeat\n     * value for a pricing feed token.\n     */\n    function _recalibrate(\n        address _tokenAddress\n    )\n        internal\n    {\n        heartBeat[_tokenAddress] = _recalibratePreview(\n            _tokenAddress\n        );\n    }\n\n    /**\n     * @dev Check if chainLink\n     * squencer is wroking.\n     */\n    function sequencerIsDead()\n        public\n        view\n        returns (bool)\n    {\n        if (IS_ARBITRUM_CHAIN == false) {\n            return false;\n        }\n\n        (\n            ,\n            int256 answer,\n            uint256 startedAt,\n            ,\n        ) = SEQUENCER.latestRoundData();\n\n        if (answer == 1) {\n            return true;\n        }\n\n        uint256 timeSinceUp = block.timestamp\n            - startedAt;\n\n        if (timeSinceUp <= GRACE_PEROID) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * @dev Check if chainLink feed was\n     * updated within expected timeFrame\n     * for single {_tokenAddress}.\n     */\n    function _chainLinkIsDead(\n        address _tokenAddress\n    )\n        internal\n        view\n        returns (bool)\n    {\n        // @TODO: Add a check for TWAP comparison on 2.5%\n        // if TWAP exists for the token.\n\n        if (heartBeat[_tokenAddress] == 0) {\n            revert HeartBeatNotSet();\n        }\n\n        uint80 latestRoundId = getLatestRoundId(\n            _tokenAddress\n        );\n\n        uint256 upd = _getRoundTimestamp(\n            _tokenAddress,\n            latestRoundId\n        );\n\n        unchecked {\n            upd = block.timestamp < upd\n                ? block.timestamp\n                : block.timestamp - upd;\n\n            return upd > heartBeat[_tokenAddress];\n        }\n    }\n\n    /**\n     * @dev Recalibrates expected\n     * heartbeat for a pricing feed.\n     */\n    function _recalibratePreview(\n        address _tokenAddress\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint80 latestRoundId = getLatestRoundId(\n            _tokenAddress\n        );\n\n        uint256 latestTimestamp = _getRoundTimestamp(\n            _tokenAddress,\n            latestRoundId\n        );\n\n        uint80 iterationCount = _getIterationCount(\n            latestRoundId\n        );\n\n        if (iterationCount < MIN_ITERATION_COUNT) {\n            revert SampleTooSmall(\n                {\n                    size: iterationCount\n                }\n            );\n        }\n\n        uint80 i = 1;\n        uint256 currentDiff;\n        uint256 currentBiggest;\n        uint256 currentSecondBiggest;\n\n        while (i < iterationCount) {\n\n            uint256 currentTimestamp = _getRoundTimestamp(\n                _tokenAddress,\n                latestRoundId - i\n            );\n\n            currentDiff = latestTimestamp\n                - currentTimestamp;\n\n            latestTimestamp = currentTimestamp;\n\n            if (currentDiff >= currentBiggest) {\n\n                currentSecondBiggest = currentBiggest;\n                currentBiggest = currentDiff;\n\n            } else if (currentDiff > currentSecondBiggest) {\n                currentSecondBiggest = currentDiff;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return currentSecondBiggest;\n    }\n\n    /**\n     * @dev Determines number of iterations\n     * needed during heartbeat recalibration.\n     */\n    function _getIterationCount(\n        uint80 _latestAggregatorRoundId\n    )\n        internal\n        pure\n        returns (uint80 res)\n    {\n        res = _latestAggregatorRoundId < MAX_ROUND_COUNT\n            ? _latestAggregatorRoundId\n            : MAX_ROUND_COUNT;\n    }\n\n    /**\n     * @dev Fetches timestamp of a byteshifted\n     * aggregatorRound with specific _roundId.\n     */\n    function _getRoundTimestamp(\n        address _tokenAddress,\n        uint80 _roundId\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        (\n            ,\n            ,\n            ,\n            uint256 timestamp\n            ,\n        ) = priceFeed[_tokenAddress].getRoundData(\n                _roundId\n            );\n\n        return timestamp;\n    }\n\n    /**\n     * @dev Routing latest round data from chainLink.\n     * Returns latestRoundData by passing underlying token address.\n     */\n    function getLatestRoundId(\n        address _tokenAddress\n    )\n        public\n        view\n        returns (\n            uint80 roundId\n        )\n    {\n        (\n            roundId\n            ,\n            ,\n            ,\n            ,\n        ) = priceFeed[_tokenAddress].latestRoundData();\n    }\n}"
    },
    {
      "filename": "contracts/WiseOracleHub/OracleHelper.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\nimport \"./Declarations.sol\";\n\nabstract contract OracleHelper is Declarations {\n\n    /**\n     * @dev Adds priceFeed for a given token.\n     */\n    function _addOracle(\n        address _tokenAddress,\n        IPriceFeed _priceFeedAddress,\n        address[] calldata _underlyingFeedTokens\n    )\n        internal\n    {\n        if (priceFeed[_tokenAddress] > ZERO_FEED) {\n            revert OracleAlreadySet();\n        }\n\n        priceFeed[_tokenAddress] = _priceFeedAddress;\n\n        _tokenDecimals[_tokenAddress] = IERC20(\n            _tokenAddress\n        ).decimals();\n\n        underlyingFeedTokens[_tokenAddress] = _underlyingFeedTokens;\n    }\n\n    function _addAggregator(\n        address _tokenAddress\n    )\n        internal\n    {\n        IAggregator tokenAggregator = IAggregator(\n            priceFeed[_tokenAddress].aggregato"
    }
  ]
}