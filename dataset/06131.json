{
  "Title": "[M-09] Users can self-follow via `FollowNFT::tryMigrate()` on Lens V2",
  "Content": "\nUsers are not supposed to be able to self-follow on Lens v2, but they are able to bypass the restriction. This can also affect modules or newer functionalities that count on this behaviour.\n\nMigration is an [Area of specific concern](https://github.com/code-423n4/2023-07-lens#areas-of-specific-concern) for the devs, and this can easily be prevented with a simple check.\n\nThis can't be undone without any upgrade.\n\n### Proof of Concept\n\n`FollowLib::follow()` has a specific restriction to revert when a user tries to self-follow on Lens v2:\n\n```solidity\n    if (followerProfileId == idsOfProfilesToFollow[i]) {\n        revert Errors.SelfFollow();\n    }\n```\n\n[FollowLib.sol#L35-L37](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/libraries/FollowLib.sol#L35-L37)\n\nHowever, users that own a follow NFT from V1 can execute `FollowNFT::tryMigrate()` to self-follow on V2, as there is no restriction to prevent it. A test proving it can be found on the next section.\n\n[FollowNFT.sol#L480-L520](https://github.com/code-423n4/2023-07-lens/blob/main/contracts/FollowNFT.sol#L480-L520)\n\n### Coded POC\n\nAdd this test to `test/migrations/Migrations.t.sol` and run `TESTING_FORK=mainnet POLYGON_RPC_URL=\"https://polygon.llamarpc.com\" forge test --mt \"testSelfFollow\"`.\n\nNote: In case of a memory allocation error during the Forge test, please comment [these lines](https://github.com/code-423n4/2023-07-lens/blob/main/test/migrations/Migrations.t.sol#L105-L116). They are not used for the current test.\n\n```solidity\n    function testSelfFollow() public onlyFork {\n        uint256 selfFollowProfileId = 3659; // juancito.lens\n        uint256 selfFollowTokenId = 42;     // juancito.lens follows juancito.lens on V1\n\n        FollowNFT nft = FollowNFT(hub.getProfile(selfFollowProfileId).followNFT);\n        address user = nft.ownerOf(selfFollowTokenId); // Owner of juancito.lens\n\n        // 1. Migrate the self-follow\n        uint256[] memory selfFollowProfileIdArray = new uint256[](1);\n        uint256[] memory selfFollowTokenIdArray = new uint256[](1);\n\n        selfFollowProfileIdArray[0] = selfFollowProfileId; // 3659\n        selfFollowTokenIdArray[0] = selfFollowTokenId;     // 42\n\n        hub.batchMigrateFollows(selfFollowProfileIdArray, selfFollowProfileIdArray, selfFollowTokenIdArray);\n\n        // 2. The user is self-following on V2\n        assertTrue(nft.isFollowing(selfFollowProfileId));\n    }\n```\n\n### Recommended Mitigation Steps\n\nAdd the following validation to `FollowNFT::tryMigrate()`:\n\n```diff\n+    if (followerProfileId == _followedProfileId) {\n+        return 0;\n+    }\n```\n\n### Assessed type\n\nInvalid Validation\n\n**[vicnaum (Lens) confirmed and commented](https://github.com/code-423n4/2023-07-lens-findings/issues/106#issuecomment-1668156711):**\n > This seems like a sub-case of [issue 112](https://github.com/code-423n4/2023-07-lens-findings/issues/112).<br>\n> (But the mitigation is different for this case)\n\n**[Picodes (judge) commented](https://github.com/code-423n4/2023-07-lens-findings/issues/106#issuecomment-1695960517):**\n > The impact is the same but the issue seems different, as the mitigation suggested by `#112` wouldn't prevent this from happening.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-07-lens",
  "Code": [
    {
      "filename": "contracts/libraries/FollowLib.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport {IFollowModule} from 'contracts/interfaces/IFollowModule.sol';\nimport {ValidationLib} from 'contracts/libraries/ValidationLib.sol';\nimport {Types} from 'contracts/libraries/constants/Types.sol';\nimport {Errors} from 'contracts/libraries/constants/Errors.sol';\nimport {Events} from 'contracts/libraries/constants/Events.sol';\nimport {StorageLib} from 'contracts/libraries/StorageLib.sol';\nimport {IFollowNFT} from 'contracts/interfaces/IFollowNFT.sol';\nimport {FollowNFTProxy} from 'contracts/base/upgradeability/FollowNFTProxy.sol';\n\nlibrary FollowLib {\n    function follow(\n        uint256 followerProfileId,\n        address transactionExecutor,\n        uint256[] calldata idsOfProfilesToFollow,\n        uint256[] calldata followTokenIds,\n        bytes[] calldata followModuleDatas\n    ) external returns (uint256[] memory) {\n        if (\n            idsOfProfilesToFollow.length != followTokenIds.length ||\n            idsOfProfilesToFollow.length != followModuleDatas.length\n        ) {\n            revert Errors.ArrayMismatch();\n        }\n        uint256[] memory followTokenIdsAssigned = new uint256[](idsOfProfilesToFollow.length);\n        uint256 i;\n        while (i < idsOfProfilesToFollow.length) {\n            ValidationLib.validateProfileExists({profileId: idsOfProfilesToFollow[i]});\n\n            ValidationLib.validateNotBlocked({profile: followerProfileId, byProfile: idsOfProfilesToFollow[i]});\n\n            if (followerProfileId == idsOfProfilesToFollow[i]) {\n                revert Errors.SelfFollow();\n            }\n\n            followTokenIdsAssigned[i] = _follow({\n                followerProfileId: followerProfileId,\n                transactionExecutor: transactionExecutor,\n                idOfProfileToFollow: idsOfProfilesToFollow[i],\n                followTokenId: followTokenIds[i],\n                followModuleData: followModuleDatas[i]\n            });\n\n            unchecked {\n                ++i;\n            }\n        }\n        return followTokenIdsAssigned;\n    }\n\n    function unfollow(\n        uint256 unfollowerProfileId,\n        address transactionExecutor,\n        uint256[] calldata idsOfProfilesToUnfollow\n    ) external {\n        uint256 i;\n        while (i < idsOfProfilesToUnfollow.length) {\n            uint256 idOfProfileToUnfollow = idsOfProfilesToUnfollow[i];\n            ValidationLib.validateProfileExists(idOfProfileToUnfollow);\n\n            address followNFT = StorageLib.getProfile(idOfProfileToUnfollow).followNFT;\n\n            if (followNFT == address(0)) {\n                revert Errors.NotFollowing();\n            }\n\n            IFollowNFT(followNFT).unfollow({\n                unfollowerProfileId: unfollowerProfileId,\n                transactionExecutor: transactionExecutor\n            });\n\n            emit Events.Unfollowed(unfollowerProfileId, idOfProfileToUnfollow, block.timestamp);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Deploys the given profile's Follow NFT contract.\n     *\n     * @param profileId The token ID of the profile which Follow NFT should be deployed.\n     *\n     * @return address The address of the deployed Follow NFT contract.\n     */\n    function _deployFollowNFT(uint256 profileId) private returns (address) {\n        bytes memory functionData = abi.encodeWithSelector(IFollowNFT.initialize.selector, profileId);\n        address followNFT = address(new FollowNFTProxy(functionData));\n        emit Events.FollowNFTDeployed(profileId, followNFT, block.timestamp);\n\n        return followNFT;\n    }\n\n    function _follow(\n        uint256 followerProfileId,\n        address transactionExecutor,\n        uint256 idOfProfileToFollow,\n        uint256 followTokenId,\n        bytes calldata followModuleData\n    ) private returns (uint256) {\n        Types.Profile storage _profileToFollow = StorageLib.getProfile(idOfProfileToFollow);\n\n        address followNFT = _profileToFollow.followNFT;\n        if (followNFT == address(0)) {\n            followNFT = _deployFollowNFT(idOfProfileToFollow);\n            _profileToFollow.followNFT = followNFT;\n        }\n\n        uint256 followTokenIdAssigned = IFollowNFT(followNFT).follow({\n            followerProfileId: followerProfileId,\n            transactionExecutor: transactionExecutor,\n            followTokenId: followTokenId\n        });\n\n        bytes memory processFollowModuleReturnData;\n        address followModule = _profileToFollow.followModule;\n        if (followModule != address(0)) {\n            processFollowModuleReturnData = IFollowModule(followModule).processFollow(\n                followerProfileId,\n                followTokenId,\n                transactionExecutor,\n                idOfProfileToFollow,\n                followModuleData\n            );\n        }\n\n        emit Events.Followed(\n            followerProfileId,\n            idOfProfileToFollow,\n            followTokenIdAssigned,\n            followModuleData,\n            processFollowModuleReturnData,\n            block.timestamp\n        );\n\n        return followTokenIdAssigned;\n    }\n}"
    },
    {
      "filename": "contracts/FollowNFT.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport {Types} from 'contracts/libraries/constants/Types.sol';\nimport {ERC2981CollectionRoyalties} from 'contracts/base/ERC2981CollectionRoyalties.sol';\nimport {Errors} from 'contracts/libraries/constants/Errors.sol';\nimport {HubRestricted} from 'contracts/base/HubRestricted.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport {IERC721Timestamped} from 'contracts/interfaces/IERC721Timestamped.sol';\nimport {IFollowNFT} from 'contracts/interfaces/IFollowNFT.sol';\nimport {ILensHub} from 'contracts/interfaces/ILensHub.sol';\nimport {LensBaseERC721} from 'contracts/base/LensBaseERC721.sol';\nimport {Strings} from '@openzeppelin/contracts/utils/Strings.sol';\nimport {StorageLib} from 'contracts/libraries/StorageLib.sol';\nimport {FollowTokenURILib} from 'contracts/libraries/token-uris/FollowTokenURILib.sol';\n\ncontract FollowNFT is HubRestricted, LensBaseERC721, ERC2981CollectionRoyalties, IFollowNFT {\n    using Strings for uint256;\n\n    string constant FOLLOW_NFT_NAME_SUFFIX = '-Follower';\n    string constant FOLLOW_NFT_SYMBOL_SUFFIX = '-Fl';\n\n    uint256[5] ___DEPRECATED_SLOTS; // Deprecated slots, previously used for delegations.\n    uint256 internal _followedProfileId;\n\n    // Old uint256 `_lastFollowTokenId` slot splitted into two uint128s to include `_followerCount`.\n    uint128 internal _lastFollowTokenId;\n    // `_followerCount` will not be decreased when a follower profile is burned, making the counter not fully accurate.\n    // New variable added in V2 in the same slot, lower-ordered to not conflict with previous storage layout.\n    uint128 internal _followerCount;\n\n    bool private _initialized;\n\n    // Introduced in v2\n    mapping(uint256 => Types.FollowData) internal _followDataByFollowTokenId;\n    mapping(uint256 => uint256) internal _followTokenIdByFollowerProfileId;\n    mapping(uint256 => uint256) internal _followApprovalByFollowTokenId;\n    uint256 internal _royaltiesInBasisPoints;\n\n    event FollowApproval(uint256 indexed followerProfileId, uint256 indexed followTokenId);\n\n    constructor(address hub) HubRestricted(hub) {\n        _initialized = true;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function initialize(uint256 profileId) external override {\n        // This is called right after deployment by the LensHub, so we can skip the onlyHub check.\n        if (_initialized) {\n            revert Errors.Initialized();\n        }\n        _initialized = true;\n        _followedProfileId = profileId;\n        _setRoyalty(1000); // 10% of royalties\n    }\n\n    /// @inheritdoc IFollowNFT\n    function follow(\n        uint256 followerProfileId,\n        address transactionExecutor,\n        uint256 followTokenId\n    ) external override onlyHub returns (uint256) {\n        if (_followTokenIdByFollowerProfileId[followerProfileId] != 0) {\n            revert AlreadyFollowing();\n        }\n\n        if (followTokenId == 0) {\n            // Fresh follow.\n            return _followMintingNewToken(followerProfileId);\n        }\n\n        address followTokenOwner = _unsafeOwnerOf(followTokenId);\n        if (followTokenOwner != address(0)) {\n            // Provided follow token is wrapped.\n            return\n                _followWithWrappedToken({\n                    followerProfileId: followerProfileId,\n                    transactionExecutor: transactionExecutor,\n                    followTokenId: followTokenId,\n                    followTokenOwner: followTokenOwner\n                });\n        }\n\n        uint256 currentFollowerProfileId = _followDataByFollowTokenId[followTokenId].followerProfileId;\n        if (currentFollowerProfileId != 0) {\n            // Provided follow token is unwrapped.\n            // It has a follower profile set already, it can only be used to follow if that profile was burnt.\n            return\n                _followWithUnwrappedTokenFromBurnedProfile({\n                    followerProfileId: followerProfileId,\n                    followTokenId: followTokenId,\n                    currentFollowerProfileId: currentFollowerProfileId\n                });\n        }\n\n        // Provided follow token does not exist anymore, it can only be used if the profile attempting to follow is\n        // allowed to recover it.\n        return _followByRecoveringToken({followerProfileId: followerProfileId, followTokenId: followTokenId});\n    }\n\n    /// @inheritdoc IFollowNFT\n    function unfollow(uint256 unfollowerProfileId, address transactionExecutor) external override onlyHub {\n        uint256 followTokenId = _followTokenIdByFollowerProfileId[unfollowerProfileId];\n        if (followTokenId == 0) {\n            revert NotFollowing();\n        }\n        address followTokenOwner = _unsafeOwnerOf(followTokenId);\n        if (followTokenOwner == address(0)) {\n            // Follow token is unwrapped.\n            // Unfollowing and allowing recovery.\n            _unfollow({unfollower: unfollowerProfileId, followTokenId: followTokenId});\n            _followDataByFollowTokenId[followTokenId].profileIdAllowedToRecover = unfollowerProfileId;\n        } else {\n            // Follow token is wrapped.\n            address unfollowerProfileOwner = IERC721(HUB).ownerOf(unfollowerProfileId);\n            // Follower profile owner or its approved delegated executor must hold the token or be approved-for-all.\n            if (\n                (followTokenOwner != unfollowerProfileOwner) &&\n                (followTokenOwner != transactionExecutor) &&\n                !isApprovedForAll(followTokenOwner, transactionExecutor) &&\n                !isApprovedForAll(followTokenOwner, unfollowerProfileOwner)\n            ) {\n                revert DoesNotHavePermissions();\n            }\n            _unfollow({unfollower: unfollowerProfileId, followTokenId: followTokenId});\n        }\n    }\n\n    /// @inheritdoc IFollowNFT\n    function removeFollower(uint256 followTokenId) external override {\n        address followTokenOwner = ownerOf(followTokenId);\n        if (followTokenOwner == msg.sender || isApprovedForAll(followTokenOwner, msg.sender)) {\n            _unfollowIfHasFollower(followTokenId);\n        } else {\n            revert DoesNotHavePermissions();\n        }\n    }\n\n    /// @inheritdoc IFollowNFT\n    function approveFollow(uint256 followerProfileId, uint256 followTokenId) external override {\n        if (!IERC721Timestamped(HUB).exists(followerProfileId)) {\n            revert Errors.TokenDoesNotExist();\n        }\n        address followTokenOwner = _unsafeOwnerOf(followTokenId);\n        if (followTokenOwner == address(0)) {\n            revert OnlyWrappedFollowTokens();\n        }\n        if (followTokenOwner != msg.sender && !isApprovedForAll(followTokenOwner, msg.sender)) {\n            revert DoesNotHavePermissions();\n        }\n        _approveFollow(followerProfileId, followTokenId);\n    }\n\n    /// @inheritdoc IFollowNFT\n    function wrap(uint256 followTokenId, address wrappedTokenReceiver) external override {\n        if (wrappedTokenReceiver == address(0)) {\n            revert Errors.InvalidParameter();\n        }\n        _wrap(followTokenId, wrappedTokenReceiver);\n    }\n\n    /// @inheritdoc IFollowNFT\n    function wrap(uint256 followTokenId) external override {\n        _wrap(followTokenId, address(0));\n    }\n\n    function _wrap(uint256 followTokenId, address wrappedTokenReceiver) internal {\n        if (_isFollowTokenWrapped(followTokenId)) {\n            revert AlreadyWrapped();\n        }\n        uint256 followerProfileId = _followDataByFollowTokenId[followTokenId].followerProfileId;\n        if (followerProfileId == 0) {\n            followerProfileId = _followDataByFollowTokenId[followTokenId].profileIdAllowedToRecover;\n            if (followerProfileId == 0) {\n                revert FollowTokenDoesNotExist();\n            }\n            delete _followDataByFollowTokenId[followTokenId].profileIdAllowedToRecover;\n        }\n        address followerProfileOwner = IERC721(HUB).ownerOf(followerProfileId);\n        if (msg.sender != followerProfileOwner) {\n            revert DoesNotHavePermissions();\n        }\n        _mint(wrappedTokenReceiver == address(0) ? followerProfileOwner : wrappedTokenReceiver, followTokenId);\n    }\n\n    /// @inheritdoc IFollowNFT\n    function unwrap(uint256 followTokenId) external override {\n        if (_followDataByFollowTokenId[followTokenId].followerProfileId == 0) {\n            revert NotFollowing();\n        }\n        super.burn(followTokenId);\n    }\n\n    /// @inheritdoc IFollowNFT\n    function processBlock(uint256 followerProfileId) external override onlyHub returns (bool) {\n        bool hasUnfollowed;\n        uint256 followTokenId = _followTokenIdByFollowerProfileId[followerProfileId];\n        if (followTokenId != 0) {\n            if (!_isFollowTokenWrapped(followTokenId)) {\n                // Wrap it first, so the user stops following but does not lose the token when being blocked.\n                _mint(IERC721(HUB).ownerOf(followerProfileId), followTokenId);\n            }\n            _unfollow(followerProfileId, followTokenId);\n            hasUnfollowed = true;\n        }\n        return hasUnfollowed;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getFollowerProfileId(uint256 followTokenId) external view override returns (uint256) {\n        return _followDataByFollowTokenId[followTokenId].followerProfileId;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function isFollowing(uint256 followerProfileId) external view override returns (bool) {\n        return _followTokenIdByFollowerProfileId[followerProfileId] != 0;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getFollowTokenId(uint256 followerProfileId) external view override returns (uint256) {\n        return _followTokenIdByFollowerProfileId[followerProfileId];\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getOriginalFollowTimestamp(uint256 followTokenId) external view override returns (uint256) {\n        return _followDataByFollowTokenId[followTokenId].originalFollowTimestamp;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getFollowTimestamp(uint256 followTokenId) external view override returns (uint256) {\n        return _followDataByFollowTokenId[followTokenId].followTimestamp;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getProfileIdAllowedToRecover(uint256 followTokenId) external view override returns (uint256) {\n        return _followDataByFollowTokenId[followTokenId].profileIdAllowedToRecover;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getFollowData(uint256 followTokenId) external view override returns (Types.FollowData memory) {\n        return _followDataByFollowTokenId[followTokenId];\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getFollowApproved(uint256 followTokenId) external view override returns (uint256) {\n        return _followApprovalByFollowTokenId[followTokenId];\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getFollowerCount() external view override returns (uint256) {\n        return _followerCount;\n    }\n\n    function burn(uint256 followTokenId) public override {\n        _unfollowIfHasFollower(followTokenId);\n        super.burn(followTokenId);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(LensBaseERC721, ERC2981CollectionRoyalties)\n        returns (bool)\n    {\n        return\n            LensBaseERC721.supportsInterface(interfaceId) || ERC2981CollectionRoyalties.supportsInterface(interfaceId);\n    }\n\n    function name() public view override returns (string memory) {\n        return string(abi.encodePacked(_followedProfileId.toString(), FOLLOW_NFT_NAME_SUFFIX));\n    }\n\n    function symbol() public view override returns (string memory) {\n        return string(abi.encodePacked(_followedProfileId.toString(), FOLLOW_NFT_SYMBOL_SUFFIX));\n    }\n\n    /**\n     * @dev This returns the follow NFT URI fetched from the hub.\n     */\n    function tokenURI(uint256 followTokenId) public view override returns (string memory) {\n        if (!_exists(followTokenId)) {\n            revert Errors.TokenDoesNotExist();\n        }\n        return\n            FollowTokenURILib.getTokenURI(\n                followTokenId,\n                _followedProfileId,\n                _followDataByFollowTokenId[followTokenId].originalFollowTimestamp\n            );\n    }\n\n    function _followMintingNewToken(uint256 followerProfileId) internal returns (uint256) {\n        uint256 followTokenIdAssigned;\n        unchecked {\n            followTokenIdAssigned = ++_lastFollowTokenId;\n            _followerCount++;\n        }\n        _baseFollow({\n            followerProfileId: followerProfileId,\n            followTokenId: followTokenIdAssigned,\n            isOriginalFollow: true\n        });\n        return followTokenIdAssigned;\n    }\n\n    function _followWithWrappedToken(\n        uint256 followerProfileId,\n        address transactionExecutor,\n        uint256 followTokenId,\n        address followTokenOwner\n    ) internal returns (uint256) {\n        bool isFollowApproved = _followApprovalByFollowTokenId[followTokenId] == followerProfileId;\n        address followerProfileOwner = IERC721(HUB).ownerOf(followerProfileId);\n        if (\n            !isFollowApproved &&\n            followTokenOwner != followerProfileOwner &&\n            followTokenOwner != transactionExecutor &&\n            !isApprovedForAll(followTokenOwner, transactionExecutor) &&\n            !isApprovedForAll(followTokenOwner, followerProfileOwner)\n        ) {\n            revert DoesNotHavePermissions();\n        }\n        // The transactionExecutor is allowed to write the follower in that wrapped token.\n        if (isFollowApproved) {\n            // The `_followApprovalByFollowTokenId` was used, and now it needs to be cleared.\n            _approveFollow(0, followTokenId);\n        }\n        _replaceFollower({\n            currentFollowerProfileId: _followDataByFollowTokenId[followTokenId].followerProfileId,\n            newFollowerProfileId: followerProfileId,\n            followTokenId: followTokenId\n        });\n        return followTokenId;\n    }\n\n    function _followWithUnwrappedTokenFromBurnedProfile(\n        uint256 followerProfileId,\n        uint256 followTokenId,\n        uint256 currentFollowerProfileId\n    ) internal returns (uint256) {\n        if (IERC721Timestamped(HUB).exists(currentFollowerProfileId)) {\n            revert DoesNotHavePermissions();\n        }\n        _replaceFollower({\n            currentFollowerProfileId: currentFollowerProfileId,\n            newFollowerProfileId: followerProfileId,\n            followTokenId: followTokenId\n        });\n        return followTokenId;\n    }\n\n    function _followByRecoveringToken(uint256 followerProfileId, uint256 followTokenId) internal returns (uint256) {\n        if (_followDataByFollowTokenId[followTokenId].profileIdAllowedToRecover != followerProfileId) {\n            revert FollowTokenDoesNotExist();\n        }\n        unchecked {\n            _followerCount++;\n        }\n        _baseFollow({followerProfileId: followerProfileId, followTokenId: followTokenId, isOriginalFollow: false});\n        return followTokenId;\n    }\n\n    function _replaceFollower(\n        uint256 currentFollowerProfileId,\n        uint256 newFollowerProfileId,\n        uint256 followTokenId\n    ) internal {\n        if (currentFollowerProfileId != 0) {\n            // As it has a follower, unfollow first, removing the current follower.\n            delete _followTokenIdByFollowerProfileId[currentFollowerProfileId];\n            ILensHub(HUB).emitUnfollowedEvent(currentFollowerProfileId, _followedProfileId);\n        } else {\n            unchecked {\n                _followerCount++;\n            }\n        }\n        // Perform the follow, setting a new follower.\n        _baseFollow({followerProfileId: newFollowerProfileId, followTokenId: followTokenId, isOriginalFollow: false});\n    }\n\n    function _baseFollow(\n        uint256 followerProfileId,\n        uint256 followTokenId,\n        bool isOriginalFollow\n    ) internal {\n        _followTokenIdByFollowerProfileId[followerProfileId] = followTokenId;\n        _followDataByFollowTokenId[followTokenId].followerProfileId = uint160(followerProfileId);\n        _followDataByFollowTokenId[followTokenId].followTimestamp = uint48(block.timestamp);\n        delete _followDataByFollowTokenId[followTokenId].profileIdAllowedToRecover;\n        if (isOriginalFollow) {\n            _followDataByFollowTokenId[followTokenId].originalFollowTimestamp = uint48(block.timestamp);\n        } else {\n            // Migration code.\n            // If the follow token was minted before the originalFollowTimestamp was introduced, it will be 0.\n            // In that case, we need to fetch the mint timestamp from the token data.\n            if (_followDataByFollowTokenId[followTokenId].originalFollowTimestamp == 0) {\n                uint48 mintTimestamp = uint48(StorageLib.getTokenData(followTokenId).mintTimestamp);\n                _followDataByFollowTokenId[followTokenId].originalFollowTimestamp = mintTimestamp;\n            }\n        }\n    }\n\n    function _unfollowIfHasFollower(uint256 followTokenId) internal {\n        uint256 followerProfileId = _followDataByFollowTokenId[followTokenId].followerProfileId;\n        if (followerProfileId != 0) {\n            _unfollow(followerProfileId, followTokenId);\n            ILensHub(HUB).emitUnfollowedEvent(followerProfileId, _followedProfileId);\n        }\n    }\n\n    function _unfollow(uint256 unfollower, uint256 followTokenId) internal {\n        unchecked {\n            // This is safe, as this line can only be reached if the unfollowed profile is being followed by the\n            // unfollower profile, so _followerCount is guaranteed to be greater than zero.\n            _followerCount--;\n        }\n        delete _followTokenIdByFollowerProfileId[unfollower];\n        delete _followDataByFollowTokenId[followTokenId].followerProfileId;\n        delete _followDataByFollowTokenId[followTokenId].followTimestamp;\n        delete _followDataByFollowTokenId[followTokenId].profileIdAllowedToRecover;\n    }\n\n    function _approveFollow(uint256 approvedProfileId, uint256 followTokenId) internal {\n        _followApprovalByFollowTokenId[followTokenId] = approvedProfileId;\n        emit FollowApproval(approvedProfileId, followTokenId);\n    }\n\n    /**\n     * @dev Upon transfers, we clear follow approvals and emit the transfer event in the hub.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 followTokenId\n    ) internal override {\n        if (from != address(0)) {\n            // It is cleared on unwrappings and transfers, and it can not be set on unwrapped tokens.\n            // As a consequence, there is no need to clear it on wrappings.\n            _approveFollow(0, followTokenId);\n        }\n        super._beforeTokenTransfer(from, to, followTokenId);\n    }\n\n    function _getReceiver(\n        uint256 /* followTokenId */\n    ) internal view override returns (address) {\n        return IERC721(HUB).ownerOf(_followedProfileId);\n    }\n\n    function _beforeRoyaltiesSet(\n        uint256 /* royaltiesInBasisPoints */\n    ) internal view override {\n        if (IERC721(HUB).ownerOf(_followedProfileId) != msg.sender) {\n            revert Errors.NotProfileOwner();\n        }\n    }\n\n    function _isFollowTokenWrapped(uint256 followTokenId) internal view returns (bool) {\n        return _exists(followTokenId);\n    }\n\n    function _getRoyaltiesInBasisPointsSlot() internal pure override returns (uint256) {\n        uint256 slot;\n        assembly {\n            slot := _royaltiesInBasisPoints.slot\n        }\n        return slot;\n    }\n\n    //////////////////\n    /// Migrations ///\n    //////////////////\n\n    // This function shouldn't fail under no circumstances, except if wrong parameters are passed.\n    function tryMigrate(\n        uint256 followerProfileId,\n        address followerProfileOwner,\n        uint256 idOfProfileFollowed,\n        uint256 followTokenId\n    ) external onlyHub returns (uint48) {\n        // Migrated FollowNFTs should have `originalFollowTimestamp` set\n        if (_followDataByFollowTokenId[followTokenId].originalFollowTimestamp != 0) {\n            return 0; // Already migrated\n        }\n\n        if (_followedProfileId != idOfProfileFollowed) {\n            revert Errors.InvalidParameter();\n        }\n\n        if (!_exists(followTokenId)) {\n            return 0; // Doesn't exist\n        }\n\n        address followTokenOwner = ownerOf(followTokenId);\n\n        // ProfileNFT and FollowNFT should be in the same account\n        if (followerProfileOwner != followTokenOwner) {\n            return 0; // Not holding both Profile & Follow NFTs together\n        }\n\n        unchecked {\n            ++_followerCount;\n        }\n\n        _followTokenIdByFollowerProfileId[followerProfileId] = followTokenId;\n\n        uint48 mintTimestamp = uint48(StorageLib.getTokenData(followTokenId).mintTimestamp);\n\n        _followDataByFollowTokenId[followTokenId].followerProfileId = uint160(followerProfileId);\n        _followDataByFollowTokenId[followTokenId].originalFollowTimestamp = mintTimestamp;\n        _followDataByFollowTokenId[followTokenId].followTimestamp = mintTimestamp;\n\n        super._burn(followTokenId);\n        return mintTimestamp;\n    }\n}"
    },
    {
      "filename": "test/migrations/Migrations.t.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport 'forge-std/Test.sol';\nimport {ForkManagement} from 'test/helpers/ForkManagement.sol';\nimport {LegacyCollectNFT} from 'contracts/misc/LegacyCollectNFT.sol';\nimport {LensHub} from 'contracts/LensHub.sol';\nimport {FollowNFT} from 'contracts/FollowNFT.sol';\nimport {TransparentUpgradeableProxy} from '@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol';\nimport {ModuleGlobals} from 'contracts/misc/ModuleGlobals.sol';\nimport {LensHandles} from 'contracts/namespaces/LensHandles.sol';\nimport {TokenHandleRegistry} from 'contracts/namespaces/TokenHandleRegistry.sol';\nimport {Types} from 'contracts/libraries/constants/Types.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport {IERC721Enumerable} from '@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol';\nimport 'test/Constants.sol';\n\ncontract MigrationsTest is Test, ForkManagement {\n    using stdJson for string;\n\n    uint256 internal constant LENS_PROTOCOL_PROFILE_ID = 1;\n    uint256 internal constant ENUMERABLE_GET_FIRST_PROFILE = 0;\n\n    address owner = address(0x087E4);\n    address deployer = address(1);\n    address governance;\n    address modulesGovernance;\n    address treasury;\n    address hubProxyAddr;\n    address proxyAdmin;\n\n    LensHandles lensHandles;\n    TokenHandleRegistry tokenHandleRegistry;\n\n    LegacyCollectNFT legacyCollectNFT;\n    FollowNFT followNFT;\n    LensHub hubImpl;\n    TransparentUpgradeableProxy hubAsProxy;\n    LensHub hub;\n    ModuleGlobals moduleGlobals;\n\n    uint256[] followerProfileIds = new uint256[](10);\n\n    function loadBaseAddresses(string memory targetEnv) internal virtual {\n        console.log('targetEnv:', targetEnv);\n\n        hubProxyAddr = json.readAddress(string(abi.encodePacked('.', targetEnv, '.LensHubProxy')));\n        console.log('hubProxyAddr:', hubProxyAddr);\n\n        hub = LensHub(hubProxyAddr);\n\n        console.log('Hub:', address(hub));\n\n        // address followNFTAddr = hub.getFollowNFTImpl();\n        address legacyCollectNFTAddr = hub.getCollectNFTImpl();\n\n        address hubImplAddr = address(uint160(uint256(vm.load(hubProxyAddr, PROXY_IMPLEMENTATION_STORAGE_SLOT))));\n        console.log('Found hubImplAddr:', hubImplAddr);\n\n        proxyAdmin = address(uint160(uint256(vm.load(hubProxyAddr, ADMIN_SLOT))));\n\n        legacyCollectNFT = LegacyCollectNFT(legacyCollectNFTAddr);\n        hubAsProxy = TransparentUpgradeableProxy(payable(address(hub)));\n        moduleGlobals = ModuleGlobals(json.readAddress(string(abi.encodePacked('.', targetEnv, '.ModuleGlobals'))));\n\n        governance = hub.getGovernance();\n        modulesGovernance = moduleGlobals.getGovernance();\n    }\n\n    function setUp() public onlyFork {\n        loadBaseAddresses(forkEnv);\n\n        // Precompute needed addresses.\n        address lensHandlesAddress = computeCreateAddress(deployer, 0);\n        address tokenHandleRegistryAddress = computeCreateAddress(deployer, 1);\n\n        console.log('lensHandlesAddress:', lensHandlesAddress);\n        console.log('tokenHandleRegistryAddress:', tokenHandleRegistryAddress);\n\n        vm.startPrank(deployer);\n\n        lensHandles = new LensHandles(owner, address(hub), HANDLE_GUARDIAN_COOLDOWN);\n        assertEq(address(lensHandles), lensHandlesAddress);\n\n        tokenHandleRegistry = new TokenHandleRegistry(address(hub), lensHandlesAddress);\n        assertEq(address(tokenHandleRegistry), tokenHandleRegistryAddress);\n\n        followNFT = new FollowNFT(address(hub));\n\n        // TODO: Last 3 addresses are for the follow modules for migration purposes.\n        hubImpl = new LensHub({\n            moduleGlobals: address(0),\n            followNFTImpl: address(followNFT),\n            collectNFTImpl: address(legacyCollectNFT),\n            lensHandlesAddress: lensHandlesAddress,\n            tokenHandleRegistryAddress: tokenHandleRegistryAddress,\n            legacyFeeFollowModule: address(0),\n            legacyProfileFollowModule: address(0),\n            newFeeFollowModule: address(0),\n            tokenGuardianCooldown: PROFILE_GUARDIAN_COOLDOWN\n        });\n\n        vm.stopPrank();\n\n        // TODO: This can be moved and split\n        uint256 idOfProfileFollowed = 8;\n        address followNFTAddress = hub.getProfile(idOfProfileFollowed).followNFT;\n        for (uint256 i = 0; i < 10; i++) {\n            uint256 followTokenId = i + 1;\n            address followerOwner = IERC721(followNFTAddress).ownerOf(followTokenId);\n            uint256 followerProfileId = IERC721Enumerable(address(hub)).tokenOfOwnerByIndex(\n                followerOwner,\n                ENUMERABLE_GET_FIRST_PROFILE\n            );\n            followerProfileIds[i] = followerProfileId;\n        }\n\n        // TODO: Upgrade can be moved to a separate function\n        vm.prank(proxyAdmin);\n        hubAsProxy.upgradeTo(address(hubImpl));\n    }\n\n    function testProfileMigration() public onlyFork {\n        uint256[] memory profileIds = new uint256[](10);\n        for (uint256 i = 0; i < 10; i++) {\n            profileIds[i] = i + 1;\n        }\n        hub.batchMigrateProfiles(profileIds);\n    }\n\n    function testFollowMigration() public onlyFork {\n        uint256 idOfProfileFollowed = 8;\n\n        uint256[] memory idsOfProfileFollowed = new uint256[](10);\n        uint256[] memory followTokenIds = new uint256[](10);\n        for (uint256 i = 0; i < 10; i++) {\n            uint256 followTokenId = i + 1;\n\n            idsOfProfileFollowed[i] = idOfProfileFollowed;\n            followTokenIds[i] = followTokenId;\n        }\n\n        hub.batchMigrateFollows(followerProfileIds, idsOfProfileFollowed, followTokenIds);\n    }\n}"
    }
  ]
}