{
  "Title": "[G-01]  Replace `modifier` with `function` (6 instances)",
  "Content": "\nModifiers make code more elegant, but cost more than normal functions.\n\nDeployment Gas Saved: **460 154**\n\nAll modifiers except `permissioned` due to unresolved error flow.\n\n*   src/Kernel.sol:[70-73](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/Kernel.sol#L70-L73), [119-123](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/Kernel.sol#L119-L123), [223-232](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/Kernel.sol#L223-L232)\n\n```solidity\n70     modifier onlyKernel() {\n71         if (msg.sender != address(kernel)) revert KernelAdapter_OnlyKernel(msg.sender);\n72         _;\n73     }\n...\n119    modifier onlyRole(bytes32 role_) {\n120        Role role = toRole(role_);\n121        if (!kernel.hasRole(msg.sender, role)) revert Policy_OnlyRole(role);\n122        _;\n123    }\n...\n223    modifier onlyExecutor() {\n224        if (msg.sender != executor) revert Kernel_OnlyExecutor(msg.sender);\n225        _;\n226    }\n227\n228    /// @notice Modifier to check if caller is the roles admin.\n229    modifier onlyAdmin() {\n230        if (msg.sender != admin) revert Kernel_OnlyAdmin(msg.sender);\n231        _;\n232    }\n```\n\n*   src/policies/Operator.sol:[188-191](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L188-L191)\n\n```solidity\n188    modifier onlyWhileActive() {\n189        if (!active) revert Operator_Inactive();\n190        _;\n191    }\n```\n\n*   [src/modules/PRICE.sol](https://github.com/code-423n4/2022-08-olympus/blob/main/src/modules/PRICE.sol)\n\n```solidity\nif (!initialized) revert Price_NotInitialized(); // @note 4 instances\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-08-olympus-dao-contest",
  "Code": [
    {
      "filename": "src/Kernel.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport \"src/utils/KernelUtils.sol\";\n\n// Kernel Adapter errors\nerror KernelAdapter_OnlyKernel(address caller_);\n\n// Module errors\nerror Module_PolicyNotPermitted(address policy_);\n\n// Policy errors\nerror Policy_OnlyRole(Role role_);\nerror Policy_ModuleDoesNotExist(Keycode keycode_);\n\n// Kernel errors\nerror Kernel_OnlyExecutor(address caller_);\nerror Kernel_OnlyAdmin(address caller_);\nerror Kernel_ModuleAlreadyInstalled(Keycode module_);\nerror Kernel_InvalidModuleUpgrade(Keycode module_);\nerror Kernel_PolicyAlreadyActivated(address policy_);\nerror Kernel_PolicyNotActivated(address policy_);\nerror Kernel_AddressAlreadyHasRole(address addr_, Role role_);\nerror Kernel_AddressDoesNotHaveRole(address addr_, Role role_);\nerror Kernel_RoleDoesNotExist(Role role_);\n\n/*//////////////////////////////////////////////////////////////\n                          GLOBAL TYPES\n//////////////////////////////////////////////////////////////*/\n\n/// @notice Actions to trigger state changes in the kernel. Passed by the executor\nenum Actions {\n    InstallModule,\n    UpgradeModule,\n    ActivatePolicy,\n    DeactivatePolicy,\n    ChangeExecutor,\n    ChangeAdmin,\n    MigrateKernel\n}\n\n/// @notice Used by executor to select an action and a target contract for a kernel action\nstruct Instruction {\n    Actions action;\n    address target;\n}\n\n/// @notice Used to define which module functions a policy needs access to\nstruct Permissions {\n    Keycode keycode;\n    bytes4 funcSelector;\n}\n\ntype Keycode is bytes5;\ntype Role is bytes32;\n\n/*//////////////////////////////////////////////////////////////\n                      COMPONENT ABSTRACTS\n//////////////////////////////////////////////////////////////*/\n\n/// @notice Generic adapter interface for kernel access in modules and policies.\nabstract contract KernelAdapter {\n    Kernel public kernel;\n\n    constructor(Kernel kernel_) {\n        kernel = kernel_;\n    }\n\n    /// @notice Modifier to restrict functions to be called only by kernel.\n    modifier onlyKernel() {\n        if (msg.sender != address(kernel)) revert KernelAdapter_OnlyKernel(msg.sender);\n        _;\n    }\n\n    /// @notice Function used by kernel when migrating to a new kernel.\n    function changeKernel(Kernel newKernel_) external onlyKernel {\n        kernel = newKernel_;\n    }\n}\n\n/// @notice Base level extension of the kernel. Modules act as independent state components to be\n///         interacted with and mutated through policies.\n/// @dev    Modules are installed and uninstalled via the executor.\nabstract contract Module is KernelAdapter {\n    constructor(Kernel kernel_) KernelAdapter(kernel_) {}\n\n    /// @notice Modifier to restrict which policies have access to module functions.\n    modifier permissioned() {\n        if (!kernel.modulePermissions(KEYCODE(), Policy(msg.sender), msg.sig))\n            revert Module_PolicyNotPermitted(msg.sender);\n        _;\n    }\n\n    /// @notice 5 byte identifier for a module.\n    function KEYCODE() public pure virtual returns (Keycode) {}\n\n    /// @notice Returns which semantic version of a module is being implemented.\n    /// @return major - Major version upgrade indicates breaking change to the interface.\n    /// @return minor - Minor version change retains backward-compatible interface.\n    function VERSION() external pure virtual returns (uint8 major, uint8 minor) {}\n\n    /// @notice Initialization function for the module\n    /// @dev    This function is called when the module is installed or upgraded by the kernel.\n    /// @dev    MUST BE GATED BY onlyKernel. Used to encompass any initialization or upgrade logic.\n    function INIT() external virtual onlyKernel {}\n}\n\n/// @notice Policies are application logic and external interface for the kernel and installed modules.\n/// @dev    Policies are activated and deactivated in the kernel by the executor.\n/// @dev    Module dependencies and function permissions must be defined in appropriate functions.\nabstract contract Policy is KernelAdapter {\n    /// @notice Denote if a policy is activated or not.\n    bool public isActive;\n\n    constructor(Kernel kernel_) KernelAdapter(kernel_) {}\n\n    /// @notice Modifier to restrict policy function access to certain addresses with a role.\n    /// @dev    Roles are defined in the policy and set by the kernel admin.\n    modifier onlyRole(bytes32 role_) {\n        Role role = toRole(role_);\n        if (!kernel.hasRole(msg.sender, role)) revert Policy_OnlyRole(role);\n        _;\n    }\n\n    /// @notice Function to let kernel grant or revoke active status.\n    function setActiveStatus(bool activate_) external onlyKernel {\n        isActive = activate_;\n    }\n\n    /// @notice Function to grab module address from a given keycode.\n    function getModuleAddress(Keycode keycode_) internal view returns (address) {\n        address moduleForKeycode = address(kernel.getModuleForKeycode(keycode_));\n        if (moduleForKeycode == address(0)) revert Policy_ModuleDoesNotExist(keycode_);\n        return moduleForKeycode;\n    }\n\n    /// @notice Define module dependencies for this policy.\n    /// @return dependencies - Keycode array of module dependencies.\n    function configureDependencies() external virtual returns (Keycode[] memory dependencies) {}\n\n    /// @notice Function called by kernel to set module function permissions.\n    /// @return requests - Array of keycodes and function selectors for requested permissions.\n    function requestPermissions() external view virtual returns (Permissions[] memory requests) {}\n}\n\n/// @notice Main contract that acts as a central component registry for the protocol.\n/// @dev    The kernel manages modules, policies and defined roles. The kernel is mutated via predefined Actions,\n/// @dev    which are input from any address assigned as the executor. The executor can be changed as needed.\ncontract Kernel {\n    /*//////////////////////////////////////////////////////////////\n                          PRIVILEGED ADDRESSES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Address that is able to initiate Actions in the kernel. Can be assigned to a multisig or governance contract.\n    address public executor;\n\n    /// @notice Address that is responsible for assigning policy-defined roles to addresses.\n    address public admin;\n\n    /*//////////////////////////////////////////////////////////////\n                           MODULE MANAGEMENT\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Array of all modules currently installed.\n    Keycode[] public allKeycodes;\n\n    /// @notice Mapping of module address to keycode.\n    mapping(Keycode => Module) public getModuleForKeycode;\n\n    /// @notice Mapping of keycode to module address.\n    mapping(Module => Keycode) public getKeycodeForModule;\n\n    /// @notice Mapping of a keycode to all of its policy dependents. Used to efficiently reconfigure policy dependencies.\n    mapping(Keycode => Policy[]) public moduleDependents;\n\n    /// @notice Helper for module dependent arrays. Prevents the need to loop through array.\n    mapping(Keycode => mapping(Policy => uint256)) public getDependentIndex;\n\n    /// @notice Module <> Policy Permissions.\n    /// @dev    Policy -> Keycode -> Function Selector -> bool for permission\n    mapping(Keycode => mapping(Policy => mapping(bytes4 => bool))) public modulePermissions;\n\n    /*//////////////////////////////////////////////////////////////\n                           POLICY MANAGEMENT\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice List of all active policies\n    Policy[] public activePolicies;\n\n    /// @notice Helper to get active policy quickly. Prevents need to loop through array.\n    mapping(Policy => uint256) public getPolicyIndex;\n\n    /// @notice Mapping for if an address has a policy-defined role.\n    mapping(address => mapping(Role => bool)) public hasRole;\n\n    /// @notice Mapping for if role exists.\n    mapping(Role => bool) public isRole;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event PermissionsUpdated(\n        Keycode indexed keycode_,\n        Policy indexed policy_,\n        bytes4 funcSelector_,\n        bool granted_\n    );\n    event RoleGranted(Role indexed role_, address indexed addr_);\n    event RoleRevoked(Role indexed role_, address indexed addr_);\n    event ActionExecuted(Actions indexed action_, address indexed target_);\n\n    /*//////////////////////////////////////////////////////////////\n                              KERNEL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    constructor() {\n        executor = msg.sender;\n        admin = msg.sender;\n    }\n\n    /// @notice Modifier to check if caller is the executor.\n    modifier onlyExecutor() {\n        if (msg.sender != executor) revert Kernel_OnlyExecutor(msg.sender);\n        _;\n    }\n\n    /// @notice Modifier to check if caller is the roles admin.\n    modifier onlyAdmin() {\n        if (msg.sender != admin) revert Kernel_OnlyAdmin(msg.sender);\n        _;\n    }\n\n    /// @notice Main kernel function. Initiates state changes to kernel depending on Action passed in.\n    function executeAction(Actions action_, address target_) external onlyExecutor {\n        if (action_ == Actions.InstallModule) {\n            ensureContract(target_);\n            ensureValidKeycode(Module(target_).KEYCODE());\n            _installModule(Module(target_));\n        } else if (action_ == Actions.UpgradeModule) {\n            ensureContract(target_);\n            ensureValidKeycode(Module(target_).KEYCODE());\n            _upgradeModule(Module(target_));\n        } else if (action_ == Actions.ActivatePolicy) {\n            ensureContract(target_);\n            _activatePolicy(Policy(target_));\n        } else if (action_ == Actions.DeactivatePolicy) {\n            ensureContract(target_);\n            _deactivatePolicy(Policy(target_));\n        } else if (action_ == Actions.ChangeExecutor) {\n            executor = target_;\n        } else if (action_ == Actions.ChangeAdmin) {\n            admin = target_;\n        } else if (action_ == Actions.MigrateKernel) {\n            ensureContract(target_);\n            _migrateKernel(Kernel(target_));\n        }\n\n        emit ActionExecuted(action_, target_);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             ACTIONS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _installModule(Module newModule_) internal {\n        Keycode keycode = newModule_.KEYCODE();\n\n        if (address(getModuleForKeycode[keycode]) != address(0))\n            revert Kernel_ModuleAlreadyInstalled(keycode);\n\n        getModuleForKeycode[keycode] = newModule_;\n        getKeycodeForModule[newModule_] = keycode;\n        allKeycodes.push(keycode);\n\n        newModule_.INIT();\n    }\n\n    function _upgradeModule(Module newModule_) internal {\n        Keycode keycode = newModule_.KEYCODE();\n        Module oldModule = getModuleForKeycode[keycode];\n\n        if (address(oldModule) == address(0) || oldModule == newModule_)\n            revert Kernel_InvalidModuleUpgrade(keycode);\n\n        getKeycodeForModule[oldModule] = Keycode.wrap(bytes5(0));\n        getKeycodeForModule[newModule_] = keycode;\n        getModuleForKeycode[keycode] = newModule_;\n\n        newModule_.INIT();\n\n        _reconfigurePolicies(keycode);\n    }\n\n    function _activatePolicy(Policy policy_) internal {\n        if (policy_.isActive()) revert Kernel_PolicyAlreadyActivated(address(policy_));\n\n        // Add policy to list of active policies\n        activePolicies.push(policy_);\n        getPolicyIndex[policy_] = activePolicies.length - 1;\n\n        // Record module dependencies\n        Keycode[] memory dependencies = policy_.configureDependencies();\n        uint256 depLength = dependencies.length;\n\n        for (uint256 i; i < depLength; ) {\n            Keycode keycode = dependencies[i];\n\n            moduleDependents[keycode].push(policy_);\n            getDependentIndex[keycode][policy_] = moduleDependents[keycode].length - 1;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Grant permissions for policy to access restricted module functions\n        Permissions[] memory requests = policy_.requestPermissions();\n        _setPolicyPermissions(policy_, requests, true);\n\n        // Set policy status to active\n        policy_.setActiveStatus(true);\n    }\n\n    function _deactivatePolicy(Policy policy_) internal {\n        if (!policy_.isActive()) revert Kernel_PolicyNotActivated(address(policy_));\n\n        // Revoke permissions\n        Permissions[] memory requests = policy_.requestPermissions();\n        _setPolicyPermissions(policy_, requests, false);\n\n        // Remove policy from all policy data structures\n        uint256 idx = getPolicyIndex[policy_];\n        Policy lastPolicy = activePolicies[activePolicies.length - 1];\n\n        activePolicies[idx] = lastPolicy;\n        activePolicies.pop();\n        getPolicyIndex[lastPolicy] = idx;\n        delete getPolicyIndex[policy_];\n\n        // Remove policy from module dependents\n        _pruneFromDependents(policy_);\n\n        // Set policy status to inactive\n        policy_.setActiveStatus(false);\n    }\n\n    /// @notice All functionality will move to the new kernel. WARNING: ACTION WILL BRICK THIS KERNEL.\n    /// @dev    New kernel must add in all of the modules and policies via executeAction.\n    /// @dev    NOTE: Data does not get cleared from this kernel.\n    function _migrateKernel(Kernel newKernel_) internal {\n        uint256 keycodeLen = allKeycodes.length;\n        for (uint256 i; i < keycodeLen; ) {\n            Module module = Module(getModuleForKeycode[allKeycodes[i]]);\n            module.changeKernel(newKernel_);\n            unchecked {\n                ++i;\n            }\n        }\n\n        uint256 policiesLen = activePolicies.length;\n        for (uint256 j; j < policiesLen; ) {\n            Policy policy = activePolicies[j];\n\n            // Deactivate before changing kernel\n            policy.setActiveStatus(false);\n            policy.changeKernel(newKernel_);\n            unchecked {\n                ++j;\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            INTERNAL HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    function _reconfigurePolicies(Keycode keycode_) internal {\n        Policy[] memory dependents = moduleDependents[keycode_];\n        uint256 depLength = dependents.length;\n\n        for (uint256 i; i < depLength; ) {\n            dependents[i].configureDependencies();\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _setPolicyPermissions(\n        Policy policy_,\n        Permissions[] memory requests_,\n        bool grant_\n    ) internal {\n        uint256 reqLength = requests_.length;\n        for (uint256 i = 0; i < reqLength; ) {\n            Permissions memory request = requests_[i];\n            modulePermissions[request.keycode][policy_][request.funcSelector] = grant_;\n\n            emit PermissionsUpdated(request.keycode, policy_, request.funcSelector, grant_);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _pruneFromDependents(Policy policy_) internal {\n        Keycode[] memory dependencies = policy_.configureDependencies();\n        uint256 depcLength = dependencies.length;\n\n        for (uint256 i; i < depcLength; ) {\n            Keycode keycode = dependencies[i];\n            Policy[] storage dependents = moduleDependents[keycode];\n\n            uint256 origIndex = getDependentIndex[keycode][policy_];\n            Policy lastPolicy = dependents[dependents.length - 1];\n\n            // Swap with last and pop\n            dependents[origIndex] = lastPolicy;\n            dependents.pop();\n\n            // Record new index and delete deactivated policy index\n            getDependentIndex[keycode][lastPolicy] = origIndex;\n            delete getDependentIndex[keycode][policy_];\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          ROLES ADMIN FUNCTION\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Function to grant policy-defined roles to some address. Can only be called by admin.\n    function grantRole(Role role_, address addr_) public onlyAdmin {\n        if (hasRole[addr_][role_]) revert Kernel_AddressAlreadyHasRole(addr_, role_);\n\n        ensureValidRole(role_);\n        if (!isRole[role_]) isRole[role_] = true;\n\n        hasRole[addr_][role_] = true;\n\n        emit RoleGranted(role_, addr_);\n    }\n\n    /// @notice Function to revoke policy-defined roles from some address. Can only be called by admin.\n    function revokeRole(Role role_, address addr_) public onlyAdmin {\n        if (!isRole[role_]) revert Kernel_RoleDoesNotExist(role_);\n        if (!hasRole[addr_][role_]) revert Kernel_AddressDoesNotHaveRole(addr_, role_);\n\n        hasRole[addr_][role_] = false;\n\n        emit RoleRevoked(role_, addr_);\n    }\n}"
    },
    {
      "filename": "src/policies/Operator.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IOperator} from \"policies/interfaces/IOperator.sol\";\nimport {IBondAuctioneer} from \"interfaces/IBondAuctioneer.sol\";\nimport {IBondCallback} from \"interfaces/IBondCallback.sol\";\n\nimport {OlympusTreasury} from \"modules/TRSRY.sol\";\nimport {OlympusMinter} from \"modules/MINTR.sol\";\nimport {OlympusPrice} from \"modules/PRICE.sol\";\nimport {OlympusRange} from \"modules/RANGE.sol\";\n\nimport \"src/Kernel.sol\";\n\nimport {TransferHelper} from \"libraries/TransferHelper.sol\";\nimport {FullMath} from \"libraries/FullMath.sol\";\n\n/// @title  Olympus Range Operator\n/// @notice Olympus Range Operator (Policy) Contract\n/// @dev    The Olympus Range Operator performs market operations to enforce OlympusDAO's OHM price range\n///         guidance policies against a specific reserve asset. The Operator is maintained by a keeper-triggered\n///         function on the Olympus Heart contract, which orchestrates state updates in the correct order to ensure\n///         market operations use up to date information. When the price of OHM against the reserve asset exceeds\n///         the cushion spread, the Operator deploys bond markets to support the price. The Operator also offers\n///         zero slippage swaps at prices dictated by the wall spread from the moving average. These market operations\n///         are performed up to a specific capacity before the market must stabilize to regenerate the capacity.\ncontract Operator is IOperator, Policy, ReentrancyGuard {\n    using TransferHelper for ERC20;\n    using FullMath for uint256;\n\n    /* ========== ERRORS =========== */\n\n    error Operator_InvalidParams();\n    error Operator_InsufficientCapacity();\n    error Operator_AmountLessThanMinimum(uint256 amountOut, uint256 minAmountOut);\n    error Operator_WallDown();\n    error Operator_AlreadyInitialized();\n    error Operator_NotInitialized();\n    error Operator_Inactive();\n\n    /* ========== EVENTS =========== */\n    event Swap(\n        ERC20 indexed tokenIn_,\n        ERC20 indexed tokenOut_,\n        uint256 amountIn_,\n        uint256 amountOut_\n    );\n    event CushionFactorChanged(uint32 cushionFactor_);\n    event CushionParamsChanged(uint32 duration_, uint32 debtBuffer_, uint32 depositInterval_);\n    event ReserveFactorChanged(uint32 reserveFactor_);\n    event RegenParamsChanged(uint32 wait_, uint32 threshold_, uint32 observe_);\n\n    /* ========== STATE VARIABLES ========== */\n\n    /// Operator variables, defined in the interface on the external getter functions\n    Status internal _status;\n    Config internal _config;\n\n    /// @notice    Whether the Operator has been initialized\n    bool public initialized;\n\n    /// @notice    Whether the Operator is active\n    bool public active;\n\n    /// Modules\n    OlympusPrice internal PRICE;\n    OlympusRange internal RANGE;\n    OlympusTreasury internal TRSRY;\n    OlympusMinter internal MINTR;\n\n    /// External contracts\n    /// @notice     Auctioneer contract used for cushion bond market deployments\n    IBondAuctioneer public auctioneer;\n    /// @notice     Callback contract used for cushion bond market payouts\n    IBondCallback public callback;\n\n    /// Tokens\n    /// @notice     OHM token contract\n    ERC20 public immutable ohm;\n    uint8 public immutable ohmDecimals;\n    /// @notice     Reserve token contract\n    ERC20 public immutable reserve;\n    uint8 public immutable reserveDecimals;\n\n    /// Constants\n    uint32 public constant FACTOR_SCALE = 1e4;\n\n    /* ========== CONSTRUCTOR ========== */\n    constructor(\n        Kernel kernel_,\n        IBondAuctioneer auctioneer_,\n        IBondCallback callback_,\n        ERC20[2] memory tokens_, // [ohm, reserve]\n        uint32[8] memory configParams // [cushionFactor, cushionDuration, cushionDebtBuffer, cushionDepositInterval, reserveFactor, regenWait, regenThreshold, regenObserve]\n    ) Policy(kernel_) {\n        /// Check params are valid\n        if (address(auctioneer_) == address(0) || address(callback_) == address(0))\n            revert Operator_InvalidParams();\n\n        if (configParams[1] > uint256(7 days) || configParams[1] < uint256(1 days))\n            revert Operator_InvalidParams();\n\n        if (configParams[2] < uint32(10_000)) revert Operator_InvalidParams();\n\n        if (configParams[3] < uint32(1 hours) || configParams[3] > configParams[1])\n            revert Operator_InvalidParams();\n\n        if (configParams[4] > 10000 || configParams[4] < 100) revert Operator_InvalidParams();\n\n        if (\n            configParams[5] < 1 hours ||\n            configParams[6] > configParams[7] ||\n            configParams[7] == uint32(0)\n        ) revert Operator_InvalidParams();\n\n        auctioneer = auctioneer_;\n        callback = callback_;\n        ohm = tokens_[0];\n        ohmDecimals = tokens_[0].decimals();\n        reserve = tokens_[1];\n        reserveDecimals = tokens_[1].decimals();\n\n        Regen memory regen = Regen({\n            count: uint32(0),\n            lastRegen: uint48(block.timestamp),\n            nextObservation: uint32(0),\n            observations: new bool[](configParams[7])\n        });\n\n        _config = Config({\n            cushionFactor: configParams[0],\n            cushionDuration: configParams[1],\n            cushionDebtBuffer: configParams[2],\n            cushionDepositInterval: configParams[3],\n            reserveFactor: configParams[4],\n            regenWait: configParams[5],\n            regenThreshold: configParams[6],\n            regenObserve: configParams[7]\n        });\n\n        _status = Status({low: regen, high: regen});\n\n        emit CushionFactorChanged(configParams[0]);\n        emit CushionParamsChanged(configParams[1], configParams[2], configParams[3]);\n        emit ReserveFactorChanged(configParams[4]);\n        emit RegenParamsChanged(configParams[5], configParams[6], configParams[7]);\n    }\n\n    /* ========== FRAMEWORK CONFIGURATION ========== */\n    /// @inheritdoc Policy\n    function configureDependencies() external override returns (Keycode[] memory dependencies) {\n        dependencies = new Keycode[](4);\n        dependencies[0] = toKeycode(\"PRICE\");\n        dependencies[1] = toKeycode(\"RANGE\");\n        dependencies[2] = toKeycode(\"TRSRY\");\n        dependencies[3] = toKeycode(\"MINTR\");\n\n        PRICE = OlympusPrice(getModuleAddress(dependencies[0]));\n        RANGE = OlympusRange(getModuleAddress(dependencies[1]));\n        TRSRY = OlympusTreasury(getModuleAddress(dependencies[2]));\n        MINTR = OlympusMinter(getModuleAddress(dependencies[3]));\n\n        /// Approve MINTR for burning OHM (called here so that it is re-approved on updates)\n        ohm.safeApprove(address(MINTR), type(uint256).max);\n    }\n\n    /// @inheritdoc Policy\n    function requestPermissions() external view override returns (Permissions[] memory requests) {\n        Keycode RANGE_KEYCODE = RANGE.KEYCODE();\n        Keycode TRSRY_KEYCODE = TRSRY.KEYCODE();\n        Keycode MINTR_KEYCODE = MINTR.KEYCODE();\n\n        requests = new Permissions[](9);\n        requests[0] = Permissions(RANGE_KEYCODE, RANGE.updateCapacity.selector);\n        requests[1] = Permissions(RANGE_KEYCODE, RANGE.updateMarket.selector);\n        requests[2] = Permissions(RANGE_KEYCODE, RANGE.updatePrices.selector);\n        requests[3] = Permissions(RANGE_KEYCODE, RANGE.regenerate.selector);\n        requests[4] = Permissions(RANGE_KEYCODE, RANGE.setSpreads.selector);\n        requests[5] = Permissions(RANGE_KEYCODE, RANGE.setThresholdFactor.selector);\n        requests[6] = Permissions(TRSRY_KEYCODE, TRSRY.setApprovalFor.selector);\n        requests[7] = Permissions(MINTR_KEYCODE, MINTR.mintOhm.selector);\n        requests[8] = Permissions(MINTR_KEYCODE, MINTR.burnOhm.selector);\n    }\n\n    modifier onlyWhileActive() {\n        if (!active) revert Operator_Inactive();\n        _;\n    }\n\n    /* ========== HEART FUNCTIONS ========== */\n    /// @inheritdoc IOperator\n    function operate() external override onlyWhileActive onlyRole(\"operator_operate\") {\n        /// Revert if not initialized\n        if (!initialized) revert Operator_NotInitialized();\n\n        /// Update the prices for the range, save new regen observations, and update capacities based on bond market activity\n        _updateRangePrices();\n        _addObservation();\n        _updateCapacity(true, 0);\n        _updateCapacity(false, 0);\n\n        /// Cache config in memory\n        Config memory config_ = _config;\n\n        /// Check if walls can regenerate capacity\n        if (\n            uint48(block.timestamp) >= RANGE.lastActive(true) + uint48(config_.regenWait) &&\n            _status.high.count >= config_.regenThreshold\n        ) {\n            _regenerate(true);\n        }\n        if (\n            uint48(block.timestamp) >= RANGE.lastActive(false) + uint48(config_.regenWait) &&\n            _status.low.count >= config_.regenThreshold\n        ) {\n            _regenerate(false);\n        }\n\n        /// Cache range data after potential regeneration\n        OlympusRange.Range memory range = RANGE.range();\n\n        /// Get latest price\n        /// See note in addObservation() for more details\n        uint256 currentPrice = PRICE.getLastPrice();\n\n        /// Check if the cushion bond markets are active\n        /// if so, determine if it should stay open or close\n        /// if not, check if a new one should be opened\n        if (range.low.active) {\n            if (auctioneer.isLive(range.low.market)) {\n                /// if active, check if the price is back above the cushion\n                /// or if the price is below the wall\n                /// if so, close the market\n                if (currentPrice > range.cushion.low.price || currentPrice < range.wall.low.price) {\n                    _deactivate(false);\n                }\n            } else {\n                /// if not active, check if the price is below the cushion\n                /// if so, open a new bond market\n                if (currentPrice < range.cushion.low.price && currentPrice > range.wall.low.price) {\n                    _activate(false);\n                }\n            }\n        }\n        if (range.high.active) {\n            if (auctioneer.isLive(range.high.market)) {\n                /// if active, check if the price is back under the cushion\n                /// or if the price is above the wall\n                /// if so, close the market\n                if (\n                    currentPrice < range.cushion.high.price || currentPrice > range.wall.high.price\n                ) {\n                    _deactivate(true);\n                }\n            } else {\n                /// if not active, check if the price is above the cushion\n                /// if so, open a new bond market\n                if (\n                    currentPrice > range.cushion.high.price && currentPrice < range.wall.high.price\n                ) {\n                    _activate(true);\n                }\n            }\n        }\n    }\n\n    /* ========== OPEN MARKET OPERATIONS (WALL) ========== */\n    /// @inheritdoc IOperator\n    function swap(\n        ERC20 tokenIn_,\n        uint256 amountIn_,\n        uint256 minAmountOut_\n    ) external override onlyWhileActive nonReentrant returns (uint256 amountOut) {\n        if (tokenIn_ == ohm) {\n            /// Revert if lower wall is inactive\n            if (!RANGE.active(false)) revert Operator_WallDown();\n\n            /// Calculate amount out (checks for sufficient capacity)\n            amountOut = getAmountOut(tokenIn_, amountIn_);\n\n            /// Revert if amount out less than the minimum specified\n            /// @dev even though price is fixed most of the time,\n            /// it is possible that the amount out could change on a sender\n            /// due to the wall prices being updated before their transaction is processed.\n            /// This would be the equivalent of the heart.beat front-running the sender.\n            if (amountOut < minAmountOut_)\n                revert Operator_AmountLessThanMinimum(amountOut, minAmountOut_);\n\n            /// Decrement wall capacity\n            _updateCapacity(false, amountOut);\n\n            /// If wall is down after swap, deactive the cushion as well\n            _checkCushion(false);\n\n            /// Transfer OHM from sender\n            ohm.safeTransferFrom(msg.sender, address(this), amountIn_);\n\n            /// Burn OHM\n            MINTR.burnOhm(address(this), amountIn_);\n\n            /// Withdraw and transfer reserve to sender\n            TRSRY.withdrawReserves(msg.sender, reserve, amountOut);\n\n            emit Swap(ohm, reserve, amountIn_, amountOut);\n        } else if (tokenIn_ == reserve) {\n            /// Revert if upper wall is inactive\n            if (!RANGE.active(true)) revert Operator_WallDown();\n\n            /// Calculate amount out (checks for sufficient capacity)\n            amountOut = getAmountOut(tokenIn_, amountIn_);\n\n            /// Revert if amount out less than the minimum specified\n            /// @dev even though price is fixed most of the time,\n            /// it is possible that the amount out could change on a sender\n            /// due to the wall prices being updated before their transaction is processed.\n            /// This would be the equivalent of the heart.beat front-running the sender.\n            if (amountOut < minAmountOut_)\n                revert Operator_AmountLessThanMinimum(amountOut, minAmountOut_);\n\n            /// Decrement wall capacity\n            _updateCapacity(true, amountOut);\n\n            /// If wall is down after swap, deactive the cushion as well\n            _checkCushion(true);\n\n            /// Transfer reserves to treasury\n            reserve.safeTransferFrom(msg.sender, address(TRSRY), amountIn_);\n\n            /// Mint OHM to sender\n            MINTR.mintOhm(msg.sender, amountOut);\n\n            emit Swap(reserve, ohm, amountIn_, amountOut);\n        } else {\n            revert Operator_InvalidParams();\n        }\n    }\n\n    /* ========== BOND MARKET OPERATIONS (CUSHION) ========== */\n    /// @notice             Records a bond purchase and updates capacity correctly\n    /// @notice             Access restricted (BondCallback)\n    /// @param id_          ID of the bond market\n    /// @param amountOut_   Amount of capacity expended\n    function bondPurchase(uint256 id_, uint256 amountOut_)\n        external\n        onlyWhileActive\n        onlyRole(\"operator_reporter\")\n    {\n        if (id_ == RANGE.market(true)) {\n            _updateCapacity(true, amountOut_);\n            _checkCushion(true);\n        }\n        if (id_ == RANGE.market(false)) {\n            _updateCapacity(false, amountOut_);\n            _checkCushion(false);\n        }\n    }\n\n    /// @notice      Activate a cushion by deploying a bond market\n    /// @param high_ Whether the cushion is for the high or low side of the range (true = high, false = low)\n    function _activate(bool high_) internal {\n        OlympusRange.Range memory range = RANGE.range();\n\n        if (high_) {\n            /// Calculate scaleAdjustment for bond market\n            /// Price decimals are returned from the perspective of the quote token\n            /// so the operations assume payoutPriceDecimal is zero and quotePriceDecimals\n            /// is the priceDecimal value\n            int8 priceDecima"
    }
  ]
}