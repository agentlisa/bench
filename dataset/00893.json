{
  "Title": "H-9: Single-sided instead of proportional exit is performed during emergency exit",
  "Content": "# Issue H-9: Single-sided instead of proportional exit is performed during emergency exit \n\nSource: https://github.com/sherlock-audit/2023-10-notional-judging/issues/87 \n\n## Found by \nxiaoming90\n## Summary\n\nSingle-sided instead of proportional exit is performed during emergency exit, which could lead to a loss of assets during emergency exit and vault restoration.\n\n## Vulnerability Detail\n\nPer the comment in Line 476 below, the BPT should be redeemed proportionally to underlying tokens during an emergency exit. However, it was found that the `_unstakeAndExitPool` function is executed with the `isSingleSided` parameter set to `true`.\n\nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/vaults/common/SingleSidedLPVaultBase.sol#L480\n\n```solidity\nFile: SingleSidedLPVaultBase.sol\n475:     /// @notice Allows the emergency exit role to trigger an emergency exit on the vault.\n476:     /// In this situation, the `claimToExit` is withdrawn proportionally to the underlying\n477:     /// tokens and held on the vault. The vault is locked so that no entries, exits or\n478:     /// valuations of vaultShares can be performed.\n479:     /// @param claimToExit if this is set to zero, the entire pool claim is withdrawn\n480:     function emergencyExit(\n481:         uint256 claimToExit, bytes calldata /* data */\n482:     ) external override onlyRole(EMERGENCY_EXIT_ROLE) {\n483:         StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n484:         if (claimToExit == 0) claimToExit = state.totalPoolClaim;\n485: \n486:         // By setting min amounts to zero, we will accept whatever tokens come from the pool\n487:         // in a proportional exit. Front running will not have an effect since no trading will\n488:         // occur during a proportional exit.\n489:         _unstakeAndExitPool(claimToExit, new uint256[](NUM_TOKENS()), true);\n```\n\nIf the `isSingleSided` is set to `True`, the `EXACT_BPT_IN_FOR_ONE_TOKEN_OUT` will be used, which is incorrect. Per the Balancer's [documentation](https://docs.balancer.fi/reference/joins-and-exits/pool-exits.html#userdata), `EXACT_BPT_IN_FOR_ONE_TOKEN_OUT` is a single asset exit where the user sends a precise quantity of BPT, and receives an estimated but unknown (computed at run time) quantity of a single token.\n\nTo perform a proportional exit, the `EXACT_BPT_IN_FOR_TOKENS_OUT` should be used instead.\n\nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/vaults/BalancerComposableAuraVault.sol#L67\n\n```solidity\nFile: BalancerComposableAuraVault.sol\n60:     function _unstakeAndExitPool(\n61:         uint256 poolClaim, uint256[] memory minAmounts, bool isSingleSided\n62:     ) internal override returns (uint256[] memory exitBalances) {\n63:         bool success = AURA_REWARD_POOL.withdrawAndUnwrap(poolClaim, false); // claimRewards = false\n64:         require(success);\n65: \n66:         bytes memory customData;\n67:         if (isSingleSided) {\n..SNIP..\n74:             uint256 primaryIndex = PRIMARY_INDEX();\n75:             customData = abi.encode(\n76:                 IBalancerVault.ComposableExitKind.EXACT_BPT_IN_FOR_ONE_TOKEN_OUT,\n77:                 poolClaim,\n78:                 primaryIndex < BPT_INDEX ?  primaryIndex : primaryIndex - 1\n79:             );\n```\n\nThe same issue affects the Curve's implementation of the `_unstakeAndExitPool` function.\n\n```solidity\nFile: Curve2TokenConvexVault.sol\n66:     function _unstakeAndExitPool(\n67:         uint256 poolClaim, uint256[] memory _minAmounts, bool isSingleSided\n68:     ) internal override returns (uint256[] memory exitBalances) {\n..SNIP..\n78:         ICurve2TokenPool pool = ICurve2TokenPool(CURVE_POOL);\n79:         exitBalances = new uint256[](2);\n80:         if (isSingleSided) {\n81:             // Redeem single-sided\n82:             exitBalances[_PRIMARY_INDEX] = pool.remove_liquidity_one_coin(\n83:                 poolClaim, int8(_PRIMARY_INDEX), _minAmounts[_PRIMARY_INDEX]\n84:             );\n```\n\n## Impact\n\nThe following are some of the impacts of this issue, which lead to loss of assets:\n\n1. Redeeming LP tokens one-sided incurs unnecessary slippage as tokens have to be swapped internally to one specific token within the pool, resulting in fewer assets received.\n\n2. Per the source code comment below, in other words, unless a proportional exit is performed, the emergency exit will be subjected to front-run attack and slippage.\n\n   ```solidity\n   File: SingleSidedLPVaultBase.sol\n   486:         // By setting min amounts to zero, we will accept whatever tokens come from the pool\n   487:         // in a proportional exit. Front running will not have an effect since no trading will\n   488:         // occur during a proportional exit.\n   489:         _unstakeAndExitPool(claimToExit, new uint256[](NUM_TOKENS()), true);\n   ```\n\n3. After the emergency exit, the vault only held one of the pool tokens. To re-enter the pool, the vault has to either swap the token to other pool tokens on external DEXs to maintain the proportion or perform a single-sided join. Both of these methods will incur unnecessary slippage, resulting in fewer LP tokens received at the end.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/vaults/common/SingleSidedLPVaultBase.sol#L480\n\nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/vaults/BalancerComposableAuraVault.sol#L67\n\nhttps://github.com/sherlock-audit/2023-10-notional/blob/main/leveraged-vaults/contracts/vaults/Curve2TokenConvexVault.sol#L80\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nSet the `isSingleSided` parameter to `false` when calling the `_unstakeAndExitPool` function to ensure that the proportional exit is performed.\n\n```diff\nfunction emergencyExit(\n    uint256 claimToExit, bytes calldata /* data */\n) external override onlyRole(EMERGENCY_EXIT_ROLE) {\n    StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n    if (claimToExit == 0) claimToExit = state.totalPoolClaim;\n\t..SNIP..\n-   _unstakeAndExitPool(claimToExit, new uint256[](NUM_TOKENS()), true);\n+   _unstakeAndExitPool(claimToExit, new uint256[](NUM_TOKENS()), false);\n```\n\n\n\n## Discussion\n\n**jeffywu**\n\nValid issue\n\n**jeffywu**\n\nhttps://github.com/notional-finance/leveraged-vaults/pull/74\n\nAlso includes a related fix for #80, in the changes above we do not use the token balances but owner will pass in the total amounts to re-enter the pools with manually.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/119",
  "Code": [
    {
      "filename": "leveraged-vaults/contracts/vaults/common/SingleSidedLPVaultBase.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\";\n\nimport {BaseStrategyVault} from \"./BaseStrategyVault.sol\";\nimport {Errors} from \"../../global/Errors.sol\";\nimport {Constants} from \"../../global/Constants.sol\";\nimport {TypeConvert} from \"../../global/TypeConvert.sol\";\nimport {TokenUtils} from \"../../utils/TokenUtils.sol\";\nimport {StrategyUtils} from \"./StrategyUtils.sol\";\nimport {VaultStorage} from \"./VaultStorage.sol\";\n\nimport {IERC20} from \"../../../interfaces/IERC20.sol\";\nimport {\n    ISingleSidedLPStrategyVault,\n    StrategyVaultSettings,\n    InitParams,\n    StrategyVaultState,\n    SingleSidedRewardTradeParams,\n    DepositParams,\n    DepositTradeParams,\n    RedeemParams,\n    TradeParams\n} from \"../../../interfaces/notional/ISingleSidedLPStrategyVault.sol\";\nimport {NotionalProxy} from \"../../../interfaces/notional/NotionalProxy.sol\";\nimport {ITradingModule, DexId} from \"../../../interfaces/trading/ITradingModule.sol\";\n\n/**\n * @notice Base contract for the SingleSidedLP strategy. This strategy deposits into an LP\n * pool given a single borrowed currency. Allows for users to trade via external exchanges\n * during entry and exit, but the general expected behavior is single sided entries and\n * exits. Inheriting contracts will fill in the implementation details for integration with\n * the external DEX pool.\n */\nabstract contract SingleSidedLPVaultBase is BaseStrategyVault, UUPSUpgradeable, ISingleSidedLPStrategyVault {\n    using TypeConvert for uint256;\n    using VaultStorage for StrategyVaultState;\n\n    uint256 internal constant MAX_TOKENS = 5;\n    uint8 internal constant NOT_FOUND = type(uint8).max;\n    /// @notice Bit mask for the 'LOCKED\" flag big\n    uint32 internal constant FLAG_LOCKED = 1 << 0;\n\n    /************************************************************************\n     * VIRTUAL FUNCTIONS                                                    *\n     * These virtual functions are used to isolate implementation specific  *\n     * behavior.                                                            *\n     ************************************************************************/\n\n    /// @notice Total number of tokens held by the LP token\n    function NUM_TOKENS() internal view virtual returns (uint256);\n\n    /// @notice Addresses of tokens held and decimal places of each token. ETH will always be\n    /// recorded in this array as Deployments.ETH_Address\n    function TOKENS() internal view virtual returns (IERC20[] memory, uint8[] memory decimals);\n\n    /// @notice Address of the LP token\n    function POOL_TOKEN() internal view virtual returns (IERC20);\n\n    /// @notice Index of the TOKENS() array that refers to the primary borrowed currency by the\n    /// leveraged vault. All valuations are done in terms of this currency.\n    function PRIMARY_INDEX() internal view virtual returns (uint256);\n\n    /// @notice Precision (i.e. 10 ** decimals) of the LP token.\n    function POOL_PRECISION() internal view virtual returns (uint256);\n\n    /// @notice Returns the value of one LP token in terms of the primary borrowed currency by this\n    /// strategy. Will revert if the spot price on the pool is not within some deviation tolerance of\n    /// the implied oracle price. This is intended to prevent any pool manipulation.\n    /// The value of the LP token is calculated as the value of the token if all the balance claims are\n    /// withdrawn proportionally and then converted to the primary currency at the oracle price. Slippage\n    /// from selling the tokens is not considered, any slippage effects will be captured by the maximum\n    /// leverage ratio allowed before liquidation.\n    function _checkPriceAndCalculateValue() internal view virtual returns (uint256 oneLPValueInPrimary);\n\n    /// @notice Called once during initialization to set the initial token approvals.\n    function _initialApproveTokens() internal virtual;\n\n    /// @notice Called to claim reward tokens\n    function _claimRewardTokens() internal virtual;\n\n    /// @notice Called during reward reinvestment to validate that the token being sold is not one\n    /// of the tokens that is required for the vault to function properly (i.e. one of the pool tokens\n    /// or any of the reward booster tokens).\n    function _isInvalidRewardToken(address token) internal view virtual returns (bool);\n\n    /// @notice Implementation specific wrapper for joining a pool with the given amounts. Will also\n    /// stake on the relevant booster protocol.\n    function _joinPoolAndStake(\n        uint256[] memory amounts, uint256 minPoolClaim\n    ) internal virtual returns (uint256 lpTokens);\n\n    /// @notice Implementation specific wrapper for unstaking from the booster protocol and withdrawing\n    /// funds from the LP pool\n    function _unstakeAndExitPool(\n        uint256 poolClaim, uint256[] memory minAmounts, bool isSingleSided\n    ) internal virtual returns (uint256[] memory exitBalances);\n\n    /// @notice Returns the total supply of the pool token. Is a virtual function because\n    /// ComposableStablePools use a \"virtual supply\" and a different method must be called\n    /// to get the actual total supply.\n    function _totalPoolSupply() internal view virtual returns (uint256) {\n        return POOL_TOKEN().totalSupply();\n    }\n\n    /************************************************************************\n     * CLASS FUNCTIONS                                                      *\n     * Below are class functions that represent the base implementation     *\n     * of the Single Sided LP strategy.                                     *\n     ************************************************************************/\n\n    constructor(NotionalProxy notional_, ITradingModule tradingModule_)\n        BaseStrategyVault(notional_, tradingModule_) {}\n\n    /************************************************************************\n     * EXTERNAL VIEW FUNCTIONS                                              *\n     ************************************************************************/\n\n    /// @notice Returns basic information about the vault for use in the user interface.\n    function getStrategyVaultInfo() external view override returns (SingleSidedLPStrategyVaultInfo memory) {\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n        return SingleSidedLPStrategyVaultInfo({\n            pool: address(POOL_TOKEN()),\n            singleSidedTokenIndex: uint8(PRIMARY_INDEX()),\n            totalLPTokens: state.totalPoolClaim,\n            totalVaultShares: state.totalVaultSharesGlobal\n        });\n    }\n\n    /// @notice Returns the current locked status of the vault\n    function isLocked() public view returns (bool) {\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n        return _hasFlag(state.flags, FLAG_LOCKED);\n    }\n\n    /// @notice Returns the current price of a vault share, even when there are no vault shares\n    /// in the strategy. Used by the user interface to collect historical valuation information.\n    function getExchangeRate(uint256 /* maturity */) external view override returns (int256) {\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n        uint256 oneLPValueInPrimary = _checkPriceAndCalculateValue();\n        // If inside an emergency exit, just report the one LP value in primary since the total\n        // pool claim will be 0\n        if (state.totalVaultSharesGlobal == 0 || isLocked()) {\n            return oneLPValueInPrimary.toInt();\n        } else {\n            uint256 lpTokensPerVaultShare = (uint256(Constants.INTERNAL_TOKEN_PRECISION) * state.totalPoolClaim)\n                / state.totalVaultSharesGlobal;\n            return (oneLPValueInPrimary * lpTokensPerVaultShare / POOL_PRECISION()).toInt();\n        }\n    }\n\n    /************************************************************************\n     * ADMIN FUNCTIONS                                                      *\n     * Administrative functions to set settings and initialize the vault.   *\n     * These methods are only callable by the Notional owner.               *\n     ************************************************************************/\n\n    /// @notice Allow Notional owner to upgrade the contract\n    function _authorizeUpgrade(\n        address /* newImplementation */\n    ) internal override onlyNotionalOwner {}\n\n    /// @notice Updates the vault settings include the maximum oracle deviation limit and the\n    /// maximum percent of the LP pool that the vault can hold.\n    function setStrategyVaultSettings(StrategyVaultSettings calldata settings) external onlyNotionalOwner {\n        // Validation occurs inside this method\n        VaultStorage.setStrategyVaultSettings(settings);\n    }\n\n    /// @notice Called to initialize the vault and set the initial approvals. All of the other vault\n    /// parameters are set via immutable parameters already.\n    function initialize(InitParams calldata params) external override initializer onlyNotionalOwner {\n        // Initialize the base vault\n        __INIT_VAULT(params.name, params.borrowCurrencyId);\n\n        // Settings are validated in setStrategyVaultSettings\n        VaultStorage.setStrategyVaultSettings(params.settings);\n\n        _initialApproveTokens();\n    }\n\n    /************************************************************************\n     * USER FUNCTIONS                                                       *\n     * These functions are called during normal usage of the vault.         *\n     * They allow for deposits and redemptions from the vault as well as a  *\n     * valuation check that is used by Notional to determine if the user is *\n     * properly collateralized.                                             *\n     ************************************************************************/\n\n    /// @notice This is a virtual function called by BaseStrategyVault which ensures that\n    /// this method is only called by Notional after an initial borrow has been made and\n    /// the deposit amount has been transferred to this vault. Will join the LP pool with\n    /// the funds given and then return the total vault shares minted.\n    function _depositFromNotional(\n        address /* account */, uint256 deposit, uint256 /* maturity */, bytes calldata data\n    ) internal override whenNotLocked returns (uint256 vaultSharesMinted) {\n        // Short circuit any zero deposit amounts\n        if (deposit == 0) return 0;\n\n        DepositParams memory params = abi.decode(data, (DepositParams));\n        uint256[] memory amounts = new uint256[](NUM_TOKENS());\n        amounts[PRIMARY_INDEX()] = deposit;\n\n        // If depositTrades are specified, then parts of the initial deposit are traded\n        // for corresponding amounts of the other pool tokens via external exchanges. If\n        // these amounts are not specified then the pool will just be joined single sided.\n        // Deposit trades are not automatically enabled on vaults since the trading module\n        // requires explicit permission for every token that can be sold by an address.\n        if (params.depositTrades.length > 0) {\n            (IERC20[] memory tokens, /* */) = TOKENS();\n            // This is an external library call so the memory location of amounts is\n            // different before and after the call.\n            amounts = StrategyUtils.executeDepositTrades(\n                tokens,\n                amounts,\n                params.depositTrades,\n                PRIMARY_INDEX()\n            );\n        }\n\n        uint256 lpTokens = _joinPoolAndStake(amounts, params.minPoolClaim);\n        return _mintVaultShares(lpTokens);\n    }\n\n    /// @notice Given a number of LP tokens minted, issues vault shares back to the holder. Vault\n    /// shares are claim on the LP tokens held by the vault. As rewards are reinvested, one vault\n    /// share is a claim on an increasing amount of LP tokens.\n    function _mintVaultShares(uint256 lpTokens) internal returns (uint256 vaultShares) {\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n        if (state.totalPoolClaim == 0) {\n            // Vault Shares are in 8 decimal precision\n            vaultShares = (lpTokens * uint256(Constants.INTERNAL_TOKEN_PRECISION)) / POOL_PRECISION();\n        } else {\n            vaultShares = (lpTokens * state.totalVaultSharesGlobal) / state.totalPoolClaim;\n        }\n\n        // Updates internal storage here\n        state.totalPoolClaim += lpTokens;\n        state.totalVaultSharesGlobal += vaultShares.toUint80();\n        state.setStrategyVaultState();\n\n        // Checks that the vault does not own too large of a portion of the pool. If this is the case,\n        // single sided exits may have a detrimental effect on the liquidity.\n        uint256 maxPoolShare = VaultStorage.getStrategyVaultSettings().maxPoolShare;\n        uint256 maxSupplyThreshold = (_totalPoolSupply() * maxPoolShare) / Constants.VAULT_PERCENT_BASIS;\n        if (maxSupplyThreshold < state.totalPoolClaim)\n            revert Errors.PoolShareTooHigh(state.totalPoolClaim, maxSupplyThreshold);\n    }\n\n    /// @notice This is a virtual function called by BaseStrategyVault which ensures that\n    /// this method is only called by Notional after an initial position has been made. Will\n    /// withdraw the LP tokens from the pool, either single sided or proportionally. On a\n    /// proportional exit, will trade all the tokens back to the primary in order to exit the pool.\n    /// @return finalPrimaryBalance which is the amount of funds that the vault will transfer back\n    /// to Notional and the account to repay debts and withdraw profits.\n    function _redeemFromNotional(\n        address /* account */, uint256 vaultShares, uint256 /* maturity */, bytes calldata data\n    ) internal override whenNotLocked returns (uint256 finalPrimaryBalance) {\n        // Short circuit any zero redemption amounts, this can occur during rolling positions\n        // or withdraw cash balances post liquidation.\n        if (vaultShares == 0) return 0;\n\n        // Updates internal account to deduct the vault shares.\n        uint256 poolClaim = _redeemVaultShares(vaultShares);\n        RedeemParams memory params = abi.decode(data, (RedeemParams));\n\n        bool isSingleSided = params.redemptionTrades.length == 0;\n        // Returns the amount of each token that has been withdrawn from the pool.\n        uint256[] memory exitBalances = _unstakeAndExitPool(poolClaim, params.minAmounts, isSingleSided);\n        if (!isSingleSided) {\n            // If not a single sided trade, will execute trades back to the primary token on\n            // external exchanges. This method will execute EXACT_IN trades to ensure that\n            // all of the balance in the other tokens is sold for primary.\n            (IERC20[] memory tokens, /* */) = TOKENS();\n            // Redemption trades are not automatically enabled on vaults since the trading module\n            // requires explicit permission for every token that can be sold by an address.\n            return StrategyUtils.executeRedemptionTrades(\n                tokens,\n                exitBalances,\n                params.redemptionTrades,\n                PRIMARY_INDEX()\n            );\n        } else {\n            // No explicit check is done here to ensure that the other balances are zero, assumed\n            // that the `_unstakeAndExitPool` method on the implementation is correct and will only\n            // ever withdraw to a single balance.\n            return exitBalances[PRIMARY_INDEX()];\n        }\n    }\n\n    /// @notice Updates internal account for vault share redemption.\n    function _redeemVaultShares(uint256 vaultShares) internal returns (uint256 poolClaim) {\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n        // Will revert on divide by zero, which is the correct behavior\n        poolClaim = (vaultShares * state.totalPoolClaim) / state.totalVaultSharesGlobal;\n\n        state.totalPoolClaim -= poolClaim;\n        // Will revert on underflow if vault shares is greater than total shares global\n        state.totalVaultSharesGlobal -= vaultShares.toUint80();\n        state.setStrategyVaultState();\n    }\n\n    /// @notice Converts the vault shares to an oracle value in underlying tokens. Used by Notional\n    /// to determine the collateral position of a vault user. If the vault is locked due to an\n    /// emergency exit, this function will revert which will prevent users from entering, exiting,\n    /// and being liquidated. During emergency exit, the vault will not be holding any LP tokens and\n    /// therefore this calculation will not be correct.\n    function convertStrategyToUnderlying(\n        address /* */, uint256 vaultShares, uint256 /* */\n    ) public view override whenNotLocked returns (int256 underlyingValue) {\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n        // Will revert on divide by zero, which is the correct behavior\n        uint256 lpTokens = (vaultShares * state.totalPoolClaim) / state.totalVaultSharesGlobal;\n        uint256 oneLPValueInPrimary = _checkPriceAndCalculateValue();\n\n        return (oneLPValueInPrimary * lpTokens / POOL_PRECISION()).toInt();\n    }\n\n    /// @notice Returns the pair price of two tokens via the TRADING_MODULE which holds a registry\n    /// of oracles. Will revert of the oracle pair is not listed.\n    function _getOraclePairPrice(address base, address quote) internal view returns (uint256) {\n        (int256 rate, int256 precision) = TRADING_MODULE.getOraclePrice(base, quote);\n        require(rate > 0);\n        require(precision > 0);\n        return uint256(rate) * POOL_PRECISION() / uint256(precision);\n    }\n\n    /// @notice Helper method called by _checkPriceAndCalculateValue which will supply the relevant\n    /// pool balances and spot prices. Calculates the claim of one LP token on relevant pool balances\n    /// and compares the oracle price to the spot price, reverting if the deviation is too high.\n    /// @return oneLPValueInPrimary the value of one LP token in terms of the primary borrowed currency\n    function _calculateLPTokenValue(\n        uint256[] memory balances,\n        uint256[] memory spotPrices\n    ) internal view returns (uint256 oneLPValueInPrimary) {\n        (IERC20[] memory tokens, uint8[] memory decimals) = TOKENS();\n        address primaryToken = address(tokens[PRIMARY_INDEX()]);\n        uint256 primaryDecimals = 10 ** decimals[PRIMARY_INDEX()];\n        uint256 totalSupply = _totalPoolSupply();\n        uint256 limit = VaultStorage.getStrategyVaultSettings().oraclePriceDeviationLimitPercent;\n\n        for (uint256 i; i < tokens.length; i++) {\n            // Skip the pool token if it is in the token list (i.e. ComposablePools)\n            if (address(tokens[i]) == address(POOL_TOKEN())) continue;\n            // This is the claim on the pool balance of 1 LP token.\n            uint256 tokenClaim = balances[i] * POOL_PRECISION() / totalSupply;\n            if (i == PRIMARY_INDEX()) {\n                oneLPValueInPrimary += tokenClaim;\n            } else {\n                uint256 price = _getOraclePairPrice(primaryToken, address(tokens[i]));\n\n                // Check that the spot price and the oracle price are near each other. If this is\n                // not true then we assume that the LP pool is being manipulated.\n                uint256 lowerLimit = price * (Constants.VAULT_PERCENT_BASIS - limit) / Constants.VAULT_PERCENT_BASIS;\n                uint256 upperLimit = price * (Constants.VAULT_PERCENT_BASIS + limit) / Constants.VAULT_PERCENT_BASIS;\n                if (spotPrices[i] < lowerLimit || upperLimit < spotPrices[i]) {\n                    revert Errors.InvalidPrice(price, spotPrices[i]);\n                }\n\n                // Convert the token claim to primary using the oracle pair price.\n                uint256 secondaryDecimals = 10 ** decimals[i];\n                oneLPValueInPrimary += (tokenClaim * POOL_PRECISION() * primaryDecimals) / \n                    (price * secondaryDecimals);\n            }\n        }\n    }\n\n    /************************************************************************\n     * REWARD REINVESTMENT                                                  *\n     * Methods used by bots to claim reward tokens and reinvest them as LP  *\n     * tokens which are donated to all vault users.                         *\n     ************************************************************************/\n\n    /// @notice Ensures that only whitelisted bots can claim reward tokens.\n    function claimRewardTokens() external override onlyRole(REWARD_REINVESTMENT_ROLE) {\n        _claimRewardTokens();\n    }\n\n    /// @notice Ensures that only whitelisted bots can reinvest rewards. Since rewards\n    /// are typically less liquid than pool tokens and lack oracles, reward reinvestment\n    /// is done using explicitly set slippage limits by the reinvestment bots. Reinvestment\n    /// will fail if the spot prices are not close to the oracle prices to ensure that\n    /// there is no front running the reinvestment.\n    function reinvestReward(\n        SingleSidedRewardTradeParams[] calldata trades,\n        uint256 minPoolClaim\n    ) external whenNotLocked onlyRole(REWARD_REINVESTMENT_ROLE) returns (\n        address rewardToken,\n        uint256 amountSold,\n        uint256 poolClaimAmount\n    ) {\n        // Will revert if spot prices are not in line with the oracle values\n        _checkPriceAndCalculateValue();\n\n        // Require one trade per token, if we do not want to buy any tokens at a\n        // given index then the amount should be set to zero. This applies to pool\n        // tokens like in the ComposableStablePool.\n        require(trades.length == NUM_TOKENS());\n        uint256[] memory amounts;\n        (rewardToken, amountSold, amounts) = _executeRewardTrades(trades);\n\n        poolClaimAmount = _joinPoolAndStake(amounts, minPoolClaim);\n\n        // Increase LP token amount without minting additional vault shares\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n        state.totalPoolClaim += poolClaimAmount;\n        state.setStrategyVaultState();\n\n        emit RewardReinvested(rewardToken, amountSold, poolClaimAmount);\n    }\n\n    function _executeRewardTrades(SingleSidedRewardTradeParams[] calldata trades) internal returns (\n        address rewardToken,\n        uint256 amountSold,\n        uint256[] memory amounts\n    ) {\n        // The sell token on all trades must be the same (checked inside executeRewardTrades) so\n        // just validate here that the sellToken is a valid reward token (i.e. none of the tokens\n        // used in the regular functioning of the vault).\n        rewardToken = trades[0].sellToken;\n        if (_isInvalidRewardToken(rewardToken)) revert Errors.InvalidRewardToken(rewardToken);\n        (IERC20[] memory tokens, /* */) = TOKENS();\n        (amounts, amountSold) = StrategyUtils.executeRewardTrades(\n            tokens, trades, rewardToken, address(POOL_TOKEN())\n        );\n    }\n\n    /************************************************************************\n     * EMERGENCY EXIT                                                       *\n     * In case of an emergency, will allow a whitelisted guardian to exit   *\n     * funds on the vault and locks the vault from further usage. The owner *\n     * can restore funds to the LP pool and reinstante vault usage. If the  *\n     * vault cannot be fully restored after an exit, the vault will need to *\n     * be upgraded and unwound manually to ensure that debts are repaid and *\n     * users can withdraw their funds.                                      *\n     ************************************************************************/\n\n    /// @notice Allows the function to execute only when the vault is not locked\n    modifier whenNotLocked() {\n        if (isLocked()) revert Errors.VaultLocked();\n        _;\n    }\n\n    /// @notice Allows the function to execute only when the vault is locked\n    modifier whenLocked() {\n        if (!isLocked()) revert Errors.VaultNotLocked();\n        _;\n    }\n\n    /// @notice Checks if a flag bit is set\n    function _hasFlag(uint32 flags, uint32 flagID) private pure returns (bool) {\n        return (flags & flagID) == flagID;\n    }\n\n    /// @notice Locks the vault, preventing deposits and redemptions. Used during\n    /// emergency exit\n    function _lockVault() internal {\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n        // Set locked flag\n        state.flags = state.flags | FLAG_LOCKED;\n        VaultStorage.setStrategyVaultState(state);\n        emit VaultLocked();\n    }\n\n    /// @notice Unlocks the vault, called during restore vault.\n    function _unlockVault() internal {\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n        // Remove locked flag\n        state.flags = state.flags & ~FLAG_LOCKED;\n        VaultStorage.setStrategyVaultState(state);\n        emit VaultUnlocked();\n    }\n\n    /// @notice Allows the emergency exit role to trigger an emergency exit on the vault.\n    /// In this situation, the `claimToExit` is withdrawn proportionally to the underlying\n    /// tokens and held on the vault. The vault is locked so that no entries, exits or\n    /// valuations of vaultShares can be performed.\n    /// @param claimToExit if this is set to zero, the entire pool claim is withdrawn\n    function emergencyExit(\n        uint256 claimToExit, bytes calldata /* data */\n    ) external override onlyRole(EMERGENCY_EXIT_ROLE) {\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n        if (claimToExit == 0) claimToExit = state.totalPoolClaim;\n\n        // By setting min amounts to zero, we will accept whatever tokens come from the pool\n        // in a proportional exit. Front running will not have an effect since no trading will\n        // occur during a proportional exit.\n        _unstakeAndExitPool(claimToExit, new uint256[](NUM_TOKENS()), true);\n\n        state.totalPoolClaim = state.totalPoolClaim - claimToExit;\n        state.setStrategyVaultState();\n\n        emit EmergencyExit(claimToExit);\n        _lockVault();\n    }\n\n    /// @notice Restores withdrawn tokens from emergencyExit back into the vault proportionally.\n    /// Unlocks the vault after restoration so that normal functionality is restored.\n    /// @param minPoolClaim slippage limit to prevent front running\n    function restoreVault(\n        uint256 minPoolClaim, bytes calldata /* data */\n    ) external override whenLocked onlyNotionalOwner {\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n\n        (IERC20[] memory tokens, /* */) = TOKENS();\n        uint256[] memory amounts = new uint256[](tokens.length);\n\n        // All balances held by the vault are assumed to be used to re-enter\n        // the pool. Since the vault has been locked no other users should have\n        // been able to enter the pool.\n        for (uint256 i; i < tokens.length; i++) {\n            if (address(tokens[i]) == address(POOL_TOKEN())) continue;\n            amounts[i] = TokenUtils.tokenBalance(address(tokens[i]));\n        }\n\n        // No trades are specified so this joins proportionally using the\n        // amounts specified.\n        uint256 poolTokens = _joinPoolAndStake(amounts, minPoolClaim);\n\n        state.totalPoolClaim = state.totalPoolClaim + poolTokens;\n        state.setStrategyVaultState();\n\n        _unlockVault();\n    }\n\n    // Storage gap for future potential upgrades\n    uint256[100] private __gap;\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/BalancerComposableAuraVault.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {NotionalProxy} from \"../../interfaces/notional/NotionalProxy.sol\";\nimport {Deployments} from \"../global/Deployments.sol\";\nimport {BalancerSpotPrice} from \"./balancer/BalancerSpotPrice.sol\";\nimport {\n    AuraStakingMixin,\n    AuraVaultDeploymentParams,\n    DeploymentParams\n} from \"./balancer/mixins/AuraStakingMixin.sol\";\nimport {IComposablePool} from \"../../interfaces/balancer/IBalancerPool.sol\";\nimport {IBalancerVault} from \"../../interfaces/balancer/IBalancerVault.sol\";\n\ncontract BalancerComposableAuraVault is AuraStakingMixin {\n    /// @notice Helper singleton function to calculate spot prices\n    BalancerSpotPrice immutable SPOT_PRICE;\n\n    constructor(\n        NotionalProxy notional_,\n        AuraVaultDeploymentParams memory params,\n        BalancerSpotPrice _spotPrice\n    ) AuraStakingMixin(notional_, params) {\n        // BPT_INDEX must be defined for a composable pool\n        require(BPT_INDEX != NOT_FOUND);\n        SPOT_PRICE = _spotPrice;\n    }\n\n    /// @notice strategy identifier\n    function strategy() external override pure returns (bytes4) {\n        return bytes4(keccak256(\"BalancerComposableAuraVault\"));\n    }\n\n    function _joinPoolAndStake(\n        uint256[] memory amounts, uint256 minPoolClaim\n    ) internal override returns (uint256 lpTokens) {\n        // Composable pool custom data does not include the BPT token amount so \n        // we loop here to remove it from the customData\n        uint256[] memory amountsWithoutBpt = new uint256[](amounts.length - 1);\n        uint256 j;\n        for (uint256 i; i < amounts.length; i++) {\n            if (i == BPT_INDEX) continue;\n            amountsWithoutBpt[j] = amounts[i];\n            j++;\n        }\n\n        bytes memory customData = abi.encode(\n            IBalancerVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,\n            amountsWithoutBpt,\n            minPoolClaim\n        );\n\n        lpTokens = _joinPoolExactTokensIn(amounts, customData);\n\n        // Transfer token to Aura protocol for boosted staking\n        bool success = AURA_BOOSTER.deposit(AURA_POOL_ID, lpTokens, true);\n        require(success);\n    }\n\n    function _unstakeAndExitPool(\n        uint256 poolClaim, uint256[] memory minAmounts, bool isSingleSided\n    ) internal override returns (uint256[] memory exitBalances) {\n        bool success = AURA_REWARD_POOL.withdrawAndUnwrap(poolClaim, false); // claimRewards = false\n        require(success);\n\n        bytes memory customData;\n        if (isSingleSided) {\n            // See this line here:\n            // https://github.com/balancer/balancer-v2-monorepo/blob/c7d4abbea39834e7778f9ff7999aaceb4e8aa048/pkg/pool-stable/contracts/ComposableStablePool.sol#L927\n            // While \"assets\" sent to the vault include the BPT token the tokenIndex passed in by this\n            // function does not include the BPT. primaryIndex in this code is inclusive of the BPT token in\n            // the assets array. Therefore, if primaryIndex > bptIndex subtract one to ensure that the primaryIndex\n            // does not include the BPT token here.\n            uint256 primaryIndex = PRIMARY_INDEX();\n            customData = abi.encode(\n                IBalancerVault.ComposableExitKind.EXACT_BPT_IN_FOR_ONE_TOKEN_OUT,\n                poolClaim,\n                primaryIndex < BPT_INDEX ?  primaryIndex : primaryIndex - 1\n            );\n        } else {\n            customData = abi.encode(\n                IBalancerVault.ComposableExitKind.EXACT_BPT_IN_FOR_ALL_TOKENS_OUT,\n                poolClaim\n            );\n        }\n\n        exitBalances = _exitPoolExactBPTIn(minAmounts, customData);\n    }\n \n    function _checkPriceAndCalculateValue() internal view override returns (uint256) {\n        (uint256[] memory balances, uint256[] memory spotPrices) = SPOT_PRICE.getComposableSpotPrices(\n            BALANCER_POOL_ID,\n            address(BALANCER_POOL_TOKEN),\n            PRIMARY_INDEX()\n        );\n\n        // Spot prices are returned in native decimals, convert them all to POOL_PRECISION\n        // as required in the _calculateLPTokenValue method.\n        (/* */, uint8[] memory decimals) = TOKENS();\n        for (uint256 i; i < spotPrices.length; i++) {\n            spotPrices[i] = spotPrices[i] * POOL_PRECISION() / 10 ** decimals[i];\n        }\n\n        return _calculateLPTokenValue(balances, spotPrices);\n    }\n\n    /// @notice Composable pools have a different method to get the total supply\n    function _totalPoolSupply() internal view override returns (uint256) {\n        return IComposablePool(address(BALANCER_POOL_TOKEN)).getActualSupply();\n    }\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/common/SingleSidedLPVaultBase.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\";\n\nimport {BaseStrategyVault} from \"./Bas"
    }
  ]
}