{
  "Title": "H-14: Pending allowances can be exploited",
  "Content": "# Issue H-14: Pending allowances can be exploited \n\nSource: https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/140 \n\n## Found by \nGiuseppeDeLaZara, cergyk, duc\n## Summary\n\nPending allowances can be exploited in multiple places in the codebase.\n\n## Vulnerability Detail\n\n[`TOFT::marketRemoveCollateralReceiver`](https://github.com/sherlock-audit/2024-02-tapioca/blob/dc2464f420927409a67763de6ec60fe5c028ab0e/TapiocaZ/contracts/tOFT/modules/TOFTMarketReceiverModule.sol#L161) has the following flow:\n\n- It calls `removeCollateral` ona a market with the following parameters: `from = msg_user`, `to = msg_.removeParams.magnetar`.\n- Inside the `SGLCollateral::removeCollateral` `_allowedBorrow` is called and check if the `from = msg_user` address has given enough `allowanceBorrow` to the `msg.sender` which in this case is the TOFT contract. \n- So for a user to use this flow in needs to call:\n```solidity\nfunction approveBorrow(address spender, uint256 amount) external returns (bool) {\n        _approveBorrow(msg.sender, spender, amount);\n        return true;\n    }\n```\n- And give the needed allowance to the TOFT contract. \n- This results in collateral being removed and transferred into the Magnetar contract with [`yieldBox.transfer(address(this), to, collateralId, share);`](https://github.com/sherlock-audit/2024-02-tapioca/blob/dc2464f420927409a67763de6ec60fe5c028ab0e/Tapioca-bar/contracts/markets/singularity/SGLLendingCommon.sol#L57).\n- The Magnetar gets the collateral, and it can withdraw it to any address specified in the [`msg_.withdrawParams`](https://github.com/sherlock-audit/2024-02-tapioca/blob/dc2464f420927409a67763de6ec60fe5c028ab0e/TapiocaZ/contracts/tOFT/modules/TOFTMarketReceiverModule.sol#L195). \n\nThis is problematic as the `TOFT::marketRemoveCollateralReceiver` doesn't check the `msg.sender`.\nIn practice this means if Alice has called `approveBorrow` and gives the needed allowance with the intention of using the `marketRemoveCollateralReceiver` flow, Bob can use the `marketRemoveCollateralReceiver` flow and withdraw all the collateral from Alice to his address.\n\nSo, any pending allowances from any user can immediately be exploited to steal the collateral. \n\n### Other occurrences\nThere are a few other occurrences of this problematic pattern in the codebase.\n\n`TOFT::marketBorrowReceiver` expects the user to give an approval to the Magnetar contract. The approval is expected inside the `_extractTokens` function where `pearlmit.transferFromERC20(_from, address(this), address(_token), _amount);` is called.\nAgain, the `msg.sender` is not checked inside the `marketBorrowReceiver` function, so this flow can be abused by another user to borrow and withdraw the borrowed amount to his address. \n\n`TOFT::mintLendXChainSGLXChainLockAndParticipateReceiver` also allows to borrow inside the BigBang market and withdraw the borrowed amount to an arbitrary address.\n\n`TOF::exerciseOptionsReceiver` has the [`_internalTransferWithAllowance`](https://github.com/sherlock-audit/2024-02-tapioca/blob/dc2464f420927409a67763de6ec60fe5c028ab0e/TapiocaZ/contracts/tOFT/modules/TOFTOptionsReceiverModule.sol#L156) function that simply allows to transfer TOFT tokens from any `_options.from` address that has given an allowance to `srcChainSender`, by anyone that calls this function.\nIt allows to forcefully call the `exerciseOptionsReceiver` on behalf of any other user. \n\n`USDO::depositLendAndSendForLockingReceiver` also expects the user to give an allowance to the Magnetar contract, i.e. `MagnetarAssetXChainModule::depositYBLendSGLLockXchainTOLP` calls the `_extractTokens`. \n\n## Impact\n\nThe impact of this vulnerability is that any pending allowances from any user can immediately be exploited to steal the collateral/borrowed amount.\n\n## Code Snippet\n- https://github.com/sherlock-audit/2024-02-tapioca/blob/dc2464f420927409a67763de6ec60fe5c028ab0e/TapiocaZ/contracts/tOFT/modules/TOFTMarketReceiverModule.sol#L161\n- https://github.com/sherlock-audit/2024-02-tapioca/blob/dc2464f420927409a67763de6ec60fe5c028ab0e/TapiocaZ/contracts/tOFT/modules/TOFTMarketReceiverModule.sol#L108\n\n## Tool used\n\nManual Review\n\n## Recommendation\nThere are multiple instances of issues with dangling allowances in the protocol. Review all the allowance flows and make sure it can't be exploited. \n\n\n\n## Discussion\n\n**sherlock-admin4**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  seem invalid to me as the approval is made withing the function call which means user doesn't have to call the said approve function\n\n\n\n**nevillehuang**\n\nrequest poc\n\n**sherlock-admin3**\n\nPoC requested from @windhustler\n\nRequests remaining: **2**\n\n**windhustler**\n\nLet's imagine Alice has some collateral inside the Singularity Market on Avalanche. \n\nShe wants to remove that collateral and initiates a transaction from Ethereum. \n\nHer transaction on Avalanche will call `TOFTMarketReceiverModule::marketRemoveCollateralReceiver` where `Market::removeCollateral` through `IMarket(msg_.removeParams.market).execute(modules, calls, true);`is called.\n\n```solidity\n## SGLCollateral.sol\n\nfunction removeCollateral(address from, address to, uint256 share)\n        external\n        optionNotPaused(PauseType.RemoveCollateral)\n        solvent(from, false)\n        allowedBorrow(from, share)\n        notSelf(to)\n    {\n        _removeCollateral(from, to, share);\n    }\n\n/**\n* @inheritdoc MarketERC20\n     */\n    function _allowedBorrow(address from, uint256 share) internal virtual override {\n        if (from != msg.sender) {\n            // TODO review risk of using this\n>>>            (uint256 pearlmitAllowed,) = penrose.pearlmit().allowance(from, msg.sender, address(yieldBox), collateralId); // Alice needs to give allowance to TOFT\n>>>            require(allowanceBorrow[from][msg.sender] >= share || pearlmitAllowed >= share, \"Market: not approved\"); // Alice needs to give allowance to TOFT.\n            if (allowanceBorrow[from][msg.sender] != type(uint256).max) {\n                allowanceBorrow[from][msg.sender] -= share;\n            }\n        }\n    }\n\n    \n\n    function _removeCollateral(address from, address to, uint256 share) internal {\n        userCollateralShare[from] -= share;\n        totalCollateralShare -= share;\n        emit LogRemoveCollateral(from, to, share);\n        yieldBox.transfer(address(this), to, collateralId, share);\n    }\n```\n\n- Remove collateral is called with `msg.sender = TOFT`, `from = Alice`, `to = Magnetar`, and `share = 10`;\n- And then Magnetar withdraws the collateral on another chain to Alice's address or any other address that is set in `MagnetarWithdrawData.LzSendParams.SendParam.to`, i.e. this can be any address. \n\nSo prerequisite for this flow to work is that Alice has:\n\na) Given allowance to the TOFT contract through the Pearlmit contract.\nb) Given the allowance to the TOFT contract through the `allowanceBorrow` function.\n\nIn other words, Alice needs to call in a separate transaction:\n\n```solidity\nSingularity.approveBorrow(TOFT, 10)\n```\n\nand\n\n```solidity\nPermiC.approve(address(yieldBox), collateralId, address(TOFT), 10, block.timestamp + 1 hour);\n```\n\nBut if Alice has ever given the two allowances listed above, Bob can front-run Alice's `TOFTMarketReceiverModule::marketRemoveCollateralReceiver` transaction and just call it with the following params:\n\n- `from =  Alice` \n- `MagnetarWithdrawData.LzSendParams.SendParam.to = Bob`\n- As a consequence, Bob will steal Alice's collateral.\n\nThis is possible due to two reasons:\n\n```solidity\n## TOFTMarketReceiverModule.sol\n{\n            uint256 share = IYieldBox(ybAddress).toShare(assetId, msg_.removeParams.amount, false);\n>>>            approve(msg_.removeParams.market, share);\n\n            (Module[] memory modules, bytes[] memory calls) = IMarketHelper(msg_.removeParams.marketHelper)\n                .removeCollateral(msg_.user, msg_.withdrawParams.withdraw ? msg_.removeParams.magnetar : msg_.user, share);\n            IMarket(msg_.removeParams.market).execute(modules, calls, true);\n        }\n```\n- This `approve` is useless here. In the normal cross-chain call the `msg.sender` is the lzEndpoint so the `approve` does nothing. As I have described approvals should be given separately.\n- `marketRemoveCollateralReceiver` is coded in a way that `msg.sender` is irrelevant which ties to the point above. \n\n\nTo give an analogy, this is almost as Alice giving allowance to UniswapV3 to use her tokens and then Bob can just exploit this allowance to drain Alice's funds.\nIt would make sense if Alice has given the allowance to Bob for using her funds, but this is not the case here.\n\n\nLet me know if this makes sense or if you need further clarification.\n\n\n**nevillehuang**\n\n@windhustler This seems to be a duplicate of #31\n\n**windhustler**\n\n#31 Makes the claim if Alice gives the allowance to Bob, he can abuse it under certain conditions. And it specifies a single instance related to `buyCollateral` flow. \n\nMy issue makes the claim that if Alice gives allowance to TOFT to execute a simple cross-chain flow, i.e.[TOFT::marketRemoveCollateralReceiver](https://github.com/sherlock-audit/2024-02-tapioca/blob/dc2464f420927409a67763de6ec60fe5c028ab0e/TapiocaZ/contracts/tOFT/modules/TOFTMarketReceiverModule.sol#L161), Bob can come along and steal all the collateral from Alice. It's quite different as Alice hasn't given any allowance to Bob at all. It makes the impact and mitigation different. \n\nMy issue also states **several other occurrences** that are similar in nature.\n\n**nevillehuang**\n\n@cryptotechmaker What do you think? I think this could be the primary issue and #31 and duplicates could be duplicated. Would the mitigation be different between these issues?\n\n**cryptotechmaker**\n\n@nevillehuang wouldn't this one and #19 be more or less duplicates? \n\nThese are the PRs I did for 19, which might solve it as well\n\nhttps://github.com/Tapioca-DAO/Tapioca-bar/pull/348\n\nhttps://github.com/Tapioca-DAO/TapiocaZ/pull/172\n\n**cryptotechmaker**\n\nIssue #137 is similar as well with the difference that 137 mentioned about some missing approvals. However it's still related to the allowance system\n\n**nevillehuang**\n\n@cryptotechmaker Here are the issues related to allowances that seems very similar:\n\n#19 \n#31\n#137\n#140\n\nFinding it hard to decide on duplication, will update again. Are the fixes similar in these issues?\n\n**cryptotechmaker**\n\n@nevillehuang  I would add https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/134 on that list as well\n\n**cryptotechmaker**\n\nWe'll analyze them this week but yes, I think those are duplicates\n\n**nevillehuang**\n\n@cryptotechmaker I believe\n\n#19 to be a duplicate of #134\n#31 to be a duplicate of #140\n#137 Separate issue\n\n**HollaDieWaldfee100**\n\nEscalate\n\nThe report explains how in a regular cross-chain flow where TOFT::marketRemoveCollateralReceiver gets called it is expected of the user to give the allowance to the TOFT contract. Setting allowances is a precondition for this flow to be possible, not some extra requirement. \nThen it describes how this can be abused by an attacker to steal all the user’s tokens. There are other issues that describe how user loss occurs while another cross-chain flow is being used in a “valid use case scenario”: https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/130\nBased on the arguments above there is no special precondition here so this should be a valid high.\n\n**sherlock-admin2**\n\n> Escalate\n> \n> The report explains how in a regular cross-chain flow where TOFT::marketRemoveCollateralReceiver gets called it is expected of the user to give the allowance to the TOFT contract. Setting allowances is a precondition for this flow to be possible, not some extra requirement. \n> Then it describes how this can be abused by an attacker to steal all the user’s tokens. There are other issues that describe how user loss occurs while another cross-chain flow is being used in a “valid use case scenario”: https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/130\n> Based on the arguments above there is no special precondition here so this should be a valid high.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**cvetanovv**\n\nWatson has demonstrated very well how a malicious user can front-run an honest user and steal his allowance, and in this way, he can steal his collateral. \n\nSo I plan to accept the escalation and make this issue High.\n\n**Evert0x**\n\nResult:\nHigh\nHas Duplicates\n\n**sherlock-admin3**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [HollaDieWaldfee100](https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/140/#issuecomment-2034517121): accepted\n\n**0xRektora**\n\nAs a reference: #109 fixes this and any related dangling allowance\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/170",
  "Code": [
    {
      "filename": "TapiocaZ/contracts/tOFT/modules/TOFTMarketReceiverModule.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {BytesLib} from \"solidity-bytes-utils/contracts/BytesLib.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n// Tapioca\nimport {\n    TOFTInitStruct,\n    MarketBorrowMsg,\n    MarketRemoveCollateralMsg,\n    LeverageUpActionMsg\n} from \"tapioca-periph/interfaces/oft/ITOFT.sol\";\nimport {\n    IMagnetar,\n    MagnetarCall,\n    DepositAddCollateralAndBorrowFromMarketData,\n    MagnetarAction\n} from \"tapioca-periph/interfaces/periph/IMagnetar.sol\";\nimport {MagnetarCollateralModule} from \"tapioca-periph/Magnetar/modules/MagnetarCollateralModule.sol\";\nimport {MagnetarYieldBoxModule} from \"tapioca-periph/Magnetar/modules/MagnetarYieldBoxModule.sol\";\nimport {IMarketHelper} from \"tapioca-periph/interfaces/bar/IMarketHelper.sol\";\nimport {IYieldBox} from \"tapioca-periph/interfaces/yieldbox/IYieldBox.sol\";\nimport {IMarket, Module} from \"tapioca-periph/interfaces/bar/IMarket.sol\";\nimport {TOFTMsgCodec} from \"contracts/tOFT/libraries/TOFTMsgCodec.sol\";\nimport {BaseTOFT} from \"contracts/tOFT/BaseTOFT.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title TOFTMarketReceiverModule\n * @author TapiocaDAO\n * @notice TOFT Market module\n */\ncontract TOFTMarketReceiverModule is BaseTOFT {\n    using SafeERC20 for IERC20;\n    using BytesLib for bytes;\n    using SafeCast for uint256;\n\n    error TOFTMarketReceiverModule_NotAuthorized(address invalidAddress);\n\n    event BorrowReceived(\n        address indexed user, address indexed market, uint256 indexed amount, bool deposit, bool withdraw\n    );\n\n    event RemoveCollateralReceived(address indexed user, address indexed market, uint256 indexed amount, bool withdraw);\n\n    event LeverageUpReceived(\n        address indexed user, address indexed market, uint256 indexed amount, uint256 supplyAmount\n    );\n\n    constructor(TOFTInitStruct memory _data) BaseTOFT(_data) {}\n\n    /**\n     * @notice Calls `buyCollateral` on a market\n     * @param _data The call data containing info about the operation.\n     *      - user::address: Address to leverage for.\n     *      - market::address: Address of the market.\n     *      - borrowAmount::address: Borrow amount to leverage with.\n     *      - supplyAmount::address: Extra asset amount used for the leverage operation.\n     *      - executorData::bytes: Leverage executor data.\n     */\n    function leverageUpReceiver(bytes memory _data) public payable {\n        /// @dev decode received message\n        LeverageUpActionMsg memory msg_ = TOFTMsgCodec.decodeLeverageUpMsg(_data);\n\n        /// @dev 'market'\n        _checkWhitelistStatus(msg_.market);\n\n        msg_.borrowAmount = _toLD(msg_.borrowAmount.toUint64());\n        if (msg_.supplyAmount > 0) {\n            msg_.supplyAmount = _toLD(msg_.supplyAmount.toUint64());\n        }\n\n        approve(address(msg_.market), type(uint256).max);\n\n        {\n            (Module[] memory modules, bytes[] memory calls) = IMarketHelper(msg_.marketHelper).buyCollateral(\n                msg_.user, msg_.borrowAmount, msg_.supplyAmount, msg_.executorData\n            );\n            IMarket(msg_.market).execute(modules, calls, true);\n        }\n\n        approve(address(msg_.market), 0);\n\n        emit LeverageUpReceived(msg_.user, msg_.market, msg_.borrowAmount, msg_.supplyAmount);\n    }\n\n    /**\n     * @notice Calls depositAddCollateralAndBorrowFromMarket on Magnetar\n     * @param _data The call data containing info about the operation.\n     *      - from::address: Address to debit tokens from.\n     *      - to::address: Address to execute operations on.\n     *      - borrowParams::struct: Borrow operation related params.\n     *      - withdrawParams::struct: Withdraw related params.\n     */\n    function marketBorrowReceiver(bytes memory _data) public payable {\n        /// @dev decode received message\n        MarketBorrowMsg memory msg_ = TOFTMsgCodec.decodeMarketBorrowMsg(_data);\n\n        _checkWhitelistStatus(msg_.borrowParams.marketHelper);\n        _checkWhitelistStatus(msg_.borrowParams.magnetar);\n        _checkWhitelistStatus(msg_.borrowParams.market);\n\n        msg_.borrowParams.amount = _toLD(msg_.borrowParams.amount.toUint64());\n        msg_.borrowParams.borrowAmount = _toLD(msg_.borrowParams.borrowAmount.toUint64());\n\n        /// @dev use market helper to deposit, add collateral to market and withdrawTo\n        approve(address(msg_.borrowParams.magnetar), msg_.borrowParams.amount);\n\n        bytes memory call = abi.encodeWithSelector(\n            MagnetarCollateralModule.depositAddCollateralAndBorrowFromMarket.selector,\n            DepositAddCollateralAndBorrowFromMarketData(\n                msg_.borrowParams.market,\n                msg_.borrowParams.marketHelper,\n                msg_.user,\n                msg_.borrowParams.amount,\n                msg_.borrowParams.borrowAmount,\n                msg_.borrowParams.deposit,\n                msg_.withdrawParams\n            )\n        );\n        MagnetarCall[] memory magnetarCall = new MagnetarCall[](1);\n        magnetarCall[0] = MagnetarCall({\n            id: MagnetarAction.CollateralModule,\n            target: msg_.borrowParams.market,\n            value: msg.value,\n            allowFailure: false,\n            call: call\n        });\n        IMagnetar(payable(msg_.borrowParams.magnetar)).burst{value: msg.value}(magnetarCall);\n\n        emit BorrowReceived(\n            msg_.user,\n            msg_.borrowParams.market,\n            msg_.borrowParams.amount,\n            msg_.borrowParams.deposit,\n            msg_.withdrawParams.withdraw\n        );\n    }\n\n    /**\n     * @notice Performs market.removeCollateral()\n     * @param _data The call data containing info about the operation.\n     *      - from::address: Address to debit tokens from.\n     *      - to::address: Address to execute operations on.\n     *      - removeParams::struct: Remove collateral operation related params.\n     *      - withdrawParams::struct: Withdraw related params.\n     */\n    function marketRemoveCollateralReceiver(bytes memory _data) public payable {\n        /// @dev decode received message\n        MarketRemoveCollateralMsg memory msg_ = TOFTMsgCodec.decodeMarketRemoveCollateralMsg(_data);\n\n        _checkWhitelistStatus(msg_.removeParams.market);\n\n        address ybAddress = IMarket(msg_.removeParams.market).yieldBox();\n        uint256 assetId = IMarket(msg_.removeParams.market).collateralId();\n\n        msg_.removeParams.amount = _toLD(msg_.removeParams.amount.toUint64());\n\n        {\n            uint256 share = IYieldBox(ybAddress).toShare(assetId, msg_.removeParams.amount, false);\n            approve(msg_.removeParams.market, share);\n\n            (Module[] memory modules, bytes[] memory calls) = IMarketHelper(msg_.removeParams.marketHelper)\n                .removeCollateral(msg_.user, msg_.withdrawParams.withdraw ? msg_.removeParams.magnetar : msg_.user, share);\n            IMarket(msg_.removeParams.market).execute(modules, calls, true);\n        }\n\n        {\n            if (msg_.withdrawParams.withdraw) {\n                _checkWhitelistStatus(msg_.removeParams.magnetar);\n\n                bytes memory call =\n                    abi.encodeWithSelector(MagnetarYieldBoxModule.withdrawToChain.selector, msg_.withdrawParams);\n                MagnetarCall[] memory magnetarCall = new MagnetarCall[](1);\n                magnetarCall[0] = MagnetarCall({\n                    id: MagnetarAction.YieldBoxModule,\n                    target: address(this),\n                    value: msg.value,\n                    allowFailure: false,\n                    call: call\n                });\n                IMagnetar(payable(msg_.removeParams.magnetar)).burst{value: msg.value}(magnetarCall);\n            }\n        }\n\n        emit RemoveCollateralReceived(\n            msg_.user, msg_.removeParams.market, msg_.removeParams.amount, msg_.withdrawParams.withdraw\n        );\n    }\n\n    function _checkWhitelistStatus(address _addr) private view {\n        if (_addr != address(0)) {\n            if (!cluster.isWhitelisted(0, _addr)) {\n                revert TOFTMarketReceiverModule_NotAuthorized(_addr);\n            }\n        }\n    }\n}"
    },
    {
      "filename": "Tapioca-bar/contracts/markets/singularity/SGLLendingCommon.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {RebaseLibrary, Rebase} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport {BoringERC20, IERC20} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n// Tapioca\nimport {SGLCommon} from \"./SGLCommon.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ncontract SGLLendingCommon is SGLCommon {\n    using RebaseLibrary for Rebase;\n    using BoringERC20 for IERC20;\n    using SafeCast for uint256;\n\n    // ************** //\n    // *** ERRORS *** //\n    // ************** //\n    error BorrowCapReached();\n    error NothingToRepay();\n    error AllowanceNotValid();\n\n    // ************************** //\n    // *** PRIVATE FUNCTIONS *** //\n    // ************************* //\n    /// @dev Concrete implementation of `addCollateral`.\n    function _addCollateral(address from, address to, bool skim, uint256 amount, uint256 share) internal {\n        if (share == 0) {\n            share = yieldBox.toShare(collateralId, amount, false);\n        }\n        uint256 oldTotalCollateralShare = totalCollateralShare;\n        userCollateralShare[to] += share;\n        totalCollateralShare = oldTotalCollateralShare + share;\n\n        _addTokens(from, to, collateralId, share, oldTotalCollateralShare, skim);\n\n        emit LogAddCollateral(skim ? address(yieldBox) : from, to, share);\n    }\n\n    /// @dev Concrete implementation of `removeCollateral`.\n    function _removeCollateral(address from, address to, uint256 share) internal {\n        userCollateralShare[from] -= share;\n        totalCollateralShare -= share;\n        emit LogRemoveCollateral(from, to, share);\n        yieldBox.transfer(address(this), to, collateralId, share);\n    }\n\n    /// @dev Concrete implementation of `borrow`.\n    function _borrow(address from, address to, uint256 amount) internal returns (uint256 part, uint256 share) {\n        share = yieldBox.toShare(assetId, amount, true);\n        Rebase memory _totalAsset = totalAsset;\n        if (_totalAsset.base < 1000) revert MinLimit();\n\n        uint256 fullAssetAmountBefore = yieldBox.toAmount(assetId, _totalAsset.elastic, false) + totalBorrow.elastic;\n\n        _totalAsset.elastic -= share.toUint128();\n\n        uint256 feeAmount = (amount * borrowOpeningFee) / FEE_PRECISION; // A flat % fee is charged for any borrow\n\n        (totalBorrow, part) = totalBorrow.add(amount + feeAmount, true);\n        if (totalBorrowCap != 0) {\n            if (totalBorrow.elastic > totalBorrowCap) revert BorrowCapReached();\n        }\n        userBorrowPart[from] += part;\n        emit LogBorrow(from, to, amount, feeAmount, part);\n\n        if (feeAmount > 0) {\n            uint256 feeFraction = (feeAmount * _totalAsset.base) / fullAssetAmountBefore;\n            _totalAsset.base += feeFraction.toUint128();\n            balanceOf[address(penrose)] += feeFraction;\n        }\n\n        totalAsset = _totalAsset;\n\n        yieldBox.transfer(address(this), to, assetId, share);\n    }\n\n    /// @dev Concrete implementation of `repay`.\n    function _repay(address from, address to, bool skim, uint256 part) internal returns (uint256 amount) {\n        if (part > userBorrowPart[to]) {\n            part = userBorrowPart[to];\n        }\n        if (part == 0) revert NothingToRepay();\n\n        if (msg.sender != from) {\n            uint256 partInAmount;\n            Rebase memory _totalBorrow = totalBorrow;\n            (_totalBorrow, partInAmount) = _totalBorrow.sub(part, false);\n\n            uint256 allowanceShare =\n                _computeAllowanceAmountInAsset(to, exchangeRate, partInAmount, _safeDecimals(asset));\n            if (allowanceShare == 0) revert AllowanceNotValid();\n            _allowedBorrow(from, allowanceShare);\n        }\n        (totalBorrow, amount) = totalBorrow.sub(part, false);\n\n        userBorrowPart[to] -= part;\n\n        uint256 share = yieldBox.toShare(assetId, amount, true);\n        uint128 totalShare = totalAsset.elastic;\n        _addTokens(from, to, assetId, share, uint256(totalShare), skim);\n        totalAsset.elastic = totalShare + share.toUint128();\n\n        emit LogRepay(skim ? address(yieldBox) : from, to, amount, part);\n    }\n\n    function _safeDecimals(IERC20 token) internal view returns (uint8) {\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x313ce567)); //decimals() selector\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\n    }\n}"
    },
    {
      "filename": "TapiocaZ/contracts/tOFT/modules/TOFTMarketReceiverModule.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {BytesLib} from \"solidity-bytes-utils/contracts/BytesLib.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n// Tapioca\nimport {\n    TOFTInitStruct,\n    MarketBorrowMsg,\n    MarketRemoveCollateralMsg,\n    LeverageUpActionMsg\n} from \"tapioca-periph/interfaces/oft/ITOFT.sol\";\nimport {\n    IMagnetar,\n    MagnetarCall,\n    DepositAddCollateralAndBorrowFromMarketData,\n    MagnetarAction\n} from \"tapioca-periph/interfaces/periph/IMagnetar.sol\";\nimport {MagnetarCollateralModule} from \"tapioca-periph/Magnetar/modules/MagnetarCollateralModule.sol\";\nimport {MagnetarYieldBoxModule} from \"tapioca-periph/Magnetar/modules/MagnetarYieldBoxModule.sol\";\nimport {IMarketHelper} from \"tapioca-periph/interfaces/bar/IMarketHelper.sol\";\nimport {IYieldBox} from \"tapioca-periph/interfaces/yieldbox/IYieldBox.sol\";\nimport {IMarket, Module} from \"tapioca-periph/interfaces/bar/IMarket.sol\";\nimport {TOFTMsgCodec} from \"contracts/tOFT/libraries/TOFTMsgCodec.sol\";\nimport {BaseTOFT} from \"contracts/tOFT/BaseTOFT.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title TOFTMarketReceiverModule\n * @author TapiocaDAO\n * @notice TOFT Market module\n */\ncontract TOFTMarketReceiverModule is BaseTOFT {\n    using SafeERC20 for IERC20;\n    using BytesLib for bytes;\n    using SafeCast for uint256;\n\n    error TOFTMarketReceiverModule_NotAuthorized(address invalidAddress);\n\n    event BorrowReceived(\n        address indexed user, address indexed market, uint256 indexed amount, bool deposit, bool withdraw\n    );\n\n    event RemoveCollateralReceived(address indexed user, address indexed market, uint256 indexed amount, bool withdraw);\n\n    event LeverageUpReceived(\n        address indexed user, address indexed market, uint256 indexed amount, uint256 supplyAmount\n    );\n\n    constructor(TOFTInitStruct memory _data) BaseTOFT(_data) {}\n\n    /**\n     * @notice Calls `buyCollateral` on a market\n     * @param _data The call data containing info about the operation.\n     *      - user::address: Address to leverage for.\n     *      - market::address: Address of the market.\n     *      - borrowAmount::address: Borrow amount to leverage with.\n     *      - supplyAmount::address: Extra asset amount used for the leverage operation.\n     *      - executorData::bytes: Leverage executor data.\n     */\n    function leverageUpReceiver(bytes memory _data) public payable {\n        /// @dev decode received message\n        LeverageUpActionMsg memory msg_ = TOFTMsgCodec.decodeLeverageUpMsg(_data);\n\n        /// @dev 'market'\n        _checkWhitelistStatus(msg_.market);\n\n        msg_.borrowAmount = _toLD(msg_.borrowAmount.toUint64());\n        if (msg_.supplyAmount > 0) {\n            msg_.supplyAmount = _toLD(msg_.supplyAmount.toUint64());\n        }\n\n        approve(address(msg_.market), type(uint256).max);\n\n        {\n            (Module[] memory modules, bytes[] memory calls) = IMarketHelper(msg_.marketHelper).buyCollateral(\n                msg_.user, msg_.borrowAmount, msg_.supplyAmount, msg_.executorData\n            );\n            IMarket(msg_.market).execute(modules, calls, true);\n        }\n\n        approve(address(msg_.market), 0);\n\n        emit LeverageUpReceived(msg_.user, msg_.market, msg_.borrowAmount, msg_.supplyAmount);\n    }\n\n    /**\n     * @notice Calls depositAddCollateralAndBorrowFromMarket on Magnetar\n     * @param _data The call data containing info about the operation.\n     *      - from::address: Address to debit tokens from.\n     *      - to::address: Address to execute operations on.\n     *      - borrowParams::struct: Borrow operation related params.\n     *      - withdrawParams::struct: Withdraw related params.\n     */\n    function marketBorrowReceiver(bytes memory _data) public payable {\n        /// @dev decode received message\n        MarketBorrowMsg memory msg_ = TOFTMsgCodec.decodeMarketBorrowMsg(_data);\n\n        _checkWhitelistStatus(msg_.borrowParams.marketHelper);\n        _checkWhitelistStatus(msg_.borrowParams.magnetar);\n        _checkWhitelistStatus(msg_.borrowParams.market);\n\n        msg_.borrowParams.amount = _toLD(msg_.borrowParams.amount.toUint64());\n        msg_.borrowParams.borrowAmount = _toLD(msg_.borrowParams.borrowAmount.toUint64());\n\n        /// @dev use market helper to deposit, add collateral to market and withdrawTo\n        approve(address(msg_.borrowParams.magnetar), msg_.borrowParams.amount);\n\n        bytes memory call = abi.encodeWithSelector(\n            MagnetarCollateralModule.depositAddCollateralAndBorrowFromMarket.selector,\n            DepositAddCollateralAndBorrowFromMarketData(\n                msg_.borrowParams.market,\n                msg_.borrowParams.marketHelper,\n                msg_.user,\n                msg_.borrowParams.amount,\n                msg_.borrowParams.borrowAmount,\n                msg_.borrowParams.deposit,\n                msg_.withdrawParams\n            )\n        );\n        MagnetarCall[] memory magnetarCall = new MagnetarCall[](1);\n        magnetarCall[0] = MagnetarCall({\n            id: MagnetarAction.CollateralModule,\n            target: msg_.borrowParams.market,\n            value: msg.value,\n            allowFailure: false,\n            call: call\n        });\n        IMagnetar(payable(msg_.borrowParams.magnetar)).burst{value: msg.value}(magnetarCall);\n\n        emit BorrowReceived(\n            msg_.user,\n            msg_.borrowParams.market,\n            msg_.borrowParams.amount,\n            msg_.borrowParams.deposit,\n            msg_.withdrawParams.withdraw\n        );\n    }\n\n    /**\n     * @notice Performs market.removeCollateral()\n     * @param _data The call data containing info about the operation.\n     *      - from::address: Address to debit tokens from.\n     *      - to::address: Address to execute operations on.\n     *      - removeParams::struct: Remove collateral operation related params.\n     *      - withdrawParams::struct: Withdraw related params.\n     */\n    function marketRemoveCollateralReceiver(bytes memory _data) public payable {\n        /// @dev decode received message\n        MarketRemoveCollateralMsg memory msg_ = TOFTMsgCodec.decodeMarketRemoveCollateralMsg(_data);\n\n        _checkWhitelistStatus(msg_.removeParams.market);\n\n        address ybAddress = IMarket(msg_.removeParams.market).yieldBox();\n        uint256 assetId = IMarket(msg_.removeParams.market).collateralId();\n\n        msg_.removeParams.amount = _toLD(msg_.removeParams.amount.toUint64());\n\n        {\n            uint256 share = IYieldBox(ybAddress).toShare(assetId, msg_.removeParams.amount, false);\n            approve(msg_.removeParams.market, share);\n\n            (Module[] memory modules, bytes[] memory calls) = IMarketHelper(msg_.removeParams.marketHelper)\n                .removeCollateral(msg_.user, msg_.withdrawParams.withdraw ? msg_.removeParams.magnetar : msg_.user, share);\n            IMarket(msg_.removeParams.market).execute(modules, calls, true);\n        }\n\n        {\n            if (msg_.withdrawParams.withdraw) {\n                _checkWhitelistStatus(msg_.removeParams.magnetar);\n\n                bytes memory call =\n                    abi.encodeWithSelector(MagnetarYieldBoxModule.withdrawToChain.selector, msg_.withdrawParams);\n                MagnetarCall[] memory magnetarCall = new MagnetarCall[](1);\n                magnetarCall[0] = MagnetarCall({\n                    id: MagnetarAction.YieldBoxModule,\n                    target: address(this),\n                    value: msg.value,\n                    allowFailure: false,\n                    call: call\n                });\n                IMagnetar(payable(msg_.removeParams.magnetar)).burst{value: msg.value}(magnetarCall);\n            }\n        }\n\n        emit RemoveCollateralReceived(\n            msg_.user, msg_.removeParams.market, msg_.removeParams.amount, msg_.withdrawParams.withdraw\n        );\n    }\n\n    function _checkWhitelistStatus(address _addr) private view {\n        if (_addr != address(0)) {\n            if (!cluster.isWhitelisted(0, _addr)) {\n                revert TOFTMarketReceiverModule_NotAuthorized(_addr);\n            }\n        }\n    }\n}"
    },
    {
      "filename": "TapiocaZ/contracts/tOFT/modules/TOFTOptionsReceiverModule.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// LZ\nimport {\n    MessagingReceipt, OFTReceipt, SendParam\n} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/interfaces/IOFT.sol\";\nimport {IOAppMsgInspector} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/interfaces/IOAppMsgInspector.sol\";\nimport {OFTMsgCodec} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/libs/OFTMsgCodec.sol\";\n\n// External\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n// Tapioca\nimport {\n    LockAndParticipateData,\n    IMagnetar,\n    MagnetarCall,\n    MagnetarAction,\n    CrossChainMintFromBBAndLendOnSGLData\n} from \"tapioca-periph/interfaces/periph/IMagnetar.sol\";\nimport {\n    ITapiocaOptionBroker, IExerciseOptionsData\n} from \"tapioca-periph/interfaces/tap-token/ITapiocaOptionBroker.sol\";\nimport {TOFTInitStruct, ExerciseOptionsMsg, LZSendParam} from \"tapioca-periph/interfaces/oft/ITOFT.sol\";\nimport {MagnetarMintXChainModule} from \"tapioca-periph/Magnetar/modules/MagnetarMintXChainModule.sol\";\nimport {TOFTMsgCodec} from \"contracts/tOFT/libraries/TOFTMsgCodec.sol\";\nimport {SafeApprove} from \"tapioca-periph/libraries/SafeApprove.sol\";\nimport {BaseTOFT} from \"contracts/tOFT/BaseTOFT.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title TOFTOptionsReceiverModule\n * @author TapiocaDAO\n * @notice TOFT Options module\n */\ncontract TOFTOptionsReceiverModule is BaseTOFT {\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n    using SafeApprove for address;\n\n    error TOFTOptionsReceiverModule_NotAuthorized(address invalidAddress);\n\n    event ExerciseOptionsReceived(\n        address indexed user, address indexed target, uint256 indexed oTapTokenId, uint256 paymentTokenAmount\n    );\n\n    constructor(TOFTInitStruct memory _data) BaseTOFT(_data) {}\n\n    /**\n     * @notice cross-chain receiver to deposit mint from BB, lend on SGL, lock on tOLP and participate on tOB\n     * @dev Cross chain flow:\n     *  step 1: magnetar.mintBBLendXChainSGL (chain A) -->\n     *         step 2: IUsdo compose call calls magnetar.depositYBLendSGLLockXchainTOLP (chain B) -->\n     *              step 3: IToft(sglReceipt) compose call calls magnetar.lockAndParticipate (chain X)\n     * @param _data.user the user to perform the operation for\n     * @param _data.bigBang the BB address\n     * @param _data.mintData the data needed to mint on BB\n     * @param _data.lendSendParams LZ send params for lending on another layer\n     */\n    function mintLendXChainSGLXChainLockAndParticipateReceiver(bytes memory _data) public payable {\n        // Decode received message.\n        CrossChainMintFromBBAndLendOnSGLData memory msg_ =\n            TOFTMsgCodec.decodeMintLendXChainSGLXChainLockAndParticipateMsg(_data);\n\n        _checkWhitelistStatus(msg_.bigBang);\n        _checkWhitelistStatus(msg_.magnetar);\n\n        if (msg_.mintData.mintAmount > 0) {\n            msg_.mintData.mintAmount = _toLD(msg_.mintData.mintAmount.toUint64());\n        }\n\n        bytes memory call = abi.encodeWithSelector(MagnetarMintXChainModule.mintBBLendXChainSGL.selector, msg_);\n        MagnetarCall[] memory magnetarCall = new MagnetarCall[](1);\n        magnetarCall[0] = MagnetarCall({\n            id: MagnetarAction.MintXChainModule,\n            target: address(this),\n            value: msg.value,\n            allowFailure: false,\n            call: call\n        });\n        IMagnetar(payable(msg_.magnetar)).burst{value: msg.value}(magnetarCall);\n    }\n\n    /**\n     * @notice Execute `magnetar.lockAndParticipate`\n     * @dev Lock on tOB and/or participate on tOLP\n     * @param _data The call data containing info about the operation.\n     * @param _data.user the user to perform the operation for\n     * @param _data.singularity the SGL address\n     * @param _data.fraction the amount to lock\n     * @param _data.lockData the data needed to lock on tOB\n     * @param _data.participateData the data needed to participate on tOLP\n     */\n    function lockAndParticipateReceiver(bytes memory _data) public payable {\n        // Decode receive message\n        LockAndParticipateData memory msg_ = TOFTMsgCodec.decodeLockAndParticipateMsg(_data);\n\n        _checkWhitelistStatus(msg_.magnetar);\n        _checkWhitelistStatus(msg_.singularity);\n        if (msg_.lockData.lock) {\n            _checkWhitelistStatus(msg_.lockData.target);\n        }\n        if (msg_.participateData.participate) {\n            _checkWhitelistStatus(msg_.participateData.target);\n        }\n\n        if (msg_.fraction > 0) {\n            msg_.fraction = _toLD(msg_.fraction.toUint64());\n        }\n\n        bytes memory call = abi.encodeWithSelector(MagnetarMintXChainModule.lockAndParticipate.selector, msg_);\n        MagnetarCall[] memory magnetarCall = new MagnetarCall[](1);\n        magnetarCall[0] = MagnetarCall({\n            id: MagnetarAction.MintXChainModule,\n            target: msg_.magnetar,\n            value: msg.value,\n            allowFailure: false,\n            call: call\n        });\n        IMagnetar(payable(msg_.magnetar)).burst{value: msg.value}(magnetarCall);\n    }\n\n    /**\n     * @notice Exercise tOB option\n     * @param _data The call data containing info about the operation.\n     *      - optionsData::address: TapiocaOptionsBroker exercise params.\n     *      - lzSendParams::struct: LZ v2 send to source params.\n     *      - composeMsg::bytes: Further compose data.\n     */\n    function exerciseOptionsReceiver(address srcChainSender, bytes memory _data) public payable {\n        // Decode received message.\n        ExerciseOptionsMsg memory msg_ = TOFTMsgCodec.decodeExerciseOptionsMsg(_data);\n\n        _checkWhitelistStatus(msg_.optionsData.target);\n        _checkWhitelistStatus(OFTMsgCodec.bytes32ToAddress(msg_.lzSendParams.sendParam.to));\n\n        {\n            // _data declared for visibility.\n            IExerciseOptionsData memory _options = msg_.optionsData;\n            _options.tapAmount = _toLD(_options.tapAmount.toUint64());\n            _options.paymentTokenAmount = _toLD(_options.paymentTokenAmount.toUint64());\n\n            // @dev retrieve paymentToken amount\n            _internalTransferWithAllowance(_options.from, srcChainSender, _options.paymentTokenAmount);\n\n            /// Does this: _approve(address(this), _options.target, _options.paymentTokenAmount);\n            pearlmit.approve(\n                address(this), 0, _options.target, uint200(_options.paymentTokenAmount), uint48(block.timestamp + 1)\n            ); // Atomic approval\n            address(this).safeApprove(address(pearlmit), _options.paymentTokenAmount);\n\n            /// @dev call exerciseOption() with address(this) as the payment token\n            uint256 bBefore = balanceOf(address(this));\n            ITapiocaOptionBroker(_options.target).exerciseOption(\n                _options.oTAPTokenID,\n                address(this), //payment token\n                _options.tapAmount\n            );\n            address(this).safeApprove(address(pearlmit), 0); // Clear approval\n            uint256 bAfter = balanceOf(address(this));\n\n            // Refund if less was used.\n            if (bBefore > bAfter) {\n                uint256 diff = bBefore - bAfter;\n                if (diff < _options.paymentTokenAmount) {\n                    IERC20(address(this)).safeTransfer(_options.from, _options.paymentTokenAmount - diff);\n                }\n            }\n        }\n\n        {\n            // _data declared for visibility.\n            IExerciseOptionsData memory _options = msg_.optionsData;\n            SendParam memory _send = msg_.lzSendParams.sendParam;\n\n            address tapOft = ITapiocaOptionBroker(_options.target).tapOFT();\n            if (msg_.withdrawOnOtherChain) {\n                /// @dev determine the right amount to send back to source\n                uint256 amountToSend = _send.amountLD > _options.tapAmount ? _options.tapAmount : _send.amountLD;\n                if (_send.minAmountLD > amountToSend) {\n                    _send.minAmountLD = amountToSend;\n                }\n\n                // Sends to source and preserve source `msg.sender` (`from` in this case).\n                _sendPacket(msg_.lzSendParams, msg_.composeMsg, _options.from);\n\n                // Refund extra amounts\n                if (_options.tapAmount - amountToSend > 0) {\n                    IERC20(tapOft).safeTransfer(_options.from, _options.tapAmount - amountToSend);\n                }\n            } else {\n                //send on this chain\n                IERC20(tapOft).safeTransfer(_options.from, _options.tapAmount);\n            }\n        }\n    }\n\n    function _checkWhitelistStatus(address _addr) private view {\n        if (_addr != address(0)) {\n            if (!cluster.isWhitelisted(0, _addr)) {\n                revert TOFTOptionsReceiverModule_NotAuthorized(_addr);\n            }\n        }\n    }\n\n    function _sendPacket(LZSendParam memory _lzSendParam, bytes memory _composeMsg, address _srcChainSender)\n        private\n        returns (MessagingReceipt memory msgReceipt, OFTReceipt memory oftReceipt)\n    {\n        /// @dev Applies the token transfers regarding this send() operation.\n        // - amountDebitedLD is the amount in local decimals that was ACTUALLY debited from the sender.\n        // - amountToCreditLD is the amount in local decimals that will be credited to the recipient on the remote OFT instance.\n        (uint256 amountDebitedLD, uint256 amountToCreditLD) =\n            _debit(_lzSendParam.sendParam.amountLD, _lzSendParam.sendParam.minAmountLD, _lzSendParam.sendParam.dstEid);\n\n        /// @dev Builds the options and OFT message to quote in the endpoint.\n        (bytes memory message, bytes memory options) = _buildOFTMsgAndOptionsMemory(\n            _lzSendParam.sendParam, _lzSendParam.extraOptions, _composeMsg, amountToCreditLD, _srcChainSender\n        );\n\n        /// @dev Sends the message to the LayerZero endpoint and returns the LayerZero msg receipt.\n        msgReceipt =\n            _lzSend(_lzSendParam.sendParam.dstEid, message, options, _lzSendParam.fee, _lzSendParam.refundAddress);\n        /// @dev Formulate the OFT receipt.\n        oftReceipt = OFTReceipt(amountDebitedLD, amountToCr"
    }
  ]
}