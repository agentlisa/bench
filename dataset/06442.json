{
  "Title": "[H-13] Re-adding a deprecated gauge in a new epoch before calling `updatePeriod()`/`queueRewardsForCycle()` will leave some gauges without rewards",
  "Content": "\n### Lines of code\n\n<https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/erc-20/ERC20Gauges.sol#L174-L181> <br><https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/erc-20/ERC20Gauges.sol#L407-L422> <br><https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/rewards/rewards/FlywheelGaugeRewards.sol#L72-L104>\n\n### Impact\n\nOne or more gauges will remain without rewards. A malicious user can DOS a selected gauge from receiving rewards.\n\n### Proof of Concept\n\nWhen a gauge is deprecated, its weight is subtracted from `totalWeight`; however, the weight of the gauge itself could remain different from 0 (it's up to the users to remove their votes). That's reflected in `_addGauge()`.\n\n```solidity\nfunction _addGauge(address gauge) internal returns (uint112 weight) {\n        // some code ... \n\n        // Check if some previous weight exists and re-add to the total. Gauge and user weights are preserved.\n        weight = _getGaugeWeight[gauge].currentWeight;\n        if (weight > 0) {\n            _writeGaugeWeight(_totalWeight, _add112, weight, currentCycle);\n        }\n\n        emit AddGauge(gauge);\n    }\n```\n\nWhen `addGauge(...)` is invoked to re-add a gauge that was previously deprecated and still contains votes, `_writeGaugeWeight(...)` is called to add the gauge's weight to `totalWeight`. When the write operation to `totalWeight` is performed during a new cycle, but before `updatePeriod` or `queueRewardsForCycle()` are called, we will have:\n- `totalWeight.storedWeight = currentWeight` (the weight before the update),\n- `totalWeight.currentWeight = newWeight` (the new weight) and\n- `totalWeight.currentCycle = cycle` (the updated new cycle).\n\nThe problem is, that when now `queueRewardsForCycle()` is called and subsequently in the call chain `calculateGaugeAllocation(...)` is called (which in turn will request the `totalWeight` through `_getStoredWeight(_totalWeight, currentCycle)`), we will read the old `totalWeight` (i.e. `totalWeight.storedWeight`) because `totalWeight.currentCycle < currentCycle` is false, as the cycle was already updated during the `addGauge(...)` call.\n\n```solidity\nfunction _getStoredWeight(Weight storage gaugeWeight, uint32 currentCycle) internal view returns (uint112) {\n        return gaugeWeight.currentCycle < currentCycle ? gaugeWeight.currentWeight : gaugeWeight.storedWeight;\n    }\n```\n\nThis will now cause a wrong calculation of the rewards since we have 1 extra gauge, but the value of `totalWeight` is less than what it is in reality. Therefore, the sum of the rewards among the gauges for the cycle will be more than the total sum allocated by the minter. In other words, the function in the code snippet below will be called for every gauge, including the re-added, but `total` is less than what it has to be.\n\n```solidity\nfunction calculateGaugeAllocation(address gauge, uint256 quantity) external view returns (uint256) {\n        if (_deprecatedGauges.contains(gauge)) return 0;\n        uint32 currentCycle = _getGaugeCycleEnd();\n\n        uint112 total = _getStoredWeight(_totalWeight, currentCycle);\n        uint112 weight = _getStoredWeight(_getGaugeWeight[gauge], currentCycle);\n        return (quantity * weight) / total;\n    }\n```\n\nThis can now cause several areas of concern. \n\nFirst, in the presented scenario where a gauge is re-added with weight > 0 before`queueRewardsForCycle(...)`, the last gauge (or perhaps the last few gauges, depending on the distribution of weight) among the active gauges that calls `getAccruedRewards()` won't receive awards since there will be less rewards than what's recorded in the gauge state.\n\nSecond, in a scenario where we might have several gauges is with a \"whale\" gauge that holds a majority of votes and therefore, will have a large amount of rewards. A malicious actor can monitor for when a gauge is re-added and front run `getAccruedRewards()` (potentially through `newEpoch()` in `BaseV2Gauge`) for all gauges, except the \"whale\" and achieving a DOS where the \"whale\" gauge won't receive the rewards for the epoch. Therefore, the reputation of it will be damaged. This can be done for any gauge, but will have a more significant impact in the case where a lot of voters are denied their awards.\n\n### Coded PoC\n\n**Scenario 1**\n\nInitially, there are 2 gauges with 75%/25% split of the votes. The gauge with 25% of the votes is removed for 1 cycle and then re-added during a new cycle but before queuing of the rewards. The 25% gauge withdraws its rewards and the 75% gauge is bricked and can't withdraw rewards.\n\nCopy the functions `testInitialGauge` & `testDeprecatedAddedGauge` and `helper_gauge_state` in `/test/rewards/rewards/FlywheelGaugeRewardsTest.t.sol`.\n\nAdd `import \"lib/forge-std/src/console.sol\";` to the imports.\n\nExecute with `forge test --match-test testDeprecatedAddedGauge -vv`.\n\nResult: gauge 2 will revert after trying to collect rewards after the 3rd cycle, since gauge 1 was re-added before queuing rewards.\n\n```solidity\nfunction testInitialGauge() public {\n        uint256 amount_rewards;\n        \n        // rewards is 100e18\n\n        // add 2 gauges, 25%/75% split\n        gaugeToken.addGauge(gauge1);\n        gaugeToken.addGauge(gauge2);\n        gaugeToken.incrementGauge(gauge1, 1e18);\n        gaugeToken.incrementGauge(gauge2, 3e18);\n        \n        console.log(\"--------------Initial gauge state--------------\");\n        helper_gauge_state();\n\n        // do one normal cycle of rewards\n        hevm.warp(block.timestamp + 1000);\n        amount_rewards = rewards.queueRewardsForCycle();\n        \n        console.log(\"--------------After 1st queueRewardsForCycle state--------------\");\n        console.log('nextCycleQueuedRewards', amount_rewards);\n        helper_gauge_state();\n        \n        // collect awards\n        hevm.prank(gauge1);\n        rewards.getAccruedRewards();\n        hevm.prank(gauge2);\n        rewards.getAccruedRewards();\n\n        console.log(\"--------------After getAccruedRewards state--------------\");\n        helper_gauge_state();\n    }\n\n    function testDeprecatedAddedGauge() public {\n        uint256 amount_rewards;\n        // setup + 1 normal cycle\n        testInitialGauge();\n        // remove gauge\n        gaugeToken.removeGauge(gauge1);\n\n        // do one more normal cycle with only 1 gauge\n        hevm.warp(block.timestamp + 1000);\n        amount_rewards = rewards.queueRewardsForCycle();\n        console.log(\"--------------After 2nd queueRewardsForCycle state--------------\");\n        console.log('nextCycleQueuedRewards', amount_rewards);\n        // examine state\n        helper_gauge_state();\n\n        hevm.prank(gauge2);\n        rewards.getAccruedRewards();\n        console.log(\"--------------After getAccruedRewards state--------------\");\n        // examine state\n        helper_gauge_state();\n\n        // A new epoch can start for 1 more cycle\n        hevm.warp(block.timestamp + 1000);\n        \n        // Add the gauge back, but before rewards are queued\n        gaugeToken.addGauge(gauge1);\n        amount_rewards = rewards.queueRewardsForCycle();\n\n        console.log(\"--------------After 3rd queueRewardsForCycle state--------------\");\n        // examine state\n        console.log('nextCycleQueuedRewards', amount_rewards);\n        helper_gauge_state();\n\n        // this is fine\n        hevm.prank(gauge1);\n        rewards.getAccruedRewards();\n\n        // this reverts\n        hevm.prank(gauge2);\n        rewards.getAccruedRewards();\n\n        console.log(\"--------------After getAccruedRewards state--------------\");\n        // examine state\n        helper_gauge_state();\n\n    }\nfunction helper_gauge_state() public view {\n        console.log('FlywheelRewards balance', rewardToken.balanceOf(address(rewards)));\n        console.log('gaugeCycle', rewards.gaugeCycle());\n        address[] memory gs = gaugeToken.gauges();\n        for(uint i=0; i<gs.length; i++) {\n            console.log('-------------');\n            (uint112 prior1, uint112 stored1, uint32 cycle1) = rewards.gaugeQueuedRewards(ERC20(gs[i]));\n            console.log(\"Gauge \",i+1);\n            console.log(\"priorRewards\",prior1);\n            console.log(\"cycleRewards\",stored1); \n            console.log(\"storedCycle\",cycle1);\n        }\n        console.log('-------------');\n    }\n```\n\n**Scenario 2**\n\nInitially, there are 4 gauges with (2e18 | 2e18 | 6e18 | 4e18) votes respectively. The gauge with 4e18 votes is removed for 1 cycle and then re-added during a new cycle but before queuing of the rewards. The 6e18 gauge withdraws its rewards and the 4e18 gauge withdraws its rewards. The two gauges with 2e18 votes are bricked and can't withdraw rewards.\n\nCopy the functions `testInitialGauge2`, `testDeprecatedAddedGauge2` and `helper_gauge_state` in `/test/rewards/rewards/FlywheelGaugeRewardsTest.t.sol`.\n\nExecute with `forge test --match-test testDeprecatedAddedGauge2 -vv`.\n\nResult: the 2 gauges with 2e18 votes will revert after trying to collect rewards.\n\n```solidity\nfunction testInitialGauge2() public {\n        uint256 amount_rewards;\n        \n        // rewards is 100e18\n        \n        // add 4 gauges, 2x/2x/6x/4x split\n        gaugeToken.addGauge(gauge1);\n        gaugeToken.addGauge(gauge2);\n        gaugeToken.addGauge(gauge3);\n        gaugeToken.addGauge(gauge4);\n\n        gaugeToken.incrementGauge(gauge1, 2e18);\n        gaugeToken.incrementGauge(gauge2, 2e18);\n        gaugeToken.incrementGauge(gauge3, 6e18);\n        gaugeToken.incrementGauge(gauge4, 4e18);\n\n        \n        console.log(\"--------------Initial gauge state--------------\");\n        helper_gauge_state();\n\n        // do one normal cycle of rewards\n        hevm.warp(block.timestamp + 1000);\n        amount_rewards = rewards.queueRewardsForCycle();\n        \n        console.log(\"--------------After 1st queueRewardsForCycle state--------------\");\n        console.log('nextCycleQueuedRewards', amount_rewards);\n        helper_gauge_state();\n        \n        // collect awards\n        hevm.prank(gauge1);\n        rewards.getAccruedRewards();\n        hevm.prank(gauge2);\n        rewards.getAccruedRewards();\n        hevm.prank(gauge3);\n        rewards.getAccruedRewards();\n        hevm.prank(gauge4);\n        rewards.getAccruedRewards();\n\n        console.log(\"--------------After getAccruedRewards state--------------\");\n        helper_gauge_state();\n    }\n    function testDeprecatedAddedGauge2() public {\n        uint256 amount_rewards;\n        // setup + 1 normal cycle\n        testInitialGauge2();\n        // remove gauge\n        gaugeToken.removeGauge(gauge4);\n\n        // do one more normal cycle with only 3 gauges\n        hevm.warp(block.timestamp + 1000);\n        amount_rewards = rewards.queueRewardsForCycle();\n        console.log(\"--------------After 2nd queueRewardsForCycle state--------------\");\n        console.log('nextCycleQueuedRewards', amount_rewards);\n        // examine state\n        helper_gauge_state();\n\n        hevm.prank(gauge1);\n        rewards.getAccruedRewards();\n        hevm.prank(gauge2);\n        rewards.getAccruedRewards();\n        hevm.prank(gauge3);\n        rewards.getAccruedRewards();\n        console.log(\"--------------After getAccruedRewards state--------------\");\n        // examine state\n        helper_gauge_state();\n\n        // A new epoch can start for 1 more cycle\n        hevm.warp(block.timestamp + 1000);\n        \n        // Add the gauge back, but before rewards are queued\n        gaugeToken.addGauge(gauge4);\n        amount_rewards = rewards.queueRewardsForCycle();\n\n        console.log(\"--------------After 3rd queueRewardsForCycle state--------------\");\n        console.log('nextCycleQueuedRewards', amount_rewards);\n        // examine state\n        helper_gauge_state();\n\n        // this is fine\n        hevm.prank(gauge3);\n        rewards.getAccruedRewards();\n        \n        // this is fine\n        hevm.prank(gauge4);\n        rewards.getAccruedRewards();\n\n        // this reverts\n        hevm.prank(gauge1);\n        rewards.getAccruedRewards();\n        \n        // this reverts, same weight as gauge 1\n        hevm.prank(gauge2);\n        rewards.getAccruedRewards();\n\n        console.log(\"--------------After getAccruedRewards state--------------\");\n        // examine state\n        helper_gauge_state();\n\n    }\nfunction helper_gauge_state() public view {\n        console.log('FlywheelRewards balance', rewardToken.balanceOf(address(rewards)));\n        console.log('gaugeCycle', rewards.gaugeCycle());\n        address[] memory gs = gaugeToken.gauges();\n        for(uint i=0; i<gs.length; i++) {\n            console.log('-------------');\n            (uint112 prior1, uint112 stored1, uint32 cycle1) = rewards.gaugeQueuedRewards(ERC20(gs[i]));\n            console.log(\"Gauge \",i+1);\n            console.log(\"priorRewards\",prior1);\n            console.log(\"cycleRewards\",stored1); \n            console.log(\"storedCycle\",cycle1);\n        }\n        console.log('-------------');\n    }\n```\n\n### Recommendation\n\nWhen a new cycle starts, make sure gauges are re-added after rewards are queued in a cycle.\n\n### Assessed type\n\nTiming\n\n**[0xLightt (Maia) confirmed](https://github.com/code-423n4/2023-05-maia-findings/issues/639#issuecomment-1632915459)**\n\n**[0xLightt (Maia) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/639#issuecomment-1708825650):**\n> Addressed [here](https://github.com/Maia-DAO/eco-c4-contest/tree/639).\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/erc-20/ERC20Gauges.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Gauge weight logic inspired by Tribe DAO Contracts (flywheel-v2/src/token/ERC20Gauges.sol)\npragma solidity ^0.8.0;\n\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\n\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\n\nimport {EnumerableSet} from \"@lib/EnumerableSet.sol\";\n\nimport {IBaseV2Gauge} from \"@gauges/interfaces/IBaseV2Gauge.sol\";\n\nimport {ERC20MultiVotes} from \"./ERC20MultiVotes.sol\";\n\nimport {Errors} from \"./interfaces/Errors.sol\";\nimport {IERC20Gauges} from \"./interfaces/IERC20Gauges.sol\";\n\n/// @title  An ERC20 with an embedded \"Gauge\" style vote with liquid weights\nabstract contract ERC20Gauges is ERC20MultiVotes, ReentrancyGuard, IERC20Gauges {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using SafeCastLib for *;\n\n    /**\n     * @notice Construct a new ERC20Gauges\n     * @param _gaugeCycleLength the length of a gauge cycle in seconds\n     * @param _incrementFreezeWindow the length of the grace period in seconds\n     */\n    constructor(uint32 _gaugeCycleLength, uint32 _incrementFreezeWindow) {\n        if (_incrementFreezeWindow >= _gaugeCycleLength) revert IncrementFreezeError();\n        gaugeCycleLength = _gaugeCycleLength;\n        incrementFreezeWindow = _incrementFreezeWindow;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            GAUGE STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Gauges\n    uint32 public immutable override gaugeCycleLength;\n\n    /// @inheritdoc IERC20Gauges\n    uint32 public immutable override incrementFreezeWindow;\n\n    /// @inheritdoc IERC20Gauges\n    mapping(address => mapping(address => uint112)) public override getUserGaugeWeight;\n\n    /// @inheritdoc IERC20Gauges\n    /// @dev NOTE this may contain weights for deprecated gauges\n    mapping(address => uint112) public override getUserWeight;\n\n    /// @notice a mapping from a gauge to the total weight allocated to it\n    /// @dev NOTE this may contain weights for deprecated gauges\n    mapping(address => Weight) internal _getGaugeWeight;\n\n    /// @notice the total global allocated weight ONLY of live gauges\n    Weight internal _totalWeight;\n\n    mapping(address => EnumerableSet.AddressSet) internal _userGauges;\n\n    EnumerableSet.AddressSet internal _gauges;\n\n    // Store deprecated gauges in case a user needs to free dead weight\n    EnumerableSet.AddressSet internal _deprecatedGauges;\n\n    /*///////////////////////////////////////////////////////////////\n                              VIEW HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Gauges\n    function getGaugeCycleEnd() external view returns (uint32) {\n        return _getGaugeCycleEnd();\n    }\n\n    function _getGaugeCycleEnd() internal view returns (uint32) {\n        uint32 nowPlusOneCycle = block.timestamp.toUint32() + gaugeCycleLength;\n        unchecked {\n            return (nowPlusOneCycle / gaugeCycleLength) * gaugeCycleLength; // cannot divide by zero and always <= nowPlusOneCycle so no overflow\n        }\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function getGaugeWeight(address gauge) external view returns (uint112) {\n        return _getGaugeWeight[gauge].currentWeight;\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function getStoredGaugeWeight(address gauge) external view returns (uint112) {\n        if (_deprecatedGauges.contains(gauge)) return 0;\n        return _getStoredWeight(_getGaugeWeight[gauge], _getGaugeCycleEnd());\n    }\n\n    function _getStoredWeight(Weight storage gaugeWeight, uint32 currentCycle) internal view returns (uint112) {\n        return gaugeWeight.currentCycle < currentCycle ? gaugeWeight.currentWeight : gaugeWeight.storedWeight;\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function totalWeight() external view returns (uint112) {\n        return _totalWeight.currentWeight;\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function storedTotalWeight() external view returns (uint112) {\n        return _getStoredWeight(_totalWeight, _getGaugeCycleEnd());\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function gauges() external view returns (address[] memory) {\n        return _gauges.values();\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function gauges(uint256 offset, uint256 num) external view returns (address[] memory values) {\n        values = new address[](num);\n        for (uint256 i = 0; i < num;) {\n            unchecked {\n                values[i] = _gauges.at(offset + i); // will revert if out of bounds\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function isGauge(address gauge) external view returns (bool) {\n        return _gauges.contains(gauge) && !_deprecatedGauges.contains(gauge);\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function numGauges() external view returns (uint256) {\n        return _gauges.length();\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function deprecatedGauges() external view returns (address[] memory) {\n        return _deprecatedGauges.values();\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function numDeprecatedGauges() external view returns (uint256) {\n        return _deprecatedGauges.length();\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function userGauges(address user) external view returns (address[] memory) {\n        return _userGauges[user].values();\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function isUserGauge(address user, address gauge) external view returns (bool) {\n        return _userGauges[user].contains(gauge);\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function userGauges(address user, uint256 offset, uint256 num) external view returns (address[] memory values) {\n        values = new address[](num);\n        for (uint256 i = 0; i < num;) {\n            unchecked {\n                values[i] = _userGauges[user].at(offset + i); // will revert if out of bounds\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function numUserGauges(address user) external view returns (uint256) {\n        return _userGauges[user].length();\n    }\n\n    /// @inheritdoc ERC20MultiVotes\n    function userUnusedVotes(address user) public view override returns (uint256) {\n        return super.userUnusedVotes(user) - getUserWeight[user];\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function calculateGaugeAllocation(address gauge, uint256 quantity) external view returns (uint256) {\n        if (_deprecatedGauges.contains(gauge)) return 0;\n        uint32 currentCycle = _getGaugeCycleEnd();\n\n        uint112 total = _getStoredWeight(_totalWeight, currentCycle);\n        uint112 weight = _getStoredWeight(_getGaugeWeight[gauge], currentCycle);\n        return (quantity * weight) / total;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        USER GAUGE OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Gauges\n    function incrementGauge(address gauge, uint112 weight) external nonReentrant returns (uint112 newUserWeight) {\n        uint32 currentCycle = _getGaugeCycleEnd();\n        _incrementGaugeWeight(msg.sender, gauge, weight, currentCycle);\n        return _incrementUserAndGlobalWeights(msg.sender, weight, currentCycle);\n    }\n\n    /**\n     * @notice Increment the weight of a gauge for a user\n     * @dev This function calls accrueBribes for the gauge to ensure the gauge handles the balance change.\n     * @param user the user to increment the weight of\n     * @param gauge the gauge to increment the weight of\n     * @param weight the weight to increment by\n     * @param cycle the cycle to increment the weight for\n     */\n    function _incrementGaugeWeight(address user, address gauge, uint112 weight, uint32 cycle) internal {\n        if (!_gauges.contains(gauge) || _deprecatedGauges.contains(gauge)) revert InvalidGaugeError();\n        unchecked {\n            if (cycle - block.timestamp <= incrementFreezeWindow) revert IncrementFreezeError();\n        }\n\n        IBaseV2Gauge(gauge).accrueBribes(user);\n\n        bool added = _userGauges[user].add(gauge); // idempotent add\n        if (added && _userGauges[user].length() > maxGauges && !canContractExceedMaxGauges[user]) {\n            revert MaxGaugeError();\n        }\n\n        getUserGaugeWeight[user][gauge] += weight;\n\n        _writeGaugeWeight(_getGaugeWeight[gauge], _add112, weight, cycle);\n\n        emit IncrementGaugeWeight(user, gauge, weight, cycle);\n    }\n\n    /**\n     * @notice Increment the weight of a gauge for a user and the total weight\n     * @param user the user to increment the weight of\n     * @param weight the weight to increment by\n     * @param cycle the cycle to increment the weight for\n     * @return newUserWeight the new user's weight\n     */\n    function _incrementUserAndGlobalWeights(address user, uint112 weight, uint32 cycle)\n        internal\n        returns (uint112 newUserWeight)\n    {\n        newUserWeight = getUserWeight[user] + weight;\n\n        // new user weight must be less than or equal to the total user weight\n        if (newUserWeight > getVotes(user)) revert OverWeightError();\n\n        // Update gauge state\n        getUserWeight[user] = newUserWeight;\n\n        _writeGaugeWeight(_totalWeight, _add112, weight, cycle);\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function incrementGauges(address[] calldata gaugeList, uint112[] calldata weights)\n        external\n        nonReentrant\n        returns (uint256 newUserWeight)\n    {\n        uint256 size = gaugeList.length;\n        if (weights.length != size) revert SizeMismatchError();\n\n        // store total in summary for a batch update on user/global state\n        uint112 weightsSum;\n\n        uint32 currentCycle = _getGaugeCycleEnd();\n\n        // Update a gauge's specific state\n        for (uint256 i = 0; i < size;) {\n            address gauge = gaugeList[i];\n            uint112 weight = weights[i];\n            weightsSum += weight;\n\n            _incrementGaugeWeight(msg.sender, gauge, weight, currentCycle);\n            unchecked {\n                i++;\n            }\n        }\n        return _incrementUserAndGlobalWeights(msg.sender, weightsSum, currentCycle);\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function decrementGauge(address gauge, uint112 weight) external nonReentrant returns (uint112 newUserWeight) {\n        uint32 currentCycle = _getGaugeCycleEnd();\n\n        // All operations will revert on underflow, protecting against bad inputs\n        _decrementGaugeWeight(msg.sender, gauge, weight, currentCycle);\n        if (!_deprecatedGauges.contains(gauge)) {\n            _writeGaugeWeight(_totalWeight, _subtract112, weight, currentCycle);\n        }\n        return _decrementUserWeights(msg.sender, weight);\n    }\n\n    /**\n     * @notice Decrement the weight of a gauge for a user\n     * @dev This function calls accrueBribes for the gauge to ensure the gauge handles the balance change.\n     * @param user the user to decrement the weight of\n     * @param gauge the gauge to decrement the weight of\n     * @param weight the weight to decrement by\n     * @param cycle the cycle to decrement the weight for\n     */\n    function _decrementGaugeWeight(address user, address gauge, uint112 weight, uint32 cycle) internal {\n        if (!_gauges.contains(gauge)) revert InvalidGaugeError();\n\n        uint112 oldWeight = getUserGaugeWeight[user][gauge];\n\n        IBaseV2Gauge(gauge).accrueBribes(user);\n\n        getUserGaugeWeight[user][gauge] = oldWeight - weight;\n        if (oldWeight == weight) {\n            // If removing all weight, remove gauge from user list.\n            require(_userGauges[user].remove(gauge));\n        }\n\n        _writeGaugeWeight(_getGaugeWeight[gauge], _subtract112, weight, cycle);\n\n        emit DecrementGaugeWeight(user, gauge, weight, cycle);\n    }\n\n    /**\n     * @notice Decrement the weight of a gauge for a user and the total weight\n     * @param user the user to decrement the weight of\n     * @param weight the weight to decrement by\n     * @return newUserWeight the new user's weight\n     */\n    function _decrementUserWeights(address user, uint112 weight) internal returns (uint112 newUserWeight) {\n        newUserWeight = getUserWeight[user] - weight;\n        getUserWeight[user] = newUserWeight;\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function decrementGauges(address[] calldata gaugeList, uint112[] calldata weights)\n        external\n        nonReentrant\n        returns (uint112 newUserWeight)\n    {\n        uint256 size = gaugeList.length;\n        if (weights.length != size) revert SizeMismatchError();\n\n        // store total in summary for the batch update on user and global state\n        uint112 weightsSum;\n        uint112 globalWeightsSum;\n\n        uint32 currentCycle = _getGaugeCycleEnd();\n\n        // Update the gauge's specific state\n        // All operations will revert on underflow, protecting against bad inputs\n        for (uint256 i = 0; i < size;) {\n            address gauge = gaugeList[i];\n            uint112 weight = weights[i];\n            weightsSum += weight;\n            if (!_deprecatedGauges.contains(gauge)) globalWeightsSum += weight;\n\n            _decrementGaugeWeight(msg.sender, gauge, weight, currentCycle);\n            unchecked {\n                i++;\n            }\n        }\n        _writeGaugeWeight(_totalWeight, _subtract112, globalWeightsSum, currentCycle);\n\n        return _decrementUserWeights(msg.sender, weightsSum);\n    }\n\n    /**\n     * @dev this function is the key to the entire contract.\n     *  The storage weight it operates on is either a global or gauge-specific weight.\n     *  The operation applied is either addition for incrementing gauges or subtraction for decrementing a gauge.\n     * @param weight the weight to apply the operation to\n     * @param op the operation to apply\n     * @param delta the amount to apply the operation by\n     * @param cycle the cycle to apply the operation for\n     */\n    function _writeGaugeWeight(\n        Weight storage weight,\n        function(uint112, uint112) view returns (uint112) op,\n        uint112 delta,\n        uint32 cycle\n    ) private {\n        uint112 currentWeight = weight.currentWeight;\n        // If the last cycle of the weight is before the current cycle, use the current weight as the stored.\n        uint112 stored = weight.currentCycle < cycle ? currentWeight : weight.storedWeight;\n        uint112 newWeight = op(currentWeight, delta);\n\n        weight.storedWeight = stored;\n        weight.currentWeight = newWeight;\n        weight.currentCycle = cycle;\n    }\n\n    function _add112(uint112 a, uint112 b) private pure returns (uint112) {\n        return a + b;\n    }\n\n    function _subtract112(uint112 a, uint112 b) private pure returns (uint112) {\n        return a - b;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        ADMIN GAUGE OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Gauges\n    uint256 public override maxGauges;\n\n    /// @inheritdoc IERC20Gauges\n    mapping(address => bool) public override canContractExceedMaxGauges;\n\n    /// @inheritdoc IERC20Gauges\n    function addGauge(address gauge) external onlyOwner returns (uint112) {\n        return _addGauge(gauge);\n    }\n\n    /**\n     * @notice Add a gauge to the contract\n     * @param gauge the gauge to add\n     * @return weight the previous weight of the gauge, if it was already added\n     */\n    function _addGauge(address gauge) internal returns (uint112 weight) {\n        bool newAdd = _gauges.add(gauge);\n        bool previouslyDeprecated = _deprecatedGauges.remove(gauge);\n        // add and fail loud if zero address or already present and not deprecated\n        if (gauge == address(0) || !(newAdd || previouslyDeprecated)) revert InvalidGaugeError();\n\n        uint32 currentCycle = _getGaugeCycleEnd();\n\n        // Check if some previous weight exists and re-add to the total. Gauge and user weights are preserved.\n        weight = _getGaugeWeight[gauge].currentWeight;\n        if (weight > 0) {\n            _writeGaugeWeight(_totalWeight, _add112, weight, currentCycle);\n        }\n\n        emit AddGauge(gauge);\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function removeGauge(address gauge) external onlyOwner {\n        _removeGauge(gauge);\n    }\n\n    /**\n     * @notice Remove a gauge from the contract\n     * @param gauge the gauge to remove\n     */\n    function _removeGauge(address gauge) internal {\n        // add to deprecated and fail loud if not present\n        if (!_deprecatedGauges.add(gauge)) revert InvalidGaugeError();\n\n        uint32 currentCycle = _getGaugeCycleEnd();\n\n        // Remove weight from total but keep the gauge and user weights in storage in case the gauge is re-added.\n        uint112 weight = _getGaugeWeight[gauge].currentWeight;\n        if (weight > 0) {\n            _writeGaugeWeight(_totalWeight, _subtract112, weight, currentCycle);\n        }\n\n        emit RemoveGauge(gauge);\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function replaceGauge(address oldGauge, address newGauge) external onlyOwner {\n        _removeGauge(oldGauge);\n        _addGauge(newGauge);\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function setMaxGauges(uint256 newMax) external onlyOwner {\n        uint256 oldMax = maxGauges;\n        maxGauges = newMax;\n\n        emit MaxGaugesUpdate(oldMax, newMax);\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function setContractExceedMaxGauges(address account, bool canExceedMax) external onlyOwner {\n        if (canExceedMax && account.code.length == 0) revert Errors.NonContractError(); // can only approve contracts\n\n        canContractExceedMaxGauges[account] = canExceedMax;\n\n        emit CanContractExceedMaxGaugesUpdate(account, canExceedMax);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// NOTE: any \"removal\" of tokens from a user requires userUnusedVotes < amount.\n    /// _decrementWeightUntilFree is called as a greedy algorithm to free up weight.\n    /// It may be more gas efficient to free weight before burning or transferring tokens.\n\n    /**\n     * @notice Burns `amount` of tokens from `from` address.\n     * @dev Frees weights and votes with a greedy algorithm if needed to burn tokens\n     * @param from The address to burn tokens from.\n     * @param amount The amount of tokens to burn.\n     */\n    function _burn(address from, uint256 amount) internal virtual override {\n        _decrementWeightUntilFree(from, amount);\n        super._burn(from, amount);\n    }\n\n    /**\n     * @notice Transfers `amount` of tokens from `msg.sender` to `to` address.\n     * @dev Frees weights and votes with a greedy algorithm if needed to burn tokens\n     * @param to the address to transfer to.\n     * @param amount the amount to transfer.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        _decrementWeightUntilFree(msg.sender, amount);\n        return super.transfer(to, amount);\n    }\n\n    /**\n     * @notice Transfers `amount` of tokens from `from` address to `to` address.\n     * @dev Frees weights and votes with a greedy algorithm if needed to burn tokens\n     * @param from the address to transfer from.\n     * @param to the address to transfer to.\n     * @param amount the amount to transfer.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        _decrementWeightUntilFree(from, amount);\n        return super.transferFrom(from, to, amount);\n    }\n\n    /**\n     * @notice A greedy algorithm for freeing weight before a token burn/transfer\n     * @dev Frees up entire gauges, so likely will free more than `weight`\n     * @param user the user to free weight for\n     * @param weight the weight to free\n     */\n    function _decrementWeightUntilFree(address user, uint256 weight) internal nonReentrant {\n        uint256 userFreeWeight = freeVotes(user) + userUnusedVotes(user);\n\n        // early return if already free\n        if (userFreeWeight >= weight) return;\n\n        uint32 currentCycle = _getGaugeCycleEnd();\n\n        // cache totals for batch updates\n        uint112 userFreed;\n        uint112 totalFreed;\n\n        // Loop through all user gauges, live and deprecated\n        address[] memory gaugeList = _userGauges[user].values();\n\n        // Free gauges through the entire list or until underweight\n        uint256 size = gaugeList.length;\n        for (uint256 i = 0; i < size && (userFreeWeight + totalFreed) < weight;) {\n            address gauge = gaugeList[i];\n            uint112 userGaugeWeight = getUserGaugeWeight[user][gauge];\n            if (userGaugeWeight != 0) {\n                // If the gauge is live (not deprecated), include its weight in the total to remove\n                if (!_deprecatedGauges.contains(gauge)) {\n                    totalFreed += userGaugeWeight;\n                }\n                userFreed += userGaugeWeight;\n                _decrementGaugeWeight(user, gauge, userGaugeWeight, currentCycle);\n\n                unchecked {\n                    i++;\n                }\n            }\n        }\n\n        getUserWeight[user] -= userFreed;\n        _writeGaugeWeight(_totalWeight, _subtract112, totalFreed, currentCycle);\n    }\n}"
    }
  ]
}