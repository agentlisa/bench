{
  "Title": "[M-08] Add a timelock to `PaladinRewardReserve` functions",
  "Content": "_Submitted by Jujic, also found by danb_\n\nThe owner of PaladinRewardReserve can approve and transfer any amount of tokens with no limits on any account. This is not good for investors. To give more trust to users: these functions should be put behind a timelock.\n\n### Proof of Concept\n\n[PaladinRewardReserve.sol#L28](https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/PaladinRewardReserve.sol#L28)<br>\n\n[PaladinRewardReserve.sol#L52](https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/PaladinRewardReserve.sol#L52)<br>\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\nAdd a timelock to transfer and spender approved functions.\n\n**[Kogaroshi (Paladin) acknowledged and commented](https://github.com/code-423n4/2022-03-paladin-findings/issues/31#issuecomment-1086661744):**\n > Those 2 smart contracts will be owned by a Multisig, executing decisions based on Governance Votes in the Paladin DAO. In future evolutions of the DAO, it should have a Timelock and an on-chain Governance controlling the smart contract.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-03-paladin",
  "Code": [
    {
      "filename": "contracts/PaladinRewardReserve.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./open-zeppelin/utils/Ownable.sol\";\nimport \"./open-zeppelin/utils/ReentrancyGuard.sol\";\nimport \"./open-zeppelin/interfaces/IERC20.sol\";\nimport \"./open-zeppelin/libraries/SafeERC20.sol\";\n\n/** @title Paladin Reward Reserve contract  */\n/// @author Paladin\ncontract PaladinRewardReserve is Ownable, ReentrancyGuard{\n    using SafeERC20 for IERC20;\n\n    /** @notice Addresses allowed to transfer tokens from this contract */\n    mapping(address => bool) public approvedSpenders;\n\n    /** @notice Emitted when a new spender is approved*/\n    event NewSpender(address indexed token, address indexed spender, uint256 amount);\n    /** @notice Emitted when the allowance of a spander is updated */\n    event UpdateSpender(address indexed token, address indexed spender, uint256 amount);\n    /** @notice Emitted when a spender allowance is removed */\n    event RemovedSpender(address indexed token, address indexed spender);\n\n    constructor(address _admin) {\n        transferOwnership(_admin);\n    }\n\n    function setNewSpender(address token, address spender, uint256 amount) external onlyOwner {\n        require(!approvedSpenders[spender], \"Already Spender\");\n        approvedSpenders[spender] = true;\n        IERC20(token).safeApprove(spender, amount);\n\n        emit NewSpender(token, spender, amount);\n    }\n\n    function updateSpenderAllowance(address token, address spender, uint256 amount) external onlyOwner {\n        require(approvedSpenders[spender], \"Not approved Spender\");\n        IERC20(token).safeApprove(spender, 0);\n        IERC20(token).safeApprove(spender, amount);\n\n        emit UpdateSpender(token, spender, amount);\n    }\n\n    function removeSpender(address token, address spender) external onlyOwner {\n        require(approvedSpenders[spender], \"Not approved Spender\");\n        approvedSpenders[spender] = false;\n        IERC20(token).safeApprove(spender, 0);\n\n        emit RemovedSpender(token, spender);\n    }\n\n    function transferToken(address token, address receiver, uint256 amount) external onlyOwner nonReentrant {\n        IERC20(token).safeTransfer(receiver, amount);\n    }\n\n}"
    },
    {
      "filename": "contracts/PaladinRewardReserve.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./open-zeppelin/utils/Ownable.sol\";\nimport \"./open-zeppelin/utils/ReentrancyGuard.sol\";\nimport \"./open-zeppelin/interfaces/IERC20.sol\";\nimport \"./open-zeppelin/libraries/SafeERC20.sol\";\n\n/** @title Paladin Reward Reserve contract  */\n/// @author Paladin\ncontract PaladinRewardReserve is Ownable, ReentrancyGuard{\n    using SafeERC20 for IERC20;\n\n    /** @notice Addresses allowed to transfer tokens from this contract */\n    mapping(address => bool) public approvedSpenders;\n\n    /** @notice Emitted when a new spender is approved*/\n    event NewSpender(address indexed token, address indexed spender, uint256 amount);\n    /** @notice Emitted when the allowance of a spander is updated */\n    event UpdateSpender(address indexed token, address indexed spender, uint256 amount);\n    /** @notice Emitted when a spender allowance is removed */\n    event RemovedSpender(address indexed token, address indexed spender);\n\n    constructor(address _admin) {\n        transferOwnership(_admin);\n    }\n\n    function setNewSpender(address token, address spender, uint256 amount) external onlyOwner {\n        require(!approvedSpenders[spender], \"Already Spender\");\n        approvedSpenders[spender] = true;\n        IERC20(token).safeApprove(spender, amount);\n\n        emit NewSpender(token, spender, amount);\n    }\n\n    function updateSpenderAllowance(address token, address spender, uint256 amount) external onlyOwner {\n        require(approvedSpenders[spender], \"Not approved Spender\");\n        IERC20(token).safeApprove(spender, 0);\n        IERC20(token).safeApprove(spender, amount);\n\n        emit UpdateSpender(token, spender, amount);\n    }\n\n    function removeSpender(address token, address spender) external onlyOwner {\n        require(approvedSpenders[spender], \"Not approved Spender\");\n        approvedSpenders[spender] = false;\n        IERC20(token).safeApprove(spender, 0);\n\n        emit RemovedSpender(token, spender);\n    }\n\n    function transferToken(address token, address receiver, uint256 amount) external onlyOwner nonReentrant {\n        IERC20(token).safeTransfer(receiver, amount);\n    }\n\n}"
    }
  ]
}