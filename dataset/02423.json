{
  "Title": "M-11: Withdrawals from IchiVaultSpell have no slippage protection so can be frontrun, stealing all user funds",
  "Content": "# Issue M-11: Withdrawals from IchiVaultSpell have no slippage protection so can be frontrun, stealing all user funds \n\nSource: https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/130 \n\n## Found by \nrvierdiiev, obront, koxuan, ctf\\_sec, tives, cergyk, berndartmueller, 0x52\n\n## Summary\n\nWhen a user withdraws their position through the `IchiVaultSpell`, part of the unwinding process is to trade one of the released tokens for the other, so the borrow can be returned. This trade is done on Uniswap V3. The parameters are set in such a way that there is no slippage protection, so any MEV bot could see this transaction, aggressively sandwich attack it, and steal the majority of the user's funds.\n\n## Vulnerability Detail\n\nUsers who have used the `IchiVaultSpell` to take positions in Ichi will eventually choose to withdraw their funds. They can do this by calling `closePosition()` or `closePositionFarm()`, both of which call to `withdrawInternal()`, which follows loosely the following logic:\n- sends the LP tokens back to the Ichi vault for the two underlying tokens (one of which was what was borrowed)\n- swaps the non-borrowed token for the borrowed token on UniV3, to ensure we will be able to pay the loan back\n- withdraw our underlying token from the Compound fork\n- repay the borrow token loan to the Compound fork\n- validate that we are still under the maxLTV for our strategy\n- send the funds (borrow token and underlying token) back to the user\n\nThe issue exists in the swap, where Uniswap is called with the following function:\n```solidity\nif (amountToSwap > 0) {\n    swapPool = IUniswapV3Pool(vault.pool());\n    swapPool.swap(\n        address(this),\n        !isTokenA,\n        int256(amountToSwap),\n        isTokenA\n            ? UniV3WrappedLibMockup.MAX_SQRT_RATIO - 1 \n            : UniV3WrappedLibMockup.MIN_SQRT_RATIO + 1, \n        abi.encode(address(this))\n    );\n}\n```\nThe 4th variable is called `sqrtPriceLimitX96` and it represents the square root of the lowest or highest price that you are willing to perform the trade at. In this case, we've hardcoded in that we are willing to take the worst possible rate (highest price in the event we are trading 1 => 0; lowest price in the event we are trading 0 => 1). \n\nThe `IchiVaultSpell.sol#uniswapV3SwapCallback()` function doesn't enforce any additional checks. It simply sends whatever delta is requested directly to Uniswap.\n```solidity\nfunction uniswapV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n) external override {\n    if (msg.sender != address(swapPool)) revert NOT_FROM_UNIV3(msg.sender);\n    address payer = abi.decode(data, (address));\n\n    if (amount0Delta > 0) {\n        if (payer == address(this)) {\n            IERC20Upgradeable(swapPool.token0()).safeTransfer(\n                msg.sender,\n                uint256(amount0Delta)\n            );\n        } else {\n            IERC20Upgradeable(swapPool.token0()).safeTransferFrom(\n                payer,\n                msg.sender,\n                uint256(amount0Delta)\n            );\n        }\n    } else if (amount1Delta > 0) {\n        if (payer == address(this)) {\n            IERC20Upgradeable(swapPool.token1()).safeTransfer(\n                msg.sender,\n                uint256(amount1Delta)\n            );\n        } else {\n            IERC20Upgradeable(swapPool.token1()).safeTransferFrom(\n                payer,\n                msg.sender,\n                uint256(amount1Delta)\n            );\n        }\n    }\n}\n```\nWhile it is true that there is an `amountRepay` parameter that is inputted by the user, it is not sufficient to protect users. Many users will want to make only a small repayment (or no repayment) while unwinding their position, and thus this variable will only act as slippage protection in the cases where users intend to repay all of their returned funds.\n\nWith this knowledge, a malicious MEV bot could watch for these transactions in the mempool. When it sees such a transaction, it could perform a \"sandwich attack\", trading massively in the same direction as the trade in advance of it to push the price out of whack, and then trading back after us, so that they end up pocketing a profit at our expense.\n\nBecause many of the ICHI token pairs have small amounts of liquidity (for example, ICHI-WBTC has under $350k), such an attack could feasible take the majority of the funds, leaving the user with close to nothing. See more details on liquidity here: https://info.uniswap.org/#/tokens/0x111111517e4929d3dcbdfa7cce55d30d4b6bc4d6\n\n## Impact\n\nUsers withdrawing their funds through the `IchiVaultSpell` who do not plan to repay all of the tokens returned from Uniswap could be sandwich attacked, losing their funds by receiving very little of their borrowed token back from the swap.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/spell/IchiVaultSpell.sol#L300-L317\n\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/spell/IchiVaultSpell.sol#L407-L442\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nHave the user input a slippage parameter to ensure that the amount of borrowed token they receive back from Uniswap is in line with what they expect. \n\nAlternatively, use the existing oracle system to estimate a fair price and use that value in the `swap()` call.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/41",
  "Code": [
    {
      "filename": "contracts/spell/IchiVaultSpell.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport \"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol\";\n\nimport \"./BasicSpell.sol\";\nimport \"../utils/BlueBerryConst.sol\";\nimport \"../libraries/UniV3/UniV3WrappedLibMockup.sol\";\nimport \"../interfaces/IOracle.sol\";\nimport \"../interfaces/IWIchiFarm.sol\";\nimport \"../interfaces/ichi/IICHIVault.sol\";\n\ncontract IchiVaultSpell is BasicSpell, IUniswapV3SwapCallback {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    struct Strategy {\n        address vault;\n        uint256 maxPositionSize;\n    }\n\n    /// @dev temperory state used to store uni v3 pool when swapping on uni v3\n    IUniswapV3Pool private swapPool;\n\n    /// @dev strategyId => ichi vault\n    Strategy[] public strategies;\n    /// @dev strategyId => collateral token => maxLTV\n    mapping(uint256 => mapping(address => uint256)) public maxLTV; // base 1e4\n    /// @dev address of ICHI farm wrapper\n    IWIchiFarm public wIchiFarm;\n    /// @dev address of ICHI token\n    address public ICHI;\n\n    event StrategyAdded(uint256 strategyId, address vault, uint256 maxPosSize);\n    event CollateralsSupportAdded(\n        uint256 strategyId,\n        address[] collaterals,\n        uint256[] maxLTVs\n    );\n\n    modifier existingStrategy(uint256 strategyId) {\n        if (strategyId >= strategies.length)\n            revert STRATEGY_NOT_EXIST(address(this), strategyId);\n\n        _;\n    }\n\n    modifier existingCollateral(uint256 strategyId, address col) {\n        if (maxLTV[strategyId][col] == 0)\n            revert COLLATERAL_NOT_EXIST(strategyId, col);\n\n        _;\n    }\n\n    function initialize(\n        IBank _bank,\n        address _werc20,\n        address _weth,\n        address _wichiFarm\n    ) external initializer {\n        __BasicSpell_init(_bank, _werc20, _weth);\n\n        wIchiFarm = IWIchiFarm(_wichiFarm);\n        ICHI = address(wIchiFarm.ICHI());\n        IWIchiFarm(_wichiFarm).setApprovalForAll(address(_bank), true);\n    }\n\n    /**\n     * @notice Owner privileged function to add vault\n     * @param vault Address of ICHI angel vault\n     * @param maxPosSize, USD price based maximum size of a position for given vault, based 1e18\n     */\n    function addStrategy(address vault, uint256 maxPosSize) external onlyOwner {\n        if (vault == address(0)) revert ZERO_ADDRESS();\n        if (maxPosSize == 0) revert ZERO_AMOUNT();\n        strategies.push(Strategy({vault: vault, maxPositionSize: maxPosSize}));\n        emit StrategyAdded(strategies.length - 1, vault, maxPosSize);\n    }\n\n    function addCollateralsSupport(\n        uint256 strategyId,\n        address[] memory collaterals,\n        uint256[] memory maxLTVs\n    ) external existingStrategy(strategyId) onlyOwner {\n        if (collaterals.length != maxLTVs.length || collaterals.length == 0)\n            revert INPUT_ARRAY_MISMATCH();\n\n        for (uint256 i = 0; i < collaterals.length; i++) {\n            if (collaterals[i] == address(0)) revert ZERO_ADDRESS();\n            if (maxLTVs[i] == 0) revert ZERO_AMOUNT();\n            maxLTV[strategyId][collaterals[i]] = maxLTVs[i];\n        }\n\n        emit CollateralsSupportAdded(strategyId, collaterals, maxLTVs);\n    }\n\n    function _validateMaxLTV(uint256 strategyId) internal view {\n        uint256 debtValue = bank.getDebtValue(bank.POSITION_ID());\n        (, address collToken, uint256 collAmount, , , , , ) = bank\n            .getCurrentPositionInfo();\n        uint256 collPrice = bank.oracle().getPrice(collToken);\n        uint256 collValue = (collPrice * collAmount) /\n            10**IERC20Metadata(collToken).decimals();\n\n        if (\n            debtValue >\n            (collValue * maxLTV[strategyId][collToken]) / DENOMINATOR\n        ) revert EXCEED_MAX_LTV();\n    }\n\n    /**\n     * @notice Internal function to deposit assets on ICHI Vault\n     * @param collToken Isolated collateral token address\n     * @param collAmount Amount of isolated collateral\n     * @param borrowToken Token address to borrow\n     * @param borrowAmount amount to borrow from Bank\n     */\n    function depositInternal(\n        uint256 strategyId,\n        address collToken,\n        address borrowToken,\n        uint256 collAmount,\n        uint256 borrowAmount\n    ) internal {\n        Strategy memory strategy = strategies[strategyId];\n\n        // 1. Lend isolated collaterals on compound\n        doLend(collToken, collAmount);\n\n        // 2. Borrow specific amounts\n        doBorrow(borrowToken, borrowAmount);\n\n        // 3. Add liquidity - Deposit on ICHI Vault\n        IICHIVault vault = IICHIVault(strategy.vault);\n        bool isTokenA = vault.token0() == borrowToken;\n        uint256 balance = IERC20(borrowToken).balanceOf(address(this));\n        ensureApprove(borrowToken, address(vault));\n        if (isTokenA) {\n            vault.deposit(balance, 0, address(this));\n        } else {\n            vault.deposit(0, balance, address(this));\n        }\n\n        // 4. Validate MAX LTV\n        _validateMaxLTV(strategyId);\n\n        // 5. Validate Max Pos Size\n        uint256 lpPrice = bank.oracle().getPrice(strategy.vault);\n        uint256 curPosSize = (lpPrice * vault.balanceOf(address(this))) /\n            10**IICHIVault(strategy.vault).decimals();\n        if (curPosSize > strategy.maxPositionSize)\n            revert EXCEED_MAX_POS_SIZE(strategyId);\n    }\n\n    /**\n     * @notice External function to deposit assets on IchiVault\n     * @param collToken Collateral Token address to deposit (e.g USDC)\n     * @param collAmount Amount of user's collateral (e.g USDC)\n     * @param borrowToken Address of token to borrow\n     * @param borrowAmount Amount to borrow from Bank\n     */\n    function openPosition(\n        uint256 strategyId,\n        address collToken,\n        address borrowToken,\n        uint256 collAmount,\n        uint256 borrowAmount\n    )\n        external\n        existingStrategy(strategyId)\n        existingCollateral(strategyId, collToken)\n    {\n        // 1-3 Deposit on ichi vault\n        depositInternal(\n            strategyId,\n            collToken,\n            borrowToken,\n            collAmount,\n            borrowAmount\n        );\n\n        // 4. Put collateral - ICHI Vault Lp Token\n        address vault = strategies[strategyId].vault;\n        doPutCollateral(vault, IERC20(vault).balanceOf(address(this)));\n    }\n\n    /**\n     * @notice External function to deposit assets on IchiVault and farm in Ichi Farm\n     * @param collToken Collateral Token address to deposit (e.g USDC)\n     * @param collAmount Amount of user's collateral (e.g USDC)\n     * @param borrowToken Address of token to borrow\n     * @param borrowAmount Amount to borrow from Bank\n     * @param farmingPid Pool Id of vault lp on ICHI Farm\n     */\n    function openPositionFarm(\n        uint256 strategyId,\n        address collToken,\n        address borrowToken,\n        uint256 collAmount,\n        uint256 borrowAmount,\n        uint256 farmingPid\n    )\n        external\n        existingStrategy(strategyId)\n        existingCollateral(strategyId, collToken)\n    {\n        Strategy memory strategy = strategies[strategyId];\n        address lpToken = wIchiFarm.ichiFarm().lpToken(farmingPid);\n        if (strategy.vault != lpToken) revert INCORRECT_LP(lpToken);\n\n        // 1-3 Deposit on ichi vault\n        depositInternal(\n            strategyId,\n            collToken,\n            borrowToken,\n            collAmount,\n            borrowAmount\n        );\n\n        // 4. Take out collateral\n        (\n            ,\n            ,\n            ,\n            ,\n            address posCollToken,\n            uint256 collId,\n            uint256 collSize,\n\n        ) = bank.getCurrentPositionInfo();\n        if (collSize > 0) {\n            (uint256 decodedPid, ) = wIchiFarm.decodeId(collId);\n            if (farmingPid != decodedPid) revert INCORRECT_PID(farmingPid);\n            if (posCollToken != address(wIchiFarm))\n                revert INCORRECT_COLTOKEN(posCollToken);\n            bank.takeCollateral(collSize);\n            wIchiFarm.burn(collId, collSize);\n        }\n\n        // 5. Deposit on farming pool, put collateral\n        ensureApprove(strategy.vault, address(wIchiFarm));\n        uint256 lpAmount = IERC20(strategy.vault).balanceOf(address(this));\n        uint256 id = wIchiFarm.mint(farmingPid, lpAmount);\n        bank.putCollateral(address(wIchiFarm), id, lpAmount);\n    }\n\n    /**\n     * @dev Increase isolated collateral of position\n     * @param token Isolated collateral token address\n     * @param amount Amount of token to increase position\n     */\n    function increasePosition(address token, uint256 amount) external {\n        // 1. Get user input amounts\n        doLend(token, amount);\n    }\n\n    /**\n     * @dev Reduce isolated collateral of position\n     * @param collToken Isolated collateral token address\n     * @param collAmount Amount of Isolated collateral\n     */\n    function reducePosition(\n        uint256 strategyId,\n        address collToken,\n        uint256 collAmount\n    ) external {\n        doWithdraw(collToken, collAmount);\n        doRefund(collToken);\n        _validateMaxLTV(strategyId);\n    }\n\n    function withdrawInternal(\n        uint256 strategyId,\n        address collToken,\n        address borrowToken,\n        uint256 amountRepay,\n        uint256 amountLpWithdraw,\n        uint256 amountShareWithdraw\n    ) internal {\n        Strategy memory strategy = strategies[strategyId];\n        IICHIVault vault = IICHIVault(strategy.vault);\n        uint256 positionId = bank.POSITION_ID();\n\n        // 1. Compute repay amount if MAX_INT is supplied (max debt)\n        if (amountRepay == type(uint256).max) {\n            amountRepay = bank.borrowBalanceCurrent(positionId, borrowToken);\n        }\n\n        // 2. Calculate actual amount to remove\n        uint256 amtLPToRemove = vault.balanceOf(address(this)) -\n            amountLpWithdraw;\n\n        // 3. Withdraw liquidity from ICHI vault\n        vault.withdraw(amtLPToRemove, address(this));\n\n        // 4. Swap withdrawn tokens to initial deposit token\n        bool isTokenA = vault.token0() == borrowToken;\n        uint256 amountToSwap = IERC20(\n            isTokenA ? vault.token1() : vault.token0()\n        ).balanceOf(address(this));\n        if (amountToSwap > 0) {\n            swapPool = IUniswapV3Pool(vault.pool());\n            swapPool.swap(\n                address(this),\n                // if withdraw token is Token0, then swap token1 -> token0 (false)\n                !isTokenA,\n                int256(amountToSwap),\n                isTokenA\n                    ? UniV3WrappedLibMockup.MAX_SQRT_RATIO - 1 // Token0 -> Token1\n                    : UniV3WrappedLibMockup.MIN_SQRT_RATIO + 1, // Token1 -> Token0\n                abi.encode(address(this))\n            );\n        }\n\n        // 5. Withdraw isolated collateral from Bank\n        doWithdraw(collToken, amountShareWithdraw);\n\n        // 6. Repay\n        doRepay(borrowToken, amountRepay);\n\n        _validateMaxLTV(strategyId);\n\n        // 7. Refund\n        doRefund(borrowToken);\n        doRefund(collToken);\n    }\n\n    /**\n     * @notice External function to withdraw assets from ICHI Vault\n     * @param collToken Token address to withdraw (e.g USDC)\n     * @param borrowToken Token address to withdraw (e.g USDC)\n     * @param lpTakeAmt Amount of ICHI Vault LP token to take out from Bank\n     * @param amountRepay Amount to repay the loan\n     * @param amountLpWithdraw Amount of ICHI Vault LP to withdraw from ICHI Vault\n     * @param amountShareWithdraw Amount of Isolated collateral to withdraw from Compound\n     */\n    function closePosition(\n        uint256 strategyId,\n        address collToken,\n        address borrowToken,\n        uint256 lpTakeAmt,\n        uint256 amountRepay,\n        uint256 amountLpWithdraw,\n        uint256 amountShareWithdraw\n    )\n        external\n        existingStrategy(strategyId)\n        existingCollateral(strategyId, collToken)\n    {\n        // 1. Take out collateral\n        doTakeCollateral(strategies[strategyId].vault, lpTakeAmt);\n\n        withdrawInternal(\n            strategyId,\n            collToken,\n            borrowToken,\n            amountRepay,\n            amountLpWithdraw,\n            amountShareWithdraw\n        );\n    }\n\n    function closePositionFarm(\n        uint256 strategyId,\n        address collToken,\n        address borrowToken,\n        uint256 lpTakeAmt,\n        uint256 amountRepay,\n        uint256 amountLpWithdraw,\n        uint256 amountShareWithdraw\n    )\n        external\n        existingStrategy(strategyId)\n        existingCollateral(strategyId, collToken)\n    {\n        address vault = strategies[strategyId].vault;\n        (, , , , address posCollToken, uint256 collId, , ) = bank\n            .getCurrentPositionInfo();\n        if (IWIchiFarm(posCollToken).getUnderlyingToken(collId) != vault)\n            revert INCORRECT_UNDERLYING(vault);\n        if (posCollToken != address(wIchiFarm))\n            revert INCORRECT_COLTOKEN(posCollToken);\n\n        // 1. Take out collateral\n        bank.takeCollateral(lpTakeAmt);\n        wIchiFarm.burn(collId, lpTakeAmt);\n        doCutRewardsFee(ICHI);\n\n        // 2-8. Remove liquidity\n        withdrawInternal(\n            strategyId,\n            collToken,\n            borrowToken,\n            amountRepay,\n            amountLpWithdraw,\n            amountShareWithdraw\n        );\n\n        // 9. Refund ichi token\n        doRefund(ICHI);\n    }\n\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external override {\n        if (msg.sender != address(swapPool)) revert NOT_FROM_UNIV3(msg.sender);\n        address payer = abi.decode(data, (address));\n\n        if (amount0Delta > 0) {\n            if (payer == address(this)) {\n                IERC20Upgradeable(swapPool.token0()).safeTransfer(\n                    msg.sender,\n                    uint256(amount0Delta)\n                );\n            } else {\n                IERC20Upgradeable(swapPool.token0()).safeTransferFrom(\n                    payer,\n                    msg.sender,\n                    uint256(amount0Delta)\n                );\n            }\n        } else if (amount1Delta > 0) {\n            if (payer == address(this)) {\n                IERC20Upgradeable(swapPool.token1()).safeTransfer(\n                    msg.sender,\n                    uint256(amount1Delta)\n                );\n            } else {\n                IERC20Upgradeable(swapPool.token1()).safeTransferFrom(\n                    payer,\n                    msg.sender,\n                    uint256(amount1Delta)\n                );\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/spell/IchiVaultSpell.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport \"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol\";\n\nimport \"./BasicSpell.sol\";\nimport \"../utils/BlueBerryConst.sol\";\nimport \"../libraries/UniV3/UniV3WrappedLibMockup.sol\";\nimport \"../interfaces/IOracle.sol\";\nimport \"../interfaces/IWIchiFarm.sol\";\nimport \"../interfaces/ichi/IICHIVault.sol\";\n\ncontract IchiVaultSpell is BasicSpell, IUniswapV3SwapCallback {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    struct Strategy {\n        address vault;\n        uint256 maxPositionSize;\n    }\n\n    /// @dev temperory state used to store uni v3 pool when swapping on uni v3\n    IUniswapV3Pool private swapPool;\n\n    /// @dev strategyId => ichi vault\n    Strategy[] public strategies;\n    /// @dev strategyId => collateral token => maxLTV\n    mapping(uint256 => mapping(address => uint256)) public maxLTV; // base 1e4\n    /// @dev address of ICHI farm wrapper\n    IWIchiFarm public wIchiFarm;\n    /// @dev address of ICHI token\n    address public ICHI;\n\n    event StrategyAdded(uint256 strategyId, address vault, uint256 maxPosSize);\n    event CollateralsSupportAdded(\n        uint256 strategyId,\n        address[] collaterals,\n        uint256[] maxLTVs\n    );\n\n    modifier existingStrategy(uint256 strategyId) {\n        if (strategyId >= strategies.length)\n            revert STRATEGY_NOT_EXIST(address(this), strategyId);\n\n        _;\n    }\n\n    modifier existingCollateral(uint256 strategyId, address col) {\n        if (maxLTV[strategyId][col] == 0)\n            revert COLLATERAL_NOT_EXIST(strategyId, col);\n\n        _;\n    }\n\n    function initialize(\n        IBank _bank,\n        address _werc20,\n        address _weth,\n        address _wichiFarm\n    ) external initializer {\n        __BasicSpell_init(_bank, _werc20, _weth);\n\n        wIchiFarm = IWIchiFarm(_wichiFarm);\n        ICHI = address(wIchiFarm.ICHI());\n        IWIchiFarm(_wichiFarm).setApprovalForAll(address(_bank), true);\n    }\n\n    /**\n     * @notice Owner privileged function to add vault\n     * @param vault Address of ICHI angel vault\n     * @param maxPosSize, USD price based maximum size of a position for given vault, based 1e18\n     */\n    function addStrategy(address vault, uint256 maxPosSize) external onlyOwner {\n        if (vault == address(0)) revert ZERO_ADDRESS();\n        if (maxPosSize == 0) revert ZERO_AMOUNT();\n        strategies.push(Strategy({vault: vault, maxPositionSize: maxPosSize}));\n        emit StrategyAdded(strategies.length - 1, vault, maxPosSize);\n    }\n\n    function addCollateralsSupport(\n        uint256 strategyId,\n        address[] memory collaterals,\n        uint256[] memory maxLTVs\n    ) external existingStrategy(strategyId) onlyOwner {\n        if (collaterals.length != maxLTVs.length || collaterals.length == 0)\n            revert INPUT_ARRAY_MISMATCH();\n\n        for (uint256 i = 0; i < collaterals.length; i++) {\n            if (collaterals[i] == address(0)) revert ZERO_ADDRESS();\n            if (maxLTVs[i] == 0) revert ZERO_AMOUNT();\n            maxLTV[strategyId][collaterals[i]] = maxLTVs[i];\n        }\n\n        emit CollateralsSupportAdded(strategyId, collaterals, maxLTVs);\n    }\n\n    function _validateMaxLTV(uint256 strategyId) internal view {\n        uint256 debtValue = bank.getDebtValue(bank.POSITION_ID());\n        (, address collToken, uint256 collAmount, , , , , ) = bank\n            .getCurrentPositionInfo();\n        uint256 collPrice = bank.oracle().getPrice(collToken);\n        uint256 collValue = (collPrice * collAmount) /\n            10**IERC20Metadata(collToken).decimals();\n\n        if (\n            debtValue >\n            (collValue * maxLTV[strategyId][collToken]) / DENOMINATOR\n        ) revert EXCEED_MAX_LTV();\n    }\n\n    /**\n     * @notice Internal function to deposit assets on ICHI Vault\n     * @param collToken Isolated collateral token address\n     * @param collAmount Amount of isolated collateral\n     * @param borrowToken Token address to borrow\n     * @param borrowAmount amount to borrow from Bank\n     */\n    function depositInternal(\n        uint256 strategyId,\n        address collToken,\n        address borrowToken,\n        uint256 collAmount,\n        uint256 borrowAmount\n    ) internal {\n        Strategy memory strategy = strategies[strategyId];\n\n        // 1. Lend isolated collaterals on compound\n        doLend(collToken, collAmount);\n\n        // 2. Borrow specific amounts\n        doBorrow(borrowToken, borrowAmount);\n\n        // 3. Add liquidity - Deposit on ICHI Vault\n        IICHIVault vault = IICHIVault(strategy.vault);\n        bool isTokenA = vault.token0() == borrowToken;\n        uint256 balance = IERC20(borrowToken).balanceOf(address(this));\n        ensureApprove(borrowToken, address(vault));\n        if (isTokenA) {\n            vault.deposit(balance, 0, address(this));\n        } else {\n            vault.deposit(0, balance, address(this));\n        }\n\n        // 4. Validate MAX LTV\n        _validateMaxLTV(strategyId);\n\n        // 5. Validate Max Pos Size\n        uint256 lpPrice = bank.oracle().getPrice(strategy.vault);\n        uint256 curPosSize = (lpPrice * vault.balanceOf(address(this))) /\n            10**IICHIVault(strategy.vault).decimals();\n        if (curPosSize > strategy.maxPositionSize)\n            revert EXCEED_MAX_POS_SIZE(strategyId);\n    }\n\n    /**\n     * @notice External function to deposit assets on IchiVault\n     * @param collToken Collateral Token address to deposit (e.g USDC)\n     * @param collAmount Amount of user's collateral (e.g USDC)\n     * @param borrowToken Address of token to borrow\n     * @param borrowAmount Amount to borrow from Bank\n     */\n    function openPosition(\n        uint256 strategyId,\n        address collToken,\n        address borrowToken,\n        uint256 collAmount,\n        uint256 borrowAmount\n    )\n        external\n        existingStrategy(strategyId)\n        existingCollateral(strategyId, collToken)\n    {\n        // 1-3 Deposit on ichi vault\n        depositInternal(\n            strategyId,\n            collToken,\n            borrowToken,\n            collAmount,\n            borrowAmount\n        );\n\n        // 4. Put collateral - ICHI Vault Lp Token\n        address vault = strategies[strategyId].vault;\n        doPutCollateral(vault, IERC20(vault).balanceOf(address(this)));\n    }\n\n    /**\n     * @notice External function to deposit assets on IchiVault and farm in Ichi Farm\n     * @param collToken Collateral Token address to deposit (e.g USDC)\n     * @param collAmount Amount of user's collateral (e.g USDC)\n     * @param borrowToken Address of token to borrow\n     * @param borrowAmount Amount to borrow from Bank\n     * @param farmingPid Pool Id of vault lp on ICHI Farm\n     */\n    function openPositionFarm(\n        uint256 strategyId,\n        address collToken,\n        address borrowToken,\n        uint256 collAmount,\n        uint256 borrowAmount,\n        uint256 farmingPid\n    )\n        external\n        existingStrategy(strategyId)\n        existingCollateral(strategyId, collToken)\n    {\n        Strategy memory strategy = strategies[strategyId];\n        address lpToken = wIchiFarm.ichiFarm().lpToken(farmingPid);\n        if (strategy.vault != lpToken) revert INCORRECT_LP(lpToken);\n\n        // 1-3 Deposit on ichi vault\n        depositInternal(\n            strategyId,\n            collToken,\n            borrowToken,\n            collAmount,\n            borrowAmount\n        );\n\n        // 4. Take out collateral\n        (\n            ,\n            ,\n            ,\n            ,\n            address posCollToken,\n            uint256 collId,\n            uint256 collSize,\n\n        ) = bank.getCurrentPositionInfo();\n        if (collSize > 0) {\n            (uint256 decodedPid, ) = wIchiFarm.decodeId(collId);\n            if (farmingPid != decodedPid) revert INCORRECT_PID(farmingPid);\n            if (posCollToken != address(wIchiFarm))\n                revert INCORRECT_COLTOKEN(posCollToken);\n            bank.takeCollateral(collSize);\n            wIchiFarm.burn(collId, collSize);\n        }\n\n        // 5. Deposit on farming pool, put collateral\n        ensureApprove(strategy.vault, address(wIchiFarm));\n        uint256 lpAmount = IERC20(strategy.vault).balanceOf(address(this));\n        uint256 id = wIchiFarm.mint(farmingPid, lpAmount);\n        bank.putCollateral(address(wIchiFarm), id, lpAmount);\n    }\n\n    /**\n     * @dev Increase isolated collateral of position\n     * @param token Isolated collateral token address\n     * @param amount Amount of token to increase position\n     */\n    function increasePosition(address token, uint256 amount) external {\n        // 1. Get user input amounts\n        doLend(token, amount);\n    }\n\n    /**\n     * @dev Reduce isolated collateral of position\n     * @param collToken Isolated collateral token address\n     * @param collAmount Amount of Isolated collateral\n     */\n    function reducePosition(\n        uint256 strategyId,\n        address collToken,\n        uint256 collAmount\n    ) external {\n        doWithdraw(collToken, collAmount);\n        doRefund(collToken);\n        _validateMaxLTV(strategyId);\n    }\n\n    function withdrawInternal(\n        uint256 strategyId,\n        address collToken,\n        address borrowToken,\n        uint256 amountRepay,\n        uint256 amountLpWithdraw,\n        uint256 amountShareWithdraw\n    ) internal {\n        Strategy memory strategy = strategies[strategyId];\n        IICHIVault vault = IICHIVault(strategy.vault);\n        uint256 positionId = bank.POSITION_ID();\n\n        // 1. Compute repay amount if MAX_INT is supplied (max debt)\n        if (amountRepay == type(uint256).max) {\n            amountRepay = bank.borrowBalanceCurrent(positionId, borrowToken);\n        }\n\n        // 2. Calculate actual amount to remove\n        uint256 amtLPToRemove = vault.balanceOf(address(this)) -\n            amountLpWithdraw;\n\n        // 3. Withdraw liquidity from ICHI vault\n        vault.withdraw(amtLPToRemove, address(this));\n\n        // 4. Swap withdrawn tokens to initial deposit token\n        bool isTokenA = vault.token0() == borrowToken;\n        uint256 amountToSwap = IERC20(\n            isTokenA ? vault.token1() : vault.token0()\n        ).balanceOf(address(this));\n        if (amountToSwap > 0) {\n            swapPool = IUniswapV3Pool(vault.pool());\n            swapPool.swap(\n                address(this),\n                // if withdraw token is Token0, then swap token1 -> token0 (false)\n                !isTokenA,\n                int256(amountToSwap),\n                isTokenA\n                    ? UniV3WrappedLibMockup.MAX_SQRT_RATIO - 1 // Token0 -> Token1\n                    : UniV3WrappedLibMockup.MIN_SQRT_RATIO + 1, // Token1 -> Token0\n                abi.encode(address(this))\n            );\n        }\n\n        // 5. Withdraw isolated collateral from Bank\n        doWithdraw(collToken, amountShareWithdraw);\n\n        // 6. Repay\n        doRepay(borrowToken, amountRepay);\n\n        _validateMaxLTV(strategyId);\n\n        // 7. Refund\n        doRefund(borrowToken);\n        doRefund(collToken);\n    }\n\n    /**\n     * @notice External function to withdraw assets from ICHI Vault\n     * @param collToken Token address to withdraw (e.g USDC)\n     * @param borrowToken Token address to withdraw (e.g USDC)\n     * @param lpTakeAmt Amount of ICHI Vault LP token to take out from Bank\n     * @param amountRepay Amount to repay the loan\n     * @param amountLpWithdraw Amount of ICHI Vault LP to withdraw from ICHI Vault\n     * @param amountShareWithdraw Amount of Isolated collateral to withdraw from Compound\n     */\n    function closePosition(\n        uint256 strategyId,\n        address collToken,\n        address borrowToken,\n        uint256 lpTakeAmt,\n        uint256 amountRepay,\n        uint256 amountLpWithdraw,\n        uint256 amountShareWithdraw\n    )\n        external\n        existingStrategy(strategyId)\n        existingCollateral(strategyId, collToken)\n    {\n        // 1. Take out collateral\n        doTakeCollateral(strategies[strategyId].vault, lpTakeAmt);\n\n        withdrawInternal(\n            strategyId,\n            collToken,\n            borrowToken,\n            amountRepay,\n            amountLpWithdraw,\n            amountShareWithdraw\n        );\n    }\n\n    function closePositionFarm(\n        uint256 strategyId,\n        address collToken,\n        address borrowToken,\n        uint256 lpTakeAmt,\n        uint256 amountRepay,\n        uint256 amountLpWithdraw,\n        uint256 amountShareWithdraw\n    )\n        external\n        existingStrategy(strategyId)\n        existingCollateral(strategyId, collToken)\n    {\n        address vault = strategies[strategyId].vault;\n        (, , , , address posCollToken, uint256 collId, , ) = bank\n            .getCurrentPositionInfo();\n        if (IWIchiFarm(posCollToken).getUnderlyingToken(collId) != vault)\n            revert INCORRECT_UNDERLYING(vault);\n        if (posCollToken != address(wIchiFarm))\n            revert INCORRECT_COLTOKEN(posCollToken);\n\n        // 1. Take out collateral\n        bank.takeCollateral(lpTakeAmt);\n        wIchiFarm.burn(collId, lpTakeAmt);\n        doCutRewardsFee(ICHI);\n\n        // 2-8. Remove liquidity\n        withdrawInternal(\n            strategyId,\n            collToken,\n            borrowToken,\n            amountRepay,\n            amountLpWithdraw,\n            amountShareWithdraw\n        );\n\n        // 9. Refund ichi token\n        doRefund(ICHI);\n    }\n\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external override {\n        if (msg.sender != address(swapPool)) revert NOT_FROM_UNIV3(msg.sender);\n        address payer = abi.decode(data, (address));\n\n        if (amount0Delta > 0) {\n            if (payer == address(this)) {\n                IERC20Upgradeable(swapPool.token0()).safeTransfer(\n                    msg.sender,\n                    uint256(amount0Delta)\n                );\n            } else {\n                IERC20Upgradeable(swapPool.token0()).safeTransferFrom(\n                    payer,\n                    msg.sender,\n                    uint256(amount0Delta)\n                );\n            }\n        } else if (amount1Delta > 0) {\n            if (payer == address(this)) {\n                IERC20Upgradeable(swapPool.token1()).safeTransfer(\n                    msg.sender,\n                    uint256(amount1Delta)\n                );\n            } else {\n                IERC20Upgradeable(swapPool.token1()).safeTransferFrom(\n                    payer,\n                    msg.sender,\n                    uint256(amount1Delta)\n                );\n            }\n        }\n    }\n}"
    }
  ]
}