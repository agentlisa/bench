{
  "Title": "[L06] Missing error messages in require statements",
  "Content": "In the code base there are many places where `require` statements are correctly followed by their error messages, clarifying what was the triggered exception. However, there are places in the code where `require` statements are not followed by the corresponding error messages.\n\n\nThis happens frequently in the internal arithmetic functions such as the one in the [`LiquidationEngine`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/LiquidationEngine.sol#L187-201) or in the [`StabilityFeeTreasury`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/StabilityFeeTreasury.sol#L131-L155) contract. If any of those require statements fails  \n\nthe checked condition, the transaction will revert silently with no informative error message.\n\n\nThe mentioned examples are just a few of the total present in the code base.\n\n\nConsider including specific and informative error messages in all `require` statements.\n\n\n***Update:** Fixed in [pull request #83.](https://github.com/reflexer-labs/geb/pull/83/files)*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/LiquidationEngine.sol",
      "content": "/// LiquidationEngine.sol\n\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.7;\n\nabstract contract CollateralAuctionHouseLike {\n    function startAuction(\n      address forgoneCollateralReceiver,\n      address initialBidder,\n      uint amountToRaise,\n      uint collateralToSell,\n      uint initialBid\n    ) virtual public returns (uint);\n}\nabstract contract SAFESaviourLike {\n    function saveSAFE(address,bytes32,address) virtual external returns (bool,uint256,uint256);\n}\nabstract contract SAFEEngineLike {\n    function collateralTypes(bytes32) virtual public view returns (\n        uint256 debtAmount,        // [wad]\n        uint256 accumulatedRate,   // [ray]\n        uint256 safetyPrice,       // [ray]\n        uint256 debtCeiling,       // [rad]\n        uint256 debtFloor,         // [rad]\n        uint256 liquidationPrice   // [ray]\n    );\n    function safes(bytes32,address) virtual public view returns (\n        uint256 lockedCollateral,  // [wad]\n        uint256 generatedDebt      // [wad]\n    );\n    function confiscateSAFECollateralAndDebt(bytes32,address,address,address,int,int) virtual external;\n    function canModifySAFE(address, address) virtual public view returns (bool);\n    function approveSAFEModification(address) virtual external;\n    function denySAFEModification(address) virtual external;\n}\nabstract contract AccountingEngineLike {\n    function pushDebtToQueue(uint) virtual external;\n}\n\ncontract LiquidationEngine {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    /**\n     * @notice Add auth to an account\n     * @param account Account to add auth to\n     */\n    function addAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 1;\n        emit AddAuthorization(account);\n    }\n    /**\n     * @notice Remove auth from an account\n     * @param account Account to remove auth from\n     */\n    function removeAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 0;\n        emit RemoveAuthorization(account);\n    }\n    /**\n    * @notice Checks whether msg.sender can call an authed function\n    **/\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"LiquidationEngine/account-not-authorized\");\n        _;\n    }\n\n    // --- SAFE Saviours ---\n    // Contracts that can save SAFEs from liquidation\n    mapping (address => uint) public safeSaviours;\n    /**\n    * @notice Authed function to add contracts that can save SAFEs from liquidation\n    * @param saviour SAFE saviour contract to be whitelisted\n    **/\n    function connectSAFESaviour(address saviour) external isAuthorized {\n        (bool ok, uint256 collateralAdded, uint256 liquidatorReward) =\n          SAFESaviourLike(saviour).saveSAFE(address(this), \"\", address(0));\n        require(ok, \"LiquidationEngine/saviour-not-ok\");\n        require(both(collateralAdded == uint(-1), liquidatorReward == uint(-1)), \"LiquidationEngine/invalid-amounts\");\n        safeSaviours[saviour] = 1;\n        emit ConnectSAFESaviour(saviour);\n    }\n    /**\n    * @notice Governance used function to remove contracts that can save SAFEs from liquidation\n    * @param saviour SAFE saviour contract to be removed\n    **/\n    function disconnectSAFESaviour(address saviour) external isAuthorized {\n        safeSaviours[saviour] = 0;\n        emit DisconnectSAFESaviour(saviour);\n    }\n\n    // --- Data ---\n    struct CollateralType {\n        // Address of the collateral auction house handling liquidations for this collateral type\n        address collateralAuctionHouse;\n        // Penalty applied to every liquidation involving this collateral type. Discourages SAFE users from bidding on their own SAFEs\n        uint256 liquidationPenalty;                                                                                                   // [wad]\n        // Max amount of system coins to request in one auction\n        uint256 liquidationQuantity;                                                                                                  // [rad]\n    }\n\n    // Collateral types included in the system\n    mapping (bytes32 => CollateralType)              public collateralTypes;\n    // Saviour contract chosen for each SAFE by its creator\n    mapping (bytes32 => mapping(address => address)) public chosenSAFESaviour;\n    // Mutex used to block against re-entrancy when 'liquidateSAFE' passes execution to a saviour\n    mapping (bytes32 => mapping(address => uint8))   public mutex;\n\n    // Max amount of system coins that can be on liquidation at any time\n    uint256 public onAuctionSystemCoinLimit;                                // [rad]\n    // Current amount of system coins out for liquidation\n    uint256 public currentOnAuctionSystemCoins;                             // [rad]\n    // Whether this contract is enabled\n    uint256 public contractEnabled;\n\n    SAFEEngineLike       public safeEngine;\n    AccountingEngineLike public accountingEngine;\n\n    // --- Events ---\n    event AddAuthorization(address account);\n    event RemoveAuthorization(address account);\n    event ConnectSAFESaviour(address saviour);\n    event DisconnectSAFESaviour(address saviour);\n    event UpdateCurrentOnAuctionSystemCoins(uint currentOnAuctionSystemCoins);\n    event ModifyParameters(bytes32 parameter, uint256 data);\n    event ModifyParameters(bytes32 parameter, address data);\n    event ModifyParameters(\n      bytes32 collateralType,\n      bytes32 parameter,\n      uint data\n    );\n    event ModifyParameters(\n      bytes32 collateralType,\n      bytes32 parameter,\n      address data\n    );\n    event DisableContract();\n    event Liquidate(\n      bytes32 indexed collateralType,\n      address indexed safe,\n      uint256 collateralAmount,\n      uint256 debtAmount,\n      uint256 amountToRaise,\n      address collateralAuctioneer,\n      uint256 auctionId\n    );\n    event SaveSAFE(\n      bytes32 indexed collateralType,\n      address indexed safe,\n      uint256 collateralAdded\n    );\n    event FailedSAFESave(bytes failReason);\n    event ProtectSAFE(\n      bytes32 collateralType,\n      address safe,\n      address saviour\n    );\n\n    // --- Init ---\n    constructor(address safeEngine_) public {\n        authorizedAccounts[msg.sender] = 1;\n        safeEngine = SAFEEngineLike(safeEngine_);\n        onAuctionSystemCoinLimit = uint(-1);\n        contractEnabled = 1;\n        emit AddAuthorization(msg.sender);\n        emit ModifyParameters(\"onAuctionSystemCoinLimit\", uint(-1));\n    }\n\n    // --- Math ---\n    uint256 constant WAD = 10 ** 18;\n    uint256 constant RAY = 10 ** 27;\n    uint256 constant MAX_LIQUIDATION_QUANTITY = uint256(-1) / RAY;\n\n    function addition(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x);\n    }\n    function subtract(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x);\n    }\n    function multiply(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n    function rmultiply(uint x, uint y) internal pure returns (uint z) {\n        z = multiply(x, y) / RAY;\n    }\n    function minimum(uint x, uint y) internal pure returns (uint z) {\n        if (x > y) { z = y; } else { z = x; }\n    }\n\n    // --- Utils ---\n    function both(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := and(x, y)}\n    }\n\n    // --- Administration ---\n    /*\n    * @notice Modify uint256 parameters\n    * @param paramter The name of the parameter modified\n    * @param data Value for the new parameter\n    */\n    function modifyParameters(bytes32 parameter, uint256 data) external isAuthorized {\n        if (parameter == \"onAuctionSystemCoinLimit\") onAuctionSystemCoinLimit = data;\n        else revert(\"LiquidationEngine/modify-unrecognized-param\");\n        emit ModifyParameters(parameter, data);\n    }\n    /**\n     * @notice Modify contract integrations\n     * @param parameter The name of the parameter modified\n     * @param data New address for the parameter\n     */\n    function modifyParameters(bytes32 parameter, address data) external isAuthorized {\n        if (parameter == \"accountingEngine\") accountingEngine = AccountingEngineLike(data);\n        else revert(\"LiquidationEngine/modify-unrecognized-param\");\n        emit ModifyParameters(parameter, data);\n    }\n    /**\n     * @notice Modify liquidation params\n     * @param collateralType The collateral type we change parameters for\n     * @param parameter The name of the parameter modified\n     * @param data New value for the parameter\n     */\n    function modifyParameters(\n        bytes32 collateralType,\n        bytes32 parameter,\n        uint data\n    ) external isAuthorized {\n        if (parameter == \"liquidationPenalty\") collateralTypes[collateralType].liquidationPenalty = data;\n        else if (parameter == \"liquidationQuantity\") {\n          require(data <= MAX_LIQUIDATION_QUANTITY, \"LiquidationEngine/liquidation-quantity-overflow\");\n          collateralTypes[collateralType].liquidationQuantity = data;\n        }\n        else revert(\"LiquidationEngine/modify-unrecognized-param\");\n        emit ModifyParameters(\n          collateralType,\n          parameter,\n          data\n        );\n    }\n    /**\n     * @notice Modify collateral auction integration\n     * @param collateralType The collateral type we change parameters for\n     * @param parameter The name of the integration modified\n     * @param data New address for the integration contract\n     */\n    function modifyParameters(\n        bytes32 collateralType,\n        bytes32 parameter,\n        address data\n    ) external isAuthorized {\n        if (parameter == \"collateralAuctionHouse\") {\n            safeEngine.denySAFEModification(collateralTypes[collateralType].collateralAuctionHouse);\n            collateralTypes[collateralType].collateralAuctionHouse = data;\n            safeEngine.approveSAFEModification(data);\n        }\n        else revert(\"LiquidationEngine/modify-unrecognized-param\");\n        emit ModifyParameters(\n            collateralType,\n            parameter,\n            data\n        );\n    }\n    /**\n     * @notice Disable this contract (normally called by GlobalSettlement)\n     */\n    function disableContract() external isAuthorized {\n        contractEnabled = 0;\n        emit DisableContract();\n    }\n\n    // --- SAFE Liquidation ---\n    /**\n     * @notice Choose a saviour contract for your SAFE\n     * @param collateralType The SAFE's collateral type\n     * @param safe The SAFE's address\n     * @param saviour The chosen saviour\n     */\n    function protectSAFE(\n        bytes32 collateralType,\n        address safe,\n        address saviour\n    ) external {\n        require(safeEngine.canModifySAFE(safe, msg.sender), \"LiquidationEngine/cannot-modify-safe\");\n        require(saviour == address(0) || safeSaviours[saviour] == 1, \"LiquidationEngine/saviour-not-authorized\");\n        chosenSAFESaviour[collateralType][safe] = saviour;\n        emit ProtectSAFE(\n            collateralType,\n            safe,\n            saviour\n        );\n    }\n    /**\n     * @notice Liquidate a SAFE\n     * @param collateralType The SAFE's collateral type\n     * @param safe The SAFE's address\n     */\n    function liquidateSAFE(bytes32 collateralType, address safe) external returns (uint auctionId) {\n        require(mutex[collateralType][safe] == 0, \"LiquidationEngine/non-null-mutex\");\n        mutex[collateralType][safe] = 1;\n\n        (, uint accumulatedRate, , , uint debtFloor, uint liquidationPrice) = safeEngine.collateralTypes(collateralType);\n        (uint safeCollateral, uint safeDebt) = safeEngine.safes(collateralType, safe);\n\n        require(contractEnabled == 1, \"LiquidationEngine/contract-not-enabled\");\n        require(both(\n          liquidationPrice > 0,\n          multiply(safeCollateral, liquidationPrice) < multiply(safeDebt, accumulatedRate)\n        ), \"LiquidationEngine/safe-not-unsafe\");\n        require(\n          both(currentOnAuctionSystemCoins < onAuctionSystemCoinLimit,\n          subtract(onAuctionSystemCoinLimit, currentOnAuctionSystemCoins) >= debtFloor),\n          \"LiquidationEngine/liquidation-limit-hit\"\n        );\n\n        if (chosenSAFESaviour[collateralType][safe] != address(0) &&\n            safeSaviours[chosenSAFESaviour[collateralType][safe]] == 1) {\n          try SAFESaviourLike(chosenSAFESaviour[collateralType][safe]).saveSAFE(msg.sender, collateralType, safe)\n            returns (bool ok, uint256 collateralAdded, uint256) {\n            if (both(ok, collateralAdded > 0)) {\n              emit SaveSAFE(collateralType, safe, collateralAdded);\n            }\n          } catch (bytes memory revertReason) {\n            emit FailedSAFESave(revertReason);\n          }\n        }\n\n        // Checks that the saviour didn't take collateral or add more debt to the SAFE\n        {\n          (uint newSafeCollateral, uint newSafeDebt) = safeEngine.safes(collateralType, safe);\n          require(both(newSafeCollateral >= safeCollateral, newSafeDebt <= safeDebt), \"LiquidationEngine/invalid-safe-saviour-operation\");\n        }\n\n        (, accumulatedRate, , , , liquidationPrice) = safeEngine.collateralTypes(collateralType);\n        (safeCollateral, safeDebt) = safeEngine.safes(collateralType, safe);\n\n        if (both(liquidationPrice > 0, multiply(safeCollateral, liquidationPrice) < multiply(safeDebt, accumulatedRate))) {\n          CollateralType memory collateralData = collateralTypes[collateralType];\n\n          uint limitAdjustedDebt = minimum(\n            safeDebt,\n            multiply(minimum(collateralData.liquidationQuantity, subtract(onAuctionSystemCoinLimit, currentOnAuctionSystemCoins)), WAD) / accumulatedRate / collateralData.liquidationPenalty\n          );\n          uint collateralToSell = minimum(safeCollateral, multiply(safeCollateral, limitAdjustedDebt) / safeDebt);\n\n          require(both(limitAdjustedDebt > 0, collateralToSell > 0), \"LiquidationEngine/null-auction\");\n          require(both(collateralToSell <= 2**255, limitAdjustedDebt <= 2**255), \"LiquidationEngine/collateral-or-debt-overflow\");\n          // This can leave the SAFE with generatedDebt < debtFloor\n          safeEngine.confiscateSAFECollateralAndDebt(\n            collateralType, safe, address(this), address(accountingEngine), -int(collateralToSell), -int(limitAdjustedDebt)\n          );\n          accountingEngine.pushDebtToQueue(multiply(limitAdjustedDebt, accumulatedRate));\n\n          {\n            uint amountToRaise_         = multiply(multiply(limitAdjustedDebt, accumulatedRate), collateralData.liquidationPenalty) / WAD;\n            currentOnAuctionSystemCoins = addition(currentOnAuctionSystemCoins, amountToRaise_);\n\n            auctionId = CollateralAuctionHouseLike(collateralData.collateralAuctionHouse).startAuction(\n              { forgoneCollateralReceiver: safe\n              , initialBidder: address(accountingEngine)\n              , amountToRaise: amountToRaise_\n              , collateralToSell: collateralToSell\n              , initialBid: 0\n             });\n\n             emit UpdateCurrentOnAuctionSystemCoins(currentOnAuctionSystemCoins);\n          }\n\n          emit Liquidate(collateralType, safe, collateralToSell, limitAdjustedDebt, multiply(limitAdjustedDebt, accumulatedRate), collateralData.collateralAuctionHouse, auctionId);\n        }\n\n        mutex[collateralType][safe] = 0;\n    }\n    function removeCoinsFromAuction(uint rad) public isAuthorized {\n        currentOnAuctionSystemCoins = subtract(currentOnAuctionSystemCoins, rad);\n        emit UpdateCurrentOnAuctionSystemCoins(currentOnAuctionSystemCoins);\n    }\n}"
    }
  ]
}