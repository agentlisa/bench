{
  "Title": "[G-08] Don't cache if used only once",
  "Content": "\nCaching here will simply increase gas cost, since it doesn't affect readability, we should not cache since we only reference the cached variables only once.\n\nhttps://github.com/open-dollar/od-contracts/blob/f4f0246bb26277249c1d5afe6201d4d9096e52e6/src/contracts/proxies/actions/BasicActions.sol#L101-L111\n```solidity\nFile: /src/contracts/proxies/actions/BasicActions.sol\n101:    address _safeEngine = ODSafeManager(_manager).safeEngine();\n\n105:    // Generates debt in the SAFE\n106:    _modifySAFECollateralization(\n107:      _manager,\n108:      _safeId,\n109:      0,\n110:      _getGeneratedDeltaDebt(_safeEngine, _safeInfo.collateralType, _safeInfo.safeHandler, _deltaWad)\n111:    );\n```\n\n```diff\ndiff --git a/src/contracts/proxies/actions/BasicActions.sol b/src/contracts/proxies/actions/BasicActions.sol\nindex e45fd41..8ad98f9 100644\n--- a/src/contracts/proxies/actions/BasicActions.sol\n+++ b/src/contracts/proxies/actions/BasicActions.sol\n@@ -98,7 +98,6 @@ contract BasicActions is CommonActions, IBasicActions {\n     uint256 _safeId,\n     uint256 _deltaWad\n   ) internal {\n-    address _safeEngine = ODSafeManager(_manager).safeEngine();\n     ODSafeManager.SAFEData memory _safeInfo = ODSafeManager(_manager).safeData(_safeId);\n     ITaxCollector(_taxCollector).taxSingle(_safeInfo.collateralType);\n\n@@ -107,7 +106,7 @@ contract BasicActions is CommonActions, IBasicActions {\n       _manager,\n       _safeId,\n       0,\n-      _getGeneratedDeltaDebt(_safeEngine, _safeInfo.collateralType, _safeInfo.safeHandler, _deltaWad)\n+      _getGeneratedDeltaDebt(ODSafeManager(_manager).safeEngine(), _safeInfo.collateralType, _safeInfo.safeHandler, _deltaWad)\n     );\n```\n\nhttps://github.com/open-dollar/od-contracts/blob/f4f0246bb26277249c1d5afe6201d4d9096e52e6/src/contracts/proxies/actions/BasicActions.sol#L128-L139\n```solidity\nFile: /src/contracts/proxies/actions/BasicActions.sol\n128:    address _safeEngine = ODSafeManager(_manager).safeEngine();\n\n\n135:\t// Paybacks debt to the SAFE\n136:    _modifySAFECollateralization(\n137:      _manager, _safeId, 0, _getRepaidDeltaDebt(_safeEngine, _safeInfo.collateralType, _safeInfo.safeHandler)\n138:    );\n139:  }\n```\n\n```diff\n-    address _safeEngine = ODSafeManager(_manager).safeEngine();\n     ODSafeManager.SAFEData memory _safeInfo = ODSafeManager(_manager).safeData(_safeId);\n     ITaxCollector(_taxCollector).taxSingle(_safeInfo.collateralType);\n\n@@ -134,7 +133,7 @@ contract BasicActions is CommonActions, IBasicActions {\n\n     // Paybacks debt to the SAFE\n     _modifySAFECollateralization(\n-      _manager, _safeId, 0, _getRepaidDeltaDebt(_safeEngine, _safeInfo.collateralType, _safeInfo.safeHandler)\n+      _manager, _safeId, 0, _getRepaidDeltaDebt(ODSafeManager(_manager).safeEngine(), _safeInfo.collateralType, _safeInfo.safeHandler)\n     );\n```\n\nhttps://github.com/open-dollar/od-contracts/blob/f4f0246bb26277249c1d5afe6201d4d9096e52e6/src/contracts/proxies/actions/BasicActions.sol#L179-L192\n```solidity\nFile: /src/contracts/proxies/actions/BasicActions.sol\n179:    address _safeEngine = ODSafeManager(_manager).safeEngine();\n\n\n186:    // Locks token amount into the SAFE and generates debt\n187:    _modifySAFECollateralization(\n188:      _manager,\n189:      _safeId,\n190:      _collateralAmount.toInt(),\n191:      _getGeneratedDeltaDebt(_safeEngine, _safeInfo.collateralType, _safeInfo.safeHandler, _deltaWad)\n192:    );\n```\n\n```diff\n-    address _safeEngine = ODSafeManager(_manager).safeEngine();\n     ODSafeManager.SAFEData memory _safeInfo = ODSafeManager(_manager).safeData(_safeId);\n     ITaxCollector(_taxCollector).taxSingle(_safeInfo.collateralType);\n\n@@ -188,7 +187,7 @@ contract BasicActions is CommonActions, IBasicActions {\n       _manager,\n       _safeId,\n       _collateralAmount.toInt(),\n-      _getGeneratedDeltaDebt(_safeEngine, _safeInfo.collateralType, _safeInfo.safeHandler, _deltaWad)\n+      _getGeneratedDeltaDebt(ODSafeManager(_manager).safeEngine(), _safeInfo.collateralType, _safeInfo.safeHandler, _deltaWad)\n     );\n```\n\nhttps://github.com/open-dollar/od-contracts/blob/f4f0246bb26277249c1d5afe6201d4d9096e52e6/src/contracts/proxies/actions/BasicActions.sol#L354-L367\n```solidity\nFile: /src/contracts/proxies/actions/BasicActions.sol\n354:    address _safeEngine = ODSafeManager(_manager).safeEngine();\n\n361:    // Paybacks debt to the SAFE and unlocks token amount from it\n362:    _modifySAFECollateralization(\n363:      _manager,\n364:      _safeId,\n365:      -_collateralWad.toInt(),\n366:      _getRepaidDeltaDebt(_safeEngine, _safeInfo.collateralType, _safeInfo.safeHandler)\n367:    );\n```\n\n```diff\n-    address _safeEngine = ODSafeManager(_manager).safeEngine();\n     ODSafeManager.SAFEData memory _safeInfo = ODSafeManager(_manager).safeData(_safeId);\n     ITaxCollector(_taxCollector).taxSingle(_safeInfo.collateralType);\n\n@@ -363,7 +362,7 @@ contract BasicActions is CommonActions, IBasicActions {\n       _manager,\n       _safeId,\n       -_collateralWad.toInt(),\n-      _getRepaidDeltaDebt(_safeEngine, _safeInfo.collateralType, _safeInfo.safeHandler)\n+      _getRepaidDeltaDebt(ODSafeManager(_manager).safeEngine(), _safeInfo.collateralType, _safeInfo.safeHandler)\n     );\n```\n\n**[pi0neerpat (OpenDollar) confirmed](https://github.com/code-423n4/2023-10-opendollar-findings/issues/386#issuecomment-1788046606)**\n\n***\n\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-10-opendollar",
  "Code": [
    {
      "filename": "src/contracts/proxies/actions/BasicActions.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport {ODSafeManager} from '@contracts/proxies/ODSafeManager.sol';\nimport {ODProxy} from '@contracts/proxies/ODProxy.sol';\n\nimport {ISAFEEngine} from '@interfaces/ISAFEEngine.sol';\nimport {ICoinJoin} from '@interfaces/utils/ICoinJoin.sol';\nimport {ITaxCollector} from '@interfaces/ITaxCollector.sol';\nimport {ICollateralJoin} from '@interfaces/utils/ICollateralJoin.sol';\nimport {IERC20Metadata} from '@openzeppelin/token/ERC20/extensions/IERC20Metadata.sol';\nimport {IBasicActions} from '@interfaces/proxies/actions/IBasicActions.sol';\n\nimport {Math, WAD, RAY, RAD} from '@libraries/Math.sol';\n\nimport {CommonActions} from '@contracts/proxies/actions/CommonActions.sol';\n\n/**\n * @title  BasicActions\n * @notice This contract defines the actions that can be executed to manage a SAFE\n */\ncontract BasicActions is CommonActions, IBasicActions {\n  using Math for uint256;\n\n  // --- Internal functions ---\n\n  /**\n   * @notice Gets delta debt generated for delta wad (always positive)\n   * @dev    Total SAFE debt minus available safeHandler COIN balance\n   */\n  function _getGeneratedDeltaDebt(\n    address _safeEngine,\n    bytes32 _cType,\n    address _safeHandler,\n    uint256 _deltaWad\n  ) internal view returns (int256 _deltaDebt) {\n    uint256 _rate = ISAFEEngine(_safeEngine).cData(_cType).accumulatedRate;\n    uint256 _coinAmount = ISAFEEngine(_safeEngine).coinBalance(_safeHandler);\n\n    // If there was already enough COIN in the safeEngine balance, just exits it without adding more debt\n    if (_coinAmount < _deltaWad * RAY) {\n      // Calculates the needed deltaDebt so together with the existing coins in the safeEngine is enough to exit wad amount of COIN tokens\n      _deltaDebt = ((_deltaWad * RAY - _coinAmount) / _rate).toInt();\n      // This is neeeded due lack of precision. It might need to sum an extra deltaDebt wei (for the given COIN wad amount)\n      _deltaDebt = uint256(_deltaDebt) * _rate < _deltaWad * RAY ? _deltaDebt + 1 : _deltaDebt;\n    }\n  }\n\n  /**\n   * @notice Gets repaid delta debt generated\n   * @dev    The rate adjusted debt of the SAFE\n   */\n  function _getRepaidDeltaDebt(\n    address _safeEngine,\n    bytes32 _cType,\n    address _safeHandler\n  ) internal view returns (int256 _deltaDebt) {\n    uint256 _rate = ISAFEEngine(_safeEngine).cData(_cType).accumulatedRate;\n    uint256 _generatedDebt = ISAFEEngine(_safeEngine).safes(_cType, _safeHandler).generatedDebt;\n    uint256 _coinAmount = ISAFEEngine(_safeEngine).coinBalance(_safeHandler);\n\n    // Uses the whole coin balance in the safeEngine to reduce the debt\n    _deltaDebt = (_coinAmount / _rate).toInt();\n    // Checks the calculated deltaDebt is not higher than safe.generatedDebt (total debt), otherwise uses its value\n    _deltaDebt = uint256(_deltaDebt) <= _generatedDebt ? -_deltaDebt : -_generatedDebt.toInt();\n  }\n\n  /**\n   * @notice Gets repaid debt\n   * @dev    The rate adjusted SAFE's debt minus COIN balance available in usr's address\n   */\n  function _getRepaidDebt(\n    address _safeEngine,\n    address _usr,\n    bytes32 _cType,\n    address _safeHandler\n  ) internal view returns (uint256 _deltaWad) {\n    uint256 _rate = ISAFEEngine(_safeEngine).cData(_cType).accumulatedRate;\n    uint256 _generatedDebt = ISAFEEngine(_safeEngine).safes(_cType, _safeHandler).generatedDebt;\n    uint256 _coinAmount = ISAFEEngine(_safeEngine).coinBalance(_usr);\n\n    // Uses the whole coin balance in the safeEngine to reduce the debt\n    uint256 _rad = _generatedDebt * _rate - _coinAmount;\n    // Calculates the equivalent COIN amount\n    _deltaWad = _rad / RAY;\n    // If the rad precision has some dust, it will need to request for 1 extra wad wei\n    _deltaWad = _deltaWad * RAY < _rad ? _deltaWad + 1 : _deltaWad;\n  }\n\n  /**\n   * @notice Generates debt\n   * @dev    Modifies the SAFE collateralization ratio, increasing the debt and sends the COIN amount to the user's address\n   */\n  function _generateDebt(\n    address _manager,\n    address _taxCollector,\n    address _coinJoin,\n    uint256 _safeId,\n    uint256 _deltaWad\n  ) internal {\n    address _safeEngine = ODSafeManager(_manager).safeEngine();\n    ODSafeManager.SAFEData memory _safeInfo = ODSafeManager(_manager).safeData(_safeId);\n    ITaxCollector(_taxCollector).taxSingle(_safeInfo.collateralType);\n\n    // Generates debt in the SAFE\n    _modifySAFECollateralization(\n      _manager,\n      _safeId,\n      0,\n      _getGeneratedDeltaDebt(_safeEngine, _safeInfo.collateralType, _safeInfo.safeHandler, _deltaWad)\n    );\n\n    // Moves the COIN amount to user's address\n    _collectAndExitCoins(_manager, _coinJoin, _safeId, _deltaWad);\n  }\n\n  /**\n   * @notice Repays debt\n   * @dev    Joins COIN amount into the safeEngine and modifies the SAFE collateralization reducing the debt\n   */\n  function _repayDebt(\n    address _manager,\n    address _taxCollector,\n    address _coinJoin,\n    uint256 _safeId,\n    uint256 _deltaWad\n  ) internal {\n    address _safeEngine = ODSafeManager(_manager).safeEngine();\n    ODSafeManager.SAFEData memory _safeInfo = ODSafeManager(_manager).safeData(_safeId);\n    ITaxCollector(_taxCollector).taxSingle(_safeInfo.collateralType);\n\n    // Joins COIN amount into the safeEngine\n    _joinSystemCoins(_coinJoin, _safeInfo.safeHandler, _deltaWad);\n\n    // Paybacks debt to the SAFE\n    _modifySAFECollateralization(\n      _manager, _safeId, 0, _getRepaidDeltaDebt(_safeEngine, _safeInfo.collateralType, _safeInfo.safeHandler)\n    );\n  }\n\n  /// @notice Routes the openSAFE call to the ODSafeManager contract\n  function _openSAFE(address _manager, bytes32 _cType, address _usr) internal returns (uint256 _safeId) {\n    _safeId = ODSafeManager(_manager).openSAFE(_cType, _usr);\n  }\n\n  /// @notice Routes the transferCollateral call to the ODSafeManager contract\n  function _transferCollateral(address _manager, uint256 _safeId, address _dst, uint256 _deltaWad) internal {\n    if (_deltaWad == 0) return;\n    ODSafeManager(_manager).transferCollateral(_safeId, _dst, _deltaWad);\n  }\n\n  /// @notice Routes the transferInternalCoins call to the ODSafeManager contract\n  function _transferInternalCoins(address _manager, uint256 _safeId, address _dst, uint256 _rad) internal {\n    ODSafeManager(_manager).transferInternalCoins(_safeId, _dst, _rad);\n  }\n\n  /// @notice Routes the modifySAFECollateralization call to the ODSafeManager contract\n  function _modifySAFECollateralization(\n    address _manager,\n    uint256 _safeId,\n    int256 _deltaCollateral,\n    int256 _deltaDebt\n  ) internal {\n    ODSafeManager(_manager).modifySAFECollateralization(_safeId, _deltaCollateral, _deltaDebt);\n  }\n\n  /**\n   * @notice Joins collateral and exits an amount of COIN\n   */\n  function _lockTokenCollateralAndGenerateDebt(\n    address _manager,\n    address _taxCollector,\n    address _collateralJoin,\n    address _coinJoin,\n    uint256 _safeId,\n    uint256 _collateralAmount,\n    uint256 _deltaWad\n  ) internal {\n    address _safeEngine = ODSafeManager(_manager).safeEngine();\n    ODSafeManager.SAFEData memory _safeInfo = ODSafeManager(_manager).safeData(_safeId);\n    ITaxCollector(_taxCollector).taxSingle(_safeInfo.collateralType);\n\n    // Takes token amount from user's wallet and joins into the safeEngine\n    _joinCollateral(_collateralJoin, _safeInfo.safeHandler, _collateralAmount);\n\n    // Locks token amount into the SAFE and generates debt\n    _modifySAFECollateralization(\n      _manager,\n      _safeId,\n      _collateralAmount.toInt(),\n      _getGeneratedDeltaDebt(_safeEngine, _safeInfo.collateralType, _safeInfo.safeHandler, _deltaWad)\n    );\n\n    // Exits and transfers COIN amount to the user's address\n    _collectAndExitCoins(_manager, _coinJoin, _safeId, _deltaWad);\n  }\n\n  /**\n   * @notice Transfers an amount of COIN to the proxy address and exits to the user's address\n   */\n  function _collectAndExitCoins(address _manager, address _coinJoin, uint256 _safeId, uint256 _deltaWad) internal {\n    // Moves the COIN amount to proxy's address\n    _transferInternalCoins(_manager, _safeId, address(this), _deltaWad * RAY);\n    // Exits the COIN amount to the user's address\n    _exitSystemCoins(_coinJoin, _deltaWad * RAY);\n  }\n\n  /**\n   * @notice Transfers an amount of collateral to the proxy address and exits collateral tokens to the user\n   */\n  function _collectAndExitCollateral(\n    address _manager,\n    address _collateralJoin,\n    uint256 _safeId,\n    uint256 _deltaWad\n  ) internal {\n    // Moves the amount from the SAFE handler to proxy's address\n    _transferCollateral(_manager, _safeId, address(this), _deltaWad);\n    // Exits a rounded down amount of collateral\n    _exitCollateral(_collateralJoin, _deltaWad);\n  }\n\n  // --- Methods ---\n\n  /// @inheritdoc IBasicActions\n  function openSAFE(address _manager, bytes32 _cType, address _usr) external delegateCall returns (uint256 _safeId) {\n    return _openSAFE(_manager, _cType, _usr);\n  }\n\n  /// @inheritdoc IBasicActions\n  function generateDebt(\n    address _manager,\n    address _taxCollector,\n    address _coinJoin,\n    uint256 _safeId,\n    uint256 _deltaWad\n  ) external delegateCall {\n    _generateDebt(_manager, _taxCollector, _coinJoin, _safeId, _deltaWad);\n  }\n\n  /// @inheritdoc IBasicActions\n  function repayDebt(\n    address _manager,\n    address _taxCollector,\n    address _coinJoin,\n    uint256 _safeId,\n    uint256 _deltaWad\n  ) external delegateCall {\n    _repayDebt(_manager, _taxCollector, _coinJoin, _safeId, _deltaWad);\n  }\n\n  /// @inheritdoc IBasicActions\n  function lockTokenCollateral(\n    address _manager,\n    address _collateralJoin,\n    uint256 _safeId,\n    uint256 _deltaWad\n  ) external delegateCall {\n    ODSafeManager.SAFEData memory _safeInfo = ODSafeManager(_manager).safeData(_safeId);\n\n    // Takes token amount from user's wallet and joins into the safeEngine\n    _joinCollateral(_collateralJoin, _safeInfo.safeHandler, _deltaWad);\n\n    // Locks token amount in the safe\n    _modifySAFECollateralization(_manager, _safeId, _deltaWad.toInt(), 0);\n  }\n\n  /// @inheritdoc IBasicActions\n  function freeTokenCollateral(\n    address _manager,\n    address _collateralJoin,\n    uint256 _safeId,\n    uint256 _deltaWad\n  ) external delegateCall {\n    // Unlocks token amount from the SAFE\n    _modifySAFECollateralization(_manager, _safeId, -_deltaWad.toInt(), 0);\n    // Transfers token amount to the user's address\n    _collectAndExitCollateral(_manager, _collateralJoin, _safeId, _deltaWad);\n  }\n\n  /// @inheritdoc IBasicActions\n  function repayAllDebt(\n    address _manager,\n    address _taxCollector,\n    address _coinJoin,\n    uint256 _safeId\n  ) external delegateCall {\n    address _safeEngine = ODSafeManager(_manager).safeEngine();\n    ODSafeManager.SAFEData memory _safeInfo = ODSafeManager(_manager).safeData(_safeId);\n    ITaxCollector(_taxCollector).taxSingle(_safeInfo.collateralType);\n\n    ISAFEEngine.SAFE memory _safeData = ISAFEEngine(_safeEngine).safes(_safeInfo.collateralType, _safeInfo.safeHandler);\n\n    // Joins COIN amount into the safeEngine\n    _joinSystemCoins(\n      _coinJoin,\n      address(this),\n      _getRepaidDebt(_safeEngine, address(this), _safeInfo.collateralType, _safeInfo.safeHandler)\n    );\n\n    // Paybacks debt to the SAFE (allowed because reducing debt of the SAFE)\n    ISAFEEngine(_safeEngine).modifySAFECollateralization({\n      _cType: _safeInfo.collateralType,\n      _safe: _safeInfo.safeHandler,\n      _collateralSource: address(this),\n      _debtDestination: address(this),\n      _deltaCollateral: 0,\n      _deltaDebt: -int256(_safeData.generatedDebt)\n    });\n  }\n\n  /// @inheritdoc IBasicActions\n  function lockTokenCollateralAndGenerateDebt(\n    address _manager,\n    address _taxCollector,\n    address _collateralJoin,\n    address _coinJoin,\n    uint256 _safe,\n    uint256 _collateralAmount,\n    uint256 _deltaWad\n  ) external delegateCall {\n    _lockTokenCollateralAndGenerateDebt(\n      _manager, _taxCollector, _collateralJoin, _coinJoin, _safe, _collateralAmount, _deltaWad\n    );\n  }\n\n  /// @inheritdoc IBasicActions\n  function openLockTokenCollateralAndGenerateDebt(\n    address _manager,\n    address _taxCollector,\n    address _collateralJoin,\n    address _coinJoin,\n    bytes32 _cType,\n    uint256 _collateralAmount,\n    uint256 _deltaWad\n  ) external delegateCall returns (uint256 _safe) {\n    _safe = _openSAFE(_manager, _cType, address(this));\n\n    _lockTokenCollateralAndGenerateDebt(\n      _manager, _taxCollector, _collateralJoin, _coinJoin, _safe, _collateralAmount, _deltaWad\n    );\n  }\n\n  /// @inheritdoc IBasicActions\n  function repayDebtAndFreeTokenCollateral(\n    address _manager,\n    address _taxCollector,\n    address _collateralJoin,\n    address _coinJoin,\n    uint256 _safeId,\n    uint256 _collateralWad,\n    uint256 _debtWad\n  ) external delegateCall {\n    address _safeEngine = ODSafeManager(_manager).safeEngine();\n    ODSafeManager.SAFEData memory _safeInfo = ODSafeManager(_manager).safeData(_safeId);\n    ITaxCollector(_taxCollector).taxSingle(_safeInfo.collateralType);\n\n    // Joins COIN amount into the safeEngine\n    _joinSystemCoins(_coinJoin, _safeInfo.safeHandler, _debtWad);\n\n    // Paybacks debt to the SAFE and unlocks token amount from it\n    _modifySAFECollateralization(\n      _manager,\n      _safeId,\n      -_collateralWad.toInt(),\n      _getRepaidDeltaDebt(_safeEngine, _safeInfo.collateralType, _safeInfo.safeHandler)\n    );\n\n    // Transfers token amount to the user's address\n    _collectAndExitCollateral(_manager, _collateralJoin, _safeId, _collateralWad);\n  }\n\n  /// @inheritdoc IBasicActions\n  function repayAllDebtAndFreeTokenCollateral(\n    address _manager,\n    address _taxCollector,\n    address _collateralJoin,\n    address _coinJoin,\n    uint256 _safeId,\n    uint256 _collateralWad\n  ) external delegateCall {\n    address _safeEngine = ODSafeManager(_manager).safeEngine();\n    ODSafeManager.SAFEData memory _safeInfo = ODSafeManager(_manager).safeData(_safeId);\n    ITaxCollector(_taxCollector).taxSingle(_safeInfo.collateralType);\n\n    ISAFEEngine.SAFE memory _safeData = ISAFEEngine(_safeEngine).safes(_safeInfo.collateralType, _safeInfo.safeHandler);\n\n    // Joins COIN amount into the safeEngine\n    _joinSystemCoins(\n      _coinJoin,\n      _safeInfo.safeHandler,\n      _getRepaidDebt(_safeEngine, _safeInfo.safeHandler, _safeInfo.collateralType, _safeInfo.safeHandler)\n    );\n\n    // Paybacks debt to the SAFE and unlocks token amount from it\n    _modifySAFECollateralization(_manager, _safeId, -_collateralWad.toInt(), -_safeData.generatedDebt.toInt());\n\n    // Transfers token amount to the user's address\n    _collectAndExitCollateral(_manager, _collateralJoin, _safeId, _collateralWad);\n  }\n}"
    },
    {
      "filename": "src/contracts/proxies/actions/BasicActions.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport {ODSafeManager} from '@contracts/proxies/ODSafeManager.sol';\nimport {ODProxy} from '@contracts/proxies/ODProxy.sol';\n\nimport {ISAFEEngine} from '@interfaces/ISAFEEngine.sol';\nimport {ICoinJoin} from '@interfaces/utils/ICoinJoin.sol';\nimport {ITaxCollector} from '@interfaces/ITaxCollector.sol';\nimport {ICollateralJoin} from '@interfaces/utils/ICollateralJoin.sol';\nimport {IERC20Metadata} from '@openzeppelin/token/ERC20/extensions/IERC20Metadata.sol';\nimport {IBasicActions} from '@interfaces/proxies/actions/IBasicActions.sol';\n\nimport {Math, WAD, RAY, RAD} from '@libraries/Math.sol';\n\nimport {CommonActions} from '@contracts/proxies/actions/CommonActions.sol';\n\n/**\n * @title  BasicActions\n * @notice This contract defines the actions that can be executed to manage a SAFE\n */\ncontract BasicActions is CommonActions, IBasicActions {\n  using Math for uint256;\n\n  // --- Internal functions ---\n\n  /**\n   * @notice Gets delta debt generated for delta wad (always positive)\n   * @dev    Total SAFE debt minus available safeHandler COIN balance\n   */\n  function _getGeneratedDeltaDebt(\n    address _safeEngine,\n    bytes32 _cType,\n    address _safeHandler,\n    uint256 _deltaWad\n  ) internal view returns (int256 _deltaDebt) {\n    uint256 _rate = ISAFEEngine(_safeEngine).cData(_cType).accumulatedRate;\n    uint256 _coinAmount = ISAFEEngine(_safeEngine).coinBalance(_safeHandler);\n\n    // If there was already enough COIN in the safeEngine balance, just exits it without adding more debt\n    if (_coinAmount < _deltaWad * RAY) {\n      // Calculates the needed deltaDebt so together with the existing coins in the safeEngine is enough to exit wad amount of COIN tokens\n      _deltaDebt = ((_deltaWad * RAY - _coinAmount) / _rate).toInt();\n      // This is neeeded due lack of precision. It might need to sum an extra deltaDebt wei (for the given COIN wad amount)\n      _deltaDebt = uint256(_deltaDebt) * _rate < _deltaWad * RAY ? _deltaDebt + 1 : _deltaDebt;\n    }\n  }\n\n  /**\n   * @notice Gets repaid delta debt generated\n   * @dev    The rate adjusted debt of the SAFE\n   */\n  function _getRepaidDeltaDebt(\n    address _safeEngine,\n    bytes32 _cType,\n    address _safeHandler\n  ) internal view returns (int256 _deltaDebt) {\n    uint256 _rate = ISAFEEngine(_safeEngine).cData(_cType).accumulatedRate;\n    uint256 _generatedDebt = ISAFEEngine(_safeEngine).safes(_cType, _safeHandler).generatedDebt;\n    uint256 _coinAmount = ISAFEEngine(_safeEngine).coinBalance(_safeHandler);\n\n    // Uses the whole coin balance in the safeEngine to reduce the debt\n    _deltaDebt = (_coinAmount / _rate).toInt();\n    // Checks the calculated deltaDebt is not higher than safe.generatedDebt (total debt), otherwise uses its value\n    _deltaDebt = uint256(_deltaDebt) <= _generatedDebt ? -_deltaDebt : -_generatedDebt.toInt();\n  }\n\n  /**\n   * @notice Gets repaid debt\n   * @dev    The rate adjusted SAFE's debt minus COIN balance available in usr's address\n   */\n  function _getRepaidDebt(\n    address _safeEngine,\n    address _usr,\n    bytes32 _cType,\n    address _safeHandler\n  ) internal view returns (uint256 _deltaWad) {\n    uint256 _rate = ISAFEEngine(_safeEngine).cData(_cType).accumulatedRate;\n    uint256 _generatedDebt = ISAFEEngine(_safeEngine).safes(_cType, _safeHandler).generatedDebt;\n    uint256 _coinAmount = ISAFEEngine(_safeEngine).coinBalance(_usr);\n\n    // Uses the whole coin balance in the safeEngine to reduce the debt\n    uint256 _rad = _generatedDebt * _rate - _coinAmount;\n    // Calculates the equivalent COIN amount\n    _deltaWad = _rad / RAY;\n    // If the rad precision has some dust, it will need to request for 1 extra wad wei\n    _deltaWad = _deltaWad * RAY < _rad ? _deltaWad + 1 : _deltaWad;\n  }\n\n  /**\n   * @notice Generates debt\n   * @dev    Modifies the SAFE collateralization ratio, increasing the debt and sends the COIN amount to the user's address\n   */\n  function _generateDebt(\n    address _manager,\n    address _taxCollector,\n    address _coinJoin,\n    uint256 _safeId,\n    uint256 _deltaWad\n  ) internal {\n    address _safeEngine = ODSafeManager(_manager).safeEngine();\n    ODSafeManager.SAFEData memory _safeInfo = ODSafeManager(_manager).safeData(_safeId);\n    ITaxCollector(_taxCollector).taxSingle(_safeInfo.collateralType);\n\n    // Generates debt in the SAFE\n    _modifySAFECollateralization(\n      _manager,\n      _safeId,\n      0,\n      _getGeneratedDeltaDebt(_safeEngine, _safeInfo.collateralType, _safeInfo.safeHandler, _deltaWad)\n    );\n\n    // Moves the COIN amount to user's address\n    _collectAndExitCoins(_manager, _coinJoin, _safeId, _deltaWad);\n  }\n\n  /**\n   * @notice Repays debt\n   * @dev    Joins COIN amount into the safeEngine and modifies the SAFE collateralization reducing the debt\n   */\n  function _repayDebt(\n    address _manager,\n    address _taxCollector,\n    address _coinJoin,\n    uint256 _safeId,\n    uint256 _deltaWad\n  ) internal {\n    address _safeEngine = ODSafeManager(_manager).safeEngine();\n    ODSafeManager.SAFEData memory _safeInfo = ODSafeManager(_manager).safeData(_safeId);\n    ITaxCollector(_taxCollector).taxSingle(_safeInfo.collateralType);\n\n    // Joins COIN amount into the safeEngine\n    _joinSystemCoins(_coinJoin, _safeInfo.safeHandler, _deltaWad);\n\n    // Paybacks debt to the SAFE\n    _modifySAFECollateralization(\n      _manager, _safeId, 0, _getRepaidDeltaDebt(_safeEngine, _safeInfo.collateralType, _safeInfo.safeHandler)\n    );\n  }\n\n  /// @notice Routes the openSAFE call to the ODSafeManager contract\n  function _openSAFE(address _manager, bytes32 _cType, address _usr) internal returns (uint256 _safeId) {\n    _safeId = ODSafeManager(_manager).openSAFE(_cType, _usr);\n  }\n\n  /// @notice Routes the transferCollateral call to the ODSafeManager contract\n  function _transferCollateral(address _manager, uint256 _safeId, address _dst, uint256 _deltaWad) internal {\n    if (_deltaWad == 0) return;\n    ODSafeManager(_manager).transferCollateral(_safeId, _dst, _deltaWad);\n  }\n\n  /// @notice Routes the transferInternalCoins call to the ODSafeManager contract\n  function _transferInternalCoins(address _manager, uint256 _safeId, address _dst, uint256 _rad) internal {\n    ODSafeManager(_manager).transferInternalCoins(_safeId, _dst, _rad);\n  }\n\n  /// @notice Routes the modifySAFECollateralization call to the ODSafeManager contract\n  function _modifySAFECollateralization(\n    address _manager,\n    uint256 _safeId,\n    int256 _deltaCollateral,\n    int256 _deltaDebt\n  ) internal {\n    ODSafeManager(_manager).modifySAFECollateralization(_safeId, _deltaCollateral, _deltaDebt);\n  }\n\n  /**\n   * @notice Joins collateral and exits an amount of COIN\n   */\n  function _lockTokenCollateralAndGenerateDebt(\n    address _manager,\n    address _taxCollector,\n    address _collateralJoin,\n    address _coinJoin,\n    uint256 _safeId,\n    uint256 _collateralAmount,\n    uint256 _deltaWad\n  ) internal {\n    address _safeEngine = ODSafeManager(_manager).safeEngine();\n    ODSafeManager.SAFEData memory _safeInfo = ODSafeManager(_manager).safeData(_safeId);\n    ITaxCollector(_taxCollector).taxSingle(_safeInfo.collateralType);\n\n    // Takes token amount from user's wallet and joins into the safeEngine\n    _joinCollateral(_collateralJoin, _safeInfo.safeHandler, _collateralAmount);\n\n    // Locks token amount into the SAFE and generates debt\n    _modifySAFECollateralization(\n      _manager,\n      _safeId,\n      _collateralAmount.toInt(),\n      _getGeneratedDeltaDebt(_safeEngine, _safeInfo.collateralType, _safeInfo.safeHandler, _deltaWad)\n    );\n\n    // Exits and transfers COIN amount to the user's address\n    _collectAndExitCoins(_manager, _coinJoin, _safeId, _deltaWad);\n  }\n\n  /**\n   * @notice Transfers an amount of COIN to the proxy address and exits to the user's address\n   */\n  function _collectAndExitCoins(address _manager, address _coinJoin, uint256 _safeId, uint256 _deltaWad) internal {\n    // Moves the COIN amount to proxy's address\n    _transferInternalCoins(_manager, _safeId, address(this), _deltaWad * RAY);\n    // Exits the COIN amount to the user's address\n    _exitSystemCoins(_coinJoin, _deltaWad * RAY);\n  }\n\n  /**\n   * @notice Transfers an amount of collateral to the proxy address and exits collateral tokens to the user\n   */\n  function _collectAndExitCollateral(\n    address _manager,\n    address _collateralJoin,\n    uint256 _safeId,\n    uint256 _deltaWad\n  ) internal {\n    // Moves the amount from the SAFE handler to proxy's address\n    _transferCollateral(_manager, _safeId, address(this), _deltaWad);\n    // Exits a rounded down amount of collateral\n    _exitCollateral(_collateralJoin, _deltaWad);\n  }\n\n  // --- Methods ---\n\n  /// @inheritdoc IBasicActions\n  function openSAFE(address _manager, bytes32 _cType, address _usr) external delegateCall returns (uint256 _safeId) {\n    return _openSAFE(_manager, _cType, _usr);\n  }\n\n  /// @inheritdoc IBasicActions\n  function generateDebt(\n    address _manager,\n    address _taxCollector,\n    address _coinJoin,\n    uint256 _safeId,\n    uint256 _deltaWad\n  ) external delegateCall {\n    _generateDebt(_manager, _taxCollector, _coinJoin, _safeId, _deltaWad);\n  }\n\n  /// @inheritdoc IBasicActions\n  function repayDebt(\n    address _manager,\n    address _taxCollector,\n    address _coinJoin,\n    uint256 _safeId,\n    uint256 _deltaWad\n  ) external delegateCall {\n    _repayDebt(_manager, _taxCollector, _coinJoin, _safeId, _deltaWad);\n  }\n\n  /// @inheritdoc IBasicActions\n  function lockTokenCollateral(\n    address _manager,\n    address _collateralJoin,\n    uint256 _safeId,\n    uint256 _deltaWad\n  ) external delegateCall {\n    ODSafeManager.SAFEData memory _safeInfo = ODSafeManager(_manager).safeData(_safeId);\n\n    // Takes token amount from user's wallet and joins into the safeEngine\n    _joinCollateral(_collateralJoin, _safeInfo.safeHandler, _deltaWad);\n\n    // Locks token amount in the safe\n    _modifySAFECollateralization(_manager, _safeId, _deltaWad.toInt(), 0);\n  }\n\n  /// @inheritdoc IBasicActions\n  function freeTokenCollateral(\n    address _manager,\n    address _collateralJoin,\n    uint256 _safeId,\n    uint256 _deltaWad\n  ) external delegateCall {\n    // Unlocks token amount from the SAFE\n    _modifySAFECollateralization(_manager, _safeId, -_deltaWad.toInt(), 0);\n    // Transfers token amount to the user's address\n    _collectAndExitCollateral(_manager, _collateralJoin, _safeId, _deltaWad);\n  }\n\n  /// @inheritdoc IBasicActions\n  function repayAllDebt(\n    address _manager,\n    address _taxCollector,\n    address _coinJoin,\n    uint256 _safeId\n  ) external delegateCall {\n    address _safeEngine = ODSafeManager(_manager).safeEngine();\n    ODSafeManager.SAFEData memory _safeInfo = ODSafeManager(_manager).safeData(_safeId);\n    ITaxCollector(_taxCollector).taxSingle(_safeInfo.collateralType);\n\n    ISAFEEngine.SAFE memory _safeData = ISAFEEngine(_safeEngine).safes(_safeInfo.collateralType, _safeInfo.safeHandler);\n\n    // Joins COIN amount into the safeEngine\n    _joinSystemCoins(\n      _coinJoin,\n      address(this),\n      _getRepaidDebt(_safeEngine, address(this), _safeInfo.collateralType, _safeInfo.safeHandler)\n    );\n\n    // Paybacks debt to the SAFE (allowed because reducing debt of the SAFE)\n    ISAFEEngine(_safeEngine).modifySAFECollateralization({\n      _cType: _safeInfo.collateralType,\n      _safe: _safeInfo.safeHandler,\n      _collateralSource: address(this),\n      _debtDestination: address(this),\n      _deltaCollateral: 0,\n      _deltaDebt: -int256(_safeData.generatedDebt)\n    });\n  }\n\n  /// @inheritdoc IBasicActions\n  function lockTokenCollateralAndGenerateDebt(\n    address _manager,\n    address _taxCollector,\n    address _collateralJoin,\n    address _coinJoin,\n    uint256 _safe,\n    uint256 _collateralAmount,\n    uint256 _deltaWad\n  ) external delegateCall {\n    _lockTokenCollateralAndGenerateDebt(\n      _manager, _taxCollector, _collateralJoin, _coinJoin, _safe, _collateralAmount, _deltaWad\n    );\n  }\n\n  /// @inheritdoc IBasicActions\n  function openLockTokenCollateralAndGenerateDebt(\n    address _manager,\n    address _taxCollector,\n    address _collateralJoin,\n    address _coinJoin,\n    bytes32 _cType,\n    uint256 _collateralAmount,\n    uint256 _deltaWad\n  ) external delegateCall returns (uint256 _safe) {\n    _safe = _openSAFE(_manager, _cType, address(this));\n\n    _lockTokenCollateralAndGenerateDebt(\n      _manager, _taxCollector, _collateralJoin, _coinJoin, _safe, _collateralAmount, _deltaWad\n    );\n  }\n\n  /// @inheritdoc IBasicActions\n  function repayDebtAndFreeTokenCollateral(\n    address _manager,\n    address _taxCollector,\n    address _collateralJoin,\n    address _coinJoin,\n    uint256 _safeId,\n    uint256 _collateralWad,\n    uint256 _debtWad\n  ) external delegateCall {\n    address _safeEngine = ODSafeManager(_manager).safeEngine();\n    ODSafeManager.SAFEData memory _safeInfo = ODSafeManager(_manager).safeData(_safeId);\n    ITaxCollector(_taxCollector).taxSingle(_safeInfo.collateralType);\n\n    // Joins COIN amount into the safeEngine\n    _joinSystemCoins(_coinJoin, _safeInfo.safeHandler, _debtWad);\n\n    // Paybacks debt to the SAFE and unlocks token amount from it\n    _modifySAFECollateralization(\n      _manager,\n      _safeId,\n      -_collateralWad.toInt(),\n      _getRepaidDeltaDebt(_safeEngine, _safeInfo.collateralType, _safeInfo.safeHandler)\n    );\n\n    // Transfers token amount to the user's address\n    _collectAndExitCollateral(_manager, _collateralJoin, _safeId, _collateralWad);\n  }\n\n  /// @inheritdoc IBasicActions\n  function repayAllDebtAndFreeTokenCollateral(\n    address _manager,\n    address _taxCollector,\n    address _collateralJoin,\n    address _coinJoin,\n    uint256 _safeId,\n    uint256 _collateralWad\n  ) external delegateCall {\n    address _safeEngine = ODSafeManager(_manager).safeEngine();\n    ODSafeManager.SAFEData memory _safeInfo = ODSafeManager(_manager).safeData(_safeId);\n    ITaxCollector(_taxCollector).taxSingle(_safeInfo.collateralType);\n\n    ISAFEEngine.SAFE memory _safeData = ISAFEEngine(_safeEngine).safes(_safeInfo.collateralType, _safeInfo.safeHandler);\n\n    // Joins COIN amount into the safeEngine\n    _joinSystemCoins(\n      _coinJoin,\n      _safeInfo.safeHandler,\n      _getRepaidDebt(_safeEngine, _safeInfo.safeHandler, _safeInfo.collateralType, _safeInfo.safeHandler)\n    );\n\n    // Paybacks debt to the SAFE and unlocks token amount from it\n    _modifySAFECollateralization(_manager, _safeId, -_collateralWad.toInt(), -_safeData.generatedDebt.toInt());\n\n    // Transfers token amount to the user's address\n    _collectAndExitCollateral(_manager, _collateralJoin, _safeId, _collateralWad);\n  }\n}"
    },
    {
      "filename": "src/contracts/proxies/actions/BasicActions.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport {ODSafeManager} from '@contracts/proxies/ODSafeManager.sol';\nimport {ODProxy} from '@contracts/proxies/ODProxy.sol';\n\nimport {ISAFEEngine} from '@interfaces/ISAFEEngine.sol';\nimport {ICoinJoin} from '@interfaces/utils/ICoinJoin.sol';\nimport {ITaxCollector} from '@interfaces/ITaxCollector.sol';\nimport {ICollateralJoin} from '@interfaces/utils/ICollateralJoin.sol';\nimport {IERC20Metadata} from '@openzeppelin/token/ERC20/extensions/IERC20Metadata.sol';\nimport {IBasicActions} from '@interfaces/proxies/actions/IBasicActions.sol';\n\nimport {Math, WAD, RAY, RAD} from '@libraries/Math.sol';\n\nimport {CommonActions} from '@contracts/proxies/actions/CommonActions.sol';\n\n/**\n * @title  BasicActions\n * @notice This contract defines the actions that can be executed to manage a SAFE\n */\ncontract BasicActions is CommonActions, IBasicActions {\n  using Math for uint256;\n\n  // --- Internal functions ---\n\n  /**\n   * @notice Gets delta debt generated for delta wad (always positive)\n   * @dev    Total SAFE debt minus available safeHandler COIN balance\n   */\n  function _getGeneratedDeltaDebt(\n    address _safeEngine,\n    bytes32 _cType,\n    address _safeHandler,\n    uint256 _deltaWad\n  ) internal view returns (int256 _deltaDebt) {\n    uint256 _rate = ISAFEEngine(_safeEngine).cData(_cType).accumulatedRate;\n    uint256 _coinAmount = ISAFEEngine(_safeEngine).coinBalance(_safeHandler);\n\n    // If there was already enough COIN in the safeEngine balance, just exits it without adding more debt\n    if (_coinAmount < _deltaWad * RAY) {\n      // Calculates the needed deltaDebt so together with the existing coins in the safeEngine is enough to exit wad amount of COIN tokens\n      _deltaDebt = ((_deltaWad * RAY - _coinAmount) / _rate).toInt();\n      // This is neeeded due lack of precision. It might need to sum an extra deltaDebt wei (for the given COIN wad amount)\n      _deltaDebt = uint256(_deltaDebt) * _rate < _deltaWad * RAY ? _deltaDebt + 1 : _deltaDebt;\n    }\n  }\n\n  /**\n   * @notice Gets repaid delta debt generated\n   * @dev    The rate adjusted debt of the SAFE\n   */\n  function _getRepaidDeltaDebt(\n    address _safeEngine,\n    bytes32 _cType,\n    address _safeHandler\n  ) internal view returns (int256 _deltaDebt) {\n    uint256 _rate = ISAFEEngine(_safeEngine).cData(_cType).accumulatedRate;\n    uint256 _generatedDebt = ISAFEEngine(_safeEngine).safes(_cType, _safeHandler).generatedDebt;\n    uint256 _coinAmount = ISAFEEngine(_safeEngine).coinBalance(_safeHandler);\n\n    // Uses the whole coin balance in the safeEngine to reduce the debt\n    _deltaDebt = (_coinAmount / _rate).toInt();\n    // Checks the calculated deltaDebt is not higher than safe.generatedDebt (total debt), otherwise uses its value\n    _deltaDebt = uint256(_deltaDebt) <= _generatedDebt ? -_deltaDebt : -_generatedDebt.toInt();\n  }\n\n  /**\n   * @notice Gets repaid debt\n   * @dev    The rate adjusted SAFE's debt minus COIN balance available in usr's address\n   */\n  function _getRepaidDebt(\n    address _safeEngine,\n    address _usr,\n    bytes32 _cType,\n    address _safeHandler\n  ) internal view returns (uint256 _deltaWad) {\n    uint256 _rate = ISAFEEngine(_safeEngine).cData(_cType).accumulatedRate;\n    uint256 _generatedDebt = ISAF"
    }
  ]
}