{
  "Title": "`AllocationVesting.setAllocations()` allows setting a zero `numberOfWeeks`",
  "Content": "##### Description\n\n- https://github.com/prisma-fi/prisma-contracts/blob/d9a2b2ba4d26e01115731fffadd8306c5955a660/contracts/dao/AllocationVesting.sol#L94\n\n`setAllocations()` allows an admin to create an allocation with zero `numberOfWeeks`, leading to unexpected behavior. For example, the `_vestedAt()` function for allocations with zero `numberOfWeeks` always returns zero and thus the `claim()` function reverts, so a user can't withdraw funds from such an allocation.\n\nHowever, `transferPoints()` assumes that if an allocation has zero `numberOfWeeks`, then this allocation is empty and therefore rewrites `numberOfWeeks` with the sender's value:\n```\nif (numberOfWeeksTo == 0) {\n    allocations[to].numberOfWeeks = numberOfWeeksFrom;\n}\n```\n\n- https://github.com/prisma-fi/prisma-contracts/blob/d9a2b2ba4d26e01115731fffadd8306c5955a660/contracts/dao/AllocationVesting.sol#L130-L133\n\nThus, after transferring additional points, this allocation becomes available for withdrawal.\n\n##### Recommendation\n\nWe recommend adding a check in the `AllocationVesting.setAllocations()` function to ensure that `numberOfWeeks` cannot be zero.\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/dao/AllocationVesting.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { DelegatedOps } from \"../dependencies/DelegatedOps.sol\";\nimport { PrismaOwnable } from \"../dependencies/PrismaOwnable.sol\";\nimport { ITokenLocker } from \"../interfaces/ITokenLocker.sol\";\n\n/**\n * @title Vesting contract for team and investors\n * @author PrismaFi\n * @notice Vesting contract which allows transfer of future vesting claims\n */\ncontract AllocationVesting is DelegatedOps, Ownable {\n    error NothingToClaim();\n    error CannotLock();\n    error WrongMaxTotalPreclaimPct();\n    error PreclaimTooLarge();\n    error AllocationsMismatch();\n    error ZeroTotalAllocation();\n    error ZeroAllocation();\n    error InsufficientPoints();\n    error LockedAllocation();\n    error IllegalVestingStart();\n    error VestingAlreadyStarted();\n    error IncompatibleVestingPeriod(uint256 numberOfWeeksFrom, uint256 numberOfWeeksTo);\n\n    struct AllocationSplit {\n        address recipient;\n        uint24 points;\n        uint8 numberOfWeeks;\n    }\n\n    struct AllocationState {\n        uint24 points;\n        uint8 numberOfWeeks;\n        uint128 claimed;\n        uint96 preclaimed;\n    }\n\n    // This number should allow a good precision in allocation fractions\n    uint256 private constant TOTAL_POINTS = 100000;\n    // Users allocations\n    mapping(address => AllocationState) public allocations;\n    // max percentage of one's vest that can be preclaimed in total\n    uint256 public immutable maxTotalPreclaimPct;\n    // Total allocation expressed in tokens\n    uint256 public immutable totalAllocation;\n    IERC20 public immutable vestingToken;\n    address public immutable vault;\n    ITokenLocker public immutable tokenLocker;\n    uint256 public immutable lockToTokenRatio;\n    // Vesting timeline starting timestamp\n    uint256 public vestingStart;\n\n    constructor(\n        IERC20 vestingToken_,\n        ITokenLocker tokenLocker_,\n        uint256 totalAllocation_,\n        address vault_,\n        uint256 maxTotalPreclaimPct_\n    ) {\n        if (totalAllocation_ == 0) revert ZeroTotalAllocation();\n        if (maxTotalPreclaimPct_ > 20) revert WrongMaxTotalPreclaimPct();\n        vault = vault_;\n        tokenLocker = tokenLocker_;\n        vestingToken = vestingToken_;\n        totalAllocation = totalAllocation_;\n        lockToTokenRatio = tokenLocker_.lockToTokenRatio();\n        maxTotalPreclaimPct = maxTotalPreclaimPct_;\n    }\n\n    /**\n     *\n     * @notice Set allocations and starts vesting\n     * @param allocationSplits Allocations to be set\n     * @param vestingStart_ Start of the vesting timeline\n     * @dev This can be called only once by the owner\n     */\n    function setAllocations(AllocationSplit[] calldata allocationSplits, uint256 vestingStart_) external onlyOwner {\n        if (vestingStart_ < block.timestamp || block.timestamp + 5 weeks < vestingStart_) revert IllegalVestingStart();\n        if (vestingStart != 0) revert VestingAlreadyStarted();\n        vestingStart = vestingStart_;\n        uint256 loopEnd = allocationSplits.length;\n        uint256 totalPoints;\n        for (uint256 i; i < loopEnd; ) {\n            uint256 points = allocationSplits[i].points;\n            totalPoints += points;\n            if (points == 0) revert ZeroAllocation();\n            address recipient = allocationSplits[i].recipient;\n            allocations[recipient].points = uint24(points);\n            allocations[recipient].numberOfWeeks = allocationSplits[i].numberOfWeeks;\n            unchecked {\n                ++i;\n            }\n        }\n        if (totalPoints != TOTAL_POINTS) revert AllocationsMismatch();\n    }\n\n    /**\n     * @notice Claims accrued tokens for initiator and transfers a number of allocation points to a recipient\n     * @dev Can be delegated\n     * @param from Initiator\n     * @param to Recipient\n     * @param points Number of points to transfer\n     */\n    function transferPoints(address from, address to, uint256 points) external callerOrDelegated(from) {\n        AllocationState memory fromAllocation = allocations[from];\n        AllocationState memory toAllocation = allocations[to];\n        uint8 numberOfWeeksFrom = fromAllocation.numberOfWeeks;\n        uint8 numberOfWeeksTo = toAllocation.numberOfWeeks;\n        if (numberOfWeeksTo != 0 && numberOfWeeksTo != numberOfWeeksFrom)\n            revert IncompatibleVestingPeriod(numberOfWeeksFrom, numberOfWeeksTo);\n        uint256 totalVested = _vestedAt(block.timestamp, fromAllocation.points, numberOfWeeksFrom);\n        if (totalVested < fromAllocation.claimed) revert LockedAllocation();\n        if (points == 0) revert ZeroAllocation();\n        if (fromAllocation.points < points) revert InsufficientPoints();\n        // We claim one last time before transfer\n        uint256 claimed = _claim(from, fromAllocation.points, fromAllocation.claimed, numberOfWeeksFrom);\n        // Passive balance to transfer\n        uint128 claimedAdjustment = uint128((claimed * points) / fromAllocation.points);\n        allocations[from].points = uint24(fromAllocation.points - points);\n        // we don't use fromAllocation as it's been modified with _claim()\n        allocations[from].claimed = allocations[from].claimed - claimedAdjustment;\n\n        allocations[to].points = toAllocation.points + uint24(points);\n        allocations[to].claimed = toAllocation.claimed + claimedAdjustment;\n        if (numberOfWeeksTo == 0) {\n            allocations[to].numberOfWeeks = numberOfWeeksFrom;\n        }\n    }\n\n    /**\n     * @notice Lock future claimable tokens tokens\n     * @dev Can be delegated\n     * @param account Account to lock for\n     * @param amount Amount to preclaim\n     */\n    function lockFutureClaims(address account, uint256 amount) external callerOrDelegated(account) {\n        lockFutureClaimsWithReceiver(account, account, amount);\n    }\n\n    /**\n     * @notice Lock future claimable tokens tokens\n     * @dev Can be delegated\n     * @param account Account to lock for\n     * @param receiver Receiver of the lock\n     * @param amount Amount to preclaim. If 0 the maximum allowed will be locked\n     */\n    function lockFutureClaimsWithReceiver(\n        address account,\n        address receiver,\n        uint256 amount\n    ) public callerOrDelegated(account) {\n        AllocationState memory allocation = allocations[account];\n        if (allocation.points == 0 || vestingStart == 0) revert CannotLock();\n        uint256 claimedUpdated = allocation.claimed;\n        if (_claimableAt(block.timestamp, allocation.points, allocation.claimed, allocation.numberOfWeeks) > 0) {\n            claimedUpdated = _claim(account, allocation.points, allocation.claimed, allocation.numberOfWeeks);\n        }\n        uint256 userAllocation = (allocation.points * totalAllocation) / TOTAL_POINTS;\n        uint256 _unclaimed = userAllocation - claimedUpdated;\n        uint256 preclaimed = allocation.preclaimed;\n        uint256 maxTotalPreclaim = (maxTotalPreclaimPct * userAllocation) / 100;\n        uint256 leftToPreclaim = maxTotalPreclaim - preclaimed;\n        if (amount == 0) amount = leftToPreclaim > _unclaimed ? _unclaimed : leftToPreclaim;\n        else if (preclaimed + amount > maxTotalPreclaim || amount > _unclaimed) revert PreclaimTooLarge();\n        allocations[account].claimed = uint128(claimedUpdated + amount);\n        allocations[account].preclaimed = uint96(preclaimed + amount);\n        vestingToken.transferFrom(vault, address(this), amount);\n        tokenLocker.lock(receiver, amount / lockToTokenRatio, 52);\n    }\n\n    /**\n     *\n     * @notice Claims accrued tokens\n     * @dev Can be delegated\n     * @param account Account to claim for\n     */\n    function claim(address account) external callerOrDelegated(account) {\n        AllocationState memory allocation = allocations[account];\n        _claim(account, allocation.points, allocation.claimed, allocation.numberOfWeeks);\n    }\n\n    // This function exists to avoid reloading the AllocationState struct in memory\n    function _claim(\n        address account,\n        uint256 points,\n        uint256 claimed,\n        uint256 numberOfWeeks\n    ) private returns (uint256 claimedUpdated) {\n        if (points == 0) revert NothingToClaim();\n        uint256 claimable = _claimableAt(block.timestamp, points, claimed, numberOfWeeks);\n        if (claimable == 0) revert NothingToClaim();\n        claimedUpdated = claimed + claimable;\n        allocations[account].claimed = uint128(claimedUpdated);\n        // We send to delegate for possible zaps\n        vestingToken.transferFrom(vault, msg.sender, claimable);\n    }\n\n    /**\n     * @notice Calculates number of tokens claimable by the user at the current block\n     * @param account Account to calculate for\n     * @return claimable Accrued tokens\n     */\n    function claimableNow(address account) external view returns (uint256 claimable) {\n        AllocationState memory allocation = allocations[account];\n        claimable = _claimableAt(block.timestamp, allocation.points, allocation.claimed, allocation.numberOfWeeks);\n    }\n\n    function _claimableAt(\n        uint256 when,\n        uint256 points,\n        uint256 claimed,\n        uint256 numberOfWeeks\n    ) private view returns (uint256) {\n        uint256 totalVested = _vestedAt(when, points, numberOfWeeks);\n        return totalVested > claimed ? totalVested - claimed : 0;\n    }\n\n    function _vestedAt(uint256 when, uint256 points, uint256 numberOfWeeks) private view returns (uint256 vested) {\n        if (vestingStart == 0 || numberOfWeeks == 0) return 0;\n        uint256 vestingWeeks = numberOfWeeks * 1 weeks;\n        uint256 vestingEnd = vestingStart + vestingWeeks;\n        uint256 endTime = when >= vestingEnd ? vestingEnd : when;\n        uint256 timeSinceStart = endTime - vestingStart;\n        vested = (totalAllocation * timeSinceStart * points) / (TOTAL_POINTS * vestingWeeks);\n    }\n\n    /**\n     * @notice Calculates the total number of tokens left unclaimed by the user including unvested ones\n     * @param account Account to calculate for\n     * @return Unclaimed tokens\n     */\n    function unclaimed(address account) external view returns (uint256) {\n        AllocationState memory allocation = allocations[account];\n        uint256 accountAllocation = (totalAllocation * allocation.points) / TOTAL_POINTS;\n        return accountAllocation - allocation.claimed;\n    }\n}"
    },
    {
      "filename": "contracts/dao/AllocationVesting.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { DelegatedOps } from \"../dependencies/DelegatedOps.sol\";\nimport { PrismaOwnable } from \"../dependencies/PrismaOwnable.sol\";\nimport { ITokenLocker } from \"../interfaces/ITokenLocker.sol\";\n\n/**\n * @title Vesting contract for team and investors\n * @author PrismaFi\n * @notice Vesting contract which allows transfer of future vesting claims\n */\ncontract AllocationVesting is DelegatedOps, Ownable {\n    error NothingToClaim();\n    error CannotLock();\n    error WrongMaxTotalPreclaimPct();\n    error PreclaimTooLarge();\n    error AllocationsMismatch();\n    error ZeroTotalAllocation();\n    error ZeroAllocation();\n    error InsufficientPoints();\n    error LockedAllocation();\n    error IllegalVestingStart();\n    error VestingAlreadyStarted();\n    error IncompatibleVestingPeriod(uint256 numberOfWeeksFrom, uint256 numberOfWeeksTo);\n\n    struct AllocationSplit {\n        address recipient;\n        uint24 points;\n        uint8 numberOfWeeks;\n    }\n\n    struct AllocationState {\n        uint24 points;\n        uint8 numberOfWeeks;\n        uint128 claimed;\n        uint96 preclaimed;\n    }\n\n    // This number should allow a good precision in allocation fractions\n    uint256 private constant TOTAL_POINTS = 100000;\n    // Users allocations\n    mapping(address => AllocationState) public allocations;\n    // max percentage of one's vest that can be preclaimed in total\n    uint256 public immutable maxTotalPreclaimPct;\n    // Total allocation expressed in tokens\n    uint256 public immutable totalAllocation;\n    IERC20 public immutable vestingToken;\n    address public immutable vault;\n    ITokenLocker public immutable tokenLocker;\n    uint256 public immutable lockToTokenRatio;\n    // Vesting timeline starting timestamp\n    uint256 public vestingStart;\n\n    constructor(\n        IERC20 vestingToken_,\n        ITokenLocker tokenLocker_,\n        uint256 totalAllocation_,\n        address vault_,\n        uint256 maxTotalPreclaimPct_\n    ) {\n        if (totalAllocation_ == 0) revert ZeroTotalAllocation();\n        if (maxTotalPreclaimPct_ > 20) revert WrongMaxTotalPreclaimPct();\n        vault = vault_;\n        tokenLocker = tokenLocker_;\n        vestingToken = vestingToken_;\n        totalAllocation = totalAllocation_;\n        lockToTokenRatio = tokenLocker_.lockToTokenRatio();\n        maxTotalPreclaimPct = maxTotalPreclaimPct_;\n    }\n\n    /**\n     *\n     * @notice Set allocations and starts vesting\n     * @param allocationSplits Allocations to be set\n     * @param vestingStart_ Start of the vesting timeline\n     * @dev This can be called only once by the owner\n     */\n    function setAllocations(AllocationSplit[] calldata allocationSplits, uint256 vestingStart_) external onlyOwner {\n        if (vestingStart_ < block.timestamp || block.timestamp + 5 weeks < vestingStart_) revert IllegalVestingStart();\n        if (vestingStart != 0) revert VestingAlreadyStarted();\n        vestingStart = vestingStart_;\n        uint256 loopEnd = allocationSplits.length;\n        uint256 totalPoints;\n        for (uint256 i; i < loopEnd; ) {\n            uint256 points = allocationSplits[i].points;\n            totalPoints += points;\n            if (points == 0) revert ZeroAllocation();\n            address recipient = allocationSplits[i].recipient;\n            allocations[recipient].points = uint24(points);\n            allocations[recipient].numberOfWeeks = allocationSplits[i].numberOfWeeks;\n            unchecked {\n                ++i;\n            }\n        }\n        if (totalPoints != TOTAL_POINTS) revert AllocationsMismatch();\n    }\n\n    /**\n     * @notice Claims accrued tokens for initiator and transfers a number of allocation points to a recipient\n     * @dev Can be delegated\n     * @param from Initiator\n     * @param to Recipient\n     * @param points Number of points to transfer\n     */\n    function transferPoints(address from, address to, uint256 points) external callerOrDelegated(from) {\n        AllocationState memory fromAllocation = allocations[from];\n        AllocationState memory toAllocation = allocations[to];\n        uint8 numberOfWeeksFrom = fromAllocation.numberOfWeeks;\n        uint8 numberOfWeeksTo = toAllocation.numberOfWeeks;\n        if (numberOfWeeksTo != 0 && numberOfWeeksTo != numberOfWeeksFrom)\n            revert IncompatibleVestingPeriod(numberOfWeeksFrom, numberOfWeeksTo);\n        uint256 totalVested = _vestedAt(block.timestamp, fromAllocation.points, numberOfWeeksFrom);\n        if (totalVested < fromAllocation.claimed) revert LockedAllocation();\n        if (points == 0) revert ZeroAllocation();\n        if (fromAllocation.points < points) revert InsufficientPoints();\n        // We claim one last time before transfer\n        uint256 claimed = _claim(from, fromAllocation.points, fromAllocation.claimed, numberOfWeeksFrom);\n        // Passive balance to transfer\n        uint128 claimedAdjustment = uint128((claimed * points) / fromAllocation.points);\n        allocations[from].points = uint24(fromAllocation.points - points);\n        // we don't use fromAllocation as it's been modified with _claim()\n        allocations[from].claimed = allocations[from].claimed - claimedAdjustment;\n\n        allocations[to].points = toAllocation.points + uint24(points);\n        allocations[to].claimed = toAllocation.claimed + claimedAdjustment;\n        if (numberOfWeeksTo == 0) {\n            allocations[to].numberOfWeeks = numberOfWeeksFrom;\n        }\n    }\n\n    /**\n     * @notice Lock future claimable tokens tokens\n     * @dev Can be delegated\n     * @param account Account to lock for\n     * @param amount Amount to preclaim\n     */\n    function lockFutureClaims(address account, uint256 amount) external callerOrDelegated(account) {\n        lockFutureClaimsWithReceiver(account, account, amount);\n    }\n\n    /**\n     * @notice Lock future claimable tokens tokens\n     * @dev Can be delegated\n     * @param account Account to lock for\n     * @param receiver Receiver of the lock\n     * @param amount Amount to preclaim. If 0 the maximum allowed will be locked\n     */\n    function lockFutureClaimsWithReceiver(\n        address account,\n        address receiver,\n        uint256 amount\n    ) public callerOrDelegated(account) {\n        AllocationState memory allocation = allocations[account];\n        if (allocation.points == 0 || vestingStart == 0) revert CannotLock();\n        uint256 claimedUpdated = allocation.claimed;\n        if (_claimableAt(block.timestamp, allocation.points, allocation.claimed, allocation.numberOfWeeks) > 0) {\n            claimedUpdated = _claim(account, allocation.points, allocation.claimed, allocation.numberOfWeeks);\n        }\n        uint256 userAllocation = (allocation.points * totalAllocation) / TOTAL_POINTS;\n        uint256 _unclaimed = userAllocation - claimedUpdated;\n        uint256 preclaimed = allocation.preclaimed;\n        uint256 maxTotalPreclaim = (maxTotalPreclaimPct * userAllocation) / 100;\n        uint256 leftToPreclaim = maxTotalPreclaim - preclaimed;\n        if (amount == 0) amount = leftToPreclaim > _unclaimed ? _unclaimed : leftToPreclaim;\n        else if (preclaimed + amount > maxTotalPreclaim || amount > _unclaimed) revert PreclaimTooLarge();\n        allocations[account].claimed = uint128(claimedUpdated + amount);\n        allocations[account].preclaimed = uint96(preclaimed + amount);\n        vestingToken.transferFrom(vault, address(this), amount);\n        tokenLocker.lock(receiver, amount / lockToTokenRatio, 52);\n    }\n\n    /**\n     *\n     * @notice Claims accrued tokens\n     * @dev Can be delegated\n     * @param account Account to claim for\n     */\n    function claim(address account) external callerOrDelegated(account) {\n        AllocationState memory allocation = allocations[account];\n        _claim(account, allocation.points, allocation.claimed, allocation.numberOfWeeks);\n    }\n\n    // This function exists to avoid reloading the AllocationState struct in memory\n    function _claim(\n        address account,\n        uint256 points,\n        uint256 claimed,\n        uint256 numberOfWeeks\n    ) private returns (uint256 claimedUpdated) {\n        if (points == 0) revert NothingToClaim();\n        uint256 claimable = _claimableAt(block.timestamp, points, claimed, numberOfWeeks);\n        if (claimable == 0) revert NothingToClaim();\n        claimedUpdated = claimed + claimable;\n        allocations[account].claimed = uint128(claimedUpdated);\n        // We send to delegate for possible zaps\n        vestingToken.transferFrom(vault, msg.sender, claimable);\n    }\n\n    /**\n     * @notice Calculates number of tokens claimable by the user at the current block\n     * @param account Account to calculate for\n     * @return claimable Accrued tokens\n     */\n    function claimableNow(address account) external view returns (uint256 claimable) {\n        AllocationState memory allocation = allocations[account];\n        claimable = _claimableAt(block.timestamp, allocation.points, allocation.claimed, allocation.numberOfWeeks);\n    }\n\n    function _claimableAt(\n        uint256 when,\n        uint256 points,\n        uint256 claimed,\n        uint256 numberOfWeeks\n    ) private view returns (uint256) {\n        uint256 totalVested = _vestedAt(when, points, numberOfWeeks);\n        return totalVested > claimed ? totalVested - claimed : 0;\n    }\n\n    function _vestedAt(uint256 when, uint256 points, uint256 numberOfWeeks) private view returns (uint256 vested) {\n        if (vestingStart == 0 || numberOfWeeks == 0) return 0;\n        uint256 vestingWeeks = numberOfWeeks * 1 weeks;\n        uint256 vestingEnd = vestingStart + vestingWeeks;\n        uint256 endTime = when >= vestingEnd ? vestingEnd : when;\n        uint256 timeSinceStart = endTime - vestingStart;\n        vested = (totalAllocation * timeSinceStart * points) / (TOTAL_POINTS * vestingWeeks);\n    }\n\n    /**\n     * @notice Calculates the total number of tokens left unclaimed by the user including unvested ones\n     * @param account Account to calculate for\n     * @return Unclaimed tokens\n     */\n    function unclaimed(address account) external view returns (uint256) {\n        AllocationState memory allocation = allocations[account];\n        uint256 accountAllocation = (totalAllocation * allocation.points) / TOTAL_POINTS;\n        return accountAllocation - allocation.claimed;\n    }\n}"
    }
  ]
}