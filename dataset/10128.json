{
  "Title": "[M-02] Fee on transfer tokens can lead to incorrect approval",
  "Content": "_Submitted by hrkrshnn, also found by itsmeSTYJ_\n\n#### Fee on transfer tokens can lead to incorrect approval\n\nThe\n[createBasket](https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Factory.sol#L106)\nfunction does not account for tokens with fee on transfer.\n\n```solidity\nfunction createBasket(uint256 idNumber) external override returns (IBasket) {\n// ...\nfor (uint256 i = 0; i < bProposal.weights.length; i++) {\nIERC20 token = IERC20(bProposal.tokens[i]);\ntoken.safeTransferFrom(msg.sender, address(this), bProposal.weights[i]);\ntoken.safeApprove(address(newBasket), bProposal.weights[i]);\n}\n// ...\n}\n```\n\nThe function `safeTransferFrom` may not transfer exactly\n`bProposal.weights[i]` amount of tokens, for tokens with a fee on\ntransfer. This means that the `safeApprove` call in the next line would\nbe approving more tokens than what was received, leading to accounting\nissues.\n\n##### Recommended Mitigation Steps\n\nIt is recommended to find the balance of the current contract before and\nafter the `transferFrom` to see how much tokens were received, and\napprove only what was received.\n\n**[frank-beard (Kuiper) confirmed](https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/236#issuecomment-946911439):**\n> the protocol for now is only expected to work with defi safe, standard erc-20 tokens.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/236#issuecomment-984191431):**\n> This finding is similar to #206 , but in contrast to it, it shows a specific way to brick / grief the protocol, as per the docs:\n> ```\n> 2 â€” Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n> ```\n>\n> This is an hypothetical attack with stated assumptions\n>\n> Will not mark as duplicate and will consider this as a valid finding as it shows a specific vulnerability when paired with `feeOnTransfer` tokens\n>\n> Mitigation can be as simple as never using `feeOnTransfer` tokens\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2021-09-defiProtocol",
  "Code": [
    {
      "filename": "contracts/contracts/Factory.sol",
      "content": "pragma solidity =0.8.7;\n\nimport \"hardhat/console.sol\";\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { Clones } from \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"./interfaces/IAuction.sol\";\nimport \"./interfaces/IBasket.sol\";\nimport \"./interfaces/IFactory.sol\";\n\ncontract Factory is IFactory, Ownable {\n    using SafeERC20 for IERC20;\n\n    uint256 private constant BASE = 1e18;\n\n    constructor (IAuction _auctionImpl, IBasket _basketImpl) {\n        auctionImpl = _auctionImpl;\n        basketImpl = _basketImpl;\n        ownerSplit = 0;\n    }\n\n    Proposal[] private _proposals;\n\n    IAuction public override auctionImpl;\n    IBasket public override basketImpl;\n\n    uint256 public override minLicenseFee = 1e15; // 1e15 0.1%\n    uint256 public override auctionDecrement = 10000;\n    uint256 public override auctionMultiplier = 2;\n    uint256 public override bondPercentDiv = 400;\n    uint256 public override ownerSplit;\n\n    function proposal(uint256 proposalId) external override view returns (Proposal memory) {\n        return _proposals[proposalId];\n    }\n\n    function setMinLicenseFee(uint256 newMinLicenseFee) public override onlyOwner {\n        minLicenseFee = newMinLicenseFee;\n    }\n\n    function setAuctionDecrement(uint256 newAuctionDecrement) public override onlyOwner {\n        auctionDecrement = newAuctionDecrement;\n    }\n\n    function setAuctionMultiplier(uint256 newAuctionMultiplier) public override onlyOwner {\n        auctionMultiplier = newAuctionMultiplier;\n    }\n\n    function setBondPercentDiv(uint256 newBondPercentDiv) public override onlyOwner {\n        bondPercentDiv = newBondPercentDiv;\n    }\n\n    function setOwnerSplit(uint256 newOwnerSplit) public override onlyOwner {\n        require(newOwnerSplit <= 2e17); // 20%\n\n        ownerSplit = newOwnerSplit;\n    }\n\n    function getProposalWeights(uint256 id) external override view returns (address[] memory, uint256[] memory) {\n        return (_proposals[id].tokens, _proposals[id].weights);\n    }\n\n    function proposeBasketLicense(\n        uint256 licenseFee, \n        string memory tokenName, \n        string memory tokenSymbol, \n        address[] memory tokens,\n        uint256[] memory weights\n    ) public override returns (uint256 id) {\n        basketImpl.validateWeights(tokens, weights);\n\n        require(licenseFee >= minLicenseFee);\n\n        // create proposal object\n        Proposal memory proposal = Proposal({\n            licenseFee: licenseFee,\n            tokenName: tokenName,\n            tokenSymbol: tokenSymbol,\n            proposer: address(msg.sender),\n            tokens: tokens,\n            weights: weights,\n            basket: address(0)\n        });\n\n        emit BasketLicenseProposed(msg.sender, tokenName);\n        _proposals.push(proposal);\n\n        return _proposals.length - 1;\n    }\n\n    function createBasket(uint256 idNumber) external override returns (IBasket) {\n        Proposal memory bProposal = _proposals[idNumber];\n        require(bProposal.basket == address(0));\n\n        IAuction newAuction = IAuction(Clones.clone(address(auctionImpl)));\n        IBasket newBasket = IBasket(Clones.clone(address(basketImpl)));\n\n        newAuction.initialize(address(newBasket), address(this));\n        newBasket.initialize(bProposal, newAuction);\n\n        for (uint256 i = 0; i < bProposal.weights.length; i++) {\n            IERC20 token = IERC20(bProposal.tokens[i]);\n            token.safeTransferFrom(msg.sender, address(this), bProposal.weights[i]);\n            token.safeApprove(address(newBasket), bProposal.weights[i]);\n        }\n\n        newBasket.mintTo(BASE, msg.sender);\n\n        _proposals[idNumber].basket = address(newBasket);\n\n        emit BasketCreated(address(newBasket));\n\n        return newBasket;\n    }\n}"
    }
  ]
}