{
  "Title": "[37] Redundant return of the nonce deployed",
  "Content": "\n### Proof of Concept\n\nTake a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/system-contracts/contracts/NonceHolder.sol#L122-L131\n\n```solidity\n    function getDeploymentNonce(address _address) external view returns (uint256 deploymentNonce) {\n        uint256 addressAsKey = uint256(uint160(_address));\n        (deploymentNonce, ) = _splitRawNonce(rawNonces[addressAsKey]);\n\n        return deploymentNonce;\n    }\n```\n\nFunction is returning the deployment nonce for the accounts used with the CREATE opcode, case with this is that the variable to be returned is already named, but execution still passes a `return`\n\n### Impact\n\nRedundant code, bad structure.\n\n### Recommended Mitigation Steps\n\nAlways remove redundant code from production code.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-03-zksync",
  "Code": [
    {
      "filename": "code/system-contracts/contracts/NonceHolder.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.20;\n\nimport {INonceHolder} from \"./interfaces/INonceHolder.sol\";\nimport {IContractDeployer} from \"./interfaces/IContractDeployer.sol\";\nimport {ISystemContract} from \"./interfaces/ISystemContract.sol\";\nimport {DEPLOYER_SYSTEM_CONTRACT} from \"./Constants.sol\";\n\n/**\n * @author Matter Labs\n * @custom:security-contact security@matterlabs.dev\n * @notice A contract used for managing nonces for accounts. Together with bootloader,\n * this contract ensures that the pair (sender, nonce) is always unique, ensuring\n * unique transaction hashes.\n * @dev The account allows for both ascending growth in nonces and mapping nonces to specific\n * stored values in them.\n * The users can mark a range of nonces by increasing the `minNonce`. This way all the nonces\n * less than `minNonce` will become used. The other way to mark a certain 256-bit key as nonce is to set\n * some value under it in this contract.\n * @dev Apart from transaction nonces, this contract also stores the deployment nonce for accounts, that\n * will be used for address derivation using CREATE. For the economy of space, this nonce is stored tightly\n * packed with the `minNonce`.\n * @dev The behavior of some of the methods depends on the nonce ordering of the account. Nonce ordering is a mere suggestion and all the checks that are present\n * here serve more as a help to users to prevent from doing mistakes, rather than any invariants.\n */\ncontract NonceHolder is INonceHolder, ISystemContract {\n    uint256 private constant DEPLOY_NONCE_MULTIPLIER = 2 ** 128;\n    /// The minNonce can be increased by 2^32 at a time to prevent it from\n    /// overflowing beyond 2**128.\n    uint256 private constant MAXIMAL_MIN_NONCE_INCREMENT = 2 ** 32;\n\n    /// RawNonces for accounts are stored in format\n    /// minNonce + 2^128 * deploymentNonce, where deploymentNonce\n    /// is the nonce used for deploying smart contracts.\n    mapping(uint256 account => uint256 packedMinAndDeploymentNonce) internal rawNonces;\n\n    /// Mapping of values under nonces for accounts.\n    /// The main key of the mapping is the 256-bit address of the account, while the\n    /// inner mapping is a mapping from a nonce to the value stored there.\n    mapping(uint256 account => mapping(uint256 nonceKey => uint256 value)) internal nonceValues;\n\n    /// @notice Returns the current minimal nonce for account.\n    /// @param _address The account to return the minimal nonce for\n    /// @return The current minimal nonce for this account.\n    function getMinNonce(address _address) public view returns (uint256) {\n        uint256 addressAsKey = uint256(uint160(_address));\n        (, uint256 minNonce) = _splitRawNonce(rawNonces[addressAsKey]);\n\n        return minNonce;\n    }\n\n    /// @notice Returns the raw version of the current minimal nonce\n    /// @dev It is equal to minNonce + 2^128 * deployment nonce.\n    /// @param _address The account to return the raw nonce for\n    /// @return The raw nonce for this account.\n    function getRawNonce(address _address) public view returns (uint256) {\n        uint256 addressAsKey = uint256(uint160(_address));\n        return rawNonces[addressAsKey];\n    }\n\n    /// @notice Increases the minimal nonce for the msg.sender and returns the previous one.\n    /// @param _value The number by which to increase the minimal nonce for msg.sender.\n    /// @return oldMinNonce The value of the minimal nonce for msg.sender before the increase.\n    function increaseMinNonce(uint256 _value) public onlySystemCall returns (uint256 oldMinNonce) {\n        require(_value <= MAXIMAL_MIN_NONCE_INCREMENT, \"The value for incrementing the nonce is too high\");\n\n        uint256 addressAsKey = uint256(uint160(msg.sender));\n        uint256 oldRawNonce = rawNonces[addressAsKey];\n\n        unchecked {\n            rawNonces[addressAsKey] = (oldRawNonce + _value);\n        }\n\n        (, oldMinNonce) = _splitRawNonce(oldRawNonce);\n    }\n\n    /// @notice Sets the nonce value `key` for the msg.sender as used.\n    /// @param _key The nonce key under which the value will be set.\n    /// @param _value The value to store under the _key.\n    /// @dev The value must be non-zero.\n    function setValueUnderNonce(uint256 _key, uint256 _value) public onlySystemCall {\n        IContractDeployer.AccountInfo memory accountInfo = DEPLOYER_SYSTEM_CONTRACT.getAccountInfo(msg.sender);\n\n        require(_value != 0, \"Nonce value cannot be set to 0\");\n        // If an account has sequential nonce ordering, we enforce that the previous\n        // nonce has already been used.\n        if (accountInfo.nonceOrdering == IContractDeployer.AccountNonceOrdering.Sequential && _key != 0) {\n            require(isNonceUsed(msg.sender, _key - 1), \"Previous nonce has not been used\");\n        }\n\n        uint256 addressAsKey = uint256(uint160(msg.sender));\n\n        nonceValues[addressAsKey][_key] = _value;\n\n        emit ValueSetUnderNonce(msg.sender, _key, _value);\n    }\n\n    /// @notice Gets the value stored under a custom nonce for msg.sender.\n    /// @param _key The key under which to get the stored value.\n    /// @return The value stored under the `_key` for the msg.sender.\n    function getValueUnderNonce(uint256 _key) public view returns (uint256) {\n        uint256 addressAsKey = uint256(uint160(msg.sender));\n        return nonceValues[addressAsKey][_key];\n    }\n\n    /// @notice A convenience method to increment the minimal nonce if it is equal\n    /// to the `_expectedNonce`.\n    /// @param _expectedNonce The expected minimal nonce for the account.\n    function incrementMinNonceIfEquals(uint256 _expectedNonce) external onlySystemCall {\n        uint256 addressAsKey = uint256(uint160(msg.sender));\n        uint256 oldRawNonce = rawNonces[addressAsKey];\n\n        (, uint256 oldMinNonce) = _splitRawNonce(oldRawNonce);\n        require(oldMinNonce == _expectedNonce, \"Incorrect nonce\");\n\n        unchecked {\n            rawNonces[addressAsKey] = oldRawNonce + 1;\n        }\n    }\n\n    /// @notice Returns the deployment nonce for the accounts used for CREATE opcode.\n    /// @param _address The address to return the deploy nonce of.\n    /// @return deploymentNonce The deployment nonce of the account.\n    function getDeploymentNonce(address _address) external view returns (uint256 deploymentNonce) {\n        uint256 addressAsKey = uint256(uint160(_address));\n        (deploymentNonce, ) = _splitRawNonce(rawNonces[addressAsKey]);\n\n        return deploymentNonce;\n    }\n\n    /// @notice Increments the deployment nonce for the account and returns the previous one.\n    /// @param _address The address of the account which to return the deploy nonce for.\n    /// @return prevDeploymentNonce The deployment nonce at the time this function is called.\n    function incrementDeploymentNonce(address _address) external returns (uint256 prevDeploymentNonce) {\n        require(\n            msg.sender == address(DEPLOYER_SYSTEM_CONTRACT),\n            \"Only the contract deployer can increment the deployment nonce\"\n        );\n        uint256 addressAsKey = uint256(uint160(_address));\n        uint256 oldRawNonce = rawNonces[addressAsKey];\n\n        unchecked {\n            rawNonces[addressAsKey] = (oldRawNonce + DEPLOY_NONCE_MULTIPLIER);\n        }\n\n        (prevDeploymentNonce, ) = _splitRawNonce(oldRawNonce);\n    }\n\n    /// @notice A method that checks whether the nonce has been used before.\n    /// @param _address The address the nonce of which is being checked.\n    /// @param _nonce The nonce value which is checked.\n    /// @return `true` if the nonce has been used, `false` otherwise.\n    function isNonceUsed(address _address, uint256 _nonce) public view returns (bool) {\n        uint256 addressAsKey = uint256(uint160(_address));\n        return (_nonce < getMinNonce(_address) || nonceValues[addressAsKey][_nonce] > 0);\n    }\n\n    /// @notice Checks and reverts based on whether the nonce is used (not used).\n    /// @param _address The address the nonce of which is being checked.\n    /// @param _key The nonce value which is tested.\n    /// @param _shouldBeUsed The flag for the method. If `true`, the method checks that whether this nonce\n    /// is marked as used and reverts if this is not the case. If `false`, this method will check that the nonce\n    /// has *not* been used yet, and revert otherwise.\n    /// @dev This method should be used by the bootloader.\n    function validateNonceUsage(address _address, uint256 _key, bool _shouldBeUsed) external view {\n        bool isUsed = isNonceUsed(_address, _key);\n\n        if (isUsed && !_shouldBeUsed) {\n            revert(\"Reusing the same nonce twice\");\n        } else if (!isUsed && _shouldBeUsed) {\n            revert(\"The nonce was not set as used\");\n        }\n    }\n\n    /// @notice Splits the raw nonce value into the deployment nonce and the minimal nonce.\n    /// @param _rawMinNonce The value of the raw minimal nonce (equal to minNonce + deploymentNonce* 2**128).\n    /// @return deploymentNonce and minNonce.\n    function _splitRawNonce(uint256 _rawMinNonce) internal pure returns (uint256 deploymentNonce, uint256 minNonce) {\n        deploymentNonce = _rawMinNonce / DEPLOY_NONCE_MULTIPLIER;\n        minNonce = _rawMinNonce % DEPLOY_NONCE_MULTIPLIER;\n    }\n}"
    }
  ]
}