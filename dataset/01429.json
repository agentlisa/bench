{
  "Title": "M-18: Slashing during `LSTCalculatorBase.sol` deployment can show bad apr for months",
  "Content": "# Issue M-18: Slashing during `LSTCalculatorBase.sol` deployment can show bad apr for months \n\nSource: https://github.com/sherlock-audit/2023-06-tokemak-judging/issues/824 \n\n## Found by \ncarrotsmuggler, saidam017, xiaoming90\n\nSlashing during `LSTCalculatorBase.sol` deployment can show bad apr for months\n\n## Vulnerability Detail\n\nThe contract `LSTCalculatorBase.sol` has some functions to calculate the rough APR expected from a liquid staking token. The contract is first deployed, and the first snapshot is taken after `APR_FILTER_INIT_INTERVAL_IN_SEC`, which is 9 days. It then calculates the APR between the deployment and this first snapshot, and uses that to initialize the APR value. It uses the function `calculateAnnualizedChangeMinZero` to do this calculation.\n\nThe issue is that the function `calculateAnnualizedChangeMinZero` has a floor of 0. So if the backing of the LST decreases over that 9 days due to a slashing event in that interval, this function will return 0, and the initial APR and `baseApr` will be set to 0.\n\nThe calculator is designed to update the APR at regular intervals of 3 days. However, the new apr is given a weight of 10% and the older apr is given a weight of 90% as seen below.\n\n```solidity\nreturn ((priorValue * (1e18 - alpha)) + (currentValue * alpha)) / 1e18;\n```\n\nAnd alpha is hardcoded to 0.1. So if the initial APR starts at 0 due to a slashing event in the initial 9 day period, a large number of updates will be required to bring the APR up to the correct value.\n\nAssuming the correct APR of 6%, and an initial APR of 0%, we can calculate that it takes upto 28 updates to reflect close the correct APR. This transaltes to 84 days. So the wrong APR cann be shown for upto 3 months. Tha protocol uses these APR values to justify the allocation to the various protocols. Thus a wrong APR for months would mean the protocol would sub optimally allocate funds for months, losing potential yield.\n\n## Impact\n\nThe protocol can underperform for months due to slashing events messing up APR calculations close to deployment date.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-06-tokemak/blob/main/v2-core-audit-2023-07-14/src/stats/calculators/base/LSTCalculatorBase.sol#L108-L110\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIt is recommended to initialize the APR with a specified value, rather than calculate it over the initial 9 days. 9 day window is not good enough to get an accurate APR, and can be easily manipulated by a slashing event.\n\n\n\n## Discussion\n\n**codenutt**\n\nThis behavior is acceptable. If we happen to see a slash > 12 bps over the initial 9 days, yes, we set it to 0. It increases the ramp time for that LST so pools with that LST will be set aside for a while until some APR (incentive, etc) comes up. For larger slashes that are more material (> 25bps), we have a 90 day penalty anyway.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/101",
  "Code": [
    {
      "filename": "v2-core-audit-2023-07-14/src/stats/calculators/base/LSTCalculatorBase.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// Copyright (c) 2023 Tokemak Foundation. All rights reserved.\npragma solidity 0.8.17;\n\nimport { BaseStatsCalculator } from \"src/stats/calculators/base/BaseStatsCalculator.sol\";\nimport { Initializable } from \"openzeppelin-contracts/proxy/utils/Initializable.sol\";\nimport { ILSTStats } from \"src/interfaces/stats/ILSTStats.sol\";\nimport { IStatsCalculator } from \"src/interfaces/stats/IStatsCalculator.sol\";\nimport { ISystemRegistry } from \"src/interfaces/ISystemRegistry.sol\";\nimport { Stats } from \"src/stats/Stats.sol\";\nimport { SecurityBase } from \"src/security/SecurityBase.sol\";\nimport { IRootPriceOracle } from \"src/interfaces/oracles/IRootPriceOracle.sol\";\n\nabstract contract LSTCalculatorBase is ILSTStats, BaseStatsCalculator, Initializable {\n    /// @notice time in seconds between apr snapshots\n    uint256 public constant APR_SNAPSHOT_INTERVAL_IN_SEC = 3 * 24 * 60 * 60; // 3 days\n\n    /// @notice time in seconds for the initialization period\n    uint256 public constant APR_FILTER_INIT_INTERVAL_IN_SEC = 9 * 24 * 60 * 60; // 9 days\n\n    /// @notice time in seconds between slashing snapshots\n    uint256 public constant SLASHING_SNAPSHOT_INTERVAL_IN_SEC = 24 * 60 * 60; // 1 day\n\n    /// @notice alpha for filter\n    uint256 public constant ALPHA = 1e17; // 0.1; must be 0 < x <= 1e18\n\n    /// @notice lstTokenAddress is the address for the LST that the stats are for\n    address public lstTokenAddress;\n\n    /// @notice ethPerToken at the last snapshot for base apr\n    uint256 public lastBaseAprEthPerToken;\n\n    /// @notice timestamp of the last snapshot for base apr\n    uint256 public lastBaseAprSnapshotTimestamp;\n\n    /// @notice ethPerToken at the last snapshot for slashing events\n    uint256 public lastSlashingEthPerToken;\n\n    /// @notice timestamp of the last snapshot for base apr\n    uint256 public lastSlashingSnapshotTimestamp;\n\n    /// @notice filtered base apr\n    uint256 public baseApr;\n\n    /// @notice indicates if baseApr filter is initialized\n    bool public baseAprFilterInitialized;\n\n    /// @notice list of slashing costs (slashing / value at the time)\n    uint256[] public slashingCosts;\n\n    /// @notice list of timestamps associated with slashing events\n    uint256[] public slashingTimestamps;\n\n    bytes32 private _aprId;\n\n    struct InitData {\n        address lstTokenAddress;\n    }\n\n    event BaseAprSnapshotTaken(\n        uint256 priorEthPerToken,\n        uint256 priorTimestamp,\n        uint256 currentEthPerToken,\n        uint256 currentTimestamp,\n        uint256 priorBaseApr,\n        uint256 currentBaseApr\n    );\n\n    event SlashingSnapshotTaken(\n        uint256 priorEthPerToken, uint256 priorTimestamp, uint256 currentEthPerToken, uint256 currentTimestamp\n    );\n\n    event SlashingEventRecorded(uint256 slashingCost, uint256 slashingTimestamp);\n\n    constructor(ISystemRegistry _systemRegistry) BaseStatsCalculator(_systemRegistry) { }\n\n    /// @inheritdoc IStatsCalculator\n    function initialize(bytes32[] calldata, bytes calldata initData) external override initializer {\n        InitData memory decodedInitData = abi.decode(initData, (InitData));\n        lstTokenAddress = decodedInitData.lstTokenAddress;\n        _aprId = Stats.generateRawTokenIdentifier(lstTokenAddress);\n\n        uint256 currentEthPerToken = calculateEthPerToken();\n        lastBaseAprEthPerToken = currentEthPerToken;\n        lastBaseAprSnapshotTimestamp = block.timestamp;\n        baseAprFilterInitialized = false;\n        lastSlashingEthPerToken = currentEthPerToken;\n        lastSlashingSnapshotTimestamp = block.timestamp;\n    }\n\n    /// @inheritdoc IStatsCalculator\n    function getAddressId() external view returns (address) {\n        return lstTokenAddress;\n    }\n\n    /// @inheritdoc IStatsCalculator\n    function getAprId() external view returns (bytes32) {\n        return _aprId;\n    }\n\n    function _snapshot() internal override {\n        uint256 currentEthPerToken = calculateEthPerToken();\n        if (_timeForAprSnapshot()) {\n            uint256 currentApr = Stats.calculateAnnualizedChangeMinZero(\n                lastBaseAprSnapshotTimestamp, lastBaseAprEthPerToken, block.timestamp, currentEthPerToken\n            );\n            uint256 newBaseApr;\n            if (baseAprFilterInitialized) {\n                newBaseApr = Stats.getFilteredValue(ALPHA, baseApr, currentApr);\n            } else {\n                // Speed up the baseApr filter ramp\n                newBaseApr = currentApr;\n                baseAprFilterInitialized = true;\n            }\n\n            emit BaseAprSnapshotTaken(\n                lastBaseAprEthPerToken,\n                lastBaseAprSnapshotTimestamp,\n                currentEthPerToken,\n                block.timestamp,\n                baseApr,\n                newBaseApr\n            );\n\n            baseApr = newBaseApr;\n            lastBaseAprEthPerToken = currentEthPerToken;\n            lastBaseAprSnapshotTimestamp = block.timestamp;\n        }\n\n        if (_hasSlashingOccurred(currentEthPerToken)) {\n            uint256 cost = Stats.calculateUnannualizedNegativeChange(lastSlashingEthPerToken, currentEthPerToken);\n            slashingCosts.push(cost);\n            slashingTimestamps.push(block.timestamp);\n\n            emit SlashingEventRecorded(cost, block.timestamp);\n            emit SlashingSnapshotTaken(\n                lastSlashingEthPerToken, lastSlashingSnapshotTimestamp, currentEthPerToken, block.timestamp\n            );\n\n            lastSlashingEthPerToken = currentEthPerToken;\n            lastSlashingSnapshotTimestamp = block.timestamp;\n        } else if (_timeForSlashingSnapshot()) {\n            emit SlashingSnapshotTaken(\n                lastSlashingEthPerToken, lastSlashingSnapshotTimestamp, currentEthPerToken, block.timestamp\n            );\n            lastSlashingEthPerToken = currentEthPerToken;\n            lastSlashingSnapshotTimestamp = block.timestamp;\n        }\n    }\n\n    /// @inheritdoc IStatsCalculator\n    function shouldSnapshot() public view override returns (bool) {\n        uint256 currentEthPerToken = calculateEthPerToken();\n        if (_timeForAprSnapshot()) {\n            return true;\n        }\n\n        if (_hasSlashingOccurred(currentEthPerToken)) {\n            return true;\n        }\n\n        if (_timeForSlashingSnapshot()) {\n            return true;\n        }\n\n        return false;\n    }\n\n    function _timeForAprSnapshot() private view returns (bool) {\n        if (baseAprFilterInitialized) {\n            // slither-disable-next-line timestamp\n            return block.timestamp >= lastBaseAprSnapshotTimestamp + APR_SNAPSHOT_INTERVAL_IN_SEC;\n        } else {\n            // slither-disable-next-line timestamp\n            return block.timestamp >= lastBaseAprSnapshotTimestamp + APR_FILTER_INIT_INTERVAL_IN_SEC;\n        }\n    }\n\n    function _timeForSlashingSnapshot() private view returns (bool) {\n        // slither-disable-next-line timestamp\n        return block.timestamp >= lastSlashingSnapshotTimestamp + SLASHING_SNAPSHOT_INTERVAL_IN_SEC;\n    }\n\n    function _hasSlashingOccurred(uint256 currentEthPerToken) private view returns (bool) {\n        return currentEthPerToken < lastSlashingEthPerToken;\n    }\n\n    /// @inheritdoc ILSTStats\n    function current() external returns (LSTStatsData memory) {\n        uint256 lastSnapshotTimestamp;\n\n        // return the most recent snapshot timestamp\n        // the timestamp is used by the LMP to ensure that snapshots are occurring\n        // so it is indifferent to which snapshot has occurred\n        // slither-disable-next-line timestamp\n        if (lastBaseAprSnapshotTimestamp < lastSlashingSnapshotTimestamp) {\n            lastSnapshotTimestamp = lastSlashingSnapshotTimestamp;\n        } else {\n            lastSnapshotTimestamp = lastBaseAprSnapshotTimestamp;\n        }\n\n        IRootPriceOracle pricer = systemRegistry.rootPriceOracle();\n        uint256 price = pricer.getPriceInEth(lstTokenAddress);\n\n        // result is 1e18\n        uint256 priceToBacking;\n        if (isRebasing()) {\n            priceToBacking = price;\n        } else {\n            uint256 backing = calculateEthPerToken();\n            // price is always 1e18 and backing is in eth, which is 1e18\n            priceToBacking = price * 1e18 / backing;\n        }\n\n        // positive value is a premium; negative value is a discount\n        int256 premium = int256(priceToBacking) - 1e18;\n\n        return LSTStatsData({\n            lastSnapshotTimestamp: lastSnapshotTimestamp,\n            baseApr: baseApr,\n            premium: premium,\n            slashingCosts: slashingCosts,\n            slashingTimestamps: slashingTimestamps\n        });\n    }\n\n    /// @inheritdoc ILSTStats\n    function calculateEthPerToken() public view virtual returns (uint256);\n\n    /// @inheritdoc ILSTStats\n    function isRebasing() public view virtual returns (bool);\n}"
    }
  ]
}