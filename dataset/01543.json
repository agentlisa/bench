{
  "Title": "Double voting in `Bootstrap.vy` in case of violation of time intervals",
  "Content": "##### Description\n\n- https://github.com/yearn/yETH-bootstrap/blob/2dd219d3af49952275934638e8c9d50d0fef0d8f/contracts/Bootstrap.vy#L423\n\nThe Bootstrap contract is deployed by the owner setting key periods using the following functions: \n- set_whitelist_period()\n- set_incentive_period()\n- set_deposit_period()\n- set_vote_period()\n- set_lock_end()\n\nThere is a scenario in which the `deposit_end` and `vote_end` parameters in the `Bootstrap` contract end up being higher than `lock_end`. This can happen, for example, if the management initially sets the correct values for the time intervals but later decides to manually extend the voting by calling `set_deposit_period()` and `set_vote_period()` with increased values, forgetting to also call `set_lock_end()`.\n\nCalling `set_deposit_period()` with increased values will work without an error because requirement `_begin >= self.whitelist_begin` will be satisfied. Calling `set_vote_period()` with increased values will also work without an error because condition `_begin >= self.deposit_begin` will be satisfied.\n\nIf `deposit_end` and `vote_end` are increased enough to be higher than `lock_end`, a hacker can call `claim()` to withdraw their funds in styETH, sell them for ETH, and vote again repeating this process multiple times. Potentially, it can be done with a flash loan if the hacker finds a place to sell styETH or yETH, for example, via a curve stable pool. By accumulating votes, the hacker can claim 99.99% of all incentives from winning projects.\n\n##### Recommendation\n\nIt is recommended to check invariant `vote_end < lock_end` in the `set_vote_period()` function.\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/Bootstrap.vy",
      "content": "# @version 0.3.7\n\"\"\"\n@title yETH bootstrap\n@author 0xkorin, Yearn Finance\n@license Copyright (c) Yearn Finance, 2023 - all rights reserved\n@notice \n    Implements the bootstrap phase as outlined in YIP-72, summarized:\n    Contract defines multiple periods\n        - Whitelist period: LSD protocols apply to be whitelisted by depositing 1 ETH\n        - Deposit period: anyone can deposit ETH, which mints st-yETH 1:1 locked into the contract\n        - Incentive period: anyone is able to incentivize voting for a whitelisted protocol by depositing tokens\n        - Vote period: depositors are able to vote on their preferred whitelisted protocol\n    After the vote period up to 5 protocols are declared as winner.\n    Incentives for winning protocols will be distributed over all voters according to their overall vote weight, \n    regardless whether they voted for that specific protocol or not.\n    Protocols that do not win will have their incentives refunded.\n    10% of deposited ETH is sent to the POL.\n    90% of deposited ETH is used to buy LSDs and deposit into the newly deployed yETH pool.\n    The minted yETH is used to pay off 90% of the debt in the bootstrap contract.\n    Depositor's st-yETH become withdrawable after a specific time.\n\"\"\"\n\nfrom vyper.interfaces import ERC20\n\ninterface Token:\n    def mint(_account: address, _amount: uint256): nonpayable\n    def burn(_account: address, _amount: uint256): nonpayable\n\ninterface Staking:\n    def deposit(_assets: uint256) -> uint256: nonpayable\n\ntoken: public(immutable(address))\nstaking: public(immutable(address))\ntreasury: public(immutable(address))\npol: public(immutable(address))\nmanagement: public(address)\npending_management: public(address)\n\napplications: HashMap[address, uint256]\ndebt: public(uint256)\ndeposited: public(uint256)\ndeposits: public(HashMap[address, uint256]) # user => amount deposited\nincentives: public(HashMap[address, HashMap[address, uint256]]) # protocol => incentive => amount\nincentive_depositors: public(HashMap[address, HashMap[address, HashMap[address, uint256]]]) # protocol => incentive => depositor => amount\nvoted: public(uint256)\nvotes_used: public(HashMap[address, uint256]) # user => votes used\nvotes: public(HashMap[address, uint256]) # protocol => votes\nwinners_list: public(DynArray[address, MAX_WINNERS])\nwinners: public(HashMap[address, bool]) # protocol => winner?\nincentive_claimed: public(HashMap[address, HashMap[address, HashMap[address, bool]]]) # winner => incentive => user => claimed?\n\nwhitelist_begin: public(uint256)\nwhitelist_end: public(uint256)\nincentive_begin: public(uint256)\nincentive_end: public(uint256)\ndeposit_begin: public(uint256)\ndeposit_end: public(uint256)\nvote_begin: public(uint256)\nvote_end: public(uint256)\nlock_end: public(uint256)\n\nevent Apply:\n    protocol: indexed(address)\n\nevent Whitelist:\n    protocol: indexed(address)\n\nevent Incentivize:\n    protocol: indexed(address)\n    incentive: indexed(address)\n    depositor: indexed(address)\n    amount: uint256\n\nevent Deposit:\n    depositor: indexed(address)\n    receiver: indexed(address)\n    amount: uint256\n\nevent Claim:\n    claimer: indexed(address)\n    receiver: indexed(address)\n    amount: uint256\n\nevent Vote:\n    voter: indexed(address)\n    protocol: indexed(address)\n    amount: uint256\n\nevent Repay:\n    payer: indexed(address)\n    amount: uint256\n\nevent Split:\n    amount: uint256\n\nevent ClaimIncentive:\n    protocol: indexed(address)\n    incentive: indexed(address)\n    claimer: indexed(address)\n    amount: uint256\n\nevent RefundIncentive:\n    protocol: indexed(address)\n    incentive: indexed(address)\n    depositor: indexed(address)\n    amount: uint256\n\nevent SetPeriod:\n    period: indexed(uint256)\n    begin: uint256\n    end: uint256\n\nevent Winners:\n    winners: DynArray[address, MAX_WINNERS]\n\nevent PendingManagement:\n    management: indexed(address)\n\nevent SetManagement:\n    management: indexed(address)\n\nNOTHING: constant(uint256) = 0\nAPPLIED: constant(uint256) = 1\nWHITELISTED: constant(uint256) = 2\nPOL_SPLIT: constant(uint256) = 10\nMAX_WINNERS: constant(uint256) = 5\n\n@external\ndef __init__(_token: address, _staking: address, _treasury: address, _pol: address):\n    \"\"\"\n    @notice Constructor\n    @param _token yETH token address\n    @param _staking st-yETH token address\n    @param _treasury Treasury address\n    @param _pol POL address\n    \"\"\"\n    token = _token\n    staking = _staking\n    treasury = _treasury\n    pol = _pol\n    self.management = msg.sender\n    assert ERC20(token).approve(_staking, max_value(uint256), default_return_value=True)\n\n@external\n@payable\ndef __default__():\n    \"\"\"\n    @notice Send ETH in exchange for 1:1 locked st-yETH\n    \"\"\"\n    self._deposit(msg.sender)\n\n@external\n@payable\ndef apply(_protocol: address):\n    \"\"\"\n    @notice\n        As a LSD protocol apply to be whitelisted for potential inclusion into the yETH pool.\n        Requires an application fee of 1 ETH to be sent along with the call\n    @param _protocol The LSD protocol token address\n    \"\"\"\n    assert msg.value == 1_000_000_000_000_000_000 # dev: application fee\n    assert block.timestamp >= self.whitelist_begin and block.timestamp < self.whitelist_end # dev: outside application period\n    assert self.applications[_protocol] == NOTHING # dev: already applied\n    self.applications[_protocol] = APPLIED\n    log Apply(_protocol)\n\n@external\ndef incentivize(_protocol: address, _incentive: address, _amount: uint256):\n    \"\"\"\n    @notice\n        Incentivize depositors to vote on a specific protocol.\n        Deposited incentives are refunded if the protocol does not receive sufficient votes to be included in the yETH pool\n    @param _protocol The LSD protocol address\n    @param _incentive The incentive token address\n    @param _amount The amount of tokens to deposit as incentive\n    \"\"\"\n    assert _amount > 0\n    assert block.timestamp >= self.incentive_begin and block.timestamp < self.incentive_end # dev: outside incentive period\n    assert self.applications[_protocol] == WHITELISTED # dev: not whitelisted\n    self.incentives[_protocol][_incentive] += _amount\n    self.incentive_depositors[_protocol][_incentive][msg.sender] += _amount\n    assert ERC20(_incentive).transferFrom(msg.sender, self, _amount, default_return_value=True)\n    log Incentivize(_protocol, _incentive, msg.sender, _amount)\n\n@external\n@payable\ndef deposit(_account: address = msg.sender):\n    \"\"\"\n    @notice Deposit ETH in exchange for 1:1 locked st-yETH\n    @param _account Deposit on behalf of this account\n    \"\"\"\n    self._deposit(_account)\n\n@internal\n@payable\ndef _deposit(_account: address):\n    \"\"\"\n    @notice Deposit ETH in exchange for 1:1 locked st-yETH\n    @param _account Deposit on behalf of this account\n    \"\"\"\n    assert msg.value > 0\n    assert block.timestamp >= self.deposit_begin and block.timestamp < self.deposit_end # dev: outside deposit period\n    assert self.lock_end > 0\n    self.debt += msg.value\n    self.deposited += msg.value\n    self.deposits[_account] += msg.value\n    Token(token).mint(self, msg.value)\n    Staking(staking).deposit(msg.value)\n    log Deposit(msg.sender, _account, msg.value)\n\n@external\ndef claim(_amount: uint256, _receiver: address = msg.sender):\n    \"\"\"\n    @notice Claim st-yETH once the lock has expired\n    @param _amount Amount of tokens to claim\n    @param _receiver Account to transfer the tokens to\n    \"\"\"\n    assert _amount > 0\n    assert block.timestamp >= self.lock_end\n    self.deposited -= _amount\n    self.deposits[msg.sender] -= _amount\n    assert ERC20(staking).transfer(_receiver, _amount, default_return_value=True)\n    log Claim(msg.sender, _receiver, _amount)\n\n@external\n@view\ndef votes_available(_account: address) -> uint256:\n    \"\"\"\n    @notice Get the amount of available votes for a specific account\n    @param _account The account to query for\n    @return Amount of available votes\n    \"\"\"\n    if block.timestamp < self.vote_begin or block.timestamp >= self.vote_end:\n        return 0\n\n    return self.deposits[_account] - self.votes_used[_account]\n\n@external\ndef vote(_protocols: DynArray[address, 32], _votes: DynArray[uint256, 32]):\n    \"\"\"\n    @notice Vote for whitelisted protocols to be included into the pool\n    @param _protocols Protocols to vote for\n    @param _votes Amount of votes to allocate for each protocol\n    \"\"\"\n    assert len(_protocols) == len(_votes)\n    assert block.timestamp >= self.vote_begin and block.timestamp < self.vote_end # dev: outside vote period\n    used: uint256 = 0\n    for i in range(32):\n        if i == len(_protocols):\n            break\n        protocol: address = _protocols[i]\n        votes: uint256 = _votes[i]\n        assert self.applications[protocol] == WHITELISTED # dev: protocol not whitelisted\n        used += votes\n        self.votes[protocol] += votes\n        log Vote(msg.sender, protocol, votes)\n    self.voted += used\n    used += self.votes_used[msg.sender]\n    assert used <= self.deposits[msg.sender] # dev: too many votes\n    self.votes_used[msg.sender] = used\n\n@external\ndef repay(_amount: uint256):\n    \"\"\"\n    @notice Repay yETH debt by burning it\n    @param _amount Amount of debt to repay\n    \"\"\"\n    self.debt -= _amount\n    assert ERC20(token).transferFrom(msg.sender, self, _amount, default_return_value=True)\n    Token(token).burn(self, _amount)\n    log Repay(msg.sender, _amount)\n\n@external\ndef split():\n    \"\"\"\n    @notice Split deposited ETH 9:1 between treasury and POL\n    \"\"\"\n    assert msg.sender == self.management or msg.sender == treasury\n    amount: uint256 = self.balance\n    assert amount > 0\n    log Split(amount)\n    raw_call(pol, b\"\", value=amount/10)\n    amount -= amount/10\n    raw_call(treasury, b\"\", value=amount)\n\n@external\n@view\ndef claimable_incentive(_protocol: address, _incentive: address, _claimer: address) -> uint256:\n    \"\"\"\n    @notice Get the amount of claimable incentives\n    @param _protocol Address of the LSD protocol to claim incentives for\n    @param _incentive Incentive token to claim\n    @param _claimer Account to query for\n    @return Amount of claimable incentive tokens\n    \"\"\"\n    if not self.winners[_protocol] or self.incentive_claimed[_protocol][_incentive][_claimer]:\n        return 0\n    return self.incentives[_protocol][_incentive] * self.votes_used[_claimer] / self.voted\n\n@external\ndef claim_incentive(_protocol: address, _incentive: address, _claimer: address = msg.sender) -> uint256:\n    \"\"\"\n    @notice Claim a specific incentive\n    @param _protocol Address of the LSD protocol to claim incentives for\n    @param _incentive Incentive token to claim\n    @param _claimer Account to claim for\n    @return Amount of incentive tokens claimed\n    \"\"\"\n    assert self.winners[_protocol] # dev: protocol is not winner\n    assert not self.incentive_claimed[_protocol][_incentive][_claimer] # dev: incentive already claimed\n    \n    incentive: uint256 = self.incentives[_protocol][_incentive] * self.votes_used[_claimer] / self.voted\n    assert incentive > 0 # dev: nothing to claim\n\n    self.incentive_claimed[_protocol][_incentive][_claimer] = True\n    assert ERC20(_incentive).transfer(_claimer, incentive, default_return_value=True)\n    log ClaimIncentive(_protocol, _incentive, _claimer, incentive)\n    return incentive\n\n@external\ndef refund_incentive(_protocol: address, _incentive: address, _depositor: address = msg.sender) -> uint256:\n    \"\"\"\n    @notice Refund incentive for protocols that did not win\n    @param _protocol Address of the LSD protocol to refund incentives for\n    @param _incentive Incentive token to refund\n    @param _depositor Account that deposited the incentive\n    @return Amount of incentive tokens refunded\n    \"\"\"\n    assert len(self.winners_list) > 0 # dev: no winners declared\n    assert not self.winners[_protocol] # dev: protocol is winner\n\n    amount: uint256 = self.incentive_depositors[_protocol][_incentive][_depositor]\n    assert amount > 0 # dev: nothing to refund\n\n    self.incentive_depositors[_protocol][_incentive][_depositor] = 0\n    assert ERC20(_incentive).transfer(_depositor, amount, default_return_value=True)\n    log RefundIncentive(_protocol, _incentive, _depositor, amount)\n    return amount\n\n@external\n@view\ndef has_applied(_protocol: address) -> bool:\n    \"\"\"\n    @notice Check whether the LSD protocol has applied to be whitelisted\n    @param _protocol Address of the LSD protocol to query for\n    @return True if the protocol has applied, False if it has not yet applied\n    \"\"\"\n    return self.applications[_protocol] > NOTHING\n\n@external\n@view\ndef is_whitelisted(_protocol: address) -> bool:\n    \"\"\"\n    @notice Check whether the LSD protocol is whitelisted\n    @param _protocol Address of the LSD protocol to query for\n    @return True if the protocol is whitelisted, False if it has not been whitelisted\n    \"\"\"\n    return self.applications[_protocol] == WHITELISTED\n\n@external\n@view\ndef num_winners() -> uint256:\n    \"\"\"\n    @notice Get the number of declared winners\n    @return Number of declared winners\n    \"\"\"\n    return len(self.winners_list)\n\n# MANAGEMENT FUNCTIONS\n\n@external\ndef set_whitelist_period(_begin: uint256, _end: uint256):\n    \"\"\"\n    @notice Set the period during which protocols can apply to be whitelisted\n    @param _begin Timestamp of the beginning of the period\n    @param _end Timestamp of the end of the period\n    \"\"\"\n    assert msg.sender == self.management\n    assert _end > _begin\n    self.whitelist_begin = _begin\n    self.whitelist_end = _end\n    log SetPeriod(0, _begin,  _end)\n\n@external\ndef set_incentive_period(_begin: uint256, _end: uint256):\n    \"\"\"\n    @notice Set the period during which incentives can be deposited\n    @dev Not allowed to start before the whitelist period\n    @param _begin Timestamp of the beginning of the period\n    @param _end Timestamp of the end of the period\n    \"\"\"\n    assert msg.sender == self.management\n    assert _begin >= self.whitelist_begin\n    assert _end > _begin\n    self.incentive_begin = _begin\n    self.incentive_end = _end\n    log SetPeriod(1, _begin,  _end)\n\n@external\ndef set_deposit_period(_begin: uint256, _end: uint256):\n    \"\"\"\n    @notice Set the period during which users can deposit ETH for st-yETH\n    @dev Not allowed to start before the whitelist period\n    @param _begin Timestamp of the beginning of the period\n    @param _end Timestamp of the end of the period\n    \"\"\"\n    assert msg.sender == self.management\n    assert _begin >= self.whitelist_begin\n    assert _end > _begin\n    self.deposit_begin = _begin\n    self.deposit_end = _end\n    log SetPeriod(2, _begin,  _end)\n\n@external\ndef set_vote_period(_begin: uint256, _end: uint256):\n    \"\"\"\n    @notice Set the period during which depositors can vote for protocols\n    @dev Not allowed to start before the deposit period\n    @param _begin Timestamp of the beginning of the period\n    @param _end Timestamp of the end of the period\n    \"\"\"\n    assert msg.sender == self.management\n    assert _begin >= self.deposit_begin\n    assert _end > _begin\n    self.vote_begin = _begin\n    self.vote_end = _end\n    log SetPeriod(3, _begin, _end)\n\n@external\ndef set_lock_end(_end: uint256):\n    \"\"\"\n    @notice Set the time the st-yETH lock ends\n    @dev Not allowed to be before the end of the vote period\n    @param _end Timestamp of the end of the lock\n    \"\"\"\n    assert msg.sender == self.management\n    assert _end >= self.vote_end\n    self.lock_end = _end\n    log SetPeriod(4, 0, _end)\n\n@external\ndef whitelist(_protocol: address):\n    \"\"\"\n    @notice Whitelist a protocol \n    @param _protocol Address of the LSD protocol\n    \"\"\"\n    assert msg.sender == self.management\n    assert self.applications[_protocol] == APPLIED # dev: has not applied\n    self.applications[_protocol] = WHITELISTED\n    log Whitelist(_protocol)\n\n@external\ndef undo_whitelist(_protocol: address):\n    \"\"\"\n    @notice Undo a protocol whitelist. Should only be used in emergencies\n    @param _protocol Address of the LSD protocol\n    \"\"\"\n    assert msg.sender == self.management\n    assert self.applications[_protocol] == WHITELISTED # dev: not whitelisted\n    self.applications[_protocol] = APPLIED\n\n@external\ndef declare_winners(_winners: DynArray[address, MAX_WINNERS]):\n    \"\"\"\n    @notice Declare the winners of the vote\n    @param _winners Addresses of the LSD protocols\n    \"\"\"\n    assert msg.sender == self.management\n    assert block.timestamp >= self.vote_end\n    assert len(self.winners_list) == 0\n    for winner in _winners:\n        assert self.applications[winner] == WHITELISTED\n        assert not self.winners[winner]\n        self.winners_list.append(winner)\n        self.winners[winner] = True\n    log Winners(_winners)\n\n@external\ndef set_management(_management: address):\n    \"\"\"\n    @notice \n        Set the pending management address.\n        Needs to be accepted by that account separately to transfer management over\n    @param _management New pending management address\n    \"\"\"\n    assert msg.sender == self.management\n    self.pending_management = _management\n    log PendingManagement(_management)\n\n@external\ndef accept_management():\n    \"\"\"\n    @notice \n        Accept management role.\n        Can only be called by account previously marked as pending management by current management\n    \"\"\"\n    assert msg.sender == self.pending_management\n    self.pending_management = empty(address)\n    self.management = msg.sender\n    log SetManagement(msg.sender)"
    }
  ]
}