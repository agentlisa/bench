{
  "Title": "[H-14] `Redeemer.sol#redeem()` can be called by anyone before maturity, which may lead to loss of user funds",
  "Content": "_Submitted by WatchPug, also found by csanuragjain, datapunk, and Lambda_\n\n```solidity\nfunction redeem(\n    uint8 p,\n    address u,\n    uint256 m\n) public returns (bool) {\n    // Get the principal token that is being redeemed by the user\n    address principal = IMarketPlace(marketPlace).markets(u, m, p);\n\n    // Make sure we have the correct principal\n    if (\n        p != uint8(MarketPlace.Principals.Swivel) &&\n        p != uint8(MarketPlace.Principals.Element) &&\n        p != uint8(MarketPlace.Principals.Yield) &&\n        p != uint8(MarketPlace.Principals.Notional)\n    ) {\n        revert Invalid('principal');\n    }\n\n    // The amount redeemed should be the balance of the principal token held by the Illuminate contract\n    uint256 amount = IERC20(principal).balanceOf(lender);\n\n    // Transfer the principal token from the lender contract to here\n    Safe.transferFrom(IERC20(principal), lender, address(this), amount);\n\n    if (p == uint8(MarketPlace.Principals.Swivel)) {\n        // Redeems zc tokens to the sender's address\n        ISwivel(swivelAddr).redeemZcToken(u, m, amount);\n    } else if (p == uint8(MarketPlace.Principals.Element)) {\n        // Redeems principal tokens from element\n        IElementToken(principal).withdrawPrincipal(amount, marketPlace);\n    } else if (p == uint8(MarketPlace.Principals.Yield)) {\n        // Redeems prinicipal tokens from yield\n        IYieldToken(principal).redeem(address(this), address(this), amount);\n    } else if (p == uint8(MarketPlace.Principals.Notional)) {\n        // Redeems the principal token from notional\n        amount = INotional(principal).maxRedeem(address(this));\n    }\n\n    emit Redeem(p, u, m, amount);\n    return true;\n}\n```\n\nThere are some protocols (eg Notional) that allows redeem before maturity, when doing so, they will  actually make a market sell, usually means a discounted sale.\n\nSince `redeem()` is a public function, anyone can call it before maturity, and force the whole protocol to sell it's holdings at a discounted price, causing fund loss to the stake holders.\n\n<https://github.com/notional-finance/wrapped-fcash/blob/8f76be58dda648ea58eef863432c14c940e13900/contracts/wfCashERC4626.sol#L155-L169>\n\n```solidity\nfunction previewRedeem(uint256 shares) public view override returns (uint256 assets) {\n    if (hasMatured()) {\n        assets = convertToAssets(shares);\n    } else {\n        // If withdrawing non-matured assets, we sell them on the market (i.e. borrow)\n        (uint16 currencyId, uint40 maturity) = getDecodedID();\n        (assets, /* */, /* */, /* */) = NotionalV2.getPrincipalFromfCashBorrow(\n            currencyId,\n            shares,\n            maturity,\n            0,\n            block.timestamp\n        );\n    }\n}\n```\n\n#### Recommendation\n\nConsider only allow unauthenticated call after maturity.\n\n**[JTraversa (Illuminate) confirmed](https://github.com/code-423n4/2022-06-illuminate-findings/issues/347)**\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2022-06-illuminate",
  "Code": [
    {
      "filename": "contracts/wfCashERC4626.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./wfCashLogic.sol\";\nimport \"../interfaces/IERC4626.sol\";\n\ncontract wfCashERC4626 is IERC4626, wfCashLogic {\n    constructor(INotionalV2 _notional, WETH9 _weth) wfCashLogic(_notional, _weth) {}\n\n    /** @dev See {IERC4262-asset} */\n    function asset() public view override returns (address) {\n        (IERC20 underlyingToken, bool isETH) = getToken(true);\n        return isETH ? address(WETH) : address(underlyingToken);\n    }\n\n    function _getMaturedUnderlyingExternal() private view returns (uint256) {\n        // If the fCash has matured we use the cash balance instead.\n        uint16 currencyId = getCurrencyId();\n        // We cannot settle an account in a view method, so this may fail if the account has not been settled\n        // after maturity. This can be done by anyone so it should not be an issue\n        (int256 cashBalance, /* */, /* */) = NotionalV2.getAccountBalance(currencyId, address(this));\n        int256 underlyingExternal = NotionalV2.convertCashBalanceToExternal(currencyId, cashBalance, true);\n        require(underlyingExternal > 0, \"Must Settle\");\n\n        return uint256(underlyingExternal);\n    }\n\n    /** @dev See {IERC4262-totalAssets} */\n    function totalAssets() public view override returns (uint256) {\n        if (hasMatured()) {\n            return _getMaturedUnderlyingExternal();\n        } else {\n            (/* */, int256 precision) = getUnderlyingToken();\n            // Get the present value of the fCash held by the contract, this is returned in 8 decimal precision\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\n            int256 pvInternal = NotionalV2.getPresentfCashValue(\n                currencyId,\n                maturity,\n                int256(totalSupply()), // total supply cannot overflow as fCash overflows at uint88\n                block.timestamp,\n                false\n            );\n\n            int256 pvExternal = (pvInternal * precision) / Constants.INTERNAL_TOKEN_PRECISION;\n            // PV should always be >= 0 since we are lending\n            require(pvExternal >= 0);\n            return uint256(pvExternal);\n        }\n    }\n\n    /** @dev See {IERC4262-convertToShares} */\n    function convertToShares(uint256 assets) public view override returns (uint256 shares) {\n        if (hasMatured()) {\n            uint256 underlyingExternal = _getMaturedUnderlyingExternal();\n\n            // The withdraw calculation is:\n            // shares * cashBalance / totalSupply = cashBalanceShare\n            //\n            // Converting this to underlying external:\n            // shares * convert(cashBalance) / totalSupply = underlyingExternalShare\n            // shares * underlyingExternal / totalSupply = underlyingExternalShare\n            // shares * underlyingExternal / totalSupply = assets\n            // shares = (assets * totalSupply) / underlyingExternal\n            return (assets * totalSupply()) / underlyingExternal; // uint256 overflow checked above\n        } else {\n            // This is how much fCash received from depositing assets\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\n            (uint256 fCashAmount, /* */, /* */) = NotionalV2.getfCashLendFromDeposit(\n                currencyId,\n                assets,\n                maturity,\n                0,\n                block.timestamp,\n                true\n            );\n\n            return fCashAmount;\n        }\n    }\n\n    /** @dev See {IERC4262-convertToAssets} */\n    function convertToAssets(uint256 shares) public view override returns (uint256 assets) {\n        if (hasMatured()) {\n            uint256 underlyingExternal = _getMaturedUnderlyingExternal();\n\n            // The withdraw calculation is:\n            // shares * cashBalance / totalSupply = cashBalanceShare\n            return (shares * underlyingExternal) / totalSupply(); // uint256 overflow checked above\n        } else {\n            // This is how much underlying it will require to lend the fCash\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\n            (uint256 depositAmountUnderlying, /* */, /* */, /* */) = NotionalV2.getDepositFromfCashLend(\n                currencyId,\n                shares,\n                maturity,\n                0,\n                block.timestamp\n            );\n\n            return depositAmountUnderlying;\n        }\n    }\n\n    /** @dev See {IERC4262-maxDeposit} */\n    function maxDeposit(address) public view override returns (uint256) {\n        return hasMatured() ? 0 : type(uint256).max;\n    }\n\n    /** @dev See {IERC4262-maxMint} */\n    function maxMint(address) public view override returns (uint256) {\n        return hasMatured() ? 0 : type(uint88).max;\n    }\n\n    /** @dev See {IERC4262-maxWithdraw} */\n    function maxWithdraw(address owner) public view override returns (uint256) {\n        return convertToAssets(balanceOf(owner));\n    }\n\n    /** @dev See {IERC4262-maxRedeem} */\n    function maxRedeem(address owner) public view override returns (uint256) {\n        return balanceOf(owner);\n    }\n\n    /** @dev See {IERC4262-previewDeposit} */\n    function previewDeposit(uint256 assets) public view override returns (uint256) {\n        require(!hasMatured(), \"Matured\");\n        return convertToShares(assets);\n    }\n\n    /** @dev See {IERC4262-previewMint} */\n    function previewMint(uint256 shares) public view override returns (uint256) {\n        require(!hasMatured(), \"Matured\");\n        return convertToAssets(shares);\n    }\n\n    /** @dev See {IERC4262-previewWithdraw} */\n    function previewWithdraw(uint256 assets) public view override returns (uint256 shares) {\n        if (hasMatured()) {\n            shares = convertToShares(assets);\n        } else {\n            // If withdrawing non-matured assets, we sell them on the market (i.e. borrow)\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\n            (shares, /* */, /* */) = NotionalV2.getfCashBorrowFromPrincipal(\n                currencyId,\n                assets,\n                maturity,\n                0,\n                block.timestamp,\n                true\n            );\n        }\n    }\n\n    /** @dev See {IERC4262-previewRedeem} */\n    function previewRedeem(uint256 shares) public view override returns (uint256 assets) {\n        if (hasMatured()) {\n            assets = convertToAssets(shares);\n        } else {\n            // If withdrawing non-matured assets, we sell them on the market (i.e. borrow)\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\n            (assets, /* */, /* */, /* */) = NotionalV2.getPrincipalFromfCashBorrow(\n                currencyId,\n                shares,\n                maturity,\n                0,\n                block.timestamp\n            );\n        }\n    }\n\n    /** @dev See {IERC4262-deposit} */\n    function deposit(uint256 assets, address receiver) public override returns (uint256) {\n        require(assets <= maxDeposit(receiver), \"Max Deposit\");\n        uint256 shares = previewDeposit(assets);\n\n        _mintInternal(assets, _safeUint88(shares), receiver, 0, true);\n        emit Deposit(msg.sender, receiver, assets, shares);\n        return shares;\n    }\n\n    /** @dev See {IERC4262-mint} */\n    function mint(uint256 shares, address receiver) public override returns (uint256) {\n        uint256 assets = previewMint(shares);\n\n        _mintInternal(assets, _safeUint88(shares), receiver, 0, true);\n        emit Deposit(msg.sender, receiver, assets, shares);\n        return assets;\n    }\n\n    /** @dev See {IERC4262-withdraw} */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public override returns (uint256) {\n        uint256 shares = previewWithdraw(assets);\n\n        if (msg.sender != owner) {\n            _spendAllowance(owner, msg.sender, shares);\n        }\n        _redeemInternal(shares, receiver, owner);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        return shares;\n    }\n\n    /** @dev See {IERC4262-redeem} */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public override returns (uint256) {\n        // It is more accurate and gas efficient to check the balance of the\n        // receiver here than rely on the previewRedeem method.\n        uint256 balanceBefore = IERC20(asset()).balanceOf(receiver);\n\n        if (msg.sender != owner) {\n            _spendAllowance(owner, msg.sender, shares);\n        }\n        _redeemInternal(shares, receiver, owner);\n\n        uint256 balanceAfter = IERC20(asset()).balanceOf(receiver);\n        uint256 assets = balanceAfter - balanceBefore;\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n        return assets;\n    }\n\n    function _redeemInternal(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) private {\n        bytes memory userData = abi.encode(\n            RedeemOpts({\n                redeemToUnderlying: true,\n                transferfCash: false,\n                receiver: receiver,\n                maxImpliedRate: 0\n            })\n        );\n\n        // No operator data\n        _burn(owner, shares, userData, \"\");\n    }\n\n    function _safeNegInt88(uint256 x) private pure returns (int88) {\n        int256 y = -int256(x);\n        require(int256(type(int88).min) <= y);\n        return int88(y);\n    }\n}"
    }
  ]
}