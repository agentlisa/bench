{
  "Title": "[L-06] Missing checks for `address(0x0)` when assigning values to `address` state variables",
  "Content": "\nFile: revenue-distribution-token-1.0.0-beta.1/contracts/RevenueDistributionToken.sol (line [73](https://github.com/maple-labs/revenue-distribution-token/blob/41a3e40bf8c109ff19b38b80fde300c44fd42a3d/contracts/RevenueDistributionToken.sol#L73))<br>\n\n```solidity\npendingOwner = pendingOwner_;\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-03-maple",
  "Code": [
    {
      "filename": "contracts/RevenueDistributionToken.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity 0.8.7;\n\nimport { ERC20 }       from \"../modules/erc20/contracts/ERC20.sol\";\nimport { ERC20Helper } from \"../modules/erc20-helper/src/ERC20Helper.sol\";\n\nimport { IRevenueDistributionToken } from \"./interfaces/IRevenueDistributionToken.sol\";\n\n/*\n    ██████╗ ██████╗ ████████╗\n    ██╔══██╗██╔══██╗╚══██╔══╝\n    ██████╔╝██║  ██║   ██║\n    ██╔══██╗██║  ██║   ██║\n    ██║  ██║██████╔╝   ██║\n    ╚═╝  ╚═╝╚═════╝    ╚═╝\n*/\n\ncontract RevenueDistributionToken is IRevenueDistributionToken, ERC20 {\n\n    uint256 public immutable override precision;  // Precision of rates, equals max deposit amounts before rounding errors occur\n\n    address public override asset;  // Underlying ERC-20 asset used by ERC-4626 functionality.\n\n    address public override owner;         // Current owner of the contract, able to update the vesting schedule.\n    address public override pendingOwner;  // Pending owner of the contract, able to accept ownership.\n\n    uint256 public override freeAssets;           // Amount of assets unlocked regardless of time passed.\n    uint256 public override issuanceRate;         // asset/second rate dependent on aggregate vesting schedule (needs increased precision).\n    uint256 public override lastUpdated;          // Timestamp of when issuance equation was last updated.\n    uint256 public override vestingPeriodFinish;  // Timestamp when current vesting schedule ends.\n\n    uint256 private locked = 1;  // Used in reentrancy check.\n\n    /*****************/\n    /*** Modifiers ***/\n    /*****************/\n\n    modifier nonReentrant() {\n        require(locked == 1, \"RDT:LOCKED\");\n\n        locked = 2;\n\n        _;\n\n        locked = 1;\n    }\n\n    constructor(string memory name_, string memory symbol_, address owner_, address asset_, uint256 precision_)\n        ERC20(name_, symbol_, ERC20(asset_).decimals())\n    {\n        require((owner = owner_) != address(0), \"RDT:C:OWNER_ZERO_ADDRESS\");\n\n        asset     = asset_;  // Don't need to check zero address as ERC20(asset_).decimals() will fail in ERC20 constructor.\n        precision = precision_;\n    }\n\n    /********************************/\n    /*** Administrative Functions ***/\n    /********************************/\n\n    function acceptOwnership() external override {\n        require(msg.sender == pendingOwner, \"RDT:AO:NOT_PO\");\n\n        emit OwnershipAccepted(owner, msg.sender);\n\n        owner        = msg.sender;\n        pendingOwner = address(0);\n    }\n\n    function setPendingOwner(address pendingOwner_) external override {\n        require(msg.sender == owner, \"RDT:SPO:NOT_OWNER\");\n\n        pendingOwner = pendingOwner_;\n\n        emit PendingOwnerSet(msg.sender, pendingOwner_);\n    }\n\n    // TODO: Revisit returns\n    function updateVestingSchedule(uint256 vestingPeriod_) external override returns (uint256 issuanceRate_, uint256 freeAssets_) {\n        require(msg.sender == owner, \"RDT:UVS:NOT_OWNER\");\n        require(totalSupply != 0,    \"RDT:UVS:ZERO_SUPPLY\");\n\n        // Update \"y-intercept\" to reflect current available asset.\n        freeAssets_ = freeAssets = totalAssets();\n\n        // Calculate slope.\n        issuanceRate_ = issuanceRate = ((ERC20(asset).balanceOf(address(this)) - freeAssets_) * precision) / vestingPeriod_;\n\n        // Update timestamp and period finish.\n        vestingPeriodFinish = (lastUpdated = block.timestamp) + vestingPeriod_;\n\n        emit VestingScheduleUpdated(msg.sender, vestingPeriodFinish, issuanceRate);\n    }\n\n    /************************/\n    /*** Staker Functions ***/\n    /************************/\n\n    function deposit(uint256 assets_, address receiver_) external virtual override nonReentrant returns (uint256 shares_) {\n        _mint(shares_ = previewDeposit(assets_), assets_, receiver_, msg.sender);\n    }\n\n    function depositWithPermit(\n        uint256 assets_,\n        address receiver_,\n        uint256 deadline_,\n        uint8   v_,\n        bytes32 r_,\n        bytes32 s_\n    )\n        external virtual override nonReentrant returns (uint256 shares_)\n    {\n        ERC20(asset).permit(msg.sender, address(this), assets_, deadline_, v_, r_, s_);\n        _mint(shares_ = previewDeposit(assets_), assets_, receiver_, msg.sender);\n    }\n\n    function mint(uint256 shares_, address receiver_) external virtual override nonReentrant returns (uint256 assets_) {\n        _mint(shares_, assets_ = previewMint(shares_), receiver_, msg.sender);\n    }\n\n    function mintWithPermit(\n        uint256 shares_,\n        address receiver_,\n        uint256 maxAssets_,\n        uint256 deadline_,\n        uint8   v_,\n        bytes32 r_,\n        bytes32 s_\n    )\n        external virtual override nonReentrant returns (uint256 assets_)\n    {\n        require((assets_ = previewMint(shares_)) <= maxAssets_, \"RDT:MWP:INSUFFICIENT_PERMIT\");\n\n        ERC20(asset).permit(msg.sender, address(this), maxAssets_, deadline_, v_, r_, s_);\n        _mint(shares_, assets_, receiver_, msg.sender);\n    }\n\n    function redeem(uint256 shares_, address receiver_, address owner_) external virtual override nonReentrant returns (uint256 assets_) {\n        _burn(shares_, assets_ = previewRedeem(shares_), receiver_, owner_, msg.sender);\n    }\n\n    function withdraw(uint256 assets_, address receiver_, address owner_) external virtual override nonReentrant returns (uint256 shares_) {\n        _burn(shares_ = previewWithdraw(assets_), assets_, receiver_, owner_, msg.sender);\n    }\n\n    /**************************/\n    /*** Internal Functions ***/\n    /**************************/\n\n    function _mint(uint256 shares_, uint256 assets_, address receiver_, address caller_) internal {\n        require(shares_ != 0, \"RDT:M:ZERO_SHARES\");\n        require(assets_ != 0, \"RDT:M:ZERO_ASSETS\");\n\n        _mint(receiver_, shares_);\n\n        freeAssets = totalAssets() + assets_;\n\n        _updateIssuanceParams();\n\n        emit Deposit(caller_, receiver_, assets_, shares_);\n\n        require(ERC20Helper.transferFrom(address(asset), caller_, address(this), assets_), \"RDT:M:TRANSFER_FROM\");\n    }\n\n    function _burn(uint256 shares_, uint256 assets_, address receiver_, address owner_, address caller_) internal {\n        require(shares_ != 0, \"RDT:B:ZERO_SHARES\");\n        require(assets_ != 0, \"RDT:B:ZERO_ASSETS\");\n\n        if (caller_ != owner_) {\n            _reduceCallerAllowance(caller_, owner_, shares_);\n        }\n\n        _burn(owner_, shares_);\n\n        freeAssets = totalAssets() - assets_;\n\n        _updateIssuanceParams();\n\n        emit Withdraw(caller_, receiver_, owner_, assets_, shares_);\n\n        require(ERC20Helper.transfer(address(asset), receiver_, assets_), \"RDT:B:TRANSFER\");\n    }\n\n    function _updateIssuanceParams() internal {\n        issuanceRate = (lastUpdated = block.timestamp) > vestingPeriodFinish ? 0 : issuanceRate;\n    }\n\n    /**********************/\n    /*** View Functions ***/\n    /**********************/\n\n    function APR() external view override returns (uint256 apr_) {\n        return (issuanceRate * 365 days * 1e6) / (totalSupply * precision);\n    }\n\n    function balanceOfAssets(address account_) public view override returns (uint256 balanceOfAssets_) {\n        return convertToAssets(balanceOf[account_]);\n    }\n\n    function convertToAssets(uint256 shares_) public view override returns (uint256 assets_) {\n        uint256 supply = totalSupply;  // Cache to stack.\n\n        assets_ = supply == 0 ? shares_ : (shares_ * totalAssets()) / supply;\n    }\n\n    function convertToShares(uint256 assets_) public view override returns (uint256 shares_) {\n        uint256 supply = totalSupply;  // Cache to stack.\n\n        shares_ = supply == 0 ? assets_ : (assets_ * supply) / totalAssets();\n    }\n\n    function maxDeposit(address receiver_) external pure virtual override returns (uint256 maxAssets_) {\n        receiver_;  // Silence warning\n        maxAssets_ = type(uint256).max;\n    }\n\n    function maxMint(address receiver_) external pure virtual override returns (uint256 maxShares_) {\n        receiver_;  // Silence warning\n        maxShares_ = type(uint256).max;\n    }\n\n    function maxRedeem(address owner_) external view virtual override returns (uint256 maxShares_) {\n        maxShares_ = balanceOf[owner_];\n    }\n\n    function maxWithdraw(address owner_) external view virtual override returns (uint256 maxAssets_) {\n        maxAssets_ = balanceOfAssets(owner_);\n    }\n\n    function previewDeposit(uint256 assets_) public view virtual override returns (uint256 shares_) {\n        // As per https://eips.ethereum.org/EIPS/eip-4626#security-considerations,\n        // it should round DOWN if it’s calculating the amount of shares to issue to a user, given an amount of assets provided.\n        shares_ = convertToShares(assets_);\n    }\n\n    function previewMint(uint256 shares_) public view virtual override returns (uint256 assets_) {\n        uint256 supply = totalSupply;  // Cache to stack.\n\n        // As per https://eips.ethereum.org/EIPS/eip-4626#security-considerations,\n        // it should round UP if it’s calculating the amount of assets a user must provide, to be issued a given amount of shares.\n        assets_ = supply == 0 ? shares_ : _divRoundUp(shares_ * totalAssets(), supply);\n    }\n\n    function previewRedeem(uint256 shares_) public view virtual override returns (uint256 assets_) {\n        // As per https://eips.ethereum.org/EIPS/eip-4626#security-considerations,\n        // it should round DOWN if it’s calculating the amount of assets to send to a user, given amount of shares returned.\n        assets_ = convertToAssets(shares_);\n    }\n\n    function previewWithdraw(uint256 assets_) public view virtual override returns (uint256 shares_) {\n        uint256 supply = totalSupply;  // Cache to stack.\n\n        // As per https://eips.ethereum.org/EIPS/eip-4626#security-considerations,\n        // it should round UP if it’s calculating the amount of shares a user must return, to be sent a given amount of assets.\n        shares_ = supply == 0 ? assets_ : _divRoundUp(assets_ * supply, totalAssets());\n    }\n\n    function totalAssets() public view override returns (uint256 totalManagedAssets_) {\n        if (issuanceRate == 0) return freeAssets;\n\n        uint256 vestingTimePassed =\n            block.timestamp > vestingPeriodFinish ?\n                vestingPeriodFinish - lastUpdated :\n                block.timestamp - lastUpdated;\n\n        return ((issuanceRate * vestingTimePassed) / precision) + freeAssets;\n    }\n\n    /**************************/\n    /*** Internal Functions ***/\n    /**************************/\n\n    function _reduceCallerAllowance(address caller_, address owner_, uint256 shares_) internal {\n        uint256 callerAllowance = allowance[owner_][caller_];  // Cache to stack.\n\n        // TODO: investigate whether leave this `require()` in for clarity from error message, or let the safe math check in `callerAllowance - shares_` handle the underflow.\n        require(callerAllowance >= shares_, \"RDT:CALLER_ALLOWANCE\");\n\n        if (callerAllowance == type(uint256).max) return;\n\n        allowance[owner_][caller_] = callerAllowance - shares_;\n    }\n\n    function _divRoundUp(uint256 numerator_, uint256 divisor_) internal pure returns (uint256 result_) {\n       return (numerator_ / divisor_) + (numerator_ % divisor_ > 0 ? 1 : 0);\n    }\n\n}"
    }
  ]
}