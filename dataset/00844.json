{
  "Title": "M-2: First depositor can lock the quote target value to zero",
  "Content": "# Issue M-2: First depositor can lock the quote target value to zero \n\nSource: https://github.com/sherlock-audit/2023-12-dodo-gsp-judging/issues/48 \n\n## Found by \nhash, mstpr-brainbot, nuthan2x\n## Summary\nWhen the initial deposit occurs, it is possible for the quote target to be set to 0. This situation significantly impacts other LPs as well. Even if subsequent LPs deposit substantial amounts, the quote target remains at 0 due to multiplication with this zero value. 0 _QUOTE_TARGET_ value will impact the swaps that pool facilities\n## Vulnerability Detail\nWhen the first deposit happens, _QUOTE_TARGET_ is set as follows:\n```solidity\n if (totalSupply == 0) {\n            // case 1. initial supply\n            // The shares will be minted to user\n            shares = quoteBalance < DecimalMath.mulFloor(baseBalance, _I_)\n                ? DecimalMath.divFloor(quoteBalance, _I_)\n                : baseBalance;\n            // The target will be updated\n            _BASE_TARGET_ = uint112(shares);\n            _QUOTE_TARGET_ = uint112(DecimalMath.mulFloor(shares, _I_));\n```\n\nIn this scenario, the 'shares' value can be a minimum of 1e3, as indicated here: [link to code snippet](https://github.com/sherlock-audit/2023-12-dodo-gsp/blob/af43d39f6a89e5084843e196fc0185abffe6304d/dodo-gassaving-pool/contracts/GasSavingPool/impl/GSPVault.sol#L295).\n\nThis implies that if someone deposits minuscule amounts of quote token and base token, they can set the _QUOTE_TARGET_ to zero because the `mulFloor` operation uses a scaling factor of 1e18:\n\n```solidity\nfunction mulFloor(uint256 target, uint256 d) internal pure returns (uint256) {\n        return target * d / (10 ** 18);\n    }\n```\n\nShould the quote target become 0, subsequent deposits will not increase due to the multiplication with \"0\" on the quote target. This situation is highly problematic because the swaps depend on the value of the quote target:\nhttps://github.com/sherlock-audit/2023-12-dodo-gsp/blob/af43d39f6a89e5084843e196fc0185abffe6304d/dodo-gassaving-pool/contracts/GasSavingPool/impl/GSPFunding.sol#L74-L75\n```solidity\n// @review 0 + (0 * something) = 0! doesn't matter what amount has been deposited !\n_QUOTE_TARGET_ = uint112(uint256(_QUOTE_TARGET_) + (DecimalMath.mulFloor(uint256(_QUOTE_TARGET_), mintRatio)));\n```\n\nHere a PoC shows that if the first deposit is tiny the _QUOTE_TARGET_ is 0. Also, whatever deposits after goes through the _QUOTE_TARGET_ still 0 because of the multiplication with 0! \n\n```solidity\nfunction test_StartWithZeroTarget() external {\n        // tapir deposits tiny amounts to make quote target 0\n        vm.startPrank(tapir);\n        dai.safeTransfer(address(gsp), 1 * 1e5);\n        usdc.transfer(address(gsp), 1 * 1e5);\n        gsp.buyShares(tapir);\n\n        console.log(\"Base target\", gsp._BASE_TARGET_());\n        console.log(\"Quote target\", gsp._QUOTE_TARGET_());\n        console.log(\"Base reserve\", gsp._BASE_RESERVE_());\n        console.log(\"Quote reserve\", gsp._QUOTE_RESERVE_());\n\n        // quote target is indeed 0!\n        assertEq(gsp._QUOTE_TARGET_(), 0);\n\n        vm.stopPrank();\n\n        // hippo deposits properly\n        vm.startPrank(hippo);\n        dai.safeTransfer(address(gsp), 1000 * 1e18);\n        usdc.transfer(address(gsp), 10000 * 1e6);\n        gsp.buyShares(hippo);\n\n        console.log(\"Base target\", gsp._BASE_TARGET_());\n        console.log(\"Quote target\", gsp._QUOTE_TARGET_());\n        console.log(\"Base reserve\", gsp._BASE_RESERVE_());\n        console.log(\"Quote reserve\", gsp._QUOTE_RESERVE_());\n\n        // although hippo deposited 1000 USDC as quote tokens, target is still 0 due to multiplication with 0\n        assertEq(gsp._QUOTE_TARGET_(), 0);\n    }\n```\n\nTest result and logs:\n<img width=\"479\" alt=\"image\" src=\"https://github.com/sherlock-audit/2023-12-dodo-gsp-mstpr/assets/120012681/762c190b-f35c-4d2a-9bf2-9654b94dd119\">\n\n## Impact\nSince the quote target is important and used when pool deciding the swap math I will label this as high.\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-12-dodo-gsp/blob/af43d39f6a89e5084843e196fc0185abffe6304d/dodo-gassaving-pool/contracts/GasSavingPool/impl/GSPFunding.sol#L31-L82\n## Tool used\n\nManual Review\n\n## Recommendation\nAccording to the quote tokens decimals, multiply the quote token balance with the proper decimal scalor.\n\n\n\n## Discussion\n\n**Skyewwww**\n\nWhen Q0=0, users can still call sellQuote which can be executed normally. When user calls sellBase, the target will be check. If target is not greater than 0, the transaction will be revert as we expected.\n![image](https://github.com/sherlock-audit/2023-12-dodo-gsp-judging/assets/113418260/8e54a7ec-0e07-4ff3-b4d7-97ea826ba9a7)\n![image](https://github.com/sherlock-audit/2023-12-dodo-gsp-judging/assets/113418260/32fceac1-1c00-4548-92e2-a52a20731e4b)\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/135",
  "Code": [
    {
      "filename": "dodo-gassaving-pool/contracts/GasSavingPool/impl/GSPVault.sol",
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.8.16;\n\nimport {DecimalMath} from \"../../lib/DecimalMath.sol\";\nimport {PMMPricing} from \"../../lib/PMMPricing.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {GSPStorage} from \"./GSPStorage.sol\";\n\ncontract GSPVault is GSPStorage {\n    using SafeERC20 for IERC20;\n\n    // ============ Modifiers ============\n    /// @notice Check whether the caller is maintainer\n    modifier onlyMaintainer() {\n        require(msg.sender == _MAINTAINER_, \"ACCESS_DENIED\");\n        _;\n    }\n\n    // ============ Events ============\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    event Mint(address indexed user, uint256 value);\n\n    event Burn(address indexed user, uint256 value);\n\n    // ============ View Functions ============\n    /**\n     * @notice Get the reserves of the pool\n     * @return baseReserve The base token reserve\n     * @return quoteReserve The quote token reserve\n     */\n    function getVaultReserve() external view returns (uint256 baseReserve, uint256 quoteReserve) {\n        baseReserve = _BASE_RESERVE_;\n        quoteReserve = _QUOTE_RESERVE_;\n    }\n\n    /**\n     * @notice Get the fee rate of the pool\n     * @param user Useless, just keep the same interface with old version pool\n     * @return lpFeeRate The lp fee rate\n     * @return mtFeeRate The mt fee rate\n     */\n    function getUserFeeRate(address user) \n        external \n        view \n        returns (uint256 lpFeeRate, uint256 mtFeeRate) \n    {\n        lpFeeRate = _LP_FEE_RATE_;\n        mtFeeRate = _MT_FEE_RATE_;\n    }\n\n    // ============ Asset In ============\n    /**\n     * @notice Get the amount of base token transferred in\n     * @dev The amount of base token input should be the base token reserve minus the mt fee in base token\n     * @return input The amount of base token transferred in\n     */\n    function getBaseInput() public view returns (uint256 input) {\n        return _BASE_TOKEN_.balanceOf(address(this)) - uint256(_BASE_RESERVE_) - uint256(_MT_FEE_BASE_);\n    }\n\n    /**\n     * @notice Get the amount of quote token transferred in\n     * @dev The amount of quote token input should be the quote token reserve minus the mt fee in quote token\n     * @return input The amount of quote token transferred in\n     */\n    function getQuoteInput() public view returns (uint256 input) {\n        return _QUOTE_TOKEN_.balanceOf(address(this)) - uint256(_QUOTE_RESERVE_) - uint256(_MT_FEE_QUOTE_);\n    }\n\n    // ============ TWAP UPDATE ===========\n    /**\n     * @notice Update the twap price, internal use only\n     * @dev The twap price is updated when _IS_OPEN_TWAP_ is true\n     */\n    function _twapUpdate() internal {\n        // blockTimestamp is the timestamp of the current block\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n        // timeElapsed is the time elapsed since the last update\n        uint32 timeElapsed = blockTimestamp - _BLOCK_TIMESTAMP_LAST_;\n        // if timeElapsed is greater than 0 and the reserves are not 0, update the twap price\n        if (timeElapsed > 0 && _BASE_RESERVE_ != 0 && _QUOTE_RESERVE_ != 0) {\n            _BASE_PRICE_CUMULATIVE_LAST_ += getMidPrice() * timeElapsed;\n        }\n        // update the last block timestamp\n        _BLOCK_TIMESTAMP_LAST_ = blockTimestamp;\n    }\n\n    // ============ Set States ============\n    /**\n     * @notice Set the reserves of the pool, internal use only\n     * @param baseReserve The base token reserve\n     * @param quoteReserve The quote token reserve\n     */\n    function _setReserve(uint256 baseReserve, uint256 quoteReserve) internal {\n        // the reserves should be less than the max uint112\n        require(baseReserve <= type(uint112).max && quoteReserve <= type(uint112).max, \"OVERFLOW\");\n        _BASE_RESERVE_ = uint112(baseReserve);\n        _QUOTE_RESERVE_ = uint112(quoteReserve);\n        // if _IS_OPEN_TWAP_ is true, update the twap price\n        if (_IS_OPEN_TWAP_) _twapUpdate();\n    }\n\n    /**\n     * @notice Sync the reserves of the pool, internal use only\n     * @dev The balances of the pool should be actual balances minus the mt fee\n     */\n    function _sync() internal {\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this)) - uint256(_MT_FEE_BASE_);\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this)) - uint256(_MT_FEE_QUOTE_);\n        // the reserves should be less than the max uint112\n        require(baseBalance <= type(uint112).max && quoteBalance <= type(uint112).max, \"OVERFLOW\");\n        // if the current reserves are not equal to the recorded reserves, update the reserves\n        if (baseBalance != _BASE_RESERVE_) {\n            _BASE_RESERVE_ = uint112(baseBalance);\n        }\n        if (quoteBalance != _QUOTE_RESERVE_) {\n            _QUOTE_RESERVE_ = uint112(quoteBalance);\n        }\n        // if _IS_OPEN_TWAP_ is true, update the twap price\n        if (_IS_OPEN_TWAP_) _twapUpdate();\n    }\n\n    /// @notice Sync the reserves of the pool\n    function sync() external nonReentrant {\n        _sync();\n    }\n\n    /// @notice Correct the rState of the pool, details in pmm algorithm\n    function correctRState() public {\n        if (_RState_ == uint32(PMMPricing.RState.BELOW_ONE) && _BASE_RESERVE_<_BASE_TARGET_) {\n          _RState_ = uint32(PMMPricing.RState.ONE);\n          _BASE_TARGET_ = _BASE_RESERVE_;\n          _QUOTE_TARGET_ = _QUOTE_RESERVE_;\n        }\n        if (_RState_ == uint32(PMMPricing.RState.ABOVE_ONE) && _QUOTE_RESERVE_<_QUOTE_TARGET_) {\n          _RState_ = uint32(PMMPricing.RState.ONE);\n          _BASE_TARGET_ = _BASE_RESERVE_;\n          _QUOTE_TARGET_ = _QUOTE_RESERVE_;\n        }\n    }\n\n    /**\n     * @notice PriceLimit is used for oracle change protection\n     * @notice It sets a ratio where the relative deviation between the new price and the old price cannot exceed this ratio.\n     * @dev The default priceLimit is 1e3, the decimals of priceLimit is 1e6\n     * @param priceLimit The new price limit\n     */\n    function adjustPriceLimit(uint256 priceLimit) external onlyMaintainer {\n        // the default priceLimit is 1e3\n        require(priceLimit <= 1e6, \"INVALID_PRICE_LIMIT\");\n        _PRICE_LIMIT_ = priceLimit;\n    }\n\n    /**\n     * @notice Adjust oricle price i, only for maintainer\n     * @param i The new oracle price\n     */\n    function adjustPrice(uint256 i) external onlyMaintainer {\n        // the difference between i and _I_ should be less than priceLimit\n        uint256 offset = i > _I_ ? i - _I_ : _I_ - i;\n        require((offset * 1e6 / _I_) <= _PRICE_LIMIT_, \"EXCEED_PRICE_LIMIT\");\n        _I_ = i;\n    }\n\n    /**\n     * @notice Adjust mtFee rate, only for maintainer\n     * @dev The decimals of mtFee rate is 1e18\n     * @param mtFeeRate The new mtFee rate\n     */\n    function adjustMtFeeRate(uint256 mtFeeRate) external onlyMaintainer {\n        require(mtFeeRate <= 10**18, \"INVALID_MT_FEE_RATE\");\n        _MT_FEE_RATE_ = mtFeeRate;\n    }\n\n    // ============ Asset Out ============\n    /**\n     * @notice Transfer base token out, internal use only\n     * @param to The address of the receiver\n     * @param amount The amount of base token to transfer out\n     */\n    function _transferBaseOut(address to, uint256 amount) internal {\n        if (amount > 0) {\n            _BASE_TOKEN_.safeTransfer(to, amount);\n        }\n    }\n\n    /**\n     * @notice Transfer quote token out, internal use only\n     * @param to The address of the receiver\n     * @param amount The amount of quote token to transfer out\n     */\n    function _transferQuoteOut(address to, uint256 amount) internal {\n        if (amount > 0) {\n            _QUOTE_TOKEN_.safeTransfer(to, amount);\n        }\n    }\n\n    /// @notice Maintainer withdraw mtFee, only for maintainer\n    function withdrawMtFeeTotal() external nonReentrant onlyMaintainer {\n        uint256 mtFeeQuote = _MT_FEE_QUOTE_;\n        uint256 mtFeeBase = _MT_FEE_BASE_;\n        _MT_FEE_QUOTE_ = 0;\n        _transferQuoteOut(_MAINTAINER_, mtFeeQuote);\n        _MT_FEE_BASE_ = 0;\n        _transferBaseOut(_MAINTAINER_, mtFeeBase);\n    }\n\n    // ============ Shares (ERC20) ============\n\n    /**\n     * @dev Transfer token for a specified address\n     * @param to The address to transfer to.\n     * @param amount The amount to be transferred.\n     */\n    function transfer(address to, uint256 amount) public returns (bool) {\n        require(amount <= _SHARES_[msg.sender], \"BALANCE_NOT_ENOUGH\");\n\n        _SHARES_[msg.sender] = _SHARES_[msg.sender] - (amount);\n        _SHARES_[to] = _SHARES_[to] + amount;\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Gets the balance of the specified address.\n     * @param owner The address to query the the balance of.\n     * @return balance An uint256 representing the amount owned by the passed address.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance) {\n        return _SHARES_[owner];\n    }\n\n    /**\n     * @dev Transfer tokens from one address to another\n     * @param from address The address which you want to send tokens from\n     * @param to address The address which you want to transfer to\n     * @param amount uint256 the amount of tokens to be transferred\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public returns (bool) {\n        require(amount <= _SHARES_[from], \"BALANCE_NOT_ENOUGH\");\n        require(amount <= _ALLOWED_[from][msg.sender], \"ALLOWANCE_NOT_ENOUGH\");\n\n        _SHARES_[from] = _SHARES_[from] - amount;\n        _SHARES_[to] = _SHARES_[to] + amount;\n        _ALLOWED_[from][msg.sender] = _ALLOWED_[from][msg.sender] - amount;\n        emit Transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n     * @param spender The address which will spend the funds.\n     * @param amount The amount of tokens to be spent.\n     */\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) private {\n        _ALLOWED_[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Function to check the amount of tokens that an owner _ALLOWED_ to a spender.\n     * @param owner address The address which owns the funds.\n     * @param spender address The address which will spend the funds.\n     * @return A uint256 specifying the amount of tokens still available for the spender.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _ALLOWED_[owner][spender];\n    }\n\n    function _mint(address user, uint256 value) internal {\n        require(value > 1000, \"MINT_AMOUNT_NOT_ENOUGH\");\n        _SHARES_[user] = _SHARES_[user] + value;\n        totalSupply = totalSupply + value;\n        emit Mint(user, value);\n        emit Transfer(address(0), user, value);\n    }\n\n    function _burn(address user, uint256 value) internal {\n        _SHARES_[user] = _SHARES_[user] - value;\n        totalSupply = totalSupply - value;\n        emit Burn(user, value);\n        emit Transfer(user, address(0), value);\n    }\n\n    // ============================ Permit ======================================\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(deadline >= block.timestamp, \"DODO_DSP_LP: EXPIRED\");\n        bytes32 digest =\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR,\n                    keccak256(\n                        abi.encode(\n                            PERMIT_TYPEHASH,\n                            owner,\n                            spender,\n                            value,\n                            nonces[owner]++,\n                            deadline\n                        )\n                    )\n                )\n            );\n\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(\n            recoveredAddress != address(0) && recoveredAddress == owner,\n            \"DODO_DSP_LP: INVALID_SIGNATURE\"\n        );\n        _approve(owner, spender, value);\n    }\n}"
    },
    {
      "filename": "dodo-gassaving-pool/contracts/GasSavingPool/impl/GSPFunding.sol",
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\n\npragma solidity 0.8.16;\n\nimport {GSPVault} from \"./GSPVault.sol\";\nimport {DecimalMath} from \"../../lib/DecimalMath.sol\";\nimport {IDODOCallee} from \"../../intf/IDODOCallee.sol\";\n\n/// @notice this part focus on Lp tokens, mint and burn\ncontract GSPFunding is GSPVault {\n    // ============ Events ============\n\n    event BuyShares(address to, uint256 increaseShares, uint256 totalShares);\n\n    event SellShares(address payer, address to, uint256 decreaseShares, uint256 totalShares);\n\n    // ============ Buy & Sell Shares ============\n    \n    /// @notice User mint Lp token and deposit tokens, the result is rounded down\n    /// @dev User first transfer baseToken and quoteToken to GSP, then call buyShares\n    /// @param to The address will receive shares\n    /// @return shares The amount of shares user will receive\n    /// @return baseInput The amount of baseToken user transfer to GSP\n    /// @return quoteInput The amount of quoteToken user transfer to GSP\n    function buyShares(address to)\n        external\n        nonReentrant\n        returns (\n            uint256 shares,\n            uint256 baseInput,\n            uint256 quoteInput\n        )\n    {\n        // The balance of baseToken and quoteToken should be the balance minus the fee\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this)) - _MT_FEE_BASE_;\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this)) - _MT_FEE_QUOTE_;\n        // The reserve of baseToken and quoteToken\n        uint256 baseReserve = _BASE_RESERVE_;\n        uint256 quoteReserve = _QUOTE_RESERVE_;\n\n        // The amount of baseToken and quoteToken user transfer to GSP\n        baseInput = baseBalance - baseReserve;\n        quoteInput = quoteBalance - quoteReserve;\n\n        // BaseToken should be transferred to GSP before calling buyShares\n        require(baseInput > 0, \"NO_BASE_INPUT\");\n\n        // Round down when withdrawing. Therefore, never be a situation occuring balance is 0 but totalsupply is not 0\n        // But May Happen，reserve >0 But totalSupply = 0\n        if (totalSupply == 0) {\n            // case 1. initial supply\n            // The shares will be minted to user\n            shares = quoteBalance < DecimalMath.mulFloor(baseBalance, _I_)\n                ? DecimalMath.divFloor(quoteBalance, _I_)\n                : baseBalance;\n            // The target will be updated\n            _BASE_TARGET_ = uint112(shares);\n            _QUOTE_TARGET_ = uint112(DecimalMath.mulFloor(shares, _I_));\n        } else if (baseReserve > 0 && quoteReserve > 0) {\n            // case 2. normal case\n            uint256 baseInputRatio = DecimalMath.divFloor(baseInput, baseReserve);\n            uint256 quoteInputRatio = DecimalMath.divFloor(quoteInput, quoteReserve);\n            uint256 mintRatio = quoteInputRatio < baseInputRatio ? quoteInputRatio : baseInputRatio;\n            // The shares will be minted to user\n            shares = DecimalMath.mulFloor(totalSupply, mintRatio);\n\n            // The target will be updated\n            _BASE_TARGET_ = uint112(uint256(_BASE_TARGET_) + (DecimalMath.mulFloor(uint256(_BASE_TARGET_), mintRatio)));\n            _QUOTE_TARGET_ = uint112(uint256(_QUOTE_TARGET_) + (DecimalMath.mulFloor(uint256(_QUOTE_TARGET_), mintRatio)));\n        }\n        // The shares will be minted to user\n        // The reserve will be updated\n        _mint(to, shares);\n        _setReserve(baseBalance, quoteBalance);\n        emit BuyShares(to, shares, _SHARES_[to]);\n    }\n\n    /// @notice User burn their lp and withdraw their tokens, the result is rounded down\n    /// @dev User call sellShares, the calculated baseToken and quoteToken amount should geater than minBaseToken and minQuoteToken\n    /// @param shareAmount The amount of shares user want to sell\n    /// @param to The address will receive baseToken and quoteToken\n    /// @param baseMinAmount The minimum amount of baseToken user want to receive\n    /// @param quoteMinAmount The minimum amount of quoteToken user want to receive\n    /// @param data The data will be passed to callee contract\n    /// @param deadline The deadline of this transaction\n    function sellShares(\n        uint256 shareAmount,\n        address to,\n        uint256 baseMinAmount,\n        uint256 quoteMinAmount,\n        bytes calldata data,\n        uint256 deadline\n    ) external nonReentrant returns (uint256 baseAmount, uint256 quoteAmount) {\n        // The deadline should be greater than current timestamp\n        require(deadline >= block.timestamp, \"TIME_EXPIRED\");\n        // The amount of shares user want to sell should be less than user's balance\n        require(shareAmount <= _SHARES_[msg.sender], \"GLP_NOT_ENOUGH\");\n\n        // The balance of baseToken and quoteToken should be the balance minus the fee\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this)) - _MT_FEE_BASE_;\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this)) - _MT_FEE_QUOTE_;\n        // The total shares of GSP\n        uint256 totalShares = totalSupply;\n\n        // The amount of baseToken and quoteToken user will receive is calculated by the ratio of user's shares to total shares\n        baseAmount = baseBalance * shareAmount / totalShares;\n        quoteAmount = quoteBalance * shareAmount / totalShares;\n        \n        // The target will be updated\n        _BASE_TARGET_ = uint112(uint256(_BASE_TARGET_) - DecimalMath._divCeil((uint256(_BASE_TARGET_) * (shareAmount)), totalShares));\n        _QUOTE_TARGET_ = uint112(uint256(_QUOTE_TARGET_) - DecimalMath._divCeil((uint256(_QUOTE_TARGET_) * (shareAmount)), totalShares));\n        \n        // The calculated baseToken and quoteToken amount should geater than minBaseToken and minQuoteToken\n        require(\n            baseAmount >= baseMinAmount && quoteAmount >= quoteMinAmount,\n            \"WITHDRAW_NOT_ENOUGH\"\n        );\n\n        // The shares will be burned from user\n        // The baseToken and quoteToken will be transferred to user\n        // The reserve will be synced\n        _burn(msg.sender, shareAmount);\n        _transferBaseOut(to, baseAmount);\n        _transferQuoteOut(to, quoteAmount);\n        _sync();\n\n        // If the data is not empty, the callee contract will be called\n        if (data.length > 0) {\n            //Same as DVM \n            IDODOCallee(to).DVMSellShareCall(\n                msg.sender,\n                shareAmount,\n                baseAmount,\n                quoteAmount,\n                data\n            );\n        }\n\n        emit SellShares(msg.sender, to, shareAmount, _SHARES_[msg.sender]);\n    }\n}"
    },
    {
      "filename": "dodo-gassaving-pool/contracts/GasSavingPool/impl/GSPFunding.sol",
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\n\npragma solidity 0.8.16;\n\nimport {GSPVault} from \"./GSPVault.sol\";\nimport {DecimalMath} from \"../../lib/DecimalMath.sol\";\nimport {IDODOCallee} from \"../../intf/IDODOCallee.sol\";\n\n/// @notice this part focus on Lp tokens, mint and burn\ncontract GSPFunding is GSPVault {\n    // ============ Events ============\n\n    event BuyShares(address to, uint256 increaseShares, uint256 totalShares);\n\n    event SellShares(address payer, address to, uint256 decreaseShares, uint256 totalShares);\n\n    // ============ Buy & Sell Shares ============\n    \n    /// @notice User mint Lp token and deposit tokens, the result is rounded down\n    /// @dev User first transfer baseToken and quoteToken to GSP, then call buyShares\n    /// @param to The address will receive shares\n    /// @return shares The amount of shares user will receive\n    /// @return baseInput The amount of baseToken user transfer to GSP\n    /// @return quoteInput The amount of quoteToken user transfer to GSP\n    function buyShares(address to)\n        external\n        nonReentrant\n        returns (\n            uint256 shares,\n            uint256 baseInput,\n            uint256 quoteInput\n        )\n    {\n        // The balance of baseToken and quoteToken should be the balance minus the fee\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this)) - _MT_FEE_BASE_;\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this)) - _MT_FEE_QUOTE_;\n        // The reserve of baseToken and quoteToken\n        uint256 baseReserve = _BASE_RESERVE_;\n        uint256 quoteReserve = _QUOTE_RESERVE_;\n\n        // The amount of baseToken and quoteToken user transfer to GSP\n        baseInput = baseBalance - baseReserve;\n        quoteInput = quoteBalance - quoteReserve;\n\n        // BaseToken should be transferred to GSP before calling buyShares\n        require(baseInput > 0, \"NO_BASE_INPUT\");\n\n        // Round down when withdrawing. Therefore, never be a situation occuring balance is 0 but totalsupply is not 0\n        // But May Happen，reserve >0 But totalSupply = 0\n        if (totalSupply == 0) {\n            // case 1. initial supply\n            // The shares will be minted to user\n            shares = quoteBalance < DecimalMath.mulFloor(baseBalance, _I_)\n                ? DecimalMath.divFloor(quoteBalance, _I_)\n                : baseBalance;\n            // The target will be updated\n            _BASE_TARGET_ = uint112(shares);\n            _QUOTE_TARGET_ = uint112(DecimalMath.mulFloor(shares, _I_));\n        } else if (baseReserve > 0 && quoteReserve > 0) {\n            // case 2. normal case\n            uint256 baseInputRatio = DecimalMath.divFloor(baseInput, baseReserve);\n            uint256 quoteInputRatio = DecimalMath.divFloor(quoteInput, quoteReserve);\n            uint256 mintRatio = quoteInputRatio < baseInputRatio ? quoteInputRatio : baseInputRatio;\n            // The shares will be minted to user\n            shares = DecimalMath.mulFloor(totalSupply, mintRatio);\n\n            // The target will be updated\n            _BASE_TARGET_ = uint112(uint256(_BASE_TARGET_) + (DecimalMath.mulFloor(uint256(_BASE_TARGET_), mintRatio)));\n            _QUOTE_TARGET_ = uint112(uint256(_QUOTE_TARGET_) + (DecimalMath.mulFloor(uint256(_QUOTE_TARGET_), mintRatio)));\n        }\n        // The shares will be minted to user\n        // The reserve will be updated\n        _mint(to, shares);\n        _setReserve(baseBalance, quoteBalance);\n        emit BuyShares(to, shares, _SHARES_[to]);\n    }\n\n    /// @notice User burn their lp and withdraw their tokens, the result is rounded down\n    /// @dev User call sellShares, the calculated baseToken and quoteToken amount should geater than minBaseToken and minQuoteToken\n    /// @param shareAmount The amount of shares user want to sell\n    /// @param to The address will receive baseToken and quoteToken\n    /// @param baseMinAmount The minimum amount of baseToken user want to receive\n    /// @param quoteMinAmount The minimum amount of quoteToken user want to receive\n    /// @param data The data will be passed to callee contract\n    /// @param deadline The deadline of this transaction\n    function sellShares(\n        uint256 shareAmount,\n        address to,\n        uint256 baseMinAmount,\n        uint256 quoteMinAmount,\n        bytes calldata data,\n        uint256 deadline\n    ) external nonReentrant returns (uint256 baseAmount, uint256 quoteAmount) {\n        // The deadline should be greater than current timestamp\n        require(deadline >= block.timestamp, \"TIME_EXPIRED\");\n        // The amount of shares user want to sell should be less than user's balance\n        require(shareAmount <= _SHARES_[msg.sender], \"GLP_NOT_ENOUGH\");\n\n        // The balance of baseToken and quoteToken should be the balance minus the fee\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this)) - _MT_FEE_BASE_;\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this)) - _MT_FEE_QUOTE_;\n        // The total shares of GSP\n        uint256 totalShares = totalSupply;\n\n        // The amount of baseToken and quoteToken user will receive is calculated by the ratio of user's shares to total shares\n        baseAmount = baseBalance * shareAmount / totalShares;\n        quoteAmount = quoteBalance * shareAmount / totalShares;\n        \n        // The target will be updated\n        _BASE_TARGET_ = uint112(uint256(_BASE_TARGET_) - DecimalMath._divCeil((uint256(_BASE_TARGET_) * (shareAmount)), totalShares));\n        _QUOTE_TARGET_ = uint112(uint256(_QUOTE_TARGET_) - DecimalMath._divCeil((uint256(_QUOTE_TARGET_) * (shareAmount)), totalShares));\n        \n        // The calculated baseToken and quoteToken amount should geater than minBaseToken and minQuoteToken\n        require(\n            baseAmount >= baseMinAmount && quoteAmount >= quoteMinAmount,\n            \"WITHDRAW_NOT_ENOUGH\"\n        );\n\n        // The shares will be burned from user\n        // The baseToken and quoteToken will be transferred to user\n        // The reserve will be synced\n        _burn(msg.sender, shareAmount);\n        _transferBaseOut(to, baseAmount);\n        _transferQuoteOut(to, quoteAmount);\n        _sync();\n\n        // If the data is not empty, the callee contract will be called\n        if (data.length > 0) {\n            //Same as DVM \n            IDODOCallee(to).DVMSellShareCall(\n                msg.sender,\n                shareAmount,\n                baseAmount,\n                quoteAmount,\n                data\n            );\n        }\n\n        emit SellShares(msg.sender, to, shareAmount, _SHARES_[msg.sender]);\n    }\n}"
    }
  ]
}