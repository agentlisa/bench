{
  "Title": "[N-01] - `tokenIconURL` is not used in `proposeTokenUnwhitelisting()`",
  "Content": "\n[`tokenIconURL`](https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/dao/Proposals.sol#L180) is only used when whitelisting tokens but not when [unwhitelisting](https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/dao/DAO.sol#L157-L164).\n\n### Recommendation\n\nConsider removing it from `proposeTokenUnwhitelisting()`\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-01-salty",
  "Code": [
    {
      "filename": "src/dao/Proposals.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\";\nimport \"openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\";\nimport \"openzeppelin-contracts/contracts/utils/Strings.sol\";\nimport \"../pools/interfaces/IPoolsConfig.sol\";\nimport \"../staking/interfaces/IStaking.sol\";\nimport \"../interfaces/IExchangeConfig.sol\";\nimport \"./interfaces/IDAOConfig.sol\";\nimport \"./interfaces/IProposals.sol\";\nimport \"./interfaces/IDAO.sol\";\nimport \"../pools/PoolUtils.sol\";\n\n\n// Allows SALT stakers to propose and vote on various types of ballots such as parameter changes, token whitelisting/unwhitelisting, sending tokens, calling contracts, and updating website URLs.\n// Ensures ballot uniqueness, tracks and validates user voting power, enforces quorums, and provides a mechanism for users to alter votes.\n\ncontract Proposals is IProposals, ReentrancyGuard\n    {\n    event ProposalCreated(uint256 indexed ballotID, BallotType ballotType, string ballotName);\n    event BallotFinalized(uint256 indexed ballotID);\n    event VoteCast(address indexed voter, uint256 indexed ballotID, Vote vote, uint256 votingPower);\n\n\tusing SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    IStaking immutable public staking;\n    IExchangeConfig immutable public exchangeConfig;\n    IPoolsConfig immutable public poolsConfig;\n    IDAOConfig immutable public daoConfig;\n    ISalt immutable public salt;\n\n\t// Mapping from ballotName to a currently open ballotID (zero if none).\n\t// Used to check for existing ballots by name so as to not allow duplicate ballots to be created.\n\tmapping(string=>uint256) public openBallotsByName;\n\n\t// Maps ballotID to the corresponding Ballot\n\tmapping(uint256=>Ballot) public ballots;\n\tuint256 public nextBallotID = 1;\n\n\t// All of the ballotIDs that are currently open for voting\n\tEnumerableSet.UintSet private _allOpenBallots;\n\n\t// The ballotIDs of the tokens currently being proposed for whitelisting\n\tEnumerableSet.UintSet private _openBallotsForTokenWhitelisting;\n\n\t// The number of votes cast for a given ballot by Vote type\n\tmapping(uint256=>mapping(Vote=>uint256)) private _votesCastForBallot;\n\n\t// The last vote cast by a user for a given ballot.\n\t// Allows users to change their vote - so that the previous vote can be undone before casting the new vote.\n\tmapping(uint256=>mapping(address=>UserVote)) private _lastUserVoteForBallot;\n\n\t// Which users currently have active proposals\n\t// Useful for checking that users are only able to create one active proposal at a time (to discourage spam proposals).\n\tmapping(address=>bool) private _userHasActiveProposal;\n\n\t// Which users proposed which ballots.\n\t// Useful when a ballot is finalized - so that the user that proposed it can have their _usersWithActiveProposals status cleared\n\tmapping(uint256=>address) private _usersThatProposedBallots;\n\n\t// The time at which the first proposal can be made (45 days after deployment).\n\t// This is to allow some time for users to start staking - as some percent of stake is required to propose ballots and if the total amount staked.\n\tuint256 immutable firstPossibleProposalTimestamp = block.timestamp + 45 days;\n\n\n    constructor( IStaking _staking, IExchangeConfig _exchangeConfig, IPoolsConfig _poolsConfig, IDAOConfig _daoConfig )\n\t\t{\n\t\tstaking = _staking;\n\t\texchangeConfig = _exchangeConfig;\n\t\tpoolsConfig = _poolsConfig;\n\t\tdaoConfig = _daoConfig;\n\n\t\tsalt = exchangeConfig.salt();\n        }\n\n\n\tfunction _possiblyCreateProposal( string memory ballotName, BallotType ballotType, address address1, uint256 number1, string memory string1, string memory string2 ) internal returns (uint256 ballotID)\n\t\t{\n\t\trequire( block.timestamp >= firstPossibleProposalTimestamp, \"Cannot propose ballots within the first 45 days of deployment\" );\n\n\t\t// The DAO can create confirmation proposals which won't have the below requirements\n\t\tif ( msg.sender != address(exchangeConfig.dao() ) )\n\t\t\t{\n\t\t\t// Make sure that the sender has the minimum amount of xSALT required to make the proposal\n\t\t\tuint256 totalStaked = staking.totalShares(PoolUtils.STAKED_SALT);\n\t\t\tuint256 requiredXSalt = ( totalStaked * daoConfig.requiredProposalPercentStakeTimes1000() ) / ( 100 * 1000 );\n\n\t\t\trequire( requiredXSalt > 0, \"requiredXSalt cannot be zero\" );\n\n\t\t\tuint256 userXSalt = staking.userShareForPool( msg.sender, PoolUtils.STAKED_SALT );\n\t\t\trequire( userXSalt >= requiredXSalt, \"Sender does not have enough xSALT to make the proposal\" );\n\n\t\t\t// Make sure that the user doesn't already have an active proposal\n\t\t\trequire( ! _userHasActiveProposal[msg.sender], \"Users can only have one active proposal at a time\" );\n\t\t\t}\n\n\t\t// Make sure that a proposal of the same name is not already open for the ballot\n\t\trequire( openBallotsByName[ballotName] == 0, \"Cannot create a proposal similar to a ballot that is still open\" );\n\t\trequire( openBallotsByName[ string.concat(ballotName, \"_confirm\")] == 0, \"Cannot create a proposal for a ballot with a secondary confirmation\" );\n\n\t\tuint256 ballotMinimumEndTime = block.timestamp + daoConfig.ballotMinimumDuration();\n\n\t\t// Add the new Ballot to storage\n\t\tballotID = nextBallotID++;\n\t\tballots[ballotID] = Ballot( ballotID, true, ballotType, ballotName, address1, number1, string1, string2, ballotMinimumEndTime );\n\t\topenBallotsByName[ballotName] = ballotID;\n\t\t_allOpenBallots.add( ballotID );\n\n\t\t// Remember that the user made a proposal\n\t\t_userHasActiveProposal[msg.sender] = true;\n\t\t_usersThatProposedBallots[ballotID] = msg.sender;\n\n\t\temit ProposalCreated(ballotID, ballotType, ballotName);\n\t\t}\n\n\n\t// Create a confirmation proposal from the DAO\n\tfunction createConfirmationProposal( string calldata ballotName, BallotType ballotType, address address1, string calldata string1, string calldata description ) external returns (uint256 ballotID)\n\t\t{\n\t\trequire( msg.sender == address(exchangeConfig.dao()), \"Only the DAO can create a confirmation proposal\" );\n\n\t\treturn _possiblyCreateProposal( ballotName, ballotType, address1, 0, string1, description );\n\t\t}\n\n\n\tfunction markBallotAsFinalized( uint256 ballotID ) external nonReentrant\n\t\t{\n\t\trequire( msg.sender == address(exchangeConfig.dao()), \"Only the DAO can mark a ballot as finalized\" );\n\n\t\tBallot storage ballot = ballots[ballotID];\n\n\t\t// Remove finalized whitelist token ballots from the list of open whitelisting proposals\n\t\tif ( ballot.ballotType == BallotType.WHITELIST_TOKEN )\n\t\t\t_openBallotsForTokenWhitelisting.remove( ballotID );\n\n\t\t// Remove from the list of all open ballots\n\t\t_allOpenBallots.remove( ballotID );\n\n\t\tballot.ballotIsLive = false;\n\n\t\t// Indicate that the user who posted the proposal no longer has an active proposal\n\t\taddress userThatPostedBallot = _usersThatProposedBallots[ballotID];\n\t\t_userHasActiveProposal[userThatPostedBallot] = false;\n\n\t\tdelete openBallotsByName[ballot.ballotName];\n\n\t\temit BallotFinalized(ballotID);\n\t\t}\n\n\n\tfunction proposeParameterBallot( uint256 parameterType, string calldata description ) external nonReentrant returns (uint256 ballotID)\n\t\t{\n\t\tstring memory ballotName = string.concat(\"parameter:\", Strings.toString(parameterType) );\n\t\treturn _possiblyCreateProposal( ballotName, BallotType.PARAMETER, address(0), parameterType, \"\", description );\n\t\t}\n\n\n\tfunction proposeTokenWhitelisting( IERC20 token, string calldata tokenIconURL, string calldata description ) external nonReentrant returns (uint256 _ballotID)\n\t\t{\n\t\trequire( address(token) != address(0), \"token cannot be address(0)\" );\n\t\trequire( token.totalSupply() < type(uint112).max, \"Token supply cannot exceed uint112.max\" ); // 5 quadrillion max supply with 18 decimals of precision\n\n\t\trequire( _openBallotsForTokenWhitelisting.length() < daoConfig.maxPendingTokensForWhitelisting(), \"The maximum number of token whitelisting proposals are already pending\" );\n\t\trequire( poolsConfig.numberOfWhitelistedPools() < poolsConfig.maximumWhitelistedPools(), \"Maximum number of whitelisted pools already reached\" );\n\t\trequire( ! poolsConfig.tokenHasBeenWhitelisted(token, exchangeConfig.wbtc(), exchangeConfig.weth()), \"The token has already been whitelisted\" );\n\n\t\tstring memory ballotName = string.concat(\"whitelist:\", Strings.toHexString(address(token)) );\n\n\t\tuint256 ballotID = _possiblyCreateProposal( ballotName, BallotType.WHITELIST_TOKEN, address(token), 0, tokenIconURL, description );\n\t\t_openBallotsForTokenWhitelisting.add( ballotID );\n\n\t\treturn ballotID;\n\t\t}\n\n\n\tfunction proposeTokenUnwhitelisting( IERC20 token, string calldata tokenIconURL, string calldata description ) external nonReentrant returns (uint256 ballotID)\n\t\t{\n\t\trequire( poolsConfig.tokenHasBeenWhitelisted(token, exchangeConfig.wbtc(), exchangeConfig.weth()), \"Can only unwhitelist a whitelisted token\" );\n\t\trequire( address(token) != address(exchangeConfig.wbtc()), \"Cannot unwhitelist WBTC\" );\n\t\trequire( address(token) != address(exchangeConfig.weth()), \"Cannot unwhitelist WETH\" );\n\t\trequire( address(token) != address(exchangeConfig.dai()), \"Cannot unwhitelist DAI\" );\n\t\trequire( address(token) != address(exchangeConfig.usds()), \"Cannot unwhitelist USDS\" );\n\t\trequire( address(token) != address(exchangeConfig.salt()), \"Cannot unwhitelist SALT\" );\n\n\t\tstring memory ballotName = string.concat(\"unwhitelist:\", Strings.toHexString(address(token)) );\n\t\treturn _possiblyCreateProposal( ballotName, BallotType.UNWHITELIST_TOKEN, address(token), 0, tokenIconURL, description );\n\t\t}\n\n\n\t// Proposes sending a specified amount of SALT to a wallet or contract.\n\t// Only one sendSALT Ballot can be open at a time and the sending limit is 5% of the current SALT balance of the DAO.\n\tfunction proposeSendSALT( address wallet, uint256 amount, string calldata description ) external nonReentrant returns (uint256 ballotID)\n\t\t{\n\t\trequire( wallet != address(0), \"Cannot send SALT to address(0)\" );\n\n\t\t// Limit to 5% of current balance\n\t\tuint256 balance = exchangeConfig.salt().balanceOf( address(exchangeConfig.dao()) );\n\t\tuint256 maxSendable = balance * 5 / 100;\n\t\trequire( amount <= maxSendable, \"Cannot send more than 5% of the DAO SALT balance\" );\n\n\t\t// This ballotName is not unique for the receiving wallet and enforces the restriction of one sendSALT ballot at a time.\n\t\t// If more receivers are necessary at once, a splitter can be used.\n\t\tstring memory ballotName = \"sendSALT\";\n\t\treturn _possiblyCreateProposal( ballotName, BallotType.SEND_SALT, wallet, amount, \"\", description );\n\t\t}\n\n\n\t// Proposes calling the callFromDAO(uint256) function on an arbitrary contract.\n\tfunction proposeCallContract( address contractAddress, uint256 number, string calldata description ) external nonReentrant returns (uint256 ballotID)\n\t\t{\n\t\trequire( contractAddress != address(0), \"Contract address cannot be address(0)\" );\n\n\t\tstring memory ballotName = string.concat(\"callContract:\", Strings.toHexString(address(contractAddress)) );\n\t\treturn _possiblyCreateProposal( ballotName, BallotType.CALL_CONTRACT, contractAddress, number, description, \"\" );\n\t\t}\n\n\n\tfunction proposeCountryInclusion( string calldata country, string calldata description ) external nonReentrant returns (uint256 ballotID)\n\t\t{\n\t\trequire( bytes(country).length == 2, \"Country must be an ISO 3166 Alpha-2 Code\" );\n\n\t\tstring memory ballotName = string.concat(\"include:\", country );\n\t\treturn _possiblyCreateProposal( ballotName, BallotType.INCLUDE_COUNTRY, address(0), 0, country, description );\n\t\t}\n\n\n\tfunction proposeCountryExclusion( string calldata country, string calldata description ) external nonReentrant returns (uint256 ballotID)\n\t\t{\n\t\trequire( bytes(country).length == 2, \"Country must be an ISO 3166 Alpha-2 Code\" );\n\n\t\tstring memory ballotName = string.concat(\"exclude:\", country );\n\t\treturn _possiblyCreateProposal( ballotName, BallotType.EXCLUDE_COUNTRY, address(0), 0, country, description );\n\t\t}\n\n\n\tfunction proposeSetContractAddress( string calldata contractName, address newAddress, string calldata description ) external nonReentrant returns (uint256 ballotID)\n\t\t{\n\t\trequire( newAddress != address(0), \"Proposed address cannot be address(0)\" );\n\n\t\tstring memory ballotName = string.concat(\"setContract:\", contractName );\n\t\treturn _possiblyCreateProposal( ballotName, BallotType.SET_CONTRACT, newAddress, 0, \"\", description );\n\t\t}\n\n\n\tfunction proposeWebsiteUpdate( string calldata newWebsiteURL, string calldata description ) external nonReentrant returns (uint256 ballotID)\n\t\t{\n\t\trequire( keccak256(abi.encodePacked(newWebsiteURL)) != keccak256(abi.encodePacked(\"\")), \"newWebsiteURL cannot be empty\" );\n\n\t\tstring memory ballotName = string.concat(\"setURL:\", newWebsiteURL );\n\t\treturn _possiblyCreateProposal( ballotName, BallotType.SET_WEBSITE_URL, address(0), 0, newWebsiteURL, description );\n\t\t}\n\n\n\t// Cast a vote on an open ballot\n\tfunction castVote( uint256 ballotID, Vote vote ) external nonReentrant\n\t\t{\n\t\tBallot memory ballot = ballots[ballotID];\n\n\t\t// Require that the ballot is actually live\n\t\trequire( ballot.ballotIsLive, \"The specified ballot is not open for voting\" );\n\n\t\t// Make sure that the vote type is valid for the given ballot\n\t\tif ( ballot.ballotType == BallotType.PARAMETER )\n\t\t\trequire( (vote == Vote.INCREASE) || (vote == Vote.DECREASE) || (vote == Vote.NO_CHANGE), \"Invalid VoteType for Parameter Ballot\" );\n\t\telse // If a Ballot is not a Parameter Ballot, it is an Approval ballot\n\t\t\trequire( (vote == Vote.YES) || (vote == Vote.NO), \"Invalid VoteType for Approval Ballot\" );\n\n\t\t// Make sure that the user has voting power before proceeding.\n\t\t// Voting power is equal to their userShare of STAKED_SALT.\n\t\t// If the user changes their stake after voting they will have to recast their vote.\n\n\t\tuint256 userVotingPower = staking.userShareForPool( msg.sender, PoolUtils.STAKED_SALT );\n\t\trequire( userVotingPower > 0, \"Staked SALT required to vote\" );\n\n\t\t// Remove any previous votes made by the user on the ballot\n\t\tUserVote memory lastVote = _lastUserVoteForBallot[ballotID][msg.sender];\n\n\t\t// Undo the last vote?\n\t\tif ( lastVote.votingPower > 0 )\n\t\t\t_votesCastForBallot[ballotID][lastVote.vote] -= lastVote.votingPower;\n\n\t\t// Update the votes cast for the ballot with the user's current voting power\n\t\t_votesCastForBallot[ballotID][vote] += userVotingPower;\n\n\t\t// Remember how the user voted in case they change their vote later\n\t\t_lastUserVoteForBallot[ballotID][msg.sender] = UserVote( vote, userVotingPower );\n\n\t\temit VoteCast(msg.sender, ballotID, vote, userVotingPower);\n\t\t}\n\n\n\t// === VIEWS ===\n\tfunction ballotForID( uint256 ballotID ) external view returns (Ballot memory)\n\t\t{\n\t\treturn ballots[ballotID];\n\t\t}\n\n\n\tfunction lastUserVoteForBallot( uint256 ballotID, address user ) external view returns (UserVote memory)\n\t\t{\n\t\treturn _lastUserVoteForBallot[ballotID][user];\n\t\t}\n\n\n\tfunction votesCastForBallot( uint256 ballotID, Vote vote ) external view returns (uint256)\n\t\t{\n\t\treturn _votesCastForBallot[ballotID][vote];\n\t\t}\n\n\n\t// The required quorum is normally a default 10% of the amount of SALT staked.\n\t// There is though a minimum of 0.50% of SALT.totalSupply (in the case that the amount of staked SALT is low - at launch for instance).\n\tfunction requiredQuorumForBallotType( BallotType ballotType ) public view returns (uint256 requiredQuorum)\n\t\t{\n\t\t// The quorum will be specified as a percentage of the total amount of SALT staked\n\t\tuint256 totalStaked = staking.totalShares( PoolUtils.STAKED_SALT );\n\t\trequire( totalStaked != 0, \"SALT staked cannot be zero to determine quorum\" );\n\n\t\tif ( ballotType == BallotType.PARAMETER )\n\t\t\trequiredQuorum = ( 1 * totalStaked * daoConfig.baseBallotQuorumPercentTimes1000()) / ( 100 * 1000 );\n\t\telse if ( ( ballotType == BallotType.WHITELIST_TOKEN ) || ( ballotType == BallotType.UNWHITELIST_TOKEN ) )\n\t\t\trequiredQuorum = ( 2 * totalStaked * daoConfig.baseBallotQuorumPercentTimes1000()) / ( 100 * 1000 );\n\t\telse\n\t\t\t// All other ballot types require 3x multiple of the baseQuorum\n\t\t\trequiredQuorum = ( 3 * totalStaked * daoConfig.baseBallotQuorumPercentTimes1000()) / ( 100 * 1000 );\n\n\t\t// Make sure that the requiredQuorum is at least 0.50% of the total SALT supply.\n\t\t// Circulating supply after the first 45 days of emissions will be about 3 million - so this would require about 16% of the circulating\n\t\t// SALT to be staked and voting to pass a proposal (including whitelisting) 45 days after deployment..\n\t\tuint256 totalSupply = ERC20(address(exchangeConfig.salt())).totalSupply();\n\t\tuint256 minimumQuorum = totalSupply * 5 / 1000;\n\n\t\tif ( requiredQuorum < minimumQuorum )\n\t\t\trequiredQuorum = minimumQuorum;\n\t\t}\n\n\n\tfunction totalVotesCastForBallot( uint256 ballotID ) public view returns (uint256)\n\t\t{\n\t\tmapping(Vote=>uint256) storage votes = _votesCastForBallot[ballotID];\n\n\t\tBallot memory ballot = ballots[ballotID];\n\t\tif ( ballot.ballotType == BallotType.PARAMETER )\n\t\t\treturn votes[Vote.INCREASE] + votes[Vote.DECREASE] + votes[Vote.NO_CHANGE];\n\t\telse\n\t\t\treturn votes[Vote.YES] + votes[Vote.NO];\n\t\t}\n\n\n\t// Assumes that the quorum has been checked elsewhere\n\tfunction ballotIsApproved( uint256 ballotID ) external view returns (bool)\n\t\t{\n\t\tmapping(Vote=>uint256) storage votes = _votesCastForBallot[ballotID];\n\n\t\treturn votes[Vote.YES] > votes[Vote.NO];\n\t\t}\n\n\n\t// Assumes that the quorum has been checked elsewhere\n\tfunction winningParameterVote( uint256 ballotID ) external view returns (Vote)\n\t\t{\n\t\tmapping(Vote=>uint256) storage votes = _votesCastForBallot[ballotID];\n\n\t\tuint256 increaseTotal = votes[Vote.INCREASE];\n\t\tuint256 decreaseTotal = votes[Vote.DECREASE];\n\t\tuint256 noChangeTotal = votes[Vote.NO_CHANGE];\n\n\t\tif ( increaseTotal > decreaseTotal )\n\t\tif ( increaseTotal > noChangeTotal )\n\t\t\treturn Vote.INCREASE;\n\n\t\tif ( decreaseTotal > increaseTotal )\n\t\tif ( decreaseTotal > noChangeTotal )\n\t\t\treturn Vote.DECREASE;\n\n\t\treturn Vote.NO_CHANGE;\n\t\t}\n\n\n\t// Checks that ballot is live, and minimumEndTime and quorum have both been reached.\n\tfunction canFinalizeBallot( uint256 ballotID ) external view returns (bool)\n\t\t{\n        Ballot memory ballot = ballots[ballotID];\n        if ( ! ballot.ballotIsLive )\n        \treturn false;\n\n        // Check that the minimum duration has passed\n        if (block.timestamp < ballot.ballotMinimumEndTime )\n            return false;\n\n        // Check that the required quorum has been reached\n        if ( totalVotesCastForBallot(ballotID) < requiredQuorumForBallotType( ballot.ballotType ))\n            return false;\n\n        return true;\n\t    }\n\n\n\tfunction openBallots() external view returns (uint256[] memory)\n\t\t{\n\t\treturn _allOpenBallots.values();\n\t\t}\n\n\n\tfunction openBallotsForTokenWhitelisting() external view returns (uint256[] memory)\n\t\t{\n\t\treturn _openBallotsForTokenWhitelisting.values();\n\t\t}\n\n\n\t// Returns the ballotID of the whitelisting ballot that currently has the most yes votes\n\t// Requires that the quorum has been reached and that the number of yes votes is greater than the number no votes\n\tfunction tokenWhitelistingBallotWithTheMostVotes() external view returns (uint256)\n\t\t{\n\t\tuint256 quorum = requiredQuorumForBallotType( BallotType.WHITELIST_TOKEN);\n\n\t\tuint256 bestID = 0;\n\t\tuint256 mostYes = 0;\n\t\tfor( uint256 i = 0; i < _openBallotsForTokenWhitelisting.length(); i++ )\n\t\t\t{\n\t\t\tuint256 ballotID = _openBallotsForTokenWhitelisting.at(i);\n\t\t\tuint256 yesTotal = _votesCastForBallot[ballotID][Vote.YES];\n\t\t\tuint256 noTotal = _votesCastForBallot[ballotID][Vote.NO];\n\n\t\t\tif ( (yesTotal + noTotal) >= quorum ) // Make sure that quorum has been reached\n\t\t\tif ( yesTotal > noTotal )  // Make sure the token vote is favorable\n\t\t\tif ( yesTotal > mostYes )  // Make sure these are the most yes votes seen\n\t\t\t\t{\n\t\t\t\tbestID = ballotID;\n\t\t\t\tmostYes = yesTotal;\n\t\t\t\t}\n\t\t\t}\n\n\t\treturn bestID;\n\t\t}\n\n\n\tfunction userHasActiveProposal( address user ) external view returns (bool)\n\t\t{\n\t\treturn _userHasActiveProposal[user];\n\t\t}\n\t}"
    }
  ]
}