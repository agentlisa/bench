{
  "Title": "M-37: There is no market enabled validation in Swap and CreateAdl activities",
  "Content": "# Issue M-37: There is no market enabled validation in Swap and CreateAdl activities \n\nSource: https://github.com/sherlock-audit/2023-02-gmx-judging/issues/33 \n\n## Found by \nIllIllI, caventa\n\n## Summary\nThere is no market enabled validation in Swap and CreateAdl activities.\n\n## Vulnerability Detail\nController may execute activities  for disabled market in Swaphandler and CreateAdlHandler\n\n## Impact\nActivities can still be performed on an disabled market\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/swap/SwapUtils.sol#L98-L149\nhttps://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/swap/SwapUtils.sol#L158-L318\nhttps://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/adl/AdlUtils.sol#L125-L173\n\n## Tool used\nManual Review\n\n## Recommendation\nAdd the similar following code\n\n```solidity\nMarket.Props memory _market = MarketUtils.getEnabledMarket(dataStore, market);\n```\n\nto swap and createAdl\n\n\n\n## Discussion\n\n**xvi10**\n\nfor ADL, the market is validated in _getExecuteOrderParams called after AdlUtils.createAdlOrder\n\nfor swaps, the swap path is fetched with getEnabledMarkets before calling the swap function\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/6",
  "Code": [
    {
      "filename": "gmx-synthetics/contracts/swap/SwapUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../adl/AdlUtils.sol\";\nimport \"../data/DataStore.sol\";\nimport \"../event/EventEmitter.sol\";\nimport \"../oracle/Oracle.sol\";\nimport \"../pricing/SwapPricingUtils.sol\";\nimport \"../token/TokenUtils.sol\";\nimport \"../fee/FeeUtils.sol\";\n\n/**\n * @title SwapUtils\n * @dev Library for swap functions\n */\nlibrary SwapUtils {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using Price for Price.Props;\n\n    using EventUtils for EventUtils.AddressItems;\n    using EventUtils for EventUtils.UintItems;\n    using EventUtils for EventUtils.IntItems;\n    using EventUtils for EventUtils.BoolItems;\n    using EventUtils for EventUtils.Bytes32Items;\n    using EventUtils for EventUtils.BytesItems;\n    using EventUtils for EventUtils.StringItems;\n\n    /**\n     * @param dataStore The contract that provides access to data stored on-chain.\n     * @param eventEmitter The contract that emits events.\n     * @param oracle The contract that provides access to price data from oracles.\n     * @param tokenIn The address of the token that is being swapped.\n     * @param amountIn The amount of the token that is being swapped.\n     * @param swapPathMarkets An array of market properties, specifying the markets in which the swap should be executed.\n     * @param minOutputAmount The minimum amount of tokens that should be received as part of the swap.\n     * @param receiver The address to which the swapped tokens should be sent.\n     * @param shouldUnwrapNativeToken A boolean indicating whether the received tokens should be unwrapped from the wrapped native token (WNT) if they are wrapped.\n     */\n    struct SwapParams {\n        DataStore dataStore;\n        EventEmitter eventEmitter;\n        Oracle oracle;\n        Bank bank;\n        address tokenIn;\n        uint256 amountIn;\n        Market.Props[] swapPathMarkets;\n        uint256 minOutputAmount;\n        address receiver;\n        bool shouldUnwrapNativeToken;\n    }\n\n    /**\n     * @param market The market in which the swap should be executed.\n     * @param tokenIn The address of the token that is being swapped.\n     * @param amountIn The amount of the token that is being swapped.\n     * @param receiver The address to which the swapped tokens should be sent.\n     * @param shouldUnwrapNativeToken A boolean indicating whether the received tokens should be unwrapped from the wrapped native token (WNT) if they are wrapped.\n     */\n    struct _SwapParams {\n        Market.Props market;\n        address tokenIn;\n        uint256 amountIn;\n        address receiver;\n        bool shouldUnwrapNativeToken;\n    }\n\n    /**\n     * @param tokenOut The address of the token that is being received as part of the swap.\n     * @param tokenInPrice The price of the token that is being swapped.\n     * @param tokenOutPrice The price of the token that is being received as part of the swap.\n     * @param amountIn The amount of the token that is being swapped.\n     * @param amountOut The amount of the token that is being received as part of the swap.\n     * @param poolAmountOut The total amount of the token that is being received by all users in the swap pool.\n     */\n    struct SwapCache {\n        address tokenOut;\n        Price.Props tokenInPrice;\n        Price.Props tokenOutPrice;\n        uint256 amountIn;\n        uint256 amountOut;\n        uint256 poolAmountOut;\n    }\n\n    event SwapReverted(string reason, bytes reasonBytes);\n\n    error InvalidTokenIn(address tokenIn, address market);\n    error InsufficientSwapOutputAmount(uint256 outputAmount, uint256 minOutputAmount);\n\n    /**\n     * @dev Swaps a given amount of a given token for another token based on a\n     * specified swap path.\n     * @param params The parameters for the swap.\n     * @return A tuple containing the address of the token that was received as\n     * part of the swap and the amount of the received token.\n     */\n    function swap(SwapParams memory params) external returns (address, uint256) {\n        if (params.swapPathMarkets.length == 0) {\n            if (address(params.bank) != params.receiver) {\n                params.bank.transferOut(\n                    params.tokenIn,\n                    params.receiver,\n                    params.amountIn,\n                    params.shouldUnwrapNativeToken\n                );\n            }\n            return (params.tokenIn, params.amountIn);\n        }\n\n        if (address(params.bank) != params.swapPathMarkets[0].marketToken) {\n            params.bank.transferOut(\n                params.tokenIn,\n                params.swapPathMarkets[0].marketToken,\n                params.amountIn,\n                false\n            );\n        }\n\n        address tokenOut = params.tokenIn;\n        uint256 outputAmount = params.amountIn;\n\n        for (uint256 i = 0; i < params.swapPathMarkets.length; i++) {\n            Market.Props memory market = params.swapPathMarkets[i];\n            uint256 nextIndex = i + 1;\n            address receiver;\n            if (nextIndex < params.swapPathMarkets.length) {\n                receiver = params.swapPathMarkets[nextIndex].marketToken;\n            } else {\n                receiver = params.receiver;\n            }\n\n            _SwapParams memory _params = _SwapParams(\n                market,\n                tokenOut,\n                outputAmount,\n                receiver,\n                i == params.swapPathMarkets.length - 1 ? params.shouldUnwrapNativeToken : false // only convert ETH on the last swap if needed\n            );\n\n            (tokenOut, outputAmount) = _swap(params, _params);\n        }\n\n        if (outputAmount < params.minOutputAmount) {\n            revert InsufficientSwapOutputAmount(outputAmount, params.minOutputAmount);\n        }\n\n        return (tokenOut, outputAmount);\n    }\n\n    /**\n     * Performs a swap on a single market.\n     *\n     * @param params  The parameters for the swap.\n     * @param _params The parameters for the swap on this specific market.\n     * @return The token and amount that was swapped.\n     */\n    function _swap(SwapParams memory params, _SwapParams memory _params) internal returns (address, uint256) {\n        SwapCache memory cache;\n\n        if (_params.tokenIn != _params.market.longToken && _params.tokenIn != _params.market.shortToken) {\n            revert InvalidTokenIn(_params.tokenIn, _params.market.marketToken);\n        }\n\n        cache.tokenOut = MarketUtils.getOppositeToken(_params.tokenIn, _params.market);\n        cache.tokenInPrice = params.oracle.getLatestPrice(_params.tokenIn);\n        cache.tokenOutPrice = params.oracle.getLatestPrice(cache.tokenOut);\n\n        SwapPricingUtils.SwapFees memory fees = SwapPricingUtils.getSwapFees(\n            params.dataStore,\n            _params.market.marketToken,\n            _params.amountIn\n        );\n\n        FeeUtils.incrementClaimableFeeAmount(\n            params.dataStore,\n            params.eventEmitter,\n            _params.market.marketToken,\n            _params.tokenIn,\n            fees.feeReceiverAmount,\n            Keys.SWAP_FEE\n        );\n\n        int256 priceImpactUsd = SwapPricingUtils.getPriceImpactUsd(\n            SwapPricingUtils.GetPriceImpactUsdParams(\n                params.dataStore,\n                _params.market.marketToken,\n                _params.tokenIn,\n                cache.tokenOut,\n                cache.tokenInPrice.midPrice(),\n                cache.tokenOutPrice.midPrice(),\n                (fees.amountAfterFees * cache.tokenInPrice.midPrice()).toInt256(),\n                -(fees.amountAfterFees * cache.tokenInPrice.midPrice()).toInt256()\n            )\n        );\n\n        if (priceImpactUsd > 0) {\n            // when there is a positive price impact factor, additional tokens from the swap impact pool\n            // are withdrawn for the user\n            // for example, if 50,000 USDC is swapped out and there is a positive price impact\n            // an additional 100 USDC may be sent to the user\n            // the swap impact pool is decreased by the used amount\n\n            cache.amountIn = fees.amountAfterFees;\n            // round amountOut down\n            cache.amountOut = cache.amountIn * cache.tokenInPrice.min / cache.tokenOutPrice.max;\n            cache.poolAmountOut = cache.amountOut;\n\n            int256 positiveImpactAmount = MarketUtils.applySwapImpactWithCap(\n                params.dataStore,\n                params.eventEmitter,\n                _params.market.marketToken,\n                cache.tokenOut,\n                cache.tokenOutPrice,\n                priceImpactUsd\n            );\n\n            cache.amountOut += positiveImpactAmount.toUint256();\n        } else {\n            // when there is a negative price impact factor,\n            // less of the input amount is sent to the pool\n            // for example, if 10 ETH is swapped in and there is a negative price impact\n            // only 9.995 ETH may be swapped in\n            // the remaining 0.005 ETH will be stored in the swap impact pool\n\n            int256 negativeImpactAmount = MarketUtils.applySwapImpactWithCap(\n                params.dataStore,\n                params.eventEmitter,\n                _params.market.marketToken,\n                _params.tokenIn,\n                cache.tokenInPrice,\n                priceImpactUsd\n            );\n\n            cache.amountIn = fees.amountAfterFees - (-negativeImpactAmount).toUint256();\n            cache.amountOut = cache.amountIn * cache.tokenInPrice.min / cache.tokenOutPrice.max;\n            cache.poolAmountOut = cache.amountOut;\n        }\n\n        // the amountOut value includes the positive price impact amount\n        if (_params.receiver != _params.market.marketToken) {\n            MarketToken(payable(_params.market.marketToken)).transferOut(\n                cache.tokenOut,\n                _params.receiver,\n                cache.amountOut,\n                _params.shouldUnwrapNativeToken\n            );\n        }\n\n        MarketUtils.applyDeltaToPoolAmount(\n            params.dataStore,\n            params.eventEmitter,\n            _params.market.marketToken,\n            _params.tokenIn,\n            (cache.amountIn + fees.feeAmountForPool).toInt256()\n        );\n\n        // the poolAmountOut excludes the positive price impact amount\n        // as that is deducted from the swap impact pool instead\n        MarketUtils.applyDeltaToPoolAmount(\n            params.dataStore,\n            params.eventEmitter,\n            _params.market.marketToken,\n            cache.tokenOut,\n            -cache.poolAmountOut.toInt256()\n        );\n\n        MarketUtils.MarketPrices memory prices = MarketUtils.MarketPrices(\n            params.oracle.getLatestPrice(_params.market.indexToken),\n            _params.tokenIn == _params.market.longToken ? cache.tokenInPrice : cache.tokenOutPrice,\n            _params.tokenIn == _params.market.shortToken ? cache.tokenInPrice : cache.tokenOutPrice\n        );\n\n        MarketUtils.validatePoolAmount(\n            params.dataStore,\n            _params.market.marketToken,\n            _params.tokenIn\n        );\n\n        MarketUtils.validateReserve(\n            params.dataStore,\n            _params.market,\n            prices,\n            cache.tokenOut == _params.market.longToken\n        );\n\n        MarketUtils.validateMaxPnl(\n            params.dataStore,\n            _params.market,\n            prices,\n            Keys.MAX_PNL_FACTOR_FOR_WITHDRAWALS\n        );\n\n        SwapPricingUtils.emitSwapInfo(\n            params.eventEmitter,\n            _params.market.marketToken,\n            _params.receiver,\n            _params.tokenIn,\n            cache.tokenOut,\n            cache.tokenInPrice.min,\n            cache.tokenOutPrice.max,\n            _params.amountIn,\n            cache.amountIn,\n            cache.amountOut,\n            priceImpactUsd\n        );\n\n        SwapPricingUtils.emitSwapFeesCollected(\n            params.eventEmitter,\n            _params.market.marketToken,\n            _params.tokenIn,\n            \"swap\",\n            fees\n        );\n\n        return (cache.tokenOut, cache.amountOut);\n    }\n}"
    },
    {
      "filename": "gmx-synthetics/contracts/swap/SwapUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../adl/AdlUtils.sol\";\nimport \"../data/DataStore.sol\";\nimport \"../event/EventEmitter.sol\";\nimport \"../oracle/Oracle.sol\";\nimport \"../pricing/SwapPricingUtils.sol\";\nimport \"../token/TokenUtils.sol\";\nimport \"../fee/FeeUtils.sol\";\n\n/**\n * @title SwapUtils\n * @dev Library for swap functions\n */\nlibrary SwapUtils {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using Price for Price.Props;\n\n    using EventUtils for EventUtils.AddressItems;\n    using EventUtils for EventUtils.UintItems;\n    using EventUtils for EventUtils.IntItems;\n    using EventUtils for EventUtils.BoolItems;\n    using EventUtils for EventUtils.Bytes32Items;\n    using EventUtils for EventUtils.BytesItems;\n    using EventUtils for EventUtils.StringItems;\n\n    /**\n     * @param dataStore The contract that provides access to data stored on-chain.\n     * @param eventEmitter The contract that emits events.\n     * @param oracle The contract that provides access to price data from oracles.\n     * @param tokenIn The address of the token that is being swapped.\n     * @param amountIn The amount of the token that is being swapped.\n     * @param swapPathMarkets An array of market properties, specifying the markets in which the swap should be executed.\n     * @param minOutputAmount The minimum amount of tokens that should be received as part of the swap.\n     * @param receiver The address to which the swapped tokens should be sent.\n     * @param shouldUnwrapNativeToken A boolean indicating whether the received tokens should be unwrapped from the wrapped native token (WNT) if they are wrapped.\n     */\n    struct SwapParams {\n        DataStore dataStore;\n        EventEmitter eventEmitter;\n        Oracle oracle;\n        Bank bank;\n        address tokenIn;\n        uint256 amountIn;\n        Market.Props[] swapPathMarkets;\n        uint256 minOutputAmount;\n        address receiver;\n        bool shouldUnwrapNativeToken;\n    }\n\n    /**\n     * @param market The market in which the swap should be executed.\n     * @param tokenIn The address of the token that is being swapped.\n     * @param amountIn The amount of the token that is being swapped.\n     * @param receiver The address to which the swapped tokens should be sent.\n     * @param shouldUnwrapNativeToken A boolean indicating whether the received tokens should be unwrapped from the wrapped native token (WNT) if they are wrapped.\n     */\n    struct _SwapParams {\n        Market.Props market;\n        address tokenIn;\n        uint256 amountIn;\n        address receiver;\n        bool shouldUnwrapNativeToken;\n    }\n\n    /**\n     * @param tokenOut The address of the token that is being received as part of the swap.\n     * @param tokenInPrice The price of the token that is being swapped.\n     * @param tokenOutPrice The price of the token that is being received as part of the swap.\n     * @param amountIn The amount of the token that is being swapped.\n     * @param amountOut The amount of the token that is being received as part of the swap.\n     * @param poolAmountOut The total amount of the token that is being received by all users in the swap pool.\n     */\n    struct SwapCache {\n        address tokenOut;\n        Price.Props tokenInPrice;\n        Price.Props tokenOutPrice;\n        uint256 amountIn;\n        uint256 amountOut;\n        uint256 poolAmountOut;\n    }\n\n    event SwapReverted(string reason, bytes reasonBytes);\n\n    error InvalidTokenIn(address tokenIn, address market);\n    error InsufficientSwapOutputAmount(uint256 outputAmount, uint256 minOutputAmount);\n\n    /**\n     * @dev Swaps a given amount of a given token for another token based on a\n     * specified swap path.\n     * @param params The parameters for the swap.\n     * @return A tuple containing the address of the token that was received as\n     * part of the swap and the amount of the received token.\n     */\n    function swap(SwapParams memory params) external returns (address, uint256) {\n        if (params.swapPathMarkets.length == 0) {\n            if (address(params.bank) != params.receiver) {\n                params.bank.transferOut(\n                    params.tokenIn,\n                    params.receiver,\n                    params.amountIn,\n                    params.shouldUnwrapNativeToken\n                );\n            }\n            return (params.tokenIn, params.amountIn);\n        }\n\n        if (address(params.bank) != params.swapPathMarkets[0].marketToken) {\n            params.bank.transferOut(\n                params.tokenIn,\n                params.swapPathMarkets[0].marketToken,\n                params.amountIn,\n                false\n            );\n        }\n\n        address tokenOut = params.tokenIn;\n        uint256 outputAmount = params.amountIn;\n\n        for (uint256 i = 0; i < params.swapPathMarkets.length; i++) {\n            Market.Props memory market = params.swapPathMarkets[i];\n            uint256 nextIndex = i + 1;\n            address receiver;\n            if (nextIndex < params.swapPathMarkets.length) {\n                receiver = params.swapPathMarkets[nextIndex].marketToken;\n            } else {\n                receiver = params.receiver;\n            }\n\n            _SwapParams memory _params = _SwapParams(\n                market,\n                tokenOut,\n                outputAmount,\n                receiver,\n                i == params.swapPathMarkets.length - 1 ? params.shouldUnwrapNativeToken : false // only convert ETH on the last swap if needed\n            );\n\n            (tokenOut, outputAmount) = _swap(params, _params);\n        }\n\n        if (outputAmount < params.minOutputAmount) {\n            revert InsufficientSwapOutputAmount(outputAmount, params.minOutputAmount);\n        }\n\n        return (tokenOut, outputAmount);\n    }\n\n    /**\n     * Performs a swap on a single market.\n     *\n     * @param params  The parameters for the swap.\n     * @param _params The parameters for the swap on this specific market.\n     * @return The token and amount that was swapped.\n     */\n    function _swap(SwapParams memory params, _SwapParams memory _params) internal returns (address, uint256) {\n        SwapCache memory cache;\n\n        if (_params.tokenIn != _params.market.longToken && _params.tokenIn != _params.market.shortToken) {\n            revert InvalidTokenIn(_params.tokenIn, _params.market.marketToken);\n        }\n\n        cache.tokenOut = MarketUtils.getOppositeToken(_params.tokenIn, _params.market);\n        cache.tokenInPrice = params.oracle.getLatestPrice(_params.tokenIn);\n        cache.tokenOutPrice = params.oracle.getLatestPrice(cache.tokenOut);\n\n        SwapPricingUtils.SwapFees memory fees = SwapPricingUtils.getSwapFees(\n            params.dataStore,\n            _params.market.marketToken,\n            _params.amountIn\n        );\n\n        FeeUtils.incrementClaimableFeeAmount(\n            params.dataStore,\n            params.eventEmitter,\n            _params.market.marketToken,\n            _params.tokenIn,\n            fees.feeReceiverAmount,\n            Keys.SWAP_FEE\n        );\n\n        int256 priceImpactUsd = SwapPricingUtils.getPriceImpactUsd(\n            SwapPricingUtils.GetPriceImpactUsdParams(\n                params.dataStore,\n                _params.market.marketToken,\n                _params.tokenIn,\n                cache.tokenOut,\n                cache.tokenInPrice.midPrice(),\n                cache.tokenOutPrice.midPrice(),\n                (fees.amountAfterFees * cache.tokenInPrice.midPrice()).toInt256(),\n                -(fees.amountAfterFees * cache.tokenInPrice.midPrice()).toInt256()\n            )\n        );\n\n        if (priceImpactUsd > 0) {\n            // when there is a positive price impact factor, additional tokens from the swap impact pool\n            // are withdrawn for the user\n            // for example, if 50,000 USDC is swapped out and there is a positive price impact\n            // an additional 100 USDC may be sent to the user\n            // the swap impact pool is decreased by the used amount\n\n            cache.amountIn = fees.amountAfterFees;\n            // round amountOut down\n            cache.amountOut = cache.amountIn * cache.tokenInPrice.min / cache.tokenOutPrice.max;\n            cache.poolAmountOut = cache.amountOut;\n\n            int256 positiveImpactAmount = MarketUtils.applySwapImpactWithCap(\n                params.dataStore,\n                params.eventEmitter,\n                _params.market.marketToken,\n                cache.tokenOut,\n                cache.tokenOutPrice,\n                priceImpactUsd\n            );\n\n            cache.amountOut += positiveImpactAmount.toUint256();\n        } else {\n            // when there is a negative price impact factor,\n            // less of the input amount is sent to the pool\n            // for example, if 10 ETH is swapped in and there is a negative price impact\n            // only 9.995 ETH may be swapped in\n            // the remaining 0.005 ETH will be stored in the swap impact pool\n\n            int256 negativeImpactAmount = MarketUtils.applySwapImpactWithCap(\n                params.dataStore,\n                params.eventEmitter,\n                _params.market.marketToken,\n                _params.tokenIn,\n                cache.tokenInPrice,\n                priceImpactUsd\n            );\n\n            cache.amountIn = fees.amountAfterFees - (-negativeImpactAmount).toUint256();\n            cache.amountOut = cache.amountIn * cache.tokenInPrice.min / cache.tokenOutPrice.max;\n            cache.poolAmountOut = cache.amountOut;\n        }\n\n        // the amountOut value includes the positive price impact amount\n        if (_params.receiver != _params.market.marketToken) {\n            MarketToken(payable(_params.market.marketToken)).transferOut(\n                cache.tokenOut,\n                _params.receiver,\n                cache.amountOut,\n                _params.shouldUnwrapNativeToken\n            );\n        }\n\n        MarketUtils.applyDeltaToPoolAmount(\n            params.dataStore,\n            params.eventEmitter,\n            _params.market.marketToken,\n            _params.tokenIn,\n            (cache.amountIn + fees.feeAmountForPool).toInt256()\n        );\n\n        // the poolAmountOut excludes the positive price impact amount\n        // as that is deducted from the swap impact pool instead\n        MarketUtils.applyDeltaToPoolAmount(\n            params.dataStore,\n            params.eventEmitter,\n            _params.market.marketToken,\n            cache.tokenOut,\n            -cache.poolAmountOut.toInt256()\n        );\n\n        MarketUtils.MarketPrices memory prices = MarketUtils.MarketPrices(\n            params.oracle.getLatestPrice(_params.market.indexToken),\n            _params.tokenIn == _params.market.longToken ? cache.tokenInPrice : cache.tokenOutPrice,\n            _params.tokenIn == _params.market.shortToken ? cache.tokenInPrice : cache.tokenOutPrice\n        );\n\n        MarketUtils.validatePoolAmount(\n            params.dataStore,\n            _params.market.marketToken,\n            _params.tokenIn\n        );\n\n        MarketUtils.validateReserve(\n            params.dataStore,\n            _params.market,\n            prices,\n            cache.tokenOut == _params.market.longToken\n        );\n\n        MarketUtils.validateMaxPnl(\n            params.dataStore,\n            _params.market,\n            prices,\n            Keys.MAX_PNL_FACTOR_FOR_WITHDRAWALS\n        );\n\n        SwapPricingUtils.emitSwapInfo(\n            params.eventEmitter,\n            _params.market.marketToken,\n            _params.receiver,\n            _params.tokenIn,\n            cache.tokenOut,\n            cache.tokenInPrice.min,\n            cache.tokenOutPrice.max,\n            _params.amountIn,\n            cache.amountIn,\n            cache.amountOut,\n            priceImpactUsd\n        );\n\n        SwapPricingUtils.emitSwapFeesCollected(\n            params.eventEmitter,\n            _params.market.marketToken,\n            _params.tokenIn,\n            \"swap\",\n            fees\n        );\n\n        return (cache.tokenOut, cache.amountOut);\n    }\n}"
    },
    {
      "filename": "gmx-synthetics/contracts/adl/AdlUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../data/DataStore.sol\";\nimport \"../event/EventEmitter.sol\";\n\nimport \"../order/OrderStoreUtils.sol\";\nimport \"../order/OrderEventUtils.sol\";\nimport \"../position/PositionUtils.sol\";\nimport \"../position/PositionStoreUtils.sol\";\nimport \"../nonce/NonceUtils.sol\";\n\n// @title AdlUtils\n// @dev Library to help with auto-deleveraging\n// This is particularly for markets with an index token that is different from\n// the long token\n//\n// For example, if there is a DOGE / USD perp market with ETH as the long token\n// it would be possible for the price of DOGE to increase faster than the price of\n// ETH\n//\n// In this scenario, profitable positions should be closed through ADL to ensure\n// that the system remains fully solvent\nlibrary AdlUtils {\n    using SafeCast for int256;\n    using Array for uint256[];\n    using Market for Market.Props;\n    using Position for Position.Props;\n\n    using EventUtils for EventUtils.AddressItems;\n    using EventUtils for EventUtils.UintItems;\n    using EventUtils for EventUtils.IntItems;\n    using EventUtils for EventUtils.BoolItems;\n    using EventUtils for EventUtils.Bytes32Items;\n    using EventUtils for EventUtils.BytesItems;\n    using EventUtils for EventUtils.StringItems;\n\n    // @dev CreateAdlOrderParams struct used in createAdlOrder to avoid stack\n    // too deep errors\n    //\n    // @param dataStore DataStore\n    // @param orderStore OrderStore\n    // @param account the account to reduce the position for\n    // @param market the position's market\n    // @param collateralToken the position's collateralToken\n    // @param isLong whether the position is long or short\n    // @param sizeDeltaUsd the size to reduce the position by\n    // @param updatedAtBlock the block to set the order's updatedAtBlock to\n    struct CreateAdlOrderParams {\n        DataStore dataStore;\n        EventEmitter eventEmitter;\n        address account;\n        address market;\n        address collateralToken;\n        bool isLong;\n        uint256 sizeDeltaUsd;\n        uint256 updatedAtBlock;\n    }\n\n    error InvalidSizeDeltaForAdl(uint256 sizeDeltaUsd, uint256 positionSizeInUsd);\n    error AdlNotEnabled();\n\n    // @dev Multiple positions may need to be reduced to ensure that the pending\n    // profits does not exceed the allowed thresholds\n    //\n    // This automatic reduction of positions can only be done if the pool is in a state\n    // where auto-deleveraging is required\n    //\n    // This function checks the pending profit state and updates an isAdlEnabled\n    // flag to avoid having to repeatedly validate whether auto-deleveraging is required\n    //\n    // Once the pending profit has been reduced below the threshold this function can\n    // be called again to clear the flag\n    //\n    // The ADL check would be possible to do in AdlHandler.executeAdl as well\n    // but with that order keepers could use stale oracle prices to prove that\n    // an ADL state is possible\n    //\n    // Having this function allows any order keeper to disable ADL if prices\n    // have updated such that ADL is no longer needed\n    //\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param oracle Oracle\n    // @param market address of the market to check\n    // @param isLong indicates whether to check the long or short side of the market\n    // @param maxOracleBlockNumbers the oracle block numbers for the prices stored in the oracle\n    function updateAdlState(\n        DataStore dataStore,\n        EventEmitter eventEmitter,\n        Oracle oracle,\n        address market,\n        bool isLong,\n        uint256[] memory maxOracleBlockNumbers\n    ) external {\n        uint256 latestAdlBlock = getLatestAdlBlock(dataStore, market, isLong);\n\n        if (!maxOracleBlockNumbers.areGreaterThanOrEqualTo(latestAdlBlock)) {\n            OracleUtils.revertOracleBlockNumbersAreSmallerThanRequired(maxOracleBlockNumbers, latestAdlBlock);\n        }\n\n        Market.Props memory _market = MarketUtils.getEnabledMarket(dataStore, market);\n        MarketUtils.MarketPrices memory prices = MarketUtils.getMarketPrices(oracle, _market);\n        (bool shouldEnableAdl, int256 pnlToPoolFactor, uint256 maxPnlFactor) = MarketUtils.isPnlFactorExceeded(\n            dataStore,\n            _market,\n            prices,\n            isLong,\n            Keys.MAX_PNL_FACTOR\n        );\n\n        setIsAdlEnabled(dataStore, market, isLong, shouldEnableAdl);\n        setLatestAdlBlock(dataStore, market, isLong, block.number);\n\n        emitAdlStateUpdated(eventEmitter, market, isLong, pnlToPoolFactor, maxPnlFactor, shouldEnableAdl);\n    }\n\n    // @dev Construct an ADL order\n    //\n    // A decrease order is used to reduce a profitable position\n    //\n    // @param params CreateAdlOrderParams\n    // @return the key of the created order\n    function createAdlOrder(CreateAdlOrderParams memory params) external returns (bytes32) {\n        bytes32 positionKey = PositionUtils.getPositionKey(params.account, params.market, params.collateralToken, params.isLong);\n        Position.Props memory position = PositionStoreUtils.get(params.dataStore, positionKey);\n\n        if (params.sizeDeltaUsd > position.sizeInUsd()) {\n            revert InvalidSizeDeltaForAdl(params.sizeDeltaUsd, position.sizeInUsd());\n        }\n\n        Order.Addresses memory addresses = Order.Addresses(\n            params.account, // account\n            params.account, // receiver\n            address(0), // callbackContract\n            params.market, // market\n            position.collateralToken(), // initialCollateralToken\n            new address[](0) // swapPath\n        );\n\n        Order.Numbers memory numbers = Order.Numbers(\n            Order.OrderType.MarketDecrease, // orderType\n            Order.DecreasePositionSwapType.NoSwap, // decreasePositionSwapType\n            params.sizeDeltaUsd, // sizeDeltaUsd\n            0, // initialCollateralDeltaAmount\n            0, // triggerPrice\n            position.isLong() ? 0 : type(uint256).max, // acceptablePrice\n            0, // executionFee\n            0, // callbackGasLimit\n            0, // minOutputAmount\n            params.updatedAtBlock // updatedAtBlock\n        );\n\n        Order.Flags memory flags = Order.Flags(\n            position.isLong(), // isLong\n            true, // shouldUnwrapNativeToken\n            false // isFrozen\n        );\n\n        Order.Props memory order = Order.Props(\n            addresses,\n            numbers,\n            flags\n        );\n\n        bytes32 key = NonceUtils.getNextKey(params.dataStore);\n        OrderStoreUtils.set(params.dataStore, key, order);\n\n        OrderEventUtils.emitOrderCreated(params.eventEmitter, key, order);\n\n        return key;\n    }\n\n    // @dev validate if the requested ADL can be executed\n    //\n    // @param dataStore DataStore\n    // @param market address of the market to check\n    // @param isLong indicates whether to check the long or short side of the market\n    // @param maxOracleBlockNumbers the oracle block numbers for the prices stored in the oracle\n    function validateAdl(\n        DataStore dataStore,\n        address market,\n        bool isLong,\n        uint256[] memory maxOracleBlockNumbers\n    ) external view {\n        bool isAdlEnabled = AdlUtils.getIsAdlEnabled(dataStore, market, isLong);\n        if (!isAdlEnabled) {\n            revert AdlNotEnabled();\n        }\n\n        uint256 latestAdlBlock = AdlUtils.getLatestAdlBlock(dataStore, market, isLong);\n        if (!maxOracleBlockNumbers.areGreaterThanOrEqualTo(latestAdlBlock)) {\n            OracleUtils.revertOracleBlockNumbersAreSmallerThanRequired(maxOracleBlockNumbers, latestAdlBlock);\n        }\n    }\n\n    // @dev get the latest block at which the ADL flag was updated\n    //\n    // @param dataStore DataStore\n    // @param market address of the market to check\n    // @param isLong indicates whether to check the long or short side of the market\n    //\n    // @return the latest block at which the ADL flag was updated\n    function getLatestAdlBlock(DataStore dataStore, address market, bool isLong) internal view returns (uint256) {\n        return dataStore.getUint(Keys.latestAdlBlockKey(market, isLong));\n    }\n\n    // @dev set the latest block at which the ADL flag was updated\n    //\n    // @param dataStore DataStore\n    // @param market address of the market to check\n    // @param isLong indicates whether to check the long or short side of the market\n    // @param value the latest blo"
    }
  ]
}