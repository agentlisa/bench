{
  "Title": "[M-11] Source contract can steal NFTs from users",
  "Content": "\nA source contract can burn and transfer NFTs of users without their permission.\n\n### Proof of Concept\n\nEvery Holographed ERC721 collection is paired with a source contract, which is the user created contract that's extended by the Holographed ERC721 contract ([HolographFactory.sol#L234-L246](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographFactory.sol#L234-L246)). A source contract, however, has excessive privileges in the Holographed ERC721. Specifically, it can burn and transfer users' NFTs without their approval ([HolographERC721.sol#L500](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/HolographERC721.sol#L500), [HolographERC721.sol#L577](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/HolographERC721.sol#L577)):\n\n```solidity\nfunction sourceBurn(uint256 tokenId) external onlySource {\n  address wallet = _tokenOwner[tokenId];\n  _burn(wallet, tokenId);\n}\n\nfunction sourceTransfer(address to, uint256 tokenId) external onlySource {\n  address wallet = _tokenOwner[tokenId];\n  _transferFrom(wallet, to, tokenId);\n}\n```\n\nWhile this might be desirable for extensibility and flexibility, this puts users at the risk of being robbed by the source contract owner or a hacker who hacked the source contract owner's key.\n\n### Recommended Mitigation Steps\n\nConsider removing the `sourceBurn` and `sourceTransfer` functions of `HolographERC721` and requiring user approval to transfer or burn their tokens (`burn` and `safeTransferFrom` can be called by a source contract instead of `sourceBurn` and `sourceTransfer`).\n\n**[gzeon (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/290#issuecomment-1297281122):**\n > Also [`#403`](https://github.com/code-423n4/2022-10-holograph-findings/issues/403) brought up that source contract can also steal NFTs from burn address.\n\n**[alexanderattar (Holograph) confirmed and commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/290#issuecomment-1306692944):**\n > Need to add a `require(!_burnedTokens[tokenId], \"ERC721: token has been burned\");` check to sourceTransfer function\n\n**[alexanderattar (Holograph) resolved](https://github.com/code-423n4/2022-10-holograph-findings/issues/290#event-7817138955):**\n > [Feature/HOLO-604: implementing critical issue fixes](https://github.com/holographxyz/holograph-protocol/pull/84)\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-10-holograph-contest",
  "Code": [
    {
      "filename": "contracts/HolographFactory.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"./abstract/Admin.sol\";\nimport \"./abstract/Initializable.sol\";\n\nimport \"./enforcer/Holographer.sol\";\n\nimport \"./interface/Holographable.sol\";\nimport \"./interface/HolographFactoryInterface.sol\";\nimport \"./interface/HolographRegistryInterface.sol\";\nimport \"./interface/InitializableInterface.sol\";\n\nimport \"./struct/DeploymentConfig.sol\";\nimport \"./struct/Verification.sol\";\n\n/**\n * @title Holograph Factory\n * @author https://github.com/holographxyz\n * @notice Deploy holographable contracts\n * @dev The contract provides methods that allow for the creation of Holograph Protocol compliant smart contracts, that are capable of minting holographable assets\n */\ncontract HolographFactory is Admin, Initializable, Holographable, HolographFactoryInterface {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.holograph')) - 1)\n   */\n  bytes32 constant _holographSlot = 0xb4107f746e9496e8452accc7de63d1c5e14c19f510932daa04077cd49e8bd77a;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.registry')) - 1)\n   */\n  bytes32 constant _registrySlot = 0xce8e75d5c5227ce29a4ee170160bb296e5dea6934b80a9bd723f7ef1e7c850e7;\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    (address holograph, address registry) = abi.decode(initPayload, (address, address));\n    assembly {\n      sstore(_adminSlot, origin())\n      sstore(_holographSlot, holograph)\n      sstore(_registrySlot, registry)\n    }\n    _setInitialized();\n    return InitializableInterface.init.selector;\n  }\n\n  /**\n   * @notice Deploy holographable contract via bridge request\n   * @dev This function directly forwards the calldata to the deployHolographableContract function\n   *      It is used to allow for Holograph Bridge to make cross-chain deployments\n   */\n  function bridgeIn(\n    uint32, /* fromChain*/\n    bytes calldata payload\n  ) external returns (bytes4) {\n    (DeploymentConfig memory config, Verification memory signature, address signer) = abi.decode(\n      payload,\n      (DeploymentConfig, Verification, address)\n    );\n    HolographFactoryInterface(address(this)).deployHolographableContract(config, signature, signer);\n    return Holographable.bridgeIn.selector;\n  }\n\n  /**\n   * @notice Deploy holographable contract via bridge request\n   * @dev This function directly returns the calldata\n   *      It is used to allow for Holograph Bridge to make cross-chain deployments\n   */\n  function bridgeOut(\n    uint32, /* toChain*/\n    address, /* sender*/\n    bytes calldata payload\n  ) external pure returns (bytes4 selector, bytes memory data) {\n    return (Holographable.bridgeOut.selector, payload);\n  }\n\n  /**\n   * @notice Deploy a holographable smart contract\n   * @dev Using this function allows to deploy smart contracts that have the same address across all EVM chains\n   * @param config contract deployement configurations\n   * @param signature that was created by the wallet that created the original payload\n   * @param signer address of wallet that created the payload\n   */\n  function deployHolographableContract(\n    DeploymentConfig memory config,\n    Verification memory signature,\n    address signer\n  ) external {\n    address registry;\n    address holograph;\n    assembly {\n      holograph := sload(_holographSlot)\n      registry := sload(_registrySlot)\n    }\n    /**\n     * @dev the configuration is encoded and hashed along with signer address\n     */\n    bytes32 hash = keccak256(\n      abi.encodePacked(\n        config.contractType,\n        config.chainType,\n        config.salt,\n        keccak256(config.byteCode),\n        keccak256(config.initCode),\n        signer\n      )\n    );\n    /**\n     * @dev the hash is validated against signature\n     *      this is to guarantee that the original creator's configuration has not been altered\n     */\n    require(_verifySigner(signature.r, signature.s, signature.v, hash, signer), \"HOLOGRAPH: invalid signature\");\n    /**\n     * @dev check that this contract has not already been deployed on this chain\n     */\n    bytes memory holographerBytecode = type(Holographer).creationCode;\n    address holographerAddress = address(\n      uint160(uint256(keccak256(abi.encodePacked(bytes1(0xff), address(this), hash, keccak256(holographerBytecode)))))\n    );\n    require(!_isContract(holographerAddress), \"HOLOGRAPH: already deployed\");\n    /**\n     * @dev convert hash into uint256 which will be used as the salt for create2\n     */\n    uint256 saltInt = uint256(hash);\n    address sourceContractAddress;\n    bytes memory sourceByteCode = config.byteCode;\n    assembly {\n      /**\n       * @dev deploy the user created smart contract first\n       */\n      sourceContractAddress := create2(0, add(sourceByteCode, 0x20), mload(sourceByteCode), saltInt)\n    }\n    assembly {\n      /**\n       * @dev deploy the Holographer contract\n       */\n      holographerAddress := create2(0, add(holographerBytecode, 0x20), mload(holographerBytecode), saltInt)\n    }\n    /**\n     * @dev initialize the Holographer contract\n     */\n    require(\n      InitializableInterface(holographerAddress).init(\n        abi.encode(abi.encode(config.chainType, holograph, config.contractType, sourceContractAddress), config.initCode)\n      ) == InitializableInterface.init.selector,\n      \"initialization failed\"\n    );\n    /**\n     * @dev update the Holograph Registry with deployed contract address\n     */\n    HolographRegistryInterface(registry).setHolographedHashAddress(hash, holographerAddress);\n    /**\n     * @dev emit an event that on-chain indexers can easily read\n     */\n    emit BridgeableContractDeployed(holographerAddress, hash);\n  }\n\n  /**\n   * @notice Get the Holograph Protocol contract\n   * @dev Used for storing a reference to all the primary modules and variables of the protocol\n   */\n  function getHolograph() external view returns (address holograph) {\n    assembly {\n      holograph := sload(_holographSlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Protocol contract address\n   * @param holograph address of the Holograph Protocol smart contract to use\n   */\n  function setHolograph(address holograph) external onlyAdmin {\n    assembly {\n      sstore(_holographSlot, holograph)\n    }\n  }\n\n  /**\n   * @notice Get the Holograph Registry module\n   * @dev This module stores a reference for all deployed holographable smart contracts\n   */\n  function getRegistry() external view returns (address registry) {\n    assembly {\n      registry := sload(_registrySlot)\n    }\n  }\n\n  /**\n   * @notice Update the Holograph Registry module address\n   * @param registry address of the Holograph Registry smart contract to use\n   */\n  function setRegistry(address registry) external onlyAdmin {\n    assembly {\n      sstore(_registrySlot, registry)\n    }\n  }\n\n  /**\n   * @dev Internal function used for checking if a contract has been deployed at address\n   */\n  function _isContract(address contractAddress) private view returns (bool) {\n    bytes32 codehash;\n    assembly {\n      codehash := extcodehash(contractAddress)\n    }\n    return (codehash != 0x0 && codehash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470);\n  }\n\n  /**\n   * @dev Internal function used for verifying a signature\n   */\n  function _verifySigner(\n    bytes32 r,\n    bytes32 s,\n    uint8 v,\n    bytes32 hash,\n    address signer\n  ) private pure returns (bool) {\n    if (v < 27) {\n      v += 27;\n    }\n    /**\n     * @dev signature is checked against EIP-191 first, then directly, to support legacy wallets\n     */\n    return (ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)), v, r, s) == signer ||\n      ecrecover(hash, v, r, s) == signer);\n  }\n\n  /**\n   * @dev Purposefully reverts to prevent having any type of ether transfered into the contract\n   */\n  receive() external payable {\n    revert();\n  }\n\n  /**\n   * @dev Purposefully reverts to prevent any calls to undefined functions\n   */\n  fallback() external payable {\n    revert();\n  }\n}"
    }
  ]
}