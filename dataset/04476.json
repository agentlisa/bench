{
  "Title": "Unsafe Assumptions About Average Time Between Blocks",
  "Content": "The current implementation of the protocol uses *blocks* rather than *seconds* to measure time between interest accruals. This makes the implementation highly sensitive to changes in the average time between Ethereum blocks.\n\n\nOn [line 30 of `WhitePaperInterestRateModel.sol`](https://github.com/compound-finance/compound-protocol/blob/f385d71983ae5c5799faae9b2dfea43e5cf75262/contracts/WhitePaperInterestRateModel.sol#L30) it is implicitly assumed that the time between blocks is 15 seconds. However, the average time between blocks can change dramatically.\n\n\nFor example, the average time between blocks may increase by significant factors due to the difficulty bomb or decrease by significant factors during the transition to Serenity.\n\n\nThe difference between the actual time between blocks and the assumed time between blocks causes proportional differences between the intended interest rates and the actual interest rates.\n\n\nWhile it is possible for the admin to combat this by adjusting the interest rate model when the average time between blocks changes, such adjustments are manual and happen only after-the-fact. Errors in blocktime assumptions are cumulative, and fixing the model after-the-fact does not make users whole – it only prevents incorrect interest calculations moving forward (until the next change in blocktime).\n\n\nConsider refactoring the implementation to use *seconds* rather than *blocks* to measure the time between accruals. While `block.timestamp` can be manipulated by miners within a narrow window, these errors are small and, importantly, are not cumulative. This would decouple the interest rate model from Ethereum’s average blocktime.\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/WhitePaperInterestRateModel.sol",
      "content": "pragma solidity ^0.5.8;\n\nimport \"./Exponential.sol\";\nimport \"./InterestRateModel.sol\";\n\n/**\n  * @title The Compound Standard Interest Rate Model with pluggable constants\n  * @author Compound\n  * @notice See Section 2.4 of the Compound Whitepaper\n  */\ncontract WhitePaperInterestRateModel is InterestRateModel, Exponential {\n    /**\n     * @notice Indicator that this is an InterestRateModel contract (for inspection)\n     */\n    bool public constant isInterestRateModel = true;\n\n    /**\n     * @notice The multiplier of utilization rate that gives the slope of the interest rate\n     */\n    uint public multiplier;\n\n    /**\n     * @notice The base interest rate which is the y-intercept when utilization rate is 0\n     */\n    uint public baseRate;\n\n    /**\n     * @notice The approximate number of blocks per year that is assumed by the interest rate model\n     */\n    uint public constant blocksPerYear = 2102400;\n\n    constructor(uint baseRate_, uint multiplier_) public {\n        baseRate = baseRate_;\n        multiplier = multiplier_;\n    }\n\n    enum IRError {\n        NO_ERROR,\n        FAILED_TO_ADD_CASH_PLUS_BORROWS,\n        FAILED_TO_GET_EXP,\n        FAILED_TO_MUL_UTILIZATION_RATE,\n        FAILED_TO_ADD_BASE_RATE\n    }\n\n    /*\n     * @dev Calculates the utilization rate (borrows / (cash + borrows)) as an Exp\n     */\n    function getUtilizationRate(uint cash, uint borrows) pure internal returns (IRError, Exp memory) {\n        if (borrows == 0) {\n            // Utilization rate is zero when there's no borrows\n            return (IRError.NO_ERROR, Exp({mantissa: 0}));\n        }\n\n        (MathError err0, uint cashPlusBorrows) = addUInt(cash, borrows);\n        if (err0 != MathError.NO_ERROR) {\n            return (IRError.FAILED_TO_ADD_CASH_PLUS_BORROWS, Exp({mantissa: 0}));\n        }\n\n        (MathError err1, Exp memory utilizationRate) = getExp(borrows, cashPlusBorrows);\n        if (err1 != MathError.NO_ERROR) {\n            return (IRError.FAILED_TO_GET_EXP, Exp({mantissa: 0}));\n        }\n\n        return (IRError.NO_ERROR, utilizationRate);\n    }\n\n    /*\n     * @dev Calculates the utilization and borrow rates for use by getBorrowRate function\n     */\n    function getUtilizationAndAnnualBorrowRate(uint cash, uint borrows) view internal returns (IRError, Exp memory, Exp memory) {\n        (IRError err0, Exp memory utilizationRate) = getUtilizationRate(cash, borrows);\n        if (err0 != IRError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}), Exp({mantissa: 0}));\n        }\n\n        // Borrow Rate is 5% + UtilizationRate * 45% (baseRate + UtilizationRate * multiplier);\n        // 45% of utilizationRate, is `rate * 45 / 100`\n        (MathError err1, Exp memory utilizationRateMuled) = mulScalar(utilizationRate, multiplier);\n        // `mulScalar` only overflows when the product is >= 2^256.\n        // utilizationRate is a real number on the interval [0,1], which means that\n        // utilizationRate.mantissa is in the interval [0e18,1e18], which means that 45 times\n        // that is in the interval [0e18,45e18]. That interval has no intersection with 2^256, and therefore\n        // this can never overflow for the standard rates.\n        if (err1 != MathError.NO_ERROR) {\n            return (IRError.FAILED_TO_MUL_UTILIZATION_RATE, Exp({mantissa: 0}), Exp({mantissa: 0}));\n        }\n\n        (MathError err2, Exp memory utilizationRateScaled) = divScalar(utilizationRateMuled, mantissaOne);\n        // 100 is a constant, and therefore cannot be zero, which is the only error case of divScalar.\n        assert(err2 == MathError.NO_ERROR);\n\n        // Add the 5% for (5% + 45% * Ua)\n        (MathError err3, Exp memory annualBorrowRate) = addExp(utilizationRateScaled, Exp({mantissa: baseRate}));\n        // `addExp` only fails when the addition of mantissas overflow.\n        // As per above, utilizationRateMuled is capped at 45e18,\n        // and utilizationRateScaled is capped at 4.5e17. mantissaFivePercent = 0.5e17, and thus the addition\n        // is capped at 5e17, which is less than 2^256. This only applies to the standard rates\n        if (err3 != MathError.NO_ERROR) {\n            return (IRError.FAILED_TO_ADD_BASE_RATE, Exp({mantissa: 0}), Exp({mantissa: 0}));\n        }\n\n        return (IRError.NO_ERROR, utilizationRate, annualBorrowRate);\n    }\n\n    /**\n      * @notice Gets the current borrow interest rate based on the given asset, total cash, total borrows\n      *         and total reserves.\n      * @dev The return value should be scaled by 1e18, thus a return value of\n      *      `(true, 1000000000000)` implies an interest rate of 0.000001 or 0.0001% *per block*.\n      * @param cash The total cash of the underlying asset in the CToken\n      * @param borrows The total borrows of the underlying asset in the CToken\n      * @param _reserves The total reserves of the underlying asset in the CToken\n      * @return Success or failure and the borrow interest rate per block scaled by 10e18\n      */\n    function getBorrowRate(uint cash, uint borrows, uint _reserves) public view returns (uint, uint) {\n        _reserves; // pragma ignore unused argument\n\n        (IRError err0, Exp memory _utilizationRate, Exp memory annualBorrowRate) = getUtilizationAndAnnualBorrowRate(cash, borrows);\n        if (err0 != IRError.NO_ERROR) {\n            return (uint(err0), 0);\n        }\n\n        // And then divide down by blocks per year.\n        (MathError err1, Exp memory borrowRate) = divScalar(annualBorrowRate, blocksPerYear); // basis points * blocks per year\n        // divScalar only fails when divisor is zero. This is clearly not the case.\n        assert(err1 == MathError.NO_ERROR);\n\n        _utilizationRate; // pragma ignore unused variable\n\n        // Note: mantissa is the rate scaled 1e18, which matches the expected result\n        return (uint(IRError.NO_ERROR), borrowRate.mantissa);\n    }\n}"
    }
  ]
}