{
  "Title": "M-13: SFrxETHAdapter redemptionQueue waiting period can DOS adapter functions",
  "Content": "# Issue M-13: SFrxETHAdapter redemptionQueue waiting period can DOS adapter functions \n\nSource: https://github.com/sherlock-audit/2024-01-napier-judging/issues/120 \n\nThe protocol has acknowledged this issue.\n\n## Found by \nFalconhoof, mahdikarimi, xiaoming90\n## Links\nhttps://github.com/FraxFinance/frax-ether-redemption-queue/blob/17ebebcddf31b7780e92c23a6b440dc789e5ceac/src/contracts/FraxEtherRedemptionQueue.sol#L417-L461\nhttps://github.com/FraxFinance/frax-ether-redemption-queue/blob/17ebebcddf31b7780e92c23a6b440dc789e5ceac/src/contracts/FraxEtherRedemptionQueue.sol#L235-L246\nhttps://github.com/sherlock-audit/2024-01-napier/blob/6313f34110b0d12677b389f0ecb3197038211e12/napier-v1/src/adapters/BaseLSTAdapter.sol#L71-L139\nhttps://github.com/sherlock-audit/2024-01-napier/blob/6313f34110b0d12677b389f0ecb3197038211e12/napier-v1/src/adapters/BaseLSTAdapter.sol#L146-L169\n\n## Summary\nThe waiting period between `rebalancer` address making a withdrawal request and the withdrawn funds being ready to claim from `FraxEtherRedemptionQueue` is extremely long which can lead to a significant period of time where some of the protocol's functions are either unusable or work in a diminished capacity.\n\n## Vulnerability Detail\nIn `FraxEtherRedemptionQueue.sol`; the Queue wait time is stored in the state struct `redemptionQueueState` as `redemptionQueueState.queueLengthSecs` and is curently set to `1_296_000 Seconds` or `15 Days`; as recently as January however it was at `1_555_200 Seconds` or `18 Days`. View current setting by calling `redemptionQueueState()` [here](https://etherscan.io/address/0x82bA8da44Cd5261762e629dd5c605b17715727bd#readContract).\n\n`BaseLSTAdapter::requestWithdrawal()` is an essential function which helps to maintain `bufferEth` at a defined, healthy level. \n`bufferEth` is a facility which smooth running of redemptions and deposits.\n\nFor `redemptions`; it allows users to redeem `underlying` without having to wait for any period of time.\nHowever, redemption amounts requested which are less than `bufferEth` will be rejected as can be seen below in `BaseLSTAdapter::prefundedRedeem()`.\nFurther, there is nothing preventing `redemptions` from bringing `bufferEth` all the way to `0`.\n\n```solidity\n    function prefundedRedeem(address recipient) external virtual returns (uint256, uint256) {\n        // SOME CODE\n\n        // If the buffer is insufficient, shares cannot be redeemed immediately\n        // Need to wait for the withdrawal to be completed and the buffer to be refilled.\n>>>     if (assets > bufferEthCache) revert InsufficientBuffer();\n\n        // SOME CODE\n    }\n```\n\nFor `deposits`; where `bufferEth` is too low, it keeps user deposits in the contract until a deposit is made which brings `bufferEth` above it's target, at which point it stakes. During this time, the deposits, which are kept in the adapter, do not earn any yield; making those funds unprofitable.\n\n```solidity\n    function prefundedDeposit() external nonReentrant returns (uint256, uint256) {\n    // SOME CODE\n>>>     if (targetBufferEth >= availableEth + queueEthCache) {\n>>>         bufferEth = availableEth.toUint128();\n            return (assets, shares);\n        }\n    // SOME CODE\n    }\n```\n\n## Impact\nIf the `SFrxETHAdapter` experiences a large net redemption, bringing `bufferEth` significantly below `targetBufferEth`, the rebalancer can be required to make a withdrawal request in order to replenish the buffer.\nHowever, this will be an ineffective action given the current, 15 Day waiting period. During the waiting period if `redemptions > deposits`, the bufferEth can be brought down to `0` which will mean a complete DOSing of the `prefundedRedeem()` function.\n\nDuring the wait period too; if `redemptions >= deposits`, no new funds will be staked in `FRAX` so yields for users will decrease and may in turn lead to more redemptions.\n\nThese conditions could also necessitate the immediate calling again of `requestWithdrawal()`, given that withdrawal requests can only bring `bufferEth` up to it's target level and not beyond and during the wait period there could be further redemptions.\n\n## Code Snippet\nSimple example with Yield on `sFrxETHBalance` ignored:\n\nStart off with 100 wETH deposited; 10 wETH `bufferEth`\n> totalAssets() = (withdrawalQueueEth + bufferEth + sFrxETHBalance)\n> totalAssets() = (0 + 10 + 90)\n\nNet Redemption 5 wETH reduces bufferEth so rebalancer makes Withdrawl Request of 4.5 wETH to bring bufferEth to 10% (9.5 wEth)\n> totalAssets() = (4.5 + 5 + 85.5)\n\nDuring the wait period, continued Net Redemption reduces bufferEth further requiring another withdrawl request by rebalancer for 4.05 wEth\n> totalAssets() = (0 + 4.5 + 85.5)\n\n## Tool used\nFoundry Testing\nManual Review\n\n## Recommendation\nConsider adding a function allowing the rebalancer call `earlyBurnRedemptionTicketNft()` in `FraxEtherRedemptionQueue.sol` when there is a necessity.\nThis will allow an immediate withdrawal for a fee of `0.5%`; see function [here]( https://github.com/FraxFinance/frax-ether-redemption-queue/blob/17ebebcddf31b7780e92c23a6b440dc789e5ceac/src/contracts/FraxEtherRedemptionQueue.sol#L417-L461\n)\n\n\n\n## Discussion\n\n**massun-onibakuchi**\n\nWe are aware of the situation. Therefore, we plan to set the TARGET BUFFER PERCENTAGE passively.\n\n**nevillehuang**\n\nEscalate, this is a duplicate of #89 given it shares the exact same root cause of depletion of eth buffer to cause dos in withdrawals\n\n**sherlock-admin2**\n\n> Escalate, this is a duplicate of #89 given it shares the exact same root cause of depletion of eth buffer to cause dos in withdrawals\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Qormatic**\n\nMalicious intent is not required for this to be an issue; which it will be as it will DOS user's ability to access funds for an extended period of time. \nAs noted in the issue; the withdrawal design aims to enable users withdraw their funds from Napier immediately without having to wait in the LST protocols withdrawal queue so this issue breaks the design of the protocol.\n> For redemptions; it allows users to redeem underlying without having to wait for any period of time.\n\nFurther; as per Sherlock docs; a DOS can be considered valid if users funds are locked up for more than a week. Given that, in this case, users funds would be locked up for 15 days it more than meets that threshold.\n> Could Denial-of-Service (DOS), griefing, or locking of contracts count as a Medium (or High) issue? DoS has two separate scores on which it can become an issue:\nThe issue causes locking of funds for users for more than a week.\n\n**nevillehuang**\n\n@Qormatic You are correct, adjusted my escalation.\n\n**massun-onibakuchi**\n\n@nevillehuang it is expected that most of users will basically withdraw after the maturity because redemption of principal token can be only allowed after the maturity. ( `redemptions` >> `deposits`: after the maturity.  `redemptions` << `deposits`: before the maturity. ). so, considering the redemption queue time, we're going to set targetBufferPercentage to higher one over time and before `bufferEth` derecase or 2 weeks before the the maturity, we will request withdrawal because our team knows it'd take 2 weeks to unstake ETH before this audit. The DoS can be caused by mismanagement. We believe that using waiting time as the basis for the claim does not reflect the actual situation.\n\n**massun-onibakuchi**\n\n> Malicious intent is not required for this to be an issue; which it will be as it will DOS user's ability to access funds for an extended period of time.\n\nI think this finding needs unlikely assumption. To borrow a phrase, this issue requires malicious intent.\n\n**Qormatic**\n\n@massun-onibakuchi I don't think it's an unlikely assumption that users would want to withdraw funds before maturity; else why would you provide them with zero wait functionality to do so?\n\nAnd the Admin team may have a plan to manage a best case scenario but the DOS vulnerability would be caused by user actions outside the admin team's control and would negatively impact other users by locking up their funds for an extended period of time.\n\nAlso i dont think its fair post-contest to introduce additional context about off-chain withdrawl & buffer management which wasn't included in the README.\n\n**massun-onibakuchi**\n\n@Qormatic  why do you think it's not unlikely?\nFrom economical perspective, it is easily expected that above. Actually after the maturity deposits will be reverted by contract and only after the maturity, redemption of PT is allowed.\n\n`targetBufferPercentage` is state variable can be changed by `setTargetBufferPerecntage()`,  which intends the value can be adjusted properly after deployment.  That's why it has setter function and not immutable.\n\n**Qormatic**\n\n@massun-onibakuchi why can't user call redeemWithYT(); there's no expired modifier on it?\n\n**massun-onibakuchi**\n\n> @massun-onibakuchi why can't user call redeemWithYT(); there's no expired modifier on it?\n\n\n@Qormatic \nThis method requires users to holds the same amount of PT/YT. \n\n**Banditx0x**\n\nThis is clearly the design of the protocol. It is impossible to always be able to redeem all tokens from a protocol (like Napier) which stakes tokens into a staking protocol with a redemption queue/delay. \n\nNapier is designed to reduce the likelihood of a withdrawal being delayed, but cannot permanantly remove it.\n\n**xiaoming9090**\n\n> @nevillehuang it is expected that most of users will basically withdraw after the maturity because redemption of principal token can be only allowed after the maturity. ( `redemptions` >> `deposits`: after the maturity. `redemptions` << `deposits`: before the maturity. ). so, considering the redemption queue time, we're going to set targetBufferPercentage to higher one over time and before `bufferEth` derecase or 2 weeks before the the maturity, we will request withdrawal because our team knows it'd take 2 weeks to unstake ETH before this audit. The DoS can be caused by mismanagement. We believe that using waiting time as the basis for the claim does not reflect the actual situation.\n\nThe protocol is designed to allow users to withdraw both before and after maturity. Before maturity, users can withdraw via the `redeemWithYT` function. After maturity, the users can withdraw via the `redeem` or `withdraw` function. The report and its duplicate have shown that it is possible for malicious actors to DOS the user withdrawal, which is quite severe.\n\nThe above measures do not fully mitigate the issue. If the maturity period is a year, the `targetBufferPercentage` will only be set to a high value when it is near maturity.\n\nThus, the `targetBufferPercentage` has to be low at all other times during the one-year period. Otherwise, the protocol's core earning mechanism is broken. So, the malicious actor could still carry out the attack for the vast majority of the one-year period, resulting in users being unable to withdraw.\n\nThe approach to fully mitigate this issue is documented in my report (https://github.com/sherlock-audit/2024-01-napier-judging/issues/89).\n\n**xiaoming9090**\n\n> This is clearly the design of the protocol. It is impossible to always be able to redeem all tokens from a protocol (like Napier) which stakes tokens into a staking protocol with a redemption queue/delay.\n> \n> Napier is designed to reduce the likelihood of a withdrawal being delayed, but cannot permanantly remove it.\n\nIf appropriate fees and restrictions had been put in place (See the recommendation section of https://github.com/sherlock-audit/2024-01-napier-judging/issues/89), this issue would not have occurred in the first place. Thus, this is not related to the design of the protocol.\n\n**xiaoming9090**\n\n> @massun-onibakuchi I don't think it's an unlikely assumption that users would want to withdraw funds before maturity; else why would you provide them with zero wait functionality to do so?\n> \n> And the Admin team may have a plan to manage a best case scenario but the DOS vulnerability would be caused by user actions outside the admin team's control and would negatively impact other users by locking up their funds for an extended period of time.\n> \n> Also i dont think its fair post-contest to introduce additional context about off-chain withdrawl & buffer management which wasn't included in the README.\n\nAgree with this. Note that this DOS issue, which is quite severe, is not documented under the list of known issues of the Contest's README. Thus, it would only be fair for Watson to flag this issue during the contest. Also, the mitigation mentioned by the sponsor cannot be applied retrospectively after the contest.\n\n**cvetanovv**\n\nI agree with @nevillehuang escalation. This issue can be a dup of 89. There I have left a comment on what I think of the report.\n\n**Czar102**\n\nI agree with the escalation. Planning to consider this a duplicate of #89.\n\n**Czar102**\n\nDuring the escalation period this issue was valid and #89 – invalid. Hence, the duplication of #89 <> #120 should be proposed on #89. There already was an escalation there that showed that the issue is valid, so there is only a single mistake made here – #89 is not a duplicate of #120, but invalid. Hence, one escalation should be accepted and it was the one on #89. This issue is not undergoing any changes.\n\nHence, planning to apply the suggestion to duplicate these two, but also reject the escalation here.\n\n**nevillehuang**\n\n@Czar102 So this is a dupe of #89? Applying changes but reject escalation correct?\n\n**Czar102**\n\nYes, I edited my comment to be clearer. Technically, will consider #89 to be a duplicate of this issue.\n\n**Czar102**\n\nResult:\nMedium\nHas duplicates\n\n**sherlock-admin3**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [nevillehuang](https://github.com/sherlock-audit/2024-01-napier-judging/issues/120/#issuecomment-1984760548): rejected\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/171",
  "Code": [
    {
      "filename": "src/contracts/FraxEtherRedemptionQueue.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n// ====================================================================\n// |     ______                   _______                             |\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\/ __ `/ __ \\/ ___/ _ \\  |\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\n// | /_/   /_/   \\__,_/_/|_|  /_/   /_/_/ /_/\\__,_/_/ /_/\\___/\\___/   |\n// |                                                                  |\n// ====================================================================\n// ===================== FraxEtherRedemptionQueue =====================\n// ====================================================================\n// Users wishing to exchange frxETH for ETH 1-to-1 will need to deposit their frxETH and wait to redeem it.\n// When they do the deposit, they get an NFT with a maturity time as well as an amount.\n\n// Frax Finance: https://github.com/FraxFinance\n\n// Primary Author\n// Drake Evans: https://github.com/DrakeEvans\n// Travis Moore: https://github.com/FortisFortuna\n\n// Reviewer(s) / Contributor(s)\n// Dennis: https://github.com/denett\n// Sam Kazemian: https://github.com/samkazemian\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { Timelock2Step } from \"frax-std/access-control/v2/Timelock2Step.sol\";\nimport { OperatorRole } from \"frax-std/access-control/v2/OperatorRole.sol\";\nimport { IFrxEth } from \"./IFrxEth.sol\";\n\n/// @notice Used by the constructor\n/// @param timelockAddress Address of the timelock, which the main owner of the this contract\n/// @param operatorAddress Address of the operator, which does other tasks\n/// @param frxEthAddress Address of frxEth Erc20\n/// @param initialQueueLengthSecondss Initial length of the queue, in seconds\nstruct FraxEtherRedemptionQueueParams {\n    address timelockAddress;\n    address operatorAddress;\n    address frxEthAddress;\n    uint32 initialQueueLengthSeconds;\n}\n\ncontract FraxEtherRedemptionQueue is ERC721, Timelock2Step, OperatorRole, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using SafeCast for *;\n\n    // ==============================================================================\n    // Storage\n    // ==============================================================================\n\n    // Tokens\n    // ================\n    /// @notice The frxETH token\n    IFrxEth public immutable FRX_ETH;\n\n    // Queue-Related\n    // ================\n    /// @notice State of Frax's frxETH redemption queue\n    RedemptionQueueState public redemptionQueueState;\n\n    /// @notice State of Frax's frxETH redemption queue\n    /// @param etherLiabilities How much ETH is currently under request to be redeemed\n    /// @param nextNftId Autoincrement for the NFT id\n    /// @param queueLengthSecs Current wait time (in seconds) a new redeemer would have. Should be close to Beacon.\n    /// @param redemptionFee Redemption fee given as a percentage with 1e6 precision\n    /// @param earlyExitFee Early NFT back to frxETH exit fee given as a percentage with 1e6 precision\n    struct RedemptionQueueState {\n        uint64 nextNftId;\n        uint64 queueLengthSecs;\n        uint64 redemptionFee;\n        uint64 earlyExitFee;\n    }\n\n    /// @notice Accounting of Frax's frxETH redemption queue\n    RedemptionQueueAccounting public redemptionQueueAccounting;\n\n    /// @param etherLiabilities How much ETH would need to be paid out if every NFT holder could claim immediately\n    /// @param unclaimedFees Earned fees that the protocol has not collected yet\n    struct RedemptionQueueAccounting {\n        uint128 etherLiabilities;\n        uint128 unclaimedFees;\n    }\n\n    /// @notice Information about a user's redemption ticket NFT\n    mapping(uint256 nftId => RedemptionQueueItem) public nftInformation;\n\n    /// @notice The ```RedemptionQueueItem``` struct provides metadata information about each Nft\n    /// @param hasBeenRedeemed boolean for whether the NFT has been redeemed\n    /// @param amount How much ETH is claimable\n    /// @param maturity Unix timestamp when they can claim their ETH\n    /// @param earlyExitFee EarlyExitFee at time of NFT mint\n    struct RedemptionQueueItem {\n        bool hasBeenRedeemed;\n        uint64 maturity;\n        uint120 amount;\n        uint64 earlyExitFee;\n    }\n\n    /// @notice Maximum queue length the operator can set given in seconds\n    uint256 public maxOperatorQueueLengthSeconds = 100 days;\n\n    /// @notice The precision of the redemption fee\n    uint64 public constant FEE_PRECISION = 1e6;\n\n    /// @notice The fee recipient for various fees\n    address public feeRecipient;\n\n    // ==============================================================================\n    // Constructor\n    // ==============================================================================\n\n    /// @notice Constructor\n    /// @param _params The contructor FraxEtherRedemptionQueueParams params\n    constructor(\n        FraxEtherRedemptionQueueParams memory _params\n    )\n        payable\n        ERC721(\"FrxETHRedemptionTicket\", \"FrxETH Redemption Queue Ticket\")\n        OperatorRole(_params.operatorAddress)\n        Timelock2Step(_params.timelockAddress)\n    {\n        redemptionQueueState.queueLengthSecs = _params.initialQueueLengthSeconds;\n        FRX_ETH = IFrxEth(_params.frxEthAddress);\n    }\n\n    /// @notice Allows contract to receive Eth\n    receive() external payable {\n        // Do nothing except take in the Eth\n    }\n\n    // =============================================================================================\n    // Configurations / Privileged functions\n    // =============================================================================================\n\n    /// @notice When the accrued redemption fees are collected\n    /// @param recipient The address to receive the fees\n    /// @param collectAmount Amount of fees collected\n    event CollectRedemptionFees(address recipient, uint128 collectAmount);\n\n    /// @notice Collect redemption fees\n    /// @param _collectAmount Amount of frxEth to collect\n    function collectRedemptionFees(uint128 _collectAmount) external {\n        // Make sure the sender is either the timelock or the operator\n        _requireIsTimelockOrOperator();\n\n        uint128 _unclaimedFees = redemptionQueueAccounting.unclaimedFees;\n\n        // Make sure you are not taking too much\n        if (_collectAmount > _unclaimedFees) revert ExceedsCollectedFees(_collectAmount, _unclaimedFees);\n\n        // Decrement the unclaimed fee amount\n        redemptionQueueAccounting.unclaimedFees -= _collectAmount;\n\n        // Interactions: Transfer frxEth fees to the recipient\n        IERC20(address(FRX_ETH)).safeTransfer({ to: feeRecipient, value: _collectAmount });\n\n        emit CollectRedemptionFees({ recipient: feeRecipient, collectAmount: _collectAmount });\n    }\n\n    /// @notice When the timelock or operator recovers ERC20 tokens mistakenly sent here\n    /// @param recipient Address of the recipient\n    /// @param token Address of the erc20 token\n    /// @param amount Amount of the erc20 token recovered\n    event RecoverErc20(address recipient, address token, uint256 amount);\n\n    /// @notice Recovers ERC20 tokens mistakenly sent to this contract\n    /// @param _tokenAddress Address of the token\n    /// @param _tokenAmount Amount of the token\n    function recoverErc20(address _tokenAddress, uint256 _tokenAmount) external {\n        _requireSenderIsTimelock();\n        IERC20(_tokenAddress).safeTransfer({ to: msg.sender, value: _tokenAmount });\n        emit RecoverErc20({ recipient: msg.sender, token: _tokenAddress, amount: _tokenAmount });\n    }\n\n    /// @notice The EtherRecovered event is emitted when recoverEther is called\n    /// @param recipient Address of the recipient\n    /// @param amount Amount of the ether recovered\n    event RecoverEther(address recipient, uint256 amount);\n\n    /// @notice Recover ETH from exits where people early exited their NFT for frxETH, or when someone mistakenly directly sends ETH here\n    /// @param _amount Amount of ETH to recover\n    function recoverEther(uint256 _amount) external {\n        _requireSenderIsTimelock();\n\n        (bool _success, ) = address(msg.sender).call{ value: _amount }(\"\");\n        if (!_success) revert InvalidEthTransfer();\n\n        emit RecoverEther({ recipient: msg.sender, amount: _amount });\n    }\n\n    /// @notice When the early exit fee is set\n    /// @param oldEarlyExitFee Old early exit fee\n    /// @param newEarlyExitFee New early exit fee\n    event SetEarlyExitFee(uint64 oldEarlyExitFee, uint64 newEarlyExitFee);\n\n    /// @notice Sets the fee for exiting the NFT early and getting back frxETH (not ETH)\n    /// @param _newFee New early exit fee given in percentage terms, using 1e6 precision\n    function setEarlyExitFee(uint64 _newFee) external {\n        _requireSenderIsTimelock();\n        if (_newFee > FEE_PRECISION) revert ExceedsMaxEarlyExitFee(_newFee, FEE_PRECISION);\n\n        emit SetEarlyExitFee({ oldEarlyExitFee: redemptionQueueState.earlyExitFee, newEarlyExitFee: _newFee });\n\n        redemptionQueueState.earlyExitFee = _newFee;\n    }\n\n    /// @notice When the redemption fee is set\n    /// @param oldRedemptionFee Old redemption fee\n    /// @param newRedemptionFee New redemption fee\n    event SetRedemptionFee(uint64 oldRedemptionFee, uint64 newRedemptionFee);\n\n    /// @notice Sets the fee for redeeming\n    /// @param _newFee New redemption fee given in percentage terms, using 1e6 precision\n    function setRedemptionFee(uint64 _newFee) external {\n        _requireSenderIsTimelock();\n        if (_newFee > FEE_PRECISION) revert ExceedsMaxRedemptionFee(_newFee, FEE_PRECISION);\n\n        emit SetRedemptionFee({ oldRedemptionFee: redemptionQueueState.redemptionFee, newRedemptionFee: _newFee });\n\n        redemptionQueueState.redemptionFee = _newFee;\n    }\n\n    /// @notice When the current wait time (in seconds) of the queue is set\n    /// @param oldQueueLength Old queue length in seconds\n    /// @param newQueueLength New queue length in seconds\n    event SetQueueLengthSeconds(uint64 oldQueueLength, uint64 newQueueLength);\n\n    /// @notice Sets the current wait time (in seconds) a new redeemer would have\n    /// @param _newLength New queue time, in seconds\n    function setQueueLengthSeconds(uint64 _newLength) external {\n        _requireIsTimelockOrOperator();\n        if (msg.sender != timelockAddress && _newLength > maxOperatorQueueLengthSeconds)\n            revert ExceedsMaxQueueLengthSecs(_newLength, maxOperatorQueueLengthSeconds);\n\n        emit SetQueueLengthSeconds({\n            oldQueueLength: redemptionQueueState.queueLengthSecs,\n            newQueueLength: _newLength\n        });\n\n        redemptionQueueState.queueLengthSecs = _newLength;\n    }\n\n    /// @notice When the max queue length the operator can set is changed\n    /// @param oldMaxQueueLengthSecs Old max queue length in seconds\n    /// @param newMaxQueueLengthSecs New max queue length in seconds\n    event SetMaxOperatorQueueLengthSeconds(uint256 oldMaxQueueLengthSecs, uint256 newMaxQueueLengthSecs);\n\n    /// @notice Sets the maximum queue length the operator can set\n    /// @param _newMaxQueueLengthSeconds New maximum queue length\n    function setMaxOperatorQueueLengthSeconds(uint256 _newMaxQueueLengthSeconds) external {\n        _requireSenderIsTimelock();\n\n        emit SetMaxOperatorQueueLengthSeconds({\n            oldMaxQueueLengthSecs: maxOperatorQueueLengthSeconds,\n            newMaxQueueLengthSecs: _newMaxQueueLengthSeconds\n        });\n\n        maxOperatorQueueLengthSeconds = _newMaxQueueLengthSeconds;\n    }\n\n    /// @notice Sets the operator (bot) that updates the queue length\n    /// @param _newOperator New bot address\n    function setOperator(address _newOperator) external {\n        _requireSenderIsTimelock();\n        _setOperator(_newOperator);\n    }\n\n    /// @notice When the fee recipient is set\n    /// @param oldFeeRecipient Old fee recipient address\n    /// @param newFeeRecipient New fee recipient address\n    event SetFeeRecipient(address oldFeeRecipient, address newFeeRecipient);\n\n    /// @notice Where redemption and early exit fees go\n    /// @param _newFeeRecipient New fee recipient address\n    function setFeeRecipient(address _newFeeRecipient) external {\n        _requireSenderIsTimelock();\n\n        emit SetFeeRecipient({ oldFeeRecipient: feeRecipient, newFeeRecipient: _newFeeRecipient });\n\n        feeRecipient = _newFeeRecipient;\n    }\n\n    // =============================================================================================\n    // Queue Functions\n    // =============================================================================================\n\n    /// @notice When someone enters the redemption queue\n    /// @param nftId The ID of the NFT\n    /// @param sender The address of the msg.sender, who is redeeming frxEth\n    /// @param recipient The recipient of the NFT\n    /// @param amountFrxEthRedeemed The amount of frxEth redeemed\n    /// @param maturityTimestamp The date of maturity, upon which redemption is allowed\n    /// @param redemptionFeeAmount The redemption fee\n    /// @param earlyExitFee The early exit fee at the time of minting\n    event EnterRedemptionQueue(\n        uint256 indexed nftId,\n        address indexed sender,\n        address indexed recipient,\n        uint256 amountFrxEthRedeemed,\n        uint120 redemptionFeeAmount,\n        uint64 maturityTimestamp,\n        uint256 earlyExitFee\n    );\n\n    /// @notice Enter the queue for redeeming frxEth 1-to-1 for Eth, without the need to approve first (EIP-712 / EIP-2612)\n    /// @notice Will generate a FrxEthRedemptionTicket NFT that can be redeemed for the actual Eth later.\n    /// @param _amountToRedeem Amount to redeem\n    /// @param _recipient Recipient of the NFT. Must be ERC721 compatible if a contract\n    /// @param _deadline Deadline for this signature\n    function enterRedemptionQueueWithPermit(\n        uint120 _amountToRedeem,\n        address _recipient,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external {\n        // Call the permit\n        FRX_ETH.permit({\n            owner: msg.sender,\n            spender: address(this),\n            value: _amountToRedeem,\n            deadline: _deadline,\n            v: _v,\n            r: _r,\n            s: _s\n        });\n\n        // Do the redemption\n        enterRedemptionQueue({ _recipient: _recipient, _amountToRedeem: _amountToRedeem });\n    }\n\n    /// @notice Enter the queue for redeeming frxETH 1-to-1. Must approve first.\n    /// @notice Will generate a FrxETHRedemptionTicket NFT that can be redeemed for the actual ETH later.\n    /// @param _recipient Recipient of the NFT. Must be ERC721 compatible if a contract\n    /// @param _amountToRedeem Amount to redeem\n    /// @dev Must call approve/permit on frxEth contract prior to this call\n    function enterRedemptionQueue(address _recipient, uint120 _amountToRedeem) public nonReentrant {\n        // Get queue information\n        RedemptionQueueState memory _redemptionQueueState = redemptionQueueState;\n        RedemptionQueueAccounting memory _redemptionQueueAccounting = redemptionQueueAccounting;\n\n        // Calculations: redemption fee\n        uint120 _redemptionFeeAmount = ((uint256(_amountToRedeem) * _redemptionQueueState.redemptionFee) /\n            FEE_PRECISION).toUint120();\n\n        // Calculations: amount of ETH owed to the user\n        uint120 _amountEtherOwedToUser = _amountToRedeem - _redemptionFeeAmount;\n\n        // Calculations: increment ether liabilities by the amount of ether owed to the user\n        _redemptionQueueAccounting.etherLiabilities += uint128(_amountEtherOwedToUser);\n\n        // Calculations: increment unclaimed fees by the redemption fee taken\n        _redemptionQueueAccounting.unclaimedFees += _redemptionFeeAmount;\n\n        // Calculations: maturity timestamp\n        uint64 _maturityTimestamp = uint64(block.timestamp) + _redemptionQueueState.queueLengthSecs;\n\n        // Effects: Initialize the redemption ticket NFT information\n        nftInformation[_redemptionQueueState.nextNftId] = RedemptionQueueItem({\n            amount: _amountEtherOwedToUser,\n            maturity: _maturityTimestamp,\n            hasBeenRedeemed: false,\n            earlyExitFee: _redemptionQueueState.earlyExitFee\n        });\n\n        // Effects: Mint the redemption ticket NFT. Make sure the recipient supports ERC721.\n        _safeMint({ to: _recipient, tokenId: _redemptionQueueState.nextNftId });\n\n        // Emit here, before the state change\n        emit EnterRedemptionQueue({\n            nftId: _redemptionQueueState.nextNftId,\n            sender: msg.sender,\n            recipient: _recipient,\n            amountFrxEthRedeemed: _amountToRedeem,\n            redemptionFeeAmount: _redemptionFeeAmount,\n            maturityTimestamp: _maturityTimestamp,\n            earlyExitFee: _redemptionQueueState.earlyExitFee\n        });\n\n        // Calculations: Increment the autoincrement\n        ++_redemptionQueueState.nextNftId;\n\n        // Effects: Write all of the state changes to storage\n        redemptionQueueState = _redemptionQueueState;\n\n        // Effects: Write all of the accounting changes to storage\n        redemptionQueueAccounting = _redemptionQueueAccounting;\n\n        // Interactions: Transfer frxEth from sender\n        IERC20(address(FRX_ETH)).safeTransferFrom({ from: msg.sender, to: address(this), value: _amountToRedeem });\n    }\n\n    /// @notice When someone early redeems their NFT for frxETH, with the penalty\n    /// @param nftId The ID of the NFT\n    /// @param sender The sender of the NFT\n    /// @param recipient The recipient of the redeemed ETH\n    /// @param frxEthOut The amount of frxETH actually sent back to the user\n    /// @param earlyExitFeeAmount Any penalty fee paid for exiting early\n    event EarlyBurnRedemptionTicketNft(\n        uint256 indexed nftId,\n        address indexed sender,\n        address indexed recipient,\n        uint120 frxEthOut,\n        uint120 earlyExitFeeAmount\n    );\n\n    /// @notice Redeems a FrxETHRedemptionTicket NFT early for frxETH, not ETH. Is penalized in doing so. Used if person does not want to wait for exit anymore.\n    /// @param _nftId The ID of the NFT\n    /// @param _recipient The recipient of the redeemed ETH\n    /// @return _frxEthOut The amount of frxETH actually sent back to the user\n    function earlyBurnRedemptionTicketNft(\n        address payable _recipient,\n        uint256 _nftId\n    ) external nonReentrant returns (uint120 _frxEthOut) {\n        // Checks: ensure proper nft ownership\n        if (!_isApprovedOrOwner({ spender: msg.sender, tokenId: _nftId })) revert Erc721CallerNotOwnerOrApproved();\n\n        // Get data from state for use in calculations\n        RedemptionQueueAccounting memory _redemptionQueueAccounting = redemptionQueueAccounting;\n        RedemptionQueueItem memory _redemptionQueueItem = nftInformation[_nftId];\n        uint120 _amountToRedeem = _redemptionQueueItem.amount;\n\n        // Calculations: remove owed ether from the liabilities\n        _redemptionQueueAccounting.etherLiabilities -= _amountToRedeem;\n\n        // Calculations: determine the early exit fee\n        uint120 _earlyExitFeeAmount = ((uint256(_amountToRedeem) * _redemptionQueueItem.earlyExitFee) / FEE_PRECISION)\n            .toUint120();\n\n        // Calculations: increment unclaimedFees\n        _redemptionQueueAccounting.unclaimedFees += uint128(_earlyExitFeeAmount);\n\n        // Calculations: Amount of frxETH back to the recipient, minus the fees\n        _frxEthOut = _amountToRedeem - _earlyExitFeeAmount;\n\n        // Effects: burn the nft\n        _burn(_nftId);\n\n        // Effects: Write back accounting to state\n        redemptionQueueAccounting = _redemptionQueueAccounting;\n\n        // Effects: Mark nft as redeemed\n        nftInformation[_nftId].hasBeenRedeemed = true;\n\n        emit EarlyBurnRedemptionTicketNft({\n            sender: msg.sender,\n            recipient: _recipient,\n            nftId: _nftId,\n            frxEthOut: _frxEthOut,\n            earlyExitFeeAmount: _earlyExitFeeAmount\n        });\n\n        // Interactions: transfer frxEth\n        IERC20(address(FRX_ETH)).safeTransfer({ to: _recipient, value: _frxEthOut });\n    }\n\n    /// @notice When someone redeems their NFT for ETH\n    /// @param nftId the if of the nft redeemed\n    /// @param sender the msg.sender\n    /// @param recipient the recipient of the ether\n    /// @param amountOut the amount of ether sent to the recipient\n    event BurnRedemptionTicketNft(uint256 indexed nftId, address indexed sender, address indexed recipient,  uint120 amountOut);\n\n    /// @notice Redeems a FrxETHRedemptionTicket NFT for ETH. Must have reached the maturity date first.\n    /// @param _nftId The ID of the NFT\n    /// @param _recipient The recipient of the redeemed ETH\n    function burnRedemptionTicketNft(uint256 _nftId, address payable _recipient) external nonReentrant {\n        // Checks: ensure proper nft ownership\n        if (!_isApprovedOrOwner({ spender: msg.sender, tokenId: _nftId })) revert Erc721CallerNotOwnerOrApproved();\n\n        // Get queue information\n        RedemptionQueueItem memory _redemptionQueueItem = nftInformation[_nftId];\n\n        // Checks: Make sure maturity was reached\n        if (block.timestamp < _redemptionQueueItem.maturity) {\n            revert NotMatureYet({ currentTime: block.timestamp, maturity: _redemptionQueueItem.maturity });\n        }\n\n        // Effects: Subtract the amount from total liabilities\n        redemptionQueueAccounting.etherLiabilities -= _redemptionQueueItem.amount;\n\n        // Effects: burn the Nft\n        _burn(_nftId);\n\n        // Effects: Mark nft as redeemed\n        nftInformation[_nftId].hasBeenRedeemed = true;\n\n        // Effects: Burn frxEth to match the amount of ether sent to user 1:1\n        FRX_ETH.burn(_redemptionQueueItem.amount);\n\n        // Interactions: Transfer ETH to recipient, minus the fee\n        (bool _success, ) = _recipient.call{ value: _redemptionQueueItem.amount }(\"\");\n        if (!_success) revert InvalidEthTransfer();\n\n        emit BurnRedemptionTicketNft({\n            nftId: _nftId,\n            sender: msg.sender,\n            recipient: _recipient,\n            amountOut: _redemptionQueueItem.amount\n        });\n    }\n\n    // ====================================\n    // Internal Functions\n    // ====================================\n\n    /// @notice Checks if msg.sender is current timelock address or the operator\n    function _requireIsTimelockOrOperator() internal view {\n        if (!((msg.sender == timelockAddress) || (msg.sender == operatorAddress))) revert NotTimelockOrOperator();\n    }\n\n    // ====================================\n    // Errors\n    // ====================================\n\n    /// @notice ERC721: caller is not token owner or approved\n    error Erc721CallerNotOwnerOrApproved();\n\n    /// @notice When timelock/operator tries collecting more fees than they are due\n    /// @param collectAmount How much fee the ounsender is trying to collect\n    /// @param accruedAmount How much fees are actually collectable\n    error ExceedsCollectedFees(uint128 collectAmount, uint128 accruedAmount);\n\n    /// @notice When someone tries setting the early exit fee above the max (100%)\n    /// @param providedFee The provided early exit fee\n    /// @param maxFee The maximum early exit fee\n    error ExceedsMaxEarlyExitFee(uint64 providedFee, uint64 maxFee);\n\n    /// @notice When someone tries setting the queue length above the max\n    /// @param providedLength The provided queue length\n    /// @param maxLength The maximum queue length\n    error ExceedsMaxQueueLengthSecs(uint64 providedLength, uint256 maxLength);\n\n    /// @notice When someone tries setting the redemption fee above the max (100%)\n    /// @param providedFee The provided redemption fee\n    /// @param maxFee The maximum redemption fee\n    error ExceedsMaxRedemptionFee(uint64 providedFee, uint64 maxFee);\n\n    /// @notice Invalid ETH transfer during recoverEther\n    error InvalidEthTransfer();\n\n    /// @notice NFT is not mature enough to redeem yet\n    /// @param currentTime Current time.\n    /// @param maturity Time of maturity\n    error NotMatureYet(uint256 currentTime, uint64 maturity);\n\n    /// @notice Thrown if the sender is not the timelock or the operator\n    error NotTimelockOrOperator();\n}"
    },
    {
      "filename": "src/contracts/FraxEtherRedemptionQueue.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n// ====================================================================\n// |     ______                   _______                             |\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\/ __ `/ __ \\/ ___/ _ \\  |\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\n// | /_/   /_/   \\__,_/_/|_|  /_/   /_/_/ /_/\\__,_/_/ /_/\\___/\\___/   |\n// |                                                                  |\n// ====================================================================\n// ===================== FraxEtherRedemptionQueue =====================\n// ====================================================================\n// Users wishing to exchange frxETH for ETH 1-to-1 will need to deposit their frxETH and wait to redeem it.\n// When they do the deposit, they get an NFT with a maturity time as well as an amount.\n\n// Frax Finance: https://github.com/FraxFinance\n\n// Primary Author\n// Drake Evans: https://github.com/DrakeEvans\n// Travis Moore: https://github.com/FortisFortuna\n\n// Reviewer(s) / Contributor(s)\n// Dennis: https://github.com/denett\n// Sam Kazemian: https://github.com/samkazemian\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { Timelock2Step } from \"frax-std/access-control/v2/Timelock2Step.sol\";\nimport { OperatorRole } from \"frax-std/access-control/v2/OperatorRole.sol\";\nimport { IFrxEth } from \"./IFrxEth.sol\";\n\n/// @notice Used by the constructor\n/// @param timelockAddress Address of the timelock, which the main owner of the this contract\n/// @param operatorAddress Address of the operator, which does other tasks\n/// @param frxEthAddress Address of frxEth Erc20\n/// @param initialQueueLengthSecondss Initial length of the queue, in seconds\nstruct FraxEtherRedemptionQueueParams {\n    address timelockAddress;\n    address operatorAddress;\n    address frxEthAddress;\n    uint32 initialQueueLengthSeconds;\n}\n\ncontract FraxEtherRedemptionQueue is ERC721, Timelock2Step, OperatorRole, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using SafeCast for *;\n\n    // ==============================================================================\n    // Storage\n    // ==============================================================================\n\n    // Tokens\n    // ================\n    /// @notice The frxETH token\n    IFrxEth public immutable FRX_ETH;\n\n    // Queue-Related\n    // ================\n    /// @notice State of Frax's frxETH redemption queue\n    RedemptionQueueState public redemptionQueueState;\n\n    /// @notice State of Frax's frxETH redemption queue\n    /// @param etherLiabilities How much ETH is currently under request to be redeemed\n    /// @param nextNftId Autoincrement for the NFT id\n    /// @param queueLengthSecs Current wait time (in seconds) a new redeemer would have. Should be close to Beacon.\n    /// @param redemptionFee Redemption fee given as a percentage with 1e6 precision\n    /// @param earlyExitFee Early NFT back to frxETH exit fee given as a percentage with 1e6 precision\n    struct RedemptionQueueState {\n        uint64 nextNftId;\n        uint64 queueLengthSecs;\n        uint64 redemptionFee;\n        uint64 earlyExitFee;\n    }\n\n    /// @notice Accounting of Frax's frxETH redemption queue\n    RedemptionQueueAccounting public redemptionQueueAccounting;\n\n    /// @param etherLiabilities How much ETH would need to be paid out if every NFT holder could claim immediately\n    /// @param unclaimedFees Earned fees that the protocol has not collected yet\n    struct RedemptionQueueAccounting {\n        uint128 etherLiabilities;\n        uint128 unclaimedFees;\n    }\n\n    /// @notice Information about a user's redemption ticket NFT\n    mapping(uint256 nftId => RedemptionQueueItem) public nftInformation;\n\n    /// @notice The ```RedemptionQueueItem``` struct provides metadata information about each Nft\n    /// @param hasBeenRedeemed boolean for whether the NFT has been redeemed\n    /// @param amount How much ETH is claimable\n    /// @param maturity Unix timestamp when they can claim their ETH\n    /// @param earlyExitFee EarlyExitFee at time of NFT mint\n    struct RedemptionQueueItem {\n        bool hasBeenRedeemed;\n        uint64 maturity;\n        uint120 amount;\n        uint64 earlyExitFee;\n    }\n\n    /// @notice Maximum queue length the operator can set given in seconds\n    uint256 public maxOperatorQueueLengthSeconds = 100 days;\n\n    /// @notice The precision of the redemption fee\n    uint64 public constant FEE_PRECISION = 1e6;\n\n    /// @notice The fee recipient for various fees\n    address public feeRecipient;\n\n    // ==============================================================================\n    // Constructor\n    // ==============================================================================\n\n    /// @notice Constructor\n    /// @param _params The contructor FraxEtherRedemptionQueueParams params\n    constructor(\n        FraxEtherRedemptionQueueParams memory _params\n    )\n        payable\n        ERC721(\"FrxETHRedemptionTicket\", \"FrxETH Redemption Queue Ticket\")\n        OperatorRole(_params.operatorAddress)\n        Timelock2Step(_params.timelockAddress)\n    {\n        redemptionQueueState.queueLengthSecs = _params.initialQueueLengthSeconds;\n        FRX_ETH = IFrxEth(_params.frxEthAddress);\n    }\n\n    /// @notice Allows contract to receive Eth\n    receive() external payable {\n        // Do nothing except take in the Eth\n    }\n\n    // =============================================================================================\n    // Configurations / Privileged functions\n    // =============================================================================================\n\n    /// @notice When the accrued redemption fees are collected\n    /// @param recipient The address to receive the fees\n    /// @param collectAmount Amount of fees collected\n    event CollectRedemptionFees(address recipient, uint128 collectAmount);\n\n    /// @notice Collect redemption fees\n    /// @param _collectAmount Amount of frxEth to collect\n    function collectRedemptionFees(uint128 _collectAmount) external {\n        // Make sure the sender is either the timelock or the operator\n        _requireIsTimelockOrOperator();\n\n        uint128 _unclaimedFees = redemptionQueueAccounting.unclaimedFees;\n\n        // Make sure you are not taking too much\n        if (_collectAmount > _unclaimedFees) revert ExceedsCollectedFees(_collectAmount, _unclaimedFees);\n\n        // Decrement the unclaimed fee amount\n        redemptionQueueAccounting.unclaimedFees -= _collectAmount;\n\n        // Interactions: Transfer frxEth fees to the recipient\n        IERC20(address(FRX_ETH)).safeTransfer({ to: feeRecipient, value: _collectAmount });\n\n        emit CollectRedemptionFees({ recipient: feeRecipient, collectAmount: _collectAmount });\n    }\n\n    /// @notice When the timelock or operator recovers ERC20 tokens mistakenly sent here\n    /// @param recipient Address of the recipient\n    /// @param token Address of the erc20 token\n    /// @param amount Amount of the erc20 token recovered\n    event RecoverErc20(address recipient, address token, uint256 amount);\n\n    /// @notice Recovers ERC20 tokens mistakenly sent to this contract\n    /// @param _tokenAddress Address of the token\n    /// @param _tokenAmount Amount of the token\n    function recoverErc20(address _tokenAddress, uint256 _tokenAmount) external {\n        _requireSenderIsTimelock();\n        IERC20(_tokenAddress).safeTransfer({ to: msg.sender, value:"
    }
  ]
}