{
  "Title": "H-4: Staking#_unstake removes votes from wrong person if msg.sender != owner",
  "Content": "# Issue H-4: Staking#_unstake removes votes from wrong person if msg.sender != owner \n\nSource: https://github.com/sherlock-audit/2022-11-frankendao-judging/issues/30 \n\n## Found by \n0x52, cccz\n\n## Summary\n\nStaking#_unstake allows any msg.sender to unstake tokens for any owner that has approved them. The issue is that even when msg.sender != owner the votes are removed from msg.sender instead of owner. The result is that the owner keeps their votes and msg.sender loses theirs. This could be abused to hijack or damage voting.\n\n## Vulnerability Detail\n\n    address owner = ownerOf(_tokenId);\n    if (msg.sender != owner && !isApprovedForAll[owner][msg.sender] && msg.sender != getApproved[_tokenId]) revert NotAuthorized();\n\nStaking#_unstake allows any msg.sender to unstake tokens for any owner that has approved them.\n\n    uint lostVotingPower;\n    for (uint i = 0; i < numTokens; i++) {\n        lostVotingPower += _unstakeToken(_tokenIds[i], _to);\n    }\n\n    votesFromOwnedTokens[msg.sender] -= lostVotingPower;\n    // Since the delegate currently has the voting power, it must be removed from their balance\n    // If the user doesn't delegate, delegates(msg.sender) will return self\n    tokenVotingPower[getDelegate(msg.sender)] -= lostVotingPower;\n    totalTokenVotingPower -= lostVotingPower;\n\nAfter looping through _unstakeToken all accumulated votes are removed from msg.sender. The problem with this is that msg.sender is allowed to unstake tokens for users other than themselves and in these cases they will lose votes rather than the user who owns the token.\n\nExample:\nUser A and User B both stake tokens and have 10 votes each. User A approves User B to unstake their tokens. User B calls unstake for User A. User B is msg.sender and User A is owner. The votes should be removed from owner but instead are removed from msg.sender. The result is that after unstaking User B has a vote balance of 0 while still having their locked token and User B has a vote balance of 10 and their token back. Now User B is unable to unstake their token because their votes will underflow on unstake, permanently trapping their NFT.\n\n## Impact\n\nVotes are removed incorrectly if msg.sender != owner. By extension this would forever trap msg.sender tokens in the contract.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-frankendao/blob/main/src/Staking.sol#L427-L458\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nRemove the ability for users to unstake for other users\n\n## Discussion\n\n**zobront**\n\nFixed: https://github.com/Solidity-Guild/FrankenDAO/pull/14\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/18",
  "Code": [
    {
      "filename": "src/Staking.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/**\n _______  _______  _______  _        _        _______  _          _______           _        _        _______\n(  ____ \\(  ____ )(  ___  )( (    /|| \\    /\\(  ____ \\( (    /|  (  ____ )|\\     /|( (    /|| \\    /\\(  ____ \\\n| (    \\/| (    )|| (   ) ||  \\  ( ||  \\  / /| (    \\/|  \\  ( |  | (    )|| )   ( ||  \\  ( ||  \\  / /| (    \\/\n| (__    | (____)|| (___) ||   \\ | ||  (_/ / | (__    |   \\ | |  | (____)|| |   | ||   \\ | ||  (_/ / | (_____\n|  __)   |     __)|  ___  || (\\ \\) ||   _ (  |  __)   | (\\ \\) |  |  _____)| |   | || (\\ \\) ||   _ (  (_____  )\n| (      | (\\ (   | (   ) || | \\   ||  ( \\ \\ | (      | | \\   |  | (      | |   | || | \\   ||  ( \\ \\       ) |\n| )      | ) \\ \\__| )   ( || )  \\  ||  /  \\ \\| (____/\\| )  \\  |  | )      | (___) || )  \\  ||  /  \\ \\/\\____) |\n|/       |/   \\__/|/     \\||/    )_)|_/    \\/(_______/|/    )_)  |/       (_______)|/    )_)|_/    \\/\\_______)\n\n*/\n\nimport \"solmate/tokens/ERC721.sol\";\nimport \"solmate/utils/LibString.sol\";\nimport \"./utils/SafeCast.sol\";\nimport \"./utils/Refundable.sol\";\nimport \"./utils/Admin.sol\";\n\nimport \"./interfaces/IERC721.sol\";\nimport \"./interfaces/IStaking.sol\";\nimport \"./interfaces/IGovernance.sol\";\nimport \"./interfaces/IExecutor.sol\";\n\n/// @title FrankenDAO Staking\n/// @author Zach Obront & Zakk Fleischmann\n/// @notice Users stake FrankenPunks & FrankenMonsters and get ERC721s in return\n/// @notice These ERC721s are used for voting power for FrankenDAO governance\ncontract Staking is IStaking, ERC721, Admin, Refundable {\n  using LibString for uint256;\n\n  /// @notice The original ERC721 FrankenPunks contract\n  IERC721 frankenpunks;\n  \n  /// @notice The original ERC721 FrankenMonsters contract\n  IERC721 frankenmonsters;\n\n  /// @notice The DAO governance contract (where voting occurs)\n  IGovernance governance;\n\n  /// @return maxStakeBonusTime The maxmimum time you will earn bonus votes for staking for\n  /// @return maxStakeBonusAmount The amount of bonus votes you'll get if you stake for the max time\n  StakingSettings public stakingSettings;\n\n  /// @notice Multipliers (expressed as percentage) for calculating community voting power from user stats\n  /// @return votes The multiplier for extra voting power earned per DAO vote cast\n  /// @return proposalsCreated The multiplier for extra voting power earned per proposal created\n  /// @return proposalsPassed The multiplier for extra voting power earned per proposal passed\n  CommunityPowerMultipliers public communityPowerMultipliers;\n\n  /// @notice Constant to calculate voting power based on multipliers above\n  uint constant PERCENT = 100;\n\n  /// @notice Are refunds turned on for staking?\n  bool public stakingRefund;\n\n  /// @notice The last timestamp at which a user used their staking refund\n  mapping(address => uint256) public lastStakingRefund;\n\n  /// @notice Are refunds turned on for delegating?\n  bool public delegatingRefund;\n\n  /// @notice The last timestamp at which a user used their delegating refund\n  mapping(address => uint256) public lastDelegatingRefund;\n\n  /// @notice How often can a user use their refund?\n  uint256 public refundCooldown;\n\n  /// @notice Is staking currently paused or open?\n  bool public paused;\n\n  /// @notice Base votes for holding a Frankenpunk token\n  uint public baseVotes;\n\n  /// @notice The staked time bonus for each staked token (tokenId => bonus votes)\n  /// @dev This needs to be tracked because users will select how much time to lock for, so bonus is variable\n  mapping(uint => uint) stakedTimeBonus; \n  \n  /// @notice The allowed unlock time for each staked token (tokenId => timestamp)\n  /// @dev This remains at 0 if tokens are staked without locking\n  mapping(uint => uint) public unlockTime;\n\n  /// @notice Multiplier for votes that Frankenmonsters earn, relative to Frankenpunks\n  /// @dev Expressed as a percentage (ie punk votes * monsterMultiplier / 100 = monster votes)\n  uint public monsterMultiplier;\n\n  /// @notice Addresses that each user delegates votes to\n  /// @dev This should only be accessed via getDelegate() function, which overrides address(0) with self\n  mapping(address => address) private _delegates;\n\n  /// @notice The total voting power earned by each user's staked tokens\n  /// @dev In other words, this is the amount of voting power that would move if they redelegated\n  /// @dev They don't necessarily have this many votes, because they may have delegated them\n  mapping(address => uint) public votesFromOwnedTokens;\n\n  /// @notice The total voting power each user has, after adjusting for delegation\n  /// @dev This represents the actual token voting power of each user\n  mapping(address => uint) public tokenVotingPower;\n\n  /// @notice The total token voting power of the system\n  uint totalTokenVotingPower;\n\n  /// @notice Base token URI for the ERC721s representing the staked position\n  string public baseTokenURI;\n\n  /// @notice The total supply of staked frankenpunks\n  uint128 public stakedFrankenPunks;\n\n  /// @notice The total supply of staked frankenmonsters\n  uint128 public stakedFrankenMonsters;\n\n  /// @notice Bitmaps representing whether each FrankenPunk has a sufficient \"evil score\" for a bonus.\n  /// @dev 40 words * 256 bits = 10,240 bits, which is sufficient to hold values for 10k FrankenPunks\n  uint[40] EVIL_BITMAPS = [\n    883425322698150530263834307704826599123904599330160270537777278655401984, // 0\n    14488147225470816109160058996749687396265978336526515174837584423109802852352, // 1\n    38566513062215815139428642218823858442255833421860837338906624, // 2\n    105312291668557186697918027683670432324476705909712387428719788032, // 3\n    14474011154664524427946373126085988481660077311200856629730921422678596263936, // 4\n    3618502788692465607655909614339766499850336868450542774889103259212619972609, // 5\n    441711772776714745308416192199486840791445460561420424832198410539892736, // 6\n    6901746759773641161995257390185172072446268286034776944761674561224712, // 7\n    883423532414903565819785182543377466397133986207912949084155019599544320, // 8\n    14474011155086185177904289442148664541270784730116237084843513087002589265920, // 9\n    107839786668798718607898896909541540930351713584408019687362806153216, // 10\n    904625700641838402593673198335004289144275540958779302917589231213362556944, // 11\n    220859253090631447287862539909960206022391538433640386622889848771706880, // 12\n    1393839110204029063653915313866451565150208, // 13\n    784637716923340670665773318162647287385528792673206407169, // 14\n    107839786668602559178668060353525740564723109496935832847049186869248, // 15\n    51422802054004612152481822571560984362335820545231474237898784, // 16\n    6582018229284824169333500576582381960460086447259084614308728832, // 17\n    365732221255902219560809532335122355265736818688, // 18\n    445162639419413381705829464770174011933371831432841644599383048677490688, // 19\n    6935446280124502090171244984389489167294584349705235353545399909482504, // 20\n    452312848583266388373372050675839373643513806386188657447441353755011973120, // 21\n    51422023594160337932957247212003666383914706547133656225284128, // 22\n    2923003274661805998666646494941077336069228208128, // 23\n    215679573337205118357336126271343355406346657833909405071980653182976, // 24\n    26959946667150639794667015087041235820865508444839585222888876146720, // 25\n    3731581108651760187459529718884681603688140590625042088037390915407571845120, // 26\n    33372889303170710042455474178259135664197736114694375141005066752, // 27\n    28948022309329151699928351061631107912622119818910282538292189430411643863044, // 28\n    55214023430470347690952963241066788995217469738067023806554216123598848, // 29\n    55213971185700649632772712790212230970723509677757939395778641765335297, // 30\n    50216813883139118038214077107913983031541181002059654103040, // 31\n    45671926166601100787582220677640905906662146176, // 32\n    431359146674410260659915067596052074490887103277477952745659311325184, // 33\n    6741683593362397442763285474207733540211166501858783908538903166976, // 34\n    421249166674235107246797774824181756792478284093098635821743865856, // 35\n    53919893334350319447007114026840783409769671338355940037889148190720, // 36\n    401740641047276407850947922339698016834483256774579142524928, // 37\n    220855883097304318299647574273628650268020954052697685772267193358090240, // 38\n    0 // 39\n  ];\n\n  /////////////////////////////////\n  /////////// MODIFIERS ///////////\n  /////////////////////////////////\n\n  /// @dev To avoid needing to checkpoint voting power, tokens are locked while users have active votes cast or proposals open\n  /// @dev If a user creates a proposal or casts a vote, this modifier prevents them from unstaking or delegating\n  /// @dev Once the proposal is completed, it is removed from getActiveProposals and their tokens are unlocked\n  modifier lockedWhileVotesCast() {\n    uint[] memory activeProposals = governance.getActiveProposals();\n    for (uint i = 0; i < activeProposals.length; i++) {\n      if (governance.getReceipt(activeProposals[i], getDelegate(msg.sender)).hasVoted) revert TokenLocked();\n      (, address proposer,) = governance.getProposalData(activeProposals[i]);\n      if (proposer == getDelegate(msg.sender)) revert TokenLocked();\n    }\n    _;\n  }\n\n  /////////////////////////////////\n  ////////// CONSTRUCTOR //////////\n  /////////////////////////////////\n\n  /// @param _frankenpunks The address of the original ERC721 FrankenPunks contract\n  /// @param _frankenmonsters The address of the original ERC721 FrankenMonsters contract\n  /// @param _governance The address of the DAO governance contract\n  /// @param _executor The address of the DAO executor contract\n  /// @param _founders The address of the founder multisig for restricted functions\n  /// @param _council The address of the council multisig for restricted functions\n  constructor(\n    address _frankenpunks, \n    address _frankenmonsters,\n    address _governance, \n    address _executor, \n    address _founders,\n    address _council,\n    string memory _baseTokenURI\n  ) ERC721(\"Staked FrankenPunks\", \"sFP\") {\n    frankenpunks = IERC721(_frankenpunks);\n    frankenmonsters = IERC721(_frankenmonsters);\n    governance = IGovernance( _governance );\n\n    executor = IExecutor(_executor);\n    founders = _founders;\n    council = _council;\n\n    baseVotes = 20; // Base votes for a staked token\n    monsterMultiplier = 50; // Monsters are worth 50% of Punks\n\n    // Staking bonus increases linearly from 0 to 20 votes over 4 weeks\n    stakingSettings = StakingSettings({\n      maxStakeBonusTime: uint128(4 weeks), \n      maxStakeBonusAmount: uint128(20)\n    });\n\n    // Users get a bonus 1 vote per vote, 2 votes per proposal created, and 2 votes per proposal passed\n    communityPowerMultipliers = CommunityPowerMultipliers({\n      votes: uint64(100), \n      proposalsCreated: uint64(200),\n      proposalsPassed: uint64(200)\n    });\n\n    // Refunds are initially turned on with 1 day cooldown.\n    delegatingRefund = true;\n    stakingRefund = true;\n    refundCooldown = 1 days;\n\n    // Set the base token URI.\n    baseTokenURI = _baseTokenURI;\n  }\n\n  /////////////////////////////////\n  // OVERRIDE & REVERT TRANSFERS //\n  /////////////////////////////////  \n\n  /// @notice Transferring of staked tokens is prohibited, so all transfers will revert\n  /// @dev This will also block safeTransferFrom, because of solmate's implementation\n  function transferFrom(address, address, uint256) public pure override(ERC721) {\n    revert StakedTokensCannotBeTransferred();\n  }\n\n  /////////////////////////////////\n  /////// TOKEN URI FUNCTIONS /////\n  /////////////////////////////////\n\n  /// @notice Token URI to find metadata for each tokenId\n  /// @dev The metadata will be a variation on the metadata of the underlying token\n  function tokenURI(uint256 _tokenId) public view virtual override(ERC721) returns (string memory) {\n    if (ownerOf(_tokenId) == address(0)) revert NonExistentToken();\n\n    string memory baseURI = baseTokenURI;\n    return bytes(baseURI).length > 0\n      ? string(abi.encodePacked(baseURI, _tokenId.toString(), \".json\"))\n      : \"\";\n  }\n  \n  /////////////////////////////////\n  /////// DELEGATION LOGIC ////////\n  /////////////////////////////////\n\n  /// @notice Return the address that a given address delegates to\n  /// @param _delegator The address to check \n  /// @return The address that the delegator has delegated to\n  /// @dev If the delegator has not delegated, this function will return their own address\n  function getDelegate(address _delegator) public view returns (address) {\n    address current = _delegates[_delegator];\n    return current == address(0) ? _delegator : current;\n  }\n\n  /// @notice Delegate votes to another address\n  /// @param _delegatee The address you wish to delegate to\n  /// @dev Refunds gas if delegatingRefund is true and hasn't been used by this user in the past 24 hours\n  function delegate(address _delegatee) public {\n    if (_delegatee == address(0)) _delegatee = msg.sender;\n    \n    // Refunds gas if delegatingRefund is true and hasn't been used by this user in the past 24 hours\n    if (delegatingRefund && lastDelegatingRefund[msg.sender] + refundCooldown <= block.timestamp) {\n      uint256 startGas = gasleft();\n      _delegate(msg.sender, _delegatee);\n      lastDelegatingRefund[msg.sender] = block.timestamp;\n      _refundGas(startGas);\n    } else {\n      _delegate(msg.sender, _delegatee);\n    }\n  }\n\n  /// @notice Delegates votes from the sender to the delegatee\n  /// @param _delegator The address of the user who called the function and owns the votes being delegated\n  /// @param _delegatee The address of the user who will receive the votes\n  function _delegate(address _delegator, address _delegatee) internal lockedWhileVotesCast {\n    address currentDelegate = getDelegate(_delegator);\n    // If currentDelegate == _delegatee, then this function will not do anything\n    if (currentDelegate == _delegatee) revert InvalidDelegation();\n\n    // Set the _delegates mapping to the correct address, subbing in address(0) if they are delegating to themselves\n    _delegates[_delegator] = _delegatee == _delegator ? address(0) : _delegatee;\n    uint amount = votesFromOwnedTokens[_delegator];\n\n    // If the delegator has no votes, then this function will not do anything\n    // This is explicitly blocked to ensure that users without votes cannot abuse the refund mechanism\n    if (amount == 0) revert InvalidDelegation();\n    \n    // Move the votes from the currentDelegate to the new delegatee\n    // Neither of these addresses can be address(0) because: \n    // - currentDelegate calls getDelegate(), which replaces address(0) with the delegator's address\n    // - delegatee is changed to msg.sender in the external functions if address(0) is passed\n    tokenVotingPower[currentDelegate] -= amount;\n    tokenVotingPower[_delegatee] += amount; \n\n    // If a user is delegating back to themselves, they regain their community voting power, so adjust totals up\n    if (_delegator == _delegatee) {\n      _updateTotalCommunityVotingPower(_delegator, true);\n\n    // If a user delegates away their votes, they forfeit their community voting power, so adjust totals down\n    } else if (currentDelegate == _delegator) {\n      _updateTotalCommunityVotingPower(_delegator, false);\n    }\n\n    emit DelegateChanged(_delegator, currentDelegate, _delegatee);\n  }\n\n  /// @notice Updates the total community voting power totals\n  /// @param _delegator The address of the user who called the function and owns the votes being delegated\n  /// @param _increase Should we be increasing or decreasing the totals?\n  /// @dev This function is called by _delegate, _stake, and _unstake\n  function _updateTotalCommunityVotingPower(address _delegator, bool _increase) internal {\n    (uint64 votes, uint64 proposalsCreated, uint64 proposalsPassed) = governance.userCommunityScoreData(_delegator);\n    (uint64 totalVotes, uint64 totalProposalsCreated, uint64 totalProposalsPassed) = governance.totalCommunityScoreData();\n\n    if (_increase) {\n      governance.updateTotalCommunityScoreData(totalVotes + votes, totalProposalsCreated + proposalsCreated, totalProposalsPassed + proposalsPassed);\n    } else {\n      governance.updateTotalCommunityScoreData(totalVotes - votes, totalProposalsCreated - proposalsCreated, totalProposalsPassed - proposalsPassed);\n    }\n  }\n\n  /////////////////////////////////\n  /// STAKE & UNSTAKE FUNCTIONS ///\n  /////////////////////////////////\n\n  /// @notice Stake your tokens to get voting power\n  /// @param _tokenIds An array of the id of the token you wish to stake\n  /// @param _unlockTime The timestamp of the time your tokens will be unlocked\n  /// @dev unlockTime can be set to 0 to stake without locking (and earn no extra staked time bonus)\n  function stake(uint[] calldata _tokenIds, uint _unlockTime) public {\n    // Refunds gas if stakingRefund is true and hasn't been used by this user in the past 24 hours\n    if (stakingRefund && lastStakingRefund[msg.sender] + refundCooldown <= block.timestamp) {\n      uint256 startGas = gasleft();\n      _stake(_tokenIds, _unlockTime);\n      lastStakingRefund[msg.sender] = block.timestamp;\n      _refundGas(startGas);\n    } else {\n      _stake(_tokenIds, _unlockTime);\n    }\n  }\n\n  /// @notice Internal function to stake tokens and get voting power\n  /// @param _tokenIds An array of the id of the tokens being staked\n  /// @param _unlockTime The timestamp of when the tokens will be unlocked\n  function _stake(uint[] calldata _tokenIds, uint _unlockTime) internal {\n    if (paused) revert Paused();\n    if (_unlockTime > 0 && _unlockTime < block.timestamp) revert InvalidParameter();\n\n    uint numTokens = _tokenIds.length;\n    // This is required to ensure the gas refunds are not abused\n    if (numTokens == 0) revert InvalidParameter();\n    \n    uint newVotingPower;\n    for (uint i = 0; i < numTokens; i++) {\n        newVotingPower += _stakeToken(_tokenIds[i], _unlockTime);\n    }\n\n    votesFromOwnedTokens[msg.sender] += newVotingPower;\n    tokenVotingPower[getDelegate(msg.sender)] += newVotingPower;\n    totalTokenVotingPower += newVotingPower;\n\n    // If the user had no tokenVotingPower before and doesn't delegate, they just unlocked their community voting power\n    // If their tokenVotingPower == newVotingPower, that means (a) it was 0 before and (b) they don't delegate, or it'd be 0 now\n    if (tokenVotingPower[msg.sender] == newVotingPower) {\n      // The user's community voting power is reactivated, so we add it to the total community voting power\n      _updateTotalCommunityVotingPower(msg.sender, true);\n    \n    // If their delegate had no tokenVotingPower before, then they just unlocked their community voting power\n    } else if (tokenVotingPower[getDelegate(msg.sender)] == newVotingPower) {\n      // The delegate's community voting power is reactivated, so we add it to the total community voting power\n      _updateTotalCommunityVotingPower(getDelegate(msg.sender), true);\n    }\n  }\n\n  /// @notice Internal function to stake a single token and get voting power\n  /// @param _tokenId The id of the token being staked\n  /// @param _unlockTime The timestamp of when the token will be unlocked\n  function _stakeToken(uint _tokenId, uint _unlockTime) internal returns (uint) {\n    if (_unlockTime > 0) {\n      unlockTime[_tokenId] = _unlockTime;\n      uint fullStakedTimeBonus = ((_unlockTime - block.timestamp) * stakingSettings.maxStakeBonusAmount) / stakingSettings.maxStakeBonusTime;\n      stakedTimeBonus[_tokenId] = _tokenId < 10000 ? fullStakedTimeBonus : fullStakedTimeBonus / 2;\n    }\n\n    // Transfer the underlying token from the owner to this contract\n    IERC721 collection;\n    if (_tokenId < 10000) {\n      collection = frankenpunks;\n      stakedFrankenPunks++;\n    } else {\n      collection = frankenmonsters;\n      stakedFrankenMonsters++;\n    }\n\n    address owner = collection.ownerOf(_tokenId);\n    if (msg.sender != owner && !collection.isApprovedForAll(owner, msg.sender) && msg.sender != collection.getApproved(_tokenId)) revert NotAuthorized();\n    collection.transferFrom(owner, address(this), _tokenId);\n\n    // Mint the staker a new ERC721 token representing their staked token\n    _mint(msg.sender, _tokenId);\n\n    // Return the voting power for this token based on staked time bonus and evil score\n    return getTokenVotingPower(_tokenId);\n  }\n\n  /// @notice Unstake your tokens and surrender voting power\n  /// @param _tokenIds An array of the ids of the tokens you wish to unstake\n  /// @param _to The address to send the underlying NFT to\n  function unstake(uint[] calldata _tokenIds, address _to) public {\n    _unstake(_tokenIds, _to);\n  }\n\n  /// @notice Internal function to unstake tokens and surrender voting power\n  /// @param _tokenIds An array of the ids of the tokens being unstaked\n  /// @param _to The address to send the underlying NFT to\n  function _unstake(uint[] calldata _tokenIds, address _to) internal lockedWhileVotesCast {\n    uint numTokens = _tokenIds.length;\n    if (numTokens == 0) revert InvalidParameter();\n    \n    uint lostVotingPower;\n    for (uint i = 0; i < numTokens; i++) {\n        lostVotingPower += _unstakeToken(_tokenIds[i], _to);\n    }\n\n    votesFromOwnedTokens[msg.sender] -= lostVotingPower;\n    // Since the delegate currently has the voting power, it must be removed from their balance\n    // If the user doesn't delegate, delegates(msg.sender) will return self\n    tokenVotingPower[getDelegate(msg.sender)] -= lostVotingPower;\n    totalTokenVotingPower -= lostVotingPower;\n\n    // If this unstaking reduced the user or their delegate's tokenVotingPower to 0, then someone just lost their community voting power\n    // First, check if the user is their own delegate\n    if (msg.sender == getDelegate(msg.sender)) {\n      // Did their tokenVotingPower just become 0?\n      if (tokenVotingPower[msg.sender] == 0) {\n        // If so, reduce the total voting power to capture this decrease in the user's community voting power\n        _updateTotalCommunityVotingPower(msg.sender, false);\n      }\n    // If they aren't their own delegate...\n    } else {\n      // If their delegate's tokenVotingPower reaches 0, that means they were the final unstake and the delegate loses community voting power\n      if (tokenVotingPower[getDelegate(msg.sender)] == 0) {\n        // The delegate's community voting power is forfeited, so we adjust total community power balances down\n        _updateTotalCommunityVotingPower(getDelegate(msg.sender), false);\n      }\n    }\n  }\n\n  /// @notice Internal function to unstake a single token and surrender voting power\n  /// @param _tokenId The id of the token being unstaked\n  /// @param _to The address to send the underlying NFT to\n  function _unstakeToken(uint _tokenId, address _to) internal returns(uint) {\n    address owner = ownerOf(_tokenId);\n    if (msg.sender != owner && !isApprovedForAll[owner][msg.sender] && msg.sender != getApproved[_tokenId]) revert NotAuthorized();\n    if (unlockTime[_tokenId] > block.timestamp) revert TokenLocked();\n    \n    // Transfer the underlying token from the owner to this contract\n    IERC721 collection;\n    if (_tokenId < 10000) {\n      collection = frankenpunks;\n      --stakedFrankenPunks;\n    } else {\n      collection = frankenmonsters;\n      --stakedFrankenMonsters;\n    }\n    collection.transferFrom(address(this), _to, _tokenId);\n\n    // Voting power needs to be calculated before staked time bonus is zero'd out, as it uses this value\n    uint lostVotingPower = getTokenVotingPower(_tokenId);\n    _burn(_tokenId);\n\n    if (unlockTime[_tokenId] > 0) {\n      delete unlockTime[_tokenId];\n      delete stakedTimeBonus[_tokenId];\n    }\n\n    return lostVotingPower;\n  }\n\n    //////////////////////////////////////////////\n    ///// VOTING POWER CALCULATION FUNCTIONS /////\n    //////////////////////////////////////////////\n    \n    /// @notice Get the total voting power (token + community) for an account\n    /// @param _account The address of the account to get voting power for\n    /// @return The total voting power for the account\n    /// @dev This is used by governance to calculate the voting power of an account\n    function getVotes(address _account) public view returns (uint) {\n        return tokenVotingPower[_account] + getCommunityVotingPower(_account);\n    }\n    \n    /// @notice Get the voting power for a specific token when staking or unstaking\n    /// @param _tokenId The id of the token to get voting power for\n    /// @return The voting power for the token\n    /// @dev Voting power is calculated as baseVotes + staking bonus (0 to max staking bonus) + evil bonus (0 or 10)\n    function getTokenVotingPower(uint _tokenId) public override view returns (uint) {\n      if (ownerOf(_tokenId) == address(0)) revert NonExistentToken();\n\n      // If tokenId < 10000, it's a FrankenPunk, so 100/100 = a multiplier of 1\n      uint multiplier = _tokenId < 10_000 ? PERCENT : monsterMultiplier;\n      \n      // evilBonus will return 0 for all FrankenMonsters, as they are not eligible for the evil bonus\n      return ((baseVotes * multiplier) / PERCENT) + stakedTimeBonus[_tokenId] + evilBonus(_tokenId);\n    }\n\n    /// @notice Get the community voting power for a given user\n    /// @param _voter The address of the account to get community voting power for\n    /// @return The community voting power the user currently has\n    function getCommunityVotingPower(address _voter) public override view returns (uint) {\n      uint64 votes;\n      uint64 proposalsCreated;\n      uint64 proposalsPassed;\n      \n      // We allow this function to be called with the max uint value to get the total community voting power\n      if (_voter == address(type(uint160).max)) {\n        (votes, proposalsCreated, proposalsPassed) = governance.totalCommunityScoreData();\n      } else {\n        // This is only the case if they are delegated or unstaked, both of which should zero out the result\n        if (tokenVotingPower[_voter] == 0) return 0;\n\n        (votes, proposalsCreated, proposalsPassed) = governance.userCommunityScoreData(_voter);\n      }\n\n      CommunityPowerMultipliers memory cpMultipliers = communityPowerMultipliers;\n\n      return \n        (votes * cpMultipliers.votes / PERCENT) + \n        (proposalsCreated * cpMultipliers.proposalsCreated / PERCENT) + \n        (proposalsPassed * cpMultipliers.proposalsPassed / PERCENT);\n    }\n\n    /// @notice Get the total voting power of the entire system\n    /// @return The total votes in the system\n    /// @dev This is used to calculate the quorum and proposal thresholds\n    function getTotalVotingPower() public view returns (uint) {\n      return totalTokenVotingPower + getCommunityVotingPower(address(type(uint160).max));\n    }\n\n    function getStakedTokenSupplies() public view returns (uint128, uint128) {\n      return (stakedFrankenPunks, stakedFrankenMonsters);\n    }\n\n    /// @notice Get the evil bonus for a given token\n    /// @param _tokenId The id of the token to get the evil bonus for\n    /// @return The evil bonus for the token\n    /// @dev The evil bonus is 10 if the token is sufficiently evil, 0 otherwise\n    function evilBonus(uint _tokenId) public view returns (uint) {\n      if (_tokenId >= 10000) return 0; \n      return (EVIL_BITMAPS[_tokenId >> 8] >> (255 - (_tokenId & 255)) & 1) * 10;\n    }\n\n  /////////////////////////////////\n  //////// OWNER OPERATIONS ///////\n  /////////////////////////////////\n\n  /// @notice Set the max staking time needed to get the max bonus\n  /// @param _newMaxStakeBonusTime The new max staking time\n  /// @dev This function can only be called by the executor based on a governance proposal\n  function changeStakeTime(uint128 _newMaxStakeBonusTime) external onlyExecutor {\n    if (_newMaxStakeBonusTime == 0) revert InvalidParameter();\n    emit StakeTimeChanged(stakingSettings.maxStakeBonusTime = _newMaxStakeBonusTime);\n  }\n\n  /// @notice Set the max staking bonus earned if a token is staked for the max time\n  /// @param _newMaxStakeBonusAmount The new max staking bonus\n  /// @dev This function can only be called by the executor based on a governance proposal\n  function changeStakeAmount(uint128 _newMaxStakeBonusAmount) external onlyExecutor {\n    emit StakeAmountChanged(stakingSettings.maxStakeBonusAmount = _newMaxStakeBonusAmount);\n  }\n\n  /// @notice Set the community power multiplier for votes\n  /// @param _votesMultiplier The multiplier applied to community voting power based on past votes\n  /// @dev This function can only be called by the executor based on a governance proposal\n  function setVotesMultiplier(uint64 _votesMultiplier) external onlyExecutor {\n    emit VotesMultiplierChanged(communityPowerMultipliers.votes = _votesMultiplier);\n  }\n\n  /// @notice Set the community power multiplier for proposals created\n  /// @param _proposalsCreatedMultiplier The multiplier applied to community voting power based on proposals created\n  /// @dev This function can only be called by the executor based on a governance proposal\n  function setProposalsCreatedMultiplier(uint64 _proposalsCreatedMultiplier) external onlyExecutor {\n    emit ProposalsCreatedMultiplierChanged(communityPowerMultipliers.proposalsCreated = _proposalsCreatedMultiplier);\n  }\n\n  /// @notice Set the community power multiplier for proposals passed\n  /// @param _proposalsPassedMultiplier The multiplier applied to community voting power based on proposals passed\n  /// @dev This function can only be called by the executor based on a governance proposal\n  function setProposalsPassedMultiplier(uint64 _proposalsPassedMultiplier) external onlyExecutor {\n    emit ProposalPassedMultiplierChanged(communityPowerMultipliers.proposalsPassed =  _proposalsPassedMultiplier);\n  }\n\n  /// @notice Set the base votes for 1 staked token\n  /// @param _baseVotes The number of base votes every staked token will earn (before locking, bonuses, etc)\n  /// @dev This function can only be called by the executor based on a governance proposal\n  function setBaseVotes(uint _baseVotes) external onlyExecutor {\n    emit BaseVotesChanged(baseVotes = _baseVotes);\n  }\n\n  /// @notice Set the FrankenMonster multiplier\n  /// @param _monsterMultiplier The new multiplier for voting power for a FrankenMonster vs a FrankenPunk\n  /// @dev This value is a percent, so will be divided by 100 when calculating voting power\n  /// @dev This function can only be called by the executor based on a governance proposal\n  function setMonsterMultiplier(uint _monsterMultiplier) external onlyExecutor {\n    emit MonsterMultiplierChanged(monsterMultiplier = _monsterMultiplier);\n  }\n\n  /// @notice Turn on or off gas refunds for staking and delegating\n  /// @param _stakingRefund Should refunds for staking be on (true) or off (false)?\n  /// @param _delegatingRefund Should refunds for delegating be on (true) or off (false)?\n  /// @param _newCooldown The amount of time a user must wait between refunds of the same type\n  function setRefunds(bool _stakingRefund, bool _delegatingRefund, uint _newCooldown) external onlyExecutor {\n    emit RefundSettingsChanged(\n      stakingRefund = _stakingRefund, \n      delegatingRefund = _delegatingRefund,\n      refundCooldown = _newCooldown\n    );\n  }\n\n  /// @notice Pause or unpause staking\n  /// @param _paused Whether staking should be paused or not\n  /// @dev This will be used to open and close staking windows to incentivize participation\n  function setPause(bool _paused) external onlyPauserOrAdmins {\n    emit StakingPause(paused = _paused);\n  }\n\n  /// @notice Set hte base URI for the metadata for the staked token\n  /// @param _baseURI The new base URI\n  function setBaseURI(string calldata _baseURI) external onlyAdmins {\n    emit BaseURIChanged(baseTokenURI = _baseURI);\n  }\n\n  /// @notice Check to confirm that this is a FrankenPunks staking contract\n  /// @dev Used by governance when upgrading staking to ensure the correct contract\n  /// @dev Used instead of an interface because interface may change\n  function isFrankenPunksStakingContract() external pure returns (bool) {\n    return true;\n  }\n\n  /// @notice Contract can receive ETH (will be used to pay for gas refunds)\n  receive() external payable {}\n\n  /// @notice Contract can receive ETH (will be used to pay for gas refunds)\n  fallback() external payable {}\n}"
    }
  ]
}