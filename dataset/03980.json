{
  "Title": "[H01] removeSlasher can cause mismatch between slashingWhitelist and slashingMap",
  "Content": "It is possible to successfully call the [`removeSlasher`](https://github.com/celo-org/celo-monorepo/blob/db2e561e1f13220a98743a7999818e48a5089d13/packages/protocol/contracts/governance/LockedGold.sol#L295) function within `LockedGold.sol` with a mismatch between the input parameters `slasherIdentifier` and `index` (for example, with `index` corresponding to the index of a different identifier than `slasherIdentifier` within `slashingWhitelist`). Upon doing so, [`slashingWhitelist[index]` will be deleted](https://github.com/celo-org/celo-monorepo/blob/db2e561e1f13220a98743a7999818e48a5089d13/packages/protocol/contracts/governance/LockedGold.sol#L299-L300) and [`slashingMap`‘s entry corresponding to `identifier` will be changed to `false`](https://github.com/celo-org/celo-monorepo/blob/db2e561e1f13220a98743a7999818e48a5089d13/packages/protocol/contracts/governance/LockedGold.sol#L301).\n\n\nThis leads to two problems. The first is that the `slasherWhitelist` and `slashingMap` will be mismatched. The second is that the `slashingMap[keyBytes]` will now equal `false`, so future calls to this function with the same `slasherIdentifier` (from which `keyBytes` is derived) [will revert](https://github.com/celo-org/celo-monorepo/blob/db2e561e1f13220a98743a7999818e48a5089d13/packages/protocol/contracts/governance/LockedGold.sol#L297), and the slasher may be able to be [added to the whitelist twice](https://github.com/celo-org/celo-monorepo/blob/db2e561e1f13220a98743a7999818e48a5089d13/packages/protocol/contracts/governance/LockedGold.sol#L284).\n\n\nThis issue’s severity is minimized by the [onlyOwner](https://github.com/celo-org/celo-monorepo/blob/db2e561e1f13220a98743a7999818e48a5089d13/packages/protocol/contracts/governance/LockedGold.sol#L295) modifier on `removeSlasher`. As long as the owner can be trusted, this issue is less likely to cause problems. Additionally, the owner can perform certain combinations of calls to `removeSlasher` and `addSlasher` to fix any mismatch problems. Still, to avoid this entirely, consider adding a `require` that checks that `slashingWhitelist[index] == keyBytes` within the `removeSlasher` function.\n\n\n***Update:** Fixed in [pull request #3122](https://github.com/celo-org/celo-monorepo/pull/3122).*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/contracts/governance/LockedGold.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/math/Math.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\nimport \"./interfaces/ILockedGold.sol\";\n\nimport \"../common/Initializable.sol\";\nimport \"../common/Signatures.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/libraries/ReentrancyGuard.sol\";\n\ncontract LockedGold is ILockedGold, ReentrancyGuard, Initializable, UsingRegistry {\n  using SafeMath for uint256;\n\n  struct PendingWithdrawal {\n    // The value of the pending withdrawal.\n    uint256 value;\n    // The timestamp at which the pending withdrawal becomes available.\n    uint256 timestamp;\n  }\n\n  // NOTE: This contract does not store an account's locked gold that is being used in electing\n  // validators.\n  struct Balances {\n    // The amount of locked gold that this account has that is not currently participating in\n    // validator elections.\n    uint256 nonvoting;\n    // Gold that has been unlocked and will become available for withdrawal.\n    PendingWithdrawal[] pendingWithdrawals;\n  }\n\n  mapping(address => Balances) private balances;\n\n  // Iterable map to store whitelisted identifiers.\n  // Necessary to allow iterating over whitelisted IDs to check ID's address at runtime.\n  mapping(bytes32 => bool) internal slashingMap;\n  bytes32[] public slashingWhitelist;\n\n  modifier onlySlasher {\n    require(\n      registry.isOneOf(slashingWhitelist, msg.sender),\n      \"Caller is not a whitelisted slasher.\"\n    );\n    _;\n  }\n\n  function isSlasher(address slasher) external view returns (bool) {\n    return (registry.isOneOf(slashingWhitelist, slasher));\n  }\n\n  uint256 public totalNonvoting;\n  uint256 public unlockingPeriod;\n\n  event UnlockingPeriodSet(uint256 period);\n  event GoldLocked(address indexed account, uint256 value);\n  event GoldUnlocked(address indexed account, uint256 value, uint256 available);\n  event GoldWithdrawn(address indexed account, uint256 value);\n  event SlasherWhitelistAdded(string indexed slasherIdentifier);\n  event SlasherWhitelistRemoved(string indexed slasherIdentifier);\n  event AccountSlashed(\n    address indexed slashed,\n    uint256 penalty,\n    address indexed reporter,\n    uint256 reward\n  );\n\n  /**\n   * @notice Used in place of the constructor to allow the contract to be upgradable via proxy.\n   * @param registryAddress The address of the registry core smart contract.\n   * @param _unlockingPeriod The unlocking period in seconds.\n   */\n  function initialize(address registryAddress, uint256 _unlockingPeriod) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    setUnlockingPeriod(_unlockingPeriod);\n  }\n\n  /**\n   * @notice Sets the duration in seconds users must wait before withdrawing gold after unlocking.\n   * @param value The unlocking period in seconds.\n   */\n  function setUnlockingPeriod(uint256 value) public onlyOwner {\n    require(value != unlockingPeriod, \"Unlocking period not changed\");\n    unlockingPeriod = value;\n    emit UnlockingPeriodSet(value);\n  }\n\n  /**\n   * @notice Locks gold to be used for voting.\n   */\n  function lock() external payable nonReentrant {\n    require(getAccounts().isAccount(msg.sender), \"not account\");\n    require(msg.value > 0, \"no value\");\n    _incrementNonvotingAccountBalance(msg.sender, msg.value);\n    emit GoldLocked(msg.sender, msg.value);\n  }\n\n  /**\n   * @notice Increments the non-voting balance for an account.\n   * @param account The account whose non-voting balance should be incremented.\n   * @param value The amount by which to increment.\n   * @dev Can only be called by the registered Election smart contract.\n   */\n  function incrementNonvotingAccountBalance(address account, uint256 value)\n    external\n    onlyRegisteredContract(ELECTION_REGISTRY_ID)\n  {\n    _incrementNonvotingAccountBalance(account, value);\n  }\n\n  /**\n   * @notice Decrements the non-voting balance for an account.\n   * @param account The account whose non-voting balance should be decremented.\n   * @param value The amount by which to decrement.\n   * @dev Can only be called by the registered \"Election\" smart contract.\n   */\n  function decrementNonvotingAccountBalance(address account, uint256 value)\n    external\n    onlyRegisteredContract(ELECTION_REGISTRY_ID)\n  {\n    _decrementNonvotingAccountBalance(account, value);\n  }\n\n  /**\n   * @notice Increments the non-voting balance for an account.\n   * @param account The account whose non-voting balance should be incremented.\n   * @param value The amount by which to increment.\n   */\n  function _incrementNonvotingAccountBalance(address account, uint256 value) private {\n    balances[account].nonvoting = balances[account].nonvoting.add(value);\n    totalNonvoting = totalNonvoting.add(value);\n  }\n\n  /**\n   * @notice Decrements the non-voting balance for an account.\n   * @param account The account whose non-voting balance should be decremented.\n   * @param value The amount by which to decrement.\n   */\n  function _decrementNonvotingAccountBalance(address account, uint256 value) private {\n    balances[account].nonvoting = balances[account].nonvoting.sub(value);\n    totalNonvoting = totalNonvoting.sub(value);\n  }\n\n  /**\n   * @notice Unlocks gold that becomes withdrawable after the unlocking period.\n   * @param value The amount of gold to unlock.\n   */\n  function unlock(uint256 value) external nonReentrant {\n    require(getAccounts().isAccount(msg.sender), \"Unknown account\");\n    Balances storage account = balances[msg.sender];\n    // Prevent unlocking gold when voting on governance proposals so that the gold cannot be\n    // used to vote more than once.\n    require(!getGovernance().isVoting(msg.sender), \"Account locked\");\n    uint256 balanceRequirement = getValidators().getAccountLockedGoldRequirement(msg.sender);\n    require(\n      balanceRequirement == 0 ||\n        balanceRequirement <= getAccountTotalLockedGold(msg.sender).sub(value),\n      \"Trying to unlock too much gold\"\n    );\n    _decrementNonvotingAccountBalance(msg.sender, value);\n    uint256 available = now.add(unlockingPeriod);\n    account.pendingWithdrawals.push(PendingWithdrawal(value, available));\n    emit GoldUnlocked(msg.sender, value, available);\n  }\n\n  /**\n   * @notice Relocks gold that has been unlocked but not withdrawn.\n   * @param index The index of the pending withdrawal to relock from.\n   * @param value The value to relock from the specified pending withdrawal.\n   */\n  function relock(uint256 index, uint256 value) external nonReentrant {\n    require(getAccounts().isAccount(msg.sender), \"Unknown account\");\n    Balances storage account = balances[msg.sender];\n    require(index < account.pendingWithdrawals.length, \"Bad pending withdrawal index\");\n    PendingWithdrawal storage pendingWithdrawal = account.pendingWithdrawals[index];\n    require(value <= pendingWithdrawal.value, \"Requested value larger than pending value\");\n    if (value == pendingWithdrawal.value) {\n      deletePendingWithdrawal(account.pendingWithdrawals, index);\n    } else {\n      pendingWithdrawal.value = pendingWithdrawal.value.sub(value);\n    }\n    _incrementNonvotingAccountBalance(msg.sender, value);\n    emit GoldLocked(msg.sender, value);\n  }\n\n  /**\n   * @notice Withdraws gold that has been unlocked after the unlocking period has passed.\n   * @param index The index of the pending withdrawal to withdraw.\n   */\n  function withdraw(uint256 index) external nonReentrant {\n    require(getAccounts().isAccount(msg.sender), \"Unknown account\");\n    Balances storage account = balances[msg.sender];\n    require(index < account.pendingWithdrawals.length, \"Bad pending withdrawal index\");\n    PendingWithdrawal storage pendingWithdrawal = account.pendingWithdrawals[index];\n    require(now >= pendingWithdrawal.timestamp, \"Pending withdrawal not available\");\n    uint256 value = pendingWithdrawal.value;\n    deletePendingWithdrawal(account.pendingWithdrawals, index);\n    msg.sender.transfer(value);\n    emit GoldWithdrawn(msg.sender, value);\n  }\n\n  /**\n   * @notice Returns the total amount of locked gold in the system. Note that this does not include\n   *   gold that has been unlocked but not yet withdrawn.\n   * @return The total amount of locked gold in the system.\n   */\n  function getTotalLockedGold() external view returns (uint256) {\n    return totalNonvoting.add(getElection().getTotalVotes());\n  }\n\n  /**\n   * @notice Returns the total amount of locked gold not being used to vote in elections.\n   * @return The total amount of locked gold not being used to vote in elections.\n   */\n  function getNonvotingLockedGold() external view returns (uint256) {\n    return totalNonvoting;\n  }\n\n  /**\n   * @notice Returns the total amount of locked gold for an account.\n   * @param account The account.\n   * @return The total amount of locked gold for an account.\n   */\n  function getAccountTotalLockedGold(address account) public view returns (uint256) {\n    uint256 total = balances[account].nonvoting;\n    return total.add(getElection().getTotalVotesByAccount(account));\n  }\n\n  /**\n   * @notice Returns the total amount of non-voting locked gold for an account.\n   * @param account The account.\n   * @return The total amount of non-voting locked gold for an account.\n   */\n  function getAccountNonvotingLockedGold(address account) external view returns (uint256) {\n    return balances[account].nonvoting;\n  }\n\n  /**\n   * @notice Returns the pending withdrawals from unlocked gold for an account.\n   * @param account The address of the account.\n   * @return The value and timestamp for each pending withdrawal.\n   */\n  function getPendingWithdrawals(address account)\n    external\n    view\n    returns (uint256[] memory, uint256[] memory)\n  {\n    require(getAccounts().isAccount(account), \"Unknown account\");\n    uint256 length = balances[account].pendingWithdrawals.length;\n    uint256[] memory values = new uint256[](length);\n    uint256[] memory timestamps = new uint256[](length);\n    for (uint256 i = 0; i < length; i = i.add(1)) {\n      PendingWithdrawal memory pendingWithdrawal = (balances[account].pendingWithdrawals[i]);\n      values[i] = pendingWithdrawal.value;\n      timestamps[i] = pendingWithdrawal.timestamp;\n    }\n    return (values, timestamps);\n  }\n\n  function getSlashingWhitelist() external view returns (bytes32[] memory) {\n    return slashingWhitelist;\n  }\n\n  /**\n   * @notice Deletes a pending withdrawal.\n   * @param list The list of pending withdrawals from which to delete.\n   * @param index The index of the pending withdrawal to delete.\n   */\n  function deletePendingWithdrawal(PendingWithdrawal[] storage list, uint256 index) private {\n    uint256 lastIndex = list.length.sub(1);\n    list[index] = list[lastIndex];\n    list.length = lastIndex;\n  }\n\n  /**\n   * @notice Adds `slasher` to whitelist of approved slashing addresses.\n   * @param slasherIdentifier Identifier to whitelist.\n   */\n  function addSlasher(string calldata slasherIdentifier) external onlyOwner {\n    bytes32 keyBytes = keccak256(abi.encodePacked(slasherIdentifier));\n    require(registry.getAddressFor(keyBytes) != address(0), \"Identifier is not registered\");\n    require(!slashingMap[keyBytes], \"Cannot add slasher ID twice.\");\n    slashingWhitelist.push(keyBytes);\n    slashingMap[keyBytes] = true;\n    emit SlasherWhitelistAdded(slasherIdentifier);\n  }\n\n  /**\n   * @notice Removes `slasher` from whitelist of approved slashing addresses.\n   * @param slasherIdentifier Identifier to remove from whitelist.\n   * @param index Index of the provided identifier in slashingWhiteList array.\n   */\n  function removeSlasher(string calldata slasherIdentifier, uint256 index) external onlyOwner {\n    bytes32 keyBytes = keccak256(abi.encodePacked(slasherIdentifier));\n    require(slashingMap[keyBytes], \"Cannot remove slasher ID not yet added.\");\n    require(index < slashingWhitelist.length, \"Provided index exceeds whitelist bounds.\");\n    slashingWhitelist[index] = slashingWhitelist[slashingWhitelist.length - 1];\n    slashingWhitelist.pop();\n    slashingMap[keyBytes] = false;\n    emit SlasherWhitelistRemoved(slasherIdentifier);\n  }\n\n  /**\n   * @notice Slashes `account` by reducing its nonvoting locked gold by `penalty`.\n   *         If there is not enough nonvoting locked gold to slash, calls into\n   *         `Election.slashVotes` to slash the remaining gold. If `account` does not have\n   *         `penalty` worth of locked gold, slashes `account`'s total locked gold.\n   *         Also sends `reward` gold to the reporter, and penalty-reward to the Community Fund.\n   * @param account Address of account being slashed.\n   * @param penalty Amount to slash account.\n   * @param reporter Address of account reporting the slasher.\n   * @param reward Reward to give reporter.\n   * @param lessers The groups receiving fewer votes than i'th group, or 0 if the i'th group has\n   *                the fewest votes of any validator group.\n   * @param greaters The groups receiving more votes than the i'th group, or 0 if the i'th group\n   *                 has the most votes of any validator group.\n   * @param indices The indices of the i'th group in `account`'s voting list.\n   * @dev Fails if `reward` is greater than `account`'s total locked gold.\n   */\n  function slash(\n    address account,\n    uint256 penalty,\n    address reporter,\n    uint256 reward,\n    address[] calldata lessers,\n    address[] calldata greaters,\n    uint256[] calldata indices\n  ) external onlySlasher {\n    uint256 maxSlash = Math.min(penalty, getAccountTotalLockedGold(account));\n    require(maxSlash >= reward, \"reward cannot exceed penalty.\");\n    // Local scoping is required to avoid Solc \"stack too deep\" error from too many locals.\n    {\n      uint256 nonvotingBalance = balances[account].nonvoting;\n      uint256 difference = 0;\n      // If not enough nonvoting, revoke the difference\n      if (nonvotingBalance < maxSlash) {\n        difference = maxSlash.sub(nonvotingBalance);\n        require(\n          getElection().forceDecrementVotes(account, difference, lessers, greaters, indices) ==\n            difference,\n          \"Cannot revoke enough voting gold.\"\n        );\n      }\n      // forceDecrementVotes does not increment nonvoting account balance, so we can't double count\n      _decrementNonvotingAccountBalance(account, maxSlash.sub(difference));\n      _incrementNonvotingAccountBalance(reporter, reward);\n    }\n    address communityFund = registry.getAddressForOrDie(GOVERNANCE_REGISTRY_ID);\n    address payable communityFundPayable = address(uint160(communityFund));\n    communityFundPayable.transfer(maxSlash.sub(reward));\n    emit AccountSlashed(account, maxSlash, reporter, reward);\n  }\n}"
    },
    {
      "filename": "packages/protocol/contracts/governance/LockedGold.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/math/Math.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\nimport \"./interfaces/ILockedGold.sol\";\n\nimport \"../common/Initializable.sol\";\nimport \"../common/Signatures.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/libraries/ReentrancyGuard.sol\";\n\ncontract LockedGold is ILockedGold, ReentrancyGuard, Initializable, UsingRegistry {\n  using SafeMath for uint256;\n\n  struct PendingWithdrawal {\n    // The value of the pending withdrawal.\n    uint256 value;\n    // The timestamp at which the pending withdrawal becomes available.\n    uint256 timestamp;\n  }\n\n  // NOTE: This contract does not store an account's locked gold that is being used in electing\n  // validators.\n  struct Balances {\n    // The amount of locked gold that this account has that is not currently participating in\n    // validator elections.\n    uint256 nonvoting;\n    // Gold that has been unlocked and will become available for withdrawal.\n    PendingWithdrawal[] pendingWithdrawals;\n  }\n\n  mapping(address => Balances) private balances;\n\n  // Iterable map to store whitelisted identifiers.\n  // Necessary to allow iterating over whitelisted IDs to check ID's address at runtime.\n  mapping(bytes32 => bool) internal slashingMap;\n  bytes32[] public slashingWhitelist;\n\n  modifier onlySlasher {\n    require(\n      registry.isOneOf(slashingWhitelist, msg.sender),\n      \"Caller is not a whitelisted slasher.\"\n    );\n    _;\n  }\n\n  function isSlasher(address slasher) external view returns (bool) {\n    return (registry.isOneOf(slashingWhitelist, slasher));\n  }\n\n  uint256 public totalNonvoting;\n  uint256 public unlockingPeriod;\n\n  event UnlockingPeriodSet(uint256 period);\n  event GoldLocked(address indexed account, uint256 value);\n  event GoldUnlocked(address indexed account, uint256 value, uint256 available);\n  event GoldWithdrawn(address indexed account, uint256 value);\n  event SlasherWhitelistAdded(string indexed slasherIdentifier);\n  event SlasherWhitelistRemoved(string indexed slasherIdentifier);\n  event AccountSlashed(\n    address indexed slashed,\n    uint256 penalty,\n    address indexed reporter,\n    uint256 reward\n  );\n\n  /**\n   * @notice Used in place of the constructor to allow the contract to be upgradable via proxy.\n   * @param registryAddress The address of the registry core smart contract.\n   * @param _unlockingPeriod The unlocking period in seconds.\n   */\n  function initialize(address registryAddress, uint256 _unlockingPeriod) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    setUnlockingPeriod(_unlockingPeriod);\n  }\n\n  /**\n   * @notice Sets the duration in seconds users must wait before withdrawing gold after unlocking.\n   * @param value The unlocking period in seconds.\n   */\n  function setUnlockingPeriod(uint256 value) public onlyOwner {\n    require(value != unlockingPeriod, \"Unlocking period not changed\");\n    unlockingPeriod = value;\n    emit UnlockingPeriodSet(value);\n  }\n\n  /**\n   * @notice Locks gold to be used for voting.\n   */\n  function lock() external payable nonReentrant {\n    require(getAccounts().isAccount(msg.sender), \"not account\");\n    require(msg.value > 0, \"no value\");\n    _incrementNonvotingAccountBalance(msg.sender, msg.value);\n    emit GoldLocked(msg.sender, msg.value);\n  }\n\n  /**\n   * @notice Increments the non-voting balance for an account.\n   * @param account The account whose non-voting balance should be incremented.\n   * @param value The amount by which to increment.\n   * @dev Can only be called by the registered Election smart contract.\n   */\n  function incrementNonvotingAccountBalance(address account, uint256 value)\n    external\n    onlyRegisteredContract(ELECTION_REGISTRY_ID)\n  {\n    _incrementNonvotingAccountBalance(account, value);\n  }\n\n  /**\n   * @notice Decrements the non-voting balance for an account.\n   * @param account The account whose non-voting balance should be decremented.\n   * @param value The amount by which to decrement.\n   * @dev Can only be called by the registered \"Election\" smart contract.\n   */\n  function decrementNonvotingAccountBalance(address account, uint256 value)\n    external\n    onlyRegisteredContract(ELECTION_REGISTRY_ID)\n  {\n    _decrementNonvotingAccountBalance(account, value);\n  }\n\n  /**\n   * @notice Increments the non-voting balance for an account.\n   * @param account The account whose non-voting balance should be incremented.\n   * @param value The amount by which to increment.\n   */\n  function _incrementNonvotingAccountBalance(address account, uint256 value) private {\n    balances[account].nonvoting = balances[account].nonvoting.add(value);\n    totalNonvoting = totalNonvoting.add(value);\n  }\n\n  /**\n   * @notice Decrements the non-voting balance for an account.\n   * @param account The account whose non-voting balance should be decremented.\n   * @param value The amount by which to decrement.\n   */\n  function _decrementNonvotingAccountBalance(address account, uint256 value) private {\n    balances[account].nonvoting = balances[account].nonvoting.sub(value);\n    totalNonvoting = totalNonvoting.sub(value);\n  }\n\n  /**\n   * @notice Unlocks gold that becomes withdrawable after the unlocking period.\n   * @param value The amount of gold to unlock.\n   */\n  function unlock(uint256 value) external nonReentrant {\n    require(getAccounts().isAccount(msg.sender), \"Unknown account\");\n    Balances storage account = balances[msg.sender];\n    // Prevent unlocking gold when voting on governance proposals so that the gold cannot be\n    // used to vote more than once.\n    require(!getGovernance().isVoting(msg.sender), \"Account locked\");\n    uint256 balanceRequirement = getValidators().getAccountLockedGoldRequirement(msg.sender);\n    require(\n      balanceRequirement == 0 ||\n        balanceRequirement <= getAccountTotalLockedGold(msg.sender).sub(value),\n      \"Trying to unlock too much gold\"\n    );\n    _decrementNonvotingAccountBalance(msg.sender, value);\n    uint256 available = now.add(unlockingPeriod);\n    account.pendingWithdrawals.push(PendingWithdrawal(value, available));\n    emit GoldUnlocked(msg.sender, value, available);\n  }\n\n  /**\n   * @notice Relocks gold that has been unlocked but not withdrawn.\n   * @param index The index of the pending withdrawal to relock from.\n   * @param value The value to relock from the specified pending withdrawal.\n   */\n  function relock(uint256 index, uint256 value) external nonReentrant {\n    require(getAccounts().isAccount(msg.sender), \"Unknown account\");\n    Balances storage account = balances[msg.sender];\n    require(index < account.pendingWithdrawals.length, \"Bad pending withdrawal index\");\n    PendingWithdrawal storage pendingWithdrawal = account.pendingWithdrawals[index];\n    require(value <= pendingWithdrawal.value, \"Requested value larger than pending value\");\n    if (value == pendingWithdrawal.value) {\n      deletePendingWithdrawal(account.pendingWithdrawals, index);\n    } else {\n      pendingWithdrawal.value = pendingWithdrawal.value.sub(value);\n    }\n    _incrementNonvotingAccountBalance(msg.sender, value);\n    emit GoldLocked(msg.sender, value);\n  }\n\n  /**\n   * @notice Withdraws gold that has been unlocked after the unlocking period has passed.\n   * @param index The index of the pending withdrawal to withdraw.\n   */\n  function withdraw(uint256 index) external nonReentrant {\n    require(getAccounts().isAccount(msg.sender), \"Unknown account\");\n    Balances storage account = balances[msg.sender];\n    require(index < account.pendingWithdrawals.length, \"Bad pending withdrawal index\");\n    PendingWithdrawal storage pendingWithdrawal = account.pendingWithdrawals[index];\n    require(now >= pendingWithdrawal.timestamp, \"Pending withdrawal not available\");\n    uint256 value = pendingWithdrawal.value;\n    deletePendingWithdrawal(account.pendingWithdrawals, index);\n    msg.sender.transfer(value);\n    emit GoldWithdrawn(msg.sender, value);\n  }\n\n  /**\n   * @notice Returns the total amount of locked gold in the system. Note that this does not include\n   *   gold that has been unlocked but not yet withdrawn.\n   * @return The total amount of locked gold in the system.\n   */\n  function getTotalLockedGold() external view returns (uint256) {\n    return totalNonvoting.add(getElection().getTotalVotes());\n  }\n\n  /**\n   * @notice Returns the total amount of locked gold not being used to vote in elections.\n   * @return The total amount of locked gold not being used to vote in elections.\n   */\n  function getNonvotingLockedGold() external view returns (uint256) {\n    return totalNonvoting;\n  }\n\n  /**\n   * @notice Returns the total amount of locked gold for an account.\n   * @param account The account.\n   * @return The total amount of locked gold for an account.\n   */\n  function getAccountTotalLockedGold(address account) public view returns (uint256) {\n    uint256 total = balances[account].nonvoting;\n    return total.add(getElection().getTotalVotesByAccount(account));\n  }\n\n  /**\n   * @notice Returns the total amount of non-voting locked gold for an account.\n   * @param account The account.\n   * @return The total amount of non-voting locked gold for an account.\n   */\n  function getAccountNonvotingLockedGold(address account) external view returns (uint256) {\n    return balances[account].nonvoting;\n  }\n\n  /**\n   * @notice Returns the pending withdrawals from unlocked gold for an account.\n   * @param account The address of the account.\n   * @return The value and timestamp for each pending withdrawal.\n   */\n  function getPendingWithdrawals(address account)\n    external\n    view\n    returns (uint256[] memory, uint256[] memory)\n  {\n    require(getAccounts().isAccount(account), \"Unknown account\");\n    uint256 length = balances[account].pendingWithdrawals.length;\n    uint256[] memory values = new uint256[](length);\n    uint256[] memory timestamps = new uint256[](length);\n    for (uint256 i = 0; i < length; i = i.add(1)) {\n      PendingWithdrawal memory pendingWithdrawal = (balances[account].pendingWithdrawals[i]);\n      values[i] = pendingWithdrawal.value;\n      timestamps[i] = pendingWithdrawal.timestamp;\n    }\n    return (values, timestamps);\n  }\n\n  function getSlashingWhitelist() external view returns (bytes32[] memory) {\n    return slashingWhitelist;\n  }\n\n  /**\n   * @notice Deletes a pending withdrawal.\n   * @param list The list of pending withdrawals from which to delete.\n   * @param index The index of the pending withdrawal to delete.\n   */\n  function deletePendingWithdrawal(PendingWithdrawal[] storage list, uint256 index) private {\n    uint256 lastIndex = list.length.sub(1);\n    list[index] = list[lastIndex];\n    list.length = lastIndex;\n  }\n\n  /**\n   * @notice Adds `slasher` to whitelist of approved slashing addresses.\n   * @param slasherIdentifier Identifier to whitelist.\n   */\n  function addSlasher(string calldata slasherIdentifier) external onlyOwner {\n    bytes32 keyBytes = keccak256(abi.encodePacked(slasherIdentifier));\n    require(registry.getAddressFor(keyBytes) != address(0), \"Identifier is not registered\");\n    require(!slashingMap[keyBytes], \"Cannot add slasher ID twice.\");\n    slashingWhitelist.push(keyBytes);\n    slashingMap[keyBytes] = true;\n    emit SlasherWhitelistAdded(slasherIdentifier);\n  }\n\n  /**\n   * @notice Removes `slasher` from whitelist of approved slashing addresses.\n   * @param slasherIdentifier Identifier to remove from whitelist.\n   * @param index Index of the provided identifier in slashingWhiteList array.\n   */\n  function removeSlasher(string calldata slasherIdentifier, uint256 index) external onlyOwner {\n    bytes32 keyBytes = keccak256(abi.encodePacked(slasherIdentifier));\n    require(slashingMap[keyBytes], \"Cannot remove slasher ID not yet added.\");\n    require(index < slashingWhitelist.length, \"Provided index exceeds whitelist bounds.\");\n    slashingWhitelist[index] = slashingWhitelist[slashingWhitelist.length - 1];\n    slashingWhitelist.pop();\n    slashingMap[keyBytes] = false;\n    emit SlasherWhitelistRemoved(slasherIdentifier);\n  }\n\n  /**\n   * @notice Slashes `account` by reducing its nonvoting locked gold by `penalty`.\n   *         If there is not enough nonvoting locked gold to slash, calls into\n   *         `Election.slashVotes` to slash the remaining gold. If `account` does not have\n   *         `penalty` worth of locked gold, slashes `account`'s total locked gold.\n   *         Also sends `reward` gold to the reporter, and penalty-reward to the Community Fund.\n   * @param account Address of account being slashed.\n   * @param penalty Amount to slash account.\n   * @param reporter Address of account reporting the slasher.\n   * @param reward Reward to give reporter.\n   * @param lessers The groups receiving fewer votes than i'th group, or 0 if the i'th group has\n   *                the fewest votes of any validator group.\n   * @param greaters The groups receiving more votes than the i'th group, or 0 if the i'th group\n   *                 has the most votes of any validator group.\n   * @param indices The indices of the i'th group in `account`'s voting list.\n   * @dev Fails if `reward` is greater than `account`'s total locked gold.\n   */\n  function slash(\n    address account,\n    uint256 penalty,\n    address reporter,\n    uint256 reward,\n    address[] calldata lessers,\n    address[] calldata greaters,\n    uint256[] calldata indices\n  ) external onlySlasher {\n    uint256 maxSlash = Math.min(penalty, getAccountTotalLockedGold(account));\n    require(maxSlash >= reward, \"reward cannot exceed penalty.\");\n    // Local scoping is required to avoid Solc \"stack too deep\" error from too many locals.\n    {\n      uint256 nonvotingBalance = balances[account].nonvoting;\n      uint256 difference = 0;\n      // If not enough nonvoting, revoke the difference\n      if (nonvotingBalance < maxSlash) {\n        difference = maxSlash.sub(nonvotingBalance);\n        require(\n          getElection().forceDecrementVotes(account, difference, lessers, greaters, indices) ==\n            difference,\n          \"Cannot revoke enough voting gold.\"\n        );\n      }\n      // forceDecrementVotes does not increment nonvoting account balance, so we can't double count\n      _decrementNonvotingAccountBalance(account, maxSlash.sub(difference));\n      _incrementNonvotingAccountBalance(reporter, reward);\n    }\n    address communityFund = registry.getAddressForOrDie(GOVERNANCE_REGISTRY_ID);\n    address payable communityFundPayable = address(uint160(communityFund));\n    communityFundPayable.transfer(maxSlash.sub(reward));\n    emit AccountSlashed(account, maxSlash, reporter, reward);\n  }\n}"
    },
    {
      "filename": "packages/protocol/contracts/governance/LockedGold.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/math/Math.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\nimport \"./interfaces/ILockedGold.sol\";\n\nimport \"../common/Initializable.sol\";\nimport \"../common/Signatures.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/libraries/ReentrancyGuard.sol\";\n\ncontract LockedGold is ILockedGold, ReentrancyGuard, Initializable, UsingRegistry {\n  using SafeMath for uint256;\n\n  struct PendingWithdrawal {\n    // The value of the pending withdrawal.\n    uint256 value;\n    // The timestamp at which the pending withdrawal becomes available.\n    uint256 timestamp;\n  }\n\n  // NOTE: This contract does not store an account's locked gold that is being used in electing\n  // validators.\n  struct Balances {\n    // The amount of locked gold that this account has that is not currently participating in\n    // validator elections.\n    uint256 nonvoting;\n    // Gold that has been unlocked and will become available for withdrawal.\n    PendingWithdrawal[] pendingWithdrawals;\n  }\n\n  mapping(address => Balances) private balances;\n\n  // Iterable map to store whitelisted identifiers.\n  // Necessary to allow iterating over whitelisted IDs to check ID's address at runtime.\n  mapping(bytes32 => bool) internal slashingMap;\n  bytes32[] public slashingWhitelist;\n\n  modifier onlySlasher {\n    require(\n      registry.isOneOf(slashingWhitelist, msg.sender),\n      \"Caller is not a whitelisted slasher.\"\n    );\n    _;\n  }\n\n  function isSlasher(address slasher) external view returns (bool) {\n    return (registry.isOneOf(slashingWhitelist, slasher));\n  }\n\n  uint256 public totalNonvoting;\n  uint256 public unlockingPeriod;\n\n  event UnlockingPeriodSet(uint256 period);\n  event GoldLocked(address indexed account, uint256 value);\n  event GoldUnlocked(address indexed account, uint256 value, uint256 available);\n  event GoldWithdrawn(address indexed account, uint256 value);\n  event SlasherWhitelistAdded(string indexed slasherIdentifier);\n  event SlasherWhitelistRemoved(string indexed slasherIdentifier);\n  event AccountSlashed(\n    address indexed slashed,\n    uint256 penalty,\n    address indexed reporter,\n    uint256 reward\n  );\n\n  /**\n   * @notice Used in place of the constructor to allow the contract to be upgradable via proxy.\n   * @param registryAddress The address of the registry core smart contract.\n   * @param _unlockingPeriod The unlocking period in seconds.\n   */\n  function initialize(address registryAddress, uint256 _unlockingPeriod) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    setUnlockingPeriod(_unlockingPeriod);\n  }\n\n  /**\n   * @notice Sets the duration in seconds users must wait before withdrawing gold after unlocking.\n   * @param value The unlocking period in seconds.\n   */\n  function setUnlockingPeriod(uint256 value) public onlyOwner {\n    require(value != unlockingPeriod, \"Unlocking period not changed\");\n    unlockingPeriod = value;\n    emit UnlockingPeriodSet(value);\n  }\n\n  /**\n   * @notice Locks gold to be used for voting.\n   */\n  function lock() external payable nonReentrant {\n    require(getAccounts().i"
    }
  ]
}