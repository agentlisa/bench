{
  "Title": "[M-08] The tier reserved rate is not validated and can surpass `JBConstants.MAX_RESERVED_RATE`",
  "Content": "\n<https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L1224-L1259><br>\n<https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L566><br>\n<https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/abstract/JB721Delegate.sol#L142>\n\nIf the reserved rate of a tier is set to a value > `JBConstants.MAX_RESERVED_RATE`, the `JBTiered721DelegateStore._numberOfReservedTokensOutstandingFor` function will return way more outstanding reserved tokens (up to \\~6 times more than allowed - **2^16 - 1** due to the manual cast of `reservedRate` to `uint16` divided by `JBConstants.MAX_RESERVED_RATE = 10_000`). This inflated value is used in the `JBTiered721DelegateStore.totalRedemptionWeight` function to calculate the cumulative redemption weight of all tokens across all tiers.\n\nThis higher-than-expected redemption weight will lower the `reclaimAmount` calculated in the `JB721Delegate.redeemParams` function. Depending on the values of `_data.overflow` and `_redemptionWeight`, the calculated `reclaimAmount` can be **0** (due to rounding down, [see here](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/abstract/JB721Delegate.sol#L142)) or a smaller than anticipated value, leading to burned NFT tokens from the user and no redemptions.\n\n### Impact\n\nThe owner of an NFT contract can add tiers with higher than usual reserved rates (and mint an appropriate number of NFTs to bypass all conditions in the `JBTiered721DelegateStore._numberOfReservedTokensOutstandingFor`), which will lead to a lower-than-expected redemption amount for users.\n\n### Proof of Concept\n\n[JBTiered721DelegateStore.\\_numberOfReservedTokensOutstandingFor](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L1224-L1259)\n\n```solidity\nfunction _numberOfReservedTokensOutstandingFor(\n  address _nft,\n  uint256 _tierId,\n  JBStored721Tier memory _storedTier\n) internal view returns (uint256) {\n  // Invalid tier or no reserved rate?\n  if (_storedTier.initialQuantity == 0 || _storedTier.reservedRate == 0) return 0;\n\n  // No token minted yet? Round up to 1.\n  if (_storedTier.initialQuantity == _storedTier.remainingQuantity) return 1;\n\n  // The number of reserved tokens of the tier already minted.\n  uint256 _reserveTokensMinted = numberOfReservesMintedFor[_nft][_tierId];\n\n  // If only the reserved token (from the rounding up) has been minted so far, return 0.\n  if (_storedTier.initialQuantity - _reserveTokensMinted == _storedTier.remainingQuantity)\n    return 0;\n\n  // Get a reference to the number of tokens already minted in the tier, not counting reserves or burned tokens.\n  uint256 _numberOfNonReservesMinted = _storedTier.initialQuantity -\n    _storedTier.remainingQuantity -\n    _reserveTokensMinted;\n\n  // Store the numerator common to the next two calculations.\n  uint256 _numerator = uint256(_numberOfNonReservesMinted * _storedTier.reservedRate);\n\n  // Get the number of reserved tokens mintable given the number of non reserved tokens minted. This will round down.\n  uint256 _numberReservedTokensMintable = _numerator / JBConstants.MAX_RESERVED_RATE;\n\n  // Round up.\n  if (_numerator - JBConstants.MAX_RESERVED_RATE * _numberReservedTokensMintable > 0)\n    ++_numberReservedTokensMintable;\n\n  // Return the difference between the amount mintable and the amount already minted.\n  return _numberReservedTokensMintable - _reserveTokensMinted;\n}\n```\n\n[JBTiered721DelegateStore.totalRedemptionWeight](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L566)\n\nThe `JBTiered721DelegateStore._numberOfReservedTokensOutstandingFor` function is called from within the `JBTiered721DelegateStore.totalRedemptionWeight` function. This allows for inflating the total redemption weight.\n\n```solidity\nfunction totalRedemptionWeight(address _nft) public view override returns (uint256 weight) {\n  // Keep a reference to the greatest tier ID.\n  uint256 _maxTierId = maxTierIdOf[_nft];\n\n  // Keep a reference to the tier being iterated on.\n  JBStored721Tier memory _storedTier;\n\n  // Add each token's tier's contribution floor to the weight.\n  for (uint256 _i; _i < _maxTierId; ) {\n    // Keep a reference to the stored tier.\n    _storedTier = _storedTierOf[_nft][_i + 1];\n\n    // Add the tier's contribution floor multiplied by the quantity minted.\n    weight +=\n      (_storedTier.contributionFloor *\n        (_storedTier.initialQuantity - _storedTier.remainingQuantity)) +\n      _numberOfReservedTokensOutstandingFor(_nft, _i, _storedTier);\n\n    unchecked {\n      ++_i;\n    }\n  }\n}\n```\n\n[JBTiered721Delegate.\\_totalRedemptionWeight](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721Delegate.sol#L712)\n\n`JBTiered721DelegateStore.totalRedemptionWeight` is called in the `JBTiered721Delegate._totalRedemptionWeight` function.\n\n```solidity\nfunction _totalRedemptionWeight() internal view virtual override returns (uint256) {\n  return store.totalRedemptionWeight(address(this));\n}\n```\n\n[abstract/JB721Delegate.redeemParams](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/abstract/JB721Delegate.sol#L139)\n\nThis `JBTiered721Delegate._totalRedemptionWeight` function is then called in the `JB721Delegate.redeemParams` function, which ultimately calculates the `reclaimAmount` given an overflow and `_decodedTokenIds`.\n\n`uint256 _base = PRBMath.mulDiv(_data.overflow, _redemptionWeight, _total);` in [line 142](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/abstract/JB721Delegate.sol#L142) will lead to a lower `_base` due to the inflated denumerator `_total`.\n\n```solidity\nfunction redeemParams(JBRedeemParamsData calldata _data)\n  external\n  view\n  override\n  returns (\n    uint256 reclaimAmount,\n    string memory memo,\n    JBRedemptionDelegateAllocation[] memory delegateAllocations\n  )\n{\n  // Make sure fungible project tokens aren't being redeemed too.\n  if (_data.tokenCount > 0) revert UNEXPECTED_TOKEN_REDEEMED();\n\n  // Check the 4 bytes interfaceId and handle the case where the metadata was not intended for this contract\n  if (\n    _data.metadata.length < 4 || bytes4(_data.metadata[0:4]) != type(IJB721Delegate).interfaceId\n  ) {\n    revert INVALID_REDEMPTION_METADATA();\n  }\n\n  // Set the only delegate allocation to be a callback to this contract.\n  delegateAllocations = new JBRedemptionDelegateAllocation[](1);\n  delegateAllocations[0] = JBRedemptionDelegateAllocation(this, 0);\n\n  // If redemption rate is 0, nothing can be reclaimed from the treasury\n  if (_data.redemptionRate == 0) return (0, _data.memo, delegateAllocations);\n\n  // Decode the metadata\n  (, uint256[] memory _decodedTokenIds) = abi.decode(_data.metadata, (bytes4, uint256[]));\n\n  // Get a reference to the redemption rate of the provided tokens.\n  uint256 _redemptionWeight = _redemptionWeightOf(_decodedTokenIds);\n\n  // Get a reference to the total redemption weight.\n  uint256 _total = _totalRedemptionWeight(); // @audit-info Uses the inflated total redemption weight\n\n  // Get a reference to the linear proportion.\n  uint256 _base = PRBMath.mulDiv(_data.overflow, _redemptionWeight, _total);\n\n  // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary.\n  if (_data.redemptionRate == JBConstants.MAX_REDEMPTION_RATE)\n    return (_base, _data.memo, delegateAllocations);\n\n  // Return the weighted overflow, and this contract as the delegate so that tokens can be deleted.\n  return (\n    PRBMath.mulDiv(\n      _base,\n      _data.redemptionRate +\n        PRBMath.mulDiv(\n          _redemptionWeight,\n          JBConstants.MAX_REDEMPTION_RATE - _data.redemptionRate,\n          _total\n        ),\n      JBConstants.MAX_REDEMPTION_RATE\n    ),\n    _data.memo,\n    delegateAllocations\n  );\n}\n```\n\n### Recommended mitigation steps\n\nConsider validating the tier reserved rate `reservedRate` in the `JBTiered721DelegateStore.recordAddTiers` function to ensure the reserved rate is not greater than `JBConstants.MAX_RESERVED_RATE`.\n\n**[mejango (Juicebox DAO) confirmed](https://github.com/code-423n4/2022-10-juicebox-findings/issues/201)**\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-10-juicebox-contest",
  "Code": [
    {
      "filename": "contracts/JBTiered721DelegateStore.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport '@jbx-protocol/juice-contracts-v3/contracts/libraries/JBConstants.sol';\nimport './interfaces/IJBTiered721DelegateStore.sol';\nimport './libraries/JBBitmap.sol';\nimport './structs/JBBitmapWord.sol';\nimport './structs/JBStored721Tier.sol';\n\n/**\n  @title\n  JBTiered721DelegateStore\n\n  @notice\n  The contract that stores and manages the NFT's data.\n\n  @dev\n  Adheres to -\n  IJBTiered721DelegateStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.\n*/\ncontract JBTiered721DelegateStore is IJBTiered721DelegateStore {\n  using JBBitmap for mapping(uint256=>uint256);\n  using JBBitmap for JBBitmapWord;\n\n  //*********************************************************************//\n  // --------------------------- custom errors ------------------------- //\n  //*********************************************************************//\n\n  error CANT_MINT_MANUALLY();\n  error INSUFFICIENT_AMOUNT();\n  error INSUFFICIENT_RESERVES();\n  error INVALID_TIER();\n  error NO_QUANTITY();\n  error OUT();\n  error RESERVED_RATE_NOT_ALLOWED();\n  error MANUAL_MINTING_NOT_ALLOWED();\n  error PRICING_RESOLVER_CHANGES_LOCKED();\n  error TIER_LOCKED();\n  error TIER_REMOVED();\n  error VOTING_UNITS_NOT_ALLOWED();\n  error INVALID_PRICE_SORT_ORDER();\n\n  //*********************************************************************//\n  // --------------------- internal stored properties ------------------ //\n  //*********************************************************************//\n\n  /** \n    @notice\n    The index that should come after the given index when sorting by contribution floor.\n\n    @dev\n    If empty, assume the next index should come after. \n\n    _nft The NFT contract to get tier order index from.\n    _index The index to get a tier after relative to.\n  */\n  mapping(address => mapping(uint256 => uint256)) internal _tierIdAfter;\n\n  /**\n    @notice\n    An optional beneficiary for the reserved token of a given tier.\n\n    _nft The NFT contract to which the reserved token beneficiary belongs.\n    _tierId the ID of the tier.\n  */\n  mapping(address => mapping(uint256 => address)) internal _reservedTokenBeneficiaryOf;\n\n  /** \n    @notice\n    The stored reward tier. \n\n    _nft The NFT contract to which the tiers belong.\n    _tierId The incremental ID of the tier, starting with 1.\n  */\n  mapping(address => mapping(uint256 => JBStored721Tier)) internal _storedTierOf;\n\n  /**\n    @notice\n    Flags that influence the behavior of each NFT.\n\n    _nft The NFT for which the flags apply.\n  */\n  mapping(address => JBTiered721Flags) internal _flagsOf;\n\n  /** \n    @notice\n    For each tier ID, a flag indicating if the tier has been removed. \n\n    _nft The NFT contract to which the tier belong.\n    _depth The bitmap row\n    _word The row content\n  */\n  mapping(address => mapping(uint256 => uint256)) internal _isTierRemoved;\n\n  /** \n    @notice\n    For each NFT, the tier ID that comes last when sorting. \n\n    @dev\n    If not set, it is assumed the `maxTierIdOf` is the last sorted.\n\n    _nft The NFT contract to which the tier belongs.\n  */\n  mapping(address => uint256) internal _trackedLastSortTierIdOf;\n\n  //*********************************************************************//\n  // --------------------- public stored properties -------------------- //\n  //*********************************************************************//\n\n  /** \n    @notice\n    The biggest tier ID used. \n\n    @dev\n    This may not include the last tier ID if it has been removed.\n\n    _nft The NFT contract to get the number of tiers.\n  */\n  mapping(address => uint256) public override maxTierIdOf;\n\n  /** \n    @notice\n    Each account's balance within a specific tier.\n\n    _nft The NFT contract to which the tier balances belong.\n    _owner The address to get a balance for. \n    _tierId The ID of the tier to get a balance within.\n  */\n  mapping(address => mapping(address => mapping(uint256 => uint256))) public override tierBalanceOf;\n\n  /**\n    @notice \n    The number of reserved tokens that have been minted for each tier. \n\n    _nft The NFT contract to which the reserve data belong.\n    _tierId The ID of the tier to get a minted reserved token count for.\n   */\n  mapping(address => mapping(uint256 => uint256)) public override numberOfReservesMintedFor;\n\n  /**\n    @notice \n    The number of tokens that have been burned for each tier. \n\n    _nft The NFT contract to which the burned data belong.\n    _tierId The ID of the tier to get a burned token count for.\n   */\n  mapping(address => mapping(uint256 => uint256)) public override numberOfBurnedFor;\n\n  /** \n    @notice\n    The beneficiary of reserved tokens when the tier doesn't specify a beneficiary.\n\n    _nft The NFT contract to which the reserved token beneficiary applies.\n  */\n  mapping(address => address) public override defaultReservedTokenBeneficiaryOf;\n\n  /**\n    @notice\n    The first owner of each token ID, stored on first transfer out.\n\n    _nft The NFT contract to which the token belongs.\n    _tokenId The ID of the token to get the stored first owner of.\n  */\n  mapping(address => mapping(uint256 => address)) public override firstOwnerOf;\n\n  /**\n    @notice\n    The common base for the tokenUri's\n\n    _nft The NFT for which the base URI applies.\n  */\n  mapping(address => string) public override baseUriOf;\n\n  /**\n    @notice\n    Custom token URI resolver, superceeds base URI.\n\n    _nft The NFT for which the token URI resolver applies.\n  */\n  mapping(address => IJBTokenUriResolver) public override tokenUriResolverOf;\n\n  /**\n    @notice\n    Contract metadata uri.\n\n    _nft The NFT for which the contract URI resolver applies.\n  */\n  mapping(address => string) public override contractUriOf;\n\n  /**\n    @notice\n    When using this contract to manage token uri's, those are stored as 32bytes, based on IPFS hashes stripped down.\n\n    _nft The NFT contract to which the encoded upfs uri belongs.\n    _tierId the ID of the tier\n  */\n  mapping(address => mapping(uint256 => bytes32)) public override encodedIPFSUriOf;\n\n  //*********************************************************************//\n  // ------------------------- external views -------------------------- //\n  //*********************************************************************//\n\n  /** \n    @notice\n    Gets an array of all the active tiers. \n\n    @param _nft The NFT contract to get tiers for.\n    @param _startingId The start index of the array of tiers sorted by contribution floor. Send 0 to start at the beginning.\n    @param _size The number of tiers to include.\n\n    @return _tiers All the tiers.\n  */\n  function tiers(\n    address _nft,\n    uint256 _startingId,\n    uint256 _size\n  ) external view override returns (JB721Tier[] memory _tiers) {\n    // Keep a reference to the last tier ID.\n    uint256 _lastTierId = _lastSortIndexOf(_nft);\n\n    // Initialize an array with the appropriate length.\n    _tiers = new JB721Tier[](_size);\n\n    // Count the number of included tiers.\n    uint256 _numberOfIncludedTiers;\n\n    // Get a reference to the index being iterated on, starting with the starting index.\n    uint256 _currentSortIndex = _startingId != 0 ? _startingId : _firstSortIndexOf(_nft);\n\n    // Keep a referecen to the tier being iterated on.\n    JBStored721Tier memory _storedTier;\n\n    // Initialise a BitmapWord for isRemoved\n    JBBitmapWord memory _bitmapWord = _isTierRemoved[_nft].readId(_currentSortIndex);\n\n    // Make the sorted array.\n    while (_currentSortIndex != 0 && _numberOfIncludedTiers < _size) {\n      // Is the current index outside the currently stored word for isRemoved?\n      if (_bitmapWord.refreshBitmapNeeded(_currentSortIndex))\n        _bitmapWord = _isTierRemoved[_nft].readId(_currentSortIndex);\n\n      if (!_bitmapWord.isTierIdRemoved(_currentSortIndex)) {\n        _storedTier = _storedTierOf[_nft][_currentSortIndex];\n        // Add the tier to the array being returned.\n        _tiers[_numberOfIncludedTiers++] = JB721Tier({\n          id: _currentSortIndex,\n          contributionFloor: _storedTier.contributionFloor,\n          lockedUntil: _storedTier.lockedUntil,\n          remainingQuantity: _storedTier.remainingQuantity,\n          initialQuantity: _storedTier.initialQuantity,\n          votingUnits: _storedTier.votingUnits,\n          reservedRate: _storedTier.reservedRate,\n          reservedTokenBeneficiary: reservedTokenBeneficiaryOf(_nft, _currentSortIndex),\n          encodedIPFSUri: encodedIPFSUriOf[_nft][_currentSortIndex],\n          allowManualMint: _storedTier.allowManualMint\n        });\n      }\n\n      // Set the next sort index.\n      _currentSortIndex = _nextSortIndex(_nft, _currentSortIndex, _lastTierId);\n    }\n\n    // Resize the array if there are removed tiers\n    if (_numberOfIncludedTiers != _size)\n      assembly (\"memory-safe\"){\n        mstore(_tiers, _numberOfIncludedTiers)\n      }\n  }\n\n  /** \n    @notice\n    Return the tier for the specified ID. \n\n    @param _nft The NFT to get a tier within.\n    @param _id The ID of the tier to get. \n\n    @return The tier.\n  */\n  function tier(address _nft, uint256 _id) external view override returns (JB721Tier memory) {\n    // Get the stored tier.\n    JBStored721Tier memory _storedTier = _storedTierOf[_nft][_id];\n\n    return\n      JB721Tier({\n        id: _id,\n        contributionFloor: _storedTier.contributionFloor,\n        lockedUntil: _storedTier.lockedUntil,\n        remainingQuantity: _storedTier.remainingQuantity,\n        initialQuantity: _storedTier.initialQuantity,\n        votingUnits: _storedTier.votingUnits,\n        reservedRate: _storedTier.reservedRate,\n        reservedTokenBeneficiary: reservedTokenBeneficiaryOf(_nft, _id),\n        encodedIPFSUri: encodedIPFSUriOf[_nft][_id],\n        allowManualMint: _storedTier.allowManualMint\n      });\n  }\n\n  /**  \n    @notice\n    Return the tier for the specified token ID. \n\n    @param _nft The NFT to get a tier within.\n    @param _tokenId The ID of token to return the tier of. \n\n    @return The tier.\n  */\n  function tierOfTokenId(address _nft, uint256 _tokenId)\n    external\n    view\n    override\n    returns (JB721Tier memory)\n  {\n    // Get a reference to the tier's ID.\n    uint256 _tierId = tierIdOfToken(_tokenId);\n\n    // Get the stored tier.\n    JBStored721Tier memory _storedTier = _storedTierOf[_nft][_tierId];\n\n    return\n      JB721Tier({\n        id: _tierId,\n        contributionFloor: _storedTier.contributionFloor,\n        lockedUntil: _storedTier.lockedUntil,\n        remainingQuantity: _storedTier.remainingQuantity,\n        initialQuantity: _storedTier.initialQuantity,\n        votingUnits: _storedTier.votingUnits,\n        reservedRate: _storedTier.reservedRate,\n        reservedTokenBeneficiary: reservedTokenBeneficiaryOf(_nft, _tierId),\n        encodedIPFSUri: encodedIPFSUriOf[_nft][_tierId],\n        allowManualMint: _storedTier.allowManualMint\n      });\n  }\n\n  /** \n    @notice \n    The total supply of issued NFTs from all tiers.\n\n    @param _nft The NFT to get a total supply of.\n\n    @return supply The total number of NFTs between all tiers.\n  */\n  function totalSupply(address _nft) external view override returns (uint256 supply) {\n    // Keep a reference to the tier being iterated on.\n    JBStored721Tier storage _storedTier;\n\n    // Keep a reference to the greatest tier ID.\n    uint256 _maxTierId = maxTierIdOf[_nft];\n\n    for (uint256 _i = _maxTierId; _i != 0; ) {\n      // Set the tier being iterated on.\n      _storedTier = _storedTierOf[_nft][_i];\n\n      // Increment the total supply with the amount used already.\n      supply += _storedTier.initialQuantity - _storedTier.remainingQuantity;\n\n      unchecked {\n        --_i;\n      }\n    }\n  }\n\n  /** \n    @notice\n    The number of reserved tokens that can currently be minted within the tier. \n\n    @param _nft The NFT to get a number of reserved tokens outstanding.\n    @param _tierId The ID of the tier to get a number of reserved tokens outstanding.\n\n    @return The outstanding number of reserved tokens within the tier.\n  */\n  function numberOfReservedTokensOutstandingFor(address _nft, uint256 _tierId)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return _numberOfReservedTokensOutstandingFor(_nft, _tierId, _storedTierOf[_nft][_tierId]);\n  }\n\n  /**\n    @notice\n    The voting units for an account from its NFTs across all tiers. NFTs have a tier-specific preset number of voting units. \n\n    @param _nft The NFT to get voting units within.\n    @param _account The account to get voting units for.\n\n    @return units The voting units for the account.\n  */\n  function votingUnitsOf(address _nft, address _account)\n    external\n    view\n    virtual\n    override\n    returns (uint256 units)\n  {\n    // Keep a reference to the greatest tier ID.\n    uint256 _maxTierId = maxTierIdOf[_nft];\n\n    // Keep a reference to the balance being iterated on.\n    uint256 _balance;\n\n    // Loop through all tiers.\n    for (uint256 _i = _maxTierId; _i != 0; ) {\n      // Get a reference to the account's balance in this tier.\n      _balance = tierBalanceOf[_nft][_account][_i];\n\n      if (_balance != 0)\n        // Add the tier's voting units.\n        units += _balance * _storedTierOf[_nft][_i].votingUnits;\n\n      unchecked {\n        --_i;\n      }\n    }\n  }\n\n  /**\n    @notice\n    The voting units for an account from its NFTs across all tiers. NFTs have a tier-specific preset number of voting units. \n\n    @param _nft The NFT to get voting units within.\n    @param _account The account to get voting units for.\n    @param _tierId The ID of the tier to get voting units for.\n\n    @return The voting units for the account.\n  */\n  function tierVotingUnitsOf(\n    address _nft,\n    address _account,\n    uint256 _tierId\n  ) external view virtual override returns (uint256) {\n    // Get a reference to the account's balance in this tier.\n    uint256 _balance = tierBalanceOf[_nft][_account][_tierId];\n\n    if (_balance == 0) return 0;\n\n    // Add the tier's voting units.\n    return _balance * _storedTierOf[_nft][_tierId].votingUnits;\n  }\n\n  /**\n    @notice\n    Resolves the encoded tier IPFS URI of the tier for the given token.\n\n    @param _nft The NFT contract to which the encoded IPFS URI belongs.\n    @param _tokenId the ID of the token.\n\n    @return The encoded IPFS URI.\n  */\n  function encodedTierIPFSUriOf(address _nft, uint256 _tokenId)\n    external\n    view\n    override\n    returns (bytes32)\n  {\n    return encodedIPFSUriOf[_nft][tierIdOfToken(_tokenId)];\n  }\n\n  /** \n    @notice\n    Flags that influence the behavior of each NFT.\n\n    @param _nft The NFT for which the flags apply.\n\n    @return The flags.\n  */\n  function flagsOf(address _nft) external view override returns (JBTiered721Flags memory) {\n    return _flagsOf[_nft];\n  }\n\n  /** \n    @notice\n    Tier removed from the current tiering\n\n    @param _nft The NFT for which the removed tier is queried\n    @param _tierId The tier ID\n\n    @return True if the tier has been removed\n  */\n  function isTierRemoved(address _nft, uint256 _tierId) external view override returns(bool) {\n    JBBitmapWord memory _bitmapWord = _isTierRemoved[_nft].readId(_tierId);\n    \n    return _bitmapWord.isTierIdRemoved(_tierId);\n  }\n\n  //*********************************************************************//\n  // -------------------------- public views --------------------------- //\n  //*********************************************************************//\n\n  /** \n    @notice \n    The total number of tokens owned by the given owner. \n\n    @param _nft The NFT to get a balance from.\n    @param _owner The address to check the balance of.\n\n    @return balance The number of tokens owners by the owner accross all tiers.\n  */\n  function balanceOf(address _nft, address _owner) public view override returns (uint256 balance) {\n    // Keep a reference to the greatest tier ID.\n    uint256 _maxTierId = maxTierIdOf[_nft];\n\n    // Loop through all tiers.\n    for (uint256 _i = _maxTierId; _i != 0; ) {\n      // Get a reference to the account's balance in this tier.\n      balance += tierBalanceOf[_nft][_owner][_i];\n\n      unchecked {\n        --_i;\n      }\n    }\n  }\n\n  /**\n    @notice\n    The cumulative weight the given token IDs have in redemptions compared to the `totalRedemptionWeight`.\n\n    @param _nft The NFT for which the redemption weight is being calculated.\n    @param _tokenIds The IDs of the tokens to get the cumulative redemption weight of.\n\n    @return weight The weight.\n  */\n  function redemptionWeightOf(address _nft, uint256[] calldata _tokenIds)\n    public\n    view\n    override\n    returns (uint256 weight)\n  {\n    // Get a reference to the total number of tokens.\n    uint256 _numberOfTokenIds = _tokenIds.length;\n\n    // Add each token's tier's contribution floor to the weight.\n    for (uint256 _i; _i < _numberOfTokenIds; ) {\n      weight += _storedTierOf[_nft][tierIdOfToken(_tokenIds[_i])].contributionFloor;\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /**\n    @notice\n    The cumulative weight that all token IDs have in redemptions.\n\n    @param _nft The NFT for which the redemption weight is being calculated.\n\n    @return weight The total weight.\n  */\n  function totalRedemptionWeight(address _nft) public view override returns (uint256 weight) {\n    // Keep a reference to the greatest tier ID.\n    uint256 _maxTierId = maxTierIdOf[_nft];\n\n    // Keep a reference to the tier being iterated on.\n    JBStored721Tier memory _storedTier;\n\n    // Add each token's tier's contribution floor to the weight.\n    for (uint256 _i; _i < _maxTierId; ) {\n      // Keep a reference to the stored tier.\n      _storedTier = _storedTierOf[_nft][_i + 1];\n\n      // Add the tier's contribution floor multiplied by the quantity minted.\n      weight +=\n        (_storedTier.contributionFloor *\n          (_storedTier.initialQuantity - _storedTier.remainingQuantity)) +\n        _numberOfReservedTokensOutstandingFor(_nft, _i, _storedTier);\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /** \n    @notice\n    The tier number of the provided token ID. \n\n    @dev\n    Tier's are 1 indexed from the `tiers` array, meaning the 0th element of the array is tier 1.\n\n    @param _tokenId The ID of the token to get the tier number of. \n\n    @return The tier number of the specified token ID.\n  */\n  function tierIdOfToken(uint256 _tokenId) public pure override returns (uint256) {\n    // The tier ID is in the first 16 bits.\n    return uint256(uint16(_tokenId));\n  }\n\n  /** \n    @notice\n    The reserved token beneficiary for each tier. \n\n    @param _nft The NFT to get the reserved token beneficiary within.\n    @param _tierId The ID of the tier to get a reserved token beneficiary of.\n\n    @return The reserved token benficiary.\n  */\n  function reservedTokenBeneficiaryOf(address _nft, uint256 _tierId)\n    public\n    view\n    override\n    returns (address)\n  {\n    // Get the stored reserved token beneficiary.\n    address _storedReservedTokenBeneficiaryOfTier = _reservedTokenBeneficiaryOf[_nft][_tierId];\n\n    // If the tier has a beneficiary return it.\n    if (_storedReservedTokenBeneficiaryOfTier != address(0))\n      return _storedReservedTokenBeneficiaryOfTier;\n\n    // Return the default.\n    return defaultReservedTokenBeneficiaryOf[_nft];\n  }\n\n  //*********************************************************************//\n  // ---------------------- external transactions ---------------------- //\n  //*********************************************************************//\n\n  /** \n    @notice\n    Adds tiers. \n\n    @param _tiersToAdd The tiers to add.\n\n    @return tierIds The IDs of the tiers added.\n  */\n  function recordAddTiers(JB721TierParams[] memory _tiersToAdd)\n    external\n    override\n    returns (uint256[] memory tierIds)\n  {\n    // Get a reference to the number of new tiers.\n    uint256 _numberOfNewTiers = _tiersToAdd.length;\n\n    // Keep a reference to the greatest tier ID.\n    uint256 _currentMaxTierIdOf = maxTierIdOf[msg.sender];\n\n    // Keep a reference to the current last sorted tier ID.\n    uint256 _currentLastSortIndex = _lastSortIndexOf(msg.sender);\n\n    // Initialize an array with the appropriate length.\n    tierIds = new uint256[](_numberOfNewTiers);\n\n    // Keep a reference to the starting sort ID for sorting new tiers if needed.\n    // There's no need for sorting if there are currently no tiers.\n    // If there's no sort index, start with the first index.\n    uint256 _startSortIndex = _currentMaxTierIdOf == 0 ? 0 : _firstSortIndexOf(msg.sender);\n\n    // Keep track of the previous index.\n    uint256 _previous;\n\n    // Keep a reference to the tier being iterated on.\n    JB721TierParams memory _tierToAdd;\n\n    // Keep a reference to the flags.\n    JBTiered721Flags memory _flags = _flagsOf[msg.sender];\n\n    for (uint256 _i; _i < _numberOfNewTiers; ) {\n      // Set the tier being iterated on.\n      _tierToAdd = _tiersToAdd[_i];\n\n      // Make sure the tier's contribution floor is greater than or equal to the previous contribution floor.\n      if (_i != 0 && _tierToAdd.contributionFloor < _tiersToAdd[_i - 1].contributionFloor)\n        revert INVALID_PRICE_SORT_ORDER();\n\n      // Make sure there are no voting units set if they're not allowed.\n      if (_flags.lockVotingUnitChanges && _tierToAdd.votingUnits != 0)\n        revert VOTING_UNITS_NOT_ALLOWED();\n\n      // Make sure a reserved rate isn't set if changes should be locked or if manual minting is allowed.\n      if (\n        (_flags.lockReservedTokenChanges || _tierToAdd.allowManualMint) &&\n        _tierToAdd.reservedRate != 0\n      ) revert RESERVED_RATE_NOT_ALLOWED();\n\n      // Make sure manual minting is not set if not allowed.\n      if (_flags.lockManualMintingChanges && _tierToAdd.allowManualMint)\n        revert MANUAL_MINTING_NOT_ALLOWED();\n\n      // Make sure there is some quantity.\n      if (_tierToAdd.initialQuantity == 0) revert NO_QUANTITY();\n\n      // Get a reference to the tier ID.\n      uint256 _tierId = _currentMaxTierIdOf + _i + 1;\n\n      // Add the tier with the iterative ID.\n      _storedTierOf[msg.sender][_tierId] = JBStored721Tier({\n        contributionFloor: uint80(_tierToAdd.contributionFloor),\n        lockedUntil: uint48(_tierToAdd.lockedUntil),\n        remainingQuantity: uint40(_tierToAdd.initialQuantity),\n        initialQuantity: uint40(_tierToAdd.initialQuantity),\n        votingUnits: uint16(_tierToAdd.votingUnits),\n        reservedRate: uint16(_tierToAdd.reservedRate),\n        allowManualMint: _tierToAdd.allowManualMint\n      });\n\n      // Set the reserved token beneficiary if needed.\n      if (\n        _tierToAdd.reservedTokenBeneficiary != address(0) &&\n        _tierToAdd.reservedTokenBeneficiary != defaultReservedTokenBeneficiaryOf[msg.sender]\n      ) {\n        if (_tierToAdd.shouldUseBeneficiaryAsDefault)\n          defaultReservedTokenBeneficiaryOf[msg.sender] = _tierToAdd.reservedTokenBeneficiary;\n        else _reservedTokenBeneficiaryOf[msg.sender][_tierId] = _tierToAdd.reservedTokenBeneficiary;\n      }\n\n      // Set the encodedIPFSUri if needed.\n      if (_tierToAdd.encodedIPFSUri != bytes32(0))\n        encodedIPFSUriOf[msg.sender][_tierId] = _tierToAdd.encodedIPFSUri;\n\n      if (_startSortIndex != 0) {\n        // Keep track of the sort index.\n        uint256 _currentSortIndex = _startSortIndex;\n\n        // Initialise a BitmapWord for isRemoved\n        JBBitmapWord memory _bitmapWord = _isTierRemoved[msg.sender].readId(_currentSortIndex);\n\n        // Keep a reference to the idex to iterate on next.\n        uint256 _next;\n\n        while (_currentSortIndex != 0) {\n          // Is the current index outside the currently stored word?\n          if (_bitmapWord.refreshBitmapNeeded(_currentSortIndex))\n            _bitmapWord = _isTierRemoved[msg.sender].readId(_currentSortIndex);\n\n          // Set the next index.\n          _next = _nextSortIndex(msg.sender, _currentSortIndex, _currentLastSortIndex);\n\n          // If the contribution floor is less than the tier being iterated on, store the order.\n          if (\n            _tierToAdd.contributionFloor <\n            _storedTierOf[msg.sender][_currentSortIndex].contributionFloor\n          ) {\n            // If the index being iterated on isn't the next index, set the after.\n            if (_currentSortIndex != _tierId + 1)\n              _tierIdAfter[msg.sender][_tierId] = _currentSortIndex;\n\n            // If this is the last tier being added, track the current last sort index if it's not already tracked.\n            if (\n              _i == _numberOfNewTiers - 1 && \n              _trackedLastSortTierIdOf[msg.sender] != _currentLastSortIndex\n            ) _trackedLastSortTierIdOf[msg.sender] = _currentLastSortIndex;\n\n            // If the previous after index was set to something else, set the previous after.\n            if (_previous != _tierId - 1 || _tierIdAfter[msg.sender][_previous] != 0)\n              // Set the tier after the previous one being iterated on as the tier being added, or 0 if the index is incremented.\n              _tierIdAfter[msg.sender][_previous] = _previous == _tierId - 1 ? 0 : _tierId;\n\n            // For the next tier being added, start at this current index.\n            _startSortIndex = _currentSortIndex;\n\n            // The tier just added is the previous for the next tier being added.\n            _previous = _tierId;\n\n            // Set current to zero to break out of the loop.\n            _currentSortIndex = 0;\n          }\n          // If the tier being iterated on is the last tier, add the tier after it.\n          else if (_next == 0 || _next > _currentMaxTierIdOf) {\n            if (_tierId != _currentSortIndex + 1)\n              _tierIdAfter[msg.sender][_currentSortIndex] = _tierId;\n\n            // For the next tier being added, start at this current index.\n            _startSortIndex = _tierId;\n\n            // Break out.\n            _currentSortIndex = 0;\n\n            // If there's currently a last sort index tracked, override it.\n            if (_trackedLastSortTierIdOf[msg.sender] != 0) \n              _trackedLastSortTierIdOf[msg.sender] = 0;\n          }\n          // Move on to the next index.\n          else {\n            // Set the previous index to be the current index.\n            _previous = _currentSortIndex;\n\n            // Go to the next index.\n            _currentSortIndex = _next;\n          }\n        }\n      }\n\n      // Set the tier ID in the returned value.\n      tierIds[_i] = _tierId;\n\n      unchecked {\n        ++_i;\n      }\n    }\n\n    maxTierIdOf[msg.sender] = _currentMaxTierIdOf + _numberOfNewTiers;\n  }\n\n  /** \n    @notice\n    Mint a token within the tier for the provided value.\n\n    @dev\n    Only a project owner can mint tokens.\n\n    @param _tierId The ID of the tier to mint within.\n    @param _count The number of reserved tokens to mint. \n\n    @return tokenIds The IDs of the tokens being minted as reserves.\n  */\n  function recordMintReservesFor(uint256 _tierId, uint256 _count)\n    external\n    override\n    returns (uint256[] memory tokenIds)\n  {\n    // Get a reference to the tier.\n    JBStored721Tier storage _storedTier = _storedTierOf[msg.sender][_tierId];\n\n    // Get a reference to the number of reserved tokens mintable for the tier.\n    uint256 _numberOfReservedTokensOutstanding = _numberOfReservedTokensOutstandingFor(\n      msg.sender,\n      _tierId,\n      _storedTier\n    );\n\n    // Can't mint more reserves than expected.\n    if (_count > _numberOfReservedTokensOutstanding) revert INSUFFICIENT_RESERVES();\n\n    // Increment the number of reserved tokens minted.\n    numberOfReservesMintedFor[msg.sender][_tierId] += _count;\n\n    // Initialize an array with the appropriate length.\n    tokenIds = new uint256[](_count);\n\n    // Keep a reference to the number of burned in the tier.\n    uint256 _numberOfBurnedFromTier = numberOfBurnedFor[msg.sender][_tierId];\n\n    for (uint256 _i; _i < _count; ) {\n      // Generate the tokens.\n      tokenIds[_i] = _generateTokenId(\n        _tierId,\n        _storedTier.initialQuantity - --_storedTier.remainingQuantity + _numberOfBurnedFromTier\n      );\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /** \n    @notice\n    Sets the reserved token beneficiary.\n\n    @param _beneficiary The reservd token beneficiary.\n  */\n  function recordSetDefaultReservedTokenBeneficiary(address _beneficiary) external override {\n    defaultReservedTokenBeneficiaryOf[msg.sender] = _beneficiary;\n  }\n\n  /** \n    @notice\n    Record a token transfer.\n\n    @param _tierId The ID the tier being transfered\n    @param _from The sender of the token.\n    @param _to The recipient of the token.\n  */\n  function recordTransferForTier(\n    uint256 _tierId,\n    address _from,\n    address _to\n  ) external override {\n    // If this is not a mint then subtract the tier balance from the original holder.\n    if (_from != address(0))\n      // decrease the tier balance for the sender\n      --tierBalanceOf[msg.sender][_from][_tierId];\n\n    // if this is a burn the balance is not added\n    if (_to != address(0)) {\n      unchecked {\n        // increase the tier balance for the beneficiary\n        ++tierBalanceOf[msg.sender][_to][_tierId];\n      }\n    }\n  }\n\n  /** \n    @notice\n    Remove tiers. \n\n    @param _tierIds The tiers IDs to remove.\n  */\n  function recordRemoveTierIds(uint256[] calldata _tierIds) external override {\n    // Get a reference to the number of tiers being removed.\n    uint256 _numTiers = _tierIds.length;\n\n    // Keep a reference to the tier ID being iterated on.\n    uint256 _tierId;\n\n    for (uint256 _i; _i < _numTiers; ) {\n      // Set the tier being iterated on, 0-indexed\n      _tierId = _tierIds[_i];\n\n      // If the tier is locked throw an error.\n      if (_storedTierOf[msg.sender][_tierId].lockedUntil >= block.timestamp) revert TIER_LOCKED();\n\n      // Set the tier as removed.\n      _isTierRemoved[msg.sender].removeTier(_tierId);\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /** \n    @notice\n    Mints a token in the best available tier.\n\n    @param _amount The amount to base the mint on.\n\n    @return tokenId The token ID minted.\n    @return tierId The ID of the tier minted from.\n    @return leftoverAmount The amount leftover after the mint. \n  */\n  function recordMintBestAvailableTier(uint256 _amount)\n    external\n    override\n    returns (\n      uint256 tokenId,\n      uint256 tierId,\n      uint256 leftoverAmount\n    )\n  {\n    // Keep a reference to the last tier ID.\n    uint256 _lastTierId = _lastSortIndexOf(msg.sender);\n\n    // Keep a reference to the tier being iterated on.\n    JBStored721Tier memory _storedTier;\n\n    // Keep a reference to the starting sort ID for sorting new tiers if needed.\n    // There's no need for sorting if there are currently no tiers.\n    // If there's no sort index, start with the first index.\n    uint256 _currentSortIndex = _firstSortIndexOf(msg.sender);\n\n    // Keep a reference to the best contribution floor.\n    uint256 _bestContributionFloor;\n\n    // Initialise a BitmapWord to read isRemoved\n    JBBitmapWord memory _bitmapWord = _isTierRemoved[msg.sender].readId(_currentSortIndex);\n\n    while (_currentSortIndex != 0) {\n      // Set the tier being iterated on. Tier's are 1 indexed.\n      _storedTier = _storedTierOf[msg.sender][_currentSortIndex];\n\n      // Is the current index outside the currently stored word?\n      if (_bitmapWord.refreshBitmapNeeded(_currentSortIndex))\n        _bitmapWord = _isTierRemoved[msg.sender].readId(_currentSortIndex);\n\n      // If the contribution floor has gone over, break out of the loop.\n      if (_storedTier.contributionFloor > _amount) _currentSortIndex = 0;\n      else {\n        // If the tier is not removed, check to see if it's optimal.\n        // Set the tier as the best available so far if there is still a remaining quantity.\n        if (\n          !_bitmapWord.isTierIdRemoved(_currentSortIndex) &&\n          _storedTier.contributionFloor > _bestContributionFloor &&\n          (_storedTier.remainingQuantity -\n            _numberOfReservedTokensOutstandingFor(msg.sender, _currentSortIndex, _storedTier)) !=\n          0\n        ) {\n          tierId = _currentSortIndex;\n          _bestContributionFloor = _storedTier.contributionFloor;\n        }\n\n        // Set the next sort index.\n        _currentSortIndex = _nextSortIndex(msg.sender, _currentSortIndex, _lastTierId);\n      }\n    }\n\n    // If there's no best tier, return.\n    if (tierId == 0) leftoverAmount = _amount;\n    else {\n      // Keep a reference to the best tier.\n      JBStored721Tier storage _bestStoredTier = _storedTierOf[msg.sender][tierId];\n\n      // Make the token ID.\n      unchecked {\n        // Keep a reference to the token ID.\n        tokenId = _generateTokenId(\n          tierId,\n          _b"
    }
  ]
}