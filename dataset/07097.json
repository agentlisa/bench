{
  "Title": "[G-04] The result of a function call should be cached rather than re-calling the function",
  "Content": "\nExternal calls are expensive. Consider caching the following:\n\nhttps://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/adapter/yearn/YearnAdapter.sol#L89-L98\n\n### YearnAdapter.sol.\\_shareValue():  Results of yVault.totalSupply() should be cached(Saves gas in happy case)\n```solidity\nFile: /src/vault/adapter/yearn/YearnAdapter.sol\n89:    function _shareValue(uint256 yShares) internal view returns (uint256) {\n90:        if (yVault.totalSupply() == 0) return yShares; //@audit: initial call\n\n92:        return\n93:            yShares.mulDiv(\n94:                _freeFunds(),\n95:                yVault.totalSupply(),//@audit: 2nd call\n96:                Math.Rounding.Down\n97:            );\n98:    }\n```\n\n```diff\ndiff --git a/src/vault/adapter/yearn/YearnAdapter.sol b/src/vault/adapter/yearn/YearnAdapter.sol\nindex d951e63..12114a3 100644\n--- a/src/vault/adapter/yearn/YearnAdapter.sol\n+++ b/src/vault/adapter/yearn/YearnAdapter.sol\n@@ -87,12 +87,13 @@ contract YearnAdapter is AdapterBase {\n\n     /// @notice Determines the current value of `yShares` in assets\n     function _shareValue(uint256 yShares) internal view returns (uint256) {\n-        if (yVault.totalSupply() == 0) return yShares;\n+        uint256 _yVaultTotalSupply = yVault.totalSupply();\n+        if (_yVaultTotalSupply == 0) return yShares;\n\n         return\n             yShares.mulDiv(\n                 _freeFunds(),\n-                yVault.totalSupply(),\n+                _yVaultTotalSupply,\n                 Math.Rounding.Down\n             );\n     }\n```\n\nhttps://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/adapter/yearn/YearnAdapter.sol#L34-L55\n\n### YearnAdapter.sol.initialize(): Results of asset() should be cached and the cached value used instead of calling it twice\n\n```solidity\nFile: /src/vault/adapter/yearn/YearnAdapter.sol\n34:    function initialize(\n\n47:        _name = string.concat(\n48:            \"Popcorn Yearn\",\n49:            IERC20Metadata(asset()).name(),//@audit: 1st call\n50:            \" Adapter\"\n51:        );\n52:        _symbol = string.concat(\"popY-\", IERC20Metadata(asset()).symbol());//@audit: 2nd call\n```\n\n```diff\ndiff --git a/src/vault/adapter/yearn/YearnAdapter.sol b/src/vault/adapter/yearn/YearnAdapter.sol\nindex d951e63..f69ad26 100644\n--- a/src/vault/adapter/yearn/YearnAdapter.sol\n+++ b/src/vault/adapter/yearn/YearnAdapter.sol\n@@ -44,12 +44,14 @@ contract YearnAdapter is AdapterBase {\n\n         yVault = VaultAPI(IYearnRegistry(externalRegistry).latestVault(_asset));\n\n+        address asset_ = asset();\n+\n         _name = string.concat(\n             \"Popcorn Yearn\",\n-            IERC20Metadata(asset()).name(),\n+            IERC20Metadata(asset_).name(),\n             \" Adapter\"\n         );\n-        _symbol = string.concat(\"popY-\", IERC20Metadata(asset()).symbol());\n+        _symbol = string.concat(\"popY-\", IERC20Metadata(asset_).symbol());\n\n         IERC20(_asset).approve(address(yVault), type(uint256).max);\n     }\n```\n\nhttps://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/adapter/beefy/BeefyAdapter.sol#L46-L84\n\n### BeefyAdapter.sol.initialize(): Results of asset() should be cached and the cached value used\n```solidity\nFile: /src/vault/adapter/beefy/BeefyAdapter.sol\n46:    function initialize(\n47:        bytes memory adapterInitData,\n48:        address registry,\n49:        bytes memory beefyInitData\n50:    ) external initializer {\n\n59:        if (IBeefyVault(_beefyVault).want() != asset()) //@audit: 1st call\n60:            revert InvalidBeefyVault(_beefyVault);\n\n66:        _name = string.concat(\n67:            \"Popcorn Beefy\",\n68:            IERC20Metadata(asset()).name(), //@audit: 2nd call\n69:            \" Adapter\"\n70:        );\n71:        _symbol = string.concat(\"popB-\", IERC20Metadata(asset()).symbol());//@audit: 3rd call\n\n80:        IERC20(asset()).approve(_beefyVault, type(uint256).max);//@audit: 4th call\n```\n\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-01-popcorn",
  "Code": [
    {
      "filename": "src/vault/adapter/yearn/YearnAdapter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n// Docgen-SOLC: 0.8.15\n\npragma solidity ^0.8.15;\n\nimport {AdapterBase, ERC4626Upgradeable as ERC4626, IERC20, IERC20Metadata, ERC20, SafeERC20, Math, IStrategy, IAdapter} from \"../abstracts/AdapterBase.sol\";\nimport {VaultAPI, IYearnRegistry} from \"./IYearn.sol\";\n\n/**\n * @title   Yearn Adapter\n * @author  RedVeil\n * @notice  ERC4626 wrapper for Yearn Vaults.\n *\n * An ERC4626 compliant Wrapper for https://github.com/yearn/yearn-vaults/blob/master/contracts/Vault.vy.\n * Allows wrapping Yearn Vaults.\n */\ncontract YearnAdapter is AdapterBase {\n    using SafeERC20 for IERC20;\n    using Math for uint256;\n\n    string internal _name;\n    string internal _symbol;\n\n    VaultAPI public yVault;\n    uint256 constant DEGRADATION_COEFFICIENT = 10**18;\n\n    /**\n     * @notice Initialize a new Yearn Adapter.\n     * @param adapterInitData Encoded data for the base adapter initialization.\n     * @param externalRegistry Yearn registry address.\n     * @dev This function is called by the factory contract when deploying a new vault.\n     * @dev The yearn registry will be used given the `asset` from `adapterInitData` to find the latest yVault.\n     */\n    function initialize(\n        bytes memory adapterInitData,\n        address externalRegistry,\n        bytes memory\n    ) external initializer {\n        (address _asset, , , , , ) = abi.decode(\n            adapterInitData,\n            (address, address, address, uint256, bytes4[8], bytes)\n        );\n        __AdapterBase_init(adapterInitData);\n\n        yVault = VaultAPI(IYearnRegistry(externalRegistry).latestVault(_asset));\n\n        _name = string.concat(\n            \"Popcorn Yearn\",\n            IERC20Metadata(asset()).name(),\n            \" Adapter\"\n        );\n        _symbol = string.concat(\"popY-\", IERC20Metadata(asset()).symbol());\n\n        IERC20(_asset).approve(address(yVault), type(uint256).max);\n    }\n\n    function name()\n        public\n        view\n        override(IERC20Metadata, ERC20)\n        returns (string memory)\n    {\n        return _name;\n    }\n\n    function symbol()\n        public\n        view\n        override(IERC20Metadata, ERC20)\n        returns (string memory)\n    {\n        return _symbol;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          ACCOUNTING LOGIC\n  //////////////////////////////////////////////////////////////*/\n\n    /// @notice Emulate yearns total asset calculation to return the total assets of the vault.\n    function _totalAssets() internal view override returns (uint256) {\n        return _shareValue(underlyingBalance);\n    }\n\n    function _underlyingBalance() internal view override returns (uint256) {\n        return yVault.balanceOf(address(this));\n    }\n\n    /// @notice Determines the current value of `yShares` in assets\n    function _shareValue(uint256 yShares) internal view returns (uint256) {\n        if (yVault.totalSupply() == 0) return yShares;\n\n        return\n            yShares.mulDiv(\n                _freeFunds(),\n                yVault.totalSupply(),\n                Math.Rounding.Down\n            );\n    }\n\n    /// @notice The amount of assets that are free to be withdrawn from the yVault after locked profts.\n    function _freeFunds() internal view returns (uint256) {\n        return _yTotalAssets() - _calculateLockedProfit();\n    }\n\n    /**\n     * @notice Returns the total quantity of all assets under control of this Vault,\n     * whether they're loaned out to a Strategy, or currently held in the Vault.\n     */\n    function _yTotalAssets() internal view returns (uint256) {\n        return IERC20(asset()).balanceOf(address(yVault)) + yVault.totalDebt();\n    }\n\n    /// @notice Calculates how much profit is locked and cant be withdrawn.\n    function _calculateLockedProfit() internal view returns (uint256) {\n        uint256 lockedFundsRatio = (block.timestamp - yVault.lastReport()) *\n            yVault.lockedProfitDegradation();\n\n        if (lockedFundsRatio < DEGRADATION_COEFFICIENT) {\n            uint256 lockedProfit = yVault.lockedProfit();\n            return\n                lockedProfit -\n                ((lockedFundsRatio * lockedProfit) / DEGRADATION_COEFFICIENT);\n        } else {\n            return 0;\n        }\n    }\n\n    /// @notice The amount of yearn shares to withdraw given an amount of adapter shares\n    function convertToUnderlyingShares(uint256, uint256 shares)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return\n            shares.mulDiv(underlyingBalance, totalSupply(), Math.Rounding.Up);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    DEPOSIT/WITHDRAWAL LIMIT LOGIC\n  //////////////////////////////////////////////////////////////*/\n\n    /// @notice Applies the yVault deposit limit to the adapter.\n    function maxDeposit(address) public view override returns (uint256) {\n        if (paused()) return 0;\n\n        VaultAPI _bestVault = yVault;\n        uint256 assets = _bestVault.totalAssets();\n        uint256 _depositLimit = _bestVault.depositLimit();\n        if (assets >= _depositLimit) return 0;\n        return _depositLimit - assets;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _protocolDeposit(uint256 amount, uint256)\n        internal\n        virtual\n        override\n    {\n        yVault.deposit(amount);\n    }\n\n    function _protocolWithdraw(uint256 assets, uint256 shares)\n        internal\n        virtual\n        override\n    {\n        yVault.withdraw(convertToUnderlyingShares(assets, shares));\n    }\n}"
    },
    {
      "filename": "src/vault/adapter/yearn/YearnAdapter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n// Docgen-SOLC: 0.8.15\n\npragma solidity ^0.8.15;\n\nimport {AdapterBase, ERC4626Upgradeable as ERC4626, IERC20, IERC20Metadata, ERC20, SafeERC20, Math, IStrategy, IAdapter} from \"../abstracts/AdapterBase.sol\";\nimport {VaultAPI, IYearnRegistry} from \"./IYearn.sol\";\n\n/**\n * @title   Yearn Adapter\n * @author  RedVeil\n * @notice  ERC4626 wrapper for Yearn Vaults.\n *\n * An ERC4626 compliant Wrapper for https://github.com/yearn/yearn-vaults/blob/master/contracts/Vault.vy.\n * Allows wrapping Yearn Vaults.\n */\ncontract YearnAdapter is AdapterBase {\n    using SafeERC20 for IERC20;\n    using Math for uint256;\n\n    string internal _name;\n    string internal _symbol;\n\n    VaultAPI public yVault;\n    uint256 constant DEGRADATION_COEFFICIENT = 10**18;\n\n    /**\n     * @notice Initialize a new Yearn Adapter.\n     * @param adapterInitData Encoded data for the base adapter initialization.\n     * @param externalRegistry Yearn registry address.\n     * @dev This function is called by the factory contract when deploying a new vault.\n     * @dev The yearn registry will be used given the `asset` from `adapterInitData` to find the latest yVault.\n     */\n    function initialize(\n        bytes memory adapterInitData,\n        address externalRegistry,\n        bytes memory\n    ) external initializer {\n        (address _asset, , , , , ) = abi.decode(\n            adapterInitData,\n            (address, address, address, uint256, bytes4[8], bytes)\n        );\n        __AdapterBase_init(adapterInitData);\n\n        yVault = VaultAPI(IYearnRegistry(externalRegistry).latestVault(_asset));\n\n        _name = string.concat(\n            \"Popcorn Yearn\",\n            IERC20Metadata(asset()).name(),\n            \" Adapter\"\n        );\n        _symbol = string.concat(\"popY-\", IERC20Metadata(asset()).symbol());\n\n        IERC20(_asset).approve(address(yVault), type(uint256).max);\n    }\n\n    function name()\n        public\n        view\n        override(IERC20Metadata, ERC20)\n        returns (string memory)\n    {\n        return _name;\n    }\n\n    function symbol()\n        public\n        view\n        override(IERC20Metadata, ERC20)\n        returns (string memory)\n    {\n        return _symbol;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          ACCOUNTING LOGIC\n  //////////////////////////////////////////////////////////////*/\n\n    /// @notice Emulate yearns total asset calculation to return the total assets of the vault.\n    function _totalAssets() internal view override returns (uint256) {\n        return _shareValue(underlyingBalance);\n    }\n\n    function _underlyingBalance() internal view override returns (uint256) {\n        return yVault.balanceOf(address(this));\n    }\n\n    /// @notice Determines the current value of `yShares` in assets\n    function _shareValue(uint256 yShares) internal view returns (uint256) {\n        if (yVault.totalSupply() == 0) return yShares;\n\n        return\n            yShares.mulDiv(\n                _freeFunds(),\n                yVault.totalSupply(),\n                Math.Rounding.Down\n            );\n    }\n\n    /// @notice The amount of assets that are free to be withdrawn from the yVault after locked profts.\n    function _freeFunds() internal view returns (uint256) {\n        return _yTotalAssets() - _calculateLockedProfit();\n    }\n\n    /**\n     * @notice Returns the total quantity of all assets under control of this Vault,\n     * whether they're loaned out to a Strategy, or currently held in the Vault.\n     */\n    function _yTotalAssets() internal view returns (uint256) {\n        return IERC20(asset()).balanceOf(address(yVault)) + yVault.totalDebt();\n    }\n\n    /// @notice Calculates how much profit is locked and cant be withdrawn.\n    function _calculateLockedProfit() internal view returns (uint256) {\n        uint256 lockedFundsRatio = (block.timestamp - yVault.lastReport()) *\n            yVault.lockedProfitDegradation();\n\n        if (lockedFundsRatio < DEGRADATION_COEFFICIENT) {\n            uint256 lockedProfit = yVault.lockedProfit();\n            return\n                lockedProfit -\n                ((lockedFundsRatio * lockedProfit) / DEGRADATION_COEFFICIENT);\n        } else {\n            return 0;\n        }\n    }\n\n    /// @notice The amount of yearn shares to withdraw given an amount of adapter shares\n    function convertToUnderlyingShares(uint256, uint256 shares)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return\n            shares.mulDiv(underlyingBalance, totalSupply(), Math.Rounding.Up);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    DEPOSIT/WITHDRAWAL LIMIT LOGIC\n  //////////////////////////////////////////////////////////////*/\n\n    /// @notice Applies the yVault deposit limit to the adapter.\n    function maxDeposit(address) public view override returns (uint256) {\n        if (paused()) return 0;\n\n        VaultAPI _bestVault = yVault;\n        uint256 assets = _bestVault.totalAssets();\n        uint256 _depositLimit = _bestVault.depositLimit();\n        if (assets >= _depositLimit) return 0;\n        return _depositLimit - assets;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _protocolDeposit(uint256 amount, uint256)\n        internal\n        virtual\n        override\n    {\n        yVault.deposit(amount);\n    }\n\n    function _protocolWithdraw(uint256 assets, uint256 shares)\n        internal\n        virtual\n        override\n    {\n        yVault.withdraw(convertToUnderlyingShares(assets, shares));\n    }\n}"
    },
    {
      "filename": "src/vault/adapter/beefy/BeefyAdapter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n// Docgen-SOLC: 0.8.15\n\npragma solidity ^0.8.15;\n\nimport {AdapterBase, IERC20, IERC20Metadata, SafeERC20, ERC20, Math, IStrategy, IAdapter} from \"../abstracts/AdapterBase.sol\";\nimport {WithRewards, IWithRewards} from \"../abstracts/WithRewards.sol\";\nimport {IBeefyVault, IBeefyBooster, IBeefyBalanceCheck, IBeefyStrat} from \"./IBeefy.sol\";\nimport {IPermissionRegistry} from \"../../../interfaces/vault/IPermissionRegistry.sol\";\n\n/**\n * @title   Beefy Adapter\n * @author  RedVeil\n * @notice  ERC4626 wrapper for Beefy Vaults.\n *\n * An ERC4626 compliant Wrapper for https://github.com/beefyfinance/beefy-contracts/blob/master/contracts/BIFI/vaults/BeefyVaultV6.sol.\n * Allows wrapping Beefy Vaults with or without an active Booster.\n * Allows for additional strategies to use rewardsToken in case of an active Booster.\n */\ncontract BeefyAdapter is AdapterBase, WithRewards {\n    using SafeERC20 for IERC20;\n    using Math for uint256;\n\n    string internal _name;\n    string internal _symbol;\n\n    IBeefyVault public beefyVault;\n    IBeefyBooster public beefyBooster;\n    IBeefyBalanceCheck public beefyBalanceCheck;\n\n    uint256 public constant BPS_DENOMINATOR = 10_000;\n\n    error NotEndorsed(address beefyVault);\n    error InvalidBeefyVault(address beefyVault);\n    error InvalidBeefyBooster(address beefyBooster);\n\n    /**\n     * @notice Initialize a new Beefy Adapter.\n     * @param adapterInitData Encoded data for the base adapter initialization.\n     * @param registry Endorsement Registry to check if the beefy adapter is endorsed.\n     * @param beefyInitData Encoded data for the beefy adapter initialization.\n     * @dev `_beefyVault` - The underlying beefy vault.\n     * @dev `_beefyBooster` - An optional beefy booster.\n     * @dev This function is called by the factory contract when deploying a new vault.\n     */\n    function initialize(\n        bytes memory adapterInitData,\n        address registry,\n        bytes memory beefyInitData\n    ) external initializer {\n        (address _beefyVault, address _beefyBooster) = abi.decode(\n            beefyInitData,\n            (address, address)\n        );\n        __AdapterBase_init(adapterInitData);\n\n        if (!IPermissionRegistry(registry).endorsed(_beefyVault))\n            revert NotEndorsed(_beefyVault);\n        if (IBeefyVault(_beefyVault).want() != asset())\n            revert InvalidBeefyVault(_beefyVault);\n        if (\n            _beefyBooster != address(0) &&\n            IBeefyBooster(_beefyBooster).stakedToken() != _beefyVault\n        ) revert InvalidBeefyBooster(_beefyBooster);\n\n        _name = string.concat(\n            \"Popcorn Beefy\",\n            IERC20Metadata(asset()).name(),\n            \" Adapter\"\n        );\n        _symbol = string.concat(\"popB-\", IERC20Metadata(asset()).symbol());\n\n        beefyVault = IBeefyVault(_beefyVault);\n        beefyBooster = IBeefyBooster(_beefyBooster);\n\n        beefyBalanceCheck = IBeefyBalanceCheck(\n            _beefyBooster == address(0) ? _beefyVault : _beefyBooster\n        );\n\n        IERC20(asset()).approve(_beefyVault, type(uint256).max);\n\n        if (_beefyBooster != address(0))\n            IERC20(_beefyVault).approve(_beefyBooster, type(uint256).max);\n    }\n\n    function name()\n        public\n        view\n        override(IERC20Metadata, ERC20)\n        returns (string memory)\n    {\n        return _name;\n    }\n\n    function symbol()\n        public\n        view\n        override(IERC20Metadata, ERC20)\n        returns (string memory)\n    {\n        return _symbol;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _totalAssets() internal view override returns (uint256) {\n        return\n            underlyingBalance.mulDiv(\n                beefyVault.balance(),\n                beefyVault.totalSupply(),\n                Math.Rounding.Down\n            );\n    }\n\n    function _underlyingBalance() internal view override returns (uint256) {\n        return beefyBalanceCheck.balanceOf(address(this));\n    }\n\n    /// @notice The amount of beefy shares to withdraw given an amount of adapter shares\n    function convertToUnderlyingShares(uint256, uint256 shares)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        uint256 supply = totalSupply();\n        return\n            supply == 0\n                ? shares\n                : shares.mulDiv(underlyingBalance, supply, Math.Rounding.Up);\n    }\n\n    /// @notice The token rewarded if a beefy booster is configured\n    function rewardTokens() external view override returns (address[] memory) {\n        address[] memory _rewardTokens = new address[](1);\n        if (address(beefyBooster) == address(0)) return _rewardTokens;\n        _rewardTokens[0] = beefyBooster.rewardToken();\n        return _rewardTokens;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice `previewWithdraw` that takes beefy withdrawal fees into account\n    function previewWithdraw(uint256 assets)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        IBeefyStrat strat = IBeefyStrat(beefyVault.strategy());\n        uint256 beefyFee = strat.withdrawalFee();\n        if (beefyFee > 0)\n            assets = assets.mulDiv(\n                BPS_DENOMINATOR,\n                BPS_DENOMINATOR - beefyFee,\n                Math.Rounding.Up\n            );\n\n        return _convertToShares(assets, Math.Rounding.Up);\n    }\n\n    /// @notice `previewRedeem` that takes beefy withdrawal fees into account\n    function previewRedeem(uint256 shares)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        uint256 assets = _convertToAssets(shares, Math.Rounding.Down);\n\n        IBeefyStrat strat = IBeefyStrat(beefyVault.strategy());\n        uint256 beefyFee = strat.withdrawalFee();\n        if (beefyFee > 0)\n            assets -= assets.mulDiv(\n                beefyFee,\n                BPS_DENOMINATOR,\n                Math.Rounding.Up\n            );\n\n        return assets;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Deposit into beefy vault and optionally into the booster given its configured\n    function _protocolDeposit(uint256 amount, uint256)\n        internal\n        virtual\n        override\n    {\n        beefyVault.deposit(amount);\n        if (address(beefyBooster) != address(0))\n            beefyBooster.stake(beefyVault.balanceOf(address(this)));\n    }\n\n    /// @notice Withdraw from the beefy vault and optionally from the booster given its configured\n    function _protocolWithdraw(uint256, uint256 shares)\n        internal\n        virtual\n        override\n    {\n        uint256 beefyShares = convertToUnderlyingShares(0, shares);\n        if (address(beefyBooster) != address(0))\n            beefyBooster.withdraw(beefyShares);\n        beefyVault.withdraw(beefyShares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            STRATEGY LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    error NoBeefyBooster();\n\n    /// @notice Claim rewards from the beefy booster given its configured\n    function claim() public override onlyStrategy {\n        if (address(beefyBooster) == address(0)) revert NoBeefyBooster();\n        beefyBooster.getReward();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                      EIP-165 LOGIC\n  //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        pure\n        override(WithRewards, AdapterBase)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IWithRewards).interfaceId ||\n            interfaceId == type(IAdapter).interfaceId;\n    }\n}"
    }
  ]
}