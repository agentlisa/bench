{
  "Title": "[N-02] Incorrect Comment",
  "Content": "\n#### Instance #1 - Buyout\n\nThe comment mentioned that if a pool has more than 51% of the total supply after 4 days, the buyout is successful.\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L21>\n\n> /// @title Buyout\n> /// @author Fractional Art\n> /// @notice Module contract for vaults to hold buyout pools\n> /// - A fractional owner starts an auction for a vault by depositing any amount of ether and fractional tokens into a pool.\n> /// - During the proposal period (2 days) users can sell their fractional tokens into the pool for ether.\n> /// - During the rejection period (4 days) users can buy fractional tokens from the pool with ether.\n> /// - If a pool has more than 51% of the total supply after 4 days, the buyout is successful and the proposer\n\nHowever, based on the actual implementation, the buyout will be successful as long as the pool has more than 50% of the total supply.\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L206>\n\n```solidity\nuint256 tokenBalance = IERC1155(token).balanceOf(address(this), id);\n// Checks totalSupply of auction pool to determine if buyout is successful or not\nif (\n    (tokenBalance * 1000) /\n        IVaultRegistry(registry).totalSupply(_vault) >\n    500\n) \n```\n\n### Recommendation\n\nUpdate the comment to clearly reflect the actual implementation.\n\n```diff\n/// @title Buyout\n/// @author Fractional Art\n/// @notice Module contract for vaults to hold buyout pools\n/// - A fractional owner starts an auction for a vault by depositing any amount of ether and fractional tokens into a pool.\n/// - During the proposal period (2 days) users can sell their fractional tokens into the pool for ether.\n/// - During the rejection period (4 days) users can buy fractional tokens from the pool with ether.\n-/// - If a pool has more than 51% of the total supply after 4 days, the buyout is successful and the proposer\n+/// - If a pool has more than 50% of the total supply after 4 days, the buyout is successful and the proposer\n```\n\n#### Instance #2 - FERC1155\n\nThe comment mentioned that the `FERC1155.royaltyInfo` function is to set the token royalties. However, the actual implementation is to read the token royalties.\n\n<https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/FERC1155.sol#L241>\n\n```solidity\n/// @notice Sets the token royalties\n/// @param _id Token ID royalties are being updated for\n/// @param _salePrice Sale price to calculate the royalty for\nfunction royaltyInfo(uint256 _id, uint256 _salePrice)\n    external\n    view\n    returns (address receiver, uint256 royaltyAmount)\n{\n    receiver = royaltyAddress[_id];\n    royaltyAmount = (_salePrice * royaltyPercent[_id]) / 100;\n}\n```\n\n### Recommendation\n\nUpdate the comment to clearly reflect the actual implementation.\n\n```diff\n-/// @notice Sets the token royalties\n+/// @notice Reads the token royalties\n/// @param _id Token ID royalties are being updated for\n/// @param _salePrice Sale price to calculate the royalty for\nfunction royaltyInfo(uint256 _id, uint256 _salePrice)\n    external\n    view\n    returns (address receiver, uint256 royaltyAmount)\n{\n    receiver = royaltyAddress[_id];\n    royaltyAmount = (_salePrice * royaltyPercent[_id]) / 100;\n}\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-07-fractional",
  "Code": [
    {
      "filename": "src/modules/Buyout.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IBuyout, Auction, State} from \"../interfaces/IBuyout.sol\";\nimport {IERC1155} from \"../interfaces/IERC1155.sol\";\nimport {ISupply} from \"../interfaces/ISupply.sol\";\nimport {ITransfer} from \"../interfaces/ITransfer.sol\";\nimport {IVault} from \"../interfaces/IVault.sol\";\nimport {IVaultRegistry, Permission} from \"../interfaces/IVaultRegistry.sol\";\nimport {Multicall} from \"../utils/Multicall.sol\";\nimport {NFTReceiver} from \"../utils/NFTReceiver.sol\";\nimport {SafeSend} from \"../utils/SafeSend.sol\";\nimport {SelfPermit} from \"../utils/SelfPermit.sol\";\n\n/// @title Buyout\n/// @author Fractional Art\n/// @notice Module contract for vaults to hold buyout pools\n/// - A fractional owner starts an auction for a vault by depositing any amount of ether and fractional tokens into a pool.\n/// - During the proposal period (2 days) users can sell their fractional tokens into the pool for ether.\n/// - During the rejection period (4 days) users can buy fractional tokens from the pool with ether.\n/// - If a pool has more than 51% of the total supply after 4 days, the buyout is successful and the proposer\n///   gains access to withdraw the underlying assets (ERC20, ERC721, and ERC1155 tokens) from the vault.\n///   Otherwise the buyout is considered unsuccessful and a new one may then begin.\n/// - NOTE: A vault may only have one active buyout at any given time.\n/// - buyoutPrice = (ethDeposit * 100) / (100 - ((fractionDeposit * 100) / totalSupply))\n/// - buyoutShare = (tokenBalance * ethBalance) / (totalSupply + tokenBalance)\ncontract Buyout is IBuyout, Multicall, NFTReceiver, SafeSend, SelfPermit {\n    /// @notice Address of VaultRegistry contract\n    address public registry;\n    /// @notice Address of Supply target contract\n    address public supply;\n    /// @notice Address of Transfer target contract\n    address public transfer;\n    /// @notice Time length of the proposal period\n    uint256 public constant PROPOSAL_PERIOD = 2 days;\n    /// @notice Time length of the rejection period\n    uint256 public constant REJECTION_PERIOD = 4 days;\n    /// @notice Mapping of vault address to auction struct\n    mapping(address => Auction) public buyoutInfo;\n\n    /// @notice Initializes registry, supply, and transfer contracts\n    constructor(\n        address _registry,\n        address _supply,\n        address _transfer\n    ) {\n        registry = _registry;\n        supply = _supply;\n        transfer = _transfer;\n    }\n\n    /// @dev Callback for receiving ether when the calldata is empty\n    receive() external payable {}\n\n    /// @notice Starts the auction for a buyout pool\n    /// @param _vault Address of the vault\n    function start(address _vault) external payable {\n        // Reverts if ether deposit amount is zero\n        if (msg.value == 0) revert ZeroDeposit();\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not inactive\n        (, , State current, , , ) = this.buyoutInfo(_vault);\n        State required = State.INACTIVE;\n        if (current != required) revert InvalidState(required, current);\n\n        // Gets total supply of fractional tokens for the vault\n        uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);\n        // Gets total balance of fractional tokens owned by caller\n        uint256 depositAmount = IERC1155(token).balanceOf(msg.sender, id);\n\n        // Transfers fractional tokens into the buyout pool\n        IERC1155(token).safeTransferFrom(\n            msg.sender,\n            address(this),\n            id,\n            depositAmount,\n            \"\"\n        );\n\n        // Calculates price of buyout and fractions\n        // @dev Reverts with division error if called with total supply of tokens\n        uint256 buyoutPrice = (msg.value * 100) /\n            (100 - ((depositAmount * 100) / totalSupply));\n        uint256 fractionPrice = buyoutPrice / totalSupply;\n\n        // Sets info mapping of the vault address to auction struct\n        buyoutInfo[_vault] = Auction(\n            block.timestamp,\n            msg.sender,\n            State.LIVE,\n            fractionPrice,\n            msg.value,\n            totalSupply\n        );\n        // Emits event for starting auction\n        emit Start(\n            _vault,\n            msg.sender,\n            block.timestamp,\n            buyoutPrice,\n            fractionPrice\n        );\n    }\n\n    /// @notice Sells fractional tokens in exchange for ether from a pool\n    /// @param _vault Address of the vault\n    /// @param _amount Transfer amount of fractions\n    function sellFractions(address _vault, uint256 _amount) external {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        (uint256 startTime, , State current, uint256 fractionPrice, , ) = this\n            .buyoutInfo(_vault);\n        // Reverts if auction state is not live\n        State required = State.LIVE;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if current time is greater than end time of proposal period\n        uint256 endTime = startTime + PROPOSAL_PERIOD;\n        if (block.timestamp > endTime)\n            revert TimeExpired(block.timestamp, endTime);\n\n        // Transfers fractional tokens to pool from caller\n        IERC1155(token).safeTransferFrom(\n            msg.sender,\n            address(this),\n            id,\n            _amount,\n            \"\"\n        );\n\n        // Updates ether balance of pool\n        uint256 ethAmount = fractionPrice * _amount;\n        buyoutInfo[_vault].ethBalance -= ethAmount;\n        // Transfers ether amount to caller\n        _sendEthOrWeth(msg.sender, ethAmount);\n        // Emits event for selling fractions into pool\n        emit SellFractions(msg.sender, _amount);\n    }\n\n    /// @notice Buys fractional tokens in exchange for ether from a pool\n    /// @param _vault Address of the vault\n    /// @param _amount Transfer amount of fractions\n    function buyFractions(address _vault, uint256 _amount) external payable {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not live\n        (uint256 startTime, , State current, uint256 fractionPrice, , ) = this\n            .buyoutInfo(_vault);\n        State required = State.LIVE;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if current time is greater than end time of rejection period\n        uint256 endTime = startTime + REJECTION_PERIOD;\n        if (block.timestamp > endTime)\n            revert TimeExpired(block.timestamp, endTime);\n        // Reverts if payment amount does not equal price of fractional amount\n        if (msg.value != fractionPrice * _amount) revert InvalidPayment();\n\n        // Transfers fractional tokens to caller\n        IERC1155(token).safeTransferFrom(\n            address(this),\n            msg.sender,\n            id,\n            _amount,\n            \"\"\n        );\n        // Updates ether balance of pool\n        buyoutInfo[_vault].ethBalance += msg.value;\n        // Emits event for buying fractions from pool\n        emit BuyFractions(msg.sender, _amount);\n    }\n\n    /// @notice Ends the auction for a live buyout pool\n    /// @param _vault Address of the vault\n    /// @param _burnProof Merkle proof for burning fractional tokens\n    function end(address _vault, bytes32[] calldata _burnProof) external {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not live\n        (\n            uint256 startTime,\n            address proposer,\n            State current,\n            ,\n            uint256 ethBalance,\n\n        ) = this.buyoutInfo(_vault);\n        State required = State.LIVE;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if current time is less than or equal to end time of auction\n        uint256 endTime = startTime + REJECTION_PERIOD;\n        if (block.timestamp <= endTime)\n            revert TimeNotElapsed(block.timestamp, endTime);\n\n        uint256 tokenBalance = IERC1155(token).balanceOf(address(this), id);\n        // Checks totalSupply of auction pool to determine if buyout is successful or not\n        if (\n            (tokenBalance * 1000) /\n                IVaultRegistry(registry).totalSupply(_vault) >\n            500\n        ) {\n            // Initializes vault transaction\n            bytes memory data = abi.encodeCall(\n                ISupply.burn,\n                (address(this), tokenBalance)\n            );\n            // Executes burn of fractional tokens from pool\n            IVault(payable(_vault)).execute(supply, data, _burnProof);\n            // Sets buyout state to successful\n            buyoutInfo[_vault].state = State.SUCCESS;\n            // Emits event for ending successful auction\n            emit End(_vault, State.SUCCESS, proposer);\n        } else {\n            // Deletes auction info\n            delete buyoutInfo[_vault];\n            // Transfers fractions and ether back to proposer of the buyout pool\n            IERC1155(token).safeTransferFrom(\n                address(this),\n                proposer,\n                id,\n                tokenBalance,\n                \"\"\n            );\n            _sendEthOrWeth(proposer, ethBalance);\n            // Emits event for ending unsuccessful auction\n            emit End(_vault, State.INACTIVE, proposer);\n        }\n    }\n\n    /// @notice Cashes out proceeds from a successful buyout\n    /// @param _vault Address of the vault\n    /// @param _burnProof Merkle proof for burning fractional tokens\n    function cash(address _vault, bytes32[] calldata _burnProof) external {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not successful\n        (, , State current, , uint256 ethBalance, ) = this.buyoutInfo(_vault);\n        State required = State.SUCCESS;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if caller has a balance of zero fractional tokens\n        uint256 tokenBalance = IERC1155(token).balanceOf(msg.sender, id);\n        if (tokenBalance == 0) revert NoFractions();\n\n        // Initializes vault transaction\n        bytes memory data = abi.encodeCall(\n            ISupply.burn,\n            (msg.sender, tokenBalance)\n        );\n        // Executes burn of fractional tokens from caller\n        IVault(payable(_vault)).execute(supply, data, _burnProof);\n\n        // Transfers buyout share amount to caller based on total supply\n        uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);\n        uint256 buyoutShare = (tokenBalance * ethBalance) /\n            (totalSupply + tokenBalance);\n        _sendEthOrWeth(msg.sender, buyoutShare);\n        // Emits event for cashing out of buyout pool\n        emit Cash(_vault, msg.sender, buyoutShare);\n    }\n\n    /// @notice Terminates a vault with an inactive buyout\n    /// @param _vault Address of the vault\n    /// @param _burnProof Merkle proof for burning fractional tokens\n    function redeem(address _vault, bytes32[] calldata _burnProof) external {\n        // Reverts if address is not a registered vault\n        (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not inactive\n        (, , State current, , , ) = this.buyoutInfo(_vault);\n        State required = State.INACTIVE;\n        if (current != required) revert InvalidState(required, current);\n\n        // Initializes vault transaction\n        uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);\n        bytes memory data = abi.encodeCall(\n            ISupply.burn,\n            (msg.sender, totalSupply)\n        );\n        // Executes burn of fractional tokens from caller\n        IVault(payable(_vault)).execute(supply, data, _burnProof);\n\n        // Sets buyout state to successful and proposer to caller\n        (buyoutInfo[_vault].state, buyoutInfo[_vault].proposer) = (\n            State.SUCCESS,\n            msg.sender\n        );\n        // Emits event for redeem underlying assets from the vault\n        emit Redeem(_vault, msg.sender);\n    }\n\n    /// @notice Withdraws an ERC-20 token from a vault\n    /// @param _vault Address of the vault\n    /// @param _token Address of the token\n    /// @param _to Address of the receiver\n    /// @param _value Transfer amount\n    /// @param _erc20TransferProof Merkle proof for transferring an ERC-20 token\n    function withdrawERC20(\n        address _vault,\n        address _token,\n        address _to,\n        uint256 _value,\n        bytes32[] calldata _erc20TransferProof\n    ) external {\n        // Reverts if address is not a registered vault\n        (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not successful\n        (, address proposer, State current, , , ) = this.buyoutInfo(_vault);\n        State required = State.SUCCESS;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if caller is not the auction winner\n        if (msg.sender != proposer) revert NotWinner();\n\n        // Initializes vault transaction\n        bytes memory data = abi.encodeCall(\n            ITransfer.ERC20Transfer,\n            (_token, _to, _value)\n        );\n        // Executes transfer of ERC721 token to caller\n        IVault(payable(_vault)).execute(transfer, data, _erc20TransferProof);\n    }\n\n    /// @notice Withdraws an ERC-721 token from a vault\n    /// @param _vault Address of the vault\n    /// @param _token Address of the token\n    /// @param _to Address of the receiver\n    /// @param _tokenId ID of the token\n    /// @param _erc721TransferProof Merkle proof for transferring an ERC-721 token\n    function withdrawERC721(\n        address _vault,\n        address _token,\n        address _to,\n        uint256 _tokenId,\n        bytes32[] calldata _erc721TransferProof\n    ) external {\n        // Reverts if address is not a registered vault\n        (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not successful\n        (, address proposer, State current, , , ) = this.buyoutInfo(_vault);\n        State required = State.SUCCESS;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if caller is not the auction winner\n        if (msg.sender != proposer) revert NotWinner();\n\n        // Initializes vault transaction\n        bytes memory data = abi.encodeCall(\n            ITransfer.ERC721TransferFrom,\n            (_token, _vault, _to, _tokenId)\n        );\n        // Executes transfer of ERC721 token to caller\n        IVault(payable(_vault)).execute(transfer, data, _erc721TransferProof);\n    }\n\n    /// @notice Withdraws an ERC-1155 token from a vault\n    /// @param _vault Address of the vault\n    /// @param _token Address of the token\n    /// @param _to Address of the receiver\n    /// @param _id ID of the token type\n    /// @param _value Transfer amount\n    /// @param _erc1155TransferProof Merkle proof for transferring an ERC-1155 token\n    function withdrawERC1155(\n        address _vault,\n        address _token,\n        address _to,\n        uint256 _id,\n        uint256 _value,\n        bytes32[] calldata _erc1155TransferProof\n    ) external {\n        // Creates local scope to avoid stack too deep\n        {\n            // Reverts if address is not a registered vault\n            (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n            if (id == 0) revert NotVault(_vault);\n            // Reverts if auction state is not successful\n            (, address proposer, State current, , , ) = this.buyoutInfo(_vault);\n            State required = State.SUCCESS;\n            if (current != required) revert InvalidState(required, current);\n            // Reverts if caller is not the auction winner\n            if (msg.sender != proposer) revert NotWinner();\n        }\n\n        // Initializes vault transaction\n        bytes memory data = abi.encodeCall(\n            ITransfer.ERC1155TransferFrom,\n            (_token, _vault, _to, _id, _value)\n        );\n        // Executes transfer of ERC1155 token to caller\n        IVault(payable(_vault)).execute(transfer, data, _erc1155TransferProof);\n    }\n\n    /// @notice Batch withdraws ERC-1155 tokens from a vault\n    /// @param _vault Address of the vault\n    /// @param _token Address of the token\n    /// @param _to Address of the receiver\n    /// @param _ids IDs of each token type\n    /// @param _values Transfer amounts per token type\n    /// @param _erc1155BatchTransferProof Merkle proof for transferring multiple ERC-1155 tokens\n    function batchWithdrawERC1155(\n        address _vault,\n        address _token,\n        address _to,\n        uint256[] calldata _ids,\n        uint256[] calldata _values,\n        bytes32[] calldata _erc1155BatchTransferProof\n    ) external {\n        // Creates local scope to avoid stack too deep\n        {\n            // Reverts if address is not a registered vault\n            (, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);\n            if (id == 0) revert NotVault(_vault);\n            // Reverts if auction state is not successful\n            (, address proposer, State current, , , ) = this.buyoutInfo(_vault);\n            State required = State.SUCCESS;\n            if (current != required) revert InvalidState(required, current);\n            // Reverts if caller is not the auction winner\n            if (msg.sender != proposer) revert NotWinner();\n        }\n\n        // Initializes vault transaction\n        bytes memory data = abi.encodeCall(\n            ITransfer.ERC1155BatchTransferFrom,\n            (_token, _vault, _to, _ids, _values)\n        );\n        // Executes batch transfer of multiple ERC1155 tokens to caller\n        IVault(payable(_vault)).execute(\n            transfer,\n            data,\n            _erc1155BatchTransferProof\n        );\n    }\n\n    /// @notice Gets the list of leaf nodes used to generate a merkle tree\n    /// @dev Leaf nodes are hashed permissions of the merkle tree\n    /// @return nodes Hashes of leaf nodes\n    function getLeafNodes() external view returns (bytes32[] memory nodes) {\n        nodes = new bytes32[](5);\n        // Gets list of permissions from this module\n        Permission[] memory permissions = getPermissions();\n        for (uint256 i; i < permissions.length; ) {\n            // Hashes permission into leaf node\n            nodes[i] = keccak256(abi.encode(permissions[i]));\n            // Can't overflow since loop is a fixed size\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Gets the list of permissions installed on a vault\n    /// @dev Permissions consist of a module contract, target contract, and function selector\n    /// @return permissions List of vault permissions\n    function getPermissions()\n        public\n        view\n        returns (Permission[] memory permissions)\n    {\n        permissions = new Permission[](5);\n        // Burn function selector from supply contract\n        permissions[0] = Permission(\n            address(this),\n            supply,\n            ISupply(supply).burn.selector\n        );\n        // ERC20Transfer function selector from transfer contract\n        permissions[1] = Permission(\n            address(this),\n            transfer,\n            ITransfer(transfer).ERC20Transfer.selector\n        );\n        // ERC721TransferFrom function selector from transfer contract\n        permissions[2] = Permission(\n            address(this),\n            transfer,\n            ITransfer(transfer).ERC721TransferFrom.selector\n        );\n        // ERC1155TransferFrom function selector from transfer contract\n        permissions[3] = Permission(\n            address(this),\n            transfer,\n            ITransfer(transfer).ERC1155TransferFrom.selector\n        );\n        // ERC1155BatchTransferFrom function selector from transfer contract\n        permissions[4] = Permission(\n            address(this),\n            transfer,\n            ITransfer(transfer).ERC1155BatchTransferFrom.selector\n        );\n    }\n}"
    },
    {
      "filename": "src/modules/Buyout.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IBuyout, Auction, State} from \"../interfaces/IBuyout.sol\";\nimport {IERC1155} from \"../interfaces/IERC1155.sol\";\nimport {ISupply} from \"../interfaces/ISupply.sol\";\nimport {ITransfer} from \"../interfaces/ITransfer.sol\";\nimport {IVault} from \"../interfaces/IVault.sol\";\nimport {IVaultRegistry, Permission} from \"../interfaces/IVaultRegistry.sol\";\nimport {Multicall} from \"../utils/Multicall.sol\";\nimport {NFTReceiver} from \"../utils/NFTReceiver.sol\";\nimport {SafeSend} from \"../utils/SafeSend.sol\";\nimport {SelfPermit} from \"../utils/SelfPermit.sol\";\n\n/// @title Buyout\n/// @author Fractional Art\n/// @notice Module contract for vaults to hold buyout pools\n/// - A fractional owner starts an auction for a vault by depositing any amount of ether and fractional tokens into a pool.\n/// - During the proposal period (2 days) users can sell their fractional tokens into the pool for ether.\n/// - During the rejection period (4 days) users can buy fractional tokens from the pool with ether.\n/// - If a pool has more than 51% of the total supply after 4 days, the buyout is successful and the proposer\n///   gains access to withdraw the underlying assets (ERC20, ERC721, and ERC1155 tokens) from the vault.\n///   Otherwise the buyout is considered unsuccessful and a new one may then begin.\n/// - NOTE: A vault may only have one active buyout at any given time.\n/// - buyoutPrice = (ethDeposit * 100) / (100 - ((fractionDeposit * 100) / totalSupply))\n/// - buyoutShare = (tokenBalance * ethBalance) / (totalSupply + tokenBalance)\ncontract Buyout is IBuyout, Multicall, NFTReceiver, SafeSend, SelfPermit {\n    /// @notice Address of VaultRegistry contract\n    address public registry;\n    /// @notice Address of Supply target contract\n    address public supply;\n    /// @notice Address of Transfer target contract\n    address public transfer;\n    /// @notice Time length of the proposal period\n    uint256 public constant PROPOSAL_PERIOD = 2 days;\n    /// @notice Time length of the rejection period\n    uint256 public constant REJECTION_PERIOD = 4 days;\n    /// @notice Mapping of vault address to auction struct\n    mapping(address => Auction) public buyoutInfo;\n\n    /// @notice Initializes registry, supply, and transfer contracts\n    constructor(\n        address _registry,\n        address _supply,\n        address _transfer\n    ) {\n        registry = _registry;\n        supply = _supply;\n        transfer = _transfer;\n    }\n\n    /// @dev Callback for receiving ether when the calldata is empty\n    receive() external payable {}\n\n    /// @notice Starts the auction for a buyout pool\n    /// @param _vault Address of the vault\n    function start(address _vault) external payable {\n        // Reverts if ether deposit amount is zero\n        if (msg.value == 0) revert ZeroDeposit();\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not inactive\n        (, , State current, , , ) = this.buyoutInfo(_vault);\n        State required = State.INACTIVE;\n        if (current != required) revert InvalidState(required, current);\n\n        // Gets total supply of fractional tokens for the vault\n        uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);\n        // Gets total balance of fractional tokens owned by caller\n        uint256 depositAmount = IERC1155(token).balanceOf(msg.sender, id);\n\n        // Transfers fractional tokens into the buyout pool\n        IERC1155(token).safeTransferFrom(\n            msg.sender,\n            address(this),\n            id,\n            depositAmount,\n            \"\"\n        );\n\n        // Calculates price of buyout and fractions\n        // @dev Reverts with division error if called with total supply of tokens\n        uint256 buyoutPrice = (msg.value * 100) /\n            (100 - ((depositAmount * 100) / totalSupply));\n        uint256 fractionPrice = buyoutPrice / totalSupply;\n\n        // Sets info mapping of the vault address to auction struct\n        buyoutInfo[_vault] = Auction(\n            block.timestamp,\n            msg.sender,\n            State.LIVE,\n            fractionPrice,\n            msg.value,\n            totalSupply\n        );\n        // Emits event for starting auction\n        emit Start(\n            _vault,\n            msg.sender,\n            block.timestamp,\n            buyoutPrice,\n            fractionPrice\n        );\n    }\n\n    /// @notice Sells fractional tokens in exchange for ether from a pool\n    /// @param _vault Address of the vault\n    /// @param _amount Transfer amount of fractions\n    function sellFractions(address _vault, uint256 _amount) external {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        (uint256 startTime, , State current, uint256 fractionPrice, , ) = this\n            .buyoutInfo(_vault);\n        // Reverts if auction state is not live\n        State required = State.LIVE;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if current time is greater than end time of proposal period\n        uint256 endTime = startTime + PROPOSAL_PERIOD;\n        if (block.timestamp > endTime)\n            revert TimeExpired(block.timestamp, endTime);\n\n        // Transfers fractional tokens to pool from caller\n        IERC1155(token).safeTransferFrom(\n            msg.sender,\n            address(this),\n            id,\n            _amount,\n            \"\"\n        );\n\n        // Updates ether balance of pool\n        uint256 ethAmount = fractionPrice * _amount;\n        buyoutInfo[_vault].ethBalance -= ethAmount;\n        // Transfers ether amount to caller\n        _sendEthOrWeth(msg.sender, ethAmount);\n        // Emits event for selling fractions into pool\n        emit SellFractions(msg.sender, _amount);\n    }\n\n    /// @notice Buys fractional tokens in exchange for ether from a pool\n    /// @param _vault Address of the vault\n    /// @param _amount Transfer amount of fractions\n    function buyFractions(address _vault, uint256 _amount) external payable {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not live\n        (uint256 startTime, , State current, uint256 fractionPrice, , ) = this\n            .buyoutInfo(_vault);\n        State required = State.LIVE;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if current time is greater than end time of rejection period\n        uint256 endTime = startTime + REJECTION_PERIOD;\n        if (block.timestamp > endTime)\n            revert TimeExpired(block.timestamp, endTime);\n        // Reverts if payment amount does not equal price of fractional amount\n        if (msg.value != fractionPrice * _amount) revert InvalidPayment();\n\n        // Transfers fractional tokens to caller\n        IERC1155(token).safeTransferFrom(\n            address(this),\n            msg.sender,\n            id,\n            _amount,\n            \"\"\n        );\n        // Updates ether balance of pool\n        buyoutInfo[_vault].ethBalance += msg.value;\n        // Emits event for buying fractions from pool\n        emit BuyFractions(msg.sender, _amount);\n    }\n\n    /// @notice Ends the auction for a live buyout pool\n    /// @param _vault Address of the vault\n    /// @param _burnProof Merkle proof for burning fractional tokens\n    function end(address _vault, bytes32[] calldata _burnProof) external {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not live\n        (\n            uint256 startTime,\n            address proposer,\n            State current,\n            ,\n            uint256 ethBalance,\n\n        ) = this.buyoutInfo(_vault);\n        State required = State.LIVE;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if current time is less than or equal to end time of auction\n        uint256 endTime = startTime + REJECTION_PERIOD;\n        if (block.timestamp <= endTime)\n            revert TimeNotElapsed(block.timestamp, endTime);\n\n        uint256 tokenBalance = IERC1155(token).balanceOf(address(this), id);\n        // Checks totalSupply of auction pool to determine if buyout is successful or not\n        if (\n            (tokenBalance * 1000) /\n                IVaultRegistry(registry).totalSupply(_vault) >\n            500\n        ) {\n            // Initializes vault transaction\n            bytes memory data = abi.encodeCall(\n                ISupply.burn,\n                (address(this), tokenBalance)\n            );\n            // Executes burn of fractional tokens from pool\n            IVault(payable(_vault)).execute(supply, data, _burnProof);\n            // Sets buyout state to successful\n            buyoutInfo[_vault].state = State.SUCCESS;\n            // Emits event for ending successful auction\n            emit End(_vault, State.SUCCESS, proposer);\n        } else {\n            // Deletes auction info\n            delete buyoutInfo[_vault];\n            // Transfers fractions and ether back to proposer of the buyout pool\n            IERC1155(token).safeTransferFrom(\n                address(this),\n                proposer,\n                id,\n                tokenBalance,\n                \"\"\n            );\n            _sendEthOrWeth(proposer, ethBalance);\n            // Emits event for ending unsuccessful auction\n            emit End(_vault, State.INACTIVE, proposer);\n        }\n    }\n\n    /// @notice Cashes out proceeds from a successful buyout\n    /// @param _vault Address of the vault\n    /// @param _burnProof Merkle proof for burning fractional tokens\n    function cash(address _vault, bytes32[] calldata _burnProof) external {\n        // Reverts if address is not a registered vault\n        (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n            _vault\n        );\n        if (id == 0) revert NotVault(_vault);\n        // Reverts if auction state is not successful\n        (, , State current, , uint256 ethBalance, ) = this.buyoutInfo(_vault);\n        State required = State.SUCCESS;\n        if (current != required) revert InvalidState(required, current);\n        // Reverts if caller has a balance of zero fractional tokens\n        uint256 tokenBalance = IERC1155(token).balanceOf(msg.sender, id);\n        if (tokenBalance == 0) revert NoFractions();\n\n        // Initializes vault transaction\n        bytes memory data = abi.encodeCall(\n            ISupply.burn,\n            (msg.sender, tokenBalance)\n        );\n        // Executes burn of fractional tokens from caller\n        IVault(payable(_vault)).execute(supply, data, _burnProof);\n\n        // Transfers buyout share amount to caller based on total supply\n        uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);\n        uint256 buyoutShare = (tokenBalance * ethBalance) /\n            (totalSupply + tokenBalance);\n        _sendEthOrWeth(msg.sender, buyoutShare);\n        // Emits event for cashing out of buyout pool\n        emit Cash(_vault, msg.sender, buyoutShare);\n    }\n\n    /// @notice Terminates a vault with an inactive buyout\n    /// @param _vault Address of the vault"
    }
  ]
}