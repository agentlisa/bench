{
  "Title": "[N-02] - `sum` in `RewardsEmitter` is not used",
  "Content": "\nThe [`sum`](https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/rewards/RewardsEmitter.sol#L115) variable is [calculated](https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/rewards/RewardsEmitter.sol#L128) in the `RewardsEmitter` but never used, nor returned.\n\nIt may have been left from a previous refactor, as a `sum` variable [is also used in `StakingRewards::addSALTRewards()`](https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/staking/StakingRewards.sol#L201-L204), which is called by the `RewardsEmitter`.\n\nThe `RewardsEmitter` already [approved the SALT token to its maximum](https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/rewards/RewardsEmitter.sol#L50), so there should be no issue. On any case, I'm highlighting this, as it may hide some other issue I couldn't detect.\n\n### Recommendation\n\nVerify that `sum` is actually not used, and remove it from the `RewardsEmitter` contract if not.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-01-salty",
  "Code": [
    {
      "filename": "src/rewards/RewardsEmitter.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport \"../rewards/interfaces/IRewardsConfig.sol\";\nimport \"../pools/interfaces/IPoolsConfig.sol\";\nimport \"../interfaces/IExchangeConfig.sol\";\nimport \"./interfaces/IRewardsEmitter.sol\";\nimport \"../interfaces/ISalt.sol\";\nimport \"../pools/PoolUtils.sol\";\n\n\n// Stores SALT rewards for later distribution at a default rate of 1% per day to those holding shares in the specified StakingRewards contract.\n// The gradual emissions rate is to help offset natural rewards fluctuation and create a more stable yield.\n// This also creates an easy mechanism to see what the current yield is for any pool as the emitter acts like an exponential average of the incoming SALT rewards.\n// There will be two deplyed RewardsEmitters:\n// Staking.sol - allows users to stake SALT to acquire xSALT and distributes rewards to Staking.sol\n// Liquidity.sol - allows liquidity providers to deposit and stake collateralAndLiquidity and distributes rewards to CollateralAndLiquidity.sol.\ncontract RewardsEmitter is IRewardsEmitter, ReentrancyGuard\n    {\n\tusing SafeERC20 for ISalt;\n\n\tIStakingRewards immutable public stakingRewards;\n\tIExchangeConfig immutable public exchangeConfig;\n\tIPoolsConfig immutable public poolsConfig;\n\tIRewardsConfig immutable public rewardsConfig;\n\tISalt immutable public salt;\n   \tbool immutable isForCollateralAndLiquidity;\n\n\tuint256 constant public MAX_TIME_SINCE_LAST_UPKEEP = 1 days;\n\n    // The stored SALT rewards by poolID that need to be distributed to the specified StakingRewards.sol contract.\n    // Only a percentage of these will be distributed per day (interpolated to a default of 1% per day).\n   \tmapping(bytes32=>uint256) public pendingRewards;\n\n\n\n    constructor( IStakingRewards _stakingRewards, IExchangeConfig _exchangeConfig, IPoolsConfig _poolsConfig, IRewardsConfig _rewardsConfig, bool _isForCollateralAndLiquidity )\n\t\t{\n\t\tstakingRewards = _stakingRewards;\n\t\texchangeConfig = _exchangeConfig;\n\t\tpoolsConfig = _poolsConfig;\n\t\trewardsConfig = _rewardsConfig;\n\t\tisForCollateralAndLiquidity = _isForCollateralAndLiquidity;\n\n\t\tsalt = _exchangeConfig.salt();\n\n\t\t// Save gas for later reward distribution by approving in advance\n\t\tsalt.approve(address(stakingRewards), type(uint256).max);\n\t\t}\n\n\n\t// Add SALT rewards for later distribution to the specified whitelisted pools.\n\t// Specified SALT rewards are transfered from the sender.\n\t// Requires that rewarded pools are whitelisted.\n\tfunction addSALTRewards( AddedReward[] calldata addedRewards ) external nonReentrant\n\t\t{\n\t\tuint256 sum = 0;\n\t\tfor( uint256 i = 0; i < addedRewards.length; i++ )\n\t\t\t{\n\t\t\tAddedReward memory addedReward = addedRewards[i];\n\t\t\trequire( poolsConfig.isWhitelisted( addedReward.poolID ), \"Invalid pool\" );\n\n\t\t\tuint256 amountToAdd = addedReward.amountToAdd;\n\t\t\tif ( amountToAdd != 0 )\n\t\t\t\t{\n\t\t\t\t// Update pendingRewards so the SALT can be distributed later\n\t\t\t\tpendingRewards[ addedReward.poolID ] += amountToAdd;\n\t\t\t\tsum += amountToAdd;\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Transfer the SALT from the sender for all of the specified rewards\n\t\tif ( sum > 0 )\n\t\t\tsalt.safeTransferFrom( msg.sender, address(this), sum );\n\t\t}\n\n\n\t// Transfer a percent (default 1% per day) of the currently held rewards to the specified StakingRewards pools.\n\t// The percentage to transfer is interpolated from how long it's been since the last performUpkeep().\n\tfunction performUpkeep( uint256 timeSinceLastUpkeep ) external\n\t\t{\n\t\trequire( msg.sender == address(exchangeConfig.upkeep()), \"RewardsEmitter.performUpkeep is only callable from the Upkeep contract\" );\n\n\t\tif ( timeSinceLastUpkeep == 0 )\n\t\t\treturn;\n\n\t\tbytes32[] memory poolIDs;\n\n\t\t if ( isForCollateralAndLiquidity )\n\t\t \t{\n\t\t \t// For the liquidityRewardsEmitter, all pools can receive rewards\n\t\t\tpoolIDs = poolsConfig.whitelistedPools();\n\t\t\t}\n\t\t else\n\t\t \t{\n\t\t \t// The stakingRewardsEmitter only distributes rewards to those that have staked SALT\n\t\t \tpoolIDs = new bytes32[](1);\n\t\t \tpoolIDs[0] = PoolUtils.STAKED_SALT;\n\t\t \t}\n\n\t\t// Cap the timeSinceLastUpkeep at one day (if for some reason it has been longer).\n\t\t// This will cap the emitted rewards at a default of 1% in this transaction.\n\t\tif ( timeSinceLastUpkeep >= MAX_TIME_SINCE_LAST_UPKEEP )\n        \ttimeSinceLastUpkeep = MAX_TIME_SINCE_LAST_UPKEEP;\n\n\t\t// These are the AddedRewards that will be sent to the specified StakingRewards contract\n\t\tAddedReward[] memory addedRewards = new AddedReward[]( poolIDs.length );\n\n\t\t// Rewards to emit = pendingRewards * timeSinceLastUpkeep * rewardsEmitterDailyPercent / oneDay\n\t\tuint256 numeratorMult = timeSinceLastUpkeep * rewardsConfig.rewardsEmitterDailyPercentTimes1000();\n\t\tuint256 denominatorMult = 1 days * 100000; // simplification of numberSecondsInOneDay * (100 percent) * 1000\n\n\t\tuint256 sum = 0;\n\t\tfor( uint256 i = 0; i < poolIDs.length; i++ )\n\t\t\t{\n\t\t\tbytes32 poolID = poolIDs[i];\n\n\t\t\t// Each pool will send a percentage of the pending rewards based on the time elapsed since the last send\n\t\t\tuint256 amountToAddForPool = ( pendingRewards[poolID] * numeratorMult ) / denominatorMult;\n\n\t\t\t// Reduce the pending rewards so they are not sent again\n\t\t\tif ( amountToAddForPool != 0 )\n\t\t\t\t{\n\t\t\t\tpendingRewards[poolID] -= amountToAddForPool;\n\n\t\t\t\tsum += amountToAddForPool;\n\t\t\t\t}\n\n\t\t\t// Specify the rewards that will be added for the specific pool\n\t\t\taddedRewards[i] = AddedReward( poolID, amountToAddForPool );\n\t\t\t}\n\n\t\t// Add the rewards so that they can later be claimed by the users proportional to their share of the StakingRewards derived contract.\n\t\tstakingRewards.addSALTRewards( addedRewards );\n\t\t}\n\n\n\t// === VIEWS ===\n\n\tfunction pendingRewardsForPools( bytes32[] calldata pools ) external view returns (uint256[] memory)\n\t\t{\n\t\tuint256[] memory rewards = new uint256[]( pools.length );\n\n\t\tfor( uint256 i = 0; i < rewards.length; i++ )\n\t\t\trewards[i] = pendingRewards[ pools[i] ];\n\n\t\treturn rewards;\n\t\t}\n\t}"
    },
    {
      "filename": "src/staking/StakingRewards.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport \"openzeppelin-contracts/contracts/utils/math/Math.sol\";\nimport \"../pools/interfaces/IPoolsConfig.sol\";\nimport \"../interfaces/IExchangeConfig.sol\";\nimport \"./interfaces/IStakingRewards.sol\";\nimport \"./interfaces/IStakingConfig.sol\";\nimport \"../interfaces/ISalt.sol\";\n\n// This contract allows users to receive rewards (as SALT tokens) for staking SALT or liquidity shares.\n// A user's reward is proportional to their share of the stake and is based on their share at the time that rewards are added.\n//\n// What staked shares represent is specific to the contracts that derive from StakingRewards.\n//\n// 1. Staking.sol: shares represent the amount of SALT staked (staked to the STAKED_SALT pool)\n// 2. Liquidity.sol: shares represent the amount of liquidity deposited and staked to specific pools\n\nabstract contract StakingRewards is IStakingRewards, ReentrancyGuard\n    {\n\tevent UserShareIncreased(address indexed wallet, bytes32 indexed poolID, uint256 amountIncreased);\n\tevent UserShareDecreased(address indexed wallet, bytes32 indexed poolID, uint256 amountDecreased, uint256 claimedRewards);\n\tevent RewardsClaimed(address indexed wallet, uint256 claimedRewards);\n\tevent SaltRewardsAdded(bytes32 indexed poolID, uint256 amountAdded);\n\n\tusing SafeERC20 for ISalt;\n\n\tISalt immutable public salt;\n\tIExchangeConfig immutable public exchangeConfig;\n    IStakingConfig immutable public stakingConfig;\n    IPoolsConfig immutable public poolsConfig;\n\n\t// A nested mapping that stores the UserShareInfo data for each user and each poolID.\n\tmapping(address=>mapping(bytes32=>UserShareInfo)) private _userShareInfo;\n\n    // A mapping that stores the total pending SALT rewards for each poolID.\n    mapping(bytes32=>uint256) public totalRewards;\n\n    // A mapping that stores the total shares for each poolID.\n    mapping(bytes32=>uint256) public totalShares;\n\n\n\t// Constructs a new StakingRewards contract with providing configs\n \tconstructor( IExchangeConfig _exchangeConfig, IPoolsConfig _poolsConfig, IStakingConfig _stakingConfig )\n\t\t{\n\t\texchangeConfig = _exchangeConfig;\n    \tpoolsConfig = _poolsConfig;\n\t\tstakingConfig = _stakingConfig;\n\n\t\tsalt = _exchangeConfig.salt(); // cached for efficiency\n        }\n\n\n\t// Increase a user's share for the given whitelisted pool.\n\tfunction _increaseUserShare( address wallet, bytes32 poolID, uint256 increaseShareAmount, bool useCooldown ) internal\n\t\t{\n\t\trequire( poolsConfig.isWhitelisted( poolID ), \"Invalid pool\" );\n\t\trequire( increaseShareAmount != 0, \"Cannot increase zero share\" );\n\n\t\tUserShareInfo storage user = _userShareInfo[wallet][poolID];\n\n\t\tif ( useCooldown )\n\t\tif ( msg.sender != address(exchangeConfig.dao()) ) // DAO doesn't use the cooldown\n\t\t\t{\n\t\t\trequire( block.timestamp >= user.cooldownExpiration, \"Must wait for the cooldown to expire\" );\n\n\t\t\t// Update the cooldown expiration for future transactions\n\t\t\tuser.cooldownExpiration = block.timestamp + stakingConfig.modificationCooldown();\n\t\t\t}\n\n\t\tuint256 existingTotalShares = totalShares[poolID];\n\n\t\t// Determine the amount of virtualRewards to add based on the current ratio of rewards/shares.\n\t\t// The ratio of virtualRewards/increaseShareAmount is the same as totalRewards/totalShares for the pool.\n\t\t// The virtual rewards will be deducted later when calculating the user's owed rewards.\n        if ( existingTotalShares != 0 ) // prevent / 0\n        \t{\n\t\t\t// Round up in favor of the protocol.\n\t\t\tuint256 virtualRewardsToAdd = Math.ceilDiv( totalRewards[poolID] * increaseShareAmount, existingTotalShares );\n\n\t\t\tuser.virtualRewards += uint128(virtualRewardsToAdd);\n\t        totalRewards[poolID] += uint128(virtualRewardsToAdd);\n\t        }\n\n\t\t// Update the deposit balances\n\t\tuser.userShare += uint128(increaseShareAmount);\n\t\ttotalShares[poolID] = existingTotalShares + increaseShareAmount;\n\n\t\temit UserShareIncreased(wallet, poolID, increaseShareAmount);\n\t\t}\n\n\n\t// Decrease a user's share for the pool and have any pending rewards sent to them.\n\t// Does not require the pool to be valid (in case the pool was recently unwhitelisted).\n\tfunction _decreaseUserShare( address wallet, bytes32 poolID, uint256 decreaseShareAmount, bool useCooldown ) internal\n\t\t{\n\t\trequire( decreaseShareAmount != 0, \"Cannot decrease zero share\" );\n\n\t\tUserShareInfo storage user = _userShareInfo[wallet][poolID];\n\t\trequire( decreaseShareAmount <= user.userShare, \"Cannot decrease more than existing user share\" );\n\n\t\tif ( useCooldown )\n\t\tif ( msg.sender != address(exchangeConfig.dao()) ) // DAO doesn't use the cooldown\n\t\t\t{\n\t\t\trequire( block.timestamp >= user.cooldownExpiration, \"Must wait for the cooldown to expire\" );\n\n\t\t\t// Update the cooldown expiration for future transactions\n\t\t\tuser.cooldownExpiration = block.timestamp + stakingConfig.modificationCooldown();\n\t\t\t}\n\n\t\t// Determine the share of the rewards for the amountToDecrease (will include previously added virtual rewards)\n\t\tuint256 rewardsForAmount = ( totalRewards[poolID] * decreaseShareAmount ) / totalShares[poolID];\n\n\t\t// For the amountToDecrease determine the proportion of virtualRewards (proportional to all virtualRewards for the user)\n\t\t// Round virtualRewards down in favor of the protocol\n\t\tuint256 virtualRewardsToRemove = (user.virtualRewards * decreaseShareAmount) / user.userShare;\n\n\t\t// Update totals\n\t\ttotalRewards[poolID] -= rewardsForAmount;\n\t\ttotalShares[poolID] -= decreaseShareAmount;\n\n\t\t// Update the user's share and virtual rewards\n\t\tuser.userShare -= uint128(decreaseShareAmount);\n\t\tuser.virtualRewards -= uint128(virtualRewardsToRemove);\n\n\t\tuint256 claimableRewards = 0;\n\n\t\t// Some of the rewardsForAmount are actually virtualRewards and can't be claimed.\n\t\t// In the event that virtualRewards are greater than actual rewards - claimableRewards will stay zero.\n\t\tif ( virtualRewardsToRemove < rewardsForAmount )\n\t\t\tclaimableRewards = rewardsForAmount - virtualRewardsToRemove;\n\n\t\t// Send the claimable rewards\n\t\tif ( claimableRewards != 0 )\n\t\t\tsalt.safeTransfer( wallet, claimableRewards );\n\n\t\temit UserShareDecreased(wallet, poolID, decreaseShareAmount, claimableRewards);\n\t\t}\n\n\n\t// ===== PUBLIC FUNCTIONS =====\n\n\t// Claim all available SALT rewards from multiple pools for the user.\n\t// The claimed rewards are added to the user's virtual rewards balance - so that they can't be claimed again later.\n     function claimAllRewards( bytes32[] calldata poolIDs ) external nonReentrant returns (uint256 claimableRewards)\n    \t{\n\t\tmapping(bytes32=>UserShareInfo) storage userInfo = _userShareInfo[msg.sender];\n\n\t\tclaimableRewards = 0;\n\t\tfor( uint256 i = 0; i < poolIDs.length; i++ )\n\t\t\t{\n\t\t\tbytes32 poolID = poolIDs[i];\n\n\t\t\tuint256 pendingRewards = userRewardForPool( msg.sender, poolID );\n\n\t\t\t// Increase the virtualRewards balance for the user to account for them receiving the rewards without withdrawing\n\t\t\tuserInfo[poolID].virtualRewards += uint128(pendingRewards);\n\n\t\t\tclaimableRewards += pendingRewards;\n\t\t\t}\n\n\t\tif ( claimableRewards > 0 )\n\t\t\t{\n\t\t\t// Send the actual rewards\n\t\t\tsalt.safeTransfer( msg.sender, claimableRewards );\n\n\t\t\temit RewardsClaimed(msg.sender, claimableRewards);\n\t\t\t}\n    \t}\n\n\n\t// Adds SALT rewards for specific whitelisted pools.\n\t// There is some risk of addSALTRewards being frontrun to hunt rewards, but there are multiple mechanisms in place to prevent this from being effective.\n\t// 1. There is a cooldown period of default one hour before shares can be withdrawn once deposited.\n\t// 2. Staked SALT has a default unstake period of 52 weeks.\n\t// 3. Rewards are first placed into a RewardsEmitter which deposits rewards via addSALTRewards at the default rate of 1% per day.\n\t// 4. Rewards are deposited fairly often, with outstanding rewards being transferred with a frequency proportional to the activity of the exchange.\n\t// Example: if $100k rewards were being deposited in a bulk transaction, it would only equate to $1000 (1%) the first day,\n\t// or $10 in claimable rewards during a 15 minute upkeep period.\n \tfunction addSALTRewards( AddedReward[] calldata addedRewards ) external nonReentrant\n\t\t{\n\t\tuint256 sum = 0;\n\t\tfor( uint256 i = 0; i < addedRewards.length; i++ )\n\t\t\t{\n\t\t\tAddedReward memory addedReward = addedRewards[i];\n\n\t\t\tbytes32 poolID = addedReward.poolID;\n\t\t\trequire( poolsConfig.isWhitelisted( poolID ), \"Invalid pool\" );\n\n\t\t\tuint256 amountToAdd = addedReward.amountToAdd;\n\n\t\t\ttotalRewards[ poolID ] += amountToAdd;\n\t\t\tsum = sum + amountToAdd;\n\n\t\t\temit SaltRewardsAdded(poolID, amountToAdd);\n\t\t\t}\n\n\t\t// Transfer in the SALT for all the specified rewards\n\t\tif ( sum > 0 )\n\t\t\t{\n\t\t\t// Transfer the SALT rewards from the sender\n\t\t\tsalt.safeTransferFrom( msg.sender, address(this), sum );\n\t\t\t}\n\t\t}\n\n\n\t// === VIEWS ===\n\n\t// Returns the total shares for specified pools.\n\tfunction totalSharesForPools( bytes32[] calldata poolIDs ) external view returns (uint256[] memory shares)\n\t\t{\n\t\tshares = new uint256[]( poolIDs.length );\n\n\t\tfor( uint256 i = 0; i < shares.length; i++ )\n\t\t\tshares[i] = totalShares[ poolIDs[i] ];\n\t\t}\n\n\n\t// Returns the total rewards for specified pools.\n\tfunction totalRewardsForPools( bytes32[] calldata poolIDs ) external view returns (uint256[] memory rewards)\n\t\t{\n\t\trewards = new uint256[]( poolIDs.length );\n\n\t\tfor( uint256 i = 0; i < rewards.length; i++ )\n\t\t\trewards[i] = totalRewards[ poolIDs[i] ];\n\t\t}\n\n\n\t// Returns the user's pending rewards for a specified pool.\n\tfunction userRewardForPool( address wallet, bytes32 poolID ) public view returns (uint256)\n\t\t{\n\t\t// If there are no shares for the pool, the user can't have any shares either and there can't be any rewards\n\t\tif ( totalShares[poolID] == 0 )\n\t\t\treturn 0;\n\n\t\tUserShareInfo memory user = _userShareInfo[wallet][poolID];\n\t\tif ( user.userShare == 0 )\n\t\t\treturn 0;\n\n\t\t// Determine the share of the rewards for the user based on their deposited share\n\t\tuint256 rewardsShare = ( totalRewards[poolID] * user.userShare ) / totalShares[poolID];\n\n\t\t// Reduce by the virtualRewards - as they were only added to keep the share / rewards ratio the same when the used added their share\n\n\t\t// In the event that virtualRewards exceeds rewardsShare due to precision loss - just return zero\n\t\tif ( user.virtualRewards > rewardsShare )\n\t\t\treturn 0;\n\n\t\treturn rewardsShare - user.virtualRewards;\n\t\t}\n\n\n\t// Returns the user's pending rewards for specified pools.\n\tfunction userRewardsForPools( address wallet, bytes32[] calldata poolIDs ) external view returns (uint256[] memory rewards)\n\t\t{\n\t\trewards = new uint256[]( poolIDs.length );\n\n\t\tfor( uint256 i = 0; i < rewards.length; i++ )\n\t\t\trewards[i] = userRewardForPool( wallet, poolIDs[i] );\n\t\t}\n\n\n\t// Get the user's shares for a specified pool.\n\tfunction userShareForPool( address wallet, bytes32 poolID ) public view returns (uint256)\n\t\t{\n\t\treturn _userShareInfo[wallet][poolID].userShare;\n\t\t}\n\n\n\t// Get the user's shares for specified pools.\n\tfunction userShareForPools( address wallet, bytes32[] calldata poolIDs ) external view returns (uint256[] memory shares)\n\t\t{\n\t\tshares = new uint256[]( poolIDs.length );\n\n\t\tfor( uint256 i = 0; i < shares.length; i++ )\n\t\t\tshares[i] = _userShareInfo[wallet][ poolIDs[i] ].userShare;\n\t\t}\n\n\n\t// Get the user's virtual rewards for a specified pool.\n\tfunction userVirtualRewardsForPool( address wallet, bytes32 poolID ) public view returns (uint256)\n\t\t{\n\t\treturn _userShareInfo[wallet][poolID].virtualRewards;\n\t\t}\n\n\n\t// Get the cooldown time remaining for the user for specified pools.\n\tfunction userCooldowns( address wallet, bytes32[] calldata poolIDs ) external view returns (uint256[] memory cooldowns)\n\t\t{\n\t\tcooldowns = new uint256[]( poolIDs.length );\n\n\t\tmapping(bytes32=>UserShareInfo) storage userInfo = _userShareInfo[wallet];\n\n\t\tfor( uint256 i = 0; i < cooldowns.length; i++ )\n\t\t\t{\n\t\t\tuint256 cooldownExpiration = userInfo[ poolIDs[i] ].cooldownExpiration;\n\n\t\t\tif ( block.timestamp >= cooldownExpiration )\n\t\t\t\tcooldowns[i] = 0;\n\t\t\telse\n\t\t\t\tcooldowns[i] = cooldownExpiration - block.timestamp;\n\t\t\t}\n\t\t}\n\t}"
    },
    {
      "filename": "src/rewards/RewardsEmitter.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport \"../rewards/interfaces/IRewardsConfig.sol\";\nimport \"../pools/interfaces/IPoolsConfig.sol\";\nimport \"../interfaces/IExchangeConfig.sol\";\nimport \"./interfaces/IRewardsEmitter.sol\";\nimport \"../interfaces/ISalt.sol\";\nimport \"../pools/PoolUtils.sol\";\n\n\n// Stores SALT rewards for later distribution at a default rate of 1% per day to those holding shares in the specified StakingRewards contract.\n// The gradual emissions rate is to help offset natural rewards fluctuation and create a more stable yield.\n// This also creates an easy mechanism to see what the current yield is for any pool as the emitter acts like an exponential average of the incoming SALT rewards.\n// There will be two deplyed RewardsEmitters:\n// Staking.sol - allows users to stake SALT to acquire xSALT and distributes rewards to Staking.sol\n// Liquidity.sol - allows liquidity providers to deposit and stake collateralAndLiquidity and distributes rewards to CollateralAndLiquidity.sol.\ncontract RewardsEmitter is IRewardsEmitter, ReentrancyGuard\n    {\n\tusing SafeERC20 for ISalt;\n\n\tIStakingRewards immutable public stakingRewards;\n\tIExchangeConfig immutable public exchangeConfig;\n\tIPoolsConfig immutable public poolsConfig;\n\tIRewardsConfig immutable public rewardsConfig;\n\tISalt immutable public salt;\n   \tbool immutable isForCollateralAndLiquidity;\n\n\tuint256 constant public MAX_TIME_SINCE_LAST_UPKEEP = 1 days;\n\n    // The stored SALT rewards by poolID that need to be distributed to the specified StakingRewards.sol contract.\n    // Only a percentage of these will be distributed per day (interpolated to a default of 1% per day).\n   \tmapping(bytes32=>uint256) public pendingRewards;\n\n\n\n    constructor( IStakingRewards _stakingRewards, IExchangeConfig _exchangeConfig, IPoolsConfig _poolsConfig, IRewardsConfig _rewardsConfig, bool _isForCollateralAndLiquidity )\n\t\t{\n\t\tstakingRewards = _stakingRewards;\n\t\texchangeConfig = _exchangeConfig;\n\t\tpoolsConfig = _poolsConfig;\n\t\trewardsConfig = _rewardsConfig;\n\t\tisForCollateralAndLiquidity = _isForCollateralAndLiquidity;\n\n\t\tsalt = _exchangeConfig.salt();\n\n\t\t// Save gas for later reward distribution by approving in advance\n\t\tsalt.approve(address(stakingRewards), type(uint256).max);\n\t\t}\n\n\n\t// Add SALT rewards for later distribution to the specified whitelisted pools.\n\t// Specified SALT rewards are transfered from the sender.\n\t// Requires that rewarded pools are whitelisted.\n\tfunction addSALTRewards( AddedReward[] calldata addedRewards ) external nonReentrant\n\t\t{\n\t\tuint256 sum = 0;\n\t\tfor( uint256 i = 0; i < addedRewards.length; i++ )\n\t\t\t{\n\t\t\tAddedReward memory addedReward = addedRewards[i];\n\t\t\trequire( poolsConfig.isWhitelisted( addedReward.poolID ), \"Invalid pool\" );\n\n\t\t\tuint256 amountToAdd = addedReward.amountToAdd;\n\t\t\tif ( amountToAdd != 0 )\n\t\t\t\t{\n\t\t\t\t// Update pendingRewards so the SALT can be distributed later\n\t\t\t\tpendingRewards[ addedReward.poolID ] += amountToAdd;\n\t\t\t\tsum += amountToAdd;\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Transfer the SALT from the sender for all of the specified rewards\n\t\tif ( sum > 0 )\n\t\t\tsalt.safeTransferFrom( msg.sender, address(this), sum );\n\t\t}\n\n\n\t// Transfer a percent (default 1% per day) of the currently held rewards to the specified StakingRewards pools.\n\t// The percentage to transfer is interpolated from how long it's been since the last performUpkeep().\n\tfunction performUpkeep( uint256 timeSinceLastUpkeep ) external\n\t\t{\n\t\trequire( msg.sender == address(exchangeConfig.upkeep()), \"RewardsEmitter.performUpkeep is only callable from the Upkeep contract\" );\n\n\t\tif ( timeSinceLastUpkeep == 0 )\n\t\t\treturn;\n\n\t\tbytes32[] memory poolIDs;\n\n\t\t if ( isForCollateralAndLiquidity )\n\t\t \t{\n\t\t \t// For the liquidityRewardsEmitter, all pools can receive rewards\n\t\t\tpoolIDs = poolsConfig.whitelistedPools();\n\t\t\t}\n\t\t else\n\t\t \t{\n\t\t \t// The stakingRewardsEmitter only distributes rewards to those that have staked SALT\n\t\t \tpoolIDs = new bytes32[](1);\n\t\t \tpoolIDs[0] = PoolUtils.STAKED_SALT;\n\t\t \t}\n\n\t\t// Cap the timeSinceLastUpkeep at one day (if for some reason it has been longer).\n\t\t// This will cap the emitted rewards at a default of 1% in this transaction.\n\t\tif ( timeSinceLastUpkeep >= MAX_TIME_SINCE_LAST_UPKEEP )\n        \ttimeSinceLastUpkeep = MAX_TIME_SINCE_LAST_UPKEEP;\n\n\t\t// These are the AddedRewards that will be sent to the specified StakingRewards contract\n\t\tAddedReward[] memory addedRewards = new AddedReward[]( poolIDs.length );\n\n\t\t// Rewards to emit = pendingRewards * timeSinceLastUpkeep * rewardsEmitterDailyPercent / oneDay\n\t\tuint256 numeratorMult = timeSinceLastUpkeep * rewardsConfig.rewardsEmitterDailyPercentTimes1000();\n\t\tuint256 denominatorMult = 1 days * 100000; // simplification of numberSecondsInOneDay * (100 percent) * 1000\n\n\t\tuint256 sum = 0;\n\t\tfor( uint256 i = 0; i < poolIDs.length; i++ )\n\t\t\t{\n\t\t\tbytes32 poolID = poolIDs[i];\n\n\t\t\t// Each pool will send a percentage of the pending rewards based on the time elapsed since the last send\n\t\t\tuint256 amountToAddForPool = ( pendingRewards[poolID] * numeratorMult ) / denominatorMult;\n\n\t\t\t// Reduce the pending rewards so they are not sent again\n\t\t\tif ( amountToAddForPool != 0 )\n\t\t\t\t{\n\t\t\t\tpendingRewards[poolID] -= amountToAddForPool;\n\n\t\t\t\tsum += amountToAddForPool;\n\t\t\t\t}\n\n\t\t\t// Specify the rewards that will be added for the specific pool\n\t\t\taddedRewards[i] = AddedReward( poolID, amountToAddForPool );\n\t\t\t}\n\n\t\t// Add the rewards so that they can later be claimed by the users proportional to their share of the StakingRewards derived contract.\n\t\tstakingRewards.addSALTRewards( addedRewards );\n\t\t}\n\n\n\t// === VIEWS ===\n\n\tfunction pendingRewardsForPools( bytes32[] calldata pools ) external view returns (uint256[] memory)\n\t\t{\n\t\tuint256[] memory rewards = new uint256[]( pools.length );\n\n\t\tfor( uint256 i = 0; i < rewards.length; i++ )\n\t\t\trewards[i] = pendingRewards[ pools[i] ];\n\n\t\treturn rewards;\n\t\t}\n\t}"
    }
  ]
}