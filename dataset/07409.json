{
  "Title": "[H-02] ProtocolDAO lacks a method to take out GGP",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/Staking.sol#L379-L383\n\n\n# Vulnerability details\n\n## Impact\n\nProtocolDAO implementation does not have a method to take out  GGP. So it can't handle ggp unless it updates ProtocolDAO\n## Proof of Concept\n\n\nrecordStakingEnd() will pass the rewards of this reward\n\"If the validator is failing at their duties, their GGP will be slashed and used to compensate the loss to our Liquid Stakers\"\n\nAt this point slashGGP() will be executed and the GGP will be transferred to \"ProtocolDAO\"\n\nstaking.slashGGP():\n```solidity\n    function slashGGP(address stakerAddr, uint256 ggpAmt) public onlySpecificRegisteredContract(\"MinipoolManager\", msg.sender) {\n        Vault vault = Vault(getContractAddress(\"Vault\"));\n        decreaseGGPStake(stakerAddr, ggpAmt);\n        vault.transferToken(\"ProtocolDAO\", ggp, ggpAmt);\n    }\n```\nBut the current ProtocolDAO implementation does not have a method to take out  GGP. So it can't handle ggp unless it updates ProtocolDAO\n\n\n## Tools Used\n\n## Recommended Mitigation Steps\n\n1.transfer GGP to  ClaimProtocolDAO \nor\n2.Similar to ClaimProtocolDAO, add spend method to retrieve GGP\n\n```solidity\ncontract ProtocolDAO is Base {\n...\n\n+    function spend(\n+        address recipientAddress,\n+        uint256 amount\n+    ) external onlyGuardian {\n+        Vault vault = Vault(getContractAddress(\"Vault\"));\n+        TokenGGP ggpToken = TokenGGP(getContractAddress(\"TokenGGP\"));\n+\n+        if (amount == 0 || amount > vault.balanceOfToken(\"ProtocolDAO\", ggpToken)) {\n+            revert InvalidAmount();\n+        }\n+\n+        vault.withdrawToken(recipientAddress, ggpToken, amount);\n+\n+        emit GGPTokensSentByDAOProtocol(address(this), recipientAddress, amount);\n+   }\n```",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-12-gogopool-contest",
  "Code": [
    {
      "filename": "contracts/contract/Staking.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport \"./Base.sol\";\nimport {MinipoolManager} from \"./MinipoolManager.sol\";\nimport {Oracle} from \"./Oracle.sol\";\nimport {ProtocolDAO} from \"./ProtocolDAO.sol\";\nimport {Storage} from \"./Storage.sol\";\nimport {Vault} from \"./Vault.sol\";\n\nimport {ERC20} from \"@rari-capital/solmate/src/mixins/ERC4626.sol\";\nimport {FixedPointMathLib} from \"@rari-capital/solmate/src/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\";\n\n/*\n\tData Storage Schema\n\tA \"staker\" is a user of the protocol who stakes GGP into this contract\n\n\tstaker.count = Starts at 0 and counts up by 1 after a staker is added.\n\n\tstaker.index<stakerAddr> = <index> of stakerAddr\n\tstaker.item<index>.stakerAddr = wallet address of staker, used as primary key\n\tstaker.item<index>.ggpStaked = Total amt of GGP staked across all minipools\n\tstaker.item<index>.avaxStaked = Total amt of AVAX staked across all minipools\n\tstaker.item<index>.avaxAssigned = Total amt of liquid staker funds assigned across all minipools\n\tstaker.item<index>.avaxAssignedHighWater = Highest amt of liquid staker funds assigned during a GGP rewards cycle\n*/\n\n/// @title GGP staking and staker attributes\ncontract Staking is Base {\n\tusing SafeTransferLib for ERC20;\n\tusing SafeTransferLib for address;\n\tusing FixedPointMathLib for uint256;\n\n\terror CannotWithdrawUnder150CollateralizationRatio();\n\terror InsufficientBalance();\n\terror InvalidRewardsStartTime();\n\terror StakerNotFound();\n\n\tevent GGPStaked(address indexed from, uint256 amount);\n\tevent GGPWithdrawn(address indexed to, uint256 amount);\n\n\t/// @dev Not used for storage, just for returning data from view functions\n\tstruct Staker {\n\t\taddress stakerAddr;\n\t\tuint256 ggpStaked;\n\t\tuint256 avaxStaked;\n\t\tuint256 avaxAssigned;\n\t\tuint256 avaxAssignedHighWater;\n\t\tuint256 minipoolCount;\n\t\tuint256 rewardsStartTime;\n\t\tuint256 ggpRewards;\n\t\tuint256 lastRewardsCycleCompleted;\n\t}\n\n\tuint256 internal constant TENTH = 0.1 ether;\n\n\tERC20 public immutable ggp;\n\n\tconstructor(Storage storageAddress, ERC20 ggp_) Base(storageAddress) {\n\t\tversion = 1;\n\t\tggp = ggp_;\n\t}\n\n\t/// @notice Total GGP (stored in vault) assigned to this contract\n\tfunction getTotalGGPStake() public view returns (uint256) {\n\t\tVault vault = Vault(getContractAddress(\"Vault\"));\n\t\treturn vault.balanceOfToken(\"Staking\", ggp);\n\t}\n\n\t/// @notice Total count of GGP stakers in the protocol\n\tfunction getStakerCount() public view returns (uint256) {\n\t\treturn getUint(keccak256(\"staker.count\"));\n\t}\n\n\t/* GGP STAKE */\n\n\t/// @notice The amount of GGP a given staker is staking\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction getGGPStake(address stakerAddr) public view returns (uint256) {\n\t\tint256 stakerIndex = requireValidStaker(stakerAddr);\n\t\treturn getUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".ggpStaked\")));\n\t}\n\n\t/// @notice Increase the amount of GGP a given staker is staking\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction increaseGGPStake(address stakerAddr, uint256 amount) internal {\n\t\tint256 stakerIndex = requireValidStaker(stakerAddr);\n\t\taddUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".ggpStaked\")), amount);\n\t}\n\n\t/// @notice Decrease the amount of GGP a given staker is staking\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction decreaseGGPStake(address stakerAddr, uint256 amount) internal {\n\t\tint256 stakerIndex = requireValidStaker(stakerAddr);\n\t\tsubUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".ggpStaked\")), amount);\n\t}\n\n\t/* AVAX STAKE */\n\n\t/// @notice The amount of AVAX a given staker is staking\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction getAVAXStake(address stakerAddr) public view returns (uint256) {\n\t\tint256 stakerIndex = requireValidStaker(stakerAddr);\n\t\treturn getUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".avaxStaked\")));\n\t}\n\n\t/// @notice Increase the amount of AVAX a given staker is staking\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction increaseAVAXStake(address stakerAddr, uint256 amount) public onlySpecificRegisteredContract(\"MinipoolManager\", msg.sender) {\n\t\tint256 stakerIndex = requireValidStaker(stakerAddr);\n\t\taddUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".avaxStaked\")), amount);\n\t}\n\n\t/// @notice Decrease the amount of AVAX a given staker is staking\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction decreaseAVAXStake(address stakerAddr, uint256 amount) public onlySpecificRegisteredContract(\"MinipoolManager\", msg.sender) {\n\t\tint256 stakerIndex = requireValidStaker(stakerAddr);\n\t\tsubUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".avaxStaked\")), amount);\n\t}\n\n\t/* AVAX ASSIGNED */\n\n\t/// @notice The amount of AVAX a given staker is assigned by the protocol (for minipool creation)\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction getAVAXAssigned(address stakerAddr) public view returns (uint256) {\n\t\tint256 stakerIndex = getIndexOf(stakerAddr);\n\t\treturn getUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".avaxAssigned\")));\n\t}\n\n\t/// @notice Increase the amount of AVAX a given staker is assigned by the protocol (for minipool creation)\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction increaseAVAXAssigned(address stakerAddr, uint256 amount) public onlySpecificRegisteredContract(\"MinipoolManager\", msg.sender) {\n\t\tint256 stakerIndex = requireValidStaker(stakerAddr);\n\t\taddUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".avaxAssigned\")), amount);\n\t}\n\n\t/// @notice Decrease the amount of AVAX a given staker is assigned by the protocol (for minipool creation)\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction decreaseAVAXAssigned(address stakerAddr, uint256 amount) public onlySpecificRegisteredContract(\"MinipoolManager\", msg.sender) {\n\t\tint256 stakerIndex = requireValidStaker(stakerAddr);\n\t\tsubUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".avaxAssigned\")), amount);\n\t}\n\n\t/* AVAX ASSIGNED HIGH-WATER */\n\n\t/// @notice Largest total AVAX amt assigned to a staker during a rewards period\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction getAVAXAssignedHighWater(address stakerAddr) public view returns (uint256) {\n\t\tint256 stakerIndex = getIndexOf(stakerAddr);\n\t\treturn getUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".avaxAssignedHighWater\")));\n\t}\n\n\t/// @notice Increase the AVAXAssignedHighWater\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction increaseAVAXAssignedHighWater(address stakerAddr, uint256 amount) public onlyRegisteredNetworkContract {\n\t\tint256 stakerIndex = requireValidStaker(stakerAddr);\n\t\taddUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".avaxAssignedHighWater\")), amount);\n\t}\n\n\t/// @notice Reset the AVAXAssignedHighWater to what the current AVAXAssigned is for the staker\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction resetAVAXAssignedHighWater(address stakerAddr) public onlyRegisteredNetworkContract {\n\t\tint256 stakerIndex = requireValidStaker(stakerAddr);\n\t\tuint256 currAVAXAssigned = getUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".avaxAssigned\")));\n\t\tsetUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".avaxAssignedHighWater\")), currAVAXAssigned);\n\t}\n\n\t/* MINIPOOL COUNT */\n\n\t/// @notice The number of minipools the given staker has\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction getMinipoolCount(address stakerAddr) public view returns (uint256) {\n\t\tint256 stakerIndex = getIndexOf(stakerAddr);\n\t\treturn getUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".minipoolCount\")));\n\t}\n\n\t/// @notice Increase the number of minipools the given staker has\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction increaseMinipoolCount(address stakerAddr) public onlySpecificRegisteredContract(\"MinipoolManager\", msg.sender) {\n\t\tint256 stakerIndex = requireValidStaker(stakerAddr);\n\t\taddUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".minipoolCount\")), 1);\n\t}\n\n\t/// @notice Decrease the number of minipools the given staker has\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction decreaseMinipoolCount(address stakerAddr) public onlySpecificRegisteredContract(\"MinipoolManager\", msg.sender) {\n\t\tint256 stakerIndex = requireValidStaker(stakerAddr);\n\t\tsubUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".minipoolCount\")), 1);\n\t}\n\n\t/* REWARDS START TIME */\n\n\t/// @notice The timestamp when the staker registered for GGP rewards\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction getRewardsStartTime(address stakerAddr) public view returns (uint256) {\n\t\tint256 stakerIndex = getIndexOf(stakerAddr);\n\t\treturn getUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".rewardsStartTime\")));\n\t}\n\n\t/// @notice Set the timestamp when the staker registered for GGP rewards\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\t// TODO cant use onlySpecificRegisteredContract(\"ClaimNodeOp\", msg.sender) since we also call from increaseMinipoolCount. Wat do?\n\tfunction setRewardsStartTime(address stakerAddr, uint256 time) public onlyRegisteredNetworkContract {\n\t\tint256 stakerIndex = requireValidStaker(stakerAddr);\n\t\tif (time > block.timestamp) {\n\t\t\trevert InvalidRewardsStartTime();\n\t\t}\n\n\t\tsetUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".rewardsStartTime\")), time);\n\t}\n\n\t/* GGP REWARDS */\n\n\t/// @notice The amount of GGP rewards the staker has earned and not claimed\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction getGGPRewards(address stakerAddr) public view returns (uint256) {\n\t\tint256 stakerIndex = getIndexOf(stakerAddr);\n\t\treturn getUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".ggpRewards\")));\n\t}\n\n\t/// @notice Increase the amount of GGP rewards the staker has earned and not claimed\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction increaseGGPRewards(address stakerAddr, uint256 amount) public onlySpecificRegisteredContract(\"ClaimNodeOp\", msg.sender) {\n\t\tint256 stakerIndex = requireValidStaker(stakerAddr);\n\t\taddUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".ggpRewards\")), amount);\n\t}\n\n\t/// @notice Decrease the amount of GGP rewards the staker has earned and not claimed\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction decreaseGGPRewards(address stakerAddr, uint256 amount) public onlySpecificRegisteredContract(\"ClaimNodeOp\", msg.sender) {\n\t\tint256 stakerIndex = requireValidStaker(stakerAddr);\n\t\tsubUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".ggpRewards\")), amount);\n\t}\n\n\t/* LAST REWARDS CYCLE PAID OUT */\n\n\t/// @notice The most recent reward cycle number that the staker has been paid out for\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction getLastRewardsCycleCompleted(address stakerAddr) public view returns (uint256) {\n\t\tint256 stakerIndex = getIndexOf(stakerAddr);\n\t\treturn getUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".lastRewardsCycleCompleted\")));\n\t}\n\n\t/// @notice Set the most recent reward cycle number that the staker has been paid out for\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\t/// @param cycleNumber The cycle that the staker was just rewarded for\n\tfunction setLastRewardsCycleCompleted(address stakerAddr, uint256 cycleNumber) public onlySpecificRegisteredContract(\"ClaimNodeOp\", msg.sender) {\n\t\tint256 stakerIndex = requireValidStaker(stakerAddr);\n\t\tsetUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".lastRewardsCycleCompleted\")), cycleNumber);\n\t}\n\n\t/// @notice Get a stakers's minimum GGP stake to collateralize their minipools, based on current GGP price\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\t/// @return Amount of GGP\n\tfunction getMinimumGGPStake(address stakerAddr) public view returns (uint256) {\n\t\tProtocolDAO dao = ProtocolDAO(getContractAddress(\"ProtocolDAO\"));\n\t\tOracle oracle = Oracle(getContractAddress(\"Oracle\"));\n\t\t(uint256 ggpPriceInAvax, ) = oracle.getGGPPriceInAVAX();\n\n\t\tuint256 avaxAssigned = getAVAXAssigned(stakerAddr);\n\t\tuint256 ggp100pct = avaxAssigned.divWadDown(ggpPriceInAvax);\n\t\treturn ggp100pct.mulWadDown(dao.getMinCollateralizationRatio());\n\t}\n\n\t/// @notice Returns collateralization ratio based on current GGP price\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\t/// @return A ratio where 0 = 0%, 1 ether = 100%\n\tfunction getCollateralizationRatio(address stakerAddr) public view returns (uint256) {\n\t\tuint256 avaxAssigned = getAVAXAssigned(stakerAddr);\n\t\tif (avaxAssigned == 0) {\n\t\t\t// Infinite collat ratio\n\t\t\treturn type(uint256).max;\n\t\t}\n\t\tOracle oracle = Oracle(getContractAddress(\"Oracle\"));\n\t\t(uint256 ggpPriceInAvax, ) = oracle.getGGPPriceInAVAX();\n\t\tuint256 ggpStakedInAvax = getGGPStake(stakerAddr).mulWadDown(ggpPriceInAvax);\n\t\treturn ggpStakedInAvax.divWadDown(avaxAssigned);\n\t}\n\n\t/// @notice Returns effective collateralization ratio which will be used to pay out rewards\n\t///         based on current GGP price and AVAX high water mark. A staker can earn GGP rewards\n\t///         on up to 150% collat ratio\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\t/// @return Ratio is between 0%-150% (0-1.5 ether)\n\tfunction getEffectiveRewardsRatio(address stakerAddr) public view returns (uint256) {\n\t\tuint256 avaxAssignedHighWater = getAVAXAssignedHighWater(stakerAddr);\n\t\tif (avaxAssignedHighWater == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (getCollateralizationRatio(stakerAddr) < TENTH) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tOracle oracle = Oracle(getContractAddress(\"Oracle\"));\n\t\t(uint256 ggpPriceInAvax, ) = oracle.getGGPPriceInAVAX();\n\t\tuint256 ggpStakedInAvax = getGGPStake(stakerAddr).mulWadDown(ggpPriceInAvax);\n\t\tuint256 ratio = ggpStakedInAvax.divWadDown(avaxAssignedHighWater);\n\n\t\tProtocolDAO dao = ProtocolDAO(getContractAddress(\"ProtocolDAO\"));\n\t\tuint256 maxRatio = dao.getMaxCollateralizationRatio();\n\n\t\treturn (ratio > maxRatio) ? maxRatio : ratio;\n\t}\n\n\t/// @notice GGP that will count towards rewards this cycle\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction getEffectiveGGPStaked(address stakerAddr) external view returns (uint256) {\n\t\tOracle oracle = Oracle(getContractAddress(\"Oracle\"));\n\t\t(uint256 ggpPriceInAvax, ) = oracle.getGGPPriceInAVAX();\n\n\t\tuint256 avaxAssignedHighWater = getAVAXAssignedHighWater(stakerAddr);\n\t\tuint256 ratio = getEffectiveRewardsRatio(stakerAddr);\n\t\treturn avaxAssignedHighWater.mulWadDown(ratio).divWadDown(ggpPriceInAvax);\n\t}\n\n\t/// @notice Accept a GGP stake\n\t/// @param amount The amount of GGP being staked\n\tfunction stakeGGP(uint256 amount) external whenNotPaused {\n\t\t// Transfer GGP tokens from staker to this contract\n\t\tggp.safeTransferFrom(msg.sender, address(this), amount);\n\t\t_stakeGGP(msg.sender, amount);\n\t}\n\n\t/// @notice Convenience function to allow for restaking claimed GGP rewards\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\t/// @param amount The amount of GGP being staked\n\tfunction restakeGGP(address stakerAddr, uint256 amount) public onlySpecificRegisteredContract(\"ClaimNodeOp\", msg.sender) {\n\t\t// Transfer GGP tokens from the ClaimNodeOp contract to this contract\n\t\tggp.safeTransferFrom(msg.sender, address(this), amount);\n\t\t_stakeGGP(stakerAddr, amount);\n\t}\n\n\t/// @notice Stakes GGP in the protocol\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\t/// @param amount The amount of GGP being staked\n\tfunction _stakeGGP(address stakerAddr, uint256 amount) internal {\n\t\temit GGPStaked(stakerAddr, amount);\n\n\t\t// Deposit GGP tokens from this contract to vault\n\t\tVault vault = Vault(getContractAddress(\"Vault\"));\n\t\tggp.approve(address(vault), amount);\n\t\tvault.depositToken(\"Staking\", ggp, amount);\n\n\t\tint256 stakerIndex = getIndexOf(stakerAddr);\n\t\tif (stakerIndex == -1) {\n\t\t\t// create index for the new staker\n\t\t\tstakerIndex = int256(getUint(keccak256(\"staker.count\")));\n\t\t\taddUint(keccak256(\"staker.count\"), 1);\n\t\t\tsetUint(keccak256(abi.encodePacked(\"staker.index\", stakerAddr)), uint256(stakerIndex + 1));\n\t\t\tsetAddress(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".stakerAddr\")), stakerAddr);\n\t\t}\n\t\tincreaseGGPStake(stakerAddr, amount);\n\t}\n\n\t/// @notice Allows the staker to unstake their GGP if they are over the 150% collateralization ratio\n\t/// @param amount The amount of GGP being withdrawn\n\tfunction withdrawGGP(uint256 amount) external whenNotPaused {\n\t\tif (amount > getGGPStake(msg.sender)) {\n\t\t\trevert InsufficientBalance();\n\t\t}\n\n\t\temit GGPWithdrawn(msg.sender, amount);\n\n\t\tdecreaseGGPStake(msg.sender, amount);\n\n\t\tProtocolDAO dao = ProtocolDAO(getContractAddress(\"ProtocolDAO\"));\n\t\tif (getCollateralizationRatio(msg.sender) < dao.getMaxCollateralizationRatio()) {\n\t\t\trevert CannotWithdrawUnder150CollateralizationRatio();\n\t\t}\n\n\t\tVault vault = Vault(getContractAddress(\"Vault\"));\n\t\tvault.withdrawToken(msg.sender, ggp, amount);\n\t}\n\n\t/// @notice Minipool Manager will call this if a minipool ended and was not in good standing\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\t/// @param ggpAmt The amount of GGP being slashed\n\tfunction slashGGP(address stakerAddr, uint256 ggpAmt) public onlySpecificRegisteredContract(\"MinipoolManager\", msg.sender) {\n\t\tVault vault = Vault(getContractAddress(\"Vault\"));\n\t\tdecreaseGGPStake(stakerAddr, ggpAmt);\n\t\tvault.transferToken(\"ProtocolDAO\", ggp, ggpAmt);\n\t}\n\n\t/// @notice Verifying the staker exists in the protocol\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction requireValidStaker(address stakerAddr) public view returns (int256) {\n\t\tint256 index = getIndexOf(stakerAddr);\n\t\tif (index != -1) {\n\t\t\treturn index;\n\t\t} else {\n\t\t\trevert StakerNotFound();\n\t\t}\n\t}\n\n\t/// @notice Get index of the staker\n\t/// @return staker index or -1 if the value was not found\n\tfunction getIndexOf(address stakerAddr) public view returns (int256) {\n\t\treturn int256(getUint(keccak256(abi.encodePacked(\"staker.index\", stakerAddr)))) - 1;\n\t}\n\n\t/// @notice Gets the staker information using the staker's index\n\t/// @param stakerIndex Index of the staker\n\t/// @return staker struct containing the staker's properties\n\tfunction getStaker(int256 stakerIndex) public view returns (Staker memory staker) {\n\t\tstaker.ggpStaked = getUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".ggpStaked\")));\n\t\tstaker.avaxAssigned = getUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".avaxAssigned\")));\n\t\tstaker.avaxStaked = getUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".avaxStaked\")));\n\t\tstaker.stakerAddr = getAddress(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".stakerAddr\")));\n\t\tstaker.minipoolCount = getUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".minipoolCount\")));\n\t\tstaker.rewardsStartTime = getUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".rewardsStartTime\")));\n\t\tstaker.ggpRewards = getUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".ggpRewards\")));\n\t\tstaker.lastRewardsCycleCompleted = getUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".lastRewardsCycleCompleted\")));\n\t}\n\n\t/// @notice Get stakers in the protocol (limit=0 means no pagination)\n\t/// @param offset The number the result should be offset by\n\t/// @param limit The limit to the amount of minipools that should be returned\n\t/// @return stakers in the protocol that adhear to the paramaters\n\tfunction getStakers(uint256 offset, uint256 limit) external view returns (Staker[] memory stakers) {\n\t\tuint256 totalStakers = getStakerCount();\n\t\tuint256 max = offset + limit;\n\t\tif (max > totalStakers || limit == 0) {\n\t\t\tmax = totalStakers;\n\t\t}\n\t\tstakers = new Staker[](max - offset);\n\t\tuint256 total = 0;\n\t\tfor (uint256 i = offset; i < max; i++) {\n\t\t\tStaker memory s = getStaker(int256(i));\n\t\t\tstakers[total] = s;\n\t\t\ttotal++;\n\t\t}\n\t\t// Dirty hack to cut unused elements off end of return value (from RP)\n\t\t// solhint-disable-next-line no-inline-assembly\n\t\tassembly {\n\t\t\tmstore(stakers, total)\n\t\t}\n\t}\n}"
    }
  ]
}