{
  "Title": "Lack of Governance action to update registered emitters",
  "Content": "**Description:** The Wormhole CCTP integration contract currently exposes a function [`Governance::registerEmitterAndDomain`](https://github.com/wormhole-foundation/wormhole-circle-integration/blob/f7df33b159a71b163b8b5c7e7381c0d8f193da99/evm/src/contracts/CircleIntegration/Governance.sol#L48-L84) to register an emitter address and its corresponding CCTP domain on the given foreign chain; however, no such function currently exists to update this state. Any mistake made when registering the emitter and CCTP domain is irreversible unless an upgrade is performed on the entirety of the integration contract itself. Deployment of protocol upgrades comes with its own risks and should not be performed as a necessary fix for trivial human errors. Having a separate governance action to update the emitter address, foreign chain identifier, and CCTP domain is a preferable pre-emptive measure against any potential human errors.\n\n```solidity\nfunction registerEmitterAndDomain(bytes memory encodedVaa) public {\n    /* snip: parsing of Governance VAA payload */\n\n    // Set the registeredEmitters state variable.\n    registeredEmitters[foreignChain] = foreignAddress;\n\n    // update the chainId to domain (and domain to chainId) mappings\n    getChainToDomain()[foreignChain] = cctpDomain;\n    getDomainToChain()[cctpDomain] = foreignChain;\n}\n```\n\n**Impact:** In the event an emitter is registered with an incorrect foreign chain identifier or CCTP domain, then a protocol upgrade will be required to mitigate this issue. As such, the risks associated with the deployment of protocol upgrades and the potential time-sensitive nature of this issue designate a low severity issue.\n\n**Proof of Concept:**\n1. A Governance VAA erroneously registers an emitter with the incorrect foreign chain identifier.\n2. A Governance upgrade is now required to re-initialize this state so that the correct foreign chain identifier can be associated with the given emitter address.\n\n**Recommended Mitigation:** The addition of a `Governance::updateEmitterAndDomain` function is recommended to allow Governance to more easily respond to any issues with the registered emitter state.\n\n**Wormhole Foundation:** Allowing existing emitters to be updated comes with similar impacts of admin mistakes. But allowing updates is indeed easier than coordinating a whole contract upgrade. However we won’t change this since we can’t easily enforce that governance messages to perform these updates are played in sequence.\n\n**Cyfrin:** Acknowledged.\n\n\\clearpage",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "evm/src/contracts/CircleIntegration/Governance.sol",
      "content": "// SPDX-License-Identifier: Apache 2\npragma solidity ^0.8.19;\n\nimport {ERC1967Upgrade} from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol\";\n\nimport {BytesParsing} from \"src/libraries/BytesParsing.sol\";\nimport {IWormhole} from \"src/interfaces/IWormhole.sol\";\nimport {IGovernance} from \"src/interfaces/IGovernance.sol\";\n\nimport {State} from \"./State.sol\";\nimport {\n    getRegisteredEmitters,\n    getChainToDomain,\n    getConsumedVaas,\n    getDomainToChain\n} from \"./Storage.sol\";\n\nabstract contract Governance is IGovernance, State, ERC1967Upgrade {\n    using BytesParsing for bytes;\n\n    /**\n     * @dev Governance emitter chain ID.\n     */\n    uint16 constant _GOVERNANCE_CHAIN = 1;\n\n    /**\n     * @dev Governance emitter address.\n     */\n    bytes32 constant _GOVERNANCE_EMITTER =\n        0x0000000000000000000000000000000000000000000000000000000000000004;\n\n    /**\n     * @dev \"CircleIntegration\" (left-padded with zeros).\n     */\n    bytes32 constant GOVERNANCE_MODULE =\n        0x000000000000000000000000000000436972636c65496e746567726174696f6e;\n\n    /**\n     * @dev Governance action ID indicating decree to register new emitter and CCTP domain.\n     */\n    uint8 constant _ACTION_REGISTER_EMITTER_AND_DOMAIN = 2;\n\n    /**\n     * @dev Governance action ID indicating decree to upgrade contract.\n     */\n    uint8 constant _ACTION_CONTRACT_UPGRADE = 3;\n\n    /// @inheritdoc IGovernance\n    function registerEmitterAndDomain(bytes memory encodedVaa) public {\n        (IWormhole.VM memory vaa, uint256 offset) =\n            _verifyAndConsumeGovernanceMessage(encodedVaa, _ACTION_REGISTER_EMITTER_AND_DOMAIN);\n\n        // Registering emitters should only be relevant for this contract's chain ID,\n        // unless the target chain is 0 (which means all chains).\n        uint16 targetChain;\n        (targetChain, offset) = vaa.payload.asUint16Unchecked(offset);\n        require(targetChain == 0 || targetChain == _chainId, \"invalid target chain\");\n\n        uint16 foreignChain;\n        (foreignChain, offset) = vaa.payload.asUint16Unchecked(offset);\n        require(foreignChain != 0 && foreignChain != _chainId, \"invalid chain\");\n\n        mapping(uint16 => bytes32) storage registeredEmitters = getRegisteredEmitters();\n\n        // For now, ensure that we cannot register the same foreign chain again.\n        require(registeredEmitters[foreignChain] == 0, \"chain already registered\");\n\n        bytes32 foreignAddress;\n        (foreignAddress, offset) = vaa.payload.asBytes32Unchecked(offset);\n        require(foreignAddress != 0, \"emitter cannot be zero address\");\n\n        uint32 cctpDomain;\n        (cctpDomain, offset) = vaa.payload.asUint32Unchecked(offset);\n        require(cctpDomain != _localCctpDomain, \"domain == localDomain()\");\n\n        _checkLength(vaa.payload, offset);\n\n        // Set the registeredEmitters state variable.\n        registeredEmitters[foreignChain] = foreignAddress;\n\n        // update the chainId to domain (and domain to chainId) mappings\n        getChainToDomain()[foreignChain] = cctpDomain;\n        getDomainToChain()[cctpDomain] = foreignChain;\n    }\n\n    /// @inheritdoc IGovernance\n    function upgradeContract(bytes memory encodedVaa) public {\n        (IWormhole.VM memory vaa, uint256 offset) =\n            _verifyAndConsumeGovernanceMessage(encodedVaa, _ACTION_CONTRACT_UPGRADE);\n\n        // contract upgrades should only be relevant for this contract's chain ID\n        uint16 targetChain;\n        (targetChain, offset) = vaa.payload.asUint16Unchecked(offset);\n        require(targetChain == _chainId, \"invalid target chain\");\n\n        bytes32 encodedImplementation;\n        (encodedImplementation, offset) = vaa.payload.asBytes32Unchecked(offset);\n        require(bytes12(encodedImplementation) == 0, \"invalid address\");\n\n        _checkLength(vaa.payload, offset);\n\n        address newImplementation;\n        assembly (\"memory-safe\") {\n            newImplementation := encodedImplementation\n        }\n\n        // Verify new implementation is CircleIntegration.\n        {\n            (, bytes memory queried) = newImplementation.staticcall(\n                abi.encodeWithSignature(\"circleIntegrationImplementation()\")\n            );\n\n            require(queried.length == 32, \"invalid implementation\");\n            require(\n                abi.decode(queried, (bytes32)) == keccak256(\"circleIntegrationImplementation()\"),\n                \"invalid implementation\"\n            );\n        }\n\n        // Save the current implementation address for event.\n        address currentImplementation = _getImplementation();\n\n        _upgradeTo(newImplementation);\n\n        // call initialize function of the new implementation\n        (bool success, bytes memory reason) =\n            newImplementation.delegatecall(abi.encodeWithSignature(\"initialize()\"));\n        require(success, string(reason));\n\n        emit ContractUpgraded(currentImplementation, newImplementation);\n    }\n\n    /// @inheritdoc IGovernance\n    function verifyGovernanceMessage(bytes memory encodedVaa, uint8 action)\n        public\n        view\n        returns (bytes32, bytes memory)\n    {\n        (IWormhole.VM memory vaa,) = _verifyGovernanceMessage(getConsumedVaas(), encodedVaa, action);\n        return (vaa.hash, vaa.payload);\n    }\n\n    function _verifyAndConsumeGovernanceMessage(bytes memory encodedVaa, uint8 action)\n        private\n        returns (IWormhole.VM memory, uint256)\n    {\n        mapping(bytes32 => bool) storage consumedVaas = getConsumedVaas();\n\n        // verify the governance message\n        (IWormhole.VM memory vaa, uint256 offset) =\n            _verifyGovernanceMessage(consumedVaas, encodedVaa, action);\n\n        // store the hash for replay protection\n        consumedVaas[vaa.hash] = true;\n\n        return (vaa, offset);\n    }\n\n    function _verifyGovernanceMessage(\n        mapping(bytes32 => bool) storage consumedVaas,\n        bytes memory encodedVaa,\n        uint8 action\n    ) private view returns (IWormhole.VM memory vaa, uint256 offset) {\n        // Make sure the blockchain has not forked.\n        require(block.chainid == _evmChain, \"invalid evm chain\");\n\n        // verify the governance message\n        bool valid;\n        string memory reason;\n        (vaa, valid, reason) = _wormhole.parseAndVerifyVM(encodedVaa);\n        require(valid, reason);\n\n        // Confirm that the governance message was sent from the governance contract.\n        require(vaa.emitterChainId == _GOVERNANCE_CHAIN, \"invalid governance chain\");\n        require(vaa.emitterAddress == _GOVERNANCE_EMITTER, \"invalid governance contract\");\n\n        // Confirm that this governance action has not been consumed already.\n        require(!consumedVaas[vaa.hash], \"governance action already consumed\");\n\n        bytes32 govModule;\n        (govModule, offset) = vaa.payload.asBytes32Unchecked(offset);\n\n        require(govModule == GOVERNANCE_MODULE, \"invalid governance module\");\n\n        uint8 govAction;\n        (govAction, offset) = vaa.payload.asUint8Unchecked(offset);\n\n        require(govAction == action, \"invalid governance action\");\n    }\n\n    function _checkLength(bytes memory encoded, uint256 expected) private pure {\n        require(encoded.length == expected, \"invalid governance payload length\");\n    }\n\n    // getters\n\n    /// @inheritdoc IGovernance\n    function governanceChainId() public pure returns (uint16) {\n        return _GOVERNANCE_CHAIN;\n    }\n\n    /// @inheritdoc IGovernance\n    function governanceContract() public pure returns (bytes32) {\n        return _GOVERNANCE_EMITTER;\n    }\n}"
    }
  ]
}