{
  "Title": "[H-15] The difference between `gasLeft` and `gasAfterTransfer` is greater than `TRANSFER_OVERHEAD`, causing `anyExecute` to always fail",
  "Content": "\nIn `_payExecutionGas`,  there is the following code:\n\n```solidity\n///Save gas left\n\tuint256 gasLeft = gasleft();\n\t.\n\t.\n\t. \n\t.\n//Transfer gas remaining to recipient\n\tSafeTransferLib.safeTransferETH(_recipient, gasRemaining - minExecCost);\n\t//Save Gas\n\tuint256 gasAfterTransfer = gasleft();\n\t//Check if sufficient balance\n\tif (gasLeft - gasAfterTransfer > TRANSFER_OVERHEAD) {\n\t\t_forceRevert();\n\t\treturn;\n\t}\n```\n\n<https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L1029-L1054>\n\nIt checks if the difference between `gasLeft` and `gasAfterTransfer` is greater than `TRANSFER_OVERHEAD`. Then, it calls `_forceRevert()` so that `Anycall Executor` reverts the call. This check has been introduced to prevent any arbitrary code executed in the `_recipient's fallback` (this was confirmed by the sponsor). However, the condition `gasLeft - gasAfterTransfer > TRANSFER_OVERHEAD` is always true. `TRANSFER_OVERHEAD` is `24_000`.\n\n```solidity\nuint256 internal constant TRANSFER_OVERHEAD = 24_000;\n```\n\n<https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L139>\n\nAnd the **gas spent between `gasLeft` and `gasAfterTransfer` is nearly `70_000` which is higher than `24_000`**. Thus, causing the function to always revert. Function `_payExecutionGas` is called by `anyExecute` which is called by the `Anycall Executor`. This means `anyExecute` will also fail. This happens because the `gasLeft` value is stored before replenishing gas and not before the transfer.\n\n### Proof of Concept\n\nThis PoC is independent from the codebase (but uses the same code). There is one contract simulating `BranchBridgeAgent.anyExecute`.\n\nWhen we run the test, `anyExecute` will revert because `gasLeft - gasAfterTransfer` is always greater than `TRANSFER_OVERHEAD` (`24_000`).\n\nHere is the output of the test:\n\n```sh\n[PASS] test_anyexecute_always_revert_bc_transfer_overhead() (gas: 124174)\nLogs:\n  (gasLeft - gasAfterTransfer > TRANSFER_OVERHEAD) => true\n  gasLeft - gasAfterTransfer = 999999999999979606 - 999999999999909238 = 70368\n\nTest result: ok. 1 passed; 0 failed; finished in 1.88ms\n```\n\n### Explanation\n\nThe `BranchBridgeAgent.anyExecute` method depends on the following external calls:\n\n1. `AnycallExecutor.context()`\n2. `AnycallProxy.config()`\n3. `AnycallConfig.executionBudget()`\n4. `AnycallConfig.withdraw()`\n5. `AnycallConfig.deposit()`\n6. `WETH9.withdraw()`\n\nFor this reason, I've copied the same code from [multichain-smart-contracts](https://github.com/anyswap/multichain-smart-contracts). For `WETH9`, I've used the contract from the codebase which has minimal code.\n\nPlease note that:\n\n- **tx.gasprice** is replaced with a fixed value in the `_payExecutionGas` method, as it is not available in Foundry.\n- In `_replenishGas`, reading the config via `IAnycallProxy(local`AnyCall`Address).config()` is replaced with an immediate call for simplicity. In other words, avoiding a proxy to make the PoC simpler and shorter. However, if done with a proxy, the gas used would increase. So in both ways, it is in favor of the PoC.\n- In `_forceRevert`, we call `anycallConfig`, immediately skipping the returned value from `AnycallProxy`. This is irrelevant for this PoC.\n\n### The Coded PoC\n\n- `Foundry.toml\n`\n```sh\n\t[profile.default]\n\tsolc = '0.8.17'\n\tsrc = 'solidity'\n\ttest = 'solidity/test'\n\tout = 'out'\n\tlibs = ['lib']\n\tfuzz_runs = 1000\n\toptimizer_runs = 10_000\n```\n\n- `.gitmodules`\n\n```sh\n\t[submodule \"lib/ds-test\"]\n\t\tpath = lib/ds-test\n\t\turl = https://github.com/dapphub/ds-test\n\t\tbranch = master\n\t[submodule \"lib/forge-std\"]\n\t\tpath = lib/forge-std\n\t\turl = https://github.com/brockelmore/forge-std\n\t\tbranch = master\n```\n\n- `remappings.txt`\n\n```sh\n\tds-test/=lib/ds-test/src\n\tforge-std/=lib/forge-std/src\n```\n\n- Test File:\n\n<details>\n\n```solidity\n// PoC => Maia OmniChain: anyExecute always revert in BranchBridgeAgent\npragma solidity >=0.8.4 <0.9.0;\n\nimport {Test} from \"forge-std/Test.sol\";\nimport \"forge-std/console.sol\";\n\nimport {DSTest} from \"ds-test/test.sol\";\n\nlibrary SafeTransferLib {\n    /*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*/\n    /-                     CUSTOM ERRORS                        */\n    /*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*/\n\n    /// @dev The ETH transfer has failed.\n    error ETHTransferFailed();\n\n    /// @dev The ERC20 `transferFrom` has failed.\n    error TransferFromFailed();\n\n    /// @dev The ERC20 `transfer` has failed.\n    error TransferFailed();\n\n    /// @dev The ERC20 `approve` has failed.\n    error ApproveFailed();\n\n    /*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*/\n    /-                       CONSTANTS                          */\n    /*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*/\n\n    /// @dev Suggested gas stipend for contract receiving ETH\n    /// that disallows any storage writes.\n    uint256 internal constant _GAS_STIPEND_NO_STORAGE_WRITES = 2300;\n\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\n    /// storage reads and writes, but low enough to prevent griefing.\n    /// Multiply by a small constant (e.g. 2), if needed.\n    uint256 internal constant _GAS_STIPEND_NO_GRIEF = 100000;\n\n    /*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*/\n    /-                     ETH OPERATIONS                       */\n    /*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*/\n\n    /// @dev Sends `amount` (in wei) ETH to `to`.\n    /// Reverts upon failure.\n    ///\n    /// Note: This implementation does NOT protect against gas griefing.\n    /// Please use `forceSafeTransferETH` for gas griefing protection.\n    function safeTransferETH(address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer the ETH and check if it succeeded or not.\n            if iszero(call(gas(), to, amount, 0, 0, 0, 0)) {\n                // Store the function selector of `ETHTransferFailed()`.\n                mstore(0x00, 0xb12d13eb)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\n    /// The `gasStipend` can be set to a low enough value to prevent\n    /// storage writes or gas griefing.\n    ///\n    /// If sending via the normal procedure fails, force sends the ETH by\n    /// creating a temporary contract which uses `SELFDESTRUCT` to force send the ETH.\n    ///\n    /// Reverts if the current contract has insufficient balance.\n    function forceSafeTransferETH(\n        address to,\n        uint256 amount,\n        uint256 gasStipend\n    ) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If insufficient balance, revert.\n            if lt(selfbalance(), amount) {\n                // Store the function selector of `ETHTransferFailed()`.\n                mstore(0x00, 0xb12d13eb)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            // Transfer the ETH and check if it succeeded or not.\n            if iszero(call(gasStipend, to, amount, 0, 0, 0, 0)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                // We can directly use `SELFDESTRUCT` in the contract creation.\n                // Compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758\n                if iszero(create(amount, 0x0b, 0x16)) {\n                    // To coerce gas estimation to provide enough gas for the `create` above.\n                    if iszero(gt(gas(), 1000000)) {\n                        revert(0, 0)\n                    }\n                }\n            }\n        }\n    }\n\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a gas stipend\n    /// equal to `_GAS_STIPEND_NO_GRIEF`. This gas stipend is a reasonable default\n    /// for 99% of cases and can be overridden with the three-argument version of this\n    /// function if necessary.\n    ///\n    /// If sending via the normal procedure fails, force sends the ETH by\n    /// creating a temporary contract which uses `SELFDESTRUCT` to force send the ETH.\n    ///\n    /// Reverts if the current contract has insufficient balance.\n    function forceSafeTransferETH(address to, uint256 amount) internal {\n        // Manually inlined because the compiler doesn't inline functions with branches.\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If insufficient balance, revert.\n            if lt(selfbalance(), amount) {\n                // Store the function selector of `ETHTransferFailed()`.\n                mstore(0x00, 0xb12d13eb)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            // Transfer the ETH and check if it succeeded or not.\n            if iszero(call(_GAS_STIPEND_NO_GRIEF, to, amount, 0, 0, 0, 0)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                // We can directly use `SELFDESTRUCT` in the contract creation.\n                // Compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758\n                if iszero(create(amount, 0x0b, 0x16)) {\n                    // To coerce gas estimation to provide enough gas for the `create` above.\n                    if iszero(gt(gas(), 1000000)) {\n                        revert(0, 0)\n                    }\n                }\n            }\n        }\n    }\n\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\n    /// The `gasStipend` can be set to a low enough value to prevent\n    /// storage writes or gas griefing.\n    ///\n    /// Simply use `gasleft()` for `gasStipend` if you don't need a gas stipend.\n    ///\n    /// Note: Does NOT revert upon failure.\n    /// Returns whether the transfer of ETH is successful instead.\n    function trySafeTransferETH(\n        address to,\n        uint256 amount,\n        uint256 gasStipend\n    ) internal returns (bool success) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer the ETH and check if it succeeded or not.\n            success := call(gasStipend, to, amount, 0, 0, 0, 0)\n        }\n    }\n\n    /*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*/\n    /-                    ERC20 OPERATIONS                      */\n    /*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*/\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have at least `amount` approved for\n    /// the current contract to manage.\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n\n            mstore(0x60, amount) // Store the `amount` argument.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            // Store the function selector of `transferFrom(address,address,uint256)`.\n            mstore(0x0c, 0x23b872dd000000000000000000000000)\n\n            if iszero(\n                and(\n                    // The arguments of `and` are evaluated from right to left.\n                    // Set success to whether the call reverted, if not we check it either\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n                )\n            ) {\n                // Store the function selector of `TransferFromFailed()`.\n                mstore(0x00, 0x7939f424)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have their entire balance approved for\n    /// the current contract to manage.\n    function safeTransferAllFrom(\n        address token,\n        address from,\n        address to\n    ) internal returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            // Store the function selector of `balanceOf(address)`.\n            mstore(0x0c, 0x70a08231000000000000000000000000)\n            if iszero(\n                and(\n                    // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\n                )\n            ) {\n                // Store the function selector of `TransferFromFailed()`.\n                mstore(0x00, 0x7939f424)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // Store the function selector of `transferFrom(address,address,uint256)`.\n            mstore(0x00, 0x23b872dd)\n            // The `amount` argument is already written to the memory word at 0x60.\n            amount := mload(0x60)\n\n            if iszero(\n                and(\n                    // The arguments of `and` are evaluated from right to left.\n                    // Set success to whether the call reverted, if not we check it either\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n                )\n            ) {\n                // Store the function selector of `TransferFromFailed()`.\n                mstore(0x00, 0x7939f424)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\n    /// Reverts upon failure.\n    function safeTransfer(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            // Store the function selector of `transfer(address,uint256)`.\n            mstore(0x00, 0xa9059cbb000000000000000000000000)\n\n            if iszero(\n                and(\n                    // The arguments of `and` are evaluated from right to left.\n                    // Set success to whether the call reverted, if not we check it either\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                )\n            ) {\n                // Store the function selector of `TransferFailed()`.\n                mstore(0x00, 0x90b8ec18)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            // Restore the part of the free memory pointer that was overwritten.\n            mstore(0x34, 0)\n        }\n    }\n\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\n    /// Reverts upon failure.\n    function safeTransferAll(\n        address token,\n        address to\n    ) internal returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\n            mstore(0x20, address()) // Store the address of the current contract.\n            if iszero(\n                and(\n                    // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\n                )\n            ) {\n                // Store the function selector of `TransferFailed()`.\n                mstore(0x00, 0x90b8ec18)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            mstore(0x14, to) // Store the `to` argument.\n            // The `amount` argument is already written to the memory word at 0x34.\n            amount := mload(0x34)\n            // Store the function selector of `transfer(address,uint256)`.\n            mstore(0x00, 0xa9059cbb000000000000000000000000)\n\n            if iszero(\n                and(\n                    // The arguments of `and` are evaluated from right to left.\n                    // Set success to whether the call reverted, if not we check it either\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                )\n            ) {\n                // Store the function selector of `TransferFailed()`.\n                mstore(0x00, 0x90b8ec18)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            // Restore the part of the free memory pointer that was overwritten.\n            mstore(0x34, 0)\n        }\n    }\n\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\n    /// Reverts upon failure.\n    function safeApprove(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            // Store the function selector of `approve(address,uint256)`.\n            mstore(0x00, 0x095ea7b3000000000000000000000000)\n\n            if iszero(\n                and(\n                    // The arguments of `and` are evaluated from right to left.\n                    // Set success to whether the call reverted, if not we check it either\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                )\n            ) {\n                // Store the function selector of `ApproveFailed()`.\n                mstore(0x00, 0x3e3f8f73)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            // Restore the part of the free memory pointer that was overwritten.\n            mstore(0x34, 0)\n        }\n    }\n\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\n    /// Returns zero if the `token` does not exist.\n    function balanceOf(\n        address token,\n        address account\n    ) internal view returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, account) // Store the `account` argument.\n            // Store the function selector of `balanceOf(address)`.\n            mstore(0x00, 0x70a08231000000000000000000000000)\n            amount := mul(\n                mload(0x20),\n                and(\n                    // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\n                )\n            )\n        }\n    }\n}\n\ninterface IAnycallExecutor {\n    function context()\n        external\n        view\n        returns (address from, uint256 fromChainID, uint256 nonce);\n\n    function execute(\n        address _to,\n        bytes calldata _data,\n        address _from,\n        uint256 _fromChainID,\n        uint256 _nonce,\n        uint256 _flags,\n        bytes calldata _extdata\n    ) external returns (bool success, bytes memory result);\n}\n\ninterface IAnycallConfig {\n    function calcSrcFees(\n        address _app,\n        uint256 _toChainID,\n        uint256 _dataLength\n    ) external view returns (uint256);\n\n    function executionBudget(address _app) external view returns (uint256);\n\n    function deposit(address _account) external payable;\n\n    function withdraw(uint256 _amount) external;\n}\n\ninterface IAnycallProxy {\n    function executor() external view returns (address);\n\n    function config() external view returns (address);\n\n    function anyCall(\n        address _to,\n        bytes calldata _data,\n        uint256 _toChainID,\n        uint256 _flags,\n        bytes calldata _extdata\n    ) external payable;\n\n    function anyCall(\n        string calldata _to,\n        bytes calldata _data,\n        uint256 _toChainID,\n        uint256 _flags,\n        bytes calldata _extdata\n    ) external payable;\n}\n\ncontract WETH9 {\n    string public name = \"Wrapped Ether\";\n    string public symbol = \"WETH\";\n    uint8 public decimals = 18;\n\n    event Approval(address indexed src, address indexed guy, uint256 wad);\n    event Transfer(address indexed src, address indexed dst, uint256 wad);\n    event Deposit(address indexed dst, uint256 wad);\n    event Withdrawal(address indexed src, uint256 wad);\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    // function receive() external payable {\n    //   deposit();\n    // }\n\n    function deposit() public payable {\n        balanceOf[msg.sender] += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 wad) public {\n        require(balanceOf[msg.sender] >= wad);\n        balanceOf[msg.sender] -= wad;\n        payable(msg.sender).transfer(wad);\n        emit Withdrawal(msg.sender, wad);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function approve(address guy, uint256 wad) public returns (bool) {\n        allowance[msg.sender][guy] = wad;\n        emit Approval(msg.sender, guy, wad);\n        return true;\n    }\n\n    function transfer(address dst, uint256 wad) public returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) public returns (bool) {\n        require(balanceOf[src] >= wad);\n\n        if (src != msg.sender && allowance[src][msg.sender] != 255) {\n            require(allowance[src][msg.sender] >= wad);\n            allowance[src][msg.sender] -= wad;\n        }\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n}\n\ncontract AnycallExecutor {\n    struct Context {\n        address from;\n        uint256 fromChainID;\n        uint256 nonce;\n    }\n    // Context public override context;\n    Context public context;\n\n    constructor() {\n        context.fromChainID = 1;\n        context.from = address(2);\n        context.nonce = 1;\n    }\n}\n\ncontract AnycallV7Config {\n    event Deposit(address indexed account, uint256 amount);\n\n    mapping(address => uint256) public executionBudget;\n\n    /// @notice Deposit native currency crediting `_account` for execution costs on this chain\n    /// @param _account The account to deposit and credit for\n    function deposit(address _account) external payable {\n        executionBudget[_account] += msg.value;\n        emit Deposit(_account, msg.value);\n    }\n}\n\ncontract BranchBridgeAgent {\n    error AnycallUnauthorizedCaller();\n    error GasErrorOrRepeatedTx();\n\n    uint256 public remoteCallDepositedGas;\n\n    uint256 internal constant MIN_EXECUTION_OVERHEAD = 160_000; // 100_000 for anycall + 35_000 Pre 1st Gas Checkpoint Execution + 25_000 Post last Gas Checkpoint Executions\n    uint256 internal constant TRANSFER_OVERHEAD = 24_000;\n\n    WETH9 public immutable wrappedNativeToken;\n\n    AnycallV7Config public anycallV7Config;\n\n    uint256 public accumulatedFees;\n\n    /// @notice Local Chain Id\n    uint24 public immutable localChainId;\n\n    /// @notice Address for Bridge Agent who processes requests submitted for the Root Router Address where cross-chain requests are executed in the Root Chain.\n    address public immutable rootBridgeAgentAddress;\n    /// @notice Local Anyexec Address\n    address public immutable local`AnyCall`ExecutorAddress;\n\n    /// @notice Address for Local AnycallV7 Proxy Address where cross-chain requests are sent to the Root Chain Router.\n    address public immutable local`AnyCall`Address;\n\n    constructor() {\n        AnycallExecutor anycallExecutor = new AnycallExecutor();\n        local`AnyCall`ExecutorAddress = address(anycallExecutor);\n\n        localChainId = 1;\n\n        wrappedNativeToken = new WETH9();\n\n        local`AnyCall`Address = address(3);\n\n        rootBridgeAgentAddress = address(2);\n\n        anycallV7Config = new AnycallV7Config();\n    }\n\n    modifier requiresExecutor() {\n        _requiresExecutor();\n        _;\n    }\n\n    function _requiresExecutor() internal view {\n        if (msg.sender != local`AnyCall`ExecutorAddress)\n            revert AnycallUnauthorizedCaller();\n        (address from, , ) = IAnycallExecutor(local`AnyCall`ExecutorAddress)\n            .context();\n        if (from != rootBridgeAgentAddress) revert AnycallUnauthorizedCaller();\n    }\n\n    function _replenishGas(uint256 _executionGasSpent) internal virtual {\n        //Deposit Gas\n        anycallV7Config.deposit{value: _executionGasSpent}(address(this));\n        // IAnycallConfig(IAnycallProxy(local`AnyCall`Address).config()).deposit{value: _executionGasSpent}(address(this));\n    }\n\n    function _forceRevert() internal virtual {\n        IAnycallConfig anycallConfig = IAnycallConfig(\n            IAnycallProxy(local`AnyCall`Address).config()\n        );\n\n        // uint256 executionBudget = anycallConfig.executionBudget(address(this));\n        uint256 executionBudget = anycallV7Config.executionBudget(\n            address(this)\n        );\n\n        // Withdraw all execution gas budget from anycall for tx to revert with \"no enough budget\"\n        if (executionBudget > 0)\n            try anycallConfig.withdraw(executionBudget) {} catch {}\n    }\n\n    /**\n     * @notice Internal function repays gas used by Branch Bridge Agent to fulfill remote initiated interaction.\n     - @param _recipient address to send excess gas to.\n     - @param _initialGas gas used by Branch Bridge Agent.\n     */\n    function _payExecutionGas(\n        address _recipient,\n        uint256 _initialGas\n    ) internal virtual {\n        //Gas remaining\n        uint256 gasRemaining = wrappedNativeToken.balanceOf(address(this));\n\n        //Unwrap Gas\n        wrappedNativeToken.withdraw(gasRemaining);\n\n        //Delete Remote Initiated Action State\n        delete (remoteCallDepositedGas);\n\n        ///Save gas left\n        uint256 gasLeft = gasleft();\n\n        //Get Branch Environment Execution Cost\n        // Assume tx.gasPrice 1e9\n        uint256 minExecCost = 1e9 *\n            (MIN_EXECUTION_OVERHEAD + _initialGas - gasLeft);\n\n        //Check if sufficient balance\n        if (minExecCost > gasRemaining) {\n            _forceRevert();\n            return;\n        }\n\n        //Replenish Gas\n        _replenishGas(minExecCost);\n\n        //Transfer gas remaining to recipient\n        SafeTransferLib.safeTransferETH(_recipient, gasRemaining - minExecCost);\n\n        //Save Gas\n        uint256 gasAfterTransfer = gasleft();\n\n        //Check if sufficient balance // This condition is always true\n        if (gasLeft - gasAfterTransfer > TRANSFER_OVERHEAD) {\n            console.log(\n                \"(gasLeft - gasAfterTransfer > TRANSFER_OVERHEAD) => true\"\n            );\n            console.log(\n                \"gasLeft - gasAfterTransfer = %d - %d = %d\",\n                gasLeft,\n                gasAfterTransfer,\n                gasLeft - gasAfterTransfer\n            );\n            _forceRevert();\n            return;\n        }\n    }\n\n    function anyExecute(\n        bytes memory data\n    )\n        public\n        virtual\n        requiresExecutor\n        returns (bool success, bytes memory result)\n    {\n        //Get Initial Gas Checkpoint\n        uint256 initialGas = gasleft();\n\n        //Action Recipient\n        address recipient = address(0x0); // for simplicity and since it is irrelevant //address(uint160(bytes20(data[PARAMS_START:PARAMS_START_SIGNED])));\n\n        // Other Code Here\n\n        //Deduct gas costs from deposit and replenish this bridge agent's execution budget.\n        _payExecutionGas(recipient, initialGas);\n    }\n\n    function depositIntoWeth(uint256 amt) external {\n        wrappedNativeToken.deposit{value: amt}();\n    }\n\n    fallback() external payable {}\n}\n\ncontract GasCalcTransferOverHead is DSTest, Test {\n    BranchBridgeAgent branchBridgeAgent;\n\n    function setUp() public {\n        branchBridgeAgent = new BranchBridgeAgent();\n        vm.deal(\n            address(branchBridgeAgent.local`AnyCall`ExecutorAddress()),\n            100 ether\n        ); // executer pays gas\n        vm.deal(address(branchBridgeAgent), 100 ether);\n    }\n\n    function test_anyexecute_always_revert_bc_transfer_overhead() public {\n        // add weth balance\n        branchBridgeAgent.depositIntoWeth(100 ether);\n        vm.prank(address(branchBridgeAgent.local`AnyCall`ExecutorAddress()));\n        vm.expectRevert();\n        branchBridgeAgent.anyExecute{gas: 1 ether}(bytes(\"\"));\n        vm.stopPrank();\n    }\n}\n\n```\n\n</details>\n\n### Recommended Mitigation Steps\n\nIncrease the `TRANSFER_OVERHEAD` to cover the actual gas spent. You could also add a gas checkpoint immediately before the transfer to make the naming makes sense (i.e. `TRANSFER_OVERHEAD`). However, the gas will be nearly `34_378`, which is still higher than `TRANSFER_OVERHEAD` (`24_000`).\n\nYou can simply comment out the code after `gasLeft` till the transfer, by removing `_minExecCost` from the value to transfer since it is commented out. Now, when you run the test again, you will see an output like this (with a failed test but we are not interested in it anyway):\n\n```solidity\n[FAIL. Reason: Call did not revert as expected] test_anyexecute_always_revert_bc_transfer_overhead() (gas: 111185)\nLogs:\n  (gasLeft - gasAfterTransfer > TRANSFER_OVERHEAD) => true\n  gasLeft - gasAfterTransfer = 999999999999979606 - 999999999999945228 = 34378\n\nTest result: FAILED. 0 passed; 1 failed; finished in 1.26ms\n```\n\n**`gasLeft` - `gasAfterTransfer` = 34378**\n\nPlease note that I have tested a simple function in Remix as well and it gave the same gas spent (i.e. 34378):\n\n    // copy the library code from Solady and paste it here\n    // https://github.com/Vectorized/solady/blob/main/src/utils/SafeTransferLib.sol\n\n\n    contract Test {\n\n           function testGas() payable public returns (uint256){\n            ///Save gas left\n            uint256 gasLeft = gasleft();\n\n            //Transfer gas remaining to recipient\n            SafeTransferLib.safeTransferETH(address(0), 1 ether);\n\n            //Save Gas\n            uint256 gasAfterTransfer = gasleft();\n\n            return gasLeft-gasAfterTransfer;\n\n           }\n\n    }\n\nThe returned value will be 34378.\n\n**[0xBugsy (Maia) confirmed and commented](https://github.com/code-423n4/2023-05-maia-findings/issues/610#issuecomment-1655675877):**\n > We recognize the audit's findings on Anycall Gas Management. These will not be rectified due to the upcoming migration of this section to LayerZero.\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/ulysses-omnichain/BranchBridgeAgent.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {WETH9} from \"./interfaces/IWETH9.sol\";\n\nimport {AnycallFlags} from \"./lib/AnycallFlags.sol\";\nimport {IAnycallProxy} from \"./interfaces/IAnycallProxy.sol\";\nimport {IAnycallConfig} from \"./interfaces/IAnycallConfig.sol\";\nimport {IAnycallExecutor} from \"./interfaces/IAnycallExecutor.sol\";\nimport {IApp, IBranchBridgeAgent} from \"./interfaces/IBranchBridgeAgent.sol\";\nimport {IBranchRouter as IRouter} from \"./interfaces/IBranchRouter.sol\";\nimport {IBranchPort as IPort} from \"./interfaces/IBranchPort.sol\";\n\nimport {ERC20hTokenBranch as ERC20hToken} from \"./token/ERC20hTokenBranch.sol\";\nimport {BranchBridgeAgentExecutor, DeployBranchBridgeAgentExecutor} from \"./BranchBridgeAgentExecutor.sol\";\nimport {\n    Deposit,\n    DepositStatus,\n    DepositInput,\n    DepositMultipleInput,\n    DepositParams,\n    DepositMultipleParams,\n    SettlementParams,\n    SettlementMultipleParams\n} from \"./interfaces/IBranchBridgeAgent.sol\";\n\n/// @title Library for Branch Bridge Agent Deployment\nlibrary DeployBranchBridgeAgent {\n    function deploy(\n        WETH9 _wrappedNativeToken,\n        uint256 _rootChainId,\n        uint256 _localChainId,\n        address _rootBridgeAgentAddress,\n        address _localAnyCallAddress,\n        address _localAnyCallExecutorAddress,\n        address _localRouterAddress,\n        address _localPortAddress\n    ) external returns (BranchBridgeAgent) {\n        return new BranchBridgeAgent(\n            _wrappedNativeToken,\n            _rootChainId,\n            _localChainId,\n            _rootBridgeAgentAddress,\n            _localAnyCallAddress,\n            _localAnyCallExecutorAddress,\n            _localRouterAddress,\n            _localPortAddress\n        );\n    }\n}\n\n/// @title Branch Bridge Agent Contract\ncontract BranchBridgeAgent is IBranchBridgeAgent {\n    using SafeTransferLib for address;\n    using SafeCastLib for uint256;\n\n    /*///////////////////////////////////////////////////////////////\n                            ENCODING CONSTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// AnyExec Decode Consts\n\n    uint8 internal constant PARAMS_START = 1;\n\n    uint8 internal constant PARAMS_START_SIGNED = 21;\n\n    uint8 internal constant PARAMS_ENTRY_SIZE = 32;\n\n    uint8 internal constant PARAMS_GAS_OUT = 16;\n\n    /// ClearTokens Decode Consts\n\n    uint8 internal constant PARAMS_TKN_START = 5;\n\n    uint8 internal constant PARAMS_AMT_OFFSET = 64;\n\n    uint8 internal constant PARAMS_DEPOSIT_OFFSET = 96;\n\n    /*///////////////////////////////////////////////////////////////\n                        BRIDGE AGENT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Chain Id for Root Chain where liqudity is virtualized(e.g. 4).\n    uint256 public immutable rootChainId;\n\n    /// @notice Chain Id for Local Chain.\n    uint256 public immutable localChainId;\n\n    /// @notice Address for Local Wrapped Native Token.\n    WETH9 public immutable wrappedNativeToken;\n\n    /// @notice Address for Bridge Agent who processes requests submitted for the Root Router Address where cross-chain requests are executed in the Root Chain.\n    address public immutable rootBridgeAgentAddress;\n\n    /// @notice Address for Local AnycallV7 Proxy Address where cross-chain requests are sent to the Root Chain Router.\n    address public immutable localAnyCallAddress;\n\n    /// @notice Address for Local Anyexec Address where cross-chain requests from the Root Chain Router are received locally.\n    address public immutable localAnyCallExecutorAddress;\n\n    /// @notice Address for Local Router used for custom actions for different hApps.\n    address public immutable localRouterAddress;\n\n    /// @notice Address for Local Port Address where funds deposited from this chain are kept, managed and supplied to different Port Strategies.\n    address public immutable localPortAddress;\n\n    address public bridgeAgentExecutorAddress;\n\n    /*///////////////////////////////////////////////////////////////\n                        DEPOSITS STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Deposit nonce used for identifying transaction.\n    uint32 public depositNonce;\n\n    /// @notice Mapping from Pending deposits hash to Deposit Struct.\n    mapping(uint32 => Deposit) public getDeposit;\n\n    /*///////////////////////////////////////////////////////////////\n                            EXECUTOR STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice If true, bridge agent has already served a request with this nonce from  a given chain. Chain -> Nonce -> Bool\n    mapping(uint32 => bool) public executionHistory;\n\n    /*///////////////////////////////////////////////////////////////\n                        GAS MANAGEMENT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public remoteCallDepositedGas;\n\n    uint256 internal constant MIN_FALLBACK_RESERVE = 185_000; // 100_000 for anycall + 85_000 fallback execution overhead\n    uint256 internal constant MIN_EXECUTION_OVERHEAD = 160_000; // 100_000 for anycall + 35_000 Pre 1st Gas Checkpoint Execution + 25_000 Post last Gas Checkpoint Executions\n    uint256 internal constant TRANSFER_OVERHEAD = 24_000;\n\n    constructor(\n        WETH9 _wrappedNativeToken,\n        uint256 _rootChainId,\n        uint256 _localChainId,\n        address _rootBridgeAgentAddress,\n        address _localAnyCallAddress,\n        address _localAnyCallExecutorAddress,\n        address _localRouterAddress,\n        address _localPortAddress\n    ) {\n        require(_rootBridgeAgentAddress != address(0), \"Root Bridge Agent Address cannot be the zero address.\");\n        require(_localAnyCallAddress != address(0), \"AnyCall Address cannot be the zero address.\");\n        require(_localAnyCallExecutorAddress != address(0), \"AnyCall Executor Address cannot be the zero address.\");\n        require(_localRouterAddress != address(0), \"Local Router Address cannot be the zero address.\");\n        require(_localPortAddress != address(0), \"Local Port Address cannot be the zero address.\");\n\n        wrappedNativeToken = _wrappedNativeToken;\n        localChainId = _localChainId;\n        rootChainId = _rootChainId;\n        rootBridgeAgentAddress = _rootBridgeAgentAddress;\n        localAnyCallAddress = _localAnyCallAddress;\n        localAnyCallExecutorAddress = _localAnyCallExecutorAddress;\n        localRouterAddress = _localRouterAddress;\n        localPortAddress = _localPortAddress;\n        bridgeAgentExecutorAddress = DeployBranchBridgeAgentExecutor.deploy();\n        depositNonce = 1;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchBridgeAgent\n    function getDepositEntry(uint32 _depositNonce) external view returns (Deposit memory) {\n        return getDeposit[_depositNonce];\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        USER EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOut(bytes calldata _params, uint128 _remoteExecutionGas) external payable lock requiresFallbackGas {\n        //Wrap the gas allocated for omnichain execution.\n        wrappedNativeToken.deposit{value: msg.value}();\n\n        //Perform Call without deposit\n        _callOut(msg.sender, _params, msg.value.toUint128(), _remoteExecutionGas);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOutAndBridge(bytes calldata _params, DepositInput memory _dParams, uint128 _remoteExecutionGas)\n        external\n        payable\n        lock\n        requiresFallbackGas\n    {\n        //Wrap the gas allocated for omnichain execution.\n        wrappedNativeToken.deposit{value: msg.value}();\n\n        //Perform Call with deposit\n        _callOutAndBridge(msg.sender, _params, _dParams, msg.value.toUint128(), _remoteExecutionGas);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOutAndBridgeMultiple(\n        bytes calldata _params,\n        DepositMultipleInput memory _dParams,\n        uint128 _remoteExecutionGas\n    ) external payable lock requiresFallbackGas {\n        //Wrap the gas allocated for omnichain execution.\n        wrappedNativeToken.deposit{value: msg.value}();\n\n        //Perform Call with multiple deposits\n        _callOutAndBridgeMultiple(msg.sender, _params, _dParams, msg.value.toUint128(), _remoteExecutionGas);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOutSigned(bytes calldata _params, uint128 _remoteExecutionGas)\n        external\n        payable\n        lock\n        requiresFallbackGas\n    {\n        //Encode Data for cross-chain call.\n        bytes memory packedData = abi.encodePacked(\n            bytes1(0x04), msg.sender, depositNonce, _params, msg.value.toUint128(), _remoteExecutionGas\n        );\n\n        //Wrap the gas allocated for omnichain execution.\n        wrappedNativeToken.deposit{value: msg.value}();\n\n        //Perform Signed Call without deposit\n        _noDepositCall(msg.sender, packedData, msg.value.toUint128());\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOutSignedAndBridge(bytes calldata _params, DepositInput memory _dParams, uint128 _remoteExecutionGas)\n        external\n        payable\n        lock\n        requiresFallbackGas\n    {\n        //Encode Data for cross-chain call.\n        bytes memory packedData = abi.encodePacked(\n            bytes1(0x05),\n            msg.sender,\n            depositNonce,\n            _dParams.hToken,\n            _dParams.token,\n            _dParams.amount,\n            _normalizeDecimals(_dParams.deposit, ERC20(_dParams.token).decimals()),\n            _dParams.toChain,\n            _params,\n            msg.value.toUint128(),\n            _remoteExecutionGas\n        );\n\n        //Wrap the gas allocated for omnichain execution.\n        wrappedNativeToken.deposit{value: msg.value}();\n\n        //Create Deposit and Send Cross-Chain request\n        _depositAndCall(\n            msg.sender,\n            packedData,\n            _dParams.hToken,\n            _dParams.token,\n            _dParams.amount,\n            _dParams.deposit,\n            msg.value.toUint128()\n        );\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function callOutSignedAndBridgeMultiple(\n        bytes calldata _params,\n        DepositMultipleInput memory _dParams,\n        uint128 _remoteExecutionGas\n    ) external payable lock requiresFallbackGas {\n        //Normalize Deposits\n        uint256[] memory _deposits = new uint256[](_dParams.hTokens.length);\n\n        for (uint256 i = 0; i < _dParams.hTokens.length; i++) {\n            _deposits[i] = _normalizeDecimals(_dParams.deposits[i], ERC20(_dParams.tokens[i]).decimals());\n        }\n\n        //Encode Data for cross-chain call.\n        bytes memory packedData = abi.encodePacked(\n            bytes1(0x06),\n            msg.sender,\n            uint8(_dParams.hTokens.length),\n            depositNonce,\n            _dParams.hTokens,\n            _dParams.tokens,\n            _dParams.amounts,\n            _deposits,\n            _dParams.toChain,\n            _params,\n            msg.value.toUint128(),\n            _remoteExecutionGas\n        );\n\n        //Wrap the gas allocated for omnichain execution.\n        wrappedNativeToken.deposit{value: msg.value}();\n\n        //Create Deposit and Send Cross-Chain request\n        _depositAndCallMultiple(\n            msg.sender,\n            packedData,\n            _dParams.hTokens,\n            _dParams.tokens,\n            _dParams.amounts,\n            _dParams.deposits,\n            msg.value.toUint128()\n        );\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function retryDeposit(\n        bool _isSigned,\n        uint32 _depositNonce,\n        bytes calldata _params,\n        uint128 _remoteExecutionGas,\n        uint24 _toChain\n    ) external payable lock requiresFallbackGas {\n        //Check if deposit belongs to message sender\n        if (getDeposit[_depositNonce].owner != msg.sender) revert NotDepositOwner();\n\n        //Encode Data for cross-chain call.\n        bytes memory packedData;\n\n        if (uint8(getDeposit[_depositNonce].hTokens.length) == 1) {\n            if (_isSigned) {\n                packedData = abi.encodePacked(\n                    bytes1(0x05),\n                    msg.sender,\n                    _depositNonce,\n                    getDeposit[_depositNonce].hTokens[0],\n                    getDeposit[_depositNonce].tokens[0],\n                    getDeposit[_depositNonce].amounts[0],\n                    _normalizeDecimals(\n                        getDeposit[_depositNonce].deposits[0], ERC20(getDeposit[_depositNonce].tokens[0]).decimals()\n                    ),\n                    _toChain,\n                    _params,\n                    msg.value.toUint128(),\n                    _remoteExecutionGas\n                );\n            } else {\n                packedData = abi.encodePacked(\n                    bytes1(0x02),\n                    _depositNonce,\n                    getDeposit[_depositNonce].hTokens[0],\n                    getDeposit[_depositNonce].tokens[0],\n                    getDeposit[_depositNonce].amounts[0],\n                    _normalizeDecimals(\n                        getDeposit[_depositNonce].deposits[0], ERC20(getDeposit[_depositNonce].tokens[0]).decimals()\n                    ),\n                    _toChain,\n                    _params,\n                    msg.value.toUint128(),\n                    _remoteExecutionGas\n                );\n            }\n        } else if (uint8(getDeposit[_depositNonce].hTokens.length) > 1) {\n            //Nonce\n            uint32 nonce = _depositNonce;\n\n            if (_isSigned) {\n                packedData = abi.encodePacked(\n                    bytes1(0x06),\n                    msg.sender,\n                    uint8(getDeposit[_depositNonce].hTokens.length),\n                    nonce,\n                    getDeposit[nonce].hTokens,\n                    getDeposit[nonce].tokens,\n                    getDeposit[nonce].amounts,\n                    _normalizeDecimalsMultiple(getDeposit[nonce].deposits, getDeposit[nonce].tokens),\n                    _toChain,\n                    _params,\n                    msg.value.toUint128(),\n                    _remoteExecutionGas\n                );\n            } else {\n                packedData = abi.encodePacked(\n                    bytes1(0x03),\n                    uint8(getDeposit[nonce].hTokens.length),\n                    _depositNonce,\n                    getDeposit[nonce].hTokens,\n                    getDeposit[nonce].tokens,\n                    getDeposit[nonce].amounts,\n                    _normalizeDecimalsMultiple(getDeposit[nonce].deposits, getDeposit[nonce].tokens),\n                    _toChain,\n                    _params,\n                    msg.value.toUint128(),\n                    _remoteExecutionGas\n                );\n            }\n        }\n\n        //Wrap the gas allocated for omnichain execution.\n        wrappedNativeToken.deposit{value: msg.value}();\n\n        //Deposit Gas to Port\n        _depositGas(msg.value.toUint128());\n\n        //Ensure success Status\n        getDeposit[_depositNonce].status = DepositStatus.Success;\n\n        //Update Deposited Gas\n        getDeposit[_depositNonce].depositedGas = msg.value.toUint128();\n\n        //Perform Call\n        _performCall(packedData);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function retrySettlement(uint32 _settlementNonce, uint128 _gasToBoostSettlement)\n        external\n        payable\n        lock\n        requiresFallbackGas\n    {\n        //Encode Data for cross-chain call.\n        bytes memory packedData = abi.encodePacked(\n            bytes1(0x07), depositNonce++, _settlementNonce, msg.value.toUint128(), _gasToBoostSettlement\n        );\n        //Update State and Perform Call\n        _sendRetrieveOrRetry(packedData);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function retrieveDeposit(uint32 _depositNonce) external payable lock requiresFallbackGas {\n        //Encode Data for cross-chain call.\n        bytes memory packedData = abi.encodePacked(bytes1(0x08), _depositNonce, msg.value.toUint128(), uint128(0));\n\n        //Update State and Perform Call\n        _sendRetrieveOrRetry(packedData);\n    }\n\n    function _sendRetrieveOrRetry(bytes memory _data) internal {\n        //Deposit Gas for call.\n        _createGasDeposit(msg.sender, msg.value.toUint128());\n\n        //Perform Call\n        _performCall(_data);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function redeemDeposit(uint32 _depositNonce) external lock {\n        //Update Deposit\n        if (getDeposit[_depositNonce].status != DepositStatus.Failed) {\n            revert DepositRedeemUnavailable();\n        }\n        _redeemDeposit(_depositNonce);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    BRANCH ROUTER EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchBridgeAgent\n    function performSystemCallOut(\n        address _depositor,\n        bytes calldata _params,\n        uint128 _gasToBridgeOut,\n        uint128 _remoteExecutionGas\n    ) external payable lock requiresRouter {\n        //Get remote call execution deposited gas.\n        (uint128 gasToBridgeOut, bool isRemote) =\n            (remoteCallDepositedGas > 0 ? (_gasToBridgeOut, true) : (msg.value.toUint128(), false));\n\n        //Wrap the gas allocated for omnichain execution.\n        if (!isRemote && gasToBridgeOut > 0) wrappedNativeToken.deposit{value: msg.value}();\n\n        //Check Fallback Gas\n        _requiresFallbackGas(gasToBridgeOut);\n\n        //Encode Data for cross-chain call.\n        bytes memory packedData =\n            abi.encodePacked(bytes1(0x00), depositNonce, _params, gasToBridgeOut, _remoteExecutionGas);\n\n        //Perform Call\n        _noDepositCall(_depositor, packedData, gasToBridgeOut);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function performCallOut(\n        address _depositor,\n        bytes calldata _params,\n        uint128 _gasToBridgeOut,\n        uint128 _remoteExecutionGas\n    ) external payable lock requiresRouter {\n        //Get remote call execution deposited gas.\n        (uint128 gasToBridgeOut, bool isRemote) =\n            (remoteCallDepositedGas > 0 ? (_gasToBridgeOut, true) : (msg.value.toUint128(), false));\n\n        //Wrap the gas allocated for omnichain execution.\n        if (!isRemote && gasToBridgeOut > 0) wrappedNativeToken.deposit{value: msg.value}();\n\n        //Check Fallback Gas\n        _requiresFallbackGas(gasToBridgeOut);\n\n        //Perform Call\n        _callOut(_depositor, _params, gasToBridgeOut, _remoteExecutionGas);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function performCallOutAndBridge(\n        address _depositor,\n        bytes calldata _params,\n        DepositInput memory _dParams,\n        uint128 _gasToBridgeOut,\n        uint128 _remoteExecutionGas\n    ) external payable lock requiresRouter {\n        //Get remote call execution deposited gas.\n        (uint128 gasToBridgeOut, bool isRemote) =\n            (remoteCallDepositedGas > 0 ? (_gasToBridgeOut, true) : (msg.value.toUint128(), false));\n\n        //Wrap the gas allocated for omnichain execution.\n        if (!isRemote && gasToBridgeOut > 0) wrappedNativeToken.deposit{value: msg.value}();\n\n        //Check Fallback Gas\n        _requiresFallbackGas(gasToBridgeOut);\n\n        //Perform Call\n        _callOutAndBridge(_depositor, _params, _dParams, gasToBridgeOut, _remoteExecutionGas);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function performCallOutAndBridgeMultiple(\n        address _depositor,\n        bytes calldata _params,\n        DepositMultipleInput memory _dParams,\n        uint128 _gasToBridgeOut,\n        uint128 _remoteExecutionGas\n    ) external payable lock requiresRouter {\n        //Get remote call execution deposited gas.\n        (uint128 gasToBridgeOut, bool isRemote) =\n            (remoteCallDepositedGas > 0 ? (_gasToBridgeOut, true) : (msg.value.toUint128(), false));\n\n        //Wrap the gas allocated for omnichain execution.\n        if (!isRemote && gasToBridgeOut > 0) wrappedNativeToken.deposit{value: msg.value}();\n\n        //Check Fallback Gas\n        _requiresFallbackGas(gasToBridgeOut);\n\n        //Perform Call\n        _callOutAndBridgeMultiple(_depositor, _params, _dParams, gasToBridgeOut, _remoteExecutionGas);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                TOKEN MANAGEMENT EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchBridgeAgent\n    function clearToken(address _recipient, address _hToken, address _token, uint256 _amount, uint256 _deposit)\n        external\n        requiresAgentExecutor\n    {\n        _clearToken(_recipient, _hToken, _token, _amount, _deposit);\n    }\n\n    /// @inheritdoc IBranchBridgeAgent\n    function clearTokens(bytes calldata _sParams, address _recipient)\n        external\n        requiresAgentExecutor\n        returns (SettlementMultipleParams memory)\n    {\n        //Parse Params\n        uint8 numOfAssets = uint8(bytes1(_sParams[0]));\n        uint32 nonce = uint32(bytes4(_sParams[PARAMS_START:PARAMS_TKN_START]));\n\n        address[] memory _hTokens = new address[](numOfAssets);\n        address[] memory _tokens = new address[](numOfAssets);\n        uint256[] memory _amounts = new uint256[](numOfAssets);\n        uint256[] memory _deposits = new uint256[](numOfAssets);\n\n        //Transfer token to recipient\n        for (uint256 i = 0; i < numOfAssets;) {\n            //Parse Params\n            _hTokens[i] = address(\n                uint160(\n                    bytes20(\n                        bytes32(\n                            _sParams[\n                                PARAMS_TKN_START + (PARAMS_ENTRY_SIZE * i) + 12:\n                                    PARAMS_TKN_START + (PARAMS_ENTRY_SIZE * (PARAMS_START + i))\n                            ]\n                        )\n                    )\n                )\n            );\n            _tokens[i] = address(\n                uint160(\n                    bytes20(\n                        _sParams[\n                            PARAMS_TKN_START + PARAMS_ENTRY_SIZE * uint16(i + numOfAssets) + 12:\n                                PARAMS_TKN_START + PARAMS_ENTRY_SIZE * uint16(PARAMS_START + i + numOfAssets)\n                        ]\n                    )\n                )\n            );\n            _amounts[i] = uint256(\n                bytes32(\n                    _sParams[\n                        PARAMS_TKN_START + PARAMS_AMT_OFFSET * uint16(numOfAssets) + (PARAMS_ENTRY_SIZE * uint16(i)):\n                            PARAMS_TKN_START + PARAMS_AMT_OFFSET * uint16(numOfAssets)\n                                + PARAMS_ENTRY_SIZE * uint16(PARAMS_START + i)\n                    ]\n                )\n            );\n            _deposits[i] = uint256(\n                bytes32(\n                    _sParams[\n                        PARAMS_TKN_START + PARAMS_DEPOSIT_OFFSET * uint16(numOfAssets) + (PARAMS_ENTRY_SIZE * uint16(i)):\n                            PARAMS_TKN_START + PARAMS_DEPOSIT_OFFSET * uint16(numOfAssets)\n                                + PARAMS_ENTRY_SIZE * uint16(PARAMS_START + i)\n                    ]\n                )\n            );\n            //Clear Tokens to destination\n            if (_amounts[i] - _deposits[i] > 0) {\n                IPort(localPortAddress).bridgeIn(_recipient, _hTokens[i], _amounts[i] - _deposits[i]);\n            }\n\n            if (_deposits[i] > 0) {\n                IPort(localPortAddress).withdraw(_recipient, _tokens[i], _deposits[i]);\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return SettlementMultipleParams(numOfAssets, _recipient, nonce, _hTokens, _tokens, _amounts, _deposits);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                LOCAL USER DEPOSIT INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Function to perform a call to the Root Omnichain Router without token deposit.\n     *   @param _depositor address of the user that will deposit the funds.\n     *   @param _params RLP enconded parameters to execute on the root chain.\n     *   @param _gasToBridgeOut gas allocated for the cross-chain call.\n     *   @param _remoteExecutionGas gas allocated for branch chain execution.\n     *   @dev ACTION ID: 1 (Call without deposit)\n     *\n     */\n    function _callOut(address _depositor, bytes calldata _params, uint128 _gasToBridgeOut, uint128 _remoteExecutionGas)\n        internal\n    {\n        //Encode Data for cross-chain call.\n        bytes memory packedData =\n            abi.encodePacked(bytes1(0x01), depositNonce, _params, _gasToBridgeOut, _remoteExecutionGas);\n\n        //Perform Call\n        _noDepositCall(_depositor, packedData, _gasToBridgeOut);\n    }\n\n    /**\n     * @notice Function to perform a call to the Root Omnichain Router while depositing a single asset.\n     *   @param _depositor address of the user that will deposit the funds.\n     *   @param _params RLP enconded parameters to execute on the root chain.\n     *   @param _dParams additional token deposit parameters.\n     *   @param _gasToBridgeOut gas allocated for the cross-chain call.\n     *   @param _remoteExecutionGas gas allocated for branch chain execution.\n     *   @dev ACTION ID: 2 (Call with single deposit)\n     *\n     */\n    function _callOutAndBridge(\n        address _depositor,\n        bytes calldata _params,\n        DepositInput memory _dParams,\n        uint128 _gasToBridgeOut,\n        uint128 _remoteExecutionGas\n    ) internal {\n        //Encode Data for cross-chain call.\n        bytes memory packedData = abi.encodePacked(\n            bytes1(0x02),\n            depositNonce,\n            _dParams.hToken,\n            _dParams.token,\n            _dParams.amount,\n            _normalizeDecimals(_dParams.deposit, ERC20(_dParams.token).decimals()),\n            _dParams.toChain,\n            _params,\n            _gasToBridgeOut,\n            _remoteExecutionGas\n        );\n\n        //Create Deposit and Send Cross-Chain request\n        _depositAndCall(\n            _depositor, packedData, _dParams.hToken, _dParams.token, _dParams.amount, _dParams.deposit, _gasToBridgeOut\n        );\n    }\n\n    /**\n     * @notice Function to perform a call to the Root Omnichain Router while depositing two or more assets.\n     *   @param _params RLP enconded parameters to execute on the root chain.\n     *   @param _dParams additional token deposit parameters.\n     *   @param _gasToBridgeOut gas allocated for the cross-chain call.\n     *   @param _remoteExecutionGas gas allocated for branch chain execution.\n     *   @dev ACTION ID: 3 (Call with multiple deposit)\n     *\n     */\n    function _callOutAndBridgeMultiple(\n        address _depositor,\n        bytes calldata _params,\n        DepositMultipleInput memory _dParams,\n        uint128 _gasToBridgeOut,\n        uint128 _remoteExecutionGas\n    ) internal {\n        //Normalize Deposits\n        uint256[] memory deposits = new uint256[](_dParams.hTokens.length);\n\n        for (uint256 i = 0; i < _dParams.hTokens.length; i++) {\n            deposits[i] = _normalizeDecimals(_dParams.deposits[i], ERC20(_dParams.tokens[i]).decimals());\n        }\n\n        //Encode Data for cross-chain call.\n        bytes memory packedData = abi.encodePacked(\n            bytes1(0x03),\n            uint8(_dParams.hTokens.length),\n            depositNonce,\n            _dParams.hTokens,\n            _dParams.tokens,\n            _dParams.amounts,\n            deposits,\n            _dParams.toChain,\n            _params,\n            _gasToBridgeOut,\n            _remoteExecutionGas\n        );\n\n        //Create Deposit and Send Cross-Chain request\n        _depositAndCallMultiple(\n            _depositor,\n            packedData,\n            _dParams.hTokens,\n            _dParams.tokens,\n            _dParams.amounts,\n            _dParams.deposits,\n            _gasToBridgeOut\n        );\n    }\n\n    /**\n     * @notice Internal function to move assets from branch chain to root omnichain environment. Naive assets are deposited and hTokens are bridgedOut.\n     *   @param _depositor token depositor.\n     *   @param _data data to be sent to cross-chain messaging layer.\n     *   @param _gasToBridgeOut gas allocated for the cross-chain call.\n     *\n     */\n    function _noDepositCall(address _depositor, bytes memory _data, uint128 _gasToBridgeOut) internal {\n        //Deposit Gas for call.\n        _createGasDeposit(_depositor, _gasToBridgeOut);\n\n        //Perform Call\n        _performCall(_data);\n    }\n\n    /**\n     * @notice Internal function to move assets from branch chain to root omnichain environment. Naive assets are deposited and hTokens are bridgedOut.\n     *   @param _depositor token depositor.\n     *   @param _data data to be sent to cross-chain messaging layer.\n     *   @param _hToken Local Input hToken Address.\n     *   @param _token Native / Underlying Token Address.\n     *   @param _amount Amount of Local hTokens deposited for trade.\n     *   @param _deposit Amount of native tokens deposited for trade.\n     *   @param _gasToBridgeOut gas allocated for the cross-chain call.\n     *\n     */\n    function _depositAndCall(\n        address _depositor,\n        bytes memory _data,\n        address _hToken,\n        address _token,\n        uint256 _amount,\n        uint256 _deposit,\n        uint128 _gasToBridgeOut\n    ) internal {\n        //Deposit and Store Info\n        _createDepositSingle(_depositor, _hToken, _token, _amount, _deposit, _gasToBridgeOut);\n\n        //Perform Call\n        _performCall(_data);\n    }\n\n    /**\n     * @dev Internal function to move assets from branch chain to root omnichain environment. Naive assets are deposited and hTokens are bridgedOut.\n     *   @param _depositor token depositor.\n     *   @param _data data to be sent to cross-chain messaging layer.\n     *   @param _hTokens Local Input hToken Address.\n     *   @param _tokens Native / Underlying Token Address.\n     *   @param _amounts Amount of Local hTokens deposited for trade.\n     *   @param _deposits  Amount of native tokens deposited for trade.\n     *   @param _gasToBridgeOut gas allocated for the cross-chain call.\n     *\n     */\n    function _depositAndCallMultiple(\n        address _depositor,\n        bytes memory _data,\n        address[] memory _hTokens,\n        address[] memory _tokens,\n        uint256[] memory _amounts,\n        uint256[] memory _deposits,\n        uint128 _gasToBridgeOut\n    ) internal {\n        //Validate Input\n        if (\n            _hTokens.length != _tokens.length || _tokens.length != _amounts.length\n                || _amounts.length != _deposits.length\n        ) revert InvalidInput();\n\n        //Deposit and Store Info\n        _createDepositMultiple(_depositor, _hTokens, _tokens, _amounts, _deposits, _gasToBridgeOut);\n\n        //Perform Call\n        _performCall(_data);\n    }\n\n    /**\n     * @dev Function to create a pending deposit.\n     *    @param _user user address.\n     *    @param _gasToBridgeOut gas allocated for omnichain execution.\n     *\n     */\n    function _createGasDeposit(address _user, uint128 _gasToBridgeOut) internal {\n        //Deposit Gas to Port\n        _depositGas(_gasToBridgeOut);\n\n        // Update State\n        getDeposit[_getAndIncrementDepositNonce()] = Deposit({\n            owner: _user,\n            hTokens: new address[](0),\n            tokens: new address[](0),\n            amounts: new uint256[](0),\n            deposits: new uint256[](0),\n            status: DepositStatus.Success,\n            depositedGas: _gasToBridgeOut\n        });\n    }\n\n    /**\n     * @dev Function to create a pending deposit.\n     *    @param _user user address.\n     *    @param _hToken deposited local hToken addresses.\n     *    @param _token deposited native / underlying Token addresses.\n     *    @param _amount amounts of hTokens input.\n     *    @param _deposit amount of deposited underlying / native tokens.\n     *    @param _gasToBridgeOut gas allocated for omnichain execution.\n     *\n     */\n    function _createDepositSingle(\n        address _user,\n        address _hToken,"
    }
  ]
}