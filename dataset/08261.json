{
  "Title": "[H-01] `MIMOEmptyVault.sol executeOperation()` does not transfer the Vault leftover assets to the owner, it is locked in the `MIMOEmptyVault`",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-08-mimo/blob/eb1a5016b69f72bc1e4fd3600a65e908bd228f13/contracts/actions/MIMOEmptyVault.sol#L96-L100\n\n\n# Vulnerability details\n\n## Impact\nMIMOEmptyVault.sol executeAction() is supposed to pay off the debt and return the leftover assets to the owner of the Vault\nBut In fact the emptyVault contract, after executing the executionOperation(), only pays back the flash loan, and does not transfer the leftover assets to the owner, and locked in the emptyVault contract\n\n## Proof of Concept\n```\n  function executeOperation(\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata premiums,\n    address initiator,\n    bytes calldata params\n  ) external override returns (bool) {\n\n    ....\n    ....\n\n    require(flashloanRepayAmount <= vaultCollateral.balanceOf(address(this)), Errors.CANNOT_REPAY_FLASHLOAN);\n\n    vaultCollateral.safeIncreaseAllowance(address(lendingPool), flashloanRepayAmount);\n\n    //****Paid off the flash loan but did not transfer the remaining balance back to mimoProxy or owner ***//\n\n    return true;\n  }\n\n```\n\nAdd logs to test case \n\ntest/02_integration/MIMOEmtpyVault.test.ts\n\n```\n  it(\"should be able to empty vault with 1inch\", async () => {\n  ...\n  ...\n  ...\n  ++++ console.log(\"before emptyVault balance:--->\", (await wmatic.balanceOf(emptyVault.address)) + \"\");\n    const tx = await mimoProxy.execute(emptyVault.address, MIMOProxyData);\n    const receipt = await tx.wait(1);\n  ++++ console.log(\"after emptyVault balance: --->\", (await wmatic.balanceOf(emptyVault.address)) + \"\");  \n\n```\n\nprint:\n```\nbefore emptyVault balance:---> 0\nafter emptyVault balance: ---> 44383268870065355782\n\n```\n\n## Tools Used\n\n## Recommended Mitigation Steps\n\n```\n  function executeOperation(\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata premiums,\n    address initiator,\n    bytes calldata params\n  ) external override returns (bool) {\n\n    ....\n    ....\n\n    require(flashloanRepayAmount <= vaultCollateral.balanceOf(address(this)), Errors.CANNOT_REPAY_FLASHLOAN);\n\n    vaultCollateral.safeIncreaseAllowance(address(lendingPool), flashloanRepayAmount);\n\n    //****transfer the remaining balance back to mimoProxy or owner ***//\n    ++++ vaultCollateral.safeTransfer(address(mimoProxy), vaultCollateral.balanceOf(address(this)) - flashloanRepayAmount);\n\n    return true;\n  }\n\n```\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-08-mimo-august-2022-contest",
  "Code": [
    {
      "filename": "contracts/actions/MIMOEmptyVault.sol",
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.10;\n\nimport \"../core/interfaces/IVaultsCore.sol\";\nimport \"../proxy/interfaces/IMIMOProxy.sol\";\nimport \"./interfaces/IMIMOEmptyVault.sol\";\nimport \"./MIMOFlashloan.sol\";\nimport \"./MIMOSwap.sol\";\n\n/**\n  @title A SuperVault V2 action contract for repaying an existing vault's debt and withdrawing all collateral without any additional capital.\n  @notice Should only be accessed through a MIMOProxy delegateCall\n */\ncontract MIMOEmptyVault is MIMOSwap, MIMOFlashloan, IMIMOEmtpyVault {\n  using SafeERC20 for IERC20;\n\n  IMIMOProxyRegistry public immutable proxyRegistry;\n\n  /**\n    @param _a The addressProvider for the MIMO protocol\n    @param _dexAP The dexAddressProvider for the MIMO protocol\n    @param _lendingPool The AAVE lending pool used for flashloans\n    @param _proxyRegistry The MIMOProxyRegistry used to verify access control\n   */\n  constructor(\n    IAddressProvider _a,\n    IDexAddressProvider _dexAP,\n    IPool _lendingPool,\n    IMIMOProxyRegistry _proxyRegistry\n  ) MIMOFlashloan(_lendingPool) MIMOSwap(_a, _dexAP) {\n    if (address(_proxyRegistry) == address(0)) {\n      revert CustomErrors.CANNOT_SET_TO_ADDRESS_ZERO();\n    }\n    proxyRegistry = _proxyRegistry;\n  }\n\n  /**\n    @notice Uses a flashloan to repay all debts for a vault and send all collateral in the vault to the owner\n    @notice Vault must have been created though a MIMOProxy\n    @dev Should be called by MIMOProxy through a delegatecall \n    @dev Uses an AAVE V3 flashLoan that will call executeOperation\n    @param _calldata Bytes containing vaultId, FlashloanData struct, RebalanceData struct, SwapData struct\n   */\n  function executeAction(bytes calldata _calldata) external override {\n    (uint256 vaultId, FlashLoanData memory flData, SwapData memory swapData) = abi.decode(\n      _calldata,\n      (uint256, FlashLoanData, SwapData)\n    );\n    bytes memory params = abi.encode(msg.sender, vaultId, swapData);\n\n    _takeFlashLoan(flData, params);\n  }\n\n  /**\n    @notice Executes an emptyVault operation after taking a flashloan  \n    @dev Integrates with AAVE V3 flashLoans\n    @param assets Address array with one element corresponding to the address of the target vault asset\n    @param amounts Uint array with one element corresponding to the amount of the target vault asset\n    @param premiums Uint array with one element corresponding to the flashLoan fees\n    @param initiator Initiator of the flashloan; can only be MIMOProxy owner\n    @param params Bytes sent by this contract containing MIMOProxy owner, target vault id, SwapData struct\n   */\n  function executeOperation(\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata premiums,\n    address initiator,\n    bytes calldata params\n  ) external override returns (bool) {\n    (address owner, uint256 vaultId, SwapData memory swapData) = abi.decode(params, (address, uint256, SwapData));\n    IMIMOProxy mimoProxy = IMIMOProxy(proxyRegistry.getCurrentProxy(owner));\n\n    if (initiator != address(mimoProxy)) {\n      revert CustomErrors.INITIATOR_NOT_AUTHORIZED(initiator, address(mimoProxy));\n    }\n    if (msg.sender != address(lendingPool)) {\n      revert CustomErrors.CALLER_NOT_LENDING_POOL(msg.sender, address(lendingPool));\n    }\n\n    IERC20 vaultCollateral = IERC20(assets[0]);\n    uint256 amount = amounts[0];\n    vaultCollateral.safeTransfer(address(mimoProxy), amounts[0]);\n    uint256 flashloanRepayAmount = amount + premiums[0];\n\n    IMIMOProxy(mimoProxy).execute(\n      address(this),\n      abi.encodeWithSignature(\n        \"emptyVaultOperation(address,uint256,uint256,(uint256,bytes))\",\n        vaultCollateral,\n        vaultId,\n        amount,\n        swapData\n      )\n    );\n\n    require(flashloanRepayAmount <= vaultCollateral.balanceOf(address(this)), Errors.CANNOT_REPAY_FLASHLOAN);\n\n    vaultCollateral.safeIncreaseAllowance(address(lendingPool), flashloanRepayAmount);\n\n    return true;\n  }\n\n  /**\n    @notice Used by executeOperation through MIMOProxy callback to perform rebalance logic within MIMOProxy context\n    @notice There will likely be some leftover par after repaying the loan; that will also be sent back to the user\n    @param vaultCollateral Collateral of the vault to empty\n    @param vaultId vault id of the vault to be emptied\n    @param swapAmount Amount of collateral to swap to for par to repay vaultdebt\n    @param swapData SwapData passed from the flashloan call\n   */\n  function emptyVaultOperation(\n    IERC20 vaultCollateral,\n    uint256 vaultId,\n    uint256 swapAmount,\n    SwapData calldata swapData\n  ) external {\n    IVaultsCore core = a.core();\n\n    _aggregatorSwap(vaultCollateral, swapAmount, swapData);\n\n    IERC20 stablex = IERC20(a.stablex());\n    stablex.safeIncreaseAllowance(address(core), stablex.balanceOf(address(this)));\n    core.repayAll(vaultId);\n\n    uint256 withdrawAmount = a.vaultsData().vaultCollateralBalance(vaultId);\n\n    core.withdraw(vaultId, withdrawAmount);\n    vaultCollateral.safeTransfer(msg.sender, withdrawAmount);\n  }\n}"
    }
  ]
}