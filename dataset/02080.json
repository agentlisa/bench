{
  "Title": "H-14: Pool value calculation uses wrong portion of the borrowing fees",
  "Content": "# Issue H-14: Pool value calculation uses wrong portion of the borrowing fees \n\nSource: https://github.com/sherlock-audit/2023-02-gmx-judging/issues/131 \n\n## Found by \n0xAmanda, IllIllI\n\n## Summary\n\nThe calculation of a pool's value incorrectly includes the fee receiver portion of the borrowing fees, rather than the pool's portion\n\n\n## Vulnerability Detail\n\nBorrowing fees consist of two parts - the amount that the pool gets, and the amount the fee receiver address gets. Multiplying the total borrowing fees by the factor results in the amount the fee receiver is supposed to get, not the amount the pool is supposed to get. The code incorrectly includes the fee receiver amount rather than the pool amount, when calculating the pool's value.\n\n\n## Impact\n\nThe `getPoolValue()` function is used to determine how many shares [to mint](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/deposit/ExecuteDepositUtils.sol#L317-L323) for a deposit of collateral tokens, and how many collateral tokens to get back during [withdrawal](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/withdrawal/WithdrawalUtils.sol#L446-L462), and for [viewing](https://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/market/MarketUtils.sol#L186-L205) the value of market tokens.\n\nThis means the accounting of value is wrong, and therefore some LPs will get more for their tokens than they should, and some less, and these will be principal losses.\n\n\n## Code Snippet\n\n```solidity\n// File: gmx-synthetics/contracts/market/MarketUtils.sol : MarketUtils.getPoolValue()   #1\n\n334            cache.value = cache.longTokenUsd + cache.shortTokenUsd;\n335    \n336            cache.totalBorrowingFees = getTotalBorrowingFees(dataStore, market.marketToken, market.longToken, market.shortToken, true);\n337            cache.totalBorrowingFees += getTotalBorrowingFees(dataStore, market.marketToken, market.longToken, market.shortToken, false);\n338    \n339            cache.borrowingFeeReceiverFactor = dataStore.getUint(Keys.BORROWING_FEE_RECEIVER_FACTOR);\n340 @>         cache.value += Precision.applyFactor(cache.totalBorrowingFees, cache.borrowingFeeReceiverFactor);\n341    \n342            cache.impactPoolAmount = getPositionImpactPoolAmount(dataStore, market.marketToken);\n343            cache.value += cache.impactPoolAmount * indexTokenPrice.pickPrice(maximize);\n```\nhttps://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/market/MarketUtils.sol#L329-L349\n\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nUse the pool's portion of the borrowing fees:\n```diff\ndiff --git a/gmx-synthetics/contracts/market/MarketUtils.sol b/gmx-synthetics/contracts/market/MarketUtils.sol\nindex 7624b69..bd006bf 100644\n--- a/gmx-synthetics/contracts/market/MarketUtils.sol\n+++ b/gmx-synthetics/contracts/market/MarketUtils.sol\n@@ -337,7 +337,7 @@ library MarketUtils {\n         cache.totalBorrowingFees += getTotalBorrowingFees(dataStore, market.marketToken, market.longToken, market.shortToken, false);\n \n         cache.borrowingFeeReceiverFactor = dataStore.getUint(Keys.BORROWING_FEE_RECEIVER_FACTOR);\n-        cache.value += Precision.applyFactor(cache.totalBorrowingFees, cache.borrowingFeeReceiverFactor);\n+        cache.value += cache.totalBorrowingFees - Precision.applyFactor(cache.totalBorrowingFees, cache.borrowingFeeReceiverFactor);\n \n         cache.impactPoolAmount = getPositionImpactPoolAmount(dataStore, market.marketToken);\n         cache.value += cache.impactPoolAmount * indexTokenPrice.pickPrice(maximize);\n```\n\n\n\n\n## Discussion\n\n**xvi10**\n\nFix in https://github.com/gmx-io/gmx-synthetics/pull/84\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/6",
  "Code": [
    {
      "filename": "gmx-synthetics/contracts/deposit/ExecuteDepositUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../adl/AdlUtils.sol\";\n\nimport \"../data/DataStore.sol\";\nimport \"../event/EventEmitter.sol\";\n\nimport \"./DepositVault.sol\";\nimport \"./DepositStoreUtils.sol\";\nimport \"./DepositEventUtils.sol\";\n\nimport \"../pricing/SwapPricingUtils.sol\";\nimport \"../oracle/Oracle.sol\";\nimport \"../oracle/OracleUtils.sol\";\n\nimport \"../gas/GasUtils.sol\";\nimport \"../callback/CallbackUtils.sol\";\n\nimport \"../utils/Array.sol\";\nimport \"../utils/ErrorUtils.sol\";\n\n// @title DepositUtils\n// @dev Library for deposit functions, to help with the depositing of liquidity\n// into a market in return for market tokens\nlibrary ExecuteDepositUtils {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using Array for uint256[];\n\n    using Price for Price.Props;\n    using Deposit for Deposit.Props;\n\n    // @dev ExecuteDepositParams struct used in executeDeposit to avoid stack\n    // too deep errors\n    //\n    // @param dataStore DataStore\n    // @param eventEmitter EventEmitter\n    // @param oracle Oracle\n    // @param key the key of the deposit to execute\n    // @param oracleBlockNumbers the oracle block numbers for the prices in oracle\n    // @param keeper the address of the keeper executing the deposit\n    // @param startingGas the starting amount of gas\n    struct ExecuteDepositParams {\n        DataStore dataStore;\n        EventEmitter eventEmitter;\n        DepositVault depositVault;\n        Oracle oracle;\n        bytes32 key;\n        uint256[] minOracleBlockNumbers;\n        uint256[] maxOracleBlockNumbers;\n        address keeper;\n        uint256 startingGas;\n    }\n\n    // @dev _ExecuteDepositParams struct used in executeDeposit to avoid stack\n    // too deep errors\n    //\n    // @param market the market to deposit into\n    // @param account the depositing account\n    // @param receiver the account to send the market tokens to\n    // @param tokenIn the token to deposit, either the market.longToken or\n    // market.shortToken\n    // @param tokenOut the other token, if tokenIn is market.longToken then\n    // tokenOut is market.shortToken and vice versa\n    // @param tokenInPrice price of tokenIn\n    // @param tokenOutPrice price of tokenOut\n    // @param amount amount of tokenIn\n    // @param priceImpactUsd price impact in USD\n    struct _ExecuteDepositParams {\n        Market.Props market;\n        address account;\n        address receiver;\n        address tokenIn;\n        address tokenOut;\n        Price.Props tokenInPrice;\n        Price.Props tokenOutPrice;\n        uint256 amount;\n        int256 priceImpactUsd;\n    }\n\n    struct ExecuteDepositCache {\n        uint256 longTokenAmount;\n        uint256 shortTokenAmount;\n        uint256 longTokenUsd;\n        uint256 shortTokenUsd;\n        uint256 receivedMarketTokens;\n        int256 priceImpactUsd;\n    }\n\n    error EmptyDeposit();\n    error MinMarketTokens(uint256 received, uint256 expected);\n    error EmptyDepositAmountsAfterSwap();\n    error UnexpectedNonZeroShortAmount();\n    error InvalidPoolValueForDeposit(int256 poolValue);\n    error InvalidSwapOutputToken(address outputToken, address expectedOutputToken);\n\n    // @dev executes a deposit\n    // @param params ExecuteDepositParams\n    function executeDeposit(ExecuteDepositParams memory params) external {\n        Deposit.Props memory deposit = DepositStoreUtils.get(params.dataStore, params.key);\n        ExecuteDepositCache memory cache;\n\n        if (deposit.account() == address(0)) {\n            revert EmptyDeposit();\n        }\n\n        OracleUtils.validateBlockNumberWithinRange(\n            params.minOracleBlockNumbers,\n            params.maxOracleBlockNumbers,\n            deposit.updatedAtBlock()\n        );\n\n        Market.Props memory market = MarketUtils.getEnabledMarket(params.dataStore, deposit.market());\n\n        MarketUtils.MarketPrices memory prices = MarketUtils.getMarketPrices(params.oracle, market);\n\n        // deposits should improve the pool state but it should be checked if\n        // the max pnl factor for deposits is exceeded as this would lead to the\n        // price of the market token decreasing below the allowed amount\n        MarketUtils.validateMaxPnl(\n            params.dataStore,\n            market,\n            prices,\n            Keys.MAX_PNL_FACTOR_FOR_DEPOSITS\n        );\n\n        cache.longTokenAmount = swap(\n            params,\n            deposit.longTokenSwapPath(),\n            deposit.initialLongToken(),\n            deposit.initialLongTokenAmount(),\n            market.marketToken,\n            market.longToken\n        );\n\n        cache.shortTokenAmount = swap(\n            params,\n            deposit.shortTokenSwapPath(),\n            deposit.initialShortToken(),\n            deposit.initialShortTokenAmount(),\n            market.marketToken,\n            market.shortToken\n        );\n\n        if (cache.longTokenAmount == 0 && cache.shortTokenAmount == 0) {\n            revert EmptyDepositAmountsAfterSwap();\n        }\n\n        // if the market.longToken and market.shortToken are the same, there are two cases to consider:\n        // 1. the user is depositing the market.longToken directly\n        // 2. the user is depositing an initialLongToken and swapping it to the market.longToken\n        // for both cases, we expect the cache.shortTokenAmount to be zero, because it is unlikely that\n        // the user provides different initialLongTokens and initialShortTokens to be swapped to the same\n        // token, so that flow is not supported\n        // for the first case, the deposited token will be recorded in initialLongTokenAmount, it is not possible\n        // to have an initialShortTokenAmount because recordTransferIn records a single difference in balance of the token\n        // after all transfers\n        // for both cases, split the longTokenAmount into longTokenAmount and shortTokenAmount to minimize\n        // price impact for the user\n        if (market.longToken == market.shortToken) {\n            if (cache.shortTokenAmount > 0) {\n                revert UnexpectedNonZeroShortAmount();\n            }\n\n            (cache.longTokenAmount, cache.shortTokenAmount) = getAdjustedLongAndShortTokenAmounts(\n                params.dataStore,\n                market,\n                cache.longTokenAmount\n            );\n        }\n\n        cache.longTokenUsd = cache.longTokenAmount * prices.longTokenPrice.midPrice();\n        cache.shortTokenUsd = cache.shortTokenAmount * prices.shortTokenPrice.midPrice();\n\n        cache.receivedMarketTokens;\n\n        cache.priceImpactUsd = SwapPricingUtils.getPriceImpactUsd(\n            SwapPricingUtils.GetPriceImpactUsdParams(\n                params.dataStore,\n                market.marketToken,\n                market.longToken,\n                market.shortToken,\n                prices.longTokenPrice.midPrice(),\n                prices.shortTokenPrice.midPrice(),\n                (cache.longTokenAmount * prices.longTokenPrice.midPrice()).toInt256(),\n                (cache.shortTokenAmount * prices.shortTokenPrice.midPrice()).toInt256()\n            )\n        );\n\n        if (cache.longTokenAmount > 0) {\n            _ExecuteDepositParams memory _params = _ExecuteDepositParams(\n                market,\n                deposit.account(),\n                deposit.receiver(),\n                market.longToken,\n                market.shortToken,\n                prices.longTokenPrice,\n                prices.shortTokenPrice,\n                cache.longTokenAmount,\n                cache.priceImpactUsd * cache.longTokenUsd.toInt256() / (cache.longTokenUsd + cache.shortTokenUsd).toInt256()\n            );\n\n            cache.receivedMarketTokens += _executeDeposit(params, _params);\n        }\n\n        if (cache.shortTokenAmount > 0) {\n            _ExecuteDepositParams memory _params = _ExecuteDepositParams(\n                market,\n                deposit.account(),\n                deposit.receiver(),\n                market.shortToken,\n                market.longToken,\n                prices.shortTokenPrice,\n                prices.longTokenPrice,\n                cache.shortTokenAmount,\n                cache.priceImpactUsd * cache.shortTokenUsd.toInt256() / (cache.longTokenUsd + cache.shortTokenUsd).toInt256()\n            );\n\n            cache.receivedMarketTokens += _executeDeposit(params, _params);\n        }\n\n        if (cache.receivedMarketTokens < deposit.minMarketTokens()) {\n            revert MinMarketTokens(cache.receivedMarketTokens, deposit.minMarketTokens());\n        }\n\n        DepositStoreUtils.remove(params.dataStore, params.key, deposit.account());\n\n        DepositEventUtils.emitDepositExecuted(\n            params.eventEmitter,\n            params.key,\n            cache.longTokenAmount,\n            cache.shortTokenAmount,\n            cache.receivedMarketTokens\n        );\n\n        CallbackUtils.afterDepositExecution(params.key, deposit);\n\n        GasUtils.payExecutionFee(\n            params.dataStore,\n            params.depositVault,\n            deposit.executionFee(),\n            params.startingGas,\n            params.keeper,\n            deposit.account()\n        );\n    }\n\n    // @dev executes a deposit\n    // @param params ExecuteDepositParams\n    // @param _params _ExecuteDepositParams\n    function _executeDeposit(ExecuteDepositParams memory params, _ExecuteDepositParams memory _params) internal returns (uint256) {\n        SwapPricingUtils.SwapFees memory fees = SwapPricingUtils.getSwapFees(\n            params.dataStore,\n            _params.market.marketToken,\n            _params.amount\n        );\n\n        FeeUtils.incrementClaimableFeeAmount(\n            params.dataStore,\n            params.eventEmitter,\n            _params.market.marketToken,\n            _params.tokenIn,\n            fees.feeReceiverAmount,\n            Keys.DEPOSIT_FEE\n        );\n\n        SwapPricingUtils.emitSwapFeesCollected(\n            params.eventEmitter,\n             _params.market.marketToken,\n             _params.tokenIn,\n             \"deposit\",\n             fees\n         );\n\n        uint256 mintAmount;\n\n        int256 _poolValue = MarketUtils.getPoolValue(\n            params.dataStore,\n            _params.market,\n            _params.tokenIn == _params.market.longToken ? _params.tokenInPrice : _params.tokenOutPrice,\n            _params.tokenIn == _params.market.shortToken ? _params.tokenInPrice : _params.tokenOutPrice,\n            params.oracle.getPrimaryPrice(_params.market.indexToken),\n            Keys.MAX_PNL_FACTOR_FOR_DEPOSITS,\n            true\n        );\n\n        if (_poolValue < 0) {\n            revert InvalidPoolValueForDeposit(_poolValue);\n        }\n\n        uint256 poolValue = _poolValue.toUint256();\n\n        uint256 supply = MarketUtils.getMarketTokenSupply(MarketToken(payable(_params.market.marketToken)));\n\n        if (_params.priceImpactUsd > 0) {\n            // when there is a positive price impact factor,\n            // tokens from the swap impact pool are used to mint additional market tokens for the user\n            // for example, if 50,000 USDC is deposited and there is a positive price impact\n            // an additional 0.005 ETH may be used to mint market tokens\n            // the swap impact pool is decreased by the used amount\n            //\n            // priceImpactUsd is calculated based on pricing assuming only depositAmount of tokenIn\n            // was added to the pool\n            // since impactAmount of tokenOut is added to the pool here, the calculation of\n            // the tokenInPrice would not be entirely accurate\n            int256 positiveImpactAmount = MarketUtils.applySwapImpactWithCap(\n                params.dataStore,\n                params.eventEmitter,\n                _params.market.marketToken,\n                _params.tokenOut,\n                _params.tokenOutPrice,\n                _params.priceImpactUsd\n            );\n\n            // calculate the usd amount using positiveImpactAmount since it may\n            // be capped by the max available amount in the impact pool\n            mintAmount += MarketUtils.usdToMarketTokenAmount(\n                positiveImpactAmount.toUint256() * _params.tokenOutPrice.min,\n                poolValue,\n                supply\n            );\n\n            // deposit the token out, that was withdrawn from the impact pool, to mint market tokens\n            MarketUtils.applyDeltaToPoolAmount(\n                params.dataStore,\n                params.eventEmitter,\n                _params.market.marketToken,\n                _params.tokenOut,\n                positiveImpactAmount\n            );\n        } else {\n            // when there is a negative price impact factor,\n            // less of the deposit amount is used to mint market tokens\n            // for example, if 10 ETH is deposited and there is a negative price impact\n            // only 9.995 ETH may be used to mint market tokens\n            // the remaining 0.005 ETH will be stored in the swap impact pool\n            int256 negativeImpactAmount = MarketUtils.applySwapImpactWithCap(\n                params.dataStore,\n                params.eventEmitter,\n                _params.market.marketToken,\n                _params.tokenIn,\n                _params.tokenInPrice,\n                _params.priceImpactUsd\n            );\n            fees.amountAfterFees -= (-negativeImpactAmount).toUint256();\n        }\n\n        mintAmount += MarketUtils.usdToMarketTokenAmount(\n            fees.amountAfterFees * _params.tokenInPrice.min,\n            poolValue,\n            supply\n        );\n\n        MarketUtils.applyDeltaToPoolAmount(\n            params.dataStore,\n            params.eventEmitter,\n            _params.market.marketToken,\n            _params.tokenIn,\n            (fees.amountAfterFees + fees.feeAmountForPool).toInt256()\n        );\n\n        MarketUtils.validatePoolAmount(\n            params.dataStore,\n            _params.market.marketToken,\n            _params.tokenIn\n        );\n\n        MarketToken(payable(_params.market.marketToken)).mint(_params.receiver, mintAmount);\n\n        return mintAmount;\n    }\n\n    // @dev this should only be called if the long and short tokens are the same\n    // calculate the long and short amounts that would lead to the smallest amount\n    // of price impact by helping to balance the pool\n    // @param dataStore DataStore\n    // @param market the market for the deposit\n    // @param longTokenAmount the long token amount\n    function getAdjustedLongAndShortTokenAmounts(\n        DataStore dataStore,\n        Market.Props memory market,\n        uint256 longTokenAmount\n    ) internal view returns (uint256, uint256) {\n        uint256 poolLongTokenAmount = MarketUtils.getPoolAmount(dataStore, market.marketToken, market.longToken);\n        uint256 poolShortTokenAmount = MarketUtils.getPoolAmount(dataStore, market.marketToken, market.shortToken);\n\n        uint256 adjustedLongTokenAmount;\n        uint256 adjustedShortTokenAmount;\n\n        if (poolLongTokenAmount < poolShortTokenAmount) {\n            uint256 diff = poolLongTokenAmount - poolShortTokenAmount;\n\n            if (diff < poolLongTokenAmount) {\n                adjustedLongTokenAmount = diff + (longTokenAmount - diff) / 2;\n                adjustedShortTokenAmount = longTokenAmount - adjustedLongTokenAmount;\n            } else {\n                adjustedLongTokenAmount = longTokenAmount;\n            }\n        } else {\n            uint256 diff = poolShortTokenAmount - poolLongTokenAmount;\n\n            if (diff < poolShortTokenAmount) {\n                adjustedShortTokenAmount = diff + (longTokenAmount - diff) / 2;\n                adjustedLongTokenAmount - longTokenAmount - adjustedShortTokenAmount;\n            } else {\n                adjustedLongTokenAmount = 0;\n                adjustedShortTokenAmount = longTokenAmount;\n            }\n        }\n\n        return (adjustedLongTokenAmount, adjustedShortTokenAmount);\n    }\n\n    function swap(\n        ExecuteDepositParams memory params,\n        address[] memory swapPath,\n        address initialToken,\n        uint256 inputAmount,\n        address market,\n        address expectedOutputToken\n    ) internal returns (uint256) {\n        Market.Props[] memory swapPathMarkets = MarketUtils.getEnabledMarkets(\n            params.dataStore,\n            swapPath\n        );\n\n        (address outputToken, uint256 outputAmount) = SwapUtils.swap(\n            SwapUtils.SwapParams(\n                params.dataStore, // dataStore\n                params.eventEmitter, // eventEmitter\n                params.oracle, // oracle\n                params.depositVault, // bank\n                initialToken, // tokenIn\n                inputAmount, // amountIn\n                swapPathMarkets, // swapPathMarkets\n                0, // minOutputAmount\n                market, // receiver\n                false // shouldUnwrapNativeToken\n            )\n        );\n\n        if (outputToken != expectedOutputToken) {\n            revert InvalidSwapOutputToken(outputToken, expectedOutputToken);\n        }\n\n        return outputAmount;\n    }\n}"
    },
    {
      "filename": "gmx-synthetics/contracts/market/MarketUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport \"../data/DataStore.sol\";\nimport \"../event/EventEmitter.sol\";\nimport \"../bank/StrictBank.sol\";\n\nimport \"./Market.sol\";\nimport \"./MarketToken.sol\";\nimport \"./MarketEventUtils.sol\";\nimport \"./MarketStoreUtils.sol\";\n\nimport \"../position/Position.sol\";\nimport \"../order/Order.sol\";\n\nimport \"../oracle/Oracle.sol\";\nimport \"../price/Price.sol\";\n\nimport \"../utils/Calc.sol\";\nimport \"../utils/Precision.sol\";\n\n// @title MarketUtils\n// @dev Library for market functions\nlibrary MarketUtils {\n    using SafeCast for int256;\n    using SafeCast for uint256;\n\n    using Market for Market.Props;\n    using Position for Position.Props;\n    using Order for Order.Props;\n    using Price for Price.Props;\n\n    // @dev struct to store the prices of tokens of a market\n    // @param indexTokenPrice price of the market's index token\n    // @param longTokenPrice price of the market's long token\n    // @param shortTokenPrice price of the market's short token\n    struct MarketPrices {\n        Price.Props indexTokenPrice;\n        Price.Props longTokenPrice;\n        Price.Props shortTokenPrice;\n    }\n\n    // @dev struct for the result of the getNextFundingAmountPerSize call\n    // @param longsPayShorts whether longs pay shorts or shorts pay longs\n    // @param fundingAmountPerSize_LongCollateral_LongPosition funding amount per\n    // size for users with a long position using long collateral\n    // @param fundingAmountPerSize_LongCollateral_ShortPosition funding amount per\n    // size for users with a short position using long collateral\n    // @param fundingAmountPerSize_ShortCollateral_LongPosition funding amount per\n    // size for users with a long position using short collateral\n    // @param fundingAmountPerSize_ShortCollateral_ShortPosition funding amount per\n    // size for users with a short position using short collateral\n    struct GetNextFundingAmountPerSizeResult {\n        bool longsPayShorts;\n        int256 fundingAmountPerSize_LongCollateral_LongPosition;\n        int256 fundingAmountPerSize_LongCollateral_ShortPosition;\n        int256 fundingAmountPerSize_ShortCollateral_LongPosition;\n        int256 fundingAmountPerSize_ShortCollateral_ShortPosition;\n    }\n\n    // @dev struct to avoid stack too deep errors for the getPoolValue call\n    // @param value the pool value\n    // @param longTokenAmount the amount of long token in the pool\n    // @param shortTokenAmount the amount of short token in the pool\n    // @param longTokenUsd the USD value of the long tokens in the pool\n    // @param shortTokenUsd the USD value of the short tokens in the pool\n    // @param totalBorrowingFees the total pending borrowing fees for the market\n    // @param borrowingFeeReceiverFactor the fee receiver factor for borrowing fees\n    // @param impactPoolAmount the amount of tokens in the impact pool\n    // @param longPnl the pending pnl of long positions\n    // @param shortPnl the pending pnl of short positions\n    // @param netPnl the net pnl of long and short positions\n    struct GetPoolValueCache {\n        uint256 value;\n\n        uint256 longTokenAmount;\n        uint256 shortTokenAmount;\n        uint256 longTokenUsd;\n        uint256 shortTokenUsd;\n\n        uint256 totalBorrowingFees;\n        uint256 borrowingFeeReceiverFactor;\n\n        uint256 impactPoolAmount;\n        int256 longPnl;\n        int256 shortPnl;\n        int256 netPnl;\n    }\n\n    // @dev GetNextFundingAmountPerSizeCache struct used in getNextFundingAmountPerSize\n    // to avoid stack too deep errors\n    //\n    // @param durationInSeconds duration in seconds since the last funding update\n    //\n    // @param diffUsd the absolute difference in long and short open interest for the market\n    // @param totalOpenInterest the total long and short open interest for the market\n    // @param fundingUsd the funding amount in USD\n    //\n    // @param fundingUsdForLongCollateral the funding amount in USD for positions using the long token as collateral\n    // @param fundingUsdForShortCollateral the funding amount in USD for positions using the short token as collateral\n    struct GetNextFundingAmountPerSizeCache {\n        GetNextFundingAmountPerSizeOpenInterestCache oi;\n        GetNextFundingAmountPerSizeFundingPerSizeCache fps;\n\n        uint256 durationInSeconds;\n\n        uint256 diffUsd;\n        uint256 totalOpenInterest;\n        uint256 sizeOfLargerSide;\n        uint256 fundingFactorPerSecond;\n        uint256 fundingUsd;\n\n        uint256 fundingUsdForLongCollateral;\n        uint256 fundingUsdForShortCollateral;\n    }\n\n    // @param longOpenInterestWithLongCollateral amount of long open interest using the long token as collateral\n    // @param longOpenInterestWithShortCollateral amount of long open interest using the short token as collateral\n    // @param shortOpenInterestWithLongCollateral amount of short open interest using the long token as collateral\n    // @param shortOpenInterestWithShortCollateral amount of short open interest using the short token as collateral\n    //\n    // @param longOpenInterest total long open interest for the market\n    // @param shortOpenInterest total short open interest for the market\n    struct GetNextFundingAmountPerSizeOpenInterestCache {\n        uint256 longOpenInterestWithLongCollateral;\n        uint256 longOpenInterestWithShortCollateral;\n        uint256 shortOpenInterestWithLongCollateral;\n        uint256 shortOpenInterestWithShortCollateral;\n\n        uint256 longOpenInterest;\n        uint256 shortOpenInterest;\n    }\n\n    // @param fundingAmountPerSize_LongCollateral_LongPosition funding per size for longs using the long token as collateral\n    // @param fundingAmountPerSize_LongCollateral_ShortPosition funding per size for shorts using the long token as collateral\n    // @param fundingAmountPerSize_ShortCollateral_LongPosition funding per size for longs using the short token as collateral\n    // @param fundingAmountPerSize_ShortCollateral_ShortPosition funding per size for shorts using the short token as collateral\n    //\n    // @param fundingAmountPerSizePortion_LongCollateral_LongPosition the next funding amount per size for longs using the long token as collateral\n    // @param fundingAmountPerSizePortion_LongCollateral_ShortPosition the next funding amount per size for longs using the short token as collateral\n    // @param fundingAmountPerSizePortion_ShortCollateral_LongPosition the next funding amount per size for shorts using the long token as collateral\n    // @param fundingAmountPerSizePortion_ShortCollateral_ShortPosition the next funding amount per size for shorts using the short token as collateral\n    struct GetNextFundingAmountPerSizeFundingPerSizeCache {\n        int256 fundingAmountPerSize_LongCollateral_LongPosition;\n        int256 fundingAmountPerSize_LongCollateral_ShortPosition;\n        int256 fundingAmountPerSize_ShortCollateral_LongPosition;\n        int256 fundingAmountPerSize_ShortCollateral_ShortPosition;\n\n        uint256 fundingAmountPerSizePortion_LongCollateral_LongPosition;\n        uint256 fundingAmountPerSizePortion_ShortCollateral_LongPosition;\n        uint256 fundingAmountPerSizePortion_LongCollateral_ShortPosition;\n        uint256 fundingAmountPerSizePortion_ShortCollateral_ShortPosition;\n    }\n\n    error EmptyMarket();\n    error DisabledMarket(address market);\n    error InsufficientPoolAmount(uint256 poolAmount, uint256 amount);\n    error InsufficientReserve(uint256 reservedUsd, uint256 maxReservedUsd);\n    error UnexpectedPoolValueForTokenPriceCalculation(int256 poolValue);\n    error UnexpectedSupplyForTokenPriceCalculation();\n    error UnableToGetOppositeToken(address inputToken, address market);\n    error UnableToGetCachedTokenPrice(address token, address market);\n    error CollateralAlreadyClaimed(uint256 adjustedClaimableAmount, uint256 claimedAmount);\n    error OpenInterestCannotBeUpdatedForSwapOnlyMarket(address market);\n    error MaxOpenInterestExceeded(uint256 openInterest, uint256 maxOpenInterest);\n    error MaxPoolAmountExceeded(uint256 poolAmount, uint256 maxPoolAmount);\n    error UnexpectedBorrowingFactor(uint256 positionBorrowingFactor, uint256 cumulativeBorrowingFactor);\n    error UnableToGetBorrowingFactorEmptyPoolUsd();\n    error UnableToGetFundingFactorEmptyOpenInterest();\n    error InvalidPositionMarket(address market);\n    error InvalidCollateralTokenForMarket(address market, address token);\n    error PnlFactorExceededForLongs(int256 pnlToPoolFactor, uint256 maxPnlFactor);\n    error PnlFactorExceededForShorts(int256 pnlToPoolFactor, uint256 maxPnlFactor);\n\n    // @dev get the market token's price\n    // @param dataStore DataStore\n    // @param market the market to check\n    // @param longTokenPrice the price of the long token\n    // @param shortTokenPrice the price of the short token\n    // @param indexTokenPrice the price of the index token\n    // @param maximize whether to maximize or minimize the market token price\n    // @return returns the market token's price\n    function getMarketTokenPrice(\n        DataStore dataStore,\n        Market.Props memory market,\n        Price.Props memory longTokenPrice,\n        Price.Props memory shortTokenPrice,\n        Price.Props memory indexTokenPrice,\n        bytes32 pnlFactorType,\n        bool maximize\n    ) internal view returns (int256) {\n        int256 poolValue = getPoolValue(\n            dataStore,\n            market,\n            longTokenPrice,\n            shortTokenPrice,\n            indexTokenPrice,\n            pnlFactorType,\n            maximize\n        );\n\n        if (poolValue == 0) { return 0; }\n\n        if (poolValue < 0) {\n            revert UnexpectedPoolValueForTokenPriceCalculation(poolValue);\n        }\n\n        uint256 supply = getMarketTokenSupply(MarketToken(payable(market.marketToken)));\n\n        if (supply == 0) {\n            revert UnexpectedSupplyForTokenPriceCalculation();\n        }\n\n        return poolValue * Precision.WEI_PRECISION.toInt256() / supply.toInt256();\n    }\n\n    // @dev get the total supply of the marketToken\n    // @param marketToken the marketToken\n    // @return the total supply of the marketToken\n    function getMarketTokenSupply(MarketToken marketToken) internal view returns (uint256) {\n        return marketToken.totalSupply();\n    }\n\n    // @dev get the opposite token of the market\n    // if the inputToken is the longToken return the shortToken and vice versa\n    // @param inputToken the input token\n    // @param market the market values\n    // @return the opposite token\n    function getOppositeToken(address inputToken, Market.Props memory market) internal pure returns (address) {\n        if (inputToken == market.longToken) {\n            return market.shortToken;\n        }\n\n        if (inputToken == market.shortToken) {\n            return market.longToken;\n        }\n\n        revert UnableToGetOppositeToken(inputToken, market.marketToken);\n    }\n\n    // @dev get the token price from the stored MarketPrices\n    // @param token the token to get the price for\n    // @param the market values\n    // @param the market token prices\n    // @return the token price from the stored MarketPrices\n    function getCachedTokenPrice(address token, Market.Props memory market, MarketPrices memory prices) internal pure returns (Price.Props memory) {\n        if (token == market.longToken) {\n            return prices.longTokenPrice;\n        }\n        if (token == market.shortToken) {\n            return prices.shortTokenPrice;\n        }\n        if (token == market.indexToken) {\n            return prices.indexTokenPrice;\n        }\n\n        revert UnableToGetCachedTokenPrice(token, market.marketToken);\n    }\n\n    // @dev return the latest prices for the market tokens\n    // the secondary price for market.indexToken is overwritten for certain order\n    // types, use this value instead of the primary price for positions\n    // @param oracle Oracle\n    // @param market the market values\n    function getMarketPricesForPosition(Oracle oracle, Market.Props memory market) internal view returns (MarketPrices memory) {\n        return MarketPrices(\n            oracle.getLatestPrice(market.indexToken),\n            oracle.getLatestPrice(market.longToken),\n            oracle.getLatestPrice(market.shortToken)\n        );\n    }\n\n    // @dev return the primary prices for the market tokens\n    // @param oracle Oracle\n    // @param market the market values\n    function getMarketPrices(Oracle oracle, Market.Props memory market) internal view returns (MarketPrices memory) {\n        return MarketPrices(\n            oracle.getPrimaryPrice(market.indexToken),\n            oracle.getPrimaryPrice(market.longToken),\n            oracle.getPrimaryPrice(market.shortToken)\n        );\n    }\n\n    // @dev get the usd value of either the long or short tokens in the pool\n    // without accounting for the pnl of open positions\n    // @param dataStore DataStore\n    // @param market the market values\n    // @param prices the prices of the market tokens\n    // @param whether to return the value for the long or short token\n    // @return the usd value of either the long or short tokens in the pool\n    function getPoolUsdWithoutPnl(\n        DataStore dataStore,\n        Market.Props memory market,\n        MarketPrices memory prices,\n        bool isLong\n    ) internal view returns (uint256) {\n        address token = isLong ? market.longToken : market.shortToken;\n        uint256 poolAmount = getPoolAmount(dataStore, market.marketToken, token);\n        uint256 tokenPrice = isLong ? prices.longTokenPrice.min : prices.shortTokenPrice.min;\n        return poolAmount * tokenPrice;\n    }\n\n    // @dev get the USD value of a pool\n    // the value of a pool is the worth of the liquidity provider tokens in the pool - pending trader pnl\n    // we use the token index prices to calculate this and ignore price impact since if all positions were closed the\n    // net price impact should be zero\n    // @param dataStore DataStore\n    // @param market the market values\n    // @param longTokenPrice price of the long token\n    // @param shortTokenPrice price of the short token\n    // @param indexTokenPrice price of the index token\n    // @param maximize whether to maximize or minimize the pool value\n    // @return the USD value of a pool\n    function getPoolValue(\n        DataStore dataStore,\n        Market.Props memory market,\n        Price.Props memory longTokenPrice,\n        Price.Props memory shortTokenPrice,\n        Price.Props memory indexTokenPrice,\n        bytes32 pnlFactorType,\n        bool maximize\n    ) internal view returns (int256) {\n        GetPoolValueCache memory cache;\n\n        cache.longTokenAmount = getPoolAmount(dataStore, market.marketToken, market.longToken);\n        cache.shortTokenAmount = getPoolAmount(dataStore, market.marketToken, market.shortToken);\n\n        cache.longTokenUsd = cache.longTokenAmount * longTokenPrice.pickPrice(maximize);\n        cache.shortTokenUsd = cache.shortTokenAmount * shortTokenPrice.pickPrice(maximize);\n\n        cache.value = cache.longTokenUsd + cache.shortTokenUsd;\n\n        cache.totalBorrowingFees = getTotalBorrowingFees(dataStore, market.marketToken, market.longToken, market.shortToken, true);\n        cache.totalBorrowingFees += getTotalBorrowingFees(dataStore, market.marketToken, market.longToken, market.shortToken, false);\n\n        cache.borrowingFeeReceiverFactor = dataStore.getUint(Keys.BORROWING_FEE_RECEIVER_FACTOR);\n        cache.value += Precision.applyFactor(cache.totalBorrowingFees, cache.borrowingFeeReceiverFactor);\n\n        cache.impactPoolAmount"
    }
  ]
}