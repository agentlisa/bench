{
  "Title": "Inconsistent Convention for Checking Access Allowance",
  "Content": "`_checkAccessAllowed` is called using the function signature (e.g., [here](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/TokenConverter/AbstractTokenConverter.sol#L156) and [here](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/TokenConverter/RiskFundConverter.sol#L110)), but it is called using a [different convention](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/ProtocolReserve/XVSVaultTreasury.sol#L60) in `XVSVaultTreasury` (variable name replaces type). Consider sticking to a consistent convention for `_checkAccessAllowed` to avoid the likelihood of checking for incorrect strings and causing functions to [revert](https://github.com/VenusProtocol/governance-contracts/blob/main/contracts/Governance/AccessControlledV8.sol#L80).\n\n\n***Update:** Resolved at commit [b467b46](https://github.com/VenusProtocol/protocol-reserve/pull/24/commits/b467b46ef2a72e02988936bd027f98acd8653d80).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/TokenConverter/AbstractTokenConverter.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport { SafeERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport { AccessControlledV8 } from \"@venusprotocol/governance-contracts/contracts/Governance/AccessControlledV8.sol\";\nimport { IERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport { ResilientOracle } from \"@venusprotocol/oracle/contracts/ResilientOracle.sol\";\n\nimport { MANTISSA_ONE, EXP_SCALE } from \"../Utils/Constants.sol\";\nimport { ensureNonzeroAddress } from \"../Utils/Validators.sol\";\nimport { IAbstractTokenConverter } from \"./IAbstractTokenConverter.sol\";\n\n/// @title AbstractTokenConverter\n/// @author Venus\n/// @notice Abstract contract will be extended by XVSVaultConverter and RiskFundConverter\nabstract contract AbstractTokenConverter is AccessControlledV8, IAbstractTokenConverter, ReentrancyGuardUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @notice Maximum incentive could be\n    uint256 public constant MAX_INCENTIVE = 0.5e18;\n\n    /// @notice Venus price oracle contract\n    ResilientOracle public priceOracle;\n\n    /// @notice conversion configurations for the existing pairs\n    /// @dev tokenAddressIn => tokenAddressOut => ConversionConfig\n    mapping(address => mapping(address => ConversionConfig)) public convertConfigurations;\n\n    /// @notice Address at all incoming tokens are transferred to\n    address public destinationAddress;\n\n    /// @notice Boolean of if convert is paused\n    bool public conversionPaused;\n\n    /// @dev This empty reserved space is put in place to allow future versions to add new\n    /// variables without shifting down storage in the inheritance chain.\n    /// See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n    uint256[47] private __gap;\n\n    /// @notice Emitted when config is updated for tokens pair\n    event ConversionConfigUpdated(\n        address indexed tokenAddressIn,\n        address indexed tokenAddressOut,\n        uint256 oldIncentive,\n        uint256 newIncentive,\n        bool oldEnabled,\n        bool newEnabled\n    );\n    /// @notice Emitted when price oracle address is updated\n    event PriceOracleUpdated(ResilientOracle oldPriceOracle, ResilientOracle priceOracle);\n\n    /// @notice Emitted when destination address is updated\n    event DestinationAddressUpdated(address oldDestinationAddress, address destinationAddress);\n\n    /// @notice Emitted when exact amount of tokens are convert for tokens\n    event ConvertExactTokens(uint256 amountIn, uint256 amountOut);\n\n    /// @notice Emitted when tokens are convert for exact amount of tokens\n    event ConvertForExactTokens(uint256 amountIn, uint256 amountOut);\n\n    /// @notice Emitted when exact amount of tokens are convert for tokens, for deflationary tokens\n    event ConvertExactTokensSupportingFeeOnTransferTokens(uint256 amountIn, uint256 amountOut);\n\n    /// @notice Emitted when tokens are convert for exact amount of tokens, for deflationary tokens\n    event ConvertForExactTokensSupportingFeeOnTransferTokens(uint256 amountIn, uint256 amountOut);\n\n    /// @notice Emitted when conversion is paused\n    event ConversionPaused(address sender);\n\n    /// @notice Emitted when conversion is unpaused\n    event ConversionResumed(address sender);\n\n    /// @notice Event emitted when tokens are swept\n    event SweepToken(address indexed token);\n\n    /// @notice Thrown when given input amount is zero\n    error InsufficientInputAmount();\n\n    /// @notice Thrown when conversion is disabled or config does not exist for given pair\n    error ConversionConfigNotEnabled();\n\n    /// @notice Thrown when incentive is higher than the MAX_INCENTIVE\n    error IncentiveTooHigh(uint256 incentive, uint256 maxIncentive);\n\n    /// @notice Thrown when amountOut is lower than amountOutMin\n    error AmountOutLowerThanMinRequired(uint256 amountOutMantissa, uint256 amountOutMinMantissa);\n\n    /// @notice Thrown when actual amountIn or amountOut is lower than expected\n    error AmountInOrAmountOutMismatched(\n        uint256 actualAmountIn,\n        uint256 requiredAmountIn,\n        uint256 actualAmountOut,\n        uint256 requiredAmountOut\n    );\n\n    /// @notice Thrown when amountIn is higher than amountInMax\n    error AmountInHigherThanMax(uint256 amountInMantissa, uint256 amountInMaxMantissa);\n\n    /// @notice Thrown when conversion is paused\n    error ConversionTokensPaused();\n\n    /// @notice Thrown when conversion is Active\n    error ConversionTokensActive();\n\n    /**\n     * @notice Pause conversion of tokens\n     * @custom:event Emits ConversionPaused on success\n     * @custom:error ConversionTokensPaused thrown when convert is already paused\n     * @custom:access Restricted by ACM\n     */\n    function pauseConversion() external {\n        _checkAccessAllowed(\"pauseConversion()\");\n        _checkConversionPaused();\n        conversionPaused = true;\n        emit ConversionPaused(msg.sender);\n    }\n\n    /**\n     * @notice Resume conversion of tokens.\n     * @custom:event Emits ConversionResumed on success\n     * @custom:error ConversionTokensActive thrown when convert is already active\n     * @custom:access Restricted by ACM\n     */\n    function resumeConversion() external {\n        _checkAccessAllowed(\"resumeConversion()\");\n        if (!conversionPaused) {\n            revert ConversionTokensActive();\n        }\n\n        conversionPaused = false;\n        emit ConversionResumed(msg.sender);\n    }\n\n    /// @notice Sets a new price oracle\n    /// @param priceOracle_ Address of the new price oracle to set\n    /// @custom:access Only Governance\n    function setPriceOracle(ResilientOracle priceOracle_) external onlyOwner {\n        _setPriceOracle(priceOracle_);\n    }\n\n    /// @notice Sets a new destination address\n    /// @param destinationAddress_ Address of the new price oracle to set\n    /// @custom:access Only Governance\n    function setDestination(address destinationAddress_) external onlyOwner {\n        _setDestination(destinationAddress_);\n    }\n\n    /// @notice Set the configuration for new or existing convert pair\n    /// @param conversionConfig ConversionConfig config details to update\n    /// @custom:event Emits ConversionConfigUpdated event on success\n    /// @custom:error Unauthorized error is thrown when the call is not authorized by AccessControlManager\n    /// @custom:error ZeroAddressNotAllowed is thrown when pool registry address is zero\n    /// @custom:access Controlled by AccessControlManager\n    function setConversionConfig(ConversionConfig calldata conversionConfig) external {\n        _checkAccessAllowed(\"setConversionConfig(ConversionConfig)\");\n        ensureNonzeroAddress(conversionConfig.tokenAddressIn);\n        ensureNonzeroAddress(conversionConfig.tokenAddressOut);\n\n        if (conversionConfig.incentive > MAX_INCENTIVE) {\n            revert IncentiveTooHigh(conversionConfig.incentive, MAX_INCENTIVE);\n        }\n\n        ConversionConfig storage configuration = convertConfigurations[conversionConfig.tokenAddressIn][\n            conversionConfig.tokenAddressOut\n        ];\n\n        uint256 oldIncentive = configuration.incentive;\n        bool oldEnabled = configuration.enabled;\n\n        configuration.tokenAddressIn = conversionConfig.tokenAddressIn;\n        configuration.tokenAddressOut = conversionConfig.tokenAddressOut;\n        configuration.incentive = conversionConfig.incentive;\n        configuration.enabled = conversionConfig.enabled;\n\n        emit ConversionConfigUpdated(\n            conversionConfig.tokenAddressIn,\n            conversionConfig.tokenAddressOut,\n            oldIncentive,\n            conversionConfig.incentive,\n            oldEnabled,\n            conversionConfig.enabled\n        );\n    }\n\n    /// @notice Convert exact amount of tokenAddressIn for tokenAddressOut\n    /// @dev Method does not support deflationary tokens transfer\n    /// @param amountInMantissa Amount of tokenAddressIn\n    /// @param amountOutMinMantissa Min amount of tokenAddressOut required as output\n    /// @param tokenAddressIn Address of the token to convert\n    /// @param tokenAddressOut Address of the token to get after convert\n    /// @param to Address of the tokenAddressOut receiver\n    /// @custom:event Emits ConvertExactTokens event on success\n    /// @custom:error AmountOutLowerThanMinRequired error is thrown when amount of output tokenAddressOut is less than amountOutMinMantissa\n    /// @custom:error AmountInOrAmountOutMismatched error is thrown when Amount of tokenAddressIn or tokenAddressOut is lower than expected fater transfer\n    function convertExactTokens(\n        uint256 amountInMantissa,\n        uint256 amountOutMinMantissa,\n        address tokenAddressIn,\n        address tokenAddressOut,\n        address to\n    ) external nonReentrant {\n        _checkConversionPaused();\n        uint256 actualAmountIn;\n        uint256 amountConvertedMantissa;\n        uint256 actualAmountOut;\n        uint256 amountOutMantissa;\n\n        (actualAmountIn, amountConvertedMantissa, actualAmountOut, amountOutMantissa) = _convertExactTokensForTokens(\n            amountInMantissa,\n            amountOutMinMantissa,\n            tokenAddressIn,\n            tokenAddressOut,\n            to\n        );\n\n        if ((actualAmountIn < amountConvertedMantissa) || (actualAmountOut < amountOutMantissa)) {\n            revert AmountInOrAmountOutMismatched(\n                actualAmountIn,\n                amountConvertedMantissa,\n                actualAmountOut,\n                amountOutMantissa\n            );\n        }\n\n        postConversionHook(tokenAddressIn, tokenAddressOut, actualAmountIn, actualAmountOut);\n\n        emit ConvertExactTokens(actualAmountIn, actualAmountOut);\n    }\n\n    /// @notice Convert tokens for tokenAddressIn for exact amount of tokenAddressOut\n    /// @dev Method does not support deflationary tokens transfer\n    /// @param amountInMaxMantissa Max amount of tokenAddressIn\n    /// @param amountOutMantissa Amount of tokenAddressOut required as output\n    /// @param tokenAddressIn Address of the token to convert\n    /// @param tokenAddressOut Address of the token to get after convert\n    /// @param to Address of the tokenAddressOut receiver\n    /// @custom:event Emits ConvertForExactTokens event on success\n    /// @custom:error AmountInHigherThanMax error is thrown when amount of tokenAddressIn is higher than amountInMaxMantissa\n    /// @custom:error AmountInOrAmountOutMismatched error is thrown when Amount of tokenAddressIn or tokenAddressOut is lower than expected fater transfer\n    function convertForExactTokens(\n        uint256 amountInMaxMantissa,\n        uint256 amountOutMantissa,\n        address tokenAddressIn,\n        address tokenAddressOut,\n        address to\n    ) external nonReentrant {\n        _checkConversionPaused();\n        uint256 actualAmountIn;\n        uint256 amountInMantissa;\n        uint256 actualAmountOut;\n        uint256 amountConvertedMantissa;\n\n        (actualAmountIn, amountInMantissa, actualAmountOut, amountConvertedMantissa) = _convertForExactTokens(\n            amountInMaxMantissa,\n            amountOutMantissa,\n            tokenAddressIn,\n            tokenAddressOut,\n            to\n        );\n\n        if ((actualAmountIn < amountInMantissa) || (actualAmountOut < amountConvertedMantissa)) {\n            revert AmountInOrAmountOutMismatched(\n                actualAmountIn,\n                amountInMantissa,\n                actualAmountOut,\n                amountConvertedMantissa\n            );\n        }\n\n        postConversionHook(tokenAddressIn, tokenAddressOut, actualAmountIn, actualAmountOut);\n\n        emit ConvertForExactTokens(actualAmountIn, actualAmountOut);\n    }\n\n    /// @notice Convert exact amount of tokenAddressIn for tokenAddressOut\n    /// @param amountInMantissa Amount of tokenAddressIn\n    /// @param amountOutMinMantissa Min amount of tokenAddressOut required as output\n    /// @param tokenAddressIn Address of the token to convert\n    /// @param tokenAddressOut Address of the token to get after convert\n    /// @param to Address of the tokenAddressOut receiver\n    /// @custom:event Emits ConvertExactTokensSupportingFeeOnTransferTokens event on success\n    /// @custom:error AmountOutLowerThanMinRequired error is thrown when amount of output tokenAddressOut is less than amountOutMinMantissa\n    function convertExactTokensSupportingFeeOnTransferTokens(\n        uint256 amountInMantissa,\n        uint256 amountOutMinMantissa,\n        address tokenAddressIn,\n        address tokenAddressOut,\n        address to\n    ) external nonReentrant {\n        _checkConversionPaused();\n        uint256 actualAmountIn;\n        uint256 amountConvertedMantissa;\n        uint256 actualAmountOut;\n        uint256 amountOutMantissa;\n\n        (actualAmountIn, amountConvertedMantissa, actualAmountOut, amountOutMantissa) = _convertExactTokensForTokens(\n            amountInMantissa,\n            amountOutMinMantissa,\n            tokenAddressIn,\n            tokenAddressOut,\n            to\n        );\n\n        postConversionHook(tokenAddressIn, tokenAddressOut, actualAmountIn, actualAmountOut);\n\n        emit ConvertExactTokensSupportingFeeOnTransferTokens(actualAmountIn, actualAmountOut);\n    }\n\n    /// @notice Convert tokens for tokenAddressIn for exact amount of tokenAddressOut\n    /// @param amountInMaxMantissa Max amount of tokenAddressIn\n    /// @param amountOutMantissa Amount of tokenAddressOut required as output\n    /// @param tokenAddressIn Address of the token to convert\n    /// @param tokenAddressOut Address of the token to get after convert\n    /// @param to Address of the tokenAddressOut receiver\n    /// @custom:event Emits ConvertForExactTokensSupportingFeeOnTransferTokens event on success\n    /// @custom:error AmountInHigherThanMax error is thrown when amount of tokenAddressIn is higher than amountInMaxMantissa\n    function convertForExactTokensSupportingFeeOnTransferTokens(\n        uint256 amountInMaxMantissa,\n        uint256 amountOutMantissa,\n        address tokenAddressIn,\n        address tokenAddressOut,\n        address to\n    ) external nonReentrant {\n        _checkConversionPaused();\n        uint256 actualAmountIn;\n        uint256 amountInMantissa;\n        uint256 actualAmountOut;\n        uint256 amountConvertedMantissa;\n\n        (actualAmountIn, amountInMantissa, actualAmountOut, amountConvertedMantissa) = _convertForExactTokens(\n            amountInMaxMantissa,\n            amountOutMantissa,\n            tokenAddressIn,\n            tokenAddressOut,\n            to\n        );\n\n        postConversionHook(tokenAddressIn, tokenAddressOut, actualAmountIn, actualAmountOut);\n\n        emit ConvertForExactTokensSupportingFeeOnTransferTokens(actualAmountIn, actualAmountOut);\n    }\n\n    /// @notice A public function to sweep ERC20 tokens and transfer them to user(to address)\n    /// @param tokenAddress The address of the ERC-20 token to sweep\n    /// @custom:event Emits SweepToken event on success\n    /// @custom:error ZeroAddressNotAllowed is thrown when tokenAddress/to address is zero\n    /// @custom:access Only Governance\n    function sweepToken(address tokenAddress, address to, uint256 amount) external onlyOwner nonReentrant {\n        ensureNonzeroAddress(tokenAddress);\n        ensureNonzeroAddress(to);\n\n        IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);\n        postSweepToken(tokenAddress, amount);\n        token.safeTransfer(to, amount);\n\n        emit SweepToken(address(token));\n    }\n\n    /// @notice To get the amount of tokenAddressOut tokens sender could receive on providing amountInMantissa tokens of tokenAddressIn\n    /// @param amountInMantissa Amount of tokenAddressIn\n    /// @param tokenAddressIn Address of the token to convert\n    /// @param tokenAddressOut Address of the token to get after convert\n    /// @return amountConvertedMantissa Amount of tokenAddressIn should be transferred after convert\n    /// @return amountOutMantissa Amount of the tokenAddressOut sender should receive after convert\n    /// @custom:error InsufficientInputAmount error is thrown when given input amount is zero\n    /// @custom:error ConversionConfigNotEnabled is thrown when convert is disabled or config does not exist for given pair\n    function getUpdatedAmountOut(\n        uint256 amountInMantissa,\n        address tokenAddressIn,\n        address tokenAddressOut\n    ) public returns (uint256 amountConvertedMantissa, uint256 amountOutMantissa) {\n        priceOracle.updateAssetPrice(tokenAddressIn);\n        priceOracle.updateAssetPrice(tokenAddressOut);\n        (amountConvertedMantissa, amountOutMantissa) = getAmountOut(amountInMantissa, tokenAddressIn, tokenAddressOut);\n    }\n\n    /// @notice To get the amount of tokenAddressIn tokens sender would send on receiving amountOutMantissa tokens of tokenAddressOut\n    /// @param amountOutMantissa Amount of tokenAddressOut user wants to receive\n    /// @param tokenAddressIn Address of the token to convert\n    /// @param tokenAddressOut Address of the token to get after convert\n    /// @return amountConvertedMantissa Amount of tokenAddressOut should be transferred after convert\n    /// @return amountInMantissa Amount of the tokenAddressIn sender would send to contract before convert\n    /// @custom:error InsufficientInputAmount error is thrown when given input amount is zero\n    /// @custom:error ConversionConfigNotEnabled is thrown when convert is disabled or config does not exist for given pair\n    function getUpdatedAmountIn(\n        uint256 amountOutMantissa,\n        address tokenAddressIn,\n        address tokenAddressOut\n    ) public returns (uint256 amountConvertedMantissa, uint256 amountInMantissa) {\n        priceOracle.updateAssetPrice(tokenAddressIn);\n        priceOracle.updateAssetPrice(tokenAddressOut);\n        (amountConvertedMantissa, amountInMantissa) = getAmountIn(amountOutMantissa, tokenAddressIn, tokenAddressOut);\n    }\n\n    /// @notice To get the amount of tokenAddressOut tokens sender could receive on providing amountInMantissa tokens of tokenAddressIn\n    /// @dev This function retrieves values without altering token prices.\n    /// @param amountInMantissa Amount of tokenAddressIn\n    /// @param tokenAddressIn Address of the token to convert\n    /// @param tokenAddressOut Address of the token to get after convert\n    /// @return amountConvertedMantissa Amount of tokenAddressIn should be transferred after convert\n    /// @return amountOutMantissa Amount of the tokenAddressOut sender should receive after convert\n    /// @custom:error InsufficientInputAmount error is thrown when given input amount is zero\n    /// @custom:error ConversionConfigNotEnabled is thrown when convert is disabled or config does not exist for given pair\n    function getAmountOut(\n        uint256 amountInMantissa,\n        address tokenAddressIn,\n        address tokenAddressOut\n    ) public view returns (uint256 amountConvertedMantissa, uint256 amountOutMantissa) {\n        if (amountInMantissa == 0) {\n            revert InsufficientInputAmount();\n        }\n\n        ConversionConfig memory configuration = convertConfigurations[tokenAddressIn][tokenAddressOut];\n\n        if (!configuration.enabled) {\n            revert ConversionConfigNotEnabled();\n        }\n\n        uint256 maxTokenOutReserve = balanceOf(tokenAddressOut);\n        uint256 tokenInUnderlyingPrice = priceOracle.getPrice(tokenAddressIn);\n        uint256 tokenOutUnderlyingPrice = priceOracle.getPrice(tokenAddressOut);\n\n        /// amount of tokenAddressOut after including incentive\n        uint256 conversionWithIncentive = MANTISSA_ONE + configuration.incentive;\n        /// conversion rate after considering incentive(conversionWithIncentive)\n        uint256 tokenInToOutConversion = (tokenInUnderlyingPrice * conversionWithIncentive) / tokenOutUnderlyingPrice;\n\n        amountOutMantissa = (amountInMantissa * tokenInToOutConversion) / EXP_SCALE;\n        amountConvertedMantissa = amountInMantissa;\n\n        /// If contract has less liquity for tokenAddressOut than amountOutMantissa\n        if (maxTokenOutReserve < amountOutMantissa) {\n            amountConvertedMantissa =\n                ((maxTokenOutReserve * EXP_SCALE) + tokenInToOutConversion - 1) /\n                tokenInToOutConversion; //round-up\n            amountOutMantissa = maxTokenOutReserve;\n        }\n    }\n\n    /// @notice To get the amount of tokenAddressIn tokens sender would send on receiving amountOutMantissa tokens of tokenAddressOut\n    /// @dev This function retrieves values without altering token prices.\n    /// @param amountOutMantissa Amount of tokenAddressOut user wants to receive\n    /// @param tokenAddressIn Address of the token to convert\n    /// @param tokenAddressOut Address of the token to get after convert\n    /// @return amountConvertedMantissa Amount of tokenAddressOut should be transferred after convert\n    /// @return amountInMantissa Amount of the tokenAddressIn sender would send to contract before convert\n    /// @custom:error InsufficientInputAmount error is thrown when given input amount is zero\n    /// @custom:error ConversionConfigNotEnabled is thrown when convert is disabled or config does not exist for given pair\n    function getAmountIn(\n        uint256 amountOutMantissa,\n        address tokenAddressIn,\n        address tokenAddressOut\n    ) public view returns (uint256 amountConvertedMantissa, uint256 amountInMantissa) {\n        if (amountOutMantissa == 0) {\n            revert InsufficientInputAmount();\n        }\n\n        ConversionConfig memory configuration = convertConfigurations[tokenAddressIn][tokenAddressOut];\n\n        if (!configuration.enabled) {\n            revert ConversionConfigNotEnabled();\n        }\n\n        uint256 maxTokenOutReserve = balanceOf(tokenAddressOut);\n        uint256 tokenInUnderlyingPrice = priceOracle.getPrice(tokenAddressIn);\n        uint256 tokenOutUnderlyingPrice = priceOracle.getPrice(tokenAddressOut);\n\n        /// amount of tokenAddressOut after including incentive\n        uint256 conversionWithIncentive = MANTISSA_ONE + configuration.incentive;\n        /// conversion rate after considering incentive(conversionWithIncentive)\n        uint256 tokenInToOutConversion = (tokenInUnderlyingPrice * conversionWithIncentive) / tokenOutUnderlyingPrice;\n\n        /// If contract has less liquity for tokenAddressOut than amountOutMantissa\n        if (maxTokenOutReserve < amountOutMantissa) {\n            amountInMantissa = ((maxTokenOutReserve * EXP_SCALE) + tokenInToOutConversion - 1) / tokenInToOutConversion; //round-up\n            amountConvertedMantissa = maxTokenOutReserve;\n        } else {\n            amountInMantissa = ((amountOutMantissa * EXP_SCALE) + tokenInToOutConversion - 1) / tokenInToOutConversion; //round-up\n            amountConvertedMantissa = amountOutMantissa;\n        }\n    }\n\n    /// @notice Get the balance for specific token\n    /// @param token Address of the token\n    function balanceOf(address token) public view virtual returns (uint256 tokenBalance) {}\n\n    /// @notice Operations to perform after sweepToken\n    /// @param token Address of the token\n    /// @param amount Amount transferred to address(to)\n    function postSweepToken(address token, uint256 amount) internal virtual {}\n\n    /// @notice Convert exact amount of tokenAddressIn for tokenAddressOut\n    /// @param amountInMantissa Amount of tokenAddressIn\n    /// @param amountOutMinMantissa Min amount of tokenAddressOut required as output\n    /// @param tokenAddressIn Address of the token to convert\n    /// @param tokenAddressOut Address of the token to get after convert\n    /// @param to Address of the tokenAddressOut receiver\n    /// @return actualAmountIn Actual amount of tokenAddressIn transferred\n    /// @return amountConvertedMantissa Amount of tokenAddressIn supposed to get transferred\n    /// @return actualAmountOut Actual amount of tokenAddressOut transferred\n    /// @return amountOutMantissa Amount of tokenAddressOut supposed to get transferred\n    /// @custom:error AmountOutLowerThanMinRequired error is thrown when amount of output tokenAddressOut is less than amountOutMinMantissa\n    function _convertExactTokensForTokens(\n        uint256 amountInMantissa,\n        uint256 amountOutMinMantissa,\n        address tokenAddressIn,\n        address tokenAddressOut,\n        address to\n    )\n        internal\n        returns (\n            uint256 actualAmountIn,\n            uint256 amountConvertedMantissa,\n            uint256 actualAmountOut,\n            uint256 amountOutMantissa\n        )\n    {\n        (amountConvertedMantissa, amountOutMantissa) = getUpdatedAmountOut(\n            amountInMantissa,\n            tokenAddressIn,\n            tokenAddressOut\n        );\n\n        if (amountOutMantissa < amountOutMinMantissa) {\n            revert AmountOutLowerThanMinRequired(amountOutMantissa, amountOutMinMantissa);\n        }\n        (actualAmountIn, actualAmountOut) = _actualAmounts(\n            tokenAddressIn,\n            tokenAddressOut,\n            to,\n            amountConvertedMantissa,\n            amountOutMantissa\n        );\n    }\n\n    /// @notice Convert tokens for tokenAddressIn for exact amount of tokenAddressOut\n    /// @param amountInMaxMantissa Max amount of tokenAddressIn\n    /// @param amountOutMantissa Amount of tokenAddressOut required as output\n    /// @param tokenAddressIn Address of the token to convert\n    /// @param tokenAddressOut Address of the token to get after convert\n    /// @param to Address of the tokenAddressOut receiver\n    /// @return actualAmountIn Actual amount of tokenAddressIn transferred\n    /// @return amountInMantissa Amount of tokenAddressIn supposed to get transferred\n    /// @return actualAmountOut Actual amount of tokenAddressOut transferred\n    /// @return amountConvertedMantissa Amount of tokenAddressOut supposed to get transferred\n    /// @custom:error AmountInHigherThanMax error is thrown when amount of tokenAddressIn is higher than amountInMaxMantissa\n    function _convertForExactTokens(\n        uint256 amountInMaxMantissa,\n        uint256 amountOutMantissa,\n        address tokenAddressIn,\n        address tokenAddressOut,\n        address to\n    )\n        internal\n        returns (\n            uint256 actualAmountIn,\n            uint256 amountInMantissa,\n            uint256 actualAmountOut,\n            uint256 amountConvertedMantissa\n        )\n    {\n        (amountConvertedMantissa, amountInMantissa) = getUpdatedAmountIn(\n            amountOutMantissa,\n            tokenAddressIn,\n            tokenAddressOut\n        );\n\n        if (amountInMantissa > amountInMaxMantissa) {\n            revert AmountInHigherThanMax(amountInMantissa, amountInMaxMantissa);\n        }\n        (actualAmountIn, actualAmountOut) = _actualAmounts(\n            tokenAddressIn,\n            tokenAddressOut,\n            to,\n            amountInMantissa,\n            amountConvertedMantissa\n        );\n    }\n\n    /// @notice return actualAmounts from reserves for tokenAddressIn and tokenAddressOut\n    /// @param tokenAddressIn Address of the token to convert\n    /// @param tokenAddressOut Address of the token to get after convert\n    /// @param to Address of the tokenAddressOut receiver\n    /// @param amountInMantissa Amount of tokenAddressIn supposed to get transferred\n    /// @param amountConvertedMantissa Amount of tokenAddressOut supposed to get transferred\n    /// @return actualAmountIn Actual amount of tokenAddressIn transferred\n    /// @return actualAmountOut Actual amount of tokenAddressOut transferred\n    function _actualAmounts(\n        address tokenAddressIn,\n        address tokenAddressOut,\n        address to,\n        uint256 amountInMantissa,\n        uint256 amountConvertedMantissa\n    ) internal returns (uint256 actualAmountIn, uint256 actualAmountOut) {\n        IERC20Upgradeable tokenIn = IERC20Upgradeable(tokenAddressIn);\n        uint256 balanceBeforeDestination = tokenIn.balanceOf(destinationAddress);\n        tokenIn.safeTransferFrom(msg.sender, destinationAddress, amountInMantissa);\n        uint256 balanceAfterDestination = tokenIn.balanceOf(destinationAddress);\n\n        IERC20Upgradeable tokenOut = IERC20Upgradeable(tokenAddressOut);\n        uint256 balanceBeforeTo = tokenOut.balanceOf(to);\n        tokenOut.safeTransfer(to, amountConvertedMantissa);\n        uint256 balanceAfterTo = tokenOut.balanceOf(to);\n\n        actualAmountIn = balanceAfterDestination - balanceBeforeDestination;\n        actualAmountOut = balanceAfterTo - balanceBeforeTo;\n    }\n\n    /// @notice Sets a new price oracle\n    /// @param priceOracle_ Address of the new price oracle to set\n    /// @custom:event Emits PriceOracleUpdated event on success\n    /// @custom:error ZeroAddressNotAllowed is thrown when price oracle address is zero\n    function _setPriceOracle(ResilientOracle priceOracle_) internal {\n        ensureNonzeroAddress(address(priceOracle_));\n\n        ResilientOracle oldPriceOracle = priceOracle;\n        priceOracle = priceOracle_;\n\n        emit PriceOracleUpdated(oldPriceOracle, priceOracle);\n    }\n\n    /// @notice Sets a new destination address\n    /// @param destinationAddress_ Address of the new price oracle to set\n    /// @custom:event Emits DestinationAddressUpdated event on success\n    /// @custom:error ZeroAddressNotAllowed is thrown when destination address is zero\n    function _setDestination(address destinationAddress_) internal {\n        ensureNonzeroAddress(destinationAddress_);\n\n        address oldDestinationAddress = destinationAddress;\n        destinationAddress = destinationAddress_;\n\n        emit DestinationAddressUpdated(oldDestinationAddress, destinationAddress);\n    }\n\n    /// @notice Hook to perform after converting tokens\n    /// @param tokenInAddress Address of the token\n    /// @param amountIn Amount of tokenIn converted\n    /// @param amountOut Amount of tokenOut converted\n    function postConversionHook(\n        address tokenInAddress,\n        address tokenAddressOut,\n        uint256 amountIn,\n        uint256 amountOut\n    ) internal virtual {}\n\n    /// @param accessControlManager_ Access control manager contract address\n    /// @param priceOracle_ Resilient oracle address\n    /// @param destinationAddress_  Address at all incoming tokens will transferred to\n    function __AbstractTokenConverter_init(\n        address accessControlManager_,\n        ResilientOracle priceOracle_,\n        address destinationAddress_\n    ) internal onlyInitializing {\n        __AccessControlled_init(accessControlManager_);\n        __ReentrancyGuard_init();\n        __AbstractTokenConverter_init_unchained(priceOracle_, destinationAddress_);\n    }\n\n    /// @param priceOracle_ Resilient oracle address\n    /// @param destinationAddress_  Address at all incoming tokens will transferred to\n    function __AbstractTokenConverter_init_unchained(\n        ResilientOracle priceOracle_,\n        address destinationAddress_\n    ) internal onlyInitializing {\n        _setPriceOracle(priceOracle_);\n        _setDestination(destinationAddress_);\n        conversionPaused = false;\n    }\n\n    /// @notice To check, is convert paused\n    function _checkConversionPaused() internal view {\n        if (conversionPaused) {\n            revert ConversionTokensPaused();\n        }\n    }\n}"
    }
  ]
}