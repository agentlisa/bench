{
  "Title": "H-7: `reportOutOfOrderValidatorExits` does not updates the heap order",
  "Content": "# Issue H-7: `reportOutOfOrderValidatorExits` does not updates the heap order \n\nSource: https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/131 \n\n## Found by \nComposableSecurity, g, mstpr-brainbot\n## Summary\nWhen an operator's validator exits without a withdrawal request, the owner can invoke the `reportOutOfOrderValidatorExits` function to increase the `exited` portion of the operator validators. However, this action does not update the heap. Consequently, during subsequent allocation or deallocation processes, the heap may incorrectly mark validators as exited.\n## Vulnerability Detail\nFirst, let's see how the utilization is determined for native ETH deposits for operators which is calculated as:\n`operatorShares.allocation.divWad(operatorShares.cap)` where as the allocation is the total `deposited` validators and the `cap` is predetermined value by the owner of the registry.\n\nWhen the heap is retrieved from the storage, here how it is fetched:\n```solidity\nfunction getOperatorUtilizationHeapForETH(RioLRTOperatorRegistryStorageV1.StorageV1 storage s)\n        internal\n        view\n        returns (OperatorUtilizationHeap.Data memory heap)\n    {\n        uint8 numActiveOperators = s.activeOperatorCount;\n        if (numActiveOperators == 0) return OperatorUtilizationHeap.Data(new OperatorUtilizationHeap.Operator[](0), 0);\n\n        heap = OperatorUtilizationHeap.initialize(MAX_ACTIVE_OPERATOR_COUNT);\n\n        uint256 activeDeposits;\n        IRioLRTOperatorRegistry.OperatorValidatorDetails memory validators;\n        unchecked {\n            uint8 i;\n            for (i = 0; i < numActiveOperators; ++i) {\n                uint8 operatorId = s.activeOperatorsByETHDepositUtilization.get(i);\n\n                // Non-existent operator ID. We've reached the end of the heap.\n                if (operatorId == 0) break;\n\n                validators = s.operatorDetails[operatorId].validatorDetails;\n                activeDeposits = validators.deposited - validators.exited;\n                heap.operators[i + 1] = OperatorUtilizationHeap.Operator({\n                    id: operatorId,\n                    utilization: activeDeposits.divWad(validators.cap)\n                });\n            }\n            heap.count = i;\n        }\n    }\n```\nas we can see, the heap is always assumed to be order in the storage when the registry fetches it initially. There are no ordering of the heap when requesting the heap initially.\n\nWhen, say the deallocation happens via an user withdrawal request, the queue can exit early if the operator in the heap has \"0\" room:\n```solidity\n function deallocateETHDeposits(uint256 depositsToDeallocate) external onlyCoordinator returns (uint256 depositsDeallocated, OperatorETHDeallocation[] memory deallocations) {\n        deallocations = new OperatorETHDeallocation[](s.activeOperatorCount);\n\n\n        OperatorUtilizationHeap.Data memory heap = s.getOperatorUtilizationHeapForETH();\n        if (heap.isEmpty()) revert NO_AVAILABLE_OPERATORS_FOR_DEALLOCATION();\n\n\n        uint256 deallocationIndex;\n        uint256 remainingDeposits = depositsToDeallocate;\n\n\n        bytes memory pubKeyBatch;\n        while (remainingDeposits > 0) {\n            uint8 operatorId = heap.getMax().id;\n\n\n            OperatorDetails storage operator = s.operatorDetails[operatorId];\n            OperatorValidatorDetails memory validators = operator.validatorDetails;\n            -> uint256 activeDeposits = validators.deposited - validators.exited;\n\n\n            // Exit early if the operator with the highest utilization rate has no active deposits,\n            // as no further deallocations can be made.\n            -> if (activeDeposits == 0) break;\n             .\n        }\n        .\n    }\n```\n\n`reportOutOfOrderValidatorExits` increases the \"exited\" part of the operators validator:\n```solidity\nfunction reportOutOfOrderValidatorExits(uint8 operatorId, uint256 fromIndex, uint256 validatorCount) external {\n       .\n       .\n        // Swap the position of the validators starting from the `fromIndex` with the validators that were next in line to be exited.\n        VALIDATOR_DETAILS_POSITION.swapValidatorDetails(operatorId, fromIndex, validators.exited, validatorCount);\n        -> operator.validatorDetails.exited += uint40(validatorCount);\n\n        emit OperatorOutOfOrderValidatorExitsReported(operatorId, validatorCount);\n    }\n```\n\nNow, knowing all these above, let's do an example where calling `reportOutOfOrderValidatorExits` can make the heap work wrongly and exit prematurely.\n\nAssume there are 3 operators which has native ETH deposits. \noperatorId 1 -> utilization 5%\noperatorId 2 -> utilization 10%\noperatorId 3 -> utilization 15%\n\nsuch operators would be ordered in the heap as:\nheap.operators[1] -> operatorId: 1, utilization: 5\nheap.operators[2] -> operatorId: 2, utilization: 10\nheap.operators[3] -> operatorId: 3, utilization: 15\nheap.getMin() -> operatorId: 1, utilization: 5\nheap.getMax() -> operatorId:3, utilization 15\n\nnow, let's say the \"cap\" is 100 for all of the operators which means that:\noperatorId 1 -> validator.deposits = 5, validator.exit = 0\noperatorId 2 -> validator.deposits = 10, validator.exit = 0\noperatorId 3 -> validator.deposits = 15, validator.exit = 0\n\nLet's assume that the operator 3 exits 15 validator from beacon chain without prior to a user request, which is a reason for owner to call `reportOutOfOrderValidatorExits` to increase the exited validators. \n\nWhen the owner calls `reportOutOfOrderValidatorExits` for the operatorId 3, the exited will be 15 for the operatorId 3. \nAfter the call the operators validator balances will be:\noperatorId 1 -> validator.deposits = 5, validator.exit = 0\noperatorId 2 -> validator.deposits = 10, validator.exit = 8\noperatorId 3 -> validator.deposits = 15, validator.exit = 15\n\nhence, the utilizations will be:\noperatorId 1 -> utilization 5%\noperatorId 2 -> utilization 10%\noperatorId 3 -> utilization 0%\n\nwhich means now the operatorId 3 has the lowest utilization and should be the first to get deposits and last to unwind deposits from. However, the heap is not re-ordered meaning that the minimum in the heap is  still opeartorId 1 and the maximum is still operatorId 3!\n\nNow, when a user tries to withdraw, the first deallocation target will be the operatorId 3 because the heap thinks that it is the most utilized still. \n\nHowever, since the active utilization for operatorId 3 is \"0\" the loop will exit early hence, the withdrawals will not go through\nhttps://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/4f01e065c1ed346875cf5b05d2b43e0bcdb4c849/rio-sherlock-audit/contracts/restaking/RioLRTOperatorRegistry.sol#L556-L560\n\nHence, the user will not be able to request the withdrawal! \n\n**Coded PoC:**\n```solidity\n// forge test --match-contract OperatorUtilizationHeapTest --match-test test_RemovingValidatorMessesTheHeap -vv\n    function test_RemovingValidatorMessesTheHeap() public {\n        OperatorUtilizationHeap.Data memory heap = OperatorUtilizationHeap.initialize(5);\n\n        // @review initialize and order 3 operators \n        heap.insert(OperatorUtilizationHeap.Operator({id: 1, utilization: 5}));\n        heap.store(heapStore);\n\n        heap.insert(OperatorUtilizationHeap.Operator({id: 2, utilization: 10}));\n        heap.store(heapStore);\n\n        heap.insert(OperatorUtilizationHeap.Operator({id: 3, utilization: 15}));\n        heap.store(heapStore);\n\n        // @review mimick how the heap can be fetched from the storage initially\n        uint8 numActiveOperators = 3;\n        OperatorUtilizationHeap.Data memory newHeap = OperatorUtilizationHeap.initialize(64);\n        uint8 i;\n        for (i = 0; i < numActiveOperators; ++i) {\n            uint8 operatorId = heapStore.get(i);\n            if (operatorId == 0) break;\n\n            newHeap.operators[i+1] = OperatorUtilizationHeap.Operator({\n                   id: operatorId,\n                   utilization: heap.operators[operatorId].utilization\n            });\n        }\n        newHeap.count = i;\n\n        // @review assume the reportValidatorAndExits called, and now the utilization is \"0\"\n        heap.updateUtilizationByID(3, 0);\n        // @review this should be done, but the heap is not stored! \n        // heap.store(heapStore);\n\n        console.log(\"1st\", heap.operators[1].id);\n        console.log(\"2nd\", heap.operators[2].id);\n        console.log(\"3rd\", heap.operators[3].id);\n        console.log(\"origin heaps min\", heap.getMin().id);\n        console.log(\"origin heaps max\", heap.getMax().id);\n\n        console.log(\"1st\", newHeap.operators[1].id);\n        console.log(\"2nd\", newHeap.operators[2].id);\n        console.log(\"3rd\", newHeap.operators[3].id);\n        console.log(\"new heaps min\", newHeap.getMin().id);\n        console.log(\"new heaps max\", newHeap.getMax().id);\n\n        // @review mins and maxs are mixed\n        assertEq(newHeap.getMin().id, 1);\n        assertEq(heap.getMin().id, 3);\n        assertEq(heap.getMax().id, 2);\n        assertEq(newHeap.getMax().id, 3);\n    }\n```\n## Impact\nHeap can be mixed, withdrawals and deposits can fail, hence I will label this as high. \n## Code Snippet\nhttps://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/4f01e065c1ed346875cf5b05d2b43e0bcdb4c849/rio-sherlock-audit/contracts/utils/OperatorRegistryV1Admin.sol#L357C5-L386C6\n\nhttps://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/4f01e065c1ed346875cf5b05d2b43e0bcdb4c849/rio-sherlock-audit/contracts/restaking/RioLRTOperatorRegistry.sol#L541-L594\n\nhttps://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/4f01e065c1ed346875cf5b05d2b43e0bcdb4c849/rio-sherlock-audit/contracts/restaking/RioLRTOperatorRegistry.sol#L310-L336\n## Tool used\n\nManual Review\n\n## Recommendation\nupdate the utilization in the reportOutOfOrderValidatorExits function \n\n\n\n## Discussion\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/rio-org/rio-sherlock-audit/pull/10.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/176",
  "Code": [
    {
      "filename": "rio-sherlock-audit/contracts/restaking/RioLRTOperatorRegistry.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.23;\n\nimport {LibMap} from '@solady/utils/LibMap.sol';\nimport {FixedPointMathLib} from '@solady/utils/FixedPointMathLib.sol';\nimport {SafeCast} from '@openzeppelin/contracts/utils/math/SafeCast.sol';\nimport {UpgradeableBeacon} from '@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol';\nimport {UUPSUpgradeable} from '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\nimport {OwnableUpgradeable} from '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport {RioLRTOperatorRegistryStorageV1} from 'contracts/restaking/storage/RioLRTOperatorRegistryStorageV1.sol';\nimport {IRioLRTOperatorDelegator} from 'contracts/interfaces/IRioLRTOperatorDelegator.sol';\nimport {IBeaconChainProofs} from 'contracts/interfaces/eigenlayer/IBeaconChainProofs.sol';\nimport {BLS_PUBLIC_KEY_LENGTH, ETH_DEPOSIT_SIZE} from 'contracts/utils/Constants.sol';\nimport {OperatorRegistryV1Admin} from 'contracts/utils/OperatorRegistryV1Admin.sol';\nimport {OperatorUtilizationHeap} from 'contracts/utils/OperatorUtilizationHeap.sol';\nimport {IStrategy} from 'contracts/interfaces/eigenlayer/IStrategy.sol';\nimport {IEigenPod} from 'contracts/interfaces/eigenlayer/IEigenPod.sol';\nimport {ValidatorDetails} from 'contracts/utils/ValidatorDetails.sol';\nimport {RioLRTCore} from 'contracts/restaking/base/RioLRTCore.sol';\nimport {Memory} from 'contracts/utils/Memory.sol';\nimport {Asset} from 'contracts/utils/Asset.sol';\n\ncontract RioLRTOperatorRegistry is OwnableUpgradeable, UUPSUpgradeable, RioLRTCore, RioLRTOperatorRegistryStorageV1 {\n    using OperatorUtilizationHeap for OperatorUtilizationHeap.Data;\n    using OperatorRegistryV1Admin for StorageV1;\n    using ValidatorDetails for bytes32;\n    using FixedPointMathLib for *;\n    using Asset for address;\n    using LibMap for *;\n\n    /// @dev The validator details storage position.\n    bytes32 internal constant VALIDATOR_DETAILS_POSITION = keccak256('RIO.OPERATOR_REGISTRY.VALIDATOR_DETAILS');\n\n    /// @notice The operator delegator beacon contract.\n    address public immutable operatorDelegatorBeacon;\n\n    /// @notice Require that the caller is the operator's manager.\n    /// @param operatorId The operator's ID.\n    modifier onlyOperatorManager(uint8 operatorId) {\n        if (msg.sender != s.operatorDetails[operatorId].manager) revert ONLY_OPERATOR_MANAGER();\n        _;\n    }\n\n    /// @notice Require that the caller is the operator's manager OR the security daemon's\n    /// wallet that has been configured by the security council.\n    /// @param operatorId The operator's ID.\n    modifier onlyOperatorManagerOrSecurityDaemon(uint8 operatorId) {\n        if (msg.sender != s.operatorDetails[operatorId].manager && msg.sender != s.securityDaemon) {\n            revert ONLY_OPERATOR_MANAGER_OR_SECURITY_DAEMON();\n        }\n        _;\n    }\n\n    /// @notice Require that the caller is the operator's manager OR the proof uploader\n    // wallet that has been configured by the DAO.\n    /// @param operatorId The operator's ID.\n    modifier onlyOperatorManagerOrProofUploader(uint8 operatorId) {\n        if (msg.sender != s.operatorDetails[operatorId].manager && msg.sender != s.proofUploader) {\n            revert ONLY_OPERATOR_MANAGER_OR_PROOF_UPLOADER();\n        }\n        _;\n    }\n\n    /// @param issuer_ The LRT issuer that's authorized to deploy this contract.\n    /// @param initialBeaconOwner The initial owner who can upgrade the operator delegator beacon contract.\n    /// @param operatorDelegatorImpl_ The operator contract implementation.\n    constructor(address issuer_, address initialBeaconOwner, address operatorDelegatorImpl_) RioLRTCore(issuer_) {\n        operatorDelegatorBeacon = address(new UpgradeableBeacon(operatorDelegatorImpl_, initialBeaconOwner));\n    }\n\n    /// @notice Initializes the contract.\n    /// @param initialOwner The initial owner of the contract.\n    /// @param token_ The address of the liquid restaking token.\n    function initialize(address initialOwner, address token_) external initializer {\n        __Ownable_init(initialOwner);\n        __UUPSUpgradeable_init();\n        __RioLRTCore_init(token_);\n\n        s.setValidatorKeyReviewPeriod(1 days);\n    }\n\n    /// @notice Returns the total number of operators in the registry.\n    function operatorCount() external view returns (uint8) {\n        return s.operatorCount;\n    }\n\n    /// @notice Returns the total number of active operators in the registry.\n    function activeOperatorCount() external view returns (uint8) {\n        return s.activeOperatorCount;\n    }\n\n    /// @notice The minimum acceptable delay between an operator signaling intent to register\n    // for an AVS and completing registration.\n    function minStakerOptOutBlocks() external view returns (uint24) {\n        return s.minStakerOptOutBlocks;\n    }\n\n    /// @notice The security daemon, which is responsible for removal of duplicate\n    /// or invalid validator keys.\n    function securityDaemon() external view returns (address) {\n        return s.securityDaemon;\n    }\n\n    /// @notice The amount of time (in seconds) before uploaded validator keys are considered \"vetted\".\n    function validatorKeyReviewPeriod() external view returns (uint24) {\n        return s.validatorKeyReviewPeriod;\n    }\n\n    /// @notice Returns the operator details for the provided operator ID.\n    /// @param operatorId The operator's ID.\n    function getOperatorDetails(uint8 operatorId) external view returns (OperatorPublicDetails memory) {\n        OperatorDetails storage operator = s.operatorDetails[operatorId];\n        return OperatorPublicDetails(\n            operator.active,\n            operator.delegator,\n            operator.manager,\n            operator.pendingManager,\n            operator.earningsReceiver,\n            operator.validatorDetails\n        );\n    }\n\n    // forgefmt: disable-next-item\n    /// @notice Returns the operator's share details for the provided operator ID and strategy.\n    /// @param operatorId The operator's ID.\n    /// @param strategy The strategy to get the share details for.\n    function getOperatorShareDetails(uint8 operatorId, address strategy) external view returns (OperatorShareDetails memory) {\n        return s.operatorDetails[operatorId].shareDetails[strategy];\n    }\n\n    // forgefmt: disable-next-item\n    /// @notice Adds a new operator to the registry, deploying a delegator contract and\n    /// delegating to the provided operator address.\n    /// @param config The new operator's configuration.\n    function addOperator(OperatorConfig calldata config) external onlyOwner returns (uint8 operatorId, address delegator) {\n        return s.addOperator(address(token), operatorDelegatorBeacon, config);\n    }\n\n    /// @notice Activates an operator.\n    /// @param operatorId The operator's ID.\n    function activateOperator(uint8 operatorId) external onlyOwner {\n        s.activateOperator(operatorId);\n    }\n\n    /// Deactivates an operator, exiting all remaining stake to the\n    /// asset manager.\n    /// @param operatorId The operator's ID.\n    function deactivateOperator(uint8 operatorId) external onlyOwner {\n        s.deactivateOperator(assetRegistry(), operatorId);\n    }\n\n    // forgefmt: disable-next-item\n    /// @notice Sets the operator's strategy share allocation caps.\n    /// @param operatorId The operator's ID.\n    /// @param newStrategyShareCaps The new strategy share allocation caps.\n    function setOperatorStrategyShareCaps(uint8 operatorId, StrategyShareCap[] calldata newStrategyShareCaps) external onlyOwner {\n        s.setOperatorStrategyShareCaps(operatorId, newStrategyShareCaps);\n    }\n\n    /// @notice Sets the operator's maximum active validator cap.\n    /// @param operatorId The operator's ID.\n    /// @param newValidatorCap The new maximum active validator cap.\n    function setOperatorValidatorCap(uint8 operatorId, uint40 newValidatorCap) external onlyOwner {\n        s.setOperatorValidatorCap(operatorId, newValidatorCap);\n    }\n\n    /// @notice Sets the security daemon to a new account (`newSecurityDaemon`).\n    /// @param newSecurityDaemon The new security daemon address.\n    function setSecurityDaemon(address newSecurityDaemon) external onlyOwner {\n        s.setSecurityDaemon(newSecurityDaemon);\n    }\n\n    /// @notice Sets the proof uploader to a new account (`newSecurityDaemon`).\n    /// @param newProofUploader The new proof uploader address.\n    function setProofUploader(address newProofUploader) external onlyOwner {\n        s.setProofUploader(newProofUploader);\n    }\n\n    /// @notice Sets the minimum acceptable delay between an operator signaling intent to register\n    // for an AVS and completing registration.\n    /// @param newMinStakerOptOutBlocks The new min staker opt out blocks.\n    function setMinStakerOptOutBlocks(uint24 newMinStakerOptOutBlocks) external onlyOwner {\n        s.setMinStakerOptOutBlocks(newMinStakerOptOutBlocks);\n    }\n\n    /// @notice Sets the amount of time (in seconds) before uploaded validator keys are considered \"vetted\".\n    /// @param newValidatorKeyReviewPeriod The new validator key review period.\n    function setValidatorKeyReviewPeriod(uint24 newValidatorKeyReviewPeriod) external onlyOwner {\n        s.setValidatorKeyReviewPeriod(newValidatorKeyReviewPeriod);\n    }\n\n    // forgefmt: disable-next-item\n    /// @notice Sets an operator's earnings receiver.\n    /// @param operatorId The operator's ID.\n    /// @param newEarningsReceiver The new reward address of the operator.\n    function setOperatorEarningsReceiver(uint8 operatorId, address newEarningsReceiver) external onlyOperatorManager(operatorId) {\n        if (newEarningsReceiver == address(0)) revert INVALID_EARNINGS_RECEIVER();\n        s.operatorDetails[operatorId].earningsReceiver = newEarningsReceiver;\n\n        emit OperatorEarningsReceiverSet(operatorId, newEarningsReceiver);\n    }\n\n    // forgefmt: disable-next-item\n    /// @notice Sets an operator's pending manager.\n    /// @param operatorId The operator's ID.\n    /// @param newPendingManager The new pending manager of the operator.\n    function setOperatorPendingManager(uint8 operatorId, address newPendingManager) external onlyOperatorManager(operatorId) {\n        if (newPendingManager == address(0)) revert INVALID_PENDING_MANAGER();\n        s.operatorDetails[operatorId].pendingManager = newPendingManager;\n\n        emit OperatorPendingManagerSet(operatorId, newPendingManager);\n    }\n\n    /// @notice Confirms an operator's pending manager.\n    /// @param operatorId The operator's ID.\n    function confirmOperatorManager(uint8 operatorId) external {\n        address sender = msg.sender;\n\n        OperatorDetails storage operator = s.operatorDetails[operatorId];\n        if (sender != operator.pendingManager) revert ONLY_OPERATOR_PENDING_MANAGER();\n\n        delete operator.pendingManager;\n        operator.manager = sender;\n\n        emit OperatorManagerSet(operatorId, sender);\n    }\n\n    /// @notice Verifies withdrawal credentials of validator(s) owned by the provided\n    /// operator's EigenPod. It also verifies the effective balance of the validator(s).\n    /// @param operatorId The operator's ID.\n    /// @param oracleTimestamp The timestamp of the oracle that submitted the proof.\n    /// @param stateRootProof The state root proof.\n    /// @param validatorIndices The indices of the validators to verify.\n    /// @param validatorFieldsProofs The validator fields proofs.\n    /// @param validatorFields The validator fields.\n    function verifyWithdrawalCredentials(\n        uint8 operatorId,\n        uint64 oracleTimestamp,\n        IBeaconChainProofs.StateRootProof calldata stateRootProof,\n        uint40[] calldata validatorIndices,\n        bytes[] calldata validatorFieldsProofs,\n        bytes32[][] calldata validatorFields\n    ) external onlyOperatorManagerOrProofUploader(operatorId) {\n        OperatorDetails storage operator = s.operatorDetails[operatorId];\n        IRioLRTOperatorDelegator(operator.delegator).verifyWithdrawalCredentials(\n            oracleTimestamp, stateRootProof, validatorIndices, validatorFieldsProofs, validatorFields\n        );\n\n        // Once verified, shares are tracked as EigenPod shares.\n        assetRegistry().decreaseUnverifiedValidatorETHBalance(validatorIndices.length * ETH_DEPOSIT_SIZE);\n\n        emit OperatorWithdrawalCredentialsVerified(operatorId, oracleTimestamp, validatorIndices);\n    }\n\n    /// @notice Adds pending validator details (public keys and signatures) to storage for the provided operator.\n    /// Each added batch extends the timestamp at which the details will be considered confirmed.\n    /// @param operatorId The operator's ID.\n    /// @param validatorCount The number of validators in the batch.\n    /// @param publicKeys The validator public keys.\n    /// @param signatures The validator signatures.\n    function addValidatorDetails(\n        uint8 operatorId,\n        uint256 validatorCount,\n        bytes calldata publicKeys,\n        bytes calldata signatures\n    ) external onlyOperatorManager(operatorId) {\n        OperatorDetails storage operator = s.operatorDetails[operatorId];\n        OperatorValidatorDetails memory validators = operator.validatorDetails;\n\n        if (validatorCount == 0) revert INVALID_VALIDATOR_COUNT();\n\n        // First check if there are any pending validator details that can be moved into a confirmed state.\n        if (validators.total > validators.confirmed && block.timestamp >= validators.nextConfirmationTimestamp) {\n            operator.validatorDetails.confirmed = validators.confirmed = validators.total;\n        }\n\n        operator.validatorDetails.total = VALIDATOR_DETAILS_POSITION.saveValidatorDetails(\n            operatorId, validators.total, validatorCount, publicKeys, signatures\n        );\n        operator.validatorDetails.nextConfirmationTimestamp = uint40(block.timestamp + s.validatorKeyReviewPeriod);\n\n        emit OperatorPendingValidatorDetailsAdded(operatorId, validatorCount);\n    }\n\n    // forgefmt: disable-next-item\n    /// @notice Removes pending validator details (public keys and signatures) from storage for the provided operator.\n    /// @param operatorId The operator's ID.\n    /// @param fromIndex The index of the first validator to remove.\n    /// @param validatorCount The number of validator to remove.\n    function removeValidatorDetails(uint8 operatorId, uint256 fromIndex, uint256 validatorCount)\n        external\n        onlyOperatorManagerOrSecurityDaemon(operatorId)\n    {\n        OperatorDetails storage operator = s.operatorDetails[operatorId];\n        OperatorValidatorDetails memory validators = operator.validatorDetails;\n\n        if (validatorCount == 0) revert INVALID_VALIDATOR_COUNT();\n        if (fromIndex < validators.confirmed || fromIndex + validatorCount > validators.total) revert INVALID_INDEX();\n\n        operator.validatorDetails.total = VALIDATOR_DETAILS_POSITION.removeValidatorDetails(\n            operatorId, fromIndex, validatorCount, validators.total\n        );\n        emit OperatorPendingValidatorDetailsRemoved(operatorId, validatorCount);\n    }\n\n    /// @notice Reports validator exits that occur prior to instruction by the protocol.\n    /// @param operatorId The operator's ID.\n    /// @param fromIndex The index of the first validator to report.\n    /// @param validatorCount The number of validators to report.\n    function reportOutOfOrderValidatorExits(uint8 operatorId, uint256 fromIndex, uint256 validatorCount) external {\n        OperatorDetails storage operator = s.operatorDetails[operatorId];\n        OperatorValidatorDetails memory validators = operator.validatorDetails;\n\n        if (fromIndex < validators.exited || fromIndex + validatorCount > validators.deposited) revert INVALID_INDEX();\n\n        bytes memory exitedPubKeyBatch = ValidatorDetails.allocateMemoryForPubKeys(validatorCount);\n        VALIDATOR_DETAILS_POSITION.loadValidatorDetails(\n            operatorId, fromIndex, validatorCount, exitedPubKeyBatch, new bytes(0), 0\n        );\n\n        // Verify that all validators have exited.\n        IEigenPod pod = IRioLRTOperatorDelegator(operator.delegator).eigenPod();\n        bytes memory publicKey = Memory.unsafeAllocateBytes(BLS_PUBLIC_KEY_LENGTH);\n        for (uint256 i = 0; i < validatorCount; ++i) {\n            Memory.copyBytes(exitedPubKeyBatch, publicKey, i * BLS_PUBLIC_KEY_LENGTH, 0, BLS_PUBLIC_KEY_LENGTH);\n            if (pod.validatorStatus(_hashValidatorBLSPubKey(publicKey)) != IEigenPod.VALIDATOR_STATUS.WITHDRAWN) {\n                revert VALIDATOR_NOT_EXITED();\n            }\n        }\n\n        // Swap the position of the validators starting from the `fromIndex` with the validators that were next in line to be exited.\n        VALIDATOR_DETAILS_POSITION.swapValidatorDetails(operatorId, fromIndex, validators.exited, validatorCount);\n        operator.validatorDetails.exited += uint40(validatorCount);\n\n        emit OperatorOutOfOrderValidatorExitsReported(operatorId, validatorCount);\n    }\n\n    // forgefmt: disable-next-item\n    /// @notice Allocates a specified amount of shares for the provided strategy to the operators with the lowest utilization.\n    /// @param strategy The strategy to allocate the shares to.\n    /// @param sharesToAllocate The amount of shares to allocate.\n    function allocateStrategyShares(address strategy, uint256 sharesToAllocate) external onlyDepositPool returns (uint256 sharesAllocated, OperatorStrategyAllocation[] memory allocations) {\n        OperatorUtilizationHeap.Data memory heap = s.getOperatorUtilizationHeapForStrategy(strategy);\n        if (heap.isEmpty()) {\n            return (sharesAllocated, allocations);\n        }\n\n        uint256 allocationIndex;\n        uint256 remainingShares = sharesToAllocate;\n\n        allocations = new OperatorStrategyAllocation[](s.activeOperatorCount);\n        while (remainingShares > 0) {\n            uint8 operatorId = heap.getMin().id;\n\n            OperatorDetails storage operator = s.operatorDetails[operatorId];\n            OperatorShareDetails memory operatorShares = operator.shareDetails[strategy];\n\n            // If the allocation of the operator with the lowest utilization rate is maxed out,\n            // then exit early. We will not be able to allocate to any other operators.\n            if (operatorShares.allocation >= operatorShares.cap) break;\n\n            uint256 newShareAllocation = FixedPointMathLib.min(operatorShares.cap - operatorShares.allocation, remainingShares);\n            uint256 newTokenAllocation = IStrategy(strategy).sharesToUnderlyingView(newShareAllocation);\n            allocations[allocationIndex] = OperatorStrategyAllocation(\n                operator.delegator,\n                newShareAllocation,\n                newTokenAllocation\n            );\n            remainingShares -= newShareAllocation;\n\n            uint128 updatedAllocation = operatorShares.allocation + SafeCast.toUint128(newShareAllocation);\n\n            operator.shareDetails[strategy].allocation = updatedAllocation;\n            heap.updateUtilization(OperatorUtilizationHeap.ROOT_INDEX, updatedAllocation.divWad(operatorShares.cap));\n\n            emit StrategySharesAllocated(operatorId, strategy, newShareAllocation, newTokenAllocation);\n\n            unchecked {\n                ++allocationIndex;\n            }\n        }\n        sharesAllocated = sharesToAllocate - remainingShares;\n\n        heap.store(s.activeOperatorsByStrategyShareUtilization[strategy]);\n\n        // Shrink the array length to the number of allocations made.\n        if (allocationIndex < s.activeOperatorCount) {\n            assembly {\n                mstore(allocations, allocationIndex)\n            }\n        }\n    }\n\n    // forgefmt: disable-next-item\n    /// @notice Allocates a specified amount of ETH deposits to the operators with the lowest utilization.\n    /// @param depositsToAllocate The amount of deposits to allocate (32 ETH each)\n    function allocateETHDeposits(uint256 depositsToAllocate) external onlyDepositPool returns (uint256 depositsAllocated, OperatorETHAllocation[] memory allocations) {\n        OperatorUtilizationHeap.Data memory heap = s.getOperatorUtilizationHeapForETH();\n        if (heap.isEmpty()) {\n            return (depositsAllocated, allocations);\n        }\n\n        uint256 allocationIndex;\n        uint256 remainingDeposits = depositsToAllocate;\n\n        uint8 skippedOperatorCount;\n        OperatorUtilizationHeap.Operator[] memory skippedOperators = new OperatorUtilizationHeap.Operator[](heap.count);\n\n        bytes memory pubKeyBatch;\n        bytes memory signatureBatch;\n        allocations = new OperatorETHAllocation[](s.activeOperatorCount);\n        while (remainingDeposits > 0 && !heap.isEmpty()) {\n            uint8 operatorId = heap.getMin().id;\n\n            OperatorDetails storage operator = s.operatorDetails[operatorId];\n            OperatorValidatorDetails memory validators = operator.validatorDetails;\n            uint256 activeDeposits = validators.deposited - validators.exited;\n\n            // If the current deposited validator count of the operator is greater than or equal to its cap,\n            // then exit early. We will not be able to allocate to any other operators.\n            if (activeDeposits >= validators.cap) break;\n\n            // If the total number of uploaded keys is greater than the number of confirmed keys AND the\n            // current timestamp is greater than or equal to the next confirmation timestamp, mark all pending keys\n            // as confirmed.\n            if (validators.total > validators.confirmed && block.timestamp >= validators.nextConfirmationTimestamp) {\n                operator.validatorDetails.confirmed = validators.confirmed = validators.total;\n            }\n\n            // We can only allocate to confirmed keys that have not yet received a deposit.\n            uint256 unallocatedConfirmedKeys = validators.confirmed - validators.deposited;\n            if (unallocatedConfirmedKeys == 0) {\n                skippedOperators[skippedOperatorCount++] = heap.extractMin();\n                continue;\n            }\n\n            // Each allocation is a 32 ETH deposit. We can only allocate up to the number of unallocated confirmed keys.\n            uint256 updatedAllocation;\n            {\n                uint256 newDepositAllocation = FixedPointMathLib.min(\n                    FixedPointMathLib.min(validators.cap - activeDeposits, unallocatedConfirmedKeys), remainingDeposits\n                );\n\n                // Load the allocated validator details from storage and update the deposited validator count.\n                (pubKeyBatch, signatureBatch) = ValidatorDetails.allocateMemory(newDepositAllocation);\n                VALIDATOR_DETAILS_POSITION.loadValidatorDetails(\n                    operatorId, validators.deposited, newDepositAllocation, pubKeyBatch, signatureBatch, 0\n                );\n                operator.validatorDetails.deposited += uint40(newDepositAllocation);\n\n                allocations[allocationIndex] = OperatorETHAllocation(operator.delegator, newDepositAllocation, pubKeyBatch, signatureBatch);\n                remainingDeposits -= newDepositAllocation;\n\n                updatedAllocation = activeDeposits + newDepositAllocation;\n\n                emit ETHDepositsAllocated(operatorId, newDepositAllocation, pubKeyBatch);\n            }\n            heap.updateUtilization(OperatorUtilizationHeap.ROOT_INDEX, updatedAllocation.divWad(validators.cap));\n\n            unchecked {\n                ++allocationIndex;\n            }\n        }\n        depositsAllocated = depositsToAllocate - remainingDeposits;\n        if (depositsAllocated == 0) {\n            return (depositsAllocated, new OperatorETHAllocation[](0));\n        }\n\n        // Reinsert skipped operators back into the heap.\n        for (uint256 i = 0; i < skippedOperatorCount; ++i) {\n            heap.insert(skippedOperators[i]);\n        }\n        heap.store(s.activeOperatorsByETHDepositUtilization);\n\n        // Shrink the array length to the number of allocations made.\n        if (allocationIndex < s.activeOperatorCount) {\n            assembly {\n                mstore(allocations, allocationIndex)\n            }\n        }\n    }\n\n    // forgefmt: disable-next-item\n    /// @notice Deallocates a specified amount of shares for the provided strategy from the operators with the highest utilization.\n    /// @param strategy The strategy to deallocate the shares from.\n    /// @param sharesToDeallocate The amount of shares to deallocate.\n    function deallocateStrategyShares(address strategy, uint256 sharesToDeallocate) external onlyCoordinator returns (uint256 sharesDeallocated, OperatorStrategyDeallocation[] memory deallocations) {        \n        deallocations = new OperatorStrategyDeallocation[](s.activeOperatorCount);\n\n        OperatorUtilizationHeap.Data memory heap = s.getOperatorUtilizationHeapForStrategy(strategy);\n        if (heap.isEmpty()) revert NO_AVAILABLE_OPERATORS_FOR_DEALLOCATION();\n\n        uint256 deallocationIndex;\n        uint256 remainingShares = sharesToDeallocate;\n\n        while (remainingShares > 0) {\n            uint8 operatorId = heap.getMax().id;\n\n            OperatorDetails storage operator = s.operatorDetails[operatorId];\n            OperatorShareDetails memory operatorShares = operator.shareDetails[strategy];\n\n            // Exit early if the operator with the highest utilization rate has no allocation,\n            // as no further deallocations can be made.\n            if (operatorShares.allocation == 0) break;\n\n            uint256 newShareDeallocation = FixedPointMathLib.min(operatorShares.allocation, remainingShares);\n            uint256 newTokenDeallocation = IStrategy(strategy).sharesToUnderlyingView(newShareDeallocation);\n            deallocations[deallocationIndex] = OperatorStrategyDeallocation(\n                operator.delegator,\n                newShareDeallocation,\n                newTokenDeallocation\n            );\n            remainingShares -= newShareDeallocation;\n\n            uint128 updatedAllocation = operatorShares.allocation - SafeCast.toUint128(newShareDeallocation);\n\n            operator.shareDetails[strategy].allocation = updatedAllocation;\n            heap.updateUtilization(heap.getMaxIndex(), updatedAllocation.divWad(operatorShares.cap));\n\n            emit StrategySharesDeallocated(operatorId, strategy, newShareDeallocation, newTokenDeallocation);\n\n            unchecked {\n                ++deallocationIndex;\n            }\n        }\n        sharesDeallocated = sharesToDeallocate - remainingShares;\n\n        heap.store(s.activeOperatorsByStrategyShareUtilization[strategy]);\n\n        // Shrink the array length to the number of deallocations made.\n        if (deallocationIndex < s.activeOperatorCount) {\n            assembly {\n                mstore(deallocations, deallocationIndex)\n            }\n        }\n    }\n\n    // forgefmt: disable-next-item\n    /// @notice Deallocates a specified amount of ETH deposits from the operators with the highest utilization.\n    /// @param depositsToDeallocate The amount of deposits to deallocate (32 ETH each)\n    function deallocateETHDeposits(uint256 depositsToDeallocate) external onlyCoordinator returns (uint256 depositsDeallocated, OperatorETHDeallocation[] memory deallocations) {\n        deallocations = new OperatorETHDeallocation[](s.activeOperatorCount);\n\n        OperatorUtilizationHeap.Data memory heap = s.getOperatorUtilizationHeapForETH();\n        if (heap.isEmpty()) revert NO_AVAILABLE_OPERATORS_FOR_DEALLOCATION();\n\n        uint256 deallocationIndex;\n        uint256 remainingDeposits = depositsToDeallocate;\n\n        bytes memory pubKeyBatch;\n        while (remainingDeposits > 0) {\n            uint8 operatorId = heap.getMax().id;\n\n            OperatorDetails storage operator = s.operatorDetails[operatorId];\n            OperatorValidatorDetails memory validators = operator.validatorDetails;\n            uint256 activeDeposits = validators.deposited - validators.exited;\n\n            // Exit early if the operator with the highest utilization rate has no active deposits,\n            // as no further deallocations can be made.\n            if (activeDeposits == 0) break;\n\n            // Each deallocation will trigger the withdrawal of a 32 ETH deposit. The specific validators\n            // to withdraw from are chosen by the software run by the operator.\n            uint256 newDepositDeallocation = FixedPointMathLib.min(activeDeposits, remainingDeposits);\n            pubKeyBatch = ValidatorDetails.allocateMemoryForPubKeys(newDepositDeallocation);\n            VALIDATOR_DETAILS_POSITION.loadValidatorDetails(\n                operatorId, validators.exited, newDepositDeallocation, pubKeyBatch, new bytes(0), 0\n            );\n\n            operator.validatorDetails.exited += uint40(newDepositDeallocation);\n\n            deallocations[deallocationIndex] = OperatorETHDeallocation(operator.delegator, newDepositDeallocation);\n            remainingDeposits -= newDepositDeallocation;\n\n            uint256 updatedAllocation = activeDeposits - newDepositDeallocation;\n            heap.updateUtilization(heap.getMaxIndex(), updatedAllocation.divWad(validators.cap));\n\n            emit ETHDepositsDeallocated(operatorId, newDepositDeallocation, pubKeyBatch);\n\n            unchecked {\n                ++deallocationIndex;\n            }\n        }\n        depositsDeallocated = depositsToDeallocate - remainingDeposits;\n\n        heap.store(s.activeOperatorsByETHDepositUtilization);\n\n        // Shrink the array length to the number of deallocations made.\n        if (deallocationIndex < s.activeOperatorCount) {\n            assembly {\n                mstore(deallocations, deallocationIndex)\n            }\n        }\n    }\n\n    /// @dev Hashes a validator's BLS public key and returns the hash.\n    /// @param pubKey The validator's BLS public key.\n    function _hashValidatorBLSPubKey(bytes memory pubKey) internal pure returns (bytes32 pubKeyHash) {\n        if (pubKey.length != BLS_PUBLIC_KEY_LENGTH) {\n            revert INVALID_PUBLIC_KEY_LENGTH();\n        }\n        return sha256(abi.encodePacked(pubKey, bytes16(0)));\n    }\n\n    /// @dev Allows the owner to upgrade the operator registry implementation.\n    /// @param newImplementation The implementation to upgrade to.\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n}"
    },
    {
      "filename": "rio-sherlock-audit/contracts/utils/OperatorRegistryV1Admin.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.23;\n\nimport {LibMap} from '@solady/utils/LibMap.sol';\nimport {CREATE3} from '@solady/utils/CREATE3.sol';\nimport {FixedPointMathLib} from '@solady/utils/FixedPointMathLib.sol';\nimport {BeaconProxy} from '@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol';\nimport {RioLRTOperatorRegistryStorageV1} from 'contracts/restaking/storage/RioLRTOperatorRegistryStorageV1.sol';\nimport {IRioLRTOperatorDelegator} from 'contracts/interfaces/IRioLRTOperatorDelegator.sol';\nimport {IRioLRTOperatorRegistry} from 'contracts/interfaces/IRioLRTOperatorRegistry.sol';\nimport {OperatorUtilizationHeap} from 'contracts/utils/OperatorUtilizationHeap.sol';\nimport {IRioLRTAssetRegistry} from 'contracts/interfaces/IRioLRTAssetRegistry.sol';\nimport {BEACON_CHAIN_STRATEGY} from 'contracts/utils/Constants.sol';\nimport {Array} from 'contracts/utils/Array.sol';\nimport {Asset} from 'contracts/utils/Asset.sol';\n\n/// @title Administrative functions for the operator registry.\nlibrary OperatorRegistryV1Admin {\n    using OperatorRegistryV1Admin for RioLRTOperatorRegistryStorageV1.StorageV1;\n    using OperatorRegistryV1Admin for IRioLRTOperatorRegistry.OperatorDetails;\n    using OperatorUtilizationHeap for OperatorUtilizationHeap.Data;\n    using FixedPointMathLib for *;\n    using LibMap for *;\n    using Array for *;\n    using Asset for *;\n\n    /// @notice The maximum number of operators allowed in the registry.\n    uint8 public constant MAX_OPERATOR_COUNT = 254;\n\n    /// @notice The maximum number of active operators allowed.\n    uint8 public constant MAX_ACTIVE_OPERATOR_COUNT = 64;\n\n    /// @notice Adds a new operator to the registry, deploying a delegator contract and\n    /// delegating to the provided `operator`.\n    /// @param s The operator registry v1 storage accessor.\n    /// @param token The address of the liquid restaking token.\n    /// @param operatorDelegatorBeacon The operator delegator beacon address.\n    /// @param config The new operator's configuration.\n    function addOperator(\n        RioLRTOperatorRegistryStorageV1.StorageV1 storage s,\n        address token,\n        address operatorDelegatorBeacon,\n        IRioLRTOperatorRegistry.OperatorConfig"
    }
  ]
}