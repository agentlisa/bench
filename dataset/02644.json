{
  "Title": "H-7: User can steal rewards from other users by withdrawing their Velo Deposit NFTs from other users' depositors",
  "Content": "# Issue H-7: User can steal rewards from other users by withdrawing their Velo Deposit NFTs from other users' depositors \n\nSource: https://github.com/sherlock-audit/2022-11-isomorph-judging/issues/51 \n\n## Found by \n0x52, HollaDieWaldfee\n\n## Summary\n\nRewards from staking AMM tokens accumulate to the depositor used to deposit them. The rewards accumulated by a depositor are passed to the owner when they claim. A malicious user to steal the rewards from other users by manipulating other users depositors. Since any NFT of a DepositReceipt can be withdrawn from any depositor with the same DepositReceipt, a malicious user could mint an NFT on their depositor then withdraw in from another user's depositor. The net effect is that that the victims deposits will effectively be in the attackers depositor and they will collect all the rewards.\n\n## Vulnerability Detail\n\n    function withdrawFromGauge(uint256 _NFTId, address[] memory _tokens)  public  {\n        uint256 amount = depositReceipt.pooledTokens(_NFTId);\n        depositReceipt.burn(_NFTId);\n        gauge.getReward(address(this), _tokens);\n        gauge.withdraw(amount);\n        //AMMToken adheres to ERC20 spec meaning it reverts on failure, no need to check return\n        //slither-disable-next-line unchecked-transfer\n        AMMToken.transfer(msg.sender, amount);\n    }\n\nEvery user must create a `Depositor` using `Templater` to interact with vaults and take loans. `Depositor#withdrawFromGauge` allows any user to withdraw any NFT that was minted by the same `DepositReciept`. This is where the issues arises. Since rewards are accumulated to the `Depositor` in which the underlying is staked a user can deposit to their `Depositor` then withdraw their NFT through the `Depositor` of another user's `Depositor` that uses the same `DepositReciept`. The effect is that the tokens will remained staked to the attackers `Depositor` allowing them to steal all the other user's rewards.\n\nExample:\n`User A` and `User B` both create a `Depositor` for the same `DepositReciept`. Both users deposit 100 tokens into their respective `Depositors`. `User B` now calls `withdrawFromGauge` on `Depositor A`. `User B` gets their 100 tokens back and `Depositor B` still has 100 tokens deposited in it. `User B` cannot steal these tokens but they are now collecting the yield on all 100 tokens via `Depositor B` and `User A` isn't getting any rewards at all because `Depositor A` no longer has any tokens deposited into Velodrome gauge.\n\n## Impact\n\nMalicious user can steal other user's rewards\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-isomorph/blob/main/contracts/Velo-Deposit-Tokens/contracts/Depositor.sol#L119-L127\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nDepositors should only be able to burn NFTs that they minted. Change DepositReciept_Base#burn to enforce this:\n\n        function burn(uint256 _NFTId) external onlyMinter{\n    +       //tokens must be burned by the depositor that minted them\n    +       address depositor = relatedDepositor[_NFTId];\n    +       require(depositor == msg.sender, \"Wrong depositor\");\n            require(_isApprovedOrOwner(msg.sender, _NFTId), \"ERC721: caller is not token owner or approved\");\n            delete pooledTokens[_NFTId];\n            delete relatedDepositor[_NFTId];\n            _burn(_NFTId);\n        }\n\n\n## Discussion\n\n**kree-dotcom**\n\nSponsor confirmed, will fix. Appears to be a duplicate of issue #43 's footnote.\n\n**kree-dotcom**\n\nFixed https://github.com/kree-dotcom/Velo-Deposit-Tokens/commit/23ff5653b555b11c9f4dead7ff5a72d50eac5788\n\nWe have taken a different approach to that suggested by the auditor, theirs looked valid though. \nWe added the checks on lines 82 and 123 that validate any depositReceipt being withdrawn was originally minted by that Depositor contract. Other lines changed in this commit relate to #47 .\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/22",
  "Code": [
    {
      "filename": "contracts/Velo-Deposit-Tokens/contracts/Depositor.sol",
      "content": "pragma solidity =0.8.9;\n\nimport \"./DepositReceipt_USDC.sol\";\nimport \"./Interfaces/IGauge.sol\";\nimport \"./Interfaces/IRouter.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n\n//Depositer takes pooled tokens from the user and deposits them on their behalf \n// into the Gauge. It then mints them the  ERC20 deposit receipt to use elsewhere\n// the initial Depositer can claim rewards from the Guage via the Depositer at any time\ncontract Depositor is Ownable {\n\n    using SafeERC20 for IERC20; \n\n    DepositReceipt_USDC public immutable depositReceipt;\n    IERC20 public immutable AMMToken;\n    IGauge public immutable gauge;\n    \n    \n    /**\n    *    @notice Used to deposit pooledTokens to the Gauge and mint a new DepositReceipt\n    *    @param _depositReceipt address of the related depositReceipt so we can mint and burn new DepositReceipt NFTs\n    *    @param _AMMToken the associate pooledToken we transfer to the Gauge on behalf of the user.\n    *    @param _gauge the related gauge for this pooledToken, where we deposit/withdraw pooledTokens and claim rewards from.\n    *    \n    **/\n    constructor(\n                address _depositReceipt,\n                address _AMMToken, \n                address _gauge\n                ){\n\n        AMMToken = IERC20(_AMMToken);\n        gauge = IGauge(_gauge);\n        depositReceipt = DepositReceipt_USDC(_depositReceipt);\n    }\n\n    //function required to receive ERC721s to this contract\n    function onERC721Received(\n        address operator,\n        address from,\n        uint tokenId,\n        bytes calldata data\n    ) external returns (bytes4){\n        return(IERC721Receiver.onERC721Received.selector);\n    }\n\n\n    /**\n    *    @notice Used to deposit pooledTokens to the Gauge and mint a new DepositReceipt\n    *    @param _amount amount of pooledTokens to deposit.\n    *    @return NFTId the Id relating to the newly minte DepositReceipt\n    *    \n    **/\n    function depositToGauge(uint256 _amount) onlyOwner() external returns(uint256){\n         //AMMToken adheres to ERC20 spec meaning it reverts on failure, no need to check return\n        //slither-disable-next-line unchecked-transfer\n        AMMToken.transferFrom(msg.sender, address(this), _amount);\n\n        AMMToken.safeIncreaseAllowance(address(gauge), _amount);\n        //we are not attaching a veNFT to the deposit so the 2nd arg is always 0.\n        gauge.deposit(_amount, 0);\n        uint256 NFTId = depositReceipt.safeMint(_amount);\n        //safeMint sends the minted DepositReceipt to Depositor so now we forward it to the user.\n        depositReceipt.safeTransferFrom(address(this), msg.sender, NFTId);\n        return(NFTId);\n    }\n\n    /**\n    *    @notice used to withdraw percentageSplit of specified DepositReceipt worth of pooledTokens.\n    *    @param _NFTId the ID sof the DepositReceipt you wish to reclaim some of the pooledTokens of.\n    *    @param _percentageSplit the percentage of the pooled tokens to be withdrawn , 100% is 1e18.\n    *    @param _tokens  array of reward tokens the user wishes to claim at the same time, can be empty.\n    *    \n    **/\n    function partialWithdrawFromGauge(uint256 _NFTId, uint256 _percentageSplit, address[] memory _tokens) public {\n        uint256 newNFTId = depositReceipt.split(_NFTId, _percentageSplit);\n        //then call withdrawFromGauge on portion removing.\n        withdrawFromGauge(newNFTId, _tokens);\n    }  \n\n    /**\n    *    @notice Wrapper around partialWithdrawFromGauge and withdrawFromGauge to improve user experience.\n    *    @param _NFTIds the ID sof the DepositReceipts you wish to burn and reclaim the pooledTokens relating to\n    *    @param _usingPartial Set to true if you wish to withdraw only part of one DepositReceipt\n    *    @param _partialNFTId the DepositReceipt Id of which you only wish to withdraw less than 100% of its pooled tokens\n    *    @param _percentageSplit if a partial withdrawal is being used, the percentage of the pooled tokens to be withdrawn , 100% is 1e18.\n    *    @param _tokens  array of reward tokens the user wishes to claim at the same time, can be empty.\n    *    \n    **/\n    function multiWithdrawFromGauge(\n        uint256[] memory _NFTIds, \n        bool _usingPartial,\n        uint256 _partialNFTId, \n        uint256 _percentageSplit, \n        address[] memory _tokens\n        ) external {\n\n        //here we use external calls in a loop, if gas is excessive withdrawFromGauge and partialWithdrawFromGauge can be called directly preventing DOS.\n        uint256 length = _NFTIds.length;\n        for (uint256 i = 0; i < length; i++ ){\n            withdrawFromGauge(_NFTIds[i], _tokens);\n        }\n        if(_usingPartial){\n            partialWithdrawFromGauge(_partialNFTId, _percentageSplit, _tokens);\n        }\n        \n    }\n\n    /**\n    *    @notice burns the NFT related to the ID and withdraws the owed pooledtokens from Gauge and sends to user.  \n    *    @param _NFTId the ID of the DepositReceipt you wish to burn and reclaim the pooledTokens relating to\n    *    @param _tokens  array of reward tokens the user wishes to claim at the same time, can be empty.\n    *    \n    **/\n    function withdrawFromGauge(uint256 _NFTId, address[] memory _tokens)  public  {\n        uint256 amount = depositReceipt.pooledTokens(_NFTId);\n        depositReceipt.burn(_NFTId);\n        gauge.getReward(address(this), _tokens);\n        gauge.withdraw(amount);\n        //AMMToken adheres to ERC20 spec meaning it reverts on failure, no need to check return\n        //slither-disable-next-line unchecked-transfer\n        AMMToken.transfer(msg.sender, amount);\n    }\n\n    /**\n    *    @notice Function to claim accrued rewards from gauge and send to Depositor owner who must be the caller.\n    *    @notice because we call the gauge then transfer to the user there should never be reward tokens leftover in Depositor\n    *            but if there are you can call again as gauge will succeed even if it has nothing to send the Depositor\n    *    @param _tokens  array of reward tokens the user wishes to claim. \n    *    \n    **/\n    function claimRewards( address[] memory _tokens) onlyOwner() external {\n        require(_tokens.length > 0, \"Empty tokens array\");\n        gauge.getReward(address(this), _tokens);\n        \n        uint256 length =  _tokens.length;\n        for (uint i = 0; i < length; i++) {\n            uint256 balance = IERC20(_tokens[i]).balanceOf(address(this));\n            // using SafeERC20 in case reward token returns false on failure\n            IERC20(_tokens[i]).safeTransfer(msg.sender, balance);\n        }\n\n    }\n\n    /**\n    *    @notice Function to check the quantity of _token rewards awaiting being claimed by claimRewards()\n    *    @param _token  reward tokens the user wishes to check the pending balance of in the gauge.\n    *    \n    **/\n    function viewPendingRewards(address _token) external view returns(uint256){\n        //passthrough to Gauge\n        return gauge.earned(_token, address(this)); \n    }\n    \n}"
    }
  ]
}