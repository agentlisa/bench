{
  "Title": "[M-02] `CreateOfferer.sol` should not enforce the nonce incremented sequentially, otherwise user can DOS the contract by skipping order",
  "Content": "\nAccording to https://github.com/ProjectOpenSea/seaport/blob/main/docs/SeaportDocumentation.md#contract-orders:\n\n> \"Seaport v1.2 introduced support for a new type of order: the contract order. In brief, a smart contract that implements the ContractOffererInterface (referred to as an “Seaport app contract” or 'Seaport app' in the docs and a 'contract offerer' in the code) can now provide a dynamically generated order (a contract order) in response to a buyer or seller’s contract order request.\"\n\nThe CreateOfferer.sol aims to be comply with the interface ContractOffererInterface.\n\nThe life cycle of the contract life cycle here is here:\n\n<https://github.com/ProjectOpenSea/seaport/blob/main/docs/SeaportDocumentation.md#example-lifecycle-journey>\n\nFirst the function `_getGeneratedOrder` is called.\n\nThen after the order execution, the function ratifyOrder is triggered for contract (CreateOfferer.sol) to do post order validation.\n\nIn the logic of ratifyOrder, the nonce is incremented by calling this [line of code](https://github.com/code-423n4/2023-09-delegate/blob/a6dbac8068760ee4fc5bababb57e3fe79e5eeb2e/src/CreateOfferer.sol#L77) `Helpers.processNonce`.\n\n```solidity\nfunction ratifyOrder(SpentItem[] calldata offer, ReceivedItem[] calldata consideration, bytes calldata context, bytes32[] calldata, uint256 contractNonce)\n\texternal\n\tcheckStage(Enums.Stage.ratify, Enums.Stage.generate)\n\tonlySeaport(msg.sender)\n\treturns (bytes4)\n{\n\tHelpers.processNonce(nonce, contractNonce);\n\tHelpers.verifyCreate(delegateToken, offer[0].identifier, transientState.receivers, consideration[0], context);\n\treturn this.ratifyOrder.selector;\n}\n```\n\nThis is calling this [line of code](https://github.com/code-423n4/2023-09-delegate/blob/a6dbac8068760ee4fc5bababb57e3fe79e5eeb2e/src/libraries/CreateOffererLib.sol#L184).\n\n```solidity\nfunction processNonce(CreateOffererStructs.Nonce storage nonce, uint256 contractNonce) internal {\n\tif (nonce.value != contractNonce) revert CreateOffererErrors.InvalidContractNonce(nonce.value, contractNonce);\n\tunchecked {\n\t\t++nonce.value;\n\t} // Infeasible this will overflow if starting point is zero\n}\n```\n\nThe CreateOffererStructs.Nonce data structure is just [nonce](https://github.com/code-423n4/2023-09-delegate/blob/a6dbac8068760ee4fc5bababb57e3fe79e5eeb2e/src/libraries/CreateOffererLib.sol#L72).\n\n```solidity\nlibrary CreateOffererStructs {\n    /// @notice Used to track the stage and lock status\n    struct Stage {\n        CreateOffererEnums.Stage flag;\n        CreateOffererEnums.Lock lock;\n    }\n\n    /// @notice Used to keep track of the seaport contract nonce of CreateOfferer\n    struct Nonce {\n        uint256 value;\n    }\n```\n\nBut this is not how Seaport contract track contract nonce.\n\nOn Seaport contract, we are calling [\\_getGeneratedOrder](https://github.com/ProjectOpenSea/seaport/blob/539f0c18af85152aff9d64d90a55cf1627fd3e25/reference/lib/ReferenceOrderValidator.sol#L323).\n\nWhich calls [\\_callGenerateOrder](https://github.com/ProjectOpenSea/seaport/blob/539f0c18af85152aff9d64d90a55cf1627fd3e25/reference/lib/ReferenceOrderValidator.sol#L360).\n\n```solidity\n{\n\t// Do a low-level call to get success status and any return data.\n\t(bool success, bytes memory returnData) = _callGenerateOrder(\n\t\torderParameters,\n\t\tcontext,\n\t\toriginalOfferItems,\n\t\toriginalConsiderationItems\n\t);\n\n\t{\n\t\t// Increment contract nonce and use it to derive order hash.\n\t\t// Note: nonce will be incremented even for skipped orders, and\n\t\t// even if generateOrder's return data doesn't meet constraints.\n\t\tuint256 contractNonce = (\n\t\t\t_contractNonces[orderParameters.offerer]++\n\t\t);\n\n\t\t// Derive order hash from contract nonce and offerer address.\n\t\torderHash = bytes32(\n\t\t\tcontractNonce ^\n\t\t\t\t(uint256(uint160(orderParameters.offerer)) << 96)\n\t\t);\n\t}\n```\n\nAs we can see:\n\n```solidity\n// Increment contract nonce and use it to derive order hash.\n// Note: nonce will be incremented even for skipped orders, and\n// even if generateOrder's return data doesn't meet constraints.\nuint256 contractNonce = (\n\t_contractNonces[orderParameters.offerer]++\n);\n```\n\nNonce will be incremented even for skipped orders.\n\nThis is very important, suppose the low level call \\_callGenerateOrder return false, we are hitting the [else block](https://github.com/ProjectOpenSea/seaport/blob/539f0c18af85152aff9d64d90a55cf1627fd3e25/reference/lib/ReferenceOrderValidator.sol#L401).\n\n```solidity\n return _revertOrReturnEmpty(revertOnInvalid, orderHash);\n```\n\nThis is calling `_revertOrReturnEmpty`.\n\n```solidity\nfunction _revertOrReturnEmpty(\n\tbool revertOnInvalid,\n\tbytes32 contractOrderHash\n)\n\tinternal\n\tpure\n\treturns (\n\t\tbytes32 orderHash,\n\t\tuint256 numerator,\n\t\tuint256 denominator,\n\t\tOrderToExecute memory emptyOrder\n\t)\n{\n\t// If invalid input should not revert...\n\tif (!revertOnInvalid) {\n\t\t// Return the contract order hash and zero values for the numerator\n\t\t// and denominator.\n\t\treturn (contractOrderHash, 0, 0, emptyOrder);\n\t}\n\n\t// Otherwise, revert.\n\trevert InvalidContractOrder(contractOrderHash);\n}\n```\n\nClearly we can see that if the flag revertOnInvalid is set to false, then even the low level call return false, the nonce of the offerer is still incremented.\n\nWhere in the Seaport code does it set revertOnInvalid to false?\n\nWhen the Seaport wants to combine multiple orders in [this line of code](https://github.com/ProjectOpenSea/seaport-core/blob/d4e8c74adc472b311ab64b5c9f9757b5bba57a15/src/lib/OrderCombiner.sol#L137).\n\n```solidity\n    function _fulfillAvailableAdvancedOrders(\n        AdvancedOrder[] memory advancedOrders,\n        CriteriaResolver[] memory criteriaResolvers,\n        FulfillmentComponent[][] memory offerFulfillments,\n        FulfillmentComponent[][] memory considerationFulfillments,\n        bytes32 fulfillerConduitKey,\n        address recipient,\n        uint256 maximumFulfilled\n    ) internal returns (bool[] memory, /* availableOrders */ Execution[] memory /* executions */ ) {\n        // Validate orders, apply amounts, & determine if they use conduits.\n        (bytes32[] memory orderHashes, bool containsNonOpen) = _validateOrdersAndPrepareToFulfill(\n            advancedOrders,\n            criteriaResolvers,\n            false, // Signifies that invalid orders should NOT revert.\n            maximumFulfilled,\n            recipient\n        );\n```\n\nWe [call](https://github.com/ProjectOpenSea/seaport-core/blob/d4e8c74adc472b311ab64b5c9f9757b5bba57a15/src/lib/OrderCombiner.sol#L256) `_validateOrderAndUpdateStatus`.\n\n```solidity\n// Validate it, update status, and determine fraction to fill.\n(bytes32 orderHash, uint256 numerator, uint256 denominator) =\n_validateOrderAndUpdateStatus(advancedOrder, revertOnInvalid);\n```\n\nFinally we [call](https://github.com/ProjectOpenSea/seaport-core/blob/d4e8c74adc472b311ab64b5c9f9757b5bba57a15/src/lib/OrderValidator.sol#L178C21-L178C37) the logic \\_getGeneratedOrder(orderParameters, advancedOrder.extraData, revertOnInvalid) below with parameter revertOnInvalid false.\n\n```solidity\n  // If the order is a contract order, return the generated order.\n\tif (orderParameters.orderType == OrderType.CONTRACT) {\n\t\t// Ensure that the numerator and denominator are both equal to 1.\n\t\tassembly {\n\t\t\t// (1 ^ nd =/= 0) => (nd =/= 1) => (n =/= 1) || (d =/= 1)\n\t\t\t// It's important that the values are 120-bit masked before\n\t\t\t// multiplication is applied. Otherwise, the last implication\n\t\t\t// above is not correct (mod 2^256).\n\t\t\tinvalidFraction := xor(mul(numerator, denominator), 1)\n\t\t}\n\n\t\t// Revert if the supplied numerator and denominator are not valid.\n\t\tif (invalidFraction) {\n\t\t\t_revertBadFraction();\n\t\t}\n\n\t\t// Return the generated order based on the order params and the\n\t\t// provided extra data. If revertOnInvalid is true, the function\n\t\t// will revert if the input is invalid.\n\t\treturn _getGeneratedOrder(orderParameters, advancedOrder.extraData, revertOnInvalid);\n\t}\n```\n\nOk what does this mean?\n\nSuppose the CreateOfferer.sol fulfills two orders and creates two delegate tokens.\n\nThe nonces start from 0 and then increment to 1 and then increment to 2.\n\nA user crafts a contract with malformed minimumReceived and combines with another valid order to call OrderCombine.\n\nAs we can see above, when multiple order is passed in, the revertOnInvalid is set to false, so the contract order from CreateOfferer.sol is skipped, but the nonce is incremented.\n\nThen the nonce tracked by CreateOfferer.sol internally is out of sync with the contract nonce in seaport contract forever.\n\nThen the CreateOfferer.sol is not usable because if the [ratifyOrder callback](https://github.com/ProjectOpenSea/seaport/blob/539f0c18af85152aff9d64d90a55cf1627fd3e25/reference/lib/ReferenceZoneInteraction.sol#L147) hit the contract, transaction revert [in this check](https://github.com/code-423n4/2023-09-delegate/blob/a6dbac8068760ee4fc5bababb57e3fe79e5eeb2e/src/libraries/CreateOffererLib.sol#L185).\n\n```solidity\n if (nonce.value != contractNonce) revert CreateOffererErrors.InvalidContractNonce(nonce.value, contractNonce);\n```\n\n### Recommended Mitigation Steps\n\nI would recommend do not validate the order execution in the ratifyOrder call back by using the contract nonce, instead, validate the order using [orderHash](https://github.com/ProjectOpenSea/seaport/blob/539f0c18af85152aff9d64d90a55cf1627fd3e25/reference/lib/ReferenceZoneInteraction.sol#L151).\n\n```solidity\nif (\nContractOffererInterface(offerer).ratifyOrder(\norderToExecute.spentItems,\norderToExecute.receivedItems,\nadvancedOrder.extraData,\norderHashes,\nuint256(orderHash) ^ (uint256(uint160(offerer)) << 96)\n) != ContractOffererInterface.ratifyOrder.selector\n)\n```\n\n### Assessed type\n\nDoS\n\n**[0xfoobar (Delegate) confirmed and commented](https://github.com/code-423n4/2023-09-delegate-findings/issues/94#issuecomment-1728555434):**\n > Need to double-check but looks plausible.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-09-delegate-findings/issues/94#issuecomment-1742175246):**\n > `_callGenerateOrder` is caught, and in case of multiple order will be incrementing nonce without reverting.\n> \n> [ReferenceOrderValidator.sol#L286-L302](https://github.com/ProjectOpenSea/seaport/blob/22ea29df3c241ebc17c95268164dde47e1186287/reference/lib/ReferenceOrderValidator.sol#L286-L302)\n> \n> ```solidity\n>     function _callGenerateOrder(\n>         OrderParameters memory orderParameters,\n>         bytes memory context,\n>         SpentItem[] memory originalOfferItems,\n>         SpentItem[] memory originalConsiderationItems\n>     ) internal returns (bool success, bytes memory returnData) {\n>         return\n>             orderParameters.offerer.call(\n>                 abi.encodeWithSelector(\n>                     ContractOffererInterface.generateOrder.selector,\n>                     msg.sender,\n>                     originalOfferItems,\n>                     originalConsiderationItems,\n>                     context\n>                 )\n>             );\n>     }\n> ```\n> \n> The call to `generateOrder` will revert at `processSpentItems`.\n> \n> [CreateOffererLib.sol#L351-L352](https://github.com/code-423n4/2023-09-delegate/blob/a6dbac8068760ee4fc5bababb57e3fe79e5eeb2e/src/libraries/CreateOffererLib.sol#L351-L352)\n> \n> ```solidity\n>         if (!(minimumReceived.length == 1 && maximumSpent.length == 1)) revert CreateOffererErrors.NoBatchWrapping();\n> \n> ```\n> \n> This will cause the nonce to be increased in Seaport but not on the `CreateOfferer`.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-09-delegate-findings/issues/94#issuecomment-1742682777):**\n > Have asked the Warden for a Coded POC.<br>\n> Have reached out to Seaport Devs to ask for advice as to whether the issue is valid.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-09-delegate-findings/issues/94#issuecomment-1745091145):**\n > [Coded POC](https://gist.github.com/JeffCX/2d91b4f5f781f08a249350e748d85131#file-createofferer-t-sol-L545) from the warden.\n\n**[0xfoobar (Delegate) disagreed with severity and commented](https://github.com/code-423n4/2023-09-delegate-findings/issues/94#issuecomment-1745811557):**\n > Believe issue is valid, would love confirmation from Seaport devs if you have it. Believe this should be a quality Medium not High because CreateOfferer is tangential to the core protocol, would not cause any loss of user funds if abused, and could be easily replaced if DoS-ed. Appreciate the detailed work to dive into the workings of Seaport nonces.\n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-09-delegate-findings/issues/94#issuecomment-1748635567):**\n > Agree with impact from Sponsor. Temporarly marking as valid; however, we will not confirm until runnable POC is produced.\n\n**[ladboy233 (warden) commented](https://github.com/code-423n4/2023-09-delegate-findings/issues/94#issuecomment-1748951894):**\n > Agree with sponsor's severity assessment!\n> \n> Fully runnable [POC](https://gist.github.com/JeffCX/1ac6d24c79b4b680e5f2f24298135f7a) to show the nonce is out of sync.\n>\n> The Contract offerer internal nonce is tracked in this [line of code](https://gist.github.com/JeffCX/1ac6d24c79b4b680e5f2f24298135f7a#file-poc-sol-L62).\n> \n> While the contract offerer nonce on Seaport side can be acquired by calling:\n> \n> ```solidity\n> seaport.getContractOffererNonce(address(contractOfferer1));\n> ```\n> \n> And indeed if we use `fulfillAvailableAdvancedOrder` to fulfill only one contract order and revert in other order, nonce is still incremented.\n> \n> ```solidity\n>      uint256 seaport_contrat_offer_1_nonce = seaport.getContractOffererNonce(address(contractOfferer1));\n>         console2.log(seaport_contrat_offer_1_nonce); // the nonce of contract offerer on seaport is 1 is 1!!\n>         uint256 oldNonce = contractOfferer1.nonce(); // the none of contract offerer 1 is 0!\n>         console2.log(oldNonce);\n> ```\n> \n> A more detailed explanation is [here](https://gist.github.com/JeffCX/0d58dacfddaae87a74eb59ab07ebaca8).\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-09-delegate-findings/issues/94#issuecomment-1750142313):**\n > Logs\n> ```solidity\n> Logs:\n>   mockERC721.ownerOf(1) 0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496\n>   mockERC721.ownerOf(2) 0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496\n>   setRevert true\n>   mockERC721.ownerOf(1) 0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496\n>   mockERC721.ownerOf(2) 0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496\n>   generateOrder\n>   reverting\n>   generateOrder\n>   Sent ETH to SEAPORT true\n>   fulfilled true\n>   1\n>   0\n>   mockERC721.ownerOf(1) 0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496\n>   mockERC721.ownerOf(2) 0xa0Cb889707d426A7A386870A03bc70d1b0697598\n> ```\n> \n> As shown by the logs, the Token 1 is not transfered, but the nonce is consumed.\n>\n> <details>\n> <summary>POC</summary>\n> \n> ```solidity\n> // SPDX-License-Identifier: CC0-1.0\n> pragma solidity ^0.8.21;\n> \n> import {Test} from \"forge-std/Test.sol\";\n> import {BaseSeaportTest} from \"./base/BaseSeaportTest.t.sol\";\n> import {BaseLiquidDelegateTest} from \"./base/BaseLiquidDelegateTest.t.sol\";\n> import {SeaportHelpers, User} from \"./utils/SeaportHelpers.t.sol\";\n> import {IDelegateToken, Structs as IDelegateTokenStructs} from \"src/interfaces/IDelegateToken.sol\";\n> import {IDelegateRegistry} from \"delegate-registry/src/IDelegateRegistry.sol\";\n> import {AdvancedOrder, OrderParameters, Fulfillment, CriteriaResolver, OfferItem, ConsiderationItem, FulfillmentComponent} from \"seaport/contracts/lib/ConsiderationStructs.sol\";\n> import {ItemType, OrderType} from \"seaport/contracts/lib/ConsiderationEnums.sol\";\n> import {SpentItem} from \"seaport/contracts/interfaces/ContractOffererInterface.sol\";\n> \n> import {CreateOfferer, Enums as OffererEnums, Structs as OffererStructs} from \"src/CreateOfferer.sol\";\n> import {MockERC721} from \"./mock/MockTokens.t.sol\";\n> import {WETH} from \"./mock/WETH.t.sol\";\n> \n> import {console2} from \"forge-std/console2.sol\";\n> \n> import {IERC721} from \"openzeppelin/token/ERC721/IERC721.sol\";\n> \n> import {IERC1155} from \"openzeppelin/token/ERC1155/IERC1155.sol\";\n> \n> import {ItemType} from \"seaport/contracts/lib/ConsiderationEnums.sol\";\n> \n> import {ContractOffererInterface, SpentItem, ReceivedItem, Schema} from \"seaport/contracts/interfaces/ContractOffererInterface.sol\";\n> \n> interface ISeaport {\n>     function getContractOffererNonce(address contractOfferer) external view returns (uint256 nonce);\n> }\n> \n> abstract contract ERC165 {\n>     /**\n>      * @dev See {IERC165-supportsInterface}.\n>      */\n>     function supportsInterface(bytes4 interfaceId) public view returns (bool) {\n>         return interfaceId == bytes4(keccak256(\"supportsInterface(bytes4)\"));\n>     }\n> }\n> \n> /**\n>  * @title TestContractOffererNativeToken\n>  */\n> contract TestContractOffererNativeToken is ContractOffererInterface, ERC165 {\n>     error OrderUnavailable();\n> \n>     address private immutable _SEAPORT;\n> \n>     SpentItem private _available;\n>     SpentItem private _required;\n> \n>     bool public ready;\n>     bool public fulfilled;\n> \n>     uint256 public extraAvailable;\n>     uint256 public extraRequired;\n> \n>     bool reverting = false;\n>     uint256 public nonce = 0;\n>     address public otherContract;\n> \n>     string public name;\n> \n>     event ShowName(string name);\n> \n>     event NumberUpdated(uint256 number);\n> \n>     constructor(address seaport, string memory _name) {\n>         // Set immutable values and storage variables.\n>         _SEAPORT = seaport;\n>         fulfilled = false;\n>         ready = false;\n>         extraAvailable = 0;\n>         extraRequired = 0;\n>         name = _name;\n>     }\n> \n>     function setRevert(bool state) public {\n>         console2.log(\"setRevert\", state);\n>         reverting = state;\n>     }\n> \n>     receive() external payable {}\n> \n>     function activate(SpentItem memory available, SpentItem memory required) public payable {\n>         if (ready || fulfilled) {\n>             revert OrderUnavailable();\n>         }\n> \n>         // Set storage variables.\n>         _available = available;\n>         _required = required;\n>         ready = true;\n>     }\n> \n>     /// In case of criteria based orders and non-wildcard items, the member\n>     /// `available.identifier` would correspond to the `identifierOrCriteria`\n>     /// i.e., the merkle-root.\n>     /// @param identifier corresponds to the actual token-id that gets transferred.\n>     function activateWithCriteria(SpentItem memory available, SpentItem memory required, uint256 identifier) public {\n>         if (ready || fulfilled) {\n>             revert OrderUnavailable();\n>         }\n> \n>         if (available.itemType == ItemType.ERC721_WITH_CRITERIA) {\n>             IERC721 token = IERC721(available.token);\n> \n>             token.transferFrom(msg.sender, address(this), identifier);\n> \n>             token.setApprovalForAll(_SEAPORT, true);\n>         } else if (available.itemType == ItemType.ERC1155_WITH_CRITERIA) {\n>             IERC1155 token = IERC1155(available.token);\n> \n>             token.safeTransferFrom(msg.sender, address(this), identifier, available.amount, \"\");\n> \n>             token.setApprovalForAll(_SEAPORT, true);\n>         }\n> \n>         // Set storage variables.\n>         _available = available;\n>         _required = required;\n>         ready = true;\n>     }\n> \n>     function extendAvailable() public {\n>         if (!ready || fulfilled) {\n>             revert OrderUnavailable();\n>         }\n> \n>         extraAvailable++;\n> \n>         _available.amount /= 2;\n>     }\n> \n>     function extendRequired() public {\n>         if (!ready || fulfilled) {\n>             revert OrderUnavailable();\n>         }\n> \n>         extraRequired++;\n>     }\n> \n>     function generateOrder(address, SpentItem[] calldata minimumReceived, SpentItem[] calldata maximumSpent, bytes calldata /* context */ )\n>         external\n>         returns (SpentItem[] memory offer, ReceivedItem[] memory consideration)\n>     {\n>         console2.log(\"generateOrder\");\n>         emit ShowName(name);\n>         // Set the offer and consideration that were supplied during deployment.\n>         if (reverting) {\n>             console2.log(\"reverting\");\n>             revert(\"revert here\");\n>         }\n> \n>         if (otherContract != address(0)) {\n>             uint256 result = ISeaport(_SEAPORT).getContractOffererNonce(otherContract);\n>             console2.log(\"result\", result);\n>             emit NumberUpdated(result);\n>             uint256 oldNonce = TestContractOffererNativeToken(payable(otherContract)).nonce();\n>             emit NumberUpdated(oldNonce);\n>         }\n> \n>         offer = new SpentItem[](1);\n>         consideration = new ReceivedItem[](1);\n> \n>         // Send eth to Seaport.\n>         (bool success,) = _SEAPORT.call{value: minimumReceived[0].amount}(\"\");\n>         console2.log(\"Sent ETH to SEAPORT\", success);\n> \n>         // revert(\"error\");\n> \n>         // Revert if transaction fails.\n>         if (!success) {\n>             assembly {\n>                 returndatacopy(0, 0, returndatasize())\n>                 revert(0, returndatasize())\n>             }\n>         }\n> \n>         // Set the offer item as the _available item in storage.\n>         offer[0] = minimumReceived[0];\n> \n>         // Set the erc721 consideration item.\n>         consideration[0] = ReceivedItem({\n>             itemType: ItemType.ERC721,\n>             token: maximumSpent[0].token,\n>             identifier: maximumSpent[0].identifier,\n>             amount: maximumSpent[0].amount,\n>             recipient: payable(address(this))\n>         });\n> \n>         // Update storage to reflect that the order has been fulfilled.\n>         fulfilled = true;\n>         console2.log(\"fulfilled\", fulfilled);\n>     }\n> \n>     function previewOrder(address caller, address, SpentItem[] calldata, SpentItem[] calldata, bytes calldata context)\n>         external\n>         view\n>         returns (SpentItem[] memory offer, ReceivedItem[] memory consideration)\n>     {\n>         // Ensure the caller is Seaport & the order has not yet been fulfilled.\n>         if (!ready || fulfilled || caller != _SEAPORT || context.length != 0) {\n>             revert OrderUnavailable();\n>         }\n> \n>         // Set the offer and consideration that were supplied during deployment.\n>         offer = new SpentItem[](1 + extraAvailable);\n>         consideration = new ReceivedItem[](1 + extraRequired);\n> \n>         for (uint256 i = 0; i < 1 + extraAvailable; ++i) {\n>             offer[i] = _available;\n>         }\n> \n>         for (uint256 i = 0; i < 1 + extraRequired; ++i) {\n>             consideration[i] =\n>                 ReceivedItem({itemType: _required.itemType, token: _required.token, identifier: _required.identifier, amount: _required.amount, recipient: payable(address(this))});\n>         }\n>     }\n> \n>     function getInventory() external view returns (SpentItem[] memory offerable, SpentItem[] memory receivable) {\n>         // Set offerable and receivable supplied at deployment if unfulfilled.\n>         if (!ready || fulfilled) {\n>             offerable = new SpentItem[](0);\n> \n>             receivable = new SpentItem[](0);\n>         } else {\n>             offerable = new SpentItem[](1 + extraAvailable);\n>             for (uint256 i = 0; i < 1 + extraAvailable; ++i) {\n>                 offerable[i] = _available;\n>             }\n> \n>             receivable = new SpentItem[](1 + extraRequired);\n>             for (uint256 i = 0; i < 1 + extraRequired; ++i) {\n>                 receivable[i] = _required;\n>             }\n>         }\n>     }\n> \n>     function ratifyOrder(\n>         SpentItem[] calldata, /* offer */\n>         ReceivedItem[] calldata, /* consideration */\n>         bytes calldata, /* context */\n>         bytes32[] calldata, /* orderHashes */\n>         uint256 /* contractNonce */\n>     ) external pure returns (bytes4 /* ratifyOrderMagicValue */ ) {\n>         return ContractOffererInterface.ratifyOrder.selector;\n>     }\n> \n>     function onERC1155Received(address, address, uint256, uint256, bytes calldata) external pure returns (bytes4) {\n>         return bytes4(0xf23a6e61);\n>     }\n> \n>     // function supportsInterface(\n>     //     bytes4 interfaceId\n>     // )\n>     //     public\n>     //     view\n>     //     virtual\n>     //     override(ERC165, ContractOffererInterface)\n>     //     returns (bool)\n>     // {\n>     //     return\n>     //         interfaceId == type(ContractOffererInterface).interfaceId ||\n>     //         super.supportsInterface(interfaceId);\n>     // }\n> \n>     /**\n>      * @dev Returns the metadata for this contract offerer.\n>      */\n>     function getSeaportMetadata()\n>         external\n>         pure\n>         override\n>         returns (\n>             string memory name,\n>             Schema[] memory schemas // map to Seaport Improvement Proposal IDs\n>         )\n>     {\n>         schemas = new Schema[](1);\n>         schemas[0].id = 1337;\n>         schemas[0].metadata = new bytes(0);\n> \n>         return (\"TestContractOffererNativeToken\", schemas);\n>     }\n> }\n> \n> contract CreateOffererTest is Test, BaseSeaportTest, BaseLiquidDelegateTest, SeaportHelpers {\n>     CreateOfferer createOfferer;\n>     WETH weth;\n>     uint256 startGas;\n>     User buyer;\n>     User seller;\n> \n>     OfferItem offerItem;\n>     ConsiderationItem considerationItem;\n>     OfferItem[] offerItems;\n>     ConsiderationItem[] considerationItems;\n>     SpentItem[] minimumReceived;\n>     SpentItem[] maximumSpent;\n> \n>     function setUp() public {\n>         OffererStructs.Parameters memory createOffererParameters =\n>             OffererStructs.Parameters({seaport: address(seaport), delegateToken: address(dt), principalToken: address(principal)});\n>         createOfferer = new CreateOfferer(createOffererParameters);\n>         weth = new WETH();\n>         // Setup buyer and seller\n>         seller = makeUser(\"seller\");\n>         vm.label(seller.addr, \"seller\");\n>         buyer = makeUser(\"buyer\");\n>         vm.label(buyer.addr, \"buyer\");\n>     }\n> \n>     function addOfferItem(OfferItem memory _offerItem) internal {\n>         offerItems.push(_offerItem);\n>     }\n> \n>     ///@dev reset the offer items array\n>     function resetOfferItems() internal {\n>         delete offerItems;\n>     }\n> \n>     ///@dev Construct and an offer item to the offer items array\n>     function addOfferItem(ItemType itemType, address token, uint256 identifier, uint256 startAmount, uint256 endAmount) internal {\n>         offerItem.itemType = itemType;\n>         offerItem.token = token;\n>         offerItem.identifierOrCriteria = identifier;\n>         offerItem.startAmount = startAmount;\n>         offerItem.endAmount = endAmount;\n>         addOfferItem(offerItem);\n>         delete offerItem;\n>     }\n> \n>     function addOfferItem(ItemType itemType, address token, uint256 identifier, uint256 amount) internal {\n>         addOfferItem({itemType: itemType, token: token, identifier: identifier, startAmount: amount, endAmount: amount});\n>     }\n> \n>     function addOfferItem(ItemType itemType, uint256 identifier, uint256 startAmount, uint256 endAmount) internal {\n>         if (itemType == ItemType.NATIVE) {\n>             addEthOfferItem(startAmount, endAmount);\n>         } else if (itemType == ItemType.ERC20) {\n>             addErc20OfferItem(startAmount, endAmount);\n>         } else if (itemType == ItemType.ERC1155) {\n>             addErc1155OfferItem(identifier, startAmount, endAmount);\n>         } else {\n>             addErc721OfferItem(identifier);\n>         }\n>     }\n> \n>     function addOfferItem(ItemType itemType, uint256 identifier, uint256 amt) internal {\n>         addOfferItem(itemType, identifier, amt, amt);\n>     }\n> \n>     function addErc721OfferItem(uint256 identifier) internal {\n>         addErc721OfferItem(address(mockERC721), identifier);\n>     }\n> \n>     function addErc721OfferItem(address token, uint256 identifier) internal {\n>         addErc721OfferItem(token, identifier, 1, 1);\n>     }\n> \n>     function addErc721OfferItem(address token, uint256 identifier, uint256 amount) internal {\n>         addErc721OfferItem(token, identifier, amount, amount);\n>     }\n> \n>     function addErc721OfferItem(address token, uint256 identifier, uint256 startAmount, uint256 endAmount) internal {\n>         addOfferItem(ItemType.ERC721, token, identifier, startAmount, endAmount);\n>     }\n> \n>     function addErc1155OfferItem(uint256 tokenId, uint256 amount) internal {\n>         addOfferItem(ItemType.ERC1155, address(mockERC1155), tokenId, amount, amount);\n>     }\n> \n>     function addErc20OfferItem(uint256 startAmount, uint256 endAmount) internal {\n>         addOfferItem(ItemType.ERC20, address(mockERC20), 0, startAmount, endAmount);\n>     }\n> \n>     function addErc20OfferItem(uint256 amount) internal {\n>         addErc20OfferItem(amount, amount);\n>     }\n> \n>     function addErc1155OfferItem(uint256 tokenId, uint256 startAmount, uint256 endAmount) internal {\n>         addOfferItem(ItemType.ERC1155, address(mockERC1155), tokenId, startAmount, endAmount);\n>     }\n> \n>     function addEthOfferItem(uint256 startAmount, uint256 endAmount) internal {\n>         addOfferItem(ItemType.NATIVE, address(0), 0, startAmount, endAmount);\n>     }\n> \n>     function addEthOfferItem(uint256 paymentAmount) internal {\n>         addEthOfferItem(paymentAmount, paymentAmount);\n>     }\n> \n>     ///@dev add a considerationItem to the considerationItems array\n>     function addConsiderationItem(ConsiderationItem memory _considerationItem) internal {\n>         considerationItems.push(_considerationItem);\n>     }\n> \n>     ///@dev reset the considerationItems array\n>     function resetConsiderationItems() internal {\n>         delete considerationItems;\n>     }\n> \n>     ///@dev construct a considerationItem and add it to the considerationItems array\n>     function addConsiderationItem(address payable recipient, ItemType itemType, address token, uint256 identifier, uint256 startAmount, uint256 endAmount) internal {\n>         considerationItem.itemType = itemType;\n>         considerationItem.token = token;\n>         considerationItem.identifierOrCriteria = identifier;\n>         considerationItem.startAmount = startAmount;\n>         considerationItem.endAmount = endAmount;\n>         considerationItem.recipient = recipient;\n>         addConsiderationItem(considerationItem);\n>         delete considerationItem;\n>     }\n> \n>     function addConsiderationItem(address payable recipient, ItemType itemType, uint256 identifier, uint256 amt) internal {\n>         if (itemType == ItemType.NATIVE) {\n>             addEthConsiderationItem(recipient, amt);\n>         } else if (itemType == ItemType.ERC20) {\n>             addErc20ConsiderationItem(recipient, amt);\n>         } else if (itemType == ItemType.ERC1155) {\n>             addErc1155ConsiderationItem(recipient, identifier, amt);\n>         } else {\n>             addErc721ConsiderationItem(recipient, identifier);\n>         }\n>     }\n> \n>     function addEthConsiderationItem(address payable recipient, uint256 paymentAmount) internal {\n>         addConsiderationItem(recipient, ItemType.NATIVE, address(0), 0, paymentAmount, paymentAmount);\n>     }\n> \n>     function addEthConsiderationItem(address payable recipient, uint256 startAmount, uint256 endAmount) internal {\n>         addConsiderationItem(recipient, ItemType.NATIVE, address(0), 0, startAmount, endAmount);\n>     }\n> \n>     function addErc20ConsiderationItem(address payable receiver, uint256 startAmount, uint256 endAmount) internal {\n>         addConsiderationItem(receiver, ItemType.ERC20, address(mockERC20), 0, startAmount, endAmount);\n>     }\n> \n>     function addErc20ConsiderationItem(address payable receiver, uint256 paymentAmount) internal {\n>         addErc20ConsiderationItem(receiver, paymentAmount, paymentAmount);\n>     }\n> \n>     function addErc721ConsiderationItem(address payable recipient, uint256 tokenId) internal {\n>         addConsiderationItem(recipient, ItemType.ERC721, address(mockERC721), tokenId, 1, 1);\n>     }\n> \n>     function addErc1155ConsiderationItem(address payable recipient, uint256 tokenId, uint256 amount) internal {\n>         addConsiderationItem(recipient, ItemType.ERC1155, address(mockERC1155), tokenId, amount, amount);\n>     }\n> \n>     receive() external payable {}\n> \n>     /// @dev Example of setting up one order\n>     function test_single_POC() public {\n>         TestContractOffererNativeToken contractOfferer1 = new TestContractOffererNativeToken(\n>                 address(seaport),\n>                 \"contractOffer1\"\n>             );\n>         vm.deal(address(contractOfferer1), 100 ether);\n> \n>         mockERC721.setApprovalForAll(address(contrac",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-09-delegate",
  "Code": [
    {
      "filename": "docs/SeaportDocumentation.md",
      "content": "---\ntitle: Interacting with Seaport\ncategory: 6520398b749af50013f52ff4\nslug: seaport-interactions\nparentDocSlug: seaport-overview\norder: 1\nhidden: false\n---\n\n# Seaport Documentation\n\nDocumentation around creating orders, fulfillment, and interacting with Seaport.\n\n## Table of Contents\n\n- [Order](#order)\n- [Order Fulfillment](#order-fulfillment)\n- [Sequence of Events](#sequence-of-events)\n- [Contract Orders](#contract-orders)\n- [Bulk Order Creation](#bulk-order-creation)\n- [Known Limitations And Workarounds](#known-limitations-and-workarounds)\n\n## Order\n\nEach order contains eleven key components:\n\n- The `offerer` of the order supplies all offered items and must either fulfill the order personally (i.e. `msg.sender == offerer`) or approve the order via signature (either standard 65-byte EDCSA, 64-byte EIP-2098, or an EIP-1271 `isValidSignature` check) or by listing the order on-chain (i.e. calling `validate`).\n- The `zone` of the order is an optional secondary account attached to the order with two additional privileges:\n  - The zone may cancel orders where it is named as the zone by calling `cancel`. (Note that offerers can also cancel their own orders, either individually or for all orders signed with their current counter at once by calling `incrementCounter`).\n  - \"Restricted\" orders (as specified by the order type) must either be executed by the zone or the offerer, or must be approved as indicated by a call to `validateOrder` when the caller is not the zone.\n- The `offer` contains an array of items that may be transferred from the offerer's account, where each item consists of the following components:\n  - The `itemType` designates the type of item, with valid types being:\n    * Ether (or other native token for the given chain) enum value: `NATIVE = 0`\n    * ERC20: enum value: `ERC20 = 1`\n    * ERC721: enum value: `ERC721 = 2`\n    * ERC1155: enum value: `ERC1155 = 3`\n    * ERC721 with \"criteria\" (explained below): enum value: `ERC721_WITH_CRITERIA = 4`\n    * ERC1155 with \"criteria\" (explained below): enum value: `ERC1155_WITH_CRITERIA = 5`\n  - The `token` designates the account of the item's token contract (with the null address used for Ether or other native tokens).\n  - The `identifierOrCriteria` represents either the ERC721 or ERC1155 token identifier or, in the case of a criteria-based item type, a merkle root composed of the valid set of token identifiers for the item. This value will be ignored for Ether and ERC20 item types, and can optionally be zero for criteria-based item types to allow for any identifier.\n  - The `startAmount` represents the amount of the item in question that will be required should the order be fulfilled at the moment the order becomes active.\n  - The `endAmount` represents the amount of the item in question that will be required should the order be fulfilled at the moment the order expires. If this value differs from the item's `startAmount`, the realized amount is calculated linearly based on the time elapsed since the order became active.\n- The `consideration` contains an array of items that must be received in order to fulfill the order. It contains all of the same components as an offered item, and additionally includes a `recipient` that will receive each item. This array may be extended by the fulfiller on order fulfillment so as to support \"tipping\" (e.g. relayer or referral payments).\n- The `orderType` designates one of four types for the order depending on three distinct preferences:\n  - `FULL` indicates that the order does not support partial fills, whereas `PARTIAL` enables filling some fraction of the order, with the important caveat that each item must be cleanly divisible by the supplied fraction (i.e. no remainder after division).\n  - `OPEN` indicates that the call to execute the order can be submitted by any account, whereas `RESTRICTED` requires that the order either be executed by the offerer or the zone of the order, or that a magic value indicating that the order is approved is returned upon calling `validateOrder` when the caller is not the zone.\n  - `CONTRACT` indicates that the order will be generated by the offerer upon a call from Seaport to `generateOrder`, then verified after execution with a follow-on call to `ratifyOrder` on the offerer.\n- The `startTime` indicates the block timestamp at which the order becomes active.\n- The `endTime` indicates the block timestamp at which the order expires. This value and the `startTime` are used in conjunction with the `startAmount` and `endAmount` of each item to derive their current amount.\n- The `zoneHash` represents an arbitrary 32-byte value that will be supplied to the zone when fulfilling restricted orders that the zone can utilize when making a determination on whether to authorize the order.\n- The `salt` represents an arbitrary source of entropy for the order.\n- The `conduitKey` is a `bytes32` value that indicates what conduit, if any, should be utilized as a source for token approvals when performing transfers. By default (i.e. when `conduitKey` is set to the zero hash), the offerer will grant ERC20, ERC721, and ERC1155 token approvals to Seaport directly so that it can perform any transfers specified by the order during fulfillment. In contrast, an offerer that elects to utilize a conduit will grant token approvals to the conduit contract corresponding to the supplied conduit key, and Seaport will then instruct that conduit to transfer the respective tokens.\n- The `counter` indicates a value that must match the current counter for the given offerer.\n\n## Order Fulfillment\n\nOrders are fulfilled via one of four methods:\n\n- Calling one of two \"standard\" functions, `fulfillOrder` and `fulfillAdvancedOrder`, where a second implied order will be constructed with the caller as the offerer, the consideration of the fulfilled order as the offer, and the offer of the fulfilled order as the consideration (with \"advanced\" orders containing the fraction that should be filled alongside a set of \"criteria resolvers\" that designate an identifier and a corresponding inclusion proof for each criteria-based item on the fulfilled order). All offer items will be transferred from the offerer of the order to the fulfiller, then all consideration items will be transferred from the fulfiller to the named recipient.\n- Calling the \"basic\" function, `fulfillBasicOrder` with one of six basic route types supplied (`ETH_TO_ERC721`, `ETH_TO_ERC1155`, `ERC20_TO_ERC721`, `ERC20_TO_ERC1155`, `ERC721_TO_ERC20`, and `ERC1155_TO_ERC20`) will derive the order to fulfill from a subset of components, assuming the order in question adheres to the following:\n  - The order only contains a single offer item and contains at least one consideration item.\n  - The order contains exactly one ERC721 or ERC1155 item and that item is not criteria-based.\n  - The offerer of the order is the recipient of the first consideration item.\n  - All other items have the same Ether (or other native tokens) or ERC20 item type and token.\n  - The order does not offer an item with Ether (or other native tokens) as its item type.\n  - The `startAmount` on each item must match that item's `endAmount` (i.e. items cannot have an ascending/descending amount).\n  - All \"ignored\" item fields (i.e. `token` and `identifierOrCriteria` on native items and `identifierOrCriteria` on ERC20 items) are set to the null address or zero.\n  - If the order has an ERC721 item, that item has an amount of `1`.\n  - If the order has multiple consideration items and all consideration items other than the first consideration item have the same item type as the offered item, the offered item amount is not less than the sum of all consideration item amounts excluding the first consideration item amount.\n- Calling one of two \"fulfill available\" functions, `fulfillAvailableOrders` and `fulfillAvailableAdvancedOrders`, where a group of orders are supplied alongside a group of fulfillments specifying which offer items can be aggregated into distinct transfers and which consideration items can be accordingly aggregated, and where any orders that have been cancelled, have an invalid time, or have already been fully filled will be skipped without causing the rest of the available orders to revert. Additionally, any remaining orders will be skipped once `maximumFulfilled` available orders have been located. Similar to the standard fulfillment method, all offer items will be transferred from the respective offerer to the fulfiller, then all consideration items will be transferred from the fulfiller to the named recipient.\n- Calling one of two \"match\" functions, `matchOrders` and `matchAdvancedOrders`, where a group of explicit orders are supplied alongside a group of fulfillments specifying which offer items to apply to which consideration items (and with the \"advanced\" case operating in a similar fashion to the standard method, but supporting partial fills via supplied `numerator` and `denominator` fractional values as well as an optional `extraData` argument that will be supplied as part of a call to the `validateOrder` function when fulfilling restricted order types or to `generateOrder` and `ratifyOrder` as \"context\" on contract order types). Note that orders fulfilled in this manner do not have an explicit fulfiller; instead, Seaport will simply ensure coincidence of wants across each order.  Note also that contract orders do not enforce usage of a specific conduit, but a Seaport app can require the usage of a specific conduit by setting allowances or approval on tokens for specific conduits.  If a fulfiller does not supply the correct conduit key, the call will revert.  There's currently no endpoint for finding which conduit a given Seaport app prefers.\n\nWhile the standard method can technically be used for fulfilling any order, it suffers from key efficiency limitations in certain scenarios:\n\n- It requires additional calldata compared to the basic method for simple \"hot paths\".\n- It requires the fulfiller to approve each consideration item, even if the consideration item can be fulfilled using an offer item (as is commonly the case when fulfilling an order that offers ERC20 items for an ERC721 or ERC1155 item and also includes consideration items with the same ERC20 item type for paying fees).\n- It can result in unnecessary transfers, whereas in the \"match\" case those transfers can be reduced to a more minimal set.\n\n> Note: Calls to Seaport that would fulfill or match a collection of advanced orders can be monitored and where there are unused offer items, it's possible for a third party to claim them. Anyone can monitor the mempool to find calls to `matchOrders` or `matchAdvancedOrders` without \"ad-hoc\" orders (where the offerer is the caller, hence does not require a signature) and calculate if there are any unused offer item amounts.  If there are unused offer item amounts, the third party can frontrun the transaction and supply themselves as the recipient, thereby allowing that third party to claim the unused offer items for themselves. A Seaport app or a zone could prevent this, or the fulfiller can utilize a private mempool, but by default it's possible.\n\n> Note: Contract orders can supply additional offer amounts when the order is executed. However, if they supply extra offer items with criteria, on the fly, the fulfiller won't be able to supply the necessary criteria resolvers, which would make fulfilling the order infeasible.  Seaport apps should specifically avoid returning criteria-based items and generally avoid mismatches between previewOrder and what's executed on-chain.\n\n### Balance and Approval Requirements\n\nWhen creating an offer, the following requirements should be checked to ensure that the order will be fulfillable:\n\n- The offerer should have sufficient balance of all offered items.\n- If the order does not indicate to use a conduit, the offerer should have sufficient approvals set for the Seaport contract for all offered ERC20, ERC721, and ERC1155 items.\n- If the order _does_ indicate to use a conduit, the offerer should have sufficient approvals set for the respective conduit contract for all offered ERC20, ERC721 and ERC1155 items.\n\nWhen fulfilling a _basic_ order, the following requirements need to be checked to ensure that the order will be fulfillable:\n\n- The above checks need to be performed to ensure that the offerer still has sufficient balance and approvals.\n- The fulfiller should have sufficient balance of all consideration items _except for those with an item type that matches the order's offered item type_ — by way of example, if the fulfilled order offers an ERC20 item and requires an ERC721 item to the offerer and the same ERC20 item to another recipient, the fulfiller needs to own the ERC721 item but does not need to own the ERC20 item as it will be sourced from the offerer.\n- If the fulfiller does not elect to utilize a conduit, they need to have sufficient approvals set for the Seaport contract for all ERC20, ERC721, and ERC1155 consideration items on the fulfilled order _except for ERC20 items with an item type that matches the order's offered item type_.\n- If the fulfiller _does_ elect to utilize a conduit, they need to have sufficient approvals set for their respective conduit for all ERC20, ERC721, and ERC1155 consideration items on the fulfilled order _except for ERC20 items with an item type that matches the order's offered item type_.\n- If the fulfilled order specifies Ether (or other native tokens) as consideration items, the fulfiller must be able to supply the sum total of those items as `msg.value`.\n\nWhen fulfilling a _standard_ order, the following requirements need to be checked to ensure that the order will be fulfillable:\n\n- The above checks need to be performed to ensure that the offerer still has sufficient balance and approvals.\n- The fulfiller should have sufficient balance of all consideration items _after receiving all offered items_ — by way of example, if the fulfilled order offers an ERC20 item and requires an ERC721 item to the offerer and the same ERC20 item to another recipient with an amount less than or equal to the offered amount, the fulfiller does not need to own the ERC20 item as it will first be received from the offerer.\n- If the fulfiller does not elect to utilize a conduit, they need to have sufficient approvals set for the Seaport contract for all ERC20, ERC721, and ERC1155 consideration items on the fulfilled order.\n- If the fulfiller _does_ elect to utilize a conduit, they need to have sufficient approvals set for their respective conduit for all ERC20, ERC721, and ERC1155 consideration items on the fulfilled order.\n- If the fulfilled order specifies Ether (or other native tokens) as consideration items, the fulfiller must be able to supply the sum total of those items as `msg.value`.\n\nWhen fulfilling a set of _match_ orders, the following requirements need to be checked to ensure that the order will be fulfillable:\n\n- Each account that sources the ERC20, ERC721, or ERC1155 item for an execution that will be performed as part of the fulfillment must have sufficient balance and approval on Seaport or the indicated conduit at the time the execution is triggered. Note that prior executions may supply the necessary balance for subsequent executions.\n- The sum total of all executions involving Ether (or other native tokens) must be supplied as `msg.value`. Note that executions where the offerer and the recipient are the same account will be filtered out of the final execution set.\n\n### Partial Fills\n\nWhen constructing an order, the offerer may elect to enable partial fills by setting an appropriate order type. Then, orders that support partial fills can be fulfilled for some _fraction_ of the respective order, allowing subsequent fills to bypass signature verification. To summarize a few key points on partial fills:\n\n- When creating orders that support partial fills or determining a fraction to fill on those orders, all items (both offer and consideration) on the order must be cleanly divisible by the supplied fraction (i.e. no remainder after division).\n- If the desired fraction to fill would result in more than the full order amount being filled, that fraction will be reduced to the amount remaining to fill. This applies to both partial fill attempts as well as full fill attempts. If this behavior is not desired (i.e. the fill should be \"all or none\"), the fulfiller can either use a \"basic\" order method if available (which requires that the full order amount be filled), or use the \"match\" order method and explicitly provide an order that requires the full desired amount be received back.\n  - By way of example: if one fulfiller tries to fill 1/2 of an order but another fulfiller first fills 3/4 of the order, the original fulfiller will end up filling 1/4 of the order.\n- If any of the items on a partially fillable order specify a different \"startAmount\" and \"endAmount (e.g. they are ascending-amount or descending-amount items), the fraction will be applied to _both_ amounts prior to determining the current price. This ensures that cleanly divisible amounts can be chosen when constructing the order without a dependency on the time when the order is ultimately fulfilled.\n- Partial fills can be combined with criteria-based items to enable constructing orders that offer or receive multiple items that would otherwise not be partially fillable (e.g. ERC721 items).\n\n  - By way of example: an offerer can create a partially fillable order to supply up to 10 ETH for up to 10 ERC721 items from a given collection; then, any fulfiller can fill a portion of that order until it has been fully filled (or cancelled).\n\n## Sequence of Events\n\n### Fulfill Order\n\nWhen fulfilling an order via `fulfillOrder` or `fulfillAdvancedOrder`:\n\n1. Hash order\n   - Derive hashes for offer items and consideration items\n   - Retrieve current counter for the offerer\n   - Derive hash for order\n2. Perform initial validation\n   - Ensure current time is inside order range\n   - Ensure valid caller for the order type; if the order type is restricted and the caller is not the offerer or the zone, call the zone to determine whether the order is valid\n3. Retrieve and update order status\n   - Ensure order is not cancelled\n   - Ensure order is not fully filled\n     - If the order is _partially_ filled, reduce the supplied fill amount if necessary so that the order is not overfilled\n   - Verify the order signature if not already validated\n   - Determine fraction to fill based on preference + available amount\n   - Update order status (validated + fill fraction)\n4. Determine amount for each item\n   - Compare start amount and end amount\n     - if they are equal: apply fill fraction to either one, ensure it divides cleanly, and use that amount\n     - if not: apply fill fraction to both, ensuring they both divide cleanly, then find linear fit based on current time\n5. Apply criteria resolvers\n   - Ensure each criteria resolver refers to a criteria-based order item\n   - Ensure the supplied identifier for each item is valid via inclusion proof if the item has a non-zero criteria root\n   - Update each item type and identifier\n   - Ensure all remaining items are non-criteria-based\n6. Emit OrderFulfilled event\n   - Include updated items (i.e. after amount adjustment and criteria resolution)\n7. Transfer offer items from offerer to caller\n   - Use either conduit or Seaport directly to source approvals, depending on order type\n8. Transfer consideration items from caller to respective recipients\n   - Use either conduit or Seaport directly to source approvals, depending on the fulfiller's stated preference\n\n> Note: `fulfillBasicOrder` works in a similar fashion, with a few exceptions: it reconstructs the order from a subset of order elements, skips linear fit amount adjustment and criteria resolution, requires that the full order amount be fillable, and performs a more minimal set of transfers by default when the offer item shares the same type and token as additional consideration items.\n\n### Match Orders\n\nWhen matching a group of orders via `matchOrders` or `matchAdvancedOrders`, steps 1 through 6 are nearly identical but are performed for _each_ supplied order. From there, the implementation diverges from standard fulfillments:\n\n7. Apply fulfillments\n   - Ensure each fulfillment refers to one or more offer items and one or more consideration items, all with the same type and token, and with the same approval source for each offer item and the same recipient for each consideration item\n   - Reduce the amount on each offer item and each consideration item to zero and track total reduced amounts for each\n   - Compare total amounts for each and add back the remaining amount to the first item on the appropriate side of the order\n   - Return a single execution for each fulfillment\n8. Scan each consideration item and ensure that none still have a nonzero amount remaining\n9. Perform transfers as part of each execution\n   - Use either conduit or Seaport directly to source approvals, depending on the original order type\n   - Ignore each execution where `to == from`\n\n## Contract Orders\n\nSeaport v1.2 introduced support for a new type of order: the contract order.  In brief, a smart contract that implements the `ContractOffererInterface` (referred to as an “Seaport app contract” or \"Seaport app\" in the docs and a “contract offerer” in the code) can now provide a dynamically generated order (a contract order) in response to a buyer or seller’s contract order request.  Support for contract orders puts on-chain liquidity on equal footing with off-chain liquidity in the Seaport ecosystem.  Further, the two types of liquidity are now broadly composable.\n\nThis unlocks a broad range of Seaport-native functionality, including instant conversion from an order’s specified currency (e.g. WETH) to a fulfiller’s preferred currency (e.g. ETH or DAI), flashloan-enriched functionality, liquidation engines, and more.  In general, Seaport apps allow the Seaport community to extend default Seaport functionality.  Developers with ideas or use cases that could be implemented as Seaport apps should open PRs in [the Seaport Improvement Protocol (SIP) repo](https://github.com/ProjectOpenSea/SIPs).\n\n### Creating a Seaport App\n\nAnyone can build a Seaport app contract that interfaces with Seaport.  A Seaport app just has to comply with the following interface:\n\n```solidity\ninterface ContractOffererInterface {\n\nfunction generateOrder(\n        address fulfiller,\n        SpentItem[] calldata minimumReceived,\n        SpentItem[] calldata maximumSpent,\n        bytes calldata context\n    )\n        external\n        returns (SpentItem[] memory offer, ReceivedItem[] memory consideration);\n\nfunction ratifyOrder(\n        SpentItem[] calldata offer,\n        ReceivedItem[] calldata consideration,\n        bytes calldata context,\n        bytes32[] calldata orderHashes,\n        uint256 contractNonce\n    ) external returns (bytes4 ratifyOrderMagicValue);\n\nfunction previewOrder(\n        address caller,\n        address fulfiller,\n        SpentItem[] calldata minimumReceived,\n        SpentItem[] calldata maximumSpent,\n        bytes calldata context\n    )\n        external\n        view\n        returns (SpentItem[] memory offer, ReceivedItem[] memory consideration);\n\nfunction getSeaportMetadata()\n        external\n        view\n        returns (\n            string memory name,\n            Schema[] memory schemas\n        );\n}\n```\n\nSee the [TestContractOfferer.sol](https://github.com/ProjectOpenSea/seaport/blob/main/contracts/test/TestContractOfferer.sol) file in `./contracts/test/` for an example of an MVP Seaport app contract.\n\n### Arguments and Basic Functionality\n\nWhen Seaport receives a contract order request from a fulfiller, it calls the Seaport app contract’s `generateOrder` function, which returns an array of `SpentItem`s and an array of `ReceivedItem`s.  The Seaport app can adjust the response according to its own rules and if its response falls within the acceptable range specified in the original requester's offer (`minimumReceived`) and consideration (`maximumSpent`) parameters, Seaport will execute the orders.  If not, the call will revert.\n\nNote that when a request for a contract order is made, the requester is not supplying a conventional, signed order.  Instead, the requester is supplying parameters that specify an acceptable range for the Seaport app to work within.\n\nThe `minimumReceived` array represents the smallest set that a requester is willing to accept from the Seaport app contract in the deal, though the Seaport app can provide more.  The `maximumSpent` array represents the largest set that a requester is willing to provide to the Seaport app in the deal, though the Seaport app can accept less. In a very straightforward case, the requester's `minimumReceived` array would become the `offer` array on the Seaport app's contract order and the requester's `maximumSpent` array would become the `consideration` array on the Seaport app's contract order.  These two guardrails can provide protection against slippage, among other safety functions.\n\nWhere a Seaport app provides extra offer items, increases offer item amounts (i.e. where it voluntarily exceeds the `minimumReceived` specified by the requester), removes consideration items, or reduces consideration item amounts (i.e. where it voluntarily demands less than the `maximumSpent` specified by the requester), those changes are collectively referred to as a \"rebate.\"  When a Seaport app attempts to provide fewer offer items, decreased offer item amounts, additional consideration items, or increased consideration item amounts, those changes are collectively referred to as a \"penalty,\" and Seaport will catch and reject the order.\n\nAn optimal Seaport app should return an order with penalties when its `previewOrder` function is called with unacceptable `minimumReceived` and `maximumSpent` arrays, so that the caller can learn what the Seaport app expects. But it should revert when its `generateOrder` is called with unacceptable `minimumReceived` and `maximumSpent` arrays, so the function fails fast, gets skipped, and avoids wasting gas by leaving the validation to Seaport.\n\n### The Context Concept\n\nThe third argument provided to a Seaport app contract is `context`, which functions analogously to a zone’s `extraData` argument. For example, a Seaport app that provides AMM-like functionality might use context to determine which token IDs a buyer prefers or whether to take an “exact in” or “exact out” approach to deriving the order.  The `context` is arbitrary bytes, but should be encoded according to a standard provided in [the Seaport Improvement Protocol (SIP) repo](https://github.com/ProjectOpenSea/SIPs).\n\nWhile it’s still early days for the SIP ecosystem, every order generator contract should eventually be able to find an SIP that provides a `context` encoding and decoding standard that matches its use case.  Order generators that adopt one or more SIP-standardized encoding or decoding approaches should signal that fact according to the specifications found in [SIP 5](https://github.com/ProjectOpenSea/SIPs/blob/main/SIPS/sip-5.md), which functions analogously to EIP 165.\n\nContext may be left empty, or it may contain all of the information necessary to fulfill the contract order (in place of fleshed-out `minimumReceived` and `maximumSpent` arguments). The latter case should only be utilized when the Seaport app contract in question is known to be reliable, as using the `minimumReceived` and `maximumSpent` arrays will cause Seaport to perform additional validation that the returned order meets the fulfiller’s expectations.  Note that `minimumReceived` is optional, but `maximumSpent` is not.  Even if the context is doing the majority of the work, `maximumSpent` must still be present as a safeguard.\n\n### Lifecycle\n\nContract orders are not signed and validated ahead of time like the other Seaport order types, but instead are generated on demand by the Seaport app contract.  Order hashes for orders created by order generators are derived on the fly in `_getGeneratedOrder`, based on the Seaport app’s address and the `contractNonce`, which is incremented per order generator on each generated contract order.  By virtue of responding to a call from Seaport, a Seaport app is effectively stating that its provided offer is acceptable and valid from its perspective.\n\nThe contract order lifecycle contains both a stateful `generateOrder` call to derive the contract order prior to execution and a stateful `ratifyOrder` call performed after execution.  This means that contract orders can respond to the condition of e.g. the price of a fungible token before execution and verify post-execution that a flashloan was repaid or a critical feature of an NFT was not changed mid-flight.\n\n### Divergence from Non-Contract Orders\n\nNote that when a collection-wide criteria-based item (criteria = 0) is provided as an input to a contract order, the Seaport app contract has full latitude to choose any identifier they want mid-flight. This deviates from Seaport’s behavior elsewhere, where the fulfiller can pick which identifier to receive by providing a CriteriaResolver.  For contract order requests with identifierOrCriteria = 0, Seaport does not expect a corresponding CriteriaResolver, and will revert if one is provided.  See `_getGeneratedOrder` and `_compareItems` for more detail.\n\nDuring fulfillment, contract orders may designate native token (e.g. Ether) offer items; order generator contracts can then send native tokens directly to Seaport as part of the `generateOrder` call (or otherwise), allowing the fulfiller to use those native tokens. Any unused native tokens will be sent to the fulfiller (i.e. the caller). Native tokens can only be sent to Seaport when the reentrancy lock is set, and only then under specific circumstances. This enables conversion between ETH and WETH on-the-fly, among other possibilities. Note that any native tokens sent to Seaport will be immediately spendable by the current (or next) caller.  Note also that this is a deviation from Seaport’s behavior elsewhere, where buyers may not supply native tokens as offer items.\n\nSeaport also makes an exception to its normal reentrancy policies for order generator contracts.  Order generator contracts may call the receive hook and provide native tokens.  Anything that’s available to the Seaport app can be spent, including `msg.value` and balance.\n\nBuyers interacting with order generator contracts should note that in some cases, order generator contracts will be able to lower the value of an offered NFT by transferring out valuable tokens that are attached to the NFT.  For example, a Seaport app could modify a property of an NFT it owns when Seaport calls its `generateOrder` function.  Consider using a mirrored order that allows for a post-transfer validation, such as a contract order or a restricted order, in cases like this.\n\n# Example Lifecycle Journey\n\nTo recap everything discussed above, here’s a description of the lifecycle of an example contract order:\n\n- An EOA buyer calls `fulfillOrder` and passes in an `Order` struct with `OrderParameters` that has `OrderType` of `CONTRACT`.  Basically, the order says, \"Go to the Seaport app contract at 0x123 and tell it I want to buy at least one Blitmap.  Tell the Seaport app that I'm willing to spend up to 10 ETH but no more.\"\n- `fulfillOrder` calls `_validateAndFulfillAdvancedOrder`, as with other order types.\n- `_validateAndFulfillAdvancedOrder` calls `_validateOrderAndUpdateStatus`, as with other order types.\n- Inside `_validateOrderAndUpdateStatus`, at the point where the code path hits the line `if (orderParameters.orderType == OrderType.CONTRACT) { ...`, the code path for contract orders diverges from the code path for other order types.  \n- After some initial checks, `_validateOrderAndUpdateStatus` calls `_getGeneratedOrder`.\n- `_getGeneratedOrder` does a low level call to the targeted order generator's `generateOrder` function.\n- The Seaport app contract can do pretty much anything it wants at this point, but a typical example would include processing the arguments it received, picking some NFTs it’s willing to sell, and returning a `SpentItem` array and a `ReceivedItem` array.  In this example narrative, the Seaport app's response says \"OK, I'm willing to sell the Blitmaps item for 10 ETH.\"\n- `_getGeneratedOrder` massages the result of the external `generateOrder` call into Seaport format, does some checks, and then returns the order hash to `_validateOrderAndUpdateStatus`.\n- `_validateOr"
    }
  ]
}