{
  "Title": "M-3: User can trade away an asset using Balancer batchSwap without removing it from account",
  "Content": "# Issue M-3: User can trade away an asset using Balancer batchSwap without removing it from account \n\nSource: https://github.com/sherlock-audit/2022-11-sentiment-judging/issues/7 \n\n## Found by \nobront\n\n## Summary\n\nBalancer's `batchSwap()` function takes in an `amount` of tokens to trade at each step of the swap. This amount can actually exceed the amount returned from the previous step. Because BalancerController.sol uses only the first token in the chain as `tokensOut`, a user can abuse this functionality to empty their account of a token while bypassing the expected `removeAsset` calls.\n\n## Vulnerability Detail\n\nBalancer's `batchSwap()` functionality takes in an array of `BatchSwapSteps`, each of which dictates a pool to use for the swap, assets to swap to and from, an amount, and some additional user data (which is currently unused by Balancer).\n\nThe expectation is that users will either leave `amount = 0` (which will autofill the amount returned from the last step) or will set `amount` manually to some smaller value. \n\nHowever, it is also possible to input an `amount` that is greater than the value returned by the previous step, if you own those tokens and you have already approved the Balancer contract to trade them.\n\nUsing this technique, a user could send their tokens to Balancer without having them flagged by Sentiment as `tokensOut`. In an extreme case, this would allow them to get rid of all their tokens, without their account being updated to reflect this.\n\nHere is an example:\n- A user has 400 BAL and 100 WETH\n- They call `batchSwap()` with the path BAL => WETH => USDC\n- For the first step, they set `amount = 400`\n- For the second step, they set `amount = [amount returned from step 1] + 100`\n- The result is that they will have traded all of their BAL and WETH into USDC, but only BAL will appear in `tokensOut`\n\n[Here is a gist with a proof of concept showing a user decreasing their WETH balance without WETH appearing in tokensOut.](https://gist.github.com/zobront/bb35345412536b4209ed6c94c26a5c29)\n\n## Impact\n\nUsers have the ability to use the `batchSwap()` functionality to throw off the accounting on their account, removing a token but keeping the token in their `assets` array and keeping `hasAsset[token] = true`.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-sentiment/blob/main/controller-merged/src/balancer/BalancerController.sol#L193-L197\n\nhttps://github.com/sherlock-audit/2022-11-sentiment/blob/main/controller-merged/src/balancer/BalancerController.sol#L219-L222\n\n## Tool used\n\nManual Review, Foundry\n\n## Recommendation\n\nBalancer's batchSwap() function returns int256[] memory assetDeltas, which provide details on the final amounts of each asset that are inputted and outputted from the function.\n\nRather than try to manually calculate these values, the best option is likely the following:\n- Use an in-line assembly block to STATICCALL Balancer's canBatchSwap() to return the asset deltas\n- Any positive number in assetDeltas means the token belongs in tokensOut\n- Any negative number in assetDeltas means the token belongs in tokensIn\n\n## Discussion\n\n**r0ohafza**\n\nPR: https://github.com/sentimentxyz/controller/pull/49\n\n**zobront**\n\nConfirmed fix. Didn't follow recommendation above, but blocked all trades with intermediate amounts > 0, so problem is solved.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/17",
  "Code": [
    {
      "filename": "controller-merged/src/balancer/BalancerController.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {IController} from \"../core/IController.sol\";\nimport {IVault, IAsset} from \"./IVault.sol\";\n\n/**\n    @title Balancer V2 Controller\n    @notice Balance v2 controller for join/exit/swap/batchSwap (multiHop)\n*/\ncontract BalancerController is IController {\n\n    /* -------------------------------------------------------------------------- */\n    /*                             CONSTANT VARIABLES                             */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice joinPool(bytes32,address,address,(address[],uint256[],bytes,bool))\n    bytes4 constant JOIN = 0xb95cac28;\n\n    /// @notice exitPool(bytes32,address,address,(address[],uint256[],bytes,bool))\n    bytes4 constant EXIT = 0x8bdb3913;\n\n    /// @notice swap((bytes32,uint8,address,address,uint256,bytes),(address,bool,address,bool),uint256,uint256)\n    bytes4 constant SWAP = 0x52bbbe29;\n    bytes4 constant BATCH_SWAP = 0x945bcec9;\n\n    /* -------------------------------------------------------------------------- */\n    /*                              EXTERNAL FUNCTIONS                            */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IController\n    function canCall(address target, bool useEth, bytes calldata data)\n        external\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        bytes4 sig = bytes4(data);\n\n        if (sig == JOIN)\n            return canJoin(target, useEth, data[4:]);\n        if (sig == EXIT)\n            return canExit(target, useEth, data[4:]);\n        if (sig == SWAP)\n            return canSwap(target, useEth, data[4:]);\n        if (sig == BATCH_SWAP)\n            return canBatchSwap(target, useEth, data[4:]);\n        return (false, new address[](0), new address[](0));\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             INTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    function canJoin(address target, bool, bytes calldata data)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        (\n            bytes32 poolId,\n            ,\n            ,\n            IVault.JoinPoolRequest memory request\n        ) = abi.decode(data, (\n                bytes32, address, address, IVault.JoinPoolRequest\n            )\n        );\n        address[] memory tokensIn = new address[](1);\n        address[] memory tokensOut = new address[](request.assets.length);\n\n        uint i; uint j;\n        while(i < request.assets.length) {\n            if (\n                request.maxAmountsIn[i] > 0 &&\n                address(request.assets[i]) != address(0)\n            )\n                tokensOut[j++] = address(request.assets[i]);\n            unchecked { ++i; }\n        }\n        assembly { mstore(tokensOut, j) }\n\n        (tokensIn[0],) = IVault(target).getPool(poolId);\n\n        return (\n            true,\n            tokensIn,\n            tokensOut\n        );\n    }\n\n    function canExit(address target, bool, bytes calldata data)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        (\n            bytes32 poolId,\n            ,\n            ,\n            IVault.ExitPoolRequest memory request\n        ) = abi.decode(data, (\n                bytes32, address, address, IVault.ExitPoolRequest\n            )\n        );\n        address[] memory tokensOut = new address[](1);\n        address[] memory tokensIn = new address[](request.assets.length);\n\n        uint i; uint j;\n        while(i < request.assets.length) {\n            if (address(request.assets[i]) != address(0))\n                tokensIn[j++] = address(request.assets[i]);\n            unchecked { ++i; }\n        }\n        assembly { mstore(tokensIn, j) }\n\n        (tokensOut[0],) = IVault(target).getPool(poolId);\n\n        return (\n            true,\n            tokensIn,\n            tokensOut\n        );\n    }\n\n    function canSwap(address, bool, bytes calldata data)\n        internal\n        pure\n        returns (bool, address[] memory, address[] memory)\n    {\n        (\n            IVault.SingleSwap memory swap,\n            ,\n            ,\n        ) = abi.decode(data, (\n                IVault.SingleSwap, IVault.FundManagement, uint256, uint256\n            )\n        );\n\n        address[] memory tokensIn;\n        address[] memory tokensOut;\n\n        if (address(swap.assetIn) == address(0)) {\n            tokensIn = new address[](1);\n            tokensIn[0] = address(swap.assetOut);\n            return (\n                true,\n                tokensIn,\n                new address[](0)\n            );\n        }\n\n        if (address(swap.assetOut) == address(0)) {\n            tokensOut = new address[](1);\n            tokensOut[0] = address(swap.assetIn);\n            return (\n                true,\n                new address[](0),\n                tokensOut\n            );\n        }\n\n        tokensIn = new address[](1);\n        tokensOut = new address[](1);\n        tokensOut[0] = address(swap.assetIn);\n        tokensIn[0] = address(swap.assetOut);\n\n        return (\n            true,\n            tokensIn,\n            tokensOut\n        );\n    }\n\n    function canBatchSwap(address, bool, bytes calldata data)\n        internal\n        pure\n        returns (bool, address[] memory, address[] memory)\n    {\n        (\n            ,\n            IVault.BatchSwapStep[] memory swaps,\n            IAsset[] memory assets,\n            ,\n            ,\n        ) = abi.decode(data, (\n                uint8, IVault.BatchSwapStep[], IAsset[], IVault.FundManagement, uint256[], uint256\n            )\n        );\n\n        if (!isMultiHopSwap(swaps))\n            return (false, new address[](0), new address[](0));\n\n        uint tokenInIndex = swaps[swaps.length - 1].assetOutIndex;\n        uint tokenOutIndex = swaps[0].assetInIndex;\n\n        address[] memory tokensIn;\n        address[] memory tokensOut;\n\n        if (address(assets[tokenOutIndex]) == address(0)) {\n            tokensIn = new address[](1);\n            tokensIn[0] = address(assets[tokenInIndex]);\n            return (\n                true,\n                tokensIn,\n                new address[](0)\n            );\n        }\n\n        if (address(assets[tokenInIndex]) == address(0)) {\n            tokensOut = new address[](1);\n            tokensOut[0] = address(assets[tokenOutIndex]);\n            return (\n                true,\n                new address[](0),\n                tokensOut\n            );\n        }\n\n        tokensIn = new address[](1);\n        tokensOut = new address[](1);\n        tokensOut[0] = address(assets[tokenOutIndex]);\n        tokensIn[0] = address(assets[tokenInIndex]);\n\n        return (\n            true,\n            tokensIn,\n            tokensOut\n        );\n    }\n\n    function isMultiHopSwap(IVault.BatchSwapStep[] memory swaps)\n        internal\n        pure\n        returns (bool)\n    {\n        uint steps = swaps.length;\n        for (uint i; i < steps - 1; i++) {\n            if (swaps[i].assetOutIndex != swaps[i+1].assetInIndex)\n                return false;\n        }\n        return true;\n    }\n}"
    },
    {
      "filename": "controller-merged/src/balancer/BalancerController.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {IController} from \"../core/IController.sol\";\nimport {IVault, IAsset} from \"./IVault.sol\";\n\n/**\n    @title Balancer V2 Controller\n    @notice Balance v2 controller for join/exit/swap/batchSwap (multiHop)\n*/\ncontract BalancerController is IController {\n\n    /* -------------------------------------------------------------------------- */\n    /*                             CONSTANT VARIABLES                             */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice joinPool(bytes32,address,address,(address[],uint256[],bytes,bool))\n    bytes4 constant JOIN = 0xb95cac28;\n\n    /// @notice exitPool(bytes32,address,address,(address[],uint256[],bytes,bool))\n    bytes4 constant EXIT = 0x8bdb3913;\n\n    /// @notice swap((bytes32,uint8,address,address,uint256,bytes),(address,bool,address,bool),uint256,uint256)\n    bytes4 constant SWAP = 0x52bbbe29;\n    bytes4 constant BATCH_SWAP = 0x945bcec9;\n\n    /* -------------------------------------------------------------------------- */\n    /*                              EXTERNAL FUNCTIONS                            */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IController\n    function canCall(address target, bool useEth, bytes calldata data)\n        external\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        bytes4 sig = bytes4(data);\n\n        if (sig == JOIN)\n            return canJoin(target, useEth, data[4:]);\n        if (sig == EXIT)\n            return canExit(target, useEth, data[4:]);\n        if (sig == SWAP)\n            return canSwap(target, useEth, data[4:]);\n        if (sig == BATCH_SWAP)\n            return canBatchSwap(target, useEth, data[4:]);\n        return (false, new address[](0), new address[](0));\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             INTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    function canJoin(address target, bool, bytes calldata data)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        (\n            bytes32 poolId,\n            ,\n            ,\n            IVault.JoinPoolRequest memory request\n        ) = abi.decode(data, (\n                bytes32, address, address, IVault.JoinPoolRequest\n            )\n        );\n        address[] memory tokensIn = new address[](1);\n        address[] memory tokensOut = new address[](request.assets.length);\n\n        uint i; uint j;\n        while(i < request.assets.length) {\n            if (\n                request.maxAmountsIn[i] > 0 &&\n                address(request.assets[i]) != address(0)\n            )\n                tokensOut[j++] = address(request.assets[i]);\n            unchecked { ++i; }\n        }\n        assembly { mstore(tokensOut, j) }\n\n        (tokensIn[0],) = IVault(target).getPool(poolId);\n\n        return (\n            true,\n            tokensIn,\n            tokensOut\n        );\n    }\n\n    function canExit(address target, bool, bytes calldata data)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        (\n            bytes32 poolId,\n            ,\n            ,\n            IVault.ExitPoolRequest memory request\n        ) = abi.decode(data, (\n                bytes32, address, address, IVault.ExitPoolRequest\n            )\n        );\n        address[] memory tokensOut = new address[](1);\n        address[] memory tokensIn = new address[](request.assets.length);\n\n        uint i; uint j;\n        while(i < request.assets.length) {\n            if (address(request.assets[i]) != address(0))\n                tokensIn[j++] = address(request.assets[i]);\n            unchecked { ++i; }\n        }\n        assembly { mstore(tokensIn, j) }\n\n        (tokensOut[0],) = IVault(target).getPool(poolId);\n\n        return (\n            true,\n            tokensIn,\n            tokensOut\n        );\n    }\n\n    function canSwap(address, bool, bytes calldata data)\n        internal\n        pure\n        returns (bool, address[] memory, address[] memory)\n    {\n        (\n            IVault.SingleSwap memory swap,\n            ,\n            ,\n        ) = abi.decode(data, (\n                IVault.SingleSwap, IVault.FundManagement, uint256, uint256\n            )\n        );\n\n        address[] memory tokensIn;\n        address[] memory tokensOut;\n\n        if (address(swap.assetIn) == address(0)) {\n            tokensIn = new address[](1);\n            tokensIn[0] = address(swap.assetOut);\n            return (\n                true,\n                tokensIn,\n                new address[](0)\n            );\n        }\n\n        if (address(swap.assetOut) == address(0)) {\n            tokensOut = new address[](1);\n            tokensOut[0] = address(swap.assetIn);\n            return (\n                true,\n                new address[](0),\n                tokensOut\n            );\n        }\n\n        tokensIn = new address[](1);\n        tokensOut = new address[](1);\n        tokensOut[0] = address(swap.assetIn);\n        tokensIn[0] = address(swap.assetOut);\n\n        return (\n            true,\n            tokensIn,\n            tokensOut\n        );\n    }\n\n    function canBatchSwap(address, bool, bytes calldata data)\n        internal\n        pure\n        returns (bool, address[] memory, address[] memory)\n    {\n        (\n            ,\n            IVault.BatchSwapStep[] memory swaps,\n            IAsset[] memory assets,\n            ,\n            ,\n        ) = abi.decode(data, (\n                uint8, IVault.BatchSwapStep[], IAsset[], IVault.FundManagement, uint256[], uint256\n            )\n        );\n\n        if (!isMultiHopSwap(swaps))\n            return (false, new address[](0), new address[](0));\n\n        uint tokenInIndex = swaps[swaps.length - 1].assetOutIndex;\n        uint tokenOutIndex = swaps[0].assetInIndex;\n\n        address[] memory tokensIn;\n        address[] memory tokensOut;\n\n        if (address(assets[tokenOutIndex]) == address(0)) {\n            tokensIn = new address[](1);\n            tokensIn[0] = address(assets[tokenInIndex]);\n            return (\n                true,\n                tokensIn,\n                new address[](0)\n            );\n        }\n\n        if (address(assets[tokenInIndex]) == address(0)) {\n            tokensOut = new address[](1);\n            tokensOut[0] = address(assets[tokenOutIndex]);\n            return (\n                true,\n                new address[](0),\n                tokensOut\n            );\n        }\n\n        tokensIn = new address[](1);\n        tokensOut = new address[](1);\n        tokensOut[0] = address(assets[tokenOutIndex]);\n        tokensIn[0] = address(assets[tokenInIndex]);\n\n        return (\n            true,\n            tokensIn,\n            tokensOut\n        );\n    }\n\n    function isMultiHopSwap(IVault.BatchSwapStep[] memory swaps)\n        internal\n        pure\n        returns (bool)\n    {\n        uint steps = swaps.length;\n        for (uint i; i < steps - 1; i++) {\n            if (swaps[i].assetOutIndex != swaps[i+1].assetInIndex)\n                return false;\n        }\n        return true;\n    }\n}"
    }
  ]
}