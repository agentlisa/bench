{
  "Title": "[N-03] Function read() does not revert with \"OLD!\" as mentioned in comments",
  "Content": "\nThere is 1 instance of this issue:\n\nhttps://github.com/open-dollar/od-contracts/blob/f4f0246bb26277249c1d5afe6201d4d9096e52e6/src/contracts/oracles/CamelotRelayer.sol#L91C1-L101C4\n\nFunction does not revert with \"OLD!\" since there is no such revert message in the consult function.\n```solidity\nFile: CamelotRelayer.sol\n092:   function read() external view returns (uint256 _result) {\n093:     // This call may revert with 'OLD!' if the pool doesn't have enough cardinality or initialized history \n094:     (int24 _arithmeticMeanTick,) = OracleLibrary.consult(camelotPair, quotePeriod);\n095:     uint256 _quoteAmount = OracleLibrary.getQuoteAtTick({\n096:       tick: _arithmeticMeanTick,\n097:       baseAmount: baseAmount,\n098:       baseToken: baseToken,\n099:       quoteToken: quoteToken\n100:     });\n101:     _result = _parseResult(_quoteAmount);\n102:   }\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-10-opendollar",
  "Code": [
    {
      "filename": "src/contracts/oracles/CamelotRelayer.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\nimport {IBaseOracle} from '@interfaces/oracles/IBaseOracle.sol';\nimport {ICamelotRelayer} from '@interfaces/oracles/ICamelotRelayer.sol';\nimport {IERC20Metadata} from '@openzeppelin/token/ERC20/extensions/IERC20Metadata.sol';\n// import {ICamelotFactory} from '@camelot/interfaces/ICamelotFactory.sol';\nimport {IAlgebraFactory} from '@interfaces/factories/IAlgebraFactory.sol';\nimport {ICamelotPair} from '@camelot/interfaces/ICamelotPair.sol';\nimport {OracleLibrary} from '@uniswap/v3-periphery/contracts/libraries/OracleLibrary.sol';\nimport {CAMELOT_V3_FACTORY, GOERLI_CAMELOT_V3_FACTORY} from '@script/Registry.s.sol';\n\n/**\n * @title  CamelotRelayer\n * @notice This contracts consults a CamelotRelayer TWAP and transforms the result into a standard IBaseOracle feed\n * @dev    The quote obtained from the pool query is transformed into an 18 decimals format\n */\ncontract CamelotRelayer is IBaseOracle, ICamelotRelayer {\n  // --- Registry ---\n  address internal constant _CAMELOT_FACTORY = GOERLI_CAMELOT_V3_FACTORY;\n\n  /// @inheritdoc ICamelotRelayer\n  address public camelotPair;\n  /// @inheritdoc ICamelotRelayer\n  address public baseToken;\n  /// @inheritdoc ICamelotRelayer\n  address public quoteToken;\n\n  // --- Data ---\n  /// @inheritdoc IBaseOracle\n  string public symbol;\n\n  /// @inheritdoc ICamelotRelayer\n  uint128 public baseAmount;\n  /// @inheritdoc ICamelotRelayer\n  uint256 public multiplier;\n  /// @inheritdoc ICamelotRelayer\n  uint32 public quotePeriod;\n\n  constructor(address _baseToken, address _quoteToken, uint32 _quotePeriod) {\n    // camelotPair = ICamelotFactory(_CAMELOT_FACTORY).getPair(_baseToken, _quoteToken);\n    camelotPair = IAlgebraFactory(_CAMELOT_FACTORY).poolByPair(_baseToken, _quoteToken);\n    if (camelotPair == address(0)) revert CamelotRelayer_InvalidPool();\n\n    address _token0 = ICamelotPair(camelotPair).token0();\n    address _token1 = ICamelotPair(camelotPair).token1();\n\n    // The factory validates that both token0 and token1 are desired baseToken and quoteTokens\n    if (_token0 == _baseToken) {\n      baseToken = _token0;\n      quoteToken = _token1;\n    } else {\n      baseToken = _token1;\n      quoteToken = _token0;\n    }\n\n    baseAmount = uint128(10 ** IERC20Metadata(_baseToken).decimals());\n    multiplier = 18 - IERC20Metadata(_quoteToken).decimals();\n    quotePeriod = _quotePeriod;\n\n    symbol = string(abi.encodePacked(IERC20Metadata(_baseToken).symbol(), ' / ', IERC20Metadata(_quoteToken).symbol()));\n  }\n\n  /**\n   * @dev    Method will return invalid if the pool doesn't have enough history\n   * @inheritdoc IBaseOracle\n   */\n  function getResultWithValidity() external view returns (uint256 _result, bool _validity) {\n    // If the pool doesn't have enough history return false\n    if (OracleLibrary.getOldestObservationSecondsAgo(camelotPair) < quotePeriod) {\n      return (0, false);\n    }\n    // Consult the query with a TWAP period of quotePeriod\n    (int24 _arithmeticMeanTick,) = OracleLibrary.consult(camelotPair, quotePeriod);\n    // Calculate the quote amount\n    uint256 _quoteAmount = OracleLibrary.getQuoteAtTick({\n      tick: _arithmeticMeanTick,\n      baseAmount: baseAmount,\n      baseToken: baseToken,\n      quoteToken: quoteToken\n    });\n    // Process the quote result to 18 decimal quote\n    _result = _parseResult(_quoteAmount);\n    _validity = true;\n  }\n\n  /**\n   * @dev    This method may revert with 'OLD!' if the pool doesn't have enough cardinality or initialized history\n   * @inheritdoc IBaseOracle\n   */\n  function read() external view returns (uint256 _result) {\n    // This call may revert with 'OLD!' if the pool doesn't have enough cardinality or initialized history\n    (int24 _arithmeticMeanTick,) = OracleLibrary.consult(camelotPair, quotePeriod);\n    uint256 _quoteAmount = OracleLibrary.getQuoteAtTick({\n      tick: _arithmeticMeanTick,\n      baseAmount: baseAmount,\n      baseToken: baseToken,\n      quoteToken: quoteToken\n    });\n    _result = _parseResult(_quoteAmount);\n  }\n\n  function _parseResult(uint256 _quoteResult) internal view returns (uint256 _result) {\n    return _quoteResult * 10 ** multiplier;\n  }\n}"
    }
  ]
}