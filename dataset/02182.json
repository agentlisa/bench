{
  "Title": "M-17: minimumPull Vault parameter cannot be adjusted",
  "Content": "# Issue M-17: minimumPull Vault parameter cannot be adjusted \n\nSource: https://github.com/sherlock-audit/2023-01-derby-judging/issues/154 \n\n## Found by \nhyh\n\n## Summary\n\n`minimumPull` is hardcoded to be `10^6` in Vault and can't be reset thereafter.\n\nIf vault token has low decimals and high enough value, for example WBTC having 8 decimals (https://etherscan.io/token/0x2260fac5e5542a773aa44fbcfedf7c193bc2c599#code), `minimumPull` can block funds pulling when it is needed for Vault withdrawals.\n\n## Vulnerability Detail\n\nSuppose BTC is `USD 300k` and a new Vault has `USD 30k` AUM. If vault token is WBTC the value of `minimumPull = 0.01 WBTC` will be around `USD 3000`, which is `10%` of the Vault AUM.\n\nIn this case oftentimes withdrawals requested will not be that high, so `minimumPull` check can block substantial share of protocol withdrawals when it is needed to cover Vault LP withdrawal queue.\n\n## Impact\n\nVault withdrawal requests cannot be processed for an arbitrary time while `reservedFunds` and Vault balance difference is lower than threshold, i.e. LP funds will be frozen in the Vault.\n\n## Code Snippet\n\n`minimumPull` is hardcoded to `10^6` on construction:\n\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Vault.sol#L90-L105\n\n```solidity\n  constructor(\n    uint256 _vaultNumber,\n    address _dao,\n    address _controller,\n    address _vaultCurrency,\n    uint256 _uScale\n  ) {\n    controller = IController(_controller);\n    vaultCurrency = IERC20(_vaultCurrency);\n\n    vaultNumber = _vaultNumber;\n    dao = _dao;\n    uScale = _uScale;\n    lastTimeStamp = block.timestamp;\n    minimumPull = 1_000_000;\n  }\n```\n\nFor example, `maxDivergenceWithdraws` is hardcoded to be `10^6` in MainVault too:\n\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/MainVault.sol#L50-L68\n\n```solidity\n  constructor(\n    ...\n  )\n    VaultToken(_name, _symbol, _decimals)\n    Vault(_vaultNumber, _dao, _controller, _vaultCurrency, _uScale)\n  {\n    ...\n    maxDivergenceWithdraws = 1_000_000;\n  }\n```\n\nBut it's resettable:\n\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/MainVault.sol#L418-L420\n\n```solidity\n  function setMaxDivergence(uint256 _maxDivergence) external onlyDao {\n    maxDivergenceWithdraws = _maxDivergence;\n  }\n```\n\nBut `minimumPull` can't be reset.\n\nIt is impossible to withdraw less than `minimumPull` from protocols:\n\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/Vault.sol#L111-L127\n\n```solidity\n  function pullFunds(uint256 _value) internal {\n    uint256 latestID = controller.latestProtocolId(vaultNumber);\n    for (uint i = 0; i < latestID; i++) {\n      if (currentAllocations[i] == 0) continue;\n\n      uint256 shortage = _value - vaultCurrency.balanceOf(address(this));\n      uint256 balanceProtocol = balanceUnderlying(i);\n\n      uint256 amountToWithdraw = shortage > balanceProtocol ? balanceProtocol : shortage;\n      savedTotalUnderlying -= amountToWithdraw;\n\n      if (amountToWithdraw < minimumPull) break;\n      withdrawFromProtocol(i, amountToWithdraw);\n\n      if (_value <= vaultCurrency.balanceOf(address(this))) break;\n    }\n  }\n```\n\nWhen Vault balance is lacking the LP withdrawals are blocked:\n\nhttps://github.com/sherlock-audit/2023-01-derby/blob/main/derby-yield-optimiser/contracts/MainVault.sol#L131-L144\n\n```solidity\n  function withdraw(\n    uint256 _amount,\n    address _receiver,\n    address _owner\n  ) external nonReentrant onlyWhenVaultIsOn returns (uint256 value) {\n    value = (_amount * exchangeRate) / (10 ** decimals());\n\n    require(value > 0, \"!value\");\n\n    require(getVaultBalance() - reservedFunds >= value, \"!funds\");\n\n    _burn(msg.sender, _amount);\n    transferFunds(_receiver, value);\n  }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider introducing a setter for `minimumPull`, so it can be reset to a relevant level with regard to vault token decimals and its market value:\n\n```solidity\n  function setMinimumPull(uint256 _minimumPull) external onlyDao {\n    minimumPull = _minimumPull;\n  }\n```\n\nThis will also allow to dynamically adjust the Vaults thereafter (say 1e6 is ok as threshold while WBTC is 20k, but becomes prohibiting when it is 200k).\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/13",
  "Code": [
    {
      "filename": "derby-yield-optimiser/contracts/Vault.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Derby Finance - 2022\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"./Interfaces/IController.sol\";\nimport \"./Interfaces/IProvider.sol\";\n\nimport \"./VaultToken.sol\";\nimport \"./libraries/Swap.sol\";\n\ncontract Vault is ReentrancyGuard {\n  using SafeERC20 for IERC20;\n\n  // state 0 Rebalance done and ready for xController to rebalance again\n  // state 1 Allocation amount received and ready to send funds over to xController\n  // state 2 Allocation amount 0 received => will receive funds from xController\n  // state 3 Allocation amount sent or received and ready to rebalance the vault itself\n  enum State {\n    Idle,\n    PushedUnderlying,\n    SendingFundsXChain,\n    WaitingForFunds,\n    RebalanceVault,\n    SendRewardsPerToken\n  }\n\n  IERC20 internal vaultCurrency;\n  IController internal controller;\n  State public state;\n\n  bool public deltaAllocationsReceived;\n\n  address private dao;\n  address private guardian;\n  address public vaultCurrencyAddr;\n  address public xController;\n\n  uint256 public vaultNumber;\n  uint256 public liquidityPerc;\n  uint256 public performanceFee;\n  uint256 public rebalancingPeriod;\n  uint256 public uScale;\n  uint256 public minimumPull;\n  int256 public marginScale;\n\n  // UNIX timestamp\n  uint256 public rebalanceInterval;\n  uint256 public lastTimeStamp;\n\n  // total underlying of all protocols in vault, excluding vault balance\n  uint256 public savedTotalUnderlying;\n\n  // total amount of funds the vault reserved for users that made a withdrawalRequest\n  uint256 internal reservedFunds;\n\n  // total number of allocated Derby tokens currently\n  int256 public totalAllocatedTokens;\n  // delta of the total number of Derby tokens allocated on next rebalancing\n  int256 private deltaAllocatedTokens;\n\n  string internal stateError = \"Wrong state\";\n\n  // (protocolNumber => currentAllocation): current allocations over the protocols\n  mapping(uint256 => int256) internal currentAllocations;\n\n  // (protocolNumber => deltaAllocation): delta of the portfolio on next rebalancing\n  mapping(uint256 => int256) internal deltaAllocations;\n\n  // historical reward per protocol per token, formula: TVL * yield * perfFee / totalLockedTokens\n  // (rebalancingPeriod => protocolId => rewardPerLockedToken)\n  mapping(uint256 => mapping(uint256 => int256)) public rewardPerLockedToken;\n\n  // (protocolNumber => lastPrice): last price of underlying protocol vault\n  mapping(uint256 => uint256) public lastPrices;\n\n  modifier onlyDao() {\n    require(msg.sender == dao, \"Vault: only DAO\");\n    _;\n  }\n\n  modifier onlyGuardian() {\n    require(msg.sender == guardian, \"only Guardian\");\n    _;\n  }\n\n  constructor(\n    uint256 _vaultNumber,\n    address _dao,\n    address _controller,\n    address _vaultCurrency,\n    uint256 _uScale\n  ) {\n    controller = IController(_controller);\n    vaultCurrency = IERC20(_vaultCurrency);\n\n    vaultNumber = _vaultNumber;\n    dao = _dao;\n    uScale = _uScale;\n    lastTimeStamp = block.timestamp;\n    minimumPull = 1_000_000;\n  }\n\n  /// @notice Withdraw from protocols on shortage in Vault\n  /// @dev Keeps on withdrawing until the Vault balance > _value\n  /// @param _value The total value of vaultCurrency an user is trying to withdraw.\n  /// @param _value The (value - current underlying value of this vault) is withdrawn from the underlying protocols.\n  function pullFunds(uint256 _value) internal {\n    uint256 latestID = controller.latestProtocolId(vaultNumber);\n    for (uint i = 0; i < latestID; i++) {\n      if (currentAllocations[i] == 0) continue;\n\n      uint256 shortage = _value - vaultCurrency.balanceOf(address(this));\n      uint256 balanceProtocol = balanceUnderlying(i);\n\n      uint256 amountToWithdraw = shortage > balanceProtocol ? balanceProtocol : shortage;\n      savedTotalUnderlying -= amountToWithdraw;\n\n      if (amountToWithdraw < minimumPull) break;\n      withdrawFromProtocol(i, amountToWithdraw);\n\n      if (_value <= vaultCurrency.balanceOf(address(this))) break;\n    }\n  }\n\n  /// @notice Step 7 trigger, end; Vaults rebalance\n  /// @notice Rebalances i.e deposit or withdraw from all underlying protocols\n  /// @dev amountToProtocol = totalAmount * currentAllocation / totalAllocatedTokens\n  /// @dev amountToDeposit = amountToProtocol - currentBalanceProtocol\n  /// @dev if amountToDeposit < 0 => withdraw\n  /// @dev Execute all withdrawals before deposits\n  function rebalance() external nonReentrant {\n    require(state == State.RebalanceVault, stateError);\n    require(deltaAllocationsReceived, \"!Delta allocations\");\n\n    rebalancingPeriod++;\n\n    claimTokens();\n    settleDeltaAllocation();\n\n    uint256 underlyingIncBalance = calcUnderlyingIncBalance();\n    uint256[] memory protocolToDeposit = rebalanceCheckProtocols(underlyingIncBalance);\n\n    executeDeposits(protocolToDeposit);\n    setTotalUnderlying();\n\n    if (reservedFunds > vaultCurrency.balanceOf(address(this))) pullFunds(reservedFunds);\n\n    state = State.SendRewardsPerToken;\n    deltaAllocationsReceived = false;\n  }\n\n  /// @notice Helper to return underlying balance plus totalUnderlying - liquidty for the vault\n  /// @return underlying totalUnderlying - liquidityVault\n  function calcUnderlyingIncBalance() internal view returns (uint256) {\n    uint256 totalUnderlyingInclVaultBalance = savedTotalUnderlying +\n      getVaultBalance() -\n      reservedFunds;\n    uint256 liquidityVault = (totalUnderlyingInclVaultBalance * liquidityPerc) / 100;\n    return totalUnderlyingInclVaultBalance - liquidityVault;\n  }\n\n  /// @notice Adds deltaAllocatedTokens to totalAllocatedTokens\n  function settleDeltaAllocation() internal {\n    totalAllocatedTokens += deltaAllocatedTokens;\n    deltaAllocatedTokens = 0;\n  }\n\n  /// @notice Rebalances i.e deposit or withdraw from all underlying protocols\n  /// @dev Loops over all protocols in ETF, calculate new currentAllocation based on deltaAllocation\n  /// @dev Also calculate the performance fee here. This is an amount, based on the current TVL (before the rebalance),\n  /// @dev the performanceFee and difference between the current exchangeRate and the exchangeRate of the last rebalance of the vault.\n  /// @param _newTotalUnderlying this will be the new total underlying: Totalunderlying = TotalUnderlyingInProtocols - BalanceVault\n  /// @return uint256[] with amounts to deposit in protocols, the index being the protocol number.\n  function rebalanceCheckProtocols(\n    uint256 _newTotalUnderlying\n  ) internal returns (uint256[] memory) {\n    uint256[] memory protocolToDeposit = new uint[](controller.latestProtocolId(vaultNumber));\n    uint256 latestID = controller.latestProtocolId(vaultNumber);\n    for (uint i = 0; i < latestID; i++) {\n      bool isBlacklisted = controller.getProtocolBlacklist(vaultNumber, i);\n\n      storePriceAndRewards(_newTotalUnderlying, i);\n\n      if (isBlacklisted) continue;\n      setAllocation(i);\n\n      int256 amountToProtocol = calcAmountToProtocol(_newTotalUnderlying, i);\n      uint256 currentBalance = balanceUnderlying(i);\n\n      int256 amountToDeposit = amountToProtocol - int(currentBalance);\n      uint256 amountToWithdraw = amountToDeposit < 0 ? currentBalance - uint(amountToProtocol) : 0;\n\n      if (amountToDeposit > marginScale) protocolToDeposit[i] = uint256(amountToDeposit);\n      if (amountToWithdraw > uint(marginScale) || currentAllocations[i] == 0)\n        withdrawFromProtocol(i, amountToWithdraw);\n    }\n\n    return protocolToDeposit;\n  }\n\n  /// @notice Calculates the amount to deposit or withdraw to protocol during a vault rebalance\n  /// @param _totalUnderlying Totalunderlying = TotalUnderlyingInProtocols - BalanceVault\n  /// @param _protocol Protocol id number\n  /// @return amountToProtocol amount to deposit or withdraw to protocol\n  function calcAmountToProtocol(\n    uint256 _totalUnderlying,\n    uint256 _protocol\n  ) internal view returns (int256 amountToProtocol) {\n    if (totalAllocatedTokens == 0) amountToProtocol = 0;\n    else\n      amountToProtocol =\n        (int(_totalUnderlying) * currentAllocations[_protocol]) /\n        totalAllocatedTokens;\n  }\n\n  /// @notice Stores the historical price and the reward per rounded locked token, ignoring decimals.\n  /// @dev formula yield protocol i at time t: y(it) = (P(it) - P(it-1)) / P(it-1).\n  /// @dev formula rewardPerLockedToken for protocol i at time t: r(it) = y(it) * TVL(t) * perfFee(t) / totalLockedTokens(t)\n  /// @dev later, when the total rewards are calculated for a game player we multiply this (r(it)) by the locked tokens on protocol i at time t\n  /// @param _totalUnderlying Totalunderlying = TotalUnderlyingInProtocols - BalanceVault.\n  /// @param _protocolId Protocol id number.\n  function storePriceAndRewards(uint256 _totalUnderlying, uint256 _protocolId) internal {\n    uint256 currentPrice = price(_protocolId);\n    if (lastPrices[_protocolId] == 0) {\n      lastPrices[_protocolId] = currentPrice;\n      return;\n    }\n\n    int256 priceDiff = int256(currentPrice - lastPrices[_protocolId]);\n    int256 nominator = (int256(_totalUnderlying * performanceFee) * priceDiff);\n    int256 totalAllocatedTokensRounded = totalAllocatedTokens / 1E18;\n    int256 denominator = totalAllocatedTokensRounded * int256(lastPrices[_protocolId]) * 100; // * 100 cause perfFee is in percentages\n\n    if (totalAllocatedTokensRounded == 0) {\n      rewardPerLockedToken[rebalancingPeriod][_protocolId] = 0;\n    } else {\n      rewardPerLockedToken[rebalancingPeriod][_protocolId] = nominator / denominator;\n    }\n\n    lastPrices[_protocolId] = currentPrice;\n  }\n\n  /// @notice Creates array out of the rewardsPerLockedToken mapping to send to the game\n  /// @return rewards Array with rewardsPerLockedToken of all protocols in vault => index matches protocolId\n  function rewardsToArray() internal view returns (int256[] memory rewards) {\n    uint256 latestId = controller.latestProtocolId(vaultNumber);\n\n    rewards = new int[](latestId);\n    for (uint256 i = 0; i < latestId; i++) {\n      rewards[i] = rewardPerLockedToken[rebalancingPeriod][i];\n    }\n  }\n\n  /// @notice Helper function to set allocations\n  /// @param _i Protocol number linked to an underlying protocol e.g compound_usdc_01\n  function setAllocation(uint256 _i) internal {\n    currentAllocations[_i] += deltaAllocations[_i];\n    deltaAllocations[_i] = 0;\n    require(currentAllocations[_i] >= 0, \"Allocation underflow\");\n  }\n\n  /// @notice Helper function so the rebalance will execute all withdrawals first\n  /// @dev Executes and resets all deposits set in mapping(protocolToDeposit) by rebalanceETF\n  /// @param protocolToDeposit array with amounts to deposit in protocols, the index being the protocol number.\n  function executeDeposits(uint256[] memory protocolToDeposit) internal {\n    uint256 latestID = controller.latestProtocolId(vaultNumber);\n    for (uint i = 0; i < latestID; i++) {\n      uint256 amount = protocolToDeposit[i];\n      if (amount == 0) continue;\n      depositInProtocol(i, amount);\n    }\n  }\n\n  /// @notice Deposit amount to underlying protocol\n  /// @dev Deposits VaultCurrency in Protocol e.g USDC\n  /// @param _protocolNum Protocol number linked to an underlying protocol e.g compound_usdc_01\n  /// @param _amount in VaultCurrency to deposit\n  function depositInProtocol(uint256 _protocolNum, uint256 _amount) internal {\n    IController.ProtocolInfoS memory protocol = controller.getProtocolInfo(\n      vaultNumber,\n      _protocolNum\n    );\n\n    if (getVaultBalance() < _amount) _amount = getVaultBalance();\n\n    if (protocol.underlying != address(vaultCurrency)) {\n      _amount = Swap.swapStableCoins(\n        Swap.SwapInOut(_amount, address(vaultCurrency), protocol.underlying),\n        uScale,\n        controller.underlyingUScale(protocol.underlying),\n        controller.getCurveParams(address(vaultCurrency), protocol.underlying)\n      );\n    }\n\n    IERC20(protocol.underlying).safeIncreaseAllowance(protocol.provider, _amount);\n    IProvider(protocol.provider).deposit(_amount, protocol.LPToken, protocol.underlying);\n  }\n\n  /// @notice Withdraw amount from underlying protocol\n  /// @dev shares = amount / PricePerShare\n  /// @param _protocolNum Protocol number linked to an underlying protocol e.g compound_usdc_01\n  /// @param _amount in VaultCurrency to withdraw\n  function withdrawFromProtocol(uint256 _protocolNum, uint256 _amount) internal {\n    if (_amount <= 0) return;\n    IController.ProtocolInfoS memory protocol = controller.getProtocolInfo(\n      vaultNumber,\n      _protocolNum\n    );\n\n    _amount = (_amount * protocol.uScale) / uScale;\n    uint256 shares = IProvider(protocol.provider).calcShares(_amount, protocol.LPToken);\n    uint256 balance = IProvider(protocol.provider).balance(address(this), protocol.LPToken);\n\n    if (shares == 0) return;\n    if (balance < shares) shares = balance;\n\n    IERC20(protocol.LPToken).safeIncreaseAllowance(protocol.provider, shares);\n    uint256 amountReceived = IProvider(protocol.provider).withdraw(\n      shares,\n      protocol.LPToken,\n      protocol.underlying\n    );\n\n    if (protocol.underlying != address(vaultCurrency)) {\n      _amount = Swap.swapStableCoins(\n        Swap.SwapInOut(amountReceived, protocol.underlying, address(vaultCurrency)),\n        controller.underlyingUScale(protocol.underlying),\n        uScale,\n        controller.getCurveParams(protocol.underlying, address(vaultCurrency))\n      );\n    }\n  }\n\n  /// @notice Set total balance in VaultCurrency in all underlying protocols\n  function setTotalUnderlying() public {\n    uint totalUnderlying;\n    uint256 latestID = controller.latestProtocolId(vaultNumber);\n    for (uint i = 0; i < latestID; i++) {\n      if (currentAllocations[i] == 0) continue;\n      totalUnderlying += balanceUnderlying(i);\n    }\n    savedTotalUnderlying = totalUnderlying;\n  }\n\n  /// @notice Get balance in VaultCurrency in underlying protocol\n  /// @param _protocolNum Protocol number linked to an underlying protocol e.g compound_usdc_01\n  /// @return Balance in VaultCurrency e.g USDC\n  function balanceUnderlying(uint256 _protocolNum) public view returns (uint256) {\n    IController.ProtocolInfoS memory protocol = controller.getProtocolInfo(\n      vaultNumber,\n      _protocolNum\n    );\n    uint256 underlyingBalance = (IProvider(protocol.provider).balanceUnderlying(\n      address(this),\n      protocol.LPToken\n    ) * uScale) / protocol.uScale;\n    return underlyingBalance;\n  }\n\n  /// @notice Calculates how many shares are equal to the amount in vault currency\n  /// @param _protocolNum Protocol number linked to an underlying protocol e.g compound_usdc_01\n  /// @param _amount Amount in underyling token e.g USDC\n  /// @return number of shares i.e LP tokens\n  function calcShares(uint256 _protocolNum, uint256 _amount) public view returns (uint256) {\n    IController.ProtocolInfoS memory protocol = controller.getProtocolInfo(\n      vaultNumber,\n      _protocolNum\n    );\n    uint256 shares = IProvider(protocol.provider).calcShares(\n      (_amount * protocol.uScale) / uScale,\n      protocol.LPToken\n    );\n\n    return shares;\n  }\n\n  /// @notice Get price for underlying protocol\n  /// @param _protocolNum Protocol number linked to an underlying protocol e.g compound_usdc_01\n  /// @return protocolPrice Price per lp token\n  function price(uint256 _protocolNum) public view returns (uint256) {\n    IController.ProtocolInfoS memory protocol = controller.getProtocolInfo(\n      vaultNumber,\n      _protocolNum\n    );\n    return IProvider(protocol.provider).exchangeRate(protocol.LPToken);\n  }\n\n  /// @notice Set the delta allocated tokens by game contract\n  /// @dev Allocation can be negative\n  /// @param _protocolNum Protocol number linked to an underlying vault e.g compound_usdc_01\n  /// @param _allocation Delta allocation in tokens\n  function setDeltaAllocationsInt(uint256 _protocolNum, int256 _allocation) internal {\n    require(!controller.getProtocolBlacklist(vaultNumber, _protocolNum), \"Protocol on blacklist\");\n    deltaAllocations[_protocolNum] += _allocation;\n    deltaAllocatedTokens += _allocation;\n  }\n\n  /// @notice Harvest extra tokens from underlying protocols\n  /// @dev Loops over protocols in ETF and check if they are claimable in controller contract\n  function claimTokens() public {\n    uint256 latestID = controller.latestProtocolId(vaultNumber);\n    for (uint i = 0; i < latestID; i++) {\n      if (currentAllocations[i] == 0) continue;\n      bool claim = controller.claim(vaultNumber, i);\n      if (claim) {\n        address govToken = controller.getGovToken(vaultNumber, i);\n        uint256 tokenBalance = IERC20(govToken).balanceOf(address(this));\n        Swap.swapTokensMulti(\n          Swap.SwapInOut(tokenBalance, govToken, address(vaultCurrency)),\n          controller.getUniswapParams(),\n          false\n        );\n      }\n    }\n  }\n\n  function getVaultBalance() public view returns (uint256) {\n    return vaultCurrency.balanceOf(address(this));\n  }\n\n  /// @notice Checks if a rebalance is needed based on the set interval\n  /// @return bool True of rebalance is needed, false if not\n  function rebalanceNeeded() public view returns (bool) {\n    return (block.timestamp - lastTimeStamp) > rebalanceInterval || msg.sender == guardian;\n  }\n\n  /// @notice Getter for dao address\n  function getDao() public view returns (address) {\n    return dao;\n  }\n\n  /// @notice Getter for guardian address\n  function getGuardian() public view returns (address) {\n    return guardian;\n  }\n\n  /*\n  Only Dao functions\n  */\n\n  /// @notice Set the performanceFee, the percentage of the yield that goes to the game players.\n  /// @dev The actual performanceFee could be a bit more or a bit less than the performanceFee set here due to approximations in the game.\n  /// @param _performanceFee Value at which to set the performanceFee.\n  function setPerformanceFee(uint256 _performanceFee) external onlyDao {\n    require(_performanceFee <= 100);\n    performanceFee = _performanceFee;\n  }\n\n  /// @notice Set the governance address\n  /// @param _dao New address of the governance / DAO\n  function setDao(address _dao) external onlyDao {\n    dao = _dao;\n  }\n\n  /// @notice Setter for guardian address\n  /// @param _guardian new address of the guardian\n  function setGuardian(address _guardian) external onlyDao {\n    guardian = _guardian;\n  }\n\n  /*\n  Only Guardian functions\n  */\n\n  /// @notice Set minimum interval for the rebalance function\n  /// @param _timestampInternal UNIX timestamp\n  function setRebalanceInterval(uint256 _timestampInternal) external onlyGuardian {\n    rebalanceInterval = _timestampInternal;\n  }\n\n  /// @notice The DAO should be able to blacklist protocols, the funds should be sent to the vault.\n  /// @param _protocolNum Protocol number linked to an underlying vault e.g compound_usdc_01\n  function blacklistProtocol(uint256 _protocolNum) external onlyGuardian {\n    uint256 balanceProtocol = balanceUnderlying(_protocolNum);\n    currentAllocations[_protocolNum] = 0;\n    controller.setProtocolBlacklist(vaultNumber, _protocolNum);\n    savedTotalUnderlying -= balanceProtocol;\n    withdrawFromProtocol(_protocolNum, balanceProtocol);\n  }\n\n  /// @notice Set the marginScale, the threshold used for deposits and withdrawals.\n  /// @notice If the threshold is not met the deposit/ withdrawal is not executed.\n  /// @dev Take into account the uScale (scale of the underlying).\n  /// @param _marginScale Value at which to set the marginScale.\n  function setMarginScale(int256 _marginScale) external onlyGuardian {\n    marginScale = _marginScale;\n  }\n\n  /// @notice Set the liquidityPerc, the amount of liquidity which should be held in the vault after rebalancing.\n  /// @dev The actual liquidityPerc could be a bit more or a bit less than the liquidityPerc set here.\n  /// @dev This is because some deposits or withdrawals might not execute because they don't meet the marginScale.\n  /// @param _liquidityPerc Value at which to set the liquidityPerc.\n  function setLiquidityPerc(uint256 _liquidityPerc) external onlyGuardian {\n    require(_liquidityPerc <= 100);\n    liquidityPerc = _liquidityPerc;\n  }\n\n  /// @notice callback to receive Ether from unwrapping WETH\n  receive() external payable {\n    require(msg.sender == Swap.WETH, \"Not WETH\");\n  }\n}"
    },
    {
      "filename": "derby-yield-optimiser/contracts/MainVault.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Derby Finance - 2022\npragma solidity ^0.8.11;\n\nimport \"./Vault.sol\";\n\nimport \"./Interfaces/IXProvider.sol\";\n\ncontract MainVault is Vault, VaultToken {\n  using SafeERC20 for IERC20;\n\n  struct UserInfo {\n    // amount in vaultCurrency the vault owes to the user\n    uint256 withdrawalAllowance;\n    // rebalancing period the withdrawal request is made\n    uint256 withdrawalRequestPeriod;\n    // amount in vaultCurrency the vault owes to the user\n    uint256 rewardAllowance;\n    // rebalancing period the reward request is made\n    uint256 rewardRequestPeriod;\n  }\n\n  address public derbyToken;\n  address public game;\n  address public xProvider;\n\n  bool public vaultOff;\n  // True when rewards should be swapped to derby tokens\n  bool public swapRewards;\n\n  // total amount of withdrawal requests for the vault to pull extra during a cross-chain rebalance, will be upped when a user makes a withdrawalRequest\n  // during a cross-chain rebalance the vault will pull extra funds by the amount of totalWithdrawalRequests and the totalWithdrawalRequests will turn into actual reservedFunds\n  uint256 internal totalWithdrawalRequests;\n  uint256 public exchangeRate;\n  uint32 public homeChain;\n  uint256 public amountToSendXChain;\n  uint256 public governanceFee; // Basis points\n  uint256 public maxDivergenceWithdraws;\n\n  string internal allowanceError = \"!Allowance\";\n\n  // (userAddress => userInfo struct)\n  mapping(address => UserInfo) internal userInfo;\n\n  // training\n  bool private training;\n  uint256 private maxTrainingDeposit;\n  mapping(address => bool) private whitelist;\n\n  constructor(\n    string memory _name,\n    string memory _symbol,\n    uint8 _decimals,\n    uint256 _vaultNumber,\n    address _dao,\n    address _game,\n    address _controller,\n    address _vaultCurrency,\n    uint256 _uScale\n  )\n    VaultToken(_name, _symbol, _decimals)\n    Vault(_vaultNumber, _dao, _controller, _vaultCurrency, _uScale)\n  {\n    exchangeRate = _uScale;\n    game = _game;\n    governanceFee = 0;\n    maxDivergenceWithdraws = 1_000_000;\n  }\n\n  modifier onlyXProvider() {\n    require(msg.sender == xProvider, \"only xProvider\");\n    _;\n  }\n\n  modifier onlyWhenVaultIsOn() {\n    require(state == State.Idle, \"Rebalancing\");\n    require(!vaultOff, \"Vault is off\");\n    _;\n  }\n\n  modifier onlyWhenIdle() {\n    require(state == State.Idle, \"Rebalancing\");\n    _;\n  }\n\n  modifier onlyGame() {\n    require(msg.sender == game, \"only game\");\n    _;\n  }\n\n  event PushTotalUnderlying(\n    uint256 _vaultNumber,\n    uint32 _chainId,\n    uint256 _underlying,\n    uint256 _totalSupply,\n    uint256 _withdrawalRequests\n  );\n  event RebalanceXChain(uint256 _vaultNumber, uint256 _amount, address _asset);\n  event PushedRewardsToGame(uint256 _vaultNumber, uint32 _chain, int256[] _rewards);\n\n  /// @notice Deposit in Vault\n  /// @dev Deposit VaultCurrency to Vault and mint LP tokens\n  /// @param _amount Amount to deposit\n  /// @param _receiver Receiving adress for the tokens\n  /// @return shares Tokens received by buyer\n  function deposit(\n    uint256 _amount,\n    address _receiver\n  ) external nonReentrant onlyWhenVaultIsOn returns (uint256 shares) {\n    if (training) {\n      require(whitelist[msg.sender]);\n      uint256 balanceSender = (balanceOf(msg.sender) * exchangeRate) / (10 ** decimals());\n      require(_amount + balanceSender <= maxTrainingDeposit);\n    }\n\n    uint256 balanceBefore = getVaultBalance() - reservedFunds;\n    vaultCurrency.safeTransferFrom(msg.sender, address(this), _amount);\n    uint256 balanceAfter = getVaultBalance() - reservedFunds;\n\n    uint256 amount = balanceAfter - balanceBefore;\n    shares = (amount * (10 ** decimals())) / exchangeRate;\n\n    _mint(_receiver, shares);\n  }\n\n  /// @notice Withdraw from Vault\n  /// @dev Withdraw VaultCurrency from Vault and burn LP tokens\n  /// @param _amount Amount to withdraw in LP tokens\n  /// @param _receiver Receiving adress for the vaultcurrency\n  /// @return value Amount received by seller in vaultCurrency\n  function withdraw(\n    uint256 _amount,\n    address _receiver,\n    address _owner\n  ) external nonReentrant onlyWhenVaultIsOn returns (uint256 value) {\n    value = (_amount * exchangeRate) / (10 ** decimals());\n\n    require(value > 0, \"!value\");\n\n    require(getVaultBalance() - reservedFunds >= value, \"!funds\");\n\n    _burn(msg.sender, _amount);\n    transferFunds(_receiver, value);\n  }\n\n  /// @notice Withdrawal request for when the vault doesnt have enough funds available\n  /// @dev Will give the user allowance for his funds and pulls the extra funds at the next rebalance\n  /// @param _amount Amount to withdraw in LP token\n  function withdrawalRequest(\n    uint256 _amount\n  ) external nonReentrant onlyWhenVaultIsOn returns (uint256 value) {\n    UserInfo storage user = userInfo[msg.sender];\n    require(user.withdrawalRequestPeriod == 0, \"Already a request\");\n\n    value = (_amount * exchangeRate) / (10 ** decimals());\n\n    _burn(msg.sender, _amount);\n\n    user.withdrawalAllowance = value;\n    user.withdrawalRequestPeriod = rebalancingPeriod;\n    totalWithdrawalRequests += value;\n  }\n\n  /// @notice Withdraw the allowance the user requested on the last rebalancing period\n  /// @dev Will send the user funds and reset the allowance\n  function withdrawAllowance() external nonReentrant onlyWhenIdle returns (uint256 value) {\n    UserInfo storage user = userInfo[msg.sender];\n    require(user.withdrawalAllowance > 0, allowanceError);\n    require(rebalancingPeriod > user.withdrawalRequestPeriod, \"Funds not arrived\");\n\n    value = user.withdrawalAllowance;\n    value = checkForBalance(value);\n\n    reservedFunds -= value;\n    delete user.withdrawalAllowance;\n    delete user.withdrawalRequestPeriod;\n\n    transferFunds(msg.sender, value);\n  }\n\n  /// @notice Substract governance fee from value\n  /// @param _receiver Receiving adress for the vaultcurrency\n  /// @param _value Amount received by seller in vaultCurrency\n  function transferFunds(address _receiver, uint256 _value) internal {\n    uint256 govFee = (_value * governanceFee) / 10_000;\n\n    vaultCurrency.safeTransfer(getDao(), govFee);\n    vaultCurrency.safeTransfer(_receiver, _value - govFee);\n  }\n\n  /// @notice Function for the game to set a withdrawalRequest for the rewards of the game user\n  /// @param _value Amount to set a request in vaultCurrency\n  /// @param _user Address of the user\n  function redeemRewardsGame(\n    uint256 _value,\n    address _user\n  ) external onlyGame nonReentrant onlyWhenVaultIsOn {\n    UserInfo storage user = userInfo[_user];\n    require(user.rewardAllowance == 0, allowanceError);\n\n    user.rewardAllowance = _value;\n    user.rewardRequestPeriod = rebalancingPeriod;\n    totalWithdrawalRequests += _value;\n  }\n\n  /// @notice Withdraw the reward allowance set by the game with redeemRewardsGame\n  /// @dev Will swap vaultCurrency to Derby tokens, send the user funds and reset the allowance\n  function withdrawRewards() external nonReentrant onlyWhenIdle returns (uint256 value) {\n    UserInfo storage user = userInfo[msg.sender];\n    require(user.rewardAllowance > 0, allowanceError);\n    require(rebalancingPeriod > user.rewardRequestPeriod, \"!Funds\");\n\n    value = user.rewardAllowance;\n    value = checkForBalance(value);\n\n    reservedFunds -= value;\n    delete user.rewardAllowance;\n    delete user.rewardRequestPeriod;\n\n    if (swapRewards) {\n      uint256 tokensReceived = Swap.swapTokensMulti(\n        Swap.SwapInOut(value, address(vaultCurrency), derbyToken),\n        controller.getUniswapParams(),\n        true\n      );\n      IERC20(derbyToken).safeTransfer(msg.sender, tokensReceived);\n    } else {\n      vaultCurrency.safeTransfer(msg.sender, value);\n    }\n  }\n\n  /// @notice Sometimes when swapping stable coins the vault will get a fraction of a coin less then expected\n  /// @notice This is to make sure the vault doesnt get stuck\n  /// @notice Value will be set to the vaultBalance\n  /// @notice When divergence is greater then maxDivergenceWithdraws it will revert\n  /// @param _value Value the user wants to withdraw\n  /// @return value Value - divergence\n  function checkForBalance(uint256 _value) internal view returns (uint256) {\n    if (_value > getVaultBalance()) {\n      uint256 oldValue = _value;\n      _value = getVaultBalance();\n      require(oldValue - _value <= maxDivergenceWithdraws, \"Max divergence\");\n    }\n    return _value;\n  }\n\n  /// @notice Step 2 trigger; Vaults push totalUnderlying, totalSupply and totalWithdrawalRequests to xChainController\n  /// @notice Pushes totalUnderlying, totalSupply and totalWithdrawalRequests of the vault for this chainId to xController\n  function pushTotalUnderlyingToController() external payable onlyWhenIdle {\n    require(rebalanceNeeded(), \"!rebalance needed\");\n\n    setTotalUnderlying();\n    uint256 underlying = savedTotalUnderlying + getVaultBalance() - reservedFunds;\n\n    IXProvider(xProvider).pushTotalUnderlying{value: msg.value}(\n      vaultNumber,\n      homeChain,\n      underlying,\n      totalSupply(),\n      totalWithdrawalRequests\n    );\n\n    state = State.PushedUnderlying;\n    lastTimeStamp = block.timestamp;\n\n    emit PushTotalUnderlying(\n      vaultNumber,\n      homeChain,\n      underlying,\n      totalSupply(),\n      totalWithdrawalRequests\n    );\n  }\n\n  /// @notice See setXChainAllocationInt below\n  function setXChainAllocation(\n    uint256 _amountToSend,\n    uint256 _exchangeRate,\n    bool _receivingFunds\n  ) external onlyXProvider {\n    require(state == State.PushedUnderlying, stateError);\n    setXChainAllocationInt(_amountToSend, _exchangeRate, _receivingFunds);\n  }\n\n  /// @notice Step 3 end; xChainController pushes exchangeRate and amount the vaults have to send back to all vaults\n  /// @notice Will set the amount to send back to the xController by the xController\n  /// @dev Sets the amount and state so the dao can trigger the rebalanceXChain function\n  /// @dev When amount == 0 the vault doesnt need to send anything and will wait for funds from the xController\n  /// @param _amountToSend amount to send in vaultCurrency\n  function setXChainAllocationInt(\n    uint256 _amountToSend,\n    uint256 _exchangeRate,\n    bool _receivingFunds\n  ) internal {\n    amountToSendXChain = _amountToSend;\n    exchangeRate = _exchangeRate;\n\n    if (_amountToSend == 0 && !_receivingFunds) settleReservedFunds();\n    else if (_amountToSend == 0 && _receivingFunds) state = State.WaitingForFunds;\n    else state = State.SendingFundsXChain;\n  }\n\n  /// @notice Step 4 trigger; Push funds from vaults to xChainController\n  /// @notice Send vaultcurrency to the xController for xChain rebalance\n  /// @param _slippage Slippage tollerance for xChain swap, in BPS (i.e. 30 = 0.3%)\n  /// @param _relayerFee The fee offered to the relayers\n  function rebalanceXChain(uint256 _slippage, uint256 _relayerFee) external payable {\n    require(state == State.SendingFundsXChain, stateError);\n\n    if (amountToSendXChain > getVaultBalance()) pullFunds(amountToSendXChain);\n    if (amountToSendXChain > getVaultBalance()) amountToSendXChain = getVaultBalance();\n\n    vaultCurrency.safeIncreaseAllowance(xProvider, amountToSendXChain);\n    IXProvider(xProvider).xTransferToController{value: msg.value}(\n      vaultNumber,\n      amountToSendXChain,\n      address(vaultCurrency),\n      _slippage,\n      _relayerFee\n    );\n\n    emit RebalanceXChain(vaultNumber, amountToSendXChain, address(vaultCurrency));\n\n    amountToSendXChain = 0;\n    settleReservedFunds();\n  }\n\n  /// @notice Step 5 end; Push funds from xChainController to vaults\n  /// @notice Receiving feedback from xController when funds are received, so the vault can rebalance\n  function receiveFunds() external onlyXProvider {\n    if (state != State.WaitingForFunds) return;\n    settleReservedFunds();\n  }\n\n  /// @notice Helper to settle reserved funds when funds arrived and up to the next State\n  function settleReservedFunds() internal {\n    reservedFunds += totalWithdrawalRequests;\n    totalWithdrawalRequests = 0;\n    state = State.RebalanceVault;\n  }\n\n  /// @notice See receiveProtocolAllocations below\n  function receiveProtocolAllocations(int256[] memory _deltas) external onlyXProvider {\n    receiveProtocolAllocationsInt(_deltas);\n  }\n\n  /// @notice Step 6 end; Game pushes deltaAllocations to vaults\n  /// @notice Receives protocol allocation array from the game and settle"
    }
  ]
}