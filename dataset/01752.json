{
  "Title": "Misleading Documentation",
  "Content": "The following documentation is misleading:\n\n\n* [Line 83 of `BoundValidator`](https://github.com/VenusProtocol/oracle/blob/8fa1becb9b1c512e0b68d73dff09ee4aa172c882/contracts/oracles/BoundValidator.sol#L83) says \"range error thrown if lower bound is greater than upper bound\" instead of \"range error thrown if lower bound is greater than or equal to upper bound\".\n* [Line 18 of `TwapOracle`](https://github.com/VenusProtocol/oracle/blob/78b1a411c42e5c103e688e4e76bc69c476206833/contracts/oracles/TwapOracle.sol#L18) says that the `baseUnit` signifies the \"decimals of the underlying asset\", but it actually takes the value of `1e{decimals}` of the asset.\n* [Line 25 of `TwapOracle`](https://github.com/VenusProtocol/oracle/blob/78b1a411c42e5c103e688e4e76bc69c476206833/contracts/oracles/TwapOracle.sol#L25) says that \"XVS-WBNB is not reversed, while WBNB-XVS is\", when in reality the opposite is true.\n\n\nConsider updating these misleading comments to match the code's intention.\n\n\n***Update:** Resolved in [pull request #84](https://github.com/VenusProtocol/oracle/pull/84) at commit [f4352f1](https://github.com/VenusProtocol/oracle/commit/f4352f1403bf7adb5d4a10533b1806bc73b797e4).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/oracles/BoundValidator.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\nimport \"../interfaces/VBep20Interface.sol\";\nimport \"../interfaces/OracleInterface.sol\";\nimport \"@venusprotocol/governance-contracts/contracts/Governance/AccessControlledV8.sol\";\n\nstruct ValidateConfig {\n    /// @notice asset address\n    address asset;\n    /// @notice Upper bound of deviation between reported price and anchor price,\n    /// beyond which the reported price will be invalidated\n    uint256 upperBoundRatio;\n    /// @notice Lower bound of deviation between reported price and anchor price,\n    /// below which the reported price will be invalidated\n    uint256 lowerBoundRatio;\n}\n\n// BoundValidator provides some common functions and can be used\n// to wrap up other contracts to form pivot oracles\ncontract BoundValidator is AccessControlledV8, BoundValidatorInterface {\n    /// @notice validation configs by asset\n    mapping(address => ValidateConfig) public validateConfigs;\n\n    /// @notice vBNB address\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address public immutable vBnb;\n\n    /// @notice VAI address\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address public immutable vai;\n\n    /// @notice Set this as asset address for BNB. This is the underlying for vBNB\n    address public constant BNB_ADDR = 0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB;\n\n    /// @notice Emit this event when new validation configs are added\n    event ValidateConfigAdded(address indexed asset, uint256 indexed upperBound, uint256 indexed lowerBound);\n\n    /// @notice Constructor for the implementation contract. Sets immutable variables.\n    /// @param vBnbAddress The address of the vBNB\n    /// @param vaiAddress The address of the VAI\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address vBnbAddress, address vaiAddress) {\n        if (vBnbAddress == address(0)) revert(\"vBNB can't be zero address\");\n        if (vaiAddress == address(0)) revert(\"VAI can't be zero address\");\n        vBnb = vBnbAddress;\n        vai = vaiAddress;\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Add multiple validation configs at the same time\n     * @param configs Array of validation configs\n     * @custom:access Only Governance\n     * @custom:error Zero length error is thrown if length of the config array is 0\n     * @custom:event Emits ValidateConfigAdded for each validation config that is successfully set\n     */\n    function setValidateConfigs(ValidateConfig[] memory configs) external virtual {\n        uint256 length = configs.length;\n        if (length == 0) revert(\"invalid validate config length\");\n        for (uint256 i; i < length; ) {\n            setValidateConfig(configs[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Initializes the owner of the contract\n     * @param accessControlManager_ Address of the access control manager contract\n     */\n    function initialize(address accessControlManager_) public initializer {\n        __AccessControlled_init(accessControlManager_);\n    }\n\n    /**\n     * @notice Add a single validation config\n     * @param config Validation config struct\n     * @custom:access Only Governance\n     * @custom:error Null address error is thrown if asset address is null\n     * @custom:error Range error thrown if bound ratio is not positive\n     * @custom:error Range error thrown if lower bound is greater than upper bound\n     * @custom:event Emits ValidateConfigAdded when a validation config is successfully set\n     */\n    function setValidateConfig(ValidateConfig memory config) public virtual {\n        _checkAccessAllowed(\"setValidateConfig(ValidateConfig)\");\n\n        if (config.asset == address(0)) revert(\"asset can't be zero address\");\n        if (config.upperBoundRatio == 0 || config.lowerBoundRatio == 0) revert(\"bound must be positive\");\n        if (config.upperBoundRatio <= config.lowerBoundRatio) revert(\"upper bound must be higher than lowner bound\");\n        validateConfigs[config.asset] = config;\n        emit ValidateConfigAdded(config.asset, config.upperBoundRatio, config.lowerBoundRatio);\n    }\n\n    /**\n     * @notice Test reported asset price against anchor price\n     * @param vToken vToken address\n     * @param reportedPrice The price to be tested\n     * @custom:error Missing error thrown if asset config is not set\n     * @custom:error Price error thrown if anchor price is not valid\n     */\n    function validatePriceWithAnchorPrice(\n        address vToken,\n        uint256 reportedPrice,\n        uint256 anchorPrice\n    ) public view virtual override returns (bool) {\n        address asset = _getUnderlyingAsset(vToken);\n\n        if (validateConfigs[asset].upperBoundRatio == 0) revert(\"validation config not exist\");\n        if (anchorPrice == 0) revert(\"anchor price is not valid\");\n        return _isWithinAnchor(asset, reportedPrice, anchorPrice);\n    }\n\n    /**\n     * @notice Test whether the reported price is within the valid bounds\n     * @param asset Asset address\n     * @param reportedPrice The price to be tested\n     * @param anchorPrice The reported price must be within the the valid bounds of this price\n     */\n    function _isWithinAnchor(address asset, uint256 reportedPrice, uint256 anchorPrice) internal view returns (bool) {\n        if (reportedPrice != 0) {\n            uint256 anchorRatio = (anchorPrice * 100e16) / reportedPrice;\n            uint256 upperBoundAnchorRatio = validateConfigs[asset].upperBoundRatio;\n            uint256 lowerBoundAnchorRatio = validateConfigs[asset].lowerBoundRatio;\n            return anchorRatio <= upperBoundAnchorRatio && anchorRatio >= lowerBoundAnchorRatio;\n        }\n        return false;\n    }\n\n    /**\n     * @dev This function returns the underlying asset of a vToken\n     * @param vToken vToken address\n     * @return asset underlying asset address\n     */\n    function _getUnderlyingAsset(address vToken) internal view returns (address asset) {\n        if (address(vToken) == vBnb) {\n            asset = BNB_ADDR;\n        } else if (address(vToken) == vai) {\n            asset = vai;\n        } else {\n            asset = VBep20Interface(vToken).underlying();\n        }\n    }\n}"
    },
    {
      "filename": "contracts/oracles/TwapOracle.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../libraries/PancakeLibrary.sol\";\nimport \"../interfaces/OracleInterface.sol\";\nimport \"../interfaces/VBep20Interface.sol\";\nimport \"@venusprotocol/governance-contracts/contracts/Governance/AccessControlledV8.sol\";\n\nstruct Observation {\n    uint256 timestamp;\n    uint256 acc;\n}\n\nstruct TokenConfig {\n    /// @notice Asset address, which can't be zero address and can be used for existance check\n    address asset;\n    /// @notice Decimals of underlying asset\n    uint256 baseUnit;\n    /// @notice The address of Pancake pair\n    address pancakePool;\n    /// @notice Whether the token is paired with WBNB\n    bool isBnbBased;\n    /// @notice A flag identifies whether the Pancake pair is reversed\n    /// e.g. XVS-WBNB is not reversed, while WBNB-XVS is.\n    bool isReversedPool;\n    /// @notice The minimum window in seconds required between TWAP updates\n    uint256 anchorPeriod;\n}\n\ncontract TwapOracle is AccessControlledV8, TwapInterface {\n    using FixedPoint for *;\n\n    /// @notice WBNB address\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address public immutable WBNB;\n\n    /// @notice vBNB address\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address public immutable vBnb;\n\n    /// @notice VAI address\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address public immutable vai;\n\n    /// @notice the base unit of WBNB and BUSD, which are the paired tokens for all assets\n    uint256 public constant bnbBaseUnit = 1e18;\n    uint256 public constant busdBaseUnit = 1e18;\n\n    /// @notice Configs by token\n    mapping(address => TokenConfig) public tokenConfigs;\n\n    /// @notice Stored price by token\n    mapping(address => uint256) public prices;\n\n    /// @notice Keeps a record of token observations mapped by address, updated on every updateTwap invocation.\n    mapping(address => Observation[]) public observations;\n\n    /// @notice Observation array index which probably falls in current anchor period mapped by asset address\n    mapping(address => uint256) public windowStart;\n\n    /// @notice Emit this event when TWAP window is updated\n    event TwapWindowUpdated(\n        address indexed asset,\n        uint256 oldTimestamp,\n        uint256 oldAcc,\n        uint256 newTimestamp,\n        uint256 newAcc\n    );\n\n    /// @notice Emit this event when TWAP price is updated\n    event AnchorPriceUpdated(address indexed asset, uint256 price, uint256 oldTimestamp, uint256 newTimestamp);\n\n    /// @notice Emit this event when new token configs are added\n    event TokenConfigAdded(address indexed asset, address indexed pancakePool, uint256 indexed anchorPeriod);\n\n    modifier notNullAddress(address someone) {\n        if (someone == address(0)) revert(\"can't be zero address\");\n        _;\n    }\n\n    /// @notice Constructor for the implementation contract. Sets immutable variables.\n    /// @param vBnbAddress The address of the VBNB\n    /// @param wBnbAddress The address of the WBNB\n    /// @param vaiAddress The address of the WBNB\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(\n        address vBnbAddress,\n        address wBnbAddress,\n        address vaiAddress\n    ) notNullAddress(vBnbAddress) notNullAddress(wBnbAddress) notNullAddress(vaiAddress) {\n        vBnb = vBnbAddress;\n        WBNB = wBnbAddress;\n        vai = vaiAddress;\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Adds multiple token configs at the same time\n     * @param configs Config array\n     * @custom:error Zero length error thrown, if length of the config array is 0\n     */\n    function setTokenConfigs(TokenConfig[] memory configs) external {\n        if (configs.length == 0) revert(\"length can't be 0\");\n        uint256 numTokenConfigs = configs.length;\n        for (uint256 i; i < numTokenConfigs; ) {\n            setTokenConfig(configs[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Get the underlying TWAP price for the given vToken\n     * @param vToken vToken address\n     * @return price Underlying price in USD\n     * @custom:error Missing error is thrown if the token config does not exist\n     * @custom:error Range error is thrown if TWAP price is not greater than zero\n     */\n    function getUnderlyingPrice(address vToken) external view override returns (uint256) {\n        address asset = _getUnderlyingAsset(vToken);\n\n        if (tokenConfigs[asset].asset == address(0)) revert(\"asset not exist\");\n        uint256 price = prices[asset];\n\n        // if price is 0, it means the price hasn't been updated yet and it's meaningless, revert\n        if (price == 0) revert(\"TWAP price must be positive\");\n        return (price * (10 ** (18 - IERC20Metadata(asset).decimals())));\n    }\n\n    /**\n     * @notice Initializes the owner of the contract\n     * @param accessControlManager_ Address of the access control manager contract\n     */\n    function initialize(address accessControlManager_) public initializer {\n        __AccessControlled_init(accessControlManager_);\n    }\n\n    /**\n     * @notice Adds a single token config\n     * @param config token config struct\n     * @custom:access Only Governance\n     * @custom:error Range error is thrown if anchor period is not greater than zero\n     * @custom:error Range error is thrown if base unit is not greater than zero\n     * @custom:error Value error is thrown if base unit decimals is not the same as asset decimals\n     * @custom:error NotNullAddress error is thrown if address of asset is null\n     * @custom:error NotNullAddress error is thrown if PancakeSwap pool address is null\n     * @custom:event Emits TokenConfigAdded event if new token config are added with\n     * asset address, PancakePool address, anchor period address\n     */\n    function setTokenConfig(\n        TokenConfig memory config\n    ) public notNullAddress(config.asset) notNullAddress(config.pancakePool) {\n        _checkAccessAllowed(\"setTokenConfig(TokenConfig)\");\n\n        if (config.anchorPeriod == 0) revert(\"anchor period must be positive\");\n        if (config.baseUnit != 10 ** IERC20Metadata(config.asset).decimals())\n            revert(\"base unit decimals must be same as asset decimals\");\n\n        uint256 cumulativePrice = currentCumulativePrice(config);\n\n        // Initialize observation data\n        observations[config.asset].push(Observation(block.timestamp, cumulativePrice));\n        tokenConfigs[config.asset] = config;\n        emit TokenConfigAdded(config.asset, config.pancakePool, config.anchorPeriod);\n    }\n\n    /**\n     * @notice Updates the current token/BUSD price from PancakeSwap, with 18 decimals of precision.\n     * @return anchorPrice anchor price of the underlying asset of the vToken\n     * @custom:error Missing error is thrown if token config does not exist\n     */\n    function updateTwap(address vToken) public returns (uint256) {\n        address asset = _getUnderlyingAsset(vToken);\n\n        if (tokenConfigs[asset].asset == address(0)) revert(\"asset not exist\");\n        // Update & fetch WBNB price first, so we can calculate the price of WBNB paired token\n        if (asset != WBNB && tokenConfigs[asset].isBnbBased) {\n            if (tokenConfigs[WBNB].asset == address(0)) revert(\"WBNB not exist\");\n            _updateTwapInternal(tokenConfigs[WBNB]);\n        }\n        return _updateTwapInternal(tokenConfigs[asset]);\n    }\n\n    /**\n     * @notice Fetches the current token/WBNB and token/BUSD price accumulator from PancakeSwap.\n     * @return cumulative price of target token regardless of pair order\n     */\n    function currentCumulativePrice(TokenConfig memory config) public view returns (uint256) {\n        (uint256 price0, uint256 price1, ) = PancakeOracleLibrary.currentCumulativePrices(config.pancakePool);\n        if (config.isReversedPool) {\n            return price1;\n        } else {\n            return price0;\n        }\n    }\n\n    /**\n     * @notice Fetches the current token/BUSD price from PancakeSwap, with 18 decimals of precision.\n     * @return price Underlying price in USD, with 18 decimals\n     * @custom:error Timing error is thrown if current time is not greater than old observation timestamp\n     * @custom:error Zero price error is thrown if token is BNB based and price is zero\n     * @custom:error Zero price error is thrown if fetched anchorPriceMantissa is zero\n     * @custom:event Emits AnchorPriceUpdated event on successful update of observation with assset address,\n     * AnchorPrice, old observation timestamp and current timestamp\n     */\n    function _updateTwapInternal(TokenConfig memory config) internal virtual returns (uint256) {\n        // pokeWindowValues already handled reversed pool cases,\n        // priceAverage will always be Token/BNB or Token/BUSD *twap** price.\n        (uint256 nowCumulativePrice, uint256 oldCumulativePrice, uint256 oldTimestamp) = pokeWindowValues(config);\n\n        if (block.timestamp == oldTimestamp) return prices[config.asset];\n\n        // This should be impossible, but better safe than sorry\n        if (block.timestamp < oldTimestamp) revert(\"now must come after before\");\n\n        uint256 timeElapsed;\n        unchecked {\n            timeElapsed = block.timestamp - oldTimestamp;\n        }\n\n        // Calculate Pancake *twap**\n        FixedPoint.uq112x112 memory priceAverage = FixedPoint.uq112x112(\n            uint224((nowCumulativePrice - oldCumulativePrice) / timeElapsed)\n        );\n        // *twap** price with 1e18 decimal mantissa\n        uint256 priceAverageMantissa = priceAverage.decode112with18();\n\n        // To cancel the decimals in cumulative price, we need to mulitply the average price with\n        // tokenBaseUnit / (wbnbBaseUnit or busdBaseUnit, which is 1e18)\n        uint256 pairedTokenBaseUnit = config.isBnbBased ? bnbBaseUnit : busdBaseUnit;\n        uint256 anchorPriceMantissa = (priceAverageMantissa * config.baseUnit) / pairedTokenBaseUnit;\n\n        // if this token is paired with BNB, convert its price to USD\n        if (config.isBnbBased) {\n            uint256 bnbPrice = prices[WBNB];\n            if (bnbPrice == 0) revert(\"bnb price is invalid\");\n            anchorPriceMantissa = (anchorPriceMantissa * bnbPrice) / bnbBaseUnit;\n        }\n\n        if (anchorPriceMantissa == 0) revert(\"twap price cannot be 0\");\n\n        emit AnchorPriceUpdated(config.asset, anchorPriceMantissa, oldTimestamp, block.timestamp);\n\n        // save anchor price, which is 1e18 decimals\n        prices[config.asset] = anchorPriceMantissa;\n\n        return anchorPriceMantissa;\n    }\n\n    /**\n     * @notice Appends current observation and pick an observation with a timestamp equal\n     * or just greater than the window start timestamp. If one is not available,\n     * then pick the last availableobservation. The window start index is updated in both the cases.\n     * Only the current observation is saved, prior observations are deleted during this operation.\n     * @return Tuple of cumulative price, old observation and timestamp\n     * @custom:event Emits TwapWindowUpdated on successful calculation of cumulative price with asset address,\n     * new observation timestamp, current timestamp, new observation price and cumulative price\n     */\n    function pokeWindowValues(\n        TokenConfig memory config\n    ) internal returns (uint256, uint256 startCumulativePrice, uint256 startCumulativeTimestamp) {\n        uint256 cumulativePrice = currentCumulativePrice(config);\n        uint256 currentTimestamp = block.timestamp;\n        uint256 windowStartTimestamp = currentTimestamp - config.anchorPeriod;\n        Observation[] memory storedObservations = observations[config.asset];\n\n        uint256 storedObservationsLength = storedObservations.length;\n        for (uint256 windowStartIndex = windowStart[config.asset]; windowStartIndex < storedObservationsLength; ) {\n            if (\n                (storedObservations[windowStartIndex].timestamp >= windowStartTimestamp) ||\n                (windowStartIndex == storedObservationsLength - 1)\n            ) {\n                startCumulativePrice = storedObservations[windowStartIndex].acc;\n                startCumulativeTimestamp = storedObservations[windowStartIndex].timestamp;\n                windowStart[config.asset] = windowStartIndex;\n                break;\n            } else {\n                delete observations[config.asset][windowStartIndex];\n            }\n\n            unchecked {\n                ++windowStartIndex;\n            }\n        }\n\n        observations[config.asset].push(Observation(currentTimestamp, cumulativePrice));\n        emit TwapWindowUpdated(\n            config.asset,\n            startCumulativeTimestamp,\n            startCumulativePrice,\n            block.timestamp,\n            cumulativePrice\n        );\n        return (cumulativePrice, startCumulativePrice, startCumulativeTimestamp);\n    }\n\n    /**\n     * @dev This function returns the underlying asset of a vToken\n     * @param vToken vToken address\n     * @return asset underlying asset address\n     */\n    function _getUnderlyingAsset(address vToken) internal view returns (address asset) {\n        if (address(vToken) == vBnb) {\n            asset = WBNB;\n        } else if (address(vToken) == vai) {\n            asset = vai;\n        } else {\n            asset = VBep20Interface(vToken).underlying();\n        }\n    }\n}"
    },
    {
      "filename": "contracts/oracles/TwapOracle.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../libraries/PancakeLibrary.sol\";\nimport \"../interfaces/OracleInterface.sol\";\nimport \"../interfaces/VBep20Interface.sol\";\nimport \"@venusprotocol/governance-contracts/contracts/Governance/AccessControlledV8.sol\";\n\nstruct Observation {\n    uint256 timestamp;\n    uint256 acc;\n}\n\nstruct TokenConfig {\n    /// @notice Asset address, which can't be zero address and can be used for existance check\n    address asset;\n    /// @notice Decimals of underlying asset\n    uint256 baseUnit;\n    /// @notice The address of Pancake pair\n    address pancakePool;\n    /// @notice Whether the token is paired with WBNB\n    bool isBnbBased;\n    /// @notice A flag identifies whether the Pancake pair is reversed\n    /// e.g. XVS-WBNB is not reversed, while WBNB-XVS is.\n    bool isReversedPool;\n    /// @notice The minimum window in seconds required between TWAP updates\n    uint256 anchorPeriod;\n}\n\ncontract TwapOracle is AccessControlledV8, TwapInterface {\n    using FixedPoint for *;\n\n    /// @notice WBNB address\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address public immutable WBNB;\n\n    /// @notice vBNB address\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address public immutable vBnb;\n\n    /// @notice VAI address\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address public immutable vai;\n\n    /// @notice the base unit of WBNB and BUSD, which are the paired tokens for all assets\n    uint256 public constant bnbBaseUnit = 1e18;\n    uint256 public constant busdBaseUnit = 1e18;\n\n    /// @notice Configs by token\n    mapping(address => TokenConfig) public tokenConfigs;\n\n    /// @notice Stored price by token\n    mapping(address => uint256) public prices;\n\n    /// @notice Keeps a record of token observations mapped by address, updated on every updateTwap invocation.\n    mapping(address => Observation[]) public observations;\n\n    /// @notice Observation array index which probably falls in current anchor period mapped by asset address\n    mapping(address => uint256) public windowStart;\n\n    /// @notice Emit this event when TWAP window is updated\n    event TwapWindowUpdated(\n        address indexed asset,\n        uint256 oldTimestamp,\n        uint256 oldAcc,\n        uint256 newTimestamp,\n        uint256 newAcc\n    );\n\n    /// @notice Emit this event when TWAP price is updated\n    event AnchorPriceUpdated(address indexed asset, uint256 price, uint256 oldTimestamp, uint256 newTimestamp);\n\n    /// @notice Emit this event when new token configs are added\n    event TokenConfigAdded(address indexed asset, address indexed pancakePool, uint256 indexed anchorPeriod);\n\n    modifier notNullAddress(address someone) {\n        if (someone == address(0)) revert(\"can't be zero address\");\n        _;\n    }\n\n    /// @notice Constructor for the implementation contract. Sets immutable variables.\n    /// @param vBnbAddress The address of the VBNB\n    /// @param wBnbAddress The address of the WBNB\n    /// @param vaiAddress The address of the WBNB\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(\n        address vBnbAddress,\n        address wBnbAddress,\n        address vaiAddress\n    ) notNullAddress(vBnbAddress) notNullAddress(wBnbAddress) notNullAddress(vaiAddress) {\n        vBnb = vBnbAddress;\n        WBNB = wBnbAddress;\n        vai = vaiAddress;\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Adds multiple token configs at the same time\n     * @param configs Config array\n     * @custom:error Zero length error thrown, if length of the config array is 0\n     */\n    function setTokenConfigs(TokenConfig[] memory configs) external {\n        if (configs.length == 0) revert(\"length can't be 0\");\n        uint256 numTokenConfigs = configs.length;\n        for (uint256 i; i < numTokenConfigs; ) {\n            setTokenConfig(configs[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Get the underlying TWAP price for the given vToken\n     * @param vToken vToken address\n     * @return price Underlying price in USD\n     * @custom:error Missing error is thrown if the token config does not exist\n     * @custom:error Range error is thrown if TWAP price is not greater than zero\n     */\n    function getUnderlyingPrice(address vToken) external view override returns (uint256) {\n        address asset = _getUnderlyingAsset(vToken);\n\n        if (tokenConfigs[asset].asset == address(0)) revert(\"asset not exist\");\n        uint256 price = prices[asset];\n\n        // if price is 0, it means the price hasn't been updated yet and it's meaningless, revert\n        if (price == 0) revert(\"TWAP price must be positive\");\n        return (price * (10 ** (18 - IERC20Metadata(asset).decimals())));\n    }\n\n    /**\n     * @notice Initializes the owner of the contract\n     * @param accessControlManager_ Address of the access control manager contract\n     */\n    function initialize(address accessControlManager_) public initializer {\n        __AccessControlled_init(accessControlManager_);\n    }\n\n    /**\n     * @notice Adds a single token config\n     * @param config token config struct\n     * @custom:access Only Governance\n     * @custom:error Range error is thrown if anchor period is not greater than zero\n     * @custom:error Range error is thrown if base unit is not greater than zero\n     * @custom:error Value error is thrown if base unit decimals is not the same as asset decimals\n     * @custom:error NotNullAddress error is thrown if address of asset is null\n     * @custom:error NotNullAddress error is thrown if PancakeSwap pool address is null\n     * @custom:event Emits TokenConfigAdded event if new token config are added with\n     * asset address, PancakePool address, anchor period address\n     */\n    function setTokenConfig(\n        TokenConfig memory config\n    ) public notNullAddress(config.asset) notNullAddress(config.pancakePool) {\n        _checkAccessAllowed(\"setTokenConfig(TokenConfig)\");\n\n        if (config.anchorPeriod == 0) revert(\"anchor period must be positive\");\n        if (config.baseUnit != 10 ** IERC20Metadata(config.asset).decimals())\n            revert(\"base unit decimals must be same as asset decimals\");\n\n        uint256 cumulativePrice = currentCumulativePrice(config);\n\n        // Initialize observation data\n        observations[config.asset].push(Observation(block.timestamp, cumulativePrice));\n        tokenConfigs[config.asset] = config;\n        emit TokenConfigAdded(config.asset, config.pancakePool, config.anchorPeriod);\n    }\n\n    /**\n     * @notice Updates the current token/BUSD price from PancakeSwap, with 18 decimals of precision.\n     * @return anchorPrice anchor price of the underlying asset of the vToken\n     * @custom:error Missing error is thrown if token config does not exist\n     */\n    function updateTwap(address vToken) public returns (uint256) {\n        address asset = _getUnderlyingAsset(vToken);\n\n        if (tokenConfigs[asset].asset == address(0)) revert(\"asset not exist\");\n        // Update & fetch WBNB price first, so we can calculate the price of WBNB paired token\n        if (asset != WBNB && tokenConfigs[asset].isBnbBased) {\n            if (tokenConfigs[WBNB].asset == address(0)) revert(\"WBNB not exist\");\n            _updateTwapInternal(tokenConfigs[WBNB]);\n        }\n        return _updateTwapInternal(tokenConfigs[asset]);\n    }\n\n    /**\n     * @notice Fetches the current token/WBNB and token/BUSD price accumulator from PancakeSwap.\n     * @return cumulative price of target token regardless of pair order\n     */\n    function currentCumulativePrice(TokenConfig memory config) public view returns (uint256) {\n        (uint256 price0, uint256 price1, ) = PancakeOracleLibrary.currentCumulativePrices(config.pancakePool);\n        if (config.isReversedPool) {\n            return price1;\n        } else {\n            return price0;\n        }\n    }\n\n    /**\n     * @notice Fetches the current token/BUSD price from PancakeSwap, with 18 decimals of precision.\n     * @return price Underlying price in USD, with 18 decimals\n     * @custom:error Timing error is thrown if current time is not greater than old observation timestamp\n     * @custom:error Zero price error is thrown if token is BNB based and price is zero\n     * @custom:error Zero price error is thrown if fetched anchorPriceMantissa is zero\n     * @custom:event Emits AnchorPriceUpdated event on successful update of observation with assset address,\n     * AnchorPrice, old observation timestamp and current timestamp\n     */\n    function _updateTwapInternal(TokenConfig memory config) internal virtual returns (uint256) {\n        // pokeWindowValues already handled reversed pool cases,\n        // priceAverage will always be Token/BNB or Token/BUSD *twap** price.\n        (uint256 nowCumulativePrice, uint256 oldCumulativePrice, uint256 oldTimestamp) = pokeWindowValues(config);\n\n        if (block.timestamp == oldTimestamp) return prices[config.asset];\n\n        // This should be impossible, but better safe than sorry\n        if (block.timestamp < oldTimestamp) revert(\"now must come after before\");\n\n        uint256 timeElapsed;\n        unchecked {\n            timeElapsed = block.timestamp - oldTimestamp;\n        }\n\n        // Calculate Pancake *twap**\n        FixedPoint.uq112x112 memory priceAverage = FixedPoint.uq112x112(\n            uint224((nowCumulativePrice - oldCumulativePrice) / timeElapsed)\n        );\n        // *twap** price with 1e18 decimal mantissa\n        uint256 priceAverageMantissa = priceAverage.decode112with18();\n\n        // To cancel the decimals in cumulative price, we need to mulitply the average price with\n        // tokenBaseUnit / (wbnbBaseUnit or busdBaseUnit, which is 1e18)\n        uint256 pairedTokenBaseUnit = config.isBnbBased ? bnbBaseUnit : busdBaseUnit;\n        uint256 anchorPriceMantissa = (priceAverageMantissa * config.baseUnit) / pairedTokenBaseUnit;\n\n        // if this token is paired with BNB, convert its price to USD\n        if (config.isBnbBased) {\n            uint256 bnbPrice = prices[WBNB];\n            if (bnbPrice == 0) revert(\"bnb price is invalid\");\n            anchorPriceMantissa = (anchorPriceMantissa * bnbPrice) / bnbBaseUnit;\n        }\n\n        if (anchorPriceMantissa == 0) revert(\"twap price cannot be 0\");\n\n        emit AnchorPriceUpdated(config.asset, anchorPriceMantissa, oldTimestamp, block.timestamp);\n\n        // save anchor price, which is 1e18 decimals\n        prices[config.asset] = anchorPriceMantissa;\n\n        return anchorPriceMantissa;\n    }\n\n    /**\n     * @notice Appends current observation and pick an observation with a timestamp equal\n     * or just greater than the window start timestamp. If one is not available,\n     * then pick the last availableobservation. The window start index is updated in both the cases.\n     * Only the current observation is saved, prior observations are deleted during this operation.\n     * @return Tuple of cumulative price, old observation and timestamp\n     * @custom:event Emits TwapWindowUpdated on successful calculation of cumulative price with asset address,\n     * new observation timestamp, current timestamp, new observation price and cumulative price\n     */\n    function pokeWindowValues(\n        TokenConfig memory config\n    ) internal returns (uint256, uint256 startCumulativePrice, uint256 startCumulativeTimestamp) {\n        uint256 cumulativePrice = currentCumulativePrice(config);\n        uint256 currentTimestamp = block.timestamp;\n        uint256 windowStartTimestamp = currentTimestamp - config.anchorPeriod;\n        Observation[] memory storedObservations = observations[config.asset];\n\n        uint256 storedObservationsLength = storedObservations.length;\n        for (uint256 windowStartIndex = windowStart[config.asset]; windowStartIndex < storedObservationsLength; ) {\n            if (\n                (storedObservations[windowStartIndex].timestamp >= windowStartTimestamp) ||\n                (windowStartIndex == storedObservationsLength - 1)\n            ) {\n                startCumulativePrice = storedObservations[windowStartIndex].acc;\n                startCumulativeTimestamp = storedObservations[windowStartIndex].timestamp;\n                windowStart[config.asset] = windowStartIndex;\n                break;\n            } else {\n                delete observations[config.asset][windowStartIndex];\n            }\n\n            unchecked {\n                ++windowStartIndex;\n            }\n        }\n\n        observations[config.asset].push(Observation(currentTimestamp, cumulativePrice));\n        emit TwapWindowUpdated(\n            config.asset,\n            startCumulativeTimestamp,\n            startCumulativePrice,\n            block.timestamp,\n            cumulativePrice\n        );\n        return (cumulativePrice, s"
    }
  ]
}