{
  "Title": "[H-02] crvRewardsContract `getReward` can be called directly, breaking vaults `claimRewards` functionallity",
  "Content": "\ncrvRewardsContract of convex can be called by anyone on behalf of Vault, this will allow malicious users to call `getReward` and break the Vault `claimRewards` functionality.\n\n### Proof of Concept\n\nConvex rewarded allow anyone to call `getReward` on behalf of any users:\n\n<https://github.com/convex-eth/platform/blob/main/contracts/contracts/BaseRewardPool.sol#L263-L279>\n\nThis will break Vault `claimRewards` functionality that depends on this `getReward`:\n\n<https://github.com/code-423n4/2023-07-amphora/blob/main/core/solidity/contracts/core/Vault.sol#L164-L229>\n\n```solidity\n  function claimRewards(address[] memory _tokenAddresses) external override onlyMinter {\n    uint256 _totalCrvReward;\n    uint256 _totalCvxReward;\n\n    IAMPHClaimer _amphClaimer = CONTROLLER.claimerContract();\n    for (uint256 _i; _i < _tokenAddresses.length;) {\n      IVaultController.CollateralInfo memory _collateralInfo = CONTROLLER.tokenCollateralInfo(_tokenAddresses[_i]);\n      if (_collateralInfo.tokenId == 0) revert Vault_TokenNotRegistered();\n      if (_collateralInfo.collateralType != IVaultController.CollateralType.CurveLPStakedOnConvex) {\n        revert Vault_TokenNotCurveLP();\n      }\n\n      IBaseRewardPool _rewardsContract = _collateralInfo.crvRewardsContract;\n      uint256 _crvReward = _rewardsContract.earned(address(this));\n\n      if (_crvReward != 0) {\n        // Claim the CRV reward\n        _totalCrvReward += _crvReward;\n        _rewardsContract.getReward(address(this), false);\n        _totalCvxReward += _calculateCVXReward(_crvReward);\n      }\n\n   ...\n  }\n```\n\nThis will allow malicious users to call `getReward` on behalf of Vaults, and basically prevent them to mint get the rewards and get the deserved AMPH tokens.\n\n### Recommended Mitigation Steps\n\nCreate another functionality inside Vault that similar to `claimRewards`, but used CVX, CRV balance inside the contract, to perform the AMPH claim and claim the rewards.\n\n**[0xShaito (Amphora) confirmed and commented](https://github.com/code-423n4/2023-07-amphora-findings/issues/301#issuecomment-1667507614):**\n > True! We will fix this.\n> \n> Impact of the attack would be the loss of the rewards. No user deposits at risk.\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-07-amphora",
  "Code": [
    {
      "filename": "contracts/contracts/BaseRewardPool.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n/**\n *Submitted for verification at Etherscan.io on 2020-07-17\n */\n\n/*\n   ____            __   __        __   _\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\n _\\ \\ / // // _ \\/ __// _ \\/ -_)/ __// / \\ \\ /\n/___/ \\_, //_//_/\\__//_//_/\\__/ \\__//_/ /_\\_\\\n     /___/\n\n* Synthetix: BaseRewardPool.sol\n*\n* Docs: https://docs.synthetix.io/\n*\n*\n* MIT License\n* ===========\n*\n* Copyright (c) 2020 Synthetix\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n*/\n\nimport \"./Interfaces.sol\";\nimport \"./interfaces/MathUtil.sol\";\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/utils/Address.sol';\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\n\n\n\ncontract BaseRewardPool {\n     using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 public rewardToken;\n    IERC20 public stakingToken;\n    uint256 public constant duration = 7 days;\n\n    address public operator;\n    address public rewardManager;\n\n    uint256 public pid;\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    uint256 public queuedRewards = 0;\n    uint256 public currentRewards = 0;\n    uint256 public historicalRewards = 0;\n    uint256 public constant newRewardRatio = 830;\n    uint256 private _totalSupply;\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n    mapping(address => uint256) private _balances;\n\n    address[] public extraRewards;\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n\n    constructor(\n        uint256 pid_,\n        address stakingToken_,\n        address rewardToken_,\n        address operator_,\n        address rewardManager_\n    ) public {\n        pid = pid_;\n        stakingToken = IERC20(stakingToken_);\n        rewardToken = IERC20(rewardToken_);\n        operator = operator_;\n        rewardManager = rewardManager_;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function extraRewardsLength() external view returns (uint256) {\n        return extraRewards.length;\n    }\n\n    function addExtraReward(address _reward) external returns(bool){\n        require(msg.sender == rewardManager, \"!authorized\");\n        require(_reward != address(0),\"!reward setting\");\n\n        extraRewards.push(_reward);\n        return true;\n    }\n    function clearExtraRewards() external{\n        require(msg.sender == rewardManager, \"!authorized\");\n        delete extraRewards;\n    }\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return MathUtil.min(block.timestamp, periodFinish);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalSupply() == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable()\n                    .sub(lastUpdateTime)\n                    .mul(rewardRate)\n                    .mul(1e18)\n                    .div(totalSupply())\n            );\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return\n            balanceOf(account)\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e18)\n                .add(rewards[account]);\n    }\n\n    function stake(uint256 _amount)\n        public\n        updateReward(msg.sender)\n        returns(bool)\n    {\n        require(_amount > 0, 'RewardPool : Cannot stake 0');\n        \n        //also stake to linked rewards\n        for(uint i=0; i < extraRewards.length; i++){\n            IRewards(extraRewards[i]).stake(msg.sender, _amount);\n        }\n\n        _totalSupply = _totalSupply.add(_amount);\n        _balances[msg.sender] = _balances[msg.sender].add(_amount);\n\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n        emit Staked(msg.sender, _amount);\n\n        \n        return true;\n    }\n\n    function stakeAll() external returns(bool){\n        uint256 balance = stakingToken.balanceOf(msg.sender);\n        stake(balance);\n        return true;\n    }\n\n    function stakeFor(address _for, uint256 _amount)\n        public\n        updateReward(_for)\n        returns(bool)\n    {\n        require(_amount > 0, 'RewardPool : Cannot stake 0');\n        \n        //also stake to linked rewards\n        for(uint i=0; i < extraRewards.length; i++){\n            IRewards(extraRewards[i]).stake(_for, _amount);\n        }\n\n        //give to _for\n        _totalSupply = _totalSupply.add(_amount);\n        _balances[_for] = _balances[_for].add(_amount);\n\n        //take away from sender\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n        emit Staked(_for, _amount);\n        \n        return true;\n    }\n\n\n    function withdraw(uint256 amount, bool claim)\n        public\n        updateReward(msg.sender)\n        returns(bool)\n    {\n        require(amount > 0, 'RewardPool : Cannot withdraw 0');\n\n        //also withdraw from linked rewards\n        for(uint i=0; i < extraRewards.length; i++){\n            IRewards(extraRewards[i]).withdraw(msg.sender, amount);\n        }\n\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n\n        stakingToken.safeTransfer(msg.sender, amount);\n        emit Withdrawn(msg.sender, amount);\n     \n        if(claim){\n            getReward(msg.sender,true);\n        }\n\n        return true;\n    }\n\n    function withdrawAll(bool claim) external{\n        withdraw(_balances[msg.sender],claim);\n    }\n\n    function withdrawAndUnwrap(uint256 amount, bool claim) public updateReward(msg.sender) returns(bool){\n\n        //also withdraw from linked rewards\n        for(uint i=0; i < extraRewards.length; i++){\n            IRewards(extraRewards[i]).withdraw(msg.sender, amount);\n        }\n        \n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n\n        //tell operator to withdraw from here directly to user\n        IDeposit(operator).withdrawTo(pid,amount,msg.sender);\n        emit Withdrawn(msg.sender, amount);\n\n        //get rewards too\n        if(claim){\n            getReward(msg.sender,true);\n        }\n        return true;\n    }\n\n    function withdrawAllAndUnwrap(bool claim) external{\n        withdrawAndUnwrap(_balances[msg.sender],claim);\n    }\n\n    function getReward(address _account, bool _claimExtras) public updateReward(_account) returns(bool){\n        uint256 reward = earned(_account);\n        if (reward > 0) {\n            rewards[_account] = 0;\n            rewardToken.safeTransfer(_account, reward);\n            IDeposit(operator).rewardClaimed(pid, _account, reward);\n            emit RewardPaid(_account, reward);\n        }\n\n        //also get rewards from linked rewards\n        if(_claimExtras){\n            for(uint i=0; i < extraRewards.length; i++){\n                IRewards(extraRewards[i]).getReward(_account);\n            }\n        }\n        return true;\n    }\n\n    function getReward() external returns(bool){\n        getReward(msg.sender,true);\n        return true;\n    }\n\n    function donate(uint256 _amount) external returns(bool){\n        IERC20(rewardToken).safeTransferFrom(msg.sender, address(this), _amount);\n        queuedRewards = queuedRewards.add(_amount);\n    }\n\n    function queueNewRewards(uint256 _rewards) external returns(bool){\n        require(msg.sender == operator, \"!authorized\");\n\n        _rewards = _rewards.add(queuedRewards);\n\n        if (block.timestamp >= periodFinish) {\n            notifyRewardAmount(_rewards);\n            queuedRewards = 0;\n            return true;\n        }\n\n        //et = now - (finish-duration)\n        uint256 elapsedTime = block.timestamp.sub(periodFinish.sub(duration));\n        //current at now: rewardRate * elapsedTime\n        uint256 currentAtNow = rewardRate * elapsedTime;\n        uint256 queuedRatio = currentAtNow.mul(1000).div(_rewards);\n\n        //uint256 queuedRatio = currentRewards.mul(1000).div(_rewards);\n        if(queuedRatio < newRewardRatio){\n            notifyRewardAmount(_rewards);\n            queuedRewards = 0;\n        }else{\n            queuedRewards = _rewards;\n        }\n        return true;\n    }\n\n    function notifyRewardAmount(uint256 reward)\n        internal\n        updateReward(address(0))\n    {\n        historicalRewards = historicalRewards.add(reward);\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(duration);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            reward = reward.add(leftover);\n            rewardRate = reward.div(duration);\n        }\n        currentRewards = reward;\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp.add(duration);\n        emit RewardAdded(reward);\n    }\n}"
    },
    {
      "filename": "core/solidity/contracts/core/Vault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {IUSDA} from '@interfaces/core/IUSDA.sol';\nimport {IVault} from '@interfaces/core/IVault.sol';\nimport {IVaultController} from '@interfaces/core/IVaultController.sol';\nimport {IAMPHClaimer} from '@interfaces/core/IAMPHClaimer.sol';\nimport {IBooster} from '@interfaces/utils/IBooster.sol';\nimport {IBaseRewardPool} from '@interfaces/utils/IBaseRewardPool.sol';\nimport {IVirtualBalanceRewardPool} from '@interfaces/utils/IVirtualBalanceRewardPool.sol';\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {Context} from '@openzeppelin/contracts/utils/Context.sol';\nimport {SafeERC20Upgradeable} from '@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol';\nimport {IERC20Upgradeable} from '@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol';\nimport {ICVX} from '@interfaces/utils/ICVX.sol';\n\n/// @notice Vault contract, our implementation of maker-vault like vault\n/// @dev Major differences:\n/// 1. multi-collateral\n/// 2. generate interest in USDA\ncontract Vault is IVault, Context {\n  using SafeERC20Upgradeable for IERC20;\n\n  /// @dev The CVX token\n  ICVX public immutable CVX;\n\n  /// @dev The CRV token\n  IERC20 public immutable CRV;\n\n  /// @dev The vault controller\n  IVaultController public immutable CONTROLLER;\n\n  /// @dev Metadata of vault, aka the id & the minter's address\n  VaultInfo public vaultInfo;\n\n  /// @dev This is the unscaled liability of the vault.\n  /// The number is meaningless on its own, and must be combined with the factor taken from\n  /// the vaultController in order to find the true liabilitiy\n  uint256 public baseLiability;\n\n  /// @dev Keeps track of the accounting of the collateral deposited\n  mapping(address => uint256) public balances;\n\n  /// @dev Keeps track of the tokens that are staked on convex\n  mapping(address => bool) public isTokenStaked;\n\n  /// @notice Checks if _msgSender is the controller of the vault\n  modifier onlyVaultController() {\n    if (_msgSender() != address(CONTROLLER)) revert Vault_NotVaultController();\n    _;\n  }\n\n  /// @notice Checks if _msgSender is the minter of the vault\n  modifier onlyMinter() {\n    if (_msgSender() != vaultInfo.minter) revert Vault_NotMinter();\n    _;\n  }\n\n  /// @dev Must be called by VaultController, else it will not be registered as a vault in system\n  /// @param _id Unique id of the vault, ever increasing and tracked by VaultController\n  /// @param _minter Address of the person who created this vault\n  /// @param _controllerAddress Address of the VaultController\n  /// @param _cvx Address of CVX token\n  /// @param _crv Address of CRV token\n  constructor(uint96 _id, address _minter, address _controllerAddress, IERC20 _cvx, IERC20 _crv) {\n    vaultInfo = VaultInfo(_id, _minter);\n    CONTROLLER = IVaultController(_controllerAddress);\n    CVX = ICVX(address(_cvx));\n    CRV = _crv;\n  }\n\n  /// @notice Returns the minter of the vault\n  /// @return _minter The address of minter\n  function minter() external view override returns (address _minter) {\n    _minter = vaultInfo.minter;\n  }\n\n  /// @notice Returns the id of the vault\n  /// @return _id The id of the vault\n  function id() external view override returns (uint96 _id) {\n    _id = vaultInfo.id;\n  }\n\n  /// @notice Used to deposit a token to the vault\n  /// @dev    Deposits and stakes on convex if token is of type CurveLPStakedOnConvex\n  /// @param _token The address of the token to deposit\n  /// @param _amount The amount of the token to deposit\n  function depositERC20(address _token, uint256 _amount) external override onlyMinter {\n    if (CONTROLLER.tokenId(_token) == 0) revert Vault_TokenNotRegistered();\n    if (_amount == 0) revert Vault_AmountZero();\n    SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(_token), _msgSender(), address(this), _amount);\n    if (CONTROLLER.tokenCollateralType(_token) == IVaultController.CollateralType.CurveLPStakedOnConvex) {\n      uint256 _poolId = CONTROLLER.tokenPoolId(_token);\n      /// If it's type CurveLPStakedOnConvex then pool id can't be 0\n      IBooster _booster = CONTROLLER.BOOSTER();\n      if (isTokenStaked[_token]) {\n        /// In this case the user's balance is already staked so we only stake the newly deposited amount\n        _depositAndStakeOnConvex(_token, _booster, _amount, _poolId);\n      } else {\n        /// In this case the user's balance isn't staked so we stake the amount + his balance for the specific tokenv\n        isTokenStaked[_token] = true;\n        _depositAndStakeOnConvex(_token, _booster, balances[_token] + _amount, _poolId);\n      }\n    }\n    balances[_token] += _amount;\n    CONTROLLER.modifyTotalDeposited(vaultInfo.id, _amount, _token, true);\n    emit Deposit(_token, _amount);\n  }\n\n  /// @notice Withdraws an erc20 token from the vault\n  /// @dev    This can only be called by the minter\n  ///         The withdraw will be denied if ones vault would become insolvent\n  ///         If the withdraw token is of CurveLPStakedOnConvex then unstake and withdraw directly to user\n  /// @param _tokenAddress The address of erc20 token\n  /// @param _amount The amount of erc20 token to withdraw\n  function withdrawERC20(address _tokenAddress, uint256 _amount) external override onlyMinter {\n    if (CONTROLLER.tokenId(_tokenAddress) == 0) revert Vault_TokenNotRegistered();\n    if (isTokenStaked[_tokenAddress]) {\n      if (!CONTROLLER.tokenCrvRewardsContract(_tokenAddress).withdrawAndUnwrap(_amount, false)) {\n        revert Vault_WithdrawAndUnstakeOnConvexFailed();\n      }\n    }\n    // reduce balance\n    balances[_tokenAddress] -= _amount;\n    // check if the account is solvent\n    if (!CONTROLLER.checkVault(vaultInfo.id)) revert Vault_OverWithdrawal();\n    // transfer the token to the owner\n    SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(_tokenAddress), _msgSender(), _amount);\n    // modify total deposited\n    CONTROLLER.modifyTotalDeposited(vaultInfo.id, _amount, _tokenAddress, false);\n    emit Withdraw(_tokenAddress, _amount);\n  }\n\n  /// @notice Let's the user manually stake their crvLP\n  /// @dev    This can be called if the convex pool didn't exist when the token was registered\n  ///         and was later updated\n  /// @param _tokenAddress The address of erc20 crvLP token\n  function stakeCrvLPCollateral(address _tokenAddress) external override onlyMinter {\n    uint256 _poolId = CONTROLLER.tokenPoolId(_tokenAddress);\n    if (_poolId == 0) revert Vault_TokenCanNotBeStaked();\n    if (balances[_tokenAddress] == 0) revert Vault_TokenZeroBalance();\n    if (isTokenStaked[_tokenAddress]) revert Vault_TokenAlreadyStaked();\n\n    isTokenStaked[_tokenAddress] = true;\n\n    IBooster _booster = CONTROLLER.BOOSTER();\n    _depositAndStakeOnConvex(_tokenAddress, _booster, balances[_tokenAddress], _poolId);\n\n    emit Staked(_tokenAddress, balances[_tokenAddress]);\n  }\n\n  /// @notice Returns true when user can manually stake their token balance\n  /// @param _token The address of the token to check\n  /// @return _canStake Returns true if the token can be staked manually\n  function canStake(address _token) external view override returns (bool _canStake) {\n    uint256 _poolId = CONTROLLER.tokenPoolId(_token);\n    if (_poolId != 0 && balances[_token] != 0 && !isTokenStaked[_token]) _canStake = true;\n  }\n\n  /// @notice Claims available rewards from multiple tokens\n  /// @dev    Transfers a percentage of the crv and cvx rewards to claim AMPH tokens\n  /// @param _tokenAddresses The addresses of the erc20 tokens\n  function claimRewards(address[] memory _tokenAddresses) external override onlyMinter {\n    uint256 _totalCrvReward;\n    uint256 _totalCvxReward;\n\n    IAMPHClaimer _amphClaimer = CONTROLLER.claimerContract();\n    for (uint256 _i; _i < _tokenAddresses.length;) {\n      IVaultController.CollateralInfo memory _collateralInfo = CONTROLLER.tokenCollateralInfo(_tokenAddresses[_i]);\n      if (_collateralInfo.tokenId == 0) revert Vault_TokenNotRegistered();\n      if (_collateralInfo.collateralType != IVaultController.CollateralType.CurveLPStakedOnConvex) {\n        revert Vault_TokenNotCurveLP();\n      }\n\n      IBaseRewardPool _rewardsContract = _collateralInfo.crvRewardsContract;\n      uint256 _crvReward = _rewardsContract.earned(address(this));\n\n      if (_crvReward != 0) {\n        // Claim the CRV reward\n        _totalCrvReward += _crvReward;\n        _rewardsContract.getReward(address(this), false);\n        _totalCvxReward += _calculateCVXReward(_crvReward);\n      }\n\n      // Loop and claim all virtual rewards\n      uint256 _extraRewards = _rewardsContract.extraRewardsLength();\n      for (uint256 _j; _j < _extraRewards;) {\n        IVirtualBalanceRewardPool _virtualReward = _rewardsContract.extraRewards(_j);\n        IERC20 _rewardToken = _virtualReward.rewardToken();\n        uint256 _earnedReward = _virtualReward.earned(address(this));\n        if (_earnedReward != 0) {\n          _virtualReward.getReward();\n          _rewardToken.transfer(_msgSender(), _earnedReward);\n          emit ClaimedReward(address(_rewardToken), _earnedReward);\n        }\n        unchecked {\n          ++_j;\n        }\n      }\n      unchecked {\n        ++_i;\n      }\n    }\n\n    if (_totalCrvReward > 0 || _totalCvxReward > 0) {\n      if (address(_amphClaimer) != address(0)) {\n        // Approve amounts for it to be taken\n        (uint256 _takenCVX, uint256 _takenCRV, uint256 _claimableAmph) =\n          _amphClaimer.claimable(address(this), this.id(), _totalCvxReward, _totalCrvReward);\n        if (_claimableAmph != 0) {\n          CRV.approve(address(_amphClaimer), _takenCRV);\n          CVX.approve(address(_amphClaimer), _takenCVX);\n\n          // Claim AMPH tokens depending on how much CRV and CVX was claimed\n          _amphClaimer.claimAmph(this.id(), _totalCvxReward, _totalCrvReward, _msgSender());\n\n          _totalCvxReward -= _takenCVX;\n          _totalCrvReward -= _takenCRV;\n        }\n      }\n\n      if (_totalCvxReward > 0) CVX.transfer(_msgSender(), _totalCvxReward);\n      if (_totalCrvReward > 0) CRV.transfer(_msgSender(), _totalCrvReward);\n\n      emit ClaimedReward(address(CRV), _totalCrvReward);\n      emit ClaimedReward(address(CVX), _totalCvxReward);\n    }\n  }\n\n  /// @notice Returns an array of all the available rewards the user can claim\n  /// @param _tokenAddress The address of the token collateral to check rewards for\n  /// @return _rewards The array of all the available rewards\n  function claimableRewards(address _tokenAddress) external view override returns (Reward[] memory _rewards) {\n    if (CONTROLLER.tokenId(_tokenAddress) == 0) revert Vault_TokenNotRegistered();\n    if (CONTROLLER.tokenCollateralType(_tokenAddress) != IVaultController.CollateralType.CurveLPStakedOnConvex) {\n      revert Vault_TokenNotCurveLP();\n    }\n\n    IBaseRewardPool _rewardsContract = CONTROLLER.tokenCrvRewardsContract(_tokenAddress);\n    IAMPHClaimer _amphClaimer = CONTROLLER.claimerContract();\n\n    uint256 _rewardsAmount = _rewardsContract.extraRewardsLength();\n\n    uint256 _crvReward = _rewardsContract.earned(address(this));\n    uint256 _cvxReward = _calculateCVXReward(_crvReward);\n\n    // +3 for CRV, CVX and AMPH\n    _rewards = new Reward[](_rewardsAmount+3);\n    _rewards[0] = Reward(CRV, _crvReward);\n    _rewards[1] = Reward(CVX, _cvxReward);\n\n    uint256 _i;\n    for (_i; _i < _rewardsAmount;) {\n      IVirtualBalanceRewardPool _virtualReward = _rewardsContract.extraRewards(_i);\n      IERC20 _rewardToken = _virtualReward.rewardToken();\n      uint256 _earnedReward = _virtualReward.earned(address(this));\n      _rewards[_i + 2] = Reward(_rewardToken, _earnedReward);\n\n      unchecked {\n        ++_i;\n      }\n    }\n\n    uint256 _takenCVX;\n    uint256 _takenCRV;\n    uint256 _claimableAmph;\n    // if claimer is not set, nothing will happen (and variables are already in zero)\n    if (address(_amphClaimer) != address(0)) {\n      // claimer is set, proceed\n      (_takenCVX, _takenCRV, _claimableAmph) = _amphClaimer.claimable(address(this), this.id(), _cvxReward, _crvReward);\n      _rewards[_i + 2] = Reward(_amphClaimer.AMPH(), _claimableAmph);\n    }\n\n    _rewards[0].amount = _crvReward - _takenCRV;\n    if (_cvxReward > 0) _rewards[1].amount = _cvxReward - _takenCVX;\n  }\n\n  /// @notice Function used by the VaultController to transfer tokens\n  /// @dev Callable by the VaultController only\n  /// @param _token The token to transfer\n  /// @param _to The address to send the tokens to\n  /// @param _amount The amount of tokens to move\n  function controllerTransfer(address _token, address _to, uint256 _amount) external override onlyVaultController {\n    SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(_token), _to, _amount);\n    balances[_token] -= _amount;\n  }\n\n  /// @notice Function used by the VaultController to withdraw from convex\n  /// @dev Callable by the VaultController only\n  /// @param _rewardPool The pool to withdraw\n  /// @param _amount The amount of tokens to withdraw\n  function controllerWithdrawAndUnwrap(\n    IBaseRewardPool _rewardPool,\n    uint256 _amount\n  ) external override onlyVaultController {\n    if (!_rewardPool.withdrawAndUnwrap(_amount, false)) revert Vault_WithdrawAndUnstakeOnConvexFailed();\n  }\n\n  /// @notice Function used by the VaultController to reduce a vault's liability\n  /// @dev Callable by the VaultController only\n  /// @param _increase True to increase, false to decrease\n  /// @param _baseAmount The change in base liability\n  /// @return _newLiability The new liability\n  function modifyLiability(\n    bool _increase,\n    uint256 _baseAmount\n  ) external override onlyVaultController returns (uint256 _newLiability) {\n    if (_increase) {\n      baseLiability += _baseAmount;\n    } else {\n      // require statement only valid for repayment\n      if (baseLiability < _baseAmount) revert Vault_RepayTooMuch();\n      baseLiability -= _baseAmount;\n    }\n    _newLiability = baseLiability;\n  }\n\n  /// @dev Internal function for depositing and staking on convex\n  function _depositAndStakeOnConvex(address _token, IBooster _booster, uint256 _amount, uint256 _poolId) internal {\n    IERC20(_token).approve(address(_booster), _amount);\n    if (!_booster.deposit(_poolId, _amount, true)) revert Vault_DepositAndStakeOnConvexFailed();\n  }\n\n  /// @notice Used to calculate the CVX reward for a given CRV amount\n  /// @dev This is copied from the CVX mint function\n  /// @param _crv The amount of CRV to calculate the CVX reward for\n  /// @return _cvxAmount The amount of CVX to get\n  function _calculateCVXReward(uint256 _crv) internal view returns (uint256 _cvxAmount) {\n    uint256 _supply = CVX.totalSupply();\n    uint256 _totalCliffs = CVX.totalCliffs();\n\n    //use current supply to gauge cliff\n    //this will cause a bit of overflow into the next cliff range\n    //but should be within reasonable levels.\n    //requires a max supply check though\n    uint256 _cliff = _supply / CVX.reductionPerCliff();\n    //mint if below total cliffs\n    if (_cliff < _totalCliffs) {\n      //for reduction% take inverse of current cliff\n      uint256 _reduction = _totalCliffs - _cliff;\n      //reduce\n      _cvxAmount = (_crv * _reduction) / _totalCliffs;\n\n      //supply cap check\n      uint256 _amtTillMax = CVX.maxSupply() - _supply;\n      if (_cvxAmount > _amtTillMax) _cvxAmount = _amtTillMax;\n    }\n  }\n}"
    }
  ]
}