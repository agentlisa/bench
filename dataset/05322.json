{
  "Title": "[H-04] Bonds created in year cross epoch's can lead to lost payouts",
  "Content": "\n<https://github.com/code-423n4/2023-12-autonolas/blob/2a095eb1f8359be349d23af67089795fb0be4ed1/tokenomics/contracts/Tokenomics.sol#L1037-L1038> <br><https://github.com/code-423n4/2023-12-autonolas/blob/2a095eb1f8359be349d23af67089795fb0be4ed1/governance/contracts/OLAS.sol#L75-L84>\n\nBond depositors and agent/component owner's may never receive the payout Olas.\nIncorrect inflation control.\n\n### Proof of Concept\n\n`effectiveBond` is used to account how much of Olas is available for bonding. This includes Olas that are to be minted in the current epoch ie. `effectiveBond` will include the Olas partitioned for bonding in epoch 5 at the beginning of epoch 5 itself. In case of epoch's crossing `YEAR` intervals, a portion of the Olas would actually only be mintable in the next year due to the yearwise inflation control enforced at the mint (after 9 years due to fixed supply till 10 years). Due to silent reverts, this can lead to lost Olas payouts\n\nThe inflation for bonds are accounted using the `effectiveBond` variable. <br><https://github.com/code-423n4/2023-12-autonolas/blob/2a095eb1f8359be349d23af67089795fb0be4ed1/tokenomics/contracts/Tokenomics.sol#L609-L617>\n\n```solidity\n    function reserveAmountForBondProgram(uint256 amount) external returns (bool success) {\n       \n       .....\n\n        // Effective bond must be bigger than the requested amount\n        uint256 eBond = effectiveBond;\n        if (eBond >= amount) {\n\n            eBond -= amount;\n            effectiveBond = uint96(eBond);\n            success = true;\n            emit EffectiveBondUpdated(eBond);\n        }\n    }\n```\n\nThis variable is updated with the estimated bond Olas at the beginning of an epoch itself.\n\n<https://github.com/code-423n4/2023-12-autonolas/blob/2a095eb1f8359be349d23af67089795fb0be4ed1/tokenomics/contracts/Tokenomics.sol#L1037-L1038>\n\n```solidity\n    function checkpoint() external returns (bool) {\n        \n        .....\n\n        // Update effectiveBond with the current or updated maxBond value\n        curMaxBond += effectiveBond;\n        effectiveBond = uint96(curMaxBond);\n```\n\nIn case of epochs crossing `YEAR` intervals after 9 years, the new Olas amount will not be fully mintable in the same year due to the inflation control check enforced in the Olas contract.\n\n<https://github.com/code-423n4/2023-12-autonolas/blob/2a095eb1f8359be349d23af67089795fb0be4ed1/governance/contracts/OLAS.sol#L75-L84>\n\n```solidity\n    function mint(address account, uint256 amount) external {\n\n        ....\n        \n        // Check the inflation schedule and mint\n        if (inflationControl(amount)) {\n            _mint(account, amount);\n        }\n```\n\nWhenever a deposit is made on a bond, the required Olas is minted by the treasury and transferred to the Depository contract, from where the depositor claims the payout after the vesting time. `Olas.sol` doesn't revert for inflation check failure but fails silently. This can cause a deposit to succeed but corresponding redeem to fail since payout Olas has not been actually minted.\nIt can also happen that agent/component owner's who have not claimed the topup Olas amount will loose their reward due to silent return when minting their reward.\n\n### Example\n\n*   Year 10, 1 month left for Year 11.\n*   All Olas associated with previous epochs have been minted.\n*   New epoch of 2 months is started, 1 month in Year 10 and 1 month in Year 11.\n*   Total Olas for the epoch, t = year 10 1 month inflation + year 11 1 month inflation.\n\nYear 10 1 month inflaiton (y10m1) = (1\\_000\\_000\\_000e18 \\* 2 / 100 / 12)<br>\nYear 11 1 month inflation (y11m1) = (1\\_020\\_000\\_000e18 \\* 2 / 100 / 12)\nt = y10m1 + y11m1\n\n*   Olas bond percentage = 50%\n*   Hence effectiveBond = t/2\n*   But actual mintable remaining in year 0, m = y10m1 < effectiveBond\n*   A bond is created with supply == effectiveBond\n*   User's deposit for the entire bond supply but only y10m1 Olas can be minted. Depending on the nature of deposits, the actual amount minted can vary from 0 to y10m1. In case of unminted amounts(as rewards of agent/component owner's etc.) at Year 10, this amount can be minted for bond deposits following which if agent/component owners claim within the year, no Olas will be received by them.\n*   Users lose their Olas payout.\n\n### POC Test\n\n<https://gist.github.com/10xhash/2157c1f2cdc9513b3f0a7f359a65015e>\n\n### Recommended Mitigation Steps\n\nIn case of multi-year epochs, separate bond amounts of next year.\n\n**[kupermind (Olas) confirmed](https://github.com/code-423n4/2023-12-autonolas-findings/issues/373#issuecomment-1893958287)**\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-12-autonolas",
  "Code": [
    {
      "filename": "tokenomics/contracts/Tokenomics.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./TokenomicsConstants.sol\";\nimport \"./interfaces/IDonatorBlacklist.sol\";\nimport \"./interfaces/IErrorsTokenomics.sol\";\nimport \"./interfaces/IOLAS.sol\";\nimport \"./interfaces/IServiceRegistry.sol\";\nimport \"./interfaces/IToken.sol\";\nimport \"./interfaces/ITreasury.sol\";\nimport \"./interfaces/IVotingEscrow.sol\";\n\n/*\n* In this contract we consider both ETH and OLAS tokens.\n* For ETH tokens, there are currently about 121 million tokens.\n* Even if the ETH inflation rate is 5% per year, it would take 130+ years to reach 2^96 - 1 of ETH total supply.\n* Lately the inflation rate was lower and could actually be deflationary.\n*\n* For OLAS tokens, the initial numbers will be as follows:\n*  - For the first 10 years there will be the cap of 1 billion (1e27) tokens;\n*  - After 10 years, the inflation rate is capped at 2% per year.\n* Starting from a year 11, the maximum number of tokens that can be reached per the year x is 1e27 * (1.02)^x.\n* To make sure that a unit(n) does not overflow the total supply during the year x, we have to check that\n* 2^n - 1 >= 1e27 * (1.02)^x. We limit n by 96, thus it would take 220+ years to reach that total supply.\n*\n* We then limit each time variable to last until the value of 2^32 - 1 in seconds.\n* 2^32 - 1 gives 136+ years counted in seconds starting from the year 1970.\n* Thus, this counter is safe until the year 2106.\n*\n* The number of blocks cannot be practically bigger than the number of seconds, since there is more than one second\n* in a block. Thus, it is safe to assume that uint32 for the number of blocks is also sufficient.\n*\n* We also limit the number of registry units by the value of 2^32 - 1.\n* We assume that the system is expected to support no more than 2^32-1 units.\n*\n* Lastly, we assume that the coefficients from tokenomics factors calculation are bound by 2^16 - 1.\n*\n* In conclusion, this contract is only safe to use until 2106.\n*/\n\n// Structure for component / agent point with tokenomics-related statistics\n// The size of the struct is 96 + 32 + 8 * 2 = 144 (1 slot)\nstruct UnitPoint {\n    // Summation of all the relative OLAS top-ups accumulated by each component / agent in a service\n    // After 10 years, the OLAS inflation rate is 2% per year. It would take 220+ years to reach 2^96 - 1\n    uint96 sumUnitTopUpsOLAS;\n    // Number of new units\n    // This number cannot be practically bigger than the total number of supported units\n    uint32 numNewUnits;\n    // Reward component / agent fraction\n    // This number cannot be practically bigger than 100 as the summation with other fractions gives at most 100 (%)\n    uint8 rewardUnitFraction;\n    // Top-up component / agent fraction\n    // This number cannot be practically bigger than 100 as the summation with other fractions gives at most 100 (%)\n    uint8 topUpUnitFraction;\n}\n\n// Structure for epoch point with tokenomics-related statistics during each epoch\n// The size of the struct is 96 * 2 + 64 + 32 * 2 + 8 * 2 = 256 + 80 (2 slots)\nstruct EpochPoint {\n    // Total amount of ETH donations accrued by the protocol during one epoch\n    // Even if the ETH inflation rate is 5% per year, it would take 130+ years to reach 2^96 - 1 of ETH total supply\n    uint96 totalDonationsETH;\n    // Amount of OLAS intended to fund top-ups for the epoch based on the inflation schedule\n    // After 10 years, the OLAS inflation rate is 2% per year. It would take 220+ years to reach 2^96 - 1\n    uint96 totalTopUpsOLAS;\n    // Inverse of the discount factor\n    // IDF is bound by a factor of 18, since (2^64 - 1) / 10^18 > 18\n    // IDF uses a multiplier of 10^18 by default, since it is a rational number and must be accounted for divisions\n    // The IDF depends on the epsilonRate value, idf = 1 + epsilonRate, and epsilonRate is bound by 17 with 18 decimals\n    uint64 idf;\n    // Number of new owners\n    // Each unit has at most one owner, so this number cannot be practically bigger than numNewUnits\n    uint32 numNewOwners;\n    // Epoch end timestamp\n    // 2^32 - 1 gives 136+ years counted in seconds starting from the year 1970, which is safe until the year of 2106\n    uint32 endTime;\n    // Parameters for rewards and top-ups (in percentage)\n    // Each of these numbers cannot be practically bigger than 100 as they sum up to 100%\n    // treasuryFraction + rewardComponentFraction + rewardAgentFraction = 100%\n    // Treasury fraction\n    uint8 rewardTreasuryFraction;\n    // maxBondFraction + topUpComponentFraction + topUpAgentFraction <= 100%\n    // Amount of OLAS (in percentage of inflation) intended to fund bonding incentives during the epoch\n    uint8 maxBondFraction;\n}\n\n// Structure for tokenomics point\n// The size of the struct is 256 * 2 + 256 * 2 = 256 * 4 (4 slots)\nstruct TokenomicsPoint {\n    // Two unit points in a representation of mapping and not on array to save on gas\n    // One unit point is for component (key = 0) and one is for agent (key = 1)\n    mapping(uint256 => UnitPoint) unitPoints;\n    // Epoch point\n    EpochPoint epochPoint;\n}\n\n// Struct for component / agent incentive balances\nstruct IncentiveBalances {\n    // Reward in ETH\n    // Even if the ETH inflation rate is 5% per year, it would take 130+ years to reach 2^96 - 1 of ETH total supply\n    uint96 reward;\n    // Pending relative reward in ETH\n    uint96 pendingRelativeReward;\n    // Top-up in OLAS\n    // After 10 years, the OLAS inflation rate is 2% per year. It would take 220+ years to reach 2^96 - 1\n    uint96 topUp;\n    // Pending relative top-up\n    uint96 pendingRelativeTopUp;\n    // Last epoch number the information was updated\n    // This number cannot be practically bigger than the number of blocks\n    uint32 lastEpoch;\n}\n\n/// @title Tokenomics - Smart contract for tokenomics logic with incentives for unit owners and discount factor regulations for bonds.\n/// @author AL\n/// @author Aleksandr Kuperman - <aleksandr.kuperman@valory.xyz>\ncontract Tokenomics is TokenomicsConstants, IErrorsTokenomics {\n    event OwnerUpdated(address indexed owner);\n    event TreasuryUpdated(address indexed treasury);\n    event DepositoryUpdated(address indexed depository);\n    event DispenserUpdated(address indexed dispenser);\n    event EpochLengthUpdated(uint256 epochLen);\n    event EffectiveBondUpdated(uint256 effectiveBond);\n    event IDFUpdated(uint256 idf);\n    event TokenomicsParametersUpdateRequested(uint256 indexed epochNumber, uint256 devsPerCapital, uint256 codePerDev,\n        uint256 epsilonRate, uint256 epochLen, uint256 veOLASThreshold);\n    event TokenomicsParametersUpdated(uint256 indexed epochNumber);\n    event IncentiveFractionsUpdateRequested(uint256 indexed epochNumber, uint256 rewardComponentFraction,\n        uint256 rewardAgentFraction, uint256 maxBondFraction, uint256 topUpComponentFraction, uint256 topUpAgentFraction);\n    event IncentiveFractionsUpdated(uint256 indexed epochNumber);\n    event ComponentRegistryUpdated(address indexed componentRegistry);\n    event AgentRegistryUpdated(address indexed agentRegistry);\n    event ServiceRegistryUpdated(address indexed serviceRegistry);\n    event DonatorBlacklistUpdated(address indexed blacklist);\n    event EpochSettled(uint256 indexed epochCounter, uint256 treasuryRewards, uint256 accountRewards, uint256 accountTopUps);\n    event TokenomicsImplementationUpdated(address indexed implementation);\n\n    // Owner address\n    address public owner;\n    // Max bond per epoch: calculated as a fraction from the OLAS inflation parameter\n    // After 10 years, the OLAS inflation rate is 2% per year. It would take 220+ years to reach 2^96 - 1\n    uint96 public maxBond;\n\n    // OLAS token address\n    address public olas;\n    // Inflation amount per second\n    uint96 public inflationPerSecond;\n\n    // Treasury contract address\n    address public treasury;\n    // veOLAS threshold for top-ups\n    // This number cannot be practically bigger than the number of OLAS tokens\n    uint96 public veOLASThreshold;\n\n    // Depository contract address\n    address public depository;\n    // effectiveBond = sum(MaxBond(e)) - sum(BondingProgram) over all epochs: accumulates leftovers from previous epochs\n    // Effective bond is updated before the start of the next epoch such that the bonding limits are accounted for\n    // This number cannot be practically bigger than the inflation remainder of OLAS\n    uint96 public effectiveBond;\n\n    // Dispenser contract address\n    address public dispenser;\n    // Number of units of useful code that can be built by a developer during one epoch\n    // We assume this number will not be practically bigger than 4,722 of its integer-part (with 18 digits of fractional-part)\n    uint72 public codePerDev;\n    // Current year number\n    // This number is enough for the next 255 years\n    uint8 public currentYear;\n    // Tokenomics parameters change request flag\n    bytes1 public tokenomicsParametersUpdated;\n    // Reentrancy lock\n    uint8 internal _locked;\n\n    // Component Registry\n    address public componentRegistry;\n    // Default epsilon rate that contributes to the interest rate: 10% or 0.1\n    // We assume that for the IDF calculation epsilonRate must be lower than 17 (with 18 decimals)\n    // (2^64 - 1) / 10^18 > 18, however IDF = 1 + epsilonRate, thus we limit epsilonRate by 17 with 18 decimals at most\n    uint64 public epsilonRate;\n    // Epoch length in seconds\n    // By design, the epoch length cannot be practically bigger than one year, or 31_536_000 seconds\n    uint32 public epochLen;\n\n    // Agent Registry\n    address public agentRegistry;\n    // veOLAS threshold for top-ups that will be set in the next epoch\n    // This number cannot be practically bigger than the number of OLAS tokens\n    uint96 public nextVeOLASThreshold;\n\n    // Service Registry\n    address public serviceRegistry;\n    // Global epoch counter\n    // This number cannot be practically bigger than the number of blocks\n    uint32 public epochCounter;\n    // Time launch of the OLAS contract\n    // 2^32 - 1 gives 136+ years counted in seconds starting from the year 1970, which is safe until the year of 2106\n    uint32 public timeLaunch;\n    // Epoch length in seconds that will be set in the next epoch\n    // By design, the epoch length cannot be practically bigger than one year, or 31_536_000 seconds\n    uint32 public nextEpochLen;\n\n    // Voting Escrow address\n    address public ve;\n    // Number of valuable devs that can be paid per units of capital per epoch in fixed point format\n    // We assume this number will not be practically bigger than 4,722 of its integer-part (with 18 digits of fractional-part)\n    uint72 public devsPerCapital;\n\n    // Blacklist contract address\n    address public donatorBlacklist;\n    // Last donation block number to prevent the flash loan attack\n    // This number cannot be practically bigger than the number of seconds\n    uint32 public lastDonationBlockNumber;\n\n    // Map of service Ids and their amounts in current epoch\n    mapping(uint256 => uint256) public mapServiceAmounts;\n    // Mapping of owner of component / agent address => reward amount (in ETH)\n    mapping(address => uint256) public mapOwnerRewards;\n    // Mapping of owner of component / agent address => top-up amount (in OLAS)\n    mapping(address => uint256) public mapOwnerTopUps;\n    // Mapping of epoch => tokenomics point\n    mapping(uint256 => TokenomicsPoint) public mapEpochTokenomics;\n    // Map of new component / agent Ids that contribute to protocol owned services\n    mapping(uint256 => mapping(uint256 => bool)) public mapNewUnits;\n    // Mapping of new owner of component / agent addresses that create them\n    mapping(address => bool) public mapNewOwners;\n    // Mapping of component / agent Id => incentive balances\n    mapping(uint256 => mapping(uint256 => IncentiveBalances)) public mapUnitIncentives;\n\n    /// @dev Tokenomics constructor.\n    constructor()\n        TokenomicsConstants()\n    {}\n\n    /// @dev Tokenomics initializer.\n    /// @notice Tokenomics contract must be initialized no later than one year from the launch of the OLAS token contract.\n    /// @param _olas OLAS token address.\n    /// @param _treasury Treasury address.\n    /// @param _depository Depository address.\n    /// @param _dispenser Dispenser address.\n    /// @param _ve Voting Escrow address.\n    /// @param _epochLen Epoch length.\n    /// @param _componentRegistry Component registry address.\n    /// @param _agentRegistry Agent registry address.\n    /// @param _serviceRegistry Service registry address.\n    /// @param _donatorBlacklist DonatorBlacklist address.\n    /// #if_succeeds {:msg \"ep is correct endTime\"} mapEpochTokenomics[0].epochPoint.endTime > 0;\n    /// #if_succeeds {:msg \"maxBond eq effectiveBond form start\"} effectiveBond == maxBond;\n    /// #if_succeeds {:msg \"olas must not be a zero address\"} old(_olas) != address(0) ==> olas == _olas;\n    /// #if_succeeds {:msg \"treasury must not be a zero address\"} old(_treasury) != address(0) ==> treasury == _treasury;\n    /// #if_succeeds {:msg \"depository must not be a zero address\"} old(_depository) != address(0) ==> depository == _depository;\n    /// #if_succeeds {:msg \"dispenser must not be a zero address\"} old(_dispenser) != address(0) ==> dispenser == _dispenser;\n    /// #if_succeeds {:msg \"vaOLAS must not be a zero address\"} old(_ve) != address(0) ==> ve == _ve;\n    /// #if_succeeds {:msg \"epochLen\"} old(_epochLen > MIN_EPOCH_LENGTH && _epochLen <= type(uint32).max) ==> epochLen == _epochLen;\n    /// #if_succeeds {:msg \"componentRegistry must not be a zero address\"} old(_componentRegistry) != address(0) ==> componentRegistry == _componentRegistry;\n    /// #if_succeeds {:msg \"agentRegistry must not be a zero address\"} old(_agentRegistry) != address(0) ==> agentRegistry == _agentRegistry;\n    /// #if_succeeds {:msg \"serviceRegistry must not be a zero address\"} old(_serviceRegistry) != address(0) ==> serviceRegistry == _serviceRegistry;\n    /// #if_succeeds {:msg \"donatorBlacklist assignment\"} donatorBlacklist == _donatorBlacklist;\n    /// #if_succeeds {:msg \"inflationPerSecond must not be zero\"} inflationPerSecond > 0 && inflationPerSecond <= getInflationForYear(0);\n    /// #if_succeeds {:msg \"Zero epoch point end time must be non-zero\"} mapEpochTokenomics[0].epochPoint.endTime > 0;\n    /// #if_succeeds {:msg \"maxBond\"} old(_epochLen > MIN_EPOCH_LENGTH && _epochLen <= type(uint32).max && inflationPerSecond > 0 && inflationPerSecond <= getInflationForYear(0))\n    /// ==> maxBond == (inflationPerSecond * _epochLen * mapEpochTokenomics[1].epochPoint.maxBondFraction) / 100;\n    function initializeTokenomics(\n        address _olas,\n        address _treasury,\n        address _depository,\n        address _dispenser,\n        address _ve,\n        uint256 _epochLen,\n        address _componentRegistry,\n        address _agentRegistry,\n        address _serviceRegistry,\n        address _donatorBlacklist\n    ) external\n    {\n        // Check if the contract is already initialized\n        if (owner != address(0)) {\n            revert AlreadyInitialized();\n        }\n\n        // Check for at least one zero contract address\n        if (_olas == address(0) || _treasury == address(0) || _depository == address(0) || _dispenser == address(0) ||\n            _ve == address(0) || _componentRegistry == address(0) || _agentRegistry == address(0) ||\n            _serviceRegistry == address(0)) {\n            revert ZeroAddress();\n        }\n\n        // Initialize storage variables\n        owner = msg.sender;\n        _locked = 1;\n        epsilonRate = 1e17;\n        veOLASThreshold = 10_000e18;\n\n        // Check that the epoch length has at least a practical minimal value\n        if (uint32(_epochLen) < MIN_EPOCH_LENGTH) {\n            revert LowerThan(_epochLen, MIN_EPOCH_LENGTH);\n        }\n\n        // Check that the epoch length is not bigger than one year\n        if (uint32(_epochLen) > ONE_YEAR) {\n            revert Overflow(_epochLen, ONE_YEAR);\n        }\n\n        // Assign other input variables\n        olas = _olas;\n        treasury = _treasury;\n        depository = _depository;\n        dispenser = _dispenser;\n        ve = _ve;\n        epochLen = uint32(_epochLen);\n        componentRegistry = _componentRegistry;\n        agentRegistry = _agentRegistry;\n        serviceRegistry = _serviceRegistry;\n        donatorBlacklist = _donatorBlacklist;\n\n        // Time launch of the OLAS contract\n        uint256 _timeLaunch = IOLAS(_olas).timeLaunch();\n        // Check that the tokenomics contract is initialized no later than one year after the OLAS token is deployed\n        if (block.timestamp >= (_timeLaunch + ONE_YEAR)) {\n            revert Overflow(_timeLaunch + ONE_YEAR, block.timestamp);\n        }\n        // Seconds left in the deployment year for the zero year inflation schedule\n        // This value is necessary since it is different from a precise one year time, as the OLAS contract started earlier\n        uint256 zeroYearSecondsLeft = uint32(_timeLaunch + ONE_YEAR - block.timestamp);\n        // Calculating initial inflation per second: (mintable OLAS from getInflationForYear(0)) / (seconds left in a year)\n        // Note that we lose precision here dividing by the number of seconds right away, but to avoid complex calculations\n        // later we consider it less error-prone and sacrifice at most 6 insignificant digits (or 1e-12) of OLAS per year\n        uint256 _inflationPerSecond = getInflationForYear(0) / zeroYearSecondsLeft;\n        inflationPerSecond = uint96(_inflationPerSecond);\n        timeLaunch = uint32(_timeLaunch);\n\n        // The initial epoch start time is the end time of the zero epoch\n        mapEpochTokenomics[0].epochPoint.endTime = uint32(block.timestamp);\n\n        // The epoch counter starts from 1\n        epochCounter = 1;\n        TokenomicsPoint storage tp = mapEpochTokenomics[1];\n\n        // Setting initial parameters and fractions\n        devsPerCapital = 1e18;\n        tp.epochPoint.idf = 1e18;\n\n        // Reward fractions\n        // 0 stands for components and 1 for agents\n        // The initial target is to distribute around 2/3 of incentives reserved to fund owners of the code\n        // for components royalties and 1/3 for agents royalties\n        tp.unitPoints[0].rewardUnitFraction = 83;\n        tp.unitPoints[1].rewardUnitFraction = 17;\n        // tp.epochPoint.rewardTreasuryFraction is essentially equal to zero\n\n        // We consider a unit of code as n agents or m components.\n        // Initially we consider 1 unit of code as either 2 agents or 1 component.\n        // E.g. if we have 2 profitable components and 2 profitable agents, this means there are (2 x 2.0 + 2 x 1.0) / 3 = 2\n        // units of code.\n        // We assume that during one epoch the developer can contribute with one piece of code (1 component or 2 agents)\n        codePerDev = 1e18;\n\n        // Top-up fractions\n        uint256 _maxBondFraction = 50;\n        tp.epochPoint.maxBondFraction = uint8(_maxBondFraction);\n        tp.unitPoints[0].topUpUnitFraction = 41;\n        tp.unitPoints[1].topUpUnitFraction = 9;\n\n        // Calculate initial effectiveBond based on the maxBond during the first epoch\n        // maxBond = inflationPerSecond * epochLen * maxBondFraction / 100\n        uint256 _maxBond = (_inflationPerSecond * _epochLen * _maxBondFraction) / 100;\n        maxBond = uint96(_maxBond);\n        effectiveBond = uint96(_maxBond);\n    }\n\n    /// @dev Gets the tokenomics implementation contract address.\n    /// @return implementation Tokenomics implementation contract address.\n    function tokenomicsImplementation() external view returns (address implementation) {\n        assembly {\n            implementation := sload(PROXY_TOKENOMICS)\n        }\n    }\n\n    /// @dev Changes the tokenomics implementation contract address.\n    /// @notice Make sure the implementation contract has a function to change the implementation.\n    /// @param implementation Tokenomics implementation contract address.\n    /// #if_succeeds {:msg \"new implementation\"} implementation == tokenomicsImplementation();\n    function changeTokenomicsImplementation(address implementation) external {\n        // Check for the contract ownership\n        if (msg.sender != owner) {\n            revert OwnerOnly(msg.sender, owner);\n        }\n\n        // Check for the zero address\n        if (implementation == address(0)) {\n            revert ZeroAddress();\n        }\n\n        // Store the implementation address under the designated storage slot\n        assembly {\n            sstore(PROXY_TOKENOMICS, implementation)\n        }\n        emit TokenomicsImplementationUpdated(implementation);\n    }\n\n    /// @dev Changes the owner address.\n    /// @param newOwner Address of a new owner.\n    function changeOwner(address newOwner) external {\n        // Check for the contract ownership\n        if (msg.sender != owner) {\n            revert OwnerOnly(msg.sender, owner);\n        }\n\n        // Check for the zero address\n        if (newOwner == address(0)) {\n            revert ZeroAddress();\n        }\n\n        owner = newOwner;\n        emit OwnerUpdated(newOwner);\n    }\n\n    /// @dev Changes various managing contract addresses.\n    /// @param _treasury Treasury address.\n    /// @param _depository Depository address.\n    /// @param _dispenser Dispenser address.\n    function changeManagers(address _treasury, address _depository, address _dispenser) external {\n        // Check for the contract ownership\n        if (msg.sender != owner) {\n            revert OwnerOnly(msg.sender, owner);\n        }\n\n        // Change Treasury contract address\n        if (_treasury != address(0)) {\n            treasury = _treasury;\n            emit TreasuryUpdated(_treasury);\n        }\n        // Change Depository contract address\n        if (_depository != address(0)) {\n            depository = _depository;\n            emit DepositoryUpdated(_depository);\n        }\n        // Change Dispenser contract address\n        if (_dispenser != address(0)) {\n            dispenser = _dispenser;\n            emit DispenserUpdated(_dispenser);\n        }\n    }\n\n    /// @dev Changes registries contract addresses.\n    /// @param _componentRegistry Component registry address.\n    /// @param _agentRegistry Agent registry address.\n    /// @param _serviceRegistry Service registry address.\n    function changeRegistries(address _componentRegistry, address _agentRegistry, address _serviceRegistry) external {\n        // Check for the contract ownership\n        if (msg.sender != owner) {\n            revert OwnerOnly(msg.sender, owner);\n        }\n\n        // Check for registries addresses\n        if (_componentRegistry != address(0)) {\n            componentRegistry = _componentRegistry;\n            emit ComponentRegistryUpdated(_componentRegistry);\n        }\n        if (_agentRegistry != address(0)) {\n            agentRegistry = _agentRegistry;\n            emit AgentRegistryUpdated(_agentRegistry);\n        }\n        if (_serviceRegistry != address(0)) {\n            serviceRegistry = _serviceRegistry;\n            emit ServiceRegistryUpdated(_serviceRegistry);\n        }\n    }\n\n    /// @dev Changes donator blacklist contract address.\n    /// @notice DonatorBlacklist contract can be disabled by setting its address to zero.\n    /// @param _donatorBlacklist DonatorBlacklist contract address.\n    function changeDonatorBlacklist(address _donatorBlacklist) external {\n        // Check for the contract ownership\n        if (msg.sender != owner) {\n            revert OwnerOnly(msg.sender, owner);\n        }\n\n        donatorBlacklist = _donatorBlacklist;\n        emit DonatorBlacklistUpdated(_donatorBlacklist);\n    }\n\n    /// @dev Changes tokenomics parameters.\n    /// @notice Parameter values are not updated for those that are passed as zero or out of defined bounds.\n    /// @param _devsPerCapital Number of valuable devs can be paid per units of capital per epoch.\n    /// @param _codePerDev Number of units of useful code that can be built by a developer during one epoch.\n    /// @param _epsilonRate Epsilon rate that contributes to the interest rate value.\n    /// @param _epochLen New epoch length.\n    /// #if_succeeds {:msg \"ep is correct endTime\"} epochCounter > 1\n    /// ==> mapEpochTokenomics[epochCounter - 1].epochPoint.endTime > mapEpochTokenomics[epochCounter - 2].epochPoint.endTime;\n    /// #if_succeeds {:msg \"epochLen\"} old(_epochLen > MIN_EPOCH_LENGTH && _epochLen <= ONE_YEAR && epochLen != _epochLen) ==> nextEpochLen == _epochLen;\n    /// #if_succeeds {:msg \"devsPerCapital\"} _devsPerCapital > MIN_PARAM_VALUE && _devsPerCapital <= type(uint72).max ==> devsPerCapital == _devsPerCapital;\n    /// #if_succeeds {:msg \"codePerDev\"} _codePerDev > MIN_PARAM_VALUE && _codePerDev <= type(uint72).max ==> codePerDev == _codePerDev;\n    /// #if_succeeds {:msg \"epsilonRate\"} _epsilonRate > 0 && _epsilonRate < 17e18 ==> epsilonRate == _epsilonRate;\n    /// #if_succeeds {:msg \"veOLASThreshold\"} _veOLASThreshold > 0 && _veOLASThreshold <= type(uint96).max ==> nextVeOLASThreshold == _veOLASThreshold;\n    function changeTokenomicsParameters(\n        uint256 _devsPerCapital,\n        uint256 _codePerDev,\n        uint256 _epsilonRate,\n        uint256 _epochLen,\n        uint256 _veOLASThreshold\n    ) external\n    {\n        // Check for the contract ownership\n        if (msg.sender != owner) {\n            revert OwnerOnly(msg.sender, owner);\n        }\n\n        // devsPerCapital is the part of the IDF calculation and thus its change will be accounted for in the next epoch\n        if (uint72(_devsPerCapital) > MIN_PARAM_VALUE) {\n            devsPerCapital = uint72(_devsPerCapital);\n        } else {\n            // This is done in order not to pass incorrect parameters into the event\n            _devsPerCapital = devsPerCapital;\n        }\n\n        // devsPerCapital is the part of the IDF calculation and thus its change will be accounted for in the next epoch\n        if (uint72(_codePerDev) > MIN_PARAM_VALUE) {\n            codePerDev = uint72(_codePerDev);\n        } else {\n            // This is done in order not to pass incorrect parameters into the event\n            _codePerDev = codePerDev;\n        }\n\n        // Check the epsilonRate value for idf to fit in its size\n        // 2^64 - 1 < 18.5e18, idf is equal at most 1 + epsilonRate < 18e18, which fits in the variable size\n        // epsilonRate is the part of the IDF calculation and thus its change will be accounted for in the next epoch\n        if (_epsilonRate > 0 && _epsilonRate <= 17e18) {\n            epsilonRate = uint64(_epsilonRate);\n        } else {\n            _epsilonRate = epsilonRate;\n        }\n\n        // Check for the epochLen value to change\n        if (uint32(_epochLen) >= MIN_EPOCH_LENGTH && uint32(_epochLen) <= ONE_YEAR) {\n            nextEpochLen = uint32(_epochLen);\n        } else {\n            _epochLen = epochLen;\n        }\n\n        // Adjust veOLAS threshold for the next epoch\n        if (uint96(_veOLASThreshold) > 0) {\n            nextVeOLASThreshold = uint96(_veOLASThreshold);\n        } else {\n            _veOLASThreshold = veOLASThreshold;\n        }\n\n        // Set the flag that tokenomics parameters are requested to be updated (1st bit is set to one)\n        tokenomicsParametersUpdated = tokenomicsParametersUpdated | 0x01;\n        emit TokenomicsParametersUpdateRequested(epochCounter + 1, _devsPerCapital, _codePerDev, _epsilonRate, _epochLen,\n            _veOLASThreshold);\n    }\n\n    /// @dev Sets incentive parameter fractions.\n    /// @param _rewardComponentFraction Fraction for component owner rewards funded by ETH donations.\n    /// @param _rewardAgentFraction Fraction for agent owner rewards funded by ETH donations.\n    /// @param _maxBondFraction Fraction for the maxBond that depends on the OLAS inflation.\n    /// @param _topUpComponentFraction Fraction for component owners OLAS top-up.\n    /// @param _topUpAgentFraction Fraction for agent owners OLAS top-up.\n    /// #if_succeeds {:msg \"maxBond\"} mapEpochTokenomics[epochCounter + 1].epochPoint.maxBondFraction == _maxBondFraction;\n    function changeIncentiveFractions(\n        uint256 _rewardComponentFraction,\n        uint256 _rewardAgentFraction,\n        uint256 _maxBondFraction,\n        uint256 _topUpComponentFraction,\n        uint256 _topUpAgentFraction\n    ) external\n    {\n        // Check for the contract ownership\n        if (msg.sender != owner) {\n            revert OwnerOnly(msg.sender, owner);\n        }\n\n        // Check that the sum of fractions is 100%\n        if (_rewardComponentFraction + _rewardAgentFraction > 100) {\n            revert WrongAmount(_rewardComponentFraction + _rewardAgentFraction, 100);\n        }\n\n        // Same check for top-up fractions\n        if (_maxBondFraction + _topUpComponentFraction + _topUpAgentFraction > 100) {\n            revert WrongAmount(_maxBondFraction + _topUpComponentFraction + _topUpAgentFraction, 100);\n        }\n\n        // All the adjustments will be accounted for in the next epoch\n        uint256 eCounter = epochCounter + 1;\n        TokenomicsPoint storage tp = mapEpochTokenomics[eCounter];\n        // 0 stands for components and 1 for agents\n        tp.unitPoints[0].rewardUnitFraction = uint8(_rewardComponentFraction);\n        tp.unitPoints[1].rewardUnitFraction = uint8(_rewardAgentFraction);\n        // Rewards are always distributed in full: the leftovers will be allocated to treasury\n        tp.epochPoint.rewardTreasuryFraction = uint8(100 - _rewardComponentFraction - _rewardAgentFraction);\n\n        tp.epochPoint.maxBondFraction = uint8(_maxBondFraction);\n        tp.unitPoints[0].topUpUnitFraction = uint8(_topUpComponentFraction);\n        tp.unitPoints[1].topUpUnitFraction = uint8(_topUpAgentFraction);\n\n        // Set the flag that incentive fractions are requested to be updated (2nd bit is set to one)\n        tokenomicsParametersUpdated = tokenomicsParametersUpdated | 0x02;\n        emit IncentiveFractionsUpdateRequested(eCounter, _rewardComponentFraction, _rewardAgentFraction,\n            _maxBondFraction, _topUpComponentFraction, _topUpAgentFraction);\n    }\n\n    /// @dev Reserves OLAS amount from the effective bond to be minted during a bond program.\n    /// @notice Programs exceeding the limit of the effective bond are not allowed.\n    /// @param amount Requested amount for the bond program.\n    /// @return success True if effective bond threshold is not reached.\n    /// #if_succeeds {:msg \"effectiveBond\"} old(effectiveBond) > amount ==> effectiveBond == old(effectiveBond) - amount;\n    function reserveAmountForBondProgram(uint256 amount) external returns (bool success) {\n        // Check for the depository access\n        if (depository != msg.sender) {\n            revert ManagerOnly(msg.sender, depository);\n        }\n\n        // Effective bond must be bigger than the requested amount\n        uint256 eBond = effectiveBond;\n        if (eBond >= amount) {\n            // The effective bond value is adjusted with the amount that is reserved for bonding\n            // The unrealized part of the bonding amount will be returned when the bonding program is closed\n            eBond -= amount;\n            effectiveBond = uint96(eBond);\n            success = true;\n            emit EffectiveBondUpdated(eBond);\n        }\n    }\n\n    /// @dev Refunds unused bond program amount when the program is closed.\n    /// @param amount Amount to be refunded from the closed bond program.\n    /// #if_succeeds {:msg \"effectiveBond\"} old(effectiveBond + amount) <= type(uint96).max ==> effectiveBond == old(effectiveBond) + amount;\n    function refundFromBondProgram(uint256 amount) external {\n        // Check for the depository access\n        if (depository != msg.sender) {\n            revert ManagerOnly(msg.sender, depository);\n        }\n\n        uint256 eBond = effectiveBond + amount;\n        // This scenario is not realistically possible. It is only possible when closing the bonding program\n        // with the effectiveBond value close to uint96 max\n        if (eBond > type(uint96).max) {\n            revert Overflow(eBond, type(uint96).max);\n        }\n        effectiveBond = uint96(eBond);\n        emit EffectiveBondUpdated(eBond);\n    }\n\n    /// @dev Finalizes epoch incentives for a specified component / agent Id.\n    /// @param epochNum Epoch number to finalize incentives for.\n    /// @param unitType Unit type (component / agent).\n    /// @param unitId Unit Id.\n    function _finalizeIncentivesForUnitId(uint256 epochNum, uint256 unitType, uint256 unitId) internal {\n        // Gets the overall amount of unit rewards for the unit's last epoch\n        // The pendingRelativeReward can be zero if the rewardUnitFraction was zero in the first place"
    }
  ]
}