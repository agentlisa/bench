{
  "Title": "[G-10] `creatorsAddress != address(0)` check not required in buyToken()",
  "Content": "\nThe check below is from the buyToken() function (see [here](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/ERC20TokenEmitter.sol#L201)). The second condition `creatorsAddress != address(0)` can be removed since `creatorsAddress` can never be the zero address. This is because function [setCreatorsAddress()](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/ERC20TokenEmitter.sol#L310) implements this check already.\n\n```solidity\nFile: ERC20TokenEmitter.sol\n205:         if (totalTokensForCreators > 0 && creatorsAddress != address(0)) {\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-12-revolutionprotocol",
  "Code": [
    {
      "filename": "packages/revolution/src/ERC20TokenEmitter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport { TokenEmitterRewards } from \"@collectivexyz/protocol-rewards/src/abstract/TokenEmitter/TokenEmitterRewards.sol\";\nimport { Ownable2StepUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\n\nimport { VRGDAC } from \"./libs/VRGDAC.sol\";\nimport { toDaysWadUnsafe } from \"./libs/SignedWadMath.sol\";\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport { NontransferableERC20Votes } from \"./NontransferableERC20Votes.sol\";\nimport { IERC20TokenEmitter } from \"./interfaces/IERC20TokenEmitter.sol\";\n\nimport { IRevolutionBuilder } from \"./interfaces/IRevolutionBuilder.sol\";\n\ncontract ERC20TokenEmitter is\n    IERC20TokenEmitter,\n    ReentrancyGuardUpgradeable,\n    TokenEmitterRewards,\n    Ownable2StepUpgradeable,\n    PausableUpgradeable\n{\n    // treasury address to pay funds to\n    address public treasury;\n\n    // The token that is being minted.\n    NontransferableERC20Votes public token;\n\n    // The VRGDA contract\n    VRGDAC public vrgdac;\n\n    // solhint-disable-next-line not-rely-on-time\n    uint256 public startTime;\n\n    /**\n     * @notice A running total of the amount of tokens emitted.\n     */\n    int256 public emittedTokenWad;\n\n    // The split of the purchase that is reserved for the creator of the Verb in basis points\n    uint256 public creatorRateBps;\n\n    // The split of (purchase proceeds * creatorRate) that is sent to the creator as ether in basis points\n    uint256 public entropyRateBps;\n\n    // The account or contract to pay the creator reward to\n    address public creatorsAddress;\n\n    ///                                                          ///\n    ///                         IMMUTABLES                       ///\n    ///                                                          ///\n\n    /// @notice The contract upgrade manager\n    IRevolutionBuilder private immutable manager;\n\n    ///                                                          ///\n    ///                         CONSTRUCTOR                      ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    /// @param _protocolRewards The protocol rewards contract address\n    /// @param _protocolFeeRecipient The protocol fee recipient address\n    constructor(\n        address _manager,\n        address _protocolRewards,\n        address _protocolFeeRecipient\n    ) payable TokenEmitterRewards(_protocolRewards, _protocolFeeRecipient) initializer {\n        manager = IRevolutionBuilder(_manager);\n    }\n\n    ///                                                          ///\n    ///                         INITIALIZER                      ///\n    ///                                                          ///\n\n    /**\n     * @notice Initialize the token emitter\n     * @param _initialOwner The initial owner of the token emitter\n     * @param _erc20Token The ERC-20 token contract address\n     * @param _vrgdac The VRGDA contract address\n     * @param _treasury The treasury address to pay funds to\n     * @param _creatorsAddress The address to pay the creator reward to\n     */\n    function initialize(\n        address _initialOwner,\n        address _erc20Token,\n        address _treasury,\n        address _vrgdac,\n        address _creatorsAddress\n    ) external initializer {\n        require(msg.sender == address(manager), \"Only manager can initialize\");\n\n        __Pausable_init();\n        __ReentrancyGuard_init();\n\n        require(_treasury != address(0), \"Invalid treasury address\");\n\n        // Set up ownable\n        __Ownable_init(_initialOwner);\n\n        treasury = _treasury;\n        creatorsAddress = _creatorsAddress;\n        vrgdac = VRGDAC(_vrgdac);\n        token = NontransferableERC20Votes(_erc20Token);\n        startTime = block.timestamp;\n    }\n\n    function _mint(address _to, uint256 _amount) private {\n        token.mint(_to, _amount);\n    }\n\n    function totalSupply() public view returns (uint) {\n        // returns total supply issued so far\n        return token.totalSupply();\n    }\n\n    function decimals() public view returns (uint8) {\n        // returns decimals\n        return token.decimals();\n    }\n\n    function balanceOf(address _owner) public view returns (uint) {\n        // returns balance of address\n        return token.balanceOf(_owner);\n    }\n\n    /**\n     * @notice Pause the contract.\n     * @dev This function can only be called by the owner when the\n     * contract is unpaused.\n     */\n    function pause() external override onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @notice Unpause the token emitter.\n     * @dev This function can only be called by the owner when the\n     * contract is paused.\n     */\n    function unpause() external override onlyOwner {\n        _unpause();\n    }\n\n    /**\n     * @notice A payable function that allows a user to buy tokens for a list of addresses and a list of basis points to split the token purchase between.\n     * @param addresses The addresses to send purchased tokens to.\n     * @param basisPointSplits The basis points of the purchase to send to each address.\n     * @param protocolRewardsRecipients The addresses to pay the builder, purchaseRefferal, and deployer rewards to\n     * @return tokensSoldWad The amount of tokens sold in wad units.\n     */\n    function buyToken(\n        address[] calldata addresses,\n        uint[] calldata basisPointSplits,\n        ProtocolRewardAddresses calldata protocolRewardsRecipients\n    ) public payable nonReentrant whenNotPaused returns (uint256 tokensSoldWad) {\n        //prevent treasury from paying itself\n        require(msg.sender != treasury && msg.sender != creatorsAddress, \"Funds recipient cannot buy tokens\");\n\n        require(msg.value > 0, \"Must send ether\");\n        // ensure the same number of addresses and bps\n        require(addresses.length == basisPointSplits.length, \"Parallel arrays required\");\n\n        // Get value left after protocol rewards\n        uint256 msgValueRemaining = _handleRewardsAndGetValueToSend(\n            msg.value,\n            protocolRewardsRecipients.builder,\n            protocolRewardsRecipients.purchaseReferral,\n            protocolRewardsRecipients.deployer\n        );\n\n        //Share of purchase amount to send to treasury\n        uint256 toPayTreasury = (msgValueRemaining * (10_000 - creatorRateBps)) / 10_000;\n\n        //Share of purchase amount to reserve for creators\n        //Ether directly sent to creators\n        uint256 creatorDirectPayment = ((msgValueRemaining - toPayTreasury) * entropyRateBps) / 10_000;\n        //Tokens to emit to creators\n        int totalTokensForCreators = ((msgValueRemaining - toPayTreasury) - creatorDirectPayment) > 0\n            ? getTokenQuoteForEther((msgValueRemaining - toPayTreasury) - creatorDirectPayment)\n            : int(0);\n\n        // Tokens to emit to buyers\n        int totalTokensForBuyers = toPayTreasury > 0 ? getTokenQuoteForEther(toPayTreasury) : int(0);\n\n        //Transfer ETH to treasury and update emitted\n        emittedTokenWad += totalTokensForBuyers;\n        if (totalTokensForCreators > 0) emittedTokenWad += totalTokensForCreators;\n\n        //Deposit funds to treasury\n        (bool success, ) = treasury.call{ value: toPayTreasury }(new bytes(0));\n        require(success, \"Transfer failed.\");\n\n        //Transfer ETH to creators\n        if (creatorDirectPayment > 0) {\n            (success, ) = creatorsAddress.call{ value: creatorDirectPayment }(new bytes(0));\n            require(success, \"Transfer failed.\");\n        }\n\n        //Mint tokens for creators\n        if (totalTokensForCreators > 0 && creatorsAddress != address(0)) {\n            _mint(creatorsAddress, uint256(totalTokensForCreators));\n        }\n\n        uint256 bpsSum = 0;\n\n        //Mint tokens to buyers\n\n        for (uint256 i = 0; i < addresses.length; i++) {\n            if (totalTokensForBuyers > 0) {\n                // transfer tokens to address\n                _mint(addresses[i], uint256((totalTokensForBuyers * int(basisPointSplits[i])) / 10_000));\n            }\n            bpsSum += basisPointSplits[i];\n        }\n\n        require(bpsSum == 10_000, \"bps must add up to 10_000\");\n\n        emit PurchaseFinalized(\n            msg.sender,\n            msg.value,\n            toPayTreasury,\n            msg.value - msgValueRemaining,\n            uint256(totalTokensForBuyers),\n            uint256(totalTokensForCreators),\n            creatorDirectPayment\n        );\n\n        return uint256(totalTokensForBuyers);\n    }\n\n    /**\n     * @notice Returns the amount of wei that would be spent to buy an amount of tokens. Does not take into account the protocol rewards.\n     * @param amount the amount of tokens to buy.\n     * @return spentY The cost in wei of the token purchase.\n     */\n    function buyTokenQuote(uint256 amount) public view returns (int spentY) {\n        require(amount > 0, \"Amount must be greater than 0\");\n        // Note: By using toDaysWadUnsafe(block.timestamp - startTime) we are establishing that 1 \"unit of time\" is 1 day.\n        // solhint-disable-next-line not-rely-on-time\n        return\n            vrgdac.xToY({\n                timeSinceStart: toDaysWadUnsafe(block.timestamp - startTime),\n                sold: emittedTokenWad,\n                amount: int(amount)\n            });\n    }\n\n    /**\n     * @notice Returns the amount of tokens that would be emitted for an amount of wei. Does not take into account the protocol rewards.\n     * @param etherAmount the payment amount in wei.\n     * @return gainedX The amount of tokens that would be emitted for the payment amount.\n     */\n    function getTokenQuoteForEther(uint256 etherAmount) public view returns (int gainedX) {\n        require(etherAmount > 0, \"Ether amount must be greater than 0\");\n        // Note: By using toDaysWadUnsafe(block.timestamp - startTime) we are establishing that 1 \"unit of time\" is 1 day.\n        // solhint-disable-next-line not-rely-on-time\n        return\n            vrgdac.yToX({\n                timeSinceStart: toDaysWadUnsafe(block.timestamp - startTime),\n                sold: emittedTokenWad,\n                amount: int(etherAmount)\n            });\n    }\n\n    /**\n     * @notice Returns the amount of tokens that would be emitted for the payment amount, taking into account the protocol rewards.\n     * @param paymentAmount the payment amount in wei.\n     * @return gainedX The amount of tokens that would be emitted for the payment amount.\n     */\n    function getTokenQuoteForPayment(uint256 paymentAmount) external view returns (int gainedX) {\n        require(paymentAmount > 0, \"Payment amount must be greater than 0\");\n        // Note: By using toDaysWadUnsafe(block.timestamp - startTime) we are establishing that 1 \"unit of time\" is 1 day.\n        // solhint-disable-next-line not-rely-on-time\n        return\n            vrgdac.yToX({\n                timeSinceStart: toDaysWadUnsafe(block.timestamp - startTime),\n                sold: emittedTokenWad,\n                amount: int(((paymentAmount - computeTotalReward(paymentAmount)) * (10_000 - creatorRateBps)) / 10_000)\n            });\n    }\n\n    /**\n     * @notice Set the split of (purchase * creatorRate) that is sent to the creator as ether in basis points.\n     * @dev Only callable by the owner.\n     * @param _entropyRateBps New entropy rate in basis points.\n     */\n    function setEntropyRateBps(uint256 _entropyRateBps) external onlyOwner {\n        require(_entropyRateBps <= 10_000, \"Entropy rate must be less than or equal to 10_000\");\n\n        emit EntropyRateBpsUpdated(entropyRateBps = _entropyRateBps);\n    }\n\n    /**\n     * @notice Set the split of the payment that is reserved for creators in basis points.\n     * @dev Only callable by the owner.\n     * @param _creatorRateBps New creator rate in basis points.\n     */\n    function setCreatorRateBps(uint256 _creatorRateBps) external onlyOwner {\n        require(_creatorRateBps <= 10_000, \"Creator rate must be less than or equal to 10_000\");\n\n        emit CreatorRateBpsUpdated(creatorRateBps = _creatorRateBps);\n    }\n\n    /**\n     * @notice Set the creators address to pay the creatorRate to. Can be a contract.\n     * @dev Only callable by the owner.\n     */\n    function setCreatorsAddress(address _creatorsAddress) external override onlyOwner nonReentrant {\n        require(_creatorsAddress != address(0), \"Invalid address\");\n\n        emit CreatorsAddressUpdated(creatorsAddress = _creatorsAddress);\n    }\n}"
    }
  ]
}