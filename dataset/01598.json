{
  "Title": "M-6: Malicious user can control premium emissions to steal margin from other traders",
  "Content": "# Issue M-6: Malicious user can control premium emissions to steal margin from other traders \n\nSource: https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/87 \n\n## Found by \ndirk\\_y\n## Summary\nA malicious user can force premiums to be applied in a positive direction for their positions. They can effectively steal margin from other traders that have filled the other side of their positions.\n\n## Vulnerability Detail\nThis vulnerability stems from how the premiums are calculated when `settleFunding` is called in `AMM.sol`:\n\n```solidity\nint256 premium = getMarkPriceTwap() - underlyingPrice;\n```\n\nEffectively, the premium for a position is calculated based on the difference between the perpetual maker TWAP and the oracle TWAP. Under the hood, `getMarkPriceTwap` calls `_calcTwap`, which calculates the TWAP price from the last hour to the current block timestamp:\n\n```solidity\n        uint256 currentPeriodStart = (_blockTimestamp() / spotPriceTwapInterval) * spotPriceTwapInterval;\n        uint256 lastPeriodStart = currentPeriodStart - spotPriceTwapInterval;\n\n        // If there is no trade in the last period, return the last trade price\n        if (markPriceTwapData.lastTimestamp <= lastPeriodStart) {\n            return markPriceTwapData.lastPrice;\n        }\n\n        /**\n        * check if there is any trade after currentPeriodStart\n        * since this function will not be called before the nextFundingTime,\n        * we can use the lastPeriodAccumulator to calculate the twap if there is a trade after currentPeriodStart\n        */\n        if (markPriceTwapData.lastTimestamp >= currentPeriodStart) {\n            // use the lastPeriodAccumulator to calculate the twap\n            twap = markPriceTwapData.lastPeriodAccumulator / spotPriceTwapInterval;\n        } else {\n            // use the accumulator to calculate the twap\n            uint256 currentAccumulator = markPriceTwapData.accumulator + (currentPeriodStart - markPriceTwapData.lastTimestamp) * markPriceTwapData.lastPrice;\n            twap = currentAccumulator / spotPriceTwapInterval;\n        }\n```\n\nThis method works closely in conjunction with `_updateTWAP` which is called every time a new position is opened based on the fill price. I'll talk more about his in the \"Recommendation\" section, but the core issue is that too much weight is placed on the last price that was filled, along with the fact the user can open uncapped positions. As can be seen from the `_calcTwap` method above, if there has not been a recently opened position, then the TWAP is determined as the last filled price. And naturally, a time weighted price isn't weighted by the size of a fill as well, so the size of the last fill has no impact.\n\nAs a result of this, a malicious user can place orders (which should then be executed by the validators) at a price that maximises the difference between the market TWAP and the oracle TWAP in order to maximise the premiums generated in the market. If the malicious user opens up a large enough position, the premiums generated exceed the taker/maker fees for opening positions. And since the same user can place orders for both sides of the market, they do not need to increase their margin requirement over time in order to meet the minimum margin requirements. Effectively the user is able to generate free revenue assuming the price of the underlying asset doesn't significantly deviate in the opposite direction of the large position held by the user.\n\nBelow is a diff to the existing test suite with a test case that shows how a malicious user could control premiums to make a profit. It can be run with `forge test -vvv --match-path test/foundry/OrderBook.t.sol`:\n\n```diff\ndiff --git a/hubble-protocol/test/foundry/OrderBook.t.sol b/hubble-protocol/test/foundry/OrderBook.t.sol\nindex b4dafdf..f5d36b2 100644\n--- a/hubble-protocol/test/foundry/OrderBook.t.sol\n+++ b/hubble-protocol/test/foundry/OrderBook.t.sol\n@@ -228,6 +228,60 @@ contract OrderBookTests is Utils {\n         assertPositions(bob, -size, quote, 0, quote * 1e18 / stdMath.abs(size));\n     }\n \n+    function testUserCanControlEmissions() public {\n+        uint256 price = 1e6;\n+        oracle.setUnderlyingPrice(address(wavax), int(uint(price)));\n+\n+        // Calculate how much margin required for 100x MIN_SIZE\n+        uint256 marginRequired = orderBook.getRequiredMargin(100 * MIN_SIZE, price) * 1e18 / uint(defaultWethPrice) + 1e10; // required weth margin in 1e18, add 1e10 for any precision loss\n+        \n+        // Let's say Alice is our malicious user, and Bob is a normal user\n+        addMargin(alice, marginRequired, 1, address(weth));\n+        addMargin(bob, marginRequired, 1, address(weth));\n+\n+        // Alice places a large legitimate long order that is matched with a short order from Bob\n+        placeAndExecuteOrder(0, aliceKey, bobKey, MIN_SIZE * 90, price, true, false, MIN_SIZE * 90, false);\n+\n+        // Alice's free margin is now pretty low\n+        int256 availabeMargin = marginAccount.getAvailableMargin(alice);\n+        assertApproxEqRel(availabeMargin, 200410, 0.1e18); // Assert within 10%\n+\n+        // Calculate what's the least we could fill an order for given the oracle price\n+        uint256 spreadLimit = amm.maxOracleSpreadRatio();\n+        uint minPrice = price * (1e6 - spreadLimit) / 1e6;\n+\n+        // Alice can fill both sides of an order at the minimum fill price calculated above, with the minimum size\n+        // Alice would place such orders (and hopefully have them executed) just after anyone else makes an order in a period (1 hour)\n+        // The goal for Alice is to keep the perpetual TWAP as low as possible vs the oracle TWAP (since she holds a large long position)\n+        // In quiet market conditions Alice just has to make sure she's the last person to fill\n+        // In busy market conditions Alice would fill an order immediately after anyone else fills an order\n+        // In this test Alice fills an order every 2 periods, but in reality, if nobody was trading then Alice wouldn't have to do anything provided she was the last filler\n+        for (uint i = 0; i < 100; i++) {\n+            uint256 currentPeriodStart = (block.timestamp / 1 hours) * 1 hours;\n+\n+            // Warp to before the end of the period\n+            vm.warp(currentPeriodStart + 3590);\n+            \n+            // Place and execute both sides of an order as Alice\n+            // Alice can do this because once both sides of the order are executed, the effect to her free margin is 0\n+            // As mentioned above, Alice would place such orders every time after another order is executed\n+            placeAndExecuteOrder(0, aliceKey, aliceKey, MIN_SIZE, minPrice, true, false, MIN_SIZE, false);\n+            \n+            // Warp to the start of the next period\n+            vm.warp(currentPeriodStart + (3600 * 2) + 10);\n+            \n+            // Funding is settled. This calculates the premium emissions by comparing the perpetual twap with the oracle twap\n+            orderBook.settleFunding();\n+        }\n+\n+        // Alice's margin is now significantly higher (after just 200 hours) because she's been pushing the premiums in her direction\n+        availabeMargin = marginAccount.getAvailableMargin(alice);\n+        assertApproxEqRel(availabeMargin, 716442910, 0.1e18); // Assert within 10%\n+\n+    }\n+\n     function testLiquidateAndExecuteOrder(uint64 price, uint120 size_) public {\n         vm.assume(price > 10 && size_ != 0);\n         oracle.setUnderlyingPrice(address(wavax), int(uint(price)));\n\n``` \n\n## Impact\nA user can effectively steal funds from other traders that are filling the other side of their positions. The larger the position the malicious user is able to fill and the longer the period, the more funds can be credited to the malicious user's margin account.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/AMM.sol#L255-L258\nhttps://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/AMM.sol#L501-L503\n\n## Tool used\nManual Review\n\n## Recommendation\nI originally thought the best way to mitigate this kind of attack is to scale the TWAP calculation based on the filled amount vs the total fill amount of the whole market. However the downside with this approach is that the fill amount will perpetually increase (given it's a perpetual market after all!) and so the market TWAP deviations from the oracle TWAP would decrease and so the premium emissions would also decrease over time. This could be argued as a feature in that early users receive a larger premium than later users.\n\nUpon further thought I think the best way to prevent this kind of attack is simply to disincentivise the malicious user from doing so; by making this a net-loss situation. This can be done with a combination of the following:\n\n- Increasing minimum order size\n- Increasing trader/maker fees\n- Introducing another fixed fee per order (rather than only variable rate fees)\n- Capping the maximum position size (both long and short)\n- Reducing the maximum price deviation of fill prices from oracle price\n- Increasing the minimum margin requirements\n\nThis will vary per perpetual market, but the key thing that needs to be accomplished is that the cost to a user to place orders to control the market TWAP is greater than the premium that can be obtained from their position. This will also require some estimates as to how frequently users are going to be placing orders. If orders are relatively infrequent then increasing the TWAP calculation from 1 hour will also help with this.\n\nIt is also worth considering whether the following lines in `_calcTwap` are overly weighted towards the last fill price:\n\n```solidity\n       // If there is no trade in the last period, return the last trade price\n        if (markPriceTwapData.lastTimestamp <= lastPeriodStart) {\n            return markPriceTwapData.lastPrice;\n        }\n```\n\nYou could make the argument that if no trades have occurred in a significant period of time then the market TWAP should revert back to the oracle TWAP and premium emissions should halt. This could either be after one empty period, or X number of empty periods to be defined by Hubble.\n\nFinally, having a trader able to hold both sides of the same perpetual in the same order makes this attack easier to implement, so it might be worth adding an extra check to prevent this. However it's worth noting the same could be achieved with 2 accounts assuming they alternated the long/short positions between them to avoid excessive margin requirements. So I'm not sure this is strictly necessary.\n\n\n\n## Discussion\n\n**asquare08**\n\nThis is a scenario of low liquidity where no trade has happened in the last 1 hour and if happened, a malicious user has made a trade just after that to move the price up/down. Many other systems might also fail in such a scenario.\nAlso, only validators can match the placed orders and the malicious user will not always get their desired price unless the validator picks their short and long orders. Hence we can change the severity to `medium`\n\n**ctf-sec**\n\nChanged the severity to medium\n\n**MarkuSchick**\n\nEscalate\n\nThe market manipulation the user is referring to is a dublicate of the funding rate manipulation raised in https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/183: \n`2. Manipulation of funding rate`.\n\nAccording to [other comments](https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/183#issuecomment-1643652209) funding rate manipulation is a low severity issue.\n\n**sherlock-admin2**\n\n > Escalate\n> \n> The market manipulation the user is referring to is a dublicate of the funding rate manipulation raised in https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/183: \n> `2. Manipulation of funding rate`.\n> \n> According to [other comments](https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/183#issuecomment-1643652209) funding rate manipulation is a low severity issue.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**djb15**\n\nIn my (biased) opinion I think the medium (not low) severity argument for the other issue is that you would need multiple validators to be malicious which is highly unlikely (**in a normal market environment**).\n\nIn this issue **any** user can open orders to manipulate the funding rate, but this is only possible in low liquidity scenarios which is why it is a medium severity issue.\n\nA single malicious validator would be able to do the same thing as is detailed in this report in low liquidity market environments, which would make these two issues identical. Hence why I think both should be medium severity.\n\n**asquare08**\n\nAs mentioned in the comment [here](https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/87#issuecomment-1640419190), its a valid medium issue. Also refer to [this](https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/183#issuecomment-1665745210) comment\n\n**hrishibhat**\n\nResult:\nMedium\nUnique\nConsidering this a valid medium issue\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [MarkuSchick](https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/87/#issuecomment-1643704754): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/72",
  "Code": [
    {
      "filename": "hubble-protocol/contracts/AMM.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.9;\n\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport { Governable } from \"./legos/Governable.sol\";\nimport { ERC20Detailed, IOracle, IRegistry, IAMM, IClearingHouse, IOrderBook } from \"./Interfaces.sol\";\n\n/**\n * @title Maintains the information about open positions, open notional, oracle price, funding rate, etc.\n * @notice All methods are intended to be called by the ClearingHouse contract.\n * @dev The name \"AMM\" is slightly misleading because this contract doesn't actually have a bonding curve. But it does facilitate trading b/w users. Maybe \"Market\" would been more appropriate.\n * There will be 1 AMM contract for every market i.e. if Hubble Exchange has 3 markets (ETH-PERP, BTC-PERP, AVAX-PERP), there will be 3 AMM contracts.\n*/\ncontract AMM is IAMM, Governable {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    /* ****************** */\n    /*       Structs      */\n    /* ****************** */\n\n    /**\n     * @notice Position struct\n     * @param size is signed, positive for long and negative for short. scaled by 1e18\n     * @param openNotional $ amount that the position was opened at. Always positive. scaled by 1e6\n     * openNotional / size gives the average entry price\n     * @param lastPremiumFraction is the premium fraction at which the pending fundings for the trader have been settled\n     * @param liquidationThreshold is the max position size that can be liquidated in one go. This is to support partial liquidations. scaled by 1e18\n    */\n    struct Position {\n        int256 size;\n        uint256 openNotional;\n        int256 lastPremiumFraction;\n        uint liquidationThreshold;\n    }\n\n    struct TWAPData {\n        uint256 lastPrice;\n        uint256 lastTimestamp;\n        uint256 accumulator;\n        uint256 lastPeriodAccumulator;\n    }\n\n    /* ****************** */\n    /*      Constants     */\n    /* ****************** */\n\n    int256 constant BASE_PRECISION = 1e18;\n    uint256 constant BASE_PRECISION_UINT = 1e18;\n    address public immutable clearingHouse;\n\n    /* ****************** */\n    /*       Storage      */\n    /* ****************** */\n\n    // vars needed in the precompiles should preferably come first and mention the SLOT_# to avoid any potential slot errors\n    TWAPData public markPriceTwapData; // SLOT_1 - SLOT_4 !!! used in precompile !!!\n\n    mapping(address => Position) override public positions; // SLOT_5 !!! used in precompile !!!\n\n    int256 public cumulativePremiumFraction; // SLOT_6 !!! used in precompile !!!\n\n    // maximum allowed % difference between mark price and index price. scaled 6 decimals\n    uint256 public maxOracleSpreadRatio; // SLOT_7 !!! used in precompile !!!\n\n    // maximum allowd % size which can be liquidated in one tx. scaled 6 decimals\n    uint256 public maxLiquidationRatio; // SLOT_8 !!! used in precompile !!!\n\n    /// @notice Min amount of base asset quantity to trade\n    uint256 public minSizeRequirement; // SLOT_9 !!! used in precompile !!!\n\n    IOracle public oracle; // SLOT_10 !!! used in precompile !!!\n\n    address override public underlyingAsset; // SLOT_11 !!! used in precompile !!!\n    string public name;\n\n    uint256 public fundingBufferPeriod;\n    uint256 public nextFundingTime;\n\n    uint256 public longOpenInterestNotional;\n    uint256 public shortOpenInterestNotional;\n    // maximum allowed % difference between mark price and index price before liquidation\n    uint256 public maxLiquidationPriceSpread; // scaled 6 decimals  // SLOT_17 !!! used in precompile !!!\n\n    uint256 public spotPriceTwapInterval;\n    uint256 public fundingPeriod;\n\n    enum Side { LONG, SHORT }\n\n    // maximum hourly funding rate allowed in %\n    int256 public maxFundingRate; // in hourly %,  scaled to 1e6\n\n    uint256[50] private __gap;\n\n    /* ****************** */\n    /*    Storage Ends    */\n    /* ****************** */\n\n    modifier onlyClearingHouse() {\n        require(msg.sender == clearingHouse, \"Only clearingHouse\");\n        _;\n    }\n\n    constructor(address _clearingHouse) {\n        clearingHouse = _clearingHouse;\n    }\n\n    function initialize(\n        string memory _name,\n        address _underlyingAsset,\n        address _oracle,\n        uint _minSizeRequirement,\n        address _governance\n    ) external initializer {\n        name = _name;\n        underlyingAsset = _underlyingAsset;\n        oracle = IOracle(_oracle);\n        minSizeRequirement = _minSizeRequirement;\n        _setGovernace(_governance);\n\n        // values that most likely wouldn't need to change frequently\n        fundingBufferPeriod = 15 minutes;\n        maxOracleSpreadRatio = 20 * 1e4; // 20%\n        maxLiquidationRatio = 25 * 1e4; // 25%\n        maxLiquidationPriceSpread = 1 * 1e4; // 1%\n\n        fundingPeriod = 1 hours;\n        spotPriceTwapInterval = 1 hours;\n    }\n\n    /**\n     * @notice Executes state updates about position modifications, after all the validations have passed at the ClearingHouse/OrderBook level\n     * @param fillAmount != 0 has been validated in orderBook.executeMatchedOrders/liquidateAndExecuteOrder\n     * @param is2ndTrade true if this is the 2nd trade in the same tx. In that case, we update TWAP and return openInterest\n    */\n    function openPosition(IOrderBook.Order memory order, int256 fillAmount, uint256 fulfillPrice, bool is2ndTrade)\n        override\n        external\n        onlyClearingHouse\n        returns (int realizedPnl, bool isPositionIncreased, int size, uint openNotional, uint openInterest)\n    {\n        Position memory position = positions[order.trader];\n        bool isNewPosition = position.size == 0 ? true : false;\n        Side side = fillAmount > 0 ? Side.LONG : Side.SHORT;\n\n        if (isNewPosition || (position.size > 0 ? Side.LONG : Side.SHORT) == side) {\n            // realizedPnl = 0;\n            _increasePosition(order.trader, fillAmount, fulfillPrice);\n            isPositionIncreased = true;\n        } else {\n            (realizedPnl, isPositionIncreased) = _openReversePosition(order.trader, fillAmount, fulfillPrice);\n        }\n\n        size = positions[order.trader].size;\n        openNotional = positions[order.trader].openNotional;\n\n        uint totalPosSize = uint(abs(size));\n        require(totalPosSize == 0 || totalPosSize >= minSizeRequirement, \"position_less_than_minSize\");\n        // update liquidation threshold\n        // no need to make liquidationThreshold multiple of minSizeRequirement as its the max limit\n        positions[order.trader].liquidationThreshold = Math.max(\n            (totalPosSize * maxLiquidationRatio / 1e6) + 1,\n            minSizeRequirement\n        );\n\n        if (is2ndTrade) {\n            _updateTWAP(fulfillPrice);\n            openInterest = openInterestNotional();\n        }\n    }\n\n    function liquidatePosition(address trader, uint price, int fillAmount)\n        override\n        external\n        onlyClearingHouse\n        returns (int realizedPnl, uint quoteAsset, int size, uint openNotional)\n    {\n        Position memory position = positions[trader];\n        bool isLongPosition = position.size > 0 ? true : false;\n        uint pozSize = uint(abs(position.size));\n        uint toLiquidate = Math.min(pozSize, position.liquidationThreshold);\n\n        require(abs(fillAmount).toUint256() <= toLiquidate, \"AMM_liquidating_too_much_at_once\");\n\n        // liquidate position\n        // if fillAmount is lower, liquidate till fillAmount\n        if (isLongPosition) {\n            require(fillAmount > 0, \"AMM_matching_trade_should_be_opposite\");\n            quoteAsset = fillAmount.toUint256() * price / 1e18;\n        } else {\n            require(fillAmount < 0, \"AMM_matching_trade_should_be_opposite\");\n            quoteAsset = (-fillAmount).toUint256() * price / 1e18;\n        }\n        realizedPnl = _reducePosition(trader, -fillAmount, price);\n\n        size = positions[trader].size;\n        openNotional = positions[trader].openNotional;\n    }\n\n    function updatePosition(address trader)\n        override\n        external\n        onlyClearingHouse\n        returns(int256 fundingPayment, int256 latestCumulativePremiumFraction)\n    {\n        (\n            fundingPayment,\n            latestCumulativePremiumFraction\n        ) = getPendingFundingPayment(trader);\n        positions[trader].lastPremiumFraction = latestCumulativePremiumFraction;\n    }\n\n    function getOpenNotionalWhileReducingPosition(\n        int256 positionSize,\n        uint256 openNotional,\n        int256 unrealizedPnl,\n        int256 baseAssetQuantity\n    )\n        override\n        public\n        pure\n        returns(uint256 remainOpenNotional, int realizedPnl)\n    {\n        require(abs(positionSize) >= abs(baseAssetQuantity), \"AMM.ONLY_REDUCE_POS\");\n        realizedPnl = unrealizedPnl * abs(baseAssetQuantity) / abs(positionSize);\n        remainOpenNotional = openNotional - uint(openNotional.toInt256() * abs(baseAssetQuantity) / abs(positionSize));\n    }\n\n    /**\n     * @notice update funding rate\n     * @dev only allow to update while reaching `nextFundingTime`\n     */\n    function settleFunding()\n        override\n        external\n        onlyClearingHouse\n        returns (\n            int256 premiumFraction,\n            int256 underlyingPrice,\n            int256 /* cumulativePremiumFraction */, // required for emitting events\n            uint256 /* nextFundingTime */\n        )\n    {\n        if (\n            _blockTimestamp() < nextFundingTime\n        ) return (0, 0, 0, 0);\n\n        // premium = twapMarketPrice - twapIndexPrice\n        // timeFraction = fundingPeriod(1 hour) / 1 day\n        // premiumFraction = premium * timeFraction\n        // @todo calculate oracle twap for exact funding period\n        underlyingPrice = getUnderlyingTwapPrice(spotPriceTwapInterval);\n\n        if (markPriceTwapData.lastTimestamp != 0) { // there was atleast 1 trade in the lifetime of the market\n            int256 premium = getMarkPriceTwap() - underlyingPrice;\n            premiumFraction = (premium * int256(fundingPeriod)) / 1 days;\n            // funding rate cap\n            // if premiumFraction > 0, premiumFraction = min(premiumFraction, maxFundingRate * indexTwap)\n            // if premiumFraction < 0, premiumFraction = max(premiumFraction, -maxFundingRate * indexTwap)\n            if (maxFundingRate != 0) {\n                int256 premiumFractionLimit = maxFundingRate * underlyingPrice / 1e6;\n                if (premiumFraction > 0) {\n                    premiumFraction = _min(premiumFraction, premiumFractionLimit);\n                } else {\n                    premiumFraction = _max(premiumFraction, -premiumFractionLimit);\n                }\n            }\n            cumulativePremiumFraction += premiumFraction;\n        }\n\n        // Updates for next funding event\n        // in order to prevent multiple funding settlement during very short time after network congestion\n        uint256 minNextValidFundingTime = _blockTimestamp() + fundingBufferPeriod;\n\n        // floor((nextFundingTime + fundingPeriod) / 3600) * 3600\n        uint256 nextFundingTimeOnHourStart = ((nextFundingTime + fundingPeriod) / fundingPeriod) * fundingPeriod;\n\n        // max(nextFundingTimeOnHourStart, minNextValidFundingTime)\n        nextFundingTime = nextFundingTimeOnHourStart > minNextValidFundingTime\n            ? nextFundingTimeOnHourStart\n            : minNextValidFundingTime;\n\n        return (premiumFraction, underlyingPrice, cumulativePremiumFraction, nextFundingTime);\n    }\n\n    function startFunding() external onlyClearingHouse returns (uint256) {\n        nextFundingTime = ((_blockTimestamp() + fundingPeriod) / fundingPeriod) * fundingPeriod;\n        return nextFundingTime;\n    }\n\n    /* ****************** */\n    /*       View         */\n    /* ****************** */\n\n    function getUnderlyingTwapPrice(uint256 _intervalInSeconds) public view returns (int256) {\n        return oracle.getUnderlyingTwapPrice(underlyingAsset, _intervalInSeconds);\n    }\n\n    function getMarkPriceTwap() public view returns (int256) {\n        return _calcTwap().toInt256();\n    }\n\n    /**\n     * @notice Get notional postion and unrealized PnL at the last trade price\n    */\n    function getNotionalPositionAndUnrealizedPnl(address trader)\n        override\n        external\n        view\n        returns(uint256 notionalPosition, int256 unrealizedPnl)\n    {\n        (notionalPosition, unrealizedPnl,) = getPositionMetadata(lastPrice(), positions[trader].openNotional, positions[trader].size, 0 /* margin (unused) */);\n    }\n\n    /**\n    * @notice Evaluates the optimal PnL depending on the purpose. Returns max/min(oracle_mf, last_price_mf) depending on mode\n    * if mode = Maintenance_Margin, return values which have maximum margin fraction i.e we make the best effort to save user from the liquidation\n    * if mode = Min_Allowable_Margin, return values which have minimum margin fraction. We use this to determine whether user can take any more leverage.\n    */\n    function getOptimalPnl(address trader, int256 margin, IClearingHouse.Mode mode) override external view returns (uint notionalPosition, int256 unrealizedPnl) {\n        Position memory position = positions[trader];\n        if (position.size == 0) {\n            return (0,0);\n        }\n\n        // based on last price\n        int256 lastPriceBasedMF;\n        (notionalPosition, unrealizedPnl, lastPriceBasedMF) = getPositionMetadata(\n            lastPrice(),\n            position.openNotional,\n            position.size,\n            margin\n        );\n\n        // based on oracle price\n        (uint oracleBasedNotional, int256 oracleBasedUnrealizedPnl, int256 oracleBasedMF) = getPositionMetadata(\n            oracle.getUnderlyingPrice(underlyingAsset).toUint256(),\n            position.openNotional,\n            position.size,\n            margin\n        );\n\n        // while evaluating margin for liquidation, we give the best deal to the user\n        if ((mode == IClearingHouse.Mode.Maintenance_Margin && oracleBasedMF > lastPriceBasedMF)\n        // when evaluating margin for leverage, we give the worst deal to the user\n            || (mode == IClearingHouse.Mode.Min_Allowable_Margin && oracleBasedMF < lastPriceBasedMF)) {\n            return (oracleBasedNotional, oracleBasedUnrealizedPnl);\n        }\n    }\n\n    function getPositionMetadata(uint256 price, uint256 openNotional, int256 size, int256 margin)\n        public\n        pure\n        returns (uint256 notionalPos, int256 uPnl, int256 marginFraction)\n    {\n        notionalPos = price * abs(size).toUint256() / BASE_PRECISION_UINT;\n        if (notionalPos == 0) {\n            return (0, 0, 0);\n        }\n        if (size > 0) {\n            uPnl = notionalPos.toInt256() - openNotional.toInt256();\n        } else if (size < 0) {\n            uPnl = openNotional.toInt256() - notionalPos.toInt256();\n        }\n        marginFraction = (margin + uPnl) * 1e6 / notionalPos.toInt256();\n    }\n\n    function getPendingFundingPayment(address trader)\n        override\n        public\n        view\n        returns(\n            int256 takerFundingPayment,\n            int256 latestCumulativePremiumFraction\n        )\n    {\n        Position memory taker = positions[trader];\n\n        // cache state variables locally for cheaper access and return values\n        latestCumulativePremiumFraction = cumulativePremiumFraction;\n\n        // Taker\n        takerFundingPayment = (latestCumulativePremiumFraction - taker.lastPremiumFraction)\n            * taker.size\n            / BASE_PRECISION;\n    }\n\n    function lastPrice() public view returns(uint256) {\n        // return oracle price at the start of amm\n        if (markPriceTwapData.lastTimestamp == 0) {\n            return uint(oracle.getUnderlyingPrice(underlyingAsset));\n        }\n        return markPriceTwapData.lastPrice;\n    }\n\n    function getUnderlyingPrice() public view returns(uint256) {\n        return uint(oracle.getUnderlyingPrice(underlyingAsset));\n    }\n\n    function openInterestNotional() override public view returns (uint256) {\n        return longOpenInterestNotional + shortOpenInterestNotional;\n    }\n\n    /* ****************** */\n    /*       Internal     */\n    /* ****************** */\n\n    function _increasePosition(address trader, int256 baseAssetQuantity, uint price)\n        internal\n    {\n        if (baseAssetQuantity > 0) { // Long - purchase baseAssetQuantity\n            longOpenInterestNotional += baseAssetQuantity.toUint256();\n        } else { // Short - sell baseAssetQuantity\n            shortOpenInterestNotional += (-baseAssetQuantity).toUint256();\n        }\n        positions[trader].size += baseAssetQuantity; // -ve baseAssetQuantity will increase short position\n        positions[trader].openNotional += abs(baseAssetQuantity).toUint256() * price / 1e18;\n    }\n\n    function _openReversePosition(address trader, int256 baseAssetQuantity, uint price)\n        internal\n        returns (int realizedPnl, bool isPositionIncreased)\n    {\n        Position memory position = positions[trader];\n        if (abs(position.size) >= abs(baseAssetQuantity)) {\n            (realizedPnl) = _reducePosition(trader, baseAssetQuantity, price);\n        } else {\n            (realizedPnl) = _reducePosition(trader, -position.size, price);\n            _increasePosition(trader, baseAssetQuantity + position.size, price);\n            isPositionIncreased = true;\n        }\n    }\n\n    /**\n    * @dev validate that baseAssetQuantity <= position.size should be performed before the call to _reducePosition\n    */\n    function _reducePosition(address trader, int256 baseAssetQuantity, uint price)\n        internal\n        returns (int realizedPnl)\n    {\n        Position storage position = positions[trader]; // storage because there are updates at the end\n        (,int256 unrealizedPnl,) = getPositionMetadata(price, positions[trader].openNotional, positions[trader].size, 0 /* margin (unused) */);\n\n        bool isLongPosition = position.size > 0 ? true : false;\n\n        if (isLongPosition) {\n            longOpenInterestNotional -= (-baseAssetQuantity).toUint256();\n        } else {\n            shortOpenInterestNotional -= baseAssetQuantity.toUint256();\n        }\n        (position.openNotional, realizedPnl) = getOpenNotionalWhileReducingPosition(position.size, position.openNotional, unrealizedPnl, baseAssetQuantity);\n        position.size += baseAssetQuantity;\n    }\n\n    function _updateTWAP(uint256 price) internal {\n        uint256 currentTimestamp = _blockTimestamp();\n        uint256 currentPeriodStart = (currentTimestamp / spotPriceTwapInterval) * spotPriceTwapInterval;\n        uint256 lastPeriodStart = currentPeriodStart - spotPriceTwapInterval;\n        uint256 deltaTime;\n\n        // If its the first trade in the current period, reset the accumulator, and set the lastPeriod accumulator\n        if (markPriceTwapData.lastTimestamp < currentPeriodStart) {\n            /**\n            * check if there was a trade in the last period\n            * though this is not required as we return lastPrice in _calcTwap if there is no trade in last hour\n            * keeping it to have correct accumulator values\n            */\n            if (markPriceTwapData.lastTimestamp > lastPeriodStart) {\n                deltaTime = currentPeriodStart - markPriceTwapData.lastTimestamp;\n                markPriceTwapData.lastPeriodAccumulator = markPriceTwapData.accumulator + markPriceTwapData.lastPrice * deltaTime;\n            } else {\n                markPriceTwapData.lastPeriodAccumulator = markPriceTwapData.lastPrice * spotPriceTwapInterval;\n            }\n            markPriceTwapData.accumulator = (currentTimestamp - currentPeriodStart) * markPriceTwapData.lastPrice;\n        } else {\n            // Update the accumulator\n            deltaTime = currentTimestamp - markPriceTwapData.lastTimestamp;\n            markPriceTwapData.accumulator += markPriceTwapData.lastPrice * deltaTime;\n        }\n\n        // Update the last price and timestamp\n        markPriceTwapData.lastPrice = price;\n        markPriceTwapData.lastTimestamp = currentTimestamp;\n    }\n\n    function _blockTimestamp() internal view virtual returns (uint256) {\n        return block.timestamp;\n    }\n\n    /**\n    * @notice Calculates the TWAP price from the last hour start to the current block timestamp\n    */\n    function _calcTwap() internal view returns (uint256 twap) {\n        uint256 currentPeriodStart = (_blockTimestamp() / spotPriceTwapInterval) * spotPriceTwapInterval;\n        uint256 lastPeriodStart = currentPeriodStart - spotPriceTwapInterval;\n\n        // If there is no trade in the last period, return the last trade price\n        if (markPriceTwapData.lastTimestamp <= lastPeriodStart) {\n            return markPriceTwapData.lastPrice;\n        }\n\n        /**\n        * check if there is any trade after currentPeriodStart\n        * since this function will not be called before the nextFundingTime,\n        * we can use the lastPeriodAccumulator to calculate the twap if there is a trade after currentPeriodStart\n        */\n        if (markPriceTwapData.lastTimestamp >= currentPeriodStart) {\n            // use the lastPeriodAccumulator to calculate the twap\n            twap = markPriceTwapData.lastPeriodAccumulator / spotPriceTwapInterval;\n        } else {\n            // use the accumulator to calculate the twap\n            uint256 currentAccumulator = markPriceTwapData.accumulator + (currentPeriodStart - markPriceTwapData.lastTimestamp) * markPriceTwapData.lastPrice;\n            twap = currentAccumulator / spotPriceTwapInterval;\n        }\n    }\n\n    /* ****************** */\n    /*       Pure         */\n    /* ****************** */\n\n    function abs(int x) internal pure returns (int) {\n        return x >= 0 ? x : -x;\n    }\n\n    function _max(int x, int y) private pure returns (int) {\n        return x >= y ? x : y;\n    }\n\n    function _min(int x, int y) private pure returns (int) {\n        return x < y ? x : y;\n    }\n\n    /* ****************** */\n    /*       Governance   */\n    /* ****************** */\n\n    function changeOracle(address _oracle) public onlyGovernance {\n        oracle = IOracle(_oracle);\n    }\n\n    function setPriceSpreadParams(uint _maxOracleSpreadRatio, uint _maxLiquidationPriceSpread) external onlyGovernance {\n        require(_maxLiquidationPriceSpread <= _maxOracleSpreadRatio, \"maxLiquidationPriceSpread > maxOracleSpreadRatio\");\n        maxOracleSpreadRatio = _maxOracleSpreadRatio;\n        maxLiquidationPriceSpread = _maxLiquidationPriceSpread;\n    }\n\n    function setLiquidationSizeRatio(uint _maxLiquidationRatio) external onlyGovernance {\n        maxLiquidationRatio = _maxLiquidationRatio;\n    }\n\n    function setMinSizeRequirement(uint _minSizeRequirement) external onlyGovernance {\n        minSizeRequirement = _minSizeRequirement;\n    }\n\n    function setFundingParams(\n        uint _fundingPeriod,\n        uint _fundingBufferPeriod,\n        int256 _maxFundingRate,\n        uint _spotPriceTwapInterval\n    ) external onlyGovernance {\n        fundingPeriod = _fundingPeriod;\n        fundingBufferPeriod = _fundingBufferPeriod;\n        maxFundingRate = _maxFundingRate;\n        spotPriceTwapInterval = _spotPriceTwapInterval;\n    }\n}"
    },
    {
      "filename": "hubble-protocol/contracts/AMM.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.9;\n\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport { Governable } from \"./legos/Governable.sol\";\nimport { ERC20Detailed, IOracle, IRegistry, IAMM, IClearingHouse, IOrderBook } from \"./Interfaces.sol\";\n\n/**\n * @title Maintains the information about open positions, open notional, oracle price, funding rate, etc.\n * @notice All methods are intended to be called by the ClearingHouse contract.\n * @dev The name \"AMM\" is slightly misleading because this contract doesn't actually have a bonding curve. But it does facilitate trading b/w users. Maybe \"Market\" would been more appropriate.\n * There will be 1 AMM contract for every market i.e. if Hubble Exchange has 3 markets (ETH-PERP, BTC-PERP, AVAX-PERP), there will be 3 AMM contracts.\n*/\ncontract AMM is IAMM, Governable {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    /* ****************** */\n    /*       Structs      */\n    /* ****************** */\n\n    /**\n     * @notice Position struct\n     * @param size is signed, positive for long and negative for short. scaled by 1e18\n     * @param openNotional $ amount that the position was opened at. Always positive. scaled by 1e6\n     * openNotional / size gives the average entry price\n     * @param lastPremiumFraction is the premium fraction at which the pending fundings for the trader have been settled\n     * @param liquidationThreshold is the max position size that can be liquidated in one go. This is to support partial liquidations. scaled by 1e18\n    */\n    struct Position {\n        int256 size;\n        uint256 openNotional;\n        int256 lastPremiumFraction;\n        uint liquidationThreshold;\n    }\n\n    struct TWAPData {\n        uint256 lastPrice;\n        uint256 lastTimestamp;\n        uint256 accumulator;\n        uint256 lastPeriodAccumulator;\n    }\n\n    /* ****************** */\n    /*      Constants     */\n    /* ****************** */\n\n    int256 constant BASE_PRECISION = 1e18;\n    uint256 constant BASE_PRECISION_UINT = 1e18;\n    address public immutable clearingHouse;\n\n    /* ****************** */\n    /*       Storage      */\n    /* ****************** */\n\n    // vars needed in the precompiles should preferably come first and mention the SLOT_# to avoid any potential slot errors\n    TWAPData public markPriceTwapData; // SLOT_1 - SLOT_4 !!! used in precompile !!!\n\n    mapping(address => Position) override public positions; // SLOT_5 !!! used in precompile !!!\n\n    int256 public cumulativePremiumFraction; // SLOT_6 !!! used in precompile !!!\n\n    // maximum allowed % difference between mark price and index price. scaled 6 decimals\n    uint256 public maxOracleSpreadRatio; // SLOT_7 !!! used in precompile !!!\n\n    // maximum allowd % size which can be liquidated in one tx. scaled 6 decimals\n    uint256 public maxLiquidationRatio; // SLOT_8 !!! used in precompile !!!\n\n    /// @notice Min amount of base asset quantity to trade\n    uint256 public minSizeRequirement; // SLOT_9 !!! used in precompile !!!\n\n    IOracle public oracle; // SLOT_10 !!! used in precompile !!!\n\n    address override public underlyingAsset; // SLOT_11 !!! used in precompile !!!\n    string public name;\n\n    uint256 public fundingBufferPeriod;\n    uint256 public nextFundingTime;\n\n    uint256 public longOpenInterestNotional;\n    uint256 public shortOpenInterestNotional;\n    // maximum allowed % difference between mark price and index price before liquidation\n    uint256 public maxLiquidationPriceSpread; // scaled 6 decimals  // SLOT_17 !!! used in precompile !!!\n\n    uint256 public spotPriceTwapInterval;\n    uint256 public fundingPeriod;\n\n    enum Side { LONG, SHORT }\n\n    // maximum hourly funding rate allowed in %\n    int256 public maxFundingRate; // in hourly %,  scaled to 1e6\n\n    uint256[50] private __gap;\n\n    /* ****************** */\n    /*    Storage Ends    */\n    /* ****************** */\n\n    modifier onlyClearingHouse() {\n        require(msg.sender == clearingHouse, \"Only clearingHouse\");\n        _;\n    }\n\n    constructor(address _clearingHouse) {\n        clearingHouse = _clearingHouse;\n    }\n\n    function initialize(\n        string memory _name,\n        address _underlyingAsset,\n        address _oracle,\n        uint _minSizeRequirement,\n        address _governance\n    ) external initializer {\n        name = _name;\n        underlyingAsset = _underlyingAsset;\n        oracle = IOracle(_oracle);\n        minSizeRequirement = _minSizeRequirement;\n        _setGovernace(_governance);\n\n        // values that most likely wouldn't need to change frequently\n        fundingBufferPeriod = 15 minutes;\n        maxOracleSpreadRatio = 20 * 1e4; // 20%\n        maxLiquidationRatio = 25 * 1e4; // 25%\n        maxLiquidationPriceSpread = 1 * 1e4; // 1%\n\n        fundingPeriod = 1 hours;\n        spotPriceTwapInterval = 1 hours;\n    }\n\n    /**\n     * @notice Executes state updates about position modifications, after all the validations have passed at the ClearingHouse/OrderBook level\n     * @param fillAmount != 0 has been validated in orderBook.executeMatchedOrders/liquidateAndExecuteOrder\n     * @param is2ndTrade true if this is the 2nd trade in the same tx. In that case, we update TWAP and return openInterest\n    */\n    function openPosition(IOrderBook.Order memory order, int256 fillAmount, uint256 fulfillPrice, bool is2ndTrade)\n        override\n        external\n        onlyClearingHouse\n        returns (int realizedPnl, bool isPositionIncreased, int size, uint openNotional, uint openInterest)\n    {\n        Position memory position = positions[order.trader];\n        bool isNewPosition = position.size == 0 ? true : false;\n        Side side = fillAmount > 0 ? Side.LONG : Side.SHORT;\n\n        if (isNewPosition || (position.size > 0 ? Side.LONG : Side.SHORT) == side) {\n            // realizedPnl = 0;\n            _increasePosition(order.trader, fillAmount, fulfillPrice);\n            isPositionIncreased = true;\n        } else {\n            (realizedPnl, isPositionIncreased) = _openReversePosition(order.trader, fillAmount, fulfillPrice);\n        }\n\n        size = positions[order.trader].size;\n        openNotional = positions[order.trader].openNotional;\n\n        uint totalPosSize = uint(abs(size));\n        require(totalPosSize == 0 || totalPosSize >= minSizeRequirement, \"position_less_than_minSize\");\n        // update liquidation threshold\n        // no need to make liquidationThreshold multiple of minSizeRequirement as its the max limit\n        positions[order.trader].liquidationThreshold = Math.max(\n            (totalPosSize * maxLiquidationRatio / 1e6) + 1,\n            minSizeRequirement\n        );\n\n        if (is2ndTrade) {\n            _updateTWAP(fulfillPrice);\n            openInterest = openInterestNotional();\n        }\n    }\n\n    function liquidatePosition(address trader, uint price, int fillAmount)\n        override\n        external\n        onlyClearingHouse\n        returns (int realizedPnl, uint quoteAsset, int size, uint openNotional)\n    {\n        Position memory position = positions[trader];\n        bool isLongPosition = position.size > 0 ? true : false;\n        uint pozSize = uint(abs(position.size));\n        uint toLiquidate = Math.min(pozSize, position.liquidationThreshold);\n\n        require(abs(fillAmount).toUint256() <= toLiquidate, \"AMM_liquidating_too_much_at_once\");\n\n        // liquidate position\n        // if fillAmount is lower, liquidate till fillAmount\n        if (isLongPosition) {\n            require(fillAmount > 0, \"AMM_matching_trade_should_be_opposite\");\n            quoteAsset = fillAmount.toUint256() * price / 1e18;\n        } else {\n            require(fillAmount < 0, \"AMM_matching_trade_should_be_opposite\");\n            quoteAsset = (-fillAmount).toUint256() * price / 1e18;\n        }\n        realizedPnl = _reducePosition(trader, -fillAmount, price);\n\n        size = positions[trader].size;\n        openNotional = positions[trader].openNotional;\n    }\n\n    function updatePosition(address trader)\n        override\n        external\n        onlyClearingHouse\n        returns(int256 fundingPayment, int256 latestCumulativePremiumFraction)\n    {\n        (\n            fundingPayment,\n            latestCumulativePremiumFraction\n        ) = getPendingFundingPayment(trader);\n        positions[trader].lastPremiumFraction = latestCumulativePremiumFraction;\n    }\n\n    function getOpenNotionalWhileReducingPosition(\n        int256 positionSize,\n        uint256 openNotional,\n        int256 unrealizedPnl,\n        int256 baseAssetQuantity\n    )\n        override\n        public\n        pure\n        returns(uint256 remainOpenNotional, int realizedPnl)\n    {\n        require(abs(positionSize) >= abs(baseAssetQuantity), \"AMM.ONLY_REDUCE_POS\");\n        realizedPnl = unrealizedPnl * abs(baseAssetQuantity) / abs(positionSize);\n        remainOpenNotional = openNotional - uint(openNotional.toInt256() * abs(baseAssetQuantity) / abs(positionSize));\n    }\n\n    /**\n     * @notice update funding rate\n     * @dev only allow to update while reaching `nextFundingTime`\n     */\n    function settleFunding()\n        override\n        external\n        onlyClearingHouse\n        returns (\n            int256 premiumFraction,\n            int256 underlyingPrice,\n            int256 /* cumulativePremiumFraction */, // required for emitting events\n            ui"
    }
  ]
}