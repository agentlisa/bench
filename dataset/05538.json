{
  "Title": "[M-02] Soft Restricted Staker Role can withdraw stUSDe for USDe",
  "Content": "\nA requirement is stated that a user with the `SOFT_RESTRICTED_STAKER_ROLE` is not allowed to withdraw `USDe` for `stUSDe`.\n\nThe code does not satisfy that condition, when a holder has the `SOFT_RESTRICTED_STAKER_ROLE`, they can exchange their `stUSDe` for `USDe` using `StakedUSDeV2`.\n\n### Description\n\nThe Ethena readme has the following decription of legal requirements for the Soft Restricted Staker Role: <br><https://github.com/code-423n4/2023-10-ethena/blob/ee67d9b542642c9757a6b826c82d0cae60256509/README.md?plain=1#L98>\n\n    Due to legal requirements, there's a `SOFT_RESTRICTED_STAKER_ROLE` and `FULL_RESTRICTED_STAKER_ROLE`. \n    The former is for addresses based in countries we are not allowed to provide yield to, for example USA. \n    Addresses under this category will be soft restricted. They cannot deposit USDe to get stUSDe or withdraw stUSDe for USDe. \n    However they can participate in earning yield by buying and selling stUSDe on the open market.\n\nIn summary, legal requires are that a `SOFT_RESTRICTED_STAKER_ROLE`:\n\n*   MUST NOT deposit USDe to get stUSDe\n*   MUST NOT withdraw USDe for USDe\n*   MAY earn yield by trading stUSDe on the open market\n\nAs `StakedUSDeV2` is a `ERC4626`, the `stUSDe` is a share on the underlying `USDe` asset. There are two distinct entrypoints for a user to exchange their share for their claim on the underlying the asset, `withdraw` and `redeem`. Each cater for a different input (`withdraw` being by asset, `redeem` being by share), however both invoked the same internal `_withdraw` function, hence both entrypoints are affected.\n\nThere are two cases where a user with `SOFT_RESTRICTED_STAKER_ROLE` may have acquired `stUSDe`:\n\n*   Brought `stUSDe` on the open market\n*   Deposited `USDe` in `StakedUSDeV2` before being granted the `SOFT_RESTRICTED_STAKER_ROLE`\n\nIn both cases the user can call either withdraw their holding by calling `withdraw` or `redeem` (when cooldown is off), or `unstake` (if cooldown is on) and successfully exchange their `stUSDe` for `USDe`.\n\n### Proof of Concept\n\nThe following two tests demonstrate the use case of a user staking, then being granted the `SOFT_RESTRICTED_STAKER_ROLE`, then exchanging their `stUSDe` for `USDe` (first using `redeem` function, the second using `withdrawm`).\n\nThe use case for acquiring on the open market, only requiring a different setup, however the exchange behaviour is identical and the cooldown enabled `cooldownAssets` and `cooldownShares` function still use the same `_withdraw` as `redeem` and `withdraw`, which leads to the same outcome.\n\n(Place code into `StakedUSDe.t.sol` and run with `forge test`)<br>\n<https://github.com/code-423n4/2023-10-ethena/blob/ee67d9b542642c9757a6b826c82d0cae60256509/test/foundry/staking/StakedUSDe.t.sol>\n\n```Solidity\n  bytes32 public constant SOFT_RESTRICTED_STAKER_ROLE = keccak256(\"SOFT_RESTRICTED_STAKER_ROLE\");\n  bytes32 private constant BLACKLIST_MANAGER_ROLE = keccak256(\"BLACKLIST_MANAGER_ROLE\");\n\n  function test_redeem_while_soft_restricted() public {\n    // Set up Bob with 100 stUSDe\n    uint256 initialAmount = 100 ether;\n    _mintApproveDeposit(bob, initialAmount);\n    uint256 stakeOfBob = stakedUSDe.balanceOf(bob);\n\n    // Alice becomes a blacklist manager\n    vm.prank(owner);\n    stakedUSDe.grantRole(BLACKLIST_MANAGER_ROLE, alice);\n\n    // Blacklist Bob with the SOFT_RESTRICTED_STAKER_ROLE\n    vm.prank(alice);\n    stakedUSDe.addToBlacklist(bob, false);\n\n    // Assert that Bob has staked and is now has the soft restricted role\n    assertEq(usdeToken.balanceOf(bob), 0);\n    assertEq(stakedUSDe.totalSupply(), stakeOfBob);\n    assertEq(stakedUSDe.totalAssets(), initialAmount);\n    assertTrue(stakedUSDe.hasRole(SOFT_RESTRICTED_STAKER_ROLE, bob));\n\n    // Rewards to StakeUSDe and vest\n    uint256 rewardAmount = 50 ether;\n    _transferRewards(rewardAmount, rewardAmount);\n    vm.warp(block.timestamp + 8 hours);\n\n    // Assert that only the total assets have increased after vesting\n    assertEq(usdeToken.balanceOf(bob), 0);\n    assertEq(stakedUSDe.totalSupply(), stakeOfBob);\n    assertEq(stakedUSDe.totalAssets(), initialAmount + rewardAmount);\n    assertTrue(stakedUSDe.hasRole(SOFT_RESTRICTED_STAKER_ROLE, bob));\n\n    // Bob withdraws his stUSDe for USDe\n    vm.prank(bob);\n    stakedUSDe.redeem(stakeOfBob, bob, bob);\n\n    // End state being while being soft restricted Bob redeemed USDe with rewards\n    assertApproxEqAbs(usdeToken.balanceOf(bob), initialAmount + rewardAmount, 2);\n    assertApproxEqAbs(stakedUSDe.totalAssets(), 0, 2);\n    assertTrue(stakedUSDe.hasRole(SOFT_RESTRICTED_STAKER_ROLE, bob));\n  }\n\n  function test_withdraw_while_soft_restricted() public {\n    // Set up Bob with 100 stUSDe\n    uint256 initialAmount = 100 ether;\n    _mintApproveDeposit(bob, initialAmount);\n    uint256 stakeOfBob = stakedUSDe.balanceOf(bob);\n\n    // Alice becomes a blacklist manager\n    vm.prank(owner);\n    stakedUSDe.grantRole(BLACKLIST_MANAGER_ROLE, alice);\n\n    // Blacklist Bob with the SOFT_RESTRICTED_STAKER_ROLE\n    vm.prank(alice);\n    stakedUSDe.addToBlacklist(bob, false);\n\n    // Assert that Bob has staked and is now has the soft restricted role\n    assertEq(usdeToken.balanceOf(bob), 0);\n    assertEq(stakedUSDe.totalSupply(), stakeOfBob);\n    assertEq(stakedUSDe.totalAssets(), initialAmount);\n    assertTrue(stakedUSDe.hasRole(SOFT_RESTRICTED_STAKER_ROLE, bob));\n\n    // Rewards to StakeUSDe and vest\n    uint256 rewardAmount = 50 ether;\n    _transferRewards(rewardAmount, rewardAmount);\n    vm.warp(block.timestamp + 8 hours);\n\n    // Assert that only the total assets have increased after vesting\n    assertEq(usdeToken.balanceOf(bob), 0);\n    assertEq(stakedUSDe.totalSupply(), stakeOfBob);\n    assertEq(stakedUSDe.totalAssets(), initialAmount + rewardAmount);\n    assertTrue(stakedUSDe.hasRole(SOFT_RESTRICTED_STAKER_ROLE, bob));\n\n    // Bob withdraws his stUSDe for USDe (-1 as dust is lost in asset to share rounding in ERC4626)\n    vm.prank(bob);\n    stakedUSDe.withdraw(initialAmount + rewardAmount - 1, bob, bob);\n\n    // End state being while being soft restricted Bob redeemed USDe with rewards\n    assertApproxEqAbs(usdeToken.balanceOf(bob), initialAmount + rewardAmount, 2);\n    assertApproxEqAbs(stakedUSDe.totalAssets(), 0, 2);\n    assertTrue(stakedUSDe.hasRole(SOFT_RESTRICTED_STAKER_ROLE, bob));\n  }\n```\n\n### Tools Used\n\nManual review, Foundry test\n\n### Recommended Mitigation Steps\n\nWith the function overriding present, to prevent the `SOFT_RESTRICTED_STAKER_ROLE` from being able to exchange their `stUSDs` for `USDe`, make the following change in `StakedUSDe`\n\n<https://github.com/code-423n4/2023-10-ethena/blob/ee67d9b542642c9757a6b826c82d0cae60256509/contracts/StakedUSDe.sol#L232>\n\n```Solidity\n-    if (hasRole(FULL_RESTRICTED_STAKER_ROLE, caller) || hasRole(FULL_RESTRICTED_STAKER_ROLE, receiver)) {\n+    if (hasRole(FULL_RESTRICTED_STAKER_ROLE, caller) || hasRole(FULL_RESTRICTED_STAKER_ROLE, receiver) || hasRole(SOFT_RESTRICTED_STAKER_ROLE, caller)) {\n      revert OperationNotAllowed();\n    }\n```\n\n**[0xDjango (judge) decreased severity to Medium](https://github.com/code-423n4/2023-10-ethena-findings/issues/246#issuecomment-1810742469)**\n\n**[kayinnnn (Ethena) disputed and commented](https://github.com/code-423n4/2023-10-ethena-findings/issues/246#issuecomment-1858130415):**\n> For this issue, the docs were incorrect to say withdrawal by soft restricted role is not allowed. Only depositing is not allowed.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-10-ethena",
  "Code": [
    {
      "filename": "README.md?plain=1",
      "content": "# Ethena Labs audit details\n- Total Prize Pool: $36,500 USDC\n  - HM awards: $24,750 USDC\n  - Analysis awards: $1,500 USDC\n  - QA awards: $750 USDC\n  - Bot Race awards: $2,250 USDC\n  - Gas awards: $750 USDC\n  - Judge awards: $3,600 USDC\n  - Lookout awards: $2,400 USDC\n  - Scout awards: $500 USDC\n- Join [C4 Discord](https://discord.gg/code4rena) to register\n- Submit findings [using the C4 form](https://code4rena.com/contests/2023-10-ethena-labs/submit)\n- [Read our guidelines for more details](https://docs.code4rena.com/roles/wardens)\n- Starts October 24, 2023 20:00 UTC\n- Ends October 30, 2023 20:00 UTC\n\n## Automated Findings / Publicly Known Issues\n\nThe 4naly3er report can be found [here](https://github.com/code-423n4/2023-10-ethena/blob/main/4naly3er-report.md).\n\nAutomated findings output for the audit can be found [here](https://github.com/code-423n4/2023-10-ethena/blob/main/bot-report.md) within 24 hours of audit opening.\n\n_Note for C4 wardens: Anything included in the 4naly3er **or** the automated findings output is considered a publicly known issue and is ineligible for awards._\n\n# Overview\n\n## Gitbook\nTo get an overview of Ethena, please visit our [Gitbook](https://ethena-labs.gitbook.io/ethena-labs/10CaMBZwnrLWSUWzLS2a/).\n\n## Goals\n\nThe goal of Ethena is to offer a permissionless stablecoin, USDe, to defi users and to offer users yield for being in our ecosystem. Unlike USDC where Circle captures the yield, USDe holders can stake their USDe in exchange to receive stUSDe, which increases in value relative to USDe as the protocol earns yield. (Similar to rETH increasing in value with respect to ETH)\n\n## How USDe is minted\n\nEthena provides an RFQ of how much USDe can be minted for a stETH amount. If user agrees to price, user signs the EIP712 signature and submits it to Ethena. stETH is traded for newly minted USDe at the rate specified by Ethena's RFQ and user's signature. The stETH is then sent to custodians and delegated to perps exchange, where an a USD amount of ETH perps equal to the USDe minted is shorted, creating a delta neutral position.\n\n## How Ethena generated yield\n\nUsers mint USDe with stETH, and Ethena opens an equvilant short ETH perps position on perps exchanges. stETH yields 3-4% annualized, while short ETH perps yield 6-8%. The combined long and short position daily yield is sent to an insurance fund, and then sent to the staking contract every 8 hours.\n\n## How we maintain delta neutrality\n\nThe long stETH and short ETH perps creates a position with value that's fixed to the time of it's creation. Imagine ETH = &#36;2000, user sends in 10 stETH to mint 20000 USDe, and Ethena shorts 10 ETH worth of perps.\n\nIf the market goes down 90%, the long 10 stETH position is now worth &#36;2000, down from &#36;20000. While the short 10 ETH perps position has an unrealized P&L of $18000. If the user wishes to redeem his USDe, the short perps position can be closed to realize &#36;18000 of profits, and buy 90 stETH. Along with the original 10 stETH, the user is returned 100 stETH, also worth &#36;20000.\n\n## Our 3 Smart contracts\n\n### USDe.sol\n\n`USDe.sol` is the contract of our stablecoin. It extends `ERC20Burnable`, `ERC20Permit` and `Ownable2Step` from Open Zepplin. There's a single variable, the `minter` address that can be modified by the `OWNER`. Outside of `Ownable2Step` contract owner only has one custom function, the ability to set the `minter` variable to any address.\n\nThe `minter` address is the only address that has the ability to mint USDe. This minter address has one of the most powerful non-owner permissions, the ability to create an unlimited amount of USDe. It will always be pointed to the `EthenaMinting.sol` contract.\n\n### EthenaMinting.sol\n\n`EthenaMinting.sol` is the contract and address that the `minter` variable in `USDe.sol` points to. When users mint USDe with stETH (or other collateral) or redeems collateral for USDe, this contract is invoked.\n\nThe primary functions used in this contract is `mint()` and `redeen()`. Users who call this contract are all within Ethena. When outside users wishes to mint or redeem, they perform an EIP712 signature based on an offchain price we provided to them. They sign the order and sends it back to Ethena's backend, where we run a series of checks and are the ones who take their signed order and put them on chain.\n\nBy design, Ethena will be the only ones calling `mint()`,`redeen()` and other functions in this contract.\n\n### Minting\n\nIn the `mint()` function, `order` and `signature` parameters comes from users who wishes to mint and performed the EIP 712 signature. `route` is generated by Ethena, where it defines where the incoming collateral from users go to. The address in `route` we defined must be inside `_custodianAddresses` as a safety check, to ensure funds throughout the flow from users end up in our custodians within a single transaction. Only `DEFAULT_ADMIN_ROLE` can add custodian address.\n\n### Redeeming\n\nSimilar to minting, user performs an EIP712 signature with prices Ethena defined. We then submit their signature and order into `redeem()` function. The funds from redemption comes from the Ethena minting contract directly. Ethena aims to hold between &#36;100k-&#36;200k worth of collateral at all times for hot redemptions. This mean for users intending to redeem a large amount, they will need to redeem over several blocks. Alternatively they can sell USDe on the open market.\n\n### Setting delegated signer\n\nSome users trade through smart contracts. Ethena minting has the ability to delegate signers to sign for an address, using `setDelegatedSigner`. The smart contract should call this function with the desired EOA address to delegate signing to. To remove delegation, call `removeDelegatedSigner`. Multiple signers can be delegated at once, and it can be used by EOA addresses as well.\n\nBy setting a delegated signer, the smart contract allows both the `order.benefactor` and delegated signed to be the address that's ecrecovered from the order and signature, rather than just `order.benefactor`.\n\n#### Security\n\n`EthenaMinting.sol` have crucial roles called the `MINTER` and `REDEEMER`. Starting with `MINTER`, in our original design, they have the ability to mint any amount of USDe for any amount of collateral. Given `MINTER` is a hot wallet and is an EOA address, we considered the scenario where this key becomes compromised. An attacker could then mint a billion USDe for no collateral, and dump them on pools, causing a black swan event our insurance fund cannot cover.\n\nOur solution is to enforce an on chain mint and redeem limitation of 100k USDe per block. In addition, we have `GATEKEEPER` roles with the ability to disable mint/redeems and remove `MINTERS`,`REDEEMERS`. `GATEKEEPERS` acts as a safety layer in case of compromised `MINTER`/`REDEEMER`. They will be run in seperate AWS accounts not tied to our organisation, constantly checking each transaction on chain and disable mint/redeems on detecting transactions at prices not in line with the market. In case compromised `MINTERS` or `REDEEMERS` after this security implementation, a hacker can at most mint 100k USDe for no collateral, and redeem all the collateral within the contract (we will hold ~$200k max), for a max loss of $300k in a single block, before `GATEKEEPER` disable mint and redeem. The $300k loss will not materialy affect our operations.\n\nFurther down the line, there has been considerations to give external organisations a `GATEKEEPER` role. We expect the external organisations to only invoke the gatekeeper functions when price errors occur on chain. Abuse of this prvileage means their `GATEKEEPER` role will be removed.\n\nThe `DEFAULT_ADMIN_ROLE`, also our ethena multisig, is required to re-enable minting/redeeming. `DEFAULT_ADMIN_ROLE` also has the power to add/remove `GATEKEEPERS`,`MINTER` and `REDEEMER`.\n\n`DEFAULT_ADMIN_ROLE` is the most powerful role in the minting contract, but is still beneath the `OWNER` role of `USDe.sol`, given that the owner can remove the minting contract's privilege to mint.\n\n### StakedUSDeV2.sol\n\n`StakedUSDeV2.sol` is where holders of USDe stablecoin can stake their stablecoin, get stUSDe in return and earn yield. Our protocol's yield is paid out by having a `REWARDER` role of the staking contract send yield in USDe, increasing the stUSDe value with respect to USDe.\n\nThis contract is a modification of the ERC4626 standard, with a change to vest in rewards linearly over 8 hours to prevent users frontrunning the payment of yield, then unwinding their position right after (or even in the same block). This is also the reason for `REWARDER` role. Otherwise users can be denied rewards if random addresses send in 1 wei and modifies the rate of reward vesting.\n\nThere's also an additional change to add a 14 day cooldown period on unstaking stUSDe. When the unstake process is initiated, from the user's perspective, stUSDe is burnt immediately, and they will be able to invoke the withdraw function after cooldown is up to get their USDe in return. Behind the scenes, on burning of stUSDe, USDe is sent to a seperate silo contract to hold the funds for the cooldown period. And on withdrawal, the staking contract moves user funds from silo contract out to the user's address. The cooldown is configurable up to 90 days.\n\nDue to legal requirements, there's a `SOFT_RESTRICTED_STAKER_ROLE` and `FULL_RESTRICTED_STAKER_ROLE`. The former is for addresses based in countries we are not allowed to provide yield to, for example USA. Addresses under this category will be soft restricted. They cannot deposit USDe to get stUSDe or withdraw stUSDe for USDe. However they can participate in earning yield by buying and selling stUSDe on the open market.\n\n`FULL_RESTRCITED_STAKER_ROLE` is for sanction/stolen funds, or if we get a request from law enforcement to freeze funds. Addresses fully restricted cannot move their funds, and only Ethena can unfreeze the address. Ethena also have the ability to repossess funds of an address fully restricted. We understand having the ability to freeze and repossess funds of any address Ethena choose could be a cause of concern for defi users decisions to stake USDe. While we aim to make our operations as secure as possible, interacting with Ethena still requires a certain amount of trust in our organisation outside of code on the smart contract, given the tie into cefi to earn yield.\n\nNote this restriction only applied to staking contract, there are no restrictions or ability to freeze funds of the USDe stablecoin, unlike USDC.\n\n## Owner of Ethena's smart contracts\nEthena utilises a gnosis safe multisig to hold ownership of its smart contracts. All multisig keys are cold wallets. We will require 7/10 or more confirmations before transactions are approved. This multisig is purely for the purpose of owning the smart contracts, and will not hold funds or do other on chain actions.\n\n## Links\n\n- **Documentation:** https://ethena-labs.gitbook.io/ethena-labs/10CaMBZwnrLWSUWzLS2a/\n- **Website:** https://www.ethena.fi/\n- **Twitter:** https://twitter.com/ethena_labs\n- **Discord:** https://discord.com/invite/ethena\n\n# Scope\nSmart contract files are located in /protocols/USDe/contracts\n\n`USDe.sol`\n`EthenaMinting.sol` and the contract it extends, `SingleAdminAccessControl.sol`\n`StakedUSDeV2.sol`, the contract it extends, `StakedUSDe.sol` and the additional contract it creates `USDeSilo.sol`\n\n| Contract | SLOC | Purpose | Libraries used |  \n| ----------- | ----------- | ----------- | ----------- |\n| [USDe.sol](https://github.com/code-423n4/2023-10-ethena/blob/main/contracts/USDe.sol) | 24 | USDe token stablecoin contract that grants another address the ability to mint USDe | [`@openzeppelin/ERC20Burnable.sol`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/ERC20Burnable.sol) [`@openzeppelin/ERC20Permit.sol`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/ERC20Permit.sol) [`@openzeppelin/Ownable2Step.sol`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable2Step.sol)|\n| [EthenaMinting.sol](https://github.com/code-423n4/2023-10-ethena/blob/main/contracts/EthenaMinting.sol) | 295 | The contract where minting and redemption occurs. USDe.sol grants this contract the ability to mint USDe | [`@openzeppelin/ReentrancyGuard.sol`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/ReentrancyGuard.sol) |\n| [StakedUSDe.sol](https://github.com/code-423n4/2023-10-ethena/blob/main/contracts/StakedUSDe.sol) | 130 | Extension of ERC4626. Users stake USDe to receive stUSDe which increases in value as Ethena deposits protocol yield here | [`@openzeppelin/ReentrancyGuard.sol`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/ReentrancyGuard.sol) [`@openzeppelin/ERC20Permit.sol`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/ERC20Permit.sol) [`@openzeppelin/ERC4626.sol`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/ERC4626.sol) |\n| [StakedUSDeV2.sol](https://github.com/code-423n4/2023-10-ethena/blob/main/contracts/StakedUSDeV2.sol) | 76 | Extends StakedUSDe, adds a redemption cooldown.  | |\n| [USDeSilo.sol](https://github.com/code-423n4/2023-10-ethena/blob/main/contracts/USDeSilo.sol) | 20 | Contract to temporarily hold USDe during redemption cooldown  | |\n| [SingleAdminAccessControl.sol](https://github.com/code-423n4/2023-10-ethena/blob/main/contracts/SingleAdminAccessControl.sol) | 43 | EthenaMinting uses SingleAdminAccessControl rather than the standard AccessControl  | |\n\n## Out of Scope\n\nAny file not listed above\n\n# Additional Context\n\n### ERC20 Interactions\n\nstETH and our own USDe stablecoin.\n\n### ERC721 Interactions\n\nOnly our own ERC712 signed order in EthenaMinting.sol.\n\n### Blockchains\n\nEthereum mainnet\n  \n### Trusted Roles\n\n- `USDe` minter - can mint any amount of `USDe` tokens to any address. Expected to be the `EthenaMinting` contract\n- `USDe` owner - can set token `minter` and transfer ownership to another address\n- `USDe` token holder - can not just transfer tokens but burn them and sign permits for others to spend their balance\n- `StakedUSDe` admin - can rescue tokens from the contract and also to redistribute a fully restricted staker's `stUSDe` balance, as well as give roles to other addresses (for example the `FULL_RESTRICTED_STAKER_ROLE` role)\n- `StakedUSDeV2` admin - has all power of \"`StakedUSDe` admin\" and can also call the `setCooldownDuration` method\n- `REWARDER_ROLE` - can transfer rewards into the `StakedUSDe` contract that will be vested over the next 8 hours\n- `BLACKLIST_MANAGER_ROLE` - can do/undo full or soft restriction on a holder of `stUSDe`\n- `SOFT_RESTRICTED_STAKER_ROLE` - address with this role can't stake his `USDe` tokens or get `stUSDe` tokens minted to him\n- `FULL_RESTRICTED_STAKER_ROLE` - address with this role can't burn his `stUSDe` tokens to unstake his `USDe` tokens, neither to transfer `stUSDe` tokens. His balance can be manipulated by the admin of `StakedUSDe`\n- `MINTER_ROLE` - can actually mint `USDe` tokens and also transfer `EthenaMinting`'s token or ETH balance to a custodian address\n- `REDEEMER_ROLE` - can redeem collateral assets for burning `USDe`\n- `EthenaMinting` admin - can set the maxMint/maxRedeem amounts per block and add or remove supported collateral assets and custodian addresses, grant/revoke roles\n- `GATEKEEPER_ROLE` - can disable minting/redeeming of `USDe` and remove `MINTER_ROLE` and `REDEEMER_ROLE` roles from authorized accounts\n\n\n# Attack Ideas (Where to look for bugs)\n\n\n# Main Invariants\n\nProperties that should NEVER be broken under any circumstance:\n\nEthenaMinting.sol - User's signed EIP712 order, if executed, must always execute as signed. ie for mint orders, USDe is minted to user and collateral asset is removed from user based on the signed values.\n\nMax mint per block should never be exceeded.\n\nUSDe.sol - Only the defined minter address can have the ability to mint USDe.\n\n\n\n# Known Issues\n\n- `SOFT_RESTRICTED_STAKER_ROLE` can be bypassed by user buying/selling stUSDe on the open market\n- Line 343 in `EthenaMinting.sol` should be `InvalidAddress()` instead of `InvalidAmount()`\n- `maxRedeemPerBlock` does not limit redemption in case of `REDEEMER_ROLE` key compromise unlike `maxMintPerBlock`, as the attacker can redeem all collateral held in the contract for 0 USDe, which does not increment `maxRedeemPerBlock`. This is by design, as limiting unlimited mints was the primary attack vector we wish to eliminate on key compromise and losing all funds currently in minting contract (which will be a <$200k amount) is an acceptable outcome. \n\n\n## Scoping Details \n\n```\n- If you have a public code repo, please share it here: ethena.fi  \n- How many contracts are in scope?: 6   \n- Total SLoC for these contracts?: 588  \n- How many external imports are there?: 4\n- How many separate interfaces and struct definitions are there for the contracts within scope?: 6\n- Does most of your code generally use composition or inheritance?: Inheritance   \n- How many external calls?:    \n- What is the overall line coverage percentage provided by your tests?: 70%\n- Is this an upgrade of an existing system?: False\n- Check all that apply (e.g. timelock, NFT, AMM, ERC20, rollups, etc.): ERC-20 Token\n- Is there a need to understand a separate part of the codebase / get context in order to audit this part of the protocol?: False  \n- Please describe required context: N/A\n- Does it use an oracle?: No  \n- Describe any novel or unique curve logic or mathematical models your code uses:  None\n- Is this either a fork of or an alternate implementation of another project?: No   \n- Does it use a side-chain?: No, ethereum mainnet only\n- Describe any specific areas you would like addressed: Any attack that results in misplacement of funds or denial of service.\n```\n\n# Tests\n\n## Install\n\n### Foundry unit tests\n\n```bash\nforge build\nforge test\n```\n\nEnable tracing and logging to console via\n\n```\nforge test -vvvv\n```"
    },
    {
      "filename": "contracts/StakedUSDe.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.19;\n\n/**\n * solhint-disable private-vars-leading-underscore\n */\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport \"./SingleAdminAccessControl.sol\";\nimport \"./interfaces/IStakedUSDe.sol\";\n\n/**\n * @title StakedUSDe\n * @notice The StakedUSDe contract allows users to stake USDe tokens and earn a portion of protocol LST and perpetual yield that is allocated\n * to stakers by the Ethena DAO governance voted yield distribution algorithm.  The algorithm seeks to balance the stability of the protocol by funding\n * the protocol's insurance fund, DAO activities, and rewarding stakers with a portion of the protocol's yield.\n */\ncontract StakedUSDe is SingleAdminAccessControl, ReentrancyGuard, ERC20Permit, ERC4626, IStakedUSDe {\n  using SafeERC20 for IERC20;\n\n  /* ------------- CONSTANTS ------------- */\n  /// @notice The role that is allowed to distribute rewards to this contract\n  bytes32 private constant REWARDER_ROLE = keccak256(\"REWARDER_ROLE\");\n  /// @notice The role that is allowed to blacklist and un-blacklist addresses\n  bytes32 private constant BLACKLIST_MANAGER_ROLE = keccak256(\"BLACKLIST_MANAGER_ROLE\");\n  /// @notice The role which prevents an address to stake\n  bytes32 private constant SOFT_RESTRICTED_STAKER_ROLE = keccak256(\"SOFT_RESTRICTED_STAKER_ROLE\");\n  /// @notice The role which prevents an address to transfer, stake, or unstake. The owner of the contract can redirect address staking balance if an address is in full restricting mode.\n  bytes32 private constant FULL_RESTRICTED_STAKER_ROLE = keccak256(\"FULL_RESTRICTED_STAKER_ROLE\");\n  /// @notice The vesting period of lastDistributionAmount over which it increasingly becomes available to stakers\n  uint256 private constant VESTING_PERIOD = 8 hours;\n  /// @notice Minimum non-zero shares amount to prevent donation attack\n  uint256 private constant MIN_SHARES = 1 ether;\n\n  /* ------------- STATE VARIABLES ------------- */\n\n  /// @notice The amount of the last asset distribution from the controller contract into this\n  /// contract + any unvested remainder at that time\n  uint256 public vestingAmount;\n\n  /// @notice The timestamp of the last asset distribution from the controller contract into this contract\n  uint256 public lastDistributionTimestamp;\n\n  /* ------------- MODIFIERS ------------- */\n\n  /// @notice ensure input amount nonzero\n  modifier notZero(uint256 amount) {\n    if (amount == 0) revert InvalidAmount();\n    _;\n  }\n\n  /// @notice ensures blacklist target is not owner\n  modifier notOwner(address target) {\n    if (target == owner()) revert CantBlacklistOwner();\n    _;\n  }\n\n  /* ------------- CONSTRUCTOR ------------- */\n\n  /**\n   * @notice Constructor for StakedUSDe contract.\n   * @param _asset The address of the USDe token.\n   * @param _initialRewarder The address of the initial rewarder.\n   * @param _owner The address of the admin role.\n   *\n   */\n  constructor(IERC20 _asset, address _initialRewarder, address _owner)\n    ERC20(\"Staked USDe\", \"stUSDe\")\n    ERC4626(_asset)\n    ERC20Permit(\"stUSDe\")\n  {\n    if (_owner == address(0) || _initialRewarder == address(0) || address(_asset) == address(0)) {\n      revert InvalidZeroAddress();\n    }\n\n    _grantRole(REWARDER_ROLE, _initialRewarder);\n    _grantRole(DEFAULT_ADMIN_ROLE, _owner);\n  }\n\n  /* ------------- EXTERNAL ------------- */\n\n  /**\n   * @notice Allows the owner to transfer rewards from the controller contract into this contract.\n   * @param amount The amount of rewards to transfer.\n   */\n  function transferInRewards(uint256 amount) external nonReentrant onlyRole(REWARDER_ROLE) notZero(amount) {\n    if (getUnvestedAmount() > 0) revert StillVesting();\n    uint256 newVestingAmount = amount + getUnvestedAmount();\n\n    vestingAmount = newVestingAmount;\n    lastDistributionTimestamp = block.timestamp;\n    // transfer assets from rewarder to this contract\n    IERC20(asset()).safeTransferFrom(msg.sender, address(this), amount);\n\n    emit RewardsReceived(amount, newVestingAmount);\n  }\n\n  /**\n   * @notice Allows the owner (DEFAULT_ADMIN_ROLE) and blacklist managers to blacklist addresses.\n   * @param target The address to blacklist.\n   * @param isFullBlacklisting Soft or full blacklisting level.\n   */\n  function addToBlacklist(address target, bool isFullBlacklisting)\n    external\n    onlyRole(BLACKLIST_MANAGER_ROLE)\n    notOwner(target)\n  {\n    bytes32 role = isFullBlacklisting ? FULL_RESTRICTED_STAKER_ROLE : SOFT_RESTRICTED_STAKER_ROLE;\n    _grantRole(role, target);\n  }\n\n  /**\n   * @notice Allows the owner (DEFAULT_ADMIN_ROLE) and blacklist managers to un-blacklist addresses.\n   * @param target The address to un-blacklist.\n   * @param isFullBlacklisting Soft or full blacklisting level.\n   */\n  function removeFromBlacklist(address target, bool isFullBlacklisting)\n    external\n    onlyRole(BLACKLIST_MANAGER_ROLE)\n    notOwner(target)\n  {\n    bytes32 role = isFullBlacklisting ? FULL_RESTRICTED_STAKER_ROLE : SOFT_RESTRICTED_STAKER_ROLE;\n    _revokeRole(role, target);\n  }\n\n  /**\n   * @notice Allows the owner to rescue tokens accidentally sent to the contract.\n   * Note that the owner cannot rescue USDe tokens because they functionally sit here\n   * and belong to stakers but can rescue staked USDe as they should never actually\n   * sit in this contract and a staker may well transfer them here by accident.\n   * @param token The token to be rescued.\n   * @param amount The amount of tokens to be rescued.\n   * @param to Where to send rescued tokens\n   */\n  function rescueTokens(address token, uint256 amount, address to) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (address(token) == asset()) revert InvalidToken();\n    IERC20(token).safeTransfer(to, amount);\n  }\n\n  /**\n   * @dev Burns the full restricted user amount and mints to the desired owner address.\n   * @param from The address to burn the entire balance, with the FULL_RESTRICTED_STAKER_ROLE\n   * @param to The address to mint the entire balance of \"from\" parameter.\n   */\n  function redistributeLockedAmount(address from, address to) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    if (hasRole(FULL_RESTRICTED_STAKER_ROLE, from) && !hasRole(FULL_RESTRICTED_STAKER_ROLE, to)) {\n      uint256 amountToDistribute = balanceOf(from);\n      _burn(from, amountToDistribute);\n      // to address of address(0) enables burning\n      if (to != address(0)) _mint(to, amountToDistribute);\n\n      emit LockedAmountRedistributed(from, to, amountToDistribute);\n    } else {\n      revert OperationNotAllowed();\n    }\n  }\n\n  /* ------------- PUBLIC ------------- */\n\n  /**\n   * @notice Returns the amount of USDe tokens that are vested in the contract.\n   */\n  function totalAssets() public view override returns (uint256) {\n    return IERC20(asset()).balanceOf(address(this)) - getUnvestedAmount();\n  }\n\n  /**\n   * @notice Returns the amount of USDe tokens that are unvested in the contract.\n   */\n  function getUnvestedAmount() public view returns (uint256) {\n    uint256 timeSinceLastDistribution = block.timestamp - lastDistributionTimestamp;\n\n    if (timeSinceLastDistribution >= VESTING_PERIOD) {\n      return 0;\n    }\n\n    return ((VESTING_PERIOD - timeSinceLastDistribution) * vestingAmount) / VESTING_PERIOD;\n  }\n\n  /// @dev Necessary because both ERC20 (from ERC20Permit) and ERC4626 declare decimals()\n  function decimals() public pure override(ERC4626, ERC20) returns (uint8) {\n    return 18;\n  }\n\n  /* ------------- INTERNAL ------------- */\n\n  /// @notice ensures a small non-zero amount of shares does not remain, exposing to donation attack\n  function _checkMinShares() internal view {\n    uint256 _totalSupply = totalSupply();\n    if (_totalSupply > 0 && _totalSupply < MIN_SHARES) revert MinSharesViolation();\n  }\n\n  /**\n   * @dev Deposit/mint common workflow.\n   * @param caller sender of assets\n   * @param receiver where to send shares\n   * @param assets assets to deposit\n   * @param shares shares to mint\n   */\n  function _deposit(address caller, address receiver, uint256 assets, uint256 shares)\n    internal\n    override\n    nonReentrant\n    notZero(assets)\n    notZero(shares)\n  {\n    if (hasRole(SOFT_RESTRICTED_STAKER_ROLE, caller) || hasRole(SOFT_RESTRICTED_STAKER_ROLE, receiver)) {\n      revert OperationNotAllowed();\n    }\n    super._deposit(caller, receiver, assets, shares);\n    _checkMinShares();\n  }\n\n  /**\n   * @dev Withdraw/redeem common workflow.\n   * @param caller tx sender\n   * @param receiver where to send assets\n   * @param _owner where to burn shares from\n   * @param assets asset amount to transfer out\n   * @param shares shares to burn\n   */\n  function _withdraw(address caller, address receiver, address _owner, uint256 assets, uint256 shares)\n    internal\n    override\n    nonReentrant\n    notZero(assets)\n    notZero(shares)\n  {\n    if (hasRole(FULL_RESTRICTED_STAKER_ROLE, caller) || hasRole(FULL_RESTRICTED_STAKER_ROLE, receiver)) {\n      revert OperationNotAllowed();\n    }\n\n    super._withdraw(caller, receiver, _owner, assets, shares);\n    _checkMinShares();\n  }\n\n  /**\n   * @dev Hook that is called before any transfer of tokens. This includes\n   * minting and burning. Disables transfers from or to of addresses with the FULL_RESTRICTED_STAKER_ROLE role.\n   */\n\n  function _beforeTokenTransfer(address from, address to, uint256) internal virtual override {\n    if (hasRole(FULL_RESTRICTED_STAKER_ROLE, from) && to != address(0)) {\n      revert OperationNotAllowed();\n    }\n    if (hasRole(FULL_RESTRICTED_STAKER_ROLE, to)) {\n      revert OperationNotAllowed();\n    }\n  }\n\n  /**\n   * @dev Remove renounce role access from AccessControl, to prevent users to resign roles.\n   */\n  function renounceRole(bytes32, address) public virtual override {\n    revert OperationNotAllowed();\n  }\n}"
    }
  ]
}