{
  "Title": "[N-03] Include return parameters in NatSpec comments",
  "Content": "\n`@return` tag is missing.\n\n[ProfilePicture.sol#L67-L70](https://github.com/code-423n4/2023-03-canto-identity/blob/077372297fc419ea7688ab62cc3fd4e8f4e24e66/canto-pfp-protocol/src/ProfilePicture.sol#L67-L70)\n\n[Bio.sol#L40-L43](https://github.com/code-423n4/2023-03-canto-identity/blob/077372297fc419ea7688ab62cc3fd4e8f4e24e66/canto-bio-protocol/src/Bio.sol#L40-L43)\n\n[Namespace.sol#L88-L90](https://github.com/code-423n4/2023-03-canto-identity/blob/077372297fc419ea7688ab62cc3fd4e8f4e24e66/canto-namespace-protocol/src/Namespace.sol#L88-L90)\n\n[Utils.sol#L69-L73](https://github.com/code-423n4/2023-03-canto-identity/blob/077372297fc419ea7688ab62cc3fd4e8f4e24e66/canto-namespace-protocol/src/Utils.sol#L69-L73)\n\n[Utils.sol#L219-L222](https://github.com/code-423n4/2023-03-canto-identity/blob/077372297fc419ea7688ab62cc3fd4e8f4e24e66/canto-namespace-protocol/src/Utils.sol#L219-L222)\n\n[Utils.sol#L263-L267](https://github.com/code-423n4/2023-03-canto-identity/blob/077372297fc419ea7688ab62cc3fd4e8f4e24e66/canto-namespace-protocol/src/Utils.sol#L263-L267)\n\n### Recommendations\n\nAdd `@return` tag whenever function returns any value.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-03-canto-identity",
  "Code": [
    {
      "filename": "canto-pfp-protocol/src/ProfilePicture.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\nimport \"../interface/Turnstile.sol\";\nimport \"../interface/ICidNFT.sol\";\n\ncontract ProfilePicture is ERC721 {\n    /*//////////////////////////////////////////////////////////////\n                                 STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Reference to the CID NFT\n    ICidNFT private immutable cidNFT;\n\n    /*//////////////////////////////////////////////////////////////\n                                 STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Data that is stored per PFP\n    struct ProfilePictureData {\n        /// @notice Reference to the NFT contract\n        address nftContract;\n        /// @notice Referenced nft ID\n        uint256 nftID;\n    }\n\n    /// @notice Number of tokens minted\n    uint256 public numMinted;\n\n    /// @notice Stores the pfp data per NFT\n    mapping(uint256 => ProfilePictureData) private pfp;\n\n    /// @notice Name with which the subprotocol is registered\n    string public subprotocolName;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    event PfpAdded(\n        address indexed minter,\n        uint256 indexed pfpNftID,\n        address indexed referencedContract,\n        uint256 referencedNftId\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error TokenNotMinted(uint256 tokenID);\n    error PFPNoLongerOwnedByOriginalOwner(uint256 tokenID);\n    error PFPNotOwnedByCaller(address caller, address nftContract, uint256 nftID);\n\n    /// @notice Initiates CSR on mainnet\n    /// @param _cidNFT Address of the CID NFT\n    /// @param _subprotocolName Name with which the subprotocol is / will be registered in the registry. Registration will not be performed automatically\n    constructor(address _cidNFT, string memory _subprotocolName) ERC721(\"Profile Picture\", \"PFP\") {\n        cidNFT = ICidNFT(_cidNFT);\n        subprotocolName = _subprotocolName;\n        if (block.chainid == 7700) {\n            // Register CSR on Canto mainnnet\n            Turnstile turnstile = Turnstile(0xEcf044C5B4b867CFda001101c617eCd347095B44);\n            turnstile.register(tx.origin);\n        }\n    }\n\n    /// @notice Get the token URI for the specified _id\n    /// @param _id ID to query for\n    /// @dev Reverts if PFP is no longer owned by owner of associated CID NFT\n    function tokenURI(uint256 _id) public view override returns (string memory) {\n        (address nftContract, uint256 nftID) = getPFP(_id);\n        if (nftContract == address(0)) revert PFPNoLongerOwnedByOriginalOwner(_id);\n        return ERC721(nftContract).tokenURI(nftID);\n    }\n\n    /// @notice Mint a new PFP NFT\n    /// @param _nftContract The nft contract address to reference\n    /// @param _nftID The nft ID to reference\n    function mint(address _nftContract, uint256 _nftID) external {\n        uint256 tokenId = ++numMinted;\n        if (ERC721(_nftContract).ownerOf(_nftID) != msg.sender)\n            revert PFPNotOwnedByCaller(msg.sender, _nftContract, _nftID);\n        ProfilePictureData storage pictureData = pfp[tokenId];\n        pictureData.nftContract = _nftContract;\n        pictureData.nftID = _nftID;\n        _mint(msg.sender, tokenId);\n        emit PfpAdded(msg.sender, tokenId, _nftContract, _nftID);\n    }\n\n    /// @notice Query the referenced profile picture\n    /// @dev Checks if the PFP is still owned by the owner of the CID NFT\n    /// @param _pfpID Profile picture NFT ID to query\n    /// @return nftContract The referenced NFT contract (address(0) if no longer owned), nftID The referenced NFT ID\n    function getPFP(uint256 _pfpID) public view returns (address nftContract, uint256 nftID) {\n        if (_ownerOf[_pfpID] == address(0)) revert TokenNotMinted(_pfpID);\n        ProfilePictureData storage pictureData = pfp[_pfpID];\n        nftContract = pictureData.nftContract;\n        nftID = pictureData.nftID;\n        uint256 cidNFTID = cidNFT.getPrimaryCIDNFT(subprotocolName, _pfpID);\n        IAddressRegistry addressRegistry = cidNFT.addressRegistry();\n        if (cidNFTID == 0 || addressRegistry.getAddress(cidNFTID) != ERC721(nftContract).ownerOf(nftID)) {\n            nftContract = address(0);\n            nftID = 0; // Strictly not needed because nftContract has to be always checked, but reset nevertheless to 0\n        }\n    }\n}"
    },
    {
      "filename": "canto-bio-protocol/src/Bio.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\nimport {LibString} from \"solmate/utils/LibString.sol\";\nimport {Base64} from \"solady/utils/Base64.sol\";\nimport \"../interface/Turnstile.sol\";\n\ncontract Bio is ERC721 {\n    /*//////////////////////////////////////////////////////////////\n                                 STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Number of tokens minted\n    uint256 public numMinted;\n\n    /// @notice Stores the bio value per NFT\n    mapping(uint256 => string) public bio;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    event BioAdded(address indexed minter, uint256 indexed nftID, string indexed bio);\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error TokenNotMinted(uint256 tokenID);\n    error InvalidBioLength(uint256 length);\n\n    /// @notice Initiates CSR on mainnet\n    constructor() ERC721(\"Biography\", \"Bio\") {\n        if (block.chainid == 7700) {\n            // Register CSR on Canto mainnnet\n            Turnstile turnstile = Turnstile(0xEcf044C5B4b867CFda001101c617eCd347095B44);\n            turnstile.register(tx.origin);\n        }\n    }\n\n    /// @notice Get the token URI for the specified _id\n    /// @dev Generates an on-chain SVG with a new line after 40 bytes. Line splitting generally supports UTF-8 multibyte characters and emojis, but is not tested for arbitrary UTF-8 characters\n    /// @param _id ID to query for\n    function tokenURI(uint256 _id) public view override returns (string memory) {\n        if (_ownerOf[_id] == address(0)) revert TokenNotMinted(_id);\n        string memory bioText = bio[_id];\n        bytes memory bioTextBytes = bytes(bioText);\n        uint lengthInBytes = bioTextBytes.length;\n        // Insert a new line after 40 characters, taking into account unicode character\n        uint lines = (lengthInBytes - 1) / 40 + 1;\n        string[] memory strLines = new string[](lines);\n        bool prevByteWasContinuation;\n        uint256 insertedLines;\n        // Because we do not split on zero-width joiners, line in bytes can technically be much longer. Will be shortened to the needed length afterwards\n        bytes memory bytesLines = new bytes(80);\n        uint bytesOffset;\n        for (uint i; i < lengthInBytes; ++i) {\n            bytes1 character = bioTextBytes[i];\n            bytesLines[bytesOffset] = character;\n            bytesOffset++;\n            if ((i > 0 && (i + 1) % 40 == 0) || prevByteWasContinuation || i == lengthInBytes - 1) {\n                bytes1 nextCharacter;\n                if (i != lengthInBytes - 1) {\n                    nextCharacter = bioTextBytes[i + 1];\n                }\n                if (nextCharacter & 0xC0 == 0x80) {\n                    // Unicode continuation byte, top two bits are 10\n                    prevByteWasContinuation = true;\n                } else {\n                    // Do not split when the prev. or next character is a zero width joiner. Otherwise, üë®‚Äçüëß‚Äçüë¶ could become üë®>‚Äçüëß‚Äçüë¶\n                    // Furthermore, do not split when next character is skin tone modifier to avoid ü§¶‚Äç‚ôÇÔ∏è\\nüèª\n                    if (\n                        // Note that we do not need to check i < lengthInBytes - 4, because we assume that it's a valid UTF8 string and these prefixes imply that another byte follows\n                        (nextCharacter == 0xE2 && bioTextBytes[i + 2] == 0x80 && bioTextBytes[i + 3] == 0x8D) ||\n                        (nextCharacter == 0xF0 &&\n                            bioTextBytes[i + 2] == 0x9F &&\n                            bioTextBytes[i + 3] == 0x8F &&\n                            uint8(bioTextBytes[i + 4]) >= 187 &&\n                            uint8(bioTextBytes[i + 4]) <= 191) ||\n                        (i >= 2 &&\n                            bioTextBytes[i - 2] == 0xE2 &&\n                            bioTextBytes[i - 1] == 0x80 &&\n                            bioTextBytes[i] == 0x8D)\n                    ) {\n                        prevByteWasContinuation = true;\n                        continue;\n                    }\n                    assembly {\n                        mstore(bytesLines, bytesOffset)\n                    }\n                    strLines[insertedLines++] = string(bytesLines);\n                    bytesLines = new bytes(80);\n                    prevByteWasContinuation = false;\n                    bytesOffset = 0;\n                }\n            }\n        }\n        string\n            memory svg = '<svg xmlns=\"http://www.w3.org/2000/svg\" preserveAspectRatio=\"xMinYMin meet\" viewBox=\"0 0 400 100\"><style>text { font-family: sans-serif; font-size: 12px; }</style>';\n        string memory text = '<text x=\"50%\" y=\"50%\" dominant-baseline=\"middle\" text-anchor=\"middle\">';\n        for (uint i; i < lines; ++i) {\n            text = string.concat(text, '<tspan x=\"50%\" dy=\"20\">', strLines[i], \"</tspan>\");\n        }\n        string memory json = Base64.encode(\n            bytes(\n                string.concat(\n                    '{\"name\": \"Bio #',\n                    LibString.toString(_id),\n                    '\", \"description\": \"',\n                    bioText,\n                    '\", \"image\": \"data:image/svg+xml;base64,',\n                    Base64.encode(bytes(string.concat(svg, text, \"</text></svg>\"))),\n                    '\"}'\n                )\n            )\n        );\n        return string(abi.encodePacked(\"data:application/json;base64,\", json));\n    }\n\n    /// @notice Mint a new Bio NFT\n    /// @param _bio The text to add\n    function mint(string calldata _bio) external {\n        // We check the length in bytes, so will be higher for UTF-8 characters. But sufficient for this check\n        if (bytes(_bio).length == 0 || bytes(_bio).length > 200) revert InvalidBioLength(bytes(_bio).length);\n        uint256 tokenId = ++numMinted;\n        bio[tokenId] = _bio;\n        _mint(msg.sender, tokenId);\n        emit BioAdded(msg.sender, tokenId, _bio);\n    }\n}"
    },
    {
      "filename": "canto-namespace-protocol/src/Namespace.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\nimport {Owned} from \"solmate/auth/Owned.sol\";\nimport {Base64} from \"solady/utils/Base64.sol\";\nimport \"./Tray.sol\";\nimport \"./Utils.sol\";\nimport \"../interface/Turnstile.sol\";\n\ncontract Namespace is ERC721, Owned {\n    /*//////////////////////////////////////////////////////////////\n                                 ADDRESSES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Reference to the Tray NFT\n    Tray public immutable tray;\n\n    /// @notice Reference to the $NOTE TOKEN\n    ERC20 public note;\n\n    /// @notice Wallet that receives the revenue\n    address private revenueAddress;\n\n    /*//////////////////////////////////////////////////////////////\n                                 STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice References the tile for fusing by specifying the tray ID and the index within the tray\n    struct CharacterData {\n        /// @notice ID of the Tray NFT\n        uint256 trayID;\n        /// @notice Offset of the tile within the tray. Valid values 0..TILES_PER_TRAY - 1\n        uint8 tileOffset;\n        /// @notice Emoji modifier for the skin tone. Can have values of 0 (yellow) and 1 - 5 (light to dark). Only supported by some emojis\n        uint8 skinToneModifier;\n    }\n\n    /// @notice Next Namespace ID to mint. We start with minting at ID 1\n    uint256 public nextNamespaceIDToMint;\n\n    /// @notice Maps names to NFT IDs\n    mapping(string => uint256) public nameToToken;\n\n    /// @notice Maps NFT IDs to (ASCII) names\n    mapping(uint256 => string) public tokenToName;\n\n    /// @notice Stores the character data of an NFT\n    mapping(uint256 => Tray.TileData[]) private nftCharacters;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    event NamespaceFused(address indexed fuser, uint256 indexed namespaceId, string indexed name);\n    event RevenueAddressUpdated(address indexed oldRevenueAddress, address indexed newRevenueAddress);\n    event NoteAddressUpdate(address indexed oldNoteAddress, address indexed newNoteAddress);\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error CallerNotAllowedToFuse();\n    error CallerNotAllowedToBurn();\n    error InvalidNumberOfCharacters(uint256 numCharacters);\n    error FusingDuplicateCharactersNotAllowed();\n    error NameAlreadyRegistered(uint256 nftID);\n    error TokenNotMinted(uint256 tokenID);\n    error CannotFuseCharacterWithSkinTone();\n\n    /// @notice Sets the reference to the tray\n    /// @param _tray Address of the tray contract\n    /// @param _note Address of the $NOTE token\n    /// @param _revenueAddress Adress to send the revenue to\n    constructor(\n        address _tray,\n        address _note,\n        address _revenueAddress\n    ) ERC721(\"Namespace\", \"NS\") Owned(msg.sender) {\n        tray = Tray(_tray);\n        note = ERC20(_note);\n        revenueAddress = _revenueAddress;\n        if (block.chainid == 7700) {\n            // Register CSR on Canto mainnnet\n            Turnstile turnstile = Turnstile(0xEcf044C5B4b867CFda001101c617eCd347095B44);\n            turnstile.register(tx.origin);\n        }\n    }\n\n    /// @notice Get the token URI for the specified _id\n    /// @param _id ID to query for\n    function tokenURI(uint256 _id) public view override returns (string memory) {\n        if (_ownerOf[_id] == address(0)) revert TokenNotMinted(_id);\n        string memory json = Base64.encode(\n            bytes(\n                string(\n                    abi.encodePacked(\n                        '{\"name\": \"',\n                        tokenToName[_id],\n                        '\", \"image\": \"data:image/svg+xml;base64,',\n                        Base64.encode(bytes(Utils.generateSVG(nftCharacters[_id], false))),\n                        '\"}'\n                    )\n                )\n            )\n        );\n        return string(abi.encodePacked(\"data:application/json;base64,\", json));\n    }\n\n    /// @notice Fuse a new Namespace NFT with the referenced tiles\n    /// @param _characterList The tiles to use for the fusing\n    function fuse(CharacterData[] calldata _characterList) external {\n        uint256 numCharacters = _characterList.length;\n        if (numCharacters > 13 || numCharacters == 0) revert InvalidNumberOfCharacters(numCharacters);\n        uint256 fusingCosts = 2**(13 - numCharacters) * 1e18;\n        SafeTransferLib.safeTransferFrom(note, msg.sender, revenueAddress, fusingCosts);\n        uint256 namespaceIDToMint = ++nextNamespaceIDToMint;\n        Tray.TileData[] storage nftToMintCharacters = nftCharacters[namespaceIDToMint];\n        bytes memory bName = new bytes(numCharacters * 33); // Used to convert into a string. Can be 33 times longer than the string at most (longest zalgo characters is 33 bytes)\n        uint256 numBytes;\n        // Extract unique trays for burning them later on\n        uint256 numUniqueTrays;\n        uint256[] memory uniqueTrays = new uint256[](_characterList.length);\n        for (uint256 i; i < numCharacters; ++i) {\n            bool isLastTrayEntry = true;\n            uint256 trayID = _characterList[i].trayID;\n            uint8 tileOffset = _characterList[i].tileOffset;\n            // Check for duplicate characters in the provided list. 1/2 * n^2 loop iterations, but n is bounded to 13 and we do not perform any storage operations\n            for (uint256 j = i + 1; j < numCharacters; ++j) {\n                if (_characterList[j].trayID == trayID) {\n                    isLastTrayEntry = false;\n                    if (_characterList[j].tileOffset == tileOffset) revert FusingDuplicateCharactersNotAllowed();\n                }\n            }\n            Tray.TileData memory tileData = tray.getTile(trayID, tileOffset); // Will revert if tileOffset is too high\n            uint8 characterModifier = tileData.characterModifier;\n\n            if (tileData.fontClass != 0 && _characterList[i].skinToneModifier != 0) {\n                revert CannotFuseCharacterWithSkinTone();\n            }\n            \n            if (tileData.fontClass == 0) {\n                // Emoji\n                characterModifier = _characterList[i].skinToneModifier;\n            }\n            bytes memory charAsBytes = Utils.characterToUnicodeBytes(0, tileData.characterIndex, characterModifier);\n            tileData.characterModifier = characterModifier;\n            uint256 numBytesChar = charAsBytes.length;\n            for (uint256 j; j < numBytesChar; ++j) {\n                bName[numBytes + j] = charAsBytes[j];\n            }\n            numBytes += numBytesChar;\n            nftToMintCharacters.push(tileData);\n            // We keep track of the unique trays NFTs (for burning them) and only check the owner once for the last occurence of the tray\n            if (isLastTrayEntry) {\n                uniqueTrays[numUniqueTrays++] = trayID;\n                // Verify address is allowed to fuse\n                address trayOwner = tray.ownerOf(trayID);\n                if (\n                    trayOwner != msg.sender &&\n                    tray.getApproved(trayID) != msg.sender &&\n                    !tray.isApprovedForAll(trayOwner, msg.sender)\n                ) revert CallerNotAllowedToFuse();\n            }\n        }\n        // Set array to the real length (in bytes) to avoid zero bytes in the end when doing the string conversion\n        assembly {\n            mstore(bName, numBytes)\n        }\n        string memory nameToRegister = string(bName);\n        uint256 currentRegisteredID = nameToToken[nameToRegister];\n        if (currentRegisteredID != 0) revert NameAlreadyRegistered(currentRegisteredID);\n        nameToToken[nameToRegister] = namespaceIDToMint;\n        tokenToName[namespaceIDToMint] = nameToRegister;\n\n        for (uint256 i; i < numUniqueTrays; ++i) {\n            tray.burn(uniqueTrays[i]);\n        }\n        _mint(msg.sender, namespaceIDToMint);\n        // Although _mint already emits an event, we additionally emit one because of the name\n        emit NamespaceFused(msg.sender, namespaceIDToMint, nameToRegister);\n    }\n\n    /// @notice Burn a specified Namespace NFT\n    /// @param _id Namespace NFT ID\n    function burn(uint256 _id) external {\n        address nftOwner = ownerOf(_id);\n        if (nftOwner != msg.sender && getApproved[_id] != msg.sender && !isApprovedForAll[nftOwner][msg.sender])\n            revert CallerNotAllowedToBurn();\n        string memory associatedName = tokenToName[_id];\n        delete tokenToName[_id];\n        delete nameToToken[associatedName];\n        _burn(_id);\n    }\n\n    /// @notice Change the address of the $NOTE token\n    /// @param _newNoteAddress New address to use\n    function changeNoteAddress(address _newNoteAddress) external onlyOwner {\n        address currentNoteAddress = address(note);\n        note = ERC20(_newNoteAddress);\n        emit NoteAddressUpdate(currentNoteAddress, _newNoteAddress);\n    }\n\n    /// @notice Change the revenue address\n    /// @param _newRevenueAddress New address to use\n    function changeRevenueAddress(address _newRevenueAddress) external onlyOwner {\n        address currentRevenueAddress = revenueAddress;\n        revenueAddress = _newRevenueAddress;\n        emit RevenueAddressUpdated(currentRevenueAddress, _newRevenueAddress);\n    }\n}"
    },
    {
      "filename": "canto-namespace-protocol/src/Utils.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\nimport \"./Tray.sol\";\nimport {LibString} from \"solmate/utils/LibString.sol\";\n\n/// @notice Utiltities for the on-chain SVG generation of the text data and pseudo randomness\nlibrary Utils {\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error EmojiDoesNotSupportSkinToneModifier(uint16 emojiIndex);\n    error InvalidSkinToneModifierProvided(uint256 characterModifier);\n\n    /// @notice UTF-8 encoding of the squiggle characters. The characters have a different length (1 to 3 bytes)\n    bytes private constant FONT_SQUIGGLE =\n        hex\"CEB1E182A6C688D483D2BDCF9DC9A0D48BCEB9CA9DC699CA85C9B1C9B3CF83CF81CF99C9BECA82C69ACF85CA8BC9AF78E183A7C8A5\";\n\n    /// @notice UTF-8 encoding of possible characters that can be above a letter for Zalgo. All characters have a length of 2 bytes\n    bytes private constant ZALGO_ABOVE_LETTER =\n        hex\"CC80CC81CC82CC83CC84CC85CC86CC87CC88CC89CC8ACC8BCC8CCC8DCC8ECC8FCC90CC91CC92CC93CC94CC95CC9ACC9BCCBDCCBECCBFCD80CD81CD82CD83CD84CD86CD8ACD8BCD8CCD90CD91CD92CD97CD98CD9BCD9DCD9ECDA0CDA1\";\n\n    /// @notice Number of characters that can be above a letter for Zalgo\n    uint256 private constant ZALGO_NUM_ABOVE = 46;\n\n    /// @notice UTF-8 encoding of possible characters that can be below a letter for Zalgo. All characters have a length of 2 bytes\n    bytes private constant ZALGO_BELOW_LETTER =\n        hex\"CC96CC97CC98CC99CC9CCC9DCC9ECC9FCCA0CCA1CCA2CCA3CCA4CCA5CCA6CCA7CCA8CCA9CCAACCABCCACCCADCCAECCAFCCB0CCB1CCB2CCB3CCB9CCBACCBBCCBCCD85CD87CD88CD89CD8DCD8ECD93CD94CD95CD96CD99CD9ACD9CCD9FCDA2\";\n\n    /// @notice Number of characters that can be below a letter for Zalgo\n    uint256 private constant ZALGO_NUM_BELOW = 47;\n\n    /// @notice UTF-8 encoding of possible characters that can be over a letter (i.e., in the middle) for Zalgo. All characters have a length of 2 bytes\n    bytes private constant ZALGO_OVER_LETTER = hex\"CCB4CCB5CCB6CCB7CCB8\";\n\n    /// @notice Number of characters that can be over a letter for Zalgo\n    uint256 private constant ZALGO_NUM_OVER = 5;\n\n    /// @notice UTF-8 encoding of all supported emojis. They are sorted by their length in bytes (all with 3 bytes first, then all with four bytes, ...)\n    /// For emojis with the same length, the emojis that do not support skin tone modifier come first.\n    /// @dev This string is generated by the script utils/gen_emoji_string.py\n    bytes private constant EMOJIS =\n        hex\"E29CA8E29C85E29D97E29AA1E29895E2AD90E29D8CE29ABDE29D93E28FB0E2AD95E29AABE29ABEE29894E29AAAE29C8BE29C8AF09F9882F09FA4A3F09F98ADF09F9898F09FA5B0F09F988DF09F988AF09F8E89F09F9881F09F9295F09FA5BAF09F9885F09F94A5F09F9984F09F9886F09FA497F09F9889F09F8E82F09FA494F09F9982F09F98B3F09FA5B3F09F988EF09F929CF09F9894F09F9296F09F9180F09F988BF09F988FF09F98A2F09F9297F09F98A9F09F92AFF09F8CB9F09F929EF09F8E88F09F9299F09F9883F09F98A1F09F9290F09F989CF09F9988F09F9884F09FA4A4F09FA4AAF09F9880F09F928BF09F9280F09F9294F09F988CF09F9293F09FA4A9F09F9983F09F98ACF09F98B1F09F98B4F09FA4ADF09F9890F09F8C9EF09F9892F09F9887F09F8CB8F09F9888F09F8EB6F09F8E8AF09FA5B5F09F989EF09F929AF09F96A4F09F92B0F09F989AF09F9191F09F8E81F09F92A5F09F9891F09FA5B4F09F92A9F09FA4AEF09F98A4F09FA4A2F09F8C9FF09F98A5F09F8C88F09F929BF09F989DF09F98ABF09F98B2F09F94B4F09F8CBBF09FA4AFF09FA4ACF09F9895F09F8D80F09F92A6F09FA68BF09FA4A8F09F8CBAF09F98B9F09F8CB7F09F929DF09F92A4F09F90B0F09F9893F09F9298F09F8DBBF09F989FF09F98A3F09FA790F09F98A0F09FA4A0F09F98BBF09F8C99F09F989BF09F998AF09FA7A1F09FA4A1F09FA4ABF09F8CBCF09FA582F09F98B7F09FA493F09FA5B6F09F98B6F09F9896F09F8EB5F09F9899F09F8D86F09FA491F09F9897F09F90B6F09F8D93F09F9185F09F9184F09F8CBFF09F9AA8F09F93A3F09F8D91F09F8D83F09F98AEF09F928EF09F93A2F09F8CB1F09F9981F09F8DB7F09F98AAF09F8C9AF09F8F86F09F8D92F09F9289F09F92A2F09F9B92F09F98B8F09F90BEF09F9A80F09F8EAFF09F8DBAF09F938CF09F93B7F09F92A8F09F8D95F09F8FA0F09F93B8F09F9087F09F9AA9F09F98B0F09F8C8AF09F9095F09F92ABF09F98B5F09F8EA4F09F8FA1F09FA580F09FA4A7F09F8DBEF09F8DB0F09F8D81F09F98AFF09F928CF09F92B8F09FA781F09F98BAF09F92A7F09F92A3F09FA490F09F8D8EF09F90B7F09F90A5F09F938DF09F8E80F09FA587F09F8C9DF09F94ABF09F90B1F09F90A3F09F8EA7F09F929FF09F91B9F09F928DF09F8DBCF09F92A1F09F98BDF09F8D8AF09F98A8F09F8DABF09FA7A2F09FA495F09F9AABF09F8EBCF09F90BBF09F93B2F09F91BBF09F91BFF09F8CAEF09F8DADF09F909FF09F90B8F09F909DF09F9088F09F94B5F09F94AAF09F98A7F09F8C84F09F98BEF09F93B1F09F8D87F09F8CB4F09F90A2F09F8C83F09F91BDF09F8D8CF09F93BAF09F9494F09F8C85F09FA684F09F8EA5F09F8D8BF09FA59AF09F92B2F09F939AF09F9094F09F8EB8F09FA583F09F98BFF09F9A97F09F8C8EF09F948AF09FA685F09F9ABFF09FA686F09F8D89F09F8DACF09FA7B8F09F8DA8F09F939DF09F93A9F09F92B5F09F92ADF09F8C8DF09F8DBFF09FA7BFF09F8F80F09F8D8FF09F8CB3F09F9989F09F98A6F09F8DB9F09F8DA6F09F9B91F09F8D94F09F8D82F09F9092F09F8DAAF09F9980F09F8D97F09F8CA0F09F8EACF09F8CB5F09F8D84F09F9090F09F8DA9F09FA681F09F939EF09F8D85F09F908DF09F92ACF09FA5A4F09F98BCF09F8CBEF09FA780F09F8EAEF09FA7A0F09F8C8FF09F949DF09F8C89F09FA492F09F9197F09F8CB2F09F8D9CF09F90A6F09F8DAFF09F8F85F09F90BCF09F9284F09F91BAF09F949EF09F8E86F09F8EA8F09F8D9EF09F8E87F09FA69CF09F9091F09F9099F09FA68DF09F9497F09F9396F09F94B9F09FA593F09FA592F09F8DB8F09F918DF09F998FF09FA4A6F09FA4B7F09F918FF09F918CF09F92AAF09F9189F09FA49EF09F998CF09F9187F09F998BF09F9188F09F918BF09F9695F09F9283F09F918AF09F8F83F09FA498F09FA49DF09FA499F09F9AB6F09F9285F09FA49FF09F918EF09F9987F09F91B6F09FA4B2F09F9186F09F95BAF09F9281F09F9985F09FA79AF09FA4B8F09F9190F09FA49AF09F91BCF09F91A7F09FA49CF09FA4B0F09FA798F09F9986F09F91B8F09F91A6F09F9B8CF09FA49BF09F91AEE29DA4EFB88FE298BAEFB88FE299A5EFB88FE29DA3EFB88FE29C8CEFB88FE29880EFB88FE298B9EFB88FE280BCEFB88FE298A0EFB88FE29EA1EFB88FE29AA0EFB88FE29C94EFB88FE2989DEFB88FE2AC87EFB88FE29D84EFB88FE28189EFB88FE2988EEFB88FE29C9DEFB88FE29898EFB88FE29C88EFB88FE296B6EFB88FE29C8DEFB88FE2AC85EFB88FE29881EFB88FE29891EFB88FE299BBEFB88FF09F9181EFB88FF09F9690EFB88FF09F97A3EFB88FF09F8CA7EFB88FF09F958AEFB88FF09F8FB5EFB88FF09F8F96EFB88FF09F87BAF09F87B8F09F87A7F09F87B7F09F87BAF09F87B2F09F8FB3EFB88FE2808DF09F8C88\";\n\n    /// @notice These constants are used to efficiently parse the UTF-8 encoding of the emojis. They enable constant time lookup of any character.\n    /// This is done by storing the byte offset where each group (with the same length) starts and by storing the amount per group.\n    /// Furthermore, we store the number of emojis where the skin tone can be modified such that we can revert when this is not supported (and would result in wrong characters).\n\n    /// @notice LE refers to \"less or equal than\", i.e. we store the amount of emojis that are less or equal than 3, 4, 6, 7, 8 bytes\n    uint256 private constant EMOJIS_LE_THREE_BYTES = 17;\n    uint256 private constant EMOJIS_LE_FOUR_BYTES = 383;\n    uint256 private constant EMOJIS_LE_SIX_BYTES = 409;\n    uint256 private constant EMOJIS_LE_SEVEN_BYTES = 416;\n    uint256 private constant EMOJIS_LE_EIGHT_BYTES = 419;\n    // uint256 constant EMOJIS_LE_FOURTEEN_BYTES = 420;\n\n    /// @notice Number of emojis where the skin tone can be modified for three and four bytes\n    uint256 private constant EMOJIS_MOD_SKIN_TONE_THREE_BYTES = 2;\n    uint256 private constant EMOJIS_MOD_SKIN_TONE_FOUR_BYTES = 47;\n    // 0 for 7, 8, 14 bytes\n\n    /// @notice Byte offset where the groups start\n    uint256 private constant EMOJIS_BYTE_OFFSET_FOUR_BYTES = 51; // 17 * 3\n    uint256 private constant EMOJIS_BYTE_OFFSET_SIX_BYTES = 1515; // 17 * 3 + 366 * 4\n    uint256 private constant EMOJIS_BYTE_OFFSET_SEVEN_BYTES = 1671; // 17 * 3 + 366 * 4 + 26 * 6\n    uint256 private constant EMOJIS_BYTE_OFFSET_EIGHT_BYTES = 1720; // 17 * 3 + 366 * 4 + 26 * 6 + 7 * 7\n    uint256 private constant EMOJIS_BYTE_OFFSET_FOURTEEN_BYTES = 1744; // 17 * 3 + 366 * 4 + 26 * 6 + 7 * 7 + 3 * 8\n\n    /// @notice Convert a given font class, character index, and a seed (for font classes with randomness) to their Unicode representation as bytes\n    /// @param _fontClass The class to convert\n    /// @param _characterIndex Index within the class\n    /// @param _characterModifier Some characters have numeric modifiers (skin tone modifier for emojis, seed generated at minting for zalgo)\n    function characterToUnicodeBytes(\n        uint8 _fontClass,\n        uint16 _characterIndex,\n        uint256 _characterModifier\n    ) internal pure returns (bytes memory) {\n        if (_fontClass == 0) {\n            // Emojis\n            uint256 byteOffset;\n            uint256 numBytes;\n            bool supportsSkinToneModifier;\n            if (_characterIndex < EMOJIS_LE_THREE_BYTES) {\n                numBytes = 3;\n                byteOffset = _characterIndex * 3;\n                supportsSkinToneModifier = _characterIndex >= EMOJIS_LE_THREE_BYTES - EMOJIS_MOD_SKIN_TONE_THREE_BYTES;\n            } else if (_characterIndex < EMOJIS_LE_FOUR_BYTES) {\n                numBytes = 4;\n                byteOffset = EMOJIS_BYTE_OFFSET_FOUR_BYTES + (_characterIndex - EMOJIS_LE_THREE_BYTES) * 4;\n                supportsSkinToneModifier = _characterIndex >= EMOJIS_LE_FOUR_BYTES - EMOJIS_MOD_SKIN_TONE_FOUR_BYTES;\n            } else if (_characterIndex < EMOJIS_LE_SIX_BYTES) {\n                numBytes = 6;\n                byteOffset = EMOJIS_BYTE_OFFSET_SIX_BYTES + (_characterIndex - EMOJIS_LE_FOUR_BYTES) * 6;\n            } else if (_characterIndex < EMOJIS_LE_SEVEN_BYTES) {\n                numBytes = 7;\n                byteOffset = EMOJIS_BYTE_OFFSET_SEVEN_BYTES + (_characterIndex - EMOJIS_LE_SIX_BYTES) * 7;\n            } else if (_characterIndex < EMOJIS_LE_EIGHT_BYTES) {\n                numBytes = 8;\n                byteOffset = EMOJIS_BYTE_OFFSET_EIGHT_BYTES + (_characterIndex - EMOJIS_LE_SEVEN_BYTES) * 8;\n            } else {\n                numBytes = 14;\n                byteOffset = EMOJIS_BYTE_OFFSET_FOURTEEN_BYTES + (_characterIndex - EMOJIS_LE_EIGHT_BYTES) * 14;\n            }\n            bytes memory character = abi.encodePacked(\n                EMOJIS[byteOffset],\n                EMOJIS[byteOffset + 1],\n                EMOJIS[byteOffset + 2]\n            );\n            for (uint256 i = 3; i < numBytes; ++i) {\n                character = abi.encodePacked(character, EMOJIS[byteOffset + i]);\n            }\n            if (_characterModifier != 0) {\n                if (!supportsSkinToneModifier) revert EmojiDoesNotSupportSkinToneModifier(_characterIndex);\n                if (_characterModifier == 1) {\n                    character = abi.encodePacked(character, hex\"F09F8FBB\");\n                } else if (_characterModifier == 2) {\n                    character = abi.encodePacked(character, hex\"F09F8FBC\");\n                } else if (_characterModifier == 3) {\n                    character = abi.encodePacked(character, hex\"F09F8FBD\");\n                } else if (_characterModifier == 4) {\n                    character = abi.encodePacked(character, hex\"F09F8FBE\");\n                } else if (_characterModifier == 5) {\n                    character = abi.encodePacked(character, hex\"F09F8FBF\");\n                } else {\n                    revert InvalidSkinToneModifierProvided(_characterModifier);\n                }\n            }\n            return character;\n        } else if (_fontClass == 1) {\n            // Basic, sans-serif text\n            uint8 asciiStartingIndex = 97; // Starting index for (lowercase) characters\n            if (_characterIndex > 25) {\n                asciiStartingIndex = 22; // Starting index for (lowercase) characters - 25\n            }\n            return abi.encodePacked(bytes1(asciiStartingIndex + uint8(_characterIndex)));\n        } else if (_fontClass == 7) {\n            // Zalgo\n            uint8 asciiStartingIndex = 97;\n            uint256 numAbove = (_characterModifier % 7) + 1;\n            // We do not reuse the same seed for the following generations to avoid any symmetries, e.g. that 2 chars above would also always result in 2 chars below\n            _characterModifier = iteratePRNG(_characterModifier);\n            uint256 numMiddle = _characterModifier % 2;\n            _charact"
    }
  ]
}