{
  "Title": "H-3: CurveTricryptoOracle#getPrice contains math error that causes LP to be priced completely wrong",
  "Content": "# Issue H-3: CurveTricryptoOracle#getPrice contains math error that causes LP to be priced completely wrong \n\nSource: https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/100 \n\n## Found by \n0x52, Kow\n\nCurveTricryptoOracle#getPrice incorrectly divides the LP price by the price of ETH which causes it to return the price of LP in terms of ETH instead of USD\n\n## Vulnerability Detail\n\n[CurveTricryptoOracle.sol#L57-L62](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/oracle/CurveTricryptoOracle.sol#L57-L62)\n\n                (lpPrice(\n                    virtualPrice,\n                    base.getPrice(tokens[1]),\n                    ethPrice,\n                    base.getPrice(tokens[0])\n                ) * 1e18) / ethPrice;\n\nAfter the LP price has been calculated in USD it is mistakenly divided by the price of ETH causing the contract to return the LP price in terms of ETH rather than USD. This leads to LP that is massively undervalued causing positions which are actually heavily over collateralized to be liquidated.\n\n## Impact\n\nHealthy positions are liquidated due to incorrect LP pricing\n\n## Code Snippet\n\n[CurveTricryptoOracle.sol#L48-L65](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/oracle/CurveTricryptoOracle.sol#L48-L65)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nDon't divide the price by the price of ETH\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n2 comment(s) were left on this issue during the judging contest.\n\n**0xyPhilic** commented:\n> invalid because lpPrice is considered in ETH so dividing by ETH/USD price returns the final result in USD\n\n**Kral01** commented:\n> there is a precision value\n\n\n\n**Gornutz**\n\nJudges accurately state why the division by ETH/USD is required to return the proper USD value.\n\n**Shogoki**\n\nClosing in regards to other judges and sponsors comments.\n\n**IAm0x52**\n\nThis is valid. The code being used here was borrowed from the Sentiment [CurveTriCryptoOracle](https://arbiscan.io/address/0x4e828a117ddc3e4dd919b46c90d4e04678a05504#code), which is specifically meant to return the price in terms of ETH. This oracle is meant to return the valuation in USD which means the division by the price of ETH needs to be dropped.\n\n**Shogoki**\n\n> This is valid. The code being used here was borrowed from the Sentiment [CurveTriCryptoOracle](https://arbiscan.io/address/0x4e828a117ddc3e4dd919b46c90d4e04678a05504#code), which is specifically meant to return the price in terms of ETH. This oracle is meant to return the valuation in USD which means the division by the price of ETH needs to be dropped.\n\nMaybe was a bit quick in closing. Will reopen it and we will take a deeper look at it.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/104",
  "Code": [
    {
      "filename": "blueberry-core/contracts/oracle/CurveTricryptoOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"./CurveBaseOracle.sol\";\n\n/// @title Curve Volatile Oracle\n/// @author BlueberryProtocol \n/// @notice Oracle contract which privides price feeds of Curve volatile pool LP tokens\ncontract CurveTricryptoOracle is CurveBaseOracle {\n    \n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n    \n    /// @notice Constructor initializes the CurveBaseOracle with the provided parameters.\n    /// @param base_ The address of the base oracle.\n    /// @param addressProvider_ The address of the curve address provider.\n    constructor(\n        IBaseOracle base_,\n        ICurveAddressProvider addressProvider_\n    ) CurveBaseOracle(base_, addressProvider_) {}\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Overrides the base oracle's reentrancy check.\n    /// @param _pool The address of the pool to check.\n    /// @param (unnamed) Unused parameter for overriding.\n    function _checkReentrant(address _pool, uint256) internal override {\n        ICurvePool pool = ICurvePool(_pool);\n        pool.claim_admin_fees();\n    }\n\n    /// @notice Returns the USD value of the specified Curve LP token with 18 decimals of precision.\n    /// @dev If the length of tokens is not 3, the function will revert.\n    /// @param crvLp The ERC-20 Curve LP token address.\n    /// @return The USD value of the Curve LP token.\n    function getPrice(address crvLp) external override returns (uint256) {\n        (address pool, address[] memory tokens, uint256 virtualPrice) = _getPoolInfo(crvLp);\n        _checkReentrant(pool, tokens.length);\n\n        /// Check if the token list length is 3 (tricrypto)\n        if (tokens.length == 3) {\n            /// tokens[2] is WETH\n            uint256 ethPrice = base.getPrice(tokens[2]);\n            return\n                (lpPrice(\n                    virtualPrice,\n                    base.getPrice(tokens[1]),\n                    ethPrice,\n                    base.getPrice(tokens[0])\n                ) * 1e18) / ethPrice;\n        }\n        revert BlueBerryErrors.ORACLE_NOT_SUPPORT_LP(crvLp);\n    }\n\n    /// @dev Calculates the LP price using provided token prices and virtual price.\n    /// @param virtualPrice The virtual price from the pool.\n    /// @param p1 Price of the first token.\n    /// @param p2 Price of the second token (usually ETH).\n    /// @param p3 Price of the third token.\n    /// @return The calculated LP price.\n    function lpPrice(\n        uint256 virtualPrice,\n        uint256 p1,\n        uint256 p2,\n        uint256 p3\n    ) internal pure returns (uint256) {\n        return (3 * virtualPrice * cubicRoot(((p1 * p2) / 1e18) * p3)) / 1e18;\n    }\n\n    /// @dev Calculates the cubic root of the provided value using the Newton-Raphson method.\n    /// @param x The value to find the cubic root for.\n    /// @return The calculated cubic root.\n\n    function cubicRoot(uint256 x) internal pure returns (uint256) {\n        uint256 D = x / 1e18;\n        for (uint256 i; i < 255; ) {\n            uint256 D_prev = D;\n            D = (D * (2e18 + ((((x / D) * 1e18) / D) * 1e18) / D)) / (3e18);\n            uint256 diff = (D > D_prev) ? D - D_prev : D_prev - D;\n            if (diff < 2 || diff * 1e18 < D) return D;\n            unchecked {\n                ++i;\n            }\n        }\n        revert(\"Did Not Converge\");\n    }\n}"
    },
    {
      "filename": "blueberry-core/contracts/oracle/CurveTricryptoOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"./CurveBaseOracle.sol\";\n\n/// @title Curve Volatile Oracle\n/// @author BlueberryProtocol \n/// @notice Oracle contract which privides price feeds of Curve volatile pool LP tokens\ncontract CurveTricryptoOracle is CurveBaseOracle {\n    \n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n    \n    /// @notice Constructor initializes the CurveBaseOracle with the provided parameters.\n    /// @param base_ The address of the base oracle.\n    /// @param addressProvider_ The address of the curve address provider.\n    constructor(\n        IBaseOracle base_,\n        ICurveAddressProvider addressProvider_\n    ) CurveBaseOracle(base_, addressProvider_) {}\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Overrides the base oracle's reentrancy check.\n    /// @param _pool The address of the pool to check.\n    /// @param (unnamed) Unused parameter for overriding.\n    function _checkReentrant(address _pool, uint256) internal override {\n        ICurvePool pool = ICurvePool(_pool);\n        pool.claim_admin_fees();\n    }\n\n    /// @notice Returns the USD value of the specified Curve LP token with 18 decimals of precision.\n    /// @dev If the length of tokens is not 3, the function will revert.\n    /// @param crvLp The ERC-20 Curve LP token address.\n    /// @return The USD value of the Curve LP token.\n    function getPrice(address crvLp) external override returns (uint256) {\n        (address pool, address[] memory tokens, uint256 virtualPrice) = _getPoolInfo(crvLp);\n        _checkReentrant(pool, tokens.length);\n\n        /// Check if the token list length is 3 (tricrypto)\n        if (tokens.length == 3) {\n            /// tokens[2] is WETH\n            uint256 ethPrice = base.getPrice(tokens[2]);\n            return\n                (lpPrice(\n                    virtualPrice,\n                    base.getPrice(tokens[1]),\n                    ethPrice,\n                    base.getPrice(tokens[0])\n                ) * 1e18) / ethPrice;\n        }\n        revert BlueBerryErrors.ORACLE_NOT_SUPPORT_LP(crvLp);\n    }\n\n    /// @dev Calculates the LP price using provided token prices and virtual price.\n    /// @param virtualPrice The virtual price from the pool.\n    /// @param p1 Price of the first token.\n    /// @param p2 Price of the second token (usually ETH).\n    /// @param p3 Price of the third token.\n    /// @return The calculated LP price.\n    function lpPrice(\n        uint256 virtualPrice,\n        uint256 p1,\n        uint256 p2,\n        uint256 p3\n    ) internal pure returns (uint256) {\n        return (3 * virtualPrice * cubicRoot(((p1 * p2) / 1e18) * p3)) / 1e18;\n    }\n\n    /// @dev Calculates the cubic root of the provided value using the Newton-Raphson method.\n    /// @param x The value to find the cubic root for.\n    /// @return The calculated cubic root.\n\n    function cubicRoot(uint256 x) internal pure returns (uint256) {\n        uint256 D = x / 1e18;\n        for (uint256 i; i < 255; ) {\n            uint256 D_prev = D;\n            D = (D * (2e18 + ((((x / D) * 1e18) / D) * 1e18) / D)) / (3e18);\n            uint256 diff = (D > D_prev) ? D - D_prev : D_prev - D;\n            if (diff < 2 || diff * 1e18 < D) return D;\n            unchecked {\n                ++i;\n            }\n        }\n        revert(\"Did Not Converge\");\n    }\n}"
    }
  ]
}