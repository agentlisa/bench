{
  "Title": "[L08] Unchecked casting from uint256 to int256",
  "Content": "The `BasePool` contract [uses the `FixidityLib` to perform fixed point arithmetic with protection against overflow](https://github.com/pooltogether/pooltogether-contracts/blob/78ac6863f4616269f7d04a0ddd1d60bdfc454937/contracts/BasePool.sol#L27).\n\n\nThe `newFixed` function of the library [accepts an `int256`](https://github.com/DeltaCamp/Fixidity/blob/edf533f77df43b16a7b92f17af7a8930db01f293/contracts/FixidityLib.sol#L149) as the parameter so the `uint256` variables `_feeFraction` and `_grossWinnings` first [need to be cast into `int256` values](https://github.com/pooltogether/pooltogether-contracts/blob/78ac6863f4616269f7d04a0ddd1d60bdfc454937/contracts/BasePool.sol#L410-L412).\n\n\nIf one of those parameters is higher than the maximum `int256`, the cast will overflow. This realistically should not occur but it is nevertheless good coding practice to explicitly check any assumptions.\n\n\nConsider ensuring that neither parameter exceeds the maximum `int256`.\n\n\n**Update**: *Fixed in [PR#12](https://github.com/pooltogether/pooltogether-contracts/pull/12/commits/35cbd7dbf305bfd6684ee2629bfe7d20db92cba6). The `_grossWinnings` variable is now capped at the maximum safe value. The `_feeFraction` was already restricted by the contract logic to be less than 1e18 so it could not cause an overflow.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/BasePool.sol",
      "content": "/**\nCopyright 2019 PoolTogether LLC\n\nThis file is part of PoolTogether.\n\nPoolTogether is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation under version 3 of the License.\n\nPoolTogether is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with PoolTogether.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity 0.5.12;\n\nimport \"@openzeppelin/contracts/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/access/Roles.sol\";\nimport \"./compound/ICErc20.sol\";\nimport \"./DrawManager.sol\";\nimport \"fixidity/contracts/FixidityLib.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\n\n/**\n * @title The Pool contract\n * @author Brendan Asselstine\n * @notice This contract allows users to pool deposits into Compound and win the accrued interest in periodic draws.\n * Funds are immediately deposited and withdrawn from the Compound cToken contract.\n * Draws go through three stages: open, committed and rewarded in that order.\n * Only one draw is ever in the open stage.  Users deposits are always added to the open draw.  Funds in the open Draw are that user's open balance.\n * When a Draw is committed, the funds in it are moved to a user's committed total and the total committed balance of all users is updated.\n * When a Draw is rewarded, the gross winnings are the accrued interest since the last reward (if any).  A winner is selected with their chances being\n * proportional to their committed balance vs the total committed balance of all users.\n *\n *\n * With the above in mind, there is always an open draw and possibly a committed draw.  The progression is:\n *\n * Step 1: Draw 1 Open\n * Step 2: Draw 2 Open | Draw 1 Committed\n * Step 3: Draw 3 Open | Draw 2 Committed | Draw 1 Rewarded\n * Step 4: Draw 4 Open | Draw 3 Committed | Draw 2 Rewarded\n * Step 5: Draw 5 Open | Draw 4 Committed | Draw 3 Rewarded\n * Step X: ...\n */\ncontract BasePool is Initializable, ReentrancyGuard {\n  using DrawManager for DrawManager.State;\n  using SafeMath for uint256;\n  using Roles for Roles.Role;\n\n  bytes32 private constant ROLLED_OVER_ENTROPY_MAGIC_NUMBER = bytes32(uint256(1));\n\n  /**\n   * Emitted when a user deposits into the Pool.\n   * @param sender The purchaser of the tickets\n   * @param amount The size of the deposit\n   */\n  event Deposited(address indexed sender, uint256 amount);\n\n  /**\n   * Emitted when a user deposits into the Pool and the deposit is immediately committed\n   * @param sender The purchaser of the tickets\n   * @param amount The size of the deposit\n   */\n  event DepositedAndCommitted(address indexed sender, uint256 amount);\n\n  /**\n   * Emitted when Sponsors have deposited into the Pool\n   * @param sender The purchaser of the tickets\n   * @param amount The size of the deposit\n   */\n  event SponsorshipDeposited(address indexed sender, uint256 amount);\n\n  /**\n   * Emitted when an admin has been added to the Pool.\n   * @param admin The admin that was added\n   */\n  event AdminAdded(address indexed admin);\n\n  /**\n   * Emitted when an admin has been removed from the Pool.\n   * @param admin The admin that was removed\n   */\n  event AdminRemoved(address indexed admin);\n\n  /**\n   * Emitted when a user withdraws from the pool.\n   * @param sender The user that is withdrawing from the pool\n   * @param amount The amount that the user withdrew\n   */\n  event Withdrawn(address indexed sender, uint256 amount);\n\n  /**\n   * Emitted when a new draw is opened for deposit.\n   * @param drawId The draw id\n   * @param feeBeneficiary The fee beneficiary for this draw\n   * @param secretHash The committed secret hash\n   * @param feeFraction The fee fraction of the winnings to be given to the beneficiary\n   */\n  event Opened(\n    uint256 indexed drawId,\n    address indexed feeBeneficiary,\n    bytes32 secretHash,\n    uint256 feeFraction\n  );\n\n  /**\n   * Emitted when a draw is committed.\n   * @param drawId The draw id\n   */\n  event Committed(\n    uint256 indexed drawId\n  );\n\n  /**\n   * Emitted when a draw is rewarded.\n   * @param drawId The draw id\n   * @param winner The address of the winner\n   * @param entropy The entropy used to select the winner\n   * @param winnings The net winnings given to the winner\n   * @param fee The fee being given to the draw beneficiary\n   */\n  event Rewarded(\n    uint256 indexed drawId,\n    address indexed winner,\n    bytes32 entropy,\n    uint256 winnings,\n    uint256 fee\n  );\n\n  /**\n   * Emitted when the fee fraction is changed.  Takes effect on the next draw.\n   * @param feeFraction The next fee fraction encoded as a fixed point 18 decimal\n   */\n  event NextFeeFractionChanged(uint256 feeFraction);\n\n  /**\n   * Emitted when the next fee beneficiary changes.  Takes effect on the next draw.\n   * @param feeBeneficiary The next fee beneficiary\n   */\n  event NextFeeBeneficiaryChanged(address indexed feeBeneficiary);\n\n  /**\n   * Emitted when an admin pauses the contract\n   */\n  event Paused(address indexed sender);\n\n  /**\n   * Emitted when an admin unpauses the contract\n   */\n  event Unpaused(address indexed sender);\n\n  /**\n   * Emitted when the draw is rolled over in the event that the secret is forgotten.\n   */\n  event RolledOver(uint256 indexed drawId);\n\n  struct Draw {\n    uint256 feeFraction; //fixed point 18\n    address feeBeneficiary;\n    uint256 openedBlock;\n    bytes32 secretHash;\n    bytes32 entropy;\n    address winner;\n    uint256 netWinnings;\n    uint256 fee;\n  }\n\n  /**\n   * The Compound cToken that this Pool is bound to.\n   */\n  ICErc20 public cToken;\n\n  /**\n   * The fee beneficiary to use for subsequent Draws.\n   */\n  address public nextFeeBeneficiary;\n\n  /**\n   * The fee fraction to use for subsequent Draws.\n   */\n  uint256 public nextFeeFraction;\n\n  /**\n   * The total of all balances\n   */\n  uint256 public accountedBalance;\n\n  /**\n   * The total deposits and winnings for each user.\n   */\n  mapping (address => uint256) balances;\n\n  /**\n   * A mapping of draw ids to Draw structures\n   */\n  mapping(uint256 => Draw) draws;\n\n  /**\n   * A structure that is used to manage the user's odds of winning.\n   */\n  DrawManager.State drawState;\n\n  /**\n   * A structure containing the administrators\n   */\n  Roles.Role admins;\n\n  /**\n   * Whether the contract is paused\n   */\n  bool public paused;\n\n  /**\n   * @notice Initializes a new Pool contract.\n   * @param _owner The owner of the Pool.  They are able to change settings and are set as the owner of new lotteries.\n   * @param _cToken The Compound Finance MoneyMarket contract to supply and withdraw tokens.\n   * @param _feeFraction The fraction of the gross winnings that should be transferred to the owner as the fee.  Is a fixed point 18 number.\n   * @param _feeBeneficiary The address that will receive the fee fraction\n   */\n  function init (\n    address _owner,\n    address _cToken,\n    uint256 _feeFraction,\n    address _feeBeneficiary\n  ) public initializer {\n    require(_owner != address(0), \"owner cannot be the null address\");\n    require(_cToken != address(0), \"money market address is zero\");\n    cToken = ICErc20(_cToken);\n    _addAdmin(_owner);\n    _setNextFeeFraction(_feeFraction);\n    _setNextFeeBeneficiary(_feeBeneficiary);\n  }\n\n  /**\n   * @notice Opens a new Draw.\n   * @param _secretHash The secret hash to commit to the Draw.\n   */\n  function open(bytes32 _secretHash) internal {\n    drawState.openNextDraw();\n    draws[drawState.openDrawIndex] = Draw(\n      nextFeeFraction,\n      nextFeeBeneficiary,\n      block.number,\n      _secretHash,\n      bytes32(0),\n      address(0),\n      uint256(0),\n      uint256(0)\n    );\n    emit Opened(\n      drawState.openDrawIndex,\n      nextFeeBeneficiary,\n      _secretHash,\n      nextFeeFraction\n    );\n  }\n\n  /**\n   * @notice Commits the current draw.\n   */\n  function emitCommitted() internal {\n    uint256 drawId = currentOpenDrawId();\n    emit Committed(drawId);\n  }\n\n  /**\n   * @notice Commits the current open draw, if any, and opens the next draw using the passed hash.  Really this function is only called twice:\n   * the first after Pool contract creation and the second immediately after.\n   * Can only be called by an admin.\n   * May fire the Committed event, and always fires the Open event.\n   * @param nextSecretHash The secret hash to use to open a new Draw\n   */\n  function openNextDraw(bytes32 nextSecretHash) public onlyAdmin {\n    if (currentCommittedDrawId() > 0) {\n      require(currentCommittedDrawHasBeenRewarded(), \"the current committed draw has not been rewarded\");\n    }\n    if (currentOpenDrawId() != 0) {\n      emitCommitted();\n    }\n    open(nextSecretHash);\n  }\n\n  /**\n   * @notice Ignores the current draw, and opens the next draw.\n   * @dev This function will be removed once the winner selection has been decentralized.\n   * @param nextSecretHash The hash to commit for the next draw\n   */\n  function rolloverAndOpenNextDraw(bytes32 nextSecretHash) public onlyAdmin {\n    rollover();\n    openNextDraw(nextSecretHash);\n  }\n\n  /**\n   * @notice Rewards the current committed draw using the passed secret, commits the current open draw, and opens the next draw using the passed secret hash.\n   * Can only be called by an admin.\n   * Fires the Rewarded event, the Committed event, and the Open event.\n   * @param nextSecretHash The secret hash to use to open a new Draw\n   * @param lastSecret The secret to reveal to reward the current committed Draw.\n   */\n  function rewardAndOpenNextDraw(bytes32 nextSecretHash, bytes32 lastSecret, bytes32 _salt) public onlyAdmin {\n    reward(lastSecret, _salt);\n    openNextDraw(nextSecretHash);\n  }\n\n  /**\n   * @notice Rewards the winner for the current committed Draw using the passed secret.\n   * The gross winnings are calculated by subtracting the accounted balance from the current underlying cToken balance.\n   * A winner is calculated using the revealed secret.\n   * If there is a winner (i.e. any eligible users) then winner's balance is updated with their net winnings.\n   * The draw beneficiary's balance is updated with the fee.\n   * The accounted balance is updated to include the fee and, if there was a winner, the net winnings.\n   * Fires the Rewarded event.\n   * @param _secret The secret to reveal for the current committed Draw\n   */\n  function reward(bytes32 _secret, bytes32 _salt) public onlyAdmin requireCommittedNoReward nonReentrant {\n    // require that there is a committed draw\n    // require that the committed draw has not been rewarded\n    uint256 drawId = currentCommittedDrawId();\n\n    Draw storage draw = draws[drawId];\n\n    require(draw.secretHash == keccak256(abi.encodePacked(_secret, _salt)), \"secret does not match\");\n\n    // derive entropy from the revealed secret\n    bytes32 entropy = keccak256(abi.encodePacked(_secret));\n\n    // Select the winner using the hash as entropy\n    address winningAddress = calculateWinner(entropy);\n\n    // Calculate the gross winnings\n    uint256 underlyingBalance = balance();\n    uint256 grossWinnings = underlyingBalance.sub(accountedBalance);\n\n    // Calculate the beneficiary fee\n    uint256 fee = calculateFee(draw.feeFraction, grossWinnings);\n\n    // Update balance of the beneficiary\n    balances[draw.feeBeneficiary] = balances[draw.feeBeneficiary].add(fee);\n\n    // Calculate the net winnings\n    uint256 netWinnings = grossWinnings.sub(fee);\n\n    draw.winner = winningAddress;\n    draw.netWinnings = netWinnings;\n    draw.fee = fee;\n    draw.entropy = entropy;\n\n    // If there is a winner who is to receive non-zero winnings\n    if (winningAddress != address(0) && netWinnings != 0) {\n      // Updated the accounted total\n      accountedBalance = underlyingBalance;\n\n      awardWinnings(winningAddress, netWinnings);\n    } else {\n      // Only account for the fee\n      accountedBalance = accountedBalance.add(fee);\n    }\n\n    emit Rewarded(\n      drawId,\n      winningAddress,\n      entropy,\n      netWinnings,\n      fee\n    );\n  }\n\n  function awardWinnings(address winner, uint256 amount) internal {\n    // Update balance of the winner\n    balances[winner] = balances[winner].add(amount);\n\n    // Enter their winnings into the next draw\n    drawState.deposit(winner, amount);\n  }\n\n  /**\n   * @notice A function that skips the reward for the committed draw id.\n   * @dev This function will be removed once the entropy is decentralized.\n   */\n  function rollover() public onlyAdmin requireCommittedNoReward {\n    uint256 drawId = currentCommittedDrawId();\n\n    Draw storage draw = draws[drawId];\n    draw.entropy = ROLLED_OVER_ENTROPY_MAGIC_NUMBER;\n\n    emit RolledOver(\n      drawId\n    );\n\n    emit Rewarded(\n      drawId,\n      address(0),\n      ROLLED_OVER_ENTROPY_MAGIC_NUMBER,\n      0,\n      0\n    );\n  }\n\n  /**\n   * @notice Calculate the beneficiary fee using the passed fee fraction and gross winnings.\n   * @param _feeFraction The fee fraction, between 0 and 1, represented as a 18 point fixed number.\n   * @param _grossWinnings The gross winnings to take a fraction of.\n   */\n  function calculateFee(uint256 _feeFraction, uint256 _grossWinnings) internal pure returns (uint256) {\n    int256 grossWinningsFixed = FixidityLib.newFixed(int256(_grossWinnings));\n    int256 feeFixed = FixidityLib.multiply(grossWinningsFixed, FixidityLib.newFixed(int256(_feeFraction), uint8(18)));\n    return uint256(FixidityLib.fromFixed(feeFixed));\n  }\n\n  /**\n   * @notice Allows a user to deposit a sponsorship amount.  The deposit is transferred into the cToken.\n   * Sponsorships allow a user to contribute to the pool without becoming eligible to win.  They can withdraw their sponsorship at any time.\n   * The deposit will immediately be added to Compound and the interest will contribute to the next draw.\n   * @param _amount The amount of the token underlying the cToken to deposit.\n   */\n  function depositSponsorship(uint256 _amount) public unlessPaused nonReentrant {\n    // Transfer the tokens into this contract\n    require(token().transferFrom(msg.sender, address(this), _amount), \"token transfer failed\");\n\n    // Deposit the sponsorship amount\n    _depositSponsorshipFrom(msg.sender, _amount);\n  }\n\n  /**\n   * @notice Deposits the token balance for this contract as a sponsorship.\n   * If people erroneously transfer tokens to this contract, this function will allow us to recoup those tokens as sponsorship.\n   */\n  function transferBalanceToSponsorship() public {\n    // Deposit the sponsorship amount\n    _depositSponsorshipFrom(address(this), token().balanceOf(address(this)));\n  }\n\n  /**\n   * @notice Deposits into the pool under the current open Draw.  The deposit is transferred into the cToken.\n   * Once the open draw is committed, the deposit will be added to the user's total committed balance and increase their chances of winning\n   * proportional to the total committed balance of all users.\n   * @param _amount The amount of the token underlying the cToken to deposit.\n   */\n  function depositPool(uint256 _amount) public requireOpenDraw unlessPaused nonReentrant {\n    // Transfer the tokens into this contract\n    require(token().transferFrom(msg.sender, address(this), _amount), \"token transfer failed\");\n\n    // Deposit the funds\n    _depositPoolFrom(msg.sender, _amount);\n  }\n\n  function _depositSponsorshipFrom(address _spender, uint256 _amount) internal {\n    // Deposit the funds\n    _depositFrom(_spender, _amount);\n\n    emit SponsorshipDeposited(_spender, _amount);\n  }\n\n  function _depositPoolFrom(address _spender, uint256 _amount) internal {\n    // Update the user's eligibility\n    drawState.deposit(_spender, _amount);\n\n    _depositFrom(_spender, _amount);\n\n    emit Deposited(_spender, _amount);\n  }\n\n  function _depositPoolFromCommitted(address _spender, uint256 _amount) internal {\n    // Update the user's eligibility\n    drawState.depositCommitted(_spender, _amount);\n\n    _depositFrom(_spender, _amount);\n\n    emit DepositedAndCommitted(_spender, _amount);\n  }\n\n  function _depositFrom(address _spender, uint256 _amount) internal {\n    // Update the user's balance\n    balances[_spender] = balances[_spender].add(_amount);\n\n    // Update the total of this contract\n    accountedBalance = accountedBalance.add(_amount);\n\n    // Deposit into Compound\n    require(token().approve(address(cToken), _amount), \"could not approve money market spend\");\n    require(cToken.mint(_amount) == 0, \"could not supply money market\");\n  }\n\n  /**\n   * @notice Withdraw the sender's entire balance back to them.\n   */\n  function withdraw() public nonReentrant {\n    uint balance = balances[msg.sender];\n\n    // Update their chances of winning\n    drawState.withdraw(msg.sender);\n\n    _withdraw(msg.sender, balance);\n  }\n\n  /**\n   * @notice Transfers tokens from the cToken contract to the sender.  Updates the accounted balance.\n   */\n  function _withdraw(address _sender, uint256 _amount) internal {\n    uint balance = balances[_sender];\n\n    require(_amount <= balance, \"not enough funds\");\n\n    // Update the user's balance\n    balances[_sender] = balance.sub(_amount);\n\n    // Update the total of this contract\n    accountedBalance = accountedBalance.sub(_amount);\n\n    // Withdraw from Compound and transfer\n    require(cToken.redeemUnderlying(_amount) == 0, \"could not redeem from compound\");\n    require(token().transfer(_sender, _amount), \"could not transfer winnings\");\n\n    emit Withdrawn(_sender, _amount);\n  }\n\n  /**\n   * @notice Returns the id of the current open Draw.\n   * @return The current open Draw id\n   */\n  function currentOpenDrawId() public view returns (uint256) {\n    return drawState.openDrawIndex;\n  }\n\n  /**\n   * @notice Returns the id of the current committed Draw.\n   * @return The current committed Draw id\n   */\n  function currentCommittedDrawId() public view returns (uint256) {\n    if (drawState.openDrawIndex > 1) {\n      return drawState.openDrawIndex - 1;\n    } else {\n      return 0;\n    }\n  }\n\n  /**\n   * @notice Returns whether the current committed draw has been rewarded\n   * @return True if the current committed draw has been rewarded, false otherwise\n   */\n  function currentCommittedDrawHasBeenRewarded() internal view returns (bool) {\n    Draw storage draw = draws[currentCommittedDrawId()];\n    return draw.entropy != bytes32(0);\n  }\n\n  /**\n   * @notice Gets information for a given draw.\n   * @param _drawId The id of the Draw to retrieve info for.\n   * @return Fields including:\n   *  feeFraction: the fee fraction\n   *  feeBeneficiary: the beneficiary of the fee\n   *  openedBlock: The block at which the draw was opened\n   *  secretHash: The hash of the secret committed to this draw.\n   */\n  function getDraw(uint256 _drawId) public view returns (\n    uint256 feeFraction,\n    address feeBeneficiary,\n    uint256 openedBlock,\n    bytes32 secretHash,\n    bytes32 entropy,\n    address winner,\n    uint256 netWinnings,\n    uint256 fee\n  ) {\n    Draw storage draw = draws[_drawId];\n    feeFraction = draw.feeFraction;\n    feeBeneficiary = draw.feeBeneficiary;\n    openedBlock = draw.openedBlock;\n    secretHash = draw.secretHash;\n    entropy = draw.entropy;\n    winner = draw.winner;\n    netWinnings = draw.netWinnings;\n    fee = draw.fee;\n  }\n\n  /**\n   * @notice Returns the total of the address's balance in committed Draws.  That is, the total that contributes to their chances of winning.\n   * @param _addr The address of the user\n   * @return The total committed balance for the user\n   */\n  function committedBalanceOf(address _addr) external view returns (uint256) {\n    return drawState.committedBalanceOf(_addr);\n  }\n\n  /**\n   * @notice Returns the total of the address's balance in the open Draw.  That is, the total that will *eventually* contribute to their chances of winning.\n   * @param _addr The address of the user\n   * @return The total open balance for the user\n   */\n  function openBalanceOf(address _addr) external view returns (uint256) {\n    return drawState.openBalanceOf(_addr);\n  }\n\n  /**\n   * @notice Returns a user's total balance, including both committed Draw balance and open Draw balance.\n   * @param _addr The address of the user to check.\n   * @return The users's current balance.\n   */\n  function totalBalanceOf(address _addr) external view returns (uint256) {\n    return balances[_addr];\n  }\n\n  /**\n   * @notice Returns a user's total balance, including both committed Draw balance and open Draw balance.\n   * @param _addr The address of the user to check.\n   * @return The users's current balance.\n   */\n  function balanceOf(address _addr) external view returns (uint256) {\n    return drawState.committedBalanceOf(_addr);\n  }\n\n  /**\n   * @notice Calculates a winner using the passed entropy for the current committed balances.\n   * @param _entropy The entropy to use to select the winner\n   * @return The winning address\n   */\n  function calculateWinner(bytes32 _entropy) public view returns (address) {\n    return drawState.drawWithEntropy(_entropy);\n  }\n\n  /**\n   * @notice Returns the total committed balance.  Used to compute an address's chances of winning.\n   * @return The total committed balance.\n   */\n  function committedSupply() public view returns (uint256) {\n    return drawState.committedSupply();\n  }\n\n  /**\n   * @notice Returns the total open balance.  This balance is the number of tickets purchased for the open draw.\n   * @return The total open balance\n   */\n  function openSupply() public view returns (uint256) {\n    return drawState.openSupply();\n  }\n\n  /**\n   * @notice Calculates the total estimated interest earned for the given number of blocks\n   * @param _blocks The number of block that interest accrued for\n   * @return The total estimated interest as a 18 point fixed decimal.\n   */\n  function estimatedInterestRate(uint256 _blocks) public view returns (uint256) {\n    return supplyRatePerBlock().mul(_blocks);\n  }\n\n  /**\n   * @notice Convenience function to return the supplyRatePerBlock value from the money market contract.\n   * @return The cToken supply rate per block\n   */\n  function supplyRatePerBlock() public view returns (uint256) {\n    return cToken.supplyRatePerBlock();\n  }\n\n  /**\n   * @notice Sets the beneficiary fee fraction for subsequent Draws.\n   * Fires the NextFeeFractionChanged event.\n   * Can only be called by an admin.\n   * @param _feeFraction The fee fraction to use.\n   * Must be between 0 and 1 and formatted as a fixed point number with 18 decimals (as in Ether).\n   */\n  function setNextFeeFraction(uint256 _feeFraction) public onlyAdmin {\n    _setNextFeeFraction(_feeFraction);\n  }\n\n  function _setNextFeeFraction(uint256 _feeFraction) internal {\n    require(_feeFraction <= 1 ether, \"fee fraction must be 1 or less\");\n    nextFeeFraction = _feeFraction;\n\n    emit NextFeeFractionChanged(_feeFraction);\n  }\n\n  /**\n   * @notice Sets the fee beneficiary for subsequent Draws.\n   * Can only be called by admins.\n   * @param _feeBeneficiary The beneficiary for the fee fraction.  Cannot be the 0 address.\n   */\n  function setNextFeeBeneficiary(address _feeBeneficiary) public onlyAdmin {\n    _setNextFeeBeneficiary(_feeBeneficiary);\n  }\n\n  function _setNextFeeBeneficiary(address _feeBeneficiary) internal {\n    require(_feeBeneficiary != address(0), \"beneficiary should not be 0x0\");\n    nextFeeBeneficiary = _feeBeneficiary;\n\n    emit NextFeeBeneficiaryChanged(_feeBeneficiary);\n  }\n\n  /**\n   * @notice Adds an administrator.\n   * Can only be called by administrators.\n   * Fires the AdminAdded event.\n   * @param _admin The address of the admin to add\n   */\n  function addAdmin(address _admin) public onlyAdmin {\n    _addAdmin(_admin);\n  }\n\n  /**\n   * @notice Checks whether a given address is an administrator.\n   * @param _admin The address to check\n   * @return True if the address is an admin, false otherwise.\n   */\n  function isAdmin(address _admin) public view returns (bool) {\n    return admins.has(_admin);\n  }\n\n  function _addAdmin(address _admin) internal {\n    admins.add(_admin);\n\n    emit AdminAdded(_admin);\n  }\n\n  /**\n   * @notice Removes an administrator\n   * Can only be called by an admin.\n   * Admins cannot remove themselves.  This ensures there is always one admin.\n   * @param _admin The address of the admin to remove\n   */\n  function removeAdmin(address _admin) public onlyAdmin {\n    require(admins.has(_admin), \"admin does not exist\");\n    require(_admin != msg.sender, \"cannot remove yourself\");\n    admins.remove(_admin);\n\n    emit AdminRemoved(_admin);\n  }\n\n  modifier requireCommittedNoReward() {\n    require(currentCommittedDrawId() > 0, \"must be a committed draw\");\n    require(!currentCommittedDrawHasBeenRewarded(), \"the committed draw has already been rewarded\");\n    _;\n  }\n\n  /**\n   * @notice Returns the token underlying the cToken.\n   * @return An ERC20 token address\n   */\n  function token() public view returns (IERC20) {\n    return IERC20(cToken.underlying());\n  }\n\n  /**\n   * @notice Returns the underlying balance of this contract in the cToken.\n   * @return The cToken underlying balance for this contract.\n   */\n  function balance() public returns (uint256) {\n    return cToken.balanceOfUnderlying(address(this));\n  }\n\n  function pause() public unlessPaused onlyAdmin {\n    paused = true;\n\n    emit Paused(msg.sender);\n  }\n\n  function unpause() public whenPaused onlyAdmin {\n    paused = false;\n\n    emit Unpaused(msg.sender);\n  }\n\n  modifier onlyAdmin() {\n    require(admins.has(msg.sender), \"must be an admin\");\n    _;\n  }\n\n  modifier requireOpenDraw() {\n    require(currentOpenDrawId() != 0, \"there is no open draw\");\n    _;\n  }\n\n  modifier whenPaused() {\n    require(paused, \"contract is not paused\");\n    _;\n  }\n\n  modifier unlessPaused() {\n    require(!paused, \"contract is paused\");\n    _;\n  }\n}"
    },
    {
      "filename": "contracts/FixidityLib.sol",
      "content": "pragma solidity ^0.5.0;\n\n\n/**\n * @title FixidityLib\n * @author Gadi Guy, Alberto Cuesta Canada\n * @notice This library provides fixed point arithmetic with protection against\n * overflow. \n * All operations are done with int256 and the operands must have been created \n * with any of the newFrom* functions, which shift the comma digits() to the \n * right and check for limits.\n * When using this library be sure of using maxNewFixed() as the upper limit for\n * creation of fixed point numbers. Use maxFixedMul(), maxFixedDiv() and\n * maxFixedAdd() if you want to be certain that those operations don't \n * overflow.\n */\nlibrary FixidityLib {\n\n    /**\n     * @notice Number of positions that the comma is shifted to the right.\n     */\n    function digits() public pure returns(uint8) {\n        return 24;\n    }\n    \n    /**\n     * @notice This is 1 in the fixed point units used in this library.\n     * @dev Test fixed1() equals 10^digits()\n     * Hardcoded to 24 digits.\n     */\n    function fixed1() public pure returns(int256) {\n        return 1000000000000000000000000;\n    }\n\n    /**\n     * @notice The amount of decimals lost on each multiplication operand.\n     * @dev Test mulPrecision() equals sqrt(fixed1)\n     * Hardcoded to 24 digits.\n     */\n    function mulPrecision() public pure returns(int256) {\n        return 1000000000000;\n    }\n\n    /**\n     * @notice Maximum value that can be represented in an int256\n     * @dev Test maxInt256() equals 2^255 -1\n     */\n    function maxInt256() public pure returns(int256) {\n        return 57896044618658097711785492504343953926634992332820282019728792003956564819967;\n    }\n\n    /**\n     * @notice Minimum value that can be represented in an int256\n     * @dev Test minInt256 equals (2^255) * (-1)\n     */\n    function minInt256() public pure returns(int256) {\n        return -57896044618658097711785492504343953926634992332820282019728792003956564819968;\n    }\n\n    /**\n     * @notice Maximum value that can be converted to fixed point. Optimize for\n     * @dev deployment. \n     * Test maxNewFixed() equals maxInt256() / fixed1()\n     * Hardcoded to 24 digits.\n     */\n    function maxNewFixed() public pure returns(int256) {\n        return 57896044618658097711785492504343953926634992332820282;\n    }\n\n    /**\n     * @notice Minimum value that can be converted to fixed point. Optimize for\n     * deployment. \n     * @dev Test minNewFixed() equals -(maxInt256()) / fixed1()\n     * Hardcoded to 24 digits.\n     */\n    function minNewFixed() public pure returns(int256) {\n        return -57896044618658097711785492504343953926634992332820282;\n    }\n\n    /**\n     * @notice Maximum value that can be safely used as an addition operator.\n     * @dev Test maxFixedAdd() equals maxInt256()-1 / 2\n     * Test add(maxFixedAdd(),maxFixedAdd()) equals maxFixedAdd() + maxFixedAdd()\n     * Test add(maxFixedAdd()+1,maxFixedAdd()) throws \n     * Test add(-maxFixedAdd(),-maxFixedAdd()) equals -maxFixedAdd() - maxFixedAdd()\n     * Test add(-maxFixedAdd(),-maxFixedAdd()-1) throws \n     */\n    function maxFixedAdd() public pure returns(int256) {\n        return 28948022309329048855892746252171976963317496166410141009864396001978282409983;\n    }\n\n    /**\n     * @notice Maximum negative value that can be safely in a subtraction.\n     * @dev Test maxFixedSub() equals minInt256() / 2\n     */\n    function maxFixedSub() public pure returns(int256) {\n        return -28948022309329048855892746252171976963317496166410141009864396001978282409984;\n    }\n\n    /**\n     * @notice Maximum value that can be safely used as a multiplication operator.\n     * @dev Calculated as sqrt(maxInt256()*fixed1()). \n     * Be careful with your sqrt() implementation. I couldn't find a calculator\n     * that would give the exact square root of maxInt256*fixed1 so this number\n     * is below the real number by no more than 3*10**28. It is safe to use as\n     * a limit for your multiplications, although powers of two of numbers over\n     * this value might still work.\n     * Test multiply(maxFixedMul(),maxFixedMul()) equals maxFixedMul() * maxFixedMul()\n     * Test multiply(maxFixedMul(),maxFixedMul()+1) throws \n     * Test multiply(-maxFixedMul(),maxFixedMul()) equals -maxFixedMul() * maxFixedMul()\n     * Test multiply(-maxFixedMul(),maxFixedMul()+1) throws \n     * Hardcoded to 24 digits.\n     */\n    function maxFixedMul() public pure returns(int256) {\n        return 240615969168004498257251713877715648331380787511296;\n    }\n\n    /**\n     * @notice Maximum value that can be safely used as a dividend.\n     * @dev divide(maxFixedDiv,newFixedFraction(1,fixed1())) = maxInt256().\n     * Test maxFixedDiv() equals maxInt256()/fixed1()\n     * Test divide(maxFixedDiv(),multiply(mulPrecision(),mulPrecision())) = maxFixedDiv()*(10^digits())\n     * Test divide(maxFixedDiv()+1,multiply(mulPrecision(),mulPrecision())) throws\n     * Hardcoded to 24 digits.\n     */\n    function maxFixedDiv() public pure returns(int256) {\n        return 57896044618658097711785492504343953926634992332820282;\n    }\n\n    /**\n     * @notice Maximum value that can be safely used as a divisor.\n     * @dev Test maxFixedDivisor() equals fixed1()*fixed1() - Or 10**(digits()*2)\n     * Test divide(10**(digits()*2 + 1),10**(digits()*2)) = returns 10*fixed1()\n     * Test divide(10**(digits()*2 + 1),10**(digits()*2 + 1)) = throws\n     * Hardcoded to 24 digits.\n     */\n    function maxFixedDivisor() public pure returns(int256) {\n        return 1000000000000000000000000000000000000000000000000;\n    }\n\n    /**\n     * @notice Converts an int256 to fixed point units, equivalent to multiplying\n     * by 10^digits().\n     * @dev Test newFixed(0) returns 0\n     * Test newFixed(1) returns fixed1()\n     * Test newFixed(maxNewFixed()) returns maxNewFixed() * fixed1()\n     * Test newFixed(maxNewFixed()+1) fails\n     */\n    function newFixed(int256 x)\n        public\n        pure\n        returns (int256)\n    {\n        require(x <= maxNewFixed());\n        require(x >= minNewFixed());\n        return x * fixed1();\n    }\n\n    /**\n     * @notice Converts an int256 in the fixed point representation of this \n     * library to a non decimal. All decimal digits will be truncated.\n     */\n    function fromFixed(int256 x)\n        public\n        pure\n        returns (int256)\n    {\n        return x / fixed1();\n    }\n\n    /**\n     * @notice Converts an int256 which is already in some fixed point \n     * representation to a different fixed precision representation.\n     * Both the origin and destination precisions must be 38 or less digits.\n     * Origin values with a precision higher than the destination precision\n     * will be truncated accordingly.\n     * @de"
    }
  ]
}