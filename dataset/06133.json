{
  "Title": "[M-11] Blocked follower can keep follow with `batchMigrateFollows`",
  "Content": "\nYou can migrate V1 followers by calling the `LensV2Migration.batchMigrateFollows` function, which can be called by anyone.\n\n```solidity\nfunction batchMigrateFollows(\n    uint256[] calldata followerProfileIds,\n    uint256[] calldata idsOfProfileFollowed,\n    uint256[] calldata followTokenIds\n) external {\n    MigrationLib.batchMigrateFollows(followerProfileIds, idsOfProfileFollowed, followTokenIds);\n}\n```\n\n<https://github.com/code-423n4/2023-07-lens/blob/cdef6ebc6266c44c7068bc1c4c04e12bf0d67ead/contracts/misc/LensV2Migration.sol#L37-L43>\n\n```solidity\nfunction _migrateFollow(\n    uint256 followerProfileId,\n    uint256 idOfProfileFollowed,\n    uint256 followTokenId\n) private {\n    uint48 mintTimestamp = FollowNFT(StorageLib.getProfile(idOfProfileFollowed).followNFT).tryMigrate({\n        followerProfileId: followerProfileId,\n        followerProfileOwner: StorageLib.getTokenData(followerProfileId).owner,\n        idOfProfileFollowed: idOfProfileFollowed,\n        followTokenId: followTokenId\n    });\n    // `mintTimestamp` will be 0 if:\n    // - Follow NFT was already migrated\n    // - Follow NFT does not exist or was burnt\n    // - Follower profile Owner is different from Follow NFT Owner\n    if (mintTimestamp != 0) {\n        emit Events.Followed({\n            followerProfileId: followerProfileId,\n            idOfProfileFollowed: idOfProfileFollowed,\n            followTokenIdAssigned: followTokenId,\n            followModuleData: '',\n            processFollowModuleReturnData: '',\n            timestamp: mintTimestamp // The only case where this won't match block.timestamp is during the migration\n        });\n    }\n}\n```\n\n<https://github.com/code-423n4/2023-07-lens/blob/cdef6ebc6266c44c7068bc1c4c04e12bf0d67ead/contracts/libraries/MigrationLib.sol#L114-L139>\n\nThe `FollowNFT.tryMigrate` is where the actual migration logic proceed.  `FollowNFT.tryMigrate` does not check whether the `followerProfileId` has been blocked by the `idOfProfileFollowed`.\n\n```solidity\nfunction tryMigrate(\n    uint256 followerProfileId,\n    address followerProfileOwner,\n    uint256 idOfProfileFollowed,\n    uint256 followTokenId\n) external onlyHub returns (uint48) {\n    // Migrated FollowNFTs should have `originalFollowTimestamp` set\n    if (_followDataByFollowTokenId[followTokenId].originalFollowTimestamp != 0) {\n        return 0; // Already migrated\n    }\n\n    if (_followedProfileId != idOfProfileFollowed) {\n        revert Errors.InvalidParameter();\n    }\n\n    if (!_exists(followTokenId)) {\n        return 0; // Doesn't exist\n    }\n\n    address followTokenOwner = ownerOf(followTokenId);\n\n    // ProfileNFT and FollowNFT should be in the same account\n    if (followerProfileOwner != followTokenOwner) {\n        return 0; // Not holding both Profile & Follow NFTs together\n    }\n\n    unchecked {\n        ++_followerCount;\n    }\n\n    _followTokenIdByFollowerProfileId[followerProfileId] = followTokenId;\n\n    uint48 mintTimestamp = uint48(StorageLib.getTokenData(followTokenId).mintTimestamp);\n\n    _followDataByFollowTokenId[followTokenId].followerProfileId = uint160(followerProfileId);\n    _followDataByFollowTokenId[followTokenId].originalFollowTimestamp = mintTimestamp;\n    _followDataByFollowTokenId[followTokenId].followTimestamp = mintTimestamp;\n\n    super._burn(followTokenId);\n    return mintTimestamp;\n}\n```\n\n<https://github.com/code-423n4/2023-07-lens/blob/cdef6ebc6266c44c7068bc1c4c04e12bf0d67ead/contracts/FollowNFT.sol#L480-L520>\n\nLet's think the case that the `idOfProfileFollowed` profile blocked the `followerProfileId` when the follower has not yet migrated. In this case, if the owner of the `followerProfileId` or anyone else calls `LensV2Migration.batchMigrateFollows`, then the blocked `followerProfileId` can follow the `idOfProfileFollowed`.\n\nThe following codes are the PoC codes. Add and modify <https://github.com/code-423n4/2023-07-lens/blob/main/test/migrations/Migrations.t.sol> to run PoC.\n\nFirst, modify the test because it is broken due to a change of the return value of getProfile. Add the following interface at `Migrations.t.sol` test file.\n\n```solidity\ninterface LensHubV1 {\n    struct ProfileV1 {\n        uint256 pubCount; // offset 0\n        address followModule; // offset 1\n        address followNFT; // offset 2\n        string __DEPRECATED__handle; // offset 3\n        string imageURI; // offset 4\n        string __DEPRECATED__followNFTURI;\n    }\n\n    function getProfile(uint256 profileId) external view returns (ProfileV1 memory);\n}\n```\n\nAlso modify the following code to recover broken tests. <https://github.com/code-423n4/2023-07-lens/blob/cdef6ebc6266c44c7068bc1c4c04e12bf0d67ead/test/migrations/Migrations.t.sol#L107>\n\n```solidity\naddress followNFTAddress = LensHubV1(address(hub)).getProfile(idOfProfileFollowed).followNFT;\n```\n\nAdd this test function at  `MigrationsTest` contract and run. Even after being blocked, it is possible to follow through `batchMigrateFollows`.\n\n```solidity\nfunction testMigrateBlockedFollowerPoC() public onlyFork {\n    uint256 idOfProfileFollowed = 8;\n\n    uint256[] memory idsOfProfileFollowed = new uint256[](10);\n    uint256[] memory followTokenIds = new uint256[](10);\n    bool[] memory blockStatuses = new bool[](10);\n\n    for (uint256 i = 0; i < 10; i++) {\n        uint256 followTokenId = i + 1;\n\n        idsOfProfileFollowed[i] = idOfProfileFollowed;\n        followTokenIds[i] = followTokenId;\n\n        blockStatuses[i] = true;\n    }\n\n    // block followers\n    address targetProfileOwner = hub.ownerOf(idOfProfileFollowed);\n    vm.prank(targetProfileOwner);\n\n    hub.setBlockStatus(\n        idOfProfileFollowed,\n        followerProfileIds,\n        blockStatuses\n    );\n\n    // check block status\n    assertEq(hub.isBlocked(followerProfileIds[0], idOfProfileFollowed), true);\n\n    // migrate\n    hub.batchMigrateFollows(followerProfileIds, idsOfProfileFollowed, followTokenIds);\n\n    // check follow work \n    address followNFTAddress = LensHubV1(address(hub)).getProfile(idOfProfileFollowed).followNFT;\n    assertEq(FollowNFT(followNFTAddress).isFollowing(followerProfileIds[0]), true); // blocked, but followed!\n}\n```\n\n### Recommended Mitigation Steps\n\nAt `FollowNFT.tryMigrate` function, If the follower is blocked, make it unfollowed.\n\n### Assessed type\n\nInvalid Validation\n\n**[vicnaum (Lens) confirmed and commented](https://github.com/code-423n4/2023-07-lens-findings/issues/40#issuecomment-1670022300):**\n> This looks like a subset of [issue 112](https://github.com/code-423n4/2023-07-lens-findings/issues/112).\n\n**[Picodes (judge) commented](https://github.com/code-423n4/2023-07-lens-findings/issues/40#issuecomment-1695965310):**\n > Although the impact is similar, it doesn't look like a duplicate to me as this is specifically about a blocked user being able to migrate himself, whereas `#112` is about an attacker migrating someone without its consent.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-07-lens",
  "Code": [
    {
      "filename": "contracts/misc/LensV2Migration.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport {MigrationLib} from 'contracts/libraries/MigrationLib.sol';\n\n// Handles\nimport {LensHandles} from 'contracts/namespaces/LensHandles.sol';\nimport {TokenHandleRegistry} from 'contracts/namespaces/TokenHandleRegistry.sol';\n\ncontract LensV2Migration {\n    address internal immutable FEE_FOLLOW_MODULE;\n    address internal immutable PROFILE_FOLLOW_MODULE;\n    address internal immutable NEW_FEE_FOLLOW_MODULE;\n\n    LensHandles internal immutable lensHandles;\n    TokenHandleRegistry internal immutable tokenHandleRegistry;\n\n    constructor(\n        address legacyFeeFollowModule,\n        address legacyProfileFollowModule,\n        address newFeeFollowModule,\n        address lensHandlesAddress,\n        address tokenHandleRegistryAddress\n    ) {\n        FEE_FOLLOW_MODULE = legacyFeeFollowModule;\n        PROFILE_FOLLOW_MODULE = legacyProfileFollowModule;\n        NEW_FEE_FOLLOW_MODULE = newFeeFollowModule;\n        lensHandles = LensHandles(lensHandlesAddress);\n        tokenHandleRegistry = TokenHandleRegistry(tokenHandleRegistryAddress);\n    }\n\n    function batchMigrateProfiles(uint256[] calldata profileIds) external {\n        MigrationLib.batchMigrateProfiles(profileIds, lensHandles, tokenHandleRegistry);\n    }\n\n    function batchMigrateFollows(\n        uint256[] calldata followerProfileIds,\n        uint256[] calldata idsOfProfileFollowed,\n        uint256[] calldata followTokenIds\n    ) external {\n        MigrationLib.batchMigrateFollows(followerProfileIds, idsOfProfileFollowed, followTokenIds);\n    }\n\n    function batchMigrateFollowModules(uint256[] calldata profileIds) external {\n        MigrationLib.batchMigrateFollowModules(\n            profileIds,\n            FEE_FOLLOW_MODULE,\n            PROFILE_FOLLOW_MODULE,\n            NEW_FEE_FOLLOW_MODULE\n        );\n    }\n}"
    },
    {
      "filename": "contracts/libraries/MigrationLib.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.19;\n\nimport {Events} from 'contracts/libraries/constants/Events.sol';\nimport {Errors} from 'contracts/libraries/constants/Errors.sol';\nimport {StorageLib} from 'contracts/libraries/StorageLib.sol';\nimport {FollowNFT} from 'contracts/FollowNFT.sol';\nimport {LensHandles} from 'contracts/namespaces/LensHandles.sol';\nimport {TokenHandleRegistry} from 'contracts/namespaces/TokenHandleRegistry.sol';\nimport {IFollowModule} from 'contracts/interfaces/IFollowModule.sol';\n\ninterface ILegacyFeeFollowModule {\n    struct ProfileData {\n        address currency;\n        uint256 amount;\n        address recipient;\n    }\n\n    function getProfileData(uint256 profileId) external view returns (ProfileData memory);\n}\n\nlibrary MigrationLib {\n    uint256 internal constant LENS_PROTOCOL_PROFILE_ID = 1;\n    uint256 internal constant DOT_LENS_SUFFIX_LENGTH = 5;\n\n    // Profiles Handles Migration:\n\n    event ProfileMigrated(uint256 profileId, address profileDestination, string handle, uint256 handleId);\n\n    /**\n     * @notice Migrates an array of profiles from V1 to V2. This function can be callable by anyone.\n     * We would still perform the migration in batches by ourselves, but good to allow users to migrate on their own if they want to.\n     *\n     * @param profileIds The array of profile IDs to migrate.\n     */\n    function batchMigrateProfiles(\n        uint256[] calldata profileIds,\n        LensHandles lensHandles,\n        TokenHandleRegistry tokenHandleRegistry\n    ) external {\n        uint256 i;\n        while (i < profileIds.length) {\n            _migrateProfile(profileIds[i], lensHandles, tokenHandleRegistry);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Migrates a profile from V1 to V2.\n     *\n     * @dev We do not revert in any case, as we want to allow the migration to continue even if one profile fails\n     *      (and it usually fails if already migrated or profileNFT moved).\n     * @dev Estimated gas cost of one profile migration is around 178k gas.\n     *\n     * @param profileId The profile ID to migrate.\n     */\n    function _migrateProfile(\n        uint256 profileId,\n        LensHandles lensHandles,\n        TokenHandleRegistry tokenHandleRegistry\n    ) private {\n        address profileOwner = StorageLib.getTokenData(profileId).owner;\n        // We check if the profile exists by checking owner != address(0).\n        if (profileOwner != address(0)) {\n            // We check if the profile has already been migrated by checking __DEPRECATED__handle != \"\".\n            string memory handle = StorageLib.getProfile(profileId).__DEPRECATED__handle;\n            if (bytes(handle).length == 0) {\n                return; // Already migrated\n            }\n            bytes32 handleHash = keccak256(bytes(handle));\n            // We check if the profile is the \"lensprotocol\" profile by checking profileId != 1.\n            // \"lensprotocol\" is the only edge case without the .lens suffix:\n            if (profileId != LENS_PROTOCOL_PROFILE_ID) {\n                assembly {\n                    let handle_length := mload(handle)\n                    mstore(handle, sub(handle_length, DOT_LENS_SUFFIX_LENGTH)) // Cut 5 chars (.lens) from the end\n                }\n            }\n            // We mint a new handle on the LensHandles contract. The resulting handle NFT is sent to the profile owner.\n            uint256 handleId = lensHandles.migrateHandle(profileOwner, handle);\n            // We link it to the profile in the TokenHandleRegistry contract.\n            tokenHandleRegistry.migrationLink(handleId, profileId);\n            emit ProfileMigrated(profileId, profileOwner, handle, handleId);\n            delete StorageLib.getProfile(profileId).__DEPRECATED__handle;\n            delete StorageLib.profileIdByHandleHash()[handleHash];\n        }\n    }\n\n    // FollowNFT Migration:\n\n    function batchMigrateFollows(\n        uint256[] calldata followerProfileIds,\n        uint256[] calldata idsOfProfileFollowed,\n        uint256[] calldata followTokenIds\n    ) external {\n        if (\n            followerProfileIds.length != idsOfProfileFollowed.length ||\n            followerProfileIds.length != followTokenIds.length\n        ) {\n            revert Errors.ArrayMismatch();\n        }\n        uint256 i;\n        while (i < followerProfileIds.length) {\n            _migrateFollow(followerProfileIds[i], idsOfProfileFollowed[i], followTokenIds[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _migrateFollow(\n        uint256 followerProfileId,\n        uint256 idOfProfileFollowed,\n        uint256 followTokenId\n    ) private {\n        uint48 mintTimestamp = FollowNFT(StorageLib.getProfile(idOfProfileFollowed).followNFT).tryMigrate({\n            followerProfileId: followerProfileId,\n            followerProfileOwner: StorageLib.getTokenData(followerProfileId).owner,\n            idOfProfileFollowed: idOfProfileFollowed,\n            followTokenId: followTokenId\n        });\n        // `mintTimestamp` will be 0 if:\n        // - Follow NFT was already migrated\n        // - Follow NFT does not exist or was burnt\n        // - Follower profile Owner is different from Follow NFT Owner\n        if (mintTimestamp != 0) {\n            emit Events.Followed({\n                followerProfileId: followerProfileId,\n                idOfProfileFollowed: idOfProfileFollowed,\n                followTokenIdAssigned: followTokenId,\n                followModuleData: '',\n                processFollowModuleReturnData: '',\n                timestamp: mintTimestamp // The only case where this won't match block.timestamp is during the migration\n            });\n        }\n    }\n\n    function batchMigrateFollowModules(\n        uint256[] calldata profileIds,\n        address legacyFeeFollowModule,\n        address legacyProfileFollowModule,\n        address newFeeFollowModule\n    ) external {\n        uint256 i;\n        while (i < profileIds.length) {\n            address currentFollowModule = StorageLib.getProfile(profileIds[i]).followModule;\n            if (currentFollowModule == legacyFeeFollowModule) {\n                // If the profile had the legacy 'feeFollowModule' set, we need to read its parameters\n                // and initialize the new feeFollowModule with them.\n                StorageLib.getProfile(profileIds[i]).followModule = newFeeFollowModule;\n                ILegacyFeeFollowModule.ProfileData memory feeFollowModuleData = ILegacyFeeFollowModule(\n                    legacyFeeFollowModule\n                ).getProfileData(profileIds[i]);\n                IFollowModule(newFeeFollowModule).initializeFollowModule({\n                    profileId: profileIds[i],\n                    transactionExecutor: msg.sender,\n                    data: abi.encode(\n                        feeFollowModuleData.currency,\n                        feeFollowModuleData.amount,\n                        feeFollowModuleData.recipient\n                    )\n                });\n            } else if (currentFollowModule == legacyProfileFollowModule) {\n                // If the profile had `ProfileFollowModule` set, we just remove the follow module, as in Lens V2\n                // you can only follow with a Lens profile.\n                delete StorageLib.getProfile(profileIds[i]).followModule;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/FollowNFT.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.15;\n\nimport {Types} from 'contracts/libraries/constants/Types.sol';\nimport {ERC2981CollectionRoyalties} from 'contracts/base/ERC2981CollectionRoyalties.sol';\nimport {Errors} from 'contracts/libraries/constants/Errors.sol';\nimport {HubRestricted} from 'contracts/base/HubRestricted.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport {IERC721Timestamped} from 'contracts/interfaces/IERC721Timestamped.sol';\nimport {IFollowNFT} from 'contracts/interfaces/IFollowNFT.sol';\nimport {ILensHub} from 'contracts/interfaces/ILensHub.sol';\nimport {LensBaseERC721} from 'contracts/base/LensBaseERC721.sol';\nimport {Strings} from '@openzeppelin/contracts/utils/Strings.sol';\nimport {StorageLib} from 'contracts/libraries/StorageLib.sol';\nimport {FollowTokenURILib} from 'contracts/libraries/token-uris/FollowTokenURILib.sol';\n\ncontract FollowNFT is HubRestricted, LensBaseERC721, ERC2981CollectionRoyalties, IFollowNFT {\n    using Strings for uint256;\n\n    string constant FOLLOW_NFT_NAME_SUFFIX = '-Follower';\n    string constant FOLLOW_NFT_SYMBOL_SUFFIX = '-Fl';\n\n    uint256[5] ___DEPRECATED_SLOTS; // Deprecated slots, previously used for delegations.\n    uint256 internal _followedProfileId;\n\n    // Old uint256 `_lastFollowTokenId` slot splitted into two uint128s to include `_followerCount`.\n    uint128 internal _lastFollowTokenId;\n    // `_followerCount` will not be decreased when a follower profile is burned, making the counter not fully accurate.\n    // New variable added in V2 in the same slot, lower-ordered to not conflict with previous storage layout.\n    uint128 internal _followerCount;\n\n    bool private _initialized;\n\n    // Introduced in v2\n    mapping(uint256 => Types.FollowData) internal _followDataByFollowTokenId;\n    mapping(uint256 => uint256) internal _followTokenIdByFollowerProfileId;\n    mapping(uint256 => uint256) internal _followApprovalByFollowTokenId;\n    uint256 internal _royaltiesInBasisPoints;\n\n    event FollowApproval(uint256 indexed followerProfileId, uint256 indexed followTokenId);\n\n    constructor(address hub) HubRestricted(hub) {\n        _initialized = true;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function initialize(uint256 profileId) external override {\n        // This is called right after deployment by the LensHub, so we can skip the onlyHub check.\n        if (_initialized) {\n            revert Errors.Initialized();\n        }\n        _initialized = true;\n        _followedProfileId = profileId;\n        _setRoyalty(1000); // 10% of royalties\n    }\n\n    /// @inheritdoc IFollowNFT\n    function follow(\n        uint256 followerProfileId,\n        address transactionExecutor,\n        uint256 followTokenId\n    ) external override onlyHub returns (uint256) {\n        if (_followTokenIdByFollowerProfileId[followerProfileId] != 0) {\n            revert AlreadyFollowing();\n        }\n\n        if (followTokenId == 0) {\n            // Fresh follow.\n            return _followMintingNewToken(followerProfileId);\n        }\n\n        address followTokenOwner = _unsafeOwnerOf(followTokenId);\n        if (followTokenOwner != address(0)) {\n            // Provided follow token is wrapped.\n            return\n                _followWithWrappedToken({\n                    followerProfileId: followerProfileId,\n                    transactionExecutor: transactionExecutor,\n                    followTokenId: followTokenId,\n                    followTokenOwner: followTokenOwner\n                });\n        }\n\n        uint256 currentFollowerProfileId = _followDataByFollowTokenId[followTokenId].followerProfileId;\n        if (currentFollowerProfileId != 0) {\n            // Provided follow token is unwrapped.\n            // It has a follower profile set already, it can only be used to follow if that profile was burnt.\n            return\n                _followWithUnwrappedTokenFromBurnedProfile({\n                    followerProfileId: followerProfileId,\n                    followTokenId: followTokenId,\n                    currentFollowerProfileId: currentFollowerProfileId\n                });\n        }\n\n        // Provided follow token does not exist anymore, it can only be used if the profile attempting to follow is\n        // allowed to recover it.\n        return _followByRecoveringToken({followerProfileId: followerProfileId, followTokenId: followTokenId});\n    }\n\n    /// @inheritdoc IFollowNFT\n    function unfollow(uint256 unfollowerProfileId, address transactionExecutor) external override onlyHub {\n        uint256 followTokenId = _followTokenIdByFollowerProfileId[unfollowerProfileId];\n        if (followTokenId == 0) {\n            revert NotFollowing();\n        }\n        address followTokenOwner = _unsafeOwnerOf(followTokenId);\n        if (followTokenOwner == address(0)) {\n            // Follow token is unwrapped.\n            // Unfollowing and allowing recovery.\n            _unfollow({unfollower: unfollowerProfileId, followTokenId: followTokenId});\n            _followDataByFollowTokenId[followTokenId].profileIdAllowedToRecover = unfollowerProfileId;\n        } else {\n            // Follow token is wrapped.\n            address unfollowerProfileOwner = IERC721(HUB).ownerOf(unfollowerProfileId);\n            // Follower profile owner or its approved delegated executor must hold the token or be approved-for-all.\n            if (\n                (followTokenOwner != unfollowerProfileOwner) &&\n                (followTokenOwner != transactionExecutor) &&\n                !isApprovedForAll(followTokenOwner, transactionExecutor) &&\n                !isApprovedForAll(followTokenOwner, unfollowerProfileOwner)\n            ) {\n                revert DoesNotHavePermissions();\n            }\n            _unfollow({unfollower: unfollowerProfileId, followTokenId: followTokenId});\n        }\n    }\n\n    /// @inheritdoc IFollowNFT\n    function removeFollower(uint256 followTokenId) external override {\n        address followTokenOwner = ownerOf(followTokenId);\n        if (followTokenOwner == msg.sender || isApprovedForAll(followTokenOwner, msg.sender)) {\n            _unfollowIfHasFollower(followTokenId);\n        } else {\n            revert DoesNotHavePermissions();\n        }\n    }\n\n    /// @inheritdoc IFollowNFT\n    function approveFollow(uint256 followerProfileId, uint256 followTokenId) external override {\n        if (!IERC721Timestamped(HUB).exists(followerProfileId)) {\n            revert Errors.TokenDoesNotExist();\n        }\n        address followTokenOwner = _unsafeOwnerOf(followTokenId);\n        if (followTokenOwner == address(0)) {\n            revert OnlyWrappedFollowTokens();\n        }\n        if (followTokenOwner != msg.sender && !isApprovedForAll(followTokenOwner, msg.sender)) {\n            revert DoesNotHavePermissions();\n        }\n        _approveFollow(followerProfileId, followTokenId);\n    }\n\n    /// @inheritdoc IFollowNFT\n    function wrap(uint256 followTokenId, address wrappedTokenReceiver) external override {\n        if (wrappedTokenReceiver == address(0)) {\n            revert Errors.InvalidParameter();\n        }\n        _wrap(followTokenId, wrappedTokenReceiver);\n    }\n\n    /// @inheritdoc IFollowNFT\n    function wrap(uint256 followTokenId) external override {\n        _wrap(followTokenId, address(0));\n    }\n\n    function _wrap(uint256 followTokenId, address wrappedTokenReceiver) internal {\n        if (_isFollowTokenWrapped(followTokenId)) {\n            revert AlreadyWrapped();\n        }\n        uint256 followerProfileId = _followDataByFollowTokenId[followTokenId].followerProfileId;\n        if (followerProfileId == 0) {\n            followerProfileId = _followDataByFollowTokenId[followTokenId].profileIdAllowedToRecover;\n            if (followerProfileId == 0) {\n                revert FollowTokenDoesNotExist();\n            }\n            delete _followDataByFollowTokenId[followTokenId].profileIdAllowedToRecover;\n        }\n        address followerProfileOwner = IERC721(HUB).ownerOf(followerProfileId);\n        if (msg.sender != followerProfileOwner) {\n            revert DoesNotHavePermissions();\n        }\n        _mint(wrappedTokenReceiver == address(0) ? followerProfileOwner : wrappedTokenReceiver, followTokenId);\n    }\n\n    /// @inheritdoc IFollowNFT\n    function unwrap(uint256 followTokenId) external override {\n        if (_followDataByFollowTokenId[followTokenId].followerProfileId == 0) {\n            revert NotFollowing();\n        }\n        super.burn(followTokenId);\n    }\n\n    /// @inheritdoc IFollowNFT\n    function processBlock(uint256 followerProfileId) external override onlyHub returns (bool) {\n        bool hasUnfollowed;\n        uint256 followTokenId = _followTokenIdByFollowerProfileId[followerProfileId];\n        if (followTokenId != 0) {\n            if (!_isFollowTokenWrapped(followTokenId)) {\n                // Wrap it first, so the user stops following but does not lose the token when being blocked.\n                _mint(IERC721(HUB).ownerOf(followerProfileId), followTokenId);\n            }\n            _unfollow(followerProfileId, followTokenId);\n            hasUnfollowed = true;\n        }\n        return hasUnfollowed;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getFollowerProfileId(uint256 followTokenId) external view override returns (uint256) {\n        return _followDataByFollowTokenId[followTokenId].followerProfileId;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function isFollowing(uint256 followerProfileId) external view override returns (bool) {\n        return _followTokenIdByFollowerProfileId[followerProfileId] != 0;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getFollowTokenId(uint256 followerProfileId) external view override returns (uint256) {\n        return _followTokenIdByFollowerProfileId[followerProfileId];\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getOriginalFollowTimestamp(uint256 followTokenId) external view override returns (uint256) {\n        return _followDataByFollowTokenId[followTokenId].originalFollowTimestamp;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getFollowTimestamp(uint256 followTokenId) external view override returns (uint256) {\n        return _followDataByFollowTokenId[followTokenId].followTimestamp;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getProfileIdAllowedToRecover(uint256 followTokenId) external view override returns (uint256) {\n        return _followDataByFollowTokenId[followTokenId].profileIdAllowedToRecover;\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getFollowData(uint256 followTokenId) external view override returns (Types.FollowData memory) {\n        return _followDataByFollowTokenId[followTokenId];\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getFollowApproved(uint256 followTokenId) external view override returns (uint256) {\n        return _followApprovalByFollowTokenId[followTokenId];\n    }\n\n    /// @inheritdoc IFollowNFT\n    function getFollowerCount() external view override returns (uint256) {\n        return _followerCount;\n    }\n\n    function burn(uint256 followTokenId) public override {\n        _unfollowIfHasFollower(followTokenId);\n        super.burn(followTokenId);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(LensBaseERC721, ERC2981CollectionRoyalties)\n        returns (bool)\n    {\n        return\n            LensBaseERC721.supportsInterface(interfaceId) || ERC2981CollectionRoyalties.supportsInterface(interfaceId);\n    }\n\n    function name() public view override returns (string memory) {\n        return string(abi.encodePacked(_followedProfileId.toString(), FOLLOW_NFT_NAME_SUFFIX));\n    }\n\n    function symbol() public view override returns (string memory) {\n        return string(abi.encodePacked(_followedProfileId.toString(), FOLLOW_NFT_SYMBOL_SUFFIX));\n    }\n\n    /**\n     * @dev This returns the follow NFT URI fetched from the hub.\n     */\n    function tokenURI(uint256 followTokenId) public view override returns (string memory) {\n        if (!_exists(followTokenId)) {\n            revert Errors.TokenDoesNotExist();\n        }\n        return\n            FollowTokenURILib.getTokenURI(\n                followTokenId,\n                _followedProfileId,\n                _followDataByFollowTokenId[followTokenId].originalFollowTimestamp\n            );\n    }\n\n    function _followMintingNewToken(uint256 followerProfileId) internal returns (uint256) {\n        uint256 followTokenIdAssigned;\n        unchecked {\n            followTokenIdAssigned = ++_lastFollowTokenId;\n            _followerCount++;\n        }\n        _baseFollow({\n            followerProfileId: followerProfileId,\n            followTokenId: followTokenIdAssigned,\n            isOriginalFollow: true\n        });\n        return followTokenIdAssigned;\n    }\n\n    function _followWithWrappedToken(\n        uint256 followerProfileId,\n        address transactionExecutor,\n        uint256 followTokenId,\n        address followTokenOwner\n    ) internal returns (uint256) {\n        bool isFollowApproved = _followApprovalByFollowTokenId[followTokenId] == followerProfileId;\n        address followerProfileOwner = IERC721(HUB).ownerOf(followerProfileId);\n        if (\n            !isFollowApproved &&\n            followTokenOwner != followerProfileOwner &&\n            followTokenOwner != transactionExecutor &&\n            !isApprovedForAll(followTokenOwner, transactionExecutor) &&\n            !isApprovedForAll(followTokenOwner, followerProfileOwner)\n        ) {\n            revert DoesNotHavePermissions();\n        }\n        // The transactionExecutor is allowed to write the follower in that wrapped token.\n        if (isFollowApproved) {\n            // The `_followApprovalByFollowTokenId` was used, and now it needs to be cleared.\n            _approveFollow(0, followTokenId);\n        }\n        _replaceFollower({\n            currentFollowerProfileId: _followDataByFollowTokenId[followTokenId].followerProfileId,\n            newFollowerProfileId: followerProfileId,\n            followTokenId: followTokenId\n        });\n        return followTokenId;\n    }\n\n    function _followWithUnwrappedTokenFromBurnedProfile(\n        uint256 followerProfileId,\n        uint256 followTokenId,\n        uint256 currentFollowerProfileId\n    ) internal returns (uint256) {\n        if (IERC721Timestamped(HUB).exists(currentFollowerProfileId)) {\n            revert DoesNotHavePermissions();\n        }\n        _replaceFollower({\n            currentFollowerProfileId: currentFollowerProfileId,\n            newFollowerProfileId: followerProfileId,\n            followTokenId: followTokenId\n        });\n        return followTokenId;\n    }\n\n    function _followByRecoveringToken(uint256 followerProfileId, uint256 followTokenId) internal returns (uint256) {\n        if (_followDataByFollowTokenId[followTokenId].profileIdAllowedToRecover != followerProfileId) {\n            revert FollowTokenDoesNotExist();\n        }\n        unchecked {\n            _followerCount++;\n        }\n        _baseFollow({followerProfileId: followerProfileId, followTokenId: followTokenId, isOriginalFollow: false});\n        return followTokenId;\n    }\n\n    function _replaceFollower(\n        uint256 currentFollowerProfileId,\n        uint256 newFollowerProfileId,\n        uint256 followTokenId\n    ) internal {\n        if (currentFollowerProfileId != 0) {\n            // As it has a follower, unfollow first, removing the current follower.\n            delete _followTokenIdByFollowerProfileId[currentFollowerProfileId];\n            ILensHub(HUB).emitUnfollowedEvent(currentFollowerProfileId, _followedProfileId);\n        } else {\n            unchecked {\n                _followerCount++;\n            }\n        }\n        // Perform the follow, setting a new follower.\n        _baseFollow({followerProfileId: newFollowerProfileId, followTokenId: followTokenId, isOriginalFollow: false});\n    }\n\n    function _baseFollow(\n        uint256 followerProfileId,\n        uint256 followTokenId,\n        bool isOriginalFollow\n    ) internal {\n        _followTokenIdByFollowerProfileId[followerProfileId] = followTokenId;\n        _followDataByFollowTokenId[followTokenId].followerProfileId = uint160(followerProfileId);\n        _followDataByFollowTokenId[followTokenId].followTimestamp = uint48(block.timestamp);\n        delete _followDataByFollowTokenId[followTokenId].profileIdAllowedToRecover;\n        if (isOriginalFollow) {\n            _followDataByFollowTokenId[followTokenId].originalFollowTimestamp = uint48(block.timestamp);\n        } else {\n            // Migration code.\n            // If the follow token was minted before the originalFollowTimestamp was introduced, it will be 0.\n            // In that case, we need to fetch the mint timestamp from the token data.\n            if (_followDataByFollowTokenId[followTokenId].originalFollowTimestamp == 0) {\n                uint48 mintTimestamp = uint48(StorageLib.getTokenData(followTokenId).mintTimestamp);\n                _followDataByFollowTokenId[followTokenId].originalFollowTimestamp = mintTimestamp;\n            }\n        }\n    }\n\n    function _unfollowIfHasFollower(uint256 followTokenId) internal {\n        uint256 followerProfileId = _followDataByFollowTokenId[followTokenId].followerProfileId;\n        if (followerProfileId != 0) {\n            _unfollow(followerProfileId, followTokenId);\n            ILensHub(HUB).emitUnfollowedEvent(followerProfileId, _followedProfileId);\n        }\n    }\n\n    function _unfollow(uint256 unfollower, uint256 followTokenId) internal {\n        unchecked {\n            // This is safe, as this line can only be reached if the unfollowed profile is being followed by the\n            // unfollower profile, so _followerCount is guaranteed to be greater than zero.\n            _followerCount--;\n        }\n        delete _followTokenIdByFollowerProfileId[unfollower];\n        delete _followDataByFollowTokenId[followTokenId].followerProfileId;\n        delete _followDataByFollowTokenId[followTokenId].followTimestamp;\n        delete _followDataByFollowTokenId[followTokenId].profileIdAllowedToRecover;\n    }\n\n    function _approveFollow(uint256 approvedProfileId, uint256 followTokenId) internal {\n        _followApprovalByFollowTokenId[followTokenId] = approvedProfileId;\n        emit FollowApproval(approvedProfileId, followTokenId);\n    }\n\n    /**\n     * @dev Upon transfers, we clear follow approvals and emit the transfer event in the hub.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 followTokenId\n    ) internal override {\n        if (from != address(0)) {\n            // It is cleared on unwrappings and transfers, and it can not be set on unwrapped tokens.\n            // As a consequence, there is no need to clear it on wrappings.\n            _approveFollow(0, followTokenId);\n        }\n        super._beforeTokenTransfer(from, to, followTokenId);\n    }\n\n    function _getReceiver(\n        uint256 /* followTokenId */\n    ) internal view override returns (address) {\n        return IERC721(HUB).ownerOf(_followedProfileId);\n    }\n\n    function _beforeRoyaltiesSet(\n        uint256 /* royaltiesInBasisPoints */\n    ) internal view override {\n        if (IERC721(HUB).ownerOf(_followedProfileId) != msg.sender) {\n            revert Errors.NotProfileOwner();\n        }\n    }\n\n    function _isFollowTokenWrapped(uint256 followTokenId) internal view returns (bool) {\n        return _exists(followTokenId);\n    }\n\n    function _getRoyaltiesInBasisPointsSlot() internal pure override returns (uint256) {\n        uint256 slot;\n        assembly {\n            slot := _royaltiesInBasisPoints.slot\n        }\n        return slot;\n    }\n\n    //////////////////\n    /// Migrations ///\n    //////////////////\n\n    // This function shouldn't fail under no circumstances, except if wrong parameters are passed.\n    function tryMigrate(\n        uint256 followerProfileId,\n        address followerProfileOwner,\n        uint256 idOfProfileFollowed,\n        uint256 followTokenId\n    ) external onlyHub returns (uint48) {\n        // Migrated FollowNFTs should have `originalFollowTimestamp` set\n        if (_followDataByFollowTokenId[followTokenId].originalFollowTimestamp != 0) {\n            return 0; // Already migrated\n        }\n\n        if (_followedProfileId != idOfProfileFollowed) {\n            revert Errors.InvalidParameter();\n        }\n\n        if (!_exists(followTokenId)) {\n            return 0; // Doesn't exist\n        }\n\n        address followTokenOwner = ownerOf(followTokenId);\n\n        // ProfileNFT and FollowNFT should be in the same account\n        if (followerProfileOwner != followTokenOwner) {\n            return 0; // Not holding both Profile & Follow NFTs together\n        }\n\n        unchecked {\n            ++_followerCount;\n        }\n\n        _followTokenIdByFollowerProfileId[followerProfileId] = followTokenId;\n\n        uint48 mintTimestamp = uint48(StorageLib.getTokenData(followTokenId).mintTimestamp);\n\n        _followDataByFollowTokenId[followTokenId].followerProfileId = uint160(followerProfileId);\n        _followDataByFollowTokenId[followTokenId].originalFollowTimestamp = mintTimestamp;\n        _followDataByFollowTokenId[followTokenId].followTimestamp = mintTimestamp;\n\n        super._burn(followTokenId);\n        return mintTimestamp;\n    }\n}"
    },
    {
      "filename": "test/migrations/Migrations.t.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport 'forge-std/Test.sol';\nimport {ForkManagement} from 'test/helpers/ForkManagement.sol';\nimport {LegacyCollectNFT} from 'contracts/misc/LegacyCollectNFT.sol';\nimport {LensHub} from 'contracts/LensHub.sol';\nimport {FollowNFT} from 'contracts/FollowNFT.sol';\nimport {TransparentUpgradeableProxy} from '@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol';\nimport {ModuleGlobals} from 'contracts/misc/ModuleGlobals.sol';\nimport {LensHandles} from 'contracts/namespaces/LensHandles.sol';\nimport {TokenHandleRegistry} from 'contracts/namespaces/TokenHandleRegistry.sol';\nimport {Types} from 'contracts/libraries/constants/Types.sol';\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport {IERC721Enumerable} from '@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol';\nimport 'test/Constants.sol';\n\ncontract MigrationsTest is Test, ForkManagement {\n    using stdJson for string;\n\n    uint256 internal constant LENS_PROTOCOL_PROFILE_ID = 1;\n    uint256 internal constant ENUMERABLE_GET_FIRST_PROFILE = 0;\n\n    address owner = address(0x087E4);\n    address deployer = address(1);\n    address governance;\n    address modulesGovernance;\n    address treasury;\n    address hubProxyAddr;\n    address proxyAdmin;\n\n    LensHandles lensHandles;\n    TokenHandleRegistry tokenHandleRegistry;\n\n    LegacyCollectNFT legacyCollectNFT;\n    FollowNFT followNFT;\n    LensHub hubImpl;\n    TransparentUpgradeableProxy hubAsProxy;\n    LensHub hub;\n    ModuleGlobals moduleGlobals;\n\n    uint256[] followerProfileIds = new uint256[](10);\n\n    function loadBaseAddresses(string memory targetEnv) internal virtual {\n        console.log('targetEnv:', targetEnv);\n\n        hubProxyAddr = json.readAddress(string(abi.encodePacked('.', targetEnv, '.LensHubProxy')));\n        console.log('hubProxyAddr:', hubProxyAddr);\n\n        hub = LensHub(hubProxyAddr);"
    }
  ]
}