{
  "Title": "[M-13] In `ERC20Boost.sol`, a user can be `attached` to a gauge and have no boost balance.",
  "Content": "\nWhen a user with a boosted gauge becomes deprecated, the user can transfer their boost tokens. When the same gauge is reintroduced to the active gauge list, the user will boost it again, even if their boost token balance is zero.\n\n### Impact\n\nThe same amount of boost tokens can be allocated to gauges by multiple addresses.\n\n### Proof of Concept\n\nLet's take an example:\n\n1. Alice calls `attach()` from `gaugeA` to boost it; `getUserBoost[alice]` is set to `balanceOf(alice)`.\n2. The owner removes `gaugeA` and it's added to `_deprecatedGauges`.\n3. Alice calls `updateUserBoost()`; because `gaugeA` is now deprecated, their allocated boost is set to `userBoost` which is initialized to zero (0):\n\n```solidity\n    function updateUserBoost(address user) external {\n        uint256 userBoost = 0;\n        address[] memory gaugeList = _userGauges[user].values();\n        uint256 length = gaugeList.length;\n        for (uint256 i = 0; i < length;) {\n            address gauge = gaugeList[i];\n            if (!_deprecatedGauges.contains(gauge)) {\n                uint256 gaugeBoost = getUserGaugeBoost[user][gauge].userGaugeBoost;\n                if (userBoost < gaugeBoost) userBoost = gaugeBoost;\n            }\n            unchecked {\n                i++;\n            }\n        }\n        getUserBoost[user] = userBoost;\n        emit UpdateUserBoost(user, userBoost);\n    } \n```\n\n4. `freeGaugeBoost()` returns the amount of unallocated boost tokens:\n\n```solidity\n\nfunction freeGaugeBoost(address user) public view returns (uint256) {\n\treturn balanceOf[user] - getUserBoost[user];\n}\n\n```\n\n5. `transfer()` has the `notAttached()` modifier that ensures the transferred amount is free (not allocated to any gauge):\n\n```solidity\n    /**\n     * @notice Transfers `amount` of tokens from `msg.sender` to `to` address.\n     * @dev User must have enough free boost.\n     * @param to the address to transfer to.\n     * @param amount the amount to transfer.\n     */\n    function transfer(address to, uint256 amount) public override notAttached(msg.sender, amount) returns (bool) {\n        return super.transfer(to, amount);\n    }\n```\n\n6. Alice transfers their tokens.\n7. When `gaugeA` is added back, `addGauge(gaugeA)`, Alice will continue to boost `gaugeA` even if their balance is 0.\n\n<https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/erc-20/ERC20Boost.sol#L150-L172>\n\n<https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/erc-20/ERC20Boost.sol#L81C1-L83C6>\n\n<https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/erc-20/ERC20Boost.sol#L336-L344>\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\nOne solution is `updateUserBoost()` to loop all gauges (active and deprecated), not only the active ones:\n\n```solidity\n    function updateUserBoost(address user) external {\n        uint256 userBoost = 0;\n        address[] memory gaugeList = _userGauges[user].values();\n\n\n        uint256 length = gaugeList.length;\n        for (uint256 i = 0; i < length;) {\n            address gauge = gaugeList[i];\n            uint256 gaugeBoost = getUserGaugeBoost[user][gauge].userGaugeBoost;\n            if (userBoost < gaugeBoost) userBoost = gaugeBoost;\n            unchecked {\n                i++;\n            }\n        }\n        getUserBoost[user] = userBoost;\n        emit UpdateUserBoost(user, userBoost);\n    }\n```\n\nEven the `updateUserBoost()` comments indicate all `_userGauges` should be iterated over.\n\n```solidity\n/**\n* @notice Update geUserBoost for a user, loop through all _userGauges\n* @param user the user to update the boost for.\n*/\nfunction  updateUserBoost(address user) external;\n```\n\n### Assessed type\n\nOther\n\n**[0xLightt (Maia) confirmed](https://github.com/code-423n4/2023-05-maia-findings/issues/656#issuecomment-1632929622)**\n\n**[0xLightt (Maia) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/656#issuecomment-1708812372):**\n > Addressed [here](https://github.com/Maia-DAO/eco-c4-contest/tree/656).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/erc-20/ERC20Boost.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {EnumerableSet} from \"@lib/EnumerableSet.sol\";\n\nimport {IBaseV2Gauge} from \"@gauges/interfaces/IBaseV2Gauge.sol\";\n\nimport {Errors} from \"./interfaces/Errors.sol\";\nimport {IERC20Boost} from \"./interfaces/IERC20Boost.sol\";\n\n/// @title An ERC20 with an embedded attachment mechanism to keep track of boost\n///        allocations to gauges.\nabstract contract ERC20Boost is ERC20, Ownable, IERC20Boost {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using SafeCastLib for *;\n\n    /*///////////////////////////////////////////////////////////////\n                            GAUGE STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Boost\n    mapping(address => mapping(address => GaugeState)) public override getUserGaugeBoost;\n\n    /// @inheritdoc IERC20Boost\n    mapping(address => uint256) public override getUserBoost;\n\n    mapping(address => EnumerableSet.AddressSet) internal _userGauges;\n\n    EnumerableSet.AddressSet internal _gauges;\n\n    // Store deprecated gauges in case a user needs to free dead boost\n    EnumerableSet.AddressSet internal _deprecatedGauges;\n\n    /*///////////////////////////////////////////////////////////////\n                            VIEW HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Boost\n    function gauges() external view returns (address[] memory) {\n        return _gauges.values();\n    }\n\n    /// @inheritdoc IERC20Boost\n    function gauges(uint256 offset, uint256 num) external view returns (address[] memory values) {\n        values = new address[](num);\n        for (uint256 i = 0; i < num;) {\n            unchecked {\n                values[i] = _gauges.at(offset + i); // will revert if out of bounds\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC20Boost\n    function isGauge(address gauge) external view returns (bool) {\n        return _gauges.contains(gauge) && !_deprecatedGauges.contains(gauge);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function numGauges() external view returns (uint256) {\n        return _gauges.length();\n    }\n\n    /// @inheritdoc IERC20Boost\n    function deprecatedGauges() external view returns (address[] memory) {\n        return _deprecatedGauges.values();\n    }\n\n    /// @inheritdoc IERC20Boost\n    function numDeprecatedGauges() external view returns (uint256) {\n        return _deprecatedGauges.length();\n    }\n\n    /// @inheritdoc IERC20Boost\n    function freeGaugeBoost(address user) public view returns (uint256) {\n        return balanceOf[user] - getUserBoost[user];\n    }\n\n    /// @inheritdoc IERC20Boost\n    function userGauges(address user) external view returns (address[] memory) {\n        return _userGauges[user].values();\n    }\n\n    /// @inheritdoc IERC20Boost\n    function isUserGauge(address user, address gauge) external view returns (bool) {\n        return _userGauges[user].contains(gauge);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function userGauges(address user, uint256 offset, uint256 num) external view returns (address[] memory values) {\n        values = new address[](num);\n        for (uint256 i = 0; i < num;) {\n            unchecked {\n                values[i] = _userGauges[user].at(offset + i); // will revert if out of bounds\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC20Boost\n    function numUserGauges(address user) external view returns (uint256) {\n        return _userGauges[user].length();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        GAUGE OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Boost\n    function attach(address user) external {\n        if (!_gauges.contains(msg.sender) || _deprecatedGauges.contains(msg.sender)) {\n            revert InvalidGauge();\n        }\n\n        // idempotent add\n        if (!_userGauges[user].add(msg.sender)) revert GaugeAlreadyAttached();\n\n        uint128 userGaugeBoost = balanceOf[user].toUint128();\n\n        if (getUserBoost[user] < userGaugeBoost) {\n            getUserBoost[user] = userGaugeBoost;\n            emit UpdateUserBoost(user, userGaugeBoost);\n        }\n\n        getUserGaugeBoost[user][msg.sender] =\n            GaugeState({userGaugeBoost: userGaugeBoost, totalGaugeBoost: totalSupply.toUint128()});\n\n        emit Attach(user, msg.sender, userGaugeBoost);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function detach(address user) external {\n        require(_userGauges[user].remove(msg.sender));\n        delete getUserGaugeBoost[user][msg.sender];\n\n        emit Detach(user, msg.sender);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        USER GAUGE OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Boost\n    function updateUserBoost(address user) external {\n        uint256 userBoost = 0;\n\n        address[] memory gaugeList = _userGauges[user].values();\n\n        uint256 length = gaugeList.length;\n        for (uint256 i = 0; i < length;) {\n            address gauge = gaugeList[i];\n\n            if (!_deprecatedGauges.contains(gauge)) {\n                uint256 gaugeBoost = getUserGaugeBoost[user][gauge].userGaugeBoost;\n\n                if (userBoost < gaugeBoost) userBoost = gaugeBoost;\n            }\n\n            unchecked {\n                i++;\n            }\n        }\n        getUserBoost[user] = userBoost;\n\n        emit UpdateUserBoost(user, userBoost);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function decrementGaugeBoost(address gauge, uint256 boost) public {\n        GaugeState storage gaugeState = getUserGaugeBoost[msg.sender][gauge];\n        if (boost >= gaugeState.userGaugeBoost) {\n            _userGauges[msg.sender].remove(gauge);\n            delete getUserGaugeBoost[msg.sender][gauge];\n\n            emit Detach(msg.sender, gauge);\n        } else {\n            gaugeState.userGaugeBoost -= boost.toUint128();\n\n            emit DecrementUserGaugeBoost(msg.sender, gauge, gaugeState.userGaugeBoost);\n        }\n    }\n\n    /// @inheritdoc IERC20Boost\n    function decrementGaugeAllBoost(address gauge) external {\n        require(_userGauges[msg.sender].remove(gauge));\n        delete getUserGaugeBoost[msg.sender][gauge];\n\n        emit Detach(msg.sender, gauge);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function decrementAllGaugesBoost(uint256 boost) external {\n        decrementGaugesBoostIndexed(boost, 0, _userGauges[msg.sender].length());\n    }\n\n    /// @inheritdoc IERC20Boost\n    function decrementGaugesBoostIndexed(uint256 boost, uint256 offset, uint256 num) public {\n        address[] memory gaugeList = _userGauges[msg.sender].values();\n\n        uint256 length = gaugeList.length;\n        for (uint256 i = 0; i < num && i < length;) {\n            address gauge = gaugeList[offset + i];\n\n            GaugeState storage gaugeState = getUserGaugeBoost[msg.sender][gauge];\n\n            if (_deprecatedGauges.contains(gauge) || boost >= gaugeState.userGaugeBoost) {\n                require(_userGauges[msg.sender].remove(gauge)); // Remove from set. Should never fail.\n                delete getUserGaugeBoost[msg.sender][gauge];\n\n                emit Detach(msg.sender, gauge);\n            } else {\n                gaugeState.userGaugeBoost -= boost.toUint128();\n\n                emit DecrementUserGaugeBoost(msg.sender, gauge, gaugeState.userGaugeBoost);\n            }\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC20Boost\n    function decrementAllGaugesAllBoost() external {\n        // Loop through all user gauges, live and deprecated\n        address[] memory gaugeList = _userGauges[msg.sender].values();\n\n        // Free gauges until through the entire list\n        uint256 size = gaugeList.length;\n        for (uint256 i = 0; i < size;) {\n            address gauge = gaugeList[i];\n\n            require(_userGauges[msg.sender].remove(gauge)); // Remove from set. Should never fail.\n            delete getUserGaugeBoost[msg.sender][gauge];\n\n            emit Detach(msg.sender, gauge);\n\n            unchecked {\n                i++;\n            }\n        }\n\n        getUserBoost[msg.sender] = 0;\n\n        emit UpdateUserBoost(msg.sender, 0);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        ADMIN GAUGE OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Boost\n    function addGauge(address gauge) external onlyOwner {\n        _addGauge(gauge);\n    }\n\n    function _addGauge(address gauge) internal {\n        bool newAdd = _gauges.add(gauge);\n        bool previouslyDeprecated = _deprecatedGauges.remove(gauge);\n        // add and fail loud if zero address or already present and not deprecated\n        if (gauge == address(0) || !(newAdd || previouslyDeprecated)) revert InvalidGauge();\n\n        emit AddGauge(gauge);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function removeGauge(address gauge) external onlyOwner {\n        _removeGauge(gauge);\n    }\n\n    function _removeGauge(address gauge) internal {\n        // add to deprecated and fail loud if not present\n        if (!_deprecatedGauges.add(gauge)) revert InvalidGauge();\n\n        emit RemoveGauge(gauge);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function replaceGauge(address oldGauge, address newGauge) external onlyOwner {\n        _removeGauge(oldGauge);\n        _addGauge(newGauge);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// NOTE: any \"removal\" of tokens from a user requires notAttached < amount.\n\n    /**\n     * @notice Burns `amount` of tokens from `from` address.\n     * @dev User must have enough free boost.\n     * @param from The address to burn tokens from.\n     * @param amount The amount of tokens to burn.\n     */\n    function _burn(address from, uint256 amount) internal override notAttached(from, amount) {\n        super._burn(from, amount);\n    }\n\n    /**\n     * @notice Transfers `amount` of tokens from `msg.sender` to `to` address.\n     * @dev User must have enough free boost.\n     * @param to the address to transfer to.\n     * @param amount the amount to transfer.\n     */\n    function transfer(address to, uint256 amount) public override notAttached(msg.sender, amount) returns (bool) {\n        return super.transfer(to, amount);\n    }\n\n    /**\n     * @notice Transfers `amount` of tokens from `from` address to `to` address.\n     * @dev User must have enough free boost.\n     * @param from the address to transfer from.\n     * @param to the address to transfer to.\n     * @param amount the amount to transfer.\n     */\n    function transferFrom(address from, address to, uint256 amount)\n        public\n        override\n        notAttached(from, amount)\n        returns (bool)\n    {\n        return super.transferFrom(from, to, amount);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Reverts if the user does not have enough free boost.\n     * @param user The user address.\n     * @param amount The amount of boost.\n     */\n    modifier notAttached(address user, uint256 amount) {\n        if (freeGaugeBoost(user) < amount) revert AttachedBoost();\n        _;\n    }\n}"
    },
    {
      "filename": "src/erc-20/ERC20Boost.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {EnumerableSet} from \"@lib/EnumerableSet.sol\";\n\nimport {IBaseV2Gauge} from \"@gauges/interfaces/IBaseV2Gauge.sol\";\n\nimport {Errors} from \"./interfaces/Errors.sol\";\nimport {IERC20Boost} from \"./interfaces/IERC20Boost.sol\";\n\n/// @title An ERC20 with an embedded attachment mechanism to keep track of boost\n///        allocations to gauges.\nabstract contract ERC20Boost is ERC20, Ownable, IERC20Boost {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using SafeCastLib for *;\n\n    /*///////////////////////////////////////////////////////////////\n                            GAUGE STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Boost\n    mapping(address => mapping(address => GaugeState)) public override getUserGaugeBoost;\n\n    /// @inheritdoc IERC20Boost\n    mapping(address => uint256) public override getUserBoost;\n\n    mapping(address => EnumerableSet.AddressSet) internal _userGauges;\n\n    EnumerableSet.AddressSet internal _gauges;\n\n    // Store deprecated gauges in case a user needs to free dead boost\n    EnumerableSet.AddressSet internal _deprecatedGauges;\n\n    /*///////////////////////////////////////////////////////////////\n                            VIEW HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Boost\n    function gauges() external view returns (address[] memory) {\n        return _gauges.values();\n    }\n\n    /// @inheritdoc IERC20Boost\n    function gauges(uint256 offset, uint256 num) external view returns (address[] memory values) {\n        values = new address[](num);\n        for (uint256 i = 0; i < num;) {\n            unchecked {\n                values[i] = _gauges.at(offset + i); // will revert if out of bounds\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC20Boost\n    function isGauge(address gauge) external view returns (bool) {\n        return _gauges.contains(gauge) && !_deprecatedGauges.contains(gauge);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function numGauges() external view returns (uint256) {\n        return _gauges.length();\n    }\n\n    /// @inheritdoc IERC20Boost\n    function deprecatedGauges() external view returns (address[] memory) {\n        return _deprecatedGauges.values();\n    }\n\n    /// @inheritdoc IERC20Boost\n    function numDeprecatedGauges() external view returns (uint256) {\n        return _deprecatedGauges.length();\n    }\n\n    /// @inheritdoc IERC20Boost\n    function freeGaugeBoost(address user) public view returns (uint256) {\n        return balanceOf[user] - getUserBoost[user];\n    }\n\n    /// @inheritdoc IERC20Boost\n    function userGauges(address user) external view returns (address[] memory) {\n        return _userGauges[user].values();\n    }\n\n    /// @inheritdoc IERC20Boost\n    function isUserGauge(address user, address gauge) external view returns (bool) {\n        return _userGauges[user].contains(gauge);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function userGauges(address user, uint256 offset, uint256 num) external view returns (address[] memory values) {\n        values = new address[](num);\n        for (uint256 i = 0; i < num;) {\n            unchecked {\n                values[i] = _userGauges[user].at(offset + i); // will revert if out of bounds\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC20Boost\n    function numUserGauges(address user) external view returns (uint256) {\n        return _userGauges[user].length();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        GAUGE OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Boost\n    function attach(address user) external {\n        if (!_gauges.contains(msg.sender) || _deprecatedGauges.contains(msg.sender)) {\n            revert InvalidGauge();\n        }\n\n        // idempotent add\n        if (!_userGauges[user].add(msg.sender)) revert GaugeAlreadyAttached();\n\n        uint128 userGaugeBoost = balanceOf[user].toUint128();\n\n        if (getUserBoost[user] < userGaugeBoost) {\n            getUserBoost[user] = userGaugeBoost;\n            emit UpdateUserBoost(user, userGaugeBoost);\n        }\n\n        getUserGaugeBoost[user][msg.sender] =\n            GaugeState({userGaugeBoost: userGaugeBoost, totalGaugeBoost: totalSupply.toUint128()});\n\n        emit Attach(user, msg.sender, userGaugeBoost);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function detach(address user) external {\n        require(_userGauges[user].remove(msg.sender));\n        delete getUserGaugeBoost[user][msg.sender];\n\n        emit Detach(user, msg.sender);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        USER GAUGE OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Boost\n    function updateUserBoost(address user) external {\n        uint256 userBoost = 0;\n\n        address[] memory gaugeList = _userGauges[user].values();\n\n        uint256 length = gaugeList.length;\n        for (uint256 i = 0; i < length;) {\n            address gauge = gaugeList[i];\n\n            if (!_deprecatedGauges.contains(gauge)) {\n                uint256 gaugeBoost = getUserGaugeBoost[user][gauge].userGaugeBoost;\n\n                if (userBoost < gaugeBoost) userBoost = gaugeBoost;\n            }\n\n            unchecked {\n                i++;\n            }\n        }\n        getUserBoost[user] = userBoost;\n\n        emit UpdateUserBoost(user, userBoost);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function decrementGaugeBoost(address gauge, uint256 boost) public {\n        GaugeState storage gaugeState = getUserGaugeBoost[msg.sender][gauge];\n        if (boost >= gaugeState.userGaugeBoost) {\n            _userGauges[msg.sender].remove(gauge);\n            delete getUserGaugeBoost[msg.sender][gauge];\n\n            emit Detach(msg.sender, gauge);\n        } else {\n            gaugeState.userGaugeBoost -= boost.toUint128();\n\n            emit DecrementUserGaugeBoost(msg.sender, gauge, gaugeState.userGaugeBoost);\n        }\n    }\n\n    /// @inheritdoc IERC20Boost\n    function decrementGaugeAllBoost(address gauge) external {\n        require(_userGauges[msg.sender].remove(gauge));\n        delete getUserGaugeBoost[msg.sender][gauge];\n\n        emit Detach(msg.sender, gauge);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function decrementAllGaugesBoost(uint256 boost) external {\n        decrementGaugesBoostIndexed(boost, 0, _userGauges[msg.sender].length());\n    }\n\n    /// @inheritdoc IERC20Boost\n    function decrementGaugesBoostIndexed(uint256 boost, uint256 offset, uint256 num) public {\n        address[] memory gaugeList = _userGauges[msg.sender].values();\n\n        uint256 length = gaugeList.length;\n        for (uint256 i = 0; i < num && i < length;) {\n            address gauge = gaugeList[offset + i];\n\n            GaugeState storage gaugeState = getUserGaugeBoost[msg.sender][gauge];\n\n            if (_deprecatedGauges.contains(gauge) || boost >= gaugeState.userGaugeBoost) {\n                require(_userGauges[msg.sender].remove(gauge)); // Remove from set. Should never fail.\n                delete getUserGaugeBoost[msg.sender][gauge];\n\n                emit Detach(msg.sender, gauge);\n            } else {\n                gaugeState.userGaugeBoost -= boost.toUint128();\n\n                emit DecrementUserGaugeBoost(msg.sender, gauge, gaugeState.userGaugeBoost);\n            }\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC20Boost\n    function decrementAllGaugesAllBoost() external {\n        // Loop through all user gauges, live and deprecated\n        address[] memory gaugeList = _userGauges[msg.sender].values();\n\n        // Free gauges until through the entire list\n        uint256 size = gaugeList.length;\n        for (uint256 i = 0; i < size;) {\n            address gauge = gaugeList[i];\n\n            require(_userGauges[msg.sender].remove(gauge)); // Remove from set. Should never fail.\n            delete getUserGaugeBoost[msg.sender][gauge];\n\n            emit Detach(msg.sender, gauge);\n\n            unchecked {\n                i++;\n            }\n        }\n\n        getUserBoost[msg.sender] = 0;\n\n        emit UpdateUserBoost(msg.sender, 0);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        ADMIN GAUGE OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Boost\n    function addGauge(address gauge) external onlyOwner {\n        _addGauge(gauge);\n    }\n\n    function _addGauge(address gauge) internal {\n        bool newAdd = _gauges.add(gauge);\n        bool previouslyDeprecated = _deprecatedGauges.remove(gauge);\n        // add and fail loud if zero address or already present and not deprecated\n        if (gauge == address(0) || !(newAdd || previouslyDeprecated)) revert InvalidGauge();\n\n        emit AddGauge(gauge);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function removeGauge(address gauge) external onlyOwner {\n        _removeGauge(gauge);\n    }\n\n    function _removeGauge(address gauge) internal {\n        // add to deprecated and fail loud if not present\n        if (!_deprecatedGauges.add(gauge)) revert InvalidGauge();\n\n        emit RemoveGauge(gauge);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function replaceGauge(address oldGauge, address newGauge) external onlyOwner {\n        _removeGauge(oldGauge);\n        _addGauge(newGauge);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// NOTE: any \"removal\" of tokens from a user requires notAttached < amount.\n\n    /**\n     * @notice Burns `amount` of tokens from `from` address.\n     * @dev User must have enough free boost.\n     * @param from The address to burn tokens from.\n     * @param amount The amount of tokens to burn.\n     */\n    function _burn(address from, uint256 amount) internal override notAttached(from, amount) {\n        super._burn(from, amount);\n    }\n\n    /**\n     * @notice Transfers `amount` of tokens from `msg.sender` to `to` address.\n     * @dev User must have enough free boost.\n     * @param to the address to transfer to.\n     * @param amount the amount to transfer.\n     */\n    function transfer(address to, uint256 amount) public override notAttached(msg.sender, amount) returns (bool) {\n        return super.transfer(to, amount);\n    }\n\n    /**\n     * @notice Transfers `amount` of tokens from `from` address to `to` address.\n     * @dev User must have enough free boost.\n     * @param from the address to transfer from.\n     * @param to the address to transfer to.\n     * @param amount the amount to transfer.\n     */\n    function transferFrom(address from, address to, uint256 amount)\n        public\n        override\n        notAttached(from, amount)\n        returns (bool)\n    {\n        return super.transferFrom(from, to, amount);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Reverts if the user does not have enough free boost.\n     * @param user The user address.\n     * @param amount The amount of boost.\n     */\n    modifier notAttached(address user, uint256 amount) {\n        if (freeGaugeBoost(user) < amount) revert AttachedBoost();\n        _;\n    }\n}"
    },
    {
      "filename": "src/erc-20/ERC20Boost.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {EnumerableSet} from \"@lib/EnumerableSet.sol\";\n\nimport {IBaseV2Gauge} from \"@gauges/interfaces/IBaseV2Gauge.sol\";\n\nimport {Errors} from \"./interfaces/Errors.sol\";\nimport {IERC20Boost} from \"./interfaces/IERC20Boost.sol\";\n\n/// @title An ERC20 with an embedded attachment mechanism to keep track of boost\n///        allocations to gauges.\nabstract contract ERC20Boost is ERC20, Ownable, IERC20Boost {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using SafeCastLib for *;\n\n    /*///////////////////////////////////////////////////////////////\n                            GAUGE STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Boost\n    mapping(address => mapping(address => GaugeState)) public override getUserGaugeBoost;\n\n    /// @inheritdoc IERC20Boost\n    mapping(address => uint256) public override getUserBoost;\n\n    mapping(address => EnumerableSet.AddressSet) internal _userGauges;\n\n    EnumerableSet.AddressSet internal _gauges;\n\n    // Store deprecated gauges in case a user needs to free dead boost\n    EnumerableSet.AddressSet internal _deprecatedGauges;\n\n    /*///////////////////////////////////////////////////////////////\n                            VIEW HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Boost\n    function gauges() external view returns (address[] memory) {\n        return _gauges.values();\n    }\n\n    /// @inheritdoc IERC20Boost\n    function gauges(uint256 offset, uint256 num) external view returns (address[] memory values) {\n        values = new address[](num);\n        for (uint256 i = 0; i < num;) {\n            unchecked {\n                values[i] = _gauges.at(offset + i); // will revert if out of bounds\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC20Boost\n    function isGauge(address gauge) external view returns (bool) {\n        return _gauges.contains(gauge) && !_deprecatedGauges.contains(gauge);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function numGauges() external view returns (uint256) {\n        return _gauges.length();\n    }\n\n    /// @inheritdoc IERC20Boost\n    function deprecatedGauges() external view returns (address[] memory) {\n        return _deprecatedGauges.values();\n    }\n\n    /// @inheritdoc IERC20Boost\n    function numDeprecatedGauges() external view returns (uint256) {\n        return _deprecatedGauges.length();\n    }\n\n    /// @inheritdoc IERC20Boost\n    function freeGaugeBoost(address user) public view returns (uint256) {\n        return balanceOf[user] - getUserBoost[user];\n    }\n\n    /// @inheritdoc IERC20Boost\n    function userGauges(address user) external view returns (address[] memory) {\n        return _userGauges[user].values();\n    }\n\n    /// @inheritdoc IERC20Boost\n    function isUserGauge(address user, address gauge) external view returns (bool) {\n        return _userGauges[user].contains(gauge);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function userGauges(address user, uint256 offset, uint256 num) external view returns (address[] memory values) {\n        values = new address[](num);\n        for (uint256 i = 0; i < num;) {\n            unchecked {\n                values[i] = _userGauges[user].at(offset + i); // will revert if out of bounds\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC20Boost\n    function numUserGauges(address user) external view returns (uint256) {\n        return _userGauges[user].length();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        GAUGE OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Boost\n    function attach(address user) external {\n        if (!_gauges.contains(msg.sender) || _deprecatedGauges.contains(msg.sender)) {\n            revert InvalidGauge();\n        }\n\n        // idempotent add\n        if (!_userGauges[user].add(msg.sender)) revert GaugeAlreadyAttached();\n\n        uint128 userGaugeBoost = balanceOf[user].toUint128();\n\n        if (getUserBoost[user] < userGaugeBoost) {\n            getUserBoost[user] = userGaugeBoost;\n            emit UpdateUserBoost(user, userGaugeBoost);\n        }\n\n        getUserGaugeBoost[user][msg.sender] =\n            GaugeState({userGaugeBoost: userGaugeBoost, totalGaugeBoost: totalSupply.toUint128()});\n\n        emit Attach(user, msg.sender, userGaugeBoost);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function detach(address user) external {\n        require(_userGauges[user].remove(msg.sender));\n        delete getUserGaugeBoost[user][msg.sender];\n\n        emit Detach(user, msg.sender);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        USER GAUGE OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Boost\n    function updateUserBoost(address user) external {\n        uint256 userBoost = 0;\n\n        address[] memory gaugeList = _userGauges[user].values();\n\n        uint256 length = gaugeList.length;\n        for (uint256 i = 0; i < length;) {\n            address gauge = gaugeList[i];\n\n            if (!_deprecatedGauges.contains(gauge)) {\n                uint256 gaugeBoost = getUserGaugeBoost[user][gauge].userGaugeBoost;\n\n                if (userBoost < gaugeBoost) userBoost = gaugeBoost;\n            }\n\n            unchecked {\n                i++;\n            }\n        }\n        getUserBoost[user] = userBoost;\n\n        emit UpdateUserBoost(user, userBoost);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function decrementGaugeBoost(address gauge, uint256 boost) public {\n        GaugeState storage gaugeState = getUserGaugeBoost[msg.sender][gauge];\n        if (boost >= gaugeState.userGaugeBoost) {\n            _userGauges[msg.sender].remove(gauge);\n            delete getUserGaugeBoost[msg.sender][gauge];\n\n            emit Detach(msg.sender, gauge);\n        } else {\n            gaugeState.userGaugeBoost -= boost.toUint128();\n\n            emit DecrementUserGaugeBoost(msg.sender, gauge, gaugeState.userGaugeBoost);\n        }\n    }\n\n    /// @inheritdoc IERC20Boost\n    function decrementGaugeAllBoost(address gauge) external {\n        require(_userGauges[msg.sender].remove(gauge));\n        delete getUserGaugeBoost[msg.sender][gauge];\n\n        emit Detach(msg.sender, gauge);\n    }\n\n    /// @inheritdoc IERC20Boost\n    function decrementAllGaugesBoost(uint256 boost) external {\n        decrementGaugesBoostIndexed(boost, 0, _userGauges[msg.sender].length());\n    }\n\n    /// @inheritdoc IERC20Boost\n    function decrementGaugesBoostIndexed(uint256 boost, uint256 offset, uint256 num) public {\n        address[] memory gaugeList = _userGauges[msg.sender].values();\n\n        uint256 length = gaugeList.length;\n        for (uint256 i = 0; i < num && i < length;) {\n            address gauge = gaugeList[offset + i];\n\n            GaugeState storage gaugeState = getUserGaugeBoost[msg.sender][gauge];\n\n            if (_deprecatedGauges.contains(gauge) || boost >= gaugeState.userGaugeBoost) {\n                require(_userGauges[msg.sender].remove(gauge)); // Remove from set. Should never fail.\n                delete getUserGaugeBoost[msg.sender][gauge];\n\n                emit Detach(msg.sender, gauge);\n            } else {\n                gaugeState.userGaugeBoost -= boost.toUint128();\n\n                emit DecrementUserGaugeBoost(msg.sender, gauge, gaugeState.userGaugeBoost);\n            }\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC20Boost\n    function decrementAllGaugesAllBoost() external {\n        // Loop through all user gauges, live and deprecated\n        address[] memory gaugeList = _userGauges[msg.sender].values();\n\n        // Free gauges until through the entire list\n        uint256 size = gaugeList.length;\n        for (uint256 i = 0; i < size;) {\n            address gauge = gaugeList[i];\n\n            require(_userGauges[msg.sender].remove(gauge)); // Remove from set. Should never fail.\n            delete getUserGaugeBoost[msg.sender][gauge];\n\n            emit Detach(msg.sender, gauge);\n\n            unchecked {\n                i++;\n            }\n        }\n\n        getUserBoost[msg.sender] = 0;\n\n        emit UpdateUserBoost(msg.sender, 0);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        ADMIN GAUGE OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Boost\n    function addGauge(address gauge) external onlyOwner {\n        _addGauge(gauge);\n    }\n\n    function _addGauge(address gauge) internal {\n        bool newAdd = _gauges.add(gauge);\n        bool previouslyDeprecated = _deprecatedGauges.remove(gauge);\n        // add and fail loud if zero address or already present and not deprecated\n        if (gauge == address(0) || !(newAdd || previouslyDepre"
    }
  ]
}