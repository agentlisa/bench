{
  "Title": "M-5: There is no limit on the amount of fee users have to pay",
  "Content": "# Issue M-5: There is no limit on the amount of fee users have to pay \n\nSource: https://github.com/sherlock-audit/2022-09-harpie-judging/tree/main/008-M \n\n## Found by \nhickuphh3, 0xSmartContract, xiaoming90, ak1, minhquanym, leastwood, defsec, HonorLt\n\n## Summary\n\nhttps://github.com/Harpieio/contracts/blob/97083d7ce8ae9d85e29a139b1e981464ff92b89e/contracts/Transfer.sol#L57\nhttps://github.com/Harpieio/contracts/blob/97083d7ce8ae9d85e29a139b1e981464ff92b89e/contracts/Transfer.sol#L88\n\n## Vulnerability Detail\n\nThere is no upper limit on the amount of fee users have to pay to withdraw their funds back. So any EOA can call transfer function on `Transfer` contract can set an unreasonable amount of fee and users have to pay it if they want their funds back. We need to make sure that users' funds cannot be loss even when the protocol acts maliciously. \n\n## Impact\n\nIn case the protocol acts maliciously and set `fee = 1e18` to transfer users' fund to `Vault`, users cannot withdraw their funds since fee is too high.\n\n## Proof of Concept\n\nIn both `transferERC20()` and `transferERC721()`, EOA is caller and can set `fee` param to any value it wants. \n```solidity\nfunction transferERC721(address _ownerAddress, address _erc721Address, uint256 _erc721Id, uint128 _fee) public returns (bool) {\n      require(_transferEOAs[msg.sender] == true || msg.sender == address(this), \"Caller must be an approved caller.\");\n      require(_erc721Address != address(this));\n      (bool transferSuccess, bytes memory transferResult) = address(_erc721Address).call(\n          abi.encodeCall(IERC721(_erc721Address).transferFrom, (_ownerAddress, vaultAddress, _erc721Id))\n      );\n      require(transferSuccess, string (transferResult));\n      (bool loggingSuccess, bytes memory loggingResult) = address(vaultAddress).call(\n          abi.encodeCall(Vault.logIncomingERC721, (_ownerAddress, _erc721Address, _erc721Id, _fee))\n      );\n      require(loggingSuccess, string (loggingResult));\n      emit successfulERC721Transfer(_ownerAddress, _erc721Address, _erc721Id);\n      return transferSuccess;\n  }\n```\n\nAnd users need to send enough fee (native token) to withdraw their fund back on `Vault`\n```solidity\nfunction withdrawERC721(address _originalAddress, address _erc721Address, uint256 _id) payable external {\n      require(_recipientAddress[_originalAddress] == msg.sender, \"Function caller is not an authorized recipientAddress.\");\n      require(_erc721Address != address(this), \"The vault is not a token address\");\n      require(canWithdrawERC721(_originalAddress, _erc721Address, _id), \"Insufficient withdrawal allowance.\");\n      require(msg.value >= _erc721WithdrawalAllowances[_originalAddress][_erc721Address][_id].fee, \"Insufficient payment.\");\n\n      _erc721WithdrawalAllowances[_originalAddress][_erc721Address][_id].isStored = false;\n      _erc721WithdrawalAllowances[_originalAddress][_erc721Address][_id].fee = 0;\n      IERC721(_erc721Address).transferFrom(address(this), msg.sender, _id);\n}\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider adding an upper limit on the amount of fee users need to pay\n\n## Lead Senior Watson\n\nCurrently there is no way to revoke a change fee controller request. I'd shy away from using a mapping, adds unnecessary overhead when it can be handled by a `pendingFeeController` variable. Also important to note that mapping in `changeFeeController()` is not cleared.\n\n## Harpie Team\n\nUsing leastwood's suggestion of a timelock for feeController. Fix [here](https://github.com/Harpieio/contracts/pull/4/commits/9b75a000f6cb0798e650f1433012b2b52f7a0e2b). Supplementary fixes for this issue: \n[1](https://github.com/Harpieio/contracts/pull/4/commits/c60dc166aab6f7067379ea3f1e39be2ae17cc2dc), \n[2](https://github.com/Harpieio/contracts/pull/4/commits/ea97548c379ec9b48e42724a52a1ee7bd4cce6b7), \n[3](https://github.com/Harpieio/contracts/pull/4/commits/8cfc07577c49eb0b0713fb5499ea9313153c2c7c). \n\n## Lead Senior Watson\n\nConfirmed fixes. \n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/3",
  "Code": [
    {
      "filename": "contracts/Transfer.sol",
      "content": "// contracts/delegator.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./Vault.sol\";\n\n/// @notice This contract is designed to move ERC20s and ERC721s from user wallets into the noncustodial Vault contract.\n/// After receiving user Approval, it uses server-side EOAs to call below functions when we detect malicious transactions.\ncontract Transfer {\n    /// @dev We use safeERC20 to work with noncompliant ERC20s\n    using SafeERC20 for IERC20; \n\n    /// @dev ERC20Details and ERC721Details are used to define an individual\n    /// token, along with its owner. these are used in our batchTransfer functions\n    /// @param ownerAddress The owner of the token\n    /// @param fee The fee we charge users as they recover their assets\n    struct ERC20Details {\n        address ownerAddress;\n        address erc20Address;\n        uint128 erc20Fee;\n    }\n    struct ERC721Details {\n        address ownerAddress;\n        address erc721Address;\n        uint128 erc721Fee;\n        uint256 erc721Id;\n    }\n\n    /// @notice We've hardcoded the address that this contract transfers tokens to,\n    /// so your Approved tokens can only move to our noncustodial vault\n    /// @dev vaultAddress is the address of our noncustodial Vault contract\n    address immutable private vaultAddress;\n\n    /// @dev transferEOASetter is an EOA that can set other EOAs as callers of the\n    /// Transfer functions below\n    address immutable private transferEOASetter;\n\n    /// @dev a mapping of all possible EOAs that can call Transfer functions\n    mapping(address => bool) private _transferEOAs;\n\n    /// @dev Immutables are set upon contract construction for safety\n    constructor(address _vaultAddress, address _transferEOASetter) {\n        vaultAddress = _vaultAddress;\n        transferEOASetter = _transferEOASetter;\n    } \n\n    /// @dev These events fire when a token transfer and subsequent logging is successful\n    event successfulERC721Transfer(address ownerAddress, address erc721Address, uint256 tokenId);\n    event successfulERC20Transfer(address ownerAddress, address erc20Address);\n\n    /// @dev These events fire when an individual Transfer in a batchTransfer fails\n    event failedERC721Transfer(address ownerAddress, address erc721Address, uint256 tokenId);\n    event failedERC20Transfer(address ownerAddress, address erc20Address);\n \n    /// @notice This function transfers ERC721s to a noncustodial vault contract.\n    function transferERC721(address _ownerAddress, address _erc721Address, uint256 _erc721Id, uint128 _fee) public returns (bool) {\n        require(_transferEOAs[msg.sender] == true || msg.sender == address(this), \"Caller must be an approved caller.\");\n        require(_erc721Address != address(this));\n        (bool transferSuccess, bytes memory transferResult) = address(_erc721Address).call(\n            abi.encodeCall(IERC721(_erc721Address).transferFrom, (_ownerAddress, vaultAddress, _erc721Id))\n        );\n        require(transferSuccess, string (transferResult));\n        (bool loggingSuccess, bytes memory loggingResult) = address(vaultAddress).call(\n            abi.encodeCall(Vault.logIncomingERC721, (_ownerAddress, _erc721Address, _erc721Id, _fee))\n        );\n        require(loggingSuccess, string (loggingResult));\n        emit successfulERC721Transfer(_ownerAddress, _erc721Address, _erc721Id);\n        return transferSuccess;\n    }\n\n    /// @notice Batch transfering ERC721s in case we need to handle a large set of addresses at once (ie. protocol attack)\n    /// @dev Care must be taken to pass good data, this function does not revert when a single transaction throws \n    function batchTransferERC721(ERC721Details[] memory _details) public returns (bool) {\n        require(_transferEOAs[msg.sender] == true, \"Caller must be an approved caller.\");\n        for (uint256 i=0; i<_details.length; i++ ) {\n            // If statement adds a bit more gas cost, but allows us to continue the loop even if a\n            // token is not in a user's wallet anymore, instead of reverting the whole batch\n            try this.transferERC721{gas:400e3}(_details[i].ownerAddress, _details[i].erc721Address, _details[i].erc721Id, _details[i].erc721Fee) {}\n            catch {\n                emit failedERC721Transfer(_details[i].ownerAddress, _details[i].erc721Address, _details[i].erc721Id);\n            }\n        }\n        return true;\n    }\n\n    /// @notice This function transfers ERC20s to a noncustodial vault contract.\n    function transferERC20(address _ownerAddress, address _erc20Address, uint128 _fee) public returns (bool) {\n        require (_transferEOAs[msg.sender] == true || msg.sender == address(this), \"Caller must be an approved caller.\");\n        require(_erc20Address != address(this));\n        // Do the functions after the following line occur if the following line fails? Does it revert? Test\n        uint256 balance = IERC20(_erc20Address).balanceOf(_ownerAddress);\n        IERC20(_erc20Address).safeTransferFrom(\n            _ownerAddress, \n            vaultAddress, \n            balance\n        );\n        (bool loggingSuccess, bytes memory loggingResult) = address(vaultAddress).call(\n            abi.encodeCall(Vault.logIncomingERC20, (_ownerAddress, _erc20Address, balance, _fee))\n        );\n        require(loggingSuccess, string (loggingResult));\n        emit successfulERC20Transfer(_ownerAddress, _erc20Address);\n        return loggingSuccess;\n    }\n\n    /// @notice Batch transfering ERC20s in case we need to handle a large set of addresses at once (ie. protocol attack)\n    /// @dev Care must be taken to pass good data, this function does not revert when a single transaction throws\n    function batchTransferERC20(ERC20Details[] memory _details) public returns (bool) {\n        require(_transferEOAs[msg.sender] == true, \"Caller must be an approved caller.\");\n        for (uint256 i=0; i<_details.length; i++ ) {\n            try this.transferERC20{gas:400e3}(_details[i].ownerAddress, _details[i].erc20Address, _details[i].erc20Fee) {}\n            catch {\n                emit failedERC20Transfer(_details[i].ownerAddress, _details[i].erc20Address);\n            }\n        }\n        return true;\n    }\n\n    /// @dev This adds or removes transferEOAs that can call the above functions\n    function setTransferEOA(address _newTransferEOA, bool _value) public {\n        require(msg.sender == transferEOASetter, \"Caller must be an approved caller.\");\n        _transferEOAs[_newTransferEOA] = _value;\n    }\n}"
    },
    {
      "filename": "contracts/Transfer.sol",
      "content": "// contracts/delegator.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./Vault.sol\";\n\n/// @notice This contract is designed to move ERC20s and ERC721s from user wallets into the noncustodial Vault contract.\n/// After receiving user Approval, it uses server-side EOAs to call below functions when we detect malicious transactions.\ncontract Transfer {\n    /// @dev We use safeERC20 to work with noncompliant ERC20s\n    using SafeERC20 for IERC20; \n\n    /// @dev ERC20Details and ERC721Details are used to define an individual\n    /// token, along with its owner. these are used in our batchTransfer functions\n    /// @param ownerAddress The owner of the token\n    /// @param fee The fee we charge users as they recover their assets\n    struct ERC20Details {\n        address ownerAddress;\n        address erc20Address;\n        uint128 erc20Fee;\n    }\n    struct ERC721Details {\n        address ownerAddress;\n        address erc721Address;\n        uint128 erc721Fee;\n        uint256 erc721Id;\n    }\n\n    /// @notice We've hardcoded the address that this contract transfers tokens to,\n    /// so your Approved tokens can only move to our noncustodial vault\n    /// @dev vaultAddress is the address of our noncustodial Vault contract\n    address immutable private vaultAddress;\n\n    /// @dev transferEOASetter is an EOA that can set other EOAs as callers of the\n    /// Transfer functions below\n    address immutable private transferEOASetter;\n\n    /// @dev a mapping of all possible EOAs that can call Transfer functions\n    mapping(address => bool) private _transferEOAs;\n\n    /// @dev Immutables are set upon contract construction for safety\n    constructor(address _vaultAddress, address _transferEOASetter) {\n        vaultAddress = _vaultAddress;\n        transferEOASetter = _transferEOASetter;\n    } \n\n    /// @dev These events fire when a token transfer and subsequent logging is successful\n    event successfulERC721Transfer(address ownerAddress, address erc721Address, uint256 tokenId);\n    event successfulERC20Transfer(address ownerAddress, address erc20Address);\n\n    /// @dev These events fire when an individual Transfer in a batchTransfer fails\n    event failedERC721Transfer(address ownerAddress, address erc721Address, uint256 tokenId);\n    event failedERC20Transfer(address ownerAddress, address erc20Address);\n \n    /// @notice This function transfers ERC721s to a noncustodial vault contract.\n    function transferERC721(address _ownerAddress, address _erc721Address, uint256 _erc721Id, uint128 _fee) public returns (bool) {\n        require(_transferEOAs[msg.sender] == true || msg.sender == address(this), \"Caller must be an approved caller.\");\n        require(_erc721Address != address(this));\n        (bool transferSuccess, bytes memory transferResult) = address(_erc721Address).call(\n            abi.encodeCall(IERC721(_erc721Address).transferFrom, (_ownerAddress, vaultAddress, _erc721Id))\n        );\n        require(transferSuccess, string (transferResult));\n        (bool loggingSuccess, bytes memory loggingResult) = address(vaultAddress).call(\n            abi.encodeCall(Vault.logIncomingERC721, (_ownerAddress, _erc721Address, _erc721Id, _fee))\n        );\n        require(loggingSuccess, string (loggingResult));\n        emit successfulERC721Transfer(_ownerAddress, _erc721Address, _erc721Id);\n        return transferSuccess;\n    }\n\n    /// @notice Batch transfering ERC721s in case we need to handle a large set of addresses at once (ie. protocol attack)\n    /// @dev Care must be taken to pass good data, this function does not revert when a single transaction throws \n    function batchTransferERC721(ERC721Details[] memory _details) public returns (bool) {\n        require(_transferEOAs[msg.sender] == true, \"Caller must be an approved caller.\");\n        for (uint256 i=0; i<_details.length; i++ ) {\n            // If statement adds a bit more gas cost, but allows us to continue the loop even if a\n            // token is not in a user's wallet anymore, instead of reverting the whole batch\n            try this.transferERC721{gas:400e3}(_details[i].ownerAddress, _details[i].erc721Address, _details[i].erc721Id, _details[i].erc721Fee) {}\n            catch {\n                emit failedERC721Transfer(_details[i].ownerAddress, _details[i].erc721Address, _details[i].erc721Id);\n            }\n        }\n        return true;\n    }\n\n    /// @notice This function transfers ERC20s to a noncustodial vault contract.\n    function transferERC20(address _ownerAddress, address _erc20Address, uint128 _fee) public returns (bool) {\n        require (_transferEOAs[msg.sender] == true || msg.sender == address(this), \"Caller must be an approved caller.\");\n        require(_erc20Address != address(this));\n        // Do the functions after the following line occur if the following line fails? Does it revert? Test\n        uint256 balance = IERC20(_erc20Address).balanceOf(_ownerAddress);\n        IERC20(_erc20Address).safeTransferFrom(\n            _ownerAddress, \n            vaultAddress, \n            balance\n        );\n        (bool loggingSuccess, bytes memory loggingResult) = address(vaultAddress).call(\n            abi.encodeCall(Vault.logIncomingERC20, (_ownerAddress, _erc20Address, balance, _fee))\n        );\n        require(loggingSuccess, string (loggingResult));\n        emit successfulERC20Transfer(_ownerAddress, _erc20Address);\n        return loggingSuccess;\n    }\n\n    /// @notice Batch transfering ERC20s in case we need to handle a large set of addresses at once (ie. protocol attack)\n    /// @dev Care must be taken to pass good data, this function does not revert when a single transaction throws\n    function batchTransferERC20(ERC20Details[] memory _details) public returns (bool) {\n        require(_transferEOAs[msg.sender] == true, \"Caller must be an approved caller.\");\n        for (uint256 i=0; i<_details.length; i++ ) {\n            try this.transferERC20{gas:400e3}(_details[i].ownerAddress, _details[i].erc20Address, _details[i].erc20Fee) {}\n            catch {\n                emit failedERC20Transfer(_details[i].ownerAddress, _details[i].erc20Address);\n            }\n        }\n        return true;\n    }\n\n    /// @dev This adds or removes transferEOAs that can call the above functions\n    function setTransferEOA(address _newTransferEOA, bool _value) public {\n        require(msg.sender == transferEOASetter, \"Caller must be an approved caller.\");\n        _transferEOAs[_newTransferEOA] = _value;\n    }\n}"
    }
  ]
}