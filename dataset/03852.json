{
  "Title": "Potential integer overflow",
  "Content": "##### Description\nAt the line https://github.com/bondappetit/bondappetit-protocol/blob/355180f0aca0b29d60d808f761052956b7a3a159/contracts/Investment.sol#L147 contract potentially can catch integer overflow in case if `cumulative.decimals() > 18`. Since `cumulative` token is not predefined contract we should check actual decimals amount\n\n##### Recommendation\nWe recommend add check\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/Investment.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./utils/OwnablePausable.sol\";\nimport \"./uniswap/IUniswapV2Router02.sol\";\nimport \"./GovernanceToken.sol\";\n\ncontract Investment is OwnablePausable {\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n\n    ///@notice Address of cumulative token\n    ERC20 public cumulative;\n\n    ///@notice Address of governance token\n    GovernanceToken public governanceToken;\n\n    ///@notice Date of locking governance token\n    uint256 public governanceTokenLockDate;\n\n    uint8 internal constant GOVERNANCE_TOKEN_PRICE_DECIMALS = 6;\n\n    ///@notice Price governance token\n    uint256 public governanceTokenPrice = 1000000;\n\n    ///@dev Address of UniswapV2Router\n    IUniswapV2Router02 internal uniswapRouter;\n\n    ///@notice Investment tokens list\n    mapping(address => bool) public investmentTokens;\n\n    /// @notice An event thats emitted when an uniswap router contract address changed.\n    event UniswapRouterChanged(address newUniswapRouter);\n\n    /// @notice An event thats emitted when an invest token allowed.\n    event InvestTokenAllowed(address token);\n\n    /// @notice An event thats emitted when an invest token denied.\n    event InvestTokenDenied(address token);\n\n    /// @notice An event thats emitted when an governance token price changed.\n    event GovernanceTokenPriceChanged(uint256 newPrice);\n\n    /// @notice An event thats emitted when an invested token.\n    event Invested(address investor, address token, uint256 amount, uint256 reward);\n\n    /// @notice An event thats emitted when an withdrawal token.\n    event Withdrawal(address recipient, address token, uint256 amount);\n\n    /**\n     * @param _cumulative Address of cumulative token\n     * @param _governanceToken Address of governance token\n     * @param _uniswapRouter Address of UniswapV2Router\n     */\n    constructor(\n        address _cumulative,\n        address _governanceToken,\n        uint256 _governanceTokenLockDate,\n        address _uniswapRouter\n    ) public {\n        cumulative = ERC20(_cumulative);\n        governanceToken = GovernanceToken(_governanceToken);\n        governanceTokenLockDate = _governanceTokenLockDate;\n        uniswapRouter = IUniswapV2Router02(_uniswapRouter);\n    }\n\n    /**\n     * @notice Changed uniswap router contract address.\n     * @param _uniswapRouter Address new uniswap router contract.\n     */\n    function changeUniswapRouter(address _uniswapRouter) external onlyOwner {\n        uniswapRouter = IUniswapV2Router02(_uniswapRouter);\n        emit UniswapRouterChanged(_uniswapRouter);\n    }\n\n    /**\n     * @notice Add token to investable tokens white list\n     * @param token Allowable token\n     */\n    function allowToken(address token) external onlyOwner {\n        investmentTokens[token] = true;\n        emit InvestTokenAllowed(token);\n    }\n\n    /**\n     * @notice Remove token from investable tokens white list\n     * @param token Denied token\n     */\n    function denyToken(address token) external onlyOwner {\n        investmentTokens[token] = false;\n        emit InvestTokenDenied(token);\n    }\n\n    /**\n     * @notice Update governance token price\n     * @param newPrice New price of governance token of USD (6 decimal)\n     */\n    function changeGovernanceTokenPrice(uint256 newPrice) external onlyOwner {\n        require(newPrice > 0, \"Investment::changeGovernanceTokenPrice: invalid new governance token price\");\n\n        governanceTokenPrice = newPrice;\n        emit GovernanceTokenPriceChanged(newPrice);\n    }\n\n    /**\n     * @param token Invested token\n     * @return Pools for each consecutive pair of addresses must exist and have liquidity\n     */\n    function _path(address token) internal view returns (address[] memory) {\n        address weth = uniswapRouter.WETH();\n        if (weth == token) {\n            address[] memory path = new address[](2);\n            path[0] = token;\n            path[1] = address(cumulative);\n            return path;\n        }\n\n        address[] memory path = new address[](3);\n        path[0] = token;\n        path[1] = weth;\n        path[2] = address(cumulative);\n        return path;\n    }\n\n    /**\n     * @param token Invested token\n     * @param amount Invested amount\n     * @return Amount cumulative token after swap\n     */\n    function _amountOut(address token, uint256 amount) internal view returns (uint256) {\n        uint256[] memory amountsOut = uniswapRouter.getAmountsOut(amount, _path(token));\n        require(amountsOut.length != 0, \"Investment::_amountOut: invalid amounts out length\");\n\n        return amountsOut[amountsOut.length - 1];\n    }\n\n    /**\n     * @param amount Cumulative amount invested\n     * @return Amount governance token after swap\n     */\n    function _governanceTokenPrice(uint256 amount) internal view returns (uint256) {\n        uint256 decimals = cumulative.decimals();\n\n        return amount.mul(10**(18 - decimals + GOVERNANCE_TOKEN_PRICE_DECIMALS)).div(governanceTokenPrice);\n    }\n\n    /**\n     * @param token Invested token\n     * @param amount Invested amount\n     * @return Amount governance token after swap\n     */\n    function price(address token, uint256 amount) external view returns (uint256) {\n        require(investmentTokens[token], \"Investment::price: invalid investable token\");\n\n        uint256 amountOut = amount;\n        if (token != address(cumulative)) {\n            amountOut = _amountOut(token, amount);\n        }\n\n        return _governanceTokenPrice(amountOut);\n    }\n\n    /**\n     * @notice Invest tokens to protocol\n     * @param token Invested token\n     * @param amount Invested amount\n     */\n    function invest(address token, uint256 amount) external whenNotPaused returns (bool) {\n        require(investmentTokens[token], \"Investment::invest: invalid investable token\");\n        uint256 reward = _governanceTokenPrice(amount);\n\n        ERC20(token).safeTransferFrom(_msgSender(), address(this), amount);\n\n        if (token != address(cumulative)) {\n            uint256 amountOut = _amountOut(token, amount);\n            require(amountOut != 0, \"Investment::invest: liquidity pool is empty\");\n            reward = _governanceTokenPrice(amountOut);\n\n            ERC20(token).safeApprove(address(uniswapRouter), amount);\n            uniswapRouter.swapExactTokensForTokens(amount, amountOut, _path(token), address(this), block.timestamp);\n        }\n\n        governanceToken.transferLock(_msgSender(), reward, governanceTokenLockDate);\n\n        emit Invested(_msgSender(), token, amount, reward);\n        return true;\n    }\n\n    /**\n     * @notice Invest ETH to protocol\n     */\n    function investETH() external payable whenNotPaused returns (bool) {\n        address token = uniswapRouter.WETH();\n        require(investmentTokens[token], \"Investment::investETH: invalid investable token\");\n        uint256 reward = _governanceTokenPrice(msg.value);\n\n        if (token != address(cumulative)) {\n            uint256 amountOut = _amountOut(token, msg.value);\n            require(amountOut != 0, \"Investment::invest: liquidity pool is empty\");\n            reward = _governanceTokenPrice(amountOut);\n\n            uniswapRouter.swapExactETHForTokens{value: msg.value}(amountOut, _path(token), address(this), block.timestamp);\n        }\n\n        governanceToken.transferLock(_msgSender(), reward, governanceTokenLockDate);\n\n        emit Invested(_msgSender(), token, msg.value, reward);\n        return true;\n    }\n\n    /**\n     * @notice Withdraw invested token to address\n     * @param recipient Recipient of tokens\n     */\n    function withdraw(address recipient) external onlyOwner {\n        require(recipient != address(0), \"Investment::withdraw: cannot transfer to the zero address\");\n\n        uint256 balance = cumulative.balanceOf(address(this));\n        cumulative.safeTransfer(recipient, balance);\n\n        emit Withdrawal(recipient, address(cumulative), balance);\n    }\n}"
    }
  ]
}