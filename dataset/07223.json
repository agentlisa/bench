{
  "Title": "[M-08] Asset.lotPrice() doesnâ€™t use the most recent price in case of oracle timeout",
  "Content": "# Lines of code\n\nhttps://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/plugins/assets/Asset.sol#L144-L145\n\n\n# Vulnerability details\n\n## Impact\n\n`Asset.lotPrice()` has a fallback mechanism in case that `tryPrice()` fails - it uses the last saved price and multiplies its value by `lotMultiplier` (a variable that decreases as the time since the last saved price increase) and returns the results.\nHowever, the `tryPrice()` might fail due to oracle timeout, in that case the last saved price might be older than the oracle's price.\n\nThis can cause the backing manager to misestimate the value of the asset, trade it at a lower price, or do an unnecessary haircut.\n\n## Proof of Concept\nIn the PoC below:\n* Oracle price is set at day 0\n* The asset is refreshed (e.g. somebody issued/vested/redeemed)\n* After 5 days the oracle gets an update\n* 25 hours later the `lotPrice()` is calculated based on the oracle price from day 0 even though a price from day 5 is available from the oracle\n* Oracle gets another update\n* 25 hours later the `lotPrice()` goes down to zero since it considers the price from day 0 (which is more than a week ago) to be the last saved price, even though a price from a day ago is available from the oracle\n\n```diff\ndiff --git a/test/fixtures.ts b/test/fixtures.ts\nindex 5299a5f6..75ca8010 100644\n--- a/test/fixtures.ts\n+++ b/test/fixtures.ts\n@@ -69,7 +69,7 @@ export const SLOW = !!useEnv('SLOW')\n \n export const PRICE_TIMEOUT = bn('604800') // 1 week\n \n-export const ORACLE_TIMEOUT = bn('281474976710655').div(2) // type(uint48).max / 2\n+export const ORACLE_TIMEOUT = bn('86400') // one day\n \n export const ORACLE_ERROR = fp('0.01') // 1% oracle error\n \ndiff --git a/test/plugins/Asset.test.ts b/test/plugins/Asset.test.ts\nindex d49c53f3..7f2f721e 100644\n--- a/test/plugins/Asset.test.ts\n+++ b/test/plugins/Asset.test.ts\n@@ -233,6 +233,45 @@ describe('Assets contracts #fast', () => {\n       )\n     })\n \n+    it('PoC lot price doesn\\'t use most recent price', async () => {\n+      // Update values in Oracles to 0\n+\n+      await setOraclePrice(rsrAsset.address, bn('1.1e8'))\n+\n+      await rsrAsset.refresh();\n+      let [lotLow, lotHigh] = await rsrAsset.lotPrice();\n+      let descripion = \"day 0\";\n+      console.log({descripion, lotLow, lotHigh});\n+      let hour = 60*60;\n+      let day = hour*24;\n+      await advanceTime(day * 5);\n+\n+      await setOraclePrice(rsrAsset.address, bn('2e8'));\n+      // await rsrAsset.refresh();\n+\n+      [lotLow, lotHigh] = await rsrAsset.lotPrice();\n+      descripion = 'after 5 days (right after update)';\n+      console.log({descripion,lotLow, lotHigh});\n+\n+      await advanceTime(day + hour);\n+\n+      // Fallback prices should be zero\n+\n+      [lotLow, lotHigh] = await rsrAsset.lotPrice();\n+      descripion = 'after 6+ days';\n+      console.log({descripion, lotLow, lotHigh});\n+\n+      await setOraclePrice(rsrAsset.address, bn('2e8'));\n+\n+      await advanceTime(day + hour);\n+\n+      [lotLow, lotHigh] = await rsrAsset.lotPrice();\n+      descripion = 'after 7+ days';\n+      console.log({descripion, lotLow, lotHigh});\n+\n+    })\n+    return;\n+\n     it('Should return (0, 0) if price is zero', async () => {\n       // Update values in Oracles to 0\n       await setOraclePrice(compAsset.address, bn('0'))\n@@ -595,6 +634,7 @@ describe('Assets contracts #fast', () => {\n       expect(lotHighPrice4).to.be.equal(bn(0))\n     })\n   })\n+  return;\n \n   describe('Constructor validation', () => {\n     it('Should not allow price timeout to be zero', async () => {\n\n```\n\nOutput:\n```\n{\n  descripion: 'day 0',\n  lotLow: BigNumber { value: \"1089000000000000000\" },\n  lotHigh: BigNumber { value: \"1111000000000000000\" }\n}\n{\n  descripion: 'after 5 days (right after update)',\n  lotLow: BigNumber { value: \"1980000000000000000\" },\n  lotHigh: BigNumber { value: \"2020000000000000000\" }\n}\n{\n  descripion: 'after 6+ days',\n  lotLow: BigNumber { value: \"149087485119047618\" },\n  lotHigh: BigNumber { value: \"152099353505291005\" }\n}\n{\n  descripion: 'after 7+ days', // `lotPrice()` returns zero even though the most recent price the oracle holds is from 25 hours ago\n  lotLow: BigNumber { value: \"0\" },\n  lotHigh: BigNumber { value: \"0\" }\n}\n```\n\n## Recommended Mitigation Steps\nAllow specifying a timeout to `tryPrice()`, in case that `tryPrice()` fails due to oracle timeout then call it again with `priceTimeout` as the timeout.\nIf the call succeeds the second time then use it as the most recent price for fallback calculations. ",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-01-reserve-contest",
  "Code": [
    {
      "filename": "contracts/plugins/assets/Asset.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.9;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../../interfaces/IAsset.sol\";\nimport \"./OracleLib.sol\";\n\ncontract Asset is IAsset {\n    using FixLib for uint192;\n    using OracleLib for AggregatorV3Interface;\n\n    AggregatorV3Interface public immutable chainlinkFeed; // {UoA/tok}\n\n    IERC20Metadata public immutable erc20;\n\n    uint8 public immutable erc20Decimals;\n\n    uint192 public immutable override maxTradeVolume; // {UoA}\n\n    uint48 public immutable oracleTimeout; // {s} Seconds that an oracle value is considered valid\n\n    uint192 public immutable oracleError; // {1} The max % deviation allowed by the oracle\n\n    // === Lot price ===\n\n    uint48 public immutable priceTimeout; // {s} The period over which `savedHighPrice` decays to 0\n\n    uint192 public savedLowPrice; // {UoA/tok} The low price of the token during the last update\n\n    uint192 public savedHighPrice; // {UoA/tok} The high price of the token during the last update\n\n    uint48 public lastSave; // {s} The timestamp when prices were last saved\n\n    /// @param priceTimeout_ {s} The number of seconds over which savedHighPrice decays to 0\n    /// @param chainlinkFeed_ Feed units: {UoA/tok}\n    /// @param oracleError_ {1} The % the oracle feed can be off by\n    /// @param maxTradeVolume_ {UoA} The max trade volume, in UoA\n    /// @param oracleTimeout_ {s} The number of seconds until a oracle value becomes invalid\n    constructor(\n        uint48 priceTimeout_,\n        AggregatorV3Interface chainlinkFeed_,\n        uint192 oracleError_,\n        IERC20Metadata erc20_,\n        uint192 maxTradeVolume_,\n        uint48 oracleTimeout_\n    ) {\n        require(priceTimeout_ > 0, \"price timeout zero\");\n        require(address(chainlinkFeed_) != address(0), \"missing chainlink feed\");\n        require(oracleError_ > 0 && oracleError_ < FIX_ONE, \"oracle error out of range\");\n        require(address(erc20_) != address(0), \"missing erc20\");\n        require(maxTradeVolume_ > 0, \"invalid max trade volume\");\n        require(oracleTimeout_ > 0, \"oracleTimeout zero\");\n        priceTimeout = priceTimeout_;\n        chainlinkFeed = chainlinkFeed_;\n        oracleError = oracleError_;\n        erc20 = erc20_;\n        erc20Decimals = erc20.decimals();\n        maxTradeVolume = maxTradeVolume_;\n        oracleTimeout = oracleTimeout_;\n    }\n\n    /// Can revert, used by other contract functions in order to catch errors\n    /// Should not return FIX_MAX for low\n    /// Should only return FIX_MAX for high if low is 0\n    /// @dev The third (unused) variable is only here for compatibility with Collateral\n    /// @param low {UoA/tok} The low price estimate\n    /// @param high {UoA/tok} The high price estimate\n    function tryPrice()\n        external\n        view\n        virtual\n        returns (\n            uint192 low,\n            uint192 high,\n            uint192\n        )\n    {\n        uint192 p = chainlinkFeed.price(oracleTimeout); // {UoA/tok}\n        uint192 delta = p.mul(oracleError);\n        return (p - delta, p + delta, 0);\n    }\n\n    /// Should not revert\n    /// Refresh saved prices\n    function refresh() public virtual override {\n        try this.tryPrice() returns (uint192 low, uint192 high, uint192) {\n            // {UoA/tok}, {UoA/tok}\n            // (0, 0) is a valid price; (0, FIX_MAX) is unpriced\n\n            // Save prices if priced\n            if (high < FIX_MAX) {\n                savedLowPrice = low;\n                savedHighPrice = high;\n                lastSave = uint48(block.timestamp);\n            } else {\n                // must be unpriced\n                assert(low == 0);\n            }\n        } catch (bytes memory errData) {\n            // see: docs/solidity-style.md#Catching-Empty-Data\n            if (errData.length == 0) revert(); // solhint-disable-line reason-string\n        }\n    }\n\n    /// Should not revert\n    /// @dev Should be general enough to not need to be overridden\n    /// @return {UoA/tok} The lower end of the price estimate\n    /// @return {UoA/tok} The upper end of the price estimate\n    function price() public view virtual returns (uint192, uint192) {\n        try this.tryPrice() returns (uint192 low, uint192 high, uint192) {\n            assert(low <= high);\n            return (low, high);\n        } catch (bytes memory errData) {\n            // see: docs/solidity-style.md#Catching-Empty-Data\n            if (errData.length == 0) revert(); // solhint-disable-line reason-string\n            return (0, FIX_MAX);\n        }\n    }\n\n    /// Should not revert\n    /// lotLow should be nonzero when the asset might be worth selling\n    /// @dev Should be general enough to not need to be overridden\n    /// @return lotLow {UoA/tok} The lower end of the lot price estimate\n    /// @return lotHigh {UoA/tok} The upper end of the lot price estimate\n    function lotPrice() external view virtual returns (uint192 lotLow, uint192 lotHigh) {\n        try this.tryPrice() returns (uint192 low, uint192 high, uint192) {\n            // if the price feed is still functioning, use that\n            lotLow = low;\n            lotHigh = high;\n        } catch (bytes memory errData) {\n            // see: docs/solidity-style.md#Catching-Empty-Data\n            if (errData.length == 0) revert(); // solhint-disable-line reason-string\n\n            // if the price feed is broken, use a decayed historical value\n\n            uint48 delta = uint48(block.timestamp) - lastSave; // {s}\n            if (delta >= priceTimeout) return (0, 0); // no price after timeout elapses\n\n            // {1} = {s} / {s}\n            uint192 lotMultiplier = divuu(priceTimeout - delta, priceTimeout);\n\n            // {UoA/tok} = {UoA/tok} * {1}\n            lotLow = savedLowPrice.mul(lotMultiplier);\n            lotHigh = savedHighPrice.mul(lotMultiplier);\n        }\n        assert(lotLow <= lotHigh);\n    }\n\n    /// @return {tok} The balance of the ERC20 in whole tokens\n    function bal(address account) external view returns (uint192) {\n        return shiftl_toFix(erc20.balanceOf(account), -int8(erc20Decimals));\n    }\n\n    /// @return If the asset is an instance of ICollateral or not\n    function isCollateral() external pure virtual returns (bool) {\n        return false;\n    }\n\n    // solhint-disable no-empty-blocks\n\n    /// Claim rewards earned by holding a balance of the ERC20 token\n    /// @dev Use delegatecall\n    function claimRewards() external virtual {}\n\n    // solhint-enable no-empty-blocks\n}"
    }
  ]
}