{
  "Title": "[H-03] `BadgerYieldSource` `balanceOfToken` share calculation seems wrong",
  "Content": "_Submitted by cmichel_\n\nWhen suppling to the `BadgerYieldSource`, some `amount` of `badger` is deposited to `badgerSett` and one receives `badgerSett` share tokens in return which are stored in the `balances` mapping of the user. So far this is correct.\n\nThe `balanceOfToken` function should then return the redeemable balance in `badger` for the user's `badgerSett` balance.\nIt computes it as the pro-rata share of the user balance (compared to the total-supply of `badgerSett`) on the `badger` in the vault:\n\n```solidity\nbalances[addr].mul(\n  badger.balanceOf(address(badgerSett))\n).div(\n  badgerSett.totalSupply()\n)\n```\n\nHowever, `badger.balanceOf(address(badgerSett))` is only a small amount of badger that is deployed in the vault (\"Sett\") due to most of the capital being deployed to the _strategies_. Therefore, it under-reports the actual balance:\n\n> Typically, a Sett will keep a small portion of deposited funds in reserve to handle small withdrawals cheaply. [Badger Docs](https://badger-finance.gitbook.io/badger-finance/technical/setts/sett-contract)\n\nAny contract or user calling the `balanceOf` function will receive a value that is far lower than the actual balance.\nUsing this value as a basis for computations will lead to further errors in the integrations.\n\nRecommend using [`badgerSett.balance()`](https://github.com/Badger-Finance/badger-system/blob/2b0ee9bd77a2cc6f875b9b984ae4dfe713bbc55c/contracts/badger-sett/Sett.sol#L126) instead of `badger.balanceOf(address(badgerSett))` to also account for \"the balance in the Sett, the Controller, and the Strategy\".\n\n**[asselstine (PoolTogether) confirmed](https://github.com/code-423n4/2021-06-pooltogether-findings/issues/84)**\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2021-06-pooltogether",
  "Code": [
    {
      "filename": "contracts/badger-sett/Sett.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.11;\n\nimport \"../../deps/@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"../../deps/@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"../../deps/@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"../../deps/@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\";\nimport \"../../deps/@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"../../deps/@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"../../deps/@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\n\nimport \"../../interfaces/badger/IController.sol\";\nimport \"../../interfaces/erc20/IERC20Detailed.sol\";\nimport \"./SettAccessControlDefended.sol\";\n\n/* \n    Source: https://github.com/iearn-finance/yearn-protocol/blob/develop/contracts/vaults/yVault.sol\n    \n    Changelog:\n\n    V1.1\n    * Strategist no longer has special function calling permissions\n    * Version function added to contract\n    * All write functions, with the exception of transfer, are pausable\n    * Keeper or governance can pause\n    * Only governance can unpause\n\n    V1.2\n    * Transfer functions are now pausable along with all other non-permissioned write functions\n    * All permissioned write functions, with the exception of pause() & unpause(), are pausable as well\n*/\n\ncontract Sett is ERC20Upgradeable, SettAccessControlDefended, PausableUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressUpgradeable for address;\n    using SafeMathUpgradeable for uint256;\n\n    IERC20Upgradeable public token;\n\n    uint256 public min;\n    uint256 public constant max = 10000;\n\n    address public controller;\n\n    mapping(address => uint256) public blockLock;\n\n    string internal constant _defaultNamePrefix = \"Badger Sett \";\n    string internal constant _symbolSymbolPrefix = \"b\";\n\n    address public guardian;\n\n    event FullPricePerShareUpdated(uint256 value, uint256 indexed timestamp, uint256 indexed blockNumber);\n\n    function initialize(\n        address _token,\n        address _controller,\n        address _governance,\n        address _keeper,\n        address _guardian,\n        bool _overrideTokenName,\n        string memory _namePrefix,\n        string memory _symbolPrefix\n    ) public initializer whenNotPaused {\n        IERC20Detailed namedToken = IERC20Detailed(_token);\n        string memory tokenName = namedToken.name();\n        string memory tokenSymbol = namedToken.symbol();\n\n        string memory name;\n        string memory symbol;\n\n        if (_overrideTokenName) {\n            name = string(abi.encodePacked(_namePrefix, tokenName));\n            symbol = string(abi.encodePacked(_symbolPrefix, tokenSymbol));\n        } else {\n            name = string(abi.encodePacked(_defaultNamePrefix, tokenName));\n            symbol = string(abi.encodePacked(_symbolSymbolPrefix, tokenSymbol));\n        }\n\n        __ERC20_init(name, symbol);\n\n        token = IERC20Upgradeable(_token);\n        governance = _governance;\n        strategist = address(0);\n        keeper = _keeper;\n        controller = _controller;\n        guardian = _guardian;\n\n        min = 9500;\n\n        emit FullPricePerShareUpdated(getPricePerFullShare(), now, block.number);\n\n        // Paused on launch\n        _pause();\n    }\n\n    /// ===== Modifiers =====\n\n    function _onlyController() internal view {\n        require(msg.sender == controller, \"onlyController\");\n    }\n\n    function _onlyAuthorizedPausers() internal view {\n        require(msg.sender == guardian || msg.sender == governance, \"onlyPausers\");\n    }\n\n    function _blockLocked() internal view {\n        require(blockLock[msg.sender] < block.number, \"blockLocked\");\n    }\n\n    /// ===== View Functions =====\n\n    function version() public view returns (string memory) {\n        return \"1.2\";\n    }\n\n    function getPricePerFullShare() public view virtual returns (uint256) {\n        if (totalSupply() == 0) {\n            return 1e18;\n        }\n        return balance().mul(1e18).div(totalSupply());\n    }\n\n    /// @notice Return the total balance of the underlying token within the system\n    /// @notice Sums the balance in the Sett, the Controller, and the Strategy\n    function balance() public view returns (uint256) {\n        return token.balanceOf(address(this)).add(IController(controller).balanceOf(address(token)));\n    }\n\n    /// @notice Defines how much of the Setts' underlying can be borrowed by the Strategy for use\n    /// @notice Custom logic in here for how much the vault allows to be borrowed\n    /// @notice Sets minimum required on-hand to keep small withdrawals cheap\n    function available() public view virtual returns (uint256) {\n        return token.balanceOf(address(this)).mul(min).div(max);\n    }\n\n    /// ===== Public Actions =====\n\n    /// @notice Deposit assets into the Sett, and return corresponding shares to the user\n    /// @notice Only callable by EOA accounts that pass the _defend() check\n    function deposit(uint256 _amount) public whenNotPaused {\n        _defend();\n        _blockLocked();\n\n        _lockForBlock(msg.sender);\n        _deposit(_amount);\n    }\n\n    /// @notice Convenience function: Deposit entire balance of asset into the Sett, and return corresponding shares to the user\n    /// @notice Only callable by EOA accounts that pass the _defend() check\n    function depositAll() external whenNotPaused {\n        _defend();\n        _blockLocked();\n\n        _lockForBlock(msg.sender);\n        _deposit(token.balanceOf(msg.sender));\n    }\n\n    /// @notice No rebalance implementation for lower fees and faster swaps\n    function withdraw(uint256 _shares) public whenNotPaused {\n        _defend();\n        _blockLocked();\n\n        _lockForBlock(msg.sender);\n        _withdraw(_shares);\n    }\n\n    /// @notice Convenience function: Withdraw all shares of the sender\n    function withdrawAll() external whenNotPaused {\n        _defend();\n        _blockLocked();\n\n        _lockForBlock(msg.sender);\n        _withdraw(balanceOf(msg.sender));\n    }\n\n    /// ===== Permissioned Actions: Governance =====\n\n    /// @notice Set minimum threshold of underlying that must be deposited in strategy\n    /// @notice Can only be changed by governance\n    function setMin(uint256 _min) external whenNotPaused {\n        _onlyGovernance();\n        min = _min;\n    }\n\n    /// @notice Change controller address\n    /// @notice Can only be changed by governance\n    function setController(address _controller) public whenNotPaused {\n        _onlyGovernance();\n        controller = _controller;\n    }\n\n    /// @notice Change guardian address\n    /// @notice Can only be changed by governance\n    function setGuardian(address _guardian) external whenNotPaused {\n        _onlyGovernance();\n        guardian = _guardian;\n    }\n\n    /// ===== Permissioned Actions: Controller =====\n\n    /// @notice Used to swap any borrowed reserve over the debt limit to liquidate to 'token'\n    /// @notice Only controller can trigger harvests\n    function harvest(address reserve, uint256 amount) external whenNotPaused {\n        _onlyController();\n        require(reserve != address(token), \"token\");\n        IERC20Upgradeable(reserve).safeTransfer(controller, amount);\n    }\n\n    /// ===== Permissioned Functions: Trusted Actors =====\n\n    /// @notice Transfer the underlying available to be claimed to the controller\n    /// @notice The controller will deposit into the Strategy for yield-generating activities\n    /// @notice Permissionless operation\n    function earn() public whenNotPaused {\n        _onlyAuthorizedActors();\n\n        uint256 _bal = available();\n        token.safeTransfer(controller, _bal);\n        IController(controller).earn(address(token), _bal);\n    }\n\n    /// @dev Emit event tracking current full price per share\n    /// @dev Provides a pure on-chain way of approximating APY\n    function trackFullPricePerShare() external whenNotPaused {\n        _onlyAuthorizedActors();\n        emit FullPricePerShareUpdated(getPricePerFullShare(), now, block.number);\n    }\n\n    function pause() external {\n        _onlyAuthorizedPausers();\n        _pause();\n    }\n\n    function unpause() external {\n        _onlyGovernance();\n        _unpause();\n    }\n\n    /// ===== Internal Implementations =====\n\n    /// @dev Calculate the number of shares to issue for a given deposit\n    /// @dev This is based on the realized value of underlying assets between Sett & associated Strategy\n    function _deposit(uint256 _amount) internal virtual {\n        uint256 _pool = balance();\n        uint256 _before = token.balanceOf(address(this));\n        token.safeTransferFrom(msg.sender, address(this), _amount);\n        uint256 _after = token.balanceOf(address(this));\n        _amount = _after.sub(_before); // Additional check for deflationary tokens\n        uint256 shares = 0;\n        if (totalSupply() == 0) {\n            shares = _amount;\n        } else {\n            shares = (_amount.mul(totalSupply())).div(_pool);\n        }\n        _mint(msg.sender, shares);\n    }\n\n    // No rebalance implementation for lower fees and faster swaps\n    function _withdraw(uint256 _shares) internal virtual {\n        uint256 r = (balance().mul(_shares)).div(totalSupply());\n        _burn(msg.sender, _shares);\n\n        // Check balance\n        uint256 b = token.balanceOf(address(this));\n        if (b < r) {\n            uint256 _toWithdraw = r.sub(b);\n            IController(controller).withdraw(address(token), _toWithdraw);\n            uint256 _after = token.balanceOf(address(this));\n            uint256 _diff = _after.sub(b);\n            if (_diff < _toWithdraw) {\n                r = b.add(_diff);\n            }\n        }\n\n        token.safeTransfer(msg.sender, r);\n    }\n\n    function _lockForBlock(address account) internal {\n        blockLock[account] = block.number;\n    }\n\n    /// ===== ERC20 Overrides =====\n\n    /// @dev Add blockLock to transfers, users cannot transfer tokens in the same block as a deposit or withdrawal.\n    function transfer(address recipient, uint256 amount) public virtual override whenNotPaused returns (bool) {\n        _blockLocked();\n        return super.transfer(recipient, amount);\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override whenNotPaused returns (bool) {\n        _blockLocked();\n        return super.transferFrom(sender, recipient, amount);\n    }\n}"
    }
  ]
}