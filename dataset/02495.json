{
  "Title": "M-20: CryptoKitty and CryptoFighter NFT can be paused, which block borrowing / repaying / liquidating action in the ERC721Pool when borrowers still forced to pay the compounding interest",
  "Content": "# Issue M-20: CryptoKitty and CryptoFighter NFT can be paused, which block borrowing / repaying / liquidating action in the ERC721Pool when borrowers still forced to pay the compounding interest \n\nSource: https://github.com/sherlock-audit/2023-01-ajna-judging/issues/34 \n\n## Found by \nctf\\_sec\n\n## Summary\n\nCryptoKitty and CryptoFighter NFT can be paused, which block borrowing / repaying / liquidating action in the ERC721Pool\n\n## Vulnerability Detail\n\nIn the current implementation in the factory contract and the pool contract, special logic is in-place to handle non-standard NFT such as crypto-kitty, crypto-figher or crypto punk.\n\nIn the factory contract:\n\n```solidity\nNFTTypes nftType;\n// CryptoPunks NFTs\nif (collateral_ == 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB ) {\n\tnftType = NFTTypes.CRYPTOPUNKS;\n}\n// CryptoKitties and CryptoFighters NFTs\nelse if (collateral_ == 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d || collateral_ ==  0x87d598064c736dd0C712D329aFCFAA0Ccc1921A1) {\n\tnftType = NFTTypes.CRYPTOKITTIES;\n}\n// All other NFTs that support the EIP721 standard\nelse {\n\t// Here 0x80ac58cd is the ERC721 interface Id\n\t// Neither a standard NFT nor a non-standard supported NFT(punk, kitty or fighter)\n\ttry IERC165(collateral_).supportsInterface(0x80ac58cd) returns (bool supportsERC721Interface) {\n\t\tif (!supportsERC721Interface) revert NFTNotSupported();\n\t} catch {\n\t\trevert NFTNotSupported();\n\t}\n\n\tnftType = NFTTypes.STANDARD_ERC721;\n}\n```\n\nAnd in ERC721Pool When handling ERC721 token transfer:\n\n```solidity\n/**\n *  @notice Helper function for transferring multiple NFT tokens from msg.sender to pool.\n *  @notice Reverts in case token id is not supported by subset pool.\n *  @param  poolTokens_ Array in pool that tracks NFT ids (could be tracking NFTs pledged by borrower or NFTs added by a lender in a specific bucket).\n *  @param  tokenIds_   Array of NFT token ids to transfer from msg.sender to pool.\n */\nfunction _transferFromSenderToPool(\n\tuint256[] storage poolTokens_,\n\tuint256[] calldata tokenIds_\n) internal {\n\tbool subset   = _getArgUint256(SUBSET) != 0;\n\tuint8 nftType = _getArgUint8(NFT_TYPE);\n\n\tfor (uint256 i = 0; i < tokenIds_.length;) {\n\t\tuint256 tokenId = tokenIds_[i];\n\t\tif (subset && !tokenIdsAllowed[tokenId]) revert OnlySubset();\n\t\tpoolTokens_.push(tokenId);\n\n\t\tif (nftType == uint8(NFTTypes.STANDARD_ERC721)){\n\t\t\t_transferNFT(msg.sender, address(this), tokenId);\n\t\t}\n\t\telse if (nftType == uint8(NFTTypes.CRYPTOKITTIES)) {\n\t\t\tICryptoKitties(_getArgAddress(COLLATERAL_ADDRESS)).transferFrom(msg.sender ,address(this), tokenId);\n\t\t}\n\t\telse{\n\t\t\tICryptoPunks(_getArgAddress(COLLATERAL_ADDRESS)).buyPunk(tokenId);\n\t\t}\n\n\t\tunchecked { ++i; }\n\t}\n}\n```\n\nand\n\n```solidity\nuint8 nftType = _getArgUint8(NFT_TYPE);\n\nfor (uint256 i = 0; i < amountToRemove_;) {\n\tuint256 tokenId = poolTokens_[--noOfNFTsInPool]; // start with transferring the last token added in bucket\n\tpoolTokens_.pop();\n\n\tif (nftType == uint8(NFTTypes.STANDARD_ERC721)){\n\t\t_transferNFT(address(this), toAddress_, tokenId);\n\t}\n\telse if (nftType == uint8(NFTTypes.CRYPTOKITTIES)) {\n\t\tICryptoKitties(_getArgAddress(COLLATERAL_ADDRESS)).transfer(toAddress_, tokenId);\n\t}\n\telse {\n\t\tICryptoPunks(_getArgAddress(COLLATERAL_ADDRESS)).transferPunk(toAddress_, tokenId);\n\t}\n\n\ttokensTransferred[i] = tokenId;\n\n\tunchecked { ++i; }\n}\n```\n\nnote if the NFT address is classified as either crypto kitties or crypto fighers, then the NFT type is classified as CryptoKitties, then transfer and transferFrom method is triggered.\n\n```solidity\nif (nftType == uint8(NFTTypes.CRYPTOKITTIES)) {\n\t\t\tICryptoKitties(_getArgAddress(COLLATERAL_ADDRESS)).transferFrom(msg.sender ,address(this), tokenId);\n\t\t}\n```\n\nand\n\n```solidity\nelse if (nftType == uint8(NFTTypes.CRYPTOKITTIES)) {\n\tICryptoKitties(_getArgAddress(COLLATERAL_ADDRESS)).transfer(toAddress_, tokenId);\n}\n```\n\nHowever, in both crypto-kitty and in crypto-figher NFT, the transfer and transferFrom method can be paused.\n\nIn crypto-figher NFT:\n\nhttps://etherscan.io/address/0x87d598064c736dd0C712D329aFCFAA0Ccc1921A1#code#L873\n\n```solidity\nfunction transferFrom(\n\taddress _from,\n\taddress _to,\n\tuint256 _tokenId\n)\n\tpublic\n\twhenNotPaused\n{\n```\n\nIn Crypto-kitty NFT:\n\nhttps://etherscan.io/address/0x06012c8cf97BEaD5deAe237070F9587f8E7A266d#code#L615\n\n```solidity\nfunction transferFrom(\n\taddress _from,\n\taddress _to,\n\tuint256 _tokenId\n)\n\texternal\n\twhenNotPaused\n{\n```\n\nnote the WhenNotPaused modifier.\n\n## Impact\n\nIf the transfer and transferFrom is paused in CryptoKitty and CryptoFighter NFT, the borrowing and repaying and liquidating action is blocked in ERC721Pool, the user cannot fully clear his debt and has to pay the compounding interest when the transfer is paused.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/ERC721PoolFactory.sol#L58-L80\n\nhttps://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/ERC721Pool.sol#L591-L623\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nInterest should not be charged when external contract is paused to borrower when the external contract pause the transfer and transferFrom.\n\n## Discussion\n\n**grandizzy**\n\nwe're going to remove support for those NFTs and support only wrapped NFTs - will be fixed with the same fix as for #163 #140 #31 \n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/32",
  "Code": [
    {
      "filename": "contracts/src/ERC721PoolFactory.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.14;\n\nimport { ClonesWithImmutableArgs } from '@clones/ClonesWithImmutableArgs.sol';\nimport { IERC165 }                 from '@openzeppelin/contracts/utils/introspection/IERC165.sol';\n\nimport { IERC721PoolFactory } from './interfaces/pool/erc721/IERC721PoolFactory.sol';\nimport { NFTTypes }           from './interfaces/pool/erc721/IERC721NonStandard.sol';\n\nimport { IERC20Token, PoolType } from './interfaces/pool/IPool.sol';\n\nimport { ERC721Pool }   from './ERC721Pool.sol';\nimport { PoolDeployer } from './base/PoolDeployer.sol';\n\n/**\n *  @title  ERC721 Pool Factory\n *  @notice Pool factory contract for creating ERC721 pools. If a list with token ids is provided then a subset ERC721 pool is created for the NFT.\n *  @notice Pool creators can: create pool by providing a fungible token for quote, a non fungible token for collateral and an interest rate between 1-10%\n *  @dev    Reverts if pool is already created or if params to deploy new pool are invalid.\n */\ncontract ERC721PoolFactory is PoolDeployer, IERC721PoolFactory {\n\n    using ClonesWithImmutableArgs for address;\n\n    ERC721Pool public implementation;\n\n    /// @dev Default bytes32 hash used by ERC721 Non-NFTSubset pool types\n    bytes32 public constant ERC721_NON_SUBSET_HASH = keccak256(\"ERC721_NON_SUBSET_HASH\");\n\n    constructor(address ajna_) {\n        if (ajna_ == address(0)) revert DeployWithZeroAddress();\n\n        ajna = ajna_;\n\n        implementation = new ERC721Pool();\n    }\n\n    /**\n     *  @inheritdoc IERC721PoolFactory\n     *  @dev  immutable args:\n     *          - pool type; ajna, collateral and quote address; quote scale; number of token ids in subset; NFT type\n     *  @dev  write state:\n     *          - deployedPools mapping\n     *          - deployedPoolsList array\n     *  @dev reverts on:\n     *          - 0x address provided as quote or collateral DeployWithZeroAddress()\n     *          - pool with provided quote / collateral pair already exists PoolAlreadyExists()\n     *          - invalid interest rate provided PoolInterestRateInvalid()\n     *          - not supported NFT provided NFTNotSupported()\n     *  @dev emit events:\n     *          - PoolCreated\n     */\n    function deployPool(\n        address collateral_, address quote_, uint256[] memory tokenIds_, uint256 interestRate_\n    ) external canDeploy(getNFTSubsetHash(tokenIds_), collateral_, quote_, interestRate_) returns (address pool_) {\n        uint256 quoteTokenScale = 10**(18 - IERC20Token(quote_).decimals());\n\n        NFTTypes nftType;\n        // CryptoPunks NFTs\n        if (collateral_ == 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB ) {\n            nftType = NFTTypes.CRYPTOPUNKS;\n        }\n        // CryptoKitties and CryptoFighters NFTs\n        else if (collateral_ == 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d || collateral_ ==  0x87d598064c736dd0C712D329aFCFAA0Ccc1921A1) {\n            nftType = NFTTypes.CRYPTOKITTIES;\n        }\n        // All other NFTs that support the EIP721 standard\n        else {\n            // Here 0x80ac58cd is the ERC721 interface Id\n            // Neither a standard NFT nor a non-standard supported NFT(punk, kitty or fighter)\n            try IERC165(collateral_).supportsInterface(0x80ac58cd) returns (bool supportsERC721Interface) {\n                if (!supportsERC721Interface) revert NFTNotSupported();\n            } catch {\n                revert NFTNotSupported();\n            }\n\n            nftType = NFTTypes.STANDARD_ERC721;\n        }\n\n        bytes memory data = abi.encodePacked(\n            PoolType.ERC721,\n            ajna,\n            collateral_,\n            quote_,\n            quoteTokenScale,\n            tokenIds_.length,\n            nftType\n        );\n\n        ERC721Pool pool = ERC721Pool(address(implementation).clone(data));\n\n        pool_ = address(pool);\n\n        // Track the newly deployed pool\n        deployedPools[getNFTSubsetHash(tokenIds_)][collateral_][quote_] = pool_;\n        deployedPoolsList.push(pool_);\n\n        emit PoolCreated(pool_);\n\n        pool.initialize(tokenIds_, interestRate_);\n    }\n\n    /*******************************/\n    /*** Pool Creation Functions ***/\n    /*******************************/\n\n    function getNFTSubsetHash(uint256[] memory tokenIds_) public pure returns (bytes32) {\n        if (tokenIds_.length == 0) return ERC721_NON_SUBSET_HASH;\n        else return keccak256(abi.encodePacked(tokenIds_));\n    }\n}"
    },
    {
      "filename": "contracts/src/ERC721Pool.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.14;\n\nimport {\n    IERC721Token,\n    IPoolErrors,\n    IPoolLenderActions,\n    IPoolLiquidationActions\n}                           from './interfaces/pool/IPool.sol';\nimport {\n    BucketTakeResult,\n    DrawDebtResult,\n    RepayDebtResult,\n    SettleParams,\n    TakeResult\n}                           from './interfaces/pool/commons/IPoolInternals.sol';\nimport { PoolState }        from './interfaces/pool/commons/IPoolState.sol';\n\nimport {\n    IERC721Pool,\n    IERC721PoolBorrowerActions,\n    IERC721PoolImmutables,\n    IERC721PoolLenderActions\n}                               from './interfaces/pool/erc721/IERC721Pool.sol';\nimport { IERC721Taker }         from './interfaces/pool/erc721/IERC721Taker.sol';\nimport {\n    ICryptoPunks,\n    ICryptoKitties,\n    NFTTypes\n}                               from './interfaces/pool/erc721/IERC721NonStandard.sol';\n\nimport { FlashloanablePool } from './base/FlashloanablePool.sol';\n\nimport { _revertIfAuctionClearable } from './libraries/helpers/RevertsHelper.sol';\n\nimport { Maths }    from './libraries/internal/Maths.sol';\nimport { Deposits } from './libraries/internal/Deposits.sol';\nimport { Loans }    from './libraries/internal/Loans.sol';\n\nimport { Auctions }        from './libraries/external/Auctions.sol';\nimport { LenderActions }   from './libraries/external/LenderActions.sol';\nimport { BorrowerActions } from './libraries/external/BorrowerActions.sol';\n\n/**\n *  @title  ERC721 Pool contract\n *  @notice Entrypoint of ERC721 Pool actions for pool actors:\n *          - Lenders: add, remove and move quote tokens; transfer LPs\n *          - Borrowers: draw and repay debt\n *          - Traders: add, remove and move quote tokens; add and remove collateral\n *          - Kickers: auction undercollateralized loans; settle auctions; claim bond rewards\n *          - Bidders: take auctioned collateral\n *          - Reserve purchasers: start auctions; take reserves\n *          - Flash borrowers: initiate flash loans on ERC20 quote tokens\n *  @dev    Contract is FlashloanablePool with flash loan logic.\n *  @dev    Contract is base Pool with logic to handle ERC721 collateral.\n *  @dev    Calls logic from external PoolCommons, LenderActions, BorrowerActions and Auctions libraries.\n */\ncontract ERC721Pool is FlashloanablePool, IERC721Pool {\n\n    /*****************/\n    /*** Constants ***/\n    /*****************/\n\n    // immutable args offset\n    uint256 internal constant SUBSET   = 93;\n    uint256 internal constant NFT_TYPE = 125;\n\n    /***********************/\n    /*** State Variables ***/\n    /***********************/\n\n    mapping(uint256 => bool)      public tokenIdsAllowed;  // set of tokenIds that can be used for a given NFT Subset type pool\n    mapping(address => uint256[]) public borrowerTokenIds; // borrower address => array of tokenIds pledged by borrower\n    uint256[]                     public bucketTokenIds;   // array of tokenIds added in pool buckets\n\n    /****************************/\n    /*** Initialize Functions ***/\n    /****************************/\n\n    /// @inheritdoc IERC721Pool\n    function initialize(\n        uint256[] memory tokenIds_,\n        uint256 rate_\n    ) external override {\n        if (isPoolInitialized) revert AlreadyInitialized();\n\n        inflatorState.inflator       = uint208(1e18);\n        inflatorState.inflatorUpdate = uint48(block.timestamp);\n\n        interestState.interestRate       = uint208(rate_);\n        interestState.interestRateUpdate = uint48(block.timestamp);\n\n        uint256 noOfTokens = tokenIds_.length;\n\n        if (noOfTokens != 0) {\n            // add subset of tokenIds allowed in the pool\n            for (uint256 id = 0; id < noOfTokens;) {\n                tokenIdsAllowed[tokenIds_[id]] = true;\n\n                unchecked { ++id; }\n            }\n        }\n\n        Loans.init(loans);\n\n        // increment initializations count to ensure these values can't be updated\n        isPoolInitialized = true;\n    }\n\n    /******************/\n    /*** Immutables ***/\n    /******************/\n\n    /// @inheritdoc IERC721PoolImmutables\n    function isSubset() external pure override returns (bool) {\n        return _getArgUint256(SUBSET) != 0;\n    }\n\n    /***********************************/\n    /*** Borrower External Functions ***/\n    /***********************************/\n\n    /**\n     *  @inheritdoc IERC721PoolBorrowerActions\n     *  @dev write state:\n     *          - decrement poolBalances.t0DebtInAuction accumulator\n     *          - increment poolBalances.pledgedCollateral accumulator\n     *          - increment poolBalances.t0Debt accumulator\n     *          - update borrowerTokenIds and bucketTokenIds arrays\n     *  @dev emit events:\n     *          - DrawDebtNFT\n     */\n    function drawDebt(\n        address borrowerAddress_,\n        uint256 amountToBorrow_,\n        uint256 limitIndex_,\n        uint256[] calldata tokenIdsToPledge_\n    ) external nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        DrawDebtResult memory result = BorrowerActions.drawDebt(\n            auctions,\n            buckets,\n            deposits,\n            loans,\n            poolState,\n            borrowerAddress_,\n            amountToBorrow_,\n            limitIndex_,\n            Maths.wad(tokenIdsToPledge_.length)\n        );\n\n        emit DrawDebtNFT(borrowerAddress_, amountToBorrow_, tokenIdsToPledge_, result.newLup);\n\n        // update pool interest rate state\n        poolState.debt       = result.poolDebt;\n        poolState.collateral = result.poolCollateral;\n        _updateInterestState(poolState, result.newLup);\n\n        if (tokenIdsToPledge_.length != 0) {\n            // update pool balances state\n            if (result.t0DebtInAuctionChange != 0) {\n                poolBalances.t0DebtInAuction -= result.t0DebtInAuctionChange;\n            }\n            poolBalances.pledgedCollateral += Maths.wad(tokenIdsToPledge_.length);\n\n            // move collateral from sender to pool\n            _transferFromSenderToPool(borrowerTokenIds[borrowerAddress_], tokenIdsToPledge_);\n        }\n\n        if (result.settledAuction) _rebalanceTokens(borrowerAddress_, result.remainingCollateral);\n\n        // move borrowed amount from pool to sender\n        if (amountToBorrow_ != 0) {\n            // update pool balances state\n            poolBalances.t0Debt += result.t0DebtChange;\n\n            // move borrowed amount from pool to sender\n            _transferQuoteToken(msg.sender, amountToBorrow_);\n        }\n    }\n\n    /**\n     *  @inheritdoc IERC721PoolBorrowerActions\n     *  @dev write state:\n     *          - decrement poolBalances.t0Debt accumulator\n     *          - decrement poolBalances.t0DebtInAuction accumulator\n     *          - decrement poolBalances.pledgedCollateral accumulator\n     *          - update borrowerTokenIds arrays\n     *  @dev emit events:\n     *          - RepayDebt\n     */\n    function repayDebt(\n        address borrowerAddress_,\n        uint256 maxQuoteTokenAmountToRepay_,\n        uint256 noOfNFTsToPull_\n    ) external nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        RepayDebtResult memory result = BorrowerActions.repayDebt(\n            auctions,\n            buckets,\n            deposits,\n            loans,\n            poolState,\n            borrowerAddress_,\n            maxQuoteTokenAmountToRepay_,\n            Maths.wad(noOfNFTsToPull_)\n        );\n\n        emit RepayDebt(borrowerAddress_, result.quoteTokenToRepay, noOfNFTsToPull_, result.newLup);\n\n        if (result.settledAuction) _rebalanceTokens(borrowerAddress_, result.remainingCollateral);\n\n        // update pool interest rate state\n        poolState.debt       = result.poolDebt;\n        poolState.collateral = result.poolCollateral;\n        _updateInterestState(poolState, result.newLup);\n\n        if (result.quoteTokenToRepay != 0) {\n            // update pool balances state\n            poolBalances.t0Debt -= result.t0RepaidDebt;\n            if (result.t0DebtInAuctionChange != 0) {\n                poolBalances.t0DebtInAuction -= result.t0DebtInAuctionChange;\n            }\n\n            // move amount to repay from sender to pool\n            _transferQuoteTokenFrom(msg.sender, result.quoteTokenToRepay);\n        }\n        if (noOfNFTsToPull_ != 0) {\n            // update pool balances state\n            poolBalances.pledgedCollateral = result.poolCollateral;\n\n            // move collateral from pool to sender\n            _transferFromPoolToAddress(msg.sender, borrowerTokenIds[msg.sender], noOfNFTsToPull_);\n        }\n    }\n\n    /*********************************/\n    /*** Lender External Functions ***/\n    /*********************************/\n\n    /**\n     *  @inheritdoc IERC721PoolLenderActions\n     *  @dev write state:\n     *          - update borrowerTokenIds arrays\n     *  @dev emit events:\n     *          - AddCollateralNFT\n     */\n    function addCollateral(\n        uint256[] calldata tokenIdsToAdd_,\n        uint256 index_\n    ) external override nonReentrant returns (uint256 bucketLPs_) {\n        PoolState memory poolState = _accruePoolInterest();\n\n        bucketLPs_ = LenderActions.addCollateral(\n            buckets,\n            deposits,\n            Maths.wad(tokenIdsToAdd_.length),\n            index_\n        );\n\n        emit AddCollateralNFT(msg.sender, index_, tokenIdsToAdd_, bucketLPs_);\n\n        // update pool interest rate state\n        _updateInterestState(poolState, _lup(poolState.debt));\n\n        // move required collateral from sender to pool\n        _transferFromSenderToPool(bucketTokenIds, tokenIdsToAdd_);\n    }\n\n    /**\n     *  @inheritdoc IERC721PoolLenderActions\n     *  @dev write state:\n     *          - update bucketTokenIds arrays\n     *  @dev emit events:\n     *          - MergeOrRemoveCollateralNFT\n     */\n    function mergeOrRemoveCollateral(\n        uint256[] calldata removalIndexes_,\n        uint256 noOfNFTsToRemove_,\n        uint256 toIndex_\n    ) external override nonReentrant returns (uint256 collateralMerged_, uint256 bucketLPs_) {\n        PoolState memory poolState = _accruePoolInterest();\n        uint256 collateralAmount = Maths.wad(noOfNFTsToRemove_);\n\n        (\n            collateralMerged_,\n            bucketLPs_\n        ) = LenderActions.mergeOrRemoveCollateral(\n            buckets,\n            deposits,\n            removalIndexes_,\n            collateralAmount,\n            toIndex_\n        );\n\n        emit MergeOrRemoveCollateralNFT(msg.sender, collateralMerged_, bucketLPs_);\n\n        // update pool interest rate state\n        _updateInterestState(poolState, _lup(poolState.debt));\n\n        if (collateralMerged_ == collateralAmount) {\n            // Total collateral in buckets meets the requested removal amount, noOfNFTsToRemove_\n            _transferFromPoolToAddress(msg.sender, bucketTokenIds, noOfNFTsToRemove_);\n        }\n\n    }\n\n    /**\n     *  @inheritdoc IPoolLenderActions\n     *  @dev write state:\n     *          - update bucketTokenIds arrays\n     *  @dev emit events:\n     *          - RemoveCollateral\n     */\n    function removeCollateral(\n        uint256 noOfNFTsToRemove_,\n        uint256 index_\n    ) external override nonReentrant returns (uint256 collateralAmount_, uint256 lpAmount_) {\n        _revertIfAuctionClearable(auctions, loans);\n\n        PoolState memory poolState = _accruePoolInterest();\n\n        collateralAmount_ = Maths.wad(noOfNFTsToRemove_);\n        lpAmount_ = LenderActions.removeCollateral(\n            buckets,\n            deposits,\n            collateralAmount_,\n            index_\n        );\n\n        emit RemoveCollateral(msg.sender, index_, noOfNFTsToRemove_, lpAmount_);\n\n        // update pool interest rate state\n        _updateInterestState(poolState, _lup(poolState.debt));\n\n        _transferFromPoolToAddress(msg.sender, bucketTokenIds, noOfNFTsToRemove_);\n    }\n\n    /*******************************/\n    /*** Pool Auctions Functions ***/\n    /*******************************/\n\n    /**\n     *  @inheritdoc IPoolLiquidationActions\n     *  @dev write state:\n     *          - decrement poolBalances.t0Debt accumulator\n     *          - decrement poolBalances.t0DebtInAuction accumulator\n     *          - decrement poolBalances.pledgedCollateral accumulator\n     */\n    function settle(\n        address borrowerAddress_,\n        uint256 maxDepth_\n    ) external nonReentrant override {\n        PoolState memory poolState = _accruePoolInterest();\n\n        uint256 assets = Maths.wmul(poolBalances.t0Debt, poolState.inflator) + _getPoolQuoteTokenBalance();\n        uint256 liabilities = Deposits.treeSum(deposits) + auctions.totalBondEscrowed + reserveAuction.unclaimed;\n\n        SettleParams memory params = SettleParams(\n            {\n                borrower:    borrowerAddress_,\n                reserves:    (assets > liabilities) ? (assets-liabilities) : 0,\n                inflator:    poolState.inflator,\n                bucketDepth: maxDepth_,\n                poolType:    poolState.poolType\n            }\n        );\n        (\n            uint256 collateralRemaining,\n            uint256 t0DebtRemaining,\n            uint256 collateralSettled,\n            uint256 t0DebtSettled\n        ) = Auctions.settlePoolDebt(\n            auctions,\n            buckets,\n            deposits,\n            loans,\n            params\n        );\n\n        // slither-disable-next-line incorrect-equality\n        if (t0DebtRemaining == 0) _rebalanceTokens(params.borrower, collateralRemaining);\n\n        // update pool balances state\n        poolBalances.t0Debt            -= t0DebtSettled;\n        poolBalances.t0DebtInAuction   -= t0DebtSettled;\n        poolBalances.pledgedCollateral -= collateralSettled;\n\n        // update pool interest rate state\n        poolState.debt       -= Maths.wmul(t0DebtSettled, poolState.inflator);\n        poolState.collateral -= collateralSettled;\n        _updateInterestState(poolState, _lup(poolState.debt));\n    }\n\n    /**\n     *  @inheritdoc IPoolLiquidationActions\n     *  @dev write state:\n     *          - decrement poolBalances.t0Debt accumulator\n     *          - decrement poolBalances.t0DebtInAuction accumulator\n     *          - decrement poolBalances.pledgedCollateral accumulator\n     */\n    function take(\n        address        borrowerAddress_,\n        uint256        collateral_,\n        address        callee_,\n        bytes calldata data_\n    ) external override nonReentrant {\n        PoolState memory poolState = _accruePoolInterest();\n\n        TakeResult memory result = Auctions.take(\n            auctions,\n            buckets,\n            deposits,\n            loans,\n            poolState,\n            borrowerAddress_,\n            Maths.wad(collateral_),\n            1\n        );\n\n        // update pool balances state\n        uint256 t0PoolDebt      = poolBalances.t0Debt;\n        uint256 t0DebtInAuction = poolBalances.t0DebtInAuction;\n\n        if (result.t0DebtPenalty != 0) {\n            t0PoolDebt      += result.t0DebtPenalty;\n            t0DebtInAuction += result.t0DebtPenalty;\n        }\n\n        t0PoolDebt      -= result.t0RepayAmount;\n        t0DebtInAuction -= result.t0DebtInAuctionChange;\n\n        poolBalances.t0Debt            =  t0PoolDebt;\n        poolBalances.t0DebtInAuction   =  t0DebtInAuction;\n        poolBalances.pledgedCollateral -= result.collateralAmount;\n\n        // update pool interest rate state\n        poolState.debt       =  result.poolDebt;\n        poolState.collateral -= result.collateralAmount;\n        _updateInterestState(poolState, result.newLup);\n\n        // transfer rounded collateral from pool to taker\n        uint256[] memory tokensTaken = _transferFromPoolToAddress(\n            callee_,\n            borrowerTokenIds[borrowerAddress_],\n            result.collateralAmount / 1e18\n        );\n\n        if (data_.length != 0) {\n            IERC721Taker(callee_).atomicSwapCallback(\n                tokensTaken,\n                result.quoteTokenAmount / _getArgUint256(QUOTE_SCALE), \n                data_\n            );\n        }\n\n        if (result.settledAuction) _rebalanceTokens(borrowerAddress_, result.remainingCollateral);\n\n        // transfer from taker to pool the amount of quote tokens needed to cover collateral auctioned (including excess for rounded collateral)\n        _transferQuoteTokenFrom(callee_, result.quoteTokenAmount + result.excessQuoteToken);\n\n        // transfer from pool to borrower the excess of quote tokens after rounding collateral auctioned\n        if (result.excessQuoteToken != 0) _transferQuoteToken(borrowerAddress_, result.excessQuoteToken);\n    }\n\n    /**\n     *  @inheritdoc IPoolLiquidationActions\n     *  @dev write state:\n     *          - decrement poolBalances.t0Debt accumulator\n     *          - decrement poolBalances.t0DebtInAuction accumulator\n     *          - decrement poolBalances.pledgedCollateral accumulator\n     */\n    function bucketTake(\n        address borrowerAddress_,\n        bool    depositTake_,\n        uint256 index_\n    ) external override nonReentrant {\n\n        PoolState memory poolState = _accruePoolInterest();\n\n        BucketTakeResult memory result = Auctions.bucketTake(\n            auctions,\n            buckets,\n            deposits,\n            loans,\n            poolState,\n            borrowerAddress_,\n            depositTake_,\n            index_,\n            1\n        );\n\n        // update pool balances state\n        uint256 t0PoolDebt      = poolBalances.t0Debt;\n        uint256 t0DebtInAuction = poolBalances.t0DebtInAuction;\n\n        if (result.t0DebtPenalty != 0) {\n            t0PoolDebt      += result.t0DebtPenalty;\n            t0DebtInAuction += result.t0DebtPenalty;\n        }\n\n        t0PoolDebt      -= result.t0RepayAmount;\n        t0DebtInAuction -= result.t0DebtInAuctionChange;\n\n        poolBalances.t0Debt            =  t0PoolDebt;\n        poolBalances.t0DebtInAuction   =  t0DebtInAuction;\n        poolBalances.pledgedCollateral -= result.collateralAmount;\n\n        // update pool interest rate state\n        poolState.debt       = result.poolDebt;\n        poolState.collateral -= result.collateralAmount;\n        _updateInterestState(poolState, result.newLup);\n\n        if (result.settledAuction) _rebalanceTokens(borrowerAddress_, result.remainingCollateral);\n    }\n\n    /**************************/\n    /*** Internal Functions ***/\n    /**************************/\n\n    /**\n     *  @notice Rebalance NFT token and transfer difference to floor collateral from borrower to pool claimable array\n     *  @dev    write state:\n     *              - update borrowerTokens and bucketTokenIds arrays\n     *  @dev    emit events:\n     *              - RemoveCollateral\n     *  @param  borrowerAddress_    Address of borrower.\n     *  @param  borrowerCollateral_ Current borrower collateral to be rebalanced.\n     */\n    function _rebalanceTokens(\n        address borrowerAddress_,\n        uint256 borrowerCollateral_\n    ) internal {\n        // rebalance borrower's collateral, transfer difference to floor collateral from borrower to pool claimable array\n        uint256[] storage borrowerTokens = borrowerTokenIds[borrowerAddress_];\n\n        uint256 noOfTokensPledged    = borrowerTokens.length;\n        uint256 noOfTokensToTransfer = borrowerCollateral_ != 0 ? noOfTokensPledged - borrowerCollateral_ / 1e18 : noOfTokensPledged;\n\n        for (uint256 i = 0; i < noOfTokensToTransfer;) {\n            uint256 tokenId = borrowerTokens[--noOfTokensPledged]; // start with moving the last token pledged by borrower\n            borrowerTokens.pop();                                  // remove token id from borrower\n            bucketTokenIds.push(tokenId);                          // add token id to pool claimable tokens\n\n            unchecked { ++i; }\n        }\n    }\n\n    /**\n     *  @notice Helper function for transferring multiple NFT tokens from msg.sender to pool.\n     *  @notice Reverts in case token id is not supported by subset pool.\n     *  @param  poolTokens_ Array in pool that tracks NFT ids (could be tracking NFTs pledged by borrower or NFTs added by a lender in a specific bucket).\n     *  @param  tokenIds_   Array of NFT token ids to transfer from msg.sender to pool.\n     */\n    function _transferFromSenderToPool(\n        uint256[] storage poolTokens_,\n        uint256[] calldata tokenIds_\n    ) internal {\n        bool subset   = _getArgUint256(SUBSET) != 0;\n        uint8 nftType = _getArgUint8(NFT_TYPE);\n\n        for (uint256 i = 0; i < tokenIds_.length;) {\n            uint256 tokenId = tokenIds_[i];\n            if (subset && !tokenIdsAllowed[tokenId]) revert OnlySubset();\n            poolTokens_.push(tokenId);\n\n            if (nftType == uint8(NFTTypes.STANDARD_ERC721)){\n                _transferNFT(msg.sender, address(this), tokenId);\n            }\n            else if (nftType == uint8(NFTTypes.CRYPTOKITTIES)) {\n                ICryptoKitties(_getArgAddress(COLLATERAL_ADDRESS)).transferFrom(msg.sender ,address(this), tokenId);\n            }\n            else{\n                ICryptoPunks(_getArgAddress(COLLATERAL_ADDRESS)).buyPunk(tokenId);\n            }\n\n            unchecked { ++i; }\n        }\n    }\n\n    /**\n     *  @notice Helper function for transferring multiple NFT tokens from pool to given address.\n     *  @notice It transfers NFTs from the most recent one added into the pool (pop from array tracking NFTs in pool).\n     *  @param  toAddress_      Address where pool should transfer tokens to.\n     *  @param  poolTokens_     Array in pool that tracks NFT ids (could be tracking NFTs pledged by borrower or NFTs added by a lender in a specific bucket).\n     *  @param  amountToRemove_ Number of NFT tokens to transfer from pool to given address.\n     *  @return Array containing token ids that were transferred from pool to address.\n     */\n    function _transferFromPoolToAddress(\n        address toAddress_,\n        uint256[] storage poolTokens_,\n        uint256 amountToRemove_\n    ) internal returns (uint256[] memory) {\n        uint256[] memory tokensTransferred = new uint256[](amountToRemove_);\n\n        uint256 noOfNFTsInPool = poolTokens_.length;\n\n        uint8 nftType = _getArgUint8(NFT_TYPE);\n\n        for (uint256 i = 0; i < amountToRemove_;) {\n            uint256 tokenId = poolTokens_[--noOfNFTsInPool]; // start with transferring the last token added in bucket\n            poolTokens_.pop();\n\n            if (nftType == uint8(NFTTypes.STANDARD_ERC721)){\n                _transferNFT(address(this), toAddress_, tokenId);\n            }\n            else if (nftType == uint8(NFTTypes.CRYPTOKITTIES)) {\n                ICryptoKitties(_getArgAddress(COLLATERAL_ADDRESS)).transfer(toAddress_, tokenId);\n            }\n            else {\n                ICryptoPunks(_getArgAddress(COLLATERAL_ADDRESS)).transferPunk(toAddress_, tokenId);\n            }\n\n            tokensTransferred[i] = tokenId;\n\n            unchecked { ++i; }\n        }\n\n        return tokensTransferred;\n    }\n\n    /**\n     *  @dev Helper function to transfer an NFT from owner to target address (reused in code to reduce contract deployment bytecode size).\n     *  @param from_    NFT owner address.\n     *  @param to_      New NFT owner address.\n     *  @param tokenId_ NFT token id to be transferred.\n     */\n    function _transferNFT(address from_, address to_, uint256 tokenId_) internal {\n        // slither-disable-next-line calls-loop\n        IERC721Token(_getArgAddress(COLLATERAL_ADDRESS)).safeTransferFrom(from_, to_, tokenId_);\n    }\n\n    /************************/\n    /*** Helper Functions ***/\n    /************************/\n\n    /** @notice Implementing this method allows contracts to receive ERC721 tokens\n     *  @dev https://forum.openzeppelin.com/t/erc721holder-ierc721receiver-and-onerc721received/11828\n     */\n    function onERC721Received(address, address, uint256, bytes memory) external pure returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n}"
    }
  ]
}