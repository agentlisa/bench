{
  "Title": "M-6: Multiple functions aren't payable so quotes that require protocol fees won't work correctly",
  "Content": "# Issue M-6: Multiple functions aren't payable so quotes that require protocol fees won't work correctly \n\nSource: https://github.com/sherlock-audit/2023-03-sense-judging/issues/28 \n\n## Found by \n0x52, Bauer\n\n## Summary\n\nThere are multiple functions that use quotes but that aren't payable. This breaks their compatibility with some quotes. As the [0x docs](https://docs.0x.org/0x-swap-api/guides/use-0x-api-liquidity-in-your-smart-contracts) state: `Certain quotes require a protocol fee, in ETH, to be attached to the swap call`.\n\nThe following flows use a quote but the external/public starting function isn't payable:\n\nRollerPeriphery\n1) redeem\n\nPeriphery\n1) removeLiquidity\n2) combine\n3) swapPT\n4) swapYT\n5) issue\n\n## Vulnerability Detail\n\nSee summary.\n\n## Impact\n\nFunctions won't be compatible with certain quotes causing wasted gas fees or bad rates for users\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-03-sense/blob/main/auto-roller/src/RollerPeriphery.sol#L104\n\nhttps://github.com/sherlock-audit/2023-03-sense/blob/main/sense-v1/pkg/core/src/Periphery.sol#L325\n\nhttps://github.com/sherlock-audit/2023-03-sense/blob/main/sense-v1/pkg/core/src/Periphery.sol#L409\n\nhttps://github.com/sherlock-audit/2023-03-sense/blob/main/sense-v1/pkg/core/src/Periphery.sol#L433\n\nhttps://github.com/sherlock-audit/2023-03-sense/blob/main/sense-v1/pkg/core/src/Periphery.sol#L240\n\nhttps://github.com/sherlock-audit/2023-03-sense/blob/main/sense-v1/pkg/core/src/Periphery.sol#L263\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAdd payable to these external/public functions\n\n\n\n## Discussion\n\n**jparklev**\n\nConfirmed: We've forgotten to add payable to the functions mentioned\n\n**jparklev**\n\nFixed here for sense-v1: https://github.com/sense-finance/sense-v1/pull/345\nAnd here for the auto-roller: https://github.com/sense-finance/auto-roller/pull/33\n\nWe took the suggested fix and added payable to the mentioned functions\n\n**IAm0x52**\n\nFixes look good. Payable has been added to Periphery#removeLiquidity, combine, swapPT, swapYT and issue. Also adds payable to RollerPeriphery#redeem\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/58",
  "Code": [
    {
      "filename": "auto-roller/src/RollerPeriphery.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport { ERC20 } from \"solmate/tokens/ERC20.sol\";\nimport { ERC4626 } from \"solmate/mixins/ERC4626.sol\";\nimport { SafeTransferLib } from \"solmate/utils/SafeTransferLib.sol\";\nimport { FixedPointMathLib } from \"solmate/utils/FixedPointMathLib.sol\";\n\nimport { Trust } from \"sense-v1-utils/Trust.sol\";\n\nimport { AutoRoller } from \"./AutoRoller.sol\";\n\nimport { IPermit2 } from \"./interfaces/IPermit2.sol\";\n\ninterface AdapterLike {\n    function scale() external view returns (uint256);\n    function underlying() external view returns (address);\n    function target() external view returns (address);\n    function wrapUnderlying(uint256) external returns (uint256);\n    function unwrapTarget(uint256) external returns (uint256);\n}\n\n// Inspired by https://github.com/fei-protocol/ERC4626/blob/main/src/ERC4626Router.sol\ncontract RollerPeriphery is Trust {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    /* ========== PUBLIC CONSTANTS ========== */\n\n    /// @notice ETH address\n    address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /* ========== PUBLIC IMMUTABLES ========== */\n\n    /// @notice Permit2 contract\n    IPermit2 public immutable permit2;\n\n    // 0x ExchangeProxy address. See https://docs.0x.org/developer-resources/contract-addresses\n    address public immutable exchangeProxy;\n\n    /* ========== DATA STRUCTURES ========== */\n\n    struct PermitData {\n        IPermit2.PermitTransferFrom msg;\n        bytes sig;\n    }\n\n    struct SwapQuote {\n        ERC20 sellToken;\n        ERC20 buyToken;\n        address spender;\n        address payable swapTarget;\n        bytes swapCallData;\n    }\n\n    /* ========== ERRORS ========== */\n\n    /// @notice thrown when amount of assets received is below the min set by caller.\n    error MinAssetError();\n\n    /// @notice thrown when amount of underlying received is below the min set by caller.\n    error MinUnderlyingError();\n\n    /// @notice thrown when amount of shares received is below the min set by caller.\n    error MinSharesError();\n\n    /// @notice thrown when amount of assets received is above the max set by caller.\n    error MaxAssetError();\n\n    /// @notice thrown when amount of underlying received is above the max set by caller.\n    error MaxUnderlyingError();\n\n    /// @notice thrown when amount of shares received is above the max set by caller.\n    error MaxSharesError();\n\n    /// @notice thrown when amount of assets or excess received is below the max set by caller.\n    error MinAssetsOrExcessError();\n\n    /// @notice thrown when amount out received is below the min set by caller.\n    error MinAmountOutError();\n\n    /// @notice thrown when swap on 0x returns false.\n    error ZeroExSwapFailed(bytes res);\n\n    /// @notice thrown when swap on 0x succeeds but either the sellAmount or they buyAmount are zero.\n    error ZeroSwapAmt();\n\n    /// @notice thrown if swapTarget is not the exchange proxy.\n    error InvalidExchangeProxy();\n\n    constructor(IPermit2 _permit2, address _exchangeProxy) Trust(msg.sender) {\n        permit2 = _permit2;\n        exchangeProxy = _exchangeProxy;\n    }\n\n    /// @notice Redeem vault shares to any token, with slippage protection\n    /// @param roller AutoRoller vault\n    /// @param shares Number of shares to redeem\n    /// @param receiver Destination address for the returned assets\n    /// @param minAmountOut Minimum amount of tokens returned\n    /// @param permit Permit message to pull shares from caller\n    /// @param quote Swap quote for converting underlying to token\n    /// @return amtOut Amount of tokens redeemed by the given number of shares\n    function redeem(AutoRoller roller, uint256 shares, address receiver, uint256 minAmountOut, PermitData calldata permit, SwapQuote calldata quote) external returns (uint256 amtOut) {\n        _transferFrom(permit, address(roller), shares);\n\n        if ((amtOut = _fromTarget(address(roller.adapter()), roller.redeem(shares, address(this), address(this)), quote)) < minAmountOut) {\n            revert MinAmountOutError();\n        }\n        address(quote.buyToken) == ETH\n            ? payable(receiver).transfer(amtOut)\n            : ERC20(address(quote.buyToken)).safeTransfer(receiver, amtOut); // transfer bought tokens to receiver\n\n        _transferRemainingUnderlying(roller, receiver);\n    }\n\n    /// @notice Withdraw asset from vault with slippage protection\n    /// @param roller AutoRoller vault\n    /// @param assets Amount of asset requested for withdrawal\n    /// @param receiver Destination address for the returned assets\n    /// @param maxSharesOut Maximum amount of shares burned\n    /// @param permit Permit message to pull shares from caller\n    /// @return shares Number of shares to redeem\n    function withdrawTarget(AutoRoller roller, uint256 assets, address receiver, uint256 maxSharesOut, PermitData calldata permit) external returns (uint256 shares) {\n        _transferFrom(permit, address(roller), roller.previewWithdraw(assets));\n        \n        if ((shares = roller.withdraw(assets, receiver, address(this))) > maxSharesOut) {\n            revert MaxSharesError();\n        }\n    }\n\n    /// @notice Withdraw asset from vault and convert to underlying, with slippage protection\n    /// @param roller AutoRoller vault\n    /// @param underlyingOut Amount of underlying requested for withdrawal\n    /// @param receiver Destination address for the returned underlying\n    /// @param maxSharesOut Maximum amount of shared burned\n    /// @param permit Permit message to pull shares from caller\n    /// @return shares Number of shares to redeem\n    function withdrawUnderlying(AutoRoller roller, uint256 underlyingOut, address receiver, uint256 maxSharesOut, PermitData calldata permit) external returns (uint256 shares) {\n        AdapterLike adapter = AdapterLike(address(roller.adapter()));\n\n        // asset converted from underlying (round down)\n        uint256 assetOut = underlyingOut.divWadDown(adapter.scale());\n\n        _transferFrom(permit, address(roller), roller.previewWithdraw(assetOut));\n\n        if ((shares = roller.withdraw(assetOut, address(this), address(this))) > maxSharesOut) {\n            revert MaxSharesError();\n        }\n\n        uint256 underlyingOut = adapter.unwrapTarget(roller.asset().balanceOf(address(this)));\n        ERC20(adapter.underlying()).safeTransfer(receiver, underlyingOut);\n    }\n\n    /// @notice Mint vault shares with slippage protection\n    /// @param roller AutoRoller vault\n    /// @param shares Number of shares to mint\n    /// @param receiver Destination address for the returned shares\n    /// @param maxAmountIn Maximum amount of assets pulled from msg.sender\n    /// @return assets Amount of asset pulled from msg.sender and used to mint vault shares\n    function mintFromTarget(AutoRoller roller, uint256 shares, address receiver, uint256 maxAmountIn, PermitData calldata permit) external returns (uint256 assets) {\n        _transferFrom(permit, address(roller.asset()), roller.previewMint(shares));\n\n        if ((assets = roller.mint(shares, receiver)) > maxAmountIn) {\n            revert MaxAssetError();\n        }\n    }\n\n    /// @notice Convert underlying to asset and mint vault shares with slippage protection\n    /// @param roller AutoRoller vault\n    /// @param shares Number of shares to mint\n    /// @param receiver Destination address for the returned shares\n    /// @param maxAmountIn Maximum amount of underlying pulled from msg.sender\n    /// @return underlyingIn Amount of underlying pulled from msg.sender and used to mint vault shares\n    function mintFromUnderlying(AutoRoller roller, uint256 shares, address receiver, uint256 maxAmountIn, PermitData calldata permit) external returns (uint256 underlyingIn) {\n        AdapterLike adapter = AdapterLike(address(roller.adapter()));\n\n        _transferFrom(permit, adapter.underlying(), underlyingIn = roller.previewMint(shares).mulWadUp(adapter.scale()));\n\n        adapter.wrapUnderlying(underlyingIn); // convert underlying to asset\n\n        uint256 assetIn = roller.mint(shares, receiver);\n        if ((underlyingIn = assetIn.mulWadDown(adapter.scale())) > maxAmountIn) {\n            revert MaxUnderlyingError();\n        }\n    }\n\n    /// @notice Convert token to asset and deposit into vault with slippage protection\n    /// @param roller AutoRoller vault\n    /// @param tokenIn Amount of token pulled from msg.sender and used to mint vault shares\n    /// @param receiver Destination address for the returned shares\n    /// @param minSharesOut Minimum amount of returned shares\n    /// @param permit Permit message to pull token from caller\n    /// @param quote Swap quote for converting token to underlying\n    /// @return shares Number of shares minted by the vault and returned to msg.sender\n    function deposit(AutoRoller roller, uint256 tokenIn, address receiver, uint256 minSharesOut, PermitData calldata permit, SwapQuote calldata quote) external payable returns (uint256 shares) {\n        AdapterLike adapter = AdapterLike(address(roller.adapter()));\n\n        if (address(quote.sellToken) != ETH) _transferFrom(permit, address(quote.sellToken), tokenIn);\n        uint256 toTarget = _toTarget(address(adapter), tokenIn, quote);\n        if ((shares = roller.deposit(toTarget, receiver)) < minSharesOut) {\n            revert MinSharesError();\n        }\n    }\n\n    /// @notice Quick exit into the constituent assets with slippage protection\n    /// @param roller AutoRoller vault.\n    /// @param shares Number of shares to eject with.\n    /// @param receiver Destination address for the constituent assets.\n    /// @param minAssetsOut Minimum amount of assets returned\n    /// @param minExcessOut Minimum excess PT/YT returned\n    /// @return assets Amount of asset redeemable by the given number of shares.\n    /// @return excessBal Amount of excess PT or YT redeemable by the given number of shares.\n    /// @return isExcessPTs Whether the excess token is a YT or PT.\n    function eject(AutoRoller roller, uint256 shares, address receiver, uint256 minAssetsOut, uint256 minExcessOut)\n        external returns (uint256 assets, uint256 excessBal, bool isExcessPTs)\n    {\n        (assets, excessBal, isExcessPTs) = roller.eject(shares, receiver, msg.sender);\n\n        if (assets < minAssetsOut || excessBal < minExcessOut) {\n            revert MinAssetsOrExcessError();\n        }\n    }\n\n    function approve(ERC20 token, address to) public payable requiresTrust {\n        token.safeApprove(to, type(uint256).max);\n    }\n\n    /* ========== INTERNAL UTILS ========== */\n\n    // @dev Swaps ETH->ERC20, ERC20->ERC20 or ERC20->ETH held by this contract using a 0x-API quote\n    function _fillQuote(SwapQuote calldata quote) internal returns (uint256 boughtAmount) {\n        if (quote.sellToken == quote.buyToken) return 0; // No swap if the tokens are the same.\n        if (quote.swapTarget != exchangeProxy) revert InvalidExchangeProxy();\n\n        // Give `spender` an infinite allowance to spend this contract's `sellToken`.\n        if (address(quote.sellToken) != ETH)\n            ERC20(address(quote.sellToken)).safeApprove(quote.spender, type(uint256).max);\n\n        uint256 sellAmount = address(quote.sellToken) == ETH\n            ? address(this).balance\n            : quote.sellToken.balanceOf(address(this));\n\n        // Call the encoded swap function call on the contract at `swapTarget`,\n        // passing along any ETH attached to this function call to cover protocol fees.\n        (bool success, bytes memory res) = quote.swapTarget.call{ value: msg.value }(quote.swapCallData);\n        // if (!success) revert(_getRevertMsg(res));\n        if (!success) revert ZeroExSwapFailed(res);\n\n        // We assume the Periphery does not hold tokens so boughtAmount is always it's balance\n        boughtAmount = address(quote.buyToken) == ETH ? address(this).balance : quote.buyToken.balanceOf(address(this));\n        sellAmount =\n            sellAmount -\n            (address(quote.sellToken) == ETH ? address(this).balance : quote.sellToken.balanceOf(address(this)));\n        if (boughtAmount == 0 || sellAmount == 0) revert ZeroSwapAmt();\n\n        // Refund any unspent protocol fees (paid in ether) to the sender.\n        uint256 refundAmt = address(this).balance;\n        if (address(quote.buyToken) == ETH) refundAmt = refundAmt - boughtAmount;\n        payable(msg.sender).transfer(refundAmt);\n        emit BoughtTokens(address(quote.sellToken), address(quote.buyToken), sellAmount, boughtAmount);\n    }\n\n    /// @notice Given an amount and a quote, decides whether it needs to wrap and make a swap on 0x,\n    /// simply wrap tokens or do nothing\n    function _toTarget(\n        address adapter,\n        uint256 _amt,\n        SwapQuote calldata quote\n    ) internal returns (uint256 amt) {\n        if (address(quote.sellToken) == AdapterLike(adapter).underlying()) {\n            amt = AdapterLike(adapter).wrapUnderlying(_amt);\n        } else if (address(quote.sellToken) != AdapterLike(adapter).target()) {\n            // sell tokens for underlying and wrap into target\n            amt = AdapterLike(adapter).wrapUnderlying(_fillQuote(quote));\n        } else {\n            amt = _amt;\n        }\n    }\n\n    /// @notice Given an amount and a quote, decides whether it needs to unwrap and make a swap on 0x,\n    /// simply unwrap tokens or do nothing\n    /// @dev when using zaps, the amount of underlying to swap for quote.buyToken (on 0x) is calculated off-chain\n    function _fromTarget(\n        address adapter,\n        uint256 _amt,\n        SwapQuote calldata quote\n    ) internal returns (uint256 amt) {\n        if (address(quote.buyToken) == AdapterLike(adapter).underlying()) {\n            amt = AdapterLike(adapter).unwrapTarget(_amt);\n        } else if (address(quote.buyToken) != AdapterLike(adapter).target()) {\n            AdapterLike(adapter).unwrapTarget(_amt);\n            // sell underlying for quote.buyToken\n            amt = _fillQuote(quote);\n        } else {\n            amt = _amt;\n        }\n    }\n    \n    function _transferFrom(\n        PermitData calldata permit,\n        address token,\n        uint256 amt\n    ) internal {\n        // Generate calldata for a standard safeTransferFrom call.\n        bytes memory inputData = abi.encodeCall(ERC20.transferFrom, (msg.sender, address(this), amt));\n\n        bool success; // Call the token contract as normal, capturing whether it succeeded.\n        assembly {\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(eq(mload(0), 1), iszero(returndatasize())),\n                // Counterintuitively, this call() must be positioned after the or() in the\n                // surrounding and() because and() evaluates its arguments from right to left.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the first slot of scratch space.\n                call(gas(), token, 0, add(inputData, 32), mload(inputData), 0, 32)\n            )\n        }\n\n        // We'll fall back to using Permit2 if calling transferFrom on the token directly reverted.\n        if (!success)\n            permit2.permitTransferFrom(\n                permit.msg,\n                IPermit2.SignatureTransferDetails({ to: address(this), requestedAmount: amt }),\n                msg.sender,\n                permit.sig\n            );\n    }\n\n    function _transferRemainingUnderlying(AutoRoller roller, address receiver) internal {\n        // transfer any remaining underlying to receiver\n        ERC20 underlying = ERC20(roller.adapter().underlying());\n        uint256 remaining = underlying.balanceOf(address(this));\n        if (remaining > 0) underlying.safeTransfer(receiver, remaining);\n    }\n\n    // required for refunds\n    receive() external payable {}\n\n    /* ========== LOGS ========== */\n\n    event BoughtTokens(\n        address indexed sellToken,\n        address indexed buyToken,\n        uint256 sellAmount,\n        uint256 indexed boughtAmount\n    );\n}"
    },
    {
      "filename": "sense-v1/pkg/core/src/Periphery.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// External references\nimport { ERC20 } from \"solmate/tokens/ERC20.sol\";\nimport { SafeTransferLib } from \"solmate/utils/SafeTransferLib.sol\";\nimport { FixedMath } from \"./external/FixedMath.sol\";\nimport { BalancerVault, IAsset } from \"./external/balancer/Vault.sol\";\nimport { BalancerPool } from \"./external/balancer/Pool.sol\";\nimport { IERC3156FlashBorrower } from \"./external/flashloan/IERC3156FlashBorrower.sol\";\nimport { IPermit2 } from \"@sense-finance/v1-core/external/IPermit2.sol\";\n\n// Internal references\nimport { Errors } from \"@sense-finance/v1-utils/libs/Errors.sol\";\nimport { Levels } from \"@sense-finance/v1-utils/libs/Levels.sol\";\nimport { Trust } from \"@sense-finance/v1-utils/Trust.sol\";\nimport { BaseAdapter as Adapter } from \"./adapters/abstract/BaseAdapter.sol\";\nimport { BaseFactory as AdapterFactory } from \"./adapters/abstract/factories/BaseFactory.sol\";\nimport { Divider } from \"./Divider.sol\";\n\ninterface SpaceFactoryLike {\n    function create(address, uint256) external returns (address);\n\n    function pools(address adapter, uint256 maturity) external view returns (address);\n}\n\n/// @title Periphery\ncontract Periphery is Trust, IERC3156FlashBorrower {\n    using FixedMath for uint256;\n    using SafeTransferLib for ERC20;\n    using Levels for uint256;\n\n    /* ========== PUBLIC CONSTANTS ========== */\n\n    /// @notice Lower bound on the amount of Claim tokens one can swap in for Target\n    uint256 public constant MIN_YT_SWAP_IN = 0.000001e18;\n\n    /// @notice Acceptable error when estimating the tokens resulting from a specific swap\n    uint256 public constant PRICE_ESTIMATE_ACCEPTABLE_ERROR = 0.00000001e18;\n\n    /// @notice ETH address\n    address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /* ========== PUBLIC IMMUTABLES ========== */\n\n    /// @notice Sense core Divider address\n    Divider public immutable divider;\n\n    /// @notice Sense core Divider address\n    BalancerVault public immutable balancerVault;\n\n    /// @notice Permit2 contract\n    IPermit2 public immutable permit2;\n\n    // 0x ExchangeProxy address. See https://docs.0x.org/developer-resources/contract-addresses\n    address public immutable exchangeProxy;\n\n    /* ========== PUBLIC MUTABLE STORAGE ========== */\n\n    /// @notice Sense core Divider address\n    SpaceFactoryLike public spaceFactory;\n\n    /// @notice adapter factories -> is supported\n    mapping(address => bool) public factories;\n\n    /// @notice adapter -> bool\n    mapping(address => bool) public verified;\n\n    /* ========== DATA STRUCTURES ========== */\n\n    struct PoolLiquidity {\n        ERC20[] tokens;\n        uint256[] amounts;\n        uint256 minBptOut;\n    }\n\n    struct PermitData {\n        IPermit2.PermitTransferFrom msg;\n        bytes sig;\n    }\n\n    struct PermitBatchData {\n        IPermit2.PermitBatchTransferFrom msg;\n        bytes sig;\n    }\n\n    struct SwapQuote {\n        ERC20 sellToken;\n        ERC20 buyToken;\n        address spender;\n        address payable swapTarget;\n        bytes swapCallData;\n    }\n\n    constructor(\n        address _divider,\n        address _spaceFactory,\n        address _balancerVault,\n        address _permit2,\n        address _exchangeProxy\n    ) Trust(msg.sender) {\n        divider = Divider(_divider);\n        spaceFactory = SpaceFactoryLike(_spaceFactory);\n        balancerVault = BalancerVault(_balancerVault);\n        permit2 = IPermit2(_permit2);\n        exchangeProxy = _exchangeProxy;\n    }\n\n    /* ========== SERIES / ADAPTER MANAGEMENT ========== */\n\n    /// @notice Sponsor a new Series in any adapter previously onboarded onto the Divider\n    /// @dev Called by an external address, initializes a new series in the Divider\n    /// @param adapter Adapter to associate with the Series\n    /// @param maturity Maturity date for the Series, in units of unix time\n    /// @param withPool Whether to deploy a Space pool or not (only works for unverified adapters)\n    function sponsorSeries(\n        address adapter,\n        uint256 maturity,\n        bool withPool,\n        PermitData calldata permit,\n        SwapQuote calldata quote\n    ) external payable returns (address pt, address yt) {\n        (, address stake, uint256 stakeSize) = Adapter(adapter).getStakeAndTarget();\n        if (address(quote.sellToken) != ETH) _transferFrom(permit, stake, stakeSize);\n        if (address(quote.sellToken) != stake) _fillQuote(quote);\n\n        // Approve divider to withdraw stake assets\n        ERC20(stake).safeApprove(address(divider), stakeSize);\n\n        (pt, yt) = divider.initSeries(adapter, maturity, msg.sender);\n\n        // Space pool is always created for verified adapters whilst is optional for unverified ones.\n        // Automatically queueing series is only for verified adapters\n        if (verified[adapter]) {\n            spaceFactory.create(adapter, maturity);\n        } else {\n            if (withPool) {\n                spaceFactory.create(adapter, maturity);\n            }\n        }\n\n        // Refund any excess stake assets\n        ERC20(stake).safeTransfer(msg.sender, ERC20(stake).balanceOf(address(this)));\n\n        emit SeriesSponsored(adapter, maturity, msg.sender);\n    }\n\n    /// @notice Deploy and onboard a Adapter\n    /// @dev Called by external address, deploy a new Adapter via an Adapter Factory\n    /// @param f Factory to use\n    /// @param target Target to onboard\n    /// @param data Additional encoded data needed to deploy the adapter\n    function deployAdapter(\n        address f,\n        address target,\n        bytes calldata data\n    ) external returns (address adapter) {\n        if (!factories[f]) revert Errors.FactoryNotSupported();\n        adapter = AdapterFactory(f).deployAdapter(target, data);\n        emit AdapterDeployed(adapter);\n        _verifyAdapter(adapter);\n        _onboardAdapter(adapter, true);\n    }\n\n    /* ========== LIQUIDITY UTILS ========== */\n\n    /// @notice Swap for PTs of a particular series\n    /// @param adapter Adapter address for the Series\n    /// @param maturity Maturity date for the Series\n    /// @param amt Amount to swap for PTs\n    /// @param minAccepted Min accepted amount of PT\n    /// @param receiver Address to receive the PT\n    /// @param permit Permit to pull the tokens to swap from\n    /// @param quote Quote with swap details\n    /// @dev if quote.sellToken is neither target nor underlying, it will be swapped for underlying\n    /// on 0x and wrapped into the target\n    /// @return ptBal amount of PT received\n    function swapForPTs(\n        address adapter,\n        uint256 maturity,\n        uint256 amt,\n        uint256 minAccepted,\n        address receiver,\n        PermitData calldata permit,\n        SwapQuote calldata quote\n    ) external payable returns (uint256 ptBal) {\n        if (address(quote.sellToken) != ETH) _transferFrom(permit, address(quote.sellToken), amt);\n        return _swapTargetForPTs(adapter, maturity, _toTarget(adapter, amt, quote), minAccepted, receiver);\n    }\n\n    /// @notice Swap to YTs of a particular series\n    /// @param adapter Adapter address for the Series\n    /// @param maturity Maturity date for the Series\n    /// @param amt Amount to sell\n    /// @param targetToBorrow Amount of Target to borrow\n    /// @param minAccepted Min accepted amount of YT\n    /// @param receiver Address to receive the YT\n    /// @param permit Permit to pull the tokens to swap from\n    /// @param quote Quote with swap details\n    /// @return targetBal amount of Target sent back\n    /// @return ytBal amount of YT received\n    /// @dev if quote.sellToken is neither target nor underlying, it will be swapped for underlying\n    /// on 0x and wrapped into the target\n    function swapForYTs(\n        address adapter,\n        uint256 maturity,\n        uint256 amt,\n        uint256 targetToBorrow,\n        uint256 minAccepted,\n        address receiver,\n        PermitData calldata permit,\n        SwapQuote calldata quote\n    ) external payable returns (uint256 targetBal, uint256 ytBal) {\n        if (address(quote.sellToken) != ETH) _transferFrom(permit, address(quote.sellToken), amt);\n\n        // swap sellToken to target, borrow more target and swap to YTs\n        (targetBal, ytBal) = _flashBorrowAndSwapToYTs(\n            adapter,\n            maturity,\n            _toTarget(adapter, amt, quote),\n            targetToBorrow,\n            minAccepted\n        );\n\n        ERC20(Adapter(adapter).target()).safeTransfer(receiver, targetBal);\n        ERC20(divider.yt(adapter, maturity)).safeTransfer(receiver, ytBal);\n    }\n\n    /// @notice Swap PTs of a particular series\n    /// @param adapter Adapter address for the series\n    /// @param maturity Maturity date for the series\n    /// @param ptBal Balance of PT to sell\n    /// @param minAccepted Min accepted amount of tokens when selling them on Space\n    /// @param receiver Address to receive the tokens\n    /// @param permit Permit to pull PTs\n    /// @param quote Quote with swap details\n    /// @return amt amount of tokens received\n    /// @dev if quote.buyToken is neither target nor underlying, it will unwrap target\n    /// and swap it on 0x\n    function swapPTs(\n        address adapter,\n        uint256 maturity,\n        uint256 ptBal,\n        uint256 minAccepted,\n        address receiver,\n        PermitData calldata permit,\n        SwapQuote calldata quote\n    ) external returns (uint256 amt) {\n        amt = _swapSenseToken(adapter, maturity, ptBal, minAccepted, 0, receiver, permit, quote);\n    }\n\n    /// @notice Swap YTs of a particular series\n    /// @param adapter Adapter address for the Series\n    /// @param maturity Maturity date for the Series\n    /// @param ytBal Balance of YTs to swap\n    /// @param minAccepted Min accepted amount of tokens when selling them on Space\n    /// @param receiver Address to receive the Target\n    /// @param permit Permit to pull YTs\n    /// @param quote Quote with swap details\n    /// @return amt amount of Target received\n    /// @dev if quote.buyToken is neither target nor underlying, it will unwrap target\n    /// and swap it on 0x\n    function swapYTs(\n        address adapter,\n        uint256 maturity,\n        uint256 ytBal,\n        uint256 minAccepted,\n        address receiver,\n        PermitData calldata permit,\n        SwapQuote calldata quote\n    ) external returns (uint256 amt) {\n        amt = _swapSenseToken(adapter, maturity, ytBal, minAccepted, 1, receiver, permit, quote);\n    }\n\n    function swapYTsForTarget(\n        address adapter,\n        uint256 maturity,\n        uint256 ytBal\n    ) external returns (uint256 amt) {\n        if (msg.sender != adapter) revert Errors.OnlyAdapter();\n        PermitData memory permit = PermitData(\n            IPermit2.PermitTransferFrom(IPermit2.TokenPermissions(ERC20(address(0)), 0), 0, 0),\n            \"0x\"\n        );\n        amt = this._swapYTsForTarget(msg.sender, adapter, maturity, ytBal, permit);\n    }\n\n    function _swapSenseToken(\n        address adapter,\n        uint256 maturity,\n        uint256 sellAmt,\n        uint256 minAccepted,\n        uint8 mode, // 0 = PTs, 1 = YTs\n        address receiver,\n        PermitData calldata permit,\n        SwapQuote calldata quote\n    ) private returns (uint256 amt) {\n        amt = (mode == 1)\n            ? _swapYTsForTarget(msg.sender, adapter, maturity, sellAmt, permit)\n            : _swapPTsForTarget(adapter, maturity, sellAmt, permit);\n        amt = _fromTarget(adapter, amt, quote);\n\n        if (amt < minAccepted) revert Errors.UnexpectedSwapAmount();\n        _transfer(quote.buyToken, receiver, amt);\n\n        // transfer any remaining underlying to receiver\n        ERC20 underlying = ERC20(Adapter(adapter).underlying());\n        uint256 remaining = underlying.balanceOf(address(this));\n        if (remaining > 0) underlying.safeTransfer(receiver, remaining);\n    }\n\n    /// @notice Adds liquidity providing any Token\n    /// @param adapter Adapter address for the Series\n    /// @param maturity Maturity date for the Series\n    /// @param amt Amount to provide\n    /// @param mode 0 = issues and sell YT, 1 = issue and hold YT\n    /// @param minAccepted Min accepted amount of Target (from the sell of YTs)\n    /// @param minBptOut Minimum BPT the user will accept out for this transaction\n    /// @param receiver Address to receive the BPT\n    /// @param permit Permit to pull the tokens to swap from\n    /// @param quote Quote with swap details\n    /// @dev see return description of _addLiquidity\n    /// @dev if quote.sellToken is neither target nor underlying, it will be swapped for underlying\n    /// on 0x and wrapped into the target\n    function addLiquidity(\n        address adapter,\n        uint256 maturity,\n        uint256 amt,\n        uint256 minAccepted,\n        uint256 minBptOut,\n        uint8 mode,\n        address receiver,\n        PermitData calldata permit,\n        SwapQuote calldata quote\n    )\n        external\n        payable\n        returns (\n            uint256 tAmount,\n            uint256 issued,\n            uint256 lpShares\n        )\n    {\n        if (address(quote.sellToken) != ETH) _transferFrom(permit, address(quote.sellToken), amt);\n        (tAmount, issued, lpShares) = _addLiquidity(\n            adapter,\n            maturity,\n            _toTarget(adapter, amt, quote),\n            minAccepted,\n            minBptOut,\n            mode,\n            receiver,\n            permit\n        );\n    }\n\n    /// @notice Removes liquidity providing an amount of LP tokens and returns underlying\n    /// @dev More info on `minAmountsOut`: https://github.com/balancer-labs/docs-developers/blob/main/resources/joins-and-exits/pool-exits.md#minamountsout\n    /// @param adapter Adapter address for the Series\n    /// @param maturity Maturity date for the Series\n    /// @param lpBal Balance of LP tokens to provide\n    /// @param minAmountsOut minimum accepted amounts of PTs and Target given the amount of LP shares provided\n    /// @param minAccepted only used when removing liquidity on/after maturity and its the min accepted when swapping PTs to underlying\n    /// @param receiver Address to receive the Underlying\n    /// @param permit Permit to pull the LP tokens\n    /// @param quote Quote with swap details\n    /// @return amt amount of tokens received and ptBal PTs (in case it's called after maturity and redeem is restricted or intoTarget is false)\n    /// @dev if quote.buyToken is neither target nor underlying, it will unwrap target\n    /// and swap it on 0x\n    /// if quote.buyToken is PT, it will return target and PTs\n    function removeLiquidity(\n        address adapter,\n        uint256 maturity,\n        uint256 lpBal,\n        uint256[] memory minAmountsOut,\n        uint256 minAccepted,\n        bool swapPTs,\n        address receiver,\n        PermitData calldata permit,\n        SwapQuote calldata quote\n    ) external returns (uint256 amt, uint256 ptBal) {\n        (amt, ptBal) = _removeLiquidity(\n            adapter,\n            maturity,\n            lpBal,\n            minAmountsOut,\n            minAccepted,\n            swapPTs,\n            receiver,\n            permit\n        );\n        amt = _fromTarget(adapter, amt, quote);\n        _transfer(quote.buyToken, receiver, amt);\n    }\n\n    /* ========== UTILS ========== */\n\n    /// @notice Mint PTs & YTs of a specific Series\n    /// @param adapter Adapter address for the Series\n    /// @param maturity Maturity date for the Series [unix time]\n    /// @param amt Amount to issue with\n    /// @dev The balance of PTs and YTs minted will be the same value in units of underlying (less fees)\n    /// @param receiver Address where the resulting PTs and YTs will be transferred to\n    /// @param permit Permit to pull tokens\n    /// @param quote Quote with swap details\n    /// @return uBal Amount of PTs and YTs minted\n    /// @dev if quote.sellToken is neither target nor underlying, it will swap on 0x and wrap to target\n    /// and swap it on 0x\n    function issue(\n        address adapter,\n        uint256 maturity,\n        uint256 amt,\n        address receiver,\n        PermitData calldata permit,\n        SwapQuote calldata quote\n    ) external returns (uint256 uBal) {\n        if (address(quote.sellToken) != ETH) _transferFrom(permit, address(quote.sellToken), amt);\n        uBal = divider.issue(adapter, maturity, _toTarget(adapter, amt, quote));\n        ERC20(divider.pt(adapter, maturity)).transfer(receiver, uBal); // Send PTs to the receiver\n        ERC20(divider.yt(adapter, maturity)).transfer(receiver, uBal); // Send YT to the receiver"
    }
  ]
}