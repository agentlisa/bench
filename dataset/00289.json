{
  "Title": "Optimize the `TrimmedAmount` struct as a bit-packed `uint72` user-defined type",
  "Content": "The existing [`TrimmedAmount`](https://github.com/wormhole-foundation/example-native-token-transfers/blob/f4e2277b358349dbfb8a654d19a925628d48a8af/evm/src/libraries/TrimmedAmount.sol#L5-L8) abstraction has a [runtime gas overhead](https://soliditylang.org/blog/2021/09/27/user-defined-value-types/) due to allocation of the struct:\n```solidity\nstruct TrimmedAmount {\n    uint64 amount;\n    uint8 decimals;\n}\n```\n\nThis could be mitigated by instead implementing a user-defined type that is a bit-packed `uint72` representation of a token amount and its decimals. The use of a `uint72` type ensures that the existing width of 9 bytes is maintained, which allows for tight packing elsewhere in storage, such as in the `RateLimitParams` struct:\n```solidity\nstruct RateLimitParams {\n        TrimmedAmount limit;\n        TrimmedAmount currentCapacity;\n        uint64 lastTxTimestamp;\n    }\n```\ntherefore keeping this definition contained within a single word.\n\nDespite the non-trivial refactoring effort required, a user-defined value type is advantageous here as it would allow for the trimmed amounts to be stack-allocated and arithmetic operators to be overloaded.\n\n**Wormhole Foundation:** Fixed in [PR \\#248](https://github.com/wormhole-foundation/example-native-token-transfers/pull/248).\n\n**Cyfrin:** Verified. Some comments are incorrect, and further small optimizations could be made, but otherwise appears correct.",
  "Impact": "GAS",
  "Source": "",
  "Code": [
    {
      "filename": "evm/src/libraries/TrimmedAmount.sol",
      "content": "// SPDX-License-Identifier: Apache 2\n/// @dev TrimmedAmount is a utility library to handle token amounts with different decimals\npragma solidity >=0.8.8 <0.9.0;\n\nstruct TrimmedAmount {\n    uint64 amount;\n    uint8 decimals;\n}\n\nfunction minUint8(uint8 a, uint8 b) pure returns (uint8) {\n    return a < b ? a : b;\n}\n\nlibrary TrimmedAmountLib {\n    uint8 constant TRIMMED_DECIMALS = 8;\n\n    error AmountTooLarge(uint256 amount);\n    error NumberOfDecimalsNotEqual(uint8 decimals, uint8 decimalsOther);\n\n    function unwrap(TrimmedAmount memory a) internal pure returns (uint64, uint8) {\n        return (a.amount, a.decimals);\n    }\n\n    function getAmount(TrimmedAmount memory a) internal pure returns (uint64) {\n        return a.amount;\n    }\n\n    function getDecimals(TrimmedAmount memory a) internal pure returns (uint8) {\n        return a.decimals;\n    }\n\n    function eq(TrimmedAmount memory a, TrimmedAmount memory b) internal pure returns (bool) {\n        return a.amount == b.amount && a.decimals == b.decimals;\n    }\n\n    function gt(TrimmedAmount memory a, TrimmedAmount memory b) internal pure returns (bool) {\n        if (a.decimals != b.decimals) {\n            revert NumberOfDecimalsNotEqual(a.decimals, b.decimals);\n        }\n\n        return a.amount > b.amount;\n    }\n\n    function lt(TrimmedAmount memory a, TrimmedAmount memory b) internal pure returns (bool) {\n        if (a.decimals != b.decimals) {\n            revert NumberOfDecimalsNotEqual(a.decimals, b.decimals);\n        }\n\n        return a.amount < b.amount;\n    }\n\n    function isNull(TrimmedAmount memory a) internal pure returns (bool) {\n        return (a.amount == 0 && a.decimals == 0);\n    }\n\n    function sub(\n        TrimmedAmount memory a,\n        TrimmedAmount memory b\n    ) internal pure returns (TrimmedAmount memory) {\n        if (a.decimals != b.decimals) {\n            revert NumberOfDecimalsNotEqual(a.decimals, b.decimals);\n        }\n\n        return TrimmedAmount(a.amount - b.amount, a.decimals);\n    }\n\n    function add(\n        TrimmedAmount memory a,\n        TrimmedAmount memory b\n    ) internal pure returns (TrimmedAmount memory) {\n        if (a.decimals != b.decimals) {\n            revert NumberOfDecimalsNotEqual(a.decimals, b.decimals);\n        }\n        return TrimmedAmount(a.amount + b.amount, a.decimals);\n    }\n\n    function saturatingAdd(\n        TrimmedAmount memory a,\n        TrimmedAmount memory b\n    ) internal pure returns (TrimmedAmount memory) {\n        if (a.decimals != b.decimals) {\n            revert NumberOfDecimalsNotEqual(a.decimals, b.decimals);\n        }\n\n        uint256 saturatedSum;\n        unchecked {\n            saturatedSum = uint256(a.amount) + uint256(b.amount);\n            saturatedSum = saturatedSum > type(uint64).max ? type(uint64).max : saturatedSum;\n        }\n        return TrimmedAmount(uint64(saturatedSum), a.decimals);\n    }\n\n    function min(\n        TrimmedAmount memory a,\n        TrimmedAmount memory b\n    ) public pure returns (TrimmedAmount memory) {\n        if (a.decimals != b.decimals) {\n            revert NumberOfDecimalsNotEqual(a.decimals, b.decimals);\n        }\n\n        return a.amount < b.amount ? a : b;\n    }\n\n    /// @dev scale the amount from original decimals to target decimals (base 10)\n    function scale(\n        uint256 amount,\n        uint8 fromDecimals,\n        uint8 toDecimals\n    ) internal pure returns (uint256) {\n        if (fromDecimals == toDecimals) {\n            return amount;\n        }\n\n        if (fromDecimals > toDecimals) {\n            return amount / (10 ** (fromDecimals - toDecimals));\n        } else {\n            return amount * (10 ** (toDecimals - fromDecimals));\n        }\n    }\n\n    function shift(\n        TrimmedAmount memory amount,\n        uint8 toDecimals\n    ) internal pure returns (TrimmedAmount memory) {\n        uint8 actualToDecimals = minUint8(TRIMMED_DECIMALS, toDecimals);\n        return TrimmedAmount(\n            uint64(scale(amount.amount, amount.decimals, actualToDecimals)), actualToDecimals\n        );\n    }\n\n    function max(uint8 decimals) internal pure returns (TrimmedAmount memory) {\n        uint8 actualDecimals = minUint8(TRIMMED_DECIMALS, decimals);\n        return TrimmedAmount(type(uint64).max, actualDecimals);\n    }\n\n    /// @dev trim the amount to target decimals.\n    ///      The actual resulting decimals is the minimum of TRIMMED_DECIMALS,\n    ///      fromDecimals, and toDecimals. This ensures that no dust is\n    ///      destroyed on either side of the transfer.\n    /// @param amt the amount to be trimmed\n    /// @param fromDecimals the original decimals of the amount\n    /// @param toDecimals the target decimals of the amount\n    ///\n    function trim(\n        uint256 amt,\n        uint8 fromDecimals,\n        uint8 toDecimals\n    ) internal pure returns (TrimmedAmount memory) {\n        uint8 actualToDecimals = minUint8(minUint8(TRIMMED_DECIMALS, fromDecimals), toDecimals);\n        uint256 amountScaled = scale(amt, fromDecimals, actualToDecimals);\n\n        // NOTE: amt after trimming must fit into uint64 (that's the point of\n        // trimming, as Solana only supports uint64 for token amts)\n        if (amountScaled > type(uint64).max) {\n            revert AmountTooLarge(amt);\n        }\n        return TrimmedAmount(uint64(amountScaled), actualToDecimals);\n    }\n\n    function untrim(TrimmedAmount memory amt, uint8 toDecimals) internal pure returns (uint256) {\n        (uint256 deNorm, uint8 fromDecimals) = unwrap(amt);\n        uint256 amountScaled = scale(deNorm, fromDecimals, toDecimals);\n\n        return amountScaled;\n    }\n}"
    }
  ]
}