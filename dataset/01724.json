{
  "Title": "M-1: ChainlinkAggregator: binary search for roundId does not work correctly and Oracle can even end up temporarily DOSed",
  "Content": "# Issue M-1: ChainlinkAggregator: binary search for roundId does not work correctly and Oracle can even end up temporarily DOSed \n\nSource: https://github.com/sherlock-audit/2023-05-perennial-judging/issues/4 \n\n## Found by \nroguereddwarf\n## Summary\nWhen a phase switchover occurs, it can be necessary that phases need to be searched for a `roundId` with a timestamp as close as possible but bigger than `targetTimestamp`.\n\nFinding the `roundId` with the closest possible timestamp is necessary according to the sponsor to minimize the delay of position changes:\n\n![2023-05-25_13-55](https://github.com/roguereddwarf/images/assets/118631472/0eb0a93b-1a5e-41b2-91c4-884a51aed432)\n\nThe binary search algorithm is not able to find this best `roundId` which thereby causes unintended position changes.\n\nAlso it can occur that the `ChainlinkAggregator` library is unable to find a valid `roundId` at all (as opposed to only not finding the \"best\").\n\nThis would cause the Oracle to be temporarily DOSed until there are more valid rounds.\n\n## Vulnerability Detail\nLet's look at the binary search algorithm:\nhttps://github.com/sherlock-audit/2023-05-perennial/blob/main/perennial-mono/packages/perennial-oracle/contracts/types/ChainlinkAggregator.sol#L123-L156\n\nThe part that we are particularly interested in is:\nhttps://github.com/sherlock-audit/2023-05-perennial/blob/main/perennial-mono/packages/perennial-oracle/contracts/types/ChainlinkAggregator.sol#L139-L149\n\nLet's say in a phase there's only one valid round (`roundId=1`) and the timestamp for this round is greater than `targetTimestamp`\n\nWe would expect the `roundId` that the binary search finds to be `roundId=1`.\n\nThe binary search loop is executed with `minRoundId=1` and `maxRoundId=1001`.\n\nAll the above conditions can easily occur in reality, they represent the basic scenario under which this algorithm executes.\n\n`minRoundId` and `maxRoundId` change like this in the iterations of the loop:\n\n```text\nminRoundId=1\nmaxRoundId=1001\n\n-> \n\nminRoundId=1\nmaxRoundId=501\n\n-> \n\nminRoundId=1\nmaxRoundId=251\n\n-> \n\nminRoundId=1\nmaxRoundId=126\n\n-> \n\nminRoundId=1\nmaxRoundId=63\n\n-> \n\nminRoundId=1\nmaxRoundId=32\n\n-> \n\nminRoundId=1\nmaxRoundId=16\n\n-> \n\nminRoundId=1\nmaxRoundId=8\n\n-> \n\nminRoundId=1\nmaxRoundId=4\n\n-> \n\nminRoundId=1\nmaxRoundId=2\n\nNow the loop terminates because\nminRoundId + 1 !< maxRoundId\n\n```\n\nSince we assumed that `roundId=2` is invalid, the function returns `0` (`maxTimestamp=type(uint256).max`):\n\nhttps://github.com/sherlock-audit/2023-05-perennial/blob/main/perennial-mono/packages/perennial-oracle/contracts/types/ChainlinkAggregator.sol#L153-L155\n\nIn the case that `latestRound.roundId` is equal to the `roundId=1`  (i.e. same phase and same round id which could not be found) there would be no other valid rounds that the `ChainlinkAggregator` can find which causes a temporary DOS.\n\n## Impact\nAs explained above this would result in sub-optimal and unintended position changes in the best case.\nIn the worst-case the Oracle can be temporarily DOSed, unable to find a valid `roundId`.\n\nThis means that users cannot interact with the perennial protocol because the Oracle cannot be synced.\nSo they cannot close losing trades which is a loss of funds.\n\nThe DOS can occur since the while loop searching the phases does not terminate:\nhttps://github.com/sherlock-audit/2023-05-perennial/blob/main/perennial-mono/packages/perennial-oracle/contracts/types/ChainlinkAggregator.sol#L88-L91\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-perennial/blob/main/perennial-mono/packages/perennial-oracle/contracts/types/ChainlinkAggregator.sol#L123-L149\n\n## Tool used\nManual Review\n\n## Recommendation\nI recommend to add a check if `minRoundId` is a valid solution for the binary search.\nIf it is, `minRoundId` should be used to return the result instead of `maxRoundId`:\n\n```diff\n         // If the found timestamp is not greater than target timestamp or no max was found, then the desired round does\n         // not exist in this phase\n-        if (maxTimestamp <= targetTimestamp || maxTimestamp == type(uint256).max) return 0;\n+        if ((minTimestamp <= targetTimestamp || minTimestamp == type(uint256).max) && (maxTimestamp <= targetTimestamp || maxTimestamp == type(uint256).max)) return 0;\n \n+        if (minTimestamp > targetTimestamp) {\n+            return _aggregatorRoundIdToProxyRoundId(phaseId, uint80(minRoundId));\n+        }\n         return _aggregatorRoundIdToProxyRoundId(phaseId, uint80(maxRoundId));\n     }\n```\n\nAfter applying the changes, the binary search only returns `0` if both `minRoundId` and `maxRoundId` are not a valid result.\n\nIf this line is passed we know that either of both is valid and we can use `minRoundId` if it is the better result.\n\n\n\n## Discussion\n\n**roguereddwarf**\n\nEscalate for 10 USDC\n\nI think this should be a \"High\" severity finding.\nThe binary search lies at the core of the protocol.\nAll functionality for users to open / close trades and liquidations relies on the Chainlink oracle.\n\nBy not finding a valid `roundId` obviously many users are put at risk of losing funds (-> not being able to close trades).\n\nSimilarly when an unintended (i.e. sub-optimal) `roundId` is found this leads to a similar scenario where settlements / liquidations occur at unintended prices.\n\nIn summary, the fact that the binary search algorithm lies at the core of the protocol and there is a very direct loss of funds makes me think this should be \"High\" severity.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> I think this should be a \"High\" severity finding.\n> The binary search lies at the core of the protocol.\n> All functionality for users to open / close trades and liquidations relies on the Chainlink oracle.\n> \n> By not finding a valid `roundId` obviously many users are put at risk of losing funds (-> not being able to close trades).\n> \n> Similarly when an unintended (i.e. sub-optimal) `roundId` is found this leads to a similar scenario where settlements / liquidations occur at unintended prices.\n> \n> In summary, the fact that the binary search algorithm lies at the core of the protocol and there is a very direct loss of funds makes me think this should be \"High\" severity.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**securitygrid**\n\nComment from watson:\n[Chainlink: ETH/USD](https://etherscan.io/address/0x5f4ec3df9cbd43714fe2740f5e3616155c5b8419#readContract) has been deployed for 3 years, and the current phaseID is only 6. The binary search is only triggered when [this condition](https://github.com/sherlock-audit/2023-05-perennial/blob/main/perennial-mono/packages/perennial-oracle/contracts/ChainlinkFeedOracle.sol#L117) is met, that is, when a new phaseID is generated. This is infrequent.\nThis is from the [chainlink docs](https://docs.chain.link/data-feeds/historical-data#roundid-in-proxy): `phaseId` is incremented each time the underlying aggregator implementation is updated.\n\n**KenzoAgada**\n\nThe issue is dependent upon a Chainlink changing of phase (which is quite infrequent) and the new phase having only 1 round.\nThe impact as stated in the finding is that in those conditions, the product flywheel is jammed until further rounds are issued. (Then, the algorithm will correctly return round 2.)\nSo the impact is only very temporary and rare DOS (which can impact user funds).\n\nI think escalation is invalid and medium severity is appropriate.\n\n**arjun-io**\n\nTo add here - the binary search is also a backup solution to simply checking if roundId + 1 exists in the previous phase ([code](https://github.com/sherlock-audit/2023-05-perennial/blob/main/perennial-mono/packages/perennial-oracle/contracts/types/ChainlinkAggregator.sol#L70)). So additionally the last seen round in the previous phase has to be the very last roundID in that phase\n\n**jacksanford1**\n\nAgree with Medium due to Kenzo's reasons (unlikely and temporary situation which only indirectly could result in user funds loss due to liquidations). cc @roguereddwarf \n\n**roguereddwarf**\n\nAgreed\n\n**jacksanford1**\n\nResult:\nMedium\nUnique\nUnlikely and temporary situation which only indirectly could result in user funds loss due to liquidations is part of the reason why this is not being upgraded to a High. \n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [roguereddwarf](https://github.com/sherlock-audit/2023-05-perennial-judging/issues/4/#issuecomment-1614471358): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/79",
  "Code": [
    {
      "filename": "perennial-mono/packages/perennial-oracle/contracts/types/ChainlinkAggregator.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorProxyInterface.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"./ChainlinkRound.sol\";\n\n/// @dev ChainlinkAggregator type\ntype ChainlinkAggregator is address;\nusing ChainlinkAggregatorLib for ChainlinkAggregator global;\n\n/**\n * @title ChainlinkAggregatorLib\n * @notice Library that manages interfacing with the Chainlink Feed Aggregator Proxy.\n */\nlibrary ChainlinkAggregatorLib {\n    /**\n     * @notice Returns the decimal amount for a specific feed\n     * @param self Chainlink Feed Aggregator to operate on\n     * @return Decimal amount\n     */\n    function decimals(ChainlinkAggregator self) internal view returns (uint8) {\n        return AggregatorProxyInterface(ChainlinkAggregator.unwrap(self)).decimals();\n    }\n\n    /**\n     * @notice Returns the latest round data for a specific feed\n     * @param self Chainlink Feed Aggregator to operate on\n     * @return Latest round data\n     */\n    function getLatestRound(ChainlinkAggregator self) internal view returns (ChainlinkRound memory) {\n        (uint80 roundId, int256 answer, , uint256 updatedAt, ) =\n            AggregatorProxyInterface(ChainlinkAggregator.unwrap(self)).latestRoundData();\n        return ChainlinkRound({roundId: roundId, timestamp: updatedAt, answer: answer});\n    }\n\n    /**\n     * @notice Returns a specific round's data for a specific feed\n     * @param self Chainlink Feed Aggregator to operate on\n     * @param roundId The specific round to fetch data for\n     * @return Specific round's data\n     */\n    function getRound(ChainlinkAggregator self, uint256 roundId) internal view returns (ChainlinkRound memory) {\n        (, int256 answer, , uint256 updatedAt, ) =\n            AggregatorProxyInterface(ChainlinkAggregator.unwrap(self)).getRoundData(uint80(roundId));\n        return ChainlinkRound({roundId: roundId, timestamp: updatedAt, answer: answer});\n    }\n\n\n    /**\n     * @notice Returns the round count and next phase starting round for the lastSyncedRound phase\n     * @param self Chainlink Feed Aggregator to operate on\n     * @param startingRoundId starting roundId for the aggregator proxy\n     * @param lastSyncedRoundId last synced round ID for the proxy\n     * @param latestRound latest round from the proxy\n     * @return roundCount The number of rounds in the phase\n     * @return nextPhaseId The phaseID for the next phase\n     * @return nextPhaseStartingRoundId The starting round ID for the next phase\n     */\n    function getPhaseSwitchoverData(\n        ChainlinkAggregator self,\n        uint256 startingRoundId,\n        uint256 lastSyncedRoundId,\n        ChainlinkRound memory latestRound\n    ) internal view returns (uint256 roundCount, uint16 nextPhaseId, uint256 nextPhaseStartingRoundId) {\n        AggregatorProxyInterface proxy = AggregatorProxyInterface(ChainlinkAggregator.unwrap(self));\n\n        // Try to get the immediate next round in the same phase. If this errors, we know that the phase has ended\n        try proxy.getRoundData(uint80(lastSyncedRoundId + 1)) returns (uint80 nextRoundId,int256,uint256,uint256 nextUpdatedAt,uint80) {\n            // If the next round in this phase is before the latest round, then we can safely mark that\n            // as the end of the phase, and the latestRound as the start of the new phase\n            // Else the next round in this phase is _after_ the latest round, then we\n            // fallthrough to search for the next starting round ID using the walkback logic\n            if (nextRoundId == 0 || nextUpdatedAt == 0) { // Invalid round\n                // pass\n            } else if (nextUpdatedAt < latestRound.timestamp) {\n                return ((nextRoundId - startingRoundId) + 1, latestRound.phaseId(), latestRound.roundId);\n            }\n        } catch  {\n            // pass\n        }\n\n        // lastSyncedRound is the last round in it's phase before latestRound, so we need to find where the next phase starts\n        // The next phase should start at the round that is closest to but after lastSyncedRound.timestamp\n        ChainlinkRound memory lastSyncedRound = getRound(self, lastSyncedRoundId);\n        uint16 phaseToSearch = lastSyncedRound.phaseId();\n        while (nextPhaseStartingRoundId == 0) {\n            phaseToSearch++;\n            nextPhaseStartingRoundId = getStartingRoundId(self, phaseToSearch, lastSyncedRound.timestamp);\n        }\n\n        return ((lastSyncedRoundId - startingRoundId) + 1, phaseToSearch, nextPhaseStartingRoundId);\n    }\n\n    /**\n     * @notice Returns the round ID closest to but greater than targetTimestamp for the specified phase ID\n     * @param self Chainlink Feed Aggregator to operate on\n     * @param phaseId The specific phase to fetch data for\n     * @param targetTimestamp timestamp to search for\n     * @dev Assumes the phase ends at the aggregators latestRound or earlier\n     * @return The number of rounds in the phase\n     */\n    function getStartingRoundId(ChainlinkAggregator self, uint16 phaseId, uint256 targetTimestamp)\n    internal view returns (uint256) {\n        AggregatorProxyInterface proxy = AggregatorProxyInterface(ChainlinkAggregator.unwrap(self));\n\n        (,,,uint256 startTimestamp,) = proxy.getRoundData(uint80(_aggregatorRoundIdToProxyRoundId(phaseId, 1)));\n        if (startTimestamp == 0) return 0; // Empty phase\n\n        return _search(proxy, phaseId, targetTimestamp, startTimestamp, 1);\n    }\n\n    /**\n     * Searches the given chainlink proxy for a round which has a timestamp which is as close to but greater than\n     * the `targetTimestamp`\n     * @param proxy Chainlink Proxy to search within\n     * @param phaseId Phase to search for round\n     * @param targetTimestamp Minimum timestamp value for found round\n     * @param minTimestamp Starting timestamp value\n     * @param minRoundId Starting round ID\n     */\n    function _search(AggregatorProxyInterface proxy, uint16 phaseId, uint256 targetTimestamp, uint256 minTimestamp, uint256 minRoundId) private view returns (uint256) {\n        uint256 maxRoundId = minRoundId + 1000; // Start 1000 rounds away when searching for maximum\n        uint256 maxTimestamp = _tryGetProxyRoundData(proxy, phaseId, uint80(maxRoundId));\n\n        // Find the round bounds of the phase to perform the binary search\n        while (maxTimestamp <= targetTimestamp) {\n            minRoundId = maxRoundId;\n            minTimestamp = maxTimestamp;\n            maxRoundId = maxRoundId * 2; // Find bounds of phase by multiplying the max round by 2\n            maxTimestamp = _tryGetProxyRoundData(proxy, phaseId, uint80(maxRoundId));\n        }\n\n        // Binary Search starts here. The algorithm calculates the middle round ID and finds it's timestamp\n        // If the midtimestamp is greater than target, set max to mid and continue\n        // If the midtimestamp is less than or equal to target, set min to mid and continue\n        // Exit when min + 1 is equal to or greater than max (no rounds between them)\n        while (minRoundId + 1 < maxRoundId) {\n            uint256 midRound = Math.average(minRoundId, maxRoundId);\n            uint256 midTimestamp = _tryGetProxyRoundData(proxy, phaseId, uint80(midRound));\n            if (midTimestamp > targetTimestamp) {\n                maxTimestamp = midTimestamp;\n                maxRoundId = midRound;\n            } else {\n                minTimestamp = midTimestamp;\n                minRoundId = midRound;\n            }\n        }\n\n        // If the found timestamp is not greater than target timestamp or no max was found, then the desired round does\n        // not exist in this phase\n        if (maxTimestamp <= targetTimestamp || maxTimestamp == type(uint256).max) return 0;\n\n        return _aggregatorRoundIdToProxyRoundId(phaseId, uint80(maxRoundId));\n    }\n\n    function _tryGetProxyRoundData(AggregatorProxyInterface proxy, uint16 phaseId, uint80 tryRound) private view returns (uint256) {\n        try proxy.getRoundData(uint80(_aggregatorRoundIdToProxyRoundId(phaseId, tryRound))) returns (uint80,int256,uint256,uint256 timestamp,uint80) {\n            if (timestamp > 0) return timestamp;\n        } catch  {\n            // pass\n        }\n        return type(uint256).max;\n    }\n\n    /**\n     * @notice Convert an aggregator round ID into a proxy round ID for the given phase\n     * @dev Follows the logic specified in https://docs.chain.link/data-feeds/price-feeds/historical-data#roundid-in-proxy\n     * @param phaseId phase ID for the given aggregator round\n     * @param aggregatorRoundId round id for the aggregator round\n     * @return Proxy roundId\n     */\n    function _aggregatorRoundIdToProxyRoundId(uint16 phaseId, uint80 aggregatorRoundId) private pure returns (uint256) {\n        return (uint256(phaseId) << 64) + aggregatorRoundId;\n    }\n}"
    },
    {
      "filename": "perennial-mono/packages/perennial-oracle/contracts/types/ChainlinkAggregator.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorProxyInterface.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"./ChainlinkRound.sol\";\n\n/// @dev ChainlinkAggregator type\ntype ChainlinkAggregator is address;\nusing ChainlinkAggregatorLib for ChainlinkAggregator global;\n\n/**\n * @title ChainlinkAggregatorLib\n * @notice Library that manages interfacing with the Chainlink Feed Aggregator Proxy.\n */\nlibrary ChainlinkAggregatorLib {\n    /**\n     * @notice Returns the decimal amount for a specific feed\n     * @param self Chainlink Feed Aggregator to operate on\n     * @return Decimal amount\n     */\n    function decimals(ChainlinkAggregator self) internal view returns (uint8) {\n        return AggregatorProxyInterface(ChainlinkAggregator.unwrap(self)).decimals();\n    }\n\n    /**\n     * @notice Returns the latest round data for a specific feed\n     * @param self Chainlink Feed Aggregator to operate on\n     * @return Latest round data\n     */\n    function getLatestRound(ChainlinkAggregator self) internal view returns (ChainlinkRound memory) {\n        (uint80 roundId, int256 answer, , uint256 updatedAt, ) =\n            AggregatorProxyInterface(ChainlinkAggregator.unwrap(self)).latestRoundData();\n        return ChainlinkRound({roundId: roundId, timestamp: updatedAt, answer: answer});\n    }\n\n    /**\n     * @notice Returns a specific round's data for a specific feed\n     * @param self Chainlink Feed Aggregator to operate on\n     * @param roundId The specific round to fetch data for\n     * @return Specific round's data\n     */\n    function getRound(ChainlinkAggregator self, uint256 roundId) internal view returns (ChainlinkRound memory) {\n        (, int256 answer, , uint256 updatedAt, ) =\n            AggregatorProxyInterface(ChainlinkAggregator.unwrap(self)).getRoundData(uint80(roundId));\n        return ChainlinkRound({roundId: roundId, timestamp: updatedAt, answer: answer});\n    }\n\n\n    /**\n     * @notice Returns the round count and next phase starting round for the lastSyncedRound phase\n     * @param self Chainlink Feed Aggregator to operate on\n     * @param startingRoundId starting roundId for the aggregator proxy\n     * @param lastSyncedRoundId last synced round ID for the proxy\n     * @param latestRound latest round from the proxy\n     * @return roundCount The number of rounds in the phase\n     * @return nextPhaseId The phaseID for the next phase\n     * @return nextPhaseStartingRoundId The starting round ID for the next phase\n     */\n    function getPhaseSwitchoverData(\n        ChainlinkAggregator self,\n        uint256 startingRoundId,\n        uint256 lastSyncedRoundId,\n        ChainlinkRound memory latestRound\n    ) internal view returns (uint256 roundCount, uint16 nextPhaseId, uint256 nextPhaseStartingRoundId) {\n        AggregatorProxyInterface proxy = AggregatorProxyInterface(ChainlinkAggregator.unwrap(self));\n\n        // Try to get the immediate next round in the same phase. If this errors, we know that the phase has ended\n        try proxy.getRoundData(uint80(lastSyncedRoundId + 1)) returns (uint80 nextRoundId,int256,uint256,uint256 nextUpdatedAt,uint80) {\n            // If the next round in this phase is before the latest round, then we can safely mark that\n            // as the end of the phase, and the latestRound as the start of the new phase\n            // Else the next round in this phase is _after_ the latest round, then we\n            // fallthrough to search for the next starting round ID using the walkback logic\n            if (nextRoundId == 0 || nextUpdatedAt == 0) { // Invalid round\n                // pass\n            } else if (nextUpdatedAt < latestRound.timestamp) {\n                return ((nextRoundId - startingRoundId) + 1, latestRound.phaseId(), latestRound.roundId);\n            }\n        } catch  {\n            // pass\n        }\n\n        // lastSyncedRound is the last round in it's phase before latestRound, so we need to find where the next phase starts\n        // The next phase should start at the round that is closest to but after lastSyncedRound.timestamp\n        ChainlinkRound memory lastSyncedRound = getRound(self, lastSyncedRoundId);\n        uint16 phaseToSearch = lastSyncedRound.phaseId();\n        while (nextPhaseStartingRoundId == 0) {\n            phaseToSearch++;\n            nextPhaseStartingRoundId = getStartingRoundId(self, phaseToSearch, lastSyncedRound.timestamp);\n        }\n\n        return ((lastSyncedRoundId - startingRoundId) + 1, phaseToSearch, nextPhaseStartingRoundId);\n    }\n\n    /**\n     * @notice Returns the round ID closest to but greater than targetTimestamp for the specified phase ID\n     * @param self Chainlink Feed Aggregator to operate on\n     * @param phaseId The specific phase to fetch data for\n     * @param targetTimestamp timestamp to search for\n     * @dev Assumes the phase ends at the aggregators latestRound or earlier\n     * @return The number of rounds in the phase\n     */\n    function getStartingRoundId(ChainlinkAggregator self, uint16 phaseId, uint256 targetTimestamp)\n    internal view returns (uint256) {\n        AggregatorProxyInterface proxy = AggregatorProxyInterface(ChainlinkAggregator.unwrap(self));\n\n        (,,,uint256 startTimestamp,) = proxy.getRoundData(uint80(_aggregatorRoundIdToProxyRoundId(phaseId, 1)));\n        if (startTimestamp == 0) return 0; // Empty phase\n\n        return _search(proxy, phaseId, targetTimestamp, startTimestamp, 1);\n    }\n\n    /**\n     * Searches the given chainlink proxy for a round which has a timestamp which is as close to but greater than\n     * the `targetTimestamp`\n     * @param proxy Chainlink Proxy to search within\n     * @param phaseId Phase to search for round\n     * @param targetTimestamp Minimum timestamp value for found round\n     * @param minTimestamp Starting timestamp value\n     * @param minRoundId Starting round ID\n     */\n    function _search(AggregatorProxyInterface proxy, uint16 phaseId, uint256 targetTimestamp, uint256 minTimestamp, uint256 minRoundId) private view returns (uint256) {\n        uint256 maxRoundId = minRoundId + 1000; // Start 1000 rounds away when searching for maximum\n        uint256 maxTimestamp = _tryGetProxyRoundData(proxy, phaseId, uint80(maxRoundId));\n\n        // Find the round bounds of the phase to perform the binary search\n        while (maxTimestamp <= targetTimestamp) {\n            minRoundId = maxRoundId;\n            minTimestamp = maxTimestamp;\n            maxRoundId = maxRoundId * 2; // Find bounds of phase by multiplying the max round by 2\n            maxTimestamp = _tryGetProxyRoundData(proxy, phaseId, uint80(maxRoundId));\n        }\n\n        // Binary Search starts here. The algorithm calculates the middle round ID and finds it's timestamp\n        // If the midtimestamp is greater than target, set max to mid and continue\n        // If the midtimestamp is less than or equal to target, set min to mid and continue\n        // Exit when min + 1 is equal to or greater than max (no rounds between them)\n        while (minRoundId + 1 < maxRoundId) {\n            uint256 midRound = Math.average(minRoundId, maxRoundId);\n            uint256 midTimestamp = _tryGetProxyRoundData(proxy, phaseId, uint80(midRound));\n            if (midTimestamp > targetTimestamp) {\n                maxTimestamp = midTimestamp;\n                maxRoundId = midRound;\n            } else {\n                minTimestamp = midTimestamp;\n                minRoundId = midRound;\n            }\n        }\n\n        // If the found timestamp is not greater than target timestamp or no max was found, then the desired round does\n        // not exist in this phase\n        if (maxTimestamp <= targetTimestamp || maxTimestamp == type(uint256).max) return 0;\n\n        return _aggregatorRoundIdToProxyRoundId(phaseId, uint80(maxRoundId));\n    }\n\n    function _tryGetProxyRoundData(AggregatorProxyInterface proxy, uint16 phaseId, uint80 tryRound) private view returns (uint256) {\n        try proxy.getRoundData(uint80(_aggregatorRoundIdToProxyRoundId(phaseId, tryRound))) returns (uint80,int256,uint256,uint256 timestamp,uint80) {\n            if (timestamp > 0) return timestamp;\n        } catch  {\n            // pass\n        }\n        return type(uint256).max;\n    }\n\n    /**\n     * @notice Convert an aggregator round ID into a proxy round ID for the given phase\n     * @dev Follows the logic specified in https://docs.chain.link/data-feeds/price-feeds/historical-data#roundid-in-proxy\n     * @param phaseId phase ID for the given aggregator round\n     * @param aggregatorRoundId round id for the aggregator round\n     * @return Proxy roundId\n     */\n    function _aggregatorRoundIdToProxyRoundId(uint16 phaseId, uint80 aggregatorRoundId) private pure returns (uint256) {\n        return (uint256(phaseId) << 64) + aggregatorRoundId;\n    }\n}"
    },
    {
      "filename": "perennial-mono/packages/perennial-oracle/contracts/types/ChainlinkAggregator.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorProxyInterface.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"./ChainlinkRound.sol\";\n\n/// @dev ChainlinkAggregator type\ntype ChainlinkAggregator is address;\nusing ChainlinkAggregatorLib for ChainlinkAggregator global;\n\n/**\n * @title ChainlinkAggregatorLib\n * @notice Library that manages interfacing with the Chainlink Feed Aggregator Proxy.\n */\nlibrary ChainlinkAggregatorLib {\n    /**\n     * @notice Returns the decimal amount for a specific feed\n     * @param self Chainlink Feed Aggregator to operate on\n     * @return Decimal amount\n     */\n    function decimals(ChainlinkAggregator self) internal view returns (uint8) {\n        return AggregatorProxyInterface(ChainlinkAggregator.unwrap(self)).decimals();\n    }\n\n    /**\n     * @notice Returns the latest round data for a specific feed\n     * @param self Chainlink Feed Aggregator to operate on\n     * @return Latest round data\n     */\n    function getLatestRound(ChainlinkAggregator self) internal view returns (ChainlinkRound memory) {\n        (uint80 roundId, int256 answer, , uint256 updatedAt, ) =\n            AggregatorProxyInterface(ChainlinkAggregator.unwrap(self)).latestRoundData();\n        return ChainlinkRound({roundId: roundId, timestamp: updatedAt, answer: answer});\n    }\n\n    /**\n     * @notice Returns a specific round's data for a specific feed\n     * @param self Chainlink Feed Aggregator to operate on\n     * @param roundId The specific round to fetch data for\n     * @return Specific round's data\n     */\n    function getRound(ChainlinkAggregator self, uint256 roundId) internal view returns (ChainlinkRound memory) {\n        (, int256 answer, , uint256 updatedAt, ) =\n            AggregatorProxyInterface(ChainlinkAggregator.unwrap(self)).getRoundData(uint80(roundId));\n        return ChainlinkRound({roundId: roundId, timestamp: updatedAt, answer: answer});\n    }\n\n\n    /**\n     * @notice Returns the round count and next phase starting round for the lastSyncedRound phase\n     * @param self Chainlink Feed Aggregator to operate on\n     * @param startingRoundId starting roundId for the aggregator proxy\n     * @param lastSyncedRoundId last synced round ID for the proxy\n     * @param latestRound latest round from the proxy\n     * @return roundCount The number of rounds in the phase\n     * @return nextPhaseId The phaseID for the next phase\n     * @return nextPhaseStartingRoundId The starting round ID for the next phase\n     */\n    function getPhaseSwitchoverData(\n        ChainlinkAggregator self,\n        uint256 startingRoundId,\n        uint256 lastSyncedRoundId,\n        ChainlinkRound memory latestRound\n    ) internal view returns (uint256 roundCount, uint16 nextPhaseId, uint256 nextPhaseStartingRoundId) {\n        AggregatorProxyInterface proxy = AggregatorProxyInterface(ChainlinkAggregator.unwrap(self));\n\n        // Try to get the immediate next round in the same phase. If this errors, we know that the phase has ended\n        try proxy.getRoundData(uint80(lastSyncedRoundId + 1)) returns (uint80 nextRoundId,int256,uint256,uint256 nextUpdatedAt,uint80) {\n            // If the next round in this phase is before the latest round, then we can safely mark that\n            // as the end of the phase, and the latestRound as the start of the new phase\n            // Else the next round in this phase is _after_ the latest round, then we\n            // fallthrough to search for the next starting round ID using the walkback logic\n            if (nextRoundId == 0 || nextUpdatedAt == 0) { // Invalid round\n                // pass\n            } else if (nextUpdatedAt < latestRound.timestamp) {\n                return ((nextRoundId - startingRoundId) + 1, latestRound.phaseId(), latestRound.roundId);\n            }\n        } catch  {\n            // pass\n        }\n\n        // lastSyncedRound is the last round in it's phase before latestRound, so we need to find where the next phase starts\n        // The next phase should start at the round that is closest to but after lastSyncedRound.timestamp\n        ChainlinkRound memory lastSyncedRound = getRound(self, lastSyncedRoundId);\n        uint16 phaseToSearch = lastSyncedRound.phaseId();\n        while (nextPhaseStartingRoundId == 0) {\n            phaseToSearch++;\n            nextPhaseStartingRoundId = getStartingRoundId(self, phaseToSearch, lastSyncedRound.timestamp);\n        }\n\n        return ((lastSyncedRoundId - startingRoundId) + 1, phaseToSearch, nextPhaseStartingRoundId);\n    }\n\n    /**\n     * @notice Returns the round ID closest to but greater than targetTimestamp for the specified phase ID\n     * @param self Chainlink Feed Aggregator to operate on\n     * @param phaseId The specific phase to fetch data for\n     * @param targetTimestamp timestamp to search for\n     * @dev Assumes the phase ends at the aggregators latestRound or earlier\n     * @return The number of rounds in the phase\n     */\n    function getStartingRoundId(ChainlinkAggregator self, uint16 phaseId, uint256 targetTimestamp)\n    internal view returns (uint256) {\n        AggregatorProxyInterface proxy = AggregatorProxyInterface(ChainlinkAggregator.unwrap(self));\n\n        (,,,uint256 startTimestamp,) = proxy.getRoundData(uint80(_aggregatorRoundIdToProxyRoundId(phaseId, 1)));\n        if (startTimestamp == 0) return 0; // Empty phase\n\n        return _search(proxy, phaseId, targetTimestamp, startTimestamp, 1);\n    }\n\n    /**\n     * Searches the given chainlink proxy for a round which has a timestamp which is as close to but greater than\n     * the `targetTimestamp`\n     * @param proxy Chainlink Proxy to search within\n     * @param phaseId Phase to search for round\n     * @param targetTimestamp Minimum timestamp value for found round\n     * @param minTimestamp Starting timestamp value\n     * @param minRoundId Starting round ID\n     */\n    function _search(AggregatorProxyInterface proxy, uint16 phaseId, uint256 targetTimestamp, uint256 minTimestamp, uint256 minRoundId) private view returns (uint256) {\n        uint256 maxRoundId = minRoundId + 1000; // Start 1000 rounds away when searching for maximum\n        uint256 maxTimestamp = _tryGetProxyRoundData(proxy, phaseId, uint80(maxRoundId));\n\n        // Find the round bounds of the phase to perform the binary search\n        while (maxTimestamp <= targetTimestamp) {\n            minRoundId = maxRoundId;\n            minTimestamp = maxTimestamp;\n            maxRoundId = maxRoundId * 2; // Find bounds of phase by multiplying the max round by 2\n            maxTimestamp = _tryGetProxyRoundData(proxy, phaseId, uint80(maxRoundId));\n        }\n\n        // Binary Search starts here. The algorithm calculates the middle round ID and finds it's timestamp\n        // If the midtimestamp is greater than target, set max to mid and continue\n        // If the midtimestamp is less than or equal to target, set min to mid and continue\n        // Exit when min + 1 is equal to or greater than max (no rounds between them)\n        while (minRoundId + 1 < maxRoundId) {\n            uint256 midRound = Math.average(minRoundId, maxRoundId);\n            uint256 midTimestamp = _tryGetProxyRoundData(proxy, phaseId, uint80(midRound));\n            if (midTimestamp > targetTimestamp) {\n                maxTimestamp = midTimestamp;\n                maxRoundId = midRound;\n            } else {\n                minTimestamp = midTimestamp;\n                minRoundId = midRound;\n            }\n        }\n\n        // If the found timestamp is not greater than target timestamp or no max was found, then the desired round does\n        // not exist in this phase\n        if (maxTimestamp <= targetTimestamp || maxTimestamp == type(uint256).max) return 0;\n\n        return _aggregatorRoundIdToProxyRoundId(phaseId, uint80(maxRoundId));\n    }\n\n    function _tryGetProxyRoundData(AggregatorProxyInterface proxy, uint16 phaseId, uint80 tryRound) private view returns (uint256) {\n        try proxy.getRoundData(uint80(_aggregatorRoundIdToProxyRoundId(phaseId, tryRound))) returns (uint80,int256,uint256,uint256 timestamp,uint80) {\n            if (timestamp > 0) return timestamp;\n        } catch  {\n            // pass\n        }\n        return type(uint256).max;\n    }\n\n    /**\n     * @notice Convert an aggregator round ID into a proxy round ID for the given phase\n     * @dev Follows the logic specified in https://docs.chain.link/data-feeds/price-feeds/historical-data#roundid-in-proxy\n     * @param phaseId phase ID for the given aggregator round\n     * @param aggregatorRoundId round id for the aggregator round\n     * @return Proxy roundId\n     */\n    function _aggregatorRoundIdToProxyRoundId(uint16 phaseId, uint80 aggregatorRoundId) private pure returns (uint256) {\n        return (uint256(phaseId) << 64) + aggregatorRoundId;\n    }\n}"
    },
    {
      "filename": "perennial-mono/packages/perennial-oracle/contracts/types/ChainlinkAggregator.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorProxyInterface.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"./ChainlinkRound.sol\";\n\n/// @dev ChainlinkAggregator type\ntype ChainlinkAggregator is address;\nusing ChainlinkAggregatorLib for ChainlinkAggregator global;\n\n/**\n * @title ChainlinkAggregatorLib\n * @notice Library that manages interfacing with the Chainlink Feed Aggregator Proxy.\n */\nlibrary ChainlinkAggregatorLib {\n    /**\n     * @notice Returns the decimal amount for a specific feed\n     * @param self Chainlink Feed Aggregator to operate on\n     * @return Decimal amount\n     */\n    function decimals(ChainlinkAggregator self) internal view returns (uint8) {\n        return AggregatorProxyInterface(ChainlinkAggregator.unwrap(self)).decimals();\n    }\n\n    /**\n     * @notice Returns the latest round data for a specific feed\n     * @param self Chainlink Feed Aggregator to operate on\n     * @return Latest round data\n     */\n    function getLatestRound(ChainlinkAggregator self) internal view returns (ChainlinkRound memory) {\n        (uint80 roundId, int256 answer, , uint256 updatedAt, ) =\n            AggregatorProxyInterface(ChainlinkAggregator.unwrap(self)).latestRoundData();\n        return ChainlinkRound({roundId: roundId, timestamp: updatedAt, answer: answer});\n    }\n\n    /**\n     * @notice Returns a specific round's data for a specific feed\n     * @param self Chainlink Feed Aggregator to operate on\n     * @param roundId The specific round to fetch data for\n     * @return Specific round's data\n     */\n    function getRound(ChainlinkAggregator self, uint256 roundId) internal view returns (ChainlinkRound memory) {\n        (, int256 answer, , uint256 updatedAt, ) =\n            AggregatorProxyInterface(ChainlinkAggregator.unwrap(self)).getRoundData(uint80(roundId));\n        return ChainlinkRound({roundId: roundId, timestamp: updatedAt, answer: answer});\n    }\n\n\n    /**\n     * @notice Returns the round count and next phase starting round for the lastSyncedRound phase\n     * @param self Chainlink Feed Aggregator to operate on\n     * @param startingRoundId starting roundId for the aggregator proxy\n     * @param lastSyncedRoundId last synced round ID for the proxy\n     * @param latestRound latest round from the proxy\n     * @return roundCount The number of rounds in the phase\n     * @return nextPhaseId The phaseID for the next phase\n     * @return nextPhaseStartingRoundId The starting round ID for the next phase\n     */\n    function getPhaseSwitchoverData(\n        ChainlinkAggregator self,\n        uint256 startingRoundId,\n        uint256 lastSyncedRoundId,\n        ChainlinkRound memory latestRound\n    ) internal view returns (uint256 roundCount, uint16 nextPhaseId, uint256 nextPhaseStartingRoundId) {\n        AggregatorProxyInterface proxy = AggregatorProxyInterface(ChainlinkAggregator.unwrap(self));\n\n        // Try to get the immediate next round in the same phase. If this errors, we know that the phase has ended\n        try proxy.getRoundData(uint80(lastSyncedRoundId + 1)) returns (uint80 nextRoundId,int256,uint256,uint256 nextUpdatedAt,uint80) {\n            // If the next round in this phase is before the latest round, then we can safely mark that\n            // as the end of the phase, and the latestRound as the start of the new phase\n            // Else the next round in this phase is _after_ the latest round, then we\n            // fallthrough to search for the next starting round ID using the walkback logic\n            if (nextRoundId == 0 || nextUpdatedAt == 0) { // Invalid round\n                // pass\n            } else if (nextUpdatedAt < latestRound.timestamp) {\n                return ((nextRoundId - startingRoundId) + 1, latestRound.phaseId(), latestRound.roundId);\n            }\n        } catch  {\n            // pass\n        }\n\n        // lastSyncedRound is the last round in it's phase before latestRound, so we need to find where the next phase starts\n        // The next phase should start at the round that is closest to but after lastSyncedRound.timestamp\n        ChainlinkRound memory lastSyncedRound = getRound(self, lastSyncedRoundId);\n        uint16 phaseToSearch = lastSyncedRound.phaseId();\n        while (nextPhaseStartingRoundId == 0) {\n            phaseToSearch++;\n            nextPhaseStartingRoundId = getStartingRoundId(self, phaseToSearch, lastSyncedRound.timestamp);\n        }\n\n        return ((lastSyncedRoundId - startingRoundId) + 1, phaseToSearch, nextPhaseStartingRoundId);\n    }\n\n    /**\n     * @notice Returns the round ID closest to but greater than targetTimestamp for the specified phase ID\n     * @param self Chainlink Feed Aggregator to operate on\n     * @param phaseId The specific phase to fetch data for\n     * @param targetTimestamp timestamp to search for\n     * @dev Assumes the phase ends at the aggregators latestRound or earlier\n     * @return The number of rounds in the phase\n     */\n    function getStartingRoundId(ChainlinkAggregator self, uint16 phaseId, uint256 targetTimestamp)\n    internal view returns (uint256) {\n        AggregatorProxyInterface proxy = AggregatorProxyInterface(ChainlinkAggregator.unwrap(self));\n\n        (,,,uint256 startTimestamp,) = proxy.getRoundData(uint80(_aggregatorRoundIdToProxyRoundId(phaseId, 1)));\n        if (startTimestamp == 0) return 0; // Empty phase\n\n        return _search(proxy, phaseId, targetTimestamp, startTimestamp, 1);\n    }\n\n    /**\n     * Searches the given chainlink prox"
    }
  ]
}