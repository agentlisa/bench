{
  "Title": "M-11: Incorrect premium calculation in OracleMaker",
  "Content": "# Issue M-11: Incorrect premium calculation in OracleMaker \n\nSource: https://github.com/sherlock-audit/2024-02-perpetual-judging/issues/137 \n\nThe protocol has acknowledged this issue.\n\n## Found by \njokr\n## Summary\n Position rate should not be influenced by free collateral of the OracleMaker\n\n## Vulnerability Detail\nPosition rate determines the exposure of OracleMaker. Position rate is used to determine the amount of premium based on the current oracleMaker position. \n\nFor ex: If maker has 100 ETH long position and if a user wants to open a short then the price which he has to open will be less than actual market price. If user takes the long, then its in favour of oracleMaker, so no premium will be imposed \n\nHere is how the position rate is being calculated\n\n```solidity\n    function _getPositionRate(uint256 price) internal view returns (int256) {\n        IVault vault = _getVault();\n        uint256 marketId_ = _getOracleMakerStorage().marketId;\n        // accountValue = margin + unrealisedPnl\n        int256 accountValue = vault.getAccountValue(marketId_, address(this), price);\n        int256 unrealizedPnl = vault.getUnrealizedPnl(marketId_, address(this), price);\n        int256 unsettledMargin = accountValue - unrealizedPnl;\n        int256 collateralForOpen = FixedPointMathLib.min(unsettledMargin, accountValue);\n        // TODO: use positionMarginRequirement\n        //int256 collateralForOpen = positionMarginRequirement + freeCollateralForOpen;\n        if (collateralForOpen <= 0) {\n            revert LibError.NegativeOrZeroMargin();\n        }\n\n        int256 maxPositionNotional = (collateralForOpen * 1 ether) / _getOracleMakerStorage().minMarginRatio.toInt256();\n\n        // if maker has long position, positionRate > 0\n        // if maker has short position, positionRate < 0\n        int256 openNotional = vault.getOpenNotional(marketId_, address(this));\n        int256 uncappedPositionRate = (-openNotional * 1 ether) / maxPositionNotional;\n\n        // util ratio: 0 ~ 1\n        // position rate: -1 ~ 1\n        return\n            uncappedPositionRate > 0\n                ? FixedPointMathLib.min(uncappedPositionRate, 1 ether)\n                : FixedPointMathLib.max(uncappedPositionRate, -1 ether);\n    }\n\n```\nThe problem here is the `uncappedPositionRate` also depends on `maxPositionNotional`. `maxPositionNotional` is the maximum openNotional possible for current `openCollateral` of oracleMaker with given `minMarginRatio`.\n\n`int256 uncappedPositionRate = (-openNotional * 1 ether) / maxPositionNotional;`\n\nSo in this case if the `freeCollateral` is more in the oracle maker than the premium becomes proportionally low which is not correct.\n\nConsider this scenario\n Currently oracleMaker has 100 ETH short position. If a user wants to take a 10 ETH long position there must premium against user. So the reservation price at which user opens will be higher than market price. \n \nNow the user deposits large amount of collateral as LP. As the. freeCollateral increases, for sufficient collateral  given the premium free decreases proportionally. After the user opens the position with less premium, he just withdraws the collateral back. Thus bypassing the premium enforced by oracle maker\n\nThis is possible by considering free collateral while calculating the position rate. Position rate should solely depend on openNotional and not on free collateral in any way\n\n## Impact\nIncorrect handling of risk exposure \n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-02-perpetual/blob/main/perp-contract-v3/src/maker/OracleMaker.sol#L411\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nModify the position rate calculation by excluding `maxPositionNotional`\n\n\n\n## Discussion\n\n**sherlock-admin3**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**santipu_** commented:\n> Medium\n\n\n\n**rc56**\n\n@CheshireCatNick\n- Won't fix for now. Will improve in the future. One potential solution is to implement a time lock when deposit / withdraw into makers.\n- It is true that the trick (deposit -> open position -> withdraw) could bypass OracleMaker's spread, but the impact is considered a degradation (high risk exposure without proper compensation) of maker performance instead of a critical vulnerability.\n- Also, oracle maker requires order being delayed. Attacker cannot deposit, open position and withdraw in the same tx. Thus, this attack is not completely risk-free.\n- Note the maker has minMarginRatio which protects it from taking too much exposure. The parameter had been set conservative (minMarginRatio = 100%) from the start so we have extra safety margin to observe its real-world performance and improve it iteratively.\n\n**CheshireCatNick**\n\nAlso in the beginning we only allow whitelisted users to deposit to maker.\n\n**IllIllI000**\n\n@rc56, @CheshireCatNick, and @42bchen if you disagree that this is a High, can you let us know what severity you think this should be, and apply the disagree-with-severity tag? It seems similar to https://github.com/sherlock-audit/2024-02-perpetual-judging/issues/127 in that the LP deposits/withdrawals can be used to game what users have to pay\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/219",
  "Code": [
    {
      "filename": "perp-contract-v3/src/maker/OracleMaker.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.0;\n\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n// solhint-disable-next-line max-line-length\nimport { Ownable2StepUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\n// solhint-disable-next-line max-line-length\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { FixedPointMathLib } from \"solady/src/utils/FixedPointMathLib.sol\";\nimport { LibFormatter } from \"../common/LibFormatter.sol\";\nimport { AddressResolverUpgradeable } from \"../addressResolver/AddressResolverUpgradeable.sol\";\nimport { IAddressManager } from \"../addressManager/IAddressManager.sol\";\nimport { LibAddressResolver } from \"../addressResolver/LibAddressResolver.sol\";\nimport { INTERNAL_DECIMALS, WAD } from \"../common/LibConstant.sol\";\nimport { LibError } from \"../common/LibError.sol\";\nimport { IMaker } from \"./IMaker.sol\";\nimport { IVault } from \"../vault/IVault.sol\";\nimport { ContextBase } from \"../common/ContextBase.sol\";\nimport { IPythOracleAdapter } from \"../oracle/pythOracleAdapter/IPythOracleAdapter.sol\";\nimport { IWhitelistLpManager } from \"./IWhitelistLpManager.sol\";\n\n// Price from Pyth is predictable due to the latency between prices arriving at Pyth price service\n// and those prices appearing on-chain.\n// See https://sips.synthetix.io/sips/sip-285/#rationale\n//\n// This predictable price can be exploited by a front-runner, so any trade on OracleMaker must be 2-step, aka \"delayed\",\n// and can only be interacted with through OrderGateway and OrderGatewayV2. This is configurable\n// via OracleMaker.setValidSender().\ncontract OracleMaker is ContextBase, AddressResolverUpgradeable, Ownable2StepUpgradeable, ERC20Upgradeable, IMaker {\n    using SafeERC20 for IERC20Metadata;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using FixedPointMathLib for uint256;\n    using LibFormatter for uint256;\n    using LibFormatter for int256;\n    using LibAddressResolver for IAddressManager;\n\n    //\n    // STRUCT\n    //\n\n    /// @custom:storage-location erc7201:perp.storage.oracleMaker\n    struct OracleMakerStorage {\n        uint256 marketId;\n        bytes32 priceFeedId;\n        /// @notice the minimum margin ratio required for trade or withdrawal\n        uint256 minMarginRatio; // Min. marign ratio required by the maker at all time.\n        /// @notice max spread ratio is the \"given\" in stoikov maker\n        /// @dev price = maxSpreadRatio * positionRate\n        /// @dev when maker has long, positionRate = min(100%, openNotional * minMarginRatio / freeCollateralForOpen)\n        /// @dev when maker has short, positionRate = max(100%, openNotional * minMarginRatio / freeCollateralForOpen)\n        uint256 maxSpreadRatio;\n        mapping(address => bool) validSenderMap;\n    }\n\n    event Deposited(\n        address depositor,\n        uint256 shares, // Amount of share minted\n        uint256 underlying // Amount of underlying token deposited\n    );\n\n    event Withdrawn(\n        address withdrawer,\n        uint256 shares, // Amount of shares burnt\n        uint256 underlying // Amount of underlying tokens withdrawn\n    );\n\n    /// @notice Emitted when an order is being filled by a Pyth Oracle Maker.\n    ///         It reveals all information associated to the trade price.\n    event OMOrderFilled(\n        uint256 marketId,\n        uint256 oraclePrice, // In quote asset as wei, assume price >= 0\n        int256 baseAmount, // Base token amount filled (from taker's perspective)\n        int256 quoteAmount // Quote token amount filled (from taker's perspective)\n    );\n\n    event PriceFeedIdSet(bytes32 newPriceFeedId, bytes32 oldPriceFeedId);\n\n    event MinMarginRatioSet(uint256 newMinMarginRatio, uint256 oldMinMarginRatio);\n    event MaxSpreadRatioSet(uint256 newMaxSpreadRatio, uint256 oldMaxSpreadRatio);\n\n    //\n    // STATE\n    //\n\n    // keccak256(abi.encode(uint256(keccak256(\"perp.storage.oracleMaker\")) - 1)) & ~bytes32(uint256(0xff));\n    bytes32 constant _ORACLE_MAKER_STORAGE_LOCATION =\n        0x49404affd0747f1de28f32f44120f8f18db1aa69644f83b133007475ed402e00;\n\n    //\n    // MODIFIER\n    //\n    modifier onlyClearingHouse() {\n        if (msg.sender != address(getAddressManager().getClearingHouse())) revert LibError.Unauthorized();\n        _;\n    }\n\n    modifier onlyWhitelistLp() {\n        IWhitelistLpManager whitelistManager = getAddressManager().getWhitelistLpManager();\n        if (address(whitelistManager) != address(0)) {\n            if (!whitelistManager.isLpWhitelisted(_sender())) revert LibError.Unauthorized();\n        }\n        _;\n    }\n\n    //\n    // EXTERNAL NON-VIEW\n    //\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        uint256 marketId_,\n        string memory name_,\n        string memory symbol_,\n        address addressManager_,\n        bytes32 priceFeedId_,\n        uint256 minMarginRatio_\n    ) external initializer {\n        __AddressResolver_init(addressManager_);\n        __Ownable2Step_init();\n        __Ownable_init(msg.sender);\n        __ERC20_init(name_, symbol_);\n\n        if (!getAddressManager().getPythOracleAdapter().priceFeedExists(priceFeedId_))\n            revert LibError.IllegalPriceFeed(priceFeedId_);\n\n        _getOracleMakerStorage().marketId = marketId_;\n        setPriceFeedId(priceFeedId_);\n        setMinMarginRatio(minMarginRatio_);\n    }\n\n    function setPriceFeedId(bytes32 _priceFeedId) public onlyOwner {\n        if (!getAddressManager().getPythOracleAdapter().priceFeedExists(_priceFeedId))\n            revert LibError.IllegalPriceFeed(_priceFeedId);\n\n        bytes32 oldPriceFeedId = _getOracleMakerStorage().priceFeedId;\n        _getOracleMakerStorage().priceFeedId = _priceFeedId;\n\n        emit PriceFeedIdSet(_priceFeedId, oldPriceFeedId);\n    }\n\n    function setMinMarginRatio(uint256 _minMarginRatio) public onlyOwner {\n        if (_minMarginRatio > WAD) {\n            revert LibError.InvalidRatio(_minMarginRatio);\n        }\n        if (_minMarginRatio == 0) {\n            revert LibError.ZeroRatio();\n        }\n        uint256 oldMinMarginRatio = _getOracleMakerStorage().minMarginRatio;\n        _getOracleMakerStorage().minMarginRatio = _minMarginRatio;\n\n        emit MinMarginRatioSet(_minMarginRatio, oldMinMarginRatio);\n    }\n\n    function setMaxSpreadRatio(uint256 _maxSpreadRatio) public onlyOwner {\n        if (_maxSpreadRatio > WAD) {\n            revert LibError.InvalidRatio(_maxSpreadRatio);\n        }\n        uint256 oldMaxSpreadRatio = _getOracleMakerStorage().maxSpreadRatio;\n        _getOracleMakerStorage().maxSpreadRatio = _maxSpreadRatio;\n\n        emit MaxSpreadRatioSet(_maxSpreadRatio, oldMaxSpreadRatio);\n    }\n\n    function setValidSender(address user, bool isValid) public onlyOwner {\n        _getOracleMakerStorage().validSenderMap[user] = isValid;\n    }\n\n    function deposit(uint256 amountXCD) external onlyWhitelistLp returns (uint256) {\n        address depositor = _sender();\n        address maker = address(this);\n\n        if (amountXCD == 0) revert LibError.ZeroAmount();\n\n        IERC20Metadata collateralToken = IERC20Metadata(_getAsset());\n        IAddressManager addressManager = getAddressManager();\n        IVault vault = addressManager.getVault();\n\n        uint256 shares;\n        if (totalSupply() == 0) {\n            shares = amountXCD;\n        } else {\n            uint256 price = _getPrice();\n\n            // TODO Should consider slippage once maker has spread or other pricing logic.\n            // For now, we will just get account value from ClearingHouse (assume no slippages).\n            // shares per asset = share (share token precision) / accountValue (INTERNAL_DECIMALS)\n            // shares (share token precision) = assets (base token precision) * shares per asset\n\n            // TODO: We should add protections to prevent attackers from manipulating the share price by manipulating oracle reported price.\n            // This is because the attacker could potentially mint large amount of shares by forcing the account value low.\n            // Possible protections like rate limiting share price, or any kind of volatility check.\n\n            uint8 shareDecimals = decimals();\n            uint256 vaultValueXShareDecimals = _getVaultValueSafe(vault, price).formatDecimals(\n                INTERNAL_DECIMALS,\n                shareDecimals\n            );\n            uint256 amountXShareDecimals = amountXCD.formatDecimals(collateralToken.decimals(), shareDecimals);\n            shares = (amountXShareDecimals * totalSupply()) / vaultValueXShareDecimals;\n        }\n\n        uint256 balanceBefore = collateralToken.balanceOf(maker);\n        collateralToken.safeTransferFrom(_sender(), maker, amountXCD);\n        uint256 transferredAmount = collateralToken.balanceOf(maker) - balanceBefore;\n\n        if (transferredAmount != amountXCD) {\n            revert LibError.WrongTransferAmount(transferredAmount, amountXCD);\n        }\n\n        collateralToken.approve(address(vault), amountXCD);\n        vault.deposit(maker, amountXCD);\n        vault.transferFundToMargin(_getOracleMakerStorage().marketId, amountXCD);\n\n        _mint(depositor, shares);\n\n        emit Deposited(depositor, shares, amountXCD);\n\n        return shares;\n    }\n\n    function withdraw(uint256 shares) external onlyWhitelistLp returns (uint256) {\n        address withdrawer = _sender();\n\n        if (shares == 0) revert LibError.ZeroAmount();\n\n        // Must done before burn.\n        uint256 redeemedRatio = shares.divWad(totalSupply());\n\n        // Revert early if shares amount exceeds balance\n        _burn(withdrawer, shares);\n\n        IVault vault = _getVault();\n\n        uint256 price = _getPrice();\n        uint256 vaultValue = _getVaultValueSafe(vault, price);\n        IERC20Metadata collateralToken = IERC20Metadata(_getAsset());\n        uint256 withdrawnAmountXCD = vaultValue.mulWad(redeemedRatio).formatDecimals(\n            INTERNAL_DECIMALS,\n            collateralToken.decimals()\n        );\n\n        // It may not be possible to withdraw the required amount, due to unsettledPnl that cannot be settled totally.\n        vault.transferMarginToFund(_getOracleMakerStorage().marketId, withdrawnAmountXCD);\n        vault.withdraw(withdrawnAmountXCD);\n        collateralToken.safeTransfer(withdrawer, withdrawnAmountXCD);\n\n        _checkMinMarginRatio(price);\n\n        emit Withdrawn(withdrawer, shares, withdrawnAmountXCD);\n\n        return withdrawnAmountXCD;\n    }\n\n    function fillOrderCallback(bytes calldata) external view onlyClearingHouse {\n        _checkMinMarginRatio(_getPrice());\n    }\n\n    function fillOrder(\n        bool isBaseToQuote,\n        bool isExactInput,\n        uint256 amount,\n        bytes calldata\n    ) external onlyClearingHouse returns (uint256, bytes memory) {\n        uint256 basePrice = _getPrice();\n        uint256 basePriceWithSpread = _getBasePriceWithSpread(basePrice, isBaseToQuote);\n\n        // - `amount` base -> `amount * basePrice` quote\n        //   (isBaseToQuote=true, isExactInput=true, openNotional = `amount * basePrice`)\n        // - `amount` base <- `amount * basePrice` quote\n        //   (isBaseToQuote=false, isExactInput=false, openNotional = -`amount * basePrice`)\n        // - `amount / basePrice` base -> `amount` quote\n        //   (isBaseToQuote=true, isExactInput=false, openNotional = `amount`)\n        // - `amount / basePrice` base <- `amount` quote\n        //   (isBaseToQuote=false, isExactInput=true, openNotional = -`amount`)\n\n        int256 baseAmount;\n        int256 quoteAmount;\n        uint256 oppositeAmount;\n        if (isBaseToQuote) {\n            if (isExactInput) {\n                // TODO: Should use configed decimal number instead of hard-coding\n                oppositeAmount = (amount * basePriceWithSpread) / 1 ether;\n                baseAmount = -amount.toInt256();\n                quoteAmount = oppositeAmount.toInt256();\n            } else {\n                oppositeAmount = (amount * 1 ether) / basePriceWithSpread;\n                baseAmount = -oppositeAmount.toInt256();\n                quoteAmount = amount.toInt256();\n            }\n        } else {\n            if (isExactInput) {\n                oppositeAmount = (amount * 1 ether) / basePriceWithSpread;\n                baseAmount = oppositeAmount.toInt256();\n                quoteAmount = -amount.toInt256();\n            } else {\n                oppositeAmount = (amount * basePriceWithSpread) / 1 ether;\n                baseAmount = amount.toInt256();\n                quoteAmount = -oppositeAmount.toInt256();\n            }\n        }\n        emit OMOrderFilled(_getOracleMakerStorage().marketId, basePrice, baseAmount, quoteAmount);\n        return (oppositeAmount, new bytes(0));\n    }\n\n    //\n    // EXTERNAL VIEW\n    //\n\n    function getUtilRatio() external view returns (uint256, uint256) {\n        if (totalSupply() == 0) {\n            return (0, 0);\n        }\n\n        IVault vault = _getVault();\n        int256 positionSize = vault.getPositionSize(_getOracleMakerStorage().marketId, address(this));\n\n        if (positionSize == 0) {\n            return (0, 0);\n        }\n\n        uint256 price = _getPrice();\n        int256 positionRate = _getPositionRate(price);\n        // position rate > 0, maker has long position, set long util ratio to 0 so taker tends to long\n        // position rate < 0, maker has short position, set short util ratio to 0 so taker tends to short\n        return positionRate > 0 ? (uint256(0), positionRate.toUint256()) : ((-positionRate).toUint256(), uint256(0));\n    }\n\n    function isValidSender(address sender) external view returns (bool) {\n        return _getOracleMakerStorage().validSenderMap[sender];\n    }\n\n    function getAsset() external view returns (address) {\n        return _getAsset();\n    }\n\n    function getTotalAssets(uint256 price) external view returns (int256) {\n        IVault vault = _getVault();\n        IERC20Metadata collateralToken = IERC20Metadata(_getAsset());\n        return _getVaultValue(vault, price).formatDecimals(INTERNAL_DECIMALS, collateralToken.decimals());\n    }\n\n    // For backward-compatibility\n    function marketId() external view returns (uint256) {\n        return _getOracleMakerStorage().marketId;\n    }\n\n    // For backward-compatibility\n    function priceFeedId() external view returns (bytes32) {\n        return _getOracleMakerStorage().priceFeedId;\n    }\n\n    // For backward-compatibility\n    function minMarginRatio() external view returns (uint256) {\n        return _getOracleMakerStorage().minMarginRatio;\n    }\n\n    // For backward-compatibility\n    function maxSpreadRatio() external view returns (uint256) {\n        return _getOracleMakerStorage().maxSpreadRatio;\n    }\n\n    //\n    // INTERNAL VIEW\n    //\n    function _getVault() internal view returns (IVault) {\n        return getAddressManager().getVault();\n    }\n\n    // FIXME: when over minMarginRatio, should allow reduce maker position\n    function _checkMinMarginRatio(uint256 price) internal view {\n        uint256 marketId_ = _getOracleMakerStorage().marketId;\n        int256 marginRatio = _getVault().getMarginRatio(marketId_, address(this), price);\n        int256 minMarginRatio_ = _getOracleMakerStorage().minMarginRatio.toInt256();\n        if (marginRatio < minMarginRatio_) revert LibError.MinMarginRatioExceeded(marginRatio, minMarginRatio_);\n    }\n\n    function _getAsset() internal view returns (address) {\n        return getAddressManager().getVault().getCollateralToken();\n    }\n\n    function _getVaultValue(IVault vault, uint256 price) internal view returns (int256) {\n        uint256 marketId_ = _getOracleMakerStorage().marketId;\n        return vault.getAccountValue(marketId_, address(this), price);\n    }\n\n    function _getVaultValueSafe(IVault vault, uint256 price) internal view returns (uint256) {\n        // Revert early since we don't allow deposit/withdraw when the vault's value is negative or zero.\n        int256 vaultValue = _getVaultValue(vault, price);\n        if (vaultValue <= 0) revert LibError.NegativeOrZeroVaultValueInQuote(vaultValue);\n\n        return vaultValue.toUint256();\n    }\n\n    function _getBasePriceWithSpread(uint256 basePrice, bool isBaseToQuote) internal view returns (uint256) {\n        int256 positionRate = _getPositionRate(basePrice);\n        int256 spreadRatio = (_getOracleMakerStorage().maxSpreadRatio.toInt256() * positionRate) / 1 ether;\n        uint256 reservationPrice = (basePrice * (1 ether - spreadRatio).toUint256()) / 1 ether;\n        return\n            isBaseToQuote\n                ? FixedPointMathLib.min(basePrice, reservationPrice)\n                : FixedPointMathLib.max(basePrice, reservationPrice);\n    }\n\n    function _getPositionRate(uint256 price) internal view returns (int256) {\n        IVault vault = _getVault();\n        uint256 marketId_ = _getOracleMakerStorage().marketId;\n        int256 accountValue = vault.getAccountValue(marketId_, address(this), price);\n        int256 unrealizedPnl = vault.getUnrealizedPnl(marketId_, address(this), price);\n        int256 unsettledMargin = accountValue - unrealizedPnl;\n        int256 collateralForOpen = FixedPointMathLib.min(unsettledMargin, accountValue);\n        // TODO: use positionMarginRequirement\n        //int256 collateralForOpen = positionMarginRequirement + freeCollateralForOpen;\n        if (collateralForOpen <= 0) {\n            revert LibError.NegativeOrZeroMargin();\n        }\n\n        int256 maxPositionNotional = (collateralForOpen * 1 ether) / _getOracleMakerStorage().minMarginRatio.toInt256();\n\n        // if maker has long position, positionRate > 0\n        // if maker has short position, positionRate < 0\n        int256 openNotional = vault.getOpenNotional(marketId_, address(this));\n        int256 uncappedPositionRate = (-openNotional * 1 ether) / maxPositionNotional;\n\n        // util ratio: 0 ~ 1\n        // position rate: -1 ~ 1\n        return\n            uncappedPositionRate > 0\n                ? FixedPointMathLib.min(uncappedPositionRate, 1 ether)\n                : FixedPointMathLib.max(uncappedPositionRate, -1 ether);\n    }\n\n    function _getPrice() internal view returns (uint256) {\n        IPythOracleAdapter pythOracleAdapter = getAddressManager().getPythOracleAdapter();\n        (uint256 price, ) = pythOracleAdapter.getPrice(_getOracleMakerStorage().priceFeedId);\n        return price;\n    }\n\n    //\n    // PRIVATE\n    //\n\n    function _getOracleMakerStorage() private pure returns (OracleMakerStorage storage $) {\n        assembly {\n            $.slot := _ORACLE_MAKER_STORAGE_LOCATION\n        }\n    }\n}"
    }
  ]
}