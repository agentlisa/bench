{
  "Title": "Missing fees allow cheap griefing attacks that lead to DoS",
  "Content": "# Missing fees allow cheap griefing attacks that lead to DoS\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXDeposit.sol#L117\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXDeposit.sol#L117</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXDeposit.sol#L115C5-L115C14\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXDeposit.sol#L115C5-L115C14</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXChecks.sol#L59-L60\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXChecks.sol#L59-L60</a>\n\n\n## Summary\n\nThe protocol has chosen a design pattern which does not allow two users at the same time to interact with the system as every time a user deposits or withdraws funds a 2-step process begins which interacts with GMX and only after this process is closed, another user is allowed to start a new process. This design pattern can be abused as griefing attack by front running all user calls with a small deposit, or withdraw call, to DoS the user's call. As the protocol is deployed on L2 blockchains with low transaction fees and does not take fees on depositing or withdrawing funds, this DoS griefing attack is cheap and can be scaled to a point where nobody is able to interact with the system.\n\n## Vulnerability Details\n\nThe design pattern of the system which leads to this possibility is the status variable.\n\nThe flow for such a griefing attack would look like the following:\n\n- The system's status is Open\n- User wants to deposit or withdraw and creates a transaction to do so\n- Attacker front runs the call of the user and deposit or withdraw a small amount of funds (Systems status changes to Deposit or Withdraw)\n- User's call gets reverted as the check if the system's status is Open reverts\n\nDeposit function calls beforeDepositChecks and updates the status to Deposit:\n\n```jsx\nfunction deposit(\n  GMXTypes.Store storage self,\n  GMXTypes.DepositParams memory dp,\n  bool isNative\n) external {\n\t...\n\tGMXChecks.beforeDepositChecks(self, _dc.depositValue);\n\n  self.status = GMXTypes.Status.Deposit;\n\t...\n}\n```\n\nThe beforeDepositChecks function reverts if the current status is not Open:\n\n```jsx\nfunction beforeDepositChecks(\n  GMXTypes.Store storage self,\n  uint256 depositValue\n) external view {\n  if (self.status != GMXTypes.Status.Open)\n    revert Errors.NotAllowedInCurrentVaultStatus();\n\t...\n}\n```\n\nThe same pattern is implemented in the withdraw flow.\n\n## Impact\n\nDoS of the whole system for all depositors.\n\n## Tools Used\n\nManual Review\n\n## Recommendations\n\nImplement fees, for depositing and withdrawing, to increase the costs of such a griefing attack, or rethink the status architecture.",
  "Impact": "MEDIUM",
  "Source": "https://www.codehawks.com/contests/clo38mm260001la08daw5cbuf",
  "Code": [
    {
      "filename": "contracts/strategy/gmx/GMXDeposit.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IDeposit } from \"../../interfaces/protocols/gmx/IDeposit.sol\";\nimport { IWithdrawal } from \"../../interfaces/protocols/gmx/IWithdrawal.sol\";\nimport { IEvent } from \"../../interfaces/protocols/gmx/IEvent.sol\";\nimport { IOrder } from \"../../interfaces/protocols/gmx/IOrder.sol\";\nimport { ISwap } from  \"../../interfaces/swap/ISwap.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXReader } from \"./GMXReader.sol\";\nimport { GMXChecks } from \"./GMXChecks.sol\";\nimport { GMXManager } from \"./GMXManager.sol\";\nimport { GMXProcessDeposit } from \"./GMXProcessDeposit.sol\";\n\n/**\n  * @title GMXDeposit\n  * @author Steadefi\n  * @notice Re-usable library functions for deposit operations for Steadefi leveraged vaults\n*/\nlibrary GMXDeposit {\n  using SafeERC20 for IERC20;\n\n  /* ======================= CONSTANTS ======================= */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n\n  /* ======================== EVENTS ========================= */\n\n  event DepositCreated(\n    address indexed user,\n    address asset,\n    uint256 assetAmt\n  );\n  event DepositCompleted(\n    address indexed user,\n    uint256 shareAmt,\n    uint256 equityBefore,\n    uint256 equityAfter\n  );\n  event DepositCancelled(\n    address indexed user\n  );\n  event DepositFailed(bytes reason);\n\n  /* ================== MUTATIVE FUNCTIONS =================== */\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n    * @param isNative Boolean as to whether user is depositing native asset (e.g. ETH, AVAX, etc.)\n  */\n  function deposit(\n    GMXTypes.Store storage self,\n    GMXTypes.DepositParams memory dp,\n    bool isNative\n  ) external {\n    // Sweep any tokenA/B in vault to the temporary trove for future compouding and to prevent\n    // it from being considered as part of depositor's assets\n    if (self.tokenA.balanceOf(address(this)) > 0) {\n      self.tokenA.safeTransfer(self.trove, self.tokenA.balanceOf(address(this)));\n    }\n    if (self.tokenB.balanceOf(address(this)) > 0) {\n      self.tokenB.safeTransfer(self.trove, self.tokenB.balanceOf(address(this)));\n    }\n\n    self.refundee = payable(msg.sender);\n\n    GMXTypes.HealthParams memory _hp;\n\n    _hp.equityBefore = GMXReader.equityValue(self);\n    _hp.lpAmtBefore = GMXReader.lpAmt(self);\n    _hp.debtRatioBefore = GMXReader.debtRatio(self);\n    _hp.deltaBefore = GMXReader.delta(self);\n\n    // Transfer assets from user to vault\n    if (isNative) {\n      GMXChecks.beforeNativeDepositChecks(self, dp);\n\n      self.WNT.deposit{ value: dp.amt }();\n    } else {\n      IERC20(dp.token).safeTransferFrom(msg.sender, address(this), dp.amt);\n    }\n\n    GMXTypes.DepositCache memory _dc;\n\n    _dc.user = payable(msg.sender);\n\n    if (dp.token == address(self.lpToken)) {\n      // If LP token deposited\n      _dc.depositValue = self.gmxOracle.getLpTokenValue(\n        address(self.lpToken),\n        address(self.tokenA),\n        address(self.tokenA),\n        address(self.tokenB),\n        false,\n        false\n      )\n      * dp.amt\n      / SAFE_MULTIPLIER;\n    } else {\n      // If tokenA or tokenB deposited\n      _dc.depositValue = GMXReader.convertToUsdValue(\n        self,\n        address(dp.token),\n        dp.amt\n      );\n    }\n    _dc.depositParams = dp;\n    _dc.healthParams = _hp;\n\n    self.depositCache = _dc;\n\n    GMXChecks.beforeDepositChecks(self, _dc.depositValue);\n\n    self.status = GMXTypes.Status.Deposit;\n\n    self.vault.mintFee();\n\n    // Borrow assets and create deposit in GMX\n    (\n      uint256 _borrowTokenAAmt,\n      uint256 _borrowTokenBAmt\n    ) = GMXManager.calcBorrow(self, _dc.depositValue);\n\n    _dc.borrowParams.borrowTokenAAmt = _borrowTokenAAmt;\n    _dc.borrowParams.borrowTokenBAmt = _borrowTokenBAmt;\n\n    GMXManager.borrow(self, _borrowTokenAAmt, _borrowTokenBAmt);\n\n    GMXTypes.AddLiquidityParams memory _alp;\n\n    _alp.tokenAAmt = self.tokenA.balanceOf(address(this));\n    _alp.tokenBAmt = self.tokenB.balanceOf(address(this));\n    _alp.minMarketTokenAmt = GMXManager.calcMinMarketSlippageAmt(\n      self,\n      _dc.depositValue,\n      dp.slippage\n    );\n    _alp.executionFee = dp.executionFee;\n\n    _dc.depositKey = GMXManager.addLiquidity(\n      self,\n      _alp\n    );\n\n    self.depositCache = _dc;\n\n    emit DepositCreated(\n      _dc.user,\n      _dc.depositParams.token,\n      _dc.depositParams.amt\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processDeposit(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessDepositChecks(self);\n\n    // We transfer the core logic of this function to GMXProcessDeposit.processDeposit()\n    // to allow try/catch here to catch for any issues or any checks in afterDepositChecks() failing.\n    // If there are any issues, a DepositFailed event will be emitted and processDepositFailure()\n    // should be triggered to refund assets accordingly and reset the vault status to Open again.\n    try GMXProcessDeposit.processDeposit(self) {\n      // Mint shares to depositor\n      self.vault.mint(self.depositCache.user, self.depositCache.sharesToUser);\n\n      self.status = GMXTypes.Status.Open;\n\n      emit DepositCompleted(\n        self.depositCache.user,\n        self.depositCache.sharesToUser,\n        self.depositCache.healthParams.equityBefore,\n        self.depositCache.healthParams.equityAfter\n      );\n    } catch (bytes memory reason) {\n      self.status = GMXTypes.Status.Deposit_Failed;\n\n      emit DepositFailed(reason);\n    }\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processDepositCancellation(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessDepositCancellationChecks(self);\n\n    // Repay borrowed assets\n    GMXManager.repay(\n      self,\n      self.depositCache.borrowParams.borrowTokenAAmt,\n      self.depositCache.borrowParams.borrowTokenBAmt\n    );\n\n    // Return user's deposited asset\n    // If native token is being withdrawn, we convert wrapped to native\n    if (self.depositCache.depositParams.token == address(self.WNT)) {\n      self.WNT.withdraw(self.WNT.balanceOf(address(this)));\n      (bool success, ) = self.depositCache.user.call{value: address(this).balance}(\"\");\n      require(success, \"Transfer failed.\");\n    } else {\n      // Transfer requested withdraw asset to user\n      IERC20(self.depositCache.depositParams.token).safeTransfer(\n        self.depositCache.user,\n        self.depositCache.depositParams.amt\n      );\n    }\n\n    self.status = GMXTypes.Status.Open;\n\n    emit DepositCancelled(self.depositCache.user);\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processDepositFailure(\n    GMXTypes.Store storage self,\n    uint256 slippage,\n    uint256 executionFee\n  ) external {\n    GMXChecks.beforeProcessAfterDepositFailureChecks(self);\n\n    GMXTypes.RemoveLiquidityParams memory _rlp;\n\n    // If current LP amount is somehow less or equal to amount before, we do not remove any liquidity\n    if (GMXReader.lpAmt(self) <= self.depositCache.healthParams.lpAmtBefore) {\n      processDepositFailureLiquidityWithdrawal(self);\n    } else {\n      // Remove only the newly added LP amount\n      _rlp.lpAmt = GMXReader.lpAmt(self) - self.depositCache.healthParams.lpAmtBefore;\n\n      // If delta strategy is Long, remove all in tokenB to make it more\n      // efficent to repay tokenB debt as Long strategy only borrows tokenB\n      if (self.delta == GMXTypes.Delta.Long) {\n        address[] memory _tokenASwapPath = new address[](1);\n        _tokenASwapPath[0] = address(self.lpToken);\n        _rlp.tokenASwapPath = _tokenASwapPath;\n\n        (_rlp.minTokenAAmt, _rlp.minTokenBAmt) = GMXManager.calcMinTokensSlippageAmt(\n          self,\n          _rlp.lpAmt,\n          address(self.tokenB),\n          address(self.tokenB),\n          slippage\n        );\n      } else {\n        (_rlp.minTokenAAmt, _rlp.minTokenBAmt) = GMXManager.calcMinTokensSlippageAmt(\n          self,\n          _rlp.lpAmt,\n          address(self.tokenA),\n          address(self.tokenB),\n          slippage\n        );\n      }\n\n      _rlp.executionFee = executionFee;\n\n      // Remove liqudity\n      self.depositCache.withdrawKey = GMXManager.removeLiquidity(\n        self,\n        _rlp\n      );\n    }\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processDepositFailureLiquidityWithdrawal(\n    GMXTypes.Store storage self\n  ) public {\n    GMXChecks.beforeProcessAfterDepositFailureLiquidityWithdrawal(self);\n\n    GMXTypes.RepayParams memory _rp;\n\n    _rp.repayTokenAAmt = self.depositCache.borrowParams.borrowTokenAAmt;\n    _rp.repayTokenBAmt = self.depositCache.borrowParams.borrowTokenBAmt;\n\n    // Check if swap between assets are needed for repayment based on previous borrow\n    (\n      bool _swapNeeded,\n      address _tokenFrom,\n      address _tokenTo,\n      uint256 _tokenToAmt\n    ) = GMXManager.calcSwapForRepay(self, _rp);\n\n    if (_swapNeeded) {\n      ISwap.SwapParams memory _sp;\n\n      _sp.tokenIn = _tokenFrom;\n      _sp.tokenOut = _tokenTo;\n      _sp.amountIn = IERC20(_tokenFrom).balanceOf(address(this));\n      _sp.amountOut = _tokenToAmt;\n      _sp.slippage = self.minSlippage;\n      _sp.deadline = block.timestamp;\n      // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n      // We allow deadline to be set as the current block timestamp whenever this function\n      // is called because this function is triggered as a follow up function (by a callback/keeper)\n      // and not directly by a user/keeper. If this follow on function flow reverts due to this tx\n      // being processed after a set deadline, this will cause the vault to be in a \"stuck\" state.\n      // To resolve this, this function will have to be called again with an updated deadline until it\n      // succeeds/a miner processes the tx.\n\n      GMXManager.swapTokensForExactTokens(self, _sp);\n    }\n\n    // Adjust amount to repay for both tokens due to slight differences\n    // from liqudiity withdrawal and swaps. If the amount to repay based on previous borrow\n    // is more than the available balance vault has, we simply repay what the vault has\n    uint256 _repayTokenAAmt;\n    uint256 _repayTokenBAmt;\n\n    if (self.depositCache.borrowParams.borrowTokenAAmt > self.tokenA.balanceOf(address(this))) {\n      _repayTokenAAmt = self.tokenA.balanceOf(address(this));\n    } else {\n      _repayTokenAAmt = self.depositCache.borrowParams.borrowTokenAAmt;\n    }\n\n    if (self.depositCache.borrowParams.borrowTokenBAmt > self.tokenB.balanceOf(address(this))) {\n      _repayTokenBAmt = self.tokenB.balanceOf(address(this));\n    } else {\n      _repayTokenBAmt = self.depositCache.borrowParams.borrowTokenBAmt;\n    }\n\n    // Repay borrowed assets\n    GMXManager.repay(\n      self,\n      _repayTokenAAmt,\n      _repayTokenBAmt\n    );\n\n    // Refund user the rest of the remaining withdrawn LP assets\n    // Will be in tokenA/tokenB only; so if user deposited LP tokens\n    // they will still be refunded in tokenA/tokenB\n    self.tokenA.safeTransfer(self.depositCache.user, self.tokenA.balanceOf(address(this)));\n    self.tokenB.safeTransfer(self.depositCache.user, self.tokenB.balanceOf(address(this)));\n\n    self.status = GMXTypes.Status.Open;\n  }\n}"
    },
    {
      "filename": "contracts/strategy/gmx/GMXDeposit.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IDeposit } from \"../../interfaces/protocols/gmx/IDeposit.sol\";\nimport { IWithdrawal } from \"../../interfaces/protocols/gmx/IWithdrawal.sol\";\nimport { IEvent } from \"../../interfaces/protocols/gmx/IEvent.sol\";\nimport { IOrder } from \"../../interfaces/protocols/gmx/IOrder.sol\";\nimport { ISwap } from  \"../../interfaces/swap/ISwap.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXReader } from \"./GMXReader.sol\";\nimport { GMXChecks } from \"./GMXChecks.sol\";\nimport { GMXManager } from \"./GMXManager.sol\";\nimport { GMXProcessDeposit } from \"./GMXProcessDeposit.sol\";\n\n/**\n  * @title GMXDeposit\n  * @author Steadefi\n  * @notice Re-usable library functions for deposit operations for Steadefi leveraged vaults\n*/\nlibrary GMXDeposit {\n  using SafeERC20 for IERC20;\n\n  /* ======================= CONSTANTS ======================= */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n\n  /* ======================== EVENTS ========================= */\n\n  event DepositCreated(\n    address indexed user,\n    address asset,\n    uint256 assetAmt\n  );\n  event DepositCompleted(\n    address indexed user,\n    uint256 shareAmt,\n    uint256 equityBefore,\n    uint256 equityAfter\n  );\n  event DepositCancelled(\n    address indexed user\n  );\n  event DepositFailed(bytes reason);\n\n  /* ================== MUTATIVE FUNCTIONS =================== */\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n    * @param isNative Boolean as to whether user is depositing native asset (e.g. ETH, AVAX, etc.)\n  */\n  function deposit(\n    GMXTypes.Store storage self,\n    GMXTypes.DepositParams memory dp,\n    bool isNative\n  ) external {\n    // Sweep any tokenA/B in vault to the temporary trove for future compouding and to prevent\n    // it from being considered as part of depositor's assets\n    if (self.tokenA.balanceOf(address(this)) > 0) {\n      self.tokenA.safeTransfer(self.trove, self.tokenA.balanceOf(address(this)));\n    }\n    if (self.tokenB.balanceOf(address(this)) > 0) {\n      self.tokenB.safeTransfer(self.trove, self.tokenB.balanceOf(address(this)));\n    }\n\n    self.refundee = payable(msg.sender);\n\n    GMXTypes.HealthParams memory _hp;\n\n    _hp.equityBefore = GMXReader.equityValue(self);\n    _hp.lpAmtBefore = GMXReader.lpAmt(self);\n    _hp.debtRatioBefore = GMXReader.debtRatio(self);\n    _hp.deltaBefore = GMXReader.delta(self);\n\n    // Transfer assets from user to vault\n    if (isNative) {\n      GMXChecks.beforeNativeDepositChecks(self, dp);\n\n      self.WNT.deposit{ value: dp.amt }();\n    } else {\n      IERC20(dp.token).safeTransferFrom(msg.sender, address(this), dp.amt);\n    }\n\n    GMXTypes.DepositCache memory _dc;\n\n    _dc.user = payable(msg.sender);\n\n    if (dp.token == address(self.lpToken)) {\n      // If LP token deposited\n      _dc.depositValue = self.gmxOracle.getLpTokenValue(\n        address(self.lpToken),\n        address(self.tokenA),\n        address(self.tokenA),\n        address(self.tokenB),\n        false,\n        false\n      )\n      * dp.amt\n      / SAFE_MULTIPLIER;\n    } else {\n      // If tokenA or tokenB deposited\n      _dc.depositValue = GMXReader.convertToUsdValue(\n        self,\n        address(dp.token),\n        dp.amt\n      );\n    }\n    _dc.depositParams = dp;\n    _dc.healthParams = _hp;\n\n    self.depositCache = _dc;\n\n    GMXChecks.beforeDepositChecks(self, _dc.depositValue);\n\n    self.status = GMXTypes.Status.Deposit;\n\n    self.vault.mintFee();\n\n    // Borrow assets and create deposit in GMX\n    (\n      uint256 _borrowTokenAAmt,\n      uint256 _borrowTokenBAmt\n    ) = GMXManager.calcBorrow(self, _dc.depositValue);\n\n    _dc.borrowParams.borrowTokenAAmt = _borrowTokenAAmt;\n    _dc.borrowParams.borrowTokenBAmt = _borrowTokenBAmt;\n\n    GMXManager.borrow(self, _borrowTokenAAmt, _borrowTokenBAmt);\n\n    GMXTypes.AddLiquidityParams memory _alp;\n\n    _alp.tokenAAmt = self.tokenA.balanceOf(address(this));\n    _alp.tokenBAmt = self.tokenB.balanceOf(address(this));\n    _alp.minMarketTokenAmt = GMXManager.calcMinMarketSlippageAmt(\n      self,\n      _dc.depositValue,\n      dp.slippage\n    );\n    _alp.executionFee = dp.executionFee;\n\n    _dc.depositKey = GMXManager.addLiquidity(\n      self,\n      _alp\n    );\n\n    self.depositCache = _dc;\n\n    emit DepositCreated(\n      _dc.user,\n      _dc.depositParams.token,\n      _dc.depositParams.amt\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processDeposit(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessDepositChecks(self);\n\n    // We transfer the core logic of this function to GMXProcessDeposit.processDeposit()\n    // to allow try/catch here to catch for any issues or any checks in afterDepositChecks() failing.\n    // If there are any issues, a DepositFailed event will be emitted and processDepositFailure()\n    // should be triggered to refund assets accordingly and reset the vault status to Open again.\n    try GMXProcessDeposit.processDeposit(self) {\n      // Mint shares to depositor\n      self.vault.mint(self.depositCache.user, self.depositCache.sharesToUser);\n\n      self.status = GMXTypes.Status.Open;\n\n      emit DepositCompleted(\n        self.depositCache.user,\n        self.depositCache.sharesToUser,\n        self.depositCache.healthParams.equityBefore,\n        self.depositCache.healthParams.equityAfter\n      );\n    } catch (bytes memory reason) {\n      self.status = GMXTypes.Status.Deposit_Failed;\n\n      emit DepositFailed(reason);\n    }\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processDepositCancellation(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessDepositCancellationChecks(self);\n\n    // Repay borrowed assets\n    GMXManager.repay(\n      self,\n      self.depositCache.borrowParams.borrowTokenAAmt,\n      self.depositCache.borrowParams.borrowTokenBAmt\n    );\n\n    // Return user's deposited asset\n    // If native token is being withdrawn, we convert wrapped to native\n    if (self.depositCache.depositParams.token == address(self.WNT)) {\n      self.WNT.withdraw(self.WNT.balanceOf(address(this)));\n      (bool success, ) = self.depositCache.user.call{value: address(this).balance}(\"\");\n      require(success, \"Transfer failed.\");\n    } else {\n      // Transfer requested withdraw asset to user\n      IERC20(self.depositCache.depositParams.token).safeTransfer(\n        self.depositCache.user,\n        self.depositCache.depositParams.amt\n      );\n    }\n\n    self.status = GMXTypes.Status.Open;\n\n    emit DepositCancelled(self.depositCache.user);\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processDepositFailure(\n    GMXTypes.Store storage self,\n    uint256 slippage,\n    uint256 executionFee\n  ) external {\n    GMXChecks.beforeProcessAfterDepositFailureChecks(self);\n\n    GMXTypes.RemoveLiquidityParams memory _rlp;\n\n    // If current LP amount is somehow less or equal to amount before, we do not remove any liquidity\n    if (GMXReader.lpAmt(self) <= self.depositCache.healthParams.lpAmtBefore) {\n      processDepositFailureLiquidityWithdrawal(self);\n    } else {\n      // Remove only the newly added LP amount\n      _rlp.lpAmt = GMXReader.lpAmt(self) - self.depositCache.healthParams.lpAmtBefore;\n\n      // If delta strategy is Long, remove all in tokenB to make it more\n      // efficent to repay tokenB debt as Long strategy only borrows tokenB\n      if (self.delta == GMXTypes.Delta.Long) {\n        address[] memory _tokenASwapPath = new address[](1);\n        _tokenASwapPath[0] = address(self.lpToken);\n        _rlp.tokenASwapPath = _tokenASwapPath;\n\n        (_rlp.minTokenAAmt, _rlp.minTokenBAmt) = GMXManager.calcMinTokensSlippageAmt(\n          self,\n          _rlp.lpAmt,\n          address(self.tokenB),\n          address(self.tokenB),\n          slippage\n        );\n      } else {\n        (_rlp.minTokenAAmt, _rlp.minTokenBAmt) = GMXManager.calcMinTokensSlippageAmt(\n          self,\n          _rlp.lpAmt,\n          address(self.tokenA),\n          address(self.tokenB),\n          slippage\n        );\n      }\n\n      _rlp.executionFee = executionFee;\n\n      // Remove liqudity\n      self.depositCache.withdrawKey = GMXManager.removeLiquidity(\n        self,\n        _rlp\n      );\n    }\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processDepositFailureLiquidityWithdrawal(\n    GMXTypes.Store storage self\n  ) public {\n    GMXChecks.beforeProcessAfterDepositFailureLiquidityWithdrawal(self);\n\n    GMXTypes.RepayParams memory _rp;\n\n    _rp.repayTokenAAmt = self.depositCache.borrowParams.borrowTokenAAmt;\n    _rp.repayTokenBAmt = self.depositCache.borrowParams.borrowTokenBAmt;\n\n    // Check if swap between assets are needed for repayment based on previous borrow\n    (\n      bool _swapNeeded,\n      address _tokenFrom,\n      address _tokenTo,\n      uint256 _tokenToAmt\n    ) = GMXManager.calcSwapForRepay(self, _rp);\n\n    if (_swapNeeded) {\n      ISwap.SwapParams memory _sp;\n\n      _sp.tokenIn = _tokenFrom;\n      _sp.tokenOut = _tokenTo;\n      _sp.amountIn = IERC20(_tokenFrom).balanceOf(address(this));\n      _sp.amountOut = _tokenToAmt;\n      _sp.slippage = self.minSlippage;\n      _sp.deadline = block.timestamp;\n      // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n      // We allow deadline to be set as the current block timestamp whenever this function\n      // is called because this function is triggered as a follow up function (by a callback/keeper)\n      // and not directly by a user/keeper. If this follow on function flow reverts due to this tx\n      // being processed after a set deadline, this will cause the vault to be in a \"stuck\" state.\n      // To resolve this, this function will have to be called again with an updated deadline until it\n      // succeeds/a miner processes the tx.\n\n      GMXManager.swapTokensForExactTokens(self, _sp);\n    }\n\n    // Adjust amount to repay for both tokens due to slight differences\n    // from liqudiity withdrawal and swaps. If the amount to repay based on previous borrow\n    // is more than the available balance vault has, we simply repay what the vault has\n    uint256 _repayTokenAAmt;\n    uint256 _repayTokenBAmt;\n\n    if (self.depositCache.borrowParams.borrowTokenAAmt > self.tokenA.balanceOf(address(this))) {\n      _repayTokenAAmt = self.tokenA.balanceOf(address(this));\n    } else {\n      _repayTokenAAmt = self.depositCache.borrowParams.borrowTokenAAmt;\n    }\n\n    if (self.depositCache.borrowParams.borrowTokenBAmt > self.tokenB.balanceOf(address(this))) {\n      _repayTokenBAmt = self.tokenB.balanceOf(address(this));\n    } else {\n      _repayTokenBAmt = self.depositCache.borrowParams.borrowTokenBAmt;\n    }\n\n    // Repay borrowed assets\n    GMXManager.repay(\n      self,\n      _repayTokenAAmt,\n      _repayTokenBAmt\n    );\n\n    // Refund user the rest of the remaining withdrawn LP assets\n    // Will be in tokenA/tokenB only; so if user deposited LP tokens\n    // they will still be refunded in tokenA/tokenB\n    self.tokenA.safeTransfer(self.depositCache.user, self.tokenA.balanceOf(address(this)));\n    self.tokenB.safeTransfer(self.depositCache.user, self.tokenB.balanceOf(address(this)));\n\n    self.status = GMXTypes.Status.Open;\n  }\n}"
    },
    {
      "filename": "contracts/strategy/gmx/GMXChecks.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IDeposit } from \"../../interfaces/protocols/gmx/IDeposit.sol\";\nimport { IWithdrawal } from \"../../interfaces/protocols/gmx/IWithdrawal.sol\";\nimport { IEvent } from \"../../interfaces/protocols/gmx/IEvent.sol\";\nimport { IOrder } from \"../../interfaces/protocols/gmx/IOrder.sol\";\nimport { Errors } from \"../../utils/Errors.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXReader } from \"./GMXReader.sol\";\n\n/**\n  * @title GMXChecks\n  * @author Steadefi\n  * @notice Re-usable library functions for require function checks for Steadefi leveraged vaults\n*/\nlibrary GMXChecks {\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n  uint256 public constant MINIMUM_VALUE = 9e16;\n\n  /* ===================== VIEW FUNCTIONS ==================== */\n\n  /**\n    * @notice Checks before native token deposit\n    * @param self GMXTypes.Store\n    * @param dp GMXTypes.DepositParams\n  */\n  function beforeNativeDepositChecks(\n    GMXTypes.Store storage self,\n    GMXTypes.DepositParams memory dp\n  ) external view {\n    if (dp.token != address(self.WNT))\n      revert Errors.InvalidNativeTokenAddress();\n\n    if (\n      address(self.tokenA) != address(self.WNT) &&\n      address(self.tokenB) != address(self.WNT)\n    ) revert Errors.OnlyNonNativeDepositToken();\n\n    if (dp.amt == 0) revert Errors.EmptyDepositAmount();\n\n    if (dp.amt + dp.executionFee != msg.value)\n      revert Errors.DepositAndExecutionFeeDoesNotMatchMsgValue();\n  }\n\n  /**\n    * @notice Checks before token deposit\n    * @param self GMXTypes.Store\n    * @param depositValue USD value in 1e18\n  */\n  function beforeDepositChecks(\n    GMXTypes.Store storage self,\n    uint256 depositValue\n  ) external view {\n    if (self.status != GMXTypes.Status.Open)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n\n    if (self.depositCache.depositParams.executionFee < self.minExecutionFee)\n      revert Errors.InsufficientExecutionFeeAmount();\n\n    if (!self.vault.isTokenWhitelisted(self.depositCache.depositParams.token))\n      revert Errors.InvalidDepositToken();\n\n    if (self.depositCache.depositParams.amt == 0)\n      revert Errors.InsufficientDepositAmount();\n\n    if (self.depositCache.depositParams.slippage < self.minSlippage)\n      revert Errors.InsufficientSlippageAmount();\n\n    if (depositValue == 0)\n      revert Errors.InsufficientDepositAmount();\n\n    if (depositValue < MINIMUM_VALUE)\n      revert Errors.InsufficientDepositAmount();\n\n    if (depositValue > GMXReader.additionalCapacity(self))\n      revert Errors.InsufficientLendingLiquidity();\n  }\n\n  /**\n    * @notice Checks before processing deposit\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessDepositChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Deposit)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks after deposit\n    * @param self GMXTypes.Store\n  */\n  function afterDepositChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    // Guards: revert if lpAmt did not increase at all\n    if (GMXReader.lpAmt(self) <= self.depositCache.healthParams.lpAmtBefore)\n      revert Errors.InsufficientLPTokensMinted();\n\n    // Guards: check that debt ratio is within step change range\n    if (!_isWithinStepChange(\n      self.depositCache.healthParams.debtRatioBefore,\n      GMXReader.debtRatio(self),\n      self.debtRatioStepThreshold\n    )) revert Errors.InvalidDebtRatio();\n\n    // Slippage: Check whether user received enough shares as expected\n    if (\n      self.depositCache.sharesToUser <\n      self.depositCache.depositParams.minSharesAmt\n    ) revert Errors.InsufficientSharesMinted();\n  }\n\n  /**\n    * @notice Checks before processing deposit cancellation\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessDepositCancellationChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Deposit)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks before processing after deposit check failure\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessAfterDepositFailureChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Deposit_Failed)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks before processing after deposit failure's liquidity withdrawn\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessAfterDepositFailureLiquidityWithdrawal(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Deposit_Failed)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks before vault withdrawal\n    * @param self GMXTypes.Store\n\n  */\n  function beforeWithdrawChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Open)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n\n    if (!self.vault.isTokenWhitelisted(self.withdrawCache.withdrawParams.token))\n      revert Errors.InvalidWithdrawToken();\n\n    if (self.withdrawCache.withdrawParams.shareAmt == 0)\n      revert Errors.EmptyWithdrawAmount();\n\n    if (\n      self.withdrawCache.withdrawParams.shareAmt >\n      IERC20(address(self.vault)).balanceOf(self.withdrawCache.user)\n    ) revert Errors.InsufficientWithdrawBalance();\n\n    if (self.withdrawCache.withdrawValue < MINIMUM_VALUE)\n      revert Errors.InsufficientWithdrawAmount();\n\n    if (self.withdrawCache.withdrawParams.slippage < self.minSlippage)\n      revert Errors.InsufficientSlippageAmount();\n\n    if (self.withdrawCache.withdrawParams.executionFee < self.minExecutionFee)\n      revert Errors.InsufficientExecutionFeeAmount();\n\n    if (self.withdrawCache.withdrawParams.executionFee != msg.value)\n      revert Errors.InvalidExecutionFeeAmount();\n  }\n\n  /**\n    * @notice Checks before processing vault withdrawal\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessWithdrawChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Withdraw)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks after token withdrawal\n    * @param self GMXTypes.Store\n  */\n  function afterWithdrawChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    // Guards: revert if lpAmt did not decrease at all\n    if (GMXReader.lpAmt(self) >= self.withdrawCache.healthParams.lpAmtBefore)\n      revert Errors.InsufficientLPTokensBurned();\n\n    // Guards: revert if equity did not decrease at all\n    if (\n      self.withdrawCache.healthParams.equityAfter >=\n      self.withdrawCache.healthParams.equityBefore\n    ) revert Errors.InvalidEquityAfterWithdraw();\n\n    // Guards: check that debt ratio is within step change range\n    if (!_isWithinStepChange(\n      self.withdrawCache.healthParams.debtRatioBefore,\n      GMXReader.debtRatio(self),\n      self.debtRatioStepThreshold\n    )) revert Errors.InvalidDebtRatio();\n\n    // Check that user received enough assets as expected\n    if (\n      self.withdrawCache.tokensToUser <\n      self.withdrawCache.withdrawParams.minWithdrawTokenAmt\n    ) revert Errors.InsufficientAssetsReceived();\n  }\n\n  /**\n    * @notice Checks before processing withdrawal cancellation\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessWithdrawCancellationChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Withdraw)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks before processing after withdrawal failure\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessAfterWithdrawFailureChecks(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Withdraw_Failed)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks before processing after withdraw failure's liquidity added\n    * @param self GMXTypes.Store\n  */\n  function beforeProcessAfterWithdrawFailureLiquidityAdded(\n    GMXTypes.Store storage self\n  ) external view {\n    if (self.status != GMXTypes.Status.Withdraw_Failed)\n      revert Errors.NotAllowedInCurrentVaultStatus();\n  }\n\n  /**\n    * @notice Checks before rebalancing\n    * @param self GMXTypes.Store\n    * @param rebalanceType GMXTypes.RebalanceType\n  */\n  function beforeRebalanceChecks(\n    GMXTypes.Store storage self,\n    GMXTypes.RebalanceType rebalanceType\n  ) external view {\n    if (\n      self.status != GMXTypes.Status.Open &&\n      self.status != GMXTypes.Status.Rebalance_Open\n    ) revert Errors.NotAllowedInCurrentVaultStatus();\n\n    // Check that rebalance type is Delta or Debt\n    // And then check that rebalance conditions are met\n    // Note that Delta rebalancing requires vault's delta strategy to be Neutral as well\n    if (rebalanceType == GMXTypes.RebalanceType.Delta && self.delta == GMXTypes.Delta.Neutral) {\n      if (\n        self.rebalanceCache.healthParams.deltaBefore < self.deltaUpperLimit &&\n        self.rebalanceCache.healthParams.deltaBefore > self.deltaLowerLimit\n      ) revert Errors.InvalidRebalancePreConditions();\n    } else if (rebalanceType == GMXTypes.RebalanceType.Debt) {\n      if (\n        self.rebalanceCache.healthParams.debtRatioBefore < self.debtRatioUpperLimit &&\n        self.rebalanceCache.healthParams.debtRatioBefore > self.debtRatioLowerLimit\n      ) revert Errors.InvalidRebalancePreConditions();\n    } else {\n       revert Errors.InvalidRebalanceParameters();\n    }\n  }\n\n  /**\n    * @notice Checks before processing of rebalancing add or"
    }
  ]
}