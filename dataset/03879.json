{
  "Title": "[L03] Duplicated code",
  "Content": "Throughout the codebase there are examples of duplicated code. Duplicating code can lead to issues later in the development lifecycle and leaves the project more prone to the introduction of errors. Errors can inadvertently be introduced when functionality changes are not replicated across all instances of code that should be identical. Instead of duplicating code, consider having just one function/modifier/contract containing the duplicated code and using *that* whenever the duplicated functionality is required. Examples of duplicated code include, but are not limited to:\n\n\n* The [`SeniorBond`](https://github.com/BarnBridge/BarnBridge-SmartYieldBonds/blob/943df3a8fcd8dd128af3beb0c85a0480c0e95ead/contracts/SeniorBond.sol) and [`JuniorBond`](https://github.com/BarnBridge/BarnBridge-SmartYieldBonds/blob/943df3a8fcd8dd128af3beb0c85a0480c0e95ead/contracts/JuniorBond.sol) contracts. Consider instead having one common `Bond` contract.\n* Conversions from `uToken` to `cToken`, and vice versa throughout [`CompoundProvider`](https://github.com/BarnBridge/BarnBridge-SmartYieldBonds/blob/943df3a8fcd8dd128af3beb0c85a0480c0e95ead/contracts/providers/CompoundProvider.sol). Consider creating helper functions to perform this conversion.\n* The check whether `msg.sender == smartYield` is repeated twice in each of [`SeniorBond`](https://github.com/BarnBridge/BarnBridge-SmartYieldBonds/blob/943df3a8fcd8dd128af3beb0c85a0480c0e95ead/contracts/SeniorBond.sol) and [`JuniorBond`](https://github.com/BarnBridge/BarnBridge-SmartYieldBonds/blob/943df3a8fcd8dd128af3beb0c85a0480c0e95ead/contracts/JuniorBond.sol). Consider having a common modifier to perform this check.\n* The majority of the [`currentCumulatives`](https://github.com/BarnBridge/BarnBridge-SmartYieldBonds/blob/943df3a8fcd8dd128af3beb0c85a0480c0e95ead/contracts/providers/CompoundProvider.sol#L247) and [`_accountYieldInternal`](https://github.com/BarnBridge/BarnBridge-SmartYieldBonds/blob/943df3a8fcd8dd128af3beb0c85a0480c0e95ead/contracts/providers/CompoundProvider.sol#L333) functions are identical. Consider factoring out the identical code into a common helper function.\n\n\n**Update**: *Not fixed. The second and fourth points are outside the scope of fix review, given the extensive changes to the relevant contract. The first and third points of this issue were not addressed. In regards to the first point, the BarnBridge team stated: “We decided to keep the two contracts (SeniorBond, JuniorBond) separate, this should give us flexibility for future developments.”*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/providers/CompoundProvider.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./../external-interfaces/uniswap/IUniswapV2Router.sol\";\nimport \"./../external-interfaces/compound-finance/ICToken.sol\";\nimport \"./../external-interfaces/compound-finance/IComptroller.sol\";\n\nimport \"./../lib/math/MathUtils.sol\";\n\nimport \"./CompoundController.sol\";\nimport \"./../oracle/IYieldOracle.sol\";\nimport \"./../IProvider.sol\";\n\ncontract CompoundProvider is IProvider {\n    using SafeMath for uint256;\n\n    // underlying token (ie. DAI)\n    address public uToken; // IERC20\n\n    // claim token (ie. cDAI)\n    address public cToken;\n\n    // compound.finance Comptroller\n    address public comptroller; // IComptroller\n\n    // deposit reward token (ie. COMP)\n    address public rewardCToken; // IERC20\n\n    // cToken.balanceOf(this) measuring only deposits by users (excludes dirrect cToken transfers to pool)\n    uint256 public cTokenBalance;\n\n    // --- COMP reward checkpoint\n    // saved comptroller.compSupplyState(cToken) value @ the moment the pool harvested\n    uint256 public compSupplierIndexLast;\n\n    // cumulative balanceOf @ last harvest\n    uint256 public cumulativeUnderlyingBalanceHarvestedLast;\n\n    // when we last harvested\n    uint256 public harvestedLast;\n    // --- /COMP reward checkpoint\n\n    bool public _setup;\n\n    modifier accountYield {\n        _accountYieldInternal();\n        IYieldOracle(IController(this.controller()).oracle()).update();\n\n        _;\n\n        underlyingBalanceLast = this.underlyingBalance();\n    }\n\n    function setup(\n        address smartYield_,\n        address controller_,\n        address cToken_\n    )\n      external\n    {\n        require(\n          false == _setup,\n          \"PPC: already setup\"\n        );\n\n        smartYield = smartYield_;\n        controller = controller_;\n        cToken = cToken_;\n        uToken = ICToken(cToken_).underlying();\n        comptroller = ICToken(cToken_).comptroller();\n        rewardCToken = IComptroller(comptroller).getCompAddress();\n\n        _enterMarket();\n\n        _setup = true;\n    }\n\n  // externals\n\n    // take underlyingAmount_ from from_\n    function _takeUnderlying(address from_, uint256 underlyingAmount_)\n      external override\n      onlySmartYield\n    {\n        require(\n            underlyingAmount_ <= IERC20(uToken).allowance(from_, address(this)),\n            \"PPC: _takeUnderlying allowance\"\n        );\n        require(\n            IERC20(uToken).transferFrom(from_, address(this), underlyingAmount_),\n            \"PPC: _takeUnderlying transferFrom\"\n        );\n    }\n\n    // transfer away underlyingAmount_ to to_\n    function _sendUnderlying(address to_, uint256 underlyingAmount_)\n      external override\n      onlySmartYield\n      returns (bool)\n    {\n        return IERC20(uToken).transfer(to_, underlyingAmount_);\n    }\n\n    // deposit underlyingAmount_ with the liquidity provider adds resulting cTokens to cTokenBalance\n    // on the very first call enters the compound.finance market and saves the checkpoint needed for compRewardExpected\n    function _depositProvider(uint256 underlyingAmount_, uint256 takeFees_)\n      external override\n      onlySmartYield\n    {\n        _depositProviderInternal(underlyingAmount_, takeFees_);\n    }\n\n    // withdraw underlyingAmount_ from the liquidity provider, substract the lost cTokens from cTokenBalance\n    function _withdrawProvider(uint256 underlyingAmount_, uint256 takeFees_)\n      external override\n      onlySmartYield\n      accountYield\n    {\n        underlyingFees += takeFees_;\n\n        uint256 cTokensBefore = ICTokenErc20(cToken).balanceOf(address(this));\n        uint256 err = ICToken(cToken).redeemUnderlying(underlyingAmount_);\n        require(0 == err, \"PPC: _withdrawProvider redeemUnderlying\");\n        cTokenBalance -= cTokensBefore - ICTokenErc20(cToken).balanceOf(address(this));\n    }\n\n    // called by anyone to convert pool's COMP -> underlying and then deposit it. caller gets HARVEST_REWARD of the harvest\n    function harvest()\n      external override\n    {\n        require(\n          harvestedLast < this.currentTime(),\n          \"PPC: harvest later\"\n        );\n\n        // this is 0 unless someone transfers underlying to the contract\n        uint256 underlyingBefore = IERC20(uToken).balanceOf(address(this));\n\n        // COMP gets on the pool when:\n        // 1) pool calls comptroller.claimComp()\n        // 2) anyone calls comptroller.claimComp()\n        // 3) anyone transfers COMP to the pool\n        // we want to yield closest to 1+2 but not 3\n        uint256 rewardExpected = compRewardExpected(); // COMP\n\n        address[] memory holders = new address[](1);\n        holders[0] = address(this);\n        address[] memory markets = new address[](1);\n        markets[0] = cToken;\n\n        IComptroller(comptroller).claimComp(holders, markets, false, true);\n\n        _updateCompState();\n\n        uint256 rewardGot = IERC20(rewardCToken).balanceOf(address(this)); // COMP\n\n        if (rewardGot > 0) {\n            address uniswap = CompoundController(controller).uniswap();\n\n            // should be like:\n            // address[] memory path = new address[](3);\n            // path[0] = address(rewardCToken);\n            // path[1] = address(wethToken);\n            // path[2] = address(uToken);\n            address[] memory path = CompoundController(controller).getUniswapPath();\n\n            // TODO: optimize pre-approve uniswap, gas\n            IERC20(rewardCToken).approve(address(uniswap), rewardGot);\n\n            IUniswapV2Router(uniswap).swapExactTokensForTokens(\n                rewardGot,\n                uint256(0),\n                path,\n                address(this),\n                this.currentTime() + 1800\n            );\n        }\n\n        uint256 underlyingGot = IERC20(uToken).balanceOf(address(this));\n\n        if (underlyingGot == 0) {\n          // got no goodies :(\n          return;\n        }\n\n        uint256 extra;\n\n        if (underlyingBefore > 0) {\n          // someone sent us a present as underlying -> add it to the fees\n          extra = underlyingBefore;\n          underlyingGot -= extra;\n        }\n\n        if (rewardGot > rewardExpected) {\n          // moar present as COMP reward -> add it to the fees\n          // throw event\n          uint256 rExtra = MathUtils.fractionOf(underlyingGot, (rewardGot - rewardExpected) * 1e18 / rewardGot);\n          extra += rExtra;\n          underlyingGot -= rExtra;\n        }\n\n        uint256 toCaller = MathUtils.fractionOf(underlyingGot, CompoundController(controller).HARVEST_REWARD());\n\n        // deposit pool reward to compound - harvest reward + any goodies we received\n        // any extra goodies go to fees\n        _depositProviderInternal(underlyingGot - toCaller + extra, extra);\n\n        // pay this man\n        IERC20(uToken).transfer(msg.sender, IERC20(uToken).balanceOf(address(this)));\n    }\n\n    function transferFees()\n      external\n      override\n      accountYield\n    {\n      // cleanup any cTokens dust or cTokens that may have been dumped on the pool\n      if (ICTokenErc20(cToken).balanceOf(address(this)) > cTokenBalance) {\n        underlyingFees += ICToken(cToken).exchangeRateStored() * (ICTokenErc20(cToken).balanceOf(address(this)) - cTokenBalance) / 1e18;\n      }\n      uint256 ctokensToPay = underlyingFees * 1e18 / ICToken(cToken).exchangeRateStored();\n      uint256 err = ICToken(cToken).redeem(\n          MathUtils.min(ctokensToPay, ICTokenErc20(cToken).balanceOf(address(this)))\n      );\n      require(0 == err, \"PPC: transferFees redeem\");\n      underlyingFees = 0;\n      cTokenBalance = ICTokenErc20(cToken).balanceOf(address(this));\n      IERC20(uToken).transfer(IController(controller).feesOwner(), IERC20(uToken).balanceOf(address(this)));\n    }\n\n    // returns cumulatives and accumulates/updates internal state\n    // oracle should call this when updating\n    function cumulatives()\n      external override\n    returns(uint256 cumulativeSecondlyYield, uint256 cumulativeUnderlyingBalance) {\n        _accountYieldInternal();\n        underlyingBalanceLast = this.underlyingBalance();\n        return (cumulativeSecondlyYieldLast, cumulativeUnderlyingBalanceLast);\n    }\n\n    // returns cumulated yield per 1 underlying coin (ie 1 DAI, 1 ETH) times 1e18\n    // per https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/libraries/UniswapV2OracleLibrary.sol#L16\n    function currentCumulatives()\n      external view override\n    returns (uint256 cumulativeSecondlyYield, uint256 cumulativeUnderlyingBalance)\n    {\n        uint32 blockTimestamp = uint32(this.currentTime() % 2**32);\n        cumulativeSecondlyYield = cumulativeSecondlyYieldLast;\n        cumulativeUnderlyingBalance = cumulativeUnderlyingBalanceLast;\n\n        uint32 timeElapsed = blockTimestamp - cumulativeTimestampLast; // overflow is desired\n        if (timeElapsed > 0) {\n            if (underlyingBalanceLast > 0) {\n              // cumulativeSecondlyYield overflows eventually,\n              // due to the way it is used in the oracle that's ok,\n              // as long as it doesn't overflow twice during the windowSize\n              // see OraclelizedMock.cumulativeOverflowProof() for proof\n              cumulativeSecondlyYield +=\n                  // (this.underlyingBalance() - underlyingBalanceLast) * 1e18 -> overflows only if (this.underlyingBalance() - underlyingBalanceLast) >~ 10^41 ETH, DAI, USDC etc\n                  // (this.underlyingBalance() - underlyingBalanceLast) never underflows\n                  ((this.underlyingBalance() - underlyingBalanceLast) * 1e18) / underlyingBalanceLast;\n            }\n            cumulativeUnderlyingBalance += this.underlyingBalance() * timeElapsed;\n        }\n        return (cumulativeSecondlyYield, cumulativeUnderlyingBalance);\n    }\n\n    // current total underlying balance, as measured by pool\n    function underlyingBalance()\n      external view virtual override\n    returns (uint256)\n    {\n        // https://compound.finance/docs#protocol-math\n        return\n            cTokenBalance * ICToken(cToken).exchangeRateStored() / 1e18;\n    }\n\n  // /externals\n\n    function currentTime()\n      public view virtual override\n      returns (uint256)\n    {\n        // mockable\n        return block.timestamp;\n    }\n\n    // computes how much COMP tokens compound.finance will give us at comptroller.claimComp()\n    // note: have to do it because comptroller.claimComp() is callable by anyone\n    // source: https://github.com/compound-finance/compound-protocol/blob/master/contracts/Comptroller.sol#L1145\n    function compRewardExpected()\n      public view virtual\n      returns (uint256)\n    {\n        (uint224 supplyStateIndex, ) = IComptroller(comptroller).compSupplyState(cToken);\n        uint256 supplyIndex = uint256(supplyStateIndex);\n        uint256 supplierIndex = compSupplierIndexLast;\n\n        uint256 deltaIndex = (supplyIndex).sub(supplierIndex); // a - b\n        (, uint256 cumulativeUnderlyingBalanceNow) = this.currentCumulatives();\n        uint256 timeElapsed = this.currentTime() - harvestedLast; // harvest() has require\n\n        uint256 waUnderlyingTotal = ((cumulativeUnderlyingBalanceNow - cumulativeUnderlyingBalanceHarvestedLast) * 1e18 / timeElapsed);\n        // uint256 supplierTokens = ICTokenErc20(cToken).balanceOf(address(this))\n        uint256 supplierTokens = waUnderlyingTotal / ICToken(cToken).exchangeRateStored();\n        return (supplierTokens).mul(deltaIndex).div(1e36); // a * b / doubleScale => uint\n    }\n\n  // internals\n\n    function _depositProviderInternal(uint256 underlyingAmount_, uint256 takeFees_)\n      internal\n      accountYield\n    {\n        if (0 == cTokenBalance && 0 == compSupplierIndexLast) {\n          // this will be called once only for the first comp deposit after pool deploy\n          _updateCompState();\n        }\n        underlyingFees += takeFees_;\n\n        uint256 cTokensBefore = ICTokenErc20(cToken).balanceOf(address(this));\n        // TODO: optimization, pre-approve provider: gas\n        IERC20(uToken).approve(address(cToken), underlyingAmount_);\n        uint256 err = ICToken(cToken).mint(underlyingAmount_);\n        require(0 == err, \"PPC: _depositProvider mint\");\n        cTokenBalance += ICTokenErc20(cToken).balanceOf(address(this)) - cTokensBefore;\n    }\n\n    function _accountYieldInternal()\n      internal\n    {\n        uint32 blockTimestamp = uint32(this.currentTime() % 2**32);\n        uint32 timeElapsed = blockTimestamp - cumulativeTimestampLast; // overflow is desired\n        // only for the first time in the block\n        if (timeElapsed > 0) {\n            // if there's underlying\n            if (underlyingBalanceLast > 0) {\n              // cumulativeSecondlyYieldLast overflows eventually,\n              // due to the way it is used in the oracle that's ok,\n              // as long as it doesn't overflow twice during the windowSize\n              // see OraclelizedMock.cumulativeOverflowProof() for proof\n              cumulativeSecondlyYieldLast +=\n                  // (this.underlyingBalance() - underlyingBalanceLast) * 1e18 -> overflows only if (this.underlyingBalance() - underlyingBalanceLast) >~ 10^41 ETH, DAI, USDC etc\n                  // (this.underlyingBalance() - underlyingBalanceLast) never underflows\n                  ((this.underlyingBalance() - underlyingBalanceLast) * 1e18) / underlyingBalanceLast;\n            }\n\n            cumulativeUnderlyingBalanceLast += this.underlyingBalance() * timeElapsed;\n\n            cumulativeTimestampLast = blockTimestamp;\n        }\n    }\n\n    // call comptroller.enterMarkets()\n    // needs to be called only once BUT before any interactions with the provider\n    function _enterMarket()\n      internal\n    {\n        address[] memory markets = new address[](1);\n        markets[0] = cToken;\n        uint256[] memory err = IComptroller(comptroller).enterMarkets(markets);\n        require(err[0] == 0, \"PPC: _enterMarket\");\n    }\n\n\n    // creates checkpoint items needed to compute compRewardExpected()\n    // needs to be called right after each claimComp(), and just before the first ever deposit\n    function _updateCompState()\n      internal\n    {\n        (uint224 supplyStateIndex, ) = IComptroller(comptroller).compSupplyState(cToken);\n        compSupplierIndexLast = uint256(supplyStateIndex);\n        (, cumulativeUnderlyingBalanceHarvestedLast) = this.currentCumulatives();\n        harvestedLast = this.currentTime();\n    }\n\n    // /internals\n\n}"
    }
  ]
}