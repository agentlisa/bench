{
  "Title": "H-4: Deposits may be front-run by malicious operator to steal ETH",
  "Content": "# Issue H-4: Deposits may be front-run by malicious operator to steal ETH \n\nSource: https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/55 \n\n## Found by \ngiraffe, hash, zzykxx\n## Summary\nDelegated staking protocols may be exposed to a [known vulnerability](https://ethresear.ch/t/deposit-contract-exploit/6528), where a malicious operator front-runs a staker’s deposit call to the Beacon chain deposit contract and provides a different withdrawal credentials. This issue impacts Rio Network as well. \n\n## Vulnerability Detail\nIn Rio Network, approved operators are added to the operator registry. Thereafter, the operator adds validator details (public keys, signatures) to the same registry and awaits a confirmation period to pass (keys which are invalid may be removed by a security daemon) before the validators are active and ready to receive ETH. \n\nWhen ETH is deposited and ready to be staked, RioLRTOperatorDelegator:stakeETH() is called which in turns calls `eigenPodManager.stake{value: ETH_DEPOSIT_SIZE}(publicKey, signature, depositDataRoot);` The withdrawal credentials point to the OperatorDelegator's Eigenpod.\n\nA malicious operator may however front-run this transaction, by depositing 1 ETH into the Beacon chain deposit contract with the same validator keys but with a different, operator-controlled withdrawal credentials. Rio's OperatorDelegator's transaction would be successfully processed but the withdrawal credentials provided by the operator will **not be overwritten**. \n\nThe end state is a validator managing 1 ETH of node operator’s funds and 32 ETH of Rio users’ funds, fully controlled and withdrawable by the node operator.\n## Impact\nWhile operators are trusted by the DAO, incoming ETH deposits could be as large as `ETH_DEPOSIT_SOFT_CAP` which is 3200 ETH, a sizeable incentive for an operator to turn malicious and easily carry out the attack (cost of attack = 1 ETH per validator). In fact, incoming deposits could exceed the soft cap (i.e. multiples of 3200 ETH), as several `rebalance` could be called without delay to deposit all the ETH over a few blocks. \n\nAll deposited funds would be lost in such an attack.\n\nThis vulnerability also affected several LST/LRT protocols, see [Lido](https://research.lido.fi/t/mitigations-for-deposit-front-running-vulnerability/1239) and [EtherFi](https://246895607-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FG3Lk76lfvw9ecPIg0mK8%2Fuploads%2FFgdNivH2FNNe7JwkZXtd%2FNM0093-FINAL-ETHER-FI.pdf?alt=media&token=5aa1a2dc-33c7-430d-a2cb-59f56d2cfd2b) reports.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/main/rio-sherlock-audit/contracts/restaking/RioLRTOperatorDelegator.sol#L204\n\n## Tool used\nManual Review\n\n## Recommendation\nThe Lido discussion extensively discusses possible solutions. My recommendations would be:\n1) In order for validator key entries submitted by a node operator to be approved by the DAO, require the operator to pre-deposit 1 ETH with the correct protocol-controlled WC for each public key used in these deposit data entries. And upon approval of the validator keys, refund the operator the pre-deposited 1 ETH.\nor,\n2) Adopt what Lido did which was to establish a committee of guardians who will be tasked to watch for the deposit contract and publish a signed message off-chain to allow deposit.\n\nRio should also consider reducing the incentives for an operator to act maliciously by 1) reducing the maximum amount of ETH which can be deposited in a single tx, and 2) implement a short delay between rebalances, even if the soft cap was hit (to prevent chaining rebalances to deposit a large amount of ETH).\n\n\n\n## Discussion\n\n**nevillehuang**\n\nSince operators are not trusted in the context of rio-protocol, I believe high severity to be appropriate since this allows direct stealing of material amount of funds\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/rio-org/rio-sherlock-audit/pull/12\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/176",
  "Code": [
    {
      "filename": "rio-sherlock-audit/contracts/restaking/RioLRTOperatorDelegator.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.23;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {IRioLRTOperatorDelegator} from 'contracts/interfaces/IRioLRTOperatorDelegator.sol';\nimport {IDelegationManager} from 'contracts/interfaces/eigenlayer/IDelegationManager.sol';\nimport {IBeaconChainProofs} from 'contracts/interfaces/eigenlayer/IBeaconChainProofs.sol';\nimport {IStrategyManager} from 'contracts/interfaces/eigenlayer/IStrategyManager.sol';\nimport {IEigenPodManager} from 'contracts/interfaces/eigenlayer/IEigenPodManager.sol';\nimport {ISignatureUtils} from 'contracts/interfaces/eigenlayer/ISignatureUtils.sol';\nimport {IEigenPod} from 'contracts/interfaces/eigenlayer/IEigenPod.sol';\nimport {RioLRTCore} from 'contracts/restaking/base/RioLRTCore.sol';\nimport {Memory} from 'contracts/utils/Memory.sol';\nimport {Array} from 'contracts/utils/Array.sol';\nimport {Asset} from 'contracts/utils/Asset.sol';\nimport {\n    BEACON_CHAIN_STRATEGY,\n    BLS_PUBLIC_KEY_LENGTH,\n    BLS_SIGNATURE_LENGTH,\n    ETH_DEPOSIT_SIZE,\n    ETH_DEPOSIT_SIZE_IN_GWEI_LE64\n} from 'contracts/utils/Constants.sol';\n\ncontract RioLRTOperatorDelegator is IRioLRTOperatorDelegator, RioLRTCore {\n    using SafeERC20 for IERC20;\n    using Asset for *;\n    using Array for *;\n\n    /// @dev The withdrawal credentials prefix, which signals that withdrawals are enabled.\n    bytes1 internal constant WITHDRAWALS_ENABLED_PREFIX = 0x01;\n\n    /// @dev The minimum amount of excess ETH from full withdrawals that can be scraped from the EigenPod.\n    uint256 internal constant MIN_EXCESS_FULL_WITHDRAWAL_ETH_FOR_SCRAPE = 1 ether;\n\n    /// @notice The primary entry and exit-point for funds into and out of EigenLayer.\n    IStrategyManager public immutable strategyManager;\n\n    /// @notice The contract used for creating and managing EigenPods.\n    IEigenPodManager public immutable eigenPodManager;\n\n    /// @notice The primary delegation contract for EigenLayer.\n    IDelegationManager public immutable delegationManager;\n\n    /// @notice The operator delegator's EigenPod.\n    IEigenPod public eigenPod;\n\n    /// @notice Credentials to withdraw ETH on Consensus Layer via the EigenPod.\n    bytes32 public withdrawalCredentials;\n\n    /// @notice The amount of ETH queued for withdrawal to the withdrawal queue, intended for settling\n    /// user withdrawals, in gwei.\n    uint64 public ethQueuedForUserSettlementGwei;\n\n    /// @notice The amount of ETH queued for withdrawal to the deposit pool, specifically for facilitating\n    /// operator exits and excess full withdrawal scrapes, in gwei.\n    uint64 public ethQueuedForOperatorExitsAndScrapesGwei;\n\n    /// @param issuer_ The issuer of the LRT instance that this contract is deployed for.\n    /// @param strategyManager_ The primary entry and exit-point for funds into and out of EigenLayer.\n    /// @param eigenPodManager_ The contract used for creating and managing EigenPods.\n    /// @param delegationManager_ The primary delegation contract for EigenLayer.\n    constructor(address issuer_, address strategyManager_, address eigenPodManager_, address delegationManager_)\n        RioLRTCore(issuer_)\n    {\n        strategyManager = IStrategyManager(strategyManager_);\n        eigenPodManager = IEigenPodManager(eigenPodManager_);\n        delegationManager = IDelegationManager(delegationManager_);\n    }\n\n    // forgefmt: disable-next-item\n    /// @notice Initializes the contract by delegating to the provided EigenLayer operator.\n    /// @param token_ The address of the liquid restaking token.\n    /// @param operator The operator's address.\n    function initialize(address token_, address operator) external initializer {\n        __RioLRTCore_init_noVerify(token_);\n\n        if (msg.sender != address(operatorRegistry())) revert ONLY_OPERATOR_REGISTRY();\n\n        IDelegationManager.OperatorDetails memory operatorDetails = delegationManager.operatorDetails(operator);\n        if (operatorDetails.earningsReceiver != address(rewardDistributor())) revert INVALID_EARNINGS_RECEIVER();\n        if (operatorDetails.delegationApprover != address(0)) revert INVALID_DELEGATION_APPROVER();\n        if (operatorDetails.stakerOptOutWindowBlocks < operatorRegistry().minStakerOptOutBlocks()) {\n            revert INVALID_STAKER_OPT_OUT_BLOCKS();\n        }\n\n        delegationManager.delegateTo(\n            operator,\n            ISignatureUtils.SignatureWithExpiry(new bytes(0), 0),\n            bytes32(0)\n        );\n\n        // Deploy an EigenPod and set the withdrawal credentials to its address.\n        address eigenPodAddress = eigenPodManager.createPod();\n\n        eigenPod = IEigenPod(eigenPodAddress);\n        withdrawalCredentials = _computeWithdrawalCredentials(eigenPodAddress);\n    }\n\n    /// @notice Returns the number of shares in the operator delegator's EigenPod.\n    function getEigenPodShares() public view returns (int256) {\n        return eigenPodManager.podOwnerShares(address(this));\n    }\n\n    /// @notice The amount of ETH queued for withdrawal from EigenLayer, in wei.\n    function getETHQueuedForWithdrawal() public view returns (uint256) {\n        uint256 ethQueuedSlotData;\n        assembly {\n            ethQueuedSlotData := sload(ethQueuedForUserSettlementGwei.slot)\n        }\n\n        uint64 userSettlementGwei = uint64(ethQueuedSlotData);\n        uint64 operatorExitAndScrapeGwei = uint64(ethQueuedSlotData >> 64);\n\n        return (userSettlementGwei + operatorExitAndScrapeGwei).toWei();\n    }\n\n    /// @notice Returns the total amount of ETH under management by the operator delegator.\n    /// @dev This includes EigenPod shares (verified validator balances minus queued withdrawals)\n    /// and ETH queued for withdrawal from EigenLayer. Returns `0` if the total is negative.\n    function getETHUnderManagement() external view returns (uint256) {\n        int256 aum = getEigenPodShares() + int256(getETHQueuedForWithdrawal());\n        if (aum < 0) return 0;\n\n        return uint256(aum);\n    }\n\n    /// @notice Verifies withdrawal credentials of validator(s) owned by this operator.\n    /// It also verifies the effective balance of the validator(s).\n    /// @param oracleTimestamp The Beacon Chain timestamp whose state root the `proof` will be proven against.\n    /// @param stateRootProof Proves a `beaconStateRoot` against a block root fetched from the oracle.\n    /// @param validatorIndices The list of indices of the validators being proven, refer to consensus specs.\n    /// @param validatorFieldsProofs Proofs against the `beaconStateRoot` for each validator in `validatorFields`.\n    /// @param validatorFields The fields of the \"Validator Container\", refer to consensus specs.\n    function verifyWithdrawalCredentials(\n        uint64 oracleTimestamp,\n        IBeaconChainProofs.StateRootProof calldata stateRootProof,\n        uint40[] calldata validatorIndices,\n        bytes[] calldata validatorFieldsProofs,\n        bytes32[][] calldata validatorFields\n    ) external onlyOperatorRegistry {\n        eigenPod.verifyWithdrawalCredentials(\n            oracleTimestamp, stateRootProof, validatorIndices, validatorFieldsProofs, validatorFields\n        );\n    }\n\n    /// @notice Scrapes non-beacon chain ETH sitting in the operator delegator's\n    /// EigenPod to the reward distributor.\n    /// @dev Anyone can call this function.\n    function scrapeNonBeaconChainETHFromEigenPod() external {\n        eigenPod.withdrawNonBeaconChainETHBalanceWei(\n            address(rewardDistributor()), eigenPod.nonBeaconChainETHBalanceWei()\n        );\n    }\n\n    /// @notice Scrapes excess full withdrawal ETH from the operator delegator's EigenPod\n    /// to the deposit pool. ETH from full withdrawals may accumulate in the EigenPod over\n    /// time as full withdrawals contain more ETH than was requested from the withdrawal queue.\n    /// @dev Anyone can call this function.\n    function scrapeExcessFullWithdrawalETHFromEigenPod() external {\n        uint256 ethWithdrawable = eigenPod.withdrawableRestakedExecutionLayerGwei().toWei();\n        uint256 ethQueuedForWithdrawal = getETHQueuedForWithdrawal();\n        if (ethWithdrawable <= ethQueuedForWithdrawal + MIN_EXCESS_FULL_WITHDRAWAL_ETH_FOR_SCRAPE) {\n            revert INSUFFICIENT_EXCESS_FULL_WITHDRAWAL_ETH();\n        }\n        _queueWithdrawalForOperatorExitOrScrape(BEACON_CHAIN_STRATEGY, ethWithdrawable - ethQueuedForWithdrawal);\n    }\n\n    // forgefmt: disable-next-item\n    /// @notice Approve EigenLayer to spend an ERC20 token, then stake it into an EigenLayer strategy.\n    /// @param strategy The strategy to stake the tokens into.\n    /// @param token_ The token to stake.\n    /// @param amount The amount of tokens to stake.\n    function stakeERC20(address strategy, address token_, uint256 amount) external onlyDepositPool returns (uint256 shares) {\n        if (IERC20(token_).allowance(address(this), address(strategyManager)) < amount) {\n            IERC20(token_).forceApprove(address(strategyManager), type(uint256).max);\n        }\n        shares = strategyManager.depositIntoStrategy(strategy, token_, amount);\n    }\n\n    // forgefmt: disable-next-item\n    /// Stake ETH via the operator delegator's EigenPod, using the provided validator information.\n    /// @param validatorCount The number of validators to deposit into.\n    /// @param pubkeyBatch Batched validator public keys.\n    /// @param signatureBatch Batched validator signatures.\n    function stakeETH(uint256 validatorCount, bytes calldata pubkeyBatch, bytes calldata signatureBatch) external payable onlyDepositPool {\n        if (validatorCount == 0 || msg.value / ETH_DEPOSIT_SIZE != validatorCount) revert INVALID_VALIDATOR_COUNT();\n        if (pubkeyBatch.length != BLS_PUBLIC_KEY_LENGTH * validatorCount) {\n            revert INVALID_PUBLIC_KEYS_BATCH_LENGTH(pubkeyBatch.length, BLS_PUBLIC_KEY_LENGTH * validatorCount);\n        }\n        if (signatureBatch.length != BLS_SIGNATURE_LENGTH * validatorCount) {\n            revert INVALID_SIGNATURES_BATCH_LENGTH(signatureBatch.length, BLS_SIGNATURE_LENGTH * validatorCount);\n        }\n\n        bytes32 depositDataRoot;\n        bytes32 withdrawalCredentials_ = withdrawalCredentials;\n        bytes memory publicKey = Memory.unsafeAllocateBytes(BLS_PUBLIC_KEY_LENGTH);\n        bytes memory signature = Memory.unsafeAllocateBytes(BLS_SIGNATURE_LENGTH);\n        for (uint256 i = 0; i < validatorCount; ++i) {\n            Memory.copyBytes(pubkeyBatch, publicKey, i * BLS_PUBLIC_KEY_LENGTH, 0, BLS_PUBLIC_KEY_LENGTH);\n            Memory.copyBytes(signatureBatch, signature, i * BLS_SIGNATURE_LENGTH, 0, BLS_SIGNATURE_LENGTH);\n            depositDataRoot = _computeDepositDataRoot(withdrawalCredentials_, publicKey, signature);\n\n            eigenPodManager.stake{value: ETH_DEPOSIT_SIZE}(publicKey, signature, depositDataRoot);\n        }\n    }\n\n    // forgefmt: disable-next-item\n    /// @notice Queues a withdrawal of the specified amount of `shares` from the given `strategy` to the withdrawal queue,\n    /// intended for settling user withdrawals.\n    /// @param strategy The strategy from which to withdraw.\n    /// @param shares The amount of shares to withdraw.\n    function queueWithdrawalForUserSettlement(address strategy, uint256 shares) external onlyCoordinator returns (bytes32 root) {\n        if (strategy == BEACON_CHAIN_STRATEGY) {\n            _increaseETHQueuedForUserSettlement(shares);\n        }\n        root = _queueWithdrawal(strategy, shares, address(withdrawalQueue()));\n    }\n\n    // forgefmt: disable-next-item\n    /// @notice Queues a withdrawal of the specified amount of `shares` from the given `strategy` to the deposit pool,\n    /// specifically for facilitating operator exits.\n    /// @param strategy The strategy from which to withdraw.\n    /// @param shares The amount of shares to withdraw.\n    function queueWithdrawalForOperatorExit(address strategy, uint256 shares) external onlyOperatorRegistry returns (bytes32 root) {\n        root = _queueWithdrawalForOperatorExitOrScrape(strategy, shares);\n    }\n\n    /// @notice Decrease the amount of ETH queued from EigenLayer for user settlement.\n    /// @param amountWei The amount of ETH to decrease by, in wei.\n    function decreaseETHQueuedForUserSettlement(uint256 amountWei) external onlyWithdrawalQueue {\n        _decreaseETHQueuedForUserSettlement(amountWei);\n    }\n\n    /// @dev Decrease the amount of ETH queued for operator exit or excess full withdrawal scrape\n    /// from EigenLayer.\n    /// @param amountWei The amount of ETH to decrease by, in wei.\n    function decreaseETHQueuedForOperatorExitOrScrape(uint256 amountWei) external onlyDepositPool {\n        _decreaseETHQueuedForOperatorExitOrScrape(amountWei);\n    }\n\n    /// @notice Forwards ETH rewards to the reward distributor. This includes partial\n    /// withdrawals and any amount in excess of 32 ETH for full withdrawals.\n    receive() external payable {\n        address(rewardDistributor()).transferETH(msg.value);\n    }\n\n    // forgefmt: disable-next-item\n    /// @dev Queues a withdrawal of the specified amount of `shares` from the given `strategy` to the deposit pool,\n    /// specifically for facilitating operator exits or excess full withdrawal scrapes.\n    /// @param strategy The strategy from which to withdraw.\n    /// @param shares The amount of shares to withdraw.\n    function _queueWithdrawalForOperatorExitOrScrape(address strategy, uint256 shares) internal returns (bytes32 root) {\n        if (strategy == BEACON_CHAIN_STRATEGY) {\n            _increaseETHQueuedForOperatorExitOrScrape(shares);\n        }\n        root = _queueWithdrawal(strategy, shares, address(depositPool()));\n    }\n\n    // forgefmt: disable-next-item\n    /// @dev Queue a withdrawal of the given amount of `shares` to the `withdrawer` from the provided `strategy`.\n    /// @param strategy The strategy to withdraw from.\n    /// @param shares The amount of shares to withdraw.\n    /// @param withdrawer The address who has permission to complete the withdrawal.\n    function _queueWithdrawal(address strategy, uint256 shares, address withdrawer) internal returns (bytes32 root) {\n        IDelegationManager.QueuedWithdrawalParams[] memory withdrawalParams = new IDelegationManager.QueuedWithdrawalParams[](1);\n        withdrawalParams[0] = IDelegationManager.QueuedWithdrawalParams({\n            strategies: strategy.toArray(),\n            shares: shares.toArray(),\n            withdrawer: withdrawer\n        });\n        root = delegationManager.queueWithdrawals(withdrawalParams)[0];\n    }\n\n    /// @dev Increase the amount of ETH queued from EigenLayer for user settlement.\n    /// @param amountWei The amount of ETH to increase by, in wei.\n    function _increaseETHQueuedForUserSettlement(uint256 amountWei) internal {\n        ethQueuedForUserSettlementGwei += amountWei.toGwei();\n    }\n\n    /// @dev Decrease the amount of ETH queued from EigenLayer for user settlement.\n    /// @param amountWei The amount of ETH to decrease by, in wei.\n    function _decreaseETHQueuedForUserSettlement(uint256 amountWei) internal {\n        ethQueuedForUserSettlementGwei -= amountWei.toGwei();\n    }\n\n    /// @dev Increase the amount of ETH queued for operator exit or excess full withdrawal scrape\n    /// from EigenLayer.\n    /// @param amountWei The amount of ETH to increase by, in wei.\n    function _increaseETHQueuedForOperatorExitOrScrape(uint256 amountWei) internal {\n        ethQueuedForOperatorExitsAndScrapesGwei += amountWei.toGwei();\n    }\n\n    /// @dev Decrease the amount of ETH queued for operator exit or excess full withdrawal scrape\n    /// from EigenLayer.\n    /// @param amountWei The amount of ETH to decrease by, in wei.\n    function _decreaseETHQueuedForOperatorExitOrScrape(uint256 amountWei) internal {\n        ethQueuedForOperatorExitsAndScrapesGwei -= amountWei.toGwei();\n    }\n\n    /// @dev Compute withdrawal credentials for the given EigenPod.\n    /// @param pod The EigenPod to compute the withdrawal credentials for.\n    function _computeWithdrawalCredentials(address pod) internal pure returns (bytes32) {\n        return WITHDRAWALS_ENABLED_PREFIX | bytes32(uint256(uint160(pod)));\n    }\n\n    // forgefmt: disable-next-item\n    /// @dev Computes the deposit_root_hash required by the Beacon Deposit contract.\n    /// @param withdrawalCredentials_ Credentials to withdraw ETH on Consensus Layer.\n    /// @param publicKey A BLS12-381 public key.\n    /// @param signature A BLS12-381 signature.\n    function _computeDepositDataRoot(bytes32 withdrawalCredentials_, bytes memory publicKey, bytes memory signature) internal pure returns (bytes32) {\n        // Compute the deposit data root (`DepositData` hash tree root) according to deposit_contract.sol\n        bytes memory sigPart1 = Memory.unsafeAllocateBytes(64);\n        bytes memory sigPart2 = Memory.unsafeAllocateBytes(32);\n\n        Memory.copyBytes(signature, sigPart1, 0, 0, 64);\n        Memory.copyBytes(signature, sigPart2, 64, 0, 32);\n\n        bytes32 publicKeyRoot = sha256(abi.encodePacked(publicKey, bytes16(0)));\n        bytes32 signatureRoot =\n            sha256(abi.encodePacked(sha256(abi.encodePacked(sigPart1)), sha256(abi.encodePacked(sigPart2, bytes32(0)))));\n\n        return sha256(\n            abi.encodePacked(\n                sha256(abi.encodePacked(publicKeyRoot, withdrawalCredentials_)),\n                sha256(abi.encodePacked(ETH_DEPOSIT_SIZE_IN_GWEI_LE64, bytes24(0), signatureRoot))\n            )\n        );\n    }\n}"
    }
  ]
}