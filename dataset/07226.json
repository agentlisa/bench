{
  "Title": "[M-14] Unsafe cast of uint8 datatype to int8",
  "Content": "# Lines of code\n\nhttps://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/BackingManager.sol#L228\nhttps://github.com/reserve-protocol/protocol/blob/df7ecadc2bae74244ace5e8b39e94bc992903158/contracts/p1/BasketHandler.sol#L421\n\n\n# Vulnerability details\n\n## Impact\nConverting uint8 to int8 can have unexpected consequences when done unsafely. This issue affects the quote function in BasketHandler.sol and handoutExcessAssets in BackingManager.sol. While there is some risk here, the issue is unlikely to be exploited as ERC-20 tokens generally don't have a decimals value over 18, nevertheless one over 127. \n\n## Proof of Concept\n\n➜ int8(uint8(127))\nType: int\n├ Hex: 0x7f\n└ Decimal: 127\n➜ int8(uint8(128))\nType: int\n├ Hex: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff80\n└ Decimal: -128\n\n## Tools Used\nChisel\n\n## Recommended Mitigation Steps\nValidate that the decimals value is within an acceptable upper-bound before attempting to cast it to a signed integer. ",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2023-01-reserve-contest",
  "Code": [
    {
      "filename": "contracts/p1/BackingManager.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/IAsset.sol\";\nimport \"../interfaces/IBackingManager.sol\";\nimport \"../interfaces/IMain.sol\";\nimport \"../libraries/Array.sol\";\nimport \"../libraries/Fixed.sol\";\nimport \"./mixins/Trading.sol\";\nimport \"./mixins/RecollateralizationLib.sol\";\n\n/**\n * @title BackingManager\n * @notice The backing manager holds + manages the backing for an RToken\n */\n\n/// @custom:oz-upgrades-unsafe-allow external-library-linking\ncontract BackingManagerP1 is TradingP1, IBackingManager {\n    using FixLib for uint192;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    // Cache of peer components\n    IAssetRegistry private assetRegistry;\n    IBasketHandler private basketHandler;\n    IDistributor private distributor;\n    IRToken private rToken;\n    IERC20 private rsr;\n    IStRSR private stRSR;\n    IRevenueTrader private rsrTrader;\n    IRevenueTrader private rTokenTrader;\n    uint48 public constant MAX_TRADING_DELAY = 31536000; // {s} 1 year\n    uint192 public constant MAX_BACKING_BUFFER = FIX_ONE; // {1} 100%\n\n    uint48 public tradingDelay; // {s} how long to wait until resuming trading after switching\n    uint192 public backingBuffer; // {%} how much extra backing collateral to keep\n\n    // ==== Invariants ====\n    // tradingDelay <= MAX_TRADING_DELAY and backingBuffer <= MAX_BACKING_BUFFER\n    //\n    // ... and the *much* more complicated temporal properties for _manageTokens()\n\n    function init(\n        IMain main_,\n        uint48 tradingDelay_,\n        uint192 backingBuffer_,\n        uint192 maxTradeSlippage_,\n        uint192 minTradeVolume_\n    ) external initializer {\n        __Component_init(main_);\n        __Trading_init(main_, maxTradeSlippage_, minTradeVolume_);\n\n        assetRegistry = main_.assetRegistry();\n        basketHandler = main_.basketHandler();\n        distributor = main_.distributor();\n        rsr = main_.rsr();\n        rsrTrader = main_.rsrTrader();\n        rTokenTrader = main_.rTokenTrader();\n        rToken = main_.rToken();\n        stRSR = main_.stRSR();\n\n        setTradingDelay(tradingDelay_);\n        setBackingBuffer(backingBuffer_);\n    }\n\n    /// Give RToken max allowance over the registered token `erc20`\n    /// @custom:interaction CEI\n    // checks: erc20 in assetRegistry\n    // action: set allowance on erc20 for rToken to UINT_MAX\n    // Using two safeApprove calls instead of safeIncreaseAllowance to support USDT\n    function grantRTokenAllowance(IERC20 erc20) external notPausedOrFrozen {\n        require(assetRegistry.isRegistered(erc20), \"erc20 unregistered\");\n        // == Interaction ==\n        IERC20Upgradeable(address(erc20)).safeApprove(address(main.rToken()), 0);\n        IERC20Upgradeable(address(erc20)).safeApprove(address(main.rToken()), type(uint256).max);\n    }\n\n    /// Maintain the overall backing policy; handout assets otherwise\n    /// @custom:interaction\n    // checks: the addresses in `erc20s` are unique\n    // effect: _manageTokens(erc20s)\n    function manageTokens(IERC20[] calldata erc20s) external notPausedOrFrozen {\n        // Token list must not contain duplicates\n        require(ArrayLib.allUnique(erc20s), \"duplicate tokens\");\n        _manageTokens(erc20s);\n    }\n\n    /// Mointain the overall backing policy; handout assets otherwise\n    /// @dev Tokens must be in sorted order!\n    /// @dev Performs a uniqueness check on the erc20s list in O(n)\n    /// @custom:interaction\n    // checks: the addresses in `erc20s` are unique (and sorted)\n    // effect: _manageTokens(erc20s)\n    function manageTokensSortedOrder(IERC20[] calldata erc20s) external notPausedOrFrozen {\n        // Token list must not contain duplicates\n        require(ArrayLib.sortedAndAllUnique(erc20s), \"duplicate/unsorted tokens\");\n        _manageTokens(erc20s);\n    }\n\n    /// Maintain the overall backing policy; handout assets otherwise\n    /// @custom:interaction RCEI\n    // only called internally, from manageTokens*, so erc20s has no duplicates unique\n    // (but not necessarily all registered or valid!)\n    function _manageTokens(IERC20[] calldata erc20s) private {\n        // == Refresh ==\n        assetRegistry.refresh();\n\n        if (tradesOpen > 0) return;\n        // Only trade when all the collateral assets in the basket are SOUND\n        require(basketHandler.status() == CollateralStatus.SOUND, \"basket not sound\");\n\n        uint48 basketTimestamp = basketHandler.timestamp();\n        if (block.timestamp < basketTimestamp + tradingDelay) return;\n\n        if (basketHandler.fullyCollateralized()) {\n            // == Interaction (then return) ==\n            handoutExcessAssets(erc20s);\n        } else {\n            /*\n             * Recollateralization\n             *\n             * Strategy: iteratively move the system on a forgiving path towards collateralization\n             * through a narrowing BU price band. The initial large spread reflects the\n             * uncertainty associated with the market price of defaulted/volatile collateral, as\n             * well as potential losses due to trading slippage. In the absence of further\n             * collateral default, the size of the BU price band should decrease with each trade\n             * until it is 0, at which point collateralization is restored.\n             *\n             * If we run out of capital and are still undercollateralized, we compromise\n             * rToken.basketsNeeded to the current basket holdings. Haircut time.\n             */\n\n            (bool doTrade, TradeRequest memory req) = RecollateralizationLibP1\n                .prepareRecollateralizationTrade(this);\n\n            if (doTrade) {\n                // Seize RSR if needed\n                if (req.sell.erc20() == rsr) {\n                    uint256 bal = req.sell.erc20().balanceOf(address(this));\n                    if (req.sellAmount > bal) stRSR.seizeRSR(req.sellAmount - bal);\n                }\n\n                tryTrade(req);\n            } else {\n                // Haircut time\n                compromiseBasketsNeeded();\n            }\n        }\n    }\n\n    /// Send excess assets to the RSR and RToken traders\n    /// @custom:interaction CEI\n    function handoutExcessAssets(IERC20[] calldata erc20s) private {\n        /**\n         * Assumptions:\n         *   - Fully collateralized. All collateral meet balance requirements.\n         *   - All backing capital is held at BackingManager's address. No capital is out on-trade\n         *   - Neither RToken nor RSR are in the basket\n         *   - Each address in erc20s is unique\n         *\n         * Steps:\n         *   1. Forward all held RSR to the RSR trader to prevent using it for RToken appreciation\n         *      (action: send rsr().balanceOf(this) to rsrTrader)\n         *   2. Using whatever balances of collateral are there, fast-issue all RToken possible.\n         *      (in detail: mint RToken and set basketsNeeded so that the BU/rtok exchange rate is\n         *       roughly constant, and strictly does not decrease,\n         *   3. Handout all surplus asset balances (including collateral and RToken) to the\n         *      RSR and RToken traders according to the distribution totals.\n         */\n\n        // Forward any RSR held to StRSR pool; RSR should never be sold for RToken yield\n        if (rsr.balanceOf(address(this)) > 0) {\n            // For CEI, this is an interaction \"within our system\" even though RSR is already live\n            IERC20Upgradeable(address(rsr)).safeTransfer(\n                address(rsrTrader),\n                rsr.balanceOf(address(this))\n            );\n        }\n\n        // Mint revenue RToken and update `basketsNeeded`\n        // across this block:\n        //   where rate(R) == R.basketsNeeded / R.totalSupply,\n        //   rate(rToken') >== rate(rToken)\n        //   (>== is \"no less than, and nearly equal to\")\n        //    and rToken'.basketsNeeded <= basketHandler.basketsHeldBy(this)\n        // and rToken'.totalSupply is maximal satisfying this.\n        uint192 needed; // {BU}\n        {\n            needed = rToken.basketsNeeded(); // {BU}\n            uint192 held = basketHandler.basketsHeldBy(address(this)); // {BU}\n            if (held.gt(needed)) {\n                // gas-optimization: RToken is known to have 18 decimals, the same as FixLib\n                uint192 totalSupply = _safeWrap(rToken.totalSupply()); // {rTok}\n\n                // {BU} = {BU} - {BU}\n                uint192 extraBUs = held.minus(needed);\n\n                // {rTok} = {BU} * {rTok / BU} (if needed == 0, conv rate is 1 rTok/BU)\n                uint192 rTok = (needed > 0) ? extraBUs.mulDiv(totalSupply, needed) : extraBUs;\n\n                // gas-optimization: RToken is known to have 18 decimals, same as FixLib\n                rToken.mint(address(this), uint256(rTok));\n                rToken.setBasketsNeeded(held);\n                needed = held;\n            }\n        }\n\n        // At this point, even though basketsNeeded may have changed:\n        // - We're fully collateralized\n        // - The BU exchange rate {BU/rTok} did not decrease\n\n        // Keep a small buffer of individual collateral; \"excess\" assets are beyond the buffer.\n        needed = needed.mul(FIX_ONE.plus(backingBuffer));\n\n        // Handout excess assets above what is needed, including any recently minted RToken\n        uint256 length = erc20s.length;\n        RevenueTotals memory totals = distributor.totals();\n        uint256[] memory toRSR = new uint256[](length);\n        uint256[] memory toRToken = new uint256[](length);\n        for (uint256 i = 0; i < length; ++i) {\n            IAsset asset = assetRegistry.toAsset(erc20s[i]);\n\n            uint192 req = needed.mul(basketHandler.quantity(erc20s[i]), CEIL);\n            if (asset.bal(address(this)).gt(req)) {\n                // delta: {qTok}, the excess quantity of this asset that we hold\n                uint256 delta = asset.bal(address(this)).minus(req).shiftl_toUint(\n                    int8(IERC20Metadata(address(erc20s[i])).decimals())\n                );\n                // no div-by-0: Distributor guarantees (totals.rTokenTotal + totals.rsrTotal) > 0\n                // initial division is intentional here! We'd rather save the dust than be unfair\n                toRSR[i] = (delta / (totals.rTokenTotal + totals.rsrTotal)) * totals.rsrTotal;\n                toRToken[i] = (delta / (totals.rTokenTotal + totals.rsrTotal)) * totals.rTokenTotal;\n            }\n        }\n\n        // == Interactions ==\n        for (uint256 i = 0; i < length; ++i) {\n            IERC20Upgradeable erc20 = IERC20Upgradeable(address(erc20s[i]));\n            if (toRToken[i] > 0) erc20.safeTransfer(address(rTokenTrader), toRToken[i]);\n            if (toRSR[i] > 0) erc20.safeTransfer(address(rsrTrader), toRSR[i]);\n        }\n\n        // It's okay if there is leftover dust for RToken or a surplus asset (not RSR)\n    }\n\n    /// Compromise on how many baskets are needed in order to recollateralize-by-accounting\n    function compromiseBasketsNeeded() private {\n        assert(tradesOpen == 0 && !basketHandler.fullyCollateralized());\n        rToken.setBasketsNeeded(basketHandler.basketsHeldBy(address(this)));\n    }\n\n    // === Governance Setters ===\n\n    /// @custom:governance\n    function setTradingDelay(uint48 val) public governance {\n        require(val <= MAX_TRADING_DELAY, \"invalid tradingDelay\");\n        emit TradingDelaySet(tradingDelay, val);\n        tradingDelay = val;\n    }\n\n    /// @custom:governance\n    function setBackingBuffer(uint192 val) public governance {\n        require(val <= MAX_BACKING_BUFFER, \"invalid backingBuffer\");\n        emit BackingBufferSet(backingBuffer, val);\n        backingBuffer = val;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[41] private __gap;\n}"
    },
    {
      "filename": "contracts/p1/BasketHandler.sol",
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport \"../interfaces/IAssetRegistry.sol\";\nimport \"../interfaces/IBasketHandler.sol\";\nimport \"../interfaces/IMain.sol\";\nimport \"../libraries/Array.sol\";\nimport \"../libraries/Fixed.sol\";\nimport \"./mixins/Component.sol\";\n\n// A \"valid collateral array\" is a an IERC20[] value without rtoken, rsr, or any duplicate values\n\n// A BackupConfig value is valid if erc20s is a valid collateral array\nstruct BackupConfig {\n    uint256 max; // Maximum number of backup collateral erc20s to use in a basket\n    IERC20[] erc20s; // Ordered list of backup collateral ERC20s\n}\n\n// What does a BasketConfig value mean?\n//\n// erc20s, targetAmts, and targetNames should be interpreted together.\n// targetAmts[erc20] is the quantity of target units of erc20 that one BU should hold\n// targetNames[erc20] is the name of erc20's target unit\n// and then backups[tgt] is the BackupConfig to use for the target unit named tgt\n//\n// For any valid BasketConfig value:\n//     erc20s == keys(targetAmts) == keys(targetNames)\n//     if name is in values(targetNames), then backups[name] is a valid BackupConfig\n//     erc20s is a valid collateral array\n//\n// In the meantime, treat erc20s as the canonical set of keys for the target* maps\nstruct BasketConfig {\n    // The collateral erc20s in the prime (explicitly governance-set) basket\n    IERC20[] erc20s;\n    // Amount of target units per basket for each prime collateral token. {target/BU}\n    mapping(IERC20 => uint192) targetAmts;\n    // Cached view of the target unit for each erc20 upon setup\n    mapping(IERC20 => bytes32) targetNames;\n    // Backup configurations, per target name.\n    mapping(bytes32 => BackupConfig) backups;\n}\n\n/// The type of BasketHandler.basket.\n/// Defines a basket unit (BU) in terms of reference amounts of underlying tokens\n// Logically, basket is just a mapping of erc20 addresses to ref-unit amounts.\n// In the analytical comments I'll just refer to it that way.\n//\n// A Basket is valid if erc20s is a valid collateral array and erc20s == keys(refAmts)\nstruct Basket {\n    IERC20[] erc20s; // enumerated keys for refAmts\n    mapping(IERC20 => uint192) refAmts; // {ref/BU}\n}\n\n/*\n * @title BasketLibP1\n */\nlibrary BasketLibP1 {\n    using BasketLibP1 for Basket;\n    using FixLib for uint192;\n\n    /// Set self to a fresh, empty basket\n    // self'.erc20s = [] (empty list)\n    // self'.refAmts = {} (empty map)\n    function empty(Basket storage self) internal {\n        uint256 length = self.erc20s.length;\n        for (uint256 i = 0; i < length; ++i) self.refAmts[self.erc20s[i]] = FIX_ZERO;\n        delete self.erc20s;\n    }\n\n    /// Set `self` equal to `other`\n    function setFrom(Basket storage self, Basket storage other) internal {\n        empty(self);\n        uint256 length = other.erc20s.length;\n        for (uint256 i = 0; i < length; ++i) {\n            self.erc20s.push(other.erc20s[i]);\n            self.refAmts[other.erc20s[i]] = other.refAmts[other.erc20s[i]];\n        }\n    }\n\n    /// Add `weight` to the refAmount of collateral token `tok` in the basket `self`\n    // self'.refAmts[tok] = self.refAmts[tok] + weight\n    // self'.erc20s is keys(self'.refAmts)\n    function add(\n        Basket storage self,\n        IERC20 tok,\n        uint192 weight\n    ) internal {\n        // untestable:\n        //      Both calls to .add() use a weight that has been CEIL rounded in the\n        //      Fixed library div function, so weight will never be 0 here.\n        //      Additionally, setPrimeBasket() enforces prime-basket tokens must have a weight > 0.\n        if (weight == FIX_ZERO) return;\n        if (self.refAmts[tok].eq(FIX_ZERO)) {\n            self.erc20s.push(tok);\n            self.refAmts[tok] = weight;\n        } else {\n            self.refAmts[tok] = self.refAmts[tok].plus(weight);\n        }\n    }\n}\n\n/**\n * @title BasketHandler\n * @notice Handles the basket configuration, definition, and evolution over time.\n */\ncontract BasketHandlerP1 is ComponentP1, IBasketHandler {\n    using BasketLibP1 for Basket;\n    using CollateralStatusComparator for CollateralStatus;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using FixLib for uint192;\n\n    uint192 public constant MAX_TARGET_AMT = 1e3 * FIX_ONE; // {target/BU} max basket weight\n\n    // Peer components\n    IAssetRegistry private assetRegistry;\n    IBackingManager private backingManager;\n    IERC20 private rsr;\n    IRToken private rToken;\n    IStRSR private stRSR;\n\n    // config is the basket configuration, from which basket will be computed in a basket-switch\n    // event. config is only modified by governance through setPrimeBakset and setBackupConfig\n    BasketConfig private config;\n\n    // basket, disabled, nonce, and timestamp are only ever set by `_switchBasket()`\n    // basket is the current basket.\n    Basket private basket;\n\n    uint48 public override nonce; // A unique identifier for this basket instance\n    uint48 public override timestamp; // The timestamp when this basket was last set\n\n    // If disabled is true, status() is DISABLED, the basket is invalid,\n    // and everything except redemption should be paused.\n    bool private disabled;\n\n    // ==== Invariants ====\n    // basket is a valid Basket:\n    //   basket.erc20s is a valid collateral array and basket.erc20s == keys(basket.refAmts)\n    // config is a valid BasketConfig:\n    //   erc20s == keys(targetAmts) == keys(targetNames)\n    //   erc20s is a valid collateral array\n    //   for b in vals(backups), b.erc20s is a valid collateral array.\n    // if basket.erc20s is empty then disabled == true\n\n    // BasketHandler.init() just leaves the BasketHandler state zeroed\n    function init(IMain main_) external initializer {\n        __Component_init(main_);\n\n        assetRegistry = main_.assetRegistry();\n        backingManager = main_.backingManager();\n        rsr = main_.rsr();\n        rToken = main_.rToken();\n        stRSR = main_.stRSR();\n\n        disabled = true;\n    }\n\n    /// Disable the basket in order to schedule a basket refresh\n    /// @custom:protected\n    // checks: caller is assetRegistry\n    // effects: disabled' = true\n    function disableBasket() external {\n        require(_msgSender() == address(assetRegistry), \"asset registry only\");\n        uint192[] memory refAmts = new uint192[](basket.erc20s.length);\n        emit BasketSet(nonce, basket.erc20s, refAmts, true);\n        disabled = true;\n    }\n\n    /// Switch the basket, only callable directly by governance\n    /// @custom:interaction OR @custom:governance\n    // checks: either caller has OWNER,\n    //         or (basket is disabled after refresh and we're unpaused and unfrozen)\n    // actions: calls assetRegistry.refresh(), then _switchBasket()\n    // effects:\n    //   Either: (basket' is a valid nonempty basket, without DISABLED collateral,\n    //            that satisfies basketConfig) and disabled' = false\n    //   Or no such basket exists and disabled' = true\n    function refreshBasket() external {\n        assetRegistry.refresh();\n\n        require(\n            main.hasRole(OWNER, _msgSender()) ||\n                (status() == CollateralStatus.DISABLED && !main.pausedOrFrozen()),\n            \"basket unrefreshable\"\n        );\n        _switchBasket();\n    }\n\n    /// Set the prime basket in the basket configuration, in terms of erc20s and target amounts\n    /// @param erc20s The collateral for the new prime basket\n    /// @param targetAmts The target amounts (in) {target/BU} for the new prime basket\n    /// @custom:governance\n    // checks:\n    //   caller is OWNER\n    //   len(erc20s) == len(targetAmts)\n    //   erc20s is a valid collateral array\n    //   for all i, erc20[i] is in AssetRegistry as collateral\n    //   for all i, 0 < targetAmts[i] <= MAX_TARGET_AMT == 1000\n    //\n    // effects:\n    //   config'.erc20s = erc20s\n    //   config'.targetAmts[erc20s[i]] = targetAmts[i], for i from 0 to erc20s.length-1\n    //   config'.targetNames[e] = assetRegistry.toColl(e).targetName, for e in erc20s\n    function setPrimeBasket(IERC20[] calldata erc20s, uint192[] calldata targetAmts)\n        external\n        governance\n    {\n        require(erc20s.length > 0, \"cannot empty basket\");\n        require(erc20s.length == targetAmts.length, \"must be same length\");\n        requireValidCollArray(erc20s);\n\n        // Clean up previous basket config\n        for (uint256 i = 0; i < config.erc20s.length; ++i) {\n            delete config.targetAmts[config.erc20s[i]];\n            delete config.targetNames[config.erc20s[i]];\n        }\n        delete config.erc20s;\n\n        // Set up new config basket\n        bytes32[] memory names = new bytes32[](erc20s.length);\n\n        for (uint256 i = 0; i < erc20s.length; ++i) {\n            // This is a nice catch to have, but in general it is possible for\n            // an ERC20 in the prime basket to have its asset unregistered.\n            require(assetRegistry.toAsset(erc20s[i]).isCollateral(), \"token is not collateral\");\n            require(0 < targetAmts[i], \"invalid target amount; must be nonzero\");\n            require(targetAmts[i] <= MAX_TARGET_AMT, \"invalid target amount; too large\");\n\n            config.erc20s.push(erc20s[i]);\n            config.targetAmts[erc20s[i]] = targetAmts[i];\n            names[i] = assetRegistry.toColl(erc20s[i]).targetName();\n            config.targetNames[erc20s[i]] = names[i];\n        }\n\n        emit PrimeBasketSet(erc20s, targetAmts, names);\n    }\n\n    /// Set the backup configuration for some target name\n    /// @custom:governance\n    // checks:\n    //   caller is OWNER\n    //   erc20s is a valid collateral array\n    //   for all i, erc20[i] is in AssetRegistry as collateral\n    //\n    // effects:\n    //   config'.backups[targetName] = {max: max, erc20s: erc20s}\n    function setBackupConfig(\n        bytes32 targetName,\n        uint256 max,\n        IERC20[] calldata erc20s\n    ) external governance {\n        requireValidCollArray(erc20s);\n        BackupConfig storage conf = config.backups[targetName];\n        conf.max = max;\n        delete conf.erc20s;\n\n        for (uint256 i = 0; i < erc20s.length; ++i) {\n            // This is a nice catch to have, but in general it is possible for\n            // an ERC20 in the backup config to have its asset altered.\n            require(assetRegistry.toAsset(erc20s[i]).isCollateral(), \"token is not collateral\");\n            conf.erc20s.push(erc20s[i]);\n        }\n        emit BackupConfigSet(targetName, max, erc20s);\n    }\n\n    /// @return Whether this contract owns enough collateral to cover rToken.basketsNeeded() BUs\n    /// ie, whether the protocol is currently fully collateralized\n    function fullyCollateralized() external view returns (bool) {\n        return basketsHeldBy(address(backingManager)) >= rToken.basketsNeeded();\n    }\n\n    /// @return status_ The status of the basket\n    // returns DISABLED if disabled == true, and worst(status(coll)) otherwise\n    function status() public view returns (CollateralStatus status_) {\n        uint256 size = basket.erc20s.length;\n\n        // untestable:\n        //      disabled is only set in _switchBasket, and only if size > 0.\n        if (disabled || size == 0) return CollateralStatus.DISABLED;\n\n        for (uint256 i = 0; i < size; ++i) {\n            CollateralStatus s = assetRegistry.toColl(basket.erc20s[i]).status();\n            if (s.worseThan(status_)) status_ = s;\n        }\n    }\n\n    /// @return {tok/BU} The token-quantity of an ERC20 token in the basket.\n    // Returns 0 if erc20 is not registered, disabled, or not in the basket\n    // Returns FIX_MAX (in lieu of +infinity) if Collateral.refPerTok() is 0.\n    // Otherwise returns (token's basket.refAmts / token's Collateral.refPerTok())\n    function quantity(IERC20 erc20) public view returns (uint192) {\n        try assetRegistry.toColl(erc20) returns (ICollateral coll) {\n            if (coll.status() == CollateralStatus.DISABLED) return FIX_ZERO;\n\n            uint192 refPerTok = coll.refPerTok(); // {ref/tok}\n            if (refPerTok > 0) {\n                // {tok/BU} = {ref/BU} / {ref/tok}\n                return basket.refAmts[erc20].div(refPerTok, CEIL);\n            } else {\n                return FIX_MAX;\n            }\n        } catch {\n            return FIX_ZERO;\n        }\n    }\n\n    /// Should not revert\n    /// @return low {UoA/tok} The lower end of the price estimate\n    /// @return high {UoA/tok} The upper end of the price estimate\n    // returns sum(quantity(erc20) * price(erc20) for erc20 in basket.erc20s)\n    function price() external view returns (uint192 low, uint192 high) {\n        return _price(false);\n    }\n\n    /// Should not revert\n    /// lowLow should be nonzero when the asset might be worth selling\n    /// @return lotLow {UoA/tok} The lower end of the lot price estimate\n    /// @return lotHigh {UoA/tok} The upper end of the lot price estimate\n    // returns sum(quantity(erc20) * lotPrice(erc20) for erc20 in basket.erc20s)\n    function lotPrice() external view returns (uint192 lotLow, uint192 lotHigh) {\n        return _price(true);\n    }\n\n    /// Returns the price of a BU, using the lot prices if `useLotPrice` is true\n    /// @return low {UoA/tok} The lower end of the lot price estimate\n    /// @return high {UoA/tok} The upper end of the lot price estimate\n    function _price(bool useLotPrice) internal view returns (uint192 low, uint192 high) {\n        uint256 low256;\n        uint256 high256;\n\n        uint256 len = basket.erc20s.length;\n        for (uint256 i = 0; i < len; ++i) {\n            uint192 qty = quantity(basket.erc20s[i]);\n            if (qty == 0) continue;\n\n            (uint192 lowP, uint192 highP) = useLotPrice\n                ? assetRegistry.toAsset(basket.erc20s[i]).lotPrice()\n                : assetRegistry.toAsset(basket.erc20s[i]).price();\n\n            low256 += quantityMulPrice(qty, lowP);\n            high256 += quantityMulPrice(qty, highP);\n        }\n\n        low = low256 >= FIX_MAX ? FIX_MAX : uint192(low256);\n        high = high256 >= FIX_MAX ? FIX_MAX : uint192(high256);\n    }\n\n    /// Multiply quantity by price, rounding up to FIX_MAX and down to 0\n    /// @param qty {tok/BU}\n    /// @param p {UoA/tok}\n    function quantityMulPrice(uint192 qty, uint192 p) internal pure returns (uint192) {\n        // untestable:\n        //      qty will never = 0 here because of the check in _price()\n        if (qty == 0 || p == 0) return 0;\n        // untestable:\n        //      qty = FIX_MAX iff p = 0\n        if (qty == FIX_MAX || p == FIX_MAX) return FIX_MAX;\n\n        // return FIX_MAX instead of throwing overflow errors.\n        unchecked {\n            // p and mul *are* Fix values, so have 18 decimals (D18)\n            uint256 rawDelta = uint256(p) * qty; // {D36} = {D18} * {D18}\n            // if we overflowed *, then return FIX_MAX\n            if (rawDelta / p != qty) return FIX_MAX;\n\n            // add in FIX_HALF for rounding\n            uint256 shiftDelta = rawDelta + (FIX_ONE / 2);\n            // untestable (here there be dragons):\n            //          A)  shiftDelta = rawDelta + (FIX_ONE / 2)\n            //      shiftDelta overflows if:\n            //          B)  shiftDelta = MAX_UINT256 - FIX_ONE/2 + 1\n            //              rawDelta + (FIX_ONE/2) = MAX_UINT256 - FIX_ONE/2 + 1\n            //              p * qty = MAX_UINT256 - FIX_ONE + 1\n            //      therefore shiftDelta overflows if:\n            //          C)  p = (MAX_UINT256 - FIX_ONE + 1) / qty\n            //      MAX_UINT256 ~= 1e77 , FIX_MAX ~= 6e57 (6e20 difference in magnitude)\n            //      qty <= 1e21 (MAX_TARGET_AMT)\n            //      qty must be between 1e19 & 1e20 in order for p in (C) to be uint192,\n            //      but qty would have to be < 1e18 in order for (A) to overflow\n            if (shiftDelta < rawDelta) return FIX_MAX;\n\n            // return _div(rawDelta, FIX_ONE, ROUND)\n            return uint192(shiftDelta / FIX_ONE); // {D18} = {D36} / {D18}\n        }\n    }\n\n    /// Return the current reference basket\n    /// @return erc20s The erc20s in the reference basket\n    function basketTokens() external view returns (IERC20[] memory erc20s) {\n        uint256 len = basket.erc20s.length;\n        erc20s = new IERC20[](len);\n        for (uint256 i = 0; i < len; ++i) {\n            erc20s[i] = basket.erc20s[i];\n        }\n    }\n\n    /// Return the current issuance/redemption value of `amount` BUs\n    /// @param amount {BU}\n    /// @return erc20s The backing collateral erc20s\n    /// @return quantities {qTok} ERC20 token quantities equal to `amount` BUs\n    // Returns (erc20s, [quantity(e) * amount {as qTok} for e in erc20s])\n    function quote(uint192 amount, RoundingMode rounding)\n        external\n        view\n        returns (address[] memory erc20s, uint256[] memory quantities)\n    {\n        uint256 length = basket.erc20s.length;\n        erc20s = new address[](length);\n        quantities = new uint256[](length);\n\n        for (uint256 i = 0; i < length; ++i) {\n            erc20s[i] = address(basket.erc20s[i]);\n\n            // {qTok} = {tok/BU} * {BU} * {tok} * {qTok/tok}\n            quantities[i] = quantity(basket.erc20s[i]).mul(amount, rounding).shiftl_toUint(\n                int8(IERC20Metadata(address(basket.erc20s[i])).decimals()),\n                rounding\n            );\n        }\n    }\n\n    /// @return baskets {BU} The balance of basket units held by `account`\n    /// @dev Returns FIX_ZERO for an empty basket\n    // Returns:\n    //    0, if (basket.erc20s is empty) or (disabled is true) or (status() is DISABLED)\n    //    min(e.balanceOf(account) / quantity(e) for e in basket.erc20s if quantity(e) > 0),\n    function basketsHeldBy(address account) public view returns (uint192 baskets) {\n        uint256 length = basket.erc20s.length;\n        if (length == 0 || disabled) return FIX_ZERO;\n        baskets = FIX_MAX;\n\n        for (uint256 i = 0; i < length; ++i) {\n            ICollateral coll = assetRegistry.toColl(basket.erc20s[i]);\n            if (coll.status() == CollateralStatus.DISABLED) return FIX_ZERO;\n\n            uint192 refPerTok = coll.refPerTok();\n            // If refPerTok is 0, then we have zero of coll's reference unit.\n            // We know that basket.refAmts[basket.erc20s[i]] > 0, so we have no baskets.\n            if (refPerTok == 0) return FIX_ZERO;\n\n            // {tok}\n            uint192 bal = coll.bal(account);\n\n            // {tok/BU} = {ref/BU} / {ref/tok}.  0-division averted by condition above.\n            uint192 q = basket.refAmts[basket.erc20s[i]].div(refPerTok, CEIL);\n\n            // {BU} = {tok} / {tok/BU}.  q > 0 because q = (n).div(_, CEIL) and n > 0\n            baskets = fixMin(baskets, bal.div(q));\n        }\n    }\n\n    /* _switchBasket computes basket' from three inputs:\n       - the basket configuration (config: BasketConfig)\n       - the function (isGood: erc20 -> bool), implemented here by goodCollateral()\n       - the function (targetPerRef: erc20 -> Fix) implemented by the Collateral plugin\n\n       ==== Definitions ====\n\n       We use e:IERC20 to mean any erc20 token address, and tgt:bytes32 to mean any target name\n\n       // targetWeight(b, e) is the target-unit weight of token e in basket b\n       Let targetWeight(b, e) = b.refAmt[e] * targetPerRef(e)\n\n       // backups(tgt) is the list of sound backup tokens we plan to use for target `tgt`.\n       Let backups(tgt) = config.backups[tgt].erc20s\n                          .filter(isGood)\n                          .takeUpTo(config.backups[tgt].max)\n\n       Let primeWt(e) = if e in config.erc20s and isGood(e)\n                        then config.targetAmts[e]\n                        else 0\n       Let backupWt(e) = if e in backups(tgt)\n                         then unsoundPrimeWt(tgt) / len(Backups(tgt))\n                         else 0\n       Let unsoundPrimeWt(tgt) = sum(config.targetAmts[e]\n                                     for e in config.erc20s\n                                     where config.targetNames[e] == tgt and !isGood(e))\n\n       ==== The correctness condition ====\n\n       If unsoundPrimeWt(tgt) > 0 and len(backups(tgt)) == 0 for some tgt, then disabled' == true.\n       Else, disabled' == false and targetWeight(basket', e) == primeWt(e) + backupWt(e) for all e.\n\n       ==== Higher-level desideratum ====\n\n       T"
    }
  ]
}