{
  "Title": "H-2: repayAccountPrimeDebtAtSettlement() user lost residual cash",
  "Content": "# Issue H-2: repayAccountPrimeDebtAtSettlement() user lost residual cash \n\nSource: https://github.com/sherlock-audit/2023-03-notional-judging/issues/172 \n\n## Found by \nbin2chen, xiaoming90\n## Summary\n\nin `repayAccountPrimeDebtAtSettlement() `\nIncorrect calculation of `primeCashRefund` value (always == 0)\nResulting in the loss of the user's residual  cash\n\n## Vulnerability Detail\n\nwhen settle Vault Account \nwill execute `settleVaultAccount()`->`repayAccountPrimeDebtAtSettlement()`\nIn the `repayAccountPrimeDebtAtSettlement()` method the residual amount will be refunded to the user\nThe code is as follows.\n```solidity\n    function repayAccountPrimeDebtAtSettlement(\n        PrimeRate memory pr,\n        VaultStateStorage storage primeVaultState,\n        uint16 currencyId,\n        address vault,\n        address account,\n        int256 accountPrimeCash,\n        int256 accountPrimeStorageValue\n    ) internal returns (int256 finalPrimeDebtStorageValue, bool didTransfer) {\n...\n\n            if (netPrimeDebtRepaid < accountPrimeStorageValue) {\n                // If the net debt change is greater than the debt held by the account, then only\n                // decrease the total prime debt by what is held by the account. The residual amount\n                // will be refunded to the account via a direct transfer.\n                netPrimeDebtChange = accountPrimeStorageValue;\n                finalPrimeDebtStorageValue = 0;\n\n                int256 primeCashRefund = pr.convertFromUnderlying(\n                    pr.convertDebtStorageToUnderlying(netPrimeDebtChange.sub(accountPrimeStorageValue)) //<--------@audit always ==0\n                );\n                TokenHandler.withdrawPrimeCash(\n                    account, currencyId, primeCashRefund, pr, false // ETH will be transferred natively\n                );\n                didTransfer = true;\n            } else {\n```\n\nFrom the above code we can see that there is a spelling error\n\n1. netPrimeDebtChange = accountPrimeStorageValue;\n2. primeCashRefund = netPrimeDebtChange.sub(accountPrimeStorageValue)\nso primeCashRefund always ==0\n\nshould be `primeCashRefund = netPrimeDebtRepaid - accountPrimeStorageValue`\n\n\n## Impact\n\n`primeCashRefund` always == 0 ,  user lost residual cash\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-03-notional/blob/main/contracts-v2/contracts/internal/vaults/VaultAccount.sol#L575\n\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n```solidity\n    function repayAccountPrimeDebtAtSettlement(\n        PrimeRate memory pr,\n        VaultStateStorage storage primeVaultState,\n        uint16 currencyId,\n        address vault,\n        address account,\n        int256 accountPrimeCash,\n        int256 accountPrimeStorageValue\n    ) internal returns (int256 finalPrimeDebtStorageValue, bool didTransfer) {\n...\n\n            if (netPrimeDebtRepaid < accountPrimeStorageValue) {\n                // If the net debt change is greater than the debt held by the account, then only\n                // decrease the total prime debt by what is held by the account. The residual amount\n                // will be refunded to the account via a direct transfer.\n                netPrimeDebtChange = accountPrimeStorageValue;\n                finalPrimeDebtStorageValue = 0;\n\n                int256 primeCashRefund = pr.convertFromUnderlying(\n-                   pr.convertDebtStorageToUnderlying(netPrimeDebtChange.sub(accountPrimeStorageValue))\n+                   pr.convertDebtStorageToUnderlying(netPrimeDebtRepaid.sub(accountPrimeStorageValue)) \n                );\n                TokenHandler.withdrawPrimeCash(\n                    account, currencyId, primeCashRefund, pr, false // ETH will be transferred natively\n                );\n                didTransfer = true;\n            } else {\n```\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/59",
  "Code": [
    {
      "filename": "contracts-v2/contracts/internal/vaults/VaultAccount.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport {\n    VaultConfig,\n    VaultAccount,\n    VaultAccountStorage,\n    VaultState,\n    VaultStateStorage,\n    VaultAccountSecondaryDebtShareStorage,\n    PrimeRate\n} from \"../../global/Types.sol\";\nimport {LibStorage} from \"../../global/LibStorage.sol\";\nimport {Constants} from \"../../global/Constants.sol\";\nimport {SafeInt256} from \"../../math/SafeInt256.sol\";\nimport {SafeUint256} from \"../../math/SafeUint256.sol\";\n\nimport {Emitter} from \"../Emitter.sol\";\nimport {PrimeRateLib} from \"../pCash/PrimeRateLib.sol\";\nimport {PrimeCashExchangeRate} from \"../pCash/PrimeCashExchangeRate.sol\";\nimport {TokenHandler} from \"../balances/TokenHandler.sol\";\n\nimport {VaultSecondaryBorrow} from \"./VaultSecondaryBorrow.sol\";\nimport {VaultConfiguration} from \"./VaultConfiguration.sol\";\nimport {VaultStateLib} from \"./VaultState.sol\";\n\nimport {IVaultAction} from \"../../../interfaces/notional/IVaultController.sol\";\n\nlibrary VaultAccountLib {\n    using VaultConfiguration for VaultConfig;\n    using VaultStateLib for VaultState;\n    using PrimeRateLib for PrimeRate;\n    using SafeInt256 for int256;\n    using SafeUint256 for uint256;\n\n    event VaultSettledAssetsRemaining(\n        address indexed vault,\n        uint256 indexed maturity,\n        int256 remainingPrimeCash,\n        uint256 remainingStrategyTokens\n    );\n\n    event VaultAccountLendAtZeroInterest(\n        address indexed vault,\n        uint256 indexed maturity,\n        address indexed account,\n        uint16 currencyId,\n        int256 fCashRepaid,\n        int256 primeCashCostToLend\n    );\n\n    /// @notice Returns a single account's vault position\n    function getVaultAccount(\n        address account, VaultConfig memory vaultConfig\n    ) internal view returns (VaultAccount memory vaultAccount) {\n        mapping(address => mapping(address => VaultAccountStorage)) storage store = LibStorage.getVaultAccount();\n        VaultAccountStorage storage s = store[account][vaultConfig.vault];\n\n        vaultAccount.maturity = s.maturity;\n        vaultAccount.vaultShares = s.vaultShares;\n        vaultAccount.account = account;\n        // Read any temporary cash balance onto the stack to be applied\n        vaultAccount.tempCashBalance = int256(uint256(s.primaryCash));\n        vaultAccount.lastUpdateBlockTime = s.lastUpdateBlockTime;\n\n        vaultAccount.accountDebtUnderlying = VaultStateLib.readDebtStorageToUnderlying(\n            vaultConfig.primeRate, vaultAccount.maturity, s.accountDebt\n        );\n    }\n\n    /// @notice Called when a vault account is liquidated and cash is deposited into its account and held\n    /// as collateral against fCash\n    function setVaultAccountForLiquidation(\n        VaultAccount memory vaultAccount,\n        VaultConfig memory vaultConfig,\n        uint256 currencyIndex,\n        int256 netCashBalanceChange,\n        bool checkMinBorrow\n    ) internal {\n        mapping(address => mapping(address => VaultAccountStorage)) storage store = LibStorage\n            .getVaultAccount();\n        VaultAccountStorage storage s = store[vaultAccount.account][vaultConfig.vault];\n        \n        if (currencyIndex == 0) {\n            s.primaryCash = int256(uint256(s.primaryCash)).add(netCashBalanceChange).toUint().toUint80();\n        } else if (currencyIndex == 1) {\n            s.secondaryCashOne = int256(uint256(s.secondaryCashOne)).add(netCashBalanceChange).toUint().toUint80();\n        } else if (currencyIndex == 2) {\n            s.secondaryCashTwo = int256(uint256(s.secondaryCashTwo)).add(netCashBalanceChange).toUint().toUint80();\n        } else {\n            // This should never occur\n            revert();\n        }\n\n        // Clear temp cash balance, it is not updated during liquidation\n        vaultAccount.tempCashBalance = 0;\n\n        _setVaultAccount(vaultAccount, vaultConfig, s, checkMinBorrow, true);\n    }\n\n    /// @notice Sets a single account's vault position in storage\n    function setVaultAccount(\n        VaultAccount memory vaultAccount,\n        VaultConfig memory vaultConfig,\n        bool checkMinBorrow \n    ) internal {\n        mapping(address => mapping(address => VaultAccountStorage)) storage store = LibStorage\n            .getVaultAccount();\n        VaultAccountStorage storage s = store[vaultAccount.account][vaultConfig.vault];\n\n        _setVaultAccount(vaultAccount, vaultConfig, s, checkMinBorrow, false);\n\n        // Cash balances should never be preserved after a non-liquidation transaction,\n        // during enter, exit, roll and settle any cash balances should be applied to\n        // the transaction. These cash balances are only set after liquidation.\n        s.primaryCash = 0;\n        require(s.secondaryCashOne == 0 && s.secondaryCashTwo == 0); // dev: secondary cash\n    }\n\n    function _setVaultAccount(\n        VaultAccount memory vaultAccount,\n        VaultConfig memory vaultConfig,\n        VaultAccountStorage storage s,\n        bool checkMinBorrow,\n        bool isLiquidation\n    ) private {\n        // The temporary cash balance must be cleared to zero by the end of the transaction\n        require(vaultAccount.tempCashBalance == 0); // dev: cash balance not cleared\n        // An account must maintain a minimum borrow size in order to enter the vault. If the account\n        // wants to exit under the minimum borrow size it must fully exit so that we do not have dust\n        // accounts that become insolvent.\n        if (\n            vaultAccount.accountDebtUnderlying.neg() < vaultConfig.minAccountBorrowSize &&\n            // During local currency liquidation and settlement, the min borrow check is skipped\n            checkMinBorrow\n        ) {\n            // NOTE: use 1 to represent the minimum amount of vault shares due to rounding in the\n            // vaultSharesToLiquidator calculation\n            require(vaultAccount.accountDebtUnderlying == 0 || vaultAccount.vaultShares <= 1, \"Min Borrow\");\n        }\n\n        if (vaultConfig.hasSecondaryBorrows()) {\n            VaultAccountSecondaryDebtShareStorage storage _s = \n                LibStorage.getVaultAccountSecondaryDebtShare()[vaultAccount.account][vaultConfig.vault];\n            uint256 secondaryMaturity = _s.maturity;\n            require(vaultAccount.maturity == secondaryMaturity || secondaryMaturity == 0); // dev: invalid maturity\n        }\n\n        uint256 newDebtStorageValue = VaultStateLib.calculateDebtStorage(\n            vaultConfig.primeRate,\n            vaultAccount.maturity,\n            vaultAccount.accountDebtUnderlying\n        ).neg().toUint();\n\n        if (!isLiquidation) {\n            // Liquidation will emit its own custom events\n            Emitter.emitVaultAccountChanges(vaultAccount, vaultConfig, s, newDebtStorageValue);\n        }\n\n        s.vaultShares = vaultAccount.vaultShares.toUint80();\n        s.maturity = vaultAccount.maturity.toUint40();\n        s.lastUpdateBlockTime = vaultAccount.lastUpdateBlockTime.toUint32();\n        s.accountDebt = newDebtStorageValue.toUint80();\n    }\n\n    /// @notice Updates the secondary cash held by the account, should only be updated in two places:\n    ///   - During liquidation of a secondary borrow\n    ///   - On vault exit when the secondary borrow currency is holding cash\n    /// In setVaultAccount, a vault account cannot end up with a secondary cash balance at the end of a\n    /// user initiated (non-liquidation) transaction. The vault must clearVaultAccountSecondaryCash during\n    /// the redemption of strategy tokens.\n    function setVaultAccountSecondaryCash(\n        address account,\n        address vault,\n        int256 netSecondaryPrimeCashOne,\n        int256 netSecondaryPrimeCashTwo\n    ) internal {\n        VaultAccountStorage storage s = LibStorage.getVaultAccount()[account][vault];\n        s.secondaryCashOne = int256(uint256(s.secondaryCashOne)).add(netSecondaryPrimeCashOne).toUint().toUint80();\n        s.secondaryCashTwo = int256(uint256(s.secondaryCashTwo)).add(netSecondaryPrimeCashTwo).toUint().toUint80();\n    }\n\n    function checkVaultAccountSecondaryCash(\n        address account,\n        address vault\n    ) internal view {\n        VaultAccountStorage storage s = LibStorage.getVaultAccount()[account][vault];\n        require(s.secondaryCashOne == 0);\n        require(s.secondaryCashTwo == 0);\n    }\n    \n    function clearVaultAccountSecondaryCash(\n        address account,\n        address vault\n    ) internal returns (int256 secondaryCashOne, int256 secondaryCashTwo) {\n        VaultAccountStorage storage s = LibStorage.getVaultAccount()[account][vault];\n        secondaryCashOne = int256(uint256(s.secondaryCashOne));\n        secondaryCashTwo = int256(uint256(s.secondaryCashTwo));\n\n        s.secondaryCashOne = 0;\n        s.secondaryCashTwo = 0;\n    }\n\n    /// @notice Updates an account's fCash position and the current vault state at the same time. Also updates\n    /// and checks the total borrow capacity\n    /// @param vaultAccount vault account\n    /// @param vaultState vault state matching the maturity\n    /// @param netUnderlyingDebt underlying debt change to the account, (borrowing < 0, lending > 0)\n    /// @param netPrimeCash amount of prime cash to charge or credit to the account, must be the oppositely\n    /// signed compared to the netfCash sign\n    function updateAccountDebt(\n        VaultAccount memory vaultAccount,\n        VaultState memory vaultState,\n        int256 netUnderlyingDebt,\n        int256 netPrimeCash\n    ) internal pure {\n        if (vaultAccount.maturity != vaultState.maturity) {\n            // If borrowing across maturities, ensure that the account does not have any\n            // debt in the old maturity remaining in their account.\n            require(vaultAccount.accountDebtUnderlying == 0);\n        }\n        vaultAccount.tempCashBalance = vaultAccount.tempCashBalance.add(netPrimeCash);\n\n        // Update debt state on the account and the vault\n        vaultAccount.accountDebtUnderlying = vaultAccount.accountDebtUnderlying.add(netUnderlyingDebt);\n        require(vaultAccount.accountDebtUnderlying <= 0);\n        vaultState.totalDebtUnderlying = vaultState.totalDebtUnderlying.add(netUnderlyingDebt);\n\n        // Truncate dust balances towards zero\n        if (0 < vaultState.totalDebtUnderlying && vaultState.totalDebtUnderlying < 10) vaultState.totalDebtUnderlying = 0;\n        require(vaultState.totalDebtUnderlying <= 0);\n    }\n\n\n    /// @notice Enters into a vault position, borrowing from Notional if required.\n    /// @param vaultAccount vault account entering the position\n    /// @param vaultConfig vault configuration\n    /// @param maturity maturity to enter into\n    /// @param underlyingToBorrow a positive amount of underlying to borrow, will be converted to a negative\n    /// amount inside the method\n    /// @param maxBorrowRate the maximum annualized interest rate to borrow at, a zero signifies no\n    /// slippage limit applied\n    /// @param vaultData arbitrary data to be passed to the vault\n    /// @param strategyTokenDeposit some amount of strategy tokens from a previous maturity that will\n    /// be carried over into the current maturity\n    /// @return vaultSharesAdded the total vault shares added to the maturity for the account,\n    /// including any strategy tokens transferred during a roll or settle\n    function borrowAndEnterVault(\n        VaultAccount memory vaultAccount,\n        VaultConfig memory vaultConfig,\n        uint256 maturity,\n        uint256 underlyingToBorrow,\n        uint32 maxBorrowRate,\n        bytes calldata vaultData,\n        uint256 strategyTokenDeposit\n    ) internal returns (uint256 vaultSharesAdded) {\n        // The vault account can only be increasing their borrow position or not have one set. If they\n        // are increasing their position they must be borrowing from the same maturity.\n        require(vaultAccount.maturity == maturity || vaultAccount.accountDebtUnderlying == 0);\n        VaultState memory vaultState = VaultStateLib.getVaultState(vaultConfig, maturity);\n\n        // Borrows fCash and puts the cash balance into the vault account's temporary cash balance\n        if (underlyingToBorrow > 0) {\n            _borrowIntoVault(\n                vaultAccount,\n                vaultConfig,\n                vaultState,\n                maturity,\n                underlyingToBorrow.toInt().neg(),\n                maxBorrowRate\n            );\n        } else if (maturity != Constants.PRIME_CASH_VAULT_MATURITY) {\n            // Ensure that the maturity is a valid one if we are not borrowing (borrowing will fail)\n            // against an invalid market.\n            VaultConfiguration.checkValidMaturity(\n                vaultConfig.borrowCurrencyId,\n                maturity,\n                vaultConfig.maxBorrowMarketIndex,\n                block.timestamp\n            );\n        }\n\n        // Sets the maturity on the vault account, deposits tokens into the vault, and updates the vault state \n        vaultSharesAdded = vaultState.enterMaturity(vaultAccount, vaultConfig, strategyTokenDeposit, vaultData);\n        vaultAccount.lastUpdateBlockTime = block.timestamp;\n        setVaultAccount({vaultAccount: vaultAccount, vaultConfig: vaultConfig, checkMinBorrow: true});\n    }\n\n    ///  @notice Borrows fCash to enter a vault and pays fees\n    ///  @dev Updates vault fCash in storage, updates vaultAccount in memory\n    ///  @param vaultAccount the account's position in the vault\n    ///  @param vaultConfig configuration for the given vault\n    ///  @param maturity the maturity to enter for the vault\n    ///  @param underlyingToBorrow amount of underlying to borrow from the market, must be negative\n    ///  @param maxBorrowRate maximum annualized rate to pay for the borrow\n    function _borrowIntoVault(\n        VaultAccount memory vaultAccount,\n        VaultConfig memory vaultConfig,\n        VaultState memory vaultState,\n        uint256 maturity,\n        int256 underlyingToBorrow,\n        uint32 maxBorrowRate\n    ) private {\n        require(underlyingToBorrow < 0); // dev: fcash must be negative\n\n        int256 primeCashBorrowed;\n        if (maturity == Constants.PRIME_CASH_VAULT_MATURITY) {\n            primeCashBorrowed = vaultConfig.primeRate.convertFromUnderlying(underlyingToBorrow).neg();\n        } else {\n            // fCash fees are assessed on the amount of cash borrowed after execution of the trade\n            primeCashBorrowed = VaultConfiguration.executeTrade(\n                vaultConfig.borrowCurrencyId,\n                vaultConfig.vault,\n                maturity,\n                underlyingToBorrow,\n                maxBorrowRate,\n                vaultConfig.maxBorrowMarketIndex,\n                block.timestamp\n            );\n            // Only assess fCash fees here, Prime Cash fees are assessed in a separate method\n            vaultConfig.assessVaultFees(vaultAccount, primeCashBorrowed, maturity, block.timestamp);\n        }\n        require(primeCashBorrowed > 0, \"Borrow failed\");\n\n        updateAccountDebt(vaultAccount, vaultState, underlyingToBorrow, primeCashBorrowed);\n\n        // Ensure that we are above the minimum borrow size. Accounts smaller than this are not profitable\n        // to unwind if we need to liquidate.\n        require(vaultConfig.minAccountBorrowSize <= vaultAccount.accountDebtUnderlying.neg(), \"Min Borrow\");\n    }\n\n    /// @notice Allows an account to exit a vault term prematurely by lending fCash.\n    /// @param vaultAccount the account's position in the vault\n    /// @param vaultConfig configuration for the given vault\n    /// @param underlyingToRepay amount of underlying to lend must be positive and cannot\n    /// lend more than the account's debt\n    /// @param minLendRate minimum rate to lend at\n    /// @param blockTime current block time\n    function lendToExitVault(\n        VaultAccount memory vaultAccount,\n        VaultConfig memory vaultConfig,\n        VaultState memory vaultState,\n        int256 underlyingToRepay,\n        uint32 minLendRate,\n        uint256 blockTime\n    ) internal {\n        if (underlyingToRepay == 0) return;\n\n        // Don't allow the vault to lend to positive\n        require(vaultAccount.accountDebtUnderlying.add(underlyingToRepay) <= 0); // dev: positive debt\n        \n        // Check that the account is in an active vault\n        require(blockTime < vaultAccount.maturity);\n        \n        // Returns the cost in prime cash terms as a negative value to lend an offsetting fCash position\n        // so that the account can exit.\n        int256 primeCashCostToLend;\n        if (vaultAccount.maturity != Constants.PRIME_CASH_VAULT_MATURITY) {\n            primeCashCostToLend = VaultConfiguration.executeTrade(\n                vaultConfig.borrowCurrencyId,\n                vaultConfig.vault,\n                vaultAccount.maturity,\n                underlyingToRepay,\n                minLendRate,\n                vaultConfig.maxBorrowMarketIndex,\n                blockTime\n            );\n        }\n\n        if (primeCashCostToLend == 0) {\n            // There are two possibilities we reach this condition:\n            //  - The account is borrowing in variable prime cash\n            //  - Lending fCash has failed due to a lack of liquidity or negative interest rates. In this\n            //    case just just net off the the prime cash balance and the account will forgo any money\n            //    market interest accrued between now and maturity.\n            //    If this scenario were to occur, it is most likely that interest rates are near zero suggesting\n            //    that money market interest rates are also near zero (therefore the account is really not giving\n            //    up much by forgoing money market interest).\n            // NOTE: underlyingToRepay is positive here so primeCashToLend will be negative\n            primeCashCostToLend = vaultConfig.primeRate.convertFromUnderlying(underlyingToRepay).neg();\n\n            if (vaultAccount.maturity != Constants.PRIME_CASH_VAULT_MATURITY) {\n                // Updates some state to track lending at zero for off chain accounting.\n                PrimeCashExchangeRate.updateSettlementReserveForVaultsLendingAtZero(\n                    vaultConfig.vault,\n                    vaultConfig.borrowCurrencyId,\n                    vaultAccount.maturity,\n                    primeCashCostToLend.neg(),\n                    underlyingToRepay\n                );\n            }\n        }\n        require(primeCashCostToLend <= 0);\n\n        updateAccountDebt(vaultAccount, vaultState, underlyingToRepay, primeCashCostToLend);\n        // NOTE: vault account and vault state are not set into storage in this method.\n    }\n\n    /// @notice Settles a vault account that has a position in a matured vault.\n    /// @param vaultAccount the account's position in the vault\n    /// @param vaultConfig configuration for the given vault\n    /// @return didSettle true if the account did settle, false if it did not\n    /// @return didTransfer true if the account did a transfer, false if it did not\n    function settleVaultAccount(\n        VaultAccount memory vaultAccount,\n        VaultConfig memory vaultConfig\n    ) internal returns (bool didSettle, bool didTransfer) {\n        // PRIME_CASH_VAULT_MATURITY will always be greater than block time and will not settle,\n        // fCash settles exactly on block time. This exit will prevent any invalid maturities.\n        if (vaultAccount.maturity == 0 || block.timestamp < vaultAccount.maturity) return (false, false);\n        VaultState memory vaultState = VaultStateLib.getVaultState(vaultConfig, vaultAccount.maturity);\n\n        VaultStateStorage storage primeVaultState = LibStorage.getVaultState()\n            [vaultConfig.vault][Constants.PRIME_CASH_VAULT_MATURITY];\n        if (!vaultState.isSettled) {\n            // Settles and updates the total prime debt so that max vault capacity\n            // accounting is correct.\n            VaultStateLib.settleTotalDebtToPrimeCash(\n                primeVaultState,\n                vaultConfig.vault,\n                vaultConfig.borrowCurrencyId,\n                vaultState.maturity,\n                vaultState.totalDebtUnderlying\n            );\n\n            // This should only ever happen once, clear the total debt\n            // underlying since it has transferred to the prime cash vault\n            vaultState.totalDebtUnderlying = 0;\n            vaultState.isSettled = true;\n            // Set the fCash vault state to settled.\n            vaultState.setVaultState(vaultConfig);\n        }\n\n        // Reduces vault shares in the fcash vault state in storage. Adds prime cash vault\n        // shares to the account in memory.\n        vaultState.settleVaultSharesToPrimeVault(vaultAccount, vaultConfig, primeVaultState);\n\n        // Settle any secondary borrows if they exist into prime cash borrows.\n        bool didTransferSecondary = false;\n        if (vaultConfig.hasSecondaryBorrows()) {\n            didTransferSecondary = IVaultAction(address(this)).settleSecondaryBorrowForAccount(\n                vaultConfig.vault, vaultAccount.account\n            );\n        }\n\n        int256 accountPrimeStorageValue = PrimeRateLib.convertSettledfCashInVault(\n            vaultConfig.borrowCurrencyId,\n            vaultAccount.maturity,\n            vaultAccount.accountDebtUnderlying,\n            address(0)\n        );\n\n        // Calculates the net settled cash if there is any temp cash balance that is net off\n        // against the settled prime debt.\n        bool didTransferPrimary;\n        (accountPrimeStorageValue, didTransferPrimary) = repayAccountPrimeDebtAtSettlement(\n            vaultConfig.primeRate,\n            primeVaultState,\n            vaultConfig.borrowCurrencyId,\n            vaultConfig.vault,\n            vaultAccount.account,\n            vaultAccount.tempCashBalance,\n            accountPrimeStorageValue\n        );\n        // Clear any temp cash balance, it has been applied to the debt\n        vaultAccount.tempCashBalance = 0;\n\n        // Assess prime cash vault fees into the temp cash balance. The account has accrued prime cash\n        // fees on the time since the fCash matured to the current block time. Setting lastUpdateBlockTime\n        // to the fCash maturity, will calculate the fees accrued since that time.\n        vaultAccount.lastUpdateBlockTime = vaultAccount.maturity;\n        vaultAccount.maturity = Constants.PRIME_CASH_VAULT_MATURITY;\n        vaultAccount.accountDebtUnderlying = vaultConfig.primeRate.convertDebtStorageToUnderlying(accountPrimeStorageValue);\n        vaultConfig.assessVaultFees(\n            vaultAccount,\n            vaultConfig.primeRate.convertFromUnderlying(vaultAccount.accountDebtUnderlying).neg(),\n            Constants.PRIME_CASH_VAULT_MATURITY,\n            block.timestamp\n        );\n\n        return (true, didTransferPrimary || didTransferSecondary);\n    }\n\n    /// @notice Called at the beginning of all vault actions (enterVault, exitVault, rollVaultPosition,\n    /// deleverageVault) to ensure that certain actions occur prior to any other account actions.\n    function settleAccountOrAccruePrimeCashFees(\n        VaultAccount memory vaultAccount,\n        VaultConfig memory vaultConfig\n    ) internal returns (bool didSettle) {\n        // If the vault has matured, it will exit this settlement call in the prime cash maturity with\n        // fees assessed up to the current time. Transfers may occur but they are not relevant in this\n        // context since a collateral check will always be done on non-settlement methods.\n        (didSettle, /* */) = settleVaultAccount(vaultAccount, vaultConfig);\n\n        // If the account did not settle but is in the prime cash maturity, assess a fee.\n        if (!didSettle && vaultAccount.maturity == Constants.PRIME_CASH_VAULT_MATURITY) {\n            // The prime cash fee is deducted from the tempCashBalance\n            vaultConfig.assessVaultFees(\n                vaultAccount,\n                vaultConfig.primeRate.convertFromUnderlying(vaultAccount.accountDebtUnderlying).neg(),\n                vaultAccount.maturity,\n                block.timestamp\n            );\n        }\n    }\n\n    function accruePrimeCashFeesToDebtInLiquidation(\n        VaultAccount memory vaultAccount,\n        VaultConfig memory vaultConfig\n    ) internal returns (VaultState memory) {\n        vaultConfig.assessVaultFees(\n            vaultAccount,\n            vaultConfig.primeRate.convertFromUnderlying(vaultAccount.accountDebtUnderlying).neg(),\n            vaultAccount.maturity,\n            block.timestamp\n        );\n\n        return accruePrimeCashFeesToDebt(vaultAccount, vaultConfig);\n    }\n\n    /// @notice Accrues prime cash fees directly to debt during settlement and liquidation\n    function accruePrimeCashFeesToDebt(\n        VaultAccount memory vaultAccount,\n        VaultConfig memory vaultConfig\n    ) internal returns (VaultState memory vaultPrimeState) {\n        require(vaultAccount.maturity == Constants.PRIME_CASH_VAULT_MATURITY);\n\n        // During settle vault account, the prime cash fee is accrued to debt instead\n        // of left in the tempCashBalance.\n        vaultPrimeState = VaultStateLib.getVaultState(vaultConfig, Constants.PRIME_CASH_VAULT_MATURITY);\n\n        // Fees and prime cash claims will be held in temp cash balance. There cannot be a positive cash balance\n        // during this method, any excess positive cash should be sent back to the account during\n        // settleAccountfCashBalance\n        require(vaultAccount.tempCashBalance <= 0);\n        \n        updateAccountDebt(\n            vaultAccount,\n            vaultPrimeState,\n            vaultConfig.primeRate.convertToUnderlying(vaultAccount.tempCashBalance),\n            vaultAccount.tempCashBalance.neg()\n        );\n\n        vaultPrimeState.setVaultState(vaultConfig);\n    }\n\n    function repayAccountPrimeDebtAtSettlement(\n        PrimeRate memory pr,\n        VaultStateStorage storage primeVaultState,\n        uint16 currencyId,\n        address vault,\n        address account,\n        int256 accountPrimeCash,\n        int256 accountPrimeStorageValue\n    ) internal returns (int256 finalPrimeDebtStorageValue, bool didTransfer) {\n        didTransfer = false;\n        finalPrimeDebtStorageValue = accountPrimeStorageValue;\n        \n        if (accountPrimeCash > 0) {\n            // netPrimeDebtRepaid is a negative number\n            int256 netPrimeDebtRepaid = pr.convertUnderlyingToDebtStorage(\n                pr.convertToUnderlying(accountPrimeCash).neg()\n            );\n\n            int256 netPrimeDebtChange;\n            if (netPrimeDebtRepaid < accountPrimeStorageValue) {\n                // If the net debt change is greater than the debt held by the account, then only\n                // decrease the total prime debt by what is held by the account. The residual amount\n                // will be refunded to the account via a direct transfer.\n                netPrimeDebtChange = accountPrimeStorageValue;\n                finalPrimeDebtStorageValue = 0;\n\n                int256 primeCashRefund = pr.convertFromUnderlying(\n                    pr.convertDebtStorageToUnderlying(netPrimeDebtChange.sub(accountPrimeStorageValue))\n                );\n                TokenHandler.withdrawPrimeCash(\n                    account, currencyId, primeCashRefund, pr, false // ETH will be transferred natively\n                );\n                didTransfer = true;\n            } else {\n                // In this case, part of the account's debt is repaid.\n                netPrimeDebtChange = netPrimeDebtRepaid;\n                finalPrimeDebtStorageValue = accountPrimeStorageValue.sub(netPrimeDebtRepaid);\n            }\n\n            // Updates the global prime debt figure and events are emitted via the vault.\n            pr.updateTotalPrimeDebt(vault, currencyId, netPrimeDebtChange);\n\n            // Updates the state on the prime vault storage directly.\n            int256 totalPrimeDebt = int256(uint256(primeVaultState.totalDebt));\n            int256 newTotalDebt = totalPrimeDebt.add(netPrimeDebtChange);\n            // Set the total debt to the storage value\n            primeVaultState.totalDebt = newTotalDebt.toUint().toUint80();\n        }\n    }\n}"
    }
  ]
}