{
  "Title": "M-4: Attackers can bypass `tokensPerMint` and mint lots of tokens in a transaction",
  "Content": "# Issue M-4: Attackers can bypass `tokensPerMint` and mint lots of tokens in a transaction \n\nSource: https://github.com/sherlock-audit/2022-10-nftport-judging/issues/85 \n\n## Found by \n0xSmartContract, GimelSec\n\n## Summary\n\nAttackers can bypass `tokensPerMint`, allowing them to mint over `tokensPerMint` per transaction.\n\n## Vulnerability Detail\n\nNFTCollection has `tokensPerMint` that enforces the maximum number of tokens the user can mint per transaction. But attackers can bypass `tokensPerMint` by reentrancy attack to call `mint()` or `presaleMint()` multiple times in a transaction.\n\nFor example, we assume that `tokensPerMint` is `5` and we have a large amount of `availableSupply()`:\n1. Alice (attacker) first creates an `AttackerContract` to call `mint(5)`, then [L318](https://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/templates/NFTCollection.sol#L318) will check that `amount <= _deploymentConfig.tokensPerMint` and call `_safeMint()` on L321.\n2. But `_safeMint()` has a [callback](https://github.com/chiru-labs/ERC721A/blob/v3.2.0/contracts/ERC721A.sol#L392) that it will call `onERC721Received()` if `to` address is a contract.\n3. Now `_safeMint()` calls `onERC721Received()` on the `AttackerContract`, and the `AttackerContract` re-enter `mint(5)` again. `mint()` function will pass the check of `tokensPerMint` on L318 again. Finally, Alice will mint 5+5 tokens in a transaction.\n\n## Impact\n\nAttackers can re-enter `mint()` function again and again to bypass the check of `tokensPerMint`, and mint lots of tokens in a transaction.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/templates/NFTCollection.sol#L317-L322\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIf the protocol wants to check `to` address, keep `_safeMint()` and add [ReentrancyGuard.sol](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol) on `mint()` and `presaleMint()` to prevent reentrancy attack.\n\nOr just replace `_safeMint()` with `_mint()`.\n\n## Discussion\n\n**hyperspacebunny**\n\nI believe this only applies to free mints since `msg.value` will be 0 when called from the attacker's contract and `mint()` will revert due to the `paymentProvided` modifier.\n\n**hyperspacebunny**\n\nFixed in https://github.com/nftport/evm-minting-sherlock-fixes/pull/14\n\n**rayn731**\n\nFixed, the fix uses reentrancy guard to prevent the bypass.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/14",
  "Code": [
    {
      "filename": "evm-minting-master/contracts/templates/NFTCollection.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"erc721a/contracts/ERC721A.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n\nimport \"../lib/ERC2981.sol\";\nimport \"../lib/Base64.sol\";\nimport \"../lib/ITemplate.sol\";\n\n/**\n * @title NFTCollection\n * @notice Implements https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension.\n *\n * Uses ERC721A, with token IDs starting from 0 and increasing sequentially.\n * This is a template contract, meaning it cannot be initialized or used directly.\n * The only function of this contract is to store the code that proxies delegate their logic to.\n */\ncontract NFTCollection is\n    ERC721A,\n    ERC2981,\n    AccessControl,\n    Initializable,\n    ITemplate\n{\n    using Address for address payable;\n    using Strings for uint256;\n\n    /// Fixed at deployment time\n    struct DeploymentConfig {\n        // Name of the NFT contract.\n        string name;\n        // Symbol of the NFT contract.\n        string symbol;\n        // The contract owner address. If you wish to own the contract, then set it as your wallet address.\n        // This is also the wallet that can manage the contract on NFT marketplaces. Use `transferOwnership()`\n        // to update the contract owner. Owner gets `ADMIN_ROLE` and `DEFAULT_ADMIN_ROLE`, see {AccessControl}.\n        // The only part of `DeploymentConfig`, that can be updated after deployment.\n        address owner;\n        // The maximum number of tokens that can be minted in this collection.\n        uint256 maxSupply;\n        // The number of free token mints reserved for the contract owner\n        uint256 reservedSupply;\n        // The maximum number of tokens the user can mint per transaction.\n        uint256 tokensPerMint;\n        // Treasury address is the address where minting fees can be withdrawn to.\n        // Use `withdrawFees()` to transfer the entire contract balance to the treasury address.\n        address payable treasuryAddress;\n    }\n\n    /// Updatable by admins and owner with `updateConfig`\n    struct RuntimeConfig {\n        // Metadata base URI for tokens, NFTs minted in this contract will have metadata URI of `baseURI` + `tokenID`.\n        // Set this to reveal token metadata.\n        string baseURI;\n        // If true, the base URI of the NFTs minted in the specified contract can be updated after minting (token URIs\n        // are not frozen on the contract level). This is useful for revealing NFTs after the drop. If false, all the\n        // NFTs minted in this contract are frozen by default which means token URIs are non-updatable.\n        bool metadataUpdatable;\n        // Minting price per token for public minting\n        uint256 publicMintPrice;\n        // Flag for freezing the public mint price\n        bool publicMintPriceFrozen;\n        // Minting price per token for presale minting\n        uint256 presaleMintPrice;\n        // Flag for freezing the presale mint price\n        bool presaleMintPriceFrozen;\n        // Starting timestamp for public minting.\n        uint256 publicMintStart;\n        // Starting timestamp for whitelisted/presale minting,\n        // both public and presale minting can be active at the same time.\n        uint256 presaleMintStart;\n        // Pre-reveal token URI for placeholder metadata. This will be returned for all token IDs until a `baseURI`\n        // has been set.\n        string prerevealTokenURI;\n        // Root of the Merkle tree of whitelisted addresses. This is used to check if a wallet has been whitelisted\n        // for presale minting.\n        bytes32 presaleMerkleRoot;\n        // Secondary market royalties in basis points (100 bps = 1%). Royalties use ERC2981 standard and support\n        // OpenSea standard.\n        uint256 royaltiesBps;\n        // Address for royalties\n        address royaltiesAddress;\n    }\n\n    // Used in `getInfo()` to get full contract info\n    struct ContractInfo {\n        // semver-style contract version from `VERSION`\n        uint256 version;\n        // Contract config that is fixed on deployment\n        DeploymentConfig deploymentConfig;\n        // Updatable runtime config\n        RuntimeConfig runtimeConfig;\n    }\n\n    // Event emitted when `transferOwnership` called by current owner.\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /*************\n     * Constants *\n     *************/\n\n    /// Contract name\n    string public constant NAME = \"NFTCollection\";\n\n    /// Contract version, semver-style uint X_YY_ZZ\n    uint256 public constant VERSION = 1_04_00;\n\n    /// Admin role, on contract initialization given to the deployer.\n    // Can be updated with `transferOwnership`\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n\n    // Basis for calculating royalties.\n    // This has to be 10k for royaltiesBps to be in basis points.\n    uint16 public constant ROYALTIES_BASIS = 10000;\n\n    /********************\n     * Public variables *\n     ********************/\n\n    /// The number of tokens remaining in the reserve\n    /// @dev Managed by the contract\n    uint256 public reserveRemaining;\n\n    /***************************\n     * Contract initialization *\n     ***************************/\n\n    constructor() ERC721A(\"\", \"\") initializer {}\n\n    /// Contract initializer\n    // https://eips.ethereum.org/EIPS/eip-1167\n    function initialize(\n        DeploymentConfig memory deploymentConfig,\n        RuntimeConfig memory runtimeConfig\n    ) public initializer {\n        _validateDeploymentConfig(deploymentConfig);\n\n        // template intializer gets ADMIN_ROLE to call contract write functions\n        _grantRole(ADMIN_ROLE, msg.sender);\n        // grants `DEFAULT_ADMIN_ROLE` and `ADMIN_ROLE` to `deploymentConfig.owner`\n        _transferOwnership(deploymentConfig.owner);\n\n        _deploymentConfig = deploymentConfig;\n        _runtimeConfig = runtimeConfig;\n\n        reserveRemaining = deploymentConfig.reservedSupply;\n    }\n\n    /****************\n     * User actions *\n     ****************/\n\n    /// Public mint function, can be called by any address\n    /// if `DeploymentConfig.publicMintStart` is before the current block timestamp\n    function mint(uint256 amount)\n        external\n        payable\n        paymentProvided(amount * _runtimeConfig.publicMintPrice)\n    {\n        require(mintingActive(), \"Minting has not started yet\");\n\n        _mintTokens(msg.sender, amount);\n    }\n\n    /// Mint tokens if the wallet has been whitelisted, can be called\n    /// if `DeploymentConfig.presaleMintStart` is before the current block timestamp\n    function presaleMint(uint256 amount, bytes32[] calldata proof)\n        external\n        payable\n        paymentProvided(amount * _runtimeConfig.presaleMintPrice)\n    {\n        require(presaleActive(), \"Presale has not started yet\");\n        require(\n            isWhitelisted(msg.sender, proof),\n            \"Not whitelisted for presale\"\n        );\n\n        // Each presale whitelisted address can only mint once, up to `DeploymentConfig.tokensPerMint` tokens\n        _presaleMinted[msg.sender] = true;\n        _mintTokens(msg.sender, amount);\n    }\n\n    /******************\n     * View functions *\n     ******************/\n\n    /// Check if public minting is active\n    function mintingActive() public view returns (bool) {\n        // We need to rely on block.timestamp since it's\n        // easier to configure across different chains\n        // solhint-disable-next-line not-rely-on-time\n        return block.timestamp > _runtimeConfig.publicMintStart;\n    }\n\n    /// Check if presale minting is active\n    function presaleActive() public view returns (bool) {\n        // We need to rely on block.timestamp since it's\n        // easier to configure across different chains\n        // solhint-disable-next-line not-rely-on-time\n        return block.timestamp > _runtimeConfig.presaleMintStart;\n    }\n\n    /// Get the number of tokens still available for minting\n    function availableSupply() public view returns (uint256) {\n        return _deploymentConfig.maxSupply - totalSupply() - reserveRemaining;\n    }\n\n    /// Check if the wallet is whitelisted for the presale\n    function isWhitelisted(address wallet, bytes32[] calldata proof)\n        public\n        view\n        returns (bool)\n    {\n        // Each wallet can only call `presaleMint` once\n        require(!_presaleMinted[wallet], \"Already minted\");\n\n        // Used for checking if wallet is part of the merkle tree\n        bytes32 leaf = keccak256(abi.encodePacked(wallet));\n\n        // Checks if `leaf` is part of the merkle tree\n        return\n            MerkleProof.verify(proof, _runtimeConfig.presaleMerkleRoot, leaf);\n    }\n\n    /// Contract owner address\n    /// @dev Required for easy integration with OpenSea, the owner address can edit the collection there\n    function owner() public view returns (address) {\n        return _deploymentConfig.owner;\n    }\n\n    /*******************\n     * Access controls *\n     *******************/\n\n    /// Transfer contract ownership\n    function transferOwnership(address newOwner)\n        external\n        onlyRole(DEFAULT_ADMIN_ROLE)\n    {\n        require(newOwner != _deploymentConfig.owner, \"Already the owner\");\n        _transferOwnership(newOwner);\n    }\n\n    /// Transfer contract admin rights, changes `ADMIN_ROLE` from sender address to input `to` address\n    /// input `to` address cannot already have `ADMIN_ROLE` access rights\n    function transferAdminRights(address to) external onlyRole(ADMIN_ROLE) {\n        require(!hasRole(ADMIN_ROLE, to), \"Already an admin\");\n        require(msg.sender != _deploymentConfig.owner, \"Use transferOwnership\");\n\n        _revokeRole(ADMIN_ROLE, msg.sender);\n        _grantRole(ADMIN_ROLE, to);\n    }\n\n    /*****************\n     * Admin actions *\n     *****************/\n\n    /// Mint a token from the reserve\n    function reserveMint(address to, uint256 amount)\n        external\n        onlyRole(ADMIN_ROLE)\n    {\n        require(amount <= reserveRemaining, \"Not enough reserved\");\n        // if `reserveRemaining` ends up as 0, then further reserve mints are disabled, since `_mintTokens`\n        // expects `amount` to be greater than 0\n        reserveRemaining -= amount;\n        _mintTokens(to, amount);\n    }\n\n    /// Get full contract information\n    /// @dev Convenience helper\n    function getInfo() external view returns (ContractInfo memory info) {\n        info.version = VERSION;\n        info.deploymentConfig = _deploymentConfig;\n        info.runtimeConfig = _runtimeConfig;\n    }\n\n    /// Update contract configuration\n    /// @dev Callable by admin roles only\n    function updateConfig(RuntimeConfig calldata newConfig)\n        external\n        onlyRole(ADMIN_ROLE)\n    {\n        _validateRuntimeConfig(newConfig);\n        _runtimeConfig = newConfig;\n    }\n\n    /// Withdraw minting fees to the treasury address\n    /// @dev Callable by admin roles only\n    function withdrawFees() external onlyRole(ADMIN_ROLE) {\n        _deploymentConfig.treasuryAddress.sendValue(address(this).balance);\n    }\n\n    /*************\n     * Internals *\n     *************/\n\n    /// Contract runtime configuration, updatable after deployment\n    RuntimeConfig internal _runtimeConfig;\n    /// Contract deployment configuration, immutable after deployment, except for `owner` field\n    DeploymentConfig internal _deploymentConfig;\n\n    /// Mapping for tracking presale mint status, each whitelisted address can only presale mint once\n    /// up to `DeploymentConfig.tokensPerMint` tokens\n    mapping(address => bool) internal _presaleMinted;\n\n    /// @dev Internal function for performing token mints\n    function _mintTokens(address to, uint256 amount) internal {\n        require(amount <= _deploymentConfig.tokensPerMint, \"Amount too large\");\n        require(amount <= availableSupply(), \"Not enough tokens left\");\n\n        _safeMint(to, amount);\n    }\n\n    /// Validate deployment config\n    function _validateDeploymentConfig(DeploymentConfig memory config)\n        internal\n        pure\n    {\n        require(config.maxSupply > 0, \"Maximum supply must be non-zero\");\n        require(config.tokensPerMint > 0, \"Tokens per mint must be non-zero\");\n        require(\n            config.treasuryAddress != address(0),\n            \"Treasury address cannot be null\"\n        );\n        require(config.owner != address(0), \"Contract must have an owner\");\n        require(\n            config.reservedSupply <= config.maxSupply,\n            \"Reserve greater than supply\"\n        );\n    }\n\n    /// Validate a runtime configuration change\n    function _validateRuntimeConfig(RuntimeConfig calldata config)\n        internal\n        view\n    {\n        // Can't set royalties to more than 100%\n        require(config.royaltiesBps <= ROYALTIES_BASIS, \"Royalties too high\");\n\n        // Validate mint price changes\n        _validatePublicMintPrice(config);\n        _validatePresaleMintPrice(config);\n\n        // Validate metadata changes\n        _validateMetadata(config);\n    }\n\n    /// Checks if `_runTimeConfig.publicMintPrice` and `_runTimeConfig.publicMintPriceFrozen` updates are valid\n    function _validatePublicMintPrice(RuntimeConfig calldata config)\n        internal\n        view\n    {\n        // As long as public mint price is not frozen, all changes are valid\n        if (!_runtimeConfig.publicMintPriceFrozen) return;\n\n        // Can't change public mint price once frozen\n        require(\n            _runtimeConfig.publicMintPrice == config.publicMintPrice,\n            \"publicMintPrice is frozen\"\n        );\n\n        // Can't unfreeze public mint price\n        require(\n            config.publicMintPriceFrozen,\n            \"publicMintPriceFrozen is frozen\"\n        );\n    }\n\n    /// Checks if `_runTimeConfig.presaleMintPrice` and `_runTimeConfig.presaleMintPriceFrozen` updates are valid\n    function _validatePresaleMintPrice(RuntimeConfig calldata config)\n        internal\n        view\n    {\n        // As long as presale mint price is not frozen, all changes are valid\n        if (!_runtimeConfig.presaleMintPriceFrozen) return;\n\n        // Can't change presale mint price once frozen\n        require(\n            _runtimeConfig.presaleMintPrice == config.presaleMintPrice,\n            \"presaleMintPrice is frozen\"\n        );\n\n        // Can't unfreeze presale mint price\n        require(\n            config.presaleMintPriceFrozen,\n            \"presaleMintPriceFrozen is frozen\"\n        );\n    }\n\n    /// Checks if `_runtimeConfig.metadataUpdatable` and `_runtimeConfig.baseURI` updates are valid\n    function _validateMetadata(RuntimeConfig calldata config) internal view {\n        // If metadata is updatable, we don't have any other limitations\n        if (_runtimeConfig.metadataUpdatable) return;\n\n        // If it isn't, we can't allow the flag to change anymore\n        require(!config.metadataUpdatable, \"Cannot unfreeze metadata\");\n\n        // We also can't allow base URI to change\n        require(\n            keccak256(abi.encodePacked(_runtimeConfig.baseURI)) ==\n                keccak256(abi.encodePacked(config.baseURI)),\n            \"Metadata is frozen\"\n        );\n    }\n\n    /// Internal function without any checks for performing the ownership transfer\n    /// Removes current `_deploymentConfig.owner` from `ADMIN_ROLE` and `DEFAULT_ADMIN_ROLE` roles and grants these\n    /// roles to input `newOwner` address. Changes `_deploymentConfig.owner` to input `newOwner` address\n    /// emits an `OwnershipTransferred` event on success\n    function _transferOwnership(address newOwner) internal {\n        address previousOwner = _deploymentConfig.owner;\n        _revokeRole(ADMIN_ROLE, previousOwner);\n        _revokeRole(DEFAULT_ADMIN_ROLE, previousOwner);\n\n        _deploymentConfig.owner = newOwner;\n        _grantRole(ADMIN_ROLE, newOwner);\n        _grantRole(DEFAULT_ADMIN_ROLE, newOwner);\n\n        emit OwnershipTransferred(previousOwner, newOwner);\n    }\n\n    /// @dev See {IERC165-supportsInterface}.\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721A, AccessControl, ERC2981)\n        returns (bool)\n    {\n        return\n            ERC721A.supportsInterface(interfaceId) ||\n            AccessControl.supportsInterface(interfaceId) ||\n            ERC2981.supportsInterface(interfaceId);\n    }\n\n    /// Get the token metadata URI\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        override\n        returns (string memory)\n    {\n        require(_exists(tokenId), \"Token does not exist\");\n\n        // If `_runtimeConfig.baseURI` is empty then `_runtimeConfig.prerevealTokenURI` is returned\n        // otherwise `_runtimeConfig.baseURI` + `tokenId` returned\n        return\n            bytes(_runtimeConfig.baseURI).length > 0\n                ? string(\n                    abi.encodePacked(_runtimeConfig.baseURI, tokenId.toString())\n                )\n                : _runtimeConfig.prerevealTokenURI;\n    }\n\n    /// @dev Need name() to support setting it in the initializer instead of constructor\n    function name() public view override returns (string memory) {\n        return _deploymentConfig.name;\n    }\n\n    /// @dev Need symbol() to support setting it in the initializer instead of constructor\n    function symbol() public view override returns (string memory) {\n        return _deploymentConfig.symbol;\n    }\n\n    /// @dev ERC2981 token royalty info\n    function royaltyInfo(uint256, uint256 salePrice)\n        external\n        view\n        returns (address receiver, uint256 royaltyAmount)\n    {\n        receiver = _runtimeConfig.royaltiesAddress;\n        royaltyAmount =\n            (_runtimeConfig.royaltiesBps * salePrice) /\n            ROYALTIES_BASIS;\n    }\n\n    /**\n     * @dev OpenSea contract metadata, returns a base64 encoded JSON string containing royalties basis points\n     * and royalties address\n     */\n    function contractURI() external view returns (string memory) {\n        string memory json = Base64.encode(\n            bytes(\n                string(\n                    abi.encodePacked(\n                        '{\"seller_fee_basis_points\": ', // solhint-disable-line quotes\n                        _runtimeConfig.royaltiesBps.toString(),\n                        ', \"fee_recipient\": \"', // solhint-disable-line quotes\n                        uint256(uint160(_runtimeConfig.royaltiesAddress))\n                            .toHexString(20),\n                        '\"}' // solhint-disable-line quotes\n                    )\n                )\n            )\n        );\n\n        string memory output = string(\n            abi.encodePacked(\"data:application/json;base64,\", json)\n        );\n\n        return output;\n    }\n\n    /// Check if enough payment was provided\n    modifier paymentProvided(uint256 payment) {\n        require(msg.value >= payment, \"Payment too small\");\n        _;\n    }\n}"
    },
    {
      "filename": "contracts/ERC721A.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Creator: Chiru Labs\n\npragma solidity ^0.8.4;\n\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\nimport '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';\nimport '@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol';\nimport '@openzeppelin/contracts/utils/Address.sol';\nimport '@openzeppelin/contracts/utils/Context.sol';\nimport '@openzeppelin/contracts/utils/Strings.sol';\nimport '@openzeppelin/contracts/utils/introspection/ERC165.sol';\n\nerror ApprovalCallerNotOwnerNorApproved();\nerror ApprovalQueryForNonexistentToken();\nerror ApproveToCaller();\nerror ApprovalToCurrentOwner();\nerror BalanceQueryForZeroAddress();\nerror MintToZeroAddress();\nerror MintZeroQuantity();\nerror OwnerQueryForNonexistentToken();\nerror TransferCallerNotOwnerNorApproved();\nerror TransferFromIncorrectOwner();\nerror TransferToNonERC721ReceiverImplementer();\nerror TransferToZeroAddress();\nerror URIQueryForNonexistentToken();\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension. Built to optimize for lower gas during batch mints.\n *\n * Assumes serials are sequentially minted starting at _startTokenId() (defaults to 0, e.g. 0, 1, 2, 3..).\n *\n * Assumes that an owner cannot have more than 2**64 - 1 (max value of uint64) of supply.\n *\n * Assumes that the maximum token id cannot exceed 2**256 - 1 (max value of uint256).\n */\ncontract ERC721A is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Compiler will pack this into a single 256bit word.\n    struct TokenOwnership {\n        // The address of the owner.\n        address addr;\n        // Keeps track of the start time of ownership with minimal overhead for tokenomics.\n        uint64 startTimestamp;\n        // Whether the token has been burned.\n        bool burned;\n    }\n\n    // Compiler will pack this into a single 256bit word.\n    struct AddressData {\n        // Realistically, 2**64-1 is more than enough.\n        uint64 balance;\n        // Keeps track of mint count with minimal overhead for tokenomics.\n        uint64 numberMinted;\n        // Keeps track of burn count with minimal overhead for tokenomics.\n        uint64 numberBurned;\n        // For miscellaneous variable(s) pertaining to the address\n        // (e.g. number of whitelist mint slots used).\n        // If there are multiple variables, please pack them into a uint64.\n        uint64 aux;\n    }\n\n    // The tokenId of the next token to be minted.\n    uint256 internal _currentIndex;\n\n    // The number of tokens burned.\n    uint256 internal _burnCounter;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to ownership details\n    // An empty struct value does not necessarily mean the token is unowned. See _ownershipOf implementation for details.\n    mapping(uint256 => TokenOwnership) internal _ownerships;\n\n    // Mapping owner address to address data\n    mapping(address => AddressData) private _addressData;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n        _currentIndex = _startTokenId();\n    }\n\n    /**\n     * To change the starting tokenId, please override this function.\n     */\n    function _startTokenId() internal view virtual returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @dev Burned tokens are calculated here, use _totalMinted() if you want to count just minted tokens.\n     */\n    function totalSupply() public view returns (uint256) {\n        // Counter underflow is impossible as _burnCounter cannot be incremented\n        // more than _currentIndex - _startTokenId() times\n        unchecked {\n            return _currentIndex - _burnCounter - _startTokenId();\n        }\n    }\n\n    /**\n     * Returns the total amount of tokens minted in the contract.\n     */\n    function _totalMinted() internal view returns (uint256) {\n        // Counter underflow is impossible as _currentIndex does not decrement,\n        // and it is initialized to _startTokenId()\n        unchecked {\n            return _currentIndex - _startTokenId();\n        }\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view override returns (uint256) {\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\n        return uint256(_addressData[owner].balance);\n    }\n\n    /**\n     * Returns the number of tokens minted by `owner`.\n     */\n    function _numberMinted(address owner) internal view returns (uint256) {\n        return uint256(_addressData[owner].numberMinted);\n    }\n\n    /**\n     * Returns the number of tokens burned by or on behalf of `owner`.\n     */\n    function _numberBurned(address owner) internal view returns (uint256) {\n        return uint256(_addressData[owner].numberBurned);\n    }\n\n    /**\n     * Returns the auxillary data for `owner`. (e.g. number of whitelist mint slots used).\n     */\n    function _getAux(address owner) internal view returns (uint64) {\n        return _addressData[owner].aux;\n    }\n\n    /**\n     * Sets the auxillary data for `owner`. (e.g. number of whitelist mint slots used).\n     * If there are multiple variables, please pack them into a uint64.\n     */\n    function _setAux(address owner, uint64 aux) internal {\n        _addressData[owner].aux = aux;\n    }\n\n    /**\n     * Gas spent here starts off proportional to the maximum mint batch size.\n     * It gradually moves to O(1) as tokens get transferred around in the collection over time.\n     */\n    function _ownershipOf(uint256 tokenId) internal view returns (TokenOwnership memory) {\n        uint256 curr = tokenId;\n\n        unchecked {\n            if (_startTokenId() <= curr && curr < _currentIndex) {\n                TokenOwnership memory ownership = _ownerships[curr];\n                if (!ownership.burned) {\n                    if (ownership.addr != address(0)) {\n                        return ownership;\n                    }\n                    // Invariant:\n                    // There will always be an ownership that has an address and is not burned\n                    // before an ownership that does not have an address and is not burned.\n                    // Hence, curr will not underflow.\n                    while (true) {\n                        curr--;\n                        ownership = _ownerships[curr];\n                        if (ownership.addr != address(0)) {\n                            return ownership;\n                        }\n                    }\n                }\n            }\n        }\n        revert OwnerQueryForNonexistentToken();\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view override returns (address) {\n        return _ownershipOf(tokenId).addr;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : '';\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return '';\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public override {\n        address owner = ERC721A.ownerOf(tokenId);\n        if (to == owner) revert ApprovalToCurrentOwner();\n\n        if (_msgSender() != owner && !isApprovedForAll(owner, _msgSender())) {\n            revert ApprovalCallerNotOwnerNorApproved();\n        }\n\n        _approve(to, tokenId, owner);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view override returns (address) {\n        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        if (operator == _msgSender()) revert ApproveToCaller();\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, '');\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        _transfer(from, to, tokenId);\n        if (to.isContract() && !_checkContractOnERC721Received(from, to, tokenId, _data)) {\n            revert TransferToNonERC721ReceiverImplementer();\n        }\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     */\n    function _exists(uint256 tokenId) internal view returns (bool) {\n        return _startTokenId() <= tokenId && tokenId < _currentIndex && !_ownerships[tokenId].burned;\n    }\n\n    function _safeMint(address to, uint256 quantity) internal {\n        _safeMint(to, quantity, '');\n    }\n\n    /**\n     * @dev Safely mints `quantity` tokens and transfers them to `to`.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called for each safe transfer.\n     * - `quantity` must be greater than 0.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(\n        address to,\n        uint256 quantity,\n        bytes memory _data\n    ) internal {\n        _mint(to, quantity, _data, true);\n    }\n\n    /**\n     * @dev Mints `quantity` tokens and transfers them to `to`.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `quantity` must be greater than 0.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(\n        address to,\n        uint256 quantity,\n        bytes memory _data,\n        bool safe\n    ) internal {\n        uint256 startTokenId = _currentIndex;\n        if (to == address(0)) revert MintToZeroAddress();\n        if (quantity == 0) revert MintZeroQuantity();\n\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\n\n        // Overflows are incredibly unrealistic.\n        // balance or numberMinted overflow if current value of either + quantity > 1.8e19 (2**64) - 1\n        // updatedIndex overflows if _currentIndex + quantity > 1.2e77 (2**256) - 1\n        unchecked {\n            _addressData[to].balance += uint64(quantity);\n            _addressData[to].numberMinted += uint64(quantity);\n\n            _ownerships[startTokenId].addr = to;\n            _ownerships[startTokenId].startTimestamp = uint64(block.timestamp);\n\n            uint256 updatedIndex = startTokenId;\n            uint256 end = updatedIndex + quantity;\n\n            if (safe && to.isContract()) {\n                do {\n                    emit Transfer(address(0), to, updatedIndex);\n                    if (!_checkContractOnERC721Received(address(0), to, updatedIndex++, _data)) {\n                        revert TransferToNonERC721ReceiverImplementer();\n                    }\n                } while (updatedIndex != end);\n                // Reentrancy protection\n                if (_currentIndex != startTokenId) revert();\n            } else {\n                do {\n                    emit Transfer(address("
    }
  ]
}