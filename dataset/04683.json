{
  "Title": "Use of send",
  "Content": "Use of `send` is always risky and should be analyzed in detail. Two occurrences found in [line 185 of Token.sol](https://github.com/imapp-pl/golem-crowdfunding/blob/50100b27a7c6841ed430a028d100f5d45ba08fb1/contracts/Token.sol#L185) and [line 214 of Token.sol](https://github.com/imapp-pl/golem-crowdfunding/blob/50100b27a7c6841ed430a028d100f5d45ba08fb1/contracts/Token.sol#L214).  \n\n– [Always check send return value](https://medium.com/zeppelin-blog/onward-with-ethereum-smart-contract-security-97a827e47702#c528): OK.  \n\n– [Consider calling send at the end of the function](https://medium.com/zeppelin-blog/onward-with-ethereum-smart-contract-security-97a827e47702#3d17): Risk is low because in one case, the contract `send`s to golemFactory, which is a trusted contract, and almost at the end of the function. Consider refactoring the code to have `send` at the end, though.  \n\n– [Favor pull payments over push payments](https://medium.com/zeppelin-blog/onward-with-ethereum-smart-contract-security-97a827e47702#fa61): No problems with push payment used, because `golemFactory` will be controlled by the Golem team. Bear in mind that if `send` at line 185 fails for any reason, the whole `finalize` call will fail.\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/Token.sol",
      "content": "pragma solidity ^0.4.4;\n\nimport \"./GNTAllocation.sol\";\n\ncontract MigrationAgent {\n    function migrateFrom(address _from, uint256 _value);\n}\n\ncontract GolemNetworkToken {\n    string public constant name = \"Golem Network Token\";\n    string public constant symbol = \"GNT\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n\n    uint256 public constant tokenCreationRate = 1000;\n\n    // The funding cap in weis.\n    uint256 public constant tokenCreationCap = 820000 ether * tokenCreationRate;\n    uint256 public constant tokenCreationMin = 150000 ether * tokenCreationRate;\n\n    uint256 fundingStartBlock;\n    uint256 fundingEndBlock;\n\n    // The flag indicates if the GNT contract is in \"funding\" mode.\n    bool fundingMode = true;\n\n    // Receives ETH and its own GNT endowment.\n    address public golemFactory;\n\n    // Has control over token migration to next version of token.\n    address public migrationMaster;\n\n    GNTAllocation public lockedAllocation;\n\n    // The current total token supply.\n    uint256 totalTokens;\n\n    mapping (address => uint256) balances;\n\n    address public migrationAgent;\n    uint256 public totalMigrated;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    function GolemNetworkToken(address _golemFactory,\n                               address _migrationMaster,\n                               uint256 _fundingStartBlock,\n                               uint256 _fundingEndBlock) {\n        lockedAllocation = new GNTAllocation(_golemFactory);\n        migrationMaster = _migrationMaster;\n        golemFactory = _golemFactory;\n        fundingStartBlock = _fundingStartBlock;\n        fundingEndBlock = _fundingEndBlock;\n    }\n\n    // Transfer GNT tokens from sender's account to provided account address.\n    // This function is disabled during the funding.\n    // Required state: Operational\n    function transfer(address _to, uint256 _value) returns (bool) {\n        // Abort if not in Operational state.\n        if (fundingMode) throw;\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function totalSupply() external constant returns (uint256) {\n        return totalTokens;\n    }\n\n    function balanceOf(address _owner) external constant returns (uint256) {\n        return balances[_owner];\n    }\n\n    // Token migration support:\n\n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (fundingMode) throw;\n        if (migrationAgent == 0) throw;\n\n        // Validate input value.\n        if (_value == 0) throw;\n        if (_value > balances[msg.sender]) throw;\n\n        balances[msg.sender] -= _value;\n        totalTokens -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    // Set address of migration target contract and enable migration process.\n    // Required state: Operational Normal\n    // State transition: -> Operational Migration\n    function setMigrationAgent(address _agent) external {\n        // Abort if not in Operational Normal state.\n        if (fundingMode) throw;\n        if (migrationAgent != 0) throw;\n        if (msg.sender != migrationMaster) throw;\n        migrationAgent = _agent;\n    }\n\n    function setMigrationMaster(address _master) external {\n        if (msg.sender != migrationMaster) throw;\n        migrationMaster = _master;\n    }\n\n    // Crowdfunding:\n\n    function fundingActive() constant external returns (bool) {\n        // Copy of inFundingActive.\n        if (!fundingMode) return false;\n\n        // b ≥ Start and b ≤ End and t < Max\n        if (block.number < fundingStartBlock ||\n            block.number > fundingEndBlock ||\n            totalTokens >= tokenCreationCap) return false;\n        return true;\n    }\n\n    // Helper function to get number of tokens left during the funding.\n    function numberOfTokensLeft() constant external returns (uint256) {\n        if (!fundingMode) return 0;\n        if (block.number > fundingEndBlock) return 0;\n        return tokenCreationCap - totalTokens;\n    }\n\n    function finalized() constant external returns (bool) {\n        return !fundingMode;\n    }\n\n    // Create tokens when funding is active.\n    // Required state: Funding Active\n    // State transition: -> Funding Success (only if cap reached)\n    function() payable external {\n        // Abort if not in Funding Active state.\n        // The checks are split (instead of using or operator) because it is\n        // cheaper this way.\n        if (!fundingMode) throw;\n        if (block.number < fundingStartBlock) throw;\n        if (block.number > fundingEndBlock) throw;\n        if (totalTokens >= tokenCreationCap) throw;\n\n        // Do not allow creating 0 tokens.\n        if (msg.value == 0) throw;\n\n        // Do not create more than cap\n        var numTokens = msg.value * tokenCreationRate;\n        totalTokens += numTokens;\n        if (totalTokens > tokenCreationCap) throw;\n\n        // Assign new tokens to the sender\n        balances[msg.sender] += numTokens;\n\n        // Log token creation event\n        Transfer(0, msg.sender, numTokens);\n    }\n\n    // If cap was reached or crowdfunding has ended then:\n    // transfer ETH to the Golem Factory address,\n    // create GNT for the golemFactory (representing the company,\n    // create GNT for the developers.\n    // Required state: Funding Success\n    // State transition: -> Operational Normal\n    function finalize() external {\n        // Abort if not in Funding Success state.\n        if (!fundingMode) throw;\n        if ((block.number <= fundingEndBlock ||\n             totalTokens < tokenCreationMin) &&\n            totalTokens < tokenCreationCap) throw;\n\n        // Switch to Operational state. This is the only place this can happen.\n        fundingMode = false;\n\n        // Transfer ETH to the Golem Factory address.\n        if (!golemFactory.send(this.balance)) throw;\n\n        // Create additional GNT for the Factory (representing the company)\n        // and developers as a 18% of total number of tokens.\n        // All additional tokens are transfered to the account controller by\n        // GNTAllocation contract which will not allow using them for 6 months.\n        uint256 percentOfTotal = 18;\n        uint256 additionalTokens =\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\n        totalTokens += additionalTokens;\n        balances[lockedAllocation] += additionalTokens;\n        Transfer(0, lockedAllocation, additionalTokens);\n    }\n\n    // Get back the ether sent during the funding in case the funding has not\n    // reached the minimum level.\n    // Required state: Funding Failure\n    function refund() external {\n        // Abort if not in Funding Failure state.\n        if (!fundingMode) throw;\n        if (block.number <= fundingEndBlock) throw;\n        if (totalTokens >= tokenCreationMin) throw;\n\n        var gntValue = balances[msg.sender];\n        if (gntValue == 0) throw;\n        balances[msg.sender] = 0;\n        totalTokens -= gntValue;\n\n        var ethValue = gntValue / tokenCreationRate;\n        if (!msg.sender.send(ethValue)) throw;\n        Refund(msg.sender, ethValue);\n    }\n}"
    }
  ]
}