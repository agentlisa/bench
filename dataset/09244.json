{
  "Title": "[H-01] SpeedBumpPriceGate: Excess ether did not return to the user",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/SpeedBumpPriceGate.sol#L65-L82\n\n\n# Vulnerability details\n\n## Impact\nThe passThruGate function of the SpeedBumpPriceGate contract is used to charge NFT purchase fees.\nSince the price of NFT will change due to the previous purchase, users are likely to send more ether than the actual purchase price in order to ensure that they can purchase NFT. However, the passThruGate function did not return the excess ether, which would cause asset loss to the user.\nConsider the following scenario: \n1. An NFT is sold for 0.15 eth\n2. User A believes that the value of the NFT is acceptable within 0.3 eth, considering that someone may buy the NFT before him, so user A transfers 0.3 eth to buy the NFT\n3. When user A's transaction is executed, the price of the NFT is 0.15 eth, but since the contract does not return excess eth, user A actually spends 0.3 eth.\n## Proof of Concept\nhttps://github.com/code-423n4/2022-05-factorydao/blob/e22a562c01c533b8765229387894cc0cb9bed116/contracts/SpeedBumpPriceGate.sol#L65-L82\n## Tools Used\nNone\n## Recommended Mitigation Steps\n```\n-   function passThruGate(uint index, address) override external payable {\n+  function passThruGate(uint index, address payer) override external payable {\n        uint price = getCost(index);\n        require(msg.value >= price, 'Please send more ETH');\n\n        // bump up the price\n        Gate storage gate = gates[index];\n        // multiply by the price increase factor\n        gate.lastPrice = (price * gate.priceIncreaseFactor) / gate.priceIncreaseDenominator;\n        // move up the reference\n        gate.lastPurchaseBlock = block.number;\n\n        // pass thru the ether\n        if (msg.value > 0) {\n            // use .call so we can send to contracts, for example gnosis safe, re-entrance is not a threat here\n-           (bool sent, bytes memory data) = gate.beneficiary.call{value: msg.value}(\"\");\n+          (bool sent, bytes memory data) = gate.beneficiary.call{value: price}(\"\");\n            require(sent, 'ETH transfer failed');\n        }\n+      if (msg.value - price > 0){ \n+         (bool sent, bytes memory data) = payer.call{value: msg.value - price}(\"\");\n+          require(sent, 'ETH transfer failed');}\n    }\n```\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-05-factorydao-contest",
  "Code": [
    {
      "filename": "contracts/SpeedBumpPriceGate.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity 0.8.9;\n\nimport \"../interfaces/IPriceGate.sol\";\n\n/// @title A factory pattern for a price gate whose price increases exponentially on purchase and decays linearly thereafter\n/// @author metapriest, adrian.wachel, marek.babiarz, radoslaw.gorecki\n/// @notice This contract has no management key, anyone can add a gate\n/// @dev Note passing thru the gate forwards all gas, so beneficiary can be a contract, possibly malicious\ncontract SpeedBumpPriceGate is IPriceGate {\n\n    // this represents a single gate\n    struct Gate {\n        uint priceIncreaseFactor;\n        uint priceIncreaseDenominator;\n        uint lastPrice;\n        uint decayFactor;\n        uint priceFloor;\n        uint lastPurchaseBlock;\n        address beneficiary;\n    }\n\n    // array-like mapping of gate structs\n    mapping (uint => Gate) public gates;\n    // count the gates as they come in!\n    uint public numGates;\n\n    /// @notice Add a price gate to the list of available price gates\n    /// @dev Anyone can call this, but it must be connected to MerkleIdentity via priceGateIndex to be used\n    /// @dev The price increase factor is split into numerator and denominator to enable fractions (wow! I love fractions!)\n    /// @param priceFloor the starting price and the lowest price that can be reached via decay\n    /// @param priceDecay the per-block rate at which the price reduces until it hits the price floor\n    /// @param priceIncrease the numerator of the factor by which the price multiplies when a purchase occurs\n    /// @param priceIncreaseDenominator the denominator of the price increase factor\n    /// @param beneficiary who receives the proceeds from a purchase\n    function addGate(uint priceFloor, uint priceDecay, uint priceIncrease, uint priceIncreaseDenominator, address beneficiary) external {\n        // prefix operator increments then evaluates\n        Gate storage gate = gates[++numGates];\n        gate.priceFloor = priceFloor;\n        gate.decayFactor = priceDecay;\n        gate.priceIncreaseFactor = priceIncrease;\n        gate.priceIncreaseDenominator = priceIncreaseDenominator;\n        gate.beneficiary = beneficiary;\n    }\n\n    /// @notice Get the cost of passing thru this gate\n    /// @param index which gate are we talking about?\n    /// @return _ethCost the amount of ether required to pass thru this gate\n    function getCost(uint index) override public view returns (uint _ethCost) {\n        Gate memory gate = gates[index];\n        // compute the linear decay\n        uint decay = gate.decayFactor * (block.number - gate.lastPurchaseBlock);\n        // gate.lastPrice - decay < gate.priceFloor (left side could underflow)\n        if (gate.lastPrice < decay + gate.priceFloor) {\n            return gate.priceFloor;\n        } else {\n            return gate.lastPrice - decay;\n        }\n    }\n\n    /// @notice Pass thru this gate, should be called by MerkleIndex\n    /// @dev This can be called by anyone, devs can call it to test it on mainnet\n    /// @param index which gate are we passing thru?\n    function passThruGate(uint index, address) override external payable {\n        uint price = getCost(index);\n        require(msg.value >= price, 'Please send more ETH');\n\n        // bump up the price\n        Gate storage gate = gates[index];\n        // multiply by the price increase factor\n        gate.lastPrice = (price * gate.priceIncreaseFactor) / gate.priceIncreaseDenominator;\n        // move up the reference\n        gate.lastPurchaseBlock = block.number;\n\n        // pass thru the ether\n        if (msg.value > 0) {\n            // use .call so we can send to contracts, for example gnosis safe, re-entrance is not a threat here\n            (bool sent, bytes memory data) = gate.beneficiary.call{value: msg.value}(\"\");\n            require(sent, 'ETH transfer failed');\n        }\n    }\n}"
    }
  ]
}