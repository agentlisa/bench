{
  "Title": "[M-07] User may get less tokens than expected when collateral list order changes",
  "Content": "\n<https://github.com/AngleProtocol/angle-transmuter/blob/8a2c3aaf4bd054581b06d33049370a6f01b56d44/contracts/transmuter/libraries/LibSetters.sol#L123> <br><https://github.com/AngleProtocol/angle-transmuter/blob/8a2c3aaf4bd054581b06d33049370a6f01b56d44/contracts/transmuter/facets/Redeemer.sol#L64>\n\nThe order of `ts.collateralList` is not stable: Whenever `LibSetters.revokeCollateral` is used to revoke a collateral, it may change because of the swap that is performed. However, the function `Redeemer.redeem` relies on this order, as the user has to provide the `minAmountsOut` in the order of `ts.collateralList`. This can lead to situations where the user has crafted the `minAmountsOut` array when the order was still different, leading to unintended results (and potentially redemptions that the user did not want to accept). It also means that revoking a collateral can be challenging for the team / governance because it should never be done when a user has already prepared a redemption (either via the frontend which he had open or some other way to interact with the contract). But there is of course no way to know this.\n\n### Proof of Concept\n\nLet's say the system contains the collateral \\[tokenA, tokenB, tokenC]. `normalizedStables` for tokenA is 0. The user therefore does not want to receive tokenA (and will not receive anything for it). However, it is extremely important to him that he receives 100,000 of tokenC. He therefore crafts a `minAmountsOut` of \\[0, 10000, 100000]. Just before he submits the call, tokenA is removed from the system, resulting in the collateral array \\[tokenC, tokenB]. Even if the user only receives 50,000 tokens of tokenC, the call will therefore succeed.\n\n### Recommended Mitigation Steps\n\nThe problem could be alleviated a bit by checking the length of `minAmountsOut` (making sure it is not longer than `ts.collateralList`). However, that would not help if a collateral is revoked and a new one is added. Another solution would be to provide pairs of token addresses and amounts, which would solve the problem completely.\n\n**[Picodes (Angle) confirmed and commented](https://github.com/code-423n4/2023-06-angle-findings/issues/8#issuecomment-1628688537):**\n > The mitigation doesn't cost much and we will implement it. It's really an edge case though.\n\n**[Angle mitigated](https://github.com/code-423n4/2023-07-angle-mitigation/blob/main/README.md#mitigations-to-be-reviewed):**\n> PR: https://github.com/AngleProtocol/angle-transmuter/commit/f8d0bf7c4009586f7022d5929359041db3990175<br>\n> Applies the suggested fix.\n\n**Status:** Not fully mitigated. Full details in reports from [Lambda](https://github.com/code-423n4/2023-07-angle-mitigation-findings/issues/5) and [auditor0517](https://github.com/code-423n4/2023-07-angle-mitigation-findings/issues/30).\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-01-dev-test-repo",
  "Code": [
    {
      "filename": "contracts/transmuter/libraries/LibSetters.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.19;\n\nimport { SafeCast } from \"oz/utils/math/SafeCast.sol\";\nimport { IERC20Metadata } from \"oz/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport { LibManager } from \"../libraries/LibManager.sol\";\nimport { LibOracle } from \"./LibOracle.sol\";\nimport { LibStorage as s } from \"./LibStorage.sol\";\nimport { LibDiamond } from \"./LibDiamond.sol\";\nimport { LibWhitelist } from \"./LibWhitelist.sol\";\n\nimport \"../../utils/Constants.sol\";\nimport \"../../utils/Errors.sol\";\nimport \"../Storage.sol\";\n\n/// @title LibSetters\n/// @author Angle Labs, Inc.\nlibrary LibSetters {\n    using SafeCast for uint256;\n\n    event CollateralAdded(address indexed collateral);\n    event CollateralManagerSet(address indexed collateral, ManagerStorage managerData);\n    event CollateralRevoked(address indexed collateral);\n    event CollateralWhitelistStatusUpdated(address indexed collateral, bytes whitelistData, uint8 whitelistStatus);\n    event FeesSet(address indexed collateral, uint64[] xFee, int64[] yFee, bool mint);\n    event OracleSet(address indexed collateral, bytes oracleConfig);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event PauseToggled(address indexed collateral, uint256 pausedType, bool isPaused);\n    event RedemptionCurveParamsSet(uint64[] xFee, int64[] yFee);\n    event ReservesAdjusted(address indexed collateral, uint256 amount, bool increase);\n    event TrustedToggled(address indexed sender, bool isTrusted, TrustedType trustedType);\n    event WhitelistStatusToggled(WhitelistType whitelistType, address indexed who, uint256 whitelistStatus);\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                 ONLY GOVERNOR ACTIONS                                              \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Internal version of `setAccessControlManager`\n    function setAccessControlManager(IAccessControlManager _newAccessControlManager) internal {\n        DiamondStorage storage ds = s.diamondStorage();\n        IAccessControlManager previousAccessControlManager = ds.accessControlManager;\n        ds.accessControlManager = _newAccessControlManager;\n        emit OwnershipTransferred(address(previousAccessControlManager), address(_newAccessControlManager));\n    }\n\n    /// @notice Internal version of `setCollateralManager`\n    function setCollateralManager(address collateral, ManagerStorage memory managerData) internal {\n        Collateral storage collatInfo = s.transmuterStorage().collaterals[collateral];\n        if (collatInfo.decimals == 0) revert NotCollateral();\n        uint8 isManaged = collatInfo.isManaged;\n        if (isManaged > 0) {\n            (, uint256 totalValue) = LibManager.totalAssets(collatInfo.managerData.config);\n            if (totalValue > 0) revert ManagerHasAssets();\n        }\n        if (managerData.config.length != 0) {\n            // The first subCollateral given should be the actual collateral asset\n            if (address(managerData.subCollaterals[0]) != collateral) revert InvalidParams();\n            // Sanity check on the manager data that is passed\n            LibManager.parseManagerConfig(managerData.config);\n            collatInfo.isManaged = 1;\n        } else collatInfo.isManaged = 0;\n        collatInfo.managerData = managerData;\n        emit CollateralManagerSet(collateral, managerData);\n    }\n\n    /// @notice Internal version of `toggleTrusted`\n    function toggleTrusted(address sender, TrustedType t) internal {\n        TransmuterStorage storage ts = s.transmuterStorage();\n        uint256 trustedStatus;\n        if (t == TrustedType.Updater) {\n            trustedStatus = 1 - ts.isTrusted[sender];\n            ts.isTrusted[sender] = trustedStatus;\n        } else {\n            trustedStatus = 1 - ts.isSellerTrusted[sender];\n            ts.isSellerTrusted[sender] = trustedStatus;\n        }\n        emit TrustedToggled(sender, trustedStatus == 1, t);\n    }\n\n    /// @notice Internal version of `addCollateral`\n    function addCollateral(address collateral) internal {\n        TransmuterStorage storage ts = s.transmuterStorage();\n        Collateral storage collatInfo = ts.collaterals[collateral];\n        if (collatInfo.decimals != 0) revert AlreadyAdded();\n        collatInfo.decimals = uint8(IERC20Metadata(collateral).decimals());\n        ts.collateralList.push(collateral);\n        emit CollateralAdded(collateral);\n    }\n\n    /// @notice Internal version of `adjustStablecoins`\n    function adjustStablecoins(address collateral, uint128 amount, bool increase) internal {\n        TransmuterStorage storage ts = s.transmuterStorage();\n        Collateral storage collatInfo = ts.collaterals[collateral];\n        if (collatInfo.decimals == 0) revert NotCollateral();\n        uint128 normalizedAmount = ((amount * BASE_27) / ts.normalizer).toUint128();\n        if (increase) {\n            collatInfo.normalizedStables += uint216(normalizedAmount);\n            ts.normalizedStables += normalizedAmount;\n        } else {\n            collatInfo.normalizedStables -= uint216(normalizedAmount);\n            ts.normalizedStables -= normalizedAmount;\n        }\n        emit ReservesAdjusted(collateral, amount, increase);\n    }\n\n    /// @notice Internal version of `revokeCollateral`\n    function revokeCollateral(address collateral) internal {\n        TransmuterStorage storage ts = s.transmuterStorage();\n        Collateral storage collatInfo = ts.collaterals[collateral];\n        if (collatInfo.decimals == 0 || collatInfo.normalizedStables > 0) revert NotCollateral();\n        uint8 isManaged = collatInfo.isManaged;\n        if (isManaged > 0) {\n            (, uint256 totalValue) = LibManager.totalAssets(collatInfo.managerData.config);\n            if (totalValue > 0) revert ManagerHasAssets();\n        }\n        delete ts.collaterals[collateral];\n        address[] memory collateralListMem = ts.collateralList;\n        uint256 length = collateralListMem.length;\n        for (uint256 i; i < length - 1; ++i) {\n            if (collateralListMem[i] == collateral) {\n                ts.collateralList[i] = collateralListMem[length - 1];\n                break;\n            }\n        }\n        ts.collateralList.pop();\n        emit CollateralRevoked(collateral);\n    }\n\n    /// @notice Internal version of `setOracle`\n    function setOracle(address collateral, bytes memory oracleConfig) internal {\n        Collateral storage collatInfo = s.transmuterStorage().collaterals[collateral];\n        if (collatInfo.decimals == 0) revert NotCollateral();\n        // Checks oracle validity\n        LibOracle.readMint(oracleConfig);\n        collatInfo.oracleConfig = oracleConfig;\n        emit OracleSet(collateral, oracleConfig);\n    }\n\n    /// @notice Internal version of `setWhitelistStatus`\n    function setWhitelistStatus(address collateral, uint8 whitelistStatus, bytes memory whitelistData) internal {\n        Collateral storage collatInfo = s.transmuterStorage().collaterals[collateral];\n        if (collatInfo.decimals == 0) revert NotCollateral();\n        if (whitelistStatus == 1) {\n            // Sanity check\n            LibWhitelist.parseWhitelistData(whitelistData);\n            collatInfo.whitelistData = whitelistData;\n        }\n        collatInfo.onlyWhitelisted = whitelistStatus;\n        emit CollateralWhitelistStatusUpdated(collateral, whitelistData, whitelistStatus);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                 ONLY GUARDIAN ACTIONS                                              \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Internal version of `togglePause`\n    function togglePause(address collateral, ActionType action) internal {\n        uint8 isLive;\n        if (action == ActionType.Mint || action == ActionType.Burn) {\n            Collateral storage collatInfo = s.transmuterStorage().collaterals[collateral];\n            if (collatInfo.decimals == 0) revert NotCollateral();\n            if (action == ActionType.Mint) {\n                isLive = 1 - collatInfo.isMintLive;\n                collatInfo.isMintLive = isLive;\n            } else {\n                isLive = 1 - collatInfo.isBurnLive;\n                collatInfo.isBurnLive = isLive;\n            }\n        } else {\n            TransmuterStorage storage ts = s.transmuterStorage();\n            isLive = 1 - ts.isRedemptionLive;\n            ts.isRedemptionLive = isLive;\n        }\n        emit PauseToggled(collateral, uint256(action), isLive == 0);\n    }\n\n    /// @notice Internal version of `setFees`\n    function setFees(address collateral, uint64[] memory xFee, int64[] memory yFee, bool mint) internal {\n        TransmuterStorage storage ts = s.transmuterStorage();\n        Collateral storage collatInfo = ts.collaterals[collateral];\n        if (collatInfo.decimals == 0) revert NotCollateral();\n        checkFees(xFee, yFee, mint ? ActionType.Mint : ActionType.Burn);\n        if (mint) {\n            collatInfo.xFeeMint = xFee;\n            collatInfo.yFeeMint = yFee;\n        } else {\n            collatInfo.xFeeBurn = xFee;\n            collatInfo.yFeeBurn = yFee;\n        }\n        emit FeesSet(collateral, xFee, yFee, mint);\n    }\n\n    /// @notice Internal version of `setRedemptionCurveParams`\n    function setRedemptionCurveParams(uint64[] memory xFee, int64[] memory yFee) internal {\n        TransmuterStorage storage ts = s.transmuterStorage();\n        LibSetters.checkFees(xFee, yFee, ActionType.Redeem);\n        ts.xRedemptionCurve = xFee;\n        ts.yRedemptionCurve = yFee;\n        emit RedemptionCurveParamsSet(xFee, yFee);\n    }\n\n    /// @notice Internal version of `toggleWhitelist`\n    function toggleWhitelist(WhitelistType whitelistType, address who) internal {\n        TransmuterStorage storage ts = s.transmuterStorage();\n        uint256 whitelistStatus = 1 - ts.isWhitelistedForType[whitelistType][who];\n        ts.isWhitelistedForType[whitelistType][who] = whitelistStatus;\n        emit WhitelistStatusToggled(whitelistType, who, whitelistStatus);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                        HELPERS                                                     \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Checks the fee values given for the `mint`, `burn`, and `redeem` functions\n    function checkFees(uint64[] memory xFee, int64[] memory yFee, ActionType action) internal view {\n        uint256 n = xFee.length;\n        if (n != yFee.length || n == 0) revert InvalidParams();\n        if (\n            // Mint inflexion points should be in [0,BASE_9[\n            // We have: amountPostFee * (BASE_9 + yFeeMint) = amountPreFee * BASE_9\n            // Hence we consider BASE_12 as the max value (100% fees) for yFeeMint\n            (action == ActionType.Mint && (xFee[n - 1] >= BASE_9 || xFee[0] != 0 || yFee[n - 1] > int256(BASE_12))) ||\n            // Burn inflexion points should be in [0,BASE_9] but fees should be constant in\n            // the first segment [BASE_9, x_{n-1}[\n            (action == ActionType.Burn &&\n                (xFee[0] != BASE_9 || yFee[n - 1] > int256(BASE_9) || (n > 1 && (yFee[0] != yFee[1])))) ||\n            // Redemption inflexion points should be in [0,BASE_9]\n            (action == ActionType.Redeem && (xFee[n - 1] > BASE_9 || yFee[n - 1] < 0 || yFee[n - 1] > int256(BASE_9)))\n        ) revert InvalidParams();\n\n        for (uint256 i = 0; i < n - 1; ++i) {\n            if (\n                // xFee strictly increasing and yFee increasing for mints\n                (action == ActionType.Mint && (xFee[i] >= xFee[i + 1] || (yFee[i + 1] < yFee[i]))) ||\n                // xFee strictly decreasing and yFee increasing for burns\n                (action == ActionType.Burn && (xFee[i] <= xFee[i + 1] || (yFee[i + 1] < yFee[i]))) ||\n                // xFee strictly increasing and yFee should be in [0,BASE_9] for redemptions\n                (action == ActionType.Redeem && (xFee[i] >= xFee[i + 1] || yFee[i] < 0 || yFee[i] > int256(BASE_9)))\n            ) revert InvalidParams();\n        }\n\n        // If a mint or burn fee is negative, we need to check that accounts atomically minting\n        // (from any collateral) and then burning cannot get more than their initial value\n        if (yFee[0] < 0) {\n            if (!LibDiamond.isGovernor(msg.sender)) revert NotGovernor(); // Only governor can set negative fees\n            TransmuterStorage storage ts = s.transmuterStorage();\n            address[] memory collateralListMem = ts.collateralList;\n            uint256 length = collateralListMem.length;\n            if (action == ActionType.Mint) {\n                // This can be mathematically expressed by `(1-min_c(burnFee_c))<=(1+mintFee[0])`\n                for (uint256 i; i < length; ++i) {\n                    int64[] memory burnFees = ts.collaterals[collateralListMem[i]].yFeeBurn;\n                    if (burnFees[0] + yFee[0] < 0) revert InvalidNegativeFees();\n                }\n            }\n            if (action == ActionType.Burn) {\n                // This can be mathematically expressed by `(1-burnFee[0])<=(1+min_c(mintFee_c))`\n                for (uint256 i; i < length; ++i) {\n                    int64[] memory mintFees = ts.collaterals[collateralListMem[i]].yFeeMint;\n                    if (yFee[0] + mintFees[0] < 0) revert InvalidNegativeFees();\n                }\n            }\n        }\n    }\n}"
    },
    {
      "filename": "README.md",
      "content": "# Angle Protocol - Mitigation Review details\n\n- Total Prize Pool: $14,000 USDC\n- [Warden guidelines for C4 mitigation reviews](https://code4rena.notion.site/Guidelines-for-C4-mitigation-reviews-ed10fc5cfbf640bd8dcec66f38b343c4)\n- Submit findings [using the C4 form](https://code4rena.com/contests/2023-07-angle-protocol-mitigation-review/submit)\n- Starts July 17, 2023 20:00 UTC\n- Ends July 21, 2023 20:00 UTC \n\n## Important note\n\nEach warden must submit a mitigation review for:\n\n- Every High and Medium finding listed as in-scope below, and\n- one report each for the Gas and QA fixes.\n\nFor the Gas and QA mitigation reports:\n- Submit any new High or Medium issues introduced by the QA and GAS fixes as a newly-introduced High and Medium risk issue.\n\n**Incomplete mitigation reviews will not be eligible for awards.**\n\n## Findings being mitigated\n\nMitigations of all High and Medium issues will be considered in-scope and listed here.\n\n- [H-01: Possible reentrancy during redemption/swap](https://github.com/code-423n4/2023-06-angle-findings/issues/24)\n- [H-02: The first disputer might lose funds although his dispute is valid.](https://github.com/code-423n4/2023-06-angle-findings/issues/23)\n- [H-03: Poor detection of disputed trees allows claiming tokens from a disputed tre](https://github.com/code-423n4/2023-06-angle-findings/issues/10)\n- [M-01: LibHelpers.piecewiseLinear will revert when the value is less than the first element of the array](https://github.com/code-423n4/2023-06-angle-findings/issues/40)\n- [M-02: Unsafe cast in getCollateralRatio()](https://github.com/code-423n4/2023-06-angle-findings/issues/31)\n- [M-03: Read-only reentrancy is possible](https://github.com/code-423n4/2023-06-angle-findings/issues/30)\n- [M-04: estimatedAPR() might return the wrong APR.](https://github.com/code-423n4/2023-06-angle-findings/issues/28)\n- [M-06: Interest is not accrued before parameters are updated in SavingsVest](https://github.com/code-423n4/2023-06-angle-findings/issues/13)\n- [M-07: User may get less tokens than expected when collateral list order changes](https://github.com/code-423n4/2023-06-angle-findings/issues/8)\n\n## Overview of changes\n\nChanges related to High and Medium issues on Merkl can be found [here](https://github.com/AngleProtocol/merkl-contracts/compare/code-423n4-2023-06-angle...code-423n4-2023-06-angle-mitigation).\nChanges that we intend to make on Merkl prior to final deployment, so including QA and GAS can be found [here](https://github.com/AngleProtocol/merkl-contracts/compare/code-423n4-2023-06-angle...code-423n4-2023-06-angle-full-mitigation). Updated tests and scripts are on the `main` branch.\n\nChanges related to High and Medium issues on Transmuter can be found [here](https://github.com/AngleProtocol/angle-transmuter/compare/code-423n4-2023-06-angle...code-423n4-2023-06-angle-mitigation).\nChanges that we intend to make on Transmuter prior to final deployment, so including QA and GAS can be found can be found [here](https://github.com/AngleProtocol/angle-transmuter/compare/code-423n4-2023-06-angle...code-423n4-2023-06-angle-full-mitigation). Updated tests and scripts are on the `main` branch.\n\n## Mitigations to be reviewed\n\n### Individual PRs\n\n| URL                                                                                               | Mitigation of | Purpose                                             |\n| ------------------------------------------------------------------------------------------------- | ------------- | --------------------------------------------------- |\n| https://github.com/AngleProtocol/angle-transmuter/commit/864c1c47cb550f8e337244f0f70409a171a4e671 | H-01          | Adds a reentrancy guard to several functions        |\n| https://github.com/AngleProtocol/merkl-contracts/commit/7402ee6b84789391479c5876b27be23fd579f7b2  | H-02          | Applies the suggested fix                           |\n| https://github.com/AngleProtocol/merkl-contracts/commit/82d8c0ff37b4a9ad8277cac4aef85f3ca0ad5c7c  | H-03          | Applies the suggested fix                           |\n| https://github.com/AngleProtocol/angle-transmuter/commit/5f7635cdab52b75416309d45f8cd253609c705ff | M-01          | Add an handler for this edge case                   |\n| https://github.com/AngleProtocol/angle-transmuter/commit/6f2ffcb1e89e3bba05c9aa2133ef94347aa42c28 | M-02          | Adds safeCast                                       |\n| https://github.com/AngleProtocol/angle-transmuter/commit/864c1c47cb550f8e337244f0f70409a171a4e671 | M-03          | Adds a reentrancy guard to several functions        |\n| https://github.com/AngleProtocol/angle-transmuter/commit/337c65d005bbd8ed6dfa76929d2cae475066756a | M-04          | Applies the suggested fix                           |\n| https://github.com/AngleProtocol/angle-transmuter/commit/94c4e51ae3400a63532e85f04f4081152adc97db | M-06          | Calls `accrues` before updating sensible parameters |\n| https://github.com/AngleProtocol/angle-transmuter/commit/f8d0bf7c4009586f7022d5929359041db3990175 | M-07          | Applies the suggested fix                           |\n| https://github.com/AngleProtocol/merkl-contracts/commit/3c2fe3a956cdd29b632e8d7a20e1fc2ce5e8ac37  | QA & GAS      |                                                     |\n| https://github.com/AngleProtocol/angle-transmuter/commit/66bba3f5dba4ab6307c997e350dfadb13d2a2119 | QA & GAS      |                                                     |\n\n## Out of Scope\n\n- [M-05: uint128 changeAmount might overflow](https://github.com/code-423n4/2023-06-angle-findings/issues/16): we consider that there is no risk here as swaps will be reverting, and that the chances that this happen are infinitesimals"
    }
  ]
}