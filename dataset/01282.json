{
  "Title": "M-2: commitRequested() front-run  malicious invalid oralce",
  "Content": "# Issue M-2: commitRequested() front-run  malicious invalid oralce \n\nSource: https://github.com/sherlock-audit/2023-09-perennial-judging/issues/27 \n\n## Found by \nbin2chen\nBoth `commitRequested()` and `commit()` can modify `lastCommittedPublishTime`, and both check that they cannot `pythPrice.publishTime<=lastCommittedPublishTime`.\nThis allows a malicious user to front-run `commitRequested()` to execute `commit()`, causing `commitRequested()` to revert, invalid oralce\n\n## Vulnerability Detail\n\nExecution of the `commitRequested()` method restricts the `lastCommittedPublishTime` from going backward.\n\n```solidity\n    function commitRequested(uint256 versionIndex, bytes calldata updateData)\n        public\n        payable\n        keep(KEEPER_REWARD_PREMIUM, KEEPER_BUFFER, updateData, \"\")\n    {\n...\n\n@>      if (pythPrice.publishTime <= lastCommittedPublishTime) revert PythOracleNonIncreasingPublishTimes();\n@>        lastCommittedPublishTime = pythPrice.publishTime;\n...\n```\n`commit()` has a similar limitation and can set `lastCommittedPublishTime`.\n\n```solidity\n    function commit(uint256 versionIndex, uint256 oracleVersion, bytes calldata updateData) external payable {\n        if (\n            versionList.length > versionIndex &&                // must be a requested version\n            versionIndex >= nextVersionIndexToCommit &&         // must be the next (or later) requested version\n@>          oracleVersion == versionList[versionIndex]          // must be the corresponding timestamp\n        ) {\n            commitRequested(versionIndex, updateData);\n            return;\n        }\n...\n@>      if (pythPrice.publishTime <= lastCommittedPublishTime) revert PythOracleNonIncreasingPublishTimes();\n@>      lastCommittedPublishTime = pythPrice.publishTime;\n....\n```\n\nThis leads to a situation where anyone can front-run `commitRequested()` and use his `updateData` to execute `commit()`.\nIn order to satisfy the `commit()` constraint, we need to pass a `commit()` parameter set as follows\n\n1. versionIndex= nextVersionIndexToCommit\n2. oracleVersion = versionList[versionIndex]  - 1    and oralceVersion > _latestVersion\n3. pythPrice.publishTime >= versionList[versionIndex]  - 1  + MIN_VALID_TIME_AFTER_VERSION\n\nThis way `lastCommittedPublishTime` will be modified, causing `commitRequested()` to execute with `revert PythOracleNonIncreasingPublishTimes`\n\nExample:\nGiven: \nnextVersionIndexToCommit = 10\nversionList[10]   = 200  \n_latestVersion    = 100  \n\nwhen:\n 1. keeper exexute commitRequested(versionIndex = 10 , VAA{ publishTime = 205})\n 2. front-run execute `commit(versionIndex = 10 , oracleVersion = 200-1 , VAA{ publishTime = 205})\n     * versionIndex= nextVersionIndexToCommit    （pass）\n     * oracleVersion = versionList[versionIndex]  - 1    and oralceVersion > _latestVersion  (pass) \n     * pythPrice.publishTime >= versionList[versionIndex]  - 1  + MIN_VALID_TIME_AFTER_VERSION  (pass)\n\n\nBy the time the `keeper` submits the next VVA, the price may have passed its expiration date\n\n## Impact\n\nIf the user can control the oralce invalidation, it can lead to many problems\ne.g. invalidating `oracle` to one's own detriment, not having to take losses\nMaliciously destroying other people's profits, etc.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-09-perennial/blob/main/perennial-v2/packages/perennial-oracle/contracts/pyth/PythOracle.sol#L174\n\nhttps://github.com/sherlock-audit/2023-09-perennial/blob/main/perennial-v2/packages/perennial-oracle/contracts/pyth/PythOracle.sol#L129\n\n## Tool used\n\nManual Review\n\n## Recommendation\ncheck `pythPrice` whether valid for `nextVersionIndexToCommit`\n```diff\n    function commit(uint256 versionIndex, uint256 oracleVersion, bytes calldata updateData) external payable {\n        // Must be before the next requested version to commit, if it exists\n        // Otherwise, try to commit it as the next request version to commit\n        if (\n            versionList.length > versionIndex &&                // must be a requested version\n            versionIndex >= nextVersionIndexToCommit &&         // must be the next (or later) requested version\n            oracleVersion == versionList[versionIndex]          // must be the corresponding timestamp\n        ) {\n            commitRequested(versionIndex, updateData);\n            return;\n        }\n\n        PythStructs.Price memory pythPrice = _validateAndGetPrice(oracleVersion, updateData);\n\n        // Price must be more recent than that of the most recently committed version\n        if (pythPrice.publishTime <= lastCommittedPublishTime) revert PythOracleNonIncreasingPublishTimes();\n        lastCommittedPublishTime = pythPrice.publishTime;\n\n        // Oracle version must be more recent than that of the most recently committed version\n        uint256 minVersion = _latestVersion;\n        uint256 maxVersion = versionList.length > versionIndex ? versionList[versionIndex] : current();\n\n        if (versionIndex < nextVersionIndexToCommit) revert PythOracleVersionIndexTooLowError();\n        if (versionIndex > nextVersionIndexToCommit && block.timestamp <= versionList[versionIndex - 1] + GRACE_PERIOD)\n            revert PythOracleGracePeriodHasNotExpiredError();\n        if (oracleVersion <= minVersion || oracleVersion >= maxVersion) revert PythOracleVersionOutsideRangeError();\n+       if (nextVersionIndexToCommit < versionList.length) {\n+           if (\n+               pythPrice.publishTime >= versionList[nextVersionIndexToCommit] + MIN_VALID_TIME_AFTER_VERSION &&\n+               pythPrice.publishTime <= versionList[nextVersionIndexToCommit] + MAX_VALID_TIME_AFTER_VERSION\n+           ) revert PythOracleUpdateValidForPreviousVersionError();\n+       }\n\n\n        _recordPrice(oracleVersion, pythPrice);\n        nextVersionIndexToCommit = versionIndex;\n        _latestVersion = oracleVersion;\n    }\n```\n\n\n\n## Discussion\n\n**sherlock-admin**\n\n4 comment(s) were left on this issue during the judging contest.\n\n**panprog** commented:\n> borderline low/medium. The issue is valid and can force keepers to re-submit if they're frontrun. It's still always possible to submit a price with publishTime which is at MAX_VALID_TIME_AFTER_VERSION away from version time, but this still interfere oracle keepers process and increases chances of invalid version. Definitely not high, because it doesn't break things, just forces to re-submit transactions and keepers can also front-run each other, so reverted keep transactions are not something possible only due to this issue. Probably a better fix is to commitRequested instead of just commit if publishTime is between MIN and MAX valid time.\n\n**n33k** commented:\n> invalid, expected behavior for commitRequested to revert because commit alreay provided the oracleVersion\n\n**0xyPhilic** commented:\n> invalid because there is no proof of funds loss\n\n**polarzero** commented:\n> Medium. Not sure what the incentive would be for an attacker to do this, and the impact it would have, but I'd rather have it downgraded than ignored.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/112",
  "Code": [
    {
      "filename": "perennial-v2/packages/perennial-oracle/contracts/pyth/PythOracle.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@pythnetwork/pyth-sdk-solidity/AbstractPyth.sol\";\nimport \"@equilibria/root/attribute/Instance.sol\";\nimport \"@equilibria/root/attribute/Kept/Kept.sol\";\nimport \"../interfaces/IPythFactory.sol\";\n\n/// @title PythOracle\n/// @notice Pyth implementation of the IOracle interface.\n/// @dev One instance per Pyth price feed should be deployed. Multiple products may use the same\n///      PythOracle instance if their payoff functions are based on the same underlying oracle.\n///      This implementation only supports non-negative prices.\ncontract PythOracle is IPythOracle, Instance, Kept {\n    /// @dev A Pyth update must come at least this long after a version to be valid\n    uint256 constant public MIN_VALID_TIME_AFTER_VERSION = 4 seconds;\n\n    /// @dev A Pyth update must come at most this long after a version to be valid\n    uint256 constant public MAX_VALID_TIME_AFTER_VERSION = 7 seconds;\n\n    /// @dev After this amount of time has passed for a version without being committed, the version can be invalidated.\n    uint256 constant public GRACE_PERIOD = 1 minutes;\n\n    /// @dev The multiplier for the keeper reward on top of cost\n    UFixed18 constant public KEEPER_REWARD_PREMIUM = UFixed18.wrap(1.5e18);\n\n    /// @dev The fixed gas buffer that is added to the keeper reward\n    uint256 constant public KEEPER_BUFFER = 80_000;\n\n    /// @dev Pyth contract\n    AbstractPyth public immutable pyth;\n\n    /// @dev Pyth price feed id\n    bytes32 public id;\n\n    /// @dev List of all requested oracle versions\n    uint256[] public versionList;\n\n    /// @dev Index in `versionList` of the next version a keeper should commit\n    uint256 public nextVersionIndexToCommit;\n\n    /// @dev Mapping from oracle version to oracle version data\n    mapping(uint256 => Fixed6) private _prices;\n\n    /// @dev Mapping from oracle version to when its VAA was published to Pyth\n    mapping(uint256 => uint256) public publishTimes;\n\n    /// @dev The time when the last committed update was published to Pyth\n    uint256 public lastCommittedPublishTime;\n\n    /// @dev The oracle version that was most recently committed\n    /// @dev We assume that we cannot commit an oracle version of 0, so `_latestVersion` being 0 means that no version has been committed yet\n    uint256 private _latestVersion;\n\n    /// @notice Initializes the immutable contract state\n    /// @param pyth_ Pyth contract\n    constructor(AbstractPyth pyth_) {\n        pyth = pyth_;\n    }\n\n    /// @notice Initializes the contract state\n    /// @param id_ price ID for Pyth price feed\n    /// @param chainlinkFeed_ Chainlink price feed for rewarding keeper in DSU\n    /// @param dsu_ Token to pay the keeper reward in\n    function initialize(bytes32 id_, AggregatorV3Interface chainlinkFeed_, Token18 dsu_) external initializer(1) {\n        __Instance__initialize();\n        __UKept__initialize(chainlinkFeed_, dsu_);\n\n        if (!pyth.priceFeedExists(id_)) revert PythOracleInvalidPriceIdError(id_);\n\n        id = id_;\n    }\n\n    function versionListLength() external view returns (uint256) {\n        return versionList.length;\n    }\n\n    /// @notice Records a request for a new oracle version\n    /// @dev Original sender to optionally use for callbacks\n    function request(address) external onlyAuthorized {\n        uint256 currentTimestamp = current();\n        if (versionList.length == 0 || versionList[versionList.length - 1] != currentTimestamp) {\n            versionList.push(currentTimestamp);\n            emit OracleProviderVersionRequested(currentTimestamp);\n        }\n    }\n\n    /// @notice Returns the latest synced oracle version and the current oracle version\n    /// @return The latest synced oracle version\n    /// @return The current oracle version collecting new orders\n    function status() external view returns (OracleVersion memory, uint256) {\n        return (latest(), current());\n    }\n\n    /// @notice Returns the latest synced oracle version\n    /// @return latestVersion Latest oracle version\n    function latest() public view returns (OracleVersion memory latestVersion) {\n        if (_latestVersion == 0) return latestVersion;\n\n        return latestVersion = OracleVersion(_latestVersion, _prices[_latestVersion], true);\n    }\n\n    /// @notice Returns the current oracle version accepting new orders\n    /// @return Current oracle version\n    function current() public view returns (uint256) {\n        return IPythFactory(address(factory())).current();\n    }\n\n    /// @notice Returns the oracle version at version `version`\n    /// @param timestamp The timestamp of which to lookup\n    /// @return oracleVersion Oracle version at version `version`\n    function at(uint256 timestamp) public view returns (OracleVersion memory oracleVersion) {\n        Fixed6 price = _prices[timestamp];\n        return OracleVersion(timestamp, price, !price.isZero());\n    }\n\n    /// @notice Returns the next oracle version to commit\n    /// @return version The next oracle version to commit\n    function nextVersionToCommit() external view returns (uint256 version) {\n        if (versionList.length == 0 || nextVersionIndexToCommit >= versionList.length) return 0;\n        return versionList[nextVersionIndexToCommit];\n    }\n\n    /// @notice Commits the price represented by `updateData` to the next version that needs to be committed\n    /// @dev Will revert if there is an earlier versionIndex that could be committed with `updateData`\n    /// @param versionIndex The index of the version to commit\n    /// @param updateData The update data to commit\n    function commitRequested(uint256 versionIndex, bytes calldata updateData)\n        public\n        payable\n        keep(KEEPER_REWARD_PREMIUM, KEEPER_BUFFER, updateData, \"\")\n    {\n        // This check isn't necessary since the caller would not be able to produce a valid updateData\n        // with an update time corresponding to a null version, but reverting with a specific error is\n        // clearer.\n        if (nextVersionIndexToCommit >= versionList.length) revert PythOracleNoNewVersionToCommitError();\n        if (versionIndex < nextVersionIndexToCommit) revert PythOracleVersionIndexTooLowError();\n\n        uint256 versionToCommit = versionList[versionIndex];\n        PythStructs.Price memory pythPrice = _validateAndGetPrice(versionToCommit, updateData);\n\n        // Price must be more recent than that of the most recently committed version\n        if (pythPrice.publishTime <= lastCommittedPublishTime) revert PythOracleNonIncreasingPublishTimes();\n        lastCommittedPublishTime = pythPrice.publishTime;\n\n        // Ensure that the keeper is committing the earliest possible version\n        if (versionIndex > nextVersionIndexToCommit) {\n            uint256 previousVersion = versionList[versionIndex - 1];\n            // We can only skip the previous version if the grace period has expired\n            if (block.timestamp <= previousVersion + GRACE_PERIOD) revert PythOracleGracePeriodHasNotExpiredError();\n\n            // If the update is valid for the previous version, we can't skip the previous version\n            if (\n                pythPrice.publishTime >= previousVersion + MIN_VALID_TIME_AFTER_VERSION &&\n                pythPrice.publishTime <= previousVersion + MAX_VALID_TIME_AFTER_VERSION\n            ) revert PythOracleUpdateValidForPreviousVersionError();\n        }\n\n        _recordPrice(versionToCommit, pythPrice);\n        nextVersionIndexToCommit = versionIndex + 1;\n        _latestVersion = versionToCommit;\n\n        emit OracleProviderVersionFulfilled(versionToCommit);\n    }\n\n    /// @notice Commits the price to a non-requested version\n    /// @dev This commit function may pay out a keeper reward if the committed version is valid\n    ///      for the next requested version to commit. A proper `versionIndex` must be supplied in case we are\n    ///      ahead of an invalidated requested version and need to verify that the provided version is valid.\n    /// @param versionIndex The next committable index, taking into account any passed invalid requested versions\n    /// @param oracleVersion The oracle version to commit\n    /// @param updateData The update data to commit\n    function commit(uint256 versionIndex, uint256 oracleVersion, bytes calldata updateData) external payable {\n        // Must be before the next requested version to commit, if it exists\n        // Otherwise, try to commit it as the next request version to commit\n        if (\n            versionList.length > versionIndex &&                // must be a requested version\n            versionIndex >= nextVersionIndexToCommit &&         // must be the next (or later) requested version\n            oracleVersion == versionList[versionIndex]          // must be the corresponding timestamp\n        ) {\n            commitRequested(versionIndex, updateData);\n            return;\n        }\n\n        PythStructs.Price memory pythPrice = _validateAndGetPrice(oracleVersion, updateData);\n\n        // Price must be more recent than that of the most recently committed version\n        if (pythPrice.publishTime <= lastCommittedPublishTime) revert PythOracleNonIncreasingPublishTimes();\n        lastCommittedPublishTime = pythPrice.publishTime;\n\n        // Oracle version must be more recent than that of the most recently committed version\n        uint256 minVersion = _latestVersion;\n        uint256 maxVersion = versionList.length > versionIndex ? versionList[versionIndex] : current();\n\n        if (versionIndex < nextVersionIndexToCommit) revert PythOracleVersionIndexTooLowError();\n        if (versionIndex > nextVersionIndexToCommit && block.timestamp <= versionList[versionIndex - 1] + GRACE_PERIOD)\n            revert PythOracleGracePeriodHasNotExpiredError();\n        if (oracleVersion <= minVersion || oracleVersion >= maxVersion) revert PythOracleVersionOutsideRangeError();\n\n        _recordPrice(oracleVersion, pythPrice);\n        nextVersionIndexToCommit = versionIndex;\n        _latestVersion = oracleVersion;\n    }\n\n    /// @notice Validates that update fees have been paid, and that the VAA represented by `updateData` is within `oracleVersion + MIN_VALID_TIME_AFTER_VERSION` and `oracleVersion + MAX_VALID_TIME_AFTER_VERSION`\n    /// @param oracleVersion The oracle version to validate against\n    /// @param updateData The update data to validate\n    function _validateAndGetPrice(uint256 oracleVersion, bytes calldata updateData) private returns (PythStructs.Price memory price) {\n        bytes[] memory updateDataList = new bytes[](1);\n        updateDataList[0] = updateData;\n        bytes32[] memory idList = new bytes32[](1);\n        idList[0] = id;\n\n        // Limit the value passed in the single update fee * number of updates to prevent packing the update data\n        // with extra updates to increase the keeper fee. When Pyth updates their fee calculations\n        // we will need to modify this to account for the new fee logic.\n        return pyth.parsePriceFeedUpdates{value: IPythStaticFee(address(pyth)).singleUpdateFeeInWei() * idList.length}(\n            updateDataList,\n            idList,\n            SafeCast.toUint64(oracleVersion + MIN_VALID_TIME_AFTER_VERSION),\n            SafeCast.toUint64(oracleVersion + MAX_VALID_TIME_AFTER_VERSION)\n        )[0].price;\n    }\n\n    /// @notice Records `price` as a Fixed6 at version `oracleVersion`\n    /// @param oracleVersion The oracle version to record the price at\n    /// @param price The price to record\n    function _recordPrice(uint256 oracleVersion, PythStructs.Price memory price) private {\n        int256 expo6Decimal = 6 + price.expo;\n        _prices[oracleVersion] = (expo6Decimal < 0) ?\n            Fixed6.wrap(price.price).div(Fixed6Lib.from(UFixed6Lib.from(10 ** uint256(-expo6Decimal)))) :\n            Fixed6.wrap(price.price).mul(Fixed6Lib.from(UFixed6Lib.from(10 ** uint256(expo6Decimal))));\n        publishTimes[oracleVersion] = price.publishTime;\n    }\n\n    /// @notice Pulls funds from the factory to reward the keeper\n    /// @param keeperFee The keeper fee to pull\n    function _raiseKeeperFee(UFixed18 keeperFee, bytes memory) internal virtual override {\n        IPythFactory(address(factory())).claim(UFixed6Lib.from(keeperFee, true));\n    }\n\n    /// @dev Only allow authorized callers\n    modifier onlyAuthorized {\n        if (!IOracleProviderFactory(address(factory())).authorized(msg.sender)) revert OracleProviderUnauthorizedError();\n        _;\n    }\n}"
    },
    {
      "filename": "perennial-v2/packages/perennial-oracle/contracts/pyth/PythOracle.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@pythnetwork/pyth-sdk-solidity/AbstractPyth.sol\";\nimport \"@equilibria/root/attribute/Instance.sol\";\nimport \"@equilibria/root/attribute/Kept/Kept.sol\";\nimport \"../interfaces/IPythFactory.sol\";\n\n/// @title PythOracle\n/// @notice Pyth implementation of the IOracle interface.\n/// @dev One instance per Pyth price feed should be deployed. Multiple products may use the same\n///      PythOracle instance if their payoff functions are based on the same underlying oracle.\n///      This implementation only supports non-negative prices.\ncontract PythOracle is IPythOracle, Instance, Kept {\n    /// @dev A Pyth update must come at least this long after a version to be valid\n    uint256 constant public MIN_VALID_TIME_AFTER_VERSION = 4 seconds;\n\n    /// @dev A Pyth update must come at most this long after a version to be valid\n    uint256 constant public MAX_VALID_TIME_AFTER_VERSION = 7 seconds;\n\n    /// @dev After this amount of time has passed for a version without being committed, the version can be invalidated.\n    uint256 constant public GRACE_PERIOD = 1 minutes;\n\n    /// @dev The multiplier for the keeper reward on top of cost\n    UFixed18 constant public KEEPER_REWARD_PREMIUM = UFixed18.wrap(1.5e18);\n\n    /// @dev The fixed gas buffer that is added to the keeper reward\n    uint256 constant public KEEPER_BUFFER = 80_000;\n\n    /// @dev Pyth contract\n    AbstractPyth public immutable pyth;\n\n    /// @dev Pyth price feed id\n    bytes32 public id;\n\n    /// @dev List of all requested oracle versions\n    uint256[] public versionList;\n\n    /// @dev Index in `versionList` of the next version a keeper should commit\n    uint256 public nextVersionIndexToCommit;\n\n    /// @dev Mapping from oracle version to oracle version data\n    mapping(uint256 => Fixed6) private _prices;\n\n    /// @dev Mapping from oracle version to when its VAA was published to Pyth\n    mapping(uint256 => uint256) public publishTimes;\n\n    /// @dev The time when the last committed update was published to Pyth\n    uint256 public lastCommittedPublishTime;\n\n    /// @dev The oracle version that was most recently committed\n    /// @dev We assume that we cannot commit an oracle version of 0, so `_latestVersion` being 0 means that no version has been committed yet\n    uint256 private _latestVersion;\n\n    /// @notice Initializes the immutable contract state\n    /// @param pyth_ Pyth contract\n    constructor(AbstractPyth pyth_) {\n        pyth = pyth_;\n    }\n\n    /// @notice Initializes the contract state\n    /// @param id_ price ID for Pyth price feed\n    /// @param chainlinkFeed_ Chainlink price feed for rewarding keeper in DSU\n    /// @param dsu_ Token to pay the keeper reward in\n    function initialize(bytes32 id_, AggregatorV3Interface chainlinkFeed_, Token18 dsu_) external initializer(1) {\n        __Instance__initialize();\n        __UKept__initialize(chainlinkFeed_, dsu_);\n\n        if (!pyth.priceFeedExists(id_)) revert PythOracleInvalidPriceIdError(id_);\n\n        id = id_;\n    }\n\n    function versionListLength() external view returns (uint256) {\n        return versionList.length;\n    }\n\n    /// @notice Records a request for a new oracle version\n    /// @dev Original sender to optionally use for callbacks\n    function request(address) external onlyAuthorized {\n        uint256 currentTimestamp = current();\n        if (versionList.length == 0 || versionList[versionList.length - 1] != currentTimestamp) {\n            versionList.push(currentTimestamp);\n            emit OracleProviderVersionRequested(currentTimestamp);\n        }\n    }\n\n    /// @notice Returns the latest synced oracle version and the current oracle version\n    /// @return The latest synced oracle version\n    /// @return The current oracle version collecting new orders\n    function status() external view returns (OracleVersion memory, uint256) {\n        return (latest(), current());\n    }\n\n    /// @notice Returns the latest synced oracle version\n    /// @return latestVersion Latest oracle version\n    function latest() public view returns (OracleVersion memory latestVersion) {\n        if (_latestVersion == 0) return latestVersion;\n\n        return latestVersion = OracleVersion(_latestVersion, _prices[_latestVersion], true);\n    }\n\n    /// @notice Returns the current oracle version accepting new orders\n    /// @return Current oracle version\n    function current() public view returns (uint256) {\n        return IPythFactory(address(factory())).current();\n    }\n\n    /// @notice Returns the oracle version at version `version`\n    /// @param timestamp The timestamp of which to lookup\n    /// @return oracleVersion Oracle version at version `version`\n    function at(uint256 timestamp) public view returns (OracleVersion memory oracleVersion) {\n        Fixed6 price = _prices[timestamp];\n        return OracleVersion(timestamp, price, !price.isZero());\n    }\n\n    /// @notice Returns the next oracle version to commit\n    /// @return version The next oracle version to commit\n    function nextVersionToCommit() external view returns (uint256 version) {\n        if (versionList.length == 0 || nextVersionIndexToCommit >= versionList.length) return 0;\n        return versionList[nextVersionIndexToCommit];\n    }\n\n    /// @notice Commits the price represented by `updateData` to the next version that needs to be committed\n    /// @dev Will revert if there is an earlier versionIndex that could be committed with `updateData`\n    /// @param versionIndex The index of the version to commit\n    /// @param updateData The update data to commit\n    function commitRequested(uint256 versionIndex, bytes calldata updateData)\n        public\n        payable\n        keep(KEEPER_REWARD_PREMIUM, KEEPER_BUFFER, updateData, \"\")\n    {\n        // This check isn't necessary since the caller would not be able to produce a valid updateData\n        // with an update time corresponding to a null version, but reverting with a specific error is\n        // clearer.\n        if (nextVersionIndexToCommit >= versionList.length) revert PythOracleNoNewVersionToCommitError();\n        if (versionIndex < nextVersionIndexToCommit) revert PythOracleVersionIndexTooLowError();\n\n        uint256 versionToCommit = versionList[versionIndex];\n        PythStructs.Price memory pythPrice = _validateAndGetPrice(versionToCommit, updateData);\n\n        // Price must be more recent than that of the most recently committed version\n        if (pythPrice.publishTime <= lastCommittedPublishTime) revert PythOracleNonIncreasingPublishTimes();\n        lastCommittedPublishTime = pythPrice.publishTime;\n\n        // Ensure that the keeper is committing the earliest possible version\n        if (versionIndex > nextVersionIndexToCommit) {\n            uint256 previousVersion = versionList[versionIndex - 1];\n            // We can only skip the previous version if the grace period has expired\n            if (block.timestamp <= previousVersion + GRACE_PERIOD) revert PythOracleGracePeriodHasNotExpiredError();\n\n            // If the update is valid for the previous version, we can't skip the previous version\n            if (\n                pythPrice.publishTime >= previousVersion + MIN_VALID_TIME_AFTER_VERSION &&\n                pythPrice.publishTime <= previousVersion + MAX_VALID_TIME_AFTER_VERSION\n            ) revert PythOracleUpdateValidForPreviousVersionError();\n        }\n\n        _recordPrice(versionToCommit, pythPrice);\n        nextVersionIndexToCommit = versionIndex + 1;\n        _latestVersion = versionToCommit;\n\n        emit OracleProviderVersionFulfilled(versionToCommit);\n    }\n\n    /// @notice Commits the price to a non-requested version\n    /// @dev This commit function may pay out a keeper reward if the committed version is valid\n    ///      for the next requested version to commit. A proper `versionIndex` must be supplied in case we are\n    ///      ahead of an invalidated requested version and need to verify that the provided version is valid.\n    /// @param versionIndex The next committable index, taking into account any passed invalid requested versions\n    /// @param oracleVersion The oracle version to commit\n    /// @param updateData The update data to commit\n    function commit(uint256 versionIndex, uint256 oracleVersion, bytes calldata updateData) external payable {\n        // Must be before the next requested version to commit, if it exists\n        // Otherwise, try to commit it as the next request version to commit\n        if (\n            versionList.length > versionIndex &&                // must be a requested version\n            versionIndex >= nextVersionIndexToCommit &&         // must be the next (or later) requested version\n            oracleVersion == versionList[versionIndex]          // must be the corresponding timestamp\n        ) {\n            commitRequested(versionIndex, updateData);\n            return;\n        }\n\n        PythStructs.Price memory pythPrice = _validateAndGetPrice(oracleVersion, updateData);\n\n        // Price must be more recent than that of the most recently committed version\n        if (pythPrice.publishTime <= lastCommittedPublishTime) revert PythOracleNonIncreasingPublishTimes();\n        lastCommittedPublishTime = pythPrice.publishTime;\n\n        // Oracle version must be more recent than that of the most recently committed version\n        uint256 minVersion = _latestVersion;\n        uint256 maxVersion = versionList.length > versionIndex ? versionList[versionIndex] : current();\n\n        if (versionIndex < nextVersionIndexToCommit) revert PythOracleVersionIndexTooLowError();\n        if (versionIndex > nextVersionIndexToCommit && block.timestamp <= versionList[versionIndex - 1] + GRACE_PERIOD)\n            revert PythOracleGracePeriodHasNotExpiredError();\n        if (oracleVersion <= minVersion || oracleVersion >= maxVersion) revert PythOracleVersionOutsideRangeError();\n\n        _recordPrice(oracleVersion, pythPrice);\n        nextVersionIndexToCommit = versionIndex;\n        _latestVersion = oracleVersion;\n    }\n\n    /// @notice Validates that update fees have been paid, and that the VAA represented by `updateData` is within `oracleVersion + MIN_VALID_TIME_AFTER_VERSION` and `oracleVersion + MAX_VALID_TIME_AFTER_VERSION`\n    /// @param oracleVersion The oracle version to validate against\n    /// @param updateData The update data to validate\n    function _validateAndGetPrice(uint256 oracleVersion, bytes calldata updateData) private returns (PythStructs.Price memory price) {\n        bytes[] memory updateDataList = new bytes[](1);\n        updateDataList[0] = updateData;\n        bytes32[] memory idList = new bytes32[](1);\n        idList[0] = id;\n\n        // Limit the value passed in the single update fee * number of updates to prevent packing the update data\n        // with extra updates to increase the keeper fee. When Pyth updates their fee calculations\n        // we will need to modify this to account for the new fee logic.\n        return pyth.parsePriceFeedUpdates{value: IPythStaticFee(address(pyth)).singleUpdateFeeInWei() * idList.length}(\n            updateDataList,\n            idList,\n            SafeCast.toUint64(oracleVersion + MIN_VALID_TIME_AFTER_VERSION),\n            SafeCast.toUint64(oracleVersion + MAX_VALID_TIME_AFTER_VERSION)\n        )[0].price;\n    }\n\n    /// @notice Records `price` as a Fixed6 at version `oracleVersion`\n    /// @param oracleVersion The oracle version to record the price at\n    /// @param price The price to record\n    function _recordPrice(uint256 oracleVersion, PythStructs.Price memory price) private {\n        int256 expo6Decimal = 6 + price.expo;\n        _prices[oracleVersion] = (expo6Decimal < 0) ?\n            Fixed6.wrap(price.price).div(Fixed6Lib.from(UFixed6Lib.from(10 ** uint256(-expo6Decimal)))) :\n            Fixed6.wrap(price.price).mul(Fixed6Lib.from(UFixed6Lib.from(10 ** uint256(expo6Decimal))));\n        publishTimes[oracleVersion] = price.publishTime;\n    }\n\n    /// @notice Pulls funds from the factory to reward the keeper\n    /// @param keeperFee The keeper fee to pull\n    function _raiseKeeperFee(UFixed18 keeperFee, bytes memory) internal virtual override {\n        IPythFactory(address(factory())).claim(UFixed6Lib.from(keeperFee, true));\n    }\n\n    /// @dev Only allow authorized callers\n    modifier onlyAuthorized {\n        if (!IOracleProviderFactory(address(factory())).authorized(msg.sender)) revert OracleProviderUnauthorizedError();\n        _;\n    }\n}"
    }
  ]
}