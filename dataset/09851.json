{
  "Title": "[M-01] `permitAndMulticall()` May Be Used to Steal Funds Or as a Denial Of Service if `_from` Is Not The Message Sender",
  "Content": "_Submitted by kirk-baird, also found by cmichel and Omik_\n\n### Line References\n\n[PermitAndMulticall.sol#L46-L64](https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/PermitAndMulticall.sol#L46-L64)<br>\n[PermitAndMulticall.sol#L31-L37](https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/PermitAndMulticall.sol#L31-L37)<br>\n[TWABDelegator.sol#L438-L445](https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/TWABDelegator.sol#L438-L445)\n\n### Vulnerability details\n\nWhen the `_from` address is not the `msg.sender` `_multiCall()` will be made on behalf of the `msg.sender`. As a result each of the functions called by `multiCall()` will be made on behalf of `msg.sender` and not `_from`.\n\nIf functions such as `transfer()` or `unstake()` are called `msg.sender` will be the original caller which would transfer the attacker the funds if the `to` field is set to an attackers address.\n\nFurthermore, if an attacker we to call `permitAndMulticall()` before the `_from` user they may use their signature and nonce combination. As a nonce is only allowe to be used once the siganture will no longer be valid and `_permitToken.permit()` will fail on the second call.\n\nAn attacker may use this as a Denial of Service (DoS) attack by continually front-running `permitAndCall()` using other users signatures.\n\n### Proof of Concept\n```solidity\nfunction _multicall(bytes[] calldata _data) internal virtual returns (bytes[] memory results) {\n  results = new bytes[](_data.length);\n  for (uint256 i = 0; i < _data.length; i++) {\n    results[i] = Address.functionDelegateCall(address(this), _data[i]);\n  }\n  return results;\n}\n```\n```solidity\nfunction _permitAndMulticall(\n  IERC20Permit _permitToken,\n  address _from,\n  uint256 _amount,\n  Signature calldata _permitSignature,\n  bytes[] calldata _data\n) internal {\n  _permitToken.permit(\n    _from,\n    address(this),\n    _amount,\n    _permitSignature.deadline,\n    _permitSignature.v,\n    _permitSignature.r,\n    _permitSignature.s\n  );\n\n  _multicall(_data);\n}\n```\n\n### Recommended Mitigation Steps\n\nConsider updating the `_from` field to be the `msg.sender` in `permitAndMulticall()` (or alternatively do this in `_permitAndMulticall()` to save some gas).\n```solidity\nfunction permitAndMulticall(\n  uint256 _amount,\n  Signature calldata _permitSignature,\n  bytes[] calldata _data\n) external {\n  _permitAndMulticall(IERC20Permit(address(ticket)), msg.sender, _amount, _permitSignature, _data);\n}\n```\n\n**[PierrickGT (PoolTogether) confirmed and resolved](https://github.com/code-423n4/2022-02-pooltogether-findings/issues/20#issuecomment-1057474934):**\n > PR: https://github.com/pooltogether/v4-twab-delegator/pull/29\n\n**[PierrickGT (PoolTogether) disagreed with Medium severity and commented](https://github.com/code-423n4/2022-02-pooltogether-findings/issues/20#issuecomment-1058307757):**\n > Should be labelled as a 3 (High Risk) issue because an attacker could steal the funds.\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-02-pooltogether-findings/issues/20#issuecomment-1060617163):**\n > I'm not exactly sure how this might be abused to steal funds. By front-running a call `permitAndMulticall()` with the same `_from` account, an attacker is able to use up the user's nonce and DoS their transactions. However, an attacker CAN control the `_data` parsed to the `_multicall()` function and delegate call to the `TWABDelegator.sol` contract. Although, in this case `msg.sender` will be the attacker and not the delegatee.\n >\n > As such, any call to transfer a delegation to another account will fail as the delegation is computed based off `msg.sender` and `_slot`.\n >\n > Could you confirm if there is a viable attack vector that would result in lost funds? @PierrickGT \n\n**[PierrickGT (PoolTogether) commented](https://github.com/code-423n4/2022-02-pooltogether-findings/issues/20#issuecomment-1061952284):**\n> You are right, the only attack vector possible would be with the `updateDelegatee` function since an attacker could pass a `_delegatee` address and we compute the delegation with the passed `_delegator` param.\n> https://github.com/pooltogether/v4-twab-delegator/blob/60ae14e11947f8c896c1fef8f4d19ee714719383/contracts/TWABDelegator.sol#L265\n> \n> Funds wouldn't be at risk but delegated to the attacker address.\n> So I think the `2 (Med Risk)` label makes sense in this case since funds are not directly at risk but the attacker would enjoy better odds of winning.\n> I've removed the `disagree with severity` label.\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-02-pooltogether-findings/issues/20#issuecomment-1062612286):**\n > As per the above comment, I will leave this as `2 (Med Risk)`. The exploit does not lead to a loss of funds but can be abused to DoS this functionality and enjoy better odds of winning.\n\n\n\n***\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-02-pooltogether",
  "Code": [
    {
      "filename": "contracts/PermitAndMulticall.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @notice Allows a user to permit token spend and then call multiple functions on a contract.\n */\ncontract PermitAndMulticall {\n  /**\n   * @notice Secp256k1 signature values.\n   * @param deadline Timestamp at which the signature expires\n   * @param v `v` portion of the signature\n   * @param r `r` portion of the signature\n   * @param s `s` portion of the signature\n   */\n  struct Signature {\n    uint256 deadline;\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n  }\n\n  /**\n   * @notice Allows a user to call multiple functions on the same contract.  Useful for EOA who want to batch transactions.\n   * @param _data An array of encoded function calls.  The calls must be abi-encoded calls to this contract.\n   * @return results The results from each function call\n   */\n  function _multicall(bytes[] calldata _data) internal virtual returns (bytes[] memory results) {\n    results = new bytes[](_data.length);\n    for (uint256 i = 0; i < _data.length; i++) {\n      results[i] = Address.functionDelegateCall(address(this), _data[i]);\n    }\n    return results;\n  }\n\n  /**\n   * @notice Alow a user to approve ticket and run various calls in one transaction.\n   * @param _from Address of the sender\n   * @param _amount Amount of tickets to approve\n   * @param _permitSignature Permit signature\n   * @param _data Datas to call with `functionDelegateCall`\n   */\n  function _permitAndMulticall(\n    IERC20Permit _permitToken,\n    address _from,\n    uint256 _amount,\n    Signature calldata _permitSignature,\n    bytes[] calldata _data\n  ) internal {\n    _permitToken.permit(\n      _from,\n      address(this),\n      _amount,\n      _permitSignature.deadline,\n      _permitSignature.v,\n      _permitSignature.r,\n      _permitSignature.s\n    );\n\n    _multicall(_data);\n  }\n}"
    },
    {
      "filename": "contracts/PermitAndMulticall.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @notice Allows a user to permit token spend and then call multiple functions on a contract.\n */\ncontract PermitAndMulticall {\n  /**\n   * @notice Secp256k1 signature values.\n   * @param deadline Timestamp at which the signature expires\n   * @param v `v` portion of the signature\n   * @param r `r` portion of the signature\n   * @param s `s` portion of the signature\n   */\n  struct Signature {\n    uint256 deadline;\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n  }\n\n  /**\n   * @notice Allows a user to call multiple functions on the same contract.  Useful for EOA who want to batch transactions.\n   * @param _data An array of encoded function calls.  The calls must be abi-encoded calls to this contract.\n   * @return results The results from each function call\n   */\n  function _multicall(bytes[] calldata _data) internal virtual returns (bytes[] memory results) {\n    results = new bytes[](_data.length);\n    for (uint256 i = 0; i < _data.length; i++) {\n      results[i] = Address.functionDelegateCall(address(this), _data[i]);\n    }\n    return results;\n  }\n\n  /**\n   * @notice Alow a user to approve ticket and run various calls in one transaction.\n   * @param _from Address of the sender\n   * @param _amount Amount of tickets to approve\n   * @param _permitSignature Permit signature\n   * @param _data Datas to call with `functionDelegateCall`\n   */\n  function _permitAndMulticall(\n    IERC20Permit _permitToken,\n    address _from,\n    uint256 _amount,\n    Signature calldata _permitSignature,\n    bytes[] calldata _data\n  ) internal {\n    _permitToken.permit(\n      _from,\n      address(this),\n      _amount,\n      _permitSignature.deadline,\n      _permitSignature.v,\n      _permitSignature.r,\n      _permitSignature.s\n    );\n\n    _multicall(_data);\n  }\n}"
    },
    {
      "filename": "contracts/TWABDelegator.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@pooltogether/v4-core/contracts/interfaces/ITicket.sol\";\n\nimport \"./Delegation.sol\";\nimport \"./LowLevelDelegator.sol\";\nimport \"./PermitAndMulticall.sol\";\n\n/**\n * @title Delegate chances to win to multiple accounts.\n * @notice This contract allows accounts to easily delegate a portion of their tickets to multiple delegatees.\n  The delegatees chance of winning prizes is increased by the delegated amount.\n  If a delegator doesn't want to actively manage the delegations, then they can stake on the contract and appoint representatives.\n */\ncontract TWABDelegator is ERC20, LowLevelDelegator, PermitAndMulticall {\n  using Address for address;\n  using Clones for address;\n  using SafeERC20 for IERC20;\n\n  /* ============ Events ============ */\n\n  /**\n   * @notice Emitted when ticket associated with this contract has been set.\n   * @param ticket Address of the ticket\n   */\n  event TicketSet(ITicket indexed ticket);\n\n  /**\n   * @notice Emitted when tickets have been staked.\n   * @param delegator Address of the delegator\n   * @param amount Amount of tickets staked\n   */\n  event TicketsStaked(address indexed delegator, uint256 amount);\n\n  /**\n   * @notice Emitted when tickets have been unstaked.\n   * @param delegator Address of the delegator\n   * @param recipient Address of the recipient that will receive the tickets\n   * @param amount Amount of tickets unstaked\n   */\n  event TicketsUnstaked(address indexed delegator, address indexed recipient, uint256 amount);\n\n  /**\n   * @notice Emitted when a new delegation is created.\n   * @param delegator Delegator of the delegation\n   * @param slot Slot of the delegation\n   * @param lockUntil Timestamp until which the delegation is locked\n   * @param delegatee Address of the delegatee\n   * @param delegation Address of the delegation that was created\n   * @param user Address of the user who created the delegation\n   */\n  event DelegationCreated(\n    address indexed delegator,\n    uint256 indexed slot,\n    uint96 lockUntil,\n    address indexed delegatee,\n    Delegation delegation,\n    address user\n  );\n\n  /**\n   * @notice Emitted when a delegatee is updated.\n   * @param delegator Address of the delegator\n   * @param slot Slot of the delegation\n   * @param delegatee Address of the delegatee\n   * @param lockUntil Timestamp until which the delegation is locked\n   * @param user Address of the user who updated the delegatee\n   */\n  event DelegateeUpdated(\n    address indexed delegator,\n    uint256 indexed slot,\n    address indexed delegatee,\n    uint96 lockUntil,\n    address user\n  );\n\n  /**\n   * @notice Emitted when a delegation is funded.\n   * @param delegator Address of the delegator\n   * @param slot Slot of the delegation\n   * @param amount Amount of tickets that were sent to the delegation\n   * @param user Address of the user who funded the delegation\n   */\n  event DelegationFunded(\n    address indexed delegator,\n    uint256 indexed slot,\n    uint256 amount,\n    address indexed user\n  );\n\n  /**\n   * @notice Emitted when a delegation is funded from the staked amount.\n   * @param delegator Address of the delegator\n   * @param slot Slot of the delegation\n   * @param amount Amount of tickets that were sent to the delegation\n   * @param user Address of the user who funded the delegation\n   */\n  event DelegationFundedFromStake(\n    address indexed delegator,\n    uint256 indexed slot,\n    uint256 amount,\n    address indexed user\n  );\n\n  /**\n   * @notice Emitted when an amount of tickets has been withdrawn from a delegation. The tickets are held by this contract and the delegator stake is increased.\n   * @param delegator Address of the delegator\n   * @param slot  Slot of the delegation\n   * @param amount Amount of tickets withdrawn\n   * @param user Address of the user who withdrew the tickets\n   */\n  event WithdrewDelegationToStake(\n    address indexed delegator,\n    uint256 indexed slot,\n    uint256 amount,\n    address indexed user\n  );\n\n  /**\n   * @notice Emitted when a delegator withdraws an amount of tickets from a delegation to their wallet.\n   * @param delegator Address of the delegator\n   * @param slot  Slot of the delegation\n   * @param amount Amount of tickets withdrawn\n   */\n  event TransferredDelegation(\n    address indexed delegator,\n    uint256 indexed slot,\n    uint256 amount,\n    address indexed to\n  );\n\n  /**\n   * @notice Emitted when a representative is set.\n   * @param delegator Address of the delegator\n   * @param representative Address of the representative\n   * @param set Boolean indicating if the representative was set or unset\n   */\n  event RepresentativeSet(address indexed delegator, address indexed representative, bool set);\n\n  /* ============ Variables ============ */\n\n  /// @notice Prize pool ticket to which this contract is tied to.\n  ITicket public immutable ticket;\n\n  /// @notice Max lock time during which a delegation cannot be updated.\n  uint256 public constant MAX_LOCK = 180 days;\n\n  /**\n   * @notice Representative elected by the delegator to handle delegation.\n   * @dev Representative can only handle delegation and cannot withdraw tickets to their wallet.\n   * @dev delegator => representative => bool allowing representative to represent the delegator\n   */\n  mapping(address => mapping(address => bool)) internal representatives;\n\n  /* ============ Constructor ============ */\n\n  /**\n   * @notice Creates a new TWAB Delegator that is bound to the given ticket contract.\n   * @param name_ The name for the staked ticket token\n   * @param symbol_ The symbol for the staked ticket token\n   * @param _ticket Address of the ticket contract\n   */\n  constructor(\n    string memory name_,\n    string memory symbol_,\n    ITicket _ticket\n  ) LowLevelDelegator() ERC20(name_, symbol_) {\n    require(address(_ticket) != address(0), \"TWABDelegator/tick-not-zero-addr\");\n    ticket = _ticket;\n\n    emit TicketSet(_ticket);\n  }\n\n  /* ============ External Functions ============ */\n\n  /**\n   * @notice Stake `_amount` of tickets in this contract.\n   * @dev Tickets can be staked on behalf of a `_to` user.\n   * @param _to Address to which the stake will be attributed\n   * @param _amount Amount of tickets to stake\n   */\n  function stake(address _to, uint256 _amount) external {\n    _requireRecipientNotZeroAddress(_to);\n    _requireAmountGtZero(_amount);\n\n    IERC20(ticket).safeTransferFrom(msg.sender, address(this), _amount);\n    _mint(_to, _amount);\n\n    emit TicketsStaked(_to, _amount);\n  }\n\n  /**\n   * @notice Unstake `_amount` of tickets from this contract. Transfers ticket to the passed `_to` address.\n   * @dev If delegator has delegated his whole stake, he will first have to withdraw from a delegation to be able to unstake.\n   * @param _to Address of the recipient that will receive the tickets\n   * @param _amount Amount of tickets to unstake\n   */\n  function unstake(address _to, uint256 _amount) external {\n    _requireRecipientNotZeroAddress(_to);\n    _requireAmountGtZero(_amount);\n\n    _burn(msg.sender, _amount);\n\n    IERC20(ticket).safeTransfer(_to, _amount);\n\n    emit TicketsUnstaked(msg.sender, _to, _amount);\n  }\n\n  /**\n   * @notice Creates a new delegation.\n   This will create a new Delegation contract for the given slot and have it delegate its tickets to the given delegatee.\n   If a non-zero lock duration is passed, then the delegatee cannot be changed, nor funding withdrawn, until the lock has expired.\n   * @dev The `_delegator` and `_slot` params are used to compute the salt of the delegation\n   * @param _delegator Address of the delegator that will be able to handle the delegation\n   * @param _slot Slot of the delegation\n   * @param _delegatee Address of the delegatee\n   * @param _lockDuration Duration of time for which the delegation is locked. Must be less than the max duration.\n   * @return Returns the address of the Delegation contract that will hold the tickets\n   */\n  function createDelegation(\n    address _delegator,\n    uint256 _slot,\n    address _delegatee,\n    uint96 _lockDuration\n  ) external returns (Delegation) {\n    _requireDelegatorOrRepresentative(_delegator);\n    _requireDelegateeNotZeroAddress(_delegatee);\n    _requireLockDuration(_lockDuration);\n\n    uint96 _lockUntil = _computeLockUntil(_lockDuration);\n    Delegation _delegation = _createDelegation(\n      _computeSalt(_delegator, bytes32(_slot)),\n      _lockUntil\n    );\n    _delegateCall(_delegation, _delegatee);\n\n    emit DelegationCreated(_delegator, _slot, _lockUntil, _delegatee, _delegation, msg.sender);\n\n    return _delegation;\n  }\n\n  /**\n   * @notice Updates the delegatee and lock duration for a delegation slot.\n   * @dev Only callable by the `_delegator` or their representative.\n   * @dev Will revert if delegation is still locked.\n   * @param _delegator Address of the delegator\n   * @param _slot Slot of the delegation\n   * @param _delegatee Address of the delegatee\n   * @param _lockDuration Duration of time during which the delegatee cannot be changed nor withdrawn\n   * @return The address of the Delegation\n   */\n  function updateDelegatee(\n    address _delegator,\n    uint256 _slot,\n    address _delegatee,\n    uint96 _lockDuration\n  ) external returns (Delegation) {\n    _requireDelegatorOrRepresentative(_delegator);\n    _requireDelegateeNotZeroAddress(_delegatee);\n    _requireLockDuration(_lockDuration);\n\n    Delegation _delegation = Delegation(_computeAddress(_delegator, _slot));\n    _requireDelegationUnlocked(_delegation);\n\n    uint96 _lockUntil = _computeLockUntil(_lockDuration);\n\n    if (_lockDuration > 0) {\n      _delegation.setLockUntil(_lockUntil);\n    }\n\n    _delegateCall(_delegation, _delegatee);\n\n    emit DelegateeUpdated(_delegator, _slot, _delegatee, _lockUntil, msg.sender);\n\n    return _delegation;\n  }\n\n  /**\n   * @notice Fund a delegation by transferring tickets from the caller to the delegation.\n   * @dev Callable by anyone.\n   * @dev Will revert if delegation does not exist.\n   * @param _delegator Address of the delegator\n   * @param _slot Slot of the delegation\n   * @param _amount Amount of tickets to transfer\n   * @return The address of the Delegation\n   */\n  function fundDelegation(\n    address _delegator,\n    uint256 _slot,\n    uint256 _amount\n  ) external returns (Delegation) {\n    _requireDelegatorNotZeroAddress(_delegator);\n    _requireAmountGtZero(_amount);\n\n    Delegation _delegation = Delegation(_computeAddress(_delegator, _slot));\n    _requireContract(address(_delegation));\n\n    IERC20(ticket).safeTransferFrom(msg.sender, address(_delegation), _amount);\n\n    emit DelegationFunded(_delegator, _slot, _amount, msg.sender);\n\n    return _delegation;\n  }\n\n  /**\n   * @notice Fund a delegation using the `_delegator` stake.\n   * @dev Callable only by the `_delegator` or a representative.\n   * @dev Will revert if delegation does not exist.\n   * @dev Will revert if `_amount` is greater than the staked amount.\n   * @param _delegator Address of the delegator\n   * @param _slot Slot of the delegation\n   * @param _amount Amount of tickets to send to the delegation from the staked amount\n   * @return The address of the Delegation\n   */\n  function fundDelegationFromStake(\n    address _delegator,\n    uint256 _slot,\n    uint256 _amount\n  ) external returns (Delegation) {\n    _requireDelegatorOrRepresentative(_delegator);\n    _requireAmountGtZero(_amount);\n\n    Delegation _delegation = Delegation(_computeAddress(_delegator, _slot));\n    _requireContract(address(_delegation));\n\n    _burn(_delegator, _amount);\n\n    IERC20(ticket).safeTransfer(address(_delegation), _amount);\n\n    emit DelegationFundedFromStake(_delegator, _slot, _amount, msg.sender);\n\n    return _delegation;\n  }\n\n  /**\n   * @notice Withdraw tickets from a delegation. The tickets will be held by this contract and the delegator's stake will increase.\n   * @dev Only callable by the `_delegator` or a representative.\n   * @dev Will send the tickets to this contract and increase the `_delegator` staked amount.\n   * @dev Will revert if delegation is still locked.\n   * @param _delegator Address of the delegator\n   * @param _slot Slot of the delegation\n   * @param _amount Amount of tickets to withdraw\n   * @return The address of the Delegation\n   */\n  function withdrawDelegationToStake(\n    address _delegator,\n    uint256 _slot,\n    uint256 _amount\n  ) external returns (Delegation) {\n    _requireDelegatorOrRepresentative(_delegator);\n\n    Delegation _delegation = Delegation(_computeAddress(_delegator, _slot));\n\n    _transfer(_delegation, address(this), _amount);\n\n    _mint(_delegator, _amount);\n\n    emit WithdrewDelegationToStake(_delegator, _slot, _amount, msg.sender);\n\n    return _delegation;\n  }\n\n  /**\n   * @notice Withdraw an `_amount` of tickets from a delegation. The delegator is assumed to be the caller. The tickets are transferred to the caller.\n   * @dev Will directly send the tickets to the delegator wallet.\n   * @dev Will revert if delegation is still locked.\n   * @param _slot Slot of the delegation\n   * @param _amount Amount to withdraw\n   * @param _to Account to transfer the withdrawn tickets to\n   * @return The address of the Delegation\n   */\n  function transferDelegationTo(\n    uint256 _slot,\n    uint256 _amount,\n    address _to\n  ) external returns (Delegation) {\n    _requireRecipientNotZeroAddress(_to);\n\n    Delegation _delegation = Delegation(_computeAddress(msg.sender, _slot));\n    _transfer(_delegation, _to, _amount);\n\n    emit TransferredDelegation(msg.sender, _slot, _amount, _to);\n\n    return _delegation;\n  }\n\n  /**\n   * @notice Allow an account to set or unset a `_representative` to handle delegation.\n   * @dev If `_set` is `true`, `_representative` will be set as representative of `msg.sender`.\n   * @dev If `_set` is `false`, `_representative` will be unset as representative of `msg.sender`.\n   * @param _representative Address of the representative\n   * @param _set Set or unset the representative\n   */\n  function setRepresentative(address _representative, bool _set) external {\n    require(_representative != address(0), \"TWABDelegator/rep-not-zero-addr\");\n\n    representatives[msg.sender][_representative] = _set;\n\n    emit RepresentativeSet(msg.sender, _representative, _set);\n  }\n\n  /**\n   * @notice Returns whether or not the given rep is a representative of the delegator.\n   * @param _delegator The delegator\n   * @param _representative The representative to check for\n   * @return True if the rep is a rep, false otherwise\n   */\n  function isRepresentativeOf(address _delegator, address _representative)\n    external\n    view\n    returns (bool)\n  {\n    return representatives[_delegator][_representative];\n  }\n\n  /**\n   * @notice Allows a user to call multiple functions on the same contract.  Useful for EOA who wants to batch transactions.\n   * @param _data An array of encoded function calls.  The calls must be abi-encoded calls to this contract.\n   * @return results The results from each function call\n   */\n  function multicall(bytes[] calldata _data) external returns (bytes[] memory results) {\n    return _multicall(_data);\n  }\n\n  /**\n   * @notice Alow a user to approve ticket and run various calls in one transaction.\n   * @param _from Address of the sender\n   * @param _amount Amount of tickets to approve\n   * @param _permitSignature Permit signature\n   * @param _data Datas to call with `functionDelegateCall`\n   */\n  function permitAndMulticall(\n    address _from,\n    uint256 _amount,\n    Signature calldata _permitSignature,\n    bytes[] calldata _data\n  ) external {\n    _permitAndMulticall(IERC20Permit(address(ticket)), _from, _amount, _permitSignature, _data);\n  }\n\n  /**\n   * @notice Allows the caller to easily get the details for a delegation.\n   * @param _delegator The delegator address\n   * @param _slot The delegation slot they are using\n   * @return delegation The address that holds tickets for the delegation\n   * @return delegatee The address that tickets are being delegated to\n   * @return balance The balance of tickets in the delegation\n   * @return lockUntil The timestamp at which the delegation unlocks\n   * @return wasCreated Whether or not the delegation has been created\n   */\n  function getDelegation(address _delegator, uint256 _slot)\n    external\n    view\n    returns (\n      Delegation delegation,\n      address delegatee,\n      uint256 balance,\n      uint256 lockUntil,\n      bool wasCreated\n    )\n  {\n    delegation = Delegation(_computeAddress(_delegator, _slot));\n    wasCreated = address(delegation).isContract();\n    delegatee = ticket.delegateOf(address(delegation));\n    balance = ticket.balanceOf(address(delegation));\n\n    if (wasCreated) {\n      lockUntil = delegation.lockUntil();\n    }\n  }\n\n  /**\n   * @notice Computes the address of the delegation for the delegator + slot combination.\n   * @param _delegator The user who is delegating tickets\n   * @param _slot The delegation slot\n   * @return The address of the delegation.  This is the address that holds the balance of tickets.\n   */\n  function computeDelegationAddress(address _delegator, uint256 _slot)\n    external\n    view\n    returns (address)\n  {\n    return _computeAddress(_delegator, _slot);\n  }\n\n  /* ============ Internal Functions ============ */\n\n  /**\n   * @notice Computes the address of a delegation contract using the delegator and slot as a salt.\n   The contract is a clone, also known as minimal proxy contract.\n   * @param _delegator Address of the delegator\n   * @param _slot Slot of the delegation\n   * @return Address at which the delegation contract will be deployed\n   */\n  function _computeAddress(address _delegator, uint256 _slot) internal view returns (address) {\n    return _computeAddress(_computeSalt(_delegator, bytes32(_slot)));\n  }\n\n  /**\n   * @notice Computes the timestamp at which the delegation unlocks, after which the delegatee can be changed and tickets withdrawn.\n   * @param _lockDuration The duration of the lock\n   * @return The lock expiration timestamp\n   */\n  function _computeLockUntil(uint96 _lockDuration) internal view returns (uint96) {\n    return uint96(block.timestamp) + _lockDuration;\n  }\n\n  /**\n   * @notice Has the Delegation contact delegate its tickets to the delegatee.\n   * @param _delegation Address of the delegation contract\n   * @param _delegatee Address of the delegatee\n   */\n  function _delegateCall(Delegation _delegation, address _delegatee) internal {\n    bytes4 _selector = ticket.delegate.selector;\n    bytes memory _data = abi.encodeWithSelector(_selector, _delegatee);\n\n    _executeCall(_delegation, _data);\n  }\n\n  /**\n   * @notice Tranfers tickets from the Delegation contract to the `_to` address.\n   * @param _delegation Address of the delegation contract\n   * @param _to Address of the recipient\n   * @param _amount Amount of tickets to transfer\n   */\n  function _transferCall(\n    Delegation _delegation,\n    address _to,\n    uint256 _amount\n  ) internal {\n    bytes4 _selector = ticket.transfer.selector;\n    bytes memory _data = abi.encodeWithSelector(_selector, _to, _amount);\n\n    _executeCall(_delegation, _data);\n  }\n\n  /**\n   * @notice Execute a function call on the delegation contract.\n   * @param _delegation Address of the delegation contract\n   * @param _data The call data that will be executed\n   */\n  function _executeCall(Delegation _delegation, bytes memory _data)\n    internal\n    returns (bytes[] memory)\n  {\n    Delegation.Call[] memory _calls = new Delegation.Call[](1);\n    _calls[0] = Delegation.Call({ to: address(ticket), value: 0, data: _data });\n\n    return _delegation.executeCalls(_calls);\n  }\n\n  /**\n   * @notice Transfers tickets from a delegation contract to `_to`.\n   * @param _delegation Address of the delegation contract\n   * @param _to Address of the recipient\n   * @param _amount Amount of tickets to transfer\n   */\n  function _transfer(\n    Delegation _delegation,\n    address _to,\n    uint256 _amount\n  ) internal {\n    _requireAmountGtZero(_amount);\n    _requireDelegationUnlocked(_delegation);\n\n    _transferCall(_delegation, _to, _amount);\n  }\n\n  /* ============ Modifier/Require Functions ============ */\n\n  /**\n   * @notice Require to only allow the delegator or representative to call a function.\n   * @param _delegator Address of the delegator\n   */\n  function _requireDelegatorOrRepresentative(address _delegator) internal view {\n    require(\n      _delegator == msg.sender || representatives[_delegator][msg.sender] == true,\n      \"TWABDelegator/not-delegator-or-rep\"\n    );\n  }\n\n  /**\n   * @notice Require to verify that `_delegatee` is not address zero.\n   * @param _delegatee Address of the delegatee\n   */\n  function _requireDelegateeNotZeroAddress(address _delegatee) internal pure {\n    require(_delegatee != address(0), \"TWABDelegator/dlgt-not-zero-adr\");\n  }\n\n  /**\n   * @notice Require to verify that `_amount` is greater than 0.\n   * @param _amount Amount to check\n   */\n  function _requireAmountGtZero(uint256 _amount) internal pure {\n    require(_amount > 0, \"TWABDelegator/amount-gt-zero\");\n  }\n\n  /**\n   * @notice Require to verify that `_delegator` is not address zero.\n   * @param _delegator Address to check\n   */\n  function _requireDelegatorNotZeroAddress(address _delegator) internal pure {\n    require(_delegator != address(0), \"TWABDelegator/dlgtr-not-zero-adr\");\n  }\n\n  /**\n   * @notice Require to verify that `_to` is not address zero.\n   * @param _to Address to check\n   */\n  function _requireRecipientNotZeroAddress(address _to) internal pure {\n    require(_to != address(0), \"TWABDelegator/to-not-zero-addr\");\n  }\n\n  /**\n   * @notice Require to verify if a `_delegation` is locked.\n   * @param _delegation Delegation to check\n   */\n  function _requireDelegationUnlocked(Delegation _delegation) internal view {\n    require(block.timestamp >= _delegation.lockUntil(), \"TWABDelegator/delegation-locked\");\n  }\n\n  /**\n   * @notice Require to verify that `_address` is a contract.\n   * @param _address Address to check\n   */\n  function _requireContract(address _address) internal view {\n    require(_address.isContract(), \"TWABDelegator/not-a-contract\");\n  }\n\n  /**\n   * @notice Require to verify that a `_lockDuration` does not exceed the maximum lock duration.\n   * @param _lockDuration Lock duration to check\n   */\n  function _requireLockDuration(uint256 _lockDuration) internal pure {\n    require(_lockDuration <= MAX_LOCK, \"TWABDelegator/lock-too-long\");\n  }\n}"
    }
  ]
}