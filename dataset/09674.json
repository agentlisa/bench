{
  "Title": "[N-09] Typos",
  "Content": "\n1.  File: contracts/HolyPaladinToken.sol (line [33](https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/HolyPaladinToken.sol#L33))\n\n```solidity\n    /** @notice Period to unlock/re-lock tokens without possibility of punishement   */\n```\n\npunishement\n\n2.  File: contracts/HolyPaladinToken.sol (line [59](https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/HolyPaladinToken.sol#L59))\n\n```solidity\n    /** @notice Struct trancking the total amount locked  */\n```\n\ntrancking\n\n3.  File: contracts/HolyPaladinToken.sol (line [110](https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/HolyPaladinToken.sol#L110))\n\n```solidity\n    /** @notice Timstamp of last update for global reward index  */\n```\n\nTimstamp\n\n4.  File: contracts/HolyPaladinToken.sol (line [113](https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/HolyPaladinToken.sol#L113))\n\n```solidity\n    /** @notice Amount of rewards distriubted per second at the start  */\n```\n\ndistriubted\n\n5.  File: contracts/HolyPaladinToken.sol (line [239](https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/HolyPaladinToken.sol#L239))\n\n```solidity\n     * @param amount amount ot withdraw\n```\n\not\n\n6.  File: contracts/HolyPaladinToken.sol (line [258](https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/HolyPaladinToken.sol#L258))\n\n```solidity\n            // If the user does not deelegate currently, automatically self-delegate\n```\n\ndeelegate\n\n7.  File: contracts/HolyPaladinToken.sol (line [421](https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/HolyPaladinToken.sol#L421))\n\n```solidity\n     * @param receiver address fo the receiver\n```\n\nfo\n\n8.  File: contracts/HolyPaladinToken.sol (line [706](https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/HolyPaladinToken.sol#L706))\n\n```solidity\n    // Find the user available balance (staked - locked) => the balance that can be transfered\n```\n\ntransfered\n\n9.  File: contracts/HolyPaladinToken.sol (line [802](https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/HolyPaladinToken.sol#L802))\n\n```solidity\n                // (using avaialable balance to count the locked balance with the multiplier later in this function)\n```\n\navaialable\n\n10. File: contracts/HolyPaladinToken.sol (line [840](https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/HolyPaladinToken.sol#L840))\n\n```solidity\n                            // a ratio based on the rpevious one and the newly calculated one\n```\n\nrpevious\n\n11. File: contracts/HolyPaladinToken.sol (line [1323](https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/HolyPaladinToken.sol#L1323))\n\n```solidity\n        // update the the Delegate chekpoint for the delegatee\n```\n\nchekpoint\n\n12. File: contracts/PaladinRewardReserve.sol (line [19](https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/PaladinRewardReserve.sol#L19))\n\n```solidity\n    /** @notice Emitted when the allowance of a spander is updated */\n```\n\nspander\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-03-paladin",
  "Code": [
    {
      "filename": "contracts/HolyPaladinToken.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"./open-zeppelin/ERC20.sol\";\nimport \"./open-zeppelin/utils/Ownable.sol\";\nimport \"./open-zeppelin/interfaces/IERC20.sol\";\nimport \"./open-zeppelin/libraries/SafeERC20.sol\";\nimport \"./open-zeppelin/utils/Math.sol\";\n\n/** @title Holy Paladin Token (hPAL) contract  */\n/// @author Paladin\ncontract HolyPaladinToken is ERC20(\"Holy Paladin Token\", \"hPAL\"), Ownable {\n    using SafeERC20 for IERC20;\n\n\n    /** @notice Seconds in a Week */\n    uint256 public constant WEEK = 604800;\n    /** @notice Seconds in a Month */\n    uint256 public constant MONTH = 2629800;\n    /** @notice 1e18 scale */\n    uint256 public constant UNIT = 1e18;\n    /** @notice Max BPS value (100%) */\n    uint256 public constant MAX_BPS = 10000;\n    /** @notice Seconds in a Year */\n    uint256 public constant ONE_YEAR = 31557600;\n\n    /** @notice  Period to wait before unstaking tokens  */\n    uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days\n    /** @notice  Duration of the unstaking period\n    After that period, unstaking cooldown is expired  */\n    uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days\n\n    /** @notice Period to unlock/re-lock tokens without possibility of punishement   */\n    uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks\n\n    /** @notice Minimum duration of a Lock  */\n    uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months\n    /** @notice Maximum duration of a Lock  */\n    uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years\n\n    /** @notice Address of the PAL token  */\n    IERC20 public immutable pal;\n\n    /** @notice Struct of the Lock of an user  */\n    struct UserLock {\n        // Amount of locked balance\n        uint128 amount; // safe because PAL max supply is 10M tokens\n        // Start of the Lock\n        uint48 startTimestamp;\n        // Duration of the Lock\n        uint48 duration;\n        // BlockNumber for the Lock\n        uint32 fromBlock; // because we want to search by block number\n    }\n\n    /** @notice Array of all user Locks, ordered from oldest to newest  */\n    mapping(address => UserLock[]) public userLocks;\n\n    /** @notice Struct trancking the total amount locked  */\n    struct TotalLock {\n        // Total locked Supply\n        uint224 total;\n        // BlockNumber for the last update\n        uint32 fromBlock;\n    }\n\n    /** @notice Current Total locked Supply  */\n    uint256 public currentTotalLocked;\n    /** @notice List of TotalLocks, ordered from oldest to newest  */\n    TotalLock[] public totalLocks;\n\n    /** @notice User Cooldowns  */\n    mapping(address => uint256) public cooldowns;\n\n    /** @notice Checkpoints for users votes  */\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint224 votes;\n    }\n\n    /** @notice Checkpoints for users Delegates  */\n    struct DelegateCheckpoint {\n        uint32 fromBlock;\n        address delegate;\n    }\n\n    /** @notice mapping tracking the Delegator for each Delegatee  */\n    mapping(address => address) public delegates;\n\n    /** @notice List of Vote checkpoints for each user  */\n    mapping(address => Checkpoint[]) public checkpoints;\n\n    /** @notice List of Delegate checkpoints for each user  */\n    mapping(address => DelegateCheckpoint[]) public delegateCheckpoints;\n\n    /** @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  */\n    uint256 public kickRatioPerWeek = 1000;\n\n    /** @notice Ratio of bonus votes applied on user locked balance  */\n    uint256 public bonusLockVoteRatio = 0.5e18;\n\n    /** @notice Allow emergency withdraws  */\n    bool public emergency = false;\n\n    /** @notice Address of the vault holding the PAL rewards  */\n    address public immutable rewardsVault;\n\n    /** @notice Global reward index  */\n    uint256 public rewardIndex;\n    /** @notice Timstamp of last update for global reward index  */\n    uint256 public lastRewardUpdate;\n\n    /** @notice Amount of rewards distriubted per second at the start  */\n    uint256 public immutable startDropPerSecond;\n    /** @notice Amount of rewards distributed per second at the end of the decrease duration  */\n    uint256 public endDropPerSecond;\n    /** @notice Current amount of rewards distriubted per second  */\n    uint256 public currentDropPerSecond;\n    /** @notice Timestamp of last update for currentDropPerSecond  */\n    uint256 public lastDropUpdate;\n    /** @notice Duration (in seconds) of the DropPerSecond decrease period  */\n    uint256 public immutable dropDecreaseDuration;\n    /** @notice Timestamp: start of the DropPerSecond decrease period  */\n    uint256 public immutable startDropTimestamp;\n\n    /** @notice Last reward index for each user  */\n    mapping(address => uint256) public userRewardIndex;\n    /** @notice Current amount of rewards claimable for the user  */\n    mapping(address => uint256) public claimableRewards;\n    /** @notice Timestamp of last update for user rewards  */\n    mapping(address => uint256) public rewardsLastUpdate;\n\n    /** @notice Base reward multiplier for lock  */\n    uint256 public immutable baseLockBonusRatio;\n    /** @notice Minimum reward multiplier for minimum lock duration  */\n    uint256 public immutable minLockBonusRatio;\n    /** @notice Maximum reward multiplier for maximum duration  */\n    uint256 public immutable maxLockBonusRatio;\n\n    /** @notice Last updated Bonus Ratio for rewards  */\n    mapping(address => uint256) public userCurrentBonusRatio;\n    /** @notice Value by which user Bonus Ratio decrease each second  */\n    mapping(address => uint256) public userBonusRatioDecrease;\n\n    /** @notice Error raised if contract is turned in emergency mode */\n    error EmergencyBlock(); \n\n    // Event\n\n    /** @notice Emitted when an user stake PAL in the contract */\n    event Stake(address indexed user, uint256 amount);\n    /** @notice Emitted when an user burns hPAL to withdraw PAL */\n    event Unstake(address indexed user, uint256 amount);\n    /** @notice Emitted when an user triggers the cooldown period */\n    event Cooldown(address indexed user);\n    /** @notice Emitted when an user creates or update its Lock */\n    event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked);\n    /** @notice Emitted when an user exits the Lock */\n    event Unlock(address indexed user, uint256 amount, uint256 totalLocked);\n    /** @notice Emitted when an user is kicked out of the Lock */\n    event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked);\n    /** @notice Emitted when an user claim the rewards */\n    event ClaimRewards(address indexed user, uint256 amount);\n    /** @notice Emitted when the delegate of an address changes */\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n    /** @notice Emitted when the votes of a delegate is updated */\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n    /** @notice Emitted when un user withdraw through the emergency method */\n    event EmergencyUnstake(address indexed user, uint256 amount);\n\n    constructor(\n        address palToken,\n        address _admin,\n        address _rewardsVault,\n        uint256 _startDropPerSecond,\n        uint256 _endDropPerSecond,\n        uint256 _dropDecreaseDuration,\n        uint256 _baseLockBonusRatio,\n        uint256 _minLockBonusRatio,\n        uint256 _maxLockBonusRatio\n    ){\n        require(palToken != address(0));\n        require(_admin != address(0));\n\n        pal = IERC20(palToken);\n\n        transferOwnership(_admin);\n\n        totalLocks.push(TotalLock(\n            0,\n            safe32(block.number)\n        ));\n        // Set the immutable variables\n        rewardsVault = _rewardsVault;\n\n        startDropPerSecond = _startDropPerSecond;\n        endDropPerSecond = _endDropPerSecond;\n\n        currentDropPerSecond = _startDropPerSecond;\n\n        dropDecreaseDuration = _dropDecreaseDuration;\n\n        baseLockBonusRatio = _baseLockBonusRatio;\n        minLockBonusRatio = _minLockBonusRatio;\n        maxLockBonusRatio = _maxLockBonusRatio;\n\n        // Set all update timestamp as contract creation timestamp\n        lastRewardUpdate = block.timestamp;\n        lastDropUpdate = block.timestamp;\n        // Start the reward distribution & DropPerSecond decrease\n        startDropTimestamp = block.timestamp;\n    }\n\n\n    /**\n     * @notice Deposits PAL & mints hPAL tokens\n     * @param amount amount to stake\n     * @return uint256 : amount of hPAL minted\n     */\n    function stake(uint256 amount) external returns(uint256) {\n        if(emergency) revert EmergencyBlock();\n        return _stake(msg.sender, amount);\n    }\n\n    /**\n     * @notice Updates the Cooldown for the caller\n     */\n    function cooldown() external {\n        require(balanceOf(msg.sender) > 0, \"hPAL: No balance\");\n\n        // Set the current timestamp as start of the user cooldown\n        cooldowns[msg.sender] = block.timestamp;\n\n        emit Cooldown(msg.sender);\n    }\n\n    /**\n     * @notice Burns hPAL & withdraws PAL\n     * @param amount amount ot withdraw\n     * @param receiver address to receive the withdrawn PAL\n     * @return uint256 : amount withdrawn\n     */\n    function unstake(uint256 amount, address receiver) external returns(uint256) {\n        if(emergency) revert EmergencyBlock();\n        return _unstake(msg.sender, amount, receiver);\n    }\n\n    /**\n     * @notice Locks hPAL for a given duration\n     * @param amount amount of the hPAL balance to lock\n     * @param duration duration of the Lock (in seconds)\n     */\n    function lock(uint256 amount, uint256 duration) external {\n        if(emergency) revert EmergencyBlock();\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(msg.sender);\n        if(delegates[msg.sender] == address(0)){\n            // If the user does not deelegate currently, automatically self-delegate\n            _delegate(msg.sender, msg.sender);\n        }\n        _lock(msg.sender, amount, duration, LockAction.LOCK);\n    }\n\n    /**\n     * @notice Increase the user current Lock duration (& restarts the Lock)\n     * @param duration new duration for the Lock (in seconds)\n     */\n    function increaseLockDuration(uint256 duration) external {\n        if(emergency) revert EmergencyBlock();\n        require(userLocks[msg.sender].length != 0, \"hPAL: No Lock\");\n        // Find the current Lock\n        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;\n        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(msg.sender);\n        // Call the _lock method with the current amount, and the new duration\n        _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION);\n    }\n\n    /**\n     * @notice Increase the amount of hPAL locked for the user\n     * @param amount new amount of hPAL to be locked (in total)\n     */\n    function increaseLock(uint256 amount) external {\n        if(emergency) revert EmergencyBlock();\n        require(userLocks[msg.sender].length != 0, \"hPAL: No Lock\");\n        // Find the current Lock\n        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;\n        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(msg.sender);\n        // Call the _lock method with the current duration, and the new amount\n        _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT);\n    }\n\n    /**\n     * @notice Removes the user Lock after expiration\n     */\n    function unlock() external {\n        if(emergency) revert EmergencyBlock();\n        require(userLocks[msg.sender].length != 0, \"hPAL: No Lock\");\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(msg.sender);\n        _unlock(msg.sender);\n    }\n\n    /**\n     * @notice Removes an user Lock if too long after expiry, and applies a penalty\n     * @param user address of the user to kick out of a Lock\n     */\n    function kick(address user) external {\n        if(emergency) revert EmergencyBlock();\n        require(msg.sender != user, \"hPAL: cannot kick yourself\");\n        // Update user rewards before any change on their balance (staked and locked)\n        // For both the user and the kicker\n        _updateUserRewards(user);\n        _updateUserRewards(msg.sender);\n        _kick(user, msg.sender);\n    }\n\n    /**\n     * @notice Staked PAL to get hPAL, and locks it for the given duration\n     * @param amount amount of PAL to stake and lock\n     * @param duration duration of the Lock (in seconds)\n     * @return uint256 : amount of hPAL minted\n     */\n    function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {\n        if(emergency) revert EmergencyBlock();\n        // Stake the given amount\n        uint256 stakedAmount = _stake(msg.sender, amount);\n        // No need to update user rewards since it's done through the _stake() method\n        if(delegates[msg.sender] == address(0)){\n            _delegate(msg.sender, msg.sender);\n        }\n        // And then lock it\n        _lock(msg.sender, amount, duration, LockAction.LOCK);\n        return stakedAmount;\n    }\n\n    /**\n     * @notice Stake more PAL into hPAL & add them to the current user Lock\n     * @param amount amount of PAL to stake and lock\n     * @param duration duration of the Lock (in seconds)\n     * @return uint256 : amount of hPAL minted\n     */\n    function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {\n        if(emergency) revert EmergencyBlock();\n        require(userLocks[msg.sender].length != 0, \"hPAL: No Lock\");\n        // Find the current Lock\n        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;\n        uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;\n        // Stake the new amount\n        uint256 stakedAmount = _stake(msg.sender, amount);\n        // No need to update user rewards since it's done through the _stake() method\n        if(delegates[msg.sender] == address(0)){\n            _delegate(msg.sender, msg.sender);\n        }\n        // Then update the lock with the new increased amount\n        if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {\n            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);\n        } else {\n            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);\n        }\n        return stakedAmount;\n    }\n\n    /**\n     * @notice Delegates the caller voting power to another address\n     * @param delegatee address to delegate to\n     */\n    function delegate(address delegatee) external virtual {\n        if(emergency) revert EmergencyBlock();\n        return _delegate(_msgSender(), delegatee);\n    }\n\n    /**\n     * @notice Claim the given amount of rewards for the caller\n     * @param amount amount ot claim\n     */\n    function claim(uint256 amount) external {\n        if(emergency) revert EmergencyBlock();\n        // Update user rewards before any change on their balance (staked and locked)\n        _updateUserRewards(msg.sender);\n\n        require(amount > 0, \"hPAL: incorrect amount\");\n\n        // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards\n        uint256 claimAmount = amount < claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];\n\n        // remove the claimed amount from the claimable mapping for the user, \n        // and transfer the PAL from the rewardsVault to the user\n        claimableRewards[msg.sender] -= claimAmount;\n\n        pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);\n\n        emit ClaimRewards(msg.sender, claimAmount);\n    }\n\n    /**\n     * @notice Updates the global Reward State for the contract\n     */\n    function updateRewardState() external {\n        if(emergency) revert EmergencyBlock();\n        _updateRewardState();\n    }\n\n    /**\n     * @notice Updates the given user Reward State\n     * @param user address of the user to update\n     */\n    function updateUserRewardState(address user) external {\n        if(emergency) revert EmergencyBlock();\n        _updateUserRewards(user);\n    }\n\n    // ---------------\n\n    /**\n     * @notice Estimates the new Cooldown for the receiver, based on sender & amount of transfer\n     * @param sender address of the sender\n     * @param receiver address fo the receiver\n     * @param amount amount ot transfer\n     * @return uint256 : new cooldown\n     */\n    function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {\n        uint256 senderCooldown = cooldowns[sender];\n        uint256 receiverBalance = balanceOf(receiver);\n\n        return _getNewReceiverCooldown(\n            senderCooldown,\n            amount,\n            receiver,\n            receiverBalance\n        );\n    }\n\n    /**\n     * @notice Get the total number of Locks for an user\n     * @param user address of the user\n     * @return uint256 : total number of Locks\n     */\n    function getUserLockCount(address user) external view returns(uint256) {\n        return userLocks[user].length;\n    }\n\n    /**\n     * @notice Get the current user Lock\n     * @param user address of the user\n     * @return UserLock : user Lock\n     */\n    function getUserLock(address user) external view returns(UserLock memory) {\n        //If the contract is blocked (emergency mode)\n        //Or if the user does not have a Lock yet\n        //Return an empty lock\n        if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);\n        uint256 lastUserLockIndex = userLocks[user].length - 1;\n        return userLocks[user][lastUserLockIndex];\n    }\n\n    /**\n     * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)\n     * @param user address of the user\n     * @param blockNumber block number\n     * @return UserLock : user past Lock\n     */\n    function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {\n        return _getPastLock(user, blockNumber);\n    }\n\n    /**\n     * @notice Get the total count of TotalLock\n     * @return uint256 : total count\n     */\n    function getTotalLockLength() external view returns(uint256){\n        return totalLocks.length;\n    }\n\n    /**\n     * @notice Get the latest TotalLock\n     * @return TotalLock : current TotalLock\n     */\n    function getCurrentTotalLock() external view returns(TotalLock memory){\n        if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked\n        return totalLocks[totalLocks.length - 1];\n    }\n\n    /**\n     * @notice Get the TotalLock at a given block\n     * @param blockNumber block number\n     * @return TotalLock : past TotalLock\n     */\n    function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {\n        require(\n            blockNumber < block.number,\n            \"hPAL: invalid blockNumber\"\n        );\n\n        TotalLock memory emptyLock = TotalLock(\n            0,\n            0\n        );\n\n        uint256 nbCheckpoints = totalLocks.length;\n\n        // last checkpoint check\n        if (totalLocks[nbCheckpoints - 1].fromBlock <= blockNumber) {\n            return totalLocks[nbCheckpoints - 1];\n        }\n\n        // no checkpoint old enough\n        if (totalLocks[0].fromBlock > blockNumber) {\n            return emptyLock;\n        }\n\n        uint256 high = nbCheckpoints - 1; // last checkpoint already checked\n        uint256 low = 0;\n        uint256 mid;\n        while (low < high) {\n            mid = Math.average(low, high);\n            if (totalLocks[mid].fromBlock == blockNumber) {\n                return totalLocks[mid];\n            }\n            if (totalLocks[mid].fromBlock > blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? emptyLock : totalLocks[high - 1];\n    }\n\n    /**\n     * @notice Get the user available balance (staked - locked)\n     * @param user address of the user\n     * @return uint256 : available balance\n     */\n    function availableBalanceOf(address user) external view returns(uint256) {\n        return _availableBalanceOf(user);\n    }\n\n    /**\n     * @notice Get all user balances\n     * @param user address of the user\n     * @return staked : staked balance\n     * @return locked : locked balance\n     * @return available : available balance (staked - locked)\n     */\n    function allBalancesOf(address user) external view returns(\n        uint256 staked,\n        uint256 locked,\n        uint256 available\n    ) {\n        // If the contract was blocked (emergency mode) or\n        // If the user has no Lock\n        // then available == staked\n        if(emergency || userLocks[user].length == 0) {\n            return(\n                balanceOf(user),\n                0,\n                balanceOf(user)\n            );\n        }\n        // If a Lock exists\n        // Then return\n        // total staked balance\n        // locked balance\n        // available balance (staked - locked)\n        uint256 lastUserLockIndex = userLocks[user].length - 1;\n        return(\n            balanceOf(user),\n            uint256(userLocks[user][lastUserLockIndex].amount),\n            balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)\n        );\n    }\n\n    /**\n     * @notice Get the estimated current amount of rewards claimable by the user\n     * @param user address of the user\n     * @return uint256 : estimated amount of rewards to claim\n     */\n    function estimateClaimableRewards(address user) external view returns(uint256) {\n        // no rewards for address 0x0\n        // & in case of emergency mode, show 0\n        if(emergency || user == address(0)) return 0;\n        // If the user rewards where updated on that block, then return the last updated value\n        if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];\n\n        // Get the user current claimable amount\n        uint256 estimatedClaimableRewards = claimableRewards[user];\n        // Get the last updated reward index\n        uint256 currentRewardIndex = rewardIndex;\n\n        if(lastRewardUpdate < block.timestamp){\n            // If needed, update the reward index\n            currentRewardIndex = _getNewIndex(currentDropPerSecond);\n        }\n\n        (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);\n\n        estimatedClaimableRewards += accruedRewards;\n\n        return estimatedClaimableRewards;\n    }\n\n    /**\n     * @notice Current number of vote checkpoints for the user\n     * @param account address of the user\n     * @return uint256 : number of checkpoints\n     */\n    function numCheckpoints(address account) external view virtual returns (uint256){\n        return checkpoints[account].length;\n    }\n\n    /**\n     * @notice Get the user current voting power (with bonus voting power from the Lock)\n     * @param user address of the user\n     * @return uint256 : user current voting power\n     */\n    function getCurrentVotes(address user) external view returns (uint256) {\n        if(emergency) return 0; //If emergency mode, do not show voting power\n\n        uint256 nbCheckpoints = checkpoints[user].length;\n        // current votes with delegation\n        uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;\n\n        // check if user has a lock\n        uint256 nbLocks = userLocks[user].length;\n\n        if(nbLocks == 0) return currentVotes;\n\n        // and if there is a lock, and user self-delegate, add the bonus voting power \n        uint256 lockAmount = userLocks[user][nbLocks - 1].amount;\n        uint256 bonusVotes = delegates[user] == user && userLocks[user][nbLocks - 1].duration >= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;\n\n        return currentVotes + bonusVotes;\n    }\n\n    /**\n     * @notice Get the user voting power for a given block (with bonus voting power from the Lock)\n     * @param user address of the user\n     * @param blockNumber block number\n     * @return uint256 : user past voting power\n     */\n    function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {\n        // votes with delegation for the given block\n        uint256 votes = _getPastVotes(user, blockNumber);\n\n\n        // check if user has a lock at that block\n        UserLock memory pastLock = _getPastLock(user, blockNumber);\n        // and if there is a lock, and user self-delegated, add the bonus voting power \n        uint256 bonusVotes = getPastDelegate(user, blockNumber) == user && pastLock.duration >= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;\n\n        return votes + bonusVotes;\n    }\n\n    /**\n     * @notice Get the user delegate at a given block\n     * @param account address of the user\n     * @param blockNumber block number\n     * @return address : delegate\n     */\n    function getPastDelegate(address account, uint256 blockNumber)\n        public\n        view\n        returns (address)\n    {\n        require(\n            blockNumber < block.number,\n            \"hPAL: invalid blockNumber\"\n        );\n\n        // no checkpoints written\n        uint256 nbCheckpoints = delegateCheckpoints[account].length;\n        if (nbCheckpoints == 0) return address(0);\n\n        // last checkpoint check\n        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {\n            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;\n        }\n\n        // no checkpoint old enough\n        if (delegateCheckpoints[account][0].fromBlock > blockNumber) {\n            return address(0);\n        }\n\n        uint256 high = nbCheckpoints - 1; // last checkpoint already checked\n        uint256 low = 0;\n        uint256 mid;\n        while (low < high) {\n            mid = Math.average(low, high);\n            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {\n                return delegateCheckpoints[account][mid].delegate;\n            }\n            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;\n    }\n\n    // ----------------\n\n    // Find the user available balance (staked - locked) => the balance that can be transfered\n    function _availableBalanceOf(address user) internal view returns(uint256) {\n        if(userLocks[user].length == 0) return balanceOf(user);\n        uint256 lastUserLockIndex = userLocks[user].length - 1;\n        return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount);\n    }\n\n    // Update dropPerSecond value\n    function _updateDropPerSecond() internal returns (uint256){\n        // If no more need for monthly updates => decrease duration is over\n        if(block.timestamp > startDropTimestamp + dropDecreaseDuration) {\n            // Set the current DropPerSecond as the end value\n            // Plus allows to be updated if the end value is later updated\n            if(currentDropPerSecond != endDropPerSecond) {\n                currentDropPerSecond = endDropPerSecond;\n                lastDropUpdate = block.timestamp;\n            }\n\n            return endDropPerSecond;\n        }\n\n        if(block.timestamp < lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month\n\n        uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);\n        uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;\n\n        uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;\n\n        // We calculate the new dropPerSecond value\n        // We don't want to go under the endDropPerSecond\n        uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease > endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;\n    \n        currentDropPerSecond = newDropPerSecond;\n        lastDropUpdate = block.timestamp;\n\n        return newDropPerSecond;\n    }\n\n    function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){\n        // Get the current total Supply\n        uint256 currentTotalSupply = totalSupply();\n        // and the seconds since the last update\n        uint256 ellapsedTime = block.timestamp - lastRewardUpdate;\n\n        // DropPerSeond without any multiplier => the base dropPerSecond for stakers\n        // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.\n        uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;\n\n        // total base reward (without multiplier) to be distributed since last update\n        uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;\n\n         // calculate the ratio to add to the index\n        uint256 ratio = currentTotalSupply > 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;\n\n        return rewardIndex + ratio;\n    }\n\n    // Update global reward state internal\n    function _updateRewardState() internal returns (uint256){\n        if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block\n\n        // Update (if needed) & get the current DropPerSecond\n        uint256 _currentDropPerSecond = _updateDropPerSecond();\n\n        // Update the index\n        uint256 newIndex = _getNewIndex(_currentDropPerSecond);\n        rewardIndex = newIndex;\n        lastRewardUpdate = block.timestamp;\n\n        return newIndex;\n    }\n\n    struct UserLockRewardVars {\n        uint256 lastUserLockIndex;\n        uint256 previousBonusRatio;\n        uint256 userRatioDecrease;\n        uint256 bonusRatioDecrease;\n        uint256 periodBonusRatio;\n    }\n\n    function _getUserAccruedRewards(\n        address user,\n        uint256 currentRewardsIndex\n    ) internal view returns(\n        uint256 accruedRewards,\n        uint256 newBonusRatio\n    ) {\n        // Find the user last index & current balances\n        uint256 userLastIndex = userRewardIndex[user];\n        uint256 userStakedBalance = _availableBalanceOf(user);\n        uint256 userLockedBalance = 0;\n\n        if(userLastIndex != currentRewardsIndex){\n\n            if(balanceOf(user) > 0){\n                // calculate the base rewards for the user staked balance\n                // (using avaialable balance to count the locked balance with the multiplier later in this function)\n                uint256 indexDiff = currentRewardsIndex - userLastIndex;\n\n                uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;\n\n                uint256 lockingRewards = 0;\n\n                if(userLocks[user].length > 0){\n                    UserLockRewardVars memory vars;\n\n                    // and if an user has a lock, calculate the locked rewards\n                    vars.lastUserLockIndex = userLocks[user].length - 1;\n\n                    // using the locked balance, and the lock duration\n                    userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);\n\n                    // Check that the user's Lock is not empty\n                    if(userLockedBalance > 0 && userLocks[user][vars.lastUserLockIndex].duration != 0){\n                        vars.previousBonusRatio = userCurrentBonusRatio[user];\n\n                        if(vars.previousBonusRatio > 0){\n                            vars.userRatioDecrease = userBonusRatioDecrease[user];\n                            // Find the new multiplier for user:\n                            // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update\n                            vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;\n                            \n                            newBonusRatio = vars.bonusRatioDecrease >= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;\n\n                            if(vars.bonusRatioDecrease >= vars.previousBonusRatio){\n                                // Since the last update, bonus ratio decrease under 0\n                                // We count the bonusRatioDecrease as the difference b"
    }
  ]
}