{
  "Title": "withdrawAll Function Can Withdraw Unsupported Tokens",
  "Content": "In the `BalancerMetaPoolStrategy`, the [`withdrawAll`](https://github.com/OriginProtocol/origin-dollar/blob/eb11498c376b65696c90981757221b076d6226aa/contracts/contracts/strategies/balancer/BalancerMetaPoolStrategy.sol#L330) implementation retrieves the [pool tokens](https://github.com/OriginProtocol/origin-dollar/blob/eb11498c376b65696c90981757221b076d6226aa/contracts/contracts/strategies/balancer/BalancerMetaPoolStrategy.sol#L343-L344) and [iterates through them,](https://github.com/OriginProtocol/origin-dollar/blob/eb11498c376b65696c90981757221b076d6226aa/contracts/contracts/strategies/balancer/BalancerMetaPoolStrategy.sol#L353C54-L358) calculating the expected minimum amounts out. These calculated amounts are used for [exiting the pool](https://github.com/OriginProtocol/origin-dollar/blob/eb11498c376b65696c90981757221b076d6226aa/contracts/contracts/strategies/balancer/BalancerMetaPoolStrategy.sol#L374-L384), where tokens are received in exchange for BPTs.\n\n\nWhile these calculations are correct, if the intention is to withdraw across all tokens supported by the pool, they are incorrect when the assets supported by the strategy are a subset of the assets in the Balancer pool.\n\n\nDuring initialization, the `BaseBalancerStrategy` [passes a list of tokens](https://github.com/OriginProtocol/origin-dollar/blob/eb11498c376b65696c90981757221b076d6226aa/contracts/contracts/strategies/balancer/BaseBalancerStrategy.sol#L119) to the `InitializableAbstractStrategy`, which in turn [populates the `assetsMapped` array](https://github.com/OriginProtocol/origin-dollar/blob/eb11498c376b65696c90981757221b076d6226aa/contracts/contracts/utils/InitializableAbstractStrategy.sol#L264). This array contains the strategy's supported assets and is not guaranteed to include all assets supported by the associated Balancer pool.\n\n\nWhen exiting, consider only withdrawing assets that are supported by the strategy to prevent ending up with assets that are not accounted for and could potentially become stuck.\n\n\n***Update:** Resolved. The Origin team stated:*\n\n\n\n> *We decided not to make any changes. While we agree with the identified problem, our strategy currently [does not support a configuration where only a subset of the pool's assets can be supported](https://github.com/OriginProtocol/origin-dollar/pull/1697/files#diff-7d59dfab7a512a013f0696d107a97b7b6b0f1e8d656b8baac6642f61e3d84db6R110-R117).*\n\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/contracts/strategies/balancer/BalancerMetaPoolStrategy.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title OETH Balancer MetaStablePool Strategy\n * @author Origin Protocol Inc\n */\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { BaseAuraStrategy, BaseBalancerStrategy } from \"./BaseAuraStrategy.sol\";\nimport { IBalancerVault } from \"../../interfaces/balancer/IBalancerVault.sol\";\nimport { IRateProvider } from \"../../interfaces/balancer/IRateProvider.sol\";\nimport { IMetaStablePool } from \"../../interfaces/balancer/IMetaStablePool.sol\";\nimport { IERC20, InitializableAbstractStrategy } from \"../../utils/InitializableAbstractStrategy.sol\";\nimport { StableMath } from \"../../utils/StableMath.sol\";\n\ncontract BalancerMetaPoolStrategy is BaseAuraStrategy {\n    using SafeERC20 for IERC20;\n    using StableMath for uint256;\n\n    constructor(\n        BaseStrategyConfig memory _stratConfig,\n        BaseBalancerConfig memory _balancerConfig,\n        address _auraRewardPoolAddress\n    )\n        InitializableAbstractStrategy(_stratConfig)\n        BaseBalancerStrategy(_balancerConfig)\n        BaseAuraStrategy(_auraRewardPoolAddress)\n    {}\n\n    /**\n     * @notice Deposits an `_amount` of vault collateral assets\n     * from the this strategy contract to the Balancer pool.\n     * @param _asset Address of the Vault collateral asset\n     * @param _amount The amount of Vault collateral assets to deposit\n     */\n    function deposit(address _asset, uint256 _amount)\n        external\n        override\n        onlyVault\n        nonReentrant\n    {\n        address[] memory assets = new address[](1);\n        uint256[] memory amounts = new uint256[](1);\n        assets[0] = _asset;\n        amounts[0] = _amount;\n\n        _deposit(assets, amounts);\n    }\n\n    /**\n     * @notice Deposits specified vault collateral assets\n     * from the this strategy contract to the Balancer pool.\n     * @param _assets Address of the Vault collateral assets\n     * @param _amounts The amount of each asset to deposit\n     */\n    function deposit(address[] memory _assets, uint256[] memory _amounts)\n        external\n        onlyVault\n        nonReentrant\n    {\n        _deposit(_assets, _amounts);\n    }\n\n    /**\n     * @notice Deposits all supported assets in this strategy contract to the Balancer pool.\n     */\n    function depositAll() external override onlyVault nonReentrant {\n        uint256 assetsLength = assetsMapped.length;\n        address[] memory assets = new address[](assetsLength);\n        uint256[] memory amounts = new uint256[](assetsLength);\n\n        // For each vault collateral asset\n        for (uint256 i = 0; i < assetsLength; ++i) {\n            assets[i] = assetsMapped[i];\n            // Get the asset balance in this strategy contract\n            amounts[i] = IERC20(assets[i]).balanceOf(address(this));\n        }\n        _deposit(assets, amounts);\n    }\n\n    function _deposit(address[] memory _assets, uint256[] memory _amounts)\n        internal\n    {\n        require(_assets.length == _amounts.length, \"Array length missmatch\");\n\n        (IERC20[] memory tokens, , ) = balancerVault.getPoolTokens(\n            balancerPoolId\n        );\n\n        uint256[] memory mappedAmounts = new uint256[](tokens.length);\n        address[] memory mappedAssets = new address[](tokens.length);\n\n        for (uint256 i = 0; i < _assets.length; ++i) {\n            address asset = _assets[i];\n            uint256 amount = _amounts[i];\n\n            require(assetToPToken[asset] != address(0), \"Unsupported asset\");\n            mappedAssets[i] = toPoolAsset(_assets[i]);\n\n            if (amount > 0) {\n                emit Deposit(asset, platformAddress, amount);\n\n                // wrap rebasing assets like stETH and frxETH to wstETH and sfrxETH\n                (, mappedAmounts[i]) = wrapPoolAsset(asset, amount);\n            }\n        }\n\n        uint256[] memory amountsIn = new uint256[](tokens.length);\n        address[] memory poolAssets = new address[](tokens.length);\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            // Convert IERC20 type to address\n            poolAssets[i] = address(tokens[i]);\n\n            // For each of the mapped assets\n            for (uint256 j = 0; j < mappedAssets.length; ++j) {\n                // If the pool asset is the same as the mapped asset\n                if (poolAssets[i] == mappedAssets[j]) {\n                    amountsIn[i] = mappedAmounts[j];\n                }\n            }\n        }\n\n        uint256 minBPT = getBPTExpected(_assets, _amounts);\n        uint256 minBPTwSlippage = minBPT.mulTruncate(1e18 - maxDepositSlippage);\n\n        /* EXACT_TOKENS_IN_FOR_BPT_OUT:\n         * User sends precise quantities of tokens, and receives an\n         * estimated but unknown (computed at run time) quantity of BPT.\n         *\n         * ['uint256', 'uint256[]', 'uint256']\n         * [EXACT_TOKENS_IN_FOR_BPT_OUT, amountsIn, minimumBPT]\n         */\n        bytes memory userData = abi.encode(\n            IBalancerVault.WeightedPoolJoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,\n            amountsIn,\n            minBPTwSlippage\n        );\n\n        IBalancerVault.JoinPoolRequest memory request = IBalancerVault\n            .JoinPoolRequest(poolAssets, amountsIn, userData, false);\n\n        // Add the pool assets in this strategy to the balancer pool\n        balancerVault.joinPool(\n            balancerPoolId,\n            address(this),\n            address(this),\n            request\n        );\n\n        // Deposit the Balancer Pool Tokens (BPT) into Aura\n        _lpDepositAll();\n    }\n\n    /**\n     * @notice Withdraw a Vault collateral asset from the Balancer pool.\n     * @param _recipient Address to receive the Vault collateral assets. Typically is the Vault.\n     * @param _asset Address of the Vault collateral asset\n     * @param _amount The amount of Vault collateral assets to withdraw\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external override onlyVault nonReentrant {\n        address[] memory assets = new address[](1);\n        uint256[] memory amounts = new uint256[](1);\n        assets[0] = _asset;\n        amounts[0] = _amount;\n\n        _withdraw(_recipient, assets, amounts);\n    }\n\n    /**\n     * @notice Withdraw multiple Vault collateral asset from the Balancer pool.\n     * @param _recipient Address to receive the Vault collateral assets. Typically is the Vault.\n     * @param _assets Addresses of the Vault collateral assets\n     * @param _amounts The amounts of Vault collateral assets to withdraw\n     */\n    function withdraw(\n        address _recipient,\n        address[] memory _assets,\n        uint256[] memory _amounts\n    ) external onlyVault nonReentrant {\n        _withdraw(_recipient, _assets, _amounts);\n    }\n\n    /**\n     * @dev Withdraw multiple Vault collateral asset from the Balancer pool.\n     * @param _recipient Address to receive the Vault collateral assets. Typically is the Vault.\n     * @param _assets Addresses of the Vault collateral assets\n     * @param _amounts The amounts of Vault collateral assets to withdraw\n     */\n    function _withdraw(\n        address _recipient,\n        address[] memory _assets,\n        uint256[] memory _amounts\n    ) internal {\n        require(_assets.length == _amounts.length, \"Invalid input arrays\");\n\n        // STEP 1 - Calculate the max about of Balancer Pool Tokens (BPT) to withdraw\n\n        // Estimate the required amount of Balancer Pool Tokens (BPT) for the assets\n        uint256 maxBPTtoWithdraw = getBPTExpected(_assets, _amounts);\n        // Increase BPTs by the max allowed slippage\n        // Any excess BPTs will be left in this strategy contract\n        maxBPTtoWithdraw = maxBPTtoWithdraw.mulTruncate(\n            1e18 + maxWithdrawalSlippage\n        );\n\n        // STEP 2  - Withdraw the Balancer Pool Tokens (BPT) from Aura to this strategy contract\n\n        // Withdraw BPT from Aura allowing for BPTs left in this strategy contract from previous withdrawals\n        _lpWithdraw(\n            maxBPTtoWithdraw - IERC20(platformAddress).balanceOf(address(this))\n        );\n\n        // STEP 3 - Calculate the Balancer pool assets and amounts from the vault collateral assets\n\n        // Get all the supported balancer pool assets\n        (IERC20[] memory tokens, , ) = balancerVault.getPoolTokens(\n            balancerPoolId\n        );\n        // Calculate the balancer pool assets and amounts to withdraw\n        uint256[] memory poolAmountsOut = new uint256[](tokens.length);\n        address[] memory poolAssets = new address[](tokens.length);\n        // Is the wrapped asset amount indexed by the assets array, not the order of the Balancer pool tokens\n        // eg wstETH and sfrxETH amounts, not the stETH and frxETH amounts\n        uint256[] memory wrappedAssetAmounts = new uint256[](_assets.length);\n\n        // For each of the Balancer pool assets\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            poolAssets[i] = address(tokens[i]);\n\n            // for each of the vault assets\n            for (uint256 j = 0; j < _assets.length; ++j) {\n                // Convert the Balancer pool asset back to a vault collateral asset\n                address vaultAsset = fromPoolAsset(poolAssets[i]);\n\n                // If the vault asset equals the vault asset mapped from the Balancer pool asset\n                if (_assets[j] == vaultAsset) {\n                    (, poolAmountsOut[i]) = toPoolAsset(\n                        vaultAsset,\n                        _amounts[j]\n                    );\n                    wrappedAssetAmounts[j] = poolAmountsOut[i];\n\n                    /* Because of the potential Balancer rounding error mentioned below\n                     * the contract might receive 1-2 WEI smaller amount than required\n                     * in the withdraw user data encoding. If slightly lesser token amount\n                     * is received the strategy can not unwrap the pool asset as it is\n                     * smaller than expected.\n                     *\n                     * For that reason we `overshoot` the required tokens expected to\n                     * circumvent the error\n                     */\n                    if (poolAmountsOut[i] > 0) {\n                        poolAmountsOut[i] += 2;\n                    }\n                }\n            }\n        }\n\n        // STEP 4 - Withdraw the balancer pool assets from the pool\n\n        /* Custom asset exit: BPT_IN_FOR_EXACT_TOKENS_OUT:\n         * User sends an estimated but unknown (computed at run time) quantity of BPT,\n         * and receives precise quantities of specified tokens.\n         *\n         * ['uint256', 'uint256[]', 'uint256']\n         * [BPT_IN_FOR_EXACT_TOKENS_OUT, amountsOut, maxBPTAmountIn]\n         */\n        bytes memory userData = abi.encode(\n            IBalancerVault.WeightedPoolExitKind.BPT_IN_FOR_EXACT_TOKENS_OUT,\n            poolAmountsOut,\n            maxBPTtoWithdraw\n        );\n\n        IBalancerVault.ExitPoolRequest memory request = IBalancerVault\n            .ExitPoolRequest(\n                poolAssets,\n                /* We specify the exact amount of a tokens we are expecting in the encoded\n                 * userData, for that reason we don't need to specify the amountsOut here.\n                 *\n                 * Also Balancer has a rounding issue that can make a transaction fail:\n                 * https://github.com/balancer/balancer-v2-monorepo/issues/2541\n                 * which is an extra reason why this field is empty.\n                 */\n                new uint256[](tokens.length),\n                userData,\n                false\n            );\n\n        balancerVault.exitPool(\n            balancerPoolId,\n            address(this),\n            // TODO: this is incorrect and should be altered when/if we intend to support\n            // pools that deal with native ETH\n            payable(address(this)),\n            request\n        );\n\n        // STEP 5 - Unswap balancer pool assets to vault collateral assets and sent to the vault.\n\n        // For each of the specified assets\n        for (uint256 i = 0; i < _assets.length; ++i) {\n            // Unwrap assets like wstETH and sfrxETH to rebasing assets stETH and frxETH\n            uint256 assetAmount = 0;\n            if (wrappedAssetAmounts[i] > 0) {\n                assetAmount = unwrapPoolAsset(\n                    _assets[i],\n                    wrappedAssetAmounts[i]\n                );\n            }\n\n            // Transfer the vault collateral assets to the recipient, which is typically the vault\n            if (_amounts[i] > 0) {\n                IERC20(_assets[i]).safeTransfer(_recipient, _amounts[i]);\n\n                emit Withdrawal(_assets[i], platformAddress, _amounts[i]);\n            }\n        }\n    }\n\n    /**\n     * @notice Withdraws all supported Vault collateral assets from the Balancer pool\n     * and send to the OToken's Vault.\n     *\n     * Is only executable by the OToken's Vault or the Governor.\n     */\n    function withdrawAll() external override onlyVaultOrGovernor nonReentrant {\n        // STEP 1 - Withdraw all Balancer Pool Tokens (BPT) from Aura to this strategy contract\n\n        _lpWithdrawAll();\n\n        // STEP 2 - Calculate the minumum amount of pool assets to accept for the BPTs\n\n        // Get the BPTs withdrawn from Aura plus any that were already in this strategy contract\n        uint256 BPTtoWithdraw = IERC20(platformAddress).balanceOf(\n            address(this)\n        );\n\n        // Get the balancer pool assets and their total balances\n        (IERC20[] memory tokens, uint256[] memory balances, ) = balancerVault\n            .getPoolTokens(balancerPoolId);\n\n        // the strategy's share of the pool assets\n        uint256 strategyShare = BPTtoWithdraw.divPrecisely(\n            IERC20(platformAddress).totalSupply()\n        );\n\n        uint256[] memory minAmountsOut = new uint256[](tokens.length);\n        address[] memory poolAssets = new address[](tokens.length);\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            poolAssets[i] = address(tokens[i]);\n            minAmountsOut[i] = balances[i]\n                .mulTruncate(strategyShare)\n                .mulTruncate(1e18 - maxWithdrawalSlippage);\n        }\n\n        // STEP 3 - Withdraw the Balancer pool assets from the pool\n\n        /* Proportional exit: EXACT_BPT_IN_FOR_TOKENS_OUT:\n         * User sends a precise quantity of BPT, and receives an estimated but unknown\n         * (computed at run time) quantity of a single token\n         *\n         * ['uint256', 'uint256']\n         * [EXACT_BPT_IN_FOR_TOKENS_OUT, bptAmountIn]\n         */\n        bytes memory userData = abi.encode(\n            IBalancerVault.WeightedPoolExitKind.EXACT_BPT_IN_FOR_TOKENS_OUT,\n            BPTtoWithdraw\n        );\n\n        IBalancerVault.ExitPoolRequest memory request = IBalancerVault\n            .ExitPoolRequest(poolAssets, minAmountsOut, userData, false);\n\n        balancerVault.exitPool(\n            balancerPoolId,\n            address(this),\n            // TODO: this is incorrect and should be altered when/if we intend to support\n            // pools that deal with native ETH\n            payable(address(this)),\n            request\n        );\n\n        // STEP 4 - Convert the balancer pool assets to the vault collateral assets and send to the vault\n\n        // For each of the Balancer pool assets\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            address poolAsset = address(tokens[i]);\n            // Convert the balancer pool asset to the vault collateral asset\n            address asset = fromPoolAsset(poolAsset);\n            // Get the balancer pool assets withdraw from the pool plus any that were already in this strategy contract\n            uint256 poolAssetAmount = IERC20(poolAsset).balanceOf(\n                address(this)\n            );\n\n            // Unwrap assets like wstETH and sfrxETH to rebasing assets stETH and frxETH\n            uint256 assetAmount = 0;\n            if (poolAssetAmount > 0) {\n                assetAmount = unwrapPoolAsset(asset, poolAssetAmount);\n            }\n\n            // Transfer the vault collateral assets to the vault\n            if (assetAmount > 0) {\n                IERC20(asset).safeTransfer(vaultAddress, assetAmount);\n                emit Withdrawal(asset, platformAddress, assetAmount);\n            }\n        }\n    }\n\n    /**\n     * @notice Approves the Balancer pool to transfer all supported\n     * assets from this strategy.\n     * Also approve any suppered assets that are wrapped in the Balancer pool\n     * like stETH and frxETH, to be transferred from this strategy to their\n     * respective wrapper contracts. eg wstETH and sfrxETH.\n     *\n     * Is only executable by the Governor.\n     */\n    function safeApproveAllTokens()\n        external\n        override\n        onlyGovernor\n        nonReentrant\n    {\n        uint256 assetCount = assetsMapped.length;\n        for (uint256 i = 0; i < assetCount; ++i) {\n            _approveAsset(assetsMapped[i]);\n        }\n        _approveBase();\n    }\n\n    // solhint-disable-next-line no-unused-vars\n    function _abstractSetPToken(address _asset, address) internal override {\n        address poolAsset = toPoolAsset(_asset);\n        if (_asset == stETH) {\n            // slither-disable-next-line unused-return\n            IERC20(stETH).approve(wstETH, 1e50);\n        } else if (_asset == frxETH) {\n            // slither-disable-next-line unused-return\n            IERC20(frxETH).approve(sfrxETH, 1e50);\n        }\n        _approveAsset(poolAsset);\n    }\n\n    /**\n     * @dev Approves the Balancer Vault to transfer an asset from\n     * this strategy. The assets could be a Vault collateral asset\n     * like WETH or rETH; or a Balancer pool asset that wraps the vault asset\n     * like wstETH or sfrxETH.\n     */\n    function _approveAsset(address _asset) internal {\n        IERC20 asset = IERC20(_asset);\n        // slither-disable-next-line unused-return\n        asset.approve(address(balancerVault), type(uint256).max);\n    }\n\n    /**\n     * @notice Returns the rate supplied by the Balancer configured rate\n     * provider. Rate is used to normalize the token to common underlying\n     * pool denominator. (ETH for ETH Liquid staking derivatives)\n     *\n     * @param _asset Address of the Balancer pool asset\n     * @return rate of the corresponding asset\n     */\n    function getRateProviderRate(address _asset)\n        internal\n        view\n        override\n        returns (uint256)\n    {\n        IMetaStablePool pool = IMetaStablePool(platformAddress);\n        IRateProvider[] memory providers = pool.getRateProviders();\n        (IERC20[] memory tokens, , ) = balancerVault.getPoolTokens(\n            balancerPoolId\n        );\n\n        uint256 providersLength = providers.length;\n        for (uint256 i = 0; i < providersLength; ++i) {\n            // _assets and corresponding rate providers are all in the same order\n            if (address(tokens[i]) == _asset) {\n                // rate provider doesn't exist, defaults to 1e18\n                if (address(providers[i]) == address(0)) {\n                    return 1e18;\n                }\n                return providers[i].getRate();\n            }\n        }\n\n        // should never happen\n        assert(false);\n    }\n}"
    },
    {
      "filename": "contracts/contracts/strategies/balancer/BaseBalancerStrategy.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title OETH Base Balancer Abstract Strategy\n * @author Origin Protocol Inc\n */\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20, InitializableAbstractStrategy } from \"../../utils/InitializableAbstractStrategy.sol\";\nimport { IBalancerVault } from \"../../interfaces/balancer/IBalancerVault.sol\";\nimport { IRateProvider } from \"../../interfaces/balancer/IRateProvider.sol\";\nimport { VaultReentrancyLib } from \"./VaultReentrancyLib.sol\";\nimport { IOracle } from \"../../interfaces/IOracle.sol\";\nimport { IVault } from \"../../interfaces/IVault.sol\";\nimport { IRETH } from \"../../interfaces/IRETH.sol\";\nimport { IWstETH } from \"../../interfaces/IWstETH.sol\";\nimport { IERC4626 } from \"../../../lib/openzeppelin/interfaces/IERC4626.sol\";\nimport { StableMath } from \"../../utils/StableMath.sol\";\n\nabstract contract BaseBalancerStrategy is InitializableAbstractStrategy {\n    using SafeERC20 for IERC20;\n    using StableMath for uint256;\n\n    address public immutable rETH;\n    address public immutable stETH;\n    address public immutable wstETH;\n    address public immutable frxETH;\n    address public immutable sfrxETH;\n\n    /// @notice Address of the Balancer vault\n    IBalancerVault public immutable balancerVault;\n    /// @notice Balancer pool identifier\n    bytes32 public immutable balancerPoolId;\n\n    // Max withdrawal slippage denominated in 1e18 (1e18 == 100%)\n    uint256 public maxWithdrawalSlippage;\n    // Max deposit slippage denominated in 1e18 (1e18 == 100%)\n    uint256 public maxDepositSlippage;\n\n    int256[48] private __reserved;\n\n    struct BaseBalancerConfig {\n        address rEthAddress; // Address of the rETH token\n        address stEthAddress; // Address of the stETH token\n        address wstEthAddress; // Address of the wstETH token\n        address frxEthAddress; // Address of the frxEth token\n        address sfrxEthAddress; // Address of the sfrxEth token\n        address balancerVaultAddress; // Address of the Balancer vault\n        bytes32 balancerPoolId; // Balancer pool identifier\n    }\n\n    event MaxWithdrawalSlippageUpdated(\n        uint256 _prevMaxSlippagePercentage,\n        uint256 _newMaxSlippagePercentage\n    );\n    event MaxDepositSlippageUpdated(\n        uint256 _prevMaxSlippagePercentage,\n        uint256 _newMaxSlippagePercentage\n    );\n\n    /**\n     * @dev Ensure we are not in a Vault context when this function is called, by attempting a no-op internal\n     * balance operation. If we are already in a Vault transaction (e.g., a swap, join, or exit), the Vault's\n     * reentrancy protection will cause this function to revert.\n     *\n     * Use this modifier with any function that can cause a state change in a pool and is either public itself,\n     * or called by a public function *outside* a Vault operation (e.g., join, exit, or swap).\n     *\n     * This is to protect against Balancer's read-only re-entrancy vulnerability:\n     * https://www.notion.so/originprotocol/Balancer-read-only-reentrancy-c686e72c82414ef18fa34312bb02e11b\n     */\n    modifier whenNotInBalancerVaultContext() {\n        VaultReentrancyLib.ensureNotInVaultContext(balancerVault);\n        _;\n    }\n\n    constructor(BaseBalancerConfig memory _balancerConfig) {\n        rETH = _balancerConfig.rEthAddress;\n        stETH = _balancerConfig.stEthAddress;\n        wstETH = _balancerConfig.wstEthAddress;\n        frxETH = _balancerConfig.frxEthAddress;\n        sfrxETH = _balancerConfig.sfrxEthAddress;\n\n        balancerVault = IBalancerVault(_balancerConfig.balancerVaultAddress);\n        balancerPoolId = _balancerConfig.balancerPoolId;\n    }\n\n    /**\n     * Initializer for setting up strategy internal state. This overrides the\n     * InitializableAbstractStrategy initializer as Balancer's strategies don't fit\n     * well within that abstraction.\n     * @param _rewardTokenAddresses Address of BAL & AURA\n     * @param _assets Addresses of supported assets. MUST be passed in the same\n     *                order as returned by coins on the pool contract, i.e.\n     *                WETH, stETH\n     * @param _pTokens Platform Token corresponding addresses\n     */\n    function initialize(\n        address[] calldata _rewardTokenAddresses, // BAL & AURA\n        address[] calldata _assets,\n        address[] calldata _pTokens\n    ) external override onlyGovernor initializer {\n        maxWithdrawalSlippage = 1e15;\n        maxDepositSlippage = 1e15;\n\n        emit MaxWithdrawalSlippageUpdated(0, maxWithdrawalSlippage);\n        emit MaxDepositSlippageUpdated(0, maxDepositSlippage);\n\n        IERC20[] memory poolAssets = getPoolAssets();\n        require(\n            poolAssets.length == _assets.length,\n            \"Pool assets length mismatch\"\n        );\n        for (uint256 i = 0; i < _assets.length; ++i) {\n            (address asset, ) = fromPoolAsset(address(poolAssets[i]), 0);\n            require(_assets[i] == asset, \"Pool assets mismatch\");\n        }\n\n        super._initialize(_rewardTokenAddresses, _assets, _pTokens);\n        _approveBase();\n    }\n\n    /**\n     * @notice Returns bool indicating whether asset is supported by strategy\n     * @param _asset Address of the asset\n     */\n    function supportsAsset(address _asset)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return assetToPToken[_asset] != address(0);\n    }\n\n    /**\n     * @notice Get strategy's share of an assets in the Balancer pool.\n     * This is not denominated in OUSD/ETH value of the assets in the Balancer pool.\n     * @param _asset  Address of the Vault collateral asset\n     * @return amount  the amount of vault collateral assets\n     *\n     * IMPORTANT if this function is overridden it needs to have a whenNotInBalancerVaultContext\n     * modifier on it or it is susceptible to read-only re-entrancy attack\n     *\n     * @dev it is important that this function is not affected by reporting inflated\n     * values of assets in case of any pool manipulation. Such a manipulation could easily\n     * exploit the protocol by:\n     *  - minting OETH\n     *  - tilting Balancer pool to report higher balances of assets\n     *  - rebasing() -> all that extra token balances get distributed to OETH holders\n     *  - tilting pool back\n     *  - redeeming OETH\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        virtual\n        override\n        whenNotInBalancerVaultContext\n        returns (uint256 amount)\n    {\n        uint256 bptBalance = _getBalancerPoolTokens();\n\n        /* To calculate the worth of queried asset:\n         *  - assume that all tokens normalized to their ETH value have an equal split balance\n         *    in the pool when it is balanced\n         *  - multiply the BPT amount with the bpt rate to get the ETH denominated amount\n         *    of strategy's holdings\n         *  - divide that by the number of tokens we support in the pool to get ETH denominated\n         *    amount that is applicable to each supported token in the pool.\n         *\n         *    It would be possible to support only 1 asset in the pool (and be exposed to all\n         *    the assets while holding BPT tokens) and deposit/withdraw/checkBalance using only\n         *    that asset. TBD: changes to other functions still required if we ever decide to\n         *    go with such configuration.\n         */\n        amount = (bptBalance.mulTruncate(\n            IRateProvider(platformAddress).getRate()\n        ) / assetsMapped.length);\n\n        /* If the pool asset is equal to (strategy )_asset it means that a rate\n         * provider for that asset exists and that asset is not necessarily\n         * pegged to a unit (ETH).\n         *\n         * Because this function returns the balance of the asset and is not denominated in\n         * ETH units we need to convert the ETH denominated amount to asset amount.\n         */\n        if (toPoolAsset(_asset) == _asset) {\n            amount = amount.divPrecisely(getRateProviderRate(_asset));\n        }\n    }\n\n    /**\n     * @notice Returns the value of all assets managed by this strategy.\n     * Uses the Balancer pool's rate (virtual price) to convert the strategy's\n     * Balancer Pool Tokens (BPT) to ETH value.\n     * @return value The ETH value\n     *\n     * IMPORTANT if this function is overridden it needs to have a whenNotInBalancerVaultContext\n     * modifier on it or it is susceptible to read-only re-entrancy attack\n     */\n    function checkBalance()\n        external\n        view\n        virtual\n        whenNotInBalancerVaultContext\n        returns (uint256 value)\n    {\n        uint256 bptBalance = _getBalancerPoolTokens();\n\n        // Convert BPT to ETH value\n        value = bptBalance.mulTruncate(\n            IRateProvider(platformAddress).getRate()\n        );\n    }\n\n    /// @notice Balancer Pool Tokens (BPT) in the Balancer pool.\n    function _getBalancerPoolTokens()\n        internal\n        view\n        virtual\n        returns (uint256 balancerPoolTokens)\n    {\n        balancerPoolTokens = IERC20(platformAddress).balanceOf(address(this));\n    }\n\n    /* solhint-disable max-line-length */\n    /**\n     * @notice BPT price is calculated by dividing the pool (sometimes wrapped) market price by the\n     * rateProviderRate of that asset. To get BPT expected we need to multiply that by underlying\n     * asset amount divided by BPT token rate. BPT token rate is similar to Curve's virtual_price\n     * and expresses how much has the price of BPT appreciated in relation to the underlying assets.\n     *\n     * @dev\n     * bptPrice = pool_asset_oracle_price / pool_asset_rate\n     *\n     * Since we only have oracle prices for the unwrapped version of the assets the equation\n     * turns into:\n     *\n     * bptPrice = from_pool_token(asset_amount).amount * oracle_price / pool_asset_rate\n     *\n     * bptExpected = bptPrice(in relation to specified asset) * asset_amount / BPT_token_rate\n     *\n     * and since from_pool_token(asset_amount).amount and pool_asset_rate cancel each-other out\n     * this makes the final equation:\n     *\n     * bptExpected = oracle_price * asset_amount / BPT_token_rate\n     *\n     * more explanation here:\n     * https://www.notion.so/originprotocol/Support-Balancer-OETH-strategy-9becdea132704e588782a919d7d471eb?pvs=4#382834f9815e46a7937f3acca0f637c5\n     */\n    /* solhint-enable max-line-length */\n    function getBPTExpected(address _asset, uint256 _amount)\n        internal\n        view\n        virtual\n        returns (uint256 bptExpected)\n    {\n        address priceProvider = IVault(vaultAddress).priceProvider();\n        uint256 strategyAssetMarketPrice = IOracle(priceProvider).price(_asset);\n        uint256 bptRate = IRateProvider(platformAddress).getRate();\n\n        bptExpected = _amount\n            .mulTruncate(strategyAssetMarketPrice)\n            .divPrecisely(bptRate);\n    }\n\n    function getBPTExpected(address[] memory _assets, uint256[] memory _amounts)\n        internal\n        view\n        virtual\n        returns (uint256 bptExpected)\n    {\n        // Get the oracle from the OETH Vault\n        address priceProvider = IVault(vaultAddress).priceProvider();\n\n        for (uint256 i = 0; i < _assets.length; ++i) {\n            uint256 strategyAssetMarketPrice = IOracle(priceProvider).price(\n                _assets[i]\n            );\n            // convert asset amount to ETH amount\n            bptExpected =\n                bptExpected +\n                _amounts[i].mulTruncate(strategyAssetMarketPrice);\n        }\n\n        uint256 bptRate = IRateProvider(platformAddress).getRate();\n        // Convert ETH amount to BPT amount\n        bptExpected = bptExpected.divPrecisely(bptRate);\n    }\n\n    function _lpDepositAll() internal virtual;\n\n    function _lpWithdraw(uint256 numBPTTokens) internal virtual;\n\n    function _lpWithdrawAll() internal virtual;\n\n    /**\n     * @notice Balancer returns assets and rateProviders for corresponding assets ordered\n     * by numerical order.\n     */\n    function getPoolAssets() internal view returns (IERC20[] memory assets) {\n        (assets, , ) = balancerVault.getPoolTokens(balancerPoolId);\n    }\n\n    /**\n     * @dev If an asset is rebasing the Balancer pools have a wrapped versions of assets\n     * that the strategy supports. This function converts the pool(wrapped) asset\n     * and corresponding amount to strategy asset.\n     */\n    function toPoolAsset(address asset, uint256 amount)\n        internal\n        view\n        returns (address poolAsset, uint256 poolAmount)\n    {\n        if (asset == stETH) {\n            poolAsset = wstETH;\n            if (amount > 0) {\n                poolAmount = IWstETH(wstETH).getWstETHByStETH(amount);\n            }\n        } else if (asset == frxETH) {\n            poolAsset = sfrxETH;\n            if (amount > 0) {\n                poolAmount = IERC4626(sfrxETH).convertToShares(amount);\n            }\n        } else {\n            poolAsset = asset;\n            poolAmount = amount;\n        }\n    }\n\n    /**\n     * @dev Converts a Vault collateral asset to a Balancer pool asset.\n     * stETH becomes wstETH, frxETH becomes sfrxETH and everything else stays the same.\n     * @param asset Address of the Vault collateral asset.\n     * @return Address of the Balancer pool a"
    }
  ]
}