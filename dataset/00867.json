{
  "Title": "M-3: Delegation Limitation in Voting Power Management",
  "Content": "# Issue M-3: Delegation Limitation in Voting Power Management \n\nSource: https://github.com/sherlock-audit/2023-11-convergence-judging/issues/142 \n\n## Found by \nlil.eth, pontifex, ydlee\n## Summary\n\nMgCVG Voting power delegation system is constrained by 2 hard limits, first on the number of tokens delegated to one user (`maxTokenIdsDelegated = 25`) and second on the number of delegatees for one token ( `maxMgDelegatees = 5`). Once this limit is reached for a token, the token owner cannot modify the delegation percentage to an existing delegated user. This inflexibility can prevent efficient and dynamic management of delegated voting power.\n\n## Vulnerability Detail\nObserve these lines : \n```solidity\nfunction delegateMgCvg(uint256 _tokenId, address _to, uint96 _percentage) external onlyTokenOwner(_tokenId) {\n    require(_percentage <= 100, \"INVALID_PERCENTAGE\");\n\n    uint256 _delegateesLength = delegatedMgCvg[_tokenId].length;\n    require(_delegateesLength < maxMgDelegatees, \"TOO_MUCH_DELEGATEES\");\n\n    uint256 tokenIdsDelegated = mgCvgDelegatees[_to].length;\n    require(tokenIdsDelegated < maxTokenIdsDelegated, \"TOO_MUCH_MG_TOKEN_ID_DELEGATED\");\n```\nif either `maxMgDelegatees` or `maxTokenIdsDelegated` are reached,  delegation is no longer possible.\nThe problem is the fact that this function can be either used to delegate or to update percentage of delegation or also to remove a delegation but in cases where we already delegated to a maximum of users (`maxMgDelegatees`) OR the user to who we delegated has reached the maximum number of tokens that can be delegated to him/her (`maxTokenIdsDelegated`), an update or a removal of delegation is no longer possible.\n\n6 scenarios are possible : \n1. `maxTokenIdsDelegated` is set to 5, Alice is the third to delegate her voting power to Bob and choose to delegate 10% to him. Bob gets 2 other people delegating their tokens to him, Alice wants to increase the power delegated to Bob to 50% but she cannot due to Bob reaching `maxTokenIdsDelegated`\n2. `maxTokenIdsDelegated` is set to 25, Alice is the 10th to delegate her voting power to Bob and choose to delegate 10%, DAO decrease `maxTokenIdsDelegated` to 3, Alice wants to increase the power delegated to Bob to 50%, but she cannot due to this\n3. `maxTokenIdsDelegated` is set to 5, Alice is the third to delegate her voting power to Bob and choose to delegate 90%. Bob gets 2 other people delegating their tokens to him, Alice wants to only remove the power delegated to Bob using this function, but she cannot due to this\n4. `maxMgDelegatees` is set to 3, Alice delegates her voting power to Bob,Charly and Donald by 20% each, Alice reaches `maxMgDelegatees` and she cannot update her voting power for any of Bob,Charly or Donald\n5. `maxMgDelegatees` is set to 5, Alice delegates her voting power to Bob,Charly and Donald by 20% each,DAO decreases`maxMgDelegatees` to 3. Alice cannot update or remove her voting power delegated to any of Bob,Charly and Donald\n6. `maxMgDelegatees` is set to 3, Alice delegates her voting power to Bob,Charly and Donald by 20% each, Alice wants to only remove her delegation to Bob but she reached `maxMgDelegatees` so she cannot only remove her delegation to Bob\n\nA function is provided to remove all user to who we delegated but this function cannot be used as a solution to this problem due to 2 things : \n- It's clearly not intended to do an update of voting power percentage by first removing all delegation we did because `delegateMgCvg()` is clearly defined to allow to delegate OR to remove one delegation OR to update percentage of delegation but in some cases it's impossible which is not acceptable\n- if Alice wants to update it's percentage delegated to Bob , she would have to remove all her delegatees and would take the risk that someone is faster than her and delegate to Bob before her, making Bob reaches `maxTokenIdsDelegated` and would render impossible for Alice to re-delegate to Bob\n\n### POC\nYou can add it to test/ut/delegation/balance-delegation.spec.ts : \n```Typescript\nit(\"maxTokenIdsDelegated is reached => Cannot update percentage of delegate\", async function () {\n        (await lockingPositionDelegate.maxTokenIdsDelegated()).should.be.equal(25);\n        await lockingPositionDelegate.connect(treasuryDao).setMaxTokenIdsDelegated(3);\n        (await lockingPositionDelegate.maxTokenIdsDelegated()).should.be.equal(3);\n\n        await lockingPositionDelegate.connect(user1).delegateMgCvg(1, user10, 20);\n        await lockingPositionDelegate.connect(user2).delegateMgCvg(2, user10, 30);\n        await lockingPositionDelegate.connect(user3).delegateMgCvg(3, user10, 30);\n        \n        const txFail = lockingPositionDelegate.connect(user1).delegateMgCvg(1, user10, 40);\n        await expect(txFail).to.be.revertedWith(\"TOO_MUCH_MG_TOKEN_ID_DELEGATED\");\n    });\n    it(\"maxTokenIdsDelegated IS DECREASED => PERCENTAGE UPDATE IS NO LONGER POSSIBLE\", async function () {\n        await lockingPositionDelegate.connect(treasuryDao).setMaxTokenIdsDelegated(25);\n        (await lockingPositionDelegate.maxTokenIdsDelegated()).should.be.equal(25);\n\n        await lockingPositionDelegate.connect(user1).delegateMgCvg(1, user10, 20);\n        await lockingPositionDelegate.connect(user2).delegateMgCvg(2, user10, 30);\n        await lockingPositionDelegate.connect(user3).delegateMgCvg(3, user10, 30);\n\n        await lockingPositionDelegate.connect(treasuryDao).setMaxTokenIdsDelegated(3);\n        (await lockingPositionDelegate.maxTokenIdsDelegated()).should.be.equal(3);        \n\n        const txFail = lockingPositionDelegate.connect(user1).delegateMgCvg(1, user10, 40);\n        await expect(txFail).to.be.revertedWith(\"TOO_MUCH_MG_TOKEN_ID_DELEGATED\");\n        await lockingPositionDelegate.connect(treasuryDao).setMaxTokenIdsDelegated(25);\n        (await lockingPositionDelegate.maxTokenIdsDelegated()).should.be.equal(25);\n    });\n    it(\"maxMgDelegatees : TRY TO UPDATE PERCENTAGE DELEGATED TO A USER IF WE ALREADY REACH maxMgDelegatees\", async function () {\n        await lockingPositionDelegate.connect(treasuryDao).setMaxMgDelegatees(3);\n        (await lockingPositionDelegate.maxMgDelegatees()).should.be.equal(3);\n\n        await lockingPositionDelegate.connect(user1).delegateMgCvg(1, user10, 20);\n        await lockingPositionDelegate.connect(user1).delegateMgCvg(1, user2, 30);\n        await lockingPositionDelegate.connect(user1).delegateMgCvg(1, user3, 30);\n\n        const txFail = lockingPositionDelegate.connect(user1).delegateMgCvg(1, user10, 40);\n        await expect(txFail).to.be.revertedWith(\"TOO_MUCH_DELEGATEES\");\n    });\n    it(\"maxMgDelegatees : maxMgDelegatees IS DECREASED => PERCENTAGE UPDATE IS NO LONGER POSSIBLE\", async function () {\n        await lockingPositionDelegate.connect(treasuryDao).setMaxMgDelegatees(5);\n        (await lockingPositionDelegate.maxMgDelegatees()).should.be.equal(5);\n\n        await lockingPositionDelegate.connect(user1).delegateMgCvg(1, user10, 20);\n        await lockingPositionDelegate.connect(user1).delegateMgCvg(1, user2, 30);\n        await lockingPositionDelegate.connect(user1).delegateMgCvg(1, user3, 10);\n\n        await lockingPositionDelegate.connect(treasuryDao).setMaxMgDelegatees(2);\n        (await lockingPositionDelegate.maxMgDelegatees()).should.be.equal(2);\n\n        const txFail2 = lockingPositionDelegate.connect(user1).delegateMgCvg(1, user2, 50);\n        await expect(txFail2).to.be.revertedWith(\"TOO_MUCH_DELEGATEES\");\n    });\n```\n## Impact\nIn some cases it is impossible to update percentage delegated or to remove only one delegated percentage then forcing users to remove all their voting power delegatations, taking the risk that someone is faster then them to delegate to their old delegated users and reach threshold for delegation, making impossible for them to re-delegate\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-11-convergence/blob/main/sherlock-cvg/contracts/Locking/LockingPositionDelegate.sol#L278\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nSeparate functions for new delegations and updates : Implement logic that differentiates between adding a new delegatee and updating an existing delegation to allow updates to existing delegations even if the maximum number of delegatees is reached\n\n\n\n## Discussion\n\n**shalbe-cvg**\n\nHello,\n\nThanks a lot for your attention.\n\nAfter an in-depth review, we have to consider your issue as Invalid.\nWe have developed a function allowing users to clean their `mgDelegatees` and `veDelegatees`. Therefore there is no need to divide this delegation function into two different ones (add / update).\n\nRegards,\nConvergence Team\n\n**nevillehuang**\n\nHi @0xR3vert @shalbe-cvg @walk-on-me,\n\nCould point me to the existing function you are pointing to that is present during the time of the audit? \n\n**shalbe-cvg**\n\n> Hi @0xR3vert @shalbe-cvg @walk-on-me,\n> \n> Could point me to the existing function you are pointing to that is present during the time of the audit?\n\nHello, this is the function `cleanDelegatees` inside LockingPositionDelegate contract\n\n**nevillehuang**\n\nAgree with sponsor, since `cleanDelegatees()` and `removeTokenIdDelegated()` [here](https://github.com/sherlock-audit/2023-11-convergence/blob/main/sherlock-cvg/contracts/Locking/LockingPositionDelegate.sol#L376-L402) allow removal of delegatees one-by-one, this seems to be a non-issue.\n\n**ChechetkinVV**\n\nEscalate\n\n> Agree with sponsor, since `cleanDelegatees()` and `removeTokenIdDelegated()` [here](https://github.com/sherlock-audit/2023-11-convergence/blob/main/sherlock-cvg/contracts/Locking/LockingPositionDelegate.sol#L376-L402) allow removal of delegatees one-by-one, this seems to be a non-issue.\n\nThe `cleanDelegatees` function referred to by the sponsor allows the owner of the token to completely remove delegation from ALL mgDelegates, but it will not be possible to remove delegation from ONE delegate using this function. This is obvious from the [`_cleanMgDelegatees`](https://github.com/sherlock-audit/2023-11-convergence/blob/e894be3e36614a385cf409dc7e278d5b8f16d6f2/sherlock-cvg/contracts/Locking/LockingPositionDelegate.sol#L445-L460)  function which is called from the [`cleanDelegatees`](https://github.com/sherlock-audit/2023-11-convergence/blob/e894be3e36614a385cf409dc7e278d5b8f16d6f2/sherlock-cvg/contracts/Locking/LockingPositionDelegate.sol#L400) function. \n\nThe only way for the owner to remove delegation from ONE delegate is using the `delegateMgCvg` function. But this becomes impossible if the delegate from whom the owner is trying to remove delegation has reached the maximum number of delegations.\n\nPerhaps recommendations from https://github.com/sherlock-audit/2023-11-convergence-judging/issues/202 and https://github.com/sherlock-audit/2023-11-convergence-judging/issues/206 reports will help to better understand this problem.\n\nThis problem is described in this report and in https://github.com/sherlock-audit/2023-11-convergence-judging/issues/202,  https://github.com/sherlock-audit/2023-11-convergence-judging/issues/206 reports. Other reports describe different problems. They are hardly duplicates of this issue.\n\n**sherlock-admin2**\n\n > Escalate\n> \n> > Agree with sponsor, since `cleanDelegatees()` and `removeTokenIdDelegated()` [here](https://github.com/sherlock-audit/2023-11-convergence/blob/main/sherlock-cvg/contracts/Locking/LockingPositionDelegate.sol#L376-L402) allow removal of delegatees one-by-one, this seems to be a non-issue.\n> \n> The `cleanDelegatees` function referred to by the sponsor allows the owner of the token to completely remove delegation from ALL mgDelegates, but it will not be possible to remove delegation from ONE delegate using this function. This is obvious from the [`_cleanMgDelegatees`](https://github.com/sherlock-audit/2023-11-convergence/blob/e894be3e36614a385cf409dc7e278d5b8f16d6f2/sherlock-cvg/contracts/Locking/LockingPositionDelegate.sol#L445-L460)  function which is called from the [`cleanDelegatees`](https://github.com/sherlock-audit/2023-11-convergence/blob/e894be3e36614a385cf409dc7e278d5b8f16d6f2/sherlock-cvg/contracts/Locking/LockingPositionDelegate.sol#L400) function. \n> \n> The only way for the owner to remove delegation from ONE delegate is using the `delegateMgCvg` function. But this becomes impossible if the delegate from whom the owner is trying to remove delegation has reached the maximum number of delegations.\n> \n> Perhaps recommendations from https://github.com/sherlock-audit/2023-11-convergence-judging/issues/202 and https://github.com/sherlock-audit/2023-11-convergence-judging/issues/206 reports will help to better understand this problem.\n> \n> This problem is described in this report and in https://github.com/sherlock-audit/2023-11-convergence-judging/issues/202,  https://github.com/sherlock-audit/2023-11-convergence-judging/issues/206 reports. Other reports describe different problems. They are hardly duplicates of this issue.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**nevillehuang**\n\n@shalbe-cvg @walk-on-me @0xR3vert @ChechetkinVV \n\nI think I agree with watsons in the sense that it seems not intended to remove all delegations once max delegation number is reached just to adjust voting power or to remove a single delegatee, for both mgCVG and veCVG. \n\nI think what the watsons are mentioning is that this would then open up a scenario of potential front-running for delegatees themselves to permanently always have max delegated mgCVG or veCVG, so it would permanently DoS the original delegator from updating/removing delegatee. \n\n**Czar102**\n\nFrom my understanding, this issue presents an issue of breaking core functionality (despite the contracts working according to the design, core intended functionality is impacted).\n\nI believe this is sufficient to warrant medium severity for the issue.\n\n@nevillehuang which issues should and which shouldn't be duplicated with this one? Do you agree with the escalation?\n\n**nevillehuang**\n\n@Czar102, As I understand, there are two current impacts\n\n1. Cannot clean delegates one by one, but forced to clean all delegates when `maxMgDelegatees` or `maxTokenIdsDelegated`\n2. Frontrunning to force DOS on delegator performing delegation removal from a delegator to invoke the max delegation check \n\nThis is what I think are duplicates:\n\n1. 142 (this issue mentions both impacts), 202, 206\n2. 40, 51, 142 (again this issue mentions both impacts), 169\n\nBoth impact arises from the `maxMgDelegatees`/`maxTokenIdsDelegated` check thats why I originally grouped them all together. While I initially disagreed, on further review I agree with escalation since this is not the intended contract functionality intended by the protocol. For impact 2, based on your previous comments [here](https://github.com/sherlock-audit/2023-11-convergence-judging/issues/165#issuecomment-1884638007), it seems like it is low severity.\n\n**Czar102**\n\nThank you for the summary @nevillehuang. I'm planning to consider all other issues (apart from #142, #202, #206) low, hence they will not be considered duplicates anymore (see [docs](https://docs.sherlock.xyz/audits/judging/judging#ix.-duplication-rules)). The three issues describing a Medium severity impact will be considered duplicates and be rewarded.\n\n**Czar102**\n\nResult:\nMedium\nHas duplicates\n\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [ChechetkinVV](https://github.com/sherlock-audit/2023-11-convergence-judging/issues/142/#issuecomment-1869103996): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/126",
  "Code": [
    {
      "filename": "sherlock-cvg/contracts/Locking/LockingPositionDelegate.sol",
      "content": "// SPDX-License-Identifier: MIT\n/**\n _____\n/  __ \\\n| /  \\/ ___  _ ____   _____ _ __ __ _  ___ _ __   ___ ___\n| |    / _ \\| '_ \\ \\ / / _ \\ '__/ _` |/ _ \\ '_ \\ / __/ _ \\\n| \\__/\\ (_) | | | \\ V /  __/ | | (_| |  __/ | | | (_|  __/\n \\____/\\___/|_| |_|\\_/ \\___|_|  \\__, |\\___|_| |_|\\___\\___|\n                                 __/ |\n                                |___/\n */\npragma solidity ^0.8.0;\n\nimport \"../interfaces/ICvgControlTower.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n/**\n* @title Cvg-Finance - LockingPositionDelegate\n* @notice Manage the lock delegation for 3 types of tokens : VeCvg, YsCvg and MgCvg.\n* @dev VeCvg : Vote for the governance of the protocol (DAO vote on snapshot  and Vote for inflation distribution  via the gauge system.\n*  | MgCvg : Vote for meta-governance of substrate protocols( DAO vote on snapshot ).\n*  | YsCVg : Share of the distribution of treasury rewards.\n*/\ncontract LockingPositionDelegate is Initializable {\n    struct MgCvgDelegatee {\n        address delegatee;\n        uint96 percentage;\n    }\n\n    struct OwnedAndDelegated {\n        uint256[] owneds;\n        uint256[] mgDelegateds;\n        uint256[] veDelegateds;\n    }\n\n    /** @dev Convergence ControlTower. */\n    ICvgControlTower public cvgControlTower;\n    /** @notice Maximum number of delegatees for MGcVg of a locking position. */\n    uint256 public maxMgDelegatees;\n    /** @notice Maximum number of tokenIds delegated for an address. */\n    uint256 public maxTokenIdsDelegated;\n    /** @notice Returns the delegated address of veCvg for a locking position . This address can, on behalf of the holder : vote on the GaugeController , vote on the Convergence Snapshot. */\n    mapping(uint256 => address) public delegatedVeCvg;\n    /** @notice Returns the tokenIds delegating their veCVG to an address. */\n    mapping(address => uint256[]) public veCvgDelegatees;\n    /** @notice Returns the delegated address of ysCvg for a tokenId, this address can claim the rewards from the YsDistributor on behalf of the owner. */\n    mapping(uint256 => address) public delegatedYsCvg;\n    /** @notice Returns the delegated addresses and the percentage of mgCVG for a tokenId. This address can, on behalf of the holder, vote on the Snapshot meta-governance proposal. */\n    mapping(uint256 => MgCvgDelegatee[]) public delegatedMgCvg;\n    /** @notice Returns the tokenIds delegating their mgCvg to an address. */\n    mapping(address => uint256[]) public mgCvgDelegatees;\n    /** @notice Keep track of the token usable by an address. */\n    mapping(address => OwnedAndDelegated) internal tokenOwnedAndDelegated;\n\n    event DelegateVeCvg(uint256 indexed tokenId, address to);\n    event DelegateShare(uint256 indexed tokenId, address delegatee);\n    event DelegateMetagovernance(uint256 indexed tokenId, address indexed to, uint256 percentage);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(ICvgControlTower _cvgControlTower) external initializer {\n        cvgControlTower = _cvgControlTower;\n        maxMgDelegatees = 5;\n        maxTokenIdsDelegated = 25;\n    }\n\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\n                        MODIFIERS\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\n\n    modifier onlyTokenOwner(uint256 tokenId) {\n        require(msg.sender == cvgControlTower.lockingPositionManager().ownerOf(tokenId), \"TOKEN_NOT_OWNED\");\n        _;\n    }\n\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\n                        ONLY LOCKING OWNER\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\n    /**\n    * @notice Set the maximum number of delegation that can be set for a token on the MetaGovernance.\n    * @dev this limit is set to avoid oog when calculating or managing the voting power\n    * @param _maxMgDelegatees is the maximum number of mg delegatees for a token.\n    */\n    function setMaxMgDelegatees(uint256 _maxMgDelegatees) external {\n        require(cvgControlTower.lockingPositionManager().owner() == msg.sender, \"NOT_OWNER\");\n        maxMgDelegatees = _maxMgDelegatees;\n    }\n\n    /**\n    * @notice Set the maximum number of tokenIds that can be delegated to an address.\n    * @dev this limit is set to avoid oog when calculating or managing the voting power, and spamming user.\n    * @param _maxTokenIdsDelegated is the maximum number of tokenIds delegated for an address.\n    */\n    function setMaxTokenIdsDelegated(uint256 _maxTokenIdsDelegated) external {\n        require(cvgControlTower.lockingPositionManager().owner() == msg.sender, \"NOT_OWNER\");\n        maxTokenIdsDelegated = _maxTokenIdsDelegated;\n    }\n\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\n                            GETTERS\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\n\n    /**\n    * @notice Obtain the veCvg delegated tokens identifiers for a delegatee.\n    * @param account is the address of the delegatee.\n    */\n    function getVeCvgDelegatees(address account) external view returns (uint256[] memory) {\n        return veCvgDelegatees[account];\n    }\n\n    /**\n    * @notice Obtain the mgCvg delegated token(NFT) for a delegatee.\n    * @param account is the address of the delegatee.\n    */\n    function getMgCvgDelegatees(address account) external view returns (uint256[] memory) {\n        return mgCvgDelegatees[account];\n    }\n\n    /**\n    * @notice  Obtain the delegatee for a token (NFT).\n    * @param _tokenId is the ID of the token (NFT) targeted.\n    */\n    function getDelegatedMgCvg(uint256 _tokenId) external view returns (MgCvgDelegatee[] memory) {\n        return delegatedMgCvg[_tokenId];\n    }\n\n    /**\n    * @notice Obtain all the token containing mgCvg and veCvg (owned and delegated) for an address.\n    * @param _addr is the targeted address\n    */\n    function getTokenOwnedAndDelegated(address _addr) external view returns (OwnedAndDelegated memory) {\n        return tokenOwnedAndDelegated[_addr];\n    }\n\n    /**\n    * @notice Obtain all the token containing mgCvg (owned and delegated) for an address.\n    * @param _addr is the targeted address\n    */\n    function getTokenMgOwnedAndDelegated(address _addr) external view returns (uint256[] memory, uint256[] memory) {\n        return (tokenOwnedAndDelegated[_addr].owneds, tokenOwnedAndDelegated[_addr].mgDelegateds);\n    }\n\n    /**\n    * @notice Obtain all the token containing veCvg (owned and delegated) for an address.\n    * @param _addr is the targeted address\n    */\n    function getTokenVeOwnedAndDelegated(address _addr) external view returns (uint256[] memory, uint256[] memory) {\n        return (tokenOwnedAndDelegated[_addr].owneds, tokenOwnedAndDelegated[_addr].veDelegateds);\n    }\n\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\n                            PUBLICS\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\n    /**\n    * @notice Get the information about a MgCvg delegatee for a token.\n    * @param _tokenId is the ID of the token (NFT) targeted.\n    * @param _to is the address we want to get information from for the token.\n    * @return _toPercentage is the percentage of mgCVG delegated to the address, _totalPercentage is the total percentage of mgCVG delegated for the token, _toIndex is the index of the delegatee in the array of delegatees.\n    */\n    function getMgDelegateeInfoPerTokenAndAddress(\n        uint256 _tokenId,\n        address _to\n    ) public view returns (uint256, uint256, uint256) {\n        MgCvgDelegatee[] memory _delegatees = delegatedMgCvg[_tokenId];\n        uint256 _delegateesLength = _delegatees.length;\n\n        uint256 _totalPercentage;\n        uint256 _toPercentage;\n        uint256 _toIndex = 999;\n        /** @dev Loop through all delegatees to find  _to params.*/\n        for (uint256 i; i < _delegateesLength;) {\n            if (_delegatees[i].delegatee == _to) {\n                _toPercentage = _delegatees[i].percentage;\n                _toIndex = i;\n            }\n\n            _totalPercentage += _delegatees[i].percentage;\n            unchecked {\n                i++;\n            }\n        }\n\n        return (_toPercentage, _totalPercentage, _toIndex);\n    }\n    /**\n    * @notice Get the tokenId index in the array of delegated veCVG tokens for an user.\n    * @dev   Use to find the old delegatee of a token , in order to remove this delegation\n    *       when an update or a clean occurs.\n    * @param _delegatee is the address of the delegatee\n    * @param _tokenId is the ID of the token (NFT) targeted\n    */\n    function getIndexForVeDelegatee(address _delegatee, uint256 _tokenId) public view returns (uint256) {\n        uint256[] memory _tokenIds = veCvgDelegatees[_delegatee];\n        uint256 _length = _tokenIds.length;\n\n        for (uint256 i; i < _length;) {\n            if (_tokenIds[i] == _tokenId) return i;\n            unchecked {\n                ++i;\n            }\n        }\n\n        return 0;\n    }\n\n    /**\n    * @notice Get the tokenId index in the array of delegated mgCVG tokens for an user.\n    * @dev    Use to find the index of delegatee, when an update or a clean occurs.\n    * @param _delegatee is the address of the delegatee.\n    * @param _tokenId is the ID of the token (NFT) targeted.\n    */\n    function getIndexForMgCvgDelegatee(address _delegatee, uint256 _tokenId) public view returns (uint256) {\n        uint256[] memory _tokenIds = mgCvgDelegatees[_delegatee];\n        uint256 _length = _tokenIds.length;\n\n        for (uint256 i; i < _length;) {\n            if (_tokenIds[i] == _tokenId) return i;\n            unchecked {\n                ++i;\n            }\n        }\n\n        return 0;\n    }\n\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\n                            EXTERNALS\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\n    /**\n     *  @notice Delegates ysCVG for a tokenId to another address, this delegatee can claim the TDE rewards on behalf of the owner.\n     *  @dev Only the owner of the Locking position can delegate.\n     *  @param _tokenId is the ID of the token (NFT) targeted.\n     *  @param _to is the address of the delegatee.\n    */\n    function delegateYsCvg(uint256 _tokenId, address _to) external onlyTokenOwner(_tokenId) {\n        delegatedYsCvg[_tokenId] = _to;\n        emit DelegateShare(_tokenId, _to);\n    }\n\n    /**\n    * @notice Delegates veCVG for a tokenId to another address.\n    * @dev Address 0x0 can be used to  remove the delegation, the previous delegatee will be removed.\n    * @param _tokenId is the ID of the token (NFT) targeted.\n    * @param _to is the address of the delegatee.\n    */\n    function delegateVeCvg(uint256 _tokenId, address _to) external onlyTokenOwner(_tokenId) {\n        require(veCvgDelegatees[_to].length < maxTokenIdsDelegated, \"TOO_MUCH_VE_TOKEN_ID_DELEGATED\");\n        /** @dev Find if this tokenId is already delegated to an address. */\n        address previousOwner = delegatedVeCvg[_tokenId];\n        if (previousOwner != address(0)) {\n            /** @dev If it is  we remove the previous delegation.*/\n            uint256 _toIndex = getIndexForVeDelegatee(previousOwner, _tokenId);\n            uint256 _delegateesLength = veCvgDelegatees[previousOwner].length;\n            /** @dev Removing delegation.*/\n            veCvgDelegatees[previousOwner][_toIndex] = veCvgDelegatees[previousOwner][_delegateesLength - 1];\n            veCvgDelegatees[previousOwner].pop();\n        }\n\n        /** @dev Associate tokenId to a new delegated address.*/\n        delegatedVeCvg[_tokenId] = _to;\n\n        if (_to != address(0)) {\n            /** @dev Add delegation to the new address.*/\n            veCvgDelegatees[_to].push(_tokenId);\n        }\n        emit DelegateVeCvg(_tokenId, _to);\n    }\n\n    /**\n     * @notice Delegates a percentage of the mgCvG for a tokenId to another address (the mgCvg can be delegated to several addresses).\n     * @dev Percentage=0 can be used to remove a delegation.\n     * @param _tokenId is the ID of the token (NFT) to delegate voting power.\n     * @param _to is the address we want to delegate to.\n     * @param _percentage is the percentage we want to delegate to the address.\n     */\n    function delegateMgCvg(uint256 _tokenId, address _to, uint96 _percentage) external onlyTokenOwner(_tokenId) {\n        require(_percentage <= 100, \"INVALID_PERCENTAGE\");\n\n        uint256 _delegateesLength = delegatedMgCvg[_tokenId].length;\n        require(_delegateesLength < maxMgDelegatees, \"TOO_MUCH_DELEGATEES\");\n\n        uint256 tokenIdsDelegated = mgCvgDelegatees[_to].length;\n        require(tokenIdsDelegated < maxTokenIdsDelegated, \"TOO_MUCH_MG_TOKEN_ID_DELEGATED\");\n\n        (uint256 _toPercentage, uint256 _totalPercentage, uint256 _toIndex) = getMgDelegateeInfoPerTokenAndAddress(\n            _tokenId,\n            _to\n        );\n        bool _isUpdate = _toIndex != 999;\n        uint256 _newTotalPercentage = _isUpdate\n            ? (_totalPercentage + _percentage - _toPercentage)\n            : (_totalPercentage + _percentage);\n        require(_newTotalPercentage <= 100, \"TOO_MUCH_PERCENTAGE\");\n\n        require(_isUpdate || _percentage > 0, \"CANNOT_REMOVE_NOT_DELEGATEE\");\n\n        /** @dev Delegating.*/\n        if (_percentage > 0) {\n            MgCvgDelegatee memory delegatee = MgCvgDelegatee({delegatee: _to, percentage: _percentage});\n\n            /** @dev Updating delegatee.*/\n            if (_isUpdate) {\n                delegatedMgCvg[_tokenId][_toIndex] = delegatee;\n            } else {\n                /** @dev Adding new delegatee.*/\n                delegatedMgCvg[_tokenId].push(delegatee);\n                mgCvgDelegatees[_to].push(_tokenId);\n            }\n        } else {\n            /** @dev Removing delegation.*/\n            delegatedMgCvg[_tokenId][_toIndex] = delegatedMgCvg[_tokenId][_delegateesLength - 1];\n            delegatedMgCvg[_tokenId].pop();\n\n            uint256 _tokenIdIndex = getIndexForMgCvgDelegatee(_to, _tokenId);\n            mgCvgDelegatees[_to][_tokenIdIndex] = mgCvgDelegatees[_to][tokenIdsDelegated - 1];\n            mgCvgDelegatees[_to].pop();\n        }\n\n        emit DelegateMetagovernance(_tokenId, _to, _percentage);\n    }\n\n    /**\n    * @notice Allow a user to manage the tokens id (owned and delegated) used to represent their voting power.\n    *   @dev This prevents bad actors who will spam an address by transferring or delegating a lot of VE/MG positions.\n    *          | This will prevent the oog when the voting/metagovernance power is calculated.\n    *  @param _ownedAndDelegatedTokens array of owned/veDelegated/mgDelegated tokenIds allowed\n    */\n    function manageOwnedAndDelegated(OwnedAndDelegated calldata _ownedAndDelegatedTokens) external {\n        /** @dev Clear the struct owneds and delegateds tokenId allowed for this user.*/\n        delete tokenOwnedAndDelegated[msg.sender];\n\n        /** @dev Add new owned tokenIds allowed for this user.*/\n        for (uint256 i; i < _ownedAndDelegatedTokens.owneds.length;) {\n            /** @dev Check if tokenId is owned by the user.*/\n            require(\n                msg.sender == cvgControlTower.lockingPositionManager().ownerOf(_ownedAndDelegatedTokens.owneds[i]),\n                \"TOKEN_NOT_OWNED\"\n            );\n            tokenOwnedAndDelegated[msg.sender].owneds.push(_ownedAndDelegatedTokens.owneds[i]);\n            unchecked {\n                ++i;\n            }\n        }\n        /** @dev Add new mgCvg delegated tokenIds allowed for this user.*/\n        for (uint256 i; i < _ownedAndDelegatedTokens.mgDelegateds.length;) {\n            /** @dev Check if the user is a mgCvg delegatee for this tokenId.*/\n            (, , uint256 _toIndex) = getMgDelegateeInfoPerTokenAndAddress(\n                _ownedAndDelegatedTokens.mgDelegateds[i],\n                msg.sender\n            );\n            require(_toIndex != 999, \"NFT_NOT_MG_DELEGATED\");\n            tokenOwnedAndDelegated[msg.sender].mgDelegateds.push(_ownedAndDelegatedTokens.mgDelegateds[i]);\n            unchecked {\n                ++i;\n            }\n        }\n        /** @dev Add new veCvg delegated tokenIds allowed for this user.*/\n        for (uint256 i; i < _ownedAndDelegatedTokens.veDelegateds.length;) {\n            /** @dev Check if the user is the veCvg delegatee for this tokenId.*/\n            require(msg.sender == delegatedVeCvg[_ownedAndDelegatedTokens.veDelegateds[i]], \"NFT_NOT_VE_DELEGATED\");\n            tokenOwnedAndDelegated[msg.sender].veDelegateds.push(_ownedAndDelegatedTokens.veDelegateds[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n    * @notice Method for a delegatee to remove a tokenId delegated at his address.\n    * @param _tokenId to remove\n    * @param removeVeDelegated boolean if user wants to remove VeCvgDelegation\n    * @param removeMgDelegated boolean if user wants to remove MgCvgDelegation\n    */\n    function removeTokenIdDelegated(uint256 _tokenId, bool removeVeDelegated, bool removeMgDelegated) external {\n        if (removeVeDelegated) {\n            _cleanVeDelegatee(_tokenId, true);\n        }\n        if (removeMgDelegated) {\n            _removeMgTokenIdDelegated(_tokenId);\n        }\n    }\n    /**\n    *   @notice Method for an owner of tokenId to clean all associated delegatees.\n    *   @param _tokenId to remove\n    *   @param cleanMgDelegatees boolean if user wants to clean all MgCvgDelegatees\n    *   @param cleanVeDelegatees boolean if user wants to clean all VeCvgDelegatees\n    */\n\n    function cleanDelegatees(\n        uint256 _tokenId,\n        bool cleanVeDelegatees,\n        bool cleanMgDelegatees\n    ) external onlyTokenOwner(_tokenId) {\n        if (cleanVeDelegatees) {\n            _cleanVeDelegatee(_tokenId, false);\n        }\n        if (cleanMgDelegatees) {\n            _cleanMgDelegatees(_tokenId);\n        }\n    }\n\n    /**\n    * @notice when a lock position is minted, this method can  automatically add this token take into account for Snapshot.\n    * @dev can only be called by lockingPositionService\n    * @param _tokenId to remove\n    */\n    function addTokenAtMint(uint256 _tokenId, address minter) external {\n        require(address(cvgControlTower.lockingPositionService()) == msg.sender, \"NOT_LOCKING_SERVICE\");\n        tokenOwnedAndDelegated[minter].owneds.push(_tokenId);\n    }\n\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\n                            INTERNALS\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\n    /*\n    * @dev Clean the veCvg delegation  for the tokenId.\n    * @param _tokenId is the ID of the token (NFT) targeted\n    * @param isRemoveByDelegatee is a boolean to check if the function is called by the delegatee\n    */\n    function _cleanVeDelegatee(uint256 _tokenId, bool isRemoveByDelegatee) internal {\n        address previousOwner = delegatedVeCvg[_tokenId];\n        if (isRemoveByDelegatee) {\n            require(msg.sender == previousOwner, \"NOT_VE_DELEGATEE\");\n        }\n        /** @dev Find index for the previous owner.*/\n        uint256 _toIndex = getIndexForVeDelegatee(previousOwner, _tokenId);\n        /** @dev Get length of delegatees.*/\n        uint256 _delegateesLength = veCvgDelegatees[previousOwner].length;\n        /** @dev Removing delegation.*/\n        veCvgDelegatees[previousOwner][_toIndex] = veCvgDelegatees[previousOwner][_delegateesLength - 1];\n        veCvgDelegatees[previousOwner].pop();\n\n        /** @dev Set zero address for delegatee of this tokenId.*/\n        delegatedVeCvg[_tokenId] = address(0);\n\n        emit DelegateVeCvg(_tokenId, address(0));\n    }\n\n    /**\n    *  @notice Clean the mgCvg delegation for the tokenId call by the delegatee.\n    *  @param _tokenId is the ID of the token (NFT) targeted.\n    */\n    function _cleanMgDelegatees(uint256 _tokenId) internal {\n        MgCvgDelegatee[] memory mgCvgDelegatee = delegatedMgCvg[_tokenId];\n        for (uint256 i; i < mgCvgDelegatee.length;) {\n            address _to = mgCvgDelegatee[i].delegatee;\n            uint256 _tokenIdIndex = getIndexForMgCvgDelegatee(_to, _tokenId);\n            mgCvgDelegatees[_to][_tokenIdIndex] = mgCvgDelegatees[_to][mgCvgDelegatees[_to].length - 1];\n            mgCvgDelegatees[_to].pop();\n\n            emit DelegateMetagovernance(_tokenId, _to, 0);\n\n            unchecked {\n                ++i;\n            }\n        }\n        delete delegatedMgCvg[_tokenId];\n    }\n\n    /**\n    * @dev Clean the mgCvg delegation for the tokenId call by the delegatee.\n    * @param _tokenId is the ID of the token (NFT) targeted\n    */\n    function _removeMgTokenIdDelegated(uint256 _tokenId) internal {\n        (, , uint256 _toIndex) = getMgDelegateeInfoPerTokenAndAddress(_tokenId, msg.sender);\n        /** @dev Check if msg.sender is the delegatee.*/\n        require(_toIndex != 999, \"NOT_MG_DELEGATEE\");\n        uint256 _delegateesLength = delegatedMgCvg[_tokenId].length;\n\n        /** @dev Removing delegation.*/\n        delegatedMgCvg[_tokenId][_toIndex] = delegatedMgCvg[_tokenId][_delegateesLength - 1];\n        delegatedMgCvg[_tokenId].pop();\n\n        uint256 _tokenIdIndex = getIndexForMgCvgDelegatee(msg.sender, _tokenId);\n        mgCvgDelegatees[msg.sender][_tokenIdIndex] = mgCvgDelegatees[msg.sender][\n            mgCvgDelegatees[msg.sender].length - 1\n            ];\n        mgCvgDelegatees[msg.sender].pop();\n\n        emit DelegateMetagovernance(_tokenId, address(0), 0);\n    }\n}"
    },
    {
      "filename": "sherlock-cvg/contracts/Locking/LockingPositionDelegate.sol",
      "content": "// SPDX-License-Identifier: MIT\n/**\n _____\n/  __ \\\n| /  \\/ ___  _ ____   _____ _ __ __ _  ___ _ __   ___ ___\n| |    / _ \\| '_ \\ \\ / / _ \\ '__/ _` |/ _ \\ '_ \\ / __/ _ \\\n| \\__/\\ (_) | | | \\ V /  __/ | | (_| |  __/ | | | (_|  __/\n \\____/\\___/|_| |_|\\_/ \\___|_|  \\__, |\\___|_| |_|\\___\\___|\n                                 __/ |\n                                |___/\n */\npragma solidity ^0.8.0;\n\nimport \"../interfaces/ICvgControlTower.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n/**\n* @title Cvg-Finance - LockingPositionDelegate\n* @notice Manage the lock delegation for 3 types of tokens : VeCvg, YsCvg and MgCvg.\n* @dev VeCvg : Vote for the governance of the protocol (DAO vote on snapshot  and Vote for inflation distribution  via the gauge system.\n*  | MgCvg : Vote for meta-governance of substrate protocols( DAO vote on snapshot ).\n*  | YsCVg : Share of the distribution of treasury rewards.\n*/\ncontract LockingPositionDelegate is Initializable {\n    struct MgCvgDelegatee {\n        address delegatee;\n        uint96 percentage;\n    }\n\n    struct OwnedAndDelegated {\n        uint256[] owneds;\n        uint256[] mgDelegateds;\n        uint256[] veDelegateds;\n    }\n\n    /** @dev Convergence ControlTower. */\n    ICvgControlTower public cvgControlTower;\n    /** @notice Maximum number of delegatees for MGcVg of a locking position. */\n    uint256 public maxMgDelegatees;\n    /** @notice Maximum number of tokenIds delegated for an address. */\n    uint256 public maxTokenIdsDelegated;\n    /** @notice Returns the delegated address of veCvg for a locking position . This address can, on behalf of the holder : vote on the GaugeController , vote on the Convergence Snapshot. */\n    mapping(uint256 => address) public delegatedVeCvg;\n    /** @notice Returns the tokenIds delegating their veCVG to an address. */\n    mapping(address => uint256[]) public veCvgDelegatees;\n    /** @notice Returns the delegated address of ysCvg for a tokenId, this address can claim the rewards from the YsDistributor on behalf of the owner. */\n    mapping(uint256 => address) public delegatedYsCvg;\n    /** @notice Returns the delegated addresses and the percentage of mgCVG for a tokenId. This address can, on behalf of the holder, vote on the Snapshot meta-governance proposal. */\n    mapping(uint256 => MgCvgDelegatee[]) public delegatedMgCvg;\n    /** @notice Returns the tokenIds delegating their mgCvg to an address. */\n    mapping(address => uint256[]) public mgCvgDelegatees;\n    /** @notice Keep track of the token usable by an address. */\n    mapping(address => OwnedAndDelegated) internal tokenOwnedAndDelegated;\n\n    event DelegateVeCvg(uint256 indexed tokenId, address to);\n    event DelegateShare(uint256 indexed tokenId, address delegatee);\n    event DelegateMetagovernance(uint256 indexed tokenId, address indexed to, uint256 percentage);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(ICvgControlTower _cvgControlTower) external initializer {\n        cvgControlTower = _cvgControlTower;\n        maxMgDelegatees = 5;\n        maxTokenIdsDelegated = 25;\n    }\n\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\n                        MODIFIERS\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\n\n    modifier onlyTokenOwner(uint256 tokenId) {\n        require(msg.sender == cvgControlTower.lockingPositionManager().ownerOf(tokenId), \"TOKEN_NOT_OWNED\");\n        _;\n    }\n\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\n                        ONLY LOCKING OWNER\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\n    /**\n    * @notice Set the maximum number of delegation that can be set for a token on the MetaGovernance.\n    * @dev this limit is set to avoid oog when calculating or managing the voting power\n    * @param _maxMgDelegatees is the maximum number of mg delegatees for a token.\n    */\n    function setMaxMgDelegatees(uint256 _maxMgDelegatees) external {\n        require(cvgControlTower.lockingPositionManager().owner() == msg.sender, \"NOT_OWNER\");\n        maxMgDelegatees = _maxMgDelegatees;\n    }\n\n    /**\n    * @notice Set the maximum number of tokenIds that can be delegated to an address.\n    * @dev this limit is set to avoid oog when calculating or managing the voting power, and spamming user.\n    * @param _maxTokenIdsDelegated is the maximum number of tokenIds delegated for an address.\n    */\n    function setMaxTokenIdsDelegated(uint256 _maxTokenIdsDelegated) external {\n        require(cvgControlTower.lockingPositionManager().owner() == msg.sender, \"NOT_OWNER\");\n        maxTokenIdsDelegated = _maxTokenIdsDelegated;\n    }\n\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\n                            GETTERS\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\n\n    /**\n    * @notice Obtain the veCvg delegated tokens identifiers for a delegatee.\n    * @param account is the address of the delegatee.\n    */\n    function getVeCvgDelegatees(address account) external view returns (uint256[] memory) {\n        return veCvgDelegatees[account];\n    }\n\n    /**\n    * @notice Obtain the mgCvg delegated token(NFT) for a delegatee.\n    * @param account is the address of the delegatee.\n    */\n    function getMgCvgDelegatees(address account) external view returns (uint256[] memory) {\n        return mgCvgDelegatees[account];\n    }\n\n    /**\n    * @notice  Obtain the delegatee for a token (NFT).\n    * @param _tokenId is the ID of the token (NFT) targeted.\n    */\n    function getDelegatedMgCvg(uint256 _tokenId) external view returns (MgCvgDelegatee[] memory) {\n        return delegatedMgCvg[_tokenId];\n    }\n\n    /**\n    * @notice Obtain all the token containing mgCvg and veCvg (owned and delegated) for an address.\n    * @param _addr is the targeted address\n    */\n    function getTokenOwnedAndDelegated(address _addr) external view returns (OwnedAndDelegated memory) {\n        return tokenOwnedAndDelegated[_addr];\n    }\n\n    /**\n    * @notice Obtain all the token containing mgCvg (owned and delegated) for an address.\n    * @param _addr is the targeted address\n    */\n    function getTokenMgOwnedAndDelegated(address _addr) external view returns (uint256[] memory, uint256[] memory) {\n        return (tokenOwnedAndDelegated[_addr].owneds, tokenOwnedAndDelegated[_addr].mgDelegateds);\n    }\n\n    /**\n    * @notice Obtain all the token containing veCvg (owned and delegated) for an address.\n    * @param _addr is the targeted address\n    */\n    function getTokenVeOwnedAndDelegated(address _addr) external view returns (uint256[] memory, uint256[] memory) {\n        return (tokenOwnedAndDelegated[_addr].owneds, tokenOwnedAndDelegated[_addr].veDelegateds);\n    }\n\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\n                            PUBLICS\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\n    /**\n    * @notice Get the information about a MgCvg delegatee for a token.\n    * @param _tokenId is the ID of the token (NFT) targeted.\n    * @param _to is the address we want to get information from for the token.\n    * @return _toPercentage is the percentage of mgCVG delegated to the address, _totalPercentage is the total percentage of mgCVG delegated for the token, _toIndex is the index of the delegatee in the array of delegatees.\n    */\n    function getMgDelegateeInfoPerTokenAndAddress(\n        uint256 _tokenId,\n        address _to\n    ) public view returns (uint256, uint256, uint256) {\n        MgCvgDelegatee[] memory _delegatees = delegatedMgCvg[_tokenId];\n        uint256 _delegateesLength = _delegatees.length;\n\n        uint256 _totalPercentage;\n        uint256 _toPercentage;\n        uint256 _toIndex = 999;\n        /** @dev Loop through all delegatees to find  _to params.*/\n        for (uint256 i; i < _delegateesLength;) {\n            if (_delegatees[i].delegatee == _to) {\n                _toPercentage = _delegatees[i].percentage;\n                _toIndex = i;\n            }\n\n            _totalPercentage += _delegatees[i].percentage;\n            unchecked {\n                i++;\n            }\n        }\n\n        return (_toPercentage, _totalPercentage, _toIndex);\n    }\n    /**\n    * @notice Get the tokenId index in the array of delegated veCVG tokens for an user.\n    * @dev   Use to find the old delegatee of a token , in order to remove this delegation\n    *       when an update or a clean occurs.\n    * @param _delegatee is the address of the delegatee\n    * @param _tokenId is the ID of the token (NFT) targeted\n    */\n    function getIndexForVeDelegatee(address _delegatee, uint256 _tokenId) public view returns (uint256) {\n        uint256[] memory _tokenIds = veCvgDelegatees[_delegatee];\n        uint256 _length = _tokenIds.length;\n\n        for (uint256 i; i < _length;) {\n            if (_tokenIds[i] == _tokenId) return i;\n            unchecked {\n                ++i;\n            }\n        }\n\n        return 0;\n    }\n\n    /**\n    * @notice Get the tokenId index in the array of delegated mgCVG tokens for an user.\n    * @dev    Use to find the index of delegatee, when an update or a clean occurs.\n    * @param _delegatee is the address of the delegatee.\n    * @param _tokenId is the ID of the token (NFT) targeted.\n    */\n    function getIndexForMgCvgDelegatee(address _delegatee, uint256 _tokenId) public view returns (uint256) {\n        uint256[] memory _tokenIds = mgCvgDelegatees[_delegatee];\n        uint256 _length = _tokenIds.length;\n\n        for (uint256 i; i < _length;) {\n            if (_tokenIds[i] == _tokenId) return i;\n            unchecked {\n                ++i;\n            }\n        }\n\n        return 0;\n    }\n\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\n                            EXTERNALS\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\n    /**\n     *  @notice Delegates ysCVG for a tokenId to another address, this delegatee can claim the TDE rewards on behalf of the owner.\n     *  @dev Only the owner of the Locking position can delegate.\n     *  @param _tokenId is the ID of the token (NFT) targeted.\n     *  @param _to is the address of the delegatee.\n    */\n    function delegateYsCvg(uint256 _tokenId, address _to) external onlyTokenOwner(_tokenId) {\n        delegatedYsCvg[_tokenId] = _to;\n        emit DelegateShare(_tokenId, _to);\n    }\n\n    /**\n    * @notice Delegates veCVG for a tokenId to another address.\n    * @dev Address 0x0 can be used to  remove the delegation, the previous delegatee will be removed.\n    * @param _tokenId is the ID of the token (NFT) targeted.\n    * @param _to is the address of the delegatee.\n    */\n    function delegateVeCvg(uint256 _tokenId, address _to) external onlyTokenOwner(_tokenId) {\n        require(veCvgDelegatees[_to].length < maxTokenIdsDelegated, \"TOO_MUCH_VE_TOKEN_ID_DELEGATED\");\n        /** @dev Find if this tokenId is already delegated to an address. */\n        address previousOwner = delegatedVeCvg[_tokenId];\n        if (previousOwner != address(0)) {\n            /** @dev If it is  we remove the previous delegation.*/\n            uint256 _toIndex = getIndexForVeDelegatee(previousOwner, _tokenId);\n            uint256 _delegateesLength = veCvgDelegatee"
    }
  ]
}