{
  "Title": "Rocketpool CLI - Lax data validation and output sanitation ✓ Addressed",
  "Content": "\n\n#### Resolution\n\n\n\nAddressed with [v1.0.0-rc1](https://github.com/rocket-pool/rocketpool-go/releases/tag/v1.0.0-rc1) by sanitizing non-printables from strings stored in the smart contract.\n\n\nThis effectively mitigates terminal-based control character injection attacks. However, might still be used to inject context-sensitive information that may be consumed by different protocols/presentation layers (web, terminal by displaying falsified information next to fields).\n\n\nE-mail and timezone format validation was introduced with <https://github.com/rocket-pool/rocketpool-go/blob/c8738633ab973503b79c7dee5c2f78d7e44e48ae/dao/trustednode/proposals.go#L22> and [rocket-pool/[email protected]`6e72501`](https://github.com/rocket-pool/rocketpool-go/commit/6e725010c976257eebf41ac21e32c51c6ecbe2b3).\n\n\nIt is recommended to further tighten the checks on untrusted information enforcing an expected format of information and reject to interact with nodes/data that does not comply with the expected formats (e.g. email being in an email format, timezone information is a valid timezone, and does not contain extra information, …).\n\n\n\n\n#### Description\n\n\n`ValidateTimezoneLocation` and `ValidateDAOMemberEmail` are only used to validate user input from the command line. Timezone location information and member email addresses are stored in the smart contract’s string storage, e.g., using the `setTimezoneLocation` function of the `RocketNodeManager` contract. This function only validates that a minimum length of 4 has been given.\n\n\nThrough direct interaction with the contract, an attacker can submit arbitrary information, which is not validated on the CLI’s side. With additional integrations of the Rocketpool smart contracts, the timezone location field may be used by an attacker to inject malicious code (e.g., for cross-site scripting attacks) or injecting false information (e.g. `Balance: 1000 RPL` or `Status: Trusted`), which is directly displayed on a user-facing application.\n\n\nOn the command line, control characters such as newline characters can be injected to alter how text is presented to the user, effectively exploiting user trust in the official application.\n\n\n#### Examples\n\n\n**rocketpool-go-2.5-Tokenomics/node/node.go:L134-L153**\n\n\n\n```\n    wg.Go(func() error {\n        var err error\n        timezoneLocation, err = GetNodeTimezoneLocation(rp, nodeAddress, opts)\n        return err\n    })\n\n    // Wait for data\n    if err := wg.Wait(); err != nil {\n        return NodeDetails{}, err\n    }\n\n    // Return\n    return NodeDetails{\n        Address: nodeAddress,\n        Exists: exists,\n        WithdrawalAddress: withdrawalAddress,\n        TimezoneLocation: timezoneLocation,\n    }, nil\n\n}\n\n```\n**smartnode-2.5-Tokenomics/rocketpool-cli/odao/members.go:L34-L44**\n\n\n\n```\nfor \\_, member := range members.Members {\n    fmt.Printf(\"--------------------\\n\")\n    fmt.Printf(\"\\n\")\n    fmt.Printf(\"Member ID: %s\\n\", member.ID)\n    fmt.Printf(\"Email address: %s\\n\", member.Email)\n    fmt.Printf(\"Joined at block: %d\\n\", member.JoinedBlock)\n    fmt.Printf(\"Last proposal block: %d\\n\", member.LastProposalBlock)\n    fmt.Printf(\"RPL bond amount: %.6f\\n\", math.RoundDown(eth.WeiToEth(member.RPLBondAmount), 6))\n    fmt.Printf(\"Unbonded minipools: %d\\n\", member.UnbondedValidatorCount)\n    fmt.Printf(\"\\n\")\n}\n\n```\n#### Recommendation\n\n\nValidate user input before storing it on the blockchain. Validate and sanitize stored user tainted data before presenting it. Establish a register of data validation rules (e.g., email format, timezone format, etc.). Reject nodes operating with nodes that do not honor data validation rules.\n\n\nValidate the correct format of variables (e.g., timezone location, email, name, …) on the storage level (if applicable) and the lowest level of the go library to offer developers a strong foundation to build on and mitigate the risk in future integrations. Furthermore, on-chain validation might not be implemented (due to increased gas consumption) should be mentioned in the developer documentation security section as they need to be handled with special caution by consumer applications. Sanitize output before presenting it to avoid control character injections in terminal applications or other presentation technologies (e.g., SQL or HTML).\n\n\nReview all usage of the `fmt` lib (especially `Sprintf` and string handling/concatenating functions). Ensure only sanitized data can reach this sink. Review the logging library and ensure it is hardened against control character injection by encoding non-printables and CR-LF.\n\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "dao/trustednode/proposals.go",
      "content": "package trustednode\n\nimport (\n\t\"fmt\"\n\t\"math/big\"\n\t\"net/mail\"\n\t\"sync\"\n\n\t\"github.com/ethereum/go-ethereum/accounts/abi/bind\"\n\t\"github.com/ethereum/go-ethereum/common\"\n\n\t\"github.com/rocket-pool/rocketpool-go/dao\"\n\t\"github.com/rocket-pool/rocketpool-go/rocketpool\"\n)\n\n// Estimate the gas of ProposeInviteMember\nfunc EstimateProposeInviteMemberGas(rp *rocketpool.RocketPool, message string, newMemberAddress common.Address, newMemberId, newMemberEmail string, opts *bind.TransactOpts) (rocketpool.GasInfo, error) {\n    rocketDAONodeTrustedProposals, err := getRocketDAONodeTrustedProposals(rp)\n    if err != nil {\n        return rocketpool.GasInfo{}, err\n    }\n    emailAddress, err := mail.ParseAddress(newMemberEmail)\n    if err != nil {\n        return rocketpool.GasInfo{}, err \n    }\n    payload, err := rocketDAONodeTrustedProposals.ABI.Pack(\"proposalInvite\", newMemberId, emailAddress.Address, newMemberAddress)\n    if err != nil {\n        return rocketpool.GasInfo{}, fmt.Errorf(\"Could not encode invite member proposal payload: %w\", err)\n    }\n    return EstimateProposalGas(rp, message, payload, opts)\n}\n\n\n// Submit a proposal to invite a new member to the trusted node DAO\nfunc ProposeInviteMember(rp *rocketpool.RocketPool, message string, newMemberAddress common.Address, newMemberId, newMemberEmail string, opts *bind.TransactOpts) (uint64, common.Hash, error) {\n    rocketDAONodeTrustedProposals, err := getRocketDAONodeTrustedProposals(rp)\n    if err != nil {\n        return 0, common.Hash{}, err\n    }\n    emailAddress, err := mail.ParseAddress(newMemberEmail)\n    if err != nil {\n        return 0, common.Hash{}, err \n    }\n    payload, err := rocketDAONodeTrustedProposals.ABI.Pack(\"proposalInvite\", newMemberId, emailAddress.Address, newMemberAddress)\n    if err != nil {\n        return 0, common.Hash{}, fmt.Errorf(\"Could not encode invite member proposal payload: %w\", err)\n    }\n    return SubmitProposal(rp, message, payload, opts)\n}\n\n\n// Estimate the gas of ProposeMemberLeave\nfunc EstimateProposeMemberLeaveGas(rp *rocketpool.RocketPool, message string, memberAddress common.Address, opts *bind.TransactOpts) (rocketpool.GasInfo, error) {\n    rocketDAONodeTrustedProposals, err := getRocketDAONodeTrustedProposals(rp)\n    if err != nil {\n        return rocketpool.GasInfo{}, err\n    }\n    payload, err := rocketDAONodeTrustedProposals.ABI.Pack(\"proposalLeave\", memberAddress)\n    if err != nil {\n        return rocketpool.GasInfo{}, fmt.Errorf(\"Could not encode member leave proposal payload: %w\", err)\n    }\n    return EstimateProposalGas(rp, message, payload, opts)\n}\n\n\n// Submit a proposal for a member to leave the trusted node DAO\nfunc ProposeMemberLeave(rp *rocketpool.RocketPool, message string, memberAddress common.Address, opts *bind.TransactOpts) (uint64, common.Hash, error) {\n    rocketDAONodeTrustedProposals, err := getRocketDAONodeTrustedProposals(rp)\n    if err != nil {\n        return 0, common.Hash{}, err\n    }\n    payload, err := rocketDAONodeTrustedProposals.ABI.Pack(\"proposalLeave\", memberAddress)\n    if err != nil {\n        return 0, common.Hash{}, fmt.Errorf(\"Could not encode member leave proposal payload: %w\", err)\n    }\n    return SubmitProposal(rp, message, payload, opts)\n}\n\n\n// Estimate the gas of ProposeReplaceMember\nfunc EstimateProposeReplaceMemberGas(rp *rocketpool.RocketPool, message string, memberAddress, newMemberAddress common.Address, newMemberId, newMemberEmail string, opts *bind.TransactOpts) (rocketpool.GasInfo, error) {\n    rocketDAONodeTrustedProposals, err := getRocketDAONodeTrustedProposals(rp)\n    if err != nil {\n        return rocketpool.GasInfo{}, err\n    }\n    emailAddress, err := mail.ParseAddress(newMemberEmail)\n    if err != nil {\n        return rocketpool.GasInfo{}, err \n    }\n    payload, err := rocketDAONodeTrustedProposals.ABI.Pack(\"proposalReplace\", memberAddress, newMemberId, emailAddress.Address, newMemberAddress)\n    if err != nil {\n        return rocketpool.GasInfo{}, fmt.Errorf(\"Could not encode replace member proposal payload: %w\", err)\n    }\n    return EstimateProposalGas(rp, message, payload, opts)\n}\n\n\n// Submit a proposal to replace a member in the trusted node DAO\nfunc ProposeReplaceMember(rp *rocketpool.RocketPool, message string, memberAddress, newMemberAddress common.Address, newMemberId, newMemberEmail string, opts *bind.TransactOpts) (uint64, common.Hash, error) {\n    rocketDAONodeTrustedProposals, err := getRocketDAONodeTrustedProposals(rp)\n    if err != nil {\n        return 0, common.Hash{}, err\n    }\n    emailAddress, err := mail.ParseAddress(newMemberEmail)\n    if err != nil {\n        return 0, common.Hash{}, err \n    }\n    payload, err := rocketDAONodeTrustedProposals.ABI.Pack(\"proposalReplace\", memberAddress, newMemberId, emailAddress.Address, newMemberAddress)\n    if err != nil {\n        return 0, common.Hash{}, fmt.Errorf(\"Could not encode replace member proposal payload: %w\", err)\n    }\n    return SubmitProposal(rp, message, payload, opts)\n}\n\n\n// Estimate the gas of ProposeKickMember\nfunc EstimateProposeKickMemberGas(rp *rocketpool.RocketPool, message string, memberAddress common.Address, rplFineAmount *big.Int, opts *bind.TransactOpts) (rocketpool.GasInfo, error) {\n    rocketDAONodeTrustedProposals, err := getRocketDAONodeTrustedProposals(rp)\n    if err != nil {\n        return rocketpool.GasInfo{}, err\n    }\n    payload, err := rocketDAONodeTrustedProposals.ABI.Pack(\"proposalKick\", memberAddress, rplFineAmount)\n    if err != nil {\n        return rocketpool.GasInfo{}, fmt.Errorf(\"Could not encode kick member proposal payload: %w\", err)\n    }\n    return EstimateProposalGas(rp, message, payload, opts)\n}\n\n\n// Submit a proposal to kick a member from the trusted node DAO\nfunc ProposeKickMember(rp *rocketpool.RocketPool, message string, memberAddress common.Address, rplFineAmount *big.Int, opts *bind.TransactOpts) (uint64, common.Hash, error) {\n    rocketDAONodeTrustedProposals, err := getRocketDAONodeTrustedProposals(rp)\n    if err != nil {\n        return 0, common.Hash{}, err\n    }\n    payload, err := rocketDAONodeTrustedProposals.ABI.Pack(\"proposalKick\", memberAddress, rplFineAmount)\n    if err != nil {\n        return 0, common.Hash{}, fmt.Errorf(\"Could not encode kick member proposal payload: %w\", err)\n    }\n    return SubmitProposal(rp, message, payload, opts)\n}\n\n\n// Estimate the gas of ProposeSetBool\nfunc EstimateProposeSetBoolGas(rp *rocketpool.RocketPool, message, contractName, settingPath string, value bool, opts *bind.TransactOpts) (rocketpool.GasInfo, error) {\n    rocketDAONodeTrustedProposals, err := getRocketDAONodeTrustedProposals(rp)\n    if err != nil {\n        return rocketpool.GasInfo{}, err\n    }\n    payload, err := rocketDAONodeTrustedProposals.ABI.Pack(\"proposalSettingBool\", contractName, settingPath, value)\n    if err != nil {\n        return rocketpool.GasInfo{}, fmt.Errorf(\"Could not encode set bool setting proposal payload: %w\", err)\n    }\n    return EstimateProposalGas(rp, message, payload, opts)\n}\n\n\n// Submit a proposal to update a bool trusted node DAO setting\nfunc ProposeSetBool(rp *rocketpool.RocketPool, message, contractName, settingPath string, value bool, opts *bind.TransactOpts) (uint64, common.Hash, error) {\n    rocketDAONodeTrustedProposals, err := getRocketDAONodeTrustedProposals(rp)\n    if err != nil {\n        return 0, common.Hash{}, err\n    }\n    payload, err := rocketDAONodeTrustedProposals.ABI.Pack(\"proposalSettingBool\", contractName, settingPath, value)\n    if err != nil {\n        return 0, common.Hash{}, fmt.Errorf(\"Could not encode set bool setting proposal payload: %w\", err)\n    }\n    return SubmitProposal(rp, message, payload, opts)\n}\n\n\n// Estimate the gas of ProposeSetUint\nfunc EstimateProposeSetUintGas(rp *rocketpool.RocketPool, message, contractName, settingPath string, value *big.Int, opts *bind.TransactOpts) (rocketpool.GasInfo, error) {\n    rocketDAONodeTrustedProposals, err := getRocketDAONodeTrustedProposals(rp)\n    if err != nil {\n        return rocketpool.GasInfo{}, err\n    }\n    payload, err := rocketDAONodeTrustedProposals.ABI.Pack(\"proposalSettingUint\", contractName, settingPath, value)\n    if err != nil {\n        return rocketpool.GasInfo{}, fmt.Errorf(\"Could not encode set uint setting proposal payload: %w\", err)\n    }\n    return EstimateProposalGas(rp, message, payload, opts)\n}\n\n\n// Submit a proposal to update a uint trusted node DAO setting\nfunc ProposeSetUint(rp *rocketpool.RocketPool, message, contractName, settingPath string, value *big.Int, opts *bind.TransactOpts) (uint64, common.Hash, error) {\n    rocketDAONodeTrustedProposals, err := getRocketDAONodeTrustedProposals(rp)\n    if err != nil {\n        return 0, common.Hash{}, err\n    }\n    payload, err := rocketDAONodeTrustedProposals.ABI.Pack(\"proposalSettingUint\", contractName, settingPath, value)\n    if err != nil {\n        return 0, common.Hash{}, fmt.Errorf(\"Could not encode set uint setting proposal payload: %w\", err)\n    }\n    return SubmitProposal(rp, message, payload, opts)\n}\n\n\n// Estimate the gas of ProposeUpgradeContract\nfunc EstimateProposeUpgradeContractGas(rp *rocketpool.RocketPool, message, upgradeType, contractName, contractAbi string, contractAddress common.Address, opts *bind.TransactOpts) (rocketpool.GasInfo, error) {\n    compressedAbi, err := rocketpool.EncodeAbiStr(contractAbi)\n    if err != nil {\n        return rocketpool.GasInfo{}, err\n    }\n    rocketDAONodeTrustedProposals, err := getRocketDAONodeTrustedProposals(rp)\n    if err != nil {\n        return rocketpool.GasInfo{}, err\n    }\n    payload, err := rocketDAONodeTrustedProposals.ABI.Pack(\"proposalUpgrade\", upgradeType, contractName, compressedAbi, contractAddress)\n    if err != nil {\n        return rocketpool.GasInfo{}, fmt.Errorf(\"Could not encode upgrade contract proposal payload: %w\", err)\n    }\n    return EstimateProposalGas(rp, message, payload, opts)\n}\n\n\n// Submit a proposal to upgrade a contract\nfunc ProposeUpgradeContract(rp *rocketpool.RocketPool, message, upgradeType, contractName, contractAbi string, contractAddress common.Address, opts *bind.TransactOpts) (uint64, common.Hash, error) {\n    compressedAbi, err := rocketpool.EncodeAbiStr(contractAbi)\n    if err != nil {\n        return 0, common.Hash{}, err\n    }\n    rocketDAONodeTrustedProposals, err := getRocketDAONodeTrustedProposals(rp)\n    if err != nil {\n        return 0, common.Hash{}, err\n    }\n    payload, err := rocketDAONodeTrustedProposals.ABI.Pack(\"proposalUpgrade\", upgradeType, contractName, compressedAbi, contractAddress)\n    if err != nil {\n        return 0, common.Hash{}, fmt.Errorf(\"Could not encode upgrade contract proposal payload: %w\", err)\n    }\n    return SubmitProposal(rp, message, payload, opts)\n}\n\n\n// Estimate the gas of a proposal submission\nfunc EstimateProposalGas(rp *rocketpool.RocketPool, message string, payload []byte, opts *bind.TransactOpts) (rocketpool.GasInfo, error) {\n    rocketDAONodeTrustedProposals, err := getRocketDAONodeTrustedProposals(rp)\n    if err != nil {\n        return rocketpool.GasInfo{}, err\n    }\n    return rocketDAONodeTrustedProposals.GetTransactionGasInfo(opts, \"propose\", message, payload)\n}\n\n\n// Submit a trusted node DAO proposal\n// Returns the ID of the new proposal\nfunc SubmitProposal(rp *rocketpool.RocketPool, message string, payload []byte, opts *bind.TransactOpts) (uint64, common.Hash, error) {\n    rocketDAONodeTrustedProposals, err := getRocketDAONodeTrustedProposals(rp)\n    if err != nil {\n        return 0, common.Hash{}, err\n    }\n    proposalCount, err := dao.GetProposalCount(rp, nil)\n    if err != nil {\n        return 0, common.Hash{}, err\n    }\n    hash, err := rocketDAONodeTrustedProposals.Transact(opts, \"propose\", message, payload)\n    if err != nil {\n        return 0, common.Hash{}, fmt.Errorf(\"Could not submit trusted node DAO proposal: %w\", err)\n    }\n    return proposalCount + 1, hash, nil\n}\n\n\n// Estimate the gas of CancelProposal\nfunc EstimateCancelProposalGas(rp *rocketpool.RocketPool, proposalId uint64, opts *bind.TransactOpts) (rocketpool.GasInfo, error) {\n    rocketDAONodeTrustedProposals, err := getRocketDAONodeTrustedProposals(rp)\n    if err != nil {\n        return rocketpool.GasInfo{}, err\n    }\n    return rocketDAONodeTrustedProposals.GetTransactionGasInfo(opts, \"cancel\", big.NewInt(int64(proposalId)))\n}\n\n\n// Cancel a submitted proposal\nfunc CancelProposal(rp *rocketpool.RocketPool, proposalId uint64, opts *bind.TransactOpts) (common.Hash, error) {\n    rocketDAONodeTrustedProposals, err := getRocketDAONodeTrustedProposals(rp)\n    if err != nil {\n        return common.Hash{}, err\n    }\n    hash, err := rocketDAONodeTrustedProposals.Transact(opts, \"cancel\", big.NewInt(int64(proposalId)))\n    if err != nil {\n        return common.Hash{}, fmt.Errorf(\"Could not cancel trusted node DAO proposal %d: %w\", proposalId, err)\n    }\n    return hash, nil\n}\n\n\n// Estimate the gas of VoteOnProposal\nfunc EstimateVoteOnProposalGas(rp *rocketpool.RocketPool, proposalId uint64, support bool, opts *bind.TransactOpts) (rocketpool.GasInfo, error) {\n    rocketDAONodeTrustedProposals, err := getRocketDAONodeTrustedProposals(rp)\n    if err != nil {\n        return rocketpool.GasInfo{}, err\n    }\n    return rocketDAONodeTrustedProposals.GetTransactionGasInfo(opts, \"vote\", big.NewInt(int64(proposalId)), support)\n}\n\n\n// Vote on a submitted proposal\nfunc VoteOnProposal(rp *rocketpool.RocketPool, proposalId uint64, support bool, opts *bind.TransactOpts) (common.Hash, error) {\n    rocketDAONodeTrustedProposals, err := getRocketDAONodeTrustedProposals(rp)\n    if err != nil {\n        return common.Hash{}, err\n    }\n    hash, err := rocketDAONodeTrustedProposals.Transact(opts, \"vote\", big.NewInt(int64(proposalId)), support)\n    if err != nil {\n        return common.Hash{}, fmt.Errorf(\"Could not vote on trusted node DAO proposal %d: %w\", proposalId, err)\n    }\n    return hash, nil\n}\n\n\n// Estimate the gas of ExecuteProposal\nfunc EstimateExecuteProposalGas(rp *rocketpool.RocketPool, proposalId uint64, opts *bind.TransactOpts) (rocketpool.GasInfo, error) {\n    rocketDAONodeTrustedProposals, err := getRocketDAONodeTrustedProposals(rp)\n    if err != nil {\n        return rocketpool.GasInfo{}, err\n    }\n    return rocketDAONodeTrustedProposals.GetTransactionGasInfo(opts, \"execute\", big.NewInt(int64(proposalId)))\n}\n\n\n// Execute a submitted proposal\nfunc ExecuteProposal(rp *rocketpool.RocketPool, proposalId uint64, opts *bind.TransactOpts) (common.Hash, error) {\n    rocketDAONodeTrustedProposals, err := getRocketDAONodeTrustedProposals(rp)\n    if err != nil {\n        return common.Hash{}, err\n    }\n    hash, err := rocketDAONodeTrustedProposals.Transact(opts, \"execute\", big.NewInt(int64(proposalId)))\n    if err != nil {\n        return common.Hash{}, fmt.Errorf(\"Could not execute trusted node DAO proposal %d: %w\", proposalId, err)\n    }\n    return hash, nil\n}\n\n\n// Get contracts\nvar rocketDAONodeTrustedProposalsLock sync.Mutex\nfunc getRocketDAONodeTrustedProposals(rp *rocketpool.RocketPool) (*rocketpool.Contract, error) {\n    rocketDAONodeTrustedProposalsLock.Lock()\n    defer rocketDAONodeTrustedProposalsLock.Unlock()\n    return rp.GetContract(\"rocketDAONodeTrustedProposals\")\n}"
    }
  ]
}