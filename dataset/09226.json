{
  "Title": "[L-01] Latent funds can be stolen",
  "Content": "\nIf someone manages, through either a bug or a mistake (self-destructing and sending funds to the contract), another user can claim the funds as their own. Measure the balance before and after, and use the difference, rather than measuring the total balance of the contract\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts-full/WETHGateway.sol   #1\n\n70           IAlchemistV2(alchemist).withdrawUnderlyingFrom(msg.sender, yieldToken, shares, address(this), minimumAmountOut);\n71   \n72           uint256 amount = WETH.balanceOf(address(this));\n73           WETH.withdraw(amount);\n74   \n75:          (bool success, ) = recipient.call{value: amount}(new bytes(0));\n```\n\n<https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/WETHGateway.sol#L70-L75>\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2022-05-alchemix-contest",
  "Code": [
    {
      "filename": "contracts-full/WETHGateway.sol",
      "content": "pragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./base/Errors.sol\";\nimport \"./interfaces/IAlchemistV2.sol\";\nimport \"./interfaces/external/IWETH9.sol\";\nimport \"./interfaces/IWETHGateway.sol\";\nimport \"./interfaces/IWhitelist.sol\";\n\n/// @title  WETHGateway\n/// @author Alchemix Finance\ncontract WETHGateway is IWETHGateway, Ownable {\n    /// @notice The version.\n    string public constant version = \"2.1.0\";\n\n    /// @notice The wrapped ethereum contract.\n    IWETH9 public immutable WETH;\n\n    /// @notice The address of the whitelist contract.\n    address public whitelist;\n\n    constructor(address weth, address _whitelist) {\n        WETH = IWETH9(weth);\n        whitelist = _whitelist;\n    }\n\n    /// @dev Allows for payments from the WETH contract.\n    receive() external payable {\n        if (IWETH9(msg.sender) != WETH) {\n            revert Unauthorized();\n        }\n    }\n\n    /// @inheritdoc IWETHGateway\n    function refreshAllowance(address alchemist) external onlyOwner {\n        WETH.approve(alchemist, type(uint256).max);\n    }\n\n    /// @inheritdoc IWETHGateway\n    function depositUnderlying(\n        address alchemist,\n        address yieldToken,\n        uint256 amount,\n        address recipient,\n        uint256 minimumAmountOut\n    ) external payable {\n        _onlyWhitelisted();\n        if (amount != msg.value) {\n            revert IllegalArgument();\n        }\n        WETH.deposit{value: msg.value}();\n        IAlchemistV2(alchemist).depositUnderlying(yieldToken, amount, recipient, minimumAmountOut);\n    }\n\n    /// @inheritdoc IWETHGateway\n    function withdrawUnderlying(\n        address alchemist,\n        address yieldToken,\n        uint256 shares,\n        address recipient,\n        uint256 minimumAmountOut\n    ) external {\n        _onlyWhitelisted();\n        // Ensure that the underlying of the target yield token is in fact WETH\n        IAlchemistV2.YieldTokenParams memory params = IAlchemistV2(alchemist).getYieldTokenParameters(yieldToken);\n        if (params.underlyingToken != address(WETH)) {\n            revert IllegalArgument();\n        }\n\n        IAlchemistV2(alchemist).withdrawUnderlyingFrom(msg.sender, yieldToken, shares, address(this), minimumAmountOut);\n\n        uint256 amount = WETH.balanceOf(address(this));\n        WETH.withdraw(amount);\n\n        (bool success, ) = recipient.call{value: amount}(new bytes(0));\n        if (!success) {\n            revert IllegalState();\n        }\n    }\n\n    /// @dev Checks the whitelist for msg.sender.\n    ///\n    /// Reverts if msg.sender is not in the whitelist.\n    function _onlyWhitelisted() internal view {\n        // Check if the message sender is an EOA. In the future, this potentially may break. It is important that functions\n        // which rely on the whitelist not be explicitly vulnerable in the situation where this no longer holds true.\n        if (tx.origin == msg.sender) {\n            return;\n        }\n\n        // Only check the whitelist for calls from contracts.\n        if (!IWhitelist(whitelist).isWhitelisted(msg.sender)) {\n            revert Unauthorized();\n        }\n    }\n}"
    }
  ]
}