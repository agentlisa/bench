{
  "Title": "[L09] Unbounded array lengths could lead to out of gas errors",
  "Content": "In our prior audit, we raised the issue of the Notional system potentially running out of gas within functions that iterated over arrays crucial to the system. We specifically cited the [‘portfolios’ array of assets](https://github.com/notional-finance/contracts/blob/b6fc6be4622422d0e34c90e77f2ec9da18596b8c/contracts/Portfolios.sol#L218) as one whose length should be bounded. While the system now limits the length of portfolios by setting a max number of assets, there are still some arrays that could grow too large to be iterated over in some cases.\n\n\nFor example, [`maxCurrencyId`](https://github.com/notional-finance/contracts/blob/b6fc6be4622422d0e34c90e77f2ec9da18596b8c/contracts/storage/EscrowStorage.sol#L61) essentially has no reasonable upper bound to limit the number of currencies that could be listed. Since `maxCurrencyId` is explicitly used to set the size of several other arrays that are often iterated over, unbounded growth of this value could be problematic. If too many currencies were listed, several functions within the system could potentially fail due to out of gas errors.\n\n\nTo prevent encountering out of gas errors that would be difficult to remedy, consider putting an upper bound on the value of variables that are used to limit array growth, especially when those arrays will be iterated over.\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/Portfolios.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"./utils/Common.sol\";\nimport \"./utils/Governed.sol\";\n\nimport \"./lib/SafeMath.sol\";\nimport \"./lib/SafeInt256.sol\";\nimport \"./lib/SafeUInt128.sol\";\nimport \"./utils/RiskFramework.sol\";\n\nimport \"./interface/IRateOracle.sol\";\nimport \"./interface/IPortfoliosCallable.sol\";\n\nimport \"./storage/PortfoliosStorage.sol\";\nimport \"./CashMarket.sol\";\n\n/**\n * @title Portfolios\n * @notice Manages account portfolios which includes all fCash positions and liquidity tokens.\n */\ncontract Portfolios is PortfoliosStorage, IPortfoliosCallable, Governed {\n    using SafeMath for uint256;\n    using SafeInt256 for int256;\n    using SafeUInt128 for uint128;\n\n    struct TradePortfolioState {\n        uint128 amountRemaining;\n        uint256 indexCount;\n        int256 unlockedCurrentCash;\n        Common.Asset[] portfolioChanges;\n    }\n\n    /**\n     * @notice Emitted when an account has its portfolio settled, only emitted if the portfolio has changed\n     * @param account the account that had its porfolio modified\n     */\n    event SettleAccount(address account);\n\n    /**\n     * @notice Emitted when an account has its portfolio settled, all accounts are emitted in the batch\n     * @param accounts batch of accounts that *may* have been settled\n     */\n    event SettleAccountBatch(address[] accounts);\n\n    /**\n     * @notice Emitted when a new cash group is listed\n     * @param cashGroupId id of the new cash group\n     */\n    event NewCashGroup(uint8 indexed cashGroupId);\n\n    /**\n     * @notice Emitted when a new cash group is updated\n     * @param cashGroupId id of the updated cash group\n     */\n    event UpdateCashGroup(uint8 indexed cashGroupId);\n\n    /**\n     * @notice Emitted when max assets is set\n     * @param maxAssets the max assets a portfolio can hold\n     */\n    event SetMaxAssets(uint256 maxAssets);\n\n    /**\n     * @notice Notice for setting haircut amount for liquidity tokens\n     * @param liquidityHaircut amount of haircut applied to liquidity token claims \n     * @param fCashHaircut amount of negative haircut applied to fcash\n     * @param fCashMaxHaircut max haircut amount applied to fcash\n     */\n    event SetHaircuts(uint128 liquidityHaircut, uint128 fCashHaircut, uint128 fCashMaxHaircut);\n\n    /**\n     * @dev skip\n     * @param directory holds contract addresses for dependencies\n     * @param numCurrencies initializes the number of currencies listed on the escrow contract\n     * @param maxAssets max assets that a portfolio can hold\n     */\n    function initialize(address directory, address owner, uint16 numCurrencies, uint256 maxAssets) external initializer {\n        Governed.initialize(directory, owner);\n\n        // We must initialize this here because it cannot be a constant.\n        NULL_ASSET = Common.Asset(0, 0, 0, 0, 0, 0);\n        G_NUM_CURRENCIES = numCurrencies;\n        G_MAX_ASSETS = maxAssets;\n\n        emit SetMaxAssets(maxAssets);\n    }\n\n    /****** Governance Parameters ******/\n\n    /**\n     * @notice Sets the haircut amount for liquidity token claims, this is set to a percentage\n     * less than 1e18, for example, a 5% haircut will be set to 0.95e18.\n     * @dev governance\n     * @param liquidityHaircut amount of negative haircut applied to token claims\n     * @param fCashHaircut amount of negative haircut applied to fcash\n     * @param fCashMaxHaircut max haircut amount applied to fcash\n     */\n    function setHaircuts(uint128 liquidityHaircut, uint128 fCashHaircut, uint128 fCashMaxHaircut) external onlyOwner {\n        PortfoliosStorageSlot._setLiquidityHaircut(liquidityHaircut);\n        PortfoliosStorageSlot._setfCashHaircut(fCashHaircut);\n        PortfoliosStorageSlot._setfCashMaxHaircut(fCashMaxHaircut);\n        Escrow().setLiquidityHaircut(liquidityHaircut);\n\n        emit SetHaircuts(liquidityHaircut, fCashHaircut, fCashMaxHaircut);\n    }\n\n    /**\n     * @dev skip\n     * @param numCurrencies the total number of currencies set by escrow\n     */\n    function setNumCurrencies(uint16 numCurrencies) external override {\n        require(calledByEscrow(), $$(ErrorCode(UNAUTHORIZED_CALLER)));\n        G_NUM_CURRENCIES = numCurrencies;\n    }\n\n    /**\n     * @notice Set the max assets that a portfolio can hold. The default will be initialized to something\n     * like 10 assets, but this will be increased as new markets are created.\n     * @dev governance\n     * @param maxAssets new max asset number\n     */\n    function setMaxAssets(uint256 maxAssets) external onlyOwner {\n        G_MAX_ASSETS = maxAssets;\n\n        emit SetMaxAssets(maxAssets);\n    }\n\n    /**\n     * @notice An cash group defines a collection of similar fCashs where the risk ladders can be netted\n     * against each other. The identifier is only 1 byte so we can only have 255 cash groups, 0 is unused.\n     * @dev governance\n     * @param numMaturities the total number of maturitys\n     * @param maturityLength the maturity length (in seconds)\n     * @param precision the discount rate precision\n     * @param currency the token address of the currenty this fCash settles in\n     * @param cashMarket the rate oracle that defines the discount rate\n     */\n    function createCashGroup(\n        uint32 numMaturities,\n        uint32 maturityLength,\n        uint32 precision,\n        uint16 currency,\n        address cashMarket\n    ) external onlyOwner {\n        require(currentCashGroupId <= MAX_CASH_GROUPS, $$(ErrorCode(OVER_CASH_GROUP_LIMIT)));\n        require(Escrow().isValidCurrency(currency), $$(ErrorCode(INVALID_CURRENCY)));\n\n        currentCashGroupId++;\n        cashGroups[currentCashGroupId] = Common.CashGroup(\n            numMaturities,\n            maturityLength,\n            precision,\n            cashMarket,\n            currency\n        );\n\n        if (cashMarket == address(0)) {\n            // If cashMarket is set to address 0, then it is an idiosyncratic cash group that does not have\n            // an AMM that will trade it. It can only be traded off chain and created via mintfCashPair\n            require(numMaturities == 1);\n        } else if (cashMarket != address(0)) {\n            // The fCash is set to 0 for discount rate oracles and there is no max rate as well.\n            IRateOracle(cashMarket).setParameters(currentCashGroupId, 0, precision, maturityLength, numMaturities, 0);\n        }\n\n        emit NewCashGroup(currentCashGroupId);\n    }\n\n    /**\n     * @notice Updates cash groups. Be very careful when calling this function! When changing maturities and\n     * maturity sizes the markets must be updated as well.\n     * @dev governance\n     * @param cashGroupId the group id to update\n     * @param numMaturities this is safe to update as long as the discount rate oracle is not shared\n     * @param maturityLength this is only safe to update when there are no assets left\n     * @param precision this is only safe to update when there are no assets left\n     * @param currency this is safe to update if there are no assets or the new currency is equivalent\n     * @param cashMarket this is safe to update once the oracle is established\n     */\n    function updateCashGroup(\n        uint8 cashGroupId,\n        uint32 numMaturities,\n        uint32 maturityLength,\n        uint32 precision,\n        uint16 currency,\n        address cashMarket\n    ) external onlyOwner {\n        require(\n            cashGroupId != 0 && cashGroupId <= currentCashGroupId,\n            $$(ErrorCode(INVALID_CASH_GROUP))\n        );\n        require(Escrow().isValidCurrency(currency), $$(ErrorCode(INVALID_CURRENCY)));\n\n        Common.CashGroup storage i = cashGroups[cashGroupId];\n        if (i.numMaturities != numMaturities) i.numMaturities = numMaturities;\n        if (i.maturityLength != maturityLength) i.maturityLength = maturityLength;\n        if (i.precision != precision) i.precision = precision;\n        if (i.currency != currency) i.currency = currency;\n        if (i.cashMarket != cashMarket) i.cashMarket = cashMarket;\n\n        // The fCash is set to 0 for discount rate oracles and there is no max rate as well.\n        IRateOracle(cashMarket).setParameters(cashGroupId, 0, precision, maturityLength, numMaturities, 0);\n\n        emit UpdateCashGroup(cashGroupId);\n    }\n\n    /****** Governance Parameters ******/\n\n    /***** Public View Methods *****/\n\n    /**\n     * @notice Returns the assets of an account\n     * @param account to retrieve\n     * @return an array representing the account's portfolio\n     */\n    function getAssets(address account) public override view returns (Common.Asset[] memory) {\n        return _accountAssets[account];\n    }\n\n    /**\n     * @notice Returns a particular asset via index\n     * @param account to retrieve\n     * @param index of asset\n     * @return a single asset by index in the portfolio\n     */\n    function getAsset(address account, uint256 index) public view returns (Common.Asset memory) {\n        return _accountAssets[account][index];\n    }\n\n    /**\n     * @notice Returns a particular cash group\n     * @param cashGroupId to retrieve\n     * @return the given cash group\n     */\n    function getCashGroup(uint8 cashGroupId) public override view returns (Common.CashGroup memory) {\n        return cashGroups[cashGroupId];\n    }\n\n    /**\n     * @notice Returns a batch of cash groups\n     * @param groupIds array of cash group ids to retrieve\n     * @return an array of cash group objects\n     */\n    function getCashGroups(uint8[] memory groupIds) public override view returns (Common.CashGroup[] memory) {\n        Common.CashGroup[] memory results = new Common.CashGroup[](groupIds.length);\n\n        for (uint256 i; i < groupIds.length; i++) {\n            results[i] = cashGroups[groupIds[i]];\n        }\n\n        return results;\n    }\n\n    /**\n     * @notice Public method for searching for a asset in an account.\n     * @param account account to search\n     * @param assetType the type of asset to search for\n     * @param cashGroupId the cash group id\n     * @param instrumentId the instrument id\n     * @param maturity the maturity timestamp of the asset\n     * @return (asset, index of asset)\n     */\n    function searchAccountAsset(\n        address account,\n        bytes1 assetType,\n        uint8 cashGroupId,\n        uint16 instrumentId,\n        uint32 maturity\n    ) public override view returns (Common.Asset memory, uint256) {\n        Common.Asset[] storage portfolio = _accountAssets[account];\n        (\n            bool found, uint256 index, /* uint128 */, /* bool */ \n        ) = _searchAsset(portfolio, assetType, cashGroupId, instrumentId, maturity, false);\n\n        if (!found) return (NULL_ASSET, index);\n\n        return (portfolio[index], index);\n    }\n\n    /**\n     * @notice Stateful version of free collateral, first settles all assets in the account before returning\n     * the free collateral parameters. Generally, external developers should not need to call this function. It is used\n     * internally to both check free collateral and ensure that the portfolio does not have any matured assets.\n     * Call `freeCollateralView` if you require a view function.\n     * @param account address of account to get free collateral for\n     * @return (net free collateral position, an array of the net currency available)\n     */\n    function freeCollateral(address account) public override returns (int256, int256[] memory, int256[] memory) {\n        // This will emit an event, which is the correct action here.\n        settleMaturedAssets(account);\n\n        return freeCollateralView(account);\n    }\n\n    function freeCollateralAggregateOnly(address account) public override returns (int256) {\n        // This will emit an event, which is the correct action here.\n        settleMaturedAssets(account);\n        \n        (int256 fc, /* int256[] memory */, /* int256[] memory */) = freeCollateralView(account);\n\n        return fc;\n    }\n\n    /**\n     * @notice Stateful version of free collateral called during settlement and liquidation.\n     * @dev skip\n     * @param account address of account to get free collateral for\n     * @param localCurrency local currency for the liquidation\n     * @param collateralCurrency collateral currency for the liquidation\n     * @return FreeCollateralFactors object\n     */\n    function freeCollateralFactors(\n        address account,\n        uint256 localCurrency,\n        uint256 collateralCurrency\n    ) public override returns (Common.FreeCollateralFactors memory) {\n        require(calledByEscrow(), $$(ErrorCode(UNAUTHORIZED_CALLER)));\n        // This will not emit an event, which is the correct action here.\n        _settleMaturedAssets(account);\n\n        (int256 fc, int256[] memory netCurrencyAvailable, int256[] memory cashClaims) = freeCollateralView(account);\n\n        return Common.FreeCollateralFactors(\n            fc,\n            netCurrencyAvailable[localCurrency],\n            netCurrencyAvailable[collateralCurrency],\n            cashClaims[localCurrency],\n            cashClaims[collateralCurrency]\n        );\n    }\n\n    /**\n     * @notice Returns the free collateral balance for an account as a view functon.\n     * @dev - INVALID_EXCHANGE_RATE: exchange rate returned by the oracle is less than 0\n     * @param account account in question\n     * @return (net free collateral position, an array of the net currency available)\n     */\n    function freeCollateralView(address account) public override view returns (int256, int256[] memory, int256[] memory) {\n        int256[] memory balances = Escrow().getBalances(account);\n        return _freeCollateral(account, balances);\n    }\n\n    function _freeCollateral(address account, int256[] memory balances) internal view returns (int256, int256[] memory, int256[] memory) {\n        Common.Asset[] memory portfolio = _accountAssets[account];\n        int256[] memory cashClaims = new int256[](balances.length);\n\n        if (portfolio.length > 0) {\n            // This returns the net requirement in each currency held by the portfolio.\n            Common.Requirement[] memory requirements = RiskFramework.getRequirement(\n                portfolio,\n                address(this)\n            );\n\n            for (uint256 i; i < requirements.length; i++) {\n                uint256 currency = uint256(requirements[i].currency);\n                cashClaims[currency] = cashClaims[currency].add(requirements[i].cashClaim);\n                balances[currency] = balances[currency].add(requirements[i].cashClaim).add(requirements[i].netfCashValue);\n            }\n        }\n\n        // Collateral requirements are denominated in ETH and positive.\n        int256[] memory ethBalances = Escrow().convertBalancesToETH(balances);\n\n        // Sum up the required balances in ETH\n        int256 fc;\n        for (uint256 i; i < balances.length; i++) {\n            fc = fc.add(ethBalances[i]);\n        }\n\n        return (fc, balances, cashClaims);\n    }\n\n    /***** Public Authenticated Methods *****/\n\n    /**\n     * @notice Updates the portfolio of an account with a asset, merging it into the rest of the\n     * portfolio if necessary.\n     * @dev skip\n     * @param account to insert the asset to\n     * @param asset asset to insert into the account\n     * @param checkFreeCollateral allows free collateral check to be skipped (BE CAREFUL WITH THIS!)\n     */\n    function upsertAccountAsset(\n        address account,\n        Common.Asset calldata asset,\n        bool checkFreeCollateral\n    ) external override {\n        // Only the fCash market can insert assets into a portfolio\n        address cashMarket = cashGroups[asset.cashGroupId].cashMarket;\n        require(msg.sender == cashMarket, $$(ErrorCode(UNAUTHORIZED_CALLER)));\n\n        Common.Asset[] storage portfolio = _accountAssets[account];\n        _upsertAsset(portfolio, asset, false);\n\n        if (checkFreeCollateral) {\n            (\n                int256 fc, /* int256[] memory */, /* int256[] memory */\n            ) = freeCollateral(account);\n            require(fc >= 0, $$(ErrorCode(INSUFFICIENT_FREE_COLLATERAL)));\n        }\n    }\n\n    /**\n     * @notice Updates the portfolio of an account with a batch of assets, merging it into the rest of the\n     * portfolio if necessary.\n     * @dev skip\n     * @param account to insert the assets into\n     * @param assets array of assets to insert into the account\n     * @param checkFreeCollateral allows free collateral check to be skipped (BE CAREFUL WITH THIS!)\n     */\n    function upsertAccountAssetBatch(\n        address account,\n        Common.Asset[] calldata assets,\n        bool checkFreeCollateral\n    ) external override {\n        if (assets.length == 0) {\n            return;\n        }\n\n        // Here we check that all the cash group ids are the same if the liquidation auction\n        // is not calling this function. If this is not the case then we have an issue. Cash markets\n        // should only ever call this function with the same cash group id for all the assets\n        // they submit.\n        uint16 id = assets[0].cashGroupId;\n        for (uint256 i = 1; i < assets.length; i++) {\n            require(assets[i].cashGroupId == id, $$(ErrorCode(INVALID_ASSET_BATCH)));\n        }\n\n        address cashMarket = cashGroups[assets[0].cashGroupId].cashMarket;\n        require(msg.sender == cashMarket, $$(ErrorCode(UNAUTHORIZED_CALLER)));\n\n        Common.Asset[] storage portfolio = _accountAssets[account];\n        for (uint256 i; i < assets.length; i++) {\n            _upsertAsset(portfolio, assets[i], false);\n        }\n\n        if (checkFreeCollateral) {\n            (\n                int256 fc, /* int256[] memory */, /* int256[] memory */\n            ) = freeCollateral(account);\n            require(fc >= 0, $$(ErrorCode(INSUFFICIENT_FREE_COLLATERAL)));\n        }\n    }\n\n    /**\n     * @notice Transfers a asset from one account to another.\n     * @dev skip\n     * @param from account to transfer from\n     * @param to account to transfer to\n     * @param assetType the type of asset to search for\n     * @param cashGroupId the cash group id\n     * @param instrumentId the instrument id\n     * @param maturity the maturity of the asset\n     * @param value the amount of notional transfer between accounts\n     */\n    function transferAccountAsset(\n        address from,\n        address to,\n        bytes1 assetType,\n        uint8 cashGroupId,\n        uint16 instrumentId,\n        uint32 maturity,\n        uint128 value\n    ) external override {\n        // Can only be called by ERC1155 token to transfer assets between accounts.\n        require(calledByERC1155Token(), $$(ErrorCode(UNAUTHORIZED_CALLER)));\n\n        Common.Asset[] storage fromPortfolio = _accountAssets[from];\n        (\n            bool found, uint256 index, /* uint128 */, /* bool */\n        ) = _searchAsset(fromPortfolio, assetType, cashGroupId, instrumentId, maturity, false);\n        require(found, $$(ErrorCode(ASSET_NOT_FOUND)));\n\n        uint32 rate = fromPortfolio[index].rate;\n        _reduceAsset(fromPortfolio, fromPortfolio[index], index, value);\n\n        Common.Asset[] storage toPortfolio = _accountAssets[to];\n        _upsertAsset(\n            toPortfolio,\n            Common.Asset(cashGroupId, instrumentId, maturity, assetType, rate, value),\n            false\n        );\n\n        // All transfers of assets must pass a free collateral check.\n        (\n            int256 fc, /* int256[] memory */, /* int256[] memory */\n        ) = freeCollateral(from);\n        require(fc >= 0, $$(ErrorCode(INSUFFICIENT_FREE_COLLATERAL)));\n\n        // Receivers of transfers do not need to pass a free collateral check because we only allow transfers\n        // of positive value. Their free collateral position will always increase.\n    }\n\n    /**\n     * @notice Used by ERC1155 token contract to create block trades for fCash pairs. Allows idiosyncratic\n     * fCash when cashGroup is set to zero.\n     * @dev skip\n     */\n    function mintfCashPair(\n        address payer,\n        address receiver,\n        uint8 cashGroupId,\n        uint32 maturity,\n        uint128 notional\n    ) external override {\n        require(calledByERC1155Trade(), $$(ErrorCode(UNAUTHORIZED_CALLER)));\n        require(cashGroupId != 0 && cashGroupId <= currentCashGroupId, $$(ErrorCode(INVALID_CASH_GROUP)));\n\n        uint32 blockTime = uint32(block.timestamp);\n        require(blockTime < maturity, $$(ErrorCode(TRADE_MATURITY_ALREADY_PASSED)));\n\n        Common.CashGroup memory fcg = cashGroups[cashGroupId];\n\n        uint32 maxMaturity;\n        if (fcg.cashMarket != address(0)) {\n            // This is a cash group that is traded on an AMM so we ensure that the maturity fits\n            // the cadence.\n            require(maturity % fcg.maturityLength == 0, $$(ErrorCode(INVALID_SWAP)));\n\n            maxMaturity = blockTime - (blockTime % fcg.maturityLength) + (fcg.maturityLength * fcg.numMaturities);\n        } else {\n            // This is an idiosyncratic asset so its max maturity is simply relative to the current time\n            maxMaturity = blockTime + fcg.maturityLength;\n        }\n        require(maturity <= maxMaturity, $$(ErrorCode(PAST_MAX_MATURITY)));\n\n\n        _upsertAsset(\n            _accountAssets[payer],\n            Common.Asset(\n                cashGroupId,\n                0,\n                maturity,\n                Common.getCashPayer(),\n                fcg.precision,\n                notional\n            ),\n            false\n        );\n\n        _upsertAsset(\n            _accountAssets[receiver],\n            Common.Asset(\n                cashGroupId,\n                0,\n                maturity,\n                Common.getCashReceiver(),\n                fcg.precision,\n                notional\n            ),\n            false\n        );\n\n        (int256 fc, /* int256[] memory */, /* int256[] memory */) = freeCollateral(payer);\n        require(fc >= 0, $$(ErrorCode(INSUFFICIENT_FREE_COLLATERAL)));\n\n        // NOTE: we do not check that the receiver has sufficient free collateral because their collateral\n        // position will always increase as a result.\n    }\n\n    /**\n     * @notice Settles all matured cash assets and liquidity tokens in a user's portfolio. This method is\n     * unauthenticated, anyone may settle the assets in any account. This is required for accounts that\n     * have negative cash and counterparties need to settle against them. Generally, external developers\n     * should not need to call this function. We ensure that accounts are settled on every free collateral\n     * check, cash settlement, and liquidation.\n     * @param account the account referenced\n     */\n    function settleMaturedAssets(address account) public override {\n        bool didSettle = _settleMaturedAssets(account);\n\n        if (didSettle) {\n            emit SettleAccount(account);\n        }\n    }\n\n    /**\n     * @notice Settle a batch of accounts. See note for `settleMaturedAssets`, external developers should not need\n     * to call this function.\n     * @param accounts an array of accounts to settle\n     */\n    function settleMaturedAssetsBatch(address[] calldata accounts) external override {\n        for (uint256 i; i < accounts.length; i++) {\n            _settleMaturedAssets(accounts[i]);\n        }\n\n        // We do not want to emit when this is called by escrow during settle cash.\n        if (!calledByEscrow()) {\n            emit SettleAccountBatch(accounts);\n        }\n    }\n\n    /**\n     * @notice Settles all matured cash assets and liquidity tokens in a user's portfolio. This method is\n     * unauthenticated, anyone may settle the assets in any account. This is required for accounts that\n     * have negative cash and counterparties need to settle against them.\n     * @param account the account referenced\n     * @return true if the account had any assets that were settled, used to determine if we emit\n     * an event or not\n     */\n    function _settleMaturedAssets(address account) internal returns (bool) {\n        bool didSettle = false;\n        Common.Asset[] storage portfolio = _accountAssets[account];\n        uint32 blockTime = uint32(block.timestamp);\n\n        // This is only used when merging the account's portfolio for updating cash balances in escrow. We\n        // keep this here so that we can do a single function call to settle all the cash in Escrow.\n        int256[] memory settledCash = new int256[](uint256(G_NUM_CURRENCIES + 1));\n        uint256 length = portfolio.length;\n\n        // Loop through the portfolio and find the assets that have matured.\n        for (uint256 i; i < length; i++) {\n            if (portfolio[i].maturity <= blockTime) {\n                Common.Asset memory asset = portfolio[i];\n                // Here we are dealing with a matured asset. We get the appropriate currency for\n                // the instrument. We may want to cache this somehow, but in all likelihood there\n                // will not be multiple matured assets in the same cash group.\n                Common.CashGroup memory fcg = cashGroups[asset.cashGroupId];\n                uint16 currency = fcg.currency;\n\n                if (Common.isCashPayer(asset.assetType)) {\n                    // If the asset is a payer, we subtract from the cash balance\n                    settledCash[currency] = settledCash[currency].sub(asset.notional);\n                } else if (Common.isCashReceiver(asset.assetType)) {\n                    // If the asset is a receiver, we add to the cash balance\n                    settledCash[currency] = settledCash[currency].add(asset.notional);\n                } else if (Common.isLiquidityToken(asset.assetType)) {\n                    // Settling liquidity tokens is a bit more involved since we need to remove\n                    // money from the collateral pools. This function returns the amount of fCash\n                    // the liquidity token has a claim to.\n                    address cashMarket = fcg.cashMarket;\n                    // This function call will transfer the collateral claim back to the Escrow account.\n                    uint128 fCashAmount = CashMarket(cashMarket).settleLiquidityToken(\n                        account,\n                        asset.notional,\n                        asset.maturity\n                    );\n                    settledCash[currency] = settledCash[currency].add(fCashAmount);\n                } else {\n                    revert($$(ErrorCode(INVALID_SWAP)));\n                }\n\n                // Remove asset from the portfolio\n                _removeAsset(portfolio, i);\n                // The portfolio has gotten smaller, so we need to go back to account for the removed asset.\n                i--;\n                length = length == 0 ? 0 : length - 1;\n                didSettle = true;\n            }\n        }\n\n        // We call the escrow contract to update the account's cash balances.\n        if (didSettle) {\n            Escrow().portfolioSettleCash(account, settledCash);\n        }\n\n        return didSettle;\n    }\n\n    /***** Public Authenticated Methods *****/\n\n    /***** Liquidation Methods *****/\n\n    /**\n     * @notice Looks for ways to take cash from the portfolio and return it to the escrow contract during\n     * cash settlement.\n     * @dev skip\n     * @param account the account to extract cash from\n     * @param currency the currency that the token should be denominated in\n     * @param amount the amount of cash to extract from the portfolio\n     * @return returns the amount of remaining cash value (if any) that the function was unable\n     *  to extract from the portfolio\n     */\n    function raiseCurrentCashViaLiquidityToken(\n        address account,\n        uint16 currency,\n        uint128 amount\n    ) external override returns (uint128) {\n        // Sorting the portfolio ensures that as we iterate through it we see each cash group\n        // in batches. However, this means that we won't be able to track the indexes to remove correctly.\n        Common.Asset[] memory portfolio = Common._sortPortfolio(_accountAssets[account]);\n        TradePortfolioState memory state = _tradePortfolio(account, currency, amount, Common.getLiquidityToken(), portfolio);\n\n        return state.amountRemaining;\n    }\n\n    /**\n     * @notice Trades cash receiver in the portfolio for cash. Only possible if there are no liquidity tokens in the portfolio\n     * as required by `settlefCash` and `liquidatefCash`. If fCash assets cannot be sold in the CashMarket, sells the fCash to\n     * the liquidator at a discount.\n     * @dev skip\n     * @param account the account to extract cash from\n     * @param liquidator the account that is initiating the action\n     * @param currency the currency that the token should be denominated in\n     * @param amount the amount of cash to extract from the portfolio\n     * @return returns the amount of remaining cash value (if any) that the function was unable\n     *  to extract from the portfolio\n     */\n    function raiseCurrentCashViaCashReceiver(\n        address account,\n        address liquidator,\n        uint16 currency,\n        uint128 amount\n    ) external override returns (uint128, uint128) {\n        // Sorting the portfolio ensures that as we iterate through it we see each cash group\n        // in batches. However, this means that we won't be able to track the indexes to remove correctly.\n        Common.Asset[] memory portfolio = Common._sortPortfolio(_accountAssets[account]);\n\n        // If a portfolio has liquidity tokens then it still has an asset that can be converted to cash more directly than fCash\n        // receiver tokens. Will not proceed until the portfolio does not have liquidity tokens.\n        uint256 fCashReceivers;\n        for (uint256 i; i < portfolio.length; i++) {\n            require(!Common.isLiquidityToken(portfolio[i].assetType), $$(ErrorCode(PORTFOLIO_HAS_LIQUIDITY_TOKENS)));\n\n            // Technically we should check for the proper currency here but we do this inside\n            // _tradefCashLiquidator. Not doing it here to save some SLOAD calls. This serves as\n            // an upper bound for the receivers in the portfolio.\n            if (Common.isCashReceiver(portfolio[i].assetType)) fCashReceivers++;\n        }\n\n        require(fCashReceivers > 0, $$(ErrorCode(PORTFOLIO_HAS_NO_RECEIVERS)));\n        TradePortfolioState memory state = _tradePortfolio(account, currency, amount, Common.getCashReceiver(), portfolio);\n\n        uint128 liquidatorPayment;\n        if (fCashReceivers > state.indexCount && state.amountRemaining > 0) {\n            // This means that there are fCashRecievers in the portfolio that were unable to be traded on the market. In this case\n            // we will allow the caller to purchase a portion of the fCashReceiver at a heavily discounted amount.\n\n            (state.amountRemaining, liquidatorPayment) = _tradefCashLiquidator(\n                _accountAssets[account],\n                _accountAssets[liquidator],\n                state.amountRemaining,\n                currency\n            );\n        }\n\n        return (state.amountRemaining, liquidatorPayment);\n    }\n\n    /**\n     * @notice Trades fCash receivers to the liquidator at a discount. Transfers the assets between portfolios and returns\n     * the amount that the liquidator must pay in return for the assets.\n     */\n    function _tradefCashLiquidator(\n        Common.Asset[] storage portfolio,\n        Common.Asset[] storage liquidatorPortfolio,\n        uint128 amountRemaining,\n        uint16 currency\n    ) internal returns (uint128, uint128) {\n        uint128 liquidatorPayment;\n        uint128 notionalToTransfer;\n\n        uint256 length = portfolio.length;\n        Common.CashGroup memory cg;\n        uint128 fCashHaircut = PortfoliosStorageSlot._fCashHaircut();\n        uint128 fCashMaxHaircut = PortfoliosStorageSlot._fCashMaxHaircut();\n\n        for (uint256 i; i < length; i++) {\n            Common.Asset memory asset = portfolio[i];\n            if (Common.isCashReceiver(asset.assetType)) {\n                cg = cashGroups[asset.cashGroupId];\n                if (cg.currency != currency) continue;\n                 \n                (liquidatorPayment, notionalToTransfer, amountRemaining) = _calculateNotionalToTransfer(\n                    fCashHaircut,\n                    fCashMaxHaircut,\n                    liquidatorPayment,\n                    amountRemaining,\n                    asset\n                );\n\n                if (notionalToTransfer == asset.notional) {\n                    // This is a full transfer and we will remove the asset, we need to update the loop\n                    // variables as well.\n                    _removeAsset(portfolio, i);\n                    i--;\n                    length = length == 0 ? 0 : length - 1;\n                } else {"
    }
  ]
}