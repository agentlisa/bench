{
  "Title": "[L-03] Fee tier `100` is also supported by Uniswap",
  "Content": "\nThe helper contract `ParticleInfoReader` has a function to view which uniswap pool has the deepest liquidity:\n\n[`ParticleInfoReader::getDeepPool`](https://github.com/code-423n4/2023-12-particle/blob/main/contracts/protocol/ParticleInfoReader.sol#L102-L117):\n```solidity\nFile: contracts/protocol/ParticleInfoReader.sol\n\n102:    function getDeepPool(address token0, address token1) external view returns (address deepPool) {\n103:        uint24[3] memory feeTiers = [uint24(500), uint24(3000), uint24(10000)];\n104:        uint128 maxLiquidity = 0;\n105:\n106:        for (uint256 i = 0; i < feeTiers.length; i++) {\n107:            address poolAddress = Base.UNI_FACTORY.getPool(token0, token1, feeTiers[i]);\n108:            if (poolAddress != address(0)) {\n109:                IUniswapV3Pool pool = IUniswapV3Pool(poolAddress);\n110:                uint128 liquidity = pool.liquidity();\n111:                if (liquidity > maxLiquidity) {\n112:                    maxLiquidity = liquidity;\n113:                    deepPool = poolAddress;\n114:                }\n115:            }\n116:        }\n117:    }\n```\n\nThe issue is that uniswap supports more `feeTiers`:\n\nhttps://docs.uniswap.org/concepts/protocol/fees#pool-fees-tiers:\n> More fee levels may be added by UNI governance, e.g. the 0.01% fee level added by this governance proposal in November 2021, as executed here.\n\nIf you look at the contract:<br>\nhttps://etherscan.io/address/0x1f98431c8ad98523631ae4a59f267346ea31f984#readContract<br>\nit returns tick spacing `1` for fee tier `100`.\n\nHence this might not return the pool with the deepest liquidity.\n\n### Recommendation\nConsider adding `100` to the list of fee tiers.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-12-particle",
  "Code": [
    {
      "filename": "contracts/protocol/ParticleInfoReader.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {IERC20} from \"../../lib/openzeppelin-contracts/contracts/interfaces/IERC20.sol\";\nimport {Multicall} from \"../../lib/openzeppelin-contracts/contracts/utils/Multicall.sol\";\nimport {Ownable2StepUpgradeable} from \"../../lib/openzeppelin-contracts-upgradeable/contracts/access/Ownable2StepUpgradeable.sol\";\nimport {UUPSUpgradeable} from \"../../lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/UUPSUpgradeable.sol\";\nimport {IUniswapV3Pool} from \"../../lib/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport {TransferHelper} from \"../../lib/v3-periphery/contracts/libraries/TransferHelper.sol\";\n\nimport {ParticlePositionManager} from \"./ParticlePositionManager.sol\";\nimport {Errors} from \"../libraries/Errors.sol\";\nimport {Base} from \"../libraries/Base.sol\";\nimport {LiquidityPosition} from \"../libraries/LiquidityPosition.sol\";\nimport {Lien} from \"../libraries/Lien.sol\";\nimport {FullMath} from \"../libraries/FullMath.sol\";\nimport {TickMath} from \"../libraries/TickMath.sol\";\nimport {LiquidityAmounts} from \"../libraries/LiquidityAmounts.sol\";\nimport {DataStruct, DataCache} from \"../libraries/Structs.sol\";\n\ncontract ParticleInfoReader is Ownable2StepUpgradeable, UUPSUpgradeable, Multicall {\n    /* Variables */\n    // solhint-disable-next-line var-name-mixedcase\n    address public PARTICLE_POSITION_MANAGER_ADDR;\n    ParticlePositionManager internal _particlePositionManager;\n\n    event UpdateParticleAddress(address particlePositionManager);\n\n    // required by openzeppelin UUPS module\n    // solhint-disable-next-line no-empty-blocks\n    function _authorizeUpgrade(address) internal override onlyOwner {}\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address particleAddr) external initializer {\n        __UUPSUpgradeable_init();\n        __Ownable_init();\n        PARTICLE_POSITION_MANAGER_ADDR = particleAddr;\n        _particlePositionManager = ParticlePositionManager(particleAddr);\n    }\n\n    /*==============================================================\n                             Update Address\n    ==============================================================*/\n\n    /**\n     * @notice Update address of particle position manager\n     * @param particleAddr address of particle position manager\n     */\n    function updateParticleAddress(address particleAddr) external onlyOwner {\n        if (particleAddr == address(0)) revert Errors.InvalidValue();\n        PARTICLE_POSITION_MANAGER_ADDR = particleAddr;\n        _particlePositionManager = ParticlePositionManager(particleAddr);\n        emit UpdateParticleAddress(particleAddr);\n    }\n\n    /*==============================================================\n                            Pool Information\n    ==============================================================*/\n\n    /**\n     * @notice Helper function getting the pool and current price information\n     * @param tokenId tokenId of the liquidity position NFT\n     * @return token0 address of token0\n     * @return token1 address of token1\n     * @return fee pool fee\n     * @return tickLower lower tick of the concentrated liquidity position\n     * @return tickUpper upper tick of the concentrated liquidity position\n     * @return liquidity amount of liquidity\n     * @return sqrtRatioX96 the current price of the token pairs of this pool\n     */\n    function getPoolInfo(\n        uint256 tokenId\n    )\n        external\n        view\n        returns (\n            address token0,\n            address token1,\n            uint24 fee,\n            int24 tickLower,\n            int24 tickUpper,\n            uint128 liquidity,\n            uint160 sqrtRatioX96\n        )\n    {\n        (, , token0, token1, fee, tickLower, tickUpper, liquidity, , , , ) = Base.UNI_POSITION_MANAGER.positions(\n            tokenId\n        );\n        IUniswapV3Pool pool = IUniswapV3Pool(Base.UNI_FACTORY.getPool(token0, token1, fee));\n        (sqrtRatioX96, , , , , , ) = pool.slot0();\n    }\n\n    /**\n     * @notice Helper function getting the pool of different price tiers with the deepest liquidity\n     * @param token0 address of token0\n     * @param token1 address of token1\n     * @return deepPool address of the pool with the deepest liquidity\n     */\n    function getDeepPool(address token0, address token1) external view returns (address deepPool) {\n        uint24[3] memory feeTiers = [uint24(500), uint24(3000), uint24(10000)];\n        uint128 maxLiquidity = 0;\n\n        for (uint256 i = 0; i < feeTiers.length; i++) {\n            address poolAddress = Base.UNI_FACTORY.getPool(token0, token1, feeTiers[i]);\n            if (poolAddress != address(0)) {\n                IUniswapV3Pool pool = IUniswapV3Pool(poolAddress);\n                uint128 liquidity = pool.liquidity();\n                if (liquidity > maxLiquidity) {\n                    maxLiquidity = liquidity;\n                    deepPool = poolAddress;\n                }\n            }\n        }\n    }\n\n    /*==============================================================\n                           Price and Liquidity\n    ==============================================================*/\n\n    /**\n     * @notice Helper function getting the pool current price\n     * @param token0 token0\n     * @param token1 token1\n     * @param fee pool fee\n     * @return sqrtRatioX96 the current price of this pool\n     */\n    function getCurrentPrice(address token0, address token1, uint24 fee) external view returns (uint160 sqrtRatioX96) {\n        IUniswapV3Pool pool = IUniswapV3Pool(Base.UNI_FACTORY.getPool(token0, token1, fee));\n        (sqrtRatioX96, , , , , , ) = pool.slot0();\n    }\n\n    /**\n     * @notice Helper function getting the pool current price\n     * @param poolAddr address of the pool\n     * @return sqrtRatioX96 the current price of this pool\n     */\n    function getCurrentPrice(address poolAddr) external view returns (uint160 sqrtRatioX96) {\n        IUniswapV3Pool pool = IUniswapV3Pool(poolAddr);\n        (sqrtRatioX96, , , , , , ) = pool.slot0();\n    }\n\n    /**\n     * @notice Helper function getting the token amounts required for given liquidity and tick boundaries\n     * @param liquidity desired amount of liquidity\n     * @param sqrtRatioX96 current price of the token pairs of this pool\n     * @param tickLower lower tick of the concentrated liquidity position\n     * @param tickUpper upper tick of the concentrated liquidity position\n     * @return amount0 amount for token0 at the current price\n     * @return amount1 amount for token1 at the current price\n     */\n    function getAmountsFromLiquidity(\n        uint128 liquidity,\n        uint160 sqrtRatioX96,\n        int24 tickLower,\n        int24 tickUpper\n    ) external pure returns (uint256 amount0, uint256 amount1) {\n        uint160 sqrtRatioAX96 = TickMath.getSqrtRatioAtTick(tickLower);\n        uint160 sqrtRatioBX96 = TickMath.getSqrtRatioAtTick(tickUpper);\n        (amount0, amount1) = LiquidityAmounts.getAmountsForLiquidity(\n            sqrtRatioX96,\n            sqrtRatioAX96,\n            sqrtRatioBX96,\n            liquidity\n        );\n    }\n\n    /**\n     * @notice Helper function getting the token amounts required for given liquidity and tick boundaries\n     * @param amount0 desired amount for token0 at the current price\n     * @param amount1 desired amount for token1 at the current price\n     * @param sqrtRatioX96 current price of the token pairs of this pool\n     * @param tickLower lower tick of the concentrated liquidity position\n     * @param tickUpper upper tick of the concentrated liquidity position\n     * @return liquidity amount of corresponding liquidity\n     */\n    function getLiquidityFromAmounts(\n        uint256 amount0,\n        uint256 amount1,\n        uint160 sqrtRatioX96,\n        int24 tickLower,\n        int24 tickUpper\n    ) external pure returns (uint128 liquidity) {\n        uint160 sqrtRatioAX96 = TickMath.getSqrtRatioAtTick(tickLower);\n        uint160 sqrtRatioBX96 = TickMath.getSqrtRatioAtTick(tickUpper);\n        liquidity = LiquidityAmounts.getLiquidityForAmounts(\n            sqrtRatioX96,\n            sqrtRatioAX96,\n            sqrtRatioBX96,\n            amount0,\n            amount1\n        );\n    }\n\n    /*==============================================================\n                         Collateral Calculation\n    ==============================================================*/\n    /**\n     * @notice Calculates the amount of collateral needed when borrowing liquidity from a position\n     * @param liquidity amount of liquidity to borrow\n     * @param tickLower lower tick of the position\n     * @param tickUpper upper tick of the position\n     * @return amount0 amount that the liquidity concentrates to at tickLower\n     * @return amount1 amount that the liquidity concentrates to at tickHigher\n     */\n    function getRequiredCollateral(\n        uint128 liquidity,\n        int24 tickLower,\n        int24 tickUpper\n    ) external pure returns (uint256 amount0, uint256 amount1) {\n        (amount0, amount1) = Base.getRequiredCollateral(liquidity, tickLower, tickUpper);\n    }\n\n    /*==============================================================\n                         Position Information\n    ==============================================================*/\n\n    /**\n     * @notice Get basic information of a liquidity position\n     * @param tokenId tokenId of the liquidity position NFT\n     * @return owner owner of the liquidity position\n     * @return token0 address of token0\n     * @return token1 address of token1\n     * @return liquidity amount of current available liquidity\n     * @return tickLower lower tick of the concentrated liquidity position\n     * @return tickUpper upper tick of the concentrated liquidity position\n     * @return token0Owed amount of token0 owed to the owner\n     * @return token1Owed amount of token1 owed to the owner\n     * @return renewalCutoffTime renewal cutoff time for all previous loans\n     */\n    function getLiquidityPosition(\n        uint256 tokenId\n    )\n        external\n        view\n        returns (\n            address owner,\n            address token0,\n            address token1,\n            uint128 liquidity,\n            int24 tickLower,\n            int24 tickUpper,\n            uint128 token0Owed,\n            uint128 token1Owed,\n            uint32 renewalCutoffTime\n        )\n    {\n        (owner, renewalCutoffTime, token0Owed, token1Owed) = _particlePositionManager.lps(tokenId);\n        (, , token0, token1, , tickLower, tickUpper, liquidity, , , , ) = Base.UNI_POSITION_MANAGER.positions(tokenId);\n    }\n\n    struct GetLienCache {\n        uint24 token0PremiumPortion;\n        uint24 token1PremiumPortion;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0;\n        uint256 amount1;\n    }\n\n    /**\n     * @notice Get basic information of a lien\n     * @param borrower address of the borrower\n     * @param lienId ID for the existing lien\n     * @return tokenId tokenId of the liquidity position NFT\n     * @return liquidity amount of liquidity locked in the lien\n     * @return startTime start time of the lien\n     * @return token0Premium amount of token0 premium locked in the lien\n     * @return token1Premium amount of token1 premium locked in the lien\n     * @return feeGrowthInside0LastX128 fee growth of token0 since the previous borrow/fee collection time\n     * @return feeGrowthInside1LastX128 fee growth of token1 since the previous borrow/fee collection time\n     * @return zeroForOne direction of the swap\n     */\n    function getLien(\n        address borrower,\n        uint96 lienId\n    )\n        external\n        view\n        returns (\n            uint40 tokenId,\n            uint128 liquidity,\n            uint32 startTime,\n            uint128 token0Premium,\n            uint128 token1Premium,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            bool zeroForOne\n        )\n    {\n        (\n            tokenId,\n            liquidity,\n            ,\n            ,\n            startTime,\n            feeGrowthInside0LastX128,\n            feeGrowthInside1LastX128,\n            zeroForOne\n        ) = _particlePositionManager.liens(keccak256(abi.encodePacked(borrower, lienId)));\n        (token0Premium, token1Premium) = getPremium(borrower, lienId);\n    }\n\n    /**\n     * @notice Get amount of preimum\n     * @param borrower address of the borrower\n     * @param lienId ID for the existing lien\n     * @return token0Premium amount of token0 premium locked in the lien\n     * @return token1Premium amount of token1 premium locked in the lien\n     */\n    function getPremium(\n        address borrower,\n        uint96 lienId\n    ) public view returns (uint128 token0Premium, uint128 token1Premium) {\n        (\n            uint40 tokenId,\n            uint128 liquidity,\n            uint24 token0PremiumPortion,\n            uint24 token1PremiumPortion,\n            ,\n            ,\n            ,\n\n        ) = _particlePositionManager.liens(keccak256(abi.encodePacked(borrower, lienId)));\n\n        (, , , , , int24 tickLower, int24 tickUpper, , , , , ) = Base.UNI_POSITION_MANAGER.positions(tokenId);\n        (uint256 amount0, uint256 amount1) = Base.getRequiredCollateral(liquidity, tickLower, tickUpper);\n        (token0Premium, token1Premium) = Base.getPremium(amount0, amount1, token0PremiumPortion, token1PremiumPortion);\n    }\n\n    struct OwedInfoCache {\n        uint40 tokenId;\n        uint128 liquidity;\n        uint24 token0PremiumPortion;\n        uint24 token1PremiumPortion;\n        uint256 feeGrowthInside0LastX128;\n        uint256 feeGrowthInside1LastX128;\n    }\n\n    /**\n     * @notice Get the current owed fees for a position\n     * @param borrower address of the borrower\n     * @param lienId ID for the existing lien\n     * @return token0Owed amount of token0 owed to the liquidity provider\n     * @return token1Owed amount of token1 owed to the liquidity provider\n     * @return token0Premium amount of token0 premium locked in the lien\n     * @return token1Premium amount of token1 premium locked in the lien\n     * @return collateral0 amount of token0 required by the lp (if oneForZero)\n     * @return collateral1 amount of token1 required by the lp (if zeroForOne)\n     */\n    function getOwedInfo(\n        address borrower,\n        uint96 lienId\n    )\n        external\n        view\n        returns (\n            uint128 token0Owed,\n            uint128 token1Owed,\n            uint128 token0Premium,\n            uint128 token1Premium,\n            uint256 collateral0,\n            uint256 collateral1\n        )\n    {\n        OwedInfoCache memory cache;\n        (\n            cache.tokenId,\n            cache.liquidity,\n            cache.token0PremiumPortion,\n            cache.token1PremiumPortion,\n            ,\n            cache.feeGrowthInside0LastX128,\n            cache.feeGrowthInside1LastX128,\n\n        ) = _particlePositionManager.liens(keccak256(abi.encodePacked(borrower, lienId)));\n        (, , token0Owed, token1Owed, token0Premium, token1Premium, collateral0, collateral1) = Base.getOwedInfo(\n            DataStruct.OwedInfoParams({\n                tokenId: cache.tokenId,\n                liquidity: cache.liquidity,\n                feeGrowthInside0LastX128: cache.feeGrowthInside0LastX128,\n                feeGrowthInside1LastX128: cache.feeGrowthInside1LastX128,\n                token0PremiumPortion: cache.token0PremiumPortion,\n                token1PremiumPortion: cache.token1PremiumPortion\n            })\n        );\n    }\n}"
    }
  ]
}