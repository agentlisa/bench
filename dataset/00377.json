{
  "Title": "M-3: Max allocations can be bypassed with multiple addresses because of guaranteed allocations",
  "Content": "# Issue M-3: Max allocations can be bypassed with multiple addresses because of guaranteed allocations \n\nSource: https://github.com/sherlock-audit/2024-03-zap-protocol-judging/issues/152 \n\n## Found by \nGatewayGuardians, Silvermist, ZdravkoHr., s1ce\n## Summary\n[`TokenSale._processPrivate()`](https://github.com/sherlock-audit/2024-03-zap-protocol/blob/c2ad35aa844899fa24f6ed0cbfcf6c7e611b061a/zap-contracts-labs/contracts/TokenSale.sol#L226) ensures that a user cannot deposit more than their allocation amount. However, each address can deposit up to at least `maxAllocations`. This can be leveraged by a malicious user by using different addresses to claim all tokens without even staking.\n\n## Vulnerability Detail\nThe idea of the protocol is to give everyone the right to have at least `maxAlocations` allocations. By completing missions, users level up and unlock new tiers. This process will be increasing their allocations. The problem is that when a user has no allocations, they have still a granted amount of `maxAllocations`.\n\n[`TokenSale.calculateMaxAllocation`](https://github.com/sherlock-audit/2024-03-zap-protocol/blob/c2ad35aa844899fa24f6ed0cbfcf6c7e611b061a/zap-contracts-labs/contracts/TokenSale.sol#L259C1-L267C6) returns $max(maxTierAlloc(), maxAllocation)$\n\nFor a user with no allocations, `_maxTierAlloc()` will return 0. The final result will be that this user have `maxAllocation` allocations (because maxAllocation > 0).\n```solidity\n        if (userTier == 0 && giftedTierAllc == 0) {\n            return 0;\n        }\n```\n\nMultiple Ethereum accounts can be used by the same party to take control over the IDO and all its allocations, on top of that without even staking.\n\n*NOTE*: setting `maxAllocation = 0` is not a solution in this case because the protocol wants to still give some allocations to their users.\n\n## Impact\nBuying all allocations without staking. This also violates a key property that only ION holders can deposit.\n\n## Code Snippet\n```solidity\n    function calculateMaxAllocation(address _sender) public returns (uint256) {\n        uint256 userMaxAllc = _maxTierAllc(_sender);\n\n        if (userMaxAllc > maxAllocation) {\n            return userMaxAllc;\n        } else {\n            return maxAllocation;\n        }\n    }\n```\n## Tool used\n\nManual Review\n\n## Recommendation\nA possible solution may be to modify `calculateMaxAllocation` in the following way:\n```diff\n    function calculateMaxAllocation(address _sender) public returns (uint256) {\n        uint256 userMaxAllc = _maxTierAllc(_sender);\n+       if (userMaxAllc == 0) return 0;\n\n         if (userMaxAllc > maxAllocation) {\n            return userMaxAllc;\n        } else {\n            return maxAllocation;\n        }\n    }\n```\n\n\n\n## Discussion\n\n**ZdravkoHr**\n\nEscalate\n\n@Hash01011122, why was this issue excluded? It shows how users can bypass a core restriction and on top of that - doing it without staking.\n\n**sherlock-admin2**\n\n> Escalate\n> \n> @Hash01011122, why was this issue excluded? It shows how users can bypass a core restriction and on top of that - doing it without staking.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Hash01011122**\n\nThe function is operating as designed. If you believe the issue warrants further investigation, please submit a Proof of Concept (PoC).\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/Lithium-Ventures/zap-contracts-labs/pull/1.\n\n**ZdravkoHr**\n\n@Hash01011122 basically everyone, regardless of the staked amount, can deposit up to maxAllocations\n\n**Hash01011122**\n\nIf you don't provide a valid PoC for this issue within 48 hours, I will consider this as invalid\n\n**ZdravkoHr**\n\n@Hash01011122, here is my PoC. You have to do two things before running it:\n1. Add this `MockStaking.sol` file in the same folder as the PoC.\n\n```solidity\ncontract MockStaking {\n    function getUserState(address) public returns(uint256, uint256, uint256, uint256) {\n        return (0, 0, 0, 0);\n    }\n}\n```\n\n2. Add this function to `TokenSale.sol`.\n```solidity\n    function setUsdc(address _new) public {\n        usdc = IERC20D(_new);\n    }\n```\n\nThe main file `TokenSale.t.sol` demonstrates how a user that hasn't staked  in the staking contract, can use different accounts to deposit as many assets as they want to.\n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.11;\n\nimport \"forge-std/Test.sol\";\nimport \"../contracts/Admin.sol\";\nimport \"../contracts/USDC.sol\";\nimport \"../contracts/interfaces/ITokenSale.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"forge-std/console.sol\";\nimport {TokenSale} from \"../contracts/TokenSale.sol\";\nimport {MockStaking} from \"./MockStaking.sol\";\n\n\ncontract TokenSaleTest is Test {\n    using stdStorage for StdStorage;\n     address public saleContract;\n     Admin public admin;\n     USDCWithSixDecimal public mockUSDC;\n     MockStaking public stakingContract;\n     TokenSale public saleInstance;\n\n     \n\n    function setUp() public {\n        saleContract = address(new TokenSale());\n        mockUSDC = new USDCWithSixDecimal(\"MockUSDC\", \"USDC\");\n        _config();\n    }\n\n    function _config() internal {\n       stakingContract = new MockStaking();\n       admin = new Admin();\n       admin.initialize(address(this));\n       admin.setStakingContract(address(stakingContract));\n       admin.addOperator(address(this));\n       admin.setMasterContract(saleContract);\n       admin.setWallet(address(this));\n\n    \n       ITokenSale.Params memory params = ITokenSale.Params({\n        totalSupply: 1000e18,\n        privateStart: uint32(block.timestamp),\n        privateTokenPrice: 20e18,\n        privateEnd: uint32(block.timestamp + 1 weeks)\n       });\n\n       admin.createPoolNew(params, 15000e18, 1000, false, 0);\n       \n       assertTrue(admin.tokenSalesM(0x5B0091f49210e7B2A57B03dfE1AB9D08289d9294));\n       saleInstance = TokenSale(payable(0x5B0091f49210e7B2A57B03dfE1AB9D08289d9294));\n\n       // A setUsdc function is added to the TokenSale contract for test purposes\n       saleInstance.setUsdc(address(mockUSDC));\n    }\n\n    function testDeposit() public {\n        uint160 addressCount = 20;\n        // A single user, WITHOUT EVER DEPOSITING TO THE STAKING CONTRACT, can deposit as much as they want using different addresses.\n            for (uint160 i = 1; i < addressCount; i++) {\n            address currentAddress = address(i);\n            mockUSDC.mint(currentAddress, type(uint256).max / addressCount);\n\n            vm.startPrank(currentAddress);\n            mockUSDC.approve(address(saleInstance), type(uint256).max);\n            // Just 100 because of decimals mess\n            saleInstance.deposit(100);\n            vm.stopPrank();\n\n            (uint128 totalPrivateSold, ) = saleInstance.getState();\n            console.log(totalPrivateSold);\n        }\n        \n    }\n\n}\n```\n\n**s1ce**\n\n@Evert0x @Hash01011122\n\nI am not sure if this issue is valid which is why I didn't escalate my own, but mine (#196) is a duplicate of this\n\nMy issue #172 that has been a marked a dup of this one is actually a dup of #158 instead\n\n**Evert0x**\n\n@Hash01011122 what's your opinion about the poc?\n\n**Hash01011122**\n\n@ZdravkoHr your PoC isn't working, @Evert0x this issue can be invalidated. Also their is a check in [`TokenSale.sol:_maxTierAllc`](https://github.com/sherlock-audit/2024-03-zap-protocol/blob/c2ad35aa844899fa24f6ed0cbfcf6c7e611b061a/zap-contracts-labs/contracts/TokenSale.sol#L286) whether if `userTier` or `giftedTierAllc` of user is zero then allocation will be zero. @ZdravkoHr do you want to add anything?? Correct me if I am wrong.\n\n\n**ZdravkoHr**\n\nThe 0 will be used in calculateMaxAllocation and maxAllocations will be returned. Which part of the PoC is not working?\n\n**Hash01011122**\n\nThe `deposit` function in your PoC isn't working, if you still feel it's valid can you please provide the exact lines of code which justifies the logic you are trying to portray with proper mitigation for it.\n\n**ZdravkoHr**\n\nHave you added the MockStaking contract and the setUsdc function?\n\n**detectiveking123**\n\n@Evert0x I believe this one and it's duplicates are actually the same issue family as #158 (they point out the same root cause issue)\n\nYou have invalidated issue family #158, but in the documentation in `TokenSale.sol` there are the following two lines:\n\n`1. Private round. Only ion token holders can participate in this round. `\n\n` A single investor can purchase up to their maximum allowed investment defined by the tier.`\n\nClearly, based on this documentation (which I strongly believe is incorrect and should not be used as a source of truth, but my personal opinions are besides the point), both issues should be valid. \n\n**Hash01011122**\n\n@ZdravkoHr I've added the setUsdc function and MockStaking contract, and also deleted the entire file and environment. I reinstalled everything from scratch to rerun your PoC, but the results remain unchanged.\n\n**Hash01011122**\n\n@detectiveking123 Still verifying this issue's validity, whereas for issue #158, I will take confirmation from sponsors.\n\n**detectiveking123**\n\n@Hash01011122 They are the exact same root cause though, so they should be valid and duplicates of each other. What the sponsors say shouldn't matter; I've shown you excerpts from the documentation that prove validity. \n\n**Evert0x**\n\nAgree with @detectiveking123\n\nFor that reason I will reject the escalation and invalidate the issue\n\n**detectiveking123**\n\n@Evert0x I'm saying the issue should be valid. They're all valid issues, and duplicates of each other, because of the above excerpts from the documentation. \n\n**Evert0x**\n\nThe language you quoted supports the invalidation of this issue. \n\n> A single investor can purchase up to **their** maximum allowed investment defined by the tier.\n\nIndicating it's a maximum allowed investment personalized to the investor.\n\nBesides that, they have clarified it in a discord message https://github.com/sherlock-audit/2024-03-zap-protocol-judging/issues/158#issuecomment-2047444809\n\nI will reject the escalation and invalidate the issue\n\n**ZdravkoHr**\n\n@Evert0x, this issue shows how tokens can be obtained without any prior staking. I think the root cause here is the missing if statement from my recommendation\n\n**detectiveking123**\n\n@Evert0x You misunderstand. The tier based max allocation is defined by `_maxTierAllc`. The current code would allow them to purchase potentially more than that if maxAllocation is higher. \n\nFurthermore, the language here is pretty clear:\n\n`1. Private round. Only ion token holders can participate in this round. `\n\nClearly, this code allows non-ion token holders/stakers to participate. \n\n\n**detectiveking123**\n\nAlso, to clarify my point, I am suggesting that it is not just this issue that is valid based on the documentation, but also the entire #158 family (they have the exact same root cause). This issue is a strict subset of #158 , although still valid. \n\nMy recommendation is to duplicate the two issue families and validate all of them. \n\n**Evert0x**\n\nThank you for correcting me @detectiveking123. I indeed misunderstood this issue.\n\nStill looking into the outcome for this issue. But I don't believe this is a duplicate of #158. \n\n**detectiveking123**\n\n@Evert0x This is actually a strict subset of #158 . \n\nBoth issues reference the exact code snippet and lead to the exact same impact, but have different opinions about what the correct fix is. In #158 , the fix that is suggested is to replace the max with a min, while in this issue adding an extra if statement is suggested. \n\nIn fact, #158 even states that: `However, swapped return values allow a user to have 0 allocations and get themaxAllocation or to exceed the maximum allocations`\n\nClearly all Watsons have identified the core issue but have different suggestions / opinions on how to fix it\n\n**Evert0x**\n\nI believe the following issues are a family #152, #158, #161, #172.\n\nThey all describe the following issue \n> get maximum allocation while having 0\n\nPlanning to make #152 the main report issue as the fix recommendation is correct\n\nThanks @detectiveking123\n\n**detectiveking123**\n\n@Evert0x No problem. Your proposed judgement makes sense to me.\n\n**Hash01011122**\n\nThanks for bring this to light @detectiveking123, I agree that this should be considered a valid issue with dups #019, #158, #161, #172.\n\n\n**Evert0x**\n\nResult:\nMedium\nHas Duplicates\n\n**sherlock-admin3**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [ZdravkoHr](https://github.com/sherlock-audit/2024-03-zap-protocol-judging/issues/152/#issuecomment-2025551345): accepted\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/243",
  "Code": [
    {
      "filename": "zap-contracts-labs/contracts/TokenSale.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"./interfaces/ITokenSale.sol\";\nimport \"./interfaces/IAdmin.sol\";\nimport \"./interfaces/IAirdrops.sol\";\nimport \"./interfaces/IERC20D.sol\";\nimport \"./interfaces/IStaking.sol\";\nimport \"hardhat/console.sol\";\n\n/*\nA tokensale includes 3 stages: \n1. Private round. Only ion token holders can participate in this round. \n The Matic/USDC price is fixed in the beginning of the tokensale.\n All tokens available in the pre-sale will be made available through the private sale round. \n A single investor can purchase up to their maximum allowed investment defined by the tier.\n Investors can claim their tokens only when the private round is finished. \n If the total supply is higher than the total demand for this tokensale, investors purchase tokens up to their max allocation. \n If the the demand is higher than supply, the number of tokens investors will receive is adjusted, and then the native token used to invest are partially refunded.\n\n*/\n\n//TODO Change USDC address\n//TODO Change Marketing wallet address\n\ncontract TokenSale is Initializable, ITokenSale {\n    using SafeERC20 for IERC20D;\n\n    uint256 constant PCT_BASE = 10 ** 18;\n    uint256 constant POINT_BASE = 1000;\n    bytes32 constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    address public marketingWallet;\n\n    uint256 public maxAllocation; // in dollar with decimals\n    uint256 public globalTaxRate; // base 1000\n    uint256 public whitelistTxRate; // base 1000\n    bool public isKYCEnabled;\n\n    IStaking stakingContract;\n    Params params;\n    IERC20D public usdc;\n    IAdmin admin;\n    /**\n     * @dev current tokensale stage (epoch)\n     */\n    Epoch public override epoch;\n    bool isRaiseClaimed;\n    bool only;\n    bytes32 public constant OPERATOR = keccak256(\"OPERATOR\");\n    address[] public usersOnDeposit;\n\n    mapping(address => Staked) public override stakes;\n    mapping(address => uint256) public tokensaleTiers;\n    /** @dev Decrease result by 1 to access correct position */\n    mapping(address => uint256) public userDepositIndex;\n    mapping(address => bool) public isWhitelisted;\n\n    State state;\n\n    receive() external payable {}\n\n    function getState() external view returns (uint128, uint128) {\n        return (state.totalPrivateSold, state.totalSupplyInValue);\n    }\n\n    function initialize(\n        Params calldata _params,\n        address _stakingContract,\n        address _admin,\n        uint256 _maxAllocation,\n        uint256 _globalTaxRate,\n        bool _isKYC,\n        uint256 _whitelistTxRate\n    ) external initializer {\n        params = _params;\n        stakingContract = IStaking(_stakingContract);\n        admin = IAdmin(_admin);\n        state.totalSupplyInValue = uint128(\n            (uint256(_params.totalSupply) *\n                uint256(_params.privateTokenPrice)) / 10 ** 18\n            // removes USDB hardcode of six, awful\n        );\n        usdc = IERC20D(0xA9F81589Cc48Ff000166Bf03B3804A0d8Cec8114); //TODO change for mainnet\n        marketingWallet = 0x6507fFd283c32386B6065EA89744Ade21515e91E; //TODO change for mainnet\n        maxAllocation = _maxAllocation;\n        globalTaxRate = _globalTaxRate;\n        isKYCEnabled = _isKYC;\n        whitelistTxRate = _whitelistTxRate;\n    }\n\n    // allocation is amount in dollar without decimals\n    function userWhitelistAllocation(\n        address[] calldata users,\n        uint256[] calldata allocations\n    ) public {\n        require(admin.hasRole(OPERATOR, msg.sender), \"TokenSale: OnlyOperator\");\n        require(\n            users.length == allocations.length,\n            \"TokenSale: Invalid length\"\n        );\n        for (uint256 i = 0; i < users.length; i++) {\n            tokensaleTiers[users[i]] = allocations[i];\n        }\n    }\n\n    function whitelistUser(address[] calldata users) public {\n        require(admin.hasRole(OPERATOR, msg.sender), \"TokenSale: OnlyOperator\");\n        for (uint256 i = 0; i < users.length; i++) {\n            isWhitelisted[users[i]] = true;\n        }\n    }\n\n    function setAllocationAndTax(uint256[3] calldata _allocations) external {\n        require(block.timestamp <= params.privateStart, \"Time lapsed\");\n        require(admin.hasRole(OPERATOR, msg.sender), \"TokenSale: OnlyOperator\");\n        maxAllocation = _allocations[0];\n        globalTaxRate = _allocations[1];\n        whitelistTxRate = _allocations[2];\n    }\n\n    function setMarketingWallet(address _wallet) external {\n        _onlyAdmin();\n        marketingWallet = _wallet;\n    }\n\n    /**\n     * @dev setup the current tokensale stage (epoch)\n     */\n    function checkingEpoch() public {\n        uint256 time = block.timestamp;\n        if (\n            epoch != Epoch.Private &&\n            time >= params.privateStart &&\n            time <= params.privateEnd\n        ) {\n            epoch = Epoch.Private;\n            return;\n        }\n        if ((epoch != Epoch.Finished && (time > params.privateEnd))) {\n            epoch = Epoch.Finished;\n            return;\n        }\n    }\n\n    // to save size\n    function _onlyAdmin() internal view {\n        require(\n            admin.hasRole(DEFAULT_ADMIN_ROLE, msg.sender) ||\n                msg.sender == address(admin),\n            \"TokenSale: Onlyadmin\"\n        );\n    }\n\n    /**\n     * @dev invest usdc to the tokensale\n     */\n    function deposit(uint256 _amount) external {\n        console.log(\"kyc enabled\", isKYCEnabled);\n        if (isKYCEnabled) {\n            require(admin.isKYCDone(msg.sender) == true, \"KYC not done\");\n        }\n        address sender = msg.sender;\n        require(\n            !admin.blacklist(address(this), sender),\n            \"TokenSale: Blacklisted\"\n        );\n        checkingEpoch();\n\n        require(epoch == Epoch.Private, \"TokenSale: Incorrect time\");\n        require(_amount > 0, \"TokenSale: 0 deposit\");\n\n        if (userDepositIndex[sender] == 0) {\n            usersOnDeposit.push(sender);\n            userDepositIndex[sender] = usersOnDeposit.length;\n        }\n        if (epoch == Epoch.Private) {\n            _processPrivate(sender, _amount);\n        }\n    }\n\n    function destroy() external override {\n        _onlyAdmin();\n        uint256 amountUSDC = usdc.balanceOf(address(this));\n        if (amountUSDC > 0) {\n            usdc.safeTransfer(admin.wallet(), amountUSDC);\n        }\n        address payable wallet = payable(admin.wallet());\n        selfdestruct(wallet);\n    }\n\n    /**\n     * @notice withdraw accidently sent ERC20 tokens\n     * @param _tokenAddress address of token to withdraw\n     */\n    function removeOtherERC20Tokens(address _tokenAddress) external {\n        _onlyAdmin();\n        require(\n            _tokenAddress != address(usdc),\n            \"TokenSale: Can't withdraw usdc\"\n        );\n        uint256 balance = IERC20D(_tokenAddress).balanceOf(address(this));\n        IERC20D(_tokenAddress).safeTransfer(admin.wallet(), balance);\n\n        emit ERC20TokensRemoved(_tokenAddress, msg.sender, balance);\n    }\n\n    /**\n     * @dev processing usdc investment to the private round\n     * @param _sender - transaction sender\n     * @param _amount - investment amount in usdc\n     */\n    function _processPrivate(address _sender, uint256 _amount) internal {\n        require(_amount > 0, \"TokenSale: Too small\");\n\n        Staked storage s = stakes[_sender];\n        uint256 amount = _amount * PCT_BASE;\n        uint256 sum = s.amount + amount;\n\n        uint256 maxAllocationOfUser = (calculateMaxAllocation(_sender)) *\n            PCT_BASE;\n        require(sum <= maxAllocationOfUser, \"upto max allocation\");\n        uint256 taxFreeAllcOfUser = 0; // hardcode zero - all pools have ax\n\n        uint256 userTaxAmount;\n\n        if (sum > taxFreeAllcOfUser) {\n            uint256 userTxRate = userTaxRate(sum, _sender);\n            if (s.amount < taxFreeAllcOfUser) {\n                userTaxAmount =\n                    ((sum - taxFreeAllcOfUser) * userTxRate) /\n                    POINT_BASE;\n            } else {\n                userTaxAmount = (amount * userTxRate) / POINT_BASE;\n            }\n        }\n\n        if (userTaxAmount > 0) {\n            s.taxAmount += userTaxAmount;\n            usdc.safeTransferFrom(_sender, marketingWallet, userTaxAmount);\n        }\n        s.amount += uint128(amount);\n        state.totalPrivateSold += uint128(amount);\n        usdc.safeTransferFrom(_sender, address(this), amount);\n\n        /**@notice Forbid unstaking*/\n        // stakingContract.setPoolsEndTime(_sender, uint256(params.privateEnd)); // TODO: uncomment\n        emit DepositPrivate(_sender, _amount, address(this));\n    }\n\n    /**\n     * @dev sends the usdc raise to admin's wallet\n     */\n\n    function calculateMaxAllocation(address _sender) public returns (uint256) {\n        uint256 userMaxAllc = _maxTierAllc(_sender);\n\n        if (userMaxAllc > maxAllocation) {\n            return userMaxAllc;\n        } else {\n            return maxAllocation;\n        }\n    }\n\n    function _maxTaxfreeAllocation(address _sender) internal returns (uint256) {\n        uint256 userTierAllc = stakingContract.getAllocationOf(_sender);\n        uint256 giftedTierAllc = tokensaleTiers[_sender];\n\n        if (userTierAllc > giftedTierAllc) {\n            return userTierAllc;\n        } else {\n            return giftedTierAllc;\n        }\n    }\n\n    function _maxTierAllc(address _sender) internal returns (uint256) {\n        (uint256 userTier, uint256 userLockLvl, , ) = stakingContract\n            .getUserState(_sender);\n\n        uint256 giftedTierAllc = tokensaleTiers[_sender];\n\n        if (userTier == 0 && giftedTierAllc == 0) {\n            return 0;\n        }\n\n        uint256 userTierAllc = stakingContract.getAllocationOf(_sender);\n        uint256 nextTierAllc;\n        if (userLockLvl > 0 && userLockLvl < 4) {\n            nextTierAllc = stakingContract.getAllocations(\n                userLockLvl + 1,\n                userTier\n            );\n        } else {\n            nextTierAllc = stakingContract.getAllocations(\n                userLockLvl,\n                userTier + 1\n            );\n        }\n\n        if (nextTierAllc > userTierAllc) {\n            if (nextTierAllc > giftedTierAllc) {\n                return nextTierAllc;\n            } else {\n                return giftedTierAllc;\n            }\n        } else {\n            if (userTierAllc > giftedTierAllc) {\n                return userTierAllc;\n            } else {\n                return giftedTierAllc;\n            }\n        }\n    }\n\n    // _amount should be in dollar without decimals\n    function userTaxRate(\n        uint256 _amount,\n        address _sender\n    ) public returns (uint256) {\n        uint256 userTaxFreeAllc = 0;\n\n        if (_amount > userTaxFreeAllc) {\n            if (isWhitelisted[_sender]) {\n                return whitelistTxRate;\n            } else {\n                return globalTaxRate;\n            }\n        } else {\n            return 0;\n        }\n    }\n\n    function takeUSDCRaised() external override {\n        checkingEpoch();\n        require(epoch == Epoch.Finished, \"TokenSale: Not time yet\");\n        require(!isRaiseClaimed, \"TokenSale: Already paid\");\n\n        uint256 earned;\n\n        if (state.totalPrivateSold > state.totalSupplyInValue) {\n            earned = uint256(state.totalSupplyInValue);\n        } else {\n            earned = uint256(state.totalPrivateSold);\n        }\n\n        isRaiseClaimed = true;\n\n        if (earned > 0) {\n            uint256 bal = usdc.balanceOf(address(this));\n            uint256 returnValue = earned <= bal ? earned : bal;\n            usdc.safeTransfer(admin.wallet(), returnValue);\n        }\n\n        emit RaiseClaimed(admin.wallet(), earned);\n    }\n\n    /**\n     * @dev allows the participants of the private round to claim usdc left\n     */\n    function claim() external {\n        checkingEpoch();\n        require(\n            uint8(epoch) > 1 && !admin.blockClaim(address(this)),\n            \"TokenSale: Not time or not allowed\"\n        );\n\n        Staked storage s = stakes[msg.sender];\n        require(s.amount != 0, \"TokenSale: No Deposit\");\n        require(!s.claimed, \"TokenSale: Already Claimed\");\n\n        uint256 left;\n        (s.share, left) = _claim(s);\n        require(left > 0, \"TokenSale: Nothing to claim\");\n        uint256 refundTaxAmount;\n        if (s.taxAmount > 0) {\n            uint256 tax = userTaxRate(s.amount, msg.sender);\n            uint256 taxFreeAllc = _maxTaxfreeAllocation(msg.sender) * PCT_BASE;\n            if (taxFreeAllc >= s.share) {\n                refundTaxAmount = s.taxAmount;\n            } else {\n                refundTaxAmount = (left * tax) / POINT_BASE;\n            }\n            usdc.safeTransferFrom(marketingWallet, msg.sender, refundTaxAmount);\n        }\n        s.claimed = true;\n        usdc.safeTransfer(msg.sender, left);\n        emit Claim(msg.sender, left);\n    }\n\n    function _claim(Staked memory _s) internal view returns (uint120, uint256) {\n        uint256 left;\n        if (state.totalPrivateSold > (state.totalSupplyInValue)) {\n            uint256 rate = (state.totalSupplyInValue * PCT_BASE) /\n                state.totalPrivateSold;\n            _s.share = uint120((uint256(_s.amount) * rate) / PCT_BASE);\n            left = uint256(_s.amount) - uint256(_s.share);\n        } else {\n            _s.share = uint120(_s.amount);\n        }\n\n        return (_s.share, left);\n    }\n\n    function canClaim(address _user) external view returns (uint120, uint256) {\n        return _claim(stakes[_user]);\n    }\n\n    /**\n     * @dev sends Locked usdc to admin wallet\n     */\n\n    function takeLocked() external override {\n        _onlyAdmin();\n        require(\n            block.timestamp >= (params.privateEnd + 2592e3),\n            \"TokenSale: Not ended\"\n        );\n        uint256 amountUSDC = usdc.balanceOf(address(this));\n        if (amountUSDC > 0) {\n            usdc.safeTransfer(admin.wallet(), amountUSDC);\n        }\n    }\n\n    /**\n    @dev Total Tokens (in $) sold in IDO\n     */\n    function totalTokenSold() external view returns (uint128) {\n        return state.totalPrivateSold;\n    }\n}"
    },
    {
      "filename": "zap-contracts-labs/contracts/TokenSale.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"./interfaces/ITokenSale.sol\";\nimport \"./interfaces/IAdmin.sol\";\nimport \"./interfaces/IAirdrops.sol\";\nimport \"./interfaces/IERC20D.sol\";\nimport \"./interfaces/IStaking.sol\";\nimport \"hardhat/console.sol\";\n\n/*\nA tokensale includes 3 stages: \n1. Private round. Only ion token holders can participate in this round. \n The Matic/USDC price is fixed in the beginning of the tokensale.\n All tokens available in the pre-sale will be made available through the private sale round. \n A single investor can purchase up to their maximum allowed investment defined by the tier.\n Investors can claim their tokens only when the private round is finished. \n If the total supply is higher than the total demand for this tokensale, investors purchase tokens up to their max allocation. \n If the the demand is higher than supply, the number of tokens investors will receive is adjusted, and then the native token used to invest are partially refunded.\n\n*/\n\n//TODO Change USDC address\n//TODO Change Marketing wallet address\n\ncontract TokenSale is Initializable, ITokenSale {\n    using SafeERC20 for IERC20D;\n\n    uint256 constant PCT_BASE = 10 ** 18;\n    uint256 constant POINT_BASE = 1000;\n    bytes32 constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    address public marketingWallet;\n\n    uint256 public maxAllocation; // in dollar with decimals\n    uint256 public globalTaxRate; // base 1000\n    uint256 public whitelistTxRate; // base 1000\n    bool public isKYCEnabled;\n\n    IStaking stakingContract;\n    Params params;\n    IERC20D public usdc;\n    IAdmin admin;\n    /**\n     * @dev current tokensale stage (epoch)\n     */\n    Epoch public override epoch;\n    bool isRaiseClaimed;\n    bool only;\n    bytes32 public constant OPERATOR = keccak256(\"OPERATOR\");\n    address[] public usersOnDeposit;\n\n    mapping(address => Staked) public override stakes;\n    mapping(address => uint256) public tokensaleTiers;\n    /** @dev Decrease result by 1 to access correct position */\n    mapping(address => uint256) public userDepositIndex;\n    mapping(address => bool) public isWhitelisted;\n\n    State state;\n\n    receive() external payable {}\n\n    function getState() external view returns (uint128, uint128) {\n        return (state.totalPrivateSold, state.totalSupplyInValue);\n    }\n\n    function initialize(\n        Params calldata _params,\n        address _stakingContract,\n        address _admin,\n        uint256 _maxAllocation,\n        uint256 _globalTaxRate,\n        bool _isKYC,\n        uint256 _whitelistTxRate\n    ) external initializer {\n        params = _params;\n        stakingContract = IStaking(_stakingContract);\n        admin = IAdmin(_admin);\n        state.totalSupplyInValue = uint128(\n            (uint256(_params.totalSupply) *\n                uint256(_params.privateTokenPrice)) / 10 ** 18\n            // removes USDB hardcode of six, awful\n        );\n        usdc = IERC20D(0xA9F81589Cc48Ff000166Bf03B3804A0d8Cec8114); //TODO change for mainnet\n        marketingWallet = 0x6507fFd283c32386B6065EA89744Ade21515e91E; //TODO change for mainnet\n        maxAllocation = _maxAllocation;\n        globalTaxRate = _globalTaxRate;\n        isKYCEnabled = _isKYC;\n        whitelistTxRate = _whitelistTxRate;\n    }\n\n    // allocation is amount in dollar without decimals\n    function userWhitelistAllocation(\n        address[] calldata users,\n        uint256[] calldata allocations\n    ) public {\n        require(admin.hasRole(OPERATOR, msg.sender), \"TokenSale: OnlyOperator\");\n        require(\n            users.length == allocations.length,\n            \"TokenSale: Invalid length\"\n        );\n        for (uint256 i = 0; i < users.length; i++) {\n            tokensaleTiers[users[i]] = allocations[i];\n        }\n    }\n\n    function whitelistUser(address[] calldata users) public {\n        require(admin.hasRole(OPERATOR, msg.sender), \"TokenSale: OnlyOperator\");\n        for (uint256 i = 0; i < users.length; i++) {\n            isWhitelisted[users[i]] = true;\n        }\n    }\n\n    function setAllocationAndTax(uint256[3] calldata _allocations) external {\n        require(block.timestamp <= params.privateStart, \"Time lapsed\");\n        require(admin.hasRole(OPERATOR, msg.sender), \"TokenSale: OnlyOperator\");\n        maxAllocation = _allocations[0];\n        globalTaxRate = _allocations[1];\n        whitelistTxRate = _allocations[2];\n    }\n\n    function setMarketingWallet(address _wallet) external {\n        _onlyAdmin();\n        marketingWallet = _wallet;\n    }\n\n    /**\n     * @dev setup the current tokensale stage (epoch)\n     */\n    function checkingEpoch() public {\n        uint256 time = block.timestamp;\n        if (\n            epoch != Epoch.Private &&\n            time >= params.privateStart &&\n            time <= params.privateEnd\n        ) {\n            epoch = Epoch.Private;\n            return;\n        }\n        if ((epoch != Epoch.Finished && (time > params.privateEnd))) {\n            epoch = Epoch.Finished;\n            return;\n        }\n    }\n\n    // to save size\n    function _onlyAdmin() internal view {\n        require(\n            admin.hasRole(DEFAULT_ADMIN_ROLE, msg.sender) ||\n                msg.sender == address(admin),\n            \"TokenSale: Onlyadmin\"\n        );\n    }\n\n    /**\n     * @dev invest usdc to the tokensale\n     */\n    function deposit(uint256 _amount) external {\n        console.log(\"kyc enabled\", isKYCEnabled);\n        if (isKYCEnabled) {\n            require(admin.isKYCDone(msg.sender) == true, \"KYC not done\");\n        }\n        address sender = msg.sender;\n        require(\n            !admin.blacklist(address(this), sender),\n            \"TokenSale: Blacklisted\"\n        );\n        checkingEpoch();\n\n        require(epoch == Epoch.Private, \"TokenSale: Incorrect time\");\n        require(_amount > 0, \"TokenSale: 0 deposit\");\n\n        if (userDepositIndex[sender] == 0) {\n            usersOnDeposit.push(sender);\n            userDepositIndex[sender] = usersOnDeposit.length;\n        }\n        if (epoch == Epoch.Private) {\n            _processPrivate(sender, _amount);\n        }\n    }\n\n    function destroy() external override {\n        _onlyAdmin();\n        uint256 amountUSDC = usdc.balanceOf(address(this));\n        if (amountUSDC > 0) {\n            usdc.safeTransfer(admin.wallet(), amountUSDC);\n        }\n        address payable wallet = payable(admin.wallet());\n        selfdestruct(wallet);\n    }\n\n    /**\n     * @notice withdraw accidently sent ERC20 tokens\n     * @param _tokenAddress address of token to withdraw\n     */\n    function removeOtherERC20Tokens(address _tokenAddress) external {\n        _onlyAdmin();\n        require(\n            _tokenAddress != address(usdc),\n            \"TokenSale: Can't withdraw usdc\"\n        );\n        uint256 balance = IERC20D(_tokenAddress).balanceOf(address(this));\n        IERC20D(_tokenAddress).safeTransfer(admin.wallet(), balance);\n\n        emit ERC20TokensRemoved(_tokenAddress, msg.sender, balance);\n    }\n\n    /**\n     * @dev processing usdc investment to the private round\n     * @param _sender - transaction sender\n     * @param _amount - investment amount in usdc\n     */\n    function _processPrivate(address _sender, uint256 _amount) internal {\n        require(_amount > 0, \"TokenSale: Too small\");\n\n        Staked storage s = stakes[_sender];\n        uint256 amount = _amount * PCT_BASE;\n        uint256 sum = s.amount + amount;\n\n        uint256 maxAllocationOfUser = (calculateMaxAllocation(_sender)) *\n            PCT_BASE;\n        require(sum <= maxAllocationOfUser, \"upto max allocation\");\n        uint256 taxFreeAllcOfUser = 0; // hardcode zero - all pools have ax\n\n        uint256 userTaxAmount;\n\n        if (sum > taxFreeAllcOfUser) {\n            uint256 userTxRate = userTaxRate(sum, _sender);\n            if (s.amount < taxFreeAllcOfUser) {\n                userTaxAmount =\n                    ((sum - taxFreeAllcOfUser) * userTxRate) /\n                    POINT_BASE;\n            } else {\n                userTaxAmount = (amount * userTxRate) / POINT_BASE;\n            }\n        }\n\n        if (userTaxAmount > 0) {\n            s.taxAmount += userTaxAmount;\n            usdc.safeTransferFrom(_sender, marketingWallet, userTaxAmount);\n        }\n        s.amount += uint128(amount);\n        state.totalPrivateSold += uint128(amount);\n        usdc.safeTransferFrom(_sender, address(this), amount);\n\n        /**@notice Forbid unstaking*/\n        // stakingContract.setPoolsEndTime(_sender, uint256(params.privateEnd)); // TODO: uncomment\n        emit DepositPrivate(_sender, _amount, address(this));\n    }\n\n    /**\n     * @dev sends the usdc raise to admin's wallet\n     */\n\n    function calculateMaxAllocation(address _sender) public returns (uint256) {\n        uint256 userMaxAllc = _maxTierAllc(_sender);\n\n        if (userMaxAllc > maxAllocation) {\n            return userMaxAllc;\n        } else {\n            return maxAllocation;\n        }\n    }\n\n    function _maxTaxfreeAllocation(address _sender) internal returns (uint256) {\n        uint256 userTierAllc = stakingContract.getAllocationOf(_sender);\n        uint256 giftedTierAllc = tokensaleTiers[_sender];\n\n        if (userTierAllc > giftedTierAllc) {\n            return userTierAllc;\n        } else {\n            return giftedTierAllc;\n        }\n    }\n\n    function _maxTierAllc(address _sender) internal returns (uint256) {\n        (uint256 userTier, uint256 userLockLvl, , ) = stakingContract\n            .getUserState(_sender);\n\n        uint256 giftedTierAllc = tokensaleTiers[_sender];\n\n        if (userTier == 0 && giftedTierAllc == 0) {\n            return 0;\n        }\n\n        uint256 userTierAllc = stakingContract.getAllocationOf(_sender);\n        uint256 nextTierAllc;\n        if (userLockLvl > 0 && userLockLvl < 4) {\n            nextTierAllc = stakingContract.getAllocations(\n                userLockLvl + 1,\n                userTier\n            );\n        } else {\n            nextTierAllc = stakingContract.getAllocations(\n                userLockLvl,\n                userTier + 1\n            );\n        }\n\n        if (nextTierAllc > userTierAllc) {\n            if (nextTierAllc > giftedTierAllc) {\n                return nextTierAllc;\n            } else {\n                return giftedTierAllc;\n            }\n        } else {\n            if (userTierAllc > giftedTierAllc) {\n                return userTierAllc;\n            } else {\n                return giftedTierAllc;\n            }\n        }\n    }\n\n    // _amount should be in dollar without decimals\n    function userTaxRate(\n        uint256 _amount,\n        address _sender\n    ) public returns (uint256) {\n        uint256 userTaxFreeAllc = 0;\n\n        if (_amount > userTaxFreeAllc) {\n            if (isWhitelisted[_sender]) {\n                return whitelistTxRate;\n            } else {\n                return globalTaxRate;\n            }\n        } else {\n            return 0;\n        }\n    }\n\n    function takeUSDCRaised() external override {\n        checkingEpoch();\n        require(epoch == Epoch.Finished, \"TokenSale: Not time yet\");\n        require(!isRaiseClaimed, \"TokenSale: Already paid\");\n\n        uint256 earned;\n\n        if (state.totalPrivateSold > state.totalSupplyInValue) {\n            earned = uint256(state.totalSupplyInValue);\n        } else {\n            earned = uint256(state.totalPrivateSold);\n        }\n\n        isRaiseClaimed = true;\n\n        if (earned > 0) {\n            uint256 bal = usdc.balanceOf(address(this));\n            uint256 returnValue = earned <= bal ? earned : bal;\n            usdc.safeTransfer(admin.wallet(), returnValue);\n        }\n\n        emit RaiseClaimed(admin.wallet(), earned);\n    }\n\n    /**\n     * @dev allows the participants of the private round to claim usdc left\n     */\n    function claim() external {\n        checkingEpoch();\n        require(\n            uint8(epoch) > 1 && !admin.blockClaim(address(this)),\n            \"TokenSale: Not time or not allowed\"\n        );\n\n        Staked storage s = stakes[msg.sender];\n        require(s.amount != 0, \"TokenSale: No Deposit\");\n        require(!s.claimed, \"TokenSale: Already Claimed\");\n\n        uint256 left;\n        (s.share, left) = _claim(s);\n        require(left > 0, \"TokenSale: Nothing to claim\");\n        uint256 refundTaxAmount;\n        if (s.taxAmount > 0) {\n            uint256 tax = userTaxRate(s.amount, msg.sender);\n            uint256 taxFreeAllc = _maxTaxfreeAllocation(msg.sender) * PCT_BASE;\n            if (taxFreeAllc >= s.share) {\n                refundTaxAmount = s.taxAmount;\n            } else {\n                refundTaxAmount = (left * tax) / POINT_BASE;\n            }\n            usdc.safeTransferFrom(marketingWallet, msg.sender, refundTaxAmount);\n        }\n        s.claimed = true;\n        usdc.safeTransfer(msg.sender, left);\n        emit Claim(msg.sender, left);\n    }\n\n    function _claim(Staked memory _s) internal view returns (uint120, uint256) {\n        uint256 left;\n        if (state.totalPrivateSold > (state.totalSupplyInValue)) {\n            uint256 rate = (state.totalSupplyInValue * PCT_BASE) /\n                state.totalPrivateSold;\n            _s.share = uint120((uint256(_s.amount) * rate) / PCT_BASE);\n            left = uint256(_s.amount) - uint256(_s.share);\n        } else {\n            _s.share = uint120(_s.amount);\n        }\n\n        return (_s.share, left);\n    }\n\n    function canClaim(address _user) external view returns (uint120, uint256) {\n        return _claim(stakes[_user]);\n    }\n\n    /**\n     * @dev sends Locked usdc to admin wallet\n     */\n\n    function takeLocked() external override {\n        _onlyAdmin();\n        require(\n            block.timestamp >= (params.privateEnd + 2592e3),\n            \"TokenSale: Not ended\"\n        );\n        uint256 amountUSDC = usdc.balanceOf(address(this));\n        if (amountUSDC > 0) {\n            usdc.safeTransfer(admin.wallet(), amountUSDC);\n        }\n    }\n\n    /**\n    @dev Total Tokens (in $) sold in IDO\n     */\n    function totalTokenSold() external view returns (uint128) {\n        return state.totalPrivateSold;\n    }\n}"
    },
    {
      "filename": "zap-contracts-labs/contracts/TokenSale.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"./interfaces/ITokenSale.sol\";\nimport \"./interfaces/IAdmin.sol\";\nimport \"./interfaces/IAirdrops.sol\";\nimport \"./interfaces/IERC20D.sol\";\nimport \"./interfaces/IStaking.sol\";\nimport \"hardhat/console.sol\";\n\n/*\nA tokensale includes 3 stages: \n1. Private round. Only ion token holders can participate in this round. \n The Matic/USDC price is fixed in the beginning of the tokensale.\n All tokens available in the pre-sale will be made available through the private sale round. \n A single investor can purchase up to their maximum allowed investment defined by the tier.\n Investors can claim their tokens only when the private round is finished. \n If the total supply is higher than the total demand for this tokensale, investors purchase tokens up to their max allocation. \n If the the demand is higher than supply, the number of tokens investors will receive is adjusted, and then the native token used to invest are partially refunded.\n\n*/\n\n//TODO Change USDC address\n//TODO Change Marketing wallet address\n\ncontract TokenSale is Initializable, ITokenSale {\n    using SafeERC20 for IERC20D;\n\n    uint256 constant PCT_BASE = 10 ** 18;\n    uint256 constant POINT_BASE = 1000;\n    bytes32 constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    address public marketingWallet;\n\n    uint256 public maxAllocation; // in dollar with decimals\n    uint256 public globalTaxRate; // base 1000\n    uint256 public whitelistTxRate; // base 1000\n    bool public isKYCEnabled;\n\n    IStaking stakingContract;\n    Params params;\n    IERC20D public usdc;\n    IAdmin admin;\n    /**\n     * @dev current tokensale stage (epoch)\n     */\n    Epoch public override epoch;\n    bool isRaiseClaimed;\n    bool only;\n    bytes32 public constant OPERATOR = keccak256(\"OPERATOR\");\n    address[] public usersOnDeposit;\n\n    mapping(address => Staked) public override stakes;\n    mapping(address => uint256) public tokensaleTiers;\n    /** @dev Decrease result by 1 to access correct position */\n    mapping(address => uint256) public userDepositIndex;\n    mapping(address => bool) public isWhitelisted;\n\n    State state;\n\n    receive() external payable {}\n\n    function getState() external view returns (uint128, uint128) {\n        return (state.totalPrivateSold, state.totalSupplyInValue);\n    }\n\n    function initialize(\n        Params calldata _params,\n        address _stakingContract,\n        address _admin,\n        uint256 _maxAllocation,\n        uint256 _globalTaxRate,\n        bool _isKYC,\n        uint256 _whitelistTxRate\n    ) external initializer {\n        params = _params;\n        stakingContract = IStaking(_stakingContract);\n        admin = IAdmin(_admin);\n        state.totalSupplyInValue = uint128(\n            (uint256(_params.totalSupply) *\n                uint256(_params.privateTokenPrice)) / 10 ** 18\n            // removes USDB hardcode of six, awful\n        );\n        usdc = IERC20D(0xA9F81589Cc48Ff000166Bf03B3804A0d8Cec8114); //TODO change for mainnet\n        marketingWallet = 0x6507fFd283c32386B6065EA89744Ade21515e91E; //TODO change for mainnet\n        maxAllocation = _maxAllocation;\n        globalTaxRate = _globalTaxRate;\n        isKYCEnabled = _isKYC;\n        whitelistTxRate = _whitelistTxRate;\n    }\n\n    // allocation is amount in dollar without decimals\n    function userWhitelistAllocation(\n        address[] calldata users,\n        uint256[] calldata allocations\n    ) public {\n        require(admin.hasRole(OPERATOR, msg.sender), \"TokenSale: OnlyOperator\");\n        require(\n            users.length == allocations.length,\n            \"TokenSale: Invalid length\"\n        );\n        for (uint256 i = 0; i < users.length; i++) {\n            tokensaleTiers[users[i]] = allocations[i];\n        }\n    }\n\n    function whitelistUser(address[] calldata users) public {\n        require(admin.hasRole(OPERATOR, msg.sender), \"TokenSale: OnlyOperator\");\n        for (uint256 i ="
    }
  ]
}