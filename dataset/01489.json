{
  "Title": "M-8: `_accumulateFunding()` maker will get the wrong amount of funding fee.",
  "Content": "# Issue M-8: `_accumulateFunding()` maker will get the wrong amount of funding fee. \n\nSource: https://github.com/sherlock-audit/2023-07-perennial-judging/issues/139 \n\n## Found by \nWATCHPUG\n\n## Vulnerability Detail\n\nThe formula that calculates the amount of funding in `Version#_accumulateFunding()` on the maker side is incorrect. This leads to an incorrect distribution of funding between the minor and the maker's side.\n\n```solidity\n// Redirect net portion of minor's side to maker\nif (fromPosition.long.gt(fromPosition.short)) {\n    fundingValues.fundingMaker = fundingValues.fundingShort.mul(Fixed6Lib.from(fromPosition.skew().abs()));\n    fundingValues.fundingShort = fundingValues.fundingShort.sub(fundingValues.fundingMaker);\n}\nif (fromPosition.short.gt(fromPosition.long)) {\n    fundingValues.fundingMaker = fundingValues.fundingLong.mul(Fixed6Lib.from(fromPosition.skew().abs()));\n    fundingValues.fundingLong = fundingValues.fundingLong.sub(fundingValues.fundingMaker);\n}\n```\n\n## PoC\n\nGiven:\n\n- long/major: 1000\n- short/minor: 1\n- maker: 1\n\nThen:\n\n1. skew(): 999/1000\n2. fundingMaker: 0.999 of the funding\n3. fundingShort: 0.001 of the funding\n\nWhile the maker only matches for `1` of the major part and contributes to half of the total short side, it takes the entire funding.\n\n## Impact\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-07-perennial/blob/main/perennial-v2/packages/perennial/contracts/types/Version.sol#L207-L215\n\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe correct formula to calculate the amount of funding belonging to the maker side should be:\n\n```markdown\nfundingMakerRatio = min(maker, major - minor) / min(major, minor + maker)\nfundingMaker = fundingMakerRatio * fundingMinor\n```\n\n\n\n## Discussion\n\n**sherlock-admin**\n\n2 comment(s) were left on this issue during the judging contest.\n\n**__141345__** commented:\n> m\n\n**panprog** commented:\n> medium because incorrect result only starts appearing if abs(long-short) > maker and the larger the difference, the more incorrect the split of funding is. But this situation is exceptional case, most of the time abs(long-short) < maker due to efficiency and liquidity limits\n\n\n\n**arjun-io**\n\nWe'd like to re-open this as it does appear to be a valid issue. Medium severity seems correct here\n\n**arjun-io**\n\nFixed: https://github.com/equilibria-xyz/perennial-v2/pull/64\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/106",
  "Code": [
    {
      "filename": "perennial-v2/packages/perennial/contracts/types/Version.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/accumulator/types/Accumulator6.sol\";\nimport \"@equilibria/root/accumulator/types/UAccumulator6.sol\";\nimport \"./ProtocolParameter.sol\";\nimport \"./MarketParameter.sol\";\nimport \"./RiskParameter.sol\";\nimport \"./Global.sol\";\nimport \"./Position.sol\";\n\n/// @dev Version type\nstruct Version {\n    /// @dev whether this version had a valid oracle price\n    bool valid;\n\n    /// @dev The maker accumulator value\n    Accumulator6 makerValue;\n\n    /// @dev The long accumulator value\n    Accumulator6 longValue;\n\n    /// @dev The short accumulator value\n    Accumulator6 shortValue;\n\n    /// @dev The maker reward accumulator value\n    UAccumulator6 makerReward;\n\n    /// @dev The long reward accumulator value\n    UAccumulator6 longReward;\n\n    /// @dev The short reward accumulator value\n    UAccumulator6 shortReward;\n}\nusing VersionLib for Version global;\nstruct VersionStorage { uint256 slot0; uint256 slot1; }\nusing VersionStorageLib for VersionStorage global;\n\n/// @dev Individual accumulation values\nstruct VersionAccumulationResult {\n    UFixed6 positionFeeMaker;\n    UFixed6 positionFeeFee;\n\n    Fixed6 fundingMaker;\n    Fixed6 fundingLong;\n    Fixed6 fundingShort;\n    UFixed6 fundingFee;\n\n    Fixed6 interestMaker;\n    Fixed6 interestLong;\n    Fixed6 interestShort;\n    UFixed6 interestFee;\n\n    Fixed6 pnlMaker;\n    Fixed6 pnlLong;\n    Fixed6 pnlShort;\n\n    UFixed6 rewardMaker;\n    UFixed6 rewardLong;\n    UFixed6 rewardShort;\n}\n\n///@title Version\n/// @notice Library that manages global versioned accumulator state.\n/// @dev Manages two accumulators: value and reward. The value accumulator measures the change in position value\n///      over time, while the reward accumulator measures the change in position ownership over time.\nlibrary VersionLib {\n    /// @notice Accumulates the global state for the period from `fromVersion` to `toOracleVersion`\n    /// @param self The Version object to update\n    /// @param global The global state\n    /// @param fromPosition The previous latest position\n    /// @param toPosition The next latest position\n    /// @param fromOracleVersion The previous latest oracle version\n    /// @param toOracleVersion The next latest oracle version\n    /// @param marketParameter The market parameter\n    /// @param riskParameter The risk parameter\n    /// @return values The accumulation result\n    /// @return totalFee The total fee accumulated\n    function accumulate(\n        Version memory self,\n        Global memory global,\n        Position memory fromPosition,\n        Position memory toPosition,\n        OracleVersion memory fromOracleVersion,\n        OracleVersion memory toOracleVersion,\n        MarketParameter memory marketParameter,\n        RiskParameter memory riskParameter\n    ) internal pure returns (VersionAccumulationResult memory values, UFixed6 totalFee) {\n        // record validity\n        self.valid = toOracleVersion.valid;\n\n        if (marketParameter.closed) return (values, UFixed6Lib.ZERO);\n\n        // accumulate position fee\n        (values.positionFeeMaker, values.positionFeeFee) =\n            _accumulatePositionFee(self, fromPosition, toPosition, marketParameter);\n\n        // accumulate funding\n        _FundingValues memory fundingValues = _accumulateFunding(\n            self,\n            global,\n            fromPosition,\n            toPosition,\n            fromOracleVersion,\n            toOracleVersion,\n            marketParameter,\n            riskParameter\n        );\n        (values.fundingMaker, values.fundingLong, values.fundingShort, values.fundingFee) = (\n            fundingValues.fundingMaker,\n            fundingValues.fundingLong,\n            fundingValues.fundingShort,\n            fundingValues.fundingFee\n        );\n\n        // accumulate interest\n        (values.interestMaker,values.interestLong, values.interestShort, values.interestFee) =\n            _accumulateInterest(self, fromPosition, fromOracleVersion, toOracleVersion, marketParameter, riskParameter);\n\n        // accumulate P&L\n        (values.pnlMaker, values.pnlLong, values.pnlShort) =\n            _accumulatePNL(self, fromPosition, fromOracleVersion, toOracleVersion);\n\n        // accumulate reward\n        (values.rewardMaker, values.rewardLong, values.rewardShort) =\n            _accumulateReward(self, fromPosition, fromOracleVersion, toOracleVersion, marketParameter);\n\n        return (values, values.positionFeeFee.add(values.fundingFee).add(values.interestFee));\n    }\n\n    /// @notice Globally accumulates position fees since last oracle update\n    /// @param self The Version object to update\n    /// @param fromPosition The previous latest position\n    /// @param toPosition The next latest position\n    /// @param marketParameter The market parameter\n    /// @return positionFeeMaker The maker's position fee\n    /// @return positionFeeFee The protocol's position fee\n    function _accumulatePositionFee(\n        Version memory self,\n        Position memory fromPosition,\n        Position memory toPosition,\n        MarketParameter memory marketParameter\n    ) private pure returns (UFixed6 positionFeeMaker, UFixed6 positionFeeFee) {\n        // If there are no makers to distribute the taker's position fee to, give it to the protocol\n        if (fromPosition.maker.isZero()) return (UFixed6Lib.ZERO, toPosition.fee);\n\n        positionFeeFee = marketParameter.positionFee.mul(toPosition.fee);\n        positionFeeMaker = toPosition.fee.sub(positionFeeFee);\n\n        self.makerValue.increment(Fixed6Lib.from(positionFeeMaker), fromPosition.maker);\n    }\n\n    /// @dev Internal struct to bypass stack depth limit\n    struct _FundingValues {\n        Fixed6 fundingMaker;\n        Fixed6 fundingLong;\n        Fixed6 fundingShort;\n        UFixed6 fundingFee;\n    }\n\n    /// @notice Globally accumulates all long-short funding since last oracle update\n    /// @param self The Version object to update\n    /// @param global The global state\n    /// @param fromPosition The previous latest position\n    /// @param toPosition The next latest position\n    /// @param fromOracleVersion The previous latest oracle version\n    /// @param toOracleVersion The next latest oracle version\n    /// @param marketParameter The market parameter\n    /// @param riskParameter The risk parameter\n    /// @return fundingValues The funding values accumulated\n    function _accumulateFunding(\n        Version memory self,\n        Global memory global,\n        Position memory fromPosition,\n        Position memory toPosition,\n        OracleVersion memory fromOracleVersion,\n        OracleVersion memory toOracleVersion,\n        MarketParameter memory marketParameter,\n        RiskParameter memory riskParameter\n    ) private pure returns (_FundingValues memory fundingValues) {\n        // Compute long-short funding rate\n        Fixed6 funding = global.pAccumulator.accumulate(\n            riskParameter.pController,\n            toPosition.virtualSkew(riskParameter),\n            fromOracleVersion.timestamp,\n            toOracleVersion.timestamp,\n            fromPosition.takerSocialized().mul(fromOracleVersion.price.abs())\n        );\n\n        // Handle maker receive-only status\n        if (riskParameter.makerReceiveOnly && funding.sign() != fromPosition.skew().sign())\n            funding = funding.mul(Fixed6Lib.NEG_ONE);\n\n        // Initialize long and short funding\n        (fundingValues.fundingLong, fundingValues.fundingShort) = (Fixed6Lib.NEG_ONE.mul(funding), funding);\n\n        // Compute fee spread\n        fundingValues.fundingFee = funding.abs().mul(marketParameter.fundingFee);\n        Fixed6 fundingSpread = Fixed6Lib.from(fundingValues.fundingFee).div(Fixed6Lib.from(2));\n\n        // Adjust funding with spread\n        (fundingValues.fundingLong, fundingValues.fundingShort) = (\n            fundingValues.fundingLong.sub(Fixed6Lib.from(fundingValues.fundingFee)).add(fundingSpread),\n            fundingValues.fundingShort.sub(fundingSpread)\n        );\n\n        // Redirect net portion of minor's side to maker\n        if (fromPosition.long.gt(fromPosition.short)) {\n            fundingValues.fundingMaker = fundingValues.fundingShort.mul(Fixed6Lib.from(fromPosition.skew().abs()));\n            fundingValues.fundingShort = fundingValues.fundingShort.sub(fundingValues.fundingMaker);\n        }\n        if (fromPosition.short.gt(fromPosition.long)) {\n            fundingValues.fundingMaker = fundingValues.fundingLong.mul(Fixed6Lib.from(fromPosition.skew().abs()));\n            fundingValues.fundingLong = fundingValues.fundingLong.sub(fundingValues.fundingMaker);\n        }\n\n        self.makerValue.increment(fundingValues.fundingMaker, fromPosition.maker);\n        self.longValue.increment(fundingValues.fundingLong, fromPosition.long);\n        self.shortValue.increment(fundingValues.fundingShort, fromPosition.short);\n    }\n\n    /// @notice Globally accumulates all maker interest since last oracle update\n    /// @param self The Version object to update\n    /// @param position The previous latest position\n    /// @param fromOracleVersion The previous latest oracle version\n    /// @param toOracleVersion The next latest oracle version\n    /// @param marketParameter The market parameter\n    /// @param riskParameter The risk parameter\n    /// @return interestMaker The total interest accrued by makers\n    /// @return interestLong The total interest accrued by longs\n    /// @return interestShort The total interest accrued by shorts\n    /// @return interestFee The total fee accrued from interest accumulation\n    function _accumulateInterest(\n        Version memory self,\n        Position memory position,\n        OracleVersion memory fromOracleVersion,\n        OracleVersion memory toOracleVersion,\n        MarketParameter memory marketParameter,\n        RiskParameter memory riskParameter\n    ) private pure returns (Fixed6 interestMaker, Fixed6 interestLong, Fixed6 interestShort, UFixed6 interestFee) {\n        UFixed6 notional = position.long.add(position.short).min(position.maker).mul(fromOracleVersion.price.abs());\n\n        // Compute maker interest\n        UFixed6 interest = riskParameter.utilizationCurve.accumulate(\n            position.utilization(),\n            fromOracleVersion.timestamp,\n            toOracleVersion.timestamp,\n            notional\n        );\n\n        // Compute fee\n        interestFee = interest.mul(marketParameter.interestFee);\n\n        // Adjust long and short funding with spread\n        interestLong = Fixed6Lib.from(\n            position.major().isZero() ?\n            interest :\n            interest.muldiv(position.long, position.long.add(position.short))\n        );\n        interestShort = Fixed6Lib.from(interest).sub(interestLong);\n        interestMaker = Fixed6Lib.from(interest.sub(interestFee));\n\n        interestLong = interestLong.mul(Fixed6Lib.NEG_ONE);\n        interestShort = interestShort.mul(Fixed6Lib.NEG_ONE);\n        self.makerValue.increment(interestMaker, position.maker);\n        self.longValue.increment(interestLong, position.long);\n        self.shortValue.increment(interestShort, position.short);\n    }\n\n    /// @notice Globally accumulates position profit & loss since last oracle update\n    /// @param self The Version object to update\n    /// @param position The previous latest position\n    /// @param fromOracleVersion The previous latest oracle version\n    /// @param toOracleVersion The next latest oracle version\n    /// @return pnlMaker The total pnl accrued by makers\n    /// @return pnlLong The total pnl accrued by longs\n    /// @return pnlShort The total pnl accrued by shorts\n    function _accumulatePNL(\n        Version memory self,\n        Position memory position,\n        OracleVersion memory fromOracleVersion,\n        OracleVersion memory toOracleVersion\n    ) private pure returns (Fixed6 pnlMaker, Fixed6 pnlLong, Fixed6 pnlShort) {\n        pnlLong = toOracleVersion.price.sub(fromOracleVersion.price)\n            .mul(Fixed6Lib.from(position.longSocialized()));\n        pnlShort = fromOracleVersion.price.sub(toOracleVersion.price)\n            .mul(Fixed6Lib.from(position.shortSocialized()));\n        pnlMaker = pnlLong.add(pnlShort).mul(Fixed6Lib.NEG_ONE);\n\n        self.longValue.increment(pnlLong, position.long);\n        self.shortValue.increment(pnlShort, position.short);\n        self.makerValue.increment(pnlMaker, position.maker);\n    }\n\n    /// @notice Globally accumulates position's reward share since last oracle update\n    /// @param self The Version object to update\n    /// @param position The previous latest position\n    /// @param fromOracleVersion The previous latest oracle version\n    /// @param toOracleVersion The next latest oracle version\n    /// @param marketParameter The market parameter\n    /// @return rewardMaker The total reward accrued by makers\n    /// @return rewardLong The total reward accrued by longs\n    /// @return rewardShort The total reward accrued by shorts\n    function _accumulateReward(\n        Version memory self,\n        Position memory position,\n        OracleVersion memory fromOracleVersion,\n        OracleVersion memory toOracleVersion,\n        MarketParameter memory marketParameter\n    ) private pure returns (UFixed6 rewardMaker, UFixed6 rewardLong, UFixed6 rewardShort) {\n        UFixed6 elapsed = UFixed6Lib.from(toOracleVersion.timestamp - fromOracleVersion.timestamp);\n\n        if (!position.maker.isZero()) {\n            rewardMaker = elapsed.mul(marketParameter.makerRewardRate);\n            self.makerReward.increment(rewardMaker, position.maker);\n        }\n        if (!position.long.isZero()) {\n            rewardLong = elapsed.mul(marketParameter.longRewardRate);\n            self.longReward.increment(rewardLong, position.long);\n        }\n        if (!position.short.isZero()) {\n            rewardShort = elapsed.mul(marketParameter.shortRewardRate);\n            self.shortReward.increment(rewardShort, position.short);\n        }\n    }\n}\n\n/// @dev Manually encodes and decodes the Version struct into storage.\n///\n///     struct StoredVersion {\n///         /* slot 0 */\n///         bool valid;\n///         int64 makerValue;\n///         int64 longValue;\n///         int64 shortValue;\n///\n///         /* slot 1 */\n///         uint64 makerReward;\n///         uint64 longReward;\n///         uint64 shortReward;\n///     }\n///\nlibrary VersionStorageLib {\n    error VersionStorageInvalidError();\n\n    function read(VersionStorage storage self) internal view returns (Version memory) {\n        (uint256 slot0, uint256 slot1) = (self.slot0, self.slot1);\n        return Version(\n            (uint256(slot0 << (256 - 8)) >> (256 - 8)) != 0,\n            Accumulator6(Fixed6.wrap(int256(slot0 << (256 - 8 - 64)) >> (256 - 64))),\n            Accumulator6(Fixed6.wrap(int256(slot0 << (256 - 8 - 64 - 64)) >> (256 - 64))),\n            Accumulator6(Fixed6.wrap(int256(slot0 << (256 - 8 - 64 - 64 - 64)) >> (256 - 64))),\n            UAccumulator6(UFixed6.wrap(uint256(slot1 << (256 - 64)) >> (256 - 64))),\n            UAccumulator6(UFixed6.wrap(uint256(slot1 << (256 - 64 - 64)) >> (256 - 64))),\n            UAccumulator6(UFixed6.wrap(uint256(slot1 << (256 - 64 - 64 - 64)) >> (256 - 64)))\n        );\n    }\n\n    function store(VersionStorage storage self, Version memory newValue) internal {\n        if (newValue.makerValue._value.gt(Fixed6.wrap(type(int64).max))) revert VersionStorageInvalidError();\n        if (newValue.makerValue._value.lt(Fixed6.wrap(type(int64).min))) revert VersionStorageInvalidError();\n        if (newValue.longValue._value.gt(Fixed6.wrap(type(int64).max))) revert VersionStorageInvalidError();\n        if (newValue.longValue._value.lt(Fixed6.wrap(type(int64).min))) revert VersionStorageInvalidError();\n        if (newValue.shortValue._value.gt(Fixed6.wrap(type(int64).max))) revert VersionStorageInvalidError();\n        if (newValue.shortValue._value.lt(Fixed6.wrap(type(int64).min))) revert VersionStorageInvalidError();\n        if (newValue.makerReward._value.gt(UFixed6.wrap(type(uint64).max))) revert VersionStorageInvalidError();\n        if (newValue.longReward._value.gt(UFixed6.wrap(type(uint64).max))) revert VersionStorageInvalidError();\n        if (newValue.shortReward._value.gt(UFixed6.wrap(type(uint64).max))) revert VersionStorageInvalidError();\n\n        uint256 encoded0 =\n            uint256((newValue.valid ? uint256(1) : uint256(0)) << (256 - 8)) >> (256 - 8) |\n            uint256(Fixed6.unwrap(newValue.makerValue._value) << (256 - 64)) >> (256 - 8 - 64) |\n            uint256(Fixed6.unwrap(newValue.longValue._value) << (256 - 64)) >> (256 - 8 - 64 - 64) |\n            uint256(Fixed6.unwrap(newValue.shortValue._value) << (256 - 64)) >> (256 - 8 - 64 - 64 - 64);\n        uint256 encoded1 =\n            uint256(UFixed6.unwrap(newValue.makerReward._value) << (256 - 64)) >> (256 - 64) |\n            uint256(UFixed6.unwrap(newValue.longReward._value) << (256 - 64)) >> (256 - 64 - 64) |\n            uint256(UFixed6.unwrap(newValue.shortReward._value) << (256 - 64)) >> (256 - 64 - 64 - 64);\n\n        assembly {\n            sstore(self.slot, encoded0)\n            sstore(add(self.slot, 1), encoded1)\n        }\n    }\n}"
    }
  ]
}