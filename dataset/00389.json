{
  "Title": "M-1: The `_zapIn` function may unexpectedly revert due to the incorrect implementation of `_transferTokenInAndApprove`",
  "Content": "# Issue M-1: The `_zapIn` function may unexpectedly revert due to the incorrect implementation of `_transferTokenInAndApprove` \n\nSource: https://github.com/sherlock-audit/2024-03-amphor-judging/issues/1 \n\n## Found by \n0xLogos, Krace, Tricko, Varun\\_05, aslanbek, cawfree, den\\_sosnovskyi, merlin, n1punp, nine9, no, whitehair0330, zzykxx\n## Summary\n\nThe `_transferTokenInAndApprove` function should approve the `router` on behalf of the *VaultZapper* contract. However, it checks the allowance from `msgSender` to the `router`, rather than the *VaultZapper*. This potentially results in the *VaultZapper* not approving the `router` and causing unexpected reverting.\n\n## Vulnerability Detail\n\nThe allowance check in the `_transferTokenInAndApprove` function should verify that `address(this)` has approved sufficient amount of `tokenIn` to the `router`. However, it currently checks the allowance of `_msgSender()`, which is unnecessary and may cause transaction reverting if `_msgSender` had previously approved the `router`.\n\n```solidity\n    function _transferTokenInAndApprove(\n        address router,\n        IERC20 tokenIn,\n        uint256 amount\n    )\n        internal\n    {\n        tokenIn.safeTransferFrom(_msgSender(), address(this), amount);\n//@ The check of allowance is useless, we should check the allowance from address(this) rather than the msgSender\n        if (tokenIn.allowance(_msgSender(), router) < amount) {\n            tokenIn.forceApprove(router, amount);\n        }\n    }\n```\n\n\n**POC**\n\nApply the patch to `asynchronous-vault/test/Zapper/ZapperDeposit.t.sol` to add the test case and run it with `forge test --match-test test_zapIn --ffi`.\n\n```diff\ndiff --git a/asynchronous-vault/test/Zapper/ZapperDeposit.t.sol b/asynchronous-vault/test/Zapper/ZapperDeposit.t.sol\nindex 9083127..ff11b56 100644\n--- a/asynchronous-vault/test/Zapper/ZapperDeposit.t.sol\n+++ b/asynchronous-vault/test/Zapper/ZapperDeposit.t.sol\n@@ -17,6 +17,25 @@ contract VaultZapperDeposit is OffChainCalls {\n         zapper = new VaultZapper();\n     }\n\n+    function test_zapIn() public {\n+        Swap memory params =\n+            Swap(_router, _USDC, _WSTETH, 1500 * 1e6, 1, address(0), 20);\n+        _setUpVaultAndZapper(_WSTETH);\n+\n+        IERC4626 vault = _vault;\n+        bytes memory swapData =\n+            _getSwapData(address(zapper), address(zapper), params);\n+\n+        _getTokenIn(params);\n+\n+        // If the msgSender() happend to approve the SwapRouter before, then the zap will always revert\n+        IERC20(params.tokenIn).approve(address(params.router), params.amount);\n+        zapper.zapAndDeposit(\n+            params.tokenIn, vault, params.router, params.amount, swapData\n+        );\n+\n+    }\n+\n     //// test_zapAndDeposit ////\n     function test_zapAndDepositUsdcWSTETH() public {\n         Swap memory usdcToWstEth =\n```\n\nResult:\n```javascript\nRan 1 test for test/Zapper/ZapperDeposit.t.sol:VaultZapperDeposit\n[FAIL. Reason: SwapFailed(\"\\u{8}�y�\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0 \\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0(ERC20: transfer amount exceeds allowance\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\")] test_zapIn() (gas: 4948462)\nSuite result: FAILED. 0 passed; 1 failed; 0 skipped; finished in 20.84s (18.74s CPU time)\n\nRan 1 test suite in 22.40s (20.84s CPU time): 0 tests passed, 1 failed, 0 skipped (1 total tests)\n\nFailing tests:\nEncountered 1 failing test in test/Zapper/ZapperDeposit.t.sol:VaultZapperDeposit\n[FAIL. Reason: SwapFailed(\"\\u{8}�y�\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0 \\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0(ERC20: transfer amount exceeds allowance\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\")] test_zapIn() (gas: 4948462)\n```\n\n## Impact\n\nThis issue could lead to transaction reverting when users interact with the contract normally, thereby affecting the contract's regular functionality.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-03-amphor/blob/6c797025ffe296e04607abf74400ff2bb36a7de3/asynchronous-vault/src/VaultZapper.sol#L160-L171\n\n## Tool used\n\nFoundry\n\n## Recommendation\n\nFix the issue:\n```diff\ndiff --git a/asynchronous-vault/src/VaultZapper.sol b/asynchronous-vault/src/VaultZapper.sol\nindex 9943535..9cf6df9 100644\n--- a/asynchronous-vault/src/VaultZapper.sol\n+++ b/asynchronous-vault/src/VaultZapper.sol\n@@ -165,7 +165,7 @@ contract VaultZapper is Ownable2Step, Pausable {\n         internal\n     {\n         tokenIn.safeTransferFrom(_msgSender(), address(this), amount);\n-        if (tokenIn.allowance(_msgSender(), router) < amount) {\n+        if (tokenIn.allowance(address(this), router) < amount) {\n             tokenIn.forceApprove(router, amount);\n         }\n     }\n```\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  seem valid; medium(3)\n\n\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/AmphorProtocol/asynchronous-vault/pull/103.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/244",
  "Code": [
    {
      "filename": "asynchronous-vault/src/VaultZapper.sol",
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport {\n    Ownable2Step,\n    Ownable\n} from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport { Pausable } from \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport { SafeERC20 } from\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { IERC7540, IERC4626 } from \"./interfaces/IERC7540.sol\";\nimport { PermitParams, AsyncSynthVault } from \"./AsyncSynthVault.sol\";\nimport { ERC20Permit } from\n    \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\ncontract VaultZapper is Ownable2Step, Pausable {\n    /**\n     * @dev The `SafeERC20` lib is only used for `safeTransfer`,\n     * `safeTransferFrom` and `forceApprove` operations.\n     */\n    using SafeERC20 for IERC20;\n\n    /**\n     * @dev The `Address` lib is only used for `sendValue` operations.\n     */\n    using Address for address payable;\n\n    mapping(IERC4626 vault => bool isAuthorized) public authorizedVaults;\n    mapping(address routerAddress => bool isAuthorized) public authorizedRouters;\n\n    event ZapAndRequestDeposit(\n        IERC7540 indexed vault,\n        address indexed router,\n        IERC20 tokenIn,\n        uint256 amount\n    );\n    event ZapAndDeposit(\n        IERC4626 indexed vault,\n        address indexed router,\n        IERC20 tokenIn,\n        uint256 amount,\n        uint256 shares\n    );\n    event ClaimRedeemAndZap(\n        IERC7540 indexed vault,\n        address indexed router,\n        uint256 shares,\n        uint256 assets\n    );\n    event RouterApproved(address indexed router, IERC20 indexed token);\n    event RouterAuthorized(address indexed router, bool allowed);\n    event VaultAuthorized(IERC4626 indexed vault, bool allowed);\n\n    error NotRouter(address router);\n    error NotVault(IERC4626 vault);\n    error SwapFailed(string reason);\n    error InconsistantSwapData(\n        uint256 expectedTokenInBalance, uint256 actualTokenInBalance\n    );\n    error NotEnoughSharesMinted(uint256 sharesMinted, uint256 minSharesMinted);\n    error NotEnoughUnderlying(\n        uint256 previewedUnderlying, uint256 withdrawedUnderlying\n    );\n    error NullMinShares();\n\n    modifier onlyAllowedRouter(address router) {\n        if (!authorizedRouters[router]) revert NotRouter(router);\n        _;\n    }\n\n    modifier onlyAllowedVault(IERC4626 vault) {\n        if (!authorizedVaults[vault]) revert NotVault(vault);\n        _;\n    }\n\n    constructor() Ownable(_msgSender()) { }\n\n    /**\n     * @param token The IERC20 token to be claimed.\n     */\n    function withdrawToken(IERC20 token) external onlyOwner {\n        token.safeTransfer(_msgSender(), token.balanceOf(address(this)));\n    }\n\n    function withdrawNativeToken() external onlyOwner {\n        payable(_msgSender()).sendValue(address(this).balance);\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function approveTokenForRouter(\n        IERC20 token,\n        address router\n    )\n        public\n        onlyOwner\n        onlyAllowedRouter(router)\n    {\n        token.forceApprove(router, type(uint256).max);\n        emit RouterApproved(router, token);\n    }\n\n    function toggleRouterAuthorization(address router) public onlyOwner {\n        bool authorized = !authorizedRouters[router];\n        authorizedRouters[router] = authorized;\n        emit RouterAuthorized(router, authorized);\n    }\n\n    function toggleVaultAuthorization(IERC7540 vault) public onlyOwner {\n        bool authorized = !authorizedVaults[vault];\n        IERC20(vault.asset()).forceApprove(\n            address(vault), authorized ? type(uint256).max : 0\n        );\n        authorizedVaults[vault] = authorized;\n        emit VaultAuthorized(vault, authorized);\n    }\n\n    // internal function used only to execute the zap before request a deposit\n    function _zapIn(\n        IERC20 tokenIn,\n        address router,\n        uint256 amount,\n        bytes calldata data\n    )\n        internal\n    {\n        uint256 expectedBalance; // of tokenIn (currently)\n\n        if (msg.value == 0) {\n            expectedBalance = tokenIn.balanceOf(address(this));\n            _transferTokenInAndApprove(router, tokenIn, amount);\n        } else {\n            expectedBalance = address(this).balance - msg.value;\n        }\n\n        _executeZap(router, data); // zap\n\n        uint256 balanceAfterZap = msg.value == 0\n            ? tokenIn.balanceOf(address(this))\n            : address(this).balance;\n\n        if (balanceAfterZap > expectedBalance) {\n            // Our balance is higher than expected, we shouldn't have received\n            // any token\n            revert InconsistantSwapData({\n                expectedTokenInBalance: expectedBalance,\n                actualTokenInBalance: balanceAfterZap\n            });\n        }\n    }\n\n    function _transferTokenInAndApprove(\n        address router,\n        IERC20 tokenIn,\n        uint256 amount\n    )\n        internal\n    {\n        tokenIn.safeTransferFrom(_msgSender(), address(this), amount);\n        if (tokenIn.allowance(_msgSender(), router) < amount) {\n            tokenIn.forceApprove(router, amount);\n        }\n    }\n\n    /*\n     ########################\n      USER RELATED FUNCTIONS\n     ########################\n    */\n    function zapAndDeposit(\n        IERC20 tokenIn,\n        IERC4626 vault,\n        address router,\n        uint256 amount,\n        bytes calldata data\n    )\n        public\n        payable\n        onlyAllowedRouter(router)\n        onlyAllowedVault(vault)\n        whenNotPaused\n        returns (uint256)\n    {\n        uint256 initialTokenOutBalance =\n            IERC20(vault.asset()).balanceOf(address(this)); // tokenOut balance to\n            // deposit, not final value\n\n        // Zap\n        _zapIn(tokenIn, router, amount, data);\n\n        // Deposit\n        uint256 shares = vault.deposit(\n            IERC20(vault.asset()).balanceOf(address(this))\n                - initialTokenOutBalance,\n            _msgSender()\n        );\n\n        emit ZapAndDeposit({\n            vault: vault,\n            router: router,\n            tokenIn: tokenIn,\n            amount: amount,\n            shares: shares\n        });\n\n        return shares;\n    }\n\n    function zapAndRequestDeposit(\n        IERC20 tokenIn,\n        IERC7540 vault,\n        address router,\n        uint256 amountIn,\n        bytes calldata data,\n        bytes calldata swapData\n    )\n        public\n        payable\n        onlyAllowedRouter(router)\n        onlyAllowedVault(vault)\n        whenNotPaused\n    {\n        uint256 initialTokenOutBalance =\n            IERC20(vault.asset()).balanceOf(address(this)); // tokenOut balance to\n            // deposit, not final value\n\n        // Zap\n        _zapIn(tokenIn, router, amountIn, swapData);\n\n        // Request deposit\n        vault.requestDeposit(\n            IERC20(vault.asset()).balanceOf(address(this))\n                - initialTokenOutBalance,\n            _msgSender(),\n            address(this),\n            data\n        );\n\n        emit ZapAndRequestDeposit({\n            vault: vault,\n            router: router,\n            tokenIn: tokenIn,\n            amount: amountIn\n        });\n    }\n\n    function zapAndClaimAndRequestDeposit(\n        IERC20 tokenIn,\n        AsyncSynthVault vault,\n        address router,\n        uint256 amountIn,\n        bytes calldata data,\n        bytes calldata swapData\n    )\n        public\n        payable\n        onlyAllowedRouter(router)\n        onlyAllowedVault(vault)\n        whenNotPaused\n    {\n        uint256 initialTokenOutBalance =\n            IERC20(vault.asset()).balanceOf(address(this)); // tokenOut balance to\n            // deposit, not final value\n\n        // Zap\n        _zapIn(tokenIn, router, amountIn, swapData);\n\n        // Claim for the user and request deposit\n        vault.claimAndRequestDeposit(\n            IERC20(vault.asset()).balanceOf(address(this))\n                - initialTokenOutBalance,\n            _msgSender(),\n            data\n        );\n\n        emit ZapAndRequestDeposit({\n            vault: vault,\n            router: router,\n            tokenIn: tokenIn,\n            amount: amountIn\n        });\n    }\n\n    /*\n     ##########################\n      PERMIT RELATED FUNCTIONS\n     ##########################\n    */\n\n    function zapAndDepositWithPermit(\n        IERC20 tokenIn,\n        IERC4626 vault,\n        address router,\n        uint256 amount,\n        bytes calldata swapData,\n        PermitParams calldata permitParams\n    )\n        public\n        returns (uint256)\n    {\n        if (tokenIn.allowance(_msgSender(), address(this)) < amount) {\n            _executePermit(tokenIn, _msgSender(), address(this), permitParams);\n        }\n        return zapAndDeposit(tokenIn, vault, router, amount, swapData);\n    }\n\n    function zapAndRequestDepositWithPermit(\n        IERC20 tokenIn,\n        IERC7540 vault,\n        address router,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata swapData,\n        PermitParams calldata permitParams\n    )\n        public\n    {\n        if (tokenIn.allowance(_msgSender(), address(this)) < amount) {\n            _executePermit(tokenIn, _msgSender(), address(this), permitParams);\n        }\n        zapAndRequestDeposit(tokenIn, vault, router, amount, data, swapData);\n    }\n\n    function zapAndClaimAndRequestDepositWithPermit(\n        IERC20 tokenIn,\n        AsyncSynthVault vault,\n        address router,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata swapData,\n        PermitParams calldata permitParams\n    )\n        public\n    {\n        if (tokenIn.allowance(_msgSender(), address(this)) < amount) {\n            _executePermit(tokenIn, _msgSender(), address(this), permitParams);\n        }\n        zapAndClaimAndRequestDeposit(\n            tokenIn, vault, router, amount, data, swapData\n        );\n    }\n\n    function _executeZap(\n        address target,\n        bytes memory data\n    )\n        internal\n        returns (bytes memory response)\n    {\n        (bool success, bytes memory _data) =\n            target.call{ value: msg.value }(data);\n        if (!success) {\n            if (data.length > 0) revert SwapFailed(string(_data));\n            else revert SwapFailed(\"Unknown reason\");\n        }\n        return _data;\n    }\n\n    function _executePermit(\n        IERC20 token,\n        address owner,\n        address spender,\n        PermitParams calldata permitParams\n    )\n        internal\n    {\n        ERC20Permit(address(token)).permit(\n            owner,\n            spender,\n            permitParams.value,\n            permitParams.deadline,\n            permitParams.v,\n            permitParams.r,\n            permitParams.s\n        );\n    }\n}"
    }
  ]
}