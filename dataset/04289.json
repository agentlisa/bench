{
  "Title": "[H01] Insolvent initial position",
  "Content": "The initial sponsor in any contract is free to [open a position](https://github.com/UMAprotocol/protocol/blob/e6eaa48124ae3f209fb117cf05eb18292cf26d21/core/contracts/financial-templates/implementation/PricelessPositionManager.sol#L303) with any amount of tokens for any amount of collateral, even if it would be insolvent. Since it is non-economical to liquidate an insolvent position, they will not be liquidated. Although, the UMA team [intends to liquidate insolvent positions](https://github.com/UMAprotocol/protocol/blob/92c9dfbbffd2cf394498ff745f95bcb5e2a6f138/documentation/synthetic_tokens/known_issues.md#no-haircut-mechanisms-implemented), some discretion would be necessary (or UMA will become a money pump).\n\n\nThis has two important consequences. Firstly, if the sponsor sold their synthetic tokens for the nominal face value, the recipient would be unable to settle them upon contract expiration. Secondly, if there are any other users with open positions when the contract expires, their collateral becomes vulnerable to theft by the initial sponsor.\n\n\nIn both cases, the issue could be prevented by due diligence. Yet if all traders and borrowers were expected to check the collateralization ratio before using synthetic tokens, it would severely limit the usability of the system.\n\n\nUnfortunately, the described situation can occur multiple times in the same financial contract if all positions are closed and a new one is opened. Nevertheless, the system must prevent insolvent contracts in order to function correctly.\n\n\nConsider submitting a price request before the first position is opened (as well as in subsequent “initial” positions) to ensure it is collateralized. Should this be prohibitive, consider requiring the initial sponsor to submit a liquidation bond that must expire before they receive their tokens.\n\n\nAlternatively, consider preventing users from completely withdrawing, redeeming or liquidating the final position. This would not prevent an initial insolvent position but it would strengthen the guarantee that a healthy contract will remain collateralized.\n\n\n**Update:** *The issue is acknowledged, but the implementation will remain unchanged to maintain the user experience. In the (abridged) words of the UMA team:*\n\n\n\n> \n>  We believe the UX and complexity tradeoffs of a lockup period outweigh the downside of asking new participants to be aware of the solvency of the contract they’re participating in. As for a contract returning to this state, token holders can be assured that as long as they hold a single token, this initial state cannot be reached again. Similarly, a sponsor can be assured that collateral introduced while the contract is solvent cannot be taken unfairly […] We do think this issue should be solved, but we think that it would be better done through a more major re-architecture of the contract for V2.\n> \n> \n> \n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "core/contracts/financial-templates/implementation/PricelessPositionManager.sol",
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../../common/implementation/FixedPoint.sol\";\nimport \"../../common/implementation/Testable.sol\";\nimport \"../../common/interfaces/ExpandedIERC20.sol\";\nimport \"../../oracle/interfaces/OracleInterface.sol\";\nimport \"../../oracle/interfaces/IdentifierWhitelistInterface.sol\";\nimport \"../../oracle/interfaces/AdministrateeInterface.sol\";\nimport \"./TokenFactory.sol\";\nimport \"./FeePayer.sol\";\n\n\n/**\n * @title Financial contract with priceless position management.\n * @notice Handles positions for multiple sponsors in an optimistic (i.e., priceless) way without relying\n * on a price feed. On construction, deploys a new ERC20, managed by this contract, that is the synthetic token.\n */\n\ncontract PricelessPositionManager is FeePayer, AdministrateeInterface {\n    using SafeMath for uint;\n    using FixedPoint for FixedPoint.Unsigned;\n    using SafeERC20 for IERC20;\n    using SafeERC20 for ExpandedIERC20;\n\n    /****************************************\n     *  PRICELESS POSITION DATA STRUCTURES  *\n     ****************************************/\n\n    // Enum to store the state of the PricelessPositionManager. Set on expiration or emergency shutdown.\n    enum ContractState { Open, ExpiredPriceRequested, ExpiredPriceReceived }\n    ContractState public contractState;\n\n    // Represents a single sponsor's position. All collateral is held by this contract.\n    // This struct acts is bookkeeping for how much of that collateral is allocated to each sponsor.\n    struct PositionData {\n        FixedPoint.Unsigned tokensOutstanding;\n        // Tracks pending withdrawal requests. A withdrawal request is pending if `requestPassTimestamp != 0`.\n        uint requestPassTimestamp;\n        FixedPoint.Unsigned withdrawalRequestAmount;\n        // Raw collateral value. This value should never be accessed directly -- always use _getCollateral().\n        // To add or remove collateral, use _addCollateral() and _removeCollateral().\n        FixedPoint.Unsigned rawCollateral;\n    }\n\n    // Maps sponsor addresses to their positions. Each sponsor can have only one position.\n    mapping(address => PositionData) public positions;\n\n    // Keep track of the total collateral and tokens across all positions to enable calculating the\n    // global collateralization ratio without iterating over all positions.\n    FixedPoint.Unsigned public totalTokensOutstanding;\n\n    // Similar to the rawCollateral in PositionData, this value should not be used directly.\n    // _getCollateral(), _addCollateral() and _removeCollateral() must be used to access and adjust.\n    FixedPoint.Unsigned public rawTotalPositionCollateral;\n\n    // Synthetic token created by this contract.\n    ExpandedIERC20 public tokenCurrency;\n\n    // Unique identifier for DVM price feed ticker.\n    bytes32 public priceIdentifer;\n    // Time that this contract expires. Should not change post-construction unless a emergency shutdown occurs.\n    uint public expirationTimestamp;\n    // Time that has to elapse for a withdrawal request to be considered passed, if no liquidations occur.\n    uint public withdrawalLiveness;\n\n    // Minimum number of tokens in a sponsor's position.\n    FixedPoint.Unsigned public minSponsorTokens;\n\n    // The expiry price pulled from the DVM.\n    FixedPoint.Unsigned public expiryPrice;\n\n    /****************************************\n     *                EVENTS                *\n     ****************************************/\n\n    event Transfer(address indexed oldSponsor, address indexed newSponsor);\n    event Deposit(address indexed sponsor, uint indexed collateralAmount);\n    event Withdrawal(address indexed sponsor, uint indexed collateralAmount);\n    event RequestWithdrawal(address indexed sponsor, uint indexed collateralAmount);\n    event RequestWithdrawalExecuted(address indexed sponsor, uint indexed collateralAmount);\n    event RequestWithdrawalCanceled(address indexed sponsor, uint indexed collateralAmount);\n    event PositionCreated(address indexed sponsor, uint indexed collateralAmount, uint indexed tokenAmount);\n    event NewSponsor(address indexed sponsor);\n    event EndedSponsor(address indexed sponsor);\n    event Redeem(address indexed sponsor, uint indexed collateralAmount, uint indexed tokenAmount);\n    event ContractExpired(address indexed caller);\n    event SettleExpiredPosition(address indexed caller, uint indexed collateralReturned, uint indexed tokensBurned);\n    event EmergencyShutdown(address indexed caller, uint originalExpirationTimestamp, uint shutdownTimestamp);\n\n    /****************************************\n     *               MODIFIERS              *\n     ****************************************/\n\n    modifier onlyPreExpiration() {\n        _onlyPreExpiration();\n        _;\n    }\n\n    modifier onlyPostExpiration() {\n        _onlyPostExpiration();\n        _;\n    }\n\n    modifier onlyCollateralizedPosition(address sponsor) {\n        _onlyCollateralizedPosition(sponsor);\n        _;\n    }\n\n    // Check that the current state of the pricelessPositionManager is Open.\n    // This prevents multiple calls to `expire` and `EmergencyShutdown` post expiration.\n    modifier onlyOpenState() {\n        _onlyOpenState();\n        _;\n    }\n\n    /**\n     * @notice Construct the PricelessPositionManager\n     * @param _isTest whether this contract is being constructed for the purpose of running tests.\n     * @param _expirationTimestamp unix timestamp of when the contract will expire.\n     * @param _withdrawalLiveness liveness delay, in seconds, for pending withdrawals.\n     * @param _collateralAddress ERC20 token used as collateral for all positions.\n     * @param _finderAddress UMA protocol Finder used to discover other protocol contracts.\n     * @param _priceIdentifier registered in the DVM for the synthetic.\n     * @param _syntheticName name for the token contract that will be deployed.\n     * @param _syntheticSymbol symbol for the token contract that will be deployed.\n     * @param _tokenFactoryAddress deployed UMA token factory to create the synthetic token.\n     */\n    constructor(\n        bool _isTest,\n        uint _expirationTimestamp,\n        uint _withdrawalLiveness,\n        address _collateralAddress,\n        address _finderAddress,\n        bytes32 _priceIdentifier,\n        string memory _syntheticName,\n        string memory _syntheticSymbol,\n        address _tokenFactoryAddress,\n        FixedPoint.Unsigned memory _minSponsorTokens\n    ) public FeePayer(_collateralAddress, _finderAddress, _isTest) {\n        expirationTimestamp = _expirationTimestamp;\n        withdrawalLiveness = _withdrawalLiveness;\n        TokenFactory tf = TokenFactory(_tokenFactoryAddress);\n        tokenCurrency = tf.createToken(_syntheticName, _syntheticSymbol, 18);\n        minSponsorTokens = _minSponsorTokens;\n\n        require(_getIdentifierWhitelist().isIdentifierSupported(_priceIdentifier));\n\n        priceIdentifer = _priceIdentifier;\n    }\n\n    /****************************************\n     *          POSITION FUNCTIONS          *\n     ****************************************/\n\n    /**\n     * @notice Transfers ownership of the caller's current position to `newSponsorAddress`.\n     * @dev Transferring positions can only occur if the recipient does not already have a position.\n     * @param newSponsorAddress is the address to which the position will be transferred.\n     */\n    function transfer(address newSponsorAddress) public onlyPreExpiration() {\n        require(_getCollateral(positions[newSponsorAddress].rawCollateral).isEqual(FixedPoint.fromUnscaledUint(0)));\n        PositionData storage positionData = _getPositionData(msg.sender);\n        require(positionData.requestPassTimestamp == 0);\n        positions[newSponsorAddress] = positionData;\n        delete positions[msg.sender];\n\n        emit Transfer(msg.sender, newSponsorAddress);\n        emit NewSponsor(newSponsorAddress);\n    }\n\n    /**\n     * @notice Transfers `collateralAmount` of `collateralCurrency` into the sponsor's position.\n     * @dev Increases the collateralization level of a position after creation.\n     * @param collateralAmount total amount of collateral tokens to be sent to the sponsor's position.\n     */\n    function deposit(FixedPoint.Unsigned memory collateralAmount) public onlyPreExpiration() fees() {\n        PositionData storage positionData = _getPositionData(msg.sender);\n        require(positionData.requestPassTimestamp == 0);\n        _addCollateral(positionData.rawCollateral, collateralAmount);\n        _addCollateral(rawTotalPositionCollateral, collateralAmount);\n\n        // Move collateral currency from sender to contract.\n        collateralCurrency.safeTransferFrom(msg.sender, address(this), collateralAmount.rawValue);\n\n        emit Deposit(msg.sender, collateralAmount.rawValue);\n    }\n\n    /**\n     * @notice Transfers `collateralAmount` of `collateralCurrency` from the sponsor's position to the sponsor.\n     * @dev Reverts if the withdrawal puts this position's collateralization ratio below the global\n     * collateralization ratio. In that case, use `requestWithdrawawal`. Might not withdraw the full requested\n     * amount in order to account for precision loss.\n     * @param collateralAmount is the amount of collateral to withdraw.\n     * @return amountWithdrawn The actual amount of collateral withdrawn.\n     */\n    function withdraw(FixedPoint.Unsigned memory collateralAmount)\n        public\n        onlyPreExpiration()\n        fees()\n        returns (FixedPoint.Unsigned memory amountWithdrawn)\n    {\n        PositionData storage positionData = _getPositionData(msg.sender);\n        require(positionData.requestPassTimestamp == 0);\n\n        _removeCollateral(positionData.rawCollateral, collateralAmount);\n        require(_checkPositionCollateralization(positionData));\n        // We elect to withdraw the amount that the global collateral is decreased by,\n        // rather than the individual position's collateral, because we need to maintain the invariant that\n        // the global collateral is always <= the collateral owned by the contract to avoid reverts on withdrawals.\n        amountWithdrawn = _removeCollateral(rawTotalPositionCollateral, collateralAmount);\n\n        // Move collateral currency from contract to sender.\n        // Note that we move the amount of collateral that is decreased from rawCollateral (inclusive of fees)\n        // instead of the user requested amount. This eliminates precision loss that could occur\n        // where the user withdraws more collateral than rawCollateral is decremented by.\n        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\n\n        emit Withdrawal(msg.sender, amountWithdrawn.rawValue);\n    }\n\n    /**\n     * @notice Starts a withdrawal request that, if passed, allows the sponsor to withdraw\n     * `collateralAmount` from their position.\n     * @dev The request will be pending for `withdrawalLiveness`, during which the position can be liquidated.\n     * @param collateralAmount the amount of collateral requested to withdraw\n     */\n    function requestWithdrawal(FixedPoint.Unsigned memory collateralAmount) public onlyPreExpiration() {\n        PositionData storage positionData = _getPositionData(msg.sender);\n        require(positionData.requestPassTimestamp == 0);\n\n        // Make sure the proposed expiration of this request is not post-expiry.\n        uint requestPassTime = getCurrentTime() + withdrawalLiveness;\n        require(requestPassTime <= expirationTimestamp);\n\n        // Update the position object for the user.\n        positionData.requestPassTimestamp = requestPassTime;\n        positionData.withdrawalRequestAmount = collateralAmount;\n\n        emit RequestWithdrawal(msg.sender, collateralAmount.rawValue);\n    }\n\n    /**\n     * @notice After a passed withdrawal request (i.e., by a call to `requestWithdrawal` and waiting\n     * `withdrawalLiveness`), withdraws `positionData.withdrawalRequestAmount` of collateral currency.\n     * @dev Might not withdraw the full requested amount in order to account for precision loss.\n     * @return amountWithdrawn The actual amount of collateral withdrawn.\n     */\n    // TODO: Decide whether to fold this functionality into withdraw() method above.\n    function withdrawPassedRequest()\n        external\n        onlyPreExpiration()\n        fees()\n        returns (FixedPoint.Unsigned memory amountWithdrawn)\n    {\n        PositionData storage positionData = _getPositionData(msg.sender);\n        require(positionData.requestPassTimestamp <= getCurrentTime());\n\n        // If withdrawal request amount is > position collateral, then withdraw the full collateral amount.\n        FixedPoint.Unsigned memory amountToWithdraw = positionData.withdrawalRequestAmount;\n        if (positionData.withdrawalRequestAmount.isGreaterThan(_getCollateral(positionData.rawCollateral))) {\n            amountToWithdraw = _getCollateral(positionData.rawCollateral);\n        }\n\n        _removeCollateral(positionData.rawCollateral, amountToWithdraw);\n        amountWithdrawn = _removeCollateral(rawTotalPositionCollateral, amountToWithdraw);\n\n        // Transfer approved withdrawal amount from the contract to the caller.\n        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\n\n        emit RequestWithdrawalExecuted(msg.sender, amountWithdrawn.rawValue);\n\n        // Reset withdrawal request\n        positionData.withdrawalRequestAmount = FixedPoint.fromUnscaledUint(0);\n        positionData.requestPassTimestamp = 0;\n    }\n\n    /**\n     * @notice Cancels a pending withdrawal request.\n     */\n    function cancelWithdrawal() external onlyPreExpiration() {\n        PositionData storage positionData = _getPositionData(msg.sender);\n        require(positionData.requestPassTimestamp != 0);\n\n        emit RequestWithdrawalCanceled(msg.sender, positionData.withdrawalRequestAmount.rawValue);\n\n        // Reset withdrawal request\n        positionData.requestPassTimestamp = 0;\n        positionData.withdrawalRequestAmount = FixedPoint.fromUnscaledUint(0);\n    }\n\n    /**\n     * @notice Pulls `collateralAmount` into the sponsor's position and mints `numTokens` of `tokenCurrency`.\n     * @dev Reverts if the minting these tokens would put the position's collateralization ratio below the\n     * global collateralization ratio.\n     * @param collateralAmount is the number of collateral tokens to collateralize the position with\n     * @param numTokens is the number of tokens to mint from the position.\n     */\n    function create(FixedPoint.Unsigned memory collateralAmount, FixedPoint.Unsigned memory numTokens)\n        public\n        onlyPreExpiration()\n        fees()\n    {\n        require(_checkCollateralization(collateralAmount, numTokens));\n\n        PositionData storage positionData = positions[msg.sender];\n        require(positionData.requestPassTimestamp == 0);\n        if (positionData.tokensOutstanding.isEqual(0)) {\n            require(numTokens.isGreaterThanOrEqual(minSponsorTokens));\n            emit NewSponsor(msg.sender);\n        }\n        _addCollateral(positionData.rawCollateral, collateralAmount);\n        positionData.tokensOutstanding = positionData.tokensOutstanding.add(numTokens);\n\n        _addCollateral(rawTotalPositionCollateral, collateralAmount);\n        totalTokensOutstanding = totalTokensOutstanding.add(numTokens);\n\n        // Transfer tokens into the contract from caller and mint the caller synthetic tokens.\n        collateralCurrency.safeTransferFrom(msg.sender, address(this), collateralAmount.rawValue);\n        require(tokenCurrency.mint(msg.sender, numTokens.rawValue), \"Minting synthetic tokens failed\");\n\n        emit PositionCreated(msg.sender, collateralAmount.rawValue, numTokens.rawValue);\n    }\n\n    /**\n     * @notice Burns `numTokens` of `tokenCurrency` and sends back the proportional amount of `collateralCurrency`.\n     * @dev Can only be called by a token sponsor. Might not redeem the full proportional amount of collateral\n     * in order to account for precision loss.\n     * @param numTokens is the number of tokens to be burnt for a commensurate amount of collateral.\n     * @return amountWithdrawn The actual amount of collateral withdrawn.\n     */\n    function redeem(FixedPoint.Unsigned memory numTokens)\n        public\n        onlyPreExpiration()\n        fees()\n        returns (FixedPoint.Unsigned memory amountWithdrawn)\n    {\n        PositionData storage positionData = _getPositionData(msg.sender);\n        require(positionData.requestPassTimestamp == 0);\n        require(!numTokens.isGreaterThan(positionData.tokensOutstanding));\n\n        FixedPoint.Unsigned memory fractionRedeemed = numTokens.div(positionData.tokensOutstanding);\n        FixedPoint.Unsigned memory collateralRedeemed = fractionRedeemed.mul(\n            _getCollateral(positionData.rawCollateral)\n        );\n\n        // If redemption returns all tokens the sponsor has then we can delete their position. Else, downsize.\n        if (positionData.tokensOutstanding.isEqual(numTokens)) {\n            amountWithdrawn = _deleteSponsorPosition(msg.sender);\n        } else {\n            // Decrease the sponsors position size of collateral and tokens.\n            _removeCollateral(positionData.rawCollateral, collateralRedeemed);\n            FixedPoint.Unsigned memory newTokenCount = positionData.tokensOutstanding.sub(numTokens);\n            require(newTokenCount.isGreaterThanOrEqual(minSponsorTokens));\n            positionData.tokensOutstanding = newTokenCount;\n\n            // Decrease the contract's collateral and tokens.\n            amountWithdrawn = _removeCollateral(rawTotalPositionCollateral, collateralRedeemed);\n            totalTokensOutstanding = totalTokensOutstanding.sub(numTokens);\n        }\n\n        // Transfer collateral from contract to caller and burn callers synthetic tokens.\n        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\n        tokenCurrency.safeTransferFrom(msg.sender, address(this), numTokens.rawValue);\n        tokenCurrency.burn(numTokens.rawValue);\n\n        emit Redeem(msg.sender, amountWithdrawn.rawValue, numTokens.rawValue);\n    }\n\n    /**\n     * @notice After a contract has passed expiry all token holders can redeem their tokens for\n     * underlying at the prevailing price defined by the DVM from the `expire` function.\n     * @dev This Burns all tokens from the caller of `tokenCurrency` and sends back the proportional\n     * amount of `collateralCurrency`. Might not redeem the full proportional amount of collateral\n     * in order to account for precision loss.\n     * @return amountWithdrawn The actual amount of collateral withdrawn.\n     */\n    function settleExpired() external onlyPostExpiration() fees() returns (FixedPoint.Unsigned memory amountWithdrawn) {\n        // If the contract state is open and onlyPostExpiration passed then `expire()` has not yet been called.\n        require(contractState != ContractState.Open);\n\n        // Get the current settlement price and store it. If it is not resolved will revert.\n        if (contractState != ContractState.ExpiredPriceReceived) {\n            expiryPrice = _getOraclePrice(expirationTimestamp);\n            contractState = ContractState.ExpiredPriceReceived;\n        }\n\n        // Get caller's tokens balance and calculate amount of underlying entitled to them.\n        FixedPoint.Unsigned memory tokensToRedeem = FixedPoint.Unsigned(tokenCurrency.balanceOf(msg.sender));\n        FixedPoint.Unsigned memory totalRedeemableCollateral = tokensToRedeem.mul(expiryPrice);\n\n        // If the caller is a sponsor with outstanding collateral they are also entitled to their excess collateral after their debt.\n        PositionData storage positionData = positions[msg.sender];\n        if (_getCollateral(positionData.rawCollateral).isGreaterThan(0)) {\n            // Calculate the underlying entitled to a token sponsor. This is collateral - debt in underlying.\n            FixedPoint.Unsigned memory tokenDebtValueInCollateral = positionData.tokensOutstanding.mul(expiryPrice);\n            FixedPoint.Unsigned memory positionCollateral = _getCollateral(positionData.rawCollateral);\n\n            // If the debt is greater than the remaining collateral, they cannot redeem anything.\n            FixedPoint.Unsigned memory positionRedeemableCollateral = tokenDebtValueInCollateral.isLessThan(\n                positionCollateral\n            )\n                ? positionCollateral.sub(tokenDebtValueInCollateral)\n                : FixedPoint.Unsigned(0);\n\n            // Add the number of redeemable tokens for the sponsor to their total redeemable collateral.\n            totalRedeemableCollateral = totalRedeemableCollateral.add(positionRedeemableCollateral);\n\n            // Reset the position state as all the value has been removed after settlement.\n            delete positions[msg.sender];\n        }\n\n        // Take the min of the remaining collateral and the collateral \"owed\". If the contract is undercapitalized,\n        // the caller will get as much collateral as the contract can pay out.\n        FixedPoint.Unsigned memory payout = FixedPoint.min(\n            _getCollateral(rawTotalPositionCollateral),\n            totalRedeemableCollateral\n        );\n\n        // Decrement total contract collateral and outstanding debt.\n        amountWithdrawn = _removeCollateral(rawTotalPositionCollateral, payout);\n        totalTokensOutstanding = totalTokensOutstanding.sub(tokensToRedeem);\n\n        // Transfer tokens & collateral and burn the redeemed tokens.\n        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\n        tokenCurrency.safeTransferFrom(msg.sender, address(this), tokensToRedeem.rawValue);\n        tokenCurrency.burn(tokensToRedeem.rawValue);\n\n        emit SettleExpiredPosition(msg.sender, amountWithdrawn.rawValue, tokensToRedeem.rawValue);\n    }\n\n    /****************************************\n     *        GLOBAL STATE FUNCTIONS        *\n     ****************************************/\n\n    /**\n     * @notice Locks contract state in expired and requests oracle price.\n     * @dev this function can only be called once the contract is expired and cant be re-called\n     * due to the state modifiers applied on it.\n     */\n    function expire() external onlyPostExpiration() onlyOpenState() fees() {\n        contractState = ContractState.ExpiredPriceRequested;\n\n        // The final fee for this request is paid out of the contract rather than by the caller.\n        _payFinalFees(address(this), _computeFinalFees());\n        _requestOraclePrice(expirationTimestamp);\n\n        emit ContractExpired(msg.sender);\n    }\n\n    /**\n     * @notice Premature contract settlement under emergency circumstances.\n     * @dev Only the governor can call this function as they are permissioned within the `FinancialContractAdmin`.\n     * Upon emergency shutdown, the contract settlement time is set to the shutdown time. This enables withdrawal\n     * to occur via the standard `settleExpired` function. Contract state is set to `ExpiredPriceRequested`\n     * which prevents re-entry into this function or the `expire` function. No fees are paid when calling\n     * `emergencyShutdown` as the governor who would call the function would also receive the fees.\n     */\n    // TODO(#969) Remove once prettier-plugin-solidity can handle the \"override\" keyword\n    // prettier-ignore\n    function emergencyShutdown() external override onlyPreExpiration() onlyOpenState() {\n        require(msg.sender == _getFinancialContractsAdminAddress());\n\n        contractState = ContractState.ExpiredPriceRequested;\n        // Expiratory time now becomes the current time (emergency shutdown time).\n        // Price requested at this time stamp. `settleExpired` can now withdraw at this timestamp.\n        uint oldExpirationTimestamp = expirationTimestamp;\n        expirationTimestamp = getCurrentTime();\n        _requestOraclePrice(expirationTimestamp);\n\n        emit EmergencyShutdown(msg.sender, oldExpirationTimestamp, expirationTimestamp);\n    }\n\n    // TODO is this how we want this function to be implemented?\n    // TODO(#969) Remove once prettier-plugin-solidity can handle the \"override\" keyword\n    // prettier-ignore\n    function remargin() external override onlyPreExpiration() {\n        return;\n    }\n\n    /**\n     * @notice Accessor method for a sponsor's collateral.\n     * @dev This is necessary because the struct returned by the positions() method shows\n     * rawCollateral, which isn't a user-readable value.\n     * @param sponsor address whose collateral amount is retrieved.\n     */\n    function getCollateral(address sponsor) external view returns (FixedPoint.Unsigned memory) {\n        // Note: do a direct access to avoid the validity check.\n        return _getCollateral(positions[sponsor].rawCollateral);\n    }\n\n    /**\n     * @notice Accessor method for the total collateral stored within the PricelessPositionManager.\n     */\n    function totalPositionCollateral() external view returns (FixedPoint.Unsigned memory) {\n        return _getCollateral(rawTotalPositionCollateral);\n    }\n\n    /**\n     * @dev This overrides pfc() so the PricelessPositionManager can report its profit from corruption.\n     */\n    // TODO(#969) Remove once prettier-plugin-solidity can handle the \"override\" keyword\n    // prettier-ignore\n    function pfc() public virtual override view returns (FixedPoint.Unsigned memory) {\n        return _getCollateral(rawTotalPositionCollateral);\n    }\n\n    /****************************************\n     *          INTERNAL FUNCTIONS         *\n     ****************************************/\n\n    function _reduceSponsorPosition(\n        address sponsor,\n        FixedPoint.Unsigned memory tokensToRemove,\n        FixedPoint.Unsigned memory collateralToRemove,\n        FixedPoint.Unsigned memory withdrawalAmountToRemove\n    ) internal {\n        PositionData storage positionData = _getPositionData(sponsor);\n\n        // If the entire position is being removed, delete it instead.\n        if (\n            tokensToRemove.isEqual(positionData.tokensOutstanding) &&\n            _getCollateral(positionData.rawCollateral).isEqual(collateralToRemove)\n        ) {\n            _deleteSponsorPosition(sponsor);\n            return;\n        }\n\n        // Decrease the sponsor's collateral, tokens, and withdrawal request.\n        _removeCollateral(positionData.rawCollateral, collateralToRemove);\n        FixedPoint.Unsigned memory newTokenCount = positionData.tokensOutstanding.sub(tokensToRemove);\n        require(newTokenCount.isGreaterThanOrEqual(minSponsorTokens));\n        positionData.tokensOutstanding = newTokenCount;\n\n        positionData.withdrawalRequestAmount = positionData.withdrawalRequestAmount.sub(withdrawalAmountToRemove);\n\n        // Decrease the contract's global counters of collateral and tokens.\n        _removeCollateral(rawTotalPositionCollateral, collateralToRemove);\n        totalTokensOutstanding = totalTokensOutstanding.sub(tokensToRemove);\n    }\n\n    function _deleteSponsorPosition(address sponsor) internal returns (FixedPoint.Unsigned memory) {\n        PositionData storage positionToLiquidate = _getPositionData(sponsor);\n\n        FixedPoint.Unsigned memory startingGlobalCollateral = _getCollateral(rawTotalPositionCollateral);\n\n        // Remove the collateral and outstanding from the overall total position.\n        FixedPoint.Unsigned memory remainingRawCollateral = positionToLiquidate.rawCollateral;\n        rawTotalPositionCollateral = rawTotalPositionCollateral.sub(remainingRawCollateral);\n        totalTokensOutstanding = totalTokensOutstanding.sub(positionToLiquidate.tokensOutstanding);\n\n        // Reset the sponsors position to have zero outstanding and collateral.\n        delete positions[sponsor];\n\n        emit EndedSponsor(sponsor);\n\n        // Return fee-adjusted amount of collateral deleted from position.\n        return startingGlobalCollateral.sub(_getCollateral(rawTotalPositionCollateral));\n    }\n\n    function _getPositionData(address sponsor)\n        internal\n        view\n        onlyCollateralizedPosition(sponsor)\n        returns (PositionData storage)\n    {\n        return positions[sponsor];\n    }\n\n    function _getIdentifierWhitelist() internal view returns (IdentifierWhitelistInterface) {\n        bytes32 identifierWhitelistInterface = \"IdentifierWhitelist\";\n        return IdentifierWhitelistInterface(finder.getImplementationAddress(identifierWhitelistInterface));\n    }\n\n    function _getOracle() internal view returns (OracleInterface) {\n        bytes32 oracleInterface = \"Oracle\";\n        return OracleInterface(finder.getImplementationAddress(oracleInterface));\n    }\n\n    function _getStoreAddress() internal view returns (address) {\n        bytes32 storeInterface = \"Store\";\n        return finder.getImplementationAddress(storeInterface);\n    }\n\n    function _getFinancialContractsAdminAddress() internal view returns (address) {\n        bytes32 financialContractsAdminInterface = \"FinancialContractsAdmin\";\n        return finder.getImplementationAddress(financialContractsAdminInterface);\n    }\n\n    function _requestOraclePrice(uint requestedTime) internal {\n        OracleInterface oracle = _getOracle();\n        oracle.requestPrice(priceIdentifer, requestedTime);\n    }\n\n    function _getOraclePrice(uint requestedTime) internal view returns (FixedPoint.Unsigned memory) {\n        // Create an instance of the oracle and get the price. If the price is not resolved revert.\n        OracleInterface oracle = _getOracle();\n        require(oracle.hasPrice(priceIdentifer, requestedTime), \"Can only get a price once the DVM has resolved\");\n        int oraclePrice = oracle.getPrice(priceIdentifer, requestedTime);\n\n        // For now we don't want to deal with negative prices in positions.\n        if (oraclePrice < 0) {\n            oraclePrice = 0;\n        }\n        return FixedPoint.Unsigned(_safeUintCast(oraclePrice));\n    }\n\n    function _checkPositionCollateralization(PositionData storage positionData) private view returns (bool) {\n        return _checkCollateralization(_getCollateral(positionData.rawCollateral), positionData.tokensOutstanding);\n    }\n\n    function _checkCollateralization(FixedPoint.Unsigned memory collateral, FixedPoint.Unsigned memory numTokens)\n        private\n        view\n        returns (bool)\n    {\n        FixedPoint.Unsigned memory global = _getCollateralizationRatio(\n            _getCollateral(rawTotalPositionCollateral),\n            totalTokensOutstanding\n        );\n        FixedPoint.Unsigned memory thisChange = _getCollateralizationRatio(collateral, numTokens);\n        return !global.isGreaterThan(thisChange);\n    }\n\n    function _getCollateralizationRatio(FixedPoint.Unsigned memory collateral, FixedPoint.Unsigned memory numTokens)\n        private\n        pure\n        returns (FixedPoint.Unsigned memory ratio)\n    {\n        if (!numTokens.isGreaterThan(0)) {\n            return FixedPoint.fromUnscaledUint(0);\n        } else {\n            return collateral.div(numTokens);\n        }\n    }\n\n    function _safeUintCast(int value) private pure returns (uint result) {\n        require(value >= 0, \"Uint underflow\");\n        return uint(value);\n    }\n\n    /**\n     * @dev These internal functions are supposed to act identically to modifiers, but re-used modifiers\n     * unnecessarily increase contract bytecode size.\n     * source: https://blog.polymath.network/solidity-tips-and-tricks-to-save-gas-and-reduce-bytecode-size-c44580b218e6\n     */\n    function _onlyOpenState() internal view {\n        require(contractState == ContractState.Open);\n    }\n\n    function _onlyPreExpiration() internal view {\n        require(getCurrentTime() < expirationTimestamp);\n    }\n\n    function _onlyPostExpiration() internal view {\n        require(getCurrentTime() >= expirationTimestamp);\n    }\n\n    function _onlyCollateralizedPosition(address sponsor) internal view {\n        require(_getCollateral(positions[sponsor].rawCollateral).isGreaterThan(0));\n    }\n}"
    }
  ]
}