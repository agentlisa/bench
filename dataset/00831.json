{
  "Title": "The use of immutable variables",
  "Content": "##### Description\nThe following variables can be marked as immutable to reduce gas consumption:\nhttps://github.com/DivergenceProtocol/diver-contracts/blob/e5286f94a7ccb9d6279fae51ea66a8833672628a/src/core/Arena.sol#L22\nhttps://github.com/DivergenceProtocol/diver-contracts/blob/e5286f94a7ccb9d6279fae51ea66a8833672628a/src/core/Arena.sol#L24\n\n##### Recommendation\nWe recommend using immutable variables instead of storage variables. \n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/core/Arena.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.14;\n\nimport { IERC20 } from \"@oz/token/ERC20/IERC20.sol\";\nimport { Ownable } from \"@oz/access/Ownable.sol\";\nimport { Clones } from \"@oz/proxy/Clones.sol\";\nimport { IERC20Metadata } from \"@oz/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { Errors } from \"./errors/Errors.sol\";\nimport { IArena, Fee, Outcome, BattleKey, CreateBattleParams } from \"./interfaces/IArena.sol\";\nimport { IBattleInit } from \"./interfaces/battle/IBattleInit.sol\";\nimport { IBattleState } from \"./interfaces/battle/IBattleState.sol\";\nimport { IBattleActions, IBattleMintBurn } from \"./interfaces/battle/IBattleActions.sol\";\nimport { DeploymentParams } from \"./params/DeploymentParams.sol\";\nimport { SToken } from \"./token/SToken.sol\";\nimport { getAdjustPrice } from \"./utils.sol\";\n\n/// @notice Deploys battles. Sets pool underlying, collateral, fees and other\n/// deployment\n/// parameters.\ncontract Arena is IArena, Ownable {\n    address public oracleAddr;\n    address[] private battleList;\n    address public battleImpl;\n    bool public isPermissionless;\n    DeploymentParams public deploymentParameters;\n    mapping(bytes32 => address) public battles;\n    mapping(string => Fee) public fees;\n    // mapping(address => mapping(string => bool)) public isSupported;\n\n    mapping(address => bool) public collateralWhitelist;\n    mapping(string => bool) public underlyingWhitelist;\n\n    constructor(address _oracleAddr, address _battleImpl) {\n        oracleAddr = _oracleAddr;\n        battleImpl = _battleImpl;\n    }\n\n    function setFeeForUnderlying(string calldata underlying, Fee calldata _fee) external onlyOwner {\n        fees[underlying] = _fee;\n    }\n\n    event CollateralWhitelistChanged(address collateral, bool state);\n\n    function setCollateralWhitelist(address collateral, bool isSupported) external onlyOwner {\n        require(collateralWhitelist[collateral] != isSupported, \"LD\");\n        collateralWhitelist[collateral] = isSupported;\n        emit CollateralWhitelistChanged(collateral, isSupported);\n    }\n\n    event UnderlyingWhitelistChanged(string underlying, bool state, Fee fee);\n\n    function setUnderlyingWhitelist(string memory underlying, bool isSupported, Fee calldata fee) external onlyOwner {\n        require(underlyingWhitelist[underlying] != isSupported, \"LD\");\n        underlyingWhitelist[underlying] = isSupported;\n        fees[underlying] = fee;\n        emit UnderlyingWhitelistChanged(underlying, isSupported, fee);\n    }\n\n    event PermissionlessChanged(bool state);\n\n    function setPermissionless() external onlyOwner {\n        isPermissionless = !isPermissionless;\n        emit PermissionlessChanged(isPermissionless);\n    }\n\n    function createBattle(BattleKey memory bk) external override returns (address battle) {\n        // collaterl address error\n        if (bk.collateral == address(0)) {\n            revert Errors.ZeroAddress();\n        }\n\n        // not supported\n        if (!isPermissionless) {\n            if (!collateralWhitelist[bk.collateral]) {\n                revert Errors.NotSupported();\n            }\n        }\n\n        if (!underlyingWhitelist[bk.underlying]) {\n            revert Errors.NotSupported();\n        }\n\n        // expiries must at 8am utc\n        if ((bk.expiries - 28_800) % 86_400 != 0 || block.timestamp >= bk.expiries) {\n            revert Errors.NotSupportedExpiries();\n        }\n\n        bk.strikeValue = getAdjustPrice(bk.strikeValue);\n        bytes32 battleKeyB32 = keccak256(abi.encode(bk.collateral, bk.underlying, bk.expiries, bk.strikeValue));\n        if (battles[battleKeyB32] != address(0)) {\n            revert Errors.BattleExisted();\n        }\n        deploymentParameters = DeploymentParams({\n            arenaAddr: address(this),\n            battleKey: bk,\n            oracleAddr: oracleAddr,\n            fee: fees[bk.underlying],\n            spear: address(0),\n            shield: address(0)\n        });\n        battle = Clones.cloneDeterministic(battleImpl, battleKeyB32);\n        uint8 decimals = IERC20Metadata(bk.collateral).decimals();\n        address spear = address(new SToken(\"Spear\", \"SPEAR\", decimals, battle));\n        address shield = address(new SToken(\"Shield\", \"SHIELD\", decimals, battle));\n        deploymentParameters.spear = spear;\n        deploymentParameters.shield = shield;\n        battles[battleKeyB32] = battle;\n        battleList.push(battle);\n        IBattleInit(battle).initState(deploymentParameters);\n        emit BattleCreated(bk, battle, spear, shield, fees[bk.underlying]);\n    }\n\n    function getBattle(BattleKey memory battleKey) external view override returns (address battle) {\n        battleKey.strikeValue = getAdjustPrice(battleKey.strikeValue);\n        bytes32 battleKeyB32 = keccak256(abi.encode(battleKey.collateral, battleKey.underlying, battleKey.expiries, battleKey.strikeValue));\n        battle = battles[battleKeyB32];\n    }\n\n    function getAllBattles() external view override returns (BattleInfo[] memory) {\n        uint256 len = battleList.length;\n        BattleInfo[] memory infos = new BattleInfo[](len);\n        for (uint256 i; i < len; i++) {\n            address battle = battleList[i];\n            BattleKey memory bk = IBattleState(battle).battleKey();\n            (uint160 sqrtPriceX96, int24 tick,) = IBattleState(battle).slot0();\n            (uint256 startTS, uint256 endTS) = IBattleState(battle).startAndEndTS();\n            (address spear, address shield) = IBattleState(battle).spearAndShield();\n            Outcome result = IBattleState(battle).battleOutcome();\n            infos[i] = BattleInfo({\n                battle: battle,\n                bk: bk,\n                sqrtPriceX96: sqrtPriceX96,\n                tick: tick,\n                startTS: startTS,\n                endTS: endTS,\n                spear: spear,\n                shield: shield,\n                spearBalance: 0,\n                shieldBalance: 0,\n                result: result\n            });\n        }\n        return infos;\n    }\n}"
    },
    {
      "filename": "src/core/Arena.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.14;\n\nimport { IERC20 } from \"@oz/token/ERC20/IERC20.sol\";\nimport { Ownable } from \"@oz/access/Ownable.sol\";\nimport { Clones } from \"@oz/proxy/Clones.sol\";\nimport { IERC20Metadata } from \"@oz/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { Errors } from \"./errors/Errors.sol\";\nimport { IArena, Fee, Outcome, BattleKey, CreateBattleParams } from \"./interfaces/IArena.sol\";\nimport { IBattleInit } from \"./interfaces/battle/IBattleInit.sol\";\nimport { IBattleState } from \"./interfaces/battle/IBattleState.sol\";\nimport { IBattleActions, IBattleMintBurn } from \"./interfaces/battle/IBattleActions.sol\";\nimport { DeploymentParams } from \"./params/DeploymentParams.sol\";\nimport { SToken } from \"./token/SToken.sol\";\nimport { getAdjustPrice } from \"./utils.sol\";\n\n/// @notice Deploys battles. Sets pool underlying, collateral, fees and other\n/// deployment\n/// parameters.\ncontract Arena is IArena, Ownable {\n    address public oracleAddr;\n    address[] private battleList;\n    address public battleImpl;\n    bool public isPermissionless;\n    DeploymentParams public deploymentParameters;\n    mapping(bytes32 => address) public battles;\n    mapping(string => Fee) public fees;\n    // mapping(address => mapping(string => bool)) public isSupported;\n\n    mapping(address => bool) public collateralWhitelist;\n    mapping(string => bool) public underlyingWhitelist;\n\n    constructor(address _oracleAddr, address _battleImpl) {\n        oracleAddr = _oracleAddr;\n        battleImpl = _battleImpl;\n    }\n\n    function setFeeForUnderlying(string calldata underlying, Fee calldata _fee) external onlyOwner {\n        fees[underlying] = _fee;\n    }\n\n    event CollateralWhitelistChanged(address collateral, bool state);\n\n    function setCollateralWhitelist(address collateral, bool isSupported) external onlyOwner {\n        require(collateralWhitelist[collateral] != isSupported, \"LD\");\n        collateralWhitelist[collateral] = isSupported;\n        emit CollateralWhitelistChanged(collateral, isSupported);\n    }\n\n    event UnderlyingWhitelistChanged(string underlying, bool state, Fee fee);\n\n    function setUnderlyingWhitelist(string memory underlying, bool isSupported, Fee calldata fee) external onlyOwner {\n        require(underlyingWhitelist[underlying] != isSupported, \"LD\");\n        underlyingWhitelist[underlying] = isSupported;\n        fees[underlying] = fee;\n        emit UnderlyingWhitelistChanged(underlying, isSupported, fee);\n    }\n\n    event PermissionlessChanged(bool state);\n\n    function setPermissionless() external onlyOwner {\n        isPermissionless = !isPermissionless;\n        emit PermissionlessChanged(isPermissionless);\n    }\n\n    function createBattle(BattleKey memory bk) external override returns (address battle) {\n        // collaterl address error\n        if (bk.collateral == address(0)) {\n            revert Errors.ZeroAddress();\n        }\n\n        // not supported\n        if (!isPermissionless) {\n            if (!collateralWhitelist[bk.collateral]) {\n                revert Errors.NotSupported();\n            }\n        }\n\n        if (!underlyingWhitelist[bk.underlying]) {\n            revert Errors.NotSupported();\n        }\n\n        // expiries must at 8am utc\n        if ((bk.expiries - 28_800) % 86_400 != 0 || block.timestamp >= bk.expiries) {\n            revert Errors.NotSupportedExpiries();\n        }\n\n        bk.strikeValue = getAdjustPrice(bk.strikeValue);\n        bytes32 battleKeyB32 = keccak256(abi.encode(bk.collateral, bk.underlying, bk.expiries, bk.strikeValue));\n        if (battles[battleKeyB32] != address(0)) {\n            revert Errors.BattleExisted();\n        }\n        deploymentParameters = DeploymentParams({\n            arenaAddr: address(this),\n            battleKey: bk,\n            oracleAddr: oracleAddr,\n            fee: fees[bk.underlying],\n            spear: address(0),\n            shield: address(0)\n        });\n        battle = Clones.cloneDeterministic(battleImpl, battleKeyB32);\n        uint8 decimals = IERC20Metadata(bk.collateral).decimals();\n        address spear = address(new SToken(\"Spear\", \"SPEAR\", decimals, battle));\n        address shield = address(new SToken(\"Shield\", \"SHIELD\", decimals, battle));\n        deploymentParameters.spear = spear;\n        deploymentParameters.shield = shield;\n        battles[battleKeyB32] = battle;\n        battleList.push(battle);\n        IBattleInit(battle).initState(deploymentParameters);\n        emit BattleCreated(bk, battle, spear, shield, fees[bk.underlying]);\n    }\n\n    function getBattle(BattleKey memory battleKey) external view override returns (address battle) {\n        battleKey.strikeValue = getAdjustPrice(battleKey.strikeValue);\n        bytes32 battleKeyB32 = keccak256(abi.encode(battleKey.collateral, battleKey.underlying, battleKey.expiries, battleKey.strikeValue));\n        battle = battles[battleKeyB32];\n    }\n\n    function getAllBattles() external view override returns (BattleInfo[] memory) {\n        uint256 len = battleList.length;\n        BattleInfo[] memory infos = new BattleInfo[](len);\n        for (uint256 i; i < len; i++) {\n            address battle = battleList[i];\n            BattleKey memory bk = IBattleState(battle).battleKey();\n            (uint160 sqrtPriceX96, int24 tick,) = IBattleState(battle).slot0();\n            (uint256 startTS, uint256 endTS) = IBattleState(battle).startAndEndTS();\n            (address spear, address shield) = IBattleState(battle).spearAndShield();\n            Outcome result = IBattleState(battle).battleOutcome();\n            infos[i] = BattleInfo({\n                battle: battle,\n                bk: bk,\n                sqrtPriceX96: sqrtPriceX96,\n                tick: tick,\n                startTS: startTS,\n                endTS: endTS,\n                spear: spear,\n                shield: shield,\n                spearBalance: 0,\n                shieldBalance: 0,\n                result: result\n            });\n        }\n        return infos;\n    }\n}"
    }
  ]
}