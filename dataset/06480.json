{
  "Title": "[M-32] `VirtualAccount` cannot directly send native tokens",
  "Content": "\nCertain functions require native tokens to be sent. These functions will revert.\n\n### Proof of Concept\n\nAccording to the Sponsor, `VirtualAccounts` can \"call any of the `dApps` present in the Root Chain (Arbitrum) e.g. Maia, Hermes, Ulysses AMM and Uniswap.\" However, this is not the case, as `call()` is not `payable` and thus cannot send native tokens to other contracts. This is problematic because certain [functions](https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/BaseBranchRouter.sol#L58-L62) require native token transfers and will fail.\n\n### Recommended Mitigation Steps\n\nConsider creating a single `call()` function that has a `payable` modifier and `{value: msg.value}`. Be aware, that since `calls[i].target.call()` is in a loop, it is not advisable to add `payable` to the existing `call()`. This is because `msg.value` may be used multiple times, and is [unsafe](https://github.com/Uniswap/v3-periphery/issues/52).\n\n### Assessed type\n\nPayable\n\n**[0xBugsy (Maia) acknowledged, but disagreed with severity](https://github.com/code-423n4/2023-05-maia-findings/issues/307#issuecomment-1632576421)**\n\n**[Trust (judge) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/307#issuecomment-1649374997):**\n > Breaking of interoperability with `dApps` on the hosting chain, contrary to docs, justifies Medium severity, in my opinion.\n\n**[0xBugsy (Maia) confirmed](https://github.com/code-423n4/2023-05-maia-findings/issues/307#issuecomment-1655947185)**\n\n**[0xLightt (Maia) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/307#issuecomment-1709927454):**\n > Addressed [here](https://github.com/Maia-DAO/eco-c4-contest/commit/03c829ba0ef3fd74de3cb4fcd1ff5a72512072e9).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/ulysses-omnichain/BaseBranchRouter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\n\nimport {IBranchRouter} from \"./interfaces/IBranchRouter.sol\";\n\nimport {\n    IBranchBridgeAgent as IBridgeAgent,\n    Deposit,\n    DepositStatus,\n    DepositInput,\n    DepositParams,\n    DepositMultipleInput,\n    DepositMultipleParams,\n    SettlementParams,\n    SettlementMultipleParams\n} from \"./interfaces/IBranchBridgeAgent.sol\";\n\n/// @title Base Branch Router Contract\ncontract BaseBranchRouter is IBranchRouter, Ownable {\n    /// @inheritdoc IBranchRouter\n    address public localBridgeAgentAddress;\n\n    /// @inheritdoc IBranchRouter\n    address public bridgeAgentExecutorAddress;\n\n    constructor() {\n        _initializeOwner(msg.sender);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        OWNER FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Contract state initialization function.\n    function initialize(address _localBridgeAgentAddress) external onlyOwner {\n        require(_localBridgeAgentAddress != address(0), \"Bridge Agent address cannot be 0\");\n        localBridgeAgentAddress = _localBridgeAgentAddress;\n        bridgeAgentExecutorAddress = IBridgeAgent(localBridgeAgentAddress).bridgeAgentExecutorAddress();\n        renounceOwnership();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchRouter\n    function getDepositEntry(uint32 _depositNonce) external view returns (Deposit memory) {\n        return IBridgeAgent(localBridgeAgentAddress).getDepositEntry(_depositNonce);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchRouter\n    function callOut(bytes calldata params, uint128 remoteExecutionGas) external payable lock {\n        IBridgeAgent(localBridgeAgentAddress).performCallOut{value: msg.value}(\n            msg.sender, params, 0, remoteExecutionGas\n        );\n    }\n\n    /// @inheritdoc IBranchRouter\n    function callOutAndBridge(bytes calldata params, DepositInput memory dParams, uint128 remoteExecutionGas)\n        external\n        payable\n        lock\n    {\n        IBridgeAgent(localBridgeAgentAddress).performCallOutAndBridge{value: msg.value}(\n            msg.sender, params, dParams, 0, remoteExecutionGas\n        );\n    }\n\n    /// @inheritdoc IBranchRouter\n    function callOutAndBridgeMultiple(\n        bytes calldata params,\n        DepositMultipleInput memory dParams,\n        uint128 remoteExecutionGas\n    ) external payable lock {\n        IBridgeAgent(localBridgeAgentAddress).performCallOutAndBridgeMultiple{value: msg.value}(\n            msg.sender, params, dParams, 0, remoteExecutionGas\n        );\n    }\n\n    /// @inheritdoc IBranchRouter\n    function retrySettlement(uint32 _settlementNonce, uint128 _gasToBoostSettlement) external payable lock {\n        IBridgeAgent(localBridgeAgentAddress).retrySettlement{value: msg.value}(_settlementNonce, _gasToBoostSettlement);\n    }\n\n    /// @inheritdoc IBranchRouter\n    function redeemDeposit(uint32 _depositNonce) external lock {\n        IBridgeAgent(localBridgeAgentAddress).redeemDeposit(_depositNonce);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        ANYCALL EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchRouter\n    function anyExecuteNoSettlement(bytes calldata)\n        external\n        virtual\n        requiresAgentExecutor\n        returns (bool success, bytes memory result)\n    {\n        /// Unrecognized Function Selector\n        return (false, \"unknown selector\");\n    }\n\n    /// @inheritdoc IBranchRouter\n    function anyExecuteSettlement(bytes calldata, SettlementParams memory)\n        external\n        virtual\n        requiresAgentExecutor\n        returns (bool success, bytes memory result)\n    {\n        /// Unrecognized Function Selector\n        return (false, \"unknown selector\");\n    }\n\n    /// @inheritdoc IBranchRouter\n    function anyExecuteSettlementMultiple(bytes calldata, SettlementMultipleParams memory)\n        external\n        virtual\n        requiresAgentExecutor\n        returns (bool success, bytes memory result)\n    {\n        /// Unrecognized Function Selector\n        return (false, \"unknown selector\");\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                                MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Modifier that verifies msg sender is the Bridge Agent Executor.\n    modifier requiresAgentExecutor() {\n        if (msg.sender != bridgeAgentExecutorAddress) revert UnrecognizedBridgeAgentExecutor();\n        _;\n    }\n\n    uint256 internal _unlocked = 1;\n\n    /// @notice Modifier for a simple re-entrancy check.\n    modifier lock() {\n        require(_unlocked == 1);\n        _unlocked = 2;\n        _;\n        _unlocked = 1;\n    }\n}"
    }
  ]
}