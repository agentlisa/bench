{
  "Title": "[N-05] Contract header not updated after branching",
  "Content": "\n1.  File: src/GlobalAccessControl.sol (lines [12-17](https://github.com/code-423n4/2022-04-badger-citadel/blob/18f8c392b6fc303fe95602eba6303725023e53da/src/GlobalAccessControl.sol#L12-L17))\n\n```solidity\n/**\n * @title Badger Geyser\n @dev Tracks stakes and pledged tokens to be distributed, for use with\n @dev BadgerTree merkle distribution system. An arbitrary number of tokens to\n distribute can be specified.\n */\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-04-badger-citadel",
  "Code": [
    {
      "filename": "src/GlobalAccessControl.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport {IERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\"; \nimport {SafeERC20Upgradeable} from \"openzeppelin-contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {PausableUpgradeable} from \"openzeppelin-contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {AccessControlEnumerableUpgradeable} from \"openzeppelin-contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {EnumerableSetUpgradeable} from \"openzeppelin-contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\n\n/**\n * @title Badger Geyser\n @dev Tracks stakes and pledged tokens to be distributed, for use with \n @dev BadgerTree merkle distribution system. An arbitrary number of tokens to \n distribute can be specified.\n */\n\ncontract GlobalAccessControl is\n    AccessControlEnumerableUpgradeable,\n    PausableUpgradeable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    bytes32 public constant CONTRACT_GOVERNANCE_ROLE =\n        keccak256(\"CONTRACT_GOVERNANCE_ROLE\");\n    bytes32 public constant TREASURY_GOVERNANCE_ROLE =\n        keccak256(\"TREASURY_GOVERNANCE_ROLE\");\n\n    bytes32 public constant TECH_OPERATIONS_ROLE =\n        keccak256(\"TECH_OPERATIONS_ROLE\");\n    bytes32 public constant POLICY_OPERATIONS_ROLE =\n        keccak256(\"POLICY_OPERATIONS_ROLE\");\n    bytes32 public constant TREASURY_OPERATIONS_ROLE =\n        keccak256(\"TREASURY_OPERATIONS_ROLE\");\n\n    bytes32 public constant KEEPER_ROLE = keccak256(\"KEEPER_ROLE\");\n\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n    bytes32 public constant UNPAUSER_ROLE = keccak256(\"UNPAUSER_ROLE\");\n\n    bytes32 public constant BLOCKLIST_MANAGER_ROLE =\n        keccak256(\"BLOCKLIST_MANAGER_ROLE\");\n    bytes32 public constant BLOCKLISTED_ROLE = keccak256(\"BLOCKLISTED_ROLE\");\n\n    bytes32 public constant CITADEL_MINTER_ROLE =\n        keccak256(\"CITADEL_MINTER_ROLE\");\n\n    // Should the function transferFrom be disabled\n    // NOTE: This is enforced at the contract level, the contract just allows the toggling of the bool\n    bool public transferFromDisabled; // Set to true in initialize\n\n    /// =======================\n    /// ===== Initializer =====\n    /// =======================\n\n    /**\n     * @notice Initializer\n     * @param _initialContractGovernance Global access control\n     */\n    function initialize(address _initialContractGovernance)\n        external\n        initializer\n    {\n        __AccessControlEnumerable_init();\n        __Pausable_init();\n\n        // Set this for assumptions and clarity\n        _setupRole(DEFAULT_ADMIN_ROLE, _initialContractGovernance);\n        \n        _setupRole(CONTRACT_GOVERNANCE_ROLE, _initialContractGovernance);\n\n        // All roles are managed by CONTRACT_GOVERNANCE_ROLE\n        _setRoleAdmin(CONTRACT_GOVERNANCE_ROLE, CONTRACT_GOVERNANCE_ROLE);\n        _setRoleAdmin(POLICY_OPERATIONS_ROLE, CONTRACT_GOVERNANCE_ROLE);\n        _setRoleAdmin(TREASURY_GOVERNANCE_ROLE, CONTRACT_GOVERNANCE_ROLE);\n        _setRoleAdmin(PAUSER_ROLE, CONTRACT_GOVERNANCE_ROLE);\n        _setRoleAdmin(UNPAUSER_ROLE, CONTRACT_GOVERNANCE_ROLE);\n        _setRoleAdmin(BLOCKLIST_MANAGER_ROLE, CONTRACT_GOVERNANCE_ROLE);\n        _setRoleAdmin(CITADEL_MINTER_ROLE, CONTRACT_GOVERNANCE_ROLE);\n        _setRoleAdmin(KEEPER_ROLE, CONTRACT_GOVERNANCE_ROLE);\n\n        // Add default admin role here to avoid governance mistakes\n        _setRoleAdmin(DEFAULT_ADMIN_ROLE, CONTRACT_GOVERNANCE_ROLE);\n\n        // BLOCKLIST is managed by BLOCKLIST_MANAGER\n        _setRoleAdmin(BLOCKLISTED_ROLE, BLOCKLIST_MANAGER_ROLE);\n    }\n\n    /// ================================================\n    /// ===== Permissioned Actions (various roles) =====\n    /// ================================================\n\n    function pause() external {\n        require(hasRole(PAUSER_ROLE, msg.sender), \"PAUSER_ROLE\");\n        _pause();\n    }\n\n    function unpause() external {\n        require(hasRole(UNPAUSER_ROLE, msg.sender), \"UNPAUSER_ROLE\");\n        _unpause();\n    }\n\n    /// @dev setup a new role via contract governance, without upgrade\n    /// @dev note that no constant will be available on the contract here to search role, but we can delegate viewing to another contract\n    /// TODO: Add string -> hash EnumerableSet to a new RoleRegistry contract for easy on-chain viewing.\n    function initializeNewRole(\n        bytes32 role,\n        string memory roleString,\n        bytes32 adminRole\n    ) external {\n        require(\n            hasRole(CONTRACT_GOVERNANCE_ROLE, msg.sender),\n            \"CONTRACT_GOVERNANCE_ROLE\"\n        );\n        require(\n            keccak256(bytes(roleString)) == role,\n            \"Role string and role do not match\"\n        );\n        _setRoleAdmin(role, adminRole);\n    }\n}"
    }
  ]
}