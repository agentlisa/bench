{
  "Title": "M-1: User can loose funds in case if swapping in DecreaseOrderUtils.processOrder will fail",
  "Content": "# Issue M-1: User can loose funds in case if swapping in DecreaseOrderUtils.processOrder will fail \n\nSource: https://github.com/sherlock-audit/2023-04-gmx-judging/issues/50 \n\n## Found by \nrvierdiiev\n## Summary\nWhen user executes decrease order, then he provides `order.minOutputAmount` value, that should protect his from loses. This value is provided with hope that swapping that will take some fees will be executed. But in case if swapping will fail, then this `order.minOutputAmount` value will be smaller then user would like to receive in case when swapping didn't occur. Because of that user can receive less output amount.\n## Vulnerability Detail\n`DecreaseOrderUtils.processOrder` function executed decrease order and [returns order execution result](https://github.com/sherlock-audit/2023-04-gmx/blob/main/gmx-synthetics/contracts/order/DecreaseOrderUtils.sol#L37-L46) which contains information about output tokens and amounts that user should receive.\n\nIn case if only 1 output token is returned to user, then function will try to swap that amount according to the swap path that user has provided.\nhttps://github.com/sherlock-audit/2023-04-gmx/blob/main/gmx-synthetics/contracts/order/DecreaseOrderUtils.sol#L83-L116\n```solidity\n        try params.contracts.swapHandler.swap(\n            SwapUtils.SwapParams(\n                params.contracts.dataStore,\n                params.contracts.eventEmitter,\n                params.contracts.oracle,\n                Bank(payable(order.market())),\n                params.key,\n                result.outputToken,\n                result.outputAmount,\n                params.swapPathMarkets,\n                0,\n                order.receiver(),\n                order.uiFeeReceiver(),\n                order.shouldUnwrapNativeToken()\n            )\n        ) returns (address tokenOut, uint256 swapOutputAmount) {\n            `(\n                params.contracts.oracle,\n                tokenOut,\n                swapOutputAmount,\n                order.minOutputAmount()\n            );\n        } catch (bytes memory reasonBytes) {\n            (string memory reason, /* bool hasRevertMessage */) = ErrorUtils.getRevertMessage(reasonBytes);\n\n            _handleSwapError(\n                params.contracts.oracle,\n                order,\n                result,\n                reason,\n                reasonBytes\n            );\n        }\n    }\n```\nAs you can see in case if swap succeeded, then `_validateOutputAmount` function will be called, that will check slippage. It will check that `swapOutputAmount` is received according to the slippage.\nBut in case if swap will not succeed, then `_handleSwapError` will be called.\nhttps://github.com/sherlock-audit/2023-04-gmx/blob/main/gmx-synthetics/contracts/order/DecreaseOrderUtils.sol#L208-L230\n```solidity\n    null(\n        Oracle oracle,\n        Order.Props memory order,\n        DecreasePositionUtils.DecreasePositionResult memory result,\n        string memory reason,\n        bytes memory reasonBytes\n    ) internal {\n        emit SwapUtils.SwapReverted(reason, reasonBytes);\n\n        _validateOutputAmount(\n            oracle,\n            result.outputToken,\n            result.outputAmount,\n            order.minOutputAmount()\n        );\n\n        MarketToken(payable(order.market())).transferOut(\n            result.outputToken,\n            order.receiver(),\n            result.outputAmount,\n            order.shouldUnwrapNativeToken()\n        );\n    }\n```\nAs you can see in this case `_validateOutputAmount` function will be called as well, but it will be called with `result.outputAmount` this time, which is amount provided by decreasing of position.\n\nNow i will describe the problem.\nIn case if user wants to swap his token, he knows that he needs to pay fees to the market pools and that this swap will eat some amount of output. So in case if `result.outputAmount` is 100$ worth of tokenA, it's fine if user will provide slippage as 3% if he has long swap path, so his slippage is 97$. \nBut in case when swap will fail, then now this slippage of 97$ is incorrect as user didn't do swapping and he should receiev exactly 100$ worth of tokenA.\n\nAlso i should note here, that it's easy to make swap fail for keeper, it's enough for him to just not provide any asset price, so swap reverts. So keeper can benefit on this slippage issue.\n## Impact\nUser can be frontruned to receive less amount in case of swapping error.\n## Code Snippet\nProvided above\n## Tool used\n\nManual Review\n\n## Recommendation\nMaybe it's needed to have another slippage param, that should be used in case of no swapping.\n\n\n\n## Discussion\n\n**xvi10**\n\nwould classify this as a low, the prices provided must still be within the max oracle age which could be a few minutes, it should be difficult to intentionally cause failures within this range\n\n**IllIllI000**\n\nIt still sounds like a medium to me. I'll let Sherlock decide\n\n**xvi10**\n\n> Also i should note here, that it's easy to make swap fail for keeper, it's enough for him to just not provide any asset price, so swap reverts. So keeper can benefit on this slippage issue.\n\nkeepers do not benefit from failed swaps, but okay with me to let Sherlock decide for this one\n\n**hrishibhat**\n\nGiven that there is a loss of funds for the user in the unlikely case of swaps failing, considering this issue a valid medium\n\n**rvierdiyev**\n\nEscalate for 10 USDC\nI don't think that #124 is duplicate of this issue.\n\nI think that this report and #124 describe different things. After reading #124 i didn't feel that it's same as this report, because here i describe error case of swapping. While #124 is talking about swapping to different token.\n\nI believe that these 2 should be separate issues.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> I don't think that #124 is duplicate of this issue.\n> \n> I think that this report and #124 describe different things. After reading #124 i didn't feel that it's same as this report, because here i describe error case of swapping. While #124 is talking about swapping to different token.\n> \n> I believe that these 2 should be separate issues.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**IllIllI000**\n\nAgree with the escalation - #124 is Invalid, and this is a solo Medium\n\n**hrishibhat**\n\nResult:\nMedium\nUnique\n#124 is not a duplicate of this issue \n\n**sherlock-admin**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [rvierdiyev](https://github.com/sherlock-audit/2023-04-gmx-judging/issues/50/#issuecomment-1600308766): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/74",
  "Code": [
    {
      "filename": "gmx-synthetics/contracts/order/DecreaseOrderUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"./BaseOrderUtils.sol\";\nimport \"../swap/SwapUtils.sol\";\nimport \"../position/DecreasePositionUtils.sol\";\nimport \"../order/OrderStoreUtils.sol\";\nimport \"../error/ErrorUtils.sol\";\n\n// @title DecreaseOrderUtils\n// @dev Library for functions to help with processing a decrease order\nlibrary DecreaseOrderUtils {\n    using Position for Position.Props;\n    using Order for Order.Props;\n    using Array for uint256[];\n\n    // @dev process a decrease order\n    // @param params BaseOrderUtils.ExecuteOrderParams\n    function processOrder(BaseOrderUtils.ExecuteOrderParams memory params) external {\n        Order.Props memory order = params.order;\n        MarketUtils.validatePositionMarket(params.contracts.dataStore, params.market);\n\n        bytes32 positionKey = PositionUtils.getPositionKey(order.account(), order.market(), order.initialCollateralToken(), order.isLong());\n        Position.Props memory position = PositionStoreUtils.get(params.contracts.dataStore, positionKey);\n        PositionUtils.validateNonEmptyPosition(position);\n\n        validateOracleBlockNumbers(\n            params.minOracleBlockNumbers,\n            params.maxOracleBlockNumbers,\n            order.orderType(),\n            order.updatedAtBlock(),\n            position.increasedAtBlock(),\n            position.decreasedAtBlock()\n        );\n\n        DecreasePositionUtils.DecreasePositionResult memory result = DecreasePositionUtils.decreasePosition(\n            PositionUtils.UpdatePositionParams(\n                params.contracts,\n                params.market,\n                order,\n                params.key,\n                position,\n                positionKey\n            )\n        );\n\n        OrderStoreUtils.remove(params.contracts.dataStore, params.key, order.account());\n\n        // if the pnlToken and the collateralToken are different\n        // and if a swap fails or no swap was requested\n        // then it is possible to receive two separate tokens from decreasing\n        // the position\n        // transfer the two tokens to the user in this case and skip processing\n        // the swapPath\n        if (result.secondaryOutputAmount > 0) {\n            _validateOutputAmount(\n                params.contracts.oracle,\n                result.outputToken,\n                result.outputAmount,\n                result.secondaryOutputToken,\n                result.secondaryOutputAmount,\n                order.minOutputAmount()\n            );\n\n            MarketToken(payable(order.market())).transferOut(\n                result.outputToken,\n                order.receiver(),\n                result.outputAmount,\n                order.shouldUnwrapNativeToken()\n            );\n\n            MarketToken(payable(order.market())).transferOut(\n                result.secondaryOutputToken,\n                order.receiver(),\n                result.secondaryOutputAmount,\n                order.shouldUnwrapNativeToken()\n            );\n\n            return;\n        }\n\n        try params.contracts.swapHandler.swap(\n            SwapUtils.SwapParams(\n                params.contracts.dataStore,\n                params.contracts.eventEmitter,\n                params.contracts.oracle,\n                Bank(payable(order.market())),\n                params.key,\n                result.outputToken,\n                result.outputAmount,\n                params.swapPathMarkets,\n                0,\n                order.receiver(),\n                order.uiFeeReceiver(),\n                order.shouldUnwrapNativeToken()\n            )\n        ) returns (address tokenOut, uint256 swapOutputAmount) {\n            _validateOutputAmount(\n                params.contracts.oracle,\n                tokenOut,\n                swapOutputAmount,\n                order.minOutputAmount()\n            );\n        } catch (bytes memory reasonBytes) {\n            (string memory reason, /* bool hasRevertMessage */) = ErrorUtils.getRevertMessage(reasonBytes);\n\n            _handleSwapError(\n                params.contracts.oracle,\n                order,\n                result,\n                reason,\n                reasonBytes\n            );\n        }\n    }\n\n    // @dev validate the oracle block numbers used for the prices in the oracle\n    // @param oracleBlockNumbers the oracle block numbers\n    // @param orderType the order type\n    // @param orderUpdatedAtBlock the block at which the order was last updated\n    // @param positionIncreasedAtBlock the block at which the position was last increased\n    // @param positionDecreasedAtBlock the block at which the position was last decreased\n    function validateOracleBlockNumbers(\n        uint256[] memory minOracleBlockNumbers,\n        uint256[] memory maxOracleBlockNumbers,\n        Order.OrderType orderType,\n        uint256 orderUpdatedAtBlock,\n        uint256 positionIncreasedAtBlock,\n        uint256 positionDecreasedAtBlock\n    ) internal pure {\n        if (orderType == Order.OrderType.MarketDecrease) {\n            OracleUtils.validateBlockNumberWithinRange(\n                minOracleBlockNumbers,\n                maxOracleBlockNumbers,\n                orderUpdatedAtBlock\n            );\n            return;\n        }\n\n        if (\n            orderType == Order.OrderType.LimitDecrease ||\n            orderType == Order.OrderType.StopLossDecrease\n        ) {\n            uint256 latestUpdatedAtBlock = orderUpdatedAtBlock > positionIncreasedAtBlock ? orderUpdatedAtBlock : positionIncreasedAtBlock;\n            if (!minOracleBlockNumbers.areGreaterThanOrEqualTo(latestUpdatedAtBlock)) {\n                revert Errors.OracleBlockNumbersAreSmallerThanRequired(minOracleBlockNumbers, latestUpdatedAtBlock);\n            }\n            return;\n        }\n\n        if (orderType == Order.OrderType.Liquidation) {\n            uint256 latestUpdatedAtBlock = positionIncreasedAtBlock > positionDecreasedAtBlock ? positionIncreasedAtBlock : positionDecreasedAtBlock;\n\n            if (!minOracleBlockNumbers.areGreaterThanOrEqualTo(latestUpdatedAtBlock)) {\n                revert Errors.OracleBlockNumbersAreSmallerThanRequired(minOracleBlockNumbers, latestUpdatedAtBlock);\n            }\n            return;\n        }\n\n        revert Errors.UnsupportedOrderType();\n    }\n\n    function _validateOutputAmount(\n        Oracle oracle,\n        address outputToken,\n        uint256 outputAmount,\n        uint256 minOutputAmount\n    ) internal view {\n        // for limit / stop-loss orders, the latest price may be the triggerPrice of the order\n        // it is possible that the valuation of the token using this price may not be precise\n        // and the condition for the order execution to revert may not be accurate\n        // this could cause orders to be frozen even if they could be executed, and orders\n        // to be executed even if the received amount of tokens is less than what the user\n        // expected\n        // the user should be informed of this possibility through documentation\n        // it is likely preferred that decrease orders are still executed if the trigger price\n        // is reached and the acceptable price is fulfillable\n        uint256 outputTokenPrice = oracle.getLatestPrice(outputToken).min;\n        uint256 outputUsd = outputAmount * outputTokenPrice;\n\n        if (outputUsd < minOutputAmount) {\n            revert Errors.InsufficientOutputAmount(outputUsd, minOutputAmount);\n        }\n    }\n\n    function _validateOutputAmount(\n        Oracle oracle,\n        address outputToken,\n        uint256 outputAmount,\n        address secondaryOutputToken,\n        uint256 secondaryOutputAmount,\n        uint256 minOutputAmount\n    ) internal view {\n        uint256 outputTokenPrice = oracle.getLatestPrice(outputToken).min;\n        uint256 outputUsd = outputAmount * outputTokenPrice;\n\n        uint256 secondaryOutputTokenPrice = oracle.getLatestPrice(secondaryOutputToken).min;\n        uint256 secondaryOutputUsd = secondaryOutputAmount * secondaryOutputTokenPrice;\n\n        uint256 totalOutputUsd = outputUsd + secondaryOutputUsd;\n\n        if (totalOutputUsd < minOutputAmount) {\n            revert Errors.InsufficientOutputAmount(totalOutputUsd, minOutputAmount);\n        }\n    }\n\n    function _handleSwapError(\n        Oracle oracle,\n        Order.Props memory order,\n        DecreasePositionUtils.DecreasePositionResult memory result,\n        string memory reason,\n        bytes memory reasonBytes\n    ) internal {\n        emit SwapUtils.SwapReverted(reason, reasonBytes);\n\n        _validateOutputAmount(\n            oracle,\n            result.outputToken,\n            result.outputAmount,\n            order.minOutputAmount()\n        );\n\n        MarketToken(payable(order.market())).transferOut(\n            result.outputToken,\n            order.receiver(),\n            result.outputAmount,\n            order.shouldUnwrapNativeToken()\n        );\n    }\n}"
    },
    {
      "filename": "gmx-synthetics/contracts/order/DecreaseOrderUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"./BaseOrderUtils.sol\";\nimport \"../swap/SwapUtils.sol\";\nimport \"../position/DecreasePositionUtils.sol\";\nimport \"../order/OrderStoreUtils.sol\";\nimport \"../error/ErrorUtils.sol\";\n\n// @title DecreaseOrderUtils\n// @dev Library for functions to help with processing a decrease order\nlibrary DecreaseOrderUtils {\n    using Position for Position.Props;\n    using Order for Order.Props;\n    using Array for uint256[];\n\n    // @dev process a decrease order\n    // @param params BaseOrderUtils.ExecuteOrderParams\n    function processOrder(BaseOrderUtils.ExecuteOrderParams memory params) external {\n        Order.Props memory order = params.order;\n        MarketUtils.validatePositionMarket(params.contracts.dataStore, params.market);\n\n        bytes32 positionKey = PositionUtils.getPositionKey(order.account(), order.market(), order.initialCollateralToken(), order.isLong());\n        Position.Props memory position = PositionStoreUtils.get(params.contracts.dataStore, positionKey);\n        PositionUtils.validateNonEmptyPosition(position);\n\n        validateOracleBlockNumbers(\n            params.minOracleBlockNumbers,\n            params.maxOracleBlockNumbers,\n            order.orderType(),\n            order.updatedAtBlock(),\n            position.increasedAtBlock(),\n            position.decreasedAtBlock()\n        );\n\n        DecreasePositionUtils.DecreasePositionResult memory result = DecreasePositionUtils.decreasePosition(\n            PositionUtils.UpdatePositionParams(\n                params.contracts,\n                params.market,\n                order,\n                params.key,\n                position,\n                positionKey\n            )\n        );\n\n        OrderStoreUtils.remove(params.contracts.dataStore, params.key, order.account());\n\n        // if the pnlToken and the collateralToken are different\n        // and if a swap fails or no swap was requested\n        // then it is possible to receive two separate tokens from decreasing\n        // the position\n        // transfer the two tokens to the user in this case and skip processing\n        // the swapPath\n        if (result.secondaryOutputAmount > 0) {\n            _validateOutputAmount(\n                params.contracts.oracle,\n                result.outputToken,\n                result.outputAmount,\n                result.secondaryOutputToken,\n                result.secondaryOutputAmount,\n                order.minOutputAmount()\n            );\n\n            MarketToken(payable(order.market())).transferOut(\n                result.outputToken,\n                order.receiver(),\n                result.outputAmount,\n                order.shouldUnwrapNativeToken()\n            );\n\n            MarketToken(payable(order.market())).transferOut(\n                result.secondaryOutputToken,\n                order.receiver(),\n                result.secondaryOutputAmount,\n                order.shouldUnwrapNativeToken()\n            );\n\n            return;\n        }\n\n        try params.contracts.swapHandler.swap(\n            SwapUtils.SwapParams(\n                params.contracts.dataStore,\n                params.contracts.eventEmitter,\n                params.contracts.oracle,\n                Bank(payable(order.market())),\n                params.key,\n                result.outputToken,\n                result.outputAmount,\n                params.swapPathMarkets,\n                0,\n                order.receiver(),\n                order.uiFeeReceiver(),\n                order.shouldUnwrapNativeToken()\n            )\n        ) returns (address tokenOut, uint256 swapOutputAmount) {\n            _validateOutputAmount(\n                params.contracts.oracle,\n                tokenOut,\n                swapOutputAmount,\n                order.minOutputAmount()\n            );\n        } catch (bytes memory reasonBytes) {\n            (string memory reason, /* bool hasRevertMessage */) = ErrorUtils.getRevertMessage(reasonBytes);\n\n            _handleSwapError(\n                params.contracts.oracle,\n                order,\n                result,\n                reason,\n                reasonBytes\n            );\n        }\n    }\n\n    // @dev validate the oracle block numbers used for the prices in the oracle\n    // @param oracleBlockNumbers the oracle block numbers\n    // @param orderType the order type\n    // @param orderUpdatedAtBlock the block at which the order was last updated\n    // @param positionIncreasedAtBlock the block at which the position was last increased\n    // @param positionDecreasedAtBlock the block at which the position was last decreased\n    function validateOracleBlockNumbers(\n        uint256[] memory minOracleBlockNumbers,\n        uint256[] memory maxOracleBlockNumbers,\n        Order.OrderType orderType,\n        uint256 orderUpdatedAtBlock,\n        uint256 positionIncreasedAtBlock,\n        uint256 positionDecreasedAtBlock\n    ) internal pure {\n        if (orderType == Order.OrderType.MarketDecrease) {\n            OracleUtils.validateBlockNumberWithinRange(\n                minOracleBlockNumbers,\n                maxOracleBlockNumbers,\n                orderUpdatedAtBlock\n            );\n            return;\n        }\n\n        if (\n            orderType == Order.OrderType.LimitDecrease ||\n            orderType == Order.OrderType.StopLossDecrease\n        ) {\n            uint256 latestUpdatedAtBlock = orderUpdatedAtBlock > positionIncreasedAtBlock ? orderUpdatedAtBlock : positionIncreasedAtBlock;\n            if (!minOracleBlockNumbers.areGreaterThanOrEqualTo(latestUpdatedAtBlock)) {\n                revert Errors.OracleBlockNumbersAreSmallerThanRequired(minOracleBlockNumbers, latestUpdatedAtBlock);\n            }\n            return;\n        }\n\n        if (orderType == Order.OrderType.Liquidation) {\n            uint256 latestUpdatedAtBlock = positionIncreasedAtBlock > positionDecreasedAtBlock ? positionIncreasedAtBlock : positionDecreasedAtBlock;\n\n            if (!minOracleBlockNumbers.areGreaterThanOrEqualTo(latestUpdatedAtBlock)) {\n                revert Errors.OracleBlockNumbersAreSmallerThanRequired(minOracleBlockNumbers, latestUpdatedAtBlock);\n            }\n            return;\n        }\n\n        revert Errors.UnsupportedOrderType();\n    }\n\n    function _validateOutputAmount(\n        Oracle oracle,\n        address outputToken,\n        uint256 outputAmount,\n        uint256 minOutputAmount\n    ) internal view {\n        // for limit / stop-loss orders, the latest price may be the triggerPrice of the order\n        // it is possible that the valuation of the token using this price may not be precise\n        // and the condition for the order execution to revert may not be accurate\n        // this could cause orders to be frozen even if they could be executed, and orders\n        // to be executed even if the received amount of tokens is less than what the user\n        // expected\n        // the user should be informed of this possibility through documentation\n        // it is likely preferred that decrease orders are still executed if the trigger price\n        // is reached and the acceptable price is fulfillable\n        uint256 outputTokenPrice = oracle.getLatestPrice(outputToken).min;\n        uint256 outputUsd = outputAmount * outputTokenPrice;\n\n        if (outputUsd < minOutputAmount) {\n            revert Errors.InsufficientOutputAmount(outputUsd, minOutputAmount);\n        }\n    }\n\n    function _validateOutputAmount(\n        Oracle oracle,\n        address outputToken,\n        uint256 outputAmount,\n        address secondaryOutputToken,\n        uint256 secondaryOutputAmount,\n        uint256 minOutputAmount\n    ) internal view {\n        uint256 outputTokenPrice = oracle.getLatestPrice(outputToken).min;\n        uint256 outputUsd = outputAmount * outputTokenPrice;\n\n        uint256 secondaryOutputTokenPrice = oracle.getLatestPrice(secondaryOutputToken).min;\n        uint256 secondaryOutputUsd = secondaryOutputAmount * secondaryOutputTokenPrice;\n\n        uint256 totalOutputUsd = outputUsd + secondaryOutputUsd;\n\n        if (totalOutputUsd < minOutputAmount) {\n            revert Errors.InsufficientOutputAmount(totalOutputUsd, minOutputAmount);\n        }\n    }\n\n    function _handleSwapError(\n        Oracle oracle,\n        Order.Props memory order,\n        DecreasePositionUtils.DecreasePositionResult memory result,\n        string memory reason,\n        bytes memory reasonBytes\n    ) internal {\n        emit SwapUtils.SwapReverted(reason, reasonBytes);\n\n        _validateOutputAmount(\n            oracle,\n            result.outputToken,\n            result.outputAmount,\n            order.minOutputAmount()\n        );\n\n        MarketToken(payable(order.market())).transferOut(\n            result.outputToken,\n            order.receiver(),\n            result.outputAmount,\n            order.shouldUnwrapNativeToken()\n        );\n    }\n}"
    },
    {
      "filename": "gmx-synthetics/contracts/order/DecreaseOrderUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"./BaseOrderUtils.sol\";\nimport \"../swap/SwapUtils.sol\";\nimport \"../position/DecreasePositionUtils.sol\";\nimport \"../order/OrderStoreUtils.sol\";\nimport \"../error/ErrorUtils.sol\";\n\n// @title DecreaseOrderUtils\n// @dev Library for functions to help with processing a decrease order\nlibrary DecreaseOrderUtils {\n    using Position for Position.Props;\n    using Order for Order.Props;\n    using Array for uint256[];\n\n    // @dev process a decrease order\n    // @param params BaseOrderUtils.ExecuteOrderParams\n    function processOrder(BaseOrderUtils.ExecuteOrderParams memory params) external {\n        Order.Props memory order = params.order;\n        MarketUtils.validatePositionMarket(params.contracts.dataStore, params.market);\n\n        bytes32 positionKey = PositionUtils.getPositionKey(order.account(), order.market(), order.initialCollateralToken(), order.isLong());\n        Position.Props memory position = PositionStoreUtils.get(params.contracts.dataStore, positionKey);\n        PositionUtils.validateNonEmptyPosition(position);\n\n        validateOracleBlockNumbers(\n            params.minOracleBlockNumbers,\n            params.maxOracleBlockNumbers,\n            order.orderType(),\n            order.updatedAtBlock(),\n            position.increasedAtBlock(),\n            position.decreasedAtBlock()\n        );\n\n        DecreasePositionUtils.DecreasePositionResult memory result = DecreasePositionUtils.decreasePosition(\n            PositionUtils.UpdatePositionParams(\n                params.contracts,\n                params.market,\n                order,\n                params.key,\n                position,\n                positionKey\n            )\n        );\n\n        OrderStoreUtils.remove(params.contracts.dataStore, params.key, order.account());\n\n        // if the pnlToken and the collateralToken are different\n        // and if a swap fails or no swap was requested\n        // then it is possible to receive two separate tokens from decreasing\n        // the position\n        // transfer the two tokens to the user in this case and skip processing\n        // the swapPath\n        if (result.secondaryOutputAmount > 0) {\n            _validateOutputAmount(\n                params.contracts.oracle,\n                result.outputToken,\n                result.outputAmount,\n                result.secondaryOutputToken,\n                result.secondaryOutputAmount,\n                order.minOutputAmount()\n            );\n\n            MarketToken(payable(order.market())).transferOut(\n                result.outputToken,\n                order.receiver(),\n                result.outputAmount,\n                order.shouldUnwrapNativeToken()\n            );\n\n            MarketToken(payable(order.market())).transferOut(\n                result.secondaryOutputToken,\n                order.receiver(),\n                result.secondaryOutputAmount,\n                order.shouldUnwrapNativeToken()\n            );\n\n            return;\n        }\n\n        try params.contracts.swapHandler.swap(\n            SwapUtils.SwapParams(\n                params.contracts.dataStore,\n                params.contracts.eventEmitter,\n                params.contracts.oracle,\n                Bank(payable(order.market())),\n                params.key,\n                result.outputToken,\n                result.outputAmount,\n                params.swapPathMarkets,\n                0,\n                order.receiver(),\n                order.uiFeeReceiver(),\n                order.shouldUnwrapNativeToken()\n            )\n        ) returns (address tokenOut, uint256 swapOutputAmount) {\n            _validateOutputAmount(\n                params.contracts.oracle,\n                tokenOut,\n                swapOutputAmount,\n                order.minOutputAmount()\n            );\n        } catch (bytes memory reasonBytes) {\n            (string memory reason, /* bool hasRevertMessage */) = ErrorUtils.getRevertMessage(reasonBytes);\n\n            _handleSwapError(\n                params.contracts.oracle,\n                order,\n                result,\n                reason,\n                reasonBytes\n            );\n        }\n    }\n\n    // @dev validate the oracle block numbers used for the prices in the oracle\n    // @param oracleBlockNumbers the oracle block numbers\n    // @param orderType the order type\n    // @param orderUpdatedAtBlock the block at which the order was last updated\n    // @param positionIncreasedAtBlock the block at which the position was last increased\n    // @param positionDecreasedAtBlock the block at which the position was last decreased\n    function validateOracleBlockNumbers(\n        uint256[] memory minOracleBlockNumbers,\n        uint256[] memory maxOracleBlockNumbers,\n        Order.OrderType orderType,\n        uint256 orderUpdatedAtBlock,\n        uint256 positionIncreasedAtBlock,\n        uint256 positionDecreasedAtBlock\n    ) internal pure {\n        if (orderType == Order.OrderType.MarketDecrease) {\n            OracleUtils.validateBlockNumberWithinRange(\n                minOracleBlockNumbers,\n                maxOracleBlockNumbers,\n                orderUpdatedAtBlock\n            );\n            return;\n        }\n\n        if (\n            orderType == Order.OrderType.LimitDecrease ||\n            orderType == Order.OrderType.StopLossDecrease\n        ) {\n            uint256 latestUpdatedAtBlock = orderUpdatedAtBlock > positionIncreasedAtBlock ? orderUpdatedAtBlock : positionIncreasedAtBlock;\n            if (!minOracleBlockNumbers.areGreaterThanOrEqualTo(latestUpdatedAtBlock)) {\n                revert Errors.OracleBlockNumbersAreSmallerThanRequired(minOracleBlockNumbers, latestUpdatedAtBlock);\n            }\n            return;\n        }\n\n        if (orderType == Order.OrderType.Liquidation) {\n            uint256 latestUpdatedAtBlock = positionIncreasedAtBlock > positionDecreasedAtBlock ? positionIncreasedAtBlock : positionDecreasedAtBlock;\n\n            if (!minOracleBlockNumbers.areGreaterThanOrEqualTo(latestUpdatedAtBlock)) {\n                revert Errors.OracleBlockNumbersAreSmallerThanRequired(minOracleBlockNumbers, latestUpdatedAtBlock);\n            }\n            return;\n        }\n\n        revert Errors.UnsupportedOrderType();\n    }\n\n    function _validateOutputAmount(\n        Oracle oracle,\n        address outputToken,\n        uint256 outputAmount,\n        uint256 minOutputAmount\n    ) internal view {\n        // for limit / stop-loss orders, the latest price may be the triggerPrice of the order\n        // it is possible that the valuation of the token using this price may not be precise\n        // and the condition for the order execution to revert may not be accurate\n        // this could cause orders to be frozen even if they could be executed, and orders\n        // to be executed even if the received amount of tokens is less than what the user\n        // expected\n        // the user should be informed of this possibility through documentation\n        // it is likely preferred that decrease orders are still executed if the trigger price\n        // is reached and the acceptable price is fulfillable\n        uint256 outputTokenPrice = oracle.getLatestPrice(outputToken).min;\n        uint256 outputUsd = outputAmount * outputTokenPrice;\n\n        if (outputUsd < minOutputAmount) {\n            revert Errors.InsufficientOutputAmount(outputUsd, minOutputAmount);\n        }\n    }\n\n    function _validateOutputAmount(\n        Oracle oracle,\n        address outputToken,\n        uint256 outputAmount,\n        address secondaryOutputToken,\n        uint256 secondaryOutputAmount,\n        uint256 minOutputAmount\n    ) internal view {\n        uint256 outputTokenPrice = oracle.getLatestPrice(outputToken).min;\n        uint256 outputUsd = outputAmount * outputTokenPrice;\n\n        uint256 secondaryOutputTokenPrice = oracle.getLatestPrice(secondaryOutputToken).min;\n        uint256 secondaryOutputUsd = secondaryOutputAmount * secondaryOutputTokenPrice;\n\n        uint256 totalOutputUsd = outputUsd + secondaryOutputUsd;\n\n        if (totalOutputUsd < minOutputAmount) {\n            revert Errors.InsufficientOutputAmount(totalOutputUsd, minOutputAmount);\n        }\n    }\n\n    function _handleSwapError(\n        Oracle oracle,\n        Order.Props memory order,\n        DecreasePositionUtils.DecreasePositionResult memory result,\n        string memory reason,\n        bytes memory reasonBytes\n    ) internal {\n        emit SwapUtils.SwapReverted(reason, reasonBytes);\n\n        _validateOutputAmount(\n            oracle,\n            result.outputToken,\n            result.outputAmount,\n            order.minOutputAmount()\n        );\n\n        MarketToken(payable(order.market())).transferOut(\n            result.outputToken,\n            order.receiver(),\n            result.outputAmount,\n            order.shouldUnwrapNativeToken()\n        );\n    }\n}"
    }
  ]
}