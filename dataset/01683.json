{
  "Title": "The System Is Not Robust to Delayed Period Updates",
  "Content": "The major functionalities of the protocol (i.e., voting, reward emission, reward distribution) are synchronized on a per-voting-period basis, making the per-period consistency in bookkeeping and accounting a factor of major importance. However, the way that the current implementation refers to a voting period is rather brittle.\n\n\nMore specifically, [the unique identifier of a period is its starting timestamp, which is calculated modulo a week's time](https://github.com/ThenafiBNB/THENA-Contracts/blob/e5458ee4ea811788576585af7a56c02986d16122/contracts/MinterUpgradeable.sol#L162). When calculating the rewards of a voting period that has ended, that period's id is retrieved by [manually subtracting a week's seconds from the current active period's id](https://github.com/ThenafiBNB/THENA-Contracts/blob/e5458ee4ea811788576585af7a56c02986d16122/contracts/VoterV3.sol#L835). However, it is not strictly imposed by the codebase that the time interval between two periods is exactly one week but rather a multiple of a week's time. It is possible, for example, that a period update action continuously fails for longer than a full period. In such a case, it would not be possible to access the past period's data and any [reward distribution action](https://github.com/ThenafiBNB/THENA-Contracts/blob/e5458ee4ea811788576585af7a56c02986d16122/contracts/VoterV3.sol#L753) would fail silently, essentially locking the reward amount in the contract.\n\n\nConsider introducing a status for each voting period's phase, so as to be able to distinguish non-existing period timestamps due to delayed updates. As a more radical solution, consider adopting a serial number for uniquely identifying the voting periods and making the period's starting timestamp a separate data entry. This would make the system robust to potential delayed period updates but would also help improve the codebase's readability and overall quality making it less error-prone during future upgrades.\n\n\n***Update:** Acknowledged, not resolved. The Retro-Thena team stated:*\n\n\n\n> *We ensure that each epoch lasts 1 week and no delays are allowed.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/MinterUpgradeable.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\nimport \"./libraries/Math.sol\";\nimport \"./interfaces/IMinter.sol\";\nimport \"./interfaces/IRewardsDistributor.sol\";\nimport \"./interfaces/IThena.sol\";\nimport \"./interfaces/IVoter.sol\";\nimport \"./interfaces/IVotingEscrow.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n// codifies the minting rules as per ve(3,3), abstracted from the token to support any token that allows minting\n\ncontract MinterUpgradeable is IMinter, OwnableUpgradeable {\n    \n    bool public isFirstMint;\n\n    uint public EMISSION;\n    uint public TAIL_EMISSION;\n    uint public REBASEMAX;\n    uint public constant PRECISION = 1000;\n    uint public teamRate;\n    uint public constant MAX_TEAM_RATE = 50; // 5%\n\n    uint public constant WEEK = 86400 * 7; // allows minting once per week (reset every Thursday 00:00 UTC)\n    uint public weekly; // represents a starting weekly emission of 2.6M THENA (THENA has 18 decimals)\n    uint public active_period;\n    uint public constant LOCK = 86400 * 7 * 52 * 2;\n\n    address internal _initializer;\n    address public team;\n    address public pendingTeam;\n    \n    IThena public _thena;\n    IVoter public _voter;\n    IVotingEscrow public _ve;\n    IRewardsDistributor public _rewards_distributor;\n\n    event Mint(address indexed sender, uint weekly, uint circulating_supply, uint circulating_emission);\n\n    constructor() {}\n\n    function initialize(    \n        address __voter, // the voting & distribution system\n        address __ve, // the ve(3,3) system that will be locked into\n        address __rewards_distributor // the distribution system that ensures users aren't diluted\n    ) initializer public {\n        __Ownable_init();\n\n        _initializer = msg.sender;\n        team = msg.sender;\n\n        teamRate = 40; // 300 bps = 3%\n\n        EMISSION = 990;\n        TAIL_EMISSION = 2;\n        REBASEMAX = 300;\n\n        _thena = IThena(IVotingEscrow(__ve).token());\n        _voter = IVoter(__voter);\n        _ve = IVotingEscrow(__ve);\n        _rewards_distributor = IRewardsDistributor(__rewards_distributor);\n\n\n        active_period = ((block.timestamp + (2 * WEEK)) / WEEK) * WEEK;\n        weekly = 2_600_000 * 1e18; // represents a starting weekly emission of 2.6M THENA (THENA has 18 decimals)\n        isFirstMint = true;\n\n    }\n\n    function _initialize(\n        address[] memory claimants,\n        uint[] memory amounts,\n        uint max // sum amounts / max = % ownership of top protocols, so if initial 20m is distributed, and target is 25% protocol ownership, then max - 4 x 20m = 80m\n    ) external {\n        require(_initializer == msg.sender);\n        if(max > 0){\n            _thena.mint(address(this), max);\n            _thena.approve(address(_ve), type(uint).max);\n            for (uint i = 0; i < claimants.length; i++) {\n                _ve.create_lock_for(amounts[i], LOCK, claimants[i]);\n            }\n        }\n\n        _initializer = address(0);\n        active_period = ((block.timestamp) / WEEK) * WEEK; // allow minter.update_period() to mint new emissions THIS Thursday\n    }\n\n    function setTeam(address _team) external {\n        require(msg.sender == team, \"not team\");\n        pendingTeam = _team;\n    }\n\n    function acceptTeam() external {\n        require(msg.sender == pendingTeam, \"not pending team\");\n        team = pendingTeam;\n    }\n\n    function setVoter(address __voter) external {\n        require(__voter != address(0));\n        require(msg.sender == team, \"not team\");\n        _voter = IVoter(__voter);\n    }\n\n    function setTeamRate(uint _teamRate) external {\n        require(msg.sender == team, \"not team\");\n        require(_teamRate <= MAX_TEAM_RATE, \"rate too high\");\n        teamRate = _teamRate;\n    }\n\n    function setEmission(uint _emission) external {\n        require(msg.sender == team, \"not team\");\n        require(_emission <= PRECISION, \"rate too high\");\n        EMISSION = _emission;\n    }\n\n\n    function setRebase(uint _rebase) external {\n        require(msg.sender == team, \"not team\");\n        require(_rebase <= PRECISION, \"rate too high\");\n        REBASEMAX = _rebase;\n    }\n\n    // calculate circulating supply as total token supply - locked supply\n    function circulating_supply() public view returns (uint) {\n        return _thena.totalSupply() - _thena.balanceOf(address(_ve));\n    }\n\n    // emission calculation is 1% of available supply to mint adjusted by circulating / total supply\n    function calculate_emission() public view returns (uint) {\n        return (weekly * EMISSION) / PRECISION;\n    }\n\n    // weekly emission takes the max of calculated (aka target) emission versus circulating tail end emission\n    function weekly_emission() public view returns (uint) {\n        return Math.max(calculate_emission(), circulating_emission());\n    }\n\n    // calculates tail end (infinity) emissions as 0.2% of total supply\n    function circulating_emission() public view returns (uint) {\n        return (circulating_supply() * TAIL_EMISSION) / PRECISION;\n    }\n\n    // calculate inflation and adjust ve balances accordingly\n    function calculate_rebate(uint _weeklyMint) public view returns (uint) {\n        uint _veTotal = _thena.balanceOf(address(_ve));\n        uint _thenaTotal = _thena.totalSupply();\n        \n        uint lockedShare = (_veTotal) * PRECISION  / _thenaTotal;\n        if(lockedShare >= REBASEMAX){\n            return _weeklyMint * REBASEMAX / PRECISION;\n        } else {\n            return _weeklyMint * lockedShare / PRECISION;\n        }\n    }\n\n    // update period can only be called once per cycle (1 week)\n    function update_period() external returns (uint) {\n        uint _period = active_period;\n        if (block.timestamp >= _period + WEEK && _initializer == address(0)) { // only trigger if new week\n            _period = (block.timestamp / WEEK) * WEEK;\n            active_period = _period;\n\n            if(!isFirstMint){\n                weekly = weekly_emission();\n            } else {\n                isFirstMint = false;\n            }\n\n            uint _rebase = calculate_rebate(weekly);\n            uint _teamEmissions = weekly * teamRate / PRECISION;\n            uint _required = weekly;\n\n            uint _gauge = weekly - _rebase - _teamEmissions;\n\n            uint _balanceOf = _thena.balanceOf(address(this));\n            if (_balanceOf < _required) {\n                _thena.mint(address(this), _required - _balanceOf);\n            }\n\n            require(_thena.transfer(team, _teamEmissions));\n            \n            require(_thena.transfer(address(_rewards_distributor), _rebase));\n            _rewards_distributor.checkpoint_token(); // checkpoint token balance that was just minted in rewards distributor\n            _rewards_distributor.checkpoint_total_supply(); // checkpoint supply\n\n            _thena.approve(address(_voter), _gauge);\n            _voter.notifyRewardAmount(_gauge);\n\n            emit Mint(msg.sender, weekly, circulating_supply(), circulating_emission());\n        }\n        return _period;\n    }\n\n    function check() external view returns(bool){\n        uint _period = active_period;\n        return (block.timestamp >= _period + WEEK && _initializer == address(0));\n    }\n\n    function period() external view returns(uint){\n        return(block.timestamp / WEEK) * WEEK;\n    }\n    function setRewardDistributor(address _rewardDistro) external {\n        require(msg.sender == team);\n        _rewards_distributor = IRewardsDistributor(_rewardDistro);\n    }\n}"
    }
  ]
}