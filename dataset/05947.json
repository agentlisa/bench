{
  "Title": "[H-08] If governance removes a gauge, user's voting power for that gauge will be lost",
  "Content": "\n<https://github.com/code-423n4/2023-08-verwa/blob/main/src/GaugeController.sol#L127-L132> \n\n<https://github.com/code-423n4/2023-08-verwa/blob/main/src/GaugeController.sol#L213> \n\n<https://github.com/code-423n4/2023-08-verwa/blob/main/src/GaugeController.sol#L241>\n\nIf governance removes a gauge for any (non-malicious) reason, a user's voting power for that gauge will be completely lost.\n\n### Vulnerability details\n\nThe `GaugeController` is a solidity port of Curve DAO's Vyper implementation. Users are to vote for channeling incentives by using the `vote_for_gauge_weights()` function, and each user can fraction their voting power by $10000$ (that is, defined by BPS).\n\nOne modification from the original is that governance can now remove gauges, not allowing users to vote on it. However, any existing individual user's voting power before removal is not reset. Since `vote_for_gauge_weights()` does not allow voting for removed gauges, the voting power is then forever lost.\n\nConsider the following scenario:\n\n*   Alice has some veRWA, and is now able to vote.\n*   She votes on some pool, say, G1, using 100% of her voting power.\n*   Pool G1 is removed by governance due to any reason. Perhaps the pool was found to be faulty and liquidity should be migrated, perhaps the market itself has became illiquid and unsafe, perhaps the intended incentives duration for that pool has simply expired.\n*   Alice still has 100% of her voting power in that pool, but she cannot remove her vote and claim the voting power back.\n\nIt is worth noting that, even if Alice does not use 100% of her voting power on that particular gauge, she would still lose whatever percent vote placed in that pool, and her overall voting power was weakened by said percent.\n\n### Impact\n\nUsers can lose their voting power.\n\n### Proof of concept\n\nWe provide the following POC to use on `GaugeController` tests.\n\n<details>\n\n```solidity\nfunction testPOC() public {\n    // prepare\n    uint256 v = 10 ether;\n    vm.deal(gov, v);\n    vm.startPrank(gov);\n    ve.createLock{value: v}(v);\n\n    // add gauges\n    gc.add_gauge(gauge1);\n    gc.change_gauge_weight(gauge1, 100);\n    gc.add_gauge(gauge2);\n    gc.change_gauge_weight(gauge2, 100);\n\n    // all-in on gauge1\n    gc.vote_for_gauge_weights(gauge1, 10000);\n\n    // governance removes gauge1\n    gc.remove_gauge(gauge1);\n\n    // cannot vote for gauge2\n    vm.expectRevert(\"Used too much power\");\n    gc.vote_for_gauge_weights(gauge2, 10000);\n\n    // cannot remove vote for gauge1\n    vm.expectRevert(\"Invalid gauge address\"); // @audit remove when mitigate\n    gc.vote_for_gauge_weights(gauge1, 0);\n\n    // cannot vote for gauge2 (to demonstrate again that voting power is not removed)\n    vm.expectRevert(\"Used too much power\");  // @audit remove when mitigate\n    gc.vote_for_gauge_weights(gauge2, 10000);\n}\n```\n\n</details>\n\n### Tools used\n\nForge\n\n### Recommended mitigation steps\n\nThe simplest way to mitigate this is to **allow zero-weight votings on expired pools** simply to remove the vote. Modify line 213 as follow:\n\n```solidity\nrequire(_user_weight == 0 || isValidGauge[_gauge_addr], \"Can only vote 0 on non-gauges\");\n```\n\n<https://github.com/code-423n4/2023-08-verwa/blob/main/src/GaugeController.sol#L213>\n\nThe given POC can then be the test case to verify successful mitigation.\n\nAs a QA-based recommendation, the sponsor can also provide an external function to remove votes, and/or provide a function to vote for various pools in the same tx. This will allow users to channel their votes directly from removed pools to ongoing pools.\n\n***\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-08-verwa",
  "Code": [
    {
      "filename": "src/GaugeController.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.16;\n\nimport {VotingEscrow} from \"./VotingEscrow.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/// @title  GaugeController\n/// @author Curve Finance (MIT) - original concept and implementation in Vyper\n///         mkt.market - Porting to Solidity with some modifications (this version)\n/// @notice Allows users to vote on distribution of CANTO that the contract receives from governance. Modifications from Curve:\n///         - Gauge types removed (resulting in the removal of the differentiation between tracking of total / sum)\n///         - Different whitelisting of gauge addresses because of removed types\n///         - Removal of gauges\ncontract GaugeController {\n    // Constants\n    uint256 public constant WEEK = 7 days;\n    uint256 public constant MULTIPLIER = 10**18;\n\n    // Events\n    event NewGauge(address indexed gauge_address);\n    event GaugeRemoved(address indexed gauge_address);\n\n    // State\n    VotingEscrow public votingEscrow;\n    address public governance;\n    mapping(address => bool) public isValidGauge;\n    mapping(address => mapping(address => VotedSlope)) public vote_user_slopes;\n    mapping(address => uint256) public vote_user_power;\n    mapping(address => mapping(address => uint256)) public last_user_vote;\n\n    mapping(address => mapping(uint256 => Point)) public points_weight;\n    mapping(address => mapping(uint256 => uint256)) public changes_weight;\n    mapping(address => uint256) time_weight;\n\n    mapping(uint256 => Point) points_sum;\n    mapping(uint256 => uint256) changes_sum;\n    uint256 public time_sum;\n\n    struct Point {\n        uint256 bias;\n        uint256 slope;\n    }\n\n    struct VotedSlope {\n        uint256 slope;\n        uint256 power;\n        uint256 end;\n    }\n\n    modifier onlyGovernance() {\n        require(msg.sender == governance);\n        _;\n    }\n\n    /// @notice Initializes state\n    /// @param _votingEscrow The voting escrow address\n    constructor(address _votingEscrow, address _governance) {\n        votingEscrow = VotingEscrow(_votingEscrow);\n        governance = _governance; // TODO: Maybe change to Oracle\n        uint256 last_epoch = (block.timestamp / WEEK) * WEEK;\n        time_sum = last_epoch;\n    }\n\n    /// @notice Fill historic gauge weights week-over-week for missed checkins and return the sum for the future week\n    /// @return Sum of weights\n    function _get_sum() internal returns (uint256) {\n        uint256 t = time_sum;\n        Point memory pt = points_sum[t];\n        for (uint256 i; i < 500; ++i) {\n            if (t > block.timestamp) break;\n            t += WEEK;\n            uint256 d_bias = pt.slope * WEEK;\n            if (pt.bias > d_bias) {\n                pt.bias -= d_bias;\n                uint256 d_slope = changes_sum[t];\n                pt.slope -= d_slope;\n            } else {\n                pt.bias = 0;\n                pt.slope = 0;\n            }\n            points_sum[t] = pt;\n            if (t > block.timestamp) time_sum = t;\n        }\n        return pt.bias;\n    }\n\n    /// @notice Fill historic gauge weights week-over-week for missed checkins\n    /// and return the total for the future week\n    /// @param _gauge_addr Address of the gauge\n    /// @return Gauge weight\n    function _get_weight(address _gauge_addr) private returns (uint256) {\n        uint256 t = time_weight[_gauge_addr];\n        if (t > 0) {\n            Point memory pt = points_weight[_gauge_addr][t];\n            for (uint256 i; i < 500; ++i) {\n                if (t > block.timestamp) break;\n                t += WEEK;\n                uint256 d_bias = pt.slope * WEEK;\n                if (pt.bias > d_bias) {\n                    pt.bias -= d_bias;\n                    uint256 d_slope = changes_weight[_gauge_addr][t];\n                    pt.slope -= d_slope;\n                } else {\n                    pt.bias = 0;\n                    pt.slope = 0;\n                }\n                points_weight[_gauge_addr][t] = pt;\n                if (t > block.timestamp) time_weight[_gauge_addr] = t;\n            }\n            return pt.bias;\n        } else {\n            return 0;\n        }\n    }\n\n    /// @notice Add a new gauge, only callable by governance\n    /// @param _gauge The gauge address\n    function add_gauge(address _gauge) external onlyGovernance {\n        require(!isValidGauge[_gauge], \"Gauge already exists\");\n        isValidGauge[_gauge] = true;\n        emit NewGauge(_gauge);\n    }\n\n    /// @notice Remove a gauge, only callable by governance\n    /// @dev Sets the gauge weight to 0\n    /// @param _gauge The gauge address\n    function remove_gauge(address _gauge) external onlyGovernance {\n        require(isValidGauge[_gauge], \"Invalid gauge address\");\n        isValidGauge[_gauge] = false;\n        _change_gauge_weight(_gauge, 0);\n        emit GaugeRemoved(_gauge);\n    }\n\n    /// @notice Checkpoint to fill data common for all gauges\n    function checkpoint() external {\n        _get_sum();\n    }\n\n    /// @notice Checkpoint to fill data for both a specific gauge and common for all gauges\n    /// @param _gauge The gauge address\n    function checkpoint_gauge(address _gauge) external {\n        _get_weight(_gauge);\n        _get_sum();\n    }\n\n    /// @notice Get Gauge relative weight (not more than 1.0) normalized to 1e18\n    ///     (e.g. 1.0 == 1e18). Inflation which will be received by it is\n    ///     inflation_rate * relative_weight / 1e18\n    /// @param _gauge Gauge address\n    /// @param _time Relative weight at the specified timestamp in the past or present\n    /// @return Value of relative weight normalized to 1e18\n    function _gauge_relative_weight(address _gauge, uint256 _time) private view returns (uint256) {\n        uint256 t = (_time / WEEK) * WEEK;\n        uint256 total_weight = points_sum[t].bias;\n        if (total_weight > 0) {\n            uint256 gauge_weight = points_weight[_gauge][t].bias;\n            return (MULTIPLIER * gauge_weight) / total_weight;\n        } else {\n            return 0;\n        }\n    }\n\n    /// @notice Get Gauge relative weight (not more than 1.0) normalized to 1e18\n    ///     (e.g. 1.0 == 1e18). Inflation which will be received by it is\n    ///     inflation_rate * relative_weight / 1e18\n    /// @param _gauge Gauge address\n    /// @param _time Relative weight at the specified timestamp in the past or present\n    /// @return Value of relative weight normalized to 1e18\n    function gauge_relative_weight(address _gauge, uint256 _time) external view returns (uint256) {\n        return _gauge_relative_weight(_gauge, _time);\n    }\n\n    /// @notice Get gauge weight normalized to 1e18 and also fill all the unfilled\n    ///     values for type and gauge records\n    /// @dev Any address can call, however nothing is recorded if the values are filled already\n    /// @param _gauge Gauge address\n    /// @param _time Relative weight at the specified timestamp in the past or present\n    /// @return Value of relative weight normalized to 1e18\n    function gauge_relative_weight_write(address _gauge, uint256 _time) external returns (uint256) {\n        _get_weight(_gauge);\n        _get_sum();\n        return _gauge_relative_weight(_gauge, _time);\n    }\n\n    /// @notice Overwrite gauge weight\n    /// @param _gauge Gauge address\n    /// @param _weight New weight\n    function _change_gauge_weight(address _gauge, uint256 _weight) internal {\n        uint256 old_gauge_weight = _get_weight(_gauge);\n        uint256 old_sum = _get_sum();\n        uint256 next_time = ((block.timestamp + WEEK) / WEEK) * WEEK;\n\n        points_weight[_gauge][next_time].bias = _weight;\n        time_weight[_gauge] = next_time;\n\n        uint256 new_sum = old_sum + _weight - old_gauge_weight;\n        points_sum[next_time].bias = new_sum;\n        time_sum = next_time;\n    }\n\n    /// @notice Allows governance to overwrite gauge weights\n    /// @param _gauge Gauge address\n    /// @param _weight New weight\n    function change_gauge_weight(address _gauge, uint256 _weight) public onlyGovernance {\n        _change_gauge_weight(_gauge, _weight);\n    }\n\n    /// @notice Allocate voting power for changing pool weights\n    /// @param _gauge_addr Gauge which `msg.sender` votes for\n    /// @param _user_weight Weight for a gauge in bps (units of 0.01%). Minimal is 0.01%. Ignored if 0\n    function vote_for_gauge_weights(address _gauge_addr, uint256 _user_weight) external {\n        require(_user_weight >= 0 && _user_weight <= 10_000, \"Invalid user weight\");\n        require(isValidGauge[_gauge_addr], \"Invalid gauge address\");\n        VotingEscrow ve = votingEscrow;\n        (\n            ,\n            /*int128 bias*/\n            int128 slope_, /*uint256 ts*/\n\n        ) = ve.getLastUserPoint(msg.sender);\n        require(slope_ >= 0, \"Invalid slope\");\n        uint256 slope = uint256(uint128(slope_));\n        uint256 lock_end = ve.lockEnd(msg.sender);\n        uint256 next_time = ((block.timestamp + WEEK) / WEEK) * WEEK;\n        require(lock_end > next_time, \"Lock expires too soon\");\n        VotedSlope memory old_slope = vote_user_slopes[msg.sender][_gauge_addr];\n        uint256 old_dt = 0;\n        if (old_slope.end > next_time) old_dt = old_slope.end - next_time;\n        uint256 old_bias = old_slope.slope * old_dt;\n        VotedSlope memory new_slope = VotedSlope({\n            slope: (slope * _user_weight) / 10_000,\n            end: lock_end,\n            power: _user_weight\n        });\n        uint256 new_dt = lock_end - next_time;\n        uint256 new_bias = new_slope.slope * new_dt;\n\n        // Check and update powers (weights) used\n        uint256 power_used = vote_user_power[msg.sender];\n        power_used = power_used + new_slope.power - old_slope.power;\n        require(power_used >= 0 && power_used <= 10_000, \"Used too much power\");\n        vote_user_power[msg.sender] = power_used;\n\n        // Remove old and schedule new slope changes\n        // Remove slope changes for old slopes\n        // Schedule recording of initial slope for next_time\n        uint256 old_weight_bias = _get_weight(_gauge_addr);\n        uint256 old_weight_slope = points_weight[_gauge_addr][next_time].slope;\n        uint256 old_sum_bias = _get_sum();\n        uint256 old_sum_slope = points_sum[next_time].slope;\n\n        points_weight[_gauge_addr][next_time].bias = Math.max(old_weight_bias + new_bias, old_bias) - old_bias;\n        points_sum[next_time].bias = Math.max(old_sum_bias + new_bias, old_bias) - old_bias;\n        if (old_slope.end > next_time) {\n            points_weight[_gauge_addr][next_time].slope =\n                Math.max(old_weight_slope + new_slope.slope, old_slope.slope) -\n                old_slope.slope;\n            points_sum[next_time].slope = Math.max(old_sum_slope + new_slope.slope, old_slope.slope) - old_slope.slope;\n        } else {\n            points_weight[_gauge_addr][next_time].slope += new_slope.slope;\n            points_sum[next_time].slope += new_slope.slope;\n        }\n        if (old_slope.end > block.timestamp) {\n            // Cancel old slope changes if they still didn't happen\n            changes_weight[_gauge_addr][old_slope.end] -= old_slope.slope;\n            changes_sum[old_slope.end] -= old_slope.slope;\n        }\n        // Add slope changes for new slopes\n        changes_weight[_gauge_addr][new_slope.end] += new_slope.slope;\n        changes_sum[new_slope.end] += new_slope.slope;\n\n        _get_sum();\n\n        vote_user_slopes[msg.sender][_gauge_addr] = new_slope;\n\n        // Record last action time\n        last_user_vote[msg.sender][_gauge_addr] = block.timestamp;\n    }\n\n    /// @notice Get current gauge weight\n    /// @param _gauge Gauge address\n    /// @return Gauge weight\n    function get_gauge_weight(address _gauge) external view returns (uint256) {\n        return points_weight[_gauge][time_weight[_gauge]].bias;\n    }\n\n    /// @notice Get total weight\n    /// @return Total weight\n    function get_total_weight() external view returns (uint256) {\n        return points_sum[time_sum].bias;\n    }\n}"
    },
    {
      "filename": "src/GaugeController.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.16;\n\nimport {VotingEscrow} from \"./VotingEscrow.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/// @title  GaugeController\n/// @author Curve Finance (MIT) - original concept and implementation in Vyper\n///         mkt.market - Porting to Solidity with some modifications (this version)\n/// @notice Allows users to vote on distribution of CANTO that the contract receives from governance. Modifications from Curve:\n///         - Gauge types removed (resulting in the removal of the differentiation between tracking of total / sum)\n///         - Different whitelisting of gauge addresses because of removed types\n///         - Removal of gauges\ncontract GaugeController {\n    // Constants\n    uint256 public constant WEEK = 7 days;\n    uint256 public constant MULTIPLIER = 10**18;\n\n    // Events\n    event NewGauge(address indexed gauge_address);\n    event GaugeRemoved(address indexed gauge_address);\n\n    // State\n    VotingEscrow public votingEscrow;\n    address public governance;\n    mapping(address => bool) public isValidGauge;\n    mapping(address => mapping(address => VotedSlope)) public vote_user_slopes;\n    mapping(address => uint256) public vote_user_power;\n    mapping(address => mapping(address => uint256)) public last_user_vote;\n\n    mapping(address => mapping(uint256 => Point)) public points_weight;\n    mapping(address => mapping(uint256 => uint256)) public changes_weight;\n    mapping(address => uint256) time_weight;\n\n    mapping(uint256 => Point) points_sum;\n    mapping(uint256 => uint256) changes_sum;\n    uint256 public time_sum;\n\n    struct Point {\n        uint256 bias;\n        uint256 slope;\n    }\n\n    struct VotedSlope {\n        uint256 slope;\n        uint256 power;\n        uint256 end;\n    }\n\n    modifier onlyGovernance() {\n        require(msg.sender == governance);\n        _;\n    }\n\n    /// @notice Initializes state\n    /// @param _votingEscrow The voting escrow address\n    constructor(address _votingEscrow, address _governance) {\n        votingEscrow = VotingEscrow(_votingEscrow);\n        governance = _governance; // TODO: Maybe change to Oracle\n        uint256 last_epoch = (block.timestamp / WEEK) * WEEK;\n        time_sum = last_epoch;\n    }\n\n    /// @notice Fill historic gauge weights week-over-week for missed checkins and return the sum for the future week\n    /// @return Sum of weights\n    function _get_sum() internal returns (uint256) {\n        uint256 t = time_sum;\n        Point memory pt = points_sum[t];\n        for (uint256 i; i < 500; ++i) {\n            if (t > block.timestamp) break;\n            t += WEEK;\n            uint256 d_bias = pt.slope * WEEK;\n            if (pt.bias > d_bias) {\n                pt.bias -= d_bias;\n                uint256 d_slope = changes_sum[t];\n                pt.slope -= d_slope;\n            } else {\n                pt.bias = 0;\n                pt.slope = 0;\n            }\n            points_sum[t] = pt;\n            if (t > block.timestamp) time_sum = t;\n        }\n        return pt.bias;\n    }\n\n    /// @notice Fill historic gauge weights week-over-week for missed checkins\n    /// and return the total for the future week\n    /// @param _gauge_addr Address of the gauge\n    /// @return Gauge weight\n    function _get_weight(address _gauge_addr) private returns (uint256) {\n        uint256 t = time_weight[_gauge_addr];\n        if (t > 0) {\n            Point memory pt = points_weight[_gauge_addr][t];\n            for (uint256 i; i < 500; ++i) {\n                if (t > block.timestamp) break;\n                t += WEEK;\n                uint256 d_bias = pt.slope * WEEK;\n                if (pt.bias > d_bias) {\n                    pt.bias -= d_bias;\n                    uint256 d_slope = changes_weight[_gauge_addr][t];\n                    pt.slope -= d_slope;\n                } else {\n                    pt.bias = 0;\n                    pt.slope = 0;\n                }\n                points_weight[_gauge_addr][t] = pt;\n                if (t > block.timestamp) time_weight[_gauge_addr] = t;\n            }\n            return pt.bias;\n        } else {\n            return 0;\n        }\n    }\n\n    /// @notice Add a new gauge, only callable by governance\n    /// @param _gauge The gauge address\n    function add_gauge(address _gauge) external onlyGovernance {\n        require(!isValidGauge[_gauge], \"Gauge already exists\");\n        isValidGauge[_gauge] = true;\n        emit NewGauge(_gauge);\n    }\n\n    /// @notice Remove a gauge, only callable by governance\n    /// @dev Sets the gauge weight to 0\n    /// @param _gauge The gauge address\n    function remove_gauge(address _gauge) external onlyGovernance {\n        require(isValidGauge[_gauge], \"Invalid gauge address\");\n        isValidGauge[_gauge] = false;\n        _change_gauge_weight(_gauge, 0);\n        emit GaugeRemoved(_gauge);\n    }\n\n    /// @notice Checkpoint to fill data common for all gauges\n    function checkpoint() external {\n        _get_sum();\n    }\n\n    /// @notice Checkpoint to fill data for both a specific gauge and common for all gauges\n    /// @param _gauge The gauge address\n    function checkpoint_gauge(address _gauge) external {\n        _get_weight(_gauge);\n        _get_sum();\n    }\n\n    /// @notice Get Gauge relative weight (not more than 1.0) normalized to 1e18\n    ///     (e.g. 1.0 == 1e18). Inflation which will be received by it is\n    ///     inflation_rate * relative_weight / 1e18\n    /// @param _gauge Gauge address\n    /// @param _time Relative weight at the specified timestamp in the past or present\n    /// @return Value of relative weight normalized to 1e18\n    function _gauge_relative_weight(address _gauge, uint256 _time) private view returns (uint256) {\n        uint256 t = (_time / WEEK) * WEEK;\n        uint256 total_weight = points_sum[t].bias;\n        if (total_weight > 0) {\n            uint256 gauge_weight = points_weight[_gauge][t].bias;\n            return (MULTIPLIER * gauge_weight) / total_weight;\n        } else {\n            return 0;\n        }\n    }\n\n    /// @notice Get Gauge relative weight (not more than 1.0) normalized to 1e18\n    ///     (e.g. 1.0 == 1e18). Inflation which will be received by it is\n    ///     inflation_rate * relative_weight / 1e18\n    /// @param _gauge Gauge address\n    /// @param _time Relative weight at the specified timestamp in the past or present\n    /// @return Value of relative weight normalized to 1e18\n    function gauge_relative_weight(address _gauge, uint256 _time) external view returns (uint256) {\n        return _gauge_relative_weight(_gauge, _time);\n    }\n\n    /// @notice Get gauge weight normalized to 1e18 and also fill all the unfilled\n    ///     values for type and gauge records\n    /// @dev Any address can call, however nothing is recorded if the values are filled already\n    /// @param _gauge Gauge address\n    /// @param _time Relative weight at the specified timestamp in the past or present\n    /// @return Value of relative weight normalized to 1e18\n    function gauge_relative_weight_write(address _gauge, uint256 _time) external returns (uint256) {\n        _get_weight(_gauge);\n        _get_sum();\n        return _gauge_relative_weight(_gauge, _time);\n    }\n\n    /// @notice Overwrite gauge weight\n    /// @param _gauge Gauge address\n    /// @param _weight New weight\n    function _change_gauge_weight(address _gauge, uint256 _weight) internal {\n        uint256 old_gauge_weight = _get_weight(_gauge);\n        uint256 old_sum = _get_sum();\n        uint256 next_time = ((block.timestamp + WEEK) / WEEK) * WEEK;\n\n        points_weight[_gauge][next_time].bias = _weight;\n        time_weight[_gauge] = next_time;\n\n        uint256 new_sum = old_sum + _weight - old_gauge_weight;\n        points_sum[next_time].bias = new_sum;\n        time_sum = next_time;\n    }\n\n    /// @notice Allows governance to overwrite gauge weights\n    /// @param _gauge Gauge address\n    /// @param _weight New weight\n    function change_gauge_weight(address _gauge, uint256 _weight) public onlyGovernance {\n        _change_gauge_weight(_gauge, _weight);\n    }\n\n    /// @notice Allocate voting power for changing pool weights\n    /// @param _gauge_addr Gauge which `msg.sender` votes for\n    /// @param _user_weight Weight for a gauge in bps (units of 0.01%). Minimal is 0.01%. Ignored if 0\n    function vote_for_gauge_weights(address _gauge_addr, uint256 _user_weight) external {\n        require(_user_weight >= 0 && _user_weight <= 10_000, \"Invalid user weight\");\n        require(isValidGauge[_gauge_addr], \"Invalid gauge address\");\n        VotingEscrow ve = votingEscrow;\n        (\n            ,\n            /*int128 bias*/\n            int128 slope_, /*uint256 ts*/\n\n        ) = ve.getLastUserPoint(msg.sender);\n        require(slope_ >= 0, \"Invalid slope\");\n        uint256 slope = uint256(uint128(slope_));\n        uint256 lock_end = ve.lockEnd(msg.sender);\n        uint256 next_time = ((block.timestamp + WEEK) / WEEK) * WEEK;\n        require(lock_end > next_time, \"Lock expires too soon\");\n        VotedSlope memory old_slope = vote_user_slopes[msg.sender][_gauge_addr];\n        uint256 old_dt = 0;\n        if (old_slope.end > next_time) old_dt = old_slope.end - next_time;\n        uint256 old_bias = old_slope.slope * old_dt;\n        VotedSlope memory new_slope = VotedSlope({\n            slope: (slope * _user_weight) / 10_000,\n            end: lock_end,\n            power: _user_weight\n        });\n        uint256 new_dt = lock_end - next_time;\n        uint256 new_bias = new_slope.slope * new_dt;\n\n        // Check and update powers (weights) used\n        uint256 power_used = vote_user_power[msg.sender];\n        power_used = power_used + new_slope.power - old_slope.power;\n        require(power_used >= 0 && power_used <= 10_000, \"Used too much power\");\n        vote_user_power[msg.sender] = power_used;\n\n        // Remove old and schedule new slope changes\n        // Remove slope changes for old slopes\n        // Schedule recording of initial slope for next_time\n        uint256 old_weight_bias = _get_weight(_gauge_addr);\n        uint256 old_weight_slope = points_weight[_gauge_addr][next_time].slope;\n        uint256 old_sum_bias = _get_sum();\n        uint256 old_sum_slope = points_sum[next_time].slope;\n\n        points_weight[_gauge_addr][next_time].bias = Math.max(old_weight_bias + new_bias, old_bias) - old_bias;\n        points_sum[next_time].bias = Math.max(old_sum_bias + new_bias, old_bias) - old_bias;\n        if (old_slope.end > next_time) {\n            points_weight[_gauge_addr][next_time].slope =\n                Math.max(old_weight_slope + new_slope.slope, old_slope.slope) -\n                old_slope.slope;\n            points_sum[next_time].slope = Math.max(old_sum_slope + new_slope.slope, old_slope.slope) - old_slope.slope;\n        } else {\n            points_weight[_gauge_addr][next_time].slope += new_slope.slope;\n            points_sum[next_time].slope += new_slope.slope;\n        }\n        if (old_slope.end > block.timestamp) {\n            // Cancel old slope changes if they still didn't happen\n            changes_weight[_gauge_addr][old_slope.end] -= old_slope.slope;\n            changes_sum[old_slope.end] -= old_slope.slope;\n        }\n        // Add slope changes for new slopes\n        changes_weight[_gauge_addr][new_slope.end] += new_slope.slope;\n        changes_sum[new_slope.end] += new_slope.slope;\n\n        _get_sum();\n\n        vote_user_slopes[msg.sender][_gauge_addr] = new_slope;\n\n        // Record last action time\n        last_user_vote[msg.sender][_gauge_addr] = block.timestamp;\n    }\n\n    /// @notice Get current gauge weight\n    /// @param _gauge Gauge address\n    /// @return Gauge weight\n    function get_gauge_weight(address _gauge) external view returns (uint256) {\n        return points_weight[_gauge][time_weight[_gauge]].bias;\n    }\n\n    /// @notice Get total weight\n    /// @return Total weight\n    function get_total_weight() external view returns (uint256) {\n        return points_sum[time_sum].bias;\n    }\n}"
    },
    {
      "filename": "src/GaugeController.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.16;\n\nimport {VotingEscrow} from \"./VotingEscrow.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/// @title  GaugeController\n/// @author Curve Finance (MIT) - original concept and implementation in Vyper\n///         mkt.market - Porting to Solidity with some modifications (this version)\n/// @notice Allows users to vote on distribution of CANTO that the contract receives from governance. Modifications from Curve:\n///         - Gauge types removed (resulting in the removal of the differentiation between tracking of total / sum)\n///         - Different whitelisting of gauge addresses because of removed types\n///         - Removal of gauges\ncontract GaugeController {\n    // Constants\n    uint256 public constant WEEK = 7 days;\n    uint256 public constant MULTIPLIER = 10**18;\n\n    // Events\n    event NewGauge(address indexed gauge_address);\n    event GaugeRemoved(address indexed gauge_address);\n\n    // State\n    VotingEscrow public votingEscrow;\n    address public governance;\n    mapping(address => bool) public isValidGauge;\n    mapping(address => mapping(address => VotedSlope)) public vote_user_slopes;\n    mapping(address => uint256) public vote_user_power;\n    mapping(address => mapping(address => uint256)) public last_user_vote;\n\n    mapping(address => mapping(uint256 => Point)) public points_weight;\n    mapping(address => mapping(uint256 => uint256)) public changes_weight;\n    mapping(address => uint256) time_weight;\n\n    mapping(uint256 => Point) points_sum;\n    mapping(uint256 => uint256) changes_sum;\n    uint256 public time_sum;\n\n    struct Point {\n        uint256 bias;\n        uint256 slope;\n    }\n\n    struct VotedSlope {\n        uint256 slope;\n        uint256 power;\n        uint256 end;\n    }\n\n    modifier onlyGovernance() {\n        require(msg.sender == governance);\n        _;\n    }\n\n    /// @notice Initializes state\n    /// @param _votingEscrow The voting escrow address\n    constructor(address _votingEscrow, address _governance) {\n        votingEscrow = VotingEscrow(_votingEscrow);\n        governance = _governance; // TODO: Maybe change to Oracle\n        uint256 last_epoch = (block.timestamp / WEEK) * WEEK;\n        time_sum = last_epoch;\n    }\n\n    /// @notice Fill historic gauge weights week-over-week for missed checkins and return the sum for the future week\n    /// @return Sum of weights\n    function _get_sum() internal returns (uint256) {\n        uint256 t = time_sum;\n        Point memory pt = points_sum[t];\n        for (uint256 i; i < 500; ++i) {\n            if (t > block.timestamp) break;\n            t += WEEK;\n            uint256 d_bias = pt.slope * WEEK;\n            if (pt.bias > d_bias) {\n                pt.bias -= d_bias;\n                uint256 d_slope = changes_sum[t];\n                pt.slope -= d_slope;\n            } else {\n                pt.bias = 0;\n                pt.slope = 0;\n            }\n            points_sum[t] = pt;\n            if (t > block.timestamp) time_sum = t;\n        }\n        return pt.bias;\n    }\n\n    /// @notice Fill historic gauge weights week-over-week for missed checkins\n    /// and return the total for the future week\n    /// @param _gauge_addr Address of the gauge\n    /// @return Gauge weight\n    function _get_weight(address _gauge_addr) private returns (uint256) {\n        uint256 t = time_weight[_gauge_addr];\n        if (t > 0) {\n            Point memory pt = points_weight[_gauge_addr][t];\n            for (uint256 i; i < 500; ++i) {\n                if (t > block.timestamp) break;\n                t += WEEK;\n                uint256 d_bias = pt.slope * WEEK;\n                if (pt.bias > d_bias) {\n                    pt.bias -= d_bias;\n                    uint256 d_slope = changes_weight[_gauge_addr][t];\n                    pt.slope -= d_slope;\n                } else {\n                    pt.bias = 0;\n                    pt.slope = 0;\n                }\n                points_weight[_gauge_addr][t] = pt;\n                if (t > block.timestamp) time_weight[_gauge_addr] = t;\n            }\n            return pt.bias;\n        } else {\n            return 0;\n        }\n    }\n\n    /// @notice Add a new gauge, only callable by governance\n    /// @param _gauge The gauge address\n    function add_gauge(address _gauge) external onlyGovernance {\n        require(!isValidGauge[_gauge], \"Gauge already exists\");\n        isValidGauge[_gauge] = true;\n        emit NewGauge(_gauge);\n    }\n\n    /// @notice Remove a gauge, only callable by governance\n    /// @dev Sets the gauge weight to 0\n    /// @param _gauge The gauge address\n    function remove_gauge(address _gauge) external onlyGovernance {\n        require(isValidGauge[_gauge], \"Invalid gauge address\");\n        isValidGauge[_gauge] = false;\n        _change_gauge_weight(_gauge, 0);\n        emit GaugeRemoved(_gauge);\n    }\n\n    /// @notice Checkpoint to fill data common for all gauges\n    function checkpoint() external {\n        _get_sum();\n    }\n\n    /// @notice Checkpoint to fill data for both a specific gauge and common for all gauges\n    /// @param _gauge The gauge address\n    function checkpoint_gauge(address _gauge) external {\n        _get_weight(_gauge);\n        _get_sum();\n    }\n\n    /// @notice Get Gauge relative weight (not more than 1.0) normalized to 1e18\n    ///     (e.g. 1.0 == 1e18). Inflation which will be received by it is\n    ///     inflation_rate * relative_weight / 1e18\n    /// @param _gauge Gauge address\n    /// @param _time Relative weight at the specified timestamp in the past or present\n    /// @return Value of relative weight normalized to 1e18\n    function _gauge_relative_weight(address _gauge, uint256 _time) private view returns (uint256) {\n        uint256 t = (_time / WEEK) * WEEK;\n        uint256 total_weight = points_sum[t].bias;\n        if (total_weight > 0) {\n            uint256 gauge_weight = points_weight[_gauge][t].bias;\n            return (MULTIPLIER * gauge_weight) / total_weight;\n        } else {\n            return 0;\n        }\n    }\n\n    /// @notice Get Gauge relative weight (not more than 1.0) normalized to 1e18\n    ///     (e.g. 1.0 == 1e18). Inflation which will be received by it is\n    ///     inflation_rate * relative_weight / 1e18\n    /// @param _gauge Gauge address\n    /// @param _time Relative weight at the specified timestamp in the past or present\n    /// @return Value of relative weight normalized to 1e18\n    function gauge_relative_weight(address _gauge, uint256 _time) external view returns (uint256) {\n        return _gauge_relative_weight(_gauge, _time);\n    }\n\n    /// @notice Get gauge weight normalized to 1e18 and also fill all the unfilled\n    ///     values for type and gauge records\n    /// @dev Any address can call, however nothing is recorded if the values are filled already\n    /// @param _gauge Gauge address\n    /// @param _time Relative weight at the specified timestamp in the past or present\n    /// @return Value of relative weight normalized to 1e18\n    function gauge_relative_weight_write(address _gauge, uint256 _time) external returns (uint256) {\n        _get_weight(_gauge);\n        _get_sum();\n        return _gauge_relative_weight(_gauge, _time);\n    }\n\n    /// @notice Overwrite gauge weight\n    /// @param _gauge Gauge address\n    /// @param _weight New weight\n    function _change_gauge_weight(address _gauge, uint256 _weight) internal {\n        uint256 old_gauge_weight = _get_weight(_gauge);\n        uint256 old_sum = _get_sum();\n        uint256 next_time = ((block.timestamp + WEEK) / WEEK) * WEEK;\n\n        points_weight[_gauge][next_time].bias = _weight;\n        time_weight[_gauge] = next_time;\n\n        uint256 new_sum = old_sum + _weight - old_gauge_weight;\n        points_sum[next_time].bias = new_sum;\n        time_sum = next_time;\n    }\n\n    /// @notice Allows governance to overwrite gauge weights\n    /// @param _gauge Gauge address\n    /// @param _weight New weight\n    function change_gauge_weight(address _gauge, uint256 _weight) public onlyGovernance {\n        _change_gauge_weight(_gauge, _weight);\n    }\n\n    /// @notice Allocate voting power for changing pool weights\n    /// @param _gauge_addr Gauge which `msg.sender` votes for\n    /// @param _user_weight Weight for a gauge in bps (units of 0.01%). Minimal is 0.01%. Ignored if 0\n    function vote_for_gauge_weights(address _gauge_addr, uint256 _user_weight) external {\n        require(_user_weight >= 0 && _user_weight <= 10_000, \"Invalid user weight\");\n        require(isValidGauge[_gauge_addr], \"Invalid gauge address\");\n        VotingEscrow ve = votingEscrow;\n        (\n            ,\n            /*int1"
    }
  ]
}