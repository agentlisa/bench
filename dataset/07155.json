{
  "Title": "[M-04] sqrtDiscriminant can be calculated wrong",
  "Content": "\nDue to the wrong calculation of short and long tokens during the `leverage` and `deleverage` process, the users can suffer financial loss while the protocol will lose fees.\n\n### Proof of Concept\n\nThe protocol uses `leverage` function to deposit short tokens and receive long tokens. On the opposite, `deleverage` function serves for depositing long tokens and receiving short tokens.\n\n[Leverage Function of TimeswapV2Pool contract](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/TimeswapV2Pool.sol#L430-L466)\n\n[Deleverage Function of TimeswapV2Pool contract](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/TimeswapV2Pool.sol#L377-L418)\n\nBoth functions call the PoolLibrary's `leverage` and `deleverage` functions after input sanitization.\n\n[Leverage Function of PoolLibrary contract](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/structs/Pool.sol#L552-L655)\n\n[Deleverage Function of PoolLibrary contract](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/structs/Pool.sol#L469-L539)\n\nPoolLibrary's `leverage` and `deleverage` functions update the state of the pool first for the fee growth and compute the `long0Amount`, `long1Amount`, and `shortAmount`. It also checks the transaction type according to the passed parameter types as per the `Transaction` contract's enum types below and calls `ConstantProduct`'s appropriate function accordingly;\n\n```solidity\n/// @dev The different kind of deleverage transactions.\nenum TimeswapV2PoolDeleverage {\n    GivenDeltaSqrtInterestRate,\n    GivenLong,\n    GivenShort,\n    GivenSum\n}\n\n/// @dev The different kind of leverage transactions.\nenum TimeswapV2PoolLeverage {\n    GivenDeltaSqrtInterestRate,\n    GivenLong,\n    GivenShort,\n    GivenSum\n}\n```\n\nIf the transaction type is  `GivenSum`, both `leverage` and `deleverage` functions of PoolLibrary call `ConstantProduct.updateGivenSumLong` for the sum amount of the long position in the base denomination to be withdrawn, and the short position to be deposited.\n\n```solidity\n\n} else if (param.transaction == TimeswapV2PoolDeleverage.GivenSum) {\n\t(pool.sqrtInterestRate, longAmount, shortAmount, shortFees) = ConstantProduct.updateGivenSumLong(\n...\n```\n\n[Link](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/structs/Pool.sol#L516-L517)\n\n```solidity\n} else if (param.transaction == TimeswapV2PoolLeverage.GivenSum) {\n\t(pool.sqrtInterestRate, longAmount, shortAmount, ) = ConstantProduct.updateGivenSumLong(\n```\n\n[Link](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/structs/Pool.sol#L602-L603)\n\n`updateGivenSumLong` updates the new square root interest rate given the sum of long positions in base denomination change and short position change;\n\n```solidity\n    function updateGivenSumLong(\n        uint160 liquidity,\n        uint160 rate,\n        uint256 sumAmount,\n        uint96 duration,\n        uint256 transactionFee,\n        bool isAdd\n    ) internal pure returns (uint160 newRate, uint256 longAmount, uint256 shortAmount, uint256 fees) {\n        uint256 amount = getShortOrLongFromGivenSum(liquidity, rate, sumAmount, duration, transactionFee, isAdd);\n\n        if (isAdd) (newRate, ) = getNewSqrtInterestRateGivenShort(liquidity, rate, amount, duration, false);\n        else newRate = getNewSqrtInterestRateGivenLong(liquidity, rate, amount, false);\n\n        fees = FeeCalculation.getFeesRemoval(amount, transactionFee);\n        amount -= fees;\n\n        if (isAdd) {\n            shortAmount = amount;\n            longAmount = sumAmount - shortAmount;\n        } else {\n            longAmount = amount;\n            shortAmount = sumAmount - longAmount;\n        }\n    }\n```\n\n[Link](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/libraries/ConstantProduct.sol#L230-L253)\n\nAnd `updateGivenSumLong` calls `getShortOrLongFromGivenSum` in order to return the `amount` which represents the short amount or long amount calculated.\n\n```solidity\n    function getShortOrLongFromGivenSum(uint160 liquidity, uint160 rate, uint256 sumAmount, uint96 duration, uint256 transactionFee, bool isShort) private pure returns (uint256 amount) {\n        uint256 negativeB = calculateNegativeB(liquidity, rate, sumAmount, duration, transactionFee, isShort);\n        uint256 sqrtDiscriminant = calculateSqrtDiscriminant(liquidity, rate, sumAmount, duration, transactionFee, negativeB, isShort);\n        amount = (negativeB - sqrtDiscriminant).shr(1, false);\n    }\n```\n\n[Link](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/libraries/ConstantProduct.sol#L356-L362)\n\nAnd the formula needs `sqrtDiscriminant` value to calculate the `amount` and it calls `calculateSqrtDiscriminant` [accordingly](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/libraries/ConstantProduct.sol#L395)\n\n`calculateSqrtDiscriminant` function performs a bunch of checks and carries out mathematical functions to return the SqrtDiscriminant by utilizing FullMath and Math libraries.\n\n```solidity\nsqrtDiscriminant = FullMath.sqrt512(b0, b1, true);\n```\n\n[Link](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/libraries/ConstantProduct.sol#L430)\n\nThe `sqrt` formula in the Math contract uses the modified version of [Babylonian Method](https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method) when flags are included.\n\n```solidity\n    function sqrt(uint256 value, bool roundUp) internal pure returns (uint256 result) { \n        if (value == type(uint256).max) return result = type(uint128).max;\n        if (value == 0) return 0;\n        unchecked {\n            uint256 estimate = (value + 1) >> 1;\n            result = value;\n            while (estimate < result) {\n                result = estimate;\n                estimate = (value / estimate + estimate) >> 1;\n            }\n        }\n\n        if (roundUp && value % result != 0) result++;\n    }\n```\n\n[Link](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-library/src/Math.sol#L69-L79)\n\nHowever, when the parameter `roundUp` is passed as `true`, this results in inconsistent behavior for different values. And it's being passed as true as can be seen [here](https://github.com/code-423n4/2023-01-timeswap/blob/ef4c84fb8535aad8abd6b67cc45d994337ec4514/packages/v2-pool/src/libraries/ConstantProduct.sol#L430)).\n\nIn order to show some examples let's pass the numbers as values and flag them true by using Math's `sqrt` function.\n\n| Values  | 1 | 2 | 3 | 4 | 5 | 6     | 7 | 8     | 9 | 10 | 11 | 12    | 13 | 14 | 15    | 16 | 17 | 18 | 19 | 20    | 21 | 22 | 23 | 24    | 25 | 26 | 27 | 28 | 29 | 30    |\n| ------- | - | - | - | - | - | ----- | - | ----- | - | -- | -- | ----- | -- | -- | ----- | -- | -- | -- | -- | ----- | -- | -- | -- | ----- | -- | -- | -- | -- | -- | ----- |\n| Results | 1 | 1 | 1 | 2 | 3 | **2** | 3 | **2** | 3 | 4  | 4  | **3** | 4  | 4  | **3** | 4  | 5  | 5  | 5  | **4** | 5  | 5  | 5  | **4** | 5  | 6  | 6  | 6  | 6  | **5** |\n\nAs can be seen from the table, the results are not distributed logically. And many times the result is steeply lesser than its neighbor results. (E.g Sqrt(6) ->2, Sqrt(15)->3 etc.)\n\nThe phenomenon occurs most if the values are small numbers.\n\nSo if the parameter  `value1` in `FullMath.sqrt512` is passed/calculated as zero value, it has a high chance of providing a wrong calculation as a result with the line below;\n\n```solidity\n    function sqrt512(uint256 value0, uint256 value1, bool roundUp) internal pure returns (uint256 result) {\n        if (value1 == 0) result = value0.sqrt(roundUp);\n```\n\nThis may lead to the wrong calculation of the `sqrtDiscriminant`, hence the wrong calculation of short or long amounts for the given transaction. The users might lose financial value due to this. Accordingly, the protocol might lose unspent fees as well.\n\nWhile the fewer values are affected more on this one, the pools with fewer token decimals and fewer token amounts are more affected by this error. As an example, a [Gemini Dollar](https://coinmarketcap.com/currencies/gemini-dollar/) pool (59th rank on CMC and having 2 decimals) would be subject to false returns.\n\n### Tools Used\n\nRemix, Excel\n\n### Recommended Mitigation Steps\n\nThe team might consider not using `true` flag for `Math.sqrt` function.\n\n**[vhawk19 (Timeswap) confirmed and resolved](https://github.com/code-423n4/2023-01-timeswap-findings/issues/227#issuecomment-1422601119):**\n > Fixed in [PR](https://github.com/Timeswap-Labs/Timeswap-V2-Monorepo/pull/258).\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-01-timeswap",
  "Code": [
    {
      "filename": "packages/v2-pool/src/TimeswapV2Pool.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity =0.8.8;\n\nimport {Ownership} from \"@timeswap-labs/v2-library/src/Ownership.sol\";\n\nimport {Error} from \"@timeswap-labs/v2-library/src/Error.sol\";\n\nimport {ITimeswapV2Option} from \"@timeswap-labs/v2-option/src/interfaces/ITimeswapV2Option.sol\";\n\nimport {TimeswapV2OptionPosition} from \"@timeswap-labs/v2-option/src/enums/Position.sol\";\n\nimport {StrikeAndMaturity} from \"@timeswap-labs/v2-option/src/structs/StrikeAndMaturity.sol\";\n\nimport {NoDelegateCall} from \"./NoDelegateCall.sol\";\n\nimport {ITimeswapV2Pool} from \"./interfaces/ITimeswapV2Pool.sol\";\nimport {ITimeswapV2PoolFactory} from \"./interfaces/ITimeswapV2PoolFactory.sol\";\nimport {ITimeswapV2PoolDeployer} from \"./interfaces/ITimeswapV2PoolDeployer.sol\";\n\nimport {ITimeswapV2PoolMintCallback} from \"./interfaces/callbacks/ITimeswapV2PoolMintCallback.sol\";\nimport {ITimeswapV2PoolBurnCallback, ITimeswapV2PoolBurn2Callback} from \"./interfaces/callbacks/ITimeswapV2PoolBurnCallback.sol\";\nimport {ITimeswapV2PoolDeleverageCallback} from \"./interfaces/callbacks/ITimeswapV2PoolDeleverageCallback.sol\";\nimport {ITimeswapV2PoolLeverageCallback} from \"./interfaces/callbacks/ITimeswapV2PoolLeverageCallback.sol\";\nimport {ITimeswapV2PoolRebalanceCallback} from \"./interfaces/callbacks/ITimeswapV2PoolRebalanceCallback.sol\";\n\nimport {ReentrancyGuard} from \"./libraries/ReentrancyGuard.sol\";\n\nimport {LiquidityPosition, LiquidityPositionLibrary} from \"./structs/LiquidityPosition.sol\";\n\nimport {Pool, PoolLibrary} from \"./structs/Pool.sol\";\nimport {TimeswapV2PoolCollectParam, TimeswapV2PoolMintParam, TimeswapV2PoolBurnParam, TimeswapV2PoolDeleverageParam, TimeswapV2PoolLeverageParam, TimeswapV2PoolRebalanceParam, ParamLibrary} from \"./structs/Param.sol\";\nimport {TimeswapV2PoolMintChoiceCallbackParam, TimeswapV2PoolMintCallbackParam, TimeswapV2PoolBurnChoiceCallbackParam, TimeswapV2PoolBurnCallbackParam, TimeswapV2PoolDeleverageChoiceCallbackParam, TimeswapV2PoolDeleverageCallbackParam, TimeswapV2PoolLeverageCallbackParam, TimeswapV2PoolLeverageChoiceCallbackParam, TimeswapV2PoolRebalanceCallbackParam} from \"./structs/CallbackParam.sol\";\n\nimport {TimeswapV2PoolMint, TimeswapV2PoolBurn, TimeswapV2PoolDeleverage, TimeswapV2PoolLeverage, TimeswapV2PoolRebalance, TransactionLibrary} from \"./enums/Transaction.sol\";\n\ncontract TimeswapV2Pool is ITimeswapV2Pool, NoDelegateCall {\n    using PoolLibrary for Pool;\n    using Ownership for address;\n    using LiquidityPositionLibrary for LiquidityPosition;\n\n    /* ===== MODEL ===== */\n\n    /// @inheritdoc ITimeswapV2Pool\n    address public immutable override poolFactory;\n    /// @inheritdoc ITimeswapV2Pool\n    address public immutable override optionPair;\n    /// @inheritdoc ITimeswapV2Pool\n    uint256 public immutable override transactionFee;\n    /// @inheritdoc ITimeswapV2Pool\n    uint256 public immutable override protocolFee;\n\n    mapping(uint256 => mapping(uint256 => uint96)) private reentrancyGuards;\n    mapping(uint256 => mapping(uint256 => Pool)) private pools;\n\n    StrikeAndMaturity[] private listOfPools;\n\n    function addPoolEnumerationIfNecessary(uint256 strike, uint256 maturity) private {\n        if (reentrancyGuards[strike][maturity] == ReentrancyGuard.NOT_INTERACTED) {\n            reentrancyGuards[strike][maturity] = ReentrancyGuard.NOT_ENTERED;\n            listOfPools.push(StrikeAndMaturity({strike: strike, maturity: maturity}));\n        }\n    }\n\n    /* ===== MODIFIER ===== */\n\n    function raiseGuard(uint256 strike, uint256 maturity) private {\n        ReentrancyGuard.check(reentrancyGuards[strike][maturity]);\n        reentrancyGuards[strike][maturity] = ReentrancyGuard.ENTERED;\n    }\n\n    function lowerGuard(uint256 strike, uint256 maturity) private {\n        reentrancyGuards[strike][maturity] = ReentrancyGuard.NOT_ENTERED;\n    }\n\n    /* ===== INIT ===== */\n\n    constructor() NoDelegateCall() {\n        (poolFactory, optionPair, transactionFee, protocolFee) = ITimeswapV2PoolDeployer(msg.sender).parameter();\n    }\n\n    // Can be overidden for testing purposes.\n    function blockTimestamp(uint96 durationForward) internal view virtual returns (uint96) {\n        return uint96(block.timestamp + durationForward); // truncation is desired\n    }\n\n    /* ===== VIEW ===== */\n\n    /// @inheritdoc ITimeswapV2Pool\n    function getByIndex(uint256 id) external view override returns (StrikeAndMaturity memory) {\n        return listOfPools[id];\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function numberOfPools() external view override returns (uint256) {\n        return listOfPools.length;\n    }\n\n    function hasLiquidity(uint256 strike, uint256 maturity) private view {\n        if (pools[strike][maturity].liquidity == 0) Error.requireLiquidity();\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function totalLiquidity(uint256 strike, uint256 maturity) external view override returns (uint160) {\n        return pools[strike][maturity].liquidity;\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function sqrtInterestRate(uint256 strike, uint256 maturity) external view override returns (uint160) {\n        return pools[strike][maturity].sqrtInterestRate;\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function liquidityOf(uint256 strike, uint256 maturity, address owner) external view override returns (uint160) {\n        return pools[strike][maturity].liquidityPositions[owner].liquidity;\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function feeGrowth(uint256 strike, uint256 maturity) external view override returns (uint256 long0FeeGrowth, uint256 long1FeeGrowth, uint256 shortFeeGrowth) {\n        return pools[strike][maturity].feeGrowth();\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function feesEarnedOf(uint256 strike, uint256 maturity, address owner) external view override returns (uint256 long0Fees, uint256 long1Fees, uint256 shortFees) {\n        return pools[strike][maturity].feesEarnedOf(owner);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function protocolFeesEarned(uint256 strike, uint256 maturity) external view override returns (uint256 long0ProtocolFees, uint256 long1ProtocolFees, uint256 shortProtocolFees) {\n        return pools[strike][maturity].protocolFeesEarned();\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function totalLongBalance(uint256 strike, uint256 maturity) external view override returns (uint256 long0Amount, uint256 long1Amount) {\n        Pool storage pool = pools[strike][maturity];\n        long0Amount = pool.long0Balance;\n        long1Amount = pool.long1Balance;\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function totalLongBalanceAdjustFees(uint256 strike, uint256 maturity) external view override returns (uint256 long0Amount, uint256 long1Amount) {\n        (long0Amount, long1Amount) = pools[strike][maturity].totalLongBalanceAdjustFees(transactionFee);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function totalPositions(uint256 strike, uint256 maturity) external view override returns (uint256 longAmount, uint256 shortAmount) {\n        (longAmount, shortAmount) = pools[strike][maturity].totalPositions(maturity, blockTimestamp(0));\n    }\n\n    /* ===== UPDATE ===== */\n\n    /// @inheritdoc ITimeswapV2Pool\n    function transferLiquidity(uint256 strike, uint256 maturity, address to, uint160 liquidityAmount) external override {\n        hasLiquidity(strike, maturity);\n\n        if (blockTimestamp(0) > maturity) Error.alreadyMatured(maturity, blockTimestamp(0));\n        if (to == address(0)) Error.zeroAddress();\n        if (liquidityAmount == 0) Error.zeroInput();\n\n        pools[strike][maturity].transferLiquidity(to, liquidityAmount, blockTimestamp(0));\n\n        emit TransferLiquidity(strike, maturity, msg.sender, to, liquidityAmount);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function transferFees(uint256 strike, uint256 maturity, address to, uint256 long0Fees, uint256 long1Fees, uint256 shortFees) external override {\n        if (to == address(0)) Error.zeroAddress();\n        if (long0Fees == 0 && long1Fees == 0 && shortFees == 0) Error.zeroInput();\n\n        pools[strike][maturity].transferFees(maturity, to, long0Fees, long1Fees, shortFees, blockTimestamp(0));\n\n        emit TransferFees(strike, maturity, msg.sender, to, long0Fees, long1Fees, shortFees);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function initialize(uint256 strike, uint256 maturity, uint160 rate) external override noDelegateCall {\n        if (maturity < blockTimestamp(0)) Error.alreadyMatured(maturity, blockTimestamp(0));\n        if (rate == 0) Error.cannotBeZero();\n        addPoolEnumerationIfNecessary(strike, maturity);\n\n        pools[strike][maturity].initialize(rate);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function collectProtocolFees(TimeswapV2PoolCollectParam calldata param) external override noDelegateCall returns (uint256 long0Amount, uint256 long1Amount, uint256 shortAmount) {\n        ParamLibrary.check(param);\n        raiseGuard(param.strike, param.maturity);\n\n        // Can only be called by the TimeswapV2Pool factory owner.\n        ITimeswapV2PoolFactory(poolFactory).owner().checkIfOwner();\n\n        // Calculate the main logic of protocol fee.\n        (long0Amount, long1Amount, shortAmount) = pools[param.strike][param.maturity].collectProtocolFees(param.long0Requested, param.long1Requested, param.shortRequested);\n\n        collect(param.strike, param.maturity, param.long0To, param.long1To, param.shortTo, long0Amount, long1Amount, shortAmount);\n\n        lowerGuard(param.strike, param.maturity);\n\n        emit CollectProtocolFees(param.strike, param.maturity, msg.sender, param.long0To, param.long1To, param.shortTo, long0Amount, long1Amount, shortAmount);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function collectTransactionFees(TimeswapV2PoolCollectParam calldata param) external override noDelegateCall returns (uint256 long0Amount, uint256 long1Amount, uint256 shortAmount) {\n        ParamLibrary.check(param);\n        raiseGuard(param.strike, param.maturity);\n\n        // Calculate the main logic of transaction fee.\n        (long0Amount, long1Amount, shortAmount) = pools[param.strike][param.maturity].collectTransactionFees(\n            param.maturity,\n            param.long0Requested,\n            param.long1Requested,\n            param.shortRequested,\n            blockTimestamp(0)\n        );\n\n        collect(param.strike, param.maturity, param.long0To, param.long1To, param.shortTo, long0Amount, long1Amount, shortAmount);\n\n        lowerGuard(param.strike, param.maturity);\n\n        emit CollectTransactionFee(param.strike, param.maturity, msg.sender, param.long0To, param.long1To, param.shortTo, long0Amount, long1Amount, shortAmount);\n    }\n\n    /// @dev Transfer long0 positions, long1 positions, and/or short positions to the receipients.\n    /// @param strike The strike price of the pool.\n    /// @param maturity The maturity of the pool.\n    /// @param long0To The receipient of long0 positions.\n    /// @param long1To The receipient of long1 positions.\n    /// @param shortTo The receipient of short positions.\n    /// @param long0Amount The amount of long0 positions wanted.\n    /// @param long1Amount The amount of long1 positions wanted.\n    /// @param shortAmount The amount of short positions wanted.\n    function collect(uint256 strike, uint256 maturity, address long0To, address long1To, address shortTo, uint256 long0Amount, uint256 long1Amount, uint256 shortAmount) private {\n        if (long0Amount != 0) ITimeswapV2Option(optionPair).transferPosition(strike, maturity, long0To, TimeswapV2OptionPosition.Long0, long0Amount);\n\n        if (long1Amount != 0) ITimeswapV2Option(optionPair).transferPosition(strike, maturity, long1To, TimeswapV2OptionPosition.Long1, long1Amount);\n\n        if (shortAmount != 0) ITimeswapV2Option(optionPair).transferPosition(strike, maturity, shortTo, TimeswapV2OptionPosition.Short, shortAmount);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function mint(TimeswapV2PoolMintParam calldata param) external override returns (uint160 liquidityAmount, uint256 long0Amount, uint256 long1Amount, uint256 shortAmount, bytes memory data) {\n        return mint(param, false, 0);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function mint(\n        TimeswapV2PoolMintParam calldata param,\n        uint96 durationForward\n    ) external override returns (uint160 liquidityAmount, uint256 long0Amount, uint256 long1Amount, uint256 shortAmount, bytes memory data) {\n        return mint(param, true, durationForward);\n    }\n\n    function mint(\n        TimeswapV2PoolMintParam calldata param,\n        bool isQuote,\n        uint96 durationForward\n    ) private noDelegateCall returns (uint160 liquidityAmount, uint256 long0Amount, uint256 long1Amount, uint256 shortAmount, bytes memory data) {\n        ParamLibrary.check(param, blockTimestamp(durationForward));\n        raiseGuard(param.strike, param.maturity);\n\n        // Calculate the main logic of mint function.\n        (liquidityAmount, long0Amount, long1Amount, shortAmount, data) = pools[param.strike][param.maturity].mint(param, blockTimestamp(durationForward));\n\n        // Calculate the amount of long0 position, long1 position, and short position required by the pool.\n\n        // long0Amount chosen could be zero. Skip the calculation for gas efficiency.\n        uint256 long0BalanceTarget;\n        if (long0Amount != 0) long0BalanceTarget = ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long0) + long0Amount;\n\n        // long1Amount chosen could be zero. Skip the calculation for gas efficiency.\n        uint256 long1BalanceTarget;\n        if (long1Amount != 0) long1BalanceTarget = ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long1) + long1Amount;\n\n        // shortAmount cannot be zero.\n        uint256 shortBalanceTarget = ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Short) + shortAmount;\n\n        // Ask the msg.sender to transfer the positions into this address.\n        data = ITimeswapV2PoolMintCallback(msg.sender).timeswapV2PoolMintCallback(\n            TimeswapV2PoolMintCallbackParam({\n                strike: param.strike,\n                maturity: param.maturity,\n                long0Amount: long0Amount,\n                long1Amount: long1Amount,\n                shortAmount: shortAmount,\n                liquidityAmount: liquidityAmount,\n                data: data\n            })\n        );\n\n        if (isQuote) revert Quote();\n\n        // Check when the position balance targets are reached.\n\n        if (long0Amount != 0) Error.checkEnough(ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long0), long0BalanceTarget);\n\n        if (long1Amount != 0) Error.checkEnough(ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long1), long1BalanceTarget);\n\n        Error.checkEnough(ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Short), shortBalanceTarget);\n\n        lowerGuard(param.strike, param.maturity);\n\n        emit Mint(param.strike, param.maturity, msg.sender, param.to, liquidityAmount, long0Amount, long1Amount, shortAmount);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function burn(TimeswapV2PoolBurnParam calldata param) external override returns (uint160 liquidityAmount, uint256 long0Amount, uint256 long1Amount, uint256 shortAmount, bytes memory data) {\n        return burn(param, false, 0);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function burn(\n        TimeswapV2PoolBurnParam calldata param,\n        uint96 durationForward\n    ) external override returns (uint160 liquidityAmount, uint256 long0Amount, uint256 long1Amount, uint256 shortAmount, bytes memory data) {\n        return burn(param, true, durationForward);\n    }\n\n    function burn(\n        TimeswapV2PoolBurnParam calldata param,\n        bool isQuote,\n        uint96 durationForward\n    ) private noDelegateCall returns (uint160 liquidityAmount, uint256 long0Amount, uint256 long1Amount, uint256 shortAmount, bytes memory data) {\n        hasLiquidity(param.strike, param.maturity);\n\n        ParamLibrary.check(param, blockTimestamp(durationForward));\n        raiseGuard(param.strike, param.maturity);\n\n        Pool storage pool = pools[param.strike][param.maturity];\n\n        // Calculate the main logic of burn function.\n        (liquidityAmount, long0Amount, long1Amount, shortAmount, data) = pool.burn(param, blockTimestamp(durationForward));\n\n        // Transfer the positions to the receipients.\n\n        // Long0 amount can be zero.\n        if (long0Amount != 0) ITimeswapV2Option(optionPair).transferPosition(param.strike, param.maturity, param.long0To, TimeswapV2OptionPosition.Long0, long0Amount);\n\n        // Long1 amount can be zero.\n        if (long1Amount != 0) ITimeswapV2Option(optionPair).transferPosition(param.strike, param.maturity, param.long1To, TimeswapV2OptionPosition.Long1, long1Amount);\n\n        // Short amount cannot be zero.\n        ITimeswapV2Option(optionPair).transferPosition(param.strike, param.maturity, param.shortTo, TimeswapV2OptionPosition.Short, shortAmount);\n\n        data = ITimeswapV2PoolBurn2Callback(msg.sender).timeswapV2PoolBurnCallback(\n            TimeswapV2PoolBurnCallbackParam({\n                strike: param.strike,\n                maturity: param.maturity,\n                long0Amount: long0Amount,\n                long1Amount: long1Amount,\n                shortAmount: shortAmount,\n                liquidityAmount: liquidityAmount,\n                data: data\n            })\n        );\n\n        if (isQuote) revert Quote();\n\n        pool.liquidityPositions[msg.sender].burn(liquidityAmount);\n\n        lowerGuard(param.strike, param.maturity);\n\n        emit Burn(param.strike, param.maturity, msg.sender, param.long0To, param.long1To, param.shortTo, liquidityAmount, long0Amount, long1Amount, shortAmount);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function deleverage(TimeswapV2PoolDeleverageParam calldata param) external override returns (uint256 long0Amount, uint256 long1Amount, uint256 shortAmount, bytes memory data) {\n        return deleverage(param, false, 0);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function deleverage(\n        TimeswapV2PoolDeleverageParam calldata param,\n        uint96 durationForward\n    ) external override returns (uint256 long0Amount, uint256 long1Amount, uint256 shortAmount, bytes memory data) {\n        return deleverage(param, true, durationForward);\n    }\n\n    function deleverage(\n        TimeswapV2PoolDeleverageParam calldata param,\n        bool isQuote,\n        uint96 durationForward\n    ) private noDelegateCall returns (uint256 long0Amount, uint256 long1Amount, uint256 shortAmount, bytes memory data) {\n        hasLiquidity(param.strike, param.maturity);\n        ParamLibrary.check(param, blockTimestamp(durationForward));\n        raiseGuard(param.strike, param.maturity);\n\n        // Calculate the main logic of deleverage function.\n        (long0Amount, long1Amount, shortAmount, data) = pools[param.strike][param.maturity].deleverage(param, transactionFee, protocolFee, blockTimestamp(durationForward));\n\n        // Calculate the amount of long0 position and long1 position required by the pool.\n\n        // long0Amount chosen could be zero. Skip the calculation for gas efficiency.\n        uint256 long0BalanceTarget;\n        if (long0Amount != 0) long0BalanceTarget = ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long0) + long0Amount;\n\n        // long1Amount chosen could be zero. Skip the calculation for gas efficiency.\n        uint256 long1BalanceTarget;\n        if (long1Amount != 0) long1BalanceTarget = ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long1) + long1Amount;\n\n        // Transfer short positions to the receipient.\n        ITimeswapV2Option(optionPair).transferPosition(param.strike, param.maturity, param.to, TimeswapV2OptionPosition.Short, shortAmount);\n\n        // Ask the msg.sender to transfer the positions into this address.\n        data = ITimeswapV2PoolDeleverageCallback(msg.sender).timeswapV2PoolDeleverageCallback(\n            TimeswapV2PoolDeleverageCallbackParam({strike: param.strike, maturity: param.maturity, long0Amount: long0Amount, long1Amount: long1Amount, shortAmount: shortAmount, data: data})\n        );\n\n        if (isQuote) revert Quote();\n\n        // Check when the position balance targets are reached.\n\n        if (long0Amount != 0) Error.checkEnough(ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long0), long0BalanceTarget);\n\n        if (long1Amount != 0) Error.checkEnough(ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Long1), long1BalanceTarget);\n\n        lowerGuard(param.strike, param.maturity);\n\n        emit Deleverage(param.strike, param.maturity, msg.sender, param.to, long0Amount, long1Amount, shortAmount);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function leverage(TimeswapV2PoolLeverageParam calldata param) external override returns (uint256 long0Amount, uint256 long1Amount, uint256 shortAmount, bytes memory data) {\n        return leverage(param, false, 0);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function leverage(TimeswapV2PoolLeverageParam calldata param, uint96 durationForward) external override returns (uint256 long0Amount, uint256 long1Amount, uint256 shortAmount, bytes memory data) {\n        return leverage(param, true, durationForward);\n    }\n\n    function leverage(\n        TimeswapV2PoolLeverageParam calldata param,\n        bool isQuote,\n        uint96 durationForward\n    ) private noDelegateCall returns (uint256 long0Amount, uint256 long1Amount, uint256 shortAmount, bytes memory data) {\n        hasLiquidity(param.strike, param.maturity);\n        ParamLibrary.check(param, blockTimestamp(durationForward));\n        raiseGuard(param.strike, param.maturity);\n\n        // Calculate the main logic of leverage function.\n        (long0Amount, long1Amount, shortAmount, data) = pools[param.strike][param.maturity].leverage(param, transactionFee, protocolFee, blockTimestamp(durationForward));\n\n        // Calculate the amount of short position required by the pool.\n\n        uint256 balanceTarget = ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Short) + shortAmount;\n\n        // Transfer the positions to the receipients.\n\n        if (long0Amount != 0) ITimeswapV2Option(optionPair).transferPosition(param.strike, param.maturity, param.long0To, TimeswapV2OptionPosition.Long0, long0Amount);\n\n        if (long1Amount != 0) ITimeswapV2Option(optionPair).transferPosition(param.strike, param.maturity, param.long1To, TimeswapV2OptionPosition.Long1, long1Amount);\n\n        // Ask the msg.sender to transfer the positions into this address.\n        data = ITimeswapV2PoolLeverageCallback(msg.sender).timeswapV2PoolLeverageCallback(\n            TimeswapV2PoolLeverageCallbackParam({strike: param.strike, maturity: param.maturity, long0Amount: long0Amount, long1Amount: long1Amount, shortAmount: shortAmount, data: data})\n        );\n\n        if (isQuote) revert Quote();\n\n        // Check when the position balance targets are reached.\n\n        Error.checkEnough(ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), TimeswapV2OptionPosition.Short), balanceTarget);\n\n        lowerGuard(param.strike, param.maturity);\n\n        emit Leverage(param.strike, param.maturity, msg.sender, param.long0To, param.long1To, long0Amount, long1Amount, shortAmount);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function rebalance(TimeswapV2PoolRebalanceParam calldata param) external override noDelegateCall returns (uint256 long0Amount, uint256 long1Amount, bytes memory data) {\n        hasLiquidity(param.strike, param.maturity);\n        ParamLibrary.check(param, blockTimestamp(0));\n        raiseGuard(param.strike, param.maturity);\n\n        // Calculate the main logic of rebalance function.\n        (long0Amount, long1Amount) = pools[param.strike][param.maturity].rebalance(param, transactionFee, protocolFee);\n\n        // Calculate the amount of long position required by the pool.\n\n        uint256 balanceTarget = ITimeswapV2Option(optionPair).positionOf(\n            param.strike,\n            param.maturity,\n            address(this),\n            param.isLong0ToLong1 ? TimeswapV2OptionPosition.Long0 : TimeswapV2OptionPosition.Long1\n        ) + (param.isLong0ToLong1 ? long0Amount : long1Amount);\n\n        // Transfer the positions to the receipients.\n\n        ITimeswapV2Option(optionPair).transferPosition(\n            param.strike,\n            param.maturity,\n            param.to,\n            param.isLong0ToLong1 ? TimeswapV2OptionPosition.Long1 : TimeswapV2OptionPosition.Long0,\n            param.isLong0ToLong1 ? long1Amount : long0Amount\n        );\n\n        // Ask the msg.sender to transfer the positions into this address.\n        data = ITimeswapV2PoolRebalanceCallback(msg.sender).timeswapV2PoolRebalanceCallback(\n            TimeswapV2PoolRebalanceCallbackParam({\n                strike: param.strike,\n                maturity: param.maturity,\n                isLong0ToLong1: param.isLong0ToLong1,\n                long0Amount: long0Amount,\n                long1Amount: long1Amount,\n                data: param.data\n            })\n        );\n\n        // Check when the position balance targets are reached.\n\n        Error.checkEnough(\n            ITimeswapV2Option(optionPair).positionOf(param.strike, param.maturity, address(this), param.isLong0ToLong1 ? TimeswapV2OptionPosition.Long0 : TimeswapV2OptionPosition.Long1),\n            balanceTarget\n        );\n\n        lowerGuard(param.strike, param.maturity);\n\n        emit Rebalance(param.strike, param.maturity, msg.sender, param.to, param.isLong0ToLong1, long0Amount, long1Amount);\n    }\n}"
    },
    {
      "filename": "packages/v2-pool/src/TimeswapV2Pool.sol",
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity =0.8.8;\n\nimport {Ownership} from \"@timeswap-labs/v2-library/src/Ownership.sol\";\n\nimport {Error} from \"@timeswap-labs/v2-library/src/Error.sol\";\n\nimport {ITimeswapV2Option} from \"@timeswap-labs/v2-option/src/interfaces/ITimeswapV2Option.sol\";\n\nimport {TimeswapV2OptionPosition} from \"@timeswap-labs/v2-option/src/enums/Position.sol\";\n\nimport {StrikeAndMaturity} from \"@timeswap-labs/v2-option/src/structs/StrikeAndMaturity.sol\";\n\nimport {NoDelegateCall} from \"./NoDelegateCall.sol\";\n\nimport {ITimeswapV2Pool} from \"./interfaces/ITimeswapV2Pool.sol\";\nimport {ITimeswapV2PoolFactory} from \"./interfaces/ITimeswapV2PoolFactory.sol\";\nimport {ITimeswapV2PoolDeployer} from \"./interfaces/ITimeswapV2PoolDeployer.sol\";\n\nimport {ITimeswapV2PoolMintCallback} from \"./interfaces/callbacks/ITimeswapV2PoolMintCallback.sol\";\nimport {ITimeswapV2PoolBurnCallback, ITimeswapV2PoolBurn2Callback} from \"./interfaces/callbacks/ITimeswapV2PoolBurnCallback.sol\";\nimport {ITimeswapV2PoolDeleverageCallback} from \"./interfaces/callbacks/ITimeswapV2PoolDeleverageCallback.sol\";\nimport {ITimeswapV2PoolLeverageCallback} from \"./interfaces/callbacks/ITimeswapV2PoolLeverageCallback.sol\";\nimport {ITimeswapV2PoolRebalanceCallback} from \"./interfaces/callbacks/ITimeswapV2PoolRebalanceCallback.sol\";\n\nimport {ReentrancyGuard} from \"./libraries/ReentrancyGuard.sol\";\n\nimport {LiquidityPosition, LiquidityPositionLibrary} from \"./structs/LiquidityPosition.sol\";\n\nimport {Pool, PoolLibrary} from \"./structs/Pool.sol\";\nimport {TimeswapV2PoolCollectParam, TimeswapV2PoolMintParam, TimeswapV2PoolBurnParam, TimeswapV2PoolDeleverageParam, TimeswapV2PoolLeverageParam, TimeswapV2PoolRebalanceParam, ParamLibrary} from \"./structs/Param.sol\";\nimport {TimeswapV2PoolMintChoiceCallbackParam, TimeswapV2PoolMintCallbackParam, TimeswapV2PoolBurnChoiceCallbackParam, TimeswapV2PoolBurnCallbackParam, TimeswapV2PoolDeleverageChoiceCallbackParam, TimeswapV2PoolDeleverageCallbackParam, TimeswapV2PoolLeverageCallbackParam, TimeswapV2PoolLeverageChoiceCallbackParam, TimeswapV2PoolRebalanceCallbackParam} from \"./structs/CallbackParam.sol\";\n\nimport {TimeswapV2PoolMint, TimeswapV2PoolBurn, TimeswapV2PoolDeleverage, TimeswapV2PoolLeverage, TimeswapV2PoolRebalance, TransactionLibrary} from \"./enums/Transaction.sol\";\n\ncontract TimeswapV2Pool is ITimeswapV2Pool, NoDelegateCall {\n    using PoolLibrary for Pool;\n    using Ownership for address;\n    using LiquidityPositionLibrary for LiquidityPosition;\n\n    /* ===== MODEL ===== */\n\n    /// @inheritdoc ITimeswapV2Pool\n    address public immutable override poolFactory;\n    /// @inheritdoc ITimeswapV2Pool\n    address public immutable override optionPair;\n    /// @inheritdoc ITimeswapV2Pool\n    uint256 public immutable override transactionFee;\n    /// @inheritdoc ITimeswapV2Pool\n    uint256 public immutable override protocolFee;\n\n    mapping(uint256 => mapping(uint256 => uint96)) private reentrancyGuards;\n    mapping(uint256 => mapping(uint256 => Pool)) private pools;\n\n    StrikeAndMaturity[] private listOfPools;\n\n    function addPoolEnumerationIfNecessary(uint256 strike, uint256 maturity) private {\n        if (reentrancyGuards[strike][maturity] == ReentrancyGuard.NOT_INTERACTED) {\n            reentrancyGuards[strike][maturity] = ReentrancyGuard.NOT_ENTERED;\n            listOfPools.push(StrikeAndMaturity({strike: strike, maturity: maturity}));\n        }\n    }\n\n    /* ===== MODIFIER ===== */\n\n    function raiseGuard(uint256 strike, uint256 maturity) private {\n        ReentrancyGuard.check(reentrancyGuards[strike][maturity]);\n        reentrancyGuards[strike][maturity] = ReentrancyGuard.ENTERED;\n    }\n\n    function lowerGuard(uint256 strike, uint256 maturity) private {\n        reentrancyGuards[strike][maturity] = ReentrancyGuard.NOT_ENTERED;\n    }\n\n    /* ===== INIT ===== */\n\n    constructor() NoDelegateCall() {\n        (poolFactory, optionPair, transactionFee, protocolFee) = ITimeswapV2PoolDeployer(msg.sender).parameter();\n    }\n\n    // Can be overidden for testing purposes.\n    function blockTimestamp(uint96 durationForward) internal view virtual returns (uint96) {\n        return uint96(block.timestamp + durationForward); // truncation is desired\n    }\n\n    /* ===== VIEW ===== */\n\n    /// @inheritdoc ITimeswapV2Pool\n    function getByIndex(uint256 id) external view override returns (StrikeAndMaturity memory) {\n        return listOfPools[id];\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function numberOfPools() external view override returns (uint256) {\n        return listOfPools.length;\n    }\n\n    function hasLiquidity(uint256 strike, uint256 maturity) private view {\n        if (pools[strike][maturity].liquidity == 0) Error.requireLiquidity();\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function totalLiquidity(uint256 strike, uint256 maturity) external view override returns (uint160) {\n        return pools[strike][maturity].liquidity;\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function sqrtInterestRate(uint256 strike, uint256 maturity) external view override returns (uint160) {\n        return pools[strike][maturity].sqrtInterestRate;\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function liquidityOf(uint256 strike, uint256 maturity, address owner) external view override returns (uint160) {\n        return pools[strike][maturity].liquidityPositions[owner].liquidity;\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function feeGrowth(uint256 strike, uint256 maturity) external view override returns (uint256 long0FeeGrowth, uint256 long1FeeGrowth, uint256 shortFeeGrowth) {\n        return pools[strike][maturity].feeGrowth();\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function feesEarnedOf(uint256 strike, uint256 maturity, address owner) external view override returns (uint256 long0Fees, uint256 long1Fees, uint256 shortFees) {\n        return pools[strike][maturity].feesEarnedOf(owner);\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function protocolFeesEarned(uint256 strike, uint256 maturity) external view override returns (uint256 long0ProtocolFees, uint256 long1ProtocolFees, uint256 shortProtocolFees) {\n        return pools[strike][maturity].protocolFeesEarned();\n    }\n\n    /// @inheritdoc ITimeswapV2Pool\n    function totalLongBalance(uint256 strike, uint256 maturity) external view override returns (uint256 long0Amount, uint256 long1Amount) {\n        Pool storage pool = pools[strike][maturity];\n        long0Amount = pool.long0B"
    }
  ]
}