{
  "Title": "[L01] Changing veto period can affect existing proposals",
  "Content": "The GrandaMento.sol contract introduced a [Veto Period](https://github.com/celo-org/celo-monorepo/blob/d06617c7f4e59f643a0a0120e5501bcf762f1a7d/packages/protocol/contracts/liquidity/GrandaMento.sol#L119) as a time buffer between a proposal’s approval and execution. This concept is critial from a proposer’s point of view and should not be changed after a proposal is proposed. However, the contract owner can update this value at anytime by calling the function [`setVetoPeriodSeconds`](https://github.com/celo-org/celo-monorepo/blob/d06617c7f4e59f643a0a0120e5501bcf762f1a7d/packages/protocol/contracts/liquidity/GrandaMento.sol#L604) which will lead to a change of veto period for all existing proposals including the ones approved. This could put existing proposals in a less preferable position, particularly the ones already approved since anyone can execute these proposals under a new veto period.\n\n\nConsidering baking the veto period into the proposal once it is created so it is not affected by future veto updates.\n\n\n***Update:** Fixed in [pull request #8369](https://github.com/celo-org/celo-monorepo/pull/8369/files).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/contracts/liquidity/GrandaMento.sol",
      "content": "pragma solidity ^0.5.13;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\nimport \"../common/FixidityLib.sol\";\nimport \"../common/Initializable.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/interfaces/ICeloVersionedContract.sol\";\nimport \"../common/libraries/ReentrancyGuard.sol\";\nimport \"../stability/interfaces/IStableToken.sol\";\n\n/**\n * @title Facilitates large exchanges between CELO stable tokens.\n */\ncontract GrandaMento is\n  ICeloVersionedContract,\n  Ownable,\n  Initializable,\n  UsingRegistry,\n  ReentrancyGuard\n{\n  using FixidityLib for FixidityLib.Fraction;\n  using SafeMath for uint256;\n\n  // Emitted when a new exchange proposal is created.\n  event ExchangeProposalCreated(\n    uint256 indexed proposalId,\n    address indexed exchanger,\n    string stableTokenRegistryId,\n    uint256 sellAmount,\n    uint256 buyAmount,\n    bool sellCelo\n  );\n\n  // Emitted when an exchange proposal is approved by the approver.\n  event ExchangeProposalApproved(uint256 indexed proposalId);\n\n  // Emitted when an exchange proposal is cancelled.\n  event ExchangeProposalCancelled(uint256 indexed proposalId);\n\n  // Emitted when an exchange proposal is executed.\n  event ExchangeProposalExecuted(uint256 indexed proposalId);\n\n  // Emitted when the approver is set.\n  event ApproverSet(address approver);\n\n  // Emitted when maxApprovalExchangeRateChange is set.\n  event MaxApprovalExchangeRateChangeSet(uint256 maxApprovalExchangeRateChange);\n\n  // Emitted when the spread is set.\n  event SpreadSet(uint256 spread);\n\n  // Emitted when the veto period in seconds is set.\n  event VetoPeriodSecondsSet(uint256 vetoPeriodSeconds);\n\n  // Emitted when the exchange limits for a stable token are set.\n  event StableTokenExchangeLimitsSet(\n    string stableTokenRegistryId,\n    uint256 minExchangeAmount,\n    uint256 maxExchangeAmount\n  );\n\n  enum ExchangeProposalState { None, Proposed, Approved, Executed, Cancelled }\n\n  struct ExchangeLimits {\n    // The minimum amount of an asset that can be exchanged in a single proposal.\n    uint256 minExchangeAmount;\n    // The maximum amount of an asset that can be exchanged in a single proposal.\n    uint256 maxExchangeAmount;\n  }\n\n  struct ExchangeProposal {\n    // The exchanger/proposer of the exchange proposal.\n    address payable exchanger;\n    // The stable token involved in this proposal. This is stored rather than\n    // the stable token's registry ID in case the contract address is changed\n    // while a stable token deposit\n    address stableToken;\n    // The state of the exchange proposal.\n    ExchangeProposalState state;\n    // Whether CELO is being sold and stableToken is being bought.\n    bool sellCelo;\n    // The amount of the sell token being sold. If a stable token is being sold,\n    // the amount of stable token in \"units\" is stored rather than the \"value.\"\n    // This is because stable tokens may experience demurrage/inflation, where\n    // the amount of stable token \"units\" doesn't change with time, but the \"value\"\n    // does. This is important to ensure the correct inflation-adjusted amount\n    // of the stable token is transferred out of this contract when a deposit is\n    // refunded or an exchange selling the stable token is executed.\n    // See StableToken.sol for more details on what \"units\" vs \"values\" are.\n    uint256 sellAmount;\n    // The amount of the buy token being bought. For stable tokens, this is\n    // kept track of as the value, not units.\n    uint256 buyAmount;\n    // The price of CELO quoted in stableToken at the time of the exchange proposal\n    // creation. This is the price used to calculate the buyAmount. Used for a\n    // safety check when an approval is being made that the price isn't wildly\n    // different. Recalculating buyAmount is not sufficient because if a stable token\n    // is being sold that has demurrage enabled, the original value when the stable\n    // tokens were deposited cannot be calculated.\n    uint256 celoStableTokenExchangeRate;\n    // The timestamp (`block.timestamp`) at which the exchange proposal was approved\n    // in seconds. If the exchange proposal has not ever been approved, is 0.\n    uint256 approvalTimestamp;\n  }\n\n  // The address with the authority to approve exchange proposals.\n  address public approver;\n\n  // The maximum allowed change in the CELO/stable token price when an exchange proposal\n  // is being approved relative to the rate when the exchange proposal was created.\n  FixidityLib.Fraction public maxApprovalExchangeRateChange;\n\n  // The percent fee imposed upon an exchange execution.\n  FixidityLib.Fraction public spread;\n\n  // The period in seconds after an approval during which an exchange proposal can be vetoed.\n  uint256 public vetoPeriodSeconds;\n\n  // The minimum and maximum amount of the stable token that can be minted or\n  // burned in a single exchange. Indexed by the stable token registry identifier string.\n  mapping(string => ExchangeLimits) public stableTokenExchangeLimits;\n\n  // State for all exchange proposals. Indexed by the exchange proposal ID.\n  mapping(uint256 => ExchangeProposal) public exchangeProposals;\n\n  // An array containing a superset of the IDs of exchange proposals that are currently\n  // in the Proposed or Approved state. Intended to allow easy viewing of all active\n  // exchange proposals. It's possible for a proposal ID in this array to no longer be\n  // active, so filtering is required to find the true set of active proposal IDs.\n  // A superset is kept because exchange proposal vetoes, intended to be done\n  // by Governance, effectively go through a multi-day timelock. If the veto\n  // call was required to provide the index in an array of activeProposalIds to\n  // remove corresponding to the vetoed exchange proposal, the timelock could result\n  // in the provided index being stale by the time the veto would be executed.\n  // Alternative approaches exist, like maintaining a linkedlist of active proposal\n  // IDs, but this approach was chosen for its low implementation complexity.\n  uint256[] public activeProposalIdsSuperset;\n\n  // Number of exchange proposals that have ever been created. Used for assigning\n  // an exchange proposal ID to a new proposal.\n  uint256 public exchangeProposalCount;\n\n  /**\n   * @notice Reverts if the sender is not the approver.\n   */\n  modifier onlyApprover() {\n    require(msg.sender == approver, \"Sender must be approver\");\n    _;\n  }\n\n  /**\n   * @notice Sets initialized == true on implementation contracts.\n   * @param test Set to true to skip implementation initialization.\n   */\n  constructor(bool test) public Initializable(test) {}\n\n  /**\n   * @notice Returns the storage, major, minor, and patch version of the contract.\n   * @return The storage, major, minor, and patch version of the contract.\n   */\n  function getVersionNumber() external pure returns (uint256, uint256, uint256, uint256) {\n    return (1, 1, 0, 0);\n  }\n\n  /**\n   * @notice Used in place of the constructor to allow the contract to be upgradable via proxy.\n   * @param _registry The address of the registry.\n   * @param _approver The approver that has the ability to approve exchange proposals.\n   * @param _maxApprovalExchangeRateChange The maximum allowed change in CELO price\n   * between an exchange proposal's creation and approval.\n   * @param _spread The spread charged on exchanges.\n   * @param _vetoPeriodSeconds The length of the veto period in seconds.\n   */\n  function initialize(\n    address _registry,\n    address _approver,\n    uint256 _maxApprovalExchangeRateChange,\n    uint256 _spread,\n    uint256 _vetoPeriodSeconds\n  ) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(_registry);\n    setApprover(_approver);\n    setMaxApprovalExchangeRateChange(_maxApprovalExchangeRateChange);\n    setSpread(_spread);\n    setVetoPeriodSeconds(_vetoPeriodSeconds);\n  }\n\n  /**\n   * @notice Creates a new exchange proposal and deposits the tokens being sold.\n   * @dev Stable token value amounts are used for the sellAmount, not unit amounts.\n   * @param stableTokenRegistryId The string registry ID for the stable token\n   * involved in the exchange.\n   * @param sellAmount The amount of the sell token being sold.\n   * @param sellCelo Whether CELO is being sold.\n   * @return The proposal identifier for the newly created exchange proposal.\n   */\n  function createExchangeProposal(\n    string calldata stableTokenRegistryId,\n    uint256 sellAmount,\n    bool sellCelo\n  ) external nonReentrant returns (uint256) {\n    address stableToken = registry.getAddressForStringOrDie(stableTokenRegistryId);\n\n    // Gets the price of CELO quoted in stableToken.\n    uint256 celoStableTokenExchangeRate = getOracleExchangeRate(stableToken).unwrap();\n\n    // Using the current oracle exchange rate, calculate what the buy amount is.\n    // This takes the spread into consideration.\n    uint256 buyAmount = getBuyAmount(celoStableTokenExchangeRate, sellAmount, sellCelo);\n\n    // Create new scope to prevent a stack too deep error.\n    {\n      // Get the minimum and maximum amount of stable token than can be involved\n      // in the exchange. This reverts if exchange limits for the stable token have\n      // not been set.\n      (uint256 minExchangeAmount, uint256 maxExchangeAmount) = getStableTokenExchangeLimits(\n        stableTokenRegistryId\n      );\n      // Ensure that the amount of stableToken being bought or sold is within\n      // the configurable exchange limits.\n      uint256 stableTokenExchangeAmount = sellCelo ? buyAmount : sellAmount;\n      require(\n        stableTokenExchangeAmount <= maxExchangeAmount &&\n          stableTokenExchangeAmount >= minExchangeAmount,\n        \"Stable token exchange amount not within limits\"\n      );\n    }\n\n    // Deposit the assets being sold.\n    IERC20 sellToken = sellCelo ? getGoldToken() : IERC20(stableToken);\n    require(\n      sellToken.transferFrom(msg.sender, address(this), sellAmount),\n      \"Transfer in of sell token failed\"\n    );\n\n    // Record the proposal.\n    // Add 1 to the running proposal count, and use the updated proposal count as\n    // the proposal ID. Proposal IDs intentionally start at 1.\n    exchangeProposalCount = exchangeProposalCount.add(1);\n    // For stable tokens, the amount is stored in units to deal with demurrage.\n    uint256 storedSellAmount = sellCelo\n      ? sellAmount\n      : IStableToken(stableToken).valueToUnits(sellAmount);\n    exchangeProposals[exchangeProposalCount] = ExchangeProposal({\n      exchanger: msg.sender,\n      stableToken: stableToken,\n      state: ExchangeProposalState.Proposed,\n      sellCelo: sellCelo,\n      sellAmount: storedSellAmount,\n      buyAmount: buyAmount,\n      celoStableTokenExchangeRate: celoStableTokenExchangeRate,\n      approvalTimestamp: 0 // initial value when not approved yet\n    });\n    // Push it into the array of active proposals.\n    activeProposalIdsSuperset.push(exchangeProposalCount);\n    // Even if stable tokens are being sold, the sellAmount emitted is the \"value.\"\n    emit ExchangeProposalCreated(\n      exchangeProposalCount,\n      msg.sender,\n      stableTokenRegistryId,\n      sellAmount,\n      buyAmount,\n      sellCelo\n    );\n    return exchangeProposalCount;\n  }\n\n  /**\n   * @notice Approves an existing exchange proposal.\n   * @dev Sender must be the approver. Exchange proposal must be in the Proposed state.\n   * @param proposalId The identifier of the proposal to approve.\n   */\n  function approveExchangeProposal(uint256 proposalId) external nonReentrant onlyApprover {\n    ExchangeProposal storage proposal = exchangeProposals[proposalId];\n    // Ensure the proposal is in the Proposed state.\n    require(proposal.state == ExchangeProposalState.Proposed, \"Proposal must be in Proposed state\");\n    // Ensure the change in the current price of CELO quoted in the stable token\n    // relative to the value when the proposal was created is within the allowed limit.\n    FixidityLib.Fraction memory currentRate = getOracleExchangeRate(proposal.stableToken);\n    FixidityLib.Fraction memory proposalRate = FixidityLib.wrap(\n      proposal.celoStableTokenExchangeRate\n    );\n    (FixidityLib.Fraction memory lesserRate, FixidityLib.Fraction memory greaterRate) = currentRate\n      .lt(proposalRate)\n      ? (currentRate, proposalRate)\n      : (proposalRate, currentRate);\n    FixidityLib.Fraction memory rateChange = greaterRate.subtract(lesserRate).divide(proposalRate);\n    require(\n      rateChange.lte(maxApprovalExchangeRateChange),\n      \"CELO exchange rate is too different from the proposed price\"\n    );\n\n    // Set the time the approval occurred and change the state.\n    proposal.approvalTimestamp = block.timestamp;\n    proposal.state = ExchangeProposalState.Approved;\n    emit ExchangeProposalApproved(proposalId);\n  }\n\n  /**\n   * @notice Cancels an exchange proposal.\n   * @dev Only callable by the exchanger if the proposal is in the Proposed state\n   * or the owner if the proposal is in the Approved state.\n   * @param proposalId The identifier of the proposal to cancel.\n   */\n  function cancelExchangeProposal(uint256 proposalId) external nonReentrant {\n    ExchangeProposal storage proposal = exchangeProposals[proposalId];\n    // Require the appropriate state and sender.\n    // This will also revert if a proposalId is given that does not correspond\n    // to a previously created exchange proposal.\n    require(\n      (proposal.state == ExchangeProposalState.Proposed && proposal.exchanger == msg.sender) ||\n        (proposal.state == ExchangeProposalState.Approved && isOwner()),\n      \"Sender cannot cancel the exchange proposal\"\n    );\n    // Mark the proposal as cancelled. Do so prior to refunding as a measure against reentrancy.\n    proposal.state = ExchangeProposalState.Cancelled;\n    // Get the token and amount that will be refunded to the proposer.\n    (IERC20 refundToken, uint256 refundAmount) = getSellTokenAndSellAmount(proposal);\n    // Finally, transfer out the deposited funds.\n    require(\n      refundToken.transfer(proposal.exchanger, refundAmount),\n      \"Transfer out of refund token failed\"\n    );\n    emit ExchangeProposalCancelled(proposalId);\n  }\n\n  /**\n   * @notice Executes an exchange proposal that's been approved and not vetoed.\n   * @dev Callable by anyone. Reverts if the proposal is not in the Approved state\n   * or vetoPeriodSeconds has not elapsed since approval.\n   * @param proposalId The identifier of the proposal to execute.\n   */\n  function executeExchangeProposal(uint256 proposalId) external nonReentrant {\n    ExchangeProposal storage proposal = exchangeProposals[proposalId];\n    // Require that the proposal is in the Approved state.\n    require(proposal.state == ExchangeProposalState.Approved, \"Proposal must be in Approved state\");\n    // Require that the veto period has elapsed since the approval time.\n    require(\n      proposal.approvalTimestamp.add(vetoPeriodSeconds) <= block.timestamp,\n      \"Veto period not elapsed\"\n    );\n    // Mark the proposal as executed. Do so prior to exchanging as a measure against reentrancy.\n    proposal.state = ExchangeProposalState.Executed;\n    // Perform the exchange.\n    (IERC20 sellToken, uint256 sellAmount) = getSellTokenAndSellAmount(proposal);\n    // If the exchange sells CELO, the CELO is sent to the Reserve from this contract\n    // and stable token is minted to the exchanger.\n    if (proposal.sellCelo) {\n      // Send the CELO from this contract to the reserve.\n      require(\n        sellToken.transfer(address(getReserve()), sellAmount),\n        \"Transfer out of CELO to Reserve failed\"\n      );\n      // Mint stable token to the exchanger.\n      require(\n        IStableToken(proposal.stableToken).mint(proposal.exchanger, proposal.buyAmount),\n        \"Stable token mint failed\"\n      );\n    } else {\n      // If the exchange is selling stable token, the stable token is burned from\n      // this contract and CELO is transferred from the Reserve to the exchanger.\n\n      // Burn the stable token from this contract.\n      require(IStableToken(proposal.stableToken).burn(sellAmount), \"Stable token burn failed\");\n      // Transfer the CELO from the Reserve to the exchanger.\n      require(\n        getReserve().transferExchangeGold(proposal.exchanger, proposal.buyAmount),\n        \"Transfer out of CELO from Reserve failed\"\n      );\n    }\n    emit ExchangeProposalExecuted(proposalId);\n  }\n\n  /**\n   * @notice Gets the sell token and the sell amount for a proposal.\n   * @dev For stable token sell amounts that are stored as units, the value\n   * is returned. Ensures sell amount is not greater than this contract's balance.\n   * @param proposal The proposal to get the sell token and sell amount for.\n   * @return (the IERC20 sell token, the value sell amount).\n   */\n  function getSellTokenAndSellAmount(ExchangeProposal memory proposal)\n    private\n    view\n    returns (IERC20, uint256)\n  {\n    IERC20 sellToken;\n    uint256 sellAmount;\n    if (proposal.sellCelo) {\n      sellToken = getGoldToken();\n      sellAmount = proposal.sellAmount;\n    } else {\n      address stableToken = proposal.stableToken;\n      sellToken = IERC20(stableToken);\n      // When selling stableToken, the sell amount is stored in units.\n      // Units must be converted to value when refunding.\n      sellAmount = IStableToken(stableToken).unitsToValue(proposal.sellAmount);\n    }\n    // In the event a precision issue from the unit <-> value calculations results\n    // in sellAmount being greater than this contract's balance, set the sellAmount\n    // to the entire balance.\n    // This check should not be necessary for CELO, but is done so regardless\n    // for extra certainty that cancelling an exchange proposal can never fail\n    // if for some reason the CELO balance of this contract is less than the\n    // recorded sell amount.\n    uint256 totalBalance = sellToken.balanceOf(address(this));\n    if (totalBalance < sellAmount) {\n      sellAmount = totalBalance;\n    }\n    return (sellToken, sellAmount);\n  }\n\n  /**\n   * @notice Using the oracle price, charges the spread and calculates the amount of\n   * the asset being bought.\n   * @dev Stable token value amounts are used for the sellAmount, not unit amounts.\n   * Assumes both CELO and the stable token have 18 decimals.\n   * @param celoStableTokenExchangeRate The unwrapped fraction exchange rate of CELO\n   * quoted in the stable token.\n   * @param sellAmount The amount of the sell token being sold.\n   * @param sellCelo Whether CELO is being sold.\n   * @return The amount of the asset being bought.\n   */\n  function getBuyAmount(uint256 celoStableTokenExchangeRate, uint256 sellAmount, bool sellCelo)\n    public\n    view\n    returns (uint256)\n  {\n    FixidityLib.Fraction memory exchangeRate = FixidityLib.wrap(celoStableTokenExchangeRate);\n    // If stableToken is being sold, instead use the price of stableToken\n    // quoted in CELO.\n    if (!sellCelo) {\n      exchangeRate = exchangeRate.reciprocal();\n    }\n    // The sell amount taking the spread into account, ie:\n    // (1 - spread) * sellAmount\n    FixidityLib.Fraction memory adjustedSellAmount = FixidityLib.fixed1().subtract(spread).multiply(\n      FixidityLib.newFixed(sellAmount)\n    );\n    // Calculate the buy amount:\n    // exchangeRate * adjustedSellAmount\n    return exchangeRate.multiply(adjustedSellAmount).fromFixed();\n  }\n\n  /**\n   * @notice Removes the proposal ID found at the provided index of activeProposalIdsSuperset\n   * if the exchange proposal is not active.\n   * @dev Anyone can call. Reverts if the exchange proposal is active.\n   * @param index The index of the proposal ID to remove from activeProposalIdsSuperset.\n   */\n  function removeFromActiveProposalIdsSuperset(uint256 index) external {\n    require(index < activeProposalIdsSuperset.length, \"Index out of bounds\");\n    uint256 proposalId = activeProposalIdsSuperset[index];\n    // Require the exchange proposal to be inactive.\n    require(\n      exchangeProposals[proposalId].state != ExchangeProposalState.Proposed &&\n        exchangeProposals[proposalId].state != ExchangeProposalState.Approved,\n      \"Exchange proposal not inactive\"\n    );\n    // If not removing the last element, overwrite the index with the value of\n    // the last element.\n    uint256 lastIndex = activeProposalIdsSuperset.length.sub(1);\n    if (index < lastIndex) {\n      activeProposalIdsSuperset[index] = activeProposalIdsSuperset[lastIndex];\n    }\n    // Delete the last element.\n    activeProposalIdsSuperset.length--;\n  }\n\n  /**\n   * @notice Gets the proposal identifiers of exchange proposals in the\n   * Proposed or Approved state. Returns a version of activeProposalIdsSuperset\n   * with inactive proposal IDs set as 0.\n   * @dev Elements with a proposal ID of 0 should be filtered out by the consumer.\n   * @return An array of active exchange proposals IDs.\n   */\n  function getActiveProposalIds() external view returns (uint256[] memory) {\n    // Solidity doesn't play well with dynamically sized memory arrays.\n    // Instead, this array is created with the same length as activeProposalIdsSuperset,\n    // and will replace elements that are inactive proposal IDs with the value 0.\n    uint256[] memory activeProposalIds = new uint256[](activeProposalIdsSuperset.length);\n\n    for (uint256 i = 0; i < activeProposalIdsSuperset.length; i = i.add(1)) {\n      uint256 proposalId = activeProposalIdsSuperset[i];\n      if (\n        exchangeProposals[proposalId].state == ExchangeProposalState.Proposed ||\n        exchangeProposals[proposalId].state == ExchangeProposalState.Approved\n      ) {\n        activeProposalIds[i] = proposalId;\n      }\n    }\n    return activeProposalIds;\n  }\n\n  /**\n   * @notice Gets the oracle CELO price quoted in the stable token.\n   * @dev Reverts if there is not a rate for the provided stable token.\n   * @param stableToken The stable token to get the oracle price for.\n   * @return The oracle CELO price quoted in the stable token.\n   */\n  function getOracleExchangeRate(address stableToken)\n    private\n    view\n    returns (FixidityLib.Fraction memory)\n  {\n    uint256 rateNumerator;\n    uint256 rateDenominator;\n    (rateNumerator, rateDenominator) = getSortedOracles().medianRate(stableToken);\n    // When rateDenominator is 0, it means there are no rates known to SortedOracles.\n    require(rateDenominator > 0, \"No oracle rates present for token\");\n    return FixidityLib.wrap(rateNumerator).divide(FixidityLib.wrap(rateDenominator));\n  }\n\n  /**\n   * @notice Gets the minimum and maximum amount of a stable token that can be\n   * involved in a single exchange.\n   * @dev Reverts if there is no explicit exchange limit for the stable token.\n   * @param stableTokenRegistryId The string registry ID for the stable token.\n   * @return (minimum exchange amount, maximum exchange amount).\n   */\n  function getStableTokenExchangeLimits(string memory stableTokenRegistryId)\n    public\n    view\n    returns (uint256, uint256)\n  {\n    ExchangeLimits memory exchangeLimits = stableTokenExchangeLimits[stableTokenRegistryId];\n    // Require the configurable stableToken max exchange amount to be > 0.\n    // This covers the case where a stableToken has never been explicitly permitted.\n    require(\n      exchangeLimits.maxExchangeAmount > 0,\n      \"Max stable token exchange amount must be defined\"\n    );\n    return (exchangeLimits.minExchangeAmount, exchangeLimits.maxExchangeAmount);\n  }\n\n  /**\n   * @notice Sets the approver.\n   * @dev Sender must be owner. New approver is allowed to be address(0).\n   * @param newApprover The new value for the approver.\n   */\n  function setApprover(address newApprover) public onlyOwner {\n    approver = newApprover;\n    emit ApproverSet(newApprover);\n  }\n\n  /**\n   * @notice Sets the maximum allowed change in the CELO/stable token price when\n   * an exchange proposal is being approved relative to the price when the proposal\n   * was created.\n   * @dev Sender must be owner.\n   * @param newMaxApprovalExchangeRateChange The new value for maxApprovalExchangeRateChange\n   * to be wrapped.\n   */\n  function setMaxApprovalExchangeRateChange(uint256 newMaxApprovalExchangeRateChange)\n    public\n    onlyOwner\n  {\n    maxApprovalExchangeRateChange = FixidityLib.wrap(newMaxApprovalExchangeRateChange);\n    emit MaxApprovalExchangeRateChangeSet(newMaxApprovalExchangeRateChange);\n  }\n\n  /**\n   * @notice Sets the spread.\n   * @dev Sender must be owner.\n   * @param newSpread The new value for the spread to be wrapped. Must be <= fixed 1.\n   */\n  function setSpread(uint256 newSpread) public onlyOwner {\n    require(newSpread <= FixidityLib.fixed1().unwrap(), \"Spread must be smaller than 1\");\n    spread = FixidityLib.wrap(newSpread);\n    emit SpreadSet(newSpread);\n  }\n\n  /**\n   * @notice Sets the minimum and maximum amount of the stable token an exchange can involve.\n   * @dev Sender must be owner. Setting the maxExchangeAmount to 0 effectively disables new\n   * exchange proposals for the token.\n   * @param stableTokenRegistryId The registry ID string for the stable token to set limits for.\n   * @param minExchangeAmount The new minimum exchange amount for the stable token.\n   * @param maxExchangeAmount The new maximum exchange amount for the stable token.\n   */\n  function setStableTokenExchangeLimits(\n    string calldata stableTokenRegistryId,\n    uint256 minExchangeAmount,\n    uint256 maxExchangeAmount\n  ) external onlyOwner {\n    require(\n      minExchangeAmount <= maxExchangeAmount,\n      \"Min exchange amount must not be greater than max\"\n    );\n    stableTokenExchangeLimits[stableTokenRegistryId] = ExchangeLimits({\n      minExchangeAmount: minExchangeAmount,\n      maxExchangeAmount: maxExchangeAmount\n    });\n    emit StableTokenExchangeLimitsSet(stableTokenRegistryId, minExchangeAmount, maxExchangeAmount);\n  }\n\n  /**\n   * @notice Sets the veto period in seconds.\n   * @dev Sender must be owner.\n   * @param newVetoPeriodSeconds The new value for the veto period in seconds.\n   */\n  function setVetoPeriodSeconds(uint256 newVetoPeriodSeconds) public onlyOwner {\n    vetoPeriodSeconds = newVetoPeriodSeconds;\n    emit VetoPeriodSecondsSet(newVetoPeriodSeconds);\n  }\n}"
    }
  ]
}