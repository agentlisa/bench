{
  "Title": "Unrecorded Calls Resulting from try/catch or Low-Level Reverts",
  "Content": "When a protocol employs `try/catch` or low-level calls anticipated to revert and subsequently relies on these revert messages as part of its operational logic, these calls may not be recorded. This is due to the fact that they revert their changes in the Engine.\n\n\nAn illustrative example can be seen in the counterfactual, always-reverting rollback logic in the [Synthetix V3 upgrade module](https://github.com/Synthetixio/synthetix-v3/blob/main/utils/core-contracts/contracts/proxy/UUPSImplementation.sol#L27-L33). Here, calls always revert but with varying revert errors.\n\n\nWe recommend documenting this edge case to ensure it is considered during integration audits.\n\n\n***Update**: Acknowledged. The SphereX team stated:*\n\n\n\n> *We will document this edge case.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "utils/core-contracts/contracts/proxy/UUPSImplementation.sol",
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.11 <0.9.0;\n\nimport \"../interfaces/IUUPSImplementation.sol\";\nimport \"../errors/AddressError.sol\";\nimport \"../errors/ChangeError.sol\";\nimport \"../utils/AddressUtil.sol\";\nimport \"./ProxyStorage.sol\";\n\nabstract contract UUPSImplementation is IUUPSImplementation, ProxyStorage {\n    /**\n     * @inheritdoc IUUPSImplementation\n     */\n    function simulateUpgradeTo(address newImplementation) public override {\n        ProxyStore storage store = _proxyStore();\n\n        store.simulatingUpgrade = true;\n\n        address currentImplementation = store.implementation;\n        store.implementation = newImplementation;\n\n        (bool rollbackSuccessful, ) = newImplementation.delegatecall(\n            abi.encodeCall(this.upgradeTo, (currentImplementation))\n        );\n\n        if (!rollbackSuccessful || _proxyStore().implementation != currentImplementation) {\n            revert UpgradeSimulationFailed();\n        }\n\n        store.simulatingUpgrade = false;\n\n        // solhint-disable-next-line reason-string\n        revert();\n    }\n\n    /**\n     * @inheritdoc IUUPSImplementation\n     */\n    function getImplementation() external view override returns (address) {\n        return _proxyStore().implementation;\n    }\n\n    function _upgradeTo(address newImplementation) internal virtual {\n        if (newImplementation == address(0)) {\n            revert AddressError.ZeroAddress();\n        }\n\n        if (!AddressUtil.isContract(newImplementation)) {\n            revert AddressError.NotAContract(newImplementation);\n        }\n\n        ProxyStore storage store = _proxyStore();\n\n        if (newImplementation == store.implementation) {\n            revert ChangeError.NoChange();\n        }\n\n        if (!store.simulatingUpgrade && _implementationIsSterile(newImplementation)) {\n            revert ImplementationIsSterile(newImplementation);\n        }\n\n        store.implementation = newImplementation;\n\n        emit Upgraded(address(this), newImplementation);\n    }\n\n    function _implementationIsSterile(\n        address candidateImplementation\n    ) internal virtual returns (bool) {\n        (bool simulationReverted, bytes memory simulationResponse) = address(this).delegatecall(\n            abi.encodeCall(this.simulateUpgradeTo, (candidateImplementation))\n        );\n\n        return\n            !simulationReverted &&\n            keccak256(abi.encodePacked(simulationResponse)) ==\n            keccak256(abi.encodePacked(UpgradeSimulationFailed.selector));\n    }\n}"
    }
  ]
}