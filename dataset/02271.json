{
  "Title": "M-1: Vault cannot be deployed properly for newer Curve pools",
  "Content": "# Issue M-1: Vault cannot be deployed properly for newer Curve pools \n\nSource: https://github.com/sherlock-audit/2023-02-notional-judging/issues/22 \n\n## Found by \nusmannk\n\n## Summary\n\nNew Curve pools have a different ABI than the one that the vaults attempt to use. Not differentiating between the two will lead to silent failures when vaults are deployed for new pools.\n\n## Vulnerability Detail\n\nDuring the deploy process the leveraged vault attempts to obtain the Curve pool's LP token address by calling `CURVE_POOL.lp_token()`. However, for new pools such as CRV/ETH (https://etherscan.io/address/0x8301ae4fc9c624d1d396cbdaa1ed877821d7c511#code), there is no `lp_token` member. Instead calling `lp_token()` will trigger the fallback function. For these pools, the token is obtained by calling `token()`.\n\nhttps://github.com/sherlock-audit/2023-02-notional/blob/main/leveraged-vaults/contracts/vaults/curve/mixins/CurvePoolMixin.sol#L25\n\n## Impact\n\nThe lp token's address will be set to the 0 address and later calls to functions such as `totalSupply` will fail, causing the vault to be in a stuck state.\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nCheck the version of the target Curve pool and toggle called functions appropiately.\n\n## Discussion\n\n**jeffywu**\n\nValid\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/52",
  "Code": [
    {
      "filename": "leveraged-vaults/contracts/vaults/curve/mixins/CurvePoolMixin.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {StrategyContext} from \"../../common/VaultTypes.sol\";\nimport {ConvexVaultDeploymentParams} from \"../CurveVaultTypes.sol\";\nimport {Deployments} from \"../../../global/Deployments.sol\";\nimport {NotionalProxy} from \"../../../../interfaces/notional/NotionalProxy.sol\";\nimport {IERC20} from \"../../../../interfaces/IERC20.sol\";\nimport {ICurvePool} from \"../../../../interfaces/curve/ICurvePool.sol\";\nimport {ConvexStakingMixin} from \"./ConvexStakingMixin.sol\";\nimport {CurveVaultStorage} from \"../internal/CurveVaultStorage.sol\";\nimport {StrategyUtils} from \"../../common/internal/strategy/StrategyUtils.sol\";\nimport {CurveConstants} from \"../internal/CurveConstants.sol\";\n\nabstract contract CurvePoolMixin is ConvexStakingMixin {\n    using StrategyUtils for StrategyContext;\n\n    ICurvePool internal immutable CURVE_POOL;\n    IERC20 internal immutable CURVE_POOL_TOKEN;\n\n    constructor(NotionalProxy notional_, ConvexVaultDeploymentParams memory params) \n        ConvexStakingMixin(notional_, params) {\n\n        CURVE_POOL = ICurvePool(params.baseParams.pool);\n        CURVE_POOL_TOKEN = IERC20(CURVE_POOL.lp_token());\n    }\n\n    function _baseStrategyContext() internal view returns(StrategyContext memory) {\n        return StrategyContext({\n            settlementPeriodInSeconds: SETTLEMENT_PERIOD_IN_SECONDS,\n            tradingModule: TRADING_MODULE,\n            vaultSettings: CurveVaultStorage.getStrategyVaultSettings(),\n            vaultState: CurveVaultStorage.getStrategyVaultState(),\n            poolClaimPrecision: CurveConstants.CURVE_PRECISION\n        });\n    }\n\n    /// @notice Converts LP tokens to strategy tokens\n    function convertPoolClaimToStrategyTokens(uint256 poolClaim)\n        external view returns (uint256 strategyTokenAmount) {\n        return _baseStrategyContext()._convertPoolClaimToStrategyTokens(poolClaim);\n    }\n\n    /// @notice Converts strategy tokens to LP tokens\n    function convertStrategyTokensToPoolClaim(uint256 strategyTokenAmount) \n        external view returns (uint256 poolClaim) {\n        return _baseStrategyContext()._convertStrategyTokensToPoolClaim(strategyTokenAmount);\n    }\n\n    uint256[40] private __gap; // Storage gap for future potential upgrades\n}"
    }
  ]
}