{
  "Title": "[G-03] Usage of `Errors` can reduce gas cost and contract size at PaladinRewardReserve.sol",
  "Content": "\n### Target codebase\n\n[PaladinRewardReserve.sol#L29](https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/PaladinRewardReserve.sol#L29)<br>\n\n[PaladinRewardReserve.sol#L37](https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/PaladinRewardReserve.sol#L37)<br>\n\n[PaladinRewardReserve.sol#L45](https://github.com/code-423n4/2022-03-paladin/blob/9c26ec8556298fb1dc3cf71f471aadad3a5c74a0/contracts/PaladinRewardReserve.sol#L45)<br>\n\nIt uses `require` but using [`Errors`](https://docs.soliditylang.org/en/v0.8.13/contracts.html?highlight=error#errors-and-the-revert-statement) in solidity can reduce the deployment gas cost.\n\n### Potential improvements\n\n    // Define error \n    error AlreadySpender();\n    error NotApprovedSpender();\n\n    // Update the logic accordingly\n    if (approvedSpenders[spender]) {\n        revert AlreadySpender();\n    }\n\n    if (!approvedSpenders[spender]) {\n        revert NotApprovedSpender();\n    }\n\n### Deployment Gas change\n\n| Contract             | Before | After  | Change |\n| -------------------- | ------ | ------ | ------ |\n| PaladinRewardReserve | 752599 | 729041 | -23558 |\n\n***\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2022-03-paladin",
  "Code": [
    {
      "filename": "contracts/PaladinRewardReserve.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./open-zeppelin/utils/Ownable.sol\";\nimport \"./open-zeppelin/utils/ReentrancyGuard.sol\";\nimport \"./open-zeppelin/interfaces/IERC20.sol\";\nimport \"./open-zeppelin/libraries/SafeERC20.sol\";\n\n/** @title Paladin Reward Reserve contract  */\n/// @author Paladin\ncontract PaladinRewardReserve is Ownable, ReentrancyGuard{\n    using SafeERC20 for IERC20;\n\n    /** @notice Addresses allowed to transfer tokens from this contract */\n    mapping(address => bool) public approvedSpenders;\n\n    /** @notice Emitted when a new spender is approved*/\n    event NewSpender(address indexed token, address indexed spender, uint256 amount);\n    /** @notice Emitted when the allowance of a spander is updated */\n    event UpdateSpender(address indexed token, address indexed spender, uint256 amount);\n    /** @notice Emitted when a spender allowance is removed */\n    event RemovedSpender(address indexed token, address indexed spender);\n\n    constructor(address _admin) {\n        transferOwnership(_admin);\n    }\n\n    function setNewSpender(address token, address spender, uint256 amount) external onlyOwner {\n        require(!approvedSpenders[spender], \"Already Spender\");\n        approvedSpenders[spender] = true;\n        IERC20(token).safeApprove(spender, amount);\n\n        emit NewSpender(token, spender, amount);\n    }\n\n    function updateSpenderAllowance(address token, address spender, uint256 amount) external onlyOwner {\n        require(approvedSpenders[spender], \"Not approved Spender\");\n        IERC20(token).safeApprove(spender, 0);\n        IERC20(token).safeApprove(spender, amount);\n\n        emit UpdateSpender(token, spender, amount);\n    }\n\n    function removeSpender(address token, address spender) external onlyOwner {\n        require(approvedSpenders[spender], \"Not approved Spender\");\n        approvedSpenders[spender] = false;\n        IERC20(token).safeApprove(spender, 0);\n\n        emit RemovedSpender(token, spender);\n    }\n\n    function transferToken(address token, address receiver, uint256 amount) external onlyOwner nonReentrant {\n        IERC20(token).safeTransfer(receiver, amount);\n    }\n\n}"
    },
    {
      "filename": "contracts/PaladinRewardReserve.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./open-zeppelin/utils/Ownable.sol\";\nimport \"./open-zeppelin/utils/ReentrancyGuard.sol\";\nimport \"./open-zeppelin/interfaces/IERC20.sol\";\nimport \"./open-zeppelin/libraries/SafeERC20.sol\";\n\n/** @title Paladin Reward Reserve contract  */\n/// @author Paladin\ncontract PaladinRewardReserve is Ownable, ReentrancyGuard{\n    using SafeERC20 for IERC20;\n\n    /** @notice Addresses allowed to transfer tokens from this contract */\n    mapping(address => bool) public approvedSpenders;\n\n    /** @notice Emitted when a new spender is approved*/\n    event NewSpender(address indexed token, address indexed spender, uint256 amount);\n    /** @notice Emitted when the allowance of a spander is updated */\n    event UpdateSpender(address indexed token, address indexed spender, uint256 amount);\n    /** @notice Emitted when a spender allowance is removed */\n    event RemovedSpender(address indexed token, address indexed spender);\n\n    constructor(address _admin) {\n        transferOwnership(_admin);\n    }\n\n    function setNewSpender(address token, address spender, uint256 amount) external onlyOwner {\n        require(!approvedSpenders[spender], \"Already Spender\");\n        approvedSpenders[spender] = true;\n        IERC20(token).safeApprove(spender, amount);\n\n        emit NewSpender(token, spender, amount);\n    }\n\n    function updateSpenderAllowance(address token, address spender, uint256 amount) external onlyOwner {\n        require(approvedSpenders[spender], \"Not approved Spender\");\n        IERC20(token).safeApprove(spender, 0);\n        IERC20(token).safeApprove(spender, amount);\n\n        emit UpdateSpender(token, spender, amount);\n    }\n\n    function removeSpender(address token, address spender) external onlyOwner {\n        require(approvedSpenders[spender], \"Not approved Spender\");\n        approvedSpenders[spender] = false;\n        IERC20(token).safeApprove(spender, 0);\n\n        emit RemovedSpender(token, spender);\n    }\n\n    function transferToken(address token, address receiver, uint256 amount) external onlyOwner nonReentrant {\n        IERC20(token).safeTransfer(receiver, amount);\n    }\n\n}"
    },
    {
      "filename": "contracts/PaladinRewardReserve.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./open-zeppelin/utils/Ownable.sol\";\nimport \"./open-zeppelin/utils/ReentrancyGuard.sol\";\nimport \"./open-zeppelin/interfaces/IERC20.sol\";\nimport \"./open-zeppelin/libraries/SafeERC20.sol\";\n\n/** @title Paladin Reward Reserve contract  */\n/// @author Paladin\ncontract PaladinRewardReserve is Ownable, ReentrancyGuard{\n    using SafeERC20 for IERC20;\n\n    /** @notice Addresses allowed to transfer tokens from this contract */\n    mapping(address => bool) public approvedSpenders;\n\n    /** @notice Emitted when a new spender is approved*/\n    event NewSpender(address indexed token, address indexed spender, uint256 amount);\n    /** @notice Emitted when the allowance of a spander is updated */\n    event UpdateSpender(address indexed token, address indexed spender, uint256 amount);\n    /** @notice Emitted when a spender allowance is removed */\n    event RemovedSpender(address indexed token, address indexed spender);\n\n    constructor(address _admin) {\n        transferOwnership(_admin);\n    }\n\n    function setNewSpender(address token, address spender, uint256 amount) external onlyOwner {\n        require(!approvedSpenders[spender], \"Already Spender\");\n        approvedSpenders[spender] = true;\n        IERC20(token).safeApprove(spender, amount);\n\n        emit NewSpender(token, spender, amount);\n    }\n\n    function updateSpenderAllowance(address token, address spender, uint256 amount) external onlyOwner {\n        require(approvedSpenders[spender], \"Not approved Spender\");\n        IERC20(token).safeApprove(spender, 0);\n        IERC20(token).safeApprove(spender, amount);\n\n        emit UpdateSpender(token, spender, amount);\n    }\n\n    function removeSpender(address token, address spender) external onlyOwner {\n        require(approvedSpenders[spender], \"Not approved Spender\");\n        approvedSpenders[spender] = false;\n        IERC20(token).safeApprove(spender, 0);\n\n        emit RemovedSpender(token, spender);\n    }\n\n    function transferToken(address token, address receiver, uint256 amount) external onlyOwner nonReentrant {\n        IERC20(token).safeTransfer(receiver, amount);\n    }\n\n}"
    }
  ]
}