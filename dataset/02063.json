{
  "Title": "M-4: minOfferCost can be bypassed in certain scenarios",
  "Content": "# Issue M-4: minOfferCost can be bypassed in certain scenarios \n\nSource: https://github.com/sherlock-audit/2023-02-kairos-judging/issues/23 \n\n## Found by \n0x52\n\n## Summary\n\nminOfferCost is designed to prevent spam loan requests that can cause the lender to have positions that cost more gas to claim than interest. Due to how interest is calculated right after this minimum is passed it is still possible for the lender to receive less than the minimum.\n\n## Vulnerability Detail\n\n[ClaimFacet.sol#L94-L106](https://github.com/sherlock-audit/2023-02-kairos/blob/main/kairos-contracts/src/ClaimFacet.sol#L94-L106)\n\n    function sendInterests(Loan storage loan, Provision storage provision) internal returns (uint256 sent) {\n        uint256 interests = loan.payment.paid - loan.lent;\n        if (interests == loan.payment.minInterestsToRepay) {\n            // this is the case if the loan is repaid shortly after issuance\n            // each lender gets its minimal interest, as an anti ddos measure to spam offer\n            sent = provision.amount + (interests / loan.nbOfPositions);\n        } else {\n            /* provision.amount / lent = share of the interests belonging to the lender. The parenthesis make the\n            calculus in the order that maximizes precison */\n            sent = provision.amount + (interests * (provision.amount)) / loan.lent; <- audit-issue minimal interest isn't guaranteed\n        }\n        loan.assetLent.checkedTransfer(msg.sender, sent);\n    }\n\nWhen a loan has generated more than the minimum interest amount the method for calculating the interest paid is different and depending on the size of the provisions it may lead to provisions that are under the guaranteed minimum.\n\nExample:\nAssume the minimum interest is 1e18. A loan is filled with 2 provisions. The first provision is 25% and the second is 75%. Since there are two loans the total minimum interest for the loan is 2e18. After some time the paid interest reaches 2.001e18 and the loan is paid back. Since it is above the minimum interest rate, it is paid out proportionally. This gives 0.5e18 to the first provision and 1.5e18 to the second provision. This violates the minimum guaranteed interest amount.\n\n## Impact\n\nMinimum interest guarantee can be violated\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-kairos/blob/main/kairos-contracts/src/ClaimFacet.sol#L94-L106\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nMinimum interest should be set based on the percentage of the lowest provision and provision shouldn't be allowed to be lower than some amount. Since this problem occurs when the percentage is less than 1/n (where n is the number of provisions), any single provision should be allowed to be lower than 1/(2n). \n\n\n\n## Discussion\n\n**npasquie**\n\nfixed by https://github.com/kairos-loan/kairos-contracts/pull/51\nthe fix restricts the nb of offer/provision per loan to 1 eliminating the vulnerability\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/56",
  "Code": [
    {
      "filename": "kairos-contracts/src/ClaimFacet.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.18;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {IClaimFacet} from \"./interface/IClaimFacet.sol\";\nimport {BorrowerAlreadyClaimed, LoanNotRepaidOrLiquidatedYet, NotBorrowerOfTheLoan} from \"./DataStructure/Errors.sol\";\nimport {ERC721CallerIsNotOwnerNorApproved} from \"./DataStructure/ERC721Errors.sol\";\nimport {Loan, Protocol, Provision, SupplyPosition} from \"./DataStructure/Storage.sol\";\nimport {ONE, protocolStorage, supplyPositionStorage} from \"./DataStructure/Global.sol\";\nimport {Ray} from \"./DataStructure/Objects.sol\";\nimport {RayMath} from \"./utils/RayMath.sol\";\nimport {Erc20CheckedTransfer} from \"./utils/Erc20CheckedTransfer.sol\";\nimport {SafeMint} from \"./SupplyPositionLogic/SafeMint.sol\";\n\n/// @notice claims supplier and borrower rights on loans or supply positions\ncontract ClaimFacet is IClaimFacet, SafeMint {\n    using RayMath for Ray;\n    using RayMath for uint256;\n    using Erc20CheckedTransfer for IERC20;\n\n    /// @notice claims principal plus interests or liquidation share due as a supplier\n    /// @param positionIds identifiers of one or multiple supply position to burn\n    /// @return sent amount sent\n    function claim(uint256[] calldata positionIds) external returns (uint256 sent) {\n        Protocol storage proto = protocolStorage();\n        SupplyPosition storage sp = supplyPositionStorage();\n        Loan storage loan;\n        Provision storage provision;\n        uint256 loanId;\n        uint256 sentTemp;\n\n        for (uint256 i = 0; i < positionIds.length; i++) {\n            if (!_isApprovedOrOwner(msg.sender, positionIds[i])) {\n                revert ERC721CallerIsNotOwnerNorApproved();\n            }\n            _burn(positionIds[i]);\n            provision = sp.provision[positionIds[i]];\n            loanId = provision.loanId;\n            loan = proto.loan[loanId];\n\n            if (loan.payment.liquidated) {\n                sentTemp = sendShareOfSaleAsSupplier(loan, provision);\n            } else {\n                if (loan.payment.paid == 0) {\n                    revert LoanNotRepaidOrLiquidatedYet(loanId);\n                }\n                sentTemp = sendInterests(loan, provision);\n            }\n            emit Claim(msg.sender, sentTemp, loanId);\n            sent += sentTemp;\n        }\n    }\n\n    /// @notice claims share of liquidation due to a borrower who's collateral has been sold\n    /// @param loanIds loan identifiers of one or multiple loans where the borrower wants to claim liquidation share\n    /// @return sent amount sent\n    function claimAsBorrower(uint256[] calldata loanIds) external returns (uint256 sent) {\n        Protocol storage proto = protocolStorage();\n        Loan storage loan;\n        uint256 sentTemp;\n        uint256 loanId;\n\n        for (uint256 i = 0; i < loanIds.length; i++) {\n            loanId = loanIds[i];\n            loan = proto.loan[loanId];\n            if (loan.borrower != msg.sender) {\n                revert NotBorrowerOfTheLoan(loanId);\n            }\n            if (loan.payment.borrowerClaimed) {\n                revert BorrowerAlreadyClaimed(loanId);\n            }\n            if (loan.payment.liquidated) {\n                loan.payment.borrowerClaimed = true;\n                // 1 - shareLent = share belonging to the borrower (not used as collateral)\n                sentTemp = loan.payment.paid.mul(ONE.sub(loan.shareLent));\n            } else {\n                revert LoanNotRepaidOrLiquidatedYet(loanId);\n            }\n            if (sentTemp > 0) {\n                /* the function may be called to store that the borrower claimed its due, but if this due is of 0 there\n                is no point in emitting a transfer and claim event */\n                loan.assetLent.checkedTransfer(msg.sender, sentTemp);\n                sent += sentTemp;\n                emit Claim(msg.sender, sentTemp, loanId);\n            }\n        }\n    }\n\n    /// @notice sends principal plus interests of the loan to `msg.sender`\n    /// @param loan - to calculate amount from\n    /// @param provision liquidity provision for this loan\n    /// @return sent amount sent\n    function sendInterests(Loan storage loan, Provision storage provision) internal returns (uint256 sent) {\n        uint256 interests = loan.payment.paid - loan.lent;\n        if (interests == loan.payment.minInterestsToRepay) {\n            // this is the case if the loan is repaid shortly after issuance\n            // each lender gets its minimal interest, as an anti ddos measure to spam offer\n            sent = provision.amount + (interests / loan.nbOfPositions);\n        } else {\n            /* provision.amount / lent = share of the interests belonging to the lender. The parenthesis make the\n            calculus in the order that maximizes precison */\n            sent = provision.amount + (interests * (provision.amount)) / loan.lent;\n        }\n        loan.assetLent.checkedTransfer(msg.sender, sent);\n    }\n\n    /// @notice sends liquidation share due to `msg.sender` as a supplier\n    /// @param loan - from which the collateral were liquidated\n    /// @param provision liquidity provisioned by this loan by the supplier\n    /// @return sent amount sent\n    function sendShareOfSaleAsSupplier(\n        Loan storage loan,\n        Provision storage provision\n    ) internal returns (uint256 sent) {\n        // in the case of a liqudidation, provision.share is considered the share of the NFT acquired by the lender\n        sent = loan.payment.paid.mul(provision.share);\n        loan.assetLent.checkedTransfer(msg.sender, sent);\n    }\n}"
    },
    {
      "filename": "kairos-contracts/src/ClaimFacet.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.18;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {IClaimFacet} from \"./interface/IClaimFacet.sol\";\nimport {BorrowerAlreadyClaimed, LoanNotRepaidOrLiquidatedYet, NotBorrowerOfTheLoan} from \"./DataStructure/Errors.sol\";\nimport {ERC721CallerIsNotOwnerNorApproved} from \"./DataStructure/ERC721Errors.sol\";\nimport {Loan, Protocol, Provision, SupplyPosition} from \"./DataStructure/Storage.sol\";\nimport {ONE, protocolStorage, supplyPositionStorage} from \"./DataStructure/Global.sol\";\nimport {Ray} from \"./DataStructure/Objects.sol\";\nimport {RayMath} from \"./utils/RayMath.sol\";\nimport {Erc20CheckedTransfer} from \"./utils/Erc20CheckedTransfer.sol\";\nimport {SafeMint} from \"./SupplyPositionLogic/SafeMint.sol\";\n\n/// @notice claims supplier and borrower rights on loans or supply positions\ncontract ClaimFacet is IClaimFacet, SafeMint {\n    using RayMath for Ray;\n    using RayMath for uint256;\n    using Erc20CheckedTransfer for IERC20;\n\n    /// @notice claims principal plus interests or liquidation share due as a supplier\n    /// @param positionIds identifiers of one or multiple supply position to burn\n    /// @return sent amount sent\n    function claim(uint256[] calldata positionIds) external returns (uint256 sent) {\n        Protocol storage proto = protocolStorage();\n        SupplyPosition storage sp = supplyPositionStorage();\n        Loan storage loan;\n        Provision storage provision;\n        uint256 loanId;\n        uint256 sentTemp;\n\n        for (uint256 i = 0; i < positionIds.length; i++) {\n            if (!_isApprovedOrOwner(msg.sender, positionIds[i])) {\n                revert ERC721CallerIsNotOwnerNorApproved();\n            }\n            _burn(positionIds[i]);\n            provision = sp.provision[positionIds[i]];\n            loanId = provision.loanId;\n            loan = proto.loan[loanId];\n\n            if (loan.payment.liquidated) {\n                sentTemp = sendShareOfSaleAsSupplier(loan, provision);\n            } else {\n                if (loan.payment.paid == 0) {\n                    revert LoanNotRepaidOrLiquidatedYet(loanId);\n                }\n                sentTemp = sendInterests(loan, provision);\n            }\n            emit Claim(msg.sender, sentTemp, loanId);\n            sent += sentTemp;\n        }\n    }\n\n    /// @notice claims share of liquidation due to a borrower who's collateral has been sold\n    /// @param loanIds loan identifiers of one or multiple loans where the borrower wants to claim liquidation share\n    /// @return sent amount sent\n    function claimAsBorrower(uint256[] calldata loanIds) external returns (uint256 sent) {\n        Protocol storage proto = protocolStorage();\n        Loan storage loan;\n        uint256 sentTemp;\n        uint256 loanId;\n\n        for (uint256 i = 0; i < loanIds.length; i++) {\n            loanId = loanIds[i];\n            loan = proto.loan[loanId];\n            if (loan.borrower != msg.sender) {\n                revert NotBorrowerOfTheLoan(loanId);\n            }\n            if (loan.payment.borrowerClaimed) {\n                revert BorrowerAlreadyClaimed(loanId);\n            }\n            if (loan.payment.liquidated) {\n                loan.payment.borrowerClaimed = true;\n                // 1 - shareLent = share belonging to the borrower (not used as collateral)\n                sentTemp = loan.payment.paid.mul(ONE.sub(loan.shareLent));\n            } else {\n                revert LoanNotRepaidOrLiquidatedYet(loanId);\n            }\n            if (sentTemp > 0) {\n                /* the function may be called to store that the borrower claimed its due, but if this due is of 0 there\n                is no point in emitting a transfer and claim event */\n                loan.assetLent.checkedTransfer(msg.sender, sentTemp);\n                sent += sentTemp;\n                emit Claim(msg.sender, sentTemp, loanId);\n            }\n        }\n    }\n\n    /// @notice sends principal plus interests of the loan to `msg.sender`\n    /// @param loan - to calculate amount from\n    /// @param provision liquidity provision for this loan\n    /// @return sent amount sent\n    function sendInterests(Loan storage loan, Provision storage provision) internal returns (uint256 sent) {\n        uint256 interests = loan.payment.paid - loan.lent;\n        if (interests == loan.payment.minInterestsToRepay) {\n            // this is the case if the loan is repaid shortly after issuance\n            // each lender gets its minimal interest, as an anti ddos measure to spam offer\n            sent = provision.amount + (interests / loan.nbOfPositions);\n        } else {\n            /* provision.amount / lent = share of the interests belonging to the lender. The parenthesis make the\n            calculus in the order that maximizes precison */\n            sent = provision.amount + (interests * (provision.amount)) / loan.lent;\n        }\n        loan.assetLent.checkedTransfer(msg.sender, sent);\n    }\n\n    /// @notice sends liquidation share due to `msg.sender` as a supplier\n    /// @param loan - from which the collateral were liquidated\n    /// @param provision liquidity provisioned by this loan by the supplier\n    /// @return sent amount sent\n    function sendShareOfSaleAsSupplier(\n        Loan storage loan,\n        Provision storage provision\n    ) internal returns (uint256 sent) {\n        // in the case of a liqudidation, provision.share is considered the share of the NFT acquired by the lender\n        sent = loan.payment.paid.mul(provision.share);\n        loan.assetLent.checkedTransfer(msg.sender, sent);\n    }\n}"
    }
  ]
}