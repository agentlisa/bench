{
  "Title": "Race condition in the `submitEpochReward()` start epoch ID",
  "Content": "##### Description\nThe `submitEpochReward()` function is designed to report the reward amount over the interval of one or several epochs. The arguments of this function are the end epoch ID and the reward amount. The start epoch ID is calculated onchain. Due to a potential race condition in the offchain oracle mechanics, there's a possibility that the start epoch ID will be miscalculated. This could lead to reporting extra rewards.\n\nRelated code - _updateEpochReward: https://github.com/aspidanet/aspida-contract/blob/a94928e27a72baabb8c73b42634350ca934b3353/contracts/RewardOracle.sol#L196\n##### Recommendation\nWe recommend introducing an additional argument, `startEpochId`, and reverting reward reports with mismatching start epoch ID values.",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/RewardOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\n\nimport \"./library/PauseGuardian.sol\";\nimport \"./library/Manable.sol\";\n\nimport \"./interface/ICore.sol\";\n\n/**\n * @title Aspida's ETH 2.0 staking reward oracle\n * @dev This contract serves as a reward oracle for ETH 2.0 staking. It calculates and updates the epoch reward based on various parameters.\n * @author Aspida engineer\n */\ncontract RewardOracle is Ownable2StepUpgradeable, PauseGuardian, Manable {\n    uint256 internal constant BASE = 1e18;\n    uint256 internal constant SECONDS_PER_SLOT = 12 seconds;\n    uint256 internal constant SLOT_PER_EPOCH = 32;\n    uint256 internal constant EPOCH_PER_YEAR = 365 days / (SECONDS_PER_SLOT * SLOT_PER_EPOCH);\n    uint256 internal constant EPOCH_INTEREST_RATE_MAX = BASE / EPOCH_PER_YEAR;\n\n    uint256 internal constant DEPOSIT_SIZE = 32 ether; // The deposit size for validators\n\n    ICore internal immutable CORE; // The interface for the core contract\n\n    uint256 internal interestRateLimitPerEpoch_; // The interest rate limit per epoch\n    uint256 internal validatorLimitPerEpoch_; // The validator limit per epoch\n\n    uint256 internal lastEpochId_; // The last epoch ID\n    uint256 internal lastActivatedValidatorCount_; // The last activated validator count\n\n    /**\n     * @dev Emitted when the interest rate limit per epoch is set\n     */\n    event SetInterestRateLimitPerEpoch(uint256 interestRateLimitPerEpoch);\n\n    /**\n     * @dev Emitted when the validator limit per epoch is set\n     */\n    event SetValidatorLimitPerEpoch(uint256 validatorLimitPerEpoch);\n\n    /**\n     * @dev Emitted when the epoch reward is updated\n     */\n    event UpdateEpochReward(\n        uint256 lastEpochId,\n        uint256 submitEpochId,\n        uint256 lastActivatedValidatorCount,\n        uint256 activatedValidatorCount,\n        uint256 rewardIncrement\n    );\n\n    /**\n     * @notice Only for the implementation contract, as for the proxy pattern,\n     *            should call `initialize()` separately.\n     * @param _core The interface for the core contract\n     */\n    constructor(ICore _core) {\n        CORE = _core;\n        initialize();\n    }\n\n    /**\n     * @notice Expects to call only once to initialize RewardOracle.\n     */\n    function initialize() public initializer {\n        __Ownable2Step_init();\n        _setInterestRateLimitPerEpoch(BASE);\n    }\n\n    /**\n     * @dev Unpause when RewardOracle is paused.\n     */\n    function _open() external onlyOwner {\n        _unpause();\n    }\n\n    /**\n     * @dev Pause RewardOracle.\n     */\n    function _close() external onlyPauseGuardian {\n        _pause();\n    }\n\n    /**\n     * @notice Add `_pauseGuardian` into pause guardians.\n     * @param _pauseGuardian The address of the pause guardian to add\n     */\n    function _addPauseGuardian(address _pauseGuardian) external onlyOwner {\n        _addPauseGuardianInternal(_pauseGuardian);\n    }\n\n    /**\n     * @notice Remove `_pauseGuardian` from pause guardians.\n     * @param _pauseGuardian The address of the pause guardian to remove\n     */\n    function _removePauseGuardian(address _pauseGuardian) external onlyOwner {\n        _removePauseGuardianInternal(_pauseGuardian);\n    }\n\n    /**\n     * @notice Add `_manager` into managers.\n     * If `_manager` have not been a manager, emits a `ManagerAdded` event.\n     *\n     * @param _manager The manager to add\n     *\n     * Requirements:\n     * - the caller must be `owner`.\n     */\n    function _addManager(address _manager) external onlyOwner {\n        _addManagerInternal(_manager);\n    }\n\n    /**\n     * @notice Remove `_manager` from managers.\n     * If `_manager` is a manager, emits a `ManagerRemoved` event.\n     *\n     * @param _manager The manager to remove\n     *\n     * Requirements:\n     * - the caller must be `owner`.\n     */\n    function _removeManager(address _manager) external onlyOwner {\n        _removeManagerInternal(_manager);\n    }\n\n    /**\n     * @notice Set the interest rate limit per epoch.\n     * @param _annualInterestRate The annual interest rate\n     *\n     * Requirements:\n     * - the caller must be `owner`.\n     * - the interest rate must not be too large.\n     * - the interest rate cannot be set to the same value.\n     */\n    function _setInterestRateLimitPerEpoch(uint256 _annualInterestRate) public onlyOwner {\n        uint256 _interestRateLimitPerEpoch = _annualInterestRate / EPOCH_PER_YEAR;\n        require(\n            _interestRateLimitPerEpoch <= EPOCH_INTEREST_RATE_MAX,\n            \"_setInterestRateLimitPerEpoch: Interest rate too large\"\n        );\n        require(\n            _interestRateLimitPerEpoch != interestRateLimitPerEpoch_,\n            \"_setInterestRateLimitPerEpoch: Cannot set the same value\"\n        );\n        interestRateLimitPerEpoch_ = _interestRateLimitPerEpoch;\n        emit SetInterestRateLimitPerEpoch(_interestRateLimitPerEpoch);\n    }\n\n    /**\n     * @notice Set the validator limit per epoch.\n     * @param _validatorLimitPerEpoch The validator limit per epoch\n     *\n     * Requirements:\n     * - the caller must be `owner`.\n     * - the validator limit cannot be set to the same value.\n     */\n    function _setValidatorLimitPerEpoch(uint256 _validatorLimitPerEpoch) public onlyOwner {\n        require(\n            _validatorLimitPerEpoch != validatorLimitPerEpoch_,\n            \"_setValidatorLimitPerEpoch: Cannot set the same value\"\n        );\n        validatorLimitPerEpoch_ = _validatorLimitPerEpoch;\n        emit SetValidatorLimitPerEpoch(_validatorLimitPerEpoch);\n    }\n\n    /**\n     * @notice Calculate the epoch interest rate.\n     * @param _epochCount The number of epochs\n     * @param _activatedValidatorCount The number of activated validators\n     * @param _rewardIncrement The reward increment\n     * @return The epoch interest rate\n     */\n    function _calculateEpochInterestRate(\n        uint256 _epochCount,\n        uint256 _activatedValidatorCount,\n        uint256 _rewardIncrement\n    ) internal pure returns (uint256) {\n        uint256 _principal = _epochCount * _activatedValidatorCount * DEPOSIT_SIZE;\n        return (_rewardIncrement * BASE + _principal - 1) / _principal;\n    }\n\n    /**\n     * @notice Update the epoch reward.\n     * @param _epochId The epoch ID\n     * @param _activatedValidatorCount The number of activated validators\n     * @param _rewardIncrement The reward increment\n     *\n     * Requirements:\n     * - the active validators must not be 0.\n     * - the epoch ID must increase.\n     * - the epoch interest rate must be valid.\n     * - the validator limit must not be exceeded.\n     */\n    function _updateEpochReward(uint256 _epochId, uint256 _activatedValidatorCount, uint256 _rewardIncrement) internal {\n        require(_activatedValidatorCount > 0, \"_updateEpochReward: Active validators must not be 0\");\n\n        uint256 _lastEpochId = lastEpochId_;\n        require(_epochId > _lastEpochId, \"_updateEpochReward: Epoch id must increase\");\n\n        uint256 _epochCount = _epochId - _lastEpochId;\n        uint256 _epochInterestRate = _calculateEpochInterestRate(\n            _epochCount,\n            _activatedValidatorCount,\n            _rewardIncrement\n        );\n        require(_epochInterestRate <= interestRateLimitPerEpoch_, \"_updateEpochReward: Invalid epoch interest rate\");\n\n        uint256 _lastActivatedValidatorCount = lastActivatedValidatorCount_;\n        if (_activatedValidatorCount > _lastActivatedValidatorCount) {\n            require(\n                (_activatedValidatorCount - _lastActivatedValidatorCount + _epochCount - 1) / _epochCount <=\n                    validatorLimitPerEpoch_,\n                \"_updateEpochReward: Validator out of increment per epoch\"\n            );\n        }\n\n        lastEpochId_ = _epochId;\n        lastActivatedValidatorCount_ = _activatedValidatorCount;\n        emit UpdateEpochReward(\n            _lastEpochId,\n            _epochId,\n            _lastActivatedValidatorCount,\n            _activatedValidatorCount,\n            _rewardIncrement\n        );\n    }\n\n    /**\n     * @notice Submit the epoch reward.\n     * @param _epochId The epoch ID\n     * @param _activatedValidatorCount The number of activated validators\n     * @param _rewardIncrement The reward increment\n     *\n     * Requirements:\n     * - the caller must be the `manager`.\n     * - the contract must not be paused.\n     */\n    function submitEpochReward(\n        uint256 _epochId,\n        uint256 _activatedValidatorCount,\n        uint256 _rewardIncrement\n    ) external whenNotPaused onlyManager {\n        _updateEpochReward(_epochId, _activatedValidatorCount, _rewardIncrement);\n        CORE.supplyReward(_rewardIncrement);\n    }\n\n    /**\n     * @notice Get the CORE contract.\n     * @return The CORE contract.\n     */\n    function core() external view returns (ICore) {\n        return CORE;\n    }\n\n    /**\n     * @notice Get the interest rate limit per epoch.\n     * @return The interest rate limit per epoch.\n     */\n    function interestRateLimitPerEpoch() external view returns (uint256) {\n        return interestRateLimitPerEpoch_;\n    }\n\n    /**\n     * @notice Get the validator limit per epoch.\n     * @return The validator limit per epoch.\n     */\n    function validatorLimitPerEpoch() external view returns (uint256) {\n        return validatorLimitPerEpoch_;\n    }\n\n    /**\n     * @notice Get the last epoch ID.\n     * @return The last epoch ID.\n     */\n    function lastEpochId() external view returns (uint256) {\n        return lastEpochId_;\n    }\n\n    /**\n     * @notice Get the last activated validator count.\n     * @return The last activated validator count.\n     */\n    function lastActivatedValidatorCount() external view returns (uint256) {\n        return lastActivatedValidatorCount_;\n    }\n\n    /**\n     * @notice Check if an address is a pause guardian.\n     * @param _pauseGuardian The address to check.\n     * @return True if the address is a pause guardian or the owner, false otherwise.\n     */\n    function isPauseGuardian(address _pauseGuardian) public view override returns (bool) {\n        return PauseGuardian.isPauseGuardian(_pauseGuardian) || _pauseGuardian == owner();\n    }\n}"
    }
  ]
}