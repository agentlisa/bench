{
  "Title": "[H-03] Outstanding reserved tokens are incorrectly counted in total redemption weight",
  "Content": "\nThe amounts redeemed in overflow redemption can be calculated incorrectly due to incorrect accounting of the outstanding number of reserved tokens.\n\n### Proof of Concept\n\nProject contributors are allowed to redeem their NFT tokens for a portion of the overflow (excessive funded amounts). The amount a contributor receives is calculated as [overflow &ast; (user's redemption rate / total redemption weight)](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/abstract/JB721Delegate.sol#L135-L142), where user's redemption weight is [the total contribution floor of all their NFTs](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L532-L539) and total redemption weight is [the total contribution floor of all minted NFTs](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L563-L566). Since the total redemption weight is the sum of individual contributor redemption weights, the amount they can redeem is proportional to their contribution.\n\nHowever, the total redemption weight calculation incorrectly accounts outstanding reserved tokens ([JBTiered721DelegateStore.sol#L563-L566](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L563-L566)):\n\n```solidity\n// Add the tier's contribution floor multiplied by the quantity minted.\nweight +=\n  (_storedTier.contributionFloor *\n    (_storedTier.initialQuantity - _storedTier.remainingQuantity)) +\n  _numberOfReservedTokensOutstandingFor(_nft, _i, _storedTier);\n```\n\nSpecifically, the *number* of reserved tokens is added to the *weight* of minted tokens. This disrupts the redemption amount calculation formula since the total redemption weight is in fact not the sum of individual contributor redemption weights.\n\n### Recommended Mitigation Steps\n\nTwo options can be seen:\n\n1.  if the outstanding number of reserved tokens is considered minted (which seems to be so, judging by [this logic](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L1058-L1063)) then it needs to be added to the quantity, i.e.:\n    ```diff\n    --- a/contracts/JBTiered721DelegateStore.sol\n    +++ b/contracts/JBTiered721DelegateStore.sol\n    @@ -562,8 +562,7 @@ contract JBTiered721DelegateStore is IJBTiered721DelegateStore {\n          // Add the tier's contribution floor multiplied by the quantity minted.\n          weight +=\n            (_storedTier.contributionFloor *\n    -          (_storedTier.initialQuantity - _storedTier.remainingQuantity)) +\n    -        _numberOfReservedTokensOutstandingFor(_nft, _i, _storedTier);\n    +          (_storedTier.initialQuantity - _storedTier.remainingQuantity +\n    +           _numberOfReservedTokensOutstandingFor(_nft, _i, _storedTier)));\n\n          unchecked {\n            ++_i;\n    ```\n2.  if it's not considered minted, then it shouldn't be counted at all.\n\n**[drgorillamd (Juicebox DAO) confirmed](https://github.com/code-423n4/2022-10-juicebox-findings/issues/129)** \n\n**[Picodes (judge) upgraded severity](https://github.com/code-423n4/2022-10-juicebox-findings/issues/129#issuecomment-1303554688):**\n > As the redeemed amounts are at stake, upgrading to High\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-10-juicebox-contest",
  "Code": [
    {
      "filename": "contracts/abstract/JB721Delegate.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport '@jbx-protocol/juice-contracts-v3/contracts/interfaces/IJBFundingCycleDataSource.sol';\nimport '@jbx-protocol/juice-contracts-v3/contracts/interfaces/IJBPayDelegate.sol';\nimport '@jbx-protocol/juice-contracts-v3/contracts/libraries/JBConstants.sol';\nimport '@jbx-protocol/juice-contracts-v3/contracts/structs/JBPayParamsData.sol';\nimport '@jbx-protocol/juice-contracts-v3/contracts/structs/JBPayDelegateAllocation.sol';\nimport '@paulrberg/contracts/math/PRBMath.sol';\nimport '../interfaces/IJB721Delegate.sol';\nimport './ERC721.sol';\n\n/**\n  @title \n  JB721Delegate\n\n  @notice \n  Delegate that offers project contributors NFTs upon payment and the ability to redeem NFTs for treasury assets.\n\n  @dev\n  Adheres to -\n  IJB721Delegate: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.\n  IJBFundingCycleDataSource: Allows this contract to be attached to a funding cycle to have its methods called during regular protocol operations.\n  IJBPayDelegate: Allows this contract to receive callbacks when a project receives a payment.\n  IJBRedemptionDelegate: Allows this contract to receive callbacks when a token holder redeems.\n\n  @dev\n  Inherits from -\n  ERC721: A standard definition for non-fungible tokens (NFTs).\n*/\nabstract contract JB721Delegate is\n  IJB721Delegate,\n  IJBFundingCycleDataSource,\n  IJBPayDelegate,\n  IJBRedemptionDelegate,\n  ERC721\n{\n  //*********************************************************************//\n  // --------------------------- custom errors ------------------------- //\n  //*********************************************************************//\n\n  error INVALID_PAYMENT_EVENT();\n  error INVALID_REDEMPTION_EVENT();\n  error UNAUTHORIZED();\n  error UNEXPECTED_TOKEN_REDEEMED();\n  error INVALID_REDEMPTION_METADATA();\n\n  //*********************************************************************//\n  // --------------- public immutable stored properties ---------------- //\n  //*********************************************************************//\n\n  /**\n    @notice\n    The ID of the project this contract's functionality applies to.\n  */\n  uint256 public override projectId;\n\n  /**\n    @notice\n    The directory of terminals and controllers for projects.\n  */\n  IJBDirectory public override directory;\n\n  //*********************************************************************//\n  // ------------------------- external views -------------------------- //\n  //*********************************************************************//\n\n  /**\n    @notice \n    Part of IJBFundingCycleDataSource, this function gets called when the project receives a payment. It will set itself as the delegate to get a callback from the terminal.\n\n    @param _data The Juicebox standard project payment data.\n\n    @return weight The weight that tokens should get minted in accordance with.\n    @return memo The memo that should be forwarded to the event.\n    @return delegateAllocations The amount to send to delegates instead of adding to the local balance.\n  */\n  function payParams(JBPayParamsData calldata _data)\n    external\n    view\n    override\n    returns (\n      uint256 weight,\n      string memory memo,\n      JBPayDelegateAllocation[] memory delegateAllocations\n    )\n  {\n    // Forward the recieved weight and memo, and use this contract as a pay delegate.\n    weight = _data.weight;\n    memo = _data.memo;\n    delegateAllocations = new JBPayDelegateAllocation[](1);\n    delegateAllocations[0] = JBPayDelegateAllocation(this, 0);\n  }\n\n  /**\n    @notice \n    Part of IJBFundingCycleDataSource, this function gets called when a project's token holders redeem.\n\n    @param _data The Juicebox standard project redemption data.\n\n    @return reclaimAmount The amount that should be reclaimed from the treasury.\n    @return memo The memo that should be forwarded to the event.\n    @return delegateAllocations The amount to send to delegates instead of adding to the beneficiary.\n  */\n  function redeemParams(JBRedeemParamsData calldata _data)\n    external\n    view\n    override\n    returns (\n      uint256 reclaimAmount,\n      string memory memo,\n      JBRedemptionDelegateAllocation[] memory delegateAllocations\n    )\n  {\n    // Make sure fungible project tokens aren't being redeemed too.\n    if (_data.tokenCount > 0) revert UNEXPECTED_TOKEN_REDEEMED();\n\n    // Check the 4 bytes interfaceId and handle the case where the metadata was not intended for this contract\n    if (\n      _data.metadata.length < 4 || bytes4(_data.metadata[0:4]) != type(IJB721Delegate).interfaceId\n    ) {\n      revert INVALID_REDEMPTION_METADATA();\n    }\n\n    // Set the only delegate allocation to be a callback to this contract.\n    delegateAllocations = new JBRedemptionDelegateAllocation[](1);\n    delegateAllocations[0] = JBRedemptionDelegateAllocation(this, 0);\n\n    // If redemption rate is 0, nothing can be reclaimed from the treasury\n    if (_data.redemptionRate == 0) return (0, _data.memo, delegateAllocations);\n\n    // Decode the metadata\n    (, uint256[] memory _decodedTokenIds) = abi.decode(_data.metadata, (bytes4, uint256[]));\n\n    // Get a reference to the redemption rate of the provided tokens.\n    uint256 _redemptionWeight = _redemptionWeightOf(_decodedTokenIds);\n\n    // Get a reference to the total redemption weight.\n    uint256 _total = _totalRedemptionWeight();\n\n    // Get a reference to the linear proportion.\n    uint256 _base = PRBMath.mulDiv(_data.overflow, _redemptionWeight, _total);\n\n    // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary.\n    if (_data.redemptionRate == JBConstants.MAX_REDEMPTION_RATE)\n      return (_base, _data.memo, delegateAllocations);\n\n    // Return the weighted overflow, and this contract as the delegate so that tokens can be deleted.\n    return (\n      PRBMath.mulDiv(\n        _base,\n        _data.redemptionRate +\n          PRBMath.mulDiv(\n            _redemptionWeight,\n            JBConstants.MAX_REDEMPTION_RATE - _data.redemptionRate,\n            _total\n          ),\n        JBConstants.MAX_REDEMPTION_RATE\n      ),\n      _data.memo,\n      delegateAllocations\n    );\n  }\n\n  //*********************************************************************//\n  // -------------------------- public views --------------------------- //\n  //*********************************************************************//\n\n  /**\n    @notice\n    Indicates if this contract adheres to the specified interface.\n\n    @dev\n    See {IERC165-supportsInterface}.\n\n    @param _interfaceId The ID of the interface to check for adherance to.\n  */\n  function supportsInterface(bytes4 _interfaceId)\n    public\n    view\n    virtual\n    override(ERC721, IERC165)\n    returns (bool)\n  {\n    return\n      _interfaceId == type(IJB721Delegate).interfaceId ||\n      _interfaceId == type(IJBFundingCycleDataSource).interfaceId ||\n      _interfaceId == type(IJBPayDelegate).interfaceId ||\n      _interfaceId == type(IJBRedemptionDelegate).interfaceId ||\n      super.supportsInterface(_interfaceId);\n  }\n\n  //*********************************************************************//\n  // -------------------------- constructor ---------------------------- //\n  //*********************************************************************//\n\n  /**\n    @param _projectId The ID of the project this contract's functionality applies to.\n    @param _directory The directory of terminals and controllers for projects.\n    @param _name The name of the token.\n    @param _symbol The symbol that the token should be represented by.\n  */\n  function _initialize(\n    uint256 _projectId,\n    IJBDirectory _directory,\n    string memory _name,\n    string memory _symbol\n  ) internal {\n    ERC721._initialize(_name, _symbol);\n\n    projectId = _projectId;\n    directory = _directory;\n  }\n\n  //*********************************************************************//\n  // ---------------------- external transactions ---------------------- //\n  //*********************************************************************//\n\n  /**\n    @notice \n    Part of IJBPayDelegate, this function gets called when the project receives a payment. It will mint an NFT to the contributor (_data.beneficiary) if conditions are met.\n\n    @dev \n    This function will revert if the contract calling is not one of the project's terminals. \n\n    @param _data The Juicebox standard project payment data.\n  */\n  function didPay(JBDidPayData calldata _data) external payable virtual override {\n    // Make sure the caller is a terminal of the project, and the call is being made on behalf of an interaction with the correct project.\n    if (\n      msg.value != 0 ||\n      !directory.isTerminalOf(projectId, IJBPaymentTerminal(msg.sender)) ||\n      _data.projectId != projectId\n    ) revert INVALID_PAYMENT_EVENT();\n\n    // Process the payment.\n    _processPayment(_data);\n  }\n\n  /**\n    @notice\n    Part of IJBRedeemDelegate, this function gets called when the token holder redeems. It will burn the specified NFTs to reclaim from the treasury to the _data.beneficiary.\n\n    @dev\n    This function will revert if the contract calling is not one of the project's terminals.\n\n    @param _data The Juicebox standard project redemption data.\n  */\n  function didRedeem(JBDidRedeemData calldata _data) external payable virtual override {\n    // Make sure the caller is a terminal of the project, and the call is being made on behalf of an interaction with the correct project.\n    if (\n      msg.value != 0 ||\n      !directory.isTerminalOf(projectId, IJBPaymentTerminal(msg.sender)) ||\n      _data.projectId != projectId\n    ) revert INVALID_REDEMPTION_EVENT();\n\n    // Check the 4 bytes interfaceId and handle the case where the metadata was not intended for this contract\n    if (\n      _data.metadata.length < 4 || bytes4(_data.metadata[0:4]) != type(IJB721Delegate).interfaceId\n    ) revert INVALID_REDEMPTION_METADATA();\n\n    // Decode the metadata.\n    (, uint256[] memory _decodedTokenIds) = abi.decode(_data.metadata, (bytes4, uint256[]));\n\n    // Get a reference to the number of token IDs being checked.\n    uint256 _numberOfTokenIds = _decodedTokenIds.length;\n\n    // Keep a reference to the token ID being iterated on.\n    uint256 _tokenId;\n\n    // Iterate through all tokens, burning them if the owner is correct.\n    for (uint256 _i; _i < _numberOfTokenIds; ) {\n      // Set the token's ID.\n      _tokenId = _decodedTokenIds[_i];\n\n      // Make sure the token's owner is correct.\n      if (_owners[_tokenId] != _data.holder) revert UNAUTHORIZED();\n\n      // Burn the token.\n      _burn(_tokenId);\n\n      unchecked {\n        ++_i;\n      }\n    }\n\n    // Call the hook.\n    _didBurn(_decodedTokenIds);\n  }\n\n  //*********************************************************************//\n  // ---------------------- internal transactions ---------------------- //\n  //*********************************************************************//\n\n  /** \n    @notice\n    Process a received payment.\n\n    @param _data The Juicebox standard project payment data.\n  */\n  function _processPayment(JBDidPayData calldata _data) internal virtual {\n    _data; // Prevents unused var compiler and natspec complaints.\n  }\n\n  /** \n    @notice\n    A function that will run when a tokens are burned via redemption.\n\n    @param _tokenIds The IDs of the tokens that were burned.\n  */\n  function _didBurn(uint256[] memory _tokenIds) internal virtual {\n    _tokenIds;\n  }\n\n  /** \n    @notice\n    The cumulative weight the given token IDs have in redemptions compared to the `totalRedemptionWeight`. \n\n    @param _tokenIds The IDs of the tokens to get the cumulative redemption weight of.\n\n    @return The weight.\n  */\n  function _redemptionWeightOf(uint256[] memory _tokenIds) internal view virtual returns (uint256) {\n    _tokenIds; // Prevents unused var compiler and natspec complaints.\n    return 0;\n  }\n\n  /** \n    @notice\n    The cumulative weight that all token IDs have in redemptions. \n\n    @return The total weight.\n  */\n  function _totalRedemptionWeight() internal view virtual returns (uint256) {\n    return 0;\n  }\n}"
    },
    {
      "filename": "contracts/JBTiered721DelegateStore.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport '@jbx-protocol/juice-contracts-v3/contracts/libraries/JBConstants.sol';\nimport './interfaces/IJBTiered721DelegateStore.sol';\nimport './libraries/JBBitmap.sol';\nimport './structs/JBBitmapWord.sol';\nimport './structs/JBStored721Tier.sol';\n\n/**\n  @title\n  JBTiered721DelegateStore\n\n  @notice\n  The contract that stores and manages the NFT's data.\n\n  @dev\n  Adheres to -\n  IJBTiered721DelegateStore: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.\n*/\ncontract JBTiered721DelegateStore is IJBTiered721DelegateStore {\n  using JBBitmap for mapping(uint256=>uint256);\n  using JBBitmap for JBBitmapWord;\n\n  //*********************************************************************//\n  // --------------------------- custom errors ------------------------- //\n  //*********************************************************************//\n\n  error CANT_MINT_MANUALLY();\n  error INSUFFICIENT_AMOUNT();\n  error INSUFFICIENT_RESERVES();\n  error INVALID_TIER();\n  error NO_QUANTITY();\n  error OUT();\n  error RESERVED_RATE_NOT_ALLOWED();\n  error MANUAL_MINTING_NOT_ALLOWED();\n  error PRICING_RESOLVER_CHANGES_LOCKED();\n  error TIER_LOCKED();\n  error TIER_REMOVED();\n  error VOTING_UNITS_NOT_ALLOWED();\n  error INVALID_PRICE_SORT_ORDER();\n\n  //*********************************************************************//\n  // --------------------- internal stored properties ------------------ //\n  //*********************************************************************//\n\n  /** \n    @notice\n    The index that should come after the given index when sorting by contribution floor.\n\n    @dev\n    If empty, assume the next index should come after. \n\n    _nft The NFT contract to get tier order index from.\n    _index The index to get a tier after relative to.\n  */\n  mapping(address => mapping(uint256 => uint256)) internal _tierIdAfter;\n\n  /**\n    @notice\n    An optional beneficiary for the reserved token of a given tier.\n\n    _nft The NFT contract to which the reserved token beneficiary belongs.\n    _tierId the ID of the tier.\n  */\n  mapping(address => mapping(uint256 => address)) internal _reservedTokenBeneficiaryOf;\n\n  /** \n    @notice\n    The stored reward tier. \n\n    _nft The NFT contract to which the tiers belong.\n    _tierId The incremental ID of the tier, starting with 1.\n  */\n  mapping(address => mapping(uint256 => JBStored721Tier)) internal _storedTierOf;\n\n  /**\n    @notice\n    Flags that influence the behavior of each NFT.\n\n    _nft The NFT for which the flags apply.\n  */\n  mapping(address => JBTiered721Flags) internal _flagsOf;\n\n  /** \n    @notice\n    For each tier ID, a flag indicating if the tier has been removed. \n\n    _nft The NFT contract to which the tier belong.\n    _depth The bitmap row\n    _word The row content\n  */\n  mapping(address => mapping(uint256 => uint256)) internal _isTierRemoved;\n\n  /** \n    @notice\n    For each NFT, the tier ID that comes last when sorting. \n\n    @dev\n    If not set, it is assumed the `maxTierIdOf` is the last sorted.\n\n    _nft The NFT contract to which the tier belongs.\n  */\n  mapping(address => uint256) internal _trackedLastSortTierIdOf;\n\n  //*********************************************************************//\n  // --------------------- public stored properties -------------------- //\n  //*********************************************************************//\n\n  /** \n    @notice\n    The biggest tier ID used. \n\n    @dev\n    This may not include the last tier ID if it has been removed.\n\n    _nft The NFT contract to get the number of tiers.\n  */\n  mapping(address => uint256) public override maxTierIdOf;\n\n  /** \n    @notice\n    Each account's balance within a specific tier.\n\n    _nft The NFT contract to which the tier balances belong.\n    _owner The address to get a balance for. \n    _tierId The ID of the tier to get a balance within.\n  */\n  mapping(address => mapping(address => mapping(uint256 => uint256))) public override tierBalanceOf;\n\n  /**\n    @notice \n    The number of reserved tokens that have been minted for each tier. \n\n    _nft The NFT contract to which the reserve data belong.\n    _tierId The ID of the tier to get a minted reserved token count for.\n   */\n  mapping(address => mapping(uint256 => uint256)) public override numberOfReservesMintedFor;\n\n  /**\n    @notice \n    The number of tokens that have been burned for each tier. \n\n    _nft The NFT contract to which the burned data belong.\n    _tierId The ID of the tier to get a burned token count for.\n   */\n  mapping(address => mapping(uint256 => uint256)) public override numberOfBurnedFor;\n\n  /** \n    @notice\n    The beneficiary of reserved tokens when the tier doesn't specify a beneficiary.\n\n    _nft The NFT contract to which the reserved token beneficiary applies.\n  */\n  mapping(address => address) public override defaultReservedTokenBeneficiaryOf;\n\n  /**\n    @notice\n    The first owner of each token ID, stored on first transfer out.\n\n    _nft The NFT contract to which the token belongs.\n    _tokenId The ID of the token to get the stored first owner of.\n  */\n  mapping(address => mapping(uint256 => address)) public override firstOwnerOf;\n\n  /**\n    @notice\n    The common base for the tokenUri's\n\n    _nft The NFT for which the base URI applies.\n  */\n  mapping(address => string) public override baseUriOf;\n\n  /**\n    @notice\n    Custom token URI resolver, superceeds base URI.\n\n    _nft The NFT for which the token URI resolver applies.\n  */\n  mapping(address => IJBTokenUriResolver) public override tokenUriResolverOf;\n\n  /**\n    @notice\n    Contract metadata uri.\n\n    _nft The NFT for which the contract URI resolver applies.\n  */\n  mapping(address => string) public override contractUriOf;\n\n  /**\n    @notice\n    When using this contract to manage token uri's, those are stored as 32bytes, based on IPFS hashes stripped down.\n\n    _nft The NFT contract to which the encoded upfs uri belongs.\n    _tierId the ID of the tier\n  */\n  mapping(address => mapping(uint256 => bytes32)) public override encodedIPFSUriOf;\n\n  //*********************************************************************//\n  // ------------------------- external views -------------------------- //\n  //*********************************************************************//\n\n  /** \n    @notice\n    Gets an array of all the active tiers. \n\n    @param _nft The NFT contract to get tiers for.\n    @param _startingId The start index of the array of tiers sorted by contribution floor. Send 0 to start at the beginning.\n    @param _size The number of tiers to include.\n\n    @return _tiers All the tiers.\n  */\n  function tiers(\n    address _nft,\n    uint256 _startingId,\n    uint256 _size\n  ) external view override returns (JB721Tier[] memory _tiers) {\n    // Keep a reference to the last tier ID.\n    uint256 _lastTierId = _lastSortIndexOf(_nft);\n\n    // Initialize an array with the appropriate length.\n    _tiers = new JB721Tier[](_size);\n\n    // Count the number of included tiers.\n    uint256 _numberOfIncludedTiers;\n\n    // Get a reference to the index being iterated on, starting with the starting index.\n    uint256 _currentSortIndex = _startingId != 0 ? _startingId : _firstSortIndexOf(_nft);\n\n    // Keep a referecen to the tier being iterated on.\n    JBStored721Tier memory _storedTier;\n\n    // Initialise a BitmapWord for isRemoved\n    JBBitmapWord memory _bitmapWord = _isTierRemoved[_nft].readId(_currentSortIndex);\n\n    // Make the sorted array.\n    while (_currentSortIndex != 0 && _numberOfIncludedTiers < _size) {\n      // Is the current index outside the currently stored word for isRemoved?\n      if (_bitmapWord.refreshBitmapNeeded(_currentSortIndex))\n        _bitmapWord = _isTierRemoved[_nft].readId(_currentSortIndex);\n\n      if (!_bitmapWord.isTierIdRemoved(_currentSortIndex)) {\n        _storedTier = _storedTierOf[_nft][_currentSortIndex];\n        // Add the tier to the array being returned.\n        _tiers[_numberOfIncludedTiers++] = JB721Tier({\n          id: _currentSortIndex,\n          contributionFloor: _storedTier.contributionFloor,\n          lockedUntil: _storedTier.lockedUntil,\n          remainingQuantity: _storedTier.remainingQuantity,\n          initialQuantity: _storedTier.initialQuantity,\n          votingUnits: _storedTier.votingUnits,\n          reservedRate: _storedTier.reservedRate,\n          reservedTokenBeneficiary: reservedTokenBeneficiaryOf(_nft, _currentSortIndex),\n          encodedIPFSUri: encodedIPFSUriOf[_nft][_currentSortIndex],\n          allowManualMint: _storedTier.allowManualMint\n        });\n      }\n\n      // Set the next sort index.\n      _currentSortIndex = _nextSortIndex(_nft, _currentSortIndex, _lastTierId);\n    }\n\n    // Resize the array if there are removed tiers\n    if (_numberOfIncludedTiers != _size)\n      assembly (\"memory-safe\"){\n        mstore(_tiers, _numberOfIncludedTiers)\n      }\n  }\n\n  /** \n    @notice\n    Return the tier for the specified ID. \n\n    @param _nft The NFT to get a tier within.\n    @param _id The ID of the tier to get. \n\n    @return The tier.\n  */\n  function tier(address _nft, uint256 _id) external view override returns (JB721Tier memory) {\n    // Get the stored tier.\n    JBStored721Tier memory _storedTier = _storedTierOf[_nft][_id];\n\n    return\n      JB721Tier({\n        id: _id,\n        contributionFloor: _storedTier.contributionFloor,\n        lockedUntil: _storedTier.lockedUntil,\n        remainingQuantity: _storedTier.remainingQuantity,\n        initialQuantity: _storedTier.initialQuantity,\n        votingUnits: _storedTier.votingUnits,\n        reservedRate: _storedTier.reservedRate,\n        reservedTokenBeneficiary: reservedTokenBeneficiaryOf(_nft, _id),\n        encodedIPFSUri: encodedIPFSUriOf[_nft][_id],\n        allowManualMint: _storedTier.allowManualMint\n      });\n  }\n\n  /**  \n    @notice\n    Return the tier for the specified token ID. \n\n    @param _nft The NFT to get a tier within.\n    @param _tokenId The ID of token to return the tier of. \n\n    @return The tier.\n  */\n  function tierOfTokenId(address _nft, uint256 _tokenId)\n    external\n    view\n    override\n    returns (JB721Tier memory)\n  {\n    // Get a reference to the tier's ID.\n    uint256 _tierId = tierIdOfToken(_tokenId);\n\n    // Get the stored tier.\n    JBStored721Tier memory _storedTier = _storedTierOf[_nft][_tierId];\n\n    return\n      JB721Tier({\n        id: _tierId,\n        contributionFloor: _storedTier.contributionFloor,\n        lockedUntil: _storedTier.lockedUntil,\n        remainingQuantity: _storedTier.remainingQuantity,\n        initialQuantity: _storedTier.initialQuantity,\n        votingUnits: _storedTier.votingUnits,\n        reservedRate: _storedTier.reservedRate,\n        reservedTokenBeneficiary: reservedTokenBeneficiaryOf(_nft, _tierId),\n        encodedIPFSUri: encodedIPFSUriOf[_nft][_tierId],\n        allowManualMint: _storedTier.allowManualMint\n      });\n  }\n\n  /** \n    @notice \n    The total supply of issued NFTs from all tiers.\n\n    @param _nft The NFT to get a total supply of.\n\n    @return supply The total number of NFTs between all tiers.\n  */\n  function totalSupply(address _nft) external view override returns (uint256 supply) {\n    // Keep a reference to the tier being iterated on.\n    JBStored721Tier storage _storedTier;\n\n    // Keep a reference to the greatest tier ID.\n    uint256 _maxTierId = maxTierIdOf[_nft];\n\n    for (uint256 _i = _maxTierId; _i != 0; ) {\n      // Set the tier being iterated on.\n      _storedTier = _storedTierOf[_nft][_i];\n\n      // Increment the total supply with the amount used already.\n      supply += _storedTier.initialQuantity - _storedTier.remainingQuantity;\n\n      unchecked {\n        --_i;\n      }\n    }\n  }\n\n  /** \n    @notice\n    The number of reserved tokens that can currently be minted within the tier. \n\n    @param _nft The NFT to get a number of reserved tokens outstanding.\n    @param _tierId The ID of the tier to get a number of reserved tokens outstanding.\n\n    @return The outstanding number of reserved tokens within the tier.\n  */\n  function numberOfReservedTokensOutstandingFor(address _nft, uint256 _tierId)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return _numberOfReservedTokensOutstandingFor(_nft, _tierId, _storedTierOf[_nft][_tierId]);\n  }\n\n  /**\n    @notice\n    The voting units for an account from its NFTs across all tiers. NFTs have a tier-specific preset number of voting units. \n\n    @param _nft The NFT to get voting units within.\n    @param _account The account to get voting units for.\n\n    @return units The voting units for the account.\n  */\n  function votingUnitsOf(address _nft, address _account)\n    external\n    view\n    virtual\n    override\n    returns (uint256 units)\n  {\n    // Keep a reference to the greatest tier ID.\n    uint256 _maxTierId = maxTierIdOf[_nft];\n\n    // Keep a reference to the balance being iterated on.\n    uint256 _balance;\n\n    // Loop through all tiers.\n    for (uint256 _i = _maxTierId; _i != 0; ) {\n      // Get a reference to the account's balance in this tier.\n      _balance = tierBalanceOf[_nft][_account][_i];\n\n      if (_balance != 0)\n        // Add the tier's voting units.\n        units += _balance * _storedTierOf[_nft][_i].votingUnits;\n\n      unchecked {\n        --_i;\n      }\n    }\n  }\n\n  /**\n    @notice\n    The voting units for an account from its NFTs across all tiers. NFTs have a tier-specific preset number of voting units. \n\n    @param _nft The NFT to get voting units within.\n    @param _account The account to get voting units for.\n    @param _tierId The ID of the tier to get voting units for.\n\n    @return The voting units for the account.\n  */\n  function tierVotingUnitsOf(\n    address _nft,\n    address _account,\n    uint256 _tierId\n  ) external view virtual override returns (uint256) {\n    // Get a reference to the account's balance in this tier.\n    uint256 _balance = tierBalanceOf[_nft][_account][_tierId];\n\n    if (_balance == 0) return 0;\n\n    // Add the tier's voting units.\n    return _balance * _storedTierOf[_nft][_tierId].votingUnits;\n  }\n\n  /**\n    @notice\n    Resolves the encoded tier IPFS URI of the tier for the given token.\n\n    @param _nft The NFT contract to which the encoded IPFS URI belongs.\n    @param _tokenId the ID of the token.\n\n    @return The encoded IPFS URI.\n  */\n  function encodedTierIPFSUriOf(address _nft, uint256 _tokenId)\n    external\n    view\n    override\n    returns (bytes32)\n  {\n    return encodedIPFSUriOf[_nft][tierIdOfToken(_tokenId)];\n  }\n\n  /** \n    @notice\n    Flags that influence the behavior of each NFT.\n\n    @param _nft The NFT for which the flags apply.\n\n    @return The flags.\n  */\n  function flagsOf(address _nft) external view override returns (JBTiered721Flags memory) {\n    return _flagsOf[_nft];\n  }\n\n  /** \n    @notice\n    Tier removed from the current tiering\n\n    @param _nft The NFT for which the removed tier is queried\n    @param _tierId The tier ID\n\n    @return True if the tier has been removed\n  */\n  function isTierRemoved(address _nft, uint256 _tierId) external view override returns(bool) {\n    JBBitmapWord memory _bitmapWord = _isTierRemoved[_nft].readId(_tierId);\n    \n    return _bitmapWord.isTierIdRemoved(_tierId);\n  }\n\n  //*********************************************************************//\n  // -------------------------- public views --------------------------- //\n  //*********************************************************************//\n\n  /** \n    @notice \n    The total number of tokens owned by the given owner. \n\n    @param _nft The NFT to get a balance from.\n    @param _owner The address to check the balance of.\n\n    @return balance The number of tokens owners by the owner accross all tiers.\n  */\n  function balanceOf(address _nft, address _owner) public view override returns (uint256 balance) {\n    // Keep a reference to the greatest tier ID.\n    uint256 _maxTierId = maxTierIdOf[_nft];\n\n    // Loop through all tiers.\n    for (uint256 _i = _maxTierId; _i != 0; ) {\n      // Get a reference to the account's balance in this tier.\n      balance += tierBalanceOf[_nft][_owner][_i];\n\n      unchecked {\n        --_i;\n      }\n    }\n  }\n\n  /**\n    @notice\n    The cumulative weight the given token IDs have in redemptions compared to the `totalRedemptionWeight`.\n\n    @param _nft The NFT for which the redemption weight is being calculated.\n    @param _tokenIds The IDs of the tokens to get the cumulative redemption weight of.\n\n    @return weight The weight.\n  */\n  function redemptionWeightOf(address _nft, uint256[] calldata _tokenIds)\n    public\n    view\n    override\n    returns (uint256 weight)\n  {\n    // Get a reference to the total number of tokens.\n    uint256 _numberOfTokenIds = _tokenIds.length;\n\n    // Add each token's tier's contribution floor to the weight.\n    for (uint256 _i; _i < _numberOfTokenIds; ) {\n      weight += _storedTierOf[_nft][tierIdOfToken(_tokenIds[_i])].contributionFloor;\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /**\n    @notice\n    The cumulative weight that all token IDs have in redemptions.\n\n    @param _nft The NFT for which the redemption weight is being calculated.\n\n    @return weight The total weight.\n  */\n  function totalRedemptionWeight(address _nft) public view override returns (uint256 weight) {\n    // Keep a reference to the greatest tier ID.\n    uint256 _maxTierId = maxTierIdOf[_nft];\n\n    // Keep a reference to the tier being iterated on.\n    JBStored721Tier memory _storedTier;\n\n    // Add each token's tier's contribution floor to the weight.\n    for (uint256 _i; _i < _maxTierId; ) {\n      // Keep a reference to the stored tier.\n      _storedTier = _storedTierOf[_nft][_i + 1];\n\n      // Add the tier's contribution floor multiplied by the quantity minted.\n      weight +=\n        (_storedTier.contributionFloor *\n          (_storedTier.initialQuantity - _storedTier.remainingQuantity)) +\n        _numberOfReservedTokensOutstandingFor(_nft, _i, _storedTier);\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /** \n    @notice\n    The tier number of the provided token ID. \n\n    @dev\n    Tier's are 1 indexed from the `tiers` array, meaning the 0th element of the array is tier 1.\n\n    @param _tokenId The ID of the token to get the tier number of. \n\n    @return The tier number of the specified token ID.\n  */\n  function tierIdOfToken(uint256 _tokenId) public pure override returns (uint256) {\n    // The tier ID is in the first 16 bits.\n    return uint256(uint16(_tokenId));\n  }\n\n  /** \n    @notice\n    The reserved token beneficiary for each tier. \n\n    @param _nft The NFT to get the reserved token beneficiary within.\n    @param _tierId The ID of the tier to get a reserved token beneficiary of.\n\n    @return The reserved token benficiary.\n  */\n  function reservedTokenBeneficiaryOf(address _nft, uint256 _tierId)\n    public\n    view\n    override\n    returns (address)\n  {\n    // Get the stored reserved token beneficiary.\n    address _storedReservedTokenBeneficiaryOfTier = _reservedTokenBeneficiaryOf[_nft][_tierId];\n\n    // If the tier has a beneficiary return it.\n    if (_storedReservedTokenBeneficiaryOfTier != address(0))\n      return _storedReservedTokenBeneficiaryOfTier;\n\n    // Return the default.\n    return defaultReservedTokenBeneficiaryOf[_nft];\n  }\n\n  //*********************************************************************//\n  // ---------------------- external transactions ---------------------- //\n  //*********************************************************************//\n\n  /** \n    @notice\n    Adds tiers. \n\n    @param _tiersToAdd The tiers to add.\n\n    @return tierIds The IDs of the tiers added.\n  */\n  function recordAddTiers(JB721TierParams[] memory _tiersToAdd)\n    external\n    override\n    returns (uint256[] memory tierIds)\n  {\n    // Get a reference to the number of new tiers.\n    uint256 _numberOfNewTiers = _tiersToAdd.length;\n\n    // Keep a reference to the greatest tier ID.\n    uint256 _currentMaxTierIdOf = maxTierIdOf[msg.sender];\n\n    // Keep a reference to the current last sorted tier ID.\n    uint256 _currentLastSortIndex = _lastSortIndexOf(msg.sender);\n\n    // Initialize an array with the appropriate length.\n    tierIds = new uint256[](_numberOfNewTiers);\n\n    // Keep a reference to the starting sort ID for sorting new tiers if needed.\n    // There's no need for sorting if there are currently no tiers.\n    // If there's no sort index, start with the first index.\n    uint256 _startSortIndex = _currentMaxTierIdOf == 0 ? 0 : _first"
    }
  ]
}