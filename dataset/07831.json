{
  "Title": "[M-01] `isOwner` / `onlyOwner` checks can be bypassed by attacker in ERC721/ERC20 implementations",
  "Content": "\n[ERC721H.sol#L185](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/abstract/ERC721H.sol#L185)<br>\n[ERC721H.sol#L121](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/abstract/ERC721H.sol#L121)<br>\n\nERC20H and ERC721H are base contracts for NFTs / coins to inherit from. They supply the modifier onlyOwner and function isOwner which are used in the implementations for access control. However, there are several functions which when using these the answer may be corrupted to true by an attacker.\n\nThe issue comes from confusion between calls coming from HolographERC721's fallback function, and calls from actually implemented functions.\n\nIn the fallback function, the enforcer appends an additional 32 bytes of `msg.sender`:\n\n    assembly {\n      calldatacopy(0, 0, calldatasize())\n      mstore(calldatasize(), caller())\n      let result := call(gas(), sload(_sourceContractSlot), callvalue(), 0, add(calldatasize(), 32), 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n\nIndeed these are the bytes read as msgSender:\n\n    function msgSender() internal pure returns (address sender) {\n      assembly {\n        sender := calldataload(sub(calldatasize(), 0x20))\n      }\n    }\n\nand isOwner simply compares these to the stored owner:\n\n    function isOwner() external view returns (bool) {\n      if (msg.sender == holographer()) {\n        return msgSender() == _getOwner();\n      } else {\n        return msg.sender == _getOwner();\n      }\n    }\n\nHowever, the enforcer calls these functions directly in several locations, and in these cases it of course does not append a 32 byte msg.sender. For example, in safeTransferFrom:\n\n    function safeTransferFrom(\n      address from,\n      address to,\n      uint256 tokenId,\n      bytes memory data\n    ) public payable {\n      require(_isApproved(msg.sender, tokenId), \"ERC721: not approved sender\");\n      if (_isEventRegistered(HolographERC721Event.beforeSafeTransfer)) {\n        require(SourceERC721().beforeSafeTransfer(from, to, tokenId, data));\n      }\n      _transferFrom(from, to, tokenId);\n      if (_isContract(to)) {\n        require(\n          (ERC165(to).supportsInterface(ERC165.supportsInterface.selector) &&\n            ERC165(to).supportsInterface(ERC721TokenReceiver.onERC721Received.selector) &&\n            ERC721TokenReceiver(to).onERC721Received(address(this), from, tokenId, data) ==\n            ERC721TokenReceiver.onERC721Received.selector),\n          \"ERC721: onERC721Received fail\"\n        );\n      }\n      if (_isEventRegistered(HolographERC721Event.afterSafeTransfer)) {\n        require(SourceERC721().afterSafeTransfer(from, to, tokenId, data));\n      }\n    }\n\nHere, caller has arbitrary control of the data parameter, and can pass owner's address.When the implementation, SourceERC721(), gets called, beforeSafeTransfer / afterSafeTransfer will behave as if they are called by owner.\n\nTherefore, depending on the actual implementation, derived contracts can lose funds by specifying owner-specific logic.\n\nThis pattern occurs with the following functions, which have an arbitrary data parameter:\n\n*   beforeSafeTransfer / after SafeTransfer\n*   beforeTransfer / afterTransfer\n*   beforeOnERC721Received / afterOnERC721Received\n*   beforeOnERC20Received / aferERC20Received\n\n### Impact\n\nOwner-specific functionality can be initiated on NFT / ERC20 implementation contracts.\n\n### Recommended Mitigation Steps\n\nRefactor the code to represent `msg.sender` information in a bug-free way.\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/464#issuecomment-1295213520):**\n > Those function do not have the `onlyOwner` modifier so this doesn't seems to be valid. e.g.\n> [StrictERC20H.sol#L220-L228](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/abstract/StrictERC20H.sol#L220-L228)\n\n**[Trust (warden) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/464#issuecomment-1295249488):**\n > isOwner and onlyOwner are utilities implemented in ERC721H, to be used in implementation contracts. The actual implementations are out of scope, and defined by NFT / ERC20 creators. We can see such an example in the SampleERC721.sol file, which indeed uses onlyOwner:\n> ```\n>   function mint(\n>     address to,\n>     uint224 tokenId,\n>     string calldata URI\n>   ) external onlyHolographer onlyOwner {\n>     HolographERC721Interface H721 = HolographERC721Interface(holographer());\n>     if (tokenId == 0) {\n>       _currentTokenId += 1;\n>       while (H721.exists(uint256(_currentTokenId)) || H721.burned(uint256(_currentTokenId))) {\n>         _currentTokenId += 1;\n>       }\n>       tokenId = _currentTokenId;\n>     }\n>     H721.sourceMint(to, tokenId);\n>     uint256 id = H721.sourceGetChainPrepend() + uint256(tokenId);\n>     _tokenURIs[id] = URI;\n>   }\n> ```\n> The submission proves that these modifiers, which ARE in scope, are NOT safe to use in certain function implementations, as they can be bypassed. Since there is no warning label to not use those utilities in the list of functions I mentioned, this could potentially result in real damage to the protocol.\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/464#issuecomment-1295834895):**\n > Is there a codepath that the Holographer will call mint without appending sender address? This might be easy to misuse (which I doubt) but would be QA at best. Imo the modifier is working as intended and it is the developers responsibility to understand the consequences of making a call from the Holographer (which is a privileged account) regardless. Everything can be misused does not mean they are Med/High risk unless you can provide an actual exploit.\n\n**[Trust (warden) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/464#issuecomment-1295842157):**\n > I have brought up mint() as an example of using onlyOwner in the ERC721 implementation. I will reiterate that the issue is confusion between calls coming from HolographERC721's fallback function, and calls from Enforcer's transferFrom / safeTransferFrom / etc. When the list of functions above (beforeTransferFrom/ afterTransferFrom / etc) are called NOT from the fallback, which happens in transferFrom / safeTransferFrom / onERC20Received, the sender can pass any \"data\" parameter they wish, which will be interpreted by the isOwner function as the passed sender in the last 32 bytes.\n> \n> \"Everything can be misused does not mean they are Med/High risk unless you can provide an actual exploit.\" - The problem is that it will NOT be developer misuse to use isOwner / onlyOwner in ERC721/ERC20 implementation, it's use of inherited functionality (like in SampleERC721.sol example). There is no warning that owner check is not safe from \"beforeOnERC20Received\", for example.  Protocol is likely shooting themselves in the foot if they don't protect from owner checks in these functions.\n> \n> If it is required I have no problem coding example innocent ERC20/ERC721 implementation that is vulnerable to the attack.\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/464#issuecomment-1296062620):**\n > I will reopen this to let sponsor comment, but intended to judge as QA. Will review when judging.\n\nAlso they can't manipulate unless it is called from the Holographer, which have limited affordance.\n\n**[alexanderattar (Holograph) confirmed and commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/464#issuecomment-1306627521):**\n > This is a valid find. We will revisit the isOwner / onlyOwner modifiers and ensure this is handled appropriately so developers inheriting the mentioned Holograph contracts don't accidentally introduce unexpected logic in their contracts\n\n**[ACC01ADE (Holograph) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/464#issuecomment-1320038876):**\n > Fixing this by ensuring that any calls to implementation contracts from HolographERC20 and HolographERC721 do not call directly, but first have the caller attached to end of calldata so that isOwner and onlyOwner are consistent.\n>\n> [Feature/HOLO-605: C4 medium risk fixes](https://github.com/holographxyz/holograph-protocol/pull/88)\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-10-holograph-contest",
  "Code": [
    {
      "filename": "contracts/abstract/ERC721H.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/Initializable.sol\";\n\nabstract contract ERC721H is Initializable {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.holographer')) - 1)\n   */\n  bytes32 constant _holographerSlot = 0xe9fcff60011c1a99f7b7244d1f2d9da93d79ea8ef3654ce590d775575255b2bd;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.owner')) - 1)\n   */\n  bytes32 constant _ownerSlot = 0xb56711ba6bd3ded7639fc335ee7524fe668a79d7558c85992e3f8494cf772777;\n\n  modifier onlyHolographer() {\n    require(msg.sender == holographer(), \"ERC721: holographer only\");\n    _;\n  }\n\n  modifier onlyOwner() {\n    if (msg.sender == holographer()) {\n      require(msgSender() == _getOwner(), \"ERC721: owner only function\");\n    } else {\n      require(msg.sender == _getOwner(), \"ERC721: owner only function\");\n    }\n    _;\n  }\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external virtual override returns (bytes4) {\n    return _init(initPayload);\n  }\n\n  function _init(\n    bytes memory /* initPayload*/\n  ) internal returns (bytes4) {\n    require(!_isInitialized(), \"ERC721: already initialized\");\n    address _holographer = msg.sender;\n    assembly {\n      sstore(_holographerSlot, _holographer)\n    }\n    _setInitialized();\n    return InitializableInterface.init.selector;\n  }\n\n  /**\n   * @dev The Holographer passes original msg.sender via calldata. This function extracts it.\n   */\n  function msgSender() internal pure returns (address sender) {\n    assembly {\n      sender := calldataload(sub(calldatasize(), 0x20))\n    }\n  }\n\n  /**\n   * @dev Address of Holograph ERC721 standards enforcer smart contract.\n   */\n  function holographer() internal view returns (address _holographer) {\n    assembly {\n      _holographer := sload(_holographerSlot)\n    }\n  }\n\n  function supportsInterface(bytes4) external pure returns (bool) {\n    return false;\n  }\n\n  /**\n   * @dev Address of initial creator/owner of the collection.\n   */\n  function owner() external view returns (address) {\n    return _getOwner();\n  }\n\n  function isOwner() external view returns (bool) {\n    if (msg.sender == holographer()) {\n      return msgSender() == _getOwner();\n    } else {\n      return msg.sender == _getOwner();\n    }\n  }\n\n  function isOwner(address wallet) external view returns (bool) {\n    return wallet == _getOwner();\n  }\n\n  function _getOwner() internal view returns (address ownerAddress) {\n    assembly {\n      ownerAddress := sload(_ownerSlot)\n    }\n  }\n\n  function _setOwner(address ownerAddress) internal {\n    assembly {\n      sstore(_ownerSlot, ownerAddress)\n    }\n  }\n\n  /**\n   * @dev Defined here to suppress compiler warnings\n   */\n  receive() external payable {}\n\n  /**\n   * @dev Return true for any un-implemented event hooks\n   */\n  fallback() external payable {\n    assembly {\n      switch eq(sload(_holographerSlot), caller())\n      case 1 {\n        mstore(0x80, 0x0000000000000000000000000000000000000000000000000000000000000001)\n        return(0x80, 0x20)\n      }\n      default {\n        revert(0x00, 0x00)\n      }\n    }\n  }\n}"
    },
    {
      "filename": "contracts/abstract/ERC721H.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/Initializable.sol\";\n\nabstract contract ERC721H is Initializable {\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.holographer')) - 1)\n   */\n  bytes32 constant _holographerSlot = 0xe9fcff60011c1a99f7b7244d1f2d9da93d79ea8ef3654ce590d775575255b2bd;\n  /**\n   * @dev bytes32(uint256(keccak256('eip1967.Holograph.owner')) - 1)\n   */\n  bytes32 constant _ownerSlot = 0xb56711ba6bd3ded7639fc335ee7524fe668a79d7558c85992e3f8494cf772777;\n\n  modifier onlyHolographer() {\n    require(msg.sender == holographer(), \"ERC721: holographer only\");\n    _;\n  }\n\n  modifier onlyOwner() {\n    if (msg.sender == holographer()) {\n      require(msgSender() == _getOwner(), \"ERC721: owner only function\");\n    } else {\n      require(msg.sender == _getOwner(), \"ERC721: owner only function\");\n    }\n    _;\n  }\n\n  /**\n   * @dev Constructor is left empty and init is used instead\n   */\n  constructor() {}\n\n  /**\n   * @notice Used internally to initialize the contract instead of through a constructor\n   * @dev This function is called by the deployer/factory when creating a contract\n   * @param initPayload abi encoded payload to use for contract initilaization\n   */\n  function init(bytes memory initPayload) external virtual override returns (bytes4) {\n    return _init(initPayload);\n  }\n\n  function _init(\n    bytes memory /* initPayload*/\n  ) internal returns (bytes4) {\n    require(!_isInitialized(), \"ERC721: already initialized\");\n    address _holographer = msg.sender;\n    assembly {\n      sstore(_holographerSlot, _holographer)\n    }\n    _setInitialized();\n    return InitializableInterface.init.selector;\n  }\n\n  /**\n   * @dev The Holographer passes original msg.sender via calldata. This function extracts it.\n   */\n  function msgSender() internal pure returns (address sender) {\n    assembly {\n      sender := calldataload(sub(calldatasize(), 0x20))\n    }\n  }\n\n  /**\n   * @dev Address of Holograph ERC721 standards enforcer smart contract.\n   */\n  function holographer() internal view returns (address _holographer) {\n    assembly {\n      _holographer := sload(_holographerSlot)\n    }\n  }\n\n  function supportsInterface(bytes4) external pure returns (bool) {\n    return false;\n  }\n\n  /**\n   * @dev Address of initial creator/owner of the collection.\n   */\n  function owner() external view returns (address) {\n    return _getOwner();\n  }\n\n  function isOwner() external view returns (bool) {\n    if (msg.sender == holographer()) {\n      return msgSender() == _getOwner();\n    } else {\n      return msg.sender == _getOwner();\n    }\n  }\n\n  function isOwner(address wallet) external view returns (bool) {\n    return wallet == _getOwner();\n  }\n\n  function _getOwner() internal view returns (address ownerAddress) {\n    assembly {\n      ownerAddress := sload(_ownerSlot)\n    }\n  }\n\n  function _setOwner(address ownerAddress) internal {\n    assembly {\n      sstore(_ownerSlot, ownerAddress)\n    }\n  }\n\n  /**\n   * @dev Defined here to suppress compiler warnings\n   */\n  receive() external payable {}\n\n  /**\n   * @dev Return true for any un-implemented event hooks\n   */\n  fallback() external payable {\n    assembly {\n      switch eq(sload(_holographerSlot), caller())\n      case 1 {\n        mstore(0x80, 0x0000000000000000000000000000000000000000000000000000000000000001)\n        return(0x80, 0x20)\n      }\n      default {\n        revert(0x00, 0x00)\n      }\n    }\n  }\n}"
    },
    {
      "filename": "contracts/abstract/StrictERC20H.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../interface/HolographedERC20.sol\";\n\nimport \"./ERC20H.sol\";\n\nabstract contract StrictERC20H is ERC20H, HolographedERC20 {\n  /**\n   * @dev Dummy variable to prevent empty functions from making \"switch to pure\" warnings.\n   */\n  bool private _success;\n\n  function bridgeIn(\n    uint32, /* _chainId*/\n    address, /* _from*/\n    address, /* _to*/\n    uint256, /* _amount*/\n    bytes calldata /* _data*/\n  ) external virtual onlyHolographer returns (bool) {\n    _success = true;\n    return true;\n  }\n\n  function bridgeOut(\n    uint32, /* _chainId*/\n    address, /* _from*/\n    address, /* _to*/\n    uint256 /* _amount*/\n  ) external virtual onlyHolographer returns (bytes memory _data) {\n    /**\n     * @dev This is just here to suppress unused parameter warning\n     */\n    _data = abi.encodePacked(holographer());\n    _success = true;\n  }\n\n  function afterApprove(\n    address, /* _owner*/\n    address, /* _to*/\n    uint256 /* _amount*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function beforeApprove(\n    address, /* _owner*/\n    address, /* _to*/\n    uint256 /* _amount*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function afterOnERC20Received(\n    address, /* _token*/\n    address, /* _from*/\n    address, /* _to*/\n    uint256, /* _amount*/\n    bytes calldata /* _data*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function beforeOnERC20Received(\n    address, /* _token*/\n    address, /* _from*/\n    address, /* _to*/\n    uint256, /* _amount*/\n    bytes calldata /* _data*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function afterBurn(\n    address, /* _owner*/\n    uint256 /* _amount*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function beforeBurn(\n    address, /* _owner*/\n    uint256 /* _amount*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function afterMint(\n    address, /* _owner*/\n    uint256 /* _amount*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function beforeMint(\n    address, /* _owner*/\n    uint256 /* _amount*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function afterSafeTransfer(\n    address, /* _from*/\n    address, /* _to*/\n    uint256, /* _amount*/\n    bytes calldata /* _data*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function beforeSafeTransfer(\n    address, /* _from*/\n    address, /* _to*/\n    uint256, /* _amount*/\n    bytes calldata /* _data*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function afterTransfer(\n    address, /* _from*/\n    address, /* _to*/\n    uint256 /* _amount*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function beforeTransfer(\n    address, /* _from*/\n    address, /* _to*/\n    uint256 /* _amount*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n}"
    }
  ]
}