{
  "Title": "[M-11] `ValidatorWithdrawalVault.distributeRewards` can be called to make operator slashable",
  "Content": "\nAn attacker can call `distributeRewards` right before `settleFunds` to make `operatorShare < penaltyAmount`. As a result, the validator will face loses.\n\n### Proof of Concept\n\n`ValidatorWithdrawalVault.distributeRewards` can be called by anyone. It's purpose is to distribute validators rewards among the stakers protocol and the operator. After the call, the balance of `ValidatorWithdrawalVault` becomes 0.\n\n`ValidatorWithdrawalVault.settle` is called when a validator is withdrawn from beacon chain. In this case, the balance of the contract is used to [find operatorShare](https://github.com/code-423n4/2023-06-stader/blob/main/contracts/ValidatorWithdrawalVault.sol#L62). If it's less than the accrued penalty by the validator, then operator is slashed.\n\nBecause `distributeRewards` is permissionless, then next situation is possible:\n1. Operator decided to withdraw a validator. At the moment of that call, the balance of `ValidatorWithdrawalVault` is not 0 and `operatorShare` is 1 eth. Also the validator accrued 4.5 eth of penalty.\n2. A malicious user sees when 32 eth of a validator's deposit is sent to the `ValidatorWithdrawalVault` and frontruns it with `distributeRewards` call. This makes balance to be 32 eth.\n3. `operatorShare` will be 4 eth this time (permisssionless) and the penalty is 4.5, so the user is slashed.\n4. In this case, if a malicious user didn't call `distributeRewards`, then the slash would not occur.\n\nAlso in same way, a permissioned operator can call `distributeRewards` to get their rewards when they are going to be slashed. As permissioned validators are not forced to have collateral to be slashed, they rescued their earnings; otherwise, they would have been sent to the `pool`.\n\n### Tools Used\n\nVsCode\n\n### Recommended Mitigation Steps\n\nMaybe think about restricting access to the `distributeRewards` function.\n\n### Assessed type\n\nAccess Control\n\n**[manoj9april (Stader) disputed and commented](https://github.com/code-423n4/2022-06-stader-findings/issues/86#issuecomment-1596586514):**\n > This is intended, as we want to `slash SD` for an operator if the penalty is greater than operator share.<br>\n> Rewards share of vaults is going to be distributed by Stader every so often to enforce this.\n\n**[Picodes (judge) commented](https://github.com/code-423n4/2022-06-stader-findings/issues/86#issuecomment-1616848505):**\n > This report shows how an operator can be slashed depending on the order of actions. It seems a valid Medium severity issue to me, as front-running/changing a sequence of action could lead to a loss of funds compared to what the `operator` and `users` thought they should get.\n> \n> Wouldn't it solve this to also fetch and solve `penaltyAmount` during `distributeRewards`?\n\n**[Co0nan (warden) commented](https://github.com/code-423n4/2022-06-stader-findings/issues/86#issuecomment-1620878405):**\n > Not sure if I'm following the impact here. \n> \n> >At the moment of that call, balance of `ValidatorWithdrawalVault` is not 0 and `operatorShare` is 1 eth. Also validator accrued 4.5 eth of penalty.\n> \n> This case means the validator has to be slashed. In both cases, the user must be slashed according to the design. I can't see the exact root cause. Also, `distributeRewards` can be called at any time; no need to make a front-run, so the system behaves as intended.\n\n**[rvierdiyev (warden) commented](https://github.com/code-423n4/2022-06-stader-findings/issues/86#issuecomment-1625422196):**\n > @Co0nan - the problem here is that once `distributeRewards` is called, then all balances of the vault becomes 0. As I described in the example, the user had 1 eth inside the vault before the `distributeRewards` call and he has 4.5 eth of penalty.\n> \n> When withdrawals of 32 eth should come, the user's balance will be 1 + 4 eth, which is more than penalty. But because a malicious user calls `distributeRewards` before 32 eth will come, then the user in the end has only 4 eth, which is less than penalty.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-06-stader",
  "Code": [
    {
      "filename": "contracts/ValidatorWithdrawalVault.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport './library/UtilLib.sol';\nimport './library/ValidatorStatus.sol';\n\nimport './VaultProxy.sol';\nimport './interfaces/IPenalty.sol';\nimport './interfaces/IPoolUtils.sol';\nimport './interfaces/INodeRegistry.sol';\nimport './interfaces/IStaderStakePoolManager.sol';\nimport './interfaces/IValidatorWithdrawalVault.sol';\nimport './interfaces/SDCollateral/ISDCollateral.sol';\nimport './interfaces/IOperatorRewardsCollector.sol';\n\nimport '@openzeppelin/contracts/utils/math/Math.sol';\n\ncontract ValidatorWithdrawalVault is IValidatorWithdrawalVault {\n    bool internal vaultSettleStatus;\n    using Math for uint256;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {}\n\n    // Allows the contract to receive ETH\n    receive() external payable {\n        emit ETHReceived(msg.sender, msg.value);\n    }\n\n    function distributeRewards() external override {\n        uint8 poolId = VaultProxy(payable(address(this))).poolId();\n        uint256 validatorId = VaultProxy(payable(address(this))).id();\n        IStaderConfig staderConfig = VaultProxy(payable(address(this))).staderConfig();\n        uint256 totalRewards = address(this).balance;\n        if (!staderConfig.onlyOperatorRole(msg.sender) && totalRewards > staderConfig.getRewardsThreshold()) {\n            emit DistributeRewardFailed(totalRewards, staderConfig.getRewardsThreshold());\n            revert InvalidRewardAmount();\n        }\n        if (totalRewards == 0) {\n            revert NotEnoughRewardToDistribute();\n        }\n        (uint256 userShare, uint256 operatorShare, uint256 protocolShare) = IPoolUtils(staderConfig.getPoolUtils())\n            .calculateRewardShare(poolId, totalRewards);\n\n        // Distribute rewards\n        IStaderStakePoolManager(staderConfig.getStakePoolManager()).receiveWithdrawVaultUserShare{value: userShare}();\n        UtilLib.sendValue(payable(staderConfig.getStaderTreasury()), protocolShare);\n        IOperatorRewardsCollector(staderConfig.getOperatorRewardsCollector()).depositFor{value: operatorShare}(\n            getOperatorAddress(poolId, validatorId, staderConfig)\n        );\n        emit DistributedRewards(userShare, operatorShare, protocolShare);\n    }\n\n    function settleFunds() external override {\n        uint8 poolId = VaultProxy(payable(address(this))).poolId();\n        uint256 validatorId = VaultProxy(payable(address(this))).id();\n        IStaderConfig staderConfig = VaultProxy(payable(address(this))).staderConfig();\n        address nodeRegistry = IPoolUtils(staderConfig.getPoolUtils()).getNodeRegistry(poolId);\n        if (msg.sender != nodeRegistry) {\n            revert CallerNotNodeRegistryContract();\n        }\n        (uint256 userSharePrelim, uint256 operatorShare, uint256 protocolShare) = calculateValidatorWithdrawalShare();\n\n        uint256 penaltyAmount = getUpdatedPenaltyAmount(poolId, validatorId, staderConfig);\n\n        if (operatorShare < penaltyAmount) {\n            ISDCollateral(staderConfig.getSDCollateral()).slashValidatorSD(validatorId, poolId);\n            penaltyAmount = operatorShare;\n        }\n\n        uint256 userShare = userSharePrelim + penaltyAmount;\n        operatorShare = operatorShare - penaltyAmount;\n\n        // Final settlement\n        vaultSettleStatus = true;\n        IPenalty(staderConfig.getPenaltyContract()).markValidatorSettled(poolId, validatorId);\n        IStaderStakePoolManager(staderConfig.getStakePoolManager()).receiveWithdrawVaultUserShare{value: userShare}();\n        UtilLib.sendValue(payable(staderConfig.getStaderTreasury()), protocolShare);\n        IOperatorRewardsCollector(staderConfig.getOperatorRewardsCollector()).depositFor{value: operatorShare}(\n            getOperatorAddress(poolId, validatorId, staderConfig)\n        );\n        emit SettledFunds(userShare, operatorShare, protocolShare);\n    }\n\n    function calculateValidatorWithdrawalShare()\n        public\n        view\n        returns (\n            uint256 _userShare,\n            uint256 _operatorShare,\n            uint256 _protocolShare\n        )\n    {\n        uint8 poolId = VaultProxy(payable(address(this))).poolId();\n        IStaderConfig staderConfig = VaultProxy(payable(address(this))).staderConfig();\n        uint256 TOTAL_STAKED_ETH = staderConfig.getStakedEthPerNode();\n        uint256 collateralETH = getCollateralETH(poolId, staderConfig); // 0, incase of permissioned NOs\n        uint256 usersETH = TOTAL_STAKED_ETH - collateralETH;\n        uint256 contractBalance = address(this).balance;\n\n        uint256 totalRewards;\n\n        if (contractBalance <= usersETH) {\n            _userShare = contractBalance;\n            return (_userShare, _operatorShare, _protocolShare);\n        } else if (contractBalance <= TOTAL_STAKED_ETH) {\n            _userShare = usersETH;\n            _operatorShare = contractBalance - _userShare;\n            return (_userShare, _operatorShare, _protocolShare);\n        } else {\n            totalRewards = contractBalance - TOTAL_STAKED_ETH;\n            _operatorShare = collateralETH;\n            _userShare = usersETH;\n        }\n        if (totalRewards > 0) {\n            (uint256 userReward, uint256 operatorReward, uint256 protocolReward) = IPoolUtils(\n                staderConfig.getPoolUtils()\n            ).calculateRewardShare(poolId, totalRewards);\n            _userShare += userReward;\n            _operatorShare += operatorReward;\n            _protocolShare += protocolReward;\n        }\n    }\n\n    // HELPER METHODS\n\n    function getCollateralETH(uint8 _poolId, IStaderConfig _staderConfig) internal view returns (uint256) {\n        return IPoolUtils(_staderConfig.getPoolUtils()).getCollateralETH(_poolId);\n    }\n\n    function getOperatorAddress(\n        uint8 _poolId,\n        uint256 _validatorId,\n        IStaderConfig _staderConfig\n    ) internal view returns (address) {\n        return UtilLib.getOperatorAddressByValidatorId(_poolId, _validatorId, _staderConfig);\n    }\n\n    function getUpdatedPenaltyAmount(\n        uint8 _poolId,\n        uint256 _validatorId,\n        IStaderConfig _staderConfig\n    ) internal returns (uint256) {\n        address nodeRegistry = IPoolUtils(_staderConfig.getPoolUtils()).getNodeRegistry(_poolId);\n        (, bytes memory pubkey, , , , , , ) = INodeRegistry(nodeRegistry).validatorRegistry(_validatorId);\n        bytes[] memory pubkeyArray = new bytes[](1);\n        pubkeyArray[0] = pubkey;\n        IPenalty(_staderConfig.getPenaltyContract()).updateTotalPenaltyAmount(pubkeyArray);\n        return IPenalty(_staderConfig.getPenaltyContract()).totalPenaltyAmount(pubkey);\n    }\n}"
    }
  ]
}