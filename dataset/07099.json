{
  "Title": "[G-06] Internal/Private functions only called once can be inlined to save gas",
  "Content": "\nNot inlining costs 20 to 40 gas because of two extra JUMP instructions and additional stack operations needed for function calls.\n\nAffected code:\n\nhttps://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/adapter/yearn/YearnAdapter.sol#L89\n\n```solidity\nFile: /src/vault/adapter/yearn/YearnAdapter.sol\n89:    function _shareValue(uint256 yShares) internal view returns (uint256) {\n\n101:    function _freeFunds() internal view returns (uint256) {\n\n109:    function _yTotalAssets() internal view returns (uint256) {\n\n114:    function _calculateLockedProfit() internal view returns (uint256) {\n```\n\nhttps://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/vault/VaultController.sol#L120-L123\n\n```solidity\nFile: /src/vault/VaultController.sol\n120:  function _deployVault(VaultInitParams memory vaultData, IDeploymentController _deploymentController)\n121:    internal\n122:    returns (address vault)\n123:  {\n\n141:  function _registerCreatedVault(\n142:    address vault,\n143:    address staking,\n144:    VaultMetadata memory metadata\n145:  ) internal {\n\n154:  function _handleVaultStakingRewards(address vault, bytes memory rewardsData) internal {\n\n225:  function __deployAdapter(\n226:    DeploymentArgs memory adapterData,\n227:    bytes memory baseAdapterData,\n228:    IDeploymentController _deploymentController\n229:  ) internal returns (address adapter) {\n\n242:  function _encodeAdapterData(DeploymentArgs memory adapterData, bytes memory baseAdapterData)\n243:    internal\n244:    returns (bytes memory)\n245:  {\n\n256:  function _deployStrategy(DeploymentArgs memory strategyData, IDeploymentController _deploymentController)\n257:    internal\n258:    returns (address strategy)\n259:  {\n\n390:  function _registerVault(address vault, VaultMetadata memory metadata) internal {\n\n692:  function _verifyAdapterConfiguration(address adapter, bytes32 adapterId) internal view {\n```\n\nhttps://github.com/code-423n4/2023-01-popcorn/blob/d95fc31449c260901811196d617366d6352258cd/src/utils/MultiRewardStaking.sol#L191-L196\n\n```solidity\nFile: /src/utils/MultiRewardStaking.sol\n191:  function _lockToken(\n192:    address user,\n193:    IERC20 rewardToken,\n194:    uint256 rewardAmount,\n195:    EscrowInfo memory escrowInfo\n196:  ) internal {\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-01-popcorn",
  "Code": [
    {
      "filename": "src/vault/adapter/yearn/YearnAdapter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n// Docgen-SOLC: 0.8.15\n\npragma solidity ^0.8.15;\n\nimport {AdapterBase, ERC4626Upgradeable as ERC4626, IERC20, IERC20Metadata, ERC20, SafeERC20, Math, IStrategy, IAdapter} from \"../abstracts/AdapterBase.sol\";\nimport {VaultAPI, IYearnRegistry} from \"./IYearn.sol\";\n\n/**\n * @title   Yearn Adapter\n * @author  RedVeil\n * @notice  ERC4626 wrapper for Yearn Vaults.\n *\n * An ERC4626 compliant Wrapper for https://github.com/yearn/yearn-vaults/blob/master/contracts/Vault.vy.\n * Allows wrapping Yearn Vaults.\n */\ncontract YearnAdapter is AdapterBase {\n    using SafeERC20 for IERC20;\n    using Math for uint256;\n\n    string internal _name;\n    string internal _symbol;\n\n    VaultAPI public yVault;\n    uint256 constant DEGRADATION_COEFFICIENT = 10**18;\n\n    /**\n     * @notice Initialize a new Yearn Adapter.\n     * @param adapterInitData Encoded data for the base adapter initialization.\n     * @param externalRegistry Yearn registry address.\n     * @dev This function is called by the factory contract when deploying a new vault.\n     * @dev The yearn registry will be used given the `asset` from `adapterInitData` to find the latest yVault.\n     */\n    function initialize(\n        bytes memory adapterInitData,\n        address externalRegistry,\n        bytes memory\n    ) external initializer {\n        (address _asset, , , , , ) = abi.decode(\n            adapterInitData,\n            (address, address, address, uint256, bytes4[8], bytes)\n        );\n        __AdapterBase_init(adapterInitData);\n\n        yVault = VaultAPI(IYearnRegistry(externalRegistry).latestVault(_asset));\n\n        _name = string.concat(\n            \"Popcorn Yearn\",\n            IERC20Metadata(asset()).name(),\n            \" Adapter\"\n        );\n        _symbol = string.concat(\"popY-\", IERC20Metadata(asset()).symbol());\n\n        IERC20(_asset).approve(address(yVault), type(uint256).max);\n    }\n\n    function name()\n        public\n        view\n        override(IERC20Metadata, ERC20)\n        returns (string memory)\n    {\n        return _name;\n    }\n\n    function symbol()\n        public\n        view\n        override(IERC20Metadata, ERC20)\n        returns (string memory)\n    {\n        return _symbol;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          ACCOUNTING LOGIC\n  //////////////////////////////////////////////////////////////*/\n\n    /// @notice Emulate yearns total asset calculation to return the total assets of the vault.\n    function _totalAssets() internal view override returns (uint256) {\n        return _shareValue(underlyingBalance);\n    }\n\n    function _underlyingBalance() internal view override returns (uint256) {\n        return yVault.balanceOf(address(this));\n    }\n\n    /// @notice Determines the current value of `yShares` in assets\n    function _shareValue(uint256 yShares) internal view returns (uint256) {\n        if (yVault.totalSupply() == 0) return yShares;\n\n        return\n            yShares.mulDiv(\n                _freeFunds(),\n                yVault.totalSupply(),\n                Math.Rounding.Down\n            );\n    }\n\n    /// @notice The amount of assets that are free to be withdrawn from the yVault after locked profts.\n    function _freeFunds() internal view returns (uint256) {\n        return _yTotalAssets() - _calculateLockedProfit();\n    }\n\n    /**\n     * @notice Returns the total quantity of all assets under control of this Vault,\n     * whether they're loaned out to a Strategy, or currently held in the Vault.\n     */\n    function _yTotalAssets() internal view returns (uint256) {\n        return IERC20(asset()).balanceOf(address(yVault)) + yVault.totalDebt();\n    }\n\n    /// @notice Calculates how much profit is locked and cant be withdrawn.\n    function _calculateLockedProfit() internal view returns (uint256) {\n        uint256 lockedFundsRatio = (block.timestamp - yVault.lastReport()) *\n            yVault.lockedProfitDegradation();\n\n        if (lockedFundsRatio < DEGRADATION_COEFFICIENT) {\n            uint256 lockedProfit = yVault.lockedProfit();\n            return\n                lockedProfit -\n                ((lockedFundsRatio * lockedProfit) / DEGRADATION_COEFFICIENT);\n        } else {\n            return 0;\n        }\n    }\n\n    /// @notice The amount of yearn shares to withdraw given an amount of adapter shares\n    function convertToUnderlyingShares(uint256, uint256 shares)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return\n            shares.mulDiv(underlyingBalance, totalSupply(), Math.Rounding.Up);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    DEPOSIT/WITHDRAWAL LIMIT LOGIC\n  //////////////////////////////////////////////////////////////*/\n\n    /// @notice Applies the yVault deposit limit to the adapter.\n    function maxDeposit(address) public view override returns (uint256) {\n        if (paused()) return 0;\n\n        VaultAPI _bestVault = yVault;\n        uint256 assets = _bestVault.totalAssets();\n        uint256 _depositLimit = _bestVault.depositLimit();\n        if (assets >= _depositLimit) return 0;\n        return _depositLimit - assets;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _protocolDeposit(uint256 amount, uint256)\n        internal\n        virtual\n        override\n    {\n        yVault.deposit(amount);\n    }\n\n    function _protocolWithdraw(uint256 assets, uint256 shares)\n        internal\n        virtual\n        override\n    {\n        yVault.withdraw(convertToUnderlyingShares(assets, shares));\n    }\n}"
    },
    {
      "filename": "src/vault/VaultController.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\n// Docgen-SOLC: 0.8.15\npragma solidity ^0.8.15;\n\nimport { SafeERC20Upgradeable as SafeERC20 } from \"openzeppelin-contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport { Owned } from \"../utils/Owned.sol\";\nimport { IVault, VaultInitParams, VaultFees } from \"../interfaces/vault/IVault.sol\";\nimport { IMultiRewardStaking } from \"../interfaces/IMultiRewardStaking.sol\";\nimport { IMultiRewardEscrow } from \"../interfaces/IMultiRewardEscrow.sol\";\nimport { IDeploymentController, ICloneRegistry } from \"../interfaces/vault/IDeploymentController.sol\";\nimport { ITemplateRegistry, Template } from \"../interfaces/vault/ITemplateRegistry.sol\";\nimport { IPermissionRegistry, Permission } from \"../interfaces/vault/IPermissionRegistry.sol\";\nimport { IVaultRegistry, VaultMetadata } from \"../interfaces/vault/IVaultRegistry.sol\";\nimport { IAdminProxy } from \"../interfaces/vault/IAdminProxy.sol\";\nimport { IERC4626, IERC20 } from \"../interfaces/vault/IERC4626.sol\";\nimport { IStrategy } from \"../interfaces/vault/IStrategy.sol\";\nimport { IAdapter } from \"../interfaces/vault/IAdapter.sol\";\nimport { IPausable } from \"../interfaces/IPausable.sol\";\nimport { DeploymentArgs } from \"../interfaces/vault/IVaultController.sol\";\n\n/**\n * @title   VaultController\n * @author  RedVeil\n * @notice  Admin contract for the vault ecosystem.\n *\n * Deploys Vaults, Adapter, Strategies and Staking contracts.\n * Calls admin functions on deployed contracts.\n */\ncontract VaultController is Owned {\n  using SafeERC20 for IERC20;\n\n  /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n  bytes32 public immutable VAULT = \"Vault\";\n  bytes32 public immutable ADAPTER = \"Adapter\";\n  bytes32 public immutable STRATEGY = \"Strategy\";\n  bytes32 public immutable STAKING = \"Staking\";\n  bytes4 internal immutable DEPLOY_SIG = bytes4(keccak256(\"deploy(bytes32,bytes32,bytes)\"));\n\n  error UnderlyingError(bytes revertReason);\n\n  /**\n   * @notice Constructor of this contract.\n   * @param _owner Owner of the contract. Controls management functions.\n   * @param _adminProxy `AdminProxy` ownes contracts in the vault ecosystem.\n   * @param _deploymentController `DeploymentController` with auxiliary deployment contracts.\n   * @param _vaultRegistry `VaultRegistry` to safe vault metadata.\n   * @param _permissionRegistry `permissionRegistry` to add endorsements and rejections.\n   * @param _escrow `MultiRewardEscrow` To escrow rewards of staking contracts.\n   */\n  constructor(\n    address _owner,\n    IAdminProxy _adminProxy,\n    IDeploymentController _deploymentController,\n    IVaultRegistry _vaultRegistry,\n    IPermissionRegistry _permissionRegistry,\n    IMultiRewardEscrow _escrow\n  ) Owned(_owner) {\n    adminProxy = _adminProxy;\n    vaultRegistry = _vaultRegistry;\n    permissionRegistry = _permissionRegistry;\n    escrow = _escrow;\n\n    _setDeploymentController(_deploymentController);\n\n    activeTemplateId[STAKING] = \"MultiRewardStaking\";\n    activeTemplateId[VAULT] = \"V1\";\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                          VAULT DEPLOYMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  event VaultDeployed(address indexed vault, address indexed staking, address indexed adapter);\n\n  /**\n   * @notice Deploy a new Vault. Optionally with an Adapter and Staking. Caller must be owner.\n   * @param vaultData Vault init params.\n   * @param adapterData Encoded adapter init data.\n   * @param strategyData Encoded strategy init data.\n   * @param staking Address of staking contract to use for the vault. If 0, a new staking contract will be deployed.\n   * @param rewardsData Encoded data to add a rewards to the staking contract\n   * @param metadata Vault metadata for the `VaultRegistry` (Will be used by the frontend for additional informations)\n   * @param initialDeposit Initial deposit to the vault. If 0, no deposit will be made.\n   * @dev This function is the one stop solution to create a new vault with all necessary admin functions or auxiliery contracts.\n   */\n  function deployVault(\n    VaultInitParams memory vaultData,\n    DeploymentArgs memory adapterData,\n    DeploymentArgs memory strategyData,\n    address staking,\n    bytes memory rewardsData,\n    VaultMetadata memory metadata,\n    uint256 initialDeposit\n  ) external canCreate returns (address vault) {\n    IDeploymentController _deploymentController = deploymentController;\n\n    _verifyToken(address(vaultData.asset));\n    _verifyAdapterConfiguration(address(vaultData.adapter), adapterData.id);\n\n    if (adapterData.id > 0)\n      vaultData.adapter = IERC4626(_deployAdapter(vaultData.asset, adapterData, strategyData, _deploymentController));\n\n    vault = _deployVault(vaultData, _deploymentController);\n\n    if (staking == address(0)) staking = _deployStaking(IERC20(address(vault)), _deploymentController);\n\n    _registerCreatedVault(vault, staking, metadata);\n\n    if (rewardsData.length > 0) _handleVaultStakingRewards(vault, rewardsData);\n\n    emit VaultDeployed(vault, staking, address(vaultData.adapter));\n\n    _handleInitialDeposit(initialDeposit, IERC20(vaultData.asset), IERC4626(vault));\n  }\n\n  /// @notice Deploys a new vault contract using the `activeTemplateId`.\n  function _deployVault(VaultInitParams memory vaultData, IDeploymentController _deploymentController)\n    internal\n    returns (address vault)\n  {\n    vaultData.owner = address(adminProxy);\n\n    (bool success, bytes memory returnData) = adminProxy.execute(\n      address(_deploymentController),\n      abi.encodeWithSelector(\n        DEPLOY_SIG,\n        VAULT,\n        activeTemplateId[VAULT],\n        abi.encodeWithSelector(IVault.initialize.selector, vaultData)\n      )\n    );\n    if (!success) revert UnderlyingError(returnData);\n\n    vault = abi.decode(returnData, (address));\n  }\n\n  /// @notice Registers newly created vault metadata.\n  function _registerCreatedVault(\n    address vault,\n    address staking,\n    VaultMetadata memory metadata\n  ) internal {\n    metadata.vault = vault;\n    metadata.staking = staking;\n    metadata.creator = msg.sender;\n\n    _registerVault(vault, metadata);\n  }\n\n  /// @notice Prepares and calls `addStakingRewardsTokens` for the newly created staking contract.\n  function _handleVaultStakingRewards(address vault, bytes memory rewardsData) internal {\n    address[] memory vaultContracts = new address[](1);\n    bytes[] memory rewardsDatas = new bytes[](1);\n\n    vaultContracts[0] = vault;\n    rewardsDatas[0] = rewardsData;\n\n    addStakingRewardsTokens(vaultContracts, rewardsDatas);\n  }\n\n  function _handleInitialDeposit(\n    uint256 initialDeposit,\n    IERC20 asset,\n    IERC4626 target\n  ) internal {\n    if (initialDeposit > 0) {\n      asset.safeTransferFrom(msg.sender, address(this), initialDeposit);\n      asset.approve(address(target), initialDeposit);\n      target.deposit(initialDeposit, msg.sender);\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                      ADAPTER DEPLOYMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Deploy a new Adapter with our without a strategy. Caller must be owner.\n   * @param asset Asset which will be used by the adapter.\n   * @param adapterData Encoded adapter init data.\n   * @param strategyData Encoded strategy init data.\n   */\n  function deployAdapter(\n    IERC20 asset,\n    DeploymentArgs memory adapterData,\n    DeploymentArgs memory strategyData,\n    uint256 initialDeposit\n  ) external canCreate returns (address adapter) {\n    _verifyToken(address(asset));\n\n    adapter = _deployAdapter(asset, adapterData, strategyData, deploymentController);\n\n    _handleInitialDeposit(initialDeposit, asset, IERC4626(adapter));\n  }\n\n  /**\n   * @notice Deploys an adapter and optionally a strategy.\n   * @dev Adds the newly deployed strategy to the adapter.\n   */\n  function _deployAdapter(\n    IERC20 asset,\n    DeploymentArgs memory adapterData,\n    DeploymentArgs memory strategyData,\n    IDeploymentController _deploymentController\n  ) internal returns (address) {\n    address strategy;\n    bytes4[8] memory requiredSigs;\n    if (strategyData.id > 0) {\n      strategy = _deployStrategy(strategyData, _deploymentController);\n      requiredSigs = templateRegistry.getTemplate(STRATEGY, strategyData.id).requiredSigs;\n    }\n\n    return\n      __deployAdapter(\n        adapterData,\n        abi.encode(asset, address(adminProxy), IStrategy(strategy), harvestCooldown, requiredSigs, strategyData.data),\n        _deploymentController\n      );\n  }\n\n  /// @notice Deploys an adapter and sets the management fee via `AdminProxy`\n  function __deployAdapter(\n    DeploymentArgs memory adapterData,\n    bytes memory baseAdapterData,\n    IDeploymentController _deploymentController\n  ) internal returns (address adapter) {\n    (bool success, bytes memory returnData) = adminProxy.execute(\n      address(_deploymentController),\n      abi.encodeWithSelector(DEPLOY_SIG, ADAPTER, adapterData.id, _encodeAdapterData(adapterData, baseAdapterData))\n    );\n    if (!success) revert UnderlyingError(returnData);\n\n    adapter = abi.decode(returnData, (address));\n\n    adminProxy.execute(adapter, abi.encodeWithSelector(IAdapter.setPerformanceFee.selector, performanceFee));\n  }\n\n  /// @notice Encodes adapter init call. Was moved into its own function to fix \"stack too deep\" error.\n  function _encodeAdapterData(DeploymentArgs memory adapterData, bytes memory baseAdapterData)\n    internal\n    returns (bytes memory)\n  {\n    return\n      abi.encodeWithSelector(\n        IAdapter.initialize.selector,\n        baseAdapterData,\n        templateRegistry.getTemplate(ADAPTER, adapterData.id).registry,\n        adapterData.data\n      );\n  }\n\n  /// @notice Deploys a new strategy contract.\n  function _deployStrategy(DeploymentArgs memory strategyData, IDeploymentController _deploymentController)\n    internal\n    returns (address strategy)\n  {\n    (bool success, bytes memory returnData) = adminProxy.execute(\n      address(_deploymentController),\n      abi.encodeWithSelector(DEPLOY_SIG, STRATEGY, strategyData.id, \"\")\n    );\n    if (!success) revert UnderlyingError(returnData);\n\n    strategy = abi.decode(returnData, (address));\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                    STAKING DEPLOYMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Deploy a new staking contract. Caller must be owner.\n   * @param asset The staking token for the new contract.\n   * @dev Deploys `MultiRewardsStaking` based on the latest templateTemplateKey.\n   */\n  function deployStaking(IERC20 asset) external canCreate returns (address) {\n    _verifyToken(address(asset));\n    return _deployStaking(asset, deploymentController);\n  }\n\n  /// @notice Deploys a new staking contract using the activeTemplateId.\n  function _deployStaking(IERC20 asset, IDeploymentController _deploymentController)\n    internal\n    returns (address staking)\n  {\n    (bool success, bytes memory returnData) = adminProxy.execute(\n      address(_deploymentController),\n      abi.encodeWithSelector(\n        DEPLOY_SIG,\n        STAKING,\n        activeTemplateId[STAKING],\n        abi.encodeWithSelector(IMultiRewardStaking.initialize.selector, asset, escrow, adminProxy)\n      )\n    );\n    if (!success) revert UnderlyingError(returnData);\n\n    staking = abi.decode(returnData, (address));\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                    VAULT MANAGEMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  error DoesntExist(address adapter);\n\n  /**\n   * @notice Propose a new Adapter. Caller must be creator of the vaults.\n   * @param vaults Vaults to propose the new adapter for.\n   * @param newAdapter New adapters to propose.\n   */\n  function proposeVaultAdapters(address[] calldata vaults, IERC4626[] calldata newAdapter) external {\n    uint8 len = uint8(vaults.length);\n\n    _verifyEqualArrayLength(len, newAdapter.length);\n\n    ICloneRegistry _cloneRegistry = cloneRegistry;\n    for (uint8 i = 0; i < len; i++) {\n      _verifyCreator(vaults[i]);\n      if (!_cloneRegistry.cloneExists(address(newAdapter[i]))) revert DoesntExist(address(newAdapter[i]));\n\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        vaults[i],\n        abi.encodeWithSelector(IVault.proposeAdapter.selector, newAdapter[i])\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /**\n   * @notice Change adapter of a vault to the previously proposed adapter.\n   * @param vaults Addresses of the vaults to change\n   */\n  function changeVaultAdapters(address[] calldata vaults) external {\n    uint8 len = uint8(vaults.length);\n    for (uint8 i = 0; i < len; i++) {\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        vaults[i],\n        abi.encodeWithSelector(IVault.changeAdapter.selector)\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /**\n   * @notice Sets new fees per vault. Caller must be creator of the vaults.\n   * @param vaults Addresses of the vaults to change\n   * @param fees New fee structures for these vaults\n   * @dev Value is in 1e18, e.g. 100% = 1e18 - 1 BPS = 1e12\n   */\n  function proposeVaultFees(address[] calldata vaults, VaultFees[] calldata fees) external {\n    uint8 len = uint8(vaults.length);\n\n    _verifyEqualArrayLength(len, fees.length);\n\n    for (uint8 i = 0; i < len; i++) {\n      _verifyCreator(vaults[i]);\n\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        vaults[i],\n        abi.encodeWithSelector(IVault.proposeFees.selector, fees[i])\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /**\n   * @notice Change adapter of a vault to the previously proposed adapter.\n   * @param vaults Addresses of the vaults\n   */\n  function changeVaultFees(address[] calldata vaults) external {\n    uint8 len = uint8(vaults.length);\n    for (uint8 i = 0; i < len; i++) {\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        vaults[i],\n        abi.encodeWithSelector(IVault.changeFees.selector)\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                          REGISTER VAULT\n    //////////////////////////////////////////////////////////////*/\n\n  IVaultRegistry public vaultRegistry;\n\n  /// @notice Call the `VaultRegistry` to register a vault via `AdminProxy`\n  function _registerVault(address vault, VaultMetadata memory metadata) internal {\n    (bool success, bytes memory returnData) = adminProxy.execute(\n      address(vaultRegistry),\n      abi.encodeWithSelector(IVaultRegistry.registerVault.selector, metadata)\n    );\n    if (!success) revert UnderlyingError(returnData);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                    ENDORSEMENT / REJECTION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Set permissions for an array of target. Caller must be owner.\n   * @param targets `AdminProxy`\n   * @param newPermissions An array of permissions to set for the targets.\n   * @dev See `PermissionRegistry` for more details\n   */\n  function setPermissions(address[] calldata targets, Permission[] calldata newPermissions) external onlyOwner {\n    // No need to check matching array length since its already done in the permissionRegistry\n    (bool success, bytes memory returnData) = adminProxy.execute(\n      address(permissionRegistry),\n      abi.encodeWithSelector(IPermissionRegistry.setPermissions.selector, targets, newPermissions)\n    );\n    if (!success) revert UnderlyingError(returnData);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                      STAKING MANAGEMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n  /**\n   * @notice Adds a new rewardToken which can be earned via staking. Caller must be creator of the Vault or owner.\n   * @param vaults Vaults of which the staking contracts should be targeted\n   * @param rewardTokenData Token that can be earned by staking.\n   * @dev `rewardToken` - Token that can be earned by staking.\n   * @dev `rewardsPerSecond` - The rate in which `rewardToken` will be accrued.\n   * @dev `amount` - Initial funding amount for this reward.\n   * @dev `useEscrow Bool` - if the rewards should be escrowed on claim.\n   * @dev `escrowPercentage` - The percentage of the reward that gets escrowed in 1e18. (1e18 = 100%, 1e14 = 1 BPS)\n   * @dev `escrowDuration` - The duration of the escrow.\n   * @dev `offset` - A cliff after claim before the escrow starts.\n   * @dev See `MultiRewardsStaking` for more details.\n   */\n  function addStakingRewardsTokens(address[] memory vaults, bytes[] memory rewardTokenData) public {\n    _verifyEqualArrayLength(vaults.length, rewardTokenData.length);\n    address staking;\n    uint8 len = uint8(vaults.length);\n    for (uint256 i = 0; i < len; i++) {\n      (\n        address rewardsToken,\n        uint160 rewardsPerSecond,\n        uint256 amount,\n        bool useEscrow,\n        uint224 escrowDuration,\n        uint24 escrowPercentage,\n        uint256 offset\n      ) = abi.decode(rewardTokenData[i], (address, uint160, uint256, bool, uint224, uint24, uint256));\n      _verifyToken(rewardsToken);\n      staking = _verifyCreatorOrOwner(vaults[i]).staking;\n\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        rewardsToken,\n        abi.encodeWithSelector(IERC20.approve.selector, staking, type(uint256).max)\n      );\n      if (!success) revert UnderlyingError(returnData);\n\n      IERC20(rewardsToken).approve(staking, type(uint256).max);\n      IERC20(rewardsToken).transferFrom(msg.sender, address(adminProxy), amount);\n\n      (success, returnData) = adminProxy.execute(\n        staking,\n        abi.encodeWithSelector(\n          IMultiRewardStaking.addRewardToken.selector,\n          rewardsToken,\n          rewardsPerSecond,\n          amount,\n          useEscrow,\n          escrowDuration,\n          escrowPercentage,\n          offset\n        )\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /**\n   * @notice Changes rewards speed for a rewardToken. This works only for rewards that accrue over time. Caller must be creator of the Vault.\n   * @param vaults Vaults of which the staking contracts should be targeted\n   * @param rewardTokens Token that can be earned by staking.\n   * @param rewardsSpeeds The rate in which `rewardToken` will be accrued.\n   * @dev See `MultiRewardsStaking` for more details.\n   */\n  function changeStakingRewardsSpeeds(\n    address[] calldata vaults,\n    IERC20[] calldata rewardTokens,\n    uint160[] calldata rewardsSpeeds\n  ) external {\n    uint8 len = uint8(vaults.length);\n\n    _verifyEqualArrayLength(len, rewardTokens.length);\n    _verifyEqualArrayLength(len, rewardsSpeeds.length);\n\n    address staking;\n    for (uint256 i = 0; i < len; i++) {\n      staking = _verifyCreator(vaults[i]).staking;\n\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        staking,\n        abi.encodeWithSelector(IMultiRewardStaking.changeRewardSpeed.selector, rewardTokens[i], rewardsSpeeds[i])\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /**\n   * @notice Funds rewards for a rewardToken.\n   * @param vaults Vaults of which the staking contracts should be targeted\n   * @param rewardTokens Token that can be earned by staking.\n   * @param amounts The amount of rewardToken that will fund this reward.\n   * @dev See `MultiRewardStaking` for more details.\n   */\n  function fundStakingRewards(\n    address[] calldata vaults,\n    IERC20[] calldata rewardTokens,\n    uint256[] calldata amounts\n  ) external {\n    uint8 len = uint8(vaults.length);\n\n    _verifyEqualArrayLength(len, rewardTokens.length);\n    _verifyEqualArrayLength(len, amounts.length);\n\n    address staking;\n    for (uint256 i = 0; i < len; i++) {\n      staking = vaultRegistry.getVault(vaults[i]).staking;\n\n      rewardTokens[i].transferFrom(msg.sender, address(this), amounts[i]);\n      IMultiRewardStaking(staking).fundReward(rewardTokens[i], amounts[i]);\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                      ESCROW MANAGEMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  IMultiRewardEscrow public escrow;\n\n  /**\n   * @notice Set fees for multiple tokens. Caller must be the owner.\n   * @param tokens Array of tokens.\n   * @param fees Array of fees for `tokens` in 1e18. (1e18 = 100%, 1e14 = 1 BPS)\n   * @dev See `MultiRewardEscrow` for more details.\n   */\n  function setEscrowTokenFees(IERC20[] calldata tokens, uint256[] calldata fees) external onlyOwner {\n    _verifyEqualArrayLength(tokens.length, fees.length);\n    (bool success, bytes memory returnData) = adminProxy.execute(\n      address(escrow),\n      abi.encodeWithSelector(IMultiRewardEscrow.setFees.selector, tokens, fees)\n    );\n    if (!success) revert UnderlyingError(returnData);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                          TEMPLATE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Adds a new templateCategory to the registry. Caller must be owner.\n   * @param templateCategories A new category of templates.\n   * @dev See `TemplateRegistry` for more details.\n   */\n  function addTemplateCategories(bytes32[] calldata templateCategories) external onlyOwner {\n    address _deploymentController = address(deploymentController);\n    uint8 len = uint8(templateCategories.length);\n    for (uint256 i = 0; i < len; i++) {\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        _deploymentController,\n        abi.encodeWithSelector(IDeploymentController.addTemplateCategory.selector, templateCategories[i])\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /**\n   * @notice Toggles the endorsement of a templates. Caller must be owner.\n   * @param templateCategories TemplateCategory of the template to endorse.\n   * @param templateIds TemplateId of the template to endorse.\n   * @dev See `TemplateRegistry` for more details.\n   */\n  function toggleTemplateEndorsements(bytes32[] calldata templateCategories, bytes32[] calldata templateIds)\n    external\n    onlyOwner\n  {\n    uint8 len = uint8(templateCategories.length);\n    _verifyEqualArrayLength(len, templateIds.length);\n\n    address _deploymentController = address(deploymentController);\n    for (uint256 i = 0; i < len; i++) {\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        address(_deploymentController),\n        abi.encodeWithSelector(\n          ITemplateRegistry.toggleTemplateEndorsement.selector,\n          templateCategories[i],\n          templateIds[i]\n        )\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                          PAUSING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  /// @notice Pause Deposits and withdraw all funds from the underlying protocol. Caller must be owner or creator of the Vault.\n  function pauseAdapters(address[] calldata vaults) external {\n    uint8 len = uint8(vaults.length);\n    for (uint256 i = 0; i < len; i++) {\n      _verifyCreatorOrOwner(vaults[i]);\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        IVault(vaults[i]).adapter(),\n        abi.encodeWithSelector(IPausable.pause.selector)\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /// @notice Pause deposits. Caller must be owner or creator of the Vault.\n  function pauseVaults(address[] calldata vaults) external {\n    uint8 len = uint8(vaults.length);\n    for (uint256 i = 0; i < len; i++) {\n      _verifyCreatorOrOwner(vaults[i]);\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        vaults[i],\n        abi.encodeWithSelector(IPausable.pause.selector)\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /// @notice Unpause Deposits and deposit all funds into the underlying protocol. Caller must be owner or creator of the Vault.\n  function unpauseAdapters(address[] calldata vaults) external {\n    uint8 len = uint8(vaults.length);\n    for (uint256 i = 0; i < len; i++) {\n      _verifyCreatorOrOwner(vaults[i]);\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        IVault(vaults[i]).adapter(),\n        abi.encodeWithSelector(IPausable.unpause.selector)\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /// @notice Unpause deposits. Caller must be owner or creator of the Vault.\n  function unpauseVaults(address[] calldata vaults) external {\n    uint8 len = uint8(vaults.length);\n    for (uint256 i = 0; i < len; i++) {\n      _verifyCreatorOrOwner(vaults[i]);\n      (bool success, bytes memory returnData) = adminProxy.execute(\n        vaults[i],\n        abi.encodeWithSelector(IPausable.unpause.selector)\n      );\n      if (!success) revert UnderlyingError(returnData);\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                       VERIFICATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n  error NotSubmitterNorOwner(address caller);\n  error NotSubmitter(address caller);\n  error NotAllowed(address subject);\n  error AdapterConfigFaulty();\n  error ArrayLengthMissmatch();\n\n  /// @notice Verify that the caller is the creator of the vault or owner of `VaultController` (admin rights).\n  function _verifyCreatorOrOwner(address vault) internal returns (VaultMetadata memory metadata) {\n    metadata = vaultRegistry.getVault(vault);\n    if (msg.sender != metadata.creator || msg.sender != owner) revert NotSubmitterNorOwner(msg.sender);\n  }\n\n  /// @notice Verify that the caller is the creator of the vault.\n  function _verifyCreator(address vault) internal view returns (VaultMetadata memory metadata) {\n    metadata = vaultRegistry.getVault(vault);\n    if (msg.sender != metadata.creator) revert NotSubmitter(msg.sender);\n  }\n\n  /// @notice Verify that the token is not rejected nor a clone.\n  function _verifyToken(address token) internal view {\n    if (\n      (\n        permissionRegistry.endorsed(address(0))\n          ? !permissionRegistry.endorsed(token)\n          : permissionRegistry.rejected(token)\n      ) ||\n      cloneRegistry.cloneExists(token) ||\n      token == address(0)\n    ) revert NotAllowed(token);\n  }\n\n  /// @notice Verify that the adapter configuration is valid.\n  function _verifyAdapterConfiguration(address adapter, bytes32 adapterId) internal view {\n    if (adapter !="
    }
  ]
}