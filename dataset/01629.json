{
  "Title": "M-18: Position value can fall below the minimum acceptable quote value",
  "Content": "# Issue M-18: Position value can fall below the minimum acceptable quote value \n\nSource: https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/248 \n\n## Found by \n0xcrunch, Ch\\_301, Juntao, berndartmueller, bin2chen, circlelooper, mstpr-brainbot, shaka, volodya, xiaoming90\n## Summary\n\nPartyB can fill a LIMIT order position till the point where the value is below the minimum acceptable quote value (`minAcceptableQuoteValue`). As a result, it breaks the invariant that the value of position must be above the minimum acceptable quote value, leading to various issues and potentially losses for the users.\n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/libraries/LibQuote.sol#L196\n\n```solidity\nFile: LibQuote.sol\n149:     function closeQuote(Quote storage quote, uint256 filledAmount, uint256 closedPrice) internal {\n..SNIP..\n189:         if (quote.closedAmount == quote.quantity) {\n190:             quote.quoteStatus = QuoteStatus.CLOSED;\n191:             quote.requestedClosePrice = 0;\n192:             removeFromOpenPositions(quote.id);\n193:             quoteLayout.partyAPositionsCount[quote.partyA] -= 1;\n194:             quoteLayout.partyBPositionsCount[quote.partyB][quote.partyA] -= 1;\n195:         } else if (\n196:             quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING || quote.quantityToClose == 0\n197:         ) {\n198:             quote.quoteStatus = QuoteStatus.OPENED;\n199:             quote.requestedClosePrice = 0;\n200:             quote.quantityToClose = 0; // for CANCEL_CLOSE_PENDING status\n201:         } else {\n202:             require(\n203:                 quote.lockedValues.total() >=\n204:                     SymbolStorage.layout().symbols[quote.symbolId].minAcceptableQuoteValue,\n205:                 \"LibQuote: Remaining quote value is low\"\n206:             );\n207:         }\n208:     }\n```\n\nIf the user has already sent the close request, but partyB has not filled it yet, the user can request to cancel it by calling the `CancelCloseRequest` function. This will cause the quote's status to change to `QuoteStatus.CANCEL_CLOSE_PENDING`.\n\nPartyB can either accept the cancel request or fill the close request ignoring the user's request. If PartyB decided to go ahead to fill the close request partially, the second branch of the if-else statement at Line 196 will be executed. However, the issue is that within this branch, PartyB is not subjected to the `minAcceptableQuoteValue` validation check. Thus, it is possible for PartyB to fill a LIMIT order position till the point where the value is below the minimum acceptable quote value (`minAcceptableQuoteValue`).\n\n## Impact\n\nIn the codebase, the `minAcceptableQuoteValue` is currently set to 5 USD. There are many reasons for having a minimum quote value in the first place. For instance, if the value of a position is too low, it will be uneconomical for the liquidator to liquidate the position because the liquidation fee would be too small or insufficient to cover the cost of liquidation. Note that the liquidation fee is computed as a percentage of the position value.\n\nThis has a negative impact on the overall efficiency of the liquidation mechanism within the protocol, which could delay or stop the liquidation of accounts or positions, exposing users to greater market risks, including the risk of incurring larger losses or having to exit at an unfavorable price. \n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/libraries/LibQuote.sol#L196\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIf the user sends a close request and PartyB decides to go ahead to fill the close request partially, consider checking if the remaining value of the position is above the minimum acceptable quote value (`minAcceptableQuoteValue`) after PartyB has filled the position.\n\n```diff\nfunction closeQuote(Quote storage quote, uint256 filledAmount, uint256 closedPrice) internal {\n\t..SNIP..\n    if (quote.closedAmount == quote.quantity) {\n        quote.quoteStatus = QuoteStatus.CLOSED;\n        quote.requestedClosePrice = 0;\n        removeFromOpenPositions(quote.id);\n        quoteLayout.partyAPositionsCount[quote.partyA] -= 1;\n        quoteLayout.partyBPositionsCount[quote.partyB][quote.partyA] -= 1;\n    } else if (\n        quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING || quote.quantityToClose == 0\n    ) {\n        quote.quoteStatus = QuoteStatus.OPENED;\n        quote.requestedClosePrice = 0;\n        quote.quantityToClose = 0; // for CANCEL_CLOSE_PENDING status\n+        \n+        require(\n+            quote.lockedValues.total() >=\n+                SymbolStorage.layout().symbols[quote.symbolId].minAcceptableQuoteValue,\n+            \"LibQuote: Remaining quote value is low\"\n+        );\n    } else {\n        require(\n            quote.lockedValues.total() >=\n                SymbolStorage.layout().symbols[quote.symbolId].minAcceptableQuoteValue,\n            \"LibQuote: Remaining quote value is low\"\n        );\n    }\n}\n```\n\n\n\n## Discussion\n\n**MoonKnightDev**\n\nThe lockedValues amount of remaining open portion of the position is already validated in the 'requestToClose' function, so there's no need to check 'minAcceptableQuoteValue' within the 'closeQuote' function.   https://github.com/sherlock-audit/2023-06-symmetrical/blob/6d2b64b6732fcfbd07c8217897dd233dbb6cd1f5/symmio-core/contracts/facets/PartyA/PartyAFacetImpl.sol#L175\n\n**hrishibhat**\n\nConsidering this a non issue based on the above sponsor comments\n\n**shaka0x**\n\n@hrishibhat @MoonKnightDev I do not understand the reasoning. The scenario can be:\n- minAcceptableQuoteValue: 5\n- It is requested to close 100% of the position, so remaining open portion is 0\n- Position is closed partially and we end up with a position of value 3\n\n**xiaoming9090**\n\n> @hrishibhat @MoonKnightDev I do not understand the reasoning. The scenario can be:\n> \n> * minAcceptableQuoteValue: 5\n> * It is requested to close 100% of the position, so remaining open portion is 0\n> * Position is closed partially and we end up with a position of value 3\n\nIf someone requests to close 100% of the position, `quote.closedAmount == quote.quantity`. In this case, the position is closed completely and this [section of the code](https://github.com/sherlock-audit/2023-06-symmetrical/blob/6d2b64b6732fcfbd07c8217897dd233dbb6cd1f5/symmio-core/contracts/libraries/LibQuote.sol#L190) will be executed instead.\n\nThe `minAcceptableQuoteValue` is not relevant for a position that is closed completely.\n\n\n**shaka0x**\n\n> > @hrishibhat @MoonKnightDev I do not understand the reasoning. The scenario can be:\n> > \n> > * minAcceptableQuoteValue: 5\n> > * It is requested to close 100% of the position, so remaining open portion is 0\n> > * Position is closed partially and we end up with a position of value 3\n> \n> If someone requests to close 100% of the position, `quote.closedAmount == quote.quantity`. In this case, the position is closed completely and this [section of the code](https://github.com/sherlock-audit/2023-06-symmetrical/blob/6d2b64b6732fcfbd07c8217897dd233dbb6cd1f5/symmio-core/contracts/libraries/LibQuote.sol#L190) will be executed instead.\n> \n> The `minAcceptableQuoteValue` is not relevant for a position that is closed completely.\n\nI mean passing 100% in `requestToClosePosition`. \n@MoonKnightDev says the check [here](https://github.com/sherlock-audit/2023-06-symmetrical/blob/6d2b64b6732fcfbd07c8217897dd233dbb6cd1f5/symmio-core/contracts/facets/PartyA/PartyAFacetImpl.sol#L175) will prevent the lockedValues amount of remaining open portion of the position be below the `minAcceptableQuoteValue`. If party A requests to close all, there are no remaining open portion, so the check passes.\nNow, in `closeQuote`, party B closes it partially and we do end up with an open position with value below the `minAcceptableQuoteValue`. \n\n**panprog**\n\nAgree with @shaka0x \nGot a working proof of concept [here](https://gist.github.com/panprog/fda806a1ec0d118b5f270d8eb0dca218)\npartyA `requestToClosePosition` -> remainder can't be below minimum\npartyA `requestToClosePosition` -> partyB `fillCloseRequest` (partial) -> remainder can't be below minimum\npartyA `requestToClosePosition` -> partyA `requestToCancelCloseRequest` -> partyB `fillCloseRequest` (partial) -> remainder **CAN** be below minimum\n\n**Navid-Fkh**\n\nFixed code PR link:\nhttps://github.com/SYMM-IO/symmio-core/pull/20\n\n**hrishibhat**\n\nAfter further review based on the points raised by @shaka0x @panprog considering this a valid issue. \nThe same is fixed by the Sponsor. \n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/85",
  "Code": [
    {
      "filename": "symmio-core/contracts/libraries/LibQuote.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"./LibLockedValues.sol\";\nimport \"../storages/QuoteStorage.sol\";\nimport \"../storages/AccountStorage.sol\";\nimport \"../storages/GlobalAppStorage.sol\";\nimport \"../storages/SymbolStorage.sol\";\nimport \"../storages/MAStorage.sol\";\n\nlibrary LibQuote {\n    using LockedValuesOps for LockedValues;\n\n    function getAmountToLockOfQuote(Quote storage quote) internal view returns (uint256) {\n        return quote.lockedValues.total();\n    }\n\n    function quoteOpenAmount(Quote storage quote) internal view returns (uint256) {\n        return quote.quantity - quote.closedAmount;\n    }\n\n    function getIndexOfItem(\n        uint256[] storage array_,\n        uint256 item\n    ) internal view returns (uint256) {\n        for (uint256 index = 0; index < array_.length; index++) {\n            if (array_[index] == item) return index;\n        }\n        return type(uint256).max;\n    }\n\n    function removeFromArray(uint256[] storage array_, uint256 item) internal {\n        uint256 index = getIndexOfItem(array_, item);\n        require(index != type(uint256).max, \"LibQuote: Item not Found\");\n        array_[index] = array_[array_.length - 1];\n        array_.pop();\n    }\n\n    function removeFromPartyAPendingQuotes(Quote storage quote) internal {\n        removeFromArray(QuoteStorage.layout().partyAPendingQuotes[quote.partyA], quote.id);\n    }\n\n    function removeFromPartyBPendingQuotes(Quote storage quote) internal {\n        removeFromArray(\n            QuoteStorage.layout().partyBPendingQuotes[quote.partyB][quote.partyA],\n            quote.id\n        );\n    }\n\n    function removeFromPendingQuotes(Quote storage quote) internal {\n        removeFromPartyAPendingQuotes(quote);\n        removeFromPartyBPendingQuotes(quote);\n    }\n\n    function addToOpenPositions(uint256 quoteId) internal {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        Quote storage quote = quoteLayout.quotes[quoteId];\n\n        quoteLayout.partyAOpenPositions[quote.partyA].push(quote.id);\n        quoteLayout.partyBOpenPositions[quote.partyB][quote.partyA].push(quote.id);\n\n        quoteLayout.partyAPositionsIndex[quote.id] = quoteLayout.partyAPositionsCount[quote.partyA];\n        quoteLayout.partyBPositionsIndex[quote.id] = quoteLayout.partyBPositionsCount[quote.partyB][\n            quote.partyA\n        ];\n\n        quoteLayout.partyAPositionsCount[quote.partyA] += 1;\n        quoteLayout.partyBPositionsCount[quote.partyB][quote.partyA] += 1;\n    }\n\n    function removeFromOpenPositions(uint256 quoteId) internal {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        Quote storage quote = quoteLayout.quotes[quoteId];\n        uint256 indexOfPartyAPosition = quoteLayout.partyAPositionsIndex[quote.id];\n        uint256 indexOfPartyBPosition = quoteLayout.partyBPositionsIndex[quote.id];\n        uint256 lastOpenPositionIndex = quoteLayout.partyAPositionsCount[quote.partyA] - 1;\n        quoteLayout.partyAOpenPositions[quote.partyA][indexOfPartyAPosition] = quoteLayout\n            .partyAOpenPositions[quote.partyA][lastOpenPositionIndex];\n        quoteLayout.partyAPositionsIndex[\n            quoteLayout.partyAOpenPositions[quote.partyA][lastOpenPositionIndex]\n        ] = indexOfPartyAPosition;\n        quoteLayout.partyAOpenPositions[quote.partyA].pop();\n\n        lastOpenPositionIndex = quoteLayout.partyBPositionsCount[quote.partyB][quote.partyA] - 1;\n        quoteLayout.partyBOpenPositions[quote.partyB][quote.partyA][\n            indexOfPartyBPosition\n        ] = quoteLayout.partyBOpenPositions[quote.partyB][quote.partyA][lastOpenPositionIndex];\n        quoteLayout.partyBPositionsIndex[\n            quoteLayout.partyBOpenPositions[quote.partyB][quote.partyA][lastOpenPositionIndex]\n        ] = indexOfPartyBPosition;\n        quoteLayout.partyBOpenPositions[quote.partyB][quote.partyA].pop();\n\n        quoteLayout.partyAPositionsIndex[quote.id] = 0;\n        quoteLayout.partyBPositionsIndex[quote.id] = 0;\n    }\n\n    function getValueOfQuoteForPartyA(\n        uint256 currentPrice,\n        uint256 filledAmount,\n        Quote storage quote\n    ) internal view returns (bool hasMadeProfit, uint256 pnl) {\n        if (currentPrice > quote.openedPrice) {\n            if (quote.positionType == PositionType.LONG) {\n                hasMadeProfit = true;\n            } else {\n                hasMadeProfit = false;\n            }\n            pnl = ((currentPrice - quote.openedPrice) * filledAmount) / 1e18;\n        } else {\n            if (quote.positionType == PositionType.LONG) {\n                hasMadeProfit = false;\n            } else {\n                hasMadeProfit = true;\n            }\n            pnl = ((quote.openedPrice - currentPrice) * filledAmount) / 1e18;\n        }\n    }\n\n    function getTradingFee(uint256 quoteId) internal view returns (uint256 fee) {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        Quote storage quote = quoteLayout.quotes[quoteId];\n        Symbol storage symbol = SymbolStorage.layout().symbols[quote.symbolId];\n        if (quote.orderType == OrderType.LIMIT) {\n            fee =\n                (LibQuote.quoteOpenAmount(quote) * quote.requestedOpenPrice * symbol.tradingFee) /\n                1e36;\n        } else {\n            fee = (LibQuote.quoteOpenAmount(quote) * quote.marketPrice * symbol.tradingFee) / 1e36;\n        }\n    }\n\n    function returnTradingFee(uint256 quoteId) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        uint256 tradingFee = LibQuote.getTradingFee(quoteId);\n        accountLayout.allocatedBalances[QuoteStorage.layout().quotes[quoteId].partyA] += tradingFee;\n        accountLayout.balances[GlobalAppStorage.layout().feeCollector] -= tradingFee;\n    }\n\n    function receiveTradingFee(uint256 quoteId) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        uint256 tradingFee = LibQuote.getTradingFee(quoteId);\n        accountLayout.allocatedBalances[QuoteStorage.layout().quotes[quoteId].partyA] -= tradingFee;\n        accountLayout.balances[GlobalAppStorage.layout().feeCollector] += tradingFee;\n    }\n\n    function closeQuote(Quote storage quote, uint256 filledAmount, uint256 closedPrice) internal {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        quote.modifyTimestamp = block.timestamp;\n\n        LockedValues memory lockedValues = LockedValues(\n            quote.lockedValues.cva -\n                ((quote.lockedValues.cva * filledAmount) / (LibQuote.quoteOpenAmount(quote))),\n            quote.lockedValues.mm -\n                ((quote.lockedValues.mm * filledAmount) / (LibQuote.quoteOpenAmount(quote))),\n            quote.lockedValues.lf -\n                ((quote.lockedValues.lf * filledAmount) / (LibQuote.quoteOpenAmount(quote)))\n        );\n        accountLayout.lockedBalances[quote.partyA].subQuote(quote).add(lockedValues);\n        accountLayout.partyBLockedBalances[quote.partyB][quote.partyA].subQuote(quote).add(\n            lockedValues\n        );\n        quote.lockedValues = lockedValues;\n\n        (bool hasMadeProfit, uint256 pnl) = LibQuote.getValueOfQuoteForPartyA(\n            closedPrice,\n            filledAmount,\n            quote\n        );\n        if (hasMadeProfit) {\n            accountLayout.allocatedBalances[quote.partyA] += pnl;\n            accountLayout.partyBAllocatedBalances[quote.partyB][quote.partyA] -= pnl;\n        } else {\n            accountLayout.allocatedBalances[quote.partyA] -= pnl;\n            accountLayout.partyBAllocatedBalances[quote.partyB][quote.partyA] += pnl;\n        }\n\n        quote.avgClosedPrice =\n            (quote.avgClosedPrice * quote.closedAmount + filledAmount * closedPrice) /\n            (quote.closedAmount + filledAmount);\n\n        quote.closedAmount += filledAmount;\n        quote.quantityToClose -= filledAmount;\n\n        if (quote.closedAmount == quote.quantity) {\n            quote.quoteStatus = QuoteStatus.CLOSED;\n            quote.requestedClosePrice = 0;\n            removeFromOpenPositions(quote.id);\n            quoteLayout.partyAPositionsCount[quote.partyA] -= 1;\n            quoteLayout.partyBPositionsCount[quote.partyB][quote.partyA] -= 1;\n        } else if (\n            quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING || quote.quantityToClose == 0\n        ) {\n            quote.quoteStatus = QuoteStatus.OPENED;\n            quote.requestedClosePrice = 0;\n            quote.quantityToClose = 0; // for CANCEL_CLOSE_PENDING status\n        } else {\n            require(\n                quote.lockedValues.total() >=\n                    SymbolStorage.layout().symbols[quote.symbolId].minAcceptableQuoteValue,\n                \"LibQuote: Remaining quote value is low\"\n            );\n        }\n    }\n\n    function expireQuote(uint256 quoteId) internal returns (QuoteStatus result) {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        Quote storage quote = quoteLayout.quotes[quoteId];\n        require(block.timestamp > quote.deadline, \"LibQuote: Quote isn't expired\");\n        require(\n            quote.quoteStatus == QuoteStatus.PENDING ||\n                quote.quoteStatus == QuoteStatus.CANCEL_PENDING ||\n                quote.quoteStatus == QuoteStatus.LOCKED ||\n                quote.quoteStatus == QuoteStatus.CLOSE_PENDING ||\n                quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING,\n            \"LibQuote: Invalid state\"\n        );\n        require(\n            !MAStorage.layout().liquidationStatus[quote.partyA],\n            \"LibQuote: PartyA isn't solvent\"\n        );\n        require(\n            !MAStorage.layout().partyBLiquidationStatus[quote.partyB][quote.partyA],\n            \"LibQuote: PartyB isn't solvent\"\n        );\n        if (\n            quote.quoteStatus == QuoteStatus.PENDING ||\n            quote.quoteStatus == QuoteStatus.LOCKED ||\n            quote.quoteStatus == QuoteStatus.CANCEL_PENDING\n        ) {\n            quote.modifyTimestamp = block.timestamp;\n            accountLayout.partyANonces[quote.partyA] += 1;\n            accountLayout.pendingLockedBalances[quote.partyA].subQuote(quote);\n            // send trading Fee back to partyA\n            LibQuote.returnTradingFee(quoteId);\n            removeFromPartyAPendingQuotes(quote);\n            if (\n                quote.quoteStatus == QuoteStatus.LOCKED ||\n                quote.quoteStatus == QuoteStatus.CANCEL_PENDING\n            ) {\n                accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n                accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].subQuote(\n                    quote\n                );\n                removeFromPartyBPendingQuotes(quote);\n            }\n            quote.quoteStatus = QuoteStatus.EXPIRED;\n            result = QuoteStatus.EXPIRED;\n        } else if (\n            quote.quoteStatus == QuoteStatus.CLOSE_PENDING ||\n            quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING\n        ) {\n            quote.modifyTimestamp = block.timestamp;\n            accountLayout.partyANonces[quote.partyA] += 1;\n            accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n            quote.requestedClosePrice = 0;\n            quote.quantityToClose = 0;\n            quote.quoteStatus = QuoteStatus.OPENED;\n            result = QuoteStatus.OPENED;\n        }\n    }\n}"
    },
    {
      "filename": "symmio-core/contracts/libraries/LibQuote.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"./LibLockedValues.sol\";\nimport \"../storages/QuoteStorage.sol\";\nimport \"../storages/AccountStorage.sol\";\nimport \"../storages/GlobalAppStorage.sol\";\nimport \"../storages/SymbolStorage.sol\";\nimport \"../storages/MAStorage.sol\";\n\nlibrary LibQuote {\n    using LockedValuesOps for LockedValues;\n\n    function getAmountToLockOfQuote(Quote storage quote) internal view returns (uint256) {\n        return quote.lockedValues.total();\n    }\n\n    function quoteOpenAmount(Quote storage quote) internal view returns (uint256) {\n        return quote.quantity - quote.closedAmount;\n    }\n\n    function getIndexOfItem(\n        uint256[] storage array_,\n        uint256 item\n    ) internal view returns (uint256) {\n        for (uint256 index = 0; index < array_.length; index++) {\n            if (array_[index] == item) return index;\n        }\n        return type(uint256).max;\n    }\n\n    function removeFromArray(uint256[] storage array_, uint256 item) internal {\n        uint256 index = getIndexOfItem(array_, item);\n        require(index != type(uint256).max, \"LibQuote: Item not Found\");\n        array_[index] = array_[array_.length - 1];\n        array_.pop();\n    }\n\n    function removeFromPartyAPendingQuotes(Quote storage quote) internal {\n        removeFromArray(QuoteStorage.layout().partyAPendingQuotes[quote.partyA], quote.id);\n    }\n\n    function removeFromPartyBPendingQuotes(Quote storage quote) internal {\n        removeFromArray(\n            QuoteStorage.layout().partyBPendingQuotes[quote.partyB][quote.partyA],\n            quote.id\n        );\n    }\n\n    function removeFromPendingQuotes(Quote storage quote) internal {\n        removeFromPartyAPendingQuotes(quote);\n        removeFromPartyBPendingQuotes(quote);\n    }\n\n    function addToOpenPositions(uint256 quoteId) internal {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        Quote storage quote = quoteLayout.quotes[quoteId];\n\n        quoteLayout.partyAOpenPositions[quote.partyA].push(quote.id);\n        quoteLayout.partyBOpenPositions[quote.partyB][quote.partyA].push(quote.id);\n\n        quoteLayout.partyAPositionsIndex[quote.id] = quoteLayout.partyAPositionsCount[quote.partyA];\n        quoteLayout.partyBPositionsIndex[quote.id] = quoteLayout.partyBPositionsCount[quote.partyB][\n            quote.partyA\n        ];\n\n        quoteLayout.partyAPositionsCount[quote.partyA] += 1;\n        quoteLayout.partyBPositionsCount[quote.partyB][quote.partyA] += 1;\n    }\n\n    function removeFromOpenPositions(uint256 quoteId) internal {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        Quote storage quote = quoteLayout.quotes[quoteId];\n        uint256 indexOfPartyAPosition = quoteLayout.partyAPositionsIndex[quote.id];\n        uint256 indexOfPartyBPosition = quoteLayout.partyBPositionsIndex[quote.id];\n        uint256 lastOpenPositionIndex = quoteLayout.partyAPositionsCount[quote.partyA] - 1;\n        quoteLayout.partyAOpenPositions[quote.partyA][indexOfPartyAPosition] = quoteLayout\n            .partyAOpenPositions[quote.partyA][lastOpenPositionIndex];\n        quoteLayout.partyAPositionsIndex[\n            quoteLayout.partyAOpenPositions[quote.partyA][lastOpenPositionIndex]\n        ] = indexOfPartyAPosition;\n        quoteLayout.partyAOpenPositions[quote.partyA].pop();\n\n        lastOpenPositionIndex = quoteLayout.partyBPositionsCount[quote.partyB][quote.partyA] - 1;\n        quoteLayout.partyBOpenPositions[quote.partyB][quote.partyA][\n            indexOfPartyBPosition\n        ] = quoteLayout.partyBOpenPositions[quote.partyB][quote.partyA][lastOpenPositionIndex];\n        quoteLayout.partyBPositionsIndex[\n            quoteLayout.partyBOpenPositions[quote.partyB][quote.partyA][lastOpenPositionIndex]\n        ] = indexOfPartyBPosition;\n        quoteLayout.partyBOpenPositions[quote.partyB][quote.partyA].pop();\n\n        quoteLayout.partyAPositionsIndex[quote.id] = 0;\n        quoteLayout.partyBPositionsIndex[quote.id] = 0;\n    }\n\n    function getValueOfQuoteForPartyA(\n        uint256 currentPrice,\n        uint256 filledAmount,\n        Quote storage quote\n    ) internal view returns (bool hasMadeProfit, uint256 pnl) {\n        if (currentPrice > quote.openedPrice) {\n            if (quote.positionType == PositionType.LONG) {\n                hasMadeProfit = true;\n            } else {\n                hasMadeProfit = false;\n            }\n            pnl = ((currentPrice - quote.openedPrice) * filledAmount) / 1e18;\n        } else {\n            if (quote.positionType == PositionType.LONG) {\n                hasMadeProfit = false;\n            } else {\n                hasMadeProfit = true;\n            }\n            pnl = ((quote.openedPrice - currentPrice) * filledAmount) / 1e18;\n        }\n    }\n\n    function getTradingFee(uint256 quoteId) internal view returns (uint256 fee) {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        Quote storage quote = quoteLayout.quotes[quoteId];\n        Symbol storage symbol = SymbolStorage.layout().symbols[quote.symbolId];\n        if (quote.orderType == OrderType.LIMIT) {\n            fee =\n                (LibQuote.quoteOpenAmount(quote) * quote.requestedOpenPrice * symbol.tradingFee) /\n                1e36;\n        } else {\n            fee = (LibQuote.quoteOpenAmount(quote) * quote.marketPrice * symbol.tradingFee) / 1e36;\n        }\n    }\n\n    function returnTradingFee(uint256 quoteId) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        uint256 tradingFee = LibQuote.getTradingFee(quoteId);\n        accountLayout.allocatedBalances[QuoteStorage.layout().quotes[quoteId].partyA] += tradingFee;\n        accountLayout.balances[GlobalAppStorage.layout().feeCollector] -= tradingFee;\n    }\n\n    function receiveTradingFee(uint256 quoteId) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        uint256 tradingFee = LibQuote.getTradingFee(quoteId);\n        accountLayout.allocatedBalances[QuoteStorage.layout().quotes[quoteId].partyA] -= tradingFee;\n        accountLayout.balances[GlobalAppStorage.layout().feeCollector] += tradingFee;\n    }\n\n    function closeQuote(Quote storage quote, uint256 filledAmount, uint256 closedPrice) internal {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        quote.modifyTimestamp = block.timestamp;\n\n        LockedValues memory lockedValues = LockedValues(\n            quote.lockedValues.cva -\n                ((quote.lockedValues.cva * filledAmount) / (LibQuote.quoteOpenAmount(quote))),\n            quote.lockedValues.mm -\n                ((quote.lockedValues.mm * filledAmount) / (LibQuote.quoteOpenAmount(quote))),\n            quote.lockedValues.lf -\n                ((quote.lockedValues.lf * filledAmount) / (LibQuote.quoteOpenAmount(quote)))\n        );\n        accountLayout.lockedBalances[quote.partyA].subQuote(quote).add(lockedValues);\n        accountLayout.partyBLockedBalances[quote.partyB][quote.partyA].subQuote(quote).add(\n            lockedValues\n        );\n        quote.lockedValues = lockedValues;\n\n        (bool hasMadeProfit, uint256 pnl) = LibQuote.getValueOfQuoteForPartyA(\n            closedPrice,\n            filledAmount,\n            quote\n        );\n        if (hasMadeProfit) {\n            accountLayout.allocatedBalances[quote.partyA] += pnl;\n            accountLayout.partyBAllocatedBalances[quote.partyB][quote.partyA] -= pnl;\n        } else {\n            accountLayout.allocatedBalances[quote.partyA] -= pnl;\n            accountLayout.partyBAllocatedBalances[quote.partyB][quote.partyA] += pnl;\n        }\n\n        quote.avgClosedPrice =\n            (quote.avgClosedPrice * quote.closedAmount + filledAmount * closedPrice) /\n            (quote.closedAmount + filledAmount);\n\n        quote.closedAmount += filledAmount;\n        quote.quantityToClose -= filledAmount;\n\n        if (quote.closedAmount == quote.quantity) {\n            quote.quoteStatus = QuoteStatus.CLOSED;\n            quote.requestedClosePrice = 0;\n            removeFromOpenPositions(quote.id);\n            quoteLayout.partyAPositionsCount[quote.partyA] -= 1;\n            quoteLayout.partyBPositionsCount[quote.partyB][quote.partyA] -= 1;\n        } else if (\n            quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING || quote.quantityToClose == 0\n        ) {\n            quote.quoteStatus = QuoteStatus.OPENED;\n            quote.requestedClosePrice = 0;\n            quote.quantityToClose = 0; // for CANCEL_CLOSE_PENDING status\n        } else {\n            require(\n                quote.lockedValues.total() >=\n                    SymbolStorage.layout().symbols[quote.symbolId].minAcceptableQuoteValue,\n                \"LibQuote: Remaining quote value is low\"\n            );\n        }\n    }\n\n    function expireQuote(uint256 quoteId) internal returns (QuoteStatus result) {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        Quote storage quote = quoteLayout.quotes[quoteId];\n        require(block.timestamp > quote.deadline, \"LibQuote: Quote isn't expired\");\n        require(\n            quote.quoteStatus == QuoteStatus.PENDING ||\n                quote.quoteStatus == QuoteStatus.CANCEL_PENDING ||\n                quote.quoteStatus == QuoteStatus.LOCKED ||\n                quote.quoteStatus == QuoteStatus.CLOSE_PENDING ||\n                quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING,\n            \"LibQuote: Invalid state\"\n        );\n        require(\n            !MAStorage.layout().liquidationStatus[quote.partyA],\n            \"LibQuote: PartyA isn't solvent\"\n        );\n        require(\n            !MAStorage.layout().partyBLiquidationStatus[quote.partyB][quote.partyA],\n            \"LibQuote: PartyB isn't solvent\"\n        );\n        if (\n            quote.quoteStatus == QuoteStatus.PENDING ||\n            quote.quoteStatus == QuoteStatus.LOCKED ||\n            quote.quoteStatus == QuoteStatus.CANCEL_PENDING\n        ) {\n            quote.modifyTimestamp = block.timestamp;\n            accountLayout.partyANonces[quote.partyA] += 1;\n            accountLayout.pendingLockedBalances[quote.partyA].subQuote(quote);\n            // send trading Fee back to partyA\n            LibQuote.returnTradingFee(quoteId);\n            removeFromPartyAPendingQuotes(quote);\n            if (\n                quote.quoteStatus == QuoteStatus.LOCKED ||\n                quote.quoteStatus == QuoteStatus.CANCEL_PENDING\n            ) {\n                accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n                accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].subQuote(\n                    quote\n                );\n                removeFromPartyBPendingQuotes(quote);\n            }\n            quote.quoteStatus = QuoteStatus.EXPIRED;\n            result = QuoteStatus.EXPIRED;\n        } else if (\n            quote.quoteStatus == QuoteStatus.CLOSE_PENDING ||\n            quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING\n        ) {\n            quote.modifyTimestamp = block.timestamp;\n            accountLayout.partyANonces[quote.partyA] += 1;\n            accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n            quote.requestedClosePrice = 0;\n            quote.quantityToClose = 0;\n            quote.quoteStatus = QuoteStatus.OPENED;\n            result = QuoteStatus.OPENED;\n        }\n    }\n}"
    },
    {
      "filename": "symmio-core/contracts/facets/PartyA/PartyAFacetImpl.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"../../libraries/LibLockedValues.sol\";\nimport \"../../libraries/LibMuon.sol\";\nimport \"../../libraries/LibAccount.sol\";\nimport \"../../libraries/LibSolvency.sol\";\nimport \"../../libraries/LibQuote.sol\";\nimport \"../../storages/MAStorage.sol\";\nimport \"../../storages/QuoteStorage.sol\";\nimport \"../../storages/MuonStorage.sol\";\nimport \"../../storages/AccountStorage.sol\";\nimport \"../../storages/SymbolStorage.sol\";\n\nlibrary PartyAFacetImpl {\n    using LockedValuesOps for LockedValues;\n\n    function sendQuote(\n        address[] memory partyBsWhiteList,\n        uint256 symbolId,\n        PositionType positionType,\n        OrderType orderType,\n        uint256 price,\n        uint256 quantity,\n        uint256 cva,\n        uint256 mm,\n        uint256 lf,\n        uint256 maxInterestRate,\n        uint256 deadline,\n        SingleUpnlAndPriceSig memory upnlSig\n    ) internal returns (uint256 currentId) {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        SymbolStorage.Layout storage symbolLayout = SymbolStorage.layout();\n\n        require(\n            quoteLayout.partyAPendingQuotes[msg.sender].length < maLayout.pendingQuotesValidLength,\n            \"PartyAFacet: Number of pending quotes out of range\"\n        );\n        require(symbolLayout.symbols[symbolId].isValid, \"PartyAFacet: Symbol is not valid\");\n        require(deadline >= block.timestamp, \"PartyAFacet: Low deadline\");\n\n        LockedValues memory lockedValues = LockedValues(cva, mm, lf);\n        uint256 tradingPrice = orderType == OrderType.LIMIT ? price : upnlSig.price;\n        uint256 notionalValue = (quantity * tradingPrice) / 1e18;\n        require(\n            lockedValues.total() <= notionalValue,\n            \"PartyAFacet: Leverage can't be lower than one\"\n        );\n\n        require(\n            lockedValues.lf >=\n                (symbolLayout.symbols[symbolId].minAcceptablePortionLF * lockedValues.total()) /\n                    1e18,\n            \"PartyAFacet: LF is not enough\"\n        );\n\n        require(\n            lockedValues.total() >= symbolLayout.symbols[symbolId].minAcceptableQuoteValue,\n            \"PartyAFacet: Quote value is low\"\n        );\n        for (uint8 i = 0; i < partyBsWhiteList.length; i++) {\n            require(\n                partyBsWhiteList[i] != msg.sender,\n                \"PartyAFacet: Sender isn't allowed in partyBWhiteList\"\n            );\n        }\n\n        LibMuon.verifyPartyAUpnlAndPrice(upnlSig, msg.sender, symbolId);\n\n        int256 availableBalance = LibAccount.partyAAvailableForQuote(upnlSig.upnl, msg.sender);\n        require(availableBalance > 0, \"PartyAFacet: Available balance is lower than zero\");\n        require(\n            uint256(availableBalance) >=\n                lockedValues.total() +\n                    ((quantity * tradingPrice * symbolLayout.symbols[symbolId].tradingFee) / 1e36),\n            \"PartyAFacet: insufficient available balance\"\n        );\n\n        // lock funds the in middle of way\n        accountLayout.pendingLockedBalances[msg.sender].add(lockedValues);\n        currentId = ++quoteLayout.lastId;\n        accountLayout.partyANonces[msg.sender] += 1;\n\n        // create quote.\n        Quote memory quote = Quote({\n            id: currentId,\n            partyBsWhiteList: partyBsWhiteList,\n            symbolId: symbolId,\n            positionType: positionType,\n            orderType: orderType,\n            openedPrice: 0,\n            requestedOpenPrice: price,\n            marketPrice: upnlSig.price,\n            quantity: quantity,\n            closedAmount: 0,\n            lockedValues: lockedValues,\n            initialLockedValues: lockedValues,\n            maxInterestRate: maxInterestRate,\n            partyA: msg.sender,\n            partyB: address(0),\n            quoteStatus: QuoteStatus.PENDING,\n            avgClosedPrice: 0,\n            requestedClosePrice: 0,\n            parentId: 0,\n            createTimestamp: block.timestamp,\n            modifyTimestamp: block.timestamp,\n            quantityToClose: 0,\n            deadline: deadline\n        });\n        quoteLayout.quoteIdsOf[msg.sender].push(currentId);\n        quoteLayout.partyAPendingQuotes[msg.sender].push(currentId);\n        quoteLayout.quotes[currentId] = quote;\n\n        LibQuote.receiveTradingFee(currentId);\n    }\n\n    function requestToCancelQuote(uint256 quoteId) internal returns (QuoteStatus result) {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        require(\n            quote.quoteStatus == QuoteStatus.PENDING || quote.quoteStatus == QuoteStatus.LOCKED,\n            \"PartyAFacet: Invalid state\"\n        );\n        accountLayout.partyANonces[quote.partyA] += 1;\n\n        if (block.timestamp > quote.deadline) {\n            result = LibQuote.expireQuote(quoteId);\n        } else if (quote.quoteStatus == QuoteStatus.PENDING) {\n            quote.quoteStatus = QuoteStatus.CANCELED;\n            LibQuote.returnTradingFee(quoteId);\n            accountLayout.pendingLockedBalances[quote.partyA].subQuote(quote);\n            LibQuote.removeFromPartyAPendingQuotes(quote);\n            result = QuoteStatus.CANCELED;\n        } else {\n            // Quote is locked\n            quote.quoteStatus = QuoteStatus.CANCEL_PENDING;\n            result = QuoteStatus.CANCEL_PENDING;\n        }\n        quote.modifyTimestamp = block.timestamp;\n    }\n\n    function requestToClosePosition(\n        uint256 quoteId,\n        uint256 closePrice,\n        uint256 quantityToClose,\n        OrderType orderType,\n        uint256 deadline,\n        SingleUpnlAndPriceSig memory upnlSig\n    ) internal {\n        SymbolStorage.Layout storage symbolLayout = SymbolStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        require(quote.quoteStatus == QuoteStatus.OPENED, \"PartyAFacet: Invalid state\");\n        require(deadline >= block.timestamp, \"PartyAFacet: Low deadline\");\n        require(\n            LibQuote.quoteOpenAmount(quote) >= quantityToClose,\n            \"PartyAFacet: Invalid quantityToClose\"\n        );\n        LibMuon.verifyPartyAUpnlAndPrice(upnlSig, quote.partyA, quote.symbolId);\n        LibSolvency.isSolventAfterRequestToClosePosition(\n            quoteId,\n            closePrice,\n            quantityToClose,\n            upnlSig\n        );\n\n        // check that remaining position is not too small\n        if (LibQuote.quoteOpenAmount(quote) > quantityToClose) {\n            require(\n                ((LibQuote.quoteOpenAmount(quote) - quantityToClose) * quote.lockedValues.total()) /\n                    LibQuote.quoteOpenAmount(quote) >=\n                    symbolLayout.symbols[quote.symbolId].minAcceptableQuoteValue,\n                \"PartyAFacet: Remaining quote value is low\"\n            );\n        }\n\n        accountLayout.partyANonces[quote.partyA] += 1;\n        quote.modifyTimestamp = block.timestamp;\n        quote.quoteStatus = QuoteStatus.CLOSE_PENDING;\n        quote.requestedClosePrice = closePrice;\n        quote.quantityToClose = quantityToClose;\n        quote.orderType = orderType;\n        quote.deadline = deadline;\n    }\n\n    function requestToCancelCloseRequest(uint256 quoteId) internal returns (QuoteStatus) {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        require(quote.quoteStatus == QuoteStatus.CLOSE_PENDING, \"PartyAFacet: Invalid state\");\n        if (block.timestamp > quote.deadline) {\n            LibQuote.expireQuote(quoteId);\n            return QuoteStatus.OPENED;\n        } else {\n            accountLayout.partyANonces[quote.partyA] += 1;\n            quote.modifyTimestamp = block.timestamp;\n            quote.quoteStatus = QuoteStatus.CANCEL_CLOSE_PENDING;\n            return QuoteStatus.CANCEL_CLOSE_PENDING;\n        }\n    }\n\n    function forceCancelQuote(uint256 quoteId) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        require(quote.quoteStatus == QuoteStatus.CANCEL_PENDING, \"PartyAFacet: Invalid state\");\n        require(\n            block.timestamp > quote.modifyTimestamp + maLayout.forceCancelCooldown,\n            \"PartyAFacet: Cooldown not reached\"\n        );\n        accountLayout.partyANonces[quote.partyA] += 1;\n        accountLayout.partyBNonces[quote.partyB][quote.p"
    }
  ]
}