{
  "Title": "[L-03] Unused imports in several files",
  "Content": "Several files in scope include unused import statements. These unnecessary imports can lead to confusion, increase the contract's bytecode size unnecessarily, and impact gas costs for deployment.\n\nThe following imports are unused and can be removed:\n[Factory.sol#L14](https://github.com/perspectivefi/spectra-core/blob/fec59dc6720fb4861b07b30845ef2c1a42f947bf/src/factory/Factory.sol#L14)  \n[RouterUtil.sol#L8](https://github.com/perspectivefi/spectra-core/blob/fec59dc6720fb4861b07b30845ef2c1a42f947bf/src/router/util/RouterUtil.sol#L8)  \n[RouterUtil.sol#L12-L14](https://github.com/perspectivefi/spectra-core/blob/fec59dc6720fb4861b07b30845ef2c1a42f947bf/src/router/util/RouterUtil.sol#L12-L14)  \n[RouterUtil.sol#L16](https://github.com/perspectivefi/spectra-core/blob/fec59dc6720fb4861b07b30845ef2c1a42f947bf/src/router/util/RouterUtil.sol#L16)  \n[CurvePoolUtil.sol#L5](https://github.com/perspectivefi/spectra-core/blob/fec59dc6720fb4861b07b30845ef2c1a42f947bf/src/libraries/CurvePoolUtil.sol#L5)",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/factory/Factory.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.20;\n\nimport \"openzeppelin-math/Math.sol\";\nimport \"../libraries/CurvePoolUtil.sol\";\nimport \"../interfaces/IFactory.sol\";\nimport \"../interfaces/ICurvePool.sol\";\nimport \"../interfaces/ICurveFactory.sol\";\nimport \"../interfaces/IPrincipalToken.sol\";\nimport \"../interfaces/IRegistry.sol\";\nimport \"../libraries/Roles.sol\";\nimport \"openzeppelin-contracts/access/manager/IAccessManager.sol\";\nimport \"openzeppelin-contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport \"openzeppelin-contracts-upgradeable/access/manager/AccessManagedUpgradeable.sol\";\nimport \"openzeppelin-contracts/proxy/beacon/BeaconProxy.sol\";\nimport \"openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\";\n\ncontract Factory is IFactory, AccessManagedUpgradeable {\n    using SafeERC20 for IERC20;\n    using Math for uint256;\n\n    bytes4 constant PAUSE_SELECTOR = IPrincipalToken(address(0)).pause.selector;\n    bytes4 constant UNPAUSE_SELECTOR = IPrincipalToken(address(0)).unPause.selector;\n    bytes4 constant SET_REWARDS_PROXY_SELECTOR =\n        IPrincipalToken(address(0)).setRewardsProxy.selector;\n    bytes4 constant CLAIM_REWARDS_SELECTOR = IPrincipalToken(address(0)).claimRewards.selector;\n    /* State\n     *****************************************************************************************************************/\n\n    address private registry;\n    address private curveAddressProvider;\n    address private curveFactory;\n\n    /* Events\n     *****************************************************************************************************************/\n\n    event PTDeployed(address indexed pt, address indexed poolCreator);\n    event CurvePoolDeployed(address indexed poolAddress, address indexed ibt, address indexed pt);\n    event RegistryChange(address indexed previousRegistry, address indexed newRegistry);\n    event CurveFactoryChange(address indexed previousFactory, address indexed newFactory);\n    event CurveAddressProviderChange(\n        address indexed previousCurveAddressProvider,\n        address indexed newCurveAddressProvider\n    );\n\n    /**\n     * @notice Constructor of the contract\n     */\n    constructor() {\n        _disableInitializers(); // using this so that the deployed logic contract later cannot be initialized.\n    }\n\n    /**\n     * @notice Initializer of the contract\n     * @param _registry The address of the registry.\n     * @param _initialAuthority The address of the access manager.\n     */\n    function initialize(address _registry, address _initialAuthority) external initializer {\n        __AccessManaged_init(_initialAuthority);\n        setRegistry(_registry);\n    }\n\n    /** @dev See {IFactory-deployPT}. */\n    function deployPT(address _ibt, uint256 _duration) public override returns (address pt) {\n        address ptBeacon = IRegistry(registry).getPTBeacon();\n        if (ptBeacon == address(0)) {\n            revert BeaconNotSet();\n        }\n\n        address accessManager = authority();\n        bytes memory _data = abi.encodeWithSelector(\n            IPrincipalToken(address(0)).initialize.selector,\n            _ibt,\n            _duration,\n            accessManager\n        );\n        pt = address(new BeaconProxy(ptBeacon, _data));\n        emit PTDeployed(pt, msg.sender);\n        IRegistry(registry).addPT(pt);\n\n        IAccessManager(accessManager).setTargetFunctionRole(pt, getPauserSigs(), Roles.PAUSER_ROLE);\n        IAccessManager(accessManager).setTargetFunctionRole(\n            pt,\n            getClaimRewardsProxySelectors(),\n            Roles.REWARDS_HARVESTER_ROLE\n        );\n        IAccessManager(accessManager).setTargetFunctionRole(\n            pt,\n            getSetRewardsProxySelectors(),\n            Roles.REWARDS_PROXY_SETTER_ROLE\n        );\n    }\n\n    /** @dev See {IFactory-deployCurvePool}. */\n    function deployCurvePool(\n        address _pt,\n        CurvePoolParams calldata _curvePoolParams,\n        uint256 _initialLiquidityInIBT\n    ) public returns (address curvePool) {\n        if (curveFactory == address(0)) {\n            revert CurveFactoryNotSet();\n        }\n        if (!IRegistry(registry).isRegisteredPT(_pt)) {\n            revert UnregisteredPT();\n        }\n        if (IPrincipalToken(_pt).maturity() < block.timestamp) {\n            revert ExpiredPT();\n        }\n        address ibt = IPrincipalToken(_pt).getIBT();\n        address[2] memory coins;\n        {\n            coins[0] = ibt;\n            coins[1] = _pt;\n        }\n        curvePool = _deployCurvePool(coins, _curvePoolParams);\n        emit CurvePoolDeployed(curvePool, ibt, _pt);\n\n        if (_initialLiquidityInIBT != 0) {\n            _addInitialLiquidity(curvePool, _initialLiquidityInIBT, _curvePoolParams.initial_price);\n        }\n    }\n\n    /** @dev See {IFactory-deployAll}. */\n    function deployAll(\n        address _ibt,\n        uint256 _duration,\n        CurvePoolParams calldata _curvePoolParams,\n        uint256 _initialLiquidityInIBT\n    ) public returns (address pt, address curvePool) {\n        // deploy PT\n        address ptBeacon = IRegistry(registry).getPTBeacon();\n        if (ptBeacon == address(0)) {\n            revert BeaconNotSet();\n        }\n        address accessManager = authority();\n        bytes memory _encodedData = abi.encodeWithSelector(\n            IPrincipalToken(address(0)).initialize.selector,\n            _ibt,\n            _duration,\n            accessManager\n        );\n        pt = address(new BeaconProxy(ptBeacon, _encodedData));\n        emit PTDeployed(pt, msg.sender);\n        IRegistry(registry).addPT(pt);\n        IAccessManager(accessManager).setTargetFunctionRole(pt, getPauserSigs(), Roles.PAUSER_ROLE);\n\n        // deploy Curve Pool\n        if (curveFactory == address(0)) {\n            revert CurveFactoryNotSet();\n        }\n        address[2] memory coins;\n        {\n            coins[0] = _ibt;\n            coins[1] = pt;\n        }\n        curvePool = _deployCurvePool(coins, _curvePoolParams);\n        emit CurvePoolDeployed(curvePool, _ibt, pt);\n\n        if (_initialLiquidityInIBT != 0) {\n            _addInitialLiquidity(curvePool, _initialLiquidityInIBT, _curvePoolParams.initial_price);\n        }\n    }\n\n    /* GETTERS\n     *****************************************************************************************************************/\n\n    /** @dev See {IFactory-getRegistry}. */\n    function getRegistry() external view override returns (address) {\n        return registry;\n    }\n\n    /** @dev See {IFactory-getCurveAddressProvider}. */\n    function getCurveAddressProvider() external view override returns (address) {\n        return curveAddressProvider;\n    }\n\n    /** @dev See {IFactory-getCurveFactory}. */\n    function getCurveFactory() external view override returns (address) {\n        return curveFactory;\n    }\n\n    /**\n     * @notice Getter for pause and unpause selectors, used for access management\n     */\n    function getPauserSigs() internal pure returns (bytes4[] memory) {\n        bytes4[] memory selectors = new bytes4[](2);\n        selectors[0] = PAUSE_SELECTOR;\n        selectors[1] = UNPAUSE_SELECTOR;\n        return selectors;\n    }\n\n    /**\n     * @notice Getter for the reward proxy setter selector, used for access management\n     */\n    function getSetRewardsProxySelectors() internal pure returns (bytes4[] memory) {\n        bytes4[] memory selectors = new bytes4[](1);\n        selectors[0] = SET_REWARDS_PROXY_SELECTOR;\n        return selectors;\n    }\n\n    /**\n     * @notice Getter for the claim rewards selector, used for access management\n     */\n    function getClaimRewardsProxySelectors() internal pure returns (bytes4[] memory) {\n        bytes4[] memory selectors = new bytes4[](1);\n        selectors[0] = CLAIM_REWARDS_SELECTOR;\n        return selectors;\n    }\n\n    /* SETTERS\n     *****************************************************************************************************************/\n\n    /** @dev See {IFactory-setCurveAddressProvider}. */\n    function setCurveAddressProvider(address _curveAddressProvider) external override restricted {\n        if (_curveAddressProvider == address(0)) {\n            revert AddressError();\n        }\n        emit CurveAddressProviderChange(curveAddressProvider, _curveAddressProvider);\n        curveAddressProvider = _curveAddressProvider;\n        _setCurveFactory();\n    }\n\n    /** @dev See {IFactory-setRegistry}. */\n    function setRegistry(address _newRegistry) public override restricted {\n        if (_newRegistry == address(0)) {\n            revert AddressError();\n        }\n        emit RegistryChange(registry, _newRegistry);\n        registry = _newRegistry;\n    }\n\n    /**\n     * @dev Splits the given IBT amount into IBT and PT based on pool initial price, and adds liquidity to the pool.\n     * @param _curvePool The address of the Curve Pool in which the user adds initial liquidity to\n     * @param _initialLiquidityInIBT The initial liquidity to seed the Curve Pool with (in IBT)\n     * @param _initialPrice The initial price of the Curve Pool\n     */\n    function _addInitialLiquidity(\n        address _curvePool,\n        uint256 _initialLiquidityInIBT,\n        uint256 _initialPrice\n    ) internal {\n        address ibt = ICurvePool(_curvePool).coins(0);\n        address pt = ICurvePool(_curvePool).coins(1);\n\n        IERC20(ibt).safeTransferFrom(msg.sender, address(this), _initialLiquidityInIBT);\n\n        // using fictive pool balances, the user is adding liquidity in a ratio that (closely) matches the empty pool's initial price\n        // with ptBalance = IBT_UNIT for having a fictive PT balance reference, ibtBalance = IBT_UNIT x initialPrice\n        uint256 ptBalance = 10 ** IERC20Metadata(ibt).decimals();\n        uint256 ibtBalance = ptBalance.mulDiv(_initialPrice, 10 ** CurvePoolUtil.CURVE_DECIMALS);\n        // compute the worth of the fictive IBT balance in the pool in PT\n        uint256 ibtBalanceInPT = IPrincipalToken(pt).previewDepositIBT(ibtBalance);\n        // compute the portion of IBT to deposit in PT\n        uint256 ibtsToTokenize = _initialLiquidityInIBT.mulDiv(\n            ptBalance,\n            ibtBalanceInPT + ptBalance\n        );\n\n        // IBT amount to deposit in the Curve Pool\n        uint256 amount0 = _initialLiquidityInIBT - ibtsToTokenize;\n        uint256 allowancePT = IERC20(ibt).allowance(address(this), pt);\n        if (allowancePT < ibtsToTokenize) {\n            IERC20(ibt).safeIncreaseAllowance(pt, type(uint256).max - allowancePT);\n        }\n        // PT amount to deposit in Curve Pool\n        uint256 amount1;\n        if (IPrincipalToken(pt).previewDepositIBT(ibtsToTokenize) != 0) {\n            amount1 = IPrincipalToken(pt).depositIBT(ibtsToTokenize, address(this), msg.sender);\n        }\n\n        IERC20(ibt).safeIncreaseAllowance(_curvePool, amount0);\n        IERC20(pt).safeIncreaseAllowance(_curvePool, amount1);\n        ICurvePool(_curvePool).add_liquidity([amount0, amount1], 0, false, msg.sender);\n    }\n\n    /**\n     * @dev Sets the curve factory address used for deploying the curve pool. Can only be called by owner.\n     */\n    function _setCurveFactory() internal {\n        // keccack's first 4 bytes of getter get_address(uint256) of curveAddressProvider is 0x493f4f74\n        // currently curve factory address is stored at index 6 on MAINNET.\n        uint256 index = 6;\n        (bool success, bytes memory responseData) = curveAddressProvider.call(\n            abi.encodeWithSelector(0x493f4f74, index)\n        );\n        if (!(success)) {\n            revert FailedToFetchCurveFactoryAddress();\n        }\n        address newCurveFactory = abi.decode(responseData, (address));\n        emit CurveFactoryChange(curveFactory, newCurveFactory);\n        curveFactory = newCurveFactory;\n    }\n\n    /**\n     * @dev Calls the Curve factory and deploys a new Curve v2 crypto pool\n     */\n    function _deployCurvePool(\n        address[2] memory _coins,\n        CurvePoolParams calldata _p\n    ) internal returns (address curvePoolAddr) {\n        bytes memory name = bytes(\"Spectra-PT/IBT\");\n        bytes memory symbol = bytes(\"SPT-PT/IBT\");\n        bytes memory cd = new bytes(576); // calldata to the curve factory\n        address coin0 = _coins[0];\n        address coin1 = _coins[1];\n        uint256 num; // temporary variable for passing contents of _p to Yul\n        // append the coins array\n        assembly {\n            mstore(\n                add(cd, 0x20),\n                0x00000000000000000000000000000000000000000000000000000000000001c0\n            )\n            mstore(\n                add(cd, 0x40),\n                0x0000000000000000000000000000000000000000000000000000000000000200\n            )\n            mstore(add(cd, 0x60), coin0)\n            mstore(add(cd, 0x80), coin1)\n        }\n\n        // append the numerical parameters\n        num = _p.A;\n        assembly {\n            mstore(add(cd, 0xa0), num)\n        }\n        num = _p.gamma;\n        assembly {\n            mstore(add(cd, 0xc0), num)\n        }\n        num = _p.mid_fee;\n        assembly {\n            mstore(add(cd, 0xe0), num)\n        }\n        num = _p.out_fee;\n        assembly {\n            mstore(add(cd, 0x100), num)\n        }\n        num = _p.allowed_extra_profit;\n        assembly {\n            mstore(add(cd, 0x120), num)\n        }\n        num = _p.fee_gamma;\n        assembly {\n            mstore(add(cd, 0x140), num)\n        }\n        num = _p.adjustment_step;\n        assembly {\n            mstore(add(cd, 0x160), num)\n        }\n        num = _p.admin_fee;\n        assembly {\n            mstore(add(cd, 0x180), num)\n        }\n        num = _p.ma_half_time;\n        assembly {\n            mstore(add(cd, 0x1a0), num)\n        }\n        num = _p.initial_price;\n\n        assembly {\n            mstore(add(cd, 0x1c0), num)\n\n            mstore(add(cd, 0x1e0), mload(name))\n            mstore(add(cd, 0x200), mload(add(name, 0x20)))\n\n            mstore(add(cd, 0x220), mload(symbol))\n            mstore(add(cd, 0x240), mload(add(symbol, 0x20)))\n        }\n\n        // prepend the function selector\n        cd = bytes.concat(ICurveFactory(address(0)).deploy_pool.selector, cd);\n\n        // make the call to the curve factory\n        (bool success, bytes memory result) = address(curveFactory).call(cd);\n        if (!success) {\n            revert DeploymentFailed();\n        }\n\n        assembly {\n            curvePoolAddr := mload(add(add(result, 12), 20))\n        }\n    }\n}"
    },
    {
      "filename": "src/router/util/RouterUtil.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.20;\n\nimport \"openzeppelin-math/Math.sol\";\nimport \"openzeppelin-contracts/utils/math/SafeCast.sol\";\nimport \"../../libraries/CurvePoolUtil.sol\";\nimport {IERC20} from \"openzeppelin-contracts/interfaces/IERC20.sol\";\nimport {IERC20Metadata} from \"openzeppelin-contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {IERC4626} from \"openzeppelin-contracts/interfaces/IERC4626.sol\";\nimport {IERC3156FlashLender} from \"openzeppelin-contracts/interfaces/IERC3156FlashLender.sol\";\nimport {SafeERC20} from \"openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Ownable2StepUpgradeable} from \"openzeppelin-contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport {Dispatcher} from \"../Dispatcher.sol\";\nimport {Constants} from \"../Constants.sol\";\nimport {IRouter} from \"../../interfaces/IRouter.sol\";\nimport {IPrincipalToken} from \"../../interfaces/IPrincipalToken.sol\";\nimport {ICurvePool} from \"../../interfaces/ICurvePool.sol\";\n\ncontract RouterUtil {\n    using Math for uint256;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    error InvalidTokenIndex(uint256 i, uint256 j);\n\n    /**\n     * @dev Gives the spot exchange rate of token i in terms of token j. Exchange rate is in 18 decimals\n     * @param _curvePool PT/IBT curve pool\n     * @param _i token index, either 0 or 1\n     * @param _j token index, either 0 or 1, must be different than _i\n     * @return The spot exchange rate of _i in terms of _j\n     */\n    function spotExchangeRate(\n        address _curvePool,\n        uint256 _i,\n        uint256 _j\n    ) public view returns (uint256) {\n        if (_i == 0 && _j == 1) {\n            return Constants.UNIT.mulDiv(Constants.UNIT, ICurvePool(_curvePool).last_prices());\n        } else if (_i == 1 && _j == 0) {\n            return ICurvePool(_curvePool).last_prices();\n        } else {\n            revert InvalidTokenIndex(_i, _j);\n        }\n    }\n\n    /**\n     * @dev Returns the maximal amount of YT one can obtain with a given amount of IBT (i.e without fees or slippage).\n     * @dev Gives the upper bound of the interval to perform bisection search in previewFlashSwapExactIBTForYT().\n     * @param _inputIBTAmount amount of IBT exchanged for YT\n     * @param _curvePool PT/IBT curve pool\n     * @return The upper bound for search interval in root finding algorithms\n     */\n    function convertIBTToYTSpot(\n        uint256 _inputIBTAmount,\n        address _curvePool\n    ) public view returns (uint256) {\n        // The spot exchange rate between IBT and YT is evaluated using the tokenization equation without fees.\n        // This equation reads: ptRate * IBT / ibtRate = 1 PT + 1 YT .\n\n        address pt = ICurvePool(_curvePool).coins(1);\n\n        uint256 ibtRate = IPrincipalToken(pt).getIBTRate(); // asset decimals\n        uint256 ptRate = IPrincipalToken(pt).getPTRate(); // asset decimals\n\n        uint256 assetUnit = getUnderlyingUnit(pt); // asset decimals\n        uint256 assetUnitAdjusted = assetUnit.mulDiv(ptRate, assetUnit); // asset decimals\n\n        uint256 ptInUnderlying = spotExchangeRate(_curvePool, 1, 0).mulDiv(ibtRate, Constants.UNIT);\n        uint256 ytInUnderlying = assetUnitAdjusted - ptInUnderlying;\n\n        return _inputIBTAmount.mulDiv(ibtRate, ytInUnderlying); // ibt decimals\n    }\n\n    /**\n     * @dev Given an output amountof YT desired, yields the amount of IBT required to get this amount\n     * @param _curvePool PT/IBT curve pool\n     * @param _outputYTAmount desired output YT token amount\n     * @return inputIBTAmount The amount of IBT needed for obtaining the defined amount of YT\n     * @return borrowedIBTAmount the quantity of IBT borrowed to execute that swap\n     */\n    function previewFlashSwapIBTToExactYT(\n        address _curvePool,\n        uint256 _outputYTAmount\n    ) public view returns (uint256 inputIBTAmount, uint256 borrowedIBTAmount) {\n        // Tokens\n        address pt = ICurvePool(_curvePool).coins(1);\n        address ibt = IPrincipalToken(pt).getIBT();\n\n        // Units and rates\n        uint256 ibtRate = IPrincipalToken(pt).getIBTRate(); // 27 decimals\n        uint256 ptRate = IPrincipalToken(pt).getPTRate(); // 27 decimals\n\n        // Outputs\n        uint256 swapPTForIBT = ICurvePool(_curvePool).get_dy(1, 0, _outputYTAmount);\n\n        // y PT:YT = (x IBT * ((UNIT - tokenizationFee) / UNIT) * ibtRate) / ptRate\n        // <=> x IBT = (y PT:YT * ptRate * UNIT) / (ibtRate * (UNIT - tokenizationFee))\n        borrowedIBTAmount = (_outputYTAmount * ptRate * Constants.UNIT).ceilDiv(\n            ibtRate * (Constants.UNIT - IPrincipalToken(pt).getTokenizationFee())\n        );\n\n        inputIBTAmount =\n            borrowedIBTAmount +\n            _getFlashFee(pt, ibt, borrowedIBTAmount) -\n            swapPTForIBT;\n    }\n\n    /**\n     * @dev Given an input IBT amount, previews the expected amount of YT obtained after executing the swap\n     * @param _curvePool PT/IBT curve pool\n     * @param _inputIBTAmount amount of IBT exchanged for YT\n     * @return The max guess of YT obtained for the given amount of IBT\n     * @return The min guess of YT obtained for the given amount of IBT\n     * @return The quantity of IBT borrowed to execute that swap.\n     */\n    function previewFlashSwapExactIBTToYT(\n        address _curvePool,\n        uint256 _inputIBTAmount\n    ) public view returns (uint256, uint256, uint256) {\n        int256 x0 = _inputIBTAmount.toInt256();\n        int256 x1 = convertIBTToYTSpot(_inputIBTAmount, _curvePool).toInt256();\n        int256 x2;\n\n        //x2 = x1 - f(x1) * (x1 - x0) / (f(x1) - f(x0))\n        // x0, x1 = x1, x2\n\n        for (uint256 i = 0; i < Constants.MAX_ITERATIONS_SECANT; ++i) {\n            if (_delta(x0.toUint256(), x1.toUint256()) < Constants.PRECISION) {\n                break;\n            }\n\n            (uint256 inputIBTAmount0, ) = previewFlashSwapIBTToExactYT(_curvePool, x0.toUint256());\n\n            (uint256 inputIBTAmount1, ) = previewFlashSwapIBTToExactYT(_curvePool, x1.toUint256());\n\n            int256 answer0 = inputIBTAmount0.toInt256() - _inputIBTAmount.toInt256();\n            int256 answer1 = inputIBTAmount1.toInt256() - _inputIBTAmount.toInt256();\n\n            if (answer0 == answer1) {\n                break;\n            }\n\n            x2 = x1 - (answer1 * (x1 - x0)) / (answer1 - answer0);\n\n            x0 = x1;\n            x1 = x2;\n        }\n        (, uint256 borrowedIBTAmount) = previewFlashSwapIBTToExactYT(_curvePool, x2.toUint256());\n\n        uint256 minGuess;\n        uint256 maxGuess;\n\n        if (x2.toUint256() >= x1.toUint256()) {\n            maxGuess = x2.toUint256();\n            minGuess = x1.toUint256();\n        } else {\n            maxGuess = x1.toUint256();\n            minGuess = x2.toUint256();\n        }\n\n        return (maxGuess, minGuess, borrowedIBTAmount);\n    }\n\n    /**\n     * @dev Given an amount of YT, previews the amount of IBT received after exchange\n     * @param _curvePool PT/IBT curve pool\n     * @param inputYTAmount amount of YT exchanged for IBT\n     * @return The amount of IBT obtained for the given amount of YT\n     * @return The amount of IBT borrowed to execute that swap.\n     */\n    function previewFlashSwapExactYTToIBT(\n        address _curvePool,\n        uint256 inputYTAmount\n    ) public view returns (uint256, uint256) {\n        // Tokens\n        address pt = ICurvePool(_curvePool).coins(1);\n        address ibt = IPrincipalToken(pt).getIBT();\n        // Units and Rates\n        uint256 ibtRate = IPrincipalToken(pt).getIBTRate();\n        uint256 ptRate = IPrincipalToken(pt).getPTRate();\n        // Outputs\n        uint256 borrowedIBTAmount = CurvePoolUtil.getDx(_curvePool, 0, 1, inputYTAmount);\n        uint256 outputIBTAmount = inputYTAmount.mulDiv(ptRate, ibtRate) -\n            borrowedIBTAmount -\n            _getFlashFee(pt, ibt, borrowedIBTAmount);\n\n        return (outputIBTAmount, borrowedIBTAmount);\n    }\n\n    function previewAddLiquidityWithAsset(\n        address _curvePool,\n        uint256 _assets\n    ) public view returns (uint256 minMintAmount) {\n        address ibt = ICurvePool(_curvePool).coins(0);\n        uint256 ibts = IERC4626(ibt).previewDeposit(_assets);\n        minMintAmount = previewAddLiquidityWithIBT(_curvePool, ibts);\n    }\n\n    function previewAddLiquidityWithIBT(\n        address _curvePool,\n        uint256 _ibts\n    ) public view returns (uint256 minMintAmount) {\n        address pt = ICurvePool(_curvePool).coins(1);\n        uint256 ibtToDepositInPT = CurvePoolUtil.calcIBTsToTokenizeForCurvePool(\n            _ibts,\n            _curvePool,\n            pt\n        );\n        uint256 amount0 = _ibts - ibtToDepositInPT;\n        uint256 amount1 = IPrincipalToken(pt).previewDepositIBT(ibtToDepositInPT);\n        minMintAmount = previewAddLiquidity(_curvePool, [amount0, amount1]);\n    }\n\n    function previewAddLiquidity(\n        address _curvePool,\n        uint256[2] memory _amounts\n    ) public view returns (uint256 minMintAmount) {\n        minMintAmount = CurvePoolUtil.previewAddLiquidity(_curvePool, _amounts);\n    }\n\n    function previewRemoveLiquidityForAsset(\n        address _curvePool,\n        uint256 _lpAmount\n    ) public view returns (uint256 assets) {\n        uint256[2] memory minAmounts = CurvePoolUtil.previewRemoveLiquidity(_curvePool, _lpAmount);\n        assets =\n            IERC4626(ICurvePool(_curvePool).coins(0)).previewRedeem(minAmounts[0]) +\n            IPrincipalToken(ICurvePool(_curvePool).coins(1)).previewRedeem(minAmounts[1]);\n    }\n\n    function previewRemoveLiquidityForIBT(\n        address _curvePool,\n        uint256 _lpAmount\n    ) public view returns (uint256 ibts) {\n        uint256[2] memory minAmounts = CurvePoolUtil.previewRemoveLiquidity(_curvePool, _lpAmount);\n        ibts =\n            minAmounts[0] +\n            IPrincipalToken(ICurvePool(_curvePool).coins(1)).previewRedeemForIBT(minAmounts[1]);\n    }\n\n    function previewRemoveLiquidity(\n        address _curvePool,\n        uint256 _lpAmount\n    ) public view returns (uint256[2] memory minAmounts) {\n        minAmounts = CurvePoolUtil.previewRemoveLiquidity(_curvePool, _lpAmount);\n    }\n\n    function previewRemoveLiquidityOneCoin(\n        address _curvePool,\n        uint256 _lpAmount,\n        uint256 _i\n    ) public view returns (uint256 minAmount) {\n        minAmount = CurvePoolUtil.previewRemoveLiquidityOneCoin(_curvePool, _lpAmount, _i);\n    }\n\n    /**\n     * @dev Returns the unit element of the underlying asset of the PT/IBT\n     * @param _pt address of Principal Token\n     * @return The unit of asset\n     */\n    function getUnderlyingUnit(address _pt) public view returns (uint256) {\n        return getUnit(IPrincipalToken(_pt).underlying());\n    }\n\n    /**\n     * @dev Returns the unit element of the token\n     * @param _token address of token\n     * @return The unit of asset\n     */\n    function getUnit(address _token) public view returns (uint256) {\n        return 10 ** IERC20Metadata(_token).decimals();\n    }\n\n    /* INTERNAL FUNCTIONS\n     *****************************************************************************************************************/\n\n    /**\n     * @dev Calculates the flash loan fee for borrowing a given quantity of IBT\n     * @param _pt address of Principal Token\n     * @param _ibt address of Interest Bearing Token\n     * @param _borrowedIBTAmount amount of Interest Bearing Tokens that have been borrowed in the flash loan\n     * @return The amount of fees charged for flash loan\n     */\n    function _getFlashFee(\n        address _pt,\n        address _ibt,\n        uint256 _borrowedIBTAmount\n    ) internal view returns (uint256) {\n        return IERC3156FlashLender(_pt).flashFee(_ibt, _borrowedIBTAmount);\n    }\n\n    /**\n     * @dev abs(a, b)\n     * @param a some integer\n     * @param b some integer\n     * @return The absolute value of a - b\n     */\n    function _delta(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a - b : b - a;\n    }\n}"
    },
    {
      "filename": "src/router/util/RouterUtil.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.20;\n\nimport \"openzeppelin-math/Math.sol\";\nimport \"openzeppelin-contracts/utils/math/SafeCast.sol\";\nimport \"../../libraries/CurvePoolUtil.sol\";\nimport {IERC20} from \"openzeppelin-contracts/interfaces/IERC20.sol\";\nimport {IERC20Metadata} from \"openzeppelin-contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {IERC4626} from \"openzeppelin-contracts/interfaces/IERC4626.sol\";\nimport {IERC3156FlashLender} from \"openzeppelin-contracts/interfaces/IERC3156FlashLender.sol\";\nimport {SafeERC20} from \"openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Ownable2StepUpgradeable} from \"openzeppelin-contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport {Dispatcher} from \"../Dispatcher.sol\";\nimport {Constants} from \"../Constants.sol\";\nimport {IRouter} from \"../../interfaces/IRouter.sol\";\nimport {IPrincipalToken} from \"../../interfaces/IPrincipalToken.sol\";\nimport {ICurvePool} from \"../../interfaces/ICurvePool.sol\";\n\ncontract RouterUtil {\n    using Math for uint256;\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    error InvalidTokenIndex(uint256 i, uint256 j);\n\n    /**\n     * @dev Gives the spot exchange rate of token i in terms of token j. Exchange rate is in 18 decimals\n     * @param _curvePool PT/IBT curve pool\n     * @param _i token index, either 0 or 1\n     * @param _j token index, either 0 or 1, must be different than _i\n     * @return The spot exchange rate of _i in terms of _j\n     */\n    function spotExchangeRate(\n        address _curvePool,\n        uint256 _i,\n        uint256 _j\n    ) public view returns (uint256) {\n        if (_i == 0 && _j == 1) {\n            return Constants.UNIT.mulDiv(Constants.UNIT, ICurvePool(_curvePool).last_prices());\n        } else if (_i == 1 && _j == 0) {\n            return ICurvePool(_curvePool).last_prices();\n        } else {\n            revert InvalidTokenIndex(_i, _j);\n        }\n    }\n\n    /**\n     * @dev Returns the maximal amount of YT one can obtain with a given amount of IBT (i.e without fees or slippage).\n     * @dev Gives the upper bound of the interval to perform bisection search in previewFlashSwapExactIBTForYT().\n     * @param _inputIBTAmount amount of IBT exchanged for YT\n     * @param _curvePool PT/IBT curve pool\n     * @return The upper bound for search interval in root finding algorithms\n     */\n    function convertIBTToYTSpot(\n        uint256 _inputIBTAmount,\n        address _curvePool\n    ) public view returns (uint256) {\n        // The spot exchange rate between IBT and YT is evaluated using the tokenization equation without fees.\n        // This equation reads: ptRate * IBT / ibtRate = 1 PT + 1 YT .\n\n        address pt = ICurvePool(_curvePool).coins(1);\n\n        uint256 ibtRate = IPrincipalToken(pt).getIBTRate(); // asset decimals\n        uint256 ptRate = IPrincipalToken(pt).getPTRate(); // asset decimals\n\n        uint256 assetUnit = getUnderlyingUnit(pt); // asset decimals\n        uint256 assetUnitAdjusted = assetUnit.mulDiv(ptRate, assetUnit); // asset decimals\n\n        uint256 ptInUnderlying = spotExchangeRate(_curvePool, 1, 0).mulDiv(ibtRate, Constants.UNIT);\n        uint256 ytInUnderlying = assetUnitAdjusted - ptInUnderlying;\n\n        return _inputIBTAmount.mulDiv(ibtRate, ytInUnderlying); // ibt decimals\n    }\n\n    /**\n     * @dev Given an output amountof YT desired, yields the amount of IBT required to get this amount\n     * @param _curvePool PT/IBT curve pool\n     * @param _outputYTAmount desired output YT token amount\n     * @return inputIBTAmount The amount of IBT needed for obtaining the defined amount of YT\n     * @return borrowedIBTAmount the quantity of IBT borrowed to execute that swap\n     */\n    function previewFlashSwapIBTToExactYT(\n        address _curvePool,\n        uint256 _outputYTAmount\n    ) public view returns (uint256 inputIBTAmount, uint256 borrowedIBTAmount) {\n        // Tokens\n        address pt = ICurvePool(_curvePool).coins(1);\n        address ibt = IPrincipalToken(pt).getIBT();\n\n        // Units and rates\n        uint256 ibtRate = IPrincipalToken(pt).getIBTRate(); // 27 decimals\n        uint256 ptRate = IPrincipalToken(pt).getPTRate(); // 27 decimals\n\n        // Outputs\n        uint256 swapPTForIBT = ICurvePool(_curvePool).get_dy(1, 0, _outputYTAmount);\n\n        // y PT:YT = (x IBT * ((UNIT - tokenizationFee) / UNIT) * ibtRate) / ptRate\n        // <=> x IBT = (y PT:YT * ptRate * UNIT) / (ibtRate * (UNIT - tokenizationFee))\n        borrowedIBTAmount = (_outputYTAmount * ptRate * Constants.UNIT).ceilDiv(\n            ibtRate * (Constants.UNIT - IPrincipalToken(pt).getTokenizationFee())\n        );\n\n        inputIBTAmount =\n            borrowedIBTAmount +\n            _getFlashFee(pt, ibt, borrowedIBTAmount) -\n            swapPTForIBT;\n    }\n\n    /**\n     * @dev Given an input IBT amount, previews the expected amount of YT obtained after executing the swap\n     * @param _curvePool PT/IBT curve pool\n     * @param _inputIBTAmount amount of IBT exchanged for YT\n     * @return The max guess of YT obtained for the given amount of IBT\n     * @return The min guess of YT obtained for the given amount of IBT\n     * @return The quantity of IBT borrowed to execute that swap.\n     */\n    function previewFlashSwapExactIBTToYT(\n        address _curvePool,\n        uint256 _inputIBTAmount\n    ) public view returns (uint256, uint256, uint256) {\n        int256 x0 = _inputIBTAmount.toInt256();\n        int256 x1 = convertIBTToYTSpot(_inputIBTAmount, _curvePool).toInt256();\n        int256 x2;\n\n        //x2 = x1 - f(x1) * (x1 - x0) / (f(x1) - f(x0))\n        // x0, x1 = x1, x2\n\n        for (uint256 i = 0; i < Constants.MAX_ITERATIONS_SECANT; ++i) {\n            if (_delta(x0.toUint256(), x1.toUint256()) < Constants.PRECISION) {\n                break;\n            }\n\n            (uint256 inputIBTAmount0, ) = previewFlashSwapIBTToExactYT(_curvePool, x0.toUint256());\n\n            (uint256 inputIBTAmount1, ) = previewFlashSwapIBTToExactYT(_curvePool, x1.toUint256());\n\n            int256 answer0 = inputIBTAmount0.toInt256() - _inputIBTAmount.toInt256();\n            int256 answer1 = inputIBTAmount1.toInt256() - _inputIBTAmount.toInt256();\n\n            if (answer0 == answer1) {\n                break;\n            }"
    }
  ]
}