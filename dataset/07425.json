{
  "Title": "[M-13] Slashing fails when node operator doesnâ€™t have enough staked GGP",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-12-gogopool/blob/main/contracts/contract/Staking.sol#L379-L383\n\n\n# Vulnerability details\n\n## Description\nWhen creating a minipool the node operator is required to put up a collateral in `GGP`, the protocol token. The amount of `GGP` collateral needed is currently calculated to be 10% of the `AVAX` staked. This is calculated using the price of `GGP - AVAX`.\n\nIf the node operator doesn't have high enough availability and doesn't get any rewards the protocol will slash their `GGP` collateral to reward liquid stakers. This is also calculated using the price of `GGP - AVAX`:\n\n```javascript\nFile: MinipoolManager.sol\n\n547:\tfunction calculateGGPSlashAmt(uint256 avaxRewardAmt) public view returns (uint256) {\n548:\t\tOracle oracle = Oracle(getContractAddress(\"Oracle\"));\n549:\t\t(uint256 ggpPriceInAvax, ) = oracle.getGGPPriceInAVAX(); // price might change or be manipulated\n550:\t\treturn avaxRewardAmt.divWadDown(ggpPriceInAvax);\n551:\t}\n\n...\n\n670:\tfunction slash(int256 index) private {\n\n...\n\n673:\t\tuint256 duration = getUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".duration\")));\n674:\t\tuint256 avaxLiquidStakerAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", index, \".avaxLiquidStakerAmt\")));\n675:\t\tuint256 expectedAVAXRewardsAmt = getExpectedAVAXRewardsAmt(duration, avaxLiquidStakerAmt);\n676:\t\tuint256 slashGGPAmt = calculateGGPSlashAmt(expectedAVAXRewardsAmt);\n\n...\n\n681:\t\tStaking staking = Staking(getContractAddress(\"Staking\"));\n682:\t\tstaking.slashGGP(owner, slashGGPAmt);\n683:\t}\n```\n\nThis is then subtracted from their staked amount:\n\n```javascript\nFile: Staking.sol\n\n94: \tfunction decreaseGGPStake(address stakerAddr, uint256 amount) internal {\n95: \t\tint256 stakerIndex = requireValidStaker(stakerAddr);\n96: \t\tsubUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".ggpStaked\")), amount); // can fail due to underflow\n97: \t}\n\n...\n\n379:\tfunction slashGGP(address stakerAddr, uint256 ggpAmt) public onlySpecificRegisteredContract(\"MinipoolManager\", msg.sender) {\n380:\t\tVault vault = Vault(getContractAddress(\"Vault\"));\n381:\t\tdecreaseGGPStake(stakerAddr, ggpAmt);\n382:\t\tvault.transferToken(\"ProtocolDAO\", ggp, ggpAmt);\n383:\t}\n```\n\nThe issue is that the current staked amount is never checked so the `subUint` can fail due to underflow if the price has changed since the minipool was created/recreated.\n\n## Impact\nIf a node operator doesn't have enough collateral, possibly caused by price changes in `GGP` during slashing they evade slashing all together.\n\nIts even possible for the node operator to foresee this and manipulate the price of `GGP` just prior to the period ending if they know that they are going to be slashed.\n\n## Proof of Concept\nPoC test in `MinipoolManager.t.sol`:\n\n```javascript\n\tfunction testRecordStakingEndWithSlashNotEnoughStake() public {\n\t\tuint256 duration = 365 days;\n\t\tuint256 depositAmt = 1000 ether;\n\t\tuint256 avaxAssignmentRequest = 1000 ether;\n\t\tuint256 validationAmt = depositAmt + avaxAssignmentRequest;\n\t\tuint128 ggpStakeAmt = 100 ether; // just enough\n\n\t\tvm.startPrank(nodeOp);\n\t\tggp.approve(address(staking), MAX_AMT);\n\t\tstaking.stakeGGP(ggpStakeAmt);\n\t\tMinipoolManager.Minipool memory mp1 = createMinipool(depositAmt, avaxAssignmentRequest, duration);\n\t\tvm.stopPrank();\n\n\t\taddress liqStaker1 = getActorWithTokens(\"liqStaker1\", MAX_AMT, MAX_AMT);\n\t\tvm.prank(liqStaker1);\n\t\tggAVAX.depositAVAX{value: MAX_AMT}();\n\n\t\tvm.prank(address(rialto));\n\t\tminipoolMgr.claimAndInitiateStaking(mp1.nodeID);\n\n\t\tbytes32 txID = keccak256(\"txid\");\n\t\tvm.prank(address(rialto));\n\t\tminipoolMgr.recordStakingStart(mp1.nodeID, txID, block.timestamp);\n\n\t\tskip(2 weeks);\n\t\t\n\t\tvm.prank(address(rialto)); // price changes just a bit\n\t\toracle.setGGPPriceInAVAX(0.999 ether, block.timestamp);\n\n\t\tvm.prank(address(rialto));\n\t\tvm.expectRevert(); // staking cannot end because of underflow\n\t\tminipoolMgr.recordStakingEnd{value: validationAmt}(mp1.nodeID, block.timestamp, 0 ether);\n\t}\n```\n\nThe only thing the protocol can do now is to call `recordStakingError` for the minipool, since no other state changes are allowed. This will return the staked funds but it will not slash the `GGP` amount for the node operator. Hence the node operator has evaded the slashing.\n\n## Tools Used\nvs code, forge\n\n## Recommended Mitigation Steps\nIf the amount to be slashed is greater than what the node operator has staked, slash all their stake.",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-12-gogopool-contest",
  "Code": [
    {
      "filename": "contracts/contract/Staking.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport \"./Base.sol\";\nimport {MinipoolManager} from \"./MinipoolManager.sol\";\nimport {Oracle} from \"./Oracle.sol\";\nimport {ProtocolDAO} from \"./ProtocolDAO.sol\";\nimport {Storage} from \"./Storage.sol\";\nimport {Vault} from \"./Vault.sol\";\n\nimport {ERC20} from \"@rari-capital/solmate/src/mixins/ERC4626.sol\";\nimport {FixedPointMathLib} from \"@rari-capital/solmate/src/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\";\n\n/*\n\tData Storage Schema\n\tA \"staker\" is a user of the protocol who stakes GGP into this contract\n\n\tstaker.count = Starts at 0 and counts up by 1 after a staker is added.\n\n\tstaker.index<stakerAddr> = <index> of stakerAddr\n\tstaker.item<index>.stakerAddr = wallet address of staker, used as primary key\n\tstaker.item<index>.ggpStaked = Total amt of GGP staked across all minipools\n\tstaker.item<index>.avaxStaked = Total amt of AVAX staked across all minipools\n\tstaker.item<index>.avaxAssigned = Total amt of liquid staker funds assigned across all minipools\n\tstaker.item<index>.avaxAssignedHighWater = Highest amt of liquid staker funds assigned during a GGP rewards cycle\n*/\n\n/// @title GGP staking and staker attributes\ncontract Staking is Base {\n\tusing SafeTransferLib for ERC20;\n\tusing SafeTransferLib for address;\n\tusing FixedPointMathLib for uint256;\n\n\terror CannotWithdrawUnder150CollateralizationRatio();\n\terror InsufficientBalance();\n\terror InvalidRewardsStartTime();\n\terror StakerNotFound();\n\n\tevent GGPStaked(address indexed from, uint256 amount);\n\tevent GGPWithdrawn(address indexed to, uint256 amount);\n\n\t/// @dev Not used for storage, just for returning data from view functions\n\tstruct Staker {\n\t\taddress stakerAddr;\n\t\tuint256 ggpStaked;\n\t\tuint256 avaxStaked;\n\t\tuint256 avaxAssigned;\n\t\tuint256 avaxAssignedHighWater;\n\t\tuint256 minipoolCount;\n\t\tuint256 rewardsStartTime;\n\t\tuint256 ggpRewards;\n\t\tuint256 lastRewardsCycleCompleted;\n\t}\n\n\tuint256 internal constant TENTH = 0.1 ether;\n\n\tERC20 public immutable ggp;\n\n\tconstructor(Storage storageAddress, ERC20 ggp_) Base(storageAddress) {\n\t\tversion = 1;\n\t\tggp = ggp_;\n\t}\n\n\t/// @notice Total GGP (stored in vault) assigned to this contract\n\tfunction getTotalGGPStake() public view returns (uint256) {\n\t\tVault vault = Vault(getContractAddress(\"Vault\"));\n\t\treturn vault.balanceOfToken(\"Staking\", ggp);\n\t}\n\n\t/// @notice Total count of GGP stakers in the protocol\n\tfunction getStakerCount() public view returns (uint256) {\n\t\treturn getUint(keccak256(\"staker.count\"));\n\t}\n\n\t/* GGP STAKE */\n\n\t/// @notice The amount of GGP a given staker is staking\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction getGGPStake(address stakerAddr) public view returns (uint256) {\n\t\tint256 stakerIndex = requireValidStaker(stakerAddr);\n\t\treturn getUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".ggpStaked\")));\n\t}\n\n\t/// @notice Increase the amount of GGP a given staker is staking\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction increaseGGPStake(address stakerAddr, uint256 amount) internal {\n\t\tint256 stakerIndex = requireValidStaker(stakerAddr);\n\t\taddUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".ggpStaked\")), amount);\n\t}\n\n\t/// @notice Decrease the amount of GGP a given staker is staking\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction decreaseGGPStake(address stakerAddr, uint256 amount) internal {\n\t\tint256 stakerIndex = requireValidStaker(stakerAddr);\n\t\tsubUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".ggpStaked\")), amount);\n\t}\n\n\t/* AVAX STAKE */\n\n\t/// @notice The amount of AVAX a given staker is staking\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction getAVAXStake(address stakerAddr) public view returns (uint256) {\n\t\tint256 stakerIndex = requireValidStaker(stakerAddr);\n\t\treturn getUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".avaxStaked\")));\n\t}\n\n\t/// @notice Increase the amount of AVAX a given staker is staking\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction increaseAVAXStake(address stakerAddr, uint256 amount) public onlySpecificRegisteredContract(\"MinipoolManager\", msg.sender) {\n\t\tint256 stakerIndex = requireValidStaker(stakerAddr);\n\t\taddUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".avaxStaked\")), amount);\n\t}\n\n\t/// @notice Decrease the amount of AVAX a given staker is staking\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction decreaseAVAXStake(address stakerAddr, uint256 amount) public onlySpecificRegisteredContract(\"MinipoolManager\", msg.sender) {\n\t\tint256 stakerIndex = requireValidStaker(stakerAddr);\n\t\tsubUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".avaxStaked\")), amount);\n\t}\n\n\t/* AVAX ASSIGNED */\n\n\t/// @notice The amount of AVAX a given staker is assigned by the protocol (for minipool creation)\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction getAVAXAssigned(address stakerAddr) public view returns (uint256) {\n\t\tint256 stakerIndex = getIndexOf(stakerAddr);\n\t\treturn getUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".avaxAssigned\")));\n\t}\n\n\t/// @notice Increase the amount of AVAX a given staker is assigned by the protocol (for minipool creation)\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction increaseAVAXAssigned(address stakerAddr, uint256 amount) public onlySpecificRegisteredContract(\"MinipoolManager\", msg.sender) {\n\t\tint256 stakerIndex = requireValidStaker(stakerAddr);\n\t\taddUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".avaxAssigned\")), amount);\n\t}\n\n\t/// @notice Decrease the amount of AVAX a given staker is assigned by the protocol (for minipool creation)\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction decreaseAVAXAssigned(address stakerAddr, uint256 amount) public onlySpecificRegisteredContract(\"MinipoolManager\", msg.sender) {\n\t\tint256 stakerIndex = requireValidStaker(stakerAddr);\n\t\tsubUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".avaxAssigned\")), amount);\n\t}\n\n\t/* AVAX ASSIGNED HIGH-WATER */\n\n\t/// @notice Largest total AVAX amt assigned to a staker during a rewards period\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction getAVAXAssignedHighWater(address stakerAddr) public view returns (uint256) {\n\t\tint256 stakerIndex = getIndexOf(stakerAddr);\n\t\treturn getUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".avaxAssignedHighWater\")));\n\t}\n\n\t/// @notice Increase the AVAXAssignedHighWater\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction increaseAVAXAssignedHighWater(address stakerAddr, uint256 amount) public onlyRegisteredNetworkContract {\n\t\tint256 stakerIndex = requireValidStaker(stakerAddr);\n\t\taddUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".avaxAssignedHighWater\")), amount);\n\t}\n\n\t/// @notice Reset the AVAXAssignedHighWater to what the current AVAXAssigned is for the staker\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction resetAVAXAssignedHighWater(address stakerAddr) public onlyRegisteredNetworkContract {\n\t\tint256 stakerIndex = requireValidStaker(stakerAddr);\n\t\tuint256 currAVAXAssigned = getUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".avaxAssigned\")));\n\t\tsetUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".avaxAssignedHighWater\")), currAVAXAssigned);\n\t}\n\n\t/* MINIPOOL COUNT */\n\n\t/// @notice The number of minipools the given staker has\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction getMinipoolCount(address stakerAddr) public view returns (uint256) {\n\t\tint256 stakerIndex = getIndexOf(stakerAddr);\n\t\treturn getUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".minipoolCount\")));\n\t}\n\n\t/// @notice Increase the number of minipools the given staker has\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction increaseMinipoolCount(address stakerAddr) public onlySpecificRegisteredContract(\"MinipoolManager\", msg.sender) {\n\t\tint256 stakerIndex = requireValidStaker(stakerAddr);\n\t\taddUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".minipoolCount\")), 1);\n\t}\n\n\t/// @notice Decrease the number of minipools the given staker has\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction decreaseMinipoolCount(address stakerAddr) public onlySpecificRegisteredContract(\"MinipoolManager\", msg.sender) {\n\t\tint256 stakerIndex = requireValidStaker(stakerAddr);\n\t\tsubUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".minipoolCount\")), 1);\n\t}\n\n\t/* REWARDS START TIME */\n\n\t/// @notice The timestamp when the staker registered for GGP rewards\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction getRewardsStartTime(address stakerAddr) public view returns (uint256) {\n\t\tint256 stakerIndex = getIndexOf(stakerAddr);\n\t\treturn getUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".rewardsStartTime\")));\n\t}\n\n\t/// @notice Set the timestamp when the staker registered for GGP rewards\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\t// TODO cant use onlySpecificRegisteredContract(\"ClaimNodeOp\", msg.sender) since we also call from increaseMinipoolCount. Wat do?\n\tfunction setRewardsStartTime(address stakerAddr, uint256 time) public onlyRegisteredNetworkContract {\n\t\tint256 stakerIndex = requireValidStaker(stakerAddr);\n\t\tif (time > block.timestamp) {\n\t\t\trevert InvalidRewardsStartTime();\n\t\t}\n\n\t\tsetUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".rewardsStartTime\")), time);\n\t}\n\n\t/* GGP REWARDS */\n\n\t/// @notice The amount of GGP rewards the staker has earned and not claimed\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction getGGPRewards(address stakerAddr) public view returns (uint256) {\n\t\tint256 stakerIndex = getIndexOf(stakerAddr);\n\t\treturn getUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".ggpRewards\")));\n\t}\n\n\t/// @notice Increase the amount of GGP rewards the staker has earned and not claimed\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction increaseGGPRewards(address stakerAddr, uint256 amount) public onlySpecificRegisteredContract(\"ClaimNodeOp\", msg.sender) {\n\t\tint256 stakerIndex = requireValidStaker(stakerAddr);\n\t\taddUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".ggpRewards\")), amount);\n\t}\n\n\t/// @notice Decrease the amount of GGP rewards the staker has earned and not claimed\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction decreaseGGPRewards(address stakerAddr, uint256 amount) public onlySpecificRegisteredContract(\"ClaimNodeOp\", msg.sender) {\n\t\tint256 stakerIndex = requireValidStaker(stakerAddr);\n\t\tsubUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".ggpRewards\")), amount);\n\t}\n\n\t/* LAST REWARDS CYCLE PAID OUT */\n\n\t/// @notice The most recent reward cycle number that the staker has been paid out for\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction getLastRewardsCycleCompleted(address stakerAddr) public view returns (uint256) {\n\t\tint256 stakerIndex = getIndexOf(stakerAddr);\n\t\treturn getUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".lastRewardsCycleCompleted\")));\n\t}\n\n\t/// @notice Set the most recent reward cycle number that the staker has been paid out for\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\t/// @param cycleNumber The cycle that the staker was just rewarded for\n\tfunction setLastRewardsCycleCompleted(address stakerAddr, uint256 cycleNumber) public onlySpecificRegisteredContract(\"ClaimNodeOp\", msg.sender) {\n\t\tint256 stakerIndex = requireValidStaker(stakerAddr);\n\t\tsetUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".lastRewardsCycleCompleted\")), cycleNumber);\n\t}\n\n\t/// @notice Get a stakers's minimum GGP stake to collateralize their minipools, based on current GGP price\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\t/// @return Amount of GGP\n\tfunction getMinimumGGPStake(address stakerAddr) public view returns (uint256) {\n\t\tProtocolDAO dao = ProtocolDAO(getContractAddress(\"ProtocolDAO\"));\n\t\tOracle oracle = Oracle(getContractAddress(\"Oracle\"));\n\t\t(uint256 ggpPriceInAvax, ) = oracle.getGGPPriceInAVAX();\n\n\t\tuint256 avaxAssigned = getAVAXAssigned(stakerAddr);\n\t\tuint256 ggp100pct = avaxAssigned.divWadDown(ggpPriceInAvax);\n\t\treturn ggp100pct.mulWadDown(dao.getMinCollateralizationRatio());\n\t}\n\n\t/// @notice Returns collateralization ratio based on current GGP price\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\t/// @return A ratio where 0 = 0%, 1 ether = 100%\n\tfunction getCollateralizationRatio(address stakerAddr) public view returns (uint256) {\n\t\tuint256 avaxAssigned = getAVAXAssigned(stakerAddr);\n\t\tif (avaxAssigned == 0) {\n\t\t\t// Infinite collat ratio\n\t\t\treturn type(uint256).max;\n\t\t}\n\t\tOracle oracle = Oracle(getContractAddress(\"Oracle\"));\n\t\t(uint256 ggpPriceInAvax, ) = oracle.getGGPPriceInAVAX();\n\t\tuint256 ggpStakedInAvax = getGGPStake(stakerAddr).mulWadDown(ggpPriceInAvax);\n\t\treturn ggpStakedInAvax.divWadDown(avaxAssigned);\n\t}\n\n\t/// @notice Returns effective collateralization ratio which will be used to pay out rewards\n\t///         based on current GGP price and AVAX high water mark. A staker can earn GGP rewards\n\t///         on up to 150% collat ratio\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\t/// @return Ratio is between 0%-150% (0-1.5 ether)\n\tfunction getEffectiveRewardsRatio(address stakerAddr) public view returns (uint256) {\n\t\tuint256 avaxAssignedHighWater = getAVAXAssignedHighWater(stakerAddr);\n\t\tif (avaxAssignedHighWater == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (getCollateralizationRatio(stakerAddr) < TENTH) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tOracle oracle = Oracle(getContractAddress(\"Oracle\"));\n\t\t(uint256 ggpPriceInAvax, ) = oracle.getGGPPriceInAVAX();\n\t\tuint256 ggpStakedInAvax = getGGPStake(stakerAddr).mulWadDown(ggpPriceInAvax);\n\t\tuint256 ratio = ggpStakedInAvax.divWadDown(avaxAssignedHighWater);\n\n\t\tProtocolDAO dao = ProtocolDAO(getContractAddress(\"ProtocolDAO\"));\n\t\tuint256 maxRatio = dao.getMaxCollateralizationRatio();\n\n\t\treturn (ratio > maxRatio) ? maxRatio : ratio;\n\t}\n\n\t/// @notice GGP that will count towards rewards this cycle\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction getEffectiveGGPStaked(address stakerAddr) external view returns (uint256) {\n\t\tOracle oracle = Oracle(getContractAddress(\"Oracle\"));\n\t\t(uint256 ggpPriceInAvax, ) = oracle.getGGPPriceInAVAX();\n\n\t\tuint256 avaxAssignedHighWater = getAVAXAssignedHighWater(stakerAddr);\n\t\tuint256 ratio = getEffectiveRewardsRatio(stakerAddr);\n\t\treturn avaxAssignedHighWater.mulWadDown(ratio).divWadDown(ggpPriceInAvax);\n\t}\n\n\t/// @notice Accept a GGP stake\n\t/// @param amount The amount of GGP being staked\n\tfunction stakeGGP(uint256 amount) external whenNotPaused {\n\t\t// Transfer GGP tokens from staker to this contract\n\t\tggp.safeTransferFrom(msg.sender, address(this), amount);\n\t\t_stakeGGP(msg.sender, amount);\n\t}\n\n\t/// @notice Convenience function to allow for restaking claimed GGP rewards\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\t/// @param amount The amount of GGP being staked\n\tfunction restakeGGP(address stakerAddr, uint256 amount) public onlySpecificRegisteredContract(\"ClaimNodeOp\", msg.sender) {\n\t\t// Transfer GGP tokens from the ClaimNodeOp contract to this contract\n\t\tggp.safeTransferFrom(msg.sender, address(this), amount);\n\t\t_stakeGGP(stakerAddr, amount);\n\t}\n\n\t/// @notice Stakes GGP in the protocol\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\t/// @param amount The amount of GGP being staked\n\tfunction _stakeGGP(address stakerAddr, uint256 amount) internal {\n\t\temit GGPStaked(stakerAddr, amount);\n\n\t\t// Deposit GGP tokens from this contract to vault\n\t\tVault vault = Vault(getContractAddress(\"Vault\"));\n\t\tggp.approve(address(vault), amount);\n\t\tvault.depositToken(\"Staking\", ggp, amount);\n\n\t\tint256 stakerIndex = getIndexOf(stakerAddr);\n\t\tif (stakerIndex == -1) {\n\t\t\t// create index for the new staker\n\t\t\tstakerIndex = int256(getUint(keccak256(\"staker.count\")));\n\t\t\taddUint(keccak256(\"staker.count\"), 1);\n\t\t\tsetUint(keccak256(abi.encodePacked(\"staker.index\", stakerAddr)), uint256(stakerIndex + 1));\n\t\t\tsetAddress(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".stakerAddr\")), stakerAddr);\n\t\t}\n\t\tincreaseGGPStake(stakerAddr, amount);\n\t}\n\n\t/// @notice Allows the staker to unstake their GGP if they are over the 150% collateralization ratio\n\t/// @param amount The amount of GGP being withdrawn\n\tfunction withdrawGGP(uint256 amount) external whenNotPaused {\n\t\tif (amount > getGGPStake(msg.sender)) {\n\t\t\trevert InsufficientBalance();\n\t\t}\n\n\t\temit GGPWithdrawn(msg.sender, amount);\n\n\t\tdecreaseGGPStake(msg.sender, amount);\n\n\t\tProtocolDAO dao = ProtocolDAO(getContractAddress(\"ProtocolDAO\"));\n\t\tif (getCollateralizationRatio(msg.sender) < dao.getMaxCollateralizationRatio()) {\n\t\t\trevert CannotWithdrawUnder150CollateralizationRatio();\n\t\t}\n\n\t\tVault vault = Vault(getContractAddress(\"Vault\"));\n\t\tvault.withdrawToken(msg.sender, ggp, amount);\n\t}\n\n\t/// @notice Minipool Manager will call this if a minipool ended and was not in good standing\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\t/// @param ggpAmt The amount of GGP being slashed\n\tfunction slashGGP(address stakerAddr, uint256 ggpAmt) public onlySpecificRegisteredContract(\"MinipoolManager\", msg.sender) {\n\t\tVault vault = Vault(getContractAddress(\"Vault\"));\n\t\tdecreaseGGPStake(stakerAddr, ggpAmt);\n\t\tvault.transferToken(\"ProtocolDAO\", ggp, ggpAmt);\n\t}\n\n\t/// @notice Verifying the staker exists in the protocol\n\t/// @param stakerAddr The C-chain address of a GGP staker in the protocol\n\tfunction requireValidStaker(address stakerAddr) public view returns (int256) {\n\t\tint256 index = getIndexOf(stakerAddr);\n\t\tif (index != -1) {\n\t\t\treturn index;\n\t\t} else {\n\t\t\trevert StakerNotFound();\n\t\t}\n\t}\n\n\t/// @notice Get index of the staker\n\t/// @return staker index or -1 if the value was not found\n\tfunction getIndexOf(address stakerAddr) public view returns (int256) {\n\t\treturn int256(getUint(keccak256(abi.encodePacked(\"staker.index\", stakerAddr)))) - 1;\n\t}\n\n\t/// @notice Gets the staker information using the staker's index\n\t/// @param stakerIndex Index of the staker\n\t/// @return staker struct containing the staker's properties\n\tfunction getStaker(int256 stakerIndex) public view returns (Staker memory staker) {\n\t\tstaker.ggpStaked = getUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".ggpStaked\")));\n\t\tstaker.avaxAssigned = getUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".avaxAssigned\")));\n\t\tstaker.avaxStaked = getUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".avaxStaked\")));\n\t\tstaker.stakerAddr = getAddress(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".stakerAddr\")));\n\t\tstaker.minipoolCount = getUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".minipoolCount\")));\n\t\tstaker.rewardsStartTime = getUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".rewardsStartTime\")));\n\t\tstaker.ggpRewards = getUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".ggpRewards\")));\n\t\tstaker.lastRewardsCycleCompleted = getUint(keccak256(abi.encodePacked(\"staker.item\", stakerIndex, \".lastRewardsCycleCompleted\")));\n\t}\n\n\t/// @notice Get stakers in the protocol (limit=0 means no pagination)\n\t/// @param offset The number the result should be offset by\n\t/// @param limit The limit to the amount of minipools that should be returned\n\t/// @return stakers in the protocol that adhear to the paramaters\n\tfunction getStakers(uint256 offset, uint256 limit) external view returns (Staker[] memory stakers) {\n\t\tuint256 totalStakers = getStakerCount();\n\t\tuint256 max = offset + limit;\n\t\tif (max > totalStakers || limit == 0) {\n\t\t\tmax = totalStakers;\n\t\t}\n\t\tstakers = new Staker[](max - offset);\n\t\tuint256 total = 0;\n\t\tfor (uint256 i = offset; i < max; i++) {\n\t\t\tStaker memory s = getStaker(int256(i));\n\t\t\tstakers[total] = s;\n\t\t\ttotal++;\n\t\t}\n\t\t// Dirty hack to cut unused elements off end of return value (from RP)\n\t\t// solhint-disable-next-line no-inline-assembly\n\t\tassembly {\n\t\t\tmstore(stakers, total)\n\t\t}\n\t}\n}"
    }
  ]
}