{
  "Title": "M-9: Protocol Reserve Within A LToken Vault Can Be Lent Out",
  "Content": "# Issue M-9: Protocol Reserve Within A LToken Vault Can Be Lent Out \nSource: https://github.com/sherlock-audit/2022-08-sentiment-judging/tree/main/122-M \n## Found by \nxiaoming90\n\n## Summary\n\nProtocol reserve, which serves as a liquidity backstop or to compensate the protocol, within a LToken vault can be lent out to the borrowers.\n\n## Vulnerability Detail\n\nThe purpose of the protocol reserve within a LToken vault is to compensate the protocol or serve as a liquidity backstop. However, based on the current setup, it is possible for the protocol reserve within a Ltoken vault to be lent out.\n\nThe following functions within the `LToken` contract show that the protocol reserve is intentionally preserved by removing the protocol reserve from the calculation of total assets within a LToken vault. As such, whenever the Liquidity Providers (LPs) attempt to redeem their LP token, the protocol reserves will stay intact and will not be withdrawn by the LPs.\n\nhttps://github.com/sherlock-audit/2022-08-sentiment/blob/main/protocol/src/tokens/LToken.sol#L191\n\n```solidity\nfunction totalAssets() public view override returns (uint) {\n    return asset.balanceOf(address(this)) + getBorrows() - getReserves();\n}\n```\n\nhttps://github.com/sherlock-audit/2022-08-sentiment/blob/main/protocol/src/tokens/LToken.sol#L195\n\n```solidity\nfunction getBorrows() public view returns (uint) {\n    return borrows + borrows.mulWadUp(getRateFactor());\n}\n```\n\nhttps://github.com/sherlock-audit/2022-08-sentiment/blob/main/protocol/src/tokens/LToken.sol#L176\n\n```solidity\nfunction getReserves() public view returns (uint) {\n    return reserves + borrows.mulWadUp(getRateFactor())\n    .mulWadUp(reserveFactor);\n}\n```\n\nHowever, this measure is not applied consistently across the protocol. The following `lendTo` function shows that as long as the borrower has sufficient collateral to ensure their account remains healthy, the borrower could borrow as many assets from the LToken vault as they wish.\n\nIn the worst-case scenario, the borrower can borrow all the assets from the LToken vault, including the protocol reserve.\n\nhttps://github.com/sherlock-audit/2022-08-sentiment/blob/main/protocol/src/tokens/LToken.sol#L128\n\n```solidity\nFile: LToken.sol\n121:     /**\n122:         @notice Lends a specified amount of underlying asset to an account\n123:         @param account Address of account\n124:         @param amt Amount of token to lend\n125:         @return isFirstBorrow Returns if the account is borrowing the asset for\n126:             the first time\n127:     */\n128:     function lendTo(address account, uint amt)\n129:         external\n130:         whenNotPaused\n131:         accountManagerOnly\n132:         returns (bool isFirstBorrow)\n133:     {\n134:         updateState();\n135:         isFirstBorrow = (borrowsOf[account] == 0);\n136: \n137:         uint borrowShares;\n138:         require((borrowShares = convertAssetToBorrowShares(amt)) != 0, \"ZERO_BORROW_SHARES\");\n139:         totalBorrowShares += borrowShares;\n140:         borrowsOf[account] += borrowShares;\n141: \n142:         borrows += amt;\n143:         asset.safeTransfer(account, amt);\n144:         return isFirstBorrow;\n145:     }\n```\n\n## Impact\n\nThe purpose of the protocol reserve within a LToken vault is to compensate the protocol or serve as a liquidity backstop. Without the protocol reserve, the protocol will become illiquidity, and there is no fund to compensate the protocol.\n\n## Recommendation\n\nConsider updating the `lendTo` function to ensure that the protocol reserve is preserved and cannot be lent out. If the underlying asset of a LToken vault is less than or equal to the protocol reserve, the lending should be paused as it is more important to preserve the protocol reserve compared to lending them out.\n\n```diff\nfunction lendTo(address account, uint amt)\n    external\n    whenNotPaused\n    accountManagerOnly\n    returns (bool isFirstBorrow)\n{\n    updateState();\n    isFirstBorrow = (borrowsOf[account] == 0);\n    \n    require\n\n    uint borrowShares;\n    require((borrowShares = convertAssetToBorrowShares(amt)) != 0, \"ZERO_BORROW_SHARES\");\n    totalBorrowShares += borrowShares;\n    borrowsOf[account] += borrowShares;\n\n    borrows += amt;\n    asset.safeTransfer(account, amt);\n    \n+   require(asset.balanceOf(address(this)) >= getReserves(), \"Not enough liquidity for lending\") \n    \n    return isFirstBorrow;\n}\n```\n\n## Sentiment Team\nWe removed reserves completely in this [PR](https://github.com/sentimentxyz/protocol/pull/236).\n\n## Lead Senior Watson\nConfirmed fix. \n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/1",
  "Code": [
    {
      "filename": "protocol/src/tokens/LToken.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {Errors} from \"../utils/Errors.sol\";\nimport {Pausable} from \"../utils/Pausable.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ERC4626} from \"./utils/ERC4626.sol\";\nimport {IRegistry} from \"../interface/core/IRegistry.sol\";\nimport {IRateModel} from \"../interface/core/IRateModel.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {ILToken} from \"../interface/tokens/ILToken.sol\";\n\n/**\n    @title Lending Token\n    @notice Lending token with ERC4626 implementation\n*/\ncontract LToken is Pausable, ERC4626, ILToken {\n    using FixedPointMathLib for uint;\n    using SafeTransferLib for ERC20;\n\n    /* -------------------------------------------------------------------------- */\n    /*                               STATE VARIABLES                              */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Utility variable to indicate if contract is initialized\n    bool private initialized;\n\n    /// @notice Registry\n    IRegistry public registry;\n\n    /// @notice Rate Model\n    IRateModel public rateModel;\n\n    /// @notice Account Manager\n    address public accountManager;\n\n    /// @notice Protocol treasury\n    address public treasury;\n\n    /// @notice Total amount of borrows\n    uint public borrows;\n\n    /// @notice Timestamp of when the state of the LToken was last updated\n    uint public lastUpdated;\n\n    /// @notice Protocol reserves\n    uint public reserves;\n\n    /// @notice Reserve factor\n    uint public reserveFactor;\n\n    /// @notice Total borrow shares minted\n    uint public totalBorrowShares;\n\n    /// @notice Mapping of account to borrow in terms of shares\n    mapping (address => uint) public borrowsOf;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   EVENTS                                   */\n    /* -------------------------------------------------------------------------- */\n\n    event ReservesRedeemed(address indexed treasury, uint amt);\n\n    /* -------------------------------------------------------------------------- */\n    /*                              CUSTOM MODIFIERS                              */\n    /* -------------------------------------------------------------------------- */\n\n    modifier accountManagerOnly() {\n        if (msg.sender != accountManager) revert Errors.AccountManagerOnly();\n        _;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             EXTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @notice Contract initialization function\n        @dev Can only be invoked once\n        @param _asset Underlying ERC20 token\n        @param _name Name of LToken\n        @param _symbol Symbol of LToken\n        @param _registry Address of Registry\n        @param _reserveFactor Borrow Fee\n        @param _treasury Protocol treasury\n    */\n    function init(\n        ERC20 _asset,\n        string calldata _name,\n        string calldata _symbol,\n        IRegistry _registry,\n        uint _reserveFactor,\n        address _treasury\n    ) external {\n        if (initialized) revert Errors.ContractAlreadyInitialized();\n\n        if (\n            address(_asset) == address(0) ||\n            address(_registry) == address(0) ||\n            _treasury == address(0)\n        ) revert Errors.ZeroAddress();\n\n        initialized = true;\n        initPausable(msg.sender);\n        initERC4626(_asset, _name, _symbol);\n        registry = _registry;\n        reserveFactor = _reserveFactor;\n        treasury = _treasury;\n    }\n\n    /**\n        @notice Initializes external dependencies\n        @param _rateModel Name of rate model contract\n    */\n    function initDep(string calldata _rateModel) external adminOnly {\n        rateModel = IRateModel(registry.getAddress(_rateModel));\n        accountManager = registry.getAddress('ACCOUNT_MANAGER');\n    }\n\n    /**\n        @notice Lends a specified amount of underlying asset to an account\n        @param account Address of account\n        @param amt Amount of token to lend\n        @return isFirstBorrow Returns if the account is borrowing the asset for\n            the first time\n    */\n    function lendTo(address account, uint amt)\n        external\n        whenNotPaused\n        accountManagerOnly\n        returns (bool isFirstBorrow)\n    {\n        updateState();\n        isFirstBorrow = (borrowsOf[account] == 0);\n\n        uint borrowShares;\n        require((borrowShares = convertAssetToBorrowShares(amt)) != 0, \"ZERO_BORROW_SHARES\");\n        totalBorrowShares += borrowShares;\n        borrowsOf[account] += borrowShares;\n\n        borrows += amt;\n        asset.safeTransfer(account, amt);\n        return isFirstBorrow;\n    }\n\n    /**\n        @notice Collects a specified amount of underlying asset from an account\n        @param account Address of account\n        @param amt Amount of token to collect\n        @return bool Returns true if account has no debt\n    */\n    function collectFrom(address account, uint amt)\n        external\n        accountManagerOnly\n        returns (bool)\n    {\n        uint borrowShares;\n        require((borrowShares = convertAssetToBorrowShares(amt)) != 0, \"ZERO_BORROW_SHARES\");\n        borrowsOf[account] -= borrowShares;\n        totalBorrowShares -= borrowShares;\n\n        borrows -= amt;\n        return (borrowsOf[account] == 0);\n    }\n\n    /**\n        @notice Returns Borrow balance of given account\n        @param account Address of account\n        @return borrowBalance Amount of underlying tokens borrowed\n    */\n    function getBorrowBalance(address account) external view returns (uint) {\n        return convertBorrowSharesToAsset(borrowsOf[account]);\n    }\n\n    function getReserves() public view returns (uint) {\n        return reserves + borrows.mulWadUp(getRateFactor())\n        .mulWadUp(reserveFactor);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                              PUBLIC FUNCTIONS                              */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @notice Returns total amount of underlying assets\n            totalAssets = underlying balance + totalBorrows + delta\n            delta = totalBorrows * RateFactor\n        @return totalAssets Total amount of underlying assets\n    */\n    function totalAssets() public view override returns (uint) {\n        return asset.balanceOf(address(this)) + getBorrows() - getReserves();\n    }\n\n    function getBorrows() public view returns (uint) {\n        return borrows + borrows.mulWadUp(getRateFactor());\n    }\n\n    /// @notice Updates state of the lending pool\n    function updateState() public {\n        if (lastUpdated == block.timestamp) return;\n        uint rateFactor = getRateFactor();\n        uint interestAccrued = borrows.mulWadUp(rateFactor);\n        borrows += interestAccrued;\n        reserves += interestAccrued.mulWadUp(reserveFactor);\n        lastUpdated = block.timestamp;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             INTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @dev Rate Factor = Timestamp Delta * 1e18 (Scales timestamp delta to 18 decimals) * Interest Rate Per Block\n            Timestamp Delta = Number of seconds since last update\n    */\n    function getRateFactor() internal view returns (uint) {\n        return (block.timestamp == lastUpdated) ?\n            0 :\n            ((block.timestamp - lastUpdated)*1e18)\n            .mulWadUp(\n                rateModel.getBorrowRatePerSecond(\n                    asset.balanceOf(address(this)),\n                    borrows\n                )\n            );\n    }\n\n    function convertAssetToBorrowShares(uint amt) internal view returns (uint) {\n        uint256 supply = totalBorrowShares;\n        return supply == 0 ? amt : amt.mulDivUp(supply, getBorrows());\n    }\n\n    function convertBorrowSharesToAsset(uint debt) internal view returns (uint) {\n        uint256 supply = totalBorrowShares;\n        return supply == 0 ? debt : debt.mulDivDown(getBorrows(), supply);\n    }\n\n    function beforeDeposit(uint, uint) internal override { updateState(); }\n    function beforeWithdraw(uint, uint) internal override { updateState(); }\n\n    /* -------------------------------------------------------------------------- */\n    /*                               ADMIN FUNCTIONS                              */\n    /* -------------------------------------------------------------------------- */\n\n    function redeemReserves(uint amt) external adminOnly {\n        updateState();\n        reserves -= amt;\n        emit ReservesRedeemed(treasury, amt);\n        asset.safeTransfer(treasury, amt);\n    }\n}"
    },
    {
      "filename": "protocol/src/tokens/LToken.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {Errors} from \"../utils/Errors.sol\";\nimport {Pausable} from \"../utils/Pausable.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ERC4626} from \"./utils/ERC4626.sol\";\nimport {IRegistry} from \"../interface/core/IRegistry.sol\";\nimport {IRateModel} from \"../interface/core/IRateModel.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {ILToken} from \"../interface/tokens/ILToken.sol\";\n\n/**\n    @title Lending Token\n    @notice Lending token with ERC4626 implementation\n*/\ncontract LToken is Pausable, ERC4626, ILToken {\n    using FixedPointMathLib for uint;\n    using SafeTransferLib for ERC20;\n\n    /* -------------------------------------------------------------------------- */\n    /*                               STATE VARIABLES                              */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Utility variable to indicate if contract is initialized\n    bool private initialized;\n\n    /// @notice Registry\n    IRegistry public registry;\n\n    /// @notice Rate Model\n    IRateModel public rateModel;\n\n    /// @notice Account Manager\n    address public accountManager;\n\n    /// @notice Protocol treasury\n    address public treasury;\n\n    /// @notice Total amount of borrows\n    uint public borrows;\n\n    /// @notice Timestamp of when the state of the LToken was last updated\n    uint public lastUpdated;\n\n    /// @notice Protocol reserves\n    uint public reserves;\n\n    /// @notice Reserve factor\n    uint public reserveFactor;\n\n    /// @notice Total borrow shares minted\n    uint public totalBorrowShares;\n\n    /// @notice Mapping of account to borrow in terms of shares\n    mapping (address => uint) public borrowsOf;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   EVENTS                                   */\n    /* -------------------------------------------------------------------------- */\n\n    event ReservesRedeemed(address indexed treasury, uint amt);\n\n    /* -------------------------------------------------------------------------- */\n    /*                              CUSTOM MODIFIERS                              */\n    /* -------------------------------------------------------------------------- */\n\n    modifier accountManagerOnly() {\n        if (msg.sender != accountManager) revert Errors.AccountManagerOnly();\n        _;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             EXTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @notice Contract initialization function\n        @dev Can only be invoked once\n        @param _asset Underlying ERC20 token\n        @param _name Name of LToken\n        @param _symbol Symbol of LToken\n        @param _registry Address of Registry\n        @param _reserveFactor Borrow Fee\n        @param _treasury Protocol treasury\n    */\n    function init(\n        ERC20 _asset,\n        string calldata _name,\n        string calldata _symbol,\n        IRegistry _registry,\n        uint _reserveFactor,\n        address _treasury\n    ) external {\n        if (initialized) revert Errors.ContractAlreadyInitialized();\n\n        if (\n            address(_asset) == address(0) ||\n            address(_registry) == address(0) ||\n            _treasury == address(0)\n        ) revert Errors.ZeroAddress();\n\n        initialized = true;\n        initPausable(msg.sender);\n        initERC4626(_asset, _name, _symbol);\n        registry = _registry;\n        reserveFactor = _reserveFactor;\n        treasury = _treasury;\n    }\n\n    /**\n        @notice Initializes external dependencies\n        @param _rateModel Name of rate model contract\n    */\n    function initDep(string calldata _rateModel) external adminOnly {\n        rateModel = IRateModel(registry.getAddress(_rateModel));\n        accountManager = registry.getAddress('ACCOUNT_MANAGER');\n    }\n\n    /**\n        @notice Lends a specified amount of underlying asset to an account\n        @param account Address of account\n        @param amt Amount of token to lend\n        @return isFirstBorrow Returns if the account is borrowing the asset for\n            the first time\n    */\n    function lendTo(address account, uint amt)\n        external\n        whenNotPaused\n        accountManagerOnly\n        returns (bool isFirstBorrow)\n    {\n        updateState();\n        isFirstBorrow = (borrowsOf[account] == 0);\n\n        uint borrowShares;\n        require((borrowShares = convertAssetToBorrowShares(amt)) != 0, \"ZERO_BORROW_SHARES\");\n        totalBorrowShares += borrowShares;\n        borrowsOf[account] += borrowShares;\n\n        borrows += amt;\n        asset.safeTransfer(account, amt);\n        return isFirstBorrow;\n    }\n\n    /**\n        @notice Collects a specified amount of underlying asset from an account\n        @param account Address of account\n        @param amt Amount of token to collect\n        @return bool Returns true if account has no debt\n    */\n    function collectFrom(address account, uint amt)\n        external\n        accountManagerOnly\n        returns (bool)\n    {\n        uint borrowShares;\n        require((borrowShares = convertAssetToBorrowShares(amt)) != 0, \"ZERO_BORROW_SHARES\");\n        borrowsOf[account] -= borrowShares;\n        totalBorrowShares -= borrowShares;\n\n        borrows -= amt;\n        return (borrowsOf[account] == 0);\n    }\n\n    /**\n        @notice Returns Borrow balance of given account\n        @param account Address of account\n        @return borrowBalance Amount of underlying tokens borrowed\n    */\n    function getBorrowBalance(address account) external view returns (uint) {\n        return convertBorrowSharesToAsset(borrowsOf[account]);\n    }\n\n    function getReserves() public view returns (uint) {\n        return reserves + borrows.mulWadUp(getRateFactor())\n        .mulWadUp(reserveFactor);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                              PUBLIC FUNCTIONS                              */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @notice Returns total amount of underlying assets\n            totalAssets = underlying balance + totalBorrows + delta\n            delta = totalBorrows * RateFactor\n        @return totalAssets Total amount of underlying assets\n    */\n    function totalAssets() public view override returns (uint) {\n        return asset.balanceOf(address(this)) + getBorrows() - getReserves();\n    }\n\n    function getBorrows() public view returns (uint) {\n        return borrows + borrows.mulWadUp(getRateFactor());\n    }\n\n    /// @notice Updates state of the lending pool\n    function updateState() public {\n        if (lastUpdated == block.timestamp) return;\n        uint rateFactor = getRateFactor();\n        uint interestAccrued = borrows.mulWadUp(rateFactor);\n        borrows += interestAccrued;\n        reserves += interestAccrued.mulWadUp(reserveFactor);\n        lastUpdated = block.timestamp;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             INTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @dev Rate Factor = Timestamp Delta * 1e18 (Scales timestamp delta to 18 decimals) * Interest Rate Per Block\n            Timestamp Delta = Number of seconds since last update\n    */\n    function getRateFactor() internal view returns (uint) {\n        return (block.timestamp == lastUpdated) ?\n            0 :\n            ((block.timestamp - lastUpdated)*1e18)\n            .mulWadUp(\n                rateModel.getBorrowRatePerSecond(\n                    asset.balanceOf(address(this)),\n                    borrows\n                )\n            );\n    }\n\n    function convertAssetToBorrowShares(uint amt) internal view returns (uint) {\n        uint256 supply = totalBorrowShares;\n        return supply == 0 ? amt : amt.mulDivUp(supply, getBorrows());\n    }\n\n    function convertBorrowSharesToAsset(uint debt) internal view returns (uint) {\n        uint256 supply = totalBorrowShares;\n        return supply == 0 ? debt : debt.mulDivDown(getBorrows(), supply);\n    }\n\n    function beforeDeposit(uint, uint) internal override { updateState(); }\n    function beforeWithdraw(uint, uint) internal override { updateState(); }\n\n    /* -------------------------------------------------------------------------- */\n    /*                               ADMIN FUNCTIONS                              */\n    /* -------------------------------------------------------------------------- */\n\n    function redeemReserves(uint amt) external adminOnly {\n        updateState();\n        reserves -= amt;\n        emit ReservesRedeemed(treasury, amt);\n        asset.safeTransfer(treasury, amt);\n    }\n}"
    },
    {
      "filename": "protocol/src/tokens/LToken.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {Errors} from \"../utils/Errors.sol\";\nimport {Pausable} from \"../utils/Pausable.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ERC4626} from \"./utils/ERC4626.sol\";\nimport {IRegistry} from \"../interface/core/IRegistry.sol\";\nimport {IRateModel} from \"../interface/core/IRateModel.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {ILToken} from \"../interface/tokens/ILToken.sol\";\n\n/**\n    @title Lending Token\n    @notice Lending token with ERC4626 implementation\n*/\ncontract LToken is Pausable, ERC4626, ILToken {\n    using FixedPointMathLib for uint;\n    using SafeTransferLib for ERC20;\n\n    /* -------------------------------------------------------------------------- */\n    /*                               STATE VARIABLES                              */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Utility variable to indicate if contract is initialized\n    bool private initialized;\n\n    /// @notice Registry\n    IRegistry public registry;\n\n    /// @notice Rate Model\n    IRateModel public rateModel;\n\n    /// @notice Account Manager\n    address public accountManager;\n\n    /// @notice Protocol treasury\n    address public treasury;\n\n    /// @notice Total amount of borrows\n    uint public borrows;\n\n    /// @notice Timestamp of when the state of the LToken was last updated\n    uint public lastUpdated;\n\n    /// @notice Protocol reserves\n    uint public reserves;\n\n    /// @notice Reserve factor\n    uint public reserveFactor;\n\n    /// @notice Total borrow shares minted\n    uint public totalBorrowShares;\n\n    /// @notice Mapping of account to borrow in terms of shares\n    mapping (address => uint) public borrowsOf;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   EVENTS                                   */\n    /* -------------------------------------------------------------------------- */\n\n    event ReservesRedeemed(address indexed treasury, uint amt);\n\n    /* -------------------------------------------------------------------------- */\n    /*                              CUSTOM MODIFIERS                              */\n    /* -------------------------------------------------------------------------- */\n\n    modifier accountManagerOnly() {\n        if (msg.sender != accountManager) revert Errors.AccountManagerOnly();\n        _;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             EXTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @notice Contract initialization function\n        @dev Can only be invoked once\n        @param _asset Underlying ERC20 token\n        @param _name Name of LToken\n        @param _symbol Symbol of LToken\n        @param _registry Address of Registry\n        @param _reserveFactor Borrow Fee\n        @param _treasury Protocol treasury\n    */\n    function init(\n        ERC20 _asset,\n        string calldata _name,\n        string calldata _symbol,\n        IRegistry _registry,\n        uint _reserveFactor,\n        address _treasury\n    ) external {\n        if (initialized) revert Errors.ContractAlreadyInitialized();\n\n        if (\n            address(_asset) == address(0) ||\n            address(_registry) == address(0) ||\n            _treasury == address(0)\n        ) revert Errors.ZeroAddress();\n\n        initialized = true;\n        initPausable(msg.sender);\n        initERC4626(_asset, _name, _symbol);\n        registry = _registry;\n        reserveFactor = _reserveFactor;\n        treasury = _treasury;\n    }\n\n    /**\n        @notice Initializes external dependencies\n        @param _rateModel Name of rate model contract\n    */\n    function initDep(string calldata _rateModel) external adminOnly {\n        rateModel = IRateModel(registry.getAddress(_rateModel));\n        accountManager = registry.getAddress('ACCOUNT_MANAGER');\n    }\n\n    /**\n        @notice Lends a specified amount of underlying asset to an account\n        @param account Address of account\n        @param amt Amount of token to lend\n        @return isFirstBorrow Returns if the account is borrowing the asset for\n            the first time\n    */\n    function lendTo(address account, uint amt)\n        external\n        whenNotPaused\n        accountManagerOnly\n        returns (bool isFirstBorrow)\n    {\n        updateState();\n        isFirstBorrow = (borrowsOf[account] == 0);\n\n        uint borrowShares;\n        require((borrowShares = convertAssetToBorrowShares(amt)) != 0, \"ZERO_BORROW_SHARES\");\n        totalBorrowShares += borrowShares;\n        borrowsOf[account] += borrowShares;\n\n        borrows += amt;\n        asset.safeTransfer(account, amt);\n        return isFirstBorrow;\n    }\n\n    /**\n        @notice Collects a specified amount of underlying asset from an account\n        @param account Address of account\n        @param amt Amount of token to collect\n        @return bool Returns true if account has no debt\n    */\n    function collectFrom(address account, uint amt)\n        external\n        accountManagerOnly\n        returns (bool)\n    {\n        uint borrowShares;\n        require((borrowShares = convertAssetToBorrowShares(amt)) != 0, \"ZERO_BORROW_SHARES\");\n        borrowsOf[account] -= borrowShares;\n        totalBorrowShares -= borrowShares;\n\n        borrows -= amt;\n        return (borrowsOf[account] == 0);\n    }\n\n    /**\n        @notice Returns Borrow balance of given account\n        @param account Address of account\n        @return borrowBalance Amount of underlying tokens borrowed\n    */\n    function getBorrowBalance(address account) external view returns (uint) {\n        return convertBorrowSharesToAsset(borrowsOf[account]);\n    }\n\n    function getReserves() public view returns (uint) {\n        return reserves + borrows.mulWadUp(getRateFactor())\n        .mulWadUp(reserveFactor);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                              PUBLIC FUNCTIONS                              */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @notice Returns total amount of underlying assets\n            totalAssets = underlying balance + totalBorrows + delta\n            delta = totalBorrows * RateFactor\n        @return totalAssets Total amount of underlying assets\n    */\n    function totalAssets() public view override returns (uint) {\n        return asset.balanceOf(address(this)) + getBorrows() - getReserves();\n    }\n\n    function getBorrows() public view returns (uint) {\n        return borrows + borrows.mulWadUp(getRateFactor());\n    }\n\n    /// @notice Updates state of the lending pool\n    function updateState() public {\n        if (lastUpdated == block.timestamp) return;\n        uint rateFactor = getRateFactor();\n        uint interestAccrued = borrows.mulWadUp(rateFactor);\n        borrows += interestAccrued;\n        reserves += interestAccrued.mulWadUp(reserveFactor);\n        lastUpdated = block.timestamp;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             INTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @dev Rate Factor = Timestamp Delta * 1e18 (Scales timestamp delta to 18 decimals) * Interest Rate Per Block\n            Timestamp Delta = Number of seconds since last update\n    */\n    function getRateFactor() internal view returns (uint) {\n        return (block.timestamp == lastUpdated) ?\n            0 :\n            ((block.timestamp - lastUpdated)*1e18)\n            .mulWadUp(\n                rateModel.getBorrowRatePerSecond(\n                    asset.balanceOf(address(this)),\n                    borrows\n                )\n            );\n    }\n\n    function convertAssetToBorrowShares(uint amt) internal view returns (uint) {\n        uint256 supply = totalBorrowShares;\n        return supply == 0 ? amt : amt.mulDivUp(supply, getBorrows());\n    }\n\n    function convertBorrowSharesToAsset(uint debt) internal view returns (uint) {\n        uint256 supply = totalBorrowShares;\n        return supply == 0 ? debt : debt.mulDivDown(getBorrows(), supply);\n    }\n\n    function beforeDeposit(uint, uint) internal override { updateState(); }\n    function beforeWithdraw(uint, uint) internal override { updateState(); }\n\n    /* -------------------------------------------------------------------------- */\n    /*                               ADMIN FUNCTIONS                              */\n    /* -------------------------------------------------------------------------- */\n\n    function redeemReserves(uint amt) external adminOnly {\n        updateState();\n        reserves -= amt;\n        emit ReservesRedeemed(treasury, amt);\n        asset.safeTransfer(treasury, amt);\n    }\n}"
    },
    {
      "filename": "protocol/src/tokens/LToken.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {Errors} from \"../utils/Errors.sol\";\nimport {Pausable} from \"../utils/Pausable.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ERC4626} from \"./utils/ERC4626.sol\";\nimport {IRegistry} from \"../interface/core/IRegistry.sol\";\nimport {IRateModel} from \"../interface/core/IRateModel.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {ILToken} from \"../interface/tokens/ILToken.sol\";\n\n/**\n    @title Lending Token\n    @notice Lending token with ERC4626 implementation\n*/\ncontract LToken is Pausable, ERC4626, ILToken {\n    using FixedPointMathLib for uint;\n    using SafeTransferLib for ERC20;\n\n    /* -------------------------------------------------------------------------- */\n    /*                               STATE VARIABLES                              */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice Utility variable to indicate if contract is initialized\n    bool private initialized;\n\n    /// @notice Registry\n    IRegistry public registry;\n\n    /// @notice Rate Model\n    IRateModel public rateModel;\n\n    /// @notice Account Manager\n    address public accountManager;\n\n    /// @notice Protocol treasury\n    address public treasury;\n\n    /// @notice Total amount of borrows\n    uint public borrows;\n\n    /// @notice Timestamp of when the state of the LToken was last updated\n    uint public lastUpdated;\n\n    /// @notice Protocol reserves\n    uint public reserves;\n\n    /// @notice Reserve factor\n    uint public reserveFactor;\n\n    /// @notice Total borrow shares minted\n    uint public totalBorrowShares;\n\n    /// @notice Mapping of account to borrow in terms of shares\n    mapping (address => uint) public borrowsOf;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                   EVENTS                                   */\n    /* -------------------------------------------------------------------------- */\n\n    event ReservesRedeemed(address indexed treasury, uint amt);\n\n    /* -------------------------------------------------------------------------- */\n    /*                              CUSTOM MODIFIERS                              */\n    /* -------------------------------------------------------------------------- */\n\n    modifier accountManagerOnly() {\n        if (msg.sender != accountManager) revert Errors.AccountManagerOnly();\n        _;\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             EXTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @notice Contract initialization function\n        @dev Can only be invoked once\n        @param _asset Underlying ERC20 token\n        @param _name Name of LToken\n        @param _symbol Symbol of LToken\n        @param _registry Address of Registry\n        @param _reserveFactor Borrow Fee\n        @param _treasury Protocol treasury\n    */\n    function init(\n        ERC20 _asset,\n        string calldata _name,\n        string calldata _symbol,\n        IRegistry _registry,\n        uint _reserveFactor,\n        address _treasury\n    ) external {\n        if (initialized) revert Errors.ContractAlreadyInitialized();\n\n        if (\n            address(_asset) == address(0) ||\n            address(_registry) == address(0) ||\n            _treasury == address(0)\n        ) revert Errors.ZeroAddress();\n\n        initialized = true;\n        initPausable(msg.sender);\n        initERC4626(_asset, _name, _symbol);\n        registry = _registry;\n        reserveFactor = _reserveFactor;\n        treasury = _treasury;\n    }\n\n    /**\n        @notice Initializes external dependencies\n        @param _rateModel Name of rate model contract\n    */\n    function initDep(string calldata _rateModel) external adminOnly {\n        rateModel = IRateModel(registry.getAddress(_rateModel));\n        accountManager = registry.getAddress('ACCOUNT_MANAGER');\n    }\n\n    /**\n        @notice Lends a specified amount of underlying asset to an account\n        @param account Address of account\n        @param amt Amount of token to lend\n        @return isFirstBorrow Returns if the account is borrowing the asset for\n            the first time\n    */\n    function lendTo(address account, uint amt)\n        external\n        whenNotPaused\n        accountManagerOnly\n        returns (bool isFirstBorrow)\n    {\n        updateState();\n        isFirstBorrow = (borrowsOf[account] == 0);\n\n        uint borrowShares;\n        require((borrowShares = convertAssetToBorrowShares(amt)) != 0, \"ZERO_BORROW_SHARES\");\n        totalBorrowShares += borrowShares;\n        borrowsOf[account] += borrowShares;\n\n        borrows += amt;\n        asset.safeTransfer(account, amt);\n        return isFirstBorrow;\n    }\n\n    /**\n        @notice Collects a specified amount of underlying asset from an account\n        @param account Address of account\n        @param amt Amount of token t"
    }
  ]
}