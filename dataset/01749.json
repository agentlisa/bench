{
  "Title": "M-8: Operator is blocked when sequencer is down on Arbitrum",
  "Content": "# Issue M-8: Operator is blocked when sequencer is down on Arbitrum \n\nSource: https://github.com/sherlock-audit/2023-05-Index-judging/issues/321 \n\n## Found by \nhildingr\n## Summary\nWhen the sequencer is down on Arbitrum state changes can still happen on L2 by passing them from L1 through the Delayed Inbox.\n\nUsers can still interact with the Index protocol but due to how Arbitrum address aliasing functions the operator will be blocked from calling onlyOperator().\n\n## Vulnerability Detail\n\nThe `msg.sender` of a transaction from the Delayed Inbox is aliased:\n\n```solidity\nL2_Alias = L1_Contract_Address + 0x1111000000000000000000000000000000001111\n```\n\nAll functions with the `onlyOperator()` modifier are therefore blocked when the sequencer is down.\n\nThe issue exists for all modifiers that are only callable by specific EOAs. But the operator of the Aave3LeverageStrategyExtension is the main security risk.\n\n## Impact\n\nThe operator has roles that are vital for the safety of the protocol. Re-balancing and issuing/redeeming can still be done when the sequencer is down it is therefore important that the operator call the necessary functions to operate the protocol when the sequencer is down. \n\n`disengage()` is an important safety function that the operator should always have access especially when the protocol is still in accessible to other users. Changing methodology and adding/removing exchanges are also important for the safety of the protocol. \n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/manager/BaseManagerV2.sol#L113-L116\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nChange the `onlyOperator()` to check if the address is the aliased address of the operator.\n\n\n\n\n## Discussion\n\n**hildingr**\n\nEscalate for 10 USDC\n\nThis is not a duplicate off #262 and should be a separate issue. \n\nThis is not about a check if a sequencer is down but rather a peculiarity on how Arbitrum aliases addresses. On the other L2s the manager is still able to reach all functions when the sequencer is down since the aliasing is not done on EOA's initiating a L1->L2 call.\n\nOn Arbitrum this is not the case and the manager/operators are completely blocked from controlling the protocol when the sequencer is down. \n\nAs it stands on the other L2's the manager/operators can still govern over the protocol and use all the available safety features if the sequencer is down. As it stands this is not possible on Arbitrum.\n\nLow probability event where it would be crucial for operator/manager to have access:\n\nSequencer is down for a prolonged time this could be some kind of attack or a technical issue, couple this with volatility in the market either due to the issues with the sequencer or unrelated. The governance should be able to change the safe parameters of position during such an event. \n\nThe recommended changes in the duplicates actually makes this worse in some cases since repaying debt is completely blocked when the sequencer is down. This is not the case for normal AAVE users which always have the ability to repay loans, this is an important safety feature guaranteed by AAVE.\n\nThis can be taken further if the Index Team wishes to have the same safety level as a native AAVE user.\n\nNew functionality can be  added to allow the operator to repay debt and de-leverage when the sequencer is down. This is a safety feature available to all AAVE users, AAVE users are never blocked from repaying debt but only from taking out additional loans when the sequencer is down. \n\nThis can be done by allowing a new operator L1Operator to access a new rebalancing feature, this L1Operator is a L1 smart-contract that uses L1 oracle data to initiate a L2 repayment of debt and rebalance when the sequencer is down.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> This is not a duplicate off #262 and should be a separate issue. \n> \n> This is not about a check if a sequencer is down but rather a peculiarity on how Arbitrum aliases addresses. On the other L2s the manager is still able to reach all functions when the sequencer is down since the aliasing is not done on EOA's initiating a L1->L2 call.\n> \n> On Arbitrum this is not the case and the manager/operators are completely blocked from controlling the protocol when the sequencer is down. \n> \n> As it stands on the other L2's the manager/operators can still govern over the protocol and use all the available safety features if the sequencer is down. As it stands this is not possible on Arbitrum.\n> \n> Low probability event where it would be crucial for operator/manager to have access:\n> \n> Sequencer is down for a prolonged time this could be some kind of attack or a technical issue, couple this with volatility in the market either due to the issues with the sequencer or unrelated. The governance should be able to change the safe parameters of position during such an event. \n> \n> The recommended changes in the duplicates actually makes this worse in some cases since repaying debt is completely blocked when the sequencer is down. This is not the case for normal AAVE users which always have the ability to repay loans, this is an important safety feature guaranteed by AAVE.\n> \n> This can be taken further if the Index Team wishes to have the same safety level as a native AAVE user.\n> \n> New functionality can be  added to allow the operator to repay debt and de-leverage when the sequencer is down. This is a safety feature available to all AAVE users, AAVE users are never blocked from repaying debt but only from taking out additional loans when the sequencer is down. \n> \n> This can be done by allowing a new operator L1Operator to access a new rebalancing feature, this L1Operator is a L1 smart-contract that uses L1 oracle data to initiate a L2 repayment of debt and rebalance when the sequencer is down.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**0xffff11**\n\nThanks. I think the changes of this happening are slim to non. Sequencer has to be down and at the same time the operator rebalance. Also, I the operator is a multisig, not an EOA, unsure if that makes any difference, but still, I do not see the medium here. @IAm0x52 thoughts? \n\n**IAm0x52**\n\nDue to the ripcord function always being available to prevent set token liquidation, low seems more appropriate to me.\n\n**0xffff11**\n\nThanks for the second opinion. As said above, I agree with low\n\n**hrishibhat**\n\nAgree with the Lead Judge and Watson on this being low\n@hildingr \n\n**hildingr**\n\nI will have to disagree here. The ripcord can not be trusted when the sequencer is down. The price could move in either direction while the Oracle price is stale.\n\nImagine if the price is moving in a direction that would allow a ripcord pull, the ripcord can not be pulled since the oracle has the stale price. \n\nOn optimism and polygon the operator can call disengage() and stop the protocol from going above the max liquidation ratio. On Arbitrum this is not possible and the position can go way beyond the max LTV without being able to delever. The position could even get liquidated before ripcord or disengage can be called. If  0.95 < HF < 1 the position can be instantly liquidated when the sequencer comes back up since no grace period is given to heavily undercollateralized positions.\n\n**ckoopmann**\n\nI don't have a strong opinion on wether this is low or medium so will leave it up to the lead watson / judge to decide.\n\nSince we are not planning to deploy on arbitrum for now we will not act on this issue for now, but will review should we deploy this there in the future. \n\n**hrishibhat**\n\n@hildingr \nAdditional comment from the Lead watson.\n> The key consideration here is that the main intention here is to keep the set token from becoming liquidated. So it doesn't really matter what the oracle is at whether it's stale or completely wrong. As long as the oracle being used by the set token matches AAVE then that's all that matters. So as I've stated, ripcord will always protect the set token so this is low\n\n**hildingr**\n\n> @hildingr Additional comment from the Lead watson.\n> \n> > The key consideration here is that the main intention here is to keep the set token from becoming liquidated. So it doesn't really matter what the oracle is at whether it's stale or completely wrong. As long as the oracle being used by the set token matches AAVE then that's all that matters. So as I've stated, ripcord will always protect the set token so this is low\n\nI disagree, the ripcord will not always protect the position. I will give a concrete example:\n\nStage 1, the sequencer is up: HF = 1.5 \n\nStage 2, the sequencer is down: HF is -> 1. ripcord can not be pulled due to incorrect internal LTV.\n\nStage 3, sequencer still down: HF < 0.95. \n\nStage 4, the moment the sequencer comes up: Race condition between instant liquidation and pulling the ripcord. This is because HF < 0.95 and no grace period is given by the AAVE sentinel.\n\nThe true LTV always matters even if AAVE and Index use the same stale oracle. We can look at it as a discontinuity in the LTV, when the seq is down it is \"unknown\" to both protocols but in the instant the sequencer comes back the LTV jumps to the true value. The true LTV can be in very dangerous territory, possibly high enough for instant liquidation.\n\n**IAm0x52**\n\n> Stage 4, the moment the sequencer comes up: Race condition between instant liquidation and pulling the ripcord. This is because HF < 0.95 and no grace period is given by the AAVE sentinel.\n\nThis is correct. it would create race conditions under these circumstances \n\n\n\n**hrishibhat**\n\nResult:\nMedium\nUnique\nConsidering this a valid medium based on the above comments \n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [hildingr](https://github.com/sherlock-audit/2023-05-Index-judging/issues/321/#issuecomment-1613336884): accepted\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/81",
  "Code": [
    {
      "filename": "index-coop-smart-contracts/contracts/manager/BaseManagerV2.sol",
      "content": "/*\n    Copyright 2021 Set Labs Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache License, Version 2.0\n*/\n\npragma solidity 0.6.10;\npragma experimental ABIEncoderV2;\n\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport { AddressArrayUtils } from \"../lib/AddressArrayUtils.sol\";\nimport { IExtension } from \"../interfaces/IExtension.sol\";\nimport { ISetToken } from \"../interfaces/ISetToken.sol\";\nimport { MutualUpgrade } from \"../lib/MutualUpgrade.sol\";\n\n\n/**\n * @title BaseManagerV2\n * @author Set Protocol\n *\n * Smart contract manager that contains permissions and admin functionality. Implements IIP-64, supporting\n * a registry of protected modules that can only be upgraded with methodologist consent.\n */\ncontract BaseManagerV2 is MutualUpgrade {\n    using Address for address;\n    using AddressArrayUtils for address[];\n    using SafeERC20 for IERC20;\n\n    /* ============ Struct ========== */\n\n    struct ProtectedModule {\n        bool isProtected;                               // Flag set to true if module is protected\n        address[] authorizedExtensionsList;             // List of Extensions authorized to call module\n        mapping(address => bool) authorizedExtensions;  // Map of extensions authorized to call module\n    }\n\n    /* ============ Events ============ */\n\n    event ExtensionAdded(\n        address _extension\n    );\n\n    event ExtensionRemoved(\n        address _extension\n    );\n\n    event MethodologistChanged(\n        address _oldMethodologist,\n        address _newMethodologist\n    );\n\n    event OperatorChanged(\n        address _oldOperator,\n        address _newOperator\n    );\n\n    event ExtensionAuthorized(\n        address _module,\n        address _extension\n    );\n\n    event ExtensionAuthorizationRevoked(\n        address _module,\n        address _extension\n    );\n\n    event ModuleProtected(\n        address _module,\n        address[] _extensions\n    );\n\n    event ModuleUnprotected(\n        address _module\n    );\n\n    event ReplacedProtectedModule(\n        address _oldModule,\n        address _newModule,\n        address[] _newExtensions\n    );\n\n    event EmergencyReplacedProtectedModule(\n        address _module,\n        address[] _extensions\n    );\n\n    event EmergencyRemovedProtectedModule(\n        address _module\n    );\n\n    event EmergencyResolved();\n\n    /* ============ Modifiers ============ */\n\n    /**\n     * Throws if the sender is not the SetToken operator\n     */\n    modifier onlyOperator() {\n        require(msg.sender == operator, \"Must be operator\");\n        _;\n    }\n\n    /**\n     * Throws if the sender is not the SetToken methodologist\n     */\n    modifier onlyMethodologist() {\n        require(msg.sender == methodologist, \"Must be methodologist\");\n        _;\n    }\n\n    /**\n     * Throws if the sender is not a listed extension\n     */\n    modifier onlyExtension() {\n        require(isExtension[msg.sender], \"Must be extension\");\n        _;\n    }\n\n    /**\n     * Throws if contract is in an emergency state following a unilateral operator removal of a\n     * protected module.\n     */\n    modifier upgradesPermitted() {\n        require(emergencies == 0, \"Upgrades paused by emergency\");\n        _;\n    }\n\n    /**\n     * Throws if contract is *not* in an emergency state. Emergency replacement and resolution\n     * can only happen in an emergency\n     */\n    modifier onlyEmergency() {\n        require(emergencies > 0, \"Not in emergency\");\n        _;\n    }\n\n    /* ============ State Variables ============ */\n\n    // Instance of SetToken\n    ISetToken public setToken;\n\n    // Array of listed extensions\n    address[] internal extensions;\n\n    // Mapping to check if extension is added\n    mapping(address => bool) public isExtension;\n\n    // Address of operator which typically executes manager only functions on Set Protocol modules\n    address public operator;\n\n    // Address of methodologist which serves as providing methodology for the index\n    address public methodologist;\n\n    // Counter incremented when the operator \"emergency removes\" a protected module. Decremented\n    // when methodologist executes an \"emergency replacement\". Operator can only add modules and\n    // extensions when `emergencies` is zero. Emergencies can only be declared \"over\" by mutual agreement\n    // between operator and methodologist or by the methodologist alone via `resolveEmergency`\n    uint256 public emergencies;\n\n    // Mapping of protected modules. These cannot be called or removed except by mutual upgrade.\n    mapping(address => ProtectedModule) public protectedModules;\n\n    // List of protected modules, for iteration. Used when checking that an extension removal\n    // can happen without methodologist approval\n    address[] public protectedModulesList;\n\n    // Boolean set when methodologist authorizes initialization after contract deployment.\n    // Must be true to call via `interactManager`.\n    bool public initialized;\n\n    /* ============ Constructor ============ */\n\n    constructor(\n        ISetToken _setToken,\n        address _operator,\n        address _methodologist\n    )\n        public\n    {\n        setToken = _setToken;\n        operator = _operator;\n        methodologist = _methodologist;\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * ONLY METHODOLOGIST : Called by the methodologist to enable contract. All `interactManager`\n     * calls revert until this is invoked. Lets methodologist review and authorize initial protected\n     * module settings.\n     */\n    function authorizeInitialization() external onlyMethodologist {\n        require(!initialized, \"Initialization authorized\");\n        initialized = true;\n    }\n\n    /**\n     * MUTUAL UPGRADE: Update the SetToken manager address. Operator and Methodologist must each call\n     * this function to execute the update.\n     *\n     * @param _newManager           New manager address\n     */\n    function setManager(address _newManager) external mutualUpgrade(operator, methodologist) {\n        require(_newManager != address(0), \"Zero address not valid\");\n        setToken.setManager(_newManager);\n    }\n\n    /**\n     * OPERATOR ONLY: Add a new extension that the BaseManager can call.\n     *\n     * @param _extension           New extension to add\n     */\n    function addExtension(address _extension) external upgradesPermitted onlyOperator {\n        require(!isExtension[_extension], \"Extension already exists\");\n        require(address(IExtension(_extension).manager()) == address(this), \"Extension manager invalid\");\n\n        _addExtension(_extension);\n    }\n\n    /**\n     * OPERATOR ONLY: Remove an existing extension tracked by the BaseManager.\n     *\n     * @param _extension           Old extension to remove\n     */\n    function removeExtension(address _extension) external onlyOperator {\n        require(isExtension[_extension], \"Extension does not exist\");\n        require(!_isAuthorizedExtension(_extension), \"Extension used by protected module\");\n\n        extensions.removeStorage(_extension);\n\n        isExtension[_extension] = false;\n\n        emit ExtensionRemoved(_extension);\n    }\n\n    /**\n     * MUTUAL UPGRADE: Authorizes an extension for a protected module. Operator and Methodologist must\n     * each call this function to execute the update. Adds extension to manager if not already present.\n     *\n     * @param _module           Module to authorize extension for\n     * @param _extension          Extension to authorize for module\n     */\n    function authorizeExtension(address _module, address _extension)\n        external\n        mutualUpgrade(operator, methodologist)\n    {\n        require(protectedModules[_module].isProtected, \"Module not protected\");\n        require(!protectedModules[_module].authorizedExtensions[_extension], \"Extension already authorized\");\n\n        _authorizeExtension(_module, _extension);\n\n        emit ExtensionAuthorized(_module, _extension);\n    }\n\n    /**\n     * MUTUAL UPGRADE: Revokes extension authorization for a protected module. Operator and Methodologist\n     * must each call this function to execute the update. In order to remove the extension completely\n     * from the contract removeExtension must be called by the operator.\n     *\n     * @param _module           Module to revoke extension authorization for\n     * @param _extension          Extension to revoke authorization of\n     */\n    function revokeExtensionAuthorization(address _module, address _extension)\n        external\n        mutualUpgrade(operator, methodologist)\n    {\n        require(protectedModules[_module].isProtected, \"Module not protected\");\n        require(isExtension[_extension], \"Extension does not exist\");\n        require(protectedModules[_module].authorizedExtensions[_extension], \"Extension not authorized\");\n\n        protectedModules[_module].authorizedExtensions[_extension] = false;\n        protectedModules[_module].authorizedExtensionsList.removeStorage(_extension);\n\n        emit ExtensionAuthorizationRevoked(_module, _extension);\n    }\n\n    /**\n     * ADAPTER ONLY: Interact with a module registered on the SetToken. Manager initialization must\n     * have been authorized by methodologist. Extension making this call must be authorized\n     * to call module if module is protected.\n     *\n     * @param _module           Module to interact with\n     * @param _data             Byte data of function to call in module\n     */\n    function interactManager(address _module, bytes memory _data) external onlyExtension {\n        require(initialized, \"Manager not initialized\");\n        require(_module != address(setToken), \"Extensions cannot call SetToken\");\n        require(_senderAuthorizedForModule(_module, msg.sender), \"Extension not authorized for module\");\n\n        // Invoke call to module, assume value will always be 0\n        _module.functionCallWithValue(_data, 0);\n    }\n\n    /**\n     * OPERATOR ONLY: Transfers _tokens held by the manager to _destination. Can be used to\n     * recover anything sent here accidentally. In BaseManagerV2, extensions should\n     * be the only contracts designated as `feeRecipient` in fee modules.\n     *\n     * @param _token           ERC20 token to send\n     * @param _destination     Address receiving the tokens\n     * @param _amount          Quantity of tokens to send\n     */\n    function transferTokens(address _token, address _destination, uint256 _amount) external onlyExtension {\n        IERC20(_token).safeTransfer(_destination, _amount);\n    }\n\n    /**\n     * OPERATOR ONLY: Add a new module to the SetToken.\n     *\n     * @param _module           New module to add\n     */\n    function addModule(address _module) external upgradesPermitted onlyOperator {\n        setToken.addModule(_module);\n    }\n\n    /**\n     * OPERATOR ONLY: Remove a new module from the SetToken. Any extensions associated with this\n     * module need to be removed in separate transactions via removeExtension.\n     *\n     * @param _module           Module to remove\n     */\n    function removeModule(address _module) external onlyOperator {\n        require(!protectedModules[_module].isProtected, \"Module protected\");\n        setToken.removeModule(_module);\n    }\n\n    /**\n     * OPERATOR ONLY: Marks a currently protected module as unprotected and deletes its authorized\n     * extension registries. Removes module from the SetToken. Increments the `emergencies` counter,\n     * prohibiting any operator-only module or extension additions until `emergencyReplaceProtectedModule`\n     * is executed or `resolveEmergency` is called by the methodologist.\n     *\n     * Called by operator when a module must be removed immediately for security reasons and it's unsafe\n     * to wait for a `mutualUpgrade` process to play out.\n     *\n     * NOTE: If removing a fee module, you can ensure all fees are distributed by calling distribute\n     * on the module's de-authorized fee extension after this call.\n     *\n     * @param _module           Module to remove\n     */\n    function emergencyRemoveProtectedModule(address _module) external onlyOperator {\n        _unProtectModule(_module);\n        setToken.removeModule(_module);\n        emergencies += 1;\n\n        emit EmergencyRemovedProtectedModule(_module);\n    }\n\n    /**\n     * OPERATOR ONLY: Marks an existing module as protected and authorizes extensions for\n     * it, adding them if necessary. Adds module to the protected modules list\n     *\n     * The operator uses this when they're adding new features and want to assure the methodologist\n     * they won't be unilaterally changed in the future. Cannot be called during an emergency because\n     * methodologist needs to explicitly approve protection arrangements under those conditions.\n     *\n     * NOTE: If adding a fee extension while protecting a fee module, it's important to set the\n     * module `feeRecipient` to the new extension's address (ideally before this call).\n     *\n     * @param  _module          Module to protect\n     * @param  _extensions        Array of extensions to authorize for protected module\n     */\n    function protectModule(address _module, address[] memory _extensions)\n        external\n        upgradesPermitted\n        onlyOperator\n    {\n        require(setToken.getModules().contains(_module), \"Module not added yet\");\n        _protectModule(_module, _extensions);\n\n        emit ModuleProtected(_module, _extensions);\n    }\n\n    /**\n     * METHODOLOGIST ONLY: Marks a currently protected module as unprotected and deletes its authorized\n     * extension registries. Removes old module from the protected modules list.\n     *\n     * Called by the methodologist when they want to cede control over a protected module without triggering\n     * an emergency (for example, to remove it because its dead).\n     *\n     * @param  _module          Module to revoke protections for\n     */\n    function unProtectModule(address _module) external onlyMethodologist {\n        _unProtectModule(_module);\n\n        emit ModuleUnprotected(_module);\n    }\n\n    /**\n     * MUTUAL UPGRADE: Replaces a protected module. Operator and Methodologist must each call this\n     * function to execute the update.\n     *\n     * > Marks a currently protected module as unprotected\n     * > Deletes its authorized extension registries.\n     * > Removes old module from SetToken.\n     * > Adds new module to SetToken.\n     * > Marks `_newModule` as protected and authorizes new extensions for it.\n     *\n     * Used when methodologists wants to guarantee that an existing protection arrangement is replaced\n     * with a suitable substitute (ex: upgrading a StreamingFeeSplitExtension).\n     *\n     * NOTE: If replacing a fee module, it's necessary to set the module `feeRecipient` to be\n     * the new fee extension address after this call. Any fees remaining in the old module's\n     * de-authorized extensions can be distributed by calling `distribute()` on the old extension.\n     *\n     * @param _oldModule        Module to remove\n     * @param _newModule        Module to add in place of removed module\n     * @param _newExtensions      Extensions to authorize for new module\n     */\n    function replaceProtectedModule(address _oldModule, address _newModule, address[] memory _newExtensions)\n        external\n        mutualUpgrade(operator, methodologist)\n    {\n        _unProtectModule(_oldModule);\n\n        setToken.removeModule(_oldModule);\n        setToken.addModule(_newModule);\n\n        _protectModule(_newModule, _newExtensions);\n\n        emit ReplacedProtectedModule(_oldModule, _newModule, _newExtensions);\n    }\n\n    /**\n     * MUTUAL UPGRADE & EMERGENCY ONLY: Replaces a module the operator has removed with\n     * `emergencyRemoveProtectedModule`. Operator and Methodologist must each call this function to\n     *  execute the update.\n     *\n     * > Adds new module to SetToken.\n     * > Marks `_newModule` as protected and authorizes new extensions for it.\n     * > Adds `_newModule` to protectedModules list.\n     * > Decrements the emergencies counter,\n     *\n     * Used when methodologist wants to guarantee that a protection arrangement which was\n     * removed in an emergency is replaced with a suitable substitute. Operator's ability to add modules\n     * or extensions is restored after invoking this method (if this is the only emergency.)\n     *\n     * NOTE: If replacing a fee module, it's necessary to set the module `feeRecipient` to be\n     * the new fee extension address after this call. Any fees remaining in the old module's\n     * de-authorized extensions can be distributed by calling `accrueFeesAndDistribute` on the old extension.\n     *\n     * @param _module          Module to add in place of removed module\n     * @param _extensions      Array of extensions to authorize for replacement module\n     */\n    function emergencyReplaceProtectedModule(\n        address _module,\n        address[] memory _extensions\n    )\n        external\n        mutualUpgrade(operator, methodologist)\n        onlyEmergency\n    {\n        setToken.addModule(_module);\n        _protectModule(_module, _extensions);\n\n        emergencies -= 1;\n\n        emit EmergencyReplacedProtectedModule(_module, _extensions);\n    }\n\n    /**\n     * METHODOLOGIST ONLY & EMERGENCY ONLY: Decrements the emergencies counter.\n     *\n     * Allows a methodologist to exit a state of emergency without replacing a protected module that\n     * was removed. This could happen if the module has no viable substitute or operator and methodologist\n     * agree that restoring normal operations is the best way forward.\n     */\n    function resolveEmergency() external onlyMethodologist onlyEmergency {\n        emergencies -= 1;\n\n        emit EmergencyResolved();\n    }\n\n    /**\n     * METHODOLOGIST ONLY: Update the methodologist address\n     *\n     * @param _newMethodologist           New methodologist address\n     */\n    function setMethodologist(address _newMethodologist) external onlyMethodologist {\n        emit MethodologistChanged(methodologist, _newMethodologist);\n\n        methodologist = _newMethodologist;\n    }\n\n    /**\n     * OPERATOR ONLY: Update the operator address\n     *\n     * @param _newOperator           New operator address\n     */\n    function setOperator(address _newOperator) external onlyOperator {\n        emit OperatorChanged(operator, _newOperator);\n\n        operator = _newOperator;\n    }\n\n    /* ============ External Getters ============ */\n\n    function getExtensions() external view returns(address[] memory) {\n        return extensions;\n    }\n\n    function getAuthorizedExtensions(address _module) external view returns (address[] memory) {\n        return protectedModules[_module].authorizedExtensionsList;\n    }\n\n    function isAuthorizedExtension(address _module, address _extension) external view returns (bool) {\n        return protectedModules[_module].authorizedExtensions[_extension];\n    }\n\n    function getProtectedModules() external view returns (address[] memory) {\n        return protectedModulesList;\n    }\n\n    /* ============ Internal ============ */\n\n\n    /**\n     * Add a new extension that the BaseManager can call.\n     */\n    function _addExtension(address _extension) internal {\n        extensions.push(_extension);\n\n        isExtension[_extension] = true;\n\n        emit ExtensionAdded(_extension);\n    }\n\n    /**\n     * Marks a currently protected module as unprotected and deletes it from authorized extension\n     * registries. Removes module from the SetToken.\n     */\n    function _unProtectModule(address _module) internal {\n        require(protectedModules[_module].isProtected, \"Module not protected\");\n\n        // Clear mapping and array entries in struct before deleting mapping entry\n        for (uint256 i = 0; i < protectedModules[_module].authorizedExtensionsList.length; i++) {\n            address extension = protectedModules[_module].authorizedExtensionsList[i];\n            protectedModules[_module].authorizedExtensions[extension] = false;\n        }\n\n        delete protectedModules[_module];\n\n        protectedModulesList.removeStorage(_module);\n    }\n\n    /**\n     * Adds new module to SetToken. Marks `_newModule` as protected and authorizes\n     * new extensions for it. Adds `_newModule` module to protectedModules list.\n     */\n    function _protectModule(address _module, address[] memory _extensions) internal {\n        require(!protectedModules[_module].isProtected, \"Module already protected\");\n\n        protectedModules[_module].isProtected = true;\n        protectedModulesList.push(_module);\n\n        for (uint i = 0; i < _extensions.length; i++) {\n            _authorizeExtension(_module, _extensions[i]);\n        }\n    }\n\n    /**\n     * Adds extension if not already added and marks extension as authorized for module\n     */\n    function _authorizeExtension(address _module, address _extension) internal {\n        if (!isExtension[_extension]) {\n            _addExtension(_extension);\n        }\n\n        protectedModules[_module].authorizedExtensions[_extension] = true;\n        protectedModules[_module].authorizedExtensionsList.push(_extension);\n    }\n\n    /**\n     * Searches the extension mappings of each protected modules to determine if an extension\n     * is authorized by any of them. Authorized extensions cannot be unilaterally removed by\n     * the operator.\n     */\n    function _isAuthorizedExtension(address _extension) internal view returns (bool) {\n        for (uint256 i = 0; i < protectedModulesList.length; i++) {\n            if (protectedModules[protectedModulesList[i]].authorizedExtensions[_extension]) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks if `_sender` (an extension) is allowed to call a module (which may be protected)\n     */\n    function _senderAuthorizedForModule(address _module, address _sender) internal view returns (bool) {\n        if (protectedModules[_module].isProtected) {\n            return protectedModules[_module].authorizedExtensions[_sender];\n        }\n\n        return true;\n    }\n}"
    }
  ]
}