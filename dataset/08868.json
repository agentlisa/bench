{
  "Title": "[M-02] The first AMM Staker will have control over how the shares are calculated.",
  "Content": "_Submitted by 0xNineDec_\n\n<https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L147>\n\n<https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L154>\n\n### Impact\n\nThe first staker can take control of how the subsequent shares are going to be distributed by simply staking 1wei amount of the token and frontrunning future stakers. The reasons of this are related on how the variables are updated and with the amounts that the Gauge allows users to stake (anything but zero). The origin of this vulnerability relies on the evaluation of the `totalStaked` variable on its inception.\n\n### Proof of Concept\n\nTo illustrate this attack, an environment of testing was made in order to track the token flows and how the variables are being updated and read.\n\nThe initial or border conditions taken into account are the same as the ones used by the team to perform the tests and just a few assumptions and simplifications were taken.\n\n1.  The inflation rate is fixed for simplicity (`0.001`). This is valid within a short period of time because it is not a function of how the tokens are distributed or their flows. By tracking how the inflation rate is calculated an updated, we see that it is managed by the `currentInflationAmountAmm` within the [`Minter.sol` contract](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L184), which value is modified by `_executeInflationRateUpdate()` three lines below the last code permalink. Its value depends on non-token balance related parameters (such as inflation decays and annual rates).\n2.  For the testing environment performed by the team, a DummyERC20 was used as testing token. The same is done on the exploit environment.\n3.  The controller is not used because it is used to retrieve the inflation rate and it is now fixed because of 1).\n\nEach user state is updated whenever he calls either `stake`, `unstake` or `claimRewards`.\n\nSteps:\n\n*   Alice is the first staker and deposits 1wei worth of DummyERC20.\n*   Bob takes one day to find out this new protocol and decides to stake 10 ETH amount of tokens (`10 * 10**decimals()`).\n*   Alice, who was scanning the mempool, frontruns Bob with the same amount he was willing to stake. Her txn is mined first.\n*   Then Bobs' transaction is mined for the 10 ETH worth.\n*   Sometime after this, the pool is checkpointed.\n*   A few days pass, and Bob wants to stake even more tokens. The same amount as before.\n*   Alice frontruns him again updating her shares.\n*   Bobs' transaction is mined and his shares are also updated.\n*   The pool is checkpointed again. And Alice managed to increase considerably her amount of shares.\n\nBoth cases were evaluated (with and without staking 1 wei first). The attack scenario outputs a 100% more shares to Alice than Bob in comparison with the ethical/non-attack situation.\n\nThe code used to perform this test is the following:\n\n    it(\"First Depositer Exploit\", async function () {\n            let userShares = []\n            let userIntegral = []\n            let userBalance = []\n\n            let globalIntegral, totalStaked;\n            let aliceBob = [alice, bob];\n\n            // Starting Checkpoint\n            await this.ammgauge.poolCheckpoint();\n            await ethers.provider.send(\"evm_increaseTime\", [1 * 24 * 60 * 60]); // 10 days\n            \n            const updateStates = async () => { \n                userShares = []\n                userIntegral = []\n                userBalance = []\n                for (const user of aliceBob) {\n                    let balances = ethers.utils.formatEther(await this.ammgauge.balances(user.address));\n                    let currentShare = ethers.utils.formatEther(await this.ammgauge.perUserShare(user.address));\n                    let currentStakedIntegral = ethers.utils.formatEther(await this.ammgauge.perUserStakedIntegral(user.address));\n                    userShares.push(currentShare);\n                    userIntegral.push(currentStakedIntegral);\n                    userBalance.push(balances);\n                }\n                globalIntegral = await this.ammgauge.ammStakedIntegral()\n                totalStaked = await this.ammgauge.totalStaked()\n                console.log(\"  \")\n                console.log(\"         ALICE / BOB\");\n                console.log(`Shares: ${userShares}`);\n                console.log(`Integr: ${userIntegral}`);\n                console.log(`Balanc: ${userBalance}`);\n                console.log(\"  \")\n                console.log(\"Global\")\n                console.log(`Integral: ${ethers.utils.formatEther(globalIntegral)}, TotalStaked: ${ethers.utils.formatEther(totalStaked)}`)\n            }\n\n            const stake = async (to, amount) => {\n                await updateStates()\n                console.log(\" \")\n                // Balance before\n                let balanceBefore = await this.ammgauge.balances(to.address);\n                // Stake\n                await this.ammgauge.connect(to).stake(amount);\n                expect(await this.ammgauge.balances(to.address)).to.be.eq(balanceBefore.add(amount));\n                // await updateStates();\n                console.log(\" \")\n            }\n\n            const unstake = async (to, amount) => {\n                await updateStates()\n                console.log(\" \")\n                // Balance before\n                let balanceBefore = await this.ammgauge.balances(to.address);\n                // Stake\n                await this.ammgauge.connect(to).unstake(amount);\n                expect(await this.ammgauge.balances(to.address)).to.be.eq(balanceBefore.sub(amount));\n                await updateStates();\n                console.log(\" \")\n            }\n\n            // HERE IS WHERE THE SIMULATION IS PERFORMED\n            let simulationTimes = 2;\n            let withOneWeiDeposit = true;\n\n            if (withOneWeiDeposit) {\n                // Alice deposits first\n                console.log(\"Alice Deposits 1wei\")\n                let firstUserDeposit = ethers.utils.parseEther(\"1\");\n                await stake(alice, 1);\n            }\n\n            for (let index = 1; index <= simulationTimes; index++) {\n                console.log(\" \")\n                console.log(`Loop number ${index}`);\n                console.log(\" \")\n\n                console.log(\"A day passes until Bob decides to deposit\")\n                await ethers.provider.send(\"evm_increaseTime\", [1 * 24 * 60 * 60]); // 1 days\n\n                console.log(\" \")\n                console.log(\"She scans that Bob is about to stake 10. So decides to frontrun him.\")\n                console.log(\"Alice Frontruns\")\n                let frontrunAmount = ethers.utils.parseEther(\"10\");\n                await stake(alice, frontrunAmount);\n\n                console.log(\" \")\n                console.log(\"Bob stakes 10 tokens\")\n                await stake(bob, frontrunAmount)\n\n                // A few days pass\n                await ethers.provider.send(\"evm_increaseTime\", [1 * 24 * 60 * 60]); // 2 days\n                // The pool is checkpointed\n                await this.ammgauge.poolCheckpoint();\n                console.log(\"After 1 day the pool is checkpointed\")\n                await updateStates()\n\n            }\n        })\n\nThe simulation was both made for the attacked and non attacked situations.\nThe values that are shown represent how the contract updates them (the `totalStaked` variable is 0 when first Alice calls the stake function after `_userCheckpoint()` rans)\n\n#### WITH 1WEI STAKE (ATTACK)\n\n| time |                Situation               |  totalStaked  | Alice Shares | Bob Shares |\n| :--: | :------------------------------------: | :-----------: | :----------: | :--------: |\n|  0-  |          First poolCheckpoint          |       0       |       0      |      0     |\n|  0+  |           Alice Deposits 1wei          |       0       |       0      |      0     |\n|   1  |       Alice frontruns Bob @ 10eth      |      1wei     |       0      |      0     |\n|   2  |         Bob 10eth txn is mined         |  10eth + 1wei |     86.4     |      0     |\n|   3  | 1 day later poolCheckpoint() is called | 20eth + 1 wei |     86.4     |      0     |\n|   4  |        Alice frontruns Bob again       | 20eth + 1 wei |     86.4     |      0     |\n|   5  |         Bob 10eth txn is mined         |  30eth + 1wei |     172.8    |      0     |\n|   6  | 1 day later poolCheckpoint() is called |  40eth + 1wei |     172.8    |    86.4    |\n\n#### WITHOUT THE 1WEI STAKE (No \"first staker hijack\")\n\n| time |                Situation               | totalStaked | Alice Shares | Bob Shares |\n| :--: | :------------------------------------: | :---------: | :----------: | :--------: |\n|  0-  |          First poolCheckpoint          |      0      |       0      |      0     |\n|  0+  |           Alice stakes 10eth           |      0      |       0      |      0     |\n|   1  |            Bob stakes 10eth            |    10eth    |       0      |      0     |\n|   2  | 1 day later poolCheckpoint() is called |    20eth    |       0      |      0     |\n|   3  |           Alice stakes 10eth           |    20eth    |       0      |      0     |\n|   4  |            Bob stakes 10eth            |    30eth    |     86.4     |      0     |\n|   5  | 1 day later poolCheckpoint() is called |    40eth    |     86.4     |    86.4    |\n\n### Recommended Mitigation Steps\n\nFurther evaluation on how the variables are updated and how does the `Integral` (both each users and global one) is calculated on the pool inception is needed to patch this issue.\n\n**[danhper (Backd) confirmed, but disagreed with severity](https://github.com/code-423n4/2022-05-backd-findings/issues/100)** \n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-05-backd-findings/issues/100#issuecomment-1159746279):**\n > The warden has identified a way for the `rewardsShares` to be improperly assigned.\n> \n> The exploit is based on the fact that if `totalStaked` is zero we effectively will skip the first loop of points.\n> \n> This can create situations where certain users are rewarded unfairly in comparison to their initial deposit.\n> \n> However, this only applies when we go from zero to non-zero for `totalStaked` henced the scenario proposed by the warden (1 day of free rewards for first depositor) is actually the worst case scenario.\n> \n> Having the deployer do 2 or 3 initial deposits should mitigate this attack, which ultimately is limited to a leak of value to the first user depositing.\n> \n> For those reasons, I believe the finding to be valid and of Medium Severity.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-05-backd-tokenomics-contest",
  "Code": [
    {
      "filename": "protocol/contracts/tokenomics/AmmGauge.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../interfaces/IController.sol\";\nimport \"../../interfaces/tokenomics/IAmmGauge.sol\";\n\nimport \"../../libraries/ScaledMath.sol\";\nimport \"../../libraries/Errors.sol\";\nimport \"../../libraries/AddressProviderHelpers.sol\";\n\nimport \"../access/Authorization.sol\";\n\ncontract AmmGauge is Authorization, IAmmGauge {\n    using AddressProviderHelpers for IAddressProvider;\n    using ScaledMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IController public immutable controller;\n\n    mapping(address => uint256) public balances;\n\n    // All the data fields required for the staking tracking\n    uint256 public ammStakedIntegral;\n    uint256 public totalStaked;\n    mapping(address => uint256) public perUserStakedIntegral;\n    mapping(address => uint256) public perUserShare;\n\n    address public immutable ammToken;\n    bool public killed;\n    uint48 public ammLastUpdated;\n\n    event RewardClaimed(address indexed account, uint256 amount);\n\n    constructor(IController _controller, address _ammToken)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        ammToken = _ammToken;\n        controller = _controller;\n        ammLastUpdated = uint48(block.timestamp);\n    }\n\n    /**\n     * @notice Shut down the gauge.\n     * @dev Accrued inflation can still be claimed from the gauge after shutdown.\n     * @return `true` if successful.\n     */\n    function kill() external override returns (bool) {\n        require(msg.sender == address(controller.inflationManager()), Error.UNAUTHORIZED_ACCESS);\n        poolCheckpoint();\n        killed = true;\n        return true;\n    }\n\n    function claimRewards(address beneficiary) external virtual override returns (uint256) {\n        require(\n            msg.sender == beneficiary || _roleManager().hasRole(Roles.GAUGE_ZAP, msg.sender),\n            Error.UNAUTHORIZED_ACCESS\n        );\n        _userCheckpoint(beneficiary);\n        uint256 amount = perUserShare[beneficiary];\n        if (amount <= 0) return 0;\n        perUserShare[beneficiary] = 0;\n        controller.inflationManager().mintRewards(beneficiary, amount);\n        emit RewardClaimed(beneficiary, amount);\n        return amount;\n    }\n\n    function stake(uint256 amount) external virtual override returns (bool) {\n        return stakeFor(msg.sender, amount);\n    }\n\n    function unstake(uint256 amount) external virtual override returns (bool) {\n        return unstakeFor(msg.sender, amount);\n    }\n\n    function getAmmToken() external view override returns (address) {\n        return ammToken;\n    }\n\n    function isAmmToken(address token) external view override returns (bool) {\n        return token == ammToken;\n    }\n\n    function claimableRewards(address user) external view virtual override returns (uint256) {\n        uint256 ammStakedIntegral_ = ammStakedIntegral;\n        if (!killed && totalStaked > 0) {\n            ammStakedIntegral_ += (controller.inflationManager().getAmmRateForToken(ammToken) *\n                (block.timestamp - uint256(ammLastUpdated))).scaledDiv(totalStaked);\n        }\n        return\n            perUserShare[user] +\n            balances[user].scaledMul(ammStakedIntegral_ - perUserStakedIntegral[user]);\n    }\n\n    /**\n     * @notice Stake amount of AMM token on behalf of another account.\n     * @param account Account for which tokens will be staked.\n     * @param amount Amount of token to stake.\n     * @return `true` if success.\n     */\n    function stakeFor(address account, uint256 amount) public virtual override returns (bool) {\n        require(amount > 0, Error.INVALID_AMOUNT);\n\n        _userCheckpoint(account);\n\n        uint256 oldBal = IERC20(ammToken).balanceOf(address(this));\n        IERC20(ammToken).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 newBal = IERC20(ammToken).balanceOf(address(this));\n        uint256 staked = newBal - oldBal;\n        balances[account] += staked;\n        totalStaked += staked;\n        emit AmmStaked(account, ammToken, amount);\n        return true;\n    }\n\n    /**\n     * @notice Unstake amount of AMM token and send to another account.\n     * @param dst Account to which unstaked AMM tokens will be sent.\n     * @param amount Amount of token to unstake.\n     * @return `true` if success.\n     */\n    function unstakeFor(address dst, uint256 amount) public virtual override returns (bool) {\n        require(amount > 0, Error.INVALID_AMOUNT);\n        require(balances[msg.sender] >= amount, Error.INSUFFICIENT_BALANCE);\n\n        _userCheckpoint(msg.sender);\n\n        uint256 oldBal = IERC20(ammToken).balanceOf(address(this));\n        IERC20(ammToken).safeTransfer(dst, amount);\n        uint256 newBal = IERC20(ammToken).balanceOf(address(this));\n        uint256 unstaked = oldBal - newBal;\n        balances[msg.sender] -= unstaked;\n        totalStaked -= unstaked;\n        emit AmmUnstaked(msg.sender, ammToken, amount);\n        return true;\n    }\n\n    function poolCheckpoint() public virtual override returns (bool) {\n        if (killed) {\n            return false;\n        }\n        uint256 currentRate = controller.inflationManager().getAmmRateForToken(ammToken);\n        // Update the integral of total token supply for the pool\n        uint256 timeElapsed = block.timestamp - uint256(ammLastUpdated);\n        if (totalStaked > 0) {\n            ammStakedIntegral += (currentRate * timeElapsed).scaledDiv(totalStaked);\n        }\n        ammLastUpdated = uint48(block.timestamp);\n        return true;\n    }\n\n    function _userCheckpoint(address user) internal virtual returns (bool) {\n        poolCheckpoint();\n        perUserShare[user] += balances[user].scaledMul(\n            ammStakedIntegral - perUserStakedIntegral[user]\n        );\n        perUserStakedIntegral[user] = ammStakedIntegral;\n        return true;\n    }\n}"
    },
    {
      "filename": "protocol/contracts/tokenomics/AmmGauge.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../interfaces/IController.sol\";\nimport \"../../interfaces/tokenomics/IAmmGauge.sol\";\n\nimport \"../../libraries/ScaledMath.sol\";\nimport \"../../libraries/Errors.sol\";\nimport \"../../libraries/AddressProviderHelpers.sol\";\n\nimport \"../access/Authorization.sol\";\n\ncontract AmmGauge is Authorization, IAmmGauge {\n    using AddressProviderHelpers for IAddressProvider;\n    using ScaledMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IController public immutable controller;\n\n    mapping(address => uint256) public balances;\n\n    // All the data fields required for the staking tracking\n    uint256 public ammStakedIntegral;\n    uint256 public totalStaked;\n    mapping(address => uint256) public perUserStakedIntegral;\n    mapping(address => uint256) public perUserShare;\n\n    address public immutable ammToken;\n    bool public killed;\n    uint48 public ammLastUpdated;\n\n    event RewardClaimed(address indexed account, uint256 amount);\n\n    constructor(IController _controller, address _ammToken)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        ammToken = _ammToken;\n        controller = _controller;\n        ammLastUpdated = uint48(block.timestamp);\n    }\n\n    /**\n     * @notice Shut down the gauge.\n     * @dev Accrued inflation can still be claimed from the gauge after shutdown.\n     * @return `true` if successful.\n     */\n    function kill() external override returns (bool) {\n        require(msg.sender == address(controller.inflationManager()), Error.UNAUTHORIZED_ACCESS);\n        poolCheckpoint();\n        killed = true;\n        return true;\n    }\n\n    function claimRewards(address beneficiary) external virtual override returns (uint256) {\n        require(\n            msg.sender == beneficiary || _roleManager().hasRole(Roles.GAUGE_ZAP, msg.sender),\n            Error.UNAUTHORIZED_ACCESS\n        );\n        _userCheckpoint(beneficiary);\n        uint256 amount = perUserShare[beneficiary];\n        if (amount <= 0) return 0;\n        perUserShare[beneficiary] = 0;\n        controller.inflationManager().mintRewards(beneficiary, amount);\n        emit RewardClaimed(beneficiary, amount);\n        return amount;\n    }\n\n    function stake(uint256 amount) external virtual override returns (bool) {\n        return stakeFor(msg.sender, amount);\n    }\n\n    function unstake(uint256 amount) external virtual override returns (bool) {\n        return unstakeFor(msg.sender, amount);\n    }\n\n    function getAmmToken() external view override returns (address) {\n        return ammToken;\n    }\n\n    function isAmmToken(address token) external view override returns (bool) {\n        return token == ammToken;\n    }\n\n    function claimableRewards(address user) external view virtual override returns (uint256) {\n        uint256 ammStakedIntegral_ = ammStakedIntegral;\n        if (!killed && totalStaked > 0) {\n            ammStakedIntegral_ += (controller.inflationManager().getAmmRateForToken(ammToken) *\n                (block.timestamp - uint256(ammLastUpdated))).scaledDiv(totalStaked);\n        }\n        return\n            perUserShare[user] +\n            balances[user].scaledMul(ammStakedIntegral_ - perUserStakedIntegral[user]);\n    }\n\n    /**\n     * @notice Stake amount of AMM token on behalf of another account.\n     * @param account Account for which tokens will be staked.\n     * @param amount Amount of token to stake.\n     * @return `true` if success.\n     */\n    function stakeFor(address account, uint256 amount) public virtual override returns (bool) {\n        require(amount > 0, Error.INVALID_AMOUNT);\n\n        _userCheckpoint(account);\n\n        uint256 oldBal = IERC20(ammToken).balanceOf(address(this));\n        IERC20(ammToken).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 newBal = IERC20(ammToken).balanceOf(address(this));\n        uint256 staked = newBal - oldBal;\n        balances[account] += staked;\n        totalStaked += staked;\n        emit AmmStaked(account, ammToken, amount);\n        return true;\n    }\n\n    /**\n     * @notice Unstake amount of AMM token and send to another account.\n     * @param dst Account to which unstaked AMM tokens will be sent.\n     * @param amount Amount of token to unstake.\n     * @return `true` if success.\n     */\n    function unstakeFor(address dst, uint256 amount) public virtual override returns (bool) {\n        require(amount > 0, Error.INVALID_AMOUNT);\n        require(balances[msg.sender] >= amount, Error.INSUFFICIENT_BALANCE);\n\n        _userCheckpoint(msg.sender);\n\n        uint256 oldBal = IERC20(ammToken).balanceOf(address(this));\n        IERC20(ammToken).safeTransfer(dst, amount);\n        uint256 newBal = IERC20(ammToken).balanceOf(address(this));\n        uint256 unstaked = oldBal - newBal;\n        balances[msg.sender] -= unstaked;\n        totalStaked -= unstaked;\n        emit AmmUnstaked(msg.sender, ammToken, amount);\n        return true;\n    }\n\n    function poolCheckpoint() public virtual override returns (bool) {\n        if (killed) {\n            return false;\n        }\n        uint256 currentRate = controller.inflationManager().getAmmRateForToken(ammToken);\n        // Update the integral of total token supply for the pool\n        uint256 timeElapsed = block.timestamp - uint256(ammLastUpdated);\n        if (totalStaked > 0) {\n            ammStakedIntegral += (currentRate * timeElapsed).scaledDiv(totalStaked);\n        }\n        ammLastUpdated = uint48(block.timestamp);\n        return true;\n    }\n\n    function _userCheckpoint(address user) internal virtual returns (bool) {\n        poolCheckpoint();\n        perUserShare[user] += balances[user].scaledMul(\n            ammStakedIntegral - perUserStakedIntegral[user]\n        );\n        perUserStakedIntegral[user] = ammStakedIntegral;\n        return true;\n    }\n}"
    },
    {
      "filename": "protocol/contracts/tokenomics/Minter.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"../../interfaces/IController.sol\";\nimport \"../../interfaces/tokenomics/IBkdToken.sol\";\nimport \"../../interfaces/tokenomics/IMinter.sol\";\n\nimport \"../../libraries/Errors.sol\";\nimport \"../../libraries/ScaledMath.sol\";\nimport \"../../libraries/AddressProviderHelpers.sol\";\n\nimport \"./BkdToken.sol\";\nimport \"../access/Authorization.sol\";\n\ncontract Minter is IMinter, Authorization, ReentrancyGuard {\n    using ScaledMath for uint256;\n    using AddressProviderHelpers for IAddressProvider;\n\n    uint256 private constant _INFLATION_DECAY_PERIOD = 365 days;\n\n    // Lp Rates\n    uint256 public immutable initialAnnualInflationRateLp;\n    uint256 public immutable annualInflationDecayLp;\n    uint256 public currentInflationAmountLp;\n\n    // Keeper Rates\n    uint256 public immutable initialPeriodKeeperInflation;\n    uint256 public immutable initialAnnualInflationRateKeeper;\n    uint256 public immutable annualInflationDecayKeeper;\n    uint256 public currentInflationAmountKeeper;\n\n    // AMM Rates\n    uint256 public immutable initialPeriodAmmInflation;\n    uint256 public immutable initialAnnualInflationRateAmm;\n    uint256 public immutable annualInflationDecayAmm;\n    uint256 public currentInflationAmountAmm;\n\n    bool public initialPeriodEnded;\n\n    // Non-inflation rates\n    uint256 public immutable nonInflationDistribution;\n    uint256 public issuedNonInflationSupply;\n\n    uint256 public lastInflationDecay;\n    uint256 public currentTotalInflation;\n\n    // Used for final safety check to ensure inflation is not exceeded\n    uint256 public totalAvailableToNow;\n    uint256 public totalMintedToNow;\n    uint256 public lastEvent;\n\n    IController public immutable controller;\n    BkdToken public token;\n\n    event TokensMinted(address beneficiary, uint256 amount);\n\n    constructor(\n        uint256 _annualInflationRateLp,\n        uint256 _annualInflationRateKeeper,\n        uint256 _annualInflationRateAmm,\n        uint256 _annualInflationDecayLp,\n        uint256 _annualInflationDecayKeeper,\n        uint256 _annualInflationDecayAmm,\n        uint256 _initialPeriodKeeperInflation,\n        uint256 _initialPeriodAmmInflation,\n        uint256 _nonInflationDistribution,\n        IController _controller\n    ) Authorization(_controller.addressProvider().getRoleManager()) {\n        require(_annualInflationDecayLp < ScaledMath.ONE, Error.INVALID_PARAMETER_VALUE);\n        require(_annualInflationDecayKeeper < ScaledMath.ONE, Error.INVALID_PARAMETER_VALUE);\n        require(_annualInflationDecayAmm < ScaledMath.ONE, Error.INVALID_PARAMETER_VALUE);\n        initialAnnualInflationRateLp = _annualInflationRateLp;\n        initialAnnualInflationRateKeeper = _annualInflationRateKeeper;\n        initialAnnualInflationRateAmm = _annualInflationRateAmm;\n\n        annualInflationDecayLp = _annualInflationDecayLp;\n        annualInflationDecayKeeper = _annualInflationDecayKeeper;\n        annualInflationDecayAmm = _annualInflationDecayAmm;\n\n        initialPeriodKeeperInflation = _initialPeriodKeeperInflation;\n        initialPeriodAmmInflation = _initialPeriodAmmInflation;\n\n        currentInflationAmountLp = _annualInflationRateLp / _INFLATION_DECAY_PERIOD;\n        currentInflationAmountKeeper = _initialPeriodKeeperInflation / _INFLATION_DECAY_PERIOD;\n        currentInflationAmountAmm = _initialPeriodAmmInflation / _INFLATION_DECAY_PERIOD;\n\n        currentTotalInflation =\n            currentInflationAmountLp +\n            currentInflationAmountKeeper +\n            currentInflationAmountAmm;\n\n        nonInflationDistribution = _nonInflationDistribution;\n        controller = _controller;\n    }\n\n    function setToken(address _token) external override onlyGovernance {\n        require(address(token) == address(0), \"Token already set!\");\n        token = BkdToken(_token);\n    }\n\n    function startInflation() external override onlyGovernance {\n        require(lastEvent == 0, \"Inflation has already started.\");\n        lastEvent = block.timestamp;\n        lastInflationDecay = block.timestamp;\n    }\n\n    /**\n     * @notice Update the inflation rate according to the piecewise linear schedule.\n     * @dev This updates the inflation rate to the next linear segment in the inflations schedule.\n     * @return `true` if successful.\n     */\n    function executeInflationRateUpdate() external override returns (bool) {\n        return _executeInflationRateUpdate();\n    }\n\n    /**\n     * @notice Mints BKD tokens to a specified address.\n     * @dev Can only be called by the controller.\n     * @param beneficiary Address to mint tokens for.\n     * @param amount Amount of tokens to mint.\n     * @return `true` if successful.\n     */\n    function mint(address beneficiary, uint256 amount)\n        external\n        override\n        nonReentrant\n        returns (bool)\n    {\n        require(msg.sender == address(controller.inflationManager()), Error.UNAUTHORIZED_ACCESS);\n        if (lastEvent == 0) return false;\n        return _mint(beneficiary, amount);\n    }\n\n    /**\n     * @notice Mint tokens that are not part of the inflation schedule.\n     * @dev The amount of tokens that can be minted in total is subject to a pre-set upper limit.\n     * @param beneficiary Address to mint tokens for.\n     * @param amount Amount of tokens to mint.\n     * @return `true` if successful.\n     */\n    function mintNonInflationTokens(address beneficiary, uint256 amount)\n        external\n        override\n        onlyGovernance\n        returns (bool)\n    {\n        require(\n            issuedNonInflationSupply + amount <= nonInflationDistribution,\n            \"Maximum non-inflation amount exceeded.\"\n        );\n        issuedNonInflationSupply += amount;\n        token.mint(beneficiary, amount);\n        emit TokensMinted(beneficiary, amount);\n        return true;\n    }\n\n    /**\n     * @notice Supplies the inflation rate for LPs per unit of time (seconds).\n     * @return LP inflation rate.\n     */\n    function getLpInflationRate() external view override returns (uint256) {\n        if (lastEvent == 0) return 0;\n        return currentInflationAmountLp;\n    }\n\n    /**\n     * @notice Supplies the inflation rate for keepers per unit of time (seconds).\n     * @return keeper inflation rate.\n     */\n    function getKeeperInflationRate() external view override returns (uint256) {\n        if (lastEvent == 0) return 0;\n        return currentInflationAmountKeeper;\n    }\n\n    /**\n     * @notice Supplies the inflation rate for LPs on AMMs per unit of time (seconds).\n     * @return AMM inflation rate.\n     */\n    function getAmmInflationRate() external view override returns (uint256) {\n        if (lastEvent == 0) return 0;\n        return currentInflationAmountAmm;\n    }\n\n    function _executeInflationRateUpdate() internal returns (bool) {\n        totalAvailableToNow += (currentTotalInflation * (block.timestamp - lastEvent));\n        lastEvent = block.timestamp;\n        if (block.timestamp >= lastInflationDecay + _INFLATION_DECAY_PERIOD) {\n            currentInflationAmountLp = currentInflationAmountLp.scaledMul(annualInflationDecayLp);\n            if (initialPeriodEnded) {\n                currentInflationAmountKeeper = currentInflationAmountKeeper.scaledMul(\n                    annualInflationDecayKeeper\n                );\n                currentInflationAmountAmm = currentInflationAmountAmm.scaledMul(\n                    annualInflationDecayAmm\n                );\n            } else {\n                currentInflationAmountKeeper =\n                    initialAnnualInflationRateKeeper /\n                    _INFLATION_DECAY_PERIOD;\n\n                currentInflationAmountAmm = initialAnnualInflationRateAmm / _INFLATION_DECAY_PERIOD;\n                initialPeriodEnded = true;\n            }\n            currentTotalInflation =\n                currentInflationAmountLp +\n                currentInflationAmountKeeper +\n                currentInflationAmountAmm;\n            controller.inflationManager().checkpointAllGauges();\n            lastInflationDecay = block.timestamp;\n        }\n        return true;\n    }\n\n    function _mint(address beneficiary, uint256 amount) internal returns (bool) {\n        totalAvailableToNow += ((block.timestamp - lastEvent) * currentTotalInflation);\n        uint256 newTotalMintedToNow = totalMintedToNow + amount;\n        require(newTotalMintedToNow <= totalAvailableToNow, \"Mintable amount exceeded\");\n        totalMintedToNow = newTotalMintedToNow;\n        lastEvent = block.timestamp;\n        token.mint(beneficiary, amount);\n        _executeInflationRateUpdate();\n        emit TokensMinted(beneficiary, amount);\n        return true;\n    }\n}"
    }
  ]
}