{
  "Title": "Missing distinction between queued and ready-to-execute state",
  "Content": "In the [`BaseBridgeReceiver`](https://github.com/compound-finance/comet/blob/2eb33b5e8454dba148373b6cb64ede4f7436fad7/contracts/bridges/BaseBridgeReceiver.sol#L6) contract, the [`state`](https://github.com/compound-finance/comet/blob/2eb33b5e8454dba148373b6cb64ede4f7436fad7/contracts/bridges/BaseBridgeReceiver.sol#L170) function returns the state of a given proposal. Currently, the possible state values are: [queued, expired, or executed](https://github.com/compound-finance/comet/blob/2eb33b5e8454dba148373b6cb64ede4f7436fad7/contracts/bridges/BaseBridgeReceiver.sol#L52-L54).\n\n\nHowever, it is important to distinguish between transactions that are still in queue and require more time before being executed, and those that can already be executed.\n\n\nThis is especially important as the `executeProposal` function [checks](https://github.com/compound-finance/comet/blob/2eb33b5e8454dba148373b6cb64ede4f7436fad7/contracts/bridges/BaseBridgeReceiver.sol#L156) that the proposal is in the `queued` state, but does not check if the proposal can already be executed. As a result, some transactions that are queued but not ready to be executed will pass the initial check, and the transaction will only revert once the `executeTransaction` function from the `Timelock` contract is called.\n\n\nConsider adding another state that indicates that the proposal is queued and can already be executed.\n\n\n***Update:** Acknowledged, not resolved. The Compound team stated:*\n\n\n\n> *The net benefit of this change would simply be that the error thrown would be thrown by the BaseBridgeReceiver instead of being thrown by the Timelock. These two approaches seem functionally equivalent; we will not make this update.*\n> \n> \n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/bridges/BaseBridgeReceiver.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.15;\n\nimport \"../ITimelock.sol\";\n\ncontract BaseBridgeReceiver {\n    /** Custom errors **/\n    error AlreadyInitialized();\n    error BadData();\n    error InvalidProposalId();\n    error ProposalNotQueued();\n    error TransactionAlreadyQueued();\n    error Unauthorized();\n\n    /** Events **/\n    event Initialized(address indexed govTimelock, address indexed localTimelock);\n    event NewLocalTimelock(address indexed oldLocalTimelock, address indexed newLocalTimelock);\n    event NewGovTimelock(address indexed oldGovTimelock, address indexed newGovTimelock);\n    event ProposalCreated(address indexed messageSender, uint id, address[] targets, uint[] values, string[] signatures, bytes[] calldatas, uint eta);\n    event ProposalExecuted(uint id);\n\n    /** Public variables **/\n\n    /// @notice Address of the governing contract that this bridge receiver expects to\n    ///  receive messages from; likely an address from another chain (e.g. mainnet)\n    address public govTimelock;\n\n    /// @notice Address of the timelock on this chain that the bridge receiver\n    /// will send messages to\n    address public localTimelock;\n\n    /// @notice Whether contract has been initialized\n    bool public initialized;\n\n    /// @notice Total count of proposals generated\n    uint public proposalCount;\n\n    struct Proposal {\n        uint id;\n        address[] targets;\n        uint[] values;\n        string[] signatures;\n        bytes[] calldatas;\n        uint eta;\n        bool executed;\n    }\n\n    /// @notice Mapping of proposal ids to their full proposal data\n    mapping (uint => Proposal) public proposals;\n\n    enum ProposalState {\n        Queued,\n        Expired,\n        Executed\n    }\n\n    /**\n     * @notice Initialize the contract\n     * @param _govTimelock Address of the governing contract that this contract\n     * will receive messages from (likely on another chain)\n     * @param _localTimelock Address of the timelock contract that this contract\n     * will send messages to\n     */\n    function initialize(address _govTimelock, address _localTimelock) external {\n        if (initialized) revert AlreadyInitialized();\n        govTimelock = _govTimelock;\n        localTimelock = _localTimelock;\n        initialized = true;\n        emit Initialized(_govTimelock, _localTimelock);\n    }\n\n    /**\n     * @notice Accept admin role for the localTimelock\n     */\n    function acceptLocalTimelockAdmin() external {\n        if (msg.sender != localTimelock) revert Unauthorized();\n        ITimelock(localTimelock).acceptAdmin();\n    }\n\n    /**\n     * @notice Set localTimelock address\n     * @param newTimelock Address to set as the localTimelock\n     */\n    function setLocalTimelock(address newTimelock) public {\n        if (msg.sender != localTimelock) revert Unauthorized();\n        address oldLocalTimelock = localTimelock;\n        localTimelock = newTimelock;\n        emit NewLocalTimelock(oldLocalTimelock, newTimelock);\n    }\n\n    /**\n     * @notice Set govTimelock address\n     * @param newTimelock Address to set as the govTimelock\n     */\n    function setGovTimelock(address newTimelock) public {\n        if (msg.sender != localTimelock) revert Unauthorized();\n        address oldGovTimelock = govTimelock;\n        govTimelock = newTimelock;\n        emit NewGovTimelock(oldGovTimelock, newTimelock);\n    }\n\n    /**\n     * @notice Process a message sent from the governing timelock (across a bridge)\n     * @param messageSender Address of the contract that sent the bridged message\n     * @param data ABI-encoded bytes containing the transactions to be queued on the local timelock\n     */\n    function processMessage(\n        address messageSender,\n        bytes calldata data\n    ) internal {\n        if (messageSender != govTimelock) revert Unauthorized();\n\n        address[] memory targets;\n        uint256[] memory values;\n        string[] memory signatures;\n        bytes[] memory calldatas;\n\n        (targets, values, signatures, calldatas) = abi.decode(\n            data,\n            (address[], uint256[], string[], bytes[])\n        );\n\n        if (values.length != targets.length) revert BadData();\n        if (signatures.length != targets.length) revert BadData();\n        if (calldatas.length != targets.length) revert BadData();\n\n        uint delay = ITimelock(localTimelock).delay();\n        uint eta = block.timestamp + delay;\n\n        for (uint8 i = 0; i < targets.length; ) {\n            if (ITimelock(localTimelock).queuedTransactions(keccak256(abi.encode(targets[i], values[i], signatures[i], calldatas[i], eta)))) revert TransactionAlreadyQueued();\n            ITimelock(localTimelock).queueTransaction(targets[i], values[i], signatures[i], calldatas[i], eta);\n            unchecked { i++; }\n        }\n\n        proposalCount++;\n        Proposal memory proposal = Proposal({\n            id: proposalCount,\n            targets: targets,\n            values: values,\n            signatures: signatures,\n            calldatas: calldatas,\n            eta: eta,\n            executed: false\n        });\n\n        proposals[proposal.id] = proposal;\n        emit ProposalCreated(messageSender, proposal.id, targets, values, signatures, calldatas, eta);\n    }\n\n    /**\n     * @notice Execute a queued proposal\n     * @param proposalId The id of the proposal to execute\n     */\n    function executeProposal(uint proposalId) external {\n        if (state(proposalId) != ProposalState.Queued) revert ProposalNotQueued();\n        Proposal storage proposal = proposals[proposalId];\n        proposal.executed = true;\n        for (uint i = 0; i < proposal.targets.length; i++) {\n            ITimelock(localTimelock).executeTransaction(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n        }\n        emit ProposalExecuted(proposalId);\n    }\n\n    /**\n     * @notice Get the state of a proposal\n     * @param proposalId Id of the proposal\n     * @return The state of the given proposal (queued, expired or executed)\n     */\n    function state(uint proposalId) public view returns (ProposalState) {\n        if (proposalId > proposalCount || proposalId == 0) revert InvalidProposalId();\n        Proposal memory proposal = proposals[proposalId];\n        if (proposal.executed) {\n            return ProposalState.Executed;\n        } else if (block.timestamp >= (proposal.eta + ITimelock(localTimelock).GRACE_PERIOD())) {\n            return ProposalState.Expired;\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n}"
    },
    {
      "filename": "contracts/bridges/BaseBridgeReceiver.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.15;\n\nimport \"../ITimelock.sol\";\n\ncontract BaseBridgeReceiver {\n    /** Custom errors **/\n    error AlreadyInitialized();\n    error BadData();\n    error InvalidProposalId();\n    error ProposalNotQueued();\n    error TransactionAlreadyQueued();\n    error Unauthorized();\n\n    /** Events **/\n    event Initialized(address indexed govTimelock, address indexed localTimelock);\n    event NewLocalTimelock(address indexed oldLocalTimelock, address indexed newLocalTimelock);\n    event NewGovTimelock(address indexed oldGovTimelock, address indexed newGovTimelock);\n    event ProposalCreated(address indexed messageSender, uint id, address[] targets, uint[] values, string[] signatures, bytes[] calldatas, uint eta);\n    event ProposalExecuted(uint id);\n\n    /** Public variables **/\n\n    /// @notice Address of the governing contract that this bridge receiver expects to\n    ///  receive messages from; likely an address from another chain (e.g. mainnet)\n    address public govTimelock;\n\n    /// @notice Address of the timelock on this chain that the bridge receiver\n    /// will send messages to\n    address public localTimelock;\n\n    /// @notice Whether contract has been initialized\n    bool public initialized;\n\n    /// @notice Total count of proposals generated\n    uint public proposalCount;\n\n    struct Proposal {\n        uint id;\n        address[] targets;\n        uint[] values;\n        string[] signatures;\n        bytes[] calldatas;\n        uint eta;\n        bool executed;\n    }\n\n    /// @notice Mapping of proposal ids to their full proposal data\n    mapping (uint => Proposal) public proposals;\n\n    enum ProposalState {\n        Queued,\n        Expired,\n        Executed\n    }\n\n    /**\n     * @notice Initialize the contract\n     * @param _govTimelock Address of the governing contract that this contract\n     * will receive messages from (likely on another chain)\n     * @param _localTimelock Address of the timelock contract that this contract\n     * will send messages to\n     */\n    function initialize(address _govTimelock, address _localTimelock) external {\n        if (initialized) revert AlreadyInitialized();\n        govTimelock = _govTimelock;\n        localTimelock = _localTimelock;\n        initialized = true;\n        emit Initialized(_govTimelock, _localTimelock);\n    }\n\n    /**\n     * @notice Accept admin role for the localTimelock\n     */\n    function acceptLocalTimelockAdmin() external {\n        if (msg.sender != localTimelock) revert Unauthorized();\n        ITimelock(localTimelock).acceptAdmin();\n    }\n\n    /**\n     * @notice Set localTimelock address\n     * @param newTimelock Address to set as the localTimelock\n     */\n    function setLocalTimelock(address newTimelock) public {\n        if (msg.sender != localTimelock) revert Unauthorized();\n        address oldLocalTimelock = localTimelock;\n        localTimelock = newTimelock;\n        emit NewLocalTimelock(oldLocalTimelock, newTimelock);\n    }\n\n    /**\n     * @notice Set govTimelock address\n     * @param newTimelock Address to set as the govTimelock\n     */\n    function setGovTimelock(address newTimelock) public {\n        if (msg.sender != localTimelock) revert Unauthorized();\n        address oldGovTimelock = govTimelock;\n        govTimelock = newTimelock;\n        emit NewGovTimelock(oldGovTimelock, newTimelock);\n    }\n\n    /**\n     * @notice Process a message sent from the governing timelock (across a bridge)\n     * @param messageSender Address of the contract that sent the bridged message\n     * @param data ABI-encoded bytes containing the transactions to be queued on the local timelock\n     */\n    function processMessage(\n        address messageSender,\n        bytes calldata data\n    ) internal {\n        if (messageSender != govTimelock) revert Unauthorized();\n\n        address[] memory targets;\n        uint256[] memory values;\n        string[] memory signatures;\n        bytes[] memory calldatas;\n\n        (targets, values, signatures, calldatas) = abi.decode(\n            data,\n            (address[], uint256[], string[], bytes[])\n        );\n\n        if (values.length != targets.length) revert BadData();\n        if (signatures.length != targets.length) revert BadData();\n        if (calldatas.length != targets.length) revert BadData();\n\n        uint delay = ITimelock(localTimelock).delay();\n        uint eta = block.timestamp + delay;\n\n        for (uint8 i = 0; i < targets.length; ) {\n            if (ITimelock(localTimelock).queuedTransactions(keccak256(abi.encode(targets[i], values[i], signatures[i], calldatas[i], eta)))) revert TransactionAlreadyQueued();\n            ITimelock(localTimelock).queueTransaction(targets[i], values[i], signatures[i], calldatas[i], eta);\n            unchecked { i++; }\n        }\n\n        proposalCount++;\n        Proposal memory proposal = Proposal({\n            id: proposalCount,\n            targets: targets,\n            values: values,\n            signatures: signatures,\n            calldatas: calldatas,\n            eta: eta,\n            executed: false\n        });\n\n        proposals[proposal.id] = proposal;\n        emit ProposalCreated(messageSender, proposal.id, targets, values, signatures, calldatas, eta);\n    }\n\n    /**\n     * @notice Execute a queued proposal\n     * @param proposalId The id of the proposal to execute\n     */\n    function executeProposal(uint proposalId) external {\n        if (state(proposalId) != ProposalState.Queued) revert ProposalNotQueued();\n        Proposal storage proposal = proposals[proposalId];\n        proposal.executed = true;\n        for (uint i = 0; i < proposal.targets.length; i++) {\n            ITimelock(localTimelock).executeTransaction(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n        }\n        emit ProposalExecuted(proposalId);\n    }\n\n    /**\n     * @notice Get the state of a proposal\n     * @param proposalId Id of the proposal\n     * @return The state of the given proposal (queued, expired or executed)\n     */\n    function state(uint proposalId) public view returns (ProposalState) {\n        if (proposalId > proposalCount || proposalId == 0) revert InvalidProposalId();\n        Proposal memory proposal = proposals[proposalId];\n        if (proposal.executed) {\n            return ProposalState.Executed;\n        } else if (block.timestamp >= (proposal.eta + ITimelock(localTimelock).GRACE_PERIOD())) {\n            return ProposalState.Expired;\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n}"
    }
  ]
}