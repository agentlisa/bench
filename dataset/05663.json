{
  "Title": "[G-04] Using a positive conditional flow to save a NOT opcode",
  "Content": "\nIn order to save some gas (NOT opcode costing 3 gas), switch to a positive statement:\n\n```diff\n- if(!condition){\n-     action1();\n- }else{\n-     action2();\n- }\n+ if(condition){\n+     action2();\n+ }else{\n+     action1();\n+ }\n```            \n\nEstimated saving:\n| Method call or Contract deployment | Before | After | After - Before | (After - Before) / Before |\n| :- | :-: | :-: | :-: | :-: |\n| `LiquidityMiningPath` | 1540432 | 1537682 | -2750 | -0.18% |\n\nThere is 1 instance of this issue:\n\n[[86-150](https://github.com/code-423n4/2023-10-canto/blob/main/canto_ambient/contracts/mixins/LiquidityMining.sol#L86-L150)]\n\n<details>\n\n```\nFile: LiquidityMining.sol\n\n\n  86           if (lastAccrued != 0) {\n  87               uint256 liquidity = pos.liquidity_;\n  88               for (int24 i = lowerTick + 10; i <= upperTick - 10; ++i) {\n  89                   uint32 tickTrackingIndex = tickTrackingIndexAccruedUpTo_[poolIdx][posKey][i];\n  90                   uint32 origIndex = tickTrackingIndex;\n  91                   uint32 numTickTracking = uint32(tickTracking_[poolIdx][i].length);\n  92                   uint32 time = lastAccrued;\n  93                   // Loop through all in-range time spans for the tick or up to the current time (if it is still in range)\n  94                   while (time < block.timestamp && tickTrackingIndex < numTickTracking) {\n  95                       TickTracking memory tickTracking = tickTracking_[poolIdx][i][tickTrackingIndex];\n  96                       uint32 currWeek = uint32((time / WEEK) * WEEK);\n  97                       uint32 nextWeek = uint32(((time + WEEK) / WEEK) * WEEK);\n  98                       uint32 dt = uint32(\n  99                           nextWeek < block.timestamp\n  100                              ? nextWeek - time\n  101                              : block.timestamp - time\n  102                      );\n  103                      uint32 tickActiveStart; // Timestamp to use for the liquidity addition\n  104                      uint32 tickActiveEnd;\n  105                      if (tickTracking.enterTimestamp < nextWeek) {\n  106                          // Tick was active before next week, need to add the liquidity\n  107                          if (tickTracking.enterTimestamp < time) {\n  108                              // Tick was already active when last claim happened, only accrue from last claim timestamp\n  109                              tickActiveStart = time;\n  110                          } else {\n  111                              // Tick has become active this week\n  112                              tickActiveStart = tickTracking.enterTimestamp;\n  113                          }\n  114                          if (tickTracking.exitTimestamp == 0) {\n  115                              // Tick still active, do not increase index because we need to continue from here\n  116                              tickActiveEnd = uint32(nextWeek < block.timestamp ? nextWeek : block.timestamp);\n  117                          } else {\n  118                              // Tick is no longer active\n  119                              if (tickTracking.exitTimestamp < nextWeek) {\n  120                                  // Exit was in this week, continue with next tick\n  121                                  tickActiveEnd = tickTracking.exitTimestamp;\n  122                                  tickTrackingIndex++;\n  123                                  dt = tickActiveEnd - tickActiveStart;\n  124                              } else {\n  125                                  // Exit was in next week, we need to consider the current tick there (i.e. not increase the index)\n  126                                  tickActiveEnd = nextWeek;\n  127                              }\n  128                          }\n  129                          timeWeightedWeeklyPositionInRangeConcLiquidity_[poolIdx][posKey][currWeek][i] +=\n  130                              (tickActiveEnd - tickActiveStart) * liquidity;\n  131                      }\n  132                      time += dt;\n  133                  }\n  134                  if (tickTrackingIndex != origIndex) {\n  135                      tickTrackingIndexAccruedUpTo_[poolIdx][posKey][i] = tickTrackingIndex;\n  136                  }\n  137              }\n  138          } else {\n  139              for (int24 i = lowerTick + 10; i <= upperTick - 10; ++i) {\n  140                  uint32 numTickTracking = uint32(tickTracking_[poolIdx][i].length);\n  141                  if (numTickTracking > 0) {\n  142                      if (tickTracking_[poolIdx][i][numTickTracking - 1].exitTimestamp == 0) {\n  143                          // Tick currently active\n  144                          tickTrackingIndexAccruedUpTo_[poolIdx][posKey][i] = numTickTracking - 1;\n  145                      } else {\n  146                          tickTrackingIndexAccruedUpTo_[poolIdx][posKey][i] = numTickTracking;\n  147                      }\n  148                  }\n  149              }\n  150          }\n```\n\n```diff\nFile: LiquidityMining.sol\n\n-   86           if (lastAccrued != 0) {\n-   87               uint256 liquidity = pos.liquidity_;\n-   88               for (int24 i = lowerTick + 10; i <= upperTick - 10; ++i) {\n-   89                   uint32 tickTrackingIndex = tickTrackingIndexAccruedUpTo_[poolIdx][posKey][i];\n-   90                   uint32 origIndex = tickTrackingIndex;\n-   91                   uint32 numTickTracking = uint32(tickTracking_[poolIdx][i].length);\n-   92                   uint32 time = lastAccrued;\n-   93                   // Loop through all in-range time spans for the tick or up to the current time (if it is still in range)\n-   94                   while (time < block.timestamp && tickTrackingIndex < numTickTracking) {\n-   95                       TickTracking memory tickTracking = tickTracking_[poolIdx][i][tickTrackingIndex];\n-   96                       uint32 currWeek = uint32((time / WEEK) * WEEK);\n-   97                       uint32 nextWeek = uint32(((time + WEEK) / WEEK) * WEEK);\n-   98                       uint32 dt = uint32(\n-   99                           nextWeek < block.timestamp\n-   100                              ? nextWeek - time\n-   101                              : block.timestamp - time\n-   102                      );\n-   103                      uint32 tickActiveStart; // Timestamp to use for the liquidity addition\n-   104                      uint32 tickActiveEnd;\n-   105                      if (tickTracking.enterTimestamp < nextWeek) {\n-   106                          // Tick was active before next week, need to add the liquidity\n-   107                          if (tickTracking.enterTimestamp < time) {\n-   108                              // Tick was already active when last claim happened, only accrue from last claim timestamp\n-   109                              tickActiveStart = time;\n-   110                          } else {\n-   111                              // Tick has become active this week\n-   112                              tickActiveStart = tickTracking.enterTimestamp;\n-   113                          }\n-   114                          if (tickTracking.exitTimestamp == 0) {\n-   115                              // Tick still active, do not increase index because we need to continue from here\n-   116                              tickActiveEnd = uint32(nextWeek < block.timestamp ? nextWeek : block.timestamp);\n-   117                          } else {\n-   118                              // Tick is no longer active\n-   119                              if (tickTracking.exitTimestamp < nextWeek) {\n-   120                                  // Exit was in this week, continue with next tick\n-   121                                  tickActiveEnd = tickTracking.exitTimestamp;\n-   122                                  tickTrackingIndex++;\n-   123                                  dt = tickActiveEnd - tickActiveStart;\n-   124                              } else {\n-   125                                  // Exit was in next week, we need to consider the current tick there (i.e. not increase the index)\n-   126                                  tickActiveEnd = nextWeek;\n-   127                              }\n-   128                          }\n-   129                          timeWeightedWeeklyPositionInRangeConcLiquidity_[poolIdx][posKey][currWeek][i] +=\n-   130                              (tickActiveEnd - tickActiveStart) * liquidity;\n-   131                      }\n-   132                      time += dt;\n-   133                  }\n-   134                  if (tickTrackingIndex != origIndex) {\n-   135                      tickTrackingIndexAccruedUpTo_[poolIdx][posKey][i] = tickTrackingIndex;\n-   136                  }\n-   137              }\n-   138          } else {\n-   139              for (int24 i = lowerTick + 10; i <= upperTick - 10; ++i) {\n-   140                  uint32 numTickTracking = uint32(tickTracking_[poolIdx][i].length);\n-   141                  if (numTickTracking > 0) {\n-   142                      if (tickTracking_[poolIdx][i][numTickTracking - 1].exitTimestamp == 0) {\n-   143                          // Tick currently active\n-   144                          tickTrackingIndexAccruedUpTo_[poolIdx][posKey][i] = numTickTracking - 1;\n-   145                      } else {\n-   146                          tickTrackingIndexAccruedUpTo_[poolIdx][posKey][i] = numTickTracking;\n-   147                      }\n-   148                  }\n-   149              }\n-   150          }\n\n\n+   86             if (lastAccrued == 0) {\n+   87                 for (int24 i = lowerTick + 10; i <= upperTick - 10; ++i) {\n+   88                     uint32 numTickTracking = uint32(tickTracking_[poolIdx][i].length);\n+   89                     if (numTickTracking > 0) {\n+   90                         if (tickTracking_[poolIdx][i][numTickTracking - 1].exitTimestamp == 0) {\n+   91                             // Tick currently active\n+   92                             tickTrackingIndexAccruedUpTo_[poolIdx][posKey][i] = numTickTracking - 1;\n+   93                         } else {\n+   94                             tickTrackingIndexAccruedUpTo_[poolIdx][posKey][i] = numTickTracking;\n+   95                         }\n+   96                     }\n+   97                 }\n+   98             } else {\n+   99                 uint256 liquidity = pos.liquidity_;\n+   100                 for (int24 i = lowerTick + 10; i <= upperTick - 10; ++i) {\n+   101                     uint32 tickTrackingIndex = tickTrackingIndexAccruedUpTo_[poolIdx][posKey][i];\n+   102                     uint32 origIndex = tickTrackingIndex;\n+   103                     uint32 numTickTracking = uint32(tickTracking_[poolIdx][i].length);\n+   104                     uint32 time = lastAccrued;\n+   105                     // Loop through all in-range time spans for the tick or up to the current time (if it is still in range)\n+   106                     while (time < block.timestamp && tickTrackingIndex < numTickTracking) {\n+   107                         TickTracking memory tickTracking = tickTracking_[poolIdx][i][tickTrackingIndex];\n+   108                         uint32 currWeek = uint32((time / WEEK) * WEEK);\n+   109                         uint32 nextWeek = uint32(((time + WEEK) / WEEK) * WEEK);\n+   110                         uint32 dt = uint32(\n+   111                             nextWeek < block.timestamp\n+   112                                 ? nextWeek - time\n+   113                                 : block.timestamp - time\n+   114                         );\n+   115                         uint32 tickActiveStart; // Timestamp to use for the liquidity addition\n+   116                         uint32 tickActiveEnd;\n+   117                         if (tickTracking.enterTimestamp < nextWeek) {\n+   118                             // Tick was active before next week, need to add the liquidity\n+   119                             if (tickTracking.enterTimestamp < time) {\n+   120                                 // Tick was already active when last claim happened, only accrue from last claim timestamp\n+   121                                 tickActiveStart = time;\n+   122                             } else {\n+   123                                 // Tick has become active this week\n+   124                                 tickActiveStart = tickTracking.enterTimestamp;\n+   125                             }\n+   126                             if (tickTracking.exitTimestamp == 0) {\n+   127                                 // Tick still active, do not increase index because we need to continue from here\n+   128                                 tickActiveEnd = uint32(nextWeek < block.timestamp ? nextWeek : block.timestamp);\n+   129                             } else {\n+   130                                 // Tick is no longer active\n+   131                                 if (tickTracking.exitTimestamp < nextWeek) {\n+   132                                     // Exit was in this week, continue with next tick\n+   133                                     tickActiveEnd = tickTracking.exitTimestamp;\n+   134                                     tickTrackingIndex++;\n+   135                                     dt = tickActiveEnd - tickActiveStart;\n+   136                                 } else {\n+   137                                     // Exit was in next week, we need to consider the current tick there (i.e. not increase the index)\n+   138                                     tickActiveEnd = nextWeek;\n+   139                                 }\n+   140                             }\n+   141                             timeWeightedWeeklyPositionInRangeConcLiquidity_[poolIdx][posKey][currWeek][i] +=\n+   142                                 (tickActiveEnd - tickActiveStart) * liquidity;\n+   143                         }\n+   144                         time += dt;\n+   145                     }\n+   146                     if (tickTrackingIndex != origIndex) {\n+   147                         tickTrackingIndexAccruedUpTo_[poolIdx][posKey][i] = tickTrackingIndex;\n+   148                     }\n+   149                 }\n+   150             }\n```\n\n</details>\n\n***\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-10-canto",
  "Code": [
    {
      "filename": "canto_ambient/contracts/mixins/LiquidityMining.sol",
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\n\nimport \"../libraries/SafeCast.sol\";\nimport \"./PositionRegistrar.sol\";\nimport \"./StorageLayout.sol\";\nimport \"./PoolRegistry.sol\";\n\n/* @title Liquidity mining mixin\n * @notice Contains the functions related to liquidity mining claiming. */\ncontract LiquidityMining is PositionRegistrar {\n    uint256 constant WEEK = 604800; // Week in seconds 604800\n\n    /// @notice Initialize the tick tracking for the first tick of a pool\n    function initTickTracking(bytes32 poolIdx, int24 tick) internal {\n        StorageLayout.TickTracking memory tickTrackingData = StorageLayout\n            .TickTracking(uint32(block.timestamp), 0);\n        tickTracking_[poolIdx][tick].push(tickTrackingData);\n    }\n\n    /// @notice Keeps track of the tick crossings\n    /// @dev Needs to be called whenever a tick is crossed\n    function crossTicks(\n        bytes32 poolIdx,\n        int24 exitTick,\n        int24 entryTick\n    ) internal {\n        uint256 numElementsExit = tickTracking_[poolIdx][exitTick].length;\n        tickTracking_[poolIdx][exitTick][numElementsExit - 1]\n            .exitTimestamp = uint32(block.timestamp);\n        StorageLayout.TickTracking memory tickTrackingData = StorageLayout\n            .TickTracking(uint32(block.timestamp), 0);\n        tickTracking_[poolIdx][entryTick].push(tickTrackingData);\n    }\n\n    /// @notice Keeps track of the global in-range time-weighted concentrated liquidity per week\n    /// @dev Needs to be called whenever the concentrated liquidity is modified (tick crossed, positions changed)\n    function accrueConcentratedGlobalTimeWeightedLiquidity(\n        bytes32 poolIdx,\n        CurveMath.CurveState memory curve\n    ) internal {\n        uint32 lastAccrued = timeWeightedWeeklyGlobalConcLiquidityLastSet_[\n            poolIdx\n        ];\n        // Only set time on first call\n        if (lastAccrued != 0) {\n            uint256 liquidity = curve.concLiq_;\n            uint32 time = lastAccrued;\n            while (time < block.timestamp) {\n                uint32 currWeek = uint32((time / WEEK) * WEEK);\n                uint32 nextWeek = uint32(((time + WEEK) / WEEK) * WEEK);\n                uint32 dt = uint32(\n                    nextWeek < block.timestamp\n                        ? nextWeek - time\n                        : block.timestamp - time\n                );\n                timeWeightedWeeklyGlobalConcLiquidity_[poolIdx][currWeek] += dt * liquidity;\n                time += dt;\n            }\n        }\n        timeWeightedWeeklyGlobalConcLiquidityLastSet_[poolIdx] = uint32(\n            block.timestamp\n        );\n    }\n\n    /// @notice Accrues the in-range time-weighted concentrated liquidity for a position by going over the tick entry / exit history\n    /// @dev Needs to be called whenever a position is modified\n    function accrueConcentratedPositionTimeWeightedLiquidity(\n        address payable owner,\n        bytes32 poolIdx,\n        int24 lowerTick,\n        int24 upperTick\n    ) internal {\n        RangePosition72 storage pos = lookupPosition(\n            owner,\n            poolIdx,\n            lowerTick,\n            upperTick\n        );\n        bytes32 posKey = encodePosKey(owner, poolIdx, lowerTick, upperTick);\n        uint32 lastAccrued = timeWeightedWeeklyPositionConcLiquidityLastSet_[\n            poolIdx\n        ][posKey];\n        // Only set time on first call\n        if (lastAccrued != 0) {\n            uint256 liquidity = pos.liquidity_;\n            for (int24 i = lowerTick + 10; i <= upperTick - 10; ++i) {\n                uint32 tickTrackingIndex = tickTrackingIndexAccruedUpTo_[poolIdx][posKey][i];\n                uint32 origIndex = tickTrackingIndex;\n                uint32 numTickTracking = uint32(tickTracking_[poolIdx][i].length);\n                uint32 time = lastAccrued;\n                // Loop through all in-range time spans for the tick or up to the current time (if it is still in range)\n                while (time < block.timestamp && tickTrackingIndex < numTickTracking) {\n                    TickTracking memory tickTracking = tickTracking_[poolIdx][i][tickTrackingIndex];\n                    uint32 currWeek = uint32((time / WEEK) * WEEK);\n                    uint32 nextWeek = uint32(((time + WEEK) / WEEK) * WEEK);\n                    uint32 dt = uint32(\n                        nextWeek < block.timestamp\n                            ? nextWeek - time\n                            : block.timestamp - time\n                    );\n                    uint32 tickActiveStart; // Timestamp to use for the liquidity addition\n                    uint32 tickActiveEnd;\n                    if (tickTracking.enterTimestamp < nextWeek) {\n                        // Tick was active before next week, need to add the liquidity\n                        if (tickTracking.enterTimestamp < time) {\n                            // Tick was already active when last claim happened, only accrue from last claim timestamp\n                            tickActiveStart = time;\n                        } else {\n                            // Tick has become active this week\n                            tickActiveStart = tickTracking.enterTimestamp;\n                        }\n                        if (tickTracking.exitTimestamp == 0) {\n                            // Tick still active, do not increase index because we need to continue from here\n                            tickActiveEnd = uint32(nextWeek < block.timestamp ? nextWeek : block.timestamp);\n                        } else {\n                            // Tick is no longer active\n                            if (tickTracking.exitTimestamp < nextWeek) {\n                                // Exit was in this week, continue with next tick\n                                tickActiveEnd = tickTracking.exitTimestamp;\n                                tickTrackingIndex++;\n                                dt = tickActiveEnd - tickActiveStart;\n                            } else {\n                                // Exit was in next week, we need to consider the current tick there (i.e. not increase the index)\n                                tickActiveEnd = nextWeek;\n                            }\n                        }\n                        timeWeightedWeeklyPositionInRangeConcLiquidity_[poolIdx][posKey][currWeek][i] +=\n                            (tickActiveEnd - tickActiveStart) * liquidity;\n                    }\n                    time += dt;\n                }\n                if (tickTrackingIndex != origIndex) {\n                    tickTrackingIndexAccruedUpTo_[poolIdx][posKey][i] = tickTrackingIndex;\n                }\n            }\n        } else {\n            for (int24 i = lowerTick + 10; i <= upperTick - 10; ++i) {\n                uint32 numTickTracking = uint32(tickTracking_[poolIdx][i].length);\n                if (numTickTracking > 0) {\n                    if (tickTracking_[poolIdx][i][numTickTracking - 1].exitTimestamp == 0) {\n                        // Tick currently active\n                        tickTrackingIndexAccruedUpTo_[poolIdx][posKey][i] = numTickTracking - 1;\n                    } else {\n                        tickTrackingIndexAccruedUpTo_[poolIdx][posKey][i] = numTickTracking;\n                    }\n                }\n            }\n        }\n        timeWeightedWeeklyPositionConcLiquidityLastSet_[poolIdx][\n            posKey\n        ] = uint32(block.timestamp);\n    }\n\n    function claimConcentratedRewards(\n        address payable owner,\n        bytes32 poolIdx,\n        int24 lowerTick,\n        int24 upperTick,\n        uint32[] memory weeksToClaim\n    ) internal {\n        accrueConcentratedPositionTimeWeightedLiquidity(\n            owner,\n            poolIdx,\n            lowerTick,\n            upperTick\n        );\n        CurveMath.CurveState memory curve = curves_[poolIdx];\n        // Need to do a global accrual in case the current tick was already in range for a long time without any modifications that triggered an accrual\n        accrueConcentratedGlobalTimeWeightedLiquidity(poolIdx, curve);\n        bytes32 posKey = encodePosKey(owner, poolIdx, lowerTick, upperTick);\n        uint256 rewardsToSend;\n        for (uint256 i; i < weeksToClaim.length; ++i) {\n            uint32 week = weeksToClaim[i];\n            require(week + WEEK < block.timestamp, \"Week not over yet\");\n            require(\n                !concLiquidityRewardsClaimed_[poolIdx][posKey][week],\n                \"Already claimed\"\n            );\n            uint256 overallInRangeLiquidity = timeWeightedWeeklyGlobalConcLiquidity_[poolIdx][week];\n            if (overallInRangeLiquidity > 0) {\n                uint256 inRangeLiquidityOfPosition;\n                for (int24 j = lowerTick + 10; j <= upperTick - 10; ++j) {\n                    inRangeLiquidityOfPosition += timeWeightedWeeklyPositionInRangeConcLiquidity_[poolIdx][posKey][week][j];\n                }\n                // Percentage of this weeks overall in range liquidity that was provided by the user times the overall weekly rewards\n                rewardsToSend += inRangeLiquidityOfPosition * concRewardPerWeek_[poolIdx][week] / overallInRangeLiquidity;\n            }\n            concLiquidityRewardsClaimed_[poolIdx][posKey][week] = true;\n        }\n        if (rewardsToSend > 0) {\n            (bool sent, ) = owner.call{value: rewardsToSend}(\"\");\n            require(sent, \"Sending rewards failed\");\n        }\n    }\n\n    function accrueAmbientGlobalTimeWeightedLiquidity(\n        bytes32 poolIdx,\n        CurveMath.CurveState memory curve\n    ) internal {\n        uint32 lastAccrued = timeWeightedWeeklyGlobalAmbLiquidityLastSet_[poolIdx];\n        // Only set time on first call\n        if (lastAccrued != 0) {\n            uint256 liquidity = curve.ambientSeeds_;\n            uint32 time = lastAccrued;\n            while (time < block.timestamp) {\n                uint32 currWeek = uint32((time / WEEK) * WEEK);\n                uint32 nextWeek = uint32(((time + WEEK) / WEEK) * WEEK);\n                uint32 dt = uint32(\n                    nextWeek < block.timestamp\n                        ? nextWeek - time\n                        : block.timestamp - time\n                );\n                timeWeightedWeeklyGlobalAmbLiquidity_[poolIdx][currWeek] += dt * liquidity;\n                time += dt;\n            }\n        }\n        timeWeightedWeeklyGlobalAmbLiquidityLastSet_[poolIdx] = uint32(\n            block.timestamp\n        );\n    }\n\n    function accrueAmbientPositionTimeWeightedLiquidity(\n        address payable owner,\n        bytes32 poolIdx\n    ) internal {\n        bytes32 posKey = encodePosKey(owner, poolIdx);\n        uint32 lastAccrued = timeWeightedWeeklyPositionAmbLiquidityLastSet_[\n            poolIdx\n        ][posKey];\n        // Only init time on first call\n        if (lastAccrued != 0) {\n            AmbientPosition storage pos = lookupPosition(owner, poolIdx);\n            uint256 liquidity = pos.seeds_;\n            uint32 time = lastAccrued;\n            while (time < block.timestamp) {\n                uint32 currWeek = uint32((time / WEEK) * WEEK);\n                uint32 nextWeek = uint32(((time + WEEK) / WEEK) * WEEK);\n                uint32 dt = uint32(\n                    nextWeek < block.timestamp\n                        ? nextWeek - time\n                        : block.timestamp - time\n                );\n                timeWeightedWeeklyPositionAmbLiquidity_[poolIdx][posKey][\n                    currWeek\n                ] += dt * liquidity;\n                time += dt;\n            }\n        }\n        timeWeightedWeeklyPositionAmbLiquidityLastSet_[poolIdx][\n            posKey\n        ] = uint32(block.timestamp);\n    }\n\n    function claimAmbientRewards(\n        address owner,\n        bytes32 poolIdx,\n        uint32[] memory weeksToClaim\n    ) internal {\n        CurveMath.CurveState memory curve = curves_[poolIdx];\n        accrueAmbientPositionTimeWeightedLiquidity(payable(owner), poolIdx);\n        accrueAmbientGlobalTimeWeightedLiquidity(poolIdx, curve);\n        bytes32 posKey = encodePosKey(owner, poolIdx);\n        uint256 rewardsToSend;\n        for (uint256 i; i < weeksToClaim.length; ++i) {\n            uint32 week = weeksToClaim[i];\n            require(week + WEEK < block.timestamp, \"Week not over yet\");\n            require(\n                !ambLiquidityRewardsClaimed_[poolIdx][posKey][week],\n                \"Already claimed\"\n            );\n            uint256 overallTimeWeightedLiquidity = timeWeightedWeeklyGlobalAmbLiquidity_[\n                    poolIdx\n                ][week];\n            if (overallTimeWeightedLiquidity > 0) {\n                uint256 rewardsForWeek = (timeWeightedWeeklyPositionAmbLiquidity_[\n                    poolIdx\n                ][posKey][week] * ambRewardPerWeek_[poolIdx][week]) /\n                    overallTimeWeightedLiquidity;\n                rewardsToSend += rewardsForWeek;\n            }\n            ambLiquidityRewardsClaimed_[poolIdx][posKey][week] = true;\n        }\n        if (rewardsToSend > 0) {\n            (bool sent, ) = owner.call{value: rewardsToSend}(\"\");\n            require(sent, \"Sending rewards failed\");\n        }\n    }\n}"
    }
  ]
}