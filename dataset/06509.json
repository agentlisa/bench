{
  "Title": "[G-19] Amounts should be checked for `0` before calling a transfer",
  "Content": "\nIt is generally a good practice to check for zero values before making any transfers in smart contract functions. This can help to avoid unnecessary external calls and save gas costs.\n\nChecking for zero values is especially important when transferring tokens or ether, as sending these assets to an address with a zero value will result in the loss of those assets.\n\nIn Solidity, you can check whether a value is zero by using the `==` operator. Here's an example of how you can check for a zero value before making a transfer:\n\n```\nfunction transfer(address payable recipient, uint256 amount) public {\n    require(amount > 0, \"Amount must be greater than zero\");\n    recipient.transfer(amount);\n}\n``\nIn the above example, we check to make sure that the amount parameter is greater than zero before making the transfer to the recipient address. If the amount is zero or negative, the function will revert and the transfer will not be made.\n\n```solidity\nFile:  src/erc-4626/ERC4626.sol\n76    address(asset).safeTransfer(receiver, assets);\n\n96    address(asset).safeTransfer(receiver, assets);\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/erc-4626/ERC4626.sol#L76\n\n```solidity\nFile: src/erc-4626/ERC4626MultiToken.sol\n80    assets[i].safeTransfer(receiver, assetsAmounts[i]);\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/erc-4626/ERC4626MultiToken.sol#L80\n\n```solidity\nFile: src/talos/boost-aggregator/BoostAggregator.sol\n176   address(hermesGaugeBoost).safeTransfer(to, amount);\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/talos/boost-aggregator/BoostAggregator.sol#L176\n\n```solidity\nFile: src/ulysses-omnichain/BranchPort.sol\n166   _token.safeTransfer(msg.sender, _amount);\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchPort.sol#L166\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/erc-4626/ERC4626.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IERC4626} from \"./interfaces/IERC4626.sol\";\n\n/// @title Minimal ERC4626 tokenized Vault implementation\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/mixins/ERC4626.sol)\nabstract contract ERC4626 is ERC20, IERC4626 {\n    using SafeTransferLib for address;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    ERC20 public immutable asset;\n\n    constructor(ERC20 _asset, string memory _name, string memory _symbol) ERC20(_name, _symbol, _asset.decimals()) {\n        asset = _asset;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n        // Need to transfer before minting or ERC777s could reenter.\n        address(asset).safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n    /// @inheritdoc IERC4626\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        address(asset).safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n    /// @inheritdoc IERC4626\n    function withdraw(uint256 assets, address receiver, address owner) public virtual returns (uint256 shares) {\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        address(asset).safeTransfer(receiver, assets);\n    }\n\n    /// @inheritdoc IERC4626\n    function redeem(uint256 shares, address receiver, address owner) public virtual returns (uint256 assets) {\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        // Check for rounding error since we round down in previewRedeem.\n        require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n        beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        address(asset).safeTransfer(receiver, assets);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function totalAssets() public view virtual returns (uint256);\n\n    /// @inheritdoc IERC4626\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDiv(supply, totalAssets());\n    }\n\n    /// @inheritdoc IERC4626\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDiv(totalAssets(), supply);\n    }\n\n    /// @inheritdoc IERC4626\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    /// @inheritdoc IERC4626\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n    }\n\n    /// @inheritdoc IERC4626\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n    }\n\n    /// @inheritdoc IERC4626\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n        return convertToAssets(shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /// @inheritdoc IERC4626\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /// @inheritdoc IERC4626\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\n        return convertToAssets(balanceOf[owner]);\n    }\n\n    /// @inheritdoc IERC4626\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\n\n    function afterDeposit(uint256 assets, uint256 shares) internal virtual {}\n}"
    },
    {
      "filename": "src/erc-4626/ERC4626MultiToken.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\n\nimport {IERC4626MultiToken} from \"./interfaces/IERC4626MultiToken.sol\";\n\n/// @title Minimal ERC4626 tokenized Vault multi asset implementation\n/// @author Maia DAO (https://github.com/Maia-DAO)\nabstract contract ERC4626MultiToken is ERC20, ReentrancyGuard, IERC4626MultiToken {\n    using SafeTransferLib for address;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626MultiToken\n    address[] public assets;\n\n    /// @inheritdoc IERC4626MultiToken\n    uint256[] public weights;\n\n    /// @inheritdoc IERC4626MultiToken\n    mapping(address => uint256) public assetId;\n\n    /// @inheritdoc IERC4626MultiToken\n    uint256 public totalWeights;\n\n    /// @inheritdoc IERC4626MultiToken\n    function getAssets() external view returns (address[] memory) {\n        return assets;\n    }\n\n    constructor(address[] memory _assets, uint256[] memory _weights, string memory _name, string memory _symbol)\n        ERC20(_name, _symbol, 18)\n    {\n        assets = _assets;\n        weights = _weights;\n\n        uint256 length = _weights.length;\n        uint256 _totalWeights;\n\n        if (length != _assets.length || length == 0) revert InvalidLength();\n\n        for (uint256 i = 0; i < length;) {\n            require(ERC20(_assets[i]).decimals() == 18);\n            require(_weights[i] > 0);\n\n            _totalWeights += _weights[i];\n            assetId[_assets[i]] = i + 1;\n\n            emit AssetAdded(_assets[i], _weights[i]);\n\n            unchecked {\n                i++;\n            }\n        }\n        totalWeights = _totalWeights;\n    }\n\n    function receiveAssets(uint256[] memory assetsAmounts) private {\n        uint256 length = assetsAmounts.length;\n        for (uint256 i = 0; i < length;) {\n            assets[i].safeTransferFrom(msg.sender, address(this), assetsAmounts[i]);\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    function sendAssets(uint256[] memory assetsAmounts, address receiver) private {\n        uint256 length = assetsAmounts.length;\n        for (uint256 i = 0; i < length;) {\n            assets[i].safeTransfer(receiver, assetsAmounts[i]);\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626MultiToken\n    function deposit(uint256[] calldata assetsAmounts, address receiver)\n        public\n        virtual\n        nonReentrant\n        returns (uint256 shares)\n    {\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(assetsAmounts)) != 0, \"ZERO_SHARES\");\n\n        // Need to transfer before minting or ERC777s could reenter.\n        receiveAssets(assetsAmounts);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assetsAmounts, shares);\n\n        afterDeposit(assetsAmounts, shares);\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function mint(uint256 shares, address receiver)\n        public\n        virtual\n        nonReentrant\n        returns (uint256[] memory assetsAmounts)\n    {\n        assetsAmounts = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        receiveAssets(assetsAmounts);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assetsAmounts, shares);\n\n        afterDeposit(assetsAmounts, shares);\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function withdraw(uint256[] calldata assetsAmounts, address receiver, address owner)\n        public\n        virtual\n        nonReentrant\n        returns (uint256 shares)\n    {\n        shares = previewWithdraw(assetsAmounts); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        beforeWithdraw(assetsAmounts, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assetsAmounts, shares);\n\n        sendAssets(assetsAmounts, receiver);\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function redeem(uint256 shares, address receiver, address owner)\n        public\n        virtual\n        nonReentrant\n        returns (uint256[] memory assetsAmounts)\n    {\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        assetsAmounts = previewRedeem(shares);\n        uint256 length = assetsAmounts.length;\n        for (uint256 i = 0; i < length;) {\n            // Check for rounding error since we round down in previewRedeem.\n            if (assetsAmounts[i] == 0) revert ZeroAssets();\n            unchecked {\n                i++;\n            }\n        }\n\n        beforeWithdraw(assetsAmounts, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assetsAmounts, shares);\n\n        sendAssets(assetsAmounts, receiver);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function totalAssets() public view virtual returns (uint256);\n\n    /// @inheritdoc IERC4626MultiToken\n    function convertToShares(uint256[] calldata assetsAmounts) public view virtual returns (uint256 shares) {\n        uint256 _totalWeights = totalWeights;\n        uint256 length = assetsAmounts.length;\n\n        if (length != assets.length) revert InvalidLength();\n\n        shares = type(uint256).max;\n        for (uint256 i = 0; i < length;) {\n            uint256 share = assetsAmounts[i].mulDiv(_totalWeights, weights[i]);\n            if (share < shares) shares = share;\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function convertToAssets(uint256 shares) public view virtual returns (uint256[] memory assetsAmounts) {\n        uint256 _totalWeights = totalWeights;\n        uint256 length = assets.length;\n\n        assetsAmounts = new uint256[](length);\n        for (uint256 i = 0; i < length;) {\n            assetsAmounts[i] = shares.mulDiv(weights[i], _totalWeights);\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function previewDeposit(uint256[] calldata assetsAmounts) public view virtual returns (uint256) {\n        return convertToShares(assetsAmounts);\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function previewMint(uint256 shares) public view virtual returns (uint256[] memory assetsAmounts) {\n        uint256 _totalWeights = totalWeights;\n        uint256 length = assets.length;\n\n        assetsAmounts = new uint256[](length);\n        for (uint256 i = 0; i < length;) {\n            assetsAmounts[i] = shares.mulDivUp(weights[i], _totalWeights);\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function previewWithdraw(uint256[] calldata assetsAmounts) public view virtual returns (uint256 shares) {\n        uint256 _totalWeights = totalWeights;\n        uint256 length = assetsAmounts.length;\n\n        if (length != assets.length) revert InvalidLength();\n\n        for (uint256 i = 0; i < length;) {\n            uint256 share = assetsAmounts[i].mulDivUp(_totalWeights, weights[i]);\n            if (share > shares) shares = share;\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function previewRedeem(uint256 shares) public view virtual returns (uint256[] memory) {\n        return convertToAssets(shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626MultiToken\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function maxWithdraw(address owner) public view virtual returns (uint256[] memory) {\n        return convertToAssets(balanceOf[owner]);\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function beforeWithdraw(uint256[] memory assetsAmounts, uint256 shares) internal virtual {}\n\n    function afterDeposit(uint256[] memory assetsAmounts, uint256 shares) internal virtual {}\n}"
    },
    {
      "filename": "src/talos/boost-aggregator/BoostAggregator.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\nimport {INonfungiblePositionManager} from \"@uniswap/v3-periphery/contracts/interfaces/INonfungiblePositionManager.sol\";\n\nimport {bHermesBoost} from \"@hermes/tokens/bHermesBoost.sol\";\nimport {UniswapV3Staker} from \"@v3-staker/UniswapV3Staker.sol\";\n\nimport {IBoostAggregator} from \"../interfaces/IBoostAggregator.sol\";\n\n/// @title Boost Aggregator for Uniswap V3 NFTs\ncontract BoostAggregator is Ownable, IBoostAggregator {\n    using SafeTransferLib for address;\n\n    /*//////////////////////////////////////////////////////////////\n                        BOOST AGGREGATOR STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBoostAggregator\n    INonfungiblePositionManager public immutable nonfungiblePositionManager;\n\n    /// @inheritdoc IBoostAggregator\n    UniswapV3Staker public immutable uniswapV3Staker;\n\n    /// @inheritdoc IBoostAggregator\n    bHermesBoost public immutable hermesGaugeBoost;\n\n    /// @inheritdoc IBoostAggregator\n    ERC20 public immutable hermes;\n\n    /// @inheritdoc IBoostAggregator\n    mapping(address => address) public userToRewardsDepot;\n\n    /// @inheritdoc IBoostAggregator\n    mapping(uint256 => address) public tokenIdToUser;\n\n    /// @inheritdoc IBoostAggregator\n    mapping(uint256 => uint256) public tokenIdRewards;\n\n    /// @inheritdoc IBoostAggregator\n    mapping(address => bool) public whitelistedAddresses;\n\n    /// @inheritdoc IBoostAggregator\n    uint256 public protocolRewards;\n\n    /// @inheritdoc IBoostAggregator\n    uint256 public protocolFee = 2000; // 20%\n    // divisioner for protocol fee\n    uint256 private constant DIVISIONER = 10000;\n\n    /**\n     * @notice Creates a new BoostAggregator\n     * @param _uniswapV3Staker The UniswapV3Staker contract\n     * @param _hermes The hermes token contract\n     * @param _owner The owner of this contract\n     */\n    constructor(UniswapV3Staker _uniswapV3Staker, ERC20 _hermes, address _owner) {\n        _initializeOwner(_owner);\n        uniswapV3Staker = _uniswapV3Staker;\n        hermesGaugeBoost = uniswapV3Staker.hermesGaugeBoost();\n        nonfungiblePositionManager = uniswapV3Staker.nonfungiblePositionManager();\n        hermes = _hermes;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            EXTERNAL HOOKS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC721Receiver\n    /// @dev msg.sender not validated to be nonfungiblePositionManager in order to allow\n    ///      whitelisted addresses to retrieve NFTs incorrectly sent to this contract\n    function onERC721Received(address, address from, uint256 tokenId, bytes calldata)\n        external\n        override\n        onlyWhitelisted(from)\n        returns (bytes4)\n    {\n        // update tokenIdRewards prior to staking\n        tokenIdRewards[tokenId] = uniswapV3Staker.tokenIdRewards(tokenId);\n        // map tokenId to user\n        tokenIdToUser[tokenId] = from;\n        // stake NFT to Uniswap V3 Staker\n        nonfungiblePositionManager.safeTransferFrom(address(this), address(uniswapV3Staker), tokenId);\n\n        return this.onERC721Received.selector;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        REWARD DEPOTS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBoostAggregator\n    function setOwnRewardsDepot(address rewardsDepot) external {\n        userToRewardsDepot[msg.sender] = rewardsDepot;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            UNSTAKE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBoostAggregator\n    function unstakeAndWithdraw(uint256 tokenId) external {\n        address user = tokenIdToUser[tokenId];\n        if (user != msg.sender) revert NotTokenIdOwner();\n\n        // unstake NFT from Uniswap V3 Staker\n        uniswapV3Staker.unstakeToken(tokenId);\n\n        uint256 pendingRewards = uniswapV3Staker.tokenIdRewards(tokenId) - tokenIdRewards[tokenId];\n\n        if (pendingRewards > DIVISIONER) {\n            uint256 newProtocolRewards = (pendingRewards * protocolFee) / DIVISIONER;\n            /// @dev protocol rewards stay in stake contract\n            protocolRewards += newProtocolRewards;\n            pendingRewards -= newProtocolRewards;\n\n            address rewardsDepot = userToRewardsDepot[user];\n            if (rewardsDepot != address(0)) {\n                // claim rewards to user's rewardsDepot\n                uniswapV3Staker.claimReward(rewardsDepot, pendingRewards);\n            } else {\n                // claim rewards to user\n                uniswapV3Staker.claimReward(user, pendingRewards);\n            }\n        }\n\n        // withdraw rewards from Uniswap V3 Staker\n        uniswapV3Staker.withdrawToken(tokenId, user, \"\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ADMIN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBoostAggregator\n    function addWhitelistedAddress(address user) external onlyOwner {\n        whitelistedAddresses[user] = true;\n    }\n\n    /// @inheritdoc IBoostAggregator\n    function removeWhitelistedAddress(address user) external onlyOwner {\n        delete whitelistedAddresses[user];\n    }\n\n    /// @inheritdoc IBoostAggregator\n    function setProtocolFee(uint256 _protocolFee) external onlyOwner {\n        if (_protocolFee > DIVISIONER) revert FeeTooHigh();\n        protocolFee = _protocolFee;\n    }\n\n    /// @inheritdoc IBoostAggregator\n    function withdrawProtocolFees(address to) external onlyOwner {\n        uniswapV3Staker.claimReward(to, protocolRewards);\n        delete protocolRewards;\n    }\n\n    /// @inheritdoc IBoostAggregator\n    function withdrawAllGaugeBoost(address to) external onlyOwner {\n        /// @dev May run out of gas.\n        hermesGaugeBoost.decrementAllGaugesAllBoost();\n        address(hermesGaugeBoost).safeTransfer(to, hermesGaugeBoost.balanceOf(address(this)));\n    }\n\n    /// @inheritdoc IBoostAggregator\n    function withdrawGaugeBoost(address to, uint256 amount) external onlyOwner {\n        /// @dev May run out of gas.\n        hermesGaugeBoost.decrementAllGaugesBoost(amount);\n        hermesGaugeBoost.updateUserBoost(address(this));\n        address(hermesGaugeBoost).safeTransfer(to, amount);\n    }\n\n    /// @inheritdoc IBoostAggregator\n    function decrementGaugesBoostIndexed(uint256 boost, uint256 offset, uint256 num) external onlyOwner {\n        hermesGaugeBoost.decrementGaugesBoostIndexed(boost, offset, num);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                                MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Only whitelisted addresses\n    /// @param from The address who the NFT is being transferred from\n    modifier onlyWhitelisted(address from) {\n        if (!whitelistedAddresses[from]) revert Unauthorized();\n        _;\n    }\n}"
    },
    {
      "filename": "src/ulysses-omnichain/BranchPort.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IPortStrategy} from \"./interfaces/IPortStrategy.sol\";\nimport {IBranchPort} from \"./interfaces/IBranchPort.sol\";\n\nimport {ERC20hTokenBranch} from \"./token/ERC20hTokenBranch.sol\";\n\n/// @title Branch Port - Omnichain Token Management Contract\ncontract BranchPort is Ownable, IBranchPort {\n    using SafeTransferLib for address;\n\n    /// @notice Local Core Branch Router Address.\n    address public coreBranchRouterAddress;\n\n    /*///////////////////////////////////////////////////////////////\n                        BRIDGE AGENT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mapping from Underlying Address to isUnderlying (bool).\n    mapping(address => bool) public isBridgeAgent;\n\n    /// @notice Branch Routers deployed in branc chain.\n    address[] public bridgeAgents;\n\n    /// @notice Number of Branch Routers deployed in current chain.\n    uint256 public bridgeAgentsLenght;\n\n    /*///////////////////////////////////////////////////////////////\n                    BRIDGE AGENT FACTORIES STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mapping from Underlying Address to isUnderlying (bool).\n    mapping(address => bool) public isBridgeAgentFactory;\n\n    /// @notice Branch Routers deployed in branc chain.\n    address[] public bridgeAgentFactories;\n\n    /// @notice Number of Branch Routers deployed in current chain.\n    uint256 public bridgeAgentFactoriesLenght;\n\n    /*///////////////////////////////////////////////////////////////\n                        PORT STRATEGY STATE\n    //////////////////////////////////////////////////////////////*/\n    /// Strategy Tokens\n\n    /// @notice Mapping returns true if Strategy Token Address is active for usage in Port Strategies.\n    mapping(address => bool) public isStrategyToken;\n\n    /// @notice List of Tokens whitelisted for usage in Port Strategies.\n    address[] public strategyTokens;\n\n    /// @notice Number of Port Strategies deployed in current branch chain.\n    uint256 public strategyTokensLenght;\n\n    /// @notice Mapping returns a given token's total debt incurred by Port Strategies.\n    mapping(address => uint256) public getStrategyTokenDebt;\n\n    /// @notice Mapping returns the minimum ratio of a given Strategy Token the Port should hold.\n    mapping(address => uint256) public getMinimumTokenReserveRatio;\n\n    /// Port Strategies\n\n    /// @notice Mapping returns true if Port Startegy is allowed to manage a given Strategy Token. Strategy => Token => bool.\n    mapping(address => mapping(address => bool)) public isPortStrategy;\n\n    /// @notice Port Strategy Addresses deployed in current branch chain.\n    address[] public portStrategies;\n\n    /// @notice Number of Port Strategies deployed in current branch chain.\n    uint256 public portStrategiesLenght;\n\n    /// @notice Mapping returns the amount of Strategy Token debt a given Port Startegy has.  Strategy => Token => uint256.\n    mapping(address => mapping(address => uint256)) public getPortStrategyTokenDebt;\n\n    /// @notice Mapping returns the last time a given Port Strategy managed a given Strategy Token. Strategy => Token => uint256.\n    mapping(address => mapping(address => uint256)) public lastManaged;\n\n    /// @notice Mapping returns the time limit a given Port Strategy must wait before managing a Strategy Token. Strategy => Token => uint256.\n    mapping(address => mapping(address => uint256)) public strategyDailyLimitAmount;\n\n    /// @notice Mapping returns the amount of a Strategy Token a given Port Strategy can manage.\n    mapping(address => mapping(address => uint256)) public strategyDailyLimitRemaining;\n\n    uint256 internal constant DIVISIONER = 1e4;\n    uint256 internal constant MIN_RESERVE_RATIO = 3e3;\n\n    constructor(address _owner) {\n        require(_owner != address(0), \"Owner is zero address\");\n        _initializeOwner(_owner);\n    }\n\n    function initialize(address _coreBranchRouter, address _bridgeAgentFactory) external virtual onlyOwner {\n        require(coreBranchRouterAddress == address(0), \"Contract already initialized\");\n        require(!isBridgeAgentFactory[_bridgeAgentFactory], \"Contract already initialized\");\n\n        require(_coreBranchRouter != address(0), \"CoreBranchRouter is zero address\");\n        require(_bridgeAgentFactory != address(0), \"BridgeAgentFactory is zero address\");\n\n        coreBranchRouterAddress = _coreBranchRouter;\n        isBridgeAgentFactory[_bridgeAgentFactory] = true;\n        bridgeAgentFactories.push(_bridgeAgentFactory);\n        bridgeAgentFactoriesLenght++;\n    }\n\n    /// @notice Function being overrriden to prevent mistakenly renouncing ownership.\n    function renounceOwnership() public payable override onlyOwner {\n        revert(\"Cannot renounce ownership\");\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns amount of Strategy Tokens\n     *   @param _token Address of a given Strategy Token.\n     *   @return uint256 excess reserves\n     */\n    function _excessReserves(address _token) internal view returns (uint256) {\n        uint256 currBalance = ERC20(_token).balanceOf(address(this));\n        uint256 minReserves = _minimumReserves(currBalance, _token);\n        return currBalance > minReserves ? currBalance - minReserves : 0;\n    }\n\n    /**\n     * @notice Returns amount of Strategy Tokens needed to reach minimum reserves\n     *   @param _token Address of a given Strategy Token.\n     *   @return uint256 excess reserves\n     */\n    function _reservesLacking(address _token) internal view returns (uint256) {\n        uint256 currBalance = ERC20(_token).balanceOf(address(this));\n        uint256 minReserves = _minimumReserves(currBalance, _token);\n        return currBalance < minReserves ? minReserves - currBalance : 0;\n    }\n\n    /**\n     * @notice Internal function to return the minimum amount of reserves of a given Strategy Token the Port should hold.\n     *   @param _currBalance Current balance of a given Strategy Token.\n     *   @param _token Address of a given Strategy Token.\n     *   @return uint256 minimum reserves\n     */\n    function _minimumReserves(uint256 _currBalance, address _token) internal view returns (uint256) {\n        return ((_currBalance + getStrategyTokenDebt[_token]) * getMinimumTokenReserveRatio[_token]) / DIVISIONER;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        PORT STRATEGY FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchPort\n    function manage(address _token, uint256 _amount) external requiresPortStrategy(_token) {\n        if (_amount > _excessReserves(_token)) revert InsufficientReserves();\n\n        _checkTimeLimit(_token, _amount);\n\n        getStrategyTokenDebt[_token] += _amount;\n        getPortStrategyTokenDebt[msg.sender][_token] += _amount;\n\n        _token.safeTransfer(msg.sender, _amount);\n\n        emit DebtCreated(msg.sender, _token, _amount);\n    }\n\n    /// @inheritdoc IBranchPort\n    function replenishReserves(address _strategy, address _token, uint256 _amount) external lock {\n        if (!isStrategyToken[_token]) revert UnrecognizedStrategyToken();\n        if (!isPortStrategy[_strategy][_token]) revert UnrecognizedPortStrategy();\n\n        uint256 reservesLacking = _reservesLacking(_token);\n\n        uint256 amountToWithdraw = _amount < reservesLacking ? _amount : reservesLacking;\n\n        IPortStrategy(_strategy).withdraw(address(this), _token, amountToWithdraw);\n\n        getPortStrategyTokenDebt[_strategy][_token] -= amountToWithdraw;\n        getStrategyTokenDebt[_token] -= amountToWithdraw;\n\n        emit DebtRepaid(_strategy, _token, amountToWithdraw);\n    }\n\n    /**\n     * @notice Internal function to check if a Port Strategy has reached its daily management limit.\n     *   @param _token address being managed.\n     *   @param _amount of token being requested.\n     */\n    function _checkTimeLimit(address _token, uint256 _amount) internal {\n        if (block.timestamp - lastManaged[msg.sender][_token] >= 1 days) {\n            strategyDailyLimitRemaining[msg.sender][_token] = strategyDailyLimitAmount[msg.sender][_token];\n        }\n        strategyDailyLimitRemaining[msg.sender][_token] -= _amount;\n        lastManaged[msg.sender][_token] = block.timestamp;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchPort\n    function withdraw(address _recipient, ad"
    }
  ]
}