{
  "Title": "[03] `claim` inside `LendingLedger` will revert if market removed from whitelist",
  "Content": "\n*Note: At the judgeâ€™s request [here](https://github.com/code-423n4/2024-03-neobase-findings/issues/7#issuecomment-2043851806), this downgraded issue from the same warden has been included in this report for completeness.*\n\nIf a market is removed from the whitelist before a user claims the reward, users cannot claim it, and the reward will remain stuck.\n\n### Proof of Concept\n\nWhen users want to claim the reward from `LendingLedger` by calling `claim`, it will trigger `update_market` first before contract sending the reward to users.\n\nhttps://github.com/code-423n4/2024-03-neobase/blob/main/src/LendingLedger.sol#L122\n\n```solidity\n    function claim(address _market) external {\n>>>     update_market(_market); // Checks if the market is whitelisted\n        MarketInfo storage market = marketInfo[_market];\n        UserInfo storage user = userInfo[_market][msg.sender];\n        int256 accumulatedCanto = int256((uint256(user.amount) * market.accCantoPerShare) / 1e18);\n        int256 cantoToSend = accumulatedCanto - user.rewardDebt;\n\n        user.rewardDebt = accumulatedCanto;\n\n        if (cantoToSend > 0) {\n            (bool success, ) = msg.sender.call{value: uint256(cantoToSend)}(\"\");\n            require(success, \"Failed to send CANTO\");\n        }\n    }\n```\n\nInside `update_market`, if the market is not whitelisted, the call will revert.\n\nhttps://github.com/code-423n4/2024-03-neobase/blob/main/src/LendingLedger.sol#L65\n\n```solidity\n    function update_market(address _market) public {\n>>>     require(lendingMarketWhitelist[_market], \"Market not whitelisted\");\n        MarketInfo storage market = marketInfo[_market];\n        if (block.number > market.lastRewardBlock) {\n            uint256 marketSupply = lendingMarketTotalBalance[_market];\n            if (marketSupply > 0) {\n                uint256 i = market.lastRewardBlock;\n                while (i < block.number) {\n                    uint256 epoch = (i / BLOCK_EPOCH) * BLOCK_EPOCH; // Rewards and voting weights are aligned on a weekly basis\n                    uint256 nextEpoch = epoch + BLOCK_EPOCH;\n                    uint256 blockDelta = Math.min(nextEpoch, block.number) - i;\n                    // May not be the exact time, but will ensure that it is equal for all users and epochs.\n                    // If this ever drifts significantly, the average block time and / or reference block time & number can be updated. However, update_market needs to be called for all markets beforehand.\n                    uint256 epochTime = referenceBlockTime +\n                        ((block.number - referenceBlockNumber) * averageBlockTime) /\n                        1000;\n                    market.accCantoPerShare += uint128(\n                        (blockDelta *\n                            cantoPerBlock[epoch] *\n                            gaugeController.gauge_relative_weight_write(_market, epochTime)) / marketSupply\n                    );\n                    market.secRewardsPerShare += uint128((blockDelta * 1e36) / marketSupply); // Scale by 1e18, consumers need to divide by it\n                    i += blockDelta;\n                }\n            }\n            market.lastRewardBlock = uint64(block.number);\n        }\n    }\n```\n\nThis could lead to an issue, if the market is removed from the whitelist before users can claim the reward, they cannot claim it, and the reward will remain stuck inside `LendingLedger`.\n\n### Recommended Mitigation Steps\n\nConsider to allow users provide additional flag param when calling `claim` so they can claim reward without triggering `update_market`.\n\n```diff\n-   function claim(address _market) external {\n+   function claim(address _market, bool updateMarket) external {\n-       update_market(_market); // Checks if the market is whitelisted\n+       if (updateMarket) {\n+         update_market(_market); \n+       }\n        MarketInfo storage market = marketInfo[_market];\n        UserInfo storage user = userInfo[_market][msg.sender];\n        int256 accumulatedCanto = int256((uint256(user.amount) * market.accCantoPerShare) / 1e18);\n        int256 cantoToSend = accumulatedCanto - user.rewardDebt;\n\n        user.rewardDebt = accumulatedCanto;\n\n        if (cantoToSend > 0) {\n            (bool success, ) = msg.sender.call{value: uint256(cantoToSend)}(\"\");\n            require(success, \"Failed to send CANTO\");\n        }\n    }\n```\n\n### Assessed type\n\nInvalid Validation\n\n**[OpenCoreCH (Neobase) acknowledged and commented](https://github.com/code-423n4/2024-03-neobase-findings/issues/6#issuecomment-2041160347):**\n> Technically true, but not really a problem for us/by design. Removing from the whitelist (i.e. blacklisting) is a permissioned operation that should only be performed under exceptional circumstances (e.g. when the corresponding market is exploited). I am not sure if the suggestion would be better in such scenarios because an attacker (that may have already performed some sync calls) could then still claim.\n\n**[0xTheC0der (judge) decreased severity to Low and commented](https://github.com/code-423n4/2024-03-neobase-findings/issues/6#issuecomment-2041582109):**\n> Blacklisting is intended by design, governance controlled and [reversible](https://github.com/code-423n4/2024-03-neobase/blob/d6e6127e6763b93c23ee95cdf7622fe950d9ed30/src/LendingLedger.sol#L154-L171). Therefore, rewards are not irrecoverably locked.\n\n***\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-03-neobase",
  "Code": [
    {
      "filename": "src/LendingLedger.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.16;\n\nimport {VotingEscrow} from \"./VotingEscrow.sol\";\nimport {GaugeController} from \"./GaugeController.sol\";\nimport {LiquidityGauge} from \"./LiquidityGauge.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {IERC20, SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ncontract LendingLedger {\n    // Constants\n    uint256 public constant BLOCK_EPOCH = 100_000; // 100000 blocks, roughly 1 week\n    uint256 public averageBlockTime = 5700; // Average block time in milliseconds\n    uint256 public referenceBlockNumber;\n    uint256 public referenceBlockTime; // Used to convert block numbers to timestamps together with averageBlockTime\n\n    // State\n    address public governance;\n    GaugeController public gaugeController;\n    mapping(address => bool) public lendingMarketWhitelist;\n\n    /// @dev Info for each user.\n    struct UserInfo {\n        uint256 amount; // Amount of cNOTE that the user has provided.\n        int256 rewardDebt; // Amount of CANTO entitled to the user.\n        int256 secRewardDebt; // Amount of secondary rewards entitled to the user.\n    }\n\n    /// @dev Info of each lending market.\n    struct MarketInfo {\n        uint128 accCantoPerShare;\n        uint128 secRewardsPerShare;\n        uint64 lastRewardBlock;\n    }\n\n    mapping(address => mapping(address => UserInfo)) public userInfo; // Info of each user for the different lending markets\n    mapping(address => MarketInfo) public marketInfo; // Info of each lending market\n\n    mapping(uint256 => uint256) public cantoPerBlock; // CANTO per block for each epoch\n\n    /// @dev Lending Market => Epoch => Balance\n    mapping(address => uint256) public lendingMarketTotalBalance; // Total balance locked within the market\n\n    mapping(address => address) public liquidityGauges; // Two way mapping for markets with liquidity gauge enabled\n\n    modifier onlyGovernance() {\n        require(msg.sender == governance);\n        _;\n    }\n\n    constructor(address _gaugeController, address _governance) {\n        gaugeController = GaugeController(_gaugeController);\n        governance = _governance;\n        referenceBlockNumber = block.number;\n        referenceBlockTime = block.timestamp;\n    }\n\n    /// @notice Set governance address\n    /// @param _governance New governance address\n    function setGovernance(address _governance) external onlyGovernance {\n        governance = _governance;\n    }\n\n    function update_market(address _market) public {\n        require(lendingMarketWhitelist[_market], \"Market not whitelisted\");\n        MarketInfo storage market = marketInfo[_market];\n        if (block.number > market.lastRewardBlock) {\n            uint256 marketSupply = lendingMarketTotalBalance[_market];\n            if (marketSupply > 0) {\n                uint256 i = market.lastRewardBlock;\n                while (i < block.number) {\n                    uint256 epoch = (i / BLOCK_EPOCH) * BLOCK_EPOCH; // Rewards and voting weights are aligned on a weekly basis\n                    uint256 nextEpoch = epoch + BLOCK_EPOCH;\n                    uint256 blockDelta = Math.min(nextEpoch, block.number) - i;\n                    // May not be the exact time, but will ensure that it is equal for all users and epochs.\n                    // If this ever drifts significantly, the average block time and / or reference block time & number can be updated. However, update_market needs to be called for all markets beforehand.\n                    uint256 epochTime = referenceBlockTime +\n                        ((block.number - referenceBlockNumber) * averageBlockTime) /\n                        1000;\n                    market.accCantoPerShare += uint128(\n                        (blockDelta *\n                            cantoPerBlock[epoch] *\n                            gaugeController.gauge_relative_weight_write(_market, epochTime)) / marketSupply\n                    );\n                    market.secRewardsPerShare += uint128((blockDelta * 1e36) / marketSupply); // Scale by 1e18, consumers need to divide by it\n                    i += blockDelta;\n                }\n            }\n            market.lastRewardBlock = uint64(block.number);\n        }\n    }\n\n    /// @notice Function that is called by the lending market on cNOTE deposits / withdrawals\n    /// @param _lender The address of the lender\n    /// @param _delta The amount of cNote deposited (positive) or withdrawn (negative)\n    function sync_ledger(address _lender, int256 _delta) external {\n        address lendingMarket = msg.sender;\n        // check if liquidity gauge is being used for the market\n        if (liquidityGauges[lendingMarket] != address(0)) lendingMarket = liquidityGauges[lendingMarket];\n\n        update_market(lendingMarket); // Checks if the market is whitelisted\n        MarketInfo storage market = marketInfo[lendingMarket];\n        UserInfo storage user = userInfo[lendingMarket][_lender];\n\n        if (_delta >= 0) {\n            user.amount += uint256(_delta);\n            user.rewardDebt += int256((uint256(_delta) * market.accCantoPerShare) / 1e18);\n            user.secRewardDebt += int256((uint256(_delta) * market.secRewardsPerShare) / 1e18);\n        } else {\n            user.amount -= uint256(-_delta);\n            user.rewardDebt -= int256((uint256(-_delta) * market.accCantoPerShare) / 1e18);\n            user.secRewardDebt -= int256((uint256(-_delta) * market.secRewardsPerShare) / 1e18);\n        }\n        int256 updatedMarketBalance = int256(lendingMarketTotalBalance[lendingMarket]) + _delta;\n        require(updatedMarketBalance >= 0, \"Market balance underflow\"); // Sanity check performed here, but the market should ensure that this never happens\n        lendingMarketTotalBalance[lendingMarket] = uint256(updatedMarketBalance);\n    }\n\n    /// @notice Claim the CANTO for a given market. Can only be performed for prior (i.e. finished) epochs, not the current one\n    /// @param _market Address of the market\n    function claim(address _market) external {\n        update_market(_market); // Checks if the market is whitelisted\n        MarketInfo storage market = marketInfo[_market];\n        UserInfo storage user = userInfo[_market][msg.sender];\n        int256 accumulatedCanto = int256((uint256(user.amount) * market.accCantoPerShare) / 1e18);\n        int256 cantoToSend = accumulatedCanto - user.rewardDebt;\n\n        user.rewardDebt = accumulatedCanto;\n\n        if (cantoToSend > 0) {\n            (bool success, ) = msg.sender.call{value: uint256(cantoToSend)}(\"\");\n            require(success, \"Failed to send CANTO\");\n        }\n    }\n\n    /// @notice Used by governance to set the overall CANTO rewards per epoch\n    /// @param _fromEpoch From which epoch (provided as block number) to set the rewards from\n    /// @param _toEpoch Until which epoch (provided as block number) to set the rewards to\n    /// @param _amountPerBlock The amount per block\n    function setRewards(\n        uint256 _fromEpoch,\n        uint256 _toEpoch,\n        uint256 _amountPerBlock\n    ) external onlyGovernance {\n        require(_fromEpoch % BLOCK_EPOCH == 0 && _toEpoch % BLOCK_EPOCH == 0, \"Invalid block number\");\n        for (uint256 i = _fromEpoch; i <= _toEpoch; i += BLOCK_EPOCH) {\n            cantoPerBlock[i] = _amountPerBlock;\n        }\n    }\n\n    /// @notice Used by governance to whitelist a lending market\n    /// @param _market Address of the market to whitelist\n    /// @param _isWhiteListed Whether the market is whitelisted or not\n    function whiteListLendingMarket(\n        address _market,\n        bool _isWhiteListed,\n        bool _hasGauge\n    ) external onlyGovernance {\n        require(lendingMarketWhitelist[_market] != _isWhiteListed, \"No change\");\n        if (_hasGauge && liquidityGauges[_market] == address(0)) {\n            LiquidityGauge liquidityGauge = new LiquidityGauge(_market, address(this));\n            liquidityGauges[_market] = address(liquidityGauge);\n            // add reverse also for reference in sync_ledger\n            liquidityGauges[address(liquidityGauge)] = _market;\n        }\n\n        lendingMarketWhitelist[_market] = _isWhiteListed;\n        if (_isWhiteListed) {\n            marketInfo[_market].lastRewardBlock = uint64(block.number);\n        }\n    }\n\n    /// @notice Used by governance to set the block time parameters if the drift is too large\n    /// @param _averageBlockTime The average block time in milliseconds\n    /// @param _referenceBlockTime The reference block time\n    /// @param _referenceBlockNumber The reference block number\n    function setBlockTimeParameters(\n        uint256 _averageBlockTime,\n        uint256 _referenceBlockTime,\n        uint256 _referenceBlockNumber\n    ) external onlyGovernance {\n        averageBlockTime = _averageBlockTime;\n        referenceBlockTime = _referenceBlockTime;\n        referenceBlockNumber = _referenceBlockNumber;\n    }\n\n    receive() external payable {}\n}"
    },
    {
      "filename": "src/LendingLedger.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.16;\n\nimport {VotingEscrow} from \"./VotingEscrow.sol\";\nimport {GaugeController} from \"./GaugeController.sol\";\nimport {LiquidityGauge} from \"./LiquidityGauge.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {IERC20, SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ncontract LendingLedger {\n    // Constants\n    uint256 public constant BLOCK_EPOCH = 100_000; // 100000 blocks, roughly 1 week\n    uint256 public averageBlockTime = 5700; // Average block time in milliseconds\n    uint256 public referenceBlockNumber;\n    uint256 public referenceBlockTime; // Used to convert block numbers to timestamps together with averageBlockTime\n\n    // State\n    address public governance;\n    GaugeController public gaugeController;\n    mapping(address => bool) public lendingMarketWhitelist;\n\n    /// @dev Info for each user.\n    struct UserInfo {\n        uint256 amount; // Amount of cNOTE that the user has provided.\n        int256 rewardDebt; // Amount of CANTO entitled to the user.\n        int256 secRewardDebt; // Amount of secondary rewards entitled to the user.\n    }\n\n    /// @dev Info of each lending market.\n    struct MarketInfo {\n        uint128 accCantoPerShare;\n        uint128 secRewardsPerShare;\n        uint64 lastRewardBlock;\n    }\n\n    mapping(address => mapping(address => UserInfo)) public userInfo; // Info of each user for the different lending markets\n    mapping(address => MarketInfo) public marketInfo; // Info of each lending market\n\n    mapping(uint256 => uint256) public cantoPerBlock; // CANTO per block for each epoch\n\n    /// @dev Lending Market => Epoch => Balance\n    mapping(address => uint256) public lendingMarketTotalBalance; // Total balance locked within the market\n\n    mapping(address => address) public liquidityGauges; // Two way mapping for markets with liquidity gauge enabled\n\n    modifier onlyGovernance() {\n        require(msg.sender == governance);\n        _;\n    }\n\n    constructor(address _gaugeController, address _governance) {\n        gaugeController = GaugeController(_gaugeController);\n        governance = _governance;\n        referenceBlockNumber = block.number;\n        referenceBlockTime = block.timestamp;\n    }\n\n    /// @notice Set governance address\n    /// @param _governance New governance address\n    function setGovernance(address _governance) external onlyGovernance {\n        governance = _governance;\n    }\n\n    function update_market(address _market) public {\n        require(lendingMarketWhitelist[_market], \"Market not whitelisted\");\n        MarketInfo storage market = marketInfo[_market];\n        if (block.number > market.lastRewardBlock) {\n            uint256 marketSupply = lendingMarketTotalBalance[_market];\n            if (marketSupply > 0) {\n                uint256 i = market.lastRewardBlock;\n                while (i < block.number) {\n                    uint256 epoch = (i / BLOCK_EPOCH) * BLOCK_EPOCH; // Rewards and voting weights are aligned on a weekly basis\n                    uint256 nextEpoch = epoch + BLOCK_EPOCH;\n                    uint256 blockDelta = Math.min(nextEpoch, block.number) - i;\n                    // May not be the exact time, but will ensure that it is equal for all users and epochs.\n                    // If this ever drifts significantly, the average block time and / or reference block time & number can be updated. However, update_market needs to be called for all markets beforehand.\n                    uint256 epochTime = referenceBlockTime +\n                        ((block.number - referenceBlockNumber) * averageBlockTime) /\n                        1000;\n                    market.accCantoPerShare += uint128(\n                        (blockDelta *\n                            cantoPerBlock[epoch] *\n                            gaugeController.gauge_relative_weight_write(_market, epochTime)) / marketSupply\n                    );\n                    market.secRewardsPerShare += uint128((blockDelta * 1e36) / marketSupply); // Scale by 1e18, consumers need to divide by it\n                    i += blockDelta;\n                }\n            }\n            market.lastRewardBlock = uint64(block.number);\n        }\n    }\n\n    /// @notice Function that is called by the lending market on cNOTE deposits / withdrawals\n    /// @param _lender The address of the lender\n    /// @param _delta The amount of cNote deposited (positive) or withdrawn (negative)\n    function sync_ledger(address _lender, int256 _delta) external {\n        address lendingMarket = msg.sender;\n        // check if liquidity gauge is being used for the market\n        if (liquidityGauges[lendingMarket] != address(0)) lendingMarket = liquidityGauges[lendingMarket];\n\n        update_market(lendingMarket); // Checks if the market is whitelisted\n        MarketInfo storage market = marketInfo[lendingMarket];\n        UserInfo storage user = userInfo[lendingMarket][_lender];\n\n        if (_delta >= 0) {\n            user.amount += uint256(_delta);\n            user.rewardDebt += int256((uint256(_delta) * market.accCantoPerShare) / 1e18);\n            user.secRewardDebt += int256((uint256(_delta) * market.secRewardsPerShare) / 1e18);\n        } else {\n            user.amount -= uint256(-_delta);\n            user.rewardDebt -= int256((uint256(-_delta) * market.accCantoPerShare) / 1e18);\n            user.secRewardDebt -= int256((uint256(-_delta) * market.secRewardsPerShare) / 1e18);\n        }\n        int256 updatedMarketBalance = int256(lendingMarketTotalBalance[lendingMarket]) + _delta;\n        require(updatedMarketBalance >= 0, \"Market balance underflow\"); // Sanity check performed here, but the market should ensure that this never happens\n        lendingMarketTotalBalance[lendingMarket] = uint256(updatedMarketBalance);\n    }\n\n    /// @notice Claim the CANTO for a given market. Can only be performed for prior (i.e. finished) epochs, not the current one\n    /// @param _market Address of the market\n    function claim(address _market) external {\n        update_market(_market); // Checks if the market is whitelisted\n        MarketInfo storage market = marketInfo[_market];\n        UserInfo storage user = userInfo[_market][msg.sender];\n        int256 accumulatedCanto = int256((uint256(user.amount) * market.accCantoPerShare) / 1e18);\n        int256 cantoToSend = accumulatedCanto - user.rewardDebt;\n\n        user.rewardDebt = accumulatedCanto;\n\n        if (cantoToSend > 0) {\n            (bool success, ) = msg.sender.call{value: uint256(cantoToSend)}(\"\");\n            require(success, \"Failed to send CANTO\");\n        }\n    }\n\n    /// @notice Used by governance to set the overall CANTO rewards per epoch\n    /// @param _fromEpoch From which epoch (provided as block number) to set the rewards from\n    /// @param _toEpoch Until which epoch (provided as block number) to set the rewards to\n    /// @param _amountPerBlock The amount per block\n    function setRewards(\n        uint256 _fromEpoch,\n        uint256 _toEpoch,\n        uint256 _amountPerBlock\n    ) external onlyGovernance {\n        require(_fromEpoch % BLOCK_EPOCH == 0 && _toEpoch % BLOCK_EPOCH == 0, \"Invalid block number\");\n        for (uint256 i = _fromEpoch; i <= _toEpoch; i += BLOCK_EPOCH) {\n            cantoPerBlock[i] = _amountPerBlock;\n        }\n    }\n\n    /// @notice Used by governance to whitelist a lending market\n    /// @param _market Address of the market to whitelist\n    /// @param _isWhiteListed Whether the market is whitelisted or not\n    function whiteListLendingMarket(\n        address _market,\n        bool _isWhiteListed,\n        bool _hasGauge\n    ) external onlyGovernance {\n        require(lendingMarketWhitelist[_market] != _isWhiteListed, \"No change\");\n        if (_hasGauge && liquidityGauges[_market] == address(0)) {\n            LiquidityGauge liquidityGauge = new LiquidityGauge(_market, address(this));\n            liquidityGauges[_market] = address(liquidityGauge);\n            // add reverse also for reference in sync_ledger\n            liquidityGauges[address(liquidityGauge)] = _market;\n        }\n\n        lendingMarketWhitelist[_market] = _isWhiteListed;\n        if (_isWhiteListed) {\n            marketInfo[_market].lastRewardBlock = uint64(block.number);\n        }\n    }\n\n    /// @notice Used by governance to set the block time parameters if the drift is too large\n    /// @param _averageBlockTime The average block time in milliseconds\n    /// @param _referenceBlockTime The reference block time\n    /// @param _referenceBlockNumber The reference block number\n    function setBlockTimeParameters(\n        uint256 _averageBlockTime,\n        uint256 _referenceBlockTime,\n        uint256 _referenceBlockNumber\n    ) external onlyGovernance {\n        averageBlockTime = _averageBlockTime;\n        referenceBlockTime = _referenceBlockTime;\n        referenceBlockNumber = _referenceBlockNumber;\n    }\n\n    receive() external payable {}\n}"
    },
    {
      "filename": "src/LendingLedger.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.16;\n\nimport {VotingEscrow} from \"./VotingEscrow.sol\";\nimport {GaugeController} from \"./GaugeController.sol\";\nimport {LiquidityGauge} from \"./LiquidityGauge.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {IERC20, SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ncontract LendingLedger {\n    // Constants\n    uint256 public constant BLOCK_EPOCH = 100_000; // 100000 blocks, roughly 1 week\n    uint256 public averageBlockTime = 5700; // Average block time in milliseconds\n    uint256 public referenceBlockNumber;\n    uint256 public referenceBlockTime; // Used to convert block numbers to timestamps together with averageBlockTime\n\n    // State\n    address public governance;\n    GaugeController public gaugeController;\n    mapping(address => bool) public lendingMarketWhitelist;\n\n    /// @dev Info for each user.\n    struct UserInfo {\n        uint256 amount; // Amount of cNOTE that the user has provided.\n        int256 rewardDebt; // Amount of CANTO entitled to the user.\n        int256 secRewardDebt; // Amount of secondary rewards entitled to the user.\n    }\n\n    /// @dev Info of each lending market.\n    struct MarketInfo {\n        uint128 accCantoPerShare;\n        uint128 secRewardsPerShare;\n        uint64 lastRewardBlock;\n    }\n\n    mapping(address => mapping(address => UserInfo)) public userInfo; // Info of each user for the different lending markets\n    mapping(address => MarketInfo) public marketInfo; // Info of each lending market\n\n    mapping(uint256 => uint256) public cantoPerBlock; // CANTO per block for each epoch\n\n    /// @dev Lending Market => Epoch => Balance\n    mapping(address => uint256) public lendingMarketTotalBalance; // Total balance locked within the market\n\n    mapping(address => address) public liquidityGauges; // Two way mapping for markets with liquidity gauge enabled\n\n    modifier onlyGovernance() {\n        require(msg.sender == governance);\n        _;\n    }\n\n    constructor(address _gaugeController, address _governance) {\n        gaugeController = GaugeController(_gaugeController);\n        governance = _governance;\n        referenceBlockNumber = block.number;\n        referenceBlockTime = block.timestamp;\n    }\n\n    /// @notice Set governance address\n    /// @param _governance New governance address\n    function setGovernance(address _governance) external onlyGovernance {\n        governance = _governance;\n    }\n\n    function update_market(address _market) public {\n        require(lendingMarketWhitelist[_market], \"Market not whitelisted\");\n        MarketInfo storage market = marketInfo[_market];\n        if (block.number > market.lastRewardBlock) {\n            uint256 marketSupply = lendingMarketTotalBalance[_market];\n            if (marketSupply > 0) {\n                uint256 i = market.lastRewardBlock;\n                while (i < block.number) {\n                    uint256 epoch = (i / BLOCK_EPOCH) * BLOCK_EPOCH; // Rewards and voting weights are aligned on a weekly basis\n                    uint256 nextEpoch = epoch + BLOCK_EPOCH;\n                    uint256 blockDelta = Math.min(nextEpoch, block.number) - i;\n                    // May not be the exact time, but will ensure that it is equal for all users and epochs.\n                    // If this ever drifts significantly, the average block time and / or reference block time & number can be updated. However, update_market needs to be called for all markets beforehand.\n                    uint256 epochTime = referenceBlockTime +\n                        ((block.number - referenceBlockNumber) * averageBlockTime) /\n                        1000;\n                    market.accCantoPerShare += uint128(\n                        (blockDelta *\n                            cantoPerBlock[epoch] *\n                            gaugeController.gauge_relative_weight_write(_market, epochTime)) / marketSupply\n                    );\n                    market.secRewardsPerShare += uint128((blockDelta * 1e36) / marketSupply); // Scale by 1e18, consumers need to divide by it\n                    i += blockDelta;\n                }\n            }\n            market.lastRewardBlock = uint64(block.number);\n        }\n    }\n\n    /// @notice Function that is called by the lending market on cNOTE deposits / withdrawals\n    /// @param _lender The address of the lender\n    /// @param _delta The amount of cNote deposited (positive) or withdrawn (negative)\n    function sync_ledger(address _lender, int256 _delta) external {\n        address lendingMarket = msg.sender;\n        // check if liquidity gauge is being used for the market\n        if (liquidityGauges[lendingMarket] != address(0)) lendingMarket = liquidityGauges[lendingMarket];\n\n        update_market(lendingMarket); // Checks if the market is whitelisted\n        MarketInfo storage market = marketInfo[lendingMarket];\n        UserInfo storage user = userInfo[lendingMarket][_lender];\n\n        if (_delta >= 0) {\n            user.amount += uint256(_delta);\n            user.rewardDebt += int256((uint256(_delta) * market.accCantoPerShare) / 1e18);\n            user.secRewardDebt += int256((uint256(_delta) * market.secRewardsPerShare) / 1e18);\n        } else {\n            user.amount -= uint256(-_delta);\n            user.rewardDebt -= int256((uint256(-_delta) * market.accCantoPerShare) / 1e18);\n            user.secRewardDebt -= int256((uint256(-_delta) * market.secRewardsPerShare) / 1e18);\n        }\n        int256 updatedMarketBalance = int256(lendingMarketTotalBalance[lendingMarket]) + _delta;\n        require(updatedMarketBalance >= 0, \"Market balance underflow\"); // Sanity check performed here, but the market should ensure that this never happens\n        lendingMarketTotalBalance[lendingMarket] = uint256(updatedMarketBalance);\n    }\n\n    /// @notice Claim the CANTO for a given market. Can only be performed for prior (i.e. finished) epochs, not the current one\n    /// @param _market Address of the market\n    function claim(address _market) external {\n        update_market(_market); // Checks if the market is whitelisted\n        MarketInfo storage market = marketInfo[_market];\n        UserInfo storage user = userInfo[_market][msg.sender];\n        int256 accumulatedCanto = int256((uint256(user.amount) * market.accCantoPerShare) / 1e18);\n        int256 cantoToSend = accumulatedCanto - user.rewardDebt;\n\n        user.rewardDebt = accumulatedCanto;\n\n        if (cantoToSend > 0) {\n            (bool success, ) = msg.sender.call{value: uint256(cantoToSend)}(\"\");\n            require(success, \"Failed to send CANTO\");\n        }\n    }\n\n    /// @notice Used by governance to set the overall CANTO rewards per epoch\n    /// @param _fromEpoch From which epoch (provided as block number) to set the rewards from\n    /// @param _toEpoch Until which epoch (provided as block number) to set the rewards to\n    /// @param _amountPerBlock The amount per block\n    function setRewards(\n        uint256 _fromEpoch,\n        uint256 _toEpoch,\n        uint256 _amountPerBlock\n    ) external onlyGovernance {\n        require(_fromEpoch % BLOCK_EPOCH == 0 && _toEpoch % BLOCK_EPOCH == 0, \"Invalid block number\");\n        for (uint256 i = _fromEpoch; i <= _toEpoch; i += BLOCK_EPOCH) {\n            cantoPerBlock[i] = _amountPerBlock;\n        }\n    }\n\n    /// @notice Used by governance to whitelist a lending market\n    /// @param _market Address of the market to whitelist\n    /// @param _isWhiteListed Whether the market is whitelisted or not\n    function whiteListLendingMarket(\n        address _market,\n        bool _isWhiteListed,\n        bool _hasGauge\n    ) external onlyGovernance {\n        require(lendingMarketWhitelist[_market] != _isWhiteListed, \"No change\");\n        if (_hasGauge && liquidityGauges[_market] == address(0)) {\n            LiquidityGauge liquidityGauge = new LiquidityGauge(_market, address(this));\n            liquidityGauges[_market] = address(liquidityGauge);\n            // add reverse also for reference in sync_ledger\n            liquidityGauges[address(liquidityGauge)] = _market;\n        }\n\n        lendingMarketWhitelist[_market] = _isWhiteListed;\n        if (_isWhiteListed) {\n            marketInfo[_market].lastRewardBlock = uint64(block.number);\n        }\n    }\n\n    /// @notice Used by governance to set the block time parameters if the drift is too large\n    /// @param _averageBlockTime The average block time in milliseconds\n    /// @param _referenceBlockTime The reference block time\n    /// @param _referenceBlockNumber The reference block number\n    function setBlockTimeParameters(\n        uint256 _averageBlockTime,\n        uint256 _referenceBlockTime,\n        uint256 _referenceBlockNumber\n    ) external onlyGovernance {\n        averageBlockTime = _averageBlockTime;\n        referenceBlockTime = _referenceBlockTime;\n        referenceBlockNumber = _referenceBlockNumber;\n    }\n\n    receive() external payable {}\n}"
    }
  ]
}