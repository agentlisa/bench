{
  "Title": "M-4: In some situations the liquidation can become unprofitable for liquidators, keeping unhealthy positions",
  "Content": "# Issue M-4: In some situations the liquidation can become unprofitable for liquidators, keeping unhealthy positions \n\nSource: https://github.com/sherlock-audit/2023-10-aloe-judging/issues/43 \n\n## Found by \npanprog\n\nWhen liquidators liquidate unhealthy accounts and the swap is required, they receive `LIQUIDATION_INCENTIVE` to compensate for the potentially unprofitable swap price required (as the swap price is the pool average price over the `UNISWAP_AVG_WINDOW`, which lags the current price). However, this only happens when swap is required **at the average price**. The assets composition can be different depending on price if the user has uniswap position as a collateral. Such uniswap position can happen (intentionally or not) to be composed in such way, that it has 100% of one asset at the current average price, but 100% of the other asset at the current market price, thus liquidator's incentive will be 0.\n\nIn particular, it can happen in the following situation:\n1. Current price is different from the average price by a reasonable amount (like 1%+)\n2. Uniswap position is such, that it's fully in one asset at the average price and fully in the other asset at the current price\n\nIn this case, there is no swap required at the average price (thus liquidation incentive = 0), however at the current price a swap of all user assets is required from liquidator at the unfavorable average price (which is worse than current price). Since liquidator doesn't receive its bonus in such case, the liquidation will be unprofitable and liquidator won't liquidate user. \n\n\n## Vulnerability Detail\n\nExample scenario of the situation when liquidation is not profitable for the liquidator:\n1. Current ETH price = 1000 USDT. Average price over the last 30 minutes = 1010 USDT\n2. Alice position is 1 ETH in the range [1000, 1006]. Alice debt is 9990 USDT. Alice account in not healthy.\n3. Bob wants to liquidate Alice account. Since at the average price of 1010 USDT Alice position composition is 0 ETH + 1003 USDT, this fully covers Alice debt and liquidation incentive = 0. However, as the liquidation proceeds, at the current price of 1000 USDT Alice's position will be converted into 1 ETH + 0 USDT and Bob will have to exchange 1 ETH into 1010 USDT without any additional bonus.\n3.1. If Bob decides to liquidate Alice account, Alice will have her 1 ETH converted into 1010 USDT, which she can immediately exchange into 1.01 ETH, creating a profit for Alice (and Bob will lose 10 USDT based on the current ETH price)\n3.2. If Bob is being rational and doesn't luiquidate unprofitably, Alice unhealthy position will remain active without being liquidated.\n\n## Impact\n\nIn some cases, liquidation will require swap of assets at unfavorable (lagging average) price without any bonus for the liquidator. Due to this, liquidation will not happen and user account will stay unhealthy, this can continue for extended time, breaking important protocol mechanism (timely liquidation) and possibly causing bad debt for unhealthy account.\n\n## Code Snippet\n\n`BalanceSheet.computeLiquidationIncentive` sets incentive only when `liabilities0 > assets0` or `liabilities1 > assets1` at the average prices:\nhttps://github.com/sherlock-audit/2023-10-aloe/blob/main/aloe-ii/core/src/libraries/BalanceSheet.sol#L125-L149\n\nIn `liquidation` it is called with compositions of uniswap position assets at the average price (C):\nhttps://github.com/sherlock-audit/2023-10-aloe/blob/main/aloe-ii/core/src/Borrower.sol#L213-L219\n\nHowever, `_getAssets` withdraws uniswap position at current price, which can be different:\nhttps://github.com/sherlock-audit/2023-10-aloe/blob/main/aloe-ii/core/src/Borrower.sol#L209\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nQuite hard to come up with good recommendations here, because allowing liquidation incentive at current price opens up different attack vectors to abuse it. Possibly choose max amount required to swap at average price, average price-5% and average price+5% (or some other %) and pay out based on this max (still not on current price to be fair and not force liquidators manipulate pool for max profit) or something like that.\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**MohammedRizwan** commented:\n>  valid\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/120",
  "Code": [
    {
      "filename": "aloe-ii/core/src/libraries/BalanceSheet.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.17;\n\nimport {FixedPointMathLib as SoladyMath} from \"solady/utils/FixedPointMathLib.sol\";\n\nimport {\n    MAX_LEVERAGE,\n    LIQUIDATION_INCENTIVE,\n    PROBE_SQRT_SCALER_MIN,\n    PROBE_SQRT_SCALER_MAX,\n    LTV_NUMERATOR\n} from \"./constants/Constants.sol\";\nimport {exp1e12} from \"./Exp.sol\";\nimport {square, mulDiv128, mulDiv128Up} from \"./MulDiv.sol\";\nimport {TickMath} from \"./TickMath.sol\";\n\nstruct Assets {\n    // The `Borrower`'s balance of `TOKEN0`, i.e. `TOKEN0.balanceOf(borrower)`\n    uint256 fixed0;\n    // The `Borrower`'s balance of `TOKEN1`, i.e. `TOKEN1.balanceOf(borrower)`\n    uint256 fixed1;\n    // The value of the `Borrower`'s Uniswap liquidity, evaluated at `Prices.a`, denominated in `TOKEN1`\n    uint256 fluid1A;\n    // The value of the `Borrower`'s Uniswap liquidity, evaluated at `Prices.b`, denominated in `TOKEN1`\n    uint256 fluid1B;\n    // The amount of `TOKEN0` underlying the `Borrower`'s Uniswap liquidity, evaluated at `Prices.c`\n    uint256 fluid0C;\n    // The amount of `TOKEN1` underlying the `Borrower`'s Uniswap liquidity, evaluated at `Prices.c`\n    uint256 fluid1C;\n}\n\nstruct Prices {\n    // Some sqrtPriceX96 *less* than the current TWAP\n    uint160 a;\n    // Some sqrtPriceX96 *greater* than the current TWAP\n    uint160 b;\n    // The current TWAP, expressed as a sqrtPriceX96\n    uint160 c;\n}\n\n/// @title BalanceSheet\n/// @notice Provides functions for computing a `Borrower`'s health\n/// @author Aloe Labs, Inc.\nlibrary BalanceSheet {\n    using SoladyMath for uint256;\n\n    /// @dev Checks whether a `Borrower` is healthy given the probe prices and its current assets and liabilities\n    function isHealthy(\n        Prices memory prices,\n        Assets memory mem,\n        uint256 liabilities0,\n        uint256 liabilities1\n    ) internal pure returns (bool) {\n        unchecked {\n            // The optimizer eliminates the conditional in `divUp`; don't worry about gas golfing that\n            liabilities0 +=\n                liabilities0.divUp(MAX_LEVERAGE) +\n                liabilities0.zeroFloorSub(mem.fixed0 + mem.fluid0C).divUp(LIQUIDATION_INCENTIVE);\n            liabilities1 +=\n                liabilities1.divUp(MAX_LEVERAGE) +\n                liabilities1.zeroFloorSub(mem.fixed1 + mem.fluid1C).divUp(LIQUIDATION_INCENTIVE);\n        }\n\n        // combine\n        uint256 priceX128;\n        uint256 liabilities;\n        uint256 assets;\n\n        priceX128 = square(prices.a);\n        liabilities = liabilities1 + mulDiv128Up(liabilities0, priceX128);\n        assets = mem.fluid1A + mem.fixed1 + mulDiv128(mem.fixed0, priceX128);\n        if (liabilities > assets) return false;\n\n        priceX128 = square(prices.b);\n        liabilities = liabilities1 + mulDiv128Up(liabilities0, priceX128);\n        assets = mem.fluid1B + mem.fixed1 + mulDiv128(mem.fixed0, priceX128);\n        if (liabilities > assets) return false;\n\n        return true;\n    }\n\n    /**\n     * Given data from the `ORACLE` (first 3 args) and parameters from the `FACTORY` (last 2 args), computes\n     * the probe prices at which to check the account's health\n     * @param metric The manipulation metric (from oracle)\n     * @param sqrtMeanPriceX96 The current TWAP, expressed as a sqrtPriceX96 (from oracle)\n     * @param iv The estimated implied volatility, expressed as a 1e12 percentage (from oracle)\n     * @param nSigma The number of standard deviations of price movement to account for (from factory)\n     * @param manipulationThresholdDivisor Helps compute the manipulation threshold (from factory). See `Constants.sol`\n     * @return a \\\\( \\text{TWAP} \\cdot e^{-n \\cdot \\sigma} \\\\) expressed as a sqrtPriceX96\n     * @return b \\\\( \\text{TWAP} \\cdot e^{+n \\cdot \\sigma} \\\\) expressed as a sqrtPriceX96\n     * @return seemsLegit Whether the Uniswap TWAP has been manipulated enough to create bad debt at the effective LTV\n     */\n    function computeProbePrices(\n        uint56 metric,\n        uint256 sqrtMeanPriceX96,\n        uint256 iv,\n        uint8 nSigma,\n        uint8 manipulationThresholdDivisor\n    ) internal pure returns (uint160 a, uint160 b, bool seemsLegit) {\n        unchecked {\n            // Essentially sqrt(e^{nSigma*iv}). Note the `Factory` defines `nSigma` with an extra factor of 10\n            uint256 sqrtScaler = uint256(exp1e12(int256((nSigma * iv) / 20))).clamp(\n                PROBE_SQRT_SCALER_MIN,\n                PROBE_SQRT_SCALER_MAX\n            );\n\n            seemsLegit = metric < _manipulationThreshold(_ltv(sqrtScaler), manipulationThresholdDivisor);\n\n            a = uint160((sqrtMeanPriceX96 * 1e12).rawDiv(sqrtScaler).max(TickMath.MIN_SQRT_RATIO));\n            b = uint160((sqrtMeanPriceX96 * sqrtScaler).rawDiv(1e12).min(TickMath.MAX_SQRT_RATIO));\n        }\n    }\n\n    /**\n     * @notice Computes the liquidation incentive that would be paid out if a liquidator closes the account\n     * using a swap with `strain = 1`\n     * @param assets0 The amount of `TOKEN0` held/controlled by the `Borrower` at the current TWAP\n     * @param assets1 The amount of `TOKEN1` held/controlled by the `Borrower` at the current TWAP\n     * @param liabilities0 The amount of `TOKEN0` that the `Borrower` owes to `LENDER0`\n     * @param liabilities1 The amount of `TOKEN1` that the `Borrower` owes to `LENDER1`\n     * @param meanPriceX128 The current TWAP\n     * @return incentive1 The incentive to pay out, denominated in `TOKEN1`\n     */\n    function computeLiquidationIncentive(\n        uint256 assets0,\n        uint256 assets1,\n        uint256 liabilities0,\n        uint256 liabilities1,\n        uint256 meanPriceX128\n    ) internal pure returns (uint256 incentive1) {\n        unchecked {\n            if (liabilities0 > assets0) {\n                // shortfall is the amount that cannot be directly repaid using Borrower assets at this price\n                uint256 shortfall = liabilities0 - assets0;\n                // to cover it, a liquidator may have to use their own assets, taking on inventory risk.\n                // to compensate them for this risk, they're allowed to seize some of the surplus asset.\n                incentive1 += mulDiv128(shortfall, meanPriceX128) / LIQUIDATION_INCENTIVE;\n            }\n\n            if (liabilities1 > assets1) {\n                // shortfall is the amount that cannot be directly repaid using Borrower assets at this price\n                uint256 shortfall = liabilities1 - assets1;\n                // to cover it, a liquidator may have to use their own assets, taking on inventory risk.\n                // to compensate them for this risk, they're allowed to seize some of the surplus asset.\n                incentive1 += shortfall / LIQUIDATION_INCENTIVE;\n            }\n        }\n    }\n\n    /// @dev Equivalent to \\\\( \\frac{log_{1.0001} \\left( \\frac{10^{12}}{ltv} \\right)}{\\text{MANIPULATION_THRESHOLD_DIVISOR}} \\\\)\n    function _manipulationThreshold(uint160 ltv, uint8 manipulationThresholdDivisor) private pure returns (uint24) {\n        unchecked {\n            return uint24(-TickMath.getTickAtSqrtRatio(ltv) - 778261) / (2 * manipulationThresholdDivisor);\n        }\n    }\n\n    /**\n     * @notice The effective LTV implied by `sqrtScaler`. This LTV is accurate for fixed assets and out-of-range\n     * Uniswap positions, but not for in-range Uniswap positions (impermanent losses make their effective LTV\n     * slightly smaller).\n     */\n    function _ltv(uint256 sqrtScaler) private pure returns (uint160 ltv) {\n        unchecked {\n            ltv = uint160(LTV_NUMERATOR.rawDiv(sqrtScaler * sqrtScaler));\n        }\n    }\n}"
    },
    {
      "filename": "aloe-ii/core/src/Borrower.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.17;\n\nimport {ImmutableArgs} from \"clones-with-immutable-args/ImmutableArgs.sol\";\nimport {Math} from \"openzeppelin-contracts/contracts/utils/math/Math.sol\";\nimport {ERC20, SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {IUniswapV3MintCallback} from \"v3-core/contracts/interfaces/callback/IUniswapV3MintCallback.sol\";\nimport {IUniswapV3Pool} from \"v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\n\nimport {LIQUIDATION_GRACE_PERIOD} from \"./libraries/constants/Constants.sol\";\nimport {Q128} from \"./libraries/constants/Q.sol\";\nimport {BalanceSheet, Assets, Prices} from \"./libraries/BalanceSheet.sol\";\nimport {LiquidityAmounts} from \"./libraries/LiquidityAmounts.sol\";\nimport {square, mulDiv128} from \"./libraries/MulDiv.sol\";\nimport {extract} from \"./libraries/Positions.sol\";\nimport {TickMath} from \"./libraries/TickMath.sol\";\n\nimport {Factory} from \"./Factory.sol\";\nimport {Lender} from \"./Lender.sol\";\nimport {VolatilityOracle} from \"./VolatilityOracle.sol\";\n\ninterface ILiquidator {\n    receive() external payable;\n\n    function swap1For0(bytes calldata data, uint256 received1, uint256 expected0) external;\n\n    function swap0For1(bytes calldata data, uint256 received0, uint256 expected1) external;\n}\n\ninterface IManager {\n    /**\n     * @notice Gives the `IManager` full control of the `Borrower`. Called within `Borrower.modify`.\n     * @dev In most cases, you'll want to verify that `msg.sender` is, in fact, a `Borrower` using\n     * `factory.isBorrower(msg.sender)`.\n     * @param data Encoded parameters that were passed to `Borrower.modify`\n     * @param owner The owner of the `Borrower`\n     * @param positions The `Borrower`'s current Uniswap positions. You can convert them to an array using\n     * `Positions.extract`\n     * @return Updated positions, encoded using `Positions.zip`. Return 0 if you don't wish to make any changes.\n     */\n    function callback(bytes calldata data, address owner, uint208 positions) external returns (uint208);\n}\n\n/// @title Borrower\n/// @author Aloe Labs, Inc.\n/// @dev \"Test everything; hold fast what is good.\" - 1 Thessalonians 5:21\ncontract Borrower is IUniswapV3MintCallback {\n    using SafeTransferLib for ERC20;\n\n    /**\n     * @notice Most liquidations involve swapping one asset for another. To incentivize such swaps (even in\n     * volatile markets) liquidators are rewarded with a 5% bonus. To avoid paying that bonus to liquidators,\n     * the account owner can listen for this event. Once it's emitted, they have 2 minutes to bring the\n     * account back to health. If they fail, the liquidation will proceed.\n     * @dev Fortuitous price movements and/or direct `Lender.repay` can bring the account back to health and\n     * nullify the immediate liquidation threat, but they will not clear the warning. This means that next\n     * time the account is unhealthy, liquidators might skip `warn` and `liquidate` right away. To clear the\n     * warning and return to a \"clean\" state, make sure to call `modify` -- even if the callback is a no-op.\n     * @dev The deadline for regaining health (avoiding liquidation) is given by `slot0.unleashLiquidationTime`.\n     * If this value is 0, the account is in the aforementioned \"clean\" state.\n     */\n    event Warn();\n\n    /**\n     * @notice Emitted when the account gets `liquidate`d\n     * @param repay0 The amount of `TOKEN0` that was repaid\n     * @param repay1 The amount of `TOKEN1` that was repaid\n     * @param incentive1 The value of the swap bonus given to the liquidator, expressed in terms of `TOKEN1`\n     * @param priceX128 The price at which the liquidation took place\n     */\n    event Liquidate(uint256 repay0, uint256 repay1, uint256 incentive1, uint256 priceX128);\n\n    enum State {\n        Ready,\n        Locked,\n        InModifyCallback\n    }\n\n    uint256 private constant SLOT0_MASK_POSITIONS = 0x000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffff;\n    uint256 private constant SLOT0_MASK_UNLEASH   = 0x00ffffffffff0000000000000000000000000000000000000000000000000000; // prettier-ignore\n    uint256 private constant SLOT0_MASK_STATE     = 0x7f00000000000000000000000000000000000000000000000000000000000000; // prettier-ignore\n    uint256 private constant SLOT0_DIRT           = 0x8000000000000000000000000000000000000000000000000000000000000000; // prettier-ignore\n\n    /// @notice The factory that created this contract\n    Factory public immutable FACTORY;\n\n    /// @notice The oracle to use for prices and implied volatility\n    VolatilityOracle public immutable ORACLE;\n\n    /// @notice The Uniswap pair in which this `Borrower` can manage positions\n    IUniswapV3Pool public immutable UNISWAP_POOL;\n\n    /// @notice The first token of the Uniswap pair\n    ERC20 public immutable TOKEN0;\n\n    /// @notice The second token of the Uniswap pair\n    ERC20 public immutable TOKEN1;\n\n    /// @notice The lender of `TOKEN0`\n    Lender public immutable LENDER0;\n\n    /// @notice The lender of `TOKEN1`\n    Lender public immutable LENDER1;\n\n    /**\n     * @notice The `Borrower`'s only mutable storage. Lowest 144 bits store the lower/upper bounds of up to 3 Uniswap\n     * positions, encoded by `Positions.zip`. Next 64 bits are unused within the `Borrower` and available to users as\n     * \"free\" storage － no additional sstore's. These 208 bits (144 + 64) are passed to `IManager.callback`, and get\n     * updated when the callback returns a non-zero value. The next 40 bits are either 0 or `unleashLiquidationTime`,\n     * as explained in the `Warn` event docs. The highest 8 bits represent the current `State` enum, plus 128. We add\n     * 128 (i.e. set the highest bit to 1) so that the slot is always non-zero, even in the absence of Uniswap\n     * positions － this saves gas.\n     */\n    uint256 public slot0;\n\n    modifier onlyInModifyCallback() {\n        require(slot0 & SLOT0_MASK_STATE == uint256(State.InModifyCallback) << 248);\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(VolatilityOracle oracle, IUniswapV3Pool pool, Lender lender0, Lender lender1) {\n        FACTORY = Factory(msg.sender);\n        ORACLE = oracle;\n        UNISWAP_POOL = pool;\n        LENDER0 = lender0;\n        LENDER1 = lender1;\n\n        TOKEN0 = lender0.asset();\n        TOKEN1 = lender1.asset();\n\n        assert(pool.token0() == address(TOKEN0) && pool.token1() == address(TOKEN1));\n    }\n\n    receive() external payable {}\n\n    function owner() public pure returns (address) {\n        return ImmutableArgs.addr();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           MAIN ENTRY POINTS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Warns the borrower that they're about to be liquidated. NOTE: Liquidators are only\n     * forced to call this in cases where the 5% swap bonus is up for grabs.\n     * @param oracleSeed The indices of `UNISWAP_POOL.observations` where we start our search for\n     * the 30-minute-old (lowest 16 bits) and 60-minute-old (next 16 bits) observations when getting\n     * TWAPs. If any of the highest 8 bits are set, we fallback to onchain binary search.\n     */\n    function warn(uint40 oracleSeed) external {\n        uint256 slot0_ = slot0;\n        // Essentially `slot0.state == State.Ready && slot0.unleashLiquidationTime == 0`\n        require(slot0_ & (SLOT0_MASK_STATE | SLOT0_MASK_UNLEASH) == 0);\n\n        {\n            // Fetch prices from oracle\n            (Prices memory prices, ) = getPrices(oracleSeed);\n            // Tally assets without actually withdrawing Uniswap positions\n            Assets memory assets = _getAssets(slot0_, prices, false);\n            // Fetch liabilities from lenders\n            (uint256 liabilities0, uint256 liabilities1) = _getLiabilities();\n            // Ensure only unhealthy accounts get warned\n            require(!BalanceSheet.isHealthy(prices, assets, liabilities0, liabilities1), \"Aloe: healthy\");\n        }\n\n        slot0 = slot0_ | ((block.timestamp + LIQUIDATION_GRACE_PERIOD) << 208);\n        emit Warn();\n    }\n\n    /**\n     * @notice Liquidates the borrower, using all available assets to pay down liabilities. If\n     * some or all of the payment cannot be made in-kind, `callee` is expected to swap one asset\n     * for the other at a venue of their choosing. NOTE: Branches involving callbacks will fail\n     * until the borrower has been `warn`ed and the grace period has expired.\n     * @dev As a baseline, `callee` receives `address(this).balance / strain` ETH. This amount is\n     * intended to cover transaction fees. If the liquidation involves a swap callback, `callee`\n     * receives a 5% bonus denominated in the surplus token. In other words, if the two numeric\n     * callback arguments were denominated in the same asset, the first argument would be 5% larger.\n     * @param callee A smart contract capable of swapping `TOKEN0` for `TOKEN1` and vice versa\n     * @param data Encoded parameters that get forwarded to `callee` callbacks\n     * @param strain Almost always set to `1` to pay off all debt and receive maximum reward. If\n     * liquidity is thin and swap price impact would be too large, you can use higher values to\n     * reduce swap size and make it easier for `callee` to do its job. `2` would be half swap size,\n     * `3` one third, and so on.\n     * @param oracleSeed The indices of `UNISWAP_POOL.observations` where we start our search for\n     * the 30-minute-old (lowest 16 bits) and 60-minute-old (next 16 bits) observations when getting\n     * TWAPs. If any of the highest 8 bits are set, we fallback to onchain binary search.\n     */\n    function liquidate(ILiquidator callee, bytes calldata data, uint256 strain, uint40 oracleSeed) external {\n        uint256 slot0_ = slot0;\n        // Essentially `slot0.state == State.Ready`\n        require(slot0_ & SLOT0_MASK_STATE == 0);\n        slot0 = slot0_ | (uint256(State.Locked) << 248);\n\n        uint256 priceX128;\n        uint256 liabilities0;\n        uint256 liabilities1;\n        uint256 incentive1;\n        {\n            // Fetch prices from oracle\n            (Prices memory prices, ) = getPrices(oracleSeed);\n            priceX128 = square(prices.c);\n            // Withdraw Uniswap positions while tallying assets\n            Assets memory assets = _getAssets(slot0_, prices, true);\n            // Fetch liabilities from lenders\n            (liabilities0, liabilities1) = _getLiabilities();\n            // Calculate liquidation incentive\n            incentive1 = BalanceSheet.computeLiquidationIncentive(\n                assets.fixed0 + assets.fluid0C, // total assets0 at `prices.c` (the TWAP)\n                assets.fixed1 + assets.fluid1C, // total assets1 at `prices.c` (the TWAP)\n                liabilities0,\n                liabilities1,\n                priceX128\n            );\n            // Ensure only unhealthy accounts can be liquidated\n            require(!BalanceSheet.isHealthy(prices, assets, liabilities0, liabilities1), \"Aloe: healthy\");\n        }\n\n        // NOTE: The health check values assets at the TWAP and is difficult to manipulate. However,\n        // the instantaneous price does impact what tokens we receive when burning Uniswap positions.\n        // As such, additional calls to `TOKEN0.balanceOf` and `TOKEN1.balanceOf` are required for\n        // precise inventory, and we take care not to increase `incentive1`.\n\n        unchecked {\n            // Figure out what portion of liabilities can be repaid using existing assets\n            uint256 repayable0 = Math.min(liabilities0, TOKEN0.balanceOf(address(this)));\n            uint256 repayable1 = Math.min(liabilities1, TOKEN1.balanceOf(address(this)));\n\n            // See what remains (similar to \"shortfall\" in BalanceSheet)\n            liabilities0 -= repayable0;\n            liabilities1 -= repayable1;\n\n            // Decide whether to swap or not\n            bool shouldSwap;\n            assembly (\"memory-safe\") {\n                // If both are zero or neither is zero, there's nothing more to do\n                shouldSwap := xor(gt(liabilities0, 0), gt(liabilities1, 0))\n                // Divide by `strain` and check again. This second check can generate false positives in cases\n                // where one division (not both) floors to 0, which is why we `and()` with the check above.\n                liabilities0 := div(liabilities0, strain)\n                liabilities1 := div(liabilities1, strain)\n                shouldSwap := and(shouldSwap, xor(gt(liabilities0, 0), gt(liabilities1, 0)))\n                // If not swapping, set `incentive1 = 0`\n                incentive1 := mul(shouldSwap, incentive1)\n            }\n\n            if (shouldSwap) {\n                uint256 unleashTime = (slot0_ & SLOT0_MASK_UNLEASH) >> 208;\n                require(0 < unleashTime && unleashTime < block.timestamp, \"Aloe: grace\");\n\n                incentive1 /= strain;\n                if (liabilities0 > 0) {\n                    // NOTE: This value is not constrained to `TOKEN1.balanceOf(address(this))`, so liquidators\n                    // are responsible for setting `strain` such that the transfer doesn't revert. This shouldn't\n                    // be an issue unless the borrower has already started accruing bad debt.\n                    uint256 available1 = mulDiv128(liabilities0, priceX128) + incentive1;\n\n                    TOKEN1.safeTransfer(address(callee), available1);\n                    callee.swap1For0(data, available1, liabilities0);\n\n                    repayable0 += liabilities0;\n                } else {\n                    // NOTE: This value is not constrained to `TOKEN0.balanceOf(address(this))`, so liquidators\n                    // are responsible for setting `strain` such that the transfer doesn't revert. This shouldn't\n                    // be an issue unless the borrower has already started accruing bad debt.\n                    uint256 available0 = Math.mulDiv(liabilities1 + incentive1, Q128, priceX128);\n\n                    TOKEN0.safeTransfer(address(callee), available0);\n                    callee.swap0For1(data, available0, liabilities1);\n\n                    repayable1 += liabilities1;\n                }\n            }\n\n            _repay(repayable0, repayable1);\n            slot0 = (slot0_ & SLOT0_MASK_POSITIONS) | SLOT0_DIRT;\n\n            payable(callee).transfer(address(this).balance / strain);\n            emit Liquidate(repayable0, repayable1, incentive1, priceX128);\n        }\n    }\n\n    /**\n     * @notice Allows the owner to manage their account by handing control to some `callee`. Inside the\n     * callback `callee` has access to all sub-commands (`uniswapDeposit`, `uniswapWithdraw`, `transfer`,\n     * `borrow`, `repay`, and `withdrawAnte`). Whatever `callee` does, the account MUST be healthy\n     * after the callback.\n     * @param callee The smart contract that will get temporary control of this account\n     * @param data Encoded parameters that get forwarded to `callee`\n     * @param oracleSeed The indices of `UNISWAP_POOL.observations` where we start our search for\n     * the 30-minute-old (lowest 16 bits) and 60-minute-old (next 16 bits) observations when getting\n     * TWAPs. If any of the highest 8 bits are set, we fallback to onchain binary search.\n     */\n    function modify(IManager callee, bytes calldata data, uint40 oracleSeed) external payable {\n        uint256 slot0_ = slot0;\n        // Essentially `slot0.state == State.Ready && msg.sender == owner()`\n        require(slot0_ & SLOT0_MASK_STATE == 0 && msg.sender == owner(), \"Aloe: only owner\");\n\n        slot0 = slot0_ | (uint256(State.InModifyCallback) << 248);\n        {\n            uint208 positions = callee.callback(data, msg.sender, uint208(slot0_));\n            assembly (\"memory-safe\") {\n                // Equivalent to `if (positions > 0) slot0_ = positions`\n                slot0_ := or(positions, mul(slot0_, iszero(positions)))\n            }\n        }\n        slot0 = (slot0_ & SLOT0_MASK_POSITIONS) | SLOT0_DIRT;\n\n        (uint256 liabilities0, uint256 liabilities1) = _getLiabilities();\n        if (liabilities0 > 0 || liabilities1 > 0) {\n            (uint208 ante, uint8 nSigma, uint8 mtd, uint32 pausedUntilTime) = FACTORY.getParameters(UNISWAP_POOL);\n            (Prices memory prices, bool seemsLegit) = _getPrices(oracleSeed, nSigma, mtd);\n\n            require(\n                seemsLegit && (block.timestamp > pausedUntilTime) && (address(this).balance >= ante),\n                \"Aloe: missing ante / sus price\"\n            );\n\n            Assets memory assets = _getAssets(slot0_, prices, false);\n            require(BalanceSheet.isHealthy(prices, assets, liabilities0, liabilities1), \"Aloe: unhealthy\");\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              SUB-COMMANDS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Callback for Uniswap V3 pool; necessary for `uniswapDeposit` to work\n     * @param amount0 The amount of `TOKEN0` owed to the `UNISWAP_POOL`\n     * @param amount1 The amount of `TOKEN1` owed to the `UNISWAP_POOL`\n     */\n    function uniswapV3MintCallback(uint256 amount0, uint256 amount1, bytes calldata) external {\n        require(msg.sender == address(UNISWAP_POOL));\n\n        if (amount0 > 0) TOKEN0.safeTransfer(msg.sender, amount0);\n        if (amount1 > 0) TOKEN1.safeTransfer(msg.sender, amount1);\n    }\n\n    /**\n     * @notice Allows the `owner()` to add liquidity to a Uniswap position (or create a new one). Only works\n     * within the `modify` callback.\n     * @dev The `LiquidityAmounts` library can help convert underlying amounts to units of `liquidity`.\n     * NOTE: Depending on your use-case, it may be more gas-efficient to call `UNISWAP_POOL.mint` in your\n     * own contract, instead of doing `uniswapDeposit` inside of `modify`'s callback. As long as you set\n     * this `Borrower` as the recipient in `UNISWAP_POOL.mint`, the result is the same.\n     * @param lower The tick at the position's lower bound\n     * @param upper The tick at the position's upper bound\n     * @param liquidity The amount of liquidity to add, in Uniswap's internal units\n     * @return amount0 The precise amount of `TOKEN0` that went into the Uniswap position\n     * @return amount1 The precise amount of `TOKEN1` that went into the Uniswap position\n     */\n    function uniswapDeposit(\n        int24 lower,\n        int24 upper,\n        uint128 liquidity\n    ) external onlyInModifyCallback returns (uint256 amount0, uint256 amount1) {\n        (amount0, amount1) = UNISWAP_POOL.mint(address(this), lower, upper, liquidity, \"\");\n    }\n\n    /**\n     * @notice Allows the `owner()` to withdraw liquidity from one of their Uniswap positions. Only works within\n     * the `modify` callback.\n     * @dev The `LiquidityAmounts` library can help convert underlying amounts to units of `liquidity`\n     * @param lower The tick at the position's lower bound\n     * @param upper The tick at the position's upper bound\n     * @param liquidity The amount of liquidity to remove, in Uniswap's internal units. Pass 0 to collect\n     * fees without burning any liquidity.\n     * @param recipient Receives the tokens from Uniswap. Usually the address of this `Borrower` account.\n     * @return burned0 The amount of `TOKEN0` that was removed from the Uniswap position\n     * @return burned1 The amount of `TOKEN1` that was removed from the Uniswap position\n     * @return collected0 Equal to `burned0` plus any earned `TOKEN0` fees that hadn't yet been claimed\n     * @return collected1 Equal to `burned1` plus any earned `TOKEN1` fees that hadn't yet been claimed\n     */\n    function uniswapWithdraw(\n        int24 lower,\n        int24 upper,\n        uint128 liquidity,\n        address recipient\n    ) external onlyInModifyCallback returns (uint256 burned0, uint256 burned1, uint256 collected0, uint256 collected1) {\n        (burned0, burned1, collected0, collected1) = _uniswapWithdraw(lower, upper, liquidity, recipient);\n    }\n\n    /**\n     * @notice The most flexible sub-command. Allows the `owner()` to transfer amounts of `TOKEN0` and `TOKEN1`\n     * to any `recipient` they want. Only works within the `modify` callback.\n     * @param amount0 The amount of `TOKEN0` to transfer\n     * @param amount1 The amount of `TOKEN1` to transfer\n     * @param recipient Receives the transferred tokens\n     */\n    function transfer(uint256 amount0, uint256 amount1, address recipient) external onlyInModifyCallback {\n        if (amount0 > 0) TOKEN0.safeTransfer(recipient, amount0);\n        if (amount1 > 0) TOKEN1.safeTransfer(recipient, amount1);\n    }\n\n    /**\n     * @notice Allows the `owner()` to borrow funds from `LENDER0` and `LENDER1`. Only works within the `modify`\n     * callback.\n     * @dev If `amount0 > 0` and interest hasn't yet accrued in this block for `LENDER0`, it will accrue\n     * prior to processing your new borrow. Same goes for `amount1 > 0` and `LENDER1`.\n     * @param amount0 The amount of `TOKEN0` to borrow\n     * @param amount1 The amount of `TOKEN1` to borrow\n     * @param recipient Receives the borrowed tokens. Usually the address of this `Borrower` account.\n     */\n    function borrow(uint256 amount0, uint256 amount1, address recipient) external onlyInModifyCallback {\n        if (amount0 > 0) LENDER0.borrow(amount0, recipient);\n        if (amount1 > 0) LENDER1.borrow(amount1, recipient);\n    }\n\n    /**\n     * @notice Allows the `owner()` to repay debts to `LENDER0` and `LENDER1`. Only works within the `modify`\n     * callback.\n     * @dev This is technically unnecessary since you could call `Lender.repay` directly, specifying this\n     * contract as the `beneficiary` and using the `transfer` sub-command to make payments. We include it\n     * because it's convenient and gas-efficient for common use-cases.\n     * @param amount0 The amount of `TOKEN0` to repay\n     * @param amount1 The amount of `TOKEN1` to repay\n     */\n    function repay(uint256 amount0, uint256 amount1) external onlyInModifyCallback {\n        _repay(amount0, amount1);\n    }\n\n    /**\n     * @notice Allows the `owner()` to withdraw their ante. Only works within the `modify` callback.\n     * @param recipient Receives the ante (as Ether)\n     */\n    function withdrawAnte(address payable recipient) external onlyInModifyCallback {\n        // WARNING: External call to user-specified address\n        recipient.transfer(address(this).balance);\n    }\n\n    /**\n     * @notice Allows the `owner()` to perform arbitrary transfers. Useful for rescuing misplaced funds. Only\n     * works within the `modify` callback.\n     * @param token The ERC20 token to transfer\n     * @param amount The amount to transfer\n     * @param recipient Receives the transferred tokens\n     */\n    function rescue(ERC20 token, uint256 amount, address recipient) external onlyInModifyCallback {\n        // WARNING: External call to user-specified address\n        token.safeTransfer(recipient, amount);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             BALANCE SHEET\n    //////////////////////////////////////////////////////////////*/\n\n    function getUniswapPositions() external view returns (int24[] memory) {\n        return extract(slot0);\n    }\n\n    /**\n     * @notice Summarizes all oracle data pertinent to account health\n     * @dev If `seemsLegit == false`, you can call `Factory.pause` to temporarily disable borrows\n     * @param oracleSeed The indices of `UNISWAP_POOL.observations` where we start our search for\n     * the 30-minute-old (lowest 16 bits) and 60-minute-old (next 16 bits) observations when getting\n     * TWAPs. If any of the highest 8 bits are set, we fallback to onchain binary search.\n     * @return prices The probe prices currently being used to evaluate account health\n     * @return seemsLegit Whether the Uniswap TWAP seems to have been manipulated or not\n     */\n    function getPrices(uint40 oracleSeed) public view returns (Prices memory prices, bool seemsLegit) {\n        (, uint8 nSigma, uint8 manipulationThresholdDivisor, ) = FACTORY.getParameters(UNISWAP_POOL);\n        (prices, seemsLegit) = _getPrices(oracleSeed, nSigma, manipulationThresholdDivisor);\n    }\n\n    function _getPrices(\n        uint40 oracleSeed,\n        uint8 nSigma,\n        uint8 manipulationThresholdDivisor\n    ) private view returns (Prices memory prices, bool seemsLegit) {\n        uint56 metric;\n        uint256 iv;\n        // compute current price and volatility\n        (metric, prices.c, iv) = ORACLE.consult(UNISWAP_POOL, oracleSeed);\n        // compute prices at which solvency will be checked\n        (prices.a, prices.b, seemsLegit) = BalanceSheet.computeProbePrices(\n            metric,\n            prices.c,\n            iv,\n            nSigma,\n            manipulationThresholdDivi"
    }
  ]
}