{
  "Title": "Calling `init()` will fail because the well that should be whitelisted has no liquidity",
  "Content": "# Calling `init()` will fail because the well that should be whitelisted has no liquidity\n\n### Severity\nHigh Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2024-04-beanstalk-2/blob/27ff8c87c9164c1fbff054be5f22e56f86cdf127/protocol/contracts/libraries/Well/LibWellBdv.sol#L37-L39\">https://github.com/Cyfrin/2024-04-beanstalk-2/blob/27ff8c87c9164c1fbff054be5f22e56f86cdf127/protocol/contracts/libraries/Well/LibWellBdv.sol#L37-L39</a>\n\n\n## Impact\n\nAccording to the team “the initial liquidity for the new Bean-wstEth well will be added to the well once the Eth from the old well is converted to wstEth”. The problem is that it will not be possible to initiate the migration to the new well because the `init()` function will revert if the new well does not have any liquidity in it.  \n\n\n## Proof of Concept\n\nWhen calling `InitMigrateUnripeBeanEthToBeanSteth:init()` to initiate the migration from the Bean-ETH well to the Bean-wstETH well, the new well is whitelisted by calling `LibWhitelist:whitelistToken()`. During this function call the function `LibWellBdv:bdv` is entered:\n\n```\n    function bdv(\n        address well,\n        uint amount\n    ) internal view returns (uint _bdv) {\n        uint beanIndex = LibWell.getBeanIndexFromWell(well);\n\n        // For now, assume Beanstalk should always use the first pump and given that the Well has been whitelisted, it should be assumed\n        // that the first Pump has been verified when the Well was whitelisted.\n        Call[] memory pumps = IWell(well).pumps();\n        uint[] memory reserves = IInstantaneousPump(pumps[0].target).readInstantaneousReserves(well, pumps[0].data);\n        // If the Bean reserve is beneath the minimum balance, the oracle should be considered as off.\n        require(reserves[beanIndex] >= C.WELL_MINIMUM_BEAN_BALANCE, \"Silo: Well Bean balance below min\"); \n        Call memory wellFunction = IWell(well).wellFunction();\n        uint lpTokenSupplyBefore = IWellFunction(wellFunction.target).calcLpTokenSupply(reserves, wellFunction.data);\n        reserves[beanIndex] = reserves[beanIndex].sub(BEAN_UNIT); // remove one Bean\n        uint deltaLPTokenSupply = lpTokenSupplyBefore.sub(\n            IWellFunction(wellFunction.target).calcLpTokenSupply(reserves, wellFunction.data)\n        );\n        _bdv = amount.mul(BEAN_UNIT).div(deltaLPTokenSupply);\n    }\n```\n\nThis function gets the reserves of the new Bean-wstETH well that should be whitelisted and checks if the bean reserves of the well are `>= WELL_MINIMUM_BEAN_BALANCE` which is set to 1000 beans:\n```\nuint[] memory reserves = IInstantaneousPump(pumps[0].target).readInstantaneousReserves(well, pumps[0].data);\n        // If the Bean reserve is beneath the minimum balance, the oracle should be considered as off.\n        require(reserves[beanIndex] >= C.WELL_MINIMUM_BEAN_BALANCE, \"Silo: Well Bean balance\n```\n\n```\nuint256 internal constant WELL_MINIMUM_BEAN_BALANCE = 1000_000_000; // 1,000 Beans\n```\n\nThe issue arises from the fact that at the time the well is whitelisted it does not have any liquidity in it because according to the development team “the initial liquidity will be added to the well once the Eth is converted to wstEth”. This means the function will revert and therefore it will not be possible to initiate the migration. \n\n\n## Recommended Mitigation Steps\n\nDo not whitelist the well when calling `InitMigrateUnripeBeanEthToBeanSteth:init()` but add a second function `InitMigrateUnripeBeanEthToBeanSteth:finish()` where the LP tokens for the new well are added and the new well which now has enough liquidity is whitelisted. \n",
  "Impact": "MEDIUM",
  "Source": "https://www.codehawks.com/contests/clu7665bs0001fmt5yahc8tyh",
  "Code": [
    {
      "filename": "protocol/contracts/libraries/Well/LibWellBdv.sol",
      "content": "/*\n SPDX-License-Identifier: MIT\n*/\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {IInstantaneousPump} from \"contracts/interfaces/basin/pumps/IInstantaneousPump.sol\";\nimport {Call, IWell} from \"contracts/interfaces/basin/IWell.sol\";\nimport {IWellFunction} from \"contracts/interfaces/basin/IWellFunction.sol\";\nimport {LibWell} from \"contracts/libraries/Well/LibWell.sol\";\nimport {C} from \"contracts/C.sol\";\n\n/**\n * @title Well Bdv Library\n * @notice contains a function to calulate the BDV of a given Well LP Token\n **/\nlibrary LibWellBdv {\n    using SafeMath for uint256;\n\n    uint constant private BEAN_UNIT = 1e6;\n\n    /**\n     * @dev Calculates the `_bdv` of a given Well LP Token given a relevant\n     * `well` and `amount` value by computing the delta LP token supply given a small change in the Bean reserve balance.\n     */\n    function bdv(\n        address well,\n        uint amount\n    ) internal view returns (uint _bdv) {\n        uint beanIndex = LibWell.getBeanIndexFromWell(well);\n\n        // For now, assume Beanstalk should always use the first pump and given that the Well has been whitelisted, it should be assumed\n        // that the first Pump has been verified when the Well was whitelisted.\n        Call[] memory pumps = IWell(well).pumps();\n        uint[] memory reserves = IInstantaneousPump(pumps[0].target).readInstantaneousReserves(well, pumps[0].data);\n        // If the Bean reserve is beneath the minimum balance, the oracle should be considered as off.\n        require(reserves[beanIndex] >= C.WELL_MINIMUM_BEAN_BALANCE, \"Silo: Well Bean balance below min\");\n        Call memory wellFunction = IWell(well).wellFunction();\n        uint lpTokenSupplyBefore = IWellFunction(wellFunction.target).calcLpTokenSupply(reserves, wellFunction.data);\n        reserves[beanIndex] = reserves[beanIndex].sub(BEAN_UNIT); // remove one Bean\n        uint deltaLPTokenSupply = lpTokenSupplyBefore.sub(\n            IWellFunction(wellFunction.target).calcLpTokenSupply(reserves, wellFunction.data)\n        );\n        _bdv = amount.mul(BEAN_UNIT).div(deltaLPTokenSupply);\n    }\n}"
    }
  ]
}