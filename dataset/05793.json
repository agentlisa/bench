{
  "Title": "[L-08] Double entries in `strategyTokens`, `portStrategies`, `bridgeAgents` and `bridgeAgentFactories` arrays are not prevented",
  "Content": "\n*There are 4 instances of this issue:*\n\nhttps://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/BranchPort.sol#L362C1-L380C1\n\n### 1. Double entry of a strategy token\n\nLet's look at the execution path of how strategy tokens are managed:\n\n**Root chain to EP:** `manageStrategyToken => callOut => _performCall => send`\n\n**EP to Branch chain:** `receivePayload => lzReceive => lzReceiveNonBlocking => _execute => executeNoSettlement (Executor) => executeNoSettlement (Router) => _manageStrategyToken => either toggleStrategyToken or addStrategyToken`\n\nAs we can see in the chain of calls above, when toggling off a strategy token, we reach the function `toggleStrategyToken()`, which toggles of the token as below:\n\n```solidity\nFile: BranchPort.sol\n380:     function toggleStrategyToken(address _token) external override requiresCoreRouter {\n381:         isStrategyToken[_token] = !isStrategyToken[_token];\n382: \n383:         emit StrategyTokenToggled(_token);\n384:     }\n```\n\nNow, when we try to toggle it back on, according to the chain of calls, we reach the function `addStrategyToken()`, which does the following:\n\n- On Line 372, we push the token to `strategyTokens` again. This is what causes the double entry.\n\n- On Line 373, there is a chance of overwriting the `_minimumReservesRatio` as well.\n\n```solidity\nFile: BranchPort.sol\n367:     function addStrategyToken(address _token, uint256 _minimumReservesRatio) external override requiresCoreRouter {\n368:         if (_minimumReservesRatio >= DIVISIONER || _minimumReservesRatio < MIN_RESERVE_RATIO) {\n369:             revert InvalidMinimumReservesRatio();\n370:         }\n371: \n372:         strategyTokens.push(_token);\n373:         getMinimumTokenReserveRatio[_token] = _minimumReservesRatio;\n374:         isStrategyToken[_token] = true;\n375: \n376:         emit StrategyTokenAdded(_token, _minimumReservesRatio);\n377:     }\n```\n\nhttps://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/BranchPort.sol#L382C1-L401C1\n\n### 2. Double entry of a Port Strategy\n\nLet's look at the execution path of how Port Strategies are managed:\n\n**Root chain to EP:** `managePortStrategy() => callOut => _performCall => send`\n\n**EP to Branch chain:** `receivePayload => lzReceive => lzReceiveNonBlocking => _execute => executeNoSettlement (Executor) => executeNoSettlement (Router) => _managePortStrategy => either addPortStrategy or togglePortStrategy` (excluding `updatePortStrategy` since it's not important here).\n\nAs we can see in the chain of calls above, when toggling off a port strategy, we reach the function `togglePortStrategy()`, which toggles of the strategy as below:\n\n```solidity\nFile: BranchPort.sol\n402:     function togglePortStrategy(address _portStrategy, address _token) external override requiresCoreRouter {\n403:         isPortStrategy[_portStrategy][_token] = !isPortStrategy[_portStrategy][_token];\n404: \n405:         emit PortStrategyToggled(_portStrategy, _token);\n406:     }\n```\n\nNow, when we try to toggle it back on, according to the chain of calls, we reach the function `addPortStrategy()`, which does the following:\n\n- On Line 394, we push the token to `portStrategies` again. This is what causes the double entry.\n\n- On Line 395, there is a chance of overwriting the `_dailyManagementLimit` as well.\n\n```solidity\nFile: BranchPort.sol\n388:     function addPortStrategy(address _portStrategy, address _token, uint256 _dailyManagementLimit)\n389:         external\n390:         override\n391:         requiresCoreRouter\n392:     {\n393:         if (!isStrategyToken[_token]) revert UnrecognizedStrategyToken();\n394:         portStrategies.push(_portStrategy);\n395:         strategyDailyLimitAmount[_portStrategy][_token] = _dailyManagementLimit;\n396:         isPortStrategy[_portStrategy][_token] = true;\n397: \n398:         emit PortStrategyAdded(_portStrategy, _token, _dailyManagementLimit);\n399:     }\n```\n\nhttps://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/BranchPort.sol#L414C1-L424C6\n\n### 3. Double entry of a Core Branch Bridge Agent\n\nLet's look at the execution path of how a Core Branch Router is set:\n\n**Root chain to EP:** `setCoreBranch() => callOut => _performCall => send`\n\n**EP to Branch chain:** `receivePayload => lzReceive => lzReceiveNonBlocking => _execute => executeNoSettlement (Executor) => executeNoSettlement (Router) => setCoreBranchRouter (Port)`\n\nAs we can see in the chain of calls above, when setting a Core Branch Router, we reach the function `setCoreBranchRouter()`, which does the following:\n\n- On Line 425 and 427 respectively, we set the `coreBranchRouterAddress` to the same address again and push the already existing coreBranchBridgeAgent to the `bridgeAgents` array. This is what causes the double entry.\n\n```solidity\nFile: BranchPort.sol\n420:     function setCoreBranchRouter(address _coreBranchRouter, address _coreBranchBridgeAgent)\n421:         external\n422:         override\n423:         requiresCoreRouter\n424:     {   //@audit Low - If caller sets coreBranchRouterAddress to the same address again, this can cause a double entry in the bridgeAgents array. To prevent this ensure that the coreBranchRouterAddress cannot be set to the existing address. Although admin error, this check can help prevent double entries \n425:         coreBranchRouterAddress = _coreBranchRouter;\n426:         isBridgeAgent[_coreBranchBridgeAgent] = true;\n427:         bridgeAgents.push(_coreBranchBridgeAgent);\n428: \n429:         emit CoreBranchSet(_coreBranchRouter, _coreBranchBridgeAgent);\n430:     }\n```\n\n**The mitigation is below for the above error (check added on Line 425 to prevent resetting to the same router address again):**\n\n```solidity\nFile: BranchPort.sol\n420:     function setCoreBranchRouter(address _coreBranchRouter, address _coreBranchBridgeAgent)\n421:         external\n422:         override\n423:         requiresCoreRouter\n424:     {   \n425:         if (coreBranchRouterAddress == _coreBranchRouter) revert SomeError(); \n426:         coreBranchRouterAddress = _coreBranchRouter;\n427:         isBridgeAgent[_coreBranchBridgeAgent] = true;\n428:         bridgeAgents.push(_coreBranchBridgeAgent);\n429: \n430:         emit CoreBranchSet(_coreBranchRouter, _coreBranchBridgeAgent);\n431:     }\n```\n\n### 4. Double entry of a Bridge Agent Factory\n\nLet's look at the execution path of how Bridge Agent Factories are managed:\n\n**Root chain to EP:** `toggleBranchBridgeAgentFactory() => callOut => _performCall => send`\n\n**EP to Branch chain:** `receivePayload => lzReceive => lzReceiveNonBlocking => _execute => executeNoSettlement (Executor) => executeNoSettlement (Router) => _toggleBranchBridgeAgentFactory => either toggleBridgeAgentFactory or addBridgeAgentFactory`\n\nAs we can see in the chain of calls above, when toggling off a branch bridge agent factory, we reach the function `toggleBridgeAgentFactory()`, which toggles of the bridge agent factory as below:\n\n```solidity\nFile: BranchPort.sol\n348:     function toggleBridgeAgentFactory(address _newBridgeAgentFactory) external override requiresCoreRouter {\n349:         isBridgeAgentFactory[_newBridgeAgentFactory] = !isBridgeAgentFactory[_newBridgeAgentFactory];\n350: \n351:         emit BridgeAgentFactoryToggled(_newBridgeAgentFactory);\n352:     }\n```\n\nNow, when we try to toggle it back on, according to the chain of calls, we reach the function `addBridgeAgentFactory()`, which does the following:\n\n- On Line 342, we push the token to `bridgeAgentFactories` array again. This is what causes the double entry.\n\n```solidity\nFile: BranchPort.sol\n338:     function addBridgeAgentFactory(address _newBridgeAgentFactory) external override requiresCoreRouter {\n339:         if (isBridgeAgentFactory[_newBridgeAgentFactory]) revert AlreadyAddedBridgeAgentFactory();\n340: \n341:         isBridgeAgentFactory[_newBridgeAgentFactory] = true;\n342:         bridgeAgentFactories.push(_newBridgeAgentFactory);\n343: \n344:         emit BridgeAgentFactoryAdded(_newBridgeAgentFactory);\n345:     }\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-09-maia",
  "Code": [
    {
      "filename": "src/BranchPort.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IPortStrategy} from \"./interfaces/IPortStrategy.sol\";\nimport {IBranchPort} from \"./interfaces/IBranchPort.sol\";\n\nimport {ERC20hTokenBranch} from \"./token/ERC20hTokenBranch.sol\";\n\n/// @title Branch Port - Omnichain Token Management Contract\n/// @author MaiaDAO\ncontract BranchPort is Ownable, IBranchPort {\n    using SafeTransferLib for address;\n\n    /*///////////////////////////////////////////////////////////////\n                        CORE ROUTER STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Local Core Branch Router Address.\n    address public coreBranchRouterAddress;\n\n    /*///////////////////////////////////////////////////////////////\n                        BRIDGE AGENT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mapping from Underlying Address to isUnderlying (bool).\n    mapping(address bridgeAgent => bool isActiveBridgeAgent) public isBridgeAgent;\n\n    /// @notice Branch Routers deployed in branch chain.\n    address[] public bridgeAgents;\n\n    /*///////////////////////////////////////////////////////////////\n                    BRIDGE AGENT FACTORIES STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mapping from Underlying Address to isUnderlying (bool).\n    mapping(address bridgeAgentFactory => bool isActiveBridgeAgentFactory) public isBridgeAgentFactory;\n\n    /// @notice Branch Routers deployed in branch chain.\n    address[] public bridgeAgentFactories;\n\n    /*///////////////////////////////////////////////////////////////\n                        STRATEGY TOKENS STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mapping returns true if Strategy Token Address is active for usage in Port Strategies.\n    mapping(address token => bool allowsStrategies) public isStrategyToken;\n\n    /// @notice List of Tokens allowed for usage in Port Strategies.\n    address[] public strategyTokens;\n\n    /// @notice Mapping returns a given token's total debt incurred by Port Strategies.\n    mapping(address token => uint256 debt) public getStrategyTokenDebt;\n\n    /// @notice Mapping returns the minimum ratio of a given Strategy Token the Port should hold.\n    mapping(address token => uint256 minimumReserveRatio) public getMinimumTokenReserveRatio;\n\n    /*///////////////////////////////////////////////////////////////\n                        PORT STRATEGIES STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mapping returns true if Port Strategy is allowed to manage a given Strategy Token.\n    mapping(address strategy => mapping(address token => bool isActiveStrategy)) public isPortStrategy;\n\n    /// @notice Port Strategy Addresses deployed in the current branch chain.\n    address[] public portStrategies;\n\n    /// @notice Mapping returns the amount of Strategy Token debt a given Port Strategy has.\n    mapping(address strategy => mapping(address token => uint256 debt)) public getPortStrategyTokenDebt;\n\n    /// @notice Mapping returns the last time a given Port Strategy managed a given Strategy Token.\n    mapping(address strategy => mapping(address token => uint256 lastManaged)) public lastManaged;\n\n    /// @notice Mapping returns the time limit a given Port Strategy must wait before managing a Strategy Token.\n    mapping(address strategy => mapping(address token => uint256 dailyLimitAmount)) public strategyDailyLimitAmount;\n\n    /// @notice Mapping returns the amount of a Strategy Token a given Port Strategy can manage.\n    mapping(address strategy => mapping(address token => uint256 dailyLimitRemaining)) public\n        strategyDailyLimitRemaining;\n\n    /*///////////////////////////////////////////////////////////////\n                            REENTRANCY STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Reentrancy lock guard state.\n    uint256 internal _unlocked = 1;\n\n    /*///////////////////////////////////////////////////////////////\n                            CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant DIVISIONER = 1e4;\n    uint256 internal constant MIN_RESERVE_RATIO = 3e3;\n\n    /*///////////////////////////////////////////////////////////////\n                            CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Constructor for the Branch Port Contract.\n     *   @param _owner Address of the Owner.\n     */\n    constructor(address _owner) {\n        require(_owner != address(0), \"Owner is zero address\");\n        _initializeOwner(_owner);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        INITIALIZATION FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Initializes the Branch Port.\n     *   @param _coreBranchRouter Address of the Core Branch Router.\n     *   @param _bridgeAgentFactory Address of the Bridge Agent Factory.\n     */\n    function initialize(address _coreBranchRouter, address _bridgeAgentFactory) external virtual onlyOwner {\n        require(coreBranchRouterAddress == address(0), \"Contract already initialized\");\n        require(!isBridgeAgentFactory[_bridgeAgentFactory], \"Contract already initialized\");\n\n        require(_coreBranchRouter != address(0), \"CoreBranchRouter is zero address\");\n        require(_bridgeAgentFactory != address(0), \"BridgeAgentFactory is zero address\");\n\n        coreBranchRouterAddress = _coreBranchRouter;\n        isBridgeAgentFactory[_bridgeAgentFactory] = true;\n        bridgeAgentFactories.push(_bridgeAgentFactory);\n    }\n\n    /// @notice Function being overrriden to prevent mistakenly renouncing ownership.\n    function renounceOwnership() public payable override onlyOwner {\n        revert(\"Cannot renounce ownership\");\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        PORT STRATEGY FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchPort\n    function manage(address _token, uint256 _amount) external override requiresPortStrategy(_token) {\n        // Cache Strategy Token Global Debt\n        uint256 _strategyTokenDebt = getStrategyTokenDebt[_token];\n\n        // Check if request would surpass the tokens minimum reserves\n        if (_amount > _excessReserves(_strategyTokenDebt, _token)) revert InsufficientReserves();\n\n        // Check if request would surpass the Port Strategy's daily limit\n        _checkTimeLimit(_token, _amount);\n\n        // Update Strategy Token Global Debt\n        getStrategyTokenDebt[_token] = _strategyTokenDebt + _amount;\n        // Update Port Strategy Token Debt\n        getPortStrategyTokenDebt[msg.sender][_token] += _amount;\n\n        // Transfer tokens to Port Strategy for management\n        _token.safeTransfer(msg.sender, _amount);\n\n        // Emit DebtCreated event\n        emit DebtCreated(msg.sender, _token, _amount);\n    }\n\n    /// @inheritdoc IBranchPort\n    function replenishReserves(address _token, uint256 _amount) external override lock {\n        // Update Port Strategy Token Debt. Will underflow if not enough debt to repay.\n        getPortStrategyTokenDebt[msg.sender][_token] -= _amount;\n\n        // Update Strategy Token Global Debt. Will underflow if not enough debt to repay.\n        getStrategyTokenDebt[_token] -= _amount;\n\n        // Get current balance of _token\n        uint256 currBalance = ERC20(_token).balanceOf(address(this));\n\n        // Withdraw tokens from startegy\n        IPortStrategy(msg.sender).withdraw(address(this), _token, _amount);\n\n        // Check if _token balance has increased by _amount\n        require(ERC20(_token).balanceOf(address(this)) - currBalance == _amount, \"Port Strategy Withdraw Failed\");\n\n        // Emit DebtRepaid event\n        emit DebtRepaid(msg.sender, _token, _amount);\n    }\n\n    /// @inheritdoc IBranchPort\n    function replenishReserves(address _strategy, address _token) external override lock {\n        // Cache Strategy Token Global Debt\n        uint256 strategyTokenDebt = getStrategyTokenDebt[_token];\n\n        // Get current balance of _token\n        uint256 currBalance = ERC20(_token).balanceOf(address(this));\n\n        // Get reserves lacking\n        uint256 reservesLacking = _reservesLacking(strategyTokenDebt, _token, currBalance);\n\n        // Cache Port Strategy Token Debt\n        uint256 portStrategyTokenDebt = getPortStrategyTokenDebt[_strategy][_token];\n\n        // Calculate amount to withdraw. The lesser of reserves lacking or Strategy Token Global Debt.\n        uint256 amountToWithdraw = portStrategyTokenDebt < reservesLacking ? portStrategyTokenDebt : reservesLacking;\n\n        // Update Port Strategy Token Debt\n        getPortStrategyTokenDebt[_strategy][_token] = portStrategyTokenDebt - amountToWithdraw;\n        // Update Strategy Token Global Debt\n        getStrategyTokenDebt[_token] = strategyTokenDebt - amountToWithdraw;\n\n        // Withdraw tokens from startegy\n        IPortStrategy(_strategy).withdraw(address(this), _token, amountToWithdraw);\n\n        // Check if _token balance has increased by _amount\n        require(\n            ERC20(_token).balanceOf(address(this)) - currBalance == amountToWithdraw, \"Port Strategy Withdraw Failed\"\n        );\n\n        // Emit DebtRepaid event\n        emit DebtRepaid(_strategy, _token, amountToWithdraw);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchPort\n    function withdraw(address _recipient, address _underlyingAddress, uint256 _deposit)\n        public\n        virtual\n        override\n        lock\n        requiresBridgeAgent\n    {\n        _underlyingAddress.safeTransfer(_recipient, _deposit);\n    }\n\n    /// @inheritdoc IBranchPort\n    function bridgeIn(address _recipient, address _localAddress, uint256 _amount)\n        external\n        override\n        requiresBridgeAgent\n    {\n        _bridgeIn(_recipient, _localAddress, _amount);\n    }\n\n    /// @inheritdoc IBranchPort\n    function bridgeInMultiple(\n        address _recipient,\n        address[] memory _localAddresses,\n        address[] memory _underlyingAddresses,\n        uint256[] memory _amounts,\n        uint256[] memory _deposits\n    ) external override requiresBridgeAgent {\n        // Cache Length\n        uint256 length = _localAddresses.length;\n\n        // Loop through token inputs\n        for (uint256 i = 0; i < length;) {\n            // Check if hTokens are being bridged in\n            if (_amounts[i] - _deposits[i] > 0) {\n                unchecked {\n                    _bridgeIn(_recipient, _localAddresses[i], _amounts[i] - _deposits[i]);\n                }\n            }\n\n            // Check if underlying tokens are being cleared\n            if (_deposits[i] > 0) {\n                withdraw(_recipient, _underlyingAddresses[i], _deposits[i]);\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @inheritdoc IBranchPort\n    function bridgeOut(\n        address _depositor,\n        address _localAddress,\n        address _underlyingAddress,\n        uint256 _amount,\n        uint256 _deposit\n    ) external override lock requiresBridgeAgent {\n        _bridgeOut(_depositor, _localAddress, _underlyingAddress, _amount, _deposit);\n    }\n\n    /// @inheritdoc IBranchPort\n    function bridgeOutMultiple(\n        address _depositor,\n        address[] memory _localAddresses,\n        address[] memory _underlyingAddresses,\n        uint256[] memory _amounts,\n        uint256[] memory _deposits\n    ) external override lock requiresBridgeAgent {\n        // Cache Length\n        uint256 length = _localAddresses.length;\n\n        // Sanity Check input arrays\n        if (length > 255) revert InvalidInputArrays();\n        if (length != _underlyingAddresses.length) revert InvalidInputArrays();\n        if (_underlyingAddresses.length != _amounts.length) revert InvalidInputArrays();\n        if (_amounts.length != _deposits.length) revert InvalidInputArrays();\n\n        // Loop through token inputs and bridge out\n        for (uint256 i = 0; i < length;) {\n            _bridgeOut(_depositor, _localAddresses[i], _underlyingAddresses[i], _amounts[i], _deposits[i]);\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    BRIDGE AGENT FACTORIES FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchPort\n    function addBridgeAgent(address _bridgeAgent) external override requiresBridgeAgentFactory {\n        if (isBridgeAgent[_bridgeAgent]) revert AlreadyAddedBridgeAgent();\n\n        isBridgeAgent[_bridgeAgent] = true;\n        bridgeAgents.push(_bridgeAgent);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        ADMIN FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchPort\n    function setCoreRouter(address _newCoreRouter) external override requiresCoreRouter {\n        require(coreBranchRouterAddress != address(0), \"CoreRouter address is zero\");\n        require(_newCoreRouter != address(0), \"New CoreRouter address is zero\");\n        coreBranchRouterAddress = _newCoreRouter;\n    }\n\n    /// @inheritdoc IBranchPort\n    function addBridgeAgentFactory(address _newBridgeAgentFactory) external override requiresCoreRouter {\n        if (isBridgeAgentFactory[_newBridgeAgentFactory]) revert AlreadyAddedBridgeAgentFactory();\n\n        isBridgeAgentFactory[_newBridgeAgentFactory] = true;\n        bridgeAgentFactories.push(_newBridgeAgentFactory);\n\n        emit BridgeAgentFactoryAdded(_newBridgeAgentFactory);\n    }\n\n    /// @inheritdoc IBranchPort\n    function toggleBridgeAgentFactory(address _newBridgeAgentFactory) external override requiresCoreRouter {\n        isBridgeAgentFactory[_newBridgeAgentFactory] = !isBridgeAgentFactory[_newBridgeAgentFactory];\n\n        emit BridgeAgentFactoryToggled(_newBridgeAgentFactory);\n    }\n\n    /// @inheritdoc IBranchPort\n    function toggleBridgeAgent(address _bridgeAgent) external override requiresCoreRouter {\n        isBridgeAgent[_bridgeAgent] = !isBridgeAgent[_bridgeAgent];\n\n        emit BridgeAgentToggled(_bridgeAgent);\n    }\n\n    /// @inheritdoc IBranchPort\n    function addStrategyToken(address _token, uint256 _minimumReservesRatio) external override requiresCoreRouter {\n        if (_minimumReservesRatio >= DIVISIONER || _minimumReservesRatio < MIN_RESERVE_RATIO) {\n            revert InvalidMinimumReservesRatio();\n        }\n\n        strategyTokens.push(_token);\n        getMinimumTokenReserveRatio[_token] = _minimumReservesRatio;\n        isStrategyToken[_token] = true;\n\n        emit StrategyTokenAdded(_token, _minimumReservesRatio);\n    }\n\n    /// @inheritdoc IBranchPort\n    function toggleStrategyToken(address _token) external override requiresCoreRouter {\n        isStrategyToken[_token] = !isStrategyToken[_token];\n\n        emit StrategyTokenToggled(_token);\n    }\n\n    /// @inheritdoc IBranchPort\n    function addPortStrategy(address _portStrategy, address _token, uint256 _dailyManagementLimit)\n        external\n        override\n        requiresCoreRouter\n    {\n        if (!isStrategyToken[_token]) revert UnrecognizedStrategyToken();\n        portStrategies.push(_portStrategy);\n        strategyDailyLimitAmount[_portStrategy][_token] = _dailyManagementLimit;\n        isPortStrategy[_portStrategy][_token] = true;\n\n        emit PortStrategyAdded(_portStrategy, _token, _dailyManagementLimit);\n    }\n\n    /// @inheritdoc IBranchPort\n    function togglePortStrategy(address _portStrategy, address _token) external override requiresCoreRouter {\n        isPortStrategy[_portStrategy][_token] = !isPortStrategy[_portStrategy][_token];\n\n        emit PortStrategyToggled(_portStrategy, _token);\n    }\n\n    /// @inheritdoc IBranchPort\n    function updatePortStrategy(address _portStrategy, address _token, uint256 _dailyManagementLimit)\n        external\n        override\n        requiresCoreRouter\n    {\n        strategyDailyLimitAmount[_portStrategy][_token] = _dailyManagementLimit;\n\n        emit PortStrategyUpdated(_portStrategy, _token, _dailyManagementLimit);\n    }\n\n    /// @inheritdoc IBranchPort\n    function setCoreBranchRouter(address _coreBranchRouter, address _coreBranchBridgeAgent)\n        external\n        override\n        requiresCoreRouter\n    {\n        coreBranchRouterAddress = _coreBranchRouter;\n        isBridgeAgent[_coreBranchBridgeAgent] = true;\n        bridgeAgents.push(_coreBranchBridgeAgent);\n\n        emit CoreBranchSet(_coreBranchRouter, _coreBranchBridgeAgent);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    INTERNAL VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns amount of Strategy Tokens\n     *   @param _token Address of a given Strategy Token.\n     *   @return uint256 excess reserves\n     */\n    function _excessReserves(uint256 _strategyTokenDebt, address _token) internal view returns (uint256) {\n        uint256 currBalance = ERC20(_token).balanceOf(address(this));\n        uint256 minReserves = _minimumReserves(_strategyTokenDebt, currBalance, _token);\n\n        unchecked {\n            return currBalance > minReserves ? currBalance - minReserves : 0;\n        }\n    }\n\n    /**\n     * @notice Returns amount of Strategy Tokens needed to reach minimum reserves\n     *   @param _token Address of a given Strategy Token.\n     *   @return uint256 excess reserves\n     */\n    function _reservesLacking(uint256 _strategyTokenDebt, address _token, uint256 currBalance)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 minReserves = _minimumReserves(_strategyTokenDebt, currBalance, _token);\n\n        unchecked {\n            return currBalance < minReserves ? minReserves - currBalance : 0;\n        }\n    }\n\n    /**\n     * @notice Internal function to return the minimum amount of reserves of a given Strategy Token the Port should hold.\n     *   @param _strategyTokenDebt Total token debt incurred by Port Strategies.\n     *   @param _currBalance Current balance of a given Strategy Token.\n     *   @param _token Address of a given Strategy Token.\n     *   @return uint256 minimum reserves\n     */\n    function _minimumReserves(uint256 _strategyTokenDebt, uint256 _currBalance, address _token)\n        internal\n        view\n        returns (uint256)\n    {\n        return ((_currBalance + _strategyTokenDebt) * getMinimumTokenReserveRatio[_token]) / DIVISIONER;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Internal function to check if a Port Strategy has reached its daily management limit.\n     *   @param _token address being managed.\n     *   @param _amount of token being requested.\n     */\n    function _checkTimeLimit(address _token, uint256 _amount) internal {\n        uint256 dailyLimit = strategyDailyLimitRemaining[msg.sender][_token];\n        if (block.timestamp - lastManaged[msg.sender][_token] >= 1 days) {\n            dailyLimit = strategyDailyLimitAmount[msg.sender][_token];\n            unchecked {\n                lastManaged[msg.sender][_token] = (block.timestamp / 1 days) * 1 days;\n            }\n        }\n        strategyDailyLimitRemaining[msg.sender][_token] = dailyLimit - _amount;\n    }\n\n    /**\n     * @notice Internal function to bridge in hTokens.\n     *   @param _recipient address of the recipient.\n     *   @param _localAddress address of the hToken.\n     *   @param _amount amount of hTokens to bridge in.\n     */\n    function _bridgeIn(address _recipient, address _localAddress, uint256 _amount) internal virtual {\n        ERC20hTokenBranch(_localAddress).mint(_recipient, _amount);\n    }\n\n    /**\n     * @notice Internal function to bridge out hTokens and underlying tokens.\n     *   @param _depositor address of the depositor.\n     *   @param _localAddress address of the hToken.\n     *   @param _underlyingAddress address of the underlying token.\n     *   @param _amount total amount of tokens to bridge out.\n     *   @param _deposit amount of underlying tokens to bridge out.\n     */\n    function _bridgeOut(\n        address _depositor,\n        address _localAddress,\n        address _underlyingAddress,\n        uint256 _amount,\n        uint256 _deposit\n    ) internal virtual {\n        // Cache hToken amount out\n        uint256 _hTokenAmount = _amount - _deposit;\n\n        // Check if hTokens are being bridged out\n        if (_hTokenAmount > 0) {\n            _localAddress.safeTransferFrom(_depositor, address(this), _hTokenAmount);\n            ERC20hTokenBranch(_localAddress).burn(_hTokenAmount);\n        }\n\n        // Check if underlying tokens are being bridged out\n        if (_deposit > 0) {\n            _underlyingAddress.safeTransferFrom(_depositor, address(this), _deposit);\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Modifier that verifies msg sender is the Branch Chain's Core Root Router.\n    modifier requiresCoreRouter() {\n        if (msg.sender != coreBranchRouterAddress) revert UnrecognizedCore();\n        _;\n    }\n\n    /// @notice Modifier that verifies msg sender is an active Bridge Agent.\n    modifier requiresBridgeAgent() {\n        if (!isBridgeAgent[msg.sender]) revert UnrecognizedBridgeAgent();\n        _;\n    }\n\n    /// @notice Modifier that verifies msg sender is an active Bridge Agent Factory.\n    modifier requiresBridgeAgentFactory() {\n        if (!isBridgeAgentFactory[msg.sender]) revert UnrecognizedBridgeAgentFactory();\n        _;\n    }\n\n    /// @notice Modifier that require msg sender to be an active Port Strategy\n    modifier requiresPortStrategy(address _token) {\n        if (!isStrategyToken[_token]) revert UnrecognizedStrategyToken();\n        if (!isPortStrategy[msg.sender][_token]) revert UnrecognizedPortStrategy();\n        _;\n    }\n\n    /// @notice Modifier for a simple re-entrancy check.\n    modifier lock() {\n        require(_unlocked == 1);\n        _unlocked = 2;\n        _;\n        _unlocked = 1;\n    }\n}"
    },
    {
      "filename": "src/BranchPort.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IPortStrategy} from \"./interfaces/IPortStrategy.sol\";\nimport {IBranchPort} from \"./interfaces/IBranchPort.sol\";\n\nimport {ERC20hTokenBranch} from \"./token/ERC20hTokenBranch.sol\";\n\n/// @title Branch Port - Omnichain Token Management Contract\n/// @author MaiaDAO\ncontract BranchPort is Ownable, IBranchPort {\n    using SafeTransferLib for address;\n\n    /*///////////////////////////////////////////////////////////////\n                        CORE ROUTER STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Local Core Branch Router Address.\n    address public coreBranchRouterAddress;\n\n    /*///////////////////////////////////////////////////////////////\n                        BRIDGE AGENT STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mapping from Underlying Address to isUnderlying (bool).\n    mapping(address bridgeAgent => bool isActiveBridgeAgent) public isBridgeAgent;\n\n    /// @notice Branch Routers deployed in branch chain.\n    address[] public bridgeAgents;\n\n    /*///////////////////////////////////////////////////////////////\n                    BRIDGE AGENT FACTORIES STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mapping from Underlying Address to isUnderlying (bool).\n    mapping(address bridgeAgentFactory => bool isActiveBridgeAgentFactory) public isBridgeAgentFactory;\n\n    /// @notice Branch Routers deployed in branch chain.\n    address[] public bridgeAgentFactories;\n\n    /*///////////////////////////////////////////////////////////////\n                        STRATEGY TOKENS STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mapping returns true if Strategy Token Address is active for usage in Port Strategies.\n    mapping(address token => bool allowsStrategies) public isStrategyToken;\n\n    /// @notice List of Tokens allowed for usage in Port Strategies.\n    address[] public strategyTokens;\n\n    /// @notice Mapping returns a given token's total debt incurred by Port Strategies.\n    mapping(address token => uint256 debt) public getStrategyTokenDebt;\n\n    /// @notice Mapping returns the minimum ratio of a given Strategy Token the Port should hold.\n    mapping(address token => uint256 minimumReserveRatio) public getMinimumTokenReserveRatio;\n\n    /*///////////////////////////////////////////////////////////////\n                        PORT STRATEGIES STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Mapping returns true if Port Strategy is allowed to manage a given Strategy Token.\n    mapping(address strategy => mapping(address token => bool isActiveStrategy)) public isPortStrategy;\n\n    /// @notice Port Strategy Addresses deployed in the current branch chain.\n    address[] public portStrategies;\n\n    /// @notice Mapping returns the amount of Strategy Token debt a given Port Strategy has.\n    mapping(address strategy => mapping(address token => uint256 debt)) public getPortStrategyTokenDebt;\n\n    /// @notice Mapping returns the last time a given Port Strategy managed a given Strategy Token.\n    mapping(address strategy => mapping(address token => uint256 lastManaged)) public lastManaged;\n\n    /// @notice Mapping returns the time limit a given Port Strategy must wait before managing a Strategy Token.\n    mapping(address strategy => mapping(address token => uint256 dailyLimitAmount)) public strategyDailyLimitAmount;\n\n    /// @notice Mapping returns the amount of a Strategy Token a given Port Strategy can manage.\n    mapping(address strategy => mapping(address token => uint256 dailyLimitRemaining)) public\n        strategyDailyLimitRemaining;\n\n    /*///////////////////////////////////////////////////////////////\n                            REENTRANCY STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Reentrancy lock guard state.\n    uint256 internal _unlocked = 1;\n\n    /*///////////////////////////////////////////////////////////////\n                            CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant DIVISIONER = 1e4;\n    uint256 internal constant MIN_RESERVE_RATIO = 3e3;\n\n    /*///////////////////////////////////////////////////////////////\n                            CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Constructor for the Branch Port Contract.\n     *   @param _owner Address of the Owner.\n     */\n    constructor(address _owner) {\n        require(_owner != address(0), \"Owner is zero address\");\n        _initializeOwner(_owner);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        INITIALIZATION FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Initializes the Branch Port.\n     *   @param _coreBranchRouter Address of the Core Branch Router.\n     *   @param _bridgeAgentFactory Address of the Bridge Agent Factory.\n     */\n    function initialize(address _coreBranchRouter, address _bridgeAgentFactory) external virtual onlyOwner {\n        require(coreBranchRouterAddress == address(0), \"Contract already initialized\");\n        require(!isBridgeAgentFactory[_bridgeAgentFactory], \"Contract already initialized\");\n\n        require(_coreBranchRouter != address(0), \"CoreBranchRouter is zero address\");\n        require(_bridgeAgentFactory != address(0), \"BridgeAgentFactory is zero address\");\n\n        coreBranchRouterAddress = _coreBranchRouter;\n        isBridgeAgentFactory[_bridgeAgentFactory] = true;\n        bridgeAgentFactories.push(_bridgeAgentFactory);\n    }\n\n    /// @notice Function being overrriden to prevent mistakenly renouncing ownership.\n    function renounceOwnership() public payable override onlyOwner {\n        revert(\"Cannot renounce ownership\");\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        PORT STRATEGY FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IBranchPort\n    function manage(address _token, uint256 _amount) external override requiresPortStrategy(_token) {\n        // Cache Strategy Token Global Debt\n        uint256 _strategyTokenDebt = getStrategyTokenDebt[_token];\n\n        // Check if request would surpass the tokens minimum reserves\n        if (_amount > _excessReserves(_strategyTokenDebt, _token)) revert InsufficientReserves();\n\n        // Check if request would surpass the Port Strategy's daily limit\n        _checkTimeLimit(_token, _amount);\n\n        // Update Strategy Token Global Debt\n        getStrategyTokenDebt[_token] = _strategyTokenDebt + _amount;\n        // Update Port Strategy Token Debt\n        getPortStrategyTokenDebt[msg.sender][_token] += _amount;\n\n        // Transfer tokens to Port Strategy for management\n        _token.safeTransfer(msg.sender, _amount);\n\n        // Emit DebtCreated event\n        emit DebtCreated(msg.sender, _token, _amount);\n    }\n\n    /// @inheritdoc IBranchPort\n    function replenishReserves(address _token, uint256 _amount) external override lock {\n        // Update Port Strategy Token Debt. Will underflow if not enough debt to repay.\n        getPortStrategyTokenDebt[msg.sender][_token] -= _amount;\n\n        // Update Strategy Token Global Debt. Will underflow if not enough debt to repay.\n        getStrategyTokenDebt[_token] -= _amount;\n\n        // Get current balance of _token\n        uint256 currBalance = ERC20(_token).balanceOf(address(this));\n\n        // Withdraw tokens from startegy\n        IPortStrategy(msg.sender).withdraw(address(this), _token, _amount);\n\n        // Check if _token balance has increased by _amount\n        require(ERC20(_token).balanceOf(address(this)) - currBalance == _amount, \"Port Strategy Withdraw Failed\");\n\n        // Emit DebtRepaid event\n        emit DebtRepaid(msg.sender, _token, _amount);\n    }\n\n    /// @inheritdoc IBranchPort\n    function replenishReserves(address _strategy, address _token) external override lock {\n        // Cache Strategy Token Global Debt\n        uint256 strategyTokenDebt = getStrategyTokenDebt[_token];\n\n        // Get current balance of _token\n        uint256 currBalance = ERC20(_token).balanceOf(address(this));\n\n        // Get reserves lacking\n        uint256 reservesLacking = _reservesLacking(strategyTokenDebt, _token, currBalance);\n\n        // Cache Port Strategy Token Debt\n        uint256 portStrategyTokenDebt = getPortStrategyTokenDebt[_strategy][_token];\n\n        // Calculate amount to withdraw. The lesser of reserves lacking or Strategy Token Global Debt.\n        uint256 amountToWithdraw = portStrategyTokenDebt < reservesLacking ? portStrategyTokenDebt : reservesLacking;\n\n        // Update Port Strategy Token Debt\n        getPortStrategyTokenDebt[_strategy][_token] = portStrategyTokenDebt - amountToWithdraw;\n        // Update Strategy Token Global Debt\n        getStrategyTokenDebt[_token] = strategyTokenDebt - amountToWithdraw;\n\n        // Withdraw tokens from startegy\n        IPortStrategy(_strategy).withdraw(address(this), _token, amountToWithdraw);\n\n        // Check if _token balance has increased by _amount\n        require(\n            ERC20(_token).balanceOf(address(this)) - currBalance == amountToWithdraw, \"Port Strategy Withdraw Failed\"\n        );\n\n        // Emit DebtRepaid event\n        emit DebtRepaid(_strategy, _token, amountToWithdraw);\n    }\n\n    /*///////////////////////////////////////////////////////////////"
    }
  ]
}