{
  "Title": "[M-03] Alter velo receptions computation",
  "Content": "_Submitted by 0x1f8b, also found by hansfriese_\n\nThe `deployer` can modify the values to obtain different values than expected.\n\n### Proof of Concept\n\nThe flag used in `initializeReceiverWith` to prevent re-initialization is `fantomSender == address(0)`, however the provided address for that value is not checked to be different from `address(0)`, so it could be initialized multiple times to establish that value.\n\nThis could allow minting multiple Velos into [Velo.mintToRedemptionReceiver](https://github.com/code-423n4/2022-05-velodrome/blob/731a7c438c4f93efc8310586d217006930be63fd/contracts/contracts/Velo.sol#L74) and setting the wrong value in `redeemableVELO` and `redeemableUSDC` to affect the calculations of the `previewRedeem` method and later receive larger amounts of tokens in `lzReceive` than expected.\n\nAffected source code:\n\n*   [RedemptionReceiver.sol#L44](https://github.com/code-423n4/2022-05-velodrome/blob/731a7c438c4f93efc8310586d217006930be63fd/contracts/contracts/redeem/RedemptionReceiver.sol#L44)\n\n### Recommended Mitigation Steps\n\n*   Ensure that the provided addresses are not `address(0)`.\n\n**[pooltypes (Velodrome) acknowledged](https://github.com/code-423n4/2022-05-velodrome-findings/issues/36)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-05-velodrome-findings/issues/36#issuecomment-1169338967):**\n > The warden has shown how, through a combination of misconfiguration and admin privilege, more tokens than expected could be transfered.\n> \n> In looking at `Velo` and `Minter` we can see that `RedemtionReceiver` has to be set by `minter` which at deployment time will be the deployer.\n> \n> I don't believe the exploit can be applied after a correct configuration as `Minter` is unable to set a new `RedemptionReceiver` meaning only the original deployer could pull of the exploit only until they set `minter` to `Minter.sol`.\n> \n> Because of the external requirements, Medium Severity is appropriate; however, I believe the likelihood of this attack being pulled off is minimal.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-05-velodrome",
  "Code": [
    {
      "filename": "contracts/contracts/Velo.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\ncontract Velo {\n\n    string public constant name = \"Velodrome\";\n    string public constant symbol = \"VELO\";\n    uint8 public constant decimals = 18;\n    uint public totalSupply = 0;\n\n    mapping(address => uint) public balanceOf;\n    mapping(address => mapping(address => uint)) public allowance;\n\n    address public minter;\n    address public redemptionReceiver;\n\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n\n    constructor() {\n        minter = msg.sender;\n        _mint(msg.sender, 0);\n    }\n\n    // No checks as its meant to be once off to set minting rights to BaseV1 Minter\n    function setMinter(address _minter) external {\n        require(msg.sender == minter);\n        minter = _minter;\n    }\n\n    function setRedemptionReceiver(address _receiver) external {\n        require(msg.sender == minter);\n        redemptionReceiver = _receiver;\n    }\n\n    function approve(address _spender, uint _value) external returns (bool) {\n        allowance[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function _mint(address _to, uint _amount) internal returns (bool) {\n        balanceOf[_to] += _amount;\n        totalSupply += _amount;\n        emit Transfer(address(0x0), _to, _amount);\n        return true;\n    }\n\n    function _transfer(address _from, address _to, uint _value) internal returns (bool) {\n        balanceOf[_from] -= _value;\n        balanceOf[_to] += _value;\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function transfer(address _to, uint _value) external returns (bool) {\n        return _transfer(msg.sender, _to, _value);\n    }\n\n    function transferFrom(address _from, address _to, uint _value) external returns (bool) {\n        uint allowed_from = allowance[_from][msg.sender];\n        if (allowed_from != type(uint).max) {\n            allowance[_from][msg.sender] -= _value;\n        }\n        return _transfer(_from, _to, _value);\n    }\n\n    function mint(address account, uint amount) external returns (bool) {\n        require(msg.sender == minter);\n        _mint(account, amount);\n        return true;\n    }\n\n    function mintToRedemptionReceiver(uint256 amount) external returns (bool) {\n        require(msg.sender == redemptionReceiver);\n        _mint(redemptionReceiver, amount);\n        return true;\n    }\n}"
    },
    {
      "filename": "contracts/contracts/redeem/RedemptionReceiver.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"LayerZero/interfaces/ILayerZeroEndpoint.sol\";\nimport \"LayerZero/interfaces/ILayerZeroReceiver.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IVelo.sol\";\n\n/// @notice Part 2 of 2 in the WeVE (FTM) -> USDC + VELO (OP) redemption process\n/// This contract is responsible for receiving the LZ message and distributing USDC + VELO\ncontract RedemptionReceiver is ILayerZeroReceiver {\n    IERC20 public immutable USDC;\n    IVelo public immutable VELO;\n    uint16 public immutable fantomChainId; // 12 for FTM, 10012 for FTM testnet\n    address public immutable endpoint;\n    address public immutable deployer;\n\n    constructor(\n        address _usdc,\n        address _velo,\n        uint16 _fantomChainId,\n        address _endpoint\n    ) {\n        require(_fantomChainId == 12 || _fantomChainId == 10012, \"CHAIN_ID_NOT_FTM\");\n        USDC = IERC20(_usdc);\n        VELO = IVelo(_velo);\n        fantomChainId = _fantomChainId;\n        endpoint = _endpoint;\n        deployer = msg.sender;\n    }\n\n    address public fantomSender;\n    uint256 public eligibleWEVE;\n    uint256 public redeemableUSDC;\n    uint256 public redeemableVELO;\n\n    function initializeReceiverWith(\n        address _fantomSender,\n        uint256 _eligibleWEVE,\n        uint256 _redeemableUSDC,\n        uint256 _redeemableVELO\n    ) external {\n        require(msg.sender == deployer, \"ONLY_DEPLOYER\");\n        require(fantomSender == address(0), \"ALREADY_INITIALIZED\");\n        require(\n            USDC.transferFrom(msg.sender, address(this), _redeemableUSDC),\n            \"USDC_TRANSFER_FAILED\"\n        );\n        require(\n            VELO.mintToRedemptionReceiver(_redeemableVELO),\n            \"VELO_MINT_FAILED\"\n        );\n        fantomSender = _fantomSender;\n        eligibleWEVE = _eligibleWEVE;\n        redeemableUSDC = _redeemableUSDC;\n        redeemableVELO = _redeemableVELO;\n    }\n\n    uint256 public redeemedWEVE;\n\n    function previewRedeem(uint256 amountWEVE)\n        public\n        view\n        returns (uint256 shareOfUSDC, uint256 shareOfVELO)\n    {\n        // pro rata USDC\n        shareOfUSDC = (amountWEVE * redeemableUSDC) / eligibleWEVE;\n        // pro rata VELO\n        shareOfVELO = (amountWEVE * redeemableVELO) / eligibleWEVE;\n    }\n\n    function lzReceive(\n        uint16 srcChainId,\n        bytes memory srcAddress,\n        uint64,\n        bytes memory payload\n    ) external override {\n        require(fantomSender != address(0), \"NOT_INITIALIZED\");\n        require(\n            msg.sender == endpoint &&\n                srcChainId == fantomChainId &&\n                addressFromPackedBytes(srcAddress) == fantomSender,\n            \"UNAUTHORIZED_CALLER\"\n        );\n\n        (address redemptionAddress, uint256 amountWEVE) = abi.decode(\n            payload,\n            (address, uint256)\n        );\n\n        require(\n            (redeemedWEVE += amountWEVE) <= eligibleWEVE,\n            \"cannot redeem more than eligible\"\n        );\n        (uint256 shareOfUSDC, uint256 shareOfVELO) = previewRedeem(amountWEVE);\n\n        require(\n            USDC.transfer(redemptionAddress, shareOfUSDC),\n            \"USDC_TRANSFER_FAILED\"\n        );\n        require(\n            VELO.transfer(redemptionAddress, shareOfVELO),\n            \"VELO_TRANSFER_FAILED\"\n        );\n    }\n\n    function addressFromPackedBytes(bytes memory toAddressBytes)\n        public\n        pure\n        returns (address toAddress)\n    {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            toAddress := mload(add(toAddressBytes, 20))\n        }\n    }\n}"
    }
  ]
}