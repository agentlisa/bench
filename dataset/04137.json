{
  "Title": "[M02] English auction bidder can win with low bidAmount on network congestion",
  "Content": "English-like auctions differs from fixed-discount ones because the amount that has to be sold  \n\nis auctioned among bidders competing to offer more system coins ([in a first phase](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/CollateralAuctionHouse.sol#L236)) for less and less collateral to buy (during a [second phase](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/CollateralAuctionHouse.sol#L264)).\n\n\nIn this kind of auction, there are two important parameters to take into account:\n\n\n* [bidExpiry](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/CollateralAuctionHouse.sol#L74): the time after which a bid can be settled (by contract set to 3 hours after the bid is placed).\n* [auctionDeadline](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/CollateralAuctionHouse.sol#L76): the amount of time an auction can last.\n\n\nWhenever a [bid expires or the auction deadline has passed](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/CollateralAuctionHouse.sol#L295), anyone can call the [`settleAuction` function](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/CollateralAuctionHouse.sol#L296) and terminate it.\n\n\nMoreover, the very first bid can be any small `bidAmount &gt; 0` and any consecutive [bid must be 1.05x times greater than the previous one](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/CollateralAuctionHouse.sol#L244). The reason why the first bid can be whatever positive amount is because collateral auctions [are started from the `LiquidationEngine`](https://github.com/reflexer-labs/geb/blob/261407b6b332c2063e4256aa5f9b223d52dad7e1/src/LiquidationEngine.sol#L369) with an initial `bidAmount = 0`.\n\n\nDuring network congestion, bidders’ transactions may not be processed, allowing very low priced bids to be filled with no counterparty bidders competing against them. Since we understand that the Reflexer team intends to implement fixed-discount auctions, we list this issue to make the risks of English style auctions clear. Consider implementing fixed-discount auctions to alleviate this problem. Make sure to implement appropriate tests simulating high network congestion. Additionally, to avoid users bidding with tiny amounts consider establishing a non-zero minimum value for the first bid.\n\n\n***Update:** Acknowledged. Reflexer Labs’ statement for the issue:*\n\n\n\n> \n>  We know about the problem and we plan to use fixed discount auctions in RAI’s case.\n> \n> \n> \n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "src/CollateralAuctionHouse.sol",
      "content": "/// EnglishCollateralAuctionHouse.sol\n\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.6.7;\n\nabstract contract SAFEEngineLike {\n    function transferInternalCoins(address,address,uint) virtual external;\n    function transferCollateral(bytes32,address,address,uint) virtual external;\n}\nabstract contract OracleRelayerLike {\n    function redemptionPrice() virtual public returns (uint256);\n}\nabstract contract OracleLike {\n    function getResultWithValidity() virtual public view returns (uint256, bool);\n}\nabstract contract LiquidationEngineLike {\n    function removeCoinsFromAuction(uint) virtual public;\n}\n\n/*\n   This thing lets you (English) auction some collateral for a given amount of system coins\n*/\n\ncontract EnglishCollateralAuctionHouse {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    /**\n     * @notice Add auth to an account\n     * @param account Account to add auth to\n     */\n    function addAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 1;\n        emit AddAuthorization(account);\n    }\n    /**\n     * @notice Remove auth from an account\n     * @param account Account to remove auth from\n     */\n    function removeAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 0;\n        emit RemoveAuthorization(account);\n    }\n    /**\n    * @notice Checks whether msg.sender can call an authed function\n    **/\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"EnglishCollateralAuctionHouse/account-not-authorized\");\n        _;\n    }\n\n    // --- Data ---\n    struct Bid {\n        // Bid size (how many coins are offered per collateral sold)\n        uint256 bidAmount;                                                                                            // [rad]\n        // How much collateral is sold in an auction\n        uint256 amountToSell;                                                                                         // [wad]\n        // Who the high bidder is\n        address highBidder;\n        // When the latest bid expires and the auction can be settled\n        uint48  bidExpiry;                                                                                            // [unix epoch time]\n        // Hard deadline for the auction after which no more bids can be placed\n        uint48  auctionDeadline;                                                                                      // [unix epoch time]\n        // Who (which SAFE) receives leftover collateral that is not sold in the auction; usually the liquidated SAFE\n        address forgoneCollateralReceiver;\n        // Who receives the coins raised from the auction; usually the accounting engine\n        address auctionIncomeRecipient;\n        // Total/max amount of coins to raise\n        uint256 amountToRaise;                                                                                        // [rad]\n    }\n\n    // Bid data for each separate auction\n    mapping (uint => Bid) public bids;\n\n    // SAFE database\n    SAFEEngineLike public safeEngine;\n    // Collateral type name\n    bytes32       public collateralType;\n\n    uint256  constant ONE = 1.00E18;                                                                                  // [wad]\n    // Minimum bid increase compared to the last bid in order to take the new one in consideration\n    uint256  public   bidIncrease = 1.05E18;                                                                          // [wad]\n    // How long the auction lasts after a new bid is submitted\n    uint48   public   bidDuration = 3 hours;                                                                          // [seconds]\n    // Total length of the auction\n    uint48   public   totalAuctionLength = 2 days;                                                                    // [seconds]\n    // Number of auctions started up until now\n    uint256  public   auctionsStarted = 0;\n\n    LiquidationEngineLike public liquidationEngine;\n\n    bytes32 public constant AUCTION_HOUSE_TYPE = bytes32(\"COLLATERAL\");\n    bytes32 public constant AUCTION_TYPE       = bytes32(\"ENGLISH\");\n\n    // --- Events ---\n    event AddAuthorization(address account);\n    event RemoveAuthorization(address account);\n    event StartAuction(\n        uint256 id,\n        uint256 auctionsStarted,\n        uint256 amountToSell,\n        uint256 initialBid,\n        uint256 amountToRaise,\n        address indexed forgoneCollateralReceiver,\n        address indexed auctionIncomeRecipient,\n        uint256 auctionDeadline\n    );\n    event ModifyParameters(bytes32 parameter, uint data);\n    event ModifyParameters(bytes32 parameter, address data);\n    event RestartAuction(uint id, uint256 auctionDeadline);\n    event IncreaseBidSize(uint id, address highBidder, uint amountToBuy, uint rad, uint bidExpiry);\n    event DecreaseSoldAmount(uint id, address highBidder, uint amountToBuy, uint rad, uint bidExpiry);\n    event SettleAuction(uint id);\n    event TerminateAuctionPrematurely(uint id, address sender, uint bidAmount, uint collateralAmount);\n\n    // --- Init ---\n    constructor(address safeEngine_, address liquidationEngine_, bytes32 collateralType_) public {\n        safeEngine = SAFEEngineLike(safeEngine_);\n        liquidationEngine = LiquidationEngineLike(liquidationEngine_);\n        collateralType = collateralType_;\n        authorizedAccounts[msg.sender] = 1;\n        emit AddAuthorization(msg.sender);\n    }\n\n    // --- Math ---\n    function addUint48(uint48 x, uint48 y) internal pure returns (uint48 z) {\n        require((z = x + y) >= x);\n    }\n    function multiply(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n    uint256 constant WAD = 10 ** 18;\n    function wmultiply(uint x, uint y) internal pure returns (uint z) {\n        z = multiply(x, y) / WAD;\n    }\n    uint256 constant RAY = 10 ** 27;\n    function rdivide(uint x, uint y) internal pure returns (uint z) {\n      z = multiply(x, RAY) / y;\n    }\n\n    // --- Admin ---\n    /**\n     * @notice Modify auction parameters\n     * @param parameter The name of the parameter modified\n     * @param data New value for the parameter\n     */\n    function modifyParameters(bytes32 parameter, uint data) external isAuthorized {\n        if (parameter == \"bidIncrease\") bidIncrease = data;\n        else if (parameter == \"bidDuration\") bidDuration = uint48(data);\n        else if (parameter == \"totalAuctionLength\") totalAuctionLength = uint48(data);\n        else revert(\"EnglishCollateralAuctionHouse/modify-unrecognized-param\");\n        emit ModifyParameters(parameter, data);\n    }\n    /**\n     * @notice Modify the address of an integrated contract\n     * @param parameter The name of the contract whose address we modify\n     * @param data New contract address\n     */\n    function modifyParameters(bytes32 parameter, address data) external isAuthorized {\n        if (parameter == \"liquidationEngine\") liquidationEngine = LiquidationEngineLike(data);\n        else revert(\"EnglishCollateralAuctionHouse/modify-unrecognized-param\");\n        emit ModifyParameters(parameter, data);\n    }\n\n    // --- Auction ---\n    /**\n     * @notice Start a new collateral auction\n     * @param forgoneCollateralReceiver Who receives leftover collateral that is not auctioned\n     * @param auctionIncomeRecipient Who receives the amount raised in the auction\n     * @param amountToRaise Total amount of coins to raise (rad)\n     * @param amountToSell Total amount of collateral available to sell (wad)\n     * @param initialBid Initial bid size (usually zero in this implementation) (rad)\n     */\n    function startAuction(\n        address forgoneCollateralReceiver,\n        address auctionIncomeRecipient,\n        uint amountToRaise,\n        uint amountToSell,\n        uint initialBid\n    ) public isAuthorized returns (uint id)\n    {\n        require(auctionsStarted < uint(-1), \"EnglishCollateralAuctionHouse/overflow\");\n        require(amountToSell > 0, \"EnglishCollateralAuctionHouse/null-amount-sold\");\n        id = ++auctionsStarted;\n\n        bids[id].bidAmount = initialBid;\n        bids[id].amountToSell = amountToSell;\n        bids[id].highBidder = msg.sender;\n        bids[id].auctionDeadline = addUint48(uint48(now), totalAuctionLength);\n        bids[id].forgoneCollateralReceiver = forgoneCollateralReceiver;\n        bids[id].auctionIncomeRecipient = auctionIncomeRecipient;\n        bids[id].amountToRaise = amountToRaise;\n\n        safeEngine.transferCollateral(collateralType, msg.sender, address(this), amountToSell);\n\n        emit StartAuction(\n          id,\n          auctionsStarted,\n          amountToSell,\n          initialBid,\n          amountToRaise,\n          forgoneCollateralReceiver,\n          auctionIncomeRecipient,\n          bids[id].auctionDeadline\n        );\n    }\n    /**\n     * @notice Restart an auction if no bids were submitted for it\n     * @param id ID of the auction to restart\n     */\n    function restartAuction(uint id) external {\n        require(bids[id].auctionDeadline < now, \"EnglishCollateralAuctionHouse/not-finished\");\n        require(bids[id].bidExpiry == 0, \"EnglishCollateralAuctionHouse/bid-already-placed\");\n        bids[id].auctionDeadline = addUint48(uint48(now), totalAuctionLength);\n        emit RestartAuction(id, bids[id].auctionDeadline);\n    }\n    /**\n     * @notice First auction phase: submit a higher bid for the same amount of collateral\n     * @param id ID of the auction you want to submit the bid for\n     * @param amountToBuy Amount of collateral to buy (wad)\n     * @param rad New bid submitted (rad)\n     */\n    function increaseBidSize(uint id, uint amountToBuy, uint rad) external {\n        require(bids[id].highBidder != address(0), \"EnglishCollateralAuctionHouse/high-bidder-not-set\");\n        require(bids[id].bidExpiry > now || bids[id].bidExpiry == 0, \"EnglishCollateralAuctionHouse/bid-already-expired\");\n        require(bids[id].auctionDeadline > now, \"EnglishCollateralAuctionHouse/auction-already-expired\");\n\n        require(amountToBuy == bids[id].amountToSell, \"EnglishCollateralAuctionHouse/amounts-not-matching\");\n        require(rad <= bids[id].amountToRaise, \"EnglishCollateralAuctionHouse/higher-than-amount-to-raise\");\n        require(rad >  bids[id].bidAmount, \"EnglishCollateralAuctionHouse/new-bid-not-higher\");\n        require(multiply(rad, ONE) >= multiply(bidIncrease, bids[id].bidAmount) || rad == bids[id].amountToRaise, \"EnglishCollateralAuctionHouse/insufficient-increase\");\n\n        if (msg.sender != bids[id].highBidder) {\n            safeEngine.transferInternalCoins(msg.sender, bids[id].highBidder, bids[id].bidAmount);\n            bids[id].highBidder = msg.sender;\n        }\n        safeEngine.transferInternalCoins(msg.sender, bids[id].auctionIncomeRecipient, rad - bids[id].bidAmount);\n\n        bids[id].bidAmount = rad;\n        bids[id].bidExpiry = addUint48(uint48(now), bidDuration);\n\n        emit IncreaseBidSize(id, msg.sender, amountToBuy, rad, bids[id].bidExpiry);\n    }\n    /**\n     * @notice Second auction phase: decrease the collateral amount you're willing to receive in\n     *         exchange for providing the same amount of coins as the winning bid\n     * @param id ID of the auction for which you want to submit a new amount of collateral to buy\n     * @param amountToBuy Amount of collateral to buy (must be smaller than the previous proposed amount) (wad)\n     * @param rad New bid submitted; must be equal to the winning bid from the increaseBidSize phase (rad)\n     */\n    function decreaseSoldAmount(uint id, uint amountToBuy, uint rad) external {\n        require(bids[id].highBidder != address(0), \"EnglishCollateralAuctionHouse/high-bidder-not-set\");\n        require(bids[id].bidExpiry > now || bids[id].bidExpiry == 0, \"EnglishCollateralAuctionHouse/bid-already-expired\");\n        require(bids[id].auctionDeadline > now, \"EnglishCollateralAuctionHouse/auction-already-expired\");\n\n        require(rad == bids[id].bidAmount, \"EnglishCollateralAuctionHouse/not-matching-bid\");\n        require(rad == bids[id].amountToRaise, \"EnglishCollateralAuctionHouse/bid-increase-not-finished\");\n        require(amountToBuy < bids[id].amountToSell, \"EnglishCollateralAuctionHouse/amount-bought-not-lower\");\n        require(multiply(bidIncrease, amountToBuy) <= multiply(bids[id].amountToSell, ONE), \"EnglishCollateralAuctionHouse/insufficient-decrease\");\n\n        if (msg.sender != bids[id].highBidder) {\n            safeEngine.transferInternalCoins(msg.sender, bids[id].highBidder, rad);\n            bids[id].highBidder = msg.sender;\n        }\n        safeEngine.transferCollateral(\n          collateralType,\n          address(this),\n          bids[id].forgoneCollateralReceiver,\n          bids[id].amountToSell - amountToBuy\n        );\n\n        bids[id].amountToSell = amountToBuy;\n        bids[id].bidExpiry    = addUint48(uint48(now), bidDuration);\n\n        emit DecreaseSoldAmount(id, msg.sender, amountToBuy, rad, bids[id].bidExpiry);\n    }\n    /**\n     * @notice Settle/finish an auction\n     * @param id ID of the auction to settle\n     */\n    function settleAuction(uint id) external {\n        require(bids[id].bidExpiry != 0 && (bids[id].bidExpiry < now || bids[id].auctionDeadline < now), \"EnglishCollateralAuctionHouse/not-finished\");\n        safeEngine.transferCollateral(collateralType, address(this), bids[id].highBidder, bids[id].amountToSell);\n        liquidationEngine.removeCoinsFromAuction(bids[id].amountToRaise);\n        delete bids[id];\n        emit SettleAuction(id);\n    }\n    /**\n     * @notice Terminate an auction prematurely (if it's still in the first phase).\n     *         Usually called by Global Settlement.\n     * @param id ID of the auction to settle\n     */\n    function terminateAuctionPrematurely(uint id) external isAuthorized {\n        require(bids[id].highBidder != address(0), \"EnglishCollateralAuctionHouse/high-bidder-not-set\");\n        require(bids[id].bidAmount < bids[id].amountToRaise, \"EnglishCollateralAuctionHouse/already-decreasing-sold-amount\");\n        liquidationEngine.removeCoinsFromAuction(bids[id].amountToRaise);\n        safeEngine.transferCollateral(collateralType, address(this), msg.sender, bids[id].amountToSell);\n        safeEngine.transferInternalCoins(msg.sender, bids[id].highBidder, bids[id].bidAmount);\n        emit TerminateAuctionPrematurely(id, msg.sender, bids[id].bidAmount, bids[id].amountToSell);\n        delete bids[id];\n    }\n\n    // --- Getters ---\n    function bidAmount(uint id) public view returns (uint256) {\n        return bids[id].bidAmount;\n    }\n    function remainingAmountToSell(uint id) public view returns (uint256) {\n        return bids[id].amountToSell;\n    }\n    function forgoneCollateralReceiver(uint id) public view returns (address) {\n        return bids[id].forgoneCollateralReceiver;\n    }\n    function amountToRaise(uint id) public view returns (uint256) {\n        return bids[id].amountToRaise;\n    }\n}\n\n/// FixedDiscountCollateralAuctionHouse.sol\n\n// Copyright (C) 2020 Reflexer Labs, INC\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n/*\n   This thing lets you sell some collateral at a fixed discount in order to instantly recapitalize the system\n*/\n\ncontract FixedDiscountCollateralAuctionHouse {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    /**\n     * @notice Add auth to an account\n     * @param account Account to add auth to\n     */\n    function addAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 1;\n        emit AddAuthorization(account);\n    }\n    /**\n     * @notice Remove auth from an account\n     * @param account Account to remove auth from\n     */\n    function removeAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 0;\n        emit RemoveAuthorization(account);\n    }\n    /**\n    * @notice Checks whether msg.sender can call an authed function\n    **/\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"FixedDiscountCollateralAuctionHouse/account-not-authorized\");\n        _;\n    }\n\n    // --- Data ---\n    struct Bid {\n        // System coins raised up until now\n        uint256 raisedAmount;                                                                                         // [rad]\n        // Amount of collateral that has been sold up until now\n        uint256 soldAmount;                                                                                           // [wad]\n        // How much collateral is sold in an auction\n        uint256 amountToSell;                                                                                         // [wad]\n        // Total/max amount of coins to raise\n        uint256 amountToRaise;                                                                                        // [rad]\n        // Duration of time after which the auction can be settled\n        uint48  auctionDeadline;                                                                                      // [unix epoch time]\n        // Who (which SAFE) receives leftover collateral that is not sold in the auction; usually the liquidated SAFE\n        address forgoneCollateralReceiver;\n        // Who receives the coins raised from the auction; usually the accounting engine\n        address auctionIncomeRecipient;\n    }\n\n    // Bid data for each separate auction\n    mapping (uint => Bid) public bids;\n\n    // SAFE database\n    SAFEEngineLike public safeEngine;\n    // Collateral type name\n    bytes32       public collateralType;\n\n    // Minimum acceptable bid\n    uint256  public   minimumBid = 5 * WAD;                                                                           // [wad]\n    // Total length of the auction. Kept to adhere to the same interface as the English auction but redundant and will probably be removed\n    uint48   public   totalAuctionLength = 10 * 365 * 24 * 3600;                                                      // [seconds]\n    // Number of auctions started up until now\n    uint256  public   auctionsStarted = 0;\n    // The last read redemption price\n    uint256  public   lastReadRedemptionPrice;\n    // Discount (compared to the system coin's current redemption price) at which collateral is being sold\n    uint256  public   discount = 0.95E18;                         // 5% discount                                      // [wad]\n    // Max lower bound deviation that the collateral median can have compared to the FSM price\n    uint256  public   lowerCollateralMedianDeviation = 0.90E18;   // 10% deviation                                    // [wad]\n    // Max upper bound deviation that the collateral median can have compared to the FSM price\n    uint256  public   upperCollateralMedianDeviation = 0.95E18;   // 5% deviation                                     // [wad]\n    // Max lower bound deviation that the system coin oracle price feed can have compared to the systemCoinOracle price\n    uint256  public   lowerSystemCoinMedianDeviation = WAD;       // 0% deviation                                     // [wad]\n    // Max upper bound deviation that the collateral median can have compared to the systemCoinOracle price\n    uint256  public   upperSystemCoinMedianDeviation = WAD;       // 0% deviation                                     // [wad]\n    // Min deviation for the system coin median result compared to the redemption price in order to take the median into account\n    uint256  public   minSystemCoinMedianDeviation   = 0.999E18;                                                      // [wad]\n\n    OracleRelayerLike     public oracleRelayer;\n    OracleLike            public collateralFSM;\n    OracleLike            public collateralMedian;\n    OracleLike            public systemCoinOracle;\n    LiquidationEngineLike public liquidationEngine;\n\n    bytes32 public constant AUCTION_HOUSE_TYPE = bytes32(\"COLLATERAL\");\n    bytes32 public constant AUCTION_TYPE       = bytes32(\"FIXED_DISCOUNT\");\n\n    // --- Events ---\n    event AddAuthorization(address account);\n    event RemoveAuthorization(address account);\n    event StartAuction(\n        uint256 id,\n        uint256 auctionsStarted,\n        uint256 amountToSell,\n        uint256 initialBid,\n        uint256 amountToRaise,\n        address indexed forgoneCollateralReceiver,\n        address indexed auctionIncomeRecipient,\n        uint256 auctionDeadline\n    );\n    event ModifyParameters(bytes32 parameter, uint data);\n    event ModifyParameters(bytes32 parameter, address data);\n    event BuyCollateral(uint id, uint wad, uint boughtCollateral);\n    event SettleAuction(uint id, uint leftoverCollateral);\n    event TerminateAuctionPrematurely(uint id, address sender, uint collateralAmount);\n\n    // --- Init ---\n    constructor(address safeEngine_, address liquidationEngine_, bytes32 collateralType_) public {\n        safeEngine = SAFEEngineLike(safeEngine_);\n        liquidationEngine = LiquidationEngineLike(liquidationEngine_);\n        collateralType = collateralType_;\n        authorizedAccounts[msg.sender] = 1;\n        emit AddAuthorization(msg.sender);\n    }\n\n    // --- Math ---\n    uint256 constant RAD = 10 ** 45;\n    function addUint48(uint48 x, uint48 y) internal pure returns (uint48 z) {\n        require((z = x + y) >= x);\n    }\n    function addUint256(uint256 x, uint256 y) internal pure returns (uint z) {\n        require((z = x + y) >= x);\n    }\n    function subtract(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x);\n    }\n    function multiply(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n    uint256 constant WAD = 10 ** 18;\n    function wmultiply(uint x, uint y) internal pure returns (uint z) {\n        z = multiply(x, y) / WAD;\n    }\n    uint256 constant RAY = 10 ** 27;\n    function rdivide(uint x, uint y) internal pure returns (uint z) {\n        z = multiply(x, RAY) / y;\n    }\n    function wdivide(uint x, uint y) internal pure returns (uint z) {\n        z = multiply(x, WAD) / y;\n    }\n    function minimum(uint x, uint y) internal pure returns (uint z) {\n        z = (x <= y) ? x : y;\n    }\n    function maximum(uint x, uint y) internal pure returns (uint z) {\n        z = (x >= y) ? x : y;\n    }\n\n    // --- General Utils ---\n    function either(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := or(x, y)}\n    }\n    function both(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := and(x, y)}\n    }\n\n    // --- Admin ---\n    /**\n     * @notice Modify auction parameters\n     * @param parameter The name of the parameter modified\n     * @param data New value for the parameter\n     */\n    function modifyParameters(bytes32 parameter, uint data) external isAuthorized {\n        if (parameter == \"discount\") {\n            require(data < WAD, \"FixedDiscountCollateralAuctionHouse/no-discount-offered\");\n            discount = data;\n        }\n        else if (parameter == \"lowerCollateralMedianDeviation\") {\n            require(data <= WAD, \"FixedDiscountCollateralAuctionHouse/invalid-lower-collateral-median-deviation\");\n            lowerCollateralMedianDeviation = data;\n        }\n        else if (parameter == \"upperCollateralMedianDeviation\") {\n            require(data <= WAD, \"FixedDiscountCollateralAuctionHouse/invalid-upper-collateral-median-deviation\");\n            upperCollateralMedianDeviation = data;\n        }\n        else if (parameter == \"lowerSystemCoinMedianDeviation\") {\n            require(data <= WAD, \"FixedDiscountCollateralAuctionHouse/invalid-lower-system-coin-median-deviation\");\n            lowerSystemCoinMedianDeviation = data;\n        }\n        else if (parameter == \"upperSystemCoinMedianDeviation\") {\n            require(data <= WAD, \"FixedDiscountCollateralAuctionHouse/invalid-upper-system-coin-median-deviation\");\n            upperSystemCoinMedianDeviation = data;\n        }\n        else if (parameter == \"minSystemCoinMedianDeviation\") {\n            minSystemCoinMedianDeviation = data;\n        }\n        else if (parameter == \"minimumBid\") {\n            minimumBid = data;\n        }\n        else if (parameter == \"totalAuctionLength\") {\n            totalAuctionLength = uint48(data);\n        }\n        else revert(\"FixedDiscountCollateralAuctionHouse/modify-unrecognized-param\");\n        emit ModifyParameters(parameter, data);\n    }\n    /**\n     * @notice Modify oracle related integrations\n     * @param parameter The name of the contract address being updated\n     * @param data New address for the oracle contract\n     */\n    function modifyParameters(bytes32 parameter, address data) external isAuthorized {\n        if (parameter == \"oracleRelayer\") oracleRelayer = OracleRelayerLike(data);\n        else if (parameter == \"collateralFSM\") collateralFSM = OracleLike(data);\n        else if (parameter == \"collateralMedian\") collateralMedian = OracleLike(data);\n        else if (parameter == \"systemCoinOracle\") systemCoinOracle = OracleLike(data);\n        else if (parameter == \"liquidationEngine\") liquidationEngine = LiquidationEngineLike(data);\n        else revert(\"FixedDiscountCollateralAuctionHouse/modify-unrecognized-param\");\n        emit ModifyParameters(parameter, data);\n    }\n\n    // --- Auction Utils ---\n    function getCollateralMedianPrice() public view returns (uint256 priceFeed) {\n        if (address(collateralMedian) == address(0)) return 0;\n\n        // wrapped call toward the collateral median\n        try collateralMedian.getResultWithValidity()\n          returns (uint256 price, bool valid) {\n          if (valid) {\n            priceFeed = uint(price);\n          }\n        } catch (bytes memory revertReason) {}\n    }\n    function getSystemCoinMarketPrice() public view returns (uint256 priceFeed) {\n        if (address(systemCoinOracle) == address(0)) return 0;\n\n        // wrapped call toward the system coin oracle\n        try systemCoinOracle.getResultWithValidity()\n          returns (uint256 price, bool valid) {\n          if (valid) {\n            priceFeed = uint(price) * 10 ** 9; // scale to RAY\n          }\n        } catch (bytes memory revertReason) {}\n    }\n    function getSystemCoinFloorDeviatedPrice(uint256 redemptionPrice) public view returns (uint256 floorPrice) {\n        uint256 minFloorDeviatedPrice = wmultiply(redemptionPrice, minSystemCoinMedianDeviation);\n        floorPrice = wmultiply(redemptionPrice, lowerSystemCoinMedianDeviation);\n        floorPrice = (floorPrice <= minFloorDeviatedPrice) ? floorPrice : redemptionPrice;\n    }\n    function getSystemCoinCeilingDeviatedPrice(uint256 redemptionPrice) public view returns (uint256 ceilingPrice) {\n        uint256 minCeilingDeviatedPrice = wmultiply(redemptionPrice, subtract(2 * WAD, minSystemCoinMedianDeviation));\n        ceilingPrice = wmultiply(redemptionPrice, subtract(2 * WAD, upperSystemCoinMedianDeviation));\n        ceilingPrice = (ceilingPrice >= minCeilingDeviatedPrice) ? ceilingPrice : redemptionPrice;\n    }\n    function getFinalTokenPrices(uint systemCoinRedemptionPrice) public view returns (uint256, uint256) {\n        require(systemCoinRedemptionPrice > 0, \"FixedDiscountCollateralAuctionHouse/invalid-redemption-price-provided\");\n        (uint256 collateralFsmPriceFeedValue, bool collateralFsmHasValidValue) = collateralFSM.getResultWithValidity();\n        if (!collateralFsmHasValidValue) {\n          return (0, 0);\n        }\n\n        uint256 systemCoinAdjustedPrice  = systemCoinRedemptionPrice;\n        uint256 systemCoinPriceFeedValue = getSystemCoinMarketPrice();\n\n        if (systemCoinPriceFeedValue > 0) {\n          uint256 floorPrice   = getSystemCoinFloorDeviatedPrice(systemCoinAdjustedPrice);\n          uint256 ceilingPrice = getSystemCoinCeilingDeviatedPrice(systemCoinAdjustedPrice);\n\n          if (uint(systemCoinPriceFeedValue) < systemCoinAdjustedPrice) {\n            systemCoinAdjustedPrice = maximum(uint(systemCoinPriceFeedValue), floorPrice);\n          } else {\n            systemCoinAdjustedPrice = minimum(uint(systemCoinPriceFeedValue), ceilingPrice);\n          }\n        }\n\n        return (uint(collateralFsmPriceFeedValue), systemCoinAdjustedPrice);\n    }\n    function getFinalBaseCollateralPrice(\n        uint256 collateralFsmPriceFeedValue,\n        uint256 collateralMedianPriceFeedValue\n    ) public view returns (uint256) {\n        uint256 floorPrice   = wmultiply(collateralFsmPriceFeedValue, lowerCollateralMedianDeviation);\n        uint256 ceilingPrice = wmultiply(collateralFsmPriceFeedValue, subtract(2 * WAD, upperCollateralMedianDeviation));\n\n        uint256 adjustedMedianPrice = (collateralMedianPriceFeedValue == 0) ?\n          collateralFsmPriceFeedValue : collateralMedianPriceFeedValue;\n\n        if (adjustedMedianPrice < collateralFsmPriceFeedValue) {\n          return maximum(adjustedMedianPrice, floorPrice);\n        } else {\n          return minimum(adjustedMedianPrice, ceilingPrice);\n        }\n    }\n    function getDiscountedCollateralPrice(\n        uint256 collateralFsmPriceFeedValue,\n        uint256 collateralMedianPriceFeedValue,\n        uint256 systemCoinPriceFeedValue,\n        uint256 customDiscount\n    ) public view returns (uint256) {\n        // calculate the collateral price in relation to the latest system coin price and apply the discount\n        return wmultiply(\n          rdivide(getFinalBaseCollateralPrice(collateralFsmPriceFeedValue, collateralMedianPriceFeedValue), systemCoinPriceFeedValue),\n          customDiscount\n        );\n    }\n    function getBoughtCollateral(\n        uint id,\n        uint256 collateralFsmPriceFeedValue,\n        uint256 collateralMedianPriceFeedValue,\n        uint256 systemCoinPriceFeedValue,\n        uint256 adjustedBid\n    ) private view returns (uint256) {\n        // calculate the collateral price in relation to the latest system coin price and apply the discount\n        uint256 discountedCollateralPrice =\n          getDiscountedCollateralPrice(\n            collateralFsmPriceFeedValue,\n            collateralMedianPriceFeedValue,\n            systemCoinPriceFeedValue,\n            discount\n          );\n        // calculate the amount of collateral bought\n        uint256 boughtCollateral = wdivide(adjustedBid, discountedCollateralPrice);\n        // if the calculated collateral amount exceeds the amount still up for sale, adjust it to the remaining amount\n        boughtCollateral = (boughtCollateral > subtract(bids[id].amountToSell, bids[id].soldAmount)) ?\n                           subtract(bids[id].amountToSell, bids[id].soldAmount) : boughtCollateral;\n\n        return boughtCollateral;\n    }\n\n    // --- Core Auction Logic ---\n    /**\n     * @notice Start a new collateral auction\n     * @param forgoneCollateralReceiver Who receives leftover collateral that is not auctioned\n     * @param auctionIncomeRecipient Who receives the amount raised in the auction\n     * @param amountToRaise Total amount of coins to raise (rad)\n     * @param amountToSell Total amount of collateral available to sell (wad)\n     * @param initialBid Unused\n     */\n    function startAuction(\n        address forgoneCollateralReceiver,\n        address auctionIncomeRecipient,\n        uint256 amountToRaise,\n        uint256 amountToSell,\n        uint256 initialBid\n    ) public isAuthorized returns (uint id) {\n        require(auctionsStarted < uint(-1), \"FixedDiscountCollateralAuctionHouse/o"
    }
  ]
}