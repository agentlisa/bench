{
  "Title": "[M-01] Possible lost msg.value",
  "Content": "_Submitted by rotcivegaf, also found by AuditsAreUS, berndartmueller, cccz, MaratCerby, dipp, and StErMi_\n\n[GeneralVault.sol#L75-L89](https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/GeneralVault.sol#L75-L89)<br>\n[LidoVault.sol#L79-L104](https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/LidoVault.sol#L79-L104)<br>\n[ConvexCurveLPVault.sol#L131-L149](https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/ConvexCurveLPVault.sol#L131-L149)<br>\n\nPossible lost value in `depositCollateral` function call\n\n### Proof of Concept\n\nIn call `depositCollateral` can will send value and the asset can be an ERC20(!= address(0)), if `LidoVault` and `ConvexCurveLPVault` contract receive this call the fouds will lost.<br>\nAlso in **LidoVault, L88**, if send as asset ETH(== address(0)) and send more value than `_amount`(msg.value > \\_amount), the exedent will lost.\n\n### Recommended Mitigation Steps\n\nIn **GeneralVault**, `depositCollateral` function:\n\n*   Check if the `msg.value` is zero when the `_asset` is ERC20(!= address(0))\n*   Check if the `msg.value` is equeal to `_amount` when the `_asset` ETH(== address(0))\n\n```solidity\nfunction depositCollateral(address _asset, uint256 _amount) external payable virtual {\n  if (_asset != address(0)) { // asset = ERC20\n    require(msg.value == 0, <AN ERROR FROM Errors LIBRARY>);\n  } else { // asset = ETH\n    require(msg.value == _amount, <AN ERROR FROM Errors LIBRARY>);\n  }\n\n  // Deposit asset to vault and receive stAsset\n  // Ex: if user deposit 100ETH, this will deposit 100ETH to Lido and receive 100stETH TODO No Lido\n  (address _stAsset, uint256 _stAssetAmount) = _depositToYieldPool(_asset, _amount);\n\n  // Deposit stAsset to lendingPool, then user will get aToken of stAsset\n  ILendingPool(_addressesProvider.getLendingPool()).deposit(\n    _stAsset,\n    _stAssetAmount,\n    msg.sender,\n    0\n  );\n\n  emit DepositCollateral(_asset, msg.sender, _amount);\n}\n```\n\nAlso can remove the `require(msg.value > 0, Errors.VT_COLLATERAL_DEPOSIT_REQUIRE_ETH);` in **LidoVault, L88**\n\n**[sforman2000 (Sturdy) confirmed](https://github.com/code-423n4/2022-05-sturdy-findings/issues/62)**\n\n**[atozICT20 (Sturdy) commented](https://github.com/code-423n4/2022-05-sturdy-findings/issues/62):**\n > [Fix the issue of ETH loss sturdyfi/code4rena-may-2022#3](https://github.com/sturdyfi/code4rena-may-2022/pull/3)\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-05-sturdy-contest",
  "Code": [
    {
      "filename": "smart-contracts/GeneralVault.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {ILendingPool} from '../../interfaces/ILendingPool.sol';\nimport {SafeMath} from '../../dependencies/openzeppelin/contracts/SafeMath.sol';\nimport {PercentageMath} from '../libraries/math/PercentageMath.sol';\nimport {Errors} from '../libraries/helpers/Errors.sol';\nimport {VersionedInitializable} from '../../protocol/libraries/sturdy-upgradeability/VersionedInitializable.sol';\nimport {ILendingPoolAddressesProvider} from '../../interfaces/ILendingPoolAddressesProvider.sol';\nimport {IERC20} from '../../dependencies/openzeppelin/contracts/IERC20.sol';\nimport {IERC20Detailed} from '../../dependencies/openzeppelin/contracts/IERC20Detailed.sol';\n\n/**\n * @title GeneralVault\n * @notice Basic feature of vault\n * @author Sturdy\n **/\n\ncontract GeneralVault is VersionedInitializable {\n  using SafeMath for uint256;\n  using PercentageMath for uint256;\n\n  event ProcessYield(address indexed collateralAsset, uint256 yieldAmount);\n  event DepositCollateral(address indexed collateralAsset, address indexed from, uint256 amount);\n  event WithdrawCollateral(address indexed collateralAsset, address indexed to, uint256 amount);\n  event SetTreasuryInfo(address indexed treasuryAddress, uint256 fee);\n\n  modifier onlyAdmin() {\n    require(_addressesProvider.getPoolAdmin() == msg.sender, Errors.CALLER_NOT_POOL_ADMIN);\n    _;\n  }\n\n  modifier onlyYieldProcessor() {\n    require(\n      _addressesProvider.getAddress('YIELD_PROCESSOR') == msg.sender,\n      Errors.CALLER_NOT_POOL_ADMIN\n    );\n    _;\n  }\n\n  struct AssetYield {\n    address asset;\n    uint256 amount;\n  }\n\n  address constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n  ILendingPoolAddressesProvider internal _addressesProvider;\n\n  // vault fee 20%\n  uint256 internal _vaultFee;\n  address internal _treasuryAddress;\n\n  uint256 public constant VAULT_REVISION = 0x1;\n\n  /**\n   * @dev Function is invoked by the proxy contract when the Vault contract is deployed.\n   * @param _provider The address of the provider\n   **/\n  function initialize(ILendingPoolAddressesProvider _provider) public initializer {\n    _addressesProvider = _provider;\n  }\n\n  function getRevision() internal pure override returns (uint256) {\n    return VAULT_REVISION;\n  }\n\n  /**\n   * @dev Deposits an `amount` of asset as collateral to borrow other asset.\n   * @param _asset The asset address for collateral\n   *  _asset = 0x0000000000000000000000000000000000000000 means to use ETH as collateral\n   * @param _amount The deposit amount\n   */\n  function depositCollateral(address _asset, uint256 _amount) external payable virtual {\n    // Deposit asset to vault and receive stAsset\n    // Ex: if user deposit 100ETH, this will deposit 100ETH to Lido and receive 100stETH TODO No Lido\n    (address _stAsset, uint256 _stAssetAmount) = _depositToYieldPool(_asset, _amount);\n\n    // Deposit stAsset to lendingPool, then user will get aToken of stAsset\n    ILendingPool(_addressesProvider.getLendingPool()).deposit(\n      _stAsset,\n      _stAssetAmount,\n      msg.sender,\n      0\n    );\n\n    emit DepositCollateral(_asset, msg.sender, _amount);\n  }\n\n  /**\n   * @dev Withdraw an `amount` of asset used as collateral to user.\n   * @param _asset The asset address for collateral\n   *  _asset = 0x0000000000000000000000000000000000000000 means to use ETH as collateral\n   * @param _amount The amount to be withdrawn\n   * @param _to Address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   */\n  function withdrawCollateral(\n    address _asset,\n    uint256 _amount,\n    address _to\n  ) external virtual {\n    // Before withdraw from lending pool, get the stAsset address and withdrawal amount\n    // Ex: In Lido vault, it will return stETH address and same amount\n    (address _stAsset, uint256 _stAssetAmount) = _getWithdrawalAmount(_asset, _amount);\n\n    // withdraw from lendingPool, it will convert user's aToken to stAsset\n    uint256 _amountToWithdraw = ILendingPool(_addressesProvider.getLendingPool()).withdrawFrom(\n      _stAsset,\n      _stAssetAmount,\n      msg.sender,\n      address(this)\n    );\n\n    // Withdraw from vault, it will convert stAsset to asset and send to user\n    // Ex: In Lido vault, it will return ETH or stETH to user\n    uint256 withdrawAmount = _withdrawFromYieldPool(_asset, _amountToWithdraw, _to);\n\n    if (_amount == type(uint256).max) {\n      uint256 decimal = IERC20Detailed(_asset).decimals();\n      _amount = _amountToWithdraw.mul(this.pricePerShare()).div(10**decimal);\n    }\n    require(withdrawAmount >= _amount.percentMul(99_00), Errors.VT_WITHDRAW_AMOUNT_MISMATCH);\n\n    emit WithdrawCollateral(_asset, _to, _amount);\n  }\n\n  /**\n   * @dev Withdraw an `amount` of asset used as collateral to user on liquidation.\n   * @param _asset The asset address for collateral\n   *  _asset = 0x0000000000000000000000000000000000000000 means to use ETH as collateral\n   * @param _amount The amount to be withdrawn\n   */\n  function withdrawOnLiquidation(address _asset, uint256 _amount)\n    external\n    virtual\n    returns (uint256)\n  {\n    return _amount;\n  }\n\n  // /**\n  //  * @dev Convert an `amount` of asset used as collateral to swappable asset on liquidation.\n  //  * @param _amountIn The amount of collateral asset\n  //  */\n  // function convertOnLiquidation(address _assetOut, uint256 _amountIn) external virtual {}\n\n  /**\n   * @dev Get yield based on strategy and re-deposit\n   */\n  function processYield() external virtual {}\n\n  /**\n   * @dev Get price per share based on yield strategy\n   */\n  function pricePerShare() external view virtual returns (uint256) {}\n\n  /**\n   * @dev Set treasury address and vault fee\n   * @param _treasury The treasury address\n   * @param _fee The vault fee which has more two decimals, ex: 100% = 100_00\n   */\n  function setTreasuryInfo(address _treasury, uint256 _fee) external onlyAdmin {\n    require(_treasury != address(0), Errors.VT_TREASURY_INVALID);\n    require(_fee <= 30_00, Errors.VT_FEE_TOO_BIG);\n    _treasuryAddress = _treasury;\n    _vaultFee = _fee;\n\n    emit SetTreasuryInfo(_treasury, _fee);\n  }\n\n  /**\n   * @dev Get yield based on strategy and re-deposit\n   */\n  function _getYield(address _stAsset) internal returns (uint256) {\n    uint256 yieldStAsset = _getYieldAmount(_stAsset);\n    require(yieldStAsset > 0, Errors.VT_PROCESS_YIELD_INVALID);\n\n    ILendingPool(_addressesProvider.getLendingPool()).getYield(_stAsset, yieldStAsset);\n    return yieldStAsset;\n  }\n\n  /**\n   * @dev Get yield amount based on strategy\n   */\n  function _getYieldAmount(address _stAsset) internal view returns (uint256) {\n    (uint256 stAssetBalance, uint256 aTokenBalance) = ILendingPool(\n      _addressesProvider.getLendingPool()\n    ).getTotalBalanceOfAssetPair(_stAsset);\n\n    // when deposit for collateral, stAssetBalance = aTokenBalance\n    // But stAssetBalance should increase overtime, so vault can grab yield from lendingPool.\n    // yield = stAssetBalance - aTokenBalance\n    if (stAssetBalance >= aTokenBalance) return stAssetBalance.sub(aTokenBalance);\n\n    return 0;\n  }\n\n  /**\n   * @dev Get the list of asset and asset's yield amount\n   **/\n  function _getAssetYields(uint256 _WETHAmount) internal view returns (AssetYield[] memory) {\n    // Get total borrowing asset volume and volumes and assets\n    (\n      uint256 totalVolume,\n      uint256[] memory volumes,\n      address[] memory assets,\n      uint256 length\n    ) = ILendingPool(_addressesProvider.getLendingPool()).getBorrowingAssetAndVolumes();\n\n    if (totalVolume == 0) return new AssetYield[](0);\n\n    AssetYield[] memory assetYields = new AssetYield[](length);\n    uint256 extraWETHAmount = _WETHAmount;\n\n    for (uint256 i = 0; i < length; i++) {\n      assetYields[i].asset = assets[i];\n      if (i != length - 1) {\n        // Distribute wethAmount based on percent of asset volume\n        assetYields[i].amount = _WETHAmount.percentMul(\n          volumes[i].mul(PercentageMath.PERCENTAGE_FACTOR).div(totalVolume)\n        );\n        extraWETHAmount = extraWETHAmount.sub(assetYields[i].amount);\n      } else {\n        // without calculation, set remained extra amount\n        assetYields[i].amount = extraWETHAmount;\n      }\n    }\n\n    return assetYields;\n  }\n\n  function _depositYield(address _asset, uint256 _amount) internal {\n    ILendingPool(_addressesProvider.getLendingPool()).depositYield(_asset, _amount);\n  }\n\n  /**\n   * @dev Deposit to yield pool based on strategy and receive stAsset\n   */\n  function _depositToYieldPool(address _asset, uint256 _amount)\n    internal\n    virtual\n    returns (address, uint256)\n  {}\n\n  /**\n   * @dev Withdraw from yield pool based on strategy with stAsset and deliver asset\n   */\n  function _withdrawFromYieldPool(\n    address _asset,\n    uint256 _amount,\n    address _to\n  ) internal virtual returns (uint256) {}\n\n  /**\n   * @dev Get Withdrawal amount of stAsset based on strategy\n   */\n  function _getWithdrawalAmount(address _asset, uint256 _amount)\n    internal\n    view\n    virtual\n    returns (address, uint256)\n  {}\n}"
    },
    {
      "filename": "smart-contracts/LidoVault.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {GeneralVault} from '../GeneralVault.sol';\nimport {IERC20} from '../../../dependencies/openzeppelin/contracts/IERC20.sol';\nimport {IWETH} from '../../../misc/interfaces/IWETH.sol';\nimport {Errors} from '../../libraries/helpers/Errors.sol';\nimport {TransferHelper} from '../../libraries/helpers/TransferHelper.sol';\nimport {SafeERC20} from '../../../dependencies/openzeppelin/contracts/SafeERC20.sol';\nimport {CurveswapAdapter} from '../../libraries/swap/CurveswapAdapter.sol';\n\n/**\n * @title LidoVault\n * @notice stETH/ETH Vault by using Lido, Uniswap, Curve\n * @author Sturdy\n **/\ncontract LidoVault is GeneralVault {\n  using SafeERC20 for IERC20;\n\n  /**\n   * @dev Receive Ether\n   */\n  receive() external payable {}\n\n  /**\n   * @dev Grab excess stETH which was from rebasing on Lido\n   *  And convert stETH -> ETH -> asset, deposit to pool\n   */\n  function processYield() external override onlyAdmin {\n    // Get yield from lendingPool\n    address LIDO = _addressesProvider.getAddress('LIDO');\n    uint256 yieldStETH = _getYield(LIDO);\n\n    // move yield to treasury\n    if (_vaultFee > 0) {\n      uint256 treasuryStETH = _processTreasury(yieldStETH);\n      yieldStETH = yieldStETH.sub(treasuryStETH);\n    }\n\n    // Exchange stETH -> ETH via Curve\n    uint256 receivedETHAmount = CurveswapAdapter.swapExactTokensForTokens(\n      _addressesProvider,\n      _addressesProvider.getAddress('STETH_ETH_POOL'),\n      LIDO,\n      ETH,\n      yieldStETH,\n      200\n    );\n\n    // ETH -> WETH\n    address weth = _addressesProvider.getAddress('WETH');\n    IWETH(weth).deposit{value: receivedETHAmount}();\n\n    // transfer WETH to yieldManager\n    address yieldManager = _addressesProvider.getAddress('YIELD_MANAGER');\n    TransferHelper.safeTransfer(weth, yieldManager, receivedETHAmount);\n\n    emit ProcessYield(_addressesProvider.getAddress('WETH'), receivedETHAmount);\n  }\n\n  /**\n   * @dev Get yield amount based on strategy\n   */\n  function getYieldAmount() external view returns (uint256) {\n    return _getYieldAmount(_addressesProvider.getAddress('LIDO'));\n  }\n\n  /**\n   * @dev Get price per share based on yield strategy\n   */\n  function pricePerShare() external view override returns (uint256) {\n    return 1e18;\n  }\n\n  /**\n   * @dev Deposit to yield pool based on strategy and receive stAsset\n   */\n  function _depositToYieldPool(address _asset, uint256 _amount)\n    internal\n    override\n    returns (address, uint256)\n  {\n    address LIDO = _addressesProvider.getAddress('LIDO');\n    uint256 assetAmount = _amount;\n    if (_asset == address(0)) {\n      // Case of ETH deposit from user, user has to send ETH\n      require(msg.value > 0, Errors.VT_COLLATERAL_DEPOSIT_REQUIRE_ETH);\n\n      // Deposit ETH to Lido and receive stETH\n      (bool sent, bytes memory data) = LIDO.call{value: msg.value}('');\n      require(sent, Errors.VT_COLLATERAL_DEPOSIT_INVALID);\n\n      assetAmount = msg.value;\n    } else {\n      // Case of stETH deposit from user, receive stETH from user\n      require(_asset == LIDO, Errors.VT_COLLATERAL_DEPOSIT_INVALID);\n      IERC20(LIDO).safeTransferFrom(msg.sender, address(this), _amount);\n    }\n\n    // Make lendingPool to transfer required amount\n    IERC20(LIDO).safeApprove(address(_addressesProvider.getLendingPool()), assetAmount);\n    return (LIDO, assetAmount);\n  }\n\n  /**\n   * @dev Get Withdrawal amount of stAsset based on strategy\n   */\n  function _getWithdrawalAmount(address _asset, uint256 _amount)\n    internal\n    view\n    override\n    returns (address, uint256)\n  {\n    // In this vault, return same amount of asset.\n    return (_addressesProvider.getAddress('LIDO'), _amount);\n  }\n\n  /**\n   * @dev Withdraw from yield pool based on strategy with stAsset and deliver asset\n   */\n  function _withdrawFromYieldPool(\n    address _asset,\n    uint256 _amount,\n    address _to\n  ) internal override returns (uint256) {\n    address LIDO = _addressesProvider.getAddress('LIDO');\n    if (_asset == address(0)) {\n      // Case of ETH withdraw request from user, so exchange stETH -> ETH via curve\n      uint256 receivedETHAmount = CurveswapAdapter.swapExactTokensForTokens(\n        _addressesProvider,\n        _addressesProvider.getAddress('STETH_ETH_POOL'),\n        LIDO,\n        ETH,\n        _amount,\n        200\n      );\n\n      // send ETH to user\n      (bool sent, bytes memory data) = address(_to).call{value: receivedETHAmount}('');\n      return receivedETHAmount;\n      require(sent, Errors.VT_COLLATERAL_WITHDRAW_INVALID);\n    } else {\n      // Case of stETH withdraw request from user, so directly send\n      require(_asset == LIDO, Errors.VT_COLLATERAL_WITHDRAW_INVALID);\n      IERC20(LIDO).safeTransfer(_to, _amount);\n    }\n    return _amount;\n  }\n\n  /**\n   * @dev Move some yield to treasury\n   */\n  function _processTreasury(uint256 _yieldAmount) internal returns (uint256) {\n    uint256 treasuryAmount = _yieldAmount.percentMul(_vaultFee);\n    IERC20(_addressesProvider.getAddress('LIDO')).safeTransfer(_treasuryAddress, treasuryAmount);\n    return treasuryAmount;\n  }\n}"
    },
    {
      "filename": "smart-contracts/ConvexCurveLPVault.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {GeneralVault} from '../../GeneralVault.sol';\nimport {IERC20} from '../../../../dependencies/openzeppelin/contracts/IERC20.sol';\nimport {SafeERC20} from '../../../../dependencies/openzeppelin/contracts/SafeERC20.sol';\nimport {IERC20Detailed} from '../../../../dependencies/openzeppelin/contracts/IERC20Detailed.sol';\nimport {IConvexBooster} from '../../../../interfaces/IConvexBooster.sol';\nimport {IConvexBaseRewardPool} from '../../../../interfaces/IConvexBaseRewardPool.sol';\nimport {TransferHelper} from '../../../libraries/helpers/TransferHelper.sol';\nimport {Errors} from '../../../libraries/helpers/Errors.sol';\nimport {SturdyInternalAsset} from '../../../tokenization/SturdyInternalAsset.sol';\n\ninterface IRewards {\n  function rewardToken() external view returns (address);\n}\n\n/**\n * @title ConvexCurveLPVault\n * @notice Curve LP Token Vault by using Convex on Ethereum\n * @author Sturdy\n **/\ncontract ConvexCurveLPVault is GeneralVault {\n  using SafeERC20 for IERC20;\n\n  address public convexBooster;\n  address internal curveLPToken;\n  address internal internalAssetToken;\n  uint256 internal convexPoolId;\n\n  /**\n   * @dev The function to set parameters related to convex/curve\n   * @param _lpToken The address of Curve LP Token which will be used in vault\n   * @param _poolId  The convex pool Id for Curve LP Token\n   */\n  function setConfiguration(address _lpToken, uint256 _poolId) external onlyAdmin {\n    require(internalAssetToken == address(0), Errors.VT_INVALID_CONFIGURATION);\n\n    convexBooster = 0xF403C135812408BFbE8713b5A23a04b3D48AAE31;\n    curveLPToken = _lpToken;\n    convexPoolId = _poolId;\n    SturdyInternalAsset _interalToken = new SturdyInternalAsset(\n      string(abi.encodePacked('Sturdy ', IERC20Detailed(_lpToken).symbol())),\n      string(abi.encodePacked('c', IERC20Detailed(_lpToken).symbol())),\n      IERC20Detailed(_lpToken).decimals()\n    );\n    internalAssetToken = address(_interalToken);\n  }\n\n  /**\n   * @dev The function to get internal asset address\n   */\n  function getInternalAsset() external view returns (address) {\n    return internalAssetToken;\n  }\n\n  /**\n   * @dev The function to get rewards token address\n   */\n  function getBaseRewardPool() internal view returns (address) {\n    IConvexBooster.PoolInfo memory poolInfo = IConvexBooster(convexBooster).poolInfo(convexPoolId);\n    return poolInfo.crvRewards;\n  }\n\n  /**\n   * @dev The function to send rewards to YieldManager & Treasury\n   * @param _asset The rewards token address\n   */\n  function _transferYield(address _asset) internal {\n    require(_asset != address(0), Errors.VT_PROCESS_YIELD_INVALID);\n    uint256 yieldAmount = IERC20(_asset).balanceOf(address(this));\n\n    // transfer to treasury\n    if (_vaultFee > 0) {\n      uint256 treasuryAmount = _processTreasury(_asset, yieldAmount);\n      yieldAmount = yieldAmount.sub(treasuryAmount);\n    }\n\n    // transfer to yieldManager\n    address yieldManager = _addressesProvider.getAddress('YIELD_MANAGER');\n    TransferHelper.safeTransfer(_asset, yieldManager, yieldAmount);\n\n    emit ProcessYield(_asset, yieldAmount);\n  }\n\n  function processYield() external override onlyAdmin {\n    // Claim Rewards(CRV, CVX, Extra incentive tokens)\n    address baseRewardPool = getBaseRewardPool();\n    IConvexBaseRewardPool(baseRewardPool).getReward();\n\n    // Transfer CRV to YieldManager\n    address _token = _addressesProvider.getAddress('CRV');\n    address _tokenFromConvex = IConvexBaseRewardPool(baseRewardPool).rewardToken();\n    require(_token == _tokenFromConvex, Errors.VT_INVALID_CONFIGURATION);\n    _transferYield(_token);\n\n    // Transfer CVX to YieldManager\n    _token = _addressesProvider.getAddress('CVX');\n    _tokenFromConvex = IConvexBooster(convexBooster).minter();\n    require(_token == _tokenFromConvex, Errors.VT_INVALID_CONFIGURATION);\n    _transferYield(_token);\n\n    // Transfer extra incentive token to YieldManager\n    uint256 extraRewardsLength = IConvexBaseRewardPool(baseRewardPool).extraRewardsLength();\n    for (uint256 i = 0; i < extraRewardsLength; i++) {\n      address _extraReward = IConvexBaseRewardPool(baseRewardPool).extraRewards(i);\n      address _rewardToken = IRewards(_extraReward).rewardToken();\n      _transferYield(_rewardToken);\n    }\n  }\n\n  /**\n   * @dev Get yield amount based on strategy\n   */\n  function getYieldAmount() external view returns (uint256) {\n    return _getYieldAmount(internalAssetToken);\n  }\n\n  /**\n   * @dev Get price per share based on yield strategy\n   */\n  function pricePerShare() external view override returns (uint256) {\n    uint256 decimals = IERC20Detailed(internalAssetToken).decimals();\n    return 10**decimals;\n  }\n\n  /**\n   * @dev Deposit to yield pool based on strategy and mint internal asset\n   */\n  function _depositToYieldPool(address _asset, uint256 _amount)\n    internal\n    override\n    returns (address, uint256)\n  {\n    // receive Curve LP Token from user\n    require(_asset == curveLPToken, Errors.VT_COLLATERAL_DEPOSIT_INVALID);\n    TransferHelper.safeTransferFrom(curveLPToken, msg.sender, address(this), _amount);\n\n    // deposit Curve LP Token to Convex\n    IERC20(curveLPToken).safeApprove(convexBooster, _amount);\n    IConvexBooster(convexBooster).deposit(convexPoolId, _amount, true);\n\n    // mint\n    SturdyInternalAsset(internalAssetToken).mint(address(this), _amount);\n    IERC20(internalAssetToken).safeApprove(address(_addressesProvider.getLendingPool()), _amount);\n\n    return (internalAssetToken, _amount);\n  }\n\n  /**\n   * @dev Get Withdrawal amount of Curve LP Token based on strategy\n   */\n  function _getWithdrawalAmount(address _asset, uint256 _amount)\n    internal\n    view\n    override\n    returns (address, uint256)\n  {\n    // In this vault, return same amount of asset.\n    return (internalAssetToken, _amount);\n  }\n\n  function _withdraw(uint256 _amount, address _to) internal returns (uint256) {\n    // Withdraw from Convex\n    address baseRewardPool = getBaseRewardPool();\n    IConvexBaseRewardPool(baseRewardPool).withdrawAndUnwrap(_amount, true);\n\n    // Deliver Curve LP Token\n    TransferHelper.safeTransfer(curveLPToken, _to, _amount);\n\n    // Burn\n    SturdyInternalAsset(internalAssetToken).burn(address(this), _amount);\n\n    return _amount;\n  }\n\n  function withdrawOnLiquidation(address _asset, uint256 _amount)\n    external\n    override\n    returns (uint256)\n  {\n    require(_asset == curveLPToken, Errors.LP_LIQUIDATION_CALL_FAILED);\n    require(msg.sender == _addressesProvider.getLendingPool(), Errors.LP_LIQUIDATION_CALL_FAILED);\n\n    return _withdraw(_amount, msg.sender);\n  }\n\n  /**\n   * @dev Withdraw from yield pool based on strategy and deliver asset\n   */\n  function _withdrawFromYieldPool(\n    address _asset,\n    uint256 _amount,\n    address _to\n  ) internal override returns (uint256) {\n    require(_asset == curveLPToken, Errors.VT_COLLATERAL_WITHDRAW_INVALID);\n\n    return _withdraw(_amount, _to);\n  }\n\n  /**\n   * @dev Move some yield(CRV) to treasury\n   */\n  function _processTreasury(address _asset, uint256 _yieldAmount) internal returns (uint256) {\n    uint256 treasuryAmount = _yieldAmount.percentMul(_vaultFee);\n    IERC20(_asset).safeTransfer(_treasuryAddress, treasuryAmount);\n    return treasuryAmount;\n  }\n}"
    }
  ]
}