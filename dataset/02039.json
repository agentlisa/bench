{
  "Title": "Arbitrary calls execution in `Executor` and `GenericCrossChainFacet`",
  "Content": "##### Description\nThe `Executor` contract allows the execution of arbitrary calls in the shared context using the `stargate` functionality or directly by calling the [`swapAndExecute`](https://github.com/Cryptorubic/multi-proxy-rubic/blob/8843336c50ca43e5b5bbe970f17e284f63a96763/src/Periphery/Executor.sol#L114) external function.\n\n`GenericCrossChainFacet` also allows the execution of arbitrary calls in the shared context using the [swapAndStartBridgeTokensViaGenericCrossChain](https://github.com/Cryptorubic/multi-proxy-rubic/blob/ba18b51508c17f8dde2b1557bcbc58d48042ce6c/src/Facets/GenericCrossChainFacet.sol#L90). \n\nIt allows an attacker to setup ERC777 hooks, to provoke blacklisting and do something harmful to the `Executor` and the `Diamond` operationality.\n\nExecuting any external calls in the context of the vulnerable contract (`Executor` or `Diamond`) allows an attacker to intercept a transaction of another user and steal ERC777 tokens:\n1. Give an approve to the attacker contract from vulnerable contract for a ERC777 token. \n2. Set a `transferOnReceive` callback that executes the attacker contract after each transfer to the`Executor` or `Diamond` contract.\n3. Some user executes a swap that utilizes the ERC777 token in the end.\n4. The attacker contract using the approve (at step 1) drains the vulnerable contract inside the ERC777 callback implementation function.\n\n##### Recommendation\nIt is recommended to allow list calls from `Executor` similar to implementation at the facet part of the project. Additionaly, it is recommended to allow list bridges in the `GenericCrossChainFacet`.\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "src/Periphery/Executor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { IERC20 } from \"@axelar-network/axelar-cgp-solidity/contracts/interfaces/IERC20.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\nimport { IRubic } from \"../Interfaces/IRubic.sol\";\nimport { IERC20Proxy } from \"../Interfaces/IERC20Proxy.sol\";\nimport { TransferrableOwnership } from \"../Helpers/TransferrableOwnership.sol\";\n\n/// @title Executor\n/// @notice Arbitrary execution contract used for cross-chain swaps and message passing\ncontract Executor is IRubic, ReentrancyGuard, TransferrableOwnership {\n    /// Storage ///\n\n    /// @notice The address of the ERC20Proxy contract\n    IERC20Proxy public erc20Proxy;\n\n    /// Errors ///\n    error ExecutionFailed();\n    error InvalidCaller();\n\n    /// Events ///\n    event ERC20ProxySet(address indexed proxy);\n\n    /// Modifiers ///\n\n    /// @dev Sends any leftover balances back to the user\n    modifier noLeftovers(\n        LibSwap.SwapData[] calldata _swaps,\n        address payable _leftoverReceiver\n    ) {\n        uint256 numSwaps = _swaps.length;\n        if (numSwaps != 1) {\n            uint256[] memory initialBalances = _fetchBalances(_swaps);\n            address finalAsset = _swaps[numSwaps - 1].receivingAssetId;\n            uint256 curBalance = 0;\n\n            _;\n\n            for (uint256 i = 0; i < numSwaps - 1; ) {\n                address curAsset = _swaps[i].receivingAssetId;\n                // Handle multi-to-one swaps\n                if (curAsset != finalAsset) {\n                    curBalance = LibAsset.getOwnBalance(curAsset);\n                    if (curBalance > initialBalances[i]) {\n                        LibAsset.transferAsset(\n                            curAsset,\n                            _leftoverReceiver,\n                            curBalance - initialBalances[i]\n                        );\n                    }\n                }\n                unchecked {\n                    ++i;\n                }\n            }\n        } else {\n            _;\n        }\n    }\n\n    /// Constructor\n    /// @notice Initialize local variables for the Executor\n    /// @param _owner The address of owner\n    /// @param _erc20Proxy The address of the ERC20Proxy contract\n    constructor(\n        address _owner,\n        address _erc20Proxy\n    ) TransferrableOwnership(_owner) {\n        owner = _owner;\n        erc20Proxy = IERC20Proxy(_erc20Proxy);\n\n        emit ERC20ProxySet(_erc20Proxy);\n    }\n\n    /// External Methods ///\n\n    /// @notice set ERC20 Proxy\n    /// @param _erc20Proxy The address of the ERC20Proxy contract\n    function setERC20Proxy(address _erc20Proxy) external onlyOwner {\n        erc20Proxy = IERC20Proxy(_erc20Proxy);\n        emit ERC20ProxySet(_erc20Proxy);\n    }\n\n    /// @notice Performs a swap before completing a cross-chain transaction\n    /// @param _transactionId the transaction id for the swap\n    /// @param _swapData array of data needed for swaps\n    /// @param _transferredAssetId token received from the other chain\n    /// @param _receiver address that will receive tokens in the end\n    function swapAndCompleteBridgeTokens(\n        bytes32 _transactionId,\n        LibSwap.SwapData[] calldata _swapData,\n        address _transferredAssetId,\n        address payable _receiver\n    ) external payable nonReentrant {\n        _processSwaps(\n            _transactionId,\n            _swapData,\n            _transferredAssetId,\n            _receiver,\n            0,\n            true\n        );\n    }\n\n    /// @notice Performs a series of swaps or arbitrary executions\n    /// @param _transactionId the transaction id for the swap\n    /// @param _swapData array of data needed for swaps\n    /// @param _transferredAssetId token received from the other chain\n    /// @param _receiver address that will receive tokens in the end\n    /// @param _amount amount of token for swaps or arbitrary executions\n    function swapAndExecute(\n        bytes32 _transactionId,\n        LibSwap.SwapData[] calldata _swapData,\n        address _transferredAssetId,\n        address payable _receiver,\n        uint256 _amount\n    ) external payable nonReentrant {\n        _processSwaps(\n            _transactionId,\n            _swapData,\n            _transferredAssetId,\n            _receiver,\n            _amount,\n            false\n        );\n    }\n\n    /// Private Methods ///\n\n    /// @notice Performs a series of swaps or arbitrary executions\n    /// @param _transactionId the transaction id for the swap\n    /// @param _swapData array of data needed for swaps\n    /// @param _transferredAssetId token received from the other chain\n    /// @param _receiver address that will receive tokens in the end\n    /// @param _amount amount of token for swaps or arbitrary executions\n    /// @param _depositAllowance If deposit approved amount of token\n    function _processSwaps(\n        bytes32 _transactionId,\n        LibSwap.SwapData[] calldata _swapData,\n        address _transferredAssetId,\n        address payable _receiver,\n        uint256 _amount,\n        bool _depositAllowance\n    ) private {\n        uint256 startingBalance;\n        uint256 finalAssetStartingBalance;\n        address finalAssetId = _swapData[_swapData.length - 1]\n            .receivingAssetId;\n        if (!LibAsset.isNativeAsset(finalAssetId)) {\n            finalAssetStartingBalance = LibAsset.getOwnBalance(finalAssetId);\n        } else {\n            finalAssetStartingBalance =\n                LibAsset.getOwnBalance(finalAssetId) -\n                msg.value;\n        }\n\n        if (!LibAsset.isNativeAsset(_transferredAssetId)) {\n            startingBalance = LibAsset.getOwnBalance(_transferredAssetId);\n            if (_depositAllowance) {\n                uint256 allowance = IERC20(_transferredAssetId).allowance(\n                    msg.sender,\n                    address(this)\n                );\n                LibAsset.transferFromERC20(\n                    _transferredAssetId,\n                    msg.sender,\n                    address(this),\n                    allowance\n                );\n            } else {\n                erc20Proxy.transferFrom(\n                    _transferredAssetId,\n                    msg.sender,\n                    address(this),\n                    _amount\n                );\n            }\n        } else {\n            startingBalance =\n                LibAsset.getOwnBalance(_transferredAssetId) -\n                msg.value;\n        }\n\n        _executeSwaps(_transactionId, _swapData, _receiver);\n\n        uint256 postSwapBalance = LibAsset.getOwnBalance(_transferredAssetId);\n        if (postSwapBalance > startingBalance) {\n            LibAsset.transferAsset(\n                _transferredAssetId,\n                _receiver,\n                postSwapBalance - startingBalance\n            );\n        }\n\n        uint256 finalAssetPostSwapBalance = LibAsset.getOwnBalance(\n            finalAssetId\n        );\n\n        if (finalAssetPostSwapBalance > finalAssetStartingBalance) {\n            LibAsset.transferAsset(\n                finalAssetId,\n                _receiver,\n                finalAssetPostSwapBalance - finalAssetStartingBalance\n            );\n        }\n\n        emit RubicTransferCompleted(\n            _transactionId,\n            _transferredAssetId,\n            _receiver,\n            finalAssetPostSwapBalance,\n            block.timestamp\n        );\n    }\n\n    /// @dev Executes swaps one after the other\n    /// @param _transactionId the transaction id for the swap\n    /// @param _swapData Array of data used to execute swaps\n    /// @param _leftoverReceiver Address to receive lefover tokens\n    function _executeSwaps(\n        bytes32 _transactionId,\n        LibSwap.SwapData[] calldata _swapData,\n        address payable _leftoverReceiver\n    ) private noLeftovers(_swapData, _leftoverReceiver) {\n        uint256 numSwaps = _swapData.length;\n        for (uint256 i = 0; i < numSwaps; ) {\n            // call to the ERC20Proxy is blocked inside LibSwap.swap\n            LibSwap.SwapData calldata currentSwapData = _swapData[i];\n            LibSwap.swap(_transactionId, currentSwapData);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Fetches balances of tokens to be swapped before swapping.\n    /// @param _swapData Array of data used to execute swaps\n    /// @return uint256[] Array of token balances.\n    function _fetchBalances(\n        LibSwap.SwapData[] calldata _swapData\n    ) private view returns (uint256[] memory) {\n        uint256 numSwaps = _swapData.length;\n        uint256[] memory balances = new uint256[](numSwaps);\n        address asset;\n        for (uint256 i = 0; i < numSwaps; ) {\n            asset = _swapData[i].receivingAssetId;\n            balances[i] = LibAsset.getOwnBalance(asset);\n\n            if (LibAsset.isNativeAsset(asset)) {\n                balances[i] -= msg.value;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return balances;\n    }\n\n    /// @dev required for receiving native assets from destination swaps\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n}"
    },
    {
      "filename": "src/Facets/GenericCrossChainFacet.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { LibMappings } from \"../Libraries/LibMappings.sol\";\nimport { IRubic } from \"../Interfaces/IRubic.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { LibFees } from \"../Libraries/LibFees.sol\";\nimport { LibUtil } from \"../Libraries/LibUtil.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport { ReentrancyGuard } from \"../Helpers/ReentrancyGuard.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { UnAuthorized, LengthMissmatch, InvalidContract } from \"../Errors/GenericErrors.sol\";\nimport { Validatable } from \"../Helpers/Validatable.sol\";\n\n/// @title Generic Cross-Chain Facet\n/// @notice Provides functionality for bridging through arbitrary cross-chain provider\ncontract GenericCrossChainFacet is\n    IRubic,\n    ReentrancyGuard,\n    SwapperV2,\n    Validatable\n{\n    /// Events ///\n\n    event ProviderFunctionAmountOffsetUpdated(\n        address[] _routers,\n        bytes4[] _selectors,\n        uint256[] _offsets\n    );\n\n    /// Types ///\n\n    /// @param router Address of the router that has to be called\n    /// @param callData Calldata that has to be passed to the router\n    struct GenericCrossChainData {\n        address router;\n        bytes callData;\n    }\n\n    /// Modifiers ///\n\n    modifier validateGenericData(GenericCrossChainData calldata _genericData) {\n        if (!LibAsset.isContract(_genericData.router))\n            revert InvalidContract();\n        _;\n    }\n\n    /// External Methods ///\n\n    /// @notice Updates the amount offset of the specific function of the specific provider's router\n    /// @param _routers Array of provider's routers\n    /// @param _selectors Array of function selectors\n    /// @param _offsets Array of amount offsets\n    function updateProviderFunctionAmountOffset(\n        address[] calldata _routers,\n        bytes4[] calldata _selectors,\n        uint256[] calldata _offsets\n    ) external {\n        LibDiamond.enforceIsContractOwner();\n\n        LibMappings.GenericCrossChainMappings storage sm = LibMappings\n            .getGenericCrossChainMappings();\n\n        if (\n            _routers.length != _selectors.length ||\n            _selectors.length != _offsets.length\n        ) {\n            revert LengthMissmatch();\n        }\n\n        for (uint64 i; i < _routers.length; ) {\n            sm.providerFunctionAmountOffset[_routers[i]][\n                _selectors[i]\n            ] = _offsets[i];\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit ProviderFunctionAmountOffsetUpdated(\n            _routers,\n            _selectors,\n            _offsets\n        );\n    }\n\n    /// @notice Bridges tokens via arbitrary cross-chain provider\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _genericData data specific to GenericCrossChainFacet\n    function startBridgeTokensViaGenericCrossChain(\n        IRubic.BridgeData memory _bridgeData,\n        GenericCrossChainData calldata _genericData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(_bridgeData.refundee))\n        validateBridgeData(_bridgeData)\n        validateGenericData(_genericData)\n        doesNotContainSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n    {\n        _bridgeData.minAmount = LibAsset.depositAssetAndAccrueFees(\n            _bridgeData.sendingAssetId,\n            _bridgeData.minAmount,\n            0,\n            _bridgeData.integrator\n        );\n\n        _startBridge(\n            _bridgeData,\n            _patchGenericCrossChainData(_genericData, _bridgeData.minAmount)\n        );\n    }\n\n    /// @notice Bridges tokens via arbitrary cross-chain provider with swaps before bridging\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _swapData an array of swap related data for performing swaps before bridging\n    /// @param _genericData data specific to GenericCrossChainFacet\n    function swapAndStartBridgeTokensViaGenericCrossChain(\n        IRubic.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        GenericCrossChainData calldata _genericData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(_bridgeData.refundee))\n        containsSourceSwaps(_bridgeData)\n        validateBridgeData(_bridgeData)\n        validateGenericData(_genericData)\n    {\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            _bridgeData.integrator,\n            payable(_bridgeData.refundee)\n        );\n\n        _startBridge(\n            _bridgeData,\n            _patchGenericCrossChainData(_genericData, _bridgeData.minAmount)\n        );\n    }\n\n    /// View Methods ///\n\n    /// @notice Fetches the amount offset of the specific function of the specific provider's router\n    /// @param _router Address of provider's router\n    /// @param _selector Selector of the function\n    /// @return Amount offset\n    function getProviderFunctionAmountOffset(\n        address _router,\n        bytes4 _selector\n    ) external view returns (uint256) {\n        LibMappings.GenericCrossChainMappings storage sm = LibMappings\n            .getGenericCrossChainMappings();\n\n        return sm.providerFunctionAmountOffset[_router][_selector];\n    }\n\n    /// Internal Methods ///\n\n    /// @dev Contains the business logic for the bridge via arbitrary cross-chain provider\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _genericData data specific to GenericCrossChainFacet\n    function _startBridge(\n        IRubic.BridgeData memory _bridgeData,\n        GenericCrossChainData memory _genericData\n    ) internal {\n        bool isNative = LibAsset.isNativeAsset(_bridgeData.sendingAssetId);\n        uint256 nativeAssetAmount;\n\n        if (isNative) {\n            nativeAssetAmount = _bridgeData.minAmount;\n        } else {\n            LibAsset.maxApproveERC20(\n                IERC20(_bridgeData.sendingAssetId),\n                _genericData.router,\n                _bridgeData.minAmount\n            );\n        }\n\n        (bool success, bytes memory res) = _genericData.router.call{\n            value: nativeAssetAmount\n        }(_genericData.callData);\n        if (!success) {\n            string memory reason = LibUtil.getRevertMsg(res);\n            revert(reason);\n        }\n\n        emit RubicTransferStarted(_bridgeData);\n    }\n\n    function _patchGenericCrossChainData(\n        GenericCrossChainData calldata _genericData,\n        uint256 amount\n    ) private view returns (GenericCrossChainData memory) {\n        LibMappings.GenericCrossChainMappings storage sm = LibMappings\n            .getGenericCrossChainMappings();\n        uint256 offset = sm.providerFunctionAmountOffset[_genericData.router][\n            bytes4(_genericData.callData[:4])\n        ];\n\n        if (offset > 0) {\n            return\n                GenericCrossChainData(\n                    _genericData.router,\n                    bytes.concat(\n                        _genericData.callData[:offset],\n                        abi.encode(amount),\n                        _genericData.callData[offset + 32:]\n                    )\n                );\n        } else {\n            return\n                GenericCrossChainData(\n                    _genericData.router,\n                    _genericData.callData\n                );\n        }\n    }\n}"
    }
  ]
}