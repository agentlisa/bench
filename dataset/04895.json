{
  "Title": "[H-03] Users will never be able to withdraw their claimed airdrop fully in ERC20Airdrop2.sol contract",
  "Content": "\n**Context:**\nThe ERC20Airdrop2.sol contract is for managing Taiko token airdrop for eligible users, but the withdrawal is not immediate and is subject to a withdrawal window.\n\nUsers can claim their tokens within claimStart and claimEnd. Once the claim window is over at claimEnd, they can withdraw their tokens between claimEnd and claimEnd + withdrawalWindow. During this withdrawal period, the tokens unlock linearly i.e. the tokens only become fully withdrawable at claimEnd + withdrawalWindow.\n\n**Issue:**\nThe issue is that once the tokens for a user are fully unlocked, the [withdraw()](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L88) function cannot be called anymore due to the [ongoingWithdrawals modifier](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L39) having a strict `claimEnd + withdrawalWindow < block.timestamp` check in its second condition.\n\n**Impact:**\nAlthough the tokens become fully unlocked when block.timestamp = claimEnd + withdrawalWindow, it is extremely difficult or close to impossible for normal users to time this to get their full allocated claim amount. This means that users are always bound to lose certain amount of their eligible claim amount. This lost amount can be small for users who claim closer to claimEnd + withdrawalWindow and higher for those who partially claimed initially or did not claim at all thinking that they would claim once their tokens are fully unlocked.\n\n### Coded POC\n\nHow to use this POC:\n\n*   Add the POC to `test/team/airdrop/ERC20Airdrop2.t.sol`\n*   Run the POC using `forge test --match-test testAirdropIssue -vvv`\n*   The POC demonstrates how alice was only able to claim half her tokens out of her total 100 tokens claimable amount.\n\n```solidity\n      function testAirdropIssue() public {\n        vm.warp(uint64(block.timestamp + 11));\n\n        vm.prank(Alice, Alice);\n        airdrop2.claim(Alice, 100, merkleProof);\n\n        // Roll 5 days after\n        vm.roll(block.number + 200);\n        vm.warp(claimEnd + 5 days);\n\n        airdrop2.withdraw(Alice);\n\n        console.log(\"Alice balance:\", token.balanceOf(Alice));\n\n        // Roll 6 days after\n        vm.roll(block.number + 200);\n        vm.warp(claimEnd + 11 days);\n\n        vm.expectRevert(ERC20Airdrop2.WITHDRAWALS_NOT_ONGOING.selector);\n        airdrop2.withdraw(Alice);\n    }\n```\n\n### Logs\n\n```solidity\nLogs:\n  > MockERC20Airdrop @ 0x0000000000000000000000000000000000000000\n    proxy      : 0xF62849F9A0B5Bf2913b396098F7c7019b51A820a\n    impl       : 0x2e234DAe75C793f67A35089C9d99245E1C58470b\n    owner      : 0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496\n    msg.sender : 0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38\n    this       : 0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496\n  Alice balance: 50\n```\n\n### Recommended Mitigation Steps\n\nIn the [modifier ongoingWithdrawals()](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L39), consider adding a buffer window in the second condition that gives users enough time to claim the fully unlocked tokens.\n\n```solidity\n    uint256 constant bufferWindow = X mins/hours/days;\n\n    modifier ongoingWithdrawals() {\n        if (claimEnd > block.timestamp || claimEnd + withdrawalWindow < block.timestamp + bufferWindow) {\n            revert WITHDRAWALS_NOT_ONGOING();\n        }\n        _;\n    }\n```\n**[dantaik (Taiko) commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/245#issuecomment-2033388656):**\n > Fixed in https://github.com/taikoxyz/taiko-mono/pull/16596\n\n**[adaki2004 (Taiko) confirmed and commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/245#issuecomment-2037149300):**\n > It is indeed a bug in the flow, while we removed Airdrop2, it is still a confirmed finding on the repo for auditing.\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2024-03-taiko",
  "Code": [
    {
      "filename": "packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../libs/LibMath.sol\";\nimport \"./MerkleClaimable.sol\";\n\n/// @title ERC20Airdrop2\n/// @notice Contract for managing Taiko token airdrop for eligible users, but the\n/// withdrawal is not immediate and is subject to a withdrawal window.\n/// @custom:security-contact security@taiko.xyz\ncontract ERC20Airdrop2 is MerkleClaimable {\n    using LibMath for uint256;\n\n    /// @notice The address of the token contract.\n    address public token;\n\n    /// @notice The address of the vault contract.\n    address public vault;\n\n    /// @notice Represents the token amount for which the user has claimed.\n    mapping(address addr => uint256 amountClaimed) public claimedAmount;\n\n    /// @notice Represents the already withdrawn amount.\n    mapping(address addr => uint256 amountWithdrawn) public withdrawnAmount;\n\n    /// @notice Length of the withdrawal window.\n    uint64 public withdrawalWindow;\n\n    uint256[45] private __gap;\n\n    /// @notice Event emitted when a user withdraws their tokens.\n    /// @param user The address of the user.\n    /// @param amount The amount of tokens withdrawn.\n    event Withdrawn(address user, uint256 amount);\n\n    error WITHDRAWALS_NOT_ONGOING();\n\n    modifier ongoingWithdrawals() {\n        if (claimEnd > block.timestamp || claimEnd + withdrawalWindow < block.timestamp) {\n            revert WITHDRAWALS_NOT_ONGOING();\n        }\n        _;\n    }\n\n    /// @notice Initializes the contract.\n    /// @param _owner The owner of this contract.\n    /// @param _claimStart The start time of the claim period.\n    /// @param _claimEnd The end time of the claim period.\n    /// @param _merkleRoot The merkle root.\n    /// @param _token The address of the token contract.\n    /// @param _vault The address of the vault contract.\n    /// @param _withdrawalWindow The length of the withdrawal window.\n    function init(\n        address _owner,\n        uint64 _claimStart,\n        uint64 _claimEnd,\n        bytes32 _merkleRoot,\n        address _token,\n        address _vault,\n        uint64 _withdrawalWindow\n    )\n        external\n        initializer\n    {\n        __Essential_init(_owner);\n        __MerkleClaimable_init(_claimStart, _claimEnd, _merkleRoot);\n\n        token = _token;\n        vault = _vault;\n        withdrawalWindow = _withdrawalWindow;\n    }\n\n    /// @notice Claims the airdrop for the user.\n    /// @param user The address of the user.\n    /// @param amount The amount of tokens to claim.\n    /// @param proof The merkle proof.\n    function claim(address user, uint256 amount, bytes32[] calldata proof) external nonReentrant {\n        // Check if this can be claimed\n        _verifyClaim(abi.encode(user, amount), proof);\n\n        // Assign the tokens\n        claimedAmount[user] += amount;\n    }\n\n    /// @notice External withdraw function\n    /// @param user User address\n    function withdraw(address user) external ongoingWithdrawals {\n        (, uint256 amount) = getBalance(user);\n        withdrawnAmount[user] += amount;\n        IERC20(token).transferFrom(vault, user, amount);\n\n        emit Withdrawn(user, amount);\n    }\n\n    /// @notice Getter for the balance and withdrawal amount per given user\n    /// The 2nd airdrop is subject to an unlock period. User has to claim his\n    /// tokens (within claimStart and claimEnd), but not immediately\n    /// withdrawable. With a time of X (withdrawalWindow) it becomes fully\n    /// withdrawable - and unlocks linearly.\n    /// @param user User address\n    /// @return balance The balance the user successfully claimed\n    /// @return withdrawableAmount The amount available to withdraw\n    function getBalance(address user)\n        public\n        view\n        returns (uint256 balance, uint256 withdrawableAmount)\n    {\n        balance = claimedAmount[user];\n        // If balance is 0 then there is no balance and withdrawable amount\n        if (balance == 0) return (0, 0);\n        // Balance might be positive before end of claiming (claimEnd - if claimed already) but\n        // withdrawable is 0.\n        if (block.timestamp < claimEnd) return (balance, 0);\n\n        // Hard cap timestamp - so range cannot go over - to get more allocation over time.\n        uint256 timeBasedAllowance = balance\n            * (block.timestamp.min(claimEnd + withdrawalWindow) - claimEnd) / withdrawalWindow;\n\n        withdrawableAmount = timeBasedAllowance - withdrawnAmount[user];\n    }\n}"
    },
    {
      "filename": "packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../libs/LibMath.sol\";\nimport \"./MerkleClaimable.sol\";\n\n/// @title ERC20Airdrop2\n/// @notice Contract for managing Taiko token airdrop for eligible users, but the\n/// withdrawal is not immediate and is subject to a withdrawal window.\n/// @custom:security-contact security@taiko.xyz\ncontract ERC20Airdrop2 is MerkleClaimable {\n    using LibMath for uint256;\n\n    /// @notice The address of the token contract.\n    address public token;\n\n    /// @notice The address of the vault contract.\n    address public vault;\n\n    /// @notice Represents the token amount for which the user has claimed.\n    mapping(address addr => uint256 amountClaimed) public claimedAmount;\n\n    /// @notice Represents the already withdrawn amount.\n    mapping(address addr => uint256 amountWithdrawn) public withdrawnAmount;\n\n    /// @notice Length of the withdrawal window.\n    uint64 public withdrawalWindow;\n\n    uint256[45] private __gap;\n\n    /// @notice Event emitted when a user withdraws their tokens.\n    /// @param user The address of the user.\n    /// @param amount The amount of tokens withdrawn.\n    event Withdrawn(address user, uint256 amount);\n\n    error WITHDRAWALS_NOT_ONGOING();\n\n    modifier ongoingWithdrawals() {\n        if (claimEnd > block.timestamp || claimEnd + withdrawalWindow < block.timestamp) {\n            revert WITHDRAWALS_NOT_ONGOING();\n        }\n        _;\n    }\n\n    /// @notice Initializes the contract.\n    /// @param _owner The owner of this contract.\n    /// @param _claimStart The start time of the claim period.\n    /// @param _claimEnd The end time of the claim period.\n    /// @param _merkleRoot The merkle root.\n    /// @param _token The address of the token contract.\n    /// @param _vault The address of the vault contract.\n    /// @param _withdrawalWindow The length of the withdrawal window.\n    function init(\n        address _owner,\n        uint64 _claimStart,\n        uint64 _claimEnd,\n        bytes32 _merkleRoot,\n        address _token,\n        address _vault,\n        uint64 _withdrawalWindow\n    )\n        external\n        initializer\n    {\n        __Essential_init(_owner);\n        __MerkleClaimable_init(_claimStart, _claimEnd, _merkleRoot);\n\n        token = _token;\n        vault = _vault;\n        withdrawalWindow = _withdrawalWindow;\n    }\n\n    /// @notice Claims the airdrop for the user.\n    /// @param user The address of the user.\n    /// @param amount The amount of tokens to claim.\n    /// @param proof The merkle proof.\n    function claim(address user, uint256 amount, bytes32[] calldata proof) external nonReentrant {\n        // Check if this can be claimed\n        _verifyClaim(abi.encode(user, amount), proof);\n\n        // Assign the tokens\n        claimedAmount[user] += amount;\n    }\n\n    /// @notice External withdraw function\n    /// @param user User address\n    function withdraw(address user) external ongoingWithdrawals {\n        (, uint256 amount) = getBalance(user);\n        withdrawnAmount[user] += amount;\n        IERC20(token).transferFrom(vault, user, amount);\n\n        emit Withdrawn(user, amount);\n    }\n\n    /// @notice Getter for the balance and withdrawal amount per given user\n    /// The 2nd airdrop is subject to an unlock period. User has to claim his\n    /// tokens (within claimStart and claimEnd), but not immediately\n    /// withdrawable. With a time of X (withdrawalWindow) it becomes fully\n    /// withdrawable - and unlocks linearly.\n    /// @param user User address\n    /// @return balance The balance the user successfully claimed\n    /// @return withdrawableAmount The amount available to withdraw\n    function getBalance(address user)\n        public\n        view\n        returns (uint256 balance, uint256 withdrawableAmount)\n    {\n        balance = claimedAmount[user];\n        // If balance is 0 then there is no balance and withdrawable amount\n        if (balance == 0) return (0, 0);\n        // Balance might be positive before end of claiming (claimEnd - if claimed already) but\n        // withdrawable is 0.\n        if (block.timestamp < claimEnd) return (balance, 0);\n\n        // Hard cap timestamp - so range cannot go over - to get more allocation over time.\n        uint256 timeBasedAllowance = balance\n            * (block.timestamp.min(claimEnd + withdrawalWindow) - claimEnd) / withdrawalWindow;\n\n        withdrawableAmount = timeBasedAllowance - withdrawnAmount[user];\n    }\n}"
    }
  ]
}