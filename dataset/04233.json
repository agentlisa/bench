{
  "Title": "[H09] Slash process can be bypassed",
  "Content": "There are two ways for any address to be slashed. The first one is by a governance’s proposal, and the second one is by a transaction performed by the guardian.\n\n\nFor governance to decide to slash a service provider, a proposal must be submitted to the contract, stakers must vote on it and achieve a majority, and then it has to be executed. This process takes several blocks to complete.\n\n\n[The `votingPeriod`](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/Governance.sol#L23) establishes how long a governance proposal is open for voting.\n\n\nSimilarly, the [`decreaseStakeLockupDuration` variable](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/ServiceProviderFactory.sol#L17) establishes the minimum length of time a service provider must wait before removing their stake.\n\n\nIf `decreaseStakeLockupDuration` is less than or equal to the `votingPeriod`, it will be possible for a malicious service provider to remove their stake before it can be slashed by the Governance protocol.\n\n\nSince the guardian is expected to be removed once the system is fully operational — meaning that slashing a malicious service provider using the guardian account will not be possible — consider setting the `decreaseStakeLockupDuration` so it is much greater than the `votingPeriod`. This would ensure that a malicious service provider can always be slashed via governance.\n\n\n***Update**: Fixed in [pull request #657](https://github.com/AudiusProject/audius-protocol/pull/657). The `_updateDecreaseStakeLockupDuration` function enforces that the `decreaseStakeLockupDuration` value is greater than the voting period plus an execution delay.*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "eth-contracts/contracts/Governance.sol",
      "content": "pragma solidity ^0.5.0;\n\nimport \"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\";\nimport \"./Staking.sol\";\nimport \"./registry/Registry.sol\";\nimport \"./InitializableV2.sol\";\n\n\ncontract Governance is InitializableV2 {\n    using SafeMath for uint;\n\n    /**\n     * @notice Address and contract instance of Audius Registry. Used to ensure this contract\n     *      can only govern contracts that are registered in the Audius Registry.\n     */\n    Registry private registry;\n    address private registryAddress;\n\n    /// @notice Address of Audius staking contract, used to permission Governance method calls\n    address private stakingAddress;\n\n    /// @notice Period in blocks for which a governance proposal is open for voting\n    uint256 private votingPeriod;\n\n    /// @notice Required miniumum number of votes to consider a proposal valid\n    uint256 private votingQuorum;\n\n    /**\n     * @notice Address of account that has special Governance permissions. Can veto proposals\n     *      and execute transactions directly on contracts.\n     */\n    address private guardianAddress;\n\n    /***** Enums *****/\n\n    /**\n     * @notice All Proposal Outcome states.\n     *      InProgress - Proposal is active and can be voted on\n     *      No - Proposal votingPeriod has closed and decision is No. Proposal will not be executed.\n     *      Yes - Proposal votingPeriod has closed and decision is Yes. Proposal will be executed.\n     *      Invalid - Proposal votingPeriod has closed and votingQuorum was not met. Proposal will not be executed.\n     *      TxFailed - Proposal voting decision was Yes, but transaction execution failed.\n     *      Evaluating - Proposal voting decision was Yes, and evaluateProposalOutcome function is currently running.\n     *          This status is transiently used inside that function to prevent re-entrancy.\n     */\n    enum Outcome {InProgress, No, Yes, Invalid, TxFailed, Evaluating}\n\n    /**\n     * @notice All Proposal Vote states for a voter.\n     *      None - The default state, for any account that has not previously voted on this Proposal.\n     *      No - The account voted No on this Proposal.\n     *      Yes - The account voted Yes on this Proposal.\n     *\n     * @dev Enum values map to uints, so first value in Enum always is 0.\n     */\n    enum Vote {None, No, Yes}\n\n    struct Proposal {\n        uint256 proposalId;\n        address proposer;\n        uint256 startBlockNumber;\n        bytes32 targetContractRegistryKey;\n        address targetContractAddress;\n        uint callValue;\n        string signature;\n        bytes callData;\n        Outcome outcome;\n        uint256 voteMagnitudeYes;\n        uint256 voteMagnitudeNo;\n        uint256 numVotes;\n        mapping(address => Vote) votes;\n    }\n\n    /***** Proposal storage *****/\n    uint256 lastProposalId = 0;\n    mapping(uint256 => Proposal) proposals;\n\n    /***** Events *****/\n    event ProposalSubmitted(\n        uint256 indexed proposalId,\n        address indexed proposer,\n        uint256 startBlockNumber,\n        string description\n    );\n    event ProposalVoteSubmitted(\n        uint256 indexed proposalId,\n        address indexed voter,\n        Vote indexed vote,\n        uint256 voterStake,\n        Vote previousVote\n    );\n    event ProposalOutcomeEvaluated(\n        uint256 indexed proposalId,\n        Outcome indexed outcome,\n        uint256 voteMagnitudeYes,\n        uint256 voteMagnitudeNo,\n        uint256 numVotes\n    );\n    event ProposalTransactionExecuted(\n        uint256 indexed proposalId,\n        bool indexed success,\n        bytes returnData\n    );\n    event GuardianTransactionExecuted(\n        address indexed targetContractAddress,\n        uint256 callValue,\n        string indexed signature,\n        bytes indexed callData,\n        bytes returnData\n    );\n    event ProposalVetoed(uint256 indexed proposalId);\n\n    /**\n     * @notice Initialize the Governance contract\n     * @dev _votingPeriod <= DelegateManager.undelegateLockupDuration\n     * @param _registryAddress - address of the registry proxy contract\n     * @param _votingPeriod - period in blocks for which a governance proposal is open for voting\n     * @param _votingQuorum - required minimum number of votes to consider a proposal valid\n     * @param _guardianAddress - address of account that has special Governance permissions\n\n     */\n    function initialize(\n        address _registryAddress,\n        uint256 _votingPeriod,\n        uint256 _votingQuorum,\n        address _guardianAddress\n    ) public initializer {\n        require(_registryAddress != address(0x00), \"Requires non-zero _registryAddress\");\n        registryAddress = _registryAddress;\n        registry = Registry(_registryAddress);\n\n        require(_votingPeriod > 0, \"Requires non-zero _votingPeriod\");\n        votingPeriod = _votingPeriod;\n\n        require(_votingQuorum > 0, \"Requires non-zero _votingQuorum\");\n        votingQuorum = _votingQuorum;\n\n        require(_guardianAddress != address(0x00), \"Requires non-zero _guardianAddress\");\n        guardianAddress = _guardianAddress;  //Guardian address becomes the only party\n\n        InitializableV2.initialize();\n    }\n\n    // ========================================= Governance Actions =========================================\n\n    /**\n     * @notice Submit a proposal for vote. Only callable by stakers with non-zero stake.\n     * @param _targetContractRegistryKey - Registry key for the contract concerning this proposal\n     * @param _callValue - amount of wei to pass with function call if a token transfer is involved\n     * @param _signature - function signature of the function to be executed if proposal is successful\n     * @param _callData - encoded value(s) to call function with if proposal is successful\n     * @param _description - Text description of proposal to be emitted in event\n     */\n    function submitProposal(\n        bytes32 _targetContractRegistryKey,\n        uint256 _callValue,\n        string calldata _signature,\n        bytes calldata _callData,\n        string calldata _description\n    ) external returns (uint256 proposalId)\n    {\n        _requireIsInitialized();\n\n        address proposer = msg.sender;\n\n        // Require proposer is active Staker\n        Staking stakingContract = Staking(stakingAddress);\n        require(\n            stakingContract.totalStakedFor(proposer) > 0,\n            \"Proposer must be active staker with non-zero stake.\"\n        );\n\n        // Require _targetContractRegistryKey points to a valid registered contract\n        address targetContractAddress = registry.getContract(_targetContractRegistryKey);\n        require(\n            targetContractAddress != address(0x00),\n            \"_targetContractRegistryKey must point to valid registered contract\"\n        );\n\n        // Signature cannot be empty\n        require(\n            bytes(_signature).length != 0,\n            \"Governance::submitProposal: _signature cannot be empty.\"\n        );\n\n        // set proposalId\n        uint256 newProposalId = lastProposalId.add(1);\n\n        // Store new Proposal obj in proposals mapping\n        proposals[newProposalId] = Proposal({\n            proposalId: newProposalId,\n            proposer: proposer,\n            startBlockNumber: block.number,\n            targetContractRegistryKey: _targetContractRegistryKey,\n            targetContractAddress: targetContractAddress,\n            callValue: _callValue,\n            signature: _signature,\n            callData: _callData,\n            outcome: Outcome.InProgress,\n            voteMagnitudeYes: 0,\n            voteMagnitudeNo: 0,\n            numVotes: 0\n            /* votes: mappings are auto-initialized to default state */\n        });\n\n        emit ProposalSubmitted(\n            newProposalId,\n            proposer,\n            block.number,\n            _description\n        );\n\n        lastProposalId = lastProposalId.add(1);\n\n        return newProposalId;\n    }\n\n    /**\n     * @notice Vote on an active Proposal. Only callable by stakers with non-zero stake.\n     * @param _proposalId - id of the proposal this vote is for\n     * @param _vote - can be either {Yes, No} from Vote enum. No other values allowed\n     */\n    function submitProposalVote(uint256 _proposalId, Vote _vote) external {\n        _requireIsInitialized();\n\n        address voter = msg.sender;\n\n        require(\n            _proposalId <= lastProposalId && _proposalId > 0,\n            \"Must provide valid non-zero _proposalId\"\n        );\n\n        // Require voter is active Staker + get voterStake.\n        Staking stakingContract = Staking(stakingAddress);\n\n        uint256 voterStake = stakingContract.totalStakedForAt(\n            voter,\n            proposals[_proposalId].startBlockNumber\n        );\n        require(voterStake > 0, \"Voter must be active staker with non-zero stake.\");\n\n        // Require proposal is still active\n        require(\n            proposals[_proposalId].outcome == Outcome.InProgress,\n            \"Governance::submitProposalVote: Cannot vote on inactive proposal.\"\n        );\n\n        // Require proposal votingPeriod is still active.\n        uint256 startBlockNumber = proposals[_proposalId].startBlockNumber;\n        uint256 endBlockNumber = startBlockNumber.add(votingPeriod);\n        require(\n            block.number > startBlockNumber && block.number <= endBlockNumber,\n            \"Governance::submitProposalVote: Proposal votingPeriod has ended\"\n        );\n\n        // Require vote is either Yes or No\n        require(\n            _vote == Vote.Yes || _vote == Vote.No,\n            \"Governance::submitProposalVote: Can only submit a Yes or No vote\"\n        );\n\n        // Record previous vote.\n        Vote previousVote = proposals[_proposalId].votes[voter];\n\n        // Will override staker's previous vote if present.\n        proposals[_proposalId].votes[voter] = _vote;\n\n        /* Update voteMagnitudes accordingly */\n\n        // New voter (Vote enum defaults to 0)\n        if (previousVote == Vote.None) {\n            if (_vote == Vote.Yes) {\n                proposals[_proposalId].voteMagnitudeYes = (\n                    proposals[_proposalId].voteMagnitudeYes.add(voterStake)\n                );\n            } else {\n                proposals[_proposalId].voteMagnitudeNo = (\n                    proposals[_proposalId].voteMagnitudeNo.add(voterStake)\n                );\n            }\n            proposals[_proposalId].numVotes = proposals[_proposalId].numVotes.add(1);\n        } else { // Repeat voter\n            if (previousVote == Vote.Yes && _vote == Vote.No) {\n                proposals[_proposalId].voteMagnitudeYes = (\n                    proposals[_proposalId].voteMagnitudeYes.sub(voterStake)\n                );\n                proposals[_proposalId].voteMagnitudeNo = (\n                    proposals[_proposalId].voteMagnitudeNo.add(voterStake)\n                );\n            } else if (previousVote == Vote.No && _vote == Vote.Yes) {\n                proposals[_proposalId].voteMagnitudeYes = (\n                    proposals[_proposalId].voteMagnitudeYes.add(voterStake)\n                );\n                proposals[_proposalId].voteMagnitudeNo = (\n                    proposals[_proposalId].voteMagnitudeNo.sub(voterStake)\n                );\n            }\n            // If _vote == previousVote, no changes needed to vote magnitudes.\n        }\n\n        emit ProposalVoteSubmitted(\n            _proposalId,\n            voter,\n            _vote,\n            voterStake,\n            previousVote\n        );\n    }\n\n    /**\n     * @notice Once the voting period for a proposal has ended, evaluate the outcome and\n     *      execute the proposal if stake-weighted vote is >= 50% Yes and voting quorum met.\n     * @dev Requires that caller is an active staker at the time the proposal is created\n     * @param _proposalId - id of the proposal\n     */\n    function evaluateProposalOutcome(uint256 _proposalId)\n    external returns (Outcome proposalOutcome)\n    {\n        _requireIsInitialized();\n\n        require(\n            _proposalId <= lastProposalId && _proposalId > 0,\n            \"Governance::evaluateProposalOutcome: Must provide valid non-zero _proposalId.\"\n        );\n\n        // Require proposal has not already been evaluated.\n        require(\n            proposals[_proposalId].outcome == Outcome.InProgress,\n            \"Governance::evaluateProposalOutcome: Cannot evaluate inactive proposal.\"\n        );\n\n        /// Re-entrancy should not be possible here since this switches the status of the\n        /// proposal to 'Evaluating' so it should fail the status is 'InProgress' check\n        proposals[_proposalId].outcome = Outcome.Evaluating;\n\n        // Require msg.sender is active Staker.\n        Staking stakingContract = Staking(stakingAddress);\n\n        require(\n            stakingContract.totalStakedForAt(\n                msg.sender, proposals[_proposalId].startBlockNumber\n            ) > 0,\n            \"Governance::evaluateProposalOutcome: Caller must be active staker with non-zero stake.\"\n        );\n\n        // Require proposal votingPeriod has ended.\n        uint256 startBlockNumber = proposals[_proposalId].startBlockNumber;\n        uint256 endBlockNumber = startBlockNumber.add(votingPeriod);\n        require(\n            block.number > endBlockNumber,\n            \"Governance::evaluateProposalOutcome: Proposal votingPeriod must end before evaluation.\"\n        );\n\n        // Require registered contract address for provided registryKey has not changed.\n        address targetContractAddress = registry.getContract(\n            proposals[_proposalId].targetContractRegistryKey\n        );\n        require(\n            targetContractAddress == proposals[_proposalId].targetContractAddress,\n            \"Governance::evaluateProposalOutcome: Registered contract address for targetContractRegistryKey has changed\"\n        );\n\n        // Calculate outcome\n        Outcome outcome;\n        // votingQuorum not met -> proposal is invalid.\n        if (proposals[_proposalId].numVotes < votingQuorum) {\n            outcome = Outcome.Invalid;\n        }\n        // votingQuorum met & vote is Yes -> execute proposed transaction & close proposal.\n        else if (\n            proposals[_proposalId].voteMagnitudeYes >= proposals[_proposalId].voteMagnitudeNo\n        ) {\n            (bool success, bytes memory returnData) = _executeTransaction(\n                targetContractAddress,\n                proposals[_proposalId].callValue,\n                proposals[_proposalId].signature,\n                proposals[_proposalId].callData\n            );\n\n            emit ProposalTransactionExecuted(\n                _proposalId,\n                success,\n                returnData\n            );\n\n            // Proposal outcome depends on success of transaction execution.\n            if (success) {\n                outcome = Outcome.Yes;\n            } else {\n                outcome = Outcome.TxFailed;\n            }\n        }\n        // votingQuorum met & vote is No -> close proposal without transaction execution.\n        else {\n            outcome = Outcome.No;\n        }\n\n        /// This records the final outcome in the proposals mapping\n        proposals[_proposalId].outcome = outcome;\n\n        emit ProposalOutcomeEvaluated(\n            _proposalId,\n            outcome,\n            proposals[_proposalId].voteMagnitudeYes,\n            proposals[_proposalId].voteMagnitudeNo,\n            proposals[_proposalId].numVotes\n        );\n\n        return outcome;\n    }\n\n    /**\n     * @notice Action limited to the guardian address that can veto a proposal\n     * @param _proposalId - id of the proposal\n     */\n    function vetoProposal(uint256 _proposalId) external {\n        _requireIsInitialized();\n\n        require(\n            msg.sender == guardianAddress,\n            \"Governance::vetoProposal: Only guardian can veto proposals.\"\n        );\n\n        require(\n            _proposalId <= lastProposalId && _proposalId > 0,\n            \"Governance::vetoProposal: Must provide valid non-zero _proposalId.\"\n        );\n\n        require(\n            proposals[_proposalId].outcome == Outcome.InProgress,\n            \"Governance::vetoProposal: Cannot veto inactive proposal.\"\n        );\n\n        proposals[_proposalId].outcome = Outcome.No;\n\n        emit ProposalVetoed(_proposalId);\n    }\n\n    // ========================================= Config Setters =========================================\n\n    /**\n     * @notice Set the Staking address\n     * @dev Only callable by self via _executeTransaction\n     * @param _stakingAddress - address for new Staking contract\n     */\n    function setStakingAddress(address _stakingAddress) external {\n        require(msg.sender == address(this), \"Only callable by self\");\n        require(_stakingAddress != address(0x00), \"Requires non-zero _stakingAddress\");\n        stakingAddress = _stakingAddress;\n    }\n\n    /**\n     * @notice Set the voting period for a Governance proposal\n     * @dev Only callable by self via _executeTransaction\n     * @param _votingPeriod - new voting period\n     */\n    function setVotingPeriod(uint256 _votingPeriod) external {\n        require(msg.sender == address(this), \"Only callable by self\");\n        votingPeriod = _votingPeriod;\n    }\n\n    /**\n     * @notice Set the voting quorum for a Governance proposal\n     * @dev Only callable by self via _executeTransaction\n     * @param _votingQuorum - new voting period\n     */\n    function setVotingQuorum(uint256 _votingQuorum) external {\n        require(msg.sender == address(this), \"Only callable by self\");\n        votingQuorum = _votingQuorum;\n    }\n\n    /**\n     * @notice Set the Registry address\n     * @dev Only callable by self via _executeTransaction\n     * @param _registryAddress - address for new Registry contract\n     */\n    function setRegistryAddress(address _registryAddress) external {\n        require(msg.sender == address(this), \"Only callable by self\");\n        require(_registryAddress != address(0x00), \"Requires non-zero _registryAddress\");\n        registryAddress = _registryAddress;\n        registry = Registry(_registryAddress);\n    }\n\n    // ========================================= Guardian Actions =========================================\n\n    /**\n     * @notice Allows the guardianAddress to execute protocol actions\n     * @param _targetContractRegistryKey - key in registry of target contraact\n     * @param _callValue - amount of wei if a token transfer is involved\n     * @param _signature - function signature of the function to be executed if proposal is successful\n     * @param _callData - encoded value(s) to call function with if proposal is successful\n     */\n    function guardianExecuteTransaction(\n        bytes32 _targetContractRegistryKey,\n        uint256 _callValue,\n        string calldata _signature,\n        bytes calldata _callData\n    ) external\n    {\n        _requireIsInitialized();\n\n        require(\n            msg.sender == guardianAddress,\n            \"Governance::guardianExecuteTransaction: Only guardian.\"\n        );\n\n        // _targetContractRegistryKey must point to a valid registered contract\n        address targetContractAddress = registry.getContract(_targetContractRegistryKey);\n        require(\n            targetContractAddress != address(0x00),\n            \"Governance::guardianExecuteTransaction: _targetContractRegistryKey must point to valid registered contract\"\n        );\n\n        // Signature cannot be empty\n        require(\n            bytes(_signature).length != 0,\n            \"Governance::guardianExecuteTransaction: _signature cannot be empty.\"\n        );\n\n        (bool success, bytes memory returnData) = _executeTransaction(\n            targetContractAddress,\n            _callValue,\n            _signature,\n            _callData\n        );\n\n        require(success, \"Governance::guardianExecuteTransaction: Transaction failed.\");\n\n        emit GuardianTransactionExecuted(\n            targetContractAddress,\n            _callValue,\n            _signature,\n            _callData,\n            returnData\n        );\n    }\n\n    /**\n     * @notice Change the guardian address\n     * @dev Only callable by current guardian\n     * @param _newGuardianAddress - new guardian address\n     */\n    function transferGuardianship(address _newGuardianAddress) external {\n        _requireIsInitialized();\n\n        require(\n            msg.sender == guardianAddress,\n            \"Governance::guardianExecuteTransaction: Only guardian.\"\n        );\n\n        guardianAddress = _newGuardianAddress;\n    }\n\n    // ========================================= Getter Functions =========================================\n\n    /**\n     * @notice Get proposal information by proposal Id\n     * @param _proposalId - id of proposal\n     */\n    function getProposalById(uint256 _proposalId)\n    external view returns (\n        uint256 proposalId,\n        address proposer,\n        uint256 startBlockNumber,\n        bytes32 targetContractRegistryKey,\n        address targetContractAddress,\n        uint callValue,\n        string memory signature,\n        bytes memory callData,\n        Outcome outcome,\n        uint256 voteMagnitudeYes,\n        uint256 voteMagnitudeNo,\n        uint256 numVotes\n    )\n    {\n        require(\n            _proposalId <= lastProposalId && _proposalId > 0,\n            \"Must provide valid non-zero _proposalId\"\n        );\n\n        Proposal memory proposal = proposals[_proposalId];\n        return (\n            proposal.proposalId,\n            proposal.proposer,\n            proposal.startBlockNumber,\n            proposal.targetContractRegistryKey,\n            proposal.targetContractAddress,\n            proposal.callValue,\n            proposal.signature,\n            proposal.callData,\n            proposal.outcome,\n            proposal.voteMagnitudeYes,\n            proposal.voteMagnitudeNo,\n            proposal.numVotes\n            /** @notice - votes mapping cannot be returned by external function */\n        );\n    }\n\n    /**\n     * @notice Get how a voter voted for a given proposal\n     * @param _proposalId - id of the proposal\n     * @param _voter - address of the voter we want to check\n     * @return returns a value from the Vote enum if a valid vote, otherwise returns no value\n     */\n    function getVoteByProposalAndVoter(uint256 _proposalId, address _voter)\n    external view returns (Vote vote)\n    {\n        require(\n            _proposalId <= lastProposalId && _proposalId > 0,\n            \"Must provide valid non-zero _proposalId\"\n        );\n        return proposals[_proposalId].votes[_voter];\n    }\n\n    /// @notice Get the contract Guardian address\n    function getGuardianAddress() external view returns (address) {\n        _requireIsInitialized();\n\n        return guardianAddress;\n    }\n\n    /// @notice Get the Staking address\n    function getStakingAddress() external view returns (address) {\n        return stakingAddress;\n    }\n\n    /// @notice Get the contract voting period\n    function getVotingPeriod() external view returns (uint) {\n        _requireIsInitialized();\n\n        return votingPeriod;\n    }\n\n    /// @notice Get the contract voting quorum\n    function getVotingQuorum() external view returns (uint) {\n        _requireIsInitialized();\n\n        return votingQuorum;\n    }\n\n    /// @notice Get the registry address\n    function getRegistryAddress() external view returns (address) {\n        return registryAddress;\n    }\n\n    // ========================================= Internal Functions =========================================\n\n    /**\n     * @notice Execute a transaction attached to a governanace proposal\n     * @dev We are aware of both potential re-entrancy issues and the risks associated with low-level solidity\n     *      function calls here, but have chosen to keep this code with those issues in mind. All governance\n     *      proposals go through a voting process, and all will be reviewed carefully to ensure that they\n     *      adhere to the expected behaviors of this call - but adding restrictions here would limit the ability\n     *      of the governance system to do required work in a generic way.\n     * @param _targetContractAddress - address of registry proxy contract to execute transaction on\n     * @param _callValue - amount of wei if a token transfer is involved\n     * @param _signature - function signature of the function to be executed if proposal is successful\n     * @param _callData - encoded value(s) to call function with if proposal is successful\n     */\n    function _executeTransaction(\n        address _targetContractAddress,\n        uint256 _callValue,\n        string memory _signature,\n        bytes memory _callData\n    ) internal returns (bool /** success */, bytes memory /** returnData */)\n    {\n        bytes memory encodedCallData = abi.encodePacked(\n            bytes4(keccak256(bytes(_signature))),\n            _callData\n        );\n        (bool success, bytes memory returnData) = (\n            // solium-disable-next-line security/no-call-value\n            _targetContractAddress.call.value(_callValue)(encodedCallData)\n        );\n\n        return (success, returnData);\n    }\n}"
    },
    {
      "filename": "eth-contracts/contracts/ServiceProviderFactory.sol",
      "content": "pragma solidity ^0.5.0;\n\nimport \"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\";\nimport \"./ServiceTypeManager.sol\";\nimport \"./ClaimsManager.sol\";\nimport \"./Staking.sol\";\n\n\ncontract ServiceProviderFactory is InitializableV2 {\n    using SafeMath for uint;\n\n    address private stakingAddress;\n    address private delegateManagerAddress;\n    address private governanceAddress;\n    address private serviceTypeManagerAddress;\n    address private claimsManagerAddress;\n    uint private decreaseStakeLockupDuration;\n\n    /// @dev - Stores following entities\n    ///        1) Directly staked amount by SP, not including delegators\n    ///        2) % Cut of delegator tokens taken during reward\n    ///        3) Bool indicating whether this SP has met min/max requirements\n    ///        4) Number of endpoints registered by SP\n    ///        5) Minimum total stake for this account\n    ///        6) Maximum total stake for this account\n    struct ServiceProviderDetails {\n        uint deployerStake;\n        uint deployerCut;\n        bool validBounds;\n        uint numberOfEndpoints;\n        uint minAccountStake;\n        uint maxAccountStake;\n    }\n\n    /// @dev - Data structure for time delay during withdrawal\n    struct DecreaseStakeRequest {\n        uint decreaseAmount;\n        uint lockupExpiryBlock;\n    }\n\n    /// @dev - Mapping of service provider address to details\n    mapping(address => ServiceProviderDetails) spDetails;\n\n    /// @dev - Minimum staked by service provider account deployer\n    /// @dev - Static regardless of total number of endpoints for a given account\n    uint minDeployerStake;\n\n    /// @dev - standard - imitates relationship between Ether and Wei\n    uint8 private constant DECIMALS = 18;\n\n    /// @dev - denominator for deployer cut calculations\n    /// @dev - user values are intended to be x/DEPLOYER_CUT_BASE\n    uint private constant DEPLOYER_CUT_BASE = 100;\n\n    /// @dev - Struct maintaining information about sp\n    /// @dev - blocknumber is block.number when endpoint registered\n    struct ServiceEndpoint {\n        address owner;\n        string endpoint;\n        uint blocknumber;\n        address delegateOwnerWallet;\n    }\n\n    /// @dev - Uniquely assigned serviceProvider ID, incremented for each service type\n    /// @notice - Keeps track of the total number of services registered regardless of\n    ///           whether some have been deregistered since\n    mapping(bytes32 => uint) serviceProviderTypeIDs;\n\n    /// @dev - mapping of (serviceType -> (serviceInstanceId <-> serviceProviderInfo))\n    /// @notice - stores the actual service provider data like endpoint and owner wallet\n    ///           with the ability lookup by service type and service id */\n    mapping(bytes32 => mapping(uint => ServiceEndpoint)) serviceProviderInfo;\n\n    /// @dev - mapping of keccak256(endpoint) to uint ID\n    /// @notice - used to check if a endpoint has already been registered and also lookup\n    /// the id of an endpoint\n    mapping(bytes32 => uint) serviceProviderEndpointToId;\n\n    /// @dev - mapping of address -> sp id array */\n    /// @notice - stores all the services registered by a provider. for each address,\n    /// provides the ability to lookup by service type and see all registered services\n    mapping(address => mapping(bytes32 => uint[])) serviceProviderAddressToId;\n\n    /// @dev - Mapping of service provider -> decrease stake request\n    mapping(address => DecreaseStakeRequest) decreaseStakeRequests;\n\n    event RegisteredServiceProvider(\n      uint _spID,\n      bytes32 _serviceType,\n      address _owner,\n      string _endpoint,\n      uint256 _stakeAmount\n    );\n\n    event DeregisteredServiceProvider(\n      uint _spID,\n      bytes32 _serviceType,\n      address _owner,\n      string _endpoint,\n      uint256 _unstakeAmount\n    );\n\n    event UpdatedStakeAmount(\n      address _owner,\n      uint256 _stakeAmount\n    );\n\n    event UpdateEndpoint(\n      bytes32 _serviceType,\n      address _owner,\n      string _oldEndpoint,\n      string _newEndpoint,\n      uint spId\n    );\n\n    /**\n     * @notice Function to initialize the contract\n     * @param _governanceAddress - Governance proxy address\n     */\n    function initialize (address _governanceAddress) public initializer\n    {\n        governanceAddress = _governanceAddress;\n\n        // Configure direct minimum stake for deployer\n        minDeployerStake = 5 * 10**uint256(DECIMALS);\n\n        // 10 blocks for lockup duration\n        decreaseStakeLockupDuration = 10;\n\n        InitializableV2.initialize();\n    }\n\n    /**\n     * @notice Register a new endpoint to the account of msg.sender\n     * @dev Transfers stake from service provider into staking pool\n     * @param _serviceType - type of service to register, must be valid in ServiceTypeManager\n     * @param _endpoint - url of the service to register - url of the service to register\n     * @param _stakeAmount - amount to stake, must be within bounds in ServiceTypeManager\n     * @param _delegateOwnerWallet - wallet to delegate some permissions for some basic management properties\n     */\n    function register(\n        bytes32 _serviceType,\n        string calldata _endpoint,\n        uint256 _stakeAmount,\n        address _delegateOwnerWallet\n    ) external returns (uint spID)\n    {\n        _requireIsInitialized();\n        require(serviceTypeManagerAddress != address(0x00), \"serviceTypeManagerAddress not set\");\n        require(stakingAddress != address(0x00), \"stakingAddress not set\");\n\n        require(\n            ServiceTypeManager(serviceTypeManagerAddress).serviceTypeIsValid(_serviceType),\n            \"Valid service type required\");\n\n        // Stake token amount from msg.sender\n        if (_stakeAmount > 0) {\n            require(!_claimPending(msg.sender), \"No claim expected to be pending prior to stake transfer\");\n            Staking(stakingAddress).stakeFor(msg.sender, _stakeAmount);\n        }\n\n        require (\n            serviceProviderEndpointToId[keccak256(bytes(_endpoint))] == 0,\n            \"Endpoint already registered\");\n\n        uint newServiceProviderID = serviceProviderTypeIDs[_serviceType].add(1);\n        serviceProviderTypeIDs[_serviceType] = newServiceProviderID;\n\n        // Index spInfo\n        serviceProviderInfo[_serviceType][newServiceProviderID] = ServiceEndpoint({\n            owner: msg.sender,\n            endpoint: _endpoint,\n            blocknumber: block.number,\n            delegateOwnerWallet: _delegateOwnerWallet\n        });\n\n        // Update endpoint mapping\n        serviceProviderEndpointToId[keccak256(bytes(_endpoint))] = newServiceProviderID;\n\n        // Update (address -> type -> ids[])\n        serviceProviderAddressToId[msg.sender][_serviceType].push(newServiceProviderID);\n\n        // Increment number of endpoints for this address\n        spDetails[msg.sender].numberOfEndpoints = spDetails[msg.sender].numberOfEndpoints.add(1);\n\n        // Update deployer total\n        spDetails[msg.sender].deployerStake = (\n            spDetails[msg.sender].deployerStake.add(_stakeAmount)\n        );\n\n        // Update min and max totals for this service provider\n        (uint typeMin, uint typeMax) = ServiceTypeManager(\n            serviceTypeManagerAddress\n        ).getServiceTypeStakeInfo(_serviceType);\n        spDetails[msg.sender].minAccountStake = spDetails[msg.sender].minAccountStake.add(typeMin);\n        spDetails[msg.sender].maxAccountStake = spDetails[msg.sender].maxAccountStake.add(typeMax);\n\n        // Confirm both aggregate account balance and directly staked amount ar"
    }
  ]
}