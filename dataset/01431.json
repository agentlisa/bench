{
  "Title": "The `digest` calculation in `deployProxyAndDistributeBySignature` does not follow EIP-712 specification",
  "Content": "# The `digest` calculation in `deployProxyAndDistributeBySignature` does not follow EIP-712 specification\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-08-sparkn/blob/0f139b2dc53905700dd29a01451b330f829653e9/src/ProxyFactory.sol#L159\">https://github.com/Cyfrin/2023-08-sparkn/blob/0f139b2dc53905700dd29a01451b330f829653e9/src/ProxyFactory.sol#L159</a>\n\n\n## Summary\n\nThe calculation of the `digest` done in [`ProxyFactory.deployProxyAndDistributeBySignature()`](https://github.com/Cyfrin/2023-08-sparkn/blob/0f139b2dc53905700dd29a01451b330f829653e9/src/ProxyFactory.sol#L159) does not follow the [EIP-712 specification](https://eips.ethereum.org/EIPS/eip-712). It is missing the function's corresponding `typeHash`, as well as the `hashStruct` calculation of the `data` signature parameter, which are both defined in the EIP.\n\nNot following the EIP specification will end up in unexpected integration failures with EIP712-compliant wallets or tooling that perform the encoding in the appropriate way.  \n\n## Vulnerability Details\n\nIn [`ProxyFactory.deployProxyAndDistributeBySignature()`](https://github.com/Cyfrin/2023-08-sparkn/blob/0f139b2dc53905700dd29a01451b330f829653e9/src/ProxyFactory.sol#L159), the `digest` is calculated as follows:\n\n```solidity\nbytes32 digest = _hashTypedDataV4(\n    keccak256(\n        abi.encode(contestId, data)\n    )\n);\n```\nThe [EIP-712 specification](https://eips.ethereum.org/EIPS/eip-712#specification) defines the encoding of a message as:\n\n```\n\"\\x19\\x01\" ‖ domainSeparator ‖ hashStruct(message)\n```\nIn the current implementation, `\"\\x19\\x01\"` and `domainSeparator` are correctly calculated and appended as per OpenZeppelin's `_hashTypedDataV4()` function, but `hashStruct(message)` is not respected. \n\nThe EIP defines that the `hashStruct` of a message is calculated from the hashing of the **typeHash** and the encoding of the data; and the former is currently missing in the `digest` calculation.\n\nAdditionally, the `data` parameter which is being included as part of the signature, is a `bytes` type, which the EIP defines as **Dynamic**. Dynamic types [are encoded as the hash of the contents](https://eips.ethereum.org/EIPS/eip-712#definition-of-encodedata); and currently the `data` parameter is being encoded as-is.\n\n## Impact\n\nThe data being signed is not being encoded as per the EIP-712 specification, which will result in unexpected integration failures with EIP712-compliant wallets or tooling that perform the encoding in the appropriate way.\n\nAfter looking at the tests, I would say this error was not caught since the tests themselves follow the same exact implementation for creating the data being signed. Usage of external libraries such as Ethers.js would have likely revealed this issue earlier.\n\n## Tools Used\n\nManual Review\n\n## Recommendations\n\n### Define and use the `typeHash` of the function.\n- Define the `typeHash`\n```solidity\nbytes32 internal constant DEPLOY_AND_DISTRIBUTE_TYPEHASH = keccak256(\n    \"DeployAndDistribute(bytes32 contestId,bytes data)\"\n);\n```\n- Include it in the `digest` calculation\n```solidity\nbytes32 digest = _hashTypedDataV4(\n    keccak256(\n        abi.encode(\n            DEPLOY_AND_DISTRIBUTE_TYPEHASH,\n            contestId,\n            ...\n        )\n    )\n);\n```\n\n### Encode the dynamic `data` parameter as per the EIP-712 specification.\n```solidity\nbytes32 digest = _hashTypedDataV4(\n    keccak256(\n        abi.encode(\n            DEPLOY_AND_DISTRIBUTE_TYPEHASH,\n            contestId,\n            keccak256(data)\n        )\n    )\n);\n```",
  "Impact": "MEDIUM",
  "Source": "https://www.codehawks.com/contests/cllcnja1h0001lc08z7w0orxx",
  "Code": [
    {
      "filename": "src/ProxyFactory.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n// Layout of Contract:\n// version\n// imports\n// errors\n// interfaces, libraries, contracts\n// Type declarations\n// State variables\n// Events\n// Modifiers\n// Functions\n\n// Layout of Functions:\n// constructor\n// receive function (if exists)\n// fallback function (if exists)\n// external\n// public\n// internal\n// private\n// view & pure functions\n\npragma solidity 0.8.18;\n\nimport {Ownable} from \"openzeppelin/access/Ownable.sol\";\nimport {ECDSA} from \"openzeppelin/utils/cryptography/ECDSA.sol\";\nimport {EIP712} from \"openzeppelin/utils/cryptography/EIP712.sol\";\nimport {Proxy} from \"./Proxy.sol\";\n\n/**\n * @title ProxyFactory contract\n * @notice This contract is the main entry point for users to use SPARKN's contracts.\n * @notice It will be used to deploy proxy contracts for every contest in SPARKN.\n * @dev This contract is the factory contract which will be used to deploy proxy contracts.\n */\ncontract ProxyFactory is Ownable, EIP712 {\n    //////////////////////\n    /////// Error ////////\n    //////////////////////\n    error ProxyFactory__NoEmptyArray();\n    error ProxyFactory__NoZeroAddress();\n    error ProxyFactory__CloseTimeNotInRange();\n    error ProxyFactory__InvalidSignature();\n    error ProxyFactory__ContestIsAlreadyRegistered();\n    error ProxyFactory__ContestIsNotClosed();\n    error ProxyFactory__ContestIsNotRegistered();\n    error ProxyFactory__ContestIsNotExpired();\n    error ProxyFactory__DelegateCallFailed();\n    error ProxyFactory__ProxyAddressCannotBeZero();\n\n    /////////////////////\n    /////// Event ///////\n    /////////////////////\n    event SetContest(\n        address indexed organizer, bytes32 indexed contestId, uint256 closeTime, address indexed implementation\n    );\n    event Distributed(address indexed proxy, bytes data);\n\n    ////////////////////////////////\n    /////// State Variables ////////\n    ////////////////////////////////\n    // contest distribution expiration\n    uint256 public constant EXPIRATION_TIME = 7 days;\n    uint256 public constant MAX_CONTEST_PERIOD = 28 days;\n\n    /// @notice record contest close time by salt\n    /// @dev The contest doesn't exist when value is 0\n    mapping(bytes32 => uint256) public saltToCloseTime;\n    /// @dev record whitelisted tokens\n    mapping(address => bool) public whitelistedTokens;\n\n    ////////////////////////////\n    /////// Constructor ////////\n    ////////////////////////////\n    /**\n     * @notice The constructor will set the whitelist tokens. e.g. USDC, JPYCv1, JPYCv2, USDT, DAI\n     * @notice the array is not supposed to be so long because only major tokens will get listed\n     * @param _whitelistedTokens The tokens array to get whitelisted\n     */\n    constructor(address[] memory _whitelistedTokens) EIP712(\"ProxyFactory\", \"1\") Ownable() {\n        if (_whitelistedTokens.length == 0) revert ProxyFactory__NoEmptyArray();\n        for (uint256 i; i < _whitelistedTokens.length;) {\n            if (_whitelistedTokens[i] == address(0)) revert ProxyFactory__NoZeroAddress();\n            whitelistedTokens[_whitelistedTokens[i]] = true;\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    ////////////////////////////////////////////\n    /////// External & Public functions ////////\n    ////////////////////////////////////////////\n    /**\n     * @notice Only owner can set contest's properties\n     * @notice close time must be less than 28 days from now\n     * @dev Set contest close time, implementation address, organizer, contest id\n     * @dev only owner can call this function\n     * @param organizer The owner of the contest\n     * @param contestId The contest id\n     * @param closeTime The contest close time\n     * @param implementation The implementation address\n     */\n    function setContest(address organizer, bytes32 contestId, uint256 closeTime, address implementation)\n        public\n        onlyOwner\n    {\n        if (organizer == address(0) || implementation == address(0)) revert ProxyFactory__NoZeroAddress();\n        if (closeTime > block.timestamp + MAX_CONTEST_PERIOD || closeTime < block.timestamp) {\n            revert ProxyFactory__CloseTimeNotInRange();\n        }\n        bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n        if (saltToCloseTime[salt] != 0) revert ProxyFactory__ContestIsAlreadyRegistered();\n        saltToCloseTime[salt] = closeTime;\n        emit SetContest(organizer, contestId, closeTime, implementation);\n    }\n\n    /**\n     * @notice deploy proxy contract and distribute winner's prize\n     * @dev the caller can only control his own contest\n     * @param contestId The contest id\n     * @param implementation The implementation address\n     * @param data The prize distribution data\n     * @return The proxy address\n     */\n    function deployProxyAndDistribute(bytes32 contestId, address implementation, bytes calldata data)\n        public\n        returns (address)\n    {\n        bytes32 salt = _calculateSalt(msg.sender, contestId, implementation);\n        if (saltToCloseTime[salt] == 0) revert ProxyFactory__ContestIsNotRegistered();\n        // can set close time to current time and end it immediately if organizer wish\n        if (saltToCloseTime[salt] > block.timestamp) revert ProxyFactory__ContestIsNotClosed();\n        address proxy = _deployProxy(msg.sender, contestId, implementation);\n        _distribute(proxy, data);\n        return proxy;\n    }\n\n    /**\n     * @notice deploy proxy contract and distribute prize on behalf of organizer\n     * @dev the caller can only control his own contest\n     * @dev It uess EIP712 to verify the signature to avoid replay attacks\n     * @dev front run is allowed because it will only help the tx sender\n     * @param organizer The organizer of the contest\n     * @param contestId The contest id\n     * @param implementation The implementation address\n     * @param signature The signature from organizer\n     * @param data The prize distribution data\n     * @return proxy The proxy address\n     */\n    function deployProxyAndDistributeBySignature(\n        address organizer,\n        bytes32 contestId,\n        address implementation,\n        bytes calldata signature,\n        bytes calldata data\n    ) public returns (address) {\n        bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(contestId, data)));\n        if (ECDSA.recover(digest, signature) != organizer) revert ProxyFactory__InvalidSignature();\n        bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n        if (saltToCloseTime[salt] == 0) revert ProxyFactory__ContestIsNotRegistered();\n        if (saltToCloseTime[salt] > block.timestamp) revert ProxyFactory__ContestIsNotClosed();\n        address proxy = _deployProxy(organizer, contestId, implementation);\n        _distribute(proxy, data);\n        return proxy;\n    }\n\n    /**\n     * @notice deploy proxy contract and distribute prize on behalf of organizer by owner\n     * @notice This can only be called after contest is expired\n     * @dev the caller must be owner\n     * @param organizer The organizer of the contest\n     * @param contestId The contest id\n     * @param implementation The implementation address\n     * @param data The prize distribution data\n     * @return proxy The proxy address\n     */\n    function deployProxyAndDistributeByOwner(\n        address organizer,\n        bytes32 contestId,\n        address implementation,\n        bytes calldata data\n    ) public onlyOwner returns (address) {\n        bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n        if (saltToCloseTime[salt] == 0) revert ProxyFactory__ContestIsNotRegistered();\n        if (saltToCloseTime[salt] + EXPIRATION_TIME > block.timestamp) revert ProxyFactory__ContestIsNotExpired();\n        // require(saltToCloseTime[salt] == 0, \"Contest is not registered\");\n        // require(saltToCloseTime[salt] < block.timestamp + EXPIRATION_TIME, \"Contest is not expired\");\n        address proxy = _deployProxy(organizer, contestId, implementation);\n        _distribute(proxy, data);\n        return proxy;\n    }\n\n    /**\n     * @notice Owner can rescue funds if token is stuck after the deployment and contest is over for a while\n     * @dev only owner can call this function and it is supposed not to be called often\n     * @dev fee sent to stadium address is included in the logic contract\n     * @param proxy The proxy address\n     * @param organizer The contest organizer\n     * @param contestId The contest id\n     * @param implementation The implementation address\n     * @param data The prize distribution calling data\n     */\n    function distributeByOwner(\n        address proxy,\n        address organizer,\n        bytes32 contestId,\n        address implementation,\n        bytes calldata data\n    ) public onlyOwner {\n        if (proxy == address(0)) revert ProxyFactory__ProxyAddressCannotBeZero();\n        bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n        if (saltToCloseTime[salt] == 0) revert ProxyFactory__ContestIsNotRegistered();\n        // distribute only when it exists and expired\n        if (saltToCloseTime[salt] + EXPIRATION_TIME > block.timestamp) revert ProxyFactory__ContestIsNotExpired();\n        _distribute(proxy, data);\n    }\n\n    /// @notice This address can be used to send ERC20 tokens before deployment of proxy\n    /// @dev Calculate the proxy address using salt and implementation address\n    /// @param salt The salt\n    /// @param implementation The implementation address\n    /// @return proxy The calculated proxy address\n    function getProxyAddress(bytes32 salt, address implementation) public view returns (address proxy) {\n        bytes memory code = abi.encodePacked(type(Proxy).creationCode, uint256(uint160(implementation)));\n        bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), salt, keccak256(code)));\n        proxy = address(uint160(uint256(hash)));\n    }\n\n    ///////////////////////////////////\n    /////// Internal functions ////////\n    ///////////////////////////////////\n    /// @dev Deploy proxy and return the proxy address\n    /// @dev This is an internal function\n    /// @param organizer The contest organizer\n    /// @param contestId The contest id\n    /// @param implementation The implementation address\n    function _deployProxy(address organizer, bytes32 contestId, address implementation) internal returns (address) {\n        bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n        address proxy = address(new Proxy{salt: salt}(implementation));\n        return proxy;\n    }\n\n    /// @dev The internal function to be used to call proxy to distribute prizes to the winners\n    /// @dev the data passed in should be the calling data of the distributing logic\n    /// @param proxy The proxy address\n    /// @param data The prize distribution data\n    function _distribute(address proxy, bytes calldata data) internal {\n        (bool success,) = proxy.call(data);\n        if (!success) revert ProxyFactory__DelegateCallFailed();\n        emit Distributed(proxy, data);\n    }\n\n    /// @dev Calculate salt using contest organizer address and contestId, implementation address\n    /// @dev This is an internal function\n    /// @param organizer The contest organizer\n    /// @param contestId The contest id\n    /// @param implementation The implementation address\n    function _calculateSalt(address organizer, bytes32 contestId, address implementation)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encode(organizer, contestId, implementation));\n    }\n}"
    },
    {
      "filename": "src/ProxyFactory.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n// Layout of Contract:\n// version\n// imports\n// errors\n// interfaces, libraries, contracts\n// Type declarations\n// State variables\n// Events\n// Modifiers\n// Functions\n\n// Layout of Functions:\n// constructor\n// receive function (if exists)\n// fallback function (if exists)\n// external\n// public\n// internal\n// private\n// view & pure functions\n\npragma solidity 0.8.18;\n\nimport {Ownable} from \"openzeppelin/access/Ownable.sol\";\nimport {ECDSA} from \"openzeppelin/utils/cryptography/ECDSA.sol\";\nimport {EIP712} from \"openzeppelin/utils/cryptography/EIP712.sol\";\nimport {Proxy} from \"./Proxy.sol\";\n\n/**\n * @title ProxyFactory contract\n * @notice This contract is the main entry point for users to use SPARKN's contracts.\n * @notice It will be used to deploy proxy contracts for every contest in SPARKN.\n * @dev This contract is the factory contract which will be used to deploy proxy contracts.\n */\ncontract ProxyFactory is Ownable, EIP712 {\n    //////////////////////\n    /////// Error ////////\n    //////////////////////\n    error ProxyFactory__NoEmptyArray();\n    error ProxyFactory__NoZeroAddress();\n    error ProxyFactory__CloseTimeNotInRange();\n    error ProxyFactory__InvalidSignature();\n    error ProxyFactory__ContestIsAlreadyRegistered();\n    error ProxyFactory__ContestIsNotClosed();\n    error ProxyFactory__ContestIsNotRegistered();\n    error ProxyFactory__ContestIsNotExpired();\n    error ProxyFactory__DelegateCallFailed();\n    error ProxyFactory__ProxyAddressCannotBeZero();\n\n    /////////////////////\n    /////// Event ///////\n    /////////////////////\n    event SetContest(\n        address indexed organizer, bytes32 indexed contestId, uint256 closeTime, address indexed implementation\n    );\n    event Distributed(address indexed proxy, bytes data);\n\n    ////////////////////////////////\n    /////// State Variables ////////\n    ////////////////////////////////\n    // contest distribution expiration\n    uint256 public constant EXPIRATION_TIME = 7 days;\n    uint256 public constant MAX_CONTEST_PERIOD = 28 days;\n\n    /// @notice record contest close time by salt\n    /// @dev The contest doesn't exist when value is 0\n    mapping(bytes32 => uint256) public saltToCloseTime;\n    /// @dev record whitelisted tokens\n    mapping(address => bool) public whitelistedTokens;\n\n    ////////////////////////////\n    /////// Constructor ////////\n    ////////////////////////////\n    /**\n     * @notice The constructor will set the whitelist tokens. e.g. USDC, JPYCv1, JPYCv2, USDT, DAI\n     * @notice the array is not supposed to be so long because only major tokens will get listed\n     * @param _whitelistedTokens The tokens array to get whitelisted\n     */\n    constructor(address[] memory _whitelistedTokens) EIP712(\"ProxyFactory\", \"1\") Ownable() {\n        if (_whitelistedTokens.length == 0) revert ProxyFactory__NoEmptyArray();\n        for (uint256 i; i < _whitelistedTokens.length;) {\n            if (_whitelistedTokens[i] == address(0)) revert ProxyFactory__NoZeroAddress();\n            whitelistedTokens[_whitelistedTokens[i]] = true;\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    ////////////////////////////////////////////\n    /////// External & Public functions ////////\n    ////////////////////////////////////////////\n    /**\n     * @notice Only owner can set contest's properties\n     * @notice close time must be less than 28 days from now\n     * @dev Set contest close time, implementation address, organizer, contest id\n     * @dev only owner can call this function\n     * @param organizer The owner of the contest\n     * @param contestId The contest id\n     * @param closeTime The contest close time\n     * @param implementation The implementation address\n     */\n    function setContest(address organizer, bytes32 contestId, uint256 closeTime, address implementation)\n        public\n        onlyOwner\n    {\n        if (organizer == address(0) || implementation == address(0)) revert ProxyFactory__NoZeroAddress();\n        if (closeTime > block.timestamp + MAX_CONTEST_PERIOD || closeTime < block.timestamp) {\n            revert ProxyFactory__CloseTimeNotInRange();\n        }\n        bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n        if (saltToCloseTime[salt] != 0) revert ProxyFactory__ContestIsAlreadyRegistered();\n        saltToCloseTime[salt] = closeTime;\n        emit SetContest(organizer, contestId, closeTime, implementation);\n    }\n\n    /**\n     * @notice deploy proxy contract and distribute winner's prize\n     * @dev the caller can only control his own contest\n     * @param contestId The contest id\n     * @param implementation The implementation address\n     * @param data The prize distribution data\n     * @return The proxy address\n     */\n    function deployProxyAndDistribute(bytes32 contestId, address implementation, bytes calldata data)\n        public\n        returns (address)\n    {\n        bytes32 salt = _calculateSalt(msg.sender, contestId, implementation);\n        if (saltToCloseTime[salt] == 0) revert ProxyFactory__ContestIsNotRegistered();\n        // can set close time to current time and end it immediately if organizer wish\n        if (saltToCloseTime[salt] > block.timestamp) revert ProxyFactory__ContestIsNotClosed();\n        address proxy = _deployProxy(msg.sender, contestId, implementation);\n        _distribute(proxy, data);\n        return proxy;\n    }\n\n    /**\n     * @notice deploy proxy contract and distribute prize on behalf of organizer\n     * @dev the caller can only control his own contest\n     * @dev It uess EIP712 to verify the signature to avoid replay attacks\n     * @dev front run is allowed because it will only help the tx sender\n     * @param organizer The organizer of the contest\n     * @param contestId The contest id\n     * @param implementation The implementation address\n     * @param signature The signature from organizer\n     * @param data The prize distribution data\n     * @return proxy The proxy address\n     */\n    function deployProxyAndDistributeBySignature(\n        address organizer,\n        bytes32 contestId,\n        address implementation,\n        bytes calldata signature,\n        bytes calldata data\n    ) public returns (address) {\n        bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(contestId, data)));\n        if (ECDSA.recover(digest, signature) != organizer) revert ProxyFactory__InvalidSignature();\n        bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n        if (saltToCloseTime[salt] == 0) revert ProxyFactory__ContestIsNotRegistered();\n        if (saltToCloseTime[salt] > block.timestamp) revert ProxyFactory__ContestIsNotClosed();\n        address proxy = _deployProxy(organizer, contestId, implementation);\n        _distribute(proxy, data);\n        return proxy;\n    }\n\n    /**\n     * @notice deploy proxy contract and distribute prize on behalf of organizer by owner\n     * @notice This can only be called after contest is expired\n     * @dev the caller must be owner\n     * @param organizer The organizer of the contest\n     * @param contestId The contest id\n     * @param implementation The implementation address\n     * @param data The prize distribution data\n     * @return proxy The proxy address\n     */\n    function deployProxyAndDistributeByOwner(\n        address organizer,\n        bytes32 contestId,\n        address implementation,\n        bytes calldata data\n    ) public onlyOwner returns (address) {\n        bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n        if (saltToCloseTime[salt] == 0) revert ProxyFactory__ContestIsNotRegistered();\n        if (saltToCloseTime[salt] + EXPIRATION_TIME > block.timestamp) revert ProxyFactory__ContestIsNotExpired();\n        // require(saltToCloseTime[salt] == 0, \"Contest is not registered\");\n        // require(saltToCloseTime[salt] < block.timestamp + EXPIRATION_TIME, \"Contest is not expired\");\n        address proxy = _deployProxy(organizer, contestId, implementation);\n        _distribute(proxy, data);\n        return proxy;\n    }\n\n    /**\n     * @notice Owner can rescue funds if token is stuck after the deployment and contest is over for a while\n     * @dev only owner can call this function and it is supposed not to be called often\n     * @dev fee sent to stadium address is included in the logic contract\n     * @param proxy The proxy address\n     * @param organizer The contest organizer\n     * @param contestId The contest id\n     * @param implementation The implementation address\n     * @param data The prize distribution calling data\n     */\n    function distributeByOwner(\n        address proxy,\n        address organizer,\n        bytes32 contestId,\n        address implementation,\n        bytes calldata data\n    ) public onlyOwner {\n        if (proxy == address(0)) revert ProxyFactory__ProxyAddressCannotBeZero();\n        bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n        if (saltToCloseTime[salt] == 0) revert ProxyFactory__ContestIsNotRegistered();\n        // distribute only when it exists and expired\n        if (saltToCloseTime[salt] + EXPIRATION_TIME > block.timestamp) revert ProxyFactory__ContestIsNotExpired();\n        _distribute(proxy, data);\n    }\n\n    /// @notice This address can be used to send ERC20 tokens before deployment of proxy\n    /// @dev Calculate the proxy address using salt and implementation address\n    /// @param salt The salt\n    /// @param implementation The implementation address\n    /// @return proxy The calculated proxy address\n    function getProxyAddress(bytes32 salt, address implementation) public view returns (address proxy) {\n        bytes memory code = abi.encodePacked(type(Proxy).creationCode, uint256(uint160(implementation)));\n        bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), salt, keccak256(code)));\n        proxy = address(uint160(uint256(hash)));\n    }\n\n    ///////////////////////////////////\n    /////// Internal functions ////////\n    ///////////////////////////////////\n    /// @dev Deploy proxy and return the proxy address\n    /// @dev This is an internal function\n    /// @param organizer The contest organizer\n    /// @param contestId The contest id\n    /// @param implementation The implementation address\n    function _deployProxy(address organizer, bytes32 contestId, address implementation) internal returns (address) {\n        bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n        address proxy = address(new Proxy{salt: salt}(implementation));\n        return proxy;\n    }\n\n    /// @dev The internal function to be used to call proxy to distribute prizes to the winners\n    /// @dev the data passed in should be the calling data of the distributing logic\n    /// @param proxy The proxy address\n    /// @param data The prize distribution data\n    function _distribute(address proxy, bytes calldata data) internal {\n        (bool success,) = proxy.call(data);\n        if (!success) revert ProxyFactory__DelegateCallFailed();\n        emit Distributed(proxy, data);\n    }\n\n    /// @dev Calculate salt using contest organizer address and contestId, implementation address\n    /// @dev This is an internal function\n    /// @param organizer The contest organizer\n    /// @param contestId The contest id\n    /// @param implementation The implementation address\n    function _calculateSalt(address organizer, bytes32 contestId, address implementation)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encode(organizer, contestId, implementation));\n    }\n}"
    },
    {
      "filename": "src/ProxyFactory.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n// Layout of Contract:\n// version\n// imports\n// errors\n// interfaces, libraries, contracts\n// Type declarations\n// State variables\n// Events\n// Modifiers\n// Functions\n\n// Layout of Functions:\n// constructor\n// receive function (if exists)\n// fallback function (if exists)\n// external\n// public\n// internal\n// private\n// view & pure functions\n\npragma solidity 0.8.18;\n\nimport {Ownable} from \"openzeppelin/access/Ownable.sol\";\nimport {ECDSA} from \"openzeppelin/utils/cryptography/ECDSA.sol\";\nimport {EIP712} from \"openzeppelin/utils/cryptography/EIP712.sol\";\nimport {Proxy} from \"./Proxy.sol\";\n\n/**\n * @title ProxyFactory contract\n * @notice This contract is the main entry point for users to use SPARKN's contracts.\n * @notice It will be used to deploy proxy contracts for every contest in SPARKN.\n * @dev This contract is the factory contract which will be used to deploy proxy contracts.\n */\ncontract ProxyFactory is Ownable, EIP712 {\n    //////////////////////\n    /////// Error ////////\n    //////////////////////\n    error ProxyFactory__NoEmptyArray();\n    error ProxyFactory__NoZeroAddress();\n    error ProxyFactory__CloseTimeNotInRange();\n    error ProxyFactory__InvalidSignature();\n    error ProxyFactory__ContestIsAlreadyRegistered();\n    error ProxyFactory__ContestIsNotClosed();\n    error ProxyFactory__ContestIsNotRegistered();\n    error ProxyFactory__ContestIsNotExpired();\n    error ProxyFactory__DelegateCallFailed();\n    error ProxyFactory__ProxyAddressCannotBeZero();\n\n    /////////////////////\n    /////// Event ///////\n    /////////////////////\n    event SetContest(\n        address indexed organizer, bytes32 indexed contestId, uint256 closeTime, address indexed implementation\n    );\n    event Distributed(address indexed proxy, bytes data);\n\n    ////////////////////////////////\n    /////// State Variables ////////\n    ////////////////////////////////\n    // contest distribution expiration\n    uint256 public constant EXPIRATION_TIME = 7 days;\n    uint256 public constant MAX_CONTEST_PERIOD = 28 days;\n\n    /// @notice record contest close time by salt\n    /// @dev The contest doesn't exist when value is 0\n    mapping(bytes32 => uint256) public saltToCloseTime;\n    /// @dev record whitelisted tokens\n    mapping(address => bool) public whitelistedTokens;\n\n    ////////////////////////////\n    /////// Constructor ////////\n    ////////////////////////////\n    /**\n     * @notice The constructor will set the whitelist tokens. e.g. USDC, JPYCv1, JPYCv2, USDT, DAI\n     * @notice the array is not supposed to be so long because only major tokens will get listed\n     * @param _whitelistedTokens The tokens array to get whitelisted\n     */\n    constructor(address[] memory _whitelistedTokens) EIP712(\"ProxyFactory\", \"1\") Ownable() {\n        if (_whitelistedTokens.length == 0) revert ProxyFactory__NoEmptyArray();\n        for (uint256 i; i < _whitelistedTokens.length;) {\n            if (_whitelistedTokens[i] == address(0)) revert ProxyFactory__NoZeroAddress();\n            whitelistedTokens[_whitelistedTokens[i]] = true;\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    ////////////////////////////////////////////\n    /////// External & Public functions ////////\n    ////////////////////////////////////////////\n    /**\n     * @notice Only owner can set contest's properties\n     * @notice close time must be less than 28 days from now\n     * @dev Set contest close time, implementation address, organizer, contest id\n     * @dev only owner can call this function\n     * @param organizer The owner of the contest\n     * @param contestId The contest id\n     * @param closeTime The contest close time\n     * @param implementation The implementation address\n     */\n    function setContest(address organizer, bytes32 contestId, uint256 closeTime, address implementation)\n        public\n        onlyOwner\n    {\n        if (organizer == address(0) || implementation == address(0)) revert ProxyFactory__NoZeroAddress();\n        if (closeTime > block.timestamp + MAX_CONTEST_PERIOD || closeTime < block.timestamp) {\n            revert ProxyFactory__CloseTimeNotInRange();\n        }\n        bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n        if (saltToCloseTime[salt] != 0) revert ProxyFactory__ContestIsAlreadyRegistered();\n        saltToCloseTime[salt] = closeTime;\n        emit SetContest(organizer, contestId, closeTime, implementation);\n    }\n\n    /**\n     * @notice deploy proxy contract and distribute winner's prize\n     * @dev the caller can only control his own contest\n     * @param contestId The contest id\n     * @param implementation The implementation address\n     * @param data The prize distribution data\n     * @return The proxy address\n     */\n    function deployProxyAndDistribute(bytes32 contestId, address implementation, bytes calldata data)\n        public\n        returns (address)\n    {\n        bytes32 salt = _calculateSalt(msg.sender, contestId, implementation);\n        if (saltToCloseTime[salt] == 0) revert ProxyFactory__ContestIsNotRegistered();\n        // can set close time to current time and end it immediately if organizer wish\n        if (saltToCloseTime[salt] > block.timestamp) revert ProxyFactory__ContestIsNotClosed();\n        address proxy = _deployProxy(msg.sender, contestId, implementation);\n        _distribute(proxy, data);\n        return proxy;\n    }\n\n    /**\n     * @notice deploy proxy contract and distribute prize on behalf of organizer\n     * @dev the caller can only control his own contest\n     * @dev It uess EIP712 to verify the signature to avoid replay attacks\n     * @dev front run is allowed because it will only help the tx sender\n     * @param organizer The organizer of the contest\n     * @param contestId The contest id\n     * @param implementation The implementation address\n     * @param signature The signature from organizer\n     * @param data The prize distribution data\n     * @return proxy The proxy address\n     */\n    function deployProxyAndDistributeBySignature(\n        address organizer,\n        bytes32 contestId,\n        address implementation,\n        bytes calldata signature,\n        bytes calldata data\n    ) public returns (address) {\n        bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(contestId, data)));\n        if (ECDSA.recover(digest, signature) != organizer) revert ProxyFactory__InvalidSignature();\n        bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n        if (saltToCloseTime[salt] == 0) revert ProxyFactory__ContestIsNotRegistered();\n        if (saltToCloseTime[salt] > block.timestamp) revert ProxyFactory__ContestIsNotClosed();\n        address proxy = _deployProxy(organizer, contestId, implementation);\n        _distribute(proxy, data);\n        return proxy;\n    }\n\n    /**\n     * @notice deploy proxy contract and distribute prize on behalf of organizer by owner\n     * @notice This can only be called after contest is expired\n     * @dev the caller must be owner\n     * @param organizer The organizer of the contest\n     * @param contestId The contest id\n     * @param implementation The implementation address\n     * @param data The prize distribution data\n     * @return proxy The proxy address\n     */\n    function deployProxyAndDistributeByOwner(\n        address organizer,\n        bytes32 contestId,\n        address implementation,\n        bytes calldata data\n    ) public onlyOwner returns (address) {\n        bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n        if (saltToCloseTime[salt] == 0) revert ProxyFactory__ContestIsNotRegistered();\n        if (saltToCloseTime[salt] + EXPIRATION_TIME > block.timestamp) revert ProxyFactory__ContestIsNotExpired();\n        // require(saltToCloseTime[salt] == 0, \"Contest is not registered\");\n        // require(saltToCloseTime[salt] < block.timestamp + EXPIRATION_TIME, \"Contest is not expired\");\n        address proxy = _deployProxy(organizer, contestId, implementation);\n        _distribute(proxy, data);\n        return proxy;\n    }\n\n    /**\n     * @notice Owner can rescue funds if token is stuck after the deployment and contest is over for a while\n     * @dev only owner can call this function and it is supposed not to be called often\n     * @dev fee sent to stadium address is included in the logic contract\n     * @param proxy The proxy address\n     * @param organizer The contest organizer\n     * @param contestId The contest id\n     * @param implementation The implementation address\n     * @param data The prize distribution calling data\n     */\n    function distributeByOwner(\n        address proxy,\n        address organizer,\n        bytes32 contestId,\n        address implementation,\n        bytes calldata data\n    ) public onlyOwner {\n        if (proxy == address(0)) revert ProxyFactory__ProxyAddressCannotBeZero();\n        bytes32 salt = _calculateSalt(organizer, contestId, implementation);\n        if (saltToCloseTime[salt] == 0) revert ProxyFactory__ContestIsNotRegistered();\n        // distribute only when it exists and expired\n        if (saltToCloseTime[salt] + EXPIRATION_TIME > block.timestamp) revert ProxyFactory__ContestIsNotExpired();\n        _distribute(proxy, data);\n    }\n\n    /// @notice This address can be used to send ERC20 tokens before deployment of proxy\n    /// @dev Calculate the proxy address using salt and implementation address\n    /// @param salt The salt\n    /// @param implementation The implementation address\n    /// @return proxy The calculated proxy a"
    }
  ]
}