{
  "Title": "[G-05] Redundant state variable getters",
  "Content": "\nGetters for public state variables are automatically generated by the solidity compiler so there is no need to code them manually as this increases deployment cost.\n\n**Instance 1:**\n\nMake `positionLendTokenData` mapping variable `private` or `internal` since a getter function was defined for it.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLendingDeclaration.sol#L270\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/WiseLowLevelHelper.sol#L144-#L153\n\nThe solidity compiler would automatically create a getter function for the `positionLendTokenData` mapping since it is declared as a `public` variable but a getter function `getPositionLendingTokenByIndex()` was also declared in the `WiseLowLevelHelper` contract for the same variable; thereby, making it two getter functions for the same variable in the contract. We could rectify this issue by making the `positionLendTokenData` variable private or internal (if the variable is to be inherited). The diff below shows how the code could be refactored:\n\n```solidity\nfile: contracts/WiseLendingDeclaration.sol\n\n270:    mapping(uint256 => address[]) public positionLendTokenData;\n\nfile: contracts/WiseLowLevelHelper.sol\n\n144:    function getPositionLendingTokenByIndex(\n145:        uint256 _nftId,\n146:        uint256 _index\n147:    )\n148:        public\n149:        view\n150:        returns (address)\n151:    {\n152:        return positionLendTokenData[_nftId][_index];\n153:    }\n```\n\n```diff\ndiff --git a/contracts/WiseLendingDeclaration.sol b/contracts/WiseLendingDeclaration.sol\nindex 05a0e01..d1ba624 100644\n--- a/contracts/WiseLendingDeclaration.sol\n+++ b/contracts/WiseLendingDeclaration.sol\n@@ -267,7 +267,7 @@ contract WiseLendingDeclaration is\n     mapping(address => uint256) internal bufferIncrease;\n     mapping(address => uint256) public maxDepositValueToken;\n\n-    mapping(uint256 => address[]) public positionLendTokenData;\n+    mapping(uint256 => address[]) internal positionLendTokenData;\n     mapping(uint256 => address[]) public positionBorrowTokenData;\n\n     mapping(uint256 => mapping(address => uint256)) public userBorrowShares;\n```\n\n**Instance 2:**\n\nMake `poolTokenAddresses` array variable `private` or `internal` since a getter function was defined for it.\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/DeclarationsFeeManager.sol#L123\n\nhttps://github.com/code-423n4/2024-02-wise-lending/blob/main/contracts/FeeManager/FeeManager.sol#L884-#L892\n\nThe solidity compiler would automatically create a getter function for the `poolTokenAddresses` array since it is declared as a `public` variable but a getter function `getPoolTokenAdressesByIndex()` was also declared in the `FeeManager` contract for the same variable thereby making it two getter functions for the same variable in the contract. We could rectify this issue by making the `poolTokenAddresses` variable private or internal (if the variable is to be inherited). The diff below shows how the code could be refactored:\n\n```solidity\nfile: contracts/FeeManager/DeclarationsFeeManager.sol\n\n123:    address[] public poolTokenAddresses;\n\nfile: contracts/FeeManager/FeeManager.sol\n\n884:    function getPoolTokenAdressesByIndex(\n885:        uint256 _index\n886:    )\n887:        external\n888:        view\n889:        returns (address)\n890:    {\n891:        return poolTokenAddresses[_index];\n892:    }\n```\n\n```diff\ndiff --git a/contracts/FeeManager/DeclarationsFeeManager.sol b/contracts/FeeManager/DeclarationsFeeManager.sol\nindex ba7eed7..e10f9be 100644\n--- a/contracts/FeeManager/DeclarationsFeeManager.sol\n+++ b/contracts/FeeManager/DeclarationsFeeManager.sol\n@@ -120,7 +120,7 @@ contract DeclarationsFeeManager is FeeManagerEvents, OwnableMaster {\n     uint256 public paybackIncentive;\n\n     // Array of pool tokens in wiseLending\n-    address[] public poolTokenAddresses;\n+    address[] internal poolTokenAddresses;\n\n     // Address of incentive master\n     address public incentiveMaster;\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2024-02-wise-lending",
  "Code": [
    {
      "filename": "contracts/WiseLendingDeclaration.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\nimport \"./OwnableMaster.sol\";\n\nimport \"./InterfaceHub/IAaveHubLite.sol\";\nimport \"./InterfaceHub/IPositionNFTs.sol\";\nimport \"./InterfaceHub/IWiseSecurity.sol\";\nimport \"./InterfaceHub/IWiseOracleHub.sol\";\nimport \"./InterfaceHub/IFeeManagerLight.sol\";\n\nimport \"./TransferHub/WrapperHelper.sol\";\nimport \"./TransferHub/SendValueHelper.sol\";\n\nerror DeadOracle();\nerror NotPowerFarm();\nerror InvalidAction();\nerror InvalidCaller();\nerror PositionLocked();\nerror LiquidatorIsInPowerFarm();\nerror PositionHasCollateral();\nerror PositionHasBorrow();\nerror InvalidAddress();\nerror InvalidLiquidator();\nerror ValueIsZero();\nerror ValueNotZero();\nerror TooManyTokens();\n\ncontract WiseLendingDeclaration is\n    OwnableMaster,\n    WrapperHelper,\n    SendValueHelper\n{\n    event FundsDeposited(\n        address indexed sender,\n        uint256 indexed nftId,\n        address indexed token,\n        uint256 amount,\n        uint256 shares,\n        uint256 timestamp\n    );\n\n    event FundsSolelyDeposited(\n        address indexed sender,\n        uint256 indexed nftId,\n        address indexed token,\n        uint256 amount,\n        uint256 timestamp\n    );\n\n    event FundsWithdrawn(\n        address indexed sender,\n        uint256 indexed nftId,\n        address indexed token,\n        uint256 amount,\n        uint256 shares,\n        uint256 timestamp\n    );\n\n    event FundsWithdrawnOnBehalf(\n        address indexed sender,\n        uint256 indexed nftId,\n        address indexed token,\n        uint256 amount,\n        uint256 shares,\n        uint256 timestamp\n    );\n\n    event FundsSolelyWithdrawn(\n        address indexed sender,\n        uint256 indexed nftId,\n        address indexed token,\n        uint256 amount,\n        uint256 timestamp\n    );\n\n    event FundsBorrowed(\n        address indexed borrower,\n        uint256 indexed nftId,\n        address indexed token,\n        uint256 amount,\n        uint256 shares,\n        uint256 timestamp\n    );\n\n    event FundsBorrowedOnBehalf(\n        address indexed sender,\n        uint256 indexed nftId,\n        address indexed token,\n        uint256 amount,\n        uint256 shares,\n        uint256 timestamp\n    );\n\n    event FundsReturned(\n        address indexed sender,\n        address indexed token,\n        uint256 indexed nftId,\n        uint256 totalPayment,\n        uint256 totalPaymentShares,\n        uint256 timestamp\n    );\n\n    constructor(\n        address _master,\n        address _wiseOracleHub,\n        address _nftContract\n    )\n        OwnableMaster(\n            _master\n        )\n        WrapperHelper(\n            IWiseOracleHub(\n                _wiseOracleHub\n            ).WETH_ADDRESS()\n        )\n    {\n        if (_wiseOracleHub == ZERO_ADDRESS) {\n            revert NoValue();\n        }\n\n        if (_nftContract == ZERO_ADDRESS) {\n            revert NoValue();\n        }\n\n        WISE_ORACLE = IWiseOracleHub(\n            _wiseOracleHub\n        );\n\n        WETH_ADDRESS = WISE_ORACLE.WETH_ADDRESS();\n\n        POSITION_NFT = IPositionNFTs(\n            _nftContract\n        );\n\n        FEE_MANAGER_NFT = POSITION_NFT.FEE_MANAGER_NFT();\n    }\n\n    function setSecurity(\n        address _wiseSecurity\n    )\n        external\n        onlyMaster\n    {\n        if (address(WISE_SECURITY) > ZERO_ADDRESS) {\n            revert InvalidAction();\n        }\n\n        WISE_SECURITY = IWiseSecurity(\n            _wiseSecurity\n        );\n\n        FEE_MANAGER = IFeeManagerLight(\n            WISE_SECURITY.FEE_MANAGER()\n        );\n\n        AAVE_HUB_ADDRESS = WISE_SECURITY.AAVE_HUB();\n    }\n\n    // AaveHub address\n    address internal AAVE_HUB_ADDRESS;\n\n    // Wrapped ETH address\n    address public immutable WETH_ADDRESS;\n\n    // Nft id for feeManager\n    uint256 immutable FEE_MANAGER_NFT;\n\n    uint256 internal constant MIN_BORROW_SHARE_PRICE = 5 * PRECISION_FACTOR_E18\n        / 10;\n\n    // WiseSecurity interface\n    IWiseSecurity public WISE_SECURITY;\n\n    // FeeManager interface\n    IFeeManagerLight internal FEE_MANAGER;\n\n    // NFT contract interface for positions\n    IPositionNFTs public immutable POSITION_NFT;\n\n    // OraceHub interface\n    IWiseOracleHub public immutable WISE_ORACLE;\n\n    // check if it is a powerfarm\n    bool internal powerFarmCheck;\n\n    uint256 internal constant GHOST_AMOUNT = 1E3;\n\n    // Structs ------------------------------------------\n\n    struct LendingEntry {\n        bool unCollateralized;\n        uint256 shares;\n    }\n\n    struct BorrowRatesEntry {\n        uint256 pole;\n        uint256 deltaPole;\n        uint256 minPole;\n        uint256 maxPole;\n        uint256 multiplicativeFactor;\n    }\n\n    struct AlgorithmEntry {\n        bool increasePole;\n        uint256 bestPole;\n        uint256 maxValue;\n        uint256 previousValue;\n    }\n\n    struct GlobalPoolEntry {\n        uint256 totalPool;\n        uint256 utilization;\n        uint256 totalBareToken;\n        uint256 poolFee;\n    }\n\n    struct LendingPoolEntry {\n        uint256 pseudoTotalPool;\n        uint256 totalDepositShares;\n        uint256 collateralFactor;\n    }\n\n    struct BorrowPoolEntry {\n        bool allowBorrow;\n        uint256 pseudoTotalBorrowAmount;\n        uint256 totalBorrowShares;\n        uint256 borrowRate;\n    }\n\n    struct TimestampsPoolEntry {\n        uint256 timeStamp;\n        uint256 timeStampScaling;\n        uint256 initialTimeStamp;\n    }\n\n    struct CoreLiquidationStruct {\n        uint256 nftId;\n        uint256 nftIdLiquidator;\n        address caller;\n        address tokenToPayback;\n        address tokenToRecieve;\n        uint256 paybackAmount;\n        uint256 shareAmountToPay;\n        uint256 maxFeeETH;\n        uint256 baseRewardLiquidation;\n        address[] lendTokens;\n        address[] borrowTokens;\n    }\n\n    modifier onlyAaveHub() {\n        _onlyAaveHub();\n        _;\n    }\n\n    function _onlyAaveHub()\n        private\n        view\n    {\n        if (msg.sender != AAVE_HUB_ADDRESS) {\n            revert InvalidCaller();\n        }\n    }\n\n    // Position mappings ------------------------------------------\n    mapping(address => uint256) internal bufferIncrease;\n    mapping(address => uint256) public maxDepositValueToken;\n\n    mapping(uint256 => address[]) public positionLendTokenData;\n    mapping(uint256 => address[]) public positionBorrowTokenData;\n\n    mapping(uint256 => mapping(address => uint256)) public userBorrowShares;\n    mapping(uint256 => mapping(address => uint256)) public pureCollateralAmount;\n    mapping(uint256 => mapping(address => LendingEntry)) public userLendingData;\n\n    // Struct mappings -------------------------------------\n    mapping(address => BorrowRatesEntry) public borrowRatesData;\n    mapping(address => AlgorithmEntry) public algorithmData;\n    mapping(address => GlobalPoolEntry) public globalPoolData;\n    mapping(address => LendingPoolEntry) public lendingPoolData;\n    mapping(address => BorrowPoolEntry) public borrowPoolData;\n    mapping(address => TimestampsPoolEntry) public timestampsPoolData;\n\n    // Bool mappings -------------------------------------\n    mapping(uint256 => bool) public positionLocked;\n    mapping(address => bool) internal parametersLocked;\n    mapping(address => bool) public verifiedIsolationPool;\n\n    // Hash mappings -------------------------------------\n    mapping(bytes32 => bool) internal hashMapPositionBorrow;\n    mapping(bytes32 => bool) internal hashMapPositionLending;\n\n    // PRECISION FACTORS ------------------------------------\n    uint256 internal constant PRECISION_FACTOR_E16 = 1E16;\n    uint256 internal constant PRECISION_FACTOR_E18 = 1E18;\n    uint256 internal constant PRECISION_FACTOR_E36 = PRECISION_FACTOR_E18 * PRECISION_FACTOR_E18;\n\n    // TIME CONSTANTS --------------------------------------\n    uint256 internal constant ONE_YEAR = 365 days;\n    uint256 internal constant THREE_HOURS = 3 hours;\n    uint256 internal constant PRECISION_FACTOR_YEAR = PRECISION_FACTOR_E18 * ONE_YEAR;\n\n    // Two months in seconds:\n    // Norming change in pole value that it steps from min to max value\n    // within two month (if nothing changes)\n    uint256 internal constant NORMALISATION_FACTOR = 4838400;\n\n    // Default boundary values for pool creation.\n    uint256 internal constant LOWER_BOUND_MAX_RATE = 100 * PRECISION_FACTOR_E16;\n    uint256 internal constant UPPER_BOUND_MAX_RATE = 300 * PRECISION_FACTOR_E16;\n\n    // LASA CONSTANTS -------------------------\n    uint256 internal constant THRESHOLD_SWITCH_DIRECTION = 90 * PRECISION_FACTOR_E16;\n    uint256 internal constant THRESHOLD_RESET_RESONANCE_FACTOR = 75 * PRECISION_FACTOR_E16;\n\n    // MORE THRESHHOLD VALUES\n\n    uint256 internal constant MAX_COLLATERAL_FACTOR = 85 * PRECISION_FACTOR_E16;\n    uint256 internal constant MAX_TOTAL_TOKEN_NUMBER = 8;\n\n    // APR RESTRICTIONS\n    uint256 internal constant RESTRICTION_FACTOR = 10\n        * PRECISION_FACTOR_E36\n        / PRECISION_FACTOR_YEAR;\n}"
    },
    {
      "filename": "contracts/WiseLowLevelHelper.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\nimport \"./WiseLendingDeclaration.sol\";\n\nabstract contract WiseLowLevelHelper is WiseLendingDeclaration {\n\n    modifier onlyFeeManager() {\n        _onlyFeeManager();\n        _;\n    }\n\n    function _onlyFeeManager()\n        private\n        view\n    {\n        if (msg.sender == address(FEE_MANAGER)) {\n            return;\n        }\n\n        revert InvalidCaller();\n    }\n\n    function _validateParameter(\n        uint256 _parameterValue,\n        uint256 _parameterLimit\n    )\n        internal\n        pure\n    {\n        if (_parameterValue > _parameterLimit) {\n            revert InvalidAction();\n        }\n    }\n\n    // --- Basic Public Views Functions ----\n\n    function getTotalPool(\n        address _poolToken\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return globalPoolData[_poolToken].totalPool;\n    }\n\n    function getPseudoTotalPool(\n        address _poolToken\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return lendingPoolData[_poolToken].pseudoTotalPool;\n    }\n\n    function getTotalBareToken(\n        address _poolToken\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return globalPoolData[_poolToken].totalBareToken;\n    }\n\n    function getPseudoTotalBorrowAmount(\n        address _poolToken\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return borrowPoolData[_poolToken].pseudoTotalBorrowAmount;\n    }\n\n    function getTotalDepositShares(\n        address _poolToken\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return lendingPoolData[_poolToken].totalDepositShares;\n    }\n\n    function getTotalBorrowShares(\n        address _poolToken\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return borrowPoolData[_poolToken].totalBorrowShares;\n    }\n\n    function getPositionLendingShares(\n        uint256 _nftId,\n        address _poolToken\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return userLendingData[_nftId][_poolToken].shares;\n    }\n\n    function getPositionBorrowShares(\n        uint256 _nftId,\n        address _poolToken\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return userBorrowShares[_nftId][_poolToken];\n    }\n\n    function getPureCollateralAmount(\n        uint256 _nftId,\n        address _poolToken\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return pureCollateralAmount[_nftId][_poolToken];\n    }\n\n    // --- Basic Internal Get Functions ----\n\n    function getTimeStamp(\n        address _poolToken\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return timestampsPoolData[_poolToken].timeStamp;\n    }\n\n    function getPositionLendingTokenByIndex(\n        uint256 _nftId,\n        uint256 _index\n    )\n        public\n        view\n        returns (address)\n    {\n        return positionLendTokenData[_nftId][_index];\n    }\n\n    function getPositionLendingTokenLength(\n        uint256 _nftId\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return positionLendTokenData[_nftId].length;\n    }\n\n    function getPositionBorrowTokenByIndex(\n        uint256 _nftId,\n        uint256 _index\n    )\n        public\n        view\n        returns (address)\n    {\n        return positionBorrowTokenData[_nftId][_index];\n    }\n\n    function getPositionBorrowTokenLength(\n        uint256 _nftId\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return positionBorrowTokenData[_nftId].length;\n    }\n\n    // --- Basic Internal Set Functions ----\n\n    function _setMaxValue(\n        address _poolToken,\n        uint256 _value\n    )\n        internal\n    {\n        algorithmData[_poolToken].maxValue = _value;\n    }\n\n    function _setBestPole(\n        address _poolToken,\n        uint256 _value\n    )\n        internal\n    {\n        algorithmData[_poolToken].bestPole = _value;\n    }\n\n    function _setIncreasePole(\n        address _poolToken,\n        bool _state\n    )\n        internal\n    {\n        algorithmData[_poolToken].increasePole = _state;\n    }\n\n    function _setPole(\n        address _poolToken,\n        uint256 _value\n    )\n        internal\n    {\n        borrowRatesData[_poolToken].pole = _value;\n    }\n\n    function _increaseTotalPool(\n        address _poolToken,\n        uint256 _amount\n    )\n        internal\n    {\n        globalPoolData[_poolToken].totalPool += _amount;\n    }\n\n    function _decreaseTotalPool(\n        address _poolToken,\n        uint256 _amount\n    )\n        internal\n    {\n        globalPoolData[_poolToken].totalPool -= _amount;\n    }\n\n    function _increaseTotalDepositShares(\n        address _poolToken,\n        uint256 _amount\n    )\n        internal\n    {\n        lendingPoolData[_poolToken].totalDepositShares += _amount;\n    }\n\n    function _decreaseTotalDepositShares(\n        address _poolToken,\n        uint256 _amount\n    )\n        internal\n    {\n        lendingPoolData[_poolToken].totalDepositShares -= _amount;\n    }\n\n    function _increasePseudoTotalBorrowAmount(\n        address _poolToken,\n        uint256 _amount\n    )\n        internal\n    {\n        borrowPoolData[_poolToken].pseudoTotalBorrowAmount += _amount;\n    }\n\n    function _decreasePseudoTotalBorrowAmount(\n        address _poolToken,\n        uint256 _amount\n    )\n        internal\n    {\n        borrowPoolData[_poolToken].pseudoTotalBorrowAmount -= _amount;\n    }\n\n    function _increaseTotalBorrowShares(\n        address _poolToken,\n        uint256 _amount\n    )\n        internal\n    {\n        borrowPoolData[_poolToken].totalBorrowShares += _amount;\n    }\n\n    function _decreaseTotalBorrowShares(\n        address _poolToken,\n        uint256 _amount\n    )\n        internal\n    {\n        borrowPoolData[_poolToken].totalBorrowShares -= _amount;\n    }\n\n    function _increasePseudoTotalPool(\n        address _poolToken,\n        uint256 _amount\n    )\n        internal\n    {\n        lendingPoolData[_poolToken].pseudoTotalPool += _amount;\n    }\n\n    function _decreasePseudoTotalPool(\n        address _poolToken,\n        uint256 _amount\n    )\n        internal\n    {\n        lendingPoolData[_poolToken].pseudoTotalPool -= _amount;\n    }\n\n    function _setTimeStamp(\n        address _poolToken,\n        uint256 _time\n    )\n        internal\n    {\n        timestampsPoolData[_poolToken].timeStamp = _time;\n    }\n\n    function _setTimeStampScaling(\n        address _poolToken,\n        uint256 _time\n    )\n        internal\n    {\n        timestampsPoolData[_poolToken].timeStampScaling = _time;\n    }\n\n    function _increaseTotalBareToken(\n        address _poolToken,\n        uint256 _amount\n    )\n        internal\n    {\n        globalPoolData[_poolToken].totalBareToken += _amount;\n    }\n\n    function _decreaseTotalBareToken(\n        address _poolToken,\n        uint256 _amount\n    )\n        internal\n    {\n        globalPoolData[_poolToken].totalBareToken -= _amount;\n    }\n\n    function _checkReentrancy()\n        internal\n        view\n    {\n        if (sendingProgress == true) {\n            revert InvalidAction();\n        }\n\n        if (_sendingProgressAaveHub() == true) {\n            revert InvalidAction();\n        }\n    }\n\n    function _sendingProgressAaveHub()\n        private\n        view\n        returns (bool)\n    {\n        return IAaveHubLite(AAVE_HUB_ADDRESS).sendingProgressAaveHub();\n    }\n\n    function _decreasePositionMappingValue(\n        mapping(uint256 => mapping(address => uint256)) storage userMapping,\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount\n    )\n        internal\n    {\n        userMapping[_nftId][_poolToken] -= _amount;\n    }\n\n    function _increaseMappingValue(\n        mapping(uint256 => mapping(address => uint256)) storage userMapping,\n        uint256 _nftId,\n        address _poolToken,\n        uint256 _amount\n    )\n        internal\n    {\n        userMapping[_nftId][_poolToken] += _amount;\n    }\n\n    function _byPassCase(\n        address _sender\n    )\n        internal\n        view\n        returns (bool)\n    {\n        if (verifiedIsolationPool[_sender] == true) {\n            return true;\n        }\n\n        return false;\n    }\n\n    function _increaseTotalAndPseudoTotalPool(\n        address _poolToken,\n        uint256 _amount\n    )\n        internal\n    {\n        _increasePseudoTotalPool(\n            _poolToken,\n            _amount\n        );\n\n        _increaseTotalPool(\n            _poolToken,\n            _amount\n        );\n    }\n\n    function setPoolFee(\n        address _poolToken,\n        uint256 _newFee\n    )\n        external\n        onlyFeeManager\n    {\n        globalPoolData[_poolToken].poolFee = _newFee;\n    }\n\n    function _checkOwnerPosition(\n        uint256 _nftId,\n        address _msgSender\n    )\n        internal\n        view\n    {\n        WISE_SECURITY.checkOwnerPosition(\n            _nftId,\n            _msgSender\n        );\n    }\n\n    function _validateNonZero(\n        uint256 _value\n    )\n        internal\n        pure\n    {\n        if (_value == 0) {\n            revert ValueIsZero();\n        }\n    }\n\n    function _validateZero(\n        uint256 _value\n    )\n        internal\n        pure\n    {\n        if (_value > 0) {\n            revert ValueNotZero();\n        }\n    }\n}"
    },
    {
      "filename": "contracts/FeeManager/DeclarationsFeeManager.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\nimport \"../InterfaceHub/IAave.sol\";\nimport \"../InterfaceHub/IERC20.sol\";\nimport \"../InterfaceHub/IWiseLending.sol\";\nimport \"../InterfaceHub/IFeeManager.sol\";\nimport \"../InterfaceHub/IWiseSecurity.sol\";\nimport \"../InterfaceHub/IPositionNFTs.sol\";\nimport \"../InterfaceHub/IWiseOracleHub.sol\";\n\nimport \"../OwnableMaster.sol\";\nimport \"./FeeManagerEvents.sol\";\n\nerror NotWiseLiquidation();\nerror AlreadySet();\nerror ExistingBadDebt();\nerror NotWiseLending();\nerror NotIncentiveMaster();\nerror PoolAlreadyAdded();\nerror TooHighValue();\nerror TooLowValue();\nerror NotAllowed();\nerror PoolNotPresent();\nerror ZeroAddress();\nerror NoIncentive();\nerror Reentered();\nerror PoolNotActive();\n\ncontract DeclarationsFeeManager is FeeManagerEvents, OwnableMaster {\n\n    constructor(\n        address _master,\n        address _aaveAddress,\n        address _wiseLendingAddress,\n        address _oracleHubAddress,\n        address _wiseSecurityAddress,\n        address _positionNFTAddress\n    )\n        OwnableMaster(\n            _master\n        )\n    {\n        if (_aaveAddress == ZERO_ADDRESS) {\n            revert NoValue();\n        }\n\n        if (_wiseLendingAddress == ZERO_ADDRESS) {\n            revert NoValue();\n        }\n\n        if (_oracleHubAddress == ZERO_ADDRESS) {\n            revert NoValue();\n        }\n\n        if (_wiseSecurityAddress == ZERO_ADDRESS) {\n            revert NoValue();\n        }\n\n        if (_positionNFTAddress == ZERO_ADDRESS) {\n            revert NoValue();\n        }\n\n        WISE_LENDING = IWiseLending(\n            _wiseLendingAddress\n        );\n\n        AAVE = IAave(\n            _aaveAddress\n        );\n\n        ORACLE_HUB = IWiseOracleHub(\n            _oracleHubAddress\n        );\n\n        WISE_SECURITY = IWiseSecurity(\n            _wiseSecurityAddress\n        );\n\n        POSITION_NFTS = IPositionNFTs(\n            _positionNFTAddress\n        );\n\n        FEE_MANAGER_NFT = POSITION_NFTS.FEE_MANAGER_NFT();\n\n        incentiveMaster = _master;\n        paybackIncentive = 5 * PRECISION_FACTOR_E16;\n\n        incentiveOwnerA = 0xf69A0e276664997357BF987df83f32a1a3F80944;\n        incentiveOwnerB = 0x8f741ea9C9ba34B5B8Afc08891bDf53faf4B3FE7;\n\n        incentiveUSD[incentiveOwnerA] = 98000 * PRECISION_FACTOR_E18;\n        incentiveUSD[incentiveOwnerB] = 106500 * PRECISION_FACTOR_E18;\n    }\n\n    // ---- Interfaces ----\n\n    // Interface aave V3 contract\n    IAave public immutable AAVE;\n\n    // Interface wiseLending contract\n    IWiseLending public immutable WISE_LENDING;\n\n    // Interface position NFT contract\n    IPositionNFTs public immutable POSITION_NFTS;\n\n    // Interface wiseSecurity contract\n    IWiseSecurity public immutable WISE_SECURITY;\n\n    // Interface wise oracleHub contract\n    IWiseOracleHub public immutable ORACLE_HUB;\n\n    // ---- Variables ----\n\n    // Global total bad debt variable\n    uint256 public totalBadDebtETH;\n\n    // Incentive percentage for paying back bad debt\n    uint256 public paybackIncentive;\n\n    // Array of pool tokens in wiseLending\n    address[] public poolTokenAddresses;\n\n    // Address of incentive master\n    address public incentiveMaster;\n\n    // Proposed incentive master (for changing)\n    address public proposedIncentiveMaster;\n\n    // Address of incentive owner A\n    address public incentiveOwnerA;\n\n    // Address of incentive owner B\n    address public incentiveOwnerB;\n\n    // ---- Mappings ----\n\n    // Bad debt of a specific position\n    mapping(uint256 => uint256) public badDebtPosition;\n\n    // Amount of fee token inside feeManager\n    mapping(address => uint256) public feeTokens;\n\n    // Open incetive amount for incentiveOwner in ETH\n    mapping(address => uint256) public incentiveUSD;\n\n    // Flag that specific token is already added\n    mapping(address => bool) public poolTokenAdded;\n\n    // Flag for token being aToken\n    mapping(address => bool) public isAaveToken;\n\n    // Getting underlying token of aave aToken\n    mapping(address => address) public underlyingToken;\n\n    // Showing which token are allowed to claim for beneficial address\n    mapping(address => mapping(address => bool)) public allowedTokens;\n\n    // Gives claimable token amount for incentiveOwner per token\n    mapping(address => mapping(address => uint256)) public gatheredIncentiveToken;\n\n    // Position NFT id of the feeManager\n    uint256 public immutable FEE_MANAGER_NFT;\n\n    // Precision factors for computations\n    uint256 internal constant PRECISION_FACTOR_E15 = 1E15;\n    uint256 internal constant PRECISION_FACTOR_E16 = 1E16;\n    uint256 internal constant PRECISION_FACTOR_E18 = 1E18;\n\n    // Base portion from gathered fees for incentiveOwners (0.5%)\n    uint256 public constant INCENTIVE_PORTION = 5 * PRECISION_FACTOR_E15;\n\n    // ---- Modifier ----\n\n    modifier onlyWiseSecurity() {\n        _onlyWiseSecurity();\n        _;\n    }\n\n    modifier onlyWiseLending() {\n        _onlyWiseLending();\n        _;\n    }\n\n    modifier onlyIncentiveMaster() {\n        _onlyIncentiveMaster();\n        _;\n    }\n\n    function _onlyIncentiveMaster()\n        private\n        view\n    {\n        if (msg.sender == incentiveMaster) {\n            return;\n        }\n\n        revert NotIncentiveMaster();\n    }\n\n    function _onlyWiseSecurity()\n        private\n        view\n    {\n        if (msg.sender == address(WISE_SECURITY)) {\n            return;\n        }\n\n        revert NotWiseLiquidation();\n    }\n\n    function _onlyWiseLending()\n        private\n        view\n    {\n        if (msg.sender == address(WISE_LENDING)) {\n            return;\n        }\n\n        revert NotWiseLending();\n    }\n}"
    },
    {
      "filename": "contracts/FeeManager/FeeManager.sol",
      "content": "// SPDX-License-Identifier: -- WISE --\n\npragma solidity =0.8.24;\n\n/**\n * @author Christoph Krpoun\n * @author Ren√© Hochmuth\n * @author Vitally Marinchenko\n */\n\nimport \"./FeeManagerHelper.sol\";\n\n/**\n * @dev Purpose of this contract is to organize fee distribution from wiseLending.\n * The feeManager aquires fee token in form of shares from each pool and can call them\n * with \"claimWiseFees()\" for each pool.\n *\n * Furthermore, this contracts has two different incentive\n * structures which can be used to bootstrap the WISE ecosystem (beneficial and incnetiveOwner roles).\n *\n * Additionally, this contract keeps track of the bad debt of each postion and has a simple mechanism\n * to pay them back via incentives. The incentive amount is funded by the gathered fees.\n */\n\ncontract FeeManager is FeeManagerHelper {\n\n    constructor(\n        address _master,\n        address _aaveAddress,\n        address _wiseLendingAddress,\n        address _oracleHubAddress,\n        address _wiseSecurityAddress,\n        address _positionNFTAddress\n    )\n        DeclarationsFeeManager(\n            _master,\n            _aaveAddress,\n            _wiseLendingAddress,\n            _oracleHubAddress,\n            _wiseSecurityAddress,\n            _positionNFTAddress\n        )\n    {}\n\n    /**\n     * @dev Allows to adjust the paid out incentive\n     * percentage for user to reduce bad debt.\n     */\n    function setRepayBadDebtIncentive(\n        uint256 _percent\n    )\n        external\n        onlyMaster\n    {\n        _checkValue(\n            _percent\n        );\n\n        paybackIncentive = _percent;\n    }\n\n    /**\n     * @dev Maps underlying token with corresponding aToken.\n     * Sets bool to identify pool token as aToken.\n     */\n    function setAaveFlag(\n        address _poolToken,\n        address _underlyingToken\n    )\n        external\n        onlyMaster\n    {\n        _setAaveFlag(\n            _poolToken,\n            _underlyingToken\n        );\n    }\n\n    /**\n     * @dev Bulk function for setting aave flag for multiple pools.\n     */\n    function setAaveFlagBulk(\n        address[] calldata _poolTokens,\n        address[] calldata _underlyingTokens\n    )\n        external\n        onlyMaster\n    {\n        uint256 i;\n        uint256 l = _poolTokens.length;\n\n        while (i < l) {\n            _setAaveFlag(\n                _poolTokens[i],\n                _underlyingTokens[i]\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Function to adjust pool fee. Fee can not be greater than 100%\n     * or lower than 1%. Can be adjusted for each pool individually.\n     */\n    function setPoolFee(\n        address _poolToken,\n        uint256 _newFee\n    )\n        external\n        onlyMaster\n    {\n        _checkValue(\n            _newFee\n        );\n\n        WISE_LENDING.setPoolFee(\n            _poolToken,\n            _newFee\n        );\n\n        emit PoolFeeChanged(\n            _poolToken,\n            _newFee,\n            block.timestamp\n        );\n    }\n\n    /**\n    * @dev Function to adjust pool fees in bulk. Fee for each pool can not be\n    * greater than 100% or lower than 1%. Can be adjusted for each pool individually.\n    */\n    function setPoolFeeBulk(\n        address[] calldata _poolTokens,\n        uint256[] calldata _newFees\n    )\n        external\n        onlyMaster\n    {\n        uint256 i;\n        uint256 l = _poolTokens.length;\n\n        while (i < l) {\n\n            _checkValue(\n                _newFees[i]\n            );\n\n            WISE_LENDING.setPoolFee(\n                _poolTokens[i],\n                _newFees[i]\n            );\n\n            emit PoolFeeChanged(\n                _poolTokens[i],\n                _newFees[i],\n                block.timestamp\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Function to propose new incentive master. This role can increase\n     * the incentive amount for both incentive mappings. These are two roles\n     * for incentivising external persons e.g. developers.\n     */\n    function proposeIncentiveMaster(\n        address _proposedIncentiveMaster\n    )\n        external\n        onlyIncentiveMaster\n    {\n        if (_proposedIncentiveMaster == ZERO_ADDRESS) {\n            revert ZeroAddress();\n        }\n\n        proposedIncentiveMaster = _proposedIncentiveMaster;\n\n        emit IncentiveMasterProposed(\n            _proposedIncentiveMaster,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Claim proposed incentive master by proposed entity.\n     */\n    function claimOwnershipIncentiveMaster()\n        external\n    {\n        if (msg.sender != proposedIncentiveMaster) {\n            revert NotAllowed();\n        }\n\n        incentiveMaster = proposedIncentiveMaster;\n        proposedIncentiveMaster = ZERO_ADDRESS;\n\n        emit ClaimedOwnershipIncentiveMaster(\n            incentiveMaster,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Increase function for increasing incentive amount for entity A.\n     * Only callable by incentive master.\n     */\n    function increaseIncentiveA(\n        uint256 _value\n    )\n        external\n        onlyIncentiveMaster\n    {\n        incentiveUSD[incentiveOwnerA] += _value;\n\n        emit IncentiveIncreasedA(\n            _value,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Increase function for increasing incentive amount for entity B.\n     * Only callable by incentive master.\n     */\n    function increaseIncentiveB(\n        uint256 _value\n    )\n        external\n        onlyIncentiveMaster\n    {\n        incentiveUSD[incentiveOwnerB] += _value;\n\n        emit IncentiveIncreasedB(\n            _value,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Function to claim all gathered incetives.\n     */\n    function claimIncentivesBulk()\n        external\n    {\n        address tokenAddress;\n\n        uint256 i;\n        uint256 l = getPoolTokenAddressesLength();\n\n        while (i < l) {\n\n            tokenAddress = poolTokenAddresses[i];\n\n            if (isAaveToken[tokenAddress] == true) {\n                tokenAddress = underlyingToken[\n                    tokenAddress\n                ];\n            }\n\n            claimIncentives(\n                tokenAddress\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit ClaimedIncentivesBulk(\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Claims gathered incentives for a specific token.\n     */\n    function claimIncentives(\n        address _feeToken\n    )\n        public\n    {\n        uint256 amount = gatheredIncentiveToken[msg.sender][_feeToken];\n\n        if (amount == 0) {\n            revert NoIncentive();\n        }\n\n        delete gatheredIncentiveToken[msg.sender][_feeToken];\n\n        emit ClaimedIncentives(\n            msg.sender,\n            _feeToken,\n            amount,\n            block.timestamp\n        );\n\n        _safeTransfer(\n            _feeToken,\n            msg.sender,\n            amount\n        );\n    }\n\n    /**\n     * @dev Function changing incentiveOwnerA! Only callable by\n     * incentiveOwnerA.\n     */\n    function changeIncentiveUSDA(\n        address _newOwner\n    )\n        external\n    {\n        if (msg.sender != incentiveOwnerA) {\n            revert NotAllowed();\n        }\n\n        if (_newOwner == incentiveOwnerA) {\n            revert NotAllowed();\n        }\n\n        if (_newOwner == incentiveOwnerB) {\n            revert NotAllowed();\n        }\n\n        incentiveUSD[_newOwner] = incentiveUSD[\n            incentiveOwnerA\n        ];\n\n        delete incentiveUSD[\n            incentiveOwnerA\n        ];\n\n        incentiveOwnerA = _newOwner;\n\n        emit IncentiveOwnerAChanged(\n            _newOwner,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Function changing incentiveOwnerB! Only callable by\n     * incentiveOwnerB.\n     */\n    function changeIncentiveUSDB(\n        address _newOwner\n    )\n        external\n    {\n        if (msg.sender != incentiveOwnerB) {\n            revert NotAllowed();\n        }\n\n        if (_newOwner == incentiveOwnerA) {\n            revert NotAllowed();\n        }\n\n        if (_newOwner == incentiveOwnerB) {\n            revert NotAllowed();\n        }\n\n        incentiveUSD[_newOwner] = incentiveUSD[\n            incentiveOwnerB\n        ];\n\n        delete incentiveUSD[\n            incentiveOwnerB\n        ];\n\n        incentiveOwnerB = _newOwner;\n\n        emit IncentiveOwnerBChanged(\n            _newOwner,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Function adding new pool token to pool token list.\n     * Called during pool creation and only callable by wiseLending\n     * contract.\n     */\n    function"
    }
  ]
}