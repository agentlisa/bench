{
  "Title": "[M-07] Malicious user can steal native tokens of MoneyMarketHook caller",
  "Content": "\nMoneyMarketHook allows user to chain some actions into one multicall to the InitCore. In the end user can get all wrapped native tokens that he withdrew [in a form of native token](https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/hook/MoneyMarketHook.sol#L76-L80). Note, that this part of code withdraws all balance from wrapped token and the sends all balance to the `msg.sender`. In case if balance of contract is 0, then the call will still succeed.\n\nOne type of actions that caller can do using `execute` function [is withdraw](https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/hook/MoneyMarketHook.sol#L124). In case if caller needs to repay funds to other address then he can provide it [as `to` param](https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/hook/MoneyMarketHook.sol#L181). So as result, `IInitCore.burnTo` will transfer pool tokens [to the provided recipient](https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/hook/MoneyMarketHook.sol#L192). And in case if token has a hook, like erc777 or erc677, then receiver will be triggered and he has execution control now.\n\nUser can have [multiple withdraws in same multicall](https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/hook/MoneyMarketHook.sol#L173). And it's possible that first withdraw is wrapped native token withdraw(which user would like to receive as native) and next withdraw is with erc777 token and other recipient.\n\nIn such case, when first withdraw is done, then wrapped token is already on MoneyMarketHook balance. And then when second withdraw is handled and attacker get hook, then he can call MoneyMarketHook.execute(it doesn't have reentrancy check) again with any params that just should pass and `_params.returnNative` as true. Then all wrapped token balance will be sent to the attacker and then execution will return back to the victim and it will send 0 amount as native token to the victim.\n\nAs result attacker is able to steal user's native tokens.\n\nFrom the readme, it's clear that only fee on transfer tokens are not supported and erc777 are supported:\n\n> Please list specific ERC20 that your protocol is anticipated to interact with. Could be \"any\" (literally anything, fee on transfer tokens, ERC777 tokens and so forth) or a list of tokens you envision using on launch.<br>\n> No fee-on-transfer tokens\n\n### Impact\n\nIt's possible to steal user's funds.\n\n### Tools Used\n\nVsCode\n\n### Recommended Mitigation Steps\n\nAdd reentrancy check to the `execute` function.\n\n**[fez-init (INIT) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2023-12-initcapital-findings/issues/19#issuecomment-1870299489):**\n > This should be a medium issue. There are multiple things that needs to be aligned, including:\n >\n> - supporting of ERC777. We did not intend to support ERC777, but acknowledge that it may not be communicated clearly.\n> - the victim needs to specify a certain malicious `to` contract for the attack to happen.\n\n > We will add reentrancy check to the execute function to prevent this kind of scenario anyways.\n\n**[hansfriese (Judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-12-initcapital-findings/issues/19#issuecomment-1870758513):**\n > I agree Medium is appropriate due to this requirement: \"the victim needs to specify a certain malicious `to` contract for the attack to happen\".\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-12-initcapital",
  "Code": [
    {
      "filename": "contracts/hook/MoneyMarketHook.sol",
      "content": "// SPDX-License-Identifier: None\npragma solidity ^0.8.19;\n\nimport '../common/library/InitErrors.sol';\nimport '../common/library/UncheckedIncrement.sol';\nimport {IInitCore} from '../interfaces/core/IInitCore.sol';\nimport {IMulticall} from '../interfaces/common/IMulticall.sol';\nimport {IPosManager} from '../interfaces/core/IPosManager.sol';\nimport {ILendingPool} from '../interfaces/lending_pool/ILendingPool.sol';\nimport {IWNative} from '../interfaces/common/IWNative.sol';\nimport {IRebaseHelper} from '../interfaces/helper/rebase_helper/IRebaseHelper.sol';\nimport {IMoneyMarketHook} from '../interfaces/hook/IMoneyMarketHook.sol';\n\nimport {IERC20} from '@openzeppelin-contracts/token/ERC20/IERC20.sol';\nimport {IERC721} from '@openzeppelin-contracts/token/ERC721/IERC721.sol';\nimport {SafeERC20} from '@openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol';\nimport {ERC721HolderUpgradeable} from\n    '@openzeppelin-contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol';\n\n// NOTE: only support normal money market actions (deposit, withdraw, borrow, repay, change position mode)\ncontract MoneyMarketHook is IMoneyMarketHook, ERC721HolderUpgradeable {\n    using UncheckedIncrement for uint;\n    using SafeERC20 for IERC20;\n\n    // immutables\n    /// @inheritdoc IMoneyMarketHook\n    address public immutable CORE;\n    /// @inheritdoc IMoneyMarketHook\n    address public immutable POS_MANAGER;\n    /// @inheritdoc IMoneyMarketHook\n    address public immutable WNATIVE;\n\n    // storages\n    /// @inheritdoc IMoneyMarketHook\n    mapping(address => uint) public lastPosIds;\n    /// @inheritdoc IMoneyMarketHook\n    mapping(address => mapping(uint => uint)) public initPosIds;\n\n    // constructor\n    constructor(address _initCore, address _wNative) {\n        CORE = _initCore;\n        POS_MANAGER = IInitCore(_initCore).POS_MANAGER();\n        WNATIVE = _wNative;\n        _disableInitializers();\n    }\n\n    // initialize\n    /// @dev initialize the contract\n    function initialize() external initializer {}\n\n    // functions\n    /// @inheritdoc IMoneyMarketHook\n    function execute(OperationParams calldata _params)\n        external\n        payable\n        returns (uint posId, uint initPosId, bytes[] memory results)\n    {\n        // create position if not exist\n        if (_params.posId == 0) {\n            (posId, initPosId) = createPos(_params.mode, _params.viewer);\n        } else {\n            // for existing position, only owner can execute\n            posId = _params.posId;\n            initPosId = initPosIds[msg.sender][posId];\n            _require(IERC721(POS_MANAGER).ownerOf(initPosId) == address(this), Errors.NOT_OWNER);\n        }\n        results = _handleMulticall(initPosId, _params);\n        // check slippage\n        _require(_params.minHealth_e18 <= IInitCore(CORE).getPosHealthCurrent_e18(initPosId), Errors.SLIPPAGE_CONTROL);\n        // unwrap token if needed\n        for (uint i; i < _params.withdrawParams.length; i = i.uinc()) {\n            address helper = _params.withdrawParams[i].rebaseHelperParams.helper;\n            if (helper != address(0)) IRebaseHelper(helper).unwrap(_params.withdrawParams[i].to);\n        }\n        // return native token\n        if (_params.returnNative) {\n            IWNative(WNATIVE).withdraw(IERC20(WNATIVE).balanceOf(address(this)));\n            (bool success,) = payable(msg.sender).call{value: address(this).balance}('');\n            _require(success, Errors.CALL_FAILED);\n        }\n    }\n\n    /// @inheritdoc IMoneyMarketHook\n    function createPos(uint16 _mode, address _viewer) public returns (uint posId, uint initPosId) {\n        posId = ++lastPosIds[msg.sender];\n        initPosId = IInitCore(CORE).createPos(_mode, _viewer);\n        initPosIds[msg.sender][posId] = initPosId;\n    }\n\n    /// @dev approve token for init core if needed\n    /// @param _token token address\n    /// @param _amt token amount to spend\n    function _ensureApprove(address _token, uint _amt) internal {\n        if (IERC20(_token).allowance(address(this), CORE) < _amt) {\n            IERC20(_token).safeApprove(CORE, type(uint).max);\n        }\n    }\n\n    // @dev prepare and execute multicall\n    // @param _initPosId init position id (nft id)\n    // @param _params operation parameters\n    // @return results results of multicall\n    function _handleMulticall(uint _initPosId, OperationParams calldata _params)\n        internal\n        returns (bytes[] memory results)\n    {\n        // prepare data for multicall\n        // 1. repay (if needed)\n        // 2. withdraw (if needed)\n        // 3. change position mode (if needed)\n        // 4. borrow (if needed)\n        // 5. deposit (if needed)\n        bool changeMode = _params.mode != 0 && _params.mode != IPosManager(POS_MANAGER).getPosMode(_initPosId);\n        bytes[] memory data;\n        {\n            uint dataLength = _params.repayParams.length + (2 * _params.withdrawParams.length) + (changeMode ? 1 : 0)\n                + _params.borrowParams.length + (2 * _params.depositParams.length);\n            data = new bytes[](dataLength);\n        }\n        uint offset;\n        // 1. repay\n        (offset, data) = _handleRepay(offset, data, _initPosId, _params.repayParams);\n        // 2. withdraw\n        (offset, data) = _handleWithdraw(offset, data, _initPosId, _params.withdrawParams);\n        // 3. change position mode\n        if (changeMode) {\n            data[offset] = abi.encodeWithSelector(IInitCore.setPosMode.selector, _initPosId, _params.mode);\n            offset = offset.uinc();\n        }\n        // 4. borrow\n        (offset, data) = _handleBorrow(offset, data, _initPosId, _params.borrowParams);\n        // 5. deposit\n        (offset, data) = _handleDeposit(offset, data, _initPosId, _params.depositParams);\n        // execute multicall\n        results = IMulticall(CORE).multicall(data);\n    }\n\n    /// @dev generate repay data for multicall\n    /// @param _offset offset of data\n    /// @param _data multicall data\n    /// @param _initPosId init position id (nft id)\n    /// @param _params repay params\n    /// @return offset new offset\n    /// @return data new data\n    function _handleRepay(uint _offset, bytes[] memory _data, uint _initPosId, RepayParams[] memory _params)\n        internal\n        returns (uint, bytes[] memory)\n    {\n        for (uint i; i < _params.length; i = i.uinc()) {\n            address uToken = ILendingPool(_params[i].pool).underlyingToken();\n            uint repayAmt = ILendingPool(_params[i].pool).debtShareToAmtCurrent(_params[i].shares);\n            _ensureApprove(uToken, repayAmt);\n            IERC20(uToken).safeTransferFrom(msg.sender, address(this), repayAmt);\n            _data[_offset] =\n                abi.encodeWithSelector(IInitCore.repay.selector, _params[i].pool, _params[i].shares, _initPosId);\n            _offset = _offset.uinc();\n        }\n        return (_offset, _data);\n    }\n\n    /// @dev generate withdraw data for multicall\n    /// @param _offset offset of data\n    /// @param _data multicall data\n    /// @param _initPosId init position id (nft id)\n    /// @param _params withdraw params\n    /// @return offset new offset\n    /// @return data new data\n    function _handleWithdraw(uint _offset, bytes[] memory _data, uint _initPosId, WithdrawParams[] calldata _params)\n        internal\n        view\n        returns (uint, bytes[] memory)\n    {\n        for (uint i; i < _params.length; i = i.uinc()) {\n            // decollateralize to pool\n            _data[_offset] = abi.encodeWithSelector(\n                IInitCore.decollateralize.selector, _initPosId, _params[i].pool, _params[i].shares, _params[i].pool\n            );\n            _offset = _offset.uinc();\n            // burn collateral to underlying token\n            address helper = _params[i].rebaseHelperParams.helper;\n            address uTokenReceiver = _params[i].to;\n            // if need to unwrap to rebase token\n            if (helper != address(0)) {\n                address uToken = ILendingPool(_params[i].pool).underlyingToken();\n                _require(\n                    _params[i].rebaseHelperParams.tokenIn == uToken\n                        && IRebaseHelper(_params[i].rebaseHelperParams.helper).YIELD_BEARING_TOKEN() == uToken,\n                    Errors.INVALID_TOKEN_IN\n                );\n                uTokenReceiver = helper;\n            }\n            _data[_offset] = abi.encodeWithSelector(IInitCore.burnTo.selector, _params[i].pool, uTokenReceiver);\n            _offset = _offset.uinc();\n        }\n        return (_offset, _data);\n    }\n\n    /// @dev generate borrow data for multicall\n    /// @param _offset offset of data\n    /// @param _data multicall data\n    /// @param _initPosId init position id (nft id)\n    /// @param _params borrow params\n    /// @return offset new offset\n    /// @return data new data\n    function _handleBorrow(uint _offset, bytes[] memory _data, uint _initPosId, BorrowParams[] calldata _params)\n        internal\n        pure\n        returns (uint, bytes[] memory)\n    {\n        for (uint i; i < _params.length; i = i.uinc()) {\n            _data[_offset] = abi.encodeWithSelector(\n                IInitCore.borrow.selector, _params[i].pool, _params[i].amt, _initPosId, _params[i].to\n            );\n            _offset = _offset.uinc();\n        }\n        return (_offset, _data);\n    }\n\n    /// @dev generate deposit data for multicall\n    /// @param _offset offset of data\n    /// @param _data multicall data\n    /// @param _initPosId init position id (nft id)\n    /// @param _params deposit params\n    /// @return offset new offset\n    /// @return data new data\n    function _handleDeposit(uint _offset, bytes[] memory _data, uint _initPosId, DepositParams[] calldata _params)\n        internal\n        returns (uint, bytes[] memory)\n    {\n        for (uint i; i < _params.length; i = i.uinc()) {\n            address pool = _params[i].pool;\n            uint amt = _params[i].amt;\n            address uToken = ILendingPool(pool).underlyingToken();\n            address helper = _params[i].rebaseHelperParams.helper;\n            // 1. deposit native token\n            // NOTE: use msg.value for native token\n            // amt > 0 mean user want to use wNative too\n            if (uToken == WNATIVE) {\n                IWNative(WNATIVE).deposit{value: msg.value}();\n                IERC20(WNATIVE).safeTransfer(pool, msg.value);\n                // transfer wNative to pool will user want to use wNative\n                if (amt != 0) {\n                    IERC20(WNATIVE).safeTransferFrom(msg.sender, pool, amt);\n                }\n            }\n            // 2. wrap rebase token to non-rebase token and deposit\n            else if (helper != address(0)) {\n                address tokenIn = _params[i].rebaseHelperParams.tokenIn;\n                _require(\n                    IRebaseHelper(_params[i].rebaseHelperParams.helper).REBASE_TOKEN() == tokenIn,\n                    Errors.INVALID_TOKEN_IN\n                );\n                _require(\n                    IRebaseHelper(_params[i].rebaseHelperParams.helper).YIELD_BEARING_TOKEN() == uToken,\n                    Errors.INVALID_TOKEN_OUT\n                );\n                IERC20(tokenIn).safeTransferFrom(msg.sender, helper, amt);\n                IRebaseHelper(helper).wrap(pool);\n            }\n            // 3. deposit normal erc20 token\n            else {\n                IERC20(uToken).safeTransferFrom(msg.sender, pool, amt);\n            }\n            // mint to position\n            _data[_offset] = abi.encodeWithSelector(IInitCore.mintTo.selector, pool, POS_MANAGER);\n            _offset = _offset.uinc();\n            // collateralize\n            _data[_offset] = abi.encodeWithSelector(IInitCore.collateralize.selector, _initPosId, pool);\n            _offset = _offset.uinc();\n        }\n        return (_offset, _data);\n    }\n}"
    },
    {
      "filename": "contracts/hook/MoneyMarketHook.sol",
      "content": "// SPDX-License-Identifier: None\npragma solidity ^0.8.19;\n\nimport '../common/library/InitErrors.sol';\nimport '../common/library/UncheckedIncrement.sol';\nimport {IInitCore} from '../interfaces/core/IInitCore.sol';\nimport {IMulticall} from '../interfaces/common/IMulticall.sol';\nimport {IPosManager} from '../interfaces/core/IPosManager.sol';\nimport {ILendingPool} from '../interfaces/lending_pool/ILendingPool.sol';\nimport {IWNative} from '../interfaces/common/IWNative.sol';\nimport {IRebaseHelper} from '../interfaces/helper/rebase_helper/IRebaseHelper.sol';\nimport {IMoneyMarketHook} from '../interfaces/hook/IMoneyMarketHook.sol';\n\nimport {IERC20} from '@openzeppelin-contracts/token/ERC20/IERC20.sol';\nimport {IERC721} from '@openzeppelin-contracts/token/ERC721/IERC721.sol';\nimport {SafeERC20} from '@openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol';\nimport {ERC721HolderUpgradeable} from\n    '@openzeppelin-contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol';\n\n// NOTE: only support normal money market actions (deposit, withdraw, borrow, repay, change position mode)\ncontract MoneyMarketHook is IMoneyMarketHook, ERC721HolderUpgradeable {\n    using UncheckedIncrement for uint;\n    using SafeERC20 for IERC20;\n\n    // immutables\n    /// @inheritdoc IMoneyMarketHook\n    address public immutable CORE;\n    /// @inheritdoc IMoneyMarketHook\n    address public immutable POS_MANAGER;\n    /// @inheritdoc IMoneyMarketHook\n    address public immutable WNATIVE;\n\n    // storages\n    /// @inheritdoc IMoneyMarketHook\n    mapping(address => uint) public lastPosIds;\n    /// @inheritdoc IMoneyMarketHook\n    mapping(address => mapping(uint => uint)) public initPosIds;\n\n    // constructor\n    constructor(address _initCore, address _wNative) {\n        CORE = _initCore;\n        POS_MANAGER = IInitCore(_initCore).POS_MANAGER();\n        WNATIVE = _wNative;\n        _disableInitializers();\n    }\n\n    // initialize\n    /// @dev initialize the contract\n    function initialize() external initializer {}\n\n    // functions\n    /// @inheritdoc IMoneyMarketHook\n    function execute(OperationParams calldata _params)\n        external\n        payable\n        returns (uint posId, uint initPosId, bytes[] memory results)\n    {\n        // create position if not exist\n        if (_params.posId == 0) {\n            (posId, initPosId) = createPos(_params.mode, _params.viewer);\n        } else {\n            // for existing position, only owner can execute\n            posId = _params.posId;\n            initPosId = initPosIds[msg.sender][posId];\n            _require(IERC721(POS_MANAGER).ownerOf(initPosId) == address(this), Errors.NOT_OWNER);\n        }\n        results = _handleMulticall(initPosId, _params);\n        // check slippage\n        _require(_params.minHealth_e18 <= IInitCore(CORE).getPosHealthCurrent_e18(initPosId), Errors.SLIPPAGE_CONTROL);\n        // unwrap token if needed\n        for (uint i; i < _params.withdrawParams.length; i = i.uinc()) {\n            address helper = _params.withdrawParams[i].rebaseHelperParams.helper;\n            if (helper != address(0)) IRebaseHelper(helper).unwrap(_params.withdrawParams[i].to);\n        }\n        // return native token\n        if (_params.returnNative) {\n            IWNative(WNATIVE).withdraw(IERC20(WNATIVE).balanceOf(address(this)));\n            (bool success,) = payable(msg.sender).call{value: address(this).balance}('');\n            _require(success, Errors.CALL_FAILED);\n        }\n    }\n\n    /// @inheritdoc IMoneyMarketHook\n    function createPos(uint16 _mode, address _viewer) public returns (uint posId, uint initPosId) {\n        posId = ++lastPosIds[msg.sender];\n        initPosId = IInitCore(CORE).createPos(_mode, _viewer);\n        initPosIds[msg.sender][posId] = initPosId;\n    }\n\n    /// @dev approve token for init core if needed\n    /// @param _token token address\n    /// @param _amt token amount to spend\n    function _ensureApprove(address _token, uint _amt) internal {\n        if (IERC20(_token).allowance(address(this), CORE) < _amt) {\n            IERC20(_token).safeApprove(CORE, type(uint).max);\n        }\n    }\n\n    // @dev prepare and execute multicall\n    // @param _initPosId init position id (nft id)\n    // @param _params operation parameters\n    // @return results results of multicall\n    function _handleMulticall(uint _initPosId, OperationParams calldata _params)\n        internal\n        returns (bytes[] memory results)\n    {\n        // prepare data for multicall\n        // 1. repay (if needed)\n        // 2. withdraw (if needed)\n        // 3. change position mode (if needed)\n        // 4. borrow (if needed)\n        // 5. deposit (if needed)\n        bool changeMode = _params.mode != 0 && _params.mode != IPosManager(POS_MANAGER).getPosMode(_initPosId);\n        bytes[] memory data;\n        {\n            uint dataLength = _params.repayParams.length + (2 * _params.withdrawParams.length) + (changeMode ? 1 : 0)\n                + _params.borrowParams.length + (2 * _params.depositParams.length);\n            data = new bytes[](dataLength);\n        }\n        uint offset;\n        // 1. repay\n        (offset, data) = _handleRepay(offset, data, _initPosId, _params.repayParams);\n        // 2. withdraw\n        (offset, data) = _handleWithdraw(offset, data, _initPosId, _params.withdrawParams);\n        // 3. change position mode\n        if (changeMode) {\n            data[offset] = abi.encodeWithSelector(IInitCore.setPosMode.selector, _initPosId, _params.mode);\n            offset = offset.uinc();\n        }\n        // 4. borrow\n        (offset, data) = _handleBorrow(offset, data, _initPosId, _params.borrowParams);\n        // 5. deposit\n        (offset, data) = _handleDeposit(offset, data, _initPosId, _params.depositParams);\n        // execute multicall\n        results = IMulticall(CORE).multicall(data);\n    }\n\n    /// @dev generate repay data for multicall\n    /// @param _offset offset of data\n    /// @param _data multicall data\n    /// @param _initPosId init position id (nft id)\n    /// @param _params repay params\n    /// @return offset new offset\n    /// @return data new data\n    function _handleRepay(uint _offset, bytes[] memory _data, uint _initPosId, RepayParams[] memory _params)\n        internal\n        returns (uint, bytes[] memory)\n    {\n        for (uint i; i < _params.length; i = i.uinc()) {\n            address uToken = ILendingPool(_params[i].pool).underlyingToken();\n            uint repayAmt = ILendingPool(_params[i].pool).debtShareToAmtCurrent(_params[i].shares);\n            _ensureApprove(uToken, repayAmt);\n            IERC20(uToken).safeTransferFrom(msg.sender, address(this), repayAmt);\n            _data[_offset] =\n                abi.encodeWithSelector(IInitCore.repay.selector, _params[i].pool, _params[i].shares, _initPosId);\n            _offset = _offset.uinc();\n        }\n        return (_offset, _data);\n    }\n\n    /// @dev generate withdraw data for multicall\n    /// @param _offset offset of data\n    /// @param _data multicall data\n    /// @param _initPosId init position id (nft id)\n    /// @param _params withdraw params\n    /// @return offset new offset\n    /// @return data new data\n    function _handleWithdraw(uint _offset, bytes[] memory _data, uint _initPosId, WithdrawParams[] calldata _params)\n        internal\n        view\n        returns (uint, bytes[] memory)\n    {\n        for (uint i; i < _params.length; i = i.uinc()) {\n            // decollateralize to pool\n            _data[_offset] = abi.encodeWithSelector(\n                IInitCore.decollateralize.selector, _initPosId, _params[i].pool, _params[i].shares, _params[i].pool\n            );\n            _offset = _offset.uinc();\n            // burn collateral to underlying token\n            address helper = _params[i].rebaseHelperParams.helper;\n            address uTokenReceiver = _params[i].to;\n            // if need to unwrap to rebase token\n            if (helper != address(0)) {\n                address uToken = ILendingPool(_params[i].pool).underlyingToken();\n                _require(\n                    _params[i].rebaseHelperParams.tokenIn == uToken\n                        && IRebaseHelper(_params[i].rebaseHelperParams.helper).YIELD_BEARING_TOKEN() == uToken,\n                    Errors.INVALID_TOKEN_IN\n                );\n                uTokenReceiver = helper;\n            }\n            _data[_offset] = abi.encodeWithSelector(IInitCore.burnTo.selector, _params[i].pool, uTokenReceiver);\n            _offset = _offset.uinc();\n        }\n        return (_offset, _data);\n    }\n\n    /// @dev generate borrow data for multicall\n    /// @param _offset offset of data\n    /// @param _data multicall data\n    /// @param _initPosId init position id (nft id)\n    /// @param _params borrow params\n    /// @return offset new offset\n    /// @return data new data\n    function _handleBorrow(uint _offset, bytes[] memory _data, uint _initPosId, BorrowParams[] calldata _params)\n        internal\n        pure\n        returns (uint, bytes[] memory)\n    {\n        for (uint i; i < _params.length; i = i.uinc()) {\n            _data[_offset] = abi.encodeWithSelector(\n                IInitCore.borrow.selector, _params[i].pool, _params[i].amt, _initPosId, _params[i].to\n            );\n            _offset = _offset.uinc();\n        }\n        return (_offset, _data);\n    }\n\n    /// @dev generate deposit data for multicall\n    /// @param _offset offset of data\n    /// @param _data multicall data\n    /// @param _initPosId init position id (nft id)\n    /// @param _params deposit params\n    /// @return offset new offset\n    /// @return data new data\n    function _handleDeposit(uint _offset, bytes[] memory _data, uint _initPosId, DepositParams[] calldata _params)\n        internal\n        returns (uint, bytes[] memory)\n    {\n        for (uint i; i < _params.length; i = i.uinc()) {\n            address pool = _params[i].pool;\n            uint amt = _params[i].amt;\n            address uToken = ILendingPool(pool).underlyingToken();\n            address helper = _params[i].rebaseHelperParams.helper;\n            // 1. deposit native token\n            // NOTE: use msg.value for native token\n            // amt > 0 mean user want to use wNative too\n            if (uToken == WNATIVE) {\n                IWNative(WNATIVE).deposit{value: msg.value}();\n                IERC20(WNATIVE).safeTransfer(pool, msg.value);\n                // transfer wNative to pool will user want to use wNative\n                if (amt != 0) {\n                    IERC20(WNATIVE).safeTransferFrom(msg.sender, pool, amt);\n                }\n            }\n            // 2. wrap rebase token to non-rebase token and deposit\n            else if (helper != address(0)) {\n                address tokenIn = _params[i].rebaseHelperParams.tokenIn;\n                _require(\n                    IRebaseHelper(_params[i].rebaseHelperParams.helper).REBASE_TOKEN() == tokenIn,\n                    Errors.INVALID_TOKEN_IN\n                );\n                _require(\n                    IRebaseHelper(_params[i].rebaseHelperParams.helper).YIELD_BEARING_TOKEN() == uToken,\n                    Errors.INVALID_TOKEN_OUT\n                );\n                IERC20(tokenIn).safeTransferFrom(msg.sender, helper, amt);\n                IRebaseHelper(helper).wrap(pool);\n            }\n            // 3. deposit normal erc20 token\n            else {\n                IERC20(uToken).safeTransferFrom(msg.sender, pool, amt);\n            }\n            // mint to position\n            _data[_offset] = abi.encodeWithSelector(IInitCore.mintTo.selector, pool, POS_MANAGER);\n            _offset = _offset.uinc();\n            // collateralize\n            _data[_offset] = abi.encodeWithSelector(IInitCore.collateralize.selector, _initPosId, pool);\n            _offset = _offset.uinc();\n        }\n        return (_offset, _data);\n    }\n}"
    },
    {
      "filename": "contracts/hook/MoneyMarketHook.sol",
      "content": "// SPDX-License-Identifier: None\npragma solidity ^0.8.19;\n\nimport '../common/library/InitErrors.sol';\nimport '../common/library/UncheckedIncrement.sol';\nimport {IInitCore} from '../interfaces/core/IInitCore.sol';\nimport {IMulticall} from '../interfaces/common/IMulticall.sol';\nimport {IPosManager} from '../interfaces/core/IPosManager.sol';\nimport {ILendingPool} from '../interfaces/lending_pool/ILendingPool.sol';\nimport {IWNative} from '../interfaces/common/IWNative.sol';\nimport {IRebaseHelper} from '../interfaces/helper/rebase_helper/IRebaseHelper.sol';\nimport {IMoneyMarketHook} from '../interfaces/hook/IMoneyMarketHook.sol';\n\nimport {IERC20} from '@openzeppelin-contracts/token/ERC20/IERC20.sol';\nimport {IERC721} from '@openzeppelin-contracts/token/ERC721/IERC721.sol';\nimport {SafeERC20} from '@openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol';\nimport {ERC721HolderUpgradeable} from\n    '@openzeppelin-contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol';\n\n// NOTE: only support normal money market actions (deposit, withdraw, borrow, repay, change position mode)\ncontract MoneyMarketHook is IMoneyMarketHook, ERC721HolderUpgradeable {\n    using UncheckedIncrement for uint;\n    using SafeERC20 for IERC20;\n\n    // immutables\n    /// @inheritdoc IMoneyMarketHook\n    address public immutable CORE;\n    /// @inheritdoc IMoneyMarketHook\n    address public immutable POS_MANAGER;\n    /// @inheritdoc IMoneyMarketHook\n    address public immutable WNATIVE;\n\n    // storages\n    /// @inheritdoc IMoneyMarketHook\n    mapping(address => uint) public lastPosIds;\n    /// @inheritdoc IMoneyMarketHook\n    mapping(address => mapping(uint => uint)) public initPosIds;\n\n    // constructor\n    constructor(address _initCore, address _wNative) {\n        CORE = _initCore;\n        POS_MANAGER = IInitCore(_initCore).POS_MANAGER();\n        WNATIVE = _wNative;\n        _disableInitializers();\n    }\n\n    // initialize\n    /// @dev initialize the contract\n    function initialize() external initializer {}\n\n    // functions\n    /// @inheritdoc IMoneyMarketHook\n    function execute(OperationParams calldata _params)\n        external\n        payable\n        returns (uint posId, uint initPosId, bytes[] memory results)\n    {\n        // create position if not exist\n        if (_params.posId == 0) {\n            (posId, initPosId) = createPos(_params.mode, _params.viewer);\n        } else {\n            // for existing position, only owner can execute\n            posId = _params.posId;\n            initPosId = initPosIds[msg.sender][posId];\n            _require(IERC721(POS_MANAGER).ownerOf(initPosId) == address(this), Errors.NOT_OWNER);\n        }\n        results = _handleMulticall(initPosId, _params);\n        // check slippage\n        _require(_params.minHealth_e18 <= IInitCore(CORE).getPosHealthCurrent_e18(initPosId), Errors.SLIPPAGE_CONTROL);\n        // unwrap token if needed\n        for (uint i; i < _params.withdrawParams.length; i = i.uinc()) {\n            address helper = _params.withdrawParams[i].rebaseHelperParams.helper;\n            if (helper != address(0)) IRebaseHelper(helper).unwrap(_params.withdrawParams[i].to);\n        }\n        // return native token\n        if (_params.returnNative) {\n            IWNative(WNATIVE).withdraw(IERC20(WNATIVE).balanceOf(address(this)));\n            (bool success,) = payable(msg.sender).call{value: address(this).balance}('');\n            _require(success, Errors.CALL_FAILED);\n        }\n    }\n\n    /// @inheritdoc IMoneyMarketHook\n    function createPos(uint16 _mode, address _viewer) public returns (uint posId, uint initPosId) {\n        posId = ++lastPosIds[msg.sender];\n        initPosId = IInitCore(CORE).createPos(_mode, _viewer);\n        initPosIds[msg.sender][posId] = initPosId;\n    }\n\n    /// @dev approve token for init core if needed\n    /// @param _token token address\n    /// @param _amt token amount to spend\n    function _ensureApprove(address _token, uint _amt) internal {\n        if (IERC20(_token).allowance(address(this), CORE) < _amt) {\n            IERC20(_token).safeApprove(CORE, type(uint).max);\n        }\n    }\n\n    // @dev prepare and execute multicall\n    // @param _initPosId init position id (nft id)\n    // @param _params operation parameters\n    // @return results results of multicall\n    function _handleMulticall(uint _initPosId, OperationParams calldata _params)\n        internal\n        returns (bytes[] memory results)\n    {\n        // prepare data for multicall\n        // 1. repay (if needed)\n        // 2. withdraw (if needed)\n        // 3. change position mode (if needed)\n        // 4. borrow (if needed)\n        // 5. deposit (if needed)\n        bool changeMode = _params.mode != 0 && _params.mode != IPosManager(POS_MANAGER).getPosMode(_initPosId);\n        bytes[] memory data;\n        {\n            uint dataLength = _params.repayParams.length + (2 * _params.withdrawParams.length) + (changeMode ? 1 : 0)\n                + _params.borrowParams.length + (2 * _params.depositParams.length);\n            data = new bytes[](dataLength);\n        }\n        uint offset;\n        // 1. repay\n        (offset, data) = _handleRepay(offset, data, _initPosId, _params.repayParams);\n        // 2. withdraw\n        (offset, data) = _handleWithdraw(offset, data, _initPosId, _params.withdrawParams);\n        // 3. change position mode\n        if (changeMode) {\n            data[offset] = abi.encodeWithSelector(IInitCore.setPosMode.selector, _initPosId, _params.mode);\n            offset = offset.uinc();\n        }\n        // 4. borrow\n        (offset, data) = _handleBorrow(offset, data, _initPosId, _params.borrowParams);\n        // 5. deposit\n        (offset, data) = _handleDeposit(offset, data, _initPosId, _params.depositParams);\n        // execute multicall\n        results = IMulticall(CORE).multicall(data);\n    }\n\n    /// @dev generate repay data for multicall\n    /// @param _offset offset of data\n    /// @param _data multicall data\n    /// @param _initPosId init position id (nft id)\n    /// @param _params repay params\n    /// @return offset new offset\n    /// @return data new data\n    function _handleRepay(uint _offset, bytes[] memory _data, uint _initPosId, RepayParams[] memory _params)\n        internal\n        returns (uint, bytes[] memory)\n    {\n        for (uint i; i < _params.length; i = i.uinc()) {\n            address uToken = ILendingPool(_params[i].pool).underlyingToken();\n            uint repayAmt = ILendingPool(_params[i].pool).debtShareToAmtCurrent(_params[i].shares);\n            _ensureApprove(uToken, repayAmt);\n            IERC20(uToken).safeTransferFrom(msg.sender, address(this), repayAmt);\n            _data[_offset] =\n                abi.encodeWithSelector(IInitCore.repay.selector, _params[i].pool, _params[i].shares, _initPosId);\n            _offset = _offset.uinc();\n        }\n        return (_offset, _data);\n    }\n\n    /// @dev generate withdraw data for multicall\n    /// @param _offset offset of data\n    /// @param _data multicall data\n    /// @param _initPosId init position id (nft id)\n    /// @param _params withdraw params\n    /// @return offset new offset\n    /// @return data new data\n    function _handleWithdraw(uint _offset, bytes[] memory _data, uint _initPosId, WithdrawParams[] calldata _params)\n        internal\n        view\n        returns (uint, bytes[] memory)\n    {\n        for (uint i; i < _params.length; i = i.uinc()) {\n            // decollateralize to pool\n            _data[_offset] = abi.encodeWithSelector(\n                IInitCore.decollateralize.selector, _initPosId, _params[i].pool, _params[i].shares, _params[i].pool\n            );\n            _offset = _offset.uinc();\n            // burn collateral to underlying token\n            address helper = _params[i].rebaseHelperParams.helper;\n            address uTokenReceiver = _params[i].to;\n            // if need to unwrap to rebase token\n            if (helper != address(0)) {\n                address uToken = ILendingPool(_params[i].pool).underlyingToken();\n                _require(\n                    _params[i].rebaseHelperParams.tokenIn == uToken\n                        && IRebaseHelper(_params[i].rebaseHelperParams.helper).YIELD_BEARING_TOKEN() == uToken,\n                    Errors.INVALID_TOKEN_IN\n                );\n                uTokenReceiver = helper;\n            }\n            _data[_offset] = abi.encodeWithSelector(IInitCore.burnTo.selector, _params[i].pool, uTokenReceiver);\n            _offset = _offset.uinc();\n        }\n        return (_offset, _data);\n    }\n\n    /// @dev generate borrow data for multicall\n    /// @param _offset offset of data\n    /// @param _data multicall data\n    /// @param _initPosId init position id (nft id)\n    /// @param _params borrow params\n    /// @return offset new offset\n    /// @return data new data\n    function _handleBorrow(uint _offset, bytes[] memory _data, uint _initPosId, BorrowParams[] calldata _params)\n        internal\n        pure\n        returns (uint, bytes[] memory)\n    {\n        for (uint i; i < _params.length; i = i.uin"
    }
  ]
}