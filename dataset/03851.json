{
  "Title": "Budget payment blocking",
  "Content": "##### Description\nIn `pay` function of `Budget.sol` contract defined at https://github.com/bondappetit/bondappetit-protocol/blob/355180f0aca0b29d60d808f761052956b7a3a159/contracts/Budget.sol#L109 contract sends ETH to recipients in loop using `transfer` method. As we know `transfer` method limited by 2300 gas, so any single recipient with payable fallback method can block whole `pay` function execution\n\n##### Recommendation\nWe recommend to rework payment scheme to claimable model.\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/Budget.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"./utils/OwnablePausable.sol\";\n\ncontract Budget is OwnablePausable {\n    using SafeMath for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @dev Expenditure item.\n    struct Expenditure {\n        address recipient;\n        uint256 min;\n        uint256 target;\n    }\n\n    /// @notice Expenditure item to address.\n    mapping(address => Expenditure) public expenditures;\n\n    /// @dev Recipients addresses list.\n    EnumerableSet.AddressSet internal recipients;\n\n    /// @notice An event emitted when expenditure item changed.\n    event ExpenditureChanged(address recipient, uint256 min, uint256 target);\n\n    /// @notice An event emitted when expenditure item payed.\n    event Payed(address recipient, uint256 amount);\n\n    receive() external payable {}\n\n    /**\n     * @notice Change expenditure item.\n     * @param recipient Recipient address.\n     * @param min Minimal balance for payment.\n     * @param target Target balance.\n     */\n    function changeExpenditure(\n        address recipient,\n        uint256 min,\n        uint256 target\n    ) external onlyOwner {\n        require(min <= target, \"Budget::changeExpenditure: minimal balance should be less or equal target balance\");\n\n        expenditures[recipient] = Expenditure(recipient, min, target);\n        if (target > 0) {\n            recipients.add(recipient);\n        } else {\n            recipients.remove(recipient);\n        }\n        emit ExpenditureChanged(recipient, min, target);\n    }\n\n    /**\n     * @notice Transfer ETH to recipient.\n     * @param recipient Recipient.\n     * @param amount Transfer amount.\n     */\n    function transferETH(address payable recipient, uint256 amount) external onlyOwner returns (bool) {\n        recipient.transfer(amount);\n        return true;\n    }\n\n    /**\n     * @notice Return all recipients addresses.\n     * @return Recipients addresses.\n     */\n    function getRecipients() external view returns (address[] memory) {\n        address[] memory result = new address[](recipients.length());\n\n        for (uint256 i = 0; i < recipients.length(); i++) {\n            result[i] = recipients.at(i);\n        }\n\n        return result;\n    }\n\n    /**\n     * @notice Return balance deficit of recipient.\n     * @param recipient Target recipient.\n     * @return Balance deficit of recipient.\n     */\n    function deficitTo(address recipient) public view returns (uint256) {\n        require(recipients.contains(recipient), \"Budget::deficitTo: recipient not in expenditure item\");\n        if (recipient.balance > expenditures[recipient].min) return 0;\n\n        return expenditures[recipient].target.sub(recipient.balance);\n    }\n\n    /**\n     * @notice Return summary balance deficit of all recipients.\n     * @return Summary balance deficit of all recipients.\n     */\n    function deficit() public view returns (uint256) {\n        uint256 result;\n\n        for (uint256 i = 0; i < recipients.length(); i++) {\n            result = result.add(deficitTo(recipients.at(i)));\n        }\n\n        return result;\n    }\n\n    /**\n     * @notice Pay ETH to all recipients with balance deficit.\n     */\n    function pay() external {\n        for (uint256 i = 0; i < recipients.length(); i++) {\n            uint256 balance = address(this).balance;\n            address recipient = recipients.at(i);\n            uint256 amount = deficitTo(recipient);\n            if (amount == 0 || balance < amount) continue;\n\n            payable(recipient).transfer(amount);\n            emit Payed(recipient, amount);\n        }\n    }\n}"
    }
  ]
}