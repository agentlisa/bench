{
  "Title": "M-3: `_withdrawFromPlugin()` will revert when `_withdrawalValues[i] == 0`",
  "Content": "# Issue M-3: `_withdrawFromPlugin()` will revert when `_withdrawalValues[i] == 0` \n\nSource: https://github.com/sherlock-audit/2022-10-mycelium-judging/tree/main/013-M \n\n## Found by \nctf\\_sec, hansfriese, WATCHPUG\n\n## Summary\n\n## Vulnerability Detail\n\nWhen `_withdrawalValues[i] == 0` in `rebalancePlugins()`, it means NOT to rebalance this plugin.\n\nHowever, the current implementation still tries to withdraw 0 from the plugin.\n\nThis will revert in AaveV2Plugin as Aave V2's `validateWithdraw()` does not allow `0` withdrawals:\n\nhttps://github.com/aave/protocol-v2/blob/554a2ed7ca4b3565e2ceaea0c454e5a70b3a2b41/contracts/protocol/libraries/logic/ValidationLogic.sol#L60-L70\n\n```solidity\n  function validateWithdraw(\n    address reserveAddress,\n    uint256 amount,\n    uint256 userBalance,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    DataTypes.UserConfigurationMap storage userConfig,\n    mapping(uint256 => address) storage reserves,\n    uint256 reservesCount,\n    address oracle\n  ) external view {\n    require(amount != 0, Errors.VL_INVALID_AMOUNT);\n```\n\n`removePlugin()` will also always `_withdrawFromPlugin()` even if the plugin's balance is 0, as it will also tries to withdraw 0 in that case (balance is 0).\n\n## Impact\n\nFor AaveV2Plugin (and any future plugins that dont allow withdraw 0):\n\n1. In every rebalance call, it must at least withdraw 1 wei from the plugin for the rebalance to work.\n2. The plugin can not be removed or rebalanced when there is no balance in it. \n\nIf such a plugin can not deposit for some reason (paused by gov, AaveV2Plugin may face that), this will further cause the whole system unable to be rebalanced until the deposit resumes for that plugin.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-10-mycelium/blob/main/mylink-contracts/src/Vault.sol#L367-L373\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nOnly call `_withdrawFromPlugin()` when `IPlugin(pluginAddr).balance() > 0`:\n\n```solidity\nfunction removePlugin(uint256 _index) external onlyOwner {\n    require(_index < pluginCount, \"Index out of bounds\");\n    address pluginAddr = plugins[_index];\n    if (IPlugin(pluginAddr).balance() > 0){\n        _withdrawFromPlugin(pluginAddr, IPlugin(pluginAddr).balance());\n    }\n    uint256 pointer = _index;\n    while (pointer < pluginCount - 1) {\n        plugins[pointer] = plugins[pointer + 1];\n        pointer++;\n    }\n    delete plugins[pluginCount - 1];\n    pluginCount--;\n\n    IERC20(LINK).approve(pluginAddr, 0);\n\n    emit PluginRemoved(pluginAddr);\n}\n```\n\n```solidity\nfunction rebalancePlugins(uint256[] memory _withdrawalValues) external onlyOwner {\n    require(_withdrawalValues.length == pluginCount, \"Invalid withdrawal values\");\n    for (uint256 i = 0; i < pluginCount; i++) {\n        if (_withdrawalValues[i] > 0)\n            _withdrawFromPlugin(plugins[i], _withdrawalValues[i]);\n    }\n    _distributeToPlugins();\n}\n```\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/7",
  "Code": [
    {
      "filename": "contracts/protocol/libraries/logic/ValidationLogic.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from '../../../dependencies/openzeppelin/contracts/SafeMath.sol';\nimport {IERC20} from '../../../dependencies/openzeppelin/contracts/IERC20.sol';\nimport {ReserveLogic} from './ReserveLogic.sol';\nimport {GenericLogic} from './GenericLogic.sol';\nimport {WadRayMath} from '../math/WadRayMath.sol';\nimport {PercentageMath} from '../math/PercentageMath.sol';\nimport {SafeERC20} from '../../../dependencies/openzeppelin/contracts/SafeERC20.sol';\nimport {ReserveConfiguration} from '../configuration/ReserveConfiguration.sol';\nimport {UserConfiguration} from '../configuration/UserConfiguration.sol';\nimport {Errors} from '../helpers/Errors.sol';\nimport {Helpers} from '../helpers/Helpers.sol';\nimport {IReserveInterestRateStrategy} from '../../../interfaces/IReserveInterestRateStrategy.sol';\nimport {DataTypes} from '../types/DataTypes.sol';\n\n/**\n * @title ReserveLogic library\n * @author Aave\n * @notice Implements functions to validate the different actions of the protocol\n */\nlibrary ValidationLogic {\n  using ReserveLogic for DataTypes.ReserveData;\n  using SafeMath for uint256;\n  using WadRayMath for uint256;\n  using PercentageMath for uint256;\n  using SafeERC20 for IERC20;\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n  using UserConfiguration for DataTypes.UserConfigurationMap;\n\n  uint256 public constant REBALANCE_UP_LIQUIDITY_RATE_THRESHOLD = 4000;\n  uint256 public constant REBALANCE_UP_USAGE_RATIO_THRESHOLD = 0.95 * 1e27; //usage ratio of 95%\n\n  /**\n   * @dev Validates a deposit action\n   * @param reserve The reserve object on which the user is depositing\n   * @param amount The amount to be deposited\n   */\n  function validateDeposit(DataTypes.ReserveData storage reserve, uint256 amount) external view {\n    (bool isActive, bool isFrozen, , ) = reserve.configuration.getFlags();\n\n    require(amount != 0, Errors.VL_INVALID_AMOUNT);\n    require(isActive, Errors.VL_NO_ACTIVE_RESERVE);\n    require(!isFrozen, Errors.VL_RESERVE_FROZEN);\n  }\n\n  /**\n   * @dev Validates a withdraw action\n   * @param reserveAddress The address of the reserve\n   * @param amount The amount to be withdrawn\n   * @param userBalance The balance of the user\n   * @param reservesData The reserves state\n   * @param userConfig The user configuration\n   * @param reserves The addresses of the reserves\n   * @param reservesCount The number of reserves\n   * @param oracle The price oracle\n   */\n  function validateWithdraw(\n    address reserveAddress,\n    uint256 amount,\n    uint256 userBalance,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    DataTypes.UserConfigurationMap storage userConfig,\n    mapping(uint256 => address) storage reserves,\n    uint256 reservesCount,\n    address oracle\n  ) external view {\n    require(amount != 0, Errors.VL_INVALID_AMOUNT);\n    require(amount <= userBalance, Errors.VL_NOT_ENOUGH_AVAILABLE_USER_BALANCE);\n\n    (bool isActive, , , ) = reservesData[reserveAddress].configuration.getFlags();\n    require(isActive, Errors.VL_NO_ACTIVE_RESERVE);\n\n    require(\n      GenericLogic.balanceDecreaseAllowed(\n        reserveAddress,\n        msg.sender,\n        amount,\n        reservesData,\n        userConfig,\n        reserves,\n        reservesCount,\n        oracle\n      ),\n      Errors.VL_TRANSFER_NOT_ALLOWED\n    );\n  }\n\n  struct ValidateBorrowLocalVars {\n    uint256 currentLtv;\n    uint256 currentLiquidationThreshold;\n    uint256 amountOfCollateralNeededETH;\n    uint256 userCollateralBalanceETH;\n    uint256 userBorrowBalanceETH;\n    uint256 availableLiquidity;\n    uint256 healthFactor;\n    bool isActive;\n    bool isFrozen;\n    bool borrowingEnabled;\n    bool stableRateBorrowingEnabled;\n  }\n\n  /**\n   * @dev Validates a borrow action\n   * @param asset The address of the asset to borrow\n   * @param reserve The reserve state from which the user is borrowing\n   * @param userAddress The address of the user\n   * @param amount The amount to be borrowed\n   * @param amountInETH The amount to be borrowed, in ETH\n   * @param interestRateMode The interest rate mode at which the user is borrowing\n   * @param maxStableLoanPercent The max amount of the liquidity that can be borrowed at stable rate, in percentage\n   * @param reservesData The state of all the reserves\n   * @param userConfig The state of the user for the specific reserve\n   * @param reserves The addresses of all the active reserves\n   * @param oracle The price oracle\n   */\n\n  function validateBorrow(\n    address asset,\n    DataTypes.ReserveData storage reserve,\n    address userAddress,\n    uint256 amount,\n    uint256 amountInETH,\n    uint256 interestRateMode,\n    uint256 maxStableLoanPercent,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    DataTypes.UserConfigurationMap storage userConfig,\n    mapping(uint256 => address) storage reserves,\n    uint256 reservesCount,\n    address oracle\n  ) external view {\n    ValidateBorrowLocalVars memory vars;\n\n    (vars.isActive, vars.isFrozen, vars.borrowingEnabled, vars.stableRateBorrowingEnabled) = reserve\n      .configuration\n      .getFlags();\n\n    require(vars.isActive, Errors.VL_NO_ACTIVE_RESERVE);\n    require(!vars.isFrozen, Errors.VL_RESERVE_FROZEN);\n    require(amount != 0, Errors.VL_INVALID_AMOUNT);\n\n    require(vars.borrowingEnabled, Errors.VL_BORROWING_NOT_ENABLED);\n\n    //validate interest rate mode\n    require(\n      uint256(DataTypes.InterestRateMode.VARIABLE) == interestRateMode ||\n        uint256(DataTypes.InterestRateMode.STABLE) == interestRateMode,\n      Errors.VL_INVALID_INTEREST_RATE_MODE_SELECTED\n    );\n\n    (\n      vars.userCollateralBalanceETH,\n      vars.userBorrowBalanceETH,\n      vars.currentLtv,\n      vars.currentLiquidationThreshold,\n      vars.healthFactor\n    ) = GenericLogic.calculateUserAccountData(\n      userAddress,\n      reservesData,\n      userConfig,\n      reserves,\n      reservesCount,\n      oracle\n    );\n\n    require(vars.userCollateralBalanceETH > 0, Errors.VL_COLLATERAL_BALANCE_IS_0);\n\n    require(\n      vars.healthFactor > GenericLogic.HEALTH_FACTOR_LIQUIDATION_THRESHOLD,\n      Errors.VL_HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD\n    );\n\n    //add the current already borrowed amount to the amount requested to calculate the total collateral needed.\n    vars.amountOfCollateralNeededETH = vars.userBorrowBalanceETH.add(amountInETH).percentDiv(\n      vars.currentLtv\n    ); //LTV is calculated in percentage\n\n    require(\n      vars.amountOfCollateralNeededETH <= vars.userCollateralBalanceETH,\n      Errors.VL_COLLATERAL_CANNOT_COVER_NEW_BORROW\n    );\n\n    /**\n     * Following conditions need to be met if the user is borrowing at a stable rate:\n     * 1. Reserve must be enabled for stable rate borrowing\n     * 2. Users cannot borrow from the reserve if their collateral is (mostly) the same currency\n     *    they are borrowing, to prevent abuses.\n     * 3. Users will be able to borrow only a portion of the total available liquidity\n     **/\n\n    if (interestRateMode == uint256(DataTypes.InterestRateMode.STABLE)) {\n      //check if the borrow mode is stable and if stable rate borrowing is enabled on this reserve\n\n      require(vars.stableRateBorrowingEnabled, Errors.VL_STABLE_BORROWING_NOT_ENABLED);\n\n      require(\n        !userConfig.isUsingAsCollateral(reserve.id) ||\n          reserve.configuration.getLtv() == 0 ||\n          amount > IERC20(reserve.aTokenAddress).balanceOf(userAddress),\n        Errors.VL_COLLATERAL_SAME_AS_BORROWING_CURRENCY\n      );\n\n      vars.availableLiquidity = IERC20(asset).balanceOf(reserve.aTokenAddress);\n\n      //calculate the max available loan size in stable rate mode as a percentage of the\n      //available liquidity\n      uint256 maxLoanSizeStable = vars.availableLiquidity.percentMul(maxStableLoanPercent);\n\n      require(amount <= maxLoanSizeStable, Errors.VL_AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE);\n    }\n  }\n\n  /**\n   * @dev Validates a repay action\n   * @param reserve The reserve state from which the user is repaying\n   * @param amountSent The amount sent for the repayment. Can be an actual value or uint(-1)\n   * @param onBehalfOf The address of the user msg.sender is repaying for\n   * @param stableDebt The borrow balance of the user\n   * @param variableDebt The borrow balance of the user\n   */\n  function validateRepay(\n    DataTypes.ReserveData storage reserve,\n    uint256 amountSent,\n    DataTypes.InterestRateMode rateMode,\n    address onBehalfOf,\n    uint256 stableDebt,\n    uint256 variableDebt\n  ) external view {\n    bool isActive = reserve.configuration.getActive();\n\n    require(isActive, Errors.VL_NO_ACTIVE_RESERVE);\n\n    require(amountSent > 0, Errors.VL_INVALID_AMOUNT);\n\n    require(\n      (stableDebt > 0 &&\n        DataTypes.InterestRateMode(rateMode) == DataTypes.InterestRateMode.STABLE) ||\n        (variableDebt > 0 &&\n          DataTypes.InterestRateMode(rateMode) == DataTypes.InterestRateMode.VARIABLE),\n      Errors.VL_NO_DEBT_OF_SELECTED_TYPE\n    );\n\n    require(\n      amountSent != uint256(-1) || msg.sender == onBehalfOf,\n      Errors.VL_NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF\n    );\n  }\n\n  /**\n   * @dev Validates a swap of borrow rate mode.\n   * @param reserve The reserve state on which the user is swapping the rate\n   * @param userConfig The user reserves configuration\n   * @param stableDebt The stable debt of the user\n   * @param variableDebt The variable debt of the user\n   * @param currentRateMode The rate mode of the borrow\n   */\n  function validateSwapRateMode(\n    DataTypes.ReserveData storage reserve,\n    DataTypes.UserConfigurationMap storage userConfig,\n    uint256 stableDebt,\n    uint256 variableDebt,\n    DataTypes.InterestRateMode currentRateMode\n  ) external view {\n    (bool isActive, bool isFrozen, , bool stableRateEnabled) = reserve.configuration.getFlags();\n\n    require(isActive, Errors.VL_NO_ACTIVE_RESERVE);\n    require(!isFrozen, Errors.VL_RESERVE_FROZEN);\n\n    if (currentRateMode == DataTypes.InterestRateMode.STABLE) {\n      require(stableDebt > 0, Errors.VL_NO_STABLE_RATE_LOAN_IN_RESERVE);\n    } else if (currentRateMode == DataTypes.InterestRateMode.VARIABLE) {\n      require(variableDebt > 0, Errors.VL_NO_VARIABLE_RATE_LOAN_IN_RESERVE);\n      /**\n       * user wants to swap to stable, before swapping we need to ensure that\n       * 1. stable borrow rate is enabled on the reserve\n       * 2. user is not trying to abuse the reserve by depositing\n       * more collateral than he is borrowing, artificially lowering\n       * the interest rate, borrowing at variable, and switching to stable\n       **/\n      require(stableRateEnabled, Errors.VL_STABLE_BORROWING_NOT_ENABLED);\n\n      require(\n        !userConfig.isUsingAsCollateral(reserve.id) ||\n          reserve.configuration.getLtv() == 0 ||\n          stableDebt.add(variableDebt) > IERC20(reserve.aTokenAddress).balanceOf(msg.sender),\n        Errors.VL_COLLATERAL_SAME_AS_BORROWING_CURRENCY\n      );\n    } else {\n      revert(Errors.VL_INVALID_INTEREST_RATE_MODE_SELECTED);\n    }\n  }\n\n  /**\n   * @dev Validates a stable borrow rate rebalance action\n   * @param reserve The reserve state on which the user is getting rebalanced\n   * @param reserveAddress The address of the reserve\n   * @param stableDebtToken The stable debt token instance\n   * @param variableDebtToken The variable debt token instance\n   * @param aTokenAddress The address of the aToken contract\n   */\n  function validateRebalanceStableBorrowRate(\n    DataTypes.ReserveData storage reserve,\n    address reserveAddress,\n    IERC20 stableDebtToken,\n    IERC20 variableDebtToken,\n    address aTokenAddress\n  ) external view {\n    (bool isActive, , , ) = reserve.configuration.getFlags();\n\n    require(isActive, Errors.VL_NO_ACTIVE_RESERVE);\n\n    //if the usage ratio is below 95%, no rebalances are needed\n    uint256 totalDebt =\n      stableDebtToken.totalSupply().add(variableDebtToken.totalSupply()).wadToRay();\n    uint256 availableLiquidity = IERC20(reserveAddress).balanceOf(aTokenAddress).wadToRay();\n    uint256 usageRatio = totalDebt == 0 ? 0 : totalDebt.rayDiv(availableLiquidity.add(totalDebt));\n\n    //if the liquidity rate is below REBALANCE_UP_THRESHOLD of the max variable APR at 95% usage,\n    //then we allow rebalancing of the stable rate positions.\n\n    uint256 currentLiquidityRate = reserve.currentLiquidityRate;\n    uint256 maxVariableBorrowRate =\n      IReserveInterestRateStrategy(reserve.interestRateStrategyAddress).getMaxVariableBorrowRate();\n\n    require(\n      usageRatio >= REBALANCE_UP_USAGE_RATIO_THRESHOLD &&\n        currentLiquidityRate <=\n        maxVariableBorrowRate.percentMul(REBALANCE_UP_LIQUIDITY_RATE_THRESHOLD),\n      Errors.LP_INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET\n    );\n  }\n\n  /**\n   * @dev Validates the action of setting an asset as collateral\n   * @param reserve The state of the reserve that the user is enabling or disabling as collateral\n   * @param reserveAddress The address of the reserve\n   * @param reservesData The data of all the reserves\n   * @param userConfig The state of the user for the specific reserve\n   * @param reserves The addresses of all the active reserves\n   * @param oracle The price oracle\n   */\n  function validateSetUseReserveAsCollateral(\n    DataTypes.ReserveData storage reserve,\n    address reserveAddress,\n    bool useAsCollateral,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    DataTypes.UserConfigurationMap storage userConfig,\n    mapping(uint256 => address) storage reserves,\n    uint256 reservesCount,\n    address oracle\n  ) external view {\n    uint256 underlyingBalance = IERC20(reserve.aTokenAddress).balanceOf(msg.sender);\n\n    require(underlyingBalance > 0, Errors.VL_UNDERLYING_BALANCE_NOT_GREATER_THAN_0);\n\n    require(\n      useAsCollateral ||\n        GenericLogic.balanceDecreaseAllowed(\n          reserveAddress,\n          msg.sender,\n          underlyingBalance,\n          reservesData,\n          userConfig,\n          reserves,\n          reservesCount,\n          oracle\n        ),\n      Errors.VL_DEPOSIT_ALREADY_IN_USE\n    );\n  }\n\n  /**\n   * @dev Validates a flashloan action\n   * @param assets The assets being flashborrowed\n   * @param amounts The amounts for each asset being borrowed\n   **/\n  function validateFlashloan(address[] memory assets, uint256[] memory amounts) internal pure {\n    require(assets.length == amounts.length, Errors.VL_INCONSISTENT_FLASHLOAN_PARAMS);\n  }\n\n  /**\n   * @dev Validates the liquidation action\n   * @param collateralReserve The reserve data of the collateral\n   * @param principalReserve The reserve data of the principal\n   * @param userConfig The user configuration\n   * @param userHealthFactor The user's health factor\n   * @param userStableDebt Total stable debt balance of the user\n   * @param userVariableDebt Total variable debt balance of the user\n   **/\n  function validateLiquidationCall(\n    DataTypes.ReserveData storage collateralReserve,\n    DataTypes.ReserveData storage principalReserve,\n    DataTypes.UserConfigurationMap storage userConfig,\n    uint256 userHealthFactor,\n    uint256 userStableDebt,\n    uint256 userVariableDebt\n  ) internal view returns (uint256, string memory) {\n    if (\n      !collateralReserve.configuration.getActive() || !principalReserve.configuration.getActive()\n    ) {\n      return (\n        uint256(Errors.CollateralManagerErrors.NO_ACTIVE_RESERVE),\n        Errors.VL_NO_ACTIVE_RESERVE\n      );\n    }\n\n    if (userHealthFactor >= GenericLogic.HEALTH_FACTOR_LIQUIDATION_THRESHOLD) {\n      return (\n        uint256(Errors.CollateralManagerErrors.HEALTH_FACTOR_ABOVE_THRESHOLD),\n        Errors.LPCM_HEALTH_FACTOR_NOT_BELOW_THRESHOLD\n      );\n    }\n\n    bool isCollateralEnabled =\n      collateralReserve.configuration.getLiquidationThreshold() > 0 &&\n        userConfig.isUsingAsCollateral(collateralReserve.id);\n\n    //if collateral isn't enabled as collateral by user, it cannot be liquidated\n    if (!isCollateralEnabled) {\n      return (\n        uint256(Errors.CollateralManagerErrors.COLLATERAL_CANNOT_BE_LIQUIDATED),\n        Errors.LPCM_COLLATERAL_CANNOT_BE_LIQUIDATED\n      );\n    }\n\n    if (userStableDebt == 0 && userVariableDebt == 0) {\n      return (\n        uint256(Errors.CollateralManagerErrors.CURRRENCY_NOT_BORROWED),\n        Errors.LPCM_SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER\n      );\n    }\n\n    return (uint256(Errors.CollateralManagerErrors.NO_ERROR), Errors.LPCM_NO_ERRORS);\n  }\n\n  /**\n   * @dev Validates an aToken transfer\n   * @param from The user from which the aTokens are being transferred\n   * @param reservesData The state of all the reserves\n   * @param userConfig The state of the user for the specific reserve\n   * @param reserves The addresses of all the active reserves\n   * @param oracle The price oracle\n   */\n  function validateTransfer(\n    address from,\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    DataTypes.UserConfigurationMap storage userConfig,\n    mapping(uint256 => address) storage reserves,\n    uint256 reservesCount,\n    address oracle\n  ) internal view {\n    (, , , , uint256 healthFactor) =\n      GenericLogic.calculateUserAccountData(\n        from,\n        reservesData,\n        userConfig,\n        reserves,\n        reservesCount,\n        oracle\n      );\n\n    require(\n      healthFactor >= GenericLogic.HEALTH_FACTOR_LIQUIDATION_THRESHOLD,\n      Errors.VL_TRANSFER_NOT_ALLOWED\n    );\n  }\n}"
    },
    {
      "filename": "mylink-contracts/src/Vault.sol",
      "content": "// SPDX-License-Identifier: CC-BY-NC-ND-4.0\npragma solidity ^0.8.9;\n\nimport \"openzeppelin/token/ERC20/IERC20.sol\";\nimport \"openzeppelin/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"openzeppelin/proxy/utils/UUPSUpgradeable.sol\";\nimport \"openzeppelin/proxy/utils/Initializable.sol\";\nimport \"./plugins/IPlugin.sol\";\nimport \"solmate/utils/FixedPointMathLib.sol\";\nimport \"./interfaces/IERC677.sol\";\n\n/**\n * @title Interest bearing ERC20 token for LINK staked to Mycelium's node\n *\n * myLINK balances are dynamic. They represent the holder's share in the total amount of\n * LINK controlled by the Vault. An account's balance is calculated as:\n *\n *      shares[account] * totalSupply() / totalShares()\n *\n * Mints, transfers, and burns operate on the equivalent number of shares, rather than the balance\n * directly. This allows the balance to change over time without requiring an infeasible number of\n * storage updates.\n *\n * Conversions between myLINK and shares will not always be exact due to rounding errors. For example,\n * if there are 100 shares and 200 myLINK in the Vault, the smallest possible transfer is 2 myLINK.\n */\n\ncontract Vault is IERC20, IERC20Metadata, IERC677Receiver, UUPSUpgradeable, Initializable {\n    using FixedPointMathLib for uint256;\n\n    /**\n     * @notice Address with owner privileges\n     * @dev Set in the initializer\n     */\n    address public owner;\n\n    /// @notice The number of decimals the token uses\n    /// @dev This should be the same as the LINK token\n    uint8 public decimals;\n\n    /// @notice The address of the LINK token\n    address public LINK;\n\n    /// @notice The maximum amount of LINK that can be deposited into the Vault\n    /// @dev This is required to prevent integer overflow errors in the myLINK balance calculations\n    uint256 public MAX_CAPACITY;\n\n    /// @notice The initial number of shares per LINK deposited\n    uint256 public STARTING_SHARES_PER_LINK;\n\n    /**\n     * @dev myLINK balances are dynamic and are determined by the total amount of LINK controlled by\n     * the Vault and the user's portion of the total shares\n     */\n    uint256 public totalShares;\n    mapping(address => uint256) public shares;\n\n    /**\n     * @dev Plugins earn yield for the LINK in the vault. They have a capacity limit and are indexed by priority.\n     * LINK is allocated to plugins with lower priority number first, and removed in reverse order.\n     * So plugins[0] should fill up first and plugins[pluginCount - 1] should be emptied first.\n     */\n    uint256 public pluginCount;\n    mapping(uint256 => address) public plugins;\n\n    /// @notice The allowed amount of myLINK a spender can transfer on behalf of the owner\n    /// @dev allowances are denoted in tokens, not shares\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /**\n     * @notice A deposit to the vault\n     *\n     * @param from The account that deposited the LINK\n     * @param amount The amount of LINK deposited\n     */\n    event Deposit(address indexed from, uint256 amount);\n\n    /**\n     * @notice A withdrawal from the vault\n     *\n     * @param to The account that received the LINK\n     * @param amount The amount of LINK withdrawn\n     */\n    event Withdraw(address indexed to, uint256 amount);\n\n    /**\n     * @notice A plugin was added to the vault\n     *\n     * @param plugin The address of the plugin contract\n     * @param index The priority index of the plugin\n     */\n    event PluginAdded(address indexed plugin, uint256 index);\n\n    /**\n     * @notice A plugin was removed from the vault\n     *\n     * @param plugin The address of the plugin contract\n     */\n    event PluginRemoved(address indexed plugin);\n\n    /**\n     * @notice The owner of the vault was changed\n     *\n     * @param previousOwner The previous owner of the vault\n     * @param newOwner The new owner of the vault\n     */\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function initialize(\n        address _LINK,\n        address _owner,\n        uint256 _capacity,\n        uint256 _startingSharesPerLink\n    ) public initializer {\n        LINK = _LINK;\n        decimals = IERC20Metadata(_LINK).decimals();\n        owner = _owner;\n        MAX_CAPACITY = _capacity;\n        STARTING_SHARES_PER_LINK = _startingSharesPerLink;\n    }\n\n    /****************************************** USER METHODS ******************************************/\n\n    /**\n     * @notice Deposits LINK into the vault and mints shares of myLINK of the same value\n     *\n     * @param _amount The amount of LINK to deposit\n     *\n     * Emits a {Deposit} event.\n     */\n    function deposit(uint256 _amount) external {\n        require(_amount > 0, \"Amount must be greater than 0\");\n        require(_amount <= availableForDeposit(), \"Amount exceeds available capacity\");\n\n        uint256 newShares = convertToShares(_amount);\n        _mintShares(msg.sender, newShares);\n\n        IERC20(LINK).transferFrom(msg.sender, address(this), _amount);\n        _distributeToPlugins();\n\n        emit Deposit(msg.sender, _amount);\n    }\n\n    /**\n     * @notice Redeems shares of myLINK for LINK\n     * @dev Pulls the LINK from the plugins before burning the shares\n     *\n     * @param _amount The amount of myLINK to redeem (denominated in tokens, not shares)\n     *\n     * Emits a {Withdraw} event.\n     */\n\n    function withdraw(uint256 _amount) external {\n        require(_amount > 0, \"Amount must be greater than 0\");\n        require(_amount <= balanceOf(msg.sender), \"Amount exceeds balance\");\n\n        _ensureLinkAmount(_amount);\n\n        _burnShares(msg.sender, convertToShares(_amount));\n\n        IERC20(LINK).transfer(msg.sender, _amount);\n\n        emit Withdraw(msg.sender, _amount);\n    }\n\n    /**\n     * @notice Redeems all shares of myLINK for LINK\n     * @dev There is often a small amount of shares remainining when using the `withdraw` method\n     * This method is provided to allow users to completely withdraw from the vault\n     *\n     * Emits a {Withdraw} event.\n     */\n\n    function withdrawAll() external {\n        uint256 amount = balanceOf(msg.sender);\n        require(amount > 0, \"Amount must be greater than 0\");\n\n        _ensureLinkAmount(amount);\n\n        _burnShares(msg.sender, shares[msg.sender]);\n\n        IERC20(LINK).transfer(msg.sender, amount);\n\n        emit Withdraw(msg.sender, amount);\n    }\n\n    /**\n     * @notice Moves `_amount` myLINK from the caller's account to `_to`\n     *\n     * @param _to The account to transfer to\n     * @param _amount The amount to transfer\n     * @return true if the transfer succeeded\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address _to, uint256 _amount) public returns (bool) {\n        _transfer(msg.sender, _to, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Moves `_amount` myLINK from `_from` to `_to` using the allowance mechanism\n     * @dev `_amount` is then deducted from the caller's allowance\n     *\n     * @param _from The account to transfer from\n     * @param _to The account to transfer to\n     * @param _amount The amount to transfer\n     * @return true if the transfer succeeded\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) public returns (bool) {\n        require(_amount <= allowance[_from][msg.sender], \"Amount exceeds allowance\");\n\n        _transfer(_from, _to, _amount);\n        allowance[_from][msg.sender] -= _amount;\n\n        return true;\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the caller's myLINK\n     *\n     * @param _spender The account to be given an allowance\n     * @param _amount The allowance amount\n     * @return true if the approval succeeded\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address _spender, uint256 _amount) public returns (bool) {\n        require(_spender != address(0), \"Cannot approve zero address\");\n        allowance[msg.sender][_spender] = _amount;\n        emit Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Mints shares of myLINK according to the amount of LINK deposited\n     * @dev ERC677 callback after LINK is transferred to the vault\n     * @dev Can only be called by the LINK token contract\n     *\n     * @param _from The account that deposited the LINK\n     * @param _amount The amount of LINK deposited\n     * @param _data The data passed to the transferAndCall method, which must be \"deposit\"\n     *\n     * Emits a {Deposit} event.\n     */\n    function onTokenTransfer(\n        address _from,\n        uint256 _amount,\n        bytes memory _data\n    ) external override returns (bool) {\n        require(msg.sender == LINK, \"Must use LINK token\");\n        require(keccak256(_data) == keccak256(abi.encodePacked(\"deposit\")), \"Data must be 'deposit'\");\n\n        require(_amount > 0, \"Amount must be greater than 0\");\n        require(totalSupply() <= MAX_CAPACITY, \"Amount exceeds available capacity\");\n\n        // We must calculate the shares based on the supply before the transfer\n        uint256 supplyBeforeTransfer = totalSupply() - _amount;\n        uint256 newShares = supplyBeforeTransfer == 0\n            ? _amount * STARTING_SHARES_PER_LINK\n            : _amount.mulDivDown(totalShares, supplyBeforeTransfer);\n\n        _mintShares(_from, newShares);\n\n        _distributeToPlugins();\n\n        emit Deposit(_from, _amount);\n\n        return true;\n    }\n\n    /****************************************** OWNER METHODS ******************************************/\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only callable by owner\");\n        _;\n    }\n\n    /**\n     * @notice Sets a new owner of the smart contract\n     * @dev Only callable by the current owner\n     *\n     * @param _newOwner The address of the new owner\n     *\n     * Emits an {OwnershipTransferred} event.\n     */\n    function transferOwnership(address _newOwner) external onlyOwner {\n        owner = _newOwner;\n        emit OwnershipTransferred(msg.sender, _newOwner);\n    }\n\n    /**\n     * @dev ensures only the owner can upgrade the contract\n     */\n    function _authorizeUpgrade(address) internal override onlyOwner {}\n\n    /**\n     * @notice Adds a plugin to the vault\n     * @dev Only callable by the owner\n     * @dev Approves the plugin to transfer LINK from the vault\n     * @dev Will shift all plugins with a greater priority index up by 1\n     *\n     * @param _plugin The address of the plugin contract\n     * @param _index The priority index of the plugin\n     *\n     * Emits a {PluginAdded} event.\n     */\n    function addPlugin(address _plugin, uint256 _index) external onlyOwner {\n        require(_plugin != address(0), \"Cannot add zero address\");\n        require(_index <= pluginCount, \"Index must be less than or equal to plugin count\");\n\n        uint256 pointer = pluginCount;\n        while (pointer > _index) {\n            plugins[pointer] = plugins[pointer - 1];\n            pointer--;\n        }\n        plugins[pointer] = _plugin;\n        pluginCount++;\n\n        IERC20(LINK).approve(_plugin, type(uint256).max);\n\n        emit PluginAdded(_plugin, _index);\n    }\n\n    /**\n     * @notice Removes a plugin from the vault\n     * @dev Only callable by the owner\n     * @dev Removes the plugin's allowance to transfer LINK from the vault\n     * @dev Will shift all plugins with a greater priority index down by 1\n     *\n     * @param _index The index of the plugin to remove\n     *\n     * Emits a {PluginRemoved} event.\n     */\n    function removePlugin(uint256 _index) external onlyOwner {\n        require(_index < pluginCount, \"Index out of bounds\");\n        address pluginAddr = plugins[_index];\n\n        _withdrawFromPlugin(pluginAddr, IPlugin(pluginAddr).balance());\n\n        uint256 pointer = _index;\n        while (pointer < pluginCount - 1) {\n            plugins[pointer] = plugins[pointer + 1];\n            pointer++;\n        }\n        delete plugins[pluginCount - 1];\n        pluginCount--;\n\n        IERC20(LINK).approve(pluginAddr, 0);\n\n        emit PluginRemoved(pluginAddr);\n    }\n\n    /**\n     * @notice Withdraws LINK from plugins and redistributes it\n     * @dev Only callable by the owner\n     * @dev Useful for when the plugin configuration changes\n     *\n     * @param _withdrawalValues The amount of LINK to withdraw from each plugin\n     */\n    function rebalancePlugins(uint256[] memory _withdrawalValues) external onlyOwner {\n        require(_withdrawalValues.length == pluginCount, \"Invalid withdrawal values\");\n        for (uint256 i = 0; i < pluginCount; i++) {\n            _withdrawFromPlugin(plugins[i], _withdrawalValues[i]);\n        }\n        _distributeToPlugins();\n    }\n\n    /**\n     * @notice Sets the vault capacity\n     * @dev Only callable by the owner\n     *\n     * @param _maxCapacity The new capacity\n     */\n    function setMaxCapacity(uint256 _maxCapacity) external onlyOwner {\n        MAX_CAPACITY = _maxCapacity;\n    }\n\n    /****************************************** INTERNAL METHODS ******************************************/\n\n    /**\n     * @notice Mints shares of myLINK to `_to`\n     *\n     * @param _to The account to mint to\n     * @param _shares The number of shares to mint\n     */\n    function _mintShares(address _to, uint256 _shares) internal {\n        require(_to != address(0), \"Cannot mint to address 0\");\n\n        totalShares += _shares;\n        unchecked {\n            // Overflow is impossible, because totalShares would overflow first\n            shares[_to] += _shares;\n        }\n    }\n\n    /**\n     * @notice Burns shares of myLINK from `_from`\n     *\n     * @param _from The account to burn from\n     * @param _shares The number of shares to burn\n     */\n    function _burnShares(address _from, uint256 _shares) internal {\n        require(_from != address(0), \"Cannot burn from address 0\");\n\n        require(shares[_from] >= _shares, \"Cannot burn more shares than owned\");\n        unchecked {\n            // Underflow is impossible, because of above require statement\n            shares[_from] -= _shares;\n            totalShares -= _shares;\n        }\n    }\n\n    /**\n     * @notice Transfers `_amount` myLINK from `_from` to `_to`\n     * @dev Converts `_amount` to an equivalent number of shares, and transfers those shares\n     *\n     * @param _from The account to transfer from\n     * @param _to The account to transfer to\n     * @param _amount The amount to transfer\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal {\n        require(_from != address(0), \"Cannot transfer from zero address\");\n        require(_to != address(0), \"Cannot transfer to zero address\");\n\n        uint256 sharesToTransfer = convertToShares(_amount);\n        require(sharesToTransfer <= shares[_from], \"Amount exceeds balance\");\n\n        unchecked {\n            // Underflow is impossible, because of above require statement\n            shares[_from] -= sharesToTransfer;\n            // Overflow is impossible because sharesToTransfer will always be less than totalShares\n            // which is checked when new shares are minteds"
    }
  ]
}