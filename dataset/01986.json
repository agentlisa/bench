{
  "Title": "Double-approval attack by malicious owner",
  "Content": "##### Description\n\nPending transactions have the `_approvalCount` counter.\n\nThe `_approvalCount` for each transaction is simply incremented by 1 each time an owner approves it. However, when the owners are reconfigured using the `configureOwners()` function, the `_approvalCount` value for valid transactions remains positive. This can lead to a scenario where the minority of owners can execute a transaction.\n\n- https://github.com/cloudwalk/brlc-multisig/blob/b5d6c2b6273162d5666d48649890b15a113df7a7/contracts/base/MultiSigWalletBase.sol#L345\n- https://github.com/cloudwalk/brlc-multisig/blob/b5d6c2b6273162d5666d48649890b15a113df7a7/contracts/base/MultiSigWalletBase.sol#L370\n\nFor example, in a wallet requiring the 2/3 of approvals, a malicious owner can create a transaction to withdraw all funds and approve it. They can then claim their account has been hacked and ask the other owners to change their account address (using `configureOwners()`). After the address change, the malicious owner can approve the previously created transaction again reaching the minimum required approvals=2 and execute the transaction.\n\n##### Recommendation\n\nWe recommend removing the counter and checking approvals in `_execute()` by iterating through `_approvalStatus()` using current owners.\n\nLike here in Gnosis:\n- https://github.com/gnosis/MultiSigWallet/blob/90639984c960d281bed3e0a5d56dd4adcb9407c4/contracts/MultiSigWallet.sol#L267-L279.\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/base/MultiSigWalletBase.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport { IMultiSigWallet } from \"./IMultiSigWallet.sol\";\nimport { MultiSigWalletStorage } from \"./MultiSigWalletStorage.sol\";\n\n/**\n * @title MultiSigWalletBase contract\n * @author CloudWalk Inc.\n * @dev The base of the multi-signature wallet contract.\n */\nabstract contract MultiSigWalletBase is MultiSigWalletStorage, IMultiSigWallet {\n    // --------------------------- Errors ---------------------------\n\n    /// @dev An unauthorized account called a function.\n    error UnauthorizedCaller();\n\n    /// @dev A transaction with the specified Id does not exist.\n    error TransactionNotExist();\n\n    /// @dev A transaction with the specified Id is already executed.\n    error TransactionAlreadyExecuted();\n\n    /// @dev A transaction with the specified Id must be approved by the caller.\n    error TransactionNotApproved();\n\n    /// @dev A transaction with the specified Id is already approved by the caller.\n    error TransactionAlreadyApproved();\n\n    /// @dev An empty array of addresses was passed when configuring the wallet owners.\n    error EmptyOwnersArray();\n\n    /// @dev The zero address was passed within the owners array when configuring the wallet owners.\n    error ZeroOwnerAddress();\n\n    /// @dev A duplicate address was passed within the owners array when configuring the wallet owners.\n    error DuplicateOwnerAddress();\n\n    /// @dev An invalid number of required approvals was passed when configuring the wallet owners.\n    error InvalidRequiredApprovals();\n\n    /// @dev The number of approvals for a given transaction is less than the required minimum.\n    error NotEnoughApprovals();\n\n    /// @dev A low level call/transaction to the transaction receiver failed.\n    error InternalTransactionFailed(bytes data);\n\n    /// @dev A transaction with the specified Id has already expired.\n    error TransactionExpired();\n\n    /// @dev A transaction with the specified Id is on cooldown.\n    error CooldownNotEnded();\n\n    // ------------------------- Modifiers --------------------------\n\n    /**\n     * @dev Throws if called by any account other than a wallet owner.\n     */\n    modifier onlyOwner() {\n        if (!_isOwner[msg.sender]) {\n            revert UnauthorizedCaller();\n        }\n        _;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the contract itself.\n     */\n    modifier onlySelfCall() {\n        if (msg.sender != address(this)) {\n            revert UnauthorizedCaller();\n        }\n        _;\n    }\n\n    // ------------------------- Functions --------------------------\n\n    /**\n     * @dev Called when native tokens are sent to the contract.\n     *\n     * Emits a {Deposit} event.\n     */\n    receive() external payable {\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-submit}.\n     *\n     * Requirements:\n     *\n     * - The caller must be a wallet owner.\n     */\n    function submit(\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) external onlyOwner {\n        _submit(to, value, data);\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-submitAndApprove}.\n     *\n     * Requirements:\n     *\n     * - The caller must be a wallet owner.\n     */\n    function submitAndApprove(\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) external onlyOwner {\n        _approve(_submit(to, value, data));\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-approve}.\n     *\n     * Requirements:\n     *\n     * - The caller must be a wallet owner.\n     * - The transaction with the given Id must exist.\n     * - The transaction with the given Id must not be expired.\n     * - The transaction with the given Id must not be executed.\n     * - The transaction with the given Id must not be already approved by the caller.\n     */\n    function approve(uint256 txId) external onlyOwner {\n        _approve(txId);\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-approveAndExecute}.\n     *\n     * Requirements:\n     *\n     * - The caller must be a wallet owner.\n     * - The transaction with the given Id must exist.\n     * - The transaction with the given Id must not be expired.\n     * - The transaction with the given Id must not be executed.\n     * - The transaction with the given Id must not be on cooldown.\n     * - The transaction with the given Id must not be already approved by the caller.\n     * - The transaction with the given Id must have at least the required number of approvals minus one.\n     */\n    function approveAndExecute(uint256 txId) external onlyOwner {\n        _approve(txId);\n        _execute(txId);\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-execute}.\n     *\n     * Requirements:\n     *\n     * - The caller must be a wallet owner.\n     * - The transaction with the given Id must exist.\n     * - The transaction with the given Id must not be expired.\n     * - The transaction with the given Id must not be executed.\n     * - The transaction with the given Id must not be on cooldown.\n     * - The transaction with the given Id must have at least the required number of approvals.\n     */\n    function execute(uint256 txId) external onlyOwner {\n        _execute(txId);\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-revoke}.\n     *\n     * Requirements:\n     *\n     * - The caller must be a wallet owner.\n     * - The transaction with the given Id must exist.\n     * - The transaction with the given Id must not be expired.\n     * - The transaction with the given Id must not be executed.\n     * - The transaction with the given Id must be approved by the caller.\n     */\n    function revoke(uint256 txId) external onlyOwner {\n        _revoke(txId);\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-configureOwners}\n     *\n     * Requirements:\n     *\n     * - The array of wallet owners must not be empty.\n     * - The number of required approvals must not be zero and must not exceed the length of the wallet owners array.\n     */\n    function configureOwners(address[] memory newOwners, uint16 newRequiredApprovals) external onlySelfCall {\n        _configureOwners(newOwners, newRequiredApprovals);\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-configureExpirationTime}\n     */\n    function configureExpirationTime(uint120 newExpirationTime) external onlySelfCall {\n        _configureExpirationTime(newExpirationTime);\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-configureCooldownTime}\n     */\n    function configureCooldownTime(uint120 newCooldownTime) external onlySelfCall {\n        _configureCooldownTime(newCooldownTime);\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-getApprovalCount}.\n     */\n    function getApprovalCount(uint256 txId) external view returns (uint256) {\n        return _approvalCount[txId];\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-getApprovalStatus}.\n     */\n    function getApprovalStatus(uint256 txId, address owner) external view returns (bool) {\n        return _approvalStatus[txId][owner];\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-getTransaction}.\n     */\n    function getTransaction(uint256 txId) external view returns (Transaction memory) {\n        if (txId >= _transactions.length) {\n            revert TransactionNotExist();\n        }\n        return _transactions[txId];\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-getTransactions}.\n     *\n     * The total number of returned transactions will not exceed the provided limit, but may be less.\n     * The function will return an empty array if there is no transaction with the given Id or if the limit is zero.\n     * The empty transaction array will be returned if the transaction with the provided Id does not exist or the\n     * provided limit is zero.\n     */\n    function getTransactions(uint256 txId, uint256 limit) external view returns (Transaction[] memory txs) {\n        uint256 len = _transactions.length;\n        if (len <= txId || limit == 0) {\n            txs = new Transaction[](0);\n        } else {\n            len -= txId;\n            if (len > limit) {\n                len = limit;\n            }\n            txs = new Transaction[](len);\n            for (uint256 i = 0; i < len; i++) {\n                txs[i] = _transactions[txId];\n                txId++;\n            }\n        }\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-owners}.\n     */\n    function owners() external view returns (address[] memory) {\n        return _owners;\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-isOwner}.\n     */\n    function isOwner(address account) external view returns (bool) {\n        return _isOwner[account];\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-requiredApprovals}.\n     */\n    function requiredApprovals() external view returns (uint256) {\n        return _requiredApprovals;\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-transactionCount}.\n     */\n    function transactionCount() external view returns (uint256) {\n        return _transactions.length;\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-expirationTime}.\n     */\n    function expirationTime() external view returns (uint120) {\n        return _expirationTime;\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-cooldownTime}.\n     */\n    function cooldownTime() external view returns (uint120) {\n        return _cooldownTime;\n    }\n\n    /**\n     * @dev See {MultiSigWallet-submit}.\n     */\n    function _submit(\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) internal returns (uint256 txId) {\n        uint128 blockTimestamp = toUint128(block.timestamp);\n\n        _transactions.push(\n            Transaction({\n                to: to,\n                executed: false,\n                cooldown: blockTimestamp + _cooldownTime,\n                expiration: blockTimestamp + _cooldownTime + _expirationTime,\n                value: value,\n                data: data\n            })\n        );\n\n        txId = _transactions.length - 1;\n\n        emit Submit(msg.sender, txId);\n    }\n\n    /**\n     * @dev See {MultiSigWallet-approve}.\n     */\n    function _approve(uint256 txId) internal {\n        if (txId >= _transactions.length) {\n            revert TransactionNotExist();\n        }\n        if (_approvalStatus[txId][msg.sender]) {\n            revert TransactionAlreadyApproved();\n        }\n\n        Transaction memory transaction = _transactions[txId];\n\n        if (transaction.executed) {\n            revert TransactionAlreadyExecuted();\n        }\n        if (transaction.expiration < block.timestamp) {\n            revert TransactionExpired();\n        }\n\n        _approvalCount[txId] += 1;\n        _approvalStatus[txId][msg.sender] = true;\n\n        emit Approve(msg.sender, txId);\n    }\n\n    /**\n     * @dev See {MultiSigWallet-execute}.\n     */\n    function _execute(uint256 txId) internal {\n        if (txId >= _transactions.length) {\n            revert TransactionNotExist();\n        }\n\n        Transaction storage transaction = _transactions[txId];\n\n        if (transaction.executed) {\n            revert TransactionAlreadyExecuted();\n        }\n        if (transaction.cooldown > block.timestamp) {\n            revert CooldownNotEnded();\n        }\n        if (transaction.expiration < block.timestamp) {\n            revert TransactionExpired();\n        }\n        if (_approvalCount[txId] < _requiredApprovals) {\n            revert NotEnoughApprovals();\n        }\n\n        transaction.executed = true;\n\n        emit Execute(msg.sender, txId);\n\n        (bool success, bytes memory data) = transaction.to.call{ value: transaction.value }(transaction.data);\n        if (!success) {\n            revert InternalTransactionFailed(data);\n        }\n    }\n\n    /**\n     * @dev See {MultiSigWallet-revoke}.\n     */\n    function _revoke(uint256 txId) internal {\n        if (txId >= _transactions.length) {\n            revert TransactionNotExist();\n        }\n        if (!_approvalStatus[txId][msg.sender]) {\n            revert TransactionNotApproved();\n        }\n\n        Transaction storage transaction = _transactions[txId];\n\n        if (transaction.executed) {\n            revert TransactionAlreadyExecuted();\n        }\n        if (transaction.expiration < block.timestamp) {\n            revert TransactionExpired();\n        }\n\n        _approvalCount[txId] -= 1;\n        _approvalStatus[txId][msg.sender] = false;\n\n        emit Revoke(msg.sender, txId);\n    }\n\n    /**\n     * @dev See {MultiSigWallet-configureOwners}.\n     */\n    function _configureOwners(address[] memory newOwners, uint16 newRequiredApprovals) internal {\n        if (newOwners.length == 0) {\n            revert EmptyOwnersArray();\n        }\n        if (newRequiredApprovals == 0) {\n            revert InvalidRequiredApprovals();\n        }\n        if (newRequiredApprovals > newOwners.length) {\n            revert InvalidRequiredApprovals();\n        }\n\n        uint256 len;\n        if (_owners.length != 0) {\n            len = _owners.length;\n            for (uint256 i = 0; i < len; i++) {\n                _isOwner[_owners[i]] = false;\n            }\n        }\n\n        address owner;\n        len = newOwners.length;\n        for (uint256 i = 0; i < len; i++) {\n            owner = newOwners[i];\n\n            if (owner == address(0)) {\n                revert ZeroOwnerAddress();\n            }\n            if (_isOwner[owner]) {\n                revert DuplicateOwnerAddress();\n            }\n\n            _isOwner[owner] = true;\n        }\n\n        _owners = newOwners;\n        _requiredApprovals = newRequiredApprovals;\n\n        emit ConfigureOwners(newOwners, newRequiredApprovals);\n    }\n\n    /**\n     * @dev See {MultiSigWallet-configureExpirationTime}.\n     */\n    function _configureExpirationTime(uint120 newExpirationTime) internal {\n        _expirationTime = newExpirationTime;\n        emit ConfigureExpirationTime(newExpirationTime);\n    }\n\n    /**\n     * @dev See {MultiSigWallet-configureCooldownTime}.\n     */\n    function _configureCooldownTime(uint120 newCooldownTime) internal {\n        _cooldownTime = newCooldownTime;\n        emit ConfigureCooldownTime(newCooldownTime);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n}"
    },
    {
      "filename": "contracts/base/MultiSigWalletBase.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport { IMultiSigWallet } from \"./IMultiSigWallet.sol\";\nimport { MultiSigWalletStorage } from \"./MultiSigWalletStorage.sol\";\n\n/**\n * @title MultiSigWalletBase contract\n * @author CloudWalk Inc.\n * @dev The base of the multi-signature wallet contract.\n */\nabstract contract MultiSigWalletBase is MultiSigWalletStorage, IMultiSigWallet {\n    // --------------------------- Errors ---------------------------\n\n    /// @dev An unauthorized account called a function.\n    error UnauthorizedCaller();\n\n    /// @dev A transaction with the specified Id does not exist.\n    error TransactionNotExist();\n\n    /// @dev A transaction with the specified Id is already executed.\n    error TransactionAlreadyExecuted();\n\n    /// @dev A transaction with the specified Id must be approved by the caller.\n    error TransactionNotApproved();\n\n    /// @dev A transaction with the specified Id is already approved by the caller.\n    error TransactionAlreadyApproved();\n\n    /// @dev An empty array of addresses was passed when configuring the wallet owners.\n    error EmptyOwnersArray();\n\n    /// @dev The zero address was passed within the owners array when configuring the wallet owners.\n    error ZeroOwnerAddress();\n\n    /// @dev A duplicate address was passed within the owners array when configuring the wallet owners.\n    error DuplicateOwnerAddress();\n\n    /// @dev An invalid number of required approvals was passed when configuring the wallet owners.\n    error InvalidRequiredApprovals();\n\n    /// @dev The number of approvals for a given transaction is less than the required minimum.\n    error NotEnoughApprovals();\n\n    /// @dev A low level call/transaction to the transaction receiver failed.\n    error InternalTransactionFailed(bytes data);\n\n    /// @dev A transaction with the specified Id has already expired.\n    error TransactionExpired();\n\n    /// @dev A transaction with the specified Id is on cooldown.\n    error CooldownNotEnded();\n\n    // ------------------------- Modifiers --------------------------\n\n    /**\n     * @dev Throws if called by any account other than a wallet owner.\n     */\n    modifier onlyOwner() {\n        if (!_isOwner[msg.sender]) {\n            revert UnauthorizedCaller();\n        }\n        _;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the contract itself.\n     */\n    modifier onlySelfCall() {\n        if (msg.sender != address(this)) {\n            revert UnauthorizedCaller();\n        }\n        _;\n    }\n\n    // ------------------------- Functions --------------------------\n\n    /**\n     * @dev Called when native tokens are sent to the contract.\n     *\n     * Emits a {Deposit} event.\n     */\n    receive() external payable {\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-submit}.\n     *\n     * Requirements:\n     *\n     * - The caller must be a wallet owner.\n     */\n    function submit(\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) external onlyOwner {\n        _submit(to, value, data);\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-submitAndApprove}.\n     *\n     * Requirements:\n     *\n     * - The caller must be a wallet owner.\n     */\n    function submitAndApprove(\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) external onlyOwner {\n        _approve(_submit(to, value, data));\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-approve}.\n     *\n     * Requirements:\n     *\n     * - The caller must be a wallet owner.\n     * - The transaction with the given Id must exist.\n     * - The transaction with the given Id must not be expired.\n     * - The transaction with the given Id must not be executed.\n     * - The transaction with the given Id must not be already approved by the caller.\n     */\n    function approve(uint256 txId) external onlyOwner {\n        _approve(txId);\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-approveAndExecute}.\n     *\n     * Requirements:\n     *\n     * - The caller must be a wallet owner.\n     * - The transaction with the given Id must exist.\n     * - The transaction with the given Id must not be expired.\n     * - The transaction with the given Id must not be executed.\n     * - The transaction with the given Id must not be on cooldown.\n     * - The transaction with the given Id must not be already approved by the caller.\n     * - The transaction with the given Id must have at least the required number of approvals minus one.\n     */\n    function approveAndExecute(uint256 txId) external onlyOwner {\n        _approve(txId);\n        _execute(txId);\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-execute}.\n     *\n     * Requirements:\n     *\n     * - The caller must be a wallet owner.\n     * - The transaction with the given Id must exist.\n     * - The transaction with the given Id must not be expired.\n     * - The transaction with the given Id must not be executed.\n     * - The transaction with the given Id must not be on cooldown.\n     * - The transaction with the given Id must have at least the required number of approvals.\n     */\n    function execute(uint256 txId) external onlyOwner {\n        _execute(txId);\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-revoke}.\n     *\n     * Requirements:\n     *\n     * - The caller must be a wallet owner.\n     * - The transaction with the given Id must exist.\n     * - The transaction with the given Id must not be expired.\n     * - The transaction with the given Id must not be executed.\n     * - The transaction with the given Id must be approved by the caller.\n     */\n    function revoke(uint256 txId) external onlyOwner {\n        _revoke(txId);\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-configureOwners}\n     *\n     * Requirements:\n     *\n     * - The array of wallet owners must not be empty.\n     * - The number of required approvals must not be zero and must not exceed the length of the wallet owners array.\n     */\n    function configureOwners(address[] memory newOwners, uint16 newRequiredApprovals) external onlySelfCall {\n        _configureOwners(newOwners, newRequiredApprovals);\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-configureExpirationTime}\n     */\n    function configureExpirationTime(uint120 newExpirationTime) external onlySelfCall {\n        _configureExpirationTime(newExpirationTime);\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-configureCooldownTime}\n     */\n    function configureCooldownTime(uint120 newCooldownTime) external onlySelfCall {\n        _configureCooldownTime(newCooldownTime);\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-getApprovalCount}.\n     */\n    function getApprovalCount(uint256 txId) external view returns (uint256) {\n        return _approvalCount[txId];\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-getApprovalStatus}.\n     */\n    function getApprovalStatus(uint256 txId, address owner) external view returns (bool) {\n        return _approvalStatus[txId][owner];\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-getTransaction}.\n     */\n    function getTransaction(uint256 txId) external view returns (Transaction memory) {\n        if (txId >= _transactions.length) {\n            revert TransactionNotExist();\n        }\n        return _transactions[txId];\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-getTransactions}.\n     *\n     * The total number of returned transactions will not exceed the provided limit, but may be less.\n     * The function will return an empty array if there is no transaction with the given Id or if the limit is zero.\n     * The empty transaction array will be returned if the transaction with the provided Id does not exist or the\n     * provided limit is zero.\n     */\n    function getTransactions(uint256 txId, uint256 limit) external view returns (Transaction[] memory txs) {\n        uint256 len = _transactions.length;\n        if (len <= txId || limit == 0) {\n            txs = new Transaction[](0);\n        } else {\n            len -= txId;\n            if (len > limit) {\n                len = limit;\n            }\n            txs = new Transaction[](len);\n            for (uint256 i = 0; i < len; i++) {\n                txs[i] = _transactions[txId];\n                txId++;\n            }\n        }\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-owners}.\n     */\n    function owners() external view returns (address[] memory) {\n        return _owners;\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-isOwner}.\n     */\n    function isOwner(address account) external view returns (bool) {\n        return _isOwner[account];\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-requiredApprovals}.\n     */\n    function requiredApprovals() external view returns (uint256) {\n        return _requiredApprovals;\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-transactionCount}.\n     */\n    function transactionCount() external view returns (uint256) {\n        return _transactions.length;\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-expirationTime}.\n     */\n    function expirationTime() external view returns (uint120) {\n        return _expirationTime;\n    }\n\n    /**\n     * @dev See {IMultiSigWallet-cooldownTime}.\n     */\n    function cooldownTime() external view returns (uint120) {\n        return _cooldownTime;\n    }\n\n    /**\n     * @dev See {MultiSigWallet-submit}.\n     */\n    function _submit(\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) internal returns (uint256 txId) {\n        uint128 blockTimestamp = toUint128(block.timestamp);\n\n        _transactions.push(\n            Transaction({\n                to: to,\n                executed: false,\n                cooldown: blockTimestamp + _cooldownTime,\n                expiration: blockTimestamp + _cooldownTime + _expirationTime,\n                value: value,\n                data: data\n            })\n        );\n\n        txId = _transactions.length - 1;\n\n        emit Submit(msg.sender, txId);\n    }\n\n    /**\n     * @dev See {MultiSigWallet-approve}.\n     */\n    function _approve(uint256 txId) internal {\n        if (txId >= _transactions.length) {\n            revert TransactionNotExist();\n        }\n        if (_approvalStatus[txId][msg.sender]) {\n            revert TransactionAlreadyApproved();\n        }\n\n        Transaction memory transaction = _transactions[txId];\n\n        if (transaction.executed) {\n            revert TransactionAlreadyExecuted();\n        }\n        if (transaction.expiration < block.timestamp) {\n            revert TransactionExpired();\n        }\n\n        _approvalCount[txId] += 1;\n        _approvalStatus[txId][msg.sender] = true;\n\n        emit Approve(msg.sender, txId);\n    }\n\n    /**\n     * @dev See {MultiSigWallet-execute}.\n     */\n    function _execute(uint256 txId) internal {\n        if (txId >= _transactions.length) {\n            revert TransactionNotExist();\n        }\n\n        Transaction storage transaction = _transactions[txId];\n\n        if (transaction.executed) {\n            revert TransactionAlreadyExecuted();\n        }\n        if (transaction.cooldown > block.timestamp) {\n            revert CooldownNotEnded();\n        }\n        if (transaction.expiration < block.timestamp) {\n            revert TransactionExpired();\n        }\n        if (_approvalCount[txId] < _requiredApprovals) {\n            revert NotEnoughApprovals();\n        }\n\n        transaction.executed = true;\n\n        emit Execute(msg.sender, txId);\n\n        (bool success, bytes memory data) = transaction.to.call{ value: transaction.value }(transaction.data);\n        if (!success) {\n            revert InternalTransactionFailed(data);\n        }\n    }\n\n    /**\n     * @dev See {MultiSigWallet-revoke}.\n     */\n    function _revoke(uint256 txId) internal {\n        if (txId >= _transactions.length) {\n            revert TransactionNotExist();\n        }\n        if (!_approvalStatus[txId][msg.sender]) {\n            revert TransactionNotApproved();\n        }\n\n        Transaction storage transaction = _transactions[txId];\n\n        if (transaction.executed) {\n            revert TransactionAlreadyExecuted();\n        }\n        if (transaction.expiration < block.timestamp) {\n            revert TransactionExpired();\n        }\n\n        _approvalCount[txId] -= 1;\n        _approvalStatus[txId][msg.sender] = false;\n\n        emit Revoke(msg.sender, txId);\n    }\n\n    /**\n     * @dev See {MultiSigWallet-configureOwners}.\n     */\n    function _configureOwners(address[] memory newOwners, uint16 newRequiredApprovals) internal {\n        if (newOwners.length == 0) {\n            revert EmptyOwnersArray();\n        }\n        if (newRequiredApprovals == 0) {\n            revert InvalidRequiredApprovals();\n        }\n        if (newRequiredApprovals > newOwners.length) {\n            revert InvalidRequiredApprovals();\n        }\n\n        uint256 len;\n        if (_owners.length != 0) {\n            len = _owners.length;\n            for (uint256 i = 0; i < len; i++) {\n                _isOwner[_owners[i]] = false;\n            }\n        }\n\n        address owner;\n        len = newOwners.length;\n        for (uint256 i = 0; i < len; i++) {\n            owner = newOwners[i];\n\n            if (owner == address(0)) {\n                revert ZeroOwnerAddress();\n            }\n            if (_isOwner[owner]) {\n                revert DuplicateOwnerAddress();\n            }\n\n            _isOwner[owner] = true;\n        }\n\n        _owners = newOwners;\n        _requiredApprovals = newRequiredApprovals;\n\n        emit ConfigureOwners(newOwners, newRequiredApprovals);\n    }\n\n    /**\n     * @dev See {MultiSigWallet-configureExpirationTime}.\n     */\n    function _configureExpirationTime(uint120 newExpirationTime) internal {\n        _expirationTime = newExpirationTime;\n        emit ConfigureExpirationTime(newExpirationTime);\n    }\n\n    /**\n     * @dev See {MultiSigWallet-configureCooldownTime}.\n     */\n    function _configureCooldownTime(uint120 newCooldownTime) internal {\n        _cooldownTime = newCooldownTime;\n        emit ConfigureCooldownTime(newCooldownTime);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n}"
    },
    {
      "filename": "contracts/MultiSigWallet.sol",
      "content": "pragma solidity ^0.4.15;\n\n\n/// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution.\n/// @author Stefan George - <stefan.george@consensys.net>\ncontract MultiSigWallet {\n\n    /*\n     *  Events\n     */\n    event Confirmation(address indexed sender, uint indexed transactionId);\n    event Revocation(address indexed sender, uint indexed transactionId);\n    event Submission(uint indexed transactionId);\n    event Execution(uint indexed transactionId);\n    event ExecutionFailure(uint indexed transactionId);\n    event Deposit(address indexed sender, uint value);\n    event OwnerAddition(address indexed owner);\n    event OwnerRemoval(address indexed owner);\n    event RequirementChange(uint required);\n\n    /*\n     *  Constants\n     */\n    uint constant public MAX_OWNER_COUNT = 50;\n\n    /*\n     *  Storage\n     */\n    mapping (uint => Transaction) public transactions;\n    mapping (uint => mapping (address => bool)) public confirmations;\n    mapping (address => bool) public isOwner;\n    address[] public owners;\n    uint public required;\n    uint public transactionCount;\n\n    struct Transaction {\n        address destination;\n        uint value;\n        bytes data;\n        bool executed;\n    }\n\n    /*\n     *  Modifiers\n     */\n    modifier onlyWallet() {\n        require(msg.sender == address(this));\n        _;\n    }\n\n    modifier ownerDoesNotExist(address owner) {\n        require(!isOwner[owner]);\n        _;\n    }\n\n    modifier ownerExists(address owner) {\n        require(isOwner[owner]);\n        _;\n    }\n\n    modifier transactionExists(uint transactionId) {\n        require(transactions[transactionId].destination != 0);\n        _;\n    }\n\n    modifier confirmed(uint transactionId, address owner) {\n        require(confirmations[transactionId][owner]);\n        _;\n    }\n\n    modifier notConfirmed(uint transactionId, address owner) {\n        require(!confirmations[transactionId][owner]);\n        _;\n    }\n\n    modifier notExecuted(uint transactionId) {\n        require(!transactions[transactionId].executed);\n        _;\n    }\n\n    modifier notNull(address _address) {\n        require(_address != 0);\n        _;\n    }\n\n    modifier validRequirement(uint ownerCount, uint _required) {\n        require(ownerCount <= MAX_OWNER_COUNT\n            && _required <= ownerCount\n            && _required != 0\n            && ownerCount != 0);\n        _;\n    }\n\n    /// @dev Fallback function allows to deposit ether.\n    function()\n        payable\n    {\n        if (msg.value > 0)\n            Deposit(msg.sender, msg.value);\n    }\n\n    /*\n     * Public functions\n     */\n    /// @dev Contract constructor sets initial owners and required number of confirmations.\n    /// @param _owners List of initial owners.\n    /// @param _required Number of required confirmations.\n    function MultiSigWallet(address[] _owners, uint _required)\n        public\n        validRequirement(_owners.length, _required)\n    {\n        for (uint i=0; i<_owners.length; i++) {\n            require(!isOwner[_owners[i]] && _owners[i] != 0);\n            isOwner[_owners[i]] = true;\n        }\n        owners = _owners;\n        required = _required;\n    }\n\n    /// @dev Allows to add a new owner. Transaction has to be sent by wallet.\n    /// @param owner Address of new owner.\n    function addOwner(address owner)\n        public\n        onlyWallet\n        ownerDoesNotExist(owner)\n        notNull(owner)\n        validRequirement(owners.length + 1, required)\n    {\n        isOwner[owner] = true;\n        owners.push(owner);\n        OwnerAddition(owner);\n    }\n\n    /// @dev Allows to remove an owner. Transaction has to be sent by wallet.\n    /// @param owner Address of owner.\n    function removeOwner(address owner)\n        public\n        onlyWallet\n        ownerExists(owner)\n    {\n        isOwner[owner] = false;\n        for (uint i=0; i<owners.length - 1; i++)\n            if (owners[i] == owner) {\n                owners["
    }
  ]
}