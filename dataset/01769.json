{
  "Title": "3S-LENFT-M02 protocol/GenesisNFT.sol: Only 1336 GenesisNFT tokens can be minted",
  "Content": "#### Description\nThe [documentation](https://lenft.gitbook.io/lenft-docs/genesis-mint) mentions that the Genesis Mint is limited to just 1337 tokens, which is corroborated by the [constant](https://github.com/leNFT/contracts/blob/master/contracts/protocol/GenesisNFT.sol#L42) set in the GenesisNFT contract: `MAX_CAP = 1337;`\n\nThe issue is that the current implementation of the GenesisNFT contract only allows for 1336 NFTs to be minted. This contract uses the following logic for minting:\n```solidity\ncontract testCap {\n\nuint256 constant MAX_CAP = 10;\nuint256 counter = 1;\n\nfunction mint(uint256 amount) external {\nrequire(counter + amount <= MAX_CAP, \"G:M:CAP_EXCEEDED\");\n\nfor (uint256 i = 0; i < amount; i++) {\n// Mint\ncounter ++;\n}\n}\n}\n```\n\nHere, even though the `MAX_CAP` is set at 10 tokens, if you ever try to call the mint function with an amount of 10, the call will revert since the counter in initialized at 1, and so the require condition `11 <= 10` will be false.\n\n#### Recommendation\n\nChange [line 344](https://github.com/leNFT/contracts/blob/master/contracts/protocol/GenesisNFT.sol#L344) to             `_tokenIdCounter.current() + amount <= getCap() + 1,` and add a test for this situation",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/protocol/GenesisNFT.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.19;\n\nimport {IAddressProvider} from \"../interfaces/IAddressProvider.sol\";\nimport {IWETH} from \"../interfaces/IWETH.sol\";\nimport {Base64} from \"@openzeppelin/contracts/utils/Base64.sol\";\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport {IGenesisNFT} from \"../interfaces/IGenesisNFT.sol\";\nimport {INativeToken} from \"../interfaces/INativeToken.sol\";\nimport {IVotingEscrow} from \"../interfaces/IVotingEscrow.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {ERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\nimport {IERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\";\nimport {CountersUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\";\nimport {ERC721EnumerableUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {IVault} from \"@balancer-labs/v2-interfaces/contracts/vault/IVault.sol\";\nimport {WeightedPoolUserData} from \"@balancer-labs/v2-interfaces/contracts/pool-weighted/WeightedPoolUserData.sol\";\nimport {IBalancerQueries} from \"@balancer-labs/v2-interfaces/contracts/standalone-utils/IBalancerQueries.sol\";\nimport {SafeCast} from \"../libraries/utils/SafeCast.sol\";\n// solhint-disable-next-line no-global-import\nimport \"../libraries/balancer/ERC20Helpers.sol\"; // Custom (pragma ^0.8.0) ERC20 helpers for Balancer tokens\n\n/// @title GenesisNFT\n/// @author leNFT\n/// @notice This contract manages the creation and minting of Genesis NFTs\n/// @dev Interacts with a balancer pool to provide liquidty on mint\ncontract GenesisNFT is\n    ERC165Upgradeable,\n    ERC721EnumerableUpgradeable,\n    OwnableUpgradeable,\n    IGenesisNFT,\n    ReentrancyGuardUpgradeable\n{\n    uint256 private constant LP_LE_AMOUNT = 4e22; // 40000 LE\n    uint256 private constant LP_ETH_AMOUNT = 1e17; // 0.1 ETH\n    uint256 private constant MAX_CAP = 1337; // 1337 NFTs\n    uint256 private constant PRICE = 25e16; // 0.25 ETH\n    uint256 private constant MAX_LOCKTIME = 180 days;\n    uint256 private constant MIN_LOCKTIME = 14 days;\n    uint256 private constant NATIVE_TOKEN_FACTOR = 400000; // Controls the amount of native tokens minted per NFT\n\n    IAddressProvider private immutable _addressProvider;\n    address payable private _devAddress;\n    DataTypes.BalancerDetails private _balancerDetails;\n    uint256 private _maxLTVBoost;\n    CountersUpgradeable.Counter private _tokenIdCounter;\n    // Mapping from owner to create loan operator approvals\n    mapping(address => mapping(address => bool)) private _loanOperatorApprovals;\n    // NFT token id to bool that's true if NFT is being used to increase a loan's max LTV\n    mapping(uint256 => bool) private _locked;\n    // NFT token id to information about its mint\n    mapping(uint256 => DataTypes.MintDetails) private _mintDetails;\n\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    modifier onlyMarket() {\n        _requireOnlyMarket();\n        _;\n    }\n\n    modifier tokenExists(uint256 tokenId) {\n        _requireTokenExists(tokenId);\n        _;\n    }\n\n    modifier validPool() {\n        _requireValidPool();\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(IAddressProvider addressProvider) {\n        _addressProvider = addressProvider;\n        _disableInitializers();\n    }\n\n    /// @notice Initializes the contract with the specified parameters\n    /// @param maxLTVBoost max LTV boost factor\n    /// @param devAddress Address of the developer\n    function initialize(\n        uint256 maxLTVBoost,\n        address payable devAddress\n    ) external initializer {\n        __ERC721_init(\"leNFT Genesis\", \"LEGEN\");\n        __ERC721Enumerable_init();\n        __ERC165_init();\n        __Ownable_init();\n        __ReentrancyGuard_init();\n        _maxLTVBoost = maxLTVBoost;\n        _devAddress = devAddress;\n\n        // Start from token_id 1 in order to reserve '0' for the null token\n        _tokenIdCounter.increment();\n    }\n\n    /// @notice Sets an approved address as a loan operator for the caller\n    /// @dev This approval allows for the use of the genesis NFT by the loan operator in a loan\n    /// @param operator Address to set approval for\n    /// @param approved True if the operator is approved, false to revoke approval\n    function setLoanOperatorApproval(address operator, bool approved) external {\n        _loanOperatorApprovals[msg.sender][operator] = approved;\n    }\n\n    /// @notice Checks if an address is approved as a loan operator for an owner\n    /// @param owner Address of the owner\n    /// @param operator Address of the operator\n    /// @return True if the operator is approved, false otherwise\n    function isLoanOperatorApproved(\n        address owner,\n        address operator\n    ) public view returns (bool) {\n        return _loanOperatorApprovals[owner][operator];\n    }\n\n    /// @notice Returns the URI for a given token ID\n    /// @param tokenId ID of the token\n    /// @return The token's URI\n    function tokenURI(\n        uint256 tokenId\n    )\n        public\n        view\n        override(ERC721Upgradeable)\n        tokenExists(tokenId)\n        returns (string memory)\n    {\n        require(_exists(tokenId), \"G:TU:INVALID_TOKEN_ID\");\n        return\n            string(\n                abi.encodePacked(\n                    \"data:application/json;base64,\",\n                    Base64.encode(\n                        abi.encodePacked(\n                            \"{\",\n                            '\"name\": \"Genesis NFT #',\n                            Strings.toString(tokenId),\n                            '\",',\n                            '\"description\": \"leNFT Genesis Collection NFT.\",',\n                            '\"image\": ',\n                            '\"data:image/svg+xml;base64,',\n                            Base64.encode(svg(tokenId)),\n                            '\",',\n                            '\"attributes\": [',\n                            string(\n                                abi.encodePacked(\n                                    '{ \"trait_type\": \"locked\", \"value\": \"',\n                                    _locked[tokenId] ? \"true\" : \"false\",\n                                    '\" },',\n                                    '{ \"trait_type\": \"unlock_timestamp\", \"value\": \"',\n                                    Strings.toString(\n                                        getUnlockTimestamp(tokenId)\n                                    ),\n                                    '\" },',\n                                    '{ \"trait_type\": \"lp_amount\", \"value\": \"',\n                                    Strings.toString(\n                                        _mintDetails[tokenId].lpAmount\n                                    ),\n                                    '\" }'\n                                )\n                            ),\n                            \"]\",\n                            \"}\"\n                        )\n                    )\n                )\n            );\n    }\n\n    /// @notice Returns the SVG present in the token's metadata\n    /// @param tokenId ID of the token\n    /// @return _svg The token's SVG\n    function svg(\n        uint256 tokenId\n    ) public view tokenExists(tokenId) returns (bytes memory _svg) {\n        require(_exists(tokenId), \"G:S:INVALID_TOKEN_ID\");\n        {\n            _svg = abi.encodePacked(\n                '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 400 400\" style=\"width:100%;background:#f8f1f1;fill:#000;font-family:monospace\">',\n                \"<defs>\",\n                '<filter id=\"a\">',\n                '<feGaussianBlur in=\"SourceGraphic\" stdDeviation=\"2\" result=\"blur\"/>',\n                \"<feMerge>\",\n                '<feMergeNode in=\"blur\"/>',\n                '<feMergeNode in=\"SourceGraphic\"/>',\n                \"</feMerge>\",\n                \"</filter>\",\n                \"</defs>\",\n                '<text x=\"50%\" y=\"25%\" text-anchor=\"middle\" font-size=\"16\" stroke=\"black\" letter-spacing=\"2\">',\n                '<tspan dy=\"0\">leNFT</tspan>',\n                '<animate attributeName=\"textLength\" from=\"0\" to=\"40%\" dur=\"1.8s\" fill=\"freeze\"/>',\n                '<animate attributeName=\"lengthAdjust\" to=\"spacing\" dur=\"1.4s\" fill=\"freeze\"/>',\n                \"</text>\"\n            );\n        }\n\n        {\n            _svg = abi.encodePacked(\n                _svg,\n                '<circle cx=\"50%\" cy=\"60%\" r=\"60\" fill=\"none\" stroke=\"#',\n                _getCircleColor(tokenId),\n                '\" stroke-width=\"2\" filter=\"url(#a)\"/>',\n                '<text x=\"50%\" y=\"17%\" text-anchor=\"middle\" font-size=\"28\">',\n                '<tspan dy=\"180\">',\n                Strings.toString(tokenId),\n                \"</tspan>\",\n                \"</text>\",\n                '<text font-size=\"16\" fill=\"#',\n                _getCircleColor(tokenId),\n                '\" stroke=\"#',\n                _getCircleColor(tokenId),\n                '\" letter-spacing=\"4\" rotate=\"180 180 180 180 180 180 180\">'\n            );\n        }\n\n        {\n            _svg = abi.encodePacked(\n                _svg,\n                '<textPath href=\"#b\" startOffset=\"0%\">',\n                \"SISENEG\",\n                '<animate attributeName=\"startOffset\" from=\"100%\" to=\"0%\" dur=\"15s\" repeatCount=\"indefinite\"/>',\n                \"</textPath>\",\n                \"</text>\",\n                \"<defs>\",\n                '<path id=\"b\" d=\"M130 240a70 70 0 1 0 140 0 70 70 0 1 0-140 0\"/>',\n                \"</defs>\",\n                \"</svg>\"\n            );\n        }\n    }\n\n    function _getCircleColor(\n        uint256 tokenId\n    ) internal view returns (string memory) {\n        // Linear interpolation between black (0x000000) and gold (0xFFD700)\n        uint256 colorValue = (uint256(0xFFD700) *\n            _mintDetails[tokenId].locktime) / MAX_LOCKTIME;\n\n        // Convert to hexadecimal color value && Cast string to bytes\n        bytes memory b = bytes(Strings.toHexString(colorValue));\n\n        // Create a new bytes array to hold the string without the prefix\n        bytes memory result = new bytes(b.length - 2);\n\n        // remove the 0x prefix\n        for (uint i = 2; i < b.length; i++) {\n            result[i - 2] = b[i];\n        }\n        // Convert to hexadecimal color value\n        return string(result);\n    }\n\n    /// @notice Returns the maximum number of tokens that can be minted\n    /// @return The maximum number of tokens\n    function getCap() public pure returns (uint256) {\n        return MAX_CAP;\n    }\n\n    /// @notice Returns the max LTV boost factor\n    /// @return The max LTV boost factor\n    function getMaxLTVBoost() external view returns (uint256) {\n        return _maxLTVBoost;\n    }\n\n    /// @notice Sets the Max LTV boost factor\n    /// @param newMaxLTVBoost The new Max LTV boost factor\n    function setMaxLTVBoost(uint256 newMaxLTVBoost) external onlyOwner {\n        _maxLTVBoost = newMaxLTVBoost;\n    }\n\n    /// @notice Returns the active state of the specified Genesis NFT\n    /// @param tokenId ID of the token\n    /// @return The active state\n    function getLockedState(\n        uint256 tokenId\n    ) external view tokenExists(tokenId) returns (bool) {\n        return _locked[tokenId];\n    }\n\n    /// @notice Sets the active state of the specified Genesis NFT to true\n    /// @param tokenId ID of the token\n    function lockGenesisNFT(\n        address onBehalfOf,\n        address caller,\n        uint256 tokenId\n    ) external override tokenExists(tokenId) onlyMarket returns (uint256) {\n        // If the caller is not the user we are borrowing on behalf Of, check if the caller is approved\n        if (onBehalfOf != caller) {\n            require(\n                isLoanOperatorApproved(onBehalfOf, caller),\n                \"VL:VB:GENESIS_NOT_AUTHORIZED\"\n            );\n        }\n\n        // Require that the NFT is owned by the user we are locking on behalf of\n        require(ownerOf(tokenId) == onBehalfOf, \"VL:VB:GENESIS_NOT_OWNED\");\n\n        //Require that the NFT is not being used\n        require(_locked[tokenId] == false, \"VL:VB:GENESIS_LOCKED\");\n\n        // Set the NFT to be locked\n        _locked[tokenId] = true;\n\n        return _maxLTVBoost;\n    }\n\n    function unlockGenesisNFT(\n        uint256 tokenId\n    ) external override tokenExists(tokenId) onlyMarket {\n        delete _locked[tokenId];\n    }\n\n    /// @notice Calculates the native token reward for a given amount and lock time\n    /// @param amount Amount of tokens to be minted\n    /// @param locktime Lock time for lock in seconds\n    /// @return The native token reward\n    function getCurrentLEReward(\n        uint256 amount,\n        uint256 locktime\n    ) public view returns (uint256) {\n        require(_tokenIdCounter.current() <= MAX_CAP, \"G:GNTR:MINT_OVER\");\n        require(locktime >= MIN_LOCKTIME, \"G:GNTR:LOCKTIME_TOO_LOW\");\n        require(locktime <= MAX_LOCKTIME, \"G:GNTR:LOCKTIME_TOO_HIGH\");\n\n        return\n            ((amount * locktime * (MAX_CAP - (_tokenIdCounter.current() / 2))) /\n                NATIVE_TOKEN_FACTOR) * 1e18;\n    }\n\n    /// @notice Sets the details of the balancer subsidized trading pool\n    /// @param balancerDetails Addresses of the balancer contracts\n    function setBalancerDetails(\n        DataTypes.BalancerDetails calldata balancerDetails\n    ) external onlyOwner {\n        _balancerDetails = balancerDetails;\n    }\n\n    /// @notice Returns the number of tokens that have been minted\n    /// @return The number of tokens\n    function mintCount() external view returns (uint256) {\n        return _tokenIdCounter.current() - 1;\n    }\n\n    /// @notice Mint new Genesis NFTs with locked LE tokens and LP tokens\n    /// @param locktime The time for which the tokens yielded by the genesis NFT are locked for\n    /// @param amount The amount of tokens to mint\n    function mint(\n        uint256 locktime,\n        uint256 amount\n    ) external payable nonReentrant validPool {\n        // Make sure amount is bigger than 0\n        require(amount > 0, \"G:M:AMOUNT_0\");\n        // Make sure locktimes are within limits\n        require(locktime >= MIN_LOCKTIME, \"G:M:LOCKTIME_TOO_LOW\");\n        require(locktime <= MAX_LOCKTIME, \"G:M:LOCKTIME_TOO_HIGH\");\n\n        // Make sure there are enough tokens to mint\n        require(\n            _tokenIdCounter.current() + amount <= getCap() + 1,\n            \"G:M:CAP_EXCEEDED\"\n        );\n\n        // Get the native token address to save on gas\n        address nativeToken = _addressProvider.getNativeToken();\n\n        // Make sure the user sent enough ETH\n        require(msg.value == PRICE * amount, \"G:M:INSUFFICIENT_ETH\");\n\n        // Get the amount of ETH to deposit to the pool\n        uint256 ethAmount = LP_ETH_AMOUNT * amount;\n        uint256 leAmount = LP_LE_AMOUNT * amount;\n\n        // Mint LE tokens\n        uint256 totalRewards = getCurrentLEReward(amount, locktime);\n        INativeToken(nativeToken).mintGenesisTokens(leAmount + totalRewards);\n\n        // Mint WETH tokens\n        address weth = _addressProvider.getWETH();\n        IWETH(weth).deposit{value: ethAmount}();\n\n        // Approve the vault to spend LE & WETH tokens\n        IERC20Upgradeable(nativeToken).approve(\n            _balancerDetails.vault,\n            leAmount\n        );\n        IERC20Upgradeable(weth).approve(_balancerDetails.vault, ethAmount);\n\n        // Deposit tokens to the pool and get the LP amount\n        uint256 oldLPBalance = IERC20Upgradeable(_balancerDetails.pool)\n            .balanceOf(address(this));\n        // avoid stack too deep errors\n        {\n            (IERC20[] memory tokens, , ) = IVault(_balancerDetails.vault)\n                .getPoolTokens(_balancerDetails.poolId);\n\n            uint256[] memory maxAmountsIn = new uint256[](2);\n            uint256[] memory amountsToEncode = new uint256[](2);\n\n            amountsToEncode[\n                _findTokenIndex(tokens, IERC20(nativeToken))\n            ] = leAmount;\n            amountsToEncode[_findTokenIndex(tokens, IERC20(weth))] = ethAmount;\n            maxAmountsIn[0] = type(uint256).max;\n            maxAmountsIn[1] = type(uint256).max;\n            bytes memory userData;\n\n            if (IERC20Upgradeable(_balancerDetails.pool).totalSupply() == 0) {\n                userData = abi.encode(\n                    WeightedPoolUserData.JoinKind.INIT,\n                    amountsToEncode\n                );\n            } else {\n                userData = abi.encode(\n                    WeightedPoolUserData.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,\n                    amountsToEncode,\n                    \"0\"\n                );\n            }\n\n            // Call the Vault to join the pool\n            IVault(_balancerDetails.vault).joinPool(\n                _balancerDetails.poolId,\n                address(this),\n                address(this),\n                IVault.JoinPoolRequest({\n                    assets: _asIAsset(tokens),\n                    maxAmountsIn: maxAmountsIn,\n                    userData: userData,\n                    fromInternalBalance: false\n                })\n            );\n        }\n\n        uint256 lpAmount = IERC20Upgradeable(_balancerDetails.pool).balanceOf(\n            address(this)\n        ) - oldLPBalance;\n\n        // Approve the voting escrow to spend LE tokens so they can be locked\n        address votingEscrow = _addressProvider.getVotingEscrow();\n        IERC20Upgradeable(nativeToken).approve(votingEscrow, totalRewards);\n\n        IVotingEscrow(votingEscrow).createLock(\n            msg.sender,\n            totalRewards,\n            block.timestamp + locktime\n        );\n\n        // Send the rest of the ETH to the dev address\n        (bool sent, ) = _devAddress.call{value: PRICE * amount - ethAmount}(\"\");\n        require(sent, \"G:M:ETH_TRANSFER_FAIL\");\n\n        uint256 tokenId;\n        for (uint256 i = 0; i < amount; i++) {\n            tokenId = _tokenIdCounter.current();\n\n            // Add mint details\n            _mintDetails[tokenId] = DataTypes.MintDetails(\n                SafeCast.toUint40(block.timestamp),\n                SafeCast.toUint40(locktime),\n                SafeCast.toUint128(lpAmount / amount)\n            );\n\n            //Increase supply\n            _tokenIdCounter.increment();\n\n            // Mint genesis NFT\n            _safeMint(msg.sender, tokenId);\n\n            emit Mint(msg.sender, tokenId);\n        }\n    }\n\n    /// @notice Get the current price for minting Genesis NFTs\n    /// @return The current price in wei\n    function getPrice() external pure returns (uint256) {\n        return PRICE;\n    }\n\n    /// @notice Get the unlock timestamp for a specific Genesis NFT\n    /// @param tokenId The ID of the Genesis NFT to check\n    /// @return The unlock timestamp for the specified token\n    function getUnlockTimestamp(\n        uint256 tokenId\n    ) public view tokenExists(tokenId) returns (uint256) {\n        return _mintDetails[tokenId].timestamp + _mintDetails[tokenId].locktime;\n    }\n\n    /// @notice Burn Genesis NFTs and unlock LP tokens and LE tokens\n    /// @param tokenIds The IDs of the Genesis NFTs to burn\n    function burn(uint256[] calldata tokenIds) external validPool nonReentrant {\n        // Make sure we are burning at least one token\n        require(tokenIds.length > 0, \"G:B:0_TOKENS\");\n        uint256 lpAmountSum;\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            //Require the caller owns the token\n            require(msg.sender == ownerOf(tokenIds[i]), \"G:B:NOT_OWNER\");\n            // Token can only be burned after locktime is over\n            require(\n                block.timestamp >= getUnlockTimestamp(tokenIds[i]),\n                \"G:B:NOT_UNLOCKED\"\n            );\n\n            // Add the LP amount to the sum\n            lpAmountSum += _mintDetails[tokenIds[i]].lpAmount;\n\n            // Burn genesis NFT\n            _burn(tokenIds[i]);\n            emit Burn(tokenIds[i]);\n        }\n        // Get the native token address to save on gas\n        address nativeTokenAddress = _addressProvider.getNativeToken();\n\n        // Withdraw LP tokens from the pool\n        (IERC20[] memory tokens, , ) = IVault(_balancerDetails.vault)\n            .getPoolTokens(_balancerDetails.poolId);\n\n        uint256 oldLEBalance = IERC20Upgradeable(nativeTokenAddress).balanceOf(\n            address(this)\n        );\n\n        uint256[] memory minAmountsOut = new uint256[](2);\n        // Call the Vault to exit the pool\n        IVault(_balancerDetails.vault).exitPool(\n            _balancerDetails.poolId,\n            address(this),\n            payable(address(this)),\n            IVault.ExitPoolRequest({\n                assets: _asIAsset(tokens),\n                minAmountsOut: minAmountsOut,\n                userData: abi.encode(\n                    WeightedPoolUserData\n                        .ExitKind\n                        .EXACT_BPT_IN_FOR_ONE_TOKEN_OUT,\n                    lpAmountSum,\n                    _findTokenIndex(tokens, IERC20(nativeTokenAddress))\n                ),\n                toInternalBalance: false\n            })\n        );\n\n        uint256 withdrawAmount = IERC20Upgradeable(nativeTokenAddress)\n            .balanceOf(address(this)) - oldLEBalance;\n        uint256 burnTokens = LP_LE_AMOUNT * tokenIds.length;\n        if (withdrawAmount > burnTokens) {\n            // Send the rest of the LE tokens to the owner of the Genesis NFT\n            IERC20Upgradeable(nativeTokenAddress).transfer(\n                msg.sender,\n                withdrawAmount - burnTokens\n            );\n        } else {\n            burnTokens = withdrawAmount;\n        }\n        if (burnTokens > 0) {\n            INativeToken(nativeTokenAddress).burnGenesisTokens(burnTokens);\n        }\n    }\n\n    /// @notice Get the current value of the LP tokens locked in the contract\n    /// @param tokenIds The tokens ids of the genesis NFTs associated with the LP tokens\n    /// @return The value of the LP tokens in wei\n    function getLPValueInLE(\n        uint256[] calldata tokenIds\n    ) external validPool returns (uint256) {\n        uint256 lpAmountSum;\n        IVault vault = IVault(_balancerDetails.vault);\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            // Make sure the token exists\n            require(_exists(tokenIds[i]), \"G:GLPVLE:NOT_FOUND\");\n            // Add the LP amount to the sum\n            lpAmountSum += _mintDetails[tokenIds[i]].lpAmount;\n        }\n\n        (IERC20[] memory tokens, , ) = vault.getPoolTokens(\n            _balancerDetails.poolId\n        );\n        uint256[] memory minAmountsOut = new uint256[](2);\n        uint256 leIndex = _findTokenIndex(\n            tokens,\n            IERC20(_addressProvider.getNativeToken())\n        );\n        // Calculate the value of the LP tokens in LE tokens\n        (, uint256[] memory amountsOut) = IBalancerQueries(\n            _balancerDetails.queries\n        ).queryExit(\n                _balancerDetails.poolId,\n                address(this),\n                address(this),\n                IVault.ExitPoolRequest({\n                    assets: _asIAsset(tokens),\n                    minAmountsOut: minAmountsOut,\n                    userData: abi.encode(\n                        WeightedPoolUserData\n                            .ExitKind\n                            .EXACT_BPT_IN_FOR_ONE_TOKEN_OUT,\n                        lpAmountSum,\n                        leIndex\n                    ),\n                    toInternalBalance: false\n                })\n            );\n\n        uint256 burnTokens = LP_LE_AMOUNT * tokenIds.length;\n        if (amountsOut[leIndex] > burnTokens) {\n            return amountsOut[leIndex] - burnTokens;\n        }\n\n        return 0;\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 batchSize\n    ) internal override(ERC721EnumerableUpgradeable) {\n        require(_locked[tokenId] == false, \"G:BTT:TOKEN_LOCKED\");\n        ERC721EnumerableUpgradeable._beforeTokenTransfer(\n            from,\n            to,\n            tokenId,\n            batchSize\n        );\n    }\n\n    function supportsInterface(\n        bytes4 interfaceId\n    )\n        public\n        view\n        override(\n            ERC721EnumerableUpgradeable,\n            ERC165Upgradeable,\n            IERC165Upgradeable\n        )\n        returns (bool)\n    {\n        return\n            ERC721EnumerableUpgradeable.supportsInterface(interfaceId) ||\n            ERC165Upgradeable.supportsInterface(interfaceId);\n    }\n\n    function _requireOnlyMarket() internal view {\n        require(\n            msg.sender == _addressProvider.getLendingMarket(),\n            \"G:NOT_MARKET\"\n        );\n    }\n\n    function _requireTokenExists(uint256 tokenId) internal view {\n        require(_exists(tokenId), \"G:TOKEN_NOT_FOUND\");\n    }\n\n    function _requireValidPool() internal view {\n        require(_balancerDetails.pool != address(0), \"G:M:BALANCER_NOT_SET\");\n        (IERC20[] memory tokens, , ) = IVault(_balancerDetails.vault)\n            .getPoolTokens(_balancerDetails.poolId);\n        // Make sure there are only two assets in the pool\n        require(tokens.length == 2, \"G:M:INVALID_POOL_LENGTH\");\n        // Make sure those two assets are the native token and WETH\n        IERC20 nativeToken = IERC20(_addressProvider.getNativeToken());\n        IERC20 weth = IERC20(_addressProvider.getWETH());\n        for (uint i = 0; i < 2; i++) {\n            require(\n                tokens[i] == nativeToken || tokens[i] == weth,\n                \"G:B:INVALID_POOL_TOKENS\"\n            );\n        }\n    }\n}"
    },
    {
      "filename": "contracts/protocol/GenesisNFT.sol",
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.19;\n\nimport {IAddressProvider} from \"../interfaces/IAddressProvider.sol\";\nimport {IWETH} from \"../interfaces/IWETH.sol\";\nimport {Base64} from \"@openzeppelin/contracts/utils/Base64.sol\";\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport {IGenesisNFT} from \"../interfaces/IGenesisNFT.sol\";\nimport {INativeToken} from \"../interfaces/INativeToken.sol\";\nimport {IVotingEscrow} from \"../interfaces/IVotingEscrow.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {ERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\nimport {IERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\";\nimport {CountersUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\";\nimport {ERC721EnumerableUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {IVault} from \"@balancer-labs/v2-interfaces/contracts/vault/IVault.sol\";\nimport {WeightedPoolUserData} from \"@balancer-labs/v2-interfaces/contracts/pool-weighted/WeightedPoolUserData.sol\";\nimport {IBalancerQueries} from \"@balancer-labs/v2-interfaces/contracts/standalone-utils/IBalancerQueries.sol\";\nimport {SafeCast} from \"../libraries/utils/SafeCast.sol\";\n// solhint-disable-next-line no-global-import\nimport \"../libraries/balancer/ERC20Helpers.sol\"; // Custom (pragma ^0.8.0) ERC20 helpers for Balancer tokens\n\n/// @title GenesisNFT\n/// @author leNFT\n/// @notice This contract manages the creation and minting of Genesis NFTs\n/// @dev Interacts with a balancer pool to provide liquidty on mint\ncontract GenesisNFT is\n    ERC165Upgradeable,\n    ERC721EnumerableUpgradeable,\n    OwnableUpgradeable,\n    IGenesisNFT,\n    ReentrancyGuardUpgradeable\n{\n    uint256 private constant LP_LE_AMOUNT = 4e22; // 40000 LE\n    uint256 private constant LP_ETH_AMOUNT = 1e17; // 0.1 ETH\n    uint256 private constant MAX_CAP = 1337; // 1337 NFTs\n    uint256 private constant PRICE = 25e16; // 0.25 ETH\n    uint256 private constant MAX_LOCKTIME = 180 days;\n    uint256 private constant MIN_LOCKTIME = 14 days;\n    uint256 private constant NATIVE_TOKEN_FACTOR = 400000; // Controls the amount of native tokens minted per NFT\n\n    IAddressProvider private immutable _addressProvider;\n    address payable private _devAddress;\n    DataTypes.BalancerDetails private _balancerDetails;\n    uint256 private _maxLTVBoost;\n    CountersUpgradeable.Counter private _tokenIdCounter;\n    // Mapping from owner to create loan operator approvals\n    mapping(address => mapping(address => bool)) private _loanOperatorApprovals;\n    // NFT token id to bool that's true if NFT is being used to increase a loan's max LTV\n    mapping(uint256 => bool) private _locked;\n    // NFT token id to information about its mint\n    mapping(uint256 => DataTypes.MintDetails) private _mintDetails;\n\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    modifier onlyMarket() {\n        _requireOnlyMarket();\n        _;\n    }\n\n    modifier tokenExists(uint256 tokenId) {\n        _requireTokenExists(tokenId);\n        _;\n    }\n\n    modifier validPool() {\n        _requireValidPool();\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(IAddressProvider addressProvider) {\n        _addressProvider = addressProvider;\n        _disableInitializers();\n    }\n\n    /// @notice Initializes the contract with the specified parameters\n    /// @param maxLTVBoost max LTV boost factor\n    /// @param devAddress Address of the developer\n    function initialize(\n        uint256 maxLTVBoost,\n        address payable devAddress\n    ) external initializer {\n        __ERC721_init(\"leNFT Genesis\", \"LEGEN\");\n        __ERC721Enumerable_init();\n        __ERC165_init();\n        __Ownable_init();\n        __ReentrancyGuard_init();\n        _maxLTVBoost = maxLTVBoost;\n        _devAddress = devAddress;\n\n        // Start from token_id 1 in order to reserve '0' for the null token\n        _tokenIdCounter.increment();\n    }\n\n    /// @notice Sets an approved address as a loan operator for the caller\n    /// @dev This approval allows for the use of the genesis NFT by the loan operator in a loan\n    /// @param operator Address to set approval for\n    /// @param approved True if the operator is approved, false to revoke approval\n    function setLoanOperatorApproval(address operator, bool approved) external {\n        _loanOperatorApprovals[msg.sender][operator] = approved;\n    }\n\n    /// @notice Checks if an address is approved as a loan operator for an owner\n    /// @param owner Address of the owner\n    /// @param operator Address of the operator\n    /// @return True if the operator is approved, false otherwise\n    function isLoanOperatorApproved(\n        address owner,\n        address operator\n    ) public view returns (bool) {\n        return _loanOperatorApprovals[owner][operator];\n    }\n\n    /// @notice Returns the URI for a given token ID\n    /// @param tokenId ID of the token\n    /// @return The token's URI\n    function tokenURI(\n        uint256 tokenId\n    )\n        public\n        view\n        override(ERC721Upgradeable)\n        tokenExists(tokenId)\n        returns (string memory)\n    {\n        require(_exists(tokenId), \"G:TU:INVALID_TOKEN_ID\");\n        return\n            string(\n                abi.encodePacked(\n                    \"data:application/json;base64,\",\n                    Base64.encode(\n                        abi.encodePacked(\n                            \"{\",\n                            '\"name\": \"Genesis NFT #',\n                            Strings.toString(tokenId),\n                            '\",',\n                            '\"description\": \"leNFT Genesis Collection NFT.\",',"
    }
  ]
}