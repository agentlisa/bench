{
  "Title": "[M-03] Not calling approve(0) before setting a new approval causes the call to revert when used with Tether (USDT)",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-04-dualityfocus/blob/f21ef7708c9335ee1996142e2581cb8714a525c9/contracts/vault_and_oracles/FlashLoan.sol#L48\nhttps://github.com/code-423n4/2022-04-dualityfocus/blob/f21ef7708c9335ee1996142e2581cb8714a525c9/contracts/vault_and_oracles/FlashLoan.sol#L58\nhttps://github.com/code-423n4/2022-04-dualityfocus/blob/f21ef7708c9335ee1996142e2581cb8714a525c9/contracts/vault_and_oracles/UniV3LpVault.sol#L418\n\n\n# Vulnerability details\n\nSome tokens do not implement the ERC20 standard properly but are still accepted by most code that accepts ERC20 tokens.  For example Tether (USDT)'s `approve()` function will revert if the current approval is not zero, to protect against front-running changes of approvals.\n\n## Impact\nThe code as currently implemented does not handle these sorts of tokens properly when they're a Uniswap pool asset, which would prevent USDT, the sixth largest pool, from being used by this project. This project relies heavily on Uniswap, so this would hamper future growth and availability of the protocol.\n\n## Proof of Concept\n\n1. File: contracts/vault_and_oracles/FlashLoan.sol (line [48](https://github.com/code-423n4/2022-04-dualityfocus/blob/f21ef7708c9335ee1996142e2581cb8714a525c9/contracts/vault_and_oracles/FlashLoan.sol#L48))\n```solidity\n        IERC20(assets[0]).approve(address(LP_VAULT), amounts[0]);\n```\n\n2. File: contracts/vault_and_oracles/FlashLoan.sol (line [58](https://github.com/code-423n4/2022-04-dualityfocus/blob/f21ef7708c9335ee1996142e2581cb8714a525c9/contracts/vault_and_oracles/FlashLoan.sol#L58))\n```solidity\n        IERC20(assets[0]).approve(address(LENDING_POOL), amountOwing);\n```\n\n3. File: contracts/vault_and_oracles/UniV3LpVault.sol (line [418](https://github.com/code-423n4/2022-04-dualityfocus/blob/f21ef7708c9335ee1996142e2581cb8714a525c9/contracts/vault_and_oracles/UniV3LpVault.sol#L418))\n```solidity\n            IERC20Detailed(params.asset).approve(msg.sender, owedBack);\n```\n\nThere are other calls to `approve()`, but they correctly set the approval to zero after the transfer is done, so that the next approval can go through.\n\n## Tools Used\nCode inspection\n\n## Recommended Mitigation Steps\nUse OpenZeppelinâ€™s `SafeERC20`'s `safeTransfer()` instead\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-04-duality-focus-contest",
  "Code": [
    {
      "filename": "contracts/vault_and_oracles/FlashLoan.sol",
      "content": "pragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport { IFlashLoanReceiver, ILendingPool, ILendingPoolAddressesProvider } from \"../external/aave/AaveInterfaces.sol\";\nimport { IERC20 } from \"../external/openzeppelin/token/ERC20/IERC20.sol\";\nimport { SafeMath } from \"../external/openzeppelin/math/SafeMath.sol\";\n\nimport { CErc20Interface } from \"../interfaces/CompoundInterfaces.sol\";\nimport \"../interfaces/IUniV3LpVault.sol\";\n\n/** \n    !!!\n    Never keep funds permanently on your FlashLoanReceiverBase contract as they could be \n    exposed to a 'griefing' attack, where the stored funds are used by an attacker.\n    !!!\n */\ncontract FlashLoan is IFlashLoanReceiver {\n    using SafeMath for uint256;\n\n    ILendingPoolAddressesProvider public immutable override ADDRESSES_PROVIDER;\n    ILendingPool public immutable override LENDING_POOL;\n    IUniV3LpVault public immutable LP_VAULT;\n\n    constructor(address _addressesProvider, address _lpVault) {\n        ADDRESSES_PROVIDER = ILendingPoolAddressesProvider(_addressesProvider);\n        LENDING_POOL = ILendingPool(ILendingPoolAddressesProvider(_addressesProvider).getLendingPool());\n        LP_VAULT = IUniV3LpVault(_lpVault);\n    }\n\n    /**\n        This function is called after your contract has received the flash loaned amount\n     */\n    function executeOperation(\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata premiums,\n        address initiator,\n        bytes calldata params\n    ) external override returns (bool) {\n        require(msg.sender == address(LENDING_POOL), \"Flashloan from untrusted lending pool\");\n        require(initiator == address(LP_VAULT), \"Flashloan must be initiated from LP Vault\");\n        //\n        // This contract now has the funds requested.\n        // Your logic goes here.\n        //\n\n        IUniV3LpVault.FlashFocusParams memory focusParams = abi.decode(params, (IUniV3LpVault.FlashFocusParams));\n        IERC20(assets[0]).approve(address(LP_VAULT), amounts[0]);\n        focusParams.asset = assets[0];\n        focusParams.amount = amounts[0];\n        focusParams.premium = premiums[0];\n\n        LP_VAULT.flashFocusCall(focusParams);\n\n        // Approve the LendingPool contract allowance to *pull* the owed amount\n        uint256 amountOwing = amounts[0].add(premiums[0]);\n        IERC20(assets[0]).transferFrom(address(LP_VAULT), address(this), amountOwing);\n        IERC20(assets[0]).approve(address(LENDING_POOL), amountOwing);\n\n        return true;\n    }\n}"
    },
    {
      "filename": "contracts/vault_and_oracles/FlashLoan.sol",
      "content": "pragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport { IFlashLoanReceiver, ILendingPool, ILendingPoolAddressesProvider } from \"../external/aave/AaveInterfaces.sol\";\nimport { IERC20 } from \"../external/openzeppelin/token/ERC20/IERC20.sol\";\nimport { SafeMath } from \"../external/openzeppelin/math/SafeMath.sol\";\n\nimport { CErc20Interface } from \"../interfaces/CompoundInterfaces.sol\";\nimport \"../interfaces/IUniV3LpVault.sol\";\n\n/** \n    !!!\n    Never keep funds permanently on your FlashLoanReceiverBase contract as they could be \n    exposed to a 'griefing' attack, where the stored funds are used by an attacker.\n    !!!\n */\ncontract FlashLoan is IFlashLoanReceiver {\n    using SafeMath for uint256;\n\n    ILendingPoolAddressesProvider public immutable override ADDRESSES_PROVIDER;\n    ILendingPool public immutable override LENDING_POOL;\n    IUniV3LpVault public immutable LP_VAULT;\n\n    constructor(address _addressesProvider, address _lpVault) {\n        ADDRESSES_PROVIDER = ILendingPoolAddressesProvider(_addressesProvider);\n        LENDING_POOL = ILendingPool(ILendingPoolAddressesProvider(_addressesProvider).getLendingPool());\n        LP_VAULT = IUniV3LpVault(_lpVault);\n    }\n\n    /**\n        This function is called after your contract has received the flash loaned amount\n     */\n    function executeOperation(\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata premiums,\n        address initiator,\n        bytes calldata params\n    ) external override returns (bool) {\n        require(msg.sender == address(LENDING_POOL), \"Flashloan from untrusted lending pool\");\n        require(initiator == address(LP_VAULT), \"Flashloan must be initiated from LP Vault\");\n        //\n        // This contract now has the funds requested.\n        // Your logic goes here.\n        //\n\n        IUniV3LpVault.FlashFocusParams memory focusParams = abi.decode(params, (IUniV3LpVault.FlashFocusParams));\n        IERC20(assets[0]).approve(address(LP_VAULT), amounts[0]);\n        focusParams.asset = assets[0];\n        focusParams.amount = amounts[0];\n        focusParams.premium = premiums[0];\n\n        LP_VAULT.flashFocusCall(focusParams);\n\n        // Approve the LendingPool contract allowance to *pull* the owed amount\n        uint256 amountOwing = amounts[0].add(premiums[0]);\n        IERC20(assets[0]).transferFrom(address(LP_VAULT), address(this), amountOwing);\n        IERC20(assets[0]).approve(address(LENDING_POOL), amountOwing);\n\n        return true;\n    }\n}"
    },
    {
      "filename": "contracts/vault_and_oracles/UniV3LpVault.sol",
      "content": "pragma solidity ^0.7.6;\npragma abicoder v2;\n\n// interfaces\nimport { ComptrollerInterface, TickOracleInterface, CErc20Interface } from \"../interfaces/CompoundInterfaces.sol\";\nimport \"../interfaces/IUniV3LpVault.sol\";\nimport \"../interfaces/IERC20Detailed.sol\";\nimport { IFlashLoanReceiver } from \"../external/aave/AaveInterfaces.sol\";\nimport \"../external/openzeppelin/token/ERC721/IERC721.sol\";\nimport \"../external/uniswap/v3-periphery/interfaces/INonfungiblePositionManager.sol\";\nimport \"../external/uniswap/v3-periphery/interfaces/ISwapRouter.sol\";\n\n// libs\nimport \"../external/uniswap/v3-core/libraries/TransferHelper.sol\";\nimport \"../external/uniswap/v3-periphery/libraries/BytesLib.sol\";\nimport { Uint256Casting } from \"../external/opyn/Uint256Casting.sol\";\nimport { SafeMath } from \"../external/openzeppelin/math/SafeMath.sol\";\nimport \"../libs/LiquidityLibrary.sol\";\n\n/**\n * @title UniV3LpVault\n * @author Duality (h/t to Uniswap's UniswapV3Staker as a starting point)\n */\ncontract UniV3LpVault is IUniV3LpVault {\n    using SafeMath for uint256;\n    using Uint256Casting for uint256;\n    using BytesLib for bytes;\n\n    address public override factory;\n\n    INonfungiblePositionManager public override nonfungiblePositionManager;\n\n    ISwapRouter public override swapRouter;\n\n    ComptrollerInterface public override comptroller;\n\n    IFlashLoanReceiver public override flashLoan;\n\n    mapping(address => bool) public override flashLoanAuthorized;\n\n    /// @dev ownerOf[tokenId] => address owner\n    mapping(uint256 => address) public override ownerOf;\n\n    /// @dev userTokens[userAddress] => tokenIds[]\n    mapping(address => uint256[]) public userTokens;\n\n    /// @notice max number of userTokens for a single userAddress\n    uint256 public override userTokensMax = 4;\n\n    /// @notice whether or not periphery functionality has been paused\n    bool public peripheryGuardianPaused;\n\n    /// @notice whether or not deposits have been paused\n    bool public depositGuardianPaused;\n\n    /// @dev Guard variable for re-entrancy checks\n    bool internal _notEntered;\n\n    constructor(\n        address _factory,\n        INonfungiblePositionManager _nonfungiblePositionManager,\n        ISwapRouter _swapRouter,\n        ComptrollerInterface _comptroller\n    ) {\n        factory = _factory;\n        nonfungiblePositionManager = _nonfungiblePositionManager;\n        swapRouter = _swapRouter;\n        comptroller = _comptroller;\n        _notEntered = true;\n    }\n\n    /*** External Mutator Functions ***/\n\n    /// @dev Upon receiving a Uniswap V3 ERC721, creates the token deposit setting owner to `from`\n    /// @inheritdoc IERC721Receiver\n    function onERC721Received(\n        address,\n        address from,\n        uint256 tokenId,\n        bytes calldata\n    ) external override nonReentrant(false) returns (bytes4) {\n        require(!depositGuardianPaused, \"deposit is paused\");\n        require(msg.sender == address(nonfungiblePositionManager), \"IUniV3LpVault::onERC721Received: not a Uni V3 nft\");\n\n        _processNewToken(tokenId, from);\n        emit TokenDeposited(from, tokenId);\n        return this.onERC721Received.selector;\n    }\n\n    /**\n     * @notice Withdraw a tokenId from the vault, so long as the caller's debt is still sufficiently collateralized\n     * @param tokenId The tokenId of the NFT to be withdrawn\n     * @param to The address to send tokenId to\n     * @param data any data to provide for the safeTransferFrom call\n     */\n    function withdrawToken(\n        uint256 tokenId,\n        address to,\n        bytes memory data\n    ) external override nonReentrant(false) avoidsShortfall {\n        require(to != address(this), \"IUniV3LpVault::withdrawToken: cannot withdraw to vault\");\n        require(ownerOf[tokenId] == msg.sender, \"IUniV3LpVault::withdrawToken: only owner can withdraw token\");\n\n        _deleteOldToken(msg.sender, tokenId);\n\n        nonfungiblePositionManager.safeTransferFrom(address(this), to, tokenId, data);\n        emit TokenWithdrawn(msg.sender, to, tokenId);\n    }\n\n    /**\n     * @notice Seize fees and/or liquidity from a borrower's LP NFT, assuming the seizure is allowed.\n     *          To be called exclusively from the CToken of the debt asset (Best mirroring original compound liquidation path)\n     * @param liquidator The address of the EOA/Contract claiming the liquidation + incentive\n     * @param borrower The address of the account currently in shortfall. Owner of tokenId.\n     * @param tokenId The tokenId to be partially or fully liquidated. Owned by Borrower.\n     * @param seizeFeesToken0 The amount of token0 to seize from tokenId's fees\n     * @param seizeFeesToken1 The amount of token1 to seize from tokenId's fees\n     * @param seizeLiquidity The amount of liquidity to convert to token0/token1 and seize\n     */\n    function seizeAssets(\n        address liquidator,\n        address borrower,\n        uint256 tokenId,\n        uint256 seizeFeesToken0,\n        uint256 seizeFeesToken1,\n        uint256 seizeLiquidity\n    ) external override nonReentrant(true) {\n        require(ownerOf[tokenId] == borrower, \"borrower must own tokenId\");\n\n        // make call to comptroller to ensure seize is allowed\n        uint256 allowed = ComptrollerInterface(comptroller).seizeAllowedUniV3(\n            address(this),\n            msg.sender,\n            liquidator,\n            borrower,\n            tokenId,\n            seizeFeesToken0,\n            seizeFeesToken1,\n            seizeLiquidity\n        );\n\n        // TODO: do we want some Comptroller like error handling/messaging here?\n        require(allowed == 0, \"seize not allowed according to Comptroller\");\n\n        if (seizeLiquidity > 0) {\n            // liquidate seizeLiquidity from tokenId position\n            _decreaseLiquidity(tokenId, uint128(seizeLiquidity));\n\n            // claim all fees + tokens from liquidity removal\n            nonfungiblePositionManager.collect(\n                INonfungiblePositionManager.CollectParams(tokenId, liquidator, type(uint128).max, type(uint128).max)\n            );\n        } else {\n            // claim feesAmountToken0 and feesAmountToken1 and send to liquidator\n            nonfungiblePositionManager.collect(\n                INonfungiblePositionManager.CollectParams(\n                    tokenId,\n                    liquidator,\n                    uint128(seizeFeesToken0),\n                    uint128(seizeFeesToken1)\n                )\n            );\n        }\n    }\n\n    // TODO: do we want a \"decreaseLiquidityAndCollect\" function?\n\n    /**\n     * @notice Passthrough function to NonfungiblePositionManager for an owner of an NFT to decrease its liquidity.\n     *          Checks that the user's position is still sufficiently collateralized after taking this action\n     * @param params INonfungiblePositionManager's decreaseLiquidityParams for the passthrough call\n     */\n    function decreaseLiquidity(INonfungiblePositionManager.DecreaseLiquidityParams calldata params)\n        external\n        override\n        nonReentrant(false)\n        isAuthorizedForToken(params.tokenId)\n        avoidsShortfall\n    {\n        require(!peripheryGuardianPaused, \"periphery functionality is paused\");\n\n        nonfungiblePositionManager.decreaseLiquidity(params);\n        emit LiquidityDecreased(msg.sender, params.tokenId, params.liquidity);\n    }\n\n    /**\n     * @notice Passthrough function to NonfungiblePositionManager for an owner of an NFT to collect its fees.\n     *          Checks that the user's position is still sufficiently collateralized after taking this action\n     * @param params INonfungiblePositionManager's CollectParams for the passthrough call\n     */\n    function collectFees(INonfungiblePositionManager.CollectParams calldata params)\n        external\n        override\n        nonReentrant(false)\n        isAuthorizedForToken(params.tokenId)\n        avoidsShortfall\n    {\n        require(!peripheryGuardianPaused, \"periphery functionality is paused\");\n\n        (uint256 amount0, uint256 amount1) = nonfungiblePositionManager.collect(params);\n        emit FeesCollected(msg.sender, params.tokenId, amount0, amount1);\n    }\n\n    /**\n     * @notice function for an owner of an NFT to automatically compound fees into liquidity of a range.\n     *          Checks that the user's position is still sufficiently collateralized after taking this action\n     *\n     *          Target balance of fees for swap are pre-computed off-chain along with slippage tolerance.\n     *\n     *          Swap is made by swapping the extra of token0 (according to expectedAmount0) to token1, depositing\n     *          the max liquidity possible (along with min checks), and any remnants left are sent back to the user\n     *\n     * @param params our CompoundFeesParams, described at definition in the interface\n     */\n    function compoundFees(CompoundFeesParams calldata params)\n        external\n        override\n        nonReentrant(false)\n        isAuthorizedForToken(params.tokenId)\n        avoidsShortfall\n    {\n        require(!peripheryGuardianPaused, \"periphery functionality is paused\");\n\n        // collect all fees\n        (uint256 amount0, uint256 amount1) = _collectMax(params.tokenId);\n\n        address token0;\n        address token1;\n\n        {\n            // avoid stack too deep\n            uint24 fee;\n            (, , token0, token1, fee, , , , , , , ) = nonfungiblePositionManager.positions(params.tokenId);\n\n            // trade assets to expectedAmounts (assuming correct off-chain computation)\n            (amount0, amount1) = _prepareForDeposit(\n                token0,\n                token1,\n                fee,\n                params.expectedAmount0,\n                params.expectedAmount1,\n                amount0,\n                amount1\n            );\n        }\n\n        // attempt to deposit amount0 and amount1 into our range\n        (uint256 amountTaken0, uint256 amountTaken1) = _increaseLiquidity(\n            params.tokenId,\n            token0,\n            token1,\n            amount0,\n            amount1,\n            params.amount0Min,\n            params.amount1Min\n        );\n\n        uint256 amountReturned0 = amount0 > amountTaken0 ? amount0.sub(amountTaken0) : 0;\n        uint256 amountReturned1 = amount1 > amountTaken1 ? amount1.sub(amountTaken1) : 0;\n\n        // send back remnants to user\n        if (amountReturned0 > 0) TransferHelper.safeTransfer(token0, msg.sender, amountReturned0);\n        if (amountReturned1 > 0) TransferHelper.safeTransfer(token1, msg.sender, amountReturned1);\n        emit FeesCompounded(msg.sender, params.tokenId, amountTaken0, amountTaken1, amountReturned0, amountReturned1);\n    }\n\n    /**\n     * @notice function for an owner of an NFT to move liquidity of one range into a new range.\n     *          Checks that the user's position is still sufficiently collateralized after taking this action\n     *\n     *          Target balance of fees for swap are pre-computed off-chain along with slippage tolerance.\n     *\n     *          Swap is made by swapping the extra of token0 (according to expectedAmount0) to token1, depositing\n     *          the max liquidity possible (along with min checks), and any remnants left are sent back to the user\n     *\n     * @param params our MoveRangeParams, described at definition in the interface\n     * @return newTokenId The tokenId of our new Uni V3 LP position\n     */\n    function moveRange(MoveRangeParams calldata params)\n        external\n        override\n        nonReentrant(false)\n        isAuthorizedForToken(params.tokenId)\n        avoidsShortfall\n        returns (uint256 newTokenId)\n    {\n        require(!peripheryGuardianPaused, \"periphery functionality is paused\");\n\n        // remove params.liquidity from token (moves to token's fees)\n        if (params.liquidity > 0) _decreaseLiquidity(params.tokenId, params.liquidity);\n\n        // collect all fees (includes decreased liquidity)\n        (uint256 amount0, uint256 amount1) = _collectMax(params.tokenId);\n\n        (, , address token0, address token1, uint24 fee, , , , , , , ) = nonfungiblePositionManager.positions(\n            params.tokenId\n        );\n\n        // trade assets to expectedAmounts (assuming correct off-chain computation)\n        (amount0, amount1) = _prepareForDeposit(\n            token0,\n            token1,\n            fee,\n            params.expectedAmount0,\n            params.expectedAmount1,\n            amount0,\n            amount1\n        );\n\n        // prepare mintParams\n        INonfungiblePositionManager.MintParams memory mintParams = INonfungiblePositionManager.MintParams(\n            token0,\n            token1,\n            fee,\n            params.newTickLower,\n            params.newTickUpper,\n            amount0,\n            amount1,\n            params.amount0Min,\n            params.amount1Min,\n            msg.sender, // _mint utilizes this appropriately\n            block.timestamp + 200\n        );\n\n        // burn old token if emptied\n        (, , , , , , , uint128 newLiquidity, , , , ) = nonfungiblePositionManager.positions(params.tokenId);\n        if (newLiquidity == 0) _burn(msg.sender, params.tokenId);\n\n        {\n            uint256 amountTaken0;\n            uint256 amountTaken1;\n\n            // mint new range\n            (newTokenId, amountTaken0, amountTaken1) = _mint(mintParams);\n\n            // send back remnants to user\n            if (amount0 > amountTaken0) TransferHelper.safeTransfer(token0, msg.sender, amount0.sub(amountTaken0));\n            if (amount1 > amountTaken1) TransferHelper.safeTransfer(token1, msg.sender, amount1.sub(amountTaken1));\n        }\n\n        emit RangeMoved(msg.sender, params.tokenId, newTokenId, params.liquidity, newLiquidity == 0);\n    }\n\n    /**\n     * @notice function only to be called by flashloan contract initiated from the NFT owner\n     * @param params our MoveRangeParams, described at definition in the interface\n     */\n    function flashFocusCall(FlashFocusParams calldata params) external override {\n        address owner = ownerOf[params.tokenId];\n        (, , address token0, address token1, , , , , , , , ) = nonfungiblePositionManager.positions(params.tokenId);\n\n        bool tokenOfPool = params.asset == token0 || params.asset == token1;\n\n        require(!peripheryGuardianPaused, \"periphery functionality is paused\");\n        require(msg.sender == address(flashLoan), \"Can only be called from our flashLoan contract\");\n        require(flashLoanAuthorized[owner], \"flashLoan action must have been authorized by tokenId owner\");\n        require(\n            tokenOfPool || params.swapPath.length > 0,\n            \"flashLoaned asset must be a pool asset or swapping to token0\"\n        );\n        require(_checkSwapPath(params.swapPath, params.asset, token0), \"swapPath did not pass integrity check\");\n\n        flashLoanAuthorized[owner] = false;\n\n        // transfer flashLoaned assets to vault\n        IERC20Detailed(params.asset).transferFrom(msg.sender, address(this), params.amount);\n\n        uint256 amount0;\n        uint256 amount1;\n\n        {\n            // creating local scope, avoiding stack too deep\n\n            // calculate our starting amounts of each asset\n            uint256 amountIn0 = params.asset == token0 ? params.amount : 0;\n            uint256 amountIn1 = params.asset == token1 ? params.amount : 0;\n\n            // swap everything to token0 if swap path is provided and params.asset is neither of the tokens\n            if (!tokenOfPool && params.swapPath.length > 0) amountIn0 = _swap(params.swapPath, params.amount);\n\n            (, , , , uint24 fee, , , , , , , ) = nonfungiblePositionManager.positions(params.tokenId);\n\n            // trade assets to expectedAmounts (assuming correct off-chain computation)\n            (amount0, amount1) = _prepareForDeposit(\n                token0,\n                token1,\n                fee,\n                params.expectedAmount0,\n                params.expectedAmount1,\n                amountIn0,\n                amountIn1\n            );\n        }\n\n        // attempt to deposit amount0 and amount1 into our range\n        (uint256 amountTaken0, uint256 amountTaken1) = _increaseLiquidity(\n            params.tokenId,\n            token0,\n            token1,\n            amount0,\n            amount1,\n            params.amount0Min,\n            params.amount1Min\n        );\n\n        {\n            // another local scope :)\n            uint256 owedBack = params.amount.add(params.premium);\n\n            // borrow the flashloaned asset in preparation for closing loan\n            uint256 success = CErc20Interface(comptroller.cTokensByUnderlying(params.asset)).borrowBehalf(\n                owner,\n                owedBack\n            );\n            require(success == 0, \"borrow failed\");\n\n            // approve borrowed assets for flashLoan to pull\n            IERC20Detailed(params.asset).approve(msg.sender, owedBack);\n        }\n\n        uint256 amountReturned0 = amount0 > amountTaken0 ? amount0.sub(amountTaken0) : 0;\n        uint256 amountReturned1 = amount1 > amountTaken1 ? amount1.sub(amountTaken1) : 0;\n\n        // send back remnants to user\n        if (amountReturned0 > 0) TransferHelper.safeTransfer(token0, msg.sender, amountReturned0);\n        if (amountReturned1 > 0) TransferHelper.safeTransfer(token1, msg.sender, amountReturned1);\n        emit FlashFocus(\n            msg.sender,\n            params.tokenId,\n            params.asset,\n            params.amount,\n            amountTaken0,\n            amountTaken1,\n            amountReturned0,\n            amountReturned1\n        );\n    }\n\n    /**\n     * @notice function for an owner of an NFT to be able enter into a focused position in one click.\n     *          Allows a user, via flashloan, to open debt and re-deposit as liquidity into their NFT range\n     *          up to max leverage in one tx.\n     *          Reentrancy guard must be local, or split up around call to CToken\n     * @param params our FlashFocusParams, described at definition in the interface\n     */\n    function flashFocus(FlashFocusParams calldata params)\n        external\n        override\n        nonReentrant(true)\n        isAuthorizedForToken(params.tokenId)\n        avoidsShortfall\n    {\n        require(!peripheryGuardianPaused, \"periphery functionality is paused\");\n        address receiverAddress = address(flashLoan);\n\n        address[] memory assets = new address[](1);\n        uint256[] memory amounts = new uint256[](1);\n        uint256[] memory modes = new uint256[](1);\n\n        assets[0] = params.asset;\n        amounts[0] = params.amount;\n        modes[0] = 0;\n\n        address onBehalfOf = address(this);\n        bytes memory newParams = abi.encode(params);\n        uint16 referralCode = 0;\n\n        flashLoanAuthorized[msg.sender] = true;\n        flashLoan.LENDING_POOL().flashLoan(\n            receiverAddress,\n            assets,\n            amounts,\n            modes,\n            onBehalfOf,\n            newParams,\n            referralCode\n        );\n    }\n\n    /**\n     * @notice function for an owner of an NFT to be able to repay a debt using an NFT in one click.\n     *          Allows a user to repay debt by removing liquidity / fees from an NFT and swapping to\n     *          the debt token in one tx.\n     * @param params our RepayDebtParams, described at definition in the interface\n     * @return amountReturned The amount of the debtToken returned to the function caller\n     */\n    function repayDebt(RepayDebtParams calldata params)\n        external\n        override\n        nonReentrant(true)\n        isAuthorizedForToken(params.tokenId)\n        avoidsShortfall\n        returns (uint256 amountReturned)\n    {\n        require(!peripheryGuardianPaused, \"periphery functionality is paused\");\n        require(comptroller.markets(params.debtCToken).isListed, \"Debt CToken must be listed by comptroller\");\n        require(\n            params.underlying == CErc20Interface(params.debtCToken).underlying(),\n            \"Underlying must match CToken underlying\"\n        );\n\n        (, , address token0, address token1, , , , , , , , ) = nonfungiblePositionManager.positions(params.tokenId);\n        require(_checkSwapPath(params.swapPath0, token0, params.underlying), \"swapPath0 did not pass integrity check\");\n        require(_checkSwapPath(params.swapPath1, token1, params.underlying), \"swapPath1 did not pass integrity check\");\n\n        // remove params.liquidity from token (moves to token's fees)\n        if (params.liquidity > 0) _decreaseLiquidity(params.tokenId, params.liquidity);\n\n        uint256 amountOutTotal;\n\n        {\n            // collect all fees (includes decreased liquidity)\n            (uint256 amount0, uint256 amount1) = _collectMax(params.tokenId);\n\n            // calculate the totalAmount of debt asset we have.\n            // check if token0 or token1 are the debt asset. otherwise, swap token0 and token1 to debt asset using swapPaths\n            uint256 amountOutFrom0 = token0 == params.underlying ? amount0 : 0;\n            uint256 amountOutFrom1 = token1 == params.underlying ? amount1 : 0;\n\n            if (amountOutFrom0 == 0 && params.swapPath0.length > 0) amountOutFrom0 = _swap(params.swapPath0, amount0);\n            if (amountOutFrom1 == 0 && params.swapPath1.length > 0) amountOutFrom1 = _swap(params.swapPath1, amount1);\n\n            // total amount of debtAsset we've collected to use towards repay\n            amountOutTotal = amountOutFrom0.add(amountOutFrom1);\n        }\n\n        require(\n            amountOutTotal > params.repayAmount,\n            \"not enough liquidity burned: Repay debt must repay repayAmount of debt\"\n        );\n\n        // repay the debt for user with new funds\n        IERC20Detailed(params.underlying).approve(address(params.debtCToken), params.repayAmount);\n        uint256 succeeded = CErc20Interface(params.debtCToken).repayBorrowBehalf(msg.sender, params.repayAmount);\n        require(succeeded == 0, \"repay debt did not succeed\");\n        IERC20Detailed(params.underlying).approve(address(params.debtCToken), 0);\n\n        // return remnants to user\n        amountReturned = amountOutTotal > params.repayAmount ? amountOutTotal.sub(params.repayAmount) : 0;\n\n        if (amountReturned > 0) TransferHelper.safeTransfer(params.underlying, msg.sender, amountReturned);\n\n        emit RepayDebt(\n            msg.sender,\n            params.tokenId,\n            params.liquidity,\n            params.debtCToken,\n            params.underlying,\n            params.repayAmount,\n            amountReturned\n        );\n    }\n\n    /*** External View Functions ***/\n\n    /**\n     * @notice gets the length of UserTokens for an account. Allows comptroller to query NFTs for value\n     * @param account The address of the account we want the user tokens length for\n     * @return length The length of the user's userTokens array\n     */\n    function getUserTokensLength(address account) external view override returns (uint256 length) {\n        length = userTokens[account].length;\n    }\n\n    /**\n     * @notice gets the poolAddress for a deposited tokenId\n     * @param tokenId The tokenId to get the poolAddress of\n     * @return poolAddress The address of the pool the token is a deposit of\n     */\n    function getPoolAddress(uint256 tokenId) external view override returns (address poolAddress) {\n        poolAddress = _getPoolAddress(tokenId);\n    }\n\n    /*** Internal Mutator Functions ***/\n\n    /**\n     * @notice Internal function to prepare for a deposit liquidity into a Uni V3 range.\n     *          uses a pool to swap amount0 and amount1 to expectedAmount0 and expectedAmount1.\n     *          uses naive logic, assumes adequate off-chain computation for expectedAmounts\n     *\n     * @param token0 Address of token0\n     * @param token1 Address of token1\n     * @param fee Fee of the pool to swap with\n     * @param expectedAmount0 The amount of token0 that we expect to deposit into a range\n     * @param expectedAmount1 The amount of token1 that we expect to deposit into a range\n     * @param amount0 The amount of token0 that we currently hold and are preparing for deposit (some may be swapped for token1)\n     * @param amount1 The amount of token1 that we currently hold and are preparing for deposit (some may be swapped for token1)\n     * @return newAmount0 Amount of token0 after preparation\n     *         newAmount1 Amount of token1 after preparation\n     */\n    function _prepareForDeposit(\n        address token0,\n        address token1,\n        uint24 fee,\n        uint256 expectedAmount0,\n        uint256 expectedAmount1,\n        uint256 amount0,\n        uint256 amount1\n    ) internal returns (uint256 newAmount0, uint256 newAmount1) {\n        if (expectedAmount0 < amount0) {\n            // have extra token0, trade all of the extra to token1\n            uint256 amountOut = _swap(abi.encodePacked(token0, fee, token1), amount0.sub(expectedAmount0));\n            newAmount0 = expectedAmount0;\n            newAmount1 = amount1.add(amountOut);\n        } else if (expectedAmount1 < amount1) {\n            // have extra of token1, trade all of the extra to token0\n            uint256 amountOut = _swap(abi.encodePacked(token1, fee, token0), amount1.sub(expectedAmount1));\n            newAmount0 = amount0.add(amountOut);\n            newAmount1 = expectedAmount1;\n        } else {\n            newAmount0 = amount0;\n            newAmount1 = amount1;\n        }\n    }\n\n    /**\n     * @notice Executes a swap. Performs necessary approval beforehand, and zeros out afterwards for safety\n     * @param swapPath The path to swap along\n     * @param amount The amount of the first token to swap\n     */\n    function _swap(bytes memory swapPath, uint256 amount) internal returns (uint256 amountOut) {\n        IERC20Detailed(swapPath.toAddress(0)).approve(address(swapRouter), amount);\n        amountOut = swapRouter.exactInput(\n            ISwapRouter.ExactInputParams(swapPath, address(this), block.timestamp + 200, amount, 0)\n        );\n        IERC20Detailed(swapPath.toAddress(0)).approve(address(swapRouter), 0);\n    }\n\n    /**\n     * @notice Increases liquidity of a Uni V3 NFT\n     * @param tokenId The tokenId of the NFT we are depositing liquidity into\n     * @param token0 The address of the first token of the pool\n     * @param token1 The address of the second token of the pool\n     * @param amount0 The amount of token0 that we expect to deposit\n     * @param amount1 The amount of token1 that we expect to deposit\n     * @param amount0Min The min amount of token0 that we are willing to deposit (slippage check)\n     * @param amount1Min The min amount of token1 that we are willing to deposit (slippage check)\n     * @return amountOut0 Amount of token0 deposited into tokenId\n     *         amountOut1 Amount of token1 deposited into tokenId\n     */\n    function _increaseLiquidity(\n        uint256 tokenId,\n        address token0,\n        address token1,\n        uint256 amount0,\n        uint256 amount1,\n        uint256 amount0Min,\n        uint256 amount1Min\n    ) internal returns (uint256 amountOut0, uint256 amountOut1) {\n        IERC20Detailed(token0).approve(address(nonfungiblePositionManager), amount0);\n        IERC20Detailed(token1).approve(address(nonfungiblePositionManager), amount1);\n\n        // deposit liquidity into tokenId\n        (, amountOut0, amountOut1) = nonfungiblePositionManager.increaseLiquidity(\n            INonfungiblePositionManager.IncreaseLiquidityParams(\n                tokenId,\n                amount0,\n                amount1,\n                amount0Min,\n                amount1Min,\n                block.timestamp + 200\n            )\n        );\n\n        IERC20Detailed(to"
    }
  ]
}