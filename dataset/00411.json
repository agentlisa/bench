{
  "Title": "H-7: TOFTOptionsReceiverModule miss cross-chain transformation for deposit and lock amounts",
  "Content": "# Issue H-7: TOFTOptionsReceiverModule miss cross-chain transformation for deposit and lock amounts \n\nSource: https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/87 \n\n## Found by \nhyh\n## Summary\n\nCross-chain token decimals transformation is applied partially in TOFTOptionsReceiverModule's `lockAndParticipateReceiver()` and `mintLendXChainSGLXChainLockAndParticipateReceiver()`.\n\n## Vulnerability Detail\n\nCurrently only first level amounts are being transformed in cross-chain TOFTOptionsReceiverModule, while the nested deposit and lock amounts involved aren't.\n\nWhenever the decimals are different for underlying tokens across chains the absence of transformation will lead to magnitudes sized misrepresentation of user operations, which can result in core functionality unavailability (operations can constantly revert or become a noops due to running them with outsized or dust sized parameters) and loss of user funds (when an operation was successfully run, but with severely misrepresented parameters).\n\n## Impact\n\nProbability can be estimated as medium due to prerequisite of having asset decimals difference between transacting chains, while the operation misrepresentation and possible fund loss impact described itself has high severity.\n\nLikelihood: Medium + Impact: High = Severity: High.\n\n## Code Snippet\n\nOnly `mintAmount` is being transformed in `mintLendXChainSGLXChainLockAndParticipateReceiver()`:\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/TapiocaZ/contracts/tOFT/modules/TOFTOptionsReceiverModule.sol#L72-L82\n\n```solidity\n    function mintLendXChainSGLXChainLockAndParticipateReceiver(bytes memory _data) public payable {\n        // Decode received message.\n        CrossChainMintFromBBAndLendOnSGLData memory msg_ =\n            TOFTMsgCodec.decodeMintLendXChainSGLXChainLockAndParticipateMsg(_data);\n\n        _checkWhitelistStatus(msg_.bigBang);\n        _checkWhitelistStatus(msg_.magnetar);\n\n        if (msg_.mintData.mintAmount > 0) {\n            msg_.mintData.mintAmount = _toLD(msg_.mintData.mintAmount.toUint64());\n        }\n```\n\nBut collateral deposit amount from `CrossChainMintFromBBAndLendOnSGLData.mintData.collateralDepositData` there isn't:\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/TapiocaZ/gitmodule/tapioca-periph/contracts/interfaces/periph/IMagnetar.sol#L104-L111\n\n```solidity\nstruct CrossChainMintFromBBAndLendOnSGLData {\n    address user;\n    address bigBang;\n    address magnetar;\n    address marketHelper;\n>>  IMintData mintData;\n    LendOrLockSendParams lendSendParams;\n}\n```\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/TapiocaZ/gitmodule/tapioca-periph/contracts/interfaces/oft/IUsdo.sol#L136-L140\n\n```solidity\nstruct IMintData {\n    bool mint;\n    uint256 mintAmount;\n>>  IDepositData collateralDepositData;\n}\n```\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/TapiocaZ/gitmodule/tapioca-periph/contracts/interfaces/common/ICommonData.sol#L22-L25\n\n```solidity\nstruct IDepositData {\n    bool deposit;\n>>  uint256 amount;\n}\n```\n\nSimilarly option lock's `amount` and `fraction` from `LockAndParticipateData` in `lockAndParticipateReceiver()`:\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/TapiocaZ/contracts/tOFT/modules/TOFTOptionsReceiverModule.sol#L106-L121\n\n```solidity\n    function lockAndParticipateReceiver(bytes memory _data) public payable {\n        // Decode receive message\n        LockAndParticipateData memory msg_ = TOFTMsgCodec.decodeLockAndParticipateMsg(_data);\n\n        _checkWhitelistStatus(msg_.magnetar);\n        _checkWhitelistStatus(msg_.singularity);\n        if (msg_.lockData.lock) {\n            _checkWhitelistStatus(msg_.lockData.target);\n        }\n        if (msg_.participateData.participate) {\n            _checkWhitelistStatus(msg_.participateData.target);\n        }\n\n        if (msg_.fraction > 0) {\n            msg_.fraction = _toLD(msg_.fraction.toUint64());\n        }\n```\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/TapiocaZ/gitmodule/tapioca-periph/contracts/interfaces/periph/IMagnetar.sol#L135-L142\n\n```solidity\nstruct LockAndParticipateData {\n    address user;\n    address singularity;\n    address magnetar;\n    uint256 fraction;\n>>  IOptionsLockData lockData;\n    IOptionsParticipateData participateData;\n}\n```\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/TapiocaZ/gitmodule/tapioca-periph/contracts/interfaces/tap-token/ITapiocaOptionLiquidityProvision.sol#L30-L36\n\n```solidity\nstruct IOptionsLockData {\n    bool lock;\n    address target;\n    uint128 lockDuration;\n>>  uint128 amount;\n>>  uint256 fraction;\n}\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider adding these local decimals transformations, e.g.:\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/TapiocaZ/contracts/tOFT/modules/TOFTOptionsReceiverModule.sol#L80-L82\n\n```diff\n        if (msg_.mintData.mintAmount > 0) {\n            msg_.mintData.mintAmount = _toLD(msg_.mintData.mintAmount.toUint64());\n        }\n+       if (msg_.mintData.collateralDepositData.amount > 0) {\n+           msg_.mintData.collateralDepositData.amount = _toLD(msg_.mintData.collateralDepositData.amount.toUint64());\n+       }\n```\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/TapiocaZ/contracts/tOFT/modules/TOFTOptionsReceiverModule.sol#L112-L114\n\n```diff\n        if (msg_.lockData.lock) {\n            _checkWhitelistStatus(msg_.lockData.target);\n+           if (msg_.lockData.amount > 0) msg_.lockData.amount = _toLD(msg_.lockData.amount.toUint64());\n+           if (msg_.lockData.fraction > 0) msg_.lockData.fraction = _toLD(msg_.lockData.fraction.toUint64());\n        }\n```\n\n\n\n## Discussion\n\n**nevillehuang**\n\n@dmitriia Could you please provide a valid explicit example for supported chains (Arbitrum, Mainnet, Optimism, Avalanche) to validate your issue?\n\n**dmitriia**\n\nFor example, the list of gas token LSDs that can be used as a collateral in BB [isn't final](https://docs.tapioca.xyz/tapioca/core-technologies/big-bang#genesis-big-bang-markets). `msg_.mintData.collateralDepositData.amount`, which conversion is missed, can be the amount of LSD to be put in as a collateral for USDO minting.\n\nThat is, if after deployment a LSD be accepted that have different decimals across supported chains, this will have an impact of magnitudes.\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/Tapioca-DAO/TapiocaZ/pull/178.\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/170",
  "Code": [
    {
      "filename": "TapiocaZ/contracts/tOFT/modules/TOFTOptionsReceiverModule.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// LZ\nimport {\n    MessagingReceipt, OFTReceipt, SendParam\n} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/interfaces/IOFT.sol\";\nimport {IOAppMsgInspector} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/interfaces/IOAppMsgInspector.sol\";\nimport {OFTMsgCodec} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/libs/OFTMsgCodec.sol\";\n\n// External\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n// Tapioca\nimport {\n    LockAndParticipateData,\n    IMagnetar,\n    MagnetarCall,\n    MagnetarAction,\n    CrossChainMintFromBBAndLendOnSGLData\n} from \"tapioca-periph/interfaces/periph/IMagnetar.sol\";\nimport {\n    ITapiocaOptionBroker, IExerciseOptionsData\n} from \"tapioca-periph/interfaces/tap-token/ITapiocaOptionBroker.sol\";\nimport {TOFTInitStruct, ExerciseOptionsMsg, LZSendParam} from \"tapioca-periph/interfaces/oft/ITOFT.sol\";\nimport {MagnetarMintXChainModule} from \"tapioca-periph/Magnetar/modules/MagnetarMintXChainModule.sol\";\nimport {TOFTMsgCodec} from \"contracts/tOFT/libraries/TOFTMsgCodec.sol\";\nimport {SafeApprove} from \"tapioca-periph/libraries/SafeApprove.sol\";\nimport {BaseTOFT} from \"contracts/tOFT/BaseTOFT.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title TOFTOptionsReceiverModule\n * @author TapiocaDAO\n * @notice TOFT Options module\n */\ncontract TOFTOptionsReceiverModule is BaseTOFT {\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n    using SafeApprove for address;\n\n    error TOFTOptionsReceiverModule_NotAuthorized(address invalidAddress);\n\n    event ExerciseOptionsReceived(\n        address indexed user, address indexed target, uint256 indexed oTapTokenId, uint256 paymentTokenAmount\n    );\n\n    constructor(TOFTInitStruct memory _data) BaseTOFT(_data) {}\n\n    /**\n     * @notice cross-chain receiver to deposit mint from BB, lend on SGL, lock on tOLP and participate on tOB\n     * @dev Cross chain flow:\n     *  step 1: magnetar.mintBBLendXChainSGL (chain A) -->\n     *         step 2: IUsdo compose call calls magnetar.depositYBLendSGLLockXchainTOLP (chain B) -->\n     *              step 3: IToft(sglReceipt) compose call calls magnetar.lockAndParticipate (chain X)\n     * @param _data.user the user to perform the operation for\n     * @param _data.bigBang the BB address\n     * @param _data.mintData the data needed to mint on BB\n     * @param _data.lendSendParams LZ send params for lending on another layer\n     */\n    function mintLendXChainSGLXChainLockAndParticipateReceiver(bytes memory _data) public payable {\n        // Decode received message.\n        CrossChainMintFromBBAndLendOnSGLData memory msg_ =\n            TOFTMsgCodec.decodeMintLendXChainSGLXChainLockAndParticipateMsg(_data);\n\n        _checkWhitelistStatus(msg_.bigBang);\n        _checkWhitelistStatus(msg_.magnetar);\n\n        if (msg_.mintData.mintAmount > 0) {\n            msg_.mintData.mintAmount = _toLD(msg_.mintData.mintAmount.toUint64());\n        }\n\n        bytes memory call = abi.encodeWithSelector(MagnetarMintXChainModule.mintBBLendXChainSGL.selector, msg_);\n        MagnetarCall[] memory magnetarCall = new MagnetarCall[](1);\n        magnetarCall[0] = MagnetarCall({\n            id: MagnetarAction.MintXChainModule,\n            target: address(this),\n            value: msg.value,\n            allowFailure: false,\n            call: call\n        });\n        IMagnetar(payable(msg_.magnetar)).burst{value: msg.value}(magnetarCall);\n    }\n\n    /**\n     * @notice Execute `magnetar.lockAndParticipate`\n     * @dev Lock on tOB and/or participate on tOLP\n     * @param _data The call data containing info about the operation.\n     * @param _data.user the user to perform the operation for\n     * @param _data.singularity the SGL address\n     * @param _data.fraction the amount to lock\n     * @param _data.lockData the data needed to lock on tOB\n     * @param _data.participateData the data needed to participate on tOLP\n     */\n    function lockAndParticipateReceiver(bytes memory _data) public payable {\n        // Decode receive message\n        LockAndParticipateData memory msg_ = TOFTMsgCodec.decodeLockAndParticipateMsg(_data);\n\n        _checkWhitelistStatus(msg_.magnetar);\n        _checkWhitelistStatus(msg_.singularity);\n        if (msg_.lockData.lock) {\n            _checkWhitelistStatus(msg_.lockData.target);\n        }\n        if (msg_.participateData.participate) {\n            _checkWhitelistStatus(msg_.participateData.target);\n        }\n\n        if (msg_.fraction > 0) {\n            msg_.fraction = _toLD(msg_.fraction.toUint64());\n        }\n\n        bytes memory call = abi.encodeWithSelector(MagnetarMintXChainModule.lockAndParticipate.selector, msg_);\n        MagnetarCall[] memory magnetarCall = new MagnetarCall[](1);\n        magnetarCall[0] = MagnetarCall({\n            id: MagnetarAction.MintXChainModule,\n            target: msg_.magnetar,\n            value: msg.value,\n            allowFailure: false,\n            call: call\n        });\n        IMagnetar(payable(msg_.magnetar)).burst{value: msg.value}(magnetarCall);\n    }\n\n    /**\n     * @notice Exercise tOB option\n     * @param _data The call data containing info about the operation.\n     *      - optionsData::address: TapiocaOptionsBroker exercise params.\n     *      - lzSendParams::struct: LZ v2 send to source params.\n     *      - composeMsg::bytes: Further compose data.\n     */\n    function exerciseOptionsReceiver(address srcChainSender, bytes memory _data) public payable {\n        // Decode received message.\n        ExerciseOptionsMsg memory msg_ = TOFTMsgCodec.decodeExerciseOptionsMsg(_data);\n\n        _checkWhitelistStatus(msg_.optionsData.target);\n        _checkWhitelistStatus(OFTMsgCodec.bytes32ToAddress(msg_.lzSendParams.sendParam.to));\n\n        {\n            // _data declared for visibility.\n            IExerciseOptionsData memory _options = msg_.optionsData;\n            _options.tapAmount = _toLD(_options.tapAmount.toUint64());\n            _options.paymentTokenAmount = _toLD(_options.paymentTokenAmount.toUint64());\n\n            // @dev retrieve paymentToken amount\n            _internalTransferWithAllowance(_options.from, srcChainSender, _options.paymentTokenAmount);\n\n            /// Does this: _approve(address(this), _options.target, _options.paymentTokenAmount);\n            pearlmit.approve(\n                address(this), 0, _options.target, uint200(_options.paymentTokenAmount), uint48(block.timestamp + 1)\n            ); // Atomic approval\n            address(this).safeApprove(address(pearlmit), _options.paymentTokenAmount);\n\n            /// @dev call exerciseOption() with address(this) as the payment token\n            uint256 bBefore = balanceOf(address(this));\n            ITapiocaOptionBroker(_options.target).exerciseOption(\n                _options.oTAPTokenID,\n                address(this), //payment token\n                _options.tapAmount\n            );\n            address(this).safeApprove(address(pearlmit), 0); // Clear approval\n            uint256 bAfter = balanceOf(address(this));\n\n            // Refund if less was used.\n            if (bBefore > bAfter) {\n                uint256 diff = bBefore - bAfter;\n                if (diff < _options.paymentTokenAmount) {\n                    IERC20(address(this)).safeTransfer(_options.from, _options.paymentTokenAmount - diff);\n                }\n            }\n        }\n\n        {\n            // _data declared for visibility.\n            IExerciseOptionsData memory _options = msg_.optionsData;\n            SendParam memory _send = msg_.lzSendParams.sendParam;\n\n            address tapOft = ITapiocaOptionBroker(_options.target).tapOFT();\n            if (msg_.withdrawOnOtherChain) {\n                /// @dev determine the right amount to send back to source\n                uint256 amountToSend = _send.amountLD > _options.tapAmount ? _options.tapAmount : _send.amountLD;\n                if (_send.minAmountLD > amountToSend) {\n                    _send.minAmountLD = amountToSend;\n                }\n\n                // Sends to source and preserve source `msg.sender` (`from` in this case).\n                _sendPacket(msg_.lzSendParams, msg_.composeMsg, _options.from);\n\n                // Refund extra amounts\n                if (_options.tapAmount - amountToSend > 0) {\n                    IERC20(tapOft).safeTransfer(_options.from, _options.tapAmount - amountToSend);\n                }\n            } else {\n                //send on this chain\n                IERC20(tapOft).safeTransfer(_options.from, _options.tapAmount);\n            }\n        }\n    }\n\n    function _checkWhitelistStatus(address _addr) private view {\n        if (_addr != address(0)) {\n            if (!cluster.isWhitelisted(0, _addr)) {\n                revert TOFTOptionsReceiverModule_NotAuthorized(_addr);\n            }\n        }\n    }\n\n    function _sendPacket(LZSendParam memory _lzSendParam, bytes memory _composeMsg, address _srcChainSender)\n        private\n        returns (MessagingReceipt memory msgReceipt, OFTReceipt memory oftReceipt)\n    {\n        /// @dev Applies the token transfers regarding this send() operation.\n        // - amountDebitedLD is the amount in local decimals that was ACTUALLY debited from the sender.\n        // - amountToCreditLD is the amount in local decimals that will be credited to the recipient on the remote OFT instance.\n        (uint256 amountDebitedLD, uint256 amountToCreditLD) =\n            _debit(_lzSendParam.sendParam.amountLD, _lzSendParam.sendParam.minAmountLD, _lzSendParam.sendParam.dstEid);\n\n        /// @dev Builds the options and OFT message to quote in the endpoint.\n        (bytes memory message, bytes memory options) = _buildOFTMsgAndOptionsMemory(\n            _lzSendParam.sendParam, _lzSendParam.extraOptions, _composeMsg, amountToCreditLD, _srcChainSender\n        );\n\n        /// @dev Sends the message to the LayerZero endpoint and returns the LayerZero msg receipt.\n        msgReceipt =\n            _lzSend(_lzSendParam.sendParam.dstEid, message, options, _lzSendParam.fee, _lzSendParam.refundAddress);\n        /// @dev Formulate the OFT receipt.\n        oftReceipt = OFTReceipt(amountDebitedLD, amountToCreditLD);\n\n        emit OFTSent(msgReceipt.guid, _lzSendParam.sendParam.dstEid, msg.sender, amountDebitedLD);\n    }\n    /**\n     * @dev For details about this function, check `BaseTapiocaOmnichainEngine._buildOFTMsgAndOptions()`.\n     * @dev !!!! IMPORTANT !!!! The differences are:\n     *      - memory instead of calldata for parameters.\n     *      - `_msgSender` is used instead of using context `msg.sender`, to preserve context of the OFT call and use `msg.sender` of the source chain.\n     *      - Does NOT combine options, make sure to pass valid options to cover gas costs/value transfers.\n     */\n\n    function _buildOFTMsgAndOptionsMemory(\n        SendParam memory _sendParam,\n        bytes memory _extraOptions,\n        bytes memory _composeMsg,\n        uint256 _amountToCreditLD,\n        address _msgSender\n    ) private view returns (bytes memory message, bytes memory options) {\n        bool hasCompose = _composeMsg.length > 0;\n\n        message = hasCompose\n            ? abi.encodePacked(\n                _sendParam.to, _toSD(_amountToCreditLD), OFTMsgCodec.addressToBytes32(_msgSender), _composeMsg\n            )\n            : abi.encodePacked(_sendParam.to, _toSD(_amountToCreditLD));\n        options = _extraOptions;\n\n        if (msgInspector != address(0)) {\n            IOAppMsgInspector(msgInspector).inspect(message, options);\n        }\n    }\n\n    /**\n     * @dev Performs a transfer with an allowance check and consumption against the xChain msg sender.\n     * @dev Can only transfer to this address.\n     *\n     * @param _owner The account to transfer from.\n     * @param srcChainSender The address of the sender on the source chain.\n     * @param _amount The amount to transfer\n     */\n    function _internalTransferWithAllowance(address _owner, address srcChainSender, uint256 _amount) internal {\n        if (_owner != srcChainSender) {\n            _spendAllowance(_owner, srcChainSender, _amount);\n        }\n\n        _transfer(_owner, address(this), _amount);\n    }\n}"
    },
    {
      "filename": "TapiocaZ/gitmodule/tapioca-periph/contracts/interfaces/periph/IMagnetar.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// Tapioca\nimport {IOptionsLockData} from \"../tap-token/ITapiocaOptionLiquidityProvision.sol\";\nimport {ICommonExternalContracts, IDepositData} from \"../common/ICommonData.sol\";\nimport {IOptionsParticipateData} from \"../tap-token/ITapiocaOptionBroker.sol\";\nimport {LZSendParam} from \"../periph/ITapiocaOmnichainEngine.sol\";\nimport {IRemoveAndRepay, IMintData} from \"../oft/IUsdo.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\nstruct MagnetarWithdrawData {\n    address yieldBox;\n    uint256 assetId;\n    bool unwrap;\n    //@dev LZv2 send params\n    LZSendParam lzSendParams;\n    uint128 sendGas;\n    uint128 composeGas;\n    uint128 sendVal;\n    uint128 composeVal;\n    bytes composeMsg;\n    uint16 composeMsgType;\n    //@dev actions data\n    bool withdraw;\n}\n\n/**\n * @dev MagnetarYieldBoxModule `depositAsset` calldata\n */\nstruct YieldBoxDepositData {\n    address yieldbox;\n    uint256 assetId;\n    address from;\n    address to;\n    uint256 amount;\n    uint256 share;\n}\n\n/**\n * @dev `exitPositionAndRemoveCollateral` calldata\n */\nstruct ExitPositionAndRemoveCollateralData {\n    address user;\n    ICommonExternalContracts externalData;\n    IRemoveAndRepay removeAndRepayData;\n}\n\n/**\n * @dev `depositRepayAndRemoveCollateralFromMarket` calldata\n */\nstruct DepositRepayAndRemoveCollateralFromMarketData {\n    address market;\n    address marketHelper;\n    address user;\n    uint256 depositAmount;\n    uint256 repayAmount;\n    uint256 collateralAmount;\n    MagnetarWithdrawData withdrawCollateralParams;\n}\n\n/**\n * @dev `depositAddCollateralAndBorrowFromMarket` calldata\n */\nstruct DepositAddCollateralAndBorrowFromMarketData {\n    address market;\n    address marketHelper;\n    address user;\n    uint256 collateralAmount;\n    uint256 borrowAmount;\n    bool deposit;\n    MagnetarWithdrawData withdrawParams;\n}\n\n/**\n * @dev `mintBBLendSGLLockTOLP` calldata\n */\nstruct MintFromBBAndLendOnSGLData {\n    address user;\n    uint256 lendAmount;\n    IMintData mintData;\n    IDepositData depositData;\n    IOptionsLockData lockData;\n    IOptionsParticipateData participateData;\n    ICommonExternalContracts externalContracts;\n}\n\n/**\n * @dev `crossChainMintFromBBAndLendOnSGL` calldata for step 1\n *  step 1: magnetar.mintBBLendXChainSGL (chain A) -->\n *         step 2: IUsdo compose call calls magnetar.depositLendAndSendForLocking (chain B) -->\n *              step 3: IToft(sglReceipt) compose call calls magnetar.lockAndParticipate (chain X)\n */\nstruct CrossChainMintFromBBAndLendOnSGLData {\n    address user;\n    address bigBang;\n    address magnetar;\n    address marketHelper;\n    IMintData mintData;\n    LendOrLockSendParams lendSendParams;\n}\n\n/**\n * @dev `crossChainMintFromBBAndLendOnSGL` calldata for step 2\n *  step 1: magnetar.mintBBLendXChainSGL (chain A) -->\n *         step 2: IUsdo compose call calls magnetar.depositLendAndSendForLocking (chain B) -->\n *              step 3: IToft(sglReceipt) compose call calls magnetar.lockAndParticipate (chain X)\n */\nstruct DepositAndSendForLockingData {\n    address user;\n    address singularity;\n    address magnetar;\n    uint256 assetId; // Singularity receipt token id\n    uint256 lendAmount;\n    IDepositData depositData;\n    LendOrLockSendParams lockAndParticipateSendParams;\n}\n\n/**\n * @dev `crossChainMintFromBBAndLendOnSGL` calldata for step 3\n *  step 1: magnetar.mintBBLendXChainSGL (chain A) -->\n *         step 2: IUsdo compose call calls magnetar.depositLendAndSendForLocking (chain B) -->\n *              step 3: IToft(sglReceipt) compose call calls magnetar.lockAndParticipate (chain X)\n */\nstruct LockAndParticipateData {\n    address user;\n    address singularity;\n    address magnetar;\n    uint256 fraction;\n    IOptionsLockData lockData;\n    IOptionsParticipateData participateData;\n}\n\nstruct LendOrLockSendParams {\n    LZSendParam lzParams;\n    uint128 lzSendGas;\n    uint128 lzSendVal;\n    uint128 lzComposeGas;\n    uint128 lzComposeVal;\n    uint16 lzComposeMsgType;\n}\n\nstruct MagnetarCall {\n    MagnetarAction id;\n    address target;\n    uint256 value;\n    bool allowFailure;\n    bytes call;\n}\n\nenum MagnetarAction {\n    Permit, // 0 Permit singular operations.\n    Wrap, // 1 Wrap/unwrap singular operations.\n    Market, // 2 Market singular operations.\n    TapToken, // 3 TapToken singular operations.\n    OFT, // 4 LZ OFT singular operations.\n    AssetModule, // 5  Usdo Singular operations.\n    AssetXChainModule, // 6  Usdo Singular operations.\n    CollateralModule, // 7 Collateral Singular related operations.\n    MintModule, // 8 BigBang Singular related operations.\n    MintXChainModule, // 9 BigBang Singular related operations.\n    OptionModule, // 10 Market Module related operations.\n    YieldBoxModule // 11 YieldBox module related operations.\n\n}\n\nenum MagnetarModule {\n    AssetModule,\n    AssetXChainModule,\n    CollateralModule,\n    MintModule,\n    MintXChainModule,\n    OptionModule,\n    YieldBoxModule\n}\n\n// TODO: fill\ninterface IMagnetar {\n    function burst(MagnetarCall[] calldata calls) external payable;\n\n    function cluster() external view returns (address);\n\n    function helper() external view returns (address);\n}\n\ninterface IMagnetarModuleExtender {\n    function isValidActionId(uint8 actionId) external view returns (bool);\n    function handleAction(MagnetarCall calldata call) external payable;\n}"
    },
    {
      "filename": "TapiocaZ/gitmodule/tapioca-periph/contracts/interfaces/oft/IUsdo.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// Tapioca\nimport {\n    ITapiocaOmnichainEngine,\n    YieldBoxApproveAssetMsg,\n    YieldBoxApproveAllMsg,\n    MarketPermitActionMsg,\n    ERC20PermitStruct,\n    LZSendParam\n} from \"../periph/ITapiocaOmnichainEngine.sol\";\nimport {\n    IOptionsParticipateData,\n    ITapiocaOptionBroker,\n    IExerciseOptionsData,\n    IOptionsExitData\n} from \"../tap-token/ITapiocaOptionBroker.sol\";\nimport {IOptionsUnlockData, IOptionsLockData} from \"../tap-token/ITapiocaOptionLiquidityProvision.sol\";\nimport {ICommonData, ICommonExternalContracts} from \"../common/ICommonData.sol\";\nimport {IPearlmit} from \"tapioca-periph/interfaces/periph/IPearlmit.sol\";\nimport {MagnetarWithdrawData} from \"../periph/IMagnetar.sol\";\nimport {IDepositData} from \"../common/ICommonData.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ninterface IUsdo is ITapiocaOmnichainEngine {\n    enum Module {\n        NonModule,\n        UsdoSender,\n        UsdoReceiver,\n        UsdoMarketReceiver,\n        UsdoOptionReceiver,\n        UsdoGenericReceiver\n    }\n\n    function mint(address _to, uint256 _amount) external;\n\n    function burn(address _from, uint256 _amount) external;\n\n    function setFlashloanHelper(address _helper) external;\n\n    function addFlashloanFee(uint256 _fee) external; //onlyOwner\n\n    function paused() external view returns (bool);\n}\n\n/// ============================\n/// ========= GENERIC ==========\n/// ============================\nstruct UsdoInitStruct {\n    address endpoint;\n    address delegate;\n    address yieldBox;\n    address cluster;\n    address extExec;\n    IPearlmit pearlmit;\n}\n\nstruct UsdoModulesInitStruct {\n    //modules\n    address usdoSenderModule;\n    address usdoReceiverModule;\n    address marketReceiverModule;\n    address optionReceiverModule;\n}\n\n/// ============================\n/// ========= COMPOSE ==========\n/// ============================\n/**\n * @notice Encodes the message for the PT_YB_SEND_SGL_LEND_OR_REPAY operation.\n */\nstruct MarketLendOrRepayMsg {\n    address user;\n    ILendOrRepayParams lendParams;\n    MagnetarWithdrawData withdrawParams;\n}\n\n/**\n * @notice Encodes the message for the PT_MARKET_REMOVE_ASSET operation.\n */\nstruct MarketRemoveAssetMsg {\n    address user;\n    ICommonExternalContracts externalData;\n    IRemoveAndRepay removeAndRepayData;\n}\n\n/**\n * @notice Encodes the message for the PT_TAP_EXERCISE operation.\n */\nstruct ExerciseOptionsMsg {\n    IExerciseOptionsData optionsData;\n    bool withdrawOnOtherChain;\n    //@dev send back to source message params\n    LZSendParam lzSendParams;\n    bytes composeMsg;\n}\n\nstruct IRemoveAndRepay {\n    bool removeAssetFromSGL;\n    uint256 removeAmount; //slightly greater than repayAmount to cover the interest\n    bool repayAssetOnBB;\n    uint256 repayAmount; // on BB\n    bool removeCollateralFromBB;\n    uint256 collateralAmount; // from BB\n    IOptionsExitData exitData;\n    IOptionsUnlockData unlockData;\n    MagnetarWithdrawData assetWithdrawData;\n    MagnetarWithdrawData collateralWithdrawData;\n}\n\n// lend or repay\nstruct ILendOrRepayParams {\n    bool repay;\n    uint256 depositAmount;\n    uint256 repayAmount;\n    address marketHelper;\n    address magnetar;\n    address market;\n    bool removeCollateral;\n    uint256 removeCollateralAmount;\n    IOptionsLockData lockData;\n    IOptionsParticipateData participateData;\n}\n\nstruct IMintData {\n    bool mint;\n    uint256 mintAmount;\n    IDepositData collateralDepositData;\n}"
    },
    {
      "filename": "TapiocaZ/gitmodule/tapioca-periph/contracts/interfaces/common/ICommonData.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\nstruct ICommonExternalContracts {\n    address magnetar;\n    address singularity;\n    address bigBang;\n    address marketHelper;\n}\n\nstruct IDepositData {\n    bool deposit;\n    uint256 amount;\n}\n\ninterface ICommonData {}"
    },
    {
      "filename": "TapiocaZ/contracts/tOFT/modules/TOFTOptionsReceiverModule.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// LZ\nimport {\n    MessagingReceipt, OFTReceipt, SendParam\n} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/interfaces/IOFT.sol\";\nimport {IOAppMsgInspector} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/interfaces/IOAppMsgInspector.sol\";\nimport {OFTMsgCodec} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/libs/OFTMsgCodec.sol\";\n\n// External\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n// Tapioca\nimport {\n    LockAndParticipateData,\n    IMagnetar,\n    MagnetarCall,\n    MagnetarAction,\n    CrossChainMintFromBBAndLendOnSGLData\n} from \"tapioca-periph/interfaces/periph/IMagnetar.sol\";\nimport {\n    ITapiocaOptionBroker, IExerciseOptionsData\n} from \"tapioca-periph/interfaces/tap-token/ITapiocaOptionBroker.sol\";\nimport {TOFTInitStruct, ExerciseOptionsMsg, LZSendParam} from \"tapioca-periph/interfaces/oft/ITOFT.sol\";\nimport {MagnetarMintXChainModule} from \"tapioca-periph/Magnetar/modules/MagnetarMintXChainModule.sol\";\nimport {TOFTMsgCodec} from \"contracts/tOFT/libraries/TOFTMsgCodec.sol\";\nimport {SafeApprove} from \"tapioca-periph/libraries/SafeApprove.sol\";\nimport {BaseTOFT} from \"contracts/tOFT/BaseTOFT.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title TOFTOptionsReceiverModule\n * @author TapiocaDAO\n * @notice TOFT Options module\n */\ncontract TOFTOptionsReceiverModule is BaseTOFT {\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n    using SafeApprove for address;\n\n    error TOFTOptionsReceiverModule_NotAuthorized(address invalidAddress);\n\n    event ExerciseOptionsReceived(\n        address indexed user, address indexed target, uint256 indexed oTapTokenId, uint256 paymentTokenAmount\n    );\n\n    constructor(TOFTInitStruct memory _data) BaseTOFT(_data) {}\n\n    /**\n     * @notice cross-chain receiver to deposit mint from BB, lend on SGL, lock on tOLP and participate on tOB\n     * @dev Cross chain flow:\n     *  step 1: magnetar.mintBBLendXChainSGL (chain A) -->\n     *         step 2: IUsdo compose call calls magnetar.depositYBLendSGLLockXchainTOLP (chain B) -->\n     *              step 3: IToft(sglReceipt) compose call calls magnetar.lockAndParticipate (chain X)\n     * @param _data.user the user to perform the operation for\n     * @param _data.bigBang the BB address\n     * @param _data.mintData the data needed to mint on BB\n     * @param _data.lendSendParams LZ send params for lending on another layer\n     */\n    function mintLendXChainSGLXChainLockAndParticipateReceiver(bytes memory _data) public payable {\n        // Decode received message.\n        CrossChainMintFromBBAndLendOnSGLData memory msg_ =\n            TOFTMsgCodec.decodeMintLendXChainSGLXChainLockAndParticipateMsg(_data);\n\n        _checkWhitelistStatus(msg_.bigBang);\n        _checkWhitelistStatus(msg_.magnetar);\n\n        if (msg_.mintData.mintAmount > 0) {\n            msg_.mintData.mintAmount = _toLD(msg_.mintData.mintAmount.toUint64());\n        }\n\n        bytes memory call = abi.encodeWithSelector(MagnetarMintXChainModule.mintBBLendXChainSGL.selector, msg_);\n        MagnetarCall[] memory magnetarCall = new MagnetarCall[](1);\n        magnetarCall[0] = MagnetarCall({\n            id: MagnetarAction.MintXChainModule,\n            target: address(this),\n            value: msg.value,\n            allowFailure: false,\n            call: call\n        });\n        IMagnetar(payable(msg_.magnetar)).burst{value: msg.value}(magnetarCall);\n    }\n\n    /**\n     * @notice Execute `magnetar.lockAndParticipate`\n     * @dev Lock on tOB and/or participate on tOLP\n     * @param _data The call data containing info about the operation.\n     * @param _data.user the user to perform the operation for\n     * @param _data.singularity the SGL address\n     * @param _data.fraction the amount to lock\n     * @param _data.lockData the data needed to lock on tOB\n     * @param _data.participateData the data needed to participate on tOLP\n     */\n    function lockAndParticipateReceiver(bytes memory _data) public payable {\n        // Decode receive message\n        LockAndParticipateData memory msg_ = TOFTMsgCodec.decodeLockAndParticipateMsg(_data);\n\n        _checkWhitelistStatus(msg_.magnetar);\n        _checkWhitelistStatus(msg_.singularity);\n        if (msg_.lockData.lock) {\n            _checkWhitelistStatus(msg_.lockData.target);\n        }\n        if (msg_.participateData.participate) {\n            _checkWhitelistStatus(msg_.participateData.target);\n        }\n\n        if (msg_.fraction > 0) {\n            msg_.fraction = _toLD(msg_.fraction.toUint64());\n        }\n\n        bytes memory call = abi.encodeWithSelector(MagnetarMintXChainModule.lockAndParticipate.selector, msg_);\n        MagnetarCall[] memory magnetarCall = new MagnetarCall[](1);\n        magnetarCall[0] = MagnetarCall({\n            id: MagnetarAction.MintXChainModule,\n            target: msg_.magnetar,\n            value: msg.value,\n            allowFailure: false,\n            call: call\n        });\n        IMagnetar(payable(msg_.magnetar)).burst{value: msg.value}(magnetarCall);\n    }\n\n    /**\n     * @notice Exercise tOB option\n     * @param _data The call data containing info about the operation.\n     *      - optionsData::address: TapiocaOptionsBroker exercise params.\n     *      - lzSendParams::struct: LZ v2 send to source params.\n     *      - composeMsg::bytes: Further compose data.\n     */\n    function exerciseOptionsReceiver(address srcChainSender, bytes memory _data) public payable {\n        // Decode received message.\n        ExerciseOptionsMsg memory msg_ = TOFTMsgCodec.decodeExerciseOptionsMsg(_data);\n\n        _checkWhitelistStatus(msg_.optionsData.target);\n        _checkWhitelistStatus(OFTMsgCodec.bytes32ToAddress(msg_.lzSendParams.sendParam.to));\n\n        {\n            // _data declared for visibility.\n            IExerciseOptionsData memory _options = msg_.optionsData;\n            _options.tapAmount = _toLD(_options.tapAmount.toUint64());\n            _options.paymentTokenAmount = _toLD(_options.paymentTokenAmount.toUint64());\n\n            // @dev retrieve paymentToken amount\n            _internalTransferWithAllowance(_options.from, srcChainSender, _options.paymentTokenAmount);\n\n            /// Does this: _approve(address(this), _options.target, _options.paymentTokenAmount);\n            pearlmit.approve(\n                address(this), 0, _options.target, uint200(_options.paymentTokenAmount), uint48(block.timestamp + 1)\n            ); // Atomic approval\n            address(this).safeApprove(address(pearlmit), _options.paymentTokenAmount);\n\n            /// @dev call exerciseOption() with address(this) as the payment token\n            uint256 bBefore = balanceOf(address(this));\n            ITapiocaOptionBroker(_options.target).exerciseOption(\n                _options.oTAPTokenID,\n                address(this), //payment token\n                _options.tapAmount\n            );\n            address(this).safeApprove(address(pearlmit), 0); // Clear approval\n            uint256 bAfter = balanceOf(address(this));\n\n            // Refund if less was used.\n            if (bBefore > bAfter) {\n                uint256 diff = bBefore - bAfter;\n                if (diff < _options.paymentTokenAmount) {\n                    IERC20(address(this)).safeTransfer(_options.from, _options.paymentTokenAmount - diff);\n                }\n            }\n        }\n\n        {\n            // _data declared for visibility.\n            IExerciseOptionsData memory _options = msg_.optionsData;\n            SendParam memory _send = msg_.lzSendParams.sendParam;\n\n            address tapOft = ITapiocaOptionBroker(_options.target).tapOFT();\n            if (msg_.withdrawOnOtherChain) {\n                /// @dev determine the right amount to send back to source\n                uint256 amountToSend = _send.amountLD > _options.tapAmount ? _options.tapAmount : _send.amountLD;\n                if (_send.minAmountLD > amountToSend) {\n                    _send.minAmountLD = amountToSend;\n                }\n\n                // Sends to source and preserve source `msg.sender` (`from` in this case).\n                _sendPacket(msg_.lzSendParams, msg_.composeMsg, _options.from);\n\n                // Refund extra amounts\n                if (_options.tapAmount - amountToSend > 0) {\n                    IERC20(tapOft).safeTransfer(_options.from, _options.tapAmount - amountToSend);\n                }\n            } else {\n                //send on this chain\n                IERC20(tapOft).safeTransfer(_options.from, _options.tapAmount);\n            }\n        }\n    }\n\n    function _checkWhitelistStatus(address _addr) private view {\n        if (_addr != address(0)) {\n            if (!cluster.isWhitelisted(0, _addr)) {\n                revert TOFTOptionsReceiverModule_NotAuthorized(_addr);\n            }\n        }\n    }\n\n    function _sendPacket(LZSendParam memory _lzSendParam, bytes memory _composeMsg, address _srcChainSender)\n        private\n        returns (MessagingReceipt memory msgReceipt, OFTReceipt memory oftReceipt)\n    {\n        /// @dev Applies the token transfers regarding this send() operation.\n        // - amountDebitedLD is the amount in local decimals that was ACTUALLY debited from the sender.\n        // - amountToCreditLD is the amount in local decimals that will be credited to the recipient on the remote OFT instance.\n        (uint256 amountDebitedLD, uint256 amountToCreditLD) ="
    }
  ]
}