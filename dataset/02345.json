{
  "Title": "M-6: Attackers may skip the collateral ratio recovery duration to inflate collateralization ratios and steal funds",
  "Content": "# Issue M-6: Attackers may skip the collateral ratio recovery duration to inflate collateralization ratios and steal funds \n\nSource: https://github.com/sherlock-audit/2023-02-surge-judging/issues/130 \n\n## Found by \nusmannk\n## Summary\n\nUnder certain market conditions, attackers can bypass the collateralization ratio update system to instantly send the collateralization ratio from zero to maximum.\n\nThe collateralization ratio in Surge defines the amount of loan token that can be borrowed per wei of collateral token. In this way it acts as both a collateralization ratio as in other lending markets but also as an exchange rate, as the ratio is taken directly between the two tokens instead of through an intermediary such as dollars.\n\nA Surge pool linearly decreaes the collateralization ratio to zero when it is in \"Surge mode\", in order to reduce demand. When the pool is not in \"Surge mode\", it increases the collateralization ratio similarly up to the preset maximum. However, an attacker can use a quirk in the way the utilization is calculated to instantly send a pool from zero to the maximum, greatly manipulating the exchange rate.\n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2023-02-surge/blob/main/surge-protocol-v1/src/Pool.sol#L216-L263\n\nThe collateralization ratio is calculated as either \n\n`_lastCollateralRatioMantissa + timeDelta * _maxCollateralRatioMantissa / _collateralRatioRecoveryDuration`\nor \n`_lastCollateralRatioMantissa - timeDelta * _maxCollateralRatioMantissa / _collateralRatioFallDuration `\n\nDepending on whether the contract is not, or is, in Surge mode (respectively).\n\nConsider a pool that has been in a state that is just under Surge mode for a long time. That is `_util <= _surgeMantissa` but the two values are very close together. There have not been any interactions with the pool in a while so `timeDelta` is large. This means that the next interaction with the pool will use a collateralization ratio of 0.\n\nAn attacker can bypass this by gifting a small amount of the loan token to the contract. This will cause the utilization (`_util`) to go up on the next calculation.\n\nNow even though the contract has not been in surge mode, on the next interaction it will think that it has been and the large `timeDelta` will be applied to a collateralization ratio increase instead of a collateralization ratio decrease.\n\nThe attacker can take advantage of the maximum collateralization ratio to borrow funds at an inflated valuation, stealing assets from the pool because they were able to skip the `_collateralRatioRecoveryDuration`.\n\n## Impact\n\nLoss of funds from pool depositors.\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nWhen calculating utilization, only use the most recently cached values of token balances instead of using live values.\n\n\n\n## Discussion\n\n**xeious**\n\nFixed\n\n**xeious**\n\nhttps://github.com/Surge-fi/surge-protocol-v1/commit/95fa486d7356482e3e8b6d8c43d93a5cf482be1b\n\n**IAm0x52**\n\nFix looks good. Loan token balance is now cached as lastLoanTokenBalance instead of using balanceOf. This value is cached at the end of all state changing functions\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/51",
  "Code": [
    {
      "filename": "surge-protocol-v1/src/Pool.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\ninterface IERC20 {\n    function balanceOf(address) external view returns(uint);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns(bool);\n    function transfer(address, uint) external returns (bool);\n    function decimals() external view returns (uint8);\n}\n\ninterface IFactory {\n    function getFee() external view returns (address to, uint feeMantissa);\n}\n\n/// @title Pool\n/// @author Moaz Mohsen & Nour Haridy\n/// @notice A Surge lending pool for a single collateral and loan token pair\n/// @dev This contract asssumes that the collateral and loan tokens are valid non-rebasing ERC20-compliant tokens\ncontract Pool {\n\n    IFactory public immutable FACTORY;\n    IERC20 public immutable COLLATERAL_TOKEN;\n    IERC20 public immutable LOAN_TOKEN;\n    string public symbol;\n    string public name;\n    uint8 public constant decimals = 18;\n    uint private constant RATE_CEILING = 100e18; // 10,000% borrow APR\n    uint public immutable MIN_RATE;\n    uint public immutable SURGE_RATE;\n    uint public immutable MAX_RATE;\n    uint public immutable MAX_COLLATERAL_RATIO_MANTISSA;\n    uint public immutable SURGE_MANTISSA;\n    uint public immutable COLLATERAL_RATIO_FALL_DURATION;\n    uint public immutable COLLATERAL_RATIO_RECOVERY_DURATION;\n    bytes4 private constant TRANSFER_SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\n    bytes4 private constant TRANSFER_FROM_SELECTOR = bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n    uint public lastCollateralRatioMantissa;\n    uint public debtSharesSupply;\n    mapping (address => uint) public debtSharesBalanceOf;\n    uint public lastTotalDebt;\n    uint public lastAccrueInterestTime;\n    uint public totalSupply;\n    mapping (address => mapping (address => uint)) public allowance;\n    mapping (address => uint) public balanceOf;\n    mapping (address => uint) public collateralBalanceOf;\n\n    constructor(\n        string memory _symbol,\n        string memory _name,\n        IERC20 _collateralToken,\n        IERC20 _loanToken,\n        uint _maxCollateralRatioMantissa,\n        uint _surgeMantissa,\n        uint _collateralRatioFallDuration,\n        uint _collateralRatioRecoveryDuration,\n        uint _minRateMantissa,\n        uint _surgeRateMantissa,\n        uint _maxRateMantissa\n    ) {\n        require(_collateralToken != _loanToken, \"Pool: collateral and loan tokens are the same\");\n        require(_collateralRatioFallDuration > 0, \"Pool: _collateralRatioFallDuration too low\");\n        require(_collateralRatioRecoveryDuration > 0, \"Pool: _collateralRatioRecoveryDuration too low\");\n        require(_maxCollateralRatioMantissa > 0, \"Pool: _maxCollateralRatioMantissa too low\");\n        require(_surgeMantissa < 1e18, \"Pool: _surgeMantissa too high\");\n        require(_minRateMantissa <= _surgeRateMantissa, \"Pool: _minRateMantissa too high\");\n        require(_surgeRateMantissa <= _maxRateMantissa, \"Pool: _surgeRateMantissa too high\");\n        require(_maxRateMantissa <= RATE_CEILING, \"Pool: _maxRateMantissa too high\");\n        symbol = _symbol;\n        name = _name;\n        FACTORY = IFactory(msg.sender);\n        COLLATERAL_TOKEN = _collateralToken;\n        LOAN_TOKEN = _loanToken;\n        MAX_COLLATERAL_RATIO_MANTISSA = _maxCollateralRatioMantissa;\n        SURGE_MANTISSA = _surgeMantissa;\n        COLLATERAL_RATIO_FALL_DURATION = _collateralRatioFallDuration;\n        COLLATERAL_RATIO_RECOVERY_DURATION = _collateralRatioRecoveryDuration;\n        lastCollateralRatioMantissa = _maxCollateralRatioMantissa;\n        MIN_RATE = _minRateMantissa;\n        SURGE_RATE = _surgeRateMantissa;\n        MAX_RATE = _maxRateMantissa;\n    }\n\n    function safeTransfer(IERC20 token, address to, uint value) internal {\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(TRANSFER_SELECTOR, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'Pool: TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint value) internal {\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(TRANSFER_FROM_SELECTOR, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'Pool: TRANSFER_FROM_FAILED');\n    }\n\n    /// @notice Gets the current state of pool variables based on the current time\n    /// @param _loanTokenBalance The current balance of the loan token in the pool\n    /// @param _feeMantissa The fee to be charged on interest accrual\n    /// @param _lastCollateralRatioMantissa The collateral ratio at the last interest accrual\n    /// @param _totalSupply The total supply of pool tokens at the last interest accrual\n    /// @param _lastAccrueInterestTime The last time interest was accrued\n    /// @param _totalDebt The total debt of the pool at the last interest accrual\n    /// @return _currentTotalSupply The current total supply of pool tokens\n    /// @return _accruedFeeShares The accrued fee shares to be transferred to the fee recipient\n    /// @return _currentCollateralRatioMantissa The current collateral ratio\n    /// @return _currentTotalDebt The current total debt of the pool\n    /// @dev This view function behaves as a pure function with the exception of immutable variables (which are constant)\n    function getCurrentState(\n        uint _loanTokenBalance,\n        uint _feeMantissa,\n        uint _lastCollateralRatioMantissa,\n        uint _totalSupply,\n        uint _lastAccrueInterestTime,\n        uint _totalDebt\n        ) internal view returns (\n            uint _currentTotalSupply,\n            uint _accruedFeeShares,\n            uint _currentCollateralRatioMantissa,\n            uint _currentTotalDebt\n        ) {\n        \n        // 1. Set default return values\n        _currentTotalSupply = _totalSupply;\n        _currentTotalDebt = _totalDebt;\n        _currentCollateralRatioMantissa = _lastCollateralRatioMantissa;\n        // _accruedFeeShares = 0;\n\n        // 2. Get the time passed since the last interest accrual\n        uint _timeDelta = block.timestamp - _lastAccrueInterestTime;\n        \n        // 3. If the time passed is 0, return the current values\n        if(_timeDelta == 0) return (_currentTotalSupply, _accruedFeeShares, _currentCollateralRatioMantissa, _currentTotalDebt);\n        \n        // 4. Calculate the supplied value\n        uint _supplied = _totalDebt + _loanTokenBalance;\n        // 5. Calculate the utilization\n        uint _util = getUtilizationMantissa(_totalDebt, _supplied);\n\n        // 6. Calculate the collateral ratio\n        _currentCollateralRatioMantissa = getCollateralRatioMantissa(\n            _util,\n            _lastAccrueInterestTime,\n            block.timestamp,\n            _lastCollateralRatioMantissa,\n            COLLATERAL_RATIO_FALL_DURATION,\n            COLLATERAL_RATIO_RECOVERY_DURATION,\n            MAX_COLLATERAL_RATIO_MANTISSA,\n            SURGE_MANTISSA\n        );\n\n        // 7. If there is no debt, return the current values\n        if(_totalDebt == 0) return (_currentTotalSupply, _accruedFeeShares, _currentCollateralRatioMantissa, _currentTotalDebt);\n\n        // 8. Calculate the borrow rate\n        uint _borrowRate = getBorrowRateMantissa(_util, SURGE_MANTISSA, MIN_RATE, SURGE_RATE, MAX_RATE);\n        // 9. Calculate the interest\n        uint _interest = _totalDebt * _borrowRate * _timeDelta / (365 days * 1e18); // does the optimizer optimize this? or should it be a constant?\n        // 10. Update the total debt\n        _currentTotalDebt += _interest;\n        \n        // 11. If there is no fee, return the current values\n        if(_feeMantissa == 0) return (_currentTotalSupply, _accruedFeeShares, _currentCollateralRatioMantissa, _currentTotalDebt);\n        // 12. Calculate the fee\n        uint fee = _interest * _feeMantissa / 1e18;\n        // 13. Calculate the accrued fee shares\n        _accruedFeeShares = fee * _totalSupply / _supplied; // if supplied is 0, we will have returned at step 7\n        // 14. Update the total supply\n        _currentTotalSupply += _accruedFeeShares;\n    }\n\n    /// @notice Gets the current borrow rate in mantissa (scaled by 1e18)\n    /// @param _util The utilization in mantissa (scaled by 1e18)\n    /// @param _surgeMantissa The utilization at which the borrow rate will be at the surge rate in mantissa (scaled by 1e18)\n    /// @param _minRateMantissa The minimum borrow rate at 0% utilization in mantissa (scaled by 1e18)\n    /// @param _surgeRateMantissa The borrow rate at the surge utilization in mantissa (scaled by 1e18)\n    /// @param _maxRateMantissa The maximum borrow rate at 100% utilization in mantissa (scaled by 1e18)\n    /// @return uint The borrow rate in mantissa (scaled by 1e18)\n    function getBorrowRateMantissa(uint _util, uint _surgeMantissa, uint _minRateMantissa, uint _surgeRateMantissa, uint _maxRateMantissa) internal pure returns (uint) {\n        if(_util <= _surgeMantissa) {\n            return (_surgeRateMantissa - _minRateMantissa) * 1e18 * _util / _surgeMantissa / 1e18 + _minRateMantissa; // is this optimized by the optimized?\n        } else {\n            uint excessUtil = _util - _surgeMantissa;\n            return (_maxRateMantissa - _surgeRateMantissa) * 1e18 * excessUtil / (1e18 - _surgeMantissa) / 1e18 + _surgeRateMantissa; // is this optimized by the optimizer?\n        }\n    }\n\n    /// @notice Gets the current pool utilization rate in mantissa (scaled by 1e18)\n    /// @param _totalDebt The total debt of the pool\n    /// @param _supplied The total supplied loan tokens of the pool\n    /// @return uint The pool utilization rate in mantissa (scaled by 1e18)\n    function getUtilizationMantissa(uint _totalDebt, uint _supplied) internal pure returns (uint) {\n        if(_supplied == 0) return 0;\n        return _totalDebt * 1e18 / _supplied;\n    }\n\n    /// @notice Converts a loan token amount to shares\n    /// @param _tokenAmount The loan token amount to convert\n    /// @param _supplied The total supplied loan tokens of the pool\n    /// @param _sharesTotalSupply The total supply of shares of the pool\n    /// @param roundUpCheck Whether to check and round up the shares amount\n    /// @return uint The shares amount\n    function tokenToShares (uint _tokenAmount, uint _supplied, uint _sharesTotalSupply, bool roundUpCheck) internal pure returns (uint) {\n        if(_supplied == 0) return _tokenAmount;\n        uint shares = _tokenAmount * _sharesTotalSupply / _supplied;\n        if(roundUpCheck && shares * _supplied < _tokenAmount * _sharesTotalSupply) shares++;\n        return shares;\n    }\n\n    /// @notice Gets the pool collateral ratio in mantissa (scaled by 1e18)\n    /// @param _util The utilization in mantissa (scaled by 1e18)\n    /// @param _lastAccrueInterestTime The last time the pool accrued interest\n    /// @param _now The current time\n    /// @param _lastCollateralRatioMantissa The last collateral ratio of the pool in mantissa (scaled by 1e18)\n    /// @param _collateralRatioFallDuration The duration of the collateral ratio fall from max to 0 in seconds\n    /// @param _collateralRatioRecoveryDuration The duration of the collateral ratio recovery from 0 to max in seconds\n    /// @param _maxCollateralRatioMantissa The maximum collateral ratio of the pool in mantissa (scaled by 1e18)\n    /// @param _surgeMantissa The utilization at which the surge threshold is triggered in mantissa (scaled by 1e18)\n    /// @return uint The pool collateral ratio in mantissa (scaled by 1e18)\n    function getCollateralRatioMantissa(\n        uint _util,\n        uint _lastAccrueInterestTime,\n        uint _now,\n        uint _lastCollateralRatioMantissa,\n        uint _collateralRatioFallDuration,\n        uint _collateralRatioRecoveryDuration,\n        uint _maxCollateralRatioMantissa,\n        uint _surgeMantissa\n        ) internal pure returns (uint) {\n        unchecked {\n            if(_lastAccrueInterestTime == _now) return _lastCollateralRatioMantissa;\n            \n            // If utilization is less than or equal to surge, we are increasing collateral ratio\n            if(_util <= _surgeMantissa) {\n                // The collateral ratio can only increase if it is less than the max collateral ratio\n                if(_lastCollateralRatioMantissa == _maxCollateralRatioMantissa) return _lastCollateralRatioMantissa;\n\n                // If the collateral ratio can increase, we calculate the increase\n                uint timeDelta = _now - _lastAccrueInterestTime;\n                uint change = timeDelta * _maxCollateralRatioMantissa / _collateralRatioRecoveryDuration;\n\n                // If the change in collateral ratio is greater than the max collateral ratio, we set the collateral ratio to the max collateral ratio\n                if(_lastCollateralRatioMantissa + change >= _maxCollateralRatioMantissa) {\n                    return _maxCollateralRatioMantissa;\n                } else {\n                    // Otherwise we increase the collateral ratio by the change\n                    return _lastCollateralRatioMantissa + change;\n                }\n            } else {\n                // If utilization is greater than the surge, we are decreasing collateral ratio\n                // The collateral ratio can only decrease if it is greater than 0\n                if(_lastCollateralRatioMantissa == 0) return 0;\n\n                // If the collateral ratio can decrease, we calculate the decrease\n                uint timeDelta = _now - _lastAccrueInterestTime;\n                uint change = timeDelta * _maxCollateralRatioMantissa / _collateralRatioFallDuration;\n\n                // If the change in collateral ratio is greater than the collateral ratio, we set the collateral ratio to 0\n                if(_lastCollateralRatioMantissa <= change) {\n                    return 0;\n                } else {\n                    // Otherwise we decrease the collateral ratio by the change\n                    return _lastCollateralRatioMantissa - change;\n                }\n            }\n        }\n    }\n\n    /// @notice Transfers pool tokens to the recipient\n    /// @param to The address of the recipient\n    /// @param amount The amount of pool tokens to transfer\n    /// @return bool that indicates if the operation was successful\n    function transfer(address to, uint amount) external returns (bool) {\n        require(to != address(0), \"Pool: to cannot be address 0\");\n        balanceOf[msg.sender] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    /// @notice Transfers pool tokens on behalf of one address to another\n    /// @param from The address of the sender\n    /// @param to The address of the recipient\n    /// @param amount The amount of pool tokens to transfer\n    /// @return bool that indicates if the operation was successful\n    function transferFrom(address from, address to, uint amount) external returns (bool) {\n        require(to != address(0), \"Pool: to cannot be address 0\");\n        allowance[from][msg.sender] -= amount;\n        balanceOf[from] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n        return true;\n    }\n\n    /// @notice Approves an address to spend pool tokens on behalf of the sender\n    /// @param spender The address of the spender\n    /// @param amount The amount of pool tokens to approve\n    /// @return bool that indicates if the operation was successful\n    function approve(address spender, uint amount) external returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    /// @notice Deposit loan tokens in exchange for pool tokens\n    /// @param amount The amount of loan tokens to deposit\n    function deposit(uint amount) external {\n        uint _loanTokenBalance = LOAN_TOKEN.balanceOf(address(this));\n        (address _feeRecipient, uint _feeMantissa) = FACTORY.getFee();\n        (  \n            uint _currentTotalSupply,\n            uint _accruedFeeShares,\n            uint _currentCollateralRatioMantissa,\n            uint _currentTotalDebt\n        ) = getCurrentState(\n            _loanTokenBalance,\n            _feeMantissa,\n            lastCollateralRatioMantissa,\n            totalSupply,\n            lastAccrueInterestTime,\n            lastTotalDebt\n        );\n\n        uint _shares = tokenToShares(amount, (_currentTotalDebt + _loanTokenBalance), _currentTotalSupply, false);\n        require(_shares > 0, \"Pool: 0 shares\");\n        _currentTotalSupply += _shares;\n\n        // commit current state\n        balanceOf[msg.sender] += _shares;\n        totalSupply = _currentTotalSupply;\n        lastTotalDebt = _currentTotalDebt;\n        lastAccrueInterestTime = block.timestamp;\n        lastCollateralRatioMantissa = _currentCollateralRatioMantissa;\n        emit Invest(msg.sender, amount);\n        emit Transfer(address(0), msg.sender, _shares);\n        if(_accruedFeeShares > 0) {\n            balanceOf[_feeRecipient] += _accruedFeeShares;\n            emit Transfer(address(0), _feeRecipient, _accruedFeeShares);\n        }\n\n        // interactions\n        safeTransferFrom(LOAN_TOKEN, msg.sender, address(this), amount);\n    }\n\n    /// @notice Withdraw loan tokens in exchange for pool tokens\n    /// @param amount The amount of loan tokens to withdraw\n    /// @dev If amount is type(uint).max, withdraws all loan tokens\n    function withdraw(uint amount) external {\n        uint _loanTokenBalance = LOAN_TOKEN.balanceOf(address(this));\n        (address _feeRecipient, uint _feeMantissa) = FACTORY.getFee();\n        (  \n            uint _currentTotalSupply,\n            uint _accruedFeeShares,\n            uint _currentCollateralRatioMantissa,\n            uint _currentTotalDebt\n        ) = getCurrentState(\n            _loanTokenBalance,\n            _feeMantissa,\n            lastCollateralRatioMantissa,\n            totalSupply,\n            lastAccrueInterestTime,\n            lastTotalDebt\n        );\n\n        uint _shares;\n        if (amount == type(uint).max) {\n            amount = balanceOf[msg.sender] * (_currentTotalDebt + _loanTokenBalance) / _currentTotalSupply;\n            _shares = balanceOf[msg.sender];\n        } else {\n            _shares = tokenToShares(amount, (_currentTotalDebt + _loanTokenBalance), _currentTotalSupply, true);\n        }\n        _currentTotalSupply -= _shares;\n\n        // commit current state\n        balanceOf[msg.sender] -= _shares;\n        totalSupply = _currentTotalSupply;\n        lastTotalDebt = _currentTotalDebt;\n        lastAccrueInterestTime = block.timestamp;\n        lastCollateralRatioMantissa = _currentCollateralRatioMantissa;\n        emit Divest(msg.sender, amount);\n        emit Transfer(msg.sender, address(0), _shares);\n        if(_accruedFeeShares > 0) {\n            balanceOf[_feeRecipient] += _accruedFeeShares;\n            emit Transfer(address(0), _feeRecipient, _accruedFeeShares);\n        }\n\n        // interactions\n        safeTransfer(LOAN_TOKEN, msg.sender, amount);\n    }\n\n    /// @notice Deposit collateral tokens\n    /// @param to The address to receive the collateral deposit\n    /// @param amount The amount of collateral tokens to deposit\n    function addCollateral(address to, uint amount) external {\n        collateralBalanceOf[to] += amount;\n        safeTransferFrom(COLLATERAL_TOKEN, msg.sender, address(this), amount);\n        emit Secure(to, msg.sender, amount);\n    }\n\n    /// @notice Gets the debt of a user\n    /// @param _userDebtShares The amount of debt shares of the user\n    /// @param _debtSharesSupply The total amount of debt shares\n    /// @param _totalDebt The total amount of debt\n    /// @return uint The debt of the user\n    function getDebtOf(uint _userDebtShares, uint _debtSharesSupply, uint _totalDebt) internal pure returns (uint) {\n        if (_debtSharesSupply == 0) return 0;\n        uint debt = _userDebtShares * _totalDebt / _debtSharesSupply;\n        if(debt * _debtSharesSupply < _userDebtShares * _totalDebt) debt++;\n        return debt;\n    }\n    \n    /// @notice Withdraw collateral tokens\n    /// @param amount The amount of collateral tokens to withdraw\n    function removeCollateral(uint amount) external {\n        uint _loanTokenBalance = LOAN_TOKEN.balanceOf(address(this));\n        (address _feeRecipient, uint _feeMantissa) = FACTORY.getFee();\n        (  \n            uint _currentTotalSupply,\n            uint _accruedFeeShares,\n            uint _currentCollateralRatioMantissa,\n            uint _currentTotalDebt\n        ) = getCurrentState(\n            _loanTokenBalance,\n            _feeMantissa,\n            lastCollateralRatioMantissa,\n            totalSupply,\n            lastAccrueInterestTime,\n            lastTotalDebt\n        );\n\n        uint userDebt = getDebtOf(debtSharesBalanceOf[msg.sender], debtSharesSupply, _currentTotalDebt);\n        if(userDebt > 0) {\n            uint userCollateralRatioMantissa = userDebt * 1e18 / (collateralBalanceOf[msg.sender] - amount);\n            require(userCollateralRatioMantissa <= _currentCollateralRatioMantissa, \"Pool: user collateral ratio too high\");\n        }\n\n        // commit current state\n        totalSupply = _currentTotalSupply;\n        lastTotalDebt = _currentTotalDebt;\n        lastAccrueInterestTime = block.timestamp;\n        lastCollateralRatioMantissa = _currentCollateralRatioMantissa;\n        collateralBalanceOf[msg.sender] -= amount;\n        emit Unsecure(msg.sender, amount);\n        if(_accruedFeeShares > 0) {\n            balanceOf[_feeRecipient] += _accruedFeeShares;\n            emit Transfer(address(0), _feeRecipient, _accruedFeeShares);\n        }\n\n        // interactions\n        safeTransfer(COLLATERAL_TOKEN, msg.sender, amount);\n    }\n\n    /// @notice Borrow loan tokens\n    /// @param amount The amount of loan tokens to borrow\n    function borrow(uint amount) external {\n        uint _loanTokenBalance = LOAN_TOKEN.balanceOf(address(this));\n        (address _feeRecipient, uint _feeMantissa) = FACTORY.getFee();\n        (  \n            uint _currentTotalSupply,\n            uint _accruedFeeShares,\n            uint _currentCollateralRatioMantissa,\n            uint _currentTotalDebt\n        ) = getCurrentState(\n            _loanTokenBalance,\n            _feeMantissa,\n            lastCollateralRatioMantissa,\n            totalSupply,\n            lastAccrueInterestTime,\n            lastTotalDebt\n        );\n\n        uint _debtSharesSupply = debtSharesSupply;\n        uint userDebt = getDebtOf(debtSharesBalanceOf[msg.sender], _debtSharesSupply, _currentTotalDebt) + amount;\n        uint userCollateralRatioMantissa = userDebt * 1e18 / collateralBalanceOf[msg.sender];\n        require(userCollateralRatioMantissa <= _currentCollateralRatioMantissa, \"Pool: user collateral ratio too high\");\n\n        uint _newUtil = getUtilizationMantissa(_currentTotalDebt + amount, (_currentTotalDebt + _loanTokenBalance));\n        require(_newUtil <= SURGE_MANTISSA, \"Pool: utilization too high\");\n\n        uint _shares = tokenToShares(amount, _currentTotalDebt, _debtSharesSupply, true);\n        _currentTotalDebt += amount;\n\n        // commit current state\n        debtSharesBalanceOf[msg.sender] += _shares;\n        debtSharesSupply = _debtSharesSupply + _shares;\n        totalSupply = _currentTotalSupply;\n        lastTotalDebt = _currentTotalDebt;\n        lastAccrueInterestTime = block.timestamp;\n        lastCollateralRatioMantissa = _currentCollateralRatioMantissa;\n        emit Borrow(msg.sender, amount);\n        if(_accruedFeeShares > 0) {\n            balanceOf[_feeRecipient] += _accruedFeeShares;\n            emit Transfer(address(0), _feeRecipient, _accruedFeeShares);\n        }\n\n        // interactions\n        safeTransfer(LOAN_TOKEN, msg.sender, amount);\n    }\n\n    /// @notice Repay loan tokens debt\n    /// @param borrower The address of the borrower to repay on their behalf\n    /// @param amount The amount of loan tokens to repay\n    /// @dev If amount is max uint, all debt will be repaid\n    function repay(address borrower, uint amount) external {\n        uint _loanTokenBalance = LOAN_TOKEN.balanceOf(address(this));\n        (address _feeRecipient, uint _feeMantissa) = FACTORY.getFee();\n        (  \n            uint _currentTotalSupply,\n            uint _accruedFeeShares,\n            uint _currentCollateralRatioMantissa,\n            uint _currentTotalDebt\n        ) = getCurrentState(\n            _loanTokenBalance,\n            _feeMantissa,\n            lastCollateralRatioMantissa,\n            totalSupply,\n            lastAccrueInterestTime,\n            lastTotalDebt\n        );\n\n        uint _debtSharesSupply = debtSharesSupply;\n\n        uint _shares;\n        if(amount == type(uint).max) {\n            amount = getDebtOf(debtSharesBalanceOf[borrower], _debtSharesSupply, _currentTotalDebt);\n            _shares = debtSharesBalanceOf[borrower];\n        } else {\n            _shares = tokenToShares(amount, _currentTotalDebt, _debtSharesSupply, false);\n        }\n        _currentTotalDebt -= amount;\n\n        // commit current state\n        debtSharesBalanceOf[borrower] -= _shares;\n        debtSharesSupply = _debtSharesSupply - _shares;\n        totalSupply = _currentTotalSupply;\n        lastTotalDebt = _currentTotalDebt;\n        lastAccrueInterestTime = block.timestamp;\n        lastCollateralRatioMantissa = _currentCollateralRatioMantissa;\n        emit Repay(borrower, msg.sender, amount);\n        if(_accruedFeeShares > 0) {\n            balanceOf[_feeRecipient] += _accruedFeeShares;\n            emit Transfer(address(0), _feeRecipient, _accruedFeeShares);\n        }\n\n        // interactions\n        safeTransferFrom(LOAN_TOKEN, msg.sender, address(this), amount);\n    }\n\n    /// @notice Seize collateral from an underwater borrower in exchange for repaying their debt\n    /// @param borrower The address of the borrower to liquidate\n    /// @param amount The amount of debt to repay\n    /// @dev If amount is max uint, all debt will be liquidated\n    function liquidate(address borrower, uint amount) external {\n        uint _loanTokenBalance = LOAN_TOKEN.balanceOf(address(this));\n        (address _feeRecipient, uint _feeMantissa) = FACTORY.getFee();\n        (  \n            uint _currentTotalSupply,\n            uint _accruedFeeShares,\n            uint _currentCollateralRatioMantissa,\n            uint _currentTotalDebt\n        ) = getCurrentState(\n            _loanTokenBalance,\n            _feeMantissa,\n            lastCollateralRatioMantissa,\n            totalSupply,\n            lastAccrueInterestTime,\n            lastTotalDebt\n        );\n\n        uint collateralBalance = collateralBalanceOf[borrower];\n        uint _debtSharesSupply = debtSharesSupply;\n        uint userDebt = getDebtOf(debtSharesBalanceOf[borrower], _debtSharesSupply, _currentTotalDebt);\n        uint userCollateralRatioMantissa = userDebt * 1e18 / collateralBalance;\n        require(userCollateralRatioMantissa > _currentCollateralRatioMantissa, \"Pool: borrower not liquidatable\");\n\n        address _borrower = borrower; // avoid stack too deep\n        uint _amount = amount; // avoid stack too deep\n        uint _shares;\n        uint collateralReward;\n        if(_amount == type(uint).max || _amount == userDebt) {\n            collateralReward = collateralBalance;\n            _shares = debtSharesBalanceOf[_borrower];\n            _amount = userDebt;\n        } else {\n            uint userInvertedCollateralRatioMantissa = collateralBalance * 1e18 / userDebt;\n            collateralReward = _amount * userInvertedCollateralRatioMantissa / 1e18; // rounds down\n            _shares = tokenToShares(_amount, _currentTotalDebt, _debtSharesSupply, false);\n        }\n        _currentTotalDebt -= _amount;\n\n        // commit current state\n        debtSharesBalanceOf[_borrower] -= _shares;\n        debtSharesSupply = _debtSharesSupply - _shares;\n        collateralBalanceOf[_borrower] = collateralBalance - collateralReward;\n        totalSupply = _currentTotalSupply;\n        lastTotalDebt = _currentTotalDebt;\n        lastAccrueInterestTime = block.timestamp;\n        lastCollateralRatioMantissa = _currentCollateralRatioMantissa;\n        emit Liquidate(_borrower, _amount, collateralReward);\n        if(_accruedFeeShares > 0) {\n            address __feeRecipient = _feeRecipient; // avoid stack too deep\n            balanceOf[__feeRecipient] += _accruedFeeShares;\n            emit Transfer(address(0), __feeRecipient, _accruedFeeShares);\n        }\n\n        // interactions\n        safeTransferFrom(LOAN_TOKEN, msg.sender, address(this), _amount);\n        safeTransfer(COLLATERAL_TOKEN, msg.sender, collateralReward);\n    }\n\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Invest(address indexed user, uint amount);\n    event Divest(address indexed user, uint amount);\n    event Borrow(address indexed user, uint amount);\n    event Repay(address indexed user, address indexed caller, uint amount);\n    event Liquidate(address indexed user, uint amount, uint collateralReward);\n    event Secure(address indexed user, address indexed caller, uint amount);\n    event Unsecure(address indexed user, uint amount);\n}"
    }
  ]
}