{
  "Title": "[G-06] Duplicated require()/if() checks should be refactored to a modifier or function",
  "Content": "\nIt is common to use require() or if() statements to validate certain conditions before executing specific code. However, when the same checks are repeated multiple times within a contract, it can result in redundant code and unnecessary gas consumption.\nTo save gas and improve code readability and maintainability, it is recommended to refactor duplicated checks into modifiers or functions. By doing so, the checks can be abstracted into reusable code blocks that can be applied to multiple functions within the contract.\n\n\n```solidity\nFile: /src/pumps/MultiFlowPump.sol\n225  if (numberOfReserves == 0) {\n\n243  if (numberOfReserves == 0) {\n\n270  if (numberOfReserves == 0) {\n\n289  if (numberOfReserves == 0) {            \n```\nhttps://github.com/code-423n4/2023-07-basin/blob/main/src/pumps/MultiFlowPump.sol#L225\n\nhttps://github.com/code-423n4/2023-07-basin/blob/main/src/pumps/MultiFlowPump.sol#L243\n\nhttps://github.com/code-423n4/2023-07-basin/blob/main/src/pumps/MultiFlowPump.sol#L270\n\nhttps://github.com/code-423n4/2023-07-basin/blob/main/src/pumps/MultiFlowPump.sol#L289\n\n```solidity\nFile: /src/Aquifer.sol\n41  if (salt != bytes32(0)) {\n\n47  if (salt != bytes32(0)) {\n```\nhttps://github.com/code-423n4/2023-07-basin/blob/main/src/Aquifer.sol#L41\n\nhttps://github.com/code-423n4/2023-07-basin/blob/main/src/Aquifer.sol#L47\n\n\n```solidity\nFile: /src/libraries/LibContractInfo.sol\n19  if (success) {\n\n37  if (success) {\n```\nhttps://github.com/code-423n4/2023-07-basin/blob/main/src/libraries/LibContractInfo.sol#L19\n\nhttps://github.com/code-423n4/2023-07-basin/blob/main/src/libraries/LibContractInfo.sol#L37\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-07-basin",
  "Code": [
    {
      "filename": "src/pumps/MultiFlowPump.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport {IPump} from \"src/interfaces/pumps/IPump.sol\";\nimport {IMultiFlowPumpErrors} from \"src/interfaces/pumps/IMultiFlowPumpErrors.sol\";\nimport {IWell} from \"src/interfaces/IWell.sol\";\nimport {IInstantaneousPump} from \"src/interfaces/pumps/IInstantaneousPump.sol\";\nimport {ICumulativePump} from \"src/interfaces/pumps/ICumulativePump.sol\";\nimport {ABDKMathQuad} from \"src/libraries/ABDKMathQuad.sol\";\nimport {LibBytes16} from \"src/libraries/LibBytes16.sol\";\nimport {LibLastReserveBytes} from \"src/libraries/LibLastReserveBytes.sol\";\nimport {SafeCast} from \"oz/utils/math/SafeCast.sol\";\n\n/**\n * @title MultiFlowPump\n * @author Publius\n * @notice Stores a geometric EMA and cumulative geometric SMA for each reserve.\n * @dev A Pump designed for use in Beanstalk with 2 tokens.\n *\n * This Pump has 3 main features:\n *  1. Multi-block MEV resistence reserves\n *  2. MEV-resistant Geometric EMA intended for instantaneous reserve queries\n *  3. MEV-resistant Cumulative Geometric intended for SMA reserve queries\n *\n * Note: If an `update` call is made with a reserve of 0, the Geometric mean oracles will be set to 0.\n * Each Well is responsible for ensuring that an `update` call cannot be made with a reserve of 0.\n */\ncontract MultiFlowPump is IPump, IMultiFlowPumpErrors, IInstantaneousPump, ICumulativePump {\n    using SafeCast for uint256;\n    using LibLastReserveBytes for bytes32;\n    using LibBytes16 for bytes32;\n    using ABDKMathQuad for bytes16;\n    using ABDKMathQuad for uint256;\n\n    bytes16 immutable LOG_MAX_INCREASE;\n    bytes16 immutable LOG_MAX_DECREASE;\n    bytes16 immutable ALPHA;\n    uint256 immutable BLOCK_TIME;\n\n    struct PumpState {\n        uint40 lastTimestamp;\n        bytes16[] lastReserves;\n        bytes16[] emaReserves;\n        bytes16[] cumulativeReserves;\n    }\n\n    /**\n     * @param _maxPercentIncrease The maximum percent increase allowed in a single block. Must be in quadruple precision format (See {ABDKMathQuad}).\n     * @param _maxPercentDecrease The maximum percent decrease allowed in a single block. Must be in quadruple precision format (See {ABDKMathQuad}).\n     * @param _blockTime The block time in the current EVM in seconds.\n     * @param _alpha The geometric EMA constant. Must be in quadruple precision format (See {ABDKMathQuad}).\n     */\n    constructor(bytes16 _maxPercentIncrease, bytes16 _maxPercentDecrease, uint256 _blockTime, bytes16 _alpha) {\n        LOG_MAX_INCREASE = ABDKMathQuad.ONE.add(_maxPercentIncrease).log_2();\n        // _maxPercentDecrease <= 100%\n        if (_maxPercentDecrease > ABDKMathQuad.ONE) {\n            revert InvalidMaxPercentDecreaseArgument(_maxPercentDecrease);\n        }\n        LOG_MAX_DECREASE = ABDKMathQuad.ONE.sub(_maxPercentDecrease).log_2();\n        BLOCK_TIME = _blockTime;\n\n        // ALPHA <= 1\n        if (_alpha > ABDKMathQuad.ONE) {\n            revert InvalidAArgument(_alpha);\n        }\n        ALPHA = _alpha;\n    }\n\n    //////////////////// PUMP ////////////////////\n\n    function update(uint256[] calldata reserves, bytes calldata) external {\n        uint256 numberOfReserves = reserves.length;\n        PumpState memory pumpState;\n\n        // All reserves are stored starting at the msg.sender address slot in storage.\n        bytes32 slot = _getSlotForAddress(msg.sender);\n\n        // Read: Last Timestamp & Last Reserves\n        (, pumpState.lastTimestamp, pumpState.lastReserves) = slot.readLastReserves();\n\n        // If the last timestamp is 0, then the pump has never been used before.\n        if (pumpState.lastTimestamp == 0) {\n            for (uint256 i; i < numberOfReserves; ++i) {\n                // If a reserve is 0, then the pump cannot be initialized.\n                if (reserves[i] == 0) return;\n            }\n            _init(slot, uint40(block.timestamp), reserves);\n            return;\n        }\n\n        // Read: Cumulative & EMA Reserves\n        // Start at the slot after `pumpState.lastReserves`\n        uint256 numSlots = _getSlotsOffset(numberOfReserves);\n        assembly {\n            slot := add(slot, numSlots)\n        }\n        pumpState.emaReserves = slot.readBytes16(numberOfReserves);\n        assembly {\n            slot := add(slot, numSlots)\n        }\n        pumpState.cumulativeReserves = slot.readBytes16(numberOfReserves);\n\n        bytes16 alphaN;\n        bytes16 deltaTimestampBytes;\n        bytes16 blocksPassed;\n        // Isolate in brackets to prevent stack too deep errors\n        {\n            uint256 deltaTimestamp = _getDeltaTimestamp(pumpState.lastTimestamp);\n            alphaN = ALPHA.powu(deltaTimestamp);\n            deltaTimestampBytes = deltaTimestamp.fromUInt();\n            // Relies on the assumption that a block can only occur every `BLOCK_TIME` seconds.\n            blocksPassed = (deltaTimestamp / BLOCK_TIME).fromUInt();\n        }\n\n        for (uint256 i; i < numberOfReserves; ++i) {\n            // Use a minimum of 1 for reserve. Geometric means will be set to 0 if a reserve is 0.\n            pumpState.lastReserves[i] = _capReserve(\n                pumpState.lastReserves[i], (reserves[i] > 0 ? reserves[i] : 1).fromUIntToLog2(), blocksPassed\n            );\n            pumpState.emaReserves[i] =\n                pumpState.lastReserves[i].mul((ABDKMathQuad.ONE.sub(alphaN))).add(pumpState.emaReserves[i].mul(alphaN));\n            pumpState.cumulativeReserves[i] =\n                pumpState.cumulativeReserves[i].add(pumpState.lastReserves[i].mul(deltaTimestampBytes));\n        }\n\n        // Write: Cumulative & EMA Reserves\n        // Order matters: work backwards to avoid using a new memory var to count up\n        slot.storeBytes16(pumpState.cumulativeReserves);\n        assembly {\n            slot := sub(slot, numSlots)\n        }\n        slot.storeBytes16(pumpState.emaReserves);\n        assembly {\n            slot := sub(slot, numSlots)\n        }\n\n        // Write: Last Timestamp & Last Reserves\n        slot.storeLastReserves(uint40(block.timestamp), pumpState.lastReserves);\n    }\n\n    /**\n     * @dev On first update for a particular Well, initialize oracle with\n     * reserves data.\n     */\n    function _init(bytes32 slot, uint40 lastTimestamp, uint256[] memory reserves) internal {\n        uint256 numberOfReserves = reserves.length;\n        bytes16[] memory byteReserves = new bytes16[](numberOfReserves);\n\n        // Skip {_capReserve} since we have no prior reference\n\n        for (uint256 i; i < numberOfReserves; ++i) {\n            if (reserves[i] == 0) return;\n            byteReserves[i] = reserves[i].fromUIntToLog2();\n        }\n\n        // Write: Last Timestamp & Last Reserves\n        slot.storeLastReserves(lastTimestamp, byteReserves);\n\n        // Write: EMA Reserves\n        // Start at the slot after `byteReserves`\n        uint256 numSlots = _getSlotsOffset(byteReserves.length);\n        assembly {\n            slot := add(slot, numSlots)\n        }\n        slot.storeBytes16(byteReserves); // EMA Reserves\n    }\n\n    //////////////////// LAST RESERVES ////////////////////\n\n    function readLastReserves(address well) public view returns (uint256[] memory reserves) {\n        bytes32 slot = _getSlotForAddress(well);\n        (uint8 numberOfReserves,, bytes16[] memory bytesReserves) = slot.readLastReserves();\n        if (numberOfReserves == 0) {\n            revert NotInitialized();\n        }\n        reserves = new uint256[](numberOfReserves);\n        for (uint256 i; i < numberOfReserves; ++i) {\n            reserves[i] = bytesReserves[i].pow_2ToUInt();\n        }\n    }\n\n    /**\n     * @dev Adds a cap to the reserve value to prevent extreme changes.\n     *\n     *  Linear space:\n     *     max reserve = (last reserve) * ((1 + MAX_PERCENT_CHANGE_PER_BLOCK) ^ blocks)\n     *\n     *  Log space:\n     *     log2(max reserve) = log2(last reserve) + blocks*log2(1 + MAX_PERCENT_CHANGE_PER_BLOCK)\n     *\n     *     `bytes16 lastReserve`      <- log2(last reserve)\n     *     `bytes16 blocksPassed`     <- log2(blocks)\n     *     `bytes16 LOG_MAX_INCREASE` <- log2(1 + MAX_PERCENT_CHANGE_PER_BLOCK)\n     *\n     *     ∴ `maxReserve = lastReserve + blocks*LOG_MAX_INCREASE`\n     *\n     */\n    function _capReserve(\n        bytes16 lastReserve,\n        bytes16 reserve,\n        bytes16 blocksPassed\n    ) internal view returns (bytes16 cappedReserve) {\n        // Reserve decreasing (lastReserve > reserve)\n        if (lastReserve.cmp(reserve) == 1) {\n            bytes16 minReserve = lastReserve.add(blocksPassed.mul(LOG_MAX_DECREASE));\n            // if reserve < minimum reserve, set reserve to minimum reserve\n            if (minReserve.cmp(reserve) == 1) reserve = minReserve;\n        }\n        // Rerserve Increasing or staying the same.\n        else {\n            bytes16 maxReserve = blocksPassed.mul(LOG_MAX_INCREASE);\n            maxReserve = lastReserve.add(maxReserve);\n            // If reserve > maximum reserve, set reserve to maximum reserve\n            if (reserve.cmp(maxReserve) == 1) reserve = maxReserve;\n        }\n        cappedReserve = reserve;\n    }\n\n    //////////////////// EMA RESERVES ////////////////////\n\n    function readLastInstantaneousReserves(address well) public view returns (uint256[] memory reserves) {\n        bytes32 slot = _getSlotForAddress(well);\n        uint8 numberOfReserves = slot.readNumberOfReserves();\n        if (numberOfReserves == 0) {\n            revert NotInitialized();\n        }\n        uint256 offset = _getSlotsOffset(numberOfReserves);\n        assembly {\n            slot := add(slot, offset)\n        }\n        bytes16[] memory byteReserves = slot.readBytes16(numberOfReserves);\n        reserves = new uint256[](numberOfReserves);\n        for (uint256 i; i < numberOfReserves; ++i) {\n            reserves[i] = byteReserves[i].pow_2ToUInt();\n        }\n    }\n\n    function readInstantaneousReserves(address well, bytes memory) public view returns (uint256[] memory emaReserves) {\n        bytes32 slot = _getSlotForAddress(well);\n        uint256[] memory reserves = IWell(well).getReserves();\n        (uint8 numberOfReserves, uint40 lastTimestamp, bytes16[] memory lastReserves) = slot.readLastReserves();\n        if (numberOfReserves == 0) {\n            revert NotInitialized();\n        }\n        uint256 offset = _getSlotsOffset(numberOfReserves);\n        assembly {\n            slot := add(slot, offset)\n        }\n        bytes16[] memory lastEmaReserves = slot.readBytes16(numberOfReserves);\n        uint256 deltaTimestamp = _getDeltaTimestamp(lastTimestamp);\n        bytes16 blocksPassed = (deltaTimestamp / BLOCK_TIME).fromUInt();\n        bytes16 alphaN = ALPHA.powu(deltaTimestamp);\n        emaReserves = new uint256[](numberOfReserves);\n        for (uint256 i; i < numberOfReserves; ++i) {\n            lastReserves[i] = _capReserve(lastReserves[i], reserves[i].fromUIntToLog2(), blocksPassed);\n            emaReserves[i] =\n                lastReserves[i].mul((ABDKMathQuad.ONE.sub(alphaN))).add(lastEmaReserves[i].mul(alphaN)).pow_2ToUInt();\n        }\n    }\n\n    //////////////////// CUMULATIVE RESERVES ////////////////////\n\n    /**\n     * @notice Read the latest cumulative reserves of `well`.\n     */\n    function readLastCumulativeReserves(address well) public view returns (bytes16[] memory reserves) {\n        bytes32 slot = _getSlotForAddress(well);\n        uint8 numberOfReserves = slot.readNumberOfReserves();\n        if (numberOfReserves == 0) {\n            revert NotInitialized();\n        }\n        uint256 offset = _getSlotsOffset(numberOfReserves) << 1;\n        assembly {\n            slot := add(slot, offset)\n        }\n        reserves = slot.readBytes16(numberOfReserves);\n    }\n\n    function readCumulativeReserves(address well, bytes memory) public view returns (bytes memory cumulativeReserves) {\n        bytes16[] memory byteCumulativeReserves = _readCumulativeReserves(well);\n        cumulativeReserves = abi.encode(byteCumulativeReserves);\n    }\n\n    function _readCumulativeReserves(address well) internal view returns (bytes16[] memory cumulativeReserves) {\n        bytes32 slot = _getSlotForAddress(well);\n        uint256[] memory reserves = IWell(well).getReserves();\n        (uint8 numberOfReserves, uint40 lastTimestamp, bytes16[] memory lastReserves) = slot.readLastReserves();\n        if (numberOfReserves == 0) {\n            revert NotInitialized();\n        }\n        uint256 offset = _getSlotsOffset(numberOfReserves) << 1;\n        assembly {\n            slot := add(slot, offset)\n        }\n        cumulativeReserves = slot.readBytes16(numberOfReserves);\n        uint256 deltaTimestamp = _getDeltaTimestamp(lastTimestamp);\n        bytes16 deltaTimestampBytes = deltaTimestamp.fromUInt();\n        bytes16 blocksPassed = (deltaTimestamp / BLOCK_TIME).fromUInt();\n        // Currently, there is so support for overflow.\n        for (uint256 i; i < cumulativeReserves.length; ++i) {\n            lastReserves[i] = _capReserve(lastReserves[i], reserves[i].fromUIntToLog2(), blocksPassed);\n            cumulativeReserves[i] = cumulativeReserves[i].add(lastReserves[i].mul(deltaTimestampBytes));\n        }\n    }\n\n    function readTwaReserves(\n        address well,\n        bytes calldata startCumulativeReserves,\n        uint256 startTimestamp,\n        bytes memory\n    ) public view returns (uint256[] memory twaReserves, bytes memory cumulativeReserves) {\n        bytes16[] memory byteCumulativeReserves = _readCumulativeReserves(well);\n        bytes16[] memory byteStartCumulativeReserves = abi.decode(startCumulativeReserves, (bytes16[]));\n        twaReserves = new uint256[](byteCumulativeReserves.length);\n\n        // Overflow is desired on `startTimestamp`, so SafeCast is not used.\n        bytes16 deltaTimestamp = _getDeltaTimestamp(uint40(startTimestamp)).fromUInt();\n        if (deltaTimestamp == bytes16(0)) {\n            revert NoTimePassed();\n        }\n        for (uint256 i; i < byteCumulativeReserves.length; ++i) {\n            // Currently, there is no support for overflow.\n            twaReserves[i] =\n                (byteCumulativeReserves[i].sub(byteStartCumulativeReserves[i])).div(deltaTimestamp).pow_2ToUInt();\n        }\n        cumulativeReserves = abi.encode(byteCumulativeReserves);\n    }\n\n    //////////////////// HELPERS ////////////////////\n\n    /**\n     * @dev Convert an `address` into a `bytes32` by zero padding the right 12 bytes.\n     */\n    function _getSlotForAddress(address addressValue) internal pure returns (bytes32) {\n        return bytes32(bytes20(addressValue)); // Because right padded, no collision on adjacent\n    }\n\n    /**\n     * @dev Get the starting byte of the slot that contains the `n`th element of an array.\n     */\n    function _getSlotsOffset(uint256 numberOfReserves) internal pure returns (uint256) {\n        return ((numberOfReserves - 1) / 2 + 1) << 5;\n    }\n\n    /**\n     * @dev Get the delta between the current and provided timestamp as a `uint256`.\n     */\n    function _getDeltaTimestamp(uint40 lastTimestamp) internal view returns (uint256) {\n        return uint256(uint40(block.timestamp) - lastTimestamp);\n    }\n}"
    },
    {
      "filename": "src/pumps/MultiFlowPump.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport {IPump} from \"src/interfaces/pumps/IPump.sol\";\nimport {IMultiFlowPumpErrors} from \"src/interfaces/pumps/IMultiFlowPumpErrors.sol\";\nimport {IWell} from \"src/interfaces/IWell.sol\";\nimport {IInstantaneousPump} from \"src/interfaces/pumps/IInstantaneousPump.sol\";\nimport {ICumulativePump} from \"src/interfaces/pumps/ICumulativePump.sol\";\nimport {ABDKMathQuad} from \"src/libraries/ABDKMathQuad.sol\";\nimport {LibBytes16} from \"src/libraries/LibBytes16.sol\";\nimport {LibLastReserveBytes} from \"src/libraries/LibLastReserveBytes.sol\";\nimport {SafeCast} from \"oz/utils/math/SafeCast.sol\";\n\n/**\n * @title MultiFlowPump\n * @author Publius\n * @notice Stores a geometric EMA and cumulative geometric SMA for each reserve.\n * @dev A Pump designed for use in Beanstalk with 2 tokens.\n *\n * This Pump has 3 main features:\n *  1. Multi-block MEV resistence reserves\n *  2. MEV-resistant Geometric EMA intended for instantaneous reserve queries\n *  3. MEV-resistant Cumulative Geometric intended for SMA reserve queries\n *\n * Note: If an `update` call is made with a reserve of 0, the Geometric mean oracles will be set to 0.\n * Each Well is responsible for ensuring that an `update` call cannot be made with a reserve of 0.\n */\ncontract MultiFlowPump is IPump, IMultiFlowPumpErrors, IInstantaneousPump, ICumulativePump {\n    using SafeCast for uint256;\n    using LibLastReserveBytes for bytes32;\n    using LibBytes16 for bytes32;\n    using ABDKMathQuad for bytes16;\n    using ABDKMathQuad for uint256;\n\n    bytes16 immutable LOG_MAX_INCREASE;\n    bytes16 immutable LOG_MAX_DECREASE;\n    bytes16 immutable ALPHA;\n    uint256 immutable BLOCK_TIME;\n\n    struct PumpState {\n        uint40 lastTimestamp;\n        bytes16[] lastReserves;\n        bytes16[] emaReserves;\n        bytes16[] cumulativeReserves;\n    }\n\n    /**\n     * @param _maxPercentIncrease The maximum percent increase allowed in a single block. Must be in quadruple precision format (See {ABDKMathQuad}).\n     * @param _maxPercentDecrease The maximum percent decrease allowed in a single block. Must be in quadruple precision format (See {ABDKMathQuad}).\n     * @param _blockTime The block time in the current EVM in seconds.\n     * @param _alpha The geometric EMA constant. Must be in quadruple precision format (See {ABDKMathQuad}).\n     */\n    constructor(bytes16 _maxPercentIncrease, bytes16 _maxPercentDecrease, uint256 _blockTime, bytes16 _alpha) {\n        LOG_MAX_INCREASE = ABDKMathQuad.ONE.add(_maxPercentIncrease).log_2();\n        // _maxPercentDecrease <= 100%\n        if (_maxPercentDecrease > ABDKMathQuad.ONE) {\n            revert InvalidMaxPercentDecreaseArgument(_maxPercentDecrease);\n        }\n        LOG_MAX_DECREASE = ABDKMathQuad.ONE.sub(_maxPercentDecrease).log_2();\n        BLOCK_TIME = _blockTime;\n\n        // ALPHA <= 1\n        if (_alpha > ABDKMathQuad.ONE) {\n            revert InvalidAArgument(_alpha);\n        }\n        ALPHA = _alpha;\n    }\n\n    //////////////////// PUMP ////////////////////\n\n    function update(uint256[] calldata reserves, bytes calldata) external {\n        uint256 numberOfReserves = reserves.length;\n        PumpState memory pumpState;\n\n        // All reserves are stored starting at the msg.sender address slot in storage.\n        bytes32 slot = _getSlotForAddress(msg.sender);\n\n        // Read: Last Timestamp & Last Reserves\n        (, pumpState.lastTimestamp, pumpState.lastReserves) = slot.readLastReserves();\n\n        // If the last timestamp is 0, then the pump has never been used before.\n        if (pumpState.lastTimestamp == 0) {\n            for (uint256 i; i < numberOfReserves; ++i) {\n                // If a reserve is 0, then the pump cannot be initialized.\n                if (reserves[i] == 0) return;\n            }\n            _init(slot, uint40(block.timestamp), reserves);\n            return;\n        }\n\n        // Read: Cumulative & EMA Reserves\n        // Start at the slot after `pumpState.lastReserves`\n        uint256 numSlots = _getSlotsOffset(numberOfReserves);\n        assembly {\n            slot := add(slot, numSlots)\n        }\n        pumpState.emaReserves = slot.readBytes16(numberOfReserves);\n        assembly {\n            slot := add(slot, numSlots)\n        }\n        pumpState.cumulativeReserves = slot.readBytes16(numberOfReserves);\n\n        bytes16 alphaN;\n        bytes16 deltaTimestampBytes;\n        bytes16 blocksPassed;\n        // Isolate in brackets to prevent stack too deep errors\n        {\n            uint256 deltaTimestamp = _getDeltaTimestamp(pumpState.lastTimestamp);\n            alphaN = ALPHA.powu(deltaTimestamp);\n            deltaTimestampBytes = deltaTimestamp.fromUInt();\n            // Relies on the assumption that a block can only occur every `BLOCK_TIME` seconds.\n            blocksPassed = (deltaTimestamp / BLOCK_TIME).fromUInt();\n        }\n\n        for (uint256 i; i < numberOfReserves; ++i) {\n            // Use a minimum of 1 for reserve. Geometric means will be set to 0 if a reserve is 0.\n            pumpState.lastReserves[i] = _capReserve(\n                pumpState.lastReserves[i], (reserves[i] > 0 ? reserves[i] : 1).fromUIntToLog2(), blocksPassed\n            );\n            pumpState.emaReserves[i] =\n                pumpState.lastReserves[i].mul((ABDKMathQuad.ONE.sub(alphaN))).add(pumpState.emaReserves[i].mul(alphaN));\n            pumpState.cumulativeReserves[i] =\n                pumpState.cumulativeReserves[i].add(pumpState.lastReserves[i].mul(deltaTimestampBytes));\n        }\n\n        // Write: Cumulative & EMA Reserves\n        // Order matters: work backwards to avoid using a new memory var to count up\n        slot.storeBytes16(pumpState.cumulativeReserves);\n        assembly {\n            slot := sub(slot, numSlots)\n        }\n        slot.storeBytes16(pumpState.emaReserves);\n        assembly {\n            slot := sub(slot, numSlots)\n        }\n\n        // Write: Last Timestamp & Last Reserves\n        slot.storeLastReserves(uint40(block.timestamp), pumpState.lastReserves);\n    }\n\n    /**\n     * @dev On first update for a particular Well, initialize oracle with\n     * reserves data.\n     */\n    function _init(bytes32 slot, uint40 lastTimestamp, uint256[] memory reserves) internal {\n        uint256 numberOfReserves = reserves.length;\n        bytes16[] memory byteReserves = new bytes16[](numberOfReserves);\n\n        // Skip {_capReserve} since we have no prior reference\n\n        for (uint256 i; i < numberOfReserves; ++i) {\n            if (reserves[i] == 0) return;\n            byteReserves[i] = reserves[i].fromUIntToLog2();\n        }\n\n        // Write: Last Timestamp & Last Reserves\n        slot.storeLastReserves(lastTimestamp, byteReserves);\n\n        // Write: EMA Reserves\n        // Start at the slot after `byteReserves`\n        uint256 numSlots = _getSlotsOffset(byteReserves.length);\n        assembly {\n            slot := add(slot, numSlots)\n        }\n        slot.storeBytes16(byteReserves); // EMA Reserves\n    }\n\n    //////////////////// LAST RESERVES ////////////////////\n\n    function readLastReserves(address well) public view returns (uint256[] memory reserves) {\n        bytes32 slot = _getSlotForAddress(well);\n        (uint8 numberOfReserves,, bytes16[] memory bytesReserves) = slot.readLastReserves();\n        if (numberOfReserves == 0) {\n            revert NotInitialized();\n        }\n        reserves = new uint256[](numberOfReserves);\n        for (uint256 i; i < numberOfReserves; ++i) {\n            reserves[i] = bytesReserves[i].pow_2ToUInt();\n        }\n    }\n\n    /**\n     * @dev Adds a cap to the reserve value to prevent extreme changes.\n     *\n     *  Linear space:\n     *     max reserve = (last reserve) * ((1 + MAX_PERCENT_CHANGE_PER_BLOCK) ^ blocks)\n     *\n     *  Log space:\n     *     log2(max reserve) = log2(last reserve) + blocks*log2(1 + MAX_PERCENT_CHANGE_PER_BLOCK)\n     *\n     *     `bytes16 lastReserve`      <- log2(last reserve)\n     *     `bytes16 blocksPassed`     <- log2(blocks)\n     *     `bytes16 LOG_MAX_INCREASE` <- log2(1 + MAX_PERCENT_CHANGE_PER_BLOCK)\n     *\n     *     ∴ `maxReserve = lastReserve + blocks*LOG_MAX_INCREASE`\n     *\n     */\n    function _capReserve(\n        bytes16 lastReserve,\n        bytes16 reserve,\n        bytes16 blocksPassed\n    ) internal view returns (bytes16 cappedReserve) {\n        // Reserve decreasing (lastReserve > reserve)\n        if (lastReserve.cmp(reserve) == 1) {\n            bytes16 minReserve = lastReserve.add(blocksPassed.mul(LOG_MAX_DECREASE));\n            // if reserve < minimum reserve, set reserve to minimum reserve\n            if (minReserve.cmp(reserve) == 1) reserve = minReserve;\n        }\n        // Rerserve Increasing or staying the same.\n        else {\n            bytes16 maxReserve = blocksPassed.mul(LOG_MAX_INCREASE);\n            maxReserve = lastReserve.add(maxReserve);\n            // If reserve > maximum reserve, set reserve to maximum reserve\n            if (reserve.cmp(maxReserve) == 1) reserve = maxReserve;\n        }\n        cappedReserve = reserve;\n    }\n\n    //////////////////// EMA RESERVES ////////////////////\n\n    function readLastInstantaneousReserves(address well) public view returns (uint256[] memory reserves) {\n        bytes32 slot = _getSlotForAddress(well);\n        uint8 numberOfReserves = slot.readNumberOfReserves();\n        if (numberOfReserves == 0) {\n            revert NotInitialized();\n        }\n        uint256 offset = _getSlotsOffset(numberOfReserves);\n        assembly {\n            slot := add(slot, offset)\n        }\n        bytes16[] memory byteReserves = slot.readBytes16(numberOfReserves);\n        reserves = new uint256[](numberOfReserves);\n        for (uint256 i; i < numberOfReserves; ++i) {\n            reserves[i] = byteReserves[i].pow_2ToUInt();\n        }\n    }\n\n    function readInstantaneousReserves(address well, bytes memory) public view returns (uint256[] memory emaReserves) {\n        bytes32 slot = _getSlotForAddress(well);\n        uint256[] memory reserves = IWell(well).getReserves();\n        (uint8 numberOfReserves, uint40 lastTimestamp, bytes16[] memory lastReserves) = slot.readLastReserves();\n        if (numberOfReserves == 0) {\n            revert NotInitialized();\n        }\n        uint256 offset = _getSlotsOffset(numberOfReserves);\n        assembly {\n            slot := add(slot, offset)\n        }\n        bytes16[] memory lastEmaReserves = slot.readBytes16(numberOfReserves);\n        uint256 deltaTimestamp = _getDeltaTimestamp(lastTimestamp);\n        bytes16 blocksPassed = (deltaTimestamp / BLOCK_TIME).fromUInt();\n        bytes16 alphaN = ALPHA.powu(deltaTimestamp);\n        emaReserves = new uint256[](numberOfReserves);\n        for (uint256 i; i < numberOfReserves; ++i) {\n            lastReserves[i] = _capReserve(lastReserves[i], reserves[i].fromUIntToLog2(), blocksPassed);\n            emaReserves[i] =\n                lastReserves[i].mul((ABDKMathQuad.ONE.sub(alphaN))).add(lastEmaReserves[i].mul(alphaN)).pow_2ToUInt();\n        }\n    }\n\n    //////////////////// CUMULATIVE RESERVES ////////////////////\n\n    /**\n     * @notice Read the latest cumulative reserves of `well`.\n     */\n    function readLastCumulativeReserves(address well) public view returns (bytes16[] memory reserves) {\n        bytes32 slot = _getSlotForAddress(well);\n        uint8 numberOfReserves = slot.readNumberOfReserves();\n        if (numberOfReserves == 0) {\n            revert NotInitialized();\n        }\n        uint256 offset = _getSlotsOffset(numberOfReserves) << 1;\n        assembly {\n            slot := add(slot, offset)\n        }\n        reserves = slot.readBytes16(numberOfReserves);\n    }\n\n    function readCumulativeReserves(address well, bytes memory) public view returns (bytes memory cumulativeReserves) {\n        bytes16[] memory byteCumulativeReserves = _readCumulativeReserves(well);\n        cumulativeReserves = abi.encode(byteCumulativeReserves);\n    }\n\n    function _readCumulativeReserves(address well) internal view returns (bytes16[] memory cumulativeReserves) {\n        bytes32 slot = _getSlotForAddress(well);\n        uint256[] memory reserves = IWell(well).getReserves();\n        (uint8 numberOfReserves, uint40 lastTimestamp, bytes16[] memory lastReserves) = slot.readLastReserves();\n        if (numberOfReserves == 0) {\n            revert NotInitialized();\n        }\n        uint256 offset = _getSlotsOffset(numberOfReserves) << 1;\n        assembly {\n            slot := add(slot, offset)\n        }\n        cumulativeReserves = slot.readBytes16(numberOfReserves);\n        uint256 deltaTimestamp = _getDeltaTimestamp(lastTimestamp);\n        bytes16 deltaTimestampBytes = deltaTimestamp.fromUInt();\n        bytes16 blocksPassed = (deltaTimestamp / BLOCK_TIME).fromUInt();\n        // Currently, there is so support for overflow.\n        for (uint256 i; i < cumulativeReserves.length; ++i) {\n            lastReserves[i] = _capReserve(lastReserves[i], reserves[i].fromUIntToLog2(), blocksPassed);\n            cumulativeReserves[i] = cumulativeReserves[i].add(lastReserves[i].mul(deltaTimestampBytes));\n        }\n    }\n\n    function readTwaReserves(\n        address well,\n        bytes calldata startCumulativeReserves,\n        uint256 startTimestamp,\n        bytes memory\n    ) public view returns (uint256[] memory twaReserves, bytes memory cumulativeReserves) {\n        bytes16[] memory byteCumulativeReserves = _readCumulativeReserves(well);\n        bytes16[] memory byteStartCumulativeReserves = abi.decode(startCumulativeReserves, (bytes16[]));\n        twaReserves = new uint256[](byteCumulativeReserves.length);\n\n        // Overflow is desired on `startTimestamp`, so SafeCast is not used.\n        bytes16 deltaTimestamp = _getDeltaTimestamp(uint40(startTimestamp)).fromUInt();\n        if (deltaTimestamp == bytes16(0)) {\n            revert NoTimePassed();\n        }\n        for (uint256 i; i < byteCumulativeReserves.length; ++i) {\n            // Currently, there is no support for overflow.\n            twaReserves[i] =\n                (byteCumulativeReserves[i].sub(byteStartCumulativeReserves[i])).div(deltaTimestamp).pow_2ToUInt();\n        }\n        cumulativeReserves = abi.encode(byteCumulativeReserves);\n    }\n\n    //////////////////// HELPERS ////////////////////\n\n    /**\n     * @dev Convert an `address` into a `bytes32` by zero padding the right 12 bytes.\n     */\n    function _getSlotForAddress(address addressValue) internal pure returns (bytes32) {\n        return bytes32(bytes20(addressValue)); // Because right padded, no collision on adjacent\n    }\n\n    /**\n     * @dev Get the starting byte of the slot that contains the `n`th element of an array.\n     */\n    function _getSlotsOffset(uint256 numberOfReserves) internal pure returns (uint256) {\n        return ((numberOfReserves - 1) / 2 + 1) << 5;\n    }\n\n    /**\n     * @dev Get the delta between the current and provided timestamp as a `uint256`.\n     */\n    function _getDeltaTimestamp(uint40 lastTimestamp) internal view returns (uint256) {\n        return uint256(uint40(block.timestamp) - lastTimestamp);\n    }\n}"
    },
    {
      "filename": "src/pumps/MultiFlowPump.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport {IPump} from \"src/interfaces/pumps/IPump.sol\";\nimport {IMultiFlowPumpErrors} from \"src/interfaces/pumps/IMultiFlowPumpErrors.sol\";\nimport {IWell} from \"src/interfaces/IWell.sol\";\nimport {IInstantaneousPump} from \"src/interfaces/pumps/IInstantaneousPump.sol\";\nimport {ICumulativePump} from \"src/interfaces/pumps/ICumulativePump.sol\";\nimport {ABDKMathQuad} from \"src/libraries/ABDKMathQuad.sol\";\nimport {LibBytes16} from \"src/libraries/LibBytes16.sol\";\nimport {LibLastReserveBytes} from \"src/libraries/LibLastReserveBytes.sol\";\nimport {SafeCast} from \"oz/utils/math/SafeCast.sol\";\n\n/**\n * @title MultiFlowPump\n * @author Publius\n * @notice Stores a geometric EMA and cumulative geometric SMA for each reserve.\n * @dev A Pump designed for use in Beanstalk with 2 tokens.\n *\n * This Pump has 3 main features:\n *  1. Multi-block MEV resistence reserves\n *  2. MEV-resistant Geometric EMA intended for instantaneous reserve queries\n *  3. MEV-resistant Cumulative Geometric intended for SMA reserve queries\n *\n * Note: If an `update` call is made with a reserve of 0, the Geometric mean oracles will be set to 0.\n * Each Well is responsible for ensuring that an `update` call cannot be made with a reserve of 0.\n */\ncontract MultiFlowPump is IPump, IMultiFlowPumpErrors, IInstantaneousPump, ICumulativePump {\n    using SafeCast for uint256;\n    using LibLastReserveBytes for bytes32;\n    using LibBytes16 for bytes32;\n    using ABDKMathQuad for bytes16;\n    using ABDKMathQuad for uint256;\n\n    bytes16 immutable LOG_MAX_INCREASE;\n    bytes16 immutable LOG_MAX_DECREASE;\n    bytes16 immutable ALPHA;\n    uint256 immutable BLOCK_TIME;\n\n    struct PumpState {\n        uint40 lastTimestamp;\n        bytes16[] lastReserves;\n        bytes16[] emaReserves;\n        bytes16[] cumulativeReserves;\n    }\n\n    /**\n     * @param _maxPercentIncrease The maximum percent increase allowed in a single block. Must be in quadruple precision format (See {ABDKMathQuad}).\n     * @param _maxPercentDecrease The maximum percent decrease allowed in a single block. Must be in quadruple precision format (See {ABDKMathQuad}).\n     * @param _blockTime The block time in the current EVM in seconds.\n     * @param _alpha The geometric EMA constant. Must be in quadruple precision format (See {ABDKMathQuad}).\n     */\n    constructor(bytes16 _maxPercentIncrease, bytes16 _maxPercentDecrease, uint256 _blockTime, bytes16 _alpha) {\n        LOG_MAX_INCREASE = ABDKMathQuad.ONE.add(_maxPercentIncrease).log_2();\n        // _maxPercentDecrease <="
    }
  ]
}