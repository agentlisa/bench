{
  "Title": "M-17: Leverage borrowing with stale rate can atomically create bad debt with no prior positions and no investment",
  "Content": "# Issue M-17: Leverage borrowing with stale rate can atomically create bad debt with no prior positions and no investment \n\nSource: https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/79 \n\n## Found by \nhyh\n## Summary\n\nLeverage buying, borrow and collateral removal can increase riskness of a position, but are allowed to be performed with a stale exchange rate within `rateValidDuration` both in BB ansd SGL. This can provide a way for creating bad debt whenever actual rate dropped more than `FEE_PRECISION - collateralizationRate` (`25%`).\n\nParticularly, an attacker can atomically extract value from the protocol without having any prior positions via leverage buying and then collateral removal.\n\n## Vulnerability Detail\n\nWhenever Oracle reported rate is stale (`oracle.get(oracleData)` doesn't return an updated value), while market rate has dropped more than `FEE_PRECISION - collateralizationRate` (`FEE_PRECISION` scale), it is possible to atomically open borrow posiiton, buy collateral from the market and then remove extra collateral from the system with no prior positions and no investment.\n\nThe possibility of opening new positions, expecially leveraged ones, with a stale rate isn't required for BB or SGL core functionality, it constitutes a possible attack vector with very low business value of this possibility by itself.\n\n## Impact\n\nWhen a collateral can be bought from the market at a rate lower than Oracle reported stale rate by more than `FEE_PRECISION - collateralizationRate`, the difference between rate mismatch and this buffer can be extracted from the protocol by anyone with no prepositioning or investment needed.\n\nThe probability of such a drop combined with Oracle staleness can be estimated as low, but once this happens given the absense of barriers to entry the attack will be carried out with high probability. The impact itself if direct loss of protocol principal funds as bad debt will be atomically created this way, which has to be covered by other assets of the system thereafter.\n\nLikelihood: Low + Impact: High = Severity: Medium.\n\n## Code Snippet\n\n`updateExchangeRate()` allows for stale rate within `rateValidDuration`:\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/Market.sol#L372-L385\n\n```solidity\n    function updateExchangeRate() public returns (bool updated, uint256 rate) {\n        (updated, rate) = oracle.get(oracleData);\n\n        if (updated) {\n            require(rate != 0, \"Market: invalid rate\");\n            exchangeRate = rate;\n            rateTimestamp = block.timestamp;\n            emit LogExchangeRate(rate);\n        } else {\n>>          require(rateTimestamp + rateValidDuration >= block.timestamp, \"Market: rate too old\");\n            // Return the old rate if fetching wasn't successful & rate isn't too old\n            rate = exchangeRate;\n        }\n    }\n```\n\n`solvent` check is used a the only control for a number of operations:\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/Market.sol#L163-L170\n\n```solidity\n    modifier solvent(address from, bool liquidation) {\n        updateExchangeRate();\n        _accrue();\n\n        _;\n\n        require(_isSolvent(from, exchangeRate, liquidation), \"Market: insolvent\");\n    }\n```\n\nIncluding atomic opening of the leveraged borrow position both in BB and SGL:\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/bigBang/BBLeverage.sol#L53-L58\n\n```solidity\n    function buyCollateral(address from, uint256 borrowAmount, uint256 supplyAmount, bytes calldata data)\n        external\n        optionNotPaused(PauseType.LeverageBuy)\n>>      solvent(from, false)\n        notSelf(from)\n        returns (uint256 amountOut)\n```\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/singularity/SGLLeverage.sol#L47-L52\n\n```solidity\n    function buyCollateral(address from, uint256 borrowAmount, uint256 supplyAmount, bytes calldata data)\n        external\n        optionNotPaused(PauseType.LeverageBuy)\n>>      solvent(from, false)\n        notSelf(from)\n        returns (uint256 amountOut)\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider introducing another level of control and allowing leverage operations and new positions opening only when the Oracle reported rate is current, e.g.:\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/Market.sol#L372-L385\n\n```diff\n-   function updateExchangeRate() public returns (bool updated, uint256 rate) {\n+   function updateExchangeRate(bool updateRequired) public returns (bool updated, uint256 rate) {\n        (updated, rate) = oracle.get(oracleData);\n\n        if (updated) {\n            require(rate != 0, \"Market: invalid rate\");\n            exchangeRate = rate;\n            rateTimestamp = block.timestamp;\n            emit LogExchangeRate(rate);\n        } else {\n-           require(rateTimestamp + rateValidDuration >= block.timestamp, \"Market: rate too old\");\n+           require(!updateRequired && rateTimestamp + rateValidDuration >= block.timestamp, \"Market: rate too old\");\n            // Return the old rate if fetching wasn't successful & rate isn't too old\n            rate = exchangeRate;\n        }\n    }\n```\n\n`liquidation` flag can be dropped from `solvent` modifier since it is used only with `liquidation == false` (while `_isSolvent()` is being called directly on liquidations both in BB and SGL), and replaced with the `updateRequired` flag proposed, e.g.:\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/Market.sol#L163-L170\n\n```diff\n-   modifier solvent(address from, bool liquidation) {\n+   modifier solvent(address from, bool updateRequired) {\n-       updateExchangeRate();\n+       updateExchangeRate(updateRequired);\n        _accrue();\n\n        _;\n\n-       require(_isSolvent(from, exchangeRate, liquidation), \"Market: insolvent\");\n+       require(_isSolvent(from, exchangeRate, false), \"Market: insolvent\");\n    }\n```\n\nAll risk increase operations, i.e. leverage buying, borrow and collateral removal can utilize `solvent` modifiers with `updateRequired == true`, enforcing the Oracle reading to be current:\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/bigBang/BBLeverage.sol#L53-L58\n\n```diff\n    function buyCollateral(address from, uint256 borrowAmount, uint256 supplyAmount, bytes calldata data)\n        external\n        optionNotPaused(PauseType.LeverageBuy)\n-       solvent(from, false)\n+       solvent(from, true)\n        notSelf(from)\n        returns (uint256 amountOut)\n```\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/bigBang/BBBorrow.sol#L37-L42\n\n```diff\n    function borrow(address from, address to, uint256 amount)\n        external\n        optionNotPaused(PauseType.Borrow)\n        notSelf(to)\n-       solvent(from, false)\n+       solvent(from, true)\n        returns (uint256 part, uint256 share)\n```\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/origins/Origins.sol#L162-L165\n\n```diff\n    function removeCollateral(uint256 share)\n        external\n        optionNotPaused(PauseType.RemoveCollateral)\n-       solvent(msg.sender, false)\n+       solvent(msg.sender, true)\n```\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/origins/Origins.sol#L175-L178\n\n```diff\n    function borrow(uint256 amount)\n        external\n        optionNotPaused(PauseType.Borrow)\n-       solvent(msg.sender, false)\n+       solvent(msg.sender, true)\n```\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/singularity/SGLBorrow.sol#L29-L34\n\n```diff\n    function borrow(address from, address to, uint256 amount)\n        external\n        optionNotPaused(PauseType.Borrow)\n-       solvent(from, false)\n+       solvent(from, true)\n        notSelf(to)\n        returns (uint256 part, uint256 share)\n```\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/singularity/SGLCollateral.sol#L48-L53\n\n```diff\n    function removeCollateral(address from, address to, uint256 share)\n        external\n        optionNotPaused(PauseType.RemoveCollateral)\n-       solvent(from, false)\n+       solvent(from, true)\n        allowedBorrow(from, share)\n        notSelf(to)\n```\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/markets/singularity/SGLLeverage.sol#L47-L52\n\n```diff\n    function buyCollateral(address from, uint256 borrowAmount, uint256 supplyAmount, bytes calldata data)\n        external\n        optionNotPaused(PauseType.LeverageBuy)\n-       solvent(from, false)\n+       solvent(from, true)\n        notSelf(from)\n        returns (uint256 amountOut)\n```\n\nAll the other `solvent(from, false)` instances can stay intact.\n\n\n\n## Discussion\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/Tapioca-DAO/Tapioca-bar/pull/357.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/170",
  "Code": [
    {
      "filename": "Tapioca-bar/contracts/markets/Market.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {RebaseLibrary, Rebase} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport {IERC20} from \"@boringcrypto/boring-solidity/contracts/ERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Tapioca\nimport {ILeverageExecutor} from \"tapioca-periph/interfaces/bar/ILeverageExecutor.sol\";\nimport {ITapiocaOracle} from \"tapioca-periph/interfaces/periph/ITapiocaOracle.sol\";\nimport {IYieldBox} from \"tapioca-periph/interfaces/yieldbox/IYieldBox.sol\";\nimport {IPearlmit} from \"tapioca-periph/interfaces/periph/IPearlmit.sol\";\nimport {IPenrose} from \"tapioca-periph/interfaces/bar/IPenrose.sol\";\nimport {MarketERC20} from \"./MarketERC20.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\nabstract contract Market is MarketERC20, Ownable {\n    using RebaseLibrary for Rebase;\n\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n    enum PauseType {\n        Borrow,\n        Repay,\n        AddCollateral,\n        RemoveCollateral,\n        Liquidation,\n        LeverageBuy,\n        LeverageSell,\n        AddAsset,\n        RemoveAsset\n    }\n\n    /// @notice pause options\n    mapping(PauseType pauseProp => bool pauseStatus) public pauseOptions;\n    /// @notice conservator's addresss\n    /// @dev conservator can pause/unpause the contract\n    address public conservator;\n\n    /// @notice returns YieldBox address\n    IYieldBox public yieldBox;\n    /// @notice returns Penrose address\n    IPenrose public penrose;\n\n    IPearlmit public pearlmit;\n\n    /// @notice collateral token address\n    IERC20 public collateral;\n    /// @notice collateral token YieldBox id\n    uint256 public collateralId;\n    /// @notice asset token address\n    IERC20 public asset;\n    /// @notice asset token YieldBox id\n    uint256 public assetId;\n    /// @notice oracle address\n    ITapiocaOracle public oracle;\n    /// @notice oracleData\n    bytes public oracleData;\n    /// @notice Exchange and interest rate tracking.\n    /// This is 'cached' here because calls to Oracles can be very expensive.\n    /// Asset -> collateral = assetAmount * exchangeRate.\n    uint256 public exchangeRate;\n    /// @notice cached rate is valid only for the `rateValidDuration` time\n    uint256 public rateValidDuration;\n    /// @notice latest timestamp when `exchangeRate` was updated\n    uint256 public rateTimestamp;\n\n    /// @notice total amount borrowed\n    /// @dev elastic = Total token amount to be repayed by borrowers, base = Total parts of the debt held by borrowers\n    Rebase public totalBorrow;\n    /// @notice total collateral supplied\n    uint256 public totalCollateralShare;\n    /// @notice max borrow cap\n    uint256 public totalBorrowCap;\n    /// @notice borrow amount per user\n    mapping(address => uint256) public userBorrowPart;\n    /// @notice collateral share per user\n    mapping(address => uint256) public userCollateralShare;\n\n    /// @notice accrual protocol rewards\n    uint256 public protocolFee; // 10%\n    /// @notice min % a liquidator can receive in rewards\n    uint256 public minLiquidatorReward = 8e4; //80%\n    /// @notice max % a liquidator can receive in rewards\n    uint256 public maxLiquidatorReward = 9e4; //90%\n    /// @notice max liquidatable bonus amount\n    /// @dev max % added to the amount that can be liquidated\n    uint256 public liquidationBonusAmount = 1e4; //10%\n    /// @notice collateralization rate\n    uint256 public collateralizationRate; // 75%\n    /// @notice liquidation collateralization rate\n    uint256 public liquidationCollateralizationRate; //80%\n    /// @notice liquidation multiplier used to compute liquidator rewards\n    uint256 public liquidationMultiplier = 12000; //12%\n    /// @notice returns the leverage executor\n    ILeverageExecutor public leverageExecutor;\n\n    // ***************** //\n    // *** CONSTANTS *** //\n    // ***************** //\n    uint256 internal EXCHANGE_RATE_PRECISION; //not costant, but can only be set in the 'init' method\n    uint256 internal constant FEE_PRECISION = 1e5;\n    uint256 internal constant FEE_PRECISION_DECIMALS = 5;\n\n    error ExchangeRateNotValid();\n\n    // ************** //\n    // *** EVENTS *** //\n    // ************** //\n    /// @notice event emitted when `leverageExecutor` is updated\n    event LeverageExecutorSet(address indexed oldVal, address indexed newVal);\n    /// @notice event emitted when `exchangeRate` validation duration is updated\n    event ExchangeRateDurationUpdated(uint256 _oldVal, uint256 _newVal);\n    /// @notice event emitted when conservator is updated\n    event ConservatorUpdated(address indexed old, address indexed _new);\n    /// @notice event emitted when pause state is changed\n    event PausedUpdated(PauseType indexed _type, bool indexed oldState, bool indexed newState);\n    /// @notice event emitted when cached exchange rate is updated\n    event LogExchangeRate(uint256 indexed rate);\n    /// @notice event emitted when borrow cap is updated\n    event LogBorrowCapUpdated(uint256 indexed _oldVal, uint256 indexed _newVal);\n    /// @notice event emitted when oracle data is updated\n    event OracleDataUpdated();\n    /// @notice event emitted when oracle is updated\n    event OracleUpdated(address newAddr);\n    /// @notice event emitted when a position is liquidated\n    event Liquidated(\n        address indexed liquidator,\n        address[] indexed users,\n        uint256 indexed liquidatorReward,\n        uint256 protocolReward,\n        uint256 repayedAmount,\n        uint256 collateralShareRemoved\n    );\n    /// @notice event emitted when the liquidation multiplier rate is updated\n    event LiquidationMultiplierUpdated(uint256 indexed oldVal, uint256 indexed newVal);\n    /// @notice event emitted on setMarketConfig updates\n    event ValueUpdated(uint256 indexed valType, uint256 indexed _newVal);\n\n    modifier optionNotPaused(PauseType _type) {\n        require(!pauseOptions[_type], \"Market: paused\");\n        _;\n    }\n\n    modifier notSelf(address destination) {\n        require(destination != address(this), \"Market: cannot execute on itself\");\n        _;\n    }\n\n    /// @dev Checks if the user is solvent in the closed liquidation case at the end of the function body.\n    modifier solvent(address from, bool liquidation) {\n        updateExchangeRate();\n        _accrue();\n\n        _;\n\n        require(_isSolvent(from, exchangeRate, liquidation), \"Market: insolvent\");\n    }\n\n    bool internal initialized;\n\n    modifier onlyOnce() {\n        require(!initialized, \"Market: initialized\");\n        _;\n        initialized = true;\n    }\n\n    // *********************** //\n    // *** OWNER FUNCTIONS *** //\n    // *********************** //\n    /// @notice updates `leverageExecutor`\n    /// @param _executor the new ILeverageExecutor\n    function setLeverageExecutor(ILeverageExecutor _executor) external onlyOwner {\n        emit LeverageExecutorSet(address(leverageExecutor), address(_executor));\n        leverageExecutor = _executor;\n    }\n\n    /// @notice sets common market configuration\n    /// @dev values are updated only if > 0 or not address(0)\n    /// @param _oracle oracle address\n    /// @param _oracleData oracle data\n    /// @param _conservator conservator address; conservator is allowed to pause/unpause the contract\n    /// @param _protocolFee protocol fee percentage\n    /// @param _liquidationBonusAmount extra amount factored in the closing factor computation\n    /// @param _minLiquidatorReward minimum reward percentage a liquidator can receive\n    /// @param _maxLiquidatorReward maximum reward percentage a liquidator can receive\n    /// @param _totalBorrowCap max amount that can be borrowed from the contract\n    /// @param _collateralizationRate the new collateralization rate value (75000 is 75%)\n    /// @param _liquidationCollateralizationRate the new liquidation collateralization rate value (75000 is 75%)\n    function setMarketConfig(\n        ITapiocaOracle _oracle,\n        bytes calldata _oracleData,\n        address _conservator,\n        uint256 _protocolFee,\n        uint256 _liquidationBonusAmount,\n        uint256 _minLiquidatorReward,\n        uint256 _maxLiquidatorReward,\n        uint256 _totalBorrowCap,\n        uint256 _collateralizationRate,\n        uint256 _liquidationCollateralizationRate\n    ) external onlyOwner {\n        if (address(_oracle) != address(0)) {\n            oracle = _oracle;\n            emit OracleUpdated(address(_oracle));\n        }\n\n        if (_oracleData.length > 0) {\n            oracleData = _oracleData;\n            emit OracleDataUpdated();\n        }\n\n        if (_conservator != address(0)) {\n            emit ConservatorUpdated(conservator, _conservator);\n            conservator = _conservator;\n        }\n\n        if (_protocolFee > 0) {\n            require(_protocolFee <= FEE_PRECISION, \"Market: not valid\");\n            protocolFee = _protocolFee;\n            emit ValueUpdated(2, _protocolFee);\n        }\n\n        if (_liquidationBonusAmount > 0) {\n            require(_liquidationBonusAmount < FEE_PRECISION, \"Market: not valid\");\n            liquidationBonusAmount = _liquidationBonusAmount;\n            emit ValueUpdated(3, _liquidationBonusAmount);\n        }\n\n        if (_minLiquidatorReward > 0) {\n            require(_minLiquidatorReward < FEE_PRECISION, \"Market: not valid\");\n            require(_minLiquidatorReward < maxLiquidatorReward, \"Market: not valid\");\n            minLiquidatorReward = _minLiquidatorReward;\n            emit ValueUpdated(4, _minLiquidatorReward);\n        }\n\n        if (_maxLiquidatorReward > 0) {\n            require(_maxLiquidatorReward < FEE_PRECISION, \"Market: not valid\");\n            require(_maxLiquidatorReward > minLiquidatorReward, \"Market: not valid\");\n            maxLiquidatorReward = _maxLiquidatorReward;\n            emit ValueUpdated(5, _maxLiquidatorReward);\n        }\n\n        if (_totalBorrowCap > 0) {\n            emit LogBorrowCapUpdated(totalBorrowCap, _totalBorrowCap);\n            totalBorrowCap = _totalBorrowCap;\n            emit ValueUpdated(6, _totalBorrowCap);\n        }\n\n        if (_collateralizationRate > 0) {\n            require(_collateralizationRate <= FEE_PRECISION, \"Market: not valid\");\n            require(_collateralizationRate <= liquidationCollateralizationRate, \"Market: collateralizationRate too big\");\n            require(\n                _collateralizationRate * (FEE_PRECISION + liquidationMultiplier) < FEE_PRECISION * FEE_PRECISION,\n                \"Market: CR * (1 + LM) >= 1\"\n            );\n            collateralizationRate = _collateralizationRate;\n            emit ValueUpdated(7, _collateralizationRate);\n        }\n\n        if (_liquidationCollateralizationRate > 0) {\n            require(\n                _liquidationCollateralizationRate >= collateralizationRate,\n                \"Market: liquidationCollateralizationRate too small\"\n            );\n            require(_liquidationCollateralizationRate <= FEE_PRECISION, \"Market: not valid\");\n            liquidationCollateralizationRate = _liquidationCollateralizationRate;\n            emit ValueUpdated(8, _liquidationCollateralizationRate);\n        }\n    }\n\n    // ********************** //\n    // *** VIEW FUNCTIONS *** //\n    // ********************** //\n    /// @notice returns the maximum liquidatable amount for user\n    /// @param borrowPart amount borrowed\n    /// @param collateralPartInAsset collateral's value in borrowed asset\n    /// @param ratesPrecision collateralizationRate and liquidationCollateralizationRate precision\n    function computeClosingFactor(uint256 borrowPart, uint256 collateralPartInAsset, uint256 ratesPrecision)\n        public\n        view\n        returns (uint256)\n    {\n        return _computeClosingFactor(\n            borrowPart,\n            collateralPartInAsset,\n            ratesPrecision,\n            liquidationCollateralizationRate,\n            liquidationMultiplier,\n            totalBorrow\n        );\n    }\n\n    function _computeClosingFactor(\n        uint256 borrowPart,\n        uint256 collateralPartInAsset,\n        uint256 ratesPrecision,\n        uint256 _liquidationCollateralizationRate,\n        uint256 _liquidationMultiplier,\n        Rebase memory _totalBorrow\n    ) internal view returns (uint256) {\n        // Obviously it's not `borrowPart` anymore but `borrowAmount`\n        borrowPart = (borrowPart * _totalBorrow.elastic) / _totalBorrow.base;\n\n        //borrowPart and collateralPartInAsset should already be scaled due to the exchange rate computation\n        uint256 liquidationStartsAt =\n            (collateralPartInAsset * _liquidationCollateralizationRate) / (10 ** ratesPrecision);\n\n        if (borrowPart < liquidationStartsAt) return 0;\n\n        //compute numerator\n        uint256 numerator = borrowPart - liquidationStartsAt;\n        //compute denominator\n        uint256 diff =\n            (collateralizationRate * ((10 ** ratesPrecision) + _liquidationMultiplier)) / (10 ** ratesPrecision);\n        int256 denominator = (int256(10 ** ratesPrecision) - int256(diff)) * int256(1e13);\n\n        //compute closing factor\n        int256 x = (int256(numerator) * int256(1e18)) / denominator;\n        int256 xPos = x < 0 ? -x : x;\n\n        //assure closing factor validity\n        if (uint256(xPos) > borrowPart) return borrowPart;\n\n        return uint256(xPos);\n    }\n\n    /// @notice return the amount of collateral for a `user` to be solvent, min TVL and max TVL. Returns 0 if user already solvent.\n    /// @dev we use a `CLOSED_COLLATERIZATION_RATE` that is a safety buffer when making the user solvent again,\n    ///      to prevent from being liquidated. This function is valid only if user is not solvent by `_isSolvent()`.\n    /// @param user The user to check solvency.\n    /// @param _exchangeRate the exchange rate asset/collateral.\n    /// @return amountToSolvency the amount of collateral to be solvent.\n    /// @return minTVL the asset value of the collateral amount factored by collateralizationRate\n    /// @return maxTVL the asset value of the collateral amount.\n    function computeTVLInfo(address user, uint256 _exchangeRate)\n        public\n        view\n        returns (uint256 amountToSolvency, uint256 minTVL, uint256 maxTVL)\n    {\n        uint256 borrowPart = userBorrowPart[user];\n        if (borrowPart == 0) return (0, 0, 0);\n\n        Rebase memory _totalBorrow = _accrueView();\n\n        uint256 collateralAmountInAsset = _computeMaxBorrowableAmount(user, _exchangeRate);\n\n        borrowPart = (borrowPart * _totalBorrow.elastic) / _totalBorrow.base;\n\n        unchecked {\n            amountToSolvency = borrowPart >= collateralAmountInAsset ? borrowPart - collateralAmountInAsset : 0;\n        }\n        (minTVL, maxTVL) = _computeMaxAndMinLTVInAsset(userCollateralShare[user], _exchangeRate);\n    }\n\n    /// @notice Gets the exchange rate. I.e how much collateral to buy 1e18 asset.\n    /// @dev This function is supposed to be invoked if needed because Oracle queries can be expensive.\n    ///      Oracle should consider USDO at 1$\n    /// @return updated True if `exchangeRate` was updated.\n    /// @return rate The new exchange rate.\n    function updateExchangeRate() public returns (bool updated, uint256 rate) {\n        (updated, rate) = oracle.get(oracleData);\n\n        if (updated) {\n            require(rate != 0, \"Market: invalid rate\");\n            exchangeRate = rate;\n            rateTimestamp = block.timestamp;\n            emit LogExchangeRate(rate);\n        } else {\n            require(rateTimestamp + rateValidDuration >= block.timestamp, \"Market: rate too old\");\n            // Return the old rate if fetching wasn't successful & rate isn't too old\n            rate = exchangeRate;\n        }\n    }\n\n    /// @notice computes the possible liquidator reward\n    /// @param user the user for which a liquidation operation should be performed\n    /// @param _exchangeRate the exchange rate asset/collateral to use for internal computations\n    function computeLiquidatorReward(address user, uint256 _exchangeRate) external view returns (uint256) {\n        return _getCallerReward(user, _exchangeRate);\n    }\n\n    // ************************** //\n    // *** INTERNAL FUNCTIONS *** //\n    // ************************** //\n    function _accrue() internal virtual;\n\n    function _accrueView() internal view virtual returns (Rebase memory);\n\n    /**\n     * @inheritdoc MarketERC20\n     */\n    function _allowedLend(address from, uint256 share) internal virtual override {\n        if (from != msg.sender) {\n            require(allowance[from][msg.sender] >= share, \"Market: not approved\");\n            if (allowance[from][msg.sender] != type(uint256).max) {\n                allowance[from][msg.sender] -= share;\n            }\n        }\n    }\n\n    /**\n     * @inheritdoc MarketERC20\n     */\n    function _allowedBorrow(address from, uint256 share) internal virtual override {\n        if (from != msg.sender) {\n            // TODO review risk of using this\n            (uint256 pearlmitAllowed,) = penrose.pearlmit().allowance(from, msg.sender, address(yieldBox), collateralId);\n            require(allowanceBorrow[from][msg.sender] >= share || pearlmitAllowed >= share, \"Market: not approved\");\n            if (allowanceBorrow[from][msg.sender] != type(uint256).max) {\n                allowanceBorrow[from][msg.sender] -= share;\n            }\n        }\n    }\n\n    function _updateOracleRateForLiquidations() internal {\n        try oracle.get(oracleData) returns (bool _updated, uint256 _exchangeRate) {\n            if (_updated && _exchangeRate > 0) {\n                exchangeRate = _exchangeRate; //update cached rate\n                rateTimestamp = block.timestamp;\n            } else {\n                _exchangeRate = exchangeRate; //use stored rate\n                if (_exchangeRate == 0) revert ExchangeRateNotValid();\n            }\n        } catch {\n            if (exchangeRate == 0) revert ExchangeRateNotValid();\n        }\n    }\n\n    function _getRevertMsg(bytes memory _returnData) internal pure returns (bytes memory) {\n        if (_returnData.length > 1000) return \"Market: reason too long\";\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (_returnData.length < 68) return \"Market: no return data\";\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Slice the sighash.\n            _returnData := add(_returnData, 0x04)\n        }\n        return _returnData; // All that remains is the revert string\n    }\n\n    function _computeMaxBorrowableAmount(address user, uint256 _exchangeRate)\n        internal\n        view\n        returns (uint256 collateralAmountInAsset)\n    {\n        require(_exchangeRate > 0, \"Market: exchangeRate not valid\");\n        uint256 userCollateralAmount = yieldBox.toAmount(collateralId, userCollateralShare[user], false);\n        collateralAmountInAsset =\n            (userCollateralAmount * (EXCHANGE_RATE_PRECISION / FEE_PRECISION) * collateralizationRate) / _exchangeRate;\n    }\n\n    /// @notice Concrete implementation of `isSolvent`. Includes a parameter to allow caching `exchangeRate`.\n    /// @param _exchangeRate The exchange rate. Used to cache the `exchangeRate` between calls.\n    function _isSolvent(address user, uint256 _exchangeRate, bool _liquidation) internal view returns (bool) {\n        // accrue must have already been called!\n        uint256 borrowPart = userBorrowPart[user];\n        if (borrowPart == 0) return true;\n        uint256 collateralShare = userCollateralShare[user];\n        if (collateralShare == 0) return false;\n\n        Rebase memory _totalBorrow = totalBorrow;\n\n        uint256 collateralAmount = yieldBox.toAmount(collateralId, collateralShare, false);\n        return collateralAmount * (EXCHANGE_RATE_PRECISION / FEE_PRECISION)\n            * (_liquidation ? liquidationCollateralizationRate : collateralizationRate)\n        // Moved exchangeRate here instead of dividing the other side to preserve more precision\n        >= (borrowPart * _totalBorrow.elastic * _exchangeRate) / _totalBorrow.base;\n    }\n\n    /// @notice Returns the min and max LTV for user in asset price\n    function _computeMaxAndMinLTVInAsset(uint256 collateralShare, uint256 _exchangeRate)\n        internal\n        view\n        returns (uint256 min, uint256 max)\n    {\n        require(_exchangeRate > 0, \"Market: exchangeRate not valid\");\n        uint256 collateralAmount = yieldBox.toAmount(collateralId, collateralShare, false);\n\n        max = (collateralAmount * EXCHANGE_RATE_PRECISION) / _exchangeRate;\n        min = (max * collateralizationRate) / FEE_PRECISION;\n    }\n\n    function _getCallerReward(address user, uint256 _exchangeRate) internal view returns (uint256) {\n        (uint256 startTVLInAsset, uint256 maxTVLInAsset) =\n            _computeMaxAndMinLTVInAsset(userCollateralShare[user], _exchangeRate);\n\n        uint256 borrowed = userBorrowPart[user];\n        if (borrowed == 0) return 0;\n        if (startTVLInAsset == 0) return 0;\n\n        borrowed = (borrowed * totalBorrow.elastic) / totalBorrow.base;\n\n        if (borrowed < startTVLInAsset) return 0;\n        if (borrowed >= maxTVLInAsset) return minLiquidatorReward;\n\n        uint256 rewardPercentage = ((borrowed - startTVLInAsset) * FEE_PRECISION) / (maxTVLInAsset - startTVLInAsset);\n\n        int256 diff = int256(minLiquidatorReward) - int256(maxLiquidatorReward);\n        int256 reward = (diff * int256(rewardPercentage)) / int256(FEE_PRECISION) + int256(maxLiquidatorReward);\n\n        if (reward < int256(minLiquidatorReward)) {\n            reward = int256(minLiquidatorReward);\n        }\n\n        return uint256(reward);\n    }\n\n    function _computeAllowanceAmountInAsset(\n        address user,\n        uint256 _exchangeRate,\n        uint256 borrowAmount,\n        uint256 assetDecimals\n    ) internal view returns (uint256) {\n        uint256 maxBorrowable = _computeMaxBorrowableAmount(user, _exchangeRate);\n\n        uint256 shareRatio = _getRatio(borrowAmount, maxBorrowable, assetDecimals);\n        return (shareRatio * userCollateralShare[user]) / (10 ** assetDecimals);\n    }\n\n    function _getRatio(uint256 numerator, uint256 denominator, uint256 precision) internal pure returns (uint256) {\n        if (numerator == 0 || denominator == 0) {\n            return 0;\n        }\n        uint256 _numerator = numerator * 10 ** (precision + 1);\n        uint256 _quotient = ((_numerator / denominator) + 5) / 10;\n        return (_quotient);\n    }\n}"
    },
    {
      "filename": "Tapioca-bar/contracts/markets/Market.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {RebaseLibrary, Rebase} from \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport {IERC20} from \"@boringcrypto/boring-solidity/contracts/ERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Tapioca\nimport {ILeverageExecutor} from \"tapioca-periph/interfaces/bar/ILeverageExecutor.sol\";\nimport {ITapiocaOracle} from \"tapioca-periph/interfaces/periph/ITapiocaOracle.sol\";\nimport {IYieldBox} from \"tapioca-periph/interfaces/yieldbox/IYieldBox.sol\";\nimport {IPearlmit} from \"tapioca-periph/interfaces/periph/IPearlmit.sol\";\nimport {IPenrose} from \"tapioca-periph/interfaces/bar/IPenrose.sol\";\nimport {MarketERC20} from \"./MarketERC20.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\nabstract contract Market is MarketERC20, Ownable {\n    using RebaseLibrary for Rebase;\n\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n    enum PauseType {\n        Borrow,\n        Repay,\n        AddCollateral,\n        RemoveCollateral,\n        Liquidation,\n        LeverageBuy,\n        LeverageSell,\n        AddAsset,\n        RemoveAsset\n    }\n\n    /// @notice pause options\n    mapping(PauseType pauseProp => bool pauseStatus) public pauseOptions;\n    /// @notice conservator's addresss\n    /// @dev conservator can pause/unpause the contract\n    address public conservator;\n\n    /// @notice returns YieldBox address\n    IYieldBox public yieldBox;\n    /// @notice returns Penrose address\n    IPenrose public penrose;\n\n    IPearlmit public pearlmit;\n\n    /// @notice collateral token address\n    IERC20 public collateral;\n    /// @notice collateral token YieldBox id\n    uint256 public collateralId;\n    /// @notice asset token address\n    IERC20 public asset;\n    /// @notice asset token YieldBox id\n    uint256 public assetId;\n    /// @notice oracle address\n    ITapiocaOracle public oracle;\n    /// @notice oracleData\n    bytes public oracleData;\n    /// @notice Exchange and interest rate tracking.\n    /// This is 'cached' here because calls to Oracles can be very expensive.\n    /// Asset -> collateral = assetAmount * exchangeRate.\n    uint256 public exchangeRate;\n    /// @notice cached rate is valid only for the `rateValidDuration` time\n    uint256 public rateValidDuration;\n    /// @notice latest timestamp when `exchangeRate` was updated\n    uint256 public rateTimestamp;\n\n    /// @notice total amount borrowed\n    /// @dev elastic = Total token amount to be repayed by borrowers, base = Total parts of the debt held by borrowers\n    Rebase public totalBorrow;\n    /// @notice total collateral supplied\n    uint256 public totalCollateralShare;\n    /// @notice max borrow cap\n    uint256 public totalBorrowCap;\n    /// @notice borrow amount per user\n    mapping(address => uint256) public userBorrowPart;\n    /// @notice collateral share per user\n    mapping(address => uint256) public userCollateralShare;\n\n    /// @notice accrual protocol rewards\n    uint256 public protocolFee; // 10%\n    /// @notice min % a liquidator can receive in rewards\n    uint256 public minLiquidatorReward = 8e4; //80%\n    /// @notice max % a liquidator can receive in rewards\n    uint256 public maxLiquidatorReward = 9e4; //90%\n    /// @notice max liquidatable bonus amount\n    /// @dev max % added to the amount that can be liquidated\n    uint256 public liquidationBonusAmount = 1e4; //10%\n    /// @notice collateralization rate\n    uint256 public collateralizationRate; // 75%\n    /// @notice liquidation collateralization rate\n    uint256 public liquidationCollateralizationRate; //80%\n    /// @notice liquidation multiplier used to compute liquidator rewards\n    uint256 public liquidationMultiplier = 12000; //12%\n    /// @notice returns the leverage executor\n    ILeverageExecutor public leverageExecutor;\n\n    // ***************** //\n    // *** CONSTANTS *** //\n    // ***************** //\n    uint256 internal EXCHANGE_RATE_PRECISION; //not costant, but can only be set in the 'init' method\n    uint256 internal constant FEE_PRECISION = 1e5;\n    uint256 internal constant FEE_PRECISION_DECIMALS = 5;\n\n    error ExchangeRateNotValid();\n\n    // ************** //\n    // *** EVENTS *** //\n    // ************** //\n    /// @notice event emitted when `leverageExecutor` is updated\n    event LeverageExecutorSet(address indexed oldVal, address indexed newVal);\n    /// @notice event emitted when `exchangeRate` validation duration is updated\n    event ExchangeRateDurationUpdated(uint256 _oldVal, uint256 _newVal);\n    /// @notice event emitted when conservator is updated\n    event ConservatorUpdated(address indexed old, address indexed _new);\n    /// @notice event emitted when pause state is changed\n    event PausedUpdated(PauseType indexed _type, bool indexed oldState, bool indexed newState);\n    /// @notice event emitted when cached exchange rate is updated\n    event LogExchangeRate(uint256 indexed rate);\n    /// @notice event emitted when borrow cap is updated\n    event LogBorrowCapUpdated(uint256 indexed _oldVal, uint256 indexed _newVal);\n    /// @notice event emitted when oracle data is updated\n    event OracleDataUpdated();\n    /// @notice event emitted when oracle is updated\n    event OracleUpdated(address newAddr);\n    /// @notice event emitted when a position is liquidated\n    event Liquidated(\n        address indexed liquidator,\n        address[] indexed users,\n        uint256 indexed liquidatorReward,\n        uint256 protocolReward,\n        uint256 repayedAmount,\n        uint256 collateralShareRemoved\n    );\n    /// @notice event emitted when the liquidation multiplier rate is updated\n    event LiquidationMultiplierUpdated(uint256 indexed oldVal, uint256 indexed newVal);\n    /// @notice event emitted on setMarketConfig updates\n    event ValueUpdated(uint256 indexed valType, uint256 indexed _newVal);\n\n    modifier optionNotPaused(PauseType _type) {\n        require(!pauseOptions[_type], \"Market: paused\");\n        _;\n    }\n\n    modifier notSelf(address destination) {\n        require(destination != address(this), \"Market: cannot execute on itself\");\n        _;\n    }\n\n    /// @dev Checks if the user is solvent in the closed liquidation case at the end of the function body.\n    modifier solvent(address from, bool liquidation) {\n        updateExchangeRate();\n        _accrue();\n\n        _;\n\n        require(_isSolvent(from, exchangeRate, liquidation), \"Market: insolvent\");\n    }\n\n    bool internal initialized;\n\n    modifier onlyOnce() {\n        require(!initialized, \"Market: initialized\");\n        _;\n        initialized = true;\n    }\n\n    // *********************** //\n    // *** OWNER FUNCTIONS *** //\n    // *********************** //\n    /// @notice updates `leverageExecutor`\n    /// @param _executor the new ILeverageExecutor\n    function setLeverageExecutor(ILeverageExecutor _executor) external onlyOwner {\n        emit LeverageExecutorSet(address(leverageExecutor), address(_executor));\n        leverageExecutor = _executor;\n    }\n\n    /// @notice sets common market configuration\n    /// @dev values are updated only if > 0 or not address(0)\n    /// @param _oracle oracle address\n    /// @param _oracleData oracle data\n    /// @param _conservator conservator address; conservator is allowed to pause/unpause the contract\n    /// @param _protocolFee protocol fee percentage\n    /// @param _liquidationBonusAmount extra amount factored in the closing factor computation\n    /// @param _minLiquidatorReward minimum reward percentage a liquidator can receive\n    /// @param _maxLiquidatorReward maximum reward percentage a liquidator can receive\n    /// @param _totalBorrowCap max amount that can be borrowed from the contract\n    /// @param _collateralizationRate the new collateralization rate value (75000 is 75%)\n    /// @param _liquidationCollateralizationRate the new liquidation collateralization rate value (75000 is 75%)\n    function setMarketConfig(\n        ITapiocaOracle _oracle,\n        bytes calldata _oracleData,\n        address _conservator,\n        uint256 _protocolFee,\n        uint256 _liquidationBonusAmount,\n        uint256 _minLiquidatorReward,\n        uint256 _maxLiquidatorReward,\n        uint256 _totalBorrowCap,\n        uint256 _collateralizationRate,\n        uint256 _liquidationCollateralizationRate\n    ) external onlyOwner {\n        if (address(_oracle) != address(0)) {\n            oracle = _oracle;\n            emit OracleUpdated(address(_oracle));\n        }\n\n        if (_oracleData.length > 0) {\n            oracleData = _oracleData;\n            emit OracleDataUpdated();\n        }\n\n        if (_conservator != address(0)) {\n            emit ConservatorUpdated(conservator, _conservator);\n            conservator = _conservator;\n        }\n\n        if (_protocolFee > 0) {\n            require(_protocolFee <= FEE_PRECISION, \"Market: not valid\");\n            protocolFee = _protocolFee;\n            emit ValueUpdated(2, _protocolFee);\n        }\n\n        if (_liquidationBonusAmount > 0) {\n            require(_liquidationBonusAmount < FEE_PRECISION, \"Market: not valid\");\n            liquidationBonusAmount = _liquidationBonusAmount;\n            emit ValueUpdated(3, _liquidationBonusAmount);\n        }\n\n        if (_minLiquidatorReward > 0) {\n            require(_minLiquidatorReward < FEE_PRECISION, \"Market: not valid\");\n            require(_minLiquidatorReward < maxLiquidatorReward, \"Market: not valid\");\n            minLiquidatorReward = _minLiquidatorReward;\n            emit ValueUpdated(4, _minLiquidatorReward);\n        }\n\n        if (_maxLiquidatorReward > 0) {\n            re"
    }
  ]
}