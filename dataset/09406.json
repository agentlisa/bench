{
  "Title": "[L-03] Unused `receive()` function will lock Ether in contract",
  "Content": "\nIf the intention is for the Ether to be used, the function should call another function, otherwise it should revert\n\n```solidity\nFile: contracts/actions/topup/TopUpAction.sol   #1\n\n176     receive() external payable {\n177         // solhint-disable-previous-line no-empty-blocks\n178     }\n```\n\n<https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/actions/topup/TopUpAction.sol#L176-L178>\n\n```solidity\nFile: contracts/pool/EthPool.sol   #2\n\n10     receive() external payable {}\n```\n\n<https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/pool/EthPool.sol#L10>\n\n```solidity\nFile: contracts/strategies/BkdEthCvx.sol   #3\n\n46     receive() external payable {}\n```\n\n<https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/strategies/BkdEthCvx.sol#L46>\n\n```solidity\nFile: contracts/strategies/StrategySwapper.sol   #4\n\n45     receive() external payable {}\n```\n\n<https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/strategies/StrategySwapper.sol#L45>\n\n```solidity\nFile: contracts/vault/EthVault.sol   #5\n\n13     receive() external payable {}\n```\n\n<https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/vault/EthVault.sol#L13>\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2022-04-backd-contest",
  "Code": [
    {
      "filename": "backd/contracts/actions/topup/TopUpAction.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport \"../../../interfaces/IGasBank.sol\";\nimport \"../../../interfaces/pool/ILiquidityPool.sol\";\nimport \"../../../interfaces/ISwapperRegistry.sol\";\nimport \"../../../interfaces/IController.sol\";\nimport \"../../../interfaces/IStakerVault.sol\";\nimport \"../../../interfaces/ISwapper.sol\";\nimport \"../../../interfaces/actions/topup/ITopUpHandler.sol\";\nimport \"../../../interfaces/actions/topup/ITopUpAction.sol\";\nimport \"../../../interfaces/actions/IActionFeeHandler.sol\";\n\nimport \"../../../libraries/AddressProviderHelpers.sol\";\nimport \"../../../libraries/Errors.sol\";\nimport \"../../../libraries/ScaledMath.sol\";\nimport \"../../../libraries/EnumerableExtensions.sol\";\n\nimport \"../../access/Authorization.sol\";\nimport \"../../utils/Preparable.sol\";\n\n/**\n * @notice The logic here should really be part of the top-up action\n * but is split in a library to circumvent the byte-code size limit\n */\nlibrary TopUpActionLibrary {\n    using SafeERC20 for IERC20;\n    using ScaledMath for uint256;\n    using AddressProviderHelpers for IAddressProvider;\n\n    function lockFunds(\n        address stakerVaultAddress,\n        address payer,\n        address token,\n        uint256 lockAmount,\n        uint256 depositAmount\n    ) external {\n        uint256 amountLeft = lockAmount;\n        IStakerVault stakerVault = IStakerVault(stakerVaultAddress);\n\n        // stake deposit amount\n        if (depositAmount > 0) {\n            depositAmount = depositAmount > amountLeft ? amountLeft : depositAmount;\n            IERC20(token).safeTransferFrom(payer, address(this), depositAmount);\n            IERC20(token).safeApprove(stakerVaultAddress, depositAmount);\n            stakerVault.stake(depositAmount);\n            stakerVault.increaseActionLockedBalance(payer, depositAmount);\n            amountLeft -= depositAmount;\n        }\n\n        // use stake vault allowance if available and required\n        if (amountLeft > 0) {\n            uint256 balance = stakerVault.balanceOf(payer);\n            uint256 allowance = stakerVault.allowance(payer, address(this));\n            uint256 availableFunds = balance < allowance ? balance : allowance;\n            if (availableFunds >= amountLeft) {\n                stakerVault.transferFrom(payer, address(this), amountLeft);\n                amountLeft = 0;\n            }\n        }\n\n        require(amountLeft == 0, Error.INSUFFICIENT_UPDATE_BALANCE);\n    }\n\n    /**\n     * @dev Computes and returns the amount of LP tokens of type `token` that will be received in exchange for an `amount` of the underlying.\n     */\n    function calcExchangeAmount(\n        IAddressProvider addressProvider,\n        address token,\n        address actionToken,\n        uint256 amount\n    ) external view returns (uint256) {\n        ILiquidityPool pool = addressProvider.getPoolForToken(token);\n        uint256 rate = pool.exchangeRate();\n        address underlying = pool.getUnderlying();\n        if (underlying == actionToken) {\n            return amount.scaledDivRoundUp(rate);\n        }\n\n        ISwapper swapper = getSwapper(addressProvider, underlying, actionToken);\n        uint256 swapperRate = swapper.getRate(underlying, actionToken);\n        return amount.scaledDivRoundUp(rate.scaledMul(swapperRate));\n    }\n\n    function getSwapper(\n        IAddressProvider addressProvider,\n        address underlying,\n        address actionToken\n    ) public view returns (ISwapper) {\n        address swapperRegistry = addressProvider.getSwapperRegistry();\n        address swapper = ISwapperRegistry(swapperRegistry).getSwapper(underlying, actionToken);\n        require(swapper != address(0), Error.SWAP_PATH_NOT_FOUND);\n        return ISwapper(swapper);\n    }\n}\n\ncontract TopUpAction is ITopUpAction, Authorization, Preparable, Initializable {\n    using ScaledMath for uint256;\n    using ScaledMath for uint128;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using EnumerableExtensions for EnumerableSet.AddressSet;\n    using AddressProviderHelpers for IAddressProvider;\n\n    /**\n     * @dev Temporary struct to hold local variables in execute\n     * and avoid the stack being \"too deep\"\n     */\n    struct ExecuteLocalVars {\n        uint256 minActionAmountToTopUp;\n        uint256 actionTokenAmount;\n        uint256 depositTotalFeesAmount;\n        uint256 actionAmountWithFees;\n        uint256 userFactor;\n        uint256 rate;\n        uint256 depositAmountWithFees;\n        uint256 depositAmountWithoutFees;\n        uint256 actionFee;\n        uint256 totalActionTokenAmount;\n        uint128 totalTopUpAmount;\n        bool success;\n        bytes topupResult;\n        uint256 gasBankBalance;\n        uint256 initialGas;\n        uint256 gasConsumed;\n        uint256 userGasPrice;\n        uint256 estimatedRequiredGas;\n        uint256 estimatedRequiredWeiForGas;\n        uint256 requiredWeiForGas;\n        uint256 reimbursedWeiForGas;\n        address underlying;\n        bool removePosition;\n    }\n\n    EnumerableSet.AddressSet private _usableTokens;\n\n    uint256 internal constant _INITIAL_ESTIMATED_GAS_USAGE = 500_000;\n\n    bytes32 internal constant _ACTION_FEE_KEY = \"ActionFee\";\n    bytes32 internal constant _FEE_HANDLER_KEY = \"FeeHandler\";\n    bytes32 internal constant _TOP_UP_HANDLER_KEY = \"TopUpHandler\";\n    bytes32 internal constant _ESTIMATED_GAS_USAGE_KEY = \"EstimatedGasUsage\";\n    bytes32 internal constant _MAX_SWAPPER_SLIPPAGE_KEY = \"MaxSwapperSlippage\";\n\n    uint256 internal constant _MAX_ACTION_FEE = 0.5 * 1e18;\n    uint256 internal constant _MIN_SWAPPER_SLIPPAGE = 0.6 * 1e18;\n    uint256 internal constant _MAX_SWAPPER_SLIPPAGE = 0.95 * 1e18;\n\n    IController public immutable controller;\n    IAddressProvider public immutable addressProvider;\n\n    EnumerableSet.Bytes32Set internal _supportedProtocols;\n\n    /// @notice mapping of (payer -> account -> protocol -> Record)\n    mapping(address => mapping(bytes32 => mapping(bytes32 => Record))) private _positions;\n\n    mapping(address => RecordMeta[]) internal _userPositions;\n\n    EnumerableSet.AddressSet internal _usersWithPositions;\n\n    constructor(IController _controller)\n        Authorization(_controller.addressProvider().getRoleManager())\n    {\n        controller = _controller;\n        addressProvider = controller.addressProvider();\n        _setConfig(_ESTIMATED_GAS_USAGE_KEY, _INITIAL_ESTIMATED_GAS_USAGE);\n    }\n\n    receive() external payable {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    function initialize(\n        address feeHandler,\n        bytes32[] calldata protocols,\n        address[] calldata handlers\n    ) external initializer onlyGovernance {\n        require(protocols.length == handlers.length, Error.INVALID_ARGUMENT);\n        _setConfig(_FEE_HANDLER_KEY, feeHandler);\n        _setConfig(_MAX_SWAPPER_SLIPPAGE_KEY, _MAX_SWAPPER_SLIPPAGE);\n        for (uint256 i = 0; i < protocols.length; i++) {\n            bytes32 protocolKey = _getProtocolKey(protocols[i]);\n            _setConfig(protocolKey, handlers[i]);\n            _updateTopUpHandler(protocols[i], address(0), handlers[i]);\n        }\n    }\n\n    /**\n     * @notice Register a top up action.\n     * @dev The `depositAmount` must be greater or equal to the `totalTopUpAmount` (which is denominated in `actionToken`).\n     * @param account Account to be topped up (first 20 bytes will typically be the address).\n     * @param depositAmount Amount of `depositToken` that will be locked.\n     * @param protocol Protocol which holds position to be topped up.\n     * @param record containing the data for the position to register\n     */\n    function register(\n        bytes32 account,\n        bytes32 protocol,\n        uint128 depositAmount,\n        Record memory record\n    ) external payable returns (bool) {\n        require(_supportedProtocols.contains(protocol), Error.PROTOCOL_NOT_FOUND);\n        require(record.singleTopUpAmount > 0, Error.INVALID_AMOUNT);\n        require(record.threshold > ScaledMath.ONE, Error.INVALID_AMOUNT);\n        require(record.singleTopUpAmount <= record.totalTopUpAmount, Error.INVALID_AMOUNT);\n        require(\n            _positions[msg.sender][account][protocol].threshold == 0,\n            Error.POSITION_ALREADY_EXISTS\n        );\n        require(_isSwappable(record.depositToken, record.actionToken), Error.SWAP_PATH_NOT_FOUND);\n        require(isUsable(record.depositToken), Error.TOKEN_NOT_USABLE);\n\n        uint256 gasDeposit = (record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount)) *\n            record.maxFee *\n            getEstimatedGasUsage();\n\n        require(msg.value >= gasDeposit, Error.VALUE_TOO_LOW_FOR_GAS);\n\n        uint256 totalLockAmount = _calcExchangeAmount(\n            record.depositToken,\n            record.actionToken,\n            record.totalTopUpAmount\n        );\n        _lockFunds(msg.sender, record.depositToken, totalLockAmount, depositAmount);\n\n        addressProvider.getGasBank().depositFor{value: msg.value}(msg.sender);\n\n        record.depositTokenBalance = uint128(totalLockAmount);\n        _positions[msg.sender][account][protocol] = record;\n        _userPositions[msg.sender].push(RecordMeta(account, protocol));\n        _usersWithPositions.add(msg.sender);\n\n        emit Register(\n            account,\n            protocol,\n            record.threshold,\n            msg.sender,\n            record.depositToken,\n            totalLockAmount,\n            record.actionToken,\n            record.singleTopUpAmount,\n            record.totalTopUpAmount,\n            record.maxFee,\n            record.extra\n        );\n        return true;\n    }\n\n    /**\n     * @notice See overloaded version of `execute` for more details.\n     */\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol\n    ) external override returns (bool) {\n        return execute(payer, account, beneficiary, protocol, 0);\n    }\n\n    /**\n     * @notice Delete a position to back on the given protocol for `account`.\n     * @param account Account holding the position.\n     * @param protocol Protocol the position is held on.\n     * @param unstake If the tokens should be unstaked from vault.\n     * @return `true` if successful.\n     */\n    function resetPosition(\n        bytes32 account,\n        bytes32 protocol,\n        bool unstake\n    ) external override returns (bool) {\n        address payer = msg.sender;\n        Record memory position = _positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n\n        address vault = addressProvider.getStakerVault(position.depositToken); // will revert if vault does not exist\n        IStakerVault staker = IStakerVault(vault);\n        staker.decreaseActionLockedBalance(payer, position.depositTokenBalance);\n        if (unstake) {\n            staker.unstake(position.depositTokenBalance);\n            IERC20(position.depositToken).safeTransfer(payer, position.depositTokenBalance);\n        } else {\n            staker.transfer(payer, position.depositTokenBalance);\n        }\n\n        _removePosition(payer, account, protocol);\n        addressProvider.getGasBank().withdrawUnused(payer);\n        return true;\n    }\n\n    /**\n     * @notice Execute top up handler update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @param protocol Protocol for which a new handler should be executed.\n     * @return Address of new handler.\n     */\n    function executeTopUpHandler(bytes32 protocol) external override returns (address) {\n        address oldHandler = _getHandler(protocol, false);\n        address newHandler = _executeAddress(_getProtocolKey(protocol));\n\n        _updateTopUpHandler(protocol, oldHandler, newHandler);\n        return newHandler;\n    }\n\n    /**\n     * @notice Reset new top up handler deadline for a protocol.\n     * @param protocol Protocol for which top up handler deadline should be reset.\n     * @return `true` if successful.\n     */\n    function resetTopUpHandler(bytes32 protocol) external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_getProtocolKey(protocol));\n    }\n\n    /**\n     * @notice Prepare action fee update.\n     * @param newActionFee New fee to set.\n     * @return `true` if success.\n     */\n    function prepareActionFee(uint256 newActionFee) external onlyGovernance returns (bool) {\n        require(newActionFee <= _MAX_ACTION_FEE, Error.INVALID_AMOUNT);\n        return _prepare(_ACTION_FEE_KEY, newActionFee);\n    }\n\n    /**\n     * @notice Execute action fee update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return `true` if successful.\n     */\n    function executeActionFee() external override returns (uint256) {\n        return _executeUInt256(_ACTION_FEE_KEY);\n    }\n\n    /**\n     * @notice Reset action fee deadline.\n     * @return `true` if successful.\n     */\n    function resetActionFee() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ACTION_FEE_KEY);\n    }\n\n    /**\n     * @notice Prepare swapper slippage update.\n     * @param newSwapperSlippage New slippage to set.\n     * @return `true` if success.\n     */\n    function prepareSwapperSlippage(uint256 newSwapperSlippage)\n        external\n        onlyGovernance\n        returns (bool)\n    {\n        require(\n            newSwapperSlippage >= _MIN_SWAPPER_SLIPPAGE &&\n                newSwapperSlippage <= _MAX_SWAPPER_SLIPPAGE,\n            Error.INVALID_AMOUNT\n        );\n        return _prepare(_MAX_SWAPPER_SLIPPAGE_KEY, newSwapperSlippage);\n    }\n\n    /**\n     * @notice Execute swapper slippage update (with time delay enforced).\n     * @dev Needs to be called after the update was prepared. Fails if called before time delay is met.\n     * @return `true` if successful.\n     */\n    function executeSwapperSlippage() external override returns (uint256) {\n        return _executeUInt256(_MAX_SWAPPER_SLIPPAGE_KEY);\n    }\n\n    /**\n     * @notice Reset action fee deadline.\n     * @return `true` if successful.\n     */\n    function resetSwapperSlippage() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_MAX_SWAPPER_SLIPPAGE_KEY);\n    }\n\n    /** Set fee handler */\n    /**\n     * @notice Prepare update of fee handler.\n     * @param handler New fee handler.\n     * @return `true` if success.\n     */\n    function prepareFeeHandler(address handler) external onlyGovernance returns (bool) {\n        return _prepare(_FEE_HANDLER_KEY, handler);\n    }\n\n    /**\n     * @notice Execute update of fee handler (with time delay enforced).\n     * @dev Needs to be called after the update was prepraed. Fails if called before time delay is met.\n     * @return `true` if successful.\n     */\n    function executeFeeHandler() external override returns (address) {\n        return _executeAddress(_FEE_HANDLER_KEY);\n    }\n\n    /**\n     * @notice Reset the handler deadline.\n     * @return `true` if success.\n     */\n    function resetFeeHandler() external onlyGovernance returns (bool) {\n        return _resetAddressConfig(_FEE_HANDLER_KEY);\n    }\n\n    /**\n     * @notice Prepare update of estimated gas usage.\n     * @param gasUsage New estimated gas usage.\n     * @return `true` if success.\n     */\n    function prepareEstimatedGasUsage(uint256 gasUsage) external onlyGovernance returns (bool) {\n        return _prepare(_ESTIMATED_GAS_USAGE_KEY, gasUsage);\n    }\n\n    /**\n     * @notice Execute update of gas usage (with time delay enforced).\n     * @return `true` if successful.\n     */\n    function executeEstimatedGasUsage() external returns (uint256) {\n        return _executeUInt256(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /**\n     * @notice Reset the gas usage deadline.\n     * @return `true` if success.\n     */\n    function resetGasUsage() external onlyGovernance returns (bool) {\n        return _resetUInt256Config(_ESTIMATED_GAS_USAGE_KEY);\n    }\n\n    /**\n     * @notice Add a new deposit token that is supported by the action.\n     * @dev There is a separate check for whether the usable token (i.e. deposit token)\n     *      is swappable for some action token.\n     * @param token Address of deposit token that can be used by the action.\n     */\n    function addUsableToken(address token) external override onlyGovernance returns (bool) {\n        return _usableTokens.add(token);\n    }\n\n    /**\n     * @notice Computes the total amount of ETH (as wei) required to pay for all\n     * the top-ups assuming the maximum gas price and the current estimated gas\n     * usage of a top-up\n     */\n    function getEthRequiredForGas(address payer) external view override returns (uint256) {\n        uint256 totalEthRequired = 0;\n        RecordMeta[] memory userRecordsMeta = _userPositions[payer];\n        uint256 gasUsagePerCall = getEstimatedGasUsage();\n        uint256 length = userRecordsMeta.length;\n        for (uint256 i = 0; i < length; i++) {\n            RecordMeta memory meta = userRecordsMeta[i];\n            Record memory record = _positions[payer][meta.account][meta.protocol];\n            uint256 totalCalls = record.totalTopUpAmount.divRoundUp(record.singleTopUpAmount);\n            totalEthRequired += totalCalls * gasUsagePerCall * record.maxFee;\n        }\n        return totalEthRequired;\n    }\n\n    /**\n     * @notice Returns a list of positions for the given payer\n     */\n    function getUserPositions(address payer) external view override returns (RecordMeta[] memory) {\n        return _userPositions[payer];\n    }\n\n    /**\n     * @notice Get a list supported protocols.\n     * @return List of supported protocols.\n     */\n    function getSupportedProtocols() external view override returns (bytes32[] memory) {\n        uint256 length = _supportedProtocols.length();\n        bytes32[] memory protocols = new bytes32[](length);\n        for (uint256 i = 0; i < length; i++) {\n            protocols[i] = _supportedProtocols.at(i);\n        }\n        return protocols;\n    }\n\n    /*\n     * @notice Gets a list of users that have an active position.\n     * @dev Uses cursor pagination.\n     * @param cursor The cursor for pagination (should start at 0 for first call).\n     * @param howMany Maximum number of users to return in this pagination request.\n     * @return users List of users that have an active position.\n     * @return nextCursor The cursor to use for the next pagination request.\n     */\n    function usersWithPositions(uint256 cursor, uint256 howMany)\n        external\n        view\n        override\n        returns (address[] memory users, uint256 nextCursor)\n    {\n        uint256 length = _usersWithPositions.length();\n        if (cursor >= length) return (new address[](0), 0);\n        if (howMany >= length - cursor) {\n            howMany = length - cursor;\n        }\n\n        address[] memory usersWithPositions_ = new address[](howMany);\n        for (uint256 i = 0; i < howMany; i++) {\n            usersWithPositions_[i] = _usersWithPositions.at(i + cursor);\n        }\n\n        return (usersWithPositions_, cursor + howMany);\n    }\n\n    /**\n     * @notice Get a list of all tokens usable for this action.\n     * @dev This refers to all tokens that can be used as deposit tokens.\n     * @return Array of addresses of usable tokens.\n     */\n    function getUsableTokens() external view override returns (address[] memory) {\n        return _usableTokens.toArray();\n    }\n\n    /**\n     * @notice Retrieves the topup handler for the given `protocol`\n     */\n    function getTopUpHandler(bytes32 protocol) external view returns (address) {\n        return _getHandler(protocol, false);\n    }\n\n    /**\n     * @notice Successfully tops up a position if it's conditions are met.\n     * @dev pool and vault funds are rebalanced after withdrawal for top up\n     * @param payer Account that pays for the top up.\n     * @param account Account owning the position for top up.\n     * @param beneficiary Address of the keeper's wallet for fee accrual.\n     * @param protocol Protocol of the top up position.\n     * @param maxWeiForGas the maximum extra amount of wei that the keeper is willing to pay for the gas\n     * @return `true` if successful.\n     */\n    function execute(\n        address payer,\n        bytes32 account,\n        address beneficiary,\n        bytes32 protocol,\n        uint256 maxWeiForGas\n    ) public override returns (bool) {\n        require(controller.canKeeperExecuteAction(msg.sender), Error.NOT_ENOUGH_BKD_STAKED);\n\n        ExecuteLocalVars memory vars;\n\n        vars.initialGas = gasleft();\n\n        Record storage position = _positions[payer][account][protocol];\n        require(position.threshold != 0, Error.NO_POSITION_EXISTS);\n        require(position.totalTopUpAmount > 0, Error.INSUFFICIENT_BALANCE);\n\n        address topUpHandler = _getHandler(protocol, true);\n        vars.userFactor = ITopUpHandler(topUpHandler).getUserFactor(account, position.extra);\n\n        // ensure that the position is actually below its set user factor threshold\n        require(vars.userFactor < position.threshold, Error.INSUFFICIENT_THRESHOLD);\n\n        IGasBank gasBank = addressProvider.getGasBank();\n\n        // fail early if the user does not have enough funds in the gas bank\n        // to cover the cost of the transaction\n        vars.estimatedRequiredGas = getEstimatedGasUsage();\n        vars.estimatedRequiredWeiForGas = vars.estimatedRequiredGas * tx.gasprice;\n\n        // compute the gas price that the user will be paying\n        vars.userGasPrice = block.basefee + position.priorityFee;\n        if (vars.userGasPrice > tx.gasprice) vars.userGasPrice = tx.gasprice;\n        if (vars.userGasPrice > position.maxFee) vars.userGasPrice = position.maxFee;\n\n        // ensure the current position allows for the gas to be paid\n        require(\n            vars.estimatedRequiredWeiForGas <=\n                vars.estimatedRequiredGas * vars.userGasPrice + maxWeiForGas,\n            Error.ESTIMATED_GAS_TOO_HIGH\n        );\n\n        vars.gasBankBalance = gasBank.balanceOf(payer);\n        // ensure the user has enough funds in the gas bank to cover the gas\n        require(\n            vars.gasBankBalance + maxWeiForGas >= vars.estimatedRequiredWeiForGas,\n            Error.GAS_BANK_BALANCE_TOO_LOW\n        );\n\n        vars.totalTopUpAmount = position.totalTopUpAmount;\n        vars.actionFee = getActionFee();\n        // add top-up fees to top-up amount\n        vars.minActionAmountToTopUp = position.singleTopUpAmount;\n        vars.actionAmountWithFees = vars.minActionAmountToTopUp.scaledMul(\n            ScaledMath.ONE + vars.actionFee\n        );\n\n        // if the amount that we want to top-up (including fees) is higher than\n        // the available topup amount, we lower this down to what is left of the position\n        if (vars.actionAmountWithFees > vars.totalTopUpAmount) {\n            vars.actionAmountWithFees = vars.totalTopUpAmount;\n            vars.minActionAmountToTopUp = vars.actionAmountWithFees.scaledDiv(\n                ScaledMath.ONE + vars.actionFee\n            );\n        }\n        ILiquidityPool pool = addressProvider.getPoolForToken(position.depositToken);\n        vars.underlying = pool.getUnderlying();\n        vars.rate = pool.exchangeRate();\n\n        ISwapper swapper;\n\n        if (vars.underlying != position.actionToken) {\n            swapper = _getSwapper(vars.underlying, position.actionToken);\n            vars.rate = vars.rate.scaledMul(swapper.getRate(vars.underlying, position.actionToken));\n        }\n\n        // compute the deposit tokens amount with and without fees\n        // we will need to unstake the amount with fees and to\n        // swap the amount without fees into action tokens\n        vars.depositAmountWithFees = vars.actionAmountWithFees.scaledDivRoundUp(vars.rate);\n        if (position.depositTokenBalance < vars.depositAmountWithFees) {\n            vars.depositAmountWithFees = position.depositTokenBalance;\n            vars.minActionAmountToTopUp =\n                (vars.depositAmountWithFees * vars.rate) /\n                (ScaledMath.ONE + vars.actionFee);\n        }\n\n        // compute amount of LP tokens needed to pay for action\n        // rate is expressed in actionToken per depositToken\n        vars.depositAmountWithoutFees = vars.minActionAmountToTopUp.scaledDivRoundUp(vars.rate);\n        vars.depositTotalFeesAmount = vars.depositAmountWithFees - vars.depositAmountWithoutFees;\n\n        // will revert if vault does not exist\n        address vault = addressProvider.getStakerVault(position.depositToken);\n\n        // unstake deposit tokens including fees\n        IStakerVault(vault).unstake(vars.depositAmountWithFees);\n        IStakerVault(vault).decreaseActionLockedBalance(payer, vars.depositAmountWithFees);\n\n        // swap the amount without the fees\n        // as the fees are paid in deposit token, not in action token\n        // Redeem first and use swapper only if the underlying tokens are not action tokens\n        vars.actionTokenAmount = pool.redeem(vars.depositAmountWithoutFees);\n\n        if (address(swapper) != address(0)) {\n            vars.minActionAmountToTopUp = vars.minActionAmountToTopUp.scaledMul(\n                getSwapperSlippage()\n            );\n            _approve(vars.underlying, address(swapper));\n            vars.actionTokenAmount = swapper.swap(\n                vars.underlying,\n                position.actionToken,\n                vars.actionTokenAmount,\n                vars.minActionAmountToTopUp\n            );\n        }\n\n        // compute how much of action token was actually redeemed and add fees to it\n        // this is to ensure that no funds get locked inside the contract\n        vars.totalActionTokenAmount =\n            vars.actionTokenAmount +\n            vars.depositTotalFeesAmount.scaledMul(vars.rate);\n\n        // at this point, we have exactly `vars.actionTokenAmount`\n        // (at least `position.singleTopUpAmount`) of action token\n        // and exactly `vars.depositTotalFeesAmount` deposit tokens in the contract\n        // solhint-disable-next-line avoid-low-level-calls\n        (vars.success, vars.topupResult) = topUpHandler.delegatecall(\n            abi.encodeWithSignature(\n                \"topUp(bytes32,address,uint256,bytes)\",\n                account,\n                position.actionToken,\n                vars.actionTokenAmount,\n                position.extra\n            )\n        );\n\n        require(vars.success && abi.decode(vars.topupResult, (bool)), Error.TOP_UP_FAILED);\n\n        // totalTopUpAmount is updated to reflect the new \"balance\" of the position\n        if (vars.totalTopUpAmount > vars.totalActionTokenAmount) {\n            position.totalTopUpAmount -= uint128(vars.totalActionTokenAmount);\n        } else {\n            position.totalTopUpAmount = 0;\n        }\n\n        position.depositTokenBalance -= uint128(vars.depositAmountWithFees);\n\n        vars.removePosition = position.totalTopUpAmount == 0 || position.depositTokenBalance == 0;\n        _payFees(payer, beneficiary, vars.depositTotalFeesAmount, position.depositToken);\n        if (vars.removePosition) {\n            if (position.depositTokenBalance > 0) {\n                // transfer any unused locked tokens to the payer\n                IStakerVault(vault).transfer(payer, position.depositTokenBalance);\n                IStakerVault(vault).decreaseActionLockedBalance(\n                    payer,\n                    position.depositTokenBalance\n                );\n            }\n            _removePosition(payer, account, protocol);\n        }\n\n        emit TopUp(\n            account,\n            protocol,\n            payer,\n            position.depositToken,\n            vars.depositAmountWithFees,\n            position.actionToken,\n            vars.actionTokenAmount\n        );\n\n        // compute gas used and reimburse the keeper by using the\n        // funds of payer in the gas bank\n        // TODO: add constant gas consumed for transfer and tx prologue\n        vars.gasConsumed = vars.initialGas - gasleft();\n\n        vars.reimbursedWeiForGas = vars.userGasPrice * vars.gasConsumed;\n        if (vars.reimbursedWeiForGas > vars.gasBankBalance) {\n            vars.reimbursedWeiForGas = vars.gasBankBalance;\n        }\n\n        // ensure that the keeper is not overpaying\n        vars.requiredWeiForGas = tx.gasprice * vars.gasConsumed;\n        require(\n            vars.reimbursedWeiForGas + maxWeiForGas >= vars.requiredWeiForGas,\n            Error.GAS_TOO_HIGH\n        );\n        gasBank.withdrawFrom(payer, payable(msg.sender), vars.reimbursedWeiForGas);\n        if (vars.removePosition) {\n            gasBank.withdrawUnused(payer);\n        }\n\n        return true;\n    }\n\n    /**\n     * @notice Prepare new top up handler fee update.\n     * @dev Setting the addres to 0 means that the protocol will no longer be supported.\n     * @param protocol Protocol for which a new handler should be prepared.\n     * @param newHandler Address of new handler.\n     * @return `true` if success.\n     */\n    function prepareTopUpHandler(bytes32 protocol, address newHandler)\n        public\n        onlyGovernance\n        returns (bool)\n    {\n        return _prepare(_getProtocolKey(protocol), newHandler);\n    }\n\n    /**\n     * @notice Check if action can be executed.\n     * @param protocol for which to get the health factor\n     * @param account for which to get the health factor\n     * @param extra data to be used by the topup handler\n     * @return healthFactor of the position\n     */\n    function getHealthFactor(\n        bytes32 protocol,\n        bytes32 account,\n        bytes memory extra\n    ) public view override returns (uint256 healthFactor) {\n        ITopUpHandler topUpHandler = ITopUpHandler(_getHandler(protocol, true));\n        return topUpHandler.getUserFactor(account, extra);\n    }\n\n    function getHandler(bytes32 protocol) public view override returns (address) {\n        return _getHandler(protocol, false);\n    }\n\n    /**\n     * @notice returns the current estimated gas usage\n     */\n    function getEstimatedGasUsage() public view returns (uint256) {\n        return currentUInts256[_ESTIMATED_GAS_USAGE_KEY];\n    }\n\n    /**\n     * @notice Returns the current action fee\n     */\n    function getActionFee() public view override returns (uint256) {\n        return currentUInts256[_ACTION_FEE_KEY];\n    }\n\n    /**\n     * @notice Returns the current max swapper slippage\n     */\n    function getSwapperSlippage() public view override returns (uint256) {\n        return currentUInts256[_MAX_SWAPPER_SLIPPAGE_KEY];\n    }\n\n    /**\n     * @notice Returns the current fee handler\n     */\n    function getFeeHandler() public view override returns (address) {\n        return currentAddresses[_FEE_HANDLER_KEY];\n    }\n\n    /**\n     * @notice Get the record for a position.\n     * @param payer Registered payer of the position.\n     * @param account Address holding the position.\n     * @param protocol Protocol where the position is held.\n     */\n    function getPosition(\n        address payer,\n        bytes32 account,\n        bytes32 protocol\n    ) public view override returns (Record memory) {\n        return _positions[payer][account][protocol];\n    }\n\n    /**\n     * @notice Check whether a token is usable as a deposit token.\n     * @param token Address of token to check.\n     * @return True if token is usable as a deposit token for this action.\n     */\n    function isUsable(address token) public view override returns (bool) {\n        return _usableTokens.contains(token);\n    }\n\n    function _updateTopUpHandler(\n        bytes32 protocol,\n        address oldHandler,\n        address newHandler\n    ) internal {\n        if (newHandler == address(0)) {\n            _supportedProtocols.remove(protocol);\n        } else if (oldHandler == address(0)) {\n            _supportedProtocols.add(protocol);\n        }\n    }\n\n    /**\n     * @dev Pays fees to the feeHandler\n     * @param payer The account who's position the fees are charged on\n     * @param beneficiary The beneficiary of the fees paid (usually this will be the keeper)\n     * @param feeAmount The amount in tokens to pay as fees\n     * @param depositToken The LpToken used to pay the fees\n     */\n    function _payFees(\n        address payer,\n        address beneficiary,\n        uint256 feeAmount,\n        address depositToken\n    ) internal {\n        address feeHandler = getF"
    }
  ]
}