{
  "Title": "3S-LENFT-N11 protocol/Trading/LiquidityPairMetadata.sol: internal function \"trait\" should start with underscore",
  "Content": "#### Description\nAccording to the standard solidity convention, internal function names should start with an underscore. This convention is used throughout the repo, except for function [trait()](https://github.com/leNFT/contracts/blob/master/contracts/protocol/Trading/LiquidityPairMetadata.sol#L225) in the `LiquidityPairMetadata` contract.\n\n#### Recommendation\nChange the function name to \"_trait\"",
  "Impact": "GAS",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/protocol/Trading/LiquidityPairMetadata.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {Base64} from \"@openzeppelin/contracts/utils/Base64.sol\";\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {ERC721} from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {IERC721Metadata} from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport {ITradingPool} from \"../../interfaces/ITradingPool.sol\";\nimport {ILiquidityPairMetadata} from \"../../interfaces/ILiquidityPairMetadata.sol\";\nimport {DataTypes} from \"../../libraries/types/DataTypes.sol\";\n\n/// @title LiquidityPair Metadata\n/// @author leNFT (thanks to out.eth (@outdoteth))\n/// @notice This contract is used to generate a liquidity pair's metadata.\n/// @dev Fills the metadata with dynamic data from the liquidity pair.\ncontract LiquidityPairMetadata is ILiquidityPairMetadata {\n    modifier lpExists(address tradingPool, uint256 tokenId) {\n        _requireLpExists(tradingPool, tokenId);\n        _;\n    }\n\n    /// @notice Returns the metadata for a liquidity pair\n    /// @param tradingPool The address of the trading pool of the liquidity pair.\n    /// @param tokenId The liquidity pair's token ID.\n    /// @return The encoded metadata for the liquidity pair.\n    function tokenURI(\n        address tradingPool,\n        uint256 tokenId\n    )\n        public\n        view\n        override\n        lpExists(tradingPool, tokenId)\n        returns (string memory)\n    {\n        bytes memory metadata;\n\n        {\n            // scope to avoid stack too deep errors\n            metadata = abi.encodePacked(\n                \"{\",\n                '\"name\": \"Liquidity Pair ',\n                IERC721Metadata(ITradingPool(tradingPool).getNFT()).symbol(),\n                IERC20Metadata(ITradingPool(tradingPool).getToken()).symbol(),\n                \" #\",\n                Strings.toString(tokenId),\n                '\",'\n            );\n        }\n\n        {\n            metadata = abi.encodePacked(\n                metadata,\n                '\"description\": \"leNFT trading liquidity pair.\",',\n                '\"image\": ',\n                '\"data:image/svg+xml;base64,',\n                Base64.encode(svg(tradingPool, tokenId)),\n                '\",',\n                '\"attributes\": [',\n                attributes(tradingPool, tokenId),\n                \"]\",\n                \"}\"\n            );\n        }\n\n        return\n            string(\n                abi.encodePacked(\n                    \"data:application/json;base64,\",\n                    Base64.encode(metadata)\n                )\n            );\n    }\n\n    /// @notice Returns the attributes for a liquidity pair encoded as json.\n    /// @param tradingPool The address of the trading pool of the liquidity pair.\n    /// @param tokenId The liquidity pair's token ID.\n    /// @return The encoded attributes for the liquidity pair.\n    function attributes(\n        address tradingPool,\n        uint256 tokenId\n    ) public view lpExists(tradingPool, tokenId) returns (string memory) {\n        DataTypes.LiquidityPair memory lp = ITradingPool(tradingPool).getLP(\n            tokenId\n        );\n\n        bytes memory _attributes;\n\n        {\n            // scope to avoid stack too deep errors\n            _attributes = abi.encodePacked(\n                _trait(\"Pool address\", Strings.toHexString(tradingPool)),\n                \",\",\n                _trait(\n                    \"Token\",\n                    Strings.toHexString(ITradingPool(tradingPool).getToken())\n                ),\n                \",\",\n                _trait(\n                    \"NFT\",\n                    Strings.toHexString(ITradingPool(tradingPool).getNFT())\n                ),\n                \",\",\n                _trait(\"Price\", Strings.toString(lp.spotPrice)),\n                \",\",\n                _trait(\"Token balance\", Strings.toString(lp.tokenAmount)),\n                \",\"\n            );\n        }\n\n        {\n            _attributes = abi.encodePacked(\n                _attributes,\n                _trait(\"NFT balance\", Strings.toString(lp.nftIds.length)),\n                \",\",\n                _trait(\"Curve\", Strings.toHexString(lp.curve)),\n                \",\",\n                _trait(\"Delta\", Strings.toString(lp.delta)),\n                \",\",\n                _trait(\"Fee\", Strings.toString(lp.fee)),\n                \",\",\n                _trait(\"Type\", Strings.toString(uint256(lp.lpType)))\n            );\n        }\n\n        return string(_attributes);\n    }\n\n    /// @notice Returns an svg image for a liquidity pair.\n    /// @param tradingPool The address of the trading pool of the liquidity pair.\n    /// @param tokenId The liquidity pair's token ID.\n    /// @return _svg The svg image for the liquidity pair.\n    function svg(\n        address tradingPool,\n        uint256 tokenId\n    ) public view lpExists(tradingPool, tokenId) returns (bytes memory _svg) {\n        DataTypes.LiquidityPair memory lp = ITradingPool(tradingPool).getLP(\n            tokenId\n        );\n        IERC721Metadata nft = IERC721Metadata(\n            ITradingPool(tradingPool).getNFT()\n        );\n        IERC20Metadata token = IERC20Metadata(\n            ITradingPool(tradingPool).getToken()\n        );\n\n        // break up svg building into multiple scopes to avoid stack too deep errors\n        {\n            _svg = abi.encodePacked(\n                '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 400 400\" style=\"width:100%;background:#eaeaea;fill:black;font-family:monospace\">',\n                '<text x=\"50%\" y=\"24px\" font-size=\"12\" text-anchor=\"middle\">',\n                \"leNFT Trading Pair \",\n                nft.symbol(),\n                token.symbol(),\n                \" #\",\n                Strings.toString(tokenId),\n                \"</text>\",\n                '<text x=\"24px\" y=\"72px\" font-size=\"8\">'\n            );\n        }\n\n        {\n            _svg = abi.encodePacked(\n                _svg,\n                \"Trading pool: \",\n                Strings.toHexString(address(tradingPool)),\n                \"</text>\",\n                '<text x=\"24px\" y=\"90px\" font-size=\"8\">',\n                \"NFT: \",\n                nft.name(),\n                \"</text>\",\n                '<text x=\"24px\" y=\"108px\" font-size=\"8\">',\n                \"Token: \",\n                token.name(),\n                \"</text>\"\n            );\n        }\n\n        {\n            _svg = abi.encodePacked(\n                _svg,\n                '<text x=\"24px\" y=\"126px\" font-size=\"8\">',\n                \"Price: \",\n                Strings.toString(lp.spotPrice),\n                \"</text>\",\n                '<text x=\"24px\" y=\"144px\" font-size=\"8\">',\n                \"NFT Balance: \",\n                Strings.toString(lp.nftIds.length),\n                \"</text>\",\n                '<text x=\"24px\" y=\"162px\" font-size=\"8\">',\n                \"Token Balance: \",\n                Strings.toString(lp.tokenAmount),\n                \"</text>\"\n            );\n        }\n\n        {\n            _svg = abi.encodePacked(\n                _svg,\n                '<text x=\"24px\" y=\"180px\" font-size=\"8\">',\n                \"Fee: \",\n                Strings.toString(lp.fee),\n                \"</text>\",\n                '<text x=\"24px\" y=\"198px\" font-size=\"8\">',\n                \"Curve: \",\n                Strings.toHexString(lp.curve),\n                \"</text>\",\n                '<text x=\"24px\" y=\"216px\" font-size=\"8\">',\n                \"Delta: \",\n                Strings.toString(lp.delta),\n                \"</text>\",\n                \"</svg>\"\n            );\n        }\n    }\n\n    /// @notice Returns a trait encoded as json.\n    /// @param traitType The trait type.\n    /// @param value The trait value.\n    /// @return The encoded trait.\n    function _trait(\n        string memory traitType,\n        string memory value\n    ) internal pure returns (string memory) {\n        return\n            string(\n                abi.encodePacked(\n                    '{ \"trait_type\": \"',\n                    traitType,\n                    '\",',\n                    '\"value\": \"',\n                    value,\n                    '\" }'\n                )\n            );\n    }\n\n    function _requireLpExists(\n        address tradingPool,\n        uint256 tokenId\n    ) internal view {\n        try\n            IERC721(tradingPool).ownerOf(tokenId) // solhint-disable-next-line no-empty-blocks\n        {} catch {\n            revert(\"LPM:LP_NOT_FOUND\");\n        }\n    }\n}"
    }
  ]
}