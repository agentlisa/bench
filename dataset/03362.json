{
  "Title": "`creditManager` isn't checked",
  "Content": "##### Description\nIt is possible to give unlimited approve to poisoned contract:\nhttps://github.com/Gearbox-protocol/gearbox-contracts/blob/0ac33ba87212ce056ac6b6357ad74161d417158a/contracts/credit/LeverageActions.sol#L222\n##### Recommendation\nWe recommend adding a check that `creditManager` is a system contract.",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/credit/LeverageActions.sol",
      "content": "// SPDX-License-Identifier: BSL-1.1\n// Gearbox. Generalized leverage protocol that allows to take leverage and then use it across other DeFi protocols and platforms in a composable way.\n// (c) Gearbox.fi, 2021\npragma solidity ^0.7.4;\npragma abicoder v2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport {BytesLib} from \"../integrations/uniswap/BytesLib.sol\";\nimport {AddressProvider} from \"../core/AddressProvider.sol\";\nimport {ContractsRegister} from \"../core/ContractsRegister.sol\";\nimport {IWETHGateway} from \"../interfaces/IWETHGateway.sol\";\nimport {ICreditManager} from \"../interfaces/ICreditManager.sol\";\nimport {ICreditFilter} from \"../interfaces/ICreditFilter.sol\";\nimport {ISwapRouter} from \"../integrations/uniswap/IUniswapV3.sol\";\nimport {IUniswapV2Router02} from \"../integrations/uniswap/IUniswapV2Router02.sol\";\nimport {ICurvePool} from \"../integrations/curve/ICurvePool.sol\";\nimport {IYVault} from \"../integrations/yearn/IYVault.sol\";\nimport {IWETH} from \"../interfaces/external/IWETH.sol\";\nimport {YearnAdapter} from \"../adapters/YearnV2.sol\";\n\nimport {Constants} from \"../libraries/helpers/Constants.sol\";\nimport {Errors} from \"../libraries/helpers/Errors.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract LeveragedActions is ReentrancyGuard {\n    using SafeMath for uint256;\n    using Address for address payable;\n    using Address for address;\n    using SafeERC20 for IERC20;\n    using BytesLib for bytes;\n\n    /// @dev The length of the bytes encoded address\n    uint256 private constant ADDR_SIZE = 20;\n\n    /// @dev Contracts reggister to check that credit manager is registered in Gearbox\n    ContractsRegister public immutable contractsRegister;\n\n    /// @dev address of WETH token\n    address public wethToken;\n\n    /// @dev WETH Gateway for opening ETH credit account\n    IWETHGateway public wethGateway;\n\n    struct LongParameters {\n        address creditManager;\n        uint256 leverageFactor;\n        uint256 swapInterface;\n        address swapContract;\n        bytes swapCalldata;\n        uint256 lpInterface;\n        address lpContract;\n    }\n\n    // Emits each time new action is done\n    event Action(\n        address indexed tokenIn,\n        address indexed collateral,\n        address indexed asset,\n        uint256 amountIn,\n        address shortSwapContract,\n        address longSwapContract,\n        address lpContract,\n        uint256 referralCode\n    );\n\n    constructor(address _addressProvider) {\n        AddressProvider addressProvider = AddressProvider(_addressProvider);\n        contractsRegister = ContractsRegister(\n            addressProvider.getContractsRegister()\n        );\n        wethGateway = IWETHGateway(addressProvider.getWETHGateway());\n        wethToken = addressProvider.getWethToken();\n    }\n\n    /// @dev Opens short position (for example, swap USDC to ETH, open credit account in ETH, then swap all ETH on account  to USDC)\n    /// @param router UniswapV2 router to use for exchange\n    /// @param amountIn Amount in, if you send ETH as value- it would be taken from msg.value\n    /// @param amountOutMin Minimal amount after first swap before opening account\n    /// @param path UniswapV2 path for short swap\n    /// @param longParams parameters for long operation\n    /// @param referralCode referral code, it'll be in Action event and in openCreditAccount also\n    function openShortUniV2(\n        address router,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] memory path,\n        LongParameters calldata longParams,\n        uint256 referralCode\n    ) external payable nonReentrant {\n        bytes memory data = abi.encodeWithSelector(\n            bytes4(0x38ed1739), // \"swapExactTokensForTokens(uint256,uint256,address[],address,uint256)\",\n            amountIn,\n            amountOutMin,\n            path,\n            address(this),\n            block.timestamp\n        ); // M:[LA-5]\n\n        _openShort(\n            router,\n            path[0],\n            amountIn,\n            data,\n            longParams,\n            referralCode\n        ); // M:[LA-5]\n    }\n\n    /// @dev Opens short position (for example, swap USDC to ETH, open credit account in ETH, then swap all ETH to USDC)\n    /// @param router UniswapV3 router  (ISwapRouter) to use for exchange\n    /// @param paramsV3 Parameters UniV# exact input for short swap operation\n    /// @param referralCode referral code, it'll be in Action event and in openCreditAccount also\n    function openShortUniV3(\n        address router,\n        ISwapRouter.ExactInputParams memory paramsV3,\n        LongParameters calldata longParams,\n        uint256 referralCode\n    ) external payable nonReentrant {\n        // Getting initial token from short paremeters\n        (address tokenIn, ) = _extractTokensUniV3(\n            paramsV3.path\n        ); // M:[LA-6]\n\n        // Changes recipient to this contract\n        paramsV3.recipient = address(this); // M:[LA-6]\n\n        bytes memory data = abi.encodeWithSelector(\n            bytes4(0xc04b8d59), // +\n            paramsV3\n        ); // M:[LA-6]\n\n        _openShort(\n            router,\n            tokenIn,\n            paramsV3.amountIn,\n            data,\n            longParams,\n            referralCode\n        ); // M:[LA-6]\n    }\n\n    /// @dev Opens short position (for example, swap USDC to ETH, open credit account in ETH, then swap all ETH to USDC)\n    /// @param curvePool Curve pool address\n    /// @param i Index value for the coin to send\n    /// @param j Index value of the coin to receive\n    /// @param amountIn Amount in, if you send ETH as value- it would be taken from msg.value\n    /// @param amountOutMin Minimal amount after first swap before opening account\n    /// @param longParams parameters for long operation\n    /// @param referralCode referral code, it'll be in Action event and in openCreditAccount also\n    function openShortCurve(\n        address curvePool,\n        int128 i,\n        int128 j,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        LongParameters calldata longParams,\n        uint256 referralCode\n    ) external payable nonReentrant {\n        address tokenIn = ICurvePool(curvePool).coins(uint256(i)); // M:[LA-1]\n\n        bytes memory data = abi.encodeWithSelector(\n            bytes4(0x3df02124), //\"exchange(int128,int128,uint256,uint256)\"\n            i,\n            j,\n            amountIn,\n            amountOutMin\n        ); // M:[LA-7]\n\n        _openShort(\n            curvePool,\n            tokenIn,\n            amountIn,\n            data,\n            longParams,\n            referralCode\n        ); // M:[LA-7]\n    }\n\n    /// @dev Opens long position (for example, open credit account in ETH, then swap all ETH to USDC)\n    /// @param amountIn Amount in, if you send ETH as value- it would be taken from msg.value\n    /// @param longParams parameters for long operation\n    /// @param referralCode referral code, it'll be in Action event and in openCreditAccount also\n    function openLong(\n        uint256 amountIn,\n        LongParameters calldata longParams,\n        uint256 referralCode\n    ) external payable nonReentrant {\n        address collateral = ICreditManager(longParams.creditManager)\n        .underlyingToken(); // M:[LA-1]\n\n        _getTokenOrWrapETH(collateral, amountIn); // M:[LA-1]\n        (address asset, ) = _openLong(longParams, referralCode); // M:[LA-1]\n\n        emit Action(\n            collateral,\n            collateral,\n            asset,\n            amountIn,\n            address(0),\n            longParams.swapContract,\n            longParams.lpContract,\n            referralCode\n        ); // M:[LA-1]\n    }\n\n    /// @dev Opens leveraged account and put all money into LP Contract (Yearn for example)\n    function openLP(\n        address creditManager,\n        uint256 leverageFactor,\n        uint256 amountIn,\n        uint256 lpInterface,\n        address lpContract,\n        uint256 referralCode\n    ) external payable nonReentrant {\n        // Gets collateral\n        address collateral = ICreditManager(creditManager).underlyingToken(); // M:[LA-8]\n\n        // Transgers tokens / wraps ETH\n        _getTokenOrWrapETH(collateral, amountIn); // M:[LA-8]\n\n        // Provide needed allowance\n        _provideCreditAccountAllowance(creditManager, collateral); // M:[LA-8]\n\n        // Opens credit account\n        ICreditManager(creditManager).openCreditAccount(\n            amountIn,\n            address(this),\n            leverageFactor,\n            referralCode\n        );\n\n        // Deposits LP\n        address lpAsset = _depositLP(creditManager, lpInterface, lpContract); // M:[LA-8]\n\n        // Transfers ownership to msg.sender\n        ICreditManager(creditManager).transferAccountOwnership(msg.sender); // M:[LA-8]\n\n        // Emits actions\n        emit Action(\n            collateral,\n            collateral,\n            lpAsset,\n            amountIn,\n            address(0),\n            address(0),\n            lpContract,\n            referralCode\n        ); // M:[LA-8]\n    }\n\n    function _openShort(\n        address shortSwapContract,\n        address tokenIn,\n        uint256 amountIn,\n        bytes memory shortSwapCalldata,\n        LongParameters calldata longParams,\n        uint256 referralCode\n    ) internal {\n        // Checks that swapContract is allowed\n        _getAdapterOrRevert(longParams.creditManager, shortSwapContract); // M:[LA-5, 6, 7]\n\n        // Transfers tokens from msg.sender to contract\n        _getTokenOrWrapETH(tokenIn, amountIn); // M:[LA-5, 6, 7]\n\n        // Provides enough allowance to swapContract\n        _provideCreditAccountAllowance(shortSwapContract, tokenIn); // M:[LA-5, 6, 7]\n\n        // Calls short swap\n        shortSwapContract.functionCall(shortSwapCalldata); // M:[LA-5, 6, 7]\n\n        // Opens long position and transfer ownership\n        (address asset, address collateral) = _openLong(\n            longParams,\n            referralCode\n        ); // M:[LA-5, 6, 7]\n\n        // Returns tokens if they exists on this contract\n        _returnTokenOrUnwrapWETH(tokenIn); // M:[LA-5, 6, 7]\n\n        // Emits action\n        emit Action(\n            tokenIn,\n            collateral,\n            asset,\n            amountIn,\n            shortSwapContract,\n            longParams.swapContract,\n            longParams.lpContract,\n            referralCode\n        ); // M:[LA-5, 6, 7]\n    }\n\n    /// @dev Opens position: open account with desired le\n    /// - opens account with desired leerage factor\n    /// - transfers all assets using provided adapter to desired asset\n    /// - executes lp operation, if provided\n    function _openLong(LongParameters calldata longParams, uint256 referralCode)\n        internal\n        returns (address asset, address collateral)\n    {\n        require(\n            contractsRegister.isCreditManager(longParams.creditManager),\n            Errors.WG_DESTINATION_IS_NOT_CREDIT_MANAGER\n        );\n\n        collateral = ICreditManager(longParams.creditManager).underlyingToken(); // M:[LA-1]\n\n        uint256 amount = IERC20(collateral).balanceOf(address(this)); // M:[LA-1]\n\n        _provideCreditAccountAllowance(longParams.creditManager, collateral); // M:[LA-1]\n        ICreditManager(longParams.creditManager).openCreditAccount(\n            amount,\n            address(this),\n            longParams.leverageFactor,\n            referralCode\n        ); // M:[LA-1]\n\n        uint256 leveragedAmount = amount\n        .mul(longParams.leverageFactor)\n        .div(Constants.LEVERAGE_DECIMALS)\n        .add(amount); // M:[LA-1]\n\n        address adapter = _getAdapterOrRevert(\n            longParams.creditManager,\n            longParams.swapContract\n        );\n\n        //\n        // UNISWAP V2 INTERFACE\n        //\n        if (longParams.swapInterface == Constants.UNISWAP_V2) {\n            (\n                uint256 amountIn,\n                uint256 amountOutMin,\n                address[] memory path,\n                ,\n                uint256 deadline\n            ) = abi.decode(\n                longParams.swapCalldata,\n                (uint256, uint256, address[], address, uint256)\n            ); // M:[LA-1]\n\n            uint256 amountOutMinLeveraged = amountOutMin\n            .mul(leveragedAmount)\n            .div(amountIn); // M:[LA-1]\n\n            IUniswapV2Router02(adapter).swapExactTokensForTokens(\n                leveragedAmount,\n                amountOutMinLeveraged,\n                path,\n                address(this), // it will be replaced in adapter\n                deadline\n            ); // M:[LA-1]\n\n            asset = path[path.length - 1]; // M:[LA-1]\n        }\n        //\n        //  UNISWAP V3 INTERFACE\n        //\n        else if (longParams.swapInterface == Constants.UNISWAP_V3) {\n            ISwapRouter.ExactInputParams memory params = abi.decode(\n                longParams.swapCalldata,\n                (ISwapRouter.ExactInputParams)\n            );\n\n            params.amountIn = leveragedAmount;\n            params.amountOutMinimum = params\n            .amountOutMinimum\n            .mul(leveragedAmount)\n            .div(params.amountIn);\n            ISwapRouter(adapter).exactInput(params);\n            (, asset) = _extractTokensUniV3(params.path);\n        }\n        //\n        // CURVE V1 INTERFACE\n        //\n        else if (longParams.swapInterface == Constants.CURVE_V1) {\n            (int128 i, int128 j, uint256 dx, uint256 min_dy) = abi.decode(\n                longParams.swapCalldata,\n                (int128, int128, uint256, uint256)\n            );\n\n            ICurvePool(adapter).exchange(\n                i,\n                j,\n                leveragedAmount,\n                min_dy.mul(leveragedAmount).div(dx)\n            );\n            asset = ICurvePool(longParams.swapContract).coins(uint256(j));\n        } else {\n            revert(Errors.LA_UNKNOWN_SWAP_INTERFACE); // Todo:\n        }\n\n        //\n        // LP\n        //\n\n        if (longParams.lpContract != address(0)) {\n            asset = _depositLP(\n                longParams.creditManager,\n                longParams.lpInterface,\n                longParams.lpContract\n            ); // M:[LA-2]\n        }\n\n        ICreditManager(longParams.creditManager).transferAccountOwnership(\n            msg.sender\n        ); // M:[LA-1, 2, 3, 4]\n    }\n\n    /// @dev Opens LP position for whole money on account\n    /// @param creditManager Address of creditManager\n    /// @param lpInterface LP Interface\n    /// @param lpContract Address of LP contract\n    /// @return LP asset address\n    function _depositLP(\n        address creditManager,\n        uint256 lpInterface,\n        address lpContract\n    ) internal returns (address) {\n        address lpAdapter = _getAdapterOrRevert(creditManager, lpContract);\n\n        if (lpInterface == Constants.LP_YEARN) {\n            IYVault(lpAdapter).deposit(); // M: [LA-2]\n            return lpContract;\n        }\n        revert(Errors.LA_UNKNOWN_LP_INTERFACE);\n    }\n\n    /// @dev Transfers money from msg.sender account or convert from eth if\n    /// @param token Address on token\n    /// @param amountIn Amount of tokens to be transferred. If value is attached to tx, it should be equal amountIn\n    function _getTokenOrWrapETH(address token, uint256 amountIn) internal {\n        if (token == wethToken && msg.value > 0) {\n            require(msg.value == amountIn, Errors.LA_INCORRECT_VALUE); // M:[LA-12]\n            IWETH(wethToken).deposit{value: msg.value}(); // M:[LA-2, ]\n        } else {\n            require(msg.value == 0, Errors.LA_INCORRECT_MSG); // M:[LA-11]\n            IERC20(token).safeTransferFrom(msg.sender, address(this), amountIn); // M:[LA-1,3,4,5,6,7,8]\n        }\n    }\n\n    /// @dev Transfers unused tokens back or ETH if it's wethToken\n    /// @param token Address of token\n    function _returnTokenOrUnwrapWETH(address token) internal {\n        // Checks balanceAfter and returns money if not all tokens were converted\n        uint256 balance = IERC20(token).balanceOf(address(this)); //  // M:[LA-13, 14]\n        if (balance > 0) {\n            if (token == wethToken) {\n                IWETH(wethToken).withdraw(balance); // M:[LA-14]\n                payable(msg.sender).sendValue(balance); // M:[LA-14]\n            } else {\n                IERC20(token).transfer(msg.sender, balance); // M:[LA-13]\n            }\n        }\n    }\n\n    /// @dev Returns adapter for provided contract or reverts if it's now allowed\n    /// @param creditManager Address of credit manager\n    /// @param targetContract Address of contract which adapter is needed\n    function _getAdapterOrRevert(address creditManager, address targetContract)\n        internal\n        view\n        returns (address)\n    {\n        // Could be optimised by adding internal list of creditManagers\n        ICreditFilter creditFilter = ICreditFilter(\n            ICreditManager(creditManager).creditFilter()\n        ); // M:[LA-10]\n\n        address adapter = creditFilter.contractToAdapter(targetContract);\n        require(\n            adapter != address(0),\n            Errors.CF_CONTRACT_IS_NOT_IN_ALLOWED_LIST\n        ); // M:[LA-10]\n        return adapter;\n    }\n\n    /// @dev Extracts from and to tokens from UniV3 path\n    /// @param path UniV3 encoded path\n    /// @return tokenA tokenIn\n    /// @return tokenB tokenOut\n    function _extractTokensUniV3(bytes memory path)\n        internal\n        pure\n        returns (address tokenA, address tokenB)\n    {\n        tokenA = path.toAddress(0);\n        tokenB = path.toAddress(path.length - ADDR_SIZE);\n    }\n\n    /// @dev Checks that credit account has enough allowance for operation by comparing existing one with x10 times more than needed\n    /// @param targetContract Contract to check allowance\n    /// @param token Token address of contract\n    function _provideCreditAccountAllowance(\n        address targetContract,\n        address token\n    ) internal {\n        // Get 10x reserve in allowance\n        if (\n            IERC20(token).allowance(address(this), targetContract) <\n            Constants.MAX_INT_4\n        ) {\n            IERC20(token).safeApprove(targetContract, 0); // M:[LA-1,2,3,4,]\n            IERC20(token).safeApprove(targetContract, Constants.MAX_INT); // M:[LA-1,2,3,4]\n        }\n    }\n\n    receive() external payable {} // M:[LA-14]\n}"
    }
  ]
}