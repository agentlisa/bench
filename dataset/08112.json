{
  "Title": "[H-03] TRSRY: front-runnable `setApprovalFor`",
  "Content": "_Submitted by zzzitron, also found by berndartmueller, csanuragjain, pashov, Ruhum, sorrynotsorry, and Trust_\n\n<https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/TRSRY.sol#L64-L72><br>\n<https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/TreasuryCustodian.sol#L42-L48>\n\nAn attacker may be able to withdraw more than intended\n\n### Proof of Concept\n\nLet's say Alice had approval of 100. Now the treasury custodian reduced the approval to 50. Alice could frontrun the `setApprovalFor` of 50, and withdraw 100 as it was before. Then withdraw 50 with the newly set approval. So the alice could withdraw 150.\n\n```solidity\n// modules/TRSRY.sol\n\n 63     /// @notice Sets approval for specific withdrawer addresses\n 64     function setApprovalFor(\n 65         address withdrawer_,\n 66         ERC20 token_,\n 67         uint256 amount_\n 68     ) external permissioned {\n 69         withdrawApproval[withdrawer_][token_] = amount_;\n 70\n 71         emit ApprovedForWithdrawal(withdrawer_, token_, amount_);\n 72     }\n```\n\nThe `TreasuryCustodian` simply calls the `setApprovalFor` to grant Approval.\n\n```solidity\n 41\n 42     function grantApproval(\n 43         address for_,\n 44         ERC20 token_,\n 45         uint256 amount_\n 46     ) external onlyRole(\"custodian\") {\n 47         TRSRY.setApprovalFor(for_, token_, amount_);\n 48     }\n```\n\n### Recommended Mitigation Steps\n\nInstead of setting the given amount, one can reduce from the current approval. By doing so, it checks whether the previous approval is spend.\n\n**[ind-igo (Olympus) confirmed and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/410#issuecomment-1238901986):**\n > Understood. Will change the logic to increase/decrease allowances.\n\n**[0xean (judge) increased severity to High and commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/410#issuecomment-1249816020):**\n > I think this vulnerability should be a high severity as it opens up the possibility of a direct loss of funds in the amount of up to the previous approval amount. Upgrading to High. \n\n**[0xean (judge) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/410#issuecomment-1250385243):**\n > @ind-igo - Not sure if you deleted your comment, but that context is useful.  Happy to take another look here. \n\n**[ind-igo (Olympus) commented](https://github.com/code-423n4/2022-08-olympus-findings/issues/410#issuecomment-1251369022):**\n > I did, I just thought it was unnecessary to evaluate the issue. I was just saying that the context of the code is that it is not intended to be used to approve an EOA/multisig, but instead used to approve governance-voted contracts to access treasury funds, in order to deposit into yield contracts or whatever. But I don't think it's very relevant to this, as the code is still faulty and exploitable in an extreme case. I already have made this remediation as well, so all good.\n\n\n\n***\n\n \n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-08-olympus-dao-contest",
  "Code": [
    {
      "filename": "src/modules/TRSRY.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\n\nimport {TransferHelper} from \"libraries/TransferHelper.sol\";\n\nimport \"src/Kernel.sol\";\n\n// ERRORS\nerror TRSRY_NotApproved();\nerror TRSRY_NoDebtOutstanding();\n\n/// @notice Treasury holds reserves, LP tokens and all other assets under the control\n///         of the protocol.\ncontract OlympusTreasury is Module, ReentrancyGuard {\n    using TransferHelper for ERC20;\n\n    event ApprovedForWithdrawal(address indexed policy_, ERC20 indexed token_, uint256 amount_);\n    event Withdrawal(\n        address indexed policy_,\n        address indexed withdrawer_,\n        ERC20 indexed token_,\n        uint256 amount_\n    );\n    event DebtIncurred(ERC20 indexed token_, address indexed policy_, uint256 amount_);\n    event DebtRepaid(ERC20 indexed token_, address indexed policy_, uint256 amount_);\n    event DebtSet(ERC20 indexed token_, address indexed policy_, uint256 amount_);\n\n    /// @notice Mapping of who is approved for withdrawal.\n    /// @dev    withdrawer -> token -> amount. Infinite approval is max(uint256).\n    mapping(address => mapping(ERC20 => uint256)) public withdrawApproval;\n\n    /// @notice Total debt for token across all withdrawals.\n    mapping(ERC20 => uint256) public totalDebt;\n\n    /// @notice Debt for particular token and debtor address\n    mapping(ERC20 => mapping(address => uint256)) public reserveDebt;\n\n    /*//////////////////////////////////////////////////////////////\n                            MODULE INTERFACE\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(Kernel kernel_) Module(kernel_) {}\n\n    function KEYCODE() public pure override returns (Keycode) {\n        return toKeycode(\"TRSRY\");\n    }\n\n    function VERSION() external pure override returns (uint8 major, uint8 minor) {\n        return (1, 0);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CORE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function getReserveBalance(ERC20 token_) external view returns (uint256) {\n        return token_.balanceOf(address(this)) + totalDebt[token_];\n    }\n\n    /// @notice Sets approval for specific withdrawer addresses\n    function setApprovalFor(\n        address withdrawer_,\n        ERC20 token_,\n        uint256 amount_\n    ) external permissioned {\n        withdrawApproval[withdrawer_][token_] = amount_;\n\n        emit ApprovedForWithdrawal(withdrawer_, token_, amount_);\n    }\n\n    /// @notice Allow withdrawal of reserve funds from pre-approved addresses.\n    function withdrawReserves(\n        address to_,\n        ERC20 token_,\n        uint256 amount_\n    ) public {\n        _checkApproval(msg.sender, token_, amount_);\n\n        token_.safeTransfer(to_, amount_);\n\n        emit Withdrawal(msg.sender, to_, token_, amount_);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             DEBT FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Pre-approved policies can get a loan to perform operations on treasury assets.\n    function getLoan(ERC20 token_, uint256 amount_) external permissioned {\n        _checkApproval(msg.sender, token_, amount_);\n\n        // Add debt to caller\n        reserveDebt[token_][msg.sender] += amount_;\n        totalDebt[token_] += amount_;\n\n        token_.safeTransfer(msg.sender, amount_);\n\n        emit DebtIncurred(token_, msg.sender, amount_);\n    }\n\n    /// @notice Lets an address with debt repay their loan.\n    function repayLoan(ERC20 token_, uint256 amount_) external nonReentrant {\n        if (reserveDebt[token_][msg.sender] == 0) revert TRSRY_NoDebtOutstanding();\n\n        // Deposit from caller first (to handle nonstandard token transfers)\n        uint256 prevBalance = token_.balanceOf(address(this));\n        token_.safeTransferFrom(msg.sender, address(this), amount_);\n\n        uint256 received = token_.balanceOf(address(this)) - prevBalance;\n\n        // Subtract debt from caller\n        reserveDebt[token_][msg.sender] -= received;\n        totalDebt[token_] -= received;\n\n        emit DebtRepaid(token_, msg.sender, received);\n    }\n\n    /// @notice An escape hatch for setting debt in special cases, like swapping reserves to another token.\n    function setDebt(\n        ERC20 token_,\n        address debtor_,\n        uint256 amount_\n    ) external permissioned {\n        uint256 oldDebt = reserveDebt[token_][debtor_];\n\n        reserveDebt[token_][debtor_] = amount_;\n\n        if (oldDebt < amount_) totalDebt[token_] += amount_ - oldDebt;\n        else totalDebt[token_] -= oldDebt - amount_;\n\n        emit DebtSet(token_, debtor_, amount_);\n    }\n\n    function _checkApproval(\n        address withdrawer_,\n        ERC20 token_,\n        uint256 amount_\n    ) internal {\n        // Must be approved\n        uint256 approval = withdrawApproval[withdrawer_][token_];\n        if (approval < amount_) revert TRSRY_NotApproved();\n\n        // Check for infinite approval\n        if (approval != type(uint256).max) {\n            unchecked {\n                withdrawApproval[withdrawer_][token_] = approval - amount_;\n            }\n        }\n    }\n}"
    },
    {
      "filename": "src/policies/TreasuryCustodian.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {OlympusTreasury} from \"src/modules/TRSRY.sol\";\nimport \"src/Kernel.sol\";\n\n// ERRORS\nerror PolicyStillActive();\nerror PolicyNotFound();\n\n// Generic contract to allow authorized contracts to interact with treasury\n// Use cases include setting and removing approvals, as well as allocating assets for yield\ncontract TreasuryCustodian is Policy {\n    /* ========== STATE VARIABLES ========== */\n    event ApprovalRevoked(address indexed policy_, ERC20[] tokens_);\n\n    // Modules\n    OlympusTreasury internal TRSRY;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(Kernel kernel_) Policy(kernel_) {}\n\n    /* ========== FRAMEWORK CONFIGURATION ========== */\n    function configureDependencies() external override returns (Keycode[] memory dependencies) {\n        dependencies = new Keycode[](1);\n        dependencies[0] = toKeycode(\"TRSRY\");\n\n        TRSRY = OlympusTreasury(getModuleAddress(dependencies[0]));\n    }\n\n    function requestPermissions() external view override returns (Permissions[] memory requests) {\n        Keycode TRSRY_KEYCODE = TRSRY.KEYCODE();\n\n        requests = new Permissions[](2);\n        requests[0] = Permissions(TRSRY_KEYCODE, TRSRY.setApprovalFor.selector);\n        requests[1] = Permissions(TRSRY_KEYCODE, TRSRY.setDebt.selector);\n    }\n\n    function grantApproval(\n        address for_,\n        ERC20 token_,\n        uint256 amount_\n    ) external onlyRole(\"custodian\") {\n        TRSRY.setApprovalFor(for_, token_, amount_);\n    }\n\n    // Anyone can call to revoke a deactivated policy's approvals.\n    // TODO Currently allows anyone to revoke any approval EXCEPT activated policies.\n    // TODO must reorg policy storage to be able to check for deactivated policies.\n    function revokePolicyApprovals(address policy_, ERC20[] memory tokens_) external {\n        if (Policy(policy_).isActive()) revert PolicyStillActive();\n\n        // TODO Make sure `policy_` is an actual policy and not a random address.\n\n        uint256 len = tokens_.length;\n        for (uint256 j; j < len; ) {\n            TRSRY.setApprovalFor(policy_, tokens_[j], 0);\n            unchecked {\n                ++j;\n            }\n        }\n\n        emit ApprovalRevoked(policy_, tokens_);\n    }\n\n    // Debt admin functions for authorized addresses to manipulate debt in special cases\n\n    function increaseDebt(\n        ERC20 token_,\n        address debtor_,\n        uint256 amount_\n    ) external onlyRole(\"custodian\") {\n        uint256 debt = TRSRY.reserveDebt(token_, debtor_);\n        TRSRY.setDebt(token_, debtor_, debt + amount_);\n    }\n\n    function decreaseDebt(\n        ERC20 token_,\n        address debtor_,\n        uint256 amount_\n    ) external onlyRole(\"custodian\") {\n        uint256 debt = TRSRY.reserveDebt(token_, debtor_);\n        TRSRY.setDebt(token_, debtor_, debt - amount_);\n    }\n}"
    }
  ]
}