{
  "Title": "M-12: Users might immediately be liquidated after position opening leading to a loss of CVA and Liquidation fee",
  "Content": "# Issue M-12: Users might immediately be liquidated after position opening leading to a loss of CVA and Liquidation fee \n\nSource: https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/225 \n\n## Found by \nRuhum, berndartmueller, cergyk, panprog, rvierdiiev, volodya, xiaoming90\n## Summary\n\nThe insolvency check (`isSolventAfterOpenPosition`) within the `openPosition` function does not consider the locked balance adjustment, causing the user account to become insolvent immediately after the position is opened. As a result, the affected users will lose their CVA and liquidation fee locked in their accounts.\n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/PartyB/PartyBFacetImpl.sol#L150\n\n\n```solidity\nFile: PartyBFacetImpl.sol\n112:     function openPosition(\n113:         uint256 quoteId,\n114:         uint256 filledAmount,\n115:         uint256 openedPrice,\n116:         PairUpnlAndPriceSig memory upnlSig\n117:     ) internal returns (uint256 currentId) {\n..SNIP..\n150:         LibSolvency.isSolventAfterOpenPosition(quoteId, filledAmount, upnlSig);\n151: \n152:         accountLayout.partyANonces[quote.partyA] += 1;\n153:         accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n154:         quote.modifyTimestamp = block.timestamp;\n155: \n156:         LibQuote.removeFromPendingQuotes(quote);\n157: \n158:         if (quote.quantity == filledAmount) {\n159:             accountLayout.pendingLockedBalances[quote.partyA].subQuote(quote);\n160:             accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].subQuote(quote);\n161: \n162:             if (quote.orderType == OrderType.LIMIT) {\n163:                 quote.lockedValues.mul(openedPrice).div(quote.requestedOpenPrice);\n164:             }\n165:             accountLayout.lockedBalances[quote.partyA].addQuote(quote);\n166:             accountLayout.partyBLockedBalances[quote.partyB][quote.partyA].addQuote(quote);\n167:         }\n```\n\nThe leverage of a position is computed based on the following formula.\n\n$leverage = \\frac{price \\times quantity}{lockedValues.total()}$\n\nWhen opening a position, there is a possibility that the leverage might change because the locked values and quantity are fixed, but it could get filled with a different market price compared to the one at the moment the user requested. Thus, the purpose of Line 163 above is to adjust the locked values to maintain a fixed leverage. After the adjustment, the locked value might be higher or lower.\n\nThe issue is that the insolvency check at Line 150 is performed before the adjustment is made. \n\nAssume that the adjustment in Line 163 cause the locked values to increase. The insolvency check (`isSolventAfterOpenPosition`) at Line 150 will be performed with old or unadjusted locked values that are smaller than expected. Since smaller locked values mean that there will be more available balance, this might cause the system to miscalculate that an account is not liquidatable, but in fact, it is actually liquidatable once the adjusted increased locked value is taken into consideration.\n\nIn this case, once the position is opened, the user account is immediately underwater and can be liquidated.\n\nThe issue will occur in the \"complete fill\" path and \"partial fill\" path since both paths adjust the locked values to maintain a fixed leverage. The \"complete fill\" path adjusts the locked values at [Line 185](https://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/PartyB/PartyBFacetImpl.sol#L185)\n\n## Impact\n\nUsers might become liquidatable immediately after opening a position due to an incorrect insolvency check within the `openPosition`, which erroneously reports that the account will still be healthy after opening the position, while in reality, it is not. As a result, the affected users will lose their CVA and liquidation fee locked in their accounts.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/PartyB/PartyBFacetImpl.sol#L150\n\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/main/symmio-core/contracts/facets/PartyB/PartyBFacetImpl.sol#L185\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider performing the insolvency check with the updated adjusted locked values.\n\n\n\n## Discussion\n\n**MoonKnightDev**\n\nThis scenario could only happen if the user requests to open a short position at a price significantly lower than the market value, creating conditions for potential liquidation. In this case, the identified bug would indeed facilitate this outcome. However, because the existence of such conditions is a prerequisite, we don't believe the severity level is high.\n\n**ctf-sec**\n\nChanged the severity to medium based on the comments above\n\n**mstpr**\n\nEscalate\n\nThis is not true. Accounts can not be immediately liquidatable in this scenario which is ensured by this function \nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/6d2b64b6732fcfbd07c8217897dd233dbb6cd1f5/symmio-core/contracts/facets/PartyB/PartyBFacetImpl.sol#L149-L150\n\nAlso, partyA can never be liquidatable after opening a position but partyB who opens the position might open the position in a level where it's almost liquidatable (-1 pnl would sufficient etc). However, partyB would not open a position because its not favor of doing so. (Who would want to open a position at a price where they are liquidatable immediately?)\n\nWhy partyA is not liquidatable immediately after partyB opens the position in such level? \n\nBecause the nonce increases in openPosition, which means that the new MuonSignature is needed. New MuonSignature will count the pnl of the partyA that its in huge profit (because partyB opened the position in a very undesired price) hence, the partyA can't be liquidatable. \n\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/6d2b64b6732fcfbd07c8217897dd233dbb6cd1f5/symmio-core/contracts/facets/PartyB/PartyBFacetImpl.sol#L152-L153\nhttps://github.com/sherlock-audit/2023-06-symmetrical/blob/6d2b64b6732fcfbd07c8217897dd233dbb6cd1f5/symmio-core/contracts/libraries/LibAccount.sol#L78-L86\n\nConsidering that, there is no point of doing something for any partyB because the harm is only to them. No body will create a position that is below/above the requested open price such that they are immediately liquidate after a small price change. \n\n\nThere is only 1 scenario that the partyA can be liquidatable which is only covered by this issue #77. This finding and the duplicates are missing the complex edge case. \n\n\n**sherlock-admin2**\n\n > Escalate\n> \n> This is not true. Accounts can not be immediately liquidatable in this scenario which is ensured by this function \n> https://github.com/sherlock-audit/2023-06-symmetrical/blob/6d2b64b6732fcfbd07c8217897dd233dbb6cd1f5/symmio-core/contracts/facets/PartyB/PartyBFacetImpl.sol#L149-L150\n> \n> Also, partyA can never be liquidatable after opening a position but partyB who opens the position might open the position in a level where it's almost liquidatable (-1 pnl would sufficient etc). However, partyB would not open a position because its not favor of doing so. (Who would want to open a position at a price where they are liquidatable immediately?)\n> \n> Why partyA is not liquidatable immediately after partyB opens the position in such level? \n> \n> Because the nonce increases in openPosition, which means that the new MuonSignature is needed. New MuonSignature will count the pnl of the partyA that its in huge profit (because partyB opened the position in a very undesired price) hence, the partyA can't be liquidatable. \n> \n> https://github.com/sherlock-audit/2023-06-symmetrical/blob/6d2b64b6732fcfbd07c8217897dd233dbb6cd1f5/symmio-core/contracts/facets/PartyB/PartyBFacetImpl.sol#L152-L153\n> https://github.com/sherlock-audit/2023-06-symmetrical/blob/6d2b64b6732fcfbd07c8217897dd233dbb6cd1f5/symmio-core/contracts/libraries/LibAccount.sol#L78-L86\n> \n> Considering that, there is no point of doing something for any partyB because the harm is only to them. No body will create a position that is below/above the requested open price such that they are immediately liquidate after a small price change. \n> \n> \n> There is only 1 scenario that the partyA can be liquidatable which is only covered by this issue #77. This finding and the duplicates are missing the complex edge case. \n> \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**MoonKnightDev**\n\nFixed code PR link:\nhttps://github.com/SYMM-IO/symmio-core/pull/14\n\n**hrishibhat**\n\nResult:\nMedium\nHas duplicates\nAgree with the following comment from the Lead senior Watson:\n\n> The root cause/bug of this report and its duplicates is that the solvency check is performed against the old locked values instead of the adjusted/actual locked values.  So when the solvency check is performed against the old locked values, it might underestimate and assumes everything is well. However, the position is opened with the adjusted/actual locked values, not the old locked values. So the position might end up opening at a higher price (it was underestimated earlier), resulting the account to be liquidatable, \n\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [mstpr](https://github.com/sherlock-audit/2023-06-symmetrical-judging/issues/225/#issuecomment-1653589060): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/85",
  "Code": [
    {
      "filename": "symmio-core/contracts/facets/PartyB/PartyBFacetImpl.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"../../libraries/LibLockedValues.sol\";\nimport \"../../libraries/LibMuon.sol\";\nimport \"../../libraries/LibAccount.sol\";\nimport \"../../libraries/LibSolvency.sol\";\nimport \"../../libraries/LibQuote.sol\";\nimport \"../../storages/MAStorage.sol\";\nimport \"../../storages/QuoteStorage.sol\";\nimport \"../../storages/MuonStorage.sol\";\nimport \"../../storages/GlobalAppStorage.sol\";\nimport \"../../storages/AccountStorage.sol\";\nimport \"../../storages/SymbolStorage.sol\";\n\nlibrary PartyBFacetImpl {\n    using LockedValuesOps for LockedValues;\n\n    function lockQuote(uint256 quoteId, SingleUpnlSig memory upnlSig, bool increaseNonce) internal {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        Quote storage quote = quoteLayout.quotes[quoteId];\n        LibMuon.verifyPartyBUpnl(upnlSig, msg.sender, quote.partyA);\n        checkPartyBValidationToLockQuote(quoteId, upnlSig.upnl);\n        if (increaseNonce) {\n            accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n        }\n        quote.modifyTimestamp = block.timestamp;\n        quote.quoteStatus = QuoteStatus.LOCKED;\n        quote.partyB = msg.sender;\n        // lock funds for partyB\n        accountLayout.partyBPendingLockedBalances[msg.sender][quote.partyA].addQuote(quote);\n        quoteLayout.partyBPendingQuotes[msg.sender][quote.partyA].push(quote.id);\n    }\n\n    function unlockQuote(uint256 quoteId) internal returns (QuoteStatus) {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        require(quote.quoteStatus == QuoteStatus.LOCKED, \"PartyBFacet: Invalid state\");\n        if (block.timestamp > quote.deadline) {\n            QuoteStatus result = LibQuote.expireQuote(quoteId);\n            return result;\n        } else {\n            accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n            quote.modifyTimestamp = block.timestamp;\n            quote.quoteStatus = QuoteStatus.PENDING;\n            accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].subQuote(quote);\n            LibQuote.removeFromPartyBPendingQuotes(quote);\n            quote.partyB = address(0);\n            return QuoteStatus.PENDING;\n        }\n    }\n\n    function acceptCancelRequest(uint256 quoteId) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        require(quote.quoteStatus == QuoteStatus.CANCEL_PENDING, \"PartyBFacet: Invalid state\");\n        accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n        quote.modifyTimestamp = block.timestamp;\n        quote.quoteStatus = QuoteStatus.CANCELED;\n        accountLayout.pendingLockedBalances[quote.partyA].subQuote(quote);\n        accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].subQuote(quote);\n        // send trading Fee back to partyA\n        LibQuote.returnTradingFee(quoteId);\n\n        LibQuote.removeFromPendingQuotes(quote);\n    }\n\n    function checkPartyBValidationToLockQuote(uint256 quoteId, int256 upnl) internal view {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n\n        Quote storage quote = quoteLayout.quotes[quoteId];\n        require(quote.quoteStatus == QuoteStatus.PENDING, \"PartyBFacet: Invalid state\");\n        require(block.timestamp <= quote.deadline, \"PartyBFacet: Quote is expired\");\n        require(quoteId <= quoteLayout.lastId, \"PartyBFacet: Invalid quoteId\");\n        int256 availableBalance = LibAccount.partyBAvailableForQuote(\n            upnl,\n            msg.sender,\n            quote.partyA\n        );\n        require(availableBalance >= 0, \"PartyBFacet: Available balance is lower than zero\");\n        require(\n            uint256(availableBalance) >= quote.lockedValues.total(),\n            \"PartyBFacet: insufficient available balance\"\n        );\n        require(\n            !maLayout.partyBLiquidationStatus[msg.sender][quote.partyA],\n            \"PartyBFacet: PartyB isn't solvent\"\n        );\n        bool isValidPartyB;\n        if (quote.partyBsWhiteList.length == 0) {\n            require(msg.sender != quote.partyA, \"PartyBFacet: PartyA can't be partyB too\");\n            isValidPartyB = true;\n        } else {\n            for (uint8 index = 0; index < quote.partyBsWhiteList.length; index++) {\n                if (msg.sender == quote.partyBsWhiteList[index]) {\n                    isValidPartyB = true;\n                    break;\n                }\n            }\n        }\n        require(isValidPartyB, \"PartyBFacet: Sender isn't whitelisted\");\n    }\n\n    function openPosition(\n        uint256 quoteId,\n        uint256 filledAmount,\n        uint256 openedPrice,\n        PairUpnlAndPriceSig memory upnlSig\n    ) internal returns (uint256 currentId) {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        Quote storage quote = quoteLayout.quotes[quoteId];\n        require(\n            quote.quoteStatus == QuoteStatus.LOCKED ||\n            quote.quoteStatus == QuoteStatus.CANCEL_PENDING,\n            \"PartyBFacet: Invalid state\"\n        );\n        require(block.timestamp <= quote.deadline, \"PartyBFacet: Quote is expired\");\n        if (quote.orderType == OrderType.LIMIT) {\n            require(\n                quote.quantity >= filledAmount && filledAmount > 0,\n                \"PartyBFacet: Invalid filledAmount\"\n            );\n        } else {\n            require(quote.quantity == filledAmount, \"PartyBFacet: Invalid filledAmount\");\n        }\n        if (quote.positionType == PositionType.LONG) {\n            require(\n                openedPrice <= quote.requestedOpenPrice,\n                \"PartyBFacet: Opened price isn't valid\"\n            );\n        } else {\n            require(\n                openedPrice >= quote.requestedOpenPrice,\n                \"PartyBFacet: Opened price isn't valid\"\n            );\n        }\n        LibMuon.verifyPairUpnlAndPrice(upnlSig, quote.partyB, quote.partyA, quote.symbolId);\n\n        quote.openedPrice = openedPrice;\n        LibSolvency.isSolventAfterOpenPosition(quoteId, filledAmount, upnlSig);\n\n        accountLayout.partyANonces[quote.partyA] += 1;\n        accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n        quote.modifyTimestamp = block.timestamp;\n\n        LibQuote.removeFromPendingQuotes(quote);\n\n        if (quote.quantity == filledAmount) {\n            accountLayout.pendingLockedBalances[quote.partyA].subQuote(quote);\n            accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].subQuote(quote);\n\n            if (quote.orderType == OrderType.LIMIT) {\n                quote.lockedValues.mul(openedPrice).div(quote.requestedOpenPrice);\n            }\n            accountLayout.lockedBalances[quote.partyA].addQuote(quote);\n            accountLayout.partyBLockedBalances[quote.partyB][quote.partyA].addQuote(quote);\n        }\n        // partially fill\n        else {\n            currentId = ++quoteLayout.lastId;\n            QuoteStatus newStatus;\n            if (quote.quoteStatus == QuoteStatus.CANCEL_PENDING) {\n                newStatus = QuoteStatus.CANCELED;\n            } else {\n                newStatus = QuoteStatus.PENDING;\n                quoteLayout.partyAPendingQuotes[quote.partyA].push(currentId);\n            }\n            LockedValues memory filledLockedValues = LockedValues(\n                (quote.lockedValues.cva * filledAmount) / quote.quantity,\n                (quote.lockedValues.mm * filledAmount) / quote.quantity,\n                (quote.lockedValues.lf * filledAmount) / quote.quantity\n            );\n            LockedValues memory appliedFilledLockedValues = filledLockedValues;\n            appliedFilledLockedValues = appliedFilledLockedValues.mulMem(openedPrice);\n            appliedFilledLockedValues = appliedFilledLockedValues.divMem(quote.requestedOpenPrice);\n            // check that opened position is not minor position\n            require(\n                appliedFilledLockedValues.total() >=\n                SymbolStorage.layout().symbols[quote.symbolId].minAcceptableQuoteValue,\n                \"PartyBFacet: Quote value is low\"\n            );\n            // check that new pending position is not minor position\n            require(\n                (quote.lockedValues.total() - filledLockedValues.total()) >=\n                SymbolStorage.layout().symbols[quote.symbolId].minAcceptableQuoteValue,\n                \"PartyBFacet: Quote value is low\"\n            );\n\n            Quote memory q = Quote({\n                id: currentId,\n                partyBsWhiteList: quote.partyBsWhiteList,\n                symbolId: quote.symbolId,\n                positionType: quote.positionType,\n                orderType: quote.orderType,\n                openedPrice: 0,\n                requestedOpenPrice: quote.requestedOpenPrice,\n                marketPrice: quote.marketPrice,\n                quantity: quote.quantity - filledAmount,\n                closedAmount: 0,\n                lockedValues: LockedValues(0, 0, 0),\n                initialLockedValues: LockedValues(0, 0, 0),\n                maxInterestRate: quote.maxInterestRate,\n                partyA: quote.partyA,\n                partyB: address(0),\n                quoteStatus: newStatus,\n                avgClosedPrice: 0,\n                requestedClosePrice: 0,\n                parentId: quote.id,\n                createTimestamp: quote.createTimestamp,\n                modifyTimestamp: block.timestamp,\n                quantityToClose: 0,\n                deadline: quote.deadline\n            });\n\n            quoteLayout.quoteIdsOf[quote.partyA].push(currentId);\n            quoteLayout.quotes[currentId] = q;\n            Quote storage newQuote = quoteLayout.quotes[currentId];\n\n            if (newStatus == QuoteStatus.CANCELED) {\n                // send trading Fee back to partyA\n                LibQuote.returnTradingFee(currentId);\n                // part of quote has been filled and part of it has been canceled\n                accountLayout.pendingLockedBalances[quote.partyA].subQuote(quote);\n                accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].subQuote(\n                    quote\n                );\n            } else {\n                accountLayout.pendingLockedBalances[quote.partyA].sub(filledLockedValues);\n                accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].sub(\n                    filledLockedValues\n                );\n            }\n            newQuote.lockedValues = quote.lockedValues.sub(filledLockedValues);\n            newQuote.initialLockedValues = newQuote.lockedValues;\n            quote.quantity = filledAmount;\n            quote.lockedValues = appliedFilledLockedValues;\n\n            // lock with amount of filledAmount\n            accountLayout.lockedBalances[quote.partyA].addQuote(quote);\n            accountLayout.partyBLockedBalances[quote.partyB][quote.partyA].addQuote(quote);\n        }\n        quote.quoteStatus = QuoteStatus.OPENED;\n        LibQuote.addToOpenPositions(quoteId);\n    }\n\n    function fillCloseRequest(\n        uint256 quoteId,\n        uint256 filledAmount,\n        uint256 closedPrice,\n        PairUpnlAndPriceSig memory upnlSig\n    ) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        require(\n            quote.quoteStatus == QuoteStatus.CLOSE_PENDING ||\n            quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING,\n            \"PartyBFacet: Invalid state\"\n        );\n        require(block.timestamp <= quote.deadline, \"PartyBFacet: Quote is expired\");\n        if (quote.positionType == PositionType.LONG) {\n            require(\n                closedPrice >= quote.requestedClosePrice,\n                \"PartyBFacet: Closed price isn't valid\"\n            );\n        } else {\n            require(\n                closedPrice <= quote.requestedClosePrice,\n                \"PartyBFacet: Closed price isn't valid\"\n            );\n        }\n        if (quote.orderType == OrderType.LIMIT) {\n            require(quote.quantityToClose >= filledAmount, \"PartyBFacet: Invalid filledAmount\");\n        } else {\n            require(quote.quantityToClose == filledAmount, \"PartyBFacet: Invalid filledAmount\");\n        }\n\n        LibMuon.verifyPairUpnlAndPrice(upnlSig, quote.partyB, quote.partyA, quote.symbolId);\n        LibSolvency.isSolventAfterClosePosition(quoteId, filledAmount, closedPrice, upnlSig);\n\n        accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n        accountLayout.partyANonces[quote.partyA] += 1;\n        LibQuote.closeQuote(quote, filledAmount, closedPrice);\n    }\n\n    function acceptCancelCloseRequest(uint256 quoteId) internal {\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        require(\n            quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING,\n            \"PartyBFacet: Invalid state\"\n        );\n        AccountStorage.layout().partyBNonces[quote.partyB][quote.partyA] += 1;\n        quote.modifyTimestamp = block.timestamp;\n        quote.quoteStatus = QuoteStatus.OPENED;\n        quote.requestedClosePrice = 0;\n        quote.quantityToClose = 0;\n    }\n\n    function emergencyClosePosition(uint256 quoteId, PairUpnlAndPriceSig memory upnlSig) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        require(quote.quoteStatus == QuoteStatus.OPENED, \"PartyBFacet: Invalid state\");\n        LibMuon.verifyPairUpnlAndPrice(upnlSig, quote.partyB, quote.partyA, quote.symbolId);\n        uint256 filledAmount = LibQuote.quoteOpenAmount(quote);\n        quote.quantityToClose = filledAmount;\n        quote.requestedClosePrice = upnlSig.price;\n        LibSolvency.isSolventAfterClosePosition(quoteId, filledAmount, upnlSig.price, upnlSig);\n        accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n        accountLayout.partyANonces[quote.partyA] += 1;\n        LibQuote.closeQuote(quote, filledAmount, upnlSig.price);\n    }\n\n}"
    },
    {
      "filename": "symmio-core/contracts/facets/PartyB/PartyBFacetImpl.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"../../libraries/LibLockedValues.sol\";\nimport \"../../libraries/LibMuon.sol\";\nimport \"../../libraries/LibAccount.sol\";\nimport \"../../libraries/LibSolvency.sol\";\nimport \"../../libraries/LibQuote.sol\";\nimport \"../../storages/MAStorage.sol\";\nimport \"../../storages/QuoteStorage.sol\";\nimport \"../../storages/MuonStorage.sol\";\nimport \"../../storages/GlobalAppStorage.sol\";\nimport \"../../storages/AccountStorage.sol\";\nimport \"../../storages/SymbolStorage.sol\";\n\nlibrary PartyBFacetImpl {\n    using LockedValuesOps for LockedValues;\n\n    function lockQuote(uint256 quoteId, SingleUpnlSig memory upnlSig, bool increaseNonce) internal {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        Quote storage quote = quoteLayout.quotes[quoteId];\n        LibMuon.verifyPartyBUpnl(upnlSig, msg.sender, quote.partyA);\n        checkPartyBValidationToLockQuote(quoteId, upnlSig.upnl);\n        if (increaseNonce) {\n            accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n        }\n        quote.modifyTimestamp = block.timestamp;\n        quote.quoteStatus = QuoteStatus.LOCKED;\n        quote.partyB = msg.sender;\n        // lock funds for partyB\n        accountLayout.partyBPendingLockedBalances[msg.sender][quote.partyA].addQuote(quote);\n        quoteLayout.partyBPendingQuotes[msg.sender][quote.partyA].push(quote.id);\n    }\n\n    function unlockQuote(uint256 quoteId) internal returns (QuoteStatus) {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        require(quote.quoteStatus == QuoteStatus.LOCKED, \"PartyBFacet: Invalid state\");\n        if (block.timestamp > quote.deadline) {\n            QuoteStatus result = LibQuote.expireQuote(quoteId);\n            return result;\n        } else {\n            accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n            quote.modifyTimestamp = block.timestamp;\n            quote.quoteStatus = QuoteStatus.PENDING;\n            accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].subQuote(quote);\n            LibQuote.removeFromPartyBPendingQuotes(quote);\n            quote.partyB = address(0);\n            return QuoteStatus.PENDING;\n        }\n    }\n\n    function acceptCancelRequest(uint256 quoteId) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        require(quote.quoteStatus == QuoteStatus.CANCEL_PENDING, \"PartyBFacet: Invalid state\");\n        accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n        quote.modifyTimestamp = block.timestamp;\n        quote.quoteStatus = QuoteStatus.CANCELED;\n        accountLayout.pendingLockedBalances[quote.partyA].subQuote(quote);\n        accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].subQuote(quote);\n        // send trading Fee back to partyA\n        LibQuote.returnTradingFee(quoteId);\n\n        LibQuote.removeFromPendingQuotes(quote);\n    }\n\n    function checkPartyBValidationToLockQuote(uint256 quoteId, int256 upnl) internal view {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        MAStorage.Layout storage maLayout = MAStorage.layout();\n\n        Quote storage quote = quoteLayout.quotes[quoteId];\n        require(quote.quoteStatus == QuoteStatus.PENDING, \"PartyBFacet: Invalid state\");\n        require(block.timestamp <= quote.deadline, \"PartyBFacet: Quote is expired\");\n        require(quoteId <= quoteLayout.lastId, \"PartyBFacet: Invalid quoteId\");\n        int256 availableBalance = LibAccount.partyBAvailableForQuote(\n            upnl,\n            msg.sender,\n            quote.partyA\n        );\n        require(availableBalance >= 0, \"PartyBFacet: Available balance is lower than zero\");\n        require(\n            uint256(availableBalance) >= quote.lockedValues.total(),\n            \"PartyBFacet: insufficient available balance\"\n        );\n        require(\n            !maLayout.partyBLiquidationStatus[msg.sender][quote.partyA],\n            \"PartyBFacet: PartyB isn't solvent\"\n        );\n        bool isValidPartyB;\n        if (quote.partyBsWhiteList.length == 0) {\n            require(msg.sender != quote.partyA, \"PartyBFacet: PartyA can't be partyB too\");\n            isValidPartyB = true;\n        } else {\n            for (uint8 index = 0; index < quote.partyBsWhiteList.length; index++) {\n                if (msg.sender == quote.partyBsWhiteList[index]) {\n                    isValidPartyB = true;\n                    break;\n                }\n            }\n        }\n        require(isValidPartyB, \"PartyBFacet: Sender isn't whitelisted\");\n    }\n\n    function openPosition(\n        uint256 quoteId,\n        uint256 filledAmount,\n        uint256 openedPrice,\n        PairUpnlAndPriceSig memory upnlSig\n    ) internal returns (uint256 currentId) {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        Quote storage quote = quoteLayout.quotes[quoteId];\n        require(\n            quote.quoteStatus == QuoteStatus.LOCKED ||\n            quote.quoteStatus == QuoteStatus.CANCEL_PENDING,\n            \"PartyBFacet: Invalid state\"\n        );\n        require(block.timestamp <= quote.deadline, \"PartyBFacet: Quote is expired\");\n        if (quote.orderType == OrderType.LIMIT) {\n            require(\n                quote.quantity >= filledAmount && filledAmount > 0,\n                \"PartyBFacet: Invalid filledAmount\"\n            );\n        } else {\n            require(quote.quantity == filledAmount, \"PartyBFacet: Invalid filledAmount\");\n        }\n        if (quote.positionType == PositionType.LONG) {\n            require(\n                openedPrice <= quote.requestedOpenPrice,\n                \"PartyBFacet: Opened price isn't valid\"\n            );\n        } else {\n            require(\n                openedPrice >= quote.requestedOpenPrice,\n                \"PartyBFacet: Opened price isn't valid\"\n            );\n        }\n        LibMuon.verifyPairUpnlAndPrice(upnlSig, quote.partyB, quote.partyA, quote.symbolId);\n\n        quote.openedPrice = openedPrice;\n        LibSolvency.isSolventAfterOpenPosition(quoteId, filledAmount, upnlSig);\n\n        accountLayout.partyANonces[quote.partyA] += 1;\n        accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n        quote.modifyTimestamp = block.timestamp;\n\n        LibQuote.removeFromPendingQuotes(quote);\n\n        if (quote.quantity == filledAmount) {\n            accountLayout.pendingLockedBalances[quote.partyA].subQuote(quote);\n            accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].subQuote(quote);\n\n            if (quote.orderType == OrderType.LIMIT) {\n                quote.lockedValues.mul(openedPrice).div(quote.requestedOpenPrice);\n            }\n            accountLayout.lockedBalances[quote.partyA].addQuote(quote);\n            accountLayout.partyBLockedBalances[quote.partyB][quote.partyA].addQuote(quote);\n        }\n        // partially fill\n        else {\n            currentId = ++quoteLayout.lastId;\n            QuoteStatus newStatus;\n            if (quote.quoteStatus == QuoteStatus.CANCEL_PENDING) {\n                newStatus = QuoteStatus.CANCELED;\n            } else {\n                newStatus = QuoteStatus.PENDING;\n                quoteLayout.partyAPendingQuotes[quote.partyA].push(currentId);\n            }\n            LockedValues memory filledLockedValues = LockedValues(\n                (quote.lockedValues.cva * filledAmount) / quote.quantity,\n                (quote.lockedValues.mm * filledAmount) / quote.quantity,\n                (quote.lockedValues.lf * filledAmount) / quote.quantity\n            );\n            LockedValues memory appliedFilledLockedValues = filledLockedValues;\n            appliedFilledLockedValues = appliedFilledLockedValues.mulMem(openedPrice);\n            appliedFilledLockedValues = appliedFilledLockedValues.divMem(quote.requestedOpenPrice);\n            // check that opened position is not minor position\n            require(\n                appliedFilledLockedValues.total() >=\n                SymbolStorage.layout().symbols[quote.symbolId].minAcceptableQuoteValue,\n                \"PartyBFacet: Quote value is low\"\n            );\n            // check that new pending position is not minor position\n            require(\n                (quote.lockedValues.total() - filledLockedValues.total()) >=\n                SymbolStorage.layout().symbols[quote.symbolId].minAcceptableQuoteValue,\n                \"PartyBFacet: Quote value is low\"\n            );\n\n            Quote memory q = Quote({\n                id: currentId,\n                partyBsWhiteList: quote.partyBsWhiteList,\n                symbolId: quote.symbolId,\n                positionType: quote.positionType,\n                orderType: quote.orderType,\n                openedPrice: 0,\n                requestedOpenPrice: quote.requestedOpenPrice,\n                marketPrice: quote.marketPrice,\n                quantity: quote.quantity - filledAmount,\n                closedAmount: 0,\n                lockedValues: LockedValues(0, 0, 0),\n                initialLockedValues: LockedValues(0, 0, 0),\n                maxInterestRate: quote.maxInterestRate,\n                partyA: quote.partyA,\n                partyB: address(0),\n                quoteStatus: newStatus,\n                avgClosedPrice: 0,\n                requestedClosePrice: 0,\n                parentId: quote.id,\n                createTimestamp: quote.createTimestamp,\n                modifyTimestamp: block.timestamp,\n                quantityToClose: 0,\n                deadline: quote.deadline\n            });\n\n            quoteLayout.quoteIdsOf[quote.partyA].push(currentId);\n            quoteLayout.quotes[currentId] = q;\n            Quote storage newQuote = quoteLayout.quotes[currentId];\n\n            if (newStatus == QuoteStatus.CANCELED) {\n                // send trading Fee back to partyA\n                LibQuote.returnTradingFee(currentId);\n                // part of quote has been filled and part of it has been canceled\n                accountLayout.pendingLockedBalances[quote.partyA].subQuote(quote);\n                accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].subQuote(\n                    quote\n                );\n            } else {\n                accountLayout.pendingLockedBalances[quote.partyA].sub(filledLockedValues);\n                accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].sub(\n                    filledLockedValues\n                );\n            }\n            newQuote.lockedValues = quote.lockedValues.sub(filledLockedValues);\n            newQuote.initialLockedValues = newQuote.lockedValues;\n            quote.quantity = filledAmount;\n            quote.lockedValues = appliedFilledLockedValues;\n\n            // lock with amount of filledAmount\n            accountLayout.lockedBalances[quote.partyA].addQuote(quote);\n            accountLayout.partyBLockedBalances[quote.partyB][quote.partyA].addQuote(quote);\n        }\n        quote.quoteStatus = QuoteStatus.OPENED;\n        LibQuote.addToOpenPositions(quoteId);\n    }\n\n    function fillCloseRequest(\n        uint256 quoteId,\n        uint256 filledAmount,\n        uint256 closedPrice,\n        PairUpnlAndPriceSig memory upnlSig\n    ) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        require(\n            quote.quoteStatus == QuoteStatus.CLOSE_PENDING ||\n            quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING,\n            \"PartyBFacet: Invalid state\"\n        );\n        require(block.timestamp <= quote.deadline, \"PartyBFacet: Quote is expired\");\n        if (quote.positionType == PositionType.LONG) {\n            require(\n                closedPrice >= quote.requestedClosePrice,\n                \"PartyBFacet: Closed price isn't valid\"\n            );\n        } else {\n            require(\n                closedPrice <= quote.requestedClosePrice,\n                \"PartyBFacet: Closed price isn't valid\"\n            );\n        }\n        if (quote.orderType == OrderType.LIMIT) {\n            require(quote.quantityToClose >= filledAmount, \"PartyBFacet: Invalid filledAmount\");\n        } else {\n            require(quote.quantityToClose == filledAmount, \"PartyBFacet: Invalid filledAmount\");\n        }\n\n        LibMuon.verifyPairUpnlAndPrice(upnlSig, quote.partyB, quote.partyA, quote.symbolId);\n        LibSolvency.isSolventAfterClosePosition(quoteId, filledAmount, closedPrice, upnlSig);\n\n        accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n        accountLayout.partyANonces[quote.partyA] += 1;\n        LibQuote.closeQuote(quote, filledAmount, closedPrice);\n    }\n\n    function acceptCancelCloseRequest(uint256 quoteId) internal {\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n\n        require(\n            quote.quoteStatus == QuoteStatus.CANCEL_CLOSE_PENDING,\n            \"PartyBFacet: Invalid state\"\n        );\n        AccountStorage.layout().partyBNonces[quote.partyB][quote.partyA] += 1;\n        quote.modifyTimestamp = block.timestamp;\n        quote.quoteStatus = QuoteStatus.OPENED;\n        quote.requestedClosePrice = 0;\n        quote.quantityToClose = 0;\n    }\n\n    function emergencyClosePosition(uint256 quoteId, PairUpnlAndPriceSig memory upnlSig) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        require(quote.quoteStatus == QuoteStatus.OPENED, \"PartyBFacet: Invalid state\");\n        LibMuon.verifyPairUpnlAndPrice(upnlSig, quote.partyB, quote.partyA, quote.symbolId);\n        uint256 filledAmount = LibQuote.quoteOpenAmount(quote);\n        quote.quantityToClose = filledAmount;\n        quote.requestedClosePrice = upnlSig.price;\n        LibSolvency.isSolventAfterClosePosition(quoteId, filledAmount, upnlSig.price, upnlSig);\n        accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n        accountLayout.partyANonces[quote.partyA] += 1;\n        LibQuote.closeQuote(quote, filledAmount, upnlSig.price);\n    }\n\n}"
    },
    {
      "filename": "symmio-core/contracts/facets/PartyB/PartyBFacetImpl.sol",
      "content": "// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\n// This contract is licensed under the SYMM Core Business Source License 1.1\n// Copyright (c) 2023 Symmetry Labs AG\n// For more information, see https://docs.symm.io/legal-disclaimer/license\npragma solidity >=0.8.18;\n\nimport \"../../libraries/LibLockedValues.sol\";\nimport \"../../libraries/LibMuon.sol\";\nimport \"../../libraries/LibAccount.sol\";\nimport \"../../libraries/LibSolvency.sol\";\nimport \"../../libraries/LibQuote.sol\";\nimport \"../../storages/MAStorage.sol\";\nimport \"../../storages/QuoteStorage.sol\";\nimport \"../../storages/MuonStorage.sol\";\nimport \"../../storages/GlobalAppStorage.sol\";\nimport \"../../storages/AccountStorage.sol\";\nimport \"../../storages/SymbolStorage.sol\";\n\nlibrary PartyBFacetImpl {\n    using LockedValuesOps for LockedValues;\n\n    function lockQuote(uint256 quoteId, SingleUpnlSig memory upnlSig, bool increaseNonce) internal {\n        QuoteStorage.Layout storage quoteLayout = QuoteStorage.layout();\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        Quote storage quote = quoteLayout.quotes[quoteId];\n        LibMuon.verifyPartyBUpnl(upnlSig, msg.sender, quote.partyA);\n        checkPartyBValidationToLockQuote(quoteId, upnlSig.upnl);\n        if (increaseNonce) {\n            accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n        }\n        quote.modifyTimestamp = block.timestamp;\n        quote.quoteStatus = QuoteStatus.LOCKED;\n        quote.partyB = msg.sender;\n        // lock funds for partyB\n        accountLayout.partyBPendingLockedBalances[msg.sender][quote.partyA].addQuote(quote);\n        quoteLayout.partyBPendingQuotes[msg.sender][quote.partyA].push(quote.id);\n    }\n\n    function unlockQuote(uint256 quoteId) internal returns (QuoteStatus) {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        require(quote.quoteStatus == QuoteStatus.LOCKED, \"PartyBFacet: Invalid state\");\n        if (block.timestamp > quote.deadline) {\n            QuoteStatus result = LibQuote.expireQuote(quoteId);\n            return result;\n        } else {\n            accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n            quote.modifyTimestamp = block.timestamp;\n            quote.quoteStatus = QuoteStatus.PENDING;\n            accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].subQuote(quote);\n            LibQuote.removeFromPartyBPendingQuotes(quote);\n            quote.partyB = address(0);\n            return QuoteStatus.PENDING;\n        }\n    }\n\n    function acceptCancelRequest(uint256 quoteId) internal {\n        AccountStorage.Layout storage accountLayout = AccountStorage.layout();\n\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\n        require(quote.quoteStatus == QuoteStatus.CANCEL_PENDING, \"PartyBFacet: Invalid state\");\n        accountLayout.partyBNonces[quote.partyB][quote.partyA] += 1;\n        quote.modifyTimestamp = block.timestamp;\n        quote.quoteStatus = QuoteStatus.CANCELED;\n        accountLayout.pendingLockedBalances[quote.partyA].subQuote(quote);\n        accountLayout.partyBPendingLockedBalances[quote.partyB][quote.partyA].subQuote(qu"
    }
  ]
}