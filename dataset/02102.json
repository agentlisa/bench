{
  "Title": "M-17: Slippage is not respected if PnL swap associated with a decrease order fails",
  "Content": "# Issue M-17: Slippage is not respected if PnL swap associated with a decrease order fails \n\nSource: https://github.com/sherlock-audit/2023-02-gmx-judging/issues/159 \n\n## Found by \nIllIllI\n\n## Summary\n\nAfter a position has been decreased, the user has an option to convert the PnL token to any other token via a swap.\n\n\n## Vulnerability Detail\n\nIf the swap fails (which is where the slippage is checked), the tokens are sent directly to the user, without checking whether there was slippage\n\n\n## Impact\n\nA user will get back fewer tokens than they expect, if there was a large price impact, and the subsequent swap fails due to e.g. the market being temporarily disabled, or the swap impact being too large, or a token being swapped through is paused\n\n\n## Code Snippet\n\nFunds are sent back directly, without checking for slippage:\n```solidity\n// File: gmx-synthetics/contracts/order/DecreaseOrderUtils.sol : DecreaseOrderUtils._handleSwapError()   #1\n\n168            emit SwapUtils.SwapReverted(reason, reasonBytes);\n169    \n170            MarketToken(payable(order.market())).transferOut(\n171                result.outputToken,\n172                order.receiver(),\n173 @>             result.outputAmount,\n174                order.shouldUnwrapNativeToken()\n175            );\n176:       }\n```\nhttps://github.com/sherlock-audit/2023-02-gmx/blob/main/gmx-synthetics/contracts/order/DecreaseOrderUtils.sol#L168-L176\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nCalculate whether the USD value of `outputToken` is equivalent to the `minOutputAmount` expected by the order, and revert if it's less than required\n\n\n\n\n## Discussion\n\n**xvi10**\n\nFix in https://github.com/gmx-io/gmx-synthetics/pull/108\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/6",
  "Code": [
    {
      "filename": "gmx-synthetics/contracts/order/DecreaseOrderUtils.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"./BaseOrderUtils.sol\";\nimport \"../swap/SwapUtils.sol\";\nimport \"../position/DecreasePositionUtils.sol\";\nimport \"../order/OrderStoreUtils.sol\";\nimport \"../utils/ErrorUtils.sol\";\n\n// @title DecreaseOrderUtils\n// @dev Library for functions to help with processing a decrease order\nlibrary DecreaseOrderUtils {\n    using Position for Position.Props;\n    using Order for Order.Props;\n    using Array for uint256[];\n\n    // @dev process a decrease order\n    // @param params BaseOrderUtils.ExecuteOrderParams\n    function processOrder(BaseOrderUtils.ExecuteOrderParams memory params) external {\n        Order.Props memory order = params.order;\n        MarketUtils.validateEnabledMarket(params.contracts.dataStore, params.market);\n        MarketUtils.validatePositionMarket(params.market);\n\n        bytes32 positionKey = PositionUtils.getPositionKey(order.account(), order.market(), order.initialCollateralToken(), order.isLong());\n        Position.Props memory position = PositionStoreUtils.get(params.contracts.dataStore, positionKey);\n        PositionUtils.validateNonEmptyPosition(position);\n\n        validateOracleBlockNumbers(\n            params.minOracleBlockNumbers,\n            params.maxOracleBlockNumbers,\n            order.orderType(),\n            order.updatedAtBlock(),\n            position.increasedAtBlock(),\n            position.decreasedAtBlock()\n        );\n\n        DecreasePositionUtils.DecreasePositionResult memory result = DecreasePositionUtils.decreasePosition(\n            PositionUtils.UpdatePositionParams(\n                params.contracts,\n                params.market,\n                order,\n                params.key,\n                position,\n                positionKey\n            )\n        );\n\n        OrderStoreUtils.remove(params.contracts.dataStore, params.key, order.account());\n\n        // if the pnlToken and the collateralToken are different\n        // and if a swap fails or no swap was requested\n        // then it is possible to receive two separate tokens from decreasing\n        // the position\n        // transfer the two tokens to the user in this case and skip processing\n        // the swapPath\n        if (result.secondaryOutputAmount > 0) {\n            MarketToken(payable(order.market())).transferOut(\n                result.outputToken,\n                order.receiver(),\n                result.outputAmount,\n                order.shouldUnwrapNativeToken()\n            );\n\n            MarketToken(payable(order.market())).transferOut(\n                result.secondaryOutputToken,\n                order.receiver(),\n                result.secondaryOutputAmount,\n                order.shouldUnwrapNativeToken()\n            );\n\n            return;\n        }\n\n        if (order.swapPath().length == 0) {\n            MarketToken(payable(order.market())).transferOut(\n                result.outputToken,\n                order.receiver(),\n                result.outputAmount,\n                order.shouldUnwrapNativeToken()\n            );\n        } else {\n            try params.contracts.swapHandler.swap(\n                SwapUtils.SwapParams(\n                    params.contracts.dataStore,\n                    params.contracts.eventEmitter,\n                    params.contracts.oracle,\n                    Bank(payable(order.market())),\n                    result.outputToken,\n                    result.outputAmount,\n                    params.swapPathMarkets,\n                    order.minOutputAmount(),\n                    order.receiver(),\n                    order.shouldUnwrapNativeToken()\n                )\n            ) returns (address /* tokenOut */, uint256 /* swapOutputAmount */) {\n            } catch Error(string memory reason) {\n                _handleSwapError(\n                    order,\n                    result,\n                    reason,\n                    \"\"\n                );\n            } catch (bytes memory reasonBytes) {\n                (string memory reason, /* bool hasRevertMessage */) = ErrorUtils.getRevertMessage(reasonBytes);\n                _handleSwapError(\n                    order,\n                    result,\n                    reason,\n                    reasonBytes\n                );\n            }\n        }\n    }\n\n    // @dev validate the oracle block numbers used for the prices in the oracle\n    // @param oracleBlockNumbers the oracle block numbers\n    // @param orderType the order type\n    // @param orderUpdatedAtBlock the block at which the order was last updated\n    // @param positionIncreasedAtBlock the block at which the position was last increased\n    // @param positionDecreasedAtBlock the block at which the position was last decreased\n    function validateOracleBlockNumbers(\n        uint256[] memory minOracleBlockNumbers,\n        uint256[] memory maxOracleBlockNumbers,\n        Order.OrderType orderType,\n        uint256 orderUpdatedAtBlock,\n        uint256 positionIncreasedAtBlock,\n        uint256 positionDecreasedAtBlock\n    ) internal pure {\n        if (orderType == Order.OrderType.MarketDecrease) {\n            OracleUtils.validateBlockNumberWithinRange(\n                minOracleBlockNumbers,\n                maxOracleBlockNumbers,\n                orderUpdatedAtBlock\n            );\n            return;\n        }\n\n        if (\n            orderType == Order.OrderType.LimitDecrease ||\n            orderType == Order.OrderType.StopLossDecrease\n        ) {\n            uint256 latestUpdatedAtBlock = orderUpdatedAtBlock > positionIncreasedAtBlock ? orderUpdatedAtBlock : positionIncreasedAtBlock;\n            if (!minOracleBlockNumbers.areGreaterThan(latestUpdatedAtBlock)) {\n                OracleUtils.revertOracleBlockNumbersAreSmallerThanRequired(minOracleBlockNumbers, latestUpdatedAtBlock);\n            }\n            return;\n        }\n\n        if (orderType == Order.OrderType.Liquidation) {\n            uint256 latestUpdatedAtBlock = positionIncreasedAtBlock > positionDecreasedAtBlock ? positionIncreasedAtBlock : positionDecreasedAtBlock;\n\n            if (!minOracleBlockNumbers.areGreaterThan(latestUpdatedAtBlock)) {\n                OracleUtils.revertOracleBlockNumbersAreSmallerThanRequired(minOracleBlockNumbers, latestUpdatedAtBlock);\n            }\n            return;\n        }\n\n        BaseOrderUtils.revertUnsupportedOrderType();\n    }\n\n    function _handleSwapError(\n        Order.Props memory order,\n        DecreasePositionUtils.DecreasePositionResult memory result,\n        string memory reason,\n        bytes memory reasonBytes\n    ) internal {\n        emit SwapUtils.SwapReverted(reason, reasonBytes);\n\n        MarketToken(payable(order.market())).transferOut(\n            result.outputToken,\n            order.receiver(),\n            result.outputAmount,\n            order.shouldUnwrapNativeToken()\n        );\n    }\n}"
    }
  ]
}