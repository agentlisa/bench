{
  "Title": "[H-01] Wrong shortfall calculation",
  "Content": "_Submitted by kenzo_\n\nEvery time an account is settled, if shortfall is created, due to a wrong calculation shortfall will double in size and add the new shortfall.\n\n#### Impact\n\nLoss of funds: users won't be able to withdraw the correct amount of funds. Somebody would have to donate funds to resolve the wrong shortfall.\n\n#### Proof of Concept\n\nWe can see in the `settleAccount` of `OptimisticLedger` that `self.shortfall` ends up being `self.shortfall+self.shortfall+newShortfall`: [(Code ref)](https://github.com/code-423n4/2021-12-perennial/blob/main/protocol/contracts/collateral/types/OptimisticLedger.sol#L63:#L74)\n\n```solidity\nfunction settleAccount(OptimisticLedger storage self, address account, Fixed18 amount)\ninternal returns (UFixed18 shortfall) {\n    Fixed18 newBalance = Fixed18Lib.from(self.balances[account]).add(amount);\n\n    if (newBalance.sign() == -1) {\n        shortfall = self.shortfall.add(newBalance.abs());\n        newBalance = Fixed18Lib.ZERO;\n    }\n\n    self.balances[account] = newBalance.abs();\n    self.shortfall = self.shortfall.add(shortfall);\n}\n```\n\nAdditionally, you can add the following line to the \"shortfall reverts if depleted\" test in `Collateral.test.js`, line 190:\n\n```js\nawait collateral.connect(productSigner).settleAccount(userB.address, -50)\n```\n\nPreviously the test product had 50 shortfall. Now we added 50 more, but the test will print that the actual shortfall is 150, and not 100 as it should be.\n\n#### Recommended Mitigation Steps\n\nMove the setting of `self.shortfall` to inside the if function and change the line to:\n```\n    self.shortfall = shortfall\n``` \n\n**[kbrizzle (Perennial) confirmed](https://github.com/code-423n4/2021-12-perennial-findings/issues/18#issuecomment-995416504):**\n > Excellent find ðŸ™ \n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-12-perennial-findings/issues/18#issuecomment-1001280292):**\n > Agree with the finding `shortfall = self.shortfall.add(newBalance.abs());` is already shortfal + newBalance.abs()\n> So performing line `73` `self.shortfall = self.shortfall.add(shortfall);` is addingÂ `shortfall` again\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2021-12-perennial",
  "Code": [
    {
      "filename": "protocol/contracts/collateral/types/OptimisticLedger.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../utils/types/UFixed18.sol\";\n\n/// @dev OptimisticLedger type\nstruct OptimisticLedger {\n    /// @dev Individual account collateral balances\n    mapping(address => UFixed18) balances;\n\n    /// @dev Total ledger collateral balance\n    UFixed18 total;\n\n    /// @dev Total ledger collateral shortfall\n    UFixed18 shortfall;\n}\n\n/**\n * @title OptimisticLedgerLib\n * @notice Library that manages a global vs account ledger where the global ledger is settled separately,\n *         and ahead of, the user-level accounts.\n * @dev    Ensures that no more collateral leaves the ledger than goes it, while allowing user-level accounts\n *         to settle as a follow up step. Overdrafts on the user-level are accounted as \"shortall\". Shortfall\n *         in the system is the quantity of insolvency that can be optionally resolved by the ledger owner.\n *         Until the shortfall is resolved, collateral may be withdrawn from the ledger on a FCFS basis. However\n *         once the ledger total has been depleted, users will not be able to withdraw even if they have non-zero\n *         user level balances until the shortfall is resolved, recapitalizing the ledger.\n */\nlibrary OptimisticLedgerLib {\n    using UFixed18Lib for UFixed18;\n    using Fixed18Lib for Fixed18;\n\n    /**\n     * @notice Credits `account` with `amount` collateral\n     * @param self The struct to operate on\n     * @param account Account to credit collateral to\n     * @param amount Amount of collateral to credit\n     */\n    function creditAccount(OptimisticLedger storage self, address account, UFixed18 amount) internal {\n        self.balances[account] = self.balances[account].add(amount);\n        self.total = self.total.add(amount);\n    }\n\n    /**\n     * @notice Debits `account` `amount` collateral\n     * @param self The struct to operate on\n     * @param account Account to debit collateral from\n     * @param amount Amount of collateral to debit\n     */\n    function debitAccount(OptimisticLedger storage self, address account, UFixed18 amount) internal {\n        self.balances[account] = self.balances[account].sub(amount);\n        self.total = self.total.sub(amount);\n    }\n\n    /**\n     * @notice Credits `account` with `amount` collateral\n     * @dev Funds come from inside the product, not totals are updated\n     *      Shortfall is created if more funds are debited from an account than exist\n     * @param self The struct to operate on\n     * @param account Account to credit collateral to\n     * @param amount Amount of collateral to credit\n     */\n    function settleAccount(OptimisticLedger storage self, address account, Fixed18 amount)\n    internal returns (UFixed18 shortfall) {\n        Fixed18 newBalance = Fixed18Lib.from(self.balances[account]).add(amount);\n\n        if (newBalance.sign() == -1) {\n            shortfall = self.shortfall.add(newBalance.abs());\n            newBalance = Fixed18Lib.ZERO;\n        }\n\n        self.balances[account] = newBalance.abs();\n        self.shortfall = self.shortfall.add(shortfall);\n    }\n\n    /**\n     * @notice Debits ledger globally `amount` collateral\n     * @dev Removes balance from total that is accounted for elsewhere (e.g. product-level accumulators)\n     * @param self The struct to operate on\n     * @param amount Amount of collateral to debit\n     */\n    function debit(OptimisticLedger storage self, UFixed18 amount) internal {\n        self.total = self.total.sub(amount);\n    }\n\n    /**\n     * @notice Reduces the amount of collateral shortfall in the ledger\n     * @param self The struct to operate on\n     * @param amount Amount of shortfall to resolve\n     */\n    function resolve(OptimisticLedger storage self, UFixed18 amount) internal {\n        self.shortfall = self.shortfall.sub(amount);\n        self.total = self.total.add(amount);\n    }\n}"
    }
  ]
}