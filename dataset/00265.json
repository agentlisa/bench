{
  "Title": "Batch Commitments Can Make Use of Arbitrary Library",
  "Content": "In the [`commitBatch` function](https://github.com/scroll-tech/scroll/blob/8bd4277c13ec17670963848a24e4e1b135504f3f/contracts/src/L1/rollup/ScrollChain.sol#L267) of the `ScrollChain` contract, the [`_version`](https://github.com/scroll-tech/scroll/blob/8bd4277c13ec17670963848a24e4e1b135504f3f/contracts/src/L1/rollup/ScrollChain.sol#L268) parameter is used to define whether the version of the batch to commit is 0 or 1, as any other values will cause the `commitBatch` function to revert. If the [`_version` is 0](https://github.com/scroll-tech/scroll/blob/8bd4277c13ec17670963848a24e4e1b135504f3f/contracts/src/L1/rollup/ScrollChain.sol#L288-L310), the `_commitChunksV0` function, as well as the `BatchHeaderV0Codec` library, will be used to handle the data. Otherwise, if the [`_version` is 1](https://github.com/scroll-tech/scroll/blob/8bd4277c13ec17670963848a24e4e1b135504f3f/contracts/src/L1/rollup/ScrollChain.sol#L311-L335), the function will use the `_commitChunksV1` function, as well as the `BatchHeaderV1Codec` library.\n\n\nHowever, the sequencer can arbitrarily define the `_version` value. This means a version 0 batch commitment can be forced to follow a version 1 commitment path and vice versa. For instance, if a version 1 batch was committed, but the `_version` parameter is set to 0, the `commitBatch` function will gracefully pass without throwing any error.\n\n\nNote that this scenario has a low likelihood since, at the time of this audit, the `commitBatch` function is guarded by the `OnlySequencer` modifier, which allows access only to the Scroll relayer EOAs. However, the severity of this issue could increase if additional parties are granted the sequencer role in the future.\n\n\nConsider validating the `_version` parameter to match the version of the committed batch.\n\n\n***Update:** Acknowledged, will resolve. The Scroll team added [PR 1264](https://github.com/scroll-tech/scroll/pull/1264) at [commit c03cdad](https://github.com/scroll-tech/scroll/commit/c03cdada92b6c4bd6087298295a047cc66c8957f) explaining the rationale of addressing this potential risk in the future:*\n\n\n\n> *We initially excluded the KZG commitment by assuming lack of presence of malicious Sequencer entities that collude with malicious Provers in the current threat model. Upon considering such a scenario (which is ruled out at present, but could eventually be possible in a decentralized setting), and as per cryptographic hygiene, we decided to include the KZG commitment (in the form of the blob's versioned hash, i.e. a hash of the commitment) while computing the Fiat-Shamir challenge. Since the blob's versioned hash is accepted as private witness to our circuits, we also include it in the preimage of the batch's public input hash (the public instance to our circuits).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/src/L1/rollup/ScrollChain.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.24;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\nimport {IL1MessageQueue} from \"./IL1MessageQueue.sol\";\nimport {IScrollChain} from \"./IScrollChain.sol\";\nimport {BatchHeaderV0Codec} from \"../../libraries/codec/BatchHeaderV0Codec.sol\";\nimport {BatchHeaderV1Codec} from \"../../libraries/codec/BatchHeaderV1Codec.sol\";\nimport {ChunkCodecV0} from \"../../libraries/codec/ChunkCodecV0.sol\";\nimport {ChunkCodecV1} from \"../../libraries/codec/ChunkCodecV1.sol\";\nimport {IRollupVerifier} from \"../../libraries/verifier/IRollupVerifier.sol\";\n\n// solhint-disable no-inline-assembly\n// solhint-disable reason-string\n\n/// @title ScrollChain\n/// @notice This contract maintains data for the Scroll rollup.\ncontract ScrollChain is OwnableUpgradeable, PausableUpgradeable, IScrollChain {\n    /**********\n     * Errors *\n     **********/\n\n    /// @dev Thrown when the given account is not EOA account.\n    error ErrorAccountIsNotEOA();\n\n    /// @dev Thrown when committing a committed batch.\n    error ErrorBatchIsAlreadyCommitted();\n\n    /// @dev Thrown when finalizing a verified batch.\n    error ErrorBatchIsAlreadyVerified();\n\n    /// @dev Thrown when committing empty batch (batch without chunks)\n    error ErrorBatchIsEmpty();\n\n    /// @dev Thrown when call precompile failed.\n    error ErrorCallPointEvaluationPrecompileFailed();\n\n    /// @dev Thrown when the caller is not prover.\n    error ErrorCallerIsNotProver();\n\n    /// @dev Thrown when the caller is not sequencer.\n    error ErrorCallerIsNotSequencer();\n\n    /// @dev Thrown when the transaction has multiple blobs.\n    error ErrorFoundMultipleBlob();\n\n    /// @dev Thrown when some fields are not zero in genesis batch.\n    error ErrorGenesisBatchHasNonZeroField();\n\n    /// @dev Thrown when importing genesis batch twice.\n    error ErrorGenesisBatchImported();\n\n    /// @dev Thrown when data hash in genesis batch is zero.\n    error ErrorGenesisDataHashIsZero();\n\n    /// @dev Thrown when the parent batch hash in genesis batch is zero.\n    error ErrorGenesisParentBatchHashIsNonZero();\n\n    /// @dev Thrown when the l2 transaction is incomplete.\n    error ErrorIncompleteL2TransactionData();\n\n    /// @dev Thrown when the batch hash is incorrect.\n    error ErrorIncorrectBatchHash();\n\n    /// @dev Thrown when the batch index is incorrect.\n    error ErrorIncorrectBatchIndex();\n\n    /// @dev Thrown when the bitmap length is incorrect.\n    error ErrorIncorrectBitmapLength();\n\n    /// @dev Thrown when the previous state root doesn't match stored one.\n    error ErrorIncorrectPreviousStateRoot();\n\n    /// @dev Thrown when the batch header version is invalid.\n    error ErrorInvalidBatchHeaderVersion();\n\n    /// @dev Thrown when the last message is skipped.\n    error ErrorLastL1MessageSkipped();\n\n    /// @dev Thrown when no blob found in the transaction.\n    error ErrorNoBlobFound();\n\n    /// @dev Thrown when the number of transactions is less than number of L1 message in one block.\n    error ErrorNumTxsLessThanNumL1Msgs();\n\n    /// @dev Thrown when the given previous state is zero.\n    error ErrorPreviousStateRootIsZero();\n\n    /// @dev Thrown when the number of batches to revert is zero.\n    error ErrorRevertZeroBatches();\n\n    /// @dev Thrown when the reverted batches are not in the ending of commited batch chain.\n    error ErrorRevertNotStartFromEnd();\n\n    /// @dev Thrown when reverting a finialized batch.\n    error ErrorRevertFinalizedBatch();\n\n    /// @dev Thrown when the given state root is zero.\n    error ErrorStateRootIsZero();\n\n    /// @dev Thrown when a chunk contains too many transactions.\n    error ErrorTooManyTxsInOneChunk();\n\n    /// @dev Thrown when the precompile output is incorrect.\n    error ErrorUnexpectedPointEvaluationPrecompileOutput();\n\n    /// @dev Thrown when the given address is `address(0)`.\n    error ErrorZeroAddress();\n\n    /*************\n     * Constants *\n     *************/\n\n    /// @dev Address of the point evaluation precompile used for EIP-4844 blob verification.\n    address constant POINT_EVALUATION_PRECOMPILE_ADDR = address(0x0A);\n\n    /// @dev BLS Modulus value defined in EIP-4844 and the magic value returned from a successful call to the\n    /// point evaluation precompile\n    uint256 constant BLS_MODULUS = 52435875175126190479447740508185965837690552500527637822603658699938581184513;\n\n    /// @notice The chain id of the corresponding layer 2 chain.\n    uint64 public immutable layer2ChainId;\n\n    /// @notice The address of L1MessageQueue contract.\n    address public immutable messageQueue;\n\n    /// @notice The address of RollupVerifier.\n    address public immutable verifier;\n\n    /*************\n     * Variables *\n     *************/\n\n    /// @notice The maximum number of transactions allowed in each chunk.\n    uint256 public maxNumTxInChunk;\n\n    /// @dev The storage slot used as L1MessageQueue contract, which is deprecated now.\n    address private __messageQueue;\n\n    /// @dev The storage slot used as RollupVerifier contract, which is deprecated now.\n    address private __verifier;\n\n    /// @notice Whether an account is a sequencer.\n    mapping(address => bool) public isSequencer;\n\n    /// @notice Whether an account is a prover.\n    mapping(address => bool) public isProver;\n\n    /// @inheritdoc IScrollChain\n    uint256 public override lastFinalizedBatchIndex;\n\n    /// @inheritdoc IScrollChain\n    mapping(uint256 => bytes32) public override committedBatches;\n\n    /// @inheritdoc IScrollChain\n    mapping(uint256 => bytes32) public override finalizedStateRoots;\n\n    /// @inheritdoc IScrollChain\n    mapping(uint256 => bytes32) public override withdrawRoots;\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier OnlySequencer() {\n        // @note In the decentralized mode, it should be only called by a list of validator.\n        if (!isSequencer[_msgSender()]) revert ErrorCallerIsNotSequencer();\n        _;\n    }\n\n    modifier OnlyProver() {\n        if (!isProver[_msgSender()]) revert ErrorCallerIsNotProver();\n        _;\n    }\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /// @notice Constructor for `ScrollChain` implementation contract.\n    ///\n    /// @param _chainId The chain id of L2.\n    /// @param _messageQueue The address of `L1MessageQueue` contract.\n    /// @param _verifier The address of zkevm verifier contract.\n    constructor(\n        uint64 _chainId,\n        address _messageQueue,\n        address _verifier\n    ) {\n        if (_messageQueue == address(0) || _verifier == address(0)) {\n            revert ErrorZeroAddress();\n        }\n\n        _disableInitializers();\n\n        layer2ChainId = _chainId;\n        messageQueue = _messageQueue;\n        verifier = _verifier;\n    }\n\n    /// @notice Initialize the storage of ScrollChain.\n    ///\n    /// @dev The parameters `_messageQueue` are no longer used.\n    ///\n    /// @param _messageQueue The address of `L1MessageQueue` contract.\n    /// @param _verifier The address of zkevm verifier contract.\n    /// @param _maxNumTxInChunk The maximum number of transactions allowed in each chunk.\n    function initialize(\n        address _messageQueue,\n        address _verifier,\n        uint256 _maxNumTxInChunk\n    ) public initializer {\n        OwnableUpgradeable.__Ownable_init();\n\n        maxNumTxInChunk = _maxNumTxInChunk;\n        __verifier = _verifier;\n        __messageQueue = _messageQueue;\n\n        emit UpdateMaxNumTxInChunk(0, _maxNumTxInChunk);\n    }\n\n    /*************************\n     * Public View Functions *\n     *************************/\n\n    /// @inheritdoc IScrollChain\n    function isBatchFinalized(uint256 _batchIndex) external view override returns (bool) {\n        return _batchIndex <= lastFinalizedBatchIndex;\n    }\n\n    /*****************************\n     * Public Mutating Functions *\n     *****************************/\n\n    /// @notice Import layer 2 genesis block\n    function importGenesisBatch(bytes calldata _batchHeader, bytes32 _stateRoot) external {\n        // check genesis batch header length\n        if (_stateRoot == bytes32(0)) revert ErrorStateRootIsZero();\n\n        // check whether the genesis batch is imported\n        if (finalizedStateRoots[0] != bytes32(0)) revert ErrorGenesisBatchImported();\n\n        (uint256 memPtr, bytes32 _batchHash, , ) = _loadBatchHeader(_batchHeader);\n\n        // check all fields except `dataHash` and `lastBlockHash` are zero\n        unchecked {\n            uint256 sum = BatchHeaderV0Codec.getVersion(memPtr) +\n                BatchHeaderV0Codec.getBatchIndex(memPtr) +\n                BatchHeaderV0Codec.getL1MessagePopped(memPtr) +\n                BatchHeaderV0Codec.getTotalL1MessagePopped(memPtr);\n            if (sum != 0) revert ErrorGenesisBatchHasNonZeroField();\n        }\n        if (BatchHeaderV0Codec.getDataHash(memPtr) == bytes32(0)) revert ErrorGenesisDataHashIsZero();\n        if (BatchHeaderV0Codec.getParentBatchHash(memPtr) != bytes32(0)) revert ErrorGenesisParentBatchHashIsNonZero();\n\n        committedBatches[0] = _batchHash;\n        finalizedStateRoots[0] = _stateRoot;\n\n        emit CommitBatch(0, _batchHash);\n        emit FinalizeBatch(0, _batchHash, _stateRoot, bytes32(0));\n    }\n\n    /// @inheritdoc IScrollChain\n    function commitBatch(\n        uint8 _version,\n        bytes calldata _parentBatchHeader,\n        bytes[] memory _chunks,\n        bytes calldata _skippedL1MessageBitmap\n    ) external override OnlySequencer whenNotPaused {\n        // check whether the batch is empty\n        if (_chunks.length == 0) revert ErrorBatchIsEmpty();\n\n        (, bytes32 _parentBatchHash, uint256 _batchIndex, uint256 _totalL1MessagesPoppedOverall) = _loadBatchHeader(\n            _parentBatchHeader\n        );\n        unchecked {\n            _batchIndex += 1;\n        }\n        if (committedBatches[_batchIndex] != 0) revert ErrorBatchIsAlreadyCommitted();\n\n        bytes32 _batchHash;\n        uint256 batchPtr;\n        bytes32 _dataHash;\n        uint256 _totalL1MessagesPoppedInBatch;\n        if (_version == 0) {\n            (_dataHash, _totalL1MessagesPoppedInBatch) = _commitChunksV0(\n                _totalL1MessagesPoppedOverall,\n                _chunks,\n                _skippedL1MessageBitmap\n            );\n            assembly {\n                batchPtr := mload(0x40)\n                _totalL1MessagesPoppedOverall := add(_totalL1MessagesPoppedOverall, _totalL1MessagesPoppedInBatch)\n            }\n            // store entries, the order matters\n            BatchHeaderV0Codec.storeVersion(batchPtr, 0);\n            BatchHeaderV0Codec.storeBatchIndex(batchPtr, _batchIndex);\n            BatchHeaderV0Codec.storeL1MessagePopped(batchPtr, _totalL1MessagesPoppedInBatch);\n            BatchHeaderV0Codec.storeTotalL1MessagePopped(batchPtr, _totalL1MessagesPoppedOverall);\n            BatchHeaderV0Codec.storeDataHash(batchPtr, _dataHash);\n            BatchHeaderV0Codec.storeParentBatchHash(batchPtr, _parentBatchHash);\n            BatchHeaderV0Codec.storeSkippedBitmap(batchPtr, _skippedL1MessageBitmap);\n            // compute batch hash\n            _batchHash = BatchHeaderV0Codec.computeBatchHash(\n                batchPtr,\n                BatchHeaderV0Codec.BATCH_HEADER_FIXED_LENGTH + _skippedL1MessageBitmap.length\n            );\n        } else if (_version == 1) {\n            bytes32 blobVersionedHash;\n            (blobVersionedHash, _dataHash, _totalL1MessagesPoppedInBatch) = _commitChunksV1(\n                _totalL1MessagesPoppedOverall,\n                _chunks,\n                _skippedL1MessageBitmap\n            );\n            assembly {\n                batchPtr := mload(0x40)\n                _totalL1MessagesPoppedOverall := add(_totalL1MessagesPoppedOverall, _totalL1MessagesPoppedInBatch)\n            }\n            // store entries, the order matters\n            BatchHeaderV1Codec.storeVersion(batchPtr, 1);\n            BatchHeaderV1Codec.storeBatchIndex(batchPtr, _batchIndex);\n            BatchHeaderV1Codec.storeL1MessagePopped(batchPtr, _totalL1MessagesPoppedInBatch);\n            BatchHeaderV1Codec.storeTotalL1MessagePopped(batchPtr, _totalL1MessagesPoppedOverall);\n            BatchHeaderV1Codec.storeDataHash(batchPtr, _dataHash);\n            BatchHeaderV1Codec.storeBlobVersionedHash(batchPtr, blobVersionedHash);\n            BatchHeaderV1Codec.storeParentBatchHash(batchPtr, _parentBatchHash);\n            BatchHeaderV1Codec.storeSkippedBitmap(batchPtr, _skippedL1MessageBitmap);\n            // compute batch hash\n            _batchHash = BatchHeaderV1Codec.computeBatchHash(\n                batchPtr,\n                BatchHeaderV1Codec.BATCH_HEADER_FIXED_LENGTH + _skippedL1MessageBitmap.length\n            );\n        } else {\n            revert ErrorInvalidBatchHeaderVersion();\n        }\n\n        // check the length of bitmap\n        unchecked {\n            if (((_totalL1MessagesPoppedInBatch + 255) / 256) * 32 != _skippedL1MessageBitmap.length) {\n                revert ErrorIncorrectBitmapLength();\n            }\n        }\n\n        committedBatches[_batchIndex] = _batchHash;\n        emit CommitBatch(_batchIndex, _batchHash);\n    }\n\n    /// @inheritdoc IScrollChain\n    /// @dev If the owner want to revert a sequence of batches by sending multiple transactions,\n    ///      make sure to revert recent batches first.\n    function revertBatch(bytes calldata _batchHeader, uint256 _count) external onlyOwner {\n        if (_count == 0) revert ErrorRevertZeroBatches();\n\n        (, bytes32 _batchHash, uint256 _batchIndex, ) = _loadBatchHeader(_batchHeader);\n        // make sure no gap is left when reverting from the ending to the beginning.\n        if (committedBatches[_batchIndex + _count] != bytes32(0)) revert ErrorRevertNotStartFromEnd();\n\n        // check finalization\n        if (_batchIndex <= lastFinalizedBatchIndex) revert ErrorRevertFinalizedBatch();\n\n        while (_count > 0) {\n            committedBatches[_batchIndex] = bytes32(0);\n\n            emit RevertBatch(_batchIndex, _batchHash);\n\n            unchecked {\n                _batchIndex += 1;\n                _count -= 1;\n            }\n\n            _batchHash = committedBatches[_batchIndex];\n            if (_batchHash == bytes32(0)) break;\n        }\n    }\n\n    /// @inheritdoc IScrollChain\n    /// @dev We keep this function to upgrade to 4844 more smoothly.\n    function finalizeBatchWithProof(\n        bytes calldata _batchHeader,\n        bytes32 _prevStateRoot,\n        bytes32 _postStateRoot,\n        bytes32 _withdrawRoot,\n        bytes calldata _aggrProof\n    ) external override OnlyProver whenNotPaused {\n        if (_prevStateRoot == bytes32(0)) revert ErrorPreviousStateRootIsZero();\n        if (_postStateRoot == bytes32(0)) revert ErrorStateRootIsZero();\n\n        // compute batch hash and verify\n        (uint256 memPtr, bytes32 _batchHash, uint256 _batchIndex, ) = _loadBatchHeader(_batchHeader);\n        bytes32 _dataHash = BatchHeaderV0Codec.getDataHash(memPtr);\n\n        // verify previous state root.\n        if (finalizedStateRoots[_batchIndex - 1] != _prevStateRoot) revert ErrorIncorrectPreviousStateRoot();\n\n        // avoid duplicated verification\n        if (finalizedStateRoots[_batchIndex] != bytes32(0)) revert ErrorBatchIsAlreadyVerified();\n\n        // compute public input hash\n        bytes32 _publicInputHash = keccak256(\n            abi.encodePacked(layer2ChainId, _prevStateRoot, _postStateRoot, _withdrawRoot, _dataHash)\n        );\n\n        // verify batch\n        IRollupVerifier(verifier).verifyAggregateProof(0, _batchIndex, _aggrProof, _publicInputHash);\n\n        // check and update lastFinalizedBatchIndex\n        unchecked {\n            if (lastFinalizedBatchIndex + 1 != _batchIndex) revert ErrorIncorrectBatchIndex();\n            lastFinalizedBatchIndex = _batchIndex;\n        }\n\n        // record state root and withdraw root\n        finalizedStateRoots[_batchIndex] = _postStateRoot;\n        withdrawRoots[_batchIndex] = _withdrawRoot;\n\n        // Pop finalized and non-skipped message from L1MessageQueue.\n        _popL1Messages(\n            BatchHeaderV0Codec.getSkippedBitmapPtr(memPtr),\n            BatchHeaderV0Codec.getTotalL1MessagePopped(memPtr),\n            BatchHeaderV0Codec.getL1MessagePopped(memPtr)\n        );\n\n        emit FinalizeBatch(_batchIndex, _batchHash, _postStateRoot, _withdrawRoot);\n    }\n\n    /// @inheritdoc IScrollChain\n    /// @dev Memory layout of `_blobDataProof`:\n    /// ```text\n    /// | z       | y       | kzg_commitment | kzg_proof |\n    /// |---------|---------|----------------|-----------|\n    /// | bytes32 | bytes32 | bytes48        | bytes48   |\n    /// ```\n    function finalizeBatchWithProof4844(\n        bytes calldata _batchHeader,\n        bytes32 _prevStateRoot,\n        bytes32 _postStateRoot,\n        bytes32 _withdrawRoot,\n        bytes calldata _blobDataProof,\n        bytes calldata _aggrProof\n    ) external override OnlyProver whenNotPaused {\n        if (_prevStateRoot == bytes32(0)) revert ErrorPreviousStateRootIsZero();\n        if (_postStateRoot == bytes32(0)) revert ErrorStateRootIsZero();\n\n        // compute batch hash and verify\n        (uint256 memPtr, bytes32 _batchHash, uint256 _batchIndex, ) = _loadBatchHeader(_batchHeader);\n        bytes32 _dataHash = BatchHeaderV1Codec.getDataHash(memPtr);\n        bytes32 _blobVersionedHash = BatchHeaderV1Codec.getBlobVersionedHash(memPtr);\n\n        // Calls the point evaluation precompile and verifies the output\n        {\n            (bool success, bytes memory data) = POINT_EVALUATION_PRECOMPILE_ADDR.staticcall(\n                abi.encodePacked(_blobVersionedHash, _blobDataProof)\n            );\n            // We verify that the point evaluation precompile call was successful by testing the latter 32 bytes of the\n            // response is equal to BLS_MODULUS as defined in https://eips.ethereum.org/EIPS/eip-4844#point-evaluation-precompile\n            if (!success) revert ErrorCallPointEvaluationPrecompileFailed();\n            (, uint256 result) = abi.decode(data, (uint256, uint256));\n            if (result != BLS_MODULUS) revert ErrorUnexpectedPointEvaluationPrecompileOutput();\n        }\n\n        // verify previous state root.\n        if (finalizedStateRoots[_batchIndex - 1] != _prevStateRoot) revert ErrorIncorrectPreviousStateRoot();\n\n        // avoid duplicated verification\n        if (finalizedStateRoots[_batchIndex] != bytes32(0)) revert ErrorBatchIsAlreadyVerified();\n\n        // compute public input hash\n        bytes32 _publicInputHash = keccak256(\n            abi.encodePacked(\n                layer2ChainId,\n                _prevStateRoot,\n                _postStateRoot,\n                _withdrawRoot,\n                _dataHash,\n                _blobDataProof[0:64]\n            )\n        );\n\n        // load version from batch header, it is always the first byte.\n        uint256 batchVersion;\n        assembly {\n            batchVersion := shr(248, calldataload(_batchHeader.offset))\n        }\n        // verify batch\n        IRollupVerifier(verifier).verifyAggregateProof(batchVersion, _batchIndex, _aggrProof, _publicInputHash);\n\n        // check and update lastFinalizedBatchIndex\n        unchecked {\n            if (lastFinalizedBatchIndex + 1 != _batchIndex) revert ErrorIncorrectBatchIndex();\n            lastFinalizedBatchIndex = _batchIndex;\n        }\n\n        // record state root and withdraw root\n        finalizedStateRoots[_batchIndex] = _postStateRoot;\n        withdrawRoots[_batchIndex] = _withdrawRoot;\n\n        // Pop finalized and non-skipped message from L1MessageQueue.\n        _popL1Messages(\n            BatchHeaderV1Codec.getSkippedBitmapPtr(memPtr),\n            BatchHeaderV1Codec.getTotalL1MessagePopped(memPtr),\n            BatchHeaderV1Codec.getL1MessagePopped(memPtr)\n        );\n\n        emit FinalizeBatch(_batchIndex, _batchHash, _postStateRoot, _withdrawRoot);\n    }\n\n    /************************\n     * Restricted Functions *\n     ************************/\n\n    /// @notice Add an account to the sequencer list.\n    /// @param _account The address of account to add.\n    function addSequencer(address _account) external onlyOwner {\n        // @note Currently many external services rely on EOA sequencer to decode metadata directly from tx.calldata.\n        // So we explicitly make sure the account is EOA.\n        if (_account.code.length > 0) revert ErrorAccountIsNotEOA();\n\n        isSequencer[_account] = true;\n\n        emit UpdateSequencer(_account, true);\n    }\n\n    /// @notice Remove an account from the sequencer list.\n    /// @param _account The address of account to remove.\n    function removeSequencer(address _account) external onlyOwner {\n        isSequencer[_account] = false;\n\n        emit UpdateSequencer(_account, false);\n    }\n\n    /// @notice Add an account to the prover list.\n    /// @param _account The address of account to add.\n    function addProver(address _account) external onlyOwner {\n        // @note Currently many external services rely on EOA prover to decode metadata directly from tx.calldata.\n        // So we explicitly make sure the account is EOA.\n        if (_account.code.length > 0) revert ErrorAccountIsNotEOA();\n        isProver[_account] = true;\n\n        emit UpdateProver(_account, true);\n    }\n\n    /// @notice Add an account from the prover list.\n    /// @param _account The address of account to remove.\n    function removeProver(address _account) external onlyOwner {\n        isProver[_account] = false;\n\n        emit UpdateProver(_account, false);\n    }\n\n    /// @notice Update the value of `maxNumTxInChunk`.\n    /// @param _maxNumTxInChunk The new value of `maxNumTxInChunk`.\n    function updateMaxNumTxInChunk(uint256 _maxNumTxInChunk) external onlyOwner {\n        uint256 _oldMaxNumTxInChunk = maxNumTxInChunk;\n        maxNumTxInChunk = _maxNumTxInChunk;\n\n        emit UpdateMaxNumTxInChunk(_oldMaxNumTxInChunk, _maxNumTxInChunk);\n    }\n\n    /// @notice Pause the contract\n    /// @param _status The pause status to update.\n    function setPause(bool _status) external onlyOwner {\n        if (_status) {\n            _pause();\n        } else {\n            _unpause();\n        }\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /// @dev Internal function to commit chunks with version 0\n    /// @param _totalL1MessagesPoppedOverall The number of L1 messages popped before the list of chunks.\n    /// @param _chunks The list of chunks to commit.\n    /// @param _skippedL1MessageBitmap The bitmap indicates whether each L1 message is skipped or not.\n    /// @return _batchDataHash The computed data hash for the list of chunks.\n    /// @return _totalL1MessagesPoppedInBatch The total number of L1 messages poped in this batch, including skipped one.\n    function _commitChunksV0(\n        uint256 _totalL1MessagesPoppedOverall,\n        bytes[] memory _chunks,\n        bytes calldata _skippedL1MessageBitmap\n    ) internal view returns (bytes32 _batchDataHash, uint256 _totalL1MessagesPoppedInBatch) {\n        uint256 _chunksLength = _chunks.length;\n\n        // load `batchDataHashPtr` and reserve the memory region for chunk data hashes\n        uint256 batchDataHashPtr;\n        assembly {\n            batchDataHashPtr := mload(0x40)\n            mstore(0x40, add(batchDataHashPtr, mul(_chunksLength, 32)))\n        }\n\n        // compute the data hash for each chunk\n        for (uint256 i = 0; i < _chunksLength; i++) {\n            uint256 _totalNumL1MessagesInChunk;\n            bytes32 _chunkDataHash;\n            (_chunkDataHash, _totalNumL1MessagesInChunk) = _commitChunkV0(\n                _chunks[i],\n                _totalL1MessagesPoppedInBatch,\n                _totalL1MessagesPoppedOverall,\n                _skippedL1MessageBitmap\n            );\n            unchecked {\n                _totalL1MessagesPoppedInBatch += _totalNumL1MessagesInChunk;\n                _totalL1MessagesPoppedOverall += _totalNumL1MessagesInChunk;\n            }\n            assembly {\n                mstore(batchDataHashPtr, _chunkDataHash)\n                batchDataHashPtr := add(batchDataHashPtr, 0x20)\n            }\n        }\n\n        assembly {\n            let dataLen := mul(_chunksLength, 0x20)\n            _batchDataHash := keccak256(sub(batchDataHashPtr, dataLen), dataLen)\n        }\n    }\n\n    /// @dev Internal function to commit chunks with version 1\n    /// @param _totalL1MessagesPoppedOverall The number of L1 messages popped before the list of chunks.\n    /// @param _chunks The list of chunks to commit.\n    /// @param _skippedL1MessageBitmap The bitmap indicates whether each L1 message is skipped or not.\n    /// @return _blobVersionedHash The blob versioned hash for the blob carried in this transaction.\n    /// @return _batchDataHash The computed data hash for the list of chunks.\n    /// @return _totalL1MessagesPoppedInBatch The total number of L1 messages poped in this batch, including skipped one.\n    function _commitChunksV1(\n        uint256 _totalL1MessagesPoppedOverall,\n        bytes[] memory _chunks,\n        bytes calldata _skippedL1MessageBitmap\n    )\n        internal\n        view\n        returns (\n            bytes32 _blobVersionedHash,\n            bytes32 _batchDataHash,\n            uint256 _totalL1MessagesPoppedInBatch\n        )\n    {\n        {\n            bytes32 _secondBlob;\n            // Get blob's versioned hash\n            assembly {\n                _blobVersionedHash := blobhash(0)\n                _secondBlob := blobhash(1)\n            }\n            if (_blobVersionedHash == bytes32(0)) revert ErrorNoBlobFound();\n            if (_secondBlob != bytes32(0)) revert ErrorFoundMultipleBlob();\n        }\n\n        uint256 _chunksLength = _chunks.length;\n\n        // load `batchDataHashPtr` and reserve the memory region for chunk data hashes\n        uint256 batchDataHashPtr;\n        assembly {\n            batchDataHashPtr := mload(0x40)\n            mstore(0x40, add(batchDataHashPtr, mul(_chunksLength, 32)))\n        }\n\n        // compute the data hash for each chunk\n        for (uint256 i = 0; i < _chunksLength; i++) {\n            uint256 _totalNumL1MessagesInChunk;\n            bytes32 _chunkDataHash;\n            (_chunkDataHash, _totalNumL1MessagesInChunk) = _commitChunkV1(\n                _chunks[i],\n                _totalL1MessagesPoppedInBatch,\n                _totalL1MessagesPoppedOverall,\n                _skippedL1MessageBitmap\n            );\n            unchecked {\n                _totalL1MessagesPoppedInBatch += _totalNumL1MessagesInChunk;\n                _totalL1MessagesPoppedOverall += _totalNumL1MessagesInChunk;\n            }\n            assembly {\n                mstore(batchDataHashPtr, _chunkDataHash)\n                batchDataHashPtr := add(batchDataHashPtr, 0x20)\n            }\n        }\n\n        // compute the data hash for current batch\n        assembly {\n            let dataLen := mul(_chunksLength, 0x20)\n            _batchDataHash := keccak256(sub(batchDataHashPtr, dataLen), dataLen)\n        }\n    }\n\n    /// @dev Internal function to load batch header from calldata to memory.\n    /// @param _batchHeader The batch header in calldata.\n    /// @return batchPtr The start memory offset of loaded batch header.\n    /// @return _batchHash The hash of the loaded batch header.\n    /// @return _batchIndex The index of this batch.\n    /// @param _totalL1MessagesPoppedOverall The number of L1 messages popped after this batch.\n    function _loadBatchHeader(bytes calldata _batchHeader)\n        internal\n        view\n        returns (\n            uint256 batchPtr,\n            bytes32 _batchHash,\n            uint256 _batchIndex,\n            uint256 _totalL1MessagesPoppedOverall\n        )\n    {\n        // load version from batch header, it is always the first byte.\n        uint256 version;\n        assembly {\n            version := shr(248, calldataload(_batchHeader.offset))\n        }\n\n        // version should be always 0 or 1 in current code\n        uint256 _length;\n        if (version == 0) {\n            (batchPtr, _length) = BatchHeaderV0Codec.loadAndValidate(_batchHeader);\n            _batchHash = BatchHeaderV0Codec.computeBatchHash(batchPtr, _length);\n            _batchIndex = BatchHeaderV0Codec.getBatchIndex(batchPtr);\n        } else if (version == 1) {\n            (batchPtr, _length) = BatchHeaderV1Codec.loadAndValidate(_batchHeader);\n            _batchHash = BatchHeaderV1Codec.computeBatchHash(batchPtr, _length);\n            _batchIndex = BatchHeaderV1Codec.getBatchIndex(batchPtr);\n        } else {\n            revert ErrorInvalidBatchHeaderVersion();\n        }\n        // only check when genesis is imported\n        if (committedBatches[_batchIndex] != _batchHash && finalizedStateRoots[0] != bytes32(0)) {\n            revert ErrorIncorrectBatchHash();\n        }\n        _totalL1MessagesPoppedOverall = BatchHeaderV0Codec.getTotalL1MessagePopped(batchPtr);\n    }\n\n    /// @dev Internal function to commit a chunk with version 0.\n    /// @param _chunk The encoded chunk to commit.\n    /// @param _totalL1MessagesPoppedInBatch The total number of L1 messages popped in the current batch before this chunk.\n    /// @param _totalL1MessagesPoppedOverall The total number of L1 messages popped in all batches including the current batch, before this chunk.\n    /// @param _skippedL1MessageBitmap The bitmap indicates whether each L1 message is skipped or not.\n    /// @return _dataHash The computed data hash for this chunk.\n    /// @return _totalNumL1MessagesInChunk The total number of L1 message popped in current chunk\n    function _commitChunkV0(\n        bytes memory _chunk,\n        uint256 _totalL1MessagesPoppedInBatch,\n        uint256 _totalL1MessagesPoppedOverall,\n        bytes calldata _skippedL1MessageBitmap\n    ) internal view returns (bytes32 _dataHash, uint256 _totalNumL1MessagesInChunk) {\n        uint256 chunkPtr;\n        uint256 startDataPtr;\n        uint256 dataPtr;\n\n        assembly {\n            dataPtr := mload(0x40)\n            startDataPtr := dataPtr\n            chunkPtr := add(_chunk, 0x20) // skip chunkLength\n        }\n\n        uint256 _numBlocks = ChunkCodecV0.validateChunkLength(chunkPtr, _chunk.length);\n\n        // concatenate block contexts, use scope to avoid stack too deep\n        {\n            uint256 _totalTransactionsInChunk;\n            for (uint256 i = 0; i < _numBlocks; i++) {\n                dataPtr = ChunkCodecV0.copyBlockContext(chunkPtr, dataPtr, i);\n                uint256 blockPtr = chunkPtr + 1 + i * ChunkCodecV0.BLOCK_CONTEXT_LENGTH;\n                uint256 _numTransactionsInBlock = ChunkCodecV0.getNumTransactions(blockPtr);\n                unchecked {\n                    _totalTransactionsInChunk += _numTransactionsInBlock;\n                }\n            }\n            assembly {\n                mstore(0x40, add(dataPtr, mul(_totalTransactionsInChunk, 0x20))) // reserve memory for tx hashes\n            }\n        }\n\n        // It is used to compute the actual number of transactions in chunk.\n        uint256 txHashStartDataPtr = dataPtr;\n        // concatenate tx hashes\n        uint256 l2TxPtr = ChunkCodecV0.getL2TxPtr(chunkPtr, _numBlocks);\n        chunkPtr += 1;\n        while (_numBlocks > 0) {\n            // concatenate l1 message hashes\n            uint256 _numL1MessagesInBlock = ChunkCodecV0.getNumL1Messages(chunkPtr);\n            dataPtr = _loadL1MessageHashes(\n                dataPtr,\n                _numL1MessagesInBlock,\n                _totalL1MessagesPoppedInBatch,\n                _totalL1MessagesPoppedOverall,\n                _skippedL1MessageBitmap\n            );\n\n            // concatenate l2 transaction hashes\n            uint256 _numTransactionsInBlock = ChunkCodecV0.getNumTransactions(chunkPtr);\n            if (_numTransactionsInBlock < _numL1MessagesInBlock) revert ErrorNumTxsLessThanNumL1Msgs();\n            for (uint256 j = _numL1MessagesInBlock; j < _numTransactionsInBlock; j++) {\n                bytes32 txHash;\n                (txHash, l2TxPtr) = ChunkCodecV0.loadL2TxHash(l2TxPtr);\n                assembly {\n                    mstore(dataPtr, txHash)\n                    dataPtr := add(dataPtr, 0x20)\n                }\n            }\n\n            unchecked {\n                _totalNumL1MessagesInChunk += _numL1MessagesInBlock;\n                _totalL1MessagesPoppedInBatch += _numL1MessagesInBlock;\n                _totalL1MessagesPoppedOverall += _numL1MessagesInBlock;\n\n                _numBlocks -= 1;\n                chunkPtr += ChunkCodecV0.BLOCK_CONTEXT_LENGTH;\n            }\n        }\n\n        // check the actual number of transactions in the chunk\n        if ((dat"
    }
  ]
}