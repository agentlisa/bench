{
  "Title": "[C08] Fork reputation goal threshold can be decreased during fork",
  "Content": "Once a universe is forking, all REP token holders are expected to migrate out their entire REP balance to one of the child universes. The migration of tokens can be accomplished calling the [`migrateOut`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/ReputationToken.sol#L48) or [`migrateOutByPayout`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/ReputationToken.sol#L39) functions in the `ReputationToken` contract corresponding to the forking universe. These will then trigger the [burning of REP tokens in the forking universe](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/ReputationToken.sol#L51), and by calling the [`migrateIn`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/ReputationToken.sol#L52) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/ReputationToken.sol#L52) of the child universe’s REP token, the corresponding REP tokens [will be minted](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/ReputationToken.sol#L60) in the child universe. The forking stage will be considered finished either when a certain amount of REP tokens have been migrated (*i.e.* [`forkReputationGoal`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Universe.sol#L31) tokens) to a child universe (which will be considered the winning child universe), or when a fixed amount of time has passed (*i.e.* when the system’s time is greater than [`forkEndTime`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Universe.sol#L30)).\n\n\nWhile the `forkReputationGoal` was expected to be a fixed threshold during a fork, an attack vector has been identified in a second-generation forking universe where any malicious user can turn the `forkReputationGoal` into an ever-decreasing moving target, thus dangerously allowing a holder of tokens to potentially manipulate the outcome of a fork in an unintended way.\n\n\nConsider a Universe B, winning child of a locked Universe A that forked in the past (*i.e.* in Universe B, `augur.getTimestamp() >= parentUniverse.getForkEndTime()` equals `true`). Now consider that the Universe B is forking to several universes, but still has not settled on which child universe is the winning one; that is, users are actively migrating their Universe-B-REP tokens to one of the many child universes by calling the [`migrateOut`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/ReputationToken.sol#L48) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/ReputationToken.sol#L48) of the Universe-B-REP token. Therefore, the total supply of Universe-B-REP tokens is decreasing (because Universe-B-REP tokens are [burned](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/ReputationToken.sol#L51)).\n\n\nThe `ReputationToken` contract implements the [`updateTotalTheoreticalSupply`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/ReputationToken.sol#L153) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/ReputationToken.sol#L153) that can be called by anyone at any time. In our scenario, calling this function will always execute [line 157](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/ReputationToken.sol#L156-L157) of `ReputationToken.sol`, thus updating the `totalTheoreticalSupply` of Universe-B-REP tokens to the last registered `totalSupply` of tokens. This means that, as the `totalSupply` of Universe-B-REP tokens is decreasing due to tokens being migrated and burned, the `totalTheoreticalSupply` will also decrease each time `updateTotalTheoreticalSupply` is called after at least one Universe-B-REP token is migrated out to a child universe.\n\n\nThe `Universe` contract implements the [`updateForkValues`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Universe.sol#L79) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Universe.sol#L79) that can be called by anyone at any time, and [updates the](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Universe.sol#L80-L81) [`forkReputationGoal`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Universe.sol#L80-L81) [with the last registered value of](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Universe.sol#L80-L81) [`totalTheoreticalSupply`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Universe.sol#L80-L81)`.` In our scenario, if the `updateForkValues` function is called in Universe B after calling `updateTotalTheoreticalSupply` in the Universe-B-REP token, then the `forkReputationGoal` threshold will be decreased, as the `totalTheoreticalSupply` was decreased (explained in previous paragraph).\n\n\nAs a consequence, any user can leverage the migration of Universe-B-REP tokens to effectively turn the `forkReputationGoal` threshold of Universe B into a moving target, thus each time requiring [less and less tokens for a child universe to be considered the winning universe](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Universe.sol#L231), not only because the amount of REP migrated is increasing (which is expected), but also because the threshold is being lowered.\n\n\nConsider analyzing the need of having a public function that updates critical system parameters such as [`updateForkValues`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Universe.sol#L79)`.` If it is to remain public to be called from off-chain clients, then its execution during a fork should be halted, making sure it is called one last time before entering the fork stage. As a starting point, one potential (untested) solution for this issue could be adding a `require(!isForking())` statement at the beginning of the [`updateForkValues`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Universe.sol#L79) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Universe.sol#L79), and adding a call to it in the [`fork`](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Universe.sol#L70) [function](https://github.com/AugurProject/augur/blob/9a33c3269e812d0cb66d49b61a72db58e32e4749/packages/augur-core/source/contracts/reporting/Universe.sol#L70) of the `Universe` contract. Regardless of the course of action taken, thorough unit tests to cover the described scenario should be included to prevent this issue from being reintroduced in future changes to the code base.\n\n\n***Update:*** *fixed in* *[`a9560f4`](https://github.com/AugurProject/augur/commit/a9560f44ea42db3fce4dedf8f238f91354aca265).* *The fork reputation goal threshold can no longer be changed once a fork has begun.*\n\n\n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "packages/augur-core/source/contracts/reporting/ReputationToken.sol",
      "content": "pragma solidity 0.5.4;\n\nimport 'ROOT/libraries/IERC820Registry.sol';\nimport 'ROOT/reporting/IV2ReputationToken.sol';\nimport 'ROOT/libraries/ITyped.sol';\nimport 'ROOT/libraries/token/VariableSupplyToken.sol';\nimport 'ROOT/libraries/token/ERC20Token.sol';\nimport 'ROOT/reporting/IUniverse.sol';\nimport 'ROOT/reporting/IMarket.sol';\nimport 'ROOT/reporting/Reporting.sol';\nimport 'ROOT/reporting/IDisputeWindow.sol';\nimport 'ROOT/reporting/IDisputeCrowdsourcer.sol';\nimport 'ROOT/libraries/math/SafeMathUint256.sol';\n\n\ncontract ReputationToken is ITyped, VariableSupplyToken, IV2ReputationToken {\n    using SafeMathUint256 for uint256;\n\n    string constant public name = \"Reputation\";\n    string constant public symbol = \"REP\";\n    IUniverse internal universe;\n    IUniverse internal parentUniverse;\n    uint256 internal totalMigrated;\n    uint256 internal totalTheoreticalSupply;\n    ERC20Token public legacyRepToken;\n    IAugur public augur;\n\n    constructor(IAugur _augur, IUniverse _universe, IUniverse _parentUniverse, address _erc820RegistryAddress) public {\n        require(_universe != IUniverse(0));\n        augur = _augur;\n        universe = _universe;\n        parentUniverse = _parentUniverse;\n        legacyRepToken = ERC20Token(augur.lookup(\"LegacyReputationToken\"));\n        updateTotalTheoreticalSupply();\n        erc820Registry = IERC820Registry(_erc820RegistryAddress);\n        initialize820InterfaceImplementations();\n    }\n\n    function migrateOutByPayout(uint256[] memory _payoutNumerators, uint256 _attotokens) public returns (bool) {\n        require(_attotokens > 0);\n        IUniverse _destinationUniverse = universe.createChildUniverse(_payoutNumerators);\n        IReputationToken _destination = _destinationUniverse.getReputationToken();\n        burn(msg.sender, _attotokens);\n        _destination.migrateIn(msg.sender, _attotokens);\n        return true;\n    }\n\n    function migrateOut(IReputationToken _destination, uint256 _attotokens) public returns (bool) {\n        require(_attotokens > 0);\n        assertReputationTokenIsLegitSibling(_destination);\n        burn(msg.sender, _attotokens);\n        _destination.migrateIn(msg.sender, _attotokens);\n        return true;\n    }\n\n    function migrateIn(address _reporter, uint256 _attotokens) public returns (bool) {\n        IUniverse _parentUniverse = universe.getParentUniverse();\n        require(ReputationToken(msg.sender) == _parentUniverse.getReputationToken());\n        require(augur.getTimestamp() < _parentUniverse.getForkEndTime());\n        mint(_reporter, _attotokens);\n        totalMigrated += _attotokens;\n        // Update the fork tenative winner and finalize if we can\n        if (!_parentUniverse.getForkingMarket().isFinalized()) {\n            _parentUniverse.updateTentativeWinningChildUniverse(universe.getParentPayoutDistributionHash());\n        }\n        return true;\n    }\n\n    function mintForReportingParticipant(uint256 _amountMigrated) public returns (bool) {\n        IUniverse _parentUniverse = universe.getParentUniverse();\n        IReportingParticipant _reportingParticipant = IReportingParticipant(msg.sender);\n        require(_parentUniverse.isContainerForReportingParticipant(_reportingParticipant));\n        uint256 _bonus = _amountMigrated.mul(2) / 5;\n        mint(address(_reportingParticipant), _bonus);\n        return true;\n    }\n\n    function mintForAuction(uint256 _amountToMint) public returns (bool) {\n        require(universe.getAuction() == IAuction(msg.sender));\n        mint(msg.sender, _amountToMint);\n        return true;\n    }\n\n    function burnForAuction(uint256 _amountToBurn) public returns (bool) {\n        require(universe.getAuction() == IAuction(msg.sender));\n        burn(msg.sender, _amountToBurn);\n        return true;\n    }\n\n    function burnForMarket(uint256 _amountToBurn) public returns (bool) {\n        require(universe.isContainerForMarket(IMarket(msg.sender)));\n        burn(msg.sender, _amountToBurn);\n        return true;\n    }\n\n    function transfer(address _to, uint _value) public returns (bool) {\n        return super.transfer(_to, _value);\n    }\n\n    function transferFrom(address _from, address _to, uint _value) public returns (bool) {\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    function trustedUniverseTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool) {\n        require(IUniverse(msg.sender) == universe);\n        return internalTransfer(_source, _destination, _attotokens, true);\n    }\n\n    function trustedMarketTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool) {\n        require(universe.isContainerForMarket(IMarket(msg.sender)));\n        return internalTransfer(_source, _destination, _attotokens, true);\n    }\n\n    function trustedReportingParticipantTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool) {\n        require(universe.isContainerForReportingParticipant(IReportingParticipant(msg.sender)));\n        return internalTransfer(_source, _destination, _attotokens, true);\n    }\n\n    function trustedAuctionTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool) {\n        require(universe.getAuction() == (IAuction(msg.sender)));\n        return internalTransfer(_source, _destination, _attotokens, true);\n    }\n\n    function trustedDisputeWindowTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool) {\n        require(universe.isContainerForDisputeWindow(IDisputeWindow(msg.sender)));\n        return internalTransfer(_source, _destination, _attotokens, true);\n    }\n\n    function assertReputationTokenIsLegitSibling(IReputationToken _shadyReputationToken) private view returns (bool) {\n        IUniverse _shadyUniverse = _shadyReputationToken.getUniverse();\n        require(universe.isParentOf(_shadyUniverse));\n        IUniverse _legitUniverse = _shadyUniverse;\n        require(_legitUniverse.getReputationToken() == _shadyReputationToken);\n        return true;\n    }\n\n    function getTypeName() public view returns (bytes32) {\n        return \"ReputationToken\";\n    }\n\n    function getUniverse() public view returns (IUniverse) {\n        return universe;\n    }\n\n    function getTotalMigrated() public view returns (uint256) {\n        return totalMigrated;\n    }\n\n    function getLegacyRepToken() public view returns (ERC20Token) {\n        return legacyRepToken;\n    }\n\n    function updateTotalTheoreticalSupply() public returns (bool) {\n        if (parentUniverse == IUniverse(0)) {\n            totalTheoreticalSupply = Reporting.getInitialREPSupply();\n        } else if (augur.getTimestamp() >= parentUniverse.getForkEndTime()) {\n            totalTheoreticalSupply = totalSupply();\n        } else {\n            totalTheoreticalSupply = totalSupply() + parentUniverse.getReputationToken().totalSupply();\n        }\n        return true;\n    }\n\n    function getTotalTheoreticalSupply() public view returns (uint256) {\n        return totalTheoreticalSupply;\n    }\n\n    function onTokenTransfer(address _from, address _to, uint256 _value) internal returns (bool) {\n        augur.logReputationTokensTransferred(universe, _from, _to, _value, balances[_from], balances[_to]);\n        return true;\n    }\n\n    function onMint(address _target, uint256 _amount) internal returns (bool) {\n        augur.logReputationTokensMinted(universe, _target, _amount, totalSupply());\n        return true;\n    }\n\n    function onBurn(address _target, uint256 _amount) internal returns (bool) {\n        augur.logReputationTokensBurned(universe, _target, _amount, totalSupply());\n        return true;\n    }\n\n    function migrateFromLegacyReputationToken() public returns (bool) {\n        uint256 _legacyBalance = legacyRepToken.balanceOf(msg.sender);\n        require(legacyRepToken.transferFrom(msg.sender, address(0), _legacyBalance));\n        mint(msg.sender, _legacyBalance);\n        return true;\n    }\n}"
    },
    {
      "filename": "packages/augur-core/source/contracts/reporting/ReputationToken.sol",
      "content": "pragma solidity 0.5.4;\n\nimport 'ROOT/libraries/IERC820Registry.sol';\nimport 'ROOT/reporting/IV2ReputationToken.sol';\nimport 'ROOT/libraries/ITyped.sol';\nimport 'ROOT/libraries/token/VariableSupplyToken.sol';\nimport 'ROOT/libraries/token/ERC20Token.sol';\nimport 'ROOT/reporting/IUniverse.sol';\nimport 'ROOT/reporting/IMarket.sol';\nimport 'ROOT/reporting/Reporting.sol';\nimport 'ROOT/reporting/IDisputeWindow.sol';\nimport 'ROOT/reporting/IDisputeCrowdsourcer.sol';\nimport 'ROOT/libraries/math/SafeMathUint256.sol';\n\n\ncontract ReputationToken is ITyped, VariableSupplyToken, IV2ReputationToken {\n    using SafeMathUint256 for uint256;\n\n    string constant public name = \"Reputation\";\n    string constant public symbol = \"REP\";\n    IUniverse internal universe;\n    IUniverse internal parentUniverse;\n    uint256 internal totalMigrated;\n    uint256 internal totalTheoreticalSupply;\n    ERC20Token public legacyRepToken;\n    IAugur public augur;\n\n    constructor(IAugur _augur, IUniverse _universe, IUniverse _parentUniverse, address _erc820RegistryAddress) public {\n        require(_universe != IUniverse(0));\n        augur = _augur;\n        universe = _universe;\n        parentUniverse = _parentUniverse;\n        legacyRepToken = ERC20Token(augur.lookup(\"LegacyReputationToken\"));\n        updateTotalTheoreticalSupply();\n        erc820Registry = IERC820Registry(_erc820RegistryAddress);\n        initialize820InterfaceImplementations();\n    }\n\n    function migrateOutByPayout(uint256[] memory _payoutNumerators, uint256 _attotokens) public returns (bool) {\n        require(_attotokens > 0);\n        IUniverse _destinationUniverse = universe.createChildUniverse(_payoutNumerators);\n        IReputationToken _destination = _destinationUniverse.getReputationToken();\n        burn(msg.sender, _attotokens);\n        _destination.migrateIn(msg.sender, _attotokens);\n        return true;\n    }\n\n    function migrateOut(IReputationToken _destination, uint256 _attotokens) public returns (bool) {\n        require(_attotokens > 0);\n        assertReputationTokenIsLegitSibling(_destination);\n        burn(msg.sender, _attotokens);\n        _destination.migrateIn(msg.sender, _attotokens);\n        return true;\n    }\n\n    function migrateIn(address _reporter, uint256 _attotokens) public returns (bool) {\n        IUniverse _parentUniverse = universe.getParentUniverse();\n        require(ReputationToken(msg.sender) == _parentUniverse.getReputationToken());\n        require(augur.getTimestamp() < _parentUniverse.getForkEndTime());\n        mint(_reporter, _attotokens);\n        totalMigrated += _attotokens;\n        // Update the fork tenative winner and finalize if we can\n        if (!_parentUniverse.getForkingMarket().isFinalized()) {\n            _parentUniverse.updateTentativeWinningChildUniverse(universe.getParentPayoutDistributionHash());\n        }\n        return true;\n    }\n\n    function mintForReportingParticipant(uint256 _amountMigrated) public returns (bool) {\n        IUniverse _parentUniverse = universe.getParentUniverse();\n        IReportingParticipant _reportingParticipant = IReportingParticipant(msg.sender);\n        require(_parentUniverse.isContainerForReportingParticipant(_reportingParticipant));\n        uint256 _bonus = _amountMigrated.mul(2) / 5;\n        mint(address(_reportingParticipant), _bonus);\n        return true;\n    }\n\n    function mintForAuction(uint256 _amountToMint) public returns (bool) {\n        require(universe.getAuction() == IAuction(msg.sender));\n        mint(msg.sender, _amountToMint);\n        return true;\n    }\n\n    function burnForAuction(uint256 _amountToBurn) public returns (bool) {\n        require(universe.getAuction() == IAuction(msg.sender));\n        burn(msg.sender, _amountToBurn);\n        return true;\n    }\n\n    function burnForMarket(uint256 _amountToBurn) public returns (bool) {\n        require(universe.isContainerForMarket(IMarket(msg.sender)));\n        burn(msg.sender, _amountToBurn);\n        return true;\n    }\n\n    function transfer(address _to, uint _value) public returns (bool) {\n        return super.transfer(_to, _value);\n    }\n\n    function transferFrom(address _from, address _to, uint _value) public returns (bool) {\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    function trustedUniverseTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool) {\n        require(IUniverse(msg.sender) == universe);\n        return internalTransfer(_source, _destination, _attotokens, true);\n    }\n\n    function trustedMarketTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool) {\n        require(universe.isContainerForMarket(IMarket(msg.sender)));\n        return internalTransfer(_source, _destination, _attotokens, true);\n    }\n\n    function trustedReportingParticipantTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool) {\n        require(universe.isContainerForReportingParticipant(IReportingParticipant(msg.sender)));\n        return internalTransfer(_source, _destination, _attotokens, true);\n    }\n\n    function trustedAuctionTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool) {\n        require(universe.getAuction() == (IAuction(msg.sender)));\n        return internalTransfer(_source, _destination, _attotokens, true);\n    }\n\n    function trustedDisputeWindowTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool) {\n        require(universe.isContainerForDisputeWindow(IDisputeWindow(msg.sender)));\n        return internalTransfer(_source, _destination, _attotokens, true);\n    }\n\n    function assertReputationTokenIsLegitSibling(IReputationToken _shadyReputationToken) private view returns (bool) {\n        IUniverse _shadyUniverse = _shadyReputationToken.getUniverse();\n        require(universe.isParentOf(_shadyUniverse));\n        IUniverse _legitUniverse = _shadyUniverse;\n        require(_legitUniverse.getReputationToken() == _shadyReputationToken);\n        return true;\n    }\n\n    function getTypeName() public view returns (bytes32) {\n        return \"ReputationToken\";\n    }\n\n    function getUniverse() public view returns (IUniverse) {\n        return universe;\n    }\n\n    function getTotalMigrated() public view returns (uint256) {\n        return totalMigrated;\n    }\n\n    function getLegacyRepToken() public view returns (ERC20Token) {\n        return legacyRepToken;\n    }\n\n    function updateTotalTheoreticalSupply() public returns (bool) {\n        if (parentUniverse == IUniverse(0)) {\n            totalTheoreticalSupply = Reporting.getInitialREPSupply();\n        } else if (augur.getTimestamp() >= parentUniverse.getForkEndTime()) {\n            totalTheoreticalSupply = totalSupply();\n        } else {\n            totalTheoreticalSupply = totalSupply() + parentUniverse.getReputationToken().totalSupply();\n        }\n        return true;\n    }\n\n    function getTotalTheoreticalSupply() public view returns (uint256) {\n        return totalTheoreticalSupply;\n    }\n\n    function onTokenTransfer(address _from, address _to, uint256 _value) internal returns (bool) {\n        augur.logReputationTokensTransferred(universe, _from, _to, _value, balances[_from], balances[_to]);\n        return true;\n    }\n\n    function onMint(address _target, uint256 _amount) internal returns (bool) {\n        augur.logReputationTokensMinted(universe, _target, _amount, totalSupply());\n        return true;\n    }\n\n    function onBurn(address _target, uint256 _amount) internal returns (bool) {\n        augur.logReputationTokensBurned(universe, _target, _amount, totalSupply());\n        return true;\n    }\n\n    function migrateFromLegacyReputationToken() public returns (bool) {\n        uint256 _legacyBalance = legacyRepToken.balanceOf(msg.sender);\n        require(legacyRepToken.transferFrom(msg.sender, address(0), _legacyBalance));\n        mint(msg.sender, _legacyBalance);\n        return true;\n    }\n}"
    },
    {
      "filename": "packages/augur-core/source/contracts/reporting/ReputationToken.sol",
      "content": "pragma solidity 0.5.4;\n\nimport 'ROOT/libraries/IERC820Registry.sol';\nimport 'ROOT/reporting/IV2ReputationToken.sol';\nimport 'ROOT/libraries/ITyped.sol';\nimport 'ROOT/libraries/token/VariableSupplyToken.sol';\nimport 'ROOT/libraries/token/ERC20Token.sol';\nimport 'ROOT/reporting/IUniverse.sol';\nimport 'ROOT/reporting/IMarket.sol';\nimport 'ROOT/reporting/Reporting.sol';\nimport 'ROOT/reporting/IDisputeWindow.sol';\nimport 'ROOT/reporting/IDisputeCrowdsourcer.sol';\nimport 'ROOT/libraries/math/SafeMathUint256.sol';\n\n\ncontract ReputationToken is ITyped, VariableSupplyToken, IV2ReputationToken {\n    using SafeMathUint256 for uint256;\n\n    string constant public name = \"Reputation\";\n    string constant public symbol = \"REP\";\n    IUniverse internal universe;\n    IUniverse internal parentUniverse;\n    uint256 internal totalMigrated;\n    uint256 internal totalTheoreticalSupply;\n    ERC20Token public legacyRepToken;\n    IAugur public augur;\n\n    constructor(IAugur _augur, IUniverse _universe, IUniverse _parentUniverse, address _erc820RegistryAddress) public {\n        require(_universe != IUniverse(0));\n        augur = _augur;\n        universe = _universe;\n        parentUniverse = _parentUniverse;\n        legacyRepToken = ERC20Token(augur.lookup(\"LegacyReputationToken\"));\n        updateTotalTheoreticalSupply();\n        erc820Registry = IERC820Registry(_erc820RegistryAddress);\n        initialize820InterfaceImplementations();\n    }\n\n    function migrateOutByPayout(uint256[] memory _payoutNumerators, uint256 _attotokens) public returns (bool) {\n        require(_attotokens > 0);\n        IUniverse _destinationUniverse = universe.createChildUniverse(_payoutNumerators);\n        IReputationToken _destination = _destinationUniverse.getReputationToken();\n        burn(msg.sender, _attotokens);\n        _destination.migrateIn(msg.sender, _attotokens);\n        return true;\n    }\n\n    function migrateOut(IReputationToken _destination, uint256 _attotokens) public returns (bool) {\n        require(_attotokens > 0);\n        assertReputationTokenIsLegitSibling(_destination);\n        burn(msg.sender, _attotokens);\n        _destination.migrateIn(msg.sender, _attotokens);\n        return true;\n    }\n\n    function migrateIn(address _reporter, uint256 _attotokens) public returns (bool) {\n        IUniverse _parentUniverse = universe.getParentUniverse();\n        require(ReputationToken(msg.sender) == _parentUniverse.getReputationToken());\n        require(augur.getTimestamp() < _parentUniverse.getForkEndTime());\n        mint(_reporter, _attotokens);\n        totalMigrated += _attotokens;\n        // Update the fork tenative winner and finalize if we can\n        if (!_parentUniverse.getForkingMarket().isFinalized()) {\n            _parentUniverse.updateTentativeWinningChildUniverse(universe.getParentPayoutDistributionHash());\n        }\n        return true;\n    }\n\n    function mintForReportingParticipant(uint256 _amountMigrated) public returns (bool) {\n        IUniverse _parentUniverse = universe.getParentUniverse();\n        IReportingParticipant _reportingParticipant = IReportingParticipant(msg.sender);\n        require(_parentUniverse.isContainerForReportingParticipant(_reportingParticipant));\n        uint256 _bonus = _amountMigrated.mul(2) / 5;\n        mint(address(_reportingParticipant), _bonus);\n        return true;\n    }\n\n    function mintForAuction(uint256 _amountToMint) public returns (bool) {\n        require(universe.getAuction() == IAuction(msg.sender));\n        mint(msg.sender, _amountToMint);\n        return true;\n    }\n\n    function burnForAuction(uint256 _amountToBurn) public returns (bool) {\n        require(universe.getAuction() == IAuction(msg.sender));\n        burn(msg.sender, _amountToBurn);\n        return true;\n    }\n\n    function burnForMarket(uint256 _amountToBurn) public returns (bool) {\n        require(universe.isContainerForMarket(IMarket(msg.sender)));\n        burn(msg.sender, _amountToBurn);\n        return true;\n    }\n\n    function transfer(address _to, uint _value) public returns (bool) {\n        return super.transfer(_to, _value);\n    }\n\n    function transferFrom(address _from, address _to, uint _value) public returns (bool) {\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    function trustedUniverseTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool) {\n        require(IUniverse(msg.sender) == universe);\n        return internalTransfer(_source, _destination, _attotokens, true);\n    }\n\n    function trustedMarketTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool) {\n        require(universe.isContainerForMarket(IMarket(msg.sender)));\n        return internalTransfer(_source, _destination, _attotokens, true);\n    }\n\n    function trustedReportingParticipantTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool) {\n        require(universe.isContainerForReportingParticipant(IReportingParticipant(msg.sender)));\n        return internalTransfer(_source, _destination, _attotokens, true);\n    }\n\n    function trustedAuctionTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool) {\n        require(universe.getAuction() == (IAuction(msg.sender)));\n        return internalTransfer(_source, _destination, _attotokens, true);\n    }\n\n    function trustedDisputeWindowTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool) {\n        require(universe.isContainerForDisputeWindow(IDisputeWindow(msg.sender)));\n        return internalTransfer(_source, _destination, _attotokens, true);\n    }\n\n    function assertReputationTokenIsLegitSibling(IReputationToken _shadyReputationToken) private view returns (bool) {\n        IUniverse _shadyUniverse = _shadyReputationToken.getUniverse();\n        require(universe.isParentOf(_shadyUniverse));\n        IUniverse _legitUniverse = _shadyUniverse;\n        require(_legitUniverse.getReputationToken() == _shadyReputationToken);\n        return true;\n    }\n\n    function getTypeName() public view returns (bytes32) {\n        return \"ReputationToken\";\n    }\n\n    function getUniverse() public view returns (IUniverse) {\n        return universe;\n    }\n\n    function getTotalMigrated() public view returns (uint256) {\n        return totalMigrated;\n    }\n\n    function getLegacyRepToken() public view returns (ERC20Token) {\n        return legacyRepToken;\n    }\n\n    function updateTotalTheoreticalSupply() public returns (bool) {\n        if (parentUniverse == IUniverse(0)) {\n            totalTheoreticalSupply = Reporting.getInitialREPSupply();\n        } else if (augur.getTimestamp() >= parentUniverse.getForkEndTime()) {\n            totalTheoreticalSupply = totalSupply();\n        } else {\n            totalTheoreticalSupply = totalSupply() + parentUniverse.getReputationToken().totalSupply();\n        }\n        return true;\n    }\n\n    function getTotalTheoreticalSupply() public view returns (uint256) {\n        return totalTheoreticalSupply;\n    }\n\n    function onTokenTransfer(address _from, address _to, uint256 _value) internal returns (bool) {\n        augur.logReputationTokensTransferred(universe, _from, _to, _value, balances[_from], balances[_to]);\n        return true;\n    }\n\n    function onMint(address _target, uint256 _amount) internal returns (bool) {\n        augur.logReputationTokensMinted(universe, _target, _amount, totalSupply());\n        return true;\n    }\n\n    function onBurn(address _target, uint256 _amount) internal returns (bool) {\n        augur.logReputationTokensBurned(universe, _target, _amount, totalSupply());\n        return true;\n    }\n\n    function migrateFromLegacyReputationToken() public returns (bool) {\n        uint256 _legacyBalance = legacyRepToken.balanceOf(msg.sender);\n        require(legacyRepToken.transferFrom(msg.sender, address(0), _legacyBalance));\n        mint(msg.sender, _legacyBalance);\n        return true;\n    }\n}"
    },
    {
      "filename": "packages/augur-core/source/contracts/reporting/Universe.sol",
      "content": "pragma solidity 0.5.4;\n\n\nimport 'ROOT/reporting/IUniverse.sol';\nimport 'ROOT/libraries/ITyped.sol';\nimport 'ROOT/factories/IReputationTokenFactory.sol';\nimport 'ROOT/factories/IDisputeWindowFactory.sol';\nimport 'ROOT/factories/IMarketFactory.sol';\nimport 'ROOT/factories/IAuctionFactory.sol';\nimport 'ROOT/reporting/IMarket.sol';\nimport 'ROOT/reporting/IV2ReputationToken.sol';\nimport 'ROOT/reporting/IAuction.sol';\nimport 'ROOT/reporting/IDisputeWindow.sol';\nimport 'ROOT/reporting/Reporting.sol';\nimport 'ROOT/reporting/IRepPriceOracle.sol';\nimport 'ROOT/libraries/math/SafeMathUint256.sol';\nimport 'ROOT/IAugur.sol';\n\n\ncontract Universe is ITyped, IUniverse {\n    using SafeMathUint256 for uint256;\n\n    IAugur public augur;\n    IUniverse private parentUniverse;\n    bytes32 private parentPayoutDistributionHash;\n    IV2ReputationToken private reputationToken;\n    IAuction private auction;\n    IMarket private forkingMarket;\n    bytes32 private tentativeWinningChildUniversePayoutDistributionHash;\n    uint256 private forkEndTime;\n    uint256 private forkReputationGoal;\n    uint256 private disputeThresholdForFork;\n    uint256 private disputeThresholdForDisputePacing;\n    uint256 private initialReportMinValue;\n    mapping(uint256 => IDisputeWindow) private disputeWindows;\n    mapping(address => bool) private markets;\n    mapping(bytes32 => IUniverse) private childUniverses;\n    uint256 private openInterestInAttoCash;\n    IMarketFactory public marketFactory;\n    IDisputeWindowFactory public disputeWindowFactory;\n\n    mapping (address => uint256) private validityBondInAttoCash;\n    mapping (address => uint256) private designatedReportStakeInAttoRep;\n    mapping (address => uint256) private designatedReportNoShowBondInAttoRep;\n    uint256 public previousValidityBondInAttoCash;\n    uint256 public previousDesignatedReportStakeInAttoRep;\n    uint256 public previousDesignatedReportNoShowBondInAttoRep;\n\n    mapping (address => uint256) private shareSettlementFeeDivisor;\n\n    address public completeSets;\n\n    uint256 constant public INITIAL_WINDOW_ID_BUFFER = 365 days * 10 ** 8;\n\n    constructor(IAugur _augur, IUniverse _parentUniverse, bytes32 _parentPayoutDistributionHash) public {\n        augur = _augur;\n        parentUniverse = _parentUniverse;\n        parentPayoutDistributionHash = _parentPayoutDistributionHash;\n        reputationToken = IReputationTokenFactory(augur.lookup(\"ReputationTokenFactory\")).createReputationToken(augur, this, parentUniverse);\n        auction = IAuctionFactory(augur.lookup(\"AuctionFactory\")).createAuction(augur, this, reputationToken);\n        marketFactory = IMarketFactory(augur.lookup(\"MarketFactory\"));\n        disputeWindowFactory = IDisputeWindowFactory(augur.lookup(\"DisputeWindowFactory\"));\n        completeSets = augur.lookup(\"CompleteSets\");\n        updateForkValues();\n        previousValidityBondInAttoCash = Reporting.getDefaultValidityBond();\n        previousDesignatedReportStakeInAttoRep = initialReportMinValue;\n        previousDesignatedReportNoShowBondInAttoRep = initialReportMinValue;\n    }\n\n    function fork() public returns (bool) {\n        require(!isForking());\n        require(isContainerForMarket(IMarket(msg.sender)));\n        forkingMarket = IMarket(msg.sender);\n        forkEndTime = augur.getTimestamp().add(Reporting.getForkDurationSeconds());\n        augur.logUniverseForked();\n        return true;\n    }\n\n    function updateForkValues() public returns (bool) {\n        uint256 _totalRepSupply = reputationToken.getTotalTheoreticalSupply();\n        forkReputationGoal = _totalRepSupply.div(2); // 50% of REP migrating results in a victory in a fork\n        disputeThresholdForFork = _totalRepSupply.div(40); // 2.5% of the total rep supply\n        initialReportMinValue = disputeThresholdForFork.div(3).div(2**18).add(1); // This value will result in a maximum 20 round dispute sequence\n        disputeThresholdForDisputePacing = disputeThresholdForFork.div(2**9); // Disputes begin normal pacing once there are 8 rounds remaining in the fastest case to fork. The \"last\" round is the one that causes a fork and requires no time so the exponent here is 9 to provide for that many rounds actually occuring.\n        return true;\n    }\n\n    function getTypeName() public view returns (bytes32) {\n        return \"Universe\";\n    }\n\n    function getParentUniverse() public view returns (IUniverse) {\n        return parentUniverse;\n    }\n\n    function getParentPayoutDistributionHash() public view returns (bytes32) {\n        return parentPayoutDistributionHash;\n    }\n\n    function getReputationToken() public view returns (IV2ReputationToken) {\n        return reputationToken;\n    }\n\n    function getAuction() public view returns (IAuction) {\n        return auction;\n    }\n\n    function getForkingMarket() public view returns (IMarket) {\n        return forkingMarket;\n    }\n\n    function getForkEndTime() public view returns (uint256) {\n        return forkEndTime;\n    }\n\n    function getForkReputationGoal() public view returns (uint256) {\n        return forkReputationGoal;\n    }\n\n    function getDisputeThresholdForFork() public view returns (uint256) {\n        return disputeThresholdForFork;\n    }\n\n    function getDisputeThresholdForDisputePacing() public view returns (uint256) {\n        return disputeThresholdForDisputePacing;\n    }\n\n    function getInitialReportMinValue() public view returns (uint256) {\n        return initialReportMinValue;\n    }\n\n    function getDisputeWindow(uint256 _disputeWindowId) public view returns (IDisputeWindow) {\n        return disputeWindows[_disputeWindowId];\n    }\n\n    function isForking() public view returns (bool) {\n        return forkingMarket != IMarket(0);\n    }\n\n    function getChildUniverse(bytes32 _parentPayoutDistributionHash) public view returns (IUniverse) {\n        return childUniverses[_parentPayoutDistributionHash];\n    }\n\n    function getDisputeWindowId(uint256 _timestamp, bool _initial) public view returns (uint256) {\n        uint256 _windowId = _timestamp.div(getDisputeRoundDurationInSeconds(_initial));\n        if (_initial) {\n            _windowId += INITIAL_WINDOW_ID_BUFFER;\n        }\n        return _windowId;\n    }\n\n    function getDisputeRoundDurationInSeconds(bool _initial) public view returns (uint256) {\n        return _initial ? Reporting.getInitialDisputeRoundDurationSeconds() : Reporting.getDisputeRoundDurationSeconds();\n    }\n\n    function getOrCreateDisputeWindowByTimestamp(uint256 _timestamp, bool _initial) public returns (IDisputeWindow) {\n        uint256 _windowId = getDisputeWindowId(_timestamp, _initial);\n        if (disputeWindows[_windowId] == IDisputeWindow(0)) {\n            IDisputeWindow _disputeWindow = disputeWindowFactory.createDisputeWindow(augur, this, _windowId, _initial);\n            disputeWindows[_windowId] = _disputeWindow;\n            augur.logDisputeWindowCreated(_disputeWindow, _windowId, _initial);\n        }\n        return disputeWindows[_windowId];\n    }\n\n    function getDisputeWindowByTimestamp(uint256 _timestamp, bool _initial) public view returns (IDisputeWindow) {\n        uint256 _windowId = getDisputeWindowId(_timestamp, _initial);\n        return disputeWindows[_windowId];\n    }\n\n    function getOrCreatePreviousPreviousDisputeWindow(bool _initial) public returns (IDisputeWindow) {\n        return getOrCreateDisputeWindowByTimestamp(augur.getTimestamp().sub(getDisputeRoundDurationInSeconds(_initial).mul(2)), _initial);\n    }\n\n    function getOrCreatePreviousDisputeWindow(bool _initial) public returns (IDisputeWindow) {\n        return getOrCreateDisputeWindowByTimestamp(augur.getTimestamp().sub(getDisputeRoundDurationInSeconds(_initial)), _initial);\n    }\n\n    function getPreviousDisputeWindow(bool _initial) public view returns (IDisputeWindow) {\n        return getDisputeWindowByTimestamp(augur.getTimestamp().sub(getDisputeRoundDurationInSeconds(_initial)), _initial);\n    }\n\n    function getOrCreateCurrentDisputeWindow(bool _initial) public returns (IDisputeWindow) {\n        return getOrCreateDisputeWindowByTimestamp(augur.getTimestamp(), _initial);\n    }\n\n    function getCurrentDisputeWindow(bool _initial) public view returns (IDisputeWindow) {\n        return getDisputeWindowByTimestamp(augur.getTimestamp(), _initial);\n    }\n\n    function getOrCreateNextDisputeWindow(bool _initial) public returns (IDisputeWindow) {\n        return getOrCreateDisputeWindowByTimestamp(augur.getTimestamp().add(getDisputeRoundDurationInSeconds(_initial)), _initial);\n    }\n\n    function getNextDisputeWindow(bool _initial) public view returns (IDisputeWindow) {\n        return getDisputeWindowByT"
    }
  ]
}