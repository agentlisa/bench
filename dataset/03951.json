{
  "Title": "[M02] Functions in StableToken do not emit Transfer event",
  "Content": "Both [`debitFrom`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/stability/StableToken.sol#L460) and [`creditTo`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/stability/StableToken.sol#L473) functions of the `StableToken` contract work in a very similar way to the `mint` and `burn` functions of an `ERC20` token in the sense that when those are called by the `VM`, the total supply of the token will increase or decrease.\n\n\nThe [ERC20 specification](https://eips.ethereum.org/EIPS/eip-20) states that on the [`transfer` function](https://eips.ethereum.org/EIPS/eip-20#transfer) *“A token contract which creates new tokens should trigger a Transfer event with the `_from` address set to `0x0` when tokens are created”*, while the StableToken does not trigger such an event in the `creditTo` function.\n\n\nSimilarly, the [ERC20 specification](https://eips.ethereum.org/EIPS/eip-20) does not mention anything about events when burning tokens, but emitting a `Transfer` event with the `_to` address set to `0x0` has become a de-facto practice found in widely used ERC20 tokens, such as the [OpenZeppelin’s ERC20 implementation](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/cdf655f770cf8412fbd4d6aef3c55194a1233ef1/contracts/token/ERC20/ERC20.sol#L196).\n\n\nWhen tokens are burned, the [`StableToken`‘s `burn`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/stability/StableToken.sol#L248) and [`debitFrom`](https://github.com/celo-org/celo-monorepo/blob/7be22605e172ca536c028e408b147aab83202e4a/packages/protocol/contracts/stability/StableToken.sol#L460) functions are not triggering the `Transfer` event and thus the amount of burned tokens is not being properly logged.\n\n\nClients attempting to reconstruct the entire history of transferred tokens by parsing `Transfer` event logs should take this issue into account to avoid mismatches in expected token balances.\n\n\nConsider emitting the `Transfer` event inside the `burn`, `debitFrom`, and `creditTo` functions after those operations are successfully registered.\n\n\n***Update:** Fixed in [pull request #2805](https://github.com/celo-org/celo-monorepo/pull/2805). The [`burn` function now emits the `Transfer` event](https://github.com/celo-org/celo-monorepo/pull/2805/files#diff-9077d537b24cd178986feb7453d4bcc0R261). The `creditTo` function was [renamed to `creditGasFees`](https://github.com/celo-org/celo-monorepo/pull/2805/files#diff-9077d537b24cd178986feb7453d4bcc0R506). It now calls the [`_creditGas` internal function which emits the `Transfer` event](https://github.com/celo-org/celo-monorepo/pull/2805/files#diff-9077d537b24cd178986feb7453d4bcc0R531).  \n\nThe `debitFrom` function was [renamed to `debitGasFees`](https://github.com/celo-org/celo-monorepo/pull/2805/files#diff-9077d537b24cd178986feb7453d4bcc0R484). In [pull request #3438](https://github.com/celo-org/celo-monorepo/pull/3438/files) comments were added to explain why the `debitGasFees` and the `creditGasFees` functions only emit the `Transfer` events for the net gas payments.*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "packages/protocol/contracts/stability/StableToken.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\nimport \"./interfaces/IStableToken.sol\";\nimport \"../common/interfaces/IERC20Token.sol\";\nimport \"../common/interfaces/ICeloToken.sol\";\nimport \"../common/Initializable.sol\";\nimport \"../common/FixidityLib.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/UsingPrecompiles.sol\";\n\n/**\n * @title An ERC20 compliant token with adjustable supply.\n */\n// solhint-disable-next-line max-line-length\ncontract StableToken is\n  IStableToken,\n  IERC20Token,\n  ICeloToken,\n  Ownable,\n  Initializable,\n  UsingRegistry,\n  UsingPrecompiles\n{\n  using FixidityLib for FixidityLib.Fraction;\n  using SafeMath for uint256;\n\n  event InflationFactorUpdated(uint256 factor, uint256 lastUpdated);\n\n  event InflationParametersUpdated(uint256 rate, uint256 updatePeriod, uint256 lastUpdated);\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  event TransferComment(string comment);\n\n  string internal name_;\n  string internal symbol_;\n  uint8 internal decimals_;\n\n  // Stored as units. Value can be found using unitsToValue().\n  mapping(address => uint256) internal balances;\n  uint256 internal totalSupply_;\n\n  // Stored as values. Units can be found using valueToUnits().\n  mapping(address => mapping(address => uint256)) internal allowed;\n\n  // STABILITY FEE PARAMETERS\n\n  // The `rate` is how much the `factor` is adjusted by per `updatePeriod`.\n  // The `factor` describes units/value of StableToken, and is greater than or equal to 1.\n  // The `updatePeriod` governs how often the `factor` is updated.\n  // `factorLastUpdated` indicates when the inflation factor was last updated.\n  struct InflationState {\n    FixidityLib.Fraction rate;\n    FixidityLib.Fraction factor;\n    uint256 updatePeriod;\n    uint256 factorLastUpdated;\n  }\n\n  InflationState inflationState;\n\n  /**\n   * Only VM would be able to set the caller address to 0x0 unless someone\n   * really has the private key for 0x0\n   */\n  modifier onlyVm() {\n    require(msg.sender == address(0), \"sender was not vm (reserved 0x0 addr)\");\n    _;\n  }\n\n  /**\n   * @notice recomputes and updates inflation factor if more than `updatePeriod`\n   * has passed since last update.\n   */\n  modifier updateInflationFactor() {\n    FixidityLib.Fraction memory updatedInflationFactor;\n    uint256 lastUpdated;\n\n    (updatedInflationFactor, lastUpdated) = getUpdatedInflationFactor();\n\n    if (lastUpdated != inflationState.factorLastUpdated) {\n      inflationState.factor = updatedInflationFactor;\n      inflationState.factorLastUpdated = lastUpdated;\n      emit InflationFactorUpdated(inflationState.factor.unwrap(), inflationState.factorLastUpdated);\n    }\n    _;\n  }\n\n  /**\n   * @param _name The name of the stable token (English)\n   * @param _symbol A short symbol identifying the token (e.g. \"cUSD\")\n   * @param _decimals Tokens are divisible to this many decimal places.\n   * @param registryAddress Address of the Registry contract.\n   * @param inflationRate weekly inflation rate.\n   * @param inflationFactorUpdatePeriod how often the inflation factor is updated.\n   */\n  function initialize(\n    string calldata _name,\n    string calldata _symbol,\n    uint8 _decimals,\n    address registryAddress,\n    uint256 inflationRate,\n    uint256 inflationFactorUpdatePeriod,\n    address[] calldata initialBalanceAddresses,\n    uint256[] calldata initialBalanceValues\n  ) external initializer {\n    require(inflationRate != 0, \"Must provide a non-zero inflation rate.\");\n\n    _transferOwnership(msg.sender);\n    totalSupply_ = 0;\n    name_ = _name;\n    symbol_ = _symbol;\n    decimals_ = _decimals;\n\n    inflationState.rate = FixidityLib.wrap(inflationRate);\n    inflationState.factor = FixidityLib.fixed1();\n    inflationState.updatePeriod = inflationFactorUpdatePeriod;\n    // solhint-disable-next-line not-rely-on-time\n    inflationState.factorLastUpdated = now;\n\n    require(initialBalanceAddresses.length == initialBalanceValues.length, \"Array length mismatch\");\n    for (uint256 i = 0; i < initialBalanceAddresses.length; i = i.add(1)) {\n      require(_mint(initialBalanceAddresses[i], initialBalanceValues[i]), \"mint failed\");\n    }\n    setRegistry(registryAddress);\n  }\n\n  /**\n   * @notice Updates Inflation Parameters.\n   * @param rate new rate.\n   * @param updatePeriod how often inflationFactor is updated.\n   */\n  function setInflationParameters(uint256 rate, uint256 updatePeriod)\n    external\n    onlyOwner\n    updateInflationFactor\n  {\n    require(rate != 0, \"Must provide a non-zero inflation rate.\");\n    inflationState.rate = FixidityLib.wrap(rate);\n    inflationState.updatePeriod = updatePeriod;\n\n    emit InflationParametersUpdated(\n      rate,\n      updatePeriod,\n      // solhint-disable-next-line not-rely-on-time\n      now\n    );\n  }\n\n  /**\n   * @notice Increase the allowance of another user.\n   * @param spender The address which is being approved to spend StableToken.\n   * @param value The increment of the amount of StableToken approved to the spender.\n   * @return True if the transaction succeeds.\n   */\n  function increaseAllowance(address spender, uint256 value)\n    external\n    updateInflationFactor\n    returns (bool)\n  {\n    uint256 oldValue = allowed[msg.sender][spender];\n    uint256 newValue = oldValue.add(value);\n    allowed[msg.sender][spender] = newValue;\n    emit Approval(msg.sender, spender, newValue);\n    return true;\n  }\n\n  /**\n   * @notice Decrease the allowance of another user.\n   * @param spender The address which is being approved to spend StableToken.\n   * @param value The decrement of the amount of StableToken approved to the spender.\n   * @return True if the transaction succeeds.\n   */\n  function decreaseAllowance(address spender, uint256 value)\n    external\n    updateInflationFactor\n    returns (bool)\n  {\n    uint256 oldValue = allowed[msg.sender][spender];\n    uint256 newValue = oldValue.sub(value);\n    allowed[msg.sender][spender] = newValue;\n    emit Approval(msg.sender, spender, newValue);\n    return true;\n  }\n\n  /**\n   * @notice Approve a user to transfer StableToken on behalf of another user.\n   * @param spender The address which is being approved to spend StableToken.\n   * @param value The amount of StableToken approved to the spender.\n   * @return True if the transaction succeeds.\n   */\n  function approve(address spender, uint256 value) external updateInflationFactor returns (bool) {\n    allowed[msg.sender][spender] = value;\n    emit Approval(msg.sender, spender, value);\n    return true;\n  }\n\n  /**\n   * @notice Mints new StableToken and gives it to 'to'.\n   * @param to The account for which to mint tokens.\n   * @param value The amount of StableToken to mint.\n   */\n  function mint(address to, uint256 value) external updateInflationFactor returns (bool) {\n    require(\n      msg.sender == registry.getAddressFor(EXCHANGE_REGISTRY_ID) ||\n        msg.sender == registry.getAddressFor(VALIDATORS_REGISTRY_ID),\n      \"Only the Exchange and Validators contracts are authorized to mint\"\n    );\n    return _mint(to, value);\n  }\n\n  /**\n   * @notice Mints new StableToken and gives it to 'to'.\n   * @param to The account for which to mint tokens.\n   * @param value The amount of StableToken to mint.\n   */\n  function _mint(address to, uint256 value) private updateInflationFactor returns (bool) {\n    uint256 units = _valueToUnits(inflationState.factor, value);\n    totalSupply_ = totalSupply_.add(units);\n    balances[to] = balances[to].add(units);\n    emit Transfer(address(0), to, value);\n    return true;\n  }\n\n  /**\n   * @notice Transfer token for a specified address\n   * @param to The address to transfer to.\n   * @param value The amount to be transferred.\n   * @param comment The transfer comment.\n   * @return True if the transaction succeeds.\n   */\n  function transferWithComment(address to, uint256 value, string calldata comment)\n    external\n    updateInflationFactor\n    returns (bool)\n  {\n    bool succeeded = transfer(to, value);\n    emit TransferComment(comment);\n    return succeeded;\n  }\n\n  /**\n   * @notice Burns StableToken from the balance of msg.sender.\n   * @param value The amount of StableToken to burn.\n   */\n  function burn(uint256 value)\n    external\n    onlyRegisteredContract(EXCHANGE_REGISTRY_ID)\n    updateInflationFactor\n    returns (bool)\n  {\n    uint256 units = _valueToUnits(inflationState.factor, value);\n    require(units <= balances[msg.sender], \"value exceeded balance of sender\");\n    totalSupply_ = totalSupply_.sub(units);\n    balances[msg.sender] = balances[msg.sender].sub(units);\n    return true;\n  }\n\n  /**\n   * @notice Transfers StableToken from one address to another on behalf of a user.\n   * @param from The address to transfer StableToken from.\n   * @param to The address to transfer StableToken to.\n   * @param value The amount of StableToken to transfer.\n   * @return True if the transaction succeeds.\n   */\n  function transferFrom(address from, address to, uint256 value)\n    external\n    updateInflationFactor\n    returns (bool)\n  {\n    uint256 units = _valueToUnits(inflationState.factor, value);\n    require(to != address(0), \"transfer attempted to reserved address 0x0\");\n    require(units <= balances[from], \"transfer value exceeded balance of sender\");\n    require(\n      value <= allowed[from][msg.sender],\n      \"transfer value exceeded sender's allowance for recipient\"\n    );\n\n    balances[to] = balances[to].add(units);\n    balances[from] = balances[from].sub(units);\n    allowed[from][msg.sender] = allowed[from][msg.sender].sub(value);\n    emit Transfer(from, to, value);\n    return true;\n  }\n\n  /**\n   * @return The name of the stable token.\n   */\n  function name() external view returns (string memory) {\n    return name_;\n  }\n\n  /**\n   * @return The symbol of the stable token.\n   */\n  function symbol() external view returns (string memory) {\n    return symbol_;\n  }\n\n  /**\n   * @return The number of decimal places to which StableToken is divisible.\n   */\n  function decimals() external view returns (uint8) {\n    return decimals_;\n  }\n\n  /**\n   * @notice Gets the amount of owner's StableToken allowed to be spent by spender.\n   * @param accountOwner The owner of the StableToken.\n   * @param spender The spender of the StableToken.\n   * @return The amount of StableToken owner is allowing spender to spend.\n   */\n  function allowance(address accountOwner, address spender) external view returns (uint256) {\n    return allowed[accountOwner][spender];\n  }\n\n  /**\n   * @notice Gets the balance of the specified address using the presently stored inflation factor.\n   * @param accountOwner The address to query the balance of.\n   * @return The balance of the specified address.\n   */\n  function balanceOf(address accountOwner) external view returns (uint256) {\n    return unitsToValue(balances[accountOwner]);\n  }\n\n  /**\n   * @return The total value of StableToken in existence\n   * @dev Though totalSupply_ is stored in units, this returns value.\n   */\n  function totalSupply() external view returns (uint256) {\n    return unitsToValue(totalSupply_);\n  }\n\n  /**\n   * @notice gets inflation parameters.\n   * @return rate\n   * @return factor\n   * @return updatePeriod\n   * @return factorLastUpdated\n   */\n  function getInflationParameters() external view returns (uint256, uint256, uint256, uint256) {\n    return (\n      inflationState.rate.unwrap(),\n      inflationState.factor.unwrap(),\n      inflationState.updatePeriod,\n      inflationState.factorLastUpdated\n    );\n  }\n\n  /**\n   * @notice Returns the units for a given value given the current inflation factor.\n   * @param value The value to convert to units.\n   * @return The units corresponding to `value` given the current inflation factor.\n   * @dev We don't compute the updated inflationFactor here because\n   * we assume any function calling this will have updated the inflation factor.\n   */\n  function valueToUnits(uint256 value) external view returns (uint256) {\n    FixidityLib.Fraction memory updatedInflationFactor;\n\n    (updatedInflationFactor, ) = getUpdatedInflationFactor();\n    return _valueToUnits(updatedInflationFactor, value);\n  }\n\n  /**\n   * @notice Returns the value of a given number of units given the current inflation factor.\n   * @param units The units to convert to value.\n   * @return The value corresponding to `units` given the current inflation factor.\n   */\n  function unitsToValue(uint256 units) public view returns (uint256) {\n    FixidityLib.Fraction memory updatedInflationFactor;\n\n    (updatedInflationFactor, ) = getUpdatedInflationFactor();\n\n    // We're ok using FixidityLib.divide here because updatedInflationFactor is\n    // not going to surpass maxFixedDivisor any time soon.\n    // Quick upper-bound estimation: if annual inflation were 5% (an order of\n    // magnitude more than the initial proposal of 0.5%), in 500 years, the\n    // inflation factor would be on the order of 10**10, which is still a safe\n    // divisor.\n    return FixidityLib.newFixed(units).divide(updatedInflationFactor).fromFixed();\n  }\n\n  /**\n   * @notice Returns the units for a given value given the current inflation factor.\n   * @param value The value to convert to units.\n   * @return The units corresponding to `value` given the current inflation factor.\n   * @dev we assume any function calling this will have updated the inflation factor.\n   */\n  function _valueToUnits(FixidityLib.Fraction memory inflationFactor, uint256 value)\n    private\n    pure\n    returns (uint256)\n  {\n    return inflationFactor.multiply(FixidityLib.newFixed(value)).fromFixed();\n  }\n\n  /**\n   * @notice Computes the up-to-date inflation factor.\n   * @return current inflation factor.\n   * @return lastUpdated time when the returned inflation factor went into effect.\n   */\n  function getUpdatedInflationFactor() private view returns (FixidityLib.Fraction memory, uint256) {\n    /* solhint-disable not-rely-on-time */\n    if (now < inflationState.factorLastUpdated.add(inflationState.updatePeriod)) {\n      return (inflationState.factor, inflationState.factorLastUpdated);\n    }\n\n    uint256 numerator;\n    uint256 denominator;\n\n    // TODO: handle retroactive updates given decreases to updatePeriod:\n    // https://github.com/celo-org/celo-monorepo/issues/3929\n    uint256 timesToApplyInflation = now.sub(inflationState.factorLastUpdated).div(\n      inflationState.updatePeriod\n    );\n\n    (numerator, denominator) = fractionMulExp(\n      inflationState.factor.unwrap(),\n      FixidityLib.fixed1().unwrap(),\n      inflationState.rate.unwrap(),\n      FixidityLib.fixed1().unwrap(),\n      timesToApplyInflation,\n      decimals_\n    );\n\n    // This should never happen. If something went wrong updating the\n    // inflation factor, keep the previous factor\n    if (numerator == 0 || denominator == 0) {\n      return (inflationState.factor, inflationState.factorLastUpdated);\n    }\n\n    FixidityLib.Fraction memory currentInflationFactor = FixidityLib.wrap(numerator).divide(\n      FixidityLib.wrap(denominator)\n    );\n    uint256 lastUpdated = inflationState.factorLastUpdated.add(\n      inflationState.updatePeriod.mul(timesToApplyInflation)\n    );\n\n    return (currentInflationFactor, lastUpdated);\n    /* solhint-enable not-rely-on-time */\n  }\n\n  /**\n   * @notice Transfers `value` from `msg.sender` to `to`\n   * @param to The address to transfer to.\n   * @param value The amount to be transferred.\n   */\n  // solhint-disable-next-line no-simple-event-func-name\n  function transfer(address to, uint256 value) public updateInflationFactor returns (bool) {\n    return _transfer(to, value);\n  }\n\n  /**\n   * @notice Deduct balance for making payments for gas in this StableToken currency.\n   * @param from The account to debit balance from\n   * @param value The value of balance to debit\n   */\n  function debitFrom(address from, uint256 value) external onlyVm updateInflationFactor {\n    uint256 units = _valueToUnits(inflationState.factor, value);\n    totalSupply_ = totalSupply_.sub(units);\n    balances[from] = balances[from].sub(units);\n  }\n\n  /**\n   * @notice Refund balance after making payments for gas in this StableToken currency.\n   * @param to The account to credit balance to\n   * @param value The amount of balance to credit\n   * @dev We can assume that the inflation factor is up to date as `debitFrom`\n   * will have been called in the same transaction\n   */\n  function creditTo(address to, uint256 value) external onlyVm {\n    uint256 units = _valueToUnits(inflationState.factor, value);\n    totalSupply_ = totalSupply_.add(units);\n    balances[to] = balances[to].add(units);\n  }\n\n  /**\n   * @notice Transfers StableToken from one address to another\n   * @param to The address to transfer StableToken to.\n   * @param value The amount of StableToken to be transferred.\n   */\n  function _transfer(address to, uint256 value) internal returns (bool) {\n    require(to != address(0), \"transfer attempted to reserved address 0x0\");\n    uint256 units = _valueToUnits(inflationState.factor, value);\n    require(balances[msg.sender] >= units, \"transfer value exceeded balance of sender\");\n    balances[msg.sender] = balances[msg.sender].sub(units);\n    balances[to] = balances[to].add(units);\n    emit Transfer(msg.sender, to, value);\n    return true;\n  }\n\n}"
    },
    {
      "filename": "contracts/token/ERC20/ERC20.sol",
      "content": "pragma solidity ^0.5.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20Mintable}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n     /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See {_burn} and {_approve}.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\n    }\n}"
    },
    {
      "filename": "packages/protocol/contracts/stability/StableToken.sol",
      "content": "pragma solidity ^0.5.3;\n\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\nimport \"./interfaces/IStableToken.sol\";\nimport \"../common/interfaces/IERC20Token.sol\";\nimport \"../common/interfaces/ICeloToken.sol\";\nimport \"../common/Initializable.sol\";\nimport \"../common/FixidityLib.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/UsingPrecompiles.sol\";\n\n/**\n * @title An ERC20 compliant token with adjustable supply.\n */\n// solhint-disable-next-line max-line-length\ncontract StableToken is\n  IStableToken,\n  IERC20Token,\n  ICeloToken,\n  Ownable,\n  Initializable,\n  UsingRegistry,\n  UsingPrecompiles\n{\n  using FixidityLib for FixidityLib.Fraction;\n  using SafeMath for uint256;\n\n  event InflationFactorUpdated(uint256 factor, uint256 lastUpdated);\n\n  event InflationParametersUpdated(uint256 rate, uint256 updatePeriod, uint256 lastUpdated);\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  event TransferComment(string comment);\n\n  string internal name_;\n  string internal symbol_;\n  uint8 internal decimals_;\n\n  // Stored as units. Value can be found using unitsToValue().\n  mapping(address => uint256) internal balances;\n  uint256 internal totalSupply_;\n\n  // Stored as values. Units can be found using valueToUnits().\n  mapping(address => mapping(address => uint256)) internal allowed;\n\n  // STABILITY FEE PARAMETERS\n\n  // The `rate` is how much the `factor` is adjusted by per `updatePeriod`.\n  // The `factor` describes units/value of StableToken, and is greater than or equal to 1.\n  // The `updatePeriod` governs how often the `factor` is updated.\n  // `factorLastUpdated` indicates when the inflation factor was last updated.\n  struct InflationState {\n    FixidityLib.Fraction rate;\n    FixidityLib.Fraction factor;\n    uint256 updatePeriod;\n    uint256 factorLastUpdated;\n  }\n\n  InflationState inflationState;\n\n  /**\n   * Only VM would be able to set the caller address to 0x0 unless someone\n   * really has the private key for 0x0\n   */\n  modifier onlyVm() {\n    require(msg.sender == address(0), \"sender was not vm (reserved 0x0 addr)\");\n    _;\n  }\n\n  /**\n   * @notice recomputes and updates inflation factor if more than `updatePeriod`\n   * has passed since last update.\n   */\n  modifier updateInflationFactor() {\n    FixidityLib.Fraction memory updatedInflationFactor;\n    uint256 lastUpdated;\n\n    (updatedInflationFactor, lastUpdated) = getUpdatedInflationFactor();\n\n    if (lastUpdated != inflationState.factorLastUpdated) {\n      inflationState.factor = updatedInflationFactor;\n      inflationState.factorLastUpdated = lastUpdated;\n      emit InflationFactorUpdated(inflationState.factor.unwrap(), inflationState.factorLastUpdated);\n    }\n    _;\n  }\n\n  /**\n   * @param _name The name of the stable token (English)\n   * @param _symbol A short symbol identifying the token (e.g. \"cUSD\")\n   * @param _decimals Tokens are divisible to this many decimal places.\n   * @param registryAddress Address of the Registry contract.\n   * @param inflationRate weekly inflation rate.\n   * @param inflationFactorUpdatePeriod how often the inflation factor is updated.\n   */\n  function initialize(\n    string calldata _name,\n    string calldata _symbol,\n    uint8 _decimals,\n    address registryAddress,\n    uint256 inflationRate,\n    uint256 inflationFactorUpdatePeriod,\n    address[] calldata initialBalanceAddresses,\n    uint256[] calldata initialBalanceValues\n  ) external initializer {\n    require(inflationRate != 0, \"Must provide a non-zero inflation rate.\");\n\n    _transferOwnership(msg.sender);\n    totalSupply_ = 0;\n    name_ = _name;\n    symbol_ = _symbol;\n    decimals_ = _decimals;\n\n    inflationState.rate = FixidityLib.wrap(inflationRate);\n    inflationState.factor = FixidityLib.fixed1();\n    inflationState.updatePeriod = inflationFactorUpdatePeriod;\n    // solhint-disable-next-line not-rely-on-time\n    inflationState.factorLastUpdated = now;\n\n    require(initialBalanceAddresses.length == initialBalanceValues.length, \"Array length mismatch\");\n    for (uint256 i = 0; i < initialBalanceAddresses.length; i = i.add(1)) {\n      require(_mint(initialBalanceAddresses[i], initialBalanceValues[i]), \"mint failed\");\n    }\n    setRegistry(registryAddress);\n  }\n\n  /**\n   * @notice Updates Inflation Parameters.\n   * @param rate new rate.\n   * @param updatePeriod how often inflationFactor is updated.\n   */\n  function setInflationParameters(uint256 rate, uint256 updatePeriod)\n    external\n    onlyOwner\n    updateInflationFactor\n  {\n    require(rate != 0, \"Must provide a non-zero inflation rate.\");\n    inflationState.rate = FixidityLib.wrap(rate);\n    inflationState.updatePeriod = updatePeriod;\n\n    emit InflationParametersUpdated(\n      rate,\n      updatePeriod,\n      // solhint-disable-next-line not-rely-on-time\n      now\n    );\n  }\n\n  /**\n   * @notice Increase the allowance of another user.\n   * @param spender The address which is being approved to spend StableToken.\n   * @param value The increment of the amount of StableToken approved to the spender.\n   * @return True if the transaction succeeds.\n   */\n  function increaseAllowance(address spender, uint256 value)\n    external\n    updateInflationFactor\n    returns (bool)\n  {\n    uint256 oldValue = allowed[msg.sender][spender];\n    uint256 newValue = oldValue.add(value);\n    allowed[msg.sender][spender] = newValue;\n    emit Approval(msg.sender, spender, newValue);\n    return true;\n  }\n\n  /**\n   * @notice Decrease the allowance of another user.\n   * @param spender The address which is being approved to spend StableToken.\n   * @param value The decrement of the amount of StableToken approved to the spender.\n   * @return True if the transaction succeeds.\n   */\n  function decreaseAllowance(address spender, uint256 value)\n    external\n    updateInflationFactor\n    returns (bool)\n  {\n    uint256 oldValue = allowed[msg.sender][spender];\n    uint256 newValue = oldValue.sub(value);\n    allowed[msg.sender][spender] = newValue;\n    emit Approval(msg.sender, spender, newValue);\n    return true;\n  }\n\n  /**\n   * @notice Approve a user to transfer StableToken on behalf of another user.\n   * @param spender The address which is being approved to spend StableToken.\n   * @param value The amount of StableToken approved to the spender.\n   * @return True if the transaction succeeds.\n   */\n  function approve(address spender, uint256 value) external updateInflationFactor returns (bool) {\n    allowed[msg.sender][spender] = value;\n    emit Approval(msg.sender, spender, value);\n    return true;\n  }\n\n  /**\n   * @notice Mints new StableToken and gives it to 'to'.\n   * @param to The account for which to mint tokens.\n   * @param value The amount of StableToken to mint.\n   */\n  function mint(address to, uint256 value) external updateInflationFactor returns (bool) {\n    require(\n      msg.sender == registry.getAddressFor(EXCHANGE_REGISTRY_ID) ||\n        msg.sender == registry.getAddressFor(VALIDATORS_REGISTRY_ID),\n      \"Only the Exchange and Validators contracts are authorized to mint\"\n    );\n    return _mint(to, value);\n  }\n\n  /**\n   * @notice Mints new StableToken and gives it to 'to'.\n   * @param to The account for which to mi"
    }
  ]
}