{
  "Title": "`Chainlink.latestRoundData()` may return stale results",
  "Content": "# `Chainlink.latestRoundData()` may return stale results\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/main/contracts/oracles/ChainlinkOracle.sol#L151-L170\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/main/contracts/oracles/ChainlinkOracle.sol#L151-L170</a>\n\n\n## Summary\nThe `_getChainlinkResponse()` function is used to get the price of tokens, the problem is that the function does not check for stale results.\n\n## Vulnerability Details\nThe `ChainlinkOracle._getChainlinkResponse()` function is used to get latest Chainlink response.\n```solidity\nfunction _getChainlinkResponse(address _feed) internal view returns (ChainlinkResponse memory) {\n    ChainlinkResponse memory _chainlinkResponse;\n\n    _chainlinkResponse.decimals = AggregatorV3Interface(_feed).decimals();\n\n    (\n      uint80 _latestRoundId,\n      int256 _latestAnswer,\n      /* uint256 _startedAt */,\n      uint256 _latestTimestamp,\n      /* uint80 _answeredInRound */\n    ) = AggregatorV3Interface(_feed).latestRoundData();\n\n    _chainlinkResponse.roundId = _latestRoundId;\n    _chainlinkResponse.answer = _latestAnswer;\n    _chainlinkResponse.timestamp = _latestTimestamp;\n    _chainlinkResponse.success = true;\n\n    return _chainlinkResponse;\n  }\n\n```\n\nThe problem is that there is not check for stale data. There are some reasons that the price feed can become stale.\n## Impact\nSince the token prices are used in many contracts, stale data could be catastrophic for the project.\n\n\n## Tools Used\n\n## Recommendations\nRead the updatedAt return value from the `Chainlink.latestRoundData()` function and verify that is not older than than specific time tolerance.\n```solidity\nrequire(block.timestamp - udpatedData < toleranceTime, \"stale price\");\n```",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/clo38mm260001la08daw5cbuf",
  "Code": [
    {
      "filename": "contracts/oracles/ChainlinkOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { Ownable2Step } from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport { Pausable } from \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { AggregatorV3Interface } from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport { Errors } from \"../utils/Errors.sol\";\n\ncontract ChainlinkOracle is Ownable2Step, Pausable {\n  using SafeCast for int256;\n\n  /* ======================= STRUCTS ========================= */\n\n  struct ChainlinkResponse {\n    uint80 roundId;\n    int256 answer;\n    uint256 timestamp;\n    bool success;\n    uint8 decimals;\n  }\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n\n  /* ======================= MAPPINGS ======================== */\n\n  // Mapping of token to Chainlink USD price feed\n  mapping(address => address) public feeds;\n  // Mapping of token to maximum delay allowed (in seconds) of last price update\n  mapping(address => uint256) public maxDelays;\n  // Mapping of token to maximum % deviation allowed (in 1e18) of last price update\n  mapping(address => uint256) public maxDeviations;\n\n  /* ====================== CONSTRUCTOR ====================== */\n\n  constructor() Ownable(msg.sender) {}\n\n  /* ===================== VIEW FUNCTIONS ==================== */\n\n  /**\n    * @notice Get token price from Chainlink feed\n    * @param token Token address\n    * @return price Asset price in int256\n    * @return decimals Price decimals in uint8\n    */\n  function consult(address token) public view whenNotPaused returns (int256, uint8) {\n    address _feed = feeds[token];\n\n    if (_feed == address(0)) revert Errors.NoTokenPriceFeedAvailable();\n\n    ChainlinkResponse memory chainlinkResponse = _getChainlinkResponse(_feed);\n    ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(_feed, chainlinkResponse.roundId);\n\n    if (_chainlinkIsFrozen(chainlinkResponse, token)) revert Errors.FrozenTokenPriceFeed();\n    if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse, token)) revert Errors.BrokenTokenPriceFeed();\n\n    return (chainlinkResponse.answer, chainlinkResponse.decimals);\n  }\n\n  /**\n    * @notice Get token price from Chainlink feed returned in 1e18\n    * @param token Token address\n    * @return price in 1e18\n    */\n  function consultIn18Decimals(address token) external view whenNotPaused returns (uint256) {\n    (int256 _answer, uint8 _decimals) = consult(token);\n\n    return _answer.toUint256() * 1e18 / (10 ** _decimals);\n  }\n\n  /* ================== INTERNAL FUNCTIONS =================== */\n\n  /**\n    * @notice Check if Chainlink oracle is not working as expected\n    * @param currentResponse Current Chainlink response\n    * @param prevResponse Previous Chainlink response\n    * @param token Token address\n    * @return Status of check in boolean\n  */\n  function _chainlinkIsBroken(\n    ChainlinkResponse memory currentResponse,\n    ChainlinkResponse memory prevResponse,\n    address token\n  ) internal view returns (bool) {\n    return _badChainlinkResponse(currentResponse) ||\n           _badChainlinkResponse(prevResponse) ||\n           _badPriceDeviation(currentResponse, prevResponse, token);\n  }\n\n  /**\n    * @notice Checks to see if Chainlink oracle is returning a bad response\n    * @param response Chainlink response\n    * @return Status of check in boolean\n  */\n  function _badChainlinkResponse(ChainlinkResponse memory response) internal view returns (bool) {\n    // Check for response call reverted\n    if (!response.success) { return true; }\n    // Check for an invalid roundId that is 0\n    if (response.roundId == 0) { return true; }\n    // Check for an invalid timeStamp that is 0, or in the future\n    if (response.timestamp == 0 || response.timestamp > block.timestamp) { return true; }\n    // Check for non-positive price\n    if (response.answer == 0) { return true; }\n\n    return false;\n  }\n\n  /**\n    * @notice Check to see if Chainlink oracle response is frozen/too stale\n    * @param response Chainlink response\n    * @param token Token address\n    * @return Status of check in boolean\n  */\n  function _chainlinkIsFrozen(ChainlinkResponse memory response, address token) internal view returns (bool) {\n    return (block.timestamp - response.timestamp) > maxDelays[token];\n  }\n\n  /**\n    * @notice Check to see if Chainlink oracle current response's price price deviation\n    * is too large compared to previous response's price\n    * @param currentResponse Current Chainlink response\n    * @param prevResponse Previous Chainlink response\n    * @param token Token address\n    * @return Status of check in boolean\n  */\n  function _badPriceDeviation(\n    ChainlinkResponse memory currentResponse,\n    ChainlinkResponse memory prevResponse,\n    address token\n  ) internal view returns (bool) {\n    // Check for a deviation that is too large\n    uint256 _deviation;\n\n    if (currentResponse.answer > prevResponse.answer) {\n      _deviation = uint256(currentResponse.answer - prevResponse.answer) * SAFE_MULTIPLIER / uint256(prevResponse.answer);\n    } else {\n      _deviation = uint256(prevResponse.answer - currentResponse.answer) * SAFE_MULTIPLIER / uint256(prevResponse.answer);\n    }\n\n    return _deviation > maxDeviations[token];\n  }\n\n  /**\n    * @notice Get latest Chainlink response\n    * @param _feed Chainlink oracle feed address\n    * @return ChainlinkResponse\n  */\n  function _getChainlinkResponse(address _feed) internal view returns (ChainlinkResponse memory) {\n    ChainlinkResponse memory _chainlinkResponse;\n\n    _chainlinkResponse.decimals = AggregatorV3Interface(_feed).decimals();\n\n    (\n      uint80 _latestRoundId,\n      int256 _latestAnswer,\n      /* uint256 _startedAt */,\n      uint256 _latestTimestamp,\n      /* uint80 _answeredInRound */\n    ) = AggregatorV3Interface(_feed).latestRoundData();\n\n    _chainlinkResponse.roundId = _latestRoundId;\n    _chainlinkResponse.answer = _latestAnswer;\n    _chainlinkResponse.timestamp = _latestTimestamp;\n    _chainlinkResponse.success = true;\n\n    return _chainlinkResponse;\n  }\n\n  /**\n    * @notice Get previous round's Chainlink response from current round\n    * @param _feed Chainlink oracle feed address\n    * @param _currentRoundId Current roundId from current Chainlink response\n    * @return ChainlinkResponse\n  */\n  function _getPrevChainlinkResponse(address _feed, uint80 _currentRoundId) internal view returns (ChainlinkResponse memory) {\n    ChainlinkResponse memory _prevChainlinkResponse;\n\n    (\n      uint80 _roundId,\n      int256 _answer,\n      /* uint256 _startedAt */,\n      uint256 _timestamp,\n      /* uint80 _answeredInRound */\n    ) = AggregatorV3Interface(_feed).getRoundData(_currentRoundId - 1);\n\n    _prevChainlinkResponse.roundId = _roundId;\n    _prevChainlinkResponse.answer = _answer;\n    _prevChainlinkResponse.timestamp = _timestamp;\n    _prevChainlinkResponse.success = true;\n\n    return _prevChainlinkResponse;\n  }\n\n  /* ================= RESTRICTED FUNCTIONS ================== */\n\n  /**\n    * @notice Add Chainlink price feed for token\n    * @param token Token address\n    * @param feed Chainlink price feed address\n    */\n  function addTokenPriceFeed(address token, address feed) external onlyOwner {\n    if (token == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (feed == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (feeds[token] != address(0)) revert Errors.TokenPriceFeedAlreadySet();\n\n    feeds[token] = feed;\n  }\n\n  /**\n    * @notice Add Chainlink max delay for token\n    * @param token Token address\n    * @param maxDelay  Max delay allowed in seconds\n  */\n  function addTokenMaxDelay(address token, uint256 maxDelay) external onlyOwner {\n    if (token == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (feeds[token] == address(0)) revert Errors.NoTokenPriceFeedAvailable();\n    if (maxDelay < 0) revert Errors.TokenPriceFeedMaxDelayMustBeGreaterOrEqualToZero();\n\n    maxDelays[token] = maxDelay;\n  }\n\n  /**\n    * @notice Add Chainlink max deviation for token\n    * @param token Token address\n    * @param maxDeviation  Max deviation allowed in seconds\n  */\n  function addTokenMaxDeviation(address token, uint256 maxDeviation) external onlyOwner {\n    if (token == address(0)) revert Errors.ZeroAddressNotAllowed();\n    if (feeds[token] == address(0)) revert Errors.NoTokenPriceFeedAvailable();\n    if (maxDeviation < 0) revert Errors.TokenPriceFeedMaxDeviationMustBeGreaterOrEqualToZero();\n\n    maxDeviations[token] = maxDeviation;\n  }\n\n  /**\n    * @notice Emergency pause of this oracle\n  */\n  function emergencyPause() external onlyOwner whenNotPaused {\n    _pause();\n  }\n\n  /**\n    * @notice Emergency resume of this oracle\n  */\n  function emergencyResume() external onlyOwner whenPaused {\n    _unpause();\n  }\n}"
    }
  ]
}