{
  "Title": "[L14] Incomplete event emissions",
  "Content": "When defining events with the sole purpose of showing a storage modification, it is a good practice to emit both the old value and the new value of the modified variable. *Some examples* are:\n\n\n* The `UniswapUpdated` event in the [`Buyback`](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/buyback/Buyback.sol#L12) and [`BuybackConstructor`](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/buyback/BuybackConstructor.sol#L12) contract should emit both the old and the new uniswap addresses.\n* The [`PriceProviderUpdated`](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/vault/VaultAdmin.sol#L45), [`RedeemFeeUpdated`](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/vault/VaultAdmin.sol#L54), [`VaultBufferUpdated`](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/vault/VaultAdmin.sol#L68), [`AllocateThresholdUpdated`](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/vault/VaultAdmin.sol#L81), [`RebaseThresholdUpdated`](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/vault/VaultAdmin.sol#L91), [`UniswapUpdated`](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/vault/VaultAdmin.sol#L101) events (among others) in the `VaultAdmin` contract should emit the old and new value that is being updated.\n\n\nAdditionally, the [`Withdrawal` event](https://github.com/OriginProtocol/origin-dollar/blob/bf4ff28d5944ecc277e66294fd2c702fee5cd58b/contracts/contracts/strategies/ThreePoolStrategy.sol#L167) in the `ThreePoolStrategy` contract should also emit the beneficiary address (i.e., who receives the assets).\n\n\nConsider reviewing all the events that are being emitted throughout the codebase and checking that all sensitive variables are being emitted, to avoid hindering the task of off-chain services interested in these events.\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/contracts/buyback/Buyback.sol",
      "content": "pragma solidity 0.5.11;\n\nimport { Governable } from \"../governance/Governable.sol\";\n\nimport { IUniswapV2Router } from \"../interfaces/uniswap/IUniswapV2Router02.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\ncontract Buyback is Governable {\n    using SafeERC20 for IERC20;\n\n    event UniswapUpdated(address _address);\n\n    // Address of Uniswap\n    address public uniswapAddr = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n\n    // Address of OUSD Vault\n    address constant public vaultAddr = 0xE75D77B1865Ae93c7eaa3040B038D7aA7BC02F70;\n\n    // Swap from OUSD\n    IERC20 constant ousd = IERC20(0x2A8e1E676Ec238d8A992307B495b45B3fEAa5e86);\n\n    // Swap to OGN\n    IERC20 constant ogn = IERC20(0x8207c1FfC5B6804F6024322CcF34F29c3541Ae26);\n\n    // USDT for Uniswap path\n    IERC20 constant usdt = IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7);\n\n    /**\n     * @dev Verifies that the caller is the OUSD Vault.\n     */\n    modifier onlyVault() {\n        require(vaultAddr == msg.sender, \"Caller is not the Vault\");\n        _;\n    }\n\n    /**\n     * @dev Set address of Uniswap for performing liquidation of strategy reward\n     * tokens. Setting to 0x0 will pause swaps.\n     * @param _address Address of Uniswap\n     */\n    function setUniswapAddr(address _address) external onlyGovernor {\n        uniswapAddr = _address;\n        // Give Uniswap unlimited OUSD allowance\n        ousd.safeApprove(uniswapAddr, 0);\n        ousd.safeApprove(uniswapAddr, uint256(-1));\n        emit UniswapUpdated(_address);\n    }\n\n    /**\n     * @dev Execute a swap of OGN for OUSD via Uniswap or Uniswap compatible\n     * protocol (e.g. Sushiswap)\n     **/\n    function swap() external onlyVault {\n        if (uniswapAddr == address(0)) return;\n\n        uint256 sourceAmount = ousd.balanceOf(address(this));\n        if (sourceAmount < 1000 * 1e18) return;\n\n        // Uniswap redemption path\n        address[] memory path = new address[](4);\n        path[0] = address(ousd);\n        path[1] = address(usdt);\n        path[2] = IUniswapV2Router(uniswapAddr).WETH();\n        path[3] = address(ogn);\n        IUniswapV2Router(uniswapAddr).swapExactTokensForTokens(\n            sourceAmount,\n            uint256(0),\n            path,\n            address(this),\n            now\n        );\n    }\n\n    /**\n     * @notice Owner function to withdraw a specific amount of a token\n     */\n    function transferToken(address token, uint256 amount)\n        external\n        onlyGovernor\n        nonReentrant\n    {\n        IERC20(token).safeTransfer(_governor(), amount);\n    }\n}"
    },
    {
      "filename": "contracts/contracts/vault/VaultAdmin.sol",
      "content": "pragma solidity 0.5.11;\n\n/**\n * @title OUSD Vault Admin Contract\n * @notice The VaultAdmin contract makes configuration and admin calls on the vault.\n * @author Origin Protocol Inc\n */\n\nimport \"./VaultStorage.sol\";\nimport { IOracle } from \"../interfaces/IOracle.sol\";\nimport { IUniswapV2Router } from \"../interfaces/uniswap/IUniswapV2Router02.sol\";\n\ncontract VaultAdmin is VaultStorage {\n    /**\n     * @dev Verifies that the caller is the Vault, Governor, or Strategist.\n     */\n    modifier onlyVaultOrGovernorOrStrategist() {\n        require(\n            msg.sender == address(this) ||\n                msg.sender == strategistAddr ||\n                isGovernor(),\n            \"Caller is not the Vault, Governor, or Strategist\"\n        );\n        _;\n    }\n\n    modifier onlyGovernorOrStrategist() {\n        require(\n            msg.sender == strategistAddr || isGovernor(),\n            \"Caller is not the Strategist or Governor\"\n        );\n        _;\n    }\n\n    /***************************************\n                 Configuration\n    ****************************************/\n\n    /**\n     * @dev Set address of price provider.\n     * @param _priceProvider Address of price provider\n     */\n    function setPriceProvider(address _priceProvider) external onlyGovernor {\n        priceProvider = _priceProvider;\n        emit PriceProviderUpdated(_priceProvider);\n    }\n\n    /**\n     * @dev Set a fee in basis points to be charged for a redeem.\n     * @param _redeemFeeBps Basis point fee to be charged\n     */\n    function setRedeemFeeBps(uint256 _redeemFeeBps) external onlyGovernor {\n        redeemFeeBps = _redeemFeeBps;\n        emit RedeemFeeUpdated(_redeemFeeBps);\n    }\n\n    /**\n     * @dev Set a buffer of assets to keep in the Vault to handle most\n     * redemptions without needing to spend gas unwinding assets from a Strategy.\n     * @param _vaultBuffer Percentage using 18 decimals. 100% = 1e18.\n     */\n    function setVaultBuffer(uint256 _vaultBuffer)\n        external\n        onlyGovernorOrStrategist\n    {\n        require(_vaultBuffer <= 1e18, \"Invalid value\");\n        vaultBuffer = _vaultBuffer;\n        emit VaultBufferUpdated(_vaultBuffer);\n    }\n\n    /**\n     * @dev Sets the minimum amount of OUSD in a mint to trigger an\n     * automatic allocation of funds afterwords.\n     * @param _threshold OUSD amount with 18 fixed decimals.\n     */\n    function setAutoAllocateThreshold(uint256 _threshold)\n        external\n        onlyGovernor\n    {\n        autoAllocateThreshold = _threshold;\n        emit AllocateThresholdUpdated(_threshold);\n    }\n\n    /**\n     * @dev Set a minimum amount of OUSD in a mint or redeem that triggers a\n     * rebase\n     * @param _threshold OUSD amount with 18 fixed decimals.\n     */\n    function setRebaseThreshold(uint256 _threshold) external onlyGovernor {\n        rebaseThreshold = _threshold;\n        emit RebaseThresholdUpdated(_threshold);\n    }\n\n    /**\n     * @dev Set address of Uniswap for performing liquidation of strategy reward\n     * tokens\n     * @param _address Address of Uniswap\n     */\n    function setUniswapAddr(address _address) external onlyGovernor {\n        uniswapAddr = _address;\n        emit UniswapUpdated(_address);\n    }\n\n    /**\n     * @dev Set address of Strategist\n     * @param _address Address of Strategist\n     */\n    function setStrategistAddr(address _address) external onlyGovernor {\n        strategistAddr = _address;\n        emit StrategistUpdated(_address);\n    }\n\n    /**\n     * @dev Set the default Strategy for an asset, i.e. the one which the asset\n            will be automatically allocated to and withdrawn from\n     * @param _asset Address of the asset\n     * @param _strategy Address of the Strategy\n     */\n    function setAssetDefaultStrategy(address _asset, address _strategy)\n        external\n        onlyGovernorOrStrategist\n    {\n        emit AssetDefaultStrategyUpdated(_asset, _strategy);\n        require(strategies[_strategy].isSupported, \"Strategy not approved\");\n        IStrategy strategy = IStrategy(_strategy);\n        require(assets[_asset].isSupported, \"Asset is not supported\");\n        require(\n            strategy.supportsAsset(_asset),\n            \"Asset not supported by Strategy\"\n        );\n        assetDefaultStrategies[_asset] = _strategy;\n    }\n\n    /**\n     * @dev Add a supported asset to the contract, i.e. one that can be\n     *         to mint OUSD.\n     * @param _asset Address of asset\n     */\n    function supportAsset(address _asset) external onlyGovernor {\n        require(!assets[_asset].isSupported, \"Asset already supported\");\n\n        assets[_asset] = Asset({ isSupported: true });\n        allAssets.push(_asset);\n\n        // Verify that our oracle supports the asset\n        // slither-disable-next-line unused-return\n        IOracle(priceProvider).price(_asset);\n\n        emit AssetSupported(_asset);\n    }\n\n    /**\n     * @dev Add a strategy to the Vault.\n     * @param _addr Address of the strategy to add\n     */\n    function approveStrategy(address _addr) external onlyGovernor {\n        require(!strategies[_addr].isSupported, \"Strategy already approved\");\n        strategies[_addr] = Strategy({ isSupported: true, _deprecated: 0 });\n        allStrategies.push(_addr);\n        emit StrategyApproved(_addr);\n    }\n\n    /**\n     * @dev Remove a strategy from the Vault. Removes all invested assets and\n     * returns them to the Vault.\n     * @param _addr Address of the strategy to remove\n     */\n\n    function removeStrategy(address _addr) external onlyGovernor {\n        require(strategies[_addr].isSupported, \"Strategy not approved\");\n\n        // Initialize strategyIndex with out of bounds result so function will\n        // revert if no valid index found\n        uint256 strategyIndex = allStrategies.length;\n        for (uint256 i = 0; i < allStrategies.length; i++) {\n            if (allStrategies[i] == _addr) {\n                strategyIndex = i;\n                break;\n            }\n        }\n\n        if (strategyIndex < allStrategies.length) {\n            allStrategies[strategyIndex] = allStrategies[allStrategies.length -\n                1];\n            allStrategies.pop();\n\n            // Withdraw all assets\n            IStrategy strategy = IStrategy(_addr);\n            strategy.withdrawAll();\n            // Call harvest after withdraw in case withdraw triggers\n            // distribution of additional reward tokens (true for Compound)\n            _harvest(_addr);\n            emit StrategyRemoved(_addr);\n        }\n\n        // Clean up struct in mapping, this can be removed later\n        // See https://github.com/OriginProtocol/origin-dollar/issues/324\n        strategies[_addr].isSupported = false;\n    }\n\n    /**\n     * @notice Move assets from one Strategy to another\n     * @param _strategyFromAddress Address of Strategy to move assets from.\n     * @param _strategyToAddress Address of Strategy to move assets to.\n     * @param _assets Array of asset address that will be moved\n     * @param _amounts Array of amounts of each corresponding asset to move.\n     */\n    function reallocate(\n        address _strategyFromAddress,\n        address _strategyToAddress,\n        address[] calldata _assets,\n        uint256[] calldata _amounts\n    ) external onlyGovernorOrStrategist {\n        require(\n            strategies[_strategyFromAddress].isSupported,\n            \"Invalid from Strategy\"\n        );\n        require(\n            strategies[_strategyToAddress].isSupported,\n            \"Invalid to Strategy\"\n        );\n        require(_assets.length == _amounts.length, \"Parameter length mismatch\");\n\n        IStrategy strategyFrom = IStrategy(_strategyFromAddress);\n        IStrategy strategyTo = IStrategy(_strategyToAddress);\n\n        for (uint256 i = 0; i < _assets.length; i++) {\n            require(strategyTo.supportsAsset(_assets[i]), \"Asset unsupported\");\n            // Withdraw from Strategy and pass other Strategy as recipient\n            strategyFrom.withdraw(address(strategyTo), _assets[i], _amounts[i]);\n        }\n        // Tell new Strategy to deposit into protocol\n        strategyTo.depositAll();\n    }\n\n    /**\n     * @dev Sets the maximum allowable difference between\n     * total supply and backing assets' value.\n     */\n    function setMaxSupplyDiff(uint256 _maxSupplyDiff) external onlyGovernor {\n        maxSupplyDiff = _maxSupplyDiff;\n        emit MaxSupplyDiffChanged(_maxSupplyDiff);\n    }\n\n    /**\n     * @dev Sets the trusteeAddress that can receive a portion of yield.\n     *      Setting to the zero address disables this feature.\n     */\n    function setTrusteeAddress(address _address) external onlyGovernor {\n        trusteeAddress = _address;\n        emit TrusteeAddressChanged(_address);\n    }\n\n    /**\n     * @dev Sets the TrusteeFeeBps to the percentage of yield that should be\n     *      received in basis points.\n     */\n    function setTrusteeFeeBps(uint256 _basis) external onlyGovernor {\n        require(_basis <= 5000, \"basis cannot exceed 50%\");\n        trusteeFeeBps = _basis;\n        emit TrusteeFeeBpsChanged(_basis);\n    }\n\n    /***************************************\n                    Pause\n    ****************************************/\n\n    /**\n     * @dev Set the deposit paused flag to true to prevent rebasing.\n     */\n    function pauseRebase() external onlyGovernorOrStrategist {\n        rebasePaused = true;\n        emit RebasePaused();\n    }\n\n    /**\n     * @dev Set the deposit paused flag to true to allow rebasing.\n     */\n    function unpauseRebase() external onlyGovernor {\n        rebasePaused = false;\n        emit RebaseUnpaused();\n    }\n\n    /**\n     * @dev Set the deposit paused flag to true to prevent capital movement.\n     */\n    function pauseCapital() external onlyGovernorOrStrategist {\n        capitalPaused = true;\n        emit CapitalPaused();\n    }\n\n    /**\n     * @dev Set the deposit paused flag to false to enable capital movement.\n     */\n    function unpauseCapital() external onlyGovernorOrStrategist {\n        capitalPaused = false;\n        emit CapitalUnpaused();\n    }\n\n    /***************************************\n                    Rewards\n    ****************************************/\n\n    /**\n     * @dev Transfer token to governor. Intended for recovering tokens stuck in\n     *      contract, i.e. mistaken sends.\n     * @param _asset Address for the asset\n     * @param _amount Amount of the asset to transfer\n     */\n    function transferToken(address _asset, uint256 _amount)\n        external\n        onlyGovernor\n    {\n        require(!assets[_asset].isSupported, \"Only unsupported assets\");\n        IERC20(_asset).safeTransfer(governor(), _amount);\n    }\n\n    /**\n     * @dev Collect reward tokens from all strategies and swap for supported\n     *      stablecoin via Uniswap\n     */\n    function harvest() external onlyGovernorOrStrategist {\n        for (uint256 i = 0; i < allStrategies.length; i++) {\n            _harvest(allStrategies[i]);\n        }\n    }\n\n    /**\n     * @dev Collect reward tokens for a specific strategy and swap for supported\n     *      stablecoin via Uniswap. Called from the vault.\n     * @param _strategyAddr Address of the strategy to collect rewards from\n     */\n    function harvest(address _strategyAddr)\n        external\n        onlyVaultOrGovernorOrStrategist\n        returns (uint256[] memory)\n    {\n        return _harvest(_strategyAddr);\n    }\n\n    /**\n     * @dev Collect reward tokens from a single strategy and swap them for a\n     *      supported stablecoin via Uniswap\n     * @param _strategyAddr Address of the strategy to collect rewards from\n     */\n    function _harvest(address _strategyAddr)\n        internal\n        returns (uint256[] memory)\n    {\n        IStrategy strategy = IStrategy(_strategyAddr);\n        address rewardTokenAddress = strategy.rewardTokenAddress();\n        if (rewardTokenAddress != address(0)) {\n            strategy.collectRewardToken();\n\n            if (uniswapAddr != address(0)) {\n                IERC20 rewardToken = IERC20(strategy.rewardTokenAddress());\n                uint256 rewardTokenAmount = rewardToken.balanceOf(\n                    address(this)\n                );\n                if (rewardTokenAmount > 0) {\n                    // Give Uniswap full amount allowance\n                    rewardToken.safeApprove(uniswapAddr, 0);\n                    rewardToken.safeApprove(uniswapAddr, rewardTokenAmount);\n\n                    // Uniswap redemption path\n                    address[] memory path = new address[](3);\n                    path[0] = strategy.rewardTokenAddress();\n                    path[1] = IUniswapV2Router(uniswapAddr).WETH();\n                    path[2] = allAssets[1]; // USDT\n\n                    return\n                        IUniswapV2Router(uniswapAddr).swapExactTokensForTokens(\n                            rewardTokenAmount,\n                            uint256(0),\n                            path,\n                            address(this),\n                            now.add(1800)\n                        );\n                }\n            }\n        }\n    }\n\n    /***************************************\n                    Pricing\n    ****************************************/\n\n    /**\n     * @dev Returns the total price in 18 digit USD for a given asset.\n     *      Never goes above 1, since that is how we price mints\n     * @param asset address of the asset\n     * @return uint256 USD price of 1 of the asset, in 18 decimal fixed\n     */\n    function priceUSDMint(address asset) external view returns (uint256) {\n        uint256 price = IOracle(priceProvider).price(asset);\n        if (price > 1e8) {\n            price = 1e8;\n        }\n        // Price from Oracle is returned with 8 decimals\n        // scale to 18 so 18-8=10\n        return price.scaleBy(10);\n    }\n\n    /**\n     * @dev Returns the total price in 18 digit USD for a given asset.\n     *      Never goes below 1, since that is how we price redeems\n     * @param asset Addresss of the asset\n     * @return uint256 USD price of 1 of the asset, in 18 decimal fixed\n     */\n    function priceUSDRedeem(address asset) external view returns (uint256) {\n        uint256 price = IOracle(priceProvider).price(asset);\n        if (price < 1e8) {\n            price = 1e8;\n        }\n        // Price from Oracle is returned with 8 decimals\n        // scale to 18 so 18-8=10\n        return price.scaleBy(10);\n    }\n\n    /***************************************\n             Strategies Admin\n    ****************************************/\n\n    /**\n     * @dev Withdraws all assets from the strategy and sends assets to the Vault.\n     * @param _strategyAddr Strategy address.\n     */\n    function withdrawAllFromStrategy(address _strategyAddr)\n        external\n        onlyGovernorOrStrategist\n    {\n        require(\n            strategies[_strategyAddr].isSupported,\n            \"Strategy is not supported\"\n        );\n        IStrategy strategy = IStrategy(_strategyAddr);\n        strategy.withdrawAll();\n    }\n\n    /**\n     * @dev Withdraws all assets from all the strategies and sends assets to the Vault.\n     */\n    function withdrawAllFromStrategies() external onlyGovernorOrStrategist {\n        for (uint256 i = 0; i < allStrategies.length; i++) {\n            IStrategy strategy = IStrategy(allStrategies[i]);\n            strategy.withdrawAll();\n        }\n    }\n}"
    },
    {
      "filename": "contracts/contracts/strategies/ThreePoolStrategy.sol",
      "content": "pragma solidity 0.5.11;\n\n/**\n * @title Curve 3Pool Strategy\n * @notice Investment strategy for investing stablecoins via Curve 3Pool\n * @author Origin Protocol Inc\n */\n\nimport { ICurvePool } from \"./ICurvePool.sol\";\nimport { ICurveGauge } from \"./ICurveGauge.sol\";\nimport { ICRVMinter } from \"./ICRVMinter.sol\";\nimport {\n    IERC20,\n    InitializableAbstractStrategy\n} from \"../utils/InitializableAbstractStrategy.sol\";\nimport { StableMath } from \"../utils/StableMath.sol\";\nimport { Helpers } from \"../utils/Helpers.sol\";\n\ncontract ThreePoolStrategy is InitializableAbstractStrategy {\n    using StableMath for uint256;\n\n    event RewardTokenCollected(address recipient, uint256 amount);\n\n    address crvGaugeAddress;\n    address crvMinterAddress;\n    uint256 constant maxSlippage = 1e16; // 1%, same as the Curve UI\n\n    /**\n     * Initializer for setting up strategy internal state. This overrides the\n     * InitializableAbstractStrategy initializer as Curve strategies don't fit\n     * well within that abstraction.\n     * @param _platformAddress Address of the Curve 3pool\n     * @param _vaultAddress Address of the vault\n     * @param _rewardTokenAddress Address of CRV\n     * @param _assets Addresses of supported assets. MUST be passed in the same\n     *                order as returned by coins on the pool contract, i.e.\n     *                DAI, USDC, USDT\n     * @param _pTokens Platform Token corresponding addresses\n     * @param _crvGaugeAddress Address of the Curve DAO gauge for this pool\n     * @param _crvMinterAddress Address of the CRV minter for rewards\n     */\n    function initialize(\n        address _platformAddress, // 3Pool address\n        address _vaultAddress,\n        address _rewardTokenAddress, // CRV\n        address[] calldata _assets,\n        address[] calldata _pTokens,\n        address _crvGaugeAddress,\n        address _crvMinterAddress\n    ) external onlyGovernor initializer {\n        // Should be set prior to abstract initialize call otherwise\n        // abstractSetPToken calls will fail\n        crvGaugeAddress = _crvGaugeAddress;\n        crvMinterAddress = _crvMinterAddress;\n        InitializableAbstractStrategy._initialize(\n            _platformAddress,\n            _vaultAddress,\n            _rewardTokenAddress,\n            _assets,\n            _pTokens\n        );\n    }\n\n    /**\n     * @dev Collect accumulated CRV and send to Vault.\n     */\n    function collectRewardToken() external onlyVault nonReentrant {\n        IERC20 crvToken = IERC20(rewardTokenAddress);\n        ICRVMinter minter = ICRVMinter(crvMinterAddress);\n        uint256 balance = crvToken.balanceOf(address(this));\n        emit RewardTokenCollected(vaultAddress, balance);\n        minter.mint(crvGaugeAddress);\n        crvToken.safeTransfer(vaultAddress, balance);\n    }\n\n    /**\n     * @dev Deposit asset into the Curve 3Pool\n     * @param _asset Address of asset to deposit\n     * @param _amount Amount of asset to deposit\n     */\n    function deposit(address _asset, uint256 _amount)\n        external\n        onlyVault\n        nonReentrant\n    {\n        require(_amount > 0, \"Must deposit something\");\n        emit Deposit(_asset, address(platformAddress), _amount);\n        // 3Pool requires passing deposit amounts for all 3 assets, set to 0 for\n        // all\n        uint256[3] memory _amounts;\n        uint256 poolCoinIndex = _getPoolCoinIndex(_asset);\n        // Set the amount on the asset we want to deposit\n        _amounts[poolCoinIndex] = _amount;\n        ICurvePool curvePool = ICurvePool(platformAddress);\n        uint256 assetDecimals = Helpers.getDecimals(_asset);\n        uint256 depositValue = _amount\n            .scaleBy(int8(18 - assetDecimals))\n            .divPrecisely(curvePool.get_virtual_price());\n        uint256 minMintAmount = depositValue.mulTruncate(\n            uint256(1e18).sub(maxSlippage)\n        );\n        // Do the deposit to 3pool\n        curvePool.add_liquidity(_amounts, minMintAmount);\n        // Deposit into Gauge\n        IERC20 pToken = IERC20(assetToPToken[_asset]);\n        ICurveGauge(crvGaugeAddress).deposit(\n            pToken.balanceOf(address(this)),\n            address(this)\n        );\n    }\n\n    /**\n     * @dev Deposit the entire balance of any supported asset into the Curve 3pool\n     */\n    function depositAll() external onlyVault nonReentrant {\n        uint256[3] memory _amounts = [uint256(0), uint256(0), uint256(0)];\n        uint256 depositValue = 0;\n        ICurvePool curvePool = ICurvePool(platformAddress);\n\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            address assetAddress = assetsMapped[i];\n            uint256 balance = IERC20(assetAddress).balanceOf(address(this));\n            if (balance > 0) {\n                uint256 poolCoinIndex = _getPoolCoinIndex(assetAddress);\n                // Set the amount on the asset we want to deposit\n                _amounts[poolCoinIndex] = balance;\n                uint256 assetDecimals = Helpers.getDecimals(assetAddress);\n                // Get value of deposit in Curve LP token to later determine\n                // the minMintAmount argument for add_liquidity\n                depositValue = depositValue.add(\n                    balance.scaleBy(int8(18 - assetDecimals)).divPrecisely(\n                        curvePool.get_virtual_price()\n                    )\n                );\n                emit Deposit(assetAddress, address(platformAddress), balance);\n            }\n        }\n\n        uint256 minMintAmount = depositValue.mulTruncate(\n            uint256(1e18).sub(maxSlippage)\n        );\n        // Do the deposit to 3pool\n        curvePool.add_liquidity(_amounts, minMintAmount);\n        // Deposit into Gauge, the PToken is the same (3Crv) for all mapped\n        // assets, so just get the address from the first one\n        IERC20 pToken = IERC20(assetToPToken[assetsMapped[0]]);\n        ICurveGauge(crvGaugeAddress).deposit(\n            pToken.balanceOf(address(this)),\n            address(this)\n        );\n    }\n\n    /**\n     * @dev Withdraw asset from Curve 3Pool\n     * @param _recipient Address to receive withdrawn asset\n     * @param _asset Address of asset to withdraw\n     * @param _amount Amount of asset to withdraw\n     */\n    function withdraw(\n        address _recipient,\n        address _asset,\n        uint256 _amount\n    ) external onlyVault nonReentrant {\n        require(_recipient != address(0), \"Invalid recipient\");\n        require(_amount > 0, \"Invalid amount\");\n\n        emit Withdrawal(_asset, address(assetToPToken[_asset]), _amount);\n\n        // Calculate how much of the pool token we need to withdraw\n        (uint256 contractPTokens, , uint256 totalPTokens) = _getTotalPTokens();\n\n        require(totalPTokens > 0, \"Insufficient 3CRV balance\");\n\n        uint256 poolCoinIndex = _getPoolCoinIndex(_asset);\n        // Calculate the max amount of the asset we'd get if we withdrew all the\n        // platform tokens\n        ICurvePool curvePool = ICurvePool(platformAddress);\n        uint256 maxAmount = curvePool.calc_withdraw_one_coin(\n            totalPTokens,\n            int128(poolCoinIndex)\n        );\n\n        // Calculate how many platform tokens we need to withdraw the asset amount\n        uint256 withdrawPTokens = totalPTokens.mul(_amount).div(maxAmount);\n        if (contractPTokens < withdrawPTokens) {\n            // Not enough of pool token exists on this contract, some must be\n            // staked in Gauge, unstake difference\n            ICurveGauge(crvGaugeAddress).withdraw(\n                withdrawPTokens.sub(contractPTokens)\n            );\n        }\n\n        // Calculate a minimum withdrawal amount\n        uint256 assetDecimals = Helpers.getDecimals(_asset);\n        // 3crv is 1e18, subtract slippage percentage and scale to asset\n        // decimals\n        uint256 minWithdrawAmount = withdrawPTokens\n            .mulTruncate(uint256(1e18).sub(maxSlippage))\n            .scaleBy(int8(assetDecimals - 18));\n\n        curvePool.remove_liquidity_one_coin(\n            withdrawPTokens,\n            int128(poolCoinIndex),\n            minWithdrawAmount\n        );\n        IERC20(_asset).safeTransfer(_recipient, _amount);\n\n        // Transfer any leftover dust back to the vault buffer.\n        uint256 dust = IERC20(_asset).balanceOf(address(this));\n        if (dust > 0) {\n            IERC20(_asset).safeTransfer(vaultAddress, dust);\n        }\n    }\n\n    /**\n     * @dev Remove all assets from platform and send them to Vault contract.\n     */\n    function withdrawAll() external onlyVaultOrGovernor nonReentrant {\n        // Withdraw all from Gauge\n        (, uint256 gaugePTokens, uint256 totalPTokens) = _getTotalPTokens();\n        ICurveGauge(crvGaugeAddress).withdraw(gaugePTokens);\n        uint256[3] memory minWithdrawAmounts = [\n            uint256(0),\n            uint256(0),\n            uint256(0)\n        ];\n        // Calculate min withdrawal amounts for each coin\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            address assetAddress = assetsMapped[i];\n            uint256 virtualBalance = checkBalance(assetAddress);\n            uint256 poolCoinIndex = _getPoolCoinIndex(assetAddress);\n            minWithdrawAmounts[poolCoinIndex] = virtualBalance.mulTruncate(\n                uint256(1e18).sub(maxSlippage)\n            );\n        }\n        // Remove liqudiity\n        ICurvePool threePool = ICurvePool(platformAddress);\n        threePool.remove_liquidity(totalPTokens, minWithdrawAmounts);\n        // Transfer assets out ot Vault\n        // Note that Curve will provide all 3 of the assets in 3pool even if\n        // we have not set PToken addresses for all of them in this strategy\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            IERC20 asset = IERC20(threePool.coins(i));\n            asset.safeTransfer(vaultAddress, asset.balanceOf(address(this)));\n        }\n    }\n\n    /**\n     * @dev Get the total asset value held in the platform\n     * @param _asset      Address of the asset\n     * @return balance    Total value of the asset in the platform\n     */\n    function checkBalance(address _asset)\n        public\n        view\n        returns (uint256 balance)\n    {\n        require(assetToPToken[_asset] != address(0), \"Unsupported asset\");\n        // LP tokens in this contract. This should generally be nothing as we\n        // should always stake the full balance in the Gauge, but include for\n        // safety\n        (, , uint256 totalPTokens) = _getTotalPTokens();\n        ICurvePool curvePool = ICurvePool(platformAddress);\n\n        uint256 pTokenTotalSupply = IERC20(assetToPToken[_asset]).totalSupply();\n        if (pTokenTotalSupply > 0) {\n            uint256 poolCoinIndex = _getPoolCoinIndex(_asset);\n            uint256 curveBalance = curvePool.balances(poolCoinIndex);\n            if (curveBalance > 0) {\n                balance = totalPTokens.mul(curveBalance).div(pTokenTotalSupply);\n            }\n        }\n    }\n\n    /**\n     * @dev Retuns bool indicating whether asset is supported by strategy\n     * @param _asset Address of the asset\n     */\n    function supportsAsset(address _asset) external view returns (bool) {\n        return assetToPToken[_asset] != address(0);\n    }\n\n    /**\n     * @dev Approve the spending of all assets by their corresponding pool tokens,\n     *      if for some reason is it necessary.\n     */\n    function safeApproveAllTokens() external {\n        // This strategy is a special case since it only supports one asset\n        for (uint256 i = 0; i < assetsMapped.length; i++) {\n            _abstractSetPToken(assetsMapped[i], assetToPToken[assetsMapped[i]]);\n        }\n    }\n\n    /**\n     * @dev Calculate the total platform token balance (i.e. 3CRV) that exist in\n     * this contract or is staked in the Gauge (or in other words, the total\n     * amount platform tokens we own).\n     * @return totalPTokens Total amount of platform tokens in native decimals\n     */\n    function _getTotalPTokens()\n        internal\n        view\n        returns (\n            uint256 contractPTokens,\n            uint256 gaugePTokens,\n            uint256 totalPTokens\n        )\n    {\n        contractPTokens = IERC20(assetToPToken[assetsMapped[0]]).balanceOf(\n            address(this)\n        );\n        ICurveGauge gauge = ICurveGauge(crvGaugeAddress);\n        gaugePTokens = gauge.balanceOf(address(this));\n        totalPTokens = contractPTokens.add(gaugePTokens);\n    }\n\n    /**\n     * @dev Call the necessary approvals for the Curve pool and gauge\n     * @param _asset Address of the asset\n     * @param _pToken Address of the corresponding platform token (i.e. 3CRV)\n     */\n    function _abstractSetPToken(address _asset, address _pToken) internal {\n        IERC20 asset = IERC20(_asset);\n        IERC20 pToken = IERC20(_pToken);\n        // 3Pool for asset (required for adding liquidity)\n        asset.safeApprove(platformAddress, 0);\n        asset.safeApprove(platformAddress, uint256(-1));\n        // 3Pool for LP token (required for removing liquidity)\n        pToken.safeApprove(platformAddress, 0);\n        pToken.safeApprove(platformAddress, uint256(-1));\n        // Gauge for LP token\n        pToken.safeApprove(crvGaugeAddress, 0);\n        pToken.safeApprove(crvGaugeAddress, uint256(-1));\n    }\n\n    /**\n     * @dev Get the index of the coin in 3pool\n     */\n    function _getPoolCoinIndex(address _asset) internal view returns (uint256) {\n        for (uint256 i = 0; i < 3; i++) {\n            if (assetsMapped[i] == _asset) return i;\n        }\n        revert(\"Invalid 3pool asset\");\n    }\n}"
    }
  ]
}