{
  "Title": "[M-02] All bridged funds will be lost for the users using the account abstraction wallet",
  "Content": "\n### Lines of code\n\n<https://github.com/code-423n4/2023-09-ondo/blob/47d34d6d4a5303af5f46e907ac2292e6a7745f6c/contracts/bridge/SourceBridge.sol#L61-L82><br>\n<https://github.com/code-423n4/2023-09-ondo/blob/47d34d6d4a5303af5f46e907ac2292e6a7745f6c/contracts/bridge/DestinationBridge.sol#L85-L114>\n\n### Impact\n\nUsers with account abstraction wallets have a different address across different chains for same account, so if someone using an account abstraction wallet bridge the asset, assets will be minted to wrong address and lost permanently.\n\n### Proof of Concept\n\nAccount abstraction wallets have been on the rise for quite a time now and have a lot of users. See the below image for the figures by safe wallet (one of the account abstraction wallets):\n\n![https://user-images.githubusercontent.com/135237830/273336415-ecc7eef9-1e00-49b4-b48b-5030d62a372b.png](https://user-images.githubusercontent.com/135237830/273336415-ecc7eef9-1e00-49b4-b48b-5030d62a372b.png)\n\nWith 4.4 million users and 5.4 billion assets, there is very high risk that safe wallet users will try to bridge the assets and loose them.\n\nNow, look at the codebase and understand how the assets will be lost.\n\nIn source bridge in `burnAndCallAxelar` we construct the payload as follow :\n\nHere, we can see the payload passes `msg.sender` as receiving an address on the other chain, assuming that the user has the same address across all the EVM chains; which is not the case if user is using the account abstraction wallet.\n\n```solidity\n    bytes memory payload = abi.encode(VERSION, msg.sender, amount, nonce++);\n```\n\nThen, it calls the following function passing the payload, which then calls the `callContract` function passing the payload to Axelar Network.\n\n```solidity\n  function _payGasAndCallCotract(\n    string calldata destinationChain,\n    string memory destContract,\n    bytes memory payload\n  ) private {\n    GAS_RECEIVER.payNativeGasForContractCall{value: msg.value}(\n      address(this),\n      destinationChain,\n      destContract,\n      payload,\n      msg.sender\n    );\n\n    // Send all information to AxelarGateway contract.\n    AXELAR_GATEWAY.callContract(destinationChain, destContract, payload);\n  }\n```\n\nThen, on the destination, any Axelar node can call the `execute()` function, passing in the payload. The tokens will be minted to an account abstraction wallet address of the source chain, but on destination, the same person will not be the owner of that address; hence, tokens are permanently lost.\n\n```solidity\n  function _execute(\n    string calldata srcChain,\n    string calldata srcAddr,\n    bytes calldata payload\n  ) internal override whenNotPaused {\n  \n    (bytes32 version, address srcSender, uint256 amt, uint256 nonce) = abi\n      .decode(payload, (bytes32, address, uint256, uint256));\n\n    if (version != VERSION) {\n      revert InvalidVersion();\n    }\n    if (chainToApprovedSender[srcChain] == bytes32(0)) {\n      revert ChainNotSupported();\n    }\n    // each chain have only one approved sender that is the source bridge contract.\n    if (chainToApprovedSender[srcChain] != keccak256(abi.encode(srcAddr))) {\n      revert SourceNotSupported();\n    }\n    if (isSpentNonce[chainToApprovedSender[srcChain]][nonce]) {\n      revert NonceSpent();\n    }\n\n    isSpentNonce[chainToApprovedSender[srcChain]][nonce] = true;\n\n    // same payload would have the same txhash\n    bytes32 txnHash = keccak256(payload);\n    txnHashToTransaction[txnHash] = Transaction(srcSender, amt);\n    _attachThreshold(amt, txnHash, srcChain);\n    _approve(txnHash);\n    _mintIfThresholdMet(txnHash);\n    emit MessageReceived(srcChain, srcSender, amt, nonce);\n  }\n```\n\n### Recommended Mitigation Steps\n\nGive the user the option to pass in the address the tokens should be minted to on the destination bridge. Pass in the warning for account abstraction wallet holders to not to pass the same wallet. Some wallets may follow a deterministic deployment approach to have same address, but as safe explains, that grants nothing, as each chain has its own different state and opcode differences; so even a deterministic approach may generate different addresses.\n\n### Assessed type\n\nInvalid Validation\n\n**[tom2o17 (Ondo) acknowledged, but disagreed with severity](https://github.com/code-423n4/2023-09-ondo-findings/issues/406#issuecomment-1717830062)**\n\n**[kirk-baird (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-09-ondo-findings/issues/406#issuecomment-1722402316):**\n > Downgrading this to medium severity as users would know ahead of time that the receiving address is the same as the sending address.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-09-ondo",
  "Code": [
    {
      "filename": "contracts/bridge/SourceBridge.sol",
      "content": "pragma solidity 0.8.16;\n\nimport \"contracts/interfaces/IAxelarGateway.sol\";\nimport \"contracts/interfaces/IAxelarGasService.sol\";\nimport \"contracts/interfaces/IMulticall.sol\";\nimport \"contracts/interfaces/IRWALike.sol\";\nimport {AddressToString} from \"contracts/external/axelar/StringAddressUtils.sol\";\nimport \"contracts/external/openzeppelin/contracts/access/Ownable.sol\";\nimport \"contracts/external/openzeppelin/contracts/security/Pausable.sol\";\n\ncontract SourceBridge is Ownable, Pausable, IMulticall {\n  /// @notice Mapping from destination chain to bridge address on that chain\n  /// @dev Axelar uses the string representation of addresses, hence we store\n  ///      the address as a string\n  mapping(string => string) public destChainToContractAddr;\n\n  /// @notice Token contract bridged by this contract\n  IRWALike public immutable TOKEN;\n\n  /// @notice Pointer  to AxelarGateway contract\n  IAxelarGateway public immutable AXELAR_GATEWAY;\n\n  /// @notice Pointer to AxelarGasService contract\n  IAxelarGasService public immutable GAS_RECEIVER;\n\n  /// @notice Versioning for payload\n  bytes32 public constant VERSION = \"1.0\";\n\n  /// @notice Monotonically increasing nonce for each transaction\n  uint256 public nonce;\n\n  /**\n   * @notice Constructor\n   *\n   * @param _token The address of the token bridged\n   * @param _axelarGateway The address of the AxelarGateway contract\n   * @param _gasService The address of the AxelarGasService contract\n   * @param owner The owner of the contract\n   */\n  constructor(\n    address _token,\n    address _axelarGateway,\n    address _gasService,\n    address owner\n  ) {\n    TOKEN = IRWALike(_token);\n    AXELAR_GATEWAY = IAxelarGateway(_axelarGateway);\n    GAS_RECEIVER = IAxelarGasService(_gasService);\n    _transferOwnership(owner);\n  }\n\n  /**\n   * @notice Burns tokens on the source Chain and calls AxelarGateway contract\n   *         to mint tokens on the destination chain\n   *\n   * @param amount The amount of tokens to burn\n   * @param destinationChain The destination chain to mint tokens on\n   *\n   * @dev The amount of tokens to mint is the same as the amount burned\n   */\n  function burnAndCallAxelar(\n    uint256 amount,\n    string calldata destinationChain\n  ) external payable whenNotPaused {\n    // check destinationChain is correct\n    string memory destContract = destChainToContractAddr[destinationChain];\n\n    if (bytes(destContract).length == 0) {\n      revert DestinationNotSupported();\n    }\n\n    if (msg.value == 0) {\n      revert GasFeeTooLow();\n    }\n\n    // burn amount\n    TOKEN.burnFrom(msg.sender, amount);\n\n    bytes memory payload = abi.encode(VERSION, msg.sender, amount, nonce++);\n\n    _payGasAndCallContract(destinationChain, destContract, payload);\n  }\n\n  /**\n   * @notice Helper function that pays gas and calls the AxelarGateway contract\n   *\n   * @param destinationChain The destination chain to mint tokens on\n   * @param destContract The contract address on the destination chain\n   * @param payload The payload to send to the AxelarGateway contract\n   */\n  function _payGasAndCallContract(\n    string calldata destinationChain,\n    string memory destContract,\n    bytes memory payload\n  ) private {\n    GAS_RECEIVER.payNativeGasForContractCall{value: msg.value}(\n      address(this),\n      destinationChain,\n      destContract,\n      payload,\n      msg.sender\n    );\n\n    // Send all information to AxelarGateway contract.\n    AXELAR_GATEWAY.callContract(destinationChain, destContract, payload);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                          Admin Functions\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Sets the destination chain to contract address mapping\n   *\n   * @param destinationChain The destination chain\n   * @param contractAddress The contract address on the destination chain\n   *\n   * @dev Chain name must come from list of supported chains\n   *      at https://docs.axelar.dev/dev/reference/mainnet-chain-names\n   */\n  function setDestinationChainContractAddress(\n    string memory destinationChain,\n    address contractAddress\n  ) external onlyOwner {\n    destChainToContractAddr[destinationChain] = AddressToString.toString(\n      contractAddress\n    );\n    emit DestinationChainContractAddressSet(destinationChain, contractAddress);\n  }\n\n  /**\n   * @notice Admin function to pause the contract\n   *\n   * @dev Only used for bridge functions\n   */\n  function pause() external onlyOwner {\n    _pause();\n  }\n\n  /**\n   * @notice Admin function to unpause the contract\n   *\n   * @dev Only used for bridge functions\n   */\n  function unpause() external onlyOwner {\n    _unpause();\n  }\n\n  /**\n   * @notice Allows for arbitrary batched calls\n   *\n   * @dev All external calls made through this function will\n   *      msg.sender == contract address\n   *\n   * @param exCallData Struct consisting of\n   *       1) target - contract to call\n   *       2) data - data to call target with\n   *       3) value - eth value to call target with\n   */\n  function multiexcall(\n    ExCallData[] calldata exCallData\n  ) external payable override onlyOwner returns (bytes[] memory results) {\n    results = new bytes[](exCallData.length);\n    for (uint256 i = 0; i < exCallData.length; ++i) {\n      (bool success, bytes memory ret) = address(exCallData[i].target).call{\n        value: exCallData[i].value\n      }(exCallData[i].data);\n      require(success, \"Call Failed\");\n      results[i] = ret;\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                           Events & Errors\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Even emitted when the destination chain to contract address mapping is set\n   *\n   * @param destinationChain The destination chain\n   * @param contractAddress The contract address on the destination chain\n   */\n  event DestinationChainContractAddressSet(\n    string indexed destinationChain,\n    address contractAddress\n  );\n\n  // Errors\n  error DestinationNotSupported();\n  error GasFeeTooLow();\n}"
    },
    {
      "filename": "contracts/bridge/DestinationBridge.sol",
      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\nimport \"contracts/interfaces/IAxelarGateway.sol\";\nimport \"contracts/interfaces/IAxelarGasService.sol\";\nimport \"contracts/external/axelar/AxelarExecutable.sol\";\nimport \"contracts/interfaces/IRWALike.sol\";\nimport \"contracts/interfaces/IAllowlist.sol\";\nimport \"contracts/external/openzeppelin/contracts/access/Ownable.sol\";\nimport \"contracts/external/openzeppelin/contracts/security/Pausable.sol\";\nimport \"contracts/bridge/MintRateLimiter.sol\";\n\ncontract DestinationBridge is\n  AxelarExecutable,\n  MintTimeBasedRateLimiter,\n  Ownable,\n  Pausable\n{\n  /// @notice Token contract bridged by this contract\n  IRWALike public immutable TOKEN;\n\n  /// @notice Pointer to AxelarGateway contract\n  IAxelarGateway public immutable AXELAR_GATEWAY;\n\n  /// @notice Pointer to USDY allowlist\n  IAllowlist public immutable ALLOWLIST;\n\n  // Mapping used to track approvers, approved msg src's and spent nonces\n  mapping(address => bool) public approvers;\n  mapping(string => bytes32) public chainToApprovedSender;\n  mapping(bytes32 => mapping(uint256 => bool)) public isSpentNonce;\n\n  /// @notice Versioning for payload, must match SourceBridge version\n  bytes32 public constant VERSION = \"1.0\";\n\n  /// @notice Mappings used to track transaction and thresholds\n  mapping(bytes32 => TxnThreshold) public txnToThresholdSet;\n  mapping(string => Threshold[]) public chainToThresholds;\n  mapping(bytes32 => Transaction) public txnHashToTransaction;\n\n  constructor(\n    address _token,\n    address _axelarGateway,\n    address _allowlist,\n    address _ondoApprover,\n    address _owner,\n    uint256 _mintLimit,\n    uint256 _mintDuration\n  )\n    AxelarExecutable(_axelarGateway)\n    MintTimeBasedRateLimiter(_mintDuration, _mintLimit)\n  {\n    TOKEN = IRWALike(_token);\n    AXELAR_GATEWAY = IAxelarGateway(_axelarGateway);\n    ALLOWLIST = IAllowlist(_allowlist);\n    approvers[_ondoApprover] = true;\n    _transferOwnership(_owner);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                         Axelar Functions\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Internal overriden function that is executed when contract is called by Axelar Gateway\n   *\n   * @param srcChain The string of the source chain eg: arbitrum\n   * @param srcAddr  The string of the address of the source contract\n   * @param payload  The payload to pass cross chain\n   */\n  function _execute(\n    string calldata srcChain,\n    string calldata srcAddr,\n    bytes calldata payload\n  ) internal override whenNotPaused {\n    (bytes32 version, address srcSender, uint256 amt, uint256 nonce) = abi\n      .decode(payload, (bytes32, address, uint256, uint256));\n\n    if (version != VERSION) {\n      revert InvalidVersion();\n    }\n    if (chainToApprovedSender[srcChain] == bytes32(0)) {\n      revert ChainNotSupported();\n    }\n    if (chainToApprovedSender[srcChain] != keccak256(abi.encode(srcAddr))) {\n      revert SourceNotSupported();\n    }\n    if (isSpentNonce[chainToApprovedSender[srcChain]][nonce]) {\n      revert NonceSpent();\n    }\n\n    isSpentNonce[chainToApprovedSender[srcChain]][nonce] = true;\n\n    bytes32 txnHash = keccak256(payload);\n    txnHashToTransaction[txnHash] = Transaction(srcSender, amt);\n    _attachThreshold(amt, txnHash, srcChain);\n    _approve(txnHash);\n    _mintIfThresholdMet(txnHash);\n    emit MessageReceived(srcChain, srcSender, amt, nonce);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                        Internal Functions\n  //////////////////////////////////////////////////////////////*/\n  /**\n   * @notice Internal function used to attach a specific threshold to a given\n   *         `txnHash`.\n   *\n   * @param amount   The amount of the token being bridged\n   * @param txnHash  The transaction hash to associate the threshold with\n   * @param srcChain The chain corresponding to the chain that the token\n   *                 being bridged originated from.\n   */\n  function _attachThreshold(\n    uint256 amount,\n    bytes32 txnHash,\n    string memory srcChain\n  ) internal {\n    Threshold[] memory thresholds = chainToThresholds[srcChain];\n    for (uint256 i = 0; i < thresholds.length; ++i) {\n      Threshold memory t = thresholds[i];\n      if (amount <= t.amount) {\n        txnToThresholdSet[txnHash] = TxnThreshold(\n          t.numberOfApprovalsNeeded,\n          new address[](0)\n        );\n        break;\n      }\n    }\n    if (txnToThresholdSet[txnHash].numberOfApprovalsNeeded == 0) {\n      revert NoThresholdMatch();\n    }\n  }\n\n  /**\n   * @notice Internal function used to approve and conditionally mint for a\n   *         given txn. Approval is conditional on this approver having not\n   *         previously approved the txn\n   *\n   * @param txnHash The txnHash to approve and conditionally mint to\n   */\n  function _approve(bytes32 txnHash) internal {\n    // Check that the approver has not already approved\n    TxnThreshold storage t = txnToThresholdSet[txnHash];\n    if (t.approvers.length > 0) {\n      for (uint256 i = 0; i < t.approvers.length; ++i) {\n        if (t.approvers[i] == msg.sender) {\n          revert AlreadyApproved();\n        }\n      }\n    }\n    t.approvers.push(msg.sender);\n  }\n\n  /**\n   * @notice Internal function used to check if the approval threshold has been\n   *         met for a given transaction.\n   *\n   * @param txnHash The txnHash to check\n   *\n   * @dev If an approver has been removed, any previous approvals are still valid\n   */\n  function _checkThresholdMet(bytes32 txnHash) internal view returns (bool) {\n    TxnThreshold memory t = txnToThresholdSet[txnHash];\n    if (t.numberOfApprovalsNeeded <= t.approvers.length) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                        Protected Functions\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Protected Function used to approve messages passed to the\n   *         Receiver contract. This function is able to be called by any\n   *         approver that is added and associated with Ondo.\n   *\n   * @param txnHash The keccak256 hash of the payload\n   */\n  function approve(bytes32 txnHash) external {\n    if (!approvers[msg.sender]) {\n      revert NotApprover();\n    }\n    _approve(txnHash);\n    _mintIfThresholdMet(txnHash);\n  }\n\n  /**\n   * @notice Admin function to add an ondo Signer or Axelar Relayer\n   *\n   * @param approver  The address we would like to add\n   */\n  function addApprover(address approver) external onlyOwner {\n    approvers[approver] = true;\n    emit ApproverAdded(approver);\n  }\n\n  /**\n   * @notice Admin function to remove an approver\n   *\n   * @param approver The address of the approver that we would like to remove\n   */\n  function removeApprover(address approver) external onlyOwner {\n    delete approvers[approver];\n    emit ApproverRemoved(approver);\n  }\n\n  /**\n   * @notice Admin function that will allow bridge calls originating from a given address\n   *         on a given chain.\n   * @notice This will initalize a nested mapping in which spent nonces from this `srcAddress`\n   *         are logged and prevented from being reused\n   *\n   * @param srcChain            The chain to support\n   * @param srcContractAddress  The address of the Ondo Bridge on this chain\n   */\n  function addChainSupport(\n    string calldata srcChain,\n    string calldata srcContractAddress\n  ) external onlyOwner {\n    chainToApprovedSender[srcChain] = keccak256(abi.encode(srcContractAddress));\n    emit ChainIdSupported(srcChain, srcContractAddress);\n  }\n\n  /**\n   * @notice Admin function used to clear and set thresholds corresponding to a chain\n   *\n   * @param srcChain       The chain to set the threshold for\n   * @param amounts        The ordered array of values corresponding to\n   *                       the amount for a given threshold\n   * @param numOfApprovers The ordered array of the number of approvals needed\n   *                       for a given threshold\n   *\n   * @dev This function will remove all previously set thresholds for a given chain\n   *      and will thresholds corresponding to the params of this function. Passing\n   *      in empty arrays will remove all thresholds for a given chain\n   */\n  function setThresholds(\n    string calldata srcChain,\n    uint256[] calldata amounts,\n    uint256[] calldata numOfApprovers\n  ) external onlyOwner {\n    if (amounts.length != numOfApprovers.length) {\n      revert ArrayLengthMismatch();\n    }\n    delete chainToThresholds[srcChain];\n    for (uint256 i = 0; i < amounts.length; ++i) {\n      if (i == 0) {\n        chainToThresholds[srcChain].push(\n          Threshold(amounts[i], numOfApprovers[i])\n        );\n      } else {\n        if (chainToThresholds[srcChain][i - 1].amount > amounts[i]) {\n          revert ThresholdsNotInAscendingOrder();\n        }\n        chainToThresholds[srcChain].push(\n          Threshold(amounts[i], numOfApprovers[i])\n        );\n      }\n    }\n    emit ThresholdSet(srcChain, amounts, numOfApprovers);\n  }\n\n  /**\n   * @notice Admin function used to set the mint limit\n   *\n   * @param mintLimit The new mint limit\n   */\n  function setMintLimit(uint256 mintLimit) external onlyOwner {\n    _setMintLimit(mintLimit);\n  }\n\n  /**\n   * @notice Admin function used to set the mint duration\n   *\n   * @param mintDuration The new mint duration\n   */\n  function setMintLimitDuration(uint256 mintDuration) external onlyOwner {\n    _setMintLimitDuration(mintDuration);\n  }\n\n  /**\n   * @notice Admin function used to pause the contract\n   *\n   * @dev Only used for bridge functions\n   */\n  function pause() external onlyOwner {\n    _pause();\n  }\n\n  /**\n   * @notice Admin function used to unpause the contract\n   *\n   * @dev Only used for bridge functions\n   */\n  function unpause() external onlyOwner {\n    _unpause();\n  }\n\n  /**\n   * @notice Admin function used to rescue ERC20 Tokens sent to the contract\n   *\n   * @param _token The address of the token to rescue\n   */\n  function rescueTokens(address _token) external onlyOwner {\n    uint256 balance = IRWALike(_token).balanceOf(address(this));\n    IRWALike(_token).transfer(owner(), balance);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                        Public Functions\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice internal function to mint a transaction if it has passed the threshold\n   *         for the number of approvers\n   *\n   * @param txnHash The hash of the transaction we wish to mint\n   */\n  function _mintIfThresholdMet(bytes32 txnHash) internal {\n    bool thresholdMet = _checkThresholdMet(txnHash);\n    Transaction memory txn = txnHashToTransaction[txnHash];\n    if (thresholdMet) {\n      _checkAndUpdateInstantMintLimit(txn.amount);\n      if (!ALLOWLIST.isAllowed(txn.sender)) {\n        ALLOWLIST.setAccountStatus(\n          txn.sender,\n          ALLOWLIST.getValidTermIndexes()[0],\n          true\n        );\n      }\n      TOKEN.mint(txn.sender, txn.amount);\n      delete txnHashToTransaction[txnHash];\n      emit BridgeCompleted(txn.sender, txn.amount);\n    }\n  }\n\n  /**\n   * @notice External view function used to get the number of approvers for a\n   *         given txnHash\n   *\n   * @param txnHash The hash to get the number of approvers for\n   */\n  function getNumApproved(bytes32 txnHash) external view returns (uint256) {\n    return txnToThresholdSet[txnHash].approvers.length;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                      Structs, Events, Errors\n  //////////////////////////////////////////////////////////////*/\n\n  struct Threshold {\n    uint256 amount;\n    uint256 numberOfApprovalsNeeded;\n  }\n\n  struct TxnThreshold {\n    uint256 numberOfApprovalsNeeded;\n    address[] approvers;\n  }\n\n  struct Transaction {\n    address sender;\n    uint256 amount;\n  }\n\n  /**\n   * @notice event emitted when an address is removed as an approver\n   *\n   * @param approver The address being removed\n   */\n  event ApproverRemoved(address approver);\n\n  /**\n   * @notice event emitted when an address is added as an approver\n   *\n   * @param approver  The address to add\n   */\n  event ApproverAdded(address approver);\n\n  /**\n   * @notice event emitted when a new contract is whitelisted as an approved\n   *         message passer.\n   *\n   * @param srcChain        The chain for the approved address\n   * @param approvedSource  The address corresponding to the source bridge contract\n   */\n  event ChainIdSupported(string srcChain, string approvedSource);\n\n  /**\n   * @notice event emitted when a threshold has been set\n   *\n   * @param chain           The chain for which the threshold was set\n   * @param amounts         The amount of tokens to reach this threshold\n   * @param numOfApprovers  The number of approvals needed\n   */\n  event ThresholdSet(string chain, uint256[] amounts, uint256[] numOfApprovers);\n\n  /**\n   * @notice event emitted when the user has been minted their tokens on the dst chain\n   *\n   * @param user    The recipient address of the newly minted tokens\n   * @param amount  The amount of tokens that have been minted\n   */\n  event BridgeCompleted(address user, uint256 amount);\n\n  /**\n   * @notice event emitted when this bridge contract receives a cross chain message\n   *\n   * @param srcChain  The chain from which the message is originating\n   * @param srcSender The address of the msg.sender on the source chain\n   * @param amt       The amount of tokens being bridged\n   * @param nonce     The nonce corresponding to the contract which originated the msg\n   */\n  event MessageReceived(\n    string srcChain,\n    address srcSender,\n    uint256 amt,\n    uint256 nonce\n  );\n\n  error NotApprover();\n  error NoThresholdMatch();\n  error ThresholdsNotInAscendingOrder();\n\n  error ChainNotSupported();\n  error SourceNotSupported();\n  error NonceSpent();\n  error AlreadyApproved();\n  error InvalidVersion();\n  error ArrayLengthMismatch();\n}"
    }
  ]
}