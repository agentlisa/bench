{
  "Title": "Possible Function Selector Clashing",
  "Content": "Clashing can happen among functions with different names. Every function that is part of a contractâ€™s public ABI is identified, at the bytecode level, by a 4-byte identifier. This identifier depends on the function's signature, but since it is only 4 bytes, there is a possibility that two different functions with different function signatures may end up having the same identifier. The Solidity compiler tracks when this happens within the same contract, but not when the collision happens across different ones, such as between a proxy and its logic contract.\n\n\nIn this protocol, the [`Unitroller`](https://github.com/VenusProtocol/venus-protocol/blob/94bc2e414e33ebf6c05d35c1605dcbd48fa932f5/contracts/Comptroller/Unitroller.sol) contract [delegatecalls](https://github.com/VenusProtocol/venus-protocol/blob/94bc2e414e33ebf6c05d35c1605dcbd48fa932f5/contracts/Comptroller/Unitroller.sol#L135) the [`Diamond`](https://github.com/VenusProtocol/venus-protocol/blob/94bc2e414e33ebf6c05d35c1605dcbd48fa932f5/contracts/Comptroller/Diamond/Diamond.sol) contract which [delegatecalls](https://github.com/VenusProtocol/venus-protocol/blob/94bc2e414e33ebf6c05d35c1605dcbd48fa932f5/contracts/Comptroller/Diamond/Diamond.sol#L223) the facets. The `Unitroller` contract contains 8 `public`/`external` functions and the `Diamond` contract contains 46 `public`/`external` functions (this can increase in future upgrades).\n\n\nThe presence of these functions creates the possibility of a [function selector clash](https://medium.com/nomic-foundation-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357). This can happen in the following scenarios:\n\n\n* Functions in `Unitroller` and hardcoded functions in `Diamond` with the same function selector\n* Functions in `Unitroller` and a facet with the same function selector\n* Hardcoded functions in `Diamond` and a facet with the same function selector\n\n\nNote that functions between different facets cannot clash as the [`diamondCut` function](https://github.com/VenusProtocol/venus-protocol/blob/94bc2e414e33ebf6c05d35c1605dcbd48fa932f5/contracts/Comptroller/Diamond/Diamond.sol#L24C14-L27) prevents adding new functions whose signature is already registered in the `Diamond`.\n\n\nConsider checking that no function selector collision is present when adding new functions to the `Diamond` (using `diamondCut`) or upgrading the `Diamond`'s implementation. Moving the hardcoded functions in `Diamond.sol` to a facet will also reduce the chances of a collision going unnoticed.\n\n\n***Update:** Acknowledged, not resolved. The Venus team stated:*\n\n\n\n> *We have just included the `diamondCut` functionality in the `Diamond.sol` file. For now, we will just acknowledge the issue, and no actions are needed from us.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/Comptroller/Diamond/Diamond.sol",
      "content": "pragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport { IDiamondCut } from \"./interfaces/IDiamondCut.sol\";\nimport \"../ComptrollerStorage.sol\";\nimport \"../Unitroller.sol\";\n\ncontract Diamond is ComptrollerV12Storage {\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut);\n\n    /**\n     * @notice Call _acceptImplementation to accept the diamond proxy as new implementaion.\n     * @param unitroller Address of the unitroller.\n     */\n    function _become(Unitroller unitroller) public {\n        require(msg.sender == unitroller.admin(), \"only unitroller admin can\");\n        require(unitroller._acceptImplementation() == 0, \"not authorized\");\n    }\n\n    /**\n     * @notice To add function selectors to the facets' mapping.\n     * @param _diamondCut IDiamondCut contains facets address, action and function selectors.\n     */\n    function diamondCut(IDiamondCut.FacetCut[] memory _diamondCut) public {\n        require(msg.sender == admin, \"only unitroller admin can\");\n        libDiamondCut(_diamondCut);\n    }\n\n    /**\n     * @notice Get all function selectors mapped to the facet address\n     * @param _facet Address of the facet\n     * @return _facetFunctionSelectors Array of function selectors\n     */\n    function getFacetFunctionSelectors(address _facet) external view returns (bytes4[] memory _facetFunctionSelectors) {\n        _facetFunctionSelectors = facetFunctionSelectors[_facet].functionSelectors;\n    }\n\n    /**\n     * @notice Get facet position in the facetFunctionSelectors through facet address\n     * @param _facet Address of the facet\n     * @return Position of the facet\n     */\n    function getFacetPosition(address _facet) external view returns (uint256) {\n        return facetFunctionSelectors[_facet].facetAddressPosition;\n    }\n\n    /**\n     * @notice Get all facet addresses\n     * @return facetAddresses_ Array of facet addresses\n     */\n    function getAllFacetAddresses() external view returns (address[] memory facetAddresses_) {\n        facetAddresses_ = facetAddresses;\n    }\n\n    /**\n     * @notice Get facet address and position through function selector\n     * @param _functionSelector function selector\n     * @return FacetAddressAndPosition facet address and position\n     */\n    function getFacetAddressAndPosition(\n        bytes4 _functionSelector\n    ) external view returns (ComptrollerV12Storage.FacetAddressAndPosition memory) {\n        return selectorToFacetAndPosition[_functionSelector];\n    }\n\n    /**\n     * @notice To add function selectors to the facets' mapping.\n     * @param _diamondCut IDiamondCut contains facets address, action and function selectors.\n     */\n    function libDiamondCut(IDiamondCut.FacetCut[] memory _diamondCut) internal {\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n            if (action == IDiamondCut.FacetCutAction.Add) {\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else {\n                revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n            }\n        }\n        emit DiamondCut(_diamondCut);\n    }\n\n    /**\n     * @notice Add function selectors to the facet's address mapping.\n     * @param _facetAddress Address of the facet.\n     * @param _functionSelectors Array of function selectors need to add in the mapping.\n     */\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(_facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress == address(0), \"LibDiamondCut: Can't add function that already exists\");\n            addFunction(selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    /**\n     * @notice Replace facet's address mapping for function selectors i.e selectors already associate to any other existing facet.\n     * @param _facetAddress Address of the facet.\n     * @param _functionSelectors Array of function selectors need to replace in the mapping.\n     */\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(_facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress != _facetAddress, \"LibDiamondCut: Can't replace function with same function\");\n            removeFunction(oldFacetAddress, selector);\n            addFunction(selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    /**\n     * @notice Remove function selectors to the facet's address mapping.\n     * @param _facetAddress Address of the facet.\n     * @param _functionSelectors Array of function selectors need to remove in the mapping.\n     */\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        // if function does not exist then do nothing and revert\n        require(_facetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = selectorToFacetAndPosition[selector].facetAddress;\n            removeFunction(oldFacetAddress, selector);\n        }\n    }\n\n    /**\n     * @notice Add new facet to the proxy.\n     * @param _facetAddress Address of the facet.\n     */\n    function addFacet(address _facetAddress) internal {\n        enforceHasContractCode(_facetAddress, \"Diamond: New facet has no code\");\n        facetFunctionSelectors[_facetAddress].facetAddressPosition = facetAddresses.length;\n        facetAddresses.push(_facetAddress);\n    }\n\n    /**\n     * @notice Add function selector to the facet's address mapping.\n     * @param _selector funciton selector need to be added.\n     * @param _selectorPosition funciton selector position.\n     * @param _facetAddress Address of the facet.\n     */\n    function addFunction(bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\n        selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\n        facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\n        selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\n    }\n\n    /**\n     * @notice Remove function selector to the facet's address mapping.\n     * @param _facetAddress Address of the facet.\n     * @param _selector function selectors need to remove in the mapping.\n     */\n    function removeFunction(address _facetAddress, bytes4 _selector) internal {\n        require(_facetAddress != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\n\n        // replace selector with last selector, then delete last selector\n        uint256 selectorPosition = selectorToFacetAndPosition[_selector].functionSelectorPosition;\n        uint256 lastSelectorPosition = facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\n        // if not the same then replace _selector with lastSelector\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\n            facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\n            selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\n        }\n        // delete the last selector\n        facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n        delete selectorToFacetAndPosition[_selector];\n\n        // if no more selectors for facet address then delete the facet address\n        if (lastSelectorPosition == 0) {\n            // replace facet address with last facet address and delete last facet address\n            uint256 lastFacetAddressPosition = facetAddresses.length - 1;\n            uint256 facetAddressPosition = facetFunctionSelectors[_facetAddress].facetAddressPosition;\n            if (facetAddressPosition != lastFacetAddressPosition) {\n                address lastFacetAddress = facetAddresses[lastFacetAddressPosition];\n                facetAddresses[facetAddressPosition] = lastFacetAddress;\n                facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\n            }\n            facetAddresses.pop();\n            delete facetFunctionSelectors[_facetAddress];\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n\n    // Find facet for function that is called and execute the\n    // function if a facet is found and return any value.\n    function() external payable {\n        address facet = selectorToFacetAndPosition[msg.sig].facetAddress;\n        require(facet != address(0), \"Diamond: Function does not exist\");\n        // Execute public function from facet using delegatecall and return any value.\n        assembly {\n            // copy function selector and any arguments\n            calldatacopy(0, 0, calldatasize())\n            // execute function call using the facet\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n            // get any return value\n            returndatacopy(0, 0, returndatasize())\n            // return any return value or error back to the caller\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n}"
    }
  ]
}