{
  "Title": "M-20: timeToEpochEnd calculates backwards, breaking protocol math",
  "Content": "# Issue M-20: timeToEpochEnd calculates backwards, breaking protocol math \n\nSource: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/50 \n\n## Found by \nobront, 0xNazgul, 0xRajeev, hansfriese\n\n## Summary\n\nWhen a lien is liquidated, it calls `timeToEpochEnd()` to determine if a liquidation accountant should be deployed and we should adjust the protocol math to expect payment in a future epoch. Because of an error in the implementation, all liquidations that will pay out in the current epoch are set up as future epoch liquidations.\n\n## Vulnerability Detail\n\nThe `liquidate()` function performs the following check to determine if it should set up the liquidation to be paid out in a future epoch:\n\n```solidity\nif (PublicVault(owner).timeToEpochEnd() <= COLLATERAL_TOKEN.auctionWindow())\n```\n\nThis check expects that `timeToEpochEnd()` will return the time until the epoch is over. However, the implementation gets this backwards:\n\n```solidity\nfunction timeToEpochEnd() public view returns (uint256) {\n  uint256 epochEnd = START() + ((currentEpoch + 1) * EPOCH_LENGTH());\n\n  if (epochEnd >= block.timestamp) {\n    return uint256(0);\n  }\n\n  return block.timestamp - epochEnd;\n}\n```\nIf `epochEnd >= block.timestamp`, that means that there IS remaining time in the epoch, and it should perform the calculation to return `epochEnd - block.timestamp`. In the opposite case, where `epochEnd <= block.timestamp`, it should return zero.\n\nThe result is that the function returns 0 for any epoch that isn't over. Since `0 < COLLATERAL_TOKEN.auctionWindow())`, all liquidated liens will trigger a liquidation accountant and the rest of the accounting for future epoch withdrawals.\n\n## Impact\n\nAccounting for a future epoch withdrawal causes a number of inconsistencies in the protocol's math, the impact of which vary depending on the situation. As a few examples:\n- It calls `decreaseEpochLienCount()`. This has the effect of artificially lowering the number of liens in the epoch, which will cause the final liens paid off in the epoch to revert (and will let us process the epoch earlier than intended).\n- It sets the payee of the lien to the liquidation accountant, which will pay out according to the withdrawal ratio (whereas all funds should be staying in the vault).\n- It calls `increaseLiquidationsExpectedAtBoundary()`, which can throw off the math when processing the epoch.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/src/PublicVault.sol#L562-L570\n\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/src/AstariaRouter.sol#L388-L415\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nFix the `timeToEpochEnd()` function so it calculates the remaining time properly:\n\n```solidity\nfunction timeToEpochEnd() public view returns (uint256) {\n  uint256 epochEnd = START() + ((currentEpoch + 1) * EPOCH_LENGTH());\n\n  if (epochEnd <= block.timestamp) {\n    return uint256(0);\n  }\n\n  return epochEnd - block.timestamp; //\n}\n```\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/8",
  "Code": [
    {
      "filename": "src/PublicVault.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\n/**\n *       __  ___       __\n *  /\\  /__'  |   /\\  |__) |  /\\\n * /~~\\ .__/  |  /~~\\ |  \\ | /~~\\\n *\n * Copyright (c) Astaria Labs, Inc\n */\n\npragma solidity ^0.8.17;\n\nimport {Auth, Authority} from \"solmate/auth/Auth.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ERC4626} from \"solmate/mixins/ERC4626.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\n\nimport {IERC721, IERC165} from \"gpl/interfaces/IERC721.sol\";\nimport {\n  IVault,\n  ERC4626Cloned,\n  ITokenBase,\n  ERC4626Base,\n  AstariaVaultBase\n} from \"gpl/ERC4626-Cloned.sol\";\n\nimport {\n  ClonesWithImmutableArgs\n} from \"clones-with-immutable-args/ClonesWithImmutableArgs.sol\";\n\nimport {IAstariaRouter} from \"./interfaces/IAstariaRouter.sol\";\nimport {ILienBase} from \"./interfaces/ILienToken.sol\";\nimport {ILienToken} from \"./interfaces/ILienToken.sol\";\n\nimport {LienToken} from \"./LienToken.sol\";\nimport {LiquidationAccountant} from \"./LiquidationAccountant.sol\";\nimport {VaultImplementation} from \"./VaultImplementation.sol\";\nimport {WithdrawProxy} from \"./WithdrawProxy.sol\";\n\nimport {Math} from \"./utils/Math.sol\";\nimport {Pausable} from \"./utils/Pausable.sol\";\n\ninterface IPublicVault is IERC165 {\n  function beforePayment(uint256 escrowId, uint256 amount) external;\n\n  function decreaseEpochLienCount(uint256 lienId) external;\n\n  function getLienEpoch(uint256 end) external view returns (uint256);\n\n  function afterPayment(uint256 lienId) external;\n}\n\n/**\n * @title Vault\n * @author androolloyd\n */\ncontract Vault is AstariaVaultBase, VaultImplementation, IVault {\n  using SafeTransferLib for ERC20;\n\n  function name() public view override returns (string memory) {\n    return string(abi.encodePacked(\"AST-Vault-\", ERC20(underlying()).symbol()));\n  }\n\n  function symbol() public view override returns (string memory) {\n    return\n      string(\n        abi.encodePacked(\"AST-V\", owner(), \"-\", ERC20(underlying()).symbol())\n      );\n  }\n\n  function _handleStrategistInterestReward(uint256 lienId, uint256 shares)\n    internal\n    virtual\n    override\n  {}\n\n  function deposit(uint256 amount, address)\n    public\n    virtual\n    override\n    returns (uint256)\n  {\n    require(msg.sender == owner(), \"only the appraiser can fund this vault\");\n    ERC20(underlying()).safeTransferFrom(\n      address(msg.sender),\n      address(this),\n      amount\n    );\n    return amount;\n  }\n\n  function withdraw(uint256 amount) external {\n    require(msg.sender == owner(), \"only the appraiser can exit this vault\");\n    ERC20(underlying()).safeTransferFrom(\n      address(this),\n      address(msg.sender),\n      amount\n    );\n  }\n}\n\n/*\n * @title PublicVault\n * @author androolloyd\n * @notice\n */\ncontract PublicVault is Vault, IPublicVault, ERC4626Cloned {\n  using FixedPointMathLib for uint256;\n  using SafeTransferLib for ERC20;\n\n  // epoch seconds when yIntercept was calculated last\n  uint256 public last;\n  // sum of all LienToken amounts\n  uint256 public yIntercept;\n  // sum of all slopes of each LienToken\n  uint256 public slope;\n\n  // block.timestamp of first epoch\n  uint256 public withdrawReserve = 0;\n  uint256 liquidationWithdrawRatio = 0;\n  uint256 strategistUnclaimedShares = 0;\n  uint64 public currentEpoch = 0;\n\n  //mapping of epoch to number of open liens\n  mapping(uint256 => uint256) public liensOpenForEpoch;\n  // WithdrawProxies and LiquidationAccountants for each epoch.\n  // The first possible WithdrawProxy and LiquidationAccountant starts at index 0, i.e. an LP that marks a withdraw in epoch 0 to collect by the end of epoch *1* would use the 0th WithdrawProxy.\n  mapping(uint64 => address) public withdrawProxies;\n  mapping(uint64 => address) public liquidationAccountants;\n  mapping(uint64 => uint256) public liquidationsExpectedAtBoundary;\n\n  event YInterceptChanged(uint256 newYintercept);\n  event WithdrawReserveTransferred(uint256 amount);\n\n  function underlying()\n    public\n    view\n    virtual\n    override(ERC4626Base, AstariaVaultBase)\n    returns (address)\n  {\n    return super.underlying();\n  }\n\n  /**\n   * @notice Signal a withdrawal of funds (redeeming for underlying asset) in the next epoch.\n   * @param shares The number of VaultToken shares to redeem.\n   * @param receiver The receiver of the WithdrawTokens (and eventual underlying asset)\n   * @param owner The owner of the VaultTokens.\n   * @return assets The amount of the underlying asset redeemed.\n   */\n  function redeem(\n    uint256 shares,\n    address receiver,\n    address owner\n  ) public virtual override returns (uint256 assets) {\n    assets = redeemFutureEpoch(shares, receiver, owner, currentEpoch);\n  }\n\n  function withdraw(\n    uint256 assets,\n    address receiver,\n    address owner\n  ) public virtual override returns (uint256 shares) {\n    shares = previewWithdraw(assets);\n    redeemFutureEpoch(shares, receiver, owner, currentEpoch);\n  }\n\n  /**\n   * @notice Signal a withdrawal of funds (redeeming for underlying asset) in an arbitrary future epoch.\n   * @param shares The number of VaultToken shares to redeem.\n   * @param receiver The receiver of the WithdrawTokens (and eventual underlying asset)\n   * @param owner The owner of the VaultTokens.\n   * @param epoch The epoch to withdraw for.\n   * @return assets The amount of the underlying asset redeemed.\n   */\n  function redeemFutureEpoch(\n    uint256 shares,\n    address receiver,\n    address owner,\n    uint64 epoch\n  ) public virtual returns (uint256 assets) {\n    // check to ensure that the requested epoch is not the current epoch or in the past\n    require(epoch >= currentEpoch, \"Exit epoch too low\");\n\n    require(msg.sender == owner, \"Only the owner can redeem\");\n    // check for rounding error since we round down in previewRedeem.\n\n    ERC20(address(this)).safeTransferFrom(owner, address(this), shares);\n\n    // Deploy WithdrawProxy if no WithdrawProxy exists for the specified epoch\n    _deployWithdrawProxyIfNotDeployed(epoch);\n\n    emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n    // WithdrawProxy shares are minted 1:1 with PublicVault shares\n    WithdrawProxy(withdrawProxies[epoch]).mint(receiver, shares); // was withdrawProxies[withdrawEpoch]\n  }\n\n  function _deployWithdrawProxyIfNotDeployed(uint64 epoch) internal {\n    if (withdrawProxies[epoch] == address(0)) {\n      address proxy = ClonesWithImmutableArgs.clone(\n        IAstariaRouter(ROUTER()).WITHDRAW_IMPLEMENTATION(),\n        abi.encodePacked(\n          address(this), //owner\n          underlying() //token\n        )\n      );\n      withdrawProxies[epoch] = proxy;\n    }\n  }\n\n  /**\n   * @notice Deposit funds into the PublicVault.\n   * @param amount The amount of funds to deposit.\n   * @param receiver The receiver of the resulting VaultToken shares.\n   */\n  function deposit(uint256 amount, address receiver)\n    public\n    override(Vault, ERC4626Cloned)\n    whenNotPaused\n    returns (uint256)\n  {\n    return super.deposit(amount, receiver);\n  }\n\n  /**\n   * @notice Retrieve the domain separator.\n   * @return The domain separator.\n   */\n  function computeDomainSeparator() internal view override returns (bytes32) {\n    return super.domainSeparator();\n  }\n\n  /**\n   * @notice Rotate epoch boundary. This must be called before the next epoch can begin.\n   */\n  function processEpoch() external {\n    // check to make sure epoch is over\n    require(getEpochEnd(currentEpoch) < block.timestamp, \"Epoch has not ended\");\n    require(withdrawReserve == 0, \"Withdraw reserve not empty\");\n    if (liquidationAccountants[currentEpoch] != address(0)) {\n      require(\n        LiquidationAccountant(liquidationAccountants[currentEpoch])\n          .getFinalAuctionEnd() < block.timestamp,\n        \"Final auction not ended\"\n      );\n    }\n\n    // split funds from LiquidationAccountant between PublicVault and WithdrawProxy if hasn't been already\n    if (\n      currentEpoch != 0 &&\n      liquidationAccountants[currentEpoch - 1] != address(0)\n    ) {\n      LiquidationAccountant(liquidationAccountants[currentEpoch - 1]).claim();\n    }\n\n    require(\n      liensOpenForEpoch[currentEpoch] == uint256(0),\n      \"loans are still open for this epoch\"\n    );\n\n    // reset liquidationWithdrawRatio to prepare for re calcualtion\n    liquidationWithdrawRatio = 0;\n\n    // check if there are LPs withdrawing this epoch\n    if (withdrawProxies[currentEpoch] != address(0)) {\n      uint256 proxySupply = WithdrawProxy(withdrawProxies[currentEpoch])\n        .totalSupply();\n\n      liquidationWithdrawRatio = proxySupply.mulDivDown(1e18, totalSupply());\n\n      if (liquidationAccountants[currentEpoch] != address(0)) {\n        LiquidationAccountant(liquidationAccountants[currentEpoch])\n          .setWithdrawRatio(liquidationWithdrawRatio);\n      }\n\n      uint256 withdrawAssets = convertToAssets(proxySupply);\n      // compute the withdrawReserve\n      uint256 withdrawLiquidations = liquidationsExpectedAtBoundary[\n        currentEpoch\n      ].mulDivDown(liquidationWithdrawRatio, 1e18);\n      withdrawReserve = withdrawAssets - withdrawLiquidations;\n      // burn the tokens of the LPs withdrawing\n      _burn(address(this), proxySupply);\n\n      _decreaseYIntercept(withdrawAssets);\n    }\n\n    // increment epoch\n    currentEpoch++;\n  }\n\n  /**\n   * @notice Deploys a LiquidationAccountant for the WithdrawProxy for the upcoming epoch boundary.\n   * @return accountant The address of the deployed LiquidationAccountant.\n   */\n  function deployLiquidationAccountant() public returns (address accountant) {\n    require(\n      liquidationAccountants[currentEpoch] == address(0),\n      \"cannot deploy two liquidation accountants for the same epoch\"\n    );\n\n    _deployWithdrawProxyIfNotDeployed(currentEpoch);\n\n    accountant = ClonesWithImmutableArgs.clone(\n      IAstariaRouter(ROUTER()).LIQUIDATION_IMPLEMENTATION(),\n      abi.encodePacked(\n        underlying(),\n        ROUTER(),\n        address(this),\n        address(LIEN_TOKEN()),\n        address(withdrawProxies[currentEpoch])\n      )\n    );\n    liquidationAccountants[currentEpoch] = accountant;\n  }\n\n  function supportsInterface(bytes4 interfaceId)\n    public\n    pure\n    override(IERC165)\n    returns (bool)\n  {\n    return\n      interfaceId == type(IPublicVault).interfaceId ||\n      interfaceId == type(IVault).interfaceId ||\n      interfaceId == type(ERC4626Cloned).interfaceId ||\n      interfaceId == type(ERC4626).interfaceId ||\n      interfaceId == type(ERC20).interfaceId ||\n      interfaceId == type(IERC165).interfaceId;\n  }\n\n  event TransferWithdraw(uint256 a, uint256 b);\n\n  /**\n   * @notice Transfers funds from the PublicVault to the WithdrawProxy.\n   */\n\n  function transferWithdrawReserve() public {\n    // check the available balance to be withdrawn\n    uint256 withdraw = ERC20(underlying()).balanceOf(address(this));\n    emit TransferWithdraw(withdraw, withdrawReserve);\n\n    // prevent transfer of more assets then are available\n    if (withdrawReserve <= withdraw) {\n      withdraw = withdrawReserve;\n      withdrawReserve = 0;\n    } else {\n      withdrawReserve -= withdraw;\n    }\n    emit TransferWithdraw(withdraw, withdrawReserve);\n\n    address currentWithdrawProxy = withdrawProxies[currentEpoch - 1]; //\n    // prevents transfer to a non-existent WithdrawProxy\n    // withdrawProxies are indexed by the epoch where they're deployed\n    if (currentWithdrawProxy != address(0)) {\n      ERC20(underlying()).safeTransfer(currentWithdrawProxy, withdraw);\n      emit WithdrawReserveTransferred(withdraw);\n    }\n  }\n\n  /**\n   * @dev Hook for updating the slope of the PublicVault after a LienToken is issued.\n   * @param lienId The ID of the lien.\n   * @param amount The amount of debt\n   */\n  function _afterCommitToLien(uint256 lienId, uint256 amount)\n    internal\n    virtual\n    override\n  {\n    // increment slope for the new lien\n    unchecked {\n      slope += LIEN_TOKEN().calculateSlope(lienId);\n    }\n\n    ILienToken.Lien memory lien = LIEN_TOKEN().getLien(lienId);\n\n    uint256 epoch = Math.ceilDiv(\n      lien.start + lien.duration - START(),\n      EPOCH_LENGTH()\n    ) - 1;\n\n    liensOpenForEpoch[epoch]++;\n    emit LienOpen(lienId, epoch);\n  }\n\n  event LienOpen(uint256 lienId, uint256 epoch);\n\n  /**\n   * @notice Retrieves the address of the LienToken contract for this PublicVault.\n   * @return The LienToken address.\n   */\n\n  function LIEN_TOKEN() public view returns (ILienToken) {\n    return IAstariaRouter(ROUTER()).LIEN_TOKEN();\n  }\n\n  /**\n   * @notice Computes the implied value of this PublicVault. This includes interest payments that have not yet been made.\n   * @return The implied value for this PublicVault.\n   */\n\n  function totalAssets() public view virtual override returns (uint256) {\n    if (last == 0 || yIntercept == 0) {\n      return ERC20(underlying()).balanceOf(address(this));\n    }\n    uint256 delta_t = block.timestamp - last;\n\n    return slope.mulDivDown(delta_t, 1) + yIntercept;\n  }\n\n  function totalSupply() public view virtual override returns (uint256) {\n    return _totalSupply + strategistUnclaimedShares;\n  }\n\n  /**\n   * @notice Mints earned fees by the strategist to the strategist address.\n   */\n  function claim() external onlyOwner {\n    _mint(owner(), strategistUnclaimedShares);\n    strategistUnclaimedShares = 0;\n  }\n\n  /**\n   * @notice Hook to update the slope and yIntercept of the PublicVault on payment.\n   * The rate for the LienToken is subtracted from the total slope of the PublicVault, and recalculated in afterPayment().\n   * @param lienId The ID of the lien.\n   * @param amount The amount paid off to deduct from the yIntercept of the PublicVault.\n   */\n  function beforePayment(uint256 lienId, uint256 amount) public onlyLienToken {\n    _handleStrategistInterestReward(lienId, amount);\n    uint256 lienSlope = LIEN_TOKEN().calculateSlope(lienId);\n    if (lienSlope > slope) {\n      slope = 0;\n    } else {\n      slope -= lienSlope;\n    }\n    last = block.timestamp;\n  }\n\n  /** @notice\n   * hook to modify the liens open for then given epoch\n   * @param epoch epoch to decrease liens of\n   */\n  function decreaseEpochLienCount(uint256 epoch) external {\n    require(\n      msg.sender == address(ROUTER()) || msg.sender == address(LIEN_TOKEN()),\n      \"only router or lien token\"\n    );\n    liensOpenForEpoch[epoch]--;\n  }\n\n  /** @notice\n   * hook to increase the amount of debt currently liquidated to discount in processEpoch\n   * @param amount the amount of debt liquidated\n   */\n  function increaseLiquidationsExpectedAtBoundary(uint256 amount) external {\n    require(msg.sender == ROUTER(), \"only router\");\n    liquidationsExpectedAtBoundary[currentEpoch] += amount;\n  }\n\n  /** @notice\n   * helper to return the LienEpoch for a given end date\n   * @param end time to compute the end for\n   */\n  function getLienEpoch(uint256 end) external view returns (uint256) {\n    return Math.ceilDiv(end - START(), EPOCH_LENGTH()) - 1;\n  }\n\n  function getEpochEnd(uint256 epoch) public view returns (uint256) {\n    return START() + (epoch + 1) * EPOCH_LENGTH();\n  }\n\n  function _increaseOpenLiens() internal {\n    liensOpenForEpoch[currentEpoch]++;\n  }\n\n  /**\n   * @notice Hook to recalculate the slope of a lien after a payment has been made.\n   * @param lienId The ID of the lien.\n   */\n  function afterPayment(uint256 lienId) public onlyLienToken {\n    slope += LIEN_TOKEN().calculateSlope(lienId);\n  }\n\n  modifier onlyLienToken() {\n    require(msg.sender == address(LIEN_TOKEN()));\n    _;\n  }\n\n  /**\n   * @notice After-deposit hook to update the yIntercept of the PublicVault to reflect a capital contribution.\n   * @param assets The amount of assets deposited to the PublicVault.\n   * @param shares The resulting amount of VaultToken shares that were issued.\n   */\n  function afterDeposit(uint256 assets, uint256 shares)\n    internal\n    virtual\n    override\n  {\n    yIntercept += assets;\n    emit YInterceptChanged(yIntercept);\n  }\n\n  /**\n   * @dev Handles the dilutive fees (on lien repayments) for strategists in VaultTokens.\n   * @param lienId The ID of the lien that received a payment.\n   * @param amount The amount that was paid.\n   */\n  function _handleStrategistInterestReward(uint256 lienId, uint256 amount)\n    internal\n    virtual\n    override\n  {\n    if (VAULT_FEE() != uint256(0)) {\n      uint256 interestOwing = LIEN_TOKEN().getInterest(lienId);\n      uint256 x = (amount > interestOwing) ? interestOwing : amount;\n      uint256 fee = x.mulDivDown(VAULT_FEE(), 1000); //VAULT_FEE is a basis point\n      strategistUnclaimedShares += convertToShares(fee);\n    }\n  }\n\n  function updateVaultAfterLiquidation(uint256 lienSlope) public {\n    require(msg.sender == ROUTER(), \"can only be called by the router\");\n    uint256 delta_t = block.timestamp - last;\n\n    yIntercept = slope.mulDivDown(delta_t, 1) + yIntercept;\n    last = block.timestamp;\n    slope -= lienSlope;\n  }\n\n  function getYIntercept() public view returns (uint256) {\n    return yIntercept;\n  }\n\n  function _decreaseYIntercept(uint256 amount) internal {\n    yIntercept -= amount;\n    emit YInterceptChanged(yIntercept);\n  }\n\n  function decreaseYIntercept(uint256 amount) public {\n    require(\n      msg.sender == AUCTION_HOUSE() ||\n        (currentEpoch != 0 &&\n          msg.sender == liquidationAccountants[currentEpoch - 1]),\n      \"msg sender only from auction house or liquidation accountant\"\n    );\n    _decreaseYIntercept(amount);\n  }\n\n  function getCurrentEpoch() public view returns (uint64) {\n    return currentEpoch;\n  }\n\n  /**\n   * @notice Computes the time until the current epoch is over.\n   * @return Seconds until the current epoch ends.\n   */\n  function timeToEpochEnd() public view returns (uint256) {\n    uint256 epochEnd = START() + ((currentEpoch + 1) * EPOCH_LENGTH());\n\n    if (epochEnd >= block.timestamp) {\n      return uint256(0);\n    }\n\n    return block.timestamp - epochEnd; //\n  }\n\n  function getLiquidationAccountant(uint64 epoch)\n    public\n    view\n    returns (address)\n  {\n    return liquidationAccountants[epoch];\n  }\n}"
    },
    {
      "filename": "src/AstariaRouter.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n\n/**\n *       __  ___       __\n *  /\\  /__'  |   /\\  |__) |  /\\\n * /~~\\ .__/  |  /~~\\ |  \\ | /~~\\\n *\n * Copyright (c) Astaria Labs, Inc\n */\n\npragma solidity ^0.8.17;\n\nimport {Auth, Authority} from \"solmate/auth/Auth.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\n\nimport {IAuctionHouse} from \"gpl/interfaces/IAuctionHouse.sol\";\nimport {IERC721} from \"gpl/interfaces/IERC721.sol\";\nimport {ITransferProxy} from \"gpl/interfaces/ITransferProxy.sol\";\nimport {SafeCastLib} from \"gpl/utils/SafeCastLib.sol\";\n\nimport {\n  ClonesWithImmutableArgs\n} from \"clones-with-immutable-args/ClonesWithImmutableArgs.sol\";\n\nimport {CollateralLookup} from \"./libraries/CollateralLookup.sol\";\n\nimport {IAstariaRouter} from \"./interfaces/IAstariaRouter.sol\";\nimport {ICollateralToken} from \"./interfaces/ICollateralToken.sol\";\nimport {ILienBase, ILienToken} from \"./interfaces/ILienToken.sol\";\nimport {IStrategyValidator} from \"./interfaces/IStrategyValidator.sol\";\n\nimport {IPublicVault, PublicVault} from \"./PublicVault.sol\";\nimport {IVault, VaultImplementation} from \"./VaultImplementation.sol\";\nimport {LiquidationAccountant} from \"./LiquidationAccountant.sol\";\n\nimport {MerkleProof} from \"./utils/MerkleProof.sol\";\nimport {Pausable} from \"./utils/Pausable.sol\";\n\n/**\n * @title AstariaRouter\n * @notice This contract manages the deployment of Vaults and universal Astaria actions.\n */\ncontract AstariaRouter is Auth, Pausable, IAstariaRouter {\n  using SafeTransferLib for ERC20;\n  using SafeCastLib for uint256;\n  using CollateralLookup for address;\n  using FixedPointMathLib for uint256;\n\n  ERC20 public immutable WETH;\n  ICollateralToken public immutable COLLATERAL_TOKEN;\n  ILienToken public immutable LIEN_TOKEN;\n  ITransferProxy public immutable TRANSFER_PROXY;\n\n  address public LIQUIDATION_IMPLEMENTATION;\n  address public SOLO_IMPLEMENTATION;\n  address public VAULT_IMPLEMENTATION;\n  address public WITHDRAW_IMPLEMENTATION;\n  address public feeTo;\n  uint256 public liquidationFeePercent;\n  uint256 public maxInterestRate;\n  uint256 public maxEpochLength;\n  uint256 public minEpochLength;\n  uint256 public minInterestBPS; // was uint64\n  uint256 public protocolFeeNumerator;\n  uint256 public protocolFeeDenominator;\n  uint256 public strategistFeeNumerator;\n  uint256 public strategistFeeDenominator;\n  uint256 public buyoutFeeNumerator;\n  uint256 public buyoutFeeDenominator;\n  uint32 public minDurationIncrease;\n  uint32 public buyoutInterestWindow;\n\n  //A strategist can have many deployed vaults\n  mapping(address => address) public vaults;\n  mapping(address => uint256) public strategistNonce;\n  mapping(uint16 => address) public strategyValidators;\n\n  /**\n   * @dev Setup transfer authority and set up addresses for deployed CollateralToken, LienToken, TransferProxy contracts, as well as PublicVault and SoloVault implementations to clone.\n   * @param _AUTHORITY The authority manager.\n   * @param _WETH The WETH address to use for transfers.\n   * @param _COLLATERAL_TOKEN The address of the deployed CollateralToken contract.\n   * @param _LIEN_TOKEN The address of the deployed LienToken contract.\n   * @param _TRANSFER_PROXY The address of the deployed TransferProxy contract.\n   * @param _VAULT_IMPL The address of a base implementation of VaultImplementation for cloning.\n   * @param _SOLO_IMPL The address of a base implementation of a PrivateVault for cloning.\n   */\n  constructor(\n    Authority _AUTHORITY,\n    address _WETH,\n    ICollateralToken _COLLATERAL_TOKEN,\n    ILienToken _LIEN_TOKEN,\n    ITransferProxy _TRANSFER_PROXY,\n    address _VAULT_IMPL,\n    address _SOLO_IMPL\n  ) Auth(address(msg.sender), _AUTHORITY) {\n    WETH = ERC20(_WETH);\n    COLLATERAL_TOKEN = _COLLATERAL_TOKEN;\n    LIEN_TOKEN = _LIEN_TOKEN;\n    TRANSFER_PROXY = _TRANSFER_PROXY;\n    VAULT_IMPLEMENTATION = _VAULT_IMPL;\n    SOLO_IMPLEMENTATION = _SOLO_IMPL;\n    liquidationFeePercent = 13;\n    minInterestBPS = uint256(0.0005 ether) / uint256(365 days); //5 bips / second\n    minEpochLength = 7 days;\n    maxEpochLength = 45 days;\n    maxInterestRate = 63419583966; // 200% apy / second\n    strategistFeeNumerator = 200;\n    strategistFeeDenominator = 1000;\n    minDurationIncrease = 14 days;\n    buyoutInterestWindow = 60 days;\n  }\n\n  /**\n   * @dev Enables _pause, freezing functions with the whenNotPaused modifier.\n   */\n  function __emergencyPause() external requiresAuth whenNotPaused {\n    _pause();\n  }\n\n  /**\n   * @dev Disables _pause, un-freezing functions with the whenNotPaused modifier.\n   */\n  function __emergencyUnpause() external requiresAuth whenPaused {\n    _unpause();\n  }\n\n  function incrementNonce() external {\n    strategistNonce[msg.sender]++;\n  }\n\n  /**\n   * @notice Sets universal protocol parameters or changes the addresses for deployed contracts.\n   * @param what The identifier for what is being filed.\n   * @param data The encoded address data to be decoded and filed.\n   */\n  function fileBatch(bytes32[] memory what, bytes[] calldata data)\n    external\n    requiresAuth\n  {\n    require(what.length == data.length, \"data length mismatch\");\n    for (uint256 i = 0; i < what.length; i++) {\n      file(what[i], data[i]);\n    }\n  }\n\n  function file(bytes32 what, bytes calldata data) public requiresAuth {\n    if (what == \"LIQUIDATION_FEE_PERCENT\") {\n      uint256 value = abi.decode(data, (uint256));\n      liquidationFeePercent = value;\n    } else if (what == \"MIN_INTEREST_BPS\") {\n      uint256 value = abi.decode(data, (uint256));\n      minInterestBPS = uint256(value);\n    } else if (what == \"APPRAISER_NUMERATOR\") {\n      uint256 value = abi.decode(data, (uint256));\n      strategistFeeNumerator = value;\n    } else if (what == \"APPRAISER_ORIGINATION_FEE_BASE\") {\n      uint256 value = abi.decode(data, (uint256));\n      strategistFeeDenominator = value;\n    } else if (what == \"MIN_DURATION_INCREASE\") {\n      uint256 value = abi.decode(data, (uint256));\n      minDurationIncrease = value.safeCastTo32();\n    } else if (what == \"WITHDRAW_IMPLEMENTATION\") {\n      address addr = abi.decode(data, (address));\n      WITHDRAW_IMPLEMENTATION = addr;\n    } else if (what == \"LIQUIDATION_IMPLEMENTATION\") {\n      address addr = abi.decode(data, (address));\n      LIQUIDATION_IMPLEMENTATION = addr;\n    } else if (what == \"VAULT_IMPLEMENTATION\") {\n      address addr = abi.decode(data, (address));\n      VAULT_IMPLEMENTATION = addr;\n    } else if (what == \"SOLO_IMPLEMENTATION\") {\n      address addr = abi.decode(data, (address));\n      SOLO_IMPLEMENTATION = addr;\n    } else if (what == \"MIN_EPOCH_LENGTH\") {\n      minEpochLength = abi.decode(data, (uint256));\n    } else if (what == \"MAX_EPOCH_LENGTH\") {\n      maxEpochLength = abi.decode(data, (uint256));\n    } else if (what == \"MAX_INTEREST_RATE\") {\n      maxInterestRate = abi.decode(data, (uint256));\n    } else if (what == \"feeTo\") {\n      address addr = abi.decode(data, (address));\n      feeTo = addr;\n    } else if (what == \"setBuyoutInterestWindow\") {\n      uint256 value = abi.decode(data, (uint256));\n      buyoutInterestWindow = value.safeCastTo32();\n    } else if (what == \"setStrategyValidator\") {\n      (uint8 TYPE, address addr) = abi.decode(data, (uint8, address));\n      strategyValidators[TYPE] = addr;\n    } else {\n      revert(\"unsupported/file\");\n    }\n  }\n\n  // MODIFIERS\n  modifier onlyVaults() {\n    require(\n      vaults[msg.sender] != address(0),\n      \"this vault has not been initialized\"\n    );\n    _;\n  }\n\n  //PUBLIC\n\n  function validateCommitment(IAstariaRouter.Commitment calldata commitment)\n    public\n    returns (bool valid, IAstariaRouter.LienDetails memory ld)\n  {\n    require(\n      commitment.lienRequest.strategy.deadline >= block.timestamp,\n      \"deadline passed\"\n    );\n\n    require(\n      strategyValidators[commitment.lienRequest.nlrType] != address(0),\n      \"invalid strategy type\"\n    );\n\n    bytes32 leaf;\n    (leaf, ld) = IStrategyValidator(\n      strategyValidators[commitment.lienRequest.nlrType]\n    ).validateAndParse(\n        commitment.lienRequest,\n        COLLATERAL_TOKEN.ownerOf(\n          commitment.tokenContract.computeId(commitment.tokenId)\n        ),\n        commitment.tokenContract,\n        commitment.tokenId\n      );\n\n    return (\n      MerkleProof.verifyCalldata(\n        commitment.lienRequest.merkle.proof,\n        commitment.lienRequest.merkle.root,\n        leaf\n      ),\n      ld\n    );\n  }\n\n  /**\n   * @notice Deposits collateral and requests loans for multiple NFTs at once.\n   * @param commitments The commitment proofs and requested loan data for each loan.\n   * @return totalBorrowed The total amount borrowed by the requested loans.\n   */\n  function commitToLiens(IAstariaRouter.Commitment[] calldata commitments)\n    external\n    whenNotPaused\n    returns (uint256 totalBorrowed)\n  {\n    totalBorrowed = 0;\n    for (uint256 i = 0; i < commitments.length; ++i) {\n      _transferAndDepositAsset(\n        commitments[i].tokenContract,\n        commitments[i].tokenId\n      );\n      totalBorrowed += _executeCommitment(commitments[i]);\n\n      uint256 collateralId = commitments[i].tokenContract.computeId(\n        commitments[i].tokenId\n      );\n      _returnCollateral(collateralId, address(msg.sender));\n    }\n    WETH.safeApprove(address(TRANSFER_PROXY), totalBorrowed);\n    TRANSFER_PROXY.tokenTransferFrom(\n      address(WETH),\n      address(this),\n      address(msg.sender),\n      totalBorrowed\n    );\n  }\n\n  /**\n   * @notice Deploys a new PrivateVault.\n   * @return The address of the new PrivateVault.\n   */\n  function newVault(address delegate) external whenNotPaused returns (address) {\n    return _newVault(uint256(0), delegate, uint256(0));\n  }\n\n  /**\n   * @notice Deploys a new PublicVault.\n   * @param epochLength The length of each epoch for the new PublicVault.\n   */\n  function newPublicVault(\n    uint256 epochLength,\n    address delegate,\n    uint256 vaultFee\n  ) external whenNotPaused returns (address) {\n    return _newVault(epochLength, delegate, vaultFee);\n  }\n\n  /**\n   * @notice Create a new lien against a CollateralToken.\n   * @param terms the decoded lien details from the commitment\n   * @param params The valid proof and lien details for the new loan.\n   * @return The ID of the created lien.\n   */\n  function requestLienPosition(\n    IAstariaRouter.LienDetails memory terms,\n    IAstariaRouter.Commitment calldata params\n  ) external whenNotPaused onlyVaults returns (uint256) {\n    return\n      LIEN_TOKEN.createLien(\n        ILienBase.LienActionEncumber({\n          tokenContract: params.tokenContract,\n          tokenId: params.tokenId,\n          terms: terms,\n          strategyRoot: params.lienRequest.merkle.root,\n          amount: params.lienRequest.amount,\n          vault: address(msg.sender)\n        })\n      );\n  }\n\n  /**\n   * @notice Lend to a PublicVault.\n   * @param vault The address of the PublicVault.\n   * @param amount The amount to lend.\n   */\n  function lendToVault(IVault vault, uint256 amount) external whenNotPaused {\n    TRANSFER_PROXY.tokenTransferFrom(\n      address(WETH),\n      address(msg.sender),\n      address(this),\n      amount\n    );\n\n    require(\n      vaults[address(vault)] != address(0),\n      \"lendToVault: vault doesn't exist\"\n    );\n    WETH.safeApprove(address(vault), amount);\n    vault.deposit(amount, address(msg.sender));\n  }\n\n  /**\n   * @notice Returns whether a specific lien can be liquidated.\n   * @param collateralId The ID of the underlying CollateralToken.\n   * @param position The specified lien position.\n   * @return A boolean value indicating whether the specified lien can be liquidated.\n   */\n  function canLiquidate(uint256 collateralId, uint256 position)\n    public\n    view\n    returns (bool)\n  {\n    ILienToken.Lien memory lien = LIEN_TOKEN.getLien(collateralId, position);\n\n    return (lien.start + lien.duration <= block.timestamp && lien.amount > 0);\n  }\n\n  /**\n   * @notice Liquidate a CollateralToken that has defaulted on one of its liens.\n   * @param collateralId The ID of the CollateralToken.\n   * @param position The position of the defaulted lien.\n   * @return reserve The amount owed on all liens for against the collateral being liquidated, including accrued interest.\n   */\n  function liquidate(uint256 collateralId, uint256 position)\n    external\n    returns (uint256 reserve)\n  {\n    require(\n      canLiquidate(collateralId, position),\n      \"liquidate: borrow is healthy\"\n    );\n\n    // if expiration will be past epoch boundary, then create a LiquidationAccountant\n\n    uint256[] memory liens = LIEN_TOKEN.getLiens(collateralId);\n    for (uint256 i = 0; i < liens.length; ++i) {\n      uint256 currentLien = liens[i];\n\n      ILienToken.Lien memory lien = LIEN_TOKEN.getLien(currentLien);\n\n      address owner = LIEN_TOKEN.ownerOf(currentLien);\n      if (\n        IPublicVault(owner).supportsInterface(type(IPublicVault).interfaceId)\n      ) {\n        // subtract slope from PublicVault\n\n        PublicVault(owner).updateVaultAfterLiquidation(\n          LIEN_TOKEN.calculateSlope(currentLien)\n        );\n        if (\n          PublicVault(owner).timeToEpochEnd() <=\n          COLLATERAL_TOKEN.auctionWindow()\n        ) {\n          uint64 currentEpoch = PublicVault(owner).getCurrentEpoch();\n          address accountant = PublicVault(owner).getLiquidationAccountant(\n            currentEpoch\n          );\n          uint256 lienEpoch = PublicVault(owner).getLienEpoch(\n            lien.start + lien.duration\n          );\n          PublicVault(owner).decreaseEpochLienCount(lienEpoch);\n\n          // only deploy a LiquidationAccountant for the next set of withdrawing LPs if the previous set of LPs have been repaid\n          if (PublicVault(owner).withdrawReserve() == 0) {\n            if (accountant == address(0)) {\n              accountant = PublicVault(owner).deployLiquidationAccountant();\n            }\n            LIEN_TOKEN.setPayee(currentLien, accountant);\n            LiquidationAccountant(accountant).handleNewLiquidation(\n              lien.amount,\n              COLLATERAL_TOKEN.auctionWindow() + 1 days\n            );\n            PublicVault(owner).increaseLiquidationsExpectedAtBoundary(\n              lien.amount\n            );\n          }\n        }\n      }\n    }\n\n    reserve = COLLATERAL_TOKEN.auctionVault(\n      collateralId,\n      address(msg.sender),\n      liquidationFeePercent\n    );\n\n    emit Liquidation(collateralId, position, reserve);\n  }\n\n  /**\n   * @notice Retrieves the fee PublicVault strategists earn on loan origination.\n   * @return The numerator and denominator used to compute the percentage fee strategists earn by receiving mint"
    }
  ]
}