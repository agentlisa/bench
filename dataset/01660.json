{
  "Title": "M-3: Min deposit protection during rebalancing can be bypassed if multiple fee tiers",
  "Content": "# Issue M-3: Min deposit protection during rebalancing can be bypassed if multiple fee tiers \n\nSource: https://github.com/sherlock-audit/2023-06-arrakis-judging/issues/28 \n\n## Found by \ncergyk\n## Summary\nArrakis vault implements a slippage protection during rebalancing, but it does not protect when multiple feeTiers are used.\n\n## Vulnerability Detail\nThe slippage protection used here:\nhttps://github.com/sherlock-audit/2023-06-arrakis/blob/main/v2-core/contracts/ArrakisV2.sol#L408-L409\n\ncan be used to check that liquidity is added around a given price (acts like a slippage protection), when used on one pool.\n\nHowever when aggregated on multiple pools as it is done here (over same tokens but multiple fee tiers), it does not protect the user, as pools can be imbalanced in different directions, and funds can be provided in the same proportion but provide liquidity at a worse price,\n\nExample:\n\nArrakis vault handles the price range 1200-2000 on WETH-USDC in fee tiers [0.3%, 0.5%], price of WETH sits at 1600.\n\nAlice sees that Bob the operator tries to rebalance the pool and thus provides liquidity on both ranges\n\nAlice front runs Bob transaction, driving the price of WETH-USDC on fee tier 0.3% to 1200, and on fee tier 0.5% to 2000.\n\nBob executes his operation, and provides bigger amounts of WETH and USDC to provide same liquidity (worse prices), and so the slippage checks out.\n\nAlice back runs the operation and makes a nice profit.\n\nPlease note that in the setup using `SimpleManager`, price deviation is checked on every minting pool:\nhttps://github.com/sherlock-audit/2023-06-arrakis/blob/main/v2-manager-templates/contracts/SimpleManager.sol#L189-L194\n\nSo the sandwiching is limited by the deviation parameter (1%). This issue still holds, since maybe Bob wanted to enforce a stricter deviation for his rebalance (0.5%) using this check, and fails to do so.\n\n## Impact\nBob makes an unfortunate rebalance to the profit of a sandwich.\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\nCheck deposited amounts in aggregate but grouped by fee tiers. \n\n\n\n\n## Discussion\n\n**kassandraoftroy**\n\nFor me this issue is a valid medium and not a duplicate of #164 since it is about rebalance() not addLiquidity() (so does not have the proper checks to sniff out manipulation when adding liquidity on multiple fee tiers simultaneously).\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/86",
  "Code": [
    {
      "filename": "v2-core/contracts/ArrakisV2.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.13;\n\nimport {\n    IUniswapV3MintCallback\n} from \"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3MintCallback.sol\";\nimport {\n    IUniswapV3Pool\n} from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport {\n    IUniswapV3Factory,\n    ArrakisV2Storage,\n    IERC20,\n    SafeERC20,\n    EnumerableSet,\n    Range,\n    Rebalance\n} from \"./abstract/ArrakisV2Storage.sol\";\nimport {FullMath} from \"@arrakisfi/v3-lib-0.8/contracts/LiquidityAmounts.sol\";\nimport {Withdraw, UnderlyingPayload} from \"./structs/SArrakisV2.sol\";\nimport {Position} from \"./libraries/Position.sol\";\nimport {Pool} from \"./libraries/Pool.sol\";\nimport {Underlying as UnderlyingHelper} from \"./libraries/Underlying.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {hundredPercent} from \"./constants/CArrakisV2.sol\";\n\n/// @title ArrakisV2 LP vault version 2\n/// @notice Smart contract managing liquidity providing strategy for a given token pair\n/// using multiple Uniswap V3 LP positions on multiple fee tiers.\n/// @author Arrakis Finance\n/// @dev DO NOT ADD STATE VARIABLES - APPEND THEM TO ArrakisV2Storage\ncontract ArrakisV2 is IUniswapV3MintCallback, ArrakisV2Storage {\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    // solhint-disable-next-line no-empty-blocks\n    constructor(IUniswapV3Factory factory_) ArrakisV2Storage(factory_) {}\n\n    /// @notice Uniswap V3 callback fn, called back on pool.mint\n    function uniswapV3MintCallback(\n        uint256 amount0Owed_,\n        uint256 amount1Owed_,\n        bytes calldata /*_data*/\n    ) external override {\n        _uniswapV3CallBack(amount0Owed_, amount1Owed_);\n    }\n\n    /// @notice mint Arrakis V2 shares by depositing underlying\n    /// @param mintAmount_ represent the amount of Arrakis V2 shares to mint.\n    /// @param receiver_ address that will receive Arrakis V2 shares.\n    /// @return amount0 amount of token0 needed to mint mintAmount_ of shares.\n    /// @return amount1 amount of token1 needed to mint mintAmount_ of shares.\n    // solhint-disable-next-line function-max-lines, code-complexity\n    function mint(uint256 mintAmount_, address receiver_)\n        external\n        nonReentrant\n        returns (uint256 amount0, uint256 amount1)\n    {\n        require(mintAmount_ > 0, \"MA\");\n        require(\n            restrictedMint == address(0) || msg.sender == restrictedMint,\n            \"R\"\n        );\n        address me = address(this);\n        uint256 ts = totalSupply();\n        bool isTotalSupplyGtZero = ts > 0;\n        if (isTotalSupplyGtZero) {\n            (amount0, amount1) = UnderlyingHelper.totalUnderlyingForMint(\n                UnderlyingPayload({\n                    ranges: _ranges,\n                    factory: factory,\n                    token0: address(token0),\n                    token1: address(token1),\n                    self: me\n                }),\n                mintAmount_,\n                ts\n            );\n        } else {\n            uint256 denominator = 1 ether;\n            uint256 init0M = init0;\n            uint256 init1M = init1;\n\n            amount0 = FullMath.mulDivRoundingUp(\n                mintAmount_,\n                init0M,\n                denominator\n            );\n            amount1 = FullMath.mulDivRoundingUp(\n                mintAmount_,\n                init1M,\n                denominator\n            );\n\n            /// @dev check ratio against small values that skew init ratio\n            if (FullMath.mulDiv(mintAmount_, init0M, denominator) == 0) {\n                amount0 = 0;\n            }\n            if (FullMath.mulDiv(mintAmount_, init1M, denominator) == 0) {\n                amount1 = 0;\n            }\n\n            uint256 amount0Mint = init0M != 0\n                ? FullMath.mulDiv(amount0, denominator, init0M)\n                : type(uint256).max;\n            uint256 amount1Mint = init1M != 0\n                ? FullMath.mulDiv(amount1, denominator, init1M)\n                : type(uint256).max;\n\n            require(\n                (amount0Mint < amount1Mint ? amount0Mint : amount1Mint) ==\n                    mintAmount_,\n                \"A0&A1\"\n            );\n        }\n\n        _mint(receiver_, mintAmount_);\n\n        // transfer amounts owed to contract\n        if (amount0 > 0) {\n            token0.safeTransferFrom(msg.sender, me, amount0);\n        }\n        if (amount1 > 0) {\n            token1.safeTransferFrom(msg.sender, me, amount1);\n        }\n\n        if (isTotalSupplyGtZero) {\n            for (uint256 i; i < _ranges.length; i++) {\n                Range memory range = _ranges[i];\n                IUniswapV3Pool pool = IUniswapV3Pool(\n                    factory.getPool(\n                        address(token0),\n                        address(token1),\n                        range.feeTier\n                    )\n                );\n                uint128 liquidity = Position.getLiquidityByRange(\n                    pool,\n                    me,\n                    range.lowerTick,\n                    range.upperTick\n                );\n                if (liquidity == 0) continue;\n\n                liquidity = SafeCast.toUint128(\n                    FullMath.mulDiv(liquidity, mintAmount_, ts)\n                );\n\n                pool.mint(me, range.lowerTick, range.upperTick, liquidity, \"\");\n            }\n        }\n\n        emit LogMint(receiver_, mintAmount_, amount0, amount1);\n    }\n\n    /// @notice burn Arrakis V2 shares and withdraw underlying.\n    /// @param burnAmount_ amount of vault shares to burn.\n    /// @param receiver_ address to receive underlying tokens withdrawn.\n    /// @return amount0 amount of token0 sent to receiver\n    /// @return amount1 amount of token1 sent to receiver\n    // solhint-disable-next-line function-max-lines, code-complexity\n    function burn(uint256 burnAmount_, address receiver_)\n        external\n        nonReentrant\n        returns (uint256 amount0, uint256 amount1)\n    {\n        require(burnAmount_ > 0, \"BA\");\n\n        uint256 ts = totalSupply();\n        require(ts > 0, \"TS\");\n\n        _burn(msg.sender, burnAmount_);\n\n        Withdraw memory total;\n        for (uint256 i; i < _ranges.length; i++) {\n            Range memory range = _ranges[i];\n            IUniswapV3Pool pool = IUniswapV3Pool(\n                factory.getPool(address(token0), address(token1), range.feeTier)\n            );\n            uint128 liquidity = Position.getLiquidityByRange(\n                pool,\n                address(this),\n                range.lowerTick,\n                range.upperTick\n            );\n            if (liquidity == 0) continue;\n\n            liquidity = SafeCast.toUint128(\n                FullMath.mulDiv(liquidity, burnAmount_, ts)\n            );\n\n            Withdraw memory withdraw = _withdraw(\n                pool,\n                range.lowerTick,\n                range.upperTick,\n                liquidity\n            );\n\n            total.fee0 += withdraw.fee0;\n            total.fee1 += withdraw.fee1;\n\n            total.burn0 += withdraw.burn0;\n            total.burn1 += withdraw.burn1;\n        }\n\n        if (burnAmount_ == ts) delete _ranges;\n\n        _applyFees(total.fee0, total.fee1);\n\n        uint256 leftOver0 = token0.balanceOf(address(this)) -\n            managerBalance0 -\n            total.burn0;\n        uint256 leftOver1 = token1.balanceOf(address(this)) -\n            managerBalance1 -\n            total.burn1;\n\n        // the proportion of user balance.\n        amount0 = FullMath.mulDiv(leftOver0, burnAmount_, ts);\n        amount1 = FullMath.mulDiv(leftOver1, burnAmount_, ts);\n\n        amount0 += total.burn0;\n        amount1 += total.burn1;\n\n        if (amount0 > 0) {\n            token0.safeTransfer(receiver_, amount0);\n        }\n\n        if (amount1 > 0) {\n            token1.safeTransfer(receiver_, amount1);\n        }\n\n        // For monitoring how much user burn LP token for getting their token back.\n        emit LPBurned(msg.sender, total.burn0, total.burn1);\n        emit LogCollectedFees(total.fee0, total.fee1);\n        emit LogBurn(receiver_, burnAmount_, amount0, amount1);\n    }\n\n    /// @notice rebalance ArrakisV2 vault's UniswapV3 positions\n    /// @param rebalanceParams_ rebalance params, containing ranges where\n    /// we need to collect tokens and ranges where we need to mint liquidity.\n    /// Also contain swap payload to changes token0/token1 proportion.\n    /// @dev only Manager contract can call this function.\n    // solhint-disable-next-line function-max-lines, code-complexity\n    function rebalance(Rebalance calldata rebalanceParams_)\n        external\n        onlyManager\n        nonReentrant\n    {\n        // Burns.\n        IUniswapV3Factory mFactory = factory;\n        IERC20 mToken0 = token0;\n        IERC20 mToken1 = token1;\n\n        {\n            Withdraw memory aggregator;\n            for (uint256 i; i < rebalanceParams_.burns.length; i++) {\n                IUniswapV3Pool pool = IUniswapV3Pool(\n                    mFactory.getPool(\n                        address(mToken0),\n                        address(mToken1),\n                        rebalanceParams_.burns[i].range.feeTier\n                    )\n                );\n\n                uint128 liquidity = Position.getLiquidityByRange(\n                    pool,\n                    address(this),\n                    rebalanceParams_.burns[i].range.lowerTick,\n                    rebalanceParams_.burns[i].range.upperTick\n                );\n\n                if (liquidity == 0) continue;\n\n                uint128 liquidityToWithdraw;\n\n                if (rebalanceParams_.burns[i].liquidity == type(uint128).max)\n                    liquidityToWithdraw = liquidity;\n                else liquidityToWithdraw = rebalanceParams_.burns[i].liquidity;\n\n                Withdraw memory withdraw = _withdraw(\n                    pool,\n                    rebalanceParams_.burns[i].range.lowerTick,\n                    rebalanceParams_.burns[i].range.upperTick,\n                    liquidityToWithdraw\n                );\n\n                if (liquidityToWithdraw == liquidity) {\n                    (bool exists, uint256 index) = Position.rangeExists(\n                        _ranges,\n                        rebalanceParams_.burns[i].range\n                    );\n                    require(exists, \"RRNE\");\n\n                    _ranges[index] = _ranges[_ranges.length - 1];\n                    _ranges.pop();\n                }\n\n                aggregator.burn0 += withdraw.burn0;\n                aggregator.burn1 += withdraw.burn1;\n\n                aggregator.fee0 += withdraw.fee0;\n                aggregator.fee1 += withdraw.fee1;\n            }\n\n            require(aggregator.burn0 >= rebalanceParams_.minBurn0, \"B0\");\n            require(aggregator.burn1 >= rebalanceParams_.minBurn1, \"B1\");\n\n            if (aggregator.fee0 > 0 || aggregator.fee1 > 0) {\n                _applyFees(aggregator.fee0, aggregator.fee1);\n\n                emit LogCollectedFees(aggregator.fee0, aggregator.fee1);\n            }\n        }\n\n        // Swap.\n        if (rebalanceParams_.swap.amountIn > 0) {\n            require(_routers.contains(rebalanceParams_.swap.router), \"NR\");\n\n            uint256 balance0Before = mToken0.balanceOf(address(this));\n            uint256 balance1Before = mToken1.balanceOf(address(this));\n\n            mToken0.safeApprove(address(rebalanceParams_.swap.router), 0);\n            mToken1.safeApprove(address(rebalanceParams_.swap.router), 0);\n\n            mToken0.safeApprove(\n                address(rebalanceParams_.swap.router),\n                balance0Before\n            );\n            mToken1.safeApprove(\n                address(rebalanceParams_.swap.router),\n                balance1Before\n            );\n\n            (bool success, ) = rebalanceParams_.swap.router.call(\n                rebalanceParams_.swap.payload\n            );\n            require(success, \"SC\");\n\n            uint256 balance0After = mToken0.balanceOf(address(this));\n            uint256 balance1After = mToken1.balanceOf(address(this));\n            if (rebalanceParams_.swap.zeroForOne) {\n                require(\n                    (balance1After >=\n                        balance1Before +\n                            rebalanceParams_.swap.expectedMinReturn) &&\n                        (balance0After >=\n                            balance0Before - rebalanceParams_.swap.amountIn),\n                    \"SF\"\n                );\n                balance0After = balance0Before - balance0After;\n                balance1After = balance1After - balance1Before;\n            } else {\n                require(\n                    (balance0After >=\n                        balance0Before +\n                            rebalanceParams_.swap.expectedMinReturn) &&\n                        (balance1After >=\n                            balance1Before - rebalanceParams_.swap.amountIn),\n                    \"SF\"\n                );\n                balance0After = balance0After - balance0Before;\n                balance1After = balance1Before - balance1After;\n            }\n            emit LogRebalance(rebalanceParams_, balance0After, balance1After);\n        } else {\n            emit LogRebalance(rebalanceParams_, 0, 0);\n        }\n\n        // Mints.\n        uint256 aggregator0;\n        uint256 aggregator1;\n        for (uint256 i; i < rebalanceParams_.mints.length; i++) {\n            (bool exists, ) = Position.rangeExists(\n                _ranges,\n                rebalanceParams_.mints[i].range\n            );\n            address pool = factory.getPool(\n                address(token0),\n                address(token1),\n                rebalanceParams_.mints[i].range.feeTier\n            );\n            if (!exists) {\n                // check that the pool exists on Uniswap V3.\n\n                require(pool != address(0), \"NUP\");\n                require(_pools.contains(pool), \"P\");\n                require(\n                    Pool.validateTickSpacing(\n                        pool,\n                        rebalanceParams_.mints[i].range\n                    ),\n                    \"RTS\"\n                );\n\n                _ranges.push(rebalanceParams_.mints[i].range);\n            }\n\n            (uint256 amt0, uint256 amt1) = IUniswapV3Pool(pool).mint(\n                address(this),\n                rebalanceParams_.mints[i].range.lowerTick,\n                rebalanceParams_.mints[i].range.upperTick,\n                rebalanceParams_.mints[i].liquidity,\n                \"\"\n            );\n            aggregator0 += amt0;\n            aggregator1 += amt1;\n        }\n        require(aggregator0 >= rebalanceParams_.minDeposit0, \"D0\");\n        require(aggregator1 >= rebalanceParams_.minDeposit1, \"D1\");\n\n        require(token0.balanceOf(address(this)) >= managerBalance0, \"MB0\");\n        require(token1.balanceOf(address(this)) >= managerBalance1, \"MB1\");\n    }\n\n    /// @notice will send manager fees to manager\n    /// @dev anyone can call this function\n    function withdrawManagerBalance() external nonReentrant {\n        _withdrawManagerBalance();\n    }\n\n    function _withdraw(\n        IUniswapV3Pool pool_,\n        int24 lowerTick_,\n        int24 upperTick_,\n        uint128 liquidity_\n    ) internal returns (Withdraw memory withdraw) {\n        (withdraw.burn0, withdraw.burn1) = pool_.burn(\n            lowerTick_,\n            upperTick_,\n            liquidity_\n        );\n\n        (uint256 collect0, uint256 collect1) = pool_.collect(\n            address(this),\n            lowerTick_,\n            upperTick_,\n            type(uint128).max,\n            type(uint128).max\n        );\n\n        withdraw.fee0 = collect0 - withdraw.burn0;\n        withdraw.fee1 = collect1 - withdraw.burn1;\n    }\n\n    function _applyFees(uint256 fee0_, uint256 fee1_) internal {\n        uint16 mManagerFeeBPS = managerFeeBPS;\n        managerBalance0 += (fee0_ * mManagerFeeBPS) / hundredPercent;\n        managerBalance1 += (fee1_ * mManagerFeeBPS) / hundredPercent;\n    }\n}"
    },
    {
      "filename": "v2-manager-templates/contracts/SimpleManager.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.13;\n\nimport {\n    IERC20,\n    SafeERC20\n} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {\n    OwnableUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {\n    EnumerableSet\n} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {\n    IUniswapV3Factory\n} from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol\";\nimport {\n    IUniswapV3Pool\n} from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport {\n    IArrakisV2,\n    Rebalance\n} from \"@arrakisfi/v2-core/contracts/interfaces/IArrakisV2.sol\";\nimport {FullMath} from \"@arrakisfi/v3-lib-0.8/contracts/FullMath.sol\";\nimport {IOwnable} from \"./interfaces/IOwnable.sol\";\nimport {IOracleWrapper} from \"./interfaces/IOracleWrapper.sol\";\nimport {IDecimals} from \"./interfaces/IDecimals.sol\";\n\nimport {hundred_percent, ten_percent} from \"./constants/CSimpleManager.sol\";\n\n/// @title SimpleManager\n/// @dev Most simple manager to manage public vault on Arrakis V2.\ncontract SimpleManager is OwnableUpgradeable {\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    struct VaultInfo {\n        IOracleWrapper oracle;\n        uint24 maxDeviation;\n        uint24 maxSlippage;\n        uint16 managerFeeBPS;\n    }\n\n    struct SetupParams {\n        address vault;\n        IOracleWrapper oracle;\n        uint24 maxDeviation;\n        uint24 maxSlippage;\n        uint16 managerFeeBPS;\n    }\n\n    IUniswapV3Factory public immutable uniFactory;\n\n    mapping(address => VaultInfo) public vaults;\n\n    EnumerableSet.AddressSet internal _operators;\n\n    event InitManagement(\n        address vault,\n        address oracle,\n        uint24 maxDeviation,\n        uint24 maxSlippage,\n        uint16 managerFeeBPS\n    );\n    event RebalanceVault(address vault, address caller);\n    event AddOperators(address[] operators);\n    event RemoveOperators(address[] operators);\n    event SetManagerFeeBPS(address[] vaults, uint16 managerFeeBPS);\n    event SetManagerFeeBPS(address vault, uint16 managerFeeBPS);\n\n    modifier requireAddressNotZero(address addr) {\n        require(addr != address(0), \"ZA\");\n        _;\n    }\n\n    constructor(\n        IUniswapV3Factory uniFactory_\n    ) requireAddressNotZero(address(uniFactory_)) {\n        uniFactory = uniFactory_;\n    }\n\n    function initialize(\n        address owner_\n    ) external initializer requireAddressNotZero(owner_) {\n        _transferOwnership(owner_);\n    }\n\n    /// @notice Initialize management\n    /// @dev onced initialize Arrakis will start to manage the initialize vault\n    /// @param params SetupParams struct containing data for manager vault\n    function initManagement(\n        SetupParams calldata params\n    ) external onlyOwner requireAddressNotZero(address(params.oracle)) {\n        require(params.maxDeviation > 0, \"DN\");\n        require(address(this) == IArrakisV2(params.vault).manager(), \"NM\");\n        require(address(vaults[params.vault].oracle) == address(0), \"AV\");\n        require(params.managerFeeBPS > 0, \"MFB\");\n        /// @dev 10% max slippage allowed by the manager.\n        require(params.maxSlippage <= ten_percent, \"MS\");\n\n        if (params.managerFeeBPS != IArrakisV2(params.vault).managerFeeBPS()) {\n            IArrakisV2(params.vault).setManagerFeeBPS(params.managerFeeBPS);\n\n            emit SetManagerFeeBPS(params.vault, params.managerFeeBPS);\n        }\n\n        vaults[params.vault] = VaultInfo({\n            oracle: params.oracle,\n            maxDeviation: params.maxDeviation,\n            maxSlippage: params.maxSlippage,\n            managerFeeBPS: params.managerFeeBPS\n        });\n\n        emit InitManagement(\n            params.vault,\n            address(params.oracle),\n            params.maxDeviation,\n            params.maxSlippage,\n            params.managerFeeBPS\n        );\n    }\n\n    /// @notice Rebalance vault\n    /// @dev only an operator of the contract Arrakis Finance can call the contract\n    /// @param vault_ address of the Arrakis V2 vault to rebalance\n    /// @param rebalanceParams_ rebalance parameters.\n    // solhint-disable-next-line function-max-lines, code-complexity\n    function rebalance(\n        address vault_,\n        Rebalance calldata rebalanceParams_\n    ) external {\n        require(_operators.contains(msg.sender), \"NO\");\n        require(\n            IArrakisV2(vault_).manager() == address(this) &&\n                address(vaults[vault_].oracle) != address(0),\n            \"NM\"\n        );\n        VaultInfo memory vaultInfo = vaults[vault_];\n\n        address token0;\n        address token1;\n        uint8 token0Decimals;\n        uint8 token1Decimals;\n        uint24[] memory checked;\n        uint256 oraclePrice;\n        uint256 increment;\n\n        uint256 mintsLength = rebalanceParams_.mints.length;\n\n        if (mintsLength > 0 || rebalanceParams_.swap.amountIn > 0) {\n            token0 = address(IArrakisV2(vault_).token0());\n            token1 = address(IArrakisV2(vault_).token1());\n            token0Decimals = IDecimals(token0).decimals();\n            token1Decimals = IDecimals(token1).decimals();\n        }\n\n        if (mintsLength > 0) {\n            checked = new uint24[](mintsLength);\n            oraclePrice = vaultInfo.oracle.getPrice0();\n        }\n\n        for (uint256 i; i < mintsLength; ++i) {\n            if (\n                _includes(\n                    rebalanceParams_.mints[i].range.feeTier,\n                    checked,\n                    increment\n                )\n            ) continue;\n\n            IUniswapV3Pool pool = IUniswapV3Pool(\n                _getPool(\n                    token0,\n                    token1,\n                    rebalanceParams_.mints[i].range.feeTier\n                )\n            );\n\n            uint256 sqrtPriceX96;\n\n            (sqrtPriceX96, , , , , , ) = pool.slot0();\n\n            uint256 poolPrice = FullMath.mulDiv(\n                sqrtPriceX96 * sqrtPriceX96,\n                10 ** token0Decimals,\n                2 ** 192\n            );\n\n            _checkDeviation(\n                poolPrice,\n                oraclePrice,\n                vaultInfo.maxDeviation,\n                token1Decimals\n            );\n\n            checked[increment] = rebalanceParams_.mints[i].range.feeTier;\n            increment++;\n        }\n\n        // check expectedMinReturn on rebalance swap against oracle\n        if (rebalanceParams_.swap.amountIn > 0) {\n            _checkMinReturn(\n                rebalanceParams_,\n                vaultInfo.oracle,\n                vaultInfo.maxSlippage,\n                token0Decimals,\n                token1Decimals\n            );\n        }\n\n        IArrakisV2(vault_).rebalance(rebalanceParams_);\n\n        emit RebalanceVault(vault_, msg.sender);\n    }\n\n    /// @notice Withdraw and Collect Fees generated by vaults on Uni v3\n    /// @dev only the owner of the contract Arrakis Finance can call the contract\n    /// @param vaults_ array of vaults where to collect fees\n    /// @param tokens_ array of tokens where to withdraw fees\n    /// @param target receiver of fees collection\n    // solhint-disable-next-line code-complexity\n    function withdrawAndCollectFees(\n        IArrakisV2[] calldata vaults_,\n        IERC20[] calldata tokens_,\n        address target\n    ) external onlyOwner requireAddressNotZero(target) {\n        uint256 vaultsLength = vaults_.length;\n\n        // #region withdraw from vaults.\n\n        for (uint256 i; i < vaultsLength; ++i) {\n            require(\n                vaults_[i].manager() == address(this) &&\n                    address(vaults[address(vaults_[i])].oracle) != address(0),\n                \"NM\"\n            );\n\n            vaults_[i].withdrawManagerBalance();\n        }\n\n        // #endregion withdraw from vaults.\n\n        // #region transfer token to target.\n\n        uint256 tokensLength = tokens_.length;\n        for (uint256 i; i < tokensLength; ++i) {\n            uint256 balance = IERC20(tokens_[i]).balanceOf(address(this));\n            if (balance > 0) IERC20(tokens_[i]).safeTransfer(target, balance);\n        }\n\n        // #endregion transfer token to target.\n    }\n\n    /// @notice Set manager fee bps as manager\n    /// @dev only the owner of simple manager call this function\n    /// @param vaults_ array of vaults where to update manager fee bps\n    /// @param managerFeeBPS_ new value of manager fee bps\n    // solhint-disable-next-line code-complexity\n    function setManagerFee(\n        address[] calldata vaults_,\n        uint16 managerFeeBPS_\n    ) external onlyOwner {\n        uint256 vaultsLength = vaults_.length;\n        for (uint256 i; i < vaultsLength; ++i) {\n            require(address(vaults[vaults_[i]].oracle) != address(0), \"NM\");\n            require(vaults[vaults_[i]].managerFeeBPS != managerFeeBPS_, \"NU\");\n            vaults[vaults_[i]].managerFeeBPS = managerFeeBPS_;\n\n            IArrakisV2(vaults_[i]).setManagerFeeBPS(managerFeeBPS_);\n        }\n\n        emit SetManagerFeeBPS(vaults_, managerFeeBPS_);\n    }\n\n    /// @notice for adding operators\n    /// @param operators_ list of operators to add\n    /// @dev only callable by owner\n    function addOperators(address[] calldata operators_) external onlyOwner {\n        uint256 operatorsLength = operators_.length;\n        require(operatorsLength > 0, \"ZO\");\n        for (uint256 i; i < operatorsLength; ++i) {\n            require(\n                operators_[i] != address(0) && _operators.add(operators_[i]),\n                \"O\"\n            );\n        }\n\n        emit AddOperators(operators_);\n    }\n\n    /// @notice for removing operators\n    /// @param operators_ list of operators to remove\n    /// @dev only callable by owner\n    function removeOperators(address[] memory operators_) external onlyOwner {\n        uint256 operatorsLength = operators_.length;\n        require(operatorsLength > 0, \"ZO\");\n        for (uint256 i; i < operatorsLength; ++i) {\n            require(_operators.remove(operators_[i]), \"NO\");\n        }\n\n        emit RemoveOperators(operators_);\n    }\n\n    /// @notice get list of operators\n    /// @return operators array of address representing operators\n    function getOperators() external view returns (address[] memory) {\n        return _operators.values();\n    }\n\n    /// @notice check if it's operators\n    /// @param operator_ address to check if it's an operator\n    /// @return return true if inputed address is an operator\n    /// otherwise return false\n    function isOperator(address operator_) external view returns (bool) {\n        return _operators.contains(operator_);\n    }\n\n    function _checkMinReturn(\n        Rebalance memory rebalanceParams_,\n        IOracleWrapper oracle_,\n        uint24 maxSlippage,\n        uint8 decimals0,\n        uint8 decimals1\n    ) internal view {\n        if (rebalanceParams_.swap.zeroForOne) {\n            require(\n                FullMath.mulDiv(\n                    rebalanceParams_.swap.expectedMinReturn,\n                    10 ** decimals0,\n                    rebalanceParams_.swap.amountIn\n                ) >\n                    FullMath.mulDiv(\n                        oracle_.getPrice0(),\n                        hundred_percent - maxSlippage,\n                        hundred_percent\n                    ),\n                \"S0\"\n            );\n        } else {\n            require(\n                FullMath.mulDiv(\n                    rebalanceParams_.swap.expectedMinReturn,\n                    10 ** decimals1,\n                    rebalanceParams_.swap.amountIn\n                ) >\n                    FullMath.mulDiv(\n                        oracle_.getPrice1(),\n                        hundred_percent - maxSlippage,\n                        hundred_percent\n                    ),\n                \"S1\"\n            );\n        }\n    }\n\n    function _getPool(\n        address token0,\n        address token1,\n        uint24 feeTier\n    ) internal view returns (address pool) {\n        pool = uniFactory.getPool(token0, token1, feeTier);\n\n        require(pool != address(0), \"NP\");\n    }\n\n    function _checkDeviation(\n        uint256 currentPrice_,\n        uint256 oraclePrice_,\n        uint24 maxDeviation_,\n        uint8 priceDecimals_\n    ) internal pure {\n        uint256 deviation = FullMath.mulDiv(\n            FullMath.mulDiv(\n                currentPrice_ > oraclePrice_\n                    ? currentPrice_ - oraclePrice_\n                    : oraclePrice_ - currentPrice_,\n                10 ** priceDecimals_,\n                oraclePrice_\n            ),\n            hundred_percent,\n            10 ** priceDecimals_\n        );\n\n        require(deviation <= maxDeviation_, \"maxDeviation\");\n    }\n\n    function _includes(\n        uint24 target,\n        uint24[] memory set,\n        uint256 upperIndex\n    ) internal pure returns (bool) {\n        for (uint256 j; j < upperIndex; j++) {\n            if (set[j] == target) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}"
    }
  ]
}