{
  "Title": "Recover Function Can Stall Associated Gauge",
  "Content": "The `owner` of a `GaugeExtraRewarder` can use the [`recoverERC20`](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/GaugeExtraRewarder.sol#L154) function to move any ERC20 token from the contract. However, if an amount of the reward token is removed while there are active users, deposit and withdraw operations in the associated gauge contract [can fail on the reward transfers](https://github.com/ThenafiBNB/THENA-Contracts/blob/2bb84cf6bb429e9bac8ac8464f4546da855ef4ca/contracts/GaugeExtraRewarder.sol#L79) due to low balance.\n\n\nConsider excluding `rewardToken` when calling function `recoverERC20`, so as to restrict the owner to only be able to recover funds that have mistakenly been sent to the contract. If the reward token needs to remain recoverable for emergency cases, consider adding a `require` statement to ensure that the `GaugeExtraRewarder` contract is stopped before recovering the reward token from the contract.\n\n\n***Update:** Resolved in [pull request #9](https://github.com/ThenafiBNB/THENA-Contracts/pull/9) at commit [748e153](https://github.com/ThenafiBNB/THENA-Contracts/pull/9/commits/748e1534c826848864ef6f44c9026e970b996805) and [pull request #12](https://github.com/ThenafiBNB/THENA-Contracts/pull/12) at commit [7693167](https://github.com/ThenafiBNB/THENA-Contracts/pull/12/commits/7693167e35395ed202cfcb177f42902832539be2). For the reward token, the owner can only recover up to the amount that has not yet been accounted for distribution. The Retro-Thena team stated:*\n\n\n\n> *The `owner` of the `GaugeExtraRewarder` contract is either the project that provides the extra reward amount or the Thena-Retro team.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/GaugeExtraRewarder.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./libraries/SignedSafeMath.sol\";\n\n\ninterface IRewarder {\n    function onReward(uint256 pid, address user, address recipient, uint256 lqdrAmount, uint256 newLpAmount) external;\n    function pendingTokens(uint256 pid, address user, uint256 lqdrAmount) external view returns (IERC20[] memory, uint256[] memory);\n}\n\ninterface IGauge {\n    function TOKEN() external view returns(address);\n}\n\n\ncontract GaugeExtraRewarder is Ownable {\n\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    bool public stop = false;\n\n    IERC20 public immutable rewardToken;\n\n    /// @notice Info of each user.\n    struct UserInfo {\n        uint256 amount;\n        int256 rewardDebt;\n    }\n\n    /// @notice Struct of pool info\n   \n    struct PoolInfo {\n        uint256 accRewardPerShare;\n        uint256 lastRewardTime;\n    }\n\n    /// @notice pool info\n    PoolInfo public poolInfo;\n\n    /// @notice Info of each user that stakes tokens.\n    mapping(address => UserInfo) public userInfo;\n\n    uint public lastDistributedTime;\n    uint public rewardPerSecond;\n    uint public distributePeriod = 86400 * 7;\n    uint public ACC_TOKEN_PRECISION = 1e12;\n\n\n    address private immutable GAUGE;\n\n    event LogOnReward(address indexed user, uint256 indexed pid, uint256 amount, address indexed to);\n\n    constructor (IERC20 _rewardToken, address gauge) {\n        rewardToken = _rewardToken;\n        poolInfo = PoolInfo({\n            lastRewardTime: block.timestamp,\n            accRewardPerShare: 0\n        });\n        GAUGE = gauge;\n    }\n\n\n    function onReward(uint256 /*pid*/, address _user, address to, uint256 /*extraData*/, uint256 lpToken) onlyGauge external {\n        if(stop) return;\n        PoolInfo memory pool = updatePool();\n        UserInfo storage user = userInfo[_user];\n        uint256 pending;\n        uint256 accRewardPerShare = pool.accRewardPerShare;\n        if (user.amount > 0) {\n            pending = int256( user.amount.mul(accRewardPerShare) / ACC_TOKEN_PRECISION ).sub(user.rewardDebt).toUInt256();\n            rewardToken.safeTransfer(to, pending);\n        }\n        user.amount = lpToken;\n        user.rewardDebt = int256(lpToken.mul(pool.accRewardPerShare) / ACC_TOKEN_PRECISION);\n    }\n\n\n    /// @notice View function to see pending WBNB on frontend.\n    /// @param _user Address of user.\n    /// @return pending rewardToken reward for a given user.\n    function pendingReward(address _user) external view returns (uint256 pending){\n        PoolInfo memory pool = poolInfo;\n        UserInfo storage user = userInfo[_user];\n        uint256 accRewardPerShare = pool.accRewardPerShare;\n        uint256 lpSupply = IERC20(IGauge(GAUGE).TOKEN()).balanceOf(GAUGE);\n\n        if (block.timestamp > pool.lastRewardTime && lpSupply != 0) {\n            uint256 time = block.timestamp.sub(pool.lastRewardTime);\n            uint256 reward = time.mul(rewardPerSecond);\n            accRewardPerShare = accRewardPerShare.add( reward.mul(ACC_TOKEN_PRECISION) / lpSupply );\n        }\n        pending = int256( user.amount.mul(accRewardPerShare) / ACC_TOKEN_PRECISION ).sub(user.rewardDebt).toUInt256();\n    }\n\n\n    modifier onlyGauge {\n        require(msg.sender == GAUGE,\"!GAUGE\");\n        _;\n    }\n\n\n\n    /// @notice Sets the reward per second to be distributed. Can only be called by the owner.\n    /// @param _rewardPerSecond The amount of Reward to be distributed per second.\n    function setRewardPerSecond(uint256 _rewardPerSecond) public onlyOwner {\n        updatePool();\n        rewardPerSecond = _rewardPerSecond;\n    }\n\n\n    function setDistributionRate(uint256 amount) public onlyOwner {\n        updatePool();\n        require(IERC20(rewardToken).balanceOf(address(this)) >= amount);\n        uint256 notDistributed;\n        if (lastDistributedTime > 0 && block.timestamp < lastDistributedTime) {\n            uint256 timeLeft = lastDistributedTime.sub(block.timestamp);\n            notDistributed = rewardPerSecond.mul(timeLeft);\n        }\n\n        amount = amount.add(notDistributed);\n        uint256 _rewardPerSecond = amount.div(distributePeriod);\n        rewardPerSecond = _rewardPerSecond;\n        lastDistributedTime = block.timestamp.add(distributePeriod);\n    }\n\n\n\n    /// @notice Update reward variables of the given pool.\n    /// @return pool Returns the pool that was updated.\n    function updatePool() public returns (PoolInfo memory pool) {\n        pool = poolInfo;\n\n        if (block.timestamp > pool.lastRewardTime) {\n            uint256 lpSupply = IERC20(IGauge(GAUGE).TOKEN()).balanceOf(GAUGE);\n            if (lpSupply > 0) {\n                uint256 time = block.timestamp.sub(pool.lastRewardTime);\n                uint256 reward = time.mul(rewardPerSecond);\n                pool.accRewardPerShare = pool.accRewardPerShare.add( reward.mul(ACC_TOKEN_PRECISION).div(lpSupply) );\n            }\n            pool.lastRewardTime = block.timestamp;\n            poolInfo = pool;\n        }\n    }\n\n\n    function recoverERC20(uint amount, address token) external onlyOwner {\n        require(amount > 0);\n        require(token != address(0));\n        require(IERC20(token).balanceOf(address(this)) >= amount);\n        IERC20(token).safeTransfer(msg.sender, amount);\n    }\n\n    function stopRewarder() external onlyOwner {\n        stop = true;\n    }\n\n    function startRewarder() external onlyOwner {\n        stop = false;\n    }\n\n\n}"
    }
  ]
}