{
  "Title": "M-4: Execution Layer rewards are lost",
  "Content": "# Issue M-4: Execution Layer rewards are lost \n\nSource: https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/174 \n\n## Found by \nfnanni\n## Summary\n\nAccording to Rio Network Docs: \"The Reward Distributor contract ([RioLRTRewardDistributor](https://github.com/contracts-and-tooling/source-code/restaking/riolrtrewarddistributor)) has the ability to [receive](https://github.com/contracts-and-tooling/source-code/restaking/riolrtrewarddistributor#receive) ETH via the Ethereum Execution Layer or EigenPod rewards and then distribute those rewards\". However, this is only true for EigenPod rewards. Execution Layer rewards are not accounted for and lost.\n\n## Vulnerability Detail\n\nExecution Layer rewards are not distributed through plain ETH transfers. Instead the balance of the block proposer fee recipient's address is directly updated. If the fee recipient getting the EL rewards is a smart contract, this means that the fallback/receive function is not called. Actually, a smart contract could receive EL rewards even if these functions are not defined.\n\nThe [RioLRTRewardDistributor](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/4f01e065c1ed346875cf5b05d2b43e0bcdb4c849/rio-sherlock-audit/contracts/restaking/RioLRTRewardDistributor.sol) contract relies solely on its [receive](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/4f01e065c1ed346875cf5b05d2b43e0bcdb4c849/rio-sherlock-audit/contracts/restaking/RioLRTRewardDistributor.sol#L82-L94) function to distribute rewards. EL rewards which don't trigger this function are not accounted in the smart contract and there is no way of distributing them.\n\n## Impact\n\nExecution Layer rewards are lost.\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAdd a method to manually distribute EL rewards. For example:\n\n```solidity\n    function distributeRemainingBalance() external {\n        uint256 value = address(this).balance;\n\n        uint256 treasuryShare = value * treasuryETHValidatorRewardShareBPS / MAX_BPS;\n        uint256 operatorShare = value * operatorETHValidatorRewardShareBPS / MAX_BPS;\n        uint256 poolShare = value - treasuryShare - operatorShare;\n\n        if (treasuryShare > 0) treasury.transferETH(treasuryShare);\n        if (operatorShare > 0) operatorRewardPool.transferETH(operatorShare);\n        if (poolShare > 0) address(depositPool()).transferETH(poolShare);\n\n        emit ETHValidatorRewardsDistributed(treasuryShare, operatorShare, poolShare);\n    }\n```\n\n\n\n## Discussion\n\n**nevillehuang**\n\nrequest poc\n\nI need more information/resources for this issue so need to facilitate discussion.\n\n**sherlock-admin3**\n\nPoC requested from @fnanni-0\n\nRequests remaining: **6**\n\n**fnanni-0**\n\n@nevillehuang I forgot to link to the Rio docs: https://docs.rio.network/rio-architecture/deposits-and-withdraws/reward-distributor. Can we get @solimander input here? Reading this issue again, there is a chance I misunderstood the docs. Is the Reward Distributor contract expected to be able to receive Execution Layer rewards, i.e. be set as blocks fee_recipient address?\n\n#### If the answer is yes:\n\nFrom the [Solidity docs](https://docs.soliditylang.org/en/latest/contracts.html#receive-ether-function): \"A contract without a receive Ether function can receive Ether as a recipient of a coinbase transaction\". The recipient of a coinbase transaction post-merge is the address defined by the block proposer in the `fee_recipient` field of the [Execution Payload](https://github.com/ethereum/consensus-specs/blob/dev/specs/bellatrix/beacon-chain.md#executionpayload). According to https://eth2book.info/capella/annotated-spec/ : \n\n> fee_recipient is the Ethereum account address that will receive the unburnt portion of the transaction fees (the priority fees). This has been called various things at various times: the original Yellow Paper calls it beneficiary; [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559) calls it author. In any case, the proposer of the block sets the fee_recipient to specify where the appropriate transaction fees for the block are to be sent. Under proof of work this was the same address as the COINBASE address that received the block reward. Under proof of stake, the block reward is credited to the validator's beacon chain balance, and **the transaction fees are credited to the fee_recipient Ethereum address**.\n\nAs an example go to etherscan and select any block recently produced. Check the fee recipient address. Check how its ETH balance is updated (\"credited\") at every transaction included in the block even though there is no explicit transaction to the fee recipient address (for example, balance update of beaverbuild [here](https://etherscan.io/tx/0xd6460ce006ff7d88d361fd2b08555e5e033208c187a16407f3a3bff304dd982d#statechange)).\n\n**solimander**\n\nOur operators will run MEV-Boost, which sets the fee recipient to the builder, who then transfers rewards to the proposer, which triggers the receive function.\n\nHowever, it seems worth adding a function to manually push rewards just in case. How does that affect severity here?\n\n**fnanni-0**\n\n@solimander I have a few questions:\n\n1. If mev-boost isn't available for a given block (for example there's a timeout), doesn't mev-boost fallback to a validator's local block proposal? See [this comment](https://github.com/flashbots/mev-boost/issues/222#issuecomment-1202401149) about Teku's client for instance (or Teku's [docs](https://docs.teku.consensys.io/concepts/builder-network#mev-boost)). In such case, fee_recipient would be the proposer address, not the builder's address.\n2. The flow you described is the current standarized payment method for mev-boost. I wonder if this could change or if there are other builder networks handling this differently. If so, I think it's risky to assume that the proposer address will always receive rewards through direct transfers.\n3. Isn't it likely that Ethereum upgrades in the future to better support Proposer-Builder Separation? If this happens, there's a chance the proposer address gets credited, not triggering the receive function.\n\n**solimander**\n\n> If mev-boost isn't available for a given block (for example there's a timeout), doesn't mev-boost fallback to a validator's local block proposal? See https://github.com/flashbots/mev-boost/issues/222#issuecomment-1202401149 about Teku's client for instance (or Teku's [docs](https://docs.teku.consensys.io/concepts/builder-network#mev-boost)). In such case, fee_recipient would be the proposer address, not the builder's address.\n\nI'm unsure, but that'd make sense. I'll be adding a function to manually split and push rewards regardless.\n\n**nevillehuang**\n\nThis issue seems out of scope and hinges on external admin integrations. But leaving open for escalation period\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in PR/commit https://github.com/rio-org/rio-sherlock-audit/pull/6.\n\n**10xhash**\n\nEscalate\n\nThe info that the RioLRTRewardDistributor is meant to receive the execution layer rewards is not mentioned anywhere. The mentioned docs state `The Reward Distributor contract (RioLRTRewardDistributor) has the ability to receive ETH via the Ethereum Execution Layer or EigenPod rewards and then distribute those rewards`, which only indicates that the RioLRTRewardDistributor should be able to receive ETH which it does. \n\n**sherlock-admin2**\n\n> Escalate\n> \n> The info that the RioLRTRewardDistributor is meant to receive the execution layer rewards is not mentioned anywhere. The mentioned docs state `The Reward Distributor contract (RioLRTRewardDistributor) has the ability to receive ETH via the Ethereum Execution Layer or EigenPod rewards and then distribute those rewards`, which only indicates that the RioLRTRewardDistributor should be able to receive ETH which it does. \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**fnanni-0**\n\nI disagree. The Reward Distributor is expected to receive and distribute rewards. “the ability to receive ETH via the Ethereum Execution Layer or EigenPod rewards”, in this context, seems to mean Execution Layer rewards, which the sponsor confirmed. EL rewards are credited, not transferred, and therefore cannot be currently distributed.\n\nFollowing up on the prior discussion with the sponsor, regarding operators' obligation to use mev-boost: builders replace the proposer's fee recipient address with their own and directly transfer funds to the former, triggering the receive function. mev-boost is not mentioned in Rio’s docs, but still EL rewards will sometimes be lost:\n\n1. if the builder network becomes unavailable through the configured relays for whatever reason, validator clients fallback to local block production in order to avoid missing a block proposal.\n1. mev-boost accepts a minimum bid parameter (see [this](https://github.com/flashbots/mev-boost/pull/274) and [this](https://github.com/flashbots/mev-boost?tab=readme-ov-file#setting-a-minimum-bid-value-with--min-bid)). If set, the process will fallback to local block production every time bids from the builder network don’t surpass this threshold.\n1. clients give the option to fallback to local block production when the builder bid represents less than X% of the locally produced block profits. See for example Teku [builder-bid-compare-factor](https://docs.teku.consensys.io/reference/cli#builder-bid-compare-factor), Lighthouse [builder-boost-factor](https://lighthouse-book.sigmaprime.io/builders.html#how-to-connect-to-a-builder) or Prysm [local-block-value-boost](https://docs.prylabs.network/docs/advanced/builder#prioritizing-local-blocks). \n\nFor operators aiming for optimal performance, settings 1, 2, and 3 are crucial. RioLRTRewardDistributor assumes the fee recipient role in these instances, causing priority fees and MEV funds to get stuck.\n\n**solimander**\n\nWe only mention MEV-Boost in [our operator docs](https://docs-operators.rio.network/post-approval-requirements#mev-boost).\n\nValid in that execution layer rewards would be stuck in the fallback case.\n\n**nevillehuang**\n\nI believe @10xhash is correct, this seems to be out of scope and invalid based on the following sherlock [rule](https://docs.sherlock.xyz/audits/judging/judging#vii.-list-of-issue-categories-that-are-not-considered-valid) unless otherwise stated in documentation, which is not present.\n\n> 14. Loss of airdrops or liquidity fees or any other rewards that are not part of the original protocol design is not considered a valid high/medium. [Example](https://github.com/sherlock-audit/2023-02-openq-judging/issues/323)\n\n**fnanni-0**\n\n@nevillehuang could you elaborate on why do you consider EL rewards sent to RioLRTRewardDistributor `rewards that are not part of the original protocol design`?\n\nThe documentation ([here](https://docs.rio.network/rio-architecture/deposits-and-withdraws/reward-distributor) and [here](https://docs.rio.network/rio-network/liquid-restaking-tokens/rewards)) mentions that EL rewards are expected and RioLRTRewardDistributor must handle them. In addition, it is stated in the [operators docs](https://docs-operators.rio.network/post-approval-requirements#mev-boost) that whitelisted operators must make sure this happens (otherwise I guess the RioDAO would delist operators who disobey?). Third, go to the FAQs section in https://goerli.rio.network/ and you will see: \n\n> ### How often do rewards compound/turnover?\n> Restaking [rewards](https://docs.rio.network/rio-network/liquid-restaking-tokens/rewards) (less fees) are [deposited](https://docs.rio.network/rio-architecture/deposits-and-withdraws#deposit-workflow) into the LRT’s deposit pool when the [daily epoch ends](https://docs.rio.network/rio-architecture/deposits-and-withdraws/deposit-pool-rebalancer). These rewards are based on the Ethereum consensus layer -->**and the execution layer rewards**<--.\n\nFurthermore, rewards expected to be received by RioLRTRewardDistributor (EL rewards included) [are distributed to the treasury, the operatorRewardPool and the depositPool](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/4f01e065c1ed346875cf5b05d2b43e0bcdb4c849/rio-sherlock-audit/contracts/restaking/RioLRTRewardDistributor.sol#L89-L91). This means that EL rewards become:\n\n1. profit for RioDAO.\n2. profit for operators.\n3. yield for the Rio protocol and potentially financial source of new validators that will allow even more yield into Rio. This seems like an important feature and incentive for users staking in Rio.\n\nThere are many places in which it is explicitly or implicitly pointed at the fact that Execution Layer rewards are part of Rio's protocol rewards and the sponsor confirmed this. \n\n**nevillehuang**\n\n@fnanni-0 You are correct, thanks for pointing me to the right resource. I believe this issue is valid and should remain as it is.\n\n**Czar102**\n\nI believe that Execution Layer rewards are a part of the initial design, but I don't see why would the `RioLRTRewardDistributor` be thought to be able to receive these rewards directly. I will quote the same source as above:\n> Restaking [rewards](https://docs.rio.network/rio-network/liquid-restaking-tokens/rewards) (less fees) are [**deposited**](https://docs.rio.network/rio-architecture/deposits-and-withdraws#deposit-workflow) into the LRT’s deposit pool when the [daily epoch ends](https://docs.rio.network/rio-architecture/deposits-and-withdraws/deposit-pool-rebalancer). These rewards are based on the Ethereum consensus layer and the execution layer rewards.\n\nPlease note that a word \"depositing\" is used, which implies that the deposit logic is triggered during these operations, and the balance isn't just incremented.\n\nAside from that, the MEV Bosst is [mentioned in the docs](https://docs.rio.network/rio-network/liquid-restaking-tokens/rewards#execution-layer-rewards):\n> To obtain the Maximal Extractable Value (MEV) from a block, the block builder can choose to auction block space to block builders in a competitive marketplace with software like MEV boost, further increasing potential rewards. \n\nIn order to keep this issue valid, there needs to be an expectation of `RioLRTRewardDistributor` to receive the Execution Layer rewards directly. @fnanni-0 can you let me know where is it communicated?\n\n**nevillehuang**\n\n@Czar102 Agree with your reasoning, I think it was not explicitly stated that execution layer rewards are expected to be received directly, as mentioned [here](https://discord.com/channels/812037309376495636/1209514827442167839/1213518776583331901)\n\n**fnanni-0**\n\n@Czar102 I think [this](https://docs-operators.rio.network/post-approval-requirements#execution-layer-rewards-configuration) is where it's the clearest. The Reward Distributor contract is mentioned and the instruction to set it as the fee recipient means that it is expected to receive execution layer rewards directly. \n\n> ## Post-Approval Requirements\n> Once approved by the RioDAO, please complete the following steps:\n> ### Ethereum Validators\n> #### Execution Layer Rewards Configuration\n> Set the fee recipient for your validators to the Reward Distributor contract. This is NOT the same as the [Withdrawal Credentials](https://docs-operators.rio.network/validator-keys#withdrawal-credentials) address.\n\nNote that even with mev-boost as a requirement (which the docs don't seem to say it's a must), setting fee recipient to the Reward Distributor contract means that in fallback cases it will receive EL rewards directly, as explain in my previous [comment](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/174#issuecomment-2025915385).\n\nIn case it matters, the documentation provided in the contest readme (https://docs.rio.network/) references the operator docs, quoted above, in the section `CONTRACTS AND TOOLING` --> `Tooling` --> `Rio Operator Guide`.\n\nRegarding,\n\n> but I don't see why would the `RioLRTRewardDistributor` be thought to be able to receive these rewards directly\n\nI guess the operator docs are enough, but let me elaborate a bit more. EigenLayer doesn't handle execution layer rewards, so it's evident that they must be handled differently. There are no other contracts in Rio protocol for this purpose except for RioLRTRewardDistributor and nowhere it is explained that there could be a special method for handling EL rewards before sending them to RioLRTRewardDistributor. The most straight forward, intuitive way is to simply send the rewards directly. \n\nHere are all the other chunks of documentation and comments linked in this discussion that seem to me to clearly state that EL rewards are or could be received directly by the `RioLRTRewardDistributor`:\n\n> The Reward Distributor contract ([RioLRTRewardDistributor](https://docs.rio.network/contracts-and-tooling/source-code/restaking/riolrtrewarddistributor)) has the ability to [receive](https://docs.rio.network/contracts-and-tooling/source-code/restaking/riolrtrewarddistributor#receive) ETH via the Ethereum Execution Layer or EigenPod rewards and then distribute those rewards.\n\n> ETH staking consensus rewards are claimed from EigenPods [...]. ETH staking execution rewards flow directly through the reward distributor. \n\n> ## Rewards\n> Participating in restaking generates rewards in a number of forms outlined below. When rewards are received by the [RewardDistributor](https://docs.rio.network/contracts-and-tooling/source-code/restaking/riolrtrewarddistributor) contract in a form other than ETH, [...].\n> ### EigenLayer Rewards and EigenLayer Points\n> [...]\n> ### Native Staking Rewards\n> [...]\n> #### Consensus Layer Rewards\n> [...]\n> #### --> Execution Layer Rewards <--\n> [...]\n\n> Restaking [rewards](https://docs.rio.network/rio-network/liquid-restaking-tokens/rewards) [quoted above] (less fees) are [deposited](https://docs.rio.network/rio-architecture/deposits-and-withdraws#deposit-workflow) into the LRT’s deposit pool when the [daily epoch ends](https://docs.rio.network/rio-architecture/deposits-and-withdraws/deposit-pool-rebalancer). These rewards are based on the Ethereum consensus layer and the execution layer rewards.\n\nRegarding the last quote, you wrote: \n\n> Please note that a word \"depositing\" is used, which implies that the deposit logic is triggered during these operations, and the balance isn't just incremented.\n\nYou are right in the sense that the deposit logic is referenced, but I think the link might be incorrect. \"deposited when the daily epoch ends\" is contradictory, since the deposit flow and the rebalance flow are two separate things. But \"depositing\" is use in the context of the Deposit Pool contract receiving rewards which is well documented, because the Reward Distributor contract sends ETH to it which can be withdrawn/staked during rebalancing.\n\n**Czar102**\n\nGreat points, @fnanni-0.\n\n@nevillehuang I think the message you quoted actually supports @fnanni-0's point, am I understanding correctly?\n> ETH staking execution rewards flow directly through the reward distributor.\n\n@fnanni-0 does Rio have control over when the Execution Layer Rewards are sent if they are sent directly? I think lack of my knowledge about it didn't allow me to fully understand the meaning of the last quote from the docs about daily deposits of rewards.\n\n**fnanni-0**\n\n> @fnanni-0 does Rio have control over when the Execution Layer Rewards are sent if they are sent directly?\n\n@Czar102 I don't think so. They are sent to the Reward Distributor directly when a validator controlled by an operator registered in Rio is selected as block proposer and one of [these three scenarios](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/174#issuecomment-2025915385) happens (or if mev-boost is not used). Does this answer your question?\n\n> about daily deposits of rewards\n\nIn case it wasn't clear, the Deposit Pool should receive the rewards from the Reward Distributor at any time, independently of the rebalance execution, like all deposits. It's the rebalancing of these deposits (rewards included) that happens daily. Anyway, this doesn't seem very relevant here.\n\n\n**Czar102**\n\nI see, thank you for this elaboration. It seems that this is indeed a valid concern.\n\n@solimander @nevillehuang @10xhash @mstpr if you still diagree, please elaborate what are we misunderstanding.\n\nPlanning to reject the escalation and leave the issue as is.\n\n**Czar102**\n\nResult:\nMedium\nUnique\n\n**sherlock-admin3**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [10xhash](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/174/#issuecomment-2024334137): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/176",
  "Code": [
    {
      "filename": "specs/bellatrix/beacon-chain.md",
      "content": "# Bellatrix -- The Beacon Chain\n\n## Table of contents\n\n<!-- TOC -->\n<!-- START doctoc generated TOC please keep comment here to allow auto update -->\n<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->\n\n- [Introduction](#introduction)\n- [Custom types](#custom-types)\n- [Preset](#preset)\n  - [Execution](#execution)\n  - [Updated penalty values](#updated-penalty-values)\n- [Configuration](#configuration)\n  - [Transition settings](#transition-settings)\n- [Containers](#containers)\n  - [Extended containers](#extended-containers)\n    - [`BeaconBlockBody`](#beaconblockbody)\n    - [`BeaconState`](#beaconstate)\n  - [New containers](#new-containers)\n    - [`ExecutionPayload`](#executionpayload)\n    - [`ExecutionPayloadHeader`](#executionpayloadheader)\n- [Helper functions](#helper-functions)\n  - [Predicates](#predicates)\n    - [`is_merge_transition_complete`](#is_merge_transition_complete)\n    - [`is_merge_transition_block`](#is_merge_transition_block)\n    - [`is_execution_enabled`](#is_execution_enabled)\n  - [Misc](#misc)\n    - [`compute_timestamp_at_slot`](#compute_timestamp_at_slot)\n  - [Beacon state accessors](#beacon-state-accessors)\n    - [Modified `get_inactivity_penalty_deltas`](#modified-get_inactivity_penalty_deltas)\n  - [Beacon state mutators](#beacon-state-mutators)\n    - [Modified `slash_validator`](#modified-slash_validator)\n- [Beacon chain state transition function](#beacon-chain-state-transition-function)\n  - [Execution engine](#execution-engine)\n    - [Request data](#request-data)\n      - [`NewPayloadRequest`](#newpayloadrequest)\n    - [Engine APIs](#engine-apis)\n    - [`notify_new_payload`](#notify_new_payload)\n    - [`is_valid_block_hash`](#is_valid_block_hash)\n    - [`verify_and_notify_new_payload`](#verify_and_notify_new_payload)\n  - [Block processing](#block-processing)\n    - [Execution payload](#execution-payload)\n      - [`process_execution_payload`](#process_execution_payload)\n  - [Epoch processing](#epoch-processing)\n    - [Slashings](#slashings)\n- [Testing](#testing)\n\n<!-- END doctoc generated TOC please keep comment here to allow auto update -->\n<!-- /TOC -->\n\n## Introduction\n\nThis upgrade adds transaction execution to the beacon chain as part of Bellatrix upgrade.\n\nAdditionally, this upgrade introduces the following minor changes:\n* Penalty parameter updates to their planned maximally punitive values\n\n## Custom types\n\n*Note*: The `Transaction` type is a stub which is not final.\n\n| Name | SSZ equivalent | Description |\n| - | - | - |\n| `Transaction` | `ByteList[MAX_BYTES_PER_TRANSACTION]` | either a [typed transaction envelope](https://eips.ethereum.org/EIPS/eip-2718#opaque-byte-array-rather-than-an-rlp-array) or a legacy transaction|\n| `ExecutionAddress` | `Bytes20` | Address of account on the execution layer |\n\n## Preset\n\n### Execution\n\n| Name | Value |\n| - | - |\n| `MAX_BYTES_PER_TRANSACTION` | `uint64(2**30)` (= 1,073,741,824) |\n| `MAX_TRANSACTIONS_PER_PAYLOAD` | `uint64(2**20)` (= 1,048,576) |\n| `BYTES_PER_LOGS_BLOOM` | `uint64(2**8)` (= 256) |\n| `MAX_EXTRA_DATA_BYTES` | `2**5` (= 32) |\n\n### Updated penalty values\n\nBellatrix updates a few configuration values to move penalty parameters to their final, maximum security values.\n\n*Note*: The spec does *not* override previous configuration values but instead creates new values and replaces usage throughout.\n\n| Name | Value |\n| - | - |\n| `INACTIVITY_PENALTY_QUOTIENT_BELLATRIX` | `uint64(2**24)` (= 16,777,216) |\n| `MIN_SLASHING_PENALTY_QUOTIENT_BELLATRIX` | `uint64(2**5)` (= 32) |\n| `PROPORTIONAL_SLASHING_MULTIPLIER_BELLATRIX` | `uint64(3)` |\n\n## Configuration\n\n### Transition settings\n\n| Name | Value |\n| - | - |\n| `TERMINAL_TOTAL_DIFFICULTY` | `58750000000000000000000` (Estimated: Sept 15, 2022)|\n| `TERMINAL_BLOCK_HASH` | `Hash32()` |\n| `TERMINAL_BLOCK_HASH_ACTIVATION_EPOCH` | `FAR_FUTURE_EPOCH` |\n\n## Containers\n\n### Extended containers\n\n#### `BeaconBlockBody`\n\n```python\nclass BeaconBlockBody(Container):\n    randao_reveal: BLSSignature\n    eth1_data: Eth1Data  # Eth1 data vote\n    graffiti: Bytes32  # Arbitrary data\n    # Operations\n    proposer_slashings: List[ProposerSlashing, MAX_PROPOSER_SLASHINGS]\n    attester_slashings: List[AttesterSlashing, MAX_ATTESTER_SLASHINGS]\n    attestations: List[Attestation, MAX_ATTESTATIONS]\n    deposits: List[Deposit, MAX_DEPOSITS]\n    voluntary_exits: List[SignedVoluntaryExit, MAX_VOLUNTARY_EXITS]\n    sync_aggregate: SyncAggregate\n    # Execution\n    execution_payload: ExecutionPayload  # [New in Bellatrix]\n```\n\n#### `BeaconState`\n\n```python\nclass BeaconState(Container):\n    # Versioning\n    genesis_time: uint64\n    genesis_validators_root: Root\n    slot: Slot\n    fork: Fork\n    # History\n    latest_block_header: BeaconBlockHeader\n    block_roots: Vector[Root, SLOTS_PER_HISTORICAL_ROOT]\n    state_roots: Vector[Root, SLOTS_PER_HISTORICAL_ROOT]\n    historical_roots: List[Root, HISTORICAL_ROOTS_LIMIT]\n    # Eth1\n    eth1_data: Eth1Data\n    eth1_data_votes: List[Eth1Data, EPOCHS_PER_ETH1_VOTING_PERIOD * SLOTS_PER_EPOCH]\n    eth1_deposit_index: uint64\n    # Registry\n    validators: List[Validator, VALIDATOR_REGISTRY_LIMIT]\n    balances: List[Gwei, VALIDATOR_REGISTRY_LIMIT]\n    # Randomness\n    randao_mixes: Vector[Bytes32, EPOCHS_PER_HISTORICAL_VECTOR]\n    # Slashings\n    slashings: Vector[Gwei, EPOCHS_PER_SLASHINGS_VECTOR]  # Per-epoch sums of slashed effective balances\n    # Participation\n    previous_epoch_participation: List[ParticipationFlags, VALIDATOR_REGISTRY_LIMIT]\n    current_epoch_participation: List[ParticipationFlags, VALIDATOR_REGISTRY_LIMIT]\n    # Finality\n    justification_bits: Bitvector[JUSTIFICATION_BITS_LENGTH]  # Bit set for every recent justified epoch\n    previous_justified_checkpoint: Checkpoint\n    current_justified_checkpoint: Checkpoint\n    finalized_checkpoint: Checkpoint\n    # Inactivity\n    inactivity_scores: List[uint64, VALIDATOR_REGISTRY_LIMIT]\n    # Sync\n    current_sync_committee: SyncCommittee\n    next_sync_committee: SyncCommittee\n    # Execution\n    latest_execution_payload_header: ExecutionPayloadHeader  # [New in Bellatrix]\n```\n\n### New containers\n\n#### `ExecutionPayload`\n\n```python\nclass ExecutionPayload(Container):\n    # Execution block header fields\n    parent_hash: Hash32\n    fee_recipient: ExecutionAddress  # 'beneficiary' in the yellow paper\n    state_root: Bytes32\n    receipts_root: Bytes32\n    logs_bloom: ByteVector[BYTES_PER_LOGS_BLOOM]\n    prev_randao: Bytes32  # 'difficulty' in the yellow paper\n    block_number: uint64  # 'number' in the yellow paper\n    gas_limit: uint64\n    gas_used: uint64\n    timestamp: uint64\n    extra_data: ByteList[MAX_EXTRA_DATA_BYTES]\n    base_fee_per_gas: uint256\n    # Extra payload fields\n    block_hash: Hash32  # Hash of execution block\n    transactions: List[Transaction, MAX_TRANSACTIONS_PER_PAYLOAD]\n```\n\n#### `ExecutionPayloadHeader`\n\n```python\nclass ExecutionPayloadHeader(Container):\n    # Execution block header fields\n    parent_hash: Hash32\n    fee_recipient: ExecutionAddress\n    state_root: Bytes32\n    receipts_root: Bytes32\n    logs_bloom: ByteVector[BYTES_PER_LOGS_BLOOM]\n    prev_randao: Bytes32\n    block_number: uint64\n    gas_limit: uint64\n    gas_used: uint64\n    timestamp: uint64\n    extra_data: ByteList[MAX_EXTRA_DATA_BYTES]\n    base_fee_per_gas: uint256\n    # Extra payload fields\n    block_hash: Hash32  # Hash of execution block\n    transactions_root: Root\n```\n\n## Helper functions\n\n### Predicates\n\n#### `is_merge_transition_complete`\n\n```python\ndef is_merge_transition_complete(state: BeaconState) -> bool:\n    return state.latest_execution_payload_header != ExecutionPayloadHeader()\n```\n\n#### `is_merge_transition_block`\n\n```python\ndef is_merge_transition_block(state: BeaconState, body: BeaconBlockBody) -> bool:\n    return not is_merge_transition_complete(state) and body.execution_payload != ExecutionPayload()\n```\n\n#### `is_execution_enabled`\n\n```python\ndef is_execution_enabled(state: BeaconState, body: BeaconBlockBody) -> bool:\n    return is_merge_transition_block(state, body) or is_merge_transition_complete(state)\n```\n\n### Misc\n\n#### `compute_timestamp_at_slot`\n\n*Note*: This function is unsafe with respect to overflows and underflows.\n\n```python\ndef compute_timestamp_at_slot(state: BeaconState, slot: Slot) -> uint64:\n    slots_since_genesis = slot - GENESIS_SLOT\n    return uint64(state.genesis_time + slots_since_genesis * SECONDS_PER_SLOT)\n```\n\n### Beacon state accessors\n\n#### Modified `get_inactivity_penalty_deltas`\n\n*Note*: The function `get_inactivity_penalty_deltas` is modified to use `INACTIVITY_PENALTY_QUOTIENT_BELLATRIX`.\n\n```python\ndef get_inactivity_penalty_deltas(state: BeaconState) -> Tuple[Sequence[Gwei], Sequence[Gwei]]:\n    \"\"\"\n    Return the inactivity penalty deltas by considering timely target participation flags and inactivity scores.\n    \"\"\"\n    rewards = [Gwei(0) for _ in range(len(state.validators))]\n    penalties = [Gwei(0) for _ in range(len(state.validators))]\n    previous_epoch = get_previous_epoch(state)\n    matching_target_indices = get_unslashed_participating_indices(state, TIMELY_TARGET_FLAG_INDEX, previous_epoch)\n    for index in get_eligible_validator_indices(state):\n        if index not in matching_target_indices:\n            penalty_numerator = state.validators[index].effective_balance * state.inactivity_scores[index]\n            # [Modified in Bellatrix]\n            penalty_denominator = INACTIVITY_SCORE_BIAS * INACTIVITY_PENALTY_QUOTIENT_BELLATRIX\n            penalties[index] += Gwei(penalty_numerator // penalty_denominator)\n    return rewards, penalties\n```\n\n### Beacon state mutators\n\n#### Modified `slash_validator`\n\n*Note*: The function `slash_validator` is modified to use `MIN_SLASHING_PENALTY_QUOTIENT_BELLATRIX`.\n\n```python\ndef slash_validator(state: BeaconState,\n                    slashed_index: ValidatorIndex,\n                    whistleblower_index: ValidatorIndex=None) -> None:\n    \"\"\"\n    Slash the validator with index ``slashed_index``.\n    \"\"\"\n    epoch = get_current_epoch(state)\n    initiate_validator_exit(state, slashed_index)\n    validator = state.validators[slashed_index]\n    validator.slashed = True\n    validator.withdrawable_epoch = max(validator.withdrawable_epoch, Epoch(epoch + EPOCHS_PER_SLASHINGS_VECTOR))\n    state.slashings[epoch % EPOCHS_PER_SLASHINGS_VECTOR] += validator.effective_balance\n    slashing_penalty = validator.effective_balance // MIN_SLASHING_PENALTY_QUOTIENT_BELLATRIX  # [Modified in Bellatrix]\n    decrease_balance(state, slashed_index, slashing_penalty)\n\n    # Apply proposer and whistleblower rewards\n    proposer_index = get_beacon_proposer_index(state)\n    if whistleblower_index is None:\n        whistleblower_index = proposer_index\n    whistleblower_reward = Gwei(validator.effective_balance // WHISTLEBLOWER_REWARD_QUOTIENT)\n    proposer_reward = Gwei(whistleblower_reward * PROPOSER_WEIGHT // WEIGHT_DENOMINATOR)\n    increase_balance(state, proposer_index, proposer_reward)\n    increase_balance(state, whistleblower_index, Gwei(whistleblower_reward - proposer_reward))\n```\n\n## Beacon chain state transition function\n\n### Execution engine\n\n#### Request data\n\n##### `NewPayloadRequest`\n\n```python\n@dataclass\nclass NewPayloadRequest(object):\n    execution_payload: ExecutionPayload\n```\n\n#### Engine APIs\n\nThe implementation-dependent `ExecutionEngine` protocol encapsulates the execution sub-system logic via:\n\n* a state object `self.execution_state` of type `ExecutionState`\n* a notification function `self.notify_new_payload` which may apply changes to the `self.execution_state`\n\nThe body of these functions are implementation dependent.\nThe Engine API may be used to implement this and similarly defined functions via an external execution engine.\n\n#### `notify_new_payload`\n\n`notify_new_payload` is a function accessed through the `EXECUTION_ENGINE` module which instantiates the `ExecutionEngine` protocol.\n\n```python\ndef notify_new_payload(self: ExecutionEngine, execution_payload: ExecutionPayload) -> bool:\n    \"\"\"\n    Return ``True`` if and only if ``execution_payload`` is valid with respect to ``self.execution_state``.\n    \"\"\"\n    ...\n```\n\n#### `is_valid_block_hash`\n\n```python\ndef is_valid_block_hash(self: ExecutionEngine, execution_payload: ExecutionPayload) -> bool:\n    \"\"\"\n    Return ``True`` if and only if ``execution_payload.block_hash`` is computed correctly.\n    \"\"\"\n    ...\n```\n\n#### `verify_and_notify_new_payload`\n\n```python\ndef verify_and_notify_new_payload(self: ExecutionEngine,\n                                  new_payload_request: NewPayloadRequest) -> bool:\n    \"\"\"\n    Return ``True`` if and only if ``new_payload_request`` is valid with respect to ``self.execution_state``.\n    \"\"\"\n    if not self.is_valid_block_hash(new_payload_request.execution_payload):\n        return False\n    if not self.notify_new_payload(new_payload_request.execution_payload):\n        return False\n    return True\n```\n\n### Block processing\n\n*Note*: The call to the `process_execution_payload` must happen before the call to the `process_randao` as the former depends on the `randao_mix` computed with the reveal of the previous block.\n\n```python\ndef process_block(state: BeaconState, block: BeaconBlock) -> None:\n    process_block_header(state, block)\n    if is_execution_enabled(state, block.body):\n        process_execution_payload(state, block.body, EXECUTION_ENGINE)  # [New in Bellatrix]\n    process_randao(state, block.body)\n    process_eth1_data(state, block.body)\n    process_operations(state, block.body)\n    process_sync_aggregate(state, block.body.sync_aggregate)\n```\n\n#### Execution payload\n\n##### `process_execution_payload`\n\n```python\ndef process_execution_payload(state: BeaconState, body: BeaconBlockBody, execution_engine: ExecutionEngine) -> None:\n    payload = body.execution_payload\n\n    # Verify consistency of the parent hash with respect to the previous execution payload header\n    if is_merge_transition_complete(state):\n        assert payload.parent_hash == state.latest_execution_payload_header.block_hash\n    # Verify prev_randao\n    assert payload.prev_randao == get_randao_mix(state, get_current_epoch(state))\n    # Verify timestamp\n    assert payload.timestamp == compute_timestamp_at_slot(state, state.slot)\n    # Verify the execution payload is valid\n    assert execution_engine.verify_and_notify_new_payload(NewPayloadRequest(execution_payload=payload))\n    # Cache execution payload header\n    state.latest_execution_payload_header = ExecutionPayloadHeader(\n        parent_hash=payload.parent_hash,\n        fee_recipient=payload.fee_recipient,\n        state_root=payload.state_root,\n        receipts_root=payload.receipts_root,\n        logs_bloom=payload.logs_bloom,\n        prev_randao=payload.prev_randao,\n        block_number=payload.block_number,\n        gas_limit=payload.gas_limit,\n        gas_used=payload.gas_used,\n        timestamp=payload.timestamp,\n        extra_data=payload.extra_data,\n        base_fee_per_gas=payload.base_fee_per_gas,\n        block_hash=payload.block_hash,\n        transactions_root=hash_tree_root(payload.transactions),\n    )\n```\n\n### Epoch processing\n\n#### Slashings\n\n*Note*: The function `process_slashings` is modified to use `PROPORTIONAL_SLASHING_MULTIPLIER_BELLATRIX`.\n\n```python\ndef process_slashings(state: BeaconState) -> None:\n    epoch = get_current_epoch(state)\n    total_balance = get_total_active_balance(state)\n    adjusted_total_slashing_balance = min(\n        sum(state.slashings) * PROPORTIONAL_SLASHING_MULTIPLIER_BELLATRIX,  # [Modified in Bellatrix]\n        total_balance\n    )\n    for index, validator in enumerate(state.validators):\n        if validator.slashed and epoch + EPOCHS_PER_SLASHINGS_VECTOR // 2 == validator.withdrawable_epoch:\n            increment = EFFECTIVE_BALANCE_INCREMENT  # Factored out from penalty numerator to avoid uint64 overflow\n            penalty_numerator = validator.effective_balance // increment * adjusted_total_slashing_balance\n            penalty = penalty_numerator // total_balance * increment\n            decrease_balance(state, ValidatorIndex(index), penalty)\n```\n\n## Testing\n\n*Note*: The function `initialize_beacon_state_from_eth1` is modified for pure Bellatrix testing only.\nModifications include:\n1. Use `BELLATRIX_FORK_VERSION` as the previous and current fork version.\n2. Utilize the Bellatrix `BeaconBlockBody` when constructing the initial `latest_block_header`.\n3. Initialize `latest_execution_payload_header`.\n  If `execution_payload_header == ExecutionPayloadHeader()`, then the Merge has not yet occurred.\n  Else, the Merge starts from genesis and the transition is incomplete.\n\n```python\ndef initialize_beacon_state_from_eth1(eth1_block_hash: Hash32,\n                                      eth1_timestamp: uint64,\n                                      deposits: Sequence[Deposit],\n                                      execution_payload_header: ExecutionPayloadHeader=ExecutionPayloadHeader()\n                                      ) -> BeaconState:\n    fork = Fork(\n        previous_version=BELLATRIX_FORK_VERSION,  # [Modified in Bellatrix] for testing only\n        current_version=BELLATRIX_FORK_VERSION,  # [Modified in Bellatrix]\n        epoch=GENESIS_EPOCH,\n    )\n    state = BeaconState(\n        genesis_time=eth1_timestamp + GENESIS_DELAY,\n        fork=fork,\n        eth1_data=Eth1Data(block_hash=eth1_block_hash, deposit_count=uint64(len(deposits))),\n        latest_block_header=BeaconBlockHeader(body_root=hash_tree_root(BeaconBlockBody())),\n        randao_mixes=[eth1_block_hash] * EPOCHS_PER_HISTORICAL_VECTOR,  # Seed RANDAO with Eth1 entropy\n    )\n\n    # Process deposits\n    leaves = list(map(lambda deposit: deposit.data, deposits))\n    for index, deposit in enumerate(deposits):\n        deposit_data_list = List[DepositData, 2**DEPOSIT_CONTRACT_TREE_DEPTH](*leaves[:index + 1])\n        state.eth1_data.deposit_root = hash_tree_root(deposit_data_list)\n        process_deposit(state, deposit)\n\n    # Process activations\n    for index, validator in enumerate(state.validators):\n        balance = state.balances[index]\n        validator.effective_balance = min(balance - balance % EFFECTIVE_BALANCE_INCREMENT, MAX_EFFECTIVE_BALANCE)\n        if validator.effective_balance == MAX_EFFECTIVE_BALANCE:\n            validator.activation_eligibility_epoch = GENESIS_EPOCH\n            validator.activation_epoch = GENESIS_EPOCH\n\n    # Set genesis validators root for domain separation and chain versioning\n    state.genesis_validators_root = hash_tree_root(state.validators)\n\n    # Fill in sync committees\n    # Note: A duplicate committee is assigned for the current and next committee at genesis\n    state.current_sync_committee = get_next_sync_committee(state)\n    state.next_sync_committee = get_next_sync_committee(state)\n\n    # [New in Bellatrix] Initialize the execution payload header\n    # If empty, will initialize a chain that has not yet gone through the Merge transition\n    state.latest_execution_payload_header = execution_payload_header\n\n    return state\n```"
    },
    {
      "filename": "rio-sherlock-audit/contracts/restaking/RioLRTRewardDistributor.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.23;\n\nimport {UUPSUpgradeable} from '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\nimport {OwnableUpgradeable} from '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport {IRioLRTRewardDistributor} from 'contracts/interfaces/IRioLRTRewardDistributor.sol';\nimport {RioLRTCore} from 'contracts/restaking/base/RioLRTCore.sol';\nimport {Asset} from 'contracts/utils/Asset.sol';\n\ncontract RioLRTRewardDistributor is IRioLRTRewardDistributor, OwnableUpgradeable, UUPSUpgradeable, RioLRTCore {\n    using Asset for address;\n\n    /// @notice The maximum basis points value (100%).\n    uint16 public constant MAX_BPS = 10_000;\n\n    /// @notice The treasury address.\n    address public treasury;\n\n    /// @notice The operator reward pool address.\n    address public operatorRewardPool;\n\n    /// @notice The treasury share of the ETH validator rewards in basis points.\n    uint16 public treasuryETHValidatorRewardShareBPS;\n\n    /// @notice The operator share of the ETH validator rewards in basis points.\n    uint16 public operatorETHValidatorRewardShareBPS;\n\n    /// @param issuer_ The LRT issuer that's authorized to deploy this contract.\n    constructor(address issuer_) RioLRTCore(issuer_) {}\n\n    // forgefmt: disable-next-item\n    /// @notice Initializes the contract.\n    /// @param initialOwner The initial owner of the contract.\n    /// @param token_ The address of the liquid restaking token.\n    /// @param treasury_ The treasury address.\n    /// @param operatorRewardPool_ The operator reward pool address.\n    function initialize(address initialOwner, address token_, address treasury_, address operatorRewardPool_) external initializer {\n        __Ownable_init(initialOwner);\n        __UUPSUpgradeable_init();\n        __RioLRTCore_init(token_);\n\n        treasury = treasury_;\n        operatorRewardPool = operatorRewardPool_;\n\n        _setTreasuryETHValidatorRewardShareBPS(500); // 5%\n        _setOperatorETHValidatorRewardShareBPS(500); // 5%\n    }\n\n    /// @notice Sets the treasury's share of ETH validator rewards.\n    /// @param newTreasuryETHValidatorRewardShareBPS The new treasury share in basis points.\n    function setTreasuryETHValidatorRewardShareBPS(uint16 newTreasuryETHValidatorRewardShareBPS) external onlyOwner {\n        _setTreasuryETHValidatorRewardShareBPS(newTreasuryETHValidatorRewardShareBPS);\n    }\n\n    /// @notice Sets the operator's share of ETH validator rewards.\n    /// @param newOperatorETHValidatorRewardShareBPS The new operator share in basis points.\n    function setOperatorETHValidatorRewardShareBPS(uint16 newOperatorETHValidatorRewardShareBPS) external onlyOwner {\n        _setOperatorETHValidatorRewardShareBPS(newOperatorETHValidatorRewardShareBPS);\n    }\n\n    /// @notice Sets the treasury's share of Ethereum validator rewards.\n    /// @param newTreasuryETHValidatorRewardShareBPS The new treasury share in basis points.\n    function _setTreasuryETHValidatorRewardShareBPS(uint16 newTreasuryETHValidatorRewardShareBPS) internal {\n        if (newTreasuryETHValidatorRewardShareBPS + operatorETHValidatorRewardShareBPS > MAX_BPS) {\n            revert TREASURY_ETH_VALIDATOR_SHARE_BPS_TOO_HIGH();\n        }\n        treasuryETHValidatorRewardShareBPS = newTreasuryETHValidatorRewardShareBPS;\n        emit TreasuryETHValidatorRewardShareBPSSet(newTreasuryETHValidatorRewardShareBPS);\n    }\n\n    /// @notice Sets the operator's share of Ethereum validator rewards.\n    /// @param newOperatorETHValidatorRewardShareBPS The new operator share in basis points.\n    function _setOperatorETHValidatorRewardShareBPS(uint16 newOperatorETHValidatorRewardShareBPS) internal {\n        if (newOperatorETHValidatorRewardShareBPS + treasuryETHValidatorRewardShareBPS > MAX_BPS) {\n            revert OPERATOR_ETH_VALIDATOR_SHARE_BPS_TOO_HIGH();\n        }\n        operatorETHValidatorRewardShareBPS = newOperatorETHValidatorRewardShareBPS;\n        emit OperatorETHValidatorRewardShareBPSSet(newOperatorETHValidatorRewardShareBPS);\n    }\n\n    /// @notice Receives ETH and distributes it to the treasury, operator, and deposit pool.\n    receive() external payable {\n        uint256 value = msg.value;\n\n        uint256 treasuryShare = value * treasuryETHValidatorRewardShareBPS / MAX_BPS;\n        uint256 operatorShare = value * operatorETHValidatorRewardShareBPS / MAX_BPS;\n        uint256 poolShare = value - treasuryShare - operatorShare;\n\n        if (treasuryShare > 0) treasury.transferETH(treasuryShare);\n        if (operatorShare > 0) operatorRewardPool.transferETH(operatorShare);\n        if (poolShare > 0) address(depositPool()).transferETH(poolShare);\n\n        emit ETHValidatorRewardsDistributed(treasuryShare, operatorShare, poolShare);\n    }\n\n    /// @dev Allows the owner to upgrade the reward distributor implementation.\n    /// @param newImplementation The implementation to upgrade to.\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n}"
    }
  ]
}