{
  "Title": "[M04][Fixed] Use of transfer might render ETH impossible to withdraw",
  "Content": "When withdrawing ETH deposits, the [`PayableProxyController` contract](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/external/proxies/PayableProxyController.sol#L19) uses Solidity’s [`transfer` function](https://github.com/opynfinance/GammaProtocol/blob/d151621b33134789b29dc78eb89dad2b557b25b9/contracts/external/proxies/PayableProxyController.sol#L73). This has some notable shortcomings when the withdrawer is a smart contract, which can render ETH deposits impossible to withdraw. Specifically, the withdrawal will inevitably fail when:\n\n\n* The withdrawer smart contract does not implement a payable fallback function.\n* The withdrawer smart contract implements a payable fallback function which uses more than 2300 gas units.\n* The withdrawer smart contract implements a payable fallback function which needs less than 2300 gas units but is called through a proxy that raises the call’s gas usage above 2300.\n\n\nTo prevent unexpected behavior and potential loss of funds, consider explicitly warning end-users about the mentioned shortcomings to raise awareness before they deposit Ether into the protocol. Additionally, note that the [`sendValue` function](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.5.1/contracts/utils/Address.sol#L63) available in OpenZeppelin Contract’s `Address` library can be used to transfer the withdrawn Ether without being limited to 2300 gas units. Risks of reentrancy stemming from the use of this function can be mitigated by tightly following the [“Check-effects-interactions” pattern](https://solidity.readthedocs.io/en/latest/security-considerations.html#use-the-checks-effects-interactions-pattern) and using OpenZeppelin Contract’s [`ReentrancyGuard` contract](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.5.1/contracts/utils/ReentrancyGuard.sol). For further reference on why using Solidity’s `transfer` is no longer recommended, refer to these articles:\n\n\n* [Stop using Solidity’s transfer now](https://diligence.consensys.net/blog/2019/09/stop-using-soliditys-transfer-now/)\n* [Reentrancy after Istanbul](https://blog.openzeppelin.com/reentrancy-after-istanbul/)\n\n\n**Update:** *Fixed in [PR#305](https://github.com/opynfinance/GammaProtocol/pull/305).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/external/proxies/PayableProxyController.sol",
      "content": "/**\n * SPDX-License-Identifier: UNLICENSED\n */\npragma solidity =0.6.10;\npragma experimental ABIEncoderV2;\n\nimport {WETH9} from \"../canonical-weth/WETH9.sol\";\nimport {ReentrancyGuard} from \"../../packages/oz/ReentrancyGuard.sol\";\nimport {SafeERC20} from \"../../packages/oz/SafeERC20.sol\";\nimport {ERC20Interface} from \"../../interfaces/ERC20Interface.sol\";\nimport {Actions} from \"../../libs/Actions.sol\";\nimport {Controller} from \"../../Controller.sol\";\n\n/**\n * @title PayableProxyController\n * @author Opyn Team\n * @dev Contract for wrapping/unwrapping ETH before/after interacting with the Gamma Protocol\n */\ncontract PayableProxyController is ReentrancyGuard {\n    WETH9 public weth;\n    Controller public controller;\n    using SafeERC20 for ERC20Interface;\n\n    constructor(\n        address _controller,\n        address _marginPool,\n        address payable _weth\n    ) public {\n        controller = Controller(_controller);\n        weth = WETH9(_weth);\n        ERC20Interface(address(weth)).safeApprove(_marginPool, uint256(-1));\n    }\n\n    /**\n     * @notice fallback function which disallows ETH to be sent to this contract without data except when unwrapping WETH\n     */\n    fallback() external payable {\n        require(msg.sender == address(weth), \"PayableProxyController: Cannot receive ETH\");\n    }\n\n    /**\n     * @notice execute a number of actions\n     * @dev a wrapper for the Controller operate function, to wrap WETH and the beginning and unwrap WETH at the end of the execution\n     * @param _actions array of actions arguments\n     */\n    function operate(Actions.ActionArgs[] memory _actions, address payable sendEthTo) external payable nonReentrant {\n        // create WETH from ETH\n        if (msg.value != 0) {\n            weth.deposit{value: msg.value}();\n        }\n\n        // verify sender\n        for (uint256 i = 0; i < _actions.length; i++) {\n            Actions.ActionArgs memory action = _actions[i];\n\n            // check that msg.sender is an owner or operator\n            if (action.owner != address(0)) {\n                require(\n                    (msg.sender == action.owner) || (controller.isOperator(action.owner, msg.sender)),\n                    \"PayableProxyController: cannot execute action \"\n                );\n            }\n        }\n\n        controller.operate(_actions);\n\n        // return all remaining WETH to the sendEthTo address as ETH\n        uint256 remainingWeth = weth.balanceOf(address(this));\n        if (remainingWeth != 0) {\n            require(sendEthTo != address(0), \"PayableProxyController: cannot send ETH to address zero\");\n\n            weth.withdraw(remainingWeth);\n            sendEthTo.transfer(remainingWeth);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/utils/Address.sol",
      "content": "pragma solidity ^0.5.5;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following \n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Converts an `address` into `address payable`. Note that this is\n     * simply a type cast: the actual underlying value is not changed.\n     *\n     * _Available since v2.4.0._\n     */\n    function toPayable(address account) internal pure returns (address payable) {\n        return address(uint160(account));\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     *\n     * _Available since v2.4.0._\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-call-value\n        (bool success, ) = recipient.call.value(amount)(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}"
    }
  ]
}