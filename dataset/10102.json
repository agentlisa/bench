{
  "Title": "[M-04] Change in interest rate can disable repay of loan",
  "Content": "_Submitted by pmerkleplant_\n\n#### Impact\nThe ability of a borrower to repay a loan is disabled if the interest rate is\nset too high by the `InterestRateModel`.\n\nHowever, there is neither a check when setting the interest rate nor an\nindication in the `IInterestRateModel`'s specs of this behavior.\n\nBut this issue could also be used in an adversarial fashion by the\n`FixedInterestRateModel`-owner if he/she would disable the repay functionality\nfor some time and enables it at a later point again with the demand of a\nhigher interest to be paid by the borrower.\n\n#### Proof of Concept\nIf an account wants to repay a loan, the function\n`UToken::_repayBorrowFresh()` is used. This function calls\n`UToken::accrueInterest()` ([line](https://github.com/code-423n4/2021-10-union/blob/main/contracts/market/UToken.sol#L465) 465)\nwhich fetches the current borrow rate of the interest rate model\n([line](https://github.com/code-423n4/2021-10-union/blob/main/contracts/market/UToken.sol#L546) 546\nand [line](https://github.com/code-423n4/2021-10-union/blob/main/contracts/market/UToken.sol#L330) 330).\n\nThe function `UToken::borrowRatePerBlock()` requires an not \"absurdly high\"\nrate, or fails otherwise ([line](https://github.com/code-423n4/2021-10-union/blob/main/contracts/market/UToken.sol#L331) 331).\n\nHowever, there is no check or indicator in `FixedInterestRateModel.sol` to\nprevent the owner to set such a high rate that effectively disables repay\nof borrowed funds ([line](https://github.com/code-423n4/2021-10-union/blob/main/contracts/market/FixedInterestRateModel.sol#L36) 36).\n\n#### Recommended Mitigation Steps\nDisallow setting the interest rate too high with a check in\n`FixedInterestRateModel::setInterestRate()`.\n\n**[kingjacob (Union) confirmed](https://github.com/code-423n4/2021-10-union-findings/issues/21)**\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2021-10-union-findings/issues/21#issuecomment-966425305):**\n > Agree with the need for a check on the `setInterestRate` function\n> Since the warden showed a specific way to negate certain protocol functionality, under specific assumptions, the finding is of medium severity\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2021-10-union",
  "Code": [
    {
      "filename": "contracts/market/UToken.sol",
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"../Controller.sol\";\nimport \"../interfaces/IUserManager.sol\";\nimport \"../interfaces/IAssetManager.sol\";\nimport \"../interfaces/IUErc20.sol\";\nimport \"../interfaces/IInterestRateModel.sol\";\n\n/**\n *  @title UToken Contract\n *  @dev Union accountBorrows can borrow and repay thru this component.\n */\ncontract UToken is Controller, ReentrancyGuardUpgradeable {\n    using SafeERC20Upgradeable for IUErc20;\n\n    bool public constant IS_UTOKEN = true;\n    uint256 public constant WAD = 1e18;\n    uint256 internal constant BORROW_RATE_MAX_MANTISSA = 0.0005e16; //Maximum borrow rate that can ever be applied (.0005% / block)\n    uint256 internal constant RESERVE_FACTORY_MAX_MANTISSA = 1e18; //Maximum fraction of interest that can be set aside for reserves\n\n    address public underlying;\n    IInterestRateModel public interestRateModel;\n    uint256 internal initialExchangeRateMantissa; //Initial exchange rate used when minting the first UTokens (used when totalSupply = 0)\n    uint256 public reserveFactorMantissa; //Fraction of interest currently set aside for reserves\n    uint256 public accrualBlockNumber; //Block number that interest was last accrued at\n    uint256 public borrowIndex; //Accumulator of the total earned interest rate since the opening of the market\n    uint256 public totalBorrows; //Total amount of outstanding borrows of the underlying in this market\n    uint256 public totalReserves; //Total amount of reserves of the underlying held in this marke\n    uint256 public totalRedeemable; //Calculates the exchange rate from the underlying to the uToken\n    uint256 public overdueBlocks; //overdue duration, based on the number of blocks\n    uint256 public originationFee;\n    uint256 public debtCeiling; //The debt limit for the whole system\n    uint256 public maxBorrow;\n    uint256 public minBorrow;\n    address public assetManager;\n    address public userManager;\n    IUErc20 public uErc20;\n\n    struct BorrowSnapshot {\n        uint256 principal;\n        uint256 interest;\n        uint256 interestIndex;\n        uint256 lastRepay; //Calculate if it is overdue\n    }\n\n    /**\n     * @notice Mapping of account addresses to outstanding borrow balances\n     */\n    mapping(address => BorrowSnapshot) internal accountBorrows;\n\n    /**\n     *  @dev Change of the interest rate model\n     *  @param oldInterestRateModel Old interest rate model address\n     *  @param newInterestRateModel New interest rate model address\n     */\n    event LogNewMarketInterestRateModel(address oldInterestRateModel, address newInterestRateModel);\n\n    event LogMint(address minter, uint256 underlyingAmount, uint256 uTokenAmount);\n\n    event LogRedeem(address redeemer, uint256 redeemTokensIn, uint256 redeemAmountIn, uint256 redeemAmount);\n\n    event LogReservesAdded(address reserver, uint256 actualAddAmount, uint256 totalReservesNew);\n\n    event LogReservesReduced(address receiver, uint256 reduceAmount, uint256 totalReservesNew);\n\n    /**\n     *  @dev Event borrow\n     *  @param account Member address\n     *  @param amount Borrow amount\n     *  @param fee Origination fee\n     */\n    event LogBorrow(address indexed account, uint256 amount, uint256 fee);\n\n    /**\n     *  @dev Event repay\n     *  @param account Member address\n     *  @param amount Repay amount\n     */\n    event LogRepay(address indexed account, uint256 amount);\n\n    /**\n     *  @dev modifier limit member\n     */\n    modifier onlyMember(address account) {\n        require(IUserManager(userManager).checkIsMember(account), \"UToken: caller is not a member\");\n        _;\n    }\n\n    modifier onlyAssetManager() {\n        require(msg.sender == assetManager, \"UToken: caller is not assetManager\");\n        _;\n    }\n\n    modifier onlyUserManager() {\n        require(msg.sender == userManager, \"UToken: caller is not userManager\");\n        _;\n    }\n\n    function __UToken_init(\n        IUErc20 uErc20_,\n        address underlying_,\n        uint256 initialExchangeRateMantissa_,\n        uint256 reserveFactorMantissa_,\n        uint256 originationFee_,\n        uint256 debtCeiling_,\n        uint256 maxBorrow_,\n        uint256 minBorrow_,\n        uint256 overdueBlocks_,\n        address admin_\n    ) public initializer {\n        require(initialExchangeRateMantissa_ > 0, \"initial exchange rate must be greater than zero.\");\n        require(address(underlying_) != address(0), \"underlying token is zero\");\n        require(\n            reserveFactorMantissa_ >= 0 && reserveFactorMantissa_ <= RESERVE_FACTORY_MAX_MANTISSA,\n            \"reserveFactorMantissa error\"\n        );\n        uErc20 = uErc20_;\n        Controller.__Controller_init(admin_);\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        underlying = underlying_;\n        originationFee = originationFee_;\n        debtCeiling = debtCeiling_;\n        maxBorrow = maxBorrow_;\n        minBorrow = minBorrow_;\n        overdueBlocks = overdueBlocks_;\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n        reserveFactorMantissa = reserveFactorMantissa_;\n        accrualBlockNumber = getBlockNumber();\n        borrowIndex = WAD;\n    }\n\n    function setAssetManager(address assetManager_) external onlyAdmin {\n        assetManager = assetManager_;\n    }\n\n    function setUserManager(address userManager_) external onlyAdmin {\n        userManager = userManager_;\n    }\n\n    /**\n     *  @dev Change loan origination fee value\n     *  Accept claims only from the admin\n     *  @param originationFee_ Fees deducted for each loan transaction\n     */\n    function setOriginationFee(uint256 originationFee_) external onlyAdmin {\n        originationFee = originationFee_;\n    }\n\n    /**\n     *  @dev Update the market debt ceiling to a fixed amount, for example, 1 billion DAI etc.\n     *  Accept claims only from the admin\n     *  @param debtCeiling_ The debt limit for the whole system\n     */\n    function setDebtCeiling(uint256 debtCeiling_) external onlyAdmin {\n        debtCeiling = debtCeiling_;\n    }\n\n    /**\n     *  @dev Update the minimum loan size\n     *  Accept claims only from the admin\n     *  @param minBorrow_ Minimum loan amount per user\n     */\n    function setMinBorrow(uint256 minBorrow_) external onlyAdmin {\n        minBorrow = minBorrow_;\n    }\n\n    /**\n     *  @dev Update the max loan size\n     *  Accept claims only from the admin\n     *  @param maxBorrow_ Max loan amount per user\n     */\n    function setMaxBorrow(uint256 maxBorrow_) external onlyAdmin {\n        maxBorrow = maxBorrow_;\n    }\n\n    /**\n     *  @dev Change loan overdue duration, based on the number of blocks\n     *  Accept claims only from the admin\n     *  @param overdueBlocks_ Maximum late repayment block. The number of arrivals is a default\n     */\n    function setOverdueBlocks(uint256 overdueBlocks_) external onlyAdmin {\n        overdueBlocks = overdueBlocks_;\n    }\n\n    /**\n     *  @dev Change to a different interest rate model\n     *  Accept claims only from the admin\n     *  @param newInterestRateModel New interest rate model address\n     */\n    function setInterestRateModel(address newInterestRateModel) external onlyAdmin {\n        _setInterestRateModelFresh(newInterestRateModel);\n    }\n\n    function setReserveFactor(uint256 reserveFactorMantissa_) external onlyAdmin {\n        require(\n            reserveFactorMantissa_ >= 0 && reserveFactorMantissa_ <= RESERVE_FACTORY_MAX_MANTISSA,\n            \"reserveFactorMantissa error\"\n        );\n        reserveFactorMantissa = reserveFactorMantissa_;\n    }\n\n    /**\n     *  @dev Returns the remaining amount that can be borrowed from the market.\n     *  @return Remaining total amount\n     */\n    function getRemainingLoanSize() public view returns (uint256) {\n        if (debtCeiling >= totalBorrows) {\n            return debtCeiling - totalBorrows;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     *  @dev Get the last repay block\n     *  @param account Member address\n     *  @return lastRepay\n     */\n    function getLastRepay(address account) public view returns (uint256 lastRepay) {\n        lastRepay = accountBorrows[account].lastRepay;\n    }\n\n    /**\n     *  @dev Get member interest index\n     *  @param account Member address\n     *  @return interestIndex\n     */\n    function getInterestIndex(address account) public view returns (uint256 interestIndex) {\n        interestIndex = accountBorrows[account].interestIndex;\n    }\n\n    /**\n     *  @dev Check if the member's loan is overdue\n     *  @param account Member address\n     *  @return isOverdue\n     */\n    function checkIsOverdue(address account) public view returns (bool isOverdue) {\n        if (getBorrowed(account) == 0) {\n            isOverdue = false;\n        } else {\n            uint256 lastRepay = getLastRepay(account);\n            uint256 diff = getBlockNumber() - lastRepay;\n            isOverdue = (overdueBlocks < diff);\n        }\n    }\n\n    /**\n     *  @dev Get the origination fee\n     *  @param amount Amount to be calculated\n     *  @return Handling fee\n     */\n    function calculatingFee(uint256 amount) public view returns (uint256) {\n        return (originationFee * amount) / WAD;\n    }\n\n    /**\n     *  @dev Get member loan data\n     *  @param member Member address\n     *  @return principal totalBorrowed asset apr limit isOverdue lastRepay\n     */\n    function getLoan(address member)\n        public\n        view\n        returns (\n            uint256 principal,\n            uint256 totalBorrowed,\n            address asset,\n            uint256 apr,\n            int256 limit,\n            bool isOverdue,\n            uint256 lastRepay\n        )\n    {\n        principal = accountBorrows[msg.sender].principal;\n        totalBorrowed = borrowBalanceStoredInternal(member);\n        asset = underlying;\n        apr = borrowRatePerBlock();\n        lastRepay = getLastRepay(member);\n        limit = _getCreditLimit(member);\n        isOverdue = checkIsOverdue(member);\n    }\n\n    /**\n     *  @dev Get the borrowed principle\n     *  @param account Member address\n     *  @return borrowed\n     */\n    function getBorrowed(address account) public view returns (uint256 borrowed) {\n        borrowed = accountBorrows[account].principal;\n    }\n\n    /**\n     *  @dev Get a member's current owed balance, including the principle and interest but without updating the user's states.\n     *  @param account Member address\n     *  @return Borrowed amount\n     */\n    function borrowBalanceView(address account) public view returns (uint256) {\n        return accountBorrows[account].principal + calculatingInterest(account);\n    }\n\n    /**\n     *  @dev Get a member's total owed, including the principle and the interest calculated based on the interest index.\n     *  @param account Member address\n     *  @return Borrowed amount\n     */\n    function borrowBalanceStoredInternal(address account) internal view returns (uint256) {\n        BorrowSnapshot memory loan = accountBorrows[account];\n\n        /* If borrowBalance = 0 then borrowIndex is likely also 0.\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n         */\n        if (loan.principal == 0) {\n            return 0;\n        }\n\n        uint256 principalTimesIndex = (loan.principal + loan.interest) * borrowIndex;\n        return principalTimesIndex / loan.interestIndex;\n    }\n\n    /**\n     *  @dev Get the borrowing interest rate per block\n     *  @return Borrow rate\n     */\n    function borrowRatePerBlock() public view returns (uint256) {\n        uint256 borrowRateMantissa = interestRateModel.getBorrowRate();\n        require(borrowRateMantissa <= BORROW_RATE_MAX_MANTISSA, \"borrow rate is absurdly high\");\n        return borrowRateMantissa;\n    }\n\n    /**\n     * @notice Returns the current per-block supply interest rate for this UToken\n     * @return The supply interest rate per block, scaled by 1e18\n     */\n    function supplyRatePerBlock() public view returns (uint256) {\n        return interestRateModel.getSupplyRate(reserveFactorMantissa);\n    }\n\n    /**\n     * @notice Accrue interest then return the up-to-date exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateCurrent() public nonReentrant returns (uint256) {\n        require(accrueInterest(), \"UToken: accrue interest failed\");\n        return exchangeRateStored();\n    }\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the UToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateStored() public view returns (uint256) {\n        uint256 totalSupply_ = uErc20.totalSupply();\n        if (totalSupply_ == 0) {\n            return initialExchangeRateMantissa;\n        } else {\n            return (totalRedeemable * WAD) / totalSupply_;\n        }\n    }\n\n    /**\n     *  @dev Calculating member's borrowed interest\n     *  @param account Member address\n     *  @return Interest amount\n     */\n    function calculatingInterest(address account) public view returns (uint256) {\n        BorrowSnapshot memory loan = accountBorrows[account];\n\n        if (loan.principal == 0) {\n            return 0;\n        }\n\n        uint256 borrowRate = borrowRatePerBlock();\n        uint256 currentBlockNumber = getBlockNumber();\n        uint256 blockDelta = currentBlockNumber - accrualBlockNumber;\n        uint256 simpleInterestFactor = borrowRate * blockDelta;\n        uint256 borrowIndexNew = (simpleInterestFactor * borrowIndex) / WAD + borrowIndex;\n\n        uint256 principalTimesIndex = (loan.principal + loan.interest) * borrowIndexNew;\n        uint256 balance = principalTimesIndex / loan.interestIndex;\n\n        return balance - accountBorrows[account].principal;\n    }\n\n    /**\n     *  @dev Borrowing from the market\n     *  Accept claims only from the member\n     *  Borrow amount must in the range of creditLimit, minBorrow, maxBorrow, debtCeiling and not overdue\n     *  @param amount Borrow amount\n     */\n    function borrow(uint256 amount) external onlyMember(msg.sender) whenNotPaused nonReentrant {\n        IAssetManager assetManagerContract = IAssetManager(assetManager);\n        require(amount >= minBorrow, \"UToken: amount less than loan size min\");\n\n        require(amount <= getRemainingLoanSize(), \"UToken: amount more than loan global size max\");\n\n        uint256 fee = calculatingFee(amount);\n        require(borrowBalanceView(msg.sender) + amount + fee <= maxBorrow, \"UToken: amount large than borrow size max\");\n\n        require(!checkIsOverdue(msg.sender), \"UToken: Member has loans overdue\");\n\n        require(amount <= assetManagerContract.getLoanableAmount(underlying), \"UToken: Not enough to lend out\");\n        require(\n            uint256(_getCreditLimit(msg.sender)) >= amount + fee,\n            \"UToken: The loan amount plus fee is greater than credit limit\"\n        );\n\n        require(accrueInterest(), \"UToken: accrue interest failed\");\n\n        uint256 borrowedAmount = borrowBalanceStoredInternal(msg.sender);\n\n        //Set lastRepay init data\n        if (accountBorrows[msg.sender].lastRepay == 0) {\n            accountBorrows[msg.sender].lastRepay = getBlockNumber();\n        }\n\n        uint256 accountBorrowsNew = borrowedAmount + amount + fee;\n        uint256 totalBorrowsNew = totalBorrows + amount + fee;\n        uint256 oldPrincipal = accountBorrows[msg.sender].principal;\n\n        accountBorrows[msg.sender].principal += amount + fee;\n        uint256 newPrincipal = accountBorrows[msg.sender].principal;\n        IUserManager(userManager).updateLockedData(msg.sender, newPrincipal - oldPrincipal, true);\n        accountBorrows[msg.sender].interest = accountBorrowsNew - accountBorrows[msg.sender].principal;\n        accountBorrows[msg.sender].interestIndex = borrowIndex;\n        totalBorrows = totalBorrowsNew;\n        // The origination fees contribute to the reserve\n        totalReserves += fee;\n\n        require(assetManagerContract.withdraw(underlying, msg.sender, amount), \"UToken: Failed to withdraw\");\n\n        emit LogBorrow(msg.sender, amount, fee);\n    }\n\n    function repayBorrow(uint256 repayAmount) external whenNotPaused nonReentrant {\n        _repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n    }\n\n    function repayBorrowBehalf(address borrower, uint256 repayAmount) external whenNotPaused nonReentrant {\n        _repayBorrowFresh(msg.sender, borrower, repayAmount);\n    }\n\n    /**\n     *  @dev Repay the loan\n     *  Accept claims only from the member\n     *  Updated member lastPaymentEpoch only when the repayment amount is greater than interest\n     *  @param payer Payer address\n     *  @param borrower Borrower address\n     *  @param amount Repay amount\n     */\n    function _repayBorrowFresh(\n        address payer,\n        address borrower,\n        uint256 amount\n    ) private {\n        IUErc20 assetToken = IUErc20(underlying);\n        //In order to prevent the state from being changed, put the value at the top\n        bool isOverdue = checkIsOverdue(borrower);\n        uint256 oldPrincipal = accountBorrows[borrower].principal;\n        require(accrueInterest(), \"UToken: accrue interest failed\");\n        require(accrualBlockNumber == getBlockNumber(), \"UToken: market not fresh\");\n\n        uint256 interest = calculatingInterest(borrower);\n        uint256 borrowedAmount = borrowBalanceStoredInternal(borrower);\n\n        uint256 repayAmount;\n        if (amount > borrowedAmount) {\n            repayAmount = borrowedAmount;\n        } else {\n            repayAmount = amount;\n        }\n\n        require(repayAmount > 0, \"UToken: repay amount or owed amount is zero\");\n\n        require(assetToken.allowance(payer, address(this)) >= repayAmount, \"UToken: Not enough allowance to repay\");\n\n        uint256 toReserveAmount;\n        uint256 toRedeemableAmount;\n        if (repayAmount >= interest) {\n            toReserveAmount = (interest * reserveFactorMantissa) / WAD;\n            toRedeemableAmount = interest - toReserveAmount;\n\n            if (isOverdue) {\n                IUserManager(userManager).updateTotalFrozen(borrower, false);\n                IUserManager(userManager).repayLoanOverdue(borrower, underlying, accountBorrows[borrower].lastRepay);\n            }\n            accountBorrows[borrower].principal = borrowedAmount - repayAmount;\n            accountBorrows[borrower].interest = 0;\n\n            if (accountBorrows[borrower].principal == 0) {\n                //LastRepay is cleared when the arrears are paid off, and reinitialized the next time the loan is borrowed\n                accountBorrows[borrower].lastRepay = 0;\n            } else {\n                accountBorrows[borrower].lastRepay = getBlockNumber();\n            }\n        } else {\n            toReserveAmount = (repayAmount * reserveFactorMantissa) / WAD;\n            toRedeemableAmount = repayAmount - toReserveAmount;\n            accountBorrows[borrower].interest = interest - repayAmount;\n        }\n\n        totalReserves += toReserveAmount;\n        totalRedeemable += toRedeemableAmount;\n\n        uint256 newPrincipal = accountBorrows[borrower].principal;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows -= repayAmount;\n\n        IUserManager(userManager).updateLockedData(borrower, oldPrincipal - newPrincipal, false);\n\n        assetToken.safeTransferFrom(payer, address(this), repayAmount);\n\n        assetToken.safeApprove(assetManager, 0);\n        assetToken.safeApprove(assetManager, repayAmount);\n\n        require(IAssetManager(assetManager).deposit(underlying, repayAmount), \"UToken: Deposit failed\");\n\n        emit LogRepay(borrower, repayAmount);\n    }\n\n    function repayBorrowWithPermit(\n        address borrower,\n        uint256 amount,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public whenNotPaused {\n        IUErc20 erc20Token = IUErc20(underlying);\n        erc20Token.permit(msg.sender, address(this), nonce, expiry, true, v, r, s);\n\n        _repayBorrowFresh(msg.sender, borrower, amount);\n    }\n\n    /**\n     *  @dev Accrue interest\n     *  @return Accrue interest finished\n     */\n    function accrueInterest() public returns (bool) {\n        uint256 borrowRate = borrowRatePerBlock();\n        uint256 currentBlockNumber = getBlockNumber();\n        uint256 blockDelta = currentBlockNumber - accrualBlockNumber;\n\n        uint256 simpleInterestFactor = borrowRate * blockDelta;\n        uint256 interestAccumulated = (simpleInterestFactor * totalBorrows) / WAD;\n        uint256 totalBorrowsNew = interestAccumulated + totalBorrows;\n        uint256 borrowIndexNew = (simpleInterestFactor * borrowIndex) / WAD + borrowIndex;\n\n        accrualBlockNumber = currentBlockNumber;\n        borrowIndex = borrowIndexNew;\n        totalBorrows = totalBorrowsNew;\n\n        return true;\n    }\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @dev This also accrues interest in a transaction\n     * @param owner The address of the account to query\n     * @return The amount of underlying owned by `owner`\n     */\n    function balanceOfUnderlying(address owner) external returns (uint256) {\n        return exchangeRateCurrent() * uErc20.balanceOf(owner);\n    }\n\n    function mint(uint256 mintAmount) external whenNotPaused nonReentrant {\n        require(accrueInterest(), \"UToken: accrue interest failed\");\n        uint256 exchangeRate = exchangeRateStored();\n        IUErc20 assetToken = IUErc20(underlying);\n        uint256 balanceBefore = assetToken.balanceOf(address(this));\n        require(assetToken.allowance(msg.sender, address(this)) >= mintAmount, \"UToken: Not enough allowance\");\n        assetToken.safeTransferFrom(msg.sender, address(this), mintAmount);\n        uint256 balanceAfter = assetToken.balanceOf(address(this));\n        uint256 actualMintAmount = balanceAfter - balanceBefore;\n        totalRedeemable += actualMintAmount;\n        uint256 mintTokens = (actualMintAmount * WAD) / exchangeRate;\n        uErc20.mint(msg.sender, mintTokens);\n\n        assetToken.safeApprove(assetManager, 0);\n        assetToken.safeApprove(assetManager, actualMintAmount);\n\n        require(IAssetManager(assetManager).deposit(underlying, actualMintAmount), \"UToken: Deposit failed\");\n\n        emit LogMint(msg.sender, actualMintAmount, mintTokens);\n    }\n\n    /**\n     * @notice Sender redeems uTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of uTokens to redeem into underlying\n     */\n    function redeem(uint256 redeemTokens) external whenNotPaused nonReentrant {\n        require(accrueInterest(), \"UToken: accrue interest failed\");\n        _redeemFresh(payable(msg.sender), redeemTokens, 0);\n    }\n\n    /**\n     * @notice Sender redeems uTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to receive from redeeming uTokens\n     */\n    function redeemUnderlying(uint256 redeemAmount) external whenNotPaused nonReentrant {\n        require(accrueInterest(), \"UToken: accrue interest failed\");\n        _redeemFresh(payable(msg.sender), 0, redeemAmount);\n    }\n\n    /**\n     * @notice User redeems uTokens in exchange for the underlying asset\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param redeemer The address of the account which is redeeming the tokens\n     * @param redeemTokensIn The number of uTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     * @param redeemAmountIn The number of underlying tokens to receive from redeeming uTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     */\n    function _redeemFresh(\n        address payable redeemer,\n        uint256 redeemTokensIn,\n        uint256 redeemAmountIn\n    ) internal {\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n        IAssetManager assetManagerContract = IAssetManager(assetManager);\n\n        uint256 exchangeRate = exchangeRateStored();\n\n        uint256 redeemTokens;\n        uint256 redeemAmount;\n\n        if (redeemTokensIn > 0) {\n            /*\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n             *  redeemTokens = redeemTokensIn\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n             */\n            redeemTokens = redeemTokensIn;\n            redeemAmount = (redeemTokensIn * exchangeRate) / WAD;\n        } else {\n            /*\n             * We get the current exchange rate and calculate the amount to be redeemed:\n             *  redeemTokens = redeemAmountIn / exchangeRate\n             *  redeemAmount = redeemAmountIn\n             */\n            redeemTokens = (redeemAmountIn * WAD) / exchangeRate;\n            redeemAmount = redeemAmountIn;\n        }\n\n        require(totalRedeemable >= redeemAmount, \"redeem amount error\");\n        totalRedeemable -= redeemAmount;\n        uErc20.burn(redeemer, redeemTokens);\n\n        require(assetManagerContract.withdraw(underlying, redeemer, redeemAmount), \"UToken: Failed to withdraw\");\n\n        emit LogRedeem(redeemer, redeemTokensIn, redeemAmountIn, redeemAmount);\n    }\n\n    function addReserves(uint256 addAmount) external whenNotPaused nonReentrant {\n        require(accrueInterest(), \"UToken: accrue interest failed\");\n        IUErc20 assetToken = IUErc20(underlying);\n        uint256 balanceBefore = assetToken.balanceOf(address(this));\n        require(assetToken.allowance(msg.sender, address(this)) >= addAmount, \"UToken: Not enough allowance\");\n        assetToken.safeTransferFrom(msg.sender, address(this), addAmount);\n        uint256 balanceAfter = assetToken.balanceOf(address(this));\n        uint256 actualAddAmount = balanceAfter - balanceBefore;\n\n        uint256 totalReservesNew = totalReserves + actualAddAmount;\n        /* Revert on overflow */\n        require(totalReservesNew >= totalReserves, \"add reserves unexpected overflow\");\n        totalReserves = totalReservesNew;\n\n        assetToken.safeApprove(assetManager, 0);\n        assetToken.safeApprove(assetManager, balanceAfter);\n\n        require(IAssetManager(assetManager).deposit(underlying, balanceAfter), \"UToken: Deposit failed\");\n\n        emit LogReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\n    }\n\n    function removeReserves(address receiver, uint256 reduceAmount) external whenNotPaused nonReentrant onlyAdmin {\n        require(accrueInterest(), \"UToken: accrue interest failed\");\n        require(reduceAmount <= totalReserves, \"amount is large than totalReserves\");\n\n        IAssetManager assetManagerContract = IAssetManager(assetManager);\n\n        uint256 totalReservesNew = totalReserves - reduceAmount;\n        // We checked reduceAmount <= totalReserves above, so this should never revert.\n        require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\");\n\n        totalReserves = totalReservesNew;\n\n        require(assetManagerContract.withdraw(underlying, receiver, reduceAmount), \"UToken: Failed to withdraw\");\n\n        emit LogReservesReduced(receiver, reduceAmount, totalReservesNew);\n    }\n\n    function debtWriteOff(address borrower, uint256 amount) external whenNotPaused onlyUserManager {\n        uint256 oldPrincipal = accountBorrows[borrower].principal;\n        uint256 repayAmount;\n        if (amount > oldPrincipal) {\n            repayAmount = oldPrincipal;\n        } else {\n            repayAmount = amount;\n        }\n\n        accountBorrows[borrower].principal = oldPrincipal - repayAmount;\n        totalBorrows -= repayAmount;\n    }\n\n    /**\n     * @dev Function to simply retrieve block number\n     *  This exists mainly for inheriting test contracts to stub this result.\n     */\n    function getBlockNumber() internal view returns (uint256) {\n        return block.number;\n    }\n\n    function _setInterestRateModelFresh(address newInterestRateModel_) private {\n        address oldInterestRateModel = address(interestRateModel);\n        address newInterestRateModel = newInterestRateModel_;\n        require(\n            IInterestRateModel(newInterestRateModel).isInterestRateModel(),\n            \"UToken: new model is not a interestRateModel\"\n        );\n        interestRateModel = IInterestRateModel(newInterestRateModel);\n\n        emit LogNewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n    }\n\n    /**\n     *  @dev Update borrower overdue info\n     *  @param account Borrower address\n     */\n    function updateOverdueInfo(address account) external whenNotPaused {\n        if (checkIsOverdue(account)) {\n            IUserManager(userManager).updateTotalFrozen(account, true);\n        }\n    }\n\n    /**\n     *  @dev Batch update borrower overdue info\n     *  @param accounts Borrowers address\n     */\n    function batchUpdateOverdueInfos(address[] calldata accounts) external whenNotPaused {\n        address[] memory overdueAccounts = new address[](accounts.length);\n        bool[] memory isOverdues = new bool[](accounts.length);\n        for (uint256 i = 0; i < accounts.length; i++) {\n            if (checkIsOverdue(accounts[i])) {\n                overdueAccounts[i] = accounts[i];\n                isOverdues[i] = true;\n            }\n        }\n        IUserManager(userManager).batchUpdateTotalFrozen(overdueAccounts, isOverdues);\n    }\n\n    /**\n     *  @dev Get a member's available credit limit\n     *  @param account Member address\n     *  @return Member credit limit\n     */\n    function _getCreditLimit(address account) private view returns (int256) {\n        return IUserManager(userManager).getCreditLimit(account);\n    }\n}"
    },
    {
      "filename": "contracts/market/UToken.sol",
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"../Controller.sol\";\nimport \"../interfaces/IUserManager.sol\";\nimport \"../interfaces/IAssetManager.sol\";\nimport \"../interfaces/IUErc20.sol\";\nimport \"../interfaces/IInterestRateModel.sol\";\n\n/**\n *  @title UToken Contract\n *  @dev Union accountBorrows can borrow and repay thru this component.\n */\ncontract UToken is Controller, ReentrancyGuardUpgradeable {\n    using SafeERC20Upgradeable for IUErc20;\n\n    bool public constant IS_UTOKEN = true;\n    uint256 public constant WAD = 1e18;\n    uint256 internal constant BORROW_RATE_MAX_MANTISSA = 0.0005e16; //Maximum borrow rate that can ever be applied (.0005% / block)\n    uint256 internal constant RESERVE_FACTORY_MAX_MANTISSA = 1e18; //Maximum fraction of interest that can be set aside for reserves\n\n    address public underlying;\n    IInterestRateModel public interestRateModel;\n    uint256 internal initialExchangeRateMantissa; //Initial exchange rate used when minting the first UTokens (used when totalSupply = 0)\n    uint256 public reserveFactorMantissa; //Fraction of interest currently set aside for reserves\n    uint256 public accrualBlockNumber; //Block number that interest was last accrued at\n    uint256 public borrowIndex; //Accumulator of the total earned interest rate since the opening of the market\n    uint256 public totalBorrows; //Total amount of outstanding borrows of the underlying in this market\n    uint256 public totalReserves; //Total amount of reserves of the underlying held in this marke\n    uint256 public totalRedeemable; //Calculates the exchange rate from the underlying to the uToken\n    uint256 public overdueBlocks; //overdue duration, based on the number of blocks\n    uint256 public originationFee;\n    uint256 public debtCeiling; //The debt limit for the whole system\n    uint256 public maxBorrow;\n    uint256 public minBorrow;\n    address public assetManager;\n    address public userManager;\n    IUErc20 public uErc20;\n\n    struct BorrowSnapshot {\n        uint256 principal;\n        uint256 interest;\n        uint256 interestIndex;\n        uint256 lastRepay; //Calculate if it is overdue\n    }\n\n    /**\n     * @notice Mapping of account addresses to outstanding borrow balances\n     */\n    mapping(address => BorrowSnapshot) internal accountBorrows;\n\n    /**\n     *  @dev Change of the interest rate model\n     *  @param oldInterestRateModel Old interest"
    }
  ]
}