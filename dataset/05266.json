{
  "Title": "[L-08] - Signatures do not implement EIP-712",
  "Content": "\n### Impact\n\n[EIP-712 Motivation](https://eips.ethereum.org/EIPS/eip-712#motivation) is to improve the usability of off-chain message signing for use on-chain.\n\nBy not adhering to it, users will find more difficulty understanding what they are signing, as off-chain tools will have trouble decoding the messsage, leading to a compatibility and integration issue.\n\nSignatures can also be replayed on other contracts, as the contract address is not included in the message hash.\n\n### Proof of Concept\n\nMessage hashes are implemented without following specs by EIP-712, missing the [`typeHash`](https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash), and the [`domainSeparator`](https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator).\n\n```solidity\nbytes32 messageHash = keccak256(abi.encodePacked(block.chainid, geoVersion, wallet));\nreturn SigningTools._verifySignature(messageHash, signature);\n```\n\n[AccessManager.sol#L53](https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/AccessManager.sol#L53)\n\n```solidity\nbytes32 messageHash = keccak256(abi.encodePacked(block.chainid, msg.sender));\nrequire(SigningTools._verifySignature(messageHash, signature), \"Incorrect BootstrapBallot.vote signatory\" );\n```\n\n[BootstrapBallot.sol#L53-L54](https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/launch/BootstrapBallot.sol#L53-L54)\n\n### Recommendation\n\nFollow the EIP-712 spec, including the corresponding `typeHash`, `domainSeparator`, contract address, and build the message hash accordingly.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2024-01-salty",
  "Code": [
    {
      "filename": "src/AccessManager.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"./interfaces/IAccessManager.sol\";\nimport \"./dao/interfaces/IDAO.sol\";\nimport \"./SigningTools.sol\";\n\n\n// A simple AccessManager in which user IP is mapped offchain to a geolocation and then whitelisted user status is stored in the contract.\n// If geographic regions are later excluded, users are required to reverify (allowing avoiding storing countries for specific wallets and potentially violating user privacy).\n// The AccessManager restricts users from adding liquidity, adding collateral and borrowing USDS on the contract level - but always allows existing assets to be removed (in case a user's region is restricted after depositing assets).\n//\n// This contract can be replaced by the DAO with other mechanics such as completely open access, decentralized ID services, KYC by region, or whatever else deemed the best option by the DAO.\n//\n// Making proposals and voting is not access restricted - just in case AccessManager.sol is ever updated with a flaw in it that universally blocks access (which would effectively cripple the DAO if proposals and voting were then mistakingly restricted).\n//\n// Updateable using DAO.proposeSetContractAddress( \"accessManager\" )\n\ncontract AccessManager is IAccessManager\n\t{\n\tevent AccessGranted(address indexed wallet, uint256 geoVersion);\n\n\tIDAO immutable public dao;\n\n\t// Determines granted access for [geoVersion][wallet]\n    mapping(uint256 => mapping(address => bool)) private _walletsWithAccess;\n\n\t// The current geoVersion for the AccessManager - which is incremented when new countries are excluded by the DAO.\n    uint256 public geoVersion;\n\n\n\tconstructor( IDAO _dao )\n\t\t{\n\t\tdao = _dao;\n\t\t}\n\n\n\t// Called whenever the DAO updates the list of excluded countries.\n\t// This effectively clears access for all users as the geoVersion is used to reference _walletsWithAccess.\n\t// If, in contrast, new countries are included, then updating the geoVersion isn't necessary as the existing _walletsWithAccess will still be valid.\n    function excludedCountriesUpdated() external\n    \t{\n    \trequire( msg.sender == address(dao), \"AccessManager.excludedCountriedUpdated only callable by the DAO\" );\n\n        geoVersion += 1;\n    \t}\n\n\n\t// Verify that the access request was signed by the authoratative signer.\n\t// Note that this is only a simplistic default mechanism and can be changed by the DAO at any time (either altering the regional restrictions themselves or replacing the access mechanism entirely).\n    function _verifyAccess(address wallet, bytes memory signature ) internal view returns (bool)\n    \t{\n\t\tbytes32 messageHash = keccak256(abi.encodePacked(block.chainid, geoVersion, wallet));\n\n\t\treturn SigningTools._verifySignature(messageHash, signature);\n    \t}\n\n\n\t// Grant access to the sender for the given geoVersion.\n\t// Requires the accompanying correct message signature from the offchain verifier.\n    function grantAccess(bytes calldata signature) external\n    \t{\n    \trequire( _verifyAccess(msg.sender, signature), \"Incorrect AccessManager.grantAccess signatory\" );\n\n        _walletsWithAccess[geoVersion][msg.sender] = true;\n\n        emit AccessGranted( msg.sender, geoVersion );\n    \t}\n\n\n\t// === VIEWS ===\n\n\t// Returns true if the wallet has access at the current geoVersion\n    function walletHasAccess(address wallet) external view returns (bool)\n    \t{\n        return _walletsWithAccess[geoVersion][wallet];\n    \t}\n}"
    },
    {
      "filename": "src/launch/BootstrapBallot.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\";\nimport \"../interfaces/IExchangeConfig.sol\";\nimport \"./interfaces/IBootstrapBallot.sol\";\nimport \"./interfaces/IAirdrop.sol\";\nimport \"../SigningTools.sol\";\n\n\n// Allows airdrop participants to vote on whether or not to start up the exchange and which countries should be initially excluded from access.\n\ncontract BootstrapBallot is IBootstrapBallot, ReentrancyGuard\n    {\n\tevent BallotFinalized(bool startExchange);\n\n    IExchangeConfig immutable public exchangeConfig;\n    IAirdrop immutable public airdrop;\n\tuint256 immutable public completionTimestamp;\n\n\tbool public ballotFinalized;\n\tbool public startExchangeApproved;\n\n\t// Ensures that voters can only vote once\n\tmapping(address=>bool) public hasVoted;\n\n\t// === VOTE TALLIES ===\n\t// Yes/No tallies on whether or not to start the exchange and distribute SALT to the ecosystem contracts\n\tuint256 public startExchangeYes;\n\tuint256 public startExchangeNo;\n\n\n\n\tconstructor( IExchangeConfig _exchangeConfig, IAirdrop _airdrop, uint256 ballotDuration )\n\t\t{\n\t\trequire( ballotDuration > 0, \"ballotDuration cannot be zero\" );\n\n\t\texchangeConfig = _exchangeConfig;\n\t\tairdrop = _airdrop;\n\n\t\tcompletionTimestamp = block.timestamp + ballotDuration;\n\t\t}\n\n\n\t// Cast a YES or NO vote to start up the exchange, distribute SALT and establish initial geo restrictions.\n\t// Votes cannot be changed once they are cast.\n\t// Requires a valid signature to signify that the msg.sender is authorized to vote (being whitelisted and the retweeting exchange launch posting - checked offchain)\n\tfunction vote( bool voteStartExchangeYes, bytes calldata signature ) external nonReentrant\n\t\t{\n\t\trequire( ! hasVoted[msg.sender], \"User already voted\" );\n\n\t\t// Verify the signature to confirm the user is authorized to vote\n\t\tbytes32 messageHash = keccak256(abi.encodePacked(block.chainid, msg.sender));\n\t\trequire(SigningTools._verifySignature(messageHash, signature), \"Incorrect BootstrapBallot.vote signatory\" );\n\n\t\tif ( voteStartExchangeYes )\n\t\t\tstartExchangeYes++;\n\t\telse\n\t\t\tstartExchangeNo++;\n\n\t\thasVoted[msg.sender] = true;\n\n\t\t// As the whitelisted user has retweeted the launch message and voted, they are authorized to the receive the airdrop.\n\t\tairdrop.authorizeWallet(msg.sender);\n\t\t}\n\n\n\t// Ensures that the completionTimestamp has been reached and then calls InitialDistribution.distributionApproved and DAO.initialGeoExclusion if the voters have approved the ballot.\n\tfunction finalizeBallot() external nonReentrant\n\t\t{\n\t\trequire( ! ballotFinalized, \"Ballot has already been finalized\" );\n\t\trequire( block.timestamp >= completionTimestamp, \"Ballot is not yet complete\" );\n\n\t\tif ( startExchangeYes > startExchangeNo )\n\t\t\t{\n\t\t\texchangeConfig.initialDistribution().distributionApproved();\n\t\t\texchangeConfig.dao().pools().startExchangeApproved();\n\n\t\t\tstartExchangeApproved = true;\n\t\t\t}\n\n\t\temit BallotFinalized(startExchangeApproved);\n\n\t\tballotFinalized = true;\n\t\t}\n\t}"
    }
  ]
}