{
  "Title": "[H-10] Wrong implementation of `NoYield.sol#emergencyWithdraw()`",
  "Content": "_Submitted by WatchPug, also found by 0x1f8b_\n\n<https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/NoYield.sol#L78-L83>\n\n```solidity\nfunction emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner returns (uint256 received) {\n    require(_wallet != address(0), 'cant burn');\n    uint256 amount = IERC20(_asset).balanceOf(address(this));\n    IERC20(_asset).safeTransfer(_wallet, received);\n    received = amount;\n}\n```\n\n`received` is not being assigned prior to L81, therefore, at L81, `received` is `0`.\n\nAs a result, the `emergencyWithdraw()` does not work, in essence.\n\n##### Recommendation\n\nChange to:\n\n```solidity\nfunction emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner returns (uint256 received) {\n    require(_wallet != address(0), 'cant burn');\n    received = IERC20(_asset).balanceOf(address(this));\n    IERC20(_asset).safeTransfer(_wallet, received);\n}\n```\n\n**[ritik99 (Sublime) confirmed](https://github.com/code-423n4/2021-12-sublime-findings/issues/115)** \n\n**[0xean (judge) commented](https://github.com/code-423n4/2021-12-sublime-findings/issues/115#issuecomment-1018669684):**\n > upgrading to High  sev based on assets being \"lost\" directly.  IE the emergency function will not work.\n> \n> `\n> 3 â€” High: Assets can be stolen/lost/compromised directly (or indirectly if there is a valid attack path that does not have hand-wavy hypotheticals).\n> `\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2021-12-sublime-contest",
  "Code": [
    {
      "filename": "contracts/yield/NoYield.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.7.6;\n\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '@openzeppelin/contracts/utils/ReentrancyGuard.sol';\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\n\nimport '../interfaces/IYield.sol';\nimport '../interfaces/Invest/ICEther.sol';\nimport '../interfaces/Invest/ICToken.sol';\n\n/**\n * @title Yield contract\n * @notice Implements the functions to lock/unlock tokens into available exchanges\n * @author Sublime\n **/\ncontract NoYield is IYield, Initializable, OwnableUpgradeable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    /**\n     * @notice stores the address of savings account contract\n     **/\n    address payable public savingsAccount;\n\n    /**\n     * @notice checks if contract is invoked by savings account\n     **/\n    modifier onlySavingsAccount() {\n        require(_msgSender() == savingsAccount, 'Invest: Only savings account can invoke');\n        _;\n    }\n\n    /**\n     * @notice used to initialize the variables in the contract\n     * @dev can only be called once\n     * @param _owner address of the owner\n     * @param _savingsAccount address of the savings account contract\n     **/\n    function initialize(address _owner, address payable _savingsAccount) external initializer {\n        __Ownable_init();\n        super.transferOwnership(_owner);\n\n        _updateSavingsAccount(_savingsAccount);\n    }\n\n    /**\n     * @notice used to query liquidity token for a given asset\n     * @param _asset address of the asset\n     * @return _tokenAddress address of the lqiudity token for the asset\n     **/\n    function liquidityToken(address _asset) external view override returns (address _tokenAddress) {\n        _tokenAddress = _asset;\n    }\n\n    /**\n     * @notice used to update savings account contract address\n     * @dev can only be called by owner\n     * @param _savingsAccount address of updated savings account contract\n     **/\n    function updateSavingsAccount(address payable _savingsAccount) external onlyOwner {\n        _updateSavingsAccount(_savingsAccount);\n    }\n\n    function _updateSavingsAccount(address payable _savingsAccount) internal {\n        require(_savingsAccount != address(0), 'Invest: zero address');\n        savingsAccount = _savingsAccount;\n        emit SavingsAccountUpdated(_savingsAccount);\n    }\n\n    /**\n     * @notice used to withdraw all tokens of a type in case of emergencies\n     * @dev only owner can withdraw\n     * @param _asset address of the token being withdrawn\n     * @param _wallet address to which tokens are withdrawn\n     */\n    function emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner returns (uint256 received) {\n        require(_wallet != address(0), 'cant burn');\n        uint256 amount = IERC20(_asset).balanceOf(address(this));\n        IERC20(_asset).safeTransfer(_wallet, received);\n        received = amount;\n    }\n\n    /**\n     * @notice Used to lock tokens in the protocol\n     * @dev Asset Tokens to be locked must be approved to this contract by user\n     * @param user the address of user\n     * @param asset the address of token to invest\n     * @param amount the amount of asset\n     * @return sharesReceived amount of shares received\n     **/\n    function lockTokens(\n        address user,\n        address asset,\n        uint256 amount\n    ) external payable override onlySavingsAccount nonReentrant returns (uint256 sharesReceived) {\n        require(amount != 0, 'Invest: amount');\n        if (asset != address(0)) {\n            IERC20(asset).safeTransferFrom(user, address(this), amount);\n        } else {\n            require(msg.value == amount, 'Invest: ETH amount');\n        }\n        sharesReceived = amount;\n        emit LockedTokens(user, asset, sharesReceived);\n    }\n\n    /**\n     * @notice Used to unlock tokens from the protocol\n     * @param asset the address of underlying token\n     * @param amount the amount of asset\n     * @return tokensReceived received amount of tokens received\n     **/\n    function unlockTokens(address asset, uint256 amount)\n        external\n        override\n        onlySavingsAccount\n        nonReentrant\n        returns (uint256 tokensReceived)\n    {\n        tokensReceived = _unlockTokens(asset, amount);\n    }\n\n    /**\n     * @notice Used to unlock shares\n     * @param asset the address of underlying token\n     * @param amount the amount of shares to unlock\n     * @return received amount of shares received\n     **/\n    function unlockShares(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256 received) {\n        received = _unlockTokens(asset, amount);\n    }\n\n    function _unlockTokens(address asset, uint256 amount) internal returns (uint256 received) {\n        require(amount != 0, 'Invest: amount');\n        received = amount;\n        if (asset == address(0)) {\n            (bool success, ) = savingsAccount.call{value: received}('');\n            require(success, 'Transfer failed');\n        } else {\n            IERC20(asset).safeTransfer(savingsAccount, received);\n        }\n        emit UnlockedTokens(asset, received);\n    }\n\n    /**\n     * @dev Used to get amount of underlying tokens for given number of shares\n     * @param shares the amount of shares\n     * @param asset the address of token locked\n     * @return amount amount of underlying tokens\n     **/\n    function getTokensForShares(uint256 shares, address asset) external pure override returns (uint256 amount) {\n        amount = shares;\n    }\n\n    /**\n     * @notice Used to get number of shares from an amount of underlying tokens\n     * @param amount the amount of tokens\n     * @param asset the address of token\n     * @return shares amount of shares for given tokens\n     **/\n    function getSharesForTokens(uint256 amount, address asset) external pure override returns (uint256 shares) {\n        shares = amount;\n    }\n}"
    }
  ]
}