{
  "Title": "Static Arrays Are Extendable",
  "Content": "Static arrays are [treated as dynamic](https://github.com/latticexyz/mud/blob/f6133591a86eb169a7b1b2b8d342733a887af610/packages/store/ts/codegen/userType.ts#L169) for storage purposes and [are cast](https://github.com/latticexyz/mud/blob/f6133591a86eb169a7b1b2b8d342733a887af610/packages/store/ts/codegen/userType.ts#L170-L171) to and from dynamic arrays as required. However, this means the corresponding dynamic field methods (`length`, `getItem`, `push`, `pop` and `update`) [are rendered](https://github.com/latticexyz/mud/blob/f6133591a86eb169a7b1b2b8d342733a887af610/packages/store/ts/codegen/field.ts#L80). Since `push` and `pop` change the array length, calling them could introduce unexpected behavior. In particular, when retrieving the contents of an array that is too short, an [empty array is returned](https://github.com/latticexyz/mud/blob/f6133591a86eb169a7b1b2b8d342733a887af610/packages/common/src/codegen/render-solidity/renderTypeHelpers.ts#L87) (and the remaining values are ignored). On the other hand, if the array is too long, it [is truncated](https://github.com/latticexyz/mud/blob/f6133591a86eb169a7b1b2b8d342733a887af610/packages/common/src/codegen/render-solidity/renderTypeHelpers.ts#L83) to the expected size.\n\n\nConsider skipping the `push` and `pop` functions for static arrays. In addition, consider implementing a simpler [`length` function](https://github.com/latticexyz/mud/blob/f6133591a86eb169a7b1b2b8d342733a887af610/packages/store/ts/codegen/field.ts#L92) that directly returns the known length. Lastly, in the interests of predictability, when [converting dynamic arrays to static ones](https://github.com/latticexyz/mud/blob/f6133591a86eb169a7b1b2b8d342733a887af610/packages/common/src/codegen/render-solidity/renderTypeHelpers.ts#L80), consider reverting whenever the lengths are inconsistent.\n\n\n***Update:** Resolved in [pull request #2175](https://github.com/latticexyz/mud/pull/2175).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "packages/store/ts/codegen/userType.ts",
      "content": "import {\n  AbiTypeToSchemaType,\n  getStaticByteLength,\n  SchemaType,\n  SchemaTypeToAbiType,\n} from \"@latticexyz/schema-type/deprecated\";\nimport { parseStaticArray } from \"@latticexyz/config\";\nimport { ImportDatum, RenderType, SolidityUserDefinedType } from \"@latticexyz/common/codegen\";\nimport { StoreConfig } from \"../config\";\n\nexport type UserTypeInfo = ReturnType<typeof getUserTypeInfo>;\n\n/**\n * Resolve an abi or user type into a SchemaType and RenderType\n */\nexport function resolveAbiOrUserType(\n  abiOrUserType: string,\n  config: StoreConfig,\n  solidityUserTypes: Record<string, SolidityUserDefinedType>\n): {\n  schemaType: SchemaType;\n  renderType: RenderType;\n} {\n  // abi types which directly mirror a SchemaType\n  if (abiOrUserType in AbiTypeToSchemaType) {\n    const schemaType = AbiTypeToSchemaType[abiOrUserType];\n    return {\n      schemaType,\n      renderType: getSchemaTypeInfo(schemaType),\n    };\n  }\n  // static arrays\n  const staticArray = parseStaticArray(abiOrUserType);\n  if (staticArray) {\n    if (staticArray.elementType in AbiTypeToSchemaType) {\n      return getStaticArrayTypeInfo(abiOrUserType, staticArray.elementType, staticArray.staticLength);\n    } else {\n      throw new Error(\"Static arrays of user types are not supported\");\n    }\n  }\n  // user types\n  return getUserTypeInfo(abiOrUserType, config, solidityUserTypes);\n}\n\n/**\n * Get the required import for SchemaType|userType (`undefined` means that no import is required)\n */\nexport function importForAbiOrUserType(\n  abiOrUserType: string,\n  usedInDirectory: string,\n  config: StoreConfig,\n  solidityUserTypes: Record<string, SolidityUserDefinedType>\n): ImportDatum | undefined {\n  // abi types which directly mirror a SchemaType\n  if (abiOrUserType in AbiTypeToSchemaType) {\n    return undefined;\n  }\n  // static arrays\n  const staticArray = parseStaticArray(abiOrUserType);\n  if (staticArray) {\n    return undefined;\n  }\n  // user-defined types in a user-provided file\n  if (abiOrUserType in solidityUserTypes) {\n    // these types can have a library name as their import symbol\n    const solidityUserType = solidityUserTypes[abiOrUserType];\n    const symbol = solidityUserType.importSymbol;\n    if (solidityUserType.isRelativePath) {\n      return {\n        symbol,\n        fromPath: solidityUserType.fromPath,\n        usedInPath: usedInDirectory,\n      };\n    } else {\n      return {\n        symbol,\n        path: solidityUserType.fromPath,\n      };\n    }\n  }\n  // other user types\n  return {\n    symbol: abiOrUserType,\n    fromPath: config.userTypesFilename,\n    usedInPath: usedInDirectory,\n  };\n}\n\nexport function getSchemaTypeInfo(schemaType: SchemaType): RenderType {\n  const staticByteLength = getStaticByteLength(schemaType);\n  const isDynamic = staticByteLength === 0;\n  const typeId = SchemaTypeToAbiType[schemaType];\n  return {\n    typeId,\n    typeWithLocation: isDynamic ? typeId + \" memory\" : typeId,\n    enumName: SchemaType[schemaType],\n    staticByteLength,\n    isDynamic,\n    typeWrap: \"\",\n    typeUnwrap: \"\",\n    internalTypeId: typeId,\n  };\n}\n\nexport function getUserTypeInfo(\n  userType: string,\n  config: StoreConfig,\n  solidityUserTypes: Record<string, SolidityUserDefinedType>\n): {\n  schemaType: SchemaType;\n  renderType: RenderType;\n} {\n  // enums\n  if (userType in config.enums) {\n    const schemaType = SchemaType.UINT8;\n    const staticByteLength = getStaticByteLength(schemaType);\n    const isDynamic = staticByteLength === 0;\n    const typeId = userType;\n    return {\n      schemaType,\n      renderType: {\n        typeId,\n        typeWithLocation: typeId,\n        enumName: SchemaType[schemaType],\n        staticByteLength,\n        isDynamic,\n        typeWrap: `${userType}`,\n        typeUnwrap: `uint8`,\n        internalTypeId: `${SchemaTypeToAbiType[schemaType]}`,\n      },\n    };\n  }\n  // user-defined types\n  if (userType in solidityUserTypes) {\n    if (!(userType in solidityUserTypes)) {\n      throw new Error(`User type \"${userType}\" not found in MUD config`);\n    }\n    const solidityUserType = solidityUserTypes[userType];\n    const typeId = solidityUserType.typeId;\n    const schemaType = AbiTypeToSchemaType[solidityUserType.internalTypeId];\n    return {\n      schemaType,\n      renderType: {\n        typeId,\n        typeWithLocation: typeId,\n        enumName: SchemaType[schemaType],\n        staticByteLength: getStaticByteLength(schemaType),\n        isDynamic: false,\n        typeWrap: `${typeId}.wrap`,\n        typeUnwrap: `${typeId}.unwrap`,\n        internalTypeId: `${solidityUserType.internalTypeId}`,\n      },\n    };\n  }\n  // invalid\n  throw new Error(`User type \"${userType}\" does not exist`);\n}\n\nfunction getStaticArrayTypeInfo(abiType: string, elementType: string, staticLength: number) {\n  const internalTypeId = elementType + \"[]\";\n  const schemaType = AbiTypeToSchemaType[internalTypeId];\n  return {\n    schemaType,\n    renderType: {\n      typeId: abiType,\n      typeWithLocation: `${abiType} memory`,\n      enumName: SchemaType[schemaType],\n      staticByteLength: 0,\n      isDynamic: true,\n      typeWrap: `toStaticArray_${elementType}_${staticLength}`,\n      typeUnwrap: `fromStaticArray_${elementType}_${staticLength}`,\n      typeWrappingData: {\n        kind: \"staticArray\",\n        elementType,\n        staticLength,\n      },\n      internalTypeId,\n    },\n  } as const;\n}"
    },
    {
      "filename": "packages/store/ts/codegen/field.ts",
      "content": "import {\n  renderArguments,\n  renderCommonData,\n  RenderField,\n  RenderType,\n  renderWithFieldSuffix,\n  renderWithStore,\n} from \"@latticexyz/common/codegen\";\nimport { RenderTableOptions } from \"./types\";\n\nexport function renderFieldMethods(options: RenderTableOptions) {\n  const storeArgument = options.storeArgument;\n  const { _typedTableId, _typedKeyArgs, _keyTupleDefinition } = renderCommonData(options);\n\n  let result = \"\";\n  for (const [schemaIndex, field] of options.fields.entries()) {\n    if (!options.withDynamicFieldMethods && field.isDynamic) {\n      continue;\n    }\n\n    // For dynamic fields, compute the field index relative to the end of the static fields\n    const _typedFieldName = `${field.typeWithLocation} ${field.name}`;\n\n    if (options.withGetters) {\n      result += renderWithFieldSuffix(options.withSuffixlessFieldMethods, field.name, (_methodNameSuffix) =>\n        renderWithStore(\n          storeArgument,\n          (_typedStore, _store, _commentSuffix, _untypedStore, _methodNamePrefix) => `\n            /**\n             * @notice Get ${field.name}${_commentSuffix}.\n             */\n            function ${_methodNamePrefix}get${_methodNameSuffix}(${renderArguments([\n            _typedStore,\n            _typedTableId,\n            _typedKeyArgs,\n          ])}) internal view returns (${_typedFieldName}) {\n              ${_keyTupleDefinition}\n              ${\n                field.isDynamic\n                  ? `bytes memory _blob = ${_store}.getDynamicField(\n                      _tableId,\n                      _keyTuple,\n                      ${schemaIndex - options.staticFields.length}\n                    );`\n                  : `bytes32 _blob = ${_store}.getStaticField(\n                      _tableId,\n                      _keyTuple,\n                      ${schemaIndex},\n                      _fieldLayout\n                    );`\n              }\n              return ${renderDecodeFieldSingle(field)};\n            }\n        `\n        )\n      );\n    }\n\n    result += renderWithFieldSuffix(options.withSuffixlessFieldMethods, field.name, (_methodNameSuffix) =>\n      renderWithStore(storeArgument, (_typedStore, _store, _commentSuffix, _untypedStore, _methodNamePrefix) => {\n        const externalArguments = renderArguments([_typedStore, _typedTableId, _typedKeyArgs, _typedFieldName]);\n        const setFieldMethod = field.isDynamic ? \"setDynamicField\" : \"setStaticField\";\n        const encodeFieldSingle = renderEncodeFieldSingle(field);\n        const internalArguments = field.isDynamic\n          ? `_tableId, _keyTuple, ${schemaIndex - options.staticFields.length}, ${encodeFieldSingle}`\n          : `_tableId, _keyTuple, ${schemaIndex}, ${encodeFieldSingle}, _fieldLayout`;\n\n        return `\n          /**\n           * @notice Set ${field.name}${_commentSuffix}.\n           */\n          function ${_methodNamePrefix}set${_methodNameSuffix}(${externalArguments}) internal {\n            ${_keyTupleDefinition}\n            ${_store}.${setFieldMethod}(${internalArguments});\n          }\n        `;\n      })\n    );\n\n    if (field.isDynamic) {\n      const portionData = fieldPortionData(field);\n      const dynamicSchemaIndex = schemaIndex - options.staticFields.length;\n\n      if (options.withGetters) {\n        result += renderWithFieldSuffix(options.withSuffixlessFieldMethods, field.name, (_methodNameSuffix) =>\n          renderWithStore(\n            storeArgument,\n            (_typedStore, _store, _commentSuffix, _untypedStore, _methodNamePrefix) => `\n              /**\n               * @notice Get the length of ${field.name}${_commentSuffix}.\n               */\n              function ${_methodNamePrefix}length${_methodNameSuffix}(${renderArguments([\n              _typedStore,\n              _typedTableId,\n              _typedKeyArgs,\n            ])}) internal view returns (uint256) {\n                ${_keyTupleDefinition}\n                uint256 _byteLength = ${_store}.getDynamicFieldLength(_tableId, _keyTuple, ${dynamicSchemaIndex});\n                unchecked {\n                  return _byteLength / ${portionData.elementLength};\n                }\n              }\n          `\n          )\n        );\n\n        result += renderWithFieldSuffix(options.withSuffixlessFieldMethods, field.name, (_methodNameSuffix) =>\n          renderWithStore(\n            storeArgument,\n            (_typedStore, _store, _commentSuffix, _untypedStore, _methodNamePrefix) => `\n              /**\n               * @notice Get an item of ${field.name}${_commentSuffix}.\n               * @dev Reverts with Store_IndexOutOfBounds if \\`_index\\` is out of bounds for the array.\n              */\n              function ${_methodNamePrefix}getItem${_methodNameSuffix}(${renderArguments([\n              _typedStore,\n              _typedTableId,\n              _typedKeyArgs,\n              \"uint256 _index\",\n            ])}) internal view returns (${portionData.typeWithLocation}) {\n              ${_keyTupleDefinition}\n              unchecked {\n                bytes memory _blob = ${_store}.getDynamicFieldSlice(\n                  _tableId,\n                  _keyTuple,\n                  ${dynamicSchemaIndex},\n                  _index * ${portionData.elementLength},\n                  (_index + 1) * ${portionData.elementLength}\n                  );\n                  return ${portionData.decoded};\n                }\n              }\n            `\n          )\n        );\n      }\n\n      result += renderWithFieldSuffix(options.withSuffixlessFieldMethods, field.name, (_methodNameSuffix) =>\n        renderWithStore(\n          storeArgument,\n          (_typedStore, _store, _commentSuffix, _untypedStore, _methodNamePrefix) => `\n              /**\n               * @notice Push ${portionData.title} to ${field.name}${_commentSuffix}.\n               */\n              function ${_methodNamePrefix}push${_methodNameSuffix}(${renderArguments([\n            _typedStore,\n            _typedTableId,\n            _typedKeyArgs,\n            `${portionData.typeWithLocation} ${portionData.name}`,\n          ])}) internal {\n              ${_keyTupleDefinition}\n              ${_store}.pushToDynamicField(_tableId, _keyTuple, ${dynamicSchemaIndex}, ${portionData.encoded});\n            }\n            `\n        )\n      );\n\n      result += renderWithFieldSuffix(options.withSuffixlessFieldMethods, field.name, (_methodNameSuffix) =>\n        renderWithStore(\n          storeArgument,\n          (_typedStore, _store, _commentSuffix, _untypedStore, _methodNamePrefix) => `\n            /**\n             * @notice Pop ${portionData.title} from ${field.name}${_commentSuffix}.\n             */\n            function ${_methodNamePrefix}pop${_methodNameSuffix}(${renderArguments([\n            _typedStore,\n            _typedTableId,\n            _typedKeyArgs,\n          ])}) internal {\n              ${_keyTupleDefinition}\n              ${_store}.popFromDynamicField(_tableId, _keyTuple, ${dynamicSchemaIndex}, ${portionData.elementLength});\n            }\n          `\n        )\n      );\n\n      result += renderWithFieldSuffix(options.withSuffixlessFieldMethods, field.name, (_methodNameSuffix) =>\n        renderWithStore(storeArgument, (_typedStore, _store, _commentSuffix, _untypedStore, _methodNamePrefix) => {\n          const externalArguments = renderArguments([\n            _typedStore,\n            _typedTableId,\n            _typedKeyArgs,\n            \"uint256 _index\",\n            `${portionData.typeWithLocation} ${portionData.name}`,\n          ]);\n\n          const internalArguments = `\n            _tableId,\n            _keyTuple,\n            ${dynamicSchemaIndex},\n            uint40(_index * ${portionData.elementLength}),\n            uint40(_encoded.length),\n            _encoded \n          `;\n\n          return `\n            /**\n             * @notice Update ${portionData.title} of ${field.name}${_commentSuffix} at \\`_index\\`.\n             */\n            function ${_methodNamePrefix}update${_methodNameSuffix}(${externalArguments}) internal {\n              ${_keyTupleDefinition}\n              unchecked {\n                bytes memory _encoded = ${portionData.encoded};\n                ${_store}.spliceDynamicData(${internalArguments});\n              }\n            }\n          `;\n        })\n      );\n    }\n  }\n  return result;\n}\n\nexport function renderEncodeFieldSingle(field: RenderField) {\n  let func;\n  if (field.arrayElement) {\n    func = \"EncodeArray.encode\";\n  } else if (field.isDynamic) {\n    func = \"bytes\";\n  } else {\n    func = \"abi.encodePacked\";\n  }\n  return `${func}(${field.typeUnwrap}(${field.name}))`;\n}\n\nexport function renderDecodeValueType(field: RenderType, offset: number) {\n  const { staticByteLength } = field;\n\n  const innerSlice = `Bytes.slice${staticByteLength}(_blob, ${offset})`;\n\n  return renderCastStaticBytesToType(field, innerSlice);\n}\n\nfunction renderCastStaticBytesToType(field: RenderType, staticBytes: string) {\n  const { staticByteLength, internalTypeId } = field;\n  const bits = staticByteLength * 8;\n\n  let result;\n  if (internalTypeId.match(/^uint\\d{1,3}$/) || internalTypeId === \"address\") {\n    result = `${internalTypeId}(${staticBytes})`;\n  } else if (internalTypeId.match(/^int\\d{1,3}$/)) {\n    result = `${internalTypeId}(uint${bits}(${staticBytes}))`;\n  } else if (internalTypeId.match(/^bytes\\d{1,2}$/)) {\n    result = staticBytes;\n  } else if (internalTypeId === \"bool\") {\n    result = `_toBool(uint8(${staticBytes}))`;\n  } else {\n    throw new Error(`Unknown value type id ${internalTypeId}`);\n  }\n  return `${field.typeWrap}(${result})`;\n}\n\n/** bytes/string are dynamic, but aren't really arrays */\nfunction fieldPortionData(field: RenderField) {\n  const methodNameSuffix = \"\";\n  if (field.arrayElement) {\n    const name = \"_element\";\n    const elementFieldData = { ...field.arrayElement, arrayElement: undefined, name, methodNameSuffix };\n    return {\n      typeWithLocation: field.arrayElement.typeWithLocation,\n      name: \"_element\",\n      encoded: renderEncodeFieldSingle(elementFieldData),\n      decoded: renderDecodeFieldSingle(elementFieldData),\n      title: \"an element\",\n      elementLength: field.arrayElement.staticByteLength,\n    };\n  } else {\n    const name = \"_slice\";\n    const elementFieldData = { ...field, name, methodNameSuffix };\n    return {\n      typeWithLocation: `${field.typeId} memory`,\n      name,\n      encoded: renderEncodeFieldSingle(elementFieldData),\n      decoded: renderDecodeFieldSingle(elementFieldData),\n      title: \"a slice\",\n      elementLength: 1,\n    };\n  }\n}\n\nfunction renderDecodeFieldSingle(field: RenderField) {\n  const { isDynamic, arrayElement } = field;\n  if (arrayElement) {\n    // arrays\n    return `${field.typeWrap}(\n      SliceLib.getSubslice(_blob, 0, _blob.length).decodeArray_${arrayElement.internalTypeId}()\n    )`;\n  } else if (isDynamic) {\n    // bytes/string\n    return `${field.typeWrap}(${field.internalTypeId}(_blob))`;\n  } else {\n    return renderCastStaticBytesToType(field, `bytes${field.staticByteLength}(_blob)`);\n  }\n}"
    }
  ]
}