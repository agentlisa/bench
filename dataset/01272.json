{
  "Title": "Unused Function",
  "Content": "The [`checkBalance`](https://github.com/OriginProtocol/origin-dollar/blob/eb11498c376b65696c90981757221b076d6226aa/contracts/contracts/strategies/balancer/BaseBalancerStrategy.sol#L202) function is only used in tests.\n\n\nConsider removing it from the production code in order to improve readability.\n\n\n***Update:** Acknowledged, will resolve. The Origin team stated:*\n\n\n\n> *We plan on using this read-only function in the future since it will be a much more gas-efficient way of calculating the vault's `totalValue`.*\n\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/contracts/strategies/balancer/BaseBalancerStrategy.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title OETH Base Balancer Abstract Strategy\n * @author Origin Protocol Inc\n */\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20, InitializableAbstractStrategy } from \"../../utils/InitializableAbstractStrategy.sol\";\nimport { IBalancerVault } from \"../../interfaces/balancer/IBalancerVault.sol\";\nimport { IRateProvider } from \"../../interfaces/balancer/IRateProvider.sol\";\nimport { VaultReentrancyLib } from \"./VaultReentrancyLib.sol\";\nimport { IOracle } from \"../../interfaces/IOracle.sol\";\nimport { IVault } from \"../../interfaces/IVault.sol\";\nimport { IRETH } from \"../../interfaces/IRETH.sol\";\nimport { IWstETH } from \"../../interfaces/IWstETH.sol\";\nimport { IERC4626 } from \"../../../lib/openzeppelin/interfaces/IERC4626.sol\";\nimport { StableMath } from \"../../utils/StableMath.sol\";\n\nabstract contract BaseBalancerStrategy is InitializableAbstractStrategy {\n    using SafeERC20 for IERC20;\n    using StableMath for uint256;\n\n    address public immutable rETH;\n    address public immutable stETH;\n    address public immutable wstETH;\n    address public immutable frxETH;\n    address public immutable sfrxETH;\n\n    /// @notice Address of the Balancer vault\n    IBalancerVault public immutable balancerVault;\n    /// @notice Balancer pool identifier\n    bytes32 public immutable balancerPoolId;\n\n    // Max withdrawal slippage denominated in 1e18 (1e18 == 100%)\n    uint256 public maxWithdrawalSlippage;\n    // Max deposit slippage denominated in 1e18 (1e18 == 100%)\n    uint256 public maxDepositSlippage;\n\n    int256[48] private __reserved;\n\n    struct BaseBalancerConfig {\n        address rEthAddress; // Address of the rETH token\n        address stEthAddress; // Address of the stETH token\n        address wstEthAddress; // Address of the wstETH token\n        address frxEthAddress; // Address of the frxEth token\n        address sfrxEthAddress; // Address of the sfrxEth token\n        address balancerVaultAddress; // Address of the Balancer vault\n        bytes32 balancerPoolId; // Balancer pool identifier\n    }\n\n    event MaxWithdrawalSlippageUpdated(\n        uint256 _prevMaxSlippagePercentage,\n        uint256 _newMaxSlippagePercentage\n    );\n    event MaxDepositSlippageUpdated(\n        uint256 _prevMaxSlippagePercentage,\n        uint256 _newMaxSlippagePercentage\n    );\n\n    /**\n     * @dev Ensure we are not in a Vault context when this function is called, by attempting a no-op internal\n     * balance operation. If we are already in a Vault transaction (e.g., a swap, join, or exit), the Vault's\n     * reentrancy protection will cause this function to revert.\n     *\n     * Use this modifier with any function that can cause a state change in a pool and is either public itself,\n     * or called by a public function *outside* a Vault operation (e.g., join, exit, or swap).\n     *\n     * This is to protect against Balancer's read-only re-entrancy vulnerability:\n     * https://www.notion.so/originprotocol/Balancer-read-only-reentrancy-c686e72c82414ef18fa34312bb02e11b\n     */\n    modifier whenNotInBalancerVaultContext() {\n        VaultReentrancyLib.ensureNotInVaultContext(balancerVault);\n        _;\n    }\n\n    constructor(BaseBalancerConfig memory _balancerConfig) {\n        rETH = _balancerConfig.rEthAddress;\n        stETH = _balancerConfig.stEthAddress;\n        wstETH = _balancerConfig.wstEthAddress;\n        frxETH = _balancerConfig.frxEthAddress;\n        sfrxETH = _balancerConfig.sfrxEthAddress;\n\n        balancerVault = IBalancerVault(_balancerConfig.balancerVaultAddress);\n        balancerPoolId = _balancerConfig.balancerPoolId;\n    }\n\n    /**\n     * Initializer for setting up strategy internal state. This overrides the\n     * InitializableAbstractStrategy initializer as Balancer's strategies don't fit\n     * well within that abstraction.\n     * @param _rewardTokenAddresses Address of BAL & AURA\n     * @param _assets Addresses of supported assets. MUST be passed in the same\n     *                order as returned by coins on the pool contract, i.e.\n     *                WETH, stETH\n     * @param _pTokens Platform Token corresponding addresses\n     */\n    function initialize(\n        address[] calldata _rewardTokenAddresses, // BAL & AURA\n        address[] calldata _assets,\n        address[] calldata _pTokens\n    ) external override onlyGovernor initializer {\n        maxWithdrawalSlippage = 1e15;\n        maxDepositSlippage = 1e15;\n\n        emit MaxWithdrawalSlippageUpdated(0, maxWithdrawalSlippage);\n        emit MaxDepositSlippageUpdated(0, maxDepositSlippage);\n\n        IERC20[] memory poolAssets = getPoolAssets();\n        require(\n            poolAssets.length == _assets.length,\n            \"Pool assets length mismatch\"\n        );\n        for (uint256 i = 0; i < _assets.length; ++i) {\n            (address asset, ) = fromPoolAsset(address(poolAssets[i]), 0);\n            require(_assets[i] == asset, \"Pool assets mismatch\");\n        }\n\n        super._initialize(_rewardTokenAddresses, _assets, _pTokens);\n        _approveBase();\n    }\n\n    /**\n     * @notice Returns bool indicating whether asset is supported by strategy\n     * @param _asset Address of the asset\n     */\n    function supportsAsset(address _asset)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return assetToPToken[_asset] != address(0);\n    }\n\n    /**\n     * @notice Get strategy's share of an assets in the Balancer pool.\n     * This is not denominated in OUSD/ETH value of the assets in the Balancer pool.\n     * @param _asset  Address of the Vault collateral asset\n     * @return amount  the amount of vault collateral assets\n     *\n     * IMPORTANT if this function is overridden it needs to have a whenNotInBalancerVaultContext\n     * modifier on it or it is susceptible to read-only re-entrancy attack\n     *\n     * @dev it is important that this function is not affected by reporting inflated\n     * values of assets in case of any pool manipulation. Such a manipulation could easily\n     * exploit the protocol by:\n     *  - minting OETH\n     *  - tilting Balancer pool to report higher balances of assets\n     *  - rebasing() -> all that extra token balances get distributed to OETH holders\n     *  - tilting pool back\n     *  - redeeming OETH\n     */\n    function checkBalance(address _asset)\n        external\n        view\n        virtual\n        override\n        whenNotInBalancerVaultContext\n        returns (uint256 amount)\n    {\n        uint256 bptBalance = _getBalancerPoolTokens();\n\n        /* To calculate the worth of queried asset:\n         *  - assume that all tokens normalized to their ETH value have an equal split balance\n         *    in the pool when it is balanced\n         *  - multiply the BPT amount with the bpt rate to get the ETH denominated amount\n         *    of strategy's holdings\n         *  - divide that by the number of tokens we support in the pool to get ETH denominated\n         *    amount that is applicable to each supported token in the pool.\n         *\n         *    It would be possible to support only 1 asset in the pool (and be exposed to all\n         *    the assets while holding BPT tokens) and deposit/withdraw/checkBalance using only\n         *    that asset. TBD: changes to other functions still required if we ever decide to\n         *    go with such configuration.\n         */\n        amount = (bptBalance.mulTruncate(\n            IRateProvider(platformAddress).getRate()\n        ) / assetsMapped.length);\n\n        /* If the pool asset is equal to (strategy )_asset it means that a rate\n         * provider for that asset exists and that asset is not necessarily\n         * pegged to a unit (ETH).\n         *\n         * Because this function returns the balance of the asset and is not denominated in\n         * ETH units we need to convert the ETH denominated amount to asset amount.\n         */\n        if (toPoolAsset(_asset) == _asset) {\n            amount = amount.divPrecisely(getRateProviderRate(_asset));\n        }\n    }\n\n    /**\n     * @notice Returns the value of all assets managed by this strategy.\n     * Uses the Balancer pool's rate (virtual price) to convert the strategy's\n     * Balancer Pool Tokens (BPT) to ETH value.\n     * @return value The ETH value\n     *\n     * IMPORTANT if this function is overridden it needs to have a whenNotInBalancerVaultContext\n     * modifier on it or it is susceptible to read-only re-entrancy attack\n     */\n    function checkBalance()\n        external\n        view\n        virtual\n        whenNotInBalancerVaultContext\n        returns (uint256 value)\n    {\n        uint256 bptBalance = _getBalancerPoolTokens();\n\n        // Convert BPT to ETH value\n        value = bptBalance.mulTruncate(\n            IRateProvider(platformAddress).getRate()\n        );\n    }\n\n    /// @notice Balancer Pool Tokens (BPT) in the Balancer pool.\n    function _getBalancerPoolTokens()\n        internal\n        view\n        virtual\n        returns (uint256 balancerPoolTokens)\n    {\n        balancerPoolTokens = IERC20(platformAddress).balanceOf(address(this));\n    }\n\n    /* solhint-disable max-line-length */\n    /**\n     * @notice BPT price is calculated by dividing the pool (sometimes wrapped) market price by the\n     * rateProviderRate of that asset. To get BPT expected we need to multiply that by underlying\n     * asset amount divided by BPT token rate. BPT token rate is similar to Curve's virtual_price\n     * and expresses how much has the price of BPT appreciated in relation to the underlying assets.\n     *\n     * @dev\n     * bptPrice = pool_asset_oracle_price / pool_asset_rate\n     *\n     * Since we only have oracle prices for the unwrapped version of the assets the equation\n     * turns into:\n     *\n     * bptPrice = from_pool_token(asset_amount).amount * oracle_price / pool_asset_rate\n     *\n     * bptExpected = bptPrice(in relation to specified asset) * asset_amount / BPT_token_rate\n     *\n     * and since from_pool_token(asset_amount).amount and pool_asset_rate cancel each-other out\n     * this makes the final equation:\n     *\n     * bptExpected = oracle_price * asset_amount / BPT_token_rate\n     *\n     * more explanation here:\n     * https://www.notion.so/originprotocol/Support-Balancer-OETH-strategy-9becdea132704e588782a919d7d471eb?pvs=4#382834f9815e46a7937f3acca0f637c5\n     */\n    /* solhint-enable max-line-length */\n    function getBPTExpected(address _asset, uint256 _amount)\n        internal\n        view\n        virtual\n        returns (uint256 bptExpected)\n    {\n        address priceProvider = IVault(vaultAddress).priceProvider();\n        uint256 strategyAssetMarketPrice = IOracle(priceProvider).price(_asset);\n        uint256 bptRate = IRateProvider(platformAddress).getRate();\n\n        bptExpected = _amount\n            .mulTruncate(strategyAssetMarketPrice)\n            .divPrecisely(bptRate);\n    }\n\n    function getBPTExpected(address[] memory _assets, uint256[] memory _amounts)\n        internal\n        view\n        virtual\n        returns (uint256 bptExpected)\n    {\n        // Get the oracle from the OETH Vault\n        address priceProvider = IVault(vaultAddress).priceProvider();\n\n        for (uint256 i = 0; i < _assets.length; ++i) {\n            uint256 strategyAssetMarketPrice = IOracle(priceProvider).price(\n                _assets[i]\n            );\n            // convert asset amount to ETH amount\n            bptExpected =\n                bptExpected +\n                _amounts[i].mulTruncate(strategyAssetMarketPrice);\n        }\n\n        uint256 bptRate = IRateProvider(platformAddress).getRate();\n        // Convert ETH amount to BPT amount\n        bptExpected = bptExpected.divPrecisely(bptRate);\n    }\n\n    function _lpDepositAll() internal virtual;\n\n    function _lpWithdraw(uint256 numBPTTokens) internal virtual;\n\n    function _lpWithdrawAll() internal virtual;\n\n    /**\n     * @notice Balancer returns assets and rateProviders for corresponding assets ordered\n     * by numerical order.\n     */\n    function getPoolAssets() internal view returns (IERC20[] memory assets) {\n        (assets, , ) = balancerVault.getPoolTokens(balancerPoolId);\n    }\n\n    /**\n     * @dev If an asset is rebasing the Balancer pools have a wrapped versions of assets\n     * that the strategy supports. This function converts the pool(wrapped) asset\n     * and corresponding amount to strategy asset.\n     */\n    function toPoolAsset(address asset, uint256 amount)\n        internal\n        view\n        returns (address poolAsset, uint256 poolAmount)\n    {\n        if (asset == stETH) {\n            poolAsset = wstETH;\n            if (amount > 0) {\n                poolAmount = IWstETH(wstETH).getWstETHByStETH(amount);\n            }\n        } else if (asset == frxETH) {\n            poolAsset = sfrxETH;\n            if (amount > 0) {\n                poolAmount = IERC4626(sfrxETH).convertToShares(amount);\n            }\n        } else {\n            poolAsset = asset;\n            poolAmount = amount;\n        }\n    }\n\n    /**\n     * @dev Converts a Vault collateral asset to a Balancer pool asset.\n     * stETH becomes wstETH, frxETH becomes sfrxETH and everything else stays the same.\n     * @param asset Address of the Vault collateral asset.\n     * @return Address of the Balancer pool asset.\n     */\n    function toPoolAsset(address asset) internal view returns (address) {\n        if (asset == stETH) {\n            return wstETH;\n        } else if (asset == frxETH) {\n            return sfrxETH;\n        }\n        return asset;\n    }\n\n    /**\n     * @dev Converts rebasing asset to its wrapped counterpart.\n     */\n    function wrapPoolAsset(address asset, uint256 amount)\n        internal\n        returns (address wrappedAsset, uint256 wrappedAmount)\n    {\n        if (asset == stETH) {\n            wrappedAsset = wstETH;\n            if (amount > 0) {\n                wrappedAmount = IWstETH(wstETH).wrap(amount);\n            }\n        } else if (asset == frxETH) {\n            wrappedAsset = sfrxETH;\n            if (amount > 0) {\n                wrappedAmount = IERC4626(sfrxETH).deposit(\n                    amount,\n                    address(this)\n                );\n            }\n        } else {\n            wrappedAsset = asset;\n            wrappedAmount = amount;\n        }\n    }\n\n    /**\n     * @dev Converts wrapped asset to its rebasing counterpart.\n     */\n    function unwrapPoolAsset(address asset, uint256 amount)\n        internal\n        returns (uint256 unwrappedAmount)\n    {\n        if (asset == stETH) {\n            unwrappedAmount = IWstETH(wstETH).unwrap(amount);\n        } else if (asset == frxETH) {\n            unwrappedAmount = IERC4626(sfrxETH).withdraw(\n                amount,\n                address(this),\n                address(this)\n            );\n        } else {\n            unwrappedAmount = amount;\n        }\n    }\n\n    /**\n     * @dev If an asset is rebasing the Balancer pools have a wrapped versions of assets\n     * that the strategy supports. This function converts the rebasing strategy asset\n     * and corresponding amount to wrapped(pool) asset.\n     */\n    function fromPoolAsset(address poolAsset, uint256 poolAmount)\n        internal\n        view\n        returns (address asset, uint256 amount)\n    {\n        amount = 0;\n        if (poolAsset == wstETH) {\n            asset = stETH;\n            if (poolAmount > 0) {\n                amount = IWstETH(wstETH).getStETHByWstETH(poolAmount);\n            }\n        } else if (poolAsset == sfrxETH) {\n            asset = frxETH;\n            if (poolAmount > 0) {\n                amount = IERC4626(sfrxETH).convertToAssets(poolAmount);\n            }\n        } else {\n            asset = poolAsset;\n            amount = poolAmount;\n        }\n    }\n\n    function fromPoolAsset(address poolAsset)\n        internal\n        view\n        returns (address asset)\n    {\n        if (poolAsset == wstETH) {\n            asset = stETH;\n        } else if (poolAsset == sfrxETH) {\n            asset = frxETH;\n        } else {\n            asset = poolAsset;\n        }\n    }\n\n    /**\n     * @notice Sets max withdrawal slippage that is considered when removing\n     * liquidity from Balancer pools.\n     * @param _maxWithdrawalSlippage Max withdrawal slippage denominated in\n     *        wad (number with 18 decimals): 1e18 == 100%, 1e16 == 1%\n     *\n     * IMPORTANT Minimum maxWithdrawalSlippage should actually be 0.1% (1e15)\n     * for production usage. Contract allows as low value as 0% for confirming\n     * correct behavior in test suite.\n     */\n    function setMaxWithdrawalSlippage(uint256 _maxWithdrawalSlippage)\n        external\n        onlyVaultOrGovernorOrStrategist\n    {\n        require(\n            _maxWithdrawalSlippage <= 1e18,\n            \"Max withdrawal slippage needs to be between 0% - 100%\"\n        );\n        emit MaxWithdrawalSlippageUpdated(\n            maxWithdrawalSlippage,\n            _maxWithdrawalSlippage\n        );\n        maxWithdrawalSlippage = _maxWithdrawalSlippage;\n    }\n\n    /**\n     * @notice Sets max deposit slippage that is considered when adding\n     * liquidity to Balancer pools.\n     * @param _maxDepositSlippage Max deposit slippage denominated in\n     *        wad (number with 18 decimals): 1e18 == 100%, 1e16 == 1%\n     *\n     * IMPORTANT Minimum maxDepositSlippage should actually be 0.1% (1e15)\n     * for production usage. Contract allows as low value as 0% for confirming\n     * correct behavior in test suite.\n     */\n    function setMaxDepositSlippage(uint256 _maxDepositSlippage)\n        external\n        onlyVaultOrGovernorOrStrategist\n    {\n        require(\n            _maxDepositSlippage <= 1e18,\n            \"Max deposit slippage needs to be between 0% - 100%\"\n        );\n        emit MaxDepositSlippageUpdated(maxDepositSlippage, _maxDepositSlippage);\n        maxDepositSlippage = _maxDepositSlippage;\n    }\n\n    function _approveBase() internal virtual {\n        IERC20 pToken = IERC20(platformAddress);\n        // Balancer vault for BPT token (required for removing liquidity)\n        pToken.safeApprove(address(balancerVault), type(uint256).max);\n    }\n\n    function getRateProviderRate(address _asset)\n        internal\n        view\n        virtual\n        returns (uint256);\n}"
    }
  ]
}