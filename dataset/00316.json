{
  "Title": "M-9: Vault checkpoints slightly incorrect conversion from assets to shares leads to slow loss of funds for long-time vault depositors",
  "Content": "# Issue M-9: Vault checkpoints slightly incorrect conversion from assets to shares leads to slow loss of funds for long-time vault depositors \n\nSource: https://github.com/sherlock-audit/2024-02-perennial-v2-3-judging/issues/25 \n\n## Found by \npanprog\n## Summary\n\nWhen vault checkpoints convert assets to shares (specifically used to calculate user's shares for their deposit), it uses the following formula:\n`shares = (assets[before fee] - settlementFee) * checkpoint.shares/checkpoint.assets * (deposit + redeem - tradeFee) / (deposit + redeem)`\n\n`settlementFee` in this formula is taken into account slightly incorrectly: in actual market collateral calculations, both settlement fee and trade fee are subtracted from collateral, but this formula basically multiplies `1 - settlement fee percentage` by `1 - trade fee percentage`, which is slightly different and adds the calculation error = `settlement fee percentage * trade fee percentage`.\n\nThis is the scenario to better understand the issue:\n1. Linear fee = 2%, settlement fee = $1\n2. User1 deposits $100 into the vault (linear fee = $2, settlement fee = $1)\n3. Vault assets = $97 (due to fees), User1 shares = 100\n4. User2 deposits $100 into the vault (linear fee = $2, settlement fee = $1)\n5. Vault assets = $194, User1 shares = 100, but User2 shares = 100.02, meaning User1's share value has slightly fallen due to a later deposit.\n\nThis is the calculation for User2 shares:\n`shares = ($100 - $1) * 100/$97 * ($100 - $2) / $100 = $99 * 100/$97 * $98/$100 = $99 * 98/$97 = 100.02`\n\nThe extra 0.02 this user has received is because the `tradeFee` is taken from the amount after settlement fee ($99) rather than full amount as it should ($100). This difference (`settlementFee * tradeFee = $0.02`) is unfair amount earned by User2 and loss of funds for User1.\n\nWhen redeeming, the formula for shares -> assets vault checkpoint conversion is correct and the correct amount is redeemed. \n\nThis issue leads to all vault depositors slowly losing share value with each deposit, and since no value is gained when redeeming, continuous deposits and redeems will lead to all long-time depositors continuously losing their funds.\n\n## Vulnerability Detail\n\nThis is the formula for vault checkpoint `toSharesGlobal`:\n```solidity\nfunction toSharesGlobal(Checkpoint memory self, UFixed6 assets) internal pure returns (UFixed6) {\n    // vault is fresh, use par value\n    if (self.shares.isZero()) return assets;\n\n    // if vault is insolvent, default to par value\n    return  self.assets.lte(Fixed6Lib.ZERO) ? assets : _toShares(self, _withoutSettlementFeeGlobal(self, assets));\n}\n\nfunction _toShares(Checkpoint memory self, UFixed6 assets) private pure returns (UFixed6) {\n    UFixed6 selfAssets = UFixed6Lib.unsafeFrom(self.assets);\n    return _withSpread(self, assets.muldiv(self.shares, selfAssets));\n}\n\nfunction _withSpread(Checkpoint memory self, UFixed6 amount) private pure returns (UFixed6) {\n    UFixed6 selfAssets = UFixed6Lib.unsafeFrom(self.assets);\n    UFixed6 totalAmount = self.deposit.add(self.redemption.muldiv(selfAssets, self.shares));\n    UFixed6 totalAmountIncludingFee = UFixed6Lib.unsafeFrom(Fixed6Lib.from(totalAmount).sub(self.tradeFee));\n\n    return totalAmount.isZero() ?\n        amount :\n        amount.muldiv(totalAmountIncludingFee, totalAmount);\n}\n\nfunction _withoutSettlementFeeGlobal(Checkpoint memory self, UFixed6 amount) private pure returns (UFixed6) {\n    return _withoutSettlementFee(amount, self.settlementFee);\n}\n\nfunction _withoutSettlementFee(UFixed6 amount, UFixed6 settlementFee) private pure returns (UFixed6) {\n    return amount.unsafeSub(settlementFee);\n}\n```\n\nThis code translates to a formula shown above, i.e. it first subtracts settlement fee from the assets (`withoutSettlementFeeGlobal`), then multiplies this by checkpoint's share value in `_toShares` (`*checkpoint.shares/checkpoint.assets`), and then multiplies this by trade fee adjustment in `_withSpread` (`*(deposit+redeem-tradeFee) / (deposit+redeem)`). Here is the formula again:\n`shares = (assets[before fee] - settlementFee) * checkpoint.shares/checkpoint.assets * (deposit + redeem - tradeFee) / (deposit + redeem)`\n\nAs shown above, the formula is incorrect, because it basically does the following:\n`user_assets = (deposit - settlementFee) * (deposit - tradeFee)/deposit = deposit * (1 - settlementFeePct) * (1 - tradeFeePct)`\n\nBut the actual user collateral after fees is calculated as:\n`user_assets = deposit - settlementFee - tradeFee = deposit * (1 - settlementFeePct - tradeFeePct)`\n\nIf we subtract the actual collateral from the formula used in checkpoint, we get the error:\n`error = deposit * ((1 - settlementFeePct) * (1 - tradeFeePct) - (1 - settlementFeePct - tradeFeePct))`\n`error = deposit * settlementFeePct * tradeFeePct`\n`error = settlementFee * tradeFeePct`\n\nSo this is systematic error, which inflates the shares given to users with any deposit by fixed amount of `settlementFee * tradeFeePct`\n\n## Impact\n\nAny vault deposit reduces the vault assets by `settlementFee * tradeFeePct`. While this amount is not very large (in the order of $0.1 - $0.001 per deposit transaction), this is amount lost with each deposit, and given that an active vault can easily have 1000s of transactions daily, this will be a loss of $1-$100/day, which is significant enough to make it a valid issue.\n\n## Code Snippet\n\nSettlementFee subtracted from asset before proceeding in `toSharesGlobal`:\nhttps://github.com/sherlock-audit/2024-02-perennial-v2-3/blob/main/perennial-v2/packages/perennial-vault/contracts/types/Checkpoint.sol#L91-L97\n\nThe result is multiplied by the checkpoint's share to assets ratio in `_toShares`:\nhttps://github.com/sherlock-audit/2024-02-perennial-v2-3/blob/main/perennial-v2/packages/perennial-vault/contracts/types/Checkpoint.sol#L153-L156\n\nAnd the final result is multiplied by `tradeFee`-adjusted deposits and redeems in `_withSpread`:\nhttps://github.com/sherlock-audit/2024-02-perennial-v2-3/blob/main/perennial-v2/packages/perennial-vault/contracts/types/Checkpoint.sol#L169-L177\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nRe-work the assets to shares conversion in vault checkpoint to use the correct formula:\n`shares = (assets[before fee] - settlementFee - tradeFee * assets / (deposit + redeem)) * checkpoint.shares/checkpoint.assets`\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  this seem valid medium; medium(3)\n\n\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/equilibria-xyz/perennial-v2/pull/304\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/254",
  "Code": [
    {
      "filename": "perennial-v2/packages/perennial-vault/contracts/types/Checkpoint.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { UFixed6, UFixed6Lib } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport { Fixed6, Fixed6Lib } from \"@equilibria/root/number/types/Fixed6.sol\";\nimport { Checkpoint as PerennialCheckpoint } from \"@equilibria/perennial-v2/contracts/interfaces/IMarket.sol\";\nimport { Account } from \"./Account.sol\";\n\n/// @dev Checkpoint type\nstruct Checkpoint {\n    /// @dev The total amount of pending deposits\n    UFixed6 deposit;\n\n    /// @dev The total amount of pending redemptions\n    UFixed6 redemption;\n\n    /// @dev The total shares at the checkpoint\n    UFixed6 shares;\n\n    /// @dev The total assets at the checkpoint\n    Fixed6 assets;\n\n    /// @dev The total fee at the checkpoint\n    Fixed6 tradeFee;\n\n    /// @dev The total settlement fee at the checkpoint\n    UFixed6 settlementFee;\n\n    /// @dev The number of deposits and redemptions during the checkpoint\n    uint256 orders;\n\n    // @dev The timestamp of of the checkpoint\n    uint256 timestamp;\n}\nusing CheckpointLib for Checkpoint global;\nstruct StoredCheckpoint {\n    /* slot 0 */\n    uint64 deposit;         // <= 18.44t\n    uint64 redemption;      // <= 18.44t\n    uint64 shares;          // <= 18.44t\n    int64 assets;           // <= 9.22t\n\n    /* slot 1 */\n    int64 tradeFee;         // <= 9.22t\n    uint64 settlementFee;   // <= 18.44t\n    uint32 orders;           // <= 4.29b\n    uint32 timestamp;       // <= 4.29b\n    bytes8 __unallocated__;\n}\nstruct CheckpointStorage { StoredCheckpoint value; }\nusing CheckpointStorageLib for CheckpointStorage global;\n\n/// @title Checkpoint\n/// @notice Holds the state for the checkpoint type\nlibrary CheckpointLib {\n    /// @notice Initializes the checkpoint\n    /// @dev Saves the current shares, and the assets + liabilities in the vault itself (not in the markets)\n    /// @param self The checkpoint to initialize\n    /// @param timestamp The timestamp of the checkpoint\n    /// @param global The global account\n    function next(Checkpoint memory self, uint256 timestamp, Account memory global) internal pure {\n        (self.timestamp, self.shares, self.assets) =\n            (timestamp, global.shares, Fixed6Lib.from(-1, global.deposit.add(global.assets)));\n        (self.deposit, self.redemption, self.tradeFee, self.settlementFee, self.orders) =\n            (UFixed6Lib.ZERO, UFixed6Lib.ZERO, Fixed6Lib.ZERO, UFixed6Lib.ZERO, 0);\n    }\n\n    /// @notice Updates the checkpoint with a new deposit or redemption\n    /// @param self The checkpoint to update\n    /// @param deposit The amount of new deposits\n    /// @param redemption The amount of new redemptions\n    function update(Checkpoint memory self, UFixed6 deposit, UFixed6 redemption) internal pure {\n        (self.deposit, self.redemption) =\n            (self.deposit.add(deposit), self.redemption.add(redemption));\n        if (!deposit.isZero() || !redemption.isZero()) self.orders++;\n    }\n\n    /// @notice Completes the checkpoint\n    /// @dev Increments the assets by the snapshotted amount of collateral in the underlying markets\n    /// @param self The checkpoint to complete\n    /// @param marketCheckpoint The checkpoint to complete with\n    function complete(Checkpoint memory self, PerennialCheckpoint memory marketCheckpoint) internal pure {\n        self.assets = self.assets.add(marketCheckpoint.collateral);\n        self.tradeFee = marketCheckpoint.tradeFee;\n        self.settlementFee = marketCheckpoint.settlementFee;\n    }\n\n    /// @notice Converts a given amount of assets to shares at checkpoint in the global context\n    /// @param assets Number of assets to convert to shares\n    /// @return Amount of shares for the given assets at checkpoint\n    function toSharesGlobal(Checkpoint memory self, UFixed6 assets) internal pure returns (UFixed6) {\n        // vault is fresh, use par value\n        if (self.shares.isZero()) return assets;\n\n        // if vault is insolvent, default to par value\n        return  self.assets.lte(Fixed6Lib.ZERO) ? assets : _toShares(self, _withoutSettlementFeeGlobal(self, assets));\n    }\n\n    /// @notice Converts a given amount of shares to assets with checkpoint in the global context\n    /// @param shares Number of shares to convert to shares\n    /// @return Amount of assets for the given shares at checkpoint\n    function toAssetsGlobal(Checkpoint memory self, UFixed6 shares) internal pure returns (UFixed6) {\n        // vault is fresh, use par value\n        return _withoutSettlementFeeGlobal(self, self.shares.isZero() ? shares : _toAssets(self, shares));\n    }\n\n\n    /// @notice Converts a given amount of assets to shares at checkpoint in the local context\n    /// @param assets Number of assets to convert to shares\n    /// @return Amount of shares for the given assets at checkpoint\n    function toSharesLocal(Checkpoint memory self, UFixed6 assets) internal pure returns (UFixed6) {\n        // vault is fresh, use par value\n        if (self.shares.isZero()) return assets;\n\n        // if vault is insolvent, default to par value\n        return  self.assets.lte(Fixed6Lib.ZERO) ? assets : _toShares(self, _withoutSettlementFeeLocal(self, assets));\n    }\n\n    /// @notice Converts a given amount of shares to assets with checkpoint in the local context\n    /// @param shares Number of shares to convert to shares\n    /// @return Amount of assets for the given shares at checkpoint\n    function toAssetsLocal(Checkpoint memory self, UFixed6 shares) internal pure returns (UFixed6) {\n        // vault is fresh, use par value\n        return _withoutSettlementFeeLocal(self, self.shares.isZero() ? shares : _toAssets(self, shares));\n    }\n\n    /// @notice Converts a given amount of assets to shares at checkpoint in the global context\n    /// @dev Dev used in limit calculations when a non-historical settlement fee must be used\n    /// @param assets Number of assets to convert to shares\n    /// @param settlementFee Custom settlement fee\n    /// @return Amount of shares for the given assets at checkpoint\n    function toShares(Checkpoint memory self, UFixed6 assets, UFixed6 settlementFee) internal pure returns (UFixed6) {\n        // vault is fresh, use par value\n        if (self.shares.isZero()) return assets;\n\n        // if vault is insolvent, default to par value\n        return  self.assets.lte(Fixed6Lib.ZERO) ? assets : _toShares(self, _withoutSettlementFee(assets, settlementFee));\n    }\n\n    /// @notice Converts a given amount of shares to assets with checkpoint in the global context\n    /// @dev Dev used in limit calculations when a non-historical settlement fee must be used\n    /// @param shares Number of shares to convert to shares\n    /// @param settlementFee Custom settlement fee\n    /// @return Amount of assets for the given shares at checkpoint\n    function toAssets(Checkpoint memory self, UFixed6 shares, UFixed6 settlementFee) internal pure returns (UFixed6) {\n        // vault is fresh, use par value\n        return _withoutSettlementFee(self.shares.isZero() ? shares : _toAssets(self, shares), settlementFee);\n    }\n\n    /// @notice Converts a given amount of assets to shares at checkpoint\n    /// @param assets Number of assets to convert to shares\n    /// @return Amount of shares for the given assets at checkpoint\n    function _toShares(Checkpoint memory self, UFixed6 assets) private pure returns (UFixed6) {\n        UFixed6 selfAssets = UFixed6Lib.unsafeFrom(self.assets);\n        return _withSpread(self, assets.muldiv(self.shares, selfAssets));\n    }\n\n    /// @notice Converts a given amount of shares to assets with checkpoint\n    /// @param shares Number of shares to convert to shares\n    /// @return Amount of assets for the given shares at checkpoint\n    function _toAssets(Checkpoint memory self, UFixed6 shares) private pure returns (UFixed6) {\n        UFixed6 selfAssets = UFixed6Lib.unsafeFrom(self.assets);\n        return _withSpread(self, shares.muldiv(selfAssets, self.shares));\n    }\n\n    /// @notice Applies a spread to a given amount from the relative fee amount of the checkpoint\n    /// @param self The checkpoint to apply the spread to\n    /// @param amount The amount to apply the spread to\n    function _withSpread(Checkpoint memory self, UFixed6 amount) private pure returns (UFixed6) {\n        UFixed6 selfAssets = UFixed6Lib.unsafeFrom(self.assets);\n        UFixed6 totalAmount = self.deposit.add(self.redemption.muldiv(selfAssets, self.shares));\n        UFixed6 totalAmountIncludingFee = UFixed6Lib.unsafeFrom(Fixed6Lib.from(totalAmount).sub(self.tradeFee));\n\n        return totalAmount.isZero() ?\n            amount :\n            amount.muldiv(totalAmountIncludingFee, totalAmount);\n    }\n\n    /// @notice Applies the fixed settlement fee to a given amount in the global context\n    /// @param self The checkpoint to apply the fee to\n    /// @param amount The amount to apply the fee to\n    /// @return The amount with the settlement fee\n    function _withoutSettlementFeeGlobal(Checkpoint memory self, UFixed6 amount) private pure returns (UFixed6) {\n        return _withoutSettlementFee(amount, self.settlementFee);\n    }\n\n    /// @notice Applies the fixed settlement fee to a given amount in the local context\n    /// @param self The checkpoint to apply the fee to\n    /// @param amount The amount to apply the fee to\n    /// @return The amount with the settlement fee\n    function _withoutSettlementFeeLocal(Checkpoint memory self, UFixed6 amount) private pure returns (UFixed6) {\n        UFixed6 settlementFeePer = self.orders == 0 ?\n            UFixed6Lib.ZERO :\n            self.settlementFee.div(UFixed6Lib.from(self.orders));\n        return _withoutSettlementFee(amount, settlementFeePer);\n    }\n\n    /// @notice Applies the fixed settlement fee to a given amount in the local context\n    /// @param amount The amount to apply the fee to\n    /// @param settlementFee The amount of settlement fee to deduct\n    /// @return The amount with the settlement fee\n    function _withoutSettlementFee(UFixed6 amount, UFixed6 settlementFee) private pure returns (UFixed6) {\n        return amount.unsafeSub(settlementFee);\n    }\n\n    /// @notice Returns if the checkpoint is healthy\n    /// @dev A checkpoint is unhealthy when it has shares but no assets, since this cannot be recovered from\n    /// @param self The checkpoint to check\n    /// @return Whether the checkpoint is healthy\n    function unhealthy(Checkpoint memory self) internal pure returns (bool) {\n        return !self.shares.isZero() && self.assets.lte(Fixed6Lib.ZERO);\n    }\n}\n\nlibrary CheckpointStorageLib {\n    // sig: 0xba85116a\n    error CheckpointStorageInvalidError();\n\n    function read(CheckpointStorage storage self) internal view returns (Checkpoint memory) {\n        StoredCheckpoint memory storedValue = self.value;\n        return Checkpoint(\n            UFixed6.wrap(uint256(storedValue.deposit)),\n            UFixed6.wrap(uint256(storedValue.redemption)),\n            UFixed6.wrap(uint256(storedValue.shares)),\n            Fixed6.wrap(int256(storedValue.assets)),\n            Fixed6.wrap(int256(storedValue.tradeFee)),\n            UFixed6.wrap(uint256(storedValue.settlementFee)),\n            uint256(storedValue.orders),\n            uint256(storedValue.timestamp)\n        );\n    }\n\n    function store(CheckpointStorage storage self, Checkpoint memory newValue) internal {\n        if (newValue.deposit.gt(UFixed6.wrap(type(uint64).max))) revert CheckpointStorageInvalidError();\n        if (newValue.redemption.gt(UFixed6.wrap(type(uint64).max))) revert CheckpointStorageInvalidError();\n        if (newValue.shares.gt(UFixed6.wrap(type(uint64).max))) revert CheckpointStorageInvalidError();\n        if (newValue.assets.gt(Fixed6.wrap(type(int64).max))) revert CheckpointStorageInvalidError();\n        if (newValue.assets.lt(Fixed6.wrap(type(int64).min))) revert CheckpointStorageInvalidError();\n        if (newValue.tradeFee.gt(Fixed6.wrap(type(int64).max))) revert CheckpointStorageInvalidError();\n        if (newValue.tradeFee.lt(Fixed6.wrap(type(int64).min))) revert CheckpointStorageInvalidError();\n        if (newValue.settlementFee.gt(UFixed6.wrap(type(uint64).max))) revert CheckpointStorageInvalidError();\n        if (newValue.orders > uint256(type(uint32).max)) revert CheckpointStorageInvalidError();\n        if (newValue.timestamp > uint256(type(uint32).max)) revert CheckpointStorageInvalidError();\n\n        self.value = StoredCheckpoint(\n            uint64(UFixed6.unwrap(newValue.deposit)),\n            uint64(UFixed6.unwrap(newValue.redemption)),\n            uint64(UFixed6.unwrap(newValue.shares)),\n            int64(Fixed6.unwrap(newValue.assets)),\n\n            int64(Fixed6.unwrap(newValue.tradeFee)),\n            uint64(UFixed6.unwrap(newValue.settlementFee)),\n            uint32(newValue.orders),\n            uint32(newValue.timestamp),\n            bytes8(0)\n        );\n    }\n}"
    },
    {
      "filename": "perennial-v2/packages/perennial-vault/contracts/types/Checkpoint.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { UFixed6, UFixed6Lib } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport { Fixed6, Fixed6Lib } from \"@equilibria/root/number/types/Fixed6.sol\";\nimport { Checkpoint as PerennialCheckpoint } from \"@equilibria/perennial-v2/contracts/interfaces/IMarket.sol\";\nimport { Account } from \"./Account.sol\";\n\n/// @dev Checkpoint type\nstruct Checkpoint {\n    /// @dev The total amount of pending deposits\n    UFixed6 deposit;\n\n    /// @dev The total amount of pending redemptions\n    UFixed6 redemption;\n\n    /// @dev The total shares at the checkpoint\n    UFixed6 shares;\n\n    /// @dev The total assets at the checkpoint\n    Fixed6 assets;\n\n    /// @dev The total fee at the checkpoint\n    Fixed6 tradeFee;\n\n    /// @dev The total settlement fee at the checkpoint\n    UFixed6 settlementFee;\n\n    /// @dev The number of deposits and redemptions during the checkpoint\n    uint256 orders;\n\n    // @dev The timestamp of of the checkpoint\n    uint256 timestamp;\n}\nusing CheckpointLib for Checkpoint global;\nstruct StoredCheckpoint {\n    /* slot 0 */\n    uint64 deposit;         // <= 18.44t\n    uint64 redemption;      // <= 18.44t\n    uint64 shares;          // <= 18.44t\n    int64 assets;           // <= 9.22t\n\n    /* slot 1 */\n    int64 tradeFee;         // <= 9.22t\n    uint64 settlementFee;   // <= 18.44t\n    uint32 orders;           // <= 4.29b\n    uint32 timestamp;       // <= 4.29b\n    bytes8 __unallocated__;\n}\nstruct CheckpointStorage { StoredCheckpoint value; }\nusing CheckpointStorageLib for CheckpointStorage global;\n\n/// @title Checkpoint\n/// @notice Holds the state for the checkpoint type\nlibrary CheckpointLib {\n    /// @notice Initializes the checkpoint\n    /// @dev Saves the current shares, and the assets + liabilities in the vault itself (not in the markets)\n    /// @param self The checkpoint to initialize\n    /// @param timestamp The timestamp of the checkpoint\n    /// @param global The global account\n    function next(Checkpoint memory self, uint256 timestamp, Account memory global) internal pure {\n        (self.timestamp, self.shares, self.assets) =\n            (timestamp, global.shares, Fixed6Lib.from(-1, global.deposit.add(global.assets)));\n        (self.deposit, self.redemption, self.tradeFee, self.settlementFee, self.orders) =\n            (UFixed6Lib.ZERO, UFixed6Lib.ZERO, Fixed6Lib.ZERO, UFixed6Lib.ZERO, 0);\n    }\n\n    /// @notice Updates the checkpoint with a new deposit or redemption\n    /// @param self The checkpoint to update\n    /// @param deposit The amount of new deposits\n    /// @param redemption The amount of new redemptions\n    function update(Checkpoint memory self, UFixed6 deposit, UFixed6 redemption) internal pure {\n        (self.deposit, self.redemption) =\n            (self.deposit.add(deposit), self.redemption.add(redemption));\n        if (!deposit.isZero() || !redemption.isZero()) self.orders++;\n    }\n\n    /// @notice Completes the checkpoint\n    /// @dev Increments the assets by the snapshotted amount of collateral in the underlying markets\n    /// @param self The checkpoint to complete\n    /// @param marketCheckpoint The checkpoint to complete with\n    function complete(Checkpoint memory self, PerennialCheckpoint memory marketCheckpoint) internal pure {\n        self.assets = self.assets.add(marketCheckpoint.collateral);\n        self.tradeFee = marketCheckpoint.tradeFee;\n        self.settlementFee = marketCheckpoint.settlementFee;\n    }\n\n    /// @notice Converts a given amount of assets to shares at checkpoint in the global context\n    /// @param assets Number of assets to convert to shares\n    /// @return Amount of shares for the given assets at checkpoint\n    function toSharesGlobal(Checkpoint memory self, UFixed6 assets) internal pure returns (UFixed6) {\n        // vault is fresh, use par value\n        if (self.shares.isZero()) return assets;\n\n        // if vault is insolvent, default to par value\n        return  self.assets.lte(Fixed6Lib.ZERO) ? assets : _toShares(self, _withoutSettlementFeeGlobal(self, assets));\n    }\n\n    /// @notice Converts a given amount of shares to assets with checkpoint in the global context\n    /// @param shares Number of shares to convert to shares\n    /// @return Amount of assets for the given shares at checkpoint\n    function toAssetsGlobal(Checkpoint memory self, UFixed6 shares) internal pure returns (UFixed6) {\n        // vault is fresh, use par value\n        return _withoutSettlementFeeGlobal(self, self.shares.isZero() ? shares : _toAssets(self, shares));\n    }\n\n\n    /// @notice Converts a given amount of assets to shares at checkpoint in the local context\n    /// @param assets Number of assets to convert to shares\n    /// @return Amount of shares for the given assets at checkpoint\n    function toSharesLocal(Checkpoint memory self, UFixed6 assets) internal pure returns (UFixed6) {\n        // vault is fresh, use par value\n        if (self.shares.isZero()) return assets;\n\n        // if vault is insolvent, default to par value\n        return  self.assets.lte(Fixed6Lib.ZERO) ? assets : _toShares(self, _withoutSettlementFeeLocal(self, assets));\n    }\n\n    /// @notice Converts a given amount of shares to assets with checkpoint in the local context\n    /// @param shares Number of shares to convert to shares\n    /// @return Amount of assets for the given shares at checkpoint\n    function toAssetsLocal(Checkpoint memory self, UFixed6 shares) internal pure returns (UFixed6) {\n        // vault is fresh, use par value\n        return _withoutSettlementFeeLocal(self, self.shares.isZero() ? shares : _toAssets(self, shares));\n    }\n\n    /// @notice Converts a given amount of assets to shares at checkpoint in the global context\n    /// @dev Dev used in limit calculations when a non-historical settlement fee must be used\n    /// @param assets Number of assets to convert to shares\n    /// @param settlementFee Custom settlement fee\n    /// @return Amount of shares for the given assets at checkpoint\n    function toShares(Checkpoint memory self, UFixed6 assets, UFixed6 settlementFee) internal pure returns (UFixed6) {\n        // vault is fresh, use par value\n        if (self.shares.isZero()) return assets;\n\n        // if vault is insolvent, default to par value\n        return  self.assets.lte(Fixed6Lib.ZERO) ? assets : _toShares(self, _withoutSettlementFee(assets, settlementFee));\n    }\n\n    /// @notice Converts a given amount of shares to assets with checkpoint in the global context\n    /// @dev Dev used in limit calculations when a non-historical settlement fee must be used\n    /// @param shares Number of shares to convert to shares\n    /// @param settlementFee Custom settlement fee\n    /// @return Amount of assets for the given shares at checkpoint\n    function toAssets(Checkpoint memory self, UFixed6 shares, UFixed6 settlementFee) internal pure returns (UFixed6) {\n        // vault is fresh, use par value\n        return _withoutSettlementFee(self.shares.isZero() ? shares : _toAssets(self, shares), settlementFee);\n    }\n\n    /// @notice Converts a given amount of assets to shares at checkpoint\n    /// @param assets Number of assets to convert to shares\n    /// @return Amount of shares for the given assets at checkpoint\n    function _toShares(Checkpoint memory self, UFixed6 assets) private pure returns (UFixed6) {\n        UFixed6 selfAssets = UFixed6Lib.unsafeFrom(self.assets);\n        return _withSpread(self, assets.muldiv(self.shares, selfAssets));\n    }\n\n    /// @notice Converts a given amount of shares to assets with checkpoint\n    /// @param shares Number of shares to convert to shares\n    /// @return Amount of assets for the given shares at checkpoint\n    function _toAssets(Checkpoint memory self, UFixed6 shares) private pure returns (UFixed6) {\n        UFixed6 selfAssets = UFixed6Lib.unsafeFrom(self.assets);\n        return _withSpread(self, shares.muldiv(selfAssets, self.shares));\n    }\n\n    /// @notice Applies a spread to a given amount from the relative fee amount of the checkpoint\n    /// @param self The checkpoint to apply the spread to\n    /// @param amount The amount to apply the spread to\n    function _withSpread(Checkpoint memory self, UFixed6 amount) private pure returns (UFixed6) {\n        UFixed6 selfAssets = UFixed6Lib.unsafeFrom(self.assets);\n        UFixed6 totalAmount = self.deposit.add(self.redemption.muldiv(selfAssets, self.shares));\n        UFixed6 totalAmountIncludingFee = UFixed6Lib.unsafeFrom(Fixed6Lib.from(totalAmount).sub(self.tradeFee));\n\n        return totalAmount.isZero() ?\n            amount :\n            amount.muldiv(totalAmountIncludingFee, totalAmount);\n    }\n\n    /// @notice Applies the fixed settlement fee to a given amount in the global context\n    /// @param self The checkpoint to apply the fee to\n    /// @param amount The amount to apply the fee to\n    /// @return The amount with the settlement fee\n    function _withoutSettlementFeeGlobal(Checkpoint memory self, UFixed6 amount) private pure returns (UFixed6) {\n        return _withoutSettlementFee(amount, self.settlementFee);\n    }\n\n    /// @notice Applies the fixed settlement fee to a given amount in the local context\n    /// @param self The checkpoint to apply the fee to\n    /// @param amount The amount to apply the fee to\n    /// @return The amount with the settlement fee\n    function _withoutSettlementFeeLocal(Checkpoint memory self, UFixed6 amount) private pure returns (UFixed6) {\n        UFixed6 settlementFeePer = self.orders == 0 ?\n            UFixed6Lib.ZERO :\n            self.settlementFee.div(UFixed6Lib.from(self.orders));\n        return _withoutSettlementFee(amount, settlementFeePer);\n    }\n\n    /// @notice Applies the fixed settlement fee to a given amount in the local context\n    /// @param amount The amount to apply the fee to\n    /// @param settlementFee The amount of settlement fee to deduct\n    /// @return The amount with the settlement fee\n    function _withoutSettlementFee(UFixed6 amount, UFixed6 settlementFee) private pure returns (UFixed6) {\n        return amount.unsafeSub(settlementFee);\n    }\n\n    /// @notice Returns if the checkpoint is healthy\n    /// @dev A checkpoint is unhealthy when it has shares but no assets, since this cannot be recovered from\n    /// @param self The checkpoint to check\n    /// @return Whether the checkpoint is healthy\n    function unhealthy(Checkpoint memory self) internal pure returns (bool) {\n        return !self.shares.isZero() && self.assets.lte(Fixed6Lib.ZERO);\n    }\n}\n\nlibrary CheckpointStorageLib {\n    // sig: 0xba85116a\n    error CheckpointStorageInvalidError();\n\n    function read(CheckpointStorage storage self) internal view returns (Checkpoint memory) {\n        StoredCheckpoint memory storedValue = self.value;\n        return Checkpoint(\n            UFixed6.wrap(uint256(storedValue.deposit)),\n            UFixed6.wrap(uint256(storedValue.redemption)),\n            UFixed6.wrap(uint256(storedValue.shares)),\n            Fixed6.wrap(int256(storedValue.assets)),\n            Fixed6.wrap(int256(storedValue.tradeFee)),\n            UFixed6.wrap(uint256(storedValue.settlementFee)),\n            uint256(storedValue.orders),\n            uint256(storedValue.timestamp)\n        );\n    }\n\n    function store(CheckpointStorage storage self, Checkpoint memory newValue) internal {\n        if (newValue.deposit.gt(UFixed6.wrap(type(uint64).max))) revert CheckpointStorageInvalidError();\n        if (newValue.redemption.gt(UFixed6.wrap(type(uint64).max))) revert CheckpointStorageInvalidError();\n        if (newValue.shares.gt(UFixed6.wrap(type(uint64).max))) revert CheckpointStorageInvalidError();\n        if (newValue.assets.gt(Fixed6.wrap(type(int64).max))) revert CheckpointStorageInvalidError();\n        if (newValue.assets.lt(Fixed6.wrap(type(int64).min))) revert CheckpointStorageInvalidError();\n        if (newValue.tradeFee.gt(Fixed6.wrap(type(int64).max))) revert CheckpointStorageInvalidError();\n        if (newValue.tradeFee.lt(Fixed6.wrap(type(int64).min))) revert CheckpointStorageInvalidError();\n        if (newValue.settlementFee.gt(UFixed6.wrap(type(uint64).max))) revert CheckpointStorageInvalidError();\n        if (newValue.orders > uint256(type(uint32).max)) revert CheckpointStorageInvalidError();\n        if (newValue.timestamp > uint256(type(uint32).max)) revert CheckpointStorageInvalidError();\n\n        self.value = StoredCheckpoint(\n            uint64(UFixed6.unwrap(newValue.deposit)),\n            uint64(UFixed6.unwrap(newValue.redemption)),\n            uint64(UFixed6.unwrap(newValue.shares)),\n            int64(Fixed6.unwrap(newValue.assets)),\n\n            int64(Fixed6.unwrap(newValue.tradeFee)),\n            uint64(UFixed6.unwrap(newValue.settlementFee)),\n            uint32(newValue.orders),\n            uint32(newValue.timestamp),\n            bytes8(0)\n        );\n    }\n}"
    },
    {
      "filename": "perennial-v2/packages/perennial-vault/contracts/types/Checkpoint.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { UFixed6, UFixed6Lib } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport { Fixed6, Fixed6Lib } from \"@equilibria/root/number/types/Fixed6.sol\";\nimport { Checkpoint as PerennialCheckpoint } from \"@equilibria/perennial-v2/contracts/interfaces/IMarket.sol\";\nimport { Account } from \"./Account.sol\";\n\n/// @dev Checkpoint type\nstruct Checkpoint {\n    /// @dev The total amount of pending deposits\n    UFixed6 deposit;\n\n    /// @dev The total amount of pending redemptions\n    UFixed6 redemption;\n\n    /// @dev The total shares at the checkpoint\n    UFixed6 shares;\n\n    /// @dev The total assets at the checkpoint\n    Fixed6 assets;\n\n    /// @dev The total fee at the checkpoint\n    Fixed6 tradeFee;\n\n    /// @dev The total settlement fee at the checkpoint\n    UFixed6 settlementFee;\n\n    /// @dev The number of deposits and redemptions during the checkpoint\n    uint256 orders;\n\n    // @dev The timestamp of of the checkpoint\n    uint256 timestamp;\n}\nusing CheckpointLib for Checkpoint global;\nstruct StoredCheckpoint {\n    /* slot 0 */\n    uint64 deposit;         // <= 18.44t\n    uint64 redemption;      // <= 18.44t\n    uint64 shares;          // <= 18.44t\n    int64 assets;           // <= 9.22t\n\n    /* slot 1 */\n    int64 tradeFee;         // <= 9.22t\n    uint64 settlementFee;   // <= 18.44t\n    uint32 orders;           // <= 4.29b\n    uint32 timestamp;       // <= 4.29b\n    bytes8 __unallocated__;\n}\nstruct CheckpointStorage { StoredCheckpoint value; }\nusing CheckpointStorageLib for CheckpointStorage global;\n\n/// @title Checkpoint\n/// @notice Holds the state for the checkpoint type\nlibrary CheckpointLib {\n    /// @notice Initializes the checkpoint\n    /// @dev Saves the current shares, and the assets + liabilities in the vault itself (not in the markets)\n    /// @param self The checkpoint to initialize\n    /// @param timestamp The timestamp of the checkpoint\n    /// @param global The global account\n    function next(Checkpoint memory self, uint256 timestamp, Account memory global) internal pure {\n        (self.timestamp, self.shares, self.assets) =\n            (timestamp, global.shares, Fixed6Lib.from(-1, global.deposit.add(global.assets)));\n        (self.deposit, self.redemption, self.tradeFee, self.settlementFee, self.orders) =\n            (UFixed6Lib.ZERO, UFixed6Lib.ZERO, Fixed6Lib.ZERO, UFixed6Lib.ZERO, 0);\n    }\n\n    /// @notice Updates the checkpoint with a new deposit or redemption\n    /// @param self The checkpoint to update\n    /// @param deposit The amount of new deposits\n    /// @param redemption The amount of new redemptions\n    function update(Checkpoint memory self, UFixed6 deposit, UFixed6 redemption) internal pure {\n        (self.deposit, self.redemption) =\n            (self.deposit.add(deposit), self.redemption.add(redemption));\n        if (!deposit.isZero() || !redemption.isZero()) self.orders++;\n    }\n\n    /// @notice Completes the checkpoint\n    /// @dev Increments the assets by the snapshotted amount of collateral in the underlying markets\n    /// @param self The checkpoint to complete\n    /// @param marketCheckpoint The checkpoint to complete with\n    function complete(Checkpoint memory self, PerennialCheckpoint memory marketCheckpoint) internal pure {\n        self.assets = self.assets.add(marketCheckpoint.collateral);\n        self.tradeFee = marketCheckpoint.tradeFee;\n        self.settlementFee = marketCheckpoint.settlementFee;\n    }\n\n    /// @notice Converts a given amount of assets to shares at checkpoint in the global context\n    /// @param assets Number of assets to convert to shares\n    /// @return Amount of shares for the given assets at checkpoint\n    function toSharesGlobal(Checkpoint memory self, UFixed6 assets) internal pure returns (UFixed6) {\n        // vault is fresh, use par value\n        if (self.shares.isZero()) return assets;\n\n        // if vault is insolvent, default to par value\n        return  self.assets.lte(Fixed6Lib.ZERO) ? assets : _toShares(self, _withoutSettlementFeeGlobal(self, assets));\n    }\n\n    /// @notice Converts a given amount of shares to assets with checkpoint in the global context\n    /// @param shares Number of shares to convert to shares\n    /// @return Amount of assets for the given shares at checkpoint\n    function toAssetsGlobal(Checkpoint memory self, UFixed6 shares) internal pure returns (UFixed6) {\n        // vault is fresh, use par value\n        return _withoutSettlementFeeGlobal(self, self.shares.isZero() ? shares : _toAssets(self, shares));\n    }\n\n\n    /// @notice Converts a given amount of assets to shares at checkpoint in the local context\n    /// @param assets Number of assets to convert to shares\n    /// @return Amount of shares for the given assets at checkpoint\n    function toSharesLocal(Checkpoint memory self, UFixed6 assets) internal pure returns (UFixed6) {\n        // vault is fresh, use par value\n        if (self.shares.isZero()) return assets;\n\n        // if vault is insolvent, default to par value\n        return  self.assets.lte(Fixed6Lib.ZERO) ? assets : _toShares(self, _withoutSettlementFeeLocal(self, assets));\n    }\n\n    /// @notice Converts a given amount of shares to assets with checkpoint in the local context\n    /// @param shares Number of shares to convert to shares\n    /// @return Amount of assets for the given shares at checkpoint\n    function toAssetsLocal(Checkpoint memory self, UFixed6 shares) internal pure returns (UFixed6) {\n        // vault is fresh, use par value\n        return _withoutSettlementFeeLocal(self, self.shares.isZero() ? shares : _toAssets(self, shares));\n    }\n\n    /// @notice Converts a given amount of assets to shares at checkpoint in the global context\n    /// @dev Dev used in limit calculations when a non-historical settlement fee must be used\n    /// @param assets Number of assets to convert to shares\n    /// @param settlementFee Custom settlement fee\n    /// @return Amount of shares for the given assets at checkpoint\n    function toShares(Checkpoint memory self, UFixed6 assets, UFixed6 settlementFee) internal pure returns (UFixed6) {\n        // vault is fresh, use par value\n        if (self.shares.isZero()) return assets;\n\n        // if vault is insolvent, default to par value\n        return  self.assets.lte(Fixed6Lib.ZERO) ? assets : _toShares(self, _withoutSettlementFee(assets, settlementFee));\n    }\n\n    /// @notice Converts a given amount of shares to assets with checkpoint in the global context\n    /// @dev Dev used in limit calculations when a non-historical settlement fee must be used\n    /// @param shares Number of shares to convert to shares\n    /// @param settlementFee Custom settlement fee\n    /// @return Amount of assets for the given shares at checkpoint\n    function toAssets(Checkpoint memory self, UFixed6 shares, UFixed6 s"
    }
  ]
}