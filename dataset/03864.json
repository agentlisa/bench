{
  "Title": "Excess reserve amount",
  "Content": "##### Description\nAt lines https://github.com/CreamFi/compound-protocol/blob/e414160eb8a774140457c885bb099baae528df04/contracts/CCapableErc20.sol#L250-L252 contract increases `internalCash` and `totalReserves` values, but it's so strange that `internalCash` increased by `totalFee` and `totalReserves` increased by `reservesFee` so we totally increased assets amount by `reservesFee + totalFee` however user paid only `totalFee`. It seems there are some uncollateralized `reservesFee`. May be there `totalFee` paid by user should be splitted to `internalCash` and `totalReserves` ?\n\n##### Recommendation\nWe recommend to double check that place \n",
  "Impact": "HIGH",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/CCapableErc20.sol",
      "content": "pragma solidity ^0.5.16;\n\nimport \"./CToken.sol\";\n\ninterface IFlashloanReceiver {\n    function executeOperation(address sender, address underlying, uint amount, uint fee, bytes calldata params) external;\n}\n\n/**\n * @title Compound's CCapableErc20 Contract\n * @notice CTokens which wrap an EIP-20 underlying\n * @author Compound\n */\ncontract CCapableErc20 is CToken, CCapableErc20Interface, CCapableDelegateInterface {\n\n    event Flashloan(address indexed receiver, uint amount, uint totalFee, uint reservesFee);\n    uint constant flashFeeBips = 3;\n\n    /**\n     * @notice Initialize the new money market\n     * @param underlying_ The address of the underlying asset\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ ERC-20 name of this token\n     * @param symbol_ ERC-20 symbol of this token\n     * @param decimals_ ERC-20 decimal precision of this token\n     */\n    function initialize(address underlying_,\n                        ComptrollerInterface comptroller_,\n                        InterestRateModel interestRateModel_,\n                        uint initialExchangeRateMantissa_,\n                        string memory name_,\n                        string memory symbol_,\n                        uint8 decimals_) public {\n        // CToken initialize does the bulk of the work\n        super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n        // Set underlying and sanity check it\n        underlying = underlying_;\n        EIP20Interface(underlying).totalSupply();\n    }\n\n    /*** User Interface ***/\n\n    /**\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function mint(uint mintAmount) external returns (uint) {\n        (uint err,) = mintInternal(mintAmount);\n        return err;\n    }\n\n    /**\n     * @notice Sender redeems cTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of cTokens to redeem into underlying\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeem(uint redeemTokens) external returns (uint) {\n        return redeemInternal(redeemTokens);\n    }\n\n    /**\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to redeem\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemUnderlying(uint redeemAmount) external returns (uint) {\n        return redeemUnderlyingInternal(redeemAmount);\n    }\n\n    /**\n      * @notice Sender borrows assets from the protocol to their own address\n      * @param borrowAmount The amount of the underlying asset to borrow\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n    function borrow(uint borrowAmount) external returns (uint) {\n        return borrowInternal(borrowAmount);\n    }\n\n    /**\n     * @notice Sender repays their own borrow\n     * @param repayAmount The amount to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function repayBorrow(uint repayAmount) external returns (uint) {\n        (uint err,) = repayBorrowInternal(repayAmount);\n        return err;\n    }\n\n    /**\n     * @notice Sender repays a borrow belonging to borrower\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount The amount to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint) {\n        (uint err,) = repayBorrowBehalfInternal(borrower, repayAmount);\n        return err;\n    }\n\n    /**\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function liquidateBorrow(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) external returns (uint) {\n        (uint err,) = liquidateBorrowInternal(borrower, repayAmount, cTokenCollateral);\n        return err;\n    }\n\n    /**\n     * @notice The sender adds to reserves.\n     * @param addAmount The amount fo underlying token to add as reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _addReserves(uint addAmount) external returns (uint) {\n        return _addReservesInternal(addAmount);\n    }\n\n    /**\n     * @notice Absorb excess cash into reserves.\n     */\n    function gulp() external {\n        uint256 cashOnChain = getCashOnChain();\n        uint256 cashPrior = getCashPrior();\n\n        uint excessCash = sub_(cashOnChain, cashPrior);\n        totalReserves = add_(totalReserves, excessCash);\n        internalCash = cashOnChain;\n    }\n\n    /*** Safe Token ***/\n\n    /**\n     * @notice Gets internal balance of this contract in terms of the underlying.\n     *  It excludes balance from direct transfer.\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying tokens owned by this contract\n     */\n    function getCashPrior() internal view returns (uint) {\n        return internalCash;\n    }\n\n    /**\n     * @notice Gets total balance of this contract in terms of the underlying\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying tokens owned by this contract\n     */\n    function getCashOnChain() internal view returns (uint) {\n        EIP20Interface token = EIP20Interface(underlying);\n        return token.balanceOf(address(this));\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\n     *      This will revert due to insufficient balance or insufficient allowance.\n     *      This function returns the actual amount received,\n     *      which may be less than `amount` if there is a fee attached to the transfer.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferIn(address from, uint amount) internal returns (uint) {\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n        uint balanceBefore = EIP20Interface(underlying).balanceOf(address(this));\n        token.transferFrom(from, address(this), amount);\n\n        bool success;\n        assembly {\n            switch returndatasize()\n                case 0 {                       // This is a non-standard ERC-20\n                    success := not(0)          // set success to true\n                }\n                case 32 {                      // This is a compliant ERC-20\n                    returndatacopy(0, 0, 32)\n                    success := mload(0)        // Set `success = returndata` of external call\n                }\n                default {                      // This is an excessively non-compliant ERC-20, revert.\n                    revert(0, 0)\n                }\n        }\n        require(success, \"TOKEN_TRANSFER_IN_FAILED\");\n\n        // Calculate the amount that was *actually* transferred\n        uint balanceAfter = EIP20Interface(underlying).balanceOf(address(this));\n        uint transferredIn = sub_(balanceAfter, balanceBefore);\n        internalCash = add_(internalCash, transferredIn);\n        return transferredIn;\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\n     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\n     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\n     *      it is >= amount, this should not revert in normal conditions.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferOut(address payable to, uint amount) internal {\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n        token.transfer(to, amount);\n\n        bool success;\n        assembly {\n            switch returndatasize()\n                case 0 {                      // This is a non-standard ERC-20\n                    success := not(0)          // set success to true\n                }\n                case 32 {                     // This is a complaint ERC-20\n                    returndatacopy(0, 0, 32)\n                    success := mload(0)        // Set `success = returndata` of external call\n                }\n                default {                     // This is an excessively non-compliant ERC-20, revert.\n                    revert(0, 0)\n                }\n        }\n        require(success, \"TOKEN_TRANSFER_OUT_FAILED\");\n        internalCash = sub_(internalCash, amount);\n    }\n\n    function flashLoan(address receiver, uint amount, bytes calldata params) external nonReentrant {\n        uint cashOnChainBefore = getCashOnChain();\n        uint cashBefore = getCashPrior();\n        require(cashBefore >= amount, \"INSUFFICIENT_LIQUIDITY\");\n\n        // 1. calculate fee\n        uint totalFee = div_(mul_(amount, flashFeeBips), 10000);\n\n        // 2. transfer fund to receiver\n        doTransferOut(address(uint160(receiver)), amount);\n\n        // 3. execute receiver's callback function\n        IFlashloanReceiver(receiver).executeOperation(msg.sender, underlying, amount, totalFee, params);\n\n        // 4. check balance\n        uint cashOnChainAfter = getCashOnChain();\n        require(cashOnChainAfter == add_(cashOnChainBefore, totalFee), \"BALANCE_INCONSISTENT\");\n\n        // 5. update reserves and internal cash\n        uint reservesFee = mul_ScalarTruncate(Exp({mantissa: reserveFactorMantissa}), totalFee);\n        totalReserves = add_(totalReserves, reservesFee);\n        internalCash = add_(cashBefore, totalFee);\n\n        emit Flashloan(receiver, amount, totalFee, reservesFee);\n    }\n}"
    }
  ]
}