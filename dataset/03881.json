{
  "Title": "[L06] Inconsistent coding style",
  "Content": "There are general inconsistencies and deviations from the [Solidity Style Guide](https://solidity.readthedocs.io/en/latest/style-guide.html) throughout the codebase. These lead to misconceptions and confusion when reading the code. Below is a non-exhaustive list of inconsistent coding styles observed.\n\n\nWhile most `public` and `external` function names do not contain an underscore, some begin with an underscore. This is misleading, as a leading underscore should be reserved for internal functions that are not accessible from a contract’s public API. For example:\n\n\n* The [`_depositProvider` function](https://github.com/BarnBridge/BarnBridge-SmartYieldBonds/blob/943df3a8fcd8dd128af3beb0c85a0480c0e95ead/contracts/providers/CompoundProvider.sol#L110)\n* The [`_sendUnderlying` function](https://github.com/BarnBridge/BarnBridge-SmartYieldBonds/blob/943df3a8fcd8dd128af3beb0c85a0480c0e95ead/contracts/providers/CompoundProvider.sol#L100)\n\n\nSome `internal` function names start with an underscore, while others do not. For example:\n\n\n* [`_updateCompState`](https://github.com/BarnBridge/BarnBridge-SmartYieldBonds/blob/943df3a8fcd8dd128af3beb0c85a0480c0e95ead/contracts/providers/CompoundProvider.sol#L372) is internal and has a leading underscore.\n* [`compound2`](https://github.com/BarnBridge/BarnBridge-SmartYieldBonds/blob/943df3a8fcd8dd128af3beb0c85a0480c0e95ead/contracts/lib/math/MathUtils.sol#L47) is internal and does not have a leading underscore.\n\n\nMost parameters end with an underscore, while some do not. For example:\n\n\n* The [`forInterval` parameter in the `consult` function](https://github.com/BarnBridge/BarnBridge-SmartYieldBonds/blob/943df3a8fcd8dd128af3beb0c85a0480c0e95ead/contracts/oracle/YieldOracle.sol#L114)\n* The [`yieldCumulativeStart_` parameter in the `computeAmountOut` function](https://github.com/BarnBridge/BarnBridge-SmartYieldBonds/blob/943df3a8fcd8dd128af3beb0c85a0480c0e95ead/contracts/oracle/YieldOracle.sol#L102)\n\n\nSome global values are defined in all capitals, however this style should be reserved for constants. This can lead users to believe that certain values cannot be changed, when in reality they can be. For example:\n\n\n* [`HARVEST_REWARD`](https://github.com/BarnBridge/BarnBridge-SmartYieldBonds/blob/943df3a8fcd8dd128af3beb0c85a0480c0e95ead/contracts/IController.sol#L16) is a non-constant defined in capitals.\n* [`feesOwner`](https://github.com/BarnBridge/BarnBridge-SmartYieldBonds/blob/943df3a8fcd8dd128af3beb0c85a0480c0e95ead/contracts/IController.sol#L13) is a non-constant defined in camel case.\n\n\nIn function definitions split across multiple lines:\n\n\n* Some put all visibility modifiers on one line, for example in [`observationIndexOf`](https://github.com/BarnBridge/BarnBridge-SmartYieldBonds/blob/943df3a8fcd8dd128af3beb0c85a0480c0e95ead/contracts/oracle/YieldOracle.sol#L62).\n* Others split these across different lines, for example in [`getUniswapPath`](https://github.com/BarnBridge/BarnBridge-SmartYieldBonds/blob/943df3a8fcd8dd128af3beb0c85a0480c0e95ead/contracts/providers/CompoundController.sol#L41).\n\n\nFurthermore, function ordering deviates from the [recommendation in the Solidity Style Guide](https://docs.soliditylang.org/en/v0.5.3/style-guide.html#order-of-functions). While the codebase does generally adhere to some form of function ordering, it is not always consistently implemented. For example:\n\n\n* In the [`// internals`](https://github.com/BarnBridge/BarnBridge-SmartYieldBonds/blob/943df3a8fcd8dd128af3beb0c85a0480c0e95ead/contracts/SmartYield.sol#L437) section of [`SmartYield` contract](https://github.com/BarnBridge/BarnBridge-SmartYieldBonds/blob/943df3a8fcd8dd128af3beb0c85a0480c0e95ead/contracts/SmartYield.sol), there is a public function definition for [`unaccountBonds`](https://github.com/BarnBridge/BarnBridge-SmartYieldBonds/blob/943df3a8fcd8dd128af3beb0c85a0480c0e95ead/contracts/SmartYield.sol#L478).\n\n\nConsider enforcing a standard coding style, such as that provided by the [Solidity Style Guide](https://solidity.readthedocs.io/en/latest/style-guide.html), to improve the project’s overall legibility. Also consider using a linter like [Solhint](https://github.com/protofire/solhint) to define a style and analyze the codebase for style deviations.\n\n\n**Update**: *The BarnBridge team did not address this issue.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/providers/CompoundProvider.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./../external-interfaces/uniswap/IUniswapV2Router.sol\";\nimport \"./../external-interfaces/compound-finance/ICToken.sol\";\nimport \"./../external-interfaces/compound-finance/IComptroller.sol\";\n\nimport \"./../lib/math/MathUtils.sol\";\n\nimport \"./CompoundController.sol\";\nimport \"./../oracle/IYieldOracle.sol\";\nimport \"./../IProvider.sol\";\n\ncontract CompoundProvider is IProvider {\n    using SafeMath for uint256;\n\n    // underlying token (ie. DAI)\n    address public uToken; // IERC20\n\n    // claim token (ie. cDAI)\n    address public cToken;\n\n    // compound.finance Comptroller\n    address public comptroller; // IComptroller\n\n    // deposit reward token (ie. COMP)\n    address public rewardCToken; // IERC20\n\n    // cToken.balanceOf(this) measuring only deposits by users (excludes dirrect cToken transfers to pool)\n    uint256 public cTokenBalance;\n\n    // --- COMP reward checkpoint\n    // saved comptroller.compSupplyState(cToken) value @ the moment the pool harvested\n    uint256 public compSupplierIndexLast;\n\n    // cumulative balanceOf @ last harvest\n    uint256 public cumulativeUnderlyingBalanceHarvestedLast;\n\n    // when we last harvested\n    uint256 public harvestedLast;\n    // --- /COMP reward checkpoint\n\n    bool public _setup;\n\n    modifier accountYield {\n        _accountYieldInternal();\n        IYieldOracle(IController(this.controller()).oracle()).update();\n\n        _;\n\n        underlyingBalanceLast = this.underlyingBalance();\n    }\n\n    function setup(\n        address smartYield_,\n        address controller_,\n        address cToken_\n    )\n      external\n    {\n        require(\n          false == _setup,\n          \"PPC: already setup\"\n        );\n\n        smartYield = smartYield_;\n        controller = controller_;\n        cToken = cToken_;\n        uToken = ICToken(cToken_).underlying();\n        comptroller = ICToken(cToken_).comptroller();\n        rewardCToken = IComptroller(comptroller).getCompAddress();\n\n        _enterMarket();\n\n        _setup = true;\n    }\n\n  // externals\n\n    // take underlyingAmount_ from from_\n    function _takeUnderlying(address from_, uint256 underlyingAmount_)\n      external override\n      onlySmartYield\n    {\n        require(\n            underlyingAmount_ <= IERC20(uToken).allowance(from_, address(this)),\n            \"PPC: _takeUnderlying allowance\"\n        );\n        require(\n            IERC20(uToken).transferFrom(from_, address(this), underlyingAmount_),\n            \"PPC: _takeUnderlying transferFrom\"\n        );\n    }\n\n    // transfer away underlyingAmount_ to to_\n    function _sendUnderlying(address to_, uint256 underlyingAmount_)\n      external override\n      onlySmartYield\n      returns (bool)\n    {\n        return IERC20(uToken).transfer(to_, underlyingAmount_);\n    }\n\n    // deposit underlyingAmount_ with the liquidity provider adds resulting cTokens to cTokenBalance\n    // on the very first call enters the compound.finance market and saves the checkpoint needed for compRewardExpected\n    function _depositProvider(uint256 underlyingAmount_, uint256 takeFees_)\n      external override\n      onlySmartYield\n    {\n        _depositProviderInternal(underlyingAmount_, takeFees_);\n    }\n\n    // withdraw underlyingAmount_ from the liquidity provider, substract the lost cTokens from cTokenBalance\n    function _withdrawProvider(uint256 underlyingAmount_, uint256 takeFees_)\n      external override\n      onlySmartYield\n      accountYield\n    {\n        underlyingFees += takeFees_;\n\n        uint256 cTokensBefore = ICTokenErc20(cToken).balanceOf(address(this));\n        uint256 err = ICToken(cToken).redeemUnderlying(underlyingAmount_);\n        require(0 == err, \"PPC: _withdrawProvider redeemUnderlying\");\n        cTokenBalance -= cTokensBefore - ICTokenErc20(cToken).balanceOf(address(this));\n    }\n\n    // called by anyone to convert pool's COMP -> underlying and then deposit it. caller gets HARVEST_REWARD of the harvest\n    function harvest()\n      external override\n    {\n        require(\n          harvestedLast < this.currentTime(),\n          \"PPC: harvest later\"\n        );\n\n        // this is 0 unless someone transfers underlying to the contract\n        uint256 underlyingBefore = IERC20(uToken).balanceOf(address(this));\n\n        // COMP gets on the pool when:\n        // 1) pool calls comptroller.claimComp()\n        // 2) anyone calls comptroller.claimComp()\n        // 3) anyone transfers COMP to the pool\n        // we want to yield closest to 1+2 but not 3\n        uint256 rewardExpected = compRewardExpected(); // COMP\n\n        address[] memory holders = new address[](1);\n        holders[0] = address(this);\n        address[] memory markets = new address[](1);\n        markets[0] = cToken;\n\n        IComptroller(comptroller).claimComp(holders, markets, false, true);\n\n        _updateCompState();\n\n        uint256 rewardGot = IERC20(rewardCToken).balanceOf(address(this)); // COMP\n\n        if (rewardGot > 0) {\n            address uniswap = CompoundController(controller).uniswap();\n\n            // should be like:\n            // address[] memory path = new address[](3);\n            // path[0] = address(rewardCToken);\n            // path[1] = address(wethToken);\n            // path[2] = address(uToken);\n            address[] memory path = CompoundController(controller).getUniswapPath();\n\n            // TODO: optimize pre-approve uniswap, gas\n            IERC20(rewardCToken).approve(address(uniswap), rewardGot);\n\n            IUniswapV2Router(uniswap).swapExactTokensForTokens(\n                rewardGot,\n                uint256(0),\n                path,\n                address(this),\n                this.currentTime() + 1800\n            );\n        }\n\n        uint256 underlyingGot = IERC20(uToken).balanceOf(address(this));\n\n        if (underlyingGot == 0) {\n          // got no goodies :(\n          return;\n        }\n\n        uint256 extra;\n\n        if (underlyingBefore > 0) {\n          // someone sent us a present as underlying -> add it to the fees\n          extra = underlyingBefore;\n          underlyingGot -= extra;\n        }\n\n        if (rewardGot > rewardExpected) {\n          // moar present as COMP reward -> add it to the fees\n          // throw event\n          uint256 rExtra = MathUtils.fractionOf(underlyingGot, (rewardGot - rewardExpected) * 1e18 / rewardGot);\n          extra += rExtra;\n          underlyingGot -= rExtra;\n        }\n\n        uint256 toCaller = MathUtils.fractionOf(underlyingGot, CompoundController(controller).HARVEST_REWARD());\n\n        // deposit pool reward to compound - harvest reward + any goodies we received\n        // any extra goodies go to fees\n        _depositProviderInternal(underlyingGot - toCaller + extra, extra);\n\n        // pay this man\n        IERC20(uToken).transfer(msg.sender, IERC20(uToken).balanceOf(address(this)));\n    }\n\n    function transferFees()\n      external\n      override\n      accountYield\n    {\n      // cleanup any cTokens dust or cTokens that may have been dumped on the pool\n      if (ICTokenErc20(cToken).balanceOf(address(this)) > cTokenBalance) {\n        underlyingFees += ICToken(cToken).exchangeRateStored() * (ICTokenErc20(cToken).balanceOf(address(this)) - cTokenBalance) / 1e18;\n      }\n      uint256 ctokensToPay = underlyingFees * 1e18 / ICToken(cToken).exchangeRateStored();\n      uint256 err = ICToken(cToken).redeem(\n          MathUtils.min(ctokensToPay, ICTokenErc20(cToken).balanceOf(address(this)))\n      );\n      require(0 == err, \"PPC: transferFees redeem\");\n      underlyingFees = 0;\n      cTokenBalance = ICTokenErc20(cToken).balanceOf(address(this));\n      IERC20(uToken).transfer(IController(controller).feesOwner(), IERC20(uToken).balanceOf(address(this)));\n    }\n\n    // returns cumulatives and accumulates/updates internal state\n    // oracle should call this when updating\n    function cumulatives()\n      external override\n    returns(uint256 cumulativeSecondlyYield, uint256 cumulativeUnderlyingBalance) {\n        _accountYieldInternal();\n        underlyingBalanceLast = this.underlyingBalance();\n        return (cumulativeSecondlyYieldLast, cumulativeUnderlyingBalanceLast);\n    }\n\n    // returns cumulated yield per 1 underlying coin (ie 1 DAI, 1 ETH) times 1e18\n    // per https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/libraries/UniswapV2OracleLibrary.sol#L16\n    function currentCumulatives()\n      external view override\n    returns (uint256 cumulativeSecondlyYield, uint256 cumulativeUnderlyingBalance)\n    {\n        uint32 blockTimestamp = uint32(this.currentTime() % 2**32);\n        cumulativeSecondlyYield = cumulativeSecondlyYieldLast;\n        cumulativeUnderlyingBalance = cumulativeUnderlyingBalanceLast;\n\n        uint32 timeElapsed = blockTimestamp - cumulativeTimestampLast; // overflow is desired\n        if (timeElapsed > 0) {\n            if (underlyingBalanceLast > 0) {\n              // cumulativeSecondlyYield overflows eventually,\n              // due to the way it is used in the oracle that's ok,\n              // as long as it doesn't overflow twice during the windowSize\n              // see OraclelizedMock.cumulativeOverflowProof() for proof\n              cumulativeSecondlyYield +=\n                  // (this.underlyingBalance() - underlyingBalanceLast) * 1e18 -> overflows only if (this.underlyingBalance() - underlyingBalanceLast) >~ 10^41 ETH, DAI, USDC etc\n                  // (this.underlyingBalance() - underlyingBalanceLast) never underflows\n                  ((this.underlyingBalance() - underlyingBalanceLast) * 1e18) / underlyingBalanceLast;\n            }\n            cumulativeUnderlyingBalance += this.underlyingBalance() * timeElapsed;\n        }\n        return (cumulativeSecondlyYield, cumulativeUnderlyingBalance);\n    }\n\n    // current total underlying balance, as measured by pool\n    function underlyingBalance()\n      external view virtual override\n    returns (uint256)\n    {\n        // https://compound.finance/docs#protocol-math\n        return\n            cTokenBalance * ICToken(cToken).exchangeRateStored() / 1e18;\n    }\n\n  // /externals\n\n    function currentTime()\n      public view virtual override\n      returns (uint256)\n    {\n        // mockable\n        return block.timestamp;\n    }\n\n    // computes how much COMP tokens compound.finance will give us at comptroller.claimComp()\n    // note: have to do it because comptroller.claimComp() is callable by anyone\n    // source: https://github.com/compound-finance/compound-protocol/blob/master/contracts/Comptroller.sol#L1145\n    function compRewardExpected()\n      public view virtual\n      returns (uint256)\n    {\n        (uint224 supplyStateIndex, ) = IComptroller(comptroller).compSupplyState(cToken);\n        uint256 supplyIndex = uint256(supplyStateIndex);\n        uint256 supplierIndex = compSupplierIndexLast;\n\n        uint256 deltaIndex = (supplyIndex).sub(supplierIndex); // a - b\n        (, uint256 cumulativeUnderlyingBalanceNow) = this.currentCumulatives();\n        uint256 timeElapsed = this.currentTime() - harvestedLast; // harvest() has require\n\n        uint256 waUnderlyingTotal = ((cumulativeUnderlyingBalanceNow - cumulativeUnderlyingBalanceHarvestedLast) * 1e18 / timeElapsed);\n        // uint256 supplierTokens = ICTokenErc20(cToken).balanceOf(address(this))\n        uint256 supplierTokens = waUnderlyingTotal / ICToken(cToken).exchangeRateStored();\n        return (supplierTokens).mul(deltaIndex).div(1e36); // a * b / doubleScale => uint\n    }\n\n  // internals\n\n    function _depositProviderInternal(uint256 underlyingAmount_, uint256 takeFees_)\n      internal\n      accountYield\n    {\n        if (0 == cTokenBalance && 0 == compSupplierIndexLast) {\n          // this will be called once only for the first comp deposit after pool deploy\n          _updateCompState();\n        }\n        underlyingFees += takeFees_;\n\n        uint256 cTokensBefore = ICTokenErc20(cToken).balanceOf(address(this));\n        // TODO: optimization, pre-approve provider: gas\n        IERC20(uToken).approve(address(cToken), underlyingAmount_);\n        uint256 err = ICToken(cToken).mint(underlyingAmount_);\n        require(0 == err, \"PPC: _depositProvider mint\");\n        cTokenBalance += ICTokenErc20(cToken).balanceOf(address(this)) - cTokensBefore;\n    }\n\n    function _accountYieldInternal()\n      internal\n    {\n        uint32 blockTimestamp = uint32(this.currentTime() % 2**32);\n        uint32 timeElapsed = blockTimestamp - cumulativeTimestampLast; // overflow is desired\n        // only for the first time in the block\n        if (timeElapsed > 0) {\n            // if there's underlying\n            if (underlyingBalanceLast > 0) {\n              // cumulativeSecondlyYieldLast overflows eventually,\n              // due to the way it is used in the oracle that's ok,\n              // as long as it doesn't overflow twice during the windowSize\n              // see OraclelizedMock.cumulativeOverflowProof() for proof\n              cumulativeSecondlyYieldLast +=\n                  // (this.underlyingBalance() - underlyingBalanceLast) * 1e18 -> overflows only if (this.underlyingBalance() - underlyingBalanceLast) >~ 10^41 ETH, DAI, USDC etc\n                  // (this.underlyingBalance() - underlyingBalanceLast) never underflows\n                  ((this.underlyingBalance() - underlyingBalanceLast) * 1e18) / underlyingBalanceLast;\n            }\n\n            cumulativeUnderlyingBalanceLast += this.underlyingBalance() * timeElapsed;\n\n            cumulativeTimestampLast = blockTimestamp;\n        }\n    }\n\n    // call comptroller.enterMarkets()\n    // needs to be called only once BUT before any interactions with the provider\n    function _enterMarket()\n      internal\n    {\n        address[] memory markets = new address[](1);\n        markets[0] = cToken;\n        uint256[] memory err = IComptroller(comptroller).enterMarkets(markets);\n        require(err[0] == 0, \"PPC: _enterMarket\");\n    }\n\n\n    // creates checkpoint items needed to compute compRewardExpected()\n    // needs to be called right after each claimComp(), and just before the first ever deposit\n    function _updateCompState()\n      internal\n    {\n        (uint224 supplyStateIndex, ) = IComptroller(comptroller).compSupplyState(cToken);\n        compSupplierIndexLast = uint256(supplyStateIndex);\n        (, cumulativeUnderlyingBalanceHarvestedLast) = this.currentCumulatives();\n        harvestedLast = this.currentTime();\n    }\n\n    // /internals\n\n}"
    },
    {
      "filename": "contracts/providers/CompoundProvider.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./../external-interfaces/uniswap/IUniswapV2Router.sol\";\nimport \"./../external-interfaces/compound-finance/ICToken.sol\";\nimport \"./../external-interfaces/compound-finance/IComptroller.sol\";\n\nimport \"./../lib/math/MathUtils.sol\";\n\nimport \"./CompoundController.sol\";\nimport \"./../oracle/IYieldOracle.sol\";\nimport \"./../IProvider.sol\";\n\ncontract CompoundProvider is IProvider {\n    using SafeMath for uint256;\n\n    // underlying token (ie. DAI)\n    address public uToken; // IERC20\n\n    // claim token (ie. cDAI)\n    address public cToken;\n\n    // compound.finance Comptroller\n    address public comptroller; // IComptroller\n\n    // deposit reward token (ie. COMP)\n    address public rewardCToken; // IERC20\n\n    // cToken.balanceOf(this) measuring only deposits by users (excludes dirrect cToken transfers to pool)\n    uint256 public cTokenBalance;\n\n    // --- COMP reward checkpoint\n    // saved comptroller.compSupplyState(cToken) value @ the moment the pool harvested\n    uint256 public compSupplierIndexLast;\n\n    // cumulative balanceOf @ last harvest\n    uint256 public cumulativeUnderlyingBalanceHarvestedLast;\n\n    // when we last harvested\n    uint256 public harvestedLast;\n    // --- /COMP reward checkpoint\n\n    bool public _setup;\n\n    modifier accountYield {\n        _accountYieldInternal();\n        IYieldOracle(IController(this.controller()).oracle()).update();\n\n        _;\n\n        underlyingBalanceLast = this.underlyingBalance();\n    }\n\n    function setup(\n        address smartYield_,\n        address controller_,\n        address cToken_\n    )\n      external\n    {\n        require(\n          false == _setup,\n          \"PPC: already setup\"\n        );\n\n        smartYield = smartYield_;\n        controller = controller_;\n        cToken = cToken_;\n        uToken = ICToken(cToken_).underlying();\n        comptroller = ICToken(cToken_).comptroller();\n        rewardCToken = IComptroller(comptroller).getCompAddress();\n\n        _enterMarket();\n\n        _setup = true;\n    }\n\n  // externals\n\n    // take underlyingAmount_ from from_\n    function _takeUnderlying(address from_, uint256 underlyingAmount_)\n      external override\n      onlySmartYield\n    {\n        require(\n            underlyingAmount_ <= IERC20(uToken).allowance(from_, address(this)),\n            \"PPC: _takeUnderlying allowance\"\n        );\n        require(\n            IERC20(uToken).transferFrom(from_, address(this), underlyingAmount_),\n            \"PPC: _takeUnderlying transferFrom\"\n        );\n    }\n\n    // transfer away underlyingAmount_ to to_\n    function _sendUnderlying(address to_, uint256 underlyingAmount_)\n      external override\n      onlySmartYield\n      returns (bool)\n    {\n        return IERC20(uToken).transfer(to_, underlyingAmount_);\n    }\n\n    // deposit underlyingAmount_ with the liquidity provider adds resulting cTokens to cTokenBalance\n    // on the very first call enters the compound.finance market and saves the checkpoint needed for compRewardExpected\n    function _depositProvider(uint256 underlyingAmount_, uint256 takeFees_)\n      external override\n      onlySmartYield\n    {\n        _depositProviderInternal(underlyingAmount_, takeFees_);\n    }\n\n    // withdraw underlyingAmount_ from the liquidity provider, substract the lost cTokens from cTokenBalance\n    function _withdrawProvider(uint256 underlyingAmount_, uint256 takeFees_)\n      external override\n      onlySmartYield\n      accountYield\n    {\n        underlyingFees += takeFees_;\n\n        uint256 cTokensBefore = ICTokenErc20(cToken).balanceOf(address(this));\n        uint256 err = ICToken(cToken).redeemUnderlying(underlyingAmount_);\n        require(0 == err, \"PPC: _withdrawProvider redeemUnderlying\");\n        cTokenBalance -= cTokensBefore - ICTokenErc20(cToken).balanceOf(address(this));\n    }\n\n    // called by anyone to convert pool's COMP -> underlying and then deposit it. caller gets HARVEST_REWARD of the harvest\n    function harvest()\n      external override\n    {\n        require(\n          harvestedLast < this.currentTime(),\n          \"PPC: harvest later\"\n        );\n\n        // this is 0 unless someone transfers underlying to the contract\n        uint256 underlyingBefore = IERC20(uToken).balanceOf(address(this));\n\n        // COMP gets on the pool when:\n        // 1) pool calls comptroller.claimComp()\n        // 2) anyone calls comptroller.claimComp()\n        // 3) anyone transfers COMP to the pool\n        // we want to yield closest to 1+2 but not 3\n        uint256 rewardExpected = compRewardExpected(); // COMP\n\n        address[] memory holders = new address[](1);\n        holders[0] = address(this);\n        address[] memory markets = new address[](1);\n        markets[0] = cToken;\n\n        IComptroller(comptroller).claimComp(holders, markets, false, true);\n\n        _updateCompState();\n\n        uint256 rewardGot = IERC20(rewardCToken).balanceOf(address(this)); // COMP\n\n        if (rewardGot > 0) {\n            address uniswap = CompoundController(controller).uniswap();\n\n            // should be like:\n            // address[] memory path = new address[](3);\n            // path[0] = address(rewardCToken);\n            // path[1] = address(wethToken);\n            // path[2] = address(uToken);\n            address[] memory path = CompoundController(controller).getUniswapPath();\n\n            // TODO: optimize pre-approve uniswap, gas\n            IERC20(rewardCToken).approve(address(uniswap), rewardGot);\n\n            IUniswapV2Router(uniswap).swapExactTokensForTokens(\n                rewardGot,\n                uint256(0),\n                path,\n                address(this),\n                this.currentTime() + 1800\n            );\n        }\n\n        uint256 underlyingGot = IERC20(uToken).balanceOf(address(this));\n\n        if (underlyingGot == 0) {\n          // got no goodies :(\n          return;\n        }\n\n        uint256 extra;\n\n        if (underlyingBefore > 0) {\n          // someone sent us a present as underlying -> add it to the fees\n          extra = underlyingBefore;\n          underlyingGot -= extra;\n        }\n\n        if (rewardGot > rewardExpected) {\n          // moar present as COMP reward -> add it to the fees\n          // throw event\n          uint256 rExtra = MathUtils.fractionOf(underlyingGot, (rewardGot - rewardExpected) * 1e18 / rewardGot);\n          extra += rExtra;\n          underlyingGot -= rExtra;\n        }\n\n        uint256 toCaller = MathUtils.fractionOf(underlyingGot, CompoundController(controller).HARVEST_REWARD());\n\n        // deposit pool reward to compound - harvest reward + any goodies we received\n        // any extra goodies go to fees\n        _depositProviderInternal(underlyingGot - toCaller + extra, extra);\n\n        // pay this man\n        IERC20(uToken).transfer(msg.sender, IERC20(uToken).balanceOf(address(this)));\n    }\n\n    function transferFees()\n      external\n      override\n      accountYield\n    {\n      // cleanup any cTokens dust or cTokens that may have been dumped on the pool\n      if (ICTokenErc20(cToken).balanceOf(address(this)) > cTokenBalance) {\n        underlyingFees += ICToken(cToken).exchangeRateStored() * (ICTokenErc20(cToken).balanceOf(address(this)) - cTokenBalance) / 1e18;\n      }\n      uint256 ctokensToPay = underlyingFees * 1e18 / ICToken(cToken).exchangeRateStored();\n      uint256 err = ICToken(cToken).redeem(\n          MathUtils.min(ctokensToPay, ICTokenErc20(cToken).balanceOf(address(this)))\n      );\n      require(0 == err, \"PPC: transferFees redeem\");\n      underlyingFees = 0;\n      cTokenBalance = ICTokenErc20(cToken).balanceOf(address(this));\n      IERC20(uToken).transfer(IController(controller).feesOwner(), IERC20(uToken).balanceOf(address(this)));\n    }\n\n    // returns cumulatives and accumulates/updates internal state\n    // oracle should call this when updating\n    function cumulatives()\n      external override\n    returns(uint256 cumulativeSecondlyYield, uint256 cumulativeUnderlyingBalance) {\n        _accountYieldInternal();\n        underlyingBalanceLast = this.underlyingBalance();\n        return (cumulativeSecondlyYieldLast, cumulativeUnderlyingBalanceLast);\n    }\n\n    // returns cumulated yield per 1 underlying coin (ie 1 DAI, 1 ETH) times 1e18\n    // per https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/libraries/UniswapV2OracleLibrary.sol#L16\n    function currentCumulatives()\n      external view override\n    returns (uint256 cumulativeSecondlyYield, uint256 cumulativeUnderlyingBalance)\n    {\n        uint32 blockTimestamp = uint32(this.currentTime() % 2**32);\n        cumulativeSecondlyYield = cumulativeSecondlyYieldLast;\n        cumulativeUnderlyingBalance = cumulativeUnderlyingBalanceLast;\n\n        uint32 timeElapsed = blockTimestamp - cumulativeTimestampLast; // overflow is desired\n        if (timeElapsed > 0) {\n            if (underlyingBalanceLast > 0) {\n              // cumulativeSecondlyYield overflows eventually,\n              // due to the way it is used in the oracle that's ok,\n              // as long as it doesn't overflow twice during the windowSize\n              // see OraclelizedMock.cumulativeOverflowProof() for proof\n              cumulativeSecondlyYield +=\n                  // (this.underlyingBalance() - underlyingBalanceLast) * 1e18 -> overflows only if (this.underlyingBalance() - underlyingBalanceLast) >~ 10^41 ETH, DAI, USDC etc\n                  // (this.underlyingBalance() - underlyingBalanceLast) never underflows\n                  ((this.underlyingBalance() - underlyingBalanceLast) * 1e18) / underlyingBalanceLast;\n            }\n            cumulativeUnderlyingBalance += this.underlyingBalance() * timeElapsed;\n        }\n        return (cumulativeSecondlyYield, cumulativeUnderlyingBalance);\n    }\n\n    // current total underlying balance, as measured by pool\n    function underlyingBalance()\n      external view virtual override\n    returns (uint256)\n    {\n        // https://compound.finance/docs#protocol-math\n        return\n            cTokenBalance * ICToken(cToken).exchangeRateStored() / 1e18;\n    }\n\n  // /externals\n\n    function currentTime()\n      public view virtual override\n      returns (uint256)\n    {\n        // mockable\n        return block.timestamp;\n    }\n\n    // computes how much COMP tokens compound.finance will give us at comptroller.claimComp()\n    // note: have to do it because comptroller.claimComp() is callable by anyone\n    // source: https://github.com/compound-finance/compound-protocol/blob/master/contracts/Comptroller.sol#L1145\n    function compRewardExpected()\n      public view virtual\n      returns (uint256)\n    {\n        (uint224 supplyStateIndex, ) = IComptroller(comptroller).compSupplyState(cToken);\n        uint256 supplyIndex = uint256(supplyStateIndex);\n        uint256 supplierIndex = compSupplierIndexLast;\n\n        uint256 deltaIndex = (supplyIndex).sub(supplierIndex); // a - b\n        (, uint256 cumulativeUnderlyingBalanceNow) = this.currentCumulatives();\n        uint256 timeElapsed = this.currentTime() - harvestedLast; // harvest() has require\n\n        uint256 waUnderlyingTotal = ((cumulativeUnderlyingBalanceNow - cumulativeUnderlyingBalanceHarvestedLast) * 1e18 / timeElapsed);\n        // uint256 supplierTokens = ICTokenErc20(cToken).balanceOf(address(this))\n        uint256 supplierTokens = waUnderlyingTotal / ICToken(cToken).exchangeRateStored();\n        return (supplierTokens).mul(deltaIndex).div(1e36); // a * b / doubleScale => uint\n    }\n\n  // internals\n\n    function _depositProviderInternal(uint256 underlyingAmount_, uint256 takeFees_)\n      internal\n      accountYield\n    {\n        if (0 == cTokenBalance && 0 == compSupplierIndexLast) {\n          // this will be called once only for the first comp deposit after pool deploy\n          _updateCompState();\n        }\n        underlyingFees += takeFees_;\n\n        uint256 cTokensBefore = ICTokenErc20(cToken).balanceOf(address(this));\n        // TODO: optimization, pre-approve provider: gas\n        IERC20(uToken).approve(address(cToken), underlyingAmount_);\n        uint256 err = ICToken(cToken).mint(underlyingAmount_);\n        require(0 == err, \"PPC: _depositProvider mint\");\n        cTokenBalance += ICTokenErc20(cToken).balanceOf(address(this)) - cTokensBefore;\n    }\n\n    function _accountYieldInternal()\n      internal\n    {\n        uint32 blockTimestamp = uint32(this.currentTime() % 2**32);\n        uint32 timeElapsed = blockTimestamp - cumulativeTimestampLast; // overflow is desired\n        // only for the first time in the block\n        if (timeElapsed > 0) {\n            // if there's underlying\n            if (underlyingBalanceLast > 0) {\n              // cumulativeSecondlyYieldLast overflows eventually,\n              // due to the way it is used in the oracle that's ok,\n              // as long as it doesn't overflow twice during the windowSize\n              // see OraclelizedMock.cumulativeOverflowProof() for proof\n              cumulativeSecondlyYieldLast +=\n                  // (this.underlyingBalance() - underlyingBalanceLast) * 1e18 -> overflows only if (this.underlyingBalance() - underlyingBalanceLast) >~ 10^41 ETH, DAI, USDC etc\n                  // (this.underlyingBalance() - underlyingBalanceLast) never underflows\n                  ((this.underlyingBalance() - underlyingBalanceLast) * 1e18) / underlyingBalanceLast;\n            }\n\n            cumulativeUnderlyingBalanceLast += this.underlyingBalance() * timeElapsed;\n\n            cumulativeTimestampLast = blockTimestamp;\n        }\n    }\n\n    // call comptroller.enterMarkets()\n    // needs to be called only once BUT before any interactions with the provider\n    function _enterMarket()\n      internal\n    {\n        address[] memory markets = new address[](1);\n        markets[0] = cToken;\n        uint256[] memory err = IComptroller(comptroller).enterMarkets(markets);\n        require(err[0] == 0, \"PPC: _enterMarket\");\n    }\n\n\n    // creates checkpoint items needed to compute compRewardExpected()\n    // needs to be called right after each claimComp(), and just before the first ever deposit\n    function _updateCompState()\n      internal\n    {\n        (uint224 supplyStateIndex, ) = IComptroller(comptroller).compSupplyState(cToken);\n        compSupplierIndexLast = uint256(supplyStateIndex);\n        (, cumulativeUnderlyingBalanceHarvestedLast) = this.currentCumulatives();\n        harvestedLast = this.currentTime();\n    }\n\n    // /internals\n\n}"
    },
    {
      "filename": "contracts/providers/CompoundProvider.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./../external-interfaces/uniswap/IUniswapV2Router.sol\";\nimport \"./../external-interfaces/compound-finance/ICToken.sol\";\nimport \"./../external-interfaces/compound-finance/IComptroller.sol\";\n\nimport \"./../lib/math/MathUtils.sol\";\n\nimport \"./CompoundController.sol\";\nimport \"./../oracle/IYieldOracle.sol\";\nimport \"./../IProvider.sol\";\n\ncontract CompoundProvider is IProvider {\n    using SafeMath for uint256;\n\n    // underlying token (ie. DAI)\n    address public uToken; // IERC20\n\n    // claim token (ie. cDAI)\n    address public cToken;\n\n    // compound.finance Comptroller\n    address public comptroller; // IComptroller\n\n    // deposit reward token (ie. COMP)\n    address public rewardCToken; // IERC20\n\n    // cToken.balanceOf(this) measuring only deposits by users (excludes dirrect cToken transfers to pool)\n    uint256 public cTokenBalance;\n\n    // --- COMP reward checkpoint\n    // saved comptroller.compSupplyState(cToken) value @ the moment the pool harvested\n    uint256 public compSupplierIndexLast;\n\n    // cumulative balanceOf @ last harvest\n    uint256 public cumulativeUnderlyingBalanceHarvestedLast;\n\n    // when we last harvested\n    uint256 public harvestedLast;\n    // --- /COMP reward checkpoint\n\n    bool public _setup;\n\n    modifier accountYield {\n        _accountYieldInternal();\n        IYieldOracle(IController(this.controller()).oracle()).update();\n\n        _;\n\n        underlyingBalanceLast = this.underlyingBalance();\n    }\n\n    function setup(\n        address smartYield_,\n        address controller_,\n        address cToken_\n    )\n      external\n    {\n        require(\n          false == _setup,\n          \"PPC: already setup\"\n        );\n\n        smartYield = smartYield_;\n        controller = controller_;\n        cToken = cToken_;\n        uToken = ICToken(cToken_).underlying();\n        comptroller = ICToken(cToken_).comptroller();\n        rewardCToken = IComptroller(comptroller).getCompAddress();\n\n        _enterMarket();\n\n        _setup = true;\n    }\n\n  // externals\n\n    // take underlyingAmount_ from from_\n    function _takeUnderlying(address from_, uint256 underlyingAmount_)\n      external override\n      onlySmartYield\n    {\n        require(\n            underlyingAmount_ <= IERC20(uToken).allowance(from_, address(this)),\n            \"PPC: _takeUnderlying allowance\"\n        );\n        require(\n            IERC20(uToken).transferFrom(from_, address(this), underlyingAmount_),\n            \"PPC: _takeUnderlying transferFrom\"\n        );\n    }\n\n    // transfer away underlyingAmount_ to to_\n    function _sendUnderlying(address to_, uint256 underlyingAmount_)\n      external override\n      onlySmartYield\n      returns (bool)\n    {\n        return IERC20(uToken).transfer(to_, underlyingAmount_);\n    }\n\n    // deposit underlyingAmount_ with the liquidity provider adds resulting cTokens to cTokenBalance\n    // on the very first call enters the compound.finance market and saves the checkpoint needed for compRewardExpected\n    function _depositProvider(uint256 underlyingAmount_, uint256 takeFees_)\n      external override\n      onlySmartYield\n    {\n        _depositProviderInternal(underlyingAmount_, takeFees_);\n    }\n\n    // withdraw underlyingAmount_ from the liquidity provider, substract the lost cTokens from cTokenBalance\n    function _withdrawProv"
    }
  ]
}