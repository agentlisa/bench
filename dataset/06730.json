{
  "Title": "[M-11] Later challengers can bid on the previous challenge to extend the expiration time of the previous challenge, so that their own challenge can succeed before the previous challenge and get challenge rewards",
  "Content": "\nWhen bidders bid, if the expiration time of the challenge is less than 30 minutes, the expiration time will be extended.\n\n```solidity\n            uint256 earliestEnd = block.timestamp + 30 minutes;\n            if (earliestEnd >= challenge.end) {\n                // bump remaining time like ebay does when last minute bids come in\n                // An attacker trying to postpone the challenge forever must increase the bid by 0.5%\n                // every 30 minutes, or double it every three days, making the attack hard to sustain\n                // for a prolonged period of time.\n                challenge.end = earliestEnd;\n            }\n```\n\nHowever, extending the expiration time will break the order of the challenges, so that the later challenges will succeed before the previous ones, thus affecting the challenger's reward expectations.\n\nConsider the following scenario:\n* There is a collateral of 2 WETH in a position, and as the actual price of WETH drops, challengers are attracted to challenge it.\n* In block 1, alice uses 2 WETH to challenge the position, and the expiration time is block 7201\n* At block 2, bob challenges the position with 2 WETH, expiring at block 7202\n* The bidder then bids 4000 ZCHF each for alice's and bob's challenges.\n* In block 7200, bob finds that if alice's challenge is successful, then bob will not be able to get the challenge reward, so bob bids 4200 ZCHF to alice's challenge. Alice's challenge expiration time is extended to block 7351.\n* At block 7201, alice cannot call end to make the challenge successful because the expiration time is extended\n* At block 7202, bob successfully calls end to make his challenge successful and gets the challenge reward.\n* In block 7351, alice calls the end function. Since the collateral in the position is 0 at this time, alice will not be able to get the challenge reward, and bob's 4200 zchf will be returned.\n\n```solidity\n    function notifyChallengeSucceeded(address _bidder, uint256 _bid, uint256 _size) external onlyHub returns (address, uint256, uint256, uint256, uint32) {\n        challengedAmount -= _size;\n        uint256 colBal = collateralBalance();\n        if (_size > colBal){\n            // Challenge is larger than the position. This can for example happen if there are multiple concurrent\n            // challenges that exceed the collateral balance in size. In this case, we need to redimension the bid and\n            // tell the caller that a part of the bid needs to be returned to the bidder.\n            _bid = _divD18(_mulD18(_bid, colBal), _size);\n            _size = colBal;\n        }\n\n        // Note that thanks to the collateral invariant, we know that\n        //    colBal * price >= minted * ONE_DEC18\n        // and that therefore\n        //    price >= minted / colbal * E18\n        // such that\n        //    volumeZCHF = price * size / E18 >= minted * size / colbal\n        // So the owner cannot maliciously decrease the price to make volume fall below the proportionate repayment.\n        uint256 volumeZCHF = _mulD18(price, _size); // How much could have minted with the challenged amount of the collateral\n        // The owner does not have to repay (and burn) more than the owner actually minted.  \n        uint256 repayment = minted < volumeZCHF ? minted : volumeZCHF; // how much must be burned to make things even\n\n```\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2023-04-frankencoin/blob/1022cb106919fba963a89205d3b90bf62543f68f/contracts/MintingHub.sol#L217-L224> <br><https://github.com/code-423n4/2023-04-frankencoin/blob/1022cb106919fba963a89205d3b90bf62543f68f/contracts/Position.sol#L329-L350>\n\n### Recommended Mitigation Steps\n\nConsider implementing a challenge queue that allows the end function to be called on subsequent challenges only after previous challenges have ended.\n\n**[luziusmeisser (Frankencoin) acknowledged and commented](https://github.com/code-423n4/2023-04-frankencoin-findings/issues/349#issuecomment-1532497402):**\n > Bids must at least be 0.5% higher than the previous bid, so pro-longing the challenge four times already costs as much as the whole challenger reward of 2%, making this attack not very attractive under normal circumstances.\n> \n> --> Not worth to add any complexity to change this.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-04-frankencoin",
  "Code": [
    {
      "filename": "contracts/MintingHub.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./IReserve.sol\";\nimport \"./IFrankencoin.sol\";\nimport \"./Ownable.sol\";\nimport \"./IPosition.sol\";\n\n/**\n * The central hub for creating, cloning and challenging collateralized Frankencoin positions.\n * Only one instance of this contract is required, whereas every new position comes with a new position\n * contract. Pending challenges are stored as structs in an array.\n */\ncontract MintingHub {\n\n    /**\n     * Irrevocable fee in ZCHF when proposing a new position (but not when cloning an existing one).\n     */\n    uint256 public constant OPENING_FEE = 1000 * 10**18;\n\n    /**\n     * The challenger reward in parts per million (ppm) relative to the challenged amount, whereas\n     * challenged amount if defined as the challenged collateral amount times the liquidation price.\n     */\n    uint32 public constant CHALLENGER_REWARD = 20000; // 2%\n\n    IPositionFactory private immutable POSITION_FACTORY; // position contract to clone\n\n    IFrankencoin public immutable zchf; // currency\n    Challenge[] public challenges; // list of open challenges\n\n    /**\n     * Map to remember pending postponed collateral returns.\n     * It maps collateral => beneficiary => amount.\n     */\n    mapping (address /** col */ => mapping (address => uint256)) public pendingReturns;\n\n    struct Challenge {\n        address challenger; // the address from which the challenge was initiated\n        IPosition position; // the position that was challenged\n        uint256 size;       // how much collateral the challenger provided\n        uint256 end;        // the deadline of the challenge (block.timestamp)\n        address bidder;     // the address from which the highest bid was made, if any\n        uint256 bid;        // the highest bid in ZCHF (total amount, not price per unit)\n    }\n\n    event ChallengeStarted(address indexed challenger, address indexed position, uint256 size, uint256 number);\n    event ChallengeAverted(address indexed position, uint256 number);\n    event ChallengeSucceeded(address indexed position, uint256 bid, uint256 number);\n    event NewBid(uint256 challengedId, uint256 bidAmount, address bidder);\n    event PostPonedReturn(address collateral, address indexed beneficiary, uint256 amount);\n\n    constructor(address _zchf, address factory) {\n        zchf = IFrankencoin(_zchf);\n        POSITION_FACTORY = IPositionFactory(factory);\n    }\n\n    function openPosition(\n        address _collateralAddress, uint256 _minCollateral, uint256 _initialCollateral,\n        uint256 _mintingMaximum, uint256 _expirationSeconds, uint256 _challengeSeconds,\n        uint32 _mintingFeePPM, uint256 _liqPrice, uint32 _reservePPM) public returns (address) {\n            return openPosition(_collateralAddress, _minCollateral, _initialCollateral, _mintingMaximum,\n            7 days, _expirationSeconds, _challengeSeconds, _mintingFeePPM, _liqPrice, _reservePPM);\n    }\n\n    /**\n     * Open a collateralized loan position. See also https://docs.frankencoin.com/positions/open .\n     * For a successful call, you must set allowances for both ZCHF and the collateral token, allowing\n     * the minting hub to transfer the initial collateral amount to the newly created position and to\n     * withdraw the fees.\n     *\n     * Together, the expiration and the minting fee imply an interest rate.\n     * TODO: in future versions, it might be better to fix the interest and not the fee\n     *\n     * @param _collateralAddress        address of collateral token\n     * @param _minCollateral     minimum collateral required to prevent dust amounts\n     * @param _initialCollateral amount of initial collateral to be deposited\n     * @param _mintingMaximum    maximal amount of ZCHF that can be minted by the position owner\n     * @param _expirationSeconds position tenor in unit of timestamp (seconds) from 'now'\n     * @param _challengeSeconds  challenge period. Longer for less liquid collateral.\n     * @param _mintingFeePPM     ppm of minted amount that is paid as fee to the equity contract\n     * @param _liqPrice          Liquidation price with (36 - token decimals) decimals,\n     *                           e.g. 18 decimals for an 18 decimal collateral, 36 decimals for a 0 decimal collateral.\n     * @param _reservePPM        ppm of minted amount that is locked as borrower's reserve, e.g. 20%\n     * @return address           address of created position\n     */\n    function openPosition(\n        address _collateralAddress, uint256 _minCollateral, uint256 _initialCollateral,\n        uint256 _mintingMaximum, uint256 _initPeriodSeconds, uint256 _expirationSeconds, uint256 _challengeSeconds,\n        uint32 _mintingFeePPM, uint256 _liqPrice, uint32 _reservePPM) public returns (address) {\n        IPosition pos = IPosition(\n            POSITION_FACTORY.createNewPosition(\n                msg.sender,\n                address(zchf),\n                _collateralAddress,\n                _minCollateral,\n                _mintingMaximum,\n                _initPeriodSeconds,\n                _expirationSeconds,\n                _challengeSeconds,\n                _mintingFeePPM,\n                _liqPrice,\n                _reservePPM\n            )\n        );\n        zchf.registerPosition(address(pos));\n        zchf.transferFrom(msg.sender, address(zchf.reserve()), OPENING_FEE);\n        require(_initialCollateral >= _minCollateral, \"must start with min col\");\n        IERC20(_collateralAddress).transferFrom(msg.sender, address(pos), _initialCollateral);\n\n        return address(pos);\n    }\n\n    modifier validPos(address position) {\n        require(zchf.isPosition(position) == address(this), \"not our pos\");\n        _;\n    }\n\n    /**\n     * Clones an existing position and immediately tries to mint the specified amount using the given amount of collateral.\n     * This requires an allowance to be set on the collateral contract such that the minting hub can withdraw the collateral.\n     */\n    function clonePosition(address position, uint256 _initialCollateral, uint256 _initialMint) public validPos(position) returns (address) {\n        IPosition existing = IPosition(position);\n        uint256 limit = existing.reduceLimitForClone(_initialMint);\n        address pos = POSITION_FACTORY.clonePosition(position);\n        zchf.registerPosition(pos);\n        existing.collateral().transferFrom(msg.sender, address(pos), _initialCollateral);\n        IPosition(pos).initializeClone(msg.sender, existing.price(), limit, _initialCollateral, _initialMint);\n        return address(pos);\n    }\n\n    /**\n     * Launch a challenge on a position\n     * @param _positionAddr      address of the position we want to challenge\n     * @param _collateralAmount  size of the collateral we want to challenge (dec 18)\n     * @return index of the challenge in challenge-array\n     */\n    function launchChallenge(address _positionAddr, uint256 _collateralAmount) external validPos(_positionAddr) returns (uint256) {\n        IPosition position = IPosition(_positionAddr);\n        IERC20(position.collateral()).transferFrom(msg.sender, address(this), _collateralAmount);\n        uint256 pos = challenges.length;\n        challenges.push(Challenge(msg.sender, position, _collateralAmount, block.timestamp + position.challengePeriod(), address(0x0), 0));\n        position.notifyChallengeStarted(_collateralAmount);\n        emit ChallengeStarted(msg.sender, address(position), _collateralAmount, pos);\n        return pos;\n    }\n\n    /**\n     * Splits a challenge into two smaller challenges.\n     * This can be useful to guard an attack, where a challenger launches a challenge so big that most bidders do not\n     * have the liquidity available to bid a sufficient amount. With this function, the can split of smaller slices of\n     * the challenge and avert it piece by piece.\n     */\n    function splitChallenge(uint256 _challengeNumber, uint256 splitOffAmount) external returns (uint256) {\n        Challenge storage challenge = challenges[_challengeNumber];\n        require(challenge.challenger != address(0x0));\n        Challenge memory copy = Challenge(\n            challenge.challenger,\n            challenge.position,\n            splitOffAmount,\n            challenge.end,\n            challenge.bidder,\n            (challenge.bid * splitOffAmount) / challenge.size\n        );\n        challenge.bid -= copy.bid;\n        challenge.size -= copy.size;\n\n        uint256 min = IPosition(challenge.position).minimumCollateral();\n        require(challenge.size >= min);\n        require(copy.size >= min);\n\n        uint256 pos = challenges.length;\n        challenges.push(copy);\n        emit ChallengeStarted(challenge.challenger, address(challenge.position), challenge.size, _challengeNumber);\n        emit ChallengeStarted(copy.challenger, address(copy.position), copy.size, pos);\n        return pos;\n    }\n\n    function minBid(uint256 challenge) public view returns (uint256) {\n        return minBid(challenges[challenge]);\n    }\n\n    /**\n     * The minimum bid size for the next bid. It must be 0.5% higher than the previous bid.\n     */\n    function minBid(Challenge storage challenge) internal view returns (uint256) {\n        return (challenge.bid * 1005) / 1000;\n    }\n\n    /**\n     * Post a bid in ZCHF given an open challenge. Requires a ZCHF allowance from the caller to the minting hub.\n     *\n     * @param _challengeNumber   index of the challenge as broadcast in the event\n     * @param _bidAmountZCHF     how much to bid for the collateral of this challenge (dec 18)\n     * @param expectedSize       size verification to guard against frontrunners doing a split-challenge-attack\n     */\n    function bid(uint256 _challengeNumber, uint256 _bidAmountZCHF, uint256 expectedSize) external {\n        Challenge storage challenge = challenges[_challengeNumber];\n        if (block.timestamp >= challenge.end) revert TooLate();\n        if (expectedSize != challenge.size) revert UnexpectedSize();\n        if (challenge.bid > 0) {\n            zchf.transfer(challenge.bidder, challenge.bid); // return old bid\n        }\n        emit NewBid(_challengeNumber, _bidAmountZCHF, msg.sender);\n        // ask position if the bid was high enough to avert the challenge\n        if (challenge.position.tryAvertChallenge(challenge.size, _bidAmountZCHF)) {\n            // bid was high enough, let bidder buy collateral from challenger\n            zchf.transferFrom(msg.sender, challenge.challenger, _bidAmountZCHF);\n            challenge.position.collateral().transfer(msg.sender, challenge.size);\n            emit ChallengeAverted(address(challenge.position), _challengeNumber);\n            delete challenges[_challengeNumber];\n        } else {\n            // challenge is not averted, update bid\n            if (_bidAmountZCHF < minBid(challenge)) revert BidTooLow(_bidAmountZCHF, minBid(challenge));\n            uint256 earliestEnd = block.timestamp + 30 minutes;\n            if (earliestEnd >= challenge.end) {\n                // bump remaining time like ebay does when last minute bids come in\n                // An attacker trying to postpone the challenge forever must increase the bid by 0.5%\n                // every 30 minutes, or double it every three days, making the attack hard to sustain\n                // for a prolonged period of time.\n                challenge.end = earliestEnd;\n            }\n            zchf.transferFrom(msg.sender, address(this), _bidAmountZCHF);\n            challenge.bid = _bidAmountZCHF;\n            challenge.bidder = msg.sender;\n        }\n    }\n\n    error TooLate();\n    error UnexpectedSize();\n    error BidTooLow(uint256 bid, uint256 min);\n\n    function end(uint256 _challengeNumber) external {\n        end(_challengeNumber, false);\n    }\n\n    function isChallengeOpen(uint256 _challengeNumber) external view returns (bool) {\n        return challenges[_challengeNumber].end > block.timestamp;\n    }\n\n    /**\n     * Ends a challenge successfully after the auction period ended, whereas successfully means that the challenger\n     * could show that the price of the collateral is too low to make the position well-collateralized.\n     *\n     * In case that the collateral cannot be transfered back to the challenger (i.e. because the collateral token has a blacklist and the\n     * challenger is on it), it is possible to postpone the return of the collateral.\n     *\n     * @param postponeCollateralReturn Can be used to postpone the return of the collateral to the challenger. Usually false. \n     */\n    function end(uint256 _challengeNumber, bool postponeCollateralReturn) public {\n        Challenge storage challenge = challenges[_challengeNumber];\n        require(challenge.challenger != address(0x0));\n        require(block.timestamp >= challenge.end, \"period has not ended\");\n        // challenge must have been successful, because otherwise it would have immediately ended on placing the winning bid\n        returnCollateral(challenge, postponeCollateralReturn);\n        // notify the position that will send the collateral to the bidder. If there is no bid, send the collateral to msg.sender\n        address recipient = challenge.bidder == address(0x0) ? msg.sender : challenge.bidder;\n        (address owner, uint256 effectiveBid, uint256 volume, uint256 repayment, uint32 reservePPM) = challenge.position.notifyChallengeSucceeded(recipient, challenge.bid, challenge.size);\n        if (effectiveBid < challenge.bid) {\n            // overbid, return excess amount\n            IERC20(zchf).transfer(challenge.bidder, challenge.bid - effectiveBid);\n        }\n        uint256 reward = (volume * CHALLENGER_REWARD) / 1000_000;\n        uint256 fundsNeeded = reward + repayment;\n        if (effectiveBid > fundsNeeded){\n            zchf.transfer(owner, effectiveBid - fundsNeeded);\n        } else if (effectiveBid < fundsNeeded){\n            zchf.notifyLoss(fundsNeeded - effectiveBid); // ensure we have enough to pay everything\n        }\n        zchf.transfer(challenge.challenger, reward); // pay out the challenger reward\n        zchf.burn(repayment, reservePPM); // Repay the challenged part\n        emit ChallengeSucceeded(address(challenge.position), challenge.bid, _challengeNumber);\n        delete challenges[_challengeNumber];\n    }\n\n    /**\n     * Challengers can call this method to withdraw collateral whose return was postponed.\n     */\n    function returnPostponedCollateral(address collateral, address target) external {\n        uint256 amount = pendingReturns[collateral][msg.sender];\n        delete pendingReturns[collateral][msg.sender];\n        IERC20(collateral).transfer(target, amount);\n    }\n\n    function returnCollateral(Challenge storage challenge, bool postpone) internal {\n        if (postpone){\n            // Postponing helps in case the challenger was blacklisted on the collateral token or otherwise cannot receive it at the moment.\n            address collateral = address(challenge.position.collateral());\n            pendingReturns[collateral][challenge.challenger] += challenge.size;\n            emit PostPonedReturn(collateral, challenge.challenger, challenge.size);\n        } else {\n            challenge.position.collateral().transfer(challenge.challenger, challenge.size); // return the challenger's collateral\n        }\n    }\n}\n\ninterface IPositionFactory {\n    function createNewPosition(\n        address _owner,\n        address _zchf,\n        address _collateral,\n        uint256 _minCollateral,\n        uint256 _initialLimit,\n        uint256 _initPeriodSeconds,\n        uint256 _duration,\n        uint256 _challengePeriod,\n        uint32 _mintingFeePPM,\n        uint256 _liqPrice,\n        uint32 _reserve\n    ) external returns (address);\n\n    function clonePosition(address _existing) external returns (address);\n}"
    }
  ]
}