{
  "Title": "[M-11] StakingRewards reward rate can be dragged out and diluted",
  "Content": "\nSimilar to <https://github.com/code-423n4/2022-02-concur-findings/issues/183>.\n\n            if (block.timestamp >= periodFinish) {\n                rewardRate = reward.div(rewardsDuration);\n            } else {\n                uint256 remaining = periodFinish.sub(block.timestamp);\n                uint256 leftover = remaining.mul(rewardRate);\n                rewardRate = reward.add(leftover).div(rewardsDuration);\n            }\n\nThe StakingRewards.notifyRewardAmount function receives a reward amount and extends the current reward end time to now + rewardsDuration.\nIt rebases the currently remaining rewards + the new rewards (reward + leftover) over this new rewardsDuration period.\nThis can lead to a dilution of the reward rate and rewards being dragged out forever by malicious new reward deposits.\n\n### Proof of Concept\n\nImagine the current rewardRate is 1000 rewards / rewardsDuration.\n\n20% of the rewardsDuration passed, i.e., now = lastUpdateTime + 20% &ast; rewardsDuration.\n\nA malicious actor notifies the contract with a reward of 0: notifyRewardAmount(0).\n\nThen the new rewardRate = (reward + leftover) / rewardsDuration = (0 + 800) / rewardsDuration = 800 / rewardsDuration.\n\nThe rewardRate just dropped by 20%.\nThis can be repeated infinitely.\nAfter another 20% of reward time passed, they trigger notifyRewardAmount(0) to reduce it by another 20% again:\nrewardRate = (0 + 640) / rewardsDuration = 640 / rewardsDuration.\n\n<https://github.com/code-423n4/2022-09-y2k-finance/blob/ac3e86f07bc2f1f51148d2265cc897e8b494adf7/src/rewards/StakingRewards.sol#L183-L195>\n\n### Recommended Mitigation Steps\n\nThe rewardRate should never decrease by a notifyRewardAmount call.\nConsider not extending the reward payouts by rewardsDuration on every call.\nperiodFinish probably shouldn't change at all, the rewardRate should just increase by rewardRate += reward / (periodFinish - block.timestamp).\n\nAlternatively, consider keeping the rewardRate constant but extend periodFinish time by += reward / rewardRate.\n\n**[MiguelBits (Y2K Finance) disputed](https://github.com/code-423n4/2022-09-y2k-finance-findings/issues/52)** \n\n**[HickupHH3 (judge) commented](https://github.com/code-423n4/2022-09-y2k-finance-findings/issues/52#issuecomment-1295879950):**\n > Admin privilege issue that would allow the admin to dilute current rewards. Medium severity due to loss of yield for all depositors from dilution of `rewardRate`.\n> \n> \n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-09-y2k-finance-contest",
  "Code": [
    {
      "filename": "src/rewards/StakingRewards.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {SafeTransferLib} from \"@solmate/utils/SafeTransferLib.sol\";\nimport {\n    ReentrancyGuard\n} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n// Inheritance\nimport {IStakingRewards} from \"./IStakingRewards.sol\";\nimport {RewardsDistributionRecipient} from \"./RewardsDistributionRecipient.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport {\n    ERC1155Holder\n} from \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport {ERC20} from \"@solmate/tokens/ERC20.sol\";\nimport \"./Owned.sol\";\n\n// https://docs.synthetix.io/contracts/source/contracts/stakingrewards\ncontract StakingRewards is\n    IStakingRewards,\n    RewardsDistributionRecipient,\n    ReentrancyGuard,\n    Pausable,\n    ERC1155Holder\n{\n    using SafeMath for uint256;\n    using SafeTransferLib for ERC20;\n\n    /* ========== STATE VARIABLES ========== */\n\n    ERC20 public immutable rewardsToken;\n    IERC1155 public immutable stakingToken;\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate;\n    uint256 public rewardsDuration;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    uint256 public id;\n\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    /* ========== EVENTS ========== */\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 id, uint256 amount);\n    event Withdrawn(address indexed user, uint256 id, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n    event RewardsDurationUpdated(uint256 newDuration);\n    event Recovered(address token, uint256 amount);\n\n    /* ========== MODIFIERS ========== */\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(\n        address _owner,\n        address _rewardsDistribution,\n        address _rewardsToken,\n        address _stakingToken,\n        uint256 _epochEnd,\n        uint256 _rewardsDuration,\n        uint256 _rewardRate\n    ) Owned(_owner) {\n        rewardsToken = ERC20(_rewardsToken);\n        stakingToken = IERC1155(_stakingToken);\n        rewardsDistribution = _rewardsDistribution;\n        id = _epochEnd;\n        rewardsDuration = _rewardsDuration;\n        rewardRate = _rewardRate;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n    function stake(uint256 amount)\n        external\n        nonReentrant\n        whenNotPaused\n        updateReward(msg.sender)\n    {\n        require(amount != 0, \"Cannot stake 0\");\n        _totalSupply = _totalSupply.add(amount);\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\n        stakingToken.safeTransferFrom(\n            msg.sender,\n            address(this),\n            id,\n            amount,\n            \"\"\n        );\n        emit Staked(msg.sender, id, amount);\n    }\n\n    function exit() external {\n        withdraw(_balances[msg.sender]);\n        getReward();\n    }\n\n    function withdraw(uint256 amount)\n        public\n        nonReentrant\n        updateReward(msg.sender)\n    {\n        require(amount > 0, \"Cannot withdraw 0\");\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        stakingToken.safeTransferFrom(\n            address(this),\n            msg.sender,\n            id,\n            amount,\n            \"\"\n        );\n        emit Withdrawn(msg.sender, id, amount);\n    }\n\n    function getReward() public nonReentrant updateReward(msg.sender) {\n        uint256 reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            rewardsToken.safeTransfer(msg.sender, reward);\n            emit RewardPaid(msg.sender, reward);\n        }\n    }\n\n    /* ========== VIEWS ========== */\n\n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n\n    function getRewardForDuration() external view returns (uint256) {\n        return rewardRate.mul(rewardsDuration);\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return block.timestamp < periodFinish ? block.timestamp : periodFinish;\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (_totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable()\n                    .sub(lastUpdateTime)\n                    .mul(rewardRate)\n                    .mul(1e18)\n                    .div(_totalSupply)\n            );\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return\n            _balances[account]\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e18)\n                .add(rewards[account]);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function notifyRewardAmount(uint256 reward)\n        external\n        override\n        onlyRewardsDistribution\n        updateReward(address(0))\n    {\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(rewardsDuration);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            rewardRate = reward.add(leftover).div(rewardsDuration);\n        }\n\n        // Ensure the provided reward amount is not more than the balance in the contract.\n        // This keeps the reward rate in the right range, preventing overflows due to\n        // very high values of rewardRate in the earned and rewardsPerToken functions;\n        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\n        uint256 balance = rewardsToken.balanceOf(address(this));\n        require(\n            rewardRate <= balance.div(rewardsDuration),\n            \"Provided reward too high\"\n        );\n\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp.add(rewardsDuration);\n        emit RewardAdded(reward);\n    }\n\n    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders\n    function recoverERC20(address tokenAddress, uint256 tokenAmount)\n        external\n        onlyOwner\n    {\n        require(\n            tokenAddress != address(stakingToken),\n            \"Cannot withdraw the staking token\"\n        );\n        ERC20(tokenAddress).safeTransfer(owner, tokenAmount);\n        emit Recovered(tokenAddress, tokenAmount);\n    }\n\n    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {\n        require(\n            block.timestamp > periodFinish,\n            \"Previous rewards period must be complete before changing the duration for the new period\"\n        );\n        rewardsDuration = _rewardsDuration;\n        emit RewardsDurationUpdated(rewardsDuration);\n    }\n}"
    }
  ]
}