{
  "Title": "[M-13] Taiko SGX Attestation - Improper validation in certchain decoding",
  "Content": "\n<https://github.com/code-423n4/2024-03-taiko/blob/0d081a40e0b9637eddf8e760fabbecc250f23599/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L135> \n\n<https://github.com/code-423n4/2024-03-taiko/blob/0d081a40e0b9637eddf8e760fabbecc250f23599/packages/protocol/contracts/verifiers/SgxVerifier.sol#L115-L136>\n\nAs part of of its ZK proof setup, Taiko leverages SGX provers. it also enables remote SGX attestation and this is possible via leveraging code from Automata, which provides a modular attestation layer extending machine-level trust to Ethereum via the AutomataDcapV3Attestation repo, which is in scope of this audit.\n\nAnyone with SGX hardware can register their instance to be an SGX prover in the Taiko Network via calling the registerInstance function in SgxVerifier.sol. This is why attestation is critical to prove the reliability and trustworthiness of the SGX prover.\n\nThe attestation process of SGX provers is a multi fold process, and starts with calling the verifyParsedQuote function in AutomataDcapV3Attestation.sol. One of the steps involves decoding the certchain provided by the SGX prover, as seen below:\n\n            // Step 4: Parse Quote CertChain\n        IPEMCertChainLib.ECSha256Certificate[] memory parsedQuoteCerts;\n        TCBInfoStruct.TCBInfo memory fetchedTcbInfo;\n        {\n            // 536k gas\n            parsedQuoteCerts = new IPEMCertChainLib.ECSha256Certificate[](3);\n            for (uint256 i; i < 3; ++i) {\n                bool isPckCert = i == 0; // additional parsing for PCKCert\n                bool certDecodedSuccessfully;\n                // todo! move decodeCert offchain\n                (certDecodedSuccessfully, parsedQuoteCerts[i]) = pemCertLib.decodeCert(\n                    authDataV3.certification.decodedCertDataArray[i], isPckCert\n                );\n                if (!certDecodedSuccessfully) {\n                    return (false, retData);\n                }\n            }\n        }\n\nafter this step is executed, a number of other steps are done including:\n\nStep 5: basic PCK and TCB check\nStep 6: Verify TCB Level\nStep 7: Verify cert chain for PCK\nStep 8: Verify the local attestation sig and qe report sig\n\nThe decoding of the certchain happens through the EMCertChainLib lib, and this involves a number of steps, one of which is to validate the decoded notBefore and notAfter tags of the certificate:\n\n            {\n            uint256 notBeforePtr = der.firstChildOf(tbsPtr);\n            uint256 notAfterPtr = der.nextSiblingOf(notBeforePtr);\n            bytes1 notBeforeTag = der[notBeforePtr.ixs()];\n            bytes1 notAfterTag = der[notAfterPtr.ixs()];\n            if (\n                (notBeforeTag != 0x17 && notBeforeTag == 0x18)\n                    || (notAfterTag != 0x17 && notAfterTag != 0x18)\n            ) {\n                return (false, cert);\n            }\n            cert.notBefore = X509DateUtils.toTimestamp(der.bytesAt(notBeforePtr));\n            cert.notAfter = X509DateUtils.toTimestamp(der.bytesAt(notAfterPtr));\n        }\n\nThese fields determine the time format, whether the notBeforePtr and notAfterPtr are in UTC or generalized time, and are used to ensure consistency in timestamps used to determine the validity period of the certificate.\n\nHowever the validation can fail because the logic above is faulty, as it will allow the attestor to pass in any value for the notBefore tag, indeeed the condition of:\n\n    (notBeforeTag != 0x17 && notBeforeTag == 0x18)\n\nwill allow the attestor to pass in any beforetag because the condition will always be false.\n\nConsider if we pass an invalid tag of 0x10:\n\n1.  notBeforeTag != 0x17 is True.\n2.  notBeforeTag == 0x18 is False.\n3.  full condition is False.\n\nI believe the original intention was to ensure the beforeTag is strictly 0x17 or 0x18, just as with the afterTag. Because of this oversight, a malicious attestor could pass in any notBefore Tag as part of their certificate.\n\nThis issue requires attention given the significance of the attestation process of SGX provers within Taiko's ZK setup. The whole point of attestation is to prove the SGX provers are secure, untampered, and trustworthy, and improper validation related to certificate validity periods can have unforeseen consequences.\n\n### Recommended Mitigation Steps\n\nUpdate the condition as below:\n\n                if (\n                (notBeforeTag != 0x17 && notBeforeTag != 0x18)\n                    || (notAfterTag != 0x17 && notAfterTag != 0x18)\n            ) {\n                return (false, cert);\n\n\n**[smtmfft (Taiko) confirmed and commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/168#issuecomment-2033492460):**\n > I think this is a valid catch, already submitted a fix.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-03-taiko",
  "Code": [
    {
      "filename": "packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport { LibString } from \"solady/src/utils/LibString.sol\";\nimport { Asn1Decode, NodePtr } from \"../utils/Asn1Decode.sol\";\nimport { BytesUtils } from \"../utils/BytesUtils.sol\";\nimport { X509DateUtils } from \"../utils/X509DateUtils.sol\";\nimport { IPEMCertChainLib } from \"./interfaces/IPEMCertChainLib.sol\";\n\n/// @title PEMCertChainLib\n/// @custom:security-contact security@taiko.xyz\ncontract PEMCertChainLib is IPEMCertChainLib {\n    using Asn1Decode for bytes;\n    using NodePtr for uint256;\n    using BytesUtils for bytes;\n\n    string internal constant HEADER = \"-----BEGIN CERTIFICATE-----\";\n    string internal constant FOOTER = \"-----END CERTIFICATE-----\";\n    uint256 internal constant HEADER_LENGTH = 27;\n    uint256 internal constant FOOTER_LENGTH = 25;\n\n    string internal constant PCK_COMMON_NAME = \"Intel SGX PCK Certificate\";\n    string internal constant PLATFORM_ISSUER_NAME = \"Intel SGX PCK Platform CA\";\n    string internal constant PROCESSOR_ISSUER_NAME = \"Intel SGX PCK Processor CA\";\n    bytes internal constant SGX_EXTENSION_OID = hex\"2A864886F84D010D01\";\n    bytes internal constant TCB_OID = hex\"2A864886F84D010D0102\";\n    bytes internal constant PCESVN_OID = hex\"2A864886F84D010D010211\";\n    bytes internal constant PCEID_OID = hex\"2A864886F84D010D0103\";\n    bytes internal constant FMSPC_OID = hex\"2A864886F84D010D0104\";\n\n    // https://github.com/intel/SGXDataCenterAttestationPrimitives/blob/e7604e02331b3377f3766ed3653250e03af72d45/QuoteVerification/QVL/Src/AttestationLibrary/src/CertVerification/X509Constants.h#L64\n    uint256 constant SGX_TCB_CPUSVN_SIZE = 16;\n\n    struct PCKTCBFlags {\n        bool fmspcFound;\n        bool pceidFound;\n        bool tcbFound;\n    }\n\n    function splitCertificateChain(\n        bytes memory pemChain,\n        uint256 size\n    )\n        external\n        pure\n        returns (bool success, bytes[] memory certs)\n    {\n        certs = new bytes[](size);\n        string memory pemChainStr = string(pemChain);\n\n        uint256 index = 0;\n        uint256 len = pemChain.length;\n\n        for (uint256 i; i < size; ++i) {\n            string memory input;\n            if (i > 0) {\n                input = LibString.slice(pemChainStr, index, index + len);\n            } else {\n                input = pemChainStr;\n            }\n            uint256 increment;\n            (success, certs[i], increment) = _removeHeadersAndFooters(input);\n\n            if (!success) {\n                return (false, certs);\n            }\n\n            index += increment;\n        }\n\n        success = true;\n    }\n\n    function decodeCert(\n        bytes memory der,\n        bool isPckCert\n    )\n        external\n        pure\n        returns (bool success, ECSha256Certificate memory cert)\n    {\n        uint256 root = der.root();\n\n        // Entering tbsCertificate sequence\n        uint256 tbsParentPtr = der.firstChildOf(root);\n\n        // Begin iterating through the descendants of tbsCertificate\n        uint256 tbsPtr = der.firstChildOf(tbsParentPtr);\n\n        // The Serial Number is located one element below Version\n\n        // The issuer commonName value is contained in the Issuer sequence\n        // which is 3 elements below the first element of the tbsCertificate sequence\n\n        // The Validity sequence is located 4 elements below the first element of the tbsCertificate\n        // sequence\n\n        // The subject commanName value is contained in the Subject sequence\n        // which is 5 elements below the first element of the tbsCertificate sequence\n\n        // The PublicKey is located in the second element of subjectPublicKeyInfo sequence\n        // which is 6 elements below the first element of the tbsCertificate sequence\n\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n\n        {\n            bytes memory serialNumBytes = der.bytesAt(tbsPtr);\n            cert.serialNumber = serialNumBytes;\n        }\n\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n\n        if (isPckCert) {\n            uint256 issuerPtr = der.firstChildOf(tbsPtr);\n            issuerPtr = der.firstChildOf(issuerPtr);\n            issuerPtr = der.firstChildOf(issuerPtr);\n            issuerPtr = der.nextSiblingOf(issuerPtr);\n            cert.pck.issuerName = string(der.bytesAt(issuerPtr));\n            bool issuerNameIsValid = LibString.eq(cert.pck.issuerName, PLATFORM_ISSUER_NAME)\n                || LibString.eq(cert.pck.issuerName, PROCESSOR_ISSUER_NAME);\n            if (!issuerNameIsValid) {\n                return (false, cert);\n            }\n        }\n\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n\n        {\n            uint256 notBeforePtr = der.firstChildOf(tbsPtr);\n            uint256 notAfterPtr = der.nextSiblingOf(notBeforePtr);\n            bytes1 notBeforeTag = der[notBeforePtr.ixs()];\n            bytes1 notAfterTag = der[notAfterPtr.ixs()];\n            if (\n                (notBeforeTag != 0x17 && notBeforeTag == 0x18)\n                    || (notAfterTag != 0x17 && notAfterTag != 0x18)\n            ) {\n                return (false, cert);\n            }\n            cert.notBefore = X509DateUtils.toTimestamp(der.bytesAt(notBeforePtr));\n            cert.notAfter = X509DateUtils.toTimestamp(der.bytesAt(notAfterPtr));\n        }\n\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n\n        if (isPckCert) {\n            uint256 subjectPtr = der.firstChildOf(tbsPtr);\n            subjectPtr = der.firstChildOf(subjectPtr);\n            subjectPtr = der.firstChildOf(subjectPtr);\n            subjectPtr = der.nextSiblingOf(subjectPtr);\n            cert.pck.commonName = string(der.bytesAt(subjectPtr));\n            if (!LibString.eq(cert.pck.commonName, PCK_COMMON_NAME)) {\n                return (false, cert);\n            }\n        }\n\n        tbsPtr = der.nextSiblingOf(tbsPtr);\n\n        {\n            // Entering subjectPublicKeyInfo sequence\n            uint256 subjectPublicKeyInfoPtr = der.firstChildOf(tbsPtr);\n            subjectPublicKeyInfoPtr = der.nextSiblingOf(subjectPublicKeyInfoPtr);\n\n            // The Signature sequence is located two sibling elements below the tbsCertificate\n            // element\n            uint256 sigPtr = der.nextSiblingOf(tbsParentPtr);\n            sigPtr = der.nextSiblingOf(sigPtr);\n\n            // Skip three bytes to the right\n            // the three bytes in question: 0x034700 or 0x034800 or 0x034900\n            sigPtr = NodePtr.getPtr(sigPtr.ixs() + 3, sigPtr.ixf() + 3, sigPtr.ixl());\n\n            sigPtr = der.firstChildOf(sigPtr);\n            bytes memory sigX = _trimBytes(der.bytesAt(sigPtr), 32);\n\n            sigPtr = der.nextSiblingOf(sigPtr);\n            bytes memory sigY = _trimBytes(der.bytesAt(sigPtr), 32);\n\n            cert.tbsCertificate = der.allBytesAt(tbsParentPtr);\n            cert.pubKey = _trimBytes(der.bytesAt(subjectPublicKeyInfoPtr), 64);\n            cert.signature = abi.encodePacked(sigX, sigY);\n        }\n\n        if (isPckCert) {\n            // entering Extension sequence\n            tbsPtr = der.nextSiblingOf(tbsPtr);\n\n            // check for the extension tag\n            if (der[tbsPtr.ixs()] != 0xA3) {\n                return (false, cert);\n            }\n\n            tbsPtr = der.firstChildOf(tbsPtr);\n            tbsPtr = der.firstChildOf(tbsPtr);\n\n            bool sgxExtnTraversedSuccessfully;\n            uint256 pcesvn;\n            uint256[] memory cpuSvns;\n            bytes memory fmspcBytes;\n            bytes memory pceidBytes;\n            (sgxExtnTraversedSuccessfully, pcesvn, cpuSvns, fmspcBytes, pceidBytes) =\n                _findPckTcbInfo(der, tbsPtr, tbsParentPtr);\n            if (!sgxExtnTraversedSuccessfully) {\n                return (false, cert);\n            }\n            cert.pck.sgxExtension.pcesvn = pcesvn;\n            cert.pck.sgxExtension.sgxTcbCompSvnArr = cpuSvns;\n            cert.pck.sgxExtension.pceid = LibString.toHexStringNoPrefix(pceidBytes);\n            cert.pck.sgxExtension.fmspc = LibString.toHexStringNoPrefix(fmspcBytes);\n            cert.isPck = true;\n        }\n\n        success = true;\n    }\n\n    function _removeHeadersAndFooters(string memory pemData)\n        private\n        pure\n        returns (bool success, bytes memory extracted, uint256 endIndex)\n    {\n        // Check if the input contains the \"BEGIN\" and \"END\" headers\n        uint256 beginPos = LibString.indexOf(pemData, HEADER);\n        uint256 endPos = LibString.indexOf(pemData, FOOTER);\n\n        bool headerFound = beginPos != LibString.NOT_FOUND;\n        bool footerFound = endPos != LibString.NOT_FOUND;\n\n        if (!headerFound || !footerFound) {\n            return (false, extracted, endIndex);\n        }\n\n        // Extract the content between the headers\n        uint256 contentStart = beginPos + HEADER_LENGTH;\n\n        // Extract and return the content\n        bytes memory contentBytes;\n\n        // do not include newline\n        bytes memory delimiter = hex\"0a\";\n        string memory contentSlice = LibString.slice(pemData, contentStart, endPos);\n        string[] memory split = LibString.split(contentSlice, string(delimiter));\n        string memory contentStr;\n\n        for (uint256 i; i < split.length; ++i) {\n            contentStr = LibString.concat(contentStr, split[i]);\n        }\n\n        contentBytes = bytes(contentStr);\n        return (true, contentBytes, endPos + FOOTER_LENGTH);\n    }\n\n    function _trimBytes(\n        bytes memory input,\n        uint256 expectedLength\n    )\n        private\n        pure\n        returns (bytes memory output)\n    {\n        uint256 n = input.length;\n\n        if (n <= expectedLength) {\n            return input;\n        }\n        uint256 lengthDiff = n - expectedLength;\n        output = input.substring(lengthDiff, expectedLength);\n    }\n\n    function _findPckTcbInfo(\n        bytes memory der,\n        uint256 tbsPtr,\n        uint256 tbsParentPtr\n    )\n        private\n        pure\n        returns (\n            bool success,\n            uint256 pcesvn,\n            uint256[] memory cpusvns,\n            bytes memory fmspcBytes,\n            bytes memory pceidBytes\n        )\n    {\n        // iterate through the elements in the Extension sequence\n        // until we locate the SGX Extension OID\n        while (tbsPtr != 0) {\n            uint256 internalPtr = der.firstChildOf(tbsPtr);\n            if (der[internalPtr.ixs()] != 0x06) {\n                return (false, pcesvn, cpusvns, fmspcBytes, pceidBytes);\n            }\n\n            if (BytesUtils.compareBytes(der.bytesAt(internalPtr), SGX_EXTENSION_OID)) {\n                // 1.2.840.113741.1.13.1\n                internalPtr = der.nextSiblingOf(internalPtr);\n                uint256 extnValueParentPtr = der.rootOfOctetStringAt(internalPtr);\n                uint256 extnValuePtr = der.firstChildOf(extnValueParentPtr);\n\n                // Copy flags to memory to avoid stack too deep\n                PCKTCBFlags memory flags;\n\n                while (!(flags.fmspcFound && flags.pceidFound && flags.tcbFound)) {\n                    uint256 extnValueOidPtr = der.firstChildOf(extnValuePtr);\n                    if (der[extnValueOidPtr.ixs()] != 0x06) {\n                        return (false, pcesvn, cpusvns, fmspcBytes, pceidBytes);\n                    }\n                    if (BytesUtils.compareBytes(der.bytesAt(extnValueOidPtr), TCB_OID)) {\n                        // 1.2.840.113741.1.13.1.2\n                        (flags.tcbFound, pcesvn, cpusvns) = _findTcb(der, extnValueOidPtr);\n                    }\n                    if (BytesUtils.compareBytes(der.bytesAt(extnValueOidPtr), PCEID_OID)) {\n                        // 1.2.840.113741.1.13.1.3\n                        uint256 pceidPtr = der.nextSiblingOf(extnValueOidPtr);\n                        pceidBytes = der.bytesAt(pceidPtr);\n                        flags.pceidFound = true;\n                    }\n                    if (BytesUtils.compareBytes(der.bytesAt(extnValueOidPtr), FMSPC_OID)) {\n                        // 1.2.840.113741.1.13.1.4\n                        uint256 fmspcPtr = der.nextSiblingOf(extnValueOidPtr);\n                        fmspcBytes = der.bytesAt(fmspcPtr);\n                        flags.fmspcFound = true;\n                    }\n\n                    if (extnValuePtr.ixl() < extnValueParentPtr.ixl()) {\n                        extnValuePtr = der.nextSiblingOf(extnValuePtr);\n                    } else {\n                        break;\n                    }\n                }\n                success = flags.fmspcFound && flags.pceidFound && flags.tcbFound;\n                break;\n            }\n\n            if (tbsPtr.ixl() < tbsParentPtr.ixl()) {\n                tbsPtr = der.nextSiblingOf(tbsPtr);\n            } else {\n                tbsPtr = 0; // exit\n            }\n        }\n    }\n\n    function _findTcb(\n        bytes memory der,\n        uint256 oidPtr\n    )\n        private\n        pure\n        returns (bool success, uint256 pcesvn, uint256[] memory cpusvns)\n    {\n        // sibiling of tcbOid\n        uint256 tcbPtr = der.nextSiblingOf(oidPtr);\n        // get the first svn object in the sequence\n        uint256 svnParentPtr = der.firstChildOf(tcbPtr);\n        cpusvns = new uint256[](SGX_TCB_CPUSVN_SIZE);\n        for (uint256 i; i < SGX_TCB_CPUSVN_SIZE + 1; ++i) {\n            uint256 svnPtr = der.firstChildOf(svnParentPtr); // OID\n            uint256 svnValuePtr = der.nextSiblingOf(svnPtr); // value\n            bytes memory svnValueBytes = der.bytesAt(svnValuePtr);\n            uint16 svnValue = svnValueBytes.length < 2\n                ? uint16(bytes2(svnValueBytes)) / 256\n                : uint16(bytes2(svnValueBytes));\n            if (BytesUtils.compareBytes(der.bytesAt(svnPtr), PCESVN_OID)) {\n                // pcesvn is 4 bytes in size\n                pcesvn = uint256(svnValue);\n            } else {\n                // each cpusvn is at maximum two bytes in size\n                uint256 cpusvn = uint256(svnValue);\n                cpusvns[i] = cpusvn;\n            }\n\n            // iterate to the next svn object in the sequence\n            svnParentPtr = der.nextSiblingOf(svnParentPtr);\n        }\n        success = true;\n    }\n}"
    },
    {
      "filename": "packages/protocol/contracts/verifiers/SgxVerifier.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"../L1/ITaikoL1.sol\";\nimport \"../common/EssentialContract.sol\";\nimport \"../thirdparty/optimism/Bytes.sol\";\nimport \"../automata-attestation/interfaces/IAttestation.sol\";\nimport \"../automata-attestation/lib/QuoteV3Auth/V3Struct.sol\";\nimport \"./IVerifier.sol\";\n\n/// @title SgxVerifier\n/// @notice This contract is the implementation of verifying SGX signature proofs\n/// onchain.\n/// @dev Please see references below:\n/// - Reference #1: https://ethresear.ch/t/2fa-zk-rollups-using-sgx/14462\n/// - Reference #2: https://github.com/gramineproject/gramine/discussions/1579\n/// @custom:security-contact security@taiko.xyz\ncontract SgxVerifier is EssentialContract, IVerifier {\n    /// @dev Each public-private key pair (Ethereum address) is generated within\n    /// the SGX program when it boots up. The off-chain remote attestation\n    /// ensures the validity of the program hash and has the capability of\n    /// bootstrapping the network with trustworthy instances.\n    struct Instance {\n        address addr;\n        uint64 validSince;\n    }\n\n    /// @notice The expiry time for the SGX instance.\n    uint64 public constant INSTANCE_EXPIRY = 180 days;\n\n    /// @notice A security feature, a delay until an instance is enabled when using onchain RA\n    /// verification\n    uint64 public constant INSTANCE_VALIDITY_DELAY = 1 days;\n\n    /// @dev For gas savings, we shall assign each SGX instance with an id that when we need to\n    /// set a new pub key, just write storage once.\n    /// Slot 1.\n    uint256 public nextInstanceId;\n\n    /// @dev One SGX instance is uniquely identified (on-chain) by it's ECDSA public key\n    /// (or rather ethereum address). Once that address is used (by proof verification) it has to be\n    /// overwritten by a new one (representing the same instance). This is due to side-channel\n    /// protection. Also this public key shall expire after some time\n    /// (for now it is a long enough 6 months setting).\n    /// Slot 2.\n    mapping(uint256 instanceId => Instance instance) public instances;\n\n    /// @dev One address shall be registered (during attestation) only once, otherwise it could\n    /// bypass this contract's expiry check by always registering with the same attestation and\n    /// getting multiple valid instanceIds. While during proving, it is technically possible to\n    /// register the old addresses, it is less of a problem, because the instanceId would be the\n    /// same for those addresses and if deleted - the attestation cannot be reused anyways.\n    /// Slot 3.\n    mapping(address instanceAddress => bool alreadyAttested) public addressRegistered;\n\n    uint256[47] private __gap;\n\n    /// @notice Emitted when a new SGX instance is added to the registry, or replaced.\n    /// @param id The ID of the SGX instance.\n    /// @param instance The address of the SGX instance.\n    /// @param replaced The address of the SGX instance that was replaced. If it is the first\n    /// instance, this value is zero address.\n    /// @param validSince The time since the instance is valid.\n    event InstanceAdded(\n        uint256 indexed id, address indexed instance, address replaced, uint256 validSince\n    );\n\n    /// @notice Emitted when an SGX instance is deleted from the registry.\n    /// @param id The ID of the SGX instance.\n    /// @param instance The address of the SGX instance.\n    event InstanceDeleted(uint256 indexed id, address indexed instance);\n\n    error SGX_ALREADY_ATTESTED();\n    error SGX_INVALID_ATTESTATION();\n    error SGX_INVALID_INSTANCE();\n    error SGX_INVALID_PROOF();\n    error SGX_RA_NOT_SUPPORTED();\n\n    /// @notice Initializes the contract.\n    /// @param _owner The owner of this contract. msg.sender will be used if this value is zero.\n    /// @param _addressManager The address of the {AddressManager} contract.\n    function init(address _owner, address _addressManager) external initializer {\n        __Essential_init(_owner, _addressManager);\n    }\n\n    /// @notice Adds trusted SGX instances to the registry.\n    /// @param _instances The address array of trusted SGX instances.\n    /// @return The respective instanceId array per addresses.\n    function addInstances(address[] calldata _instances)\n        external\n        onlyOwner\n        returns (uint256[] memory)\n    {\n        return _addInstances(_instances, true);\n    }\n\n    /// @notice Deletes SGX instances from the registry.\n    /// @param _ids The ids array of SGX instances.\n    function deleteInstances(uint256[] calldata _ids)\n        external\n        onlyFromOwnerOrNamed(\"rollup_watchdog\")\n    {\n        for (uint256 i; i < _ids.length; ++i) {\n            uint256 idx = _ids[i];\n\n            if (instances[idx].addr == address(0)) revert SGX_INVALID_INSTANCE();\n\n            emit InstanceDeleted(idx, instances[idx].addr);\n\n            delete instances[idx];\n        }\n    }\n\n    /// @notice Adds an SGX instance after the attestation is verified\n    /// @param _attestation The parsed attestation quote.\n    /// @return The respective instanceId\n    function registerInstance(V3Struct.ParsedV3QuoteStruct calldata _attestation)\n        external\n        returns (uint256)\n    {\n        address automataDcapAttestation = (resolve(\"automata_dcap_attestation\", true));\n\n        if (automataDcapAttestation == address(0)) {\n            revert SGX_RA_NOT_SUPPORTED();\n        }\n\n        (bool verified,) = IAttestation(automataDcapAttestation).verifyParsedQuote(_attestation);\n\n        if (!verified) revert SGX_INVALID_ATTESTATION();\n\n        address[] memory _address = new address[](1);\n        _address[0] = address(bytes20(_attestation.localEnclaveReport.reportData));\n\n        return _addInstances(_address, false)[0];\n    }\n\n    /// @inheritdoc IVerifier\n    function verifyProof(\n        Context calldata _ctx,\n        TaikoData.Transition calldata _tran,\n        TaikoData.TierProof calldata _proof\n    )\n        external\n        onlyFromNamed(\"taiko\")\n    {\n        // Do not run proof verification to contest an existing proof\n        if (_ctx.isContesting) return;\n\n        // Size is: 89 bytes\n        // 4 bytes + 20 bytes + 65 bytes (signature) = 89\n        if (_proof.data.length != 89) revert SGX_INVALID_PROOF();\n\n        uint32 id = uint32(bytes4(Bytes.slice(_proof.data, 0, 4)));\n        address newInstance = address(bytes20(Bytes.slice(_proof.data, 4, 20)));\n        bytes memory signature = Bytes.slice(_proof.data, 24);\n\n        address oldInstance =\n            ECDSA.recover(getSignedHash(_tran, newInstance, _ctx.prover, _ctx.metaHash), signature);\n\n        if (!_isInstanceValid(id, oldInstance)) revert SGX_INVALID_INSTANCE();\n        _replaceInstance(id, oldInstance, newInstance);\n    }\n\n    /// @notice Gets the signed hash for the proof verification.\n    /// @param _tran The transition to verify.\n    /// @param _newInstance The new instance address.\n    /// @param _prover The prover address.\n    /// @param _metaHash The meta hash.\n    /// @return The signed hash.\n    function getSignedHash(\n        TaikoData.Transition memory _tran,\n        address _newInstance,\n        address _prover,\n        bytes32 _metaHash\n    )\n        public\n        view\n        returns (bytes32)\n    {\n        address taikoL1 = resolve(\"taiko\", false);\n        return keccak256(\n            abi.encode(\n                \"VERIFY_PROOF\",\n                ITaikoL1(taikoL1).getConfig().chainId,\n                address(this),\n                _tran,\n                _newInstance,\n                _prover,\n                _metaHash\n            )\n        );\n    }\n\n    function _addInstances(\n        address[] memory _instances,\n        bool instantValid\n    )\n        private\n        returns (uint256[] memory ids)\n    {\n        ids = new uint256[](_instances.length);\n\n        uint64 validSince = uint64(block.timestamp);\n\n        if (!instantValid) {\n            validSince += INSTANCE_VALIDITY_DELAY;\n        }\n\n        for (uint256 i; i < _instances.length; ++i) {\n            if (addressRegistered[_instances[i]]) revert SGX_ALREADY_ATTESTED();\n\n            addressRegistered[_instances[i]] = true;\n\n            if (_instances[i] == address(0)) revert SGX_INVALID_INSTANCE();\n\n            instances[nextInstanceId] = Instance(_instances[i], validSince);\n            ids[i] = nextInstanceId;\n\n            emit InstanceAdded(nextInstanceId, _instances[i], address(0), validSince);\n\n            nextInstanceId++;\n        }\n    }\n\n    function _replaceInstance(uint256 id, address oldInstance, address newInstance) private {\n        // Replacing an instance means, it went through a cooldown (if added by on-chain RA) so no\n        // need to have a cooldown\n        instances[id] = Instance(newInstance, uint64(block.timestamp));\n        emit InstanceAdded(id, newInstance, oldInstance, block.timestamp);\n    }\n\n    function _isInstanceValid(uint256 id, address instance) private view returns (bool) {\n        if (instance == address(0)) return false;\n        if (instance != instances[id].addr) return false;\n        return instances[id].validSince <= block.timestamp\n            && block.timestamp <= instances[id].validSince + INSTANCE_EXPIRY;\n    }\n}"
    }
  ]
}