{
  "Title": "[G-08] Reorder structure layout",
  "Content": "\nThe following structs could be optimized moving the position of certains values in order to save slot storages:\n\n`StoredBlockInfo` in [IExecutor.sol#L15-L24](https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/ethereum/contracts/zksync/interfaces/IExecutor.sol#L15-L24)\n\n```diff\n    struct StoredBlockInfo {\n        uint64 blockNumber;\n+       uint64 indexRepeatedStorageChanges;\n        bytes32 blockHash;\n-       uint64 indexRepeatedStorageChanges;\n        uint256 numberOfLayer1Txs;\n        bytes32 priorityOperationsHash;\n        bytes32 l2LogsTreeRoot;\n        uint256 timestamp;\n        bytes32 commitment;\n    }\n```\n\n`AppStorage` in [Storage.sol:69-106](https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/ethereum/contracts/zksync/Storage.sol#L69-L106)\n\n```diff\nstruct AppStorage {\n    /// @dev Storage of variables needed for diamond cut facet\n    DiamondCutStorage diamondCutStorage;\n    /// @notice Address which will exercise governance over the network i.e. change validator set, conduct upgrades\n    address governor;\n+   bool zkPorterIsAvailable;\n    /// @notice Address that governor proposed as one that will replace it\n    address pendingGovernor;\n    /// @notice List of permitted validators\n    mapping(address => bool) validators;\n    /// @dev Verifier contract. Used to verify aggregated proof for blocks\n    Verifier verifier;\n    /// @notice Total number of executed blocks i.e. blocks[totalBlocksExecuted] points at the latest executed block (block 0 is genesis)\n    uint256 totalBlocksExecuted;\n    /// @notice Total number of proved blocks i.e. blocks[totalBlocksProved] points at the latest proved block\n    uint256 totalBlocksVerified;\n    /// @notice Total number of committed blocks i.e. blocks[totalBlocksCommitted] points at the latest committed block\n    uint256 totalBlocksCommitted;\n    /// @dev Stored hashed StoredBlock for block number\n    mapping(uint256 => bytes32) storedBlockHashes;\n    /// @dev Stored root hashes of L2 -> L1 logs\n    mapping(uint256 => bytes32) l2LogsRootHashes;\n    /// @dev Container that stores transactions requested from L1\n    PriorityQueue.Queue priorityQueue;\n    /// @dev The smart contract that manages the list with permission to call contract functions\n    IAllowList allowList;\n    /// @notice Part of the configuration parameters of ZKP circuits. Used as an input for the verifier smart contract\n    VerifierParams verifierParams;\n    /// @notice Bytecode hash of bootloader program.\n    /// @dev Used as an input to zkp-circuit.\n    bytes32 l2BootloaderBytecodeHash;\n    /// @notice Bytecode hash of default account (bytecode for EOA).\n    /// @dev Used as an input to zkp-circuit.\n    bytes32 l2DefaultAccountBytecodeHash;\n    /// @dev Indicates that the porter may be touched on L2 transactions.\n    /// @dev Used as an input to zkp-circuit.\n-   bool zkPorterIsAvailable;\n}\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-10-zksync-v2-contest",
  "Code": [
    {
      "filename": "ethereum/contracts/zksync/interfaces/IExecutor.sol",
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8;\n\ninterface IExecutor {\n    /// @notice Rollup block stored data\n    /// @param blockNumber Rollup block number\n    /// @param blockHash Hash of L2 block\n    /// @param indexRepeatedStorageChanges The serial number of the shortcut index that's used as a unique identifier for storage keys that were used twice or more\n    /// @param numberOfLayer1Txs Number of priority operations to be processed\n    /// @param priorityOperationsHash Hash of all priority operations from this block\n    /// @param l2LogsTreeRoot Root hash of tree that contains L2 -> L1 messages from this block\n    /// @param timestamp Rollup block timestamp, have the same format as Ethereum block constant\n    /// @param commitment Verified input for the zkSync circuit\n    struct StoredBlockInfo {\n        uint64 blockNumber;\n        bytes32 blockHash;\n        uint64 indexRepeatedStorageChanges;\n        uint256 numberOfLayer1Txs;\n        bytes32 priorityOperationsHash;\n        bytes32 l2LogsTreeRoot;\n        uint256 timestamp;\n        bytes32 commitment;\n    }\n\n    /// @notice Data needed to commit new block\n    /// @param blockNumber Number of the committed block\n    /// @param timestamp Unix timestamp denoting the start of the block execution\n    /// @param indexRepeatedStorageChanges The serial number of the shortcut index that's used as a unique identifier for storage keys that were used twice or more\n    /// @param newStateRoot The state root of the full state tree\n    /// @param ergsPerPubdataByteInBlock Price in ergs per one byte of published pubdata in block\n    /// @param numberOfLayer1Txs Number of priority operations to be processed\n    /// @param l2LogsTreeRoot The root hash of the tree that contains all L2 -> L1 logs in the block\n    /// @param priorityOperationsHash Hash of all priority operations from this block\n    /// @param initialStorageChanges Storage write access as a concatenation key-value\n    /// @param repeatedStorageChanges Storage write access as a concatenation index-value\n    /// @param l2Logs concatenation of all L2 -> L1 logs in the block\n    /// @param l2ArbitraryLengthMessages array of hash preimages that were sent as value of L2 logs by special system L2 contract\n    /// @param factoryDeps array of l2 bytecodes that were marked as known on L2\n    struct CommitBlockInfo {\n        uint64 blockNumber;\n        uint64 timestamp;\n        uint64 indexRepeatedStorageChanges;\n        bytes32 newStateRoot;\n        uint256 numberOfLayer1Txs;\n        bytes32 l2LogsTreeRoot;\n        bytes32 priorityOperationsHash;\n        bytes initialStorageChanges;\n        bytes repeatedStorageChanges;\n        bytes l2Logs;\n        bytes[] l2ArbitraryLengthMessages;\n        bytes[] factoryDeps;\n    }\n\n    /// @notice Recursive proof input data (individual commitments are constructed onchain)\n    /// TODO: The verifier integration is not finished yet, change the structure for compatibility later\n    struct ProofInput {\n        uint256[] recurisiveAggregationInput;\n        uint256[] serializedProof;\n    }\n\n    function commitBlocks(StoredBlockInfo calldata _lastCommittedBlockData, CommitBlockInfo[] calldata _newBlocksData)\n        external;\n\n    function proveBlocks(\n        StoredBlockInfo calldata _prevBlock,\n        StoredBlockInfo[] calldata _committedBlocks,\n        ProofInput calldata _proof\n    ) external;\n\n    function executeBlocks(StoredBlockInfo[] calldata _blocksData) external;\n\n    function revertBlocks(uint256 _newLastBlock) external;\n\n    /// @notice Event emitted when a block is committed\n    event BlockCommit(uint256 indexed blockNumber, bytes32 indexed blockHash, bytes32 indexed commitment);\n\n    /// @notice Event emitted when blocks are verified\n    event BlocksVerification(uint256 indexed previousLastVerifiedBlock, uint256 indexed currentLastVerifiedBlock);\n\n    /// @notice Event emitted when a block is executed\n    event BlockExecution(uint256 indexed blockNumber, bytes32 indexed blockHash, bytes32 indexed commitment);\n\n    /// @notice Event emitted when blocks are reverted\n    event BlocksRevert(uint256 totalBlocksCommitted, uint256 totalBlocksVerified, uint256 totalBlocksExecuted);\n}"
    },
    {
      "filename": "ethereum/contracts/zksync/Storage.sol",
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport \"./Verifier.sol\";\nimport \"../common/interfaces/IAllowList.sol\";\nimport \"./libraries/PriorityQueue.sol\";\n\n/// @dev Logically separated part of the storage structure, which is responsible for everything related to proxy upgrades and diamond cuts\n/// @param proposedDiamondCutHash The hash of diamond cut that was proposed in the current upgrade\n/// @param proposedDiamondCutTimestamp The timestamp when the diamond cut was proposed, zero if there are no active proposals\n/// @param lastDiamondFreezeTimestamp The timestamp when the diamond was frozen last time, zero if the diamond was never frozen\n/// @param currentProposalId The serial number of proposed diamond cuts, increments when proposing a new diamond cut\n/// @param securityCouncilMembers The set of the trustedÂ addresses that can instantly finish upgrade (diamond cut)\n/// @param securityCouncilMemberLastApprovedProposalId The mapping of the security council addresses and the last diamond cut that they approved\n/// @param securityCouncilEmergencyApprovals The number of received upgrade approvals from the security council\nstruct DiamondCutStorage {\n    bytes32 proposedDiamondCutHash;\n    uint256 proposedDiamondCutTimestamp;\n    uint256 lastDiamondFreezeTimestamp;\n    uint256 currentProposalId;\n    mapping(address => bool) securityCouncilMembers;\n    mapping(address => uint256) securityCouncilMemberLastApprovedProposalId;\n    uint256 securityCouncilEmergencyApprovals;\n}\n\n/// @dev The log passed from L2\n/// @param l2ShardId The shard identifier, 0 - rollup, 1 - porter. All other values are not used but are reserved for the future\n/// @param isService A boolean flag that is part of the log along with `key`, `value`, and `sender` address.\n/// This field is required formally but does not have any special meaning.\n/// @param txNumberInBlock The L2 transaction number in a block, in which the log was sent\n/// @param sender The L2 address which sent the log. \n/// @param key The 32 bytes of information that was sent in the log\n/// @param value The 32 bytes of information that was sent in the log\n// Both `key` and `value` are arbitrary 32-bytes selected by the log sender\n/// @dev The sender is an `address` type, although we are using `uint256` for addreses in `L2CanonicalTransaction`.\n/// It is made on purpose to make circuits easier, but changing the format of L2 -> L1 log format would be a non-breaking \n/// change for users and devs so it is fine.\nstruct L2Log {\n    uint8 l2ShardId;\n    bool isService;\n    uint16 txNumberInBlock;\n    address sender;\n    bytes32 key;\n    bytes32 value;\n}\n\n/// @dev An arbitrary length message passed from L2\n/// @notice Under the hood it is `L2Log` sent from the special system L2 contract\n/// @param txNumberInBlock The L2 transaction number in a block, in which the message was sent\n/// @param sender The address of the L2 account from which the message was passed\n/// @param data An arbitrary length message\nstruct L2Message {\n    uint16 txNumberInBlock;\n    address sender;\n    bytes data;\n}\n\n/// @notice Part of the configuration parameters of ZKP circuits\nstruct VerifierParams {\n    bytes32 recursionNodeLevelVkHash;\n    bytes32 recursionLeafLevelVkHash;\n    bytes32 recursionCircuitsSetVksHash;\n}\n\n/// @dev storing all storage variables for zkSync facets\n/// NOTE: It is used in a proxy, so it is possible to add new variables to the end\n/// NOTE: but NOT to modify already existing variables or change their order\nstruct AppStorage {\n    /// @dev Storage of variables needed for diamond cut facet\n    DiamondCutStorage diamondCutStorage;\n    /// @notice Address which will exercise governance over the network i.e. change validator set, conduct upgrades\n    address governor;\n    /// @notice Address that governor proposed as one that will replace it\n    address pendingGovernor;\n    /// @notice List of permitted validators\n    mapping(address => bool) validators;\n    /// @dev Verifier contract. Used to verify aggregated proof for blocks\n    Verifier verifier;\n    /// @notice Total number of executed blocks i.e. blocks[totalBlocksExecuted] points at the latest executed block (block 0 is genesis)\n    uint256 totalBlocksExecuted;\n    /// @notice Total number of proved blocks i.e. blocks[totalBlocksProved] points at the latest proved block\n    uint256 totalBlocksVerified;\n    /// @notice Total number of committed blocks i.e. blocks[totalBlocksCommitted] points at the latest committed block\n    uint256 totalBlocksCommitted;\n    /// @dev Stored hashed StoredBlock for block number\n    mapping(uint256 => bytes32) storedBlockHashes;\n    /// @dev Stored root hashes of L2 -> L1 logs\n    mapping(uint256 => bytes32) l2LogsRootHashes;\n    /// @dev Container that stores transactions requested from L1\n    PriorityQueue.Queue priorityQueue;\n    /// @dev The smart contract that manages the list with permission to call contract functions\n    IAllowList allowList;\n    /// @notice Part of the configuration parameters of ZKP circuits. Used as an input for the verifier smart contract\n    VerifierParams verifierParams;\n    /// @notice Bytecode hash of bootloader program.\n    /// @dev Used as an input to zkp-circuit.\n    bytes32 l2BootloaderBytecodeHash;\n    /// @notice Bytecode hash of default account (bytecode for EOA).\n    /// @dev Used as an input to zkp-circuit.\n    bytes32 l2DefaultAccountBytecodeHash;\n    /// @dev Indicates that the porter may be touched on L2 transactions.\n    /// @dev Used as an input to zkp-circuit.\n    bool zkPorterIsAvailable;\n}"
    }
  ]
}