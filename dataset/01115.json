{
  "Title": "M-7: Wrong `accLoanRatePerSeconds` in `repay()` can lead to underflow",
  "Content": "# Issue M-7: Wrong `accLoanRatePerSeconds` in `repay()` can lead to underflow \n\nSource: https://github.com/sherlock-audit/2023-10-real-wagmi-judging/issues/119 \n\n## Found by \nHHK, handsomegiraffe\n\nWhen a Lender call the [`repay()`](https://github.com/sherlock-audit/2023-10-real-wagmi/blob/b33752757fd6a9f404b8577c1eae6c5774b3a0db/wagmi-leverage/contracts/LiquidityBorrowingManager.sol#L532) function of the LiquidityBorrowingManager contract to do an emergency liquidity restoration using `isEmergency = true`, the `borrowingStorage.accLoanRatePerSeconds` is updated if the borrowing position hasn't been fully closed.\n\nThe computation is made in sort that the missing collateral can be computed again later so we don't loose the missing fees in case someone take over or the borrower decide to reimburse the fees.\n\nBut this computation is wrong and can lead to underflow.\n\n## Vulnerability Detail\n\nBecause the [`repay()`](https://github.com/sherlock-audit/2023-10-real-wagmi/blob/b33752757fd6a9f404b8577c1eae6c5774b3a0db/wagmi-leverage/contracts/LiquidityBorrowingManager.sol#L532) function resets the `dailyRateCollateralBalance` to 0 when the lender call didn't fully close the position. We want to be able  to compute the missing collateral again.\n\nTo do so we substract the percentage of collateral not paid to the `accLoanRatePerSeconds` so on the next call we will be adding extra second of fees that will allow the contract to compute the missing collateral.\n\nThe problem lies in the fact that we compute a percentage using the borrowed amount left instead of the initial borrow amount causing the percentage to be higher. In practice this do allows the contract to recompute the missing collateral.\n\nBut in the case of the missing `collateralBalance` or `removedAmt` being very high (ex: multiple days not paid or the loan removed was most of the position's liquidity) we might end up with a percentage higher than the `accLoanRatePerSeconds` which will cause an underflow.\n\nIn case of an underflow the call will revert and the lender will not be able to get his tokens back.\n\nConsider this POC that can be copied and pasted in the test files (replace all tests and just keep the setup & NFT creation):\n\n```js\nit(\"Updated accRate is incorrect\", async () => {\n        const amountWBTC = ethers.utils.parseUnits(\"0.05\", 8); //token0\n        let deadline = (await time.latest()) + 60;\n        const minLeverageDesired = 50;\n        const maxCollateralWBTC = amountWBTC.div(minLeverageDesired);\n\n        const loans = [\n            {\n                liquidity: nftpos[3].liquidity,\n                tokenId: nftpos[3].tokenId,\n            },\n            {\n                liquidity: nftpos[5].liquidity,\n                tokenId: nftpos[5].tokenId,\n            },\n        ];\n\n        const swapParams: ApproveSwapAndPay.SwapParamsStruct = {\n            swapTarget: constants.AddressZero,\n            swapAmountInDataIndex: 0,\n            maxGasForCall: 0,\n            swapData: swapData,\n        };\n\n        const borrowParams = {\n            internalSwapPoolfee: 500,\n            saleToken: WETH_ADDRESS,\n            holdToken: WBTC_ADDRESS,\n            minHoldTokenOut: amountWBTC,\n            maxCollateral: maxCollateralWBTC,\n            externalSwap: swapParams,\n            loans: loans,\n        };\n\n        //borrow tokens\n        await borrowingManager.connect(bob).borrow(borrowParams, deadline);\n\n        await time.increase(3600 * 72); //72h so 2 days of missing collateral\n        deadline = (await time.latest()) + 60;\n\n        const borrowingKey = await borrowingManager.userBorrowingKeys(bob.address, 0);\n\n        let repayParams = {\n            isEmergency: true,\n            internalSwapPoolfee: 0,\n            externalSwap: swapParams,\n            borrowingKey: borrowingKey,\n            swapSlippageBP1000: 0,\n        };\n\n        const oldBorrowingInfo = await borrowingManager.borrowingsInfo(borrowingKey);\n        const dailyRateCollateral = await borrowingManager.checkDailyRateCollateral(borrowingKey);\n\n        //Alice emergency repay but it reverts with 2 days of collateral missing\n        await expect(borrowingManager.connect(alice).repay(repayParams, deadline)).to.be.revertedWithPanic();\n    });\n```\n\n## Impact\n\nMedium. Lender might not be able to use `isEmergency` on `repay()` and will have to do a normal liquidation if he want his liquidity back.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-10-real-wagmi/blob/b33752757fd6a9f404b8577c1eae6c5774b3a0db/wagmi-leverage/contracts/LiquidityBorrowingManager.sol#L532\nhttps://github.com/sherlock-audit/2023-10-real-wagmi/blob/b33752757fd6a9f404b8577c1eae6c5774b3a0db/wagmi-leverage/contracts/LiquidityBorrowingManager.sol#L613\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider that when a lender do an emergency liquidity restoration they give up on their collateral missing and so use the initial amount in the computation instead of borrowed amount left.\n\n```solidity\nborrowingStorage.accLoanRatePerSeconds =\n                    holdTokenRateInfo.accLoanRatePerSeconds -\n                    FullMath.mulDiv(\n                        uint256(-collateralBalance),\n                        Constants.BP,\n                        borrowing.borrowedAmount + removedAmt //old amount\n                    );\n```\n\n\n\n## Discussion\n\n**fann95**\n\nI think you are wrong in your conclusions. Try playing with emergency close tests.\nhttps://github.com/sherlock-audit/2023-10-real-wagmi/blob/b33752757fd6a9f404b8577c1eae6c5774b3a0db/wagmi-leverage/test/WagmiLeverageTests.ts#L990\n\nThe calculation must be made with the new borrowing.borrowedAmount, since in the future it will be used in the next calculation. The commission debt should be maintained and increase over time, and in your case, it is decreasing.\n\n\n**fann95**\n\nthis is your option\n![Screenshot from 2023-10-30 11-38-00](https://github.com/sherlock-audit/2023-10-real-wagmi-judging/assets/4136026/6d0e6c95-b698-4cfa-8766-367d7be1335c)\n\nand this is my option\n![Screenshot from 2023-10-30 11-38-15](https://github.com/sherlock-audit/2023-10-real-wagmi-judging/assets/4136026/939415dc-a3c8-4435-a740-7e0cc8ffa777)\n\nIn your version, the fee debt is reduced, although no one is paying it off.\n\n**HHK-ETH**\n\nEscalate\n\nWhile using the new `borrowing.borrowedAmount` make sense to keep the missing collateral balance it will lead to underflow if the `holdTokenRateInfo.accLoanRatePerSeconds` is too low (ex: the first user to borrow so `accLoanRatePerSeconds` started at the same time).\n\nTo find the missing collateral balance with a smaller borrowed amount, the only solution is to increase the percentage. But like I said, if you increase the percentage you might end up underflowing as the `accLoanRatePerSeconds` could be smaller.\n\nHere is a simple example:\n- You have 10 tokens of collateral missing and 200 tokens total and we remove 50 tokens. The rate is 1% daily.\n- 10 / 200 * 100 = 5% is the percentage value of the missing collateral compared to the amount borrowed. \n- Since we were the first to borrow `accLoanRatePerSeconds` is pretty close to the missing collateral percentage, minus 1 day (user deposits at least 1 day of collateral when borrowing). 200*1/100 = 2 so the `accLoanRatePerSeconds` is 10+2 / 200 * 100 = 6%.\n- In the contract what we do instead is 10 / (200-50) * 100 = 6.66%. We do this because we want to be able to find the missing collateral using a smaller balance during the next call as the state is updated.\n- The substraction underflow because 6.66% > 6%.\n\nI did play with the emergency close tests. Here I reused it and added comments:\n\n```js\nit(\"emergency repay will be successful for PosManNFT owner if the collateral is depleted\", async () => {\n        let debt: LiquidityBorrowingManager.BorrowingInfoExtStructOutput[] =\n            await borrowingManager.getBorrowerDebtsInfo(bob.address);\n\n        await time.increase(debt[1].estimatedLifeTime.toNumber() + 3600 * 36); //add 36 hours as an example\n\n        debt = await borrowingManager.getBorrowerDebtsInfo(bob.address); //update debt variable\n\n        let borrowingKey = await borrowingManager.userBorrowingKeys(bob.address, 1);\n\n        let swap_params = ethers.utils.defaultAbiCoder.encode(\n            [\"address\", \"address\", \"uint256\", \"uint256\"],\n            [constants.AddressZero, constants.AddressZero, 0, 0]\n        );\n        swapData = swapIface.encodeFunctionData(\"swap\", [swap_params]);\n\n        let swapParams: ApproveSwapAndPay.SwapParamsStruct = {\n            swapTarget: constants.AddressZero,\n            swapAmountInDataIndex: 0,\n            maxGasForCall: 0,\n            swapData: swapData,\n        };\n\n        let params: LiquidityBorrowingManager.RepayParamsStruct = {\n            isEmergency: true, //emergency\n            internalSwapPoolfee: 0,\n            externalSwap: swapParams,\n            borrowingKey: borrowingKey,\n            swapSlippageBP1000: 0,\n        };\n\n        //console.log(debt);\n        let loans: LiquidityManager.LoanInfoStructOutput[] = await borrowingManager.getLoansInfo(borrowingKey);\n        expect(loans.length).to.equal(3);\n\n        let tokenRate = await borrowingManager.getHoldTokenDailyRateInfo(\n            debt[1].info.saleToken,\n            debt[1].info.holdToken\n        );\n\n        // We're going to repay alice loan which is [0] in loans array\n        const aliceLoanPercentage = loans[0].liquidity\n            .mul(100)\n            .div(loans[0].liquidity.add(loans[1].liquidity).add(loans[2].liquidity));\n        console.log(\"Alice % of total borrow: \" + aliceLoanPercentage); //Alice liquidity is around 26% of the borrowing position\n\n        //Here we do like the smart contract does, try to see how much accLoanRatePerSeconds we need to remove to find back our missing collateral\n        //without removedAmount we use the new borrowed amount (current implementation)\n        let accToRemoveWithoutRemovedAmount = debt[1].collateralBalance\n            .mul(-1)\n            .mul(10_000)\n            .div(debt[1].info.borrowedAmount.mul(100 - aliceLoanPercentage.toNumber()).div(100));\n        //with removedAmount (proposed solution), we forfeit alice part of missing collateral since she emergency withdraw\n        let accToRemoveWithRemovedAmount = debt[1].collateralBalance\n            .mul(-1)\n            .mul(10_000)\n            .div(debt[1].info.borrowedAmount);\n\n        //this is the accLoanRatePerSeconds that we're going to substract from\n        console.log(\"% to remove: \" + accToRemoveWithoutRemovedAmount);\n        console.log(\"accLoanRatePerSeconds: \" + tokenRate.holdTokenRateInfo.accLoanRatePerSeconds);\n\n        //for now even after 36hours we're still less than accLoanRatePerSeconds so no underflow\n        console.log(\"% to remove is less than accLoanRatePerSeconds\");\n        expect(tokenRate.holdTokenRateInfo.accLoanRatePerSeconds.gt(accToRemoveWithoutRemovedAmount));\n\n        //let's add 12 more hours\n        await time.increase(3600 * 12); //add 12 hours\n\n        tokenRate = await borrowingManager.getHoldTokenDailyRateInfo(debt[1].info.saleToken, debt[1].info.holdToken); //update token rate\n        debt = await borrowingManager.getBorrowerDebtsInfo(bob.address); //update debt variable\n        accToRemoveWithoutRemovedAmount = debt[1].collateralBalance\n            .mul(-1)\n            .mul(10_000)\n            .div(debt[1].info.borrowedAmount.mul(100 - aliceLoanPercentage.toNumber()).div(100));\n        accToRemoveWithRemovedAmount = debt[1].collateralBalance.mul(-1).mul(10_000).div(debt[1].info.borrowedAmount);\n\n        console.log(\"% to remove: \" + accToRemoveWithoutRemovedAmount);\n        console.log(\"accLoanRatePerSeconds: \" + tokenRate.holdTokenRateInfo.accLoanRatePerSeconds);\n\n        //the accToRemoveWithoutRemovedAmount is now greater than accLoanRatePerSeconds\n        console.log(\"% to remove is greater than accLoanRatePerSeconds thus it will underflow\");\n        expect(tokenRate.holdTokenRateInfo.accLoanRatePerSeconds.lt(accToRemoveWithoutRemovedAmount));\n\n        let deadline = (await time.latest()) + 60;\n\n        //this is going to revert with underflow\n        await expect(borrowingManager.connect(alice).repay(params, deadline)).to.be.reverted;\n        /**\n        expect(await borrowingManager.getLenderCreditsCount(nftpos[0].tokenId)).to.be.equal(0);\n        expect(await borrowingManager.getLenderCreditsCount(nftpos[1].tokenId)).to.be.gt(0);\n        expect(await borrowingManager.getLenderCreditsCount(nftpos[2].tokenId)).to.be.gt(0);\n        expect(await borrowingManager.getLenderCreditsCount(nftpos[3].tokenId)).to.be.gt(0);\n        expect(await borrowingManager.getLenderCreditsCount(nftpos[4].tokenId)).to.be.gt(0);\n        expect(await borrowingManager.getLenderCreditsCount(nftpos[5].tokenId)).to.be.gt(0);\n        expect(await borrowingManager.getBorrowerDebtsCount(bob.address)).to.be.equal(2);\n\n        debt = await borrowingManager.getBorrowerDebtsInfo(bob.address);\n        //console.log(debt);\n        loans = await borrowingManager.getLoansInfo(borrowingKey);\n        expect(loans.length).to.equal(2);\n        \n        await time.increase(100);\n        deadline = (await time.latest()) + 60;\n        await expect(borrowingManager.connect(bob).repay(params, deadline))\n            .to.emit(borrowingManager, \"EmergencyLoanClosure\")\n            .withArgs(bob.address, bob.address, borrowingKey);\n        expect(await borrowingManager.getLenderCreditsCount(nftpos[0].tokenId)).to.be.equal(0);\n        expect(await borrowingManager.getLenderCreditsCount(nftpos[1].tokenId)).to.be.equal(0);\n        expect(await borrowingManager.getLenderCreditsCount(nftpos[2].tokenId)).to.be.gt(0);\n        expect(await borrowingManager.getLenderCreditsCount(nftpos[3].tokenId)).to.be.gt(0);\n        expect(await borrowingManager.getLenderCreditsCount(nftpos[4].tokenId)).to.be.gt(0);\n        expect(await borrowingManager.getLenderCreditsCount(nftpos[5].tokenId)).to.be.gt(0);\n        expect(await borrowingManager.getBorrowerDebtsCount(bob.address)).to.be.equal(2);\n        debt = await borrowingManager.getBorrowerDebtsInfo(bob.address);\n        //console.log(debt);\n        loans = await borrowingManager.getLoansInfo(borrowingKey);\n        expect(loans.length).to.equal(1);\n\n        await time.increase(100);\n        deadline = (await time.latest()) + 60;\n        await expect(borrowingManager.connect(owner).repay(params, deadline))\n            .to.emit(borrowingManager, \"EmergencyLoanClosure\")\n            .withArgs(bob.address, owner.address, borrowingKey);\n        expect(await borrowingManager.getLenderCreditsCount(nftpos[0].tokenId)).to.be.equal(0);\n        expect(await borrowingManager.getLenderCreditsCount(nftpos[1].tokenId)).to.be.equal(0);\n        expect(await borrowingManager.getLenderCreditsCount(nftpos[2].tokenId)).to.be.equal(0);\n        expect(await borrowingManager.getLenderCreditsCount(nftpos[3].tokenId)).to.be.gt(0);\n        expect(await borrowingManager.getLenderCreditsCount(nftpos[4].tokenId)).to.be.gt(0);\n        expect(await borrowingManager.getLenderCreditsCount(nftpos[5].tokenId)).to.be.gt(0);\n        expect(await borrowingManager.getBorrowerDebtsCount(bob.address)).to.be.equal(1);*/\n    });\n```\n\nIn this example Alice represents only 26% of the borrowed amount and the `accLoanRatePerSeconds` started before this loan so a longer time is needed (here I did 48hours) but if the user calling emergency repay has a much higher percentage or it's the first borrow it wouldn't need as much time.\n\nI understand that my solution might not be what you want, but the underflow problem do exist.\n\n\n**sherlock-admin2**\n\n> Escalate\n> \n> While using the new `borrowing.borrowedAmount` make sense to keep the missing collateral balance it will lead to underflow if the `holdTokenRateInfo.accLoanRatePerSeconds` is too low (ex: the first user to borrow so `accLoanRatePerSeconds` started at the same time).\n> \n> To find the missing collateral balance with a smaller borrowed amount, the only solution is to increase the percentage. But like I said, if you increase the percentage you might end up underflowing as the `accLoanRatePerSeconds` didn't change.\n> \n> Here is a simple example:\n> - You have 10 tokens of collateral missing and 200 tokens total and we remove 50 tokens. The rate is 1% daily.\n> - 10 / 200 * 100 = 5% is the percentage value of the missing collateral compared to the amount borrowed. \n> - Since we were the first to borrow `accLoanRatePerSeconds` is pretty close to the missing collateral percentage, minus 1 day (user deposits at least 1 day of collateral when borrowing). 200*1/100 = 2 so the `accLoanRatePerSeconds` is 10+2 / 200 * 100 = 6%.\n> - In the contract what we do instead is 10 / (200-50) * 100 = 6.66%. We do this because we want to be able to find the missing collateral using a smaller balance during the next call as the state is updated.\n> - The substraction underflow because 6% > 5%.\n> \n> I did play with the emergency close tests. Here I reused it and added comments:\n> \n> ```js\n> it(\"emergency repay will be successful for PosManNFT owner if the collateral is depleted\", async () => {\n>         let debt: LiquidityBorrowingManager.BorrowingInfoExtStructOutput[] =\n>             await borrowingManager.getBorrowerDebtsInfo(bob.address);\n> \n>         await time.increase(debt[1].estimatedLifeTime.toNumber() + 3600 * 36); //add 36 hours as an example\n> \n>         debt = await borrowingManager.getBorrowerDebtsInfo(bob.address); //update debt variable\n> \n>         let borrowingKey = await borrowingManager.userBorrowingKeys(bob.address, 1);\n> \n>         let swap_params = ethers.utils.defaultAbiCoder.encode(\n>             [\"address\", \"address\", \"uint256\", \"uint256\"],\n>             [constants.AddressZero, constants.AddressZero, 0, 0]\n>         );\n>         swapData = swapIface.encodeFunctionData(\"swap\", [swap_params]);\n> \n>         let swapParams: ApproveSwapAndPay.SwapParamsStruct = {\n>             swapTarget: constants.AddressZero,\n>             swapAmountInDataIndex: 0,\n>             maxGasForCall: 0,\n>             swapData: swapData,\n>         };\n> \n>         let params: LiquidityBorrowingManager.RepayParamsStruct = {\n>             isEmergency: true, //emergency\n>             internalSwapPoolfee: 0,\n>             externalSwap: swapParams,\n>             borrowingKey: borrowingKey,\n>             swapSlippageBP1000: 0,\n>         };\n> \n>         //console.log(debt);\n>         let loans: LiquidityManager.LoanInfoStructOutput[] = await borrowingManager.getLoansInfo(borrowingKey);\n>         expect(loans.length).to.equal(3);\n> \n>         let tokenRate = await borrowingManager.getHoldTokenDailyRateInfo(\n>             debt[1].info.saleToken,\n>             debt[1].info.holdToken\n>         );\n> \n>         // We're going to repay alice loan which is [0] in loans array\n>         const aliceLoanPercentage = loans[0].liquidity\n>             .mul(100)\n>             .div(loans[0].liquidity.add(loans[1].liquidity).add(loans[2].liquidity));\n>         console.log(aliceLoanPercentage); //Alice liquidity is around 26% of the borrowing position\n> \n>         //Here we do like the smart contract does, try to see how much accLoanRatePerSeconds we need to remove to find back our missing collateral\n>         //without removedAmount (proposed solution), we forfeit alice part of missing collateral since she emergency withdraw\n>         let accToRemoveWithoutRemovedAmount = debt[1].collateralBalance\n>             .mul(-1)\n>             .mul(10_000)\n>             .div(debt[1].info.borrowedAmount.mul(100 - aliceLoanPercentage.toNumber()).div(100));\n>         //with removedAmount (current implmentation)\n>         let accToRemoveWithRemovedAmount = debt[1].collateralBalance\n>             .mul(-1)\n>             .mul(10_000)\n>             .div(debt[1].info.borrowedAmount);\n> \n>         //this is the accLoanRatePerSeconds that we're going to substract from\n>         console.log(tokenRate.holdTokenRateInfo.accLoanRatePerSeconds);\n> \n>         //for now even after 36hours we're still less than accLoanRatePerSeconds so no underflow\n>         expect(tokenRate.holdTokenRateInfo.accLoanRatePerSeconds.gt(accToRemoveWithRemovedAmount));\n> \n>         //let's add 12 more hours\n>         await time.increase(debt[1].estimatedLifeTime.toNumber() + 3600 * 12); //add 12 hours\n> \n>         debt = await borrowingManager.getBorrowerDebtsInfo(bob.address); //update debt variable\n>         accToRemoveWithoutRemovedAmount = debt[1].collateralBalance\n>             .mul(-1)\n>             .mul(10_000)\n>             .div(debt[1].info.borrowedAmount.mul(100 - aliceLoanPercentage.toNumber()).div(100));\n>         accToRemoveWithRemovedAmount = debt[1].collateralBalance.mul(-1).mul(10_000).div(debt[1].info.borrowedAmount);\n> \n>         //the accToRemoveWithRemovedAmount is now greater than accLoanRatePerSeconds\n>         expect(tokenRate.holdTokenRateInfo.accLoanRatePerSeconds.lt(accToRemoveWithRemovedAmount));\n> \n>         let deadline = (await time.latest()) + 60;\n> \n>         //this is going to revert with underflow\n>         await expect(borrowingManager.connect(alice).repay(params, deadline))\n>             .to.emit(borrowingManager, \"EmergencyLoanClosure\")\n>             .withArgs(bob.address, alice.address, borrowingKey);\n> \n>         expect(await borrowingManager.getLenderCreditsCount(nftpos[0].tokenId)).to.be.equal(0);\n>         expect(await borrowingManager.getLenderCreditsCount(nftpos[1].tokenId)).to.be.gt(0);\n>         expect(await borrowingManager.getLenderCreditsCount(nftpos[2].tokenId)).to.be.gt(0);\n>         expect(await borrowingManager.getLenderCreditsCount(nftpos[3].tokenId)).to.be.gt(0);\n>         expect(await borrowingManager.getLenderCreditsCount(nftpos[4].tokenId)).to.be.gt(0);\n>         expect(await borrowingManager.getLenderCreditsCount(nftpos[5].tokenId)).to.be.gt(0);\n>         expect(await borrowingManager.getBorrowerDebtsCount(bob.address)).to.be.equal(2);\n> \n>         debt = await borrowingManager.getBorrowerDebtsInfo(bob.address);\n>         //console.log(debt);\n>         loans = await borrowingManager.getLoansInfo(borrowingKey);\n>         expect(loans.length).to.equal(2);\n>         /**\n>         await time.increase(100);\n>         deadline = (await time.latest()) + 60;\n>         await expect(borrowingManager.connect(bob).repay(params, deadline))\n>             .to.emit(borrowingManager, \"EmergencyLoanClosure\")\n>             .withArgs(bob.address, bob.address, borrowingKey);\n>         expect(await borrowingManager.getLenderCreditsCount(nftpos[0].tokenId)).to.be.equal(0);\n>         expect(await borrowingManager.getLenderCreditsCount(nftpos[1].tokenId)).to.be.equal(0);\n>         expect(await borrowingManager.getLenderCreditsCount(nftpos[2].tokenId)).to.be.gt(0);\n>         expect(await borrowingManager.getLenderCreditsCount(nftpos[3].tokenId)).to.be.gt(0);\n>         expect(await borrowingManager.getLenderCreditsCount(nftpos[4].tokenId)).to.be.gt(0);\n>         expect(await borrowingManager.getLenderCreditsCount(nftpos[5].tokenId)).to.be.gt(0);\n>         expect(await borrowingManager.getBorrowerDebtsCount(bob.address)).to.be.equal(2);\n>         debt = await borrowingManager.getBorrowerDebtsInfo(bob.address);\n>         //console.log(debt);\n>         loans = await borrowingManager.getLoansInfo(borrowingKey);\n>         expect(loans.length).to.equal(1);\n> \n>         await time.increase(100);\n>         deadline = (await time.latest()) + 60;\n>         await expect(borrowingManager.connect(owner).repay(params, deadline))\n>             .to.emit(borrowingManager, \"EmergencyLoanClosure\")\n>             .withArgs(bob.address, owner.address, borrowingKey);\n>         expect(await borrowingManager.getLenderCreditsCount(nftpos[0].tokenId)).to.be.equal(0);\n>         expect(await borrowingManager.getLenderCreditsCount(nftpos[1].tokenId)).to.be.equal(0);\n>         expect(await borrowingManager.getLenderCreditsCount(nftpos[2].tokenId)).to.be.equal(0);\n>         expect(await borrowingManager.getLenderCreditsCount(nftpos[3].tokenId)).to.be.gt(0);\n>         expect(await borrowingManager.getLenderCreditsCount(nftpos[4].tokenId)).to.be.gt(0);\n>         expect(await borrowingManager.getLenderCreditsCount(nftpos[5].tokenId)).to.be.gt(0);\n>         expect(await borrowingManager.getBorrowerDebtsCount(bob.address)).to.be.equal(1);*/\n>     });\n> ```\n> \n> In this example Alice represents only 26% of the borrowed amount and the `accLoanRatePerSeconds` started before this loan so a longer time is needed (here I did 48hours) but if the user calling emergency repay has a much higher percentage or it's the first borrow it wouldn't need as much time.\n> \n> I understand that my solution might not be what you want, but the underflow problem do exist.\n> \n\nThe escalation could not be created because you are not exceeding the escalation threshold.\n\nYou can view the required number of additional valid issues/judging contest payouts in your Profile page,\nin the [Sherlock webapp](https://app.sherlock.xyz/audits/).\n\n\n**fann95**\n\n> ```js\n> debt = await borrowingManager.getBorrowerDebtsInfo(bob.address); //update debt variable\n> ```\n\ntokenRate also needs to be updated like the debt variable\n\n**HHK-ETH**\n\nRight, my bad sorry wrote the test quickly. Updated my comment with the new token rate, `repay` still underflow.\n\n**HHK-ETH**\n\n@fann95 @cvetanovv sorry to bother but would appreciate if you could read the escalation comment again and run the 2 POCs provided (comment and initial finding) before escalation period ends.\n\nThe `repay()` reverts with underflow when increasing the missing collateral to a certain amount (just a few days in the examples given). I tried to explain that it comes from the `accLoanRatePerSeconds` calculation. I'll happily take the blame if I'm wrong and will be sorry for the time wasted but if I'm right this is problably something we want to fix or lenders might not be able to call `repay` and will have to count on liquidators.\n\n**chewonithard**\n\nissue [195](https://github.com/sherlock-audit/2023-10-real-wagmi-judging/issues/195) is also similar. I think both issues should be reconsidered to be valid.\n\nThis bug is easily replicated using protocol's own default test file WagmiLeverageTests.ts by changing [line 1040](https://github.com/sherlock-audit/2023-10-real-wagmi-chewonithard/blob/main/wagmi-leverage/test/WagmiLeverageTests.ts#L1040) to 100_000 seconds (~1 day)\n\nExpecting an under-collateralized loan to not be liquidated in ~1 day is not unrealistic, after which the failure of emergency mode represents a significant impact to a critical protocol function.\n\n**Czar102**\n\n@fann95 @cvetanovv could you take a look at this and #195?\n\n**cvetanovv**\n\nShould be duplicated and rather seem valid to me\n\n**Czar102**\n\n@fann95 could you post your opinion on this issue? It seems to be valid.\n\n**fann95**\n\nI looked at this problem one more and realized: yes, this is a mistake. When a liquidity provider withdraws its liquidity, it also surrenders its fee debt, so the debt must be reduced in proportion to the reduction in liquidity.\n\n**fann95**\n\nI came to an interesting conclusion: the borrowingStorage.accLoanRatePerSeconds does not need to be recalculated. It should remain the same as it was, and the borrowed amount should be decreased only. So, accordingly, the fee debt will be reduced during a future recalculation.\nFixed: https://github.com/RealWagmi/wagmi-leverage/commit/4d355d8cafc86f1341af7b5acfb485a2a33ce61a\n\n**Czar102**\n\n@fann95 may I ask why do you consider this a high severity issue? It seems the watson classified this as medium severity.\n\n**Czar102**\n\nAgree with medium severity. Will be accepting the escalation.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/118",
  "Code": [
    {
      "filename": "wagmi-leverage/contracts/LiquidityBorrowingManager.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./abstract/LiquidityManager.sol\";\nimport \"./abstract/OwnerSettings.sol\";\nimport \"./abstract/DailyRateAndCollateral.sol\";\nimport \"./libraries/ErrLib.sol\";\n\n/**\n * @title LiquidityBorrowingManager\n * @dev This contract manages the borrowing liquidity functionality for WAGMI Leverage protocol.\n * It inherits from LiquidityManager, OwnerSettings, DailyRateAndCollateral, and ReentrancyGuard contracts.\n */\ncontract LiquidityBorrowingManager is\n    LiquidityManager,\n    OwnerSettings,\n    DailyRateAndCollateral,\n    ReentrancyGuard\n{\n    using { Keys.removeKey, Keys.addKeyIfNotExists } for bytes32[];\n    using { ErrLib.revertError } for bool;\n\n    /// @title BorrowParams\n    /// @notice This struct represents the parameters required for borrowing.\n    struct BorrowParams {\n        /// @notice The pool fee level for the internal swap\n        uint24 internalSwapPoolfee;\n        /// @notice The address of the token that will be sold to obtain the loan currency\n        address saleToken;\n        /// @notice The address of the token that will be held\n        address holdToken;\n        /// @notice The minimum amount of holdToken that must be obtained\n        uint256 minHoldTokenOut;\n        /// @notice The maximum amount of collateral that can be provided for the loan\n        uint256 maxCollateral;\n        /// @notice The SwapParams struct representing the external swap parameters\n        SwapParams externalSwap;\n        /// @notice An array of LoanInfo structs representing multiple loans\n        LoanInfo[] loans;\n    }\n    /// @title BorrowingInfo\n    /// @notice This struct represents the borrowing information for a borrower.\n    struct BorrowingInfo {\n        address borrower;\n        address saleToken;\n        address holdToken;\n        /// @notice The amount of fees owed by the creditor\n        uint256 feesOwed;\n        /// @notice The amount borrowed by the borrower\n        uint256 borrowedAmount;\n        /// @notice The amount of liquidation bonus\n        uint256 liquidationBonus;\n        /// @notice The accumulated loan rate per share\n        uint256 accLoanRatePerSeconds;\n        /// @notice The daily rate collateral balance multiplied by COLLATERAL_BALANCE_PRECISION\n        uint256 dailyRateCollateralBalance;\n    }\n    /// @notice This struct used for caching variables inside a function 'borrow'\n    struct BorrowCache {\n        uint256 dailyRateCollateral;\n        uint256 accLoanRatePerSeconds;\n        uint256 borrowedAmount;\n        uint256 holdTokenBalance;\n    }\n    /// @notice Struct representing the extended borrowing information.\n    struct BorrowingInfoExt {\n        /// @notice The main borrowing information.\n        BorrowingInfo info;\n        /// @notice An array of LoanInfo structs representing multiple loans\n        LoanInfo[] loans;\n        /// @notice The balance of the collateral.\n        int256 collateralBalance;\n        /// @notice The estimated lifetime of the loan.\n        uint256 estimatedLifeTime;\n        /// borrowing Key\n        bytes32 key;\n    }\n\n    /// @title RepayParams\n    /// @notice This struct represents the parameters required for repaying a loan.\n    struct RepayParams {\n        /// @notice The activation of the emergency liquidity restoration mode (available only to the lender)\n        bool isEmergency;\n        /// @notice The pool fee level for the internal swap\n        uint24 internalSwapPoolfee;\n        /// @notice The external swap parameters for the repayment transaction\n        SwapParams externalSwap;\n        /// @notice The unique borrowing key associated with the loan\n        bytes32 borrowingKey;\n        /// @notice The slippage allowance for the swap in basis points (1/10th of a percent)\n        uint256 swapSlippageBP1000;\n    }\n    /// borrowingKey=>LoanInfo\n    mapping(bytes32 => LoanInfo[]) public loansInfo;\n    /// borrowingKey=>BorrowingInfo\n    mapping(bytes32 => BorrowingInfo) public borrowingsInfo;\n    /// borrower => BorrowingKeys[]\n    mapping(address => bytes32[]) public userBorrowingKeys;\n    /// NonfungiblePositionManager tokenId => BorrowingKeys[]\n    mapping(uint256 => bytes32[]) public tokenIdToBorrowingKeys;\n\n    ///  token => FeesAmt\n    mapping(address => uint256) private platformsFeesInfo;\n\n    /// Indicates that a borrower has made a new loan\n    event Borrow(\n        address borrower,\n        bytes32 borrowingKey,\n        uint256 borrowedAmount,\n        uint256 borrowingCollateral,\n        uint256 liquidationBonus,\n        uint256 dailyRatePrepayment\n    );\n    /// Indicates that a borrower has repaid their loan, optionally with the help of a liquidator\n    event Repay(address borrower, address liquidator, bytes32 borrowingKey);\n    /// Indicates that a loan has been closed due to an emergency situation\n    event EmergencyLoanClosure(address borrower, address lender, bytes32 borrowingKey);\n    /// Indicates that the protocol has collected fee tokens\n    event CollectProtocol(address recipient, address[] tokens, uint256[] amounts);\n    /// Indicates that the daily interest rate for holding token(for specific pair) has been updated\n    event UpdateHoldTokenDailyRate(address saleToken, address holdToken, uint256 value);\n    /// Indicates that a borrower has increased their collateral balance for a loan\n    event IncreaseCollateralBalance(address borrower, bytes32 borrowingKey, uint256 collateralAmt);\n    /// Indicates that a new borrower has taken over the debt from an old borrower\n    event TakeOverDebt(\n        address oldBorrower,\n        address newBorrower,\n        bytes32 oldBorrowingKey,\n        bytes32 newBorrowingKey\n    );\n\n    error TooLittleReceivedError(uint256 minOut, uint256 out);\n\n    /// @dev Modifier to check if the current block timestamp is before or equal to the deadline.\n    modifier checkDeadline(uint256 deadline) {\n        (_blockTimestamp() > deadline).revertError(ErrLib.ErrorCode.TOO_OLD_TRANSACTION);\n        _;\n    }\n\n    function _blockTimestamp() internal view returns (uint256) {\n        return block.timestamp;\n    }\n\n    constructor(\n        address _underlyingPositionManagerAddress,\n        address _underlyingQuoterV2,\n        address _underlyingV3Factory,\n        bytes32 _underlyingV3PoolInitCodeHash\n    )\n        LiquidityManager(\n            _underlyingPositionManagerAddress,\n            _underlyingQuoterV2,\n            _underlyingV3Factory,\n            _underlyingV3PoolInitCodeHash\n        )\n    {}\n\n    /**\n     * @dev Adds or removes a swap call params to the whitelist.\n     * @param swapTarget The address of the target contract for the swap call.\n     * @param funcSelector The function selector of the swap call.\n     * @param isAllowed A boolean indicating whether the swap call is allowed or not.\n     */\n    function setSwapCallToWhitelist(\n        address swapTarget,\n        bytes4 funcSelector,\n        bool isAllowed\n    ) external onlyOwner {\n        (swapTarget == VAULT_ADDRESS ||\n            swapTarget == address(this) ||\n            swapTarget == address(underlyingPositionManager) ||\n            funcSelector == IERC20.transferFrom.selector).revertError(ErrLib.ErrorCode.FORBIDDEN);\n        whitelistedCall[swapTarget][funcSelector] = isAllowed;\n    }\n\n    /**\n     * @notice This function allows the owner to collect protocol fees for multiple tokens\n     * and transfer them to a specified recipient.\n     * @dev Only the contract owner can call this function.\n     * @param recipient The address of the recipient who will receive the collected fees.\n     * @param tokens An array of addresses representing the tokens for which fees will be collected.\n     */\n    function collectProtocol(address recipient, address[] calldata tokens) external onlyOwner {\n        uint256[] memory amounts = new uint256[](tokens.length);\n        for (uint256 i; i < tokens.length; ) {\n            address token = tokens[i];\n            uint256 amount = platformsFeesInfo[token] / Constants.COLLATERAL_BALANCE_PRECISION;\n            if (amount > 0) {\n                platformsFeesInfo[token] = 0;\n                amounts[i] = amount;\n                Vault(VAULT_ADDRESS).transferToken(token, recipient, amount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit CollectProtocol(recipient, tokens, amounts);\n    }\n\n    /**\n     * @notice This function is used to update the daily rate for holding token for specific pair.\n     * @dev Only the daily rate operator can call this function.\n     * @param saleToken The address of the sale token.\n     * @param holdToken The address of the hold token.\n     * @param value The new value of the daily rate for the hold token will be calculated based\n     * on the volatility of the pair and the popularity of loans in it\n     * @dev The value must be within the range of MIN_DAILY_RATE and MAX_DAILY_RATE.\n     */\n    function updateHoldTokenDailyRate(\n        address saleToken,\n        address holdToken,\n        uint256 value\n    ) external {\n        (msg.sender != dailyRateOperator).revertError(ErrLib.ErrorCode.INVALID_CALLER);\n        if (value > Constants.MAX_DAILY_RATE || value < Constants.MIN_DAILY_RATE) {\n            revert InvalidSettingsValue(value);\n        }\n        // If the value is within the acceptable range, the function updates the currentDailyRate property\n        // of the holdTokenRateInfo structure associated with the token pair.\n        (, TokenInfo storage holdTokenRateInfo) = _updateTokenRateInfo(saleToken, holdToken);\n        holdTokenRateInfo.currentDailyRate = value;\n        emit UpdateHoldTokenDailyRate(saleToken, holdToken, value);\n    }\n\n    /**\n     * @notice This function is used to check the daily rate collateral for a specific borrowing.\n     * @param borrowingKey The key of the borrowing.\n     * @return balance The balance of the daily rate collateral.\n     * @return estimatedLifeTime The estimated lifetime of the collateral in seconds.\n     */\n    function checkDailyRateCollateral(\n        bytes32 borrowingKey\n    ) external view returns (int256 balance, uint256 estimatedLifeTime) {\n        (, balance, estimatedLifeTime) = _getDebtInfo(borrowingKey);\n        balance /= int256(Constants.COLLATERAL_BALANCE_PRECISION);\n    }\n\n    /**\n     * @notice Get information about loans associated with a borrowing key\n     * @dev This function retrieves an array of loan information for a given borrowing key.\n     * The loans are stored in the loansInfo mapping, which is a mapping of borrowing keys to LoanInfo arrays.\n     * @param borrowingKey The unique key associated with the borrowing\n     * @return loans An array containing LoanInfo structs representing the loans associated with the borrowing key\n     */\n    function getLoansInfo(bytes32 borrowingKey) external view returns (LoanInfo[] memory loans) {\n        loans = loansInfo[borrowingKey];\n    }\n\n    /**\n     * @notice Retrieves the borrowing information for a specific NonfungiblePositionManager tokenId.\n     * @param tokenId The unique identifier of the PositionManager token.\n     * @return extinfo An array of BorrowingInfoExt structs representing the borrowing information.\n     */\n    function getLenderCreditsInfo(\n        uint256 tokenId\n    ) external view returns (BorrowingInfoExt[] memory extinfo) {\n        bytes32[] memory borrowingKeys = tokenIdToBorrowingKeys[tokenId];\n        extinfo = _getDebtsInfo(borrowingKeys);\n    }\n\n    /**\n     * @notice Retrieves the debts information for a specific borrower.\n     * @param borrower The address of the borrower.\n     * @return extinfo An array of BorrowingInfoExt structs representing the borrowing information.\n     */\n    function getBorrowerDebtsInfo(\n        address borrower\n    ) external view returns (BorrowingInfoExt[] memory extinfo) {\n        bytes32[] memory borrowingKeys = userBorrowingKeys[borrower];\n        extinfo = _getDebtsInfo(borrowingKeys);\n    }\n\n    /**\n     * @dev Returns the number of loans associated with a given NonfungiblePositionManager tokenId.\n     * @param tokenId The ID of the token.\n     * @return count The total number of loans associated with the tokenId.\n     */\n    function getLenderCreditsCount(uint256 tokenId) external view returns (uint256 count) {\n        bytes32[] memory borrowingKeys = tokenIdToBorrowingKeys[tokenId];\n        count = borrowingKeys.length;\n    }\n\n    /**\n     * @dev Returns the number of borrowings for a given borrower.\n     * @param borrower The address of the borrower.\n     * @return count The total number of borrowings for the borrower.\n     */\n    function getBorrowerDebtsCount(address borrower) external view returns (uint256 count) {\n        bytes32[] memory borrowingKeys = userBorrowingKeys[borrower];\n        count = borrowingKeys.length;\n    }\n\n    /**\n     * @dev Returns the current daily rate for holding token.\n     * @param saleToken The address of the token being sold.\n     * @param holdToken The address of the token being held.\n     * @return currentDailyRate The current daily rate .\n     */\n    function getHoldTokenDailyRateInfo(\n        address saleToken,\n        address holdToken\n    ) external view returns (uint256 currentDailyRate, TokenInfo memory holdTokenRateInfo) {\n        (currentDailyRate, holdTokenRateInfo) = _getHoldTokenRateInfo(saleToken, holdToken);\n    }\n\n    /**\n     * @dev Returns the fees information for multiple tokens in an array.\n     * @param tokens An array of token addresses for which the fees are to be retrieved.\n     * @return fees An array containing the fees for each token.\n     */\n    function getPlatformsFeesInfo(\n        address[] calldata tokens\n    ) external view returns (uint256[] memory fees) {\n        fees = new uint256[](tokens.length);\n        for (uint256 i; i < tokens.length; ) {\n            address token = tokens[i];\n            uint256 amount = platformsFeesInfo[token] / Constants.COLLATERAL_BALANCE_PRECISION;\n            fees[i] = amount;\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Calculates the collateral amount required for a lifetime in seconds.\n     *\n     * @param borrowingKey The unique identifier of the borrowing.\n     * @param lifetimeInSeconds The duration of the borrowing in seconds.\n     * @return collateralAmt The calculated collateral amount that is needed.\n     */\n    function calculateCollateralAmtForLifetime(\n        bytes32 borrowingKey,\n        uint256 lifetimeInSeconds\n    ) external view returns (uint256 collateralAmt) {\n        // Retrieve the BorrowingInfo struct associated with the borrowing key\n        BorrowingInfo memory borrowing = borrowingsInfo[borrowingKey];\n        // Check if the borrowed position is existing\n        if (borrowing.borrowedAmount > 0) {\n            // Get the current daily rate for the hold token\n            (uint256 currentDailyRate, ) = _getHoldTokenRateInfo(\n                borrowing.saleToken,\n                borrowing.holdToken\n            );\n            // Calculate the collateral amount per second\n            uint256 everySecond = (\n                FullMath.mulDivRoundingUp(\n                    borrowing.borrowedAmount,\n                    currentDailyRate * Constants.COLLATERAL_BALANCE_PRECISION,\n                    1 days * Constants.BP\n                )\n            );\n            // Calculate the total collateral amount for the borrowing lifetime\n            collateralAmt = FullMath.mulDivRoundingUp(\n                everySecond,\n                lifetimeInSeconds,\n                Constants.COLLATERAL_BALANCE_PRECISION\n            );\n            // Ensure that the collateral amount is at least 1\n            if (collateralAmt == 0) collateralAmt = 1;\n        }\n    }\n\n    /**\n     * @notice This function is used to increase the daily rate collateral for a specific borrowing.\n     * @param borrowingKey The unique identifier of the borrowing.\n     * @param collateralAmt The amount of collateral to be added.\n     */\n    function increaseCollateralBalance(bytes32 borrowingKey, uint256 collateralAmt) external {\n        BorrowingInfo storage borrowing = borrowingsInfo[borrowingKey];\n        // Ensure that the borrowed position exists and the borrower is the message sender\n        (borrowing.borrowedAmount == 0 || borrowing.borrower != address(msg.sender)).revertError(\n            ErrLib.ErrorCode.INVALID_BORROWING_KEY\n        );\n        // Increase the daily rate collateral balance by the specified collateral amount\n        borrowing.dailyRateCollateralBalance +=\n            collateralAmt *\n            Constants.COLLATERAL_BALANCE_PRECISION;\n        _pay(borrowing.holdToken, msg.sender, VAULT_ADDRESS, collateralAmt);\n        emit IncreaseCollateralBalance(msg.sender, borrowingKey, collateralAmt);\n    }\n\n    /**\n     * @notice Take over debt by transferring ownership of a borrowing to the current caller\n     * @dev This function allows the current caller to take over a debt from another borrower.\n     * The function validates the borrowingKey and checks if the collateral balance is negative.\n     * If the conditions are met, the function transfers ownership of the borrowing to the current caller,\n     * updates the daily rate collateral balance, and pays the collateral amount to the vault.\n     * Emits a `TakeOverDebt` event.\n     * @param borrowingKey The unique key associated with the borrowing to be taken over\n     * @param collateralAmt The amount of collateral to be provided by the new borrower\n     */\n    function takeOverDebt(bytes32 borrowingKey, uint256 collateralAmt) external {\n        BorrowingInfo memory oldBorrowing = borrowingsInfo[borrowingKey];\n        // Ensure that the borrowed position exists\n        (oldBorrowing.borrowedAmount == 0).revertError(ErrLib.ErrorCode.INVALID_BORROWING_KEY);\n\n        uint256 accLoanRatePerSeconds;\n        uint256 minPayment;\n        {\n            // Update token rate info and retrieve the accumulated loan rate per second for holdToken\n            (, TokenInfo storage holdTokenRateInfo) = _updateTokenRateInfo(\n                oldBorrowing.saleToken,\n                oldBorrowing.holdToken\n            );\n            accLoanRatePerSeconds = holdTokenRateInfo.accLoanRatePerSeconds;\n            // Calculate the collateral balance and current fees for the oldBorrowing\n            (int256 collateralBalance, uint256 currentFees) = _calculateCollateralBalance(\n                oldBorrowing.borrowedAmount,\n                oldBorrowing.accLoanRatePerSeconds,\n                oldBorrowing.dailyRateCollateralBalance,\n                accLoanRatePerSeconds\n            );\n            // Ensure that the collateral balance is greater than or equal to 0\n            (collateralBalance >= 0).revertError(ErrLib.ErrorCode.FORBIDDEN);\n            // Pick up platform fees from the oldBorrowing's holdToken and add them to the feesOwed\n            currentFees = _pickUpPlatformFees(oldBorrowing.holdToken, currentFees);\n            oldBorrowing.feesOwed += currentFees;\n            // Calculate the minimum payment required based on the collateral balance\n            minPayment = (uint256(-collateralBalance) / Constants.COLLATERAL_BALANCE_PRECISION) + 1;\n            (collateralAmt <= minPayment).revertError(\n                ErrLib.ErrorCode.COLLATERAL_AMOUNT_IS_NOT_ENOUGH\n            );\n        }\n        // Retrieve the old loans associated with the borrowing key and remove them from storage\n        LoanInfo[] memory oldLoans = loansInfo[borrowingKey];\n        _removeKeysAndClearStorage(oldBorrowing.borrower, borrowingKey, oldLoans);\n        // Initialize a new borrowing using the same saleToken, holdToken\n        (\n            uint256 feesDebt,\n            bytes32 newBorrowingKey,\n            BorrowingInfo storage newBorrowing\n        ) = _initOrUpdateBorrowing(\n                oldBorrowing.saleToken,\n                oldBorrowing.holdToken,\n                accLoanRatePerSeconds\n            );\n        // Add the new borrowing key and old loans to the newBorrowing\n        _addKeysAndLoansInfo(newBorrowing.borrowedAmount > 0, borrowingKey, oldLoans);\n        // Increase the borrowed amount, liquidation bonus, and fees owed of the newBorrowing based on the oldBorrowing\n        newBorrowing.borrowedAmount += oldBorrowing.borrowedAmount;\n        newBorrowing.liquidationBonus += oldBorrowing.liquidationBonus;\n        newBorrowing.feesOwed += oldBorrowing.feesOwed;\n        // oldBorrowing.dailyRateCollateralBalance is 0\n        newBorrowing.dailyRateCollateralBalance +=\n            (collateralAmt - minPayment) *\n            Constants.COLLATERAL_BALANCE_PRECISION;\n        //newBorrowing.accLoanRatePerSeconds = oldBorrowing.accLoanRatePerSeconds;\n        _pay(oldBorrowing.holdToken, msg.sender, VAULT_ADDRESS, collateralAmt + feesDebt);\n        emit TakeOverDebt(oldBorrowing.borrower, msg.sender, borrowingKey, newBorrowingKey);\n    }\n\n    /**\n     * @notice Borrow function allows a user to borrow tokens by providing collateral and taking out loans.\n     * The trader opens a long position by borrowing the liquidity of Uniswap V3 and extracting it into a pair of tokens,\n     * one of which will be swapped into a desired(holdToken).The tokens will be kept in storage until the position is closed.\n     * The margin is calculated on the basis that liquidity must be restored with any price movement.\n     * The time the position is held is paid by the trader.\n     * @dev Emits a Borrow event upon successful borrowing.\n     * @param params The BorrowParams struct containing the necessary parameters for borrowing.\n     * @param deadline The deadline timestamp after which the transaction is considered invalid.\n     */\n    function borrow(\n        BorrowParams calldata params,\n        uint256 deadline\n    ) external nonReentrant checkDeadline(deadline) {\n        // Precalculating borrowing details and storing them in cache\n        BorrowCache memory cache = _precalculateBorrowing(params);\n        // Initializing borrowing variables and obtaining borrowing key\n        (\n            uint256 feesDebt,\n            bytes32 borrowingKey,\n            BorrowingInfo storage borrowing\n        ) = _initOrUpdateBorrowing(params.saleToken, params.holdToken, cache.accLoanRatePerSeconds);\n        // Adding borrowing key and loans information to storage\n        _addKeysAndLoansInfo(borrowing.borrowedAmount > 0, borrowingKey, params.loans);\n        // Calculating liquidation bonus based on hold token, borrowed amount, and number of used loans\n        uint256 liquidationBonus = getLiquidationBonus(\n            params.holdToken,\n            cache.borrowedAmount,\n            params.loans.length\n        );\n        // Updating borrowing details\n        borrowing.borrowedAmount += cache.borrowedAmount;\n        borrowing.liquidationBonus += liquidationBonus;\n        borrowing.dailyRateCollateralBalance +=\n            cache.dailyRateCollateral *\n            Constants.COLLATERAL_BALANCE_PRECISION;\n        // Checking if borrowing collateral exceeds the maximum allowed collateral\n        uint256 borrowingCollateral = cache.borrowedAmount - cache.holdTokenBalance;\n        (borrowingCollateral > params.maxCollateral).revertError(\n            ErrLib.ErrorCode.TOO_BIG_COLLATERAL\n        );\n\n        // Transfer the required tokens to the VAULT_ADDRESS for collateral and holdTokenBalance\n        _pay(\n            params.holdToken,\n            msg.sender,\n            VAULT_ADDRESS,\n            borrowingCollateral + liquidationBonus + cache.dailyRateCollateral + feesDebt\n        );\n        // Transferring holdTokenBalance to VAULT_ADDRESS\n        _pay(params.holdToken, address(this), VAULT_ADDRESS, cache.holdTokenBalance);\n        // Emit the Borrow event with the borrower, borrowing key, and borrowed amount\n        emit Borrow(\n            msg.sender,\n            borrowingKey,\n            cache.borrowedAmount,\n            borrowingCollateral,\n            liquidationBonus,\n            cache.dailyRateCollateral\n        );\n    }\n\n    /**\n     * @notice This function is used to repay a loan.\n     * The position is closed either by the trader or by the liquidator if the trader has not paid for holding the position\n     * and the moment of liquidation has arrived.The positions borrowed from liquidation providers are restored from the held\n     * token and the remainder is sent to the caller.In the event of liquidation, the liquidity provider\n     * whose liquidity is present in the traders position can use the emergency mode and withdraw their liquidity.In this case,\n     * he will receive hold tokens and liquidity will not be restored in the uniswap pool.\n     * @param params The repayment parameters including\n     *  activation of the emergency liquidity restoration mode (available only to the lender)\n     *  internal swap pool fee,\n     *  external swap parameters,\n     *  borrowing key,\n     *  swap slippage allowance.\n     * @param deadline The deadline by which the repayment must be made.\n     */\n    function repay(\n        RepayParams calldata params,\n        uint256 deadline\n    ) external nonReentrant checkDeadline(deadline) {\n        BorrowingInfo memory borrowing = borrowingsInfo[params.borrowingKey];\n        // Check if the borrowing key is valid\n        (borrowing.borrowedAmount == 0).revertError(ErrLib.ErrorCode.INVALID_BORROWING_KEY);\n\n        bool zeroForSaleToken = borrowing.saleToken < borrowing.holdToken;\n        uint256 liquidationBonus = borrowing.liquidationBonus;\n        int256 collateralBalance;\n        // Update token rate information and get holdTokenRateInfo storage reference\n        (, TokenInfo storage holdTokenRateInfo) = _updateTokenRateInfo(\n            borrowing.saleToken,\n            borrowing.holdToken\n        );\n        {\n            // Calculate collateral balance and validate caller\n            uint256 accLoanRatePerSeconds = holdTokenRateInfo.accLoanRatePerSeconds;\n            uint256 currentFees;\n            (collateralBalance, currentFees) = _calculateCollateralBalance(\n                borrowing.borrowedAmount,\n                borrowing.accLoanRatePerSeconds,\n                borrowing.dailyRateCollateralBalance,\n                accLoanRatePerSeconds\n            );\n\n            (msg.sender != borrowing.borrower && collateralBalance >= 0).revertError(\n                ErrLib.ErrorCode.INVALID_CALLER\n            );\n\n            // Calculate liquidation bonus and adjust fees owed\n\n            if (\n                collateralBalance > 0 &&\n                (currentFees + borrowing.feesOwed) / Constants.COLLATERAL_BALANCE_PRECISION >\n                Constants.MINIMUM_AMOUNT\n            ) {\n                liquidationBonus +=\n                    uint256(collateralBalance) /\n                    Constants.COLLATERAL_BALANCE_PRECISION;\n            } else {\n                currentFees = borrowing.dailyRateCollateralBalance;\n            }\n\n            // Calculate platform fees and adjust fees owed\n            borrowing.feesOwed += _pickUpPlatformFees(borrowing.holdToken, currentFees);\n        }\n        // Check if it's an emergency repayment\n        if (params.isEmergency) {\n            (collateralBalance >= 0).revertError(ErrLib.ErrorCode.FORBIDDEN);\n            (\n                uint256 removedAmt,\n                uint256 feesAmt,\n                bool completeRepayment\n            ) = _calculateEmergencyLoanClosure(\n                    zeroForSaleToken,\n                    params.borrowingKey,\n                    borrowing.feesOwed,\n                    borrowing.borrowedAmount\n                );\n            (removedAmt == 0).revertError(ErrLib.ErrorCode.LIQUIDITY_IS_ZERO);\n            // prevent overspent\n            // Subtract the removed amount and fees from borrowedAmount and feesOwed\n            borrowing.borrowedAmount -= removedAmt;\n            borrowing.feesOwed -= feesAmt;\n            feesAmt /= Constants.COLLATERAL_BALANCE_PRECISION;\n            // Deduct the removed amount from totalBorrowed\n            holdTokenRateInfo.totalBorrowed -= removedAmt;\n            // If loansInfoLength is 0, remove the borrowing key from storage and get the liquidation bonus\n            if (completeRepayment) {\n                LoanInfo[] memory empty;\n                _removeKeysAndClearStorage(borrowing.borrower, params.borrowingKey, empty);\n                feesAmt += liquidationBonus;\n            } else {\n                BorrowingInfo storage borrowingStorage = borrowingsInfo[params.borrowingKey];\n                borrowingStorage.dailyRateCollateralBalance = 0;\n                borrowingStorage.feesOwed = borrowing.feesOwed;\n                borrowingStorage.borrowedAmount = borrowing.borrowedAmount;\n                // Calculate the updated accLoanRatePerSeconds\n                borrowingStorage.accLoanRatePerSeconds =\n                    holdTokenRateInfo.accLoanRatePerSeconds -\n                    FullMath.mulDiv(\n                        uint256(-collateralBalance),\n                        Constants.BP,\n                        borrowing.borrowedAmount // new amount\n                    );\n            }\n            // Transfer removedAmt + feesAmt to msg.sender and emit EmergencyLoanClosure event\n            Vault(VAULT_ADDRESS).transferToken(\n                borrowing.holdToken,\n                msg.sender,\n                removedAmt + feesAmt\n            );\n            emit EmergencyLoanClosure(borrowing.borrower, msg.sender, params.borrowingKey);\n        } else {\n            // Deduct borrowedAmount from totalBorrowed\n            holdTokenRateInfo.totalBorrowed -= borrowing.borrowedAmount;\n\n            // Transfer the borrowed amount and liquidation bonus from the VAULT to this contract\n            Vault(VAULT_ADDRESS).transferToken(\n                borrowing.holdToken,\n                address(this),\n                borrowing.borrowedAmount + liquidationBonus\n            );\n            // Restore liquidity using the borrowed amount and pay a daily rate fee\n            LoanInfo[] memory loans = loansInfo[params.borrowingKey];\n            _maxApproveIfNecessary(\n                borrowing.holdToken,\n                address(underlyingPositionManager),\n                type(uint128).max\n            );\n            _maxApproveIfNecessary(\n                borrowing.saleToken,\n                address(underlyingPositionManager),\n                type(uint128).max\n            );\n\n            _restoreLiquidity(\n                RestoreLiquidityParams({\n                    zeroForSaleToken: zeroForSaleToken,\n                    fee: params.internalSwapPoolfee,\n                    slippageBP1000: params.swapSlippageBP1000,\n                    totalfeesOwed: borrowing.feesOwed,\n                    totalBorrowedAmount: borrowing.borrowedAmount\n                }),\n                params.externalSwap,\n                loans\n            );\n            // Get the remaining balance of saleToken and holdToken\n            (uint256 saleTokenBalance, uint256 holdTokenBalance) = _getPairBalance(\n                borrowing.saleToken,\n                borrowing.holdToken\n            );\n            // Remove borrowing key from related data structures\n            _removeKeysAndClearStorage(borrowing.borrower, params.borrowingKey, loans);\n            // Pay a profit to a msg.sender\n            _pay(borrowing.holdToken, address(this), msg.sender, holdTokenBalance);\n            _pay(borrowing.saleToken, address(this), msg.sender, saleTokenBalance);\n\n            emit Repay(borrowing.borrower, msg.sender, params.borrowingKey);\n        }\n    }\n\n    /**\n     * @dev Calculates the liquidation bonus for a given token, borrowed amount, and times factor.\n     * @param token The address of the token.\n     * @param borrowedAmount The amount of tokens borrowed.\n     * @param times The times factor to apply to the liquidation bonus calculation.\n     * @return liquidationBonus The calculated liquidation bonus.\n     */\n    function getLiquidationBonus(\n        address token,\n        uint256 borrowedAmount,\n        uint256 times\n    ) public view returns (uint256 liquidationBonus) {\n        // Retrieve liquidation bonus for the given token\n        Liquidation memory liq = liquidationBonusForToken[token];\n\n        if (liq.bonusBP == 0) {\n            // If there is no specific bonus for the token\n            // Use default bonus\n            liq.minBonusAmount = Constants.MINIMUM_AMOUNT;\n            liq.bonusBP = dafaultLiquidationBonusBP;\n        }\n        liquidationBonus = (borrowedAmount * liq.bonusBP) / Constants.BP;\n\n        if (liquidationBonus < liq.minBonusAmount) {\n            liquidationBonus = liq.minBonusAmount;\n        }\n        l"
    }
  ]
}