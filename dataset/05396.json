{
  "Title": "[H-04] Underflow could happened when calculating Uniswap V3 position's fee growth and can cause operations to revert",
  "Content": "\nWhen operations need to calculate Uniswap V3 position's fee growth, it used similar function implemented by [uniswap v3](https://github.com/Uniswap/v3-periphery/blob/main/contracts/libraries/PositionValue.sol#L145-L166). However, according to this known issue : <https://github.com/Uniswap/v3-core/issues/573>.  The contract is implicitly relies on underflow/overflow when calculating the fee growth, if underflow is prevented, some operations that rely on fee growth will revert.\n\n### Proof of Concept\n\nIt can be observed that current implementation of  `getFeeGrowthInside` not allow underflow/overflow to happen when calculating `feeGrowthInside0X128` and `feeGrowthInside1X128`, because the contract used solidity 0.8.23.\n\n<https://github.com/code-423n4/2023-12-particle/blob/main/contracts/libraries/Base.sol#L318-L342>\n\n<details>\n\n```solidity\n    function getFeeGrowthInside(\n        address token0,\n        address token1,\n        uint24 fee,\n        int24 tickLower,\n        int24 tickUpper\n    ) internal view returns (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) {\n        IUniswapV3Pool pool = IUniswapV3Pool(UNI_FACTORY.getPool(token0, token1, fee));\n        (, int24 tickCurrent, , , , , ) = pool.slot0();\n        (, , uint256 lowerFeeGrowthOutside0X128, uint256 lowerFeeGrowthOutside1X128, , , , ) = pool.ticks(tickLower);\n        (, , uint256 upperFeeGrowthOutside0X128, uint256 upperFeeGrowthOutside1X128, , , , ) = pool.ticks(tickUpper);\n\n        if (tickCurrent < tickLower) {\n            feeGrowthInside0X128 = lowerFeeGrowthOutside0X128 - upperFeeGrowthOutside0X128;\n            feeGrowthInside1X128 = lowerFeeGrowthOutside1X128 - upperFeeGrowthOutside1X128;\n        } else if (tickCurrent < tickUpper) {\n            uint256 feeGrowthGlobal0X128 = pool.feeGrowthGlobal0X128();\n            uint256 feeGrowthGlobal1X128 = pool.feeGrowthGlobal1X128();\n            feeGrowthInside0X128 = feeGrowthGlobal0X128 - lowerFeeGrowthOutside0X128 - upperFeeGrowthOutside0X128;\n            feeGrowthInside1X128 = feeGrowthGlobal1X128 - lowerFeeGrowthOutside1X128 - upperFeeGrowthOutside1X128;\n        } else {\n            feeGrowthInside0X128 = upperFeeGrowthOutside0X128 - lowerFeeGrowthOutside0X128;\n            feeGrowthInside1X128 = upperFeeGrowthOutside1X128 - lowerFeeGrowthOutside1X128;\n        }\n    }\n```\n</details>\n\nThis could impact crucial operation that rely on this call, such as liquidation, could revert unexpectedly. This behavior is quite often especially for pools that use lower fee.\n\nCoded PoC :\n\nAdd the following test to `/test/OpenPosition.t.sol` :\n\n<details>\n\n```solidity\n  function testLiquidationRevert() public {\n        address LIQUIDATOR = payable(address(0x7777));\n        uint128 REPAY_LIQUIDITY_PORTION = 1000;\n        _setupLowerOutOfRange();\n        testBaseOpenLongPosition();\n        // get lien info\n        (, uint128 liquidityInside, , , , , , ) = particlePositionManager.liens(\n            keccak256(abi.encodePacked(SWAPPER, uint96(0)))\n        );\n        // start reclaim\n        vm.startPrank(LP);\n        vm.warp(block.timestamp + 1);\n        particlePositionManager.reclaimLiquidity(_tokenId);\n        vm.stopPrank();\n        // add back liquidity requirement\n        vm.warp(block.timestamp + 7 days);\n        IUniswapV3Pool _pool = IUniswapV3Pool(uniswapV3Factory.getPool(address(USDC), address(WETH), FEE));\n        (uint160 currSqrtRatioX96, , , , , , ) = _pool.slot0();\n        (uint256 amount0ToReturn, uint256 amount1ToReturn) = LiquidityAmounts.getAmountsForLiquidity(\n            currSqrtRatioX96,\n            _sqrtRatioAX96,\n            _sqrtRatioBX96,\n            liquidityInside\n        );\n        (uint256 usdCollateral, uint256 ethCollateral) = particleInfoReader.getRequiredCollateral(liquidityInside, _tickLower, _tickUpper);\n\n        // get swap data\n        uint160 currentPrice = particleInfoReader.getCurrentPrice(address(USDC), address(WETH), FEE);\n        uint256 amountSwap = ethCollateral - amount1ToReturn;\n\n        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({\n            tokenIn: address(WETH),\n            tokenOut: address(USDC),\n            fee: FEE,\n            recipient: address(particlePositionManager),\n            deadline: block.timestamp,\n            amountIn: amountSwap,\n            amountOutMinimum: 0,\n            sqrtPriceLimitX96: currentPrice + currentPrice / SLIPPAGE_FACTOR\n        });\n        bytes memory data = abi.encodeWithSelector(ISwapRouter.exactInputSingle.selector, params);\n        // liquidate position\n        vm.startPrank(LIQUIDATOR);\n        vm.expectRevert(abi.encodeWithSelector(Errors.InsufficientRepay.selector));\n        particlePositionManager.liquidatePosition(\n            DataStruct.ClosePositionParams({lienId: uint96(0), amountSwap: amountSwap, data: data}),\n            SWAPPER\n        );\n        vm.stopPrank();\n    }\n```\n\n</details>\n\nAlso modify `FEE` inside `/test/Base.t.sol` to `500` :\n\n```diff\ncontract ParticlePositionManagerTestBase is Test {\n    using Lien for mapping(bytes32 => Lien.Info);\n\n    IERC20 public constant WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    IERC20 public constant USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n    IERC20 public constant DAI = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);\n    uint256 public constant USDC_AMOUNT = 50000000 * 1e6;\n    uint256 public constant DAI_AMOUNT = 50000000 * 1e18;\n    uint256 public constant WETH_AMOUNT = 50000 * 1e18;\n    address payable public constant ADMIN = payable(address(0x4269));\n    address payable public constant LP = payable(address(0x1001));\n    address payable public constant SWAPPER = payable(address(0x1002));\n    address payable public constant WHALE = payable(address(0x6666));\n    IQuoter public constant QUOTER = IQuoter(0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6);\n    int24 public constant TICK_SPACING = 60;\n    uint256 public constant BASIS_POINT = 1_000_000;\n-    uint24 public constant FEE = 3000; // uniswap swap fee\n+    uint24 public constant FEE = 500; // uniswap swap fee\n   ..\n}\n```\n\nRun the test :\n\n```shell\nforge test --fork-url $MAINNET_RPC_URL --fork-block-number 18750931 --match-contract OpenPositionTest --match-test testRevertUnderflow -vvvv\n```\n\nLog output :\n\n![image](https://github.com/said017/audits/assets/19762585/8cd12d84-a8f2-4d06-b1cc-be550bca18bb)\n\nIt can be observed that the liquidation revert due to the underflow.\n\n### Recommended Mitigation Steps\n\nUse unchecked when calculating `feeGrowthInside0X128` and `feeGrowthInside1X128`.\n\n**[wukong-particle (Particle) confirmed and commented](https://github.com/code-423n4/2023-12-particle-findings/issues/10#issuecomment-1868181113):**\n > Oh this one is great. Will update the code to uncheck `feeGrowthInside0X128` and `feeGrowthInside1X128` calculations. \n\n\n***\n\n \n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-12-particle",
  "Code": [
    {
      "filename": "contracts/libraries/PositionValue.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.6.8 <0.8.0;\n\nimport '@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol';\nimport '@uniswap/v3-core/contracts/libraries/FixedPoint128.sol';\nimport '@uniswap/v3-core/contracts/libraries/TickMath.sol';\nimport '@uniswap/v3-core/contracts/libraries/Tick.sol';\nimport '../interfaces/INonfungiblePositionManager.sol';\nimport './LiquidityAmounts.sol';\nimport './PoolAddress.sol';\nimport './PositionKey.sol';\n\n/// @title Returns information about the token value held in a Uniswap V3 NFT\nlibrary PositionValue {\n    /// @notice Returns the total amounts of token0 and token1, i.e. the sum of fees and principal\n    /// that a given nonfungible position manager token is worth\n    /// @param positionManager The Uniswap V3 NonfungiblePositionManager\n    /// @param tokenId The tokenId of the token for which to get the total value\n    /// @param sqrtRatioX96 The square root price X96 for which to calculate the principal amounts\n    /// @return amount0 The total amount of token0 including principal and fees\n    /// @return amount1 The total amount of token1 including principal and fees\n    function total(\n        INonfungiblePositionManager positionManager,\n        uint256 tokenId,\n        uint160 sqrtRatioX96\n    ) internal view returns (uint256 amount0, uint256 amount1) {\n        (uint256 amount0Principal, uint256 amount1Principal) = principal(positionManager, tokenId, sqrtRatioX96);\n        (uint256 amount0Fee, uint256 amount1Fee) = fees(positionManager, tokenId);\n        return (amount0Principal + amount0Fee, amount1Principal + amount1Fee);\n    }\n\n    /// @notice Calculates the principal (currently acting as liquidity) owed to the token owner in the event\n    /// that the position is burned\n    /// @param positionManager The Uniswap V3 NonfungiblePositionManager\n    /// @param tokenId The tokenId of the token for which to get the total principal owed\n    /// @param sqrtRatioX96 The square root price X96 for which to calculate the principal amounts\n    /// @return amount0 The principal amount of token0\n    /// @return amount1 The principal amount of token1\n    function principal(\n        INonfungiblePositionManager positionManager,\n        uint256 tokenId,\n        uint160 sqrtRatioX96\n    ) internal view returns (uint256 amount0, uint256 amount1) {\n        (, , , , , int24 tickLower, int24 tickUpper, uint128 liquidity, , , , ) = positionManager.positions(tokenId);\n\n        return\n            LiquidityAmounts.getAmountsForLiquidity(\n                sqrtRatioX96,\n                TickMath.getSqrtRatioAtTick(tickLower),\n                TickMath.getSqrtRatioAtTick(tickUpper),\n                liquidity\n            );\n    }\n\n    struct FeeParams {\n        address token0;\n        address token1;\n        uint24 fee;\n        int24 tickLower;\n        int24 tickUpper;\n        uint128 liquidity;\n        uint256 positionFeeGrowthInside0LastX128;\n        uint256 positionFeeGrowthInside1LastX128;\n        uint256 tokensOwed0;\n        uint256 tokensOwed1;\n    }\n\n    /// @notice Calculates the total fees owed to the token owner\n    /// @param positionManager The Uniswap V3 NonfungiblePositionManager\n    /// @param tokenId The tokenId of the token for which to get the total fees owed\n    /// @return amount0 The amount of fees owed in token0\n    /// @return amount1 The amount of fees owed in token1\n    function fees(INonfungiblePositionManager positionManager, uint256 tokenId)\n        internal\n        view\n        returns (uint256 amount0, uint256 amount1)\n    {\n        (\n            ,\n            ,\n            address token0,\n            address token1,\n            uint24 fee,\n            int24 tickLower,\n            int24 tickUpper,\n            uint128 liquidity,\n            uint256 positionFeeGrowthInside0LastX128,\n            uint256 positionFeeGrowthInside1LastX128,\n            uint256 tokensOwed0,\n            uint256 tokensOwed1\n        ) = positionManager.positions(tokenId);\n\n        return\n            _fees(\n                positionManager,\n                FeeParams({\n                    token0: token0,\n                    token1: token1,\n                    fee: fee,\n                    tickLower: tickLower,\n                    tickUpper: tickUpper,\n                    liquidity: liquidity,\n                    positionFeeGrowthInside0LastX128: positionFeeGrowthInside0LastX128,\n                    positionFeeGrowthInside1LastX128: positionFeeGrowthInside1LastX128,\n                    tokensOwed0: tokensOwed0,\n                    tokensOwed1: tokensOwed1\n                })\n            );\n    }\n\n    function _fees(INonfungiblePositionManager positionManager, FeeParams memory feeParams)\n        private\n        view\n        returns (uint256 amount0, uint256 amount1)\n    {\n        (uint256 poolFeeGrowthInside0LastX128, uint256 poolFeeGrowthInside1LastX128) =\n            _getFeeGrowthInside(\n                IUniswapV3Pool(\n                    PoolAddress.computeAddress(\n                        positionManager.factory(),\n                        PoolAddress.PoolKey({token0: feeParams.token0, token1: feeParams.token1, fee: feeParams.fee})\n                    )\n                ),\n                feeParams.tickLower,\n                feeParams.tickUpper\n            );\n\n        amount0 =\n            FullMath.mulDiv(\n                poolFeeGrowthInside0LastX128 - feeParams.positionFeeGrowthInside0LastX128,\n                feeParams.liquidity,\n                FixedPoint128.Q128\n            ) +\n            feeParams.tokensOwed0;\n\n        amount1 =\n            FullMath.mulDiv(\n                poolFeeGrowthInside1LastX128 - feeParams.positionFeeGrowthInside1LastX128,\n                feeParams.liquidity,\n                FixedPoint128.Q128\n            ) +\n            feeParams.tokensOwed1;\n    }\n\n    function _getFeeGrowthInside(\n        IUniswapV3Pool pool,\n        int24 tickLower,\n        int24 tickUpper\n    ) private view returns (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) {\n        (, int24 tickCurrent, , , , , ) = pool.slot0();\n        (, , uint256 lowerFeeGrowthOutside0X128, uint256 lowerFeeGrowthOutside1X128, , , , ) = pool.ticks(tickLower);\n        (, , uint256 upperFeeGrowthOutside0X128, uint256 upperFeeGrowthOutside1X128, , , , ) = pool.ticks(tickUpper);\n\n        if (tickCurrent < tickLower) {\n            feeGrowthInside0X128 = lowerFeeGrowthOutside0X128 - upperFeeGrowthOutside0X128;\n            feeGrowthInside1X128 = lowerFeeGrowthOutside1X128 - upperFeeGrowthOutside1X128;\n        } else if (tickCurrent < tickUpper) {\n            uint256 feeGrowthGlobal0X128 = pool.feeGrowthGlobal0X128();\n            uint256 feeGrowthGlobal1X128 = pool.feeGrowthGlobal1X128();\n            feeGrowthInside0X128 = feeGrowthGlobal0X128 - lowerFeeGrowthOutside0X128 - upperFeeGrowthOutside0X128;\n            feeGrowthInside1X128 = feeGrowthGlobal1X128 - lowerFeeGrowthOutside1X128 - upperFeeGrowthOutside1X128;\n        } else {\n            feeGrowthInside0X128 = upperFeeGrowthOutside0X128 - lowerFeeGrowthOutside0X128;\n            feeGrowthInside1X128 = upperFeeGrowthOutside1X128 - lowerFeeGrowthOutside1X128;\n        }\n    }\n}"
    },
    {
      "filename": "contracts/libraries/Base.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {IERC20} from \"../../lib/openzeppelin-contracts/contracts/interfaces/IERC20.sol\";\nimport {FixedPoint128} from \"../../lib/v3-core/contracts/libraries/FixedPoint128.sol\";\nimport {IUniswapV3Pool} from \"../../lib/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport {IUniswapV3Factory} from \"../../lib/v3-core/contracts/interfaces/IUniswapV3Factory.sol\";\nimport {TransferHelper} from \"../../lib/v3-periphery/contracts/libraries/TransferHelper.sol\";\n\nimport {INonfungiblePositionManager} from \"../interfaces/INonfungiblePositionManager.sol\";\nimport {Errors} from \"./Errors.sol\";\nimport {FullMath} from \"./FullMath.sol\";\nimport {TickMath} from \"./TickMath.sol\";\nimport {LiquidityAmounts} from \"./LiquidityAmounts.sol\";\nimport {DataStruct, DataCache} from \"../libraries/Structs.sol\";\n\n/// @title Base Library\n/// @notice Contains internal helper functions for all contracts\nlibrary Base {\n    // solhint-disable private-vars-leading-underscore\n    address internal constant UNI_POSITION_MANAGER_ADDR = 0xC36442b4a4522E871399CD717aBDD847Ab11FE88;\n    uint256 internal constant BASIS_POINT = 1_000_000;\n\n    INonfungiblePositionManager internal constant UNI_POSITION_MANAGER =\n        INonfungiblePositionManager(UNI_POSITION_MANAGER_ADDR);\n    IUniswapV3Factory internal constant UNI_FACTORY = IUniswapV3Factory(0x1F98431c8aD98523631AE4a59f267346ea31F984);\n\n    // solhint-enable private-vars-leading-underscore\n\n    /**\n     * @notice Swap at most `amountFrom` of `tokenFrom` for at least `amountToMinimum` of `tokenTo`\n     * @dev Caller must check for non-reentrancy and proper amount is deposited in\n     * @param tokenFrom address of token to swap from\n     * @param tokenTo address of token to swap to\n     * @param amountFrom amount of tokenFrom to swap\n     * @param amountToMinimum minimum amount of tokenTo to receive\n     * @param dexAggregator address of DEX aggregator to perform swapping\n     * @param data calldata bytes to pass into DEX aggregator to perform swapping\n     * @return amountSpent amount of tokenFrom spent\n     * @return amountReceived amount of tokenTo received\n     */\n    function swap(\n        address tokenFrom,\n        address tokenTo,\n        uint256 amountFrom,\n        uint256 amountToMinimum,\n        address dexAggregator,\n        bytes calldata data\n    ) internal returns (uint256 amountSpent, uint256 amountReceived) {\n        uint256 balanceFromBefore = IERC20(tokenFrom).balanceOf(address(this));\n        uint256 balanceToBefore = IERC20(tokenTo).balanceOf(address(this));\n\n        if (amountFrom > 0) {\n            ///@dev only allow amountFrom of tokenFrom to be spent by the DEX aggregator\n            TransferHelper.safeApprove(tokenFrom, dexAggregator, amountFrom);\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = dexAggregator.call(data);\n            if (!success) revert Errors.SwapFailed();\n            TransferHelper.safeApprove(tokenFrom, dexAggregator, 0);\n        }\n\n        amountSpent = balanceFromBefore - IERC20(tokenFrom).balanceOf(address(this));\n        amountReceived = IERC20(tokenTo).balanceOf(address(this)) - balanceToBefore;\n\n        if (amountReceived < amountToMinimum) revert Errors.InsufficientSwap();\n    }\n\n    /**\n     * @notice Helper function to refund a token\n     * @param recipient the address to receive the refund\n     * @param token address of token to potentially refund\n     * @param amountExpected amount of token0 expected to spend\n     * @param amountActual amount of token0 actually spent\n     */\n    function refund(address recipient, address token, uint256 amountExpected, uint256 amountActual) internal {\n        if (amountExpected > amountActual) {\n            TransferHelper.safeTransfer(token, recipient, amountExpected - amountActual);\n        }\n    }\n\n    /**\n     * @notice Helper function to refund a token, with additional check that amountActual must not exceed amountExpected\n     * @param recipient the address to receive the refund\n     * @param token address of token to potentially refund\n     * @param amountExpected amount of token0 expected to spend\n     * @param amountActual amount of token0 actually spent\n     */\n    function refundWithCheck(address recipient, address token, uint256 amountExpected, uint256 amountActual) internal {\n        if (amountActual > amountExpected) revert Errors.OverRefund();\n        refund(recipient, token, amountExpected, amountActual);\n    }\n\n    /**\n     * @notice Helper function to prepare data for leveraged swap\n     * @param tokenId tokenId of the liquidity position NFT\n     * @param liquidity amount of liquidity to borrow out\n     * @param zeroForOne direction of the swap\n     * @return tokenFrom token to swap from\n     * @return tokenTo token to swap to\n     * @return feeGrowthInside0LastX128 the current fee growth of the aggregate position for token0\n     * @return feeGrowthInside1LastX128 the current fee growth of the aggregate position for token1\n     * @return collateralFrom amount of `tokenFrom` that `liquidity` concentrates to at its end\n     * @return collateralTo amount of `tokenTo` that `liquidity` concentrate to at its end\n     */\n    function prepareLeverage(\n        uint256 tokenId,\n        uint128 liquidity,\n        bool zeroForOne\n    )\n        internal\n        view\n        returns (\n            address tokenFrom,\n            address tokenTo,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint256 collateralFrom,\n            uint256 collateralTo\n        )\n    {\n        int24 tickLower;\n        int24 tickUpper;\n        (\n            ,\n            ,\n            tokenFrom,\n            tokenTo,\n            ,\n            tickLower,\n            tickUpper,\n            ,\n            feeGrowthInside0LastX128,\n            feeGrowthInside1LastX128,\n            ,\n\n        ) = UNI_POSITION_MANAGER.positions(tokenId);\n\n        (collateralFrom, collateralTo) = getRequiredCollateral(liquidity, tickLower, tickUpper);\n        if (!zeroForOne) {\n            (tokenFrom, tokenTo) = (tokenTo, tokenFrom);\n            (collateralFrom, collateralTo) = (collateralTo, collateralFrom);\n        }\n    }\n\n    /**\n     * @notice Calculates the amount of collateral needed when borrowing liquidity from a position\n     * @param liquidity amount of liquidity to borrow\n     * @param tickLower lower tick of the position\n     * @param tickUpper upper tick of the position\n     * @return amount0 amount that the liquidity concentrates to at tickLower\n     * @return amount1 amount that the liquidity concentrates to at tickHigher\n     */\n    function getRequiredCollateral(\n        uint128 liquidity,\n        int24 tickLower,\n        int24 tickUpper\n    ) internal pure returns (uint256 amount0, uint256 amount1) {\n        uint160 sqrtRatioAX96 = TickMath.getSqrtRatioAtTick(tickLower);\n        uint160 sqrtRatioBX96 = TickMath.getSqrtRatioAtTick(tickUpper);\n        (amount0, amount1) = LiquidityAmounts.getAmountsForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\n    }\n\n    function getRequiredRepay(\n        uint128 liquidity,\n        uint256 tokenId\n    ) internal view returns (uint256 amount0, uint256 amount1) {\n        DataCache.RepayCache memory repayCache;\n        (\n            ,\n            ,\n            repayCache.token0,\n            repayCache.token1,\n            repayCache.fee,\n            repayCache.tickLower,\n            repayCache.tickUpper,\n            ,\n            ,\n            ,\n            ,\n\n        ) = UNI_POSITION_MANAGER.positions(tokenId);\n        IUniswapV3Pool pool = IUniswapV3Pool(UNI_FACTORY.getPool(repayCache.token0, repayCache.token1, repayCache.fee));\n        (repayCache.sqrtRatioX96, , , , , , ) = pool.slot0();\n        repayCache.sqrtRatioAX96 = TickMath.getSqrtRatioAtTick(repayCache.tickLower);\n        repayCache.sqrtRatioBX96 = TickMath.getSqrtRatioAtTick(repayCache.tickUpper);\n        (amount0, amount1) = LiquidityAmounts.getAmountsForLiquidity(\n            repayCache.sqrtRatioX96,\n            repayCache.sqrtRatioAX96,\n            repayCache.sqrtRatioBX96,\n            liquidity\n        );\n    }\n\n    /**\n     * @notice Get the current owed fees for a position\n     * @param params.tokenId tokenId of the liquidity position NFT\n     * @param params.liquidity amount of liquidity in the position\n     * @param params.feeGrowthInside0LastX128 the fee growth of the position for token0 as of the last fee update\n     * @param params.feeGrowthInside1LastX128 the fee growth of the position for token1 as of the last fee update\n     * @param params.token0PremiumPortion the portion of token0 premium locked in the lien\n     * @param params.token1PremiumPortion the portion of token1 premium locked in the lien\n     * @param zeroForOne direction of the swap\n     * @return tokenFrom  address of token to swap from at close position\n     * @return tokenTo address of token to swap to at close position\n     * @return tokenFromOwed amount owed to the liquidity provider for the token on the side of swap from\n     * @return tokenToOwed amount owed to the liquidity provider for the token on the side of swap to\n     * @return tokenFromPremium amount of premium for the token on the side of swap from\n     * @return tokenToPremium amount of premium for the token on the side of swap to\n     * @return collateralFrom amount of collateral for the token on the side of swap from\n     * @return collateralTo amount of collateral for the token on the side of swap to\n     */\n    function getOwedInfoConverted(\n        DataStruct.OwedInfoParams memory params,\n        bool zeroForOne\n    )\n        internal\n        view\n        returns (\n            address tokenFrom,\n            address tokenTo,\n            uint128 tokenFromOwed,\n            uint128 tokenToOwed,\n            uint128 tokenFromPremium,\n            uint128 tokenToPremium,\n            uint256 collateralFrom,\n            uint256 collateralTo\n        )\n    {\n        (\n            tokenFrom,\n            tokenTo,\n            tokenFromOwed,\n            tokenToOwed,\n            tokenFromPremium,\n            tokenToPremium,\n            collateralFrom,\n            collateralTo\n        ) = getOwedInfo(params);\n        if (zeroForOne) {\n            (tokenFrom, tokenTo) = (tokenTo, tokenFrom);\n            (tokenFromOwed, tokenToOwed) = (tokenToOwed, tokenFromOwed);\n            (tokenFromPremium, tokenToPremium) = (tokenToPremium, tokenFromPremium);\n            (collateralFrom, collateralTo) = (collateralTo, collateralFrom);\n        }\n    }\n\n    /**\n     * @notice Get the current owed fees for a position\n     * @param params.tokenId tokenId of the liquidity position NFT\n     * @param params.liquidity amount of liquidity in the position\n     * @param params.feeGrowthInside0LastX128 the fee growth of the position for token0 as of the last fee update\n     * @param params.feeGrowthInside1LastX128 the fee growth of the position for token1 as of the last fee update\n     * @param params.token0PremiumPortion the portion of token0 premium locked in the lien\n     * @param params.token1PremiumPortion the portion of token1 premium locked in the lien\n     * @return token0 address of token0\n     * @return token1 address of token1\n     * @return token0Owed amount of token0 owed to the liquidity provider\n     * @return token1Owed amount of token1 owed to the liquidity provider\n     * @return token0Premium amount of token0 premium locked in the lien\n     * @return token1Premium amount of token1 premium locked in the lien\n     * @return collateral0 amount of token0 required by the lp (if oneForZero)\n     * @return collateral1 amount of token1 required by the lp (if zeroForOne)\n     */\n    function getOwedInfo(\n        DataStruct.OwedInfoParams memory params\n    )\n        internal\n        view\n        returns (\n            address token0,\n            address token1,\n            uint128 token0Owed,\n            uint128 token1Owed,\n            uint128 token0Premium,\n            uint128 token1Premium,\n            uint256 collateral0,\n            uint256 collateral1\n        )\n    {\n        DataCache.OwedInfoCache memory cache;\n        (, , token0, token1, cache.fee, cache.tickLower, cache.tickUpper, , , , , ) = UNI_POSITION_MANAGER.positions(\n            params.tokenId\n        );\n        (cache.feeGrowthInside0X128, cache.feeGrowthInside1X128) = getFeeGrowthInside(\n            token0,\n            token1,\n            cache.fee,\n            cache.tickLower,\n            cache.tickUpper\n        );\n        (token0Owed, token1Owed) = getOwedFee(\n            cache.feeGrowthInside0X128,\n            cache.feeGrowthInside1X128,\n            params.feeGrowthInside0LastX128,\n            params.feeGrowthInside1LastX128,\n            params.liquidity\n        );\n        (collateral0, collateral1) = getRequiredCollateral(params.liquidity, cache.tickLower, cache.tickUpper);\n        (token0Premium, token1Premium) = getPremium(\n            collateral0,\n            collateral1,\n            params.token0PremiumPortion,\n            params.token1PremiumPortion\n        );\n    }\n\n    /**\n     * @notice Helper function to calculate the current feeGrothInside(0/1)X128 based on tickLower and tickUpper\n     * @dev feeGrowthInsideX128 calculation adopted from uniswap v3 periphery PositionValue\n     * @param token0 address of token0\n     * @param token1 address of token1\n     * @param fee fee level of the pool\n     * @param tickLower lower tick of the position\n     * @param tickUpper upper tick of the position\n     * @return feeGrowthInside0X128 the current fee growth of the position for token0\n     * @return feeGrowthInside1X128 the current fee growth of the position for token1\n     */\n    function getFeeGrowthInside(\n        address token0,\n        address token1,\n        uint24 fee,\n        int24 tickLower,\n        int24 tickUpper\n    ) internal view returns (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) {\n        IUniswapV3Pool pool = IUniswapV3Pool(UNI_FACTORY.getPool(token0, token1, fee));\n        (, int24 tickCurrent, , , , , ) = pool.slot0();\n        (, , uint256 lowerFeeGrowthOutside0X128, uint256 lowerFeeGrowthOutside1X128, , , , ) = pool.ticks(tickLower);\n        (, , uint256 upperFeeGrowthOutside0X128, uint256 upperFeeGrowthOutside1X128, , , , ) = pool.ticks(tickUpper);\n\n        if (tickCurrent < tickLower) {\n            feeGrowthInside0X128 = lowerFeeGrowthOutside0X128 - upperFeeGrowthOutside0X128;\n            feeGrowthInside1X128 = lowerFeeGrowthOutside1X128 - upperFeeGrowthOutside1X128;\n        } else if (tickCurrent < tickUpper) {\n            uint256 feeGrowthGlobal0X128 = pool.feeGrowthGlobal0X128();\n            uint256 feeGrowthGlobal1X128 = pool.feeGrowthGlobal1X128();\n            feeGrowthInside0X128 = feeGrowthGlobal0X128 - lowerFeeGrowthOutside0X128 - upperFeeGrowthOutside0X128;\n            feeGrowthInside1X128 = feeGrowthGlobal1X128 - lowerFeeGrowthOutside1X128 - upperFeeGrowthOutside1X128;\n        } else {\n            feeGrowthInside0X128 = upperFeeGrowthOutside0X128 - lowerFeeGrowthOutside0X128;\n            feeGrowthInside1X128 = upperFeeGrowthOutside1X128 - lowerFeeGrowthOutside1X128;\n        }\n    }\n\n    /**\n     * @notice Helper function to get the fee owed based on the current and last feeGrowthInside\n     * @param feeGrowthInside0X128 the current fee growth of the position for token0\n     * @param feeGrowthInside1X128 the current fee growth of the position for token1\n     * @param feeGrowthInside0LastX128 the fee growth of the position for token0 at the last borrow / fee collection\n     * @param feeGrowthInside1LastX128 the fee growth of the position for token1 at the last borrow / fee collection\n     * @param liquidity liquidity of the position\n     * @return token0Owed amount of token0 owed\n     * @return token1Owed amount of token1 owed\n     */\n    function getOwedFee(\n        uint256 feeGrowthInside0X128,\n        uint256 feeGrowthInside1X128,\n        uint256 feeGrowthInside0LastX128,\n        uint256 feeGrowthInside1LastX128,\n        uint128 liquidity\n    ) internal pure returns (uint128 token0Owed, uint128 token1Owed) {\n        if (feeGrowthInside0X128 > feeGrowthInside0LastX128) {\n            token0Owed = uint128(\n                FullMath.mulDiv(feeGrowthInside0X128 - feeGrowthInside0LastX128, liquidity, FixedPoint128.Q128)\n            );\n        }\n        if (feeGrowthInside1X128 > feeGrowthInside1LastX128) {\n            token1Owed = uint128(\n                FullMath.mulDiv(feeGrowthInside1X128 - feeGrowthInside1LastX128, liquidity, FixedPoint128.Q128)\n            );\n        }\n    }\n\n    /**\n     * @notice Helper function to get the premium amount based on the premium portion and collateral as base\n     * @param collateral0 the amount of collateral for token0\n     * @param collateral1 the amount of collateral for token1\n     * @param token0PremiumPortion the premium portion based on collateral0 and BASIS_POINT\n     * @param token1PremiumPortion the premium portion based on collateral1 and BASIS_POINT\n     * @return token0Premium amount of premium for token0\n     * @return token1Premium amount of premium for token1\n     */\n    function getPremium(\n        uint256 collateral0,\n        uint256 collateral1,\n        uint24 token0PremiumPortion,\n        uint24 token1PremiumPortion\n    ) internal pure returns (uint128 token0Premium, uint128 token1Premium) {\n        token0Premium = uint128((token0PremiumPortion * collateral0) / BASIS_POINT);\n        token1Premium = uint128((token1PremiumPortion * collateral1) / BASIS_POINT);\n    }\n\n    /**\n     * @notice Helper function to fit a non-overflow uint256 value to uint24\n     * @param value the uint256 value to fit\n     * @return result uint24 value that fits\n     */\n    function uint256ToUint24(uint256 value) internal pure returns (uint24 result) {\n        if (value > type(uint24).max) revert Errors.Overflow();\n        result = uint24(value);\n    }\n}"
    }
  ]
}