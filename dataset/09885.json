{
  "Title": "[M-11] Users are able to front-run bad debt settlements to avoid insurance costs",
  "Content": "# Lines of code\n\nhttps://github.com/code-423n4/2022-02-hubble/blob/main/contracts/InsuranceFund.sol#L71-L75\nhttps://github.com/code-423n4/2022-02-hubble/blob/main/contracts/InsuranceFund.sol#L62-L69\n\n\n# Vulnerability details\n\n## Impact\n\nA user is able to front-run the call to `seizeBadDebt()` in `InsuranceFund.sol` to avoid paying the insurance costs.\n\n`seizeBadDebt()` is called by `MarginAccount.settleBadDebt()` which is a public function. When this functions is called the transaction will appear in the mem pool.  A user may then call `InsuranceFund.withdraw()` to withdraw all of their shares. If they do this with a higher gas fee it will likely be processed before the `settleBadDebt()` transaction. In this way they will avoid incurring any cost from the assets being seized.\n\nThe impact is that users may gain their share of the insurance funding payments with minimal risk (minimal as there is a change the front-run will not succeed) of having to repay these costs.\n\n## Proof of Concept\n\n```\n    function withdraw(uint _shares) external {\n        settlePendingObligation();\n        require(pendingObligation == 0, \"IF.withdraw.pending_obligations\");\n        uint amount = balance() * _shares / totalSupply();\n        _burn(msg.sender, _shares);\n        vusd.safeTransfer(msg.sender, amount);\n        emit FundsWithdrawn(msg.sender, amount, block.timestamp);\n    }\n```\n\n```\n    function seizeBadDebt(uint amount) external onlyMarginAccount {\n        pendingObligation += amount;\n        emit BadDebtAccumulated(amount, block.timestamp);\n        settlePendingObligation();\n    }\n```\n\n## Recommended Mitigation Steps\n\nConsider making the withdrawals a two step process. The first step requests a withdrawal and marks the time. The second request processes the withdrawal but requires a period of time to elapse since the first step.\n\nTo avoid having users constantly having pending withdrawal, each withdrawal should have an expiry time and also a recharge time. The if the second step is not called within expiry amount of time it should be considered invalid. The first step must not be able to be called until recharge time has passed.\n\nAnother solution involves a design change where the insurance fund is slowly filled up over time without external deposits. However, this has the disadvantage that bad debts received early in the protocols life time may not have sufficient insurance capital to cover them.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-02-hubble-contest",
  "Code": [
    {
      "filename": "contracts/InsuranceFund.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.9;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport { VanillaGovernable } from \"./legos/Governable.sol\";\nimport { IRegistry } from \"./Interfaces.sol\";\n\ncontract InsuranceFund is VanillaGovernable, ERC20Upgradeable {\n    using SafeERC20 for IERC20;\n\n    uint8 constant DECIMALS = 6;\n    uint constant PRECISION = 10 ** DECIMALS;\n\n    IERC20 public vusd;\n    address public marginAccount;\n    uint public pendingObligation;\n\n    uint256[50] private __gap;\n\n    event FundsAdded(address indexed insurer, uint amount, uint timestamp);\n    event FundsWithdrawn(address indexed insurer, uint amount, uint timestamp);\n    event BadDebtAccumulated(uint amount, uint timestamp);\n\n    modifier onlyMarginAccount() {\n        require(msg.sender == address(marginAccount), \"IF.only_margin_account\");\n        _;\n    }\n\n    function initialize(address _governance) external {\n        __ERC20_init(\"Hubble-Insurance-Fund\", \"HIF\"); // has initializer modifier\n        _setGovernace(_governance);\n    }\n\n    function deposit(uint _amount) external {\n        settlePendingObligation();\n        // we want to protect new LPs, when the insurance fund is in deficit\n        require(pendingObligation == 0, \"IF.deposit.pending_obligations\");\n\n        uint _pool = balance();\n        uint _totalSupply = totalSupply();\n        if (_totalSupply == 0 && _pool > 0) { // trading fee accumulated while there were no IF LPs\n            vusd.safeTransfer(governance, _pool);\n            _pool = 0;\n        }\n\n        vusd.safeTransferFrom(msg.sender, address(this), _amount);\n        uint shares = 0;\n        if (_pool == 0) {\n            shares = _amount;\n        } else {\n            shares = _amount * _totalSupply / _pool;\n        }\n        _mint(msg.sender, shares);\n        emit FundsAdded(msg.sender, _amount, block.timestamp);\n    }\n\n    function withdraw(uint _shares) external {\n        settlePendingObligation();\n        require(pendingObligation == 0, \"IF.withdraw.pending_obligations\");\n        uint amount = balance() * _shares / totalSupply();\n        _burn(msg.sender, _shares);\n        vusd.safeTransfer(msg.sender, amount);\n        emit FundsWithdrawn(msg.sender, amount, block.timestamp);\n    }\n\n    function seizeBadDebt(uint amount) external onlyMarginAccount {\n        pendingObligation += amount;\n        emit BadDebtAccumulated(amount, block.timestamp);\n        settlePendingObligation();\n    }\n\n    function settlePendingObligation() public {\n        if (pendingObligation > 0) {\n            uint toTransfer = Math.min(vusd.balanceOf(address(this)), pendingObligation);\n            if (toTransfer > 0) {\n                pendingObligation -= toTransfer;\n                vusd.safeTransfer(marginAccount, toTransfer);\n            }\n        }\n    }\n\n    /* ****************** */\n    /*        View        */\n    /* ****************** */\n\n    /**\n    * @notice Just a vanity function\n    */\n    function pricePerShare() external view returns (uint) {\n        uint _totalSupply = totalSupply();\n        uint _balance = balance();\n        _balance -= Math.min(_balance, pendingObligation);\n        if (_totalSupply == 0 || _balance == 0) {\n            return PRECISION;\n        }\n        return _balance * PRECISION / _totalSupply;\n    }\n\n    function balance() public view returns (uint) {\n        return vusd.balanceOf(address(this));\n    }\n\n    function decimals() public pure override returns (uint8) {\n        return DECIMALS;\n    }\n\n    /* ****************** */\n    /*   onlyGovernance   */\n    /* ****************** */\n\n    function syncDeps(IRegistry _registry) public onlyGovernance {\n        vusd = IERC20(_registry.vusd());\n        marginAccount = _registry.marginAccount();\n    }\n}"
    },
    {
      "filename": "contracts/InsuranceFund.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.9;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport { VanillaGovernable } from \"./legos/Governable.sol\";\nimport { IRegistry } from \"./Interfaces.sol\";\n\ncontract InsuranceFund is VanillaGovernable, ERC20Upgradeable {\n    using SafeERC20 for IERC20;\n\n    uint8 constant DECIMALS = 6;\n    uint constant PRECISION = 10 ** DECIMALS;\n\n    IERC20 public vusd;\n    address public marginAccount;\n    uint public pendingObligation;\n\n    uint256[50] private __gap;\n\n    event FundsAdded(address indexed insurer, uint amount, uint timestamp);\n    event FundsWithdrawn(address indexed insurer, uint amount, uint timestamp);\n    event BadDebtAccumulated(uint amount, uint timestamp);\n\n    modifier onlyMarginAccount() {\n        require(msg.sender == address(marginAccount), \"IF.only_margin_account\");\n        _;\n    }\n\n    function initialize(address _governance) external {\n        __ERC20_init(\"Hubble-Insurance-Fund\", \"HIF\"); // has initializer modifier\n        _setGovernace(_governance);\n    }\n\n    function deposit(uint _amount) external {\n        settlePendingObligation();\n        // we want to protect new LPs, when the insurance fund is in deficit\n        require(pendingObligation == 0, \"IF.deposit.pending_obligations\");\n\n        uint _pool = balance();\n        uint _totalSupply = totalSupply();\n        if (_totalSupply == 0 && _pool > 0) { // trading fee accumulated while there were no IF LPs\n            vusd.safeTransfer(governance, _pool);\n            _pool = 0;\n        }\n\n        vusd.safeTransferFrom(msg.sender, address(this), _amount);\n        uint shares = 0;\n        if (_pool == 0) {\n            shares = _amount;\n        } else {\n            shares = _amount * _totalSupply / _pool;\n        }\n        _mint(msg.sender, shares);\n        emit FundsAdded(msg.sender, _amount, block.timestamp);\n    }\n\n    function withdraw(uint _shares) external {\n        settlePendingObligation();\n        require(pendingObligation == 0, \"IF.withdraw.pending_obligations\");\n        uint amount = balance() * _shares / totalSupply();\n        _burn(msg.sender, _shares);\n        vusd.safeTransfer(msg.sender, amount);\n        emit FundsWithdrawn(msg.sender, amount, block.timestamp);\n    }\n\n    function seizeBadDebt(uint amount) external onlyMarginAccount {\n        pendingObligation += amount;\n        emit BadDebtAccumulated(amount, block.timestamp);\n        settlePendingObligation();\n    }\n\n    function settlePendingObligation() public {\n        if (pendingObligation > 0) {\n            uint toTransfer = Math.min(vusd.balanceOf(address(this)), pendingObligation);\n            if (toTransfer > 0) {\n                pendingObligation -= toTransfer;\n                vusd.safeTransfer(marginAccount, toTransfer);\n            }\n        }\n    }\n\n    /* ****************** */\n    /*        View        */\n    /* ****************** */\n\n    /**\n    * @notice Just a vanity function\n    */\n    function pricePerShare() external view returns (uint) {\n        uint _totalSupply = totalSupply();\n        uint _balance = balance();\n        _balance -= Math.min(_balance, pendingObligation);\n        if (_totalSupply == 0 || _balance == 0) {\n            return PRECISION;\n        }\n        return _balance * PRECISION / _totalSupply;\n    }\n\n    function balance() public view returns (uint) {\n        return vusd.balanceOf(address(this));\n    }\n\n    function decimals() public pure override returns (uint8) {\n        return DECIMALS;\n    }\n\n    /* ****************** */\n    /*   onlyGovernance   */\n    /* ****************** */\n\n    function syncDeps(IRegistry _registry) public onlyGovernance {\n        vusd = IERC20(_registry.vusd());\n        marginAccount = _registry.marginAccount();\n    }\n}"
    }
  ]
}