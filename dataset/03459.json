{
  "Title": "[L04] Missing docstrings",
  "Content": "Some of the contracts and functions in the code base lack documentation. For example, [some functions](https://github.com/withtally/safeguard/blob/b2c63a9dfc4090be13320d999e7c6c1d842625d3/contracts/SafeGuard.sol#L61-L91) in the `SafeGuard` contract.\n\n\nAdditionally, some docstrings use informal language, such as the one [above the `setTimelock` function in the `SafeGuard` contract](https://github.com/withtally/safeguard/blob/b2c63a9dfc4090be13320d999e7c6c1d842625d3/contracts/SafeGuard.sol#L52).\n\n\nThis hinders reviewers’ understanding of the code’s intention, which is fundamental to correctly assess not only security but also correctness. Additionally, docstrings improve readability and ease maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned and the events emitted.\n\n\nConsider thoroughly documenting all functions (and their parameters) that are part of the contracts’ public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the [Ethereum Natural Specification Format](https://solidity.readthedocs.io/en/develop/natspec-format.html) (NatSpec).\n\n\n**Update:** *Partially fixed in [PR #10](https://github.com/withtally/safeguard/pull/10). Proper docstrings have been added to various functions throughout the code base. However, in addition to the current changes, consider making the following changes:*\n\n\n* *Add `description` as the `@param` in the docstring above `queueTransactionWithDescription` function*\n* *Add `@param` in the [docstring](https://github.com/withtally/safeguard/pull/10/files#diff-1a1b069c8e6fe7253364a4ea0bcb54c383a14c396e168bcc77bf16a29904ded8R76-R78) above the `createSafeGuard` function in `SafeGuardFactory` contract*\n* *Add `@return` in docstrings above the functions in `SafeGuardFactory` contract.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/SafeGuard.sol",
      "content": "pragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport \"./ITimelock.sol\";\nimport \"hardhat/console.sol\";\n\ncontract SafeGuard is AccessControlEnumerable {\n\n    // Request info event\n    event QueueTransactionWithDescription(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta, string description);\n\n    bytes32 public constant SAFEGUARD_ADMIN_ROLE = keccak256(\"SAFEGUARD_ADMIN_ROLE\");\n    bytes32 public constant PROPOSER_ROLE = keccak256(\"PROPOSER_ROLE\");\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\n    bytes32 public constant CANCELER_ROLE = keccak256(\"CANCELER_ROLE\");\n    bytes32 public constant CREATOR_ROLE = keccak256(\"CREATOR_ROLE\");\n\n    ///@dev The address of the Timelock\n    ITimelock public timelock;\n\n    /**\n     * @dev Initializes the contract with a given Timelock address and administrator address.\n     */\n    constructor (address _admin, bytes32[] memory roles, address[] memory rolesAssignees) {\n        require(roles.length == rolesAssignees.length, \"SafeGuard::constructor: roles assignment arity mismatch\");\n        // set roles administrator\n        _setRoleAdmin(SAFEGUARD_ADMIN_ROLE, SAFEGUARD_ADMIN_ROLE);\n        _setRoleAdmin(PROPOSER_ROLE, SAFEGUARD_ADMIN_ROLE);\n        _setRoleAdmin(EXECUTOR_ROLE, SAFEGUARD_ADMIN_ROLE);\n        _setRoleAdmin(CANCELER_ROLE, SAFEGUARD_ADMIN_ROLE);\n        _setRoleAdmin(CREATOR_ROLE, SAFEGUARD_ADMIN_ROLE);\n\n        // assign roles \n        for (uint i = 0; i < roles.length; i++) {\n            _setupRole(roles[i], rolesAssignees[i]);\n        }\n\n        // set admin rol to an address\n        _setupRole(SAFEGUARD_ADMIN_ROLE, _admin);\n        _setupRole(CREATOR_ROLE, msg.sender);\n    }\n\n    /**\n     * @dev Modifier to make a function callable just by a certain role.\n     */\n    modifier justByRole(bytes32 role) {\n        require(hasRole(role, _msgSender()), \"SafeGuard: sender requires permission\");\n        _;\n    }\n\n    /**\n     * @notice Sets the timelock address this safeGuard contract is gonna use\n     * @param _timelock The address of the timelock contract\n     */\n    function setTimelock(address _timelock) public justByRole(CREATOR_ROLE) {\n        require(address(timelock) == address(0), \"SafeGuard::setTimelock: Timelock address already defined\");\n        // set timelock address\n        timelock = ITimelock(_timelock);\n    }\n\n    function queueTransaction(address target, uint256 value, string memory signature, bytes memory data, uint256 eta) public justByRole(PROPOSER_ROLE) {\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        _queueTimelockTransaction(txHash, target, value, signature, data, eta);\n    }\n\n    function queueTransactionWithDescription(address target, uint256 value, string memory signature, bytes memory data, uint256 eta, string memory description) public justByRole(PROPOSER_ROLE) {\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        _queueTimelockTransaction(txHash, target, value, signature, data, eta);\n        emit QueueTransactionWithDescription(txHash, target, value, signature, data, eta, description);\n    }\n\n    function cancelTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public justByRole(CANCELER_ROLE) {\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        _cancelTimelockTransaction(txHash, target, value, signature, data, eta);\n    }\n\n    function executeTransaction(address target, uint256 _value, string memory signature, bytes memory data, uint256 eta) public payable justByRole(EXECUTOR_ROLE) {\n        bytes32 txHash = keccak256(abi.encode(target, _value, signature, data, eta));\n        require(timelock.queuedTransactions(txHash), \"SafeGuard::executeTransaction: transaction should be queued\");\n        timelock.executeTransaction{value: _value, gas: gasleft()}(target, _value, signature, data, eta);\n    }\n\n    function _queueTimelockTransaction(bytes32 txHash, address target, uint256 value, string memory signature, bytes memory data, uint256 eta) private {\n        require(!timelock.queuedTransactions(txHash), \"SafeGuard::queueTransaction: transaction already queued at eta\");\n        timelock.queueTransaction(target, value, signature, data, eta);\n    }\n\n    function _cancelTimelockTransaction(bytes32 txHash, address target, uint256 value, string memory signature, bytes memory data, uint256 eta) private {\n        require(timelock.queuedTransactions(txHash), \"SafeGuard::cancelTransaction: transaction should be queued\");\n        timelock.cancelTransaction(target, value, signature, data, eta);\n    }\n}"
    },
    {
      "filename": "contracts/SafeGuard.sol",
      "content": "pragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport \"./ITimelock.sol\";\nimport \"hardhat/console.sol\";\n\ncontract SafeGuard is AccessControlEnumerable {\n\n    // Request info event\n    event QueueTransactionWithDescription(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta, string description);\n\n    bytes32 public constant SAFEGUARD_ADMIN_ROLE = keccak256(\"SAFEGUARD_ADMIN_ROLE\");\n    bytes32 public constant PROPOSER_ROLE = keccak256(\"PROPOSER_ROLE\");\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\n    bytes32 public constant CANCELER_ROLE = keccak256(\"CANCELER_ROLE\");\n    bytes32 public constant CREATOR_ROLE = keccak256(\"CREATOR_ROLE\");\n\n    ///@dev The address of the Timelock\n    ITimelock public timelock;\n\n    /**\n     * @dev Initializes the contract with a given Timelock address and administrator address.\n     */\n    constructor (address _admin, bytes32[] memory roles, address[] memory rolesAssignees) {\n        require(roles.length == rolesAssignees.length, \"SafeGuard::constructor: roles assignment arity mismatch\");\n        // set roles administrator\n        _setRoleAdmin(SAFEGUARD_ADMIN_ROLE, SAFEGUARD_ADMIN_ROLE);\n        _setRoleAdmin(PROPOSER_ROLE, SAFEGUARD_ADMIN_ROLE);\n        _setRoleAdmin(EXECUTOR_ROLE, SAFEGUARD_ADMIN_ROLE);\n        _setRoleAdmin(CANCELER_ROLE, SAFEGUARD_ADMIN_ROLE);\n        _setRoleAdmin(CREATOR_ROLE, SAFEGUARD_ADMIN_ROLE);\n\n        // assign roles \n        for (uint i = 0; i < roles.length; i++) {\n            _setupRole(roles[i], rolesAssignees[i]);\n        }\n\n        // set admin rol to an address\n        _setupRole(SAFEGUARD_ADMIN_ROLE, _admin);\n        _setupRole(CREATOR_ROLE, msg.sender);\n    }\n\n    /**\n     * @dev Modifier to make a function callable just by a certain role.\n     */\n    modifier justByRole(bytes32 role) {\n        require(hasRole(role, _msgSender()), \"SafeGuard: sender requires permission\");\n        _;\n    }\n\n    /**\n     * @notice Sets the timelock address this safeGuard contract is gonna use\n     * @param _timelock The address of the timelock contract\n     */\n    function setTimelock(address _timelock) public justByRole(CREATOR_ROLE) {\n        require(address(timelock) == address(0), \"SafeGuard::setTimelock: Timelock address already defined\");\n        // set timelock address\n        timelock = ITimelock(_timelock);\n    }\n\n    function queueTransaction(address target, uint256 value, string memory signature, bytes memory data, uint256 eta) public justByRole(PROPOSER_ROLE) {\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        _queueTimelockTransaction(txHash, target, value, signature, data, eta);\n    }\n\n    function queueTransactionWithDescription(address target, uint256 value, string memory signature, bytes memory data, uint256 eta, string memory description) public justByRole(PROPOSER_ROLE) {\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        _queueTimelockTransaction(txHash, target, value, signature, data, eta);\n        emit QueueTransactionWithDescription(txHash, target, value, signature, data, eta, description);\n    }\n\n    function cancelTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public justByRole(CANCELER_ROLE) {\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        _cancelTimelockTransaction(txHash, target, value, signature, data, eta);\n    }\n\n    function executeTransaction(address target, uint256 _value, string memory signature, bytes memory data, uint256 eta) public payable justByRole(EXECUTOR_ROLE) {\n        bytes32 txHash = keccak256(abi.encode(target, _value, signature, data, eta));\n        require(timelock.queuedTransactions(txHash), \"SafeGuard::executeTransaction: transaction should be queued\");\n        timelock.executeTransaction{value: _value, gas: gasleft()}(target, _value, signature, data, eta);\n    }\n\n    function _queueTimelockTransaction(bytes32 txHash, address target, uint256 value, string memory signature, bytes memory data, uint256 eta) private {\n        require(!timelock.queuedTransactions(txHash), \"SafeGuard::queueTransaction: transaction already queued at eta\");\n        timelock.queueTransaction(target, value, signature, data, eta);\n    }\n\n    function _cancelTimelockTransaction(bytes32 txHash, address target, uint256 value, string memory signature, bytes memory data, uint256 eta) private {\n        require(timelock.queuedTransactions(txHash), \"SafeGuard::cancelTransaction: transaction should be queued\");\n        timelock.cancelTransaction(target, value, signature, data, eta);\n    }\n}"
    }
  ]
}