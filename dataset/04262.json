{
  "Title": "[L02] ACOToken.sol reference implementation is publicly initializable",
  "Content": "The [`init` function of `ACOToken.sol`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L177-L185) is `public` and allows anyone to call it, setting key parameters for the contract. `ACOToken` contracts are deployed to new addresses [via the minimal proxy pattern](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOFactory.sol#L235-L249), so a reference implementation must be deployed beforehand, exposing the `init` function. A malicious user can access the `init` function and set the contract parameters as if it was a reputable `ACOToken` from Auctus. Even though this will not affect any other token contract, it should never be treated as a valid token, given that it may appear to be so to an uninformed user.\n\n\nConsider initializing the `ACOToken.sol` reference implementation with “garbage” data, such as invalid [asset addresses](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L178-L179) and an expiry time that has already passed, to make this clearer to users and [prevent other calls to `init`](https://github.com/AuctusProject/aco/blob/36bcab024c9781d799381f8f973e99fd5b0f4d2d/smart-contracts/contracts/core/ACOToken.sol#L186). Additionally, consider establishing a developer process for doing this every time a new version of `ACOToken.sol` is deployed to the network. Consider informing users to only access `ACOToken`s through the official user interface.\n\n\n**Update:** *Acknowledged. Auctus’ statement for this issue:*\n\n\n\n> \n>  The team will establish a process to initialize the ACOToken.sol reference implementation with “garbage” data after every new deployment.\n> \n> \n> \n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "smart-contracts/contracts/core/ACOToken.sol",
      "content": "pragma solidity ^0.6.6;\n\nimport \"./ERC20.sol\";\nimport \"../libs/Address.sol\";\nimport \"../libs/BokkyPooBahsDateTimeLibrary.sol\";\nimport \"../libs/Strings.sol\";\n\n/**\n * @title ACOToken\n * @dev The implementation of the ACO token.\n * The token is ERC20 compliance.\n */\ncontract ACOToken is ERC20 {\n    using Address for address;\n    \n    /**\n     * @dev Struct to store the accounts that generated tokens with a collateral deposit.\n     */\n    struct TokenCollateralized {\n        /**\n         * @dev Current amount of tokens.\n         */\n        uint256 amount;\n        \n        /**\n         * @dev Index on the collateral owners array.\n         */\n        uint256 index;\n    }\n    \n    /**\n     * @dev Emitted when collateral is deposited on the contract.\n     * @param account Address of the collateral owner.\n     * @param amount Amount of collateral deposited.\n     */\n    event CollateralDeposit(address indexed account, uint256 amount);\n    \n    /**\n     * @dev Emitted when collateral is withdrawn from the contract.\n     * @param account Address of the account.\n     * @param recipient Address of the collateral destination.\n     * @param amount Amount of collateral withdrawn.\n     * @param fee The fee amount charged on the withdrawal.\n     */\n    event CollateralWithdraw(address indexed account, address indexed recipient, uint256 amount, uint256 fee);\n    \n    /**\n     * @dev Emitted when the collateral is used on an assignment.\n     * @param from Address of the account of the collateral owner.\n     * @param to Address of the account that exercises tokens to get the collateral.\n     * @param paidAmount Amount paid to the collateral owner.\n     * @param tokenAmount Amount of tokens used to exercise.\n     */\n    event Assigned(address indexed from, address indexed to, uint256 paidAmount, uint256 tokenAmount);\n\n    /**\n     * @dev The ERC20 token address for the underlying asset (0x0 for Ethereum). \n     */\n    address public underlying;\n    \n    /**\n     * @dev The ERC20 token address for the strike asset (0x0 for Ethereum). \n     */\n    address public strikeAsset;\n    \n    /**\n     * @dev Address of the fee destination charged on the exercise.\n     */\n    address payable public feeDestination;\n    \n    /**\n     * @dev True if the type is CALL, false for PUT.\n     */\n    bool public isCall;\n    \n    /**\n     * @dev The strike price for the token with the strike asset precision.\n     */\n    uint256 public strikePrice;\n    \n    /**\n     * @dev The UNIX time for the token expiration.\n     */\n    uint256 public expiryTime;\n    \n    /**\n     * @dev The total amount of collateral on the contract.\n     */\n    uint256 public totalCollateral;\n    \n    /**\n     * @dev The fee value. It is a percentage value (100000 is 100%).\n     */\n    uint256 public acoFee;\n    \n    /**\n     * @dev Symbol of the underlying asset.\n     */\n    string public underlyingSymbol;\n    \n    /**\n     * @dev Symbol of the strike asset.\n     */\n    string public strikeAssetSymbol;\n    \n    /**\n     * @dev Decimals for the underlying asset.\n     */\n    uint8 public underlyingDecimals;\n    \n    /**\n     * @dev Decimals for the strike asset.\n     */\n    uint8 public strikeAssetDecimals;\n    \n    /**\n     * @dev Underlying precision. (10 ^ underlyingDecimals)\n     */\n    uint256 internal underlyingPrecision;\n    \n    /**\n     * @dev Accounts that generated tokens with a collateral deposit.\n     */\n    mapping(address => TokenCollateralized) internal tokenData;\n    \n    /**\n     * @dev Array with all accounts with collateral deposited.\n     */\n    address[] internal _collateralOwners;\n    \n    /**\n     * @dev Internal data to control the reentrancy.\n     */\n    bool internal _notEntered;\n    \n    /**\n     * @dev Selector for ERC20 transfer function.\n     */\n    bytes4 internal _transferSelector;\n    \n    /**\n     * @dev Selector for ERC20 transfer from function.\n     */\n    bytes4 internal _transferFromSelector;\n    \n    /**\n     * @dev Modifier to check if the token is not expired.\n     * It is executed only while the token is not expired.\n     */\n    modifier notExpired() {\n        require(_notExpired(), \"ACOToken::Expired\");\n        _;\n    }\n    \n    /**\n     * @dev Modifier to prevents a contract from calling itself during the function execution.\n     */\n    modifier nonReentrant() {\n        require(_notEntered, \"ACOToken::Reentry\");\n        _notEntered = false;\n        _;\n        _notEntered = true;\n    }\n    \n    /**\n     * @dev Function to initialize the contract.\n     * It should be called when creating the token.\n     * It must be called only once. The `assert` is to guarantee that behavior.\n     * @param _underlying Address of the underlying asset (0x0 for Ethereum).\n     * @param _strikeAsset Address of the strike asset (0x0 for Ethereum).\n     * @param _isCall True if the type is CALL, false for PUT.\n     * @param _strikePrice The strike price with the strike asset precision.\n     * @param _expiryTime The UNIX time for the token expiration.\n     * @param _acoFee Value of the ACO fee. It is a percentage value (100000 is 100%).\n     * @param _feeDestination Address of the fee destination charged on the exercise.\n     */\n    function init(\n        address _underlying,\n        address _strikeAsset,\n        bool _isCall,\n        uint256 _strikePrice,\n        uint256 _expiryTime,\n        uint256 _acoFee,\n        address payable _feeDestination\n    ) public {\n        require(underlying == address(0) && strikeAsset == address(0) && strikePrice == 0, \"ACOToken::init: Already initialized\");\n        \n        require(_expiryTime > now, \"ACOToken::init: Invalid expiry\");\n        require(_strikePrice > 0, \"ACOToken::init: Invalid strike price\");\n        require(_underlying != _strikeAsset, \"ACOToken::init: Same assets\");\n        require(_acoFee <= 500, \"ACOToken::init: Invalid ACO fee\"); // Maximum is 0.5%\n        require(_isEther(_underlying) || _underlying.isContract(), \"ACOToken::init: Invalid underlying\");\n        require(_isEther(_strikeAsset) || _strikeAsset.isContract(), \"ACOToken::init: Invalid strike asset\");\n        \n        underlying = _underlying;\n        strikeAsset = _strikeAsset;\n        isCall = _isCall;\n        strikePrice = _strikePrice;\n        expiryTime = _expiryTime;\n        acoFee = _acoFee;\n        feeDestination = _feeDestination;\n        underlyingDecimals = _getAssetDecimals(_underlying);\n        strikeAssetDecimals = _getAssetDecimals(_strikeAsset);\n        underlyingSymbol = _getAssetSymbol(_underlying);\n        strikeAssetSymbol = _getAssetSymbol(_strikeAsset);\n        underlyingPrecision = 10 ** uint256(underlyingDecimals);\n\n        _transferSelector = bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\n        _transferFromSelector = bytes4(keccak256(bytes(\"transferFrom(address,address,uint256)\")));\n        _notEntered = true;\n    }\n    \n    /**\n     * @dev Function to guarantee that the contract will not receive ether directly.\n     */\n    receive() external payable {\n        revert();\n    }\n    \n    /**\n     * @dev Function to get the token name.\n     */\n    function name() public view override returns(string memory) {\n        return _name();\n    }\n    \n    /**\n     * @dev Function to get the token symbol, that it is equal to the name.\n     */\n    function symbol() public view override returns(string memory) {\n        return _name();\n    }\n    \n    /**\n     * @dev Function to get the token decimals, that it is equal to the underlying asset decimals.\n     */\n    function decimals() public view override returns(uint8) {\n        return underlyingDecimals;\n    }\n    \n    /**\n     * @dev Function to get the current amount of collateral for an account.\n     * @param account Address of the account.\n     * @return The current amount of collateral.\n     */\n    function currentCollateral(address account) public view returns(uint256) {\n        return getCollateralAmount(currentCollateralizedTokens(account));\n    }\n    \n    /**\n     * @dev Function to get the current amount of unassignable collateral for an account.\n     * NOTE: The function is valid when the token is NOT expired yet. \n     * After expiration, the unassignable collateral is equal to the account's collateral balance.\n     * @param account Address of the account.\n     * @return The respective amount of unassignable collateral.\n     */\n    function unassignableCollateral(address account) public view returns(uint256) {\n        return getCollateralAmount(unassignableTokens(account));\n    }\n    \n    /**\n     * @dev Function to get  the current amount of assignable collateral for an account.\n     * NOTE: The function is valid when the token is NOT expired yet. \n     * After expiration, the assignable collateral is zero.\n     * @param account Address of the account.\n     * @return The respective amount of assignable collateral.\n     */\n    function assignableCollateral(address account) public view returns(uint256) {\n        return getCollateralAmount(assignableTokens(account));\n    }\n    \n    /**\n     * @dev Function to get the current amount of collateralized tokens for an account.\n     * @param account Address of the account.\n     * @return The current amount of collateralized tokens.\n     */\n    function currentCollateralizedTokens(address account) public view returns(uint256) {\n        return tokenData[account].amount;\n    }\n    \n    /**\n     * @dev Function to get the current amount of unassignable tokens for an account.\n     * NOTE: The function is valid when the token is NOT expired yet. \n     * After expiration, the unassignable tokens is equal to the account's collateralized tokens.\n     * @param account Address of the account.\n     * @return The respective amount of unassignable tokens.\n     */\n    function unassignableTokens(address account) public view returns(uint256) {\n        if (balanceOf(account) > tokenData[account].amount) {\n            return tokenData[account].amount;\n        } else {\n            return balanceOf(account);\n        }\n    }\n    \n    /**\n     * @dev Function to get  the current amount of assignable tokens for an account.\n     * NOTE: The function is valid when the token is NOT expired yet. \n     * After expiration, the assignable tokens is zero.\n     * @param account Address of the account.\n     * @return The respective amount of assignable tokens.\n     */\n    function assignableTokens(address account) public view returns(uint256) {\n        return _getAssignableAmount(account);\n    }\n    \n    /**\n     * @dev Function to get the equivalent collateral amount for a token amount.\n     * @param tokenAmount Amount of tokens.\n     * @return The respective amount of collateral.\n     */\n    function getCollateralAmount(uint256 tokenAmount) public view returns(uint256) {\n        if (isCall) {\n            return tokenAmount;\n        } else if (tokenAmount > 0) {\n            return _getTokenStrikePriceRelation(tokenAmount);\n        } else {\n            return 0;\n        }\n    }\n    \n    /**\n     * @dev Function to get the equivalent token amount for a collateral amount.\n     * @param collateralAmount Amount of collateral.\n     * @return The respective amount of tokens.\n     */\n    function getTokenAmount(uint256 collateralAmount) public view returns(uint256) {\n        if (isCall) {\n            return collateralAmount;\n        } else if (collateralAmount > 0) {\n            return collateralAmount.mul(underlyingPrecision).div(strikePrice);\n        } else {\n            return 0;\n        }\n    }\n    \n    /**\n     * @dev Function to get the data for exercise of an amount of token.\n     * @param tokenAmount Amount of tokens.\n     * @return The asset and the respective amount that should be sent to get the collateral.\n     */\n    function getExerciseData(uint256 tokenAmount) public view returns(address, uint256) {\n        if (isCall) {\n            return (strikeAsset, _getTokenStrikePriceRelation(tokenAmount)); \n        } else {\n            return (underlying, tokenAmount);\n        }\n    }\n    \n    /**\n     * @dev Function to get the collateral to be received on an exercise and the respective fee.\n     * @param tokenAmount Amount of tokens.\n     * @return The collateral to be received and the respective fee.\n     */\n    function getCollateralOnExercise(uint256 tokenAmount) public view returns(uint256, uint256) {\n        uint256 collateralAmount = getCollateralAmount(tokenAmount);\n        uint256 fee = collateralAmount.mul(acoFee).div(100000);\n        collateralAmount = collateralAmount.sub(fee);\n        return (collateralAmount, fee);\n    }\n    \n    /**\n     * @dev Function to get the collateral asset.\n     * @return The address of the collateral asset.\n     */\n    function collateral() public view returns(address) {\n        if (isCall) {\n            return underlying;\n        } else {\n            return strikeAsset;\n        }\n    }\n    \n    /**\n     * @dev Function to mint tokens with Ether deposited as collateral.\n     * NOTE: The function only works when the token is NOT expired yet. \n     */\n    function mintPayable() external payable {\n        require(_isEther(collateral()), \"ACOToken::mintPayable: Invalid call\");\n       _mintToken(msg.sender, msg.value);\n    }\n    \n    /**\n     * @dev Function to mint tokens with Ether deposited as collateral to an informed account.\n     * However, the minted tokens are assigned to the transaction sender.\n     * NOTE: The function only works when the token is NOT expired yet. \n     * @param account Address of the account that will be the collateral owner.\n     */\n    function mintToPayable(address account) external payable {\n        require(_isEther(collateral()), \"ACOToken::mintToPayable: Invalid call\");\n       _mintToken(account, msg.value);\n    }\n    \n    /**\n     * @dev Function to mint tokens with ERC20 deposited as collateral.\n     * NOTE: The function only works when the token is NOT expired yet. \n     * @param collateralAmount Amount of collateral deposited.\n     */\n    function mint(uint256 collateralAmount) external {\n        address _collateral = collateral();\n        require(!_isEther(_collateral), \"ACOToken::mint: Invalid call\");\n        \n        _transferFromERC20(_collateral, msg.sender, address(this), collateralAmount);\n        _mintToken(msg.sender, collateralAmount);\n    }\n    \n    /**\n     * @dev Function to mint tokens with ERC20 deposited as collateral to an informed account.\n     * However, the minted tokens are assigned to the transaction sender.\n     * NOTE: The function only works when the token is NOT expired yet. \n     * @param account Address of the account that will be the collateral owner.\n     * @param collateralAmount Amount of collateral deposited.\n     */\n    function mintTo(address account, uint256 collateralAmount) external {\n        address _collateral = collateral();\n        require(!_isEther(_collateral), \"ACOToken::mintTo: Invalid call\");\n        \n        _transferFromERC20(_collateral, msg.sender, address(this), collateralAmount);\n        _mintToken(account, collateralAmount);\n    }\n    \n    /**\n     * @dev Function to burn tokens and get the collateral, not assigned, back.\n     * NOTE: The function only works when the token is NOT expired yet. \n     * @param tokenAmount Amount of tokens to be burned.\n     */\n    function burn(uint256 tokenAmount) external {\n        _burn(msg.sender, tokenAmount);\n    }\n    \n    /**\n     * @dev Function to burn tokens from a specific account and send the collateral to its address.\n     * The token allowance must be respected.\n     * The collateral is sent to the transaction sender.\n     * NOTE: The function only works when the token is NOT expired yet. \n     * @param account Address of the account.\n     * @param tokenAmount Amount of tokens to be burned.\n     */\n    function burnFrom(address account, uint256 tokenAmount) external {\n        _burn(account, tokenAmount);\n    }\n    \n    /**\n     * @dev Function to get the collateral, not assigned, back.\n     * NOTE: The function only works when the token IS expired. \n     */\n    function redeem() external {\n        _redeem(msg.sender);\n    }\n    \n    /**\n     * @dev Function to get the collateral from a specific account sent back to its address .\n     * The token allowance must be respected.\n     * The collateral is sent to the transaction sender.\n     * NOTE: The function only works when the token IS expired. \n     * @param account Address of the account.\n     */\n    function redeemFrom(address account) external {\n        require(tokenData[account].amount <= allowance(account, msg.sender), \"ACOToken::redeemFrom: No allowance\");\n        _redeem(account);\n    }\n    \n    /**\n     * @dev Function to exercise the tokens, paying to get the equivalent collateral.\n     * The paid amount is sent to the collateral owners that were assigned.\n     * NOTE: The function only works when the token is NOT expired. \n     * @param tokenAmount Amount of tokens.\n     */\n    function exercise(uint256 tokenAmount) external payable {\n        _exercise(msg.sender, tokenAmount);\n    }\n    \n    /**\n     * @dev Function to exercise the tokens from an account, paying to get the equivalent collateral.\n     * The token allowance must be respected.\n     * The paid amount is sent to the collateral owners that were assigned.\n     * The collateral is transferred to the transaction sender.\n     * NOTE: The function only works when the token is NOT expired. \n     * @param account Address of the account.\n     * @param tokenAmount Amount of tokens.\n     */\n    function exerciseFrom(address account, uint256 tokenAmount) external payable {\n        _exercise(account, tokenAmount);\n    }\n    \n    /**\n     * @dev Function to exercise the tokens, paying to get the equivalent collateral.\n     * The paid amount is sent to the collateral owners (on accounts list) that were assigned.\n     * NOTE: The function only works when the token is NOT expired. \n     * @param tokenAmount Amount of tokens.\n     * @param accounts The array of addresses to get collateral from.\n     */\n    function exerciseAccounts(uint256 tokenAmount, address[] calldata accounts) external payable {\n        _exerciseFromAccounts(msg.sender, tokenAmount, accounts);\n    }\n    \n    /**\n     * @dev Function to exercise the tokens from a specific account, paying to get the equivalent collateral sent to its address.\n     * The token allowance must be respected.\n     * The paid amount is sent to the collateral owners (on accounts list) that were assigned.\n     * The collateral is transferred to the transaction sender.\n     * NOTE: The function only works when the token is NOT expired. \n     * @param account Address of the account.\n     * @param tokenAmount Amount of tokens.\n     * @param accounts The array of addresses to get the deposited collateral.\n     */\n    function exerciseAccountsFrom(address account, uint256 tokenAmount, address[] calldata accounts) external payable {\n        _exerciseFromAccounts(account, tokenAmount, accounts);\n    }\n    \n    /**\n     * @dev Function to burn the tokens after expiration.\n     * It is an optional function to `clear` the account wallet from an expired and not functional token.\n     * NOTE: The function only works when the token IS expired. \n     */\n    function clear() external {\n        _clear(msg.sender);\n    }\n    \n    /**\n     * @dev Function to burn the tokens from an account after expiration.\n     * It is an optional function to `clear` the account wallet from an expired and not functional token.\n     * The token allowance must be respected.\n     * NOTE: The function only works when the token IS expired. \n     * @param account Address of the account.\n     */\n    function clearFrom(address account) external {\n        _clear(account);\n    }\n    \n    /**\n     * @dev Internal function to burn the tokens from an account after expiration.\n     * @param account Address of the account.\n     */\n    function _clear(address account) internal {\n        require(!_notExpired(), \"ACOToken::_clear: Token not expired yet\");\n        require(!_accountHasCollateral(account), \"ACOToken::_clear: Must call the redeem method\");\n        \n        _callBurn(account, balanceOf(account));\n    }\n    \n    /**\n     * @dev Internal function to redeem respective collateral from an account.\n     * @param account Address of the account.\n     * @param tokenAmount Amount of tokens.\n     */\n    function _redeemCollateral(address account, uint256 tokenAmount) internal {\n        require(_accountHasCollateral(account), \"ACOToken::_redeemCollateral: No collateral available\");\n        require(tokenAmount > 0, \"ACOToken::_redeemCollateral: Invalid token amount\");\n        \n        TokenCollateralized storage data = tokenData[account];\n        data.amount = data.amount.sub(tokenAmount);\n        \n        _removeCollateralDataIfNecessary(account);\n        \n        _transferCollateral(account, getCollateralAmount(tokenAmount), 0);\n    }\n    \n    /**\n     * @dev Internal function to mint tokens.\n     * The tokens are minted for the transaction sender.\n     * @param account Address of the account.\n     * @param collateralAmount Amount of collateral deposited.\n     */\n    function _mintToken(address account, uint256 collateralAmount) nonReentrant notExpired internal {\n        require(collateralAmount > 0, \"ACOToken::_mintToken: Invalid collateral amount\");\n        \n        if (!_accountHasCollateral(account)) {\n            tokenData[account].index = _collateralOwners.length;\n            _collateralOwners.push(account);\n        }\n        \n        uint256 tokenAmount = getTokenAmount(collateralAmount);\n        tokenData[account].amount = tokenData[account].amount.add(tokenAmount);\n        \n        totalCollateral = totalCollateral.add(collateralAmount);\n        \n        emit CollateralDeposit(account, collateralAmount);\n        \n        super._mintAction(msg.sender, tokenAmount);\n    }\n    \n    /**\n     * @dev Internal function to transfer tokens. \n     * The token transfer only works when the token is NOT expired. \n     * @param sender Source of the tokens.\n     * @param recipient Destination address for the tokens.\n     * @param amount Amount of tokens.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) notExpired internal override {\n        super._transferAction(sender, recipient, amount);\n    }\n    \n    /**\n     * @dev Internal function to set the token permission from an account to another address. \n     * The token approval only works when the token is NOT expired. \n     * @param owner Address of the token owner.\n     * @param spender Address of the spender authorized.\n     * @param amount Amount of tokens authorized.\n     */\n    function _approve(address owner, address spender, uint256 amount) notExpired internal override {\n        super._approveAction(owner, spender, amount);\n    }\n    \n    /**\n     * @dev Internal function to transfer collateral. \n     * When there is a fee, the calculated fee is also transferred to the destination fee address.\n     * The collateral destination is always the transaction sender address.\n     * @param account Address of the account.\n     * @param collateralAmount Amount of collateral to be redeemed.\n     * @param fee Amount of fee charged.\n     */\n    function _transferCollateral(address account, uint256 collateralAmount, uint256 fee) internal {\n        \n        totalCollateral = totalCollateral.sub(collateralAmount.add(fee));\n        \n        address _collateral = collateral();\n        if (_isEther(_collateral)) {\n            payable(msg.sender).transfer(collateralAmount);\n            if (fee > 0) {\n                feeDestination.transfer(fee);   \n            }\n        } else {\n            _transferERC20(_collateral, msg.sender, collateralAmount);\n            if (fee > 0) {\n                _transferERC20(_collateral, feeDestination, fee);\n            }\n        }\n        \n        emit CollateralWithdraw(account, msg.sender, collateralAmount, fee);\n    }\n    \n    /**\n     * @dev Internal function to exercise the tokens from an account. \n     * @param account Address of the account that is exercising.\n     * @param tokenAmount Amount of tokens.\n     */\n    function _exercise(address account, uint256 tokenAmount) nonReentrant internal {\n        _validateAndBurn(account, tokenAmount);\n        _exerciseOwners(account, tokenAmount);\n        (uint256 collateralAmount, uint256 fee) = getCollateralOnExercise(tokenAmount);\n        _transferCollateral(account, collateralAmount, fee);\n    }\n    \n    /**\n     * @dev Internal function to exercise the tokens from an account. \n     * @param account Address of the account that is exercising.\n     * @param tokenAmount Amount of tokens.\n     * @param accounts The array of addresses to get the collateral from.\n     */\n    function _exerciseFromAccounts(address account, uint256 tokenAmount, address[] memory accounts) nonReentrant internal {\n        _validateAndBurn(account, tokenAmount);\n        _exerciseAccounts(account, tokenAmount, accounts);\n        (uint256 collateralAmount, uint256 fee) = getCollateralOnExercise(tokenAmount);\n        _transferCollateral(account, collateralAmount, fee);\n    }\n    \n    /**\n     * @dev Internal function to exercise the assignable tokens from the stored list of collateral owners. \n     * @param exerciseAccount Address of the account that is exercising.\n     * @param tokenAmount Amount of tokens.\n     */\n    function _exerciseOwners(address exerciseAccount, uint256 tokenAmount) internal {\n        uint256 start = _collateralOwners.length - 1;\n        for (uint256 i = start; i >= 0; --i) {\n            if (tokenAmount == 0) {\n                break;\n            }\n            tokenAmount = _exerciseAccount(_collateralOwners[i], tokenAmount, exerciseAccount);\n        }\n        require(tokenAmount == 0, \"ACOToken::_exerciseOwners: Invalid remaining amount\");\n    }\n    \n    /**\n     * @dev Internal function to exercise the assignable tokens from an accounts list. \n     * @param exerciseAccount Address of the account that is exercising.\n     * @param tokenAmount Amount of tokens.\n     * @param accounts The array of addresses to get the collateral from.\n     */\n    function _exerciseAccounts(address exerciseAccount, uint256 tokenAmount, address[] memory accounts) internal {\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            if (tokenAmount == 0) {\n                break;\n            }\n            tokenAmount = _exerciseAccount(accounts[i], tokenAmount, exerciseAccount);\n        }\n        require(tokenAmount == 0, \"ACOToken::_exerciseAccounts: Invalid remaining amount\");\n    }\n    \n    /**\n     * @dev Internal function to exercise the assignable tokens from an account and transfer to its address the respective payment. \n     * @param account Address of the account.\n     * @param tokenAmount Amount of tokens.\n     * @param exerciseAccount Address of the account that is exercising.\n     * @return Remaining amount of tokens.\n     */\n    function _exerciseAccount(address account, uint256 tokenAmount, address exerciseAccount) internal returns(uint256) {\n        uint256 available = _getAssignableAmount(account);\n        if (available > 0) {\n            \n            TokenCollateralized storage data = tokenData[account];\n            uint256 valueToTransfer;\n            if (available < tokenAmount) {\n                valueToTransfer = available;\n                tokenAmount = tokenAmount.sub(available);\n            } else {\n                valueToTransfer = tokenAmount;\n                tokenAmount = 0;\n            }\n            \n            (address exerciseAsset, uint256 amount) = getExerciseData(valueToTransfer);\n\n            data.amount = data.amount.sub(valueToTransfer); \n            \n            _removeCollateralDataIfNecessary(account);\n            \n            if (_isEther(exerciseAsset)) {\n                payable(account).transfer(amount);\n            } else {\n                _transferERC20(exerciseAsset, account, amount);\n            }\n            emit Assigned(account, exerciseAccount, amount, valueToTransfer);\n        }\n        \n        return tokenAmount;\n    }\n    \n    /**\n     * @dev Internal function to validate the exercise operation and burn the respective tokens.\n     * @param account Address of the account that is exercising.\n     * @param tokenAmount Amount of tokens.\n     */\n    function _validateAndBurn(address account, uint256 tokenAmount) notExpired internal {\n        require(tokenAmount > 0, \"ACOToken::_validateAndBurn: Invalid token amount\");\n        \n        // Whether an account has deposited collateral it only can exercise the extra amount of unassignable tokens.\n        if (_accountHasCollateral(account)) {\n            require(balanceOf(account) > tokenData[account].amount, \"ACOToken::_validateAndBurn: Tokens compromised\");\n            require(tokenAmount <= balanceOf(account).sub(tokenData[account].amount), \"ACOToken::_validateAndBurn: Token amount not available\"); \n        }\n        \n        _callBurn(account, tokenAmount);\n        \n        (address exerciseAsset, uint256 expectedAmount) = getExerciseData(tokenAmount);\n\n        if (_isEther(exerciseAsset)) {\n            require(msg.value == expectedAmount, \"ACOToken::_validateAndBurn: Invalid ether amount\");\n        } else {\n            require(msg.value == 0, \"ACOToken::_validateAndBurn: No ether expected\");\n            _transferFromERC20(exerciseAsset, msg.sender, address(this), expectedAmount);\n        }\n    }\n    \n    /**\n     * @dev Internal function to calculate the token strike price relation.\n     * @param tokenAmount Amount of tokens.\n     * @return Calculated value with strike asset precision.\n     */\n    function _getTokenStrikePriceRelation(uint256 tokenAmount) internal view returns(uint256) {\n        return tokenAmount.mul(strikePrice).div(underlyingPrecision);\n    }\n    \n    /**\n     * @dev Internal function to get the collateral sent back from an account.\n     * Function to be called when the token IS expired.\n     * @param account Address of the account.\n     */\n    function _redeem(address account) nonReentrant internal {\n        require(!_notExpired(), \"ACOToken::_redeem: Token not expired yet\");\n        \n        _redeemCollateral(account, tokenData[account].amount);\n        super._burnAction(account, balanceOf(account));\n    }\n    \n    /**\n     * @dev Internal function to burn tokens from an account and get the collateral, not assigned, back.\n     * @param account Address of the account.\n     * @param tokenAmount Amount of tokens to be burned.\n     */\n    function _burn(address account, uint256 tokenAmount) nonReentrant notExpired internal {\n        _redeemCollateral(account, tokenAmount);\n        _callBurn(account, tokenAmount);\n    }\n    \n    /**\n     * @dev Internal function to burn tokens.\n     * @param account Address of the account.\n     * @param tokenAmount Amount of tokens to be burned.\n     */\n    function _callBurn(address account, uint256 tokenAmount) internal {\n        if (account == msg.sender) {\n            super._burnAction(account, tokenAmount);\n        } else {\n            super._burnFrom(account, tokenAmount);\n        }\n    }\n    \n    /**\n     * @dev Internal function to get the amount of assignable token from an account.\n     * @param account Address of the account.\n     * @return The assignable amount of tokens.\n     */\n    function _getAssignableAmount(address account) internal view returns(uint256) {\n        if (tokenData[account].amount > balanceOf(account)) {\n            return tokenData[account].amount.sub(balanceOf(account));\n        } else {\n            return 0;\n        }\n    }\n    \n    /**\n     * @dev Internal function to remove the token data with collateral if its total amount was assigned.\n     * @param account Address of account.\n     */\n    function _removeCollateralDataIfNecessary(address account) internal {\n        TokenCollateralized storage data = tokenData[account];\n        if (!_hasCollateral(data)) {\n            uint256 lastIndex = _collateralOwners.length - 1;\n            if (lastIndex != data.index) {\n                address last = _collateralOwners[lastIndex];\n                tokenData[last].index = data.index;\n                _collateralOwners[data.index] = last;\n            }\n            _collateralOwners.pop();\n            delete tokenData[account];\n        }\n    }\n    \n    /**\n     * @dev Internal function to get if the token is not expired.\n     * @return Whether the token is NOT expired.\n     */\n    function _notExpired() internal view returns(bool) {\n        return now <= expiryTime;\n    }\n    \n    /**\n     * @dev Internal function to get if an account has collateral deposited.\n     * @param account Address of the account.\n     * @return Whether the account has collateral deposited.\n     */"
    }
  ]
}