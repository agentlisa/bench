{
  "Title": "[N-03] `eta` in `ProposalCancelled` event can be misleading",
  "Content": "\nhttps://github.com/code-423n4/2023-07-axelar/blob/main/contracts/cgp/governance/InterchainGovernance.sol#L135\n\nhttps://github.com/code-423n4/2023-07-axelar/blob/main/contracts/cgp/governance/AxelarServiceGovernance.sol#L94\n\n```solidity\nFile: cgp/governance/AxelarServiceGovernance.sol\n\n94:            emit ProposalCancelled(proposalHash, target, callData, nativeValue, eta);\n```\n\nThe `eta` here can be misleading, as it might not be the `eta` of the event. The user can send what they want here and if it is the correct `eta` that the user used to schedule, it can still have been changed when scheduling the `Timelock`.\n\n### Recommendation\n\nConsider either reading the `eta` before clearing it in `_cancelTimeLock` or don't include the `eta` in the event at all.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-07-axelar",
  "Code": [
    {
      "filename": "contracts/cgp/governance/InterchainGovernance.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { AxelarExecutable } from '../../gmp-sdk/executable/AxelarExecutable.sol';\nimport { TimeLock } from '../../gmp-sdk/util/TimeLock.sol';\nimport { IInterchainGovernance } from '../interfaces/IInterchainGovernance.sol';\nimport { Caller } from '../util/Caller.sol';\n\n/**\n * @title Interchain Governance contract\n * @notice This contract handles cross-chain governance actions. It includes functionality\n * to create, cancel, and execute governance proposals.\n */\ncontract InterchainGovernance is AxelarExecutable, TimeLock, Caller, IInterchainGovernance {\n    enum GovernanceCommand {\n        ScheduleTimeLockProposal,\n        CancelTimeLockProposal\n    }\n\n    string public governanceChain;\n    string public governanceAddress;\n    bytes32 public immutable governanceChainHash;\n    bytes32 public immutable governanceAddressHash;\n\n    /**\n     * @notice Initializes the contract\n     * @param gateway The address of the Axelar gateway contract\n     * @param governanceChain_ The name of the governance chain\n     * @param governanceAddress_ The address of the governance contract\n     * @param minimumTimeDelay The minimum time delay for timelock operations\n     */\n    constructor(\n        address gateway,\n        string memory governanceChain_,\n        string memory governanceAddress_,\n        uint256 minimumTimeDelay\n    ) AxelarExecutable(gateway) TimeLock(minimumTimeDelay) {\n        governanceChain = governanceChain_;\n        governanceAddress = governanceAddress_;\n        governanceChainHash = keccak256(bytes(governanceChain_));\n        governanceAddressHash = keccak256(bytes(governanceAddress_));\n    }\n\n    /**\n     * @notice Returns the ETA of a proposal\n     * @param target The address of the contract targeted by the proposal\n     * @param callData The call data to be sent to the target contract\n     * @param nativeValue The amount of native tokens to be sent to the target contract\n     * @return uint256 The ETA of the proposal\n     */\n    function getProposalEta(\n        address target,\n        bytes calldata callData,\n        uint256 nativeValue\n    ) external view returns (uint256) {\n        return _getTimeLockEta(_getProposalHash(target, callData, nativeValue));\n    }\n\n    /**\n     * @notice Executes a proposal\n     * @dev The proposal is executed by calling the target contract with calldata. Native value is\n     * transferred with the call to the target contract.\n     * @param target The target address of the contract to call\n     * @param callData The data containing the function and arguments for the contract to call\n     * @param nativeValue The amount of native token to send to the target contract\n     */\n    function executeProposal(\n        address target,\n        bytes calldata callData,\n        uint256 nativeValue\n    ) external payable {\n        bytes32 proposalHash = keccak256(abi.encodePacked(target, callData, nativeValue));\n\n        _finalizeTimeLock(proposalHash);\n        _call(target, callData, nativeValue);\n\n        emit ProposalExecuted(proposalHash, target, callData, nativeValue, block.timestamp);\n    }\n\n    /**\n     * @notice Internal function to execute a proposal action\n     * @param sourceChain The source chain of the proposal, must equal the governance chain\n     * @param sourceAddress The source address of the proposal, must equal the governance address\n     * @param payload The payload of the proposal\n     */\n    function _execute(\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload\n    ) internal override {\n        if (keccak256(bytes(sourceChain)) != governanceChainHash || keccak256(bytes(sourceAddress)) != governanceAddressHash)\n            revert NotGovernance();\n\n        (uint256 command, address target, bytes memory callData, uint256 nativeValue, uint256 eta) = abi.decode(\n            payload,\n            (uint256, address, bytes, uint256, uint256)\n        );\n\n        if (target == address(0)) revert InvalidTarget();\n\n        _processCommand(command, target, callData, nativeValue, eta);\n    }\n\n    /**\n     * @notice Internal function to process a governance command\n     * @param commandId The id of the command, 0 for proposal creation and 1 for proposal cancellation\n     * @param target The target address the proposal will call\n     * @param callData The data the encodes the function and arguments to call on the target contract\n     * @param nativeValue The nativeValue of native token to be sent to the target contract\n     * @param eta The time after which the proposal can be executed\n     */\n    function _processCommand(\n        uint256 commandId,\n        address target,\n        bytes memory callData,\n        uint256 nativeValue,\n        uint256 eta\n    ) internal virtual {\n        if (commandId > uint256(type(GovernanceCommand).max)) {\n            revert InvalidCommand();\n        }\n\n        GovernanceCommand command = GovernanceCommand(commandId);\n        bytes32 proposalHash = _getProposalHash(target, callData, nativeValue);\n\n        if (command == GovernanceCommand.ScheduleTimeLockProposal) {\n            eta = _scheduleTimeLock(proposalHash, eta);\n\n            emit ProposalScheduled(proposalHash, target, callData, nativeValue, eta);\n            return;\n        } else if (command == GovernanceCommand.CancelTimeLockProposal) {\n            _cancelTimeLock(proposalHash);\n\n            emit ProposalCancelled(proposalHash, target, callData, nativeValue, eta);\n            return;\n        }\n    }\n\n    /**\n     * @dev Get proposal hash using the target, callData, and nativeValue\n     */\n    function _getProposalHash(\n        address target,\n        bytes memory callData,\n        uint256 nativeValue\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(target, callData, nativeValue));\n    }\n\n    /**\n     * @notice Overrides internal function of AxelarExecutable, will always revert\n     * as this governance module does not support execute with token.\n     */\n    function _executeWithToken(\n        string calldata, /* sourceChain */\n        string calldata, /* sourceAddress */\n        bytes calldata, /* payload */\n        string calldata, /* tokenSymbol */\n        uint256 /* amount */\n    ) internal pure override {\n        revert TokenNotSupported();\n    }\n\n    /**\n     * @notice Making contact able to receive native value\n     */\n    receive() external payable {}\n}"
    },
    {
      "filename": "contracts/cgp/governance/AxelarServiceGovernance.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IAxelarServiceGovernance } from '../interfaces/IAxelarServiceGovernance.sol';\nimport { InterchainGovernance } from './InterchainGovernance.sol';\nimport { MultisigBase } from '../auth/MultisigBase.sol';\n\n/**\n * @title AxelarServiceGovernance Contract\n * @dev This contract is part of the Axelar Governance system, it inherits the Interchain Governance contract\n * with added functionality to approve and execute multisig proposals.\n */\ncontract AxelarServiceGovernance is InterchainGovernance, MultisigBase, IAxelarServiceGovernance {\n    enum ServiceGovernanceCommand {\n        ScheduleTimeLockProposal,\n        CancelTimeLockProposal,\n        ApproveMultisigProposal,\n        CancelMultisigApproval\n    }\n\n    mapping(bytes32 => bool) public multisigApprovals;\n\n    /**\n     * @notice Initializes the contract.\n     * @param gateway The address of the Axelar gateway contract\n     * @param governanceChain The name of the governance chain\n     * @param governanceAddress The address of the governance contract\n     * @param minimumTimeDelay The minimum time delay for timelock operations\n     * @param cosigners The list of initial signers\n     * @param threshold The number of required signers to validate a transaction\n     */\n    constructor(\n        address gateway,\n        string memory governanceChain,\n        string memory governanceAddress,\n        uint256 minimumTimeDelay,\n        address[] memory cosigners,\n        uint256 threshold\n    ) InterchainGovernance(gateway, governanceChain, governanceAddress, minimumTimeDelay) MultisigBase(cosigners, threshold) {}\n\n    /**\n     * @notice Executes a multisig proposal.\n     * @param target The target address the proposal will call\n     * @param callData The data that encodes the function and arguments to call on the target contract\n     * @param nativeValue The value of native token to be sent to the target contract\n     */\n    function executeMultisigProposal(\n        address target,\n        bytes calldata callData,\n        uint256 nativeValue\n    ) external payable onlySigners {\n        bytes32 proposalHash = keccak256(abi.encodePacked(target, callData, nativeValue));\n\n        if (!multisigApprovals[proposalHash]) revert NotApproved();\n\n        multisigApprovals[proposalHash] = false;\n\n        _call(target, callData, nativeValue);\n\n        emit MultisigExecuted(proposalHash, target, callData, nativeValue);\n    }\n\n    /**\n     * @notice Internal function to process a governance command\n     * @param commandId The id of the command\n     * @param target The target address the proposal will call\n     * @param callData The data the encodes the function and arguments to call on the target contract\n     * @param nativeValue The value of native token to be sent to the target contract\n     * @param eta The time after which the proposal can be executed\n     */\n    function _processCommand(\n        uint256 commandId,\n        address target,\n        bytes memory callData,\n        uint256 nativeValue,\n        uint256 eta\n    ) internal override {\n        if (commandId > uint256(type(ServiceGovernanceCommand).max)) {\n            revert InvalidCommand();\n        }\n\n        ServiceGovernanceCommand command = ServiceGovernanceCommand(commandId);\n        bytes32 proposalHash = keccak256(abi.encodePacked(target, callData, nativeValue));\n\n        if (command == ServiceGovernanceCommand.ScheduleTimeLockProposal) {\n            eta = _scheduleTimeLock(proposalHash, eta);\n\n            emit ProposalScheduled(proposalHash, target, callData, nativeValue, eta);\n            return;\n        } else if (command == ServiceGovernanceCommand.CancelTimeLockProposal) {\n            _cancelTimeLock(proposalHash);\n\n            emit ProposalCancelled(proposalHash, target, callData, nativeValue, eta);\n            return;\n        } else if (command == ServiceGovernanceCommand.ApproveMultisigProposal) {\n            multisigApprovals[proposalHash] = true;\n\n            emit MultisigApproved(proposalHash, target, callData, nativeValue);\n            return;\n        } else if (command == ServiceGovernanceCommand.CancelMultisigApproval) {\n            multisigApprovals[proposalHash] = false;\n\n            emit MultisigCancelled(proposalHash, target, callData, nativeValue);\n            return;\n        }\n    }\n}"
    }
  ]
}