{
  "Title": "[M-19] Attacker can perform griefing for `process()` in `PromiseRouter` by reverting calls to `callback()` in `callbackAddress`",
  "Content": "_Submitted by unforgiven_\n\n[PromiseRouter.sol#L226-L262](https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/promise/PromiseRouter.sol#L226-L262)<br>\n\n`process()` in ` PromiseRouter  ` is used for process stored callback function and anyone calls it gets `callbackFee` and it calls `callback()` function of `callbackAddress`. but attacker set a `callbackAddress` that reverts on `callback()` and cause `process()`  caller griefing. attacker can perform this buy front running or complex logic.\n\n### Proof of Concept\n\nThis is `process()` code:\n\n      /**\n       * @notice Process stored callback function\n       * @param transferId The transferId to process\n       */\n      function process(bytes32 transferId, bytes calldata _message) public nonReentrant {\n        // parse out the return data and callback address from message\n        bytes32 messageHash = messageHashes[transferId];\n        if (messageHash == bytes32(0)) revert PromiseRouter__process_invalidTransferId();\n\n        bytes29 _msg = _message.ref(0).mustBePromiseCallback();\n        if (messageHash != _msg.keccak()) revert PromiseRouter__process_invalidMessage();\n\n        // enforce relayer is whitelisted by calling local connext contract\n        if (!connext.approvedRelayers(msg.sender)) revert PromiseRouter__process_notApprovedRelayer();\n\n        address callbackAddress = _msg.callbackAddress();\n\n        if (!AddressUpgradeable.isContract(callbackAddress)) revert PromiseRouter__process_notContractCallback();\n\n        uint256 callbackFee = callbackFees[transferId];\n\n        // remove message\n        delete messageHashes[transferId];\n\n        // remove callback fees\n        callbackFees[transferId] = 0;\n\n        // execute callback\n        ICallback(callbackAddress).callback(transferId, _msg.returnSuccess(), _msg.returnData());\n\n        emit CallbackExecuted(transferId, msg.sender);\n\n        // Should transfer the stored relayer fee to the msg.sender\n        if (callbackFee > 0) {\n          AddressUpgradeable.sendValue(payable(msg.sender), callbackFee);\n        }\n      }\n\nAs you can see it calls `ICallback(callbackAddress).callback(transferId, _msg.returnSuccess(), _msg.returnData());` and if that call reverts then whole transaction would revert. so attacker can setup `callbackAddress` that revert and the caller of `process()` wouldn't get any fee and lose gas.\n\n### Tools Used\n\nVIM\n\n### Recommended Mitigation Steps\n\nChange the code so it won't revert if call to `callbackAddress` reverts.\n\n**[jakekidd (Connext) confirmed, but disagreed with severity](https://github.com/code-423n4/2022-06-connext-findings/issues/225)**\n\n**[jakekidd (Connext) commented](https://github.com/code-423n4/2022-06-connext-findings/issues/225#issuecomment-1166174583):**\n > If the callback would revert, *normally* it won't be called.\n> \n> However, the attacker (griefer) could potentially frontrun the relayer's callback transaction (which is already submitted / in the mempool) and update the state of their callback contract in such a way to cause this subsequent callback to fail. Why would they do that? Nothing is gained, only losses are incurred on both sides.\n> \n> This seems like it should be invalid, but it also seems like we should be doing a try/catch on principle though. Perhaps the issue is misrepresented here - it's not so much an attack vector as it's 'best practice' / QA issue.\n> \n> ~~Let's de-escalate to QA issue.~~ Confirming, but would be great to get a second look from @LayneHaber on this.\n> \n> EDIT: Changed my mind, think the risk level is appropriate.\n\n**[LayneHaber (Connext) changed to acknowledged and commented](https://github.com/code-423n4/2022-06-connext-findings/issues/225#issuecomment-1171115193):**\n > If you change the message, the following check(s) would fail (since the hash is put onchain when the message is propagated by nomad):\n> \n> ```ts\n> bytes32 messageHash = messageHashes[transferId];\n> if (messageHash == bytes32(0)) revert PromiseRouter__process_invalidTransferId();\n> \n> bytes29 _msg = _message.ref(0).mustBePromiseCallback();\n> if (messageHash != _msg.keccak()) revert PromiseRouter__process_invalidMessage();\n> ```\n> \n> An attacker cannot falsify this message because sending messages on the router is restricted via the `onlyConnext` modifier, so I don't think changing the `callbackAddress` is a valid attack strategy. \n> \n> If we extend this concern to any failing `callback`, then any revert would not be executed. In most cases, this would be caught in offchain simulations meaning the relayer would not submit the transaction (and then nobody could process the callback). This means that integrators *must* handle failures within their code. This is a common practice when writing crosschain handlers (i.e. nomad `handle` should not revert as the message cannot be reprocessed, functions called via `execute` should handle errors unless sending funds to a recovery address is okay, etc.).\n> \n> Don't think this qualifies as a value leak, but because it is potentially unprocessable will leave the severity at 2 and move the label to \"acknowledged\".\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-06-connext-findings/issues/225#issuecomment-1214769299):**\n > I guess this issue has the same concerns as [M-01 (Issue #220)](https://github.com/code-423n4/2022-06-connext-findings/issues/220). Even if the onus is on the caller of `process` to simulate the call beforehand, it seems likely that the transaction could be front-run and prove to be poor user experience for relayers. \n> \n> I don't think its realistic that relayers would call this function without first simulating the transaction to see if the callback fails, but I guess the bridge user could set the callback address up as a honey pot such that simulated transactions are successful.\n> \n> It probably makes sense to remove the main culprit of the issue by using a try/catch statement for the `ICallback(callbackAddress).callback(transferId, _msg.returnSuccess(), _msg.returnData());` call.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-06-connext",
  "Code": [
    {
      "filename": "contracts/contracts/core/promise/PromiseRouter.sol",
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.14;\n\nimport {Home} from \"../../nomad-core/contracts/Home.sol\";\nimport {TypedMemView} from \"../../nomad-core/libs/TypedMemView.sol\";\n\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport {IConnextHandler} from \"../connext/interfaces/IConnextHandler.sol\";\nimport {IBridgeToken} from \"../connext/interfaces/IBridgeToken.sol\";\n\nimport {Router} from \"../shared/Router.sol\";\nimport {XAppConnectionClient} from \"../shared/XAppConnectionClient.sol\";\nimport {Version} from \"../shared/Version.sol\";\n\nimport {ICallback} from \"./interfaces/ICallback.sol\";\nimport {PromiseMessage} from \"./libraries/PromiseMessage.sol\";\n\n/**\n * @title PromiseRouter\n */\ncontract PromiseRouter is Version, Router, ReentrancyGuardUpgradeable {\n  // ============ Libraries ============\n\n  using TypedMemView for bytes;\n  using TypedMemView for bytes29;\n  using PromiseMessage for bytes29;\n\n  // ========== Custom Errors ===========\n\n  error PromiseRouter__onlyConnext_notConnext();\n  error PromiseRouter__send_returndataEmpty();\n  error PromiseRouter__send_callbackEmpty();\n  error PromiseRouter__process_invalidTransferId();\n  error PromiseRouter__process_invalidMessage();\n  error PromiseRouter__process_notApprovedRelayer();\n  error PromiseRouter__process_insufficientCallbackFee();\n  error PromiseRouter__process_notContractCallback();\n  error PromiseRouter__bumpCallbackFee_valueIsZero();\n  error PromiseRouter__bumpCallbackFee_messageUnavailable();\n  error PromiseRouter__initCallbackFee_valueIsZero();\n\n  // ============ Public Storage ============\n\n  IConnextHandler public connext;\n\n  /**\n   * @notice Mapping of transferId to promise callback messages\n   * @dev While handling the message, it will parse transferId from incomming message and store the message in the mapping\n   */\n  mapping(bytes32 => bytes32) public messageHashes;\n\n  /**\n   * @notice Mapping of transferId to callback fee\n   * @dev This will track all the callback fees for each transferId.\n   * Can add while xcall or bumping callback fee\n   */\n  mapping(bytes32 => uint256) public callbackFees;\n\n  // ============ Upgrade Gap ============\n\n  // gap for upgrade safety\n  uint256[49] private __GAP;\n\n  // ======== Events =========\n\n  /**\n   * @notice Emitted when a promise callback has been sent from this domain\n   * @param domain The domain where to execute the callback\n   * @param remote Remote PromiseRouter address\n   * @param transferId The transferId\n   * @param callbackAddress The address of the callback\n   * @param success The return success from the execution on the destination domain\n   * @param data The returnData from the execution on the destination domain\n   * @param message The message sent to the destination domain\n   */\n  event Send(\n    uint32 domain,\n    bytes32 remote,\n    bytes32 transferId,\n    address callbackAddress,\n    bool success,\n    bytes data,\n    bytes message\n  );\n\n  /**\n   * @notice Emitted when a promise callback message has arrived to this domain\n   * @param originAndNonce Domain where the transfer originated and the unique identifier\n   * for the message from origin to destination, combined in a single field ((origin << 32) & nonce)\n   * @param origin Domain where the transfer originated\n   * @param transferId The transferId\n   * @param callbackAddress The address of the callback\n   * @param success The return success from the execution on the destination domain\n   * @param data The returnData from the execution on the destination domain\n   * @param message The message sent to the destination domain\n   */\n  event Receive(\n    uint64 indexed originAndNonce,\n    uint32 indexed origin,\n    bytes32 transferId,\n    address callbackAddress,\n    bool success,\n    bytes data,\n    bytes message\n  );\n\n  /**\n   * @notice Emitted when transaction fee for callback added\n   * @param transferId The transferId\n   * @param addedFee The fee amount that added newly\n   * @param totalFee The total fee amount, can be bumped by multiple times\n   * @param caller The transaction caller\n   */\n  event CallbackFeeAdded(bytes32 indexed transferId, uint256 addedFee, uint256 totalFee, address caller);\n\n  /**\n   * @notice Emitted when callback function executed\n   * @param transferId The transferId\n   * @param relayer The address of the relayer which executed the callback\n   */\n  event CallbackExecuted(bytes32 indexed transferId, address relayer);\n\n  /**\n   * @notice Emitted when a new Connext address is set\n   * @param connext The new connext address\n   */\n  event SetConnext(address indexed connext);\n\n  // ======== Receive =======\n  receive() external payable {}\n\n  // ============ Modifiers ============\n\n  /**\n   * @notice Restricts the caller to the local bridge router\n   */\n  modifier onlyConnext() {\n    if (msg.sender != address(connext)) revert PromiseRouter__onlyConnext_notConnext();\n    _;\n  }\n\n  // ======== Initializer ========\n\n  function initialize(address _xAppConnectionManager) public initializer {\n    __XAppConnectionClient_initialize(_xAppConnectionManager);\n  }\n\n  /**\n   * @notice Sets the Connext.\n   * @dev Connext and relayer fee router store references to each other\n   * @param _connext The address of the Connext implementation\n   */\n  function setConnext(address _connext) external onlyOwner {\n    connext = IConnextHandler(_connext);\n    emit SetConnext(_connext);\n  }\n\n  // ======== External: Send PromiseCallback =========\n\n  /**\n   * @notice Sends a request to execute callback in the originated domain\n   * @param _domain The domain where to execute callback\n   * @param _transferId The transferId\n   * @param _callbackAddress A callback address to be called when promise callback is received\n   * @param _returnSuccess The returnSuccess from the execution\n   * @param _returnData The returnData from the execution\n   */\n  function send(\n    uint32 _domain,\n    bytes32 _transferId,\n    address _callbackAddress,\n    bool _returnSuccess,\n    bytes calldata _returnData\n  ) external onlyConnext {\n    if (_returnData.length == 0) revert PromiseRouter__send_returndataEmpty();\n    if (_callbackAddress == address(0)) revert PromiseRouter__send_callbackEmpty();\n\n    // get remote PromiseRouter address; revert if not found\n    bytes32 remote = _mustHaveRemote(_domain);\n\n    bytes memory message = PromiseMessage.formatPromiseCallback(\n      _transferId,\n      _callbackAddress,\n      _returnSuccess,\n      _returnData\n    );\n\n    xAppConnectionManager.home().dispatch(_domain, remote, message);\n\n    // emit Send event\n    emit Send(_domain, remote, _transferId, _callbackAddress, _returnSuccess, _returnData, message);\n  }\n\n  // ======== External: Handle =========\n\n  /**\n   * @notice Handles an incoming message\n   * @param _origin The origin domain\n   * @param _nonce The unique identifier for the message from origin to destination\n   * @param _sender The sender address\n   * @param _message The message\n   */\n  function handle(\n    uint32 _origin,\n    uint32 _nonce,\n    bytes32 _sender,\n    bytes memory _message\n  ) external override onlyReplica onlyRemoteRouter(_origin, _sender) {\n    // parse transferId, callbackAddress, callData from message\n    bytes29 _msg = _message.ref(0).mustBePromiseCallback();\n\n    bytes32 transferId = _msg.transferId();\n    address callbackAddress = _msg.callbackAddress();\n    bool success = _msg.returnSuccess();\n    bytes memory data = _msg.returnData();\n\n    // store Promise message\n    messageHashes[transferId] = _msg.keccak();\n\n    // emit Receive event\n    emit Receive(_originAndNonce(_origin, _nonce), _origin, transferId, callbackAddress, success, data, _message);\n  }\n\n  /**\n   * @notice Process stored callback function\n   * @param transferId The transferId to process\n   */\n  function process(bytes32 transferId, bytes calldata _message) public nonReentrant {\n    // parse out the return data and callback address from message\n    bytes32 messageHash = messageHashes[transferId];\n    if (messageHash == bytes32(0)) revert PromiseRouter__process_invalidTransferId();\n\n    bytes29 _msg = _message.ref(0).mustBePromiseCallback();\n    if (messageHash != _msg.keccak()) revert PromiseRouter__process_invalidMessage();\n\n    // enforce relayer is whitelisted by calling local connext contract\n    if (!connext.approvedRelayers(msg.sender)) revert PromiseRouter__process_notApprovedRelayer();\n\n    address callbackAddress = _msg.callbackAddress();\n\n    if (!AddressUpgradeable.isContract(callbackAddress)) revert PromiseRouter__process_notContractCallback();\n\n    uint256 callbackFee = callbackFees[transferId];\n\n    // remove message\n    delete messageHashes[transferId];\n\n    // remove callback fees\n    callbackFees[transferId] = 0;\n\n    // execute callback\n    ICallback(callbackAddress).callback(transferId, _msg.returnSuccess(), _msg.returnData());\n\n    emit CallbackExecuted(transferId, msg.sender);\n\n    // Should transfer the stored relayer fee to the msg.sender\n    if (callbackFee > 0) {\n      AddressUpgradeable.sendValue(payable(msg.sender), callbackFee);\n    }\n  }\n\n  /**\n   * @notice This function will be called on the origin domain to init the callback fee while xcall\n   * @param _transferId - The unique identifier of the crosschain transaction\n   */\n  function initCallbackFee(bytes32 _transferId) external payable onlyConnext {\n    if (msg.value == 0) revert PromiseRouter__initCallbackFee_valueIsZero();\n\n    callbackFees[_transferId] += msg.value;\n\n    emit CallbackFeeAdded(_transferId, msg.value, callbackFees[_transferId], msg.sender);\n  }\n\n  /**\n   * @notice This function will be called on the origin domain to increase the callback fee\n   * @param _transferId - The unique identifier of the crosschain transaction\n   */\n  function bumpCallbackFee(bytes32 _transferId) external payable {\n    if (msg.value == 0) revert PromiseRouter__bumpCallbackFee_valueIsZero();\n\n    // use the presence of the message to evaluate if the fee should be bumped.\n    // this is to check that the user is not bumping a transferId that does not exist, or they\n    // are not bumping the fees of a transfer that has already been processed.\n    // the other options are to (a) track process status in a separate mapping (3 mappings updated)\n    // on process) or (b) use the callbackFees mapping and require the callback fees are nonzero\n    // on xcall (preventing 0-fee callbacks)\n    if (messageHashes[_transferId] == bytes32(0)) revert PromiseRouter__bumpCallbackFee_messageUnavailable();\n\n    callbackFees[_transferId] += msg.value;\n\n    emit CallbackFeeAdded(_transferId, msg.value, callbackFees[_transferId], msg.sender);\n  }\n\n  /**\n   * @dev explicit override for compiler inheritance\n   * @return domain of chain on which the contract is deployed\n   */\n  function _localDomain() internal view override(XAppConnectionClient) returns (uint32) {\n    return XAppConnectionClient._localDomain();\n  }\n\n  /**\n   * @notice Internal utility function that combines\n   * `_origin` and `_nonce`.\n   * @dev Both origin and nonce should be less than 2^32 - 1\n   * @param _origin Domain of chain where the transfer originated\n   * @param _nonce The unique identifier for the message from origin to destination\n   * @return Returns (`_origin` << 32) & `_nonce`\n   */\n  function _originAndNonce(uint32 _origin, uint32 _nonce) internal pure returns (uint64) {\n    return (uint64(_origin) << 32) | _nonce;\n  }\n}"
    }
  ]
}