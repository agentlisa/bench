{
  "Title": "Redundant shutdown check in donation",
  "Content": "##### Description\n\n`CNCDistributor` has the `donate()` function with the check protecting from donations if the contract is shutdown.\n\n- https://github.com/ConicFinance/protocol/blob/7a66d26ef84f93059a811a189655e17c11d95f5c/contracts/tokenomics/CNCDistributor.sol#L57-L60\n\nBut in fact, it is still possible to donate via direct CNC transfers to `CNCDistributor`.\nThus, the shutdown check does not make much sense.\n\n\n##### Recommendation\n\nIf blocking CNC transfers to the `CNCDistributor` is necessary, we recommend checking `CNCDistributor` shutdown within the `CNCToken` contract and reverting transfer attempts when shutdown.\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/tokenomics/CNCDistributor.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../libraries/ScaledMath.sol\";\n\nimport \"../../interfaces/tokenomics/ICNCDistributor.sol\";\nimport \"../../interfaces/vendor/ICurveGauge.sol\";\n\ncontract CNCDistributor is ICNCDistributor, Ownable {\n    using SafeERC20 for IERC20;\n    using ScaledMath for uint256;\n\n    IERC20 public constant CNC = IERC20(0x9aE380F0272E2162340a5bB646c354271c0F5cFC);\n    address public constant TREASURY = 0xB27DC5f8286f063F11491c8f349053cB37718bea;\n    ICurveGauge public constant CNC_ETH_GAUGE =\n        ICurveGauge(0x5A8fa46ebb404494D718786e55c4E043337B10bF);\n\n    uint256 internal constant INITIAL_INFLATION_RATE = 240_000 * 1e18;\n    uint256 internal constant INFLATION_RATE_DECAY = 0.3999999 * 1e18;\n    uint256 internal constant INFLATION_RATE_PERIOD = 358 days; // @dev: avoid inflation running over by 1 week\n\n    bool public override isShutdown;\n    uint256 public override gaugeInflationShare = 0.45e18;\n    uint256 public override currentInflationRate;\n    uint256 public override lastInflationRateDecay;\n\n    constructor() {\n        currentInflationRate = INITIAL_INFLATION_RATE / INFLATION_RATE_PERIOD;\n        lastInflationRateDecay = block.timestamp;\n    }\n\n    function topUpGauge() public override {\n        require(!isShutdown, \"contract is shutdown\");\n        uint256 gaugeInflationRate = gaugeInflationShare.mulDown(currentInflationRate);\n\n        (, , uint256 periodFinish, , , ) = CNC_ETH_GAUGE.reward_data(address(CNC));\n        uint256 amount;\n        if (block.timestamp < periodFinish) {\n            uint256 remainder = periodFinish - block.timestamp;\n            amount = (7 days - remainder) * gaugeInflationRate;\n        } else {\n            uint256 diff = block.timestamp - periodFinish;\n            amount = (diff + 7 days) * gaugeInflationRate;\n        }\n\n        require(CNC.balanceOf(address(this)) >= amount, \"Insufficient CNC balance\");\n        CNC.safeApprove(address(CNC_ETH_GAUGE), amount);\n        CNC_ETH_GAUGE.deposit_reward_token(address(CNC), amount);\n\n        emit GaugeTopUp(amount);\n    }\n\n    function donate(uint256 amount) external override {\n        require(!isShutdown, \"contract is shutdown\");\n        CNC.safeTransferFrom(msg.sender, address(this), amount);\n    }\n\n    function withdrawOtherToken(address token) external override onlyOwner {\n        require(token != address(CNC), \"invalid token to send to treasury\");\n        IERC20(token).safeTransfer(TREASURY, IERC20(token).balanceOf(address(this)));\n    }\n\n    function updateInflationShare(uint256 _gaugeInflationShare) external onlyOwner {\n        require(_gaugeInflationShare <= 1e18, \"inflation share can not exceed 100%\");\n        require(\n            _gaugeInflationShare != gaugeInflationShare,\n            \"new inflation shares must be different\"\n        );\n        gaugeInflationShare = _gaugeInflationShare;\n\n        emit InflationSharesUpdated(_gaugeInflationShare);\n    }\n\n    function _executeInflationRateUpdate() internal {\n        if (block.timestamp >= lastInflationRateDecay + INFLATION_RATE_PERIOD) {\n            currentInflationRate = currentInflationRate.mulDown(INFLATION_RATE_DECAY);\n            lastInflationRateDecay = block.timestamp;\n        }\n    }\n\n    function executeInflationRateUpdate() external override onlyOwner {\n        _executeInflationRateUpdate();\n    }\n\n    function setGaugeRewardDistributor(address newDistributor) external onlyOwner {\n        require(isShutdown, \"Distributor is not shutdown\");\n        require(newDistributor != address(0), \"Can not be zero address\");\n        CNC_ETH_GAUGE.set_reward_distributor(address(CNC), newDistributor);\n    }\n\n    function shutdown() external override onlyOwner {\n        require(!isShutdown, \"is already shutdown\");\n        isShutdown = true;\n        CNC.safeTransfer(TREASURY, CNC.balanceOf(address(this)));\n    }\n}"
    }
  ]
}