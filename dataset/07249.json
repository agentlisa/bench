{
  "Title": "[H-09] At the second time the nft is used as collateral to take a loan, the debt repayment via auction fund can be failed when liquidation",
  "Content": "\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/ClearingHouse.sol#L143-L146>\n\nWhen a user transfer an NFT to `CollateralToken` contract, it will toggle the function `CollateralToken.onERC721Received()`. In this function if there didn't exist any `clearingHouse` for the `collateralId`, it will create a new one for that collateral.\n\n```solidity\nif (s.clearingHouse[collateralId] == address(0)) {\n    address clearingHouse = ClonesWithImmutableArgs.clone(\n      s.ASTARIA_ROUTER.BEACON_PROXY_IMPLEMENTATION(),\n      abi.encodePacked(\n        address(s.ASTARIA_ROUTER),\n        uint8(IAstariaRouter.ImplementationType.ClearingHouse),\n        collateralId\n      )\n    );\n\n    s.clearingHouse[collateralId] = clearingHouse;\n  }\n```\n\nThe interesting thing of this technique is: there will be **just one `clearingHouse`** be used for each collateral no matter how many times the collateral is transferred to the contract. Even when the lien is liquidated / fully repayed, the `s.clearingHouse[collateralId]` remain unchanged.\n\nThe question here is any stale datas in `clearingHouse` from the previous time that the nft was used as collateral can affect the behavior of protocol when the nft was transfered to CollateralToken again?\n\nLet take a look at the function [`ClearingHouse._execute()`](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/ClearingHouse.sol#L114). In this function, the implementation uses `safeApprove()` to approve `payment - liquidatorPayment` amount for the `TRANSFER_PROXY`.\n\n```solidity\nERC20(paymentToken).safeApprove(\n  address(ASTARIA_ROUTER.TRANSFER_PROXY()),\n  payment - liquidatorPayment\n);\n```\n\nthe `safeApprove` function will revert if the allowance was set from non-zero value to non-zero value. This will incur some potential risk for the function like example below:\n\n1.  NFT x is transferred to `CollateralToken` to take loans and then it is liquidated.\n2.  At time 10, function `ClearingHouse._execute()` was called and the `payment - liquidatorPayment > totalDebt`. This will the `paymentToken.allowance[clearingHouse][TRANSFER_PROXY] > 0` after the function ended.\n3.  NFT x is transferred to `CollateralToken` for the second time to take a loans and then it is liquidated again.\n4.  At time 15 (> 10), function `ClearingHouse._execute()` was called, but at this time, the `safeApprove` will revert since the previous allowance is different from 0\n\n### Impact\n\nThe debt can be repayed by auction funds when liquidation.\n\n### Recommended Mitigation Steps\n\nConsider to use `approve` instead of `safeApprove`.\n\n**[androolloyd (Astaria) commented](https://github.com/code-423n4/2023-01-astaria-findings/issues/379#issuecomment-1404007645):**\n > We use the solmate library which doesn't seem to have a check for approvals being set to 0.\n\n**[SantiagoGregory (Astaria) confirmed](https://github.com/code-423n4/2023-01-astaria-findings/issues/379)**\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-01-astaria",
  "Code": [
    {
      "filename": "src/ClearingHouse.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/**\n *  █████╗ ███████╗████████╗ █████╗ ██████╗ ██╗ █████╗\n * ██╔══██╗██╔════╝╚══██╔══╝██╔══██╗██╔══██╗██║██╔══██╗\n * ███████║███████╗   ██║   ███████║██████╔╝██║███████║\n * ██╔══██║╚════██║   ██║   ██╔══██║██╔══██╗██║██╔══██║\n * ██║  ██║███████║   ██║   ██║  ██║██║  ██║██║██║  ██║\n * ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═╝\n *\n * Astaria Labs, Inc\n */\n\npragma solidity =0.8.17;\n\nimport {IAstariaRouter} from \"core/interfaces/IAstariaRouter.sol\";\nimport {WETH} from \"solmate/tokens/WETH.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {Clone} from \"clones-with-immutable-args/Clone.sol\";\nimport {IERC1155} from \"core/interfaces/IERC1155.sol\";\nimport {ILienToken} from \"core/interfaces/ILienToken.sol\";\nimport {Bytes32AddressLib} from \"solmate/utils/Bytes32AddressLib.sol\";\nimport {\n  ConduitControllerInterface\n} from \"seaport/interfaces/ConduitControllerInterface.sol\";\nimport {AmountDeriver} from \"seaport/lib/AmountDeriver.sol\";\nimport {Order} from \"seaport/lib/ConsiderationStructs.sol\";\nimport {IERC721Receiver} from \"core/interfaces/IERC721Receiver.sol\";\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\n\ncontract ClearingHouse is AmountDeriver, Clone, IERC1155, IERC721Receiver {\n  using Bytes32AddressLib for bytes32;\n  using SafeTransferLib for ERC20;\n\n  struct ClearingHouseStorage {\n    ILienToken.AuctionData auctionStack;\n  }\n\n  uint256 private constant CLEARING_HOUSE_STORAGE_SLOT =\n    uint256(keccak256(\"xyz.astaria.ClearingHouse.storage.location\")) - 1;\n\n  function ROUTER() public pure returns (IAstariaRouter) {\n    return IAstariaRouter(_getArgAddress(0));\n  }\n\n  function COLLATERAL_ID() public pure returns (uint256) {\n    return _getArgUint256(21);\n  }\n\n  function IMPL_TYPE() public pure returns (uint8) {\n    return _getArgUint8(20);\n  }\n\n  function _getStorage()\n    internal\n    pure\n    returns (ClearingHouseStorage storage s)\n  {\n    uint256 slot = CLEARING_HOUSE_STORAGE_SLOT;\n    assembly {\n      s.slot := slot\n    }\n  }\n\n  function setAuctionData(ILienToken.AuctionData calldata auctionData)\n    external\n  {\n    IAstariaRouter ASTARIA_ROUTER = IAstariaRouter(_getArgAddress(0)); // get the router from the immutable arg\n\n    //only execute from the conduit\n    require(msg.sender == address(ASTARIA_ROUTER.LIEN_TOKEN()));\n\n    ClearingHouseStorage storage s = _getStorage();\n    s.auctionStack = auctionData;\n  }\n\n  function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n    return interfaceId == type(IERC1155).interfaceId;\n  }\n\n  function balanceOf(address account, uint256 id)\n    external\n    view\n    returns (uint256)\n  {\n    return type(uint256).max;\n  }\n\n  function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n    external\n    view\n    returns (uint256[] memory output)\n  {\n    output = new uint256[](accounts.length);\n    for (uint256 i; i < accounts.length; ) {\n      output[i] = type(uint256).max;\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  function setApprovalForAll(address operator, bool approved) external {}\n\n  function isApprovedForAll(address account, address operator)\n    external\n    view\n    returns (bool)\n  {\n    return true;\n  }\n\n  function _execute(\n    address tokenContract, // collateral token sending the fake nft\n    address to, // buyer\n    uint256 encodedMetaData, //retrieve token address from the encoded data\n    uint256 // space to encode whatever is needed,\n  ) internal {\n    IAstariaRouter ASTARIA_ROUTER = IAstariaRouter(_getArgAddress(0)); // get the router from the immutable arg\n\n    ClearingHouseStorage storage s = _getStorage();\n    address paymentToken = bytes32(encodedMetaData).fromLast20Bytes();\n\n    uint256 currentOfferPrice = _locateCurrentAmount({\n      startAmount: s.auctionStack.startAmount,\n      endAmount: s.auctionStack.endAmount,\n      startTime: s.auctionStack.startTime,\n      endTime: s.auctionStack.endTime,\n      roundUp: true //we are a consideration we round up\n    });\n    uint256 payment = ERC20(paymentToken).balanceOf(address(this));\n\n    require(payment >= currentOfferPrice, \"not enough funds received\");\n\n    uint256 collateralId = _getArgUint256(21);\n    // pay liquidator fees here\n\n    ILienToken.AuctionStack[] storage stack = s.auctionStack.stack;\n\n    uint256 liquidatorPayment = ASTARIA_ROUTER.getLiquidatorFee(payment);\n\n    ERC20(paymentToken).safeTransfer(\n      s.auctionStack.liquidator,\n      liquidatorPayment\n    );\n\n    ERC20(paymentToken).safeApprove(\n      address(ASTARIA_ROUTER.TRANSFER_PROXY()),\n      payment - liquidatorPayment\n    );\n\n    ASTARIA_ROUTER.LIEN_TOKEN().payDebtViaClearingHouse(\n      paymentToken,\n      collateralId,\n      payment - liquidatorPayment,\n      s.auctionStack.stack\n    );\n\n    if (ERC20(paymentToken).balanceOf(address(this)) > 0) {\n      ERC20(paymentToken).safeTransfer(\n        ASTARIA_ROUTER.COLLATERAL_TOKEN().ownerOf(collateralId),\n        ERC20(paymentToken).balanceOf(address(this))\n      );\n    }\n    ASTARIA_ROUTER.COLLATERAL_TOKEN().settleAuction(collateralId);\n  }\n\n  function safeTransferFrom(\n    address from, // the from is the offerer\n    address to,\n    uint256 identifier,\n    uint256 amount,\n    bytes calldata data //empty from seaport\n  ) public {\n    //data is empty and useless\n    _execute(from, to, identifier, amount);\n  }\n\n  function safeBatchTransferFrom(\n    address from,\n    address to,\n    uint256[] calldata ids,\n    uint256[] calldata amounts,\n    bytes calldata data\n  ) public {}\n\n  function onERC721Received(\n    address operator_,\n    address from_,\n    uint256 tokenId_,\n    bytes calldata data_\n  ) external override returns (bytes4) {\n    return IERC721Receiver.onERC721Received.selector;\n  }\n\n  function validateOrder(Order memory order) external {\n    IAstariaRouter ASTARIA_ROUTER = IAstariaRouter(_getArgAddress(0));\n    require(msg.sender == address(ASTARIA_ROUTER.COLLATERAL_TOKEN()));\n    Order[] memory listings = new Order[](1);\n    listings[0] = order;\n\n    ERC721(order.parameters.offer[0].token).approve(\n      ASTARIA_ROUTER.COLLATERAL_TOKEN().getConduit(),\n      order.parameters.offer[0].identifierOrCriteria\n    );\n    ASTARIA_ROUTER.COLLATERAL_TOKEN().SEAPORT().validate(listings);\n  }\n\n  function transferUnderlying(\n    address tokenContract,\n    uint256 tokenId,\n    address target\n  ) external {\n    IAstariaRouter ASTARIA_ROUTER = IAstariaRouter(_getArgAddress(0));\n    require(msg.sender == address(ASTARIA_ROUTER.COLLATERAL_TOKEN()));\n    ERC721(tokenContract).safeTransferFrom(address(this), target, tokenId);\n  }\n\n  function settleLiquidatorNFTClaim() external {\n    IAstariaRouter ASTARIA_ROUTER = IAstariaRouter(_getArgAddress(0));\n\n    require(msg.sender == address(ASTARIA_ROUTER.COLLATERAL_TOKEN()));\n    ClearingHouseStorage storage s = _getStorage();\n    ASTARIA_ROUTER.LIEN_TOKEN().payDebtViaClearingHouse(\n      address(0),\n      COLLATERAL_ID(),\n      0,\n      s.auctionStack.stack\n    );\n  }\n}"
    },
    {
      "filename": "src/ClearingHouse.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/**\n *  █████╗ ███████╗████████╗ █████╗ ██████╗ ██╗ █████╗\n * ██╔══██╗██╔════╝╚══██╔══╝██╔══██╗██╔══██╗██║██╔══██╗\n * ███████║███████╗   ██║   ███████║██████╔╝██║███████║\n * ██╔══██║╚════██║   ██║   ██╔══██║██╔══██╗██║██╔══██║\n * ██║  ██║███████║   ██║   ██║  ██║██║  ██║██║██║  ██║\n * ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═╝\n *\n * Astaria Labs, Inc\n */\n\npragma solidity =0.8.17;\n\nimport {IAstariaRouter} from \"core/interfaces/IAstariaRouter.sol\";\nimport {WETH} from \"solmate/tokens/WETH.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {Clone} from \"clones-with-immutable-args/Clone.sol\";\nimport {IERC1155} from \"core/interfaces/IERC1155.sol\";\nimport {ILienToken} from \"core/interfaces/ILienToken.sol\";\nimport {Bytes32AddressLib} from \"solmate/utils/Bytes32AddressLib.sol\";\nimport {\n  ConduitControllerInterface\n} from \"seaport/interfaces/ConduitControllerInterface.sol\";\nimport {AmountDeriver} from \"seaport/lib/AmountDeriver.sol\";\nimport {Order} from \"seaport/lib/ConsiderationStructs.sol\";\nimport {IERC721Receiver} from \"core/interfaces/IERC721Receiver.sol\";\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\n\ncontract ClearingHouse is AmountDeriver, Clone, IERC1155, IERC721Receiver {\n  using Bytes32AddressLib for bytes32;\n  using SafeTransferLib for ERC20;\n\n  struct ClearingHouseStorage {\n    ILienToken.AuctionData auctionStack;\n  }\n\n  uint256 private constant CLEARING_HOUSE_STORAGE_SLOT =\n    uint256(keccak256(\"xyz.astaria.ClearingHouse.storage.location\")) - 1;\n\n  function ROUTER() public pure returns (IAstariaRouter) {\n    return IAstariaRouter(_getArgAddress(0));\n  }\n\n  function COLLATERAL_ID() public pure returns (uint256) {\n    return _getArgUint256(21);\n  }\n\n  function IMPL_TYPE() public pure returns (uint8) {\n    return _getArgUint8(20);\n  }\n\n  function _getStorage()\n    internal\n    pure\n    returns (ClearingHouseStorage storage s)\n  {\n    uint256 slot = CLEARING_HOUSE_STORAGE_SLOT;\n    assembly {\n      s.slot := slot\n    }\n  }\n\n  function setAuctionData(ILienToken.AuctionData calldata auctionData)\n    external\n  {\n    IAstariaRouter ASTARIA_ROUTER = IAstariaRouter(_getArgAddress(0)); // get the router from the immutable arg\n\n    //only execute from the conduit\n    require(msg.sender == address(ASTARIA_ROUTER.LIEN_TOKEN()));\n\n    ClearingHouseStorage storage s = _getStorage();\n    s.auctionStack = auctionData;\n  }\n\n  function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n    return interfaceId == type(IERC1155).interfaceId;\n  }\n\n  function balanceOf(address account, uint256 id)\n    external\n    view\n    returns (uint256)\n  {\n    return type(uint256).max;\n  }\n\n  function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n    external\n    view\n    returns (uint256[] memory output)\n  {\n    output = new uint256[](accounts.length);\n    for (uint256 i; i < accounts.length; ) {\n      output[i] = type(uint256).max;\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  function setApprovalForAll(address operator, bool approved) external {}\n\n  function isApprovedForAll(address account, address operator)\n    external\n    view\n    returns (bool)\n  {\n    return true;\n  }\n\n  function _execute(\n    address tokenContract, // collateral token sending the fake nft\n    address to, // buyer\n    uint256 encodedMetaData, //retrieve token address from the encoded data\n    uint256 // space to encode whatever is needed,\n  ) internal {\n    IAstariaRouter ASTARIA_ROUTER = IAstariaRouter(_getArgAddress(0)); // get the router from the immutable arg\n\n    ClearingHouseStorage storage s = _getStorage();\n    address paymentToken = bytes32(encodedMetaData).fromLast20Bytes();\n\n    uint256 currentOfferPrice = _locateCurrentAmount({\n      startAmount: s.auctionStack.startAmount,\n      endAmount: s.auctionStack.endAmount,\n      startTime: s.auctionStack.startTime,\n      endTime: s.auctionStack.endTime,\n      roundUp: true //we are a consideration we round up\n    });\n    uint256 payment = ERC20(paymentToken).balanceOf(address(this));\n\n    require(payment >= currentOfferPrice, \"not enough funds received\");\n\n    uint256 collateralId = _getArgUint256(21);\n    // pay liquidator fees here\n\n    ILienToken.AuctionStack[] storage stack = s.auctionStack.stack;\n\n    uint256 liquidatorPayment = ASTARIA_ROUTER.getLiquidatorFee(payment);\n\n    ERC20(paymentToken).safeTransfer(\n      s.auctionStack.liquidator,\n      liquidatorPayment\n    );\n\n    ERC20(paymentToken).safeApprove(\n      address(ASTARIA_ROUTER.TRANSFER_PROXY()),\n      payment - liquidatorPayment\n    );\n\n    ASTARIA_ROUTER.LIEN_TOKEN().payDebtViaClearingHouse(\n      paymentToken,\n      collateralId,\n      payment - liquidatorPayment,\n      s.auctionStack.stack\n    );\n\n    if (ERC20(paymentToken).balanceOf(address(this)) > 0) {\n      ERC20(paymentToken).safeTransfer(\n        ASTARIA_ROUTER.COLLATERAL_TOKEN().ownerOf(collateralId),\n        ERC20(paymentToken).balanceOf(address(this))\n      );\n    }\n    ASTARIA_ROUTER.COLLATERAL_TOKEN().settleAuction(collateralId);\n  }\n\n  function safeTransferFrom(\n    address from, // the from is the offerer\n    address to,\n    uint256 identifier,\n    uint256 amount,\n    bytes calldata data //empty from seaport\n  ) public {\n    //data is empty and useless\n    _execute(from, to, identifier, amount);\n  }\n\n  function safeBatchTransferFrom(\n    address from,\n    address to,\n    uint256[] calldata ids,\n    uint256[] calldata amounts,\n    bytes calldata data\n  ) public {}\n\n  function onERC721Received(\n    address operator_,\n    address from_,\n    uint256 tokenId_,\n    bytes calldata data_\n  ) external override returns (bytes4) {\n    return IERC721Receiver.onERC721Received.selector;\n  }\n\n  function validateOrder(Order memory order) external {\n    IAstariaRouter ASTARIA_ROUTER = IAstariaRouter(_getArgAddress(0));\n    require(msg.sender == address(ASTARIA_ROUTER.COLLATERAL_TOKEN()));\n    Order[] memory listings = new Order[](1);\n    listings[0] = order;\n\n    ERC721(order.parameters.offer[0].token).approve(\n      ASTARIA_ROUTER.COLLATERAL_TOKEN().getConduit(),\n      order.parameters.offer[0].identifierOrCriteria\n    );\n    ASTARIA_ROUTER.COLLATERAL_TOKEN().SEAPORT().validate(listings);\n  }\n\n  function transferUnderlying(\n    address tokenContract,\n    uint256 tokenId,\n    address target\n  ) external {\n    IAstariaRouter ASTARIA_ROUTER = IAstariaRouter(_getArgAddress(0));\n    require(msg.sender == address(ASTARIA_ROUTER.COLLATERAL_TOKEN()));\n    ERC721(tokenContract).safeTransferFrom(address(this), target, tokenId);\n  }\n\n  function settleLiquidatorNFTClaim() external {\n    IAstariaRouter ASTARIA_ROUTER = IAstariaRouter(_getArgAddress(0));\n\n    require(msg.sender == address(ASTARIA_ROUTER.COLLATERAL_TOKEN()));\n    ClearingHouseStorage storage s = _getStorage();\n    ASTARIA_ROUTER.LIEN_TOKEN().payDebtViaClearingHouse(\n      address(0),\n      COLLATERAL_ID(),\n      0,\n      s.auctionStack.stack\n    );\n  }\n}"
    }
  ]
}