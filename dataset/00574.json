{
  "Title": "M-6: `LendingPool#flashAction` is broken when trying to refinance position across `LendingPools` due to improper access control",
  "Content": "# Issue M-6: `LendingPool#flashAction` is broken when trying to refinance position across `LendingPools` due to improper access control \n\nSource: https://github.com/sherlock-audit/2023-12-arcadia-judging/issues/145 \n\n## Found by \n0x52\n## Summary\n\nWhen refinancing an account, `LendingPool#flashAction` is used to facilitate the transfer. However due to access restrictions on `updateActionTimestampByCreditor`, the call made from the new creditor will revert, blocking any account transfers. This completely breaks refinancing across lenders which is a core functionality of the protocol.\n\n## Vulnerability Detail\n\n[LendingPool.sol#L564-L579](https://github.com/sherlock-audit/2023-12-arcadia/blob/main/lending-v2/src/LendingPool.sol#L564-L579)\n\n    IAccount(account).updateActionTimestampByCreditor();\n\n    asset.safeTransfer(actionTarget, amountBorrowed);\n\n    {\n        uint256 accountVersion = IAccount(account).flashActionByCreditor(actionTarget, actionData);\n        if (!isValidVersion[accountVersion]) revert LendingPoolErrors.InvalidVersion();\n    }\n\nWe see above that `account#updateActionTimestampByCreditor` is called before `flashActionByCreditor`.\n\n[AccountV1.sol#L671](https://github.com/sherlock-audit/2023-12-arcadia/blob/main/accounts-v2/src/accounts/AccountV1.sol#L671)\n\n    function updateActionTimestampByCreditor() external onlyCreditor updateActionTimestamp { }\n\nWhen we look at this function, it can only be called by the current creditor. When refinancing a position, this function is actually called by the pending creditor since the `flashaction` should originate from there. This will cause the call to revert, making it impossible to refinance across `lendingPools`. \n\n## Impact\n\nRefinancing is impossible\n\n## Code Snippet\n\n[LendingPool.sol#L529-L586](https://github.com/sherlock-audit/2023-12-arcadia/blob/main/lending-v2/src/LendingPool.sol#L529-L586)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n`Account#updateActionTimestampByCreditor()` should be callable by BOTH the current and pending creditor\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  invalid\n\n\n\n**sherlock-admin**\n\nThe protocol team fixed this issue in PR/commit https://github.com/arcadia-finance/lending-v2/pull/133.\n\n**Thomas-Smets**\n\nFix consists out of two PR's:\n- accounts: https://github.com/arcadia-finance/accounts-v2/pull/173\n- lending: https://github.com/arcadia-finance/lending-v2/pull/133\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/137",
  "Code": [
    {
      "filename": "lending-v2/src/LendingPool.sol",
      "content": "/**\n * Created by Pragma Labs\n * SPDX-License-Identifier: BUSL-1.1\n */\npragma solidity 0.8.22;\n\nimport { Creditor } from \"../lib/accounts-v2/src/abstracts/Creditor.sol\";\nimport { DebtToken, ERC20, ERC4626 } from \"./DebtToken.sol\";\nimport { FixedPointMathLib } from \"../lib/solmate/src/utils/FixedPointMathLib.sol\";\nimport { IAccount } from \"./interfaces/IAccount.sol\";\nimport { IFactory } from \"./interfaces/IFactory.sol\";\nimport { ILendingPool } from \"./interfaces/ILendingPool.sol\";\nimport { ITranche } from \"./interfaces/ITranche.sol\";\nimport { LendingPoolErrors } from \"./libraries/Errors.sol\";\nimport { LendingPoolGuardian } from \"./guardians/LendingPoolGuardian.sol\";\nimport { LogExpMath } from \"./libraries/LogExpMath.sol\";\nimport { SafeCastLib } from \"../lib/solmate/src/utils/SafeCastLib.sol\";\nimport { SafeTransferLib } from \"../lib/solmate/src/utils/SafeTransferLib.sol\";\n\n/**\n * @title Arcadia LendingPool.\n * @author Pragma Labs\n * @notice The Lending pool is responsible for the:\n * - Accounting of the liabilities of borrowers via the debtTokens (ERC4626).\n * - Accounting of the liquidity of the Liquidity Providers, via one or more Tranche(s) (ERC4626).\n * - Management of issuing and repaying debt.\n * - Management of interest payments.\n * - Settlement of liquidations and default events.\n */\ncontract LendingPool is LendingPoolGuardian, Creditor, DebtToken, ILendingPool {\n    using FixedPointMathLib for uint256;\n    using SafeTransferLib for ERC20;\n\n    /* //////////////////////////////////////////////////////////////\n                                CONSTANTS\n    ////////////////////////////////////////////////////////////// */\n\n    // Seconds per year, leap years ignored.\n    uint256 internal constant YEARLY_SECONDS = 31_536_000;\n    // Contract address of the Arcadia Account Factory.\n    address internal immutable ACCOUNT_FACTORY;\n    // Contract address of the Liquidator contract.\n    address internal immutable LIQUIDATOR;\n    // The unit for fixed point numbers with 4 decimals precision.\n    uint256 internal constant ONE_4 = 10_000;\n    // Maximum total liquidation penalty, 4 decimal precision.\n    uint256 internal constant MAX_TOTAL_PENALTY = 1100;\n\n    /* //////////////////////////////////////////////////////////////\n                                STORAGE\n    ////////////////////////////////////////////////////////////// */\n\n    // The current interest rate, 18 decimals precision.\n    uint80 public interestRate;\n    // The interest rate when utilisation is 0.\n    // 18 decimals precision.\n    uint72 internal baseRatePerYear;\n    // The slope of the first curve, defined as the delta in interest rate for a delta in utilisation of 100%.\n    // 18 decimals precision.\n    uint72 internal lowSlopePerYear;\n    // The slope of the second curve, defined as the delta in interest rate for a delta in utilisation of 100%.\n    // 18 decimals precision.\n    uint72 internal highSlopePerYear;\n    // The optimal capital utilisation, where we go from the first curve to the steeper second curve.\n    // 4 decimal precision.\n    uint16 internal utilisationThreshold;\n    // Last timestamp that interests were realized.\n    uint32 internal lastSyncedTimestamp;\n    // Fee issued upon taking debt, 4 decimals precision (10 equals 0.001 or 0.1%), capped at 255 (2.55%).\n    uint8 public originationFee;\n    // Sum of all the interest weights of the tranches + treasury.\n    uint24 internal totalInterestWeight;\n    // Fraction (interestWeightTreasury / totalInterestWeight) of the interest fees that go to the treasury.\n    uint16 internal interestWeightTreasury;\n    // Fraction (liquidationWeightTreasury / totalLiquidationWeight) of the liquidation fees that goes to the treasury.\n    uint16 internal liquidationWeightTreasury;\n    // Fraction (liquidationWeightTranche / totalLiquidationWeight) of the liquidation fees that goes to the most Junior Tranche.\n    uint16 internal liquidationWeightTranche;\n\n    // Total amount of `underlying asset` that is claimable by the LPs. Does not take into account pending interests.\n    uint128 internal totalRealisedLiquidity;\n    // The minimum amount of collateral that must be held in an Account before a position can be opened.\n    uint96 internal minimumMargin;\n\n    // Address of the protocol treasury.\n    address internal treasury;\n    // Number of auctions that are currently in progress.\n    uint16 internal auctionsInProgress;\n    // Maximum amount of `underlying asset` that is paid as fee to the initiator/terminator of a liquidation.\n    uint80 internal maxReward;\n    // Minimum initiation and termination reward, relative to the minimumMargin, 4 decimal precision.\n    uint16 internal minRewardWeight;\n    // Fee paid to the Liquidation Initiator.\n    // Defined as a fraction of the openDebt with 4 decimals precision.\n    // Absolute fee can be further capped to a max amount by the creditor.\n    uint16 internal initiationWeight;\n    // Penalty the Account owner has to pay to the Creditor on top of the open Debt for being liquidated.\n    // Defined as a fraction of the openDebt with 4 decimals precision.\n    uint16 internal penaltyWeight;\n    // Fee paid to the address that is ending an auction.\n    // Defined as a fraction of the openDebt with 4 decimals precision.\n    uint16 internal terminationWeight;\n\n    // Array of the interest weights of each Tranche.\n    // Fraction (interestWeightTranches[i] / totalInterestWeight) of the interest fees that go to Tranche i.\n    uint16[] internal interestWeightTranches;\n    // Array of the contract addresses of the Tranches.\n    address[] internal tranches;\n\n    // Map tranche => status.\n    mapping(address => bool) internal isTranche;\n    // Map tranche => interestWeight.\n    // Fraction (interestWeightTranches[i] / totalInterestWeight) of the interest fees that go to Tranche i.\n    mapping(address => uint256) internal interestWeight;\n    // Map tranche => realisedLiquidity.\n    // Amount of `underlying asset` that is claimable by the liquidity providers.\n    // Does not take into account pending interests.\n    mapping(address => uint256) internal realisedLiquidityOf;\n    // Map Account => owner => beneficiary => amount.\n    // Stores the credit allowances for a beneficiary per Account and per Owner.\n    mapping(address => mapping(address => mapping(address => uint256))) public creditAllowance;\n\n    /* //////////////////////////////////////////////////////////////\n                                EVENTS\n    ////////////////////////////////////////////////////////////// */\n\n    event AuctionStarted(address indexed account, address indexed creditor, uint128 openDebt);\n    event AuctionFinished(\n        address indexed account,\n        address indexed creditor,\n        uint256 startDebt,\n        uint256 initiationReward,\n        uint256 terminationReward,\n        uint256 penalty,\n        uint256 badDebt,\n        uint256 surplus\n    );\n    event Borrow(\n        address indexed account, address indexed by, address to, uint256 amount, uint256 fee, bytes3 indexed referrer\n    );\n    event CreditApproval(address indexed account, address indexed owner, address indexed beneficiary, uint256 amount);\n    event InterestSynced(uint256 interest);\n    event InterestWeightTrancheUpdated(address indexed tranche, uint8 indexed trancheIndex, uint16 interestWeight);\n    event LiquidationWeightTrancheUpdated(uint16 liquidationWeight);\n    event PoolStateUpdated(uint256 totalDebt, uint256 totalLiquidity, uint80 interestRate);\n    event Repay(address indexed account, address indexed from, uint256 amount);\n    event TranchePopped(address tranche);\n    event TreasuryWeightsUpdated(uint16 interestWeight, uint16 liquidationWeight);\n\n    /* //////////////////////////////////////////////////////////////\n                                MODIFIERS\n    ////////////////////////////////////////////////////////////// */\n\n    /**\n     * @notice Checks if caller is the Liquidator.\n     */\n    modifier onlyLiquidator() {\n        if (LIQUIDATOR != msg.sender) revert LendingPoolErrors.Unauthorized();\n        _;\n    }\n\n    /**\n     * @notice Checks if caller is a Tranche.\n     */\n    modifier onlyTranche() {\n        if (!isTranche[msg.sender]) revert LendingPoolErrors.Unauthorized();\n        _;\n    }\n\n    /**\n     * @notice Syncs interest to LPs and treasury and updates the interest rate.\n     */\n    modifier processInterests() {\n        _syncInterests();\n        _;\n        // _updateInterestRate() modifies the state (effect), but can safely be called after interactions.\n        // Cannot be exploited by re-entrancy attack.\n        _updateInterestRate(realisedDebt, totalRealisedLiquidity);\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                                CONSTRUCTOR\n    ////////////////////////////////////////////////////////////// */\n\n    /**\n     * @notice The constructor for a lending pool.\n     * @param riskManager_ The address of the new Risk Manager.\n     * @param asset_ The underlying ERC20 token of the Lending Pool.\n     * @param treasury_ The address of the protocol treasury.\n     * @param accountFactory The contract address of the Arcadia Account Factory.\n     * @param liquidator The contract address of the Liquidator.\n     * @dev The name and symbol of the DebtToken are automatically generated, based on the name and symbol of the underlying token.\n     */\n    constructor(address riskManager_, ERC20 asset_, address treasury_, address accountFactory, address liquidator)\n        LendingPoolGuardian()\n        Creditor(riskManager_)\n        DebtToken(asset_)\n    {\n        treasury = treasury_;\n        ACCOUNT_FACTORY = accountFactory;\n        LIQUIDATOR = liquidator;\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                            TRANCHES LOGIC\n    ////////////////////////////////////////////////////////////// */\n\n    /**\n     * @notice Adds a tranche to the Lending Pool.\n     * @param tranche The address of the Tranche.\n     * @param interestWeight_ The interest weight of the specific Tranche.\n     * @dev The order of the tranches is important, the most senior tranche is added first at index 0, the most junior at the last index.\n     * @dev Each Tranche is an ERC4626 contract.\n     * @dev The interest weight of each Tranche determines the relative share of the yield (interest payments) that goes to its Liquidity providers.\n     */\n    function addTranche(address tranche, uint16 interestWeight_) external onlyOwner processInterests {\n        if (auctionsInProgress > 0) revert LendingPoolErrors.AuctionOngoing();\n        if (isTranche[tranche]) revert LendingPoolErrors.TrancheAlreadyExists();\n\n        totalInterestWeight += interestWeight_;\n        interestWeightTranches.push(interestWeight_);\n        interestWeight[tranche] = interestWeight_;\n\n        uint8 trancheIndex = uint8(tranches.length);\n        tranches.push(tranche);\n        isTranche[tranche] = true;\n\n        emit InterestWeightTrancheUpdated(tranche, trancheIndex, interestWeight_);\n    }\n\n    /**\n     * @notice Changes the interest weight of a specific Tranche.\n     * @param index The index of the Tranche for which a new interest weight is being set.\n     * @param interestWeight_ The new interest weight of the Tranche at the index.\n     * @dev The interest weight of each Tranche determines the relative share of yield (interest payments) that goes to its Liquidity providers.\n     */\n    function setInterestWeightTranche(uint256 index, uint16 interestWeight_) external onlyOwner processInterests {\n        if (index >= tranches.length) revert LendingPoolErrors.NonExistingTranche();\n        totalInterestWeight = totalInterestWeight - interestWeightTranches[index] + interestWeight_;\n        interestWeightTranches[index] = interestWeight_;\n        address tranche = tranches[index];\n        interestWeight[tranche] = interestWeight_;\n\n        emit InterestWeightTrancheUpdated(tranche, uint8(index), interestWeight_);\n    }\n\n    /**\n     * @notice Changes the liquidation weight of the most Junior Tranche.\n     * @param liquidationWeight The new liquidation weight of the Tranche at the highest index.\n     * @dev The liquidation weight determines the relative share of liquidation fees that goes to the most Junior Tranche.\n     */\n    function setLiquidationWeightTranche(uint16 liquidationWeight) external onlyOwner {\n        emit LiquidationWeightTrancheUpdated(liquidationWeightTranche = liquidationWeight);\n    }\n\n    /**\n     * @notice Removes the Tranche at the last index (most junior).\n     * @param index The index of the last Tranche.\n     * @param tranche The address of the last Tranche.\n     * @dev This function can only be called by the function _processDefault(uint256 assets),\n     * when there is a default as big as (or bigger than) the complete amount of liquidity of the most junior Tranche.\n     * @dev Passing the input parameters to the function saves gas compared to reading the address and index of the last Tranche from storage.\n     * No need to check if index and Tranche are indeed of the last tranche since function is only called by _processDefault.\n     */\n    function _popTranche(uint256 index, address tranche) internal {\n        unchecked {\n            totalInterestWeight -= interestWeightTranches[index];\n        }\n        isTranche[tranche] = false;\n        interestWeightTranches.pop();\n        tranches.pop();\n        interestWeight[tranche] = 0;\n\n        emit TranchePopped(tranche);\n    }\n\n    /* ///////////////////////////////////////////////////////////////\n                    TREASURY FEE CONFIGURATION\n    ////////////////////////////////////////////////////////////// */\n\n    /**\n     * @notice Changes the interest and liquidation weight of the Treasury.\n     * @param interestWeight_ The new interestWeight of the treasury.\n     * @param liquidationWeight The new liquidationWeight of the treasury.\n     * @dev The interestWeight determines the relative share of the yield (interest payments) that goes to the protocol treasury.\n     * @dev Setting interestWeightTreasury to a very high value will cause the treasury to collect all interest fees from that moment on.\n     * Although this will affect the future profits of liquidity providers, no funds nor realized interest are at risk for LPs.\n     */\n    function setTreasuryWeights(uint16 interestWeight_, uint16 liquidationWeight) external onlyOwner processInterests {\n        totalInterestWeight = totalInterestWeight - interestWeightTreasury + interestWeight_;\n\n        emit TreasuryWeightsUpdated(\n            interestWeightTreasury = interestWeight_, liquidationWeightTreasury = liquidationWeight\n        );\n    }\n\n    /**\n     * @notice Sets new treasury address.\n     * @param treasury_ The new address of the treasury.\n     */\n    function setTreasury(address treasury_) external onlyOwner {\n        treasury = treasury_;\n    }\n\n    /**\n     * @notice Sets the new origination fee.\n     * @param originationFee_ The new origination fee.\n     * @dev originationFee is limited by being a uint8 -> max value is 2.55%\n     * 4 decimal precision (10 = 0.1%).\n     */\n    function setOriginationFee(uint8 originationFee_) external onlyOwner {\n        originationFee = originationFee_;\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    ////////////////////////////////////////////////////////////// */\n\n    /**\n     * @notice Deposit assets in the Lending Pool.\n     * @param assets The amount of assets of the underlying ERC20 tokens being deposited.\n     * @param from The address of the Liquidity Provider who deposits the underlying ERC20 token via a Tranche.\n     * @dev This function can only be called by Tranches.\n     */\n    function depositInLendingPool(uint256 assets, address from)\n        external\n        whenDepositNotPaused\n        onlyTranche\n        processInterests\n    {\n        // Need to transfer before minting or ERC777s could reenter.\n        // Address(this) is trusted -> no risk on re-entrancy attack after transfer.\n        asset.safeTransferFrom(from, address(this), assets);\n\n        unchecked {\n            realisedLiquidityOf[msg.sender] += assets;\n            totalRealisedLiquidity = SafeCastLib.safeCastTo128(assets + totalRealisedLiquidity);\n        }\n    }\n\n    /**\n     * @notice Donate assets to the Lending Pool.\n     * @param trancheIndex The index of the tranche to donate to.\n     * @param assets The amount of assets of the underlying ERC20 tokens being deposited.\n     * @dev Can be used by anyone to donate assets to the Lending Pool.\n     * It is supposed to serve as a way to compensate the jrTranche after an\n     * auction didn't get sold and was manually liquidated after cutoffTime.\n     * @dev Inflation attacks by the first depositor in the Tranches have to be prevented with virtual assets/shares.\n     */\n    function donateToTranche(uint256 trancheIndex, uint256 assets) external whenDepositNotPaused processInterests {\n        if (assets == 0) revert LendingPoolErrors.ZeroAmount();\n\n        address tranche = tranches[trancheIndex];\n\n        // Need to transfer before donating or ERC777s could reenter.\n        // Address(this) is trusted -> no risk on re-entrancy attack after transfer.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        unchecked {\n            realisedLiquidityOf[tranche] += assets; //[̲̅$̲̅(̲̅ ͡° ͜ʖ ͡°̲̅)̲̅$̲̅]\n            totalRealisedLiquidity = SafeCastLib.safeCastTo128(assets + totalRealisedLiquidity);\n        }\n    }\n\n    /**\n     * @notice Withdraw assets from the Lending Pool.\n     * @param assets The amount of assets of the underlying ERC20 tokens being withdrawn.\n     * @param receiver The address of the receiver of the underlying ERC20 tokens.\n     * @dev This function can be called by anyone with an open balance (realisedLiquidityOf[address] bigger than 0),\n     * which can be both Tranches as other address (treasury, Liquidation Initiators, Liquidated Account Owner...).\n     */\n    function withdrawFromLendingPool(uint256 assets, address receiver)\n        external\n        whenWithdrawNotPaused\n        processInterests\n    {\n        if (realisedLiquidityOf[msg.sender] < assets) revert LendingPoolErrors.AmountExceedsBalance();\n\n        unchecked {\n            realisedLiquidityOf[msg.sender] -= assets;\n            totalRealisedLiquidity = SafeCastLib.safeCastTo128(totalRealisedLiquidity - assets);\n        }\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                            LENDING LOGIC\n    ////////////////////////////////////////////////////////////// */\n\n    /**\n     * @notice Approve a beneficiary to take out debt against an Arcadia Account.\n     * @param beneficiary The address of the beneficiary who can take out debt backed by an Arcadia Account.\n     * @param amount The amount of underlying ERC20 tokens to be lent out.\n     * @param account The address of the Arcadia Account backing the debt.\n     */\n    function approveBeneficiary(address beneficiary, uint256 amount, address account) external {\n        // If Account is not an actual address of an Arcadia Account, ownerOfAccount(address) will return the zero address.\n        if (IFactory(ACCOUNT_FACTORY).ownerOfAccount(account) != msg.sender) revert LendingPoolErrors.Unauthorized();\n\n        creditAllowance[account][msg.sender][beneficiary] = amount;\n\n        emit CreditApproval(account, msg.sender, beneficiary, amount);\n    }\n\n    /**\n     * @notice Takes out debt backed by collateral in an Arcadia Account.\n     * @param amount The amount of underlying ERC20 tokens to be lent out.\n     * @param account The address of the Arcadia Account backing the debt.\n     * @param to The address who receives the lent out underlying tokens.\n     * @param referrer A unique identifier of the referrer, who will receive part of the fees generated by this transaction.\n     * @dev The sender might be different than the owner if they have the proper allowances.\n     */\n    function borrow(uint256 amount, address account, address to, bytes3 referrer)\n        external\n        whenBorrowNotPaused\n        processInterests\n    {\n        // If Account is not an actual address of an Account, ownerOfAccount(address) will return the zero address.\n        address accountOwner = IFactory(ACCOUNT_FACTORY).ownerOfAccount(account);\n        if (accountOwner == address(0)) revert LendingPoolErrors.IsNotAnAccount();\n\n        uint256 amountWithFee = amount + amount.mulDivUp(originationFee, ONE_4);\n\n        // Check allowances to take debt.\n        if (accountOwner != msg.sender) {\n            uint256 allowed = creditAllowance[account][accountOwner][msg.sender];\n            if (allowed != type(uint256).max) {\n                creditAllowance[account][accountOwner][msg.sender] = allowed - amountWithFee;\n            }\n        }\n\n        // Mint debt tokens to the Account.\n        _deposit(amountWithFee, account);\n\n        // Add origination fee to the treasury.\n        unchecked {\n            if (amountWithFee - amount > 0) {\n                totalRealisedLiquidity = SafeCastLib.safeCastTo128(amountWithFee + totalRealisedLiquidity - amount);\n                realisedLiquidityOf[treasury] += amountWithFee - amount;\n            }\n        }\n\n        // UpdateOpenPosition checks that the Account indeed has opened a margin account for this Lending Pool and\n        // checks that it is still healthy after the debt is increased with amountWithFee.\n        // Reverts in Account if one of the checks fails.\n        uint256 accountVersion = IAccount(account).increaseOpenPosition(maxWithdraw(account));\n        if (!isValidVersion[accountVersion]) revert LendingPoolErrors.InvalidVersion();\n\n        // Transfer fails if there is insufficient liquidity in the pool.\n        asset.safeTransfer(to, amount);\n\n        emit Borrow(account, msg.sender, to, amount, amountWithFee - amount, referrer);\n    }\n\n    /**\n     * @notice Repays debt.\n     * @param amount The amount of underlying ERC20 tokens to be repaid.\n     * @param account The contract address of the Arcadia Account backing the debt.\n     * @dev if Account is not an actual address of an Arcadia Account, maxWithdraw(account) will always return 0.\n     * Function will not revert, but amount is always 0.\n     * @dev Anyone (EOAs and contracts) can repay debt in the name of an Account.\n     */\n    function repay(uint256 amount, address account) external whenRepayNotPaused processInterests {\n        uint256 accountDebt = maxWithdraw(account);\n        amount = accountDebt > amount ? amount : accountDebt;\n\n        // Need to transfer before burning debt or ERC777s could reenter.\n        // Address(this) is trusted -> no risk on re-entrancy attack after transfer.\n        asset.safeTransferFrom(msg.sender, address(this), amount);\n\n        _withdraw(amount, address(this), account);\n\n        emit Repay(account, msg.sender, amount);\n    }\n\n    /**\n     * @notice Repays debt via an auction.\n     * @param startDebt The amount of debt of the Account the moment the liquidation was initiated.\n     * @param minimumMargin_ The minimum margin of the Account.\n     * @param amount The amount repaid by a bidder during the auction.\n     * @param account The contract address of the Arcadia Account backing the debt.\n     * @param bidder The address of the bidder.\n     * @return earlyTerminate Bool indicating whether the full amount of debt was repaid.\n     * @dev This function allows a liquidator to repay a specified amount of debt for a user.\n     */\n    function auctionRepay(uint256 startDebt, uint256 minimumMargin_, uint256 amount, address account, address bidder)\n        external\n        whenLiquidationNotPaused\n        onlyLiquidator\n        processInterests\n        returns (bool earlyTerminate)\n    {\n        // Need to transfer before burning debt or ERC777s could reenter.\n        // Address(this) is trusted -> no risk on re-entrancy attack after transfer.\n        asset.safeTransferFrom(bidder, address(this), amount);\n\n        uint256 accountDebt = maxWithdraw(account);\n        if (accountDebt == 0) revert LendingPoolErrors.IsNotAnAccountWithDebt();\n        if (accountDebt <= amount) {\n            // The amount recovered by selling assets during the auction is bigger than the total debt of the Account.\n            // -> Terminate the auction and make the surplus available to the Account-Owner.\n            earlyTerminate = true;\n            unchecked {\n                _settleLiquidationHappyFlow(account, startDebt, minimumMargin_, bidder, (amount - accountDebt));\n            }\n            amount = accountDebt;\n        }\n\n        _withdraw(amount, address(this), account);\n\n        emit Repay(account, bidder, amount);\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                        LEVERAGED ACTIONS LOGIC\n    ////////////////////////////////////////////////////////////// */\n\n    /**\n     * @notice Execute and interact with external logic on leverage.\n     * @param amountBorrowed The amount of underlying ERC20 tokens to be lent out.\n     * @param account The address of the Arcadia Account backing the debt.\n     * @param actionTarget The address of the Action Target to call.\n     * @param actionData A bytes object containing three actionAssetData structs, an address array and a bytes array.\n     * @param referrer A unique identifier of the referrer, who will receive part of the fees generated by this transaction.\n     * @dev The sender might be different than the owner if they have the proper allowances.\n     * @dev accountManagementAction() works similar to flash loans, this function optimistically calls external logic and checks for the Account state at the very end.\n     */\n    function flashAction(\n        uint256 amountBorrowed,\n        address account,\n        address actionTarget,\n        bytes calldata actionData,\n        bytes3 referrer\n    ) external whenBorrowNotPaused processInterests {\n        // If Account is not an actual address of a Account, ownerOfAccount(address) will return the zero address.\n        address accountOwner = IFactory(ACCOUNT_FACTORY).ownerOfAccount(account);\n        if (accountOwner == address(0)) revert LendingPoolErrors.IsNotAnAccount();\n\n        uint256 amountBorrowedWithFee = amountBorrowed + amountBorrowed.mulDivUp(originationFee, ONE_4);\n\n        // Check allowances to take debt.\n        if (accountOwner != msg.sender) {\n            // Since calling accountManagementAction() gives the sender full control over all assets in the Account,\n            // Only Beneficiaries with maximum allowance can call the flashAction function.\n            if (creditAllowance[account][accountOwner][msg.sender] != type(uint256).max) {\n                revert LendingPoolErrors.Unauthorized();\n            }\n        }\n\n        // Mint debt tokens to the Account, debt must be minted before the actions in the Account are performed.\n        _deposit(amountBorrowedWithFee, account);\n\n        // Add origination fee to the treasury.\n        unchecked {\n            if (amountBorrowedWithFee - amountBorrowed > 0) {\n                totalRealisedLiquidity += SafeCastLib.safeCastTo128(amountBorrowedWithFee - amountBorrowed);\n                realisedLiquidityOf[treasury] += amountBorrowedWithFee - amountBorrowed;\n            }\n        }\n\n        // Need to update the actionTimestamp before transferring tokens,\n        // or ERC777s could reenter to frontrun Account transfers.\n        IAccount(account).updateActionTimestampByCreditor();\n\n        // Send Borrowed funds to the actionTarget.\n        asset.safeTransfer(actionTarget, amountBorrowed);\n\n        // The Action Target will use the borrowed funds (optionally with additional assets withdrawn from the Account)\n        // to execute one or more actions (swap, deposit, mint...).\n        // Next the action Target will deposit any of the remaining funds or any of the recipient token\n        // resulting from the actions back into the Account.\n        // As last step, after all assets are deposited back into the Account a final health check is done:\n        // The Collateral Value of all assets in the Account is bigger than the total liabilities against the Account (including the debt taken during this function).\n        // flashActionByCreditor also checks that the Account indeed has opened a margin account for this Lending Pool.\n        {\n            uint256 accountVersion = IAccount(account).flashActionByCreditor(actionTarget, actionData);\n            if (!isValidVersion[accountVersion]) revert LendingPoolErrors.InvalidVersion();\n        }\n\n        unchecked {\n            emit Borrow(\n                account, msg.sender, actionTarget, amountBorrowed, amountBorrowedWithFee - amountBorrowed, referrer\n            );\n        }\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    ////////////////////////////////////////////////////////////// */\n\n    /**\n     * @notice Returns the total amount of outstanding debt in the underlying asset.\n     * @return totalDebt The total debt in underlying assets.\n     */\n    function totalAssets() public view override returns (uint256 totalDebt) {\n        // Avoid a second calculation of unrealised debt (expensive)\n        // if interests are already synced this block.\n        if (lastSyncedTimestamp != uint32(block.timestamp)) {\n            totalDebt = realisedDebt + calcUnrealisedDebt();\n        } else {\n            totalDebt = realisedDebt;\n        }\n    }\n\n    /**\n     * @notice Returns the total redeemable amount of liquidity in the underlying asset.\n     * @return totalLiquidity_ The total redeemable amount of liquidity in the underlying asset.\n     */\n    function totalLiquidity() external view returns (uint256 totalLiquidity_) {\n        // Avoid a second calculation of unrealised debt (expensive)\n        // if interests are already synced this block.\n        if (lastSyncedTimestamp != uint32(block.timestamp)) {\n            // The total liquidity equals the sum of the realised liquidity, and the pending interests.\n            unchecked {\n                totalLiquidity_ = totalRealisedLiquidity + calcUnrealisedDebt();\n            }\n        } else {\n            totalLiquidity_ = totalRealisedLiquidity;\n        }\n    }\n\n    /**\n     * @notice Returns the redeemable amount of liquidity in the underlying asset of an address.\n     * @param owner_ The address of the liquidity provider.\n     * @return assets The redeemable amount of liquidity in the underlying asset.\n     * @dev This function syncs the interests to prevent calculating UnrealisedDebt twice when depositing/withdrawing through the Tranches.\n     * @dev After calling this function, the interest rate will not be updated until the next processInterests() call.\n     */\n    function liquidityOfAndSync(address owner_) external returns (uint256 assets) {\n        _syncInterests();\n        assets = realisedLiquidityOf[owner_];\n    }\n\n    /**\n     * @notice Returns the redeemable amount of liquidity in the underlying asset of an address.\n     * @param owner_ The address of the liquidity provider.\n     * @return assets The redeemable amount of liquidity in the underlying asset.\n     */\n    function liquidityOf(address owner_) external view returns (uint256 assets) {\n        // Avoid a second calculation of unrealised debt (expensive).\n        // if interests are already synced this block.\n        if (lastSyncedTimestamp != uint32(block.timestamp)) {\n            // The total liquidity of a tranche equals the sum of the realised liquidity\n            // of the tranche, and its pending interests.\n            uint256 interest = calcUnrealisedDebt().mulDivDown(interestWeight[owner_], totalInterestWeight);\n            unchecked {\n                assets = realisedLiquidityOf[owner_] + interest;\n            }\n        } else {\n            assets = realisedLiquidityOf[owner_];\n        }\n    }\n\n    /**\n     * @notice Skims any surplus funds in the LendingPool to the treasury.\n     * @dev In normal conditions (when there are no ongoing auctions), the total Claimable Liquidity should be equal\n     * to the sum of the available funds (the balanceOf() the underlying asset) in the pool and the total open debt.\n     * In practice the actual sum of available funds and total open debt will always be bigger than the total Claimable Liquidity.\n     * This because of the rounding errors of the ERC4626 calculations (conversions between assets and shares),\n     * or because someone accidentally sent funds directly to the"
    }
  ]
}