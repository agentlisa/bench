{
  "Title": "H-2: CurveTricryptoOracle incorrectly assumes that WETH is always the last token in the pool which leads to bad LP pricing",
  "Content": "# Issue H-2: CurveTricryptoOracle incorrectly assumes that WETH is always the last token in the pool which leads to bad LP pricing \n\nSource: https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/98 \n\n## Found by \n0x52, Vagner\n\nCurveTricryptoOracle assumes that WETH is always the last token in the pool (`tokens[2]`). This is incorrect for a majority of tricrypto pools and will lead to LP being highly overvalued.\n\n## Vulnerability Detail\n\n[CurveTricryptoOracle.sol#L53-L63](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/oracle/CurveTricryptoOracle.sol#L53-L63)\n\n        if (tokens.length == 3) {\n            /// tokens[2] is WETH\n            uint256 ethPrice = base.getPrice(tokens[2]);\n            return\n                (lpPrice(\n                    virtualPrice,\n                    base.getPrice(tokens[1]),\n                    ethPrice,\n                    base.getPrice(tokens[0])\n                ) * 1e18) / ethPrice;\n        }\n\nWhen calculating LP prices, CurveTricryptoOracle#getPrice always assumes that WETH is the second token in the pool. This isn't the case which will cause the LP to be massively overvalued.\n\nThere are 6 tricrypto pools currently deployed on mainnet. Half of these pools have an asset other than WETH as token[2]:\n\n        0x4ebdf703948ddcea3b11f675b4d1fba9d2414a14 - CRV\n        0x5426178799ee0a0181a89b4f57efddfab49941ec - INV\n        0x2889302a794da87fbf1d6db415c1492194663d13 - wstETH\n\n## Impact\n\nLP will be massively overvalued leading to overborrowing and protocol insolvency\n\n## Code Snippet\n\n[CurveTricryptoOracle.sol#L48-L65](https://github.com/sherlock-audit/2023-07-blueberry/blob/main/blueberry-core/contracts/oracle/CurveTricryptoOracle.sol#L48-L65)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThere is no need to assume that WETH is the last token. Simply pull the price for each asset and input it into lpPrice.\n\n\n\n\n\n## Discussion\n\n**IAm0x52**\n\nEscalate\n\nThis is not a dupe of #105. This will cause a large number of tricrypto pools to be overvalued which presents a serious risk to the protocol.\n\n**sherlock-admin2**\n\n > Escalate\n> \n> This is not a dupe of #105. This will cause a large number of tricrypto pools to be overvalued which presents a serious risk to the protocol.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Shogoki**\n\nAgree. \nThis is not a duplicate of #105 \nThis can become its own main report and #20 is a duplicate of it.\n\nThere were some issues with (de)duplication. I would resolve like this.\n#98 is the duplicate with #20 \n#105 is duplicate with #42 \n\n**hrishibhat**\n\nResult:\nHigh \nHas duplicates\nThis is a valid high issue based on the description\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [IAm0x52](https://github.com/sherlock-audit/2023-07-blueberry-judging/issues/98/#issuecomment-1694746548): accepted\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/104",
  "Code": [
    {
      "filename": "blueberry-core/contracts/oracle/CurveTricryptoOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"./CurveBaseOracle.sol\";\n\n/// @title Curve Volatile Oracle\n/// @author BlueberryProtocol \n/// @notice Oracle contract which privides price feeds of Curve volatile pool LP tokens\ncontract CurveTricryptoOracle is CurveBaseOracle {\n    \n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n    \n    /// @notice Constructor initializes the CurveBaseOracle with the provided parameters.\n    /// @param base_ The address of the base oracle.\n    /// @param addressProvider_ The address of the curve address provider.\n    constructor(\n        IBaseOracle base_,\n        ICurveAddressProvider addressProvider_\n    ) CurveBaseOracle(base_, addressProvider_) {}\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Overrides the base oracle's reentrancy check.\n    /// @param _pool The address of the pool to check.\n    /// @param (unnamed) Unused parameter for overriding.\n    function _checkReentrant(address _pool, uint256) internal override {\n        ICurvePool pool = ICurvePool(_pool);\n        pool.claim_admin_fees();\n    }\n\n    /// @notice Returns the USD value of the specified Curve LP token with 18 decimals of precision.\n    /// @dev If the length of tokens is not 3, the function will revert.\n    /// @param crvLp The ERC-20 Curve LP token address.\n    /// @return The USD value of the Curve LP token.\n    function getPrice(address crvLp) external override returns (uint256) {\n        (address pool, address[] memory tokens, uint256 virtualPrice) = _getPoolInfo(crvLp);\n        _checkReentrant(pool, tokens.length);\n\n        /// Check if the token list length is 3 (tricrypto)\n        if (tokens.length == 3) {\n            /// tokens[2] is WETH\n            uint256 ethPrice = base.getPrice(tokens[2]);\n            return\n                (lpPrice(\n                    virtualPrice,\n                    base.getPrice(tokens[1]),\n                    ethPrice,\n                    base.getPrice(tokens[0])\n                ) * 1e18) / ethPrice;\n        }\n        revert BlueBerryErrors.ORACLE_NOT_SUPPORT_LP(crvLp);\n    }\n\n    /// @dev Calculates the LP price using provided token prices and virtual price.\n    /// @param virtualPrice The virtual price from the pool.\n    /// @param p1 Price of the first token.\n    /// @param p2 Price of the second token (usually ETH).\n    /// @param p3 Price of the third token.\n    /// @return The calculated LP price.\n    function lpPrice(\n        uint256 virtualPrice,\n        uint256 p1,\n        uint256 p2,\n        uint256 p3\n    ) internal pure returns (uint256) {\n        return (3 * virtualPrice * cubicRoot(((p1 * p2) / 1e18) * p3)) / 1e18;\n    }\n\n    /// @dev Calculates the cubic root of the provided value using the Newton-Raphson method.\n    /// @param x The value to find the cubic root for.\n    /// @return The calculated cubic root.\n\n    function cubicRoot(uint256 x) internal pure returns (uint256) {\n        uint256 D = x / 1e18;\n        for (uint256 i; i < 255; ) {\n            uint256 D_prev = D;\n            D = (D * (2e18 + ((((x / D) * 1e18) / D) * 1e18) / D)) / (3e18);\n            uint256 diff = (D > D_prev) ? D - D_prev : D_prev - D;\n            if (diff < 2 || diff * 1e18 < D) return D;\n            unchecked {\n                ++i;\n            }\n        }\n        revert(\"Did Not Converge\");\n    }\n}"
    },
    {
      "filename": "blueberry-core/contracts/oracle/CurveTricryptoOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\n/*\n██████╗ ██╗     ██╗   ██╗███████╗██████╗ ███████╗██████╗ ██████╗ ██╗   ██╗\n██╔══██╗██║     ██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██╔══██╗╚██╗ ██╔╝\n██████╔╝██║     ██║   ██║█████╗  ██████╔╝█████╗  ██████╔╝██████╔╝ ╚████╔╝\n██╔══██╗██║     ██║   ██║██╔══╝  ██╔══██╗██╔══╝  ██╔══██╗██╔══██╗  ╚██╔╝\n██████╔╝███████╗╚██████╔╝███████╗██████╔╝███████╗██║  ██║██║  ██║   ██║\n╚═════╝ ╚══════╝ ╚═════╝ ╚══════╝╚═════╝ ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝\n*/\n\npragma solidity 0.8.16;\n\nimport \"./CurveBaseOracle.sol\";\n\n/// @title Curve Volatile Oracle\n/// @author BlueberryProtocol \n/// @notice Oracle contract which privides price feeds of Curve volatile pool LP tokens\ncontract CurveTricryptoOracle is CurveBaseOracle {\n    \n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n    \n    /// @notice Constructor initializes the CurveBaseOracle with the provided parameters.\n    /// @param base_ The address of the base oracle.\n    /// @param addressProvider_ The address of the curve address provider.\n    constructor(\n        IBaseOracle base_,\n        ICurveAddressProvider addressProvider_\n    ) CurveBaseOracle(base_, addressProvider_) {}\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Overrides the base oracle's reentrancy check.\n    /// @param _pool The address of the pool to check.\n    /// @param (unnamed) Unused parameter for overriding.\n    function _checkReentrant(address _pool, uint256) internal override {\n        ICurvePool pool = ICurvePool(_pool);\n        pool.claim_admin_fees();\n    }\n\n    /// @notice Returns the USD value of the specified Curve LP token with 18 decimals of precision.\n    /// @dev If the length of tokens is not 3, the function will revert.\n    /// @param crvLp The ERC-20 Curve LP token address.\n    /// @return The USD value of the Curve LP token.\n    function getPrice(address crvLp) external override returns (uint256) {\n        (address pool, address[] memory tokens, uint256 virtualPrice) = _getPoolInfo(crvLp);\n        _checkReentrant(pool, tokens.length);\n\n        /// Check if the token list length is 3 (tricrypto)\n        if (tokens.length == 3) {\n            /// tokens[2] is WETH\n            uint256 ethPrice = base.getPrice(tokens[2]);\n            return\n                (lpPrice(\n                    virtualPrice,\n                    base.getPrice(tokens[1]),\n                    ethPrice,\n                    base.getPrice(tokens[0])\n                ) * 1e18) / ethPrice;\n        }\n        revert BlueBerryErrors.ORACLE_NOT_SUPPORT_LP(crvLp);\n    }\n\n    /// @dev Calculates the LP price using provided token prices and virtual price.\n    /// @param virtualPrice The virtual price from the pool.\n    /// @param p1 Price of the first token.\n    /// @param p2 Price of the second token (usually ETH).\n    /// @param p3 Price of the third token.\n    /// @return The calculated LP price.\n    function lpPrice(\n        uint256 virtualPrice,\n        uint256 p1,\n        uint256 p2,\n        uint256 p3\n    ) internal pure returns (uint256) {\n        return (3 * virtualPrice * cubicRoot(((p1 * p2) / 1e18) * p3)) / 1e18;\n    }\n\n    /// @dev Calculates the cubic root of the provided value using the Newton-Raphson method.\n    /// @param x The value to find the cubic root for.\n    /// @return The calculated cubic root.\n\n    function cubicRoot(uint256 x) internal pure returns (uint256) {\n        uint256 D = x / 1e18;\n        for (uint256 i; i < 255; ) {\n            uint256 D_prev = D;\n            D = (D * (2e18 + ((((x / D) * 1e18) / D) * 1e18) / D)) / (3e18);\n            uint256 diff = (D > D_prev) ? D - D_prev : D_prev - D;\n            if (diff < 2 || diff * 1e18 < D) return D;\n            unchecked {\n                ++i;\n            }\n        }\n        revert(\"Did Not Converge\");\n    }\n}"
    }
  ]
}