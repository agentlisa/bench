{
  "Title": "M-3: Panic when decoding a malformed deposit transaction JSON string",
  "Content": "# Issue M-3: Panic when decoding a malformed deposit transaction JSON string \n\nSource: https://github.com/sherlock-audit/2023-01-optimism-judging/issues/276 \n\n## Found by \nshw\n\n## Summary\n\nWhen decoding a deposit transaction JSON  string without the `\"gas\"` field, a panic/runtime error is triggered due to a nil pointer dereference.\n\n## Vulnerability Detail\n\nThe `op-geth/core/types/transaction_marshalling.go` file defines how transactions are encoded and decoded from JSON format. In the `UnmarshalJSON()` function, from L283 to L315, a new logic is added for the deposit transaction type, `DepositTxType`. The bug happens at L293, where the `dec.Gas` field is dereferenced without checking it against `nil` first. As a result, if the provided deposit transaction JSON string does not have the `\"gas\"` field, the nil pointer dereference will trigger a runtime error and crash the program.\n\nFor a PoC: Add the following test case to `op-geth/core/types/transaction_test.go` and run `cd op-geth && go test -run TestDecodeJSON -v ./core/types`\n\n```go\nfunc TestDecodeJSON(t *testing.T) {\n    // the \"gas\" field does not exist\n    var data = []byte(\"{\\\"type\\\":\\\"0x7e\\\",\\\"nonce\\\":null,\\\"gasPrice\\\":null,\\\"maxPriorityFeePerGas\\\":null,\\\"maxFeePerGas\\\":null,\\\"value\\\":\\\"0x1\\\",\\\"input\\\":\\\"0x616263646566\\\",\\\"v\\\":null,\\\"r\\\":null,\\\"s\\\":null,\\\"to\\\":null,\\\"sourceHash\\\":\\\"0x0000000000000000000000000000000000000000000000000000000000000000\\\",\\\"from\\\":\\\"0x0000000000000000000000000000000000000001\\\",\\\"isSystemTx\\\":false,\\\"hash\\\":\\\"0xa4341f3db4363b7ca269a8538bd027b2f8784f84454ca917668642d5f6dffdf9\\\"}\")\n    var parsedTx = &Transaction{}\n    _ = json.Unmarshal(data, &parsedTx) // will panic here\n}\n```\n\n## Impact\n\nA possible exploit scenario is targeting an `ethclient` compiled based on `op-geth`. For example, according to `op-geth/ethclient/ethclient.go`, the `BlockByHash()` API makes a RPC `eth_getBlockByHash` request to an RPC endpoint and expect to receive a `json.RawMessage` data that represents the queried block. In the `getBlock()` function, the JSON raw message is then decoded into a `rpcBlock`, containing a list of `rpcTransaction`s with type of `Transaction`. Therefore, a malicious RPC endpoint can construct a deposit transaction without the `\"gas\"` field in a block and return the block to the `ethclient`. The `ethclient` will fail to decode the received block and crash due to this bug.\n\nMarking this issue as medium severity according to previous similar audit findings from Sigma Prime.\n\n## Code Snippet\n\nPlease refer to `op-geth/core/types/transaction_marshalling.go#L293`, `op-geth/ethclient/ethclient.go#L77-L79` and `op-geth/ethclient/ethclient.go#L118-L126`.\nhttps://github.com/ethereum-optimism/op-geth/blob/985086bf2a5c61e76a8ce7c74ac029660751e260/core/types/transaction_marshalling.go#L293\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nCheck whether `dec.Gas` is `nil` before dereferencing it:\n\n```go\nif dec.Gas == nil {\n    return errors.New(\"missing required field 'gas' in transaction\")\n}\n```\n\n## Discussion\n\n**rcstanciu**\n\nComment from Optimism\n\n---\n\n **Description:** Panic in transaction unmarshalling code\n\n\n **Reason:** This is a legit bug in our transaction unmarshalling code.\n\n\n **Action:** Check for nil gas before unmarshalling\n\n\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/38",
  "Code": [
    {
      "filename": "core/types/transaction_marshalling.go",
      "content": "// Copyright 2021 The go-ethereum Authors\n// This file is part of the go-ethereum library.\n//\n// The go-ethereum library is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// The go-ethereum library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with the go-ethereum library. If not, see <http://www.gnu.org/licenses/>.\n\npackage types\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"math/big\"\n\n\t\"github.com/ethereum/go-ethereum/common\"\n\t\"github.com/ethereum/go-ethereum/common/hexutil\"\n)\n\n// txJSON is the JSON representation of transactions.\ntype txJSON struct {\n\tType hexutil.Uint64 `json:\"type\"`\n\n\t// Common transaction fields:\n\tNonce                *hexutil.Uint64 `json:\"nonce\"`\n\tGasPrice             *hexutil.Big    `json:\"gasPrice\"`\n\tMaxPriorityFeePerGas *hexutil.Big    `json:\"maxPriorityFeePerGas\"`\n\tMaxFeePerGas         *hexutil.Big    `json:\"maxFeePerGas\"`\n\tGas                  *hexutil.Uint64 `json:\"gas\"`\n\tValue                *hexutil.Big    `json:\"value\"`\n\tData                 *hexutil.Bytes  `json:\"input\"`\n\tV                    *hexutil.Big    `json:\"v\"`\n\tR                    *hexutil.Big    `json:\"r\"`\n\tS                    *hexutil.Big    `json:\"s\"`\n\tTo                   *common.Address `json:\"to\"`\n\n\t// Deposit transaction fields\n\tSourceHash *common.Hash    `json:\"sourceHash,omitempty\"`\n\tFrom       *common.Address `json:\"from,omitempty\"`\n\tMint       *hexutil.Big    `json:\"mint,omitempty\"`\n\tIsSystemTx *bool           `json:\"isSystemTx,omitempty\"`\n\n\t// Access list transaction fields:\n\tChainID    *hexutil.Big `json:\"chainId,omitempty\"`\n\tAccessList *AccessList  `json:\"accessList,omitempty\"`\n\n\t// Only used for encoding:\n\tHash common.Hash `json:\"hash\"`\n}\n\n// MarshalJSON marshals as JSON with a hash.\nfunc (tx *Transaction) MarshalJSON() ([]byte, error) {\n\tvar enc txJSON\n\t// These are set for all tx types.\n\tenc.Hash = tx.Hash()\n\tenc.Type = hexutil.Uint64(tx.Type())\n\n\t// Other fields are set conditionally depending on tx type.\n\tswitch itx := tx.inner.(type) {\n\tcase *LegacyTx:\n\t\tenc.Nonce = (*hexutil.Uint64)(&itx.Nonce)\n\t\tenc.Gas = (*hexutil.Uint64)(&itx.Gas)\n\t\tenc.GasPrice = (*hexutil.Big)(itx.GasPrice)\n\t\tenc.Value = (*hexutil.Big)(itx.Value)\n\t\tenc.Data = (*hexutil.Bytes)(&itx.Data)\n\t\tenc.To = tx.To()\n\t\tenc.V = (*hexutil.Big)(itx.V)\n\t\tenc.R = (*hexutil.Big)(itx.R)\n\t\tenc.S = (*hexutil.Big)(itx.S)\n\tcase *AccessListTx:\n\t\tenc.ChainID = (*hexutil.Big)(itx.ChainID)\n\t\tenc.AccessList = &itx.AccessList\n\t\tenc.Nonce = (*hexutil.Uint64)(&itx.Nonce)\n\t\tenc.Gas = (*hexutil.Uint64)(&itx.Gas)\n\t\tenc.GasPrice = (*hexutil.Big)(itx.GasPrice)\n\t\tenc.Value = (*hexutil.Big)(itx.Value)\n\t\tenc.Data = (*hexutil.Bytes)(&itx.Data)\n\t\tenc.To = tx.To()\n\t\tenc.V = (*hexutil.Big)(itx.V)\n\t\tenc.R = (*hexutil.Big)(itx.R)\n\t\tenc.S = (*hexutil.Big)(itx.S)\n\tcase *DynamicFeeTx:\n\t\tenc.ChainID = (*hexutil.Big)(itx.ChainID)\n\t\tenc.AccessList = &itx.AccessList\n\t\tenc.Nonce = (*hexutil.Uint64)(&itx.Nonce)\n\t\tenc.Gas = (*hexutil.Uint64)(&itx.Gas)\n\t\tenc.MaxFeePerGas = (*hexutil.Big)(itx.GasFeeCap)\n\t\tenc.MaxPriorityFeePerGas = (*hexutil.Big)(itx.GasTipCap)\n\t\tenc.Value = (*hexutil.Big)(itx.Value)\n\t\tenc.Data = (*hexutil.Bytes)(&itx.Data)\n\t\tenc.To = tx.To()\n\t\tenc.V = (*hexutil.Big)(itx.V)\n\t\tenc.R = (*hexutil.Big)(itx.R)\n\t\tenc.S = (*hexutil.Big)(itx.S)\n\tcase *DepositTx:\n\t\tenc.Gas = (*hexutil.Uint64)(&itx.Gas)\n\t\tenc.Value = (*hexutil.Big)(itx.Value)\n\t\tenc.Data = (*hexutil.Bytes)(&itx.Data)\n\t\tenc.To = tx.To()\n\t\tenc.SourceHash = &itx.SourceHash\n\t\tenc.From = &itx.From\n\t\tif itx.Mint != nil {\n\t\t\tenc.Mint = (*hexutil.Big)(itx.Mint)\n\t\t}\n\t\tenc.IsSystemTx = &itx.IsSystemTransaction\n\t\t// other fields will show up as null.\n\t}\n\treturn json.Marshal(&enc)\n}\n\n// UnmarshalJSON unmarshals from JSON.\nfunc (tx *Transaction) UnmarshalJSON(input []byte) error {\n\tvar dec txJSON\n\tif err := json.Unmarshal(input, &dec); err != nil {\n\t\treturn err\n\t}\n\n\t// Decode / verify fields according to transaction type.\n\tvar inner TxData\n\tswitch dec.Type {\n\tcase LegacyTxType:\n\t\tvar itx LegacyTx\n\t\tinner = &itx\n\t\tif dec.To != nil {\n\t\t\titx.To = dec.To\n\t\t}\n\t\tif dec.Nonce == nil {\n\t\t\treturn errors.New(\"missing required field 'nonce' in transaction\")\n\t\t}\n\t\titx.Nonce = uint64(*dec.Nonce)\n\t\tif dec.GasPrice == nil {\n\t\t\treturn errors.New(\"missing required field 'gasPrice' in transaction\")\n\t\t}\n\t\titx.GasPrice = (*big.Int)(dec.GasPrice)\n\t\tif dec.Gas == nil {\n\t\t\treturn errors.New(\"missing required field 'gas' in transaction\")\n\t\t}\n\t\titx.Gas = uint64(*dec.Gas)\n\t\tif dec.Value == nil {\n\t\t\treturn errors.New(\"missing required field 'value' in transaction\")\n\t\t}\n\t\titx.Value = (*big.Int)(dec.Value)\n\t\tif dec.Data == nil {\n\t\t\treturn errors.New(\"missing required field 'input' in transaction\")\n\t\t}\n\t\titx.Data = *dec.Data\n\t\tif dec.V == nil {\n\t\t\treturn errors.New(\"missing required field 'v' in transaction\")\n\t\t}\n\t\titx.V = (*big.Int)(dec.V)\n\t\tif dec.R == nil {\n\t\t\treturn errors.New(\"missing required field 'r' in transaction\")\n\t\t}\n\t\titx.R = (*big.Int)(dec.R)\n\t\tif dec.S == nil {\n\t\t\treturn errors.New(\"missing required field 's' in transaction\")\n\t\t}\n\t\titx.S = (*big.Int)(dec.S)\n\t\twithSignature := itx.V.Sign() != 0 || itx.R.Sign() != 0 || itx.S.Sign() != 0\n\t\tif withSignature {\n\t\t\tif err := sanityCheckSignature(itx.V, itx.R, itx.S, true); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\tcase AccessListTxType:\n\t\tvar itx AccessListTx\n\t\tinner = &itx\n\t\t// Access list is optional for now.\n\t\tif dec.AccessList != nil {\n\t\t\titx.AccessList = *dec.AccessList\n\t\t}\n\t\tif dec.ChainID == nil {\n\t\t\treturn errors.New(\"missing required field 'chainId' in transaction\")\n\t\t}\n\t\titx.ChainID = (*big.Int)(dec.ChainID)\n\t\tif dec.To != nil {\n\t\t\titx.To = dec.To\n\t\t}\n\t\tif dec.Nonce == nil {\n\t\t\treturn errors.New(\"missing required field 'nonce' in transaction\")\n\t\t}\n\t\titx.Nonce = uint64(*dec.Nonce)\n\t\tif dec.GasPrice == nil {\n\t\t\treturn errors.New(\"missing required field 'gasPrice' in transaction\")\n\t\t}\n\t\titx.GasPrice = (*big.Int)(dec.GasPrice)\n\t\tif dec.Gas == nil {\n\t\t\treturn errors.New(\"missing required field 'gas' in transaction\")\n\t\t}\n\t\titx.Gas = uint64(*dec.Gas)\n\t\tif dec.Value == nil {\n\t\t\treturn errors.New(\"missing required field 'value' in transaction\")\n\t\t}\n\t\titx.Value = (*big.Int)(dec.Value)\n\t\tif dec.Data == nil {\n\t\t\treturn errors.New(\"missing required field 'input' in transaction\")\n\t\t}\n\t\titx.Data = *dec.Data\n\t\tif dec.V == nil {\n\t\t\treturn errors.New(\"missing required field 'v' in transaction\")\n\t\t}\n\t\titx.V = (*big.Int)(dec.V)\n\t\tif dec.R == nil {\n\t\t\treturn errors.New(\"missing required field 'r' in transaction\")\n\t\t}\n\t\titx.R = (*big.Int)(dec.R)\n\t\tif dec.S == nil {\n\t\t\treturn errors.New(\"missing required field 's' in transaction\")\n\t\t}\n\t\titx.S = (*big.Int)(dec.S)\n\t\twithSignature := itx.V.Sign() != 0 || itx.R.Sign() != 0 || itx.S.Sign() != 0\n\t\tif withSignature {\n\t\t\tif err := sanityCheckSignature(itx.V, itx.R, itx.S, false); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\tcase DynamicFeeTxType:\n\t\tvar itx DynamicFeeTx\n\t\tinner = &itx\n\t\t// Access list is optional for now.\n\t\tif dec.AccessList != nil {\n\t\t\titx.AccessList = *dec.AccessList\n\t\t}\n\t\tif dec.ChainID == nil {\n\t\t\treturn errors.New(\"missing required field 'chainId' in transaction\")\n\t\t}\n\t\titx.ChainID = (*big.Int)(dec.ChainID)\n\t\tif dec.To != nil {\n\t\t\titx.To = dec.To\n\t\t}\n\t\tif dec.Nonce == nil {\n\t\t\treturn errors.New(\"missing required field 'nonce' in transaction\")\n\t\t}\n\t\titx.Nonce = uint64(*dec.Nonce)\n\t\tif dec.MaxPriorityFeePerGas == nil {\n\t\t\treturn errors.New(\"missing required field 'maxPriorityFeePerGas' for txdata\")\n\t\t}\n\t\titx.GasTipCap = (*big.Int)(dec.MaxPriorityFeePerGas)\n\t\tif dec.MaxFeePerGas == nil {\n\t\t\treturn errors.New(\"missing required field 'maxFeePerGas' for txdata\")\n\t\t}\n\t\titx.GasFeeCap = (*big.Int)(dec.MaxFeePerGas)\n\t\tif dec.Gas == nil {\n\t\t\treturn errors.New(\"missing required field 'gas' for txdata\")\n\t\t}\n\t\titx.Gas = uint64(*dec.Gas)\n\t\tif dec.Value == nil {\n\t\t\treturn errors.New(\"missing required field 'value' in transaction\")\n\t\t}\n\t\titx.Value = (*big.Int)(dec.Value)\n\t\tif dec.Data == nil {\n\t\t\treturn errors.New(\"missing required field 'input' in transaction\")\n\t\t}\n\t\titx.Data = *dec.Data\n\t\tif dec.V == nil {\n\t\t\treturn errors.New(\"missing required field 'v' in transaction\")\n\t\t}\n\t\titx.V = (*big.Int)(dec.V)\n\t\tif dec.R == nil {\n\t\t\treturn errors.New(\"missing required field 'r' in transaction\")\n\t\t}\n\t\titx.R = (*big.Int)(dec.R)\n\t\tif dec.S == nil {\n\t\t\treturn errors.New(\"missing required field 's' in transaction\")\n\t\t}\n\t\titx.S = (*big.Int)(dec.S)\n\t\twithSignature := itx.V.Sign() != 0 || itx.R.Sign() != 0 || itx.S.Sign() != 0\n\t\tif withSignature {\n\t\t\tif err := sanityCheckSignature(itx.V, itx.R, itx.S, false); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\tcase DepositTxType:\n\t\tif dec.AccessList != nil || dec.V != nil || dec.R != nil || dec.S != nil || dec.MaxFeePerGas != nil ||\n\t\t\tdec.MaxPriorityFeePerGas != nil || dec.GasPrice != nil || (dec.Nonce != nil && *dec.Nonce != 0) {\n\t\t\treturn errors.New(\"unexpected field(s) in deposit transaction\")\n\t\t}\n\t\tvar itx DepositTx\n\t\tinner = &itx\n\t\tif dec.To != nil {\n\t\t\titx.To = dec.To\n\t\t}\n\t\titx.Gas = uint64(*dec.Gas)\n\t\tif dec.Value == nil {\n\t\t\treturn errors.New(\"missing required field 'value' in transaction\")\n\t\t}\n\t\titx.Value = (*big.Int)(dec.Value)\n\t\t// mint may be omitted or nil if there is nothing to mint.\n\t\titx.Mint = (*big.Int)(dec.Mint)\n\t\tif dec.Data == nil {\n\t\t\treturn errors.New(\"missing required field 'input' in transaction\")\n\t\t}\n\t\titx.Data = *dec.Data\n\t\tif dec.From == nil {\n\t\t\treturn errors.New(\"missing required field 'from' in transaction\")\n\t\t}\n\t\titx.From = *dec.From\n\t\tif dec.SourceHash == nil {\n\t\t\treturn errors.New(\"missing required field 'sourceHash' in transaction\")\n\t\t}\n\t\titx.SourceHash = *dec.SourceHash\n\t\t// IsSystemTx may be omitted. Defaults to false.\n\t\tif dec.IsSystemTx != nil {\n\t\t\titx.IsSystemTransaction = *dec.IsSystemTx\n\t\t}\n\tdefault:\n\t\treturn ErrTxTypeNotSupported\n\t}\n\n\t// Now set the inner transaction.\n\ttx.setDecoded(inner, 0)\n\n\t// TODO: check hash here?\n\treturn nil\n}"
    }
  ]
}