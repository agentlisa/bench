{
  "Title": "[M-08] `MAX_TRUST_LIMIT` might be too high",
  "Content": "_Submitted by gpersoon_\n\nBoth `SumOfTrust.sol` and `CreditLimitByMedian.sol` contain an expensive sort function. This is used by `UserManager.sol` via the functions `getLockedAmount` and `getCreditLimit`.\n\nIf the list of stakers would be very long then the sort would take up all the gas and revert.\nAttackers could make the list of stakers longer by voting in themselves (as soon as they have 3 accounts voted in), this would result in a griefing attack.\n\nLuckily the number of stakers and borrowers is limited in the function updateTrust by applying a limit of `MAX_TRUST_LIMIT`.\n\nHowever this limit is quite high (100), if that amount of stakers would be present then an out of gas error would probably occur with the sort.\nNote: there are also other for loops in the code that could have a similar problem, however sort is the most expensive.\n\n#### Proof of Concept\n- <https://github.com/code-423n4/2021-10-union/blob/4176c366986e6d1a6b3f6ec0079ba547b040ac0f/contracts/user/SumOfTrust.sol#L98-L121>\n- <https://github.com/code-423n4/2021-10-union/blob/4176c366986e6d1a6b3f6ec0079ba547b040ac0f/contracts/user/CreditLimitByMedian.sol#L107-L122>\n- <https://github.com/code-423n4/2021-10-union/blob/4176c366986e6d1a6b3f6ec0079ba547b040ac0f/contracts/user/UserManager.sol#L594>\n- <https://github.com/code-423n4/2021-10-union/blob/4176c366986e6d1a6b3f6ec0079ba547b040ac0f/contracts/user/UserManager.sol#L368>\n- <https://github.com/code-423n4/2021-10-union/blob/4176c366986e6d1a6b3f6ec0079ba547b040ac0f/contracts/user/UserManager.sol#L50>\n- <https://github.com/code-423n4/2021-10-union/blob/4176c366986e6d1a6b3f6ec0079ba547b040ac0f/contracts/user/UserManager.sol#L423-L427>\n\n#### Recommended Mitigation Steps\nDo a test with a `MAX_TRUST_LIMIT` number of stakers and borrowers and check if the code still works.\n\nSet the `MAX_TRUST_LIMIT` so that everything still works, probably include a margin for future changes in gas costs.\n\n**[GeraldHost (Union Finance) acknowledged](https://github.com/code-423n4/2021-10-union-findings/issues/5#issuecomment-949844802):**\n > yes we have tested for this and landed on the 100 limit. We have plans to improve gas efficiency considerably in future.\n\n**[GalloDaSballo (judge) commented](https://github.com/code-423n4/2021-10-union-findings/issues/5#issuecomment-966600028):**\n > The warden has indentify a griefing exploit that can be applied only under specific circumstances, I agree with the severity\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2021-10-union",
  "Code": [
    {
      "filename": "contracts/user/SumOfTrust.sol",
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../interfaces/ICreditLimitModel.sol\";\n\ncontract SumOfTrust is Ownable, ICreditLimitModel {\n    using Math for uint256;\n\n    bool public constant override isCreditLimitModel = true;\n    uint256 public override effectiveNumber;\n\n    constructor(uint256 effectiveNumber_) {\n        effectiveNumber = effectiveNumber_;\n    }\n\n    function getCreditLimit(uint256[] memory vouchs) public view override returns (uint256) {\n        if (vouchs.length >= effectiveNumber) {\n            uint256 limit;\n            for (uint256 i = 0; i < vouchs.length; i++) {\n                limit += vouchs[i];\n            }\n\n            return limit;\n        } else {\n            return 0;\n        }\n    }\n\n    function getLockedAmount(\n        LockedInfo[] memory array,\n        address account,\n        uint256 amount,\n        bool isIncrease\n    ) public pure override returns (uint256) {\n        if (array.length == 0) return 0;\n\n        uint256 remaining = amount;\n        uint256 newLockedAmount;\n        if (isIncrease) {\n            array = _sortArray(array, true);\n            for (uint256 i = 0; i < array.length; i++) {\n                uint256 remainingVouchingAmount;\n                if (array[i].vouchingAmount > array[i].lockedAmount) {\n                    remainingVouchingAmount = array[i].vouchingAmount - array[i].lockedAmount;\n                } else {\n                    remainingVouchingAmount = 0;\n                }\n\n                if (remainingVouchingAmount > array[i].availableStakingAmount) {\n                    if (array[i].availableStakingAmount > remaining) {\n                        newLockedAmount = array[i].lockedAmount + remaining;\n                        remaining = 0;\n                    } else {\n                        newLockedAmount = array[i].lockedAmount + array[i].availableStakingAmount;\n                        remaining = remaining - array[i].availableStakingAmount;\n                    }\n                } else {\n                    if (remainingVouchingAmount > remaining) {\n                        newLockedAmount = array[i].lockedAmount + remaining;\n                        remaining = 0;\n                    } else {\n                        newLockedAmount = array[i].lockedAmount + remainingVouchingAmount;\n                        remaining -= remainingVouchingAmount;\n                    }\n                }\n\n                if (account == array[i].staker) {\n                    return newLockedAmount;\n                }\n            }\n        } else {\n            array = _sortArray(array, false);\n            for (uint256 i = 0; i < array.length; i++) {\n                if (array[i].lockedAmount > remaining) {\n                    newLockedAmount = array[i].lockedAmount - remaining;\n                    remaining = 0;\n                } else {\n                    newLockedAmount = 0;\n                    remaining -= array[i].lockedAmount;\n                }\n\n                if (account == array[i].staker) {\n                    return newLockedAmount;\n                }\n            }\n        }\n\n        return 0;\n    }\n\n    function setEffectNumber(uint256 number) external onlyOwner {\n        effectiveNumber = number;\n    }\n\n    function _sortArray(LockedInfo[] memory arr, bool isPositive) private pure returns (LockedInfo[] memory) {\n        uint256 length = arr.length;\n\n        for (uint256 i = 0; i < length; i++) {\n            for (uint256 j = i + 1; j < length; j++) {\n                if (isPositive) {\n                    if (arr[i].vouchingAmount < arr[j].vouchingAmount) {\n                        LockedInfo memory temp = arr[j];\n                        arr[j] = arr[i];\n                        arr[i] = temp;\n                    }\n                } else {\n                    if (arr[i].vouchingAmount > arr[j].vouchingAmount) {\n                        LockedInfo memory temp = arr[j];\n                        arr[j] = arr[i];\n                        arr[i] = temp;\n                    }\n                }\n            }\n        }\n\n        return arr;\n    }\n}"
    },
    {
      "filename": "contracts/user/CreditLimitByMedian.sol",
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../interfaces/ICreditLimitModel.sol\";\n\ncontract CreditLimitByMedian is Ownable, ICreditLimitModel {\n    using Math for uint256;\n\n    bool public constant override isCreditLimitModel = true;\n    uint256 public override effectiveNumber;\n\n    constructor(uint256 effectiveNumber_) {\n        effectiveNumber = effectiveNumber_;\n    }\n\n    function getCreditLimit(uint256[] memory vouchs) public view override returns (uint256) {\n        if (vouchs.length >= effectiveNumber) {\n            return _findMedian(vouchs);\n        } else {\n            return 0;\n        }\n    }\n\n    function getLockedAmount(\n        LockedInfo[] memory array,\n        address account,\n        uint256 amount,\n        bool isIncrease\n    ) public pure override returns (uint256) {\n        if (array.length == 0) return 0;\n\n        uint256 newLockedAmount;\n        if (isIncrease) {\n            for (uint256 i = 0; i < array.length; i++) {\n                uint256 remainingVouchingAmount;\n                if (array[i].vouchingAmount > array[i].lockedAmount) {\n                    remainingVouchingAmount = array[i].vouchingAmount - array[i].lockedAmount;\n                } else {\n                    remainingVouchingAmount = 0;\n                }\n\n                if (remainingVouchingAmount > array[i].availableStakingAmount) {\n                    if (array[i].availableStakingAmount > amount) {\n                        newLockedAmount = array[i].lockedAmount + amount;\n                    } else {\n                        newLockedAmount = array[i].lockedAmount + array[i].availableStakingAmount;\n                    }\n                } else {\n                    if (remainingVouchingAmount > amount) {\n                        newLockedAmount = array[i].lockedAmount + amount;\n                    } else {\n                        newLockedAmount = array[i].lockedAmount + remainingVouchingAmount;\n                    }\n                }\n\n                if (account == array[i].staker) {\n                    return newLockedAmount;\n                }\n            }\n        } else {\n            for (uint256 i = 0; i < array.length; i++) {\n                if (array[i].lockedAmount > amount) {\n                    newLockedAmount = array[i].lockedAmount - 1;\n                } else {\n                    newLockedAmount = 0;\n                }\n\n                if (account == array[i].staker) {\n                    return newLockedAmount;\n                }\n            }\n        }\n\n        return 0;\n    }\n\n    function setEffectNumber(uint256 number) external onlyOwner {\n        effectiveNumber = number;\n    }\n\n    /**\n     *  @dev Find median from uint array\n     *  @param array array\n     *  @return uint256\n     */\n    function _findMedian(uint256[] memory array) private pure returns (uint256) {\n        uint256[] memory arr = _sortArray(array);\n        if (arr.length == 0) return 0;\n\n        if (arr.length % 2 == 0) {\n            uint256 num1 = arr[arr.length >> 1];\n            uint256 num2 = arr[(arr.length >> 1) - 1];\n            return num1.average(num2);\n        } else {\n            return arr[arr.length >> 1];\n        }\n    }\n\n    /**\n     *  @dev Sort uint array\n     *  @param arr array\n     *  @return uint256 array\n     */\n    function _sortArray(uint256[] memory arr) private pure returns (uint256[] memory) {\n        uint256 length = arr.length;\n\n        for (uint256 i = 0; i < length; i++) {\n            for (uint256 j = i + 1; j < length; j++) {\n                if (arr[i] < arr[j]) {\n                    uint256 temp = arr[j];\n                    arr[j] = arr[i];\n                    arr[i] = temp;\n                }\n            }\n        }\n\n        return arr;\n    }\n}"
    },
    {
      "filename": "contracts/user/UserManager.sol",
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"../Controller.sol\";\nimport \"../interfaces/IAssetManager.sol\";\nimport \"../interfaces/ICreditLimitModel.sol\";\nimport \"../interfaces/IUserManager.sol\";\nimport \"../interfaces/IComptroller.sol\";\nimport \"../interfaces/IUnionToken.sol\";\nimport \"../interfaces/IDai.sol\";\nimport \"../interfaces/IUToken.sol\";\n\n/**\n * @title UserManager Contract\n * @dev Manages the Union members credit lines, and their vouchees and borrowers info.\n */\ncontract UserManager is Controller, IUserManager, ReentrancyGuardUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    struct Member {\n        bool isMember;\n        CreditLine creditLine;\n    }\n\n    //address: member address, uint256: trustAmount\n    struct CreditLine {\n        mapping(address => uint256) borrowers;\n        address[] borrowerAddresses;\n        mapping(address => uint256) stakers;\n        address[] stakerAddresses;\n        mapping(address => uint256) lockedAmount;\n    }\n\n    struct TrustInfo {\n        address[] stakerAddresses;\n        address[] borrowerAddresses;\n        uint256 effectiveCount;\n        address staker;\n        uint256 vouchingAmount;\n        uint256 stakingAmount;\n        uint256 availableStakingAmount;\n        uint256 lockedStake;\n        uint256 totalLockedStake;\n    }\n\n    uint256 public constant MAX_TRUST_LIMIT = 100;\n    uint256 public constant MAX_STAKE_AMOUNT = 1000e18;\n    address public stakingToken;\n    address public unionToken;\n    address public assetManager;\n    IUToken public uToken;\n    ICreditLimitModel public creditLimitModel;\n    IComptroller public comptroller;\n    uint256 public newMemberFee; // New member application fee\n\n    // slither-disable-next-line constable-states\n    uint256 public override totalStaked;\n    // slither-disable-next-line constable-states\n    uint256 public override totalFrozen;\n    mapping(address => Member) private members;\n    // slither-disable-next-line uninitialized-state\n    mapping(address => uint256) public stakers; //1 user address 2 amount\n    mapping(address => uint256) public memberFrozen; //1 user address 2 frozen amount\n\n    modifier onlyMember(address account) {\n        require(checkIsMember(account), \"UserManager: caller does not have the Member role\");\n        _;\n    }\n\n    modifier onlyMarketOrAdmin() {\n        require(\n            address(uToken) == msg.sender || isAdmin(msg.sender),\n            \"UserManager: caller does not the market or admin\"\n        );\n        _;\n    }\n\n    /**\n     *  @dev Update new credit limit model event\n     *  @param newCreditLimitModel New credit limit model address\n     */\n    event LogNewCreditLimitModel(address newCreditLimitModel);\n\n    /**\n     *  @dev Add new member event\n     *  @param member New member address\n     */\n    event LogAddMember(address member);\n\n    /**\n     *  @dev Update vouch for existing member event\n     *  @param staker Trustee address\n     *  @param borrower The address gets vouched for\n     *  @param trustAmount Vouch amount\n     */\n    event LogUpdateTrust(address indexed staker, address indexed borrower, uint256 trustAmount);\n\n    /**\n     *  @dev New member application event\n     *  @param account New member's voucher address\n     *  @param borrower New member address\n     */\n    event LogRegisterMember(address indexed account, address indexed borrower);\n\n    /**\n     *  @dev Cancel vouching for other member event\n     *  @param account New member's voucher address\n     *  @param borrower The address gets vouched for\n     */\n    event LogCancelVouch(address indexed account, address indexed borrower);\n\n    /**\n     *  @dev Stake event\n     *  @param account The staker's address\n     *  @param amount The amount of tokens to stake\n     */\n    event LogStake(address indexed account, uint256 amount);\n\n    /**\n     *  @dev Unstake event\n     *  @param account The staker's address\n     *  @param amount The amount of tokens to unstake\n     */\n    event LogUnstake(address indexed account, uint256 amount);\n\n    /**\n     *  @dev DebtWriteOff event\n     *  @param staker The staker's address\n     *  @param borrower The borrower's address\n     *  @param amount The amount of write off\n     */\n    event LogDebtWriteOff(address indexed staker, address indexed borrower, uint256 amount);\n\n    function __UserManager_init(\n        address assetManager_,\n        address unionToken_,\n        address stakingToken_,\n        address creditLimitModel_,\n        address comptroller_,\n        address admin_\n    ) public initializer {\n        Controller.__Controller_init(admin_);\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\n        _setCreditLimitModel(creditLimitModel_);\n        comptroller = IComptroller(comptroller_);\n        assetManager = assetManager_;\n        unionToken = unionToken_;\n        stakingToken = stakingToken_;\n        newMemberFee = 10**18; // Set the default membership fee\n    }\n\n    function setUToken(address uToken_) public onlyAdmin {\n        uToken = IUToken(uToken_);\n    }\n\n    function setNewMemberFee(uint256 amount) public onlyAdmin {\n        newMemberFee = amount;\n    }\n\n    /**\n     *  @dev Change the credit limit model\n     *  Accept claims only from the admin\n     *  @param newCreditLimitModel New credit limit model address\n     */\n    function setCreditLimitModel(address newCreditLimitModel) public override onlyAdmin {\n        _setCreditLimitModel(newCreditLimitModel);\n    }\n\n    function _setCreditLimitModel(address newCreditLimitModel) private {\n        require(\n            ICreditLimitModel(newCreditLimitModel).isCreditLimitModel(),\n            \"MemberMnager: new model is not a creditLimitModel\"\n        );\n        creditLimitModel = ICreditLimitModel(newCreditLimitModel);\n\n        emit LogNewCreditLimitModel(newCreditLimitModel);\n    }\n\n    /**\n     *  @dev Check if the account is a valid member\n     *  @param account Member address\n     *  @return Address whether is member\n     */\n    function checkIsMember(address account) public view override returns (bool) {\n        return members[account].isMember;\n    }\n\n    /**\n     *  @dev Get member borrowerAddresses\n     *  @param account Member address\n     *  @return Address array\n     */\n    function getBorrowerAddresses(address account) public view override returns (address[] memory) {\n        return members[account].creditLine.borrowerAddresses;\n    }\n\n    /**\n     *  @dev Get member stakerAddresses\n     *  @param account Member address\n     *  @return Address array\n     */\n    function getStakerAddresses(address account) public view override returns (address[] memory) {\n        return members[account].creditLine.stakerAddresses;\n    }\n\n    /**\n     *  @dev Get member backer asset\n     *  @param account Member address\n     *  @param borrower Borrower address\n     *  @return trustAmount vouchingAmount lockedStake. Trust amount, vouch amount, and locked stake amount\n     */\n    function getBorrowerAsset(address account, address borrower)\n        public\n        view\n        override\n        returns (\n            uint256 trustAmount,\n            uint256 vouchingAmount,\n            uint256 lockedStake\n        )\n    {\n        trustAmount = members[account].creditLine.borrowers[borrower];\n        lockedStake = getLockedStake(account, borrower);\n        vouchingAmount = getVouchingAmount(account, borrower);\n    }\n\n    /**\n     *  @dev Get member stakers asset\n     *  @param account Member address\n     *  @param staker Staker address\n     *  @return trustAmount lockedStake vouchingAmount. Vouch amount and lockedStake\n     */\n    function getStakerAsset(address account, address staker)\n        public\n        view\n        override\n        returns (\n            uint256 trustAmount,\n            uint256 vouchingAmount,\n            uint256 lockedStake\n        )\n    {\n        trustAmount = members[account].creditLine.stakers[staker];\n        lockedStake = getLockedStake(staker, account);\n        vouchingAmount = getVouchingAmount(staker, account);\n    }\n\n    /**\n     *  @dev Get staker locked stake for a borrower\n     *  @param staker Staker address\n     *  @param borrower Borrower address\n     *  @return LockedStake\n     */\n    function getLockedStake(address staker, address borrower) public view returns (uint256) {\n        return members[staker].creditLine.lockedAmount[borrower];\n    }\n\n    /**\n     *  @dev Get the user's locked stake from all his backed loans\n     *  @param staker Staker address\n     *  @return LockedStake\n     */\n    function getTotalLockedStake(address staker) public view override returns (uint256) {\n        uint256 totalLockedStake = 0;\n        uint256 stakingAmount = stakers[staker];\n        address[] memory borrowerAddresses = members[staker].creditLine.borrowerAddresses;\n        address borrower;\n        for (uint256 i = 0; i < borrowerAddresses.length; i++) {\n            borrower = borrowerAddresses[i];\n            totalLockedStake += getLockedStake(staker, borrower);\n        }\n\n        if (stakingAmount >= totalLockedStake) {\n            return totalLockedStake;\n        } else {\n            return stakingAmount;\n        }\n    }\n\n    /**\n     *  @dev Get staker's defaulted / frozen staked token amount\n     *  @param staker Staker address\n     *  @return Frozen token amount\n     */\n    function getTotalFrozenAmount(address staker) public view override returns (uint256) {\n        TrustInfo memory trustInfo;\n        uint256 totalFrozenAmount = 0;\n        trustInfo.borrowerAddresses = members[staker].creditLine.borrowerAddresses;\n        trustInfo.stakingAmount = stakers[staker];\n\n        address borrower;\n        for (uint256 i = 0; i < trustInfo.borrowerAddresses.length; i++) {\n            borrower = trustInfo.borrowerAddresses[i];\n            if (uToken.checkIsOverdue(borrower)) {\n                totalFrozenAmount += getLockedStake(staker, borrower);\n            }\n        }\n\n        if (trustInfo.stakingAmount >= totalFrozenAmount) {\n            return totalFrozenAmount;\n        } else {\n            return trustInfo.stakingAmount;\n        }\n    }\n\n    /**\n     *  @dev Get the member's available credit line\n     *  @param borrower Member address\n     *  @return Credit line amount\n     */\n    function getCreditLimit(address borrower) public view override returns (int256) {\n        TrustInfo memory trustInfo;\n        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;\n        // Get the number of effective vouchee, first\n        trustInfo.effectiveCount = 0;\n        uint256[] memory limits = new uint256[](trustInfo.stakerAddresses.length);\n\n        for (uint256 i = 0; i < trustInfo.stakerAddresses.length; i++) {\n            trustInfo.staker = trustInfo.stakerAddresses[i];\n\n            trustInfo.stakingAmount = stakers[trustInfo.staker];\n\n            trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);\n\n            //A vouchingAmount value of 0 means that the amount of stake is 0 or trust is 0. In this case, this data is not used to calculate the credit limit\n            if (trustInfo.vouchingAmount > 0) {\n                //availableStakingAmount is stakerâ€˜s free stake amount\n                trustInfo.borrowerAddresses = getBorrowerAddresses(trustInfo.staker);\n\n                trustInfo.availableStakingAmount = trustInfo.stakingAmount;\n                uint256 totalLockedStake = getTotalLockedStake(trustInfo.staker);\n                if (trustInfo.stakingAmount <= totalLockedStake) {\n                    trustInfo.availableStakingAmount = 0;\n                } else {\n                    trustInfo.availableStakingAmount = trustInfo.stakingAmount - totalLockedStake;\n                }\n\n                trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);\n\n                require(\n                    trustInfo.vouchingAmount >= trustInfo.lockedStake,\n                    \"UserManager: vouchingAmount or lockedStake data error\"\n                );\n\n                //The actual effective guarantee amount cannot exceed availableStakingAmount,\n                if (trustInfo.vouchingAmount >= trustInfo.availableStakingAmount + trustInfo.lockedStake) {\n                    limits[trustInfo.effectiveCount] = trustInfo.availableStakingAmount;\n                } else {\n                    if (trustInfo.vouchingAmount <= trustInfo.lockedStake) {\n                        limits[trustInfo.effectiveCount] = 0;\n                    } else {\n                        limits[trustInfo.effectiveCount] = trustInfo.vouchingAmount - trustInfo.lockedStake;\n                    }\n                }\n                trustInfo.effectiveCount += 1;\n            }\n        }\n\n        uint256[] memory creditlimits = new uint256[](trustInfo.effectiveCount);\n        for (uint256 j = 0; j < trustInfo.effectiveCount; j++) {\n            creditlimits[j] = limits[j];\n        }\n\n        return int256(creditLimitModel.getCreditLimit(creditlimits)) - int256(uToken.calculatingInterest(borrower));\n    }\n\n    /**\n     *  @dev Get vouching amount\n     *  @param staker Staker address\n     *  @param borrower Borrower address\n     */\n    function getVouchingAmount(address staker, address borrower) public view returns (uint256) {\n        uint256 totalStake = stakers[staker];\n        uint256 trustAmount = members[borrower].creditLine.stakers[staker];\n        if (trustAmount > totalStake) {\n            return totalStake;\n        } else {\n            return trustAmount;\n        }\n    }\n\n    /**\n     *  @dev Get the user's deposited stake amount\n     *  @param account Member address\n     *  @return Deposited stake amount\n     */\n    function getStakerBalance(address account) public view override returns (uint256) {\n        return stakers[account];\n    }\n\n    /**\n     *  @dev Add member\n     *  Accept claims only from the admin\n     *  @param account Member address\n     */\n    function addMember(address account) public override onlyAdmin {\n        require(!checkIsMember(account), \"UserManager: address is already member\");\n        members[account].isMember = true;\n        emit LogAddMember(account);\n    }\n\n    /**\n     *  @dev Update the trust amount for exisitng members.\n     *  @param borrower_ Account address\n     *  @param trustAmount Trust amount\n     */\n    function updateTrust(address borrower_, uint256 trustAmount)\n        external\n        override\n        onlyMember(msg.sender)\n        whenNotPaused\n    {\n        require(borrower_ != address(0), \"borrower cannot be zero\");\n        address borrower = borrower_;\n\n        TrustInfo memory trustInfo;\n        trustInfo.staker = msg.sender;\n        require(trustInfo.staker != borrower, \"UserManager: Can't vouch for self\");\n        require(\n            members[borrower].creditLine.stakerAddresses.length < MAX_TRUST_LIMIT &&\n                members[trustInfo.staker].creditLine.borrowerAddresses.length < MAX_TRUST_LIMIT,\n            \"UserManager: trust reach limit\"\n        );\n        trustInfo.borrowerAddresses = members[trustInfo.staker].creditLine.borrowerAddresses;\n        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;\n        trustInfo.lockedStake = getLockedStake(trustInfo.staker, borrower);\n        require(\n            trustAmount >= trustInfo.lockedStake,\n            \"UserManager: trust amount cannot be less than the locked amount \"\n        );\n        uint256 borrowerCount = members[trustInfo.staker].creditLine.borrowerAddresses.length;\n        bool borrowerExist = false;\n        for (uint256 i = 0; i < borrowerCount; i++) {\n            if (trustInfo.borrowerAddresses[i] == borrower) {\n                borrowerExist = true;\n            }\n        }\n\n        uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;\n        bool stakerExist = false;\n        for (uint256 i = 0; i < stakerCount; i++) {\n            if (trustInfo.stakerAddresses[i] == trustInfo.staker) {\n                stakerExist = true;\n            }\n        }\n\n        if (!borrowerExist) {\n            members[trustInfo.staker].creditLine.borrowerAddresses.push(borrower);\n        }\n\n        if (!stakerExist) {\n            members[borrower].creditLine.stakerAddresses.push(trustInfo.staker);\n        }\n\n        members[trustInfo.staker].creditLine.borrowers[borrower] = trustAmount;\n        members[borrower].creditLine.stakers[trustInfo.staker] = trustAmount;\n        emit LogUpdateTrust(trustInfo.staker, borrower, trustAmount);\n    }\n\n    /**\n     *  @dev Stop vouch for other member.\n     *  @param staker Staker address\n     *  @param borrower borrower address\n     */\n    function cancelVouch(address staker, address borrower) external override onlyMember(msg.sender) whenNotPaused {\n        require(\n            msg.sender == staker || msg.sender == borrower,\n            \"UserManager: Accept claims only from the staker or borrower\"\n        );\n\n        require(getLockedStake(staker, borrower) == 0, \"UserManager: LockedStake is not zero\");\n\n        uint256 stakerCount = members[borrower].creditLine.stakerAddresses.length;\n        bool stakerExist = false;\n        uint256 stakerIndex = 0;\n        for (uint256 i = 0; i < stakerCount; i++) {\n            if (members[borrower].creditLine.stakerAddresses[i] == staker) {\n                stakerExist = true;\n                stakerIndex = i;\n            }\n        }\n\n        uint256 borrowerCount = members[staker].creditLine.borrowerAddresses.length;\n        bool borrowerExist = false;\n        uint256 borrowerIndex = 0;\n        for (uint256 i = 0; i < borrowerCount; i++) {\n            if (members[staker].creditLine.borrowerAddresses[i] == borrower) {\n                borrowerExist = true;\n                borrowerIndex = i;\n            }\n        }\n\n        //delete address\n        if (borrowerExist) {\n            members[staker].creditLine.borrowerAddresses[borrowerIndex] = members[staker].creditLine.borrowerAddresses[\n                borrowerCount - 1\n            ];\n            members[staker].creditLine.borrowerAddresses.pop();\n        }\n\n        if (stakerExist) {\n            members[borrower].creditLine.stakerAddresses[stakerIndex] = members[borrower].creditLine.stakerAddresses[\n                stakerCount - 1\n            ];\n            members[borrower].creditLine.stakerAddresses.pop();\n        }\n\n        delete members[staker].creditLine.borrowers[borrower];\n        delete members[borrower].creditLine.stakers[staker];\n\n        emit LogCancelVouch(staker, borrower);\n    }\n\n    function registerMemberWithPermit(\n        address newMember,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public whenNotPaused {\n        IUnionToken unionTokenContract = IUnionToken(unionToken);\n        unionTokenContract.permit(msg.sender, address(this), value, deadline, v, r, s);\n        registerMember(newMember);\n    }\n\n    /**\n     *  @dev Apply for membership, and burn UnionToken as application fees\n     *  @param newMember New member address\n     */\n    function registerMember(address newMember) public override whenNotPaused {\n        IUnionToken unionTokenContract = IUnionToken(unionToken);\n        require(!checkIsMember(newMember), \"UserManager: address is already member\");\n        require(unionTokenContract.balanceOf(msg.sender) >= newMemberFee, \"UserManager: balance not enough\");\n\n        uint256 effectiveStakerNumber = 0;\n        for (uint256 i = 0; i < members[newMember].creditLine.stakerAddresses.length; i++) {\n            address stakerAddress = members[newMember].creditLine.stakerAddresses[i];\n            if (checkIsMember(stakerAddress) && getVouchingAmount(stakerAddress, newMember) > 0)\n                effectiveStakerNumber += 1;\n        }\n\n        require(\n            effectiveStakerNumber >= creditLimitModel.effectiveNumber(),\n            \"UserManager: not enough effective stakers\"\n        );\n\n        members[newMember].isMember = true;\n\n        unionTokenContract.burnFrom(msg.sender, newMemberFee);\n\n        emit LogRegisterMember(msg.sender, newMember);\n    }\n\n    function updateLockedData(\n        address borrower,\n        uint256 amount,\n        bool isBorrow\n    ) external override onlyMarketOrAdmin {\n        TrustInfo memory trustInfo;\n        trustInfo.stakerAddresses = members[borrower].creditLine.stakerAddresses;\n\n        ICreditLimitModel.LockedInfo[] memory lockedInfoList = new ICreditLimitModel.LockedInfo[](\n            trustInfo.stakerAddresses.length\n        );\n\n        for (uint256 i = 0; i < trustInfo.stakerAddresses.length; i++) {\n            ICreditLimitModel.LockedInfo memory lockedInfo;\n\n            trustInfo.staker = trustInfo.stakerAddresses[i];\n            trustInfo.stakingAmount = stakers[trustInfo.staker];\n            trustInfo.vouchingAmount = getVouchingAmount(trustInfo.staker, borrower);\n\n            trustInfo.totalLockedStake = getTotalLockedStake(trustInfo.staker);\n            if (trustInfo.stakingAmount <= trustInfo.totalLockedStake) {\n                trustInfo.availableStakingAmount = 0;\n            } else {\n                trustInfo.availableStakingAmount = trustInfo.stakingAmount - trustInfo.totalLockedStake;\n            }\n\n            lockedInfo.staker = trustInfo.staker;\n            lockedInfo.vouchingAmount = trustInfo.vouchingAmount;\n            lockedInfo.lockedAmount = getLockedStake(trustInfo.staker, borrower);\n            lockedInfo.availableStakingAmount = trustInfo.availableStakingAmount;\n\n            lockedInfoList[i] = lockedInfo;\n        }\n\n        for (uint256 i = 0; i < lockedInfoList.length; i++) {\n            members[lockedInfoList[i].staker].creditLine.lockedAmount[borrower] = creditLimitModel.getLockedAmount(\n                lockedInfoList,\n                lockedInfoList[i].staker,\n                amount,\n                isBorrow\n            );\n        }\n    }\n\n    /**\n     *  @dev Stake\n     *  @param amount Amount\n     */\n    function stake(uint256 amount) public override whenNotPaused nonReentrant {\n        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);\n\n        comptroller.withdrawRewards(msg.sender, stakingToken);\n\n        uint256 balance = stakers[msg.sender];\n\n        require(balance + amount <= MAX_STAKE_AMOUNT, \"UserManager: Stake limit hit\");\n\n        stakers[msg.sender] = balance + amount;\n        totalStaked += amount;\n\n        require(\n            erc20Token.allowance(msg.sender, address(this)) >= amount,\n            \"UserManager: not enough allowance to stake\"\n        );\n        erc20Token.safeTransferFrom(msg.sender, address(this), amount);\n        erc20Token.safeApprove(assetManager, 0);\n        erc20Token.safeApprove(assetManager, amount);\n\n        require(IAssetManager(assetManager).deposit(stakingToken, amount), \"UserManager: Deposit failed\");\n\n        emit LogStake(msg.sender, amount);\n    }\n\n    /**\n     *  @dev stakeWithPermit\n     *  @param amount Amount\n     */\n    function stakeWithPermit(\n        uint256 amount,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public whenNotPaused {\n        IDai erc20Token = IDai(stakingToken);\n        erc20Token.permit(msg.sender, address(this), nonce, expiry, true, v, r, s);\n\n        stake(amount);\n    }\n\n    /**\n     *  @dev Unstake\n     *  @param amount Amount\n     */\n    function unstake(uint256 amount) external override whenNotPaused nonReentrant {\n        IERC20Upgradeable erc20Token = IERC20Upgradeable(stakingToken);\n        uint256 stakingAmount = stakers[msg.sender];\n        require(\n            stakingAmount - getTotalLockedStake(msg.sender) >= amount,\n            \"UserManager: unstake balance is insufficient\"\n        );\n\n        comptroller.withdrawRewards(msg.sender, stakingToken);\n\n        stakers[msg.sender] = stakingAmount - amount;\n        totalStaked -= amount;\n\n        require(\n            IAssetManager(assetManager).withdraw(stakingToken, address(this), amount),\n            \"UserManager: withdraw failed\"\n        );\n\n        erc20Token.safeTransfer(msg.sender, amount);\n\n        emit LogUnstake(msg.sender, amount);\n    }\n\n    function withdrawRewards() external whenNotPaused nonReentrant {\n        uint256 rewards = comptroller.withdrawRewards(msg.sender, stakingToken);\n        require(rewards > 0, \"UserManager: not enough rewards\");\n    }\n\n    /**\n     *  @dev Repay user's loan overdue, called only from the"
    }
  ]
}