{
  "Title": "[L-05] `addLockedFunds` should check `dripRatePerBlock` is not zero",
  "Content": "\nhttps://github.com/code-423n4/2023-05-xeth/blob/main/src/wxETH.sol#L146-L148\n\nThe `addLockedFunds` function present in the wxETH contract should check that `dripRatePerBlock > 0`.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-05-xeth",
  "Code": [
    {
      "filename": "src/wxETH.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\nimport \"@openzeppelin-contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin-contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin-contracts/access/Ownable.sol\";\nimport \"solmate/utils/FixedPointMathLib.sol\";\n\ncontract WrappedXETH is ERC20, Ownable {\n    using SafeERC20 for IERC20;\n\n    /* --------------------------------- Events --------------------------------- */\n    /// @dev emitted when the dripRatePerBlock is updated\n    event UpdateDripRate(uint oldDripRatePerBlock, uint256 newDripRatePerBlock);\n    /// @dev emitted when a sucessful accrueDrip is called\n    event Drip(uint256 amountDripped, uint256 lockedFunds, uint256 totalFunds);\n    /// @dev emitted when a user stakes xETH to receieve wxETH\n    event Stake(\n        address indexed user,\n        uint256 xETHAmount,\n        uint256 wxETHReceived\n    );\n    /// @dev emitted when a user unstakes wxETH to receieve xETH\n    event Unstake(\n        address indexed user,\n        uint256 wxETHAmount,\n        uint256 xETHReceived\n    );\n\n    /// @dev emitted when the dripping mechanism is started\n    event DripStarted();\n    /// @dev emitted when the dripping mechanism is stopped\n    event DripStopped();\n\n    /// @dev emitted when locked funds are added to the contract by the owner\n    event LockedFundsAdded(uint256 amountAdded, uint256 totalLockedFunds);\n\n    /* --------------------------------- Errors --------------------------------- */\n    error AddressZeroProvided();\n    error AmountZeroProvided();\n    error DripAlreadyRunning();\n    error DripAlreadyStopped();\n\n    /* -------------------------- Constants and Storage ------------------------- */\n\n    /// @dev initial exchange rate of wxETH to xETH. Set to 1:1\n    uint256 public constant INITIAL_EXCHANGE_RATE = 1E18; // exchange rate at begining is 1:1\n\n    /// @dev Base unit of the xETH token\n    uint256 public constant BASE_UNIT = 1E18;\n\n    /// @dev Immutable ERC20 reference to the xETH token\n    IERC20 public immutable xETH;\n\n    /// @dev amount of xETH that are locked in the contract\n    uint256 public lockedFunds;\n    /// @dev amount of xETH that will be dripped per block\n    uint256 public dripRatePerBlock;\n    /// @dev block number of the last drip\n    uint256 public lastReport;\n    /// @dev is dripping enabled in the contract?\n    bool public dripEnabled;\n\n    /* ------------------------------- Constructor ------------------------------ */\n    constructor(address xETHAddress) ERC20(\"Wrapped xETH\", \"wxETH\") {\n        /// @dev if the xETH address is address(0), revert\n        if (xETHAddress == address(0)) revert AddressZeroProvided();\n\n        /// @dev set the xETH reference\n        xETH = IERC20(xETHAddress);\n\n        /// @dev set the drip lastReport to current block\n        lastReport = block.number;\n    }\n\n    /* --------------------------- External functions --------------------------- */\n\n    /// @dev Preview the amount of wxETH that would be minted for a given xETH amount.\n    /// @param xETHAmount The amount of xETH input.\n    /// @return The amount of wxETH that would be minted.\n    /// @notice Reverts if xETHAmount is 0.\n    function previewStake(uint256 xETHAmount) public view returns (uint256) {\n        /// @dev if xETHAmount is 0, revert.\n        if (xETHAmount == 0) revert AmountZeroProvided();\n\n        /// @dev calculate the amount of wxETH to mint before transfer\n        return (xETHAmount * BASE_UNIT) / exchangeRate();\n    }\n\n    /// @dev stake allows for staking xETH in exchange for wxETH\n    /// @notice this function can only be called by a user that has approved to spend xETH\n    /// @notice this function can only be called if the xETHAmount provided is not 0\n    /// @param xETHAmount amount of xETH to be staked\n    function stake(uint256 xETHAmount) external drip returns (uint256) {\n        /// @dev calculate the amount of wxETH to mint\n        uint256 mintAmount = previewStake(xETHAmount);\n\n        /// @dev transfer xETH from the user to the contract\n        xETH.safeTransferFrom(msg.sender, address(this), xETHAmount);\n\n        /// @dev emit event\n        emit Stake(msg.sender, xETHAmount, mintAmount);\n\n        /// @dev mint the wxETH to the user\n        _mint(msg.sender, mintAmount);\n\n        return mintAmount;\n    }\n\n    /// @dev Preview the amount of xETH that would be returned for a given wxETH amount.\n    /// @param wxETHAmount The amount of wxETH input.\n    /// @return The amount of xETH that would be returned.\n    /// @notice Reverts if wxETHAmount is 0.\n    function previewUnstake(uint256 wxETHAmount) public view returns (uint256) {\n        /// @dev if wxETHAmount is 0, revert.\n        if (wxETHAmount == 0) revert AmountZeroProvided();\n\n        /// @dev calculate the amount of xETH to return\n        return (wxETHAmount * exchangeRate()) / BASE_UNIT;\n    }\n\n    /// @dev unstake allows for unstaking wxETH in exchange for xETH\n    /// @notice this function can only be called if the wxETHAmount provided is not 0\n    /// @param wxETHAmount amount of wxETH to be unstaked\n    function unstake(uint256 wxETHAmount) external drip returns (uint256) {\n        /// @dev calculate the amount of xETH to return\n        uint256 returnAmount = previewUnstake(wxETHAmount);\n\n        /// @dev emit event\n        emit Unstake(msg.sender, wxETHAmount, returnAmount);\n\n        /// @dev burn the wxETH from the user\n        _burn(msg.sender, wxETHAmount);\n\n        /// @dev return the xETH back to user\n        xETH.safeTransfer(msg.sender, returnAmount);\n\n        /// @dev return the amount of xETH sent to user\n        return returnAmount;\n    }\n\n    /// @dev addLockedFunds allows for adding locked funds to the contract\n    /// @notice this function can only be called by the owner\n    /// @notice this function can only be called if the amount provided \n    /// @dev if amount is 0, revert.\n    function addLockedFunds(uint256 amount) external onlyOwner drip {\n        /// @dev if amount or _dripRatePerBlock is 0, revert.\n        if (amount == 0) revert AmountZeroProvided();\n\n        /// @dev transfer xETH from the user to the contract\n        xETH.safeTransferFrom(msg.sender, address(this), amount);\n\n        /// @dev add the amount to the locked funds variable\n        lockedFunds += amount;\n\n        emit LockedFundsAdded(amount, lockedFunds);\n    }\n\n    function setDripRate(uint256 newDripRatePerBlock) external onlyOwner drip {\n        if (newDripRatePerBlock == 0) revert AmountZeroProvided();\n\n        emit UpdateDripRate(dripRatePerBlock, newDripRatePerBlock);\n\n        /// @dev set the drip rate per block\n        dripRatePerBlock = newDripRatePerBlock;\n    }\n\n    /// @dev This function starts (or un-pauses) the drip mechanism\n    /// @notice can be only called by the owner\n    function startDrip() external onlyOwner drip {\n        /// @dev if the drip is already running, revert\n        if (dripEnabled) revert DripAlreadyRunning();\n\n        dripEnabled = true;\n\n        /// @dev set the drip lastReport to current block\n        lastReport = block.number;\n\n        emit DripStarted();\n    }\n\n    /// @dev This function stops (or pauses) the drip mechanism\n    /// @notice can be only called by the owner\n    function stopDrip() external onlyOwner drip {\n        /// @dev if the drip is already stopped, revert\n        if (!dripEnabled) revert DripAlreadyStopped();\n\n        dripEnabled = false;\n\n        /// @dev set the drip lastReport to current block\n        lastReport = block.number;\n\n        emit DripStopped();\n    }\n\n    /// @dev accrueDrip allows for manually triggering a drip\n    // solhint-disable-next-line no-empty-blocks\n    function accrueDrip() external drip {}\n\n    /* ---------------------------- Public functions ---------------------------- */\n    /// @dev exchangeRate returns the current exchange rate of wxETH to xETH\n    function exchangeRate() public view returns (uint256) {\n        /// @dev if there are no tokens minted, return the initial exchange rate\n        uint256 _totalSupply = totalSupply();\n        if (_totalSupply == 0) {\n            return INITIAL_EXCHANGE_RATE;\n        }\n\n        /// @dev calculate the cash on hand by removing locked funds from the total xETH balance\n        /// @notice this balanceOf call will include any lockedFunds,\n        /// @notice as the locked funds are also in xETH\n        uint256 cashMinusLocked = xETH.balanceOf(address(this)) - lockedFunds;\n\n        /// @dev return the exchange rate by dividing the cash on hand by the total supply\n        return (cashMinusLocked * BASE_UNIT) / _totalSupply;\n    }\n\n    /* -------------------- Intenral functions and Modifiers -------------------- */\n\n    /// @dev _accrueDrip calculates the amount of xETH to drip and updates\n    /// @dev the lockedFunds and lastReport variables\n    function _accrueDrip() private {\n        /// @dev if drip is disabled, no need to accrue\n        if (!dripEnabled) return;\n\n        /// @dev blockDelta is the difference between now and last accrual\n        uint256 blockDelta = block.number - lastReport;\n\n        if (blockDelta != 0) {\n            /// @dev calculate dripAmount using blockDelta and dripRatePerBlock\n            uint256 dripAmount = blockDelta * dripRatePerBlock;\n\n            /// @dev We can only drip what we have\n            /// @notice if the dripAmount is greater than the lockedFunds\n            /// @notice then we set the dripAmount to the lockedFunds\n            if (dripAmount > lockedFunds) dripAmount = lockedFunds;\n\n            /// @dev unlock the dripAmount from the lockedFunds\n            /// @notice so that it reflects the amount of xETH that is available\n            /// @notice and the exchange rate shows that\n            lockedFunds -= dripAmount;\n\n            /// @dev set the lastReport to the current block\n            lastReport = block.number;\n\n            /// @notice if there are no remaining locked funds\n            /// @notice the drip must be stopped.\n            if (lockedFunds == 0) {\n                dripEnabled = false;\n                emit DripStopped();\n            }\n\n            /// @dev emit succesful drip event with dripAmount, lockedFunds and xETH balance\n            emit Drip(dripAmount, lockedFunds, xETH.balanceOf(address(this)));\n        }\n    }\n\n    /// @dev modifier drip calls accrueDrip before executing the function\n    modifier drip() {\n        _accrueDrip();\n        _;\n    }\n}"
    }
  ]
}