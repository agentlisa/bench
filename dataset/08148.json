{
  "Title": "[G-03]  Using `private` rather than `public` for constants, saves gas (8 instances)",
  "Content": "\nIf needed, the value can be read from the verified contract source code. Savings are due to the compiler not having to create non-payable getter functions for deployment calldata, and not adding another entry to the method ID table\n\nDeployment Gas Saved: **45 857**<br>\nMethod Call Gas Saved: **308**<br>\n\n*   src/policies/Governance.sol:[119-137](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Governance.sol#L119-L137)\n\n```solidity\n119    /// @notice The amount of votes a proposer needs in order to submit a proposal as a percentage of total supply (in basis points).\n120    /// @dev    This is set to 1% of the total supply.\n121    uint256 public constant SUBMISSION_REQUIREMENT = 100;\n122\n123    /// @notice Amount of time a submitted proposal has to activate before it expires.\n124    uint256 public constant ACTIVATION_DEADLINE = 2 weeks;\n125\n126    /// @notice Amount of time an activated proposal must stay up before it can be replaced by a new activated proposal.\n127    uint256 public constant GRACE_PERIOD = 1 weeks;\n128\n129    /// @notice Endorsements required to activate a proposal as percentage of total supply.\n130    uint256 public constant ENDORSEMENT_THRESHOLD = 20;\n131\n132    /// @notice Net votes required to execute a proposal on chain as a percentage of total supply.\n133    uint256 public constant EXECUTION_THRESHOLD = 33;\n134\n135    /// @notice Required time for a proposal to be active before it can be executed.\n136    /// @dev    This amount should be greater than 0 to prevent flash loan attacks.\n137    uint256 public constant EXECUTION_TIMELOCK = 3 days;\n```\n\n*   src/policies/Operator.sol:[89](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/policies/Operator.sol#L89)\n\n```solidity\n89     uint32 public constant FACTOR_SCALE = 1e4;\n```\n\n*   src/modules/RANGE.sol:[65](https://github.com/code-423n4/2022-08-olympus/blob/b5e139d732eb4c07102f149fb9426d356af617aa/src/modules/RANGE.sol#L65)\n\n```solidity\n65     uint256 public constant FACTOR_SCALE = 1e4;\n```\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/contests/2022-08-olympus-dao-contest",
  "Code": [
    {
      "filename": "src/policies/Governance.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// The Governance Policy submits & activates instructions in a INSTR module\n\nimport {OlympusInstructions} from \"modules/INSTR.sol\";\nimport {OlympusVotes} from \"modules/VOTES.sol\";\nimport \"src/Kernel.sol\";\n\n// proposing\nerror NotEnoughVotesToPropose();\n\n// endorsing\nerror CannotEndorseNullProposal();\nerror CannotEndorseInvalidProposal();\n\n// activating\nerror NotAuthorizedToActivateProposal();\nerror NotEnoughEndorsementsToActivateProposal();\nerror ProposalAlreadyActivated();\nerror ActiveProposalNotExpired();\nerror SubmittedProposalHasExpired();\n\n// voting\nerror NoActiveProposalDetected();\nerror UserAlreadyVoted();\n\n// executing\nerror NotEnoughVotesToExecute();\nerror ExecutionTimelockStillActive();\n\n// claiming\nerror VotingTokensAlreadyReclaimed();\nerror CannotReclaimTokensForActiveVote();\nerror CannotReclaimZeroVotes();\n\nstruct ProposalMetadata {\n    bytes32 title;\n    address submitter;\n    uint256 submissionTimestamp;\n    string proposalURI;\n}\n\nstruct ActivatedProposal {\n    uint256 proposalId;\n    uint256 activationTimestamp;\n}\n\n/// @notice OlympusGovernance\n/// @dev The Governor Policy is also the Kernel's Executor.\ncontract OlympusGovernance is Policy {\n    /////////////////////////////////////////////////////////////////////////////////\n    //                         Kernel Policy Configuration                         //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    OlympusInstructions public INSTR;\n    OlympusVotes public VOTES;\n\n    constructor(Kernel kernel_) Policy(kernel_) {}\n\n    function configureDependencies() external override returns (Keycode[] memory dependencies) {\n        dependencies = new Keycode[](2);\n        dependencies[0] = toKeycode(\"INSTR\");\n        dependencies[1] = toKeycode(\"VOTES\");\n\n        INSTR = OlympusInstructions(getModuleAddress(dependencies[0]));\n        VOTES = OlympusVotes(getModuleAddress(dependencies[1]));\n    }\n\n    function requestPermissions()\n        external\n        view\n        override\n        onlyKernel\n        returns (Permissions[] memory requests)\n    {\n        requests = new Permissions[](2);\n        requests[0] = Permissions(INSTR.KEYCODE(), INSTR.store.selector);\n        requests[1] = Permissions(VOTES.KEYCODE(), VOTES.transferFrom.selector);\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                             Policy Variables                                //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    event ProposalSubmitted(uint256 proposalId);\n    event ProposalEndorsed(uint256 proposalId, address voter, uint256 amount);\n    event ProposalActivated(uint256 proposalId, uint256 timestamp);\n    event WalletVoted(uint256 proposalId, address voter, bool for_, uint256 userVotes);\n    event ProposalExecuted(uint256 proposalId);\n\n    /// @notice The currently activated proposal in the governance system.\n    ActivatedProposal public activeProposal;\n\n    /// @notice Return a proposal metadata object for a given proposal id.\n    mapping(uint256 => ProposalMetadata) public getProposalMetadata;\n\n    /// @notice Return the total endorsements for a proposal id.\n    mapping(uint256 => uint256) public totalEndorsementsForProposal;\n\n    /// @notice Return the number of endorsements a user has given a proposal id.\n    mapping(uint256 => mapping(address => uint256)) public userEndorsementsForProposal;\n\n    /// @notice Return whether a proposal id has been activated. Once this is true, it should never be flipped false.\n    mapping(uint256 => bool) public proposalHasBeenActivated;\n\n    /// @notice Return the total yes votes for a proposal id used in calculating net votes.\n    mapping(uint256 => uint256) public yesVotesForProposal;\n\n    /// @notice Return the total no votes for a proposal id used in calculating net votes.\n    mapping(uint256 => uint256) public noVotesForProposal;\n\n    /// @notice Return the amount of votes a user has applied to a proposal id. This does not record how the user voted.\n    mapping(uint256 => mapping(address => uint256)) public userVotesForProposal;\n\n    /// @notice Return the amount of tokens reclaimed by a user after voting on a proposal id.\n    mapping(uint256 => mapping(address => bool)) public tokenClaimsForProposal;\n\n    /// @notice The amount of votes a proposer needs in order to submit a proposal as a percentage of total supply (in basis points).\n    /// @dev    This is set to 1% of the total supply.\n    uint256 public constant SUBMISSION_REQUIREMENT = 100;\n\n    /// @notice Amount of time a submitted proposal has to activate before it expires.\n    uint256 public constant ACTIVATION_DEADLINE = 2 weeks;\n\n    /// @notice Amount of time an activated proposal must stay up before it can be replaced by a new activated proposal.\n    uint256 public constant GRACE_PERIOD = 1 weeks;\n\n    /// @notice Endorsements required to activate a proposal as percentage of total supply.\n    uint256 public constant ENDORSEMENT_THRESHOLD = 20;\n\n    /// @notice Net votes required to execute a proposal on chain as a percentage of total supply.\n    uint256 public constant EXECUTION_THRESHOLD = 33;\n\n    /// @notice Required time for a proposal to be active before it can be executed.\n    /// @dev    This amount should be greater than 0 to prevent flash loan attacks.\n    uint256 public constant EXECUTION_TIMELOCK = 3 days;\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                               User Actions                                  //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Return the metadata for a proposal.\n    /// @dev    Used to return & access the entire metadata struct in solidity\n    function getMetadata(uint256 proposalId_) public view returns (ProposalMetadata memory) {\n        return getProposalMetadata[proposalId_];\n    }\n\n    /// @notice Return the currently active proposal in governance.\n    /// @dev    Used to return & access the entire struct active proposal struct in solidity.\n    function getActiveProposal() public view returns (ActivatedProposal memory) {\n        return activeProposal;\n    }\n\n    /// @notice Submit an on chain governance proposal.\n    /// @param  instructions_ - an array of Instruction objects each containing a Kernel Action and a target Contract address.\n    /// @param  title_ - a human-readable title of the proposal â€” i.e. \"OIP XX - My Proposal Title\".\n    /// @param  proposalURI_ - an arbitrary url linking to a human-readable description of the proposal - i.e. Snapshot, Discourse, Google Doc.\n    function submitProposal(\n        Instruction[] calldata instructions_,\n        bytes32 title_,\n        string memory proposalURI_\n    ) external {\n        if (VOTES.balanceOf(msg.sender) * 10000 < VOTES.totalSupply() * SUBMISSION_REQUIREMENT)\n            revert NotEnoughVotesToPropose();\n\n        uint256 proposalId = INSTR.store(instructions_);\n        getProposalMetadata[proposalId] = ProposalMetadata(\n            title_,\n            msg.sender,\n            block.timestamp,\n            proposalURI_\n        );\n\n        emit ProposalSubmitted(proposalId);\n    }\n\n    /// @notice Endorse a proposal.\n    /// @param  proposalId_ - The ID of the proposal being endorsed.\n    function endorseProposal(uint256 proposalId_) external {\n        uint256 userVotes = VOTES.balanceOf(msg.sender);\n\n        if (proposalId_ == 0) {\n            revert CannotEndorseNullProposal();\n        }\n\n        Instruction[] memory instructions = INSTR.getInstructions(proposalId_);\n        if (instructions.length == 0) {\n            revert CannotEndorseInvalidProposal();\n        }\n\n        // undo any previous endorsement the user made on these instructions\n        uint256 previousEndorsement = userEndorsementsForProposal[proposalId_][msg.sender];\n        totalEndorsementsForProposal[proposalId_] -= previousEndorsement;\n\n        // reapply user endorsements with most up-to-date votes\n        userEndorsementsForProposal[proposalId_][msg.sender] = userVotes;\n        totalEndorsementsForProposal[proposalId_] += userVotes;\n\n        emit ProposalEndorsed(proposalId_, msg.sender, userVotes);\n    }\n\n    /// @notice Activate a proposal.\n    /// @param  proposalId_ - The ID of the proposal being activated.\n    function activateProposal(uint256 proposalId_) external {\n        ProposalMetadata memory proposal = getProposalMetadata[proposalId_];\n\n        if (msg.sender != proposal.submitter) {\n            revert NotAuthorizedToActivateProposal();\n        }\n\n        if (block.timestamp > proposal.submissionTimestamp + ACTIVATION_DEADLINE) {\n            revert SubmittedProposalHasExpired();\n        }\n\n        if (\n            (totalEndorsementsForProposal[proposalId_] * 100) <\n            VOTES.totalSupply() * ENDORSEMENT_THRESHOLD\n        ) {\n            revert NotEnoughEndorsementsToActivateProposal();\n        }\n\n        if (proposalHasBeenActivated[proposalId_] == true) {\n            revert ProposalAlreadyActivated();\n        }\n\n        if (block.timestamp < activeProposal.activationTimestamp + GRACE_PERIOD) {\n            revert ActiveProposalNotExpired();\n        }\n\n        activeProposal = ActivatedProposal(proposalId_, block.timestamp);\n\n        proposalHasBeenActivated[proposalId_] = true;\n\n        emit ProposalActivated(proposalId_, block.timestamp);\n    }\n\n    /// @notice Cast a vote for the currently active proposal.\n    /// @param  for_ - A boolean representing the vote: true for yes, false for no.\n    function vote(bool for_) external {\n        uint256 userVotes = VOTES.balanceOf(msg.sender);\n\n        if (activeProposal.proposalId == 0) {\n            revert NoActiveProposalDetected();\n        }\n\n        if (userVotesForProposal[activeProposal.proposalId][msg.sender] > 0) {\n            revert UserAlreadyVoted();\n        }\n\n        if (for_) {\n            yesVotesForProposal[activeProposal.proposalId] += userVotes;\n        } else {\n            noVotesForProposal[activeProposal.proposalId] += userVotes;\n        }\n\n        userVotesForProposal[activeProposal.proposalId][msg.sender] = userVotes;\n\n        VOTES.transferFrom(msg.sender, address(this), userVotes);\n\n        emit WalletVoted(activeProposal.proposalId, msg.sender, for_, userVotes);\n    }\n\n    /// @notice Execute the currently active proposal.\n    function executeProposal() external {\n        uint256 netVotes = yesVotesForProposal[activeProposal.proposalId] -\n            noVotesForProposal[activeProposal.proposalId];\n        if (netVotes * 100 < VOTES.totalSupply() * EXECUTION_THRESHOLD) {\n            revert NotEnoughVotesToExecute();\n        }\n\n        if (block.timestamp < activeProposal.activationTimestamp + EXECUTION_TIMELOCK) {\n            revert ExecutionTimelockStillActive();\n        }\n\n        Instruction[] memory instructions = INSTR.getInstructions(activeProposal.proposalId);\n\n        for (uint256 step; step < instructions.length; ) {\n            kernel.executeAction(instructions[step].action, instructions[step].target);\n            unchecked {\n                ++step;\n            }\n        }\n\n        emit ProposalExecuted(activeProposal.proposalId);\n\n        // deactivate the active proposal\n        activeProposal = ActivatedProposal(0, 0);\n    }\n\n    /// @notice Reclaim locked votes from the contract after the proposal is no longer active.\n    /// @dev    The governance contract locks casted votes into the contract until the proposal\n    ///         is no longer active to prevent repeated voting with the same tokens.\n    /// @param  proposalId_ - The proposal that the user is reclaiming tokens for.\n    function reclaimVotes(uint256 proposalId_) external {\n        uint256 userVotes = userVotesForProposal[proposalId_][msg.sender];\n\n        if (userVotes == 0) {\n            revert CannotReclaimZeroVotes();\n        }\n\n        if (proposalId_ == activeProposal.proposalId) {\n            revert CannotReclaimTokensForActiveVote();\n        }\n\n        if (tokenClaimsForProposal[proposalId_][msg.sender] == true) {\n            revert VotingTokensAlreadyReclaimed();\n        }\n\n        tokenClaimsForProposal[proposalId_][msg.sender] = true;\n\n        VOTES.transferFrom(address(this), msg.sender, userVotes);\n    }\n}"
    },
    {
      "filename": "src/policies/Operator.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.15;\n\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IOperator} from \"policies/interfaces/IOperator.sol\";\nimport {IBondAuctioneer} from \"interfaces/IBondAuctioneer.sol\";\nimport {IBondCallback} from \"interfaces/IBondCallback.sol\";\n\nimport {OlympusTreasury} from \"modules/TRSRY.sol\";\nimport {OlympusMinter} from \"modules/MINTR.sol\";\nimport {OlympusPrice} from \"modules/PRICE.sol\";\nimport {OlympusRange} from \"modules/RANGE.sol\";\n\nimport \"src/Kernel.sol\";\n\nimport {TransferHelper} from \"libraries/TransferHelper.sol\";\nimport {FullMath} from \"libraries/FullMath.sol\";\n\n/// @title  Olympus Range Operator\n/// @notice Olympus Range Operator (Policy) Contract\n/// @dev    The Olympus Range Operator performs market operations to enforce OlympusDAO's OHM price range\n///         guidance policies against a specific reserve asset. The Operator is maintained by a keeper-triggered\n///         function on the Olympus Heart contract, which orchestrates state updates in the correct order to ensure\n///         market operations use up to date information. When the price of OHM against the reserve asset exceeds\n///         the cushion spread, the Operator deploys bond markets to support the price. The Operator also offers\n///         zero slippage swaps at prices dictated by the wall spread from the moving average. These market operations\n///         are performed up to a specific capacity before the market must stabilize to regenerate the capacity.\ncontract Operator is IOperator, Policy, ReentrancyGuard {\n    using TransferHelper for ERC20;\n    using FullMath for uint256;\n\n    /* ========== ERRORS =========== */\n\n    error Operator_InvalidParams();\n    error Operator_InsufficientCapacity();\n    error Operator_AmountLessThanMinimum(uint256 amountOut, uint256 minAmountOut);\n    error Operator_WallDown();\n    error Operator_AlreadyInitialized();\n    error Operator_NotInitialized();\n    error Operator_Inactive();\n\n    /* ========== EVENTS =========== */\n    event Swap(\n        ERC20 indexed tokenIn_,\n        ERC20 indexed tokenOut_,\n        uint256 amountIn_,\n        uint256 amountOut_\n    );\n    event CushionFactorChanged(uint32 cushionFactor_);\n    event CushionParamsChanged(uint32 duration_, uint32 debtBuffer_, uint32 depositInterval_);\n    event ReserveFactorChanged(uint32 reserveFactor_);\n    event RegenParamsChanged(uint32 wait_, uint32 threshold_, uint32 observe_);\n\n    /* ========== STATE VARIABLES ========== */\n\n    /// Operator variables, defined in the interface on the external getter functions\n    Status internal _status;\n    Config internal _config;\n\n    /// @notice    Whether the Operator has been initialized\n    bool public initialized;\n\n    /// @notice    Whether the Operator is active\n    bool public active;\n\n    /// Modules\n    OlympusPrice internal PRICE;\n    OlympusRange internal RANGE;\n    OlympusTreasury internal TRSRY;\n    OlympusMinter internal MINTR;\n\n    /// External contracts\n    /// @notice     Auctioneer contract used for cushion bond market deployments\n    IBondAuctioneer public auctioneer;\n    /// @notice     Callback contract used for cushion bond market payouts\n    IBondCallback public callback;\n\n    /// Tokens\n    /// @notice     OHM token contract\n    ERC20 public immutable ohm;\n    uint8 public immutable ohmDecimals;\n    /// @notice     Reserve token contract\n    ERC20 public immutable reserve;\n    uint8 public immutable reserveDecimals;\n\n    /// Constants\n    uint32 public constant FACTOR_SCALE = 1e4;\n\n    /* ========== CONSTRUCTOR ========== */\n    constructor(\n        Kernel kernel_,\n        IBondAuctioneer auctioneer_,\n        IBondCallback callback_,\n        ERC20[2] memory tokens_, // [ohm, reserve]\n        uint32[8] memory configParams // [cushionFactor, cushionDuration, cushionDebtBuffer, cushionDepositInterval, reserveFactor, regenWait, regenThreshold, regenObserve]\n    ) Policy(kernel_) {\n        /// Check params are valid\n        if (address(auctioneer_) == address(0) || address(callback_) == address(0))\n            revert Operator_InvalidParams();\n\n        if (configParams[1] > uint256(7 days) || configParams[1] < uint256(1 days))\n            revert Operator_InvalidParams();\n\n        if (configParams[2] < uint32(10_000)) revert Operator_InvalidParams();\n\n        if (configParams[3] < uint32(1 hours) || configParams[3] > configParams[1])\n            revert Operator_InvalidParams();\n\n        if (configParams[4] > 10000 || configParams[4] < 100) revert Operator_InvalidParams();\n\n        if (\n            configParams[5] < 1 hours ||\n            configParams[6] > configParams[7] ||\n            configParams[7] == uint32(0)\n        ) revert Operator_InvalidParams();\n\n        auctioneer = auctioneer_;\n        callback = callback_;\n        ohm = tokens_[0];\n        ohmDecimals = tokens_[0].decimals();\n        reserve = tokens_[1];\n        reserveDecimals = tokens_[1].decimals();\n\n        Regen memory regen = Regen({\n            count: uint32(0),\n            lastRegen: uint48(block.timestamp),\n            nextObservation: uint32(0),\n            observations: new bool[](configParams[7])\n        });\n\n        _config = Config({\n            cushionFactor: configParams[0],\n            cushionDuration: configParams[1],\n            cushionDebtBuffer: configParams[2],\n            cushionDepositInterval: configParams[3],\n            reserveFactor: configParams[4],\n            regenWait: configParams[5],\n            regenThreshold: configParams[6],\n            regenObserve: configParams[7]\n        });\n\n        _status = Status({low: regen, high: regen});\n\n        emit CushionFactorChanged(configParams[0]);\n        emit CushionParamsChanged(configParams[1], configParams[2], configParams[3]);\n        emit ReserveFactorChanged(configParams[4]);\n        emit RegenParamsChanged(configParams[5], configParams[6], configParams[7]);\n    }\n\n    /* ========== FRAMEWORK CONFIGURATION ========== */\n    /// @inheritdoc Policy\n    function configureDependencies() external override returns (Keycode[] memory dependencies) {\n        dependencies = new Keycode[](4);\n        dependencies[0] = toKeycode(\"PRICE\");\n        dependencies[1] = toKeycode(\"RANGE\");\n        dependencies[2] = toKeycode(\"TRSRY\");\n        dependencies[3] = toKeycode(\"MINTR\");\n\n        PRICE = OlympusPrice(getModuleAddress(dependencies[0]));\n        RANGE = OlympusRange(getModuleAddress(dependencies[1]));\n        TRSRY = OlympusTreasury(getModuleAddress(dependencies[2]));\n        MINTR = OlympusMinter(getModuleAddress(dependencies[3]));\n\n        /// Approve MINTR for burning OHM (called here so that it is re-approved on updates)\n        ohm.safeApprove(address(MINTR), type(uint256).max);\n    }\n\n    /// @inheritdoc Policy\n    function requestPermissions() external view override returns (Permissions[] memory requests) {\n        Keycode RANGE_KEYCODE = RANGE.KEYCODE();\n        Keycode TRSRY_KEYCODE = TRSRY.KEYCODE();\n        Keycode MINTR_KEYCODE = MINTR.KEYCODE();\n\n        requests = new Permissions[](9);\n        requests[0] = Permissions(RANGE_KEYCODE, RANGE.updateCapacity.selector);\n        requests[1] = Permissions(RANGE_KEYCODE, RANGE.updateMarket.selector);\n        requests[2] = Permissions(RANGE_KEYCODE, RANGE.updatePrices.selector);\n        requests[3] = Permissions(RANGE_KEYCODE, RANGE.regenerate.selector);\n        requests[4] = Permissions(RANGE_KEYCODE, RANGE.setSpreads.selector);\n        requests[5] = Permissions(RANGE_KEYCODE, RANGE.setThresholdFactor.selector);\n        requests[6] = Permissions(TRSRY_KEYCODE, TRSRY.setApprovalFor.selector);\n        requests[7] = Permissions(MINTR_KEYCODE, MINTR.mintOhm.selector);\n        requests[8] = Permissions(MINTR_KEYCODE, MINTR.burnOhm.selector);\n    }\n\n    modifier onlyWhileActive() {\n        if (!active) revert Operator_Inactive();\n        _;\n    }\n\n    /* ========== HEART FUNCTIONS ========== */\n    /// @inheritdoc IOperator\n    function operate() external override onlyWhileActive onlyRole(\"operator_operate\") {\n        /// Revert if not initialized\n        if (!initialized) revert Operator_NotInitialized();\n\n        /// Update the prices for the range, save new regen observations, and update capacities based on bond market activity\n        _updateRangePrices();\n        _addObservation();\n        _updateCapacity(true, 0);\n        _updateCapacity(false, 0);\n\n        /// Cache config in memory\n        Config memory config_ = _config;\n\n        /// Check if walls can regenerate capacity\n        if (\n            uint48(block.timestamp) >= RANGE.lastActive(true) + uint48(config_.regenWait) &&\n            _status.high.count >= config_.regenThreshold\n        ) {\n            _regenerate(true);\n        }\n        if (\n            uint48(block.timestamp) >= RANGE.lastActive(false) + uint48(config_.regenWait) &&\n            _status.low.count >= config_.regenThreshold\n        ) {\n            _regenerate(false);\n        }\n\n        /// Cache range data after potential regeneration\n        OlympusRange.Range memory range = RANGE.range();\n\n        /// Get latest price\n        /// See note in addObservation() for more details\n        uint256 currentPrice = PRICE.getLastPrice();\n\n        /// Check if the cushion bond markets are active\n        /// if so, determine if it should stay open or close\n        /// if not, check if a new one should be opened\n        if (range.low.active) {\n            if (auctioneer.isLive(range.low.market)) {\n                /// if active, check if the price is back above the cushion\n                /// or if the price is below the wall\n                /// if so, close the market\n                if (currentPrice > range.cushion.low.price || currentPrice < range.wall.low.price) {\n                    _deactivate(false);\n                }\n            } else {\n                /// if not active, check if the price is below the cushion\n                /// if so, open a new bond market\n                if (currentPrice < range.cushion.low.price && currentPrice > range.wall.low.price) {\n                    _activate(false);\n                }\n            }\n        }\n        if (range.high.active) {\n            if (auctioneer.isLive(range.high.market)) {\n                /// if active, check if the price is back under the cushion\n                /// or if the price is above the wall\n                /// if so, close the market\n                if (\n                    currentPrice < range.cushion.high.price || currentPrice > range.wall.high.price\n                ) {\n                    _deactivate(true);\n                }\n            } else {\n                /// if not active, check if the price is above the cushion\n                /// if so, open a new bond market\n                if (\n                    currentPrice > range.cushion.high.price && currentPrice < range.wall.high.price\n                ) {\n                    _activate(true);\n                }\n            }\n        }\n    }\n\n    /* ========== OPEN MARKET OPERATIONS (WALL) ========== */\n    /// @inheritdoc IOperator\n    function swap(\n        ERC20 tokenIn_,\n        uint256 amountIn_,\n        uint256 minAmountOut_\n    ) external override onlyWhileActive nonReentrant returns (uint256 amountOut) {\n        if (tokenIn_ == ohm) {\n            /// Revert if lower wall is inactive\n            if (!RANGE.active(false)) revert Operator_WallDown();\n\n            /// Calculate amount out (checks for sufficient capacity)\n            amountOut = getAmountOut(tokenIn_, amountIn_);\n\n            /// Revert if amount out less than the minimum specified\n            /// @dev even though price is fixed most of the time,\n            /// it is possible that the amount out could change on a sender\n            /// due to the wall prices being updated before their transaction is processed.\n            /// This would be the equivalent of the heart.beat front-running the sender.\n            if (amountOut < minAmountOut_)\n                revert Operator_AmountLessThanMinimum(amountOut, minAmountOut_);\n\n            /// Decrement wall capacity\n            _updateCapacity(false, amountOut);\n\n            /// If wall is down after swap, deactive the cushion as well\n            _checkCushion(false);\n\n            /// Transfer OHM from sender\n            ohm.safeTransferFrom(msg.sender, address(this), amountIn_);\n\n            /// Burn OHM\n            MINTR.burnOhm(address(this), amountIn_);\n\n            /// Withdraw and transfer reserve to sender\n            TRSRY.withdrawReserves(msg.sender, reserve, amountOut);\n\n            emit Swap(ohm, reserve, amountIn_, amountOut);\n        } else if (tokenIn_ == reserve) {\n            /// Revert if upper wall is inactive\n            if (!RANGE.active(true)) revert Operator_WallDown();\n\n            /// Calculate amount out (checks for sufficient capacity)\n            amountOut = getAmountOut(tokenIn_, amountIn_);\n\n            /// Revert if amount out less than the minimum specified\n            /// @dev even though price is fixed most of the time,\n            /// it is possible that the amount out could change on a sender\n            /// due to the wall prices being updated before their transaction is processed.\n            /// This would be the equivalent of the heart.beat front-running the sender.\n            if (amountOut < minAmountOut_)\n                revert Operator_AmountLessThanMinimum(amountOut, minAmountOut_);\n\n            /// Decrement wall capacity\n            _updateCapacity(true, amountOut);\n\n            /// If wall is down after swap, deactive the cushion as well\n            _checkCushion(true);\n\n            /// Transfer reserves to treasury\n            reserve.safeTransferFrom(msg.sender, address(TRSRY), amountIn_);\n\n            /// Mint OHM to sender\n            MINTR.mintOhm(msg.sender, amountOut);\n\n            emit Swap(reserve, ohm, amountIn_, amountOut);\n        } else {\n            revert Operator_InvalidParams();\n        }\n    }\n\n    /* ========== BOND MARKET OPERATIONS (CUSHION) ========== */\n    /// @notice             Records a bond purchase and updates capacity correctly\n    /// @notice             Access restricted (BondCallback)\n    /// @param id_          ID of the bond market\n    /// @param amountOut_   Amount of capacity expended\n    function bondPurchase(uint256 id_, uint256 amountOut_)\n        external\n        onlyWhileActive\n        onlyRole(\"operator_reporter\")\n    {\n        if (id_ == RANGE.market(true)) {\n            _updateCapacity(true, amountOut_);\n            _checkCushion(true);\n        }\n        if (id_ == RANGE.market(false)) {\n            _updateCapacity(false, amountOut_);\n            _checkCushion(false);\n        }\n    }\n\n    /// @notice      Activate a cushion by deploying a bond market\n    /// @param high_ Whether the cushion is for the high or low side of the range (true = high, false = low)\n    function _activate(bool high_) internal {\n        OlympusRange.Range memory range = RANGE.range();\n\n        if (high_) {\n            /// Calculate scaleAdjustment for bond market\n            /// Price decimals are returned from the perspective of the quote token\n            /// so the operations assume payoutPriceDecimal is zero and quotePriceDecimals\n            /// is the priceDecimal value\n            int8 priceDecimals = _getPriceDecimals(range.cushion.high.price);\n            int8 scaleAdjustment = int8(ohmDecimals) - int8(reserveDecimals) + (priceDecimals / 2);\n\n            /// Calculate oracle scale and bond scale with scale adjustment and format prices for bond market\n            uint256 oracleScale = 10**uint8(int8(PRICE.decimals()) - priceDecimals);\n            uint256 bondScale = 10 **\n                uint8(\n                    36 + scaleAdjustment + int8(reserveDecimals) - int8(ohmDecimals) - priceDecimals\n                );\n\n            uint256 initialPrice = range.wall.high.price.mulDiv(bondScale, oracleScale);\n            uint256 minimumPrice = range.cushion.high.price.mulDiv(bondScale, oracleScale);\n\n            /// Cache config struct to avoid multiple SLOADs\n            Config memory config_ = _config;\n\n            /// Calculate market capacity from the cushion factor\n            uint256 marketCapacity = range.high.capacity.mulDiv(\n                config_.cushionFactor,\n                FACTOR_SCALE\n            );\n\n            /// Create new bond market to buy the reserve with OHM\n            IBondAuctioneer.MarketParams memory params = IBondAuctioneer.MarketParams({\n                payoutToken: ohm,\n                quoteToken: reserve,\n                callbackAddr: address(callback),\n                capacityInQuote: false,\n                capacity: marketCapacity,\n                formattedInitialPrice: initialPrice,\n                formattedMinimumPrice: minimumPrice,\n                debtBuffer: config_.cushionDebtBuffer,\n                vesting: uint48(0), // Instant swaps\n                conclusion: uint48(block.timestamp + config_.cushionDuration),\n                depositInterval: config_.cushionDepositInterval,\n                scaleAdjustment: scaleAdjustment\n            });\n\n            uint256 market = auctioneer.createMarket(params);\n\n            /// Whitelist the bond market on the callback\n            callback.whitelist(address(auctioneer.getTeller()), market);\n\n            /// Update the market information on the range module\n            RANGE.updateMarket(true, market, marketCapacity);\n        } else {\n            /// Calculate inverse prices from the oracle feed for the low side\n            uint8 oracleDecimals = PRICE.decimals();\n            uint256 invCushionPrice = 10**(oracleDecimals * 2) / range.cushion.low.price;\n            uint256 invWallPrice = 10**(oracleDecimals * 2) / range.wall.low.price;\n\n            /// Calculate scaleAdjustment for bond market\n            /// Price decimals are returned from the perspective of the quote token\n            /// so the operations assume payoutPriceDecimal is zero and quotePriceDecimals\n            /// is the priceDecimal value\n            int8 priceDecimals = _getPriceDecimals(invCushionPrice);\n            int8 scaleAdjustment = int8(reserveDecimals) - int8(ohmDecimals) + (priceDecimals / 2);\n\n            /// Calculate oracle scale and bond scale with scale adjustment and format prices for bond market\n            uint256 oracleScale = 10**uint8(int8(oracleDecimals) - priceDecimals);\n            uint256 bondScale = 10 **\n                uint8(\n                    36 + scaleAdjustment + int8(ohmDecimals) - int8(reserveDecimals) - priceDecimals\n                );\n\n            uint256 initialPrice = invWallPrice.mulDiv(bondScale, oracleScale);\n            uint256 minimumPrice = invCushionPrice.mulDiv(bondScale, oracleScale);\n\n            /// Cache config struct to avoid multiple SLOADs\n            Config memory config_ = _config;\n\n            /// Calculate market capacity from the cushion factor\n            uint256 marketCapacity = range.low.capacity.mulDiv(config_.cushionFactor, FACTOR_SCALE);\n\n            /// Create new bond market to buy OHM with the reserve\n            IBondAuctioneer.MarketParams memory params = IBondAuctioneer.MarketParams({\n                payoutToken: reserve,\n                quoteToken: ohm,\n                callbackAddr: address(callback),\n                capacityInQuote: false,\n                capacity: marketCapacity,\n                formattedInitialPrice: initialPrice,\n                formattedMinimumPrice: minimumPrice,\n                debtBuffer: config_.cushionDebtBuffer,\n                vesting: uint48(0), // Instant swaps\n                conclusion: uint48(block.timestamp + config_.cushionDuration),\n                depositInterval: config_.cushionDepositInterval,\n                scaleAdjustment: scaleAdjustment\n            });\n\n            uint256 market = auctioneer.createMarket(params);\n\n            /// Whitelist the bond market on the callback\n            callback.whitelist(address(auctioneer.getTeller()), market);\n\n            /// Update the market information on the range module\n            RANGE.updateMarket(false, market, marketCapacity);\n        }\n    }\n\n    /// @notice      Deactivate a cushion by closing a bond market (if it is active)\n    /// @param high_ Whether the cushion is for the"
    }
  ]
}