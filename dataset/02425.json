{
  "Title": "M-13: BasicSpell.doCutRewardsFee uses depositFee instead of withdraw fee",
  "Content": "# Issue M-13: BasicSpell.doCutRewardsFee uses depositFee instead of withdraw fee \n\nSource: https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/82 \n\n## Found by \nrvierdiiev\n\n## Summary\nBasicSpell.doCutRewardsFee uses depositFee instead of withdraw fee\n## Vulnerability Detail\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/spell/BasicSpell.sol#L65-L79\n```solidity\n    function doCutRewardsFee(address token) internal {\n        if (bank.config().treasury() == address(0)) revert NO_TREASURY_SET();\n\n\n        uint256 balance = IERC20Upgradeable(token).balanceOf(address(this));\n        if (balance > 0) {\n            uint256 fee = (balance * bank.config().depositFee()) / DENOMINATOR;\n            IERC20Upgradeable(token).safeTransfer(\n                bank.config().treasury(),\n                fee\n            );\n\n\n            balance -= fee;\n            IERC20Upgradeable(token).safeTransfer(bank.EXECUTOR(), balance);\n        }\n    }\n```\nThis function is called in order to get fee from ICHI rewards, collected by farming.\nBut currently it takes `bank.config().depositFee()` instead of `bank.config().withdrawFee()`.\n## Impact\nWrong fee amount is taken.\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-02-blueberry/blob/main/contracts/spell/BasicSpell.sol#L65-L79\n## Tool used\n\nManual Review\n\n## Recommendation\nTake withdraw fee from rewards.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/41",
  "Code": [
    {
      "filename": "contracts/spell/BasicSpell.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"../utils/BlueBerryConst.sol\";\nimport \"../utils/BlueBerryErrors.sol\";\nimport \"../utils/ERC1155NaiveReceiver.sol\";\nimport \"../interfaces/IBank.sol\";\nimport \"../interfaces/IWERC20.sol\";\nimport \"../interfaces/IWETH.sol\";\n\nabstract contract BasicSpell is ERC1155NaiveReceiver, OwnableUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    IBank public bank;\n    IWERC20 public werc20;\n    address public weth;\n\n    /// @dev Mapping from token to (mapping from spender to approve status)\n    mapping(address => mapping(address => bool)) public approved;\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __BasicSpell_init(\n        IBank _bank,\n        address _werc20,\n        address _weth\n    ) internal onlyInitializing {\n        __Ownable_init();\n\n        bank = _bank;\n        werc20 = IWERC20(_werc20);\n        weth = _weth;\n\n        ensureApprove(_weth, address(_bank));\n        IWERC20(_werc20).setApprovalForAll(address(_bank), true);\n    }\n\n    /// @dev Ensure that the spell has approved the given spender to spend all of its tokens.\n    /// @param token The token to approve.\n    /// @param spender The spender to allow spending.\n    /// NOTE: This is safe because spell is never built to hold fund custody.\n    function ensureApprove(address token, address spender) internal {\n        if (!approved[token][spender]) {\n            IERC20Upgradeable(token).safeApprove(spender, type(uint256).max);\n            approved[token][spender] = true;\n        }\n    }\n\n    /// @dev Internal call to refund tokens to the current bank executor.\n    /// @param token The token to perform the refund action.\n    function doRefund(address token) internal {\n        uint256 balance = IERC20Upgradeable(token).balanceOf(address(this));\n        if (balance > 0) {\n            IERC20Upgradeable(token).safeTransfer(bank.EXECUTOR(), balance);\n        }\n    }\n\n    /// @dev Internal call to refund tokens to the current bank executor.\n    /// @param token The token to perform the refund action.\n    function doCutRewardsFee(address token) internal {\n        if (bank.config().treasury() == address(0)) revert NO_TREASURY_SET();\n\n        uint256 balance = IERC20Upgradeable(token).balanceOf(address(this));\n        if (balance > 0) {\n            uint256 fee = (balance * bank.config().depositFee()) / DENOMINATOR;\n            IERC20Upgradeable(token).safeTransfer(\n                bank.config().treasury(),\n                fee\n            );\n\n            balance -= fee;\n            IERC20Upgradeable(token).safeTransfer(bank.EXECUTOR(), balance);\n        }\n    }\n\n    function doLend(address token, uint256 amount) internal {\n        if (amount > 0) {\n            bank.lend(token, amount);\n        }\n    }\n\n    function doWithdraw(address token, uint256 amount) internal {\n        if (amount > 0) {\n            bank.withdrawLend(token, amount);\n        }\n    }\n\n    /**\n     * @dev Internal call to borrow tokens from the bank on behalf of the current executor.\n     * @param token The token to borrow from the bank.\n     * @param amount The amount to borrow.\n     * @notice Do not use `amount` input argument to handle the received amount.\n     */\n    function doBorrow(address token, uint256 amount) internal {\n        if (amount > 0) {\n            bank.borrow(token, amount);\n        }\n    }\n\n    /// @dev Internal call to repay tokens to the bank on behalf of the current executor.\n    /// @param token The token to repay to the bank.\n    /// @param amount The amount to repay.\n    function doRepay(address token, uint256 amount) internal {\n        if (amount > 0) {\n            ensureApprove(token, address(bank));\n            bank.repay(token, amount);\n        }\n    }\n\n    /// @dev Internal call to put collateral tokens in the bank.\n    /// @param token The token to put in the bank.\n    /// @param amount The amount to put in the bank.\n    function doPutCollateral(address token, uint256 amount) internal {\n        if (amount > 0) {\n            ensureApprove(token, address(werc20));\n            werc20.mint(token, amount);\n            bank.putCollateral(\n                address(werc20),\n                uint256(uint160(token)),\n                amount\n            );\n        }\n    }\n\n    /// @dev Internal call to take collateral tokens from the bank.\n    /// @param token The token to take back.\n    /// @param amount The amount to take back.\n    function doTakeCollateral(address token, uint256 amount) internal {\n        if (amount > 0) {\n            amount = bank.takeCollateral(amount);\n            werc20.burn(token, amount);\n        }\n    }\n\n    /// @dev Fallback function. Can only receive ETH from WETH contract.\n    receive() external payable {\n        if (msg.sender != weth) revert NOT_FROM_WETH(msg.sender);\n    }\n}"
    },
    {
      "filename": "contracts/spell/BasicSpell.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"../utils/BlueBerryConst.sol\";\nimport \"../utils/BlueBerryErrors.sol\";\nimport \"../utils/ERC1155NaiveReceiver.sol\";\nimport \"../interfaces/IBank.sol\";\nimport \"../interfaces/IWERC20.sol\";\nimport \"../interfaces/IWETH.sol\";\n\nabstract contract BasicSpell is ERC1155NaiveReceiver, OwnableUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    IBank public bank;\n    IWERC20 public werc20;\n    address public weth;\n\n    /// @dev Mapping from token to (mapping from spender to approve status)\n    mapping(address => mapping(address => bool)) public approved;\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __BasicSpell_init(\n        IBank _bank,\n        address _werc20,\n        address _weth\n    ) internal onlyInitializing {\n        __Ownable_init();\n\n        bank = _bank;\n        werc20 = IWERC20(_werc20);\n        weth = _weth;\n\n        ensureApprove(_weth, address(_bank));\n        IWERC20(_werc20).setApprovalForAll(address(_bank), true);\n    }\n\n    /// @dev Ensure that the spell has approved the given spender to spend all of its tokens.\n    /// @param token The token to approve.\n    /// @param spender The spender to allow spending.\n    /// NOTE: This is safe because spell is never built to hold fund custody.\n    function ensureApprove(address token, address spender) internal {\n        if (!approved[token][spender]) {\n            IERC20Upgradeable(token).safeApprove(spender, type(uint256).max);\n            approved[token][spender] = true;\n        }\n    }\n\n    /// @dev Internal call to refund tokens to the current bank executor.\n    /// @param token The token to perform the refund action.\n    function doRefund(address token) internal {\n        uint256 balance = IERC20Upgradeable(token).balanceOf(address(this));\n        if (balance > 0) {\n            IERC20Upgradeable(token).safeTransfer(bank.EXECUTOR(), balance);\n        }\n    }\n\n    /// @dev Internal call to refund tokens to the current bank executor.\n    /// @param token The token to perform the refund action.\n    function doCutRewardsFee(address token) internal {\n        if (bank.config().treasury() == address(0)) revert NO_TREASURY_SET();\n\n        uint256 balance = IERC20Upgradeable(token).balanceOf(address(this));\n        if (balance > 0) {\n            uint256 fee = (balance * bank.config().depositFee()) / DENOMINATOR;\n            IERC20Upgradeable(token).safeTransfer(\n                bank.config().treasury(),\n                fee\n            );\n\n            balance -= fee;\n            IERC20Upgradeable(token).safeTransfer(bank.EXECUTOR(), balance);\n        }\n    }\n\n    function doLend(address token, uint256 amount) internal {\n        if (amount > 0) {\n            bank.lend(token, amount);\n        }\n    }\n\n    function doWithdraw(address token, uint256 amount) internal {\n        if (amount > 0) {\n            bank.withdrawLend(token, amount);\n        }\n    }\n\n    /**\n     * @dev Internal call to borrow tokens from the bank on behalf of the current executor.\n     * @param token The token to borrow from the bank.\n     * @param amount The amount to borrow.\n     * @notice Do not use `amount` input argument to handle the received amount.\n     */\n    function doBorrow(address token, uint256 amount) internal {\n        if (amount > 0) {\n            bank.borrow(token, amount);\n        }\n    }\n\n    /// @dev Internal call to repay tokens to the bank on behalf of the current executor.\n    /// @param token The token to repay to the bank.\n    /// @param amount The amount to repay.\n    function doRepay(address token, uint256 amount) internal {\n        if (amount > 0) {\n            ensureApprove(token, address(bank));\n            bank.repay(token, amount);\n        }\n    }\n\n    /// @dev Internal call to put collateral tokens in the bank.\n    /// @param token The token to put in the bank.\n    /// @param amount The amount to put in the bank.\n    function doPutCollateral(address token, uint256 amount) internal {\n        if (amount > 0) {\n            ensureApprove(token, address(werc20));\n            werc20.mint(token, amount);\n            bank.putCollateral(\n                address(werc20),\n                uint256(uint160(token)),\n                amount\n            );\n        }\n    }\n\n    /// @dev Internal call to take collateral tokens from the bank.\n    /// @param token The token to take back.\n    /// @param amount The amount to take back.\n    function doTakeCollateral(address token, uint256 amount) internal {\n        if (amount > 0) {\n            amount = bank.takeCollateral(amount);\n            werc20.burn(token, amount);\n        }\n    }\n\n    /// @dev Fallback function. Can only receive ETH from WETH contract.\n    receive() external payable {\n        if (msg.sender != weth) revert NOT_FROM_WETH(msg.sender);\n    }\n}"
    }
  ]
}