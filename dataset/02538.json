{
  "Title": "M-6: Using one controller for two addresses could risk signature collisions",
  "Content": "# Issue M-6: Using one controller for two addresses could risk signature collisions \n\nSource: https://github.com/sherlock-audit/2023-01-sentiment-judging/issues/9 \n\n## Found by \nobront\n\n## Summary\n\nThe DNGMXVaultController is intended to be used as a controller for two separate contracts when interacting with Rage Trade. While individual contracts check for signature collisions, there is no protection in this Controller. If the contracts end up with functions with colliding signatures, this may enable users to call illegal functions and get around the protocol safeguards.\n\n## Vulnerability Detail\n\nWhile most of Sentiment's Controllers correspond to one contract, the DNGMXVaultController is one controller that will support two separate contracts: `DepositPeriphery` and `WithdrawPeriphery`.\n\nWhile signature collisions are unlikely, they do happen. For this reason, the Solidity compiler stops code from compiling in the case of a collision. This ensures that there will not be issues in any EVM bytecode. Because Sentiment controllers  approve function calls based on signatures, they can be sure that, for any given contract, they will only be approving the function they are intending.\n\nHowever, once multiple contracts are managed by one controller, there are no compiler checks across these contracts for colliding signatures. The result is that there is the potential for a function signature on one contract that is approved, due to a matching signature on the other contract.\n\n## Impact\n\nThere is the potential for users to get access to non-permitted functions if there is a signature collision.\n\nThis is a security risk in this specific case, but is also a more global suggestion for Sentiment. While two contracts on one Controller one time is unlikely to cause a problem, the practice of loading multiple contracts onto on Controller should be avoided, as the risks will increase as this is performed.\n\n## Code Snippet\n\nThese three functions do not exist on the same contract:\n\nhttps://github.com/sherlock-audit/2023-01-sentiment/blob/main/controller-52/src/rage/DNGMXVaultController.sol#L15-L22\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nSplit DNGMXVaultController into two files, one for each of the two contracts that will be interacted with. \n\nGoing forward, continue to uphold the practice of always having one Controller per contract, unless the two contracts are identical and non-upgradeable.\n\n## Discussion\n\n**bahurum**\n\nEscalate for 50 USDC. \nThis issue should be low/informational.\nI have flagged the issue but as Informational (https://github.com/sherlock-audit/2023-01-sentiment-judging/issues/25), since the two target contracts are non-upgradeable and new functions can never be added and signature collision is impossible.\nHere are the contracts on chain:\n[`depositPeriphery`](https://arbiscan.io/address/0x7ca90dd6813256bd040a8e13bbced857b1c0c90c#writeContract) \n[`withdrawPeriphery`](https://arbiscan.io/address/0xBA55D7f67Fa22DF5E92487d5b306DdB1aA543d10#writeContract)\nNote that they do not share any of the 3 function signatures of `DNGMXVaultController` and they never will since they are non-upradeable.\n\n**sherlock-admin**\n\n > Escalate for 50 USDC. \n> This issue should be low/informational.\n> I have flagged the issue but as Informational (https://github.com/sherlock-audit/2023-01-sentiment-judging/issues/25), since the two target contracts are non-upgradeable and new functions can never be added and signature collision is impossible.\n> Here are the contracts on chain:\n> [`depositPeriphery`](https://arbiscan.io/address/0x7ca90dd6813256bd040a8e13bbced857b1c0c90c#writeContract) \n> [`withdrawPeriphery`](https://arbiscan.io/address/0xBA55D7f67Fa22DF5E92487d5b306DdB1aA543d10#writeContract)\n> Note that they do not share any of the 3 function signatures of `DNGMXVaultController` and they never will since they are non-upradeable.\n\nYou've created a valid escalation for 50 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**zobront**\n\nBaharum's issue did not identify the signature collision as a risk for combining contracts into one Controller, and simply said that it would be confusing, which is why it was identified as Informational.\n\nThe issue here points out that the current Controller violates an explicit practice that Sentiment must be enforcing on all contracts to keep their protocol safe. Just because the collision doesn't happen in this specific case, it doesn't change the fact that Sentiment is violating a security principle that they should be upholding consistently.\n\nTo drive the point home, I do not believe Sentiment would get their contracts re-audited if they added one function to an individual Controller. So this type of issue needs to be caught NOW so that they don't set themselves up to be in a situation where adding one innocent, safe function later ends up causing a catastrophic problem. \n\n**zobront**\n\nFix confirmed.\n\n**hrishibhat**\n\nEscalation accepted. \n\nAfter further internal discussion, considering this issue as informational as there are no collision risks with current implementation and any changes to the code must undergo an audit process. \n\n**sherlock-admin**\n\n> Escalation accepted. \n> \n> After further internal discussion, considering this issue as informational as there are no collision risks with current implementation and any changes to the code must undergo an audit process. \n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/37",
  "Code": [
    {
      "filename": "controller-52/src/rage/DNGMXVaultController.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {IController} from \"../core/IController.sol\";\n\n/**\n    @title Rage Trade delta netural gmx vault controller\n*/\ncontract DNGMXVaultController is IController {\n\n    /* -------------------------------------------------------------------------- */\n    /*                             CONSTANT VARIABLES                             */\n    /* -------------------------------------------------------------------------- */\n\n    /// @notice depositToken(address,address,uint256)\n    bytes4 constant DEPOSIT = 0xfb0f97a8;\n\n    /// @notice redeemToken(address,address,uint256)\n    bytes4 constant REDEEM = 0x0d71bdc3;\n\n    /// @notice withdrawToken(address,address,uint256)\n    bytes4 constant WITHDRAW = 0x01e33667;\n\n    /// @notice rage trade delta netural jr vault\n    address[] public vault;\n\n    /* -------------------------------------------------------------------------- */\n    /*                                 CONSTRUCTOR                                */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n        @param _vault rage trade delta netural jr vault\n    */\n    constructor(address _vault) {\n        vault.push(_vault);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                              PUBLIC FUNCTIONS                              */\n    /* -------------------------------------------------------------------------- */\n\n    /// @inheritdoc IController\n    function canCall(address, bool, bytes calldata data)\n        external\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        bytes4 sig = bytes4(data);\n\n        if (sig == DEPOSIT) return canDeposit(data[4:]);\n        if (sig == REDEEM || sig == WITHDRAW) return canWithdraw(data[4:]);\n\n        return (false, new address[](0), new address[](0));\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*                             INTERNAL FUNCTIONS                             */\n    /* -------------------------------------------------------------------------- */\n\n    function canDeposit(bytes calldata data)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        (address token,,) = abi.decode(\n            data, (address, address, uint256)\n        );\n\n        address[] memory tokensOut = new address[](1);\n        tokensOut[0] = token;\n\n        return (true, vault, tokensOut);\n    }\n\n    function canWithdraw(bytes calldata data)\n        internal\n        view\n        returns (bool, address[] memory, address[] memory)\n    {\n        (address token,,) = abi.decode(\n            data, (address, address, uint256)\n        );\n\n        address[] memory tokensIn = new address[](1);\n        tokensIn[0] = token;\n\n        return (true, tokensIn, vault);\n    }\n}"
    }
  ]
}