{
  "Title": "[N-03] Shift ERC721 receiver import to `IVirtualAccount.sol` to avoid duplicating ERC721 receiver import",
  "Content": "\nShift all ERC721 and ERC1155 receiver imports to interface `IVirtualAccount.sol` to avoid duplicating ERC721 receiver import and ensure code maintainability.\n\n*There is 1 instance of this issue:*\n\nWe can see below that both VirtualAccount.sol and IVirtualAccount.sol have imported the IERC721Receiver interface. \n\nhttps://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/VirtualAccount.sol#L8C1-L12C1\n\n```solidity\nFile: src/VirtualAccount.sol\n9:  import {ERC1155Receiver} from \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol\";\n10: import {IERC1155Receiver} from \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\n11: import {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n```\n\nhttps://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/interfaces/IVirtualAccount.sol#L4\n\n```solidity\nFile: src/interfaces/IVirtualAccount.sol\n4: import {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-09-maia",
  "Code": [
    {
      "filename": "src/VirtualAccount.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC721} from \"solmate/tokens/ERC721.sol\";\n\nimport {ERC1155Receiver} from \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol\";\nimport {IERC1155Receiver} from \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\nimport {IVirtualAccount, Call, PayableCall} from \"./interfaces/IVirtualAccount.sol\";\nimport {IRootPort} from \"./interfaces/IRootPort.sol\";\n\n/// @title VirtualAccount - Contract for managing a virtual user account on the Root Chain\ncontract VirtualAccount is IVirtualAccount, ERC1155Receiver {\n    using SafeTransferLib for address;\n\n    /// @inheritdoc IVirtualAccount\n    address public immutable override userAddress;\n\n    /// @inheritdoc IVirtualAccount\n    address public immutable override localPortAddress;\n\n    /*//////////////////////////////////////////////////////////////\n                            CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Constructor for Virtual Account.\n     * @param _userAddress Address of the user account.\n     * @param _localPortAddress Address of the root port contract.\n     */\n    constructor(address _userAddress, address _localPortAddress) {\n        userAddress = _userAddress;\n        localPortAddress = _localPortAddress;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            FALLBACK FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    receive() external payable {}\n\n    /*//////////////////////////////////////////////////////////////\n                            EXTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IVirtualAccount\n    function withdrawNative(uint256 _amount) external override requiresApprovedCaller {\n        msg.sender.safeTransferETH(_amount);\n    }\n\n    /// @inheritdoc IVirtualAccount\n    function withdrawERC20(address _token, uint256 _amount) external override requiresApprovedCaller {\n        _token.safeTransfer(msg.sender, _amount);\n    }\n\n    /// @inheritdoc IVirtualAccount\n    function withdrawERC721(address _token, uint256 _tokenId) external override requiresApprovedCaller {\n        ERC721(_token).transferFrom(address(this), msg.sender, _tokenId);\n    }\n\n    /// @inheritdoc IVirtualAccount\n    function call(Call[] calldata calls) external override requiresApprovedCaller returns (bytes[] memory returnData) {\n        uint256 length = calls.length;\n        returnData = new bytes[](length);\n\n        for (uint256 i = 0; i < length;) {\n            bool success;\n            Call calldata _call = calls[i];\n\n            if (isContract(_call.target)) (success, returnData[i]) = _call.target.call(_call.callData);\n\n            if (!success) revert CallFailed();\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @inheritdoc IVirtualAccount\n    function payableCall(PayableCall[] calldata calls) public payable returns (bytes[] memory returnData) {\n        uint256 valAccumulator;\n        uint256 length = calls.length;\n        returnData = new bytes[](length);\n        PayableCall calldata _call;\n        for (uint256 i = 0; i < length;) {\n            _call = calls[i];\n            uint256 val = _call.value;\n            // Humanity will be a Type V Kardashev Civilization before this overflows - andreas\n            // ~ 10^25 Wei in existence << ~ 10^76 size uint fits in a uint256\n            unchecked {\n                valAccumulator += val;\n            }\n\n            bool success;\n\n            if (isContract(_call.target)) (success, returnData[i]) = _call.target.call{value: val}(_call.callData);\n\n            if (!success) revert CallFailed();\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Finally, make sure the msg.value = SUM(call[0...i].value)\n        if (msg.value != valAccumulator) revert CallFailed();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            EXTERNAL HOOKS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC721Receiver\n    function onERC721Received(address, address, uint256, bytes calldata) external pure override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    /// @inheritdoc IERC1155Receiver\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata)\n        external\n        pure\n        override\n        returns (bytes4)\n    {\n        return this.onERC1155Received.selector;\n    }\n\n    /// @inheritdoc IERC1155Receiver\n    function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata)\n        external\n        pure\n        override\n        returns (bytes4)\n    {\n        return this.onERC1155BatchReceived.selector;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            INTERNAL HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    function isContract(address addr) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(addr)\n        }\n        return size > 0;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                                MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Modifier that verifies msg sender is the approved to use the virtual account. Either the owner or an approved router.\n    modifier requiresApprovedCaller() {\n        if (!IRootPort(localPortAddress).isRouterApproved(this, msg.sender)) {\n            if (msg.sender != userAddress) {\n                revert UnauthorizedCaller();\n            }\n        }\n        _;\n    }\n}"
    },
    {
      "filename": "src/interfaces/IVirtualAccount.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\n/// @notice Call structure based off `Multicall2` contract for aggregating calls.\nstruct Call {\n    address target;\n    bytes callData;\n}\n\n/// @notice Payable call structure based off `Multicall3` contract for aggreagating calls with `msg.value`.\nstruct PayableCall {\n    address target;\n    bytes callData;\n    uint256 value;\n}\n\n/**\n * @title  Virtual Account Contract\n * @author MaiaDAO\n * @notice A Virtual Account allows users to manage assets and perform interactions remotely while\n *         allowing dApps to keep encapsulated user balance for accounting purposes.\n * @dev    This contract is based off `Multicall2` and `Multicall3` contract, executes a set of `Call` or `PayableCall`\n *         objects if any of the performed calls is invalid the whole batch should revert.\n */\ninterface IVirtualAccount is IERC721Receiver {\n    /**\n     * @notice Returns the address of the user that owns the VirtualAccount.\n     * @return The address of the user that owns the VirtualAccount.\n     */\n    function userAddress() external view returns (address);\n\n    /**\n     * @notice Returns the address of the local port.\n     * @return The address of the local port.\n     */\n    function localPortAddress() external view returns (address);\n\n    /**\n     * @notice Withdraws native tokens from the VirtualAccount.\n     * @param _amount The amount of tokens to withdraw.\n     */\n    function withdrawNative(uint256 _amount) external;\n\n    /**\n     * @notice Withdraws ERC20 tokens from the VirtualAccount.\n     * @param _token The address of the ERC20 token to withdraw.\n     * @param _amount The amount of tokens to withdraw.\n     */\n    function withdrawERC20(address _token, uint256 _amount) external;\n\n    /**\n     * @notice Withdraws ERC721 tokens from the VirtualAccount.\n     * @param _token The address of the ERC721 token to withdraw.\n     * @param _tokenId The id of the token to withdraw.\n     */\n    function withdrawERC721(address _token, uint256 _tokenId) external;\n\n    /**\n     * @notice Aggregate calls ensuring each call is successful. Inspired by `Multicall2` contract.\n     * @param callInput The call to make.\n     * @return The return data of the call.\n     */\n    function call(Call[] calldata callInput) external returns (bytes[] memory);\n\n    /**\n     * @notice Aggregate calls with a msg value ensuring each call is successful. Inspired by `Multicall3` contract.\n     * @param calls The calls to make.\n     * @return The return data of the calls.\n     * @dev Reverts if msg.value is less than the sum of the call values.\n     */\n    function payableCall(PayableCall[] calldata calls) external payable returns (bytes[] memory);\n\n    /*///////////////////////////////////////////////////////////////\n                                ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    error CallFailed();\n\n    error UnauthorizedCaller();\n}"
    }
  ]
}