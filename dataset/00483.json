{
  "Title": "M-10: Slashing penalty is unfairly paid by a subset of users if a deficit is accumulated.",
  "Content": "# Issue M-10: Slashing penalty is unfairly paid by a subset of users if a deficit is accumulated. \n\nSource: https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/363 \n\nThe protocol has acknowledged this issue.\n\n## Found by \nmonrel\n## Summary\n\nIf a deficit is accumulated in the EigenPodManager due to slashing when ETH is being withdrawn the slashing payment will be taken from the first cohort to complete a withdrawal.\n\n## Vulnerability Detail\n\nA deficit can happen in `podOwnerShares[podOwner]` in the EigenPodManager in the EigenLayer protocol. This can happen if validators are slashed when ETH is queued for withdrawal.\n\nThe issue is that this deficit will be paid for by the next cohort to complete a withdrawal by calling `settleEpochFromEigenLayer()`.\n\nIn the following code we can see how `epochWithdrawals.assetsReceived` is calculated based on the amount received from the `delegationManager.completeQueuedWithdrawal` call\n\nhttps://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/4f01e065c1ed346875cf5b05d2b43e0bcdb4c849/rio-sherlock-audit/contracts/restaking/RioLRTWithdrawalQueue.sol#L242-L268\n\n```solidity\n        uint256 balanceBefore = asset.getSelfBalance();\n\n        address[] memory assets = asset.toArray();\n        bytes32[] memory roots = new bytes32[](queuedWithdrawalCount);\n\n        IDelegationManager.Withdrawal memory queuedWithdrawal;\n        for (uint256 i; i < queuedWithdrawalCount; ++i) {\n            queuedWithdrawal = queuedWithdrawals[i];\n\n            roots[i] = _computeWithdrawalRoot(queuedWithdrawal);\n            delegationManager.completeQueuedWithdrawal(queuedWithdrawal, assets, middlewareTimesIndexes[i], true);\n\n            // Decrease the amount of ETH queued for withdrawal. We do not need to validate the staker as\n            // the aggregate root will be validated below.\n            if (asset == ETH_ADDRESS) {\n                IRioLRTOperatorDelegator(queuedWithdrawal.staker).decreaseETHQueuedForUserSettlement(\n                    queuedWithdrawal.shares[0]\n                );\n            }\n        }\n        if (epochWithdrawals.aggregateRoot != keccak256(abi.encode(roots))) {\n            revert INVALID_AGGREGATE_WITHDRAWAL_ROOT();\n        }\n        epochWithdrawals.shareValueOfAssetsReceived = SafeCast.toUint120(epochWithdrawals.sharesOwed);\n\n        uint256 assetsReceived = asset.getSelfBalance() - balanceBefore;\n        epochWithdrawals.assetsReceived += SafeCast.toUint120(assetsReceived);\n```\n\nthe amount received could be 0 if the deficit is larger than the amount queued for this cohort. See following code in `withdrawSharesAsTokens()` EigenPodManager\n\nhttps://github.com/Layr-Labs/eigenlayer-contracts/blob/e12b03f20f7dceded8de9c6901ab05cfe61a2113/src/contracts/pods/EigenPodManager.sol#L216C1-L220C14\n\n```solidity\n            } else {\n                podOwnerShares[podOwner] += int256(shares);\n                emit PodSharesUpdated(podOwner, int256(shares));\n                return;\n            }\n```\n\nThese users will pay for all slashing penalties instead of it being spread out among all LRT holders.\n\n## Impact\n\nIf a deficit is accumulated the first cohort to settle will pay for the entire amount. If they can not cover it fully, they will receive 0 and the following cohort will pay for the rest.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-02-rio-network-core-protocol/blob/4f01e065c1ed346875cf5b05d2b43e0bcdb4c849/rio-sherlock-audit/contracts/restaking/RioLRTWithdrawalQueue.sol#L242-L268\n\n## Tool used\n\nManual Review\n## Recommendation\n\nA potential solution to deal with this is to check if a deficit exists in `settleEpochFromEigenLayer()`. If it exists functionality has to be added that spreads the cost of the penalty fairly among all LRT holders.\n\n\n\n## Discussion\n\n**nevillehuang**\n\nrequest poc\n\n**sherlock-admin3**\n\nPoC requested from @0xmonrel\n\nRequests remaining: **16**\n\n**0xmonrel**\n\n\nFor this POC to run we need to first fix the epoch increment issue. Done by adding `currentEpochsByAsset[asset] += 1;` to queueCurrentEpcohSettlement().\n\n### POC\n\nThis shows that users in the first withdrawal pay for 100% of the penalty if we have a deficit due to slashing\n\nCourse of events\n1. Deposit such that we have 2 validators\n2. Request withdrawal 8 ETH and rebalance for epoch 0\n3. Request withdrawal 31.99 ETH and rebalance for epoch 1\n4. Slashing during withdrawal period such that we have a -8 ETH deficit in the EigenpodManager\n5. VerifyAndProcess both withdrawals\n6. Settle and claim epoch 0, we get 0 ETH since penalty is paid for 100% by these users.\n7. Settle and claim epoch 1, we get 31.99 ETH since 0% of penalty is paid for. \n8. Users in epoch 1 has stolen 4 ETH from users in epoch 0.\n\nCreate a new file `RioLRTDeficit.t.sol` in the `test` folder and paste the code below. Run with `forge test --match-test test_deficitPenaltyTrue -vvv`\n\n```solidity\n// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.23;\n\nimport {BEACON_CHAIN_STRATEGY, ETH_ADDRESS, ETH_DEPOSIT_SIZE, GWEI_TO_WEI} from 'contracts/utils/Constants.sol';\nimport {IDelegationManager} from 'contracts/interfaces/eigenlayer/IDelegationManager.sol';\nimport {IRioLRTWithdrawalQueue} from 'contracts/interfaces/IRioLRTWithdrawalQueue.sol';\nimport {RioDeployer} from 'test/utils/RioDeployer.sol';\nimport {Asset} from 'contracts/utils/Asset.sol';\nimport {Array} from 'contracts/utils/Array.sol';\n\nimport {IRioLRTOperatorRegistry} from 'contracts/interfaces/IRioLRTOperatorRegistry.sol';\nimport {RioLRTOperatorDelegator} from 'contracts/restaking/RioLRTOperatorDelegator.sol';\nimport {CredentialsProofs, BeaconWithdrawal} from 'test/utils/beacon-chain/MockBeaconChain.sol';\nimport \"forge-std/console2.sol\";\nimport {IEigenPodManager} from 'contracts/interfaces/eigenlayer/IEigenPodManager.sol';\nimport {stdStorage, StdStorage} from \"forge-std/Test.sol\";\n\ncontract RioLRTDeficit is RioDeployer {\n    using stdStorage for StdStorage; \n    using Asset for *;\n    using Array for *;\n\n    TestLRTDeployment public reETH;\n    TestLRTDeployment public reLST;\n\n    IRioLRTOperatorRegistry.StrategyShareCap[] public emptyStrategyShareCaps; \n    function setUp() public {\n        deployRio(); \n\n        (reETH,) = issueRestakedETH(); \n        (reLST,) = issueRestakedLST();\n    }\n\n\n    function test_deficitPenaltyTrue() public{\n        uint8[] memory operatorIds = addOperatorDelegators( //add 2 validators to 1 operator\n        reETH.operatorRegistry,\n        address(reETH.rewardDistributor),\n        1,\n        emptyStrategyShareCaps,\n        2\n        );\n        \n        uint256 depositAmount = 2*ETH_DEPOSIT_SIZE - address(reETH.depositPool).balance;  \n        reETH.coordinator.depositETH{value: depositAmount}(); \n\n\n        vm.prank(EOA, EOA);\n        reETH.coordinator.rebalance(ETH_ADDRESS); // Rebalance to stake 2 validators\n        uint40[] memory validatorIndices = verifyCredentialsForValidators(reETH.operatorRegistry, 1, 2);\n        \n        address delegator = reETH.operatorRegistry.getOperatorDetails(operatorIds[0]).delegator;\n        \n        int256 shares = RioLRTOperatorDelegator(payable(delegator)).getEigenPodShares();         \n\n        console2.log(\"Total shares after deposit:\",shares);\n        require(shares == 64 ether);\n\n       \n       //----- First withdrawal\n\n        uint256 withdrawalAmount = 8 ether;\n        reETH.coordinator.requestWithdrawal(ETH_ADDRESS, withdrawalAmount);\n        \n        uint256 firstEpoch = reETH.withdrawalQueue.getCurrentEpoch(ETH_ADDRESS);\n        \n        skip(reETH.coordinator.rebalanceDelay());\n\n        vm.prank(EOA, EOA);\n        reETH.coordinator.rebalance(ETH_ADDRESS);\n\n        //----- Second Withdrawal\n\n        uint256 withdrawalAmount2 = 31.99 ether;\n        reETH.coordinator.requestWithdrawal(ETH_ADDRESS, withdrawalAmount2);\n\n        uint256 secondEpoch = reETH.withdrawalQueue.getCurrentEpoch(ETH_ADDRESS);\n\n        skip(reETH.coordinator.rebalanceDelay());\n\n        vm.prank(EOA, EOA);\n        reETH.coordinator.rebalance(ETH_ADDRESS);\n        \n        // ------ SIMULATE SLASHING \n        // EigenLayer accounts for slashing during withdrawl period by decreasing shares. \n        // if shares < 0, these shares will be adjusted for in the next withdrawal.\n\n        /** We simulate slashing by directly setting the podownerShars[delegator] = slashedAmount\n            this is equivalent to calling recordBeaconChainETHBalanceUpdate to decrease the balance\n            due to slashing.\n         */\n\n        IEigenPodManager manager = IEigenPodManager(EIGEN_POD_MANAGER_ADDRESS);\n\n        stdstore.target(EIGEN_POD_MANAGER_ADDRESS).sig(\"podOwnerShares(address)\").with_key(delegator).checked_write_int(int256(-8 ether));\n\n        int256 loadInt = stdstore.target(EIGEN_POD_MANAGER_ADDRESS).sig(\"podOwnerShares(address)\").with_key(delegator).read_int();\n        console2.log(\"Slashing 8 Ether during withdrawal process, deficit in shares:\", loadInt);\n        \n        // verify both\n\n        verifyAndProcessWithdrawalsForValidatorIndexes(delegator, validatorIndices);\n\n        // First withdrawal will pay for entire slashing amount\n\n    {\n        IDelegationManager.Withdrawal[] memory withdrawals = new IDelegationManager.Withdrawal[](1);\n        withdrawals[0] = IDelegationManager.Withdrawal({\n            staker: delegator,\n            delegatedTo: address(1),\n            withdrawer: address(reETH.withdrawalQueue),\n            nonce: 0,\n            startBlock: 1,\n            strategies: BEACON_CHAIN_STRATEGY.toArray(),\n            shares: withdrawalAmount.toArray()\n        });\n        reETH.withdrawalQueue.settleEpochFromEigenLayer(ETH_ADDRESS, 0, withdrawals, new uint256[](1));\n\n\n        uint256 amountOut = reETH.withdrawalQueue.claimWithdrawalsForEpoch(\n            IRioLRTWithdrawalQueue.ClaimRequest({asset: ETH_ADDRESS, epoch: 0})\n        );\n        \n        console2.log(\"First Withdrawal:\", amountOut); // Users in this cohort pay for 100% of slashing\n    }\n\n\n        IDelegationManager.Withdrawal[] memory withdrawals2 = new IDelegationManager.Withdrawal[](1);\n        withdrawals2[0] = IDelegationManager.Withdrawal({\n            staker: delegator,\n            delegatedTo: address(1),\n            withdrawer: address(reETH.withdrawalQueue),\n            nonce: 1,\n            startBlock: 1,\n            strategies: BEACON_CHAIN_STRATEGY.toArray(),\n            shares: withdrawalAmount2.toArray()\n        });\n        reETH.withdrawalQueue.settleEpochFromEigenLayer(ETH_ADDRESS, 1, withdrawals2, new uint256[](1));\n\n        uint256 amountOut2 = reETH.withdrawalQueue.claimWithdrawalsForEpoch(\n            IRioLRTWithdrawalQueue.ClaimRequest({asset: ETH_ADDRESS, epoch: 1})\n        );\n        \n        console2.log(\"Second Withdrawal:\", amountOut2); // Users in this cohort pay 0% of slashing\n        console2.log(\"Users in first withdrawal paid for 100% of penalty\");\n        \n    }    \n    receive() external payable {}\n}\n\n```\n\n### Results\n\n```javascript\nLogs:\n  Total shares after deposit: 64000000000000000000\n  Slashing 8 Ether during withdrawal process, deficit in shares: -8000000000000000000\n  First Withdrawal: 0\n  Second Withdrawal: 31990000000000000000\n  Users in first withdrawal paid for 100% of penalty\n```\n\n\n\n**nevillehuang**\n\n@solimander Might want to consider the above PoC\n\n**solimander**\n\nReviewing\n\n**KupiaSecAdmin**\n\nEscalate\n\nThis has to be considered as Invalid/Low basically because EigenLayer's Slashing contracts do not have any features and all paused, it also won't have any features in its upgrades as well, which means no slashing exists.\n\n**sherlock-admin2**\n\n> Escalate\n> \n> This has to be considered as Invalid/Low basically because EigenLayer's Slashing contracts do not have any features and all paused, it also won't have any features in its upgrades as well, which means no slashing exists.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**0xmonrel**\n\nYou are misunderstanding the issue. This is about consensus layer slashing.\n\n**nevillehuang**\n\n@KupiaSecAdmin Could you link resources/proof to your argument so I can review?\n\n**KupiaSecAdmin**\n\n@nevillehuang - https://hackmd.io/@-HV50kYcRqOjl_7du8m1AA/BkOyFwc2T#Out-of-Scope\nHere's the docs about upgrades of EigenLayer, which Rio is targeting, hope it helps.\n\n@0xmonrel - If you were meant to say about Ethereum's PoS slashing, as I described [here](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/190), it should be considered as Low.\n\n**0xmonrel**\n\nThe arguments does not apply here. The effect on TVL are irrelevant what matters in this issue is that only 1 cohort of users will pay for the slashing if a deficit happens.\n\n\n**nevillehuang**\n\n@solimander Based on targeted eigen layer contracts it seems it is correct that slashing is currently not applicable to Rio. It is also not stated in the contest details that this will be integrated to rio, so I believe this is invalid based on the following sherlock guideline:\n\n> Future issues: Issues that result out of a future integration/implementation that was not mentioned in the docs/README or because of a future change in the code (as a fix to another issue) are not valid issues.\n\n**0xmonrel**\n\nPOS slashing is already live and integrated. Slashing from re-staking is not so it is not out of scope. \n\n**nevillehuang**\n\n@0xmonrel Could you point me to the correct resource. This will affect validity of #190 as well\n\n**0xmonrel**\n\nSlashing  is implemented natively through the balance update process. When a validator is slashed the balance is decreased, this is then pushed to EigenLayer through `verifyBalanceUpdates()`.  \n\nHere is the logic where slashing is accounted for and a deficit can happen:\n\nhttps://github.com/Layr-Labs/eigenlayer-contracts/blob/e12b03f20f7dceded8de9c6901ab05cfe61a2113/src/contracts/pods/EigenPodManager.sol#L207-L219\n\nLook here at the `verifyBalanceUpdates()`\n\nhttps://github.com/Layr-Labs/eigenlayer-contracts/blob/b6a3a91e1c0c126981de409b00b5fba178503447/src/contracts/pods/EigenPod.sol#L175-L221\n\nRead the comment for a description of what happens when a balance is decreased. \n\n@solimander can most likely verify that this is correct as he has deep understanding of EigenLayer.\n\n**solimander**\n\nThat's right, you can find more info on the deficit edge case in the [EigenLayer discord](https://discord.com/channels/1089434273720832071/1187171025478230168/1210639477601603660): \n\n**nevillehuang**\n\nThanks alot guys, I believe this issue is correctly judged given the constraint of a deficit edge case.\n\n**Czar102**\n\nI'm planning to reject the escalation and leave the issue as is, unless @KupiaSecAdmin or anyone else has a valid argument not to.\n\n**Czar102**\n\nResult:\nMedium\nUnique\n\n**sherlock-admin3**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [KupiaSecAdmin](https://github.com/sherlock-audit/2024-02-rio-network-core-protocol-judging/issues/363/#issuecomment-2023014162): rejected\n\n**solimander**\n\nThis is definitely an edge case of an edge case. First, slashing needs to occur while the withdrawal is queued. Second, the operator delegator's pod owner shares needs to be low enough that a deficit is possible. For this reason, considering leaving as-is for now and handling this out-of-protocol.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/176",
  "Code": [
    {
      "filename": "rio-sherlock-audit/contracts/restaking/RioLRTWithdrawalQueue.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.23;\n\nimport {UUPSUpgradeable} from '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\nimport {OwnableUpgradeable} from '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport {IRioLRTOperatorDelegator} from 'contracts/interfaces/IRioLRTOperatorDelegator.sol';\nimport {IDelegationManager} from 'contracts/interfaces/eigenlayer/IDelegationManager.sol';\nimport {IRioLRTWithdrawalQueue} from 'contracts/interfaces/IRioLRTWithdrawalQueue.sol';\nimport {SafeCast} from '@openzeppelin/contracts/utils/math/SafeCast.sol';\nimport {FixedPointMathLib} from '@solady/utils/FixedPointMathLib.sol';\nimport {RioLRTCore} from 'contracts/restaking/base/RioLRTCore.sol';\nimport {ETH_ADDRESS} from 'contracts/utils/Constants.sol';\nimport {Array} from 'contracts/utils/Array.sol';\nimport {Asset} from 'contracts/utils/Asset.sol';\n\ncontract RioLRTWithdrawalQueue is IRioLRTWithdrawalQueue, OwnableUpgradeable, UUPSUpgradeable, RioLRTCore {\n    using FixedPointMathLib for *;\n    using Asset for address;\n    using Array for *;\n\n    /// @notice The primary delegation contract for EigenLayer.\n    IDelegationManager public immutable delegationManager;\n\n    /// @notice Current asset withdrawal epochs. Incoming withdrawals are included\n    /// in the current epoch, which will be processed by the asset manager.\n    mapping(address asset => uint256 epoch) internal currentEpochsByAsset;\n\n    /// @notice The amount of assets owed to users in a given epoch, as well as the state\n    /// of the epoch's withdrawals.\n    mapping(address asset => mapping(uint256 epoch => EpochWithdrawals withdrawals)) internal epochWithdrawalsByAsset;\n\n    /// @param issuer_ The LRT issuer that's authorized to deploy this contract.\n    /// @param delegationManager_ The EigenLayer delegation manager.\n    constructor(address issuer_, address delegationManager_) RioLRTCore(issuer_) {\n        delegationManager = IDelegationManager(delegationManager_);\n    }\n\n    /// @notice Initializes the contract.\n    /// @param initialOwner The initial owner of the contract.\n    /// @param token_ The address of the liquid restaking token.\n    function initialize(address initialOwner, address token_) external initializer {\n        __Ownable_init(initialOwner);\n        __UUPSUpgradeable_init();\n        __RioLRTCore_init(token_);\n    }\n\n    /// @notice Retrieve the current withdrawal epoch for a given asset.\n    /// @param asset The asset to retrieve the current epoch for.\n    function getCurrentEpoch(address asset) public view returns (uint256) {\n        return currentEpochsByAsset[asset];\n    }\n\n    /// @notice Get the amount of strategy shares owed to withdrawers in the current `epoch` for `asset`.\n    /// @param asset The withdrawal asset.\n    function getSharesOwedInCurrentEpoch(address asset) external view returns (uint256 sharesOwed) {\n        sharesOwed = _getEpochWithdrawals(asset, getCurrentEpoch(asset)).sharesOwed;\n    }\n\n    /// @notice Retrieve withdrawal epoch information for a given asset and epoch.\n    /// @param asset The withdrawal asset.\n    /// @param epoch The epoch for which to retrieve the information.\n    function getEpochWithdrawalSummary(address asset, uint256 epoch)\n        external\n        view\n        returns (EpochWithdrawalSummary memory)\n    {\n        EpochWithdrawals storage withdrawals = _getEpochWithdrawals(asset, epoch);\n        return EpochWithdrawalSummary({\n            settled: withdrawals.settled,\n            assetsReceived: withdrawals.assetsReceived,\n            shareValueOfAssetsReceived: withdrawals.shareValueOfAssetsReceived,\n            sharesOwed: withdrawals.sharesOwed,\n            amountToBurnAtSettlement: withdrawals.amountToBurnAtSettlement,\n            aggregateRoot: withdrawals.aggregateRoot\n        });\n    }\n\n    /// @notice Retrieve a user's withdrawal information for a given asset and epoch.\n    /// @param asset The withdrawal asset.\n    /// @param epoch The epoch for which to retrieve the information.\n    /// @param user The address of the user for which to retrieve the information.\n    function getUserWithdrawalSummary(address asset, uint256 epoch, address user)\n        external\n        view\n        returns (UserWithdrawalSummary memory)\n    {\n        return _getEpochWithdrawals(asset, epoch).users[user];\n    }\n\n    /// @notice Withdraws all `asset` owed to the caller in a given epoch.\n    /// @param request The asset claim request.\n    function claimWithdrawalsForEpoch(ClaimRequest calldata request) public returns (uint256 amountOut) {\n        address withdrawer = msg.sender;\n\n        EpochWithdrawals storage epochWithdrawals = _getEpochWithdrawals(request.asset, request.epoch);\n        if (!epochWithdrawals.settled) revert EPOCH_NOT_SETTLED();\n\n        UserWithdrawalSummary memory userSummary = epochWithdrawals.users[withdrawer];\n        if (userSummary.sharesOwed == 0) revert NO_SHARES_OWED_IN_EPOCH();\n        if (userSummary.claimed) revert WITHDRAWAL_ALREADY_CLAIMED();\n\n        epochWithdrawals.users[withdrawer].claimed = true;\n\n        amountOut = userSummary.sharesOwed.mulDiv(epochWithdrawals.assetsReceived, epochWithdrawals.sharesOwed);\n        request.asset.transferTo(withdrawer, amountOut);\n\n        emit WithdrawalsClaimedForEpoch(request.epoch, request.asset, withdrawer, amountOut);\n    }\n\n    /// @notice Withdraws owed assets owed to the caller from many withdrawal requests.\n    /// @param requests The withdrawal claim request.\n    function claimWithdrawalsForManyEpochs(ClaimRequest[] calldata requests)\n        external\n        returns (uint256[] memory amountsOut)\n    {\n        uint256 requestLength = requests.length;\n\n        amountsOut = new uint256[](requestLength);\n        for (uint256 i; i < requestLength; ++i) {\n            amountsOut[i] = claimWithdrawalsForEpoch(requests[i]);\n        }\n    }\n\n    /// @notice Queue `sharesOwed` of `asset` to `withdrawer` in the current epoch. These owed shares\n    /// can be claimed as the underlying asset by the withdrawer once the current epoch is settled.\n    /// @param withdrawer The address requesting the withdrawal.\n    /// @param asset The address of the asset being withdrawn.\n    /// @param sharesOwed The amount of shares owed to the withdrawer.\n    /// @param amountIn The amount of restaking tokens pulled from the withdrawer.\n    function queueWithdrawal(address withdrawer, address asset, uint256 sharesOwed, uint256 amountIn)\n        external\n        onlyCoordinator\n    {\n        if (sharesOwed == 0) revert NO_SHARES_OWED();\n        uint256 currentEpoch = getCurrentEpoch(asset);\n\n        EpochWithdrawals storage epochWithdrawals = _getEpochWithdrawals(asset, currentEpoch);\n        epochWithdrawals.sharesOwed += SafeCast.toUint120(sharesOwed);\n        epochWithdrawals.amountToBurnAtSettlement += amountIn;\n\n        UserWithdrawalSummary storage userSummary = epochWithdrawals.users[withdrawer];\n        userSummary.sharesOwed += SafeCast.toUint120(sharesOwed);\n\n        emit WithdrawalQueued(currentEpoch, asset, withdrawer, sharesOwed, amountIn);\n    }\n\n    /// @notice Settle the current epoch for `asset` using `assetsReceived` from the deposit pool.\n    /// @param asset The address of the withdrawal asset.\n    /// @param assetsReceived The amount of assets received to settle the epoch.\n    /// @param shareValueOfAssetsReceived The value of the assets received in EigenLayer shares.\n    function settleCurrentEpoch(address asset, uint256 assetsReceived, uint256 shareValueOfAssetsReceived)\n        external\n        onlyCoordinator\n    {\n        uint256 currentEpoch = getCurrentEpoch(asset);\n\n        EpochWithdrawals storage epochWithdrawals = _getEpochWithdrawals(asset, currentEpoch);\n        if (epochWithdrawals.sharesOwed == 0) revert NO_SHARES_OWED_IN_EPOCH();\n        if (epochWithdrawals.settled) revert EPOCH_ALREADY_SETTLED();\n\n        epochWithdrawals.settled = true;\n        epochWithdrawals.assetsReceived = SafeCast.toUint120(assetsReceived);\n        epochWithdrawals.shareValueOfAssetsReceived = SafeCast.toUint120(shareValueOfAssetsReceived);\n\n        token.burn(epochWithdrawals.amountToBurnAtSettlement);\n        currentEpochsByAsset[asset] += 1;\n\n        emit EpochSettledFromDepositPool(currentEpoch, asset, assetsReceived);\n    }\n\n    /// @notice Queues the current epoch for `asset` settlement via EigenLayer and record\n    /// the amount of assets received from the deposit pool.\n    /// @param asset The address of the withdrawal asset.\n    /// @param assetsReceived The amount of assets received from the deposit pool.\n    /// @param shareValueOfAssetsReceived The value of the assets received in EigenLayer shares.\n    /// @param aggregateRoot The aggregate root of the queued EigenLayer withdrawals.\n    function queueCurrentEpochSettlement(\n        address asset,\n        uint256 assetsReceived,\n        uint256 shareValueOfAssetsReceived,\n        bytes32 aggregateRoot\n    ) external onlyCoordinator {\n        if (aggregateRoot == bytes32(0)) revert INVALID_AGGREGATE_WITHDRAWAL_ROOT();\n\n        uint256 currentEpoch = getCurrentEpoch(asset);\n\n        EpochWithdrawals storage epochWithdrawals = _getEpochWithdrawals(asset, currentEpoch);\n        if (epochWithdrawals.aggregateRoot != bytes32(0)) revert WITHDRAWALS_ALREADY_QUEUED_FOR_EPOCH();\n        if (epochWithdrawals.sharesOwed == 0) revert NO_SHARES_OWED_IN_EPOCH();\n        if (epochWithdrawals.settled) revert EPOCH_ALREADY_SETTLED();\n\n        uint256 restakingTokensToBurn;\n        if (assetsReceived > 0) {\n            epochWithdrawals.assetsReceived = SafeCast.toUint120(assetsReceived);\n            epochWithdrawals.shareValueOfAssetsReceived = SafeCast.toUint120(shareValueOfAssetsReceived);\n\n            restakingTokensToBurn = epochWithdrawals.amountToBurnAtSettlement.mulWad(\n                shareValueOfAssetsReceived.divWad(epochWithdrawals.sharesOwed)\n            );\n            token.burn(restakingTokensToBurn);\n\n            epochWithdrawals.amountToBurnAtSettlement -= restakingTokensToBurn;\n        }\n        epochWithdrawals.aggregateRoot = aggregateRoot;\n\n        emit EpochQueuedForSettlementFromEigenLayer(\n            currentEpoch, asset, assetsReceived, shareValueOfAssetsReceived, restakingTokensToBurn, aggregateRoot\n        );\n    }\n\n    /// @notice Settle `epoch` for `asset` using `queuedWithdrawals` from EigenLayer.\n    /// @param asset The address of the withdrawal asset.\n    /// @param epoch The epoch to settle.\n    /// @param queuedWithdrawals The queued withdrawals from EigenLayer.\n    /// @param middlewareTimesIndexes The middleware times indexes for the queued withdrawals.\n    function settleEpochFromEigenLayer(\n        address asset,\n        uint256 epoch,\n        IDelegationManager.Withdrawal[] calldata queuedWithdrawals,\n        uint256[] calldata middlewareTimesIndexes\n    ) external {\n        EpochWithdrawals storage epochWithdrawals = _getEpochWithdrawals(asset, epoch);\n        if (epochWithdrawals.sharesOwed == 0) revert NO_SHARES_OWED_IN_EPOCH();\n        if (epochWithdrawals.settled) revert EPOCH_ALREADY_SETTLED();\n        if (epochWithdrawals.aggregateRoot == bytes32(0)) revert WITHDRAWALS_NOT_QUEUED_FOR_EPOCH();\n\n        uint256 queuedWithdrawalCount = queuedWithdrawals.length;\n        if (queuedWithdrawalCount != middlewareTimesIndexes.length) revert INVALID_MIDDLEWARE_TIMES_INDEXES_LENGTH();\n\n        epochWithdrawals.settled = true;\n\n        // forgefmt: disable-next-item\n        uint256 sharesReceivedDuringSettlement = epochWithdrawals.sharesOwed - epochWithdrawals.shareValueOfAssetsReceived;\n\n        // If not ETH, decrease the shares held for the asset. The decrease in queued ETH is\n        // handled on a per-operator basis below.\n        if (asset != ETH_ADDRESS) {\n            assetRegistry().decreaseSharesHeldForAsset(asset, sharesReceivedDuringSettlement);\n        }\n        token.burn(epochWithdrawals.amountToBurnAtSettlement);\n\n        uint256 balanceBefore = asset.getSelfBalance();\n\n        address[] memory assets = asset.toArray();\n        bytes32[] memory roots = new bytes32[](queuedWithdrawalCount);\n\n        IDelegationManager.Withdrawal memory queuedWithdrawal;\n        for (uint256 i; i < queuedWithdrawalCount; ++i) {\n            queuedWithdrawal = queuedWithdrawals[i];\n\n            roots[i] = _computeWithdrawalRoot(queuedWithdrawal);\n            delegationManager.completeQueuedWithdrawal(queuedWithdrawal, assets, middlewareTimesIndexes[i], true);\n\n            // Decrease the amount of ETH queued for withdrawal. We do not need to validate the staker as\n            // the aggregate root will be validated below.\n            if (asset == ETH_ADDRESS) {\n                IRioLRTOperatorDelegator(queuedWithdrawal.staker).decreaseETHQueuedForUserSettlement(\n                    queuedWithdrawal.shares[0]\n                );\n            }\n        }\n        if (epochWithdrawals.aggregateRoot != keccak256(abi.encode(roots))) {\n            revert INVALID_AGGREGATE_WITHDRAWAL_ROOT();\n        }\n        epochWithdrawals.shareValueOfAssetsReceived = SafeCast.toUint120(epochWithdrawals.sharesOwed);\n\n        uint256 assetsReceived = asset.getSelfBalance() - balanceBefore;\n        epochWithdrawals.assetsReceived += SafeCast.toUint120(assetsReceived);\n\n        emit EpochSettledFromEigenLayer(epoch, asset, assetsReceived);\n    }\n\n    /// @dev Receives ETH for withdrawals.\n    receive() external payable {}\n\n    /// @dev Returns the keccak256 hash of `withdrawal`.\n    /// @param withdrawal The withdrawal.\n    function _computeWithdrawalRoot(IDelegationManager.Withdrawal memory withdrawal) public pure returns (bytes32) {\n        return keccak256(abi.encode(withdrawal));\n    }\n\n    function _getEpochWithdrawals(address asset, uint256 epoch) internal view returns (EpochWithdrawals storage) {\n        return epochWithdrawalsByAsset[asset][epoch];\n    }\n\n    /// @dev Allows the owner to upgrade the withdrawal queue implementation.\n    /// @param newImplementation The implementation to upgrade to.\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n}"
    },
    {
      "filename": "src/contracts/pods/EigenPodManager.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.12;\n\nimport \"@openzeppelin/contracts/utils/Create2.sol\";\nimport \"@openzeppelin-upgrades/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin-upgrades/contracts/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin-upgrades/contracts/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"../interfaces/IBeaconChainOracle.sol\";\n\nimport \"../permissions/Pausable.sol\";\nimport \"./EigenPodPausingConstants.sol\";\nimport \"./EigenPodManagerStorage.sol\";\n\n/**\n * @title The contract used for creating and managing EigenPods\n * @author Layr Labs, Inc.\n * @notice Terms of Service: https://docs.eigenlayer.xyz/overview/terms-of-service\n * @notice The main functionalities are:\n * - creating EigenPods\n * - staking for new validators on EigenPods\n * - keeping track of the restaked balances of all EigenPod owners\n * - withdrawing eth when withdrawals are completed\n */\ncontract EigenPodManager is\n    Initializable,\n    OwnableUpgradeable,\n    Pausable,\n    EigenPodPausingConstants,\n    EigenPodManagerStorage,\n    ReentrancyGuardUpgradeable\n{\n    \n    modifier onlyEigenPod(address podOwner) {\n        require(address(ownerToPod[podOwner]) == msg.sender, \"EigenPodManager.onlyEigenPod: not a pod\");\n        _;\n    }\n\n    modifier onlyDelegationManager() {\n        require(\n            msg.sender == address(delegationManager),\n            \"EigenPodManager.onlyDelegationManager: not the DelegationManager\"\n        );\n        _;\n    }\n\n    constructor(\n        IETHPOSDeposit _ethPOS,\n        IBeacon _eigenPodBeacon,\n        IStrategyManager _strategyManager,\n        ISlasher _slasher,\n        IDelegationManager _delegationManager\n    ) EigenPodManagerStorage(_ethPOS, _eigenPodBeacon, _strategyManager, _slasher, _delegationManager) {\n        _disableInitializers();\n    }\n\n    function initialize(\n        uint256 _maxPods,\n        IBeaconChainOracle _beaconChainOracle,\n        address initialOwner,\n        IPauserRegistry _pauserRegistry,\n        uint256 _initPausedStatus\n    ) external initializer {\n        _setMaxPods(_maxPods);\n        _updateBeaconChainOracle(_beaconChainOracle);\n        _transferOwnership(initialOwner);\n        _initializePauser(_pauserRegistry, _initPausedStatus);\n    }\n\n    /**\n     * @notice Creates an EigenPod for the sender.\n     * @dev Function will revert if the `msg.sender` already has an EigenPod.\n     * @dev Returns EigenPod address \n     */\n    function createPod() external onlyWhenNotPaused(PAUSED_NEW_EIGENPODS) returns (address) {\n        require(!hasPod(msg.sender), \"EigenPodManager.createPod: Sender already has a pod\");\n        // deploy a pod if the sender doesn't have one already\n        IEigenPod pod = _deployPod();\n\n        return address(pod);\n    }\n\n    /**\n     * @notice Stakes for a new beacon chain validator on the sender's EigenPod.\n     * Also creates an EigenPod for the sender if they don't have one already.\n     * @param pubkey The 48 bytes public key of the beacon chain validator.\n     * @param signature The validator's signature of the deposit data.\n     * @param depositDataRoot The root/hash of the deposit data for the validator's deposit.\n     */\n    function stake(\n        bytes calldata pubkey, \n        bytes calldata signature, \n        bytes32 depositDataRoot\n    ) external payable onlyWhenNotPaused(PAUSED_NEW_EIGENPODS) {\n        IEigenPod pod = ownerToPod[msg.sender];\n        if (address(pod) == address(0)) {\n            //deploy a pod if the sender doesn't have one already\n            pod = _deployPod();\n        }\n        pod.stake{value: msg.value}(pubkey, signature, depositDataRoot);\n    }\n\n    /**\n     * @notice Changes the `podOwner`'s shares by `sharesDelta` and performs a call to the DelegationManager\n     * to ensure that delegated shares are also tracked correctly\n     * @param podOwner is the pod owner whose balance is being updated.\n     * @param sharesDelta is the change in podOwner's beaconChainETHStrategy shares\n     * @dev Callable only by the podOwner's EigenPod contract.\n     * @dev Reverts if `sharesDelta` is not a whole Gwei amount\n     */\n    function recordBeaconChainETHBalanceUpdate(\n        address podOwner,\n        int256 sharesDelta\n    ) external onlyEigenPod(podOwner) nonReentrant {\n        require(podOwner != address(0), \"EigenPodManager.recordBeaconChainETHBalanceUpdate: podOwner cannot be zero address\");\n        require(sharesDelta % int256(GWEI_TO_WEI) == 0,\n            \"EigenPodManager.recordBeaconChainETHBalanceUpdate: sharesDelta must be a whole Gwei amount\");\n        int256 currentPodOwnerShares = podOwnerShares[podOwner];\n        int256 updatedPodOwnerShares = currentPodOwnerShares + sharesDelta;\n        podOwnerShares[podOwner] = updatedPodOwnerShares;\n\n        // inform the DelegationManager of the change in delegateable shares\n        int256 changeInDelegatableShares = _calculateChangeInDelegatableShares({\n            sharesBefore: currentPodOwnerShares,\n            sharesAfter: updatedPodOwnerShares\n        });\n        // skip making a call to the DelegationManager if there is no change in delegateable shares\n        if (changeInDelegatableShares != 0) {\n            if (changeInDelegatableShares < 0) {\n                delegationManager.decreaseDelegatedShares({\n                    staker: podOwner,\n                    strategy: beaconChainETHStrategy,\n                    shares: uint256(-changeInDelegatableShares)\n                });\n            } else {\n                delegationManager.increaseDelegatedShares({\n                    staker: podOwner,\n                    strategy: beaconChainETHStrategy,\n                    shares: uint256(changeInDelegatableShares)\n                });\n            }\n        }\n        emit PodSharesUpdated(podOwner, sharesDelta);\n    }\n\n    /**\n     * @notice Used by the DelegationManager to remove a pod owner's shares while they're in the withdrawal queue.\n     * Simply decreases the `podOwner`'s shares by `shares`, down to a minimum of zero.\n     * @dev This function reverts if it would result in `podOwnerShares[podOwner]` being less than zero, i.e. it is forbidden for this function to\n     * result in the `podOwner` incurring a \"share deficit\". This behavior prevents a Staker from queuing a withdrawal which improperly removes excessive\n     * shares from the operator to whom the staker is delegated.\n     * @dev Reverts if `shares` is not a whole Gwei amount\n     * @dev The delegation manager validates that the podOwner is not address(0)\n     */\n    function removeShares(\n        address podOwner, \n        uint256 shares\n    ) external onlyDelegationManager {\n        require(int256(shares) >= 0, \"EigenPodManager.removeShares: shares cannot be negative\");\n        require(shares % GWEI_TO_WEI == 0, \"EigenPodManager.removeShares: shares must be a whole Gwei amount\");\n        int256 updatedPodOwnerShares = podOwnerShares[podOwner] - int256(shares);\n        require(updatedPodOwnerShares >= 0, \"EigenPodManager.removeShares: cannot result in pod owner having negative shares\");\n        podOwnerShares[podOwner] = updatedPodOwnerShares;\n    }\n\n    /**\n     * @notice Increases the `podOwner`'s shares by `shares`, paying off deficit if possible.\n     * Used by the DelegationManager to award a pod owner shares on exiting the withdrawal queue\n     * @dev Returns the number of shares added to `podOwnerShares[podOwner]` above zero, which will be less than the `shares` input\n     * in the event that the podOwner has an existing shares deficit (i.e. `podOwnerShares[podOwner]` starts below zero)\n     * @dev Reverts if `shares` is not a whole Gwei amount\n     */\n    function addShares(\n        address podOwner,\n        uint256 shares\n    ) external onlyDelegationManager returns (uint256) {\n        require(podOwner != address(0), \"EigenPodManager.addShares: podOwner cannot be zero address\");\n        require(int256(shares) >= 0, \"EigenPodManager.addShares: shares cannot be negative\");\n        require(shares % GWEI_TO_WEI == 0, \"EigenPodManager.addShares: shares must be a whole Gwei amount\");\n        int256 currentPodOwnerShares = podOwnerShares[podOwner];\n        int256 updatedPodOwnerShares = currentPodOwnerShares + int256(shares);\n        podOwnerShares[podOwner] = updatedPodOwnerShares;\n\n        emit PodSharesUpdated(podOwner, int256(shares));\n\n        return uint256(_calculateChangeInDelegatableShares({sharesBefore: currentPodOwnerShares, sharesAfter: updatedPodOwnerShares}));\n    }\n\n    /**\n     * @notice Used by the DelegationManager to complete a withdrawal, sending tokens to some destination address\n     * @dev Prioritizes decreasing the podOwner's share deficit, if they have one\n     * @dev Reverts if `shares` is not a whole Gwei amount\n     * @dev This function assumes that `removeShares` has already been called by the delegationManager, hence why\n     *      we do not need to update the podOwnerShares if `currentPodOwnerShares` is positive\n     */\n    function withdrawSharesAsTokens(\n        address podOwner, \n        address destination, \n        uint256 shares\n    ) external onlyDelegationManager {\n        require(podOwner != address(0), \"EigenPodManager.withdrawSharesAsTokens: podOwner cannot be zero address\");\n        require(destination != address(0), \"EigenPodManager.withdrawSharesAsTokens: destination cannot be zero address\");\n        require(int256(shares) >= 0, \"EigenPodManager.withdrawSharesAsTokens: shares cannot be negative\");\n        require(shares % GWEI_TO_WEI == 0, \"EigenPodManager.withdrawSharesAsTokens: shares must be a whole Gwei amount\");\n        int256 currentPodOwnerShares = podOwnerShares[podOwner];\n\n        // if there is an existing shares deficit, prioritize decreasing the deficit first\n        if (currentPodOwnerShares < 0) {\n            uint256 currentShareDeficit = uint256(-currentPodOwnerShares);\n            // get rid of the whole deficit if possible, and pass any remaining shares onto destination\n            if (shares > currentShareDeficit) {\n                podOwnerShares[podOwner] = 0;\n                shares -= currentShareDeficit;\n                emit PodSharesUpdated(podOwner, int256(currentShareDeficit));\n            // otherwise get rid of as much deficit as possible, and return early, since there is nothing left over to forward on\n            } else {\n                podOwnerShares[podOwner] += int256(shares);\n                emit PodSharesUpdated(podOwner, int256(shares));\n                return;\n            }\n        }\n        // Actually withdraw to the destination\n        ownerToPod[podOwner].withdrawRestakedBeaconChainETH(destination, shares);\n    }\n\n    /**\n     * Sets the maximum number of pods that can be deployed\n     * @param newMaxPods The new maximum number of pods that can be deployed\n     * @dev Callable by the unpauser of this contract\n     */\n    function setMaxPods(uint256 newMaxPods) external onlyUnpauser {\n        _setMaxPods(newMaxPods);\n    }\n\n    /**\n     * @notice Updates the oracle contract that provides the beacon chain state root\n     * @param newBeaconChainOracle is the new oracle contract being pointed to\n     * @dev Callable only by the owner of this contract (i.e. governance)\n     */\n    function updateBeaconChainOracle(IBeaconChainOracle newBeaconChainOracle) external onlyOwner {\n        _updateBeaconChainOracle(newBeaconChainOracle);\n    }\n\n    /**\n     * @notice Sets the timestamp of the Deneb fork.\n     * @param newDenebForkTimestamp is the new timestamp of the Deneb fork\n     */\n    function setDenebForkTimestamp(uint64 newDenebForkTimestamp) external onlyOwner {\n        require(newDenebForkTimestamp != 0, \"EigenPodManager.setDenebForkTimestamp: cannot set newDenebForkTimestamp to 0\");\n        require(_denebForkTimestamp == 0, \"EigenPodManager.setDenebForkTimestamp: cannot set denebForkTimestamp more than once\");\n        \n        _denebForkTimestamp = newDenebForkTimestamp;\n        emit DenebForkTimestampUpdated(newDenebForkTimestamp);\n    }\n\n    // INTERNAL FUNCTIONS\n\n    function _deployPod() internal returns (IEigenPod) {\n        // check that the limit of EigenPods has not been hit, and increment the EigenPod count\n        require(numPods + 1 <= maxPods, \"EigenPodManager._deployPod: pod limit reached\");\n        ++numPods;\n        // create the pod\n        IEigenPod pod = IEigenPod(\n            Create2.deploy(\n                0,\n                bytes32(uint256(uint160(msg.sender))),\n                // set the beacon address to the eigenPodBeacon and initialize it\n                abi.encodePacked(beaconProxyBytecode, abi.encode(eigenPodBeacon, \"\"))\n            )\n        );\n        pod.initialize(msg.sender);\n        // store the pod in the mapping\n        ownerToPod[msg.sender] = pod;\n        emit PodDeployed(address(pod), msg.sender);\n        return pod;\n    }\n\n    /// @notice Internal setter for `beaconChainOracle` that also emits an event\n    function _updateBeaconChainOracle(IBeaconChainOracle newBeaconChainOracle) internal {\n        beaconChainOracle = newBeaconChainOracle;\n        emit BeaconOracleUpdated(address(newBeaconChainOracle));\n    }\n\n    /// @notice Internal setter for `maxPods` that also emits an event\n    function _setMaxPods(uint256 _maxPods) internal {\n        emit MaxPodsUpdated(maxPods, _maxPods);\n        maxPods = _maxPods;\n    }\n\n    /**\n     * @notice Calculates the change in a pod owner's delegateable shares as a result of their beacon chain ETH shares changing\n     * from `sharesBefore` to `sharesAfter`. The key concept here is that negative/\"deficit\" shares are not delegateable.\n     */\n    function _calculateChangeInDelegatableShares(int256 sharesBefore, int256 sharesAfter) internal pure returns (int256) {\n        if (sharesBefore <= 0) {\n            // if the shares started negative and stayed negative, then there cannot have been an increase in delegateable shares\n            if (sharesAfter <= 0) {\n                return 0;\n            // if the shares started negative and became positive, then the increase in delegateable shares is the ending share amount\n            } else {\n                return sharesAfter;\n            }\n        } else {\n            // if the shares started positive and became negative, then the decrease in delegateable shares is the starting share amount\n            if (sharesAfter <= 0) {\n                return (-sharesBefore);\n            // if the shares started positive and stayed positive, then the change in delegateable shares\n            // is the difference between starting and ending amounts\n            } else {\n                return (sharesAfter - sharesBefore);\n            }\n        }\n    }\n\n    // VIEW FUNCTIONS\n    /// @notice Returns the address of the `podOwner`'s EigenPod (whether it is deployed yet or not).\n    function getPod(address podOwner) public view returns (IEigenPod) {\n        IEigenPod pod = ownerToPod[podOwner];\n        // if pod does not exist already, calculate what its address *will be* once it is deployed\n        if (address(pod) == address(0)) {\n            pod = IEigenPod(\n                Create2.computeAddress(\n                    bytes32(uint256(uint160(podOwner))), //salt\n                    keccak256(abi.encodePacked(beaconProxyBytecode, abi.encode(eigenPodBeacon, \"\"))) //bytecode\n                )\n            );\n        }\n        return pod;\n    }\n\n    /// @notice Returns 'true' if the `podOwner` has created an EigenPod, and 'false' otherwise.\n    function hasPod(address podOwner) public view returns (bool) {\n        return address(ownerToPod[podOwner]) != address(0);\n    }\n\n    /// @notice Returns the Beacon block root at `timestamp`. Reverts if the Beacon block root at `timestamp` has not yet been finalized.\n    function getBlockRootAtTimestamp(uint64 timestamp) external view returns (bytes32) {\n        bytes32 stateRoot = beaconChainOracle.timestampToBlockRoot(timestamp);\n        require(\n            stateRoot != bytes32(0),\n            \"EigenPodManager.getBlockRootAtTimestamp: state root at timestamp not yet finalized\"\n        );\n        return stateRoot;\n    }\n\n    /**\n     * @notice Wrapper around the `_denebForkTimestamp` storage variable that returns type(uint64).max if the storage variable is unset.\n     * @dev This allows restricting the storage variable to be set once and only once.\n     */\n    function denebForkTimestamp() public view returns (uint64) {\n        uint64 timestamp = _denebForkTimestamp;\n        if (timestamp == 0) {\n            return type(uint64).max;\n        } else {\n            return timestamp;\n        }\n    }\n}"
    },
    {
      "filename": "rio-sherlock-audit/contracts/restaking/RioLRTWithdrawalQueue.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.23;\n\nimport {UUPSUpgradeable} from '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\nimport {OwnableUpgradeable} from '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport {IRioLRTOperatorDelegator} from 'contracts/interfaces/IRioLRTOperatorDelegator.sol';\nimport {IDelegationManager} from 'contracts/interfaces/eigenlayer/IDelegationManager.sol';\nimport {IRioLRTWithdrawalQueue} from 'contracts/interfaces/IRioLRTWithdrawalQueue.sol';\nimport {SafeCast} from '@openzeppelin/contracts/utils/math/SafeCast.sol';\nimport {FixedPointMathLib} from '@solady/utils/FixedPointMathLib.sol';\nimport {RioLRTCore} from 'contracts/restaking/base/RioLRTCore.sol';\nimport {ETH_ADDRESS} from 'contracts/utils/Constants.sol';\nimport {Array} from 'contracts/utils/Array.sol';\nimport {Asset} from 'contracts/utils/Asset.sol';\n\ncontract RioLRTWithdrawalQueue is IRioLRTWithdrawalQueue, OwnableUpgradeable, UUPSUpgradeable, RioLRTCore {\n    using FixedPointMathLib for *;\n    using Asset for address;\n    using Array for *;\n\n    /// @notice The primary delegation contract for EigenLayer.\n    IDelegationManager public immutable delegationManager;\n\n    /// @notice Current asset withdrawal epochs. Incoming withdrawals are included\n    /// in the current epoch, which will be processed by the asset manager.\n    mapping(address asset => uint256 epoch) internal currentEpochsByAsset;\n\n    /// @notice The amount of assets owed to users in a given epoch, as well as the state\n    /// of the epoch's withdrawals.\n    mapping(address asset => mapping(uint256 epoch => EpochWithdrawals withdrawals)) internal epochWithdrawalsByAsset;\n\n    /// @param issuer_ The LRT issuer that's authorized to deploy this contract.\n    /// @param delegationManager_ The EigenLayer delegation manager."
    }
  ]
}