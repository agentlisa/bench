{
  "Title": "M-21: Minting an NFT with a position on the same bucket as a previously minted NFT changes its deposit time",
  "Content": "# Issue M-21: Minting an NFT with a position on the same bucket as a previously minted NFT changes its deposit time \n\nSource: https://github.com/sherlock-audit/2023-01-ajna-judging/issues/19 \n\n## Found by \nMalfurionWhitehat\n\n## Summary\n\nMinting an NFT with a position on the same bucket as a previously minted NFT changes its deposit time.\n\n## Vulnerability Detail\n\nThis issue happens because, after a position is memorialized on the `PositionManager`, this contract will centralize LP positions from different users, but these will be mapped to the same address from the point of view of Ajna pools (different users will be mapped as the same `lender` from the point of view of a `Pool`). \n\nIf more than one user has memorialized a position to the same bucket index, [`LenderActions.transferLPs`](https://github.com/sherlock-audit/2023-01-ajna/blob/main/contracts/src/libraries/external/LenderActions.sol#L547) will update the `depositTime` to the maximum of the previous and new lender's values.\n\nAs a result, when a second user memorializes their position as an NFT, the first user's `depositTime` will be overwritten by the second user's (greater) `depositTime`.\n\n## Impact\n\nThe `depositTime` is used when applying early withdrawal fee and on bankruptcy LP calculation. One of the impacts of this issue is that a user might incur in withdrawal fees because of another user. See the following scenario:\n\n1. User1 memorializes position on bucket B\n2. One day passes, so User1 should not be affected by early withdrawal penalty\n3. User2 memorializes position on bucket B, and `depositTime` for both users (as they are using `PositionManager`) is updated to this new value\n4. User1 withdraws, will incur in early withdrawal penalty\n\n## Code Snippet\n\n```solidity\n            newLender.depositTime = Maths.max(lenderDepositTime, newLender.depositTime);\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nReconsider the `PositionsManager` architecture and the way the LP properties are stored on the Ajna protocol. Since positions are not tokenized by default, but instead are stored on state variables on each pool, it is arguably more complex to reason about transferring positions between two users. Conversely, the ERC-721 standard already provides straightforward methods for minting/burning/sending tokens for accounts. This issue could be fixed by removing the optionality of NFT minting through another independent contract (the `PositionManager.sol`), as it is centralizing other user's LPs, and instead to refactoring the Ajna pools so that every position is an ERC-721 NFT minted directly by the `Pool.sol`.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/32",
  "Code": [
    {
      "filename": "contracts/src/libraries/external/LenderActions.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.14;\n\nimport {\n    AddQuoteParams,\n    MoveQuoteParams,\n    RemoveQuoteParams\n}                     from '../../interfaces/pool/commons/IPoolInternals.sol';\nimport {\n    Bucket,\n    DepositsState,\n    Lender,\n    PoolState\n}                     from '../../interfaces/pool/commons/IPoolState.sol';\n\nimport { _feeRate, _priceAt, _ptp, MAX_FENWICK_INDEX } from '../helpers/PoolHelper.sol';\n\nimport { Deposits } from '../internal/Deposits.sol';\nimport { Buckets }  from '../internal/Buckets.sol';\nimport { Maths }    from '../internal/Maths.sol';\n\n\n/**\n    @title  LenderActions library\n    @notice External library containing logic for pool actors:\n            - Lenders: add, remove and move quote tokens; transfer LPs\n            - Traders: add, remove and move quote tokens; add and remove collateral\n */\nlibrary LenderActions {\n\n    /*************************/\n    /*** Local Var Structs ***/\n    /*************************/\n\n    struct MoveQuoteLocalVars {\n        uint256 amountToMove;           // [WAD] Quote token amount to move between indexes.\n        uint256 fromBucketPrice;        // [WAD] Price of the bucket to move amount from.\n        uint256 fromBucketLPs;          // [RAY] Amount of LPs in the bucket to move amount from.\n        uint256 fromBucketDepositTime;  // Time of lender deposit in the bucket to move amount from.\n        uint256 toBucketPrice;          // [WAD] Price of the bucket to move amount to.\n        uint256 toBucketBankruptcyTime; // Time the bucket to move amount to was marked as insolvent.\n        uint256 ptp;                    // [WAD] Pool Threshold Price.\n        uint256 htp;                    // [WAD] Highest Threshold Price.\n    }\n    struct RemoveDepositParams {\n        uint256 depositConstraint; // [WAD] Constraint on deposit in quote token.\n        uint256 lpConstraint;      // [RAY] Constraint in LPB terms.\n        uint256 bucketLPs;         // [RAY] Total LPB in the bucket.\n        uint256 bucketCollateral;  // [WAD] Claimable collateral in the bucket.\n        uint256 price;             // [WAD] Price of bucket.\n        uint256 index;             // Bucket index.\n        uint256 dustLimit;         // Minimum amount of deposit which may reside in a bucket.\n    }\n\n    /**************/\n    /*** Events ***/\n    /**************/\n\n    // See `IPoolEvents` for descriptions\n    event AddQuoteToken(address indexed lender, uint256 indexed price, uint256 amount, uint256 lpAwarded, uint256 lup);\n    event BucketBankruptcy(uint256 indexed index, uint256 lpForfeited);\n    event MoveQuoteToken(address indexed lender, uint256 indexed from, uint256 indexed to, uint256 amount, uint256 lpRedeemedFrom, uint256 lpAwardedTo, uint256 lup);\n    event RemoveQuoteToken(address indexed lender, uint256 indexed price, uint256 amount, uint256 lpRedeemed, uint256 lup);\n    event TransferLPTokens(address owner, address newOwner, uint256[] indexes, uint256 lpTokens);\n\n    /**************/\n    /*** Errors ***/\n    /**************/\n\n    // See `IPoolErrors` for descriptions\n    error BucketBankruptcyBlock();\n    error CannotMergeToHigherPrice();\n    error DustAmountNotExceeded();\n    error NoAllowance();\n    error InvalidIndex();\n    error LUPBelowHTP();\n    error NoClaim();\n    error InsufficientLPs();\n    error InsufficientLiquidity();\n    error InsufficientCollateral();\n    error MoveToSamePrice();\n\n    /***************************/\n    /***  External Functions ***/\n    /***************************/\n\n    /**\n     *  @notice See `IERC20PoolLenderActions` and `IERC721PoolLenderActions` for descriptions\n     *  @dev    write state:\n     *              - Buckets.addCollateral:\n     *                  - increment bucket.collateral and bucket.lps accumulator\n     *                  - addLenderLPs:\n     *                      - increment lender.lps accumulator and lender.depositTime state\n     *  @dev    reverts on:\n     *              - invalid bucket index InvalidIndex()\n     */\n    function addCollateral(\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        uint256 collateralAmountToAdd_,\n        uint256 index_\n    ) external returns (uint256 bucketLPs_) {\n        if (index_ == 0 || index_ > MAX_FENWICK_INDEX) revert InvalidIndex();\n\n        uint256 bucketDeposit = Deposits.valueAt(deposits_, index_);\n        uint256 bucketPrice   = _priceAt(index_);\n\n        bucketLPs_ = Buckets.addCollateral(\n            buckets_[index_],\n            msg.sender,\n            bucketDeposit,\n            collateralAmountToAdd_,\n            bucketPrice\n        );\n    }\n\n    /**\n     *  @notice See `IPoolLenderActions` for descriptions\n     *  @dev    write state:\n     *              - Deposits.unscaledAdd (add new amount in Fenwick tree):\n     *                  - update values array state \n     *              - increment bucket.lps accumulator\n     *              - increment lender.lps accumulator and lender.depositTime state\n     *  @dev    reverts on:\n     *              - invalid bucket index InvalidIndex()\n     *              - same block when bucket becomes insolvent BucketBankruptcyBlock()\n     *  @dev    emit events:\n     *              - AddQuoteToken\n     */\n    function addQuoteToken(\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        PoolState calldata poolState_,\n        AddQuoteParams calldata params_\n    ) external returns (uint256 bucketLPs_, uint256 lup_) {\n        if (params_.index == 0 || params_.index > MAX_FENWICK_INDEX) revert InvalidIndex();\n\n        Bucket storage bucket = buckets_[params_.index];\n\n        uint256 bankruptcyTime = bucket.bankruptcyTime;\n\n        // cannot deposit in the same block when bucket becomes insolvent\n        if (bankruptcyTime == block.timestamp) revert BucketBankruptcyBlock();\n\n        uint256 unscaledBucketDeposit = Deposits.unscaledValueAt(deposits_, params_.index);\n        uint256 bucketScale           = Deposits.scale(deposits_, params_.index);\n        uint256 bucketDeposit         = Maths.wmul(bucketScale, unscaledBucketDeposit);\n        uint256 bucketPrice           = _priceAt(params_.index);\n\n        bucketLPs_ = Buckets.quoteTokensToLPs(\n            bucket.collateral,\n            bucket.lps,\n            bucketDeposit,\n            params_.amount,\n            bucketPrice\n        );\n\n        Deposits.unscaledAdd(deposits_, params_.index, Maths.wdiv(params_.amount, bucketScale));\n\n        // update lender LPs\n        Lender storage lender = bucket.lenders[msg.sender];\n\n        if (bankruptcyTime >= lender.depositTime) lender.lps = bucketLPs_;\n        else lender.lps += bucketLPs_;\n\n        lender.depositTime = block.timestamp;\n\n        // update bucket LPs\n        bucket.lps += bucketLPs_;\n\n        lup_ = _lup(deposits_, poolState_.debt);\n\n        emit AddQuoteToken(msg.sender, params_.index, params_.amount, bucketLPs_, lup_);\n    }\n\n    /**\n     *  @notice See `IPoolLenderActions` for descriptions\n     *  @dev    write state:\n     *              - _removeMaxDeposit:\n     *                  - Deposits.unscaledRemove (remove amount in Fenwick tree, from index):\n     *                  - update values array state\n     *              - Deposits.unscaledAdd (add amount in Fenwick tree, to index):\n     *                  - update values array state\n     *              - decrement lender.lps accumulator for from bucket\n     *              - increment lender.lps accumulator and lender.depositTime state for to bucket\n     *              - decrement bucket.lps accumulator for from bucket\n     *              - increment bucket.lps accumulator for to bucket\n     *  @dev    reverts on:\n     *              - same index MoveToSamePrice()\n     *              - dust amount DustAmountNotExceeded()\n     *              - invalid index InvalidIndex()\n     *  @dev    emit events:\n     *              - MoveQuoteToken\n     */\n    function moveQuoteToken(\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        PoolState calldata poolState_,\n        MoveQuoteParams calldata params_\n    ) external returns (uint256 fromBucketRedeemedLPs_, uint256 toBucketLPs_, uint256 lup_) {\n        if (params_.fromIndex == params_.toIndex)\n            revert MoveToSamePrice();\n        if (params_.maxAmountToMove != 0 && params_.maxAmountToMove < poolState_.quoteDustLimit)\n            revert DustAmountNotExceeded();\n        if (params_.toIndex == 0 || params_.toIndex > MAX_FENWICK_INDEX) \n            revert InvalidIndex();\n\n        Bucket storage toBucket = buckets_[params_.toIndex];\n\n        MoveQuoteLocalVars memory vars;\n        vars.toBucketBankruptcyTime = toBucket.bankruptcyTime;\n\n        // cannot move in the same block when target bucket becomes insolvent\n        if (vars.toBucketBankruptcyTime == block.timestamp) revert BucketBankruptcyBlock();\n\n        Bucket storage fromBucket       = buckets_[params_.fromIndex];\n        Lender storage fromBucketLender = fromBucket.lenders[msg.sender];\n\n        vars.fromBucketPrice       = _priceAt(params_.fromIndex);\n        vars.toBucketPrice         = _priceAt(params_.toIndex);\n        vars.fromBucketDepositTime = fromBucketLender.depositTime;\n\n        if (fromBucket.bankruptcyTime < vars.fromBucketDepositTime) vars.fromBucketLPs = fromBucketLender.lps;\n\n        (vars.amountToMove, fromBucketRedeemedLPs_, ) = _removeMaxDeposit(\n            deposits_,\n            RemoveDepositParams({\n                depositConstraint: params_.maxAmountToMove,\n                lpConstraint:      vars.fromBucketLPs,\n                bucketLPs:         fromBucket.lps,\n                bucketCollateral:  fromBucket.collateral,\n                price:             vars.fromBucketPrice,\n                index:             params_.fromIndex,\n                dustLimit:         poolState_.quoteDustLimit\n            })\n        );\n\n        vars.ptp = _ptp(poolState_.debt, poolState_.collateral);\n\n        // apply early withdrawal penalty if quote token is moved from above the PTP to below the PTP\n        if (vars.fromBucketDepositTime != 0 && block.timestamp - vars.fromBucketDepositTime < 1 days) {\n            if (vars.fromBucketPrice > vars.ptp && vars.toBucketPrice < vars.ptp) {\n                vars.amountToMove = Maths.wmul(vars.amountToMove, Maths.WAD - _feeRate(poolState_.rate));\n            }\n        }\n\n        uint256 unscaledToBucketDeposit = Deposits.unscaledValueAt(deposits_, params_.toIndex);\n        uint256 toBucketScale           = Deposits.scale(deposits_, params_.toIndex);\n        uint256 toBucketDeposit         = Maths.wmul(toBucketScale, unscaledToBucketDeposit);\n        vars.toBucketPrice              = _priceAt(params_.toIndex);\n        toBucketLPs_ = Buckets.quoteTokensToLPs(\n            toBucket.collateral,\n            toBucket.lps,\n            toBucketDeposit,\n            vars.amountToMove,\n            vars.toBucketPrice\n        );\n\n        Deposits.unscaledAdd(deposits_, params_.toIndex, Maths.wdiv(vars.amountToMove, toBucketScale));\n\n        lup_     = _lup(deposits_, poolState_.debt);\n        vars.htp = Maths.wmul(params_.thresholdPrice, poolState_.inflator);\n\n        // check loan book's htp against new lup, revert if move drives LUP below HTP\n        if (params_.fromIndex < params_.toIndex) if(vars.htp > lup_) revert LUPBelowHTP();\n\n        // update lender LPs balance in from bucket\n        fromBucketLender.lps -= fromBucketRedeemedLPs_;\n\n        // update lender LPs balance and deposit time in target bucket\n        Lender storage toBucketLender = toBucket.lenders[msg.sender];\n\n        if (vars.toBucketBankruptcyTime >= toBucketLender.depositTime) toBucketLender.lps = toBucketLPs_;\n        else toBucketLender.lps += toBucketLPs_;\n\n        // set deposit time to the greater of the lender's from bucket and the target bucket's last bankruptcy timestamp + 1 so deposit won't get invalidated\n        toBucketLender.depositTime = Maths.max(vars.fromBucketDepositTime, vars.toBucketBankruptcyTime + 1);\n\n        // update buckets LPs balance\n        fromBucket.lps -= fromBucketRedeemedLPs_;\n        toBucket.lps   += toBucketLPs_;\n\n        emit MoveQuoteToken(\n            msg.sender,\n            params_.fromIndex,\n            params_.toIndex,\n            vars.amountToMove,\n            fromBucketRedeemedLPs_,\n            toBucketLPs_,\n            lup_\n        );\n    }\n\n    /**\n     *  @notice See `IPoolLenderActions` for descriptions\n     *  @dev    write state:\n     *          - _removeMaxDeposit:\n     *              - Deposits.unscaledRemove (remove amount in Fenwick tree):\n     *                  - update values array state\n     *              - decrement lender.lps accumulator\n     *              - decrement bucket.lps accumulator\n     *  @dev    reverts on:\n     *              - no LPs NoClaim()\n     *              - LUP lower than HTP LUPBelowHTP()\n     *  @dev    emit events:\n     *              - RemoveQuoteToken\n     *              - BucketBankruptcy\n     */\n    function removeQuoteToken(\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        PoolState calldata poolState_,\n        RemoveQuoteParams calldata params_\n    ) external returns (uint256 removedAmount_, uint256 redeemedLPs_, uint256 lup_) {\n        Bucket storage bucket = buckets_[params_.index];\n        Lender storage lender = bucket.lenders[msg.sender];\n\n        uint256 depositTime = lender.depositTime;\n\n        RemoveDepositParams memory removeParams;\n\n        if (bucket.bankruptcyTime < lender.depositTime) removeParams.lpConstraint = lender.lps;\n\n        if (removeParams.lpConstraint == 0) revert NoClaim(); // revert if no LP to claim\n\n        removeParams.depositConstraint = params_.maxAmount;\n        removeParams.price             = _priceAt(params_.index);\n        removeParams.bucketLPs         = bucket.lps;\n        removeParams.bucketCollateral  = bucket.collateral;\n        removeParams.index             = params_.index;\n        removeParams.dustLimit         = poolState_.quoteDustLimit;\n\n        uint256 unscaledRemaining;\n        (removedAmount_, redeemedLPs_, unscaledRemaining) = _removeMaxDeposit(\n            deposits_,\n            removeParams\n        );\n\n        // apply early withdrawal penalty if quote token is removed from above the PTP\n        if (depositTime != 0 && block.timestamp - depositTime < 1 days) {\n            if (removeParams.price > _ptp(poolState_.debt, poolState_.collateral)) {\n                removedAmount_ = Maths.wmul(removedAmount_, Maths.WAD - _feeRate(poolState_.rate));\n            }\n        }\n\n        lup_ = _lup(deposits_, poolState_.debt);\n\n        uint256 htp = Maths.wmul(params_.thresholdPrice, poolState_.inflator);\n\n        // check loan book's htp against new lup\n        if (htp > lup_) revert LUPBelowHTP();\n\n        // update lender and bucket LPs balances\n        lender.lps -= redeemedLPs_;\n\n        uint256 lpsRemaining = removeParams.bucketLPs - redeemedLPs_;\n\n        if (removeParams.bucketCollateral == 0 && unscaledRemaining == 0 && lpsRemaining != 0) {\n            emit BucketBankruptcy(params_.index, lpsRemaining);\n            bucket.lps            = 0;\n            bucket.bankruptcyTime = block.timestamp;\n        } else {\n            bucket.lps = lpsRemaining;\n        }\n\n        emit RemoveQuoteToken(msg.sender, params_.index, removedAmount_, redeemedLPs_, lup_);\n    }\n\n    /**\n     *  @notice See `IPoolLenderActions` for descriptions\n     *  @dev    write state:\n     *              - decrement lender.lps accumulator\n     *              - decrement bucket.collateral and bucket.lps accumulator\n     *  @dev    reverts on:\n     *              - not enough collateral InsufficientCollateral()\n     *              - insufficient LPs InsufficientLPs()\n     */\n    function removeCollateral(\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        uint256 amount_,\n        uint256 index_\n    ) external returns (uint256 lpAmount_) {\n        Bucket storage bucket = buckets_[index_];\n\n        uint256 bucketCollateral = bucket.collateral;\n\n        if (amount_ > bucketCollateral) revert InsufficientCollateral();\n\n        uint256 bucketPrice = _priceAt(index_);\n        uint256 bucketLPs   = bucket.lps;\n\n        lpAmount_ = Buckets.collateralToLPs(\n            bucketCollateral,\n            bucketLPs,\n            Deposits.valueAt(deposits_, index_),\n            amount_,\n            bucketPrice\n        );\n\n        Lender storage lender = bucket.lenders[msg.sender];\n\n        uint256 lenderLpBalance;\n        if (bucket.bankruptcyTime < lender.depositTime) lenderLpBalance = lender.lps;\n        if (lenderLpBalance == 0 || lpAmount_ > lenderLpBalance) revert InsufficientLPs();\n\n        // update lender LPs balance\n        lender.lps -= lpAmount_;\n\n        // update bucket LPs and collateral balance\n        bucket.lps        -= Maths.min(bucketLPs, lpAmount_);\n        bucket.collateral -= Maths.min(bucketCollateral, amount_);\n    }\n\n    /**\n     *  @notice Removes max collateral amount from a given bucket index.\n     *  @dev    write state:\n     *              - _removeMaxCollateral:\n     *                  - decrement lender.lps accumulator\n     *                  - decrement bucket.collateral and bucket.lps accumulator\n     *  @dev    reverts on:\n     *              - not enough collateral InsufficientCollateral()\n     *              - no claim NoClaim()\n     *  @return Amount of collateral that was removed.\n     *  @return Amount of LPs redeemed for removed collateral amount.\n     */\n    function removeMaxCollateral(\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        uint256 maxAmount_,\n        uint256 index_\n    ) external returns (uint256, uint256) {\n        return _removeMaxCollateral(\n            buckets_,\n            deposits_,\n            maxAmount_,\n            index_\n        );\n    }\n\n    /**\n     *  @notice See `IERC721PoolLenderActions` for descriptions\n     *  @dev    write state:\n     *              - Buckets.addCollateral:\n     *                  - increment bucket.collateral and bucket.lps accumulator\n     *                  - addLenderLPs:\n     *                      - increment lender.lps accumulator and lender.depositTime state\n     *  @dev    reverts on:\n     *              - invalid merge index CannotMergeToHigherPrice()\n     */\n    function mergeOrRemoveCollateral(\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        uint256[] calldata removalIndexes_,\n        uint256 collateralAmount_,\n        uint256 toIndex_\n    ) external returns (uint256 collateralToMerge_, uint256 bucketLPs_) {\n        uint256 i;\n        uint256 fromIndex;\n        uint256 collateralRemoved;\n        uint256 noOfBuckets = removalIndexes_.length;\n        uint256 collateralRemaining = collateralAmount_;\n\n        // Loop over buckets, exit if collateralAmount is reached or max noOfBuckets is reached\n        while (collateralToMerge_ < collateralAmount_ && i < noOfBuckets) {\n            fromIndex = removalIndexes_[i];\n\n            if (fromIndex > toIndex_) revert CannotMergeToHigherPrice();\n\n            (collateralRemoved, ) = _removeMaxCollateral(\n                buckets_,\n                deposits_,\n                collateralRemaining,\n                fromIndex\n            );\n\n            collateralToMerge_ += collateralRemoved;\n\n            collateralRemaining = collateralRemaining - collateralRemoved;\n\n            unchecked { ++i; }\n        }\n\n        if (collateralToMerge_ != collateralAmount_) {\n            // Merge totalled collateral to specified bucket, toIndex_\n            uint256 toBucketDeposit = Deposits.valueAt(deposits_, toIndex_);\n            uint256 toBucketPrice   = _priceAt(toIndex_);\n\n            bucketLPs_ = Buckets.addCollateral(\n                buckets_[toIndex_],\n                msg.sender,\n                toBucketDeposit,\n                collateralToMerge_,\n                toBucketPrice\n            );\n        }\n    }\n\n    /**\n     *  @notice See `IPoolLenderActions` for descriptions\n     *  @dev write state:\n     *          - delete allowance mapping\n     *          - increment new lender.lps accumulator and lender.depositTime state\n     *          - delete old lender from bucket -> lender mapping\n     *  @dev reverts on:\n     *          - invalid index InvalidIndex()\n     *          - no allowance NoAllowance()\n     *  @dev emit events:\n     *          - TransferLPTokens\n     */\n    function transferLPs(\n        mapping(uint256 => Bucket) storage buckets_,\n        mapping(address => mapping(address => mapping(uint256 => uint256))) storage allowances_,\n        address owner_,\n        address newOwner_,\n        uint256[] calldata indexes_\n    ) external {\n        uint256 indexesLength = indexes_.length;\n\n        uint256 tokensTransferred;\n\n        for (uint256 i = 0; i < indexesLength; ) {\n            uint256 index = indexes_[i];\n            if (index > MAX_FENWICK_INDEX) revert InvalidIndex();\n\n            uint256 transferAmount = allowances_[owner_][newOwner_][index];\n\n            Bucket storage bucket = buckets_[index];\n            Lender storage lender = bucket.lenders[owner_];\n\n            uint256 lenderDepositTime = lender.depositTime;\n\n            uint256 lenderLpBalance;\n\n            if (bucket.bankruptcyTime < lenderDepositTime) lenderLpBalance = lender.lps;\n\n            if (transferAmount == 0 || transferAmount != lenderLpBalance) revert NoAllowance();\n\n            delete allowances_[owner_][newOwner_][index]; // delete allowance\n\n            // move lp tokens to the new owner address\n            Lender storage newLender = bucket.lenders[newOwner_];\n\n            newLender.lps += transferAmount;\n\n            newLender.depositTime = Maths.max(lenderDepositTime, newLender.depositTime);\n\n            // reset owner lp balance for this index\n            delete bucket.lenders[owner_];\n\n            tokensTransferred += transferAmount;\n\n            unchecked { ++i; }\n        }\n\n        emit TransferLPTokens(owner_, newOwner_, indexes_, tokensTransferred);\n    }\n\n    /**************************/\n    /*** Internal Functions ***/\n    /**************************/\n\n    /**\n     *  @notice Removes max collateral amount from a given bucket index.\n     *  @dev    write state:\n     *              - decrement lender.lps accumulator\n     *              - decrement bucket.collateral and bucket.lps accumulator\n     *  @dev    reverts on:\n     *              - not enough collateral InsufficientCollateral()\n     *              - no claim NoClaim()\n     *  @dev    emit events:\n     *              - BucketBankruptcy\n     *  @return collateralAmount_ Amount of collateral that was removed.\n     *  @return lpAmount_         Amount of LPs redeemed for removed collateral amount.\n     */\n    function _removeMaxCollateral(\n        mapping(uint256 => Bucket) storage buckets_,\n        DepositsState storage deposits_,\n        uint256 maxAmount_,\n        uint256 index_\n    ) internal returns (uint256 collateralAmount_, uint256 lpAmount_) {\n        Bucket storage bucket = buckets_[index_];\n\n        uint256 bucketCollateral = bucket.collateral;\n        if (bucketCollateral == 0) revert InsufficientCollateral(); // revert if there's no collateral in bucket\n\n        Lender storage lender = bucket.lenders[msg.sender];\n\n        uint256 lenderLpBalance;\n\n        if (bucket.bankruptcyTime < lender.depositTime) lenderLpBalance = lender.lps;\n        if (lenderLpBalance == 0) revert NoClaim();                  // revert if no LP to redeem\n\n        uint256 bucketPrice   = _priceAt(index_);\n        uint256 bucketLPs     = bucket.lps;\n        uint256 bucketDeposit = Deposits.valueAt(deposits_, index_);\n\n        // limit amount by what is available in the bucket\n        collateralAmount_ = Maths.min(maxAmount_, bucketCollateral);\n\n        // determine how much LP would be required to remove the requested amount\n        uint256 collateralValue     = Maths.wmul(bucketPrice, bucketCollateral);\n        uint256 lpsForAllCollateral = Maths.rmul(bucketLPs, Maths.wwdivr(collateralValue, collateralValue + bucketDeposit));\n        uint256 requiredLPs         = Maths.rmul(lpsForAllCollateral, Maths.wwdivr(collateralAmount_, bucketCollateral));\n\n        // limit withdrawal by the lender's LPB\n        if (requiredLPs <= lenderLpBalance) {\n            // withdraw collateralAmount_ as is\n            lpAmount_ = requiredLPs;\n        } else {\n            lpAmount_         = lenderLpBalance;\n            collateralAmount_ = Maths.wmul(Maths.rrdivw(lenderLpBalance,lpsForAllCollateral), bucketCollateral);\n        }\n\n        // update lender LPs balance\n        lender.lps -= lpAmount_;\n\n        // update bucket LPs and collateral balance\n        bucketLPs         -= Maths.min(bucketLPs, lpAmount_);\n        bucketCollateral  -= Maths.min(bucketCollateral, collateralAmount_);\n        bucket.collateral  = bucketCollateral;\n        if (bucketCollateral == 0 && bucketDeposit == 0 && bucketLPs != 0) {\n            emit BucketBankruptcy(index_, bucketLPs);\n            bucket.lps            = 0;\n            bucket.bankruptcyTime = block.timestamp;\n        } else {\n            bucket.lps = bucketLPs;\n        }\n    }\n\n\n    /**\n     *  @notice Removes the amount of quote tokens calculated for the given amount of LPs.\n     *  @dev    write state:\n     *          - Deposits.unscaledRemove (remove amount in Fenwick tree, from index):\n     *              - update values array state\n     *  @return removedAmount_     Amount of scaled deposit removed.\n     *  @return redeemedLPs_       Amount of bucket LPs corresponding for calculated unscaled deposit amount.\n     */\n    function _removeMaxDeposit(\n        DepositsState storage deposits_,\n        RemoveDepositParams memory params_\n    ) internal returns (uint256 removedAmount_, uint256 redeemedLPs_, uint256 unscaledRemaining_) {\n\n        uint256 unscaledDepositAvailable = Deposits.unscaledValueAt(deposits_, params_.index);\n        if (unscaledDepositAvailable == 0) revert InsufficientLiquidity(); // revert if there's no liquidity available to remove\n\n        uint256 depositScale = Deposits.scale(deposits_, params_.index);\n\n        uint256 unscaledExchangeRate = Buckets.getUnscaledExchangeRate(\n            params_.bucketCollateral,\n            params_.bucketLPs,\n            unscaledDepositAvailable,\n            depositScale,\n            params_.price\n        );\n\n        // Below is pseudocode explaining the logic behind finding the constrained amount of deposit and LPB\n        // unscaledRemovedAmount is constrained by the de-scaled maxAmount(in QT), the unscaledDeposit constraint, and\n        // the lender LPB exchange rate in unscaled deposit-to-LPB for the bucket:\n        // unscaledRemovedAmount = min ( maxAmount_/scale, unscaledDeposit, lenderLPsBalance*unscaledExchangeRate)\n        // redeemedLPs_ = min ( maxAmount_/(unscaledExchangeRate*scale), unscaledDeposit/unscaledExchangeRate, lenderLPsBalance)\n\n        uint256 unscaledRemovedAmount;\n        uint256 unscaledLpConstraint = Maths.rmul(params_.lpConstraint, unscaledExchangeRate);\n        if (\n            params_.depositConstraint < Maths.wmul(unscaledDepositAvailable, depositScale) &&\n            Maths.wwdivr(params_.depositConstraint, depositScale) < unscaledLpConstraint\n        ) {\n            // depositConstraint is binding constraint\n            unscaledRemovedAmount = Maths.wdiv(params_.depositConstraint, depositScale);\n            redeemedLPs_          = Maths.wrdivr(unscaledRemovedAmount, unscaledExchangeRate);\n        } else if (Maths.wadToRay(unscaledDepositAvailable) < unscaledLpConstraint) {\n            // unscaledDeposit is binding constraint\n            unscaledRemovedAmount = unscaledDepositAvailable;\n            redeemedLPs_          = Maths.wrdivr(unscaledRemovedAmount, unscaledExchangeRate);\n        } else {\n            // redeeming all LPs\n            redeemedLPs_          = params_.lpConstraint;\n            unscaledRemovedAmount = Maths.rayToWad(Maths.rmul(redeemedLPs_, unscaledExchangeRate));\n        }\n\n        // If clearing out the bucket deposit, ensure it's zeroed out\n        if (redeemedLPs_ == params_.bucketLPs) {\n            unscaledRemovedAmount = unscaledDepositAvailable;\n        }\n\n        // calculate the scaled amount removed from deposits\n        removedAmount_     = Maths.wmul(depositScale, unscaledRemovedAmount);        \n        // calculate amount remaining\n        unscaledRemaining_ = unscaledDepositAvailable - unscaledRemovedAmount;\n        uint256 remaining  = Maths.wmul(depositScale, unscaledRemaining_);\n\n        // abandon dust amounts upon last withdrawal\n        if (remaining < params_.dustLimit && redeemedLPs_ == params_.bucketLPs) {\n            unscaledRemovedAmount = unscaledDepositAvailable;\n            unscaledRemaining_ = 0;\n        }\n\n        Deposits.unscaledRemove(deposits_, params_.index, unscaledRemovedAmount); // update FenwickTree\n    }\n\n    /**********************/\n    /*** View Functions ***/\n    /**********************/\n\n    function _lup(\n        DepositsState storage deposits_,\n        uint256 debt_\n    ) internal view returns (uint256) {\n        return _priceAt(Deposits.findIndexOfSum(deposits_, debt_));\n    }\n}"
    }
  ]
}