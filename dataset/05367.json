{
  "Title": "[M-07] positionMapping for last element in heap is not updated when extracting max element",
  "Content": "\n<https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/MaxHeap.sol#L156> <br><https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/MaxHeap.sol#L94>\n\nDuring the extraction of the max element through the function [extractMax()](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/MaxHeap.sol#L156), the `positionMapping` for the last element in the heap tree is not updated when the last element is equal to its parent.\n\nThese are the following impacts:\n\n1.  MaxHeap does not function as intended and breaks its expected functionality due to element being incorrectly indexed in the heap.\n2.  When a new element is inserted to that index, the incorrectly indexed element accesses the new element's itemId during value updates\n3.  Downward heapifying will work incorrectly leading to the parent having a value smaller than its child. Thus, further breaking not only the maxHeap tree but also the binary tree spec.\n4.  Error in this heapifying will lead to the incorrectly indexed element being extracted.\n\n**Note: Point 3 in the impacts above breaks an invariant of the MaxHeap tree mentioned in the README.**\n\n```solidity\nThe MaxHeap should always maintain the property of being a binary tree in which the value in each internal node is greater than or equal to the values in the children of that node. \n```\n\n### Proof of Concept\n\nHere is the whole process:\n\n1.  Let's assume this is the current state of the maxHeap tree.\n\n*   The values have been made small for ease of demonstration of the issue\n*   The itemIds being used are 1,2,3,4,5 with values being 50,20,15,10,20 respectively.\n*   The current indexes of the items are 0,1,2,3,4 (since size starts from 0)\n*   The current size of the tree is 5.\n*   Over here, note that **itemId 2 is the parent of itemId 5 and both have the same values 20**.\n\n*Note: to view the provided image, please see the original submission [here](https://github.com/code-423n4/2023-12-revolutionprotocol-findings/issues/363).*\n\n2.  Now let's say the top element with itemId = 1 and value = 50 is extracted using the [extractMax()](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/MaxHeap.sol#L156) function. The following occurs:\n\n*   On Line 174, we store the itemId at the root into the variable popped\n*   On Line 175, we replace the itemId at the root (effectively erasing it) with the last element in the heap tree i.e. itemId 5.\n*   On Line 175, size is decremented from 5 to 4 as expected.\n*   Following this on Line 178, we maxHeapify the current element at the root i.e. itemId 5 which was just set on Line 174.\n\n```solidity\nFile: MaxHeap.sol\n171:     function extractMax() external onlyAdmin returns (uint256, uint256) {\n172:         require(size > 0, \"Heap is empty\"); \n173: \n174:         uint256 popped = heap[0]; \n175:         heap[0] = heap[--size]; \n176:         \n177:         \n178:         maxHeapify(0); \n179: \n180:         return (popped, valueMapping[popped]); \n181:     }\n```\n\n3.  During the [maxHeapify()](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/MaxHeap.sol#L94) internal function call, the following occurs:\n\n*   On Lines 100-101, left and right are the indexes 1 and 2 (since pos = 0)\n*   On Lines 103-105, the values of the respective itemIds 5,2,3 are extracted as 20,20,15 respectively.\n*   On Line 107, we pass the check since 0 is not >= 2 (since size/2 = 4/2 = 2)\n*   On Line 109, we do not enter the if block since in the tree now, itemId 5 at the root has value 20 which is neither less than itemId 2 with value 20 nor itemId 3 with value 15. Thus, the function returns back to extractMax() and the call ends.\n\n```solidity\nFile: MaxHeap.sol\n099:     function maxHeapify(uint256 pos) internal {\n100:         uint256 left = 2 * pos + 1; \n101:         uint256 right = 2 * pos + 2; \n102: \n103:         uint256 posValue = valueMapping[heap[pos]];\n104:         uint256 leftValue = valueMapping[heap[left]];\n105:         uint256 rightValue = valueMapping[heap[right]];\n106: \n107:         if (pos >= (size / 2) && pos <= size) return; \n108:\n109:         if (posValue < leftValue || posValue < rightValue) {\n110:\n111:             if (leftValue > rightValue) { \n112:                 swap(pos, left);\n113:                 maxHeapify(left);\n114:             } else {\n115:                 swap(pos, right);\n116:                 maxHeapify(right);\n117:             }\n118:         }\n119:     }\n```\n\n4.  On observing the new state of the tree, we can see the following:\n\n*   ItemId 5 with value 20 has been temporarily removed from index 4 in the tree until a new item is inserted.\n*   ItemId 5 with value 20 is now the root of the tree.\n*   If we look at the details of the root node, we can see that although the heap and valueMapping mappings have been updated correctly, **the positionMapping still points to index 4 for itemId 5**.\n*   This issue originates because during the [maxHeapify()](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/MaxHeap.sol#L94) call, the itemId 5 is not less than either of it's child nodes as the condition in [maxHeapify()](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/MaxHeap.sol#L94) demands on Line 109 above.\n*   This is the first impact on the maxHeap data structure since it does not index as expected.\n\n*Note: to view the provided image, please see the original submission [here](https://github.com/code-423n4/2023-12-revolutionprotocol-findings/issues/363).*\n\n\n5.  Now let's say an itemId 6 with a value of 3 is created using the [insert()](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/MaxHeap.sol#L119) function. The following occurs:\n\n*   On Lines 131-133, heap\\[4] is updated to itemId 6, valueMapping\\[itemId] to 3 and positionMapping\\[itemId] to 4.\n\n```solidity\nFile: MaxHeap.sol\n130:     function insert(uint256 itemId, uint256 value) public onlyAdmin {\n131:         heap[size] = itemId;\n132:         valueMapping[itemId] = value; // Update the value mapping\n133:         positionMapping[itemId] = size; // Update the position mapping\n134: \n135:         uint256 current = size; \n136:         while (current != 0 && valueMapping[heap[current]] > valueMapping[heap[parent(current)]]) {\n137:             swap(current, parent(current));\n138:             current = parent(current);\n139:         }\n140:         size++; \n141:     }\n```\n\n6.  If we look at the new state of the tree now, we can observe that both the itemId 5 at the root node and the latest itemId 6 share the same indexes in the tree i.e. positionMapping for both being 4.\n\n*Note: to view the provided image, please see the original submission [here](https://github.com/code-423n4/2023-12-revolutionprotocol-findings/issues/363).*\n\n\n7.  Now if we call the [updateValue()](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/MaxHeap.sol#L136) function to update value for itemId 5 i.e. the root node, the following occurs:\n\n*   On Line 151, positionMapping\\[5] returns 4 as the position of the root itemId 5, which is clearly incorrect as demonstrated in point 6 above.\n*   On Line 152, oldValue stores the value of itemId 5 which is 20.\n*   Line 155 updates the valueMapping with the newValue.\n*   On Line 158, the check determines if the newValue is greater than the oldValue. Let's divide this into two cases, one for upward heapify and one for downward heapify.\n\n```solidity\nFile: MaxHeap.sol\n150:     function updateValue(uint256 itemId, uint256 newValue) public onlyAdmin {\n151:         uint256 position = positionMapping[itemId];\n152:         uint256 oldValue = valueMapping[itemId];\n153: \n154:         // Update the value in the valueMapping\n155:         valueMapping[itemId] = newValue;\n156: \n157:         // Decide whether to perform upwards or downwards heapify\n158:         if (newValue > oldValue) {\n159:             // Upwards heapify\n160:             while (position != 0 && valueMapping[heap[position]] > valueMapping[heap[parent(position)]]) {\n161:                 swap(position, parent(position));\n162:                 position = parent(position);\n163:             }\n164:         } else if (newValue < oldValue) maxHeapify(position); // Downwards heapify \n165:     }\n```\n\n8.  If we upward heapify by setting the newValue to be greater than the oldValue 20, the following occurs:\n\n*   On Line 160, the condition evaluates to false. Although expected since the root node is updated, the evaluation occurs incorrectly.\n*   The first condition checks if 4 != 0, which is true. This condition should actually have evaluated to false since the root node should have position/index = 0\n*   The second condition evaluates to false. This is because the valueMapping is accessing the value for itemId 6 and comparing it to its parent itemId 2.\n*   Due to this, although we do not enter the if block, the evaluation occurs incorrectly.\n\n```solidity\nFile: MaxHeap.sol\n159:             // Upwards heapify\n160:             while (position != 0 && valueMapping[heap[position]] > valueMapping[heap[parent(position)]]) {\n161:                 swap(position, parent(position));\n162:                 position = parent(position);\n163:             }\n```\n\n9.  If we downward heapify by setting the newValue (let's say 13) to be lesser than the oldValue 20, the following occurs:\n\n*   On Line 164, we enter the else if block and make an internal call to [maxHeapify()](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/MaxHeap.sol#L94) with position = 4 as argument instead of 0, which is incorrect.\n*   On Lines 101-102, left and right are set to indexes 9 and 10. This is incorrect and should have been 1 and 2 (children of the root node we are updating) instead of itemId 6's children.\n*   On Lines 103-105, itemId 6's values are retrieved i.e. 3, 0, 0 respectively.\n*   on Line 107, the condition evaluates to true since 4 >= 2 (i.e. size/2 = 5/2) and 4 <= 5 evaluate to true. Due to this we return early and the downward heapify does not occur.\n*   The impact here is that itemId 5 in the root now has a value of 13, which is **smaller than it's child node's values** i.e. 20 and 15 respectively. This not only breaks the max heap tree but also the binary tree's spec.\n*   Now if [extractMax()](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/MaxHeap.sol#L156) is called, the root node itemId 5 with value 13 is popped instead of the expected itemId 2, which has a value of 20 and is the highest valued element.\n\n```solidity\nFile: MaxHeap.sol\n164:         } else if (newValue < oldValue) maxHeapify(position); // Downwards heapify \n```\n\n[maxHeapify()](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/MaxHeap.sol#L94) function:\n\n```solidity\nFile: MaxHeap.sol\n099:     function maxHeapify(uint256 pos) internal {\n100:         uint256 left = 2 * pos + 1; \n101:         uint256 right = 2 * pos + 2; \n102: \n103:         uint256 posValue = valueMapping[heap[pos]];\n104:         uint256 leftValue = valueMapping[heap[left]];\n105:         uint256 rightValue = valueMapping[heap[right]];\n106: \n107:         if (pos >= (size / 2) && pos <= size) return; \n108:\n109:         if (posValue < leftValue || posValue < rightValue) {\n110:\n111:             if (leftValue > rightValue) { \n112:                 swap(pos, left);\n113:                 maxHeapify(left);\n114:             } else {\n115:                 swap(pos, right);\n116:                 maxHeapify(right);\n117:             }\n118:         }\n119:     }\n```\n\n10. Here is how the max heap binary tree looks finally.\n\n*Note: to view the provided image, please see the original submission [here](https://github.com/code-423n4/2023-12-revolutionprotocol-findings/issues/363).*\n\n\n**Some points to note about this issue:**\n\n1.  The downward heapifying issue has been demonstrated to display an additional impact to the already existing impact of incorrect indexing and max heap tree spec violation.\n2.  Although downward heapifying does not work in the codebase currently since downvoting does not exist, it can be introduced in the future based on sponsor's comments (see below). This would break the protocol functionality as demonstrated in this issue. This is because the data structure can change its admin to a future CultureIndex contract that supports downvoting but the CultureIndex cannot start using a new data structure since the max heap has existing data stored in it.\n3.  Even if there is no concept of downvoting, MaxHeap is expected to fully implement the maxHeap spec and functionality requirements (see below), which it does not implement correctly.\n\n*Note: to view the provided image, please see the original submission [here](https://github.com/code-423n4/2023-12-revolutionprotocol-findings/issues/363).*\n\n### Recommended Mitigation Steps\n\nThe most straightforward solution to this would be to consider this type of case in the [extractMax()](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/MaxHeap.sol#L156) function itself.\n\nThe following check ensures that if the last element is equal to the parent and it is greater than equal to the right index of the root node (i.e. index 2), we update the positionMapping correctly to 0. This check needs to be placed after [this statement](https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/MaxHeap.sol#L160).\n\n```solidity\nif (heap[size] == parent(size) && heap[size] >= heap[2]) {\n    positionMapping[heap[0]] = 0;\n}\n```\n\n**[rocketman-21 (Revolution) commented](https://github.com/code-423n4/2023-12-revolutionprotocol-findings/issues/363#issuecomment-1885810158):**\n > Not updating the `positionMapping` after extract max was an oversight on my end, I think this is legit.\n> \n> New extract max:\n> \n> ```\n>     /// @notice Extract the maximum element from the heap\n>     /// @dev The function will revert if the heap is empty\n>     /// The values for the popped node are removed from the items mapping\n>     /// @return The maximum element from the heap\n>     function extractMax() external onlyAdmin returns (uint256, uint256) {\n>         if (size == 0) revert EMPTY_HEAP();\n> \n>         // itemId of the node with the max value at the root of the heap\n>         uint256 popped = heap[0];\n> \n>         // get priority value of the popped node\n>         uint256 returnValue = items[popped].value;\n> \n>         // remove popped node values from the items mapping for the popped node\n>         delete items[popped];\n> \n>         // set the root node to the farthest leaf node and decrement the size\n>         heap[0] = heap[--size];\n> \n>         // update the heap index for the previously farthest leaf node\n>         items[heap[0]].heapIndex = 0;\n> \n>         //delete the farthest leaf node\n>         delete heap[size];\n> \n>         //maintain heap property\n>         maxHeapify(0);\n> \n>         return (popped, returnValue);\n>     }\n> ```\n> \n> https://github.com/collectivexyz/revolution-protocol/blob/941719c8f3c168d6d53e38528336ec6cf5df17c5/packages/revolution/src/culture-index/MaxHeap.sol#L187\n\n**[0xTheC0der (Judge) commented](https://github.com/code-423n4/2023-12-revolutionprotocol-findings/issues/363#issuecomment-1887545762):**\nAlthough I acknowledge that this is a good and severe find, any PoC so far was only focused on `MaxHeap` itself and not its current usage through the main entry points of the protocol. Therefore, Medium severity seems appropriate since further impacts on the main functionality of the protocol need to be proven.\n\n_Note: See full discussion [here](https://github.com/code-423n4/2023-12-revolutionprotocol-findings/issues/363)._\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-12-revolutionprotocol",
  "Code": [
    {
      "filename": "packages/revolution/src/MaxHeap.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.22;\n\nimport { Ownable2StepUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport { IRevolutionBuilder } from \"./interfaces/IRevolutionBuilder.sol\";\n\nimport { UUPS } from \"./libs/proxy/UUPS.sol\";\nimport { VersionedContract } from \"./version/VersionedContract.sol\";\n\n/// @title MaxHeap implementation in Solidity\n/// @dev This contract implements a Max Heap data structure with basic operations\n/// @author Written by rocketman and gpt4\ncontract MaxHeap is VersionedContract, UUPS, Ownable2StepUpgradeable, ReentrancyGuardUpgradeable {\n    /// @notice The parent contract that is allowed to update the data store\n    address public admin;\n\n    ///                                                          ///\n    ///                         IMMUTABLES                       ///\n    ///                                                          ///\n\n    /// @notice The contract upgrade manager\n    IRevolutionBuilder private immutable manager;\n\n    ///                                                          ///\n    ///                         CONSTRUCTOR                      ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    constructor(address _manager) payable initializer {\n        manager = IRevolutionBuilder(_manager);\n    }\n\n    ///                                                          ///\n    ///                          MODIFIERS                       ///\n    ///                                                          ///\n\n    /**\n     * @notice Require that the minter has not been locked.\n     */\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"Sender is not the admin\");\n        _;\n    }\n\n    ///                                                          ///\n    ///                         INITIALIZER                      ///\n    ///                                                          ///\n\n    /**\n     * @notice Initializes the maxheap contract\n     * @param _initialOwner The initial owner of the contract\n     * @param _admin The contract that is allowed to update the data store\n     */\n    function initialize(address _initialOwner, address _admin) public initializer {\n        require(msg.sender == address(manager), \"Only manager can initialize\");\n\n        admin = _admin;\n\n        __Ownable_init(_initialOwner);\n        __ReentrancyGuard_init();\n    }\n\n    /// @notice Struct to represent an item in the heap by it's ID\n    mapping(uint256 => uint256) public heap;\n\n    uint256 public size = 0;\n\n    /// @notice Mapping to keep track of the value of an item in the heap\n    mapping(uint256 => uint256) public valueMapping;\n\n    /// @notice Mapping to keep track of the position of an item in the heap\n    mapping(uint256 => uint256) public positionMapping;\n\n    /// @notice Get the parent index of a given position\n    /// @param pos The position for which to find the parent\n    /// @return The index of the parent node\n    function parent(uint256 pos) private pure returns (uint256) {\n        require(pos != 0, \"Position should not be zero\");\n        return (pos - 1) / 2;\n    }\n\n    /// @notice Swap two nodes in the heap\n    /// @param fpos The position of the first node\n    /// @param spos The position of the second node\n    function swap(uint256 fpos, uint256 spos) private {\n        (heap[fpos], heap[spos]) = (heap[spos], heap[fpos]);\n        (positionMapping[heap[fpos]], positionMapping[heap[spos]]) = (fpos, spos);\n    }\n\n    /// @notice Reheapify the heap starting at a given position\n    /// @dev This ensures that the heap property is maintained\n    /// @param pos The starting position for the heapify operation\n    function maxHeapify(uint256 pos) internal {\n        uint256 left = 2 * pos + 1;\n        uint256 right = 2 * pos + 2;\n\n        uint256 posValue = valueMapping[heap[pos]];\n        uint256 leftValue = valueMapping[heap[left]];\n        uint256 rightValue = valueMapping[heap[right]];\n\n        if (pos >= (size / 2) && pos <= size) return;\n\n        if (posValue < leftValue || posValue < rightValue) {\n            if (leftValue > rightValue) {\n                swap(pos, left);\n                maxHeapify(left);\n            } else {\n                swap(pos, right);\n                maxHeapify(right);\n            }\n        }\n    }\n\n    /// @notice Insert an element into the heap\n    /// @dev The function will revert if the heap is full\n    /// @param itemId The item ID to insert\n    /// @param value The value to insert\n    function insert(uint256 itemId, uint256 value) public onlyAdmin {\n        heap[size] = itemId;\n        valueMapping[itemId] = value; // Update the value mapping\n        positionMapping[itemId] = size; // Update the position mapping\n\n        uint256 current = size;\n        while (current != 0 && valueMapping[heap[current]] > valueMapping[heap[parent(current)]]) {\n            swap(current, parent(current));\n            current = parent(current);\n        }\n        size++;\n    }\n\n    /// @notice Update the value of an existing item in the heap\n    /// @param itemId The item ID whose vote count needs to be updated\n    /// @param newValue The new value for the item\n    /// @dev This function adjusts the heap to maintain the max-heap property after updating the vote count\n    function updateValue(uint256 itemId, uint256 newValue) public onlyAdmin {\n        uint256 position = positionMapping[itemId];\n        uint256 oldValue = valueMapping[itemId];\n\n        // Update the value in the valueMapping\n        valueMapping[itemId] = newValue;\n\n        // Decide whether to perform upwards or downwards heapify\n        if (newValue > oldValue) {\n            // Upwards heapify\n            while (position != 0 && valueMapping[heap[position]] > valueMapping[heap[parent(position)]]) {\n                swap(position, parent(position));\n                position = parent(position);\n            }\n        } else if (newValue < oldValue) maxHeapify(position); // Downwards heapify\n    }\n\n    /// @notice Extract the maximum element from the heap\n    /// @dev The function will revert if the heap is empty\n    /// @return The maximum element from the heap\n    function extractMax() external onlyAdmin returns (uint256, uint256) {\n        require(size > 0, \"Heap is empty\");\n\n        uint256 popped = heap[0];\n        heap[0] = heap[--size];\n        maxHeapify(0);\n\n        return (popped, valueMapping[popped]);\n    }\n\n    /// @notice Get the maximum element from the heap\n    /// @dev The function will revert if the heap is empty\n    /// @return The maximum element from the heap\n    function getMax() public view returns (uint256, uint256) {\n        require(size > 0, \"Heap is empty\");\n        return (heap[0], valueMapping[heap[0]]);\n    }\n\n    ///                                                          ///\n    ///                     MAX HEAP UPGRADE                     ///\n    ///                                                          ///\n\n    /// @notice Ensures the caller is authorized to upgrade the contract and that the new implementation is valid\n    /// @dev This function is called in `upgradeTo` & `upgradeToAndCall`\n    /// @param _newImpl The new implementation address\n    function _authorizeUpgrade(address _newImpl) internal view override onlyOwner {\n        // Ensure the new implementation is a registered upgrade\n        if (!manager.isRegisteredUpgrade(_getImplementation(), _newImpl)) revert INVALID_UPGRADE(_newImpl);\n    }\n}"
    },
    {
      "filename": "packages/revolution/src/MaxHeap.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.22;\n\nimport { Ownable2StepUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport { IRevolutionBuilder } from \"./interfaces/IRevolutionBuilder.sol\";\n\nimport { UUPS } from \"./libs/proxy/UUPS.sol\";\nimport { VersionedContract } from \"./version/VersionedContract.sol\";\n\n/// @title MaxHeap implementation in Solidity\n/// @dev This contract implements a Max Heap data structure with basic operations\n/// @author Written by rocketman and gpt4\ncontract MaxHeap is VersionedContract, UUPS, Ownable2StepUpgradeable, ReentrancyGuardUpgradeable {\n    /// @notice The parent contract that is allowed to update the data store\n    address public admin;\n\n    ///                                                          ///\n    ///                         IMMUTABLES                       ///\n    ///                                                          ///\n\n    /// @notice The contract upgrade manager\n    IRevolutionBuilder private immutable manager;\n\n    ///                                                          ///\n    ///                         CONSTRUCTOR                      ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    constructor(address _manager) payable initializer {\n        manager = IRevolutionBuilder(_manager);\n    }\n\n    ///                                                          ///\n    ///                          MODIFIERS                       ///\n    ///                                                          ///\n\n    /**\n     * @notice Require that the minter has not been locked.\n     */\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"Sender is not the admin\");\n        _;\n    }\n\n    ///                                                          ///\n    ///                         INITIALIZER                      ///\n    ///                                                          ///\n\n    /**\n     * @notice Initializes the maxheap contract\n     * @param _initialOwner The initial owner of the contract\n     * @param _admin The contract that is allowed to update the data store\n     */\n    function initialize(address _initialOwner, address _admin) public initializer {\n        require(msg.sender == address(manager), \"Only manager can initialize\");\n\n        admin = _admin;\n\n        __Ownable_init(_initialOwner);\n        __ReentrancyGuard_init();\n    }\n\n    /// @notice Struct to represent an item in the heap by it's ID\n    mapping(uint256 => uint256) public heap;\n\n    uint256 public size = 0;\n\n    /// @notice Mapping to keep track of the value of an item in the heap\n    mapping(uint256 => uint256) public valueMapping;\n\n    /// @notice Mapping to keep track of the position of an item in the heap\n    mapping(uint256 => uint256) public positionMapping;\n\n    /// @notice Get the parent index of a given position\n    /// @param pos The position for which to find the parent\n    /// @return The index of the parent node\n    function parent(uint256 pos) private pure returns (uint256) {\n        require(pos != 0, \"Position should not be zero\");\n        return (pos - 1) / 2;\n    }\n\n    /// @notice Swap two nodes in the heap\n    /// @param fpos The position of the first node\n    /// @param spos The position of the second node\n    function swap(uint256 fpos, uint256 spos) private {\n        (heap[fpos], heap[spos]) = (heap[spos], heap[fpos]);\n        (positionMapping[heap[fpos]], positionMapping[heap[spos]]) = (fpos, spos);\n    }\n\n    /// @notice Reheapify the heap starting at a given position\n    /// @dev This ensures that the heap property is maintained\n    /// @param pos The starting position for the heapify operation\n    function maxHeapify(uint256 pos) internal {\n        uint256 left = 2 * pos + 1;\n        uint256 right = 2 * pos + 2;\n\n        uint256 posValue = valueMapping[heap[pos]];\n        uint256 leftValue = valueMapping[heap[left]];\n        uint256 rightValue = valueMapping[heap[right]];\n\n        if (pos >= (size / 2) && pos <= size) return;\n\n        if (posValue < leftValue || posValue < rightValue) {\n            if (leftValue > rightValue) {\n                swap(pos, left);\n                maxHeapify(left);\n            } else {\n                swap(pos, right);\n                maxHeapify(right);\n            }\n        }\n    }\n\n    /// @notice Insert an element into the heap\n    /// @dev The function will revert if the heap is full\n    /// @param itemId The item ID to insert\n    /// @param value The value to insert\n    function insert(uint256 itemId, uint256 value) public onlyAdmin {\n        heap[size] = itemId;\n        valueMapping[itemId] = value; // Update the value mapping\n        positionMapping[itemId] = size; // Update the position mapping\n\n        uint256 current = size;\n        while (current != 0 && valueMapping[heap[current]] > valueMapping[heap[parent(current)]]) {\n            swap(current, parent(current));\n            current = parent(current);\n        }\n        size++;\n    }\n\n    /// @notice Update the value of an existing item in the heap\n    /// @param itemId The item ID whose vote count needs to be updated\n    /// @param newValue The new value for the item\n    /// @dev This function adjusts the heap to maintain the max-heap property after updating the vote count\n    function updateValue(uint256 itemId, uint256 newValue) public onlyAdmin {\n        uint256 position = positionMapping[itemId];\n        uint256 oldValue = valueMapping[itemId];\n\n        // Update the value in the valueMapping\n        valueMapping[itemId] = newValue;\n\n        // Decide whether to perform upwards or downwards heapify\n        if (newValue > oldValue) {\n            // Upwards heapify\n            while (position != 0 && valueMapping[heap[position]] > valueMapping[heap[parent(position)]]) {\n                swap(position, parent(position));\n                position = parent(position);\n            }\n        } else if (newValue < oldValue) maxHeapify(position); // Downwards heapify\n    }\n\n    /// @notice Extract the maximum element from the heap\n    /// @dev The function will revert if the heap is empty\n    /// @return The maximum element from the heap\n    function extractMax() external onlyAdmin returns (uint256, uint256) {\n        require(size > 0, \"Heap is empty\");\n\n        uint256 popped = heap[0];\n        heap[0] = heap[--size];\n        maxHeapify(0);\n\n        return (popped, valueMapping[popped]);\n    }\n\n    /// @notice Get the maximum element from the heap\n    /// @dev The function will revert if the heap is empty\n    /// @return The maximum element from the heap\n    function getMax() public view returns (uint256, uint256) {\n        require(size > 0, \"Heap is empty\");\n        return (heap[0], valueMapping[heap[0]]);\n    }\n\n    ///                                                          ///\n    ///                     MAX HEAP UPGRADE                     ///\n    ///                                                          ///\n\n    /// @notice Ensures the caller is authorized to upgrade the contract and that the new implementation is valid\n    /// @dev This function is called in `upgradeTo` & `upgradeToAndCall`\n    /// @param _newImpl The new implementation address\n    function _authorizeUpgrade(address _newImpl) internal view override onlyOwner {\n        // Ensure the new implementation is a registered upgrade\n        if (!manager.isRegisteredUpgrade(_getImplementation(), _newImpl)) revert INVALID_UPGRADE(_newImpl);\n    }\n}"
    },
    {
      "filename": "packages/revolution/src/MaxHeap.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.22;\n\nimport { Ownable2StepUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport { IRevolutionBuilder } from \"./interfaces/IRevolutionBuilder.sol\";\n\nimport { UUPS } from \"./libs/proxy/UUPS.sol\";\nimport { VersionedContract } from \"./version/VersionedContract.sol\";\n\n/// @title MaxHeap implementation in Solidity\n/// @dev This contract implements a Max Heap data structure with basic operations\n/// @author Written by rocketman and gpt4\ncontract MaxHeap is VersionedContract, UUPS, Ownable2StepUpgradeable, ReentrancyGuardUpgradeable {\n    /// @notice The parent contract that is allowed to update the data store\n    address public admin;\n\n    ///                                                          ///\n    ///                         IMMUTABLES                       ///\n    ///                                                          ///\n\n    /// @notice The contract upgrade manager\n    IRevolutionBuilder private immutable manager;\n\n    ///                                                          ///\n    ///                         CONSTRUCTOR                      ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    constructor(address _manager) payable initializer {\n        manager = IRevolutionBuilder(_manager);\n    }\n\n    ///                                                          ///\n    ///                          MODIFIERS                       ///\n    ///                                                          ///\n\n    /**\n     * @notice Require that the minter has not been locked.\n     */\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"Sender is not the admin\");\n        _;\n    }\n\n    ///                                                          ///\n    ///                         INITIALIZER                      ///\n    ///                                                          ///\n\n    /**\n     * @notice Initializes the maxheap contract\n     * @param _initialOwner The initial owner of the contract\n     * @param _admin The contract that is allowed to update the data store\n     */\n    function initialize(address _initialOwner, address _admin) public initializer {\n        require(msg.sender == address(manager), \"Only manager can initialize\");\n\n        admin = _admin;\n\n        __Ownable_init(_initialOwner);\n        __ReentrancyGuard_init();\n    }\n\n    /// @notice Struct to represent an item in the heap by it's ID\n    mapping(uint256 => uint256) public heap;\n\n    uint256 public size = 0;\n\n    /// @notice Mapping to keep track of the value of an item in the heap\n    mapping(uint256 => uint256) public valueMapping;\n\n    /// @notice Mapping to keep track of the position of an item in the heap\n    mapping(uint256 => uint256) public positionMapping;\n\n    /// @notice Get the parent index of a given position\n    /// @param pos The position for which to find the parent\n    /// @return The index of the parent node\n    function parent(uint256 pos) private pure returns (uint256) {\n        require(pos != 0, \"Position should not be zero\");\n        return (pos - 1) / 2;\n    }\n\n    /// @notice Swap two nodes in the heap\n    /// @param fpos The position of the first node\n    /// @param spos The position of the second node\n    function swap(uint256 fpos, uint256 spos) private {\n        (heap[fpos], heap[spos]) = (heap[spos], heap[fpos]);\n        (positionMapping[heap[fpos]], positionMapping[heap[spos]]) = (fpos, spos);\n    }\n\n    /// @notice Reheapify the heap starting at a given position\n    /// @dev This ensures that the heap property is maintained\n    /// @param pos The starting position for the heapify operation\n    function maxHeapify(uint256 pos) internal {\n        uint256 left = 2 * pos + 1;\n        uint256 right = 2 * pos + 2;\n\n        uint256 posValue = valueMapping[heap[pos]];\n        uint256 leftValue = valueMapping[heap[left]];\n        uint256 rightValue = valueMapping[heap[right]];\n\n        if (pos >= (size / 2) && pos <= size) return;\n\n        if (posValue < leftValue || posValue < rightValue) {\n            if (leftValue > rightValue) {\n                swap(pos, left);\n                maxHeapify(left);\n            } else {\n                swap(pos, right);\n                maxHeapify(right);\n            }\n        }\n    }\n\n    /// @notice Insert an element into the heap\n    /// @dev The function will revert if the heap is full\n    /// @param itemId The item ID to insert\n    /// @param value The value to insert\n    function insert(uint256 itemId, uint256 value) public onlyAdmin {\n        heap[size] = itemId;\n        valueMapping[itemId] = value; // Update the value mapping\n        positionMapping[itemId] = size; // Update the position mapping\n\n        uint256 current = size;\n        while (current != 0 && valueMapping[heap[current]] > valueMapping[heap[parent(current)]]) {\n            swap(current, parent(current));\n            current = parent(current);\n        }\n        size++;\n    }\n\n    /// @notice Update the value of an existing item in the heap\n    /// @param itemId The item ID whose vote count needs to be updated\n    /// @param newValue The new value for the item\n    /// @dev This function adjusts the heap to maintain the max-heap property after updating the vote count\n    function updateValue(uint256 itemId, uint256 newValue) public onlyAdmin {\n        uint256 position = positionMapping[itemId];\n        uint256 oldValue = valueMapping[itemId];\n\n        // Update the value in the valueMapping\n        valueMapping[itemId] = newValue;\n\n        // Decide whether to perform upwards or downwards heapify\n        if (newValue > oldValue) {\n            // Upwards heapify\n            while (position != 0 && valueMapping[heap[position]] > valueMapping[heap[parent(position)]]) {\n                swap(position, parent(position));\n                position = parent(position);\n            }\n        } else if (newValue < oldValue) maxHeapify(position); // Downwards heapify\n    }\n\n    /// @notice Extract the maximum element from the heap\n    /// @dev The function will revert if the heap is empty\n    /// @return The maximum element from the heap\n    function extractMax() external onlyAdmin returns (uint256, uint256) {\n        require(size > 0, \"Heap is empty\");\n\n        uint256 popped = heap[0];\n        heap[0] = heap[--size];\n        maxHeapify(0);\n\n        return (popped, valueMapping[popped]);\n    }\n\n    /// @notice Get the maximum element from the heap\n    /// @dev The function will revert if the heap is empty\n    /// @return The maximum element from the heap\n    function getMax() public view returns (uint256, uint256) {\n        require(size > 0, \"Heap is empty\");\n        return (heap[0], valueMapping[heap[0]]);\n    }\n\n    ///                                                          ///\n    ///                     MAX HEAP UPGRADE                     ///\n    ///                                                          ///\n\n    /// @notice Ensures the caller is authorized to upgrade the contract and that the new implementation is valid\n    /// @dev This function is called in `upgradeTo` & `upgradeToAndCall`\n    /// @param _newImpl The new implementation address\n    function _authorizeUpgrade(address _newImpl) internal view override onlyOwner {\n        // Ensure the new implementation is a registered upgrade\n        if (!manager.isRegisteredUpgrade(_getImplementation(), _newImpl)) revert INVALID_UPGRADE(_newImpl);\n    }\n}"
    },
    {
      "filename": "packages/revolution/src/MaxHeap.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.22;\n\nimport { Ownable2StepUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport { IRevolutionBuilder } from \"./interfaces/IRevolutionBuilder.sol\";\n\nimport { UUPS } from \"./libs/proxy/UUPS.sol\";\nimport { VersionedContract } from \"./version/VersionedContract.sol\";\n\n/// @title MaxHeap implementation in Solidity\n/// @dev This contract implements a Max Heap data structure with basic operations\n/// @author Written by rocketman and gpt4\ncontract MaxHeap is VersionedContract, UUPS, Ownable2StepUpgradeable, ReentrancyGuardUpgradeable {\n    /// @notice The parent contract that is allowed to update the data store\n    address public admin;\n\n    ///                                                          ///\n    ///                         IMMUTABLES                       ///\n    ///                                                          ///\n\n    /// @notice The contract upgrade manager\n    IRevolutionBuilder private immutable manager;\n\n    ///                                                          ///\n    ///                         CONSTRUCTOR                      ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    constructor(address _manager) payable initializer {\n        manager = IRevolutionBuilder(_manager);\n    }\n\n    ///                                                          ///\n    ///                          MODIFIERS                       ///\n    ///                                                          ///\n\n    /**\n     * @notice Require that the minter has not been locked.\n     */\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"Sender is not the admin\");\n        _;\n    }\n\n    ///                                                          ///\n    ///                         INITIALIZER                      ///\n    ///                                                          ///\n\n    /**\n     * @notice Initializes the maxheap contract\n     * @param _initialOwner The initial owner of the contract\n     * @param _admin The contract that is allowed to update the data store\n     */\n    function initialize(address _initialOwner, address _admin) public initializer {\n        require(msg.sender == address(manager), \"Only manager can initialize\");\n\n        admin = _admin;\n\n        __Ownable_init(_initialOwner);\n        __ReentrancyGuard_init();\n    }\n\n    /// @notice Struct to represent an item in the heap by it's ID\n    mapping(uint256 => uint256) public heap;\n\n    uint256 public size = 0;\n\n    /// @notice Mapping to keep track of the value of an item in the heap\n    mapping(uint256 => uint256) public valueMapping;\n\n    /// @notice Mapping to keep track of the position of an item in the heap\n    mapping(uint256 => uint256) public positionMapping;\n\n    /// @notice Get the parent index of a given position\n    /// @param pos The position for which to find the parent\n    /// @return The index of the parent node\n    function parent(uint256 pos) private pure returns (uint256) {\n        require(pos != 0, \"Position should not be zero\");\n        return (pos - 1) / 2;\n    }\n\n    /// @notice Swap two nodes in the heap\n    /// @param fpos The position of the first node\n    /// @param spos The position of the second node\n    function swap(uint256 fpos, uint256 spos) private {\n        (heap[fpos], heap[spos]) = (heap[spos], heap[fpos]);\n        (positionMapping[heap[fpos]], positionMapping[heap[spos]]) = (fpos, spos);\n    }\n\n    /// @notice Reheapify the heap starting at a given position\n    /// @dev This ensures that the heap property is maintained\n    /// @param pos The starting position for the heapify operation\n    function maxHeapify(uint256 pos) internal {\n        uint256 left = 2 * pos + 1;\n        uint256 right = 2 * pos + 2;\n\n        uint256 posValue = valueMapping[heap[pos]];\n        uint256 leftValue = valueMapping[heap[left]];\n        uint256 rightValue = valueMapping[heap[right]];\n\n        if (pos >= (size / 2) && pos <= size) return;\n\n        if (posValue < leftValue || posValue < rightValue) {\n            if (leftValue > rightValue) {\n                swap(pos, left);\n                maxHeapify(left);\n            } else {\n                swap(pos, right);\n                maxHeapify(right);\n            }\n        }\n    }\n\n    /// @notice Insert an element into the heap\n    /// @dev The function will revert if the heap is full\n    /// @param itemId The item ID to insert\n    /// @param value The value to insert\n    function insert(uint256 itemId, uint256 value) public onlyAdmin {\n        heap[size] = itemId;\n        valueMapping[itemId] = value; // Update the value mapping\n        positionMapping[itemId] = size; // Update the position mapping\n\n        uint256 current = size;\n        while (current != 0 && valueMapping[heap[current]] > valueMapping[heap[parent(current)]]) {\n            swap(current, parent(current));\n            current = parent(current);\n        }\n        size++;\n    }\n\n    /// @notice Update the value of an existing item in the heap\n    /// @param itemId The item ID whose vote count needs to be updated\n    /// @param newValue The new value for the item\n    /// @dev This function adjusts the heap to maintain the max-heap property after updating the vote count\n    function updateValue(uint256 itemId, uint256 newValue) public onlyAdmin {\n        uint256 position = positionMapping[itemId];\n        uint256 oldValue = valueMapping[itemId];\n\n        // Update the value in the valueMapping\n        valueMapping[itemId] = newValue;\n\n        // Decide whether to perform upwards or downwards heapify\n        if (newValue > oldValue) {\n            // Upwards heapify\n            while (position != 0 && valueMapping[heap[position]] > valueMapping[heap[parent(position)]]) {\n                swap(position, parent(position));\n                position = parent(position);\n            }\n        } else if (newValue < oldValue) maxHeapify(position); // Downwards heapify\n    }\n\n    /// @notice Extract the maximum element from the heap\n    /// @dev The function will revert if the heap is empty\n    /// @return The maximum element from the heap\n    function extractMax() external onlyAdmin returns (uint256, uint256) {\n        require(size > 0, \"Heap is empty\");\n\n        uint256 popped = heap[0];\n        heap[0] = heap[--size];\n        maxHeapify(0);\n\n        return (popped, valueMapping[popped]);\n    }\n\n    /// @notice Get the maximum element from the heap\n    /// @dev The function will revert if the heap is empty\n    /// @return The maximum element from the heap\n    function getMax() public view returns (uint256, uint256) {\n        require(size > 0, \"Heap is empty\");\n        return (heap[0], valueMapping[heap[0]]);\n    }\n\n    ///                                                          ///\n    ///                     MAX HEAP UPGRADE                     ///\n    ///                                                          ///\n\n    /// @notice Ensures the caller is authorized to upgrade the contract and that the new implementation is valid\n    /// @dev This function is called in `upgradeTo` & `upgradeToAndCall`\n    /// @param _newImpl The new implementation address\n    function _authorizeUpgrade(address _newImpl) internal view override onlyOwner {\n        // Ensure the new implementation is a registered upgrade\n        if (!manager.isRegisteredUpgrade(_getImplementation(), _newImpl)) revert INVALID_UPGRADE(_newImpl);\n    }\n}"
    },
    {
      "filename": "packages/revolution/src/MaxHeap.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.22;\n\nimport { Ownable2StepUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport { IRevolutionBuilder } from \"./interfaces/IRevolutionBuilder.sol\";\n\nimport { UUPS } from \"./libs/proxy/UUPS.sol\";\nimport { VersionedContract } from \"./version/VersionedContract.sol\";\n\n/// @title MaxHeap implementation in Solidity\n/// @dev This contract implements a Max Heap data structure with basic operations\n/// @author Written by rocketman and gpt4\ncontract MaxHeap is VersionedContract, UUPS, Ownable2StepUpgradeable, ReentrancyGuardUpgradeable {\n    /// @notice The parent contract that is allowed to update the data store\n    address public admin;\n\n    ///                                                          ///\n    ///                         IMMUTABLES                       ///\n    ///                                                          ///\n\n    /// @notice The contract upgrade manager\n    IRevolutionBuilder private immutable manager;\n\n    ///                                                          ///\n    ///                         CONSTRUCTOR                      ///\n    ///                                                          ///\n\n    /// @param _manager The contract upgrade manager address\n    constructor(address _manager) payable initializer {\n        manager = IRevolutionBuilder(_manager);\n    }\n\n    ///                                                          ///\n    ///                          MODIFIERS                       ///\n    ///                                                          ///\n\n    /**\n     * @notice Require that the minter has not been locked.\n     */\n    modifier onlyAdmin()"
    }
  ]
}