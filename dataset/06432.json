{
  "Title": "[M-02] Slippage controls for calling `bHermes` contract's `ERC4626DepositOnly.deposit` and `ERC4626DepositOnly.mint` functions are missing",
  "Content": "\n[EIPS](<https://eips.ethereum.org/EIPS/eip-4626#security-considerations>) mentions that \"if implementors intend to support EOA account access directly, they should consider adding an additional function call for `deposit`/`mint`/`withdraw`/`redeem` with the means to accommodate slippage loss or unexpected deposit/withdrawal limits, since they have no other means to revert the transaction if the exact output amount is not achieved.\"\n\nUsing the `bHermes` contract that inherits the `ERC4626DepositOnly` contract, EOAs can call the `ERC4626DepositOnly.deposit` and `ERC4626DepositOnly.mint` functions directly. However, because no slippage controls can be specified when calling these functions, these function's `shares` and `assets` outputs can be less than expected to these EOAs.\n\n<https://github.com/code-423n4/2023-05-maia/blob/53c7fe9d5e55754960eafe936b6cb592773d614c/src/erc-4626/ERC4626DepositOnly.sol#L32-L44>\n\n```solidity\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n        // Need to transfer before minting or ERC777s could reenter.\n        address(asset).safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n```\n\n<https://github.com/code-423n4/2023-05-maia/blob/53c7fe9d5e55754960eafe936b6cb592773d614c/src/erc-4626/ERC4626DepositOnly.sol#L47-L58>\n\n```solidity\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        address(asset).safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n```\n\nIn contrast, the `UlyssesRouter.addLiquidity` function does control the slippage by including the `minOutput` input and executing `amount = ulysses.deposit(amount, msg.sender)` and `if (amount < minOutput) revert OutputTooLow()`. Although such slippage control for an ERC-4626 vault exists in this protocol's other contract, it does not exist in the `bHermes` contract. As a result, EOAs can mint less `bHermes` shares than expected when calling the `bHermes` contract's `ERC4626DepositOnly.deposit` function and send and burn more `HERMES` tokens than expected when calling the `bHermes` contract's `ERC4626DepositOnly.mint` function.\n\n<https://github.com/code-423n4/2023-05-maia/blob/53c7fe9d5e55754960eafe936b6cb592773d614c/src/ulysses-amm/UlyssesRouter.sol#L49-L56>\n\n```solidity\n    function addLiquidity(uint256 amount, uint256 minOutput, uint256 poolId) external returns (uint256) {\n        UlyssesPool ulysses = getUlyssesLP(poolId);\n\n        amount = ulysses.deposit(amount, msg.sender);\n\n        if (amount < minOutput) revert OutputTooLow();\n        return amount;\n    }\n```\n\n### Proof of Concept\n\nThe following steps can occur for the described scenario involving the `bHermes` contract's `ERC4626DepositOnly.mint` function. The case involving the `bHermes` contract's `ERC4626DepositOnly.deposit` function is similar to this:\n\n1. Alice wants to mint 1e18 `bHermes` shares in exchange for sending and burning 1e18 `HERMES` tokens.\n2. Alice calls the `bHermes` contract's `ERC4626DepositOnly.mint` function with the `shares` input being 1e18.\n3. Yet, such `ERC4626DepositOnly.mint` function call causes 1.2e18 `HERMES` tokens to be transferred from Alice.\n4. Alice unexpectedly sends, burns, and loses 0.2e18 more `HERMES` tokens than expected for minting 1e18 `bHermes` shares.\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\nThe `bHermes` contract can be updated to include a `deposit` function that allows `msg.sender` to specify the minimum `bHermes` shares to be minted for calling the corresponding `ERC4626DepositOnly.deposit` function; calling such `bHermes.deposit` function should revert if the corresponding `ERC4626DepositOnly.deposit` function's `shares` output is less than the specified minimum `bHermes` shares to be minted. Similarly, the `bHermes` contract can also include a `mint` function that allows `msg.sender` to specify the maximum `HERMES` tokens to be sent for calling the corresponding `ERC4626DepositOnly.mint` function; calling such `bHermes.mint` function should revert if the corresponding `ERC4626DepositOnly.mint` function's `assets` output is more than the specified maximum `HERMES` tokens to be sent.\n\n**[0xLightt (Maia) acknowledged](https://github.com/code-423n4/2023-05-maia-findings/issues/901#issuecomment-1633189718)**\n\n**[0xLightt (Maia) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/901#issuecomment-1655667861):**\n > The reason this is not being addressed directly in this contract is we prefer to use a periphery contract like a generalized ERC4626 router to account for slippage and deadlines.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/erc-4626/ERC4626DepositOnly.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IERC4626DepositOnly} from \"./interfaces/IERC4626DepositOnly.sol\";\n\n/// @title Minimal Deposit Only ERC4626 tokenized Vault implementation\n/// @author Maia DAO (https://github.com/Maia-DAO)\nabstract contract ERC4626DepositOnly is ERC20, IERC4626DepositOnly {\n    using SafeTransferLib for address;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    ERC20 public immutable asset;\n\n    constructor(ERC20 _asset, string memory _name, string memory _symbol) ERC20(_name, _symbol, _asset.decimals()) {\n        asset = _asset;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626DepositOnly\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n        // Need to transfer before minting or ERC777s could reenter.\n        address(asset).safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n    /// @inheritdoc IERC4626DepositOnly\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        address(asset).safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626DepositOnly\n    function totalAssets() public view virtual returns (uint256);\n\n    /// @inheritdoc IERC4626DepositOnly\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDiv(supply, totalAssets());\n    }\n\n    /// TODO: @inheritdoc IERC4626DepositOnly\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDiv(totalAssets(), supply);\n    }\n\n    /// @inheritdoc IERC4626DepositOnly\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    /// @inheritdoc IERC4626DepositOnly\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626DepositOnly\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /// @inheritdoc IERC4626DepositOnly\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function afterDeposit(uint256 assets, uint256 shares) internal virtual {}\n}"
    },
    {
      "filename": "src/erc-4626/ERC4626DepositOnly.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IERC4626DepositOnly} from \"./interfaces/IERC4626DepositOnly.sol\";\n\n/// @title Minimal Deposit Only ERC4626 tokenized Vault implementation\n/// @author Maia DAO (https://github.com/Maia-DAO)\nabstract contract ERC4626DepositOnly is ERC20, IERC4626DepositOnly {\n    using SafeTransferLib for address;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    ERC20 public immutable asset;\n\n    constructor(ERC20 _asset, string memory _name, string memory _symbol) ERC20(_name, _symbol, _asset.decimals()) {\n        asset = _asset;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626DepositOnly\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n        // Need to transfer before minting or ERC777s could reenter.\n        address(asset).safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n    /// @inheritdoc IERC4626DepositOnly\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        address(asset).safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626DepositOnly\n    function totalAssets() public view virtual returns (uint256);\n\n    /// @inheritdoc IERC4626DepositOnly\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDiv(supply, totalAssets());\n    }\n\n    /// TODO: @inheritdoc IERC4626DepositOnly\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDiv(totalAssets(), supply);\n    }\n\n    /// @inheritdoc IERC4626DepositOnly\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    /// @inheritdoc IERC4626DepositOnly\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626DepositOnly\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /// @inheritdoc IERC4626DepositOnly\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function afterDeposit(uint256 assets, uint256 shares) internal virtual {}\n}"
    },
    {
      "filename": "src/ulysses-amm/UlyssesRouter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {UlyssesPool} from \"./UlyssesPool.sol\";\n\nimport {IUlyssesRouter, UlyssesFactory} from \"./interfaces/IUlyssesRouter.sol\";\n\n/// @title Ulysses Router - Handles routing of transactions in the Ulysses AMM\ncontract UlyssesRouter is IUlyssesRouter {\n    using SafeTransferLib for address;\n\n    /// @notice Mapping from pool id to Ulysses pool.\n    mapping(uint256 => UlyssesPool) private pools;\n\n    /// @inheritdoc IUlyssesRouter\n    UlyssesFactory public ulyssesFactory;\n\n    constructor(UlyssesFactory _ulyssesFactory) {\n        ulyssesFactory = _ulyssesFactory;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        Internal LOGIC\n    //////////////////////////////////////////////////////////////*/\n    /**\n     * @notice Returns the Ulysses pool for the given id.\n     * @param id The id of the Ulysses pool.\n     */\n    function getUlyssesLP(uint256 id) private returns (UlyssesPool ulysses) {\n        ulysses = pools[id];\n        if (address(ulysses) == address(0)) {\n            ulysses = ulyssesFactory.pools(id);\n\n            if (address(ulysses) == address(0)) revert UnrecognizedUlyssesLP();\n\n            pools[id] = ulysses;\n\n            address(ulysses.asset()).safeApprove(address(ulysses), type(uint256).max);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         LIQUIDITY LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IUlyssesRouter\n    function addLiquidity(uint256 amount, uint256 minOutput, uint256 poolId) external returns (uint256) {\n        UlyssesPool ulysses = getUlyssesLP(poolId);\n\n        amount = ulysses.deposit(amount, msg.sender);\n\n        if (amount < minOutput) revert OutputTooLow();\n        return amount;\n    }\n\n    /// @inheritdoc IUlyssesRouter\n    function removeLiquidity(uint256 amount, uint256 minOutput, uint256 poolId) external returns (uint256) {\n        UlyssesPool ulysses = getUlyssesLP(poolId);\n\n        amount = ulysses.redeem(amount, msg.sender, msg.sender);\n\n        if (amount < minOutput) revert OutputTooLow();\n        return amount;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            SWAP LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IUlyssesRouter\n    function swap(uint256 amount, uint256 minOutput, Route[] calldata routes) external returns (uint256) {\n        address(getUlyssesLP(routes[0].from).asset()).safeTransferFrom(msg.sender, address(this), amount);\n\n        uint256 length = routes.length;\n\n        for (uint256 i = 0; i < length;) {\n            amount = getUlyssesLP(routes[i].from).swapIn(amount, routes[i].to);\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (amount < minOutput) revert OutputTooLow();\n\n        unchecked {\n            --length;\n        }\n\n        address(getUlyssesLP(routes[length].to).asset()).safeTransfer(msg.sender, amount);\n\n        return amount;\n    }\n}"
    }
  ]
}