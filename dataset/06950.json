{
  "Title": "[L-01] `claimable` function doesn't validate ticket draw is finished",
  "Content": "\nhttps://github.com/code-423n4/2023-03-wenwin/blob/main/src/Lottery.sol#L159-L168\n\nThe function should validate that the draw associated with the ticket is already finished, as the function uses the winning ticket to run the calculation and this value will be undefined until the draw is finished and a ticket is selected.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2023-03-wenwin-contest",
  "Code": [
    {
      "filename": "src/Lottery.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\n// slither-disable-next-line solc-version\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"src/ReferralSystem.sol\";\nimport \"src/RNSourceController.sol\";\nimport \"src/staking/Staking.sol\";\nimport \"src/LotterySetup.sol\";\nimport \"src/TicketUtils.sol\";\n\n/// @dev Lottery contract\n/// It runs `selectionSize` / `selectionMax` type of lottery.\n/// User buys the ticket by selecting total of `selectionSize` numbers from [1, selectionMax] range.\n/// Ticket price is paid each time user buys a ticket.\n/// Part of the price is staking reward, which is claimable to `stakingRewardRecipient`.\n/// Part of the price is frontend reward which is claimable by frontend operators selling the ticket.\n/// All fees, as well as rewards are paid in `rewardToken`.\n/// All prizes are dynamic and dependant on the actual ticket sales.\ncontract Lottery is ILottery, Ticket, LotterySetup, ReferralSystem, RNSourceController {\n    using SafeERC20 for IERC20;\n    using TicketUtils for uint256;\n\n    uint256 private claimedStakingRewardAtTicketId;\n    mapping(address => uint256) private frontendDueTicketSales;\n    mapping(uint128 => mapping(uint120 => uint256)) private unclaimedCount;\n\n    address public immutable override stakingRewardRecipient;\n\n    uint256 public override lastDrawFinalTicketId;\n\n    bool public override drawExecutionInProgress;\n    uint128 public override currentDraw;\n\n    mapping(uint128 => uint120) public override winningTicket;\n    mapping(uint128 => mapping(uint8 => uint256)) public override winAmount;\n\n    mapping(uint128 => uint256) public override ticketsSold;\n    int256 public override currentNetProfit;\n\n    /// @dev Checks if ticket is a valid ticket, and reverts if invalid\n    /// @param ticket Ticket being checked\n    modifier requireValidTicket(uint256 ticket) {\n        if (!ticket.isValidTicket(selectionSize, selectionMax)) {\n            revert InvalidTicket();\n        }\n        _;\n    }\n\n    /// @dev Checks if we are not executing draw already.\n    modifier whenNotExecutingDraw() {\n        if (drawExecutionInProgress) {\n            revert DrawAlreadyInProgress();\n        }\n        _;\n    }\n\n    /// @dev Checks if draw is being executed right now.\n    modifier onlyWhenExecutingDraw() {\n        if (!drawExecutionInProgress) {\n            revert DrawNotInProgress();\n        }\n        _;\n    }\n\n    /// @dev Checks that ticket owner is caller of the function. Reverts if not called by ticket owner.\n    /// @param ticketId Ticket id we are checking owner for.\n    modifier onlyTicketOwner(uint256 ticketId) {\n        if (ownerOf(ticketId) != msg.sender) {\n            revert UnauthorizedClaim(ticketId, msg.sender);\n        }\n        _;\n    }\n\n    /// @dev Constructs a new lottery contract.\n    /// @param lotterySetupParams Setup parameter for the lottery.\n    /// @param playerRewardFirstDraw Rewards for players in native token for first draw.\n    /// @param playerRewardDecreasePerDraw Decrease of rewards for players per each draw.\n    /// @param rewardsToReferrersPerDraw Percentage of native token rewards going to players.\n    /// @param maxRNFailedAttempts Maximum number of consecutive failed attempts for random number source.\n    /// @param maxRNRequestDelay Time considered as maximum delay for RN request.\n    // solhint-disable-next-line code-complexity\n    constructor(\n        LotterySetupParams memory lotterySetupParams,\n        uint256 playerRewardFirstDraw,\n        uint256 playerRewardDecreasePerDraw,\n        uint256[] memory rewardsToReferrersPerDraw,\n        uint256 maxRNFailedAttempts,\n        uint256 maxRNRequestDelay\n    )\n        Ticket()\n        LotterySetup(lotterySetupParams)\n        ReferralSystem(playerRewardFirstDraw, playerRewardDecreasePerDraw, rewardsToReferrersPerDraw)\n        RNSourceController(maxRNFailedAttempts, maxRNRequestDelay)\n    {\n        stakingRewardRecipient = address(\n            new Staking(\n            this,\n            lotterySetupParams.token,\n            nativeToken,\n            \"Staked LOT\",\n            \"stLOT\"\n            )\n        );\n\n        nativeToken.safeTransfer(msg.sender, ILotteryToken(address(nativeToken)).INITIAL_SUPPLY());\n    }\n\n    function buyTickets(\n        uint128[] calldata drawIds,\n        uint120[] calldata tickets,\n        address frontend,\n        address referrer\n    )\n        external\n        override\n        requireJackpotInitialized\n        returns (uint256[] memory ticketIds)\n    {\n        if (drawIds.length != tickets.length) {\n            revert DrawsAndTicketsLenMismatch(drawIds.length, tickets.length);\n        }\n        ticketIds = new uint256[](tickets.length);\n        for (uint256 i = 0; i < drawIds.length; ++i) {\n            ticketIds[i] = registerTicket(drawIds[i], tickets[i], frontend, referrer);\n        }\n        referralRegisterTickets(currentDraw, referrer, msg.sender, tickets.length);\n        frontendDueTicketSales[frontend] += tickets.length;\n        rewardToken.safeTransferFrom(msg.sender, address(this), ticketPrice * tickets.length);\n    }\n\n    function executeDraw() external override whenNotExecutingDraw {\n        // slither-disable-next-line timestamp\n        if (block.timestamp < drawScheduledAt(currentDraw)) {\n            revert ExecutingDrawTooEarly();\n        }\n        returnUnclaimedJackpotToThePot();\n        drawExecutionInProgress = true;\n        requestRandomNumber();\n        emit StartedExecutingDraw(currentDraw);\n    }\n\n    function unclaimedRewards(LotteryRewardType rewardType) external view override returns (uint256 rewards) {\n        uint256 dueTicketsSold = (rewardType == LotteryRewardType.FRONTEND)\n            ? frontendDueTicketSales[msg.sender]\n            : nextTicketId - claimedStakingRewardAtTicketId;\n        rewards = LotteryMath.calculateRewards(ticketPrice, dueTicketsSold, rewardType);\n    }\n\n    function claimRewards(LotteryRewardType rewardType) external override returns (uint256 claimedAmount) {\n        address beneficiary = (rewardType == LotteryRewardType.FRONTEND) ? msg.sender : stakingRewardRecipient;\n        claimedAmount = LotteryMath.calculateRewards(ticketPrice, dueTicketsSoldAndReset(beneficiary), rewardType);\n\n        emit ClaimedRewards(beneficiary, claimedAmount, rewardType);\n        rewardToken.safeTransfer(beneficiary, claimedAmount);\n    }\n\n    function claimable(uint256 ticketId) external view override returns (uint256 claimableAmount, uint8 winTier) {\n        TicketInfo memory ticketInfo = ticketsInfo[ticketId];\n        if (!ticketInfo.claimed) {\n            uint120 _winningTicket = winningTicket[ticketInfo.drawId];\n            winTier = TicketUtils.ticketWinTier(ticketInfo.combination, _winningTicket, selectionSize, selectionMax);\n            if (block.timestamp <= ticketRegistrationDeadline(ticketInfo.drawId + LotteryMath.DRAWS_PER_YEAR)) {\n                claimableAmount = winAmount[ticketInfo.drawId][winTier];\n            }\n        }\n    }\n\n    function claimWinningTickets(uint256[] calldata ticketIds) external override returns (uint256 claimedAmount) {\n        uint256 totalTickets = ticketIds.length;\n        for (uint256 i = 0; i < totalTickets; ++i) {\n            claimedAmount += claimWinningTicket(ticketIds[i]);\n        }\n        rewardToken.safeTransfer(msg.sender, claimedAmount);\n    }\n\n    /// @dev Registers the ticket in the system. To be called when user is buying the ticket.\n    /// @param drawId Draw identifier ticket is bought for.\n    /// @param ticket Combination packed as uint120.\n    function registerTicket(\n        uint128 drawId,\n        uint120 ticket,\n        address frontend,\n        address referrer\n    )\n        private\n        beforeTicketRegistrationDeadline(drawId)\n        requireValidTicket(ticket)\n        returns (uint256 ticketId)\n    {\n        ticketId = mint(msg.sender, drawId, ticket);\n        unclaimedCount[drawId][ticket]++;\n        ticketsSold[drawId]++;\n        emit NewTicket(currentDraw, ticketId, drawId, msg.sender, ticket, frontend, referrer);\n    }\n\n    /// @dev Finalizes the draw after getting random number from source.\n    /// Calculates the winning ticket. Splits jackpot rewards if there are matching tickets.\n    /// Stores claimable amounts for each win tier and calculates net profit.\n    /// Triggers referral system's mint for current draw to split the incentives.\n    /// @param randomNumber The number that is received from source.\n    function receiveRandomNumber(uint256 randomNumber) internal override onlyWhenExecutingDraw {\n        uint120 _winningTicket = TicketUtils.reconstructTicket(randomNumber, selectionSize, selectionMax);\n        uint128 drawFinalized = currentDraw++;\n        uint256 jackpotWinners = unclaimedCount[drawFinalized][_winningTicket];\n\n        if (jackpotWinners > 0) {\n            winAmount[drawFinalized][selectionSize] = drawRewardSize(drawFinalized, selectionSize) / jackpotWinners;\n        } else {\n            for (uint8 winTier = 1; winTier < selectionSize; ++winTier) {\n                winAmount[drawFinalized][winTier] = drawRewardSize(drawFinalized, winTier);\n            }\n        }\n\n        currentNetProfit = LotteryMath.calculateNewProfit(\n            currentNetProfit,\n            ticketsSold[drawFinalized],\n            ticketPrice,\n            jackpotWinners > 0,\n            fixedReward(selectionSize),\n            expectedPayout\n        );\n        winningTicket[drawFinalized] = _winningTicket;\n        drawExecutionInProgress = false;\n\n        uint256 ticketsSoldDuringDraw = nextTicketId - lastDrawFinalTicketId;\n        lastDrawFinalTicketId = nextTicketId;\n        referralDrawFinalize(drawFinalized, ticketsSoldDuringDraw);\n\n        emit FinishedExecutingDraw(drawFinalized, randomNumber, _winningTicket);\n    }\n\n    function currentRewardSize(uint8 winTier) public view override returns (uint256 rewardSize) {\n        return drawRewardSize(currentDraw, winTier);\n    }\n\n    function drawRewardSize(uint128 drawId, uint8 winTier) private view returns (uint256 rewardSize) {\n        return LotteryMath.calculateReward(\n            currentNetProfit,\n            fixedReward(winTier),\n            fixedReward(selectionSize),\n            ticketsSold[drawId],\n            winTier == selectionSize,\n            expectedPayout\n        );\n    }\n\n    function dueTicketsSoldAndReset(address beneficiary) private returns (uint256 dueTickets) {\n        if (beneficiary == stakingRewardRecipient) {\n            dueTickets = nextTicketId - claimedStakingRewardAtTicketId;\n            claimedStakingRewardAtTicketId = nextTicketId;\n        } else {\n            dueTickets = frontendDueTicketSales[beneficiary];\n            frontendDueTicketSales[beneficiary] = 0;\n        }\n    }\n\n    function claimWinningTicket(uint256 ticketId) private onlyTicketOwner(ticketId) returns (uint256 claimedAmount) {\n        uint256 winTier;\n        (claimedAmount, winTier) = this.claimable(ticketId);\n        if (claimedAmount == 0) {\n            revert NothingToClaim(ticketId);\n        }\n\n        unclaimedCount[ticketsInfo[ticketId].drawId][ticketsInfo[ticketId].combination]--;\n        markAsClaimed(ticketId);\n        emit ClaimedTicket(msg.sender, ticketId, claimedAmount);\n    }\n\n    function returnUnclaimedJackpotToThePot() private {\n        if (currentDraw >= LotteryMath.DRAWS_PER_YEAR) {\n            uint128 drawId = currentDraw - LotteryMath.DRAWS_PER_YEAR;\n            uint256 unclaimedJackpotTickets = unclaimedCount[drawId][winningTicket[drawId]];\n            currentNetProfit += int256(unclaimedJackpotTickets * winAmount[drawId][selectionSize]);\n        }\n    }\n\n    function requireFinishedDraw(uint128 drawId) internal view override {\n        if (drawId >= currentDraw) {\n            revert DrawNotFinished(drawId);\n        }\n    }\n\n    function mintNativeTokens(address mintTo, uint256 amount) internal override {\n        ILotteryToken(address(nativeToken)).mint(mintTo, amount);\n    }\n}"
    }
  ]
}