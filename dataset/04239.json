{
  "Title": "[M03] Lack of event emission after sensitive changes",
  "Content": "In several parts of the code there are sensitive functions that lack event emissions. This can make it difficult for users to be aware of important changes that take place.\n\n\nHere are some examples:\n\n\n* The [`processClaim` function](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/ClaimsManager.sol#L263) in the `ClaimsManager` contract does not emit an event [in the case where there are no rewards](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/ClaimsManager.sol#L263).\n* The [`setGovernanceAddress`](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/ClaimsManager.sol#L153), [`setStakingAddress`](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/ClaimsManager.sol#L163), [`setServiceProviderFactoryAddress`](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/ClaimsManager.sol#L173), [`setDelegateManagerAddress`](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/ClaimsManager.sol#L183), [`updateFundingAmount`](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/ClaimsManager.sol#L295), and [`updateFundingRoundBlockDiff`](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/ClaimsManager.sol#L324) functions from the `ClaimsManager` contract do not emit events.\n* The [`addServiceType`](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/ServiceTypeManager.sol#L71) and [`removeServiceType`](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/ServiceTypeManager.sol#L93) functions from the `ServiceTypeManager` contract do not emit events.\n* The [`updateDelegateOwnerWallet`](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/ServiceProviderFactory.sol#L467), [`updateEndpoint`](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/ServiceProviderFactory.sol#L488), [`updateServiceProviderCut`](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/ServiceProviderFactory.sol#L546), and [`updateDecreaseStakeLockupDuration`](https://github.com/AudiusProject/audius-protocol/blob/6f3b31562b9d4c43cef91af0a011986a2580fba2/eth-contracts/contracts/ServiceProviderFactory.sol#L562) functions from the `ServiceProviderManager` contract do not emit events.\n\n\nConsider adding events in these cases to make it easier to track important contract changes.\n\n\n***Update:** Fixed in [pull request #583](https://github.com/AudiusProject/audius-protocol/pull/583).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "eth-contracts/contracts/ClaimsManager.sol",
      "content": "pragma solidity ^0.5.0;\nimport \"./Staking.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Mintable.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20.sol\";\nimport \"./ServiceProviderFactory.sol\";\n/// @notice SafeMath imported via ServiceProviderFactory.sol\n\n\n/**\n * Designed to automate claim funding, minting tokens as necessary\n * @notice - will call InitializableV2 constructor\n */\ncontract ClaimsManager is InitializableV2 {\n    using SafeMath for uint256;\n    address private tokenAddress;\n    address private governanceAddress;\n    address private stakingAddress;\n    address private serviceProviderFactoryAddress;\n    address private delegateManagerAddress;\n\n    // Claim related configurations\n    /**\n      * @notice - Minimum number of blocks between funding rounds\n      *       604800 seconds / week\n      *       Avg block time - 13s\n      *       604800 / 13 = 46523.0769231 blocks\n      */\n    uint private fundingRoundBlockDiff;\n\n    /**\n      * @notice - Configures the current funding amount per round\n      *  Weekly rounds, 7% PA inflation = 70,000,000 new tokens in first year\n      *                                 = 70,000,000/365*7 (year is slightly more than a week)\n      *                                 = 1342465.75342 new AUDS per week\n      *                                 = 1342465753420000000000000 new wei units per week\n      * @dev - Past a certain block height, this schedule will be updated\n      *      - Logic determining schedule will be sourced from an external contract\n      */\n    uint private fundingAmount;\n\n    // Denotes current round\n    uint private roundNumber;\n\n    // Staking contract ref\n    ERC20Mintable private audiusToken;\n\n    // Struct representing round state\n    // 1) Block at which round was funded\n    // 2) Total funded for this round\n    // 3) Total claimed in round\n    struct Round {\n        uint fundBlock;\n        uint fundingAmount;\n        uint totalClaimedInRound;\n    }\n\n    // Current round information\n    Round currentRound;\n\n    event RoundInitiated(\n      uint _blockNumber,\n      uint _roundNumber,\n      uint _fundAmount\n    );\n\n    event ClaimProcessed(\n      address _claimer,\n      uint _rewards,\n      uint _oldTotal,\n      uint _newTotal\n    );\n\n    /**\n     * @notice Function to initialize the contract\n     * @param _tokenAddress - address of ERC20 token that will be claimed\n     * @param _governanceAddress - address for Governance proxy contract\n     */\n    function initialize(\n        address _tokenAddress,\n        address _governanceAddress\n    ) public initializer\n    {\n        tokenAddress = _tokenAddress;\n        governanceAddress = _governanceAddress;\n\n        audiusToken = ERC20Mintable(tokenAddress);\n\n        fundingRoundBlockDiff = 46523;\n        fundingAmount = 1342465753420000000000000; // 1342465.75342 AUDS\n        roundNumber = 0;\n\n        currentRound = Round({\n            fundBlock: 0,\n            fundingAmount: 0,\n            totalClaimedInRound: 0\n        });\n\n        InitializableV2.initialize();\n    }\n\n    /// @notice Get the duration of a funding round in blocks\n    function getFundingRoundBlockDiff() external view returns (uint blockDiff)\n    {\n        return fundingRoundBlockDiff;\n    }\n\n    /// @notice Get the last block where a funding round was initiated\n    function getLastFundBlock() external view returns (uint lastFundBlock)\n    {\n        return currentRound.fundBlock;\n    }\n\n    /// @notice Get the amount funded per round in wei\n    function getFundsPerRound() external view returns (uint amount)\n    {\n        return fundingAmount;\n    }\n\n    /// @notice Get the total amount claimed in the current round\n    function getTotalClaimedInRound() external view returns (uint claimedAmount)\n    {\n        return currentRound.totalClaimedInRound;\n    }\n\n    /// @notice Get the Governance address\n    function getGovernanceAddress() external view returns (address addr) {\n        return governanceAddress;\n    }\n\n    /// @notice Get the ServiceProviderFactory address\n    function getServiceProviderFactoryAddress() external view returns (address addr) {\n        return serviceProviderFactoryAddress;\n    }\n\n    /// @notice Get the DelegateManager address\n    function getDelegateManagerAddress() external view returns (address addr) {\n        return delegateManagerAddress;\n    }\n\n    /**\n     * @notice Get the Staking address\n     */\n    function getStakingAddress() external view returns (address addr)\n    {\n        return stakingAddress;\n    }\n\n    /**\n     * @notice Set the Governance address\n     * @dev Only callable by Governance address\n     * @param _governanceAddress - address for new Governance contract\n     */\n    function setGovernanceAddress(address _governanceAddress) external {\n        require(msg.sender == governanceAddress, \"Only callable by Governance contract\");\n        governanceAddress = _governanceAddress;\n    }\n\n    /**\n     * @notice Set the Staking address\n     * @dev Only callable by Governance address\n     * @param _address - address for new Staking contract\n     */\n    function setStakingAddress(address _address) external {\n        require(msg.sender == governanceAddress, \"Only callable by Governance contract\");\n        stakingAddress = _address;\n    }\n\n    /**\n     * @notice Set the ServiceProviderFactory address\n     * @dev Only callable by Governance address\n     * @param _spFactory - address for new ServiceProviderFactory contract\n     */\n    function setServiceProviderFactoryAddress(address _spFactory) external {\n        require(msg.sender == governanceAddress, \"Only callable by Governance contract\");\n        serviceProviderFactoryAddress = _spFactory;\n    }\n\n    /**\n     * @notice Set the DelegateManager address\n     * @dev Only callable by Governance address\n     * @param _delegateManager - address for new DelegateManager contract\n     */\n    function setDelegateManagerAddress(address _delegateManager) external {\n        require(msg.sender == governanceAddress, \"Only callable by Governance contract\");\n        delegateManagerAddress = _delegateManager;\n    }\n\n    /**\n     * @notice Start a new funding round\n     * @dev Permissioned to be callable by stakers or governance contract\n     */\n    function initiateRound() external {\n        _requireIsInitialized();\n\n        bool senderStaked = Staking(stakingAddress).totalStakedFor(msg.sender) > 0;\n        require(\n            senderStaked || (msg.sender == governanceAddress),\n            \"Only callable by staked account or Governance contract\"\n        );\n\n        require(\n            block.number.sub(currentRound.fundBlock) > fundingRoundBlockDiff,\n            \"Required block difference not met\"\n        );\n\n        currentRound = Round({\n            fundBlock: block.number,\n            fundingAmount: fundingAmount,\n            totalClaimedInRound: 0\n        });\n\n        roundNumber = roundNumber.add(1);\n\n        emit RoundInitiated(\n            currentRound.fundBlock,\n            roundNumber,\n            currentRound.fundingAmount\n        );\n    }\n\n    /**\n     * @notice Mints and stakes tokens on behalf of ServiceProvider + delegators\n     * @dev Callable through DelegateManager by Service Provider\n     * @param _claimer  - service provider address\n     * @param _totalLockedForSP - amount of tokens locked up across DelegateManager + ServiceProvider\n     */\n    function processClaim(\n        address _claimer,\n        uint _totalLockedForSP\n    ) external\n    {\n        _requireIsInitialized();\n        require(\n            msg.sender == delegateManagerAddress,\n            \"ProcessClaim only accessible to DelegateManager\"\n        );\n\n        Staking stakingContract = Staking(stakingAddress);\n        // Prevent duplicate claim\n        uint lastUserClaimBlock = stakingContract.lastClaimedFor(_claimer);\n        require(lastUserClaimBlock <= currentRound.fundBlock, \"Claim already processed for user\");\n        uint totalStakedAtFundBlockForClaimer = stakingContract.totalStakedForAt(\n            _claimer,\n            currentRound.fundBlock);\n\n        (,,bool withinBounds,,,) = (\n            ServiceProviderFactory(serviceProviderFactoryAddress).getServiceProviderDetails(_claimer)\n        );\n\n        // Once they claim the zero reward amount, stake can be modified once again\n        // Subtract total locked amount for SP from stake at fund block\n        uint claimerTotalStake = totalStakedAtFundBlockForClaimer.sub(_totalLockedForSP);\n        uint totalStakedAtFundBlock = stakingContract.totalStakedAt(currentRound.fundBlock);\n\n        // Calculate claimer rewards\n        uint rewardsForClaimer = (\n          claimerTotalStake.mul(fundingAmount)\n        ).div(totalStakedAtFundBlock);\n\n        // For a claimer violating bounds, no new tokens are minted\n        // Claim history is marked to zero and function is short-circuited\n        // Total rewards can be zero if all stake is currently locked up\n        if (!withinBounds || rewardsForClaimer == 0) {\n            stakingContract.updateClaimHistory(0, _claimer);\n            return;\n        }\n\n        // ERC20Mintable always returns true\n        audiusToken.mint(address(this), rewardsForClaimer);\n\n        // ERC20 always returns true\n        audiusToken.approve(stakingAddress, rewardsForClaimer);\n\n        // Transfer rewards\n        stakingContract.stakeRewards(rewardsForClaimer, _claimer);\n\n        // Update round claim value\n        currentRound.totalClaimedInRound = currentRound.totalClaimedInRound.add(rewardsForClaimer);\n\n        // Update round claim value\n        uint newTotal = stakingContract.totalStakedFor(_claimer);\n\n        emit ClaimProcessed(\n            _claimer,\n            rewardsForClaimer,\n            totalStakedAtFundBlockForClaimer,\n            newTotal\n        );\n    }\n\n    /**\n     * @notice Modify funding amount per round\n     * @param _newAmount - new amount to fund per round in wei\n     */\n    function updateFundingAmount(uint _newAmount)\n    external returns (uint newAmount)\n    {\n        require(\n            msg.sender == governanceAddress,\n            \"Only callable by Governance contract\"\n        );\n        fundingAmount = _newAmount;\n        return _newAmount;\n    }\n\n    /**\n     * @notice Returns boolean indicating whether a claim is considered pending\n     * @dev Note that an address with no endpoints can never have a pending claim\n     * @param _sp - address of the service provider to check\n     * @return boolean - true if eligible for claim, false if not\n     */\n    function claimPending(address _sp) external view returns (bool pending) {\n        uint lastClaimedForSP = Staking(stakingAddress).lastClaimedFor(_sp);\n        (,,,uint numEndpoints,,) = (\n            ServiceProviderFactory(serviceProviderFactoryAddress).getServiceProviderDetails(_sp)\n        );\n        return (lastClaimedForSP < currentRound.fundBlock && numEndpoints > 0);\n    }\n\n    /**\n     * @notice Modify minimum block difference between funding rounds\n     * @param _newFundingRoundBlockDiff - new min block difference to set\n     */\n    function updateFundingRoundBlockDiff(uint _newFundingRoundBlockDiff) external {\n        require(\n            msg.sender == governanceAddress,\n            \"Only callable by Governance contract\"\n        );\n        fundingRoundBlockDiff = _newFundingRoundBlockDiff;\n    }\n}"
    },
    {
      "filename": "eth-contracts/contracts/ClaimsManager.sol",
      "content": "pragma solidity ^0.5.0;\nimport \"./Staking.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Mintable.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20.sol\";\nimport \"./ServiceProviderFactory.sol\";\n/// @notice SafeMath imported via ServiceProviderFactory.sol\n\n\n/**\n * Designed to automate claim funding, minting tokens as necessary\n * @notice - will call InitializableV2 constructor\n */\ncontract ClaimsManager is InitializableV2 {\n    using SafeMath for uint256;\n    address private tokenAddress;\n    address private governanceAddress;\n    address private stakingAddress;\n    address private serviceProviderFactoryAddress;\n    address private delegateManagerAddress;\n\n    // Claim related configurations\n    /**\n      * @notice - Minimum number of blocks between funding rounds\n      *       604800 seconds / week\n      *       Avg block time - 13s\n      *       604800 / 13 = 46523.0769231 blocks\n      */\n    uint private fundingRoundBlockDiff;\n\n    /**\n      * @notice - Configures the current funding amount per round\n      *  Weekly rounds, 7% PA inflation = 70,000,000 new tokens in first year\n      *                                 = 70,000,000/365*7 (year is slightly more than a week)\n      *                                 = 1342465.75342 new AUDS per week\n      *                                 = 1342465753420000000000000 new wei units per week\n      * @dev - Past a certain block height, this schedule will be updated\n      *      - Logic determining schedule will be sourced from an external contract\n      */\n    uint private fundingAmount;\n\n    // Denotes current round\n    uint private roundNumber;\n\n    // Staking contract ref\n    ERC20Mintable private audiusToken;\n\n    // Struct representing round state\n    // 1) Block at which round was funded\n    // 2) Total funded for this round\n    // 3) Total claimed in round\n    struct Round {\n        uint fundBlock;\n        uint fundingAmount;\n        uint totalClaimedInRound;\n    }\n\n    // Current round information\n    Round currentRound;\n\n    event RoundInitiated(\n      uint _blockNumber,\n      uint _roundNumber,\n      uint _fundAmount\n    );\n\n    event ClaimProcessed(\n      address _claimer,\n      uint _rewards,\n      uint _oldTotal,\n      uint _newTotal\n    );\n\n    /**\n     * @notice Function to initialize the contract\n     * @param _tokenAddress - address of ERC20 token that will be claimed\n     * @param _governanceAddress - address for Governance proxy contract\n     */\n    function initialize(\n        address _tokenAddress,\n        address _governanceAddress\n    ) public initializer\n    {\n        tokenAddress = _tokenAddress;\n        governanceAddress = _governanceAddress;\n\n        audiusToken = ERC20Mintable(tokenAddress);\n\n        fundingRoundBlockDiff = 46523;\n        fundingAmount = 1342465753420000000000000; // 1342465.75342 AUDS\n        roundNumber = 0;\n\n        currentRound = Round({\n            fundBlock: 0,\n            fundingAmount: 0,\n            totalClaimedInRound: 0\n        });\n\n        InitializableV2.initialize();\n    }\n\n    /// @notice Get the duration of a funding round in blocks\n    function getFundingRoundBlockDiff() external view returns (uint blockDiff)\n    {\n        return fundingRoundBlockDiff;\n    }\n\n    /// @notice Get the last block where a funding round was initiated\n    function getLastFundBlock() external view returns (uint lastFundBlock)\n    {\n        return currentRound.fundBlock;\n    }\n\n    /// @notice Get the amount funded per round in wei\n    function getFundsPerRound() external view returns (uint amount)\n    {\n        return fundingAmount;\n    }\n\n    /// @notice Get the total amount claimed in the current round\n    function getTotalClaimedInRound() external view returns (uint claimedAmount)\n    {\n        return currentRound.totalClaimedInRound;\n    }\n\n    /// @notice Get the Governance address\n    function getGovernanceAddress() external view returns (address addr) {\n        return governanceAddress;\n    }\n\n    /// @notice Get the ServiceProviderFactory address\n    function getServiceProviderFactoryAddress() external view returns (address addr) {\n        return serviceProviderFactoryAddress;\n    }\n\n    /// @notice Get the DelegateManager address\n    function getDelegateManagerAddress() external view returns (address addr) {\n        return delegateManagerAddress;\n    }\n\n    /**\n     * @notice Get the Staking address\n     */\n    function getStakingAddress() external view returns (address addr)\n    {\n        return stakingAddress;\n    }\n\n    /**\n     * @notice Set the Governance address\n     * @dev Only callable by Governance address\n     * @param _governanceAddress - address for new Governance contract\n     */\n    function setGovernanceAddress(address _governanceAddress) external {\n        require(msg.sender == governanceAddress, \"Only callable by Governance contract\");\n        governanceAddress = _governanceAddress;\n    }\n\n    /**\n     * @notice Set the Staking address\n     * @dev Only callable by Governance address\n     * @param _address - address for new Staking contract\n     */\n    function setStakingAddress(address _address) external {\n        require(msg.sender == governanceAddress, \"Only callable by Governance contract\");\n        stakingAddress = _address;\n    }\n\n    /**\n     * @notice Set the ServiceProviderFactory address\n     * @dev Only callable by Governance address\n     * @param _spFactory - address for new ServiceProviderFactory contract\n     */\n    function setServiceProviderFactoryAddress(address _spFactory) external {\n        require(msg.sender == governanceAddress, \"Only callable by Governance contract\");\n        serviceProviderFactoryAddress = _spFactory;\n    }\n\n    /**\n     * @notice Set the DelegateManager address\n     * @dev Only callable by Governance address\n     * @param _delegateManager - address for new DelegateManager contract\n     */\n    function setDelegateManagerAddress(address _delegateManager) external {\n        require(msg.sender == governanceAddress, \"Only callable by Governance contract\");\n        delegateManagerAddress = _delegateManager;\n    }\n\n    /**\n     * @notice Start a new funding round\n     * @dev Permissioned to be callable by stakers or governance contract\n     */\n    function initiateRound() external {\n        _requireIsInitialized();\n\n        bool senderStaked = Staking(stakingAddress).totalStakedFor(msg.sender) > 0;\n        require(\n            senderStaked || (msg.sender == governanceAddress),\n            \"Only callable by staked account or Governance contract\"\n        );\n\n        require(\n            block.number.sub(currentRound.fundBlock) > fundingRoundBlockDiff,\n            \"Required block difference not met\"\n        );\n\n        currentRound = Round({\n            fundBlock: block.number,\n            fundingAmount: fundingAmount,\n            totalClaimedInRound: 0\n        });\n\n        roundNumber = roundNumber.add(1);\n\n        emit RoundInitiated(\n            currentRound.fundBlock,\n            roundNumber,\n            currentRound.fundingAmount\n        );\n    }\n\n    /**\n     * @notice Mints and stakes tokens on behalf of ServiceProvider + delegators\n     * @dev Callable through DelegateManager by Service Provider\n     * @param _claimer  - service provider address\n     * @param _totalLockedForSP - amount of tokens locked up across DelegateManager + ServiceProvider\n     */\n    function processClaim(\n        address _claimer,\n        uint _totalLockedForSP\n    ) external\n    {\n        _requireIsInitialized();\n        require(\n            msg.sender == delegateManagerAddress,\n            \"ProcessClaim only accessible to DelegateManager\"\n        );\n\n        Staking stakingContract = Staking(stakingAddress);\n        // Prevent duplicate claim\n        uint lastUserClaimBlock = stakingContract.lastClaimedFor(_claimer);\n        require(lastUserClaimBlock <= currentRound.fundBlock, \"Claim already processed for user\");\n        uint totalStakedAtFundBlockForClaimer = stakingContract.totalStakedForAt(\n            _claimer,\n            currentRound.fundBlock);\n\n        (,,bool withinBounds,,,) = (\n            ServiceProviderFactory(serviceProviderFactoryAddress).getServiceProviderDetails(_claimer)\n        );\n\n        // Once they claim the zero reward amount, stake can be modified once again\n        // Subtract total locked amount for SP from stake at fund block\n        uint claimerTotalStake = totalStakedAtFundBlockForClaimer.sub(_totalLockedForSP);\n        uint totalStakedAtFundBlock = stakingContract.totalStakedAt(currentRound.fundBlock);\n\n        // Calculate claimer rewards\n        uint rewardsForClaimer = (\n          claimerTotalStake.mul(fundingAmount)\n        ).div(totalStakedAtFundBlock);\n\n        // For a claimer violating bounds, no new tokens are minted\n        // Claim history is marked to zero and function is short-circuited\n        // Total rewards can be zero if all stake is currently locked up\n        if (!withinBounds || rewardsForClaimer == 0) {\n            stakingContract.updateClaimHistory(0, _claimer);\n            return;\n        }\n\n        // ERC20Mintable always returns true\n        audiusToken.mint(address(this), rewardsForClaimer);\n\n        // ERC20 always returns true\n        audiusToken.approve(stakingAddress, rewardsForClaimer);\n\n        // Transfer rewards\n        stakingContract.stakeRewards(rewardsForClaimer, _claimer);\n\n        // Update round claim value\n        currentRound.totalClaimedInRound = currentRound.totalClaimedInRound.add(rewardsForClaimer);\n\n        // Update round claim value\n        uint newTotal = stakingContract.totalStakedFor(_claimer);\n\n        emit ClaimProcessed(\n            _claimer,\n            rewardsForClaimer,\n            totalStakedAtFundBlockForClaimer,\n            newTotal\n        );\n    }\n\n    /**\n     * @notice Modify funding amount per round\n     * @param _newAmount - new amount to fund per round in wei\n     */\n    function updateFundingAmount(uint _newAmount)\n    external returns (uint newAmount)\n    {\n        require(\n            msg.sender == governanceAddress,\n            \"Only callable by Governance contract\"\n        );\n        fundingAmount = _newAmount;\n        return _newAmount;\n    }\n\n    /**\n     * @notice Returns boolean indicating whether a claim is considered pending\n     * @dev Note that an address with no endpoints can never have a pending claim\n     * @param _sp - address of the service provider to check\n     * @return boolean - true if eligible for claim, false if not\n     */\n    function claimPending(address _sp) external view returns (bool pending) {\n        uint lastClaimedForSP = Staking(stakingAddress).lastClaimedFor(_sp);\n        (,,,uint numEndpoints,,) = (\n            ServiceProviderFactory(serviceProviderFactoryAddress).getServiceProviderDetails(_sp)\n        );\n        return (lastClaimedForSP < currentRound.fundBlock && numEndpoints > 0);\n    }\n\n    /**\n     * @notice Modify minimum block difference between funding rounds\n     * @param _newFundingRoundBlockDiff - new min block difference to set\n     */\n    function updateFundingRoundBlockDiff(uint _newFundingRoundBlockDiff) external {\n        require(\n            msg.sender == governanceAddress,\n            \"Only callable by Governance contract\"\n        );\n        fundingRoundBlockDiff = _newFundingRoundBlockDiff;\n    }\n}"
    },
    {
      "filename": "eth-contracts/contracts/ServiceTypeManager.sol",
      "content": "pragma solidity ^0.5.0;\n\nimport \"./InitializableV2.sol\";\n\n\ncontract ServiceTypeManager is InitializableV2 {\n    address governanceAddress;\n\n    /**\n     * @dev - mapping of serviceType - serviceTypeVersion\n     * Example - \"discovery-provider\" - [\"0.0.1\", \"0.0.2\", ..., \"currentVersion\"]\n     */\n    mapping(bytes32 => bytes32[]) public serviceTypeVersions;\n\n    /**\n     * @dev - mapping of serviceType - < serviceTypeVersion, isValid >\n     * Example - \"discovery-provider\" - <\"0.0.1\", true>\n     */\n    mapping(bytes32 => mapping(bytes32 => bool)) public serviceTypeVersionInfo;\n\n    /// @dev List of valid service types\n    bytes32[] private validServiceTypes;\n\n    /// @dev Struct representing service type stake requirements\n    struct ServiceTypeStakeRequirements {\n        uint minStake;\n        uint maxStake;\n    }\n\n    /// @dev mapping of service type to registered requirements\n    mapping(bytes32 => ServiceTypeStakeRequirements) serviceTypeStakeRequirements;\n\n    event SetServiceVersion(bytes32 _serviceType, bytes32 _serviceVersion);\n    event Test(string msg, bool value);\n    event TestAddr(string msg, address addr);\n\n    /**\n     * @notice Function to initialize the contract\n     * @param _governanceAddress - Governance proxy address\n     */\n    function initialize(address _governanceAddress) public initializer\n    {\n        governanceAddress = _governanceAddress;\n        InitializableV2.initialize();\n    }\n\n    /// @notice Get the Governance address\n    function getGovernanceAddress() external view returns (address addr) {\n        return governanceAddress;\n    }\n\n    /**\n     * @notice Set the Governance address\n     * @dev Only callable by Governance address\n     * @param _governanceAddress - address for new Governance contract\n     */\n    function setGovernanceAddress(address _governanceAddress) external {\n        require(msg.sender == governanceAddress, \"Only governance\");\n        governanceAddress = _governanceAddress;\n    }\n\n    // ========================================= Service Type Logic =========================================\n\n    /// @notice Add a new service type\n    /**\n     * @notice Add a new service type\n     * @param _serviceType - type of service to add\n     * @param _serviceTypeMin - minimum stake for service type\n     * @param _serviceTypeMax - maximum stake for service type\n     */\n    function addServiceType(\n        bytes32 _serviceType,\n        uint _serviceTypeMin,\n        uint _serviceTypeMax\n    ) external\n    {\n        _requireIsInitialized();\n\n        require(msg.sender == governanceAddress, \"Only callable by Governance contract\");\n        require(!this.serviceTypeIsValid(_serviceType), \"Already known service type\");\n\n        validServiceTypes.push(_serviceType);\n        serviceTypeStakeRequirements[_serviceType] = ServiceTypeStakeRequirements({\n            minStake: _serviceTypeMin,\n            maxStake: _serviceTypeMax\n        });\n    }\n\n    /**\n     * @notice Remove an existing service type\n     * @param _serviceType - name of service type to remove\n     */\n    function removeServiceType(bytes32 _serviceType) external {\n        _requireIsInitialized();\n\n        require(msg.sender == governanceAddress, \"Only callable by Governance contract\");\n\n        uint serviceIndex = 0;\n        bool foundService = false;\n        for (uint i = 0; i < validServiceTypes.length; i ++) {\n            if (validServiceTypes[i] == _serviceType) {\n                serviceIndex = i;\n                foundService = true;\n                break;\n            }\n        }\n        require(foundService == true, \"Invalid service type, not found\");\n        // Overwrite service index\n        uint lastIndex = validServiceTypes.length - 1;\n        validServiceTypes[serviceIndex] = validServiceTypes[lastIndex];\n        validServiceTypes.length--;\n        // Overwrite values\n        serviceTypeStakeRequirements[_serviceType].minStake = 0;\n        serviceTypeStakeRequirements[_serviceType].maxStake = 0;\n    }\n\n    /**\n     * @notice Update a service type\n     * @param _serviceType - type of service\n     * @param _serviceTypeMin - minimum stake for service type\n     * @param _serviceTypeMax - maximum stake for service type\n     */\n    function updateServiceType(\n        bytes32 _serviceType,\n        uint _serviceTypeMin,\n        uint _serviceTypeMax\n    ) external\n    {\n        _requireIsInitialized();\n        require(\n            msg.sender == governanceAddress,\n            \"Only callable by Governance contract\"\n        );\n\n        require(this.serviceTypeIsValid(_serviceType), \"Invalid service type\");\n\n        serviceTypeStakeRequirements[_serviceType].minStake = _serviceTypeMin;\n        serviceTypeStakeRequirements[_serviceType].maxStake = _serviceTypeMax;\n    }\n\n    /**\n     * @notice Get min and max stake for a given service type\n     * @param _serviceType - type of service\n     * @return min and max stake for type\n     */\n    function getServiceTypeStakeInfo(bytes32 _serviceType)\n    external view returns (uint min, uint max)\n    {\n        return (\n            serviceTypeStakeRequirements[_serviceType].minStake,\n            serviceTypeStakeRequirements[_serviceType].maxStake\n        );\n    }\n\n    /**\n     * @notice Get list of valid service types\n     */\n    function getValidServiceTypes()\n    external view returns (bytes32[] memory types)\n    {\n        return validServiceTypes;\n    }\n\n    /**\n     * @notice Return indicating whether this is a valid service type\n     */\n    function serviceTypeIsValid(bytes32 _serviceType)\n    external view returns (bool isValid)\n    {\n        return serviceTypeStakeRequirements[_serviceType].maxStake > 0;\n    }\n\n    // ========================================= Service Version Logic =========================================\n\n    /**\n     * @notice Add new version for a serviceType\n     * @param _serviceType - type of service\n     * @param _serviceVersion - new version of service to add\n     */\n    function setServiceVersion(\n        bytes32 _serviceType,\n        bytes32 _serviceVersion\n    ) external\n    {\n        _requireIsInitialized();\n\n        require(msg.sender == governanceAddress, \"Only callable by Governance contract\");\n\n        require(\n            serviceTypeVersionInfo[_serviceType][_serviceVersion] == false,\n            \"Already registered\"\n        );\n\n         // Update array of known types\n        serviceTypeVersions[_serviceType].push(_serviceVersion);\n\n        // Update status for this specific service version\n        serviceTypeVersionInfo[_serviceType][_serviceVersion] = true;\n\n        emit SetServiceVersion(_serviceType, _serviceVersion);\n    }\n\n    /**\n     * @notice Get a version for a service type given it's index\n     * @param _serviceType - type of service\n     * @param _versionIndex - index in list of service versions\n     */\n    function getVersion(bytes32 _serviceType, uint _versionIndex)\n    external view returns (bytes32 version)\n    {\n        require(\n            serviceTypeVersions[_serviceType].length > _versionIndex,\n            \"No registered version of serviceType\"\n        );\n        return (serviceTypeVersions[_serviceType][_versionIndex]);\n    }\n\n    /**\n     * @notice Get curent version for a service type\n     * @param _serviceType - type of service\n     * @return Returns current version of service\n     */\n    function getCurrentVersion(bytes32 _serviceType)\n    external view returns (bytes32 currentVersion)\n    {\n        require(\n            serviceTypeVersions[_serviceType].length >= 1,\n            \"No registered version of serviceType\"\n        );\n        uint latestVersionIndex = serviceTypeVersions[_serviceType].length - 1;\n        return (serviceTypeVersions[_serviceType][latestVersionIndex]);\n    }\n\n    /**\n     * @notice Get total number of versions for a service type\n     * @param _serviceType - type of service\n     */\n    function getNumberOfVersions(bytes32 _serviceType)\n    external view returns (uint)\n    {\n        return serviceTypeVersions[_serviceType].length;\n    }\n\n    /**\n     * @notice Return boolean indicating whether given version is valid for given type\n     * @param _serviceType - type of service\n     * @param _serviceVersion - version of service to check\n     */\n    function serviceVersionIsValid(bytes32 _serviceType, bytes32 _serviceVersion)\n    external view returns (bool isValidServiceVersion)\n    {\n        return serviceTypeVersionInfo[_serviceType][_serviceVersion];\n    }\n}"
    },
    {
      "filename": "eth-contracts/contracts/ServiceProviderFactory.sol",
      "content": "pragma solidity ^0.5.0;\n\nimport \"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\";\nimport \"./ServiceTypeManager.sol\";\nimport \"./ClaimsManager.sol\";\nimport \"./Staking.sol\";\n\n\ncontract ServiceProviderFactory is InitializableV2 {\n    using SafeMath for uint;\n\n    address private stakingAddress;\n    address private delegateManagerAddress;\n    address private governanceAddress;\n    address private serviceTypeManagerAddress;\n    address private claimsManagerAddress;\n    uint private decreaseStakeLockupDuration;\n\n    /// @dev - Stores following entities\n    ///        1) Directly staked amount by SP, not including delegators\n    ///        2) % Cut of delegator tokens taken during reward\n    ///        3) Bool indicating whether this SP has met min/max requirements\n    ///        4) Number of endpoints registered by SP\n    ///        5) Minimum total stake for this account\n    ///        6) Maximum total stake for this account\n    struct ServiceProviderDetails {\n        uint deployerStake;\n        uint deployerCut;\n        bool validBounds;\n        uint numberOfEndpoints;\n        uint minAccountStake;\n        uint maxAccountStake;\n    }\n\n    /// @dev - Data structure for time delay during withdrawal\n    struct DecreaseStakeRequest {\n        uint decreaseAmount;\n        uint lockupExpiryBlock;\n    }\n\n    /// @dev - Mapping of service provider address to details\n    mappi"
    }
  ]
}