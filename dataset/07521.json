{
  "Title": "[H-09] UniswapV3 tokens of certain pairs will be wrongly valued, leading to liquidations",
  "Content": "\n<https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/UniswapV3OracleWrapper.sol#L245>\n\nUniswapV3OracleWrapper is responsible for price feed of UniswapV3 NFT tokens. Its getTokenPrice() is used by the health check calculation in GenericLogic.\n\ngetTokenPrice gets price from the oracle and then uses it to calculate value of its liquidity.\n\n    function getTokenPrice(uint256 tokenId) public view returns (uint256) {\n        UinswapV3PositionData memory positionData = getOnchainPositionData(\n            tokenId\n        );\n        PairOracleData memory oracleData = _getOracleData(positionData);\n        (uint256 liquidityAmount0, uint256 liquidityAmount1) = LiquidityAmounts\n            .getAmountsForLiquidity(\n                oracleData.sqrtPriceX96,\n                TickMath.getSqrtRatioAtTick(positionData.tickLower),\n                TickMath.getSqrtRatioAtTick(positionData.tickUpper),\n                positionData.liquidity\n            );\n        (\n            uint256 feeAmount0,\n            uint256 feeAmount1\n        ) = getLpFeeAmountFromPositionData(positionData);\n        return\n            (((liquidityAmount0 + feeAmount0) * oracleData.token0Price) /\n                10**oracleData.token0Decimal) +\n            (((liquidityAmount1 + feeAmount1) * oracleData.token1Price) /\n                10**oracleData.token1Decimal);\n    }\n\nIn `_getOracleData`,  sqrtPriceX96 of the holding is calculated, using square root of token0Price and token1Price, corrected for difference in decimals. In case they have same decimals, this is the calculation:\n\n    if (oracleData.token1Decimal == oracleData.token0Decimal) {\n        // multiply by 10^18 then divide by 10^9 to preserve price in wei\n        oracleData.sqrtPriceX96 = uint160(\n            (SqrtLib.sqrt(\n                ((oracleData.token0Price * (10**18)) /\n                    (oracleData.token1Price))\n            ) * 2**96) / 1E9\n        );\n\nThe issue is that the inner calculation, could be 0, making the whole expression zero, although price is not.\n\n    ((oracleData.token0Price * (10**18)) /\n                            (oracleData.token1Price))\n\nThis expression will be 0 if `oracleData.token1Price > token0Price * 10**18`. This is not far fetched, as there is massive difference in prices of different ERC20 tokens due to tokenomic models. For example, WETH (18 decimals) is `$1300`, while BTT (18 decimals) is `$0.00000068`.\n\nThe price is represented using X96 type, so there is plenty of room to fit the price between two tokens of different values. It is just that the number is multiplied by 2&ast;&ast;96 too late in the calculation, after the division result is zero.\n\nBack in getTokenPrice, the sqrtPriceX96 parameter which can be zero, is passed to `LiquidityAmounts.getAmountsForLiquidity()` to get liquidity values. In case price is zero, the liquidity calculator will assume all holdings are amount0, while in reality they could be all amount1, or a combination of the two.\n\n    function getAmountsForLiquidity(\n        uint160 sqrtRatioX96,\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint128 liquidity\n    ) internal pure returns (uint256 amount0, uint256 amount1) {\n        if (sqrtRatioAX96 > sqrtRatioBX96)\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n        if (sqrtRatioX96 <= sqrtRatioAX96) { <- Always drop here when 0\n            amount0 = getAmount0ForLiquidity(\n                sqrtRatioAX96,\n                sqrtRatioBX96,\n                liquidity\n            );\n        } else if (sqrtRatioX96 < sqrtRatioBX96) {\n            amount0 = getAmount0ForLiquidity(\n                sqrtRatioX96,\n                sqrtRatioBX96,\n                liquidity\n            );\n            amount1 = getAmount1ForLiquidity(\n                sqrtRatioAX96,\n                sqrtRatioX96,\n                liquidity\n            );\n        } else {\n            amount1 = getAmount1ForLiquidity(\n                sqrtRatioAX96,\n                sqrtRatioBX96,\n                liquidity\n            );\n        }\n    }\n\nSince amount0 is the lower value between the two, it is easy to see that the calculated liquidity value will be much smaller than it should be, and as a result the entire Uniswapv3 holding is valuated much lower than it should. Ultimately, it will cause liquidation the moment the ratio between some uniswap pair goes over 10&ast;&ast;18.\n\nFor the sake of completeness, healthFactor is calculated by  `calculateUserAccountData`, which calls `_getUserBalanceForUniswapV3`, which queries the oracle with `_getTokenPrice`.\n\n### Impact\n\nUniswapV3 tokens of certain pairs will be wrongly valued, leading to liquidations.\n\n### Proof of Concept\n\n1.  Alice deposits a uniswap v3 liquidity token as collateral in ParaSpace (Pair A/B)\n2.  Value of B rises in comparison to A. Now PriceB = PriceA &ast; 10&ast;&ast;18\n3.  sqrtPrice resolves to 0, and entire liquidity is taken as A liquidity. In reality, price is between tickUpper and tickLower of the uniswap token. B tokens are not taken into consideration.\n4.  Liquidator Luke initiates liquidation of Alice. Alice may lose her NFT collateral although she has kept her position healthy.\n\n### Recommended Mitigation Steps\n\nMultiply by 2&ast;&ast;96 before the division operation in sqrtPriceX96 calculation.\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/contests/2022-11-paraspace-contest",
  "Code": [
    {
      "filename": "paraspace-core/contracts/misc/UniswapV3OracleWrapper.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {IUniswapV3OracleWrapper} from \"../interfaces/IUniswapV3OracleWrapper.sol\";\nimport {IPoolAddressesProvider} from \"../interfaces/IPoolAddressesProvider.sol\";\nimport {IPriceOracleGetter} from \"../interfaces/IPriceOracleGetter.sol\";\nimport {IUniswapV3Factory} from \"../dependencies/uniswap/IUniswapV3Factory.sol\";\nimport {IUniswapV3PoolState} from \"../dependencies/uniswap/IUniswapV3PoolState.sol\";\nimport {INonfungiblePositionManager} from \"../dependencies/uniswap/INonfungiblePositionManager.sol\";\nimport {LiquidityAmounts} from \"../dependencies/uniswap/LiquidityAmounts.sol\";\nimport {TickMath} from \"../dependencies/uniswap/libraries/TickMath.sol\";\nimport {SqrtLib} from \"../dependencies/math/SqrtLib.sol\";\nimport {FullMath} from \"../dependencies/uniswap/libraries/FullMath.sol\";\nimport {IERC20Detailed} from \"../dependencies/openzeppelin/contracts/IERC20Detailed.sol\";\nimport {UinswapV3PositionData} from \"../interfaces/IUniswapV3PositionInfoProvider.sol\";\n\ncontract UniswapV3OracleWrapper is IUniswapV3OracleWrapper {\n    IUniswapV3Factory immutable UNISWAP_V3_FACTORY;\n    INonfungiblePositionManager immutable UNISWAP_V3_POSITION_MANAGER;\n    IPoolAddressesProvider public immutable ADDRESSES_PROVIDER;\n    uint256 internal constant Q128 = 0x100000000000000000000000000000000;\n\n    constructor(\n        address _factory,\n        address _manager,\n        address _addressProvider\n    ) {\n        UNISWAP_V3_FACTORY = IUniswapV3Factory(_factory);\n        UNISWAP_V3_POSITION_MANAGER = INonfungiblePositionManager(_manager);\n        ADDRESSES_PROVIDER = IPoolAddressesProvider(_addressProvider);\n    }\n\n    struct FeeParams {\n        uint256 feeGrowthOutside0X128Lower;\n        uint256 feeGrowthOutside1X128Lower;\n        uint256 feeGrowthOutside0X128Upper;\n        uint256 feeGrowthOutside1X128Upper;\n    }\n\n    struct PairOracleData {\n        uint256 token0Price;\n        uint256 token1Price;\n        uint8 token0Decimal;\n        uint8 token1Decimal;\n        uint160 sqrtPriceX96;\n    }\n\n    /**\n     * @notice get onchain position data from uniswap for the specified tokenId.\n     */\n    function getOnchainPositionData(uint256 tokenId)\n        public\n        view\n        returns (UinswapV3PositionData memory)\n    {\n        (\n            ,\n            ,\n            address token0,\n            address token1,\n            uint24 fee,\n            int24 tickLower,\n            int24 tickUpper,\n            uint128 liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint256 tokensOwed0,\n            uint256 tokensOwed1\n        ) = UNISWAP_V3_POSITION_MANAGER.positions(tokenId);\n\n        IUniswapV3PoolState pool = IUniswapV3PoolState(\n            UNISWAP_V3_FACTORY.getPool(token0, token1, fee)\n        );\n        (uint160 currentPrice, int24 currentTick, , , , , ) = pool.slot0();\n\n        return\n            UinswapV3PositionData({\n                token0: token0,\n                token1: token1,\n                fee: fee,\n                tickLower: tickLower,\n                tickUpper: tickUpper,\n                currentTick: currentTick,\n                currentPrice: currentPrice,\n                liquidity: liquidity,\n                feeGrowthInside0LastX128: feeGrowthInside0LastX128,\n                feeGrowthInside1LastX128: feeGrowthInside1LastX128,\n                tokensOwed0: tokensOwed0,\n                tokensOwed1: tokensOwed1\n            });\n    }\n\n    /**\n     * @notice get onchain liquidity amount for the specified tokenId.\n     */\n    function getLiquidityAmount(uint256 tokenId)\n        external\n        view\n        returns (uint256 token0Amount, uint256 token1Amount)\n    {\n        UinswapV3PositionData memory positionData = getOnchainPositionData(\n            tokenId\n        );\n        (token0Amount, token1Amount) = getLiquidityAmountFromPositionData(\n            positionData\n        );\n    }\n\n    /**\n     * @notice calculate liquidity amount for the position data.\n     * @param positionData The specified position data\n     */\n    function getLiquidityAmountFromPositionData(\n        UinswapV3PositionData memory positionData\n    ) public pure returns (uint256 token0Amount, uint256 token1Amount) {\n        (token0Amount, token1Amount) = LiquidityAmounts.getAmountsForLiquidity(\n            positionData.currentPrice,\n            TickMath.getSqrtRatioAtTick(positionData.tickLower),\n            TickMath.getSqrtRatioAtTick(positionData.tickUpper),\n            positionData.liquidity\n        );\n    }\n\n    /**\n     * @notice get liquidity provider fee amount for the specified tokenId.\n     */\n    function getLpFeeAmount(uint256 tokenId)\n        external\n        view\n        returns (uint256 token0Amount, uint256 token1Amount)\n    {\n        UinswapV3PositionData memory positionData = getOnchainPositionData(\n            tokenId\n        );\n        (token0Amount, token1Amount) = getLpFeeAmountFromPositionData(\n            positionData\n        );\n    }\n\n    /**\n     * @notice calculate liquidity provider fee amount for the position data.\n     * @param positionData The specified position data\n     */\n    function getLpFeeAmountFromPositionData(\n        UinswapV3PositionData memory positionData\n    ) public view returns (uint256 token0Amount, uint256 token1Amount) {\n        (token0Amount, token1Amount) = _getPendingFeeAmounts(positionData);\n\n        token0Amount += positionData.tokensOwed0;\n        token1Amount += positionData.tokensOwed1;\n    }\n\n    /**\n     * @notice Returns the price for the specified tokenId.\n     */\n    function getTokenPrice(uint256 tokenId) public view returns (uint256) {\n        UinswapV3PositionData memory positionData = getOnchainPositionData(\n            tokenId\n        );\n\n        PairOracleData memory oracleData = _getOracleData(positionData);\n\n        (uint256 liquidityAmount0, uint256 liquidityAmount1) = LiquidityAmounts\n            .getAmountsForLiquidity(\n                oracleData.sqrtPriceX96,\n                TickMath.getSqrtRatioAtTick(positionData.tickLower),\n                TickMath.getSqrtRatioAtTick(positionData.tickUpper),\n                positionData.liquidity\n            );\n\n        (\n            uint256 feeAmount0,\n            uint256 feeAmount1\n        ) = getLpFeeAmountFromPositionData(positionData);\n\n        return\n            (((liquidityAmount0 + feeAmount0) * oracleData.token0Price) /\n                10**oracleData.token0Decimal) +\n            (((liquidityAmount1 + feeAmount1) * oracleData.token1Price) /\n                10**oracleData.token1Decimal);\n    }\n\n    /**\n     * @notice Returns the price for the specified tokenId array.\n     */\n    function getTokensPrices(uint256[] calldata tokenIds)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        uint256[] memory prices = new uint256[](tokenIds.length);\n\n        for (uint256 index = 0; index < tokenIds.length; index++) {\n            prices[index] = getTokenPrice(tokenIds[index]);\n        }\n\n        return prices;\n    }\n\n    /**\n     * @notice Returns the total price for the specified tokenId array.\n     */\n    function getTokensPricesSum(uint256[] calldata tokenIds)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 sum = 0;\n\n        for (uint256 index = 0; index < tokenIds.length; index++) {\n            sum += getTokenPrice(tokenIds[index]);\n        }\n\n        return sum;\n    }\n\n    function latestAnswer() external pure returns (int256) {\n        revert(\"unimplemented\");\n    }\n\n    function _getOracleData(UinswapV3PositionData memory positionData)\n        internal\n        view\n        returns (PairOracleData memory)\n    {\n        PairOracleData memory oracleData;\n        IPriceOracleGetter oracle = IPriceOracleGetter(\n            ADDRESSES_PROVIDER.getPriceOracle()\n        );\n        oracleData.token0Price = oracle.getAssetPrice(positionData.token0);\n        oracleData.token1Price = oracle.getAssetPrice(positionData.token1);\n\n        oracleData.token0Decimal = IERC20Detailed(positionData.token0)\n            .decimals();\n        oracleData.token1Decimal = IERC20Detailed(positionData.token1)\n            .decimals();\n\n        // TODO using bit shifting for the 2^96\n        // positionData.sqrtPriceX96;\n\n        if (oracleData.token1Decimal == oracleData.token0Decimal) {\n            // multiply by 10^18 then divide by 10^9 to preserve price in wei\n            oracleData.sqrtPriceX96 = uint160(\n                (SqrtLib.sqrt(\n                    ((oracleData.token0Price * (10**18)) /\n                        (oracleData.token1Price))\n                ) * 2**96) / 1E9\n            );\n        } else if (oracleData.token1Decimal > oracleData.token0Decimal) {\n            // multiple by 10^(decimalB - decimalA) to preserve price in wei\n            oracleData.sqrtPriceX96 = uint160(\n                (SqrtLib.sqrt(\n                    (oracleData.token0Price *\n                        (10 **\n                            (18 +\n                                oracleData.token1Decimal -\n                                oracleData.token0Decimal))) /\n                        (oracleData.token1Price)\n                ) * 2**96) / 1E9\n            );\n        } else {\n            // multiple by 10^(decimalA - decimalB) to preserve price in wei then divide by the same number\n            oracleData.sqrtPriceX96 = uint160(\n                (SqrtLib.sqrt(\n                    (oracleData.token0Price *\n                        (10 **\n                            (18 +\n                                oracleData.token0Decimal -\n                                oracleData.token1Decimal))) /\n                        (oracleData.token1Price)\n                ) * 2**96) /\n                    10 **\n                        (9 +\n                            oracleData.token0Decimal -\n                            oracleData.token1Decimal)\n            );\n        }\n\n        return oracleData;\n    }\n\n    function _getPendingFeeAmounts(UinswapV3PositionData memory positionData)\n        internal\n        view\n        returns (uint256 token0Amount, uint256 token1Amount)\n    {\n        IUniswapV3PoolState pool = IUniswapV3PoolState(\n            UNISWAP_V3_FACTORY.getPool(\n                positionData.token0,\n                positionData.token1,\n                positionData.fee\n            )\n        );\n        FeeParams memory feeParams;\n\n        (\n            ,\n            ,\n            feeParams.feeGrowthOutside0X128Lower,\n            feeParams.feeGrowthOutside1X128Lower,\n            ,\n            ,\n            ,\n\n        ) = pool.ticks(positionData.tickLower);\n        (\n            ,\n            ,\n            feeParams.feeGrowthOutside0X128Upper,\n            feeParams.feeGrowthOutside1X128Upper,\n            ,\n            ,\n            ,\n\n        ) = pool.ticks(positionData.tickUpper);\n\n        uint256 feeGrowthGlobal0X128 = pool.feeGrowthGlobal0X128();\n        uint256 feeGrowthGlobal1X128 = pool.feeGrowthGlobal1X128();\n\n        unchecked {\n            // calculate fee growth below\n            uint256 feeGrowthBelow0X128;\n            uint256 feeGrowthBelow1X128;\n            if (positionData.currentTick >= positionData.tickLower) {\n                feeGrowthBelow0X128 = feeParams.feeGrowthOutside0X128Lower;\n                feeGrowthBelow1X128 = feeParams.feeGrowthOutside1X128Lower;\n            } else {\n                feeGrowthBelow0X128 =\n                    feeGrowthGlobal0X128 -\n                    feeParams.feeGrowthOutside0X128Lower;\n                feeGrowthBelow1X128 =\n                    feeGrowthGlobal1X128 -\n                    feeParams.feeGrowthOutside1X128Lower;\n            }\n\n            // calculate fee growth above\n            uint256 feeGrowthAbove0X128;\n            uint256 feeGrowthAbove1X128;\n            if (positionData.currentTick < positionData.tickUpper) {\n                feeGrowthAbove0X128 = feeParams.feeGrowthOutside0X128Upper;\n                feeGrowthAbove1X128 = feeParams.feeGrowthOutside1X128Upper;\n            } else {\n                feeGrowthAbove0X128 =\n                    feeGrowthGlobal0X128 -\n                    feeParams.feeGrowthOutside0X128Upper;\n                feeGrowthAbove1X128 =\n                    feeGrowthGlobal1X128 -\n                    feeParams.feeGrowthOutside1X128Upper;\n            }\n            uint256 feeGrowthInside0X128;\n            uint256 feeGrowthInside1X128;\n\n            feeGrowthInside0X128 =\n                feeGrowthGlobal0X128 -\n                feeGrowthBelow0X128 -\n                feeGrowthAbove0X128;\n            feeGrowthInside1X128 =\n                feeGrowthGlobal1X128 -\n                feeGrowthBelow1X128 -\n                feeGrowthAbove1X128;\n\n            token0Amount = uint128(\n                FullMath.mulDiv(\n                    feeGrowthInside0X128 -\n                        positionData.feeGrowthInside0LastX128,\n                    positionData.liquidity,\n                    Q128\n                )\n            );\n\n            token1Amount = uint128(\n                FullMath.mulDiv(\n                    feeGrowthInside1X128 -\n                        positionData.feeGrowthInside1LastX128,\n                    positionData.liquidity,\n                    Q128\n                )\n            );\n        }\n    }\n}"
    }
  ]
}