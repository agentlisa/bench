{
  "Title": "M-1: Risk of Unfair Order Execution Price in `_validateOrdersAndDetermineFillPrice` Function",
  "Content": "# Issue M-1: Risk of Unfair Order Execution Price in `_validateOrdersAndDetermineFillPrice` Function \n\nSource: https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/8 \n\n## Found by \nmoneyversed\n## Summary\n\nWhile the system seems to have appropriate checks in place for order matching, a potential risk exists around the order execution pricing logic, specifically when the orders are placed in the same block. In such cases, the system currently selects the sell order price as the fill price. This may not be fair for the buyer, who may end up paying more than necessary.\n\n## Vulnerability Detail\n\nIn the `_validateOrdersAndDetermineFillPrice` function, when two orders are placed in the same block, the fill price is set as the price of the sell order (orders[1]). This is potentially unfair because it could lead to a scenario where the buyer is paying the maximum possible price, even when the sell order was potentially willing to sell at a lower price. \n\n## Impact\n\nThis could affect the trust of participants in the exchange, particularly those who frequently make buy orders. The unfair pricing might result in monetary losses for these participants, leading to a negative perception of the platform.\n\n## Code Snippet\n\n```solidity\n        if (blockPlaced0 < blockPlaced1) {\n            mode0 = OrderExecutionMode.Maker;\n            fillPrice = orders[0].price;\n        } else if (blockPlaced0 > blockPlaced1) {\n            mode1 = OrderExecutionMode.Maker;\n            fillPrice = orders[1].price;\n        } else { // both orders are placed in the same block, not possible to determine what came first in solidity\n            // executing both orders as taker order\n            mode0 = OrderExecutionMode.SameBlock;\n            mode1 = OrderExecutionMode.SameBlock;\n            // Bulls (Longs) are our friends. We give them a favorable price in this corner case\n            fillPrice = orders[1].price;\n        }\n```\n\nhttps://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/orderbooks/OrderBook.sol#L288-L300\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nA more fair approach might be to calculate the average of the buy order and sell order prices, which might better reflect the market conditions at the moment both orders were made. In case of any restrictions for using the average price, a price setting rule that better approximates a fair market price should be used.\n\n## Proof Of Concept\n\nTo reproduce this vulnerability:\n\n1. Deploy the smart contract on a local testnet or Ethereum mainnet fork.\n2. Place two orders: a buy order and a sell order within the same block with different prices.\n3. Once the orders are matched and executed, check the execution price.\n4. You will notice that the execution price is exactly the same as the sell order, regardless of the buy order's price.\n\nNote: This is a potential risk, meaning that it depends on the intentions of the traders when they place their orders. Traders who are willing to trade at the execution price would not consider this a problem, while others might see it as an unfair pricing practice.\n\n\n\n## Discussion\n\n**asquare08**\n\nIn the case of same block trade, shorts are selling at the price they quoted and longs are buying at price â‰¤ long order price. As it is a limit order system, the user get to decide the price of the order and  they are always getting a better or the same price than what they quoted. There is no scenario where a user is getting unfair/worst price.\n\n**ctf-sec**\n\nAlthough the issue has sponsor dispute tag, I am more incline with the watson and leave this as a medium issue\n\nBecause\n\n> When a validator is selected as the block producer, the buildBlock function fetches active markets and open orders from the indexer, evaluates open positions for potential liquidations, runs the matching engine, and then relays these operations as local transactions before continuing the normal transaction bundling process.\n\nthe block producer may determine the order matching and manipulate who is order[0] and who is order[1] to extract value\n\n```solidity\n{ // both orders are placed in the same block, not possible to determine what came first in solidity\n            // executing both orders as taker order\n            mode0 = OrderExecutionMode.SameBlock;\n            mode1 = OrderExecutionMode.SameBlock;\n            // Bulls (Longs) are our friends. We give them a favorable price in this corner case\n            fillPrice = orders[1].price;\n        }\n```\n\nWant to quote the first second in the report: \n\nhttps://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/183\n\n> Validators are given the exclusive privilege to match.\n\n**asquare08**\n\nYes correct validator can extract MEV from this by opening longs at better price everytime. Changed status to confirmed. \nFYI: Fill price determination happens through precompile now and long order is executed as taker and short as maker (maker fee is less than taker fee). So long will get better price but pay more fee and short order will execute at order price but pay less fee\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/72",
  "Code": [
    {
      "filename": "hubble-protocol/contracts/orderbooks/OrderBook.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.9;\n\nimport { ECDSAUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol\";\nimport { EIP712Upgradeable } from \"@openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol\";\nimport { Pausable } from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport { VanillaGovernable } from \"../legos/Governable.sol\";\nimport { IClearingHouse, IOrderBook, IAMM, IMarginAccount } from \"../Interfaces.sol\";\nimport { IHubbleBibliophile } from \"../precompiles/IHubbleBibliophile.sol\";\n\n/**\n * @title Takes care of order placement, matching, cancellations and liquidations.\n *        Mostly has only first level checks about validatiy of orders. More deeper checks and interactions happen in ClearingHouse.\n * @notice This contract is used by users to place/cancel orders and by validators to relay matched/liquidation orders\n * @dev At several places we are using something called a bibliophile. This is a special contract (precompile) that is deployed at a specific address.\n * But there is identical code in this contract that can be used as a fallback if the precompile is not available.\n*/\ncontract OrderBook is IOrderBook, VanillaGovernable, Pausable, EIP712Upgradeable {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n\n    // keccak256(\"Order(uint256 ammIndex,address trader,int256 baseAssetQuantity,uint256 price,uint256 salt,bool reduceOnly)\");\n    bytes32 public constant ORDER_TYPEHASH = 0x0a2e4d36552888a97d5a8975ad22b04e90efe5ea0a8abb97691b63b431eb25d2;\n    string constant NOT_IS_MULTIPLE = \"OB.not_multiple\";\n\n    IClearingHouse public immutable clearingHouse;\n    IMarginAccount public immutable marginAccount;\n\n    mapping(bytes32 => OrderInfo) public orderInfo; // SLOT_53 !!! used in precompile !!!\n    mapping(address => bool) public isValidator; // SLOT_54 (not used in precompile)\n\n    /**\n    * @notice maps the address of the trader to the amount of reduceOnlyAmount for each amm\n    * trader => ammIndex => reduceOnlyAmount\n    */\n    mapping(address => mapping(uint => int256)) public reduceOnlyAmount;\n\n    // cache some variables for quick assertions\n    int256[] public minSizes; // min size for each AMM, array index is the ammIndex\n    uint public minAllowableMargin;\n    uint public takerFee;\n    IHubbleBibliophile public bibliophile;\n\n    uint256 public useNewPricingAlgorithm; // declared as uint256 to take 1 full slot\n    uint256[49] private __gap;\n\n    modifier onlyValidator {\n        require(isValidator[msg.sender], \"OB.only_validator\");\n        _;\n    }\n\n    modifier onlyClearingHouse {\n        require(msg.sender == address(clearingHouse), \"OB.only_clearingHouse\");\n        _;\n    }\n\n    constructor(address _clearingHouse, address _marginAccount) {\n        clearingHouse = IClearingHouse(_clearingHouse);\n        marginAccount = IMarginAccount(_marginAccount);\n    }\n\n    function initialize(\n        string memory _name,\n        string memory _version,\n        address _governance\n    ) external initializer {\n        __EIP712_init(_name, _version);\n        _setGovernace(_governance);\n    }\n\n    /* ****************** */\n    /*    Place Orders    */\n    /* ****************** */\n\n    /**\n     * @inheritdoc IOrderBook\n    */\n    function placeOrder(Order memory order) external {\n        Order[] memory _orders = new Order[](1);\n        _orders[0] = order;\n        placeOrders(_orders);\n    }\n\n    /**\n     * @inheritdoc IOrderBook\n    */\n    function placeOrders(Order[] memory orders) public whenNotPaused {\n        address trader = orders[0].trader;\n        int[] memory posSizes = _getPositionSizes(trader);\n        uint reserveAmount;\n        for (uint i = 0; i < orders.length; i++) {\n            require(orders[i].trader == trader, \"OB_trader_mismatch\");\n            reserveAmount += _placeOrder(orders[i], posSizes[orders[i].ammIndex]);\n        }\n        if (reserveAmount != 0) {\n            marginAccount.reserveMargin(trader, reserveAmount);\n        }\n    }\n\n    function _getPositionSizes(address trader) internal view returns (int[] memory) {\n        if (address(bibliophile) != address(0)) {\n            // precompile magic allows us to execute this for a fixed gas\n            return bibliophile.getPositionSizes(trader);\n        }\n        // folowing is the fallback code if precompile is not available. Precompile is intended to perform the same computation as the following code\n        uint numAmms = clearingHouse.getAmmsLength();\n        int[] memory posSizes = new int[](numAmms);\n        for (uint i; i < numAmms; ++i) {\n            (posSizes[i],,,) = IAMM(clearingHouse.amms(i)).positions(trader);\n        }\n        return posSizes;\n    }\n\n    /**\n     * @dev has some special handling for reduceOnly orders\n    */\n    function _placeOrder(Order memory order, int size) internal returns (uint reserveAmount) {\n        require(msg.sender == order.trader, \"OB_sender_is_not_trader\");\n\n        // orders should be multiple of pre-defined minimum quantity to prevent spam with dust orders\n        require(isMultiple(order.baseAssetQuantity, minSizes[order.ammIndex]), NOT_IS_MULTIPLE);\n\n        bytes32 orderHash = getOrderHash(order);\n        // order should not exist in the orderStatus map already\n        require(orderInfo[orderHash].status == OrderStatus.Invalid, \"OB_Order_already_exists\");\n\n        // reduce only orders should only reduce the position size. They need a bit of special handling.\n        if (order.reduceOnly) {\n            require(isOppositeSign(size, order.baseAssetQuantity), \"OB_reduce_only_order_must_reduce_position\");\n            // track the total size of all the reduceOnly orders for a trader in a particular market\n            reduceOnlyAmount[order.trader][order.ammIndex] += abs(order.baseAssetQuantity);\n            // total size of reduce only orders should not exceed the position size\n            require(abs(size) >= reduceOnlyAmount[order.trader][order.ammIndex], \"OB_reduce_only_amount_exceeded\");\n        } else {\n            /**\n            * Don't allow trade in opposite direction of existing position size if there is a reduceOnly order\n            * in case of liquidation, size == 0 && reduceOnlyAmount != 0 is possible\n            * in that case, we don't not allow placing a new order in any direction, must cancel reduceOnly order first\n            * in normal case, size = 0 => reduceOnlyAmount = 0\n            */\n            if (isOppositeSign(size, order.baseAssetQuantity) || size == 0) {\n                require(reduceOnlyAmount[order.trader][order.ammIndex] == 0, \"OB_cancel_reduce_only_order_first\");\n            }\n            // reserve margin for the order\n            reserveAmount = getRequiredMargin(order.baseAssetQuantity, order.price);\n        }\n\n        // add orderInfo for the corresponding orderHash\n        orderInfo[orderHash] = OrderInfo(block.number, 0, reserveAmount, OrderStatus.Placed);\n        emit OrderPlaced(order.trader, orderHash, order, block.timestamp);\n    }\n\n    /* ****************** */\n    /*    Cancel Orders   */\n    /* ****************** */\n\n    /**\n     * @inheritdoc IOrderBook\n    */\n    function cancelOrder(Order memory order) override external {\n        Order[] memory _orders = new Order[](1);\n        _orders[0] = order;\n        cancelOrders(_orders);\n    }\n\n    /**\n     * @inheritdoc IOrderBook\n    */\n    function cancelOrders(Order[] memory orders) override public {\n        address trader = orders[0].trader;\n        uint releaseMargin;\n        for (uint i; i < orders.length; i++) {\n            require(orders[i].trader == trader, \"OB_trader_mismatch\");\n            releaseMargin += _cancelOrder(orders[i]);\n        }\n        if (releaseMargin != 0) {\n            marginAccount.releaseMargin(trader, releaseMargin);\n        }\n    }\n\n    function _cancelOrder(Order memory order) internal returns (uint releaseMargin) {\n        bytes32 orderHash = getOrderHash(order);\n        require(orderInfo[orderHash].status == OrderStatus.Placed, \"OB_Order_does_not_exist\");\n\n        address trader = order.trader;\n        if (msg.sender != trader) {\n            require(isValidator[msg.sender], \"OB_invalid_sender\");\n            // allow cancellation of order by validator if availableMargin < 0\n            // there is more information in the description of the function\n            require(marginAccount.getAvailableMargin(trader) < 0, \"OB_available_margin_not_negative\");\n        }\n\n        orderInfo[orderHash].status = OrderStatus.Cancelled;\n        if (order.reduceOnly) {\n            int unfilledAmount = abs(order.baseAssetQuantity - orderInfo[orderHash].filledAmount);\n            reduceOnlyAmount[trader][order.ammIndex] -= unfilledAmount;\n        } else {\n            releaseMargin = orderInfo[orderHash].reservedMargin;\n        }\n\n        _deleteOrderInfo(orderHash);\n        emit OrderCancelled(trader, orderHash, block.timestamp);\n    }\n\n    /* ****************** */\n    /*    Match Orders    */\n    /* ****************** */\n\n    /**\n     * @inheritdoc IOrderBook\n    */\n    function executeMatchedOrders(\n        Order[2] memory orders,\n        int256 fillAmount\n    )   override\n        external\n        whenNotPaused\n        onlyValidator\n    {\n        MatchInfo[2] memory matchInfo;\n        matchInfo[0].orderHash = getOrderHash(orders[0]);\n        matchInfo[1].orderHash = getOrderHash(orders[1]);\n\n        uint fillPrice;\n        (fillPrice, matchInfo[0].mode, matchInfo[1].mode) = useNewPricingAlgorithm == 1 ?\n            bibliophile.validateOrdersAndDetermineFillPrice(orders, [matchInfo[0].orderHash, matchInfo[1].orderHash], fillAmount) :\n            // folowing is the fallback code if precompile is not available. Precompile is intended to perform the same computation as the following code\n            _validateOrdersAndDetermineFillPrice(orders, [matchInfo[0].orderHash, matchInfo[1].orderHash], fillAmount);\n\n        try clearingHouse.openComplementaryPositions(orders, matchInfo, fillAmount, fillPrice) returns (uint256 openInterestNotional) {\n            _updateOrder(orders[0], matchInfo[0].orderHash, fillAmount);\n            _updateOrder(orders[1], matchInfo[1].orderHash, -fillAmount);\n            emit OrdersMatched(\n                matchInfo[0].orderHash,\n                matchInfo[1].orderHash,\n                fillAmount.toUint256(), // asserts fillAmount is +ve\n                fillPrice,\n                openInterestNotional,\n                msg.sender, // relayer\n                block.timestamp\n            );\n        } catch Error(string memory err) { // catches errors emitted from \"revert/require\"\n            try this.parseMatchingError(err) returns(bytes32 orderHash, string memory reason) {\n                emit OrderMatchingError(orderHash, reason);\n            } catch (bytes memory) {\n                // abi.decode failed; we bubble up the original err\n                revert(err);\n            }\n            return;\n        }\n        /* catch (bytes memory err) {\n            we do not any special handling for other generic type errors\n            they can revert the entire tx as usual\n        } */\n    }\n\n    /**\n     * @dev validate orders and determines the fill price of the orders being matched\n     * @param orders orders[0] is the long order and orders[1] is the short order\n     * @param orderHashes output of getOrderHash(order)\n     * @param fillAmount Amount of base asset to be traded between the two orders. Should be +ve. Scaled by 1e18\n    */\n    function _validateOrdersAndDetermineFillPrice(\n        Order[2] memory orders,\n        bytes32[2] memory orderHashes,\n        int256 fillAmount\n    )   internal\n        view\n        returns (uint256 fillPrice, OrderExecutionMode mode0, OrderExecutionMode mode1)\n    {\n        // Checks and Effects\n        require(orders[0].baseAssetQuantity > 0, \"OB_order_0_is_not_long\");\n        require(orders[1].baseAssetQuantity < 0, \"OB_order_1_is_not_short\");\n        require(orders[0].ammIndex == orders[1].ammIndex, \"OB_orders_for_different_amms\");\n        require(orders[0].price /* buy */ >= orders[1].price /* sell */, \"OB_orders_do_not_match\");\n        require(orderInfo[orderHashes[0]].status == OrderStatus.Placed, \"OB_invalid_order\");\n        require(orderInfo[orderHashes[1]].status == OrderStatus.Placed, \"OB_invalid_order\");\n\n        // fillAmount should be multiple of min size requirement and fillAmount should be non-zero\n        require(isMultiple(fillAmount, minSizes[orders[0].ammIndex]), NOT_IS_MULTIPLE);\n\n        uint blockPlaced0 = orderInfo[orderHashes[0]].blockPlaced;\n        uint blockPlaced1 = orderInfo[orderHashes[1]].blockPlaced;\n\n        if (blockPlaced0 < blockPlaced1) {\n            mode0 = OrderExecutionMode.Maker;\n            fillPrice = orders[0].price;\n        } else if (blockPlaced0 > blockPlaced1) {\n            mode1 = OrderExecutionMode.Maker;\n            fillPrice = orders[1].price;\n        } else { // both orders are placed in the same block, not possible to determine what came first in solidity\n            // executing both orders as taker order\n            mode0 = OrderExecutionMode.SameBlock;\n            mode1 = OrderExecutionMode.SameBlock;\n            // Bulls (Longs) are our friends. We give them a favorable price in this corner case\n            fillPrice = orders[1].price;\n        }\n        _validateSpread(orders[0].ammIndex, fillPrice, false);\n    }\n\n    /**\n     * @dev Check whether a given price is within a pre-defined % deviation from the index price of the market.\n     * This is to prevent malicious actors from manipulating the price too much\n     * @param ammIndex Market index\n     * @param price chosen fill price\n     * @param isLiquidation whether we should assert for a liquidation match or regular order match, because liquidation has a tigher spread requirement\n    */\n    function _validateSpread(uint ammIndex, uint256 price, bool isLiquidation) internal view {\n        IAMM amm = IAMM(clearingHouse.amms(ammIndex));\n        uint spreadLimit = isLiquidation ? amm.maxLiquidationPriceSpread() : amm.maxOracleSpreadRatio();\n        uint256 oraclePrice = amm.getUnderlyingPrice();\n\n        uint bound = oraclePrice * (1e6 + spreadLimit) / 1e6;\n        require(price <= bound, \"AMM.price_GT_bound\");\n        // if spreadLimit >= 1e6 it means that 100% variation is allowed which means shorts at $0 will also pass.\n        // so we don't need to check for that case\n        if (spreadLimit < 1e6) {\n            bound = oraclePrice * (1e6 - spreadLimit) / 1e6;\n            require(price >= bound, \"AMM.price_LT_bound\");\n        }\n    }\n\n    /* ****************** */\n    /*    Liquidation     */\n    /* ****************** */\n\n    /**\n     * @inheritdoc IOrderBook\n    */\n    function liquidateAndExecuteOrder(\n        address trader,\n        Order calldata order,\n        uint256 liquidationAmount\n    )   override\n        external\n        whenNotPaused\n        onlyValidator\n    {\n        bytes32 orderHash = getOrderHash(order);\n        require(orderInfo[orderHash].status == OrderStatus.Placed, \"OB_invalid_order\");\n        uint fillPrice = useNewPricingAlgorithm == 1 ?\n            bibliophile.validateLiquidationOrderAndDetermineFillPrice(order, liquidationAmount.toInt256()) :\n            _validateLiquidationOrderAndDetermineFillPrice(order, liquidationAmount.toInt256());\n\n        int256 fillAmount = liquidationAmount.toInt256();\n        if (order.baseAssetQuantity < 0) { // order is short, so short position is being liquidated\n            fillAmount *= -1;\n        }\n\n        MatchInfo memory matchInfo = MatchInfo({\n            orderHash: orderHash,\n            mode: OrderExecutionMode.Maker // execute matching order as maker order\n        });\n\n        try clearingHouse.liquidate(order, matchInfo, fillAmount, fillPrice, trader) returns (uint256 openInterestNotional) {\n            _updateOrder(order, matchInfo.orderHash, fillAmount);\n            emit LiquidationOrderMatched(\n                trader,\n                matchInfo.orderHash,\n                liquidationAmount,\n                order.price,\n                openInterestNotional,\n                msg.sender, // relayer\n                block.timestamp\n            );\n        } catch Error(string memory err) { // catches errors emitted from \"revert/require\"\n            try this.parseMatchingError(err) returns(bytes32 _orderHash, string memory reason) {\n                if (matchInfo.orderHash == _orderHash) { // err in openPosition for the order\n                    emit OrderMatchingError(_orderHash, reason);\n                    reason = \"OrderMatchingError\";\n                } // else err in liquidating the trader; but we emit this either ways so that we can track liquidation didnt succeed for whatever reason\n                emit LiquidationError(trader, _orderHash, reason, liquidationAmount);\n            } catch (bytes memory) {\n                // abi.decode failed; we bubble up the original err\n                revert(err);\n            }\n            return;\n        }\n        /* catch (bytes memory err) {\n            we do not any special handling for other generic type errors\n            they can revert the entire tx as usual\n        } */\n    }\n\n    function _validateLiquidationOrderAndDetermineFillPrice(Order memory order, int256 liquidationAmount) internal view returns(uint256 fillPrice) {\n        // fillAmount should be multiple of min size requirement and fillAmount should be non-zero\n        require(isMultiple(liquidationAmount, minSizes[order.ammIndex]), NOT_IS_MULTIPLE);\n        fillPrice = order.price;\n        _validateSpread(order.ammIndex, fillPrice, true);\n    }\n\n    /* ****************** */\n    /*  Funding Payments  */\n    /* ****************** */\n\n    function settleFunding() external whenNotPaused onlyValidator {\n        clearingHouse.settleFunding();\n    }\n\n    /* ****************** */\n    /*       View         */\n    /* ****************** */\n\n    /**\n     * @dev This is not being utilized in the contract anymore. It is only here for backwards compatibility.\n    */\n    function verifySigner(Order memory order, bytes memory signature) public view returns (address, bytes32) {\n        bytes32 orderHash = getOrderHash(order);\n        address signer = ECDSAUpgradeable.recover(orderHash, signature);\n        require(signer == order.trader, \"OB_SINT\");\n        return (signer, orderHash);\n    }\n\n    function getOrderHash(Order memory order) public view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(abi.encode(ORDER_TYPEHASH, order)));\n    }\n\n    /**\n    * @notice Get the margin required to place an order\n    * @dev includes trade fee (taker fee)\n    */\n    function getRequiredMargin(int256 baseAssetQuantity, uint256 price) public view returns(uint256 requiredMargin) {\n        uint quoteAsset = abs(baseAssetQuantity).toUint256() * price / 1e18;\n        requiredMargin = quoteAsset * minAllowableMargin / 1e6;\n        requiredMargin += quoteAsset * takerFee / 1e6;\n    }\n\n    /* ****************** */\n    /*      Internal      */\n    /* ****************** */\n\n    function _updateOrder(Order memory order, bytes32 orderHash, int256 fillAmount) internal {\n        orderInfo[orderHash].filledAmount += fillAmount;\n\n        // assert that the order is not being overfilled\n        require(abs(orderInfo[orderHash].filledAmount) <= abs(order.baseAssetQuantity), \"OB_filled_amount_higher_than_order_base\");\n\n        // update order status if filled and free up reserved margin\n        if (order.reduceOnly) {\n            // free up the reduceOnly quota\n            reduceOnlyAmount[order.trader][order.ammIndex] -= abs(fillAmount);\n            if (orderInfo[orderHash].filledAmount == order.baseAssetQuantity) {\n                orderInfo[orderHash].status = OrderStatus.Filled;\n                _deleteOrderInfo(orderHash);\n            }\n        } else {\n            uint reservedMargin = orderInfo[orderHash].reservedMargin;\n            if (orderInfo[orderHash].filledAmount == order.baseAssetQuantity) {\n                orderInfo[orderHash].status = OrderStatus.Filled;\n                marginAccount.releaseMargin(order.trader, reservedMargin);\n                _deleteOrderInfo(orderHash);\n            } else {\n                // even though the fill price might be different from the order price;\n                // we use the order price to free up the margin because the order price is the price at which the margin was reserved.\n                uint utilisedMargin = uint(abs(fillAmount)) * reservedMargin / uint(abs(order.baseAssetQuantity));\n                // need to track this so we can free up the margin when the order is fulfilled/cancelled without leaving any dust margin reserved from precision loss from divisions\n                orderInfo[orderHash].reservedMargin -= utilisedMargin;\n                marginAccount.releaseMargin(order.trader, utilisedMargin);\n            }\n        }\n    }\n\n    /**\n    * @notice Deletes everything except status and filledAmount from orderInfo\n    * @dev cannot delete order status because then same order can be placed again\n    */\n    function _deleteOrderInfo(bytes32 orderHash) internal {\n        delete orderInfo[orderHash].blockPlaced;\n        delete orderInfo[orderHash].reservedMargin;\n    }\n\n    /* ****************** */\n    /*        Pure        */\n    /* ****************** */\n\n    function abs(int x) internal pure returns (int) {\n        return x >= 0 ? x : -x;\n    }\n\n    /**\n    * @notice returns true if x and y have opposite signs\n    * @dev it considers 0 to have positive sign\n    */\n    function isOppositeSign(int256 x, int256 y) internal pure returns (bool) {\n        return (x ^ y) < 0;\n    }\n\n    /**\n    * @notice checks `x` is non-zero and whether `x` is multiple of `y`\n    * @dev assumes y is positive\n    * @return `true` if `x` is multiple of `y` and abs(x) >= y\n    */\n    function isMultiple(int256 x, int256 y) internal pure returns (bool) {\n        return (x != 0 && x % y == 0);\n    }\n\n    function parseMatchingError(string memory err) pure public returns(bytes32 orderHash, string memory reason) {\n        (orderHash, reason) = abi.decode(bytes(err), (bytes32, string));\n    }\n\n    /* ****************** */\n    /*   Config Updates   */\n    /* ****************** */\n\n    function initializeMinSize(int minSize) external onlyGovernance {\n        minSizes.push(minSize);\n    }\n\n    function updateMinSize(uint ammIndex, int minSize) external onlyGovernance {\n        minSizes[ammIndex] = minSize;\n    }\n\n    function updateParams(uint _minAllowableMargin, uint _takerFee) external onlyClearingHouse {\n        minAllowableMargin = _minAllowableMargin;\n        takerFee = _takerFee;\n    }\n\n    /* ****************** */\n    /*     Governance     */\n    /* ****************** */\n\n    function pause() external onlyGovernance {\n        _pause();\n    }\n\n    function unpause() external onlyGovernance {\n        _unpause();\n    }\n\n    function setValidatorStatus(address validator, bool status) external onlyGovernance {\n        isValidator[validator] = status;\n    }\n\n    function setBibliophile(address _bibliophile) external onlyGovernance {\n        bibliophile = IHubbleBibliophile(_bibliophile);\n    }\n\n    function setUseNewPricingAlgorithm(bool useNew) external onlyGovernance {\n        if (useNew) {\n            useNewPricingAlgorithm = 1;\n        } else {\n            useNewPricingAlgorithm = 0;\n        }\n    }\n}"
    }
  ]
}