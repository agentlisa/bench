{
  "Title": "[M-28] `MagnetarMintXChainModule` will not work as msg type is not allowed",
  "Content": "\nUsers can mint `USDO` on chain A, then lend this `USDO` to singularity on chain B and lock singularity tokens to be able to get tap options on chain C.\n\nThe first step of this flow is inside `MagnetarMintXChainModule.mintBBLendXChainSGL` function. This function [mints `USDO`](https://github.com/Tapioca-DAO/tapioca-periph/blob/032396f701be935b04a7e5cf3cb40a0136259dbc/contracts/Magnetar/modules/MagnetarMintXChainModule.sol#L67-L69) and then [initiates LZ message to chain B](https://github.com/Tapioca-DAO/tapioca-periph/blob/032396f701be935b04a7e5cf3cb40a0136259dbc/contracts/Magnetar/modules/MagnetarMintXChainModule.sol#L82-L96) to process second step using `_withdrawToChain` function.\n\nWhen message will be received by `USDO` on chain B, then receiver will handle compose message [and `MSG_DEPOSIT_LEND_AND_SEND_FOR_LOCK` msg type should be provided to process it correctly](https://github.com/Tapioca-DAO/Tapioca-bar/blob/c2031ac2e2667ac8f9ac48eaedae3dd52abef559/contracts/usdo/modules/UsdoReceiver.sol#L88-L95). The problem is that `USDO` will never receive such msg type as it is not allowed.\n\nLet's check how `_withdrawToChain` function works on chain A. In order to request compose message [it should call `_lzCustomWithdraw`](https://github.com/Tapioca-DAO/tapioca-periph/blob/032396f701be935b04a7e5cf3cb40a0136259dbc/contracts/Magnetar/modules/MagnetarBaseModule.sol#L72-L80). This function then [creates instance of `TapiocaOmnichainEngineHelper` contract](https://github.com/Tapioca-DAO/tapioca-periph/blob/032396f701be935b04a7e5cf3cb40a0136259dbc/contracts/Magnetar/modules/MagnetarBaseModule.sol#L142), which will be used to prepare LZ message.\n\nWhen `TapiocaOmnichainEngineHelper` [will build compose message](https://github.com/Tapioca-DAO/tapioca-periph/blob/032396f701be935b04a7e5cf3cb40a0136259dbc/contracts/tapiocaOmnichainEngine/extension/TapiocaOmnichainEngineHelper.sol#L141-L149) it [will call `_sanitizeMsgType` function](https://github.com/Tapioca-DAO/tapioca-periph/blob/032396f701be935b04a7e5cf3cb40a0136259dbc/contracts/tapiocaOmnichainEngine/extension/TapiocaOmnichainEngineHelper.sol#L316) with msg type that is going to be sent.\n\n<https://github.com/Tapioca-DAO/tapioca-periph/blob/032396f701be935b04a7e5cf3cb40a0136259dbc/contracts/tapiocaOmnichainEngine/extension/TapiocaOmnichainEngineHelper.sol#L333-L346>\n\n```solidity\n    function _sanitizeMsgType(uint16 _msgType) internal pure {\n        if (\n            // LZ\n            _msgType == MSG_SEND\n            // Tapioca msg types\n            || _msgType == MSG_APPROVALS || _msgType == MSG_NFT_APPROVALS || _msgType == MSG_PEARLMIT_APPROVAL\n                || _msgType == MSG_REMOTE_TRANSFER || _msgType == MSG_YB_APPROVE_ASSET || _msgType == MSG_YB_APPROVE_ALL\n                || _msgType == MSG_MARKET_PERMIT\n        ) {\n            return;\n        } else if (!_sanitizeMsgTypeExtended(_msgType)) {\n            revert InvalidMsgType(_msgType);\n        }\n    }\n```\n\nAs you can see this function allows only some types and other should be handled by `_sanitizeMsgTypeExtended` function and this function [is empty](https://github.com/Tapioca-DAO/tapioca-periph/blob/032396f701be935b04a7e5cf3cb40a0136259dbc/contracts/tapiocaOmnichainEngine/extension/TapiocaOmnichainEngineHelper.sol#L351) and returns false. It is designed to be extended by other helpers, such as [`UsdoHelper`](https://github.com/Tapioca-DAO/Tapioca-bar/blob/c2031ac2e2667ac8f9ac48eaedae3dd52abef559/contracts/usdo/extensions/UsdoHelper.sol#L62-L69).\n\nBut as `_lzCustomWithdraw` always creates instance of `TapiocaOmnichainEngineHelper` it means that some messages will be not allowed and will not work. Thus, whole minting flow that I have described on the beginning won't work.\n\n### Impact\n\nUsers can't mint on one chain and deposit on another.\n\n### Tools Used\n\nVsCode\n\n### Recommended Mitigation Steps\n\nFor different `oft` token you should use different helper. For example, if message is going to be sent to `USDO`, then `UsdoHelper` should be used; if message comes to `tOft`, then ToftHelper is needed.\n\nOr you can set all approved messaged in `TapiocaOmnichainEngineHelper` instead, then you can leave current design of `MagnetarBaseModule`.\n\n### Assessed type\n\nError\n\n**[cryptotechmaker (Tapioca) disputed and commented](https://github.com/code-423n4/2024-02-tapioca-findings/issues/59#issuecomment-2012816824):**\n > Invalid. The following extends the default behavior, see [here](https://github.com/Tapioca-DAO/tapioca-periph/blob/032396f701be935b04a7e5cf3cb40a0136259dbc/contracts/tapiocaOmnichainEngine/TapiocaOmnichainReceiver.sol#L174).\n\n\n**[rvierdiiev (warden) commented](https://github.com/code-423n4/2024-02-tapioca-findings/issues/59#issuecomment-2051233203):**\n > Sponsor said that issue is invalid, because `TapiocaOmnichainReceiver` has `_toeComposeReceiver` function to handle this. This is incorrect.\n> \n> `TapiocaOmnichainReceiver.sol` is the contract that is responsible for receiving message on another chain. But in this issue I have described the fact that initiating of request on source chain will fail, so destination chain and `TapiocaOmnichainReceiver` will not even receive it, because the source chain will not allow to send such message.\n> \n> I ask the judge and sponsor to go through the issue one more time with the whole message flow that I have described to see, that call will not be executed.\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-02-tapioca",
  "Code": [
    {
      "filename": "contracts/Magnetar/modules/MagnetarMintXChainModule.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n// Tapioca\nimport {\n    MintFromBBAndLendOnSGLData,\n    CrossChainMintFromBBAndLendOnSGLData,\n    DepositAndSendForLockingData,\n    LockAndParticipateData,\n    MagnetarWithdrawData\n} from \"tapioca-periph/interfaces/periph/IMagnetar.sol\";\nimport {TapiocaOmnichainEngineCodec} from \"tapioca-periph/tapiocaOmnichainEngine/TapiocaOmnichainEngineCodec.sol\";\nimport {IYieldBox} from \"tapioca-periph/interfaces/yieldbox/IYieldBox.sol\";\nimport {IMarket, Module} from \"tapioca-periph/interfaces/bar/IMarket.sol\";\nimport {MagnetarMintCommonModule} from \"./MagnetarMintCommonModule.sol\";\nimport {ITOFT} from \"tapioca-periph/interfaces/oft/ITOFT.sol\";\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title MagnetarMintXChainModule\n * @author TapiocaDAO\n * @notice Magnetar cross chain BigBang related operations\n */\ncontract MagnetarMintXChainModule is MagnetarMintCommonModule {\n    using SafeERC20 for IERC20;\n\n    /// =====================\n    /// Public\n    /// =====================\n    /**\n     * @notice cross-chain helper to deposit mint from BB, lend on SGL, lock on tOLP and participate on tOB\n     * @dev Cross chain flow:\n     *  step 1: magnetar.mintBBLendXChainSGL (chain A) -->\n     *         step 2: IUsdo compose call calls magnetar.depositYBLendSGLLockXchainTOLP (chain B) -->\n     *              step 3: IToft(sglReceipt) compose call calls magnetar.lockAndParticipate (chain X)\n     *  Mints from BB and sends borrowed Usdo to another layer for lending\n     *  ! Handles `step 1` described above !\n     *  !!! All uint variables should be in the LD format !!!\n     *  !!! Sets `lendAmount` parameter of the next call (step 2) !!!\n     * @param data.user the user to perform the operation for\n     * @param data.bigBang the BB address\n     * @param data.mintData the data needed to mint on BB\n     * @param data.lendSendParams LZ send params for lending on another layer\n     */\n    function mintBBLendXChainSGL(CrossChainMintFromBBAndLendOnSGLData memory data) public payable {\n        // Check sender\n        _checkSender(data.user);\n\n        address yieldBox = IMarket(data.bigBang).yieldBox();\n\n        // if `mint` was requested the following actions are performed:\n        //  - extracts & deposits collateral to YB\n        //  - performs bigBang_.addCollateral\n        //  - performs bigBang_.borrow\n        if (data.mintData.mint) {\n            _depositYBBorrowBB(data.mintData, data.bigBang, IYieldBox(yieldBox), data.user, data.marketHelper);\n        }\n\n        // decode `composeMsg` and re-encode it with updated params\n        (uint16 msgType_,, uint16 msgIndex_, bytes memory tapComposeMsg_, bytes memory nextMsg_) =\n            TapiocaOmnichainEngineCodec.decodeToeComposeMsg(data.lendSendParams.lzParams.sendParam.composeMsg);\n\n        DepositAndSendForLockingData memory lendData = abi.decode(tapComposeMsg_, (DepositAndSendForLockingData));\n        lendData.lendAmount = data.mintData.mintAmount;\n\n        data.lendSendParams.lzParams.sendParam.composeMsg =\n            TapiocaOmnichainEngineCodec.encodeToeComposeMsg(abi.encode(lendData), msgType_, msgIndex_, nextMsg_);\n\n        // send on another layer for lending\n        _withdrawToChain(\n            MagnetarWithdrawData({\n                yieldBox: yieldBox,\n                assetId: IMarket(data.bigBang).assetId(),\n                unwrap: false,\n                lzSendParams: data.lendSendParams.lzParams,\n                sendGas: data.lendSendParams.lzSendGas,\n                composeGas: data.lendSendParams.lzComposeGas,\n                sendVal: data.lendSendParams.lzSendVal,\n                composeVal: data.lendSendParams.lzComposeVal,\n                composeMsg: data.lendSendParams.lzParams.sendParam.composeMsg,\n                composeMsgType: data.lendSendParams.lzComposeMsgType,\n                withdraw: true\n            })\n        );\n    }\n\n    /**\n     * @notice cross-chain helper to deposit mint from BB, lend on SGL, lock on tOLP and participate on tOB\n     * @dev Cross chain flow:\n     *  step 1: magnetar.mintBBLendXChainSGL (chain A) -->\n     *         step 2: IUsdo compose call calls magnetar.depositYBLendSGLLockXchainTOLP (chain B) -->\n     *              step 3: IToft(sglReceipt) compose call calls magnetar.lockAndParticipate (chain X)\n     *  Lock on tOB and/or participate on tOLP\n     *  ! Handles `step 3` described above !\n     *  !!! All uint variables should be in the LD format !!!\n     * @param data.user the user to perform the operation for\n     * @param data.singularity the SGL address\n     * @param data.fraction the amount to lock\n     * @param data.lockData the data needed to lock on tOB\n     * @param data.participateData the data needed to participate on tOLP\n     */\n    function lockAndParticipate(LockAndParticipateData memory data) public payable {\n        // Check sender\n        _checkSender(data.user);\n\n        // if `lockData.lock`:\n        //      - transfer `fraction` from data.user to `address(this)\n        //      - deposits `fraction` to YB for `address(this)`\n        //      - performs tOLP.lock\n        uint256 tOLPTokenId = _lockOnTOB(\n            data.lockData,\n            IYieldBox(IMarket(data.singularity).yieldBox()),\n            data.fraction,\n            data.participateData.participate,\n            data.user,\n            data.singularity\n        );\n\n        // if `participateData.participate`:\n        //      - verify tOLPTokenId\n        //      - performs tOB.participate\n        //      - transfer `oTAPTokenId` to data.user\n        if (data.participateData.participate) {\n            _participateOnTOLP(data.participateData, data.user, data.lockData.target, tOLPTokenId);\n        }\n    }\n}"
    },
    {
      "filename": "contracts/usdo/modules/UsdoReceiver.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// LZ\nimport {OFTMsgCodec} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/libs/OFTMsgCodec.sol\";\nimport {OFTCore} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/OFTCore.sol\";\nimport {Origin} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OApp.sol\";\nimport {OFT} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/OFT.sol\";\n\n// External\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n// Tapioca\nimport {\n    IUsdo,\n    UsdoInitStruct,\n    YieldBoxApproveAllMsg,\n    MarketPermitActionMsg,\n    YieldBoxApproveAssetMsg\n} from \"tapioca-periph/interfaces/oft/IUsdo.sol\";\nimport {TapiocaOmnichainReceiver} from \"tapioca-periph/tapiocaOmnichainEngine/TapiocaOmnichainReceiver.sol\";\nimport {UsdoMarketReceiverModule} from \"./UsdoMarketReceiverModule.sol\";\nimport {UsdoOptionReceiverModule} from \"./UsdoOptionReceiverModule.sol\";\nimport {UsdoReceiver} from \"./UsdoReceiver.sol\";\nimport {BaseUsdo} from \"../BaseUsdo.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\ncontract UsdoReceiver is BaseUsdo, TapiocaOmnichainReceiver {\n    using OFTMsgCodec for bytes;\n    using OFTMsgCodec for bytes32;\n    using SafeERC20 for IERC20;\n\n    error InvalidApprovalTarget(address _target);\n\n    constructor(UsdoInitStruct memory _data) BaseUsdo(_data) {}\n\n    /**\n     * @inheritdoc TapiocaOmnichainReceiver\n     */\n    function _lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor, /*_executor*/ // @dev unused in the default implementation.\n        bytes calldata _extraData /*_extraData*/ // @dev unused in the default implementation.\n    ) internal virtual override(OFTCore, TapiocaOmnichainReceiver) {\n        TapiocaOmnichainReceiver._lzReceive(_origin, _guid, _message, _executor, _extraData);\n    }\n\n    /**\n     * @inheritdoc TapiocaOmnichainReceiver\n     */\n    function _toeComposeReceiver(uint16 _msgType, address _srcChainSender, bytes memory _toeComposeMsg)\n        internal\n        override\n        returns (bool success)\n    {\n        if (_msgType == MSG_TAP_EXERCISE) {\n            _executeModule(\n                uint8(IUsdo.Module.UsdoOptionReceiver),\n                abi.encodeWithSelector(\n                    UsdoOptionReceiverModule.exerciseOptionsReceiver.selector, _srcChainSender, _toeComposeMsg\n                ),\n                false\n            );\n        } else if (_msgType == MSG_MARKET_REMOVE_ASSET) {\n            _executeModule(\n                uint8(IUsdo.Module.UsdoMarketReceiver),\n                abi.encodeWithSelector(UsdoMarketReceiverModule.removeAssetReceiver.selector, _toeComposeMsg),\n                false\n            );\n        } else if (_msgType == MSG_YB_SEND_SGL_LEND_OR_REPAY) {\n            _executeModule(\n                uint8(IUsdo.Module.UsdoMarketReceiver),\n                abi.encodeWithSelector(UsdoMarketReceiverModule.lendOrRepayReceiver.selector, _toeComposeMsg),\n                false\n            );\n        } else if (_msgType == MSG_DEPOSIT_LEND_AND_SEND_FOR_LOCK) {\n            _executeModule(\n                uint8(IUsdo.Module.UsdoMarketReceiver),\n                abi.encodeWithSelector(\n                    UsdoMarketReceiverModule.depositLendAndSendForLockingReceiver.selector, _toeComposeMsg\n                ),\n                false\n            );\n        } else {\n            return false;\n        }\n        return true;\n    }\n}"
    },
    {
      "filename": "contracts/Magnetar/modules/MagnetarBaseModule.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// LZ\nimport {OFTMsgCodec} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/libs/OFTMsgCodec.sol\";\n\n// External\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Tapioca\nimport {\n    PrepareLzCallData,\n    PrepareLzCallReturn,\n    ComposeMsgData\n} from \"tapioca-periph/tapiocaOmnichainEngine/extension/TapiocaOmnichainEngineHelper.sol\";\nimport {TapiocaOmnichainEngineHelper} from\n    \"tapioca-periph/tapiocaOmnichainEngine/extension/TapiocaOmnichainEngineHelper.sol\";\nimport {ITapiocaOmnichainEngine, LZSendParam} from \"tapioca-periph/interfaces/periph/ITapiocaOmnichainEngine.sol\";\nimport {MagnetarWithdrawData} from \"tapioca-periph/interfaces/periph/IMagnetar.sol\";\nimport {IYieldBox} from \"tapioca-periph/interfaces/yieldbox/IYieldBox.sol\";\nimport {IOftSender} from \"tapioca-periph/interfaces/oft/IOftSender.sol\";\nimport {IPearlmit} from \"tapioca-periph/pearlmit/PearlmitHandler.sol\";\nimport {MagnetarStorage} from \"../MagnetarStorage.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\nabstract contract MagnetarBaseModule is Ownable, MagnetarStorage {\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n\n    error Magnetar_GasMismatch(uint256 expected, uint256 received);\n    error Magnetar_TargetNotWhitelisted(address target);\n    error Magnetar_ExtractTokenFail();\n\n    constructor() MagnetarStorage(IPearlmit(address(0))) {}\n\n    /// =====================\n    /// Internal\n    /// =====================\n    function _withdrawToChain(MagnetarWithdrawData memory data) internal {\n        if (!cluster.isWhitelisted(0, address(data.yieldBox))) {\n            revert Magnetar_TargetNotWhitelisted(address(data.yieldBox));\n        }\n        IYieldBox _yieldBox = IYieldBox(data.yieldBox);\n\n        // perform a same chain withdrawal\n        if (data.lzSendParams.sendParam.dstEid == 0) {\n            _withdrawHere(_yieldBox, data.assetId, data.lzSendParams.sendParam.to, data.lzSendParams.sendParam.amountLD);\n            return;\n        }\n\n        // perform a cross chain withdrawal\n        (, address asset,,) = _yieldBox.assets(data.assetId);\n        if (!cluster.isWhitelisted(0, asset)) {\n            revert Magnetar_TargetNotWhitelisted(asset);\n        }\n\n        _yieldBox.withdraw(data.assetId, address(this), address(this), data.lzSendParams.sendParam.amountLD, 0);\n        // TODO: decide about try-catch here\n        if (data.unwrap) {\n            _lzCustomWithdraw(\n                asset,\n                data.lzSendParams,\n                data.sendGas,\n                data.sendVal,\n                data.composeGas,\n                data.composeVal,\n                data.composeMsgType\n            );\n        } else {\n            _lzWithdraw(asset, data.lzSendParams, data.sendGas, data.sendVal);\n        }\n    }\n\n    function _setApprovalForYieldBox(address _target, IYieldBox _yieldBox) internal {\n        bool isApproved = _yieldBox.isApprovedForAll(address(this), _target);\n        if (!isApproved) {\n            _yieldBox.setApprovalForAll(_target, true);\n        }\n    }\n\n    function _revertYieldBoxApproval(address _target, IYieldBox _yieldBox) internal {\n        bool isApproved = _yieldBox.isApprovedForAll(address(this), _target);\n        if (isApproved) {\n            _yieldBox.setApprovalForAll(_target, false);\n        }\n    }\n\n    function _extractTokens(address _from, address _token, uint256 _amount) internal returns (uint256) {\n        uint256 balanceBefore = IERC20(_token).balanceOf(address(this));\n        // IERC20(_token).safeTransferFrom(_from, address(this), _amount);\n        bool isErr = pearlmit.transferFromERC20(_from, address(this), address(_token), _amount);\n        if (isErr) revert Magnetar_ExtractTokenFail();\n        uint256 balanceAfter = IERC20(_token).balanceOf(address(this));\n        if (balanceAfter <= balanceBefore) revert Magnetar_ExtractTokenFail();\n        return balanceAfter - balanceBefore;\n    }\n\n    /// =====================\n    /// Private\n    /// =====================\n    function _withdrawHere(IYieldBox _yieldBox, uint256 _assetId, bytes32 _to, uint256 _amount) private {\n        _yieldBox.withdraw(_assetId, address(this), OFTMsgCodec.bytes32ToAddress(_to), _amount, 0);\n    }\n\n    function _lzWithdraw(address _asset, LZSendParam memory _lzSendParam, uint128 _lzSendGas, uint128 _lzSendVal)\n        private\n    {\n        PrepareLzCallReturn memory prepareLzCallReturn = _prepareLzSend(_asset, _lzSendParam, _lzSendGas, _lzSendVal);\n\n        if (msg.value < prepareLzCallReturn.msgFee.nativeFee) {\n            revert Magnetar_GasMismatch(prepareLzCallReturn.msgFee.nativeFee, msg.value);\n        }\n\n        IOftSender(_asset).sendPacket{value: prepareLzCallReturn.msgFee.nativeFee}(\n            prepareLzCallReturn.lzSendParam, prepareLzCallReturn.composeMsg\n        );\n    }\n\n    function _lzCustomWithdraw(\n        address _asset,\n        LZSendParam memory _lzSendParam,\n        uint128 _lzSendGas,\n        uint128 _lzSendVal,\n        uint128 _lzComposeGas,\n        uint128 _lzComposeVal,\n        uint16 _lzComposeMsgType\n    ) private {\n        PrepareLzCallReturn memory prepareLzCallReturn = _prepareLzSend(_asset, _lzSendParam, _lzSendGas, _lzSendVal);\n\n        TapiocaOmnichainEngineHelper _toeHelper = new TapiocaOmnichainEngineHelper();\n        PrepareLzCallReturn memory prepareLzCallReturn2 = _toeHelper.prepareLzCall(\n            ITapiocaOmnichainEngine(_asset),\n            PrepareLzCallData({\n                dstEid: _lzSendParam.sendParam.dstEid,\n                recipient: _lzSendParam.sendParam.to,\n                amountToSendLD: 0,\n                minAmountToCreditLD: 0,\n                msgType: _lzComposeMsgType,\n                composeMsgData: ComposeMsgData({\n                    index: 0,\n                    gas: _lzComposeGas,\n                    value: prepareLzCallReturn.msgFee.nativeFee.toUint128(),\n                    data: _lzSendParam.sendParam.composeMsg,\n                    prevData: bytes(\"\"),\n                    prevOptionsData: bytes(\"\")\n                }),\n                lzReceiveGas: _lzSendGas + _lzComposeGas,\n                lzReceiveValue: _lzComposeVal\n            })\n        );\n\n        if (msg.value < prepareLzCallReturn2.msgFee.nativeFee) {\n            revert Magnetar_GasMismatch(prepareLzCallReturn2.msgFee.nativeFee, msg.value);\n        }\n\n        IOftSender(_asset).sendPacket{value: prepareLzCallReturn2.msgFee.nativeFee}(\n            prepareLzCallReturn2.lzSendParam, prepareLzCallReturn2.composeMsg\n        );\n    }\n\n    function _prepareLzSend(address _asset, LZSendParam memory _lzSendParam, uint128 _lzSendGas, uint128 _lzSendVal)\n        private\n        returns (PrepareLzCallReturn memory prepareLzCallReturn)\n    {\n        TapiocaOmnichainEngineHelper _toeHelper = new TapiocaOmnichainEngineHelper();\n        prepareLzCallReturn = _toeHelper.prepareLzCall(\n            ITapiocaOmnichainEngine(_asset),\n            PrepareLzCallData({\n                dstEid: _lzSendParam.sendParam.dstEid,\n                recipient: _lzSendParam.sendParam.to,\n                amountToSendLD: _lzSendParam.sendParam.amountLD,\n                minAmountToCreditLD: _lzSendParam.sendParam.minAmountLD,\n                msgType: 1, // SEND\n                composeMsgData: ComposeMsgData({\n                    index: 0,\n                    gas: 0,\n                    value: 0,\n                    data: bytes(\"\"),\n                    prevData: bytes(\"\"),\n                    prevOptionsData: bytes(\"\")\n                }),\n                lzReceiveGas: _lzSendGas,\n                lzReceiveValue: _lzSendVal\n            })\n        );\n    }\n}"
    },
    {
      "filename": "contracts/tapiocaOmnichainEngine/extension/TapiocaOmnichainEngineHelper.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// LZ\nimport {\n    SendParam,\n    MessagingFee,\n    MessagingReceipt,\n    OFTReceipt\n} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/interfaces/IOFT.sol\";\n\nimport {OptionsBuilder} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/libs/OptionsBuilder.sol\";\n\n// Tapioca\nimport {\n    YieldBoxApproveAllMsg,\n    MarketPermitActionMsg,\n    YieldBoxApproveAssetMsg\n} from \"tapioca-periph/interfaces/periph/ITapiocaOmnichainEngine.sol\";\nimport {\n    ITapiocaOmnichainEngine,\n    ERC20PermitApprovalMsg,\n    ERC721PermitApprovalMsg,\n    LZSendParam,\n    ERC20PermitStruct,\n    ERC721PermitStruct,\n    ERC20PermitApprovalMsg,\n    ERC721PermitApprovalMsg,\n    RemoteTransferMsg\n} from \"tapioca-periph/interfaces/periph/ITapiocaOmnichainEngine.sol\";\nimport {TapiocaOmnichainEngineCodec} from \"../TapiocaOmnichainEngineCodec.sol\";\nimport {IPearlmit} from \"tapioca-periph/interfaces/periph/IPearlmit.sol\";\nimport {BaseToeMsgType} from \"../BaseToeMsgType.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @notice Used to build the TOE compose messages.\n */\nstruct ComposeMsgData {\n    uint8 index; // The index of the message.\n    uint128 gas; // The gasLimit used on the compose() function in the OApp for this message.\n    uint128 value; // The msg.value passed to the compose() function in the OApp for this message.\n    bytes data; // The data of the message.\n    bytes prevData; // The previous compose msg data, if any. Used to aggregate the compose msg data.\n    bytes prevOptionsData; // The previous compose msg options data, if any. Used to aggregate  the compose msg options.\n}\n\n/**\n * @notice Used to prepare an LZ call. See `TapiocaOmnichainHelper.prepareLzCall()`.\n */\nstruct PrepareLzCallData {\n    uint32 dstEid; // The destination endpoint ID.\n    bytes32 recipient; // The recipient address. Receiver of the OFT send if any.\n    uint256 amountToSendLD; // The amount to send in the OFT send. If any.\n    uint256 minAmountToCreditLD; // The min amount to credit in the OFT send. If any.\n    uint16 msgType; // The message type, TOE custom ones, with `MSG_` as a prefix.\n    ComposeMsgData composeMsgData; // The compose msg data.\n    uint128 lzReceiveGas; // The gasLimit used on the lzReceive() function in the OApp.\n    uint128 lzReceiveValue; // The msg.value passed to the lzReceive() function in the OApp.\n}\n\n/**\n * @notice Used to return the result of the `TapiocaOmnichainHelper.prepareLzCall()` function.\n */\nstruct PrepareLzCallReturn {\n    bytes composeMsg; // The composed message. Can include previous composeMsg if any.\n    bytes composeOptions; // The options of the composeMsg. Single option container, not aggregated with previous composeMsgOptions.\n    SendParam sendParam; // OFT basic Tx params.\n    MessagingFee msgFee; // OFT msg fee, include aggregation of previous composeMsgOptions.\n    LZSendParam lzSendParam; // LZ Tx params. contains multiple information for the Tapioca `sendPacket()` call.\n    bytes oftMsgOptions; // OFT msg options, include aggregation of previous composeMsgOptions.\n}\n\n/**\n * @title TapiocaOmnichainEngineHelper\n * @author TapiocaDAO\n * @notice Used as a helper contract to build calls to a TOE contract and view functions.\n */\ncontract TapiocaOmnichainEngineHelper is BaseToeMsgType {\n    error InvalidMsgType(uint16 msgType); // Triggered if the msgType is invalid on an `_lzCompose`.\n    error InvalidMsgIndex(uint16 msgIndex, uint16 expectedIndex); // The msgIndex does not follow the sequence of indexes in the `_toeComposeMsg`\n    error InvalidExtraOptionsIndex(uint16 msgIndex, uint16 expectedIndex); // The option index does not follow the sequence of indexes in the `_toeComposeMsg`\n\n    /**\n     * ==========================\n     * ERC20 APPROVAL MSG BUILDER\n     * ==========================\n     */\n\n    /**\n     * @dev Helper to prepare an LZ call.\n     * @dev Refunds address is the caller. // TODO add refundAddress field.\n     * @dev `amountToSendLD` and `minAmountToCreditLD` are used for an OFT send operation. If set in composed calls, only the last message LZ data will be used.\n     * @dev !!! IMPORTANT !!! If you want to send a message without sending amounts, set both `amountToSendLD` and `minAmountToCreditLD` to 0.\n     *\n     * @return prepareLzCallReturn_ The result of the `prepareLzCall()` function. See `PrepareLzCallReturn`.\n     */\n    function prepareLzCall(ITapiocaOmnichainEngine _toeToken, PrepareLzCallData memory _prepareLzCallData)\n        public\n        view\n        returns (PrepareLzCallReturn memory prepareLzCallReturn_)\n    {\n        SendParam memory sendParam_;\n        bytes memory composeOptions_;\n        bytes memory composeMsg_;\n        MessagingFee memory msgFee_;\n        LZSendParam memory lzSendParam_;\n        bytes memory oftMsgOptions_;\n\n        // Prepare args call\n        sendParam_ = SendParam({\n            dstEid: _prepareLzCallData.dstEid,\n            to: _prepareLzCallData.recipient,\n            amountLD: _prepareLzCallData.amountToSendLD,\n            minAmountLD: _prepareLzCallData.minAmountToCreditLD,\n            extraOptions: \"0x\",\n            composeMsg: \"0x\",\n            oftCmd: \"0x\"\n        });\n\n        // If compose call found, we get its compose options and message.\n        if (_prepareLzCallData.composeMsgData.data.length > 0) {\n            composeOptions_ = OptionsBuilder.addExecutorLzComposeOption(\n                OptionsBuilder.newOptions(),\n                _prepareLzCallData.composeMsgData.index,\n                _prepareLzCallData.composeMsgData.gas,\n                _prepareLzCallData.composeMsgData.value\n            );\n\n            // Build the composed message. Overwrite `composeOptions_` to be with the enforced options.\n            (composeMsg_, composeOptions_) = buildToeComposeMsgAndOptions(\n                _toeToken,\n                _prepareLzCallData.composeMsgData.data,\n                _prepareLzCallData.msgType,\n                _prepareLzCallData.composeMsgData.index,\n                sendParam_.dstEid,\n                composeOptions_,\n                _prepareLzCallData.composeMsgData.prevData // Previous tapComposeMsg.\n            );\n        }\n\n        // Append previous option container if any.\n        if (_prepareLzCallData.composeMsgData.prevOptionsData.length > 0) {\n            require(\n                _prepareLzCallData.composeMsgData.prevOptionsData.length > 0, \"_prepareLzCall: invalid prevOptionsData\"\n            );\n            oftMsgOptions_ = _prepareLzCallData.composeMsgData.prevOptionsData;\n        } else {\n            // Else create a new one.\n            oftMsgOptions_ = OptionsBuilder.newOptions();\n        }\n\n        // Start by appending the lzReceiveOption if lzReceiveGas or lzReceiveValue is > 0.\n        if (_prepareLzCallData.lzReceiveValue > 0 || _prepareLzCallData.lzReceiveGas > 0) {\n            oftMsgOptions_ = OptionsBuilder.addExecutorLzReceiveOption(\n                oftMsgOptions_, _prepareLzCallData.lzReceiveGas, _prepareLzCallData.lzReceiveValue\n            );\n        }\n\n        // Finally, append the new compose options if any.\n        if (composeOptions_.length > 0) {\n            // And append the same value passed to the `composeOptions`.\n            oftMsgOptions_ = OptionsBuilder.addExecutorLzComposeOption(\n                oftMsgOptions_,\n                _prepareLzCallData.composeMsgData.index,\n                _prepareLzCallData.composeMsgData.gas,\n                _prepareLzCallData.composeMsgData.value\n            );\n        }\n\n        msgFee_ = _toeToken.quoteSendPacket(sendParam_, oftMsgOptions_, false, composeMsg_, \"\");\n\n        sendParam_.extraOptions = oftMsgOptions_;\n        sendParam_.composeMsg = composeMsg_;\n\n        lzSendParam_ = LZSendParam({\n            sendParam: sendParam_,\n            fee: msgFee_,\n            extraOptions: oftMsgOptions_,\n            refundAddress: address(msg.sender)\n        });\n\n        prepareLzCallReturn_ = PrepareLzCallReturn({\n            composeMsg: composeMsg_,\n            composeOptions: composeOptions_,\n            sendParam: sendParam_,\n            msgFee: msgFee_,\n            lzSendParam: lzSendParam_,\n            oftMsgOptions: oftMsgOptions_\n        });\n    }\n\n    /// =======================\n    /// Builder functions\n    /// =======================\n\n    /**\n     * @notice Encode the message for the _erc20PermitApprovalReceiver() operation.\n     * @param _erc20PermitApprovalMsg The ERC20 permit approval messages.\n     */\n    function encodeERC20PermitApprovalMsg(ERC20PermitApprovalMsg[] memory _erc20PermitApprovalMsg)\n        public\n        pure\n        returns (bytes memory msg_)\n    {\n        return TapiocaOmnichainEngineCodec.encodeERC20PermitApprovalMsg(_erc20PermitApprovalMsg);\n    }\n\n    /**\n     * @notice Encode the message for the _erc721PermitApprovalReceiver() operation.\n     * @param _erc721PermitApprovalMsg The ERC721 permit approval messages.\n     */\n    function encodeERC721PermitApprovalMsg(ERC721PermitApprovalMsg[] memory _erc721PermitApprovalMsg)\n        public\n        pure\n        returns (bytes memory msg_)\n    {\n        return TapiocaOmnichainEngineCodec.encodeERC721PermitApprovalMsg(_erc721PermitApprovalMsg);\n    }\n\n    function encodePearlmitApprovalMsg(address _pearlmit, IPearlmit.PermitBatchTransferFrom calldata _data)\n        public\n        pure\n        returns (bytes memory msg_)\n    {\n        return TapiocaOmnichainEngineCodec.encodePearlmitApprovalMsg(_pearlmit, _data);\n    }\n\n    /**\n     * @notice Encodes the message for the `remoteTransfer` operation.\n     * @param _remoteTransferMsg The owner + LZ send param to pass on the remote chain. (B->A)\n     */\n    function buildRemoteTransferMsg(RemoteTransferMsg memory _remoteTransferMsg) public pure returns (bytes memory) {\n        return TapiocaOmnichainEngineCodec.buildRemoteTransferMsg(_remoteTransferMsg);\n    }\n\n    /**\n     * @notice Encode the message for the _marketPermitBorrowReceiver() & _marketPermitLendReceiver operations.\n     * @param _marketPermitActionMsg The Market permit lend/borrow approval message.\n     */\n    function buildMarketPermitApprovalMsg(MarketPermitActionMsg memory _marketPermitActionMsg)\n        public\n        pure\n        returns (bytes memory msg_)\n    {\n        msg_ = TapiocaOmnichainEngineCodec.buildMarketPermitApprovalMsg(_marketPermitActionMsg);\n    }\n\n    /**\n     * @notice Encode the message for the _yieldBoxPermitAllReceiver() & _yieldBoxRevokeAllReceiver operations.\n     * @param _yieldBoxApprovalAllMsg The YieldBox permit/revoke approval message.\n     */\n    function buildYieldBoxApproveAllMsg(YieldBoxApproveAllMsg memory _yieldBoxApprovalAllMsg)\n        public\n        pure\n        returns (bytes memory msg_)\n    {\n        msg_ = TapiocaOmnichainEngineCodec.buildYieldBoxApproveAllMsg(_yieldBoxApprovalAllMsg);\n    }\n\n    /**\n     * @notice Encode the message for the `PT_YB_APPROVE_ASSET` operation,\n     *   _yieldBoxRevokeAssetReceiver() & _yieldBoxApproveAssetReceiver operations.\n     * @param _approvalMsg The YieldBoxApproveAssetMsg messages.\n     */\n    function buildYieldBoxApproveAssetMsg(YieldBoxApproveAssetMsg[] memory _approvalMsg)\n        public\n        pure\n        returns (bytes memory msg_)\n    {\n        uint256 approvalsLength = _approvalMsg.length;\n        for (uint256 i; i < approvalsLength;) {\n            msg_ = abi.encodePacked(msg_, TapiocaOmnichainEngineCodec.buildYieldBoxPermitAssetMsg(_approvalMsg[i]));\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// =======================\n    /// Compose builder functions\n    /// =======================\n\n    /**\n     * @dev Internal function to build the message and options.\n     *\n     * @param _msg The TAP message to be encoded.\n     * @param _msgType The message type, TAP custom ones, with `MSG_` as a prefix.\n     * @param _msgIndex The index of the current TAP compose msg.\n     * @param _dstEid The destination endpoint ID.\n     * @param _extraOptions Extra options for this message. Used to add extra options or aggregate previous `_tapComposedMsg` options.\n     * @param _tapComposedMsg The previous TAP compose messages. Empty if this is the first message.\n     *\n     * @return message The encoded message.\n     * @return options The encoded options.\n     */\n    function buildToeComposeMsgAndOptions(\n        ITapiocaOmnichainEngine _toeToken,\n        bytes memory _msg,\n        uint16 _msgType,\n        uint16 _msgIndex,\n        uint32 _dstEid,\n        bytes memory _extraOptions,\n        bytes memory _tapComposedMsg\n    ) public view returns (bytes memory message, bytes memory options) {\n        _sanitizeMsgType(_msgType);\n        _sanitizeMsgIndex(_msgIndex, _tapComposedMsg);\n\n        message = TapiocaOmnichainEngineCodec.encodeToeComposeMsg(_msg, _msgType, _msgIndex, _tapComposedMsg);\n\n        // TODO fix\n        // _sanitizeExtraOptionsIndex(_msgIndex, _extraOptions);\n        // @dev Combine the callers _extraOptions with the enforced options via the OAppOptionsType3.\n\n        options = _toeToken.combineOptions(_dstEid, _msgType, _extraOptions);\n    }\n\n    // TODO remove sanitization? If `_sendPacket()` is internal, then the msgType is what we expect it to be.\n    /**\n     * @dev Sanitizes the message type to match one of the Tapioca supported ones.\n     * @param _msgType The message type, custom ones with `MSG_` as a prefix.\n     */\n    function _sanitizeMsgType(uint16 _msgType) internal pure {\n        if (\n            // LZ\n            _msgType == MSG_SEND\n            // Tapioca msg types\n            || _msgType == MSG_APPROVALS || _msgType == MSG_NFT_APPROVALS || _msgType == MSG_PEARLMIT_APPROVAL\n                || _msgType == MSG_REMOTE_TRANSFER || _msgType == MSG_YB_APPROVE_ASSET || _msgType == MSG_YB_APPROVE_ALL\n                || _msgType == MSG_MARKET_PERMIT\n        ) {\n            return;\n        } else if (!_sanitizeMsgTypeExtended(_msgType)) {\n            revert InvalidMsgType(_msgType);\n        }\n    }\n\n    /**\n     * @dev Sanitizes the message type of a TOE inherited contract.\n     */\n    function _sanitizeMsgTypeExtended(uint16 _msgType) internal pure virtual returns (bool) {}\n\n    /**\n     * @dev Sanitizes the"
    }
  ]
}