{
  "Title": "Missing Docstrings",
  "Content": "Throughout the [codebase](https://github.com/VenusProtocol/protocol-reserve/tree/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts), there are several parts that do not have docstrings. For instance:\n\n\n* [Line 57](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/TokenConverter/IAbstractTokenConverter.sol#L6-L57) in [`IAbstractTokenConverter.sol`](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/TokenConverter/IAbstractTokenConverter.sol)\n* [Line 23](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/ProtocolReserve/RiskFundStorage.sol#L7-L23) in [`RiskFundStorage.sol`](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/ProtocolReserve/RiskFundStorage.sol)\n* [Line 274](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/TokenConverter/RiskFundConverter.sol#L16-L274) in [`RiskFundConverter.sol`](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/TokenConverter/RiskFundConverter.sol)\n* [Line 34](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/ProtocolReserve/RiskFundStorage.sol#L25-L34) in [`RiskFundStorage.sol`](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/ProtocolReserve/RiskFundStorage.sol)\n* [Line 36](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/TokenConverter/XVSVaultConverter.sol#L10-L36) in [`XVSVaultConverter.sol`](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/TokenConverter/XVSVaultConverter.sol)\n* [Line 84](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/ProtocolReserve/XVSVaultTreasury.sol#L11-L84) in [`XVSVaultTreasury.sol`](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/ProtocolReserve/XVSVaultTreasury.sol)\n* [Line 24](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/TokenConverter/IAbstractTokenConverter.sol#L24) in [`IAbstractTokenConverter.sol`](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/TokenConverter/IAbstractTokenConverter.sol)\n* [Line 72](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/ProtocolReserve/XVSVaultTreasury.sol#L59-L72) in [`XVSVaultTreasury.sol`](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/ProtocolReserve/XVSVaultTreasury.sol)\n* [Line 18](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/TokenConverter/IAbstractTokenConverter.sol#L18) in [`IAbstractTokenConverter.sol`](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/TokenConverter/IAbstractTokenConverter.sol)\n* [Line 22](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/TokenConverter/IAbstractTokenConverter.sol#L22) in [`IAbstractTokenConverter.sol`](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/TokenConverter/IAbstractTokenConverter.sol)\n* [Line 48](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/TokenConverter/IAbstractTokenConverter.sol#L42-L48) in [`IAbstractTokenConverter.sol`](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/TokenConverter/IAbstractTokenConverter.sol)\n* [Line 32](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/TokenConverter/IAbstractTokenConverter.sol#L26-L32) in [`IAbstractTokenConverter.sol`](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/TokenConverter/IAbstractTokenConverter.sol)\n* [Line 56](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/TokenConverter/IAbstractTokenConverter.sol#L50-L56) in [`IAbstractTokenConverter.sol`](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/TokenConverter/IAbstractTokenConverter.sol)\n* [Line 40](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/TokenConverter/IAbstractTokenConverter.sol#L34-L40) in [`IAbstractTokenConverter.sol`](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/TokenConverter/IAbstractTokenConverter.sol)\n* [Line 20](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/TokenConverter/IAbstractTokenConverter.sol#L20) in [`IAbstractTokenConverter.sol`](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/TokenConverter/IAbstractTokenConverter.sol)\n* [Line 55](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/TokenConverter/RiskFundConverter.sol#L55) in [`RiskFundConverter.sol`](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/TokenConverter/RiskFundConverter.sol)\n* [Line 52](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/TokenConverter/RiskFundConverter.sol#L52) in [`RiskFundConverter.sol`](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/TokenConverter/RiskFundConverter.sol)\n* [Line 58](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/TokenConverter/RiskFundConverter.sol#L58) in [`RiskFundConverter.sol`](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/TokenConverter/RiskFundConverter.sol)\n\n\nConsider thoroughly documenting all functions (and their parameters) that are part of any contract's public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the [Ethereum Natural Specification Format](https://solidity.readthedocs.io/en/develop/natspec-format.html) (NatSpec).\n\n\n***Update:** Resolved at commit [a555053](https://github.com/VenusProtocol/protocol-reserve/pull/24/commits/a555053d6a7d41e0389e5c01deffab985a392a30).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/TokenConverter/IAbstractTokenConverter.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\nimport { ResilientOracle } from \"@venusprotocol/oracle/contracts/ResilientOracle.sol\";\n\ninterface IAbstractTokenConverter {\n    struct ConversionConfig {\n        /// tokenIn address\n        address tokenAddressIn;\n        /// tokenOut address\n        address tokenAddressOut;\n        /// incentive on conversion of tokens in mantissa i.e 10% incentive would be 0.1 * 1e18\n        uint256 incentive;\n        /// whether the conversion is enabled\n        bool enabled;\n    }\n\n    function pauseConversion() external;\n\n    function resumeConversion() external;\n\n    function setPriceOracle(ResilientOracle priceOracle_) external;\n\n    function setConversionConfig(ConversionConfig calldata conversionConfig) external;\n\n    function convertExactTokens(\n        uint256 amountInMantissa,\n        uint256 amountOutMinMantissa,\n        address tokenAddressIn,\n        address tokenAddressOut,\n        address to\n    ) external;\n\n    function convertForExactTokens(\n        uint256 amountInMaxMantissa,\n        uint256 amountOutMantissa,\n        address tokenAddressIn,\n        address tokenAddressOut,\n        address to\n    ) external;\n\n    function convertExactTokensSupportingFeeOnTransferTokens(\n        uint256 amountInMantissa,\n        uint256 amountOutMinMantissa,\n        address tokenAddressIn,\n        address tokenAddressOut,\n        address to\n    ) external;\n\n    function convertForExactTokensSupportingFeeOnTransferTokens(\n        uint256 amountInMaxMantissa,\n        uint256 amountOutMantissa,\n        address tokenAddressIn,\n        address tokenAddressOut,\n        address to\n    ) external;\n}"
    },
    {
      "filename": "contracts/ProtocolReserve/RiskFundStorage.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\nimport { Ownable2StepUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\ncontract ReserveHelpersStorage is Ownable2StepUpgradeable {\n    /// @notice Deprecated slot for assetReserves mapping\n    bytes32 private __deprecatedSlot1;\n\n    /// @notice Available asset's fund per pool in RiskFund\n    /// Comptroller(pool) -> Asset -> amount\n    mapping(address => mapping(address => uint256)) public poolAssetsFunds;\n\n    /// @notice Deprecated slot for poolRegistry address\n    bytes32 private __deprecatedSlot2;\n    /// @notice Deprecated slot for status variable\n    bytes32 private __deprecatedSlot3;\n\n    /// @dev This empty reserved space is put in place to allow future versions to add new\n    /// variables without shifting down storage in the inheritance chain.\n    uint256[46] private __gap;\n}\n\ncontract MaxLoopsLimitHelpersStorage {\n    /// @notice Limit for the loops to avoid the DOS\n    /// @notice This state is deprecated, using it to prevent storage collision\n    uint256 public maxLoopsLimit;\n\n    /// @dev This empty reserved space is put in place to allow future versions to add new\n    /// variables without shifting down storage in the inheritance chain.\n    /// See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n    uint256[49] private __gap;\n}\n\n/// @title RiskFundV1Storage\n/// @author Venus\n/// @dev Risk fund V1 storage\ncontract RiskFundV1Storage is ReserveHelpersStorage, MaxLoopsLimitHelpersStorage {\n    /// @notice Address of base asset\n    address public convertibleBaseAsset;\n    /// @notice Address of shortfall contract\n    address public shortfall;\n\n    /// @notice This state is deprecated, using it to prevent storage collision\n    address private pancakeSwapRouter;\n    /// @notice This state is deprecated, using it to prevent storage collision\n    uint256 private minAmountToConvert;\n}\n\n/// @title RiskFundV2Storage\n/// @author Venus\n/// @dev Risk fund V2 storage\ncontract RiskFundV2Storage is RiskFundV1Storage, ReentrancyGuardUpgradeable {\n    /// @notice Risk fund converter address\n    address public riskFundConverter;\n}"
    },
    {
      "filename": "contracts/TokenConverter/RiskFundConverter.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\nimport { SafeERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport { IERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport { ResilientOracle } from \"@venusprotocol/oracle/contracts/ResilientOracle.sol\";\n\nimport { AbstractTokenConverter } from \"./AbstractTokenConverter.sol\";\nimport { ensureNonzeroAddress } from \"../Utils/Validators.sol\";\nimport { IPoolRegistry } from \"../Interfaces/IPoolRegistry.sol\";\nimport { IComptroller } from \"../Interfaces/IComptroller.sol\";\nimport { IRiskFund } from \"../Interfaces/IRiskFund.sol\";\nimport { IVToken } from \"../Interfaces/IVToken.sol\";\nimport { EXP_SCALE } from \"../Utils/Constants.sol\";\n\ncontract RiskFundConverter is AbstractTokenConverter {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @notice Address of the core pool comptroller\n    address public immutable corePoolComptroller;\n\n    ///@notice Address of the vBNB\n    ///@dev This address is used to exclude the BNB market while in getPools method\n    address public immutable vBNB;\n\n    ///@notice Address of the native wrapped currency\n    address public immutable NATIVE_WRAPPED;\n\n    /// @notice Store the previous state for the asset transferred to ProtocolShareReserve combined(for all pools)\n    mapping(address => uint256) internal assetsReserves;\n\n    /// @notice Store the asset's reserve per pool in the ProtocolShareReserve\n    /// @dev Comptroller(pool) -> Asset -> amount\n    mapping(address => mapping(address => uint256)) internal poolsAssetsReserves;\n\n    /// @notice Address of pool registry contract\n    address public poolRegistry;\n\n    /// @notice This mapping would contain the assets for the pool which would be send to RiskFund directly\n    /// @dev Comptroller(pool) -> Asset -> bool(should transfer directly on true)\n    mapping(address => mapping(address => bool)) public poolsAssetsDirectTransfer;\n\n    /// @dev This empty reserved space is put in place to allow future versions to add new\n    /// variables without shifting down storage in the inheritance chain\n    uint256[46] private __gap;\n\n    /// @notice Emitted when pool registry address is updated\n    event PoolRegistryUpdated(address indexed oldPoolRegistry, address indexed newPoolRegistry);\n\n    // Event emitted after the updation of the assets reserves\n    // amount -> reserve increased by amount\n    event AssetsReservesUpdated(address indexed comptroller, address indexed asset, uint256 amount);\n\n    // Event emitted after the funds transferred to the destination address\n    event AssetTransferredToDestination(address indexed comptroller, address indexed asset, uint256 amount);\n\n    // Event emitted after the poolsAssetsDirectTransfer mapping is updated\n    event PoolAssetsDirectTransferUpdated(address indexed comptroller, address indexed asset, bool value);\n\n    // Error thrown when comptrollers array length is not equal to assets array length\n    error InvalidArguments();\n\n    /// @param corePoolComptroller_ Address of the Comptroller pool\n    /// @param vBNB_ Address of the vBNB\n    /// @param nativeWrapped_ Address of the wrapped native currency\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address corePoolComptroller_, address vBNB_, address nativeWrapped_) {\n        ensureNonzeroAddress(corePoolComptroller_);\n        corePoolComptroller = corePoolComptroller_;\n        vBNB = vBNB_;\n        NATIVE_WRAPPED = nativeWrapped_;\n    }\n\n    /// @param accessControlManager_ Access control manager contract address\n    /// @param priceOracle_ Resilient oracle address\n    /// @param destinationAddress_  Address at all incoming tokens will transferred to\n    /// @param poolRegistry_ Address of the pool registry\n    function initialize(\n        address accessControlManager_,\n        ResilientOracle priceOracle_,\n        address destinationAddress_,\n        address poolRegistry_\n    ) public initializer {\n        // Initialize AbstractTokenConverter\n        __AbstractTokenConverter_init(accessControlManager_, priceOracle_, destinationAddress_);\n        poolRegistry = poolRegistry_;\n    }\n\n    /// @dev Pool registry setter\n    /// @param poolRegistry_ Address of the pool registry\n    /// @custom:event PoolRegistryUpdated emits on success\n    /// @custom:error ZeroAddressNotAllowed is thrown when pool registry address is zero\n    function setPoolRegistry(address poolRegistry_) external onlyOwner {\n        ensureNonzeroAddress(poolRegistry_);\n        address oldPoolRegistry = poolRegistry;\n        poolRegistry = poolRegistry_;\n        emit PoolRegistryUpdated(oldPoolRegistry, poolRegistry_);\n    }\n\n    /// @notice Update the poolsAssetsDirectTransfer mapping\n    /// @param comptrollers Addresses of the pools\n    /// @param assets Addresses of the assets need to be added for direct transfer\n    /// @custom:error InvalidArguments thrown when comptrollers array length is not equal to assets array length\n    /// @custom:access Restricted by ACM\n    function setPoolsAssetsDirectTransfer(\n        address[] calldata comptrollers,\n        address[][] calldata assets,\n        bool[][] calldata values\n    ) external {\n        _checkAccessAllowed(\"setPoolsAssetsDirectTransfer(address[],address[][],bool[][])\");\n\n        uint256 comptrollersLength = comptrollers.length;\n\n        if ((comptrollersLength != assets.length) || (comptrollersLength != values.length)) {\n            revert InvalidArguments();\n        }\n\n        for (uint256 i; i < comptrollersLength; ++i) {\n            address[] memory poolAssets = assets[i];\n            bool[] memory assetsValues = values[i];\n\n            if (poolAssets.length != assetsValues.length) {\n                revert InvalidArguments();\n            }\n\n            for (uint256 j; j < poolAssets.length; ++j) {\n                poolsAssetsDirectTransfer[comptrollers[i]][poolAssets[j]] = assetsValues[j];\n                emit PoolAssetsDirectTransferUpdated(comptrollers[i], poolAssets[j], assetsValues[j]);\n            }\n        }\n    }\n\n    /// @dev Get the Amount of the asset in the risk fund for the specific pool\n    /// @param comptroller Comptroller address (pool)\n    /// @param asset Asset address\n    /// @return Asset's reserve in risk fund\n    function getPoolAssetReserve(address comptroller, address asset) external view returns (uint256) {\n        require(IComptroller(comptroller).isComptroller(), \"ReserveHelpers: Comptroller address invalid\");\n        require(asset != address(0), \"ReserveHelpers: Asset address invalid\");\n        return poolsAssetsReserves[comptroller][asset];\n    }\n\n    /// @dev Update the reserve of the asset for the specific pool after transferring to risk fund\n    /// and transferring funds to the protocol share reserve\n    /// @param comptroller Comptroller address (pool)\n    /// @param asset Asset address\n    function updateAssetsState(address comptroller, address asset) public {\n        require(IComptroller(comptroller).isComptroller(), \"ReserveHelpers: Comptroller address invalid\");\n        require(asset != address(0), \"ReserveHelpers: Asset address invalid\");\n        require(poolRegistry != address(0), \"ReserveHelpers: Pool Registry address is not set\");\n        require(ensureAssetListed(comptroller, asset), \"ReserveHelpers: The pool doesn't support the asset\");\n\n        IERC20Upgradeable token = IERC20Upgradeable(asset);\n        uint256 currentBalance = token.balanceOf(address(this));\n        uint256 assetReserve = assetsReserves[asset];\n        if (currentBalance > assetReserve) {\n            uint256 balanceDifference;\n            unchecked {\n                balanceDifference = currentBalance - assetReserve;\n            }\n            if (poolsAssetsDirectTransfer[comptroller][asset]) {\n                token.safeTransfer(destinationAddress, balanceDifference);\n                emit AssetTransferredToDestination(comptroller, asset, balanceDifference);\n                IRiskFund(destinationAddress).updatePoolState(comptroller, asset, balanceDifference);\n            } else {\n                assetsReserves[asset] += balanceDifference;\n                poolsAssetsReserves[comptroller][asset] += balanceDifference;\n                emit AssetsReservesUpdated(comptroller, asset, balanceDifference);\n            }\n        }\n    }\n\n    /// @notice Get the balance for specific token\n    /// @param tokenAddress Address of the token\n    function balanceOf(address tokenAddress) public view override returns (uint256 tokenBalance) {\n        return assetsReserves[tokenAddress];\n    }\n\n    /// @notice Hook to perform after converting tokens\n    /// @dev After transfromation poolsAssetsReserves are settled by pool's reserves fraction\n    /// @param tokenInAddress Address of the tokenIn\n    /// @param tokenOutAddress Address of the tokenOut\n    /// @param amountIn Amount of tokenIn transferred\n    /// @param amountOut Amount of tokenOut transferred\n    function postConversionHook(\n        address tokenInAddress,\n        address tokenOutAddress,\n        uint256 amountIn,\n        uint256 amountOut\n    ) internal override {\n        address[] memory pools = getPools(tokenOutAddress);\n        uint256 assetReserve = assetsReserves[tokenOutAddress];\n        for (uint256 i; i < pools.length; ++i) {\n            uint256 poolShare = (poolsAssetsReserves[pools[i]][tokenOutAddress] * EXP_SCALE) / assetReserve;\n            if (poolShare == 0) continue;\n            updatePoolAssetsReserve(pools[i], tokenOutAddress, amountOut, poolShare);\n            uint256 poolAmountInShare = (poolShare * amountIn) / EXP_SCALE;\n            IRiskFund(destinationAddress).updatePoolState(pools[i], tokenInAddress, poolAmountInShare);\n        }\n\n        assetsReserves[tokenOutAddress] -= amountOut;\n    }\n\n    /// @notice Operations to perform after sweepToken\n    /// @param tokenAddress Address of the token\n    /// @param amount Amount transferred to address(to)\n    function postSweepToken(address tokenAddress, uint256 amount) internal override {\n        uint256 balance = IERC20Upgradeable(tokenAddress).balanceOf(address(this));\n        uint256 balanceDiff = balance - assetsReserves[tokenAddress];\n\n        if (balanceDiff < amount) {\n            uint256 amountDiff = amount - balanceDiff;\n            address[] memory pools = getPools(tokenAddress);\n            uint256 assetReserve = assetsReserves[tokenAddress];\n            for (uint256 i; i < pools.length; ++i) {\n                uint256 poolShare = (poolsAssetsReserves[pools[i]][tokenAddress] * EXP_SCALE) / assetReserve;\n                if (poolShare == 0) continue;\n                updatePoolAssetsReserve(pools[i], tokenAddress, amountDiff, poolShare);\n            }\n            assetsReserves[tokenAddress] -= amountDiff;\n        }\n    }\n\n    /// @notice Update the poolAssetsResreves upon transferring the tokens\n    /// @param pool Address of the pool\n    /// @param tokenAddress Address of the token\n    /// @param amount Amount transferred to address(to)\n    /// @param poolShare share for corresponding pool\n    function updatePoolAssetsReserve(address pool, address tokenAddress, uint256 amount, uint256 poolShare) internal {\n        uint256 poolAmountShare = (poolShare * amount) / EXP_SCALE;\n        poolsAssetsReserves[pool][tokenAddress] -= poolAmountShare;\n    }\n\n    /// @notice Get the array of all pools addresses\n    /// @param tokenAddress Address of the token\n    function getPools(address tokenAddress) internal view returns (address[] memory) {\n        address[] memory pools = IPoolRegistry(poolRegistry).getPoolsSupportedByAsset(tokenAddress);\n\n        if (isAssetListedInCore(tokenAddress)) {\n            uint256 poolsLength = pools.length;\n            address[] memory poolsWithCore = new address[](poolsLength + 1);\n\n            for (uint256 i; i < poolsLength; ++i) {\n                poolsWithCore[i] = pools[i];\n            }\n            poolsWithCore[poolsLength] = corePoolComptroller;\n            return poolsWithCore;\n        }\n\n        return pools;\n    }\n\n    function isAssetListedInCore(address tokenAddress) internal view returns (bool isAssetListed) {\n        address[] memory coreMarkets = IComptroller(corePoolComptroller).getAllMarkets();\n\n        for (uint256 i; i < coreMarkets.length; ++i) {\n            isAssetListed = (vBNB == coreMarkets[i])\n                ? (tokenAddress == NATIVE_WRAPPED)\n                : (IVToken(coreMarkets[i]).underlying() == tokenAddress);\n\n            if (isAssetListed) {\n                break;\n            }\n        }\n    }\n\n    function ensureAssetListed(address comptroller, address asset) internal view returns (bool) {\n        if (comptroller == corePoolComptroller) {\n            return isAssetListedInCore(asset);\n        }\n\n        return IPoolRegistry(poolRegistry).getVTokenForAsset(comptroller, asset) != address(0);\n    }\n}"
    },
    {
      "filename": "contracts/ProtocolReserve/RiskFundStorage.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\nimport { Ownable2StepUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\ncontract ReserveHelpersStorage is Ownable2StepUpgradeable {\n    /// @notice Deprecated slot for assetReserves mapping\n    bytes32 private __deprecatedSlot1;\n\n    /// @notice Available asset's fund per pool in RiskFund\n    /// Comptroller(pool) -> Asset -> amount\n    mapping(address => mapping(address => uint256)) public poolAssetsFunds;\n\n    /// @notice Deprecated slot for poolRegistry address\n    bytes32 private __deprecatedSlot2;\n    /// @notice Deprecated slot for status variable\n    bytes32 private __deprecatedSlot3;\n\n    /// @dev This empty reserved space is put in place to allow future versions to add new\n    /// variables without shifting down storage in the inheritance chain.\n    uint256[46] private __gap;\n}\n\ncontract MaxLoopsLimitHelpersStorage {\n    /// @notice Limit for the loops to avoid the DOS\n    /// @notice This state is deprecated, using it to prevent storage collision\n    uint256 public maxLoopsLimit;\n\n    /// @dev This empty reserved space is put in place to allow future versions to add new\n    /// variables without shifting down storage in the inheritance chain.\n    /// See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n    uint256[49] private __gap;\n}\n\n/// @title RiskFundV1Storage\n/// @author Venus\n/// @dev Risk fund V1 storage\ncontract RiskFundV1Storage is ReserveHelpersStorage, MaxLoopsLimitHelpersStorage {\n    /// @notice Address of base asset\n    address public convertibleBaseAsset;\n    /// @notice Address of shortfall contract\n    address public shortfall;\n\n    /// @notice This state is deprecated, using it to prevent storage collision\n    address private pancakeSwapRouter;\n    /// @notice This state is deprecated, using it to prevent storage collision\n    uint256 private minAmountToConvert;\n}\n\n/// @title RiskFundV2Storage\n/// @author Venus\n/// @dev Risk fund V2 storage\ncontract RiskFundV2Storage is RiskFundV1Storage, ReentrancyGuardUpgradeable {\n    /// @notice Risk fund converter address\n    address public riskFundConverter;\n}"
    },
    {
      "filename": "contracts/TokenConverter/XVSVaultConverter.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\nimport { SafeERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport { IERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport { ResilientOracle } from \"@venusprotocol/oracle/contracts/ResilientOracle.sol\";\n\nimport { AbstractTokenConverter } from \"./AbstractTokenConverter.sol\";\n\ncontract XVSVaultConverter is AbstractTokenConverter {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @param accessControlManager_ Access control manager contract address\n    /// @param priceOracle_ Resilient oracle address\n    /// @param destinationAddress_  Address at all incoming tokens will transferred to\n    function initialize(\n        address accessControlManager_,\n        ResilientOracle priceOracle_,\n        address destinationAddress_\n    ) public initializer {\n        // Initialize AbstractTokenConverter\n        __AbstractTokenConverter_init(accessControlManager_, priceOracle_, destinationAddress_);\n    }\n\n    /// @dev This function is called by protocolShareReserve\n    /// @param comptroller Comptroller address (pool)\n    /// @param asset Asset address.\n    function updateAssetsState(address comptroller, address asset) public {}\n\n    /// @notice Get the balance for specific token\n    /// @param tokenAddress Address of the token\n    function balanceOf(address tokenAddress) public view override returns (uint256 tokenBalance) {\n        IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);\n        tokenBalance = token.balanceOf(address(this));\n    }\n}"
    },
    {
      "filename": "contracts/ProtocolReserve/XVSVaultTreasury.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\nimport { SafeERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport { IERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport { AccessControlledV8 } from \"@venusprotocol/governance-contracts/contracts/Governance/AccessControlledV8.sol\";\n\nimport { ensureNonzeroAddress } from \"../Utils/Validators.sol\";\nimport { IXVSVault } from \"../Interfaces/IXVSVault.sol\";\n\ncontract XVSVaultTreasury is AccessControlledV8 {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @notice The xvs token address\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address public immutable xvsAddress;\n\n    /// @notice The xvsvault address\n    address public xvsVault;\n\n    /// @dev This empty reserved space is put in place to allow future versions to add new\n    /// variables without shifting down storage in the inheritance chain.\n    /// See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n    uint256[48] private __gap;\n\n    /// @notice Emitted when XVS vault address is updated\n    event XVSVaultUpdated(address indexed oldXVSVault, address indexed newXVSVault);\n\n    /// @notice Emitted when funds transferred to XVSStore address\n    event FundsTransferredToXVSStore(address indexed xvsStore, uint256 amountMantissa);\n\n    /// @notice Thrown when given input amount is zero\n    error InsufficientBalance();\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address xvsAddress_) {\n        ensureNonzeroAddress(xvsAddress_);\n        xvsAddress = xvsAddress_;\n\n        // Note that the contract is upgradeable. Use initialize() or reinitializers\n        // to set the state variables.\n        _disableInitializers();\n    }\n\n    /// @param accessControlManager_ Access control manager contract address\n    /// @param xvsVault_ XVSVault address\n    function initialize(address accessControlManager_, address xvsVault_) public virtual initializer {\n        __AccessControlled_init(accessControlManager_);\n\n        _setXVSVault(xvsVault_);\n    }\n\n    /// @dev XVS vault setter\n    /// @param xvsVault_ Address of the XVS vault\n    function setXVSVault(address xvsVault_) external onlyOwner {\n        _setXVSVault(xvsVault_);\n    }\n\n    function fundXVSVault(uint256 amountMantissa) external {\n        _checkAccessAllowed(\"fundXVSVault(amountMantissa)\");\n\n        uint256 balance = IERC20Upgradeable(xvsAddress).balanceOf(address(this));\n\n        if (balance < amountMantissa) {\n            revert InsufficientBalance();\n        }\n\n        address xvsStore = IXVSVault(xvsVault).xvsStore();\n        IERC20Upgradeable(xvsAddress).safeTransfer(xvsStore, amountMantissa);\n\n        emit FundsTransferredToXVSStore(xvsStore, amountMantissa);\n    }\n\n    /// @dev XVS vault setter\n    /// @param xvsVault_ Address of the XVS vault\n    /// @custom:event XVSVaultUpdated emits on success\n    /// @custom:error ZeroAddressNotAllowed is thrown when XVS vault address is zero\n    function _setXVSVault(address xvsVault_) internal {\n        ensureNonzeroAddress(xvsVault_);\n        address oldXVSVault = xvsVault;\n        xvsVault = xvsVault_;\n        emit XVSVaultUpdated(oldXVSVault, xvsVault_);\n    }\n}"
    },
    {
      "filename": "contracts/TokenConverter/IAbstractTokenConverter.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\nimport { ResilientOracle } from \"@venusprotocol/oracle/contracts/ResilientOracle.sol\";\n\ninterface IAbstractTokenConverter {\n    struct ConversionConfig {\n        /// tokenIn address\n        address tokenAddressIn;\n        /// tokenOut address\n        address tokenAddressOut;\n        /// incentive on conversion of tokens in mantissa i.e 10% incentive would be 0.1 * 1e18\n        uint256 incentive;\n        /// whether the conversion is enabled\n        bool enabled;\n    }\n\n    function pauseConversion() external;\n\n    function resumeConversion() external;\n\n    function setPriceOracle(ResilientOracle priceOracle_) external;\n\n    function setConversionConfig(ConversionConfig calldata conversionConfig) external;\n\n    function convertExactTokens(\n        uint256 amountInMantissa,\n        uint256 amountOutMinMantissa,\n        address tokenAddressIn,\n        address tokenAddressOut,\n        address to\n    ) external;\n\n    function convertForExactTokens(\n        uint256 amountInMaxMantissa,\n        uint256 amountOutMantissa,\n        address tokenAddressIn,\n        address tokenAddressOut,\n        address to\n    ) external;\n\n    function convertExactTokensSupportingFeeOnTransferTokens(\n        uint256 amountInMantissa,\n        uint256 amountOutMinMantissa,\n        address tokenAddressIn,\n        address tokenAddressOut,\n        address to\n    ) external;\n\n    function convertForExactTokensSupportingFeeOnTransferTokens(\n        uint256 amountInMaxMantissa,\n        uint256 amountOutMantissa,\n        address tokenAddressIn,\n        address tokenAddressOut,\n        address to\n    ) external;\n}"
    },
    {
      "filename": "contracts/ProtocolReserve/XVSVaultTreasury.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\nimport { SafeERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport { IERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport { AccessControlledV8 } from \"@venusprotocol/governance-contracts/contracts/Governance/AccessControlledV8.sol\";\n\nimport { ensureNonzeroAddress } from \"../Utils/Validators.sol\";\nimport { IXVSVault } from \"../Interfaces/IXVSVault.sol\";\n\ncontract XVSVaultTreasury is AccessControlledV8 {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @notice The xvs token address\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address public immutable xvsAddress;\n\n    /// @notice The xvsvault address\n    address public xvsVault;\n\n    /// @dev This empty reserved space is put in place to allow future versions to add new\n    /// variables without shifting down storage in the inheritance chain.\n    /// See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n    uint256[48] private __gap;\n\n    /// @notice Emitted when XVS vault address is updated\n    event XVSVaultUpdated(address indexed oldXVSVault, address indexed newXVSVault);\n\n    /// @notice Emitted when funds transferred to XVSStore address\n    event FundsTransferredToXVSStore(address indexed xvsStore, uint256 amountMantissa);\n\n    /// @notice Thrown when given input amount is zero\n    error InsufficientBalance();\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address xvsAddress_) {\n        ensureNonzeroAddress(xvsAddress_);\n        xvsAddress = xvsAddress_;\n\n        // Note that the contract is upgradeable. Use initialize() or reinitializers\n        // to set the state variables.\n        _disableInitializers();\n    }\n\n    /// @param accessControlManager_ Access control manager contract address\n    /// @param xvsVault_ XVSVault address\n    function initialize(address accessControlManager_, address xvsVault_) public virtual initializer {\n        __AccessControlled_init(accessControlManager_);\n\n        _setXVSVault(xvsVault_);\n    }\n\n    /// @dev XVS vault setter\n    /// @param xvsVault_ Address of the XVS vault\n    function setXVSVault(address xvsVault_) external onlyOwner {\n        _setXVSVault(xvsVault_);\n    }\n\n    function fundXVSVault(uint256 amountMantissa) external {\n        _checkAccessAllowed(\"fundXVSVault(amountMantissa)\");\n\n        uint256 balance = IERC20Upgradeable(xvsAddress).balanceOf(address(this));\n\n        if (balance < amountMantissa) {\n            revert InsufficientBalance();\n        }\n\n        address xvsStore = IXVSVault(xvsVault).xvsStore();\n        IERC20Upgradeable(xvsAddress).safeTransfer(xvsStore, amountMantissa);\n\n        emit FundsTransferredToXVSStore(xvsStore, amountMantissa);\n    }\n\n    /// @dev XVS vault setter\n    /// @param xvsVault_ Address of the XVS vault\n    /// @custom:event XVSVaultUpdated emits on success\n    /// @custom:error ZeroAddressNotAllowed is thrown when XVS vault address is zero\n    function _setXVSVault(address xvsVault_) internal {\n        ensureNonzeroAddress(xvsVault_);\n        address oldXVSVault = xvsVault;\n        xvsVault = xvsVault_;\n        emit XVSVaultUpdated(oldXVSVault, xvsVault_);\n    }\n}"
    },
    {
      "filename": "contracts/TokenConverter/IAbstractTokenConverter.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\nimport { ResilientOracle } from \"@venusprotocol/oracle/contracts/ResilientOracle.sol\";\n\ninterface IAbstractTokenConverter {\n    struct ConversionConfig {\n        /// tokenIn address\n        address tokenAddressIn;\n        /// tokenOut address\n        address tokenAddressOut;\n        /// incentive on conversion of tokens in mantissa i.e 10% incentive would be 0.1 * 1e18\n        uint256 incentive;\n        /// whether the conversion is enabled\n        bool enabled;\n    }\n\n    function pauseConversion() external;\n\n    function resumeConversion() external;\n\n    function setPriceOracle(ResilientOracle priceOracle_) external;\n\n    function setConversionConfig(ConversionConfig calldata conversionConfig) external;\n\n    function convertExactTokens(\n        uint256 amountInMantissa,\n        uint256 amountOutMinMantissa,\n        address tokenAddressIn,\n        address tokenAddressOut,\n        address to\n    ) external;\n\n    function convertForExactTokens(\n        uint256 amountInMaxMantissa,\n        uint256 amountOutMantissa,\n        address tokenAddressIn,\n        address tokenAddressOut,\n        address to\n    ) external;\n\n    function convertExactTokensSupportingFeeOnTransferTokens(\n        uint256 amountInMantissa,\n        uint256 amountOutMinMantissa,\n        address tokenAddressIn,\n        address tokenAddressOut,\n        address to\n    ) external;\n\n    function convertForExactTokensSupportingFeeOnTransferTokens(\n        uint256 amountInMaxMantissa,\n        uint256 amountOutMantissa,\n        address tokenAddressIn,\n        address tokenAddressOut,\n        address to\n    ) external;\n}"
    },
    {
      "filename": "contracts/TokenConverter/IAbstractTokenConverter.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\nimport { ResilientOracle } from \"@venusprotocol/oracle/contracts/ResilientOracle.sol\";\n\ninterface IAbstractTokenConverter {\n    struct ConversionConfig {\n        /// tokenIn address\n        address tokenAddressIn;\n        /// tokenOut address\n        address tokenAddressOut;\n        /// incentive on conversion of tokens in mantissa i.e 10% incentive would be 0.1 * 1e18\n        uint256 incentive;\n        /// whether the conversion is enabled\n        bool enabled;\n    }\n\n    function pauseConversion() external;\n\n    function resumeConversion() external;\n\n    function setPriceOracle(ResilientOracle priceOracle_) external;\n\n    function setConversionConfig(ConversionConfig calldata conversionConfig) external;\n\n    function convertExactTokens(\n        uint256 amountInMantissa,\n        uint256 amountOutMinMantissa,\n        address tokenAddressIn,\n        address tokenAddressOut,\n        address to\n    ) external;\n\n    function convertForExactTokens(\n        uint256 amountInMaxMantissa,\n        uint256 amountOutMantissa,\n        address tokenAddressIn,\n        address tokenAddressOut,\n        address to\n    ) external;\n\n    function convertExactTokensSupportingFeeOnTransferTokens(\n        uint256 amountInMantissa,\n        uint256 amountOutMinMantissa,\n        address tokenAddr"
    }
  ]
}