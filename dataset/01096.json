{
  "Title": "Missing Check of XVS Store Address",
  "Content": "In the `XVSVaultTreasury` contract, the `xvsStore` address is obtained from the `xvsVault` before [tokens are transferred to the `xvsStore`](https://github.com/VenusProtocol/protocol-reserve/blob/ca8f8ba3dfcf6f13d2db4ac230ac9337950525f6/contracts/ProtocolReserve/XVSVaultTreasury.sol#L69). However, there is no check that the address is non-zero.\n\n\nConsider verifying the `xvsStore` address before sending tokens to it.\n\n\n***Update:** Resolved at commit [e558b15](https://github.com/VenusProtocol/protocol-reserve/pull/24/commits/e558b1568840434b748582f4a3371c3bebec8a51).*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/ProtocolReserve/XVSVaultTreasury.sol",
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\nimport { SafeERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport { IERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport { AccessControlledV8 } from \"@venusprotocol/governance-contracts/contracts/Governance/AccessControlledV8.sol\";\n\nimport { ensureNonzeroAddress } from \"../Utils/Validators.sol\";\nimport { IXVSVault } from \"../Interfaces/IXVSVault.sol\";\n\ncontract XVSVaultTreasury is AccessControlledV8 {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @notice The xvs token address\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address public immutable xvsAddress;\n\n    /// @notice The xvsvault address\n    address public xvsVault;\n\n    /// @dev This empty reserved space is put in place to allow future versions to add new\n    /// variables without shifting down storage in the inheritance chain.\n    /// See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n    uint256[48] private __gap;\n\n    /// @notice Emitted when XVS vault address is updated\n    event XVSVaultUpdated(address indexed oldXVSVault, address indexed newXVSVault);\n\n    /// @notice Emitted when funds transferred to XVSStore address\n    event FundsTransferredToXVSStore(address indexed xvsStore, uint256 amountMantissa);\n\n    /// @notice Thrown when given input amount is zero\n    error InsufficientBalance();\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address xvsAddress_) {\n        ensureNonzeroAddress(xvsAddress_);\n        xvsAddress = xvsAddress_;\n\n        // Note that the contract is upgradeable. Use initialize() or reinitializers\n        // to set the state variables.\n        _disableInitializers();\n    }\n\n    /// @param accessControlManager_ Access control manager contract address\n    /// @param xvsVault_ XVSVault address\n    function initialize(address accessControlManager_, address xvsVault_) public virtual initializer {\n        __AccessControlled_init(accessControlManager_);\n\n        _setXVSVault(xvsVault_);\n    }\n\n    /// @dev XVS vault setter\n    /// @param xvsVault_ Address of the XVS vault\n    function setXVSVault(address xvsVault_) external onlyOwner {\n        _setXVSVault(xvsVault_);\n    }\n\n    function fundXVSVault(uint256 amountMantissa) external {\n        _checkAccessAllowed(\"fundXVSVault(amountMantissa)\");\n\n        uint256 balance = IERC20Upgradeable(xvsAddress).balanceOf(address(this));\n\n        if (balance < amountMantissa) {\n            revert InsufficientBalance();\n        }\n\n        address xvsStore = IXVSVault(xvsVault).xvsStore();\n        IERC20Upgradeable(xvsAddress).safeTransfer(xvsStore, amountMantissa);\n\n        emit FundsTransferredToXVSStore(xvsStore, amountMantissa);\n    }\n\n    /// @dev XVS vault setter\n    /// @param xvsVault_ Address of the XVS vault\n    /// @custom:event XVSVaultUpdated emits on success\n    /// @custom:error ZeroAddressNotAllowed is thrown when XVS vault address is zero\n    function _setXVSVault(address xvsVault_) internal {\n        ensureNonzeroAddress(xvsVault_);\n        address oldXVSVault = xvsVault;\n        xvsVault = xvsVault_;\n        emit XVSVaultUpdated(oldXVSVault, xvsVault_);\n    }\n}"
    }
  ]
}