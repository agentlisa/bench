{
  "Title": "No validation of the address parameter value in contract constructor",
  "Content": "##### Description\nThe variable is assigned the value of the constructor input parameter. But this parameter is not checked before this. If the value turns out to be zero, then it will be necessary redeploy the contract, since there is no other functionality to set this variable.\n\nAt the line https://github.com/pie-dao/ExperiPie/blob/facf3c246d9c43f5b1e0bad7dc2b0a9a2a2393c5/contracts/callManagers/LendingManager/LendingLogicAave.sol#L16 the `lendingPool` variable is set to the value of the `_lendingPool` input parameter.\n\nAt the line https://github.com/pie-dao/ExperiPie/blob/facf3c246d9c43f5b1e0bad7dc2b0a9a2a2393c5/contracts/callManagers/LendingManager/LendingLogicCompound.sol#L16 the `lendingRegistry` variable is set to the value of the `_lendingRegistry` input parameter.\n\nAt the line https://github.com/pie-dao/ExperiPie/blob/facf3c246d9c43f5b1e0bad7dc2b0a9a2a2393c5/contracts/callManagers/LendingManager/LendingManager.sol#L24 the `lendingRegistry` variable is set to the value of the `_lendingRegistry` input parameter.\n\nAt the line https://github.com/pie-dao/ExperiPie/blob/facf3c246d9c43f5b1e0bad7dc2b0a9a2a2393c5/contracts/callManagers/LendingManager/LendingManager.sol#L25 the variable `basket` is assigned the value of the input parameter` _basket`.\n\nAt the line https://github.com/pie-dao/ExperiPie/blob/facf3c246d9c43f5b1e0bad7dc2b0a9a2a2393c5/contracts/callManagers/RSIManager.sol#L31 values of the following variables are not checked: `_assetShort`,`_assetLong`, `_priceFeed`,`_basket`, `_synthetix`.\n\n##### Recommendation\nIn all the cases, it is necessary to add a check of the input parameter to zero before initializing the variables.\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/callManagers/LendingManager/LendingLogicAave.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.7.1;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../interfaces/ILendingLogic.sol\";\nimport \"../../interfaces/IAToken.sol\";\nimport \"../../interfaces/IAaveLendingPool.sol\";\n\ncontract LendingLogicAave is ILendingLogic {\n\n    IAaveLendingPool public lendingPool;\n    uint16 public referralCode;\n\n    constructor(address _lendingPool, uint16 _referralCode) {\n        lendingPool = IAaveLendingPool(_lendingPool);\n        referralCode = _referralCode;\n    }\n\n    function lend(address _underlying, uint256 _amount) external view override returns(address[] memory targets, bytes[] memory data) {\n        IERC20 underlying = IERC20(_underlying);\n\n        address core = lendingPool.core();\n\n        targets = new address[](3);\n        data = new bytes[](3);\n\n        // zero out approval to be sure\n        targets[0] = _underlying;\n        data[0] = abi.encodeWithSelector(underlying.approve.selector, address(core), 0);\n\n        // Set approval\n        targets[1] = _underlying;\n        data[1] = abi.encodeWithSelector(underlying.approve.selector, address(core), _amount);\n\n        // Deposit into Aave\n        targets[2] = address(lendingPool);\n        data[2] =  abi.encodeWithSelector(lendingPool.deposit.selector, _underlying, _amount, referralCode);\n\n        return(targets, data);\n    }\n    function unlend(address _wrapped, uint256 _amount) external view override returns(address[] memory targets, bytes[] memory data) {\n        targets = new address[](1);\n        data = new bytes[](1);\n\n        targets[0] = _wrapped;\n        data[0] = abi.encodeWithSelector(IAToken.redeem.selector, _amount);\n        \n        return(targets, data);\n    }\n\n}"
    },
    {
      "filename": "contracts/callManagers/LendingManager/LendingLogicCompound.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.7.1;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../interfaces/ILendingLogic.sol\";\nimport \"./LendingRegistry.sol\";\nimport \"../../interfaces/ICToken.sol\";\n\ncontract LendingLogicCompound is ILendingLogic {\n\n    LendingRegistry public lendingRegistry;\n    bytes32 public constant PROTOCOL = keccak256(abi.encodePacked(\"Compound\"));\n\n    constructor(address _lendingRegistry) {\n        lendingRegistry = LendingRegistry(_lendingRegistry);\n    }\n\n    function lend(address _underlying, uint256 _amount) external view override returns(address[] memory targets, bytes[] memory data) {\n        IERC20 underlying = IERC20(_underlying);\n\n        targets = new address[](3);\n        data = new bytes[](3);\n\n\n        address cToken = lendingRegistry.underlyingToProtocolWrapped(_underlying, PROTOCOL);\n\n        // zero out approval to be sure\n        targets[0] = _underlying;\n        data[0] = abi.encodeWithSelector(underlying.approve.selector, cToken, 0);\n\n        // Set approval\n        targets[1] = _underlying;\n        data[1] = abi.encodeWithSelector(underlying.approve.selector, cToken, _amount);\n\n        // Deposit into Compound\n        targets[2] = cToken;\n\n        data[2] =  abi.encodeWithSelector(ICToken.mint.selector, _amount);\n\n        return(targets, data);\n    }\n    function unlend(address _wrapped, uint256 _amount) external view override returns(address[] memory targets, bytes[] memory data) {\n        targets = new address[](1);\n        data = new bytes[](1);\n\n        targets[0] = _wrapped;\n        data[0] = abi.encodeWithSelector(ICToken.redeem.selector, _amount);\n        \n        return(targets, data);\n    }\n\n}"
    },
    {
      "filename": "contracts/callManagers/LendingManager/LendingManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.7.1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"./LendingRegistry.sol\";\nimport \"../../interfaces/IExperiPie.sol\";\n\ncontract LendingManager is Ownable {\n    using Math for uint256;\n\n    LendingRegistry public lendingRegistry;\n    IExperiPie public basket;\n\n    event Lend(address indexed underlying, uint256 amount, bytes32 indexed protocol);\n    event UnLend(address indexed wrapped, uint256 amount);\n    /**\n        @notice Constructor\n        @param _lendingRegistry Address of the lendingRegistry contract\n        @param _basket Address of the pool/pie/basket to manage\n    */\n    constructor(address _lendingRegistry, address _basket) public {\n        lendingRegistry = LendingRegistry(_lendingRegistry);\n        basket = IExperiPie(_basket);\n    }\n\n    /**\n        @notice Move underlying to a lending protocol\n        @param _underlying Address of the underlying token\n        @param _amount Amount of underlying to lend\n        @param _protocol Bytes32 protocol key to lend to\n    */\n    function lend(address _underlying, uint256 _amount, bytes32 _protocol) public onlyOwner {\n        // _amount or actual balance, whatever is less\n        uint256 amount = _amount.min(IERC20(_underlying).balanceOf(address(basket)));\n\n        //lend token\n        (\n            address[] memory _targets,\n            bytes[] memory _data\n        ) = lendingRegistry.getLendTXData(_underlying, amount, _protocol);\n\n        basket.callNoValue(_targets, _data);\n\n        // if needed remove underlying from basket\n        removeToken(_underlying);\n\n        // add wrapped token\n        addToken(lendingRegistry.underlyingToProtocolWrapped(_underlying, _protocol));\n\n        emit Lend(_underlying, _amount, _protocol);\n    }\n\n    /**\n        @notice Unlend wrapped token from its lending protocol\n        @param _wrapped Address of the wrapped token\n        @param _amount Amount of the wrapped token to unlend\n    */\n    function unlend(address _wrapped, uint256 _amount) public onlyOwner {\n        // unlend token\n         // _amount or actual balance, whatever is less\n        uint256 amount = _amount.min(IERC20(_wrapped).balanceOf(address(basket)));\n\n        //Unlend token\n        (\n            address[] memory _targets,\n            bytes[] memory _data\n        ) = lendingRegistry.getUnlendTXData(_wrapped, amount);\n        basket.callNoValue(_targets, _data);\n\n        // if needed add underlying\n        addToken(lendingRegistry.wrappedToUnderlying(_wrapped));\n\n        // if needed remove wrapped\n        removeToken(_wrapped);\n\n        emit UnLend(_wrapped, _amount);\n    }\n\n    /**\n        @notice Unlend and immediately lend in a different protocol\n        @param _wrapped Address of the wrapped token to bounce to another protocol\n        @param _amount Amount of the wrapped token to bounce to the other protocol\n        @param _toProtocol Protocol to deposit bounced tokens in\n    */\n    function bounce(address _wrapped, uint256 _amount, bytes32 _toProtocol) external {\n       unlend(_wrapped, _amount);\n       // Bounce all to new protocol\n       lend(lendingRegistry.wrappedToUnderlying(_wrapped), uint256(-1), _toProtocol);\n    }\n\n    function removeToken(address _token) internal {\n        uint256 balance = basket.balance(_token);\n        bool inPool = basket.getTokenInPool(_token);\n        //if there is a token balance of the token is not in the pool, skip\n        if(balance != 0 || !inPool) {\n            return;\n        }\n\n        // remove token\n        basket.singleCall(address(basket), abi.encodeWithSelector(basket.removeToken.selector, _token), 0);\n    }\n\n    function addToken(address _token) internal {\n        uint256 balance = basket.balance(_token);\n        bool inPool = basket.getTokenInPool(_token);\n        // If token has no balance or is already in the pool, skip\n        if(balance == 0 || inPool) {\n            return;\n        }\n\n        // add token\n        basket.singleCall(address(basket), abi.encodeWithSelector(basket.addToken.selector, _token), 0);\n    }\n \n}"
    },
    {
      "filename": "contracts/callManagers/LendingManager/LendingManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.7.1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"./LendingRegistry.sol\";\nimport \"../../interfaces/IExperiPie.sol\";\n\ncontract LendingManager is Ownable {\n    using Math for uint256;\n\n    LendingRegistry public lendingRegistry;\n    IExperiPie public basket;\n\n    event Lend(address indexed underlying, uint256 amount, bytes32 indexed protocol);\n    event UnLend(address indexed wrapped, uint256 amount);\n    /**\n        @notice Constructor\n        @param _lendingRegistry Address of the lendingRegistry contract\n        @param _basket Address of the pool/pie/basket to manage\n    */\n    constructor(address _lendingRegistry, address _basket) public {\n        lendingRegistry = LendingRegistry(_lendingRegistry);\n        basket = IExperiPie(_basket);\n    }\n\n    /**\n        @notice Move underlying to a lending protocol\n        @param _underlying Address of the underlying token\n        @param _amount Amount of underlying to lend\n        @param _protocol Bytes32 protocol key to lend to\n    */\n    function lend(address _underlying, uint256 _amount, bytes32 _protocol) public onlyOwner {\n        // _amount or actual balance, whatever is less\n        uint256 amount = _amount.min(IERC20(_underlying).balanceOf(address(basket)));\n\n        //lend token\n        (\n            address[] memory _targets,\n            bytes[] memory _data\n        ) = lendingRegistry.getLendTXData(_underlying, amount, _protocol);\n\n        basket.callNoValue(_targets, _data);\n\n        // if needed remove underlying from basket\n        removeToken(_underlying);\n\n        // add wrapped token\n        addToken(lendingRegistry.underlyingToProtocolWrapped(_underlying, _protocol));\n\n        emit Lend(_underlying, _amount, _protocol);\n    }\n\n    /**\n        @notice Unlend wrapped token from its lending protocol\n        @param _wrapped Address of the wrapped token\n        @param _amount Amount of the wrapped token to unlend\n    */\n    function unlend(address _wrapped, uint256 _amount) public onlyOwner {\n        // unlend token\n         // _amount or actual balance, whatever is less\n        uint256 amount = _amount.min(IERC20(_wrapped).balanceOf(address(basket)));\n\n        //Unlend token\n        (\n            address[] memory _targets,\n            bytes[] memory _data\n        ) = lendingRegistry.getUnlendTXData(_wrapped, amount);\n        basket.callNoValue(_targets, _data);\n\n        // if needed add underlying\n        addToken(lendingRegistry.wrappedToUnderlying(_wrapped));\n\n        // if needed remove wrapped\n        removeToken(_wrapped);\n\n        emit UnLend(_wrapped, _amount);\n    }\n\n    /**\n        @notice Unlend and immediately lend in a different protocol\n        @param _wrapped Address of the wrapped token to bounce to another protocol\n        @param _amount Amount of the wrapped token to bounce to the other protocol\n        @param _toProtocol Protocol to deposit bounced tokens in\n    */\n    function bounce(address _wrapped, uint256 _amount, bytes32 _toProtocol) external {\n       unlend(_wrapped, _amount);\n       // Bounce all to new protocol\n       lend(lendingRegistry.wrappedToUnderlying(_wrapped), uint256(-1), _toProtocol);\n    }\n\n    function removeToken(address _token) internal {\n        uint256 balance = basket.balance(_token);\n        bool inPool = basket.getTokenInPool(_token);\n        //if there is a token balance of the token is not in the pool, skip\n        if(balance != 0 || !inPool) {\n            return;\n        }\n\n        // remove token\n        basket.singleCall(address(basket), abi.encodeWithSelector(basket.removeToken.selector, _token), 0);\n    }\n\n    function addToken(address _token) internal {\n        uint256 balance = basket.balance(_token);\n        bool inPool = basket.getTokenInPool(_token);\n        // If token has no balance or is already in the pool, skip\n        if(balance == 0 || inPool) {\n            return;\n        }\n\n        // add token\n        basket.singleCall(address(basket), abi.encodeWithSelector(basket.addToken.selector, _token), 0);\n    }\n \n}"
    },
    {
      "filename": "contracts/callManagers/RSIManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.7.1;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/ISynthetix.sol\";\nimport \"../interfaces/IExperiPie.sol\";\nimport \"../interfaces/IPriceReferenceFeed.sol\";\n\ncontract RSISynthetixManager {\n\n    address public immutable assetShort;\n    address public immutable assetLong;\n    bytes32 public immutable assetShortKey;\n    bytes32 public immutable assetLongKey;\n\n    IPriceReferenceFeed public immutable priceFeed;\n    IExperiPie public immutable basket;\n    ISynthetix public immutable synthetix;\n\n    struct RoundData {\n        uint80 roundId;\n        int256 answer;\n        uint256 startedAt; \n        uint256 updatedAt; \n        uint80 answeredInRound;\n    }\n\n    event Rebalanced(address indexed basket, address indexed fromToken, address indexed toToken);\n\n    constructor(\n        address _assetShort,\n        address _assetLong,\n        bytes32 _assetShortKey,\n        bytes32 _assetLongKey,\n        address _priceFeed,\n        address _basket,\n        address _synthetix\n    ) {\n        assetShort = _assetShort;\n        assetLong = _assetLong;\n        assetShortKey = _assetShortKey;\n        assetLongKey = _assetLongKey;\n        priceFeed = IPriceReferenceFeed(_priceFeed);\n        basket = IExperiPie(_basket);\n        synthetix = ISynthetix(_synthetix);\n    }\n\n\n    function rebalance() external {\n        RoundData memory roundData = readLatestRound();\n        require(roundData.updatedAt > 0, \"Round not complete\");\n\n        if(roundData.answer <= 30 * 10**18) {\n            // long\n            long();\n            return;\n        } else if(roundData.answer >= 70 * 10**18) {\n            // Short\n            short();\n            return;\n        }\n    }\n\n    function long() internal {\n        IERC20 currentToken = IERC20(getCurrentToken());\n        require(address(currentToken) == assetShort, \"Can only long when short\");\n\n        uint256 currentTokenBalance = currentToken.balanceOf(address(basket));\n\n        address[] memory targets = new address[](4);\n        bytes[] memory data = new bytes[](4);\n        uint256[] memory values = new uint256[](4);\n\n        // lock pool\n        targets[0] = address(basket);\n        // lock for 30\n        data[0] = setLockData(block.number + 30);\n\n        // Swap on synthetix\n        targets[1] = address(synthetix);\n        data[1] = abi.encodeWithSelector(synthetix.exchange.selector, assetShortKey, currentTokenBalance, assetLongKey);\n\n\n        // Remove current token\n        targets[2] = address(basket);\n        data[2] = abi.encodeWithSelector(basket.removeToken.selector, assetShort);\n\n        // Add new token\n        targets[3] = address(basket);\n        data[3] = abi.encodeWithSelector(basket.addToken.selector, assetLong);\n\n        // Do calls\n        basket.call(targets, data, values);\n\n        // sanity checks\n        require(currentToken.balanceOf(address(basket)) == 0, \"Current token balance should be zero\");\n        require(IERC20(assetLong).balanceOf(address(basket)) >= 10**6, \"Amount too small\");\n\n        emit Rebalanced(address(basket), assetShort, assetLong);\n    }\n\n    function short() internal {\n        IERC20 currentToken = IERC20(getCurrentToken());\n        require(address(currentToken) == assetLong, \"Can only short when long\");\n\n        uint256 currentTokenBalance = currentToken.balanceOf(address(basket));\n\n        address[] memory targets = new address[](4);\n        bytes[] memory data = new bytes[](4);\n        uint256[] memory values = new uint256[](4);\n\n        // lock pool\n        targets[0] = address(basket);\n        // lock for 30\n        data[0] = setLockData(block.number + 30);\n\n        // Swap on synthetix\n        targets[1] = address(synthetix);\n        data[1] = abi.encodeWithSelector(synthetix.exchange.selector, assetLongKey, currentTokenBalance, assetShortKey);\n\n        // Remove current token\n        targets[2] = address(basket);\n        data[2] = abi.encodeWithSelector(basket.removeToken.selector, assetLong);\n\n        // Add new token\n        targets[3] = address(basket);\n        data[3] = abi.encodeWithSelector(basket.addToken.selector, assetShort);\n\n        // Do calls\n        basket.call(targets, data, values);\n\n        // sanity checks\n        require(currentToken.balanceOf(address(basket)) == 0, \"Current token balance should be zero\");\n        \n        // Catched by addToken in the basket itself\n        // require(IERC20(assetShort).balanceOf(address(basket)) >= 10**6, \"Amount too small\");\n\n        emit Rebalanced(address(basket), assetShort, assetLong);\n    }\n\n    function getCurrentToken() public view returns(address) {\n        address[] memory tokens = basket.getTokens();\n        require(tokens.length == 1, \"RSI Pie can only have 1 asset at the time\");\n        return tokens[0];\n    }\n\n\n    function setLockData(uint256 _block) internal returns(bytes memory data) {\n        bytes memory data = abi.encodeWithSelector(basket.setLock.selector, _block);\n        return data;\n    }\n    function readRound(uint256 _round) public view returns(RoundData memory data) {\n        (\n            uint80 roundId, \n            int256 answer, \n            uint256 startedAt, \n            uint256 updatedAt, \n            uint80 answeredInRound\n        ) = priceFeed.getRoundData(uint80(_round));\n\n        return RoundData({\n            roundId: roundId,\n            answer: answer,\n            startedAt: startedAt,\n            updatedAt: updatedAt,\n            answeredInRound: answeredInRound\n        });\n    }\n\n    function readLatestRound() public view returns(RoundData memory data) {\n        (\n            uint80 roundId, \n            int256 answer, \n            uint256 startedAt, \n            uint256 updatedAt, \n            uint80 answeredInRound\n        ) = priceFeed.latestRoundData();\n\n        return RoundData({\n            roundId: roundId,\n            answer: answer,\n            startedAt: startedAt,\n            updatedAt: updatedAt,\n            answeredInRound: answeredInRound\n        });\n    }\n\n}"
    }
  ]
}