{
  "Title": "M-1: No check for active L2 Sequencer",
  "Content": "# Issue M-1: No check for active L2 Sequencer \n\nSource: https://github.com/sherlock-audit/2023-10-notional-judging/issues/2 \n\n## Found by \n0xMaroutis, Vagner, ZanyBonzy\n## Summary\nUsing Chainlink in L2 chains such as Arbitrum requires to check if the sequencer is down to avoid prices from looking like they are fresh although they are not according to their [recommendation](https://docs.chain.link/data-feeds/l2-sequencer-feeds#arbitrum)\n\n## Vulnerability Detail\nThe `SingleSidedLPVaultBase` and `CrossCurrencyVault` contracts make the `getOraclePrice` external call to the `TradingModule` contract. However, the `getOraclePrice` in the `TradingModule` makes no check to see if the sequencer is down.\n\n## Impact\nIf the sequencer goes down, the protocol will allow users to continue to operate at the previous (stale) rates and this can be leveraged by malicious actors to gain unfair advantage.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-10-notional/blob/7aadd254da5f645a7e1b718e7f9128f845e10f02/leveraged-vaults/contracts/vaults/common/SingleSidedLPVaultBase.sol#L323\n\n```solidity\n    function _getOraclePairPrice(address base, address quote) internal view returns (uint256) {\n        (int256 rate, int256 precision) = TRADING_MODULE.getOraclePrice(base, quote);\n        require(rate > 0);\n        require(precision > 0);\n        return uint256(rate) * POOL_PRECISION() / uint256(precision);\n    }\n```\n\nhttps://github.com/sherlock-audit/2023-10-notional/blob/7aadd254da5f645a7e1b718e7f9128f845e10f02/leveraged-vaults/contracts/vaults/CrossCurrencyVault.sol#L131\n\n```solidity\n        (int256 rate, int256 rateDecimals) = TRADING_MODULE.getOraclePrice(\n```\n\nhttps://github.com/sherlock-audit/2023-10-notional/blob/7aadd254da5f645a7e1b718e7f9128f845e10f02/leveraged-vaults/contracts/trading/TradingModule.sol#L71C1-L77C6\n\n```solidity\n    function getOraclePrice(address baseToken, address quoteToken)\n        public\n        view\n        override\n        returns (int256 answer, int256 decimals)\n    {\n        PriceOracle memory baseOracle = priceOracles[baseToken];\n        PriceOracle memory quoteOracle = priceOracles[quoteToken];\n\n        int256 baseDecimals = int256(10**baseOracle.rateDecimals);\n        int256 quoteDecimals = int256(10**quoteOracle.rateDecimals);\n\n        (/* */, int256 basePrice, /* */, uint256 bpUpdatedAt, /* */) = baseOracle.oracle.latestRoundData();\n        require(block.timestamp - bpUpdatedAt <= maxOracleFreshnessInSeconds);\n        require(basePrice > 0); /// @dev: Chainlink Rate Error\n\n        (/* */, int256 quotePrice, /* */, uint256 qpUpdatedAt, /* */) = quoteOracle.oracle.latestRoundData();\n        require(block.timestamp - qpUpdatedAt <= maxOracleFreshnessInSeconds);\n        require(quotePrice > 0); /// @dev: Chainlink Rate Error\n\n        answer =\n            (basePrice * quoteDecimals * RATE_DECIMALS) /\n            (quotePrice * baseDecimals);\n        decimals = RATE_DECIMALS;\n    }\n```\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIt is recommended to follow the Chailink [example code](https://docs.chain.link/data-feeds/l2-sequencer-feeds#example-code)\n\n\n\n## Discussion\n\n**jeffywu**\n\nValid, good suggestion\n\n**jeffywu**\n\nhttps://github.com/notional-finance/leveraged-vaults/pull/76\n\n**nevillehuang**\n\nJust to further avoid any potential escalations (if it helps), I am aware of the recent sherlock rule changes [here](https://docs.sherlock.xyz/audits/judging/judging#vii.-list-of-issue-categories-that-are-not-considered-valid):\n\n> 20. Chain re-org and network liveness related issues are not considered valid.\nException: If an issue concerns any kind of a network admin (e.g. a sequencer), can be remedied by a smart contract modification, the procol team considers external admins restricted and the considered network was explicitly mentioned in the contest README, it may be a valid medium. It should be assumed that any such network issues will be resolved within 7 days, if that may be possible.\n\nImo, this constitutes a valid medium given considered network (Arbitrum) was explicitly mentioned in the contest README and external admins are restricted as seen below here\n\n> On what chains are the smart contracts going to be deployed?\n\n> Arbitrum, Mainnet, Optimism\n\nand here:\n\n> Are the admins of the protocols your contracts integrate with (if any) TRUSTED or RESTRICTED?\n\n> RESTRICTED, see answer to question below: \"In case of external protocol integrations, are the risks of external contracts pausing or executing an emergency withdrawal acceptable?\"\n> Our understanding of the external protocols is that the scope of admin functionality is restricted.\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/119",
  "Code": [
    {
      "filename": "leveraged-vaults/contracts/vaults/common/SingleSidedLPVaultBase.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\";\n\nimport {BaseStrategyVault} from \"./BaseStrategyVault.sol\";\nimport {Errors} from \"../../global/Errors.sol\";\nimport {Constants} from \"../../global/Constants.sol\";\nimport {TypeConvert} from \"../../global/TypeConvert.sol\";\nimport {TokenUtils} from \"../../utils/TokenUtils.sol\";\nimport {StrategyUtils} from \"./StrategyUtils.sol\";\nimport {VaultStorage} from \"./VaultStorage.sol\";\n\nimport {IERC20} from \"../../../interfaces/IERC20.sol\";\nimport {\n    ISingleSidedLPStrategyVault,\n    StrategyVaultSettings,\n    InitParams,\n    StrategyVaultState,\n    SingleSidedRewardTradeParams,\n    DepositParams,\n    DepositTradeParams,\n    RedeemParams,\n    TradeParams\n} from \"../../../interfaces/notional/ISingleSidedLPStrategyVault.sol\";\nimport {NotionalProxy} from \"../../../interfaces/notional/NotionalProxy.sol\";\nimport {ITradingModule, DexId} from \"../../../interfaces/trading/ITradingModule.sol\";\n\n/**\n * @notice Base contract for the SingleSidedLP strategy. This strategy deposits into an LP\n * pool given a single borrowed currency. Allows for users to trade via external exchanges\n * during entry and exit, but the general expected behavior is single sided entries and\n * exits. Inheriting contracts will fill in the implementation details for integration with\n * the external DEX pool.\n */\nabstract contract SingleSidedLPVaultBase is BaseStrategyVault, UUPSUpgradeable, ISingleSidedLPStrategyVault {\n    using TypeConvert for uint256;\n    using VaultStorage for StrategyVaultState;\n\n    uint256 internal constant MAX_TOKENS = 5;\n    uint8 internal constant NOT_FOUND = type(uint8).max;\n    /// @notice Bit mask for the 'LOCKED\" flag big\n    uint32 internal constant FLAG_LOCKED = 1 << 0;\n\n    /************************************************************************\n     * VIRTUAL FUNCTIONS                                                    *\n     * These virtual functions are used to isolate implementation specific  *\n     * behavior.                                                            *\n     ************************************************************************/\n\n    /// @notice Total number of tokens held by the LP token\n    function NUM_TOKENS() internal view virtual returns (uint256);\n\n    /// @notice Addresses of tokens held and decimal places of each token. ETH will always be\n    /// recorded in this array as Deployments.ETH_Address\n    function TOKENS() internal view virtual returns (IERC20[] memory, uint8[] memory decimals);\n\n    /// @notice Address of the LP token\n    function POOL_TOKEN() internal view virtual returns (IERC20);\n\n    /// @notice Index of the TOKENS() array that refers to the primary borrowed currency by the\n    /// leveraged vault. All valuations are done in terms of this currency.\n    function PRIMARY_INDEX() internal view virtual returns (uint256);\n\n    /// @notice Precision (i.e. 10 ** decimals) of the LP token.\n    function POOL_PRECISION() internal view virtual returns (uint256);\n\n    /// @notice Returns the value of one LP token in terms of the primary borrowed currency by this\n    /// strategy. Will revert if the spot price on the pool is not within some deviation tolerance of\n    /// the implied oracle price. This is intended to prevent any pool manipulation.\n    /// The value of the LP token is calculated as the value of the token if all the balance claims are\n    /// withdrawn proportionally and then converted to the primary currency at the oracle price. Slippage\n    /// from selling the tokens is not considered, any slippage effects will be captured by the maximum\n    /// leverage ratio allowed before liquidation.\n    function _checkPriceAndCalculateValue() internal view virtual returns (uint256 oneLPValueInPrimary);\n\n    /// @notice Called once during initialization to set the initial token approvals.\n    function _initialApproveTokens() internal virtual;\n\n    /// @notice Called to claim reward tokens\n    function _claimRewardTokens() internal virtual;\n\n    /// @notice Called during reward reinvestment to validate that the token being sold is not one\n    /// of the tokens that is required for the vault to function properly (i.e. one of the pool tokens\n    /// or any of the reward booster tokens).\n    function _isInvalidRewardToken(address token) internal view virtual returns (bool);\n\n    /// @notice Implementation specific wrapper for joining a pool with the given amounts. Will also\n    /// stake on the relevant booster protocol.\n    function _joinPoolAndStake(\n        uint256[] memory amounts, uint256 minPoolClaim\n    ) internal virtual returns (uint256 lpTokens);\n\n    /// @notice Implementation specific wrapper for unstaking from the booster protocol and withdrawing\n    /// funds from the LP pool\n    function _unstakeAndExitPool(\n        uint256 poolClaim, uint256[] memory minAmounts, bool isSingleSided\n    ) internal virtual returns (uint256[] memory exitBalances);\n\n    /// @notice Returns the total supply of the pool token. Is a virtual function because\n    /// ComposableStablePools use a \"virtual supply\" and a different method must be called\n    /// to get the actual total supply.\n    function _totalPoolSupply() internal view virtual returns (uint256) {\n        return POOL_TOKEN().totalSupply();\n    }\n\n    /************************************************************************\n     * CLASS FUNCTIONS                                                      *\n     * Below are class functions that represent the base implementation     *\n     * of the Single Sided LP strategy.                                     *\n     ************************************************************************/\n\n    constructor(NotionalProxy notional_, ITradingModule tradingModule_)\n        BaseStrategyVault(notional_, tradingModule_) {}\n\n    /************************************************************************\n     * EXTERNAL VIEW FUNCTIONS                                              *\n     ************************************************************************/\n\n    /// @notice Returns basic information about the vault for use in the user interface.\n    function getStrategyVaultInfo() external view override returns (SingleSidedLPStrategyVaultInfo memory) {\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n        return SingleSidedLPStrategyVaultInfo({\n            pool: address(POOL_TOKEN()),\n            singleSidedTokenIndex: uint8(PRIMARY_INDEX()),\n            totalLPTokens: state.totalPoolClaim,\n            totalVaultShares: state.totalVaultSharesGlobal\n        });\n    }\n\n    /// @notice Returns the current locked status of the vault\n    function isLocked() public view returns (bool) {\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n        return _hasFlag(state.flags, FLAG_LOCKED);\n    }\n\n    /// @notice Returns the current price of a vault share, even when there are no vault shares\n    /// in the strategy. Used by the user interface to collect historical valuation information.\n    function getExchangeRate(uint256 /* maturity */) external view override returns (int256) {\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n        uint256 oneLPValueInPrimary = _checkPriceAndCalculateValue();\n        // If inside an emergency exit, just report the one LP value in primary since the total\n        // pool claim will be 0\n        if (state.totalVaultSharesGlobal == 0 || isLocked()) {\n            return oneLPValueInPrimary.toInt();\n        } else {\n            uint256 lpTokensPerVaultShare = (uint256(Constants.INTERNAL_TOKEN_PRECISION) * state.totalPoolClaim)\n                / state.totalVaultSharesGlobal;\n            return (oneLPValueInPrimary * lpTokensPerVaultShare / POOL_PRECISION()).toInt();\n        }\n    }\n\n    /************************************************************************\n     * ADMIN FUNCTIONS                                                      *\n     * Administrative functions to set settings and initialize the vault.   *\n     * These methods are only callable by the Notional owner.               *\n     ************************************************************************/\n\n    /// @notice Allow Notional owner to upgrade the contract\n    function _authorizeUpgrade(\n        address /* newImplementation */\n    ) internal override onlyNotionalOwner {}\n\n    /// @notice Updates the vault settings include the maximum oracle deviation limit and the\n    /// maximum percent of the LP pool that the vault can hold.\n    function setStrategyVaultSettings(StrategyVaultSettings calldata settings) external onlyNotionalOwner {\n        // Validation occurs inside this method\n        VaultStorage.setStrategyVaultSettings(settings);\n    }\n\n    /// @notice Called to initialize the vault and set the initial approvals. All of the other vault\n    /// parameters are set via immutable parameters already.\n    function initialize(InitParams calldata params) external override initializer onlyNotionalOwner {\n        // Initialize the base vault\n        __INIT_VAULT(params.name, params.borrowCurrencyId);\n\n        // Settings are validated in setStrategyVaultSettings\n        VaultStorage.setStrategyVaultSettings(params.settings);\n\n        _initialApproveTokens();\n    }\n\n    /************************************************************************\n     * USER FUNCTIONS                                                       *\n     * These functions are called during normal usage of the vault.         *\n     * They allow for deposits and redemptions from the vault as well as a  *\n     * valuation check that is used by Notional to determine if the user is *\n     * properly collateralized.                                             *\n     ************************************************************************/\n\n    /// @notice This is a virtual function called by BaseStrategyVault which ensures that\n    /// this method is only called by Notional after an initial borrow has been made and\n    /// the deposit amount has been transferred to this vault. Will join the LP pool with\n    /// the funds given and then return the total vault shares minted.\n    function _depositFromNotional(\n        address /* account */, uint256 deposit, uint256 /* maturity */, bytes calldata data\n    ) internal override whenNotLocked returns (uint256 vaultSharesMinted) {\n        // Short circuit any zero deposit amounts\n        if (deposit == 0) return 0;\n\n        DepositParams memory params = abi.decode(data, (DepositParams));\n        uint256[] memory amounts = new uint256[](NUM_TOKENS());\n        amounts[PRIMARY_INDEX()] = deposit;\n\n        // If depositTrades are specified, then parts of the initial deposit are traded\n        // for corresponding amounts of the other pool tokens via external exchanges. If\n        // these amounts are not specified then the pool will just be joined single sided.\n        // Deposit trades are not automatically enabled on vaults since the trading module\n        // requires explicit permission for every token that can be sold by an address.\n        if (params.depositTrades.length > 0) {\n            (IERC20[] memory tokens, /* */) = TOKENS();\n            // This is an external library call so the memory location of amounts is\n            // different before and after the call.\n            amounts = StrategyUtils.executeDepositTrades(\n                tokens,\n                amounts,\n                params.depositTrades,\n                PRIMARY_INDEX()\n            );\n        }\n\n        uint256 lpTokens = _joinPoolAndStake(amounts, params.minPoolClaim);\n        return _mintVaultShares(lpTokens);\n    }\n\n    /// @notice Given a number of LP tokens minted, issues vault shares back to the holder. Vault\n    /// shares are claim on the LP tokens held by the vault. As rewards are reinvested, one vault\n    /// share is a claim on an increasing amount of LP tokens.\n    function _mintVaultShares(uint256 lpTokens) internal returns (uint256 vaultShares) {\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n        if (state.totalPoolClaim == 0) {\n            // Vault Shares are in 8 decimal precision\n            vaultShares = (lpTokens * uint256(Constants.INTERNAL_TOKEN_PRECISION)) / POOL_PRECISION();\n        } else {\n            vaultShares = (lpTokens * state.totalVaultSharesGlobal) / state.totalPoolClaim;\n        }\n\n        // Updates internal storage here\n        state.totalPoolClaim += lpTokens;\n        state.totalVaultSharesGlobal += vaultShares.toUint80();\n        state.setStrategyVaultState();\n\n        // Checks that the vault does not own too large of a portion of the pool. If this is the case,\n        // single sided exits may have a detrimental effect on the liquidity.\n        uint256 maxPoolShare = VaultStorage.getStrategyVaultSettings().maxPoolShare;\n        uint256 maxSupplyThreshold = (_totalPoolSupply() * maxPoolShare) / Constants.VAULT_PERCENT_BASIS;\n        if (maxSupplyThreshold < state.totalPoolClaim)\n            revert Errors.PoolShareTooHigh(state.totalPoolClaim, maxSupplyThreshold);\n    }\n\n    /// @notice This is a virtual function called by BaseStrategyVault which ensures that\n    /// this method is only called by Notional after an initial position has been made. Will\n    /// withdraw the LP tokens from the pool, either single sided or proportionally. On a\n    /// proportional exit, will trade all the tokens back to the primary in order to exit the pool.\n    /// @return finalPrimaryBalance which is the amount of funds that the vault will transfer back\n    /// to Notional and the account to repay debts and withdraw profits.\n    function _redeemFromNotional(\n        address /* account */, uint256 vaultShares, uint256 /* maturity */, bytes calldata data\n    ) internal override whenNotLocked returns (uint256 finalPrimaryBalance) {\n        // Short circuit any zero redemption amounts, this can occur during rolling positions\n        // or withdraw cash balances post liquidation.\n        if (vaultShares == 0) return 0;\n\n        // Updates internal account to deduct the vault shares.\n        uint256 poolClaim = _redeemVaultShares(vaultShares);\n        RedeemParams memory params = abi.decode(data, (RedeemParams));\n\n        bool isSingleSided = params.redemptionTrades.length == 0;\n        // Returns the amount of each token that has been withdrawn from the pool.\n        uint256[] memory exitBalances = _unstakeAndExitPool(poolClaim, params.minAmounts, isSingleSided);\n        if (!isSingleSided) {\n            // If not a single sided trade, will execute trades back to the primary token on\n            // external exchanges. This method will execute EXACT_IN trades to ensure that\n            // all of the balance in the other tokens is sold for primary.\n            (IERC20[] memory tokens, /* */) = TOKENS();\n            // Redemption trades are not automatically enabled on vaults since the trading module\n            // requires explicit permission for every token that can be sold by an address.\n            return StrategyUtils.executeRedemptionTrades(\n                tokens,\n                exitBalances,\n                params.redemptionTrades,\n                PRIMARY_INDEX()\n            );\n        } else {\n            // No explicit check is done here to ensure that the other balances are zero, assumed\n            // that the `_unstakeAndExitPool` method on the implementation is correct and will only\n            // ever withdraw to a single balance.\n            return exitBalances[PRIMARY_INDEX()];\n        }\n    }\n\n    /// @notice Updates internal account for vault share redemption.\n    function _redeemVaultShares(uint256 vaultShares) internal returns (uint256 poolClaim) {\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n        // Will revert on divide by zero, which is the correct behavior\n        poolClaim = (vaultShares * state.totalPoolClaim) / state.totalVaultSharesGlobal;\n\n        state.totalPoolClaim -= poolClaim;\n        // Will revert on underflow if vault shares is greater than total shares global\n        state.totalVaultSharesGlobal -= vaultShares.toUint80();\n        state.setStrategyVaultState();\n    }\n\n    /// @notice Converts the vault shares to an oracle value in underlying tokens. Used by Notional\n    /// to determine the collateral position of a vault user. If the vault is locked due to an\n    /// emergency exit, this function will revert which will prevent users from entering, exiting,\n    /// and being liquidated. During emergency exit, the vault will not be holding any LP tokens and\n    /// therefore this calculation will not be correct.\n    function convertStrategyToUnderlying(\n        address /* */, uint256 vaultShares, uint256 /* */\n    ) public view override whenNotLocked returns (int256 underlyingValue) {\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n        // Will revert on divide by zero, which is the correct behavior\n        uint256 lpTokens = (vaultShares * state.totalPoolClaim) / state.totalVaultSharesGlobal;\n        uint256 oneLPValueInPrimary = _checkPriceAndCalculateValue();\n\n        return (oneLPValueInPrimary * lpTokens / POOL_PRECISION()).toInt();\n    }\n\n    /// @notice Returns the pair price of two tokens via the TRADING_MODULE which holds a registry\n    /// of oracles. Will revert of the oracle pair is not listed.\n    function _getOraclePairPrice(address base, address quote) internal view returns (uint256) {\n        (int256 rate, int256 precision) = TRADING_MODULE.getOraclePrice(base, quote);\n        require(rate > 0);\n        require(precision > 0);\n        return uint256(rate) * POOL_PRECISION() / uint256(precision);\n    }\n\n    /// @notice Helper method called by _checkPriceAndCalculateValue which will supply the relevant\n    /// pool balances and spot prices. Calculates the claim of one LP token on relevant pool balances\n    /// and compares the oracle price to the spot price, reverting if the deviation is too high.\n    /// @return oneLPValueInPrimary the value of one LP token in terms of the primary borrowed currency\n    function _calculateLPTokenValue(\n        uint256[] memory balances,\n        uint256[] memory spotPrices\n    ) internal view returns (uint256 oneLPValueInPrimary) {\n        (IERC20[] memory tokens, uint8[] memory decimals) = TOKENS();\n        address primaryToken = address(tokens[PRIMARY_INDEX()]);\n        uint256 primaryDecimals = 10 ** decimals[PRIMARY_INDEX()];\n        uint256 totalSupply = _totalPoolSupply();\n        uint256 limit = VaultStorage.getStrategyVaultSettings().oraclePriceDeviationLimitPercent;\n\n        for (uint256 i; i < tokens.length; i++) {\n            // Skip the pool token if it is in the token list (i.e. ComposablePools)\n            if (address(tokens[i]) == address(POOL_TOKEN())) continue;\n            // This is the claim on the pool balance of 1 LP token.\n            uint256 tokenClaim = balances[i] * POOL_PRECISION() / totalSupply;\n            if (i == PRIMARY_INDEX()) {\n                oneLPValueInPrimary += tokenClaim;\n            } else {\n                uint256 price = _getOraclePairPrice(primaryToken, address(tokens[i]));\n\n                // Check that the spot price and the oracle price are near each other. If this is\n                // not true then we assume that the LP pool is being manipulated.\n                uint256 lowerLimit = price * (Constants.VAULT_PERCENT_BASIS - limit) / Constants.VAULT_PERCENT_BASIS;\n                uint256 upperLimit = price * (Constants.VAULT_PERCENT_BASIS + limit) / Constants.VAULT_PERCENT_BASIS;\n                if (spotPrices[i] < lowerLimit || upperLimit < spotPrices[i]) {\n                    revert Errors.InvalidPrice(price, spotPrices[i]);\n                }\n\n                // Convert the token claim to primary using the oracle pair price.\n                uint256 secondaryDecimals = 10 ** decimals[i];\n                oneLPValueInPrimary += (tokenClaim * POOL_PRECISION() * primaryDecimals) / \n                    (price * secondaryDecimals);\n            }\n        }\n    }\n\n    /************************************************************************\n     * REWARD REINVESTMENT                                                  *\n     * Methods used by bots to claim reward tokens and reinvest them as LP  *\n     * tokens which are donated to all vault users.                         *\n     ************************************************************************/\n\n    /// @notice Ensures that only whitelisted bots can claim reward tokens.\n    function claimRewardTokens() external override onlyRole(REWARD_REINVESTMENT_ROLE) {\n        _claimRewardTokens();\n    }\n\n    /// @notice Ensures that only whitelisted bots can reinvest rewards. Since rewards\n    /// are typically less liquid than pool tokens and lack oracles, reward reinvestment\n    /// is done using explicitly set slippage limits by the reinvestment bots. Reinvestment\n    /// will fail if the spot prices are not close to the oracle prices to ensure that\n    /// there is no front running the reinvestment.\n    function reinvestReward(\n        SingleSidedRewardTradeParams[] calldata trades,\n        uint256 minPoolClaim\n    ) external whenNotLocked onlyRole(REWARD_REINVESTMENT_ROLE) returns (\n        address rewardToken,\n        uint256 amountSold,\n        uint256 poolClaimAmount\n    ) {\n        // Will revert if spot prices are not in line with the oracle values\n        _checkPriceAndCalculateValue();\n\n        // Require one trade per token, if we do not want to buy any tokens at a\n        // given index then the amount should be set to zero. This applies to pool\n        // tokens like in the ComposableStablePool.\n        require(trades.length == NUM_TOKENS());\n        uint256[] memory amounts;\n        (rewardToken, amountSold, amounts) = _executeRewardTrades(trades);\n\n        poolClaimAmount = _joinPoolAndStake(amounts, minPoolClaim);\n\n        // Increase LP token amount without minting additional vault shares\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n        state.totalPoolClaim += poolClaimAmount;\n        state.setStrategyVaultState();\n\n        emit RewardReinvested(rewardToken, amountSold, poolClaimAmount);\n    }\n\n    function _executeRewardTrades(SingleSidedRewardTradeParams[] calldata trades) internal returns (\n        address rewardToken,\n        uint256 amountSold,\n        uint256[] memory amounts\n    ) {\n        // The sell token on all trades must be the same (checked inside executeRewardTrades) so\n        // just validate here that the sellToken is a valid reward token (i.e. none of the tokens\n        // used in the regular functioning of the vault).\n        rewardToken = trades[0].sellToken;\n        if (_isInvalidRewardToken(rewardToken)) revert Errors.InvalidRewardToken(rewardToken);\n        (IERC20[] memory tokens, /* */) = TOKENS();\n        (amounts, amountSold) = StrategyUtils.executeRewardTrades(\n            tokens, trades, rewardToken, address(POOL_TOKEN())\n        );\n    }\n\n    /************************************************************************\n     * EMERGENCY EXIT                                                       *\n     * In case of an emergency, will allow a whitelisted guardian to exit   *\n     * funds on the vault and locks the vault from further usage. The owner *\n     * can restore funds to the LP pool and reinstante vault usage. If the  *\n     * vault cannot be fully restored after an exit, the vault will need to *\n     * be upgraded and unwound manually to ensure that debts are repaid and *\n     * users can withdraw their funds.                                      *\n     ************************************************************************/\n\n    /// @notice Allows the function to execute only when the vault is not locked\n    modifier whenNotLocked() {\n        if (isLocked()) revert Errors.VaultLocked();\n        _;\n    }\n\n    /// @notice Allows the function to execute only when the vault is locked\n    modifier whenLocked() {\n        if (!isLocked()) revert Errors.VaultNotLocked();\n        _;\n    }\n\n    /// @notice Checks if a flag bit is set\n    function _hasFlag(uint32 flags, uint32 flagID) private pure returns (bool) {\n        return (flags & flagID) == flagID;\n    }\n\n    /// @notice Locks the vault, preventing deposits and redemptions. Used during\n    /// emergency exit\n    function _lockVault() internal {\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n        // Set locked flag\n        state.flags = state.flags | FLAG_LOCKED;\n        VaultStorage.setStrategyVaultState(state);\n        emit VaultLocked();\n    }\n\n    /// @notice Unlocks the vault, called during restore vault.\n    function _unlockVault() internal {\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n        // Remove locked flag\n        state.flags = state.flags & ~FLAG_LOCKED;\n        VaultStorage.setStrategyVaultState(state);\n        emit VaultUnlocked();\n    }\n\n    /// @notice Allows the emergency exit role to trigger an emergency exit on the vault.\n    /// In this situation, the `claimToExit` is withdrawn proportionally to the underlying\n    /// tokens and held on the vault. The vault is locked so that no entries, exits or\n    /// valuations of vaultShares can be performed.\n    /// @param claimToExit if this is set to zero, the entire pool claim is withdrawn\n    function emergencyExit(\n        uint256 claimToExit, bytes calldata /* data */\n    ) external override onlyRole(EMERGENCY_EXIT_ROLE) {\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n        if (claimToExit == 0) claimToExit = state.totalPoolClaim;\n\n        // By setting min amounts to zero, we will accept whatever tokens come from the pool\n        // in a proportional exit. Front running will not have an effect since no trading will\n        // occur during a proportional exit.\n        _unstakeAndExitPool(claimToExit, new uint256[](NUM_TOKENS()), true);\n\n        state.totalPoolClaim = state.totalPoolClaim - claimToExit;\n        state.setStrategyVaultState();\n\n        emit EmergencyExit(claimToExit);\n        _lockVault();\n    }\n\n    /// @notice Restores withdrawn tokens from emergencyExit back into the vault proportionally.\n    /// Unlocks the vault after restoration so that normal functionality is restored.\n    /// @param minPoolClaim slippage limit to prevent front running\n    function restoreVault(\n        uint256 minPoolClaim, bytes calldata /* data */\n    ) external override whenLocked onlyNotionalOwner {\n        StrategyVaultState memory state = VaultStorage.getStrategyVaultState();\n\n        (IERC20[] memory tokens, /* */) = TOKENS();\n        uint256[] memory amounts = new uint256[](tokens.length);\n\n        // All balances held by the vault are assumed to be used to re-enter\n        // the pool. Since the vault has been locked no other users should have\n        // been able to enter the pool.\n        for (uint256 i; i < tokens.length; i++) {\n            if (address(tokens[i]) == address(POOL_TOKEN())) continue;\n            amounts[i] = TokenUtils.tokenBalance(address(tokens[i]));\n        }\n\n        // No trades are specified so this joins proportionally using the\n        // amounts specified.\n        uint256 poolTokens = _joinPoolAndStake(amounts, minPoolClaim);\n\n        state.totalPoolClaim = state.totalPoolClaim + poolTokens;\n        state.setStrategyVaultState();\n\n        _unlockVault();\n    }\n\n    // Storage gap for future potential upgrades\n    uint256[100] private __gap;\n}"
    },
    {
      "filename": "leveraged-vaults/contracts/vaults/CrossCurrencyVault.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport {NotionalProxy} from \"../../interfaces/notional/NotionalProxy.sol\";\nimport {IWrappedfCashFactory} from \"../../interfaces/notional/IWrappedfCashFactory.sol\";\nimport {IWrappedfCashComplete as IWrappedfCash} from \"../../interfaces/notional/IWrappedfCash.sol\";\nimport {WETH9} from \"../../interfaces/WETH9.sol\";\n\nimport {BaseStrategyVault} from \"./common/BaseStrategyVault.sol\";\nimport {IERC20, TokenUtils} from \"../utils/TokenUtils.sol\";\nimport {TypeConvert} from \"../global/TypeConvert.sol\";\nimport {Token, TokenType} from \"../global/Types.sol\";\nimport {Constants} from \"../global/Constants.sol\";\nimport {ITradingModule, DexId, TradeType, Trade} from \"../../interfaces/trading/ITradingModule.sol\";\n\n/**\n * @notice This vault borrows in one currency, trades it to a different currency\n * and lends on Notional in that currency.\n */\ncontract CrossCurrencyVault is BaseStrategyVault {\n    using TypeConvert for uint256;\n\n    struct DepositParams {\n        // Minimum purchase amount of the lend underlying token, this is\n        // based on the deposit + borrowed amount and must be set to a non-zero\n        // value to establish a slippage limit.\n        uint256 minPurchaseAmount;\n        // Minimum final vault shares to receive\n        uint256 minVaultShares;\n        // ID of the desired DEX to trade on, _depositFromNotional will always trade\n        // using an EXACT_IN_SINGLE trade which is supported by all DEXes\n        uint16 dexId;\n        // Exchange data depending on the selected dexId\n        bytes exchangeData;\n    }\n\n    struct RedeemParams {\n        // Minimum purchase amount of the borrow underlying token, this is\n        // based on the amount of lend underlying received and must be set to a non-zero\n        // value to establish a slippage limit.\n        uint256 minPurchaseAmount;\n        // ID of the desired DEX to trade on, _depositFromNotional will always trade\n        // using an EXACT_IN_SINGLE trade which is supported by all DEXes\n        uint16 dexId;\n        // Exchange data depending on the selected dexId\n        bytes exchangeData;\n    }\n\n    IWrappedfCashFactory immutable WRAPPED_FCASH_FACTORY;\n    WETH9 immutable WETH;\n\n    uint16 public LEND_CURRENCY_ID;\n    IERC20 public LEND_UNDERLYING_TOKEN;\n    uint8 public LEND_DECIMALS;\n    uint8 public BORROW_DECIMALS;\n    bool public LEND_ETH;\n    // NOTE: 1 byte left in first storage slot here\n\n    constructor(\n        NotionalProxy notional_,\n        ITradingModule tradingModule_,\n        IWrappedfCashFactory factory,\n        WETH9 weth\n    ) BaseStrategyVault(notional_, tradingModule_) {\n        WRAPPED_FCASH_FACTORY = factory;\n        WETH = weth;\n    }\n\n    function strategy() external override pure returns (bytes4) {\n        return bytes4(keccak256(\"CrossCurrencyVault\"));\n    }\n\n    function initialize(\n        string memory name_,\n        uint16 borrowCurrencyId_,\n        uint16 lendCurrencyId_\n    ) external initializer {\n        __INIT_VAULT(name_, borrowCurrencyId_);\n\n        LEND_CURRENCY_ID = lendCurrencyId_;\n        (/* */, Token memory underlyingToken) = NOTIONAL.getCurrency(lendCurrencyId_);\n\n        LEND_ETH = underlyingToken.tokenType == TokenType.Ether;\n        IERC20 tokenAddress = IERC20(underlyingToken.tokenAddress);\n        LEND_UNDERLYING_TOKEN = tokenAddress;\n        LEND_DECIMALS = TokenUtils.getDecimals(address(tokenAddress));\n        BORROW_DECIMALS = TokenUtils.getDecimals(address(_underlyingToken()));\n    }\n\n    /// @notice Returns the wrapped fCash address which is created using CREATE2. It may be the case that\n    /// the wrapped fCash contract for a given maturity has not yet been deployed which would cause the\n    /// initial deposit for a maturity to revert in this contract. However, deployment of wrapped fCash\n    /// contracts is permissionless so likely some bot will be used to ensure the wrappers are deployed\n    /// before they are used.\n    function getWrappedFCashAddress(uint256 maturity) public view returns (IWrappedfCash) {\n        require(maturity < Constants.PRIME_CASH_VAULT_MATURITY);\n        return IWrappedfCash(WRAPPED_FCASH_FACTORY.computeAddress(LEND_CURRENCY_ID, uint40(maturity)));\n    }\n\n    /**\n     * @notice Converts the amount of fCash the vault holds into underlying denomination for the\n     * borrow currency.\n     * @param vaultShares each strategy token is equivalent to 1 unit of fCash or 1 unit of PrimeCash\n     * @param maturity the maturity of the fCash\n     * @return underlyingValue the value of the lent fCash in terms of the borrowed currency\n     */\n    function convertStrategyToUnderlying(\n        address /* account */,\n        uint256 vaultShares,\n        uint256 maturity\n    ) public override view returns (int256 underlyingValue) {\n        int256 pvExternalUnderlying;\n        if (maturity == Constants.PRIME_CASH_VAULT_MATURITY) {\n            // F"
    }
  ]
}