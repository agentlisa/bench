{
  "Title": "[G-02] Massive 15k per tx gas savings - use 1 and 2 for Reentrancy guard",
  "Content": "Using true and false will trigger gas-refunds, which after London, are 1/5 of what they used to be. Meaning, using 1 and 2 (keeping the slot non-zero) will cost 5k per change (5k + 5k vs 20k + 5k), saving you 15k gas per function which uses the modifier.\n\n<details>\n\n```solidity\nFile:   src/erc-20/ERC20Gauges.sol\n188   function incrementGauge(address gauge, uint112 weight) external nonReentrant returns (uint112 newUserWeight) {\n\n245   function incrementGauges(address[] calldata gaugeList, uint112[] calldata weights)\n        external\n        nonReentrant\n        returns (uint256 newUserWeight)\n    {\n\n273    function decrementGauge(address gauge, uint112 weight) external nonReentrant returns (uint112 newUserWeight) {\n\n322   function decrementGauges(address[] calldata gaugeList, uint112[] calldata weights)\n        external\n        nonReentrant\n        returns (uint112 newUserWeight)\n    {\n\n519   function _decrementWeightUntilFree(address user, uint256 weight) internal nonReentrant {                \n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/erc-20/ERC20Gauges.sol#L188\n\n```solidity\nFile:   src/erc-4626/ERC4626MultiToken.sol\n93    function deposit(uint256[] calldata assetsAmounts, address receiver)\n        public\n        virtual\n        nonReentrant\n        returns (uint256 shares)\n    {\n\n113   function mint(uint256 shares, address receiver)\n        public\n        virtual\n        nonReentrant\n        returns (uint256[] memory assetsAmounts)\n    {\n\n132    function withdraw(uint256[] calldata assetsAmounts, address receiver, address owner)\n        public\n        virtual\n        nonReentrant\n        returns (uint256 shares)\n    {\n\n156   function redeem(uint256 shares, address receiver, address owner)\n        public\n        virtual\n        nonReentrant\n        returns (uint256[] memory assetsAmounts)\n    {\n\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/erc-4626/ERC4626MultiToken.sol#L93\n\n```solidity\nFile:  src/erc-4626/UlyssesERC4626.sol\n34   function deposit(uint256 assets, address receiver) public virtual nonReentrant returns (uint256 shares) {\n\n47   function mint(uint256 shares, address receiver) public virtual nonReentrant returns (uint256 assets) {\n\n59    function redeem(uint256 shares, address receiver, address owner)\n        public\n        virtual\n        nonReentrant\n        returns (uint256 assets)\n    {\n\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/erc-4626/UlyssesERC4626.sol#L34\n\n```solidity\nFile:   src/talos/base/TalosBaseStrategy.sol\n102   function init(uint256 amount0Desired, uint256 amount1Desired, address receiver)\n        external\n        virtual\n        nonReentrant\n        returns (uint256 shares, uint256 amount0, uint256 amount1)\n    {\n\n182  function deposit(uint256 amount0Desired, uint256 amount1Desired, address receiver)\n        public\n        virtual\n        override\n        nonReentrant\n        checkDeviation\n        returns (uint256 shares, uint256 amount0, uint256 amount1)\n    {\n\n238   function redeem(uint256 shares, uint256 amount0Min, uint256 amount1Min, address receiver, address _owner)\n        public\n        virtual\n        override\n        nonReentrant\n        checkDeviation\n        returns (uint256 amount0, uint256 amount1)\n    {\n\n298   function rerange() external virtual override nonReentrant checkDeviation onlyStrategyManager {\n\n311  function rebalance() external virtual override nonReentrant checkDeviation onlyStrategyManager {\n\n394   function collectProtocolFees(uint256 amount0, uint256 amount1) external nonReentrant onlyOwner {        \n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/talos/base/TalosBaseStrategy.sol#L102\n\n```solidity\nFile:   src/ulysses-amm/UlyssesPool.sol\n150    function claimProtocolFees() external nonReentrant returns (uint256 claimed) {\n\n159    function addNewBandwidth(uint256 poolId, uint8 weight) external nonReentrant onlyOwner returns (uint256 index) {\n\n223     function setWeight(uint256 poolId, uint8 weight) external nonReentrant onlyOwner {\n\n308     function setFees(Fees calldata _fees) external nonReentrant onlyOwner {\n\n323     function setProtocolFee(uint256 _protocolFee) external nonReentrant {\n\n1093    function swapIn(uint256 assets, uint256 poolId) external nonReentrant returns (uint256 output) {\n\n1147     function swapFromPool(uint256 assets, address user) external nonReentrant returns (uint256 output) {        \n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-amm/UlyssesPool.sol#L150\n\n```solidity\nFile:  src/ulysses-amm/UlyssesToken.sol\n44   function addAsset(address asset, uint256 _weight) external nonReentrant onlyOwner {\n\n60   function removeAsset(address asset) external nonReentrant onlyOwner {\n\n88    function setWeights(uint256[] memory _weights) external nonReentrant onlyOwner {        \n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-amm/UlyssesToken.sol#L44\n\n</details>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/erc-20/ERC20Gauges.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Gauge weight logic inspired by Tribe DAO Contracts (flywheel-v2/src/token/ERC20Gauges.sol)\npragma solidity ^0.8.0;\n\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\n\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\n\nimport {EnumerableSet} from \"@lib/EnumerableSet.sol\";\n\nimport {IBaseV2Gauge} from \"@gauges/interfaces/IBaseV2Gauge.sol\";\n\nimport {ERC20MultiVotes} from \"./ERC20MultiVotes.sol\";\n\nimport {Errors} from \"./interfaces/Errors.sol\";\nimport {IERC20Gauges} from \"./interfaces/IERC20Gauges.sol\";\n\n/// @title  An ERC20 with an embedded \"Gauge\" style vote with liquid weights\nabstract contract ERC20Gauges is ERC20MultiVotes, ReentrancyGuard, IERC20Gauges {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using SafeCastLib for *;\n\n    /**\n     * @notice Construct a new ERC20Gauges\n     * @param _gaugeCycleLength the length of a gauge cycle in seconds\n     * @param _incrementFreezeWindow the length of the grace period in seconds\n     */\n    constructor(uint32 _gaugeCycleLength, uint32 _incrementFreezeWindow) {\n        if (_incrementFreezeWindow >= _gaugeCycleLength) revert IncrementFreezeError();\n        gaugeCycleLength = _gaugeCycleLength;\n        incrementFreezeWindow = _incrementFreezeWindow;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            GAUGE STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Gauges\n    uint32 public immutable override gaugeCycleLength;\n\n    /// @inheritdoc IERC20Gauges\n    uint32 public immutable override incrementFreezeWindow;\n\n    /// @inheritdoc IERC20Gauges\n    mapping(address => mapping(address => uint112)) public override getUserGaugeWeight;\n\n    /// @inheritdoc IERC20Gauges\n    /// @dev NOTE this may contain weights for deprecated gauges\n    mapping(address => uint112) public override getUserWeight;\n\n    /// @notice a mapping from a gauge to the total weight allocated to it\n    /// @dev NOTE this may contain weights for deprecated gauges\n    mapping(address => Weight) internal _getGaugeWeight;\n\n    /// @notice the total global allocated weight ONLY of live gauges\n    Weight internal _totalWeight;\n\n    mapping(address => EnumerableSet.AddressSet) internal _userGauges;\n\n    EnumerableSet.AddressSet internal _gauges;\n\n    // Store deprecated gauges in case a user needs to free dead weight\n    EnumerableSet.AddressSet internal _deprecatedGauges;\n\n    /*///////////////////////////////////////////////////////////////\n                              VIEW HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Gauges\n    function getGaugeCycleEnd() external view returns (uint32) {\n        return _getGaugeCycleEnd();\n    }\n\n    function _getGaugeCycleEnd() internal view returns (uint32) {\n        uint32 nowPlusOneCycle = block.timestamp.toUint32() + gaugeCycleLength;\n        unchecked {\n            return (nowPlusOneCycle / gaugeCycleLength) * gaugeCycleLength; // cannot divide by zero and always <= nowPlusOneCycle so no overflow\n        }\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function getGaugeWeight(address gauge) external view returns (uint112) {\n        return _getGaugeWeight[gauge].currentWeight;\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function getStoredGaugeWeight(address gauge) external view returns (uint112) {\n        if (_deprecatedGauges.contains(gauge)) return 0;\n        return _getStoredWeight(_getGaugeWeight[gauge], _getGaugeCycleEnd());\n    }\n\n    function _getStoredWeight(Weight storage gaugeWeight, uint32 currentCycle) internal view returns (uint112) {\n        return gaugeWeight.currentCycle < currentCycle ? gaugeWeight.currentWeight : gaugeWeight.storedWeight;\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function totalWeight() external view returns (uint112) {\n        return _totalWeight.currentWeight;\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function storedTotalWeight() external view returns (uint112) {\n        return _getStoredWeight(_totalWeight, _getGaugeCycleEnd());\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function gauges() external view returns (address[] memory) {\n        return _gauges.values();\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function gauges(uint256 offset, uint256 num) external view returns (address[] memory values) {\n        values = new address[](num);\n        for (uint256 i = 0; i < num;) {\n            unchecked {\n                values[i] = _gauges.at(offset + i); // will revert if out of bounds\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function isGauge(address gauge) external view returns (bool) {\n        return _gauges.contains(gauge) && !_deprecatedGauges.contains(gauge);\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function numGauges() external view returns (uint256) {\n        return _gauges.length();\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function deprecatedGauges() external view returns (address[] memory) {\n        return _deprecatedGauges.values();\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function numDeprecatedGauges() external view returns (uint256) {\n        return _deprecatedGauges.length();\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function userGauges(address user) external view returns (address[] memory) {\n        return _userGauges[user].values();\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function isUserGauge(address user, address gauge) external view returns (bool) {\n        return _userGauges[user].contains(gauge);\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function userGauges(address user, uint256 offset, uint256 num) external view returns (address[] memory values) {\n        values = new address[](num);\n        for (uint256 i = 0; i < num;) {\n            unchecked {\n                values[i] = _userGauges[user].at(offset + i); // will revert if out of bounds\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function numUserGauges(address user) external view returns (uint256) {\n        return _userGauges[user].length();\n    }\n\n    /// @inheritdoc ERC20MultiVotes\n    function userUnusedVotes(address user) public view override returns (uint256) {\n        return super.userUnusedVotes(user) - getUserWeight[user];\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function calculateGaugeAllocation(address gauge, uint256 quantity) external view returns (uint256) {\n        if (_deprecatedGauges.contains(gauge)) return 0;\n        uint32 currentCycle = _getGaugeCycleEnd();\n\n        uint112 total = _getStoredWeight(_totalWeight, currentCycle);\n        uint112 weight = _getStoredWeight(_getGaugeWeight[gauge], currentCycle);\n        return (quantity * weight) / total;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        USER GAUGE OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Gauges\n    function incrementGauge(address gauge, uint112 weight) external nonReentrant returns (uint112 newUserWeight) {\n        uint32 currentCycle = _getGaugeCycleEnd();\n        _incrementGaugeWeight(msg.sender, gauge, weight, currentCycle);\n        return _incrementUserAndGlobalWeights(msg.sender, weight, currentCycle);\n    }\n\n    /**\n     * @notice Increment the weight of a gauge for a user\n     * @dev This function calls accrueBribes for the gauge to ensure the gauge handles the balance change.\n     * @param user the user to increment the weight of\n     * @param gauge the gauge to increment the weight of\n     * @param weight the weight to increment by\n     * @param cycle the cycle to increment the weight for\n     */\n    function _incrementGaugeWeight(address user, address gauge, uint112 weight, uint32 cycle) internal {\n        if (!_gauges.contains(gauge) || _deprecatedGauges.contains(gauge)) revert InvalidGaugeError();\n        unchecked {\n            if (cycle - block.timestamp <= incrementFreezeWindow) revert IncrementFreezeError();\n        }\n\n        IBaseV2Gauge(gauge).accrueBribes(user);\n\n        bool added = _userGauges[user].add(gauge); // idempotent add\n        if (added && _userGauges[user].length() > maxGauges && !canContractExceedMaxGauges[user]) {\n            revert MaxGaugeError();\n        }\n\n        getUserGaugeWeight[user][gauge] += weight;\n\n        _writeGaugeWeight(_getGaugeWeight[gauge], _add112, weight, cycle);\n\n        emit IncrementGaugeWeight(user, gauge, weight, cycle);\n    }\n\n    /**\n     * @notice Increment the weight of a gauge for a user and the total weight\n     * @param user the user to increment the weight of\n     * @param weight the weight to increment by\n     * @param cycle the cycle to increment the weight for\n     * @return newUserWeight the new user's weight\n     */\n    function _incrementUserAndGlobalWeights(address user, uint112 weight, uint32 cycle)\n        internal\n        returns (uint112 newUserWeight)\n    {\n        newUserWeight = getUserWeight[user] + weight;\n\n        // new user weight must be less than or equal to the total user weight\n        if (newUserWeight > getVotes(user)) revert OverWeightError();\n\n        // Update gauge state\n        getUserWeight[user] = newUserWeight;\n\n        _writeGaugeWeight(_totalWeight, _add112, weight, cycle);\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function incrementGauges(address[] calldata gaugeList, uint112[] calldata weights)\n        external\n        nonReentrant\n        returns (uint256 newUserWeight)\n    {\n        uint256 size = gaugeList.length;\n        if (weights.length != size) revert SizeMismatchError();\n\n        // store total in summary for a batch update on user/global state\n        uint112 weightsSum;\n\n        uint32 currentCycle = _getGaugeCycleEnd();\n\n        // Update a gauge's specific state\n        for (uint256 i = 0; i < size;) {\n            address gauge = gaugeList[i];\n            uint112 weight = weights[i];\n            weightsSum += weight;\n\n            _incrementGaugeWeight(msg.sender, gauge, weight, currentCycle);\n            unchecked {\n                i++;\n            }\n        }\n        return _incrementUserAndGlobalWeights(msg.sender, weightsSum, currentCycle);\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function decrementGauge(address gauge, uint112 weight) external nonReentrant returns (uint112 newUserWeight) {\n        uint32 currentCycle = _getGaugeCycleEnd();\n\n        // All operations will revert on underflow, protecting against bad inputs\n        _decrementGaugeWeight(msg.sender, gauge, weight, currentCycle);\n        if (!_deprecatedGauges.contains(gauge)) {\n            _writeGaugeWeight(_totalWeight, _subtract112, weight, currentCycle);\n        }\n        return _decrementUserWeights(msg.sender, weight);\n    }\n\n    /**\n     * @notice Decrement the weight of a gauge for a user\n     * @dev This function calls accrueBribes for the gauge to ensure the gauge handles the balance change.\n     * @param user the user to decrement the weight of\n     * @param gauge the gauge to decrement the weight of\n     * @param weight the weight to decrement by\n     * @param cycle the cycle to decrement the weight for\n     */\n    function _decrementGaugeWeight(address user, address gauge, uint112 weight, uint32 cycle) internal {\n        if (!_gauges.contains(gauge)) revert InvalidGaugeError();\n\n        uint112 oldWeight = getUserGaugeWeight[user][gauge];\n\n        IBaseV2Gauge(gauge).accrueBribes(user);\n\n        getUserGaugeWeight[user][gauge] = oldWeight - weight;\n        if (oldWeight == weight) {\n            // If removing all weight, remove gauge from user list.\n            require(_userGauges[user].remove(gauge));\n        }\n\n        _writeGaugeWeight(_getGaugeWeight[gauge], _subtract112, weight, cycle);\n\n        emit DecrementGaugeWeight(user, gauge, weight, cycle);\n    }\n\n    /**\n     * @notice Decrement the weight of a gauge for a user and the total weight\n     * @param user the user to decrement the weight of\n     * @param weight the weight to decrement by\n     * @return newUserWeight the new user's weight\n     */\n    function _decrementUserWeights(address user, uint112 weight) internal returns (uint112 newUserWeight) {\n        newUserWeight = getUserWeight[user] - weight;\n        getUserWeight[user] = newUserWeight;\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function decrementGauges(address[] calldata gaugeList, uint112[] calldata weights)\n        external\n        nonReentrant\n        returns (uint112 newUserWeight)\n    {\n        uint256 size = gaugeList.length;\n        if (weights.length != size) revert SizeMismatchError();\n\n        // store total in summary for the batch update on user and global state\n        uint112 weightsSum;\n        uint112 globalWeightsSum;\n\n        uint32 currentCycle = _getGaugeCycleEnd();\n\n        // Update the gauge's specific state\n        // All operations will revert on underflow, protecting against bad inputs\n        for (uint256 i = 0; i < size;) {\n            address gauge = gaugeList[i];\n            uint112 weight = weights[i];\n            weightsSum += weight;\n            if (!_deprecatedGauges.contains(gauge)) globalWeightsSum += weight;\n\n            _decrementGaugeWeight(msg.sender, gauge, weight, currentCycle);\n            unchecked {\n                i++;\n            }\n        }\n        _writeGaugeWeight(_totalWeight, _subtract112, globalWeightsSum, currentCycle);\n\n        return _decrementUserWeights(msg.sender, weightsSum);\n    }\n\n    /**\n     * @dev this function is the key to the entire contract.\n     *  The storage weight it operates on is either a global or gauge-specific weight.\n     *  The operation applied is either addition for incrementing gauges or subtraction for decrementing a gauge.\n     * @param weight the weight to apply the operation to\n     * @param op the operation to apply\n     * @param delta the amount to apply the operation by\n     * @param cycle the cycle to apply the operation for\n     */\n    function _writeGaugeWeight(\n        Weight storage weight,\n        function(uint112, uint112) view returns (uint112) op,\n        uint112 delta,\n        uint32 cycle\n    ) private {\n        uint112 currentWeight = weight.currentWeight;\n        // If the last cycle of the weight is before the current cycle, use the current weight as the stored.\n        uint112 stored = weight.currentCycle < cycle ? currentWeight : weight.storedWeight;\n        uint112 newWeight = op(currentWeight, delta);\n\n        weight.storedWeight = stored;\n        weight.currentWeight = newWeight;\n        weight.currentCycle = cycle;\n    }\n\n    function _add112(uint112 a, uint112 b) private pure returns (uint112) {\n        return a + b;\n    }\n\n    function _subtract112(uint112 a, uint112 b) private pure returns (uint112) {\n        return a - b;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        ADMIN GAUGE OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC20Gauges\n    uint256 public override maxGauges;\n\n    /// @inheritdoc IERC20Gauges\n    mapping(address => bool) public override canContractExceedMaxGauges;\n\n    /// @inheritdoc IERC20Gauges\n    function addGauge(address gauge) external onlyOwner returns (uint112) {\n        return _addGauge(gauge);\n    }\n\n    /**\n     * @notice Add a gauge to the contract\n     * @param gauge the gauge to add\n     * @return weight the previous weight of the gauge, if it was already added\n     */\n    function _addGauge(address gauge) internal returns (uint112 weight) {\n        bool newAdd = _gauges.add(gauge);\n        bool previouslyDeprecated = _deprecatedGauges.remove(gauge);\n        // add and fail loud if zero address or already present and not deprecated\n        if (gauge == address(0) || !(newAdd || previouslyDeprecated)) revert InvalidGaugeError();\n\n        uint32 currentCycle = _getGaugeCycleEnd();\n\n        // Check if some previous weight exists and re-add to the total. Gauge and user weights are preserved.\n        weight = _getGaugeWeight[gauge].currentWeight;\n        if (weight > 0) {\n            _writeGaugeWeight(_totalWeight, _add112, weight, currentCycle);\n        }\n\n        emit AddGauge(gauge);\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function removeGauge(address gauge) external onlyOwner {\n        _removeGauge(gauge);\n    }\n\n    /**\n     * @notice Remove a gauge from the contract\n     * @param gauge the gauge to remove\n     */\n    function _removeGauge(address gauge) internal {\n        // add to deprecated and fail loud if not present\n        if (!_deprecatedGauges.add(gauge)) revert InvalidGaugeError();\n\n        uint32 currentCycle = _getGaugeCycleEnd();\n\n        // Remove weight from total but keep the gauge and user weights in storage in case the gauge is re-added.\n        uint112 weight = _getGaugeWeight[gauge].currentWeight;\n        if (weight > 0) {\n            _writeGaugeWeight(_totalWeight, _subtract112, weight, currentCycle);\n        }\n\n        emit RemoveGauge(gauge);\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function replaceGauge(address oldGauge, address newGauge) external onlyOwner {\n        _removeGauge(oldGauge);\n        _addGauge(newGauge);\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function setMaxGauges(uint256 newMax) external onlyOwner {\n        uint256 oldMax = maxGauges;\n        maxGauges = newMax;\n\n        emit MaxGaugesUpdate(oldMax, newMax);\n    }\n\n    /// @inheritdoc IERC20Gauges\n    function setContractExceedMaxGauges(address account, bool canExceedMax) external onlyOwner {\n        if (canExceedMax && account.code.length == 0) revert Errors.NonContractError(); // can only approve contracts\n\n        canContractExceedMaxGauges[account] = canExceedMax;\n\n        emit CanContractExceedMaxGaugesUpdate(account, canExceedMax);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// NOTE: any \"removal\" of tokens from a user requires userUnusedVotes < amount.\n    /// _decrementWeightUntilFree is called as a greedy algorithm to free up weight.\n    /// It may be more gas efficient to free weight before burning or transferring tokens.\n\n    /**\n     * @notice Burns `amount` of tokens from `from` address.\n     * @dev Frees weights and votes with a greedy algorithm if needed to burn tokens\n     * @param from The address to burn tokens from.\n     * @param amount The amount of tokens to burn.\n     */\n    function _burn(address from, uint256 amount) internal virtual override {\n        _decrementWeightUntilFree(from, amount);\n        super._burn(from, amount);\n    }\n\n    /**\n     * @notice Transfers `amount` of tokens from `msg.sender` to `to` address.\n     * @dev Frees weights and votes with a greedy algorithm if needed to burn tokens\n     * @param to the address to transfer to.\n     * @param amount the amount to transfer.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        _decrementWeightUntilFree(msg.sender, amount);\n        return super.transfer(to, amount);\n    }\n\n    /**\n     * @notice Transfers `amount` of tokens from `from` address to `to` address.\n     * @dev Frees weights and votes with a greedy algorithm if needed to burn tokens\n     * @param from the address to transfer from.\n     * @param to the address to transfer to.\n     * @param amount the amount to transfer.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        _decrementWeightUntilFree(from, amount);\n        return super.transferFrom(from, to, amount);\n    }\n\n    /**\n     * @notice A greedy algorithm for freeing weight before a token burn/transfer\n     * @dev Frees up entire gauges, so likely will free more than `weight`\n     * @param user the user to free weight for\n     * @param weight the weight to free\n     */\n    function _decrementWeightUntilFree(address user, uint256 weight) internal nonReentrant {\n        uint256 userFreeWeight = freeVotes(user) + userUnusedVotes(user);\n\n        // early return if already free\n        if (userFreeWeight >= weight) return;\n\n        uint32 currentCycle = _getGaugeCycleEnd();\n\n        // cache totals for batch updates\n        uint112 userFreed;\n        uint112 totalFreed;\n\n        // Loop through all user gauges, live and deprecated\n        address[] memory gaugeList = _userGauges[user].values();\n\n        // Free gauges through the entire list or until underweight\n        uint256 size = gaugeList.length;\n        for (uint256 i = 0; i < size && (userFreeWeight + totalFreed) < weight;) {\n            address gauge = gaugeList[i];\n            uint112 userGaugeWeight = getUserGaugeWeight[user][gauge];\n            if (userGaugeWeight != 0) {\n                // If the gauge is live (not deprecated), include its weight in the total to remove\n                if (!_deprecatedGauges.contains(gauge)) {\n                    totalFreed += userGaugeWeight;\n                }\n                userFreed += userGaugeWeight;\n                _decrementGaugeWeight(user, gauge, userGaugeWeight, currentCycle);\n\n                unchecked {\n                    i++;\n                }\n            }\n        }\n\n        getUserWeight[user] -= userFreed;\n        _writeGaugeWeight(_totalWeight, _subtract112, totalFreed, currentCycle);\n    }\n}"
    },
    {
      "filename": "src/erc-4626/ERC4626MultiToken.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\n\nimport {IERC4626MultiToken} from \"./interfaces/IERC4626MultiToken.sol\";\n\n/// @title Minimal ERC4626 tokenized Vault multi asset implementation\n/// @author Maia DAO (https://github.com/Maia-DAO)\nabstract contract ERC4626MultiToken is ERC20, ReentrancyGuard, IERC4626MultiToken {\n    using SafeTransferLib for address;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626MultiToken\n    address[] public assets;\n\n    /// @inheritdoc IERC4626MultiToken\n    uint256[] public weights;\n\n    /// @inheritdoc IERC4626MultiToken\n    mapping(address => uint256) public assetId;\n\n    /// @inheritdoc IERC4626MultiToken\n    uint256 public totalWeights;\n\n    /// @inheritdoc IERC4626MultiToken\n    function getAssets() external view returns (address[] memory) {\n        return assets;\n    }\n\n    constructor(address[] memory _assets, uint256[] memory _weights, string memory _name, string memory _symbol)\n        ERC20(_name, _symbol, 18)\n    {\n        assets = _assets;\n        weights = _weights;\n\n        uint256 length = _weights.length;\n        uint256 _totalWeights;\n\n        if (length != _assets.length || length == 0) revert InvalidLength();\n\n        for (uint256 i = 0; i < length;) {\n            require(ERC20(_assets[i]).decimals() == 18);\n            require(_weights[i] > 0);\n\n            _totalWeights += _weights[i];\n            assetId[_assets[i]] = i + 1;\n\n            emit AssetAdded(_assets[i], _weights[i]);\n\n            unchecked {\n                i++;\n            }\n        }\n        totalWeights = _totalWeights;\n    }\n\n    function receiveAssets(uint256[] memory assetsAmounts) private {\n        uint256 length = assetsAmounts.length;\n        for (uint256 i = 0; i < length;) {\n            assets[i].safeTransferFrom(msg.sender, address(this), assetsAmounts[i]);\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    function sendAssets(uint256[] memory assetsAmounts, address receiver) private {\n        uint256 length = assetsAmounts.length;\n        for (uint256 i = 0; i < length;) {\n            assets[i].safeTransfer(receiver, assetsAmounts[i]);\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626MultiToken\n    function deposit(uint256[] calldata assetsAmounts, address receiver)\n        public\n        virtual\n        nonReentrant\n        returns (uint256 shares)\n    {\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(assetsAmounts)) != 0, \"ZERO_SHARES\");\n\n        // Need to transfer before minting or ERC777s could reenter.\n        receiveAssets(assetsAmounts);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assetsAmounts, shares);\n\n        afterDeposit(assetsAmounts, shares);\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function mint(uint256 shares, address receiver)\n        public\n        virtual\n        nonReentrant\n        returns (uint256[] memory assetsAmounts)\n    {\n        assetsAmounts = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        receiveAssets(assetsAmounts);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assetsAmounts, shares);\n\n        afterDeposit(assetsAmounts, shares);\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function withdraw(uint256[] calldata assetsAmounts, address receiver, address owner)\n        public\n        virtual\n        nonReentrant\n        returns (uint256 shares)\n    {\n        shares = previewWithdraw(assetsAmounts); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        beforeWithdraw(assetsAmounts, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assetsAmounts, shares);\n\n        sendAssets(assetsAmounts, receiver);\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function redeem(uint256 shares, address receiver, address owner)\n        public\n        virtual\n        nonReentrant\n        returns (uint256[] memory assetsAmounts)\n    {\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        assetsAmounts = previewRedeem(shares);\n        uint256 length = assetsAmounts.length;\n        for (uint256 i = 0; i < length;) {\n            // Check for rounding error since we round down in previewRedeem.\n            if (assetsAmounts[i] == 0) revert ZeroAssets();\n            unchecked {\n                i++;\n            }\n        }\n\n        beforeWithdraw(assetsAmounts, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assetsAmounts, shares);\n\n        sendAssets(assetsAmounts, receiver);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function totalAssets() public view virtual returns (uint256);\n\n    /// @inheritdoc IERC4626MultiToken\n    function convertToShares(uint256[] calldata assetsAmounts) public view virtual returns (uint256 shares) {\n        uint256 _totalWeights = totalWeights;\n        uint256 length = assetsAmounts.length;\n\n        if (length != assets.length) revert InvalidLength();\n\n        shares = type(uint256).max;\n        for (uint256 i = 0; i < length;) {\n            uint256 share = assetsAmounts[i].mulDiv(_totalWeights, weights[i]);\n            if (share < shares) shares = share;\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function convertToAssets(uint256 shares) public view virtual returns (uint256[] memory assetsAmounts) {\n        uint256 _totalWeights = totalWeights;\n        uint256 length = assets.length;\n\n        assetsAmounts = new uint256[](length);\n        for (uint256 i = 0; i < length;) {\n            assetsAmounts[i] = shares.mulDiv(weights[i], _totalWeights);\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function previewDeposit(uint256[] calldata assetsAmounts) public view virtual returns (uint256) {\n        return convertToShares(assetsAmounts);\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function previewMint(uint256 shares) public view virtual returns (uint256[] memory assetsAmounts) {\n        uint256 _totalWeights = totalWeights;\n        uint256 length = assets.length;\n\n        assetsAmounts = new uint256[](length);\n        for (uint256 i = 0; i < length;) {\n            assetsAmounts[i] = shares.mulDivUp(weights[i], _totalWeights);\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function previewWithdraw(uint256[] calldata assetsAmounts) public view virtual returns (uint256 shares) {\n        uint256 _totalWeights = totalWeights;\n        uint256 length = assetsAmounts.length;\n\n        if (length != assets.length) revert InvalidLength();\n\n        for (uint256 i = 0; i < length;) {\n            uint256 share = assetsAmounts[i].mulDivUp(_totalWeights, weights[i]);\n            if (share > shares) shares = share;\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function previewRedeem(uint256 shares) public view virtual returns (uint256[] memory) {\n        return convertToAssets(shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626MultiToken\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function maxWithdraw(address owner) public view virtual returns (uint256[] memory) {\n        return convertToAssets(balanceOf[owner]);\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function beforeWithdraw(uint256[] memory assetsAmounts, uint256 shares) internal virtual {}\n\n    function afterDeposit(uint256[] memory assetsAmounts, uint256 shares) internal virtual {}\n}"
    },
    {
      "filename": "src/erc-4626/UlyssesERC4626.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\n\nimport {IUlyssesERC4626} from \"./interfaces/IUlyssesERC4626.sol\";\n\n/// @title Minimal ERC4626 tokenized 1:1 Vault implementation\n/// @author Maia DAO (https://github.com/Maia-DAO)\nabstract contract UlyssesERC4626 is ERC20, ReentrancyGuard, IUlyssesERC4626 {\n    using SafeTransferLib for address;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    address public immutable asset;\n\n    constructor(address _asset, string memory _name, string memory _symbol) ERC20(_name, _symbol, 18) {\n        asset = _asset;\n\n        if (ERC20(_asset).decimals() != 18) revert InvalidAssetDecimals();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function deposit(uint256 assets, address receiver) public virtual nonReentrant returns (uint256 shares) {\n        // Need to transfer before minting or ERC777s coul"
    }
  ]
}