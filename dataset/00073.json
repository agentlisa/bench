{
  "Title": "Depositors Can Avoid Participating in Debt Socialization",
  "Content": "The [`liquidate`](https://github.com/euler-xyz/euler-vault-kit/blob/83ea1ad97b7c561d6601b220d23ec85d67ceb297/src/EVault/modules/Liquidation.sol#L47-L58) function implements logic for [debt socialization](https://github.com/euler-xyz/euler-vault-kit/blob/83ea1ad97b7c561d6601b220d23ec85d67ceb297/src/EVault/modules/Liquidation.sol#L202-L214) when there is no more collateral to liquidate. Without delay in exiting positions, lenders can avoid participating in debt socialization by front running liquidation and withdrawing assets.\n\n\nConsider redesigning the mechanism to ensure that lenders cannot evade participating in debt socialization, either by implementing delayed withdrawals or by incentivizing participation through a reward system that can be implemented using a balance tracker hook.\n\n\n***Update:** Acknowledged, not resolved. The Euler team stated:*\n\n\n\n> *We acknowledge this issue. In our view, the largest area of concern is collusion between liquidators and major active depositors: If liquidators were to give/sell advance notice of a liquidation, opportunistic depositors could withdraw beforehand and the remaining passive depositors would take unfairly large haircuts on their deposits. This threat is specifically described in our whitepaper and we have decided to accept the risk.*\n> \n> \n> *Vault creators who do not wish to accept this risk can enable the `CFG_DONT_SOCIALIZE_DEBT` flag which will mitigate this issue. Although in this case, an alternative strategy of handling bad debt should be designed. Finally, in the future, a custom hook contract could be developed that enforces a withdrawal delay, as suggested.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "src/EVault/modules/Liquidation.sol",
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {ILiquidation} from \"../IEVault.sol\";\nimport {Base} from \"../shared/Base.sol\";\nimport {BalanceUtils} from \"../shared/BalanceUtils.sol\";\nimport {LiquidityUtils} from \"../shared/LiquidityUtils.sol\";\n\nimport \"../shared/types/Types.sol\";\n\n/// @title LiquidationModule\n/// @author Euler Labs (https://www.eulerlabs.com/)\n/// @notice An EVault module handling liquidations of unhealthy accounts\nabstract contract LiquidationModule is ILiquidation, Base, BalanceUtils, LiquidityUtils {\n    using TypesLib for uint256;\n\n    // Maximum liquidation discount that can be awarded under any conditions.\n    uint256 constant MAXIMUM_LIQUIDATION_DISCOUNT = 0.2 * 1e18;\n\n    struct LiquidationCache {\n        address liquidator;\n        address violator;\n        address collateral;\n        address[] collaterals;\n        Assets liability;\n        Assets repay;\n        uint256 yieldBalance;\n    }\n\n    /// @inheritdoc ILiquidation\n    function checkLiquidation(address liquidator, address violator, address collateral)\n        public\n        view\n        virtual\n        nonReentrantView\n        returns (uint256 maxRepay, uint256 maxYield)\n    {\n        LiquidationCache memory liqCache =\n            calculateLiquidation(loadVault(), liquidator, violator, collateral, type(uint256).max);\n\n        maxRepay = liqCache.repay.toUint();\n        maxYield = liqCache.yieldBalance;\n    }\n\n    /// @inheritdoc ILiquidation\n    function liquidate(address violator, address collateral, uint256 repayAssets, uint256 minYieldBalance)\n        public\n        virtual\n        nonReentrant\n    {\n        (VaultCache memory vaultCache, address liquidator) = initOperation(OP_LIQUIDATE, CHECKACCOUNT_CALLER);\n\n        LiquidationCache memory liqCache =\n            calculateLiquidation(vaultCache, liquidator, violator, collateral, repayAssets);\n\n        executeLiquidation(vaultCache, liqCache, minYieldBalance);\n    }\n\n    function calculateLiquidation(\n        VaultCache memory vaultCache,\n        address liquidator,\n        address violator,\n        address collateral,\n        uint256 desiredRepay\n    ) private view returns (LiquidationCache memory liqCache) {\n        // Init cache\n\n        liqCache.liquidator = liquidator;\n        liqCache.violator = violator;\n        liqCache.collateral = collateral;\n\n        liqCache.repay = Assets.wrap(0);\n        liqCache.yieldBalance = 0;\n        liqCache.liability = getCurrentOwed(vaultCache, violator).toAssetsUp();\n        liqCache.collaterals = getCollaterals(violator);\n\n        // Checks\n\n        // Self liquidation is not allowed\n        if (liqCache.violator == liqCache.liquidator) revert E_SelfLiquidation();\n        // Only liquidate trusted collaterals to make sure yield transfer has no side effects.\n        if (!isRecognizedCollateral(liqCache.collateral)) revert E_BadCollateral();\n        // Verify this vault is the controller for the violator\n        validateController(liqCache.violator);\n        // Violator must have enabled the collateral to be transferred to the liquidator\n        if (!isCollateralEnabled(liqCache.violator, liqCache.collateral)) revert E_CollateralDisabled();\n        // Violator's health check must not be deferred, meaning no prior operations on violator's account\n        // would possibly be forgiven after the enforced collateral transfer to the liquidator\n        if (isAccountStatusCheckDeferred(violator)) revert E_ViolatorLiquidityDeferred();\n\n        // Violator has no liabilities, liquidation is a no-op\n        if (liqCache.liability.isZero()) return liqCache;\n\n        // Calculate max yield and repay\n\n        liqCache = calculateMaxLiquidation(liqCache, vaultCache);\n\n        // Adjust for desired repay\n\n        if (desiredRepay != type(uint256).max) {\n            uint256 maxRepay = liqCache.repay.toUint();\n            if (desiredRepay > maxRepay) revert E_ExcessiveRepayAmount();\n\n            if (maxRepay > 0) {\n                liqCache.yieldBalance = desiredRepay * liqCache.yieldBalance / maxRepay;\n                liqCache.repay = desiredRepay.toAssets();\n            }\n        }\n    }\n\n    function calculateMaxLiquidation(LiquidationCache memory liqCache, VaultCache memory vaultCache)\n        private\n        view\n        returns (LiquidationCache memory)\n    {\n        // Check account health\n\n        (uint256 liquidityCollateralValue, uint256 liquidityLiabilityValue) =\n            calculateLiquidity(vaultCache, liqCache.violator, liqCache.collaterals, LTVType.LIQUIDATION);\n\n        // no violation\n        if (liquidityCollateralValue > liquidityLiabilityValue) return liqCache;\n\n        // Compute discount\n\n        uint256 discountFactor = liquidityCollateralValue * 1e18 / liquidityLiabilityValue; // discountFactor = health score = 1 - discount\n\n        if (discountFactor < 1e18 - MAXIMUM_LIQUIDATION_DISCOUNT) {\n            discountFactor = 1e18 - MAXIMUM_LIQUIDATION_DISCOUNT;\n        }\n\n        // Compute maximum yield\n\n        uint256 collateralBalance = IERC20(liqCache.collateral).balanceOf(liqCache.violator);\n        uint256 collateralValue =\n            vaultCache.oracle.getQuote(collateralBalance, liqCache.collateral, vaultCache.unitOfAccount);\n\n        if (collateralValue == 0) {\n            // worthless collateral can be claimed with no repay\n            liqCache.yieldBalance = collateralBalance;\n            return liqCache;\n        }\n\n        uint256 liabilityValue = liqCache.liability.toUint();\n        if (address(vaultCache.asset) != vaultCache.unitOfAccount) {\n            // liquidation, in contrast to liquidity calculation, uses mid-point pricing instead of bid/ask\n            liabilityValue =\n                vaultCache.oracle.getQuote(liabilityValue, address(vaultCache.asset), vaultCache.unitOfAccount);\n        }\n\n        uint256 maxRepayValue = liabilityValue;\n        uint256 maxYieldValue = maxRepayValue * 1e18 / discountFactor;\n\n        // Limit yield to borrower's available collateral, and reduce repay if necessary\n        // This can happen when borrower has multiple collaterals and seizing all of this one won't bring the violator back to solvency\n\n        if (collateralValue < maxYieldValue) {\n            maxRepayValue = collateralValue * discountFactor / 1e18;\n            maxYieldValue = collateralValue;\n        }\n\n        liqCache.repay = (maxRepayValue * liqCache.liability.toUint() / liabilityValue).toAssets();\n        liqCache.yieldBalance = maxYieldValue * collateralBalance / collateralValue;\n\n        return liqCache;\n    }\n\n    function executeLiquidation(VaultCache memory vaultCache, LiquidationCache memory liqCache, uint256 minYieldBalance)\n        private\n    {\n        // Check minimum yield.\n\n        if (minYieldBalance > liqCache.yieldBalance) revert E_MinYield();\n\n        // Handle repay: liquidator takes on violator's debt:\n\n        transferBorrow(vaultCache, liqCache.violator, liqCache.liquidator, liqCache.repay);\n\n        // Handle yield: liquidator receives violator's collateral\n\n        // Impersonate violator on the EVC to seize collateral. The yield transfer will trigger a health check on the violator's\n        // account, which should be forgiven, because the violator's account is not guaranteed to be healthy after liquidation.\n        // This operation is safe, because:\n        // 1. `liquidate` function is enforcing that the violator is not in deferred checks state,\n        //    therefore there were no prior batch operations that could have registered a health check,\n        //    and if the check is present now, it must have been triggered by the enforced transfer.\n        // 2. Only collaterals with initialized LTV settings can be liquidated and they are assumed to be audited\n        //    to have safe transfer methods, which make no external calls. In other words, yield transfer will not\n        //    have any side effects, which would be wrongly forgiven.\n        // 3. Any additional operations on violator's account in a batch will register the health check again, and it\n        //    will be executed normally at the end of the batch.\n\n        if (liqCache.yieldBalance > 0) {\n            enforceCollateralTransfer(\n                liqCache.collateral, liqCache.yieldBalance, liqCache.violator, liqCache.liquidator\n            );\n\n            forgiveAccountStatusCheck(liqCache.violator);\n        }\n\n        // Handle debt socialization\n\n        if (\n            vaultCache.configFlags.isNotSet(CFG_DONT_SOCIALIZE_DEBT) && liqCache.liability > liqCache.repay\n                && checkNoCollateral(liqCache.violator, liqCache.collaterals)\n        ) {\n            Assets owedRemaining = liqCache.liability - liqCache.repay;\n            decreaseBorrow(vaultCache, liqCache.violator, owedRemaining);\n\n            // decreaseBorrow emits Repay without any assets entering the vault. Emit Withdraw from and to zero address to cover the missing amount for offchain trackers.\n            emit Withdraw(liqCache.liquidator, address(0), address(0), owedRemaining.toUint(), 0);\n            emit DebtSocialized(liqCache.violator, owedRemaining.toUint());\n        }\n\n        emit Liquidate(\n            liqCache.liquidator, liqCache.violator, liqCache.collateral, liqCache.repay.toUint(), liqCache.yieldBalance\n        );\n    }\n}\n\n/// @dev Deployable module contract\ncontract Liquidation is LiquidationModule {\n    constructor(Integrations memory integrations) Base(integrations) {}\n}"
    }
  ]
}