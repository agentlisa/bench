{
  "Title": "[M-31] changeWallets() can be confirmed immediately after proposalWallets() by manipulating activeTimelock beforehand",
  "Content": "\n`ManagedWallet.sol` [states](https://github.com/code-423n4/2024-01-salty/blob/main/src/ManagedWallet.sol#L7-L10) that:\n\n```text\n// A smart contract which provides two wallet addresses (a main and confirmation wallet) which can be changed using the following mechanism:\n// 1. Main wallet can propose a new main wallet and confirmation wallet.\n// 2. Confirmation wallet confirms or rejects.\n// 3. There is a timelock of 30 days before the proposed mainWallet can confirm the change.\n```\nHowever, the current 30-day wait period can be bypassed. <br>\n\nThe expected order by the protocol is:\n\n1.  `proposeWallets()` is called by `mainWallet`.\n2.  To confirm the proposal, `confirmationWallet` sends at least 0.05 ether and causes the `receive()` function to trigger. This sets the `activeTimelock` to `block.timestamp + TIMELOCK_DURATION` i.e. 30 days into the future.\n3.  `proposedMainWallet` calls `changeWallets()` after 30 days and the new wallet addresses are set.\n\nTo bypass the 30-day limitation, the following flow can be used:\n\n1.  Even with no propsal for a change existing, `confirmationWallet` sends at least 0.05 ether and causes the `receive()` function to trigger. This sets the `activeTimelock` to `block.timestamp + TIMELOCK_DURATION` i.e. 30 days into the future.\n2.  Just as 30 days pass,\n    *   `proposeWallets()` is called by `mainWallet`\n    *   Immediately, with no delay whatsoever, `proposedMainWallet` calls `changeWallets()`\n3.  The new wallet addresses are successfully assigned.\n\n**Impact:** Although the users believe that any changes to wallet address is going to have a timelock of 30 days as promised by the protocol, it really can be bypassed by the current admins/wallet addresses. This breaks the intended functionality implmentation.\n\n### Proof of Concept\n\nAdd the following inside `2024-01-salty/src/root_tests/ManagedWallet.t.sol` and run with `COVERAGE=\"yes\" NETWORK=\"sep\" forge test -vv --rpc-url https://rpc.sepolia.org/ --mt test_ManipulateActiveTimeLockBeforeProposingNewWallets`:\n\n<details>\n\n```js\n    function test_ManipulateActiveTimeLockBeforeProposingNewWallets() public {\n        // Set up the initial state with main and confirmation wallets\n        address initialMainWallet = alice;\n        address initialConfirmationWallet = address(0x2222);\n        ManagedWallet managedWallet = new ManagedWallet(initialMainWallet, initialConfirmationWallet);\n\n        // Set up the proposed main and confirmation wallets\n        address newMainWallet = address(0x3333);\n        address newConfirmationWallet = address(0x4444);\n\n        // @audit : Even before any proposal exists, prank as the current confirmation wallet and send ether to start the TIMELOCK_DURATION \n        uint256 sentValue = 0.06 ether;\n        vm.prank(initialConfirmationWallet);\n        vm.deal(initialConfirmationWallet, sentValue);\n        (bool success,) = address(managedWallet).call{value: sentValue}(\"\");\n        assertTrue(success, \"Confirmation of wallet proposal failed\");\n\n        // Warp the blockchain time to the future beyond the active timelock period\n        uint256 currentTime = block.timestamp;\n        vm.warp(currentTime + TIMELOCK_DURATION);\n\n        // Prank as the initial main wallet to propose the new wallets\n        vm.startPrank(initialMainWallet);\n        managedWallet.proposeWallets(newMainWallet, newConfirmationWallet);\n        vm.stopPrank();\n\n        // @audit : With NO DELAY, immediately prank as the new proposed main wallet which should now be allowed to call changeWallets\n        vm.prank(newMainWallet);\n        managedWallet.changeWallets();\n\n        // Check that the mainWallet and confirmationWallet state variables are updated\n        assertEq(managedWallet.mainWallet(), newMainWallet, \"mainWallet was not updated correctly\");\n        assertEq(managedWallet.confirmationWallet(), newConfirmationWallet, \"confirmationWallet was not updated correctly\");\n\n        // Check that the proposed wallets and activeTimelock have been reset\n        assertEq(managedWallet.proposedMainWallet(), address(0), \"proposedMainWallet was not reset\");\n        assertEq(managedWallet.proposedConfirmationWallet(), address(0), \"proposedConfirmationWallet was not reset\");\n        assertEq(managedWallet.activeTimelock(), type(uint256).max, \"activeTimelock was not reset to max uint256\");\n    }\n```\n\n</details>\n\n### Tools used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nInside `receive()` make sure an active proposal exists:\n\n```diff\n    receive() external payable\n    \t{\n    \trequire( msg.sender == confirmationWallet, \"Invalid sender\" );\n+       require( proposedMainWallet != address(0), \"Cannot manipulate activeTimelock without active proposal\" );\n\n\t\t// Confirm if .05 or more ether is sent and otherwise reject.\n\t\t// Done this way in case custodial wallets are used as the confirmationWallet - which sometimes won't allow for smart contract calls.\n    \tif ( msg.value >= .05 ether )\n    \t\tactiveTimelock = block.timestamp + TIMELOCK_DURATION; // establish the timelock\n    \telse\n\t\t\tactiveTimelock = type(uint256).max; // effectively never\n        }\n```\n\n**[othernet-global (Salty.IO) confirmed and commented](https://github.com/code-423n4/2024-01-salty-findings/issues/49#issuecomment-1953430147):**\n > Managed wallet has been removed:\n> \n> https://github.com/othernet-global/salty-io/commit/5766592880737a5e682bb694a3a79e12926d48a5\n\n**Status:** Mitigation confirmed. Full details in reports from [t0x1c](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/15), [zzebra83](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/113), and [0xpiken](https://github.com/code-423n4/2024-03-saltyio-mitigation-findings/issues/92).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2024-01-salty",
  "Code": [
    {
      "filename": "src/ManagedWallet.sol",
      "content": "// SPDX-License-Identifier: BUSL 1.1\npragma solidity =0.8.22;\n\nimport \"./interfaces/IManagedWallet.sol\";\n\n\n// A smart contract which provides two wallet addresses (a main and confirmation wallet) which can be changed using the following mechanism:\n// 1. Main wallet can propose a new main wallet and confirmation wallet.\n// 2. Confirmation wallet confirms or rejects.\n// 3. There is a timelock of 30 days before the proposed mainWallet can confirm the change.\n\ncontract ManagedWallet is IManagedWallet\n    {\n    event WalletProposal(address proposedMainWallet, address proposedConfirmationWallet);\n    event WalletChange(address mainWallet, address confirmationWallet);\n\n    uint256 constant public TIMELOCK_DURATION = 30 days;\n\n    // The active main and confirmation wallets\n    address public mainWallet;\n    address public confirmationWallet;\n\n\t// Proposed wallets\n    address public proposedMainWallet;\n    address public proposedConfirmationWallet;\n\n\t// Active timelock\n    uint256 public activeTimelock;\n\n\n\tconstructor( address _mainWallet, address _confirmationWallet)\n\t\t{\n\t\tmainWallet = _mainWallet;\n\t\tconfirmationWallet = _confirmationWallet;\n\n\t\t// Write a value so subsequent writes take less gas\n\t\tactiveTimelock = type(uint256).max;\n        }\n\n\n\t// Make a request to change the main and confirmation wallets.\n\tfunction proposeWallets( address _proposedMainWallet, address _proposedConfirmationWallet ) external\n\t\t{\n\t\trequire( msg.sender == mainWallet, \"Only the current mainWallet can propose changes\" );\n\t\trequire( _proposedMainWallet != address(0), \"_proposedMainWallet cannot be the zero address\" );\n\t\trequire( _proposedConfirmationWallet != address(0), \"_proposedConfirmationWallet cannot be the zero address\" );\n\n\t\t// Make sure we're not overwriting a previous proposal (as only the confirmationWallet can reject proposals)\n\t\trequire( proposedMainWallet == address(0), \"Cannot overwrite non-zero proposed mainWallet.\" );\n\n\t\tproposedMainWallet = _proposedMainWallet;\n\t\tproposedConfirmationWallet = _proposedConfirmationWallet;\n\n\t\temit WalletProposal(proposedMainWallet, proposedConfirmationWallet);\n\t\t}\n\n\n\t// The confirmation wallet confirms or rejects wallet proposals by sending a specific amount of ETH to this contract\n    receive() external payable\n    \t{\n    \trequire( msg.sender == confirmationWallet, \"Invalid sender\" );\n\n\t\t// Confirm if .05 or more ether is sent and otherwise reject.\n\t\t// Done this way in case custodial wallets are used as the confirmationWallet - which sometimes won't allow for smart contract calls.\n    \tif ( msg.value >= .05 ether )\n    \t\tactiveTimelock = block.timestamp + TIMELOCK_DURATION; // establish the timelock\n    \telse\n\t\t\tactiveTimelock = type(uint256).max; // effectively never\n        }\n\n\n\t// Confirm the wallet proposals - assuming that the active timelock has already expired.\n\tfunction changeWallets() external\n\t\t{\n\t\t// proposedMainWallet calls the function - to make sure it is a valid address.\n\t\trequire( msg.sender == proposedMainWallet, \"Invalid sender\" );\n\t\trequire( block.timestamp >= activeTimelock, \"Timelock not yet completed\" );\n\n\t\t// Set the wallets\n\t\tmainWallet = proposedMainWallet;\n\t\tconfirmationWallet = proposedConfirmationWallet;\n\n\t\temit WalletChange(mainWallet, confirmationWallet);\n\n\t\t// Reset\n\t\tactiveTimelock = type(uint256).max;\n\t\tproposedMainWallet = address(0);\n\t\tproposedConfirmationWallet = address(0);\n\t\t}\n\t}"
    }
  ]
}