{
  "Title": "H-7: Refunds can be bricked by triggering OOG (out of gas) in DepositManager",
  "Content": "# Issue H-7: Refunds can be bricked by triggering OOG (out of gas) in DepositManager \n\nSource: https://github.com/sherlock-audit/2023-02-openq-judging/issues/77 \n\n## Found by \nrvierdiiev, eyexploit, TrungOre, 0xdeadbeef, MyFDsYours, joestakey, HollaDieWaldfee, chainNue, bin2chen, kiki\\_dev, clems4ever, unforgiven, yixxas, jkoppel, hake, Robert, imare, HonorLt, 0x52, ak1, Atarpara, ctf\\_sec, ltyu, seyni, Jeiwan, GimelSec, carrot, KingNFT, holyhansss\n\n## Summary\nThe `DepositManager` contract is in charge of refunding tokens from the individual bounties. This function ends up running a for loop over an unbounded array. This array can be made to be sufficiently large to exceed the block gas limit and cause out-of-gas errors and stop the processing of any refunds.\n## Vulnerability Detail\nThe function `refundDeposit()` in `DepositManager.sol` is responsible for handling refunds, through the following snippet of code,\nhttps://github.com/sherlock-audit/2023-02-openq/blob/main/contracts/DepositManager/Implementations/DepositManagerV1.sol#L152-L181\nWe are here interested in the line \nhttps://github.com/sherlock-audit/2023-02-openq/blob/main/contracts/DepositManager/Implementations/DepositManagerV1.sol#L171-L172\nwhich calculates available funds. If we check the function `getLockedFunds()`, we see it run a for loop\nhttps://github.com/sherlock-audit/2023-02-openq/blob/main/contracts/Bounty/Implementations/BountyCore.sol#L333-L352\nThis loop is running over the list of ALL deposits. The deposit list is unbounded, since there are no checks for such limits in the `receiveFunds()` function. This can result in a very long list, causing out-of-gas errors when making refund calls.\n## Impact\nInability to withdraw funds. Can be forever locked into the contract.\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-02-openq/blob/main/contracts/Bounty/Implementations/BountyCore.sol#L333-L352\n## Tool used\nManual Review\n\n## Recommendation\nPut a bound on the function `receiveFunds` to limit the number of deposits allowed.\n\n## Discussion\n\n**FlacoJones**\n\nConfirmed. Will fix by requiring funder == issuer and implementing a simple deposit volume greater than/less than token balance after claims\n\n**FlacoJones**\n\nhttps://github.com/OpenQDev/OpenQ-Contracts/pull/117 and https://github.com/OpenQDev/OpenQ-Contracts/pull/116\n\n\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/39",
  "Code": [
    {
      "filename": "contracts/DepositManager/Implementations/DepositManagerV1.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport '../Storage/DepositManagerStorage.sol';\n\n/// @title DepositManagerV1\n/// @author FlacoJones\n/// @notice Manager contract for depositing protocol, ERC-20, and ERC-721 on bounty contracts\n/// @notice Emitter of all deposit-related events\ncontract DepositManagerV1 is DepositManagerStorageV1 {\n    constructor() {}\n\n    /// @notice Initializes the DepositManager implementation\n    /// @notice Can only be called once thanks to initializer (https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializers)\n    function initialize() external initializer {\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n    }\n\n    /// @notice Sets openQTokenWhitelist address\n    /// @param _openQTokenWhitelist The OpenQTokenWhitelist address\n    function setTokenWhitelist(address _openQTokenWhitelist)\n        external\n        onlyOwner\n        onlyProxy\n    {\n        openQTokenWhitelist = OpenQTokenWhitelist(_openQTokenWhitelist);\n    }\n\n    /// @notice Transfers protocol token or ERC20 from msg.sender to bounty address\n    /// @param _bountyAddress A bounty address\n    /// @param _tokenAddress The ERC20 token address (ZeroAddress if funding with protocol token)\n    /// @param _volume The volume of token transferred\n    /// @param _expiration The duration until the deposit becomes refundable\n    /// @param funderUuid The external user id of the funder\n    function fundBountyToken(\n        address _bountyAddress,\n        address _tokenAddress,\n        uint256 _volume,\n        uint256 _expiration,\n        string memory funderUuid\n    ) external payable onlyProxy {\n        IBounty bounty = IBounty(payable(_bountyAddress));\n\n        if (!isWhitelisted(_tokenAddress)) {\n            require(\n                !tokenAddressLimitReached(_bountyAddress),\n                Errors.TOO_MANY_TOKEN_ADDRESSES\n            );\n        }\n\n        require(bountyIsOpen(_bountyAddress), Errors.CONTRACT_ALREADY_CLOSED);\n\n        (bytes32 depositId, uint256 volumeReceived) = bounty.receiveFunds{\n            value: msg.value\n        }(msg.sender, _tokenAddress, _volume, _expiration);\n\n        bytes memory funderUuidBytes = abi.encode(funderUuid);\n\n        emit TokenDepositReceived(\n            depositId,\n            _bountyAddress,\n            bounty.bountyId(),\n            bounty.organization(),\n            _tokenAddress,\n            block.timestamp,\n            msg.sender,\n            _expiration,\n            volumeReceived,\n            0,\n            funderUuidBytes,\n            VERSION_1\n        );\n    }\n\n    /// @notice Extends the expiration for a deposit\n    /// @param _bountyAddress Bounty address\n    /// @param _depositId The deposit to extend\n    /// @param _seconds The duration to add until the deposit becomes refundable\n    function extendDeposit(\n        address _bountyAddress,\n        bytes32 _depositId,\n        uint256 _seconds\n    ) external onlyProxy {\n        IBounty bounty = IBounty(payable(_bountyAddress));\n\n        require(\n            bounty.funder(_depositId) == msg.sender,\n            Errors.CALLER_NOT_FUNDER\n        );\n\n        uint256 newExpiration = bounty.extendDeposit(\n            _depositId,\n            _seconds,\n            msg.sender\n        );\n\n        emit DepositExtended(\n            _depositId,\n            newExpiration,\n            0,\n            new bytes(0),\n            VERSION_1\n        );\n    }\n\n    /// @notice Transfers NFT from msg.sender to bounty address\n    /// @param _bountyAddress The address of the bounty to fund\n    /// @param _tokenAddress The ERC721 token address of the NFT\n    /// @param _tokenId The tokenId of the NFT to transfer\n    /// @param _expiration The duration until the deposit becomes refundable\n    /// @param _data The tier of the NFT (not relevant for non-tiered bounties)\n    function fundBountyNFT(\n        address _bountyAddress,\n        address _tokenAddress,\n        uint256 _tokenId,\n        uint256 _expiration,\n        bytes calldata _data\n    ) external onlyProxy {\n        IBounty bounty = IBounty(payable(_bountyAddress));\n\n        require(isWhitelisted(_tokenAddress), Errors.TOKEN_NOT_ACCEPTED);\n        require(bountyIsOpen(_bountyAddress), Errors.CONTRACT_ALREADY_CLOSED);\n\n        bytes32 depositId = bounty.receiveNft(\n            msg.sender,\n            _tokenAddress,\n            _tokenId,\n            _expiration,\n            _data\n        );\n\n        emit NFTDepositReceived(\n            depositId,\n            _bountyAddress,\n            bounty.bountyId(),\n            bounty.organization(),\n            _tokenAddress,\n            block.timestamp,\n            msg.sender,\n            _expiration,\n            _tokenId,\n            0,\n            _data,\n            VERSION_1\n        );\n    }\n\n    /// @notice Refunds an individual deposit from bountyAddress to sender if expiration time has passed\n    /// @param _bountyAddress The address of the bounty that has the deposit to refund\n    /// @param _depositId The depositId associated with the deposit being refunded\n    function refundDeposit(address _bountyAddress, bytes32 _depositId)\n        external\n        onlyProxy\n    {\n        IBounty bounty = IBounty(payable(_bountyAddress));\n\n        require(\n            bounty.funder(_depositId) == msg.sender,\n            Errors.CALLER_NOT_FUNDER\n        );\n\n        require(\n            block.timestamp >=\n                bounty.depositTime(_depositId) + bounty.expiration(_depositId),\n            Errors.PREMATURE_REFUND_REQUEST\n        );\n\n        address depToken = bounty.tokenAddress(_depositId);\n\n        uint256 availableFunds = bounty.getTokenBalance(depToken) -\n            bounty.getLockedFunds(depToken);\n\n        uint256 volume;\n        if (bounty.volume(_depositId) <= availableFunds) {\n            volume = bounty.volume(_depositId);\n        } else {\n            volume = availableFunds;\n        }\n\n        bounty.refundDeposit(_depositId, msg.sender, volume);\n\n        emit DepositRefunded(\n            _depositId,\n            bounty.bountyId(),\n            _bountyAddress,\n            bounty.organization(),\n            block.timestamp,\n            bounty.tokenAddress(_depositId),\n            volume,\n            0,\n            new bytes(0),\n            VERSION_1\n        );\n    }\n\n    /// @notice Checks if _tokenAddress is whitelisted\n    /// @param _tokenAddress The token address in question\n    /// @return True if _tokenAddress is whitelisted, false otherwise\n    function isWhitelisted(address _tokenAddress) public view returns (bool) {\n        return openQTokenWhitelist.isWhitelisted(_tokenAddress);\n    }\n\n    /// @notice Returns true if the total number of unique tokens deposited on then bounty is greater than the OpenQWhitelist TOKEN_ADDRESS_LIMIT\n    /// @param _bountyAddress Address of bounty\n    /// @return True if the token address limit has been reached\n    function tokenAddressLimitReached(address _bountyAddress)\n        public\n        view\n        returns (bool)\n    {\n        IBounty bounty = IBounty(payable(_bountyAddress));\n\n        return\n            bounty.getTokenAddressesCount() >=\n            openQTokenWhitelist.TOKEN_ADDRESS_LIMIT();\n    }\n\n    /// @notice Checks if bounty associated with _bountyId is open\n    /// @param _bountyAddress Address of bounty\n    /// @return bool True if _bountyId is associated with an open bounty\n    function bountyIsOpen(address _bountyAddress) public view returns (bool) {\n        IBounty bounty = IBounty(payable(_bountyAddress));\n        bool isOpen = bounty.status() == OpenQDefinitions.OPEN;\n        return isOpen;\n    }\n\n    /// @notice Override for UUPSUpgradeable._authorizeUpgrade(address newImplementation) to enforce onlyOwner upgrades\n    function _authorizeUpgrade(address) internal override onlyOwner {}\n}"
    },
    {
      "filename": "contracts/DepositManager/Implementations/DepositManagerV1.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport '../Storage/DepositManagerStorage.sol';\n\n/// @title DepositManagerV1\n/// @author FlacoJones\n/// @notice Manager contract for depositing protocol, ERC-20, and ERC-721 on bounty contracts\n/// @notice Emitter of all deposit-related events\ncontract DepositManagerV1 is DepositManagerStorageV1 {\n    constructor() {}\n\n    /// @notice Initializes the DepositManager implementation\n    /// @notice Can only be called once thanks to initializer (https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializers)\n    function initialize() external initializer {\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n    }\n\n    /// @notice Sets openQTokenWhitelist address\n    /// @param _openQTokenWhitelist The OpenQTokenWhitelist address\n    function setTokenWhitelist(address _openQTokenWhitelist)\n        external\n        onlyOwner\n        onlyProxy\n    {\n        openQTokenWhitelist = OpenQTokenWhitelist(_openQTokenWhitelist);\n    }\n\n    /// @notice Transfers protocol token or ERC20 from msg.sender to bounty address\n    /// @param _bountyAddress A bounty address\n    /// @param _tokenAddress The ERC20 token address (ZeroAddress if funding with protocol token)\n    /// @param _volume The volume of token transferred\n    /// @param _expiration The duration until the deposit becomes refundable\n    /// @param funderUuid The external user id of the funder\n    function fundBountyToken(\n        address _bountyAddress,\n        address _tokenAddress,\n        uint256 _volume,\n        uint256 _expiration,\n        string memory funderUuid\n    ) external payable onlyProxy {\n        IBounty bounty = IBounty(payable(_bountyAddress));\n\n        if (!isWhitelisted(_tokenAddress)) {\n            require(\n                !tokenAddressLimitReached(_bountyAddress),\n                Errors.TOO_MANY_TOKEN_ADDRESSES\n            );\n        }\n\n        require(bountyIsOpen(_bountyAddress), Errors.CONTRACT_ALREADY_CLOSED);\n\n        (bytes32 depositId, uint256 volumeReceived) = bounty.receiveFunds{\n            value: msg.value\n        }(msg.sender, _tokenAddress, _volume, _expiration);\n\n        bytes memory funderUuidBytes = abi.encode(funderUuid);\n\n        emit TokenDepositReceived(\n            depositId,\n            _bountyAddress,\n            bounty.bountyId(),\n            bounty.organization(),\n            _tokenAddress,\n            block.timestamp,\n            msg.sender,\n            _expiration,\n            volumeReceived,\n            0,\n            funderUuidBytes,\n            VERSION_1\n        );\n    }\n\n    /// @notice Extends the expiration for a deposit\n    /// @param _bountyAddress Bounty address\n    /// @param _depositId The deposit to extend\n    /// @param _seconds The duration to add until the deposit becomes refundable\n    function extendDeposit(\n        address _bountyAddress,\n        bytes32 _depositId,\n        uint256 _seconds\n    ) external onlyProxy {\n        IBounty bounty = IBounty(payable(_bountyAddress));\n\n        require(\n            bounty.funder(_depositId) == msg.sender,\n            Errors.CALLER_NOT_FUNDER\n        );\n\n        uint256 newExpiration = bounty.extendDeposit(\n            _depositId,\n            _seconds,\n            msg.sender\n        );\n\n        emit DepositExtended(\n            _depositId,\n            newExpiration,\n            0,\n            new bytes(0),\n            VERSION_1\n        );\n    }\n\n    /// @notice Transfers NFT from msg.sender to bounty address\n    /// @param _bountyAddress The address of the bounty to fund\n    /// @param _tokenAddress The ERC721 token address of the NFT\n    /// @param _tokenId The tokenId of the NFT to transfer\n    /// @param _expiration The duration until the deposit becomes refundable\n    /// @param _data The tier of the NFT (not relevant for non-tiered bounties)\n    function fundBountyNFT(\n        address _bountyAddress,\n        address _tokenAddress,\n        uint256 _tokenId,\n        uint256 _expiration,\n        bytes calldata _data\n    ) external onlyProxy {\n        IBounty bounty = IBounty(payable(_bountyAddress));\n\n        require(isWhitelisted(_tokenAddress), Errors.TOKEN_NOT_ACCEPTED);\n        require(bountyIsOpen(_bountyAddress), Errors.CONTRACT_ALREADY_CLOSED);\n\n        bytes32 depositId = bounty.receiveNft(\n            msg.sender,\n            _tokenAddress,\n            _tokenId,\n            _expiration,\n            _data\n        );\n\n        emit NFTDepositReceived(\n            depositId,\n            _bountyAddress,\n            bounty.bountyId(),\n            bounty.organization(),\n            _tokenAddress,\n            block.timestamp,\n            msg.sender,\n            _expiration,\n            _tokenId,\n            0,\n            _data,\n            VERSION_1\n        );\n    }\n\n    /// @notice Refunds an individual deposit from bountyAddress to sender if expiration time has passed\n    /// @param _bountyAddress The address of the bounty that has the deposit to refund\n    /// @param _depositId The depositId associated with the deposit being refunded\n    function refundDeposit(address _bountyAddress, bytes32 _depositId)\n        external\n        onlyProxy\n    {\n        IBounty bounty = IBounty(payable(_bountyAddress));\n\n        require(\n            bounty.funder(_depositId) == msg.sender,\n            Errors.CALLER_NOT_FUNDER\n        );\n\n        require(\n            block.timestamp >=\n                bounty.depositTime(_depositId) + bounty.expiration(_depositId),\n            Errors.PREMATURE_REFUND_REQUEST\n        );\n\n        address depToken = bounty.tokenAddress(_depositId);\n\n        uint256 availableFunds = bounty.getTokenBalance(depToken) -\n            bounty.getLockedFunds(depToken);\n\n        uint256 volume;\n        if (bounty.volume(_depositId) <= availableFunds) {\n            volume = bounty.volume(_depositId);\n        } else {\n            volume = availableFunds;\n        }\n\n        bounty.refundDeposit(_depositId, msg.sender, volume);\n\n        emit DepositRefunded(\n            _depositId,\n            bounty.bountyId(),\n            _bountyAddress,\n            bounty.organization(),\n            block.timestamp,\n            bounty.tokenAddress(_depositId),\n            volume,\n            0,\n            new bytes(0),\n            VERSION_1\n        );\n    }\n\n    /// @notice Checks if _tokenAddress is whitelisted\n    /// @param _tokenAddress The token address in question\n    /// @return True if _tokenAddress is whitelisted, false otherwise\n    function isWhitelisted(address _tokenAddress) public view returns (bool) {\n        return openQTokenWhitelist.isWhitelisted(_tokenAddress);\n    }\n\n    /// @notice Returns true if the total number of unique tokens deposited on then bounty is greater than the OpenQWhitelist TOKEN_ADDRESS_LIMIT\n    /// @param _bountyAddress Address of bounty\n    /// @return True if the token address limit has been reached\n    function tokenAddressLimitReached(address _bountyAddress)\n        public\n        view\n        returns (bool)\n    {\n        IBounty bounty = IBounty(payable(_bountyAddress));\n\n        return\n            bounty.getTokenAddressesCount() >=\n            openQTokenWhitelist.TOKEN_ADDRESS_LIMIT();\n    }\n\n    /// @notice Checks if bounty associated with _bountyId is open\n    /// @param _bountyAddress Address of bounty\n    /// @return bool True if _bountyId is associated with an open bounty\n    function bountyIsOpen(address _bountyAddress) public view returns (bool) {\n        IBounty bounty = IBounty(payable(_bountyAddress));\n        bool isOpen = bounty.status() == OpenQDefinitions.OPEN;\n        return isOpen;\n    }\n\n    /// @notice Override for UUPSUpgradeable._authorizeUpgrade(address newImplementation) to enforce onlyOwner upgrades\n    function _authorizeUpgrade(address) internal override onlyOwner {}\n}"
    },
    {
      "filename": "contracts/Bounty/Implementations/BountyCore.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport '../Storage/BountyStorageCore.sol';\n\n/// @title BountyCore\n/// @author FlacoJones\n/// @notice Shared methods common to all bounty types\n/// @dev BountyCore -> BountyStorageCore -> Core Dependencies (OZ + Custom)\nabstract contract BountyCore is BountyStorageCore {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressUpgradeable for address payable;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    /// @notice Creates a deposit and transfers tokens from msg.sender to this contract\n    /// @param _funder The funder's address\n    /// @param _tokenAddress The ERC20 token address (ZeroAddress if funding with protocol token)\n    /// @param _volume The volume of token to transfer\n    /// @param _expiration The duration until the deposit becomes refundable\n    /// @return (depositId, volumeReceived) Returns the deposit id and the amount transferred to bounty\n    function receiveFunds(\n        address _funder,\n        address _tokenAddress,\n        uint256 _volume,\n        uint256 _expiration\n    )\n        external\n        payable\n        virtual\n        onlyDepositManager\n        nonReentrant\n        returns (bytes32, uint256)\n    {\n        require(_volume != 0, Errors.ZERO_VOLUME_SENT);\n        require(_expiration > 0, Errors.EXPIRATION_NOT_GREATER_THAN_ZERO);\n        require(status == OpenQDefinitions.OPEN, Errors.CONTRACT_IS_CLOSED);\n\n        bytes32 depositId = _generateDepositId();\n\n        uint256 volumeReceived;\n        if (_tokenAddress == address(0)) {\n            volumeReceived = msg.value;\n        } else {\n            volumeReceived = _receiveERC20(_tokenAddress, _funder, _volume);\n        }\n\n        funder[depositId] = _funder;\n        tokenAddress[depositId] = _tokenAddress;\n        volume[depositId] = volumeReceived;\n        depositTime[depositId] = block.timestamp;\n        expiration[depositId] = _expiration;\n        isNFT[depositId] = false;\n\n        deposits.push(depositId);\n        tokenAddresses.add(_tokenAddress);\n\n        return (depositId, volumeReceived);\n    }\n\n    /// @notice Transfers volume of deposit or NFT of deposit from bounty to funder\n    /// @param _depositId The deposit to refund\n    /// @param _funder The initial funder of the deposit\n    /// @param _volume The volume to be refunded (only relevant if deposit is not an NFT, otherwise is zero)\n    function refundDeposit(\n        bytes32 _depositId,\n        address _funder,\n        uint256 _volume\n    ) external virtual onlyDepositManager nonReentrant {\n        require(!refunded[_depositId], Errors.DEPOSIT_ALREADY_REFUNDED);\n        require(funder[_depositId] == _funder, Errors.CALLER_NOT_FUNDER);\n        require(\n            block.timestamp >= depositTime[_depositId] + expiration[_depositId],\n            Errors.PREMATURE_REFUND_REQUEST\n        );\n\n        refunded[_depositId] = true;\n\n        if (tokenAddress[_depositId] == address(0)) {\n            _transferProtocolToken(funder[_depositId], _volume);\n        } else if (isNFT[_depositId]) {\n            _transferNft(\n                tokenAddress[_depositId],\n                funder[_depositId],\n                tokenId[_depositId]\n            );\n        } else {\n            _transferERC20(\n                tokenAddress[_depositId],\n                funder[_depositId],\n                _volume\n            );\n        }\n    }\n\n    /// @notice Extends deposit duration\n    /// @param _depositId The deposit to extend\n    /// @param _seconds Number of seconds to extend deposit\n    /// @param _funder The initial funder of the deposit\n    function extendDeposit(\n        bytes32 _depositId,\n        uint256 _seconds,\n        address _funder\n    ) external virtual onlyDepositManager nonReentrant returns (uint256) {\n        require(status == OpenQDefinitions.OPEN, Errors.CONTRACT_IS_CLOSED);\n        require(!refunded[_depositId], Errors.DEPOSIT_ALREADY_REFUNDED);\n        require(funder[_depositId] == _funder, Errors.CALLER_NOT_FUNDER);\n\n        if (\n            block.timestamp > depositTime[_depositId] + expiration[_depositId]\n        ) {\n            expiration[_depositId] =\n                block.timestamp -\n                depositTime[_depositId] +\n                _seconds;\n        } else {\n            expiration[_depositId] = expiration[_depositId] + _seconds;\n        }\n\n        return expiration[_depositId];\n    }\n\n    /// @notice Transfers NFT from bounty address to _payoutAddress\n    /// @param _payoutAddress The destination address for the NFT\n    /// @param _depositId The payout address of the bounty\n    function claimNft(address _payoutAddress, bytes32 _depositId)\n        external\n        virtual\n        onlyClaimManager\n        nonReentrant\n    {\n        _transferNft(\n            tokenAddress[_depositId],\n            _payoutAddress,\n            tokenId[_depositId]\n        );\n    }\n\n    /// @notice Sets the funding goal\n    /// @param _fundingToken Token address for funding goal\n    /// @param _fundingGoal Token volume for funding goal\n    function setFundingGoal(address _fundingToken, uint256 _fundingGoal)\n        external\n        virtual\n        onlyOpenQ\n    {\n        fundingGoal = _fundingGoal;\n        fundingToken = _fundingToken;\n        hasFundingGoal = true;\n    }\n\n    /// @notice Whether or not KYC is required to fund and claim the bounty\n    /// @param _kycRequired Whether or not KYC is required to fund and claim the bounty\n    function setKycRequired(bool _kycRequired) external virtual onlyOpenQ {\n        kycRequired = _kycRequired;\n    }\n\n    /// @notice Whether or not the Bounty is invoiceRequired\n    /// @param _invoiceRequired Whether or not the Bounty is invoiceRequired\n    function setInvoiceRequired(bool _invoiceRequired)\n        external\n        virtual\n        onlyOpenQ\n    {\n        invoiceRequired = _invoiceRequired;\n    }\n\n    /// @notice Whether or not KYC is required to fund and claim the bounty\n    /// @param _supportingDocumentsRequired Whether or not KYC is required to fund and claim the bounty\n    function setSupportingDocumentsRequired(bool _supportingDocumentsRequired)\n        external\n        virtual\n        onlyOpenQ\n    {\n        supportingDocumentsRequired = _supportingDocumentsRequired;\n    }\n\n    /// @notice Transfers _volume of both ERC20 or protocol token to _payoutAddress\n    /// @param _tokenAddress Address of an ERC20 or Zero Address for protocol token\n    /// @param _volume Volume to transfer\n    /// @param _payoutAddress Destination address\n    function _transferToken(\n        address _tokenAddress,\n        uint256 _volume,\n        address _payoutAddress\n    ) internal virtual {\n        if (_tokenAddress == address(0)) {\n            _transferProtocolToken(_payoutAddress, _volume);\n        } else {\n            _transferERC20(_tokenAddress, _payoutAddress, _volume);\n        }\n    }\n\n    /// @notice Receives _volume of ERC20 at _tokenAddress from _funder to bounty address\n    /// @param _tokenAddress The ERC20 token address\n    /// @param _funder The funder of the bounty\n    /// @param _volume The volume of token to transfer\n    function _receiveERC20(\n        address _tokenAddress,\n        address _funder,\n        uint256 _volume\n    ) internal virtual returns (uint256) {\n        uint256 balanceBefore = getERC20Balance(_tokenAddress);\n        IERC20Upgradeable token = IERC20Upgradeable(_tokenAddress);\n        token.safeTransferFrom(_funder, address(this), _volume);\n        uint256 balanceAfter = getERC20Balance(_tokenAddress);\n        require(\n            balanceAfter >= balanceBefore,\n            Errors.TOKEN_TRANSFER_IN_OVERFLOW\n        );\n\n        //// The reason we take the balanceBefore and balanceAfter rather than the raw volume\n        /// is because certain ERC20 contracts ( e.g. USDT) take fees on transfers.\n        /// Therefore the volume received after transferFrom can be lower than the raw volume sent by the sender\n        return balanceAfter - balanceBefore;\n    }\n\n    /// @notice Transfers _volume of ERC20 at _tokenAddress from bounty address to _funder\n    /// @param _tokenAddress The ERC20 token address\n    /// @param _payoutAddress The destination address of the funds\n    /// @param _volume The volume of token to transfer\n    function _transferERC20(\n        address _tokenAddress,\n        address _payoutAddress,\n        uint256 _volume\n    ) internal virtual {\n        IERC20Upgradeable token = IERC20Upgradeable(_tokenAddress);\n        token.safeTransfer(_payoutAddress, _volume);\n    }\n\n    /// @notice Transfers _volume of protocol token from bounty address to _payoutAddress\n    /// @param _payoutAddress The destination address of the funds\n    /// @param _volume The volume of token to transfer\n    function _transferProtocolToken(address _payoutAddress, uint256 _volume)\n        internal\n        virtual\n    {\n        payable(_payoutAddress).sendValue(_volume);\n    }\n\n    /// @notice Receives NFT of _tokenId on _tokenAddress from _funder to bounty address\n    /// @param _tokenAddress The ERC721 token address\n    /// @param _sender The sender of the NFT\n    /// @param _tokenId The tokenId\n    function _receiveNft(\n        address _tokenAddress,\n        address _sender,\n        uint256 _tokenId\n    ) internal virtual {\n        IERC721Upgradeable nft = IERC721Upgradeable(_tokenAddress);\n        nft.safeTransferFrom(_sender, address(this), _tokenId);\n    }\n\n    /// @notice Transfers NFT of _tokenId on _tokenAddress from bounty address to _payoutAddress\n    /// @param _tokenAddress The ERC721 token address\n    /// @param _payoutAddress The sender of the NFT\n    /// @param _tokenId The tokenId\n    function _transferNft(\n        address _tokenAddress,\n        address _payoutAddress,\n        uint256 _tokenId\n    ) internal virtual {\n        IERC721Upgradeable nft = IERC721Upgradeable(_tokenAddress);\n        nft.safeTransferFrom(address(this), _payoutAddress, _tokenId);\n    }\n\n    /// @notice Generates a unique deposit ID from bountyId and the current length of deposits\n    function _generateDepositId() internal view virtual returns (bytes32) {\n        return keccak256(abi.encode(bountyId, deposits.length));\n    }\n\n    /// TRANSFER HELPERS\n\n    /// @notice Returns token balance for both ERC20 or protocol token\n    /// @param _tokenAddress Address of an ERC20 or Zero Address for protocol token\n    function getTokenBalance(address _tokenAddress)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        if (_tokenAddress == address(0)) {\n            return address(this).balance;\n        } else {\n            return getERC20Balance(_tokenAddress);\n        }\n    }\n\n    /// @notice Returns the ERC20 balance for this bounty address\n    /// @param _tokenAddress The ERC20 token address\n    /// @return balance The ERC20 balance for this bounty address\n    function getERC20Balance(address _tokenAddress)\n        public\n        view\n        virtual\n        returns (uint256 balance)\n    {\n        IERC20Upgradeable token = IERC20Upgradeable(_tokenAddress);\n        return token.balanceOf(address(this));\n    }\n\n    /// @notice Returns an array of all deposits (ERC20, protocol token, and NFT) for this bounty\n    /// @return deposits The array of deposits including ERC20, protocol token, and NFT\n    function getDeposits() external view virtual returns (bytes32[] memory) {\n        return deposits;\n    }\n\n    /// @notice Returns an array of ONLY NFT deposits for this bounty\n    /// @return nftDeposits The array of NFT deposits\n    function getNftDeposits() external view virtual returns (bytes32[] memory) {\n        return nftDeposits;\n    }\n\n    /// @notice Returns an array of all ERC20 token addresses which have funded this bounty\n    /// @return tokenAddresses An array of all ERC20 token addresses which have funded this bounty\n    function getTokenAddresses()\n        public\n        view\n        virtual\n        returns (address[] memory)\n    {\n        return tokenAddresses.values();\n    }\n\n    /// @notice Returns the total number of unique tokens deposited on the bounty\n    /// @return tokenAddressesCount The length of the array of all ERC20 token addresses which have funded this bounty\n    function getTokenAddressesCount() external view virtual returns (uint256) {\n        return tokenAddresses.values().length;\n    }\n\n    /// @notice Returns the amount of locked tokens (of a specific token) on a bounty address, only available for claims but not for refunds\n    /// @param _depositId The depositId that determines which token is being looked at\n    /// @return uint256\n    function getLockedFunds(address _depositId)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        uint256 lockedFunds;\n        bytes32[] memory depList = this.getDeposits();\n        for (uint256 i = 0; i < depList.length; i++) {\n            if (\n                block.timestamp <\n                depositTime[depList[i]] + expiration[depList[i]] &&\n                tokenAddress[depList[i]] == _depositId\n            ) {\n                lockedFunds += volume[depList[i]];\n            }\n        }\n\n        return lockedFunds;\n    }\n}"
    },
    {
      "filename": "contracts/Bounty/Implementations/BountyCore.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.17;\n\nimport '../Storage/BountyStorageCore.sol';\n\n/// @title BountyCore\n/// @author FlacoJones\n/// @notice Shared methods common to all bounty types\n/// @dev BountyCore -> BountyStorageCore -> Core Dependencies (OZ + Custom)\nabstract contract BountyCore is BountyStorageCore {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using AddressUpgradeable for address payable;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    /// @notice Creates a deposit and transfers tokens from msg.sender to this contract\n    /// @param _funder The funder's address\n    /// @param _tokenAddress The ERC20 token address (ZeroAddress if funding with protocol token)\n    /// @param _volume The volume of token to transfer\n    /// @param _expiration The duration until the deposit becomes refundable\n    /// @return (depositId, volumeReceived) Returns the deposit id and the amount transferred to bounty\n    function receiveFunds(\n        address _funder,\n        address _tokenAddress,\n        uint256 _volume,\n        uint256 _expiration\n    )\n        external\n        payable\n        virtual\n        onlyDepositManager\n        nonReentrant\n        returns (bytes32, uint256)\n    {\n        require(_volume != 0, Errors.ZERO_VOLUME_SENT);\n        require(_expiration > 0, Errors.EXPIRATION_NOT_GREATER_THAN_ZERO);\n        require(status == OpenQDefinitions.OPEN, Errors.CONTRACT_IS_CLOSED);\n\n        bytes32 depositId = _generateDepositId();\n\n        uint256 volumeReceived;\n        if (_tokenAddress == address(0)) {\n            volumeReceived = msg.value;\n        } else {\n            volumeReceived = _receiveERC20(_tokenAddress, _funder, _volume);\n        }\n\n        funder[depositId] = _funder;\n        tokenAddress[depositId] = _tokenAddress;\n        volume[depositId] = volumeReceived;\n        depositTime[depositId] = block.timestamp;\n        expiration[depositId] = _expiration;\n        isNFT[depositId] = false;\n\n        deposits.push(depositId);\n        tokenAddresses.add(_tokenAddress);\n\n        return (depositId, volumeReceived);\n    }\n\n    /// @notice Transfers volume of deposit or NFT of deposit from bounty to funder\n    /// @param _depositId The deposit to refund\n    /// @param _funder The initial funder of the deposit\n    /// @param _volume The volume to be refunded (only relevant if deposit is not an NFT, otherwise is zero)\n    function refundDeposit(\n        bytes32 _depositId,\n        address _funder,\n        uint256 _volume\n    ) external virtual onlyDepositManager nonReentrant {\n        require(!refunded[_depositId], Errors.DEPOSIT_ALREADY_REFUNDED);\n        require(funder[_depositId] == _funder, Errors.CALLER_NOT_FUNDER);\n        require(\n            block.timestamp >= depositTime[_depositId] + expiration[_depositId],\n            Errors.PREMATURE_REFUND_REQUEST\n        );\n\n        refunded[_depositId] = true;\n\n        if (tokenAddress[_depositId] == address(0)) {\n            _transferProtocolToken(funder[_depositId], _volume);\n        } else if (isNFT[_depositId]) {\n            _transferNft(\n                tokenAddress[_depositId],\n                funder[_depositId],\n                tokenId[_depositId]\n            );\n        } else {\n            _transferERC20(\n                tokenAddress[_depositId],\n                funder[_depositId],\n                _volume\n            );\n        }\n    }\n\n    /// @notice Extends deposit duration\n    /// @param _depositId The deposit to extend\n    /// @param _seconds Number of seconds to extend deposit\n    /// @param _funder The initial funder of the deposit\n    function extendDeposit(\n        bytes32 _depositId,\n        uint256 _seconds,\n        address _funder\n    ) e"
    }
  ]
}