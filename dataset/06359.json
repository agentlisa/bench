{
  "Title": "[M-03] Impossibility to change `safeCollateralRatio`",
  "Content": "\n### Lines of code\n\n<https://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/pools/base/LybraPeUSDVaultBase.sol#L18>\n\n### Impact\n\nBecause of `vaultType` variable is internal `vaultType` staticcall to vaults from the configurator will revert, so it makes it impossible to change `safeCollateralRatio`. It may be critical when market conditions will change, something happens with ETH.\n\n### Proof of Concept\n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {GovernanceTimelock} from \"@lybra/governance/GovernanceTimelock.sol\";\nimport {LybraStETHDepositVault} from \"@lybra/pools/LybraStETHVault.sol\";\nimport {Configurator} from \"@lybra/configuration/LybraConfigurator.sol\";\nimport {mockEtherPriceOracle} from \"@mocks/mockEtherPriceOracle.sol\";\nimport {mockCurve} from \"@mocks/mockCurve.sol\";\n\n/* remappings used\n@lybra=contracts/lybra/\n@mocks=contracts/mocks/\n */\ncontract LybraV2SafeCollateral is Test {\n\n    GovernanceTimelock govTimeLock;\n    mockEtherPriceOracle oracle;\n    mockCurve curve;\n    Configurator configurator;\n    LybraStETHDepositVault stETHVault;\n    address owner = address(7);\n    // admins && executers of GovernanceTimelock\n    address[] govTimelockArr;\n    IERC20 stETH = IERC20(0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84);\n\n    function setUp() public {\n        vm.startPrank(owner);\n        oracle = new mockEtherPriceOracle();\n        govTimelockArr.push(owner);\n        govTimeLock = new GovernanceTimelock(\n            1,\n            govTimelockArr,\n            govTimelockArr,\n            owner\n        );\n        curve = new mockCurve();\n        //  _dao , _curvePool\n        configurator = new Configurator(address(govTimeLock), address(curve));\n\n        stETHVault = new LybraStETHDepositVault(\n            address(configurator),\n            address(stETH),\n            address(oracle)\n        );\n        vm.stopPrank();\n    }\n\n    function testSafeCollateral() public {\n        vm.startPrank(owner);\n        configurator.setSafeCollateralRatio(address(stETHVault), 165 * 1e18);\n    }\n    \n\n}\n```\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nChange getter function in `LybraConfigurator`:\n\n```solidity\ninterface IVault {\n    function getVaultType() external view returns (uint8);\n}\n...\n...\nif(IVault(pool).getVaultType() == 0) {\n```\n\n<https://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/configuration/LybraConfigurator.sol#L29>\n\n<https://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/configuration/LybraConfigurator.sol#L199>\n\n### Assessed type\n\nDoS\n\n**[LybraFinance confirmed](https://github.com/code-423n4/2023-06-lybra-findings/issues/882#issuecomment-1639584191)**\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-06-lybra",
  "Code": [
    {
      "filename": "contracts/lybra/pools/base/LybraPeUSDVaultBase.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\nimport \"../../interfaces/Iconfigurator.sol\";\nimport \"../../interfaces/IPeUSD.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IPriceFeed {\n    function fetchPrice() external returns (uint256);\n}\n\nabstract contract LybraPeUSDVaultBase {\n    IPeUSD public immutable PeUSD;\n    IERC20 public immutable collateralAsset;\n    Iconfigurator public immutable configurator;\n    uint256 public poolTotalPeUSDCirculation;\n    uint8 immutable vaultType = 1;\n    IPriceFeed immutable etherOracle;\n\n    mapping(address => uint256) public depositedAsset;\n    mapping(address => uint256) borrowed;\n    mapping(address => uint256) feeStored;\n    mapping(address => uint256) feeUpdatedAt;\n\n    event DepositEther(address indexed onBehalfOf, address asset, uint256 etherAmount, uint256 assetAmount, uint256 timestamp);\n\n    event DepositAsset(address indexed onBehalfOf, address asset, uint256 amount, uint256 timestamp);\n    event WithdrawAsset(address sponsor, address indexed onBehalfOf, address asset, uint256 amount, uint256 timestamp);\n    event Mint(address sponsor, address indexed onBehalfOf, uint256 amount, uint256 timestamp);\n    event Burn(address sponsor, address indexed onBehalfOf, uint256 amount, uint256 timestamp);\n    event LiquidationRecord(address provider, address keeper, address indexed onBehalfOf, uint256 eusdamount, uint256 LiquidateAssetAmount, uint256 keeperReward, bool superLiquidation, uint256 timestamp);\n\n    event RigidRedemption(address indexed caller, address indexed provider, uint256 peusdAmount, uint256 assetAmount, uint256 timestamp);\n    event FeeDistribution(address indexed feeAddress, uint256 feeAmount, uint256 timestamp);\n\n    constructor(address _peusd, address _etherOracle, address _collateral, address _configurator) {\n        PeUSD = IPeUSD(_peusd);\n        collateralAsset = IERC20(_collateral);\n        configurator = Iconfigurator(_configurator);\n        etherOracle = IPriceFeed(_etherOracle);\n    }\n\n    function totalDepositedAsset() public view returns (uint256) {\n        return collateralAsset.balanceOf(address(this));\n    }\n\n    function depositEtherToMint(uint256 mintAmount) external payable virtual;\n\n    /**\n     * @notice Deposit staked ETH, update the interest distribution, can mint PeUSD directly\n     * Emits a `DepositAsset` event.\n     *\n     * Requirements:\n     * - `assetAmount` Must be higher than 0.\n     * - `mintAmount` Send 0 if doesn't mint PeUSD\n     */\n    function depositAssetToMint(uint256 assetAmount, uint256 mintAmount) external virtual {\n        require(assetAmount >= 1 ether, \"Deposit should not be less than 1 collateral asset.\");\n        uint256 preBalance = collateralAsset.balanceOf(address(this));\n        collateralAsset.transferFrom(msg.sender, address(this), assetAmount);\n        require(collateralAsset.balanceOf(address(this)) >= preBalance + assetAmount, \"\");\n\n        depositedAsset[msg.sender] += assetAmount;\n        if (mintAmount > 0) {\n            uint256 assetPrice = getAssetPrice();\n            _mintPeUSD(msg.sender, msg.sender, mintAmount, assetPrice);\n        }\n        emit DepositAsset(msg.sender, address(collateralAsset), assetAmount, block.timestamp);\n    }\n\n    /**\n     * @notice Withdraw collateral assets to an address\n     * Emits a `WithdrawAsset` event.\n     *\n     * Requirements:\n     * - `onBehalfOf` cannot be the zero address.\n     * - `amount` Must be higher than 0.\n     *\n     * @dev Withdraw stETH. Check userâ€™s collateral ratio after withdrawal, should be higher than `safeCollateralRatio`\n     */\n    function withdraw(address onBehalfOf, uint256 amount) external virtual {\n        require(onBehalfOf != address(0), \"TZA\");\n        require(amount > 0, \"ZA\");\n        _withdraw(msg.sender, onBehalfOf, amount);\n    }\n\n    /**\n     * @notice The mint amount number of PeUSD is minted to the address\n     * Emits a `Mint` event.\n     *\n     * Requirements:\n     * - `onBehalfOf` cannot be the zero address.\n     * - `amount` Must be higher than 0. Individual mint amount shouldn't surpass 10% when the circulation reaches 10_000_000\n     */\n    function mint(address onBehalfOf, uint256 amount) external virtual {\n        require(onBehalfOf != address(0), \"TZA\");\n        require(amount > 0, \"ZA\");\n        _mintPeUSD(msg.sender, onBehalfOf, amount, getAssetPrice());\n    }\n\n    /**\n     * @notice Burn the amount of PeUSD and payback the amount of minted PeUSD\n     * Emits a `Burn` event.\n     * Requirements:\n     * - `onBehalfOf` cannot be the zero address.\n     * - `amount` Must be higher than 0.\n     * @dev Calling the internal`_repay`function.\n     */\n    function burn(address onBehalfOf, uint256 amount) external virtual {\n        require(onBehalfOf != address(0), \"TZA\");\n        require(amount > 0, \"ZA\");\n        _repay(msg.sender, onBehalfOf, amount);\n    }\n\n    /**\n     * @notice When overallCollateralRatio is above 150%, Keeper liquidates borrowers whose collateral ratio is below badCollateralRatio, using PeUSD provided by Liquidation Provider.\n     *\n     * Requirements:\n     * - onBehalfOf Collateral Ratio should be below badCollateralRatio\n     * - assetAmount should be less than 50% of collateral\n     * - provider should authorize Lybra to utilize PeUSD\n     * @dev After liquidation, borrower's debt is reduced by assetAmount * assetPrice, collateral is reduced by the assetAmount corresponding to 110% of the value. Keeper gets keeperRatio / 110 of Liquidation Reward and Liquidator gets the remaining stETH.\n     */\n    function liquidation(address provider, address onBehalfOf, uint256 assetAmount) external virtual {\n        uint256 assetPrice = getAssetPrice();\n        uint256 onBehalfOfCollateralRatio = (depositedAsset[onBehalfOf] * assetPrice * 100) / getBorrowedOf(onBehalfOf);\n        require(onBehalfOfCollateralRatio < configurator.getBadCollateralRatio(address(this)), \"Borrowers collateral ratio should below badCollateralRatio\");\n\n        require(assetAmount * 2 <= depositedAsset[onBehalfOf], \"a max of 50% collateral can be liquidated\");\n        require(PeUSD.allowance(provider, address(this)) > 0, \"provider should authorize to provide liquidation EUSD\");\n        uint256 peusdAmount = (assetAmount * assetPrice) / 1e18;\n\n        _repay(provider, onBehalfOf, peusdAmount);\n        uint256 reducedAsset = (assetAmount * 11) / 10;\n        depositedAsset[onBehalfOf] -= reducedAsset;\n        uint256 reward2keeper;\n        if (provider == msg.sender) {\n            collateralAsset.transfer(msg.sender, reducedAsset);\n        } else {\n            reward2keeper = (reducedAsset * configurator.vaultKeeperRatio(address(this))) / 110;\n            collateralAsset.transfer(provider, reducedAsset - reward2keeper);\n            collateralAsset.transfer(msg.sender, reward2keeper);\n        }\n        emit LiquidationRecord(provider, msg.sender, onBehalfOf, peusdAmount, reducedAsset, reward2keeper, false, block.timestamp);\n    }\n\n    /**\n     * @notice Choose a Redemption Provider, Rigid Redeem `peusdAmount` of EUSD and get 1:1 value of stETH\n     * Emits a `RigidRedemption` event.\n     *\n     * *Requirements:\n     * - `provider` must be a Redemption Provider\n     * - `provider`debt must equal to or above`peusdAmount`\n     * @dev Service Fee for rigidRedemption `redemptionFee` is set to 0.5% by default, can be revised by DAO.\n     */\n    function rigidRedemption(address provider, uint256 peusdAmount) external virtual {\n        require(configurator.isRedemptionProvider(provider), \"provider is not a RedemptionProvider\");\n        require(borrowed[provider] >= peusdAmount, \"peusdAmount cannot surpass providers debt\");\n        uint256 assetPrice = getAssetPrice();\n        uint256 providerCollateralRatio = (depositedAsset[provider] * assetPrice * 100) / borrowed[provider];\n        require(providerCollateralRatio >= 100 * 1e18, \"provider's collateral ratio should more than 100%\");\n        _repay(msg.sender, provider, peusdAmount);\n        uint256 collateralAmount = (((peusdAmount * 1e18) / assetPrice) * (10000 - configurator.redemptionFee())) / 10000;\n        depositedAsset[provider] -= collateralAmount;\n        collateralAsset.transfer(msg.sender, collateralAmount);\n        emit RigidRedemption(msg.sender, provider, peusdAmount, collateralAmount, block.timestamp);\n    }\n\n    /**\n     * @dev Refresh LBR reward before adding providers debt. Refresh Lybra generated service fee before adding totalSupply. Check providers collateralRatio cannot below `safeCollateralRatio`after minting.\n     */\n    function _mintPeUSD(address _provider, address _onBehalfOf, uint256 _mintAmount, uint256 _assetPrice) internal virtual {\n        require(poolTotalPeUSDCirculation + _mintAmount <= configurator.mintVaultMaxSupply(address(this)), \"ESL\");\n        _updateFee(_provider);\n\n        try configurator.refreshMintReward(_provider) {} catch {}\n\n        borrowed[_provider] += _mintAmount;\n\n        PeUSD.mint(_onBehalfOf, _mintAmount);\n        poolTotalPeUSDCirculation += _mintAmount;\n        _checkHealth(_provider, _assetPrice);\n        emit Mint(_provider, _onBehalfOf, _mintAmount, block.timestamp);\n    }\n\n    /**\n     * @notice Burn _provideramount PeUSD to payback minted PeUSD for _onBehalfOf.\n     *\n     * @dev Refresh LBR reward before reducing providers debt. Refresh Lybra generated service fee before reducing totalPeUSDCirculation.\n     */\n    function _repay(address _provider, address _onBehalfOf, uint256 _amount) internal virtual {\n        try configurator.refreshMintReward(_onBehalfOf) {} catch {}\n        _updateFee(_onBehalfOf);\n        uint256 totalFee = feeStored[_onBehalfOf];\n        uint256 amount = borrowed[_onBehalfOf] + totalFee >= _amount ? _amount : borrowed[_onBehalfOf] + totalFee;\n        if(amount >= totalFee) {\n            feeStored[_onBehalfOf] = 0;\n            PeUSD.transferFrom(_provider, address(configurator), totalFee);\n            PeUSD.burn(_provider, amount - totalFee);\n        } else {\n            feeStored[_onBehalfOf] = totalFee - amount;\n            PeUSD.transferFrom(_provider, address(configurator), amount);\n        }\n        try configurator.distributeRewards() {} catch {}\n        borrowed[_onBehalfOf] -= amount;\n        poolTotalPeUSDCirculation -= amount;\n\n        emit Burn(_provider, _onBehalfOf, amount, block.timestamp);\n    }\n\n    function _withdraw(address _provider, address _onBehalfOf, uint256 _amount) internal {\n        require(depositedAsset[_provider] >= _amount, \"Withdraw amount exceeds deposited amount.\");\n        depositedAsset[_provider] -= _amount;\n        collateralAsset.transfer(_onBehalfOf, _amount);\n        if (getBorrowedOf(_provider) > 0) {\n            _checkHealth(_provider, getAssetPrice());\n        }\n        emit WithdrawAsset(_provider, address(collateralAsset), _onBehalfOf, _amount, block.timestamp);\n    }\n\n    /**\n     * @dev Get USD value of current collateral asset and minted EUSD through price oracle / Collateral asset USD value must higher than safe Collateral Ratio.\n     */\n    function _checkHealth(address user, uint256 price) internal view {\n        if (((depositedAsset[user] * price * 100) / getBorrowedOf(user)) < configurator.getSafeCollateralRatio(address(this))) \n            revert(\"collateralRatio is Below safeCollateralRatio\");\n    }\n\n    function _updateFee(address user) internal {\n        if (block.timestamp > feeUpdatedAt[user]) {\n            feeStored[user] += _newFee(user);\n            feeUpdatedAt[user] = block.timestamp;\n        }\n    }\n\n    function _newFee(address user) internal view returns (uint256) {\n        return (borrowed[user] * configurator.vaultMintFeeApy(address(this)) * (block.timestamp - feeUpdatedAt[user])) / (86400 * 365) / 10000;\n    }\n\n    /**\n     * @dev Return USD value of current ETH through Liquity PriceFeed Contract.\n     */\n    function _etherPrice() internal returns (uint256) {\n        return etherOracle.fetchPrice();\n    }\n\n    /**\n     * @dev Returns the current borrowing amount for the user, including borrowed shares and accumulated fees.\n     * @param user The address of the user.\n     * @return The total borrowing amount for the user.\n     */\n    function getBorrowedOf(address user) public view returns (uint256) {\n        return borrowed[user] + feeStored[user] + _newFee(user);\n    }\n\n    function getPoolTotalPeUSDCirculation() public view returns (uint256) {\n        return poolTotalPeUSDCirculation;\n    }\n\n    function getAsset() external view returns (address) {\n        return address(collateralAsset);\n    }\n\n    function getVaultType() external pure returns (uint8) {\n        return vaultType;\n    }\n\n    function getAssetPrice() public virtual returns (uint256);\n}"
    },
    {
      "filename": "contracts/lybra/configuration/LybraConfigurator.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/**\n * @title Lybra Protocol V2 Configurator Contract\n * @dev The Configurator contract is used to set various parameters and control functionalities of the Lybra Protocol. It is based on OpenZeppelin's Proxy and AccessControl libraries, allowing the DAO to control contract upgrades. There are three types of governance roles:\n * * DAO: A time-locked contract initiated by esLBR voting, with a minimum effective period of 14 days. After the vote is passed, only the developer can execute the action.\n * * TIMELOCK: A time-locked contract controlled by the developer, with a minimum effective period of 2 days.\n * * ADMIN: A multisignature account controlled by the developer.\n * All setting functions have three levels of calling permissions:\n * * onlyRole(DAO): Only callable by the DAO for governance purposes.\n * * checkRole(TIMELOCK): Callable by both the DAO and the TIMELOCK contract.\n * * checkRole(ADMIN): Callable by all governance roles.\n */\n\npragma solidity ^0.8.17;\n\nimport \"../interfaces/IGovernanceTimelock.sol\";\nimport \"../interfaces/IEUSD.sol\";\n\ninterface IProtocolRewardsPool {\n    function notifyRewardAmount(uint256 amount, uint256 tokenType) external;\n}\n\ninterface IeUSDMiningIncentives {\n    function refreshReward(address user) external;\n}\n\ninterface IVault {\n    function vaultType() external view returns (uint8);\n}\n\ninterface ICurvePool{\n    function get_dy_underlying(int128 i, int128 j, uint256 dx) external view returns (uint256);\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy) external returns(uint256);\n}\n\ncontract Configurator {\n    mapping(address => bool) public mintVault;\n    mapping(address => uint256) public mintVaultMaxSupply;\n    mapping(address => bool) public vaultMintPaused;\n    mapping(address => bool) public vaultBurnPaused;\n    mapping(address => uint256) vaultSafeCollateralRatio;\n    mapping(address => uint256) vaultBadCollateralRatio;\n    mapping(address => uint256) public vaultMintFeeApy;\n    mapping(address => uint256) public vaultKeeperRatio;\n    mapping(address => bool) redemptionProvider;\n    mapping(address => bool) public tokenMiner;\n\n    uint256 public redemptionFee = 50;\n    IGovernanceTimelock public GovernanceTimelock;\n\n    IeUSDMiningIncentives public eUSDMiningIncentives;\n    IProtocolRewardsPool public lybraProtocolRewardsPool;\n    IEUSD public EUSD;\n    IEUSD public peUSD;\n    uint256 public flashloanFee = 500;\n    // Limiting the maximum percentage of eUSD that can be cross-chain transferred to L2 in relation to the total supply.\n    uint256 maxStableRatio = 5_000;\n    address public stableToken;\n    ICurvePool public curvePool;\n    bool public premiumTradingEnabled;\n\n    event RedemptionFeeChanged(uint256 newSlippage);\n    event SafeCollateralRatioChanged(address indexed pool, uint256 newRatio);\n    event RedemptionProvider(address indexed user, bool status);\n    event ProtocolRewardsPoolChanged(address indexed pool, uint256 timestamp);\n    event EUSDMiningIncentivesChanged(address indexed pool, uint256 timestamp);\n    event BorrowApyChanged(address indexed pool, uint256 newApy);\n    event KeeperRatioChanged(address indexed pool, uint256 newSlippage);\n    event tokenMinerChanges(address indexed pool, bool status);\n\n    /// @notice Emitted when the fees for flash loaning a token have been updated\n    /// @param fee The new fee for this token as a percentage and multiplied by 100 to avoid decimals (for example, 10% is 10_00)\n    event FlashloanFeeUpdated(uint256 fee);\n\n    bytes32 public constant DAO = keccak256(\"DAO\");\n    bytes32 public constant TIMELOCK = keccak256(\"TIMELOCK\");\n    bytes32 public constant ADMIN = keccak256(\"ADMIN\");\n\n    constructor(address _dao, address _curvePool) {\n        GovernanceTimelock = IGovernanceTimelock(_dao);\n        curvePool = ICurvePool(_curvePool);\n    }\n\n    modifier onlyRole(bytes32 role) {\n        GovernanceTimelock.checkOnlyRole(role, msg.sender);\n        _;\n    }\n\n    modifier checkRole(bytes32 role) {\n        GovernanceTimelock.checkRole(role, msg.sender);\n        _;\n    }\n\n    /**\n     * @notice Initializes the eUSD and peUSD address. This function can only be executed once.\n     */\n    function initToken(address _eusd, address _peusd) external onlyRole(DAO) {\n        if (address(EUSD) == address(0)) EUSD = IEUSD(_eusd);\n        if (address(peUSD) == address(0)) peUSD = IEUSD(_peusd);\n    }\n\n    /**\n     * @notice Controls the activation of a specific eUSD vault.\n     * @param pool The address of the asset pool.\n     * @param isActive A boolean indicating whether to activate or deactivate the vault.\n     * @dev This function can only be called by the DAO.\n     */\n    function setMintVault(address pool, bool isActive) external onlyRole(DAO) {\n        mintVault[pool] = isActive;\n    }\n\n    /**\n     * @notice Controls the minting limit of eUSD for an asset pool.\n     * @param pool The address of the asset pool.\n     * @param maxSupply The maximum amount of eUSD that can be minted for the asset pool.\n     * @dev This function can only be called by the DAO.\n     */\n    function setMintVaultMaxSupply(address pool, uint256 maxSupply) external onlyRole(DAO) {\n        mintVaultMaxSupply[pool] = maxSupply;\n    }\n\n    /**\n     * @notice  badCollateralRatio can be decided by DAO,starts at 130%\n     */\n    function setBadCollateralRatio(address pool, uint256 newRatio) external onlyRole(DAO) {\n        require(newRatio >= 130 * 1e18 && newRatio <= 150 * 1e18 && newRatio <= vaultSafeCollateralRatio[pool] + 1e19, \"LNA\");\n        vaultBadCollateralRatio[pool] = newRatio;\n        emit SafeCollateralRatioChanged(pool, newRatio);\n    }\n\n    /**\n     * @notice Sets the address of the protocol rewards pool.\n     * @param addr The new address of the protocol rewards pool.\n     * @dev This function can only be called by accounts with TIMELOCK or higher privilege.\n     */\n    function setProtocolRewardsPool(address addr) external checkRole(TIMELOCK) {\n        lybraProtocolRewardsPool = IProtocolRewardsPool(addr);\n        emit ProtocolRewardsPoolChanged(addr, block.timestamp);\n    }\n\n    /**\n     * @notice Sets the address of the eUSDMiningIncentives pool.\n     * @param addr The new address of the eUSDMiningIncentives pool.\n     * @dev This function can only be called by accounts with TIMELOCK or higher privilege.\n     */\n    function setEUSDMiningIncentives(address addr) external checkRole(TIMELOCK) {\n        eUSDMiningIncentives = IeUSDMiningIncentives(addr);\n        emit EUSDMiningIncentivesChanged(addr, block.timestamp);\n    }\n\n    /**\n     * @notice Enables or disables the repayment functionality for a asset pool.\n     * @param pool The address of the pool.\n     * @param isActive Boolean value indicating whether repayment is active or paused.\n     * @dev This function can only be called by accounts with TIMELOCK or higher privilege.\n     */\n    function setvaultBurnPaused(address pool, bool isActive) external checkRole(TIMELOCK) {\n        vaultBurnPaused[pool] = isActive;\n    }\n\n    /**\n     * @notice Sets the status of premium trading.\n     * @param isActive Boolean value indicating whether premium trading is enabled or disabled.\n     * @dev This function can only be called by accounts with TIMELOCK or higher privilege.\n     */\n    function setPremiumTradingEnabled(bool isActive) external checkRole(TIMELOCK) {\n        premiumTradingEnabled = isActive;\n    }\n\n    /**\n     * @notice Enables or disables the mint functionality for a asset pool.\n     * @param pool The address of the pool.\n     * @param isActive Boolean value indicating whether minting is active or paused.\n     * @dev This function can only be called by accounts with ADMIN or higher privilege.\n     */\n    function setvaultMintPaused(address pool, bool isActive) external checkRole(ADMIN) {\n        vaultMintPaused[pool] = isActive;\n    }\n\n    /**\n     * @notice Sets the redemption fee.\n     * @param newFee The new fee to be set.\n     * @notice The fee cannot exceed 5%.\n     */\n    function setRedemptionFee(uint256 newFee) external checkRole(TIMELOCK) {\n        require(newFee <= 500, \"Max Redemption Fee is 5%\");\n        redemptionFee = newFee;\n        emit RedemptionFeeChanged(newFee);\n    }\n\n    /**\n     * @notice  safeCollateralRatio can be decided by TIMELOCK.\n     * The eUSD vault requires a minimum safe collateral rate of 160%,\n     * On the other hand, the PeUSD vault requires a safe collateral rate at least 10% higher\n     * than the liquidation collateral rate, providing an additional buffer to protect against liquidation risks.\n     */\n    function setSafeCollateralRatio(address pool, uint256 newRatio) external checkRole(TIMELOCK) {\n        if(IVault(pool).vaultType() == 0) {\n            require(newRatio >= 160 * 1e18, \"eUSD vault safe collateralRatio should more than 160%\");\n        } else {\n            require(newRatio >= vaultBadCollateralRatio[pool] + 1e19, \"PeUSD vault safe collateralRatio should more than bad collateralRatio\");\n        }\n        vaultSafeCollateralRatio[pool] = newRatio;\n        emit SafeCollateralRatioChanged(pool, newRatio);\n    }\n\n    /**\n     * @notice  Set the borrowing annual percentage yield (APY) for a asset pool.\n     * @param pool The address of the pool to set the borrowing APY for.\n     * @param newApy The new borrowing APY to set, limited to a maximum of 2%.\n     */\n    function setBorrowApy(address pool, uint256 newApy) external checkRole(TIMELOCK) {\n        require(newApy <= 200, \"Borrow APY cannot exceed 2%\");\n        vaultMintFeeApy[pool] = newApy;\n        emit BorrowApyChanged(pool, newApy);\n    }\n\n    /**\n     * @notice Set the reward ratio for the liquidator after liquidation.\n     * @param pool The address of the pool to set the reward ratio for.\n     * @param newRatio The new reward ratio to set, limited to a maximum of 5%.\n     */\n    function setKeeperRatio(address pool,uint256 newRatio) external checkRole(TIMELOCK) {\n        require(newRatio <= 5, \"Max Keeper reward is 5%\");\n        vaultKeeperRatio[pool] = newRatio;\n        emit KeeperRatioChanged(pool, newRatio);\n    }\n\n    /**\n     * @notice Sets the mining permission for the esLBR&LBR mining pool.\n     * @param _contracts An array of addresses representing the contracts.\n     * @param _bools An array of booleans indicating whether mining is allowed for each contract.\n     */\n    function setTokenMiner(address[] calldata _contracts, bool[] calldata _bools) external checkRole(TIMELOCK) {\n        for (uint256 i = 0; i < _contracts.length; i++) {\n            tokenMiner[_contracts[i]] = _bools[i];\n            emit tokenMinerChanges(_contracts[i], _bools[i]);\n        }\n    }\n\n    /**\n     * dev Sets the maximum percentage share for PeUSD.\n     * @param _ratio The ratio in basis points (1/10_000). The maximum value is 10_000.\n     */\n    function setMaxStableRatio(uint256 _ratio) external checkRole(TIMELOCK) {\n        require(_ratio <= 10_000, \"The maximum value is 10000\");\n        maxStableRatio = _ratio;\n    }\n\n    /// @notice Update the flashloan fee percentage, only available to the manager of the contract\n    /// @param fee The fee percentage for eUSD, multiplied by 100 (for example, 10% is 1000)\n    function setFlashloanFee(uint256 fee) external checkRole(TIMELOCK) {\n        if (fee > 10_000) revert('EL');\n        emit FlashloanFeeUpdated(fee);\n        flashloanFee = fee;\n    }\n\n    /// @notice Sets the address of the stablecoin used for rewards distribution.\n    /// @param _token The address of the stablecoin token.\n    function setProtocolRewardsToken(address _token) external checkRole(TIMELOCK) {\n        stableToken = _token;\n    }\n\n    /**\n     * @notice User chooses to become a Redemption Provider\n     */\n    function becomeRedemptionProvider(bool _bool) external {\n        eUSDMiningIncentives.refreshReward(msg.sender);\n        redemptionProvider[msg.sender] = _bool;\n        emit RedemptionProvider(msg.sender, _bool);\n    }\n\n    /**\n     * @dev Updates the mining data for the user's eUSD mining incentives.\n     */\n    function refreshMintReward(address user) external {\n        eUSDMiningIncentives.refreshReward(user);\n    }\n    \n    /**\n     * @notice Distributes rewards to the LybraProtocolRewardsPool based on the available balance of eUSD.\n     * If the balance is greater than 1e21, the distribution process is triggered.\n     * If premiumTradingEnabled is false or the price of the trading pair (0, 2) on the Curve pool is less than or equal to 1005000, eUSD rewards are directly transferred to the LybraProtocolRewardsPool.\n     * Otherwise, a controlled premium trading is performed by exchanging eUSD for the third token in the trading pair on the Curve pool, using a calculated amount to maintain a premium.\n     * The resulting token amount is transferred to the LybraProtocolRewardsPool.\n     * @dev The protocol rewards amount is notified to the LybraProtocolRewardsPool for proper reward allocation.\n     */\n    function distributeRewards() external {\n        uint256 peUSDBalance = peUSD.balanceOf(address(this));\n        if(peUSDBalance >= 1e21) {\n            peUSD.transfer(address(lybraProtocolRewardsPool), peUSDBalance);\n            lybraProtocolRewardsPool.notifyRewardAmount(peUSDBalance, 2);\n        }\n        uint256 balance = EUSD.balanceOf(address(this));\n        if (balance > 1e21) {\n            uint256 price = curvePool.get_dy_underlying(0, 2, 1e18);\n            if(!premiumTradingEnabled || price <= 1005000) {\n                EUSD.transfer(address(lybraProtocolRewardsPool), balance);\n                lybraProtocolRewardsPool.notifyRewardAmount(balance, 0);\n            } else {\n                EUSD.approve(address(curvePool), balance);\n                uint256 amount = curvePool.exchange_underlying(0, 2, balance, balance * price * 998 / 1e21);\n                IEUSD(stableToken).transfer(address(lybraProtocolRewardsPool), amount);\n                lybraProtocolRewardsPool.notifyRewardAmount(amount, 1);\n            }\n        }\n    }\n\n    /**\n     * @dev Returns the address of the eUSD token.\n     * @return The address of the eUSD token.\n     */\n    function getEUSDAddress() external view returns (address) {\n        return address(EUSD);\n    }\n\n    /**\n     * @dev Returns the address of the Lybra protocol rewards pool.\n     * @return The address of the Lybra protocol rewards pool.\n     */\n    function getProtocolRewardsPool() external view returns (address) {\n        return address(lybraProtocolRewardsPool);\n    }\n\n    /**\n     * @dev Returns the safe collateral ratio for a asset pool.\n     * @param pool The address of the pool to check.\n     * @return The safe collateral ratio for the specified pool.\n     */\n    function getSafeCollateralRatio(\n        address pool\n    ) external view returns (uint256) {\n        if (vaultSafeCollateralRatio[pool] == 0) return 160 * 1e18;\n        return vaultSafeCollateralRatio[pool];\n    }\n\n    function getBadCollateralRatio(address pool) external view returns(uint256) {\n        if(vaultBadCollateralRatio[pool] == 0) return vaultSafeCollateralRatio[pool] - 1e19;\n        return vaultBadCollateralRatio[pool];\n    }\n\n    /**\n     * @dev Checks if a user is a redemption provider.\n     * @param user The address of the user to check.\n     * @return True if the user is a redemption provider, false otherwise.\n     */\n    function isRedemptionProvider(address user) external view returns (bool) {\n        return redemptionProvider[user];\n    }\n\n    /**\n     * @dev Return the maximum quantity of PeUSD that can be minted by using eUSD.\n     * @return The maximum quantity of PeUSD that can be minted through eUSD.\n     */\n    function getEUSDMaxLocked() external view returns (uint256) {\n        return (EUSD.totalSupply() * maxStableRatio) / 10_000;\n    }\n\n    function hasRole(bytes32 role, address caller) external view returns (bool) {\n        return GovernanceTimelock.checkRole(role, caller);\n    }\n}"
    },
    {
      "filename": "contracts/lybra/configuration/LybraConfigurator.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/**\n * @title Lybra Protocol V2 Configurator Contract\n * @dev The Configurator contract is used to set various parameters and control functionalities of the Lybra Protocol. It is based on OpenZeppelin's Proxy and AccessControl libraries, allowing the DAO to control contract upgrades. There are three types of governance roles:\n * * DAO: A time-locked contract initiated by esLBR voting, with a minimum effective period of 14 days. After the vote is passed, only the developer can execute the action.\n * * TIMELOCK: A time-locked contract controlled by the developer, with a minimum effective period of 2 days.\n * * ADMIN: A multisignature account controlled by the developer.\n * All setting functions have three levels of calling permissions:\n * * onlyRole(DAO): Only callable by the DAO for governance purposes.\n * * checkRole(TIMELOCK): Callable by both the DAO and the TIMELOCK contract.\n * * checkRole(ADMIN): Callable by all governance roles.\n */\n\npragma solidity ^0.8.17;\n\nimport \"../interfaces/IGovernanceTimelock.sol\";\nimport \"../interfaces/IEUSD.sol\";\n\ninterface IProtocolRewardsPool {\n    function notifyRewardAmount(uint256 amount, uint256 tokenType) external;\n}\n\ninterface IeUSDMiningIncentives {\n    function refreshReward(address user) external;\n}\n\ninterface IVault {\n    function vaultType() external view returns (uint8);\n}\n\ninterface ICurvePool{\n    function get_dy_underlying(int128 i, int128 j, uint256 dx) external view returns (uint256);\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy) external returns(uint256);\n}\n\ncontract Configurator {\n    mapping(address => bool) public mintVault;\n    mapping(address => uint256) public mintVaultMaxSupply;\n    mapping(address => bool) public vaultMintPaused;\n    mapping(address => bool) public vaultBurnPaused;\n    mapping(address => uint256) vaultSafeCollateralRatio;\n    mapping(address => uint256) vaultBadCollateralRatio;\n    mapping(address => uint256) public vaultMintFeeApy;\n    mapping(address => uint256) public vaultKeeperRatio;\n    mapping(address => bool) redemptionProvider;\n    mapping(address => bool) public tokenMiner;\n\n    uint256 public redemptionFee = 50;\n    IGovernanceTimelock public GovernanceTimelock;\n\n    IeUSDMiningIncentives public eUSDMiningIncentives;\n    IProtocolRewardsPool public lybraProtocolRewardsPool;\n    IEUSD public EUSD;\n    IEUSD public peUSD;\n    uint256 public flashloanFee = 500;\n    // Limiting the maximum percentage of eUSD that can be cross-chain transferred to L2 in relation to the total supply.\n    uint256 maxStableRatio = 5_000;\n    address public stableToken;\n    ICurvePool public curvePool;\n    bool public premiumTradingEnabled;\n\n    event RedemptionFeeChanged(uint256 newSlippage);\n    event SafeCollateralRatioChanged(address indexed pool, uint256 newRatio);\n    event RedemptionProvider(address indexed user, bool status);\n    event ProtocolRewardsPoolChanged(address indexed pool, uint256 timestamp);\n    event EUSDMiningIncentivesChanged(address indexed pool, uint256 timestamp);\n    event BorrowApyChanged(address indexed pool, uint256 newApy);\n    event KeeperRatioChanged(address indexed pool, uint256 newSlippage);\n    event tokenMinerChanges(address indexed pool, bool status);\n\n    /// @notice Emitted when the fees for flash loaning a token have been updated\n    /// @param fee The new fee for this token as a percentage and multiplied by 100 to avoid decimals (for example, 10% is 10_00)\n    event FlashloanFeeUpdated(uint256 fee);\n\n    bytes32 public constant DAO = keccak256(\"DAO\");\n    bytes32 public constant TIMELOCK = keccak256(\"TIMELOCK\");\n    bytes32 public constant ADMIN = keccak256(\"ADMIN\");\n\n    constructor(address _dao, address _curvePool) {\n        GovernanceTimelock = IGovernanceTimelock(_dao);\n        curvePool = ICurvePool(_curvePool);\n    }\n\n    modifier onlyRole(bytes32 role) {\n        GovernanceTimelock.checkOnlyRo"
    }
  ]
}