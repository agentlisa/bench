{
  "Title": "M-11: Calculation B0 meets devision 0 error when a token has small decimal and high price with a small kBid",
  "Content": "# Issue M-11: Calculation B0 meets devision 0 error when a token has small decimal and high price with a small kBid  \n\nSource: https://github.com/sherlock-audit/2023-06-dodo-judging/issues/241 \n\n## Found by \nProtocol Team\nWhen a token has small decimal and high price, like wbtc, it will generate a low-precision bid price. In _calB0WithPriceLimit, \nhttps://github.com/sherlock-audit/2023-06-dodo/blob/a8d30e611acc9762029f8756d6a5b81825faf348/new-dodo-v3/contracts/DODOV3MM/lib/PMMRangeOrder.sol#L141C1-L148C10\n```solidity\n        if (k == 0) {\n            baseTarget = amount;\n        } else {\n            uint256 temp1 = priceUp + DecimalMath.mul(i, k) - i;\n            uint256 temp2 = DecimalMath.mul(i, k);\n            uint256 temp3 = DecimalMath.div(temp1, temp2);\n            uint256 temp5 = DecimalMath.sqrt(temp3) - ONE;\n\n            baseTarget = amount + DecimalMath.div(amount, temp5);\n```\nsmall bid price and kBid will cause temp2 =0, so that temp3 couldn't be calculated rightly.\n\n## Vulnerability Detail\nHere is poc\n```solidity\n   function testQueryFail() public {\n        token1ChainLinkOracle.feedData(30647 * 1e18);\n        token2ChainLinkOracle.feedData(1 * 1e18);\n        vm.startPrank(maker);\n        uint32[] memory tokenKs = new uint32[](2);\n        tokenKs[0] = 0;\n        tokenKs[1] = (1<< 16) +1;\n        address[] memory tokens = new address[](2);\n        tokens[0] = address(token2);\n        tokens[1] = address(token1);\n        address[] memory slotIndex = new address[](2);\n        slotIndex[0] = address(token1);\n        slotIndex[1] = address(token2);\n        uint80[] memory priceSlot = new uint80[](2);\n        priceSlot[0] = 2191925019632266903652;\n        priceSlot[1] = 720435765840878108682;\n\n        uint64[] memory amountslot = new uint64[](2);\n        amountslot[0] = stickAmount(10,8, 400000, 18);\n        amountslot[1] = stickAmount(400000, 18, 400000, 18);\n        d3MakerWithPool.setTokensKs(tokens, tokenKs);\n        d3MakerWithPool.setTokensPrice(slotIndex, priceSlot);\n        d3MakerWithPool.setTokensAmounts(slotIndex, amountslot);\n        vm.stopPrank();\n\n        (uint256 askDownPrice, uint256 askUpPrice, uint256 bidDownPrice, uint256 bidUpPrice, uint256 swapFee) =\n            d3MM.getTokenMMPriceInfoForRead(address(token1));\n        assertEq(askDownPrice, 304555028000000000000000000000000);\n        assertEq(askUpPrice, 307231900000000000000000000000000);\n        assertEq(bidDownPrice, 3291);\n        assertEq(bidUpPrice, 3320);\n        assertEq(swapFee, 1200000000000000);\n\n        //console.log(askDownPrice);\n        //console.log(askUpPrice);\n        //console.log(bidDownPrice);\n        //console.log(bidUpPrice);\n        //console.log(swapFee);\n\n        (,,uint kask, uint kbid,,) = d3MM.getTokenMMOtherInfoForRead(address(token1));\n        assertEq(kask, 1e14);\n        assertEq(kbid, 1e14);\n\n        (askDownPrice, askUpPrice, bidDownPrice, bidUpPrice, swapFee) =\n            d3MM.getTokenMMPriceInfoForRead(address(token2));\n        assertEq(askDownPrice, 999999960000000000);\n        assertEq(askUpPrice, 1000799800000000000);\n        assertEq(bidDownPrice, 1000400120032008002);\n        assertEq(bidUpPrice, 1001201241249250852);\n        assertEq(swapFee, 200000000000000);\n\n        (,,kask, kbid,,) = d3MM.getTokenMMOtherInfoForRead(address(token2));\n        assertEq(kask, 0);\n        assertEq(kbid, 0);\n\n        //console.log(askDownPrice);\n        //console.log(askUpPrice);\n        //console.log(bidDownPrice);\n        //console.log(bidUpPrice);\n        //console.log(swapFee);\n        //console.log(kask);\n        //console.log(kbid);\n\n        SwapCallbackData memory swapData;\n        swapData.data = \"\";\n        swapData.payer = user1;\n\n        //uint256 gasleft1 = gasleft();\n        uint256 receiveToToken = d3Proxy.sellTokens(\n            address(d3MM),\n            user1,\n            address(token1),\n            address(token2),\n            1000000,\n            0,\n            abi.encode(swapData),\n            block.timestamp + 1000\n        );\n```\nIt will revert.\nIn this example, wbtc price is 30445, and k = 0.0001, suppose maker contains rules, but model is invalid.\n\n## Impact\nMaker sets right parameters but traders can't swap. It will make swap model invalid.\n\n## Tool Used\nManual Review\n\n## Recommendation\n1. Fix formula for this corner case, like making temp2 = 1\n2. Improve calculation accuracy by consistently using precision 18 for calculations and converting to real decimal when processing amounts.  \n\n\n\n## Discussion\n\n**Attens1423**\n\nfix pr: https://github.com/DODOEX/new-dodo-v3/pull/32\n\n**hrishibhat**\n\nPlease note: This issue is not part of the contest submissions and is not eligible for contest rewards. \n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/89",
  "Code": [
    {
      "filename": "new-dodo-v3/contracts/DODOV3MM/lib/PMMRangeOrder.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.16;\n\nimport \"./PMMPricing.sol\";\nimport \"./Errors.sol\";\nimport \"./Types.sol\";\nimport {ID3Oracle} from \"contracts/intf/ID3Oracle.sol\";\n\nlibrary PMMRangeOrder {\n    uint256 internal constant ONE = 10 ** 18;\n\n    // use fromToken bid curve and toToken ask curve\n    function querySellTokens(\n        Types.RangeOrderState memory roState,\n        address fromToken,\n        address toToken,\n        uint256 fromTokenAmount\n    ) internal view returns (uint256 fromAmount, uint256 receiveToToken, uint256 vusdAmount) {\n        // contruct fromToken state and swap to vUSD\n        uint256 receiveVUSD;\n        {\n            PMMPricing.PMMState memory fromTokenState = _contructTokenState(roState, true, false);\n            receiveVUSD = PMMPricing._querySellQuoteToken(fromTokenState, fromTokenAmount);\n\n            receiveVUSD = receiveVUSD > fromTokenState.BLeft ? fromTokenState.BLeft : receiveVUSD;\n        }\n\n        // construct toToken state and swap from vUSD to toToken\n        {\n            PMMPricing.PMMState memory toTokenState = _contructTokenState(roState, false, true);\n            receiveToToken = PMMPricing._querySellQuoteToken(toTokenState, receiveVUSD);\n\n            receiveToToken = receiveToToken > toTokenState.BLeft ? toTokenState.BLeft : receiveToToken;\n        }\n\n        // oracle protect\n        {\n            uint256 oracleToAmount = ID3Oracle(roState.oracle).getMaxReceive(fromToken, toToken, fromTokenAmount);\n            require(oracleToAmount >= receiveToToken, Errors.RO_ORACLE_PROTECTION);\n        }\n        return (fromTokenAmount, receiveToToken, receiveVUSD);\n    }\n\n    // use fromToken bid curve and toToken ask curve\n    function queryBuyTokens(\n        Types.RangeOrderState memory roState,\n        address fromToken,\n        address toToken,\n        uint256 toTokenAmount\n    ) internal view returns (uint256 payFromToken, uint256 toAmount, uint256 vusdAmount) {\n        // contruct fromToken to vUSD\n        uint256 payVUSD;\n        {\n            PMMPricing.PMMState memory toTokenState = _contructTokenState(roState, false, true);\n            // vault reserve protect\n            require(\n                toTokenAmount <= toTokenState.BMaxAmount - roState.toTokenMMInfo.cumulativeAsk, Errors.RO_VAULT_RESERVE\n            );\n            payVUSD = PMMPricing._queryBuyBaseToken(toTokenState, toTokenAmount);\n        }\n\n        // construct vUSD to toToken\n        {\n            PMMPricing.PMMState memory fromTokenState = _contructTokenState(roState, true, false);\n            payFromToken = PMMPricing._queryBuyBaseToken(fromTokenState, payVUSD);\n        }\n\n        // oracle protect\n        {\n            uint256 oracleToAmount = ID3Oracle(roState.oracle).getMaxReceive(fromToken, toToken, payFromToken);\n            require(oracleToAmount >= toTokenAmount, Errors.RO_ORACLE_PROTECTION);\n        }\n\n        return (payFromToken, toTokenAmount, payVUSD);\n    }\n\n    // ========= internal ==========\n    function _contructTokenState(\n        Types.RangeOrderState memory roState,\n        bool fromTokenOrNot,\n        bool askOrNot\n    ) internal pure returns (PMMPricing.PMMState memory tokenState) {\n        Types.TokenMMInfo memory tokenMMInfo = fromTokenOrNot ? roState.fromTokenMMInfo : roState.toTokenMMInfo;\n\n        // bMax,k\n        tokenState.BMaxAmount = askOrNot ? tokenMMInfo.askAmount : tokenMMInfo.bidAmount;\n\n        // amount = 0 protection\n        require(tokenState.BMaxAmount > 0, Errors.RO_AMOUNT_ZERO);\n        tokenState.K = askOrNot ? tokenMMInfo.kAsk : tokenMMInfo.kBid;\n\n        // i, B0\n        uint256 upPrice;\n        (tokenState.i, upPrice) = askOrNot\n            ? (tokenMMInfo.askDownPrice, tokenMMInfo.askUpPrice)\n            : (tokenMMInfo.bidDownPrice, tokenMMInfo.bidUpPrice);\n        // price = 0 protection\n        require(tokenState.i > 0, Errors.RO_PRICE_ZERO);\n        tokenState.B0 = _calB0WithPriceLimit(upPrice, tokenState.K, tokenState.i, tokenState.BMaxAmount);\n        // B\n        tokenState.B = askOrNot ? tokenState.B0 - tokenMMInfo.cumulativeAsk : tokenState.B0 - tokenMMInfo.cumulativeBid;\n\n        // BLeft\n        tokenState.BLeft = askOrNot\n            ? tokenState.BMaxAmount - tokenMMInfo.cumulativeAsk\n            : tokenState.BMaxAmount - tokenMMInfo.cumulativeBid;\n\n        return tokenState;\n    }\n\n    // P_up = i(1 - k + k*(B0 / B0 - amount)^2), record amount = A\n    // (P_up + i*k - 1) / i*k = (B0 / B0 - A)^2\n    // B0 = A + A / (sqrt((P_up + i*k - i) / i*k) - 1)\n    // i = priceDown\n    function _calB0WithPriceLimit(\n        uint256 priceUp,\n        uint256 k,\n        uint256 i,\n        uint256 amount\n    ) internal pure returns (uint256 baseTarget) {\n        // (P_up + i*k - i)\n        // temp1 = PriceUp + DecimalMath.mul(i, k) - i\n        // temp1 price\n\n        // i*k\n        // temp2 = DecimalMath.mul(i, k)\n        // temp2 price\n\n        // (P_up + i*k - i)/i*k\n        // temp3 = DecimalMath(temp1, temp2)\n        // temp3 ONE\n\n        // temp4 = sqrt(temp3 * ONE)\n        // temp4 ONE\n\n        // temp5 = temp4 - ONE\n        // temp5 ONE\n\n        // B0 = amount + DecimalMath.div(amount, temp5)\n        // B0 amount\n        if (k == 0) {\n            baseTarget = amount;\n        } else {\n            uint256 temp1 = priceUp + DecimalMath.mul(i, k) - i;\n            uint256 temp3 = DecimalMath.div(temp1, DecimalMath.mul(i, k));\n            uint256 temp5 = DecimalMath.sqrt(temp3) - ONE;\n            baseTarget = amount + DecimalMath.div(amount, temp5);\n        }\n    }\n}"
    }
  ]
}