{
  "Title": "Unsafe ABI Encoding",
  "Content": "It is not an uncommon practice to use `abi.encodeWithSignature` or `abi.encodeWithSelector` to generate calldata for a low-level call. However, the first option is not typo-safe and the second option is not type-safe. The results in both of these methods being error-prone and thus to be considered unsafe. Within `Encoding.sol`, there are several occurrences of unsafe ABI encodings:\n\n\n* In [line 92](https://github.com/mantlenetworkio/mantle-v2/blob/e29d360904db5e5ec81888885f7b7250f8255895/packages/contracts-bedrock/contracts/libraries/Encoding.sol#L92).\n* In [line 124](https://github.com/mantlenetworkio/mantle-v2/blob/e29d360904db5e5ec81888885f7b7250f8255895/packages/contracts-bedrock/contracts/libraries/Encoding.sol#L124).\n\n\nConsider replacing all the occurrences of unsafe ABI encodings with `abi.encodeCall`, which checks whether the supplied values actually match the types expected by the called function and also avoids errors caused by typos.\n\n\n***Update:** Acknowledged, not resolved. The Mantle team stated:*\n\n\n\n> *There is no need to fix this.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "packages/contracts-bedrock/contracts/libraries/Encoding.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Types } from \"./Types.sol\";\nimport { Hashing } from \"./Hashing.sol\";\nimport { RLPWriter } from \"./rlp/RLPWriter.sol\";\n\n/**\n * @title Encoding\n * @notice Encoding handles Optimism's various different encoding schemes.\n */\nlibrary Encoding {\n    /**\n     * @notice RLP encodes the L2 transaction that would be generated when a given deposit is sent\n     *         to the L2 system. Useful for searching for a deposit in the L2 system. The\n     *         transaction is prefixed with 0x7e to identify its EIP-2718 type.\n     *\n     * @param _tx User deposit transaction to encode.\n     *\n     * @return RLP encoded L2 deposit transaction.\n     */\n    function encodeDepositTransaction(Types.UserDepositTransaction memory _tx)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes32 source = Hashing.hashDepositSource(_tx.l1BlockHash, _tx.logIndex);\n        bytes[] memory raw = new bytes[](10);\n        raw[0] = RLPWriter.writeBytes(abi.encodePacked(source));\n        raw[1] = RLPWriter.writeAddress(_tx.from);\n        raw[2] = _tx.isCreation ? RLPWriter.writeBytes(\"\") : RLPWriter.writeAddress(_tx.to);\n        raw[3] = RLPWriter.writeUint(_tx.mntValue);\n        raw[4] = RLPWriter.writeUint(_tx.mntTxValue);\n        raw[5] = RLPWriter.writeUint(uint256(_tx.gasLimit));\n        raw[6] = RLPWriter.writeBool(false);\n        raw[7] = RLPWriter.writeUint(_tx.ethValue);\n        raw[8] = RLPWriter.writeBytes(_tx.data);\n        raw[9] = RLPWriter.writeUint(_tx.ethTxValue);\n        return abi.encodePacked(uint8(0x7e), RLPWriter.writeList(raw));\n    }\n\n    /**\n     * @notice Encodes the cross domain message based on the version that is encoded into the\n     *         message nonce.\n     *\n     * @param _nonce    Message nonce with version encoded into the first two bytes.\n     * @param _sender   Address of the sender of the message.\n     * @param _target   Address of the target of the message.\n     * @param _mntValue MNT value to send to the target.\n     * @param _ethValue ETH value to send to the target.\n     * @param _gasLimit Gas limit to use for the message.\n     * @param _data     Data to send with the message.\n     *\n     * @return Encoded cross domain message.\n     */\n    function encodeCrossDomainMessage(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _mntValue,\n        uint256 _ethValue,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) internal pure returns (bytes memory) {\n        (, uint16 version) = decodeVersionedNonce(_nonce);\n        if (version == 0) {\n            return encodeCrossDomainMessageV0(_target, _sender, _data, _nonce);\n        } else if (version == 1) {\n            return encodeCrossDomainMessageV1(_nonce, _sender, _target, _mntValue, _ethValue, _gasLimit, _data);\n        } else {\n            revert(\"Encoding: unknown cross domain message version\");\n        }\n    }\n\n    /**\n     * @notice Encodes a cross domain message based on the V0 (legacy) encoding.\n     *\n     * @param _target Address of the target of the message.\n     * @param _sender Address of the sender of the message.\n     * @param _data   Data to send with the message.\n     * @param _nonce  Message nonce.\n     *\n     * @return Encoded cross domain message.\n     */\n    function encodeCrossDomainMessageV0(\n        address _target,\n        address _sender,\n        bytes memory _data,\n        uint256 _nonce\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodeWithSignature(\n                \"relayMessage(address,address,bytes,uint256)\",\n                _target,\n                _sender,\n                _data,\n                _nonce\n            );\n    }\n\n    /**\n     * @notice Encodes a cross domain message based on the V1 (current) encoding.\n     *\n     * @param _nonce    Message nonce.\n     * @param _sender   Address of the sender of the message.\n     * @param _target   Address of the target of the message.\n     * @param _mntValue MNT value to send to the target.\n     * @param _ethValue ETH value to send to the target.\n     * @param _gasLimit Gas limit to use for the message.\n     * @param _data     Data to send with the message.\n     *\n     * @return Encoded cross domain message.\n     */\n    function encodeCrossDomainMessageV1(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _mntValue,\n        uint256 _ethValue,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodeWithSignature(\n                \"relayMessage(uint256,address,address,uint256,uint256,uint256,bytes)\",\n                _nonce,\n                _sender,\n                _target,\n                _mntValue,\n                _ethValue,\n                _gasLimit,\n                _data\n            );\n    }\n\n    /**\n     * @notice Adds a version number into the first two bytes of a message nonce.\n     *\n     * @param _nonce   Message nonce to encode into.\n     * @param _version Version number to encode into the message nonce.\n     *\n     * @return Message nonce with version encoded into the first two bytes.\n     */\n    function encodeVersionedNonce(uint240 _nonce, uint16 _version) internal pure returns (uint256) {\n        uint256 nonce;\n        assembly {\n            nonce := or(shl(240, _version), _nonce)\n        }\n        return nonce;\n    }\n\n    /**\n     * @notice Pulls the version out of a version-encoded nonce.\n     *\n     * @param _nonce Message nonce with version encoded into the first two bytes.\n     *\n     * @return Nonce without encoded version.\n     * @return Version of the message.\n     */\n    function decodeVersionedNonce(uint256 _nonce) internal pure returns (uint240, uint16) {\n        uint240 nonce;\n        uint16 version;\n        assembly {\n            nonce := and(_nonce, 0x0000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            version := shr(240, _nonce)\n        }\n        return (nonce, version);\n    }\n}"
    },
    {
      "filename": "packages/contracts-bedrock/contracts/libraries/Encoding.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Types } from \"./Types.sol\";\nimport { Hashing } from \"./Hashing.sol\";\nimport { RLPWriter } from \"./rlp/RLPWriter.sol\";\n\n/**\n * @title Encoding\n * @notice Encoding handles Optimism's various different encoding schemes.\n */\nlibrary Encoding {\n    /**\n     * @notice RLP encodes the L2 transaction that would be generated when a given deposit is sent\n     *         to the L2 system. Useful for searching for a deposit in the L2 system. The\n     *         transaction is prefixed with 0x7e to identify its EIP-2718 type.\n     *\n     * @param _tx User deposit transaction to encode.\n     *\n     * @return RLP encoded L2 deposit transaction.\n     */\n    function encodeDepositTransaction(Types.UserDepositTransaction memory _tx)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes32 source = Hashing.hashDepositSource(_tx.l1BlockHash, _tx.logIndex);\n        bytes[] memory raw = new bytes[](10);\n        raw[0] = RLPWriter.writeBytes(abi.encodePacked(source));\n        raw[1] = RLPWriter.writeAddress(_tx.from);\n        raw[2] = _tx.isCreation ? RLPWriter.writeBytes(\"\") : RLPWriter.writeAddress(_tx.to);\n        raw[3] = RLPWriter.writeUint(_tx.mntValue);\n        raw[4] = RLPWriter.writeUint(_tx.mntTxValue);\n        raw[5] = RLPWriter.writeUint(uint256(_tx.gasLimit));\n        raw[6] = RLPWriter.writeBool(false);\n        raw[7] = RLPWriter.writeUint(_tx.ethValue);\n        raw[8] = RLPWriter.writeBytes(_tx.data);\n        raw[9] = RLPWriter.writeUint(_tx.ethTxValue);\n        return abi.encodePacked(uint8(0x7e), RLPWriter.writeList(raw));\n    }\n\n    /**\n     * @notice Encodes the cross domain message based on the version that is encoded into the\n     *         message nonce.\n     *\n     * @param _nonce    Message nonce with version encoded into the first two bytes.\n     * @param _sender   Address of the sender of the message.\n     * @param _target   Address of the target of the message.\n     * @param _mntValue MNT value to send to the target.\n     * @param _ethValue ETH value to send to the target.\n     * @param _gasLimit Gas limit to use for the message.\n     * @param _data     Data to send with the message.\n     *\n     * @return Encoded cross domain message.\n     */\n    function encodeCrossDomainMessage(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _mntValue,\n        uint256 _ethValue,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) internal pure returns (bytes memory) {\n        (, uint16 version) = decodeVersionedNonce(_nonce);\n        if (version == 0) {\n            return encodeCrossDomainMessageV0(_target, _sender, _data, _nonce);\n        } else if (version == 1) {\n            return encodeCrossDomainMessageV1(_nonce, _sender, _target, _mntValue, _ethValue, _gasLimit, _data);\n        } else {\n            revert(\"Encoding: unknown cross domain message version\");\n        }\n    }\n\n    /**\n     * @notice Encodes a cross domain message based on the V0 (legacy) encoding.\n     *\n     * @param _target Address of the target of the message.\n     * @param _sender Address of the sender of the message.\n     * @param _data   Data to send with the message.\n     * @param _nonce  Message nonce.\n     *\n     * @return Encoded cross domain message.\n     */\n    function encodeCrossDomainMessageV0(\n        address _target,\n        address _sender,\n        bytes memory _data,\n        uint256 _nonce\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodeWithSignature(\n                \"relayMessage(address,address,bytes,uint256)\",\n                _target,\n                _sender,\n                _data,\n                _nonce\n            );\n    }\n\n    /**\n     * @notice Encodes a cross domain message based on the V1 (current) encoding.\n     *\n     * @param _nonce    Message nonce.\n     * @param _sender   Address of the sender of the message.\n     * @param _target   Address of the target of the message.\n     * @param _mntValue MNT value to send to the target.\n     * @param _ethValue ETH value to send to the target.\n     * @param _gasLimit Gas limit to use for the message.\n     * @param _data     Data to send with the message.\n     *\n     * @return Encoded cross domain message.\n     */\n    function encodeCrossDomainMessageV1(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _mntValue,\n        uint256 _ethValue,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodeWithSignature(\n                \"relayMessage(uint256,address,address,uint256,uint256,uint256,bytes)\",\n                _nonce,\n                _sender,\n                _target,\n                _mntValue,\n                _ethValue,\n                _gasLimit,\n                _data\n            );\n    }\n\n    /**\n     * @notice Adds a version number into the first two bytes of a message nonce.\n     *\n     * @param _nonce   Message nonce to encode into.\n     * @param _version Version number to encode into the message nonce.\n     *\n     * @return Message nonce with version encoded into the first two bytes.\n     */\n    function encodeVersionedNonce(uint240 _nonce, uint16 _version) internal pure returns (uint256) {\n        uint256 nonce;\n        assembly {\n            nonce := or(shl(240, _version), _nonce)\n        }\n        return nonce;\n    }\n\n    /**\n     * @notice Pulls the version out of a version-encoded nonce.\n     *\n     * @param _nonce Message nonce with version encoded into the first two bytes.\n     *\n     * @return Nonce without encoded version.\n     * @return Version of the message.\n     */\n    function decodeVersionedNonce(uint256 _nonce) internal pure returns (uint240, uint16) {\n        uint240 nonce;\n        uint16 version;\n        assembly {\n            nonce := and(_nonce, 0x0000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            version := shr(240, _nonce)\n        }\n        return (nonce, version);\n    }\n}"
    }
  ]
}