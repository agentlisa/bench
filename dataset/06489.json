{
  "Title": "[M-43] Deploy flow of `Talos` is broken",
  "Content": "\nThe `Talos` protocol can't be deployed in a right way.\n\n### Proof of Concept\n\n`TalosBaseStrategy` needs `TalosManager` to be passed in the constructor:\n\n<https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/talos/base/TalosBaseStrategy.sol#L79-L95>\n\n```solidity\n    constructor(\n        IUniswapV3Pool _pool,\n        ITalosOptimizer _optimizer,\n        INonfungiblePositionManager _nonfungiblePositionManager,\n        address _strategyManager,\n        address _owner\n    ) ERC20(\"TALOS LP\", \"TLP\", 18) {\n        ...\n\n        strategyManager = _strategyManager;\n        \n        ...\n    }\n```\n\nBut `TalosManager` needs `Strategy` to be passed into the constructor:\n\n<https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/talos/TalosManager.sol#L44-L56>\n\n```solidity\n   constructor(\n        address _strategy,\n        int24 _ticksFromLowerRebalance,\n        int24 _ticksFromUpperRebalance,\n        int24 _ticksFromLowerRerange,\n        int24 _ticksFromUpperRerange\n    ) {\n        strategy = ITalosBaseStrategy(_strategy);\n        \n        ...\n    }\n```\n\n### Recommended Mitigation Steps\n\nAdd setters for complete deploy or initializing function.\n\n### Assessed type\n\nDoS\n\n**[0xLightt (Maia) confirmed](https://github.com/code-423n4/2023-05-maia-findings/issues/75#issuecomment-1631475531)**\n\n**[0xLightt (Maia) commented](https://github.com/code-423n4/2023-05-maia-findings/issues/75#issuecomment-1709185337):**\n > Addressed [here](https://github.com/Maia-DAO/eco-c4-contest/tree/75).\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/talos/base/TalosBaseStrategy.sol",
      "content": "// SPDX-License-Identifier: MIT\n// Logic inspired by Popsicle Finance Contracts (PopsicleV3Optimizer/contracts/popsicle-v3-optimizer/PopsicleV3Optimizer.sol)\npragma solidity >=0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\n\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\nimport {IUniswapV3Pool} from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport {INonfungiblePositionManager} from \"@uniswap/v3-periphery/contracts/interfaces/INonfungiblePositionManager.sol\";\n\nimport {PoolVariables} from \"../libraries/PoolVariables.sol\";\n\nimport {ITalosBaseStrategy} from \"../interfaces/ITalosBaseStrategy.sol\";\nimport {ITalosOptimizer} from \"../interfaces/ITalosOptimizer.sol\";\n\n/// @title Tokenized Vault implementation for Uniswap V3 Non Fungible Positions.\nabstract contract TalosBaseStrategy is Ownable, ERC20, ReentrancyGuard, ITalosBaseStrategy {\n    using SafeTransferLib for address;\n    using FixedPointMathLib for uint256;\n    using FixedPointMathLib for uint128;\n    using SafeCastLib for uint256;\n    using SafeCastLib for uint128;\n    using PoolVariables for IUniswapV3Pool;\n\n    /*//////////////////////////////////////////////////////////////\n                        TALOS BASE STRATEGY STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ITalosBaseStrategy\n    uint256 public override tokenId;\n    /// @inheritdoc ITalosBaseStrategy\n    uint128 public override liquidity;\n\n    /// @inheritdoc ITalosBaseStrategy\n    uint256 public protocolFees0;\n    /// @inheritdoc ITalosBaseStrategy\n    uint256 public protocolFees1;\n\n    /// @notice Current tick lower of Optimizer pool position\n    /// @inheritdoc ITalosBaseStrategy\n    int24 public override tickLower;\n    /// @notice Current tick higher of Optimizer pool position\n    /// @inheritdoc ITalosBaseStrategy\n    int24 public override tickUpper;\n\n    /// @inheritdoc ITalosBaseStrategy\n    bool public initialized;\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ITalosBaseStrategy\n    ERC20 public immutable override token0;\n    /// @inheritdoc ITalosBaseStrategy\n    ERC20 public immutable override token1;\n    /// @inheritdoc ITalosBaseStrategy\n    int24 public immutable override tickSpacing;\n    /// @inheritdoc ITalosBaseStrategy\n    uint24 public immutable override poolFee;\n    /// @inheritdoc ITalosBaseStrategy\n    IUniswapV3Pool public immutable override pool;\n    /// @inheritdoc ITalosBaseStrategy\n    ITalosOptimizer public immutable override optimizer;\n    /// @inheritdoc ITalosBaseStrategy\n    address public immutable strategyManager;\n    /// @inheritdoc ITalosBaseStrategy\n    INonfungiblePositionManager public immutable override nonfungiblePositionManager;\n\n    uint24 internal constant MULTIPLIER = 1e6;\n\n    constructor(\n        IUniswapV3Pool _pool,\n        ITalosOptimizer _optimizer,\n        INonfungiblePositionManager _nonfungiblePositionManager,\n        address _strategyManager,\n        address _owner\n    ) ERC20(\"TALOS LP\", \"TLP\", 18) {\n        _initializeOwner(_owner);\n        optimizer = _optimizer;\n        nonfungiblePositionManager = _nonfungiblePositionManager;\n        strategyManager = _strategyManager;\n        pool = _pool;\n        token0 = ERC20(_pool.token0());\n        token1 = ERC20(_pool.token1());\n        tickSpacing = _pool.tickSpacing();\n        poolFee = _pool.fee();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            INITIALIZATION\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ITalosBaseStrategy\n    function init(uint256 amount0Desired, uint256 amount1Desired, address receiver)\n        external\n        virtual\n        nonReentrant\n        returns (uint256 shares, uint256 amount0, uint256 amount1)\n    {\n        if (initialized) revert AlreadyInitialized();\n\n        {\n            // Own Scope to avoid stack to deep\n            int24 _tickSpacing = tickSpacing; // Saves an extra SLOAD\n            int24 baseThreshold = _tickSpacing * optimizer.tickRangeMultiplier();\n            (, int24 currentTick,,,,,) = pool.slot0();\n            int24 tickFloor = PoolVariables.floor(currentTick, _tickSpacing);\n\n            int24 _tickLower = tickFloor - baseThreshold; // Saves an extra SLOAD\n            int24 _tickUpper = tickFloor + baseThreshold; // Saves an extra SLOAD\n            PoolVariables.checkRange(_tickLower, _tickUpper); // Check ticks also for overflow/underflow\n            tickLower = _tickLower;\n            tickUpper = _tickUpper;\n        }\n\n        (ERC20 _token0, ERC20 _token1) = (token0, token1);\n        address(_token0).safeTransferFrom(msg.sender, address(this), amount0Desired);\n        address(_token1).safeTransferFrom(msg.sender, address(this), amount1Desired);\n\n        INonfungiblePositionManager _nonfungiblePositionManager = nonfungiblePositionManager; // Saves an extra SLOAD\n\n        address(_token0).safeApprove(address(_nonfungiblePositionManager), type(uint256).max);\n        address(_token1).safeApprove(address(_nonfungiblePositionManager), type(uint256).max);\n\n        uint128 _liquidity;\n        uint256 _tokenId;\n        (_tokenId, _liquidity, amount0, amount1) = _nonfungiblePositionManager.mint(\n            INonfungiblePositionManager.MintParams({\n                token0: address(_token0),\n                token1: address(_token1),\n                fee: poolFee,\n                tickLower: tickLower,\n                tickUpper: tickUpper,\n                amount0Desired: amount0Desired,\n                amount1Desired: amount1Desired,\n                amount0Min: 0,\n                amount1Min: 0,\n                recipient: address(this),\n                deadline: block.timestamp\n            })\n        );\n\n        if (amount0 == 0 && amount1 == 0) revert AmountsAreZero();\n\n        shares = _liquidity * MULTIPLIER;\n        liquidity = _liquidity;\n        tokenId = _tokenId;\n\n        _mint(receiver, shares);\n        if (totalSupply > optimizer.maxTotalSupply()) revert ExceedingMaxTotalSupply();\n\n        emit Initialize(tokenId, msg.sender, receiver, amount0, amount1, shares);\n\n        afterDeposit(_tokenId);\n        initialized = true;\n\n        // Refund in both assets.\n        if (amount0 < amount0Desired) {\n            uint256 refund0 = amount0Desired - amount0;\n            address(_token0).safeTransfer(msg.sender, refund0);\n        }\n\n        if (amount1 < amount1Desired) {\n            uint256 refund1 = amount1Desired - amount1;\n            address(_token1).safeTransfer(msg.sender, refund1);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ITalosBaseStrategy\n    function deposit(uint256 amount0Desired, uint256 amount1Desired, address receiver)\n        public\n        virtual\n        override\n        nonReentrant\n        checkDeviation\n        returns (uint256 shares, uint256 amount0, uint256 amount1)\n    {\n        uint256 _tokenId = tokenId;\n\n        beforeDeposit(_tokenId, receiver);\n\n        (ERC20 _token0, ERC20 _token1) = (token0, token1);\n\n        address(_token0).safeTransferFrom(msg.sender, address(this), amount0Desired);\n        address(_token1).safeTransferFrom(msg.sender, address(this), amount1Desired);\n\n        uint128 liquidityDifference;\n\n        (liquidityDifference, amount0, amount1) = nonfungiblePositionManager.increaseLiquidity(\n            INonfungiblePositionManager.IncreaseLiquidityParams({\n                tokenId: _tokenId,\n                amount0Desired: amount0Desired,\n                amount1Desired: amount1Desired,\n                amount0Min: 0,\n                amount1Min: 0,\n                deadline: block.timestamp\n            })\n        );\n\n        if (amount0 == 0 && amount1 == 0) revert AmountsAreZero();\n\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n        shares = supply == 0 ? liquidityDifference * MULTIPLIER : (liquidityDifference * supply) / liquidity;\n        liquidity += liquidityDifference;\n\n        _mint(receiver, shares);\n        if (totalSupply > optimizer.maxTotalSupply()) revert ExceedingMaxTotalSupply();\n\n        emit Deposit(msg.sender, receiver, amount0, amount1, shares);\n\n        afterDeposit(_tokenId);\n\n        // Refund in both assets.\n        if (amount0 < amount0Desired) {\n            uint256 refund0 = amount0Desired - amount0;\n            address(_token0).safeTransfer(msg.sender, refund0);\n        }\n\n        if (amount1 < amount1Desired) {\n            uint256 refund1 = amount1Desired - amount1;\n            address(_token1).safeTransfer(msg.sender, refund1);\n        }\n    }\n\n    /// @inheritdoc ITalosBaseStrategy\n    function redeem(uint256 shares, uint256 amount0Min, uint256 amount1Min, address receiver, address _owner)\n        public\n        virtual\n        override\n        nonReentrant\n        checkDeviation\n        returns (uint256 amount0, uint256 amount1)\n    {\n        if (msg.sender != _owner) {\n            uint256 allowed = allowance[_owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[_owner][msg.sender] = allowed - shares;\n        }\n\n        if (shares == 0) revert RedeemingZeroShares();\n        if (receiver == address(0)) revert ReceiverIsZeroAddress();\n\n        uint256 _tokenId = tokenId;\n\n        beforeRedeem(_tokenId, receiver);\n\n        INonfungiblePositionManager _nonfungiblePositionManager = nonfungiblePositionManager; // Saves an extra SLOAD\n        {\n            uint128 liquidityToDecrease = uint128((liquidity * shares) / totalSupply);\n\n            (amount0, amount1) = _nonfungiblePositionManager.decreaseLiquidity(\n                INonfungiblePositionManager.DecreaseLiquidityParams({\n                    tokenId: _tokenId,\n                    liquidity: liquidityToDecrease,\n                    amount0Min: amount0Min,\n                    amount1Min: amount1Min,\n                    deadline: block.timestamp\n                })\n            );\n\n            if (amount0 == 0 && amount1 == 0) revert AmountsAreZero();\n\n            _burn(_owner, shares);\n\n            liquidity -= liquidityToDecrease;\n        }\n        emit Redeem(msg.sender, receiver, _owner, amount0, amount1, shares);\n\n        (amount0, amount1) = _nonfungiblePositionManager.collect(\n            INonfungiblePositionManager.CollectParams({\n                tokenId: _tokenId,\n                recipient: receiver,\n                amount0Max: type(uint128).max,\n                amount1Max: type(uint128).max\n            })\n        );\n\n        afterRedeem(_tokenId);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        RERANGE/REBALANCE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ITalosBaseStrategy\n    function rerange() external virtual override nonReentrant checkDeviation onlyStrategyManager {\n        uint256 _tokenId = tokenId;\n        beforeRerange(_tokenId);\n        // Redeem all liquidity from pool to rerange for Optimizer's balances.\n        _withdrawAll(_tokenId);\n\n        (uint256 amount0, uint256 amount1) = doRerange();\n        emit Rerange(tokenId, tickLower, tickUpper, amount0, amount1);\n\n        afterRerange(tokenId); // tokenId changed in doRerange\n    }\n\n    /// @inheritdoc ITalosBaseStrategy\n    function rebalance() external virtual override nonReentrant checkDeviation onlyStrategyManager {\n        uint256 _tokenId = tokenId;\n        beforeRerange(_tokenId);\n        // Redeem all liquidity from pool to rerange for Optimizer's balances.\n        _withdrawAll(_tokenId);\n\n        (uint256 amount0, uint256 amount1) = doRebalance();\n        emit Rerange(tokenId, tickLower, tickUpper, amount0, amount1);\n\n        afterRerange(tokenId); // tokenId changed in doRerange\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            EXTERNAL HOOKS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC721Receiver\n    function onERC721Received(address, address, uint256, bytes calldata) external pure override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    /// @inheritdoc ITalosBaseStrategy\n    function uniswapV3SwapCallback(int256 amount0, int256 amount1, bytes calldata _data) external {\n        if (msg.sender != address(pool)) revert CallerIsNotPool();\n        if (amount0 == 0 && amount1 == 0) revert AmountsAreZero();\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n        bool zeroForOne = data.zeroForOne;\n\n        if (zeroForOne) address(token0).safeTransfer(msg.sender, uint256(amount0));\n        else address(token1).safeTransfer(msg.sender, uint256(amount1));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Redeems all liquidity for a specific tokenId\n    /// @param _tokenId position to withdraw liquidity from\n    function _withdrawAll(uint256 _tokenId) internal {\n        uint128 _liquidity = liquidity; // Saves an extra SLOAD if totalSupply is non-zero.\n        if (_liquidity == 0) return;\n        INonfungiblePositionManager _nonfungiblePositionManager = nonfungiblePositionManager;\n        _nonfungiblePositionManager.decreaseLiquidity(\n            INonfungiblePositionManager.DecreaseLiquidityParams({\n                tokenId: _tokenId,\n                liquidity: _liquidity,\n                amount0Min: 0,\n                amount1Min: 0,\n                deadline: block.timestamp\n            })\n        );\n        liquidity = 0;\n        _nonfungiblePositionManager.collect(\n            INonfungiblePositionManager.CollectParams({\n                tokenId: _tokenId,\n                recipient: address(this),\n                amount0Max: type(uint128).max,\n                amount1Max: type(uint128).max\n            })\n        );\n    }\n\n    function beforeDeposit(uint256 _tokenId, address _receiver) internal virtual;\n\n    function afterDeposit(uint256 _tokenId) internal virtual;\n\n    function beforeRedeem(uint256 _tokenId, address _owner) internal virtual;\n\n    function afterRedeem(uint256 _tokenId) internal virtual;\n\n    function beforeRerange(uint256 _tokenId) internal virtual;\n\n    function afterRerange(uint256 _tokenId) internal virtual;\n\n    function doRerange() internal virtual returns (uint256 amount0, uint256 amount1);\n\n    function doRebalance() internal virtual returns (uint256 amount0, uint256 amount1);\n\n    /*//////////////////////////////////////////////////////////////\n                            ADMIN FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ITalosBaseStrategy\n    function collectProtocolFees(uint256 amount0, uint256 amount1) external nonReentrant onlyOwner {\n        uint256 _protocolFees0 = protocolFees0;\n        uint256 _protocolFees1 = protocolFees1;\n\n        if (amount0 > _protocolFees0) {\n            revert Token0AmountIsBiggerThanProtocolFees();\n        }\n        if (amount1 > _protocolFees1) {\n            revert Token1AmountIsBiggerThanProtocolFees();\n        }\n        ERC20 _token0 = token0;\n        ERC20 _token1 = token1;\n        uint256 balance0 = _token0.balanceOf(address(this));\n        uint256 balance1 = _token1.balanceOf(address(this));\n        require(balance0 >= amount0 && balance1 >= amount1);\n        if (amount0 > 0) _token0.transfer(msg.sender, amount0);\n        if (amount1 > 0) _token1.transfer(msg.sender, amount1);\n\n        protocolFees0 = _protocolFees0 - amount0;\n        protocolFees1 = _protocolFees1 - amount1;\n        emit RewardPaid(msg.sender, amount0, amount1);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Function modifier that checks if price has not moved a lot recently.\n    /// This mitigates price manipulation during rebalance and also prevents placing orders when it's too volatile.\n    modifier checkDeviation() {\n        ITalosOptimizer _optimizer = optimizer;\n        pool.checkDeviation(_optimizer.maxTwapDeviation(), _optimizer.twapDuration());\n        _;\n    }\n\n    /// @notice Function modifier that checks if msg.sender is the strategy manager.\n    modifier onlyStrategyManager() {\n        if (msg.sender != strategyManager) revert NotStrategyManager();\n        _;\n    }\n}"
    },
    {
      "filename": "src/talos/TalosManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IUniswapV3Pool} from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\n\nimport {ITalosBaseStrategy} from \"./interfaces/ITalosBaseStrategy.sol\";\nimport {ITalosManager} from \"./interfaces/ITalosManager.sol\";\nimport {ITalosOptimizer} from \"./interfaces/ITalosOptimizer.sol\";\nimport {PoolVariables} from \"./libraries/PoolVariables.sol\";\n\nimport {ITalosManager, AutomationCompatibleInterface} from \"./interfaces/ITalosManager.sol\";\n\n/// @title Talos Strategy Manager - Manages rebalancing and reranging of Talos Positions\ncontract TalosManager is AutomationCompatibleInterface, ITalosManager {\n    using PoolVariables for IUniswapV3Pool;\n\n    /*//////////////////////////////////////////////////////////////\n                        TALOS OPTIMIZER STATE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc ITalosManager\n    int24 public immutable ticksFromLowerRebalance;\n\n    /// @inheritdoc ITalosManager\n    int24 public immutable ticksFromUpperRebalance;\n\n    /// @inheritdoc ITalosManager\n    int24 public immutable ticksFromLowerRerange;\n\n    /// @inheritdoc ITalosManager\n    int24 public immutable ticksFromUpperRerange;\n\n    /// @inheritdoc ITalosManager\n    ITalosBaseStrategy public immutable strategy;\n\n    /**\n     * @notice Construct a new Talos Strategy Manager contract.\n     * @param _strategy Strategy to manage.\n     * @param _ticksFromLowerRebalance Ticks from lower tick to rebalance.\n     * @param _ticksFromUpperRebalance Ticks from upper tick to rebalance.\n     * @param _ticksFromLowerRerange Ticks from lower tick to rerange.\n     * @param _ticksFromUpperRerange Ticks from upper tick to rerange.\n     */\n    constructor(\n        address _strategy,\n        int24 _ticksFromLowerRebalance,\n        int24 _ticksFromUpperRebalance,\n        int24 _ticksFromLowerRerange,\n        int24 _ticksFromUpperRerange\n    ) {\n        strategy = ITalosBaseStrategy(_strategy);\n        ticksFromLowerRebalance = _ticksFromLowerRebalance;\n        ticksFromUpperRebalance = _ticksFromUpperRebalance;\n        ticksFromLowerRerange = _ticksFromLowerRerange;\n        ticksFromUpperRerange = _ticksFromUpperRerange;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        UPKEEP ACTION CHECKERS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Returns true if strategy needs to be rebalanced\n     * @dev Checks if current tick is in range, returns true if not\n     */\n    function getRebalance(ITalosBaseStrategy position) private view returns (bool) {\n        //Calculate base ticks.\n        (, int24 currentTick,,,,,) = position.pool().slot0();\n\n        return currentTick - position.tickLower() >= ticksFromLowerRebalance\n            || position.tickUpper() - currentTick >= ticksFromUpperRebalance;\n    }\n\n    /**\n     * @notice Returns true if strategy needs to be reranged\n     * @dev Checks if current tick is in range, returns true if not\n     */\n    function getRerange(ITalosBaseStrategy position) private view returns (bool) {\n        //Calculate base ticks.\n        (, int24 currentTick,,,,,) = position.pool().slot0();\n\n        return currentTick - position.tickLower() >= ticksFromLowerRerange\n            || position.tickUpper() - currentTick >= ticksFromUpperRerange;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            AUTOMATION\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc AutomationCompatibleInterface\n    function checkUpkeep(bytes calldata) external view override returns (bool upkeepNeeded, bytes memory performData) {\n        ITalosOptimizer optimizer = strategy.optimizer();\n\n        // checks if price has not moved a lot recently.\n        // This mitigates price manipulation during rebalance and also prevents placing orders when it's too volatile.\n        try strategy.pool().checkDeviation(optimizer.maxTwapDeviation(), optimizer.twapDuration()) {}\n        catch {\n            return (false, \"\");\n        }\n\n        if (getRebalance(strategy)) {\n            upkeepNeeded = true;\n        } else if (getRerange(strategy)) {\n            upkeepNeeded = true;\n        }\n\n        performData = \"\";\n    }\n\n    /// @inheritdoc AutomationCompatibleInterface\n    /// @notice Rebalances or Reranges an Optimizer's positions.\n    function performUpkeep(bytes calldata) external override {\n        if (getRebalance(strategy)) {\n            /**\n             * @dev Swaps imbalanced token. Finds base position and limit position for imbalanced token if\n             * we don't have balance during swap because of price impact.\n             * mints all amounts to this position(including earned fees)\n             */\n            strategy.rebalance();\n        } else if (getRerange(strategy)) {\n            /**\n             * @dev Finds base position and limit position for imbalanced token\n             * mints all amounts to this position(including earned fees)\n             */\n            strategy.rerange();\n        }\n    }\n}"
    }
  ]
}