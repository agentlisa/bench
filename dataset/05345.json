{
  "Title": "[G-18] Functions guaranteed to revert when called by normal users can be marked payable",
  "Content": "If a function modifier or require such as onlyOwner/onlyX is used, the function will revert if a normal user tries to pay the function. Marking the function as payable will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are CALLVALUE(2), DUP1(3), ISZERO(3), PUSH2(3), JUMPI(10), PUSH1(3), DUP1(3), REVERT(0), JUMPDEST(1), POP(2) which costs an average of about 21 gas per call to the function, in addition to the extra deployment cost.\nthe recommended Mitigation Steps is that Functions guaranteed to revert when called by normal users can be marked payable.\n\n### 55 Instances\n\n<Details>\n\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/governance/contracts/OLAS.sol#L43-#L54\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/governance/contracts/OLAS.sol#L58-#L69\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/governance/contracts/OLAS.sol#L75-#L85\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/governance/contracts/multisigs/GuardCM.sol#L441-#L487\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/governance/contracts/multisigs/GuardCM.sol#L495-#L532\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/governance/contracts/multisigs/GuardCM.sol#L539-#L557\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/governance/contracts/multisigs/GuardCM.sol#L560-#L569\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/governance/contracts/bridges/FxGovernorTunnel.sol#L81-#L95\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/governance/contracts/bridges/FxGovernorTunnel.sol#L107-#L168\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/governance/contracts/bridges/HomeMediator.sol#L81-#L95\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/governance/contracts/bridges/HomeMediator.sol#L105-#L169\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/governance/contracts/bridges/BridgedERC20.sol#L30-#L43\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/governance/contracts/bridges/BridgedERC20.sol#L48-#L55\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/governance/contracts/bridges/BridgedERC20.sol#L59-#L66\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/registries/contracts/GenericRegistry.sol#L37-#L50\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/registries/contracts/GenericRegistry.sol#L54-#L66\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/registries/contracts/GenericRegistry.sol#L78-#L91\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/registries/contracts/GenericRegistry.sol\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/registries/contracts/UnitRegistry.sol#L49-#L114\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/registries/contracts/UnitRegistry.sol#L121-#L147\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/registries/contracts/GenericManager.sol#L20-#L33\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/registries/contracts/GenericManager.sol#L36-#L44\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/registries/contracts/GenericManager.sol#L47-#L55\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Depository.sol#L123-#L136\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Depository.sol#L143-#L159\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Depository.sol#L163-#L173\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Depository.sol#L183-#L236\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Depository.sol#L244-#L277\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Dispenser.sol#L46-#L59\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Dispenser.sol#L64-#L80\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/DonatorBlacklist.sol#L36-#L49\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/DonatorBlacklist.sol#L56-#L77\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Tokenomics.sol#L384-#L400\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Tokenomics.sol#L404-#L417\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Tokenomics.sol#L423-#L444\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Tokenomics.sol#L450-#L469\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Tokenomics.sol#L474-#L482\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Tokenomics.sol#L497-#L553\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Tokenomics.sol#L562-#L602\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Tokenomics.sol#L609-#L625\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Tokenomics.sol#L630-#L644\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Tokenomics.sol#L788-#L825\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Tokenomics.sol#L1085-#L1151\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Treasury.sol#L137-#L150\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Treasury.sol#L156-#L177\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Treasury.sol#L182-#L200\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Treasury.sol#L212-#L245\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Treasury.sol#L313-#L371\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Treasury.sol#L387-#L420\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Treasury.sol#L428-#L458\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Treasury.sol#L466-#L483\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Treasury.sol#L487-#L503\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Treasury.sol#L507-#L521\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Treasury.sol#L531-#L539\n- https://github.com/code-423n4/2023-12-autonolas/blob/main/tokenomics/contracts/Treasury.sol#L542-#L550\n\n</details>\n\n## Conclusion\n\nAs you embark on incorporating the recommended optimizations, we want to emphasize the utmost importance of proceeding with vigilance and dedicating thorough efforts to comprehensive testing. It is of paramount significance to ensure that the proposed alterations do not inadvertently introduce fresh vulnerabilities, while also successfully achieving the anticipated enhancements in performance.\n\nWe strongly advise conducting a meticulous and exhaustive evaluation of the modifications made to the codebase. This rigorous scrutiny and exhaustive assessment will play a pivotal role in affirming both the security and efficacy of the refactored code. Your careful attention to detail, coupled with the implementation of a robust testing framework, will provide the necessary assurance that the refined code aligns with your security objectives and effectively fulfills the intended performance optimizations.\n\n\n**[kupermind (Olas) acknowledged](https://github.com/code-423n4/2023-12-autonolas-findings/issues/399#issuecomment-1893677639)**\n***\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-12-autonolas",
  "Code": [
    {
      "filename": "governance/contracts/OLAS.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"../lib/solmate/src/tokens/ERC20.sol\";\n\n/// @dev Only `manager` has a privilege, but the `sender` was provided.\n/// @param sender Sender address.\n/// @param manager Required sender address as a manager.\nerror ManagerOnly(address sender, address manager);\n\n/// @dev Provided zero address.\nerror ZeroAddress();\n\n/// @title OLAS - Smart contract for the OLAS token.\n/// @author AL\n/// @author Aleksandr Kuperman - <aleksandr.kuperman@valory.xyz>\ncontract OLAS is ERC20 {\n    event MinterUpdated(address indexed minter);\n    event OwnerUpdated(address indexed owner);\n\n    // One year interval\n    uint256 public constant oneYear = 1 days * 365;\n    // Total supply cap for the first ten years (one billion OLAS tokens)\n    uint256 public constant tenYearSupplyCap = 1_000_000_000e18;\n    // Maximum annual inflation after first ten years\n    uint256 public constant maxMintCapFraction = 2;\n    // Initial timestamp of the token deployment\n    uint256 public immutable timeLaunch;\n\n    // Owner address\n    address public owner;\n    // Minter address\n    address public minter;\n\n    constructor() ERC20(\"Autonolas\", \"OLAS\", 18) {\n        owner = msg.sender;\n        minter = msg.sender;\n        timeLaunch = block.timestamp;\n    }\n\n    /// @dev Changes the owner address.\n    /// @param newOwner Address of a new owner.\n    function changeOwner(address newOwner) external {\n        if (msg.sender != owner) {\n            revert ManagerOnly(msg.sender, owner);\n        }\n\n        if (newOwner == address(0)) {\n            revert ZeroAddress();\n        }\n\n        owner = newOwner;\n        emit OwnerUpdated(newOwner);\n    }\n\n    /// @dev Changes the minter address.\n    /// @param newMinter Address of a new minter.\n    function changeMinter(address newMinter) external {\n        if (msg.sender != owner) {\n            revert ManagerOnly(msg.sender, owner);\n        }\n\n        if (newMinter == address(0)) {\n            revert ZeroAddress();\n        }\n\n        minter = newMinter;\n        emit MinterUpdated(newMinter);\n    }\n\n    /// @dev Mints OLAS tokens.\n    /// @notice If the inflation control does not pass, the revert does not take place, as well as no action is performed.\n    /// @param account Account address.\n    /// @param amount OLAS token amount.\n    function mint(address account, uint256 amount) external {\n        // Access control\n        if (msg.sender != minter) {\n            revert ManagerOnly(msg.sender, minter);\n        }\n\n        // Check the inflation schedule and mint\n        if (inflationControl(amount)) {\n            _mint(account, amount);\n        }\n    }\n\n    /// @dev Provides various checks for the inflation control.\n    /// @notice The `<=` check is left as is for a better code readability.\n    /// @param amount Amount of OLAS to mint.\n    /// @return True if the amount request is within inflation boundaries.\n    function inflationControl(uint256 amount) public view returns (bool) {\n        uint256 remainder = inflationRemainder();\n        return (amount <= remainder);\n    }\n\n    /// @dev Gets the reminder of OLAS possible for the mint.\n    /// @return remainder OLAS token remainder.\n    function inflationRemainder() public view returns (uint256 remainder) {\n        uint256 _totalSupply = totalSupply;\n        // Current year\n        uint256 numYears = (block.timestamp - timeLaunch) / oneYear;\n        // Calculate maximum mint amount to date\n        uint256 supplyCap = tenYearSupplyCap;\n        // After 10 years, adjust supplyCap according to the yearly inflation % set in maxMintCapFraction\n        if (numYears > 9) {\n            // Number of years after ten years have passed (including ongoing ones)\n            numYears -= 9;\n            for (uint256 i = 0; i < numYears; ++i) {\n                supplyCap += (supplyCap * maxMintCapFraction) / 100;\n            }\n        }\n        // Check for the requested mint overflow\n        remainder = supplyCap - _totalSupply;\n    }\n\n    /// @dev Burns OLAS tokens.\n    /// @param amount OLAS token amount to burn.\n    function burn(uint256 amount) external {\n        _burn(msg.sender, amount);\n    }\n\n    /// @dev Decreases the allowance of another account over their tokens.\n    /// @notice This implementation does not decrease spender allowance if the maximum allowance was granted.\n    /// @notice The underflow condition is treated by the default code generation check.\n    /// @param spender Account that tokens are approved for.\n    /// @param amount Amount to decrease approval by.\n    /// @return True if the operation succeeded.\n    function decreaseAllowance(address spender, uint256 amount) external returns (bool) {\n        uint256 spenderAllowance = allowance[msg.sender][spender];\n\n        if (spenderAllowance != type(uint256).max) {\n            spenderAllowance -= amount;\n            allowance[msg.sender][spender] = spenderAllowance;\n            emit Approval(msg.sender, spender, spenderAllowance);\n        }\n\n        return true;\n    }\n\n    /// @dev Increases the allowance of another account over their tokens.\n    /// @notice The overflow condition is treated by the default code generation check.\n    /// @param spender Account that tokens are approved for.\n    /// @param amount Amount to increase approval by.\n    /// @return True if the operation succeeded.\n    function increaseAllowance(address spender, uint256 amount) external returns (bool) {\n        uint256 spenderAllowance = allowance[msg.sender][spender];\n\n        spenderAllowance += amount;\n        allowance[msg.sender][spender] = spenderAllowance;\n        emit Approval(msg.sender, spender, spenderAllowance);\n\n        return true;\n    }\n}"
    },
    {
      "filename": "governance/contracts/OLAS.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"../lib/solmate/src/tokens/ERC20.sol\";\n\n/// @dev Only `manager` has a privilege, but the `sender` was provided.\n/// @param sender Sender address.\n/// @param manager Required sender address as a manager.\nerror ManagerOnly(address sender, address manager);\n\n/// @dev Provided zero address.\nerror ZeroAddress();\n\n/// @title OLAS - Smart contract for the OLAS token.\n/// @author AL\n/// @author Aleksandr Kuperman - <aleksandr.kuperman@valory.xyz>\ncontract OLAS is ERC20 {\n    event MinterUpdated(address indexed minter);\n    event OwnerUpdated(address indexed owner);\n\n    // One year interval\n    uint256 public constant oneYear = 1 days * 365;\n    // Total supply cap for the first ten years (one billion OLAS tokens)\n    uint256 public constant tenYearSupplyCap = 1_000_000_000e18;\n    // Maximum annual inflation after first ten years\n    uint256 public constant maxMintCapFraction = 2;\n    // Initial timestamp of the token deployment\n    uint256 public immutable timeLaunch;\n\n    // Owner address\n    address public owner;\n    // Minter address\n    address public minter;\n\n    constructor() ERC20(\"Autonolas\", \"OLAS\", 18) {\n        owner = msg.sender;\n        minter = msg.sender;\n        timeLaunch = block.timestamp;\n    }\n\n    /// @dev Changes the owner address.\n    /// @param newOwner Address of a new owner.\n    function changeOwner(address newOwner) external {\n        if (msg.sender != owner) {\n            revert ManagerOnly(msg.sender, owner);\n        }\n\n        if (newOwner == address(0)) {\n            revert ZeroAddress();\n        }\n\n        owner = newOwner;\n        emit OwnerUpdated(newOwner);\n    }\n\n    /// @dev Changes the minter address.\n    /// @param newMinter Address of a new minter.\n    function changeMinter(address newMinter) external {\n        if (msg.sender != owner) {\n            revert ManagerOnly(msg.sender, owner);\n        }\n\n        if (newMinter == address(0)) {\n            revert ZeroAddress();\n        }\n\n        minter = newMinter;\n        emit MinterUpdated(newMinter);\n    }\n\n    /// @dev Mints OLAS tokens.\n    /// @notice If the inflation control does not pass, the revert does not take place, as well as no action is performed.\n    /// @param account Account address.\n    /// @param amount OLAS token amount.\n    function mint(address account, uint256 amount) external {\n        // Access control\n        if (msg.sender != minter) {\n            revert ManagerOnly(msg.sender, minter);\n        }\n\n        // Check the inflation schedule and mint\n        if (inflationControl(amount)) {\n            _mint(account, amount);\n        }\n    }\n\n    /// @dev Provides various checks for the inflation control.\n    /// @notice The `<=` check is left as is for a better code readability.\n    /// @param amount Amount of OLAS to mint.\n    /// @return True if the amount request is within inflation boundaries.\n    function inflationControl(uint256 amount) public view returns (bool) {\n        uint256 remainder = inflationRemainder();\n        return (amount <= remainder);\n    }\n\n    /// @dev Gets the reminder of OLAS possible for the mint.\n    /// @return remainder OLAS token remainder.\n    function inflationRemainder() public view returns (uint256 remainder) {\n        uint256 _totalSupply = totalSupply;\n        // Current year\n        uint256 numYears = (block.timestamp - timeLaunch) / oneYear;\n        // Calculate maximum mint amount to date\n        uint256 supplyCap = tenYearSupplyCap;\n        // After 10 years, adjust supplyCap according to the yearly inflation % set in maxMintCapFraction\n        if (numYears > 9) {\n            // Number of years after ten years have passed (including ongoing ones)\n            numYears -= 9;\n            for (uint256 i = 0; i < numYears; ++i) {\n                supplyCap += (supplyCap * maxMintCapFraction) / 100;\n            }\n        }\n        // Check for the requested mint overflow\n        remainder = supplyCap - _totalSupply;\n    }\n\n    /// @dev Burns OLAS tokens.\n    /// @param amount OLAS token amount to burn.\n    function burn(uint256 amount) external {\n        _burn(msg.sender, amount);\n    }\n\n    /// @dev Decreases the allowance of another account over their tokens.\n    /// @notice This implementation does not decrease spender allowance if the maximum allowance was granted.\n    /// @notice The underflow condition is treated by the default code generation check.\n    /// @param spender Account that tokens are approved for.\n    /// @param amount Amount to decrease approval by.\n    /// @return True if the operation succeeded.\n    function decreaseAllowance(address spender, uint256 amount) external returns (bool) {\n        uint256 spenderAllowance = allowance[msg.sender][spender];\n\n        if (spenderAllowance != type(uint256).max) {\n            spenderAllowance -= amount;\n            allowance[msg.sender][spender] = spenderAllowance;\n            emit Approval(msg.sender, spender, spenderAllowance);\n        }\n\n        return true;\n    }\n\n    /// @dev Increases the allowance of another account over their tokens.\n    /// @notice The overflow condition is treated by the default code generation check.\n    /// @param spender Account that tokens are approved for.\n    /// @param amount Amount to increase approval by.\n    /// @return True if the operation succeeded.\n    function increaseAllowance(address spender, uint256 amount) external returns (bool) {\n        uint256 spenderAllowance = allowance[msg.sender][spender];\n\n        spenderAllowance += amount;\n        allowance[msg.sender][spender] = spenderAllowance;\n        emit Approval(msg.sender, spender, spenderAllowance);\n\n        return true;\n    }\n}"
    },
    {
      "filename": "governance/contracts/OLAS.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"../lib/solmate/src/tokens/ERC20.sol\";\n\n/// @dev Only `manager` has a privilege, but the `sender` was provided.\n/// @param sender Sender address.\n/// @param manager Required sender address as a manager.\nerror ManagerOnly(address sender, address manager);\n\n/// @dev Provided zero address.\nerror ZeroAddress();\n\n/// @title OLAS - Smart contract for the OLAS token.\n/// @author AL\n/// @author Aleksandr Kuperman - <aleksandr.kuperman@valory.xyz>\ncontract OLAS is ERC20 {\n    event MinterUpdated(address indexed minter);\n    event OwnerUpdated(address indexed owner);\n\n    // One year interval\n    uint256 public constant oneYear = 1 days * 365;\n    // Total supply cap for the first ten years (one billion OLAS tokens)\n    uint256 public constant tenYearSupplyCap = 1_000_000_000e18;\n    // Maximum annual inflation after first ten years\n    uint256 public constant maxMintCapFraction = 2;\n    // Initial timestamp of the token deployment\n    uint256 public immutable timeLaunch;\n\n    // Owner address\n    address public owner;\n    // Minter address\n    address public minter;\n\n    constructor() ERC20(\"Autonolas\", \"OLAS\", 18) {\n        owner = msg.sender;\n        minter = msg.sender;\n        timeLaunch = block.timestamp;\n    }\n\n    /// @dev Changes the owner address.\n    /// @param newOwner Address of a new owner.\n    function changeOwner(address newOwner) external {\n        if (msg.sender != owner) {\n            revert ManagerOnly(msg.sender, owner);\n        }\n\n        if (newOwner == address(0)) {\n            revert ZeroAddress();\n        }\n\n        owner = newOwner;\n        emit OwnerUpdated(newOwner);\n    }\n\n    /// @dev Changes the minter address.\n    /// @param newMinter Address of a new minter.\n    function changeMinter(address newMinter) external {\n        if (msg.sender != owner) {\n            revert ManagerOnly(msg.sender, owner);\n        }\n\n        if (newMinter == address(0)) {\n            revert ZeroAddress();\n        }\n\n        minter = newMinter;\n        emit MinterUpdated(newMinter);\n    }\n\n    /// @dev Mints OLAS tokens.\n    /// @notice If the inflation control does not pass, the revert does not take place, as well as no action is performed.\n    /// @param account Account address.\n    /// @param amount OLAS token amount.\n    function mint(address account, uint256 amount) external {\n        // Access control\n        if (msg.sender != minter) {\n            revert ManagerOnly(msg.sender, minter);\n        }\n\n        // Check the inflation schedule and mint\n        if (inflationControl(amount)) {\n            _mint(account, amount);\n        }\n    }\n\n    /// @dev Provides various checks for the inflation control.\n    /// @notice The `<=` check is left as is for a better code readability.\n    /// @param amount Amount of OLAS to mint.\n    /// @return True if the amount request is within inflation boundaries.\n    function inflationControl(uint256 amount) public view returns (bool) {\n        uint256 remainder = inflationRemainder();\n        return (amount <= remainder);\n    }\n\n    /// @dev Gets the reminder of OLAS possible for the mint.\n    /// @return remainder OLAS token remainder.\n    function inflationRemainder() public view returns (uint256 remainder) {\n        uint256 _totalSupply = totalSupply;\n        // Current year\n        uint256 numYears = (block.timestamp - timeLaunch) / oneYear;\n        // Calculate maximum mint amount to date\n        uint256 supplyCap = tenYearSupplyCap;\n        // After 10 years, adjust supplyCap according to the yearly inflation % set in maxMintCapFraction\n        if (numYears > 9) {\n            // Number of years after ten years have passed (including ongoing ones)\n            numYears -= 9;\n            for (uint256 i = 0; i < numYears; ++i) {\n                supplyCap += (supplyCap * maxMintCapFraction) / 100;\n            }\n        }\n        // Check for the requested mint overflow\n        remainder = supplyCap - _totalSupply;\n    }\n\n    /// @dev Burns OLAS tokens.\n    /// @param amount OLAS token amount to burn.\n    function burn(uint256 amount) external {\n        _burn(msg.sender, amount);\n    }\n\n    /// @dev Decreases the allowance of another account over their tokens.\n    /// @notice This implementation does not decrease spender allowance if the maximum allowance was granted.\n    /// @notice The underflow condition is treated by the default code generation check.\n    /// @param spender Account that tokens are approved for.\n    /// @param amount Amount to decrease approval by.\n    /// @return True if the operation succeeded.\n    function decreaseAllowance(address spender, uint256 amount) external returns (bool) {\n        uint256 spenderAllowance = allowance[msg.sender][spender];\n\n        if (spenderAllowance != type(uint256).max) {\n            spenderAllowance -= amount;\n            allowance[msg.sender][spender] = spenderAllowance;\n            emit Approval(msg.sender, spender, spenderAllowance);\n        }\n\n        return true;\n    }\n\n    /// @dev Increases the allowance of another account over their tokens.\n    /// @notice The overflow condition is treated by the default code generation check.\n    /// @param spender Account that tokens are approved for.\n    /// @param amount Amount to increase approval by.\n    /// @return True if the operation succeeded.\n    function increaseAllowance(address spender, uint256 amount) external returns (bool) {\n        uint256 spenderAllowance = allowance[msg.sender][spender];\n\n        spenderAllowance += amount;\n        allowance[msg.sender][spender] = spenderAllowance;\n        emit Approval(msg.sender, spender, spenderAllowance);\n\n        return true;\n    }\n}"
    },
    {
      "filename": "governance/contracts/multisigs/GuardCM.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport {Enum} from \"@gnosis.pm/safe-contracts/contracts/common/Enum.sol\";\n\ninterface IGovernor {\n    function state(uint256 proposalId) external returns (ProposalState);\n}\n\n// Governor proposal state\nenum ProposalState {\n    Pending,\n    Active,\n    Canceled,\n    Defeated,\n    Succeeded,\n    Queued,\n    Expired,\n    Executed\n}\n\n/// @dev Only `owner` has a privilege, but the `sender` was provided.\n/// @param sender Sender address.\n/// @param owner Required sender address as an owner.\nerror OwnerOnly(address sender, address owner);\n\n/// @dev Only `manager` has a privilege, but the `sender` was provided.\n/// @param sender Sender address.\n/// @param manager Required sender address as an owner.\nerror ManagerOnly(address sender, address manager);\n\n/// @dev Provided zero address.\nerror ZeroAddress();\n\n/// @dev Provided zero value.\nerror ZeroValue();\n\n/// @dev Wrong length of two arrays.\n/// @param numValues1 Number of values in a first array.\n/// @param numValues2 Numberf of values in a second array.\n/// @param numValues3 Numberf of values in a third array.\n/// @param numValues4 Numberf of values in a fourth array.\nerror WrongArrayLength(uint256 numValues1, uint256 numValues2, uint256 numValues3, uint256 numValues4);\n\n/// @dev Provided bridged mediator is not unique.\n/// @param bridgeMediator Bridge mediator address.\nerror BridgeMediatorNotUnique(address bridgeMediator);\n\n/// @dev Provided incorrect data length.\n/// @param expected Expected minimum data length.\n/// @param provided Provided data length.\nerror IncorrectDataLength(uint256 expected, uint256 provided);\n\n/// @dev No delegatecall is allowed.\nerror NoDelegateCall();\n\n/// @dev No self multisig call is allowed.\nerror NoSelfCall();\n\n/// @dev The combination of target and selector is not authorized.\n/// @param target Target address.\n/// @param selector Function selector.\n/// @param chainId Chain Id.\nerror NotAuthorized(address target, bytes4 selector, uint256 chainId);\n\n/// @dev The proposal is not defeated.\n/// @param proposalId Proposal Id.\n/// @param state Current proposal state.\nerror NotDefeated(uint256 proposalId, ProposalState state);\n\n/// @dev Passed L2 chain Id is not supported.\n/// @param chainId L2 chain Id.\nerror L2ChainIdNotSupported(uint256 chainId);\n\n/// @dev Provided wrong function selector.\n/// @param functionSig Function selector.\n/// @param chainId Chain Id.\nerror WrongSelector(bytes4 functionSig, uint256 chainId);\n\n/// @dev Provided wrong L2 bridge mediator address.\n/// @param provided Provided address.\n/// @param expected Expected address.\nerror WrongL2BridgeMediator(address provided, address expected);\n\n/// @title GuardCM - Smart contract for Gnosis Safe community multisig (CM) guard\n/// @author Aleksandr Kuperman - <aleksandr.kuperman@valory.xyz>\n/// @author Andrey Lebedev - <andrey.lebedev@valory.xyz>\ncontract GuardCM {\n    event GovernorUpdated(address indexed governor);\n    event SetTargetSelectors(address[] indexed targets, bytes4[] indexed selectors, uint256[] chainIds, bool[] statuses);\n    event SetBridgeMediators(address[] indexed bridgeMediatorL1s, address[] indexed bridgeMediatorL2s, uint256[] chainIds);\n    event GovernorCheckProposalIdChanged(uint256 indexed proposalId);\n    event GuardPaused(address indexed account);\n    event GuardUnpaused();\n\n    // schedule selector\n    bytes4 public constant SCHEDULE = bytes4(keccak256(bytes(\"schedule(address,uint256,bytes,bytes32,bytes32,uint256)\")));\n    // scheduleBatch selector\n    bytes4 public constant SCHEDULE_BATCH = bytes4(keccak256(bytes(\"scheduleBatch(address[],uint256[],bytes[],bytes32,bytes32,uint256)\")));\n    // requireToPassMessage selector (Gnosis chain)\n    bytes4 public constant REQUIRE_TO_PASS_MESSAGE = bytes4(keccak256(bytes(\"requireToPassMessage(address,bytes,uint256)\")));\n    // processMessageFromForeign selector (Gnosis chain)\n    bytes4 public constant PROCESS_MESSAGE_FROM_FOREIGN = bytes4(keccak256(bytes(\"processMessageFromForeign(bytes)\")));\n    // sendMessageToChild selector (Polygon)\n    bytes4 public constant SEND_MESSAGE_TO_CHILD = bytes4(keccak256(bytes(\"sendMessageToChild(address,bytes)\")));\n    // Initial check governance proposal Id\n    // Calculated from the proposalHash function of the GovernorOLAS\n    uint256 public governorCheckProposalId = 88250008686885504216650933897987879122244685460173810624866685274624741477673;\n    // Minimum data length that is encoded for the schedule function,\n    // plus at least 4 bytes or 32 bits for the selector from the payload\n    uint256 public constant MIN_SCHEDULE_DATA_LENGTH = 260;\n    // Minimum data length that contains at least a selector (4 bytes or 32 bits)\n    uint256 public constant SELECTOR_DATA_LENGTH = 4;\n    // Minimum payload length for message on Gnosis accounting for all required encoding and at least one selector\n    uint256 public constant MIN_GNOSIS_PAYLOAD_LENGTH = 292;\n    // Minimum payload length for message on Polygon accounting for all required encoding and at least one selector\n    uint256 public constant MIN_POLYGON_PAYLOAD_LENGTH = 164;\n\n    // Owner address\n    address public immutable owner;\n    // Multisig address\n    address public immutable multisig;\n\n    // Governor address\n    address public governor;\n    // Guard pausing possibility\n    uint8 public paused = 1;\n\n    // Mapping of (target address | bytes4 selector | uint64 chain Id) => enabled / disabled\n    mapping(uint256 => bool) public mapAllowedTargetSelectorChainIds;\n    // Mapping of bridge mediator address L1 => (bridge mediator L2 address | uint64 supported L2 chain Id)\n    mapping(address => uint256) public mapBridgeMediatorL1L2ChainIds;\n\n    /// @dev GuardCM constructor.\n    /// @param _timelock Timelock address.\n    /// @param _multisig Community multisig address.\n    /// @param _governor Governor address.\n    constructor(\n        address _timelock,\n        address _multisig,\n        address _governor\n    ) {\n        // Check for zero addresses\n        if (_timelock == address(0) || _multisig == address(0) || _governor == address(0)) {\n            revert ZeroAddress();\n        }\n        owner = _timelock;\n        multisig = _multisig;\n        governor = _governor;\n    }\n\n    /// @dev Changes the governor.\n    /// @param newGovernor Address of a new governor.\n    function changeGovernor(address newGovernor) external {\n        if (msg.sender != owner) {\n            revert OwnerOnly(msg.sender, owner);\n        }\n\n        // Check for the zero address\n        if (newGovernor == address(0)) {\n            revert ZeroAddress();\n        }\n\n        governor = newGovernor;\n        emit GovernorUpdated(newGovernor);\n    }\n\n    /// @dev Changes the governor check proposal Id.\n    /// @param proposalId Governor check proposal Id.\n    function changeGovernorCheckProposalId(uint256 proposalId) external {\n        if (msg.sender != owner) {\n            revert OwnerOnly(msg.sender, owner);\n        }\n\n        // Check for the zero value\n        if (proposalId == 0) {\n            revert ZeroValue();\n        }\n\n        governorCheckProposalId = proposalId;\n        emit GovernorCheckProposalIdChanged(proposalId);\n    }\n\n    /// @dev Verifies authorized combinations of target and selector.\n    /// @notice The bottom-most internal function is still not \"view\" since some reverts are not explicitly handled\n    /// @param target Target address.\n    /// @param data Payload bytes.\n    /// @param chainId Chain Id.\n    function _verifyData(address target, bytes memory data, uint256 chainId) internal {\n        // Push a pair of key defining variables into one key\n        // target occupies first 160 bits\n        uint256 targetSelectorChainId = uint256(uint160(target));\n        // selector occupies next 32 bits\n        targetSelectorChainId |= uint256(uint32(bytes4(data))) << 160;\n        // chainId occupies next 64 bits\n        targetSelectorChainId |= chainId << 192;\n\n        // Check the authorized combination of target and selector\n        if (!mapAllowedTargetSelectorChainIds[targetSelectorChainId]) {\n            revert NotAuthorized(target, bytes4(data), chainId);\n        }\n    }\n\n    /// @dev Verifies the bridged data for authorized combinations of targets and selectors.\n    /// @notice The processed data is packed as a set of bytes that are assembled using the following parameters:\n    ///         address target, uint96 value, uint32 payloadLength, bytes payload.\n    /// @param data Payload bytes.\n    /// @param chainId L2 chain Id.\n    function _verifyBridgedData(bytes memory data, uint256 chainId) internal {\n        // Unpack and process the data\n        // We need to skip first 12 bytes as those are zeros from encoding\n        for (uint256 i = 0; i < data.length;) {\n            address target;\n            uint32 payloadLength;\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                // First 20 bytes is the address (160 bits)\n                i := add(i, 20)\n                target := mload(add(data, i))\n                // Offset the data by 12 bytes of value (96 bits) and by 4 bytes of payload length (32 bits)\n                i := add(i, 16)\n                payloadLength := mload(add(data, i))\n            }\n\n            // Check for the zero address\n            if (target == address(0)) {\n                revert ZeroAddress();\n            }\n\n            // The payload length must be at least of the a function selector size\n            if (payloadLength < SELECTOR_DATA_LENGTH) {\n                revert IncorrectDataLength(payloadLength, SELECTOR_DATA_LENGTH);\n            }\n\n            // Get the payload\n            bytes memory payload = new bytes(payloadLength);\n            for (uint256 j = 0; j < payloadLength; ++j) {\n                payload[j] = data[i + j];\n            }\n            // Offset the data by the payload number of bytes\n            i += payloadLength;\n\n            // Verify the scope of the data\n            _verifyData(target, payload, chainId);\n        }\n    }\n\n    /// @dev Processes bridged data: checks the header and verifies the payload.\n    /// @param data Full data bytes with the header.\n    /// @param bridgeMediatorL2 Address of a bridged mediator on L2.\n    /// @param chainId L2 chain Id.\n    function _processBridgeData(\n        bytes memory data,\n        address bridgeMediatorL2,\n        uint256 chainId\n    ) internal\n    {\n        // Gnosis chains\n        if (chainId == 100 || chainId == 10200) {\n            // Check the L1 initial selector\n            bytes4 functionSig = bytes4(data);\n            if (functionSig != REQUIRE_TO_PASS_MESSAGE) {\n                revert WrongSelector(functionSig, chainId);\n            }\n\n            // Check if the data length is less than a size of a selector plus the message minimum payload size\n            if (data.length < MIN_GNOSIS_PAYLOAD_LENGTH) {\n                revert IncorrectDataLength(data.length, MIN_GNOSIS_PAYLOAD_LENGTH);\n            }\n\n            // Copy the data without the selector\n            bytes memory payload = new bytes(data.length - SELECTOR_DATA_LENGTH);\n            for (uint256 i = 0; i < payload.length; ++i) {\n                payload[i] = data[i + 4];\n            }\n\n            // Decode the requireToPassMessage payload: homeMediator (L2), mediatorPayload (need decoding), requestGasLimit\n            (address homeMediator, bytes memory mediatorPayload, ) = abi.decode(payload, (address, bytes, uint256));\n            // Check that the home mediator matches the L2 bridge mediator address\n            if (homeMediator != bridgeMediatorL2) {\n                revert WrongL2BridgeMediator(homeMediator, bridgeMediatorL2);\n            }\n\n            // Check the L2 initial selector\n            functionSig = bytes4(mediatorPayload);\n            if (functionSig != PROCESS_MESSAGE_FROM_FOREIGN) {\n                revert WrongSelector(functionSig, chainId);\n            }\n\n            // Copy the data without a selector\n            bytes memory bridgePayload = new bytes(mediatorPayload.length - SELECTOR_DATA_LENGTH);\n            for (uint256 i = 0; i < bridgePayload.length; ++i) {\n                bridgePayload[i] = mediatorPayload[i + SELECTOR_DATA_LENGTH];\n            }\n\n            // Decode the processMessageFromForeign payload: l2Message (executed on L2)\n            (bytes memory l2Message) = abi.decode(bridgePayload, (bytes));\n\n            // Verify processMessageFromForeign payload\n            _verifyBridgedData(l2Message, chainId);\n        }\n\n        // Polygon chains\n        if (chainId == 137 || chainId == 80001) {\n            // Check the L1 initial selector\n            bytes4 functionSig = bytes4(data);\n            if (functionSig != SEND_MESSAGE_TO_CHILD) {\n                revert WrongSelector(functionSig, chainId);\n            }\n\n            // Check if the data length is less than a size of a selector plus the message minimum payload size\n            if (data.length < MIN_POLYGON_PAYLOAD_LENGTH) {\n                revert IncorrectDataLength(data.length, MIN_POLYGON_PAYLOAD_LENGTH);\n            }\n\n            // Copy the data without the selector\n            bytes memory payload = new bytes(data.length - SELECTOR_DATA_LENGTH);\n            for (uint256 i = 0; i < payload.length; ++i) {\n                payload[i] = data[i + SELECTOR_DATA_LENGTH];\n            }\n\n            // Decode sendMessageToChild payload: fxGovernorTunnel (L2), l2Message (executed on L2)\n            (address fxGovernorTunnel, bytes memory l2Message) = abi.decode(payload, (address, bytes));\n            // Check that the fxGovernorTunnel matches the L2 bridge mediator address\n            if (fxGovernorTunnel != bridgeMediatorL2) {\n                revert WrongL2BridgeMediator(fxGovernorTunnel, bridgeMediatorL2);\n            }\n\n            // Verify sendMessageToChild payload\n            _verifyBridgedData(l2Message, chainId);\n        }\n    }\n\n    /// @dev Verifies authorized target and selector in the schedule or scheduleBatch function call.\n    /// @param data Data in bytes.\n    /// @param selector Schedule function selector.\n    function _verifySchedule(bytes memory data, bytes4 selector) internal {\n        // Copy the data without the selector\n        bytes memory payload = new bytes(data.length - SELECTOR_DATA_LENGTH);\n        for (uint256 i = 0; i < payload.length; ++i) {\n            payload[i] = data[i + 4];\n        }\n\n        // Prepare the decoding data sets\n        address[] memory targets;\n        bytes[] memory callDatas;\n        if (selector == SCHEDULE) {\n            targets = new address[](1);\n            callDatas = new bytes[](1);\n            // Decode the data in the schedule function\n            (targets[0], , callDatas[0], , , ) =\n                abi.decode(payload, (address, uint256, bytes, bytes32, bytes32, uint256));\n        } else {\n            // Decode the data in the scheduleBatch function\n            (targets, , callDatas, , , ) =\n            abi.decode(payload, (address[], uint256[], bytes[], bytes32, bytes32, uint256));\n        }\n\n        // Traverse all the schedule targets and selectors extracted from calldatas\n        for (uint i = 0; i < targets.length; ++i) {\n            // Get the bridgeMediatorL2 and L2 chain Id, if any\n            uint256 bridgeMediatorL2ChainId = mapBridgeMediatorL1L2ChainIds[targets[i]];\n            // bridgeMediatorL2 occupies first 160 bits\n            address bridgeMediatorL2 = address(uint160(bridgeMediatorL2ChainId));\n\n            // Check if the data goes acro"
    }
  ]
}