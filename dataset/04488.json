{
  "Title": "Interest rate calculation may be errorÂ prone",
  "Content": "The Solo contracts calculate interest accumulated over time by incrementing an `index` which represents the total accumulated interest with a starting value of 1. The index is updated by taking the [per-second interest rate and multiplying by the number of seconds elapsed since the last time the index was updated](https://github.com/dydxprotocol/solo/blob/17df84db351d5438e1b7437572722b4f52c8b2b4/contracts/protocol/lib/Interest.sol#L74) (`percentageInterestSinceLastUpdate = perSecondRate * (currentTime - lastUpdatedTime)`). This number represents the percentage gained since the last calculation and is multiplied by the previous index value to calculate the updated index value (`index = index * (1 + percentageInterestSinceLastUpdate)`).\n\n\nThis calculation differs from the true calculation which would calculate `percentageInterestSinceLastUpdate` like so: `percentageInterestSinceLastUpdate = (currentTime - lastUpdated) ^ marginalRate`. The differences between the calculation used and the true calculation are negligible when the `index` is updated fairly frequently but start to diverge as the `index` is updated less frequently. Consider implementing the true interest calculation or properly documenting the current interest calculation.\n\n\n***Update:*** *The function was better documented in* [*pull request #218*](https://github.com/dydxprotocol/solo/pull/218)*.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/protocol/lib/Interest.sol",
      "content": "/*\n\n    Copyright 2018 dYdX Trading Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.4;\n\nimport { SafeMath } from \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport { Decimal } from \"./Decimal.sol\";\nimport { Math } from \"./Math.sol\";\nimport { Time } from \"./Time.sol\";\nimport { Types } from \"./Types.sol\";\n\n\n/**\n * @title Interest\n * @author dYdX\n *\n * Library for managing the interest rate and indexes of Solo\n */\nlibrary Interest {\n    using Math for uint256;\n    using SafeMath for uint256;\n\n    // ============ Constants ============\n\n    bytes32 constant FILE = \"Interest\";\n    uint64 constant BASE = 10**18;\n\n    // ============ Structs ============\n\n    struct Rate {\n        uint256 value;\n    }\n\n    struct Index {\n        uint96 borrow;\n        uint96 supply;\n        uint32 lastUpdate;\n    }\n\n    // ============ Library Functions ============\n\n    function calculateNewIndex(\n        Index memory index,\n        Rate memory rate,\n        Types.TotalPar memory totalPar,\n        Decimal.D256 memory earningsRate\n    )\n        internal\n        view\n        returns (Index memory)\n    {\n        (\n            Types.Wei memory supplyWei,\n            Types.Wei memory borrowWei\n        ) = totalParToWei(totalPar, index);\n\n        // calculate the interest accrued by\n        uint32 currentTime = Time.currentTime();\n        uint256 borrowInterest = rate.value.mul(uint256(currentTime).sub(index.lastUpdate));\n\n        // adjust the interest by the earningsRate, then prorate the interest across all suppliers\n        uint256 supplyInterest;\n        if (Types.isZero(supplyWei)) {\n            supplyInterest = 0;\n        } else {\n            supplyInterest = Decimal.mul(borrowInterest, earningsRate);\n            if (borrowWei.value < supplyWei.value) {\n                supplyInterest = Math.getPartial(supplyInterest, borrowWei.value, supplyWei.value);\n            }\n        }\n        assert(supplyInterest <= borrowInterest);\n\n        return Index({\n            borrow: Math.getPartial(index.borrow, borrowInterest, BASE).add(index.borrow).to96(),\n            supply: Math.getPartial(index.supply, supplyInterest, BASE).add(index.supply).to96(),\n            lastUpdate: currentTime\n        });\n    }\n\n    function newIndex()\n        internal\n        view\n        returns (Index memory)\n    {\n        return Index({\n            borrow: BASE,\n            supply: BASE,\n            lastUpdate: Time.currentTime()\n        });\n    }\n\n    function parToWei(\n        Types.Par memory input,\n        Index memory index\n    )\n        internal\n        pure\n        returns (Types.Wei memory)\n    {\n        uint256 inputValue = uint256(input.value);\n        if (input.sign) {\n            return Types.Wei({\n                sign: true,\n                value: inputValue.getPartial(index.supply, BASE)\n            });\n        } else {\n            return Types.Wei({\n                sign: false,\n                value: inputValue.getPartialRoundUp(index.borrow, BASE)\n            });\n        }\n    }\n\n    function weiToPar(\n        Types.Wei memory input,\n        Index memory index\n    )\n        internal\n        pure\n        returns (Types.Par memory)\n    {\n        if (input.sign) {\n            return Types.Par({\n                sign: true,\n                value: input.value.getPartial(BASE, index.supply).to128()\n            });\n        } else {\n            return Types.Par({\n                sign: false,\n                value: input.value.getPartialRoundUp(BASE, index.borrow).to128()\n            });\n        }\n    }\n\n    function totalParToWei(\n        Types.TotalPar memory totalPar,\n        Index memory index\n    )\n        internal\n        pure\n        returns (Types.Wei memory, Types.Wei memory)\n    {\n        Types.Par memory supplyPar = Types.Par({\n            sign: true,\n            value: totalPar.supply\n        });\n        Types.Par memory borrowPar = Types.Par({\n            sign: false,\n            value: totalPar.borrow\n        });\n        Types.Wei memory supplyWei = parToWei(supplyPar, index);\n        Types.Wei memory borrowWei = parToWei(borrowPar, index);\n        return (supplyWei, borrowWei);\n    }\n}"
    }
  ]
}