{
  "Title": "L2MessageQueue Stores Incorrect Value if not Initialized Before Appending",
  "Content": "In `L2MessageQueue` it is expected that `initialize` is called before `appendMessage`. This initializes the [`zeroHashes` array](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/libraries/common/AppendOnlyMerkleTree.sol#L17). If however, it is not, [`appendMessage`](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L2/predeploys/L2MessageQueue.sol#L33) can still be called. On the 5th message sent, the wrong Merkle tree will be calculated (since at that point the calculation starts using the `zeroHashes[1]` value). After that point, even if `initialize` is called, it is too late, since messages cannot be removed and the contract is not upgradeable.\n\n\nFortunately, `appendMessage` can [only be called by the `messenger`](https://github.com/scroll-tech/scroll/blob/3bc8a3f5c6ac816ddffadca41024331dcf4d3064/contracts/src/L2/predeploys/L2MessageQueue.sol#L34), which makes this scenario unlikely.\n\n\nConsider adding a safeguard so that `appendMessage` cannot be called until `initialize` is called first.\n\n\n***Update:** Resolved in [pull request #630](https://github.com/scroll-tech/scroll/pull/630) at commit [89814bd](https://github.com/scroll-tech/scroll/pull/630/commits/89814bde4c28901839b659409ed55b57af4ade23).*\n\n\n",
  "Impact": "MEDIUM",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/src/libraries/common/AppendOnlyMerkleTree.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nabstract contract AppendOnlyMerkleTree {\n    /// @dev The maximum height of the withdraw merkle tree.\n    uint256 private constant MAX_TREE_HEIGHT = 40;\n\n    /// @notice The merkle root of the current merkle tree.\n    /// @dev This is actual equal to `branches[n]`.\n    bytes32 public messageRoot;\n\n    /// @notice The next unused message index.\n    uint256 public nextMessageIndex;\n\n    /// @notice The list of zero hash in each height.\n    bytes32[MAX_TREE_HEIGHT] private zeroHashes;\n\n    /// @notice The list of minimum merkle proofs needed to compute next root.\n    /// @dev Only first `n` elements are used, where `n` is the minimum value that `2^{n-1} >= currentMaxNonce + 1`.\n    /// It means we only use `currentMaxNonce + 1` leaf nodes to construct the merkle tree.\n    bytes32[MAX_TREE_HEIGHT] public branches;\n\n    function _initializeMerkleTree() internal {\n        // Compute hashes in empty sparse Merkle tree\n        for (uint256 height = 0; height + 1 < MAX_TREE_HEIGHT; height++) {\n            zeroHashes[height + 1] = _efficientHash(zeroHashes[height], zeroHashes[height]);\n        }\n    }\n\n    function _appendMessageHash(bytes32 _messageHash) internal returns (uint256, bytes32) {\n        uint256 _currentMessageIndex = nextMessageIndex;\n        bytes32 _hash = _messageHash;\n        uint256 _height = 0;\n\n        while (_currentMessageIndex != 0) {\n            if (_currentMessageIndex % 2 == 0) {\n                // it may be used in next round.\n                branches[_height] = _hash;\n                // it's a left child, the right child must be null\n                _hash = _efficientHash(_hash, zeroHashes[_height]);\n            } else {\n                // it's a right child, use previously computed hash\n                _hash = _efficientHash(branches[_height], _hash);\n            }\n            unchecked {\n                _height += 1;\n            }\n            _currentMessageIndex >>= 1;\n        }\n\n        branches[_height] = _hash;\n        messageRoot = _hash;\n\n        _currentMessageIndex = nextMessageIndex;\n        unchecked {\n            nextMessageIndex = _currentMessageIndex + 1;\n        }\n\n        return (_currentMessageIndex, _hash);\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}"
    },
    {
      "filename": "contracts/src/L2/predeploys/L2MessageQueue.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {AppendOnlyMerkleTree} from \"../../libraries/common/AppendOnlyMerkleTree.sol\";\nimport {OwnableBase} from \"../../libraries/common/OwnableBase.sol\";\n\n/// @title L2MessageQueue\n/// @notice The original idea is from Optimism, see [OVM_L2ToL1MessagePasser](https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts/contracts/L2/predeploys/OVM_L2ToL1MessagePasser.sol).\n/// The L2 to L1 Message Passer is a utility contract which facilitate an L1 proof of the\n/// of a message on L2. The L1 Cross Domain Messenger performs this proof in its\n/// _verifyStorageProof function, which verifies the existence of the transaction hash in this\n/// contract's `sentMessages` mapping.\ncontract L2MessageQueue is AppendOnlyMerkleTree, OwnableBase {\n    /// @notice Emitted when a new message is added to the merkle tree.\n    /// @param index The index of the corresponding message.\n    /// @param messageHash The hash of the corresponding message.\n    event AppendMessage(uint256 index, bytes32 messageHash);\n\n    /// @notice The address of L2ScrollMessenger contract.\n    address public messenger;\n\n    constructor(address _owner) {\n        _transferOwnership(_owner);\n    }\n\n    function initialize() external {\n        _initializeMerkleTree();\n    }\n\n    /// @notice record the message to merkle tree and compute the new root.\n    /// @param _messageHash The hash of the new added message.\n    function appendMessage(bytes32 _messageHash) external returns (bytes32) {\n        require(msg.sender == messenger, \"only messenger\");\n\n        (uint256 _currentNonce, bytes32 _currentRoot) = _appendMessageHash(_messageHash);\n\n        // We can use the event to compute the merkle tree locally.\n        emit AppendMessage(_currentNonce, _messageHash);\n\n        return _currentRoot;\n    }\n\n    /// @notice Update the address of messenger.\n    /// @dev You are not allowed to update messenger when there are some messages appended.\n    /// @param _messenger The address of messenger to update.\n    function updateMessenger(address _messenger) external onlyOwner {\n        require(nextMessageIndex == 0, \"cannot update messenger\");\n\n        messenger = _messenger;\n    }\n}"
    }
  ]
}