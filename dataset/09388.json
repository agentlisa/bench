{
  "Title": "[M-08] `_decimalMultiplier` doesn't account for tokens with decimals higher than 18",
  "Content": "_Submitted by shenwilly, also found by pauliax, StyxRave, and WatchPug_\n\n[StrategySwapper.sol#L287-L289](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/strategies/StrategySwapper.sol#L287-L289)<br>\n[StrategySwapper.sol#L318-L320](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/strategies/StrategySwapper.sol#L318-L320)<br>\n[StrategySwapper.sol#L335-L337](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/strategies/StrategySwapper.sol#L335-L337)<br>\n\nIn `StrategySwapper`, swapping from or to tokens with decimals higher than 18 will always revert. This will cause inabilities for strategies to harvest rewards.\n\n### Proof of Concept\n\n[L288](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/strategies/StrategySwapper.sol#L288) will revert when `token_` has higher than 18 decimals.\n\n     return 10**(18 - IERC20Full(token_).decimals());\n\n### Recommended Mitigation Steps\n\nConsider modifying how `_decimalMultiplier` works so it could handle tokens with higher than 18 decimals.\n\nUpdate the calculation of `_minTokenAmountOut` and `_minWethAmountOut` to account when decimals are higher/lower than `18`.\n\n**[chase-manning (Backd) confirmed and resolved](https://github.com/code-423n4/2022-04-backd-findings/issues/49)**\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-04-backd-contest",
  "Code": [
    {
      "filename": "backd/contracts/strategies/StrategySwapper.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../interfaces/IAddressProvider.sol\";\nimport \"../access/Authorization.sol\";\nimport \"./IStrategySwapper.sol\";\nimport \"../../interfaces/vendor/UniswapRouter02.sol\";\nimport \"../../interfaces/vendor/ICurveSwapEth.sol\";\nimport \"../../libraries/ScaledMath.sol\";\nimport \"../../libraries/AddressProviderHelpers.sol\";\nimport \"../../interfaces/IERC20Full.sol\";\nimport \"../../interfaces/vendor/IWETH.sol\";\n\ncontract StrategySwapper is IStrategySwapper, Authorization {\n    using ScaledMath for uint256;\n    using SafeERC20 for IERC20;\n    using AddressProviderHelpers for IAddressProvider;\n\n    IWETH internal constant _WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2); // WETH\n    UniswapRouter02 internal constant _SUSHISWAP =\n        UniswapRouter02(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F); // Sushiswap Router for swaps\n    UniswapRouter02 internal constant _UNISWAP =\n        UniswapRouter02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D); // Uniswap Router for swaps\n\n    IAddressProvider internal immutable _addressProvider; // Address provider used for getting oracle provider\n\n    uint256 public slippageTolerance; // The amount of slippage to allow from the oracle price of an asset\n    mapping(address => ICurveSwapEth) public curvePools; // Curve Pool to use for swaps to ETH (if any)\n    mapping(address => bool) public swapViaUniswap; // If Uniswap should be used over Sushiswap for swaps\n\n    event SetSlippageTolerance(uint256 value); // Emitted after a succuessful setting of slippage tolerance\n    event SetCurvePool(address token, address curvePool); // Emitted after a succuessful setting of a Curve Pool\n    event SetSwapViaUniswap(address token, bool swapViaUniswap); // Emitted after a succuessful setting of swap via Uniswap\n\n    constructor(address addressProvider_, uint256 slippageTolerance_)\n        Authorization(IAddressProvider(addressProvider_).getRoleManager())\n    {\n        _addressProvider = IAddressProvider(addressProvider_);\n        slippageTolerance = slippageTolerance_;\n    }\n\n    receive() external payable {}\n\n    /**\n     * @notice Swaps all the balance of a token for WETH.\n     * @param token_ Address of the token to swap for WETH.\n     */\n    function swapAllForWeth(address token_) external override {\n        return swapForWeth(token_, IERC20(token_).balanceOf(msg.sender));\n    }\n\n    /**\n     * @notice Swaps all available WETH for underlying.\n     * @param token_ Address of the token to swap WETH to.\n     */\n    function swapAllWethForToken(address token_) external override {\n        IWETH weth_ = _WETH;\n        uint256 wethBalance_ = weth_.balanceOf(msg.sender);\n        if (wethBalance_ == 0) return;\n        weth_.transferFrom(msg.sender, address(this), wethBalance_);\n\n        if (token_ == address(0)) {\n            weth_.withdraw(wethBalance_);\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool sent, ) = payable(msg.sender).call{value: wethBalance_}(\"\");\n            require(sent, \"failed to send eth\");\n            return;\n        }\n\n        // Handling Curve Pool swaps\n        ICurveSwapEth curvePool_ = curvePools[token_];\n        if (address(curvePool_) != address(0)) {\n            _approve(address(weth_), address(curvePool_));\n            (uint256 wethIndex_, uint256 tokenIndex_) = _getIndices(curvePool_, token_);\n            curvePool_.exchange(\n                wethIndex_,\n                tokenIndex_,\n                wethBalance_,\n                _minTokenAmountOut(wethBalance_, token_)\n            );\n            IERC20(token_).safeTransfer(msg.sender, IERC20(token_).balanceOf(address(this)));\n            return;\n        }\n\n        // Handling Uniswap or Sushiswap swaps\n        address[] memory path_ = new address[](2);\n        path_[0] = address(weth_);\n        path_[1] = token_;\n        UniswapRouter02 dex_ = _getDex(token_);\n        _approve(address(weth_), address(dex_));\n        uint256 amountOut_ = dex_.swapExactTokensForTokens(\n            wethBalance_,\n            _minTokenAmountOut(wethBalance_, token_),\n            path_,\n            address(this),\n            block.timestamp\n        )[1];\n        IERC20(token_).safeTransfer(msg.sender, amountOut_);\n    }\n\n    /**\n     * @notice Set slippage tolerance for swaps.\n     * @dev Stored as a multiplier, e.g. 2% would be set as 0.98.\n     * @param slippageTolerance_ New slippage tolerance.\n     */\n    function setSlippageTolerance(uint256 slippageTolerance_) external override onlyGovernance {\n        require(slippageTolerance_ <= ScaledMath.ONE, Error.INVALID_SLIPPAGE_TOLERANCE);\n        require(slippageTolerance_ > 0.8e18, Error.INVALID_SLIPPAGE_TOLERANCE);\n        slippageTolerance = slippageTolerance_;\n        emit SetSlippageTolerance(slippageTolerance_);\n    }\n\n    /**\n     * @notice Sets the Curve Pool to use for swapping a token with WETH.\n     * @dev To use Uniswap or Sushiswap instead, set the Curve Pool to the zero address.\n     * @param token_ The token to set the Curve Pool for.\n     * @param curvePool_ The address of the Curve Pool.\n     */\n    function setCurvePool(address token_, address curvePool_) external override onlyGovernance {\n        require(token_ != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n        require(curvePool_ != address(curvePools[token_]), Error.SAME_ADDRESS_NOT_ALLOWED);\n        curvePools[token_] = ICurveSwapEth(curvePool_);\n        emit SetCurvePool(token_, curvePool_);\n    }\n\n    /**\n     * @notice Sets if swaps should go via Uniswap for the given token_.\n     * @param token_ The token to set the swapViaUniswap for.\n     * @param swapViaUniswap_ If Sushiswap should be use for swaps for token_.\n     */\n    function setSwapViaUniswap(address token_, bool swapViaUniswap_)\n        external\n        override\n        onlyGovernance\n    {\n        require(token_ != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n        swapViaUniswap[token_] = swapViaUniswap_;\n        emit SetSwapViaUniswap(token_, swapViaUniswap_);\n    }\n\n    /**\n     * @notice Gets the amount of tokenOut_ that would be received by swapping amountIn_ of tokenIn_.\n     * @param tokenIn_ The token to swap in.\n     * @param tokenOut_ The token to get out.\n     * @param amountIn_ The amount to swap in.\n     * @return The amount of tokenOut_ that would be received by swapping amountIn_ of tokenIn_.\n     */\n    function amountOut(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    ) external view override returns (uint256) {\n        if (amountIn_ == 0) return 0;\n        uint256 wethOut_ = _tokenToWethAmountOut(tokenIn_, amountIn_);\n        return _wethToTokenAmountOut(tokenOut_, wethOut_);\n    }\n\n    /**\n     * @notice Swaps a token for WETH.\n     * @param token_ Address of the token to swap for WETH.\n     * @param amount_ Amount of the token to swap for WETH.\n     */\n    function swapForWeth(address token_, uint256 amount_) public override {\n        if (amount_ == 0) return;\n        IERC20(token_).safeTransferFrom(msg.sender, address(this), amount_);\n\n        // Handling Curve Pool swaps\n        ICurveSwapEth curvePool_ = curvePools[token_];\n        IWETH weth_ = _WETH;\n        if (address(curvePool_) != address(0)) {\n            _approve(token_, address(curvePool_));\n            (uint256 wethIndex_, uint256 tokenIndex_) = _getIndices(curvePool_, token_);\n            curvePool_.exchange(\n                tokenIndex_,\n                wethIndex_,\n                amount_,\n                _minWethAmountOut(amount_, token_)\n            );\n            IERC20(weth_).safeTransfer(msg.sender, weth_.balanceOf(address(this)));\n            return;\n        }\n\n        // Handling Uniswap or Sushiswap swaps\n        address[] memory path_ = new address[](2);\n        path_[0] = token_;\n        path_[1] = address(weth_);\n        UniswapRouter02 dex_ = _getDex(token_);\n        _approve(token_, address(dex_));\n        uint256 amountOut_ = dex_.swapExactTokensForTokens(\n            amount_,\n            _minWethAmountOut(amount_, token_),\n            path_,\n            address(this),\n            block.timestamp\n        )[1];\n        IERC20(weth_).safeTransfer(msg.sender, amountOut_);\n    }\n\n    /**\n     * @dev Approves infinite spending for the given spender.\n     * @param token_ The token to approve for.\n     * @param spender_ The spender to approve.\n     */\n    function _approve(address token_, address spender_) internal {\n        if (IERC20(token_).allowance(address(this), spender_) > 0) return;\n        IERC20(token_).safeApprove(spender_, type(uint256).max);\n    }\n\n    /**\n     * @dev Gets the dex to use for swapping a given token.\n     * @param token_ The token to get the dex for.\n     * @return The dex to use for swapping a given token.\n     */\n    function _getDex(address token_) internal view returns (UniswapRouter02) {\n        return swapViaUniswap[token_] ? _UNISWAP : _SUSHISWAP;\n    }\n\n    /**\n     * @dev Returns the amount of WETH received by swapping amount_ of token_.\n     * @param token_ The token to get the amount for swapping to WETH.\n     * @param amount_ The amount of token_ that is being swapped to WETH.\n     * @return The amount of WETH received by swapping amount_ of token_.\n     */\n    function _tokenToWethAmountOut(address token_, uint256 amount_)\n        internal\n        view\n        returns (uint256)\n    {\n        if (amount_ == 0) return 0;\n        IWETH weth_ = _WETH;\n        if (token_ == address(weth_)) return amount_;\n        if (token_ == address(0)) return amount_;\n\n        // Getting amount via Curve Pool if set\n        ICurveSwapEth curvePool_ = curvePools[token_];\n        if (address(curvePool_) != address(0)) {\n            (uint256 wethIndex_, uint256 tokenIndex_) = _getIndices(curvePool_, token_);\n            return curvePool_.get_dy(tokenIndex_, wethIndex_, amount_);\n        }\n\n        // Getting amount via Uniswap or Sushiswap\n        address[] memory path_ = new address[](2);\n        path_[0] = token_;\n        path_[1] = address(weth_);\n        return _getDex(token_).getAmountsOut(amount_, path_)[1];\n    }\n\n    /**\n     * @dev Returns the amount of token_ received by swapping amount_ of WETH.\n     * @param token_ The token to get the amount for swapping from WETH.\n     * @param amount_ The amount of WETH that is being swapped to token_.\n     * @return The amount of token_ received by swapping amount_ of WETH.\n     */\n    function _wethToTokenAmountOut(address token_, uint256 amount_)\n        internal\n        view\n        returns (uint256)\n    {\n        if (amount_ == 0) return 0;\n        IWETH weth_ = _WETH;\n        if (token_ == address(weth_)) return amount_;\n        if (token_ == address(0)) return amount_;\n\n        // Getting amount via Curve Pool if set\n        ICurveSwapEth curvePool_ = curvePools[token_];\n        if (address(curvePool_) != address(0)) {\n            (uint256 wethIndex_, uint256 tokenIndex_) = _getIndices(curvePool_, token_);\n            return curvePool_.get_dy(wethIndex_, tokenIndex_, amount_);\n        }\n\n        // Getting amount via Uniswap or Sushiswap\n        address[] memory path_ = new address[](2);\n        path_[0] = address(weth_);\n        path_[1] = token_;\n        return _getDex(token_).getAmountsOut(amount_, path_)[1];\n    }\n\n    /**\n     * @dev Returns the multiplier for converting a token_ amount to the same decimals as WETH.\n     *   For example, USDC (which has decimals of 6) would have a multiplier of 12e18.\n     * @param token_ The token to get the decimal multiplier for.\n     * @return the multiplier for converting a token_ amount to the same decimals as WETH.\n     */\n    function _decimalMultiplier(address token_) internal view returns (uint256) {\n        return 10**(18 - IERC20Full(token_).decimals());\n    }\n\n    /**\n     * @dev Returns the Curve Pool coin indicies for a given Token.\n     * @param curvePool_ The Curve Pool to return the indicies for.\n     * @param token_ The Token to get the indicies for.\n     * @return wethIndex_ The coin index for WETH.\n     * @return tokenIndex_ The coin index for the Token.\n     */\n    function _getIndices(ICurveSwapEth curvePool_, address token_)\n        internal\n        view\n        returns (uint256 wethIndex_, uint256 tokenIndex_)\n    {\n        return curvePool_.coins(1) == token_ ? (0, 1) : (1, 0);\n    }\n\n    /**\n     * @dev Returns the minimum amount of Token to recieve from swap.\n     * @param wethAmount_ The amount of WETH being swapped.\n     * @param token_ The Token the WETH is being swapped to.\n     * @return minAmountOut The minimum amount of Token to recieve from swap.\n     */\n    function _minTokenAmountOut(uint256 wethAmount_, address token_)\n        internal\n        view\n        returns (uint256 minAmountOut)\n    {\n        return\n            wethAmount_\n                .scaledDiv(_addressProvider.getOracleProvider().getPriceETH(token_))\n                .scaledMul(slippageTolerance) / _decimalMultiplier(token_);\n    }\n\n    /**\n     * @dev Returns the minimum amount of WETH to recieve from swap.\n     * @param tokenAmount_ The amount of Token being swapped.\n     * @param token_ The Token that is being swapped for WETH.\n     * @return minAmountOut The minimum amount of WETH to recieve from swap.\n     */\n    function _minWethAmountOut(uint256 tokenAmount_, address token_)\n        internal\n        view\n        returns (uint256 minAmountOut)\n    {\n        return\n            tokenAmount_\n                .scaledMul(_addressProvider.getOracleProvider().getPriceETH(token_))\n                .scaledMul(slippageTolerance) * _decimalMultiplier(token_);\n    }\n}"
    },
    {
      "filename": "backd/contracts/strategies/StrategySwapper.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../interfaces/IAddressProvider.sol\";\nimport \"../access/Authorization.sol\";\nimport \"./IStrategySwapper.sol\";\nimport \"../../interfaces/vendor/UniswapRouter02.sol\";\nimport \"../../interfaces/vendor/ICurveSwapEth.sol\";\nimport \"../../libraries/ScaledMath.sol\";\nimport \"../../libraries/AddressProviderHelpers.sol\";\nimport \"../../interfaces/IERC20Full.sol\";\nimport \"../../interfaces/vendor/IWETH.sol\";\n\ncontract StrategySwapper is IStrategySwapper, Authorization {\n    using ScaledMath for uint256;\n    using SafeERC20 for IERC20;\n    using AddressProviderHelpers for IAddressProvider;\n\n    IWETH internal constant _WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2); // WETH\n    UniswapRouter02 internal constant _SUSHISWAP =\n        UniswapRouter02(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F); // Sushiswap Router for swaps\n    UniswapRouter02 internal constant _UNISWAP =\n        UniswapRouter02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D); // Uniswap Router for swaps\n\n    IAddressProvider internal immutable _addressProvider; // Address provider used for getting oracle provider\n\n    uint256 public slippageTolerance; // The amount of slippage to allow from the oracle price of an asset\n    mapping(address => ICurveSwapEth) public curvePools; // Curve Pool to use for swaps to ETH (if any)\n    mapping(address => bool) public swapViaUniswap; // If Uniswap should be used over Sushiswap for swaps\n\n    event SetSlippageTolerance(uint256 value); // Emitted after a succuessful setting of slippage tolerance\n    event SetCurvePool(address token, address curvePool); // Emitted after a succuessful setting of a Curve Pool\n    event SetSwapViaUniswap(address token, bool swapViaUniswap); // Emitted after a succuessful setting of swap via Uniswap\n\n    constructor(address addressProvider_, uint256 slippageTolerance_)\n        Authorization(IAddressProvider(addressProvider_).getRoleManager())\n    {\n        _addressProvider = IAddressProvider(addressProvider_);\n        slippageTolerance = slippageTolerance_;\n    }\n\n    receive() external payable {}\n\n    /**\n     * @notice Swaps all the balance of a token for WETH.\n     * @param token_ Address of the token to swap for WETH.\n     */\n    function swapAllForWeth(address token_) external override {\n        return swapForWeth(token_, IERC20(token_).balanceOf(msg.sender));\n    }\n\n    /**\n     * @notice Swaps all available WETH for underlying.\n     * @param token_ Address of the token to swap WETH to.\n     */\n    function swapAllWethForToken(address token_) external override {\n        IWETH weth_ = _WETH;\n        uint256 wethBalance_ = weth_.balanceOf(msg.sender);\n        if (wethBalance_ == 0) return;\n        weth_.transferFrom(msg.sender, address(this), wethBalance_);\n\n        if (token_ == address(0)) {\n            weth_.withdraw(wethBalance_);\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool sent, ) = payable(msg.sender).call{value: wethBalance_}(\"\");\n            require(sent, \"failed to send eth\");\n            return;\n        }\n\n        // Handling Curve Pool swaps\n        ICurveSwapEth curvePool_ = curvePools[token_];\n        if (address(curvePool_) != address(0)) {\n            _approve(address(weth_), address(curvePool_));\n            (uint256 wethIndex_, uint256 tokenIndex_) = _getIndices(curvePool_, token_);\n            curvePool_.exchange(\n                wethIndex_,\n                tokenIndex_,\n                wethBalance_,\n                _minTokenAmountOut(wethBalance_, token_)\n            );\n            IERC20(token_).safeTransfer(msg.sender, IERC20(token_).balanceOf(address(this)));\n            return;\n        }\n\n        // Handling Uniswap or Sushiswap swaps\n        address[] memory path_ = new address[](2);\n        path_[0] = address(weth_);\n        path_[1] = token_;\n        UniswapRouter02 dex_ = _getDex(token_);\n        _approve(address(weth_), address(dex_));\n        uint256 amountOut_ = dex_.swapExactTokensForTokens(\n            wethBalance_,\n            _minTokenAmountOut(wethBalance_, token_),\n            path_,\n            address(this),\n            block.timestamp\n        )[1];\n        IERC20(token_).safeTransfer(msg.sender, amountOut_);\n    }\n\n    /**\n     * @notice Set slippage tolerance for swaps.\n     * @dev Stored as a multiplier, e.g. 2% would be set as 0.98.\n     * @param slippageTolerance_ New slippage tolerance.\n     */\n    function setSlippageTolerance(uint256 slippageTolerance_) external override onlyGovernance {\n        require(slippageTolerance_ <= ScaledMath.ONE, Error.INVALID_SLIPPAGE_TOLERANCE);\n        require(slippageTolerance_ > 0.8e18, Error.INVALID_SLIPPAGE_TOLERANCE);\n        slippageTolerance = slippageTolerance_;\n        emit SetSlippageTolerance(slippageTolerance_);\n    }\n\n    /**\n     * @notice Sets the Curve Pool to use for swapping a token with WETH.\n     * @dev To use Uniswap or Sushiswap instead, set the Curve Pool to the zero address.\n     * @param token_ The token to set the Curve Pool for.\n     * @param curvePool_ The address of the Curve Pool.\n     */\n    function setCurvePool(address token_, address curvePool_) external override onlyGovernance {\n        require(token_ != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n        require(curvePool_ != address(curvePools[token_]), Error.SAME_ADDRESS_NOT_ALLOWED);\n        curvePools[token_] = ICurveSwapEth(curvePool_);\n        emit SetCurvePool(token_, curvePool_);\n    }\n\n    /**\n     * @notice Sets if swaps should go via Uniswap for the given token_.\n     * @param token_ The token to set the swapViaUniswap for.\n     * @param swapViaUniswap_ If Sushiswap should be use for swaps for token_.\n     */\n    function setSwapViaUniswap(address token_, bool swapViaUniswap_)\n        external\n        override\n        onlyGovernance\n    {\n        require(token_ != address(0), Error.ZERO_ADDRESS_NOT_ALLOWED);\n        swapViaUniswap[token_] = swapViaUniswap_;\n        emit SetSwapViaUniswap(token_, swapViaUniswap_);\n    }\n\n    /**\n     * @notice Gets the amount of tokenOut_ that would be received by swapping amountIn_ of tokenIn_.\n     * @param tokenIn_ The token to swap in.\n     * @param tokenOut_ The token to get out.\n     * @param amountIn_ The amount to swap in.\n     * @return The amount of tokenOut_ that would be received by swapping amountIn_ of tokenIn_.\n     */\n    function amountOut(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    ) external view override returns (uint256) {\n        if (amountIn_ == 0) return 0;\n        uint256 wethOut_ = _tokenToWethAmountOut(tokenIn_, amountIn_);\n        return _wethToTokenAmountOut(tokenOut_, wethOut_);\n    }\n\n    /**\n     * @notice Swaps a token for WETH.\n     * @param token_ Address of the token to swap for WETH.\n     * @param amount_ Amount of the token to swap for WETH.\n     */\n    function swapForWeth(address token_, uint256 amount_) public override {\n        if (amount_ == 0) return;\n        IERC20(token_).safeTransferFrom(msg.sender, address(this), amount_);\n\n        // Handling Curve Pool swaps\n        ICurveSwapEth curvePool_ = curvePools[token_];\n        IWETH weth_ = _WETH;\n        if (address(curvePool_) != address(0)) {\n            _approve(token_, address(curvePool_));\n            (uint256 wethIndex_, uint256 tokenIndex_) = _getIndices(curvePool_, token_);\n            curvePool_.exchange(\n                tokenIndex_,\n                wethIndex_,\n                amount_,\n                _minWethAmountOut(amount_, token_)\n            );\n            IERC20(weth_).safeTransfer(msg.sender, weth_.balanceOf(address(this)));\n            return;\n        }\n\n        // Handling Uniswap or Sushiswap swaps\n        address[] memory path_ = new address[](2);\n        path_[0] = token_;\n        path_[1] = address(weth_);\n        UniswapRouter02 dex_ = _getDex(token_);\n        _approve(token_, address(dex_));\n        uint256 amountOut_ = dex_.swapExactTokensForTokens(\n            amount_,\n            _minWethAmountOut(amount_, token_),\n            path_,\n            address(this),\n            block.timestamp\n        )[1];\n        IERC20(weth_).safeTransfer(msg.sender, amountOut_);\n    }\n\n    /**\n     * @dev Approves infinite spending for the given spender.\n     * @param token_ The token to approve for.\n     * @param spender_ The spender to approve.\n     */\n    function _approve(address token_, address spender_) internal {\n        if (IERC20(token_).allowance(address(this), spender_) > 0) return;\n        IERC20(token_).safeApprove(spender_, type(uint256).max);\n    }\n\n    /**\n     * @dev Gets the dex to use for swapping a given token.\n     * @param token_ The token to get the dex for.\n     * @return The dex to use for swapping a given token.\n     */\n    function _getDex(address token_) internal view returns (UniswapRouter02) {\n        return swapViaUniswap[token_] ? _UNISWAP : _SUSHISWAP;\n    }\n\n    /**\n     * @dev Returns the amount of WETH received by swapping amount_ of token_.\n     * @param token_ The token to get the amount for swapping to WETH.\n     * @param amount_ The amount of token_ that is being swapped to WETH.\n     * @return The amount of WETH received by swapping amount_ of token_.\n     */\n    function _tokenToWethAmountOut(address token_, uint256 amount_)\n        internal\n        view\n        returns (uint256)\n    {\n        if (amount_ == 0) return 0;\n        IWETH weth_ = _WETH;\n        if (token_ == address(weth_)) return amount_;\n        if (token_ == address(0)) return amount_;\n\n        // Getting amount via Curve Pool if set\n        ICurveSwapEth curvePool_ = curvePools[token_];\n        if (address(curvePool_) != address(0)) {\n            (uint256 wethIndex_, uint256 tokenIndex_) = _getIndices(curvePool_, token_);\n            return curvePool_.get_dy(tokenIndex_, wethIndex_, amount_);\n        }\n\n        // Getting amount via Uniswap or Sushiswap\n        address[] memory path_ = new address[](2);\n        path_[0] = token_;\n        path_[1] = address(weth_);\n        return _getDex(token_).getAmountsOut(amount_, path_)[1];\n    }\n\n    /**\n     * @dev Returns the amount of token_ received by swapping amount_ of WETH.\n     * @param token_ The token to get the amount for swapping from WETH.\n     * @param amount_ The amount of WETH that is being swapped to token_.\n     * @return The amount of token_ received by swapping amount_ of WETH.\n     */\n    function _wethToTokenAmountOut(address token_, uint256 amount_)\n        internal\n        view\n        returns (uint256)\n    {\n        if (amount_ == 0) return 0;\n        IWETH weth_ = _WETH;\n        if (token_ == address(weth_)) return amount_;\n        if (token_ == address(0)) return amount_;\n\n        // Getting amount via Curve Pool if set\n        ICurveSwapEth curvePool_ = curvePools[token_];\n        if (address(curvePool_) != address(0)) {\n            (uint256 wethIndex_, uint256 tokenIndex_) = _getIndices(curvePool_, token_);\n            return curvePool_.get_dy(wethIndex_, tokenIndex_, amount_);\n        }\n\n        // Getting amount via Uniswap or Sushiswap\n        address[] memory path_ = new address[](2);\n        path_[0] = address(weth_);\n        path_[1] = token_;\n        return _getDex(token_).getAmountsOut(amount_, path_)[1];\n    }\n\n    /**\n     * @dev Returns the multiplier for converting a token_ amount to the same decimals as WETH.\n     *   For example, USDC (which has decimals of 6) would have a multiplier of 12e18.\n     * @param token_ The token to get the decimal multiplier for.\n     * @return the multiplier for converting a token_ amount to the same decimals as WETH.\n     */\n    function _decimalMultiplier(address token_) internal view returns (uint256) {\n        return 10**(18 - IERC20Full(token_).decimals());\n    }\n\n    /**\n     * @dev Returns the Curve Pool coin indicies for a given Token.\n     * @param curvePool_ The Curve Pool to return the indicies for.\n     * @param token_ The Token to get the indicies for.\n     * @return wethIndex_ The coin index for WETH.\n     * @return tokenIndex_ The coin index for the Token.\n     */\n    function _getIndices(ICurveSwapEth curvePool_, address token_)\n        internal\n        view\n        returns (uint256 wethIndex_, uint256 tokenIndex_)\n    {\n        return curvePool_.coins(1) == token_ ? (0, 1) : (1, 0);\n    }\n\n    /**\n     * @dev Returns the minimum amount of Token to recieve from swap.\n     * @param wethAmount_ The amount of WETH being swapped.\n     * @param token_ The Token the WETH is being swapped to.\n     * @return minAmountOut The minimum amount of Token to recieve from swap.\n     */\n    function _minTokenAmountOut(uint256 wethAmount_, address token_)\n        internal\n        view\n        returns (uint256 minAmountOut)\n    {\n        return\n            wethAmount_\n                .scaledDiv(_addressProvider.getOracleProvider().getPriceETH(token_))\n                .scaledMul(slippageTolerance) / _decimalMultiplier(token_);\n    }\n\n    /**\n     * @dev Returns the minimum amount of WETH to recieve from swap.\n     * @param tokenAmount_ The amount of Token being swapped.\n     * @param token_ The Token that is being swapped for WETH.\n     * @return minAmountOut The minimum amount of WETH to recieve from swap.\n     */\n    function _minWethAmountOut(uint256 tokenAmount_, address token_)\n        internal\n        view\n        returns (uint256 minAmountOut)\n    {\n        return\n            tokenAmount_\n                .scaledMul(_addressProvider.getOracleProvider().getPriceETH(token_))\n                .scaledMul(slippageTolerance) * _decimalMultiplier(token_);\n    }\n}"
    },
    {
      "filename": "backd/contracts/strategies/StrategySwapper.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../interfaces/IAddressProvider.sol\";\nimport \"../access/Authorization.sol\";\nimport \"./IStrategySwapper.sol\";\nimport \"../../interfaces/vendor/UniswapRouter02.sol\";\nimport \"../../interfaces/vendor/ICurveSwapEth.sol\";\nimport \"../../libraries/ScaledMath.sol\";\nimport \"../../libraries/AddressProviderHelpers.sol\";\nimport \"../../interfaces/IERC20Full.sol\";\nimport \"../../interfaces/vendor/IWETH.sol\";\n\ncontract StrategySwapper is IStrategySwapper, Authorization {\n    using ScaledMath for uint256;\n    using SafeERC20 for IERC20;\n    using AddressProviderHelpers for IAddressProvider;\n\n    IWETH internal constant _WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2); // WETH\n    UniswapRouter02 internal constant _SUSHISWAP =\n        UniswapRouter02(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F); // Sushiswap Router for swaps\n    UniswapRouter02 internal constant _UNISWAP =\n        UniswapRouter02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D); // Uniswap Router for swaps\n\n    IAddressProvider internal immutable _addressProvider; // Address provider used for getting oracle provider\n\n    uint256 public slippageTolerance; // The amount of slippage to allow from the oracle price of an asset\n    mapping(address => ICurveSwapEth) public curvePools; // Curve Pool to use for swaps to ETH (if any)\n    mapping(address => bool) public swapViaUniswap; // If Uniswap should be used over Sushiswap for swaps\n\n    event SetSlippageTolerance(uint256 value); // Emitted after a succuessful setting of slippage tolerance\n    event SetCurvePool(address token, address curvePool); // Emitted after a succuessful setting of a Curve Pool\n    event SetSwapViaUniswap(address token, bool swapViaUniswap); // Emitted after a succuessful setting of swap via Uniswap\n\n    constructor(address addressProvider_, uint256 slippageTolerance_)\n        Authorization(IAddressProvider(addressProvider_).getRoleManager())\n    {\n        _addressProvider = IAddressProvider(addressProvider_);\n        slippageTolerance = slippageTolerance_;\n    }\n\n    receive() external payable {}\n\n    /**\n     * @notice Swaps all the balance of a token for WETH.\n     * @param token_ Address of the token to swap for WETH.\n     */\n    function swapAllForWeth(address token_) external override {\n        return swapForWeth(token_, IERC20(token_).balanceOf(msg.sender));\n    }\n\n    /**\n     * @notice Swaps all available WETH for underlying.\n     * @param token_ Address of the token to swap WETH to.\n     */\n    function swapAllWethForToken(address token_) external override {\n        IWETH weth_ = _WETH;\n        uint256 wethBalance_ = weth_.balanceOf(msg.sender);\n        if (wethBalance_ == 0) return;\n        weth_.transferFrom(msg.sender, address(this), wethBalance_);\n\n        if (token_ == address(0)) {\n            weth_.withdraw(wethBalance_);\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool sent, ) = payable(msg.sender).call{value: wethBalance_}(\"\");\n            require(sent, \"failed to send eth\");\n            return;\n        }\n\n        // Handling Curve Pool swaps\n        ICurveSwapEth curvePool_ = curvePools[token_];\n        if (address(curvePool_) != address(0)) {\n            _approve(address(weth_), address(curvePool_));\n            (uint256 wethIndex_, uint256 tokenIndex_) = _getIndices(curvePool_, token_);\n            curvePool_.exchange(\n                wethIndex_,\n                tokenIndex_,\n                wethBalance_,\n                _minTokenAmountOut(wethBalance_, token_)\n            );\n            IERC20(token_).safeTransfer(msg.sender, IERC20(token_).balanceOf(address(this)));\n            return;\n        }\n\n        // Handling Uniswap or Sushiswap swaps\n        address[] memory path_ = new address[](2);\n        path_[0] = address(weth_);\n        path_[1] = token_;\n        UniswapRouter02 dex_ = _getDex(token_);\n        _approve(address(weth_), address(dex_));\n        uint256 amountOut_ = dex_.swapExactTokensForTokens(\n            wethBalance_,\n            _minTokenAmountOut(wethBalance_, token_),\n            path_,\n            address(this),\n            block.timestamp\n        )[1];\n        IERC20(token_).safeTransfer(msg.sender, amountOut_);\n    }\n\n    /**\n     * @notice Set slippage tolerance for swaps.\n     * @dev Stored as a multiplier, e.g. 2% would be set as 0.98.\n     * @param slippageTolerance_ New slippage tolerance.\n     */\n    function setSlippageTolerance(uint256 slippageTolerance_) external override onlyGovernance {\n        require(slippageTolerance_ <= ScaledMath.ONE, Error.INVALID_SLIPPAGE_TOLERANCE);\n        require(slippageTolerance_ > 0.8e18, Error.INVALID_SLIPPAGE_TOLERANCE);\n        slippageTolerance = slippageTolerance_;\n        emit SetSlippageTolerance(slippageTolerance_);\n    }\n\n    /**\n     * @notice Sets the Curve Pool to use for swapping a token with WETH.\n     * @dev To use Uniswap or Sushiswap instead, set the Curve Pool to the zer"
    }
  ]
}