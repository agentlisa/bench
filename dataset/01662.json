{
  "Title": "M-5: Update to `managerFeeBPS` applied to pending tokens yet to be claimed",
  "Content": "# Issue M-5: Update to `managerFeeBPS` applied to pending tokens yet to be claimed \n\nSource: https://github.com/sherlock-audit/2023-06-arrakis-judging/issues/198 \n\n## Found by \n0xDjango, Jeiwan, ast3ros, dipp, immeas, rugpull\\_detector, rvierdiiev\n## Summary\nA manager (malicious or not) can update the `managerFeeBPS` by calling `ArrakisV2.setManagerFeeBPS()`. The newly-updated `managerFeeBPS` will be retroactively applied to the pending fees yet to be claimed by the `ArrakisV2` contract.\n\n## Vulnerability Detail\nWhenever UniV3 fees are collected (via `burn()` or `rebalance()`), the manager fees are applied to the received pending tokens.\n\n```solidity\nfunction _applyFees(uint256 fee0_, uint256 fee1_) internal {\n    uint16 mManagerFeeBPS = managerFeeBPS;\n    managerBalance0 += (fee0_ * mManagerFeeBPS) / hundredPercent;\n    managerBalance1 += (fee1_ * mManagerFeeBPS) / hundredPercent;\n}\n```\n\nSince the manager can update the `managerFeeBPS` whenever, this calculation can be altered to take up to 100% of the pending fees in favor of the manager.\n\n```solidity\nfunction setManagerFeeBPS(uint16 managerFeeBPS_) external onlyManager {\n    require(managerFeeBPS_ <= 10000, \"MFO\");\n    managerFeeBPS = managerFeeBPS_;\n    emit LogSetManagerFeeBPS(managerFeeBPS_);\n}\n```\n\n## Impact\n- Manager's ability to intentionally or accidently steal pending fees owed to stakers\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-06-arrakis/blob/main/v2-core/contracts/abstract/ArrakisV2Storage.sol#L218-L222\n\n## Tool used\nManual Review\n\n## Recommendation\nFees should be collected at the start of execution within the `setManagerFeeBPS()` function. This effectively checkpoints the fees properly, prior to updating the `managerFeeBPS` variable.\n\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/86",
  "Code": [
    {
      "filename": "v2-core/contracts/abstract/ArrakisV2Storage.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.13;\n\nimport {\n    IUniswapV3Factory\n} from \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol\";\nimport {\n    IERC20,\n    SafeERC20\n} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {\n    OwnableUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {\n    ERC20Upgradeable\n} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {\n    ReentrancyGuardUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {\n    EnumerableSet\n} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {Range, Rebalance, InitializePayload} from \"../structs/SArrakisV2.sol\";\n\n/// @title ArrakisV2Storage base contract containing all ArrakisV2 storage variables.\n// solhint-disable-next-line max-states-count\nabstract contract ArrakisV2Storage is\n    OwnableUpgradeable,\n    ERC20Upgradeable,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    IUniswapV3Factory public immutable factory;\n\n    IERC20 public token0;\n    IERC20 public token1;\n\n    uint256 public init0;\n    uint256 public init1;\n\n    // #region manager data\n\n    uint16 public managerFeeBPS;\n    uint256 public managerBalance0;\n    uint256 public managerBalance1;\n    address public manager;\n    address public restrictedMint;\n\n    // #endregion manager data\n\n    Range[] internal _ranges;\n\n    EnumerableSet.AddressSet internal _pools;\n    EnumerableSet.AddressSet internal _routers;\n\n    // #region events\n\n    event LogMint(\n        address indexed receiver,\n        uint256 mintAmount,\n        uint256 amount0In,\n        uint256 amount1In\n    );\n\n    event LogBurn(\n        address indexed receiver,\n        uint256 burnAmount,\n        uint256 amount0Out,\n        uint256 amount1Out\n    );\n\n    event LPBurned(\n        address indexed user,\n        uint256 burnAmount0,\n        uint256 burnAmount1\n    );\n\n    event LogRebalance(\n        Rebalance rebalanceParams,\n        uint256 swapDelta0,\n        uint256 swapDelta1\n    );\n\n    event LogCollectedFees(uint256 fee0, uint256 fee1);\n\n    event LogWithdrawManagerBalance(uint256 amount0, uint256 amount1);\n    // #region Setting events\n\n    event LogSetInits(uint256 init0, uint256 init1);\n    event LogAddPools(uint24[] feeTiers);\n    event LogRemovePools(address[] pools);\n    event LogSetManager(address newManager);\n    event LogSetManagerFeeBPS(uint16 managerFeeBPS);\n    event LogRestrictedMint(address minter);\n    event LogWhitelistRouters(address[] routers);\n    event LogBlacklistRouters(address[] routers);\n    // #endregion Setting events\n\n    // #endregion events\n\n    // #region modifiers\n\n    modifier onlyManager() {\n        require(manager == msg.sender, \"NM\");\n        _;\n    }\n\n    // #endregion modifiers\n\n    constructor(IUniswapV3Factory factory_) {\n        require(address(factory_) != address(0), \"ZF\");\n        factory = factory_;\n    }\n\n    // solhint-disable-next-line function-max-lines\n    function initialize(\n        string calldata name_,\n        string calldata symbol_,\n        InitializePayload calldata params_\n    ) external initializer {\n        require(params_.feeTiers.length > 0, \"NFT\");\n        require(params_.token0 != address(0), \"T0\");\n        require(params_.token0 < params_.token1, \"WTO\");\n        require(params_.owner != address(0), \"OAZ\");\n        require(params_.manager != address(0), \"MAZ\");\n        require(params_.init0 > 0 || params_.init1 > 0, \"I\");\n\n        __ERC20_init(name_, symbol_);\n        __ReentrancyGuard_init();\n\n        _addPools(params_.feeTiers, params_.token0, params_.token1);\n        _whitelistRouters(params_.routers);\n\n        token0 = IERC20(params_.token0);\n        token1 = IERC20(params_.token1);\n\n        _transferOwnership(params_.owner);\n\n        manager = params_.manager;\n\n        init0 = params_.init0;\n        init1 = params_.init1;\n\n        emit LogAddPools(params_.feeTiers);\n        emit LogSetInits(params_.init0, params_.init1);\n        emit LogSetManager(params_.manager);\n    }\n\n    // #region setter functions\n\n    /// @notice set initial virtual allocation of token0 and token1\n    /// @param init0_ initial virtual allocation of token 0.\n    /// @param init1_ initial virtual allocation of token 1.\n    /// @dev only callable by restrictedMint or by owner if restrictedMint is unset.\n    function setInits(uint256 init0_, uint256 init1_) external {\n        require(init0_ > 0 || init1_ > 0, \"I\");\n        require(totalSupply() == 0, \"TS\");\n        address requiredCaller = restrictedMint == address(0)\n            ? owner()\n            : restrictedMint;\n        require(msg.sender == requiredCaller, \"R\");\n        emit LogSetInits(init0 = init0_, init1 = init1_);\n    }\n\n    /// @notice whitelist pools\n    /// @param feeTiers_ list of fee tiers associated to pools to whitelist.\n    /// @dev only callable by owner.\n    function addPools(uint24[] calldata feeTiers_) external onlyOwner {\n        _addPools(feeTiers_, address(token0), address(token1));\n        emit LogAddPools(feeTiers_);\n    }\n\n    /// @notice unwhitelist pools\n    /// @param pools_ list of pools to remove from whitelist.\n    /// @dev only callable by owner.\n    function removePools(address[] calldata pools_) external onlyOwner {\n        for (uint256 i = 0; i < pools_.length; i++) {\n            require(_pools.contains(pools_[i]), \"NP\");\n\n            _pools.remove(pools_[i]);\n        }\n        emit LogRemovePools(pools_);\n    }\n\n    /// @notice whitelist routers\n    /// @param routers_ list of router addresses to whitelist.\n    /// @dev only callable by owner.\n    function whitelistRouters(address[] calldata routers_) external onlyOwner {\n        _whitelistRouters(routers_);\n    }\n\n    /// @notice blacklist routers\n    /// @param routers_ list of routers addresses to blacklist.\n    /// @dev only callable by owner.\n    function blacklistRouters(address[] calldata routers_) external onlyOwner {\n        for (uint256 i = 0; i < routers_.length; i++) {\n            require(_routers.contains(routers_[i]), \"RW\");\n\n            _routers.remove(routers_[i]);\n        }\n        emit LogBlacklistRouters(routers_);\n    }\n\n    /// @notice set manager\n    /// @param manager_ manager address.\n    /// @dev only callable by owner.\n    function setManager(address manager_) external onlyOwner {\n        _withdrawManagerBalance();\n        manager = manager_;\n        emit LogSetManager(manager_);\n    }\n\n    /// @notice set manager fee bps\n    /// @param managerFeeBPS_ manager fee in basis points.\n    /// @dev only callable by manager.\n    function setManagerFeeBPS(uint16 managerFeeBPS_) external onlyManager {\n        require(managerFeeBPS_ <= 10000, \"MFO\");\n        managerFeeBPS = managerFeeBPS_;\n        emit LogSetManagerFeeBPS(managerFeeBPS_);\n    }\n\n    /// @notice set restricted minter\n    /// @param minter_ address of restricted minter.\n    /// @dev only callable by owner.\n    function setRestrictedMint(address minter_) external onlyOwner {\n        restrictedMint = minter_;\n        emit LogRestrictedMint(minter_);\n    }\n\n    // #endregion setter functions\n\n    // #region getter functions\n\n    /// @notice get full list of ranges, guaranteed to contain all active vault LP Positions.\n    /// @return ranges list of ranges\n    function getRanges() external view returns (Range[] memory) {\n        return _ranges;\n    }\n\n    function getPools() external view returns (address[] memory) {\n        uint256 len = _pools.length();\n        address[] memory output = new address[](len);\n        for (uint256 i; i < len; i++) {\n            output[i] = _pools.at(i);\n        }\n\n        return output;\n    }\n\n    function getRouters() external view returns (address[] memory) {\n        uint256 len = _routers.length();\n        address[] memory output = new address[](len);\n        for (uint256 i; i < len; i++) {\n            output[i] = _routers.at(i);\n        }\n\n        return output;\n    }\n\n    // #endregion getter functions\n\n    // #region internal functions\n\n    function _uniswapV3CallBack(uint256 amount0_, uint256 amount1_) internal {\n        require(_pools.contains(msg.sender), \"CC\");\n\n        if (amount0_ > 0) token0.safeTransfer(msg.sender, amount0_);\n        if (amount1_ > 0) token1.safeTransfer(msg.sender, amount1_);\n    }\n\n    function _withdrawManagerBalance() internal {\n        uint256 amount0 = managerBalance0;\n        uint256 amount1 = managerBalance1;\n\n        managerBalance0 = 0;\n        managerBalance1 = 0;\n\n        if (amount0 > 0) {\n            token0.safeTransfer(manager, amount0);\n        }\n\n        if (amount1 > 0) {\n            token1.safeTransfer(manager, amount1);\n        }\n\n        emit LogWithdrawManagerBalance(amount0, amount1);\n    }\n\n    function _addPools(\n        uint24[] calldata feeTiers_,\n        address token0Addr_,\n        address token1Addr_\n    ) internal {\n        for (uint256 i = 0; i < feeTiers_.length; i++) {\n            address pool = factory.getPool(\n                token0Addr_,\n                token1Addr_,\n                feeTiers_[i]\n            );\n\n            require(pool != address(0), \"ZA\");\n            require(!_pools.contains(pool), \"P\");\n\n            // explicit.\n            _pools.add(pool);\n        }\n    }\n\n    function _whitelistRouters(address[] calldata routers_) internal {\n        for (uint256 i = 0; i < routers_.length; i++) {\n            require(\n                routers_[i] != address(token0) &&\n                    routers_[i] != address(token1),\n                \"RT\"\n            );\n            require(!_routers.contains(routers_[i]), \"CR\");\n            // explicit.\n            _routers.add(routers_[i]);\n        }\n\n        emit LogWhitelistRouters(routers_);\n    }\n\n    // #endregion internal functions\n}"
    }
  ]
}