{
  "Title": "[M-02] NFTHelper Contract Allows Owner to Burn NFTs",
  "Content": "_Submitted by Kenshin_\n\n[CryptoPunksHelper.sol#L38](https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/helpers/CryptoPunksHelper.sol#L38)<br>\n[CryptoPunksHelper.sol#L52](https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/helpers/CryptoPunksHelper.sol#L52)<br>\n\nIn the NFT helper contract, there is no validation on that the receiver address must not be address zero. Therefore, it allows owner or an attacker who gain access to the owner address to burn NFTs forever through the functions by transferring the NFTs to address zero.\n\n### Proof of Concept\n\nThe PoC is originally conducted using foundry. However, it isn't that complicated so I rewrote it in TypeScipt as well, the team can easily proof this by including in the `CryptoPunksHelper.ts`.\n\n#### TypeScript\n\n    // add `.only` to run only this test, not all.\n    it.only(\"allows the owner to burn nfts\", async () => {\n        // safeTransferFrom\n        await cryptoPunks.getPunk(1);\n        await cryptoPunks.transferPunk(helper.address, 1);\n        await helper.safeTransferFrom(owner.address, ZERO_ADDRESS, 1);\n        expect(await cryptoPunks.punkIndexToAddress(1)).to.equal(ZERO_ADDRESS);\n        expect(await helper.ownerOf(1)).to.equal(ZERO_ADDRESS);\n\n        // transferFrom\n        await cryptoPunks.getPunk(2);\n        await cryptoPunks.transferPunk(helper.address, 2);\n        await helper.transferFrom(owner.address, ZERO_ADDRESS, 2);\n        expect(await cryptoPunks.punkIndexToAddress(2)).to.equal(ZERO_ADDRESS);\n        expect(await helper.ownerOf(2)).to.equal(ZERO_ADDRESS);\n      });\n\n#### Foundry\n\n    pragma solidity ^0.8.0;\n\n    // for test\n    import \"ds-test/test.sol\";\n    import \"forge-std/Vm.sol\";\n\n    // contracts\n    import \"../test/CryptoPunks.sol\";\n    import \"../helpers/CryptoPunksHelper.sol\";\n\n    contract CryptoPunksHelperTest is DSTest {\n        Vm constant vm = Vm(HEVM_ADDRESS);\n        \n        address owner = address(1);\n        address user = address(2);\n        \n        CryptoPunks private cps;\n        CryptoPunksHelper private helper;\n\n        function setUp() public {\n            vm.startPrank(owner);\n            cps = new CryptoPunks();\n            helper = new CryptoPunksHelper();\n            helper.initialize(address(cps));\n            vm.stopPrank();\n        }\n\n        function testOwnerTransferToZero() public {\n            //make sure address zero hold no punks\n            assertEq(cps.balanceOf(address(0)), 0);\n\n            // safeTransferFrom PoC\n            vm.startPrank(owner);\n            cps.getPunk(1);\n            cps.transferPunk(address(helper), 1);\n            helper.safeTransferFrom(owner, address(0), 1);\n            assertEq(cps.punkIndexToAddress(1), address(0));\n            assertEq(helper.ownerOf(1), address(0));\n            assertEq(cps.balanceOf(address(0)), 1);\n\n            // transferFrom PoC\n            cps.getPunk(2);\n            cps.transferPunk(address(helper), 2);\n            helper.transferFrom(owner, address(0), 2);\n            assertEq(cps.punkIndexToAddress(2), address(0));\n            assertEq(helper.ownerOf(2), address(0));\n            assertEq(cps.balanceOf(address(0)), 2);\n        }\n    }\n\nfoundry.toml\n\n    [default]\n    src = \"contracts\"\n    libs = [\"lib/forge-std/lib\", \"lib/\", \"node_modules\"]\n    solc_version = \"0.8.0\"\n    optimizer = false\n    fuzz_runs = 100000\n    test = \"foundryTest\"\n\n### Tools Used\n\n*   Foundry\n*   Hardhat\n\n### Recommended Mitigation Steps\n\nEven the functions are restricted for only the owner, the zero address should not be allowed as the receiver address.\n\n**[spaghettieth (JPEG'd) acknowledged and commented](https://github.com/code-423n4/2022-04-jpegd-findings/issues/47#issuecomment-1095518421):**\n > The sole purpose of `CryptoPunksHelper.sol` and `EtherRocksHelper.sol` contracts is to allow compatibility of non ERC721 NFTs to be compatible with `NFTVault.sol` without having to modify the vault's code. They don't have to provide any additional security check outside of compatibility related ones, everything else is out of scope and should be handled by the underlying NFT.\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/contests/2022-04-jpegd-contest",
  "Code": [
    {
      "filename": "contracts/helpers/CryptoPunksHelper.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport \"../escrow/NFTEscrow.sol\";\nimport \"../interfaces/ICryptoPunks.sol\";\n\n /// @title CryptoPunks NFTVault helper contract\n /// @notice Allows compatibility between CryptoPunks and {NFTVault}\n /// @dev CryptoPunks IERC721 compatibility.\n /// Meant to only be used by {NFTVault}.\n /// This contract is NOT an ERC721 wrapper for punks and is not meant to implement the ERC721 interface fully, \n /// its only purpose is to serve as a proxy between {NFTVault} and CryptoPunks.\n /// The owner is {NFTVault}\ncontract CryptoPunksHelper is NFTEscrow, OwnableUpgradeable {\n\n    /// @param punksAddress Address of the CryptoPunks contract\n    function initialize(address punksAddress) external initializer {\n        __NFTEscrow_init(punksAddress);\n        __Ownable_init();\n    }\n\n    /// @notice Returns the owner of the punk at index `_idx`\n    /// @dev If the owner of the punk is this contract we return the address of the {NFTVault} for compatibility\n    /// @param _idx The punk index\n    /// @return The owner of the punk if != `address(this)`, otherwise the the owner of this contract\n    function ownerOf(uint256 _idx) external view returns (address) {\n        address account = ICryptoPunks(nftAddress).punkIndexToAddress(_idx);\n\n        return account == address(this) ? owner() : account;\n    }\n\n    /// @notice Function called by {NFTVault} to transfer punks. Can only be called by the owner\n    /// @param _from The sender address\n    /// @param _to The recipient address\n    /// @param _idx The index of the punk to transfer\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _idx\n    ) external onlyOwner {\n        _transferFrom(_from, _to, _idx);\n    }\n\n    /// @dev We aren't calling {onERC721Received} on the _to address because punks don't implement\n    /// the {ERC721} interface, but we are including this function for compatibility with the {NFTVault} contract.\n    /// Calling the {onERC721Received} function on the receiver contract could cause problems as we aren't sending an ERC721.\n    /// @param _from The sender address\n    /// @param _to The recipient address\n    /// @param _idx The index of the punk to transfer\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _idx\n    ) external onlyOwner {\n        _transferFrom(_from, _to, _idx);\n    }\n\n    /// @dev Implementation of {transferFrom} and {safeTransferFrom}. We are using {NFTEscrow} for atomic transfers.\n    /// See {NFTEscrow} for more info\n    /// @param _from The sender address\n    /// @param _to The recipient address\n    /// @param _idx The index of the punk to transfer\n    function _transferFrom(\n        address _from,\n        address _to,\n        uint256 _idx\n    ) internal {\n        ICryptoPunks punks = ICryptoPunks(nftAddress);\n\n        address account = punks.punkIndexToAddress(_idx);\n\n        //if the owner is this address we don't need to go through {NFTEscrow}\n        if (account != address(this)) {\n            _executeTransfer(_from, _idx);\n        }\n\n        require(\n            punks.punkIndexToAddress(_idx) == address(this), //this should never be false\n            \"CryptoPunksHelper: not_deposited\"\n        );\n\n        //If _to is the owner ({NFTVault}), we aren't sending the punk\n        //since we'd have no way to get it back\n        if (_to != owner()) punks.transferPunk(_to, _idx);\n    }\n\n    /// @dev Prevent the owner from renouncing ownership. Having no owner would render this contract unusable\n    function renounceOwnership() public view override onlyOwner {\n        revert(\"Cannot renounce ownership\");\n    }\n\n    /// @dev The {transferPunk} function is used as the escrow's payload.\n    /// @param _idx The index of the punk that's going to be transferred using {NFTEscrow}\n    function _encodeFlashEscrowPayload(uint256 _idx)\n        internal\n        view\n        override\n        returns (bytes memory)\n    {\n        return\n            abi.encodeWithSignature(\n                \"transferPunk(address,uint256)\",\n                address(this),\n                _idx\n            );\n    }\n}"
    },
    {
      "filename": "contracts/helpers/CryptoPunksHelper.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport \"../escrow/NFTEscrow.sol\";\nimport \"../interfaces/ICryptoPunks.sol\";\n\n /// @title CryptoPunks NFTVault helper contract\n /// @notice Allows compatibility between CryptoPunks and {NFTVault}\n /// @dev CryptoPunks IERC721 compatibility.\n /// Meant to only be used by {NFTVault}.\n /// This contract is NOT an ERC721 wrapper for punks and is not meant to implement the ERC721 interface fully, \n /// its only purpose is to serve as a proxy between {NFTVault} and CryptoPunks.\n /// The owner is {NFTVault}\ncontract CryptoPunksHelper is NFTEscrow, OwnableUpgradeable {\n\n    /// @param punksAddress Address of the CryptoPunks contract\n    function initialize(address punksAddress) external initializer {\n        __NFTEscrow_init(punksAddress);\n        __Ownable_init();\n    }\n\n    /// @notice Returns the owner of the punk at index `_idx`\n    /// @dev If the owner of the punk is this contract we return the address of the {NFTVault} for compatibility\n    /// @param _idx The punk index\n    /// @return The owner of the punk if != `address(this)`, otherwise the the owner of this contract\n    function ownerOf(uint256 _idx) external view returns (address) {\n        address account = ICryptoPunks(nftAddress).punkIndexToAddress(_idx);\n\n        return account == address(this) ? owner() : account;\n    }\n\n    /// @notice Function called by {NFTVault} to transfer punks. Can only be called by the owner\n    /// @param _from The sender address\n    /// @param _to The recipient address\n    /// @param _idx The index of the punk to transfer\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _idx\n    ) external onlyOwner {\n        _transferFrom(_from, _to, _idx);\n    }\n\n    /// @dev We aren't calling {onERC721Received} on the _to address because punks don't implement\n    /// the {ERC721} interface, but we are including this function for compatibility with the {NFTVault} contract.\n    /// Calling the {onERC721Received} function on the receiver contract could cause problems as we aren't sending an ERC721.\n    /// @param _from The sender address\n    /// @param _to The recipient address\n    /// @param _idx The index of the punk to transfer\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _idx\n    ) external onlyOwner {\n        _transferFrom(_from, _to, _idx);\n    }\n\n    /// @dev Implementation of {transferFrom} and {safeTransferFrom}. We are using {NFTEscrow} for atomic transfers.\n    /// See {NFTEscrow} for more info\n    /// @param _from The sender address\n    /// @param _to The recipient address\n    /// @param _idx The index of the punk to transfer\n    function _transferFrom(\n        address _from,\n        address _to,\n        uint256 _idx\n    ) internal {\n        ICryptoPunks punks = ICryptoPunks(nftAddress);\n\n        address account = punks.punkIndexToAddress(_idx);\n\n        //if the owner is this address we don't need to go through {NFTEscrow}\n        if (account != address(this)) {\n            _executeTransfer(_from, _idx);\n        }\n\n        require(\n            punks.punkIndexToAddress(_idx) == address(this), //this should never be false\n            \"CryptoPunksHelper: not_deposited\"\n        );\n\n        //If _to is the owner ({NFTVault}), we aren't sending the punk\n        //since we'd have no way to get it back\n        if (_to != owner()) punks.transferPunk(_to, _idx);\n    }\n\n    /// @dev Prevent the owner from renouncing ownership. Having no owner would render this contract unusable\n    function renounceOwnership() public view override onlyOwner {\n        revert(\"Cannot renounce ownership\");\n    }\n\n    /// @dev The {transferPunk} function is used as the escrow's payload.\n    /// @param _idx The index of the punk that's going to be transferred using {NFTEscrow}\n    function _encodeFlashEscrowPayload(uint256 _idx)\n        internal\n        view\n        override\n        returns (bytes memory)\n    {\n        return\n            abi.encodeWithSignature(\n                \"transferPunk(address,uint256)\",\n                address(this),\n                _idx\n            );\n    }\n}"
    }
  ]
}