{
  "Title": "[M-09] Reward can be vested even after endTime",
  "Content": "_Submitted by csanuragjain_\n\n[AuraVestedEscrow.sol#L96](https://github.com/code-423n4/2022-05-aura/blob/main/contracts/AuraVestedEscrow.sol#L96)<br>\n\nReward vesting should end once endTime is reached, this is not done currently.\n\n### Proof of Concept\n\n1.  Observe the fund function\n2.  Observe that there is no check to disallow funding once endTime has been reached\n\n### Recommended Mitigation Steps\n\nAdd below check\n\n    require(block.timestamp<=endTime, \"Reward vesting period over\");\n\n**[0xMaharishi (Aura Finance) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2022-05-aura-findings/issues/126#issuecomment-1138397223):**\n > This report is kind of invalid, because there would be no utility in this.. it's specifically left open ended. With that being said, adding a check to ensure that funding is made BEFORE START TIME would be good.\n> \n> This should be a 0 or 1 at most.\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2022-05-aura-findings/issues/126#issuecomment-1164775429):**\n > As far as I can tell, this is totally valid. Funding in this state would cause a loss of funds in that they would never go towards a reward.\n\n**[0xMaharishi (Aura Finance) resolved](https://github.com/code-423n4/2022-05-aura-findings/issues/126):**\n > [code4rena aurafinance/aura-contracts#84](https://github.com/aurafinance/aura-contracts/pull/84)<br>\n > [All code4rena fixes code-423n4/2022-05-aura#6](https://github.com/code-423n4/2022-05-aura/pull/6)\n\n\n\n***\n\n",
  "Impact": "MEDIUM",
  "Source": "https://code4rena.com/reports/2022-05-aura",
  "Code": [
    {
      "filename": "contracts/AuraVestedEscrow.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport { IAuraLocker } from \"./Interfaces.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts-0.8/security/ReentrancyGuard.sol\";\nimport { AuraMath } from \"./AuraMath.sol\";\n\n/**\n * @title   AuraVestedEscrow\n * @author  adapted from ConvexFinance (convex-platform/contracts/contracts/VestedEscrow)\n * @notice  Vests tokens over a given timeframe to an array of recipients. Allows locking of\n *          these tokens directly to staking contract.\n * @dev     Adaptations:\n *           - One time initialisation\n *           - Consolidation of fundAdmin/admin\n *           - Lock in AuraLocker by default\n *           - Start and end time\n */\ncontract AuraVestedEscrow is ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable rewardToken;\n\n    address public admin;\n    IAuraLocker public auraLocker;\n\n    uint256 public immutable startTime;\n    uint256 public immutable endTime;\n    uint256 public immutable totalTime;\n\n    bool public initialised = false;\n\n    mapping(address => uint256) public totalLocked;\n    mapping(address => uint256) public totalClaimed;\n\n    event Funded(address indexed recipient, uint256 reward);\n    event Cancelled(address indexed recipient);\n    event Claim(address indexed user, uint256 amount, bool locked);\n\n    /**\n     * @param rewardToken_    Reward token (AURA)\n     * @param admin_          Admin to cancel rewards\n     * @param auraLocker_     Contract where rewardToken can be staked\n     * @param starttime_      Timestamp when claim starts\n     * @param endtime_        When vesting ends\n     */\n    constructor(\n        address rewardToken_,\n        address admin_,\n        address auraLocker_,\n        uint256 starttime_,\n        uint256 endtime_\n    ) {\n        require(starttime_ >= block.timestamp, \"start must be future\");\n        require(endtime_ > starttime_, \"end must be greater\");\n\n        rewardToken = IERC20(rewardToken_);\n        admin = admin_;\n        auraLocker = IAuraLocker(auraLocker_);\n\n        startTime = starttime_;\n        endTime = endtime_;\n        totalTime = endTime - startTime;\n        require(totalTime >= 16 weeks, \"!short\");\n    }\n\n    /***************************************\n                    SETUP\n    ****************************************/\n\n    /**\n     * @notice Change contract admin\n     * @param _admin New admin address\n     */\n    function setAdmin(address _admin) external {\n        require(msg.sender == admin, \"!auth\");\n        admin = _admin;\n    }\n\n    /**\n     * @notice Change locker contract address\n     * @param _auraLocker Aura Locker address\n     */\n    function setLocker(address _auraLocker) external {\n        require(msg.sender == admin, \"!auth\");\n        auraLocker = IAuraLocker(_auraLocker);\n    }\n\n    /**\n     * @notice Fund recipients with rewardTokens\n     * @param _recipient  Array of recipients to vest rewardTokens for\n     * @param _amount     Arrary of amount of rewardTokens to vest\n     */\n    function fund(address[] calldata _recipient, uint256[] calldata _amount) external nonReentrant {\n        require(!initialised, \"initialised already\");\n\n        uint256 totalAmount = 0;\n        for (uint256 i = 0; i < _recipient.length; i++) {\n            uint256 amount = _amount[i];\n\n            totalLocked[_recipient[i]] += amount;\n            totalAmount += amount;\n\n            emit Funded(_recipient[i], amount);\n        }\n        rewardToken.safeTransferFrom(msg.sender, address(this), totalAmount);\n        initialised = true;\n    }\n\n    /**\n     * @notice Cancel recipients vesting rewardTokens\n     * @param _recipient Recipient address\n     */\n    function cancel(address _recipient) external nonReentrant {\n        require(msg.sender == admin, \"!auth\");\n        require(totalLocked[_recipient] > 0, \"!funding\");\n\n        _claim(_recipient, false);\n\n        uint256 delta = remaining(_recipient);\n        rewardToken.safeTransfer(admin, delta);\n\n        totalLocked[_recipient] = 0;\n\n        emit Cancelled(_recipient);\n    }\n\n    /***************************************\n                    VIEWS\n    ****************************************/\n\n    /**\n     * @notice Available amount to claim\n     * @param _recipient Recipient to lookup\n     */\n    function available(address _recipient) public view returns (uint256) {\n        uint256 vested = _totalVestedOf(_recipient, block.timestamp);\n        return vested - totalClaimed[_recipient];\n    }\n\n    /**\n     * @notice Total remaining vested amount\n     * @param _recipient Recipient to lookup\n     */\n    function remaining(address _recipient) public view returns (uint256) {\n        uint256 vested = _totalVestedOf(_recipient, block.timestamp);\n        return totalLocked[_recipient] - vested;\n    }\n\n    /**\n     * @notice Get total amount vested for this timestamp\n     * @param _recipient  Recipient to lookup\n     * @param _time       Timestamp to check vesting amount for\n     */\n    function _totalVestedOf(address _recipient, uint256 _time) internal view returns (uint256 total) {\n        if (_time < startTime) {\n            return 0;\n        }\n        uint256 locked = totalLocked[_recipient];\n        uint256 elapsed = _time - startTime;\n        total = AuraMath.min((locked * elapsed) / totalTime, locked);\n    }\n\n    /***************************************\n                    CLAIM\n    ****************************************/\n\n    function claim(bool _lock) external nonReentrant {\n        _claim(msg.sender, _lock);\n    }\n\n    /**\n     * @dev Claim reward token (Aura) and lock it.\n     * @param _recipient  Address to receive rewards.\n     * @param _lock       Lock rewards immediately.\n     */\n    function _claim(address _recipient, bool _lock) internal {\n        uint256 claimable = available(_recipient);\n\n        totalClaimed[_recipient] += claimable;\n\n        if (_lock) {\n            require(address(auraLocker) != address(0), \"!auraLocker\");\n            rewardToken.safeApprove(address(auraLocker), claimable);\n            auraLocker.lock(_recipient, claimable);\n        } else {\n            rewardToken.safeTransfer(_recipient, claimable);\n        }\n\n        emit Claim(_recipient, claimable, _lock);\n    }\n}"
    }
  ]
}