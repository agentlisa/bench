{
  "Title": "[06] Contributed tokens left over from `exchangeRateBps` and `fundingSplitBps` floor rounding are not reimbursed",
  "Content": "\nhttps://github.com/code-423n4/2023-10-party/blob/b23c65d62a20921c709582b0b76b387f2bb9ebb5/contracts/crowdfund/InitialETHCrowdfund.sol#L302<br>\nhttps://github.com/code-423n4/2023-10-party/blob/b23c65d62a20921c709582b0b76b387f2bb9ebb5/contracts/crowdfund/ETHCrowdfundBase.sol#L267<br>\nhttps://github.com/code-423n4/2023-10-party/blob/b23c65d62a20921c709582b0b76b387f2bb9ebb5/contracts/crowdfund/ETHCrowdfundBase.sol#L270<br>\nhttps://github.com/code-423n4/2023-10-party/blob/b23c65d62a20921c709582b0b76b387f2bb9ebb5/contracts/crowdfund/InitialETHCrowdfund.sol#L329\n\nWhen a user contributes to an `InitialETHCrowdfund`, the native tokens they send are stored and converted as shares in a `PartyGovernanceNFT`, scaled down with the `exchangeRateBps` and `fundingSplitBps` factors:\n\n```Solidity\n        // InitialETHCrowdfund:295\n\n        votingPower = _processContribution(contributor, delegate, amount);\n\n        // OK to contribute with zero just to update delegate.\n        if (amount == 0) return 0;\n\n        if (tokenId == 0) {\n            // Mint contributor a new party card.\n            party.mint(contributor, votingPower, delegate);\n```\n\n```Solidity\n        // ETHCrowdfundBase:263\n        \n        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {\n            // Removes funding split from contribution amount in a way that\n            // avoids rounding errors for very small contributions <1e4 wei.\n            amount = (amount * (1e4 - fundingSplitBps_)) / 1e4;\n        }\n\n        votingPower = (amount * exchangeRateBps) / 1e4;\n```\n\nThis down-scaling can incur a precision loss, up to a theoretical `999_999` per contribution, that is not sent back to the user at contribution time nor refunded after up-scaling in case the crowdfund is lost.\n\nConsider refunding the unused tokens when the user contributes to a crowdfund. This wouldn't come at a significant cost in gas, because in the cases where users contribute round figures, an `if` would prevent a useless transfer from happening.\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2023-10-party",
  "Code": [
    {
      "filename": "contracts/crowdfund/InitialETHCrowdfund.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.20;\n\nimport { ETHCrowdfundBase } from \"./ETHCrowdfundBase.sol\";\nimport { ProposalStorage } from \"../proposals/ProposalStorage.sol\";\nimport { LibAddress } from \"../utils/LibAddress.sol\";\nimport { LibRawResult } from \"../utils/LibRawResult.sol\";\nimport { LibSafeCast } from \"../utils/LibSafeCast.sol\";\nimport { Party, PartyGovernance } from \"../party/Party.sol\";\nimport { Crowdfund } from \"../crowdfund/Crowdfund.sol\";\nimport { MetadataProvider } from \"../renderers/MetadataProvider.sol\";\nimport { IGateKeeper } from \"../gatekeepers/IGateKeeper.sol\";\nimport { IGlobals } from \"../globals/IGlobals.sol\";\nimport { IERC721 } from \"../tokens/IERC721.sol\";\n\n/// @notice A crowdfund for raising the initial funds for new parties.\n///         Unlike other crowdfunds that are started for the purpose of\n///         acquiring NFT(s), this crowdfund simply bootstraps a party with\n///         funds and lets its members coordinate on what to do with it after.\ncontract InitialETHCrowdfund is ETHCrowdfundBase {\n    using LibRawResult for bytes;\n    using LibSafeCast for uint256;\n    using LibAddress for address payable;\n\n    // Options to be passed into `initialize()` when the crowdfund is created.\n    struct InitialETHCrowdfundOptions {\n        address payable initialContributor;\n        address initialDelegate;\n        uint96 minContribution;\n        uint96 maxContribution;\n        bool disableContributingForExistingCard;\n        uint96 minTotalContributions;\n        uint96 maxTotalContributions;\n        uint16 exchangeRateBps;\n        uint16 fundingSplitBps;\n        address payable fundingSplitRecipient;\n        uint40 duration;\n        IGateKeeper gateKeeper;\n        bytes12 gateKeeperId;\n    }\n\n    struct ETHPartyOptions {\n        // Name of the party.\n        string name;\n        // Symbol of the party.\n        string symbol;\n        // The ID of the customization preset to use for the party card.\n        uint256 customizationPresetId;\n        // Options to initialize party governance with.\n        Crowdfund.FixedGovernanceOpts governanceOpts;\n        // Options to initialize party proposal engine with.\n        ProposalStorage.ProposalEngineOpts proposalEngineOpts;\n        // The tokens that are considered precious by the party.These are\n        // protected assets and are subject to extra restrictions in proposals\n        // vs other assets.\n        IERC721[] preciousTokens;\n        // The IDs associated with each token in `preciousTokens`.\n        uint256[] preciousTokenIds;\n        // The timestamp until which ragequit is enabled.\n        uint40 rageQuitTimestamp;\n        // Initial authorities to set on the party\n        address[] authorities;\n    }\n\n    struct BatchContributeArgs {\n        // IDs of cards to credit the contributions to. When set to 0, it means\n        uint256[] tokenIds;\n        // The address to which voting power will be delegated for all contributions.\n        address delegate;\n        // The contribution amounts in wei. The length of this array must be\n        // equal to the length of `tokenIds`.\n        uint96[] values;\n        // The data required to be validated by the `gatekeeper`, if set. If no\n        // `gatekeeper` is set, this can be empty.\n        bytes[] gateDatas;\n    }\n\n    struct BatchContributeForArgs {\n        // IDs of cards to credit the contributions to. When set to 0, it means\n        // a new one should be minted.\n        uint256[] tokenIds;\n        // Addresses of to credit the contributions under. Each contribution\n        // amount in `values` corresponds to a recipient in this array.\n        address payable[] recipients;\n        // The delegate to set for each recipient if they have not delegated\n        // before.\n        address[] initialDelegates;\n        // The contribution amounts in wei. The length of this array must be\n        // equal to the length of `recipients`.\n        uint96[] values;\n        // The data required to be validated by the `gatekeeper`, if set. If no\n        // `gatekeeper` is set, this can be empty.\n        bytes[] gateDatas;\n    }\n\n    event Refunded(address indexed contributor, uint256 indexed tokenId, uint256 amount);\n\n    // Set the `Globals` contract.\n    constructor(IGlobals globals) ETHCrowdfundBase(globals) {}\n\n    /// @notice Initializer to be delegatecalled by `Proxy` constructor. Will\n    ///         revert if called outside the constructor.\n    /// @param crowdfundOpts Options to initialize the crowdfund with.\n    /// @param partyOpts Options to initialize the party with.\n    /// @param customMetadataProvider Optional provider to use for the party for\n    ///                               rendering custom metadata.\n    /// @param customMetadata Optional custom metadata to use for the party.\n    function initialize(\n        InitialETHCrowdfundOptions memory crowdfundOpts,\n        ETHPartyOptions memory partyOpts,\n        MetadataProvider customMetadataProvider,\n        bytes memory customMetadata\n    ) external payable onlyInitialize {\n        // Create party the initial crowdfund will be for.\n        Party party_ = _createParty(partyOpts, customMetadataProvider, customMetadata);\n\n        // Initialize the crowdfund.\n        _initialize(\n            ETHCrowdfundOptions({\n                party: party_,\n                initialContributor: crowdfundOpts.initialContributor,\n                initialDelegate: crowdfundOpts.initialDelegate,\n                minContribution: crowdfundOpts.minContribution,\n                maxContribution: crowdfundOpts.maxContribution,\n                disableContributingForExistingCard: crowdfundOpts\n                    .disableContributingForExistingCard,\n                minTotalContributions: crowdfundOpts.minTotalContributions,\n                maxTotalContributions: crowdfundOpts.maxTotalContributions,\n                exchangeRateBps: crowdfundOpts.exchangeRateBps,\n                fundingSplitBps: crowdfundOpts.fundingSplitBps,\n                fundingSplitRecipient: crowdfundOpts.fundingSplitRecipient,\n                duration: crowdfundOpts.duration,\n                gateKeeper: crowdfundOpts.gateKeeper,\n                gateKeeperId: crowdfundOpts.gateKeeperId\n            })\n        );\n\n        // If the deployer passed in some ETH during deployment, credit them\n        // for the initial contribution.\n        uint96 initialContribution = msg.value.safeCastUint256ToUint96();\n        if (initialContribution > 0) {\n            // If this contract has ETH, either passed in during deployment or\n            // pre-existing, credit it to the `initialContributor`.\n            _contribute(\n                crowdfundOpts.initialContributor,\n                crowdfundOpts.initialDelegate,\n                initialContribution,\n                0,\n                \"\"\n            );\n        }\n\n        // Set up gatekeeper after initial contribution (initial always gets in).\n        gateKeeper = crowdfundOpts.gateKeeper;\n        gateKeeperId = crowdfundOpts.gateKeeperId;\n    }\n\n    /// @notice Contribute ETH to this crowdfund on behalf of a contributor.\n    /// @param delegate The address to which voting power will be delegated to\n    ///                 during the governance phase.\n    /// @param gateData Data to pass to the gatekeeper to prove eligibility.\n    /// @return votingPower The voting power the contributor receives for their\n    ///                     contribution.\n    function contribute(\n        address delegate,\n        bytes memory gateData\n    ) public payable onlyDelegateCall returns (uint96 votingPower) {\n        return\n            _contribute(\n                payable(msg.sender),\n                delegate,\n                msg.value.safeCastUint256ToUint96(),\n                0, // Mint a new party card for the contributor.\n                gateData\n            );\n    }\n\n    /// @notice Contribute ETH to this crowdfund on behalf of a contributor.\n    /// @param tokenId The ID of the card the contribution is being made towards.\n    /// @param delegate The address to which voting power will be delegated to\n    ///                 during the governance phase.\n    /// @param gateData Data to pass to the gatekeeper to prove eligibility.\n    /// @return votingPower The voting power the contributor receives for their\n    ///                     contribution.\n    function contribute(\n        uint256 tokenId,\n        address delegate,\n        bytes memory gateData\n    ) public payable onlyDelegateCall returns (uint96 votingPower) {\n        return\n            _contribute(\n                payable(msg.sender),\n                delegate,\n                msg.value.safeCastUint256ToUint96(),\n                tokenId,\n                gateData\n            );\n    }\n\n    /// @notice `contribute()` in batch form.\n    ///         May not revert if any individual contribution fails.\n    /// @param args The arguments to pass to each `contribute()` call.\n    /// @return votingPowers The voting power received for each contribution.\n    function batchContribute(\n        BatchContributeArgs calldata args\n    ) external payable onlyDelegateCall returns (uint96[] memory votingPowers) {\n        uint256 numContributions = args.tokenIds.length;\n        votingPowers = new uint96[](numContributions);\n\n        uint256 ethAvailable = msg.value;\n        for (uint256 i; i < numContributions; ++i) {\n            ethAvailable -= args.values[i];\n\n            votingPowers[i] = _contribute(\n                payable(msg.sender),\n                args.delegate,\n                args.values[i],\n                args.tokenIds[i],\n                args.gateDatas[i]\n            );\n        }\n\n        // Refund any unused ETH.\n        if (ethAvailable > 0) payable(msg.sender).transfer(ethAvailable);\n    }\n\n    /// @notice Contribute to this crowdfund on behalf of another address.\n    /// @param tokenId The ID of the token to credit the contribution to, or\n    ///                zero to mint a new party card for the recipient\n    /// @param recipient The address to record the contribution under\n    /// @param initialDelegate The address to delegate to for the governance\n    ///                        phase if recipient hasn't delegated\n    /// @param gateData Data to pass to the gatekeeper to prove eligibility\n    /// @return votingPower The voting power received for the contribution\n    function contributeFor(\n        uint256 tokenId,\n        address payable recipient,\n        address initialDelegate,\n        bytes memory gateData\n    ) external payable onlyDelegateCall returns (uint96 votingPower) {\n        return\n            _contribute(\n                recipient,\n                initialDelegate,\n                msg.value.safeCastUint256ToUint96(),\n                tokenId,\n                gateData\n            );\n    }\n\n    /// @notice `contributeFor()` in batch form.\n    ///         May not revert if any individual contribution fails.\n    /// @param args The arguments for the batched `contributeFor()` calls.\n    /// @return votingPowers The voting power received for each contribution.\n    function batchContributeFor(\n        BatchContributeForArgs calldata args\n    ) external payable onlyDelegateCall returns (uint96[] memory votingPowers) {\n        votingPowers = new uint96[](args.recipients.length);\n        uint256 valuesSum;\n        for (uint256 i; i < args.recipients.length; ++i) {\n            votingPowers[i] = _contribute(\n                args.recipients[i],\n                args.initialDelegates[i],\n                args.values[i],\n                args.tokenIds[i],\n                args.gateDatas[i]\n            );\n            valuesSum += args.values[i];\n        }\n        if (msg.value != valuesSum) {\n            revert InvalidMessageValue();\n        }\n    }\n\n    function _contribute(\n        address payable contributor,\n        address delegate,\n        uint96 amount,\n        uint256 tokenId,\n        bytes memory gateData\n    ) private returns (uint96 votingPower) {\n        // Require a non-null delegate.\n        if (delegate == address(0)) {\n            revert InvalidDelegateError();\n        }\n\n        // Must not be blocked by gatekeeper.\n        IGateKeeper _gateKeeper = gateKeeper;\n        if (_gateKeeper != IGateKeeper(address(0))) {\n            if (!_gateKeeper.isAllowed(msg.sender, gateKeeperId, gateData)) {\n                revert NotAllowedByGateKeeperError(msg.sender, _gateKeeper, gateKeeperId, gateData);\n            }\n        }\n\n        votingPower = _processContribution(contributor, delegate, amount);\n\n        // OK to contribute with zero just to update delegate.\n        if (amount == 0) return 0;\n\n        if (tokenId == 0) {\n            // Mint contributor a new party card.\n            party.mint(contributor, votingPower, delegate);\n        } else if (disableContributingForExistingCard) {\n            revert ContributingForExistingCardDisabledError();\n        } else if (party.ownerOf(tokenId) == contributor) {\n            // Increase voting power of contributor's existing party card.\n            party.increaseVotingPower(tokenId, votingPower);\n        } else {\n            revert NotOwnerError(tokenId);\n        }\n    }\n\n    /// @notice Refund the owner of a party card and burn it. Only available if\n    ///         the crowdfund lost. Can be called to refund for self or on\n    ///         another's behalf.\n    /// @param tokenId The ID of the party card to refund the owner of then burn.\n    /// @return amount The amount of ETH refunded to the contributor.\n    function refund(uint256 tokenId) external returns (uint96 amount) {\n        // Check crowdfund lifecycle.\n        {\n            CrowdfundLifecycle lc = getCrowdfundLifecycle();\n            if (lc != CrowdfundLifecycle.Lost) {\n                revert WrongLifecycleError(lc);\n            }\n        }\n\n        // Get amount to refund.\n        uint96 votingPower = party.votingPowerByTokenId(tokenId).safeCastUint256ToUint96();\n        amount = convertVotingPowerToContribution(votingPower);\n\n        if (amount > 0) {\n            // Get contributor to refund.\n            address payable contributor = payable(party.ownerOf(tokenId));\n\n            // Burn contributor's party card.\n            party.burn(tokenId);\n\n            // Refund contributor.\n            contributor.transferEth(amount);\n\n            emit Refunded(contributor, tokenId, amount);\n        }\n    }\n\n    /// @notice `refund()` in batch form.\n    ///         May not revert if any individual refund fails.\n    /// @param tokenIds The IDs of the party cards to burn and refund the owners of.\n    /// @param revertOnFailure If true, revert if any refund fails.\n    /// @return amounts The amounts of ETH refunded for each refund.\n    function batchRefund(\n        uint256[] calldata tokenIds,\n        bool revertOnFailure\n    ) external returns (uint96[] memory amounts) {\n        uint256 numRefunds = tokenIds.length;\n        amounts = new uint96[](numRefunds);\n\n        for (uint256 i; i < numRefunds; ++i) {\n            (bool s, bytes memory r) = address(this).call(\n                abi.encodeCall(this.refund, (tokenIds[i]))\n            );\n\n            if (!s) {\n                if (revertOnFailure) {\n                    r.rawRevert();\n                }\n            } else {\n                amounts[i] = abi.decode(r, (uint96));\n            }\n        }\n    }\n\n    function _createParty(\n        ETHPartyOptions memory opts,\n        MetadataProvider customMetadataProvider,\n        bytes memory customMetadata\n    ) private returns (Party) {\n        uint256 authoritiesLength = opts.authorities.length + 1;\n        address[] memory authorities = new address[](authoritiesLength);\n        for (uint i = 0; i < authoritiesLength - 1; ++i) {\n            authorities[i] = opts.authorities[i];\n        }\n        authorities[authoritiesLength - 1] = address(this);\n\n        if (address(customMetadataProvider) == address(0)) {\n            return\n                opts.governanceOpts.partyFactory.createParty(\n                    opts.governanceOpts.partyImpl,\n                    authorities,\n                    Party.PartyOptions({\n                        name: opts.name,\n                        symbol: opts.symbol,\n                        customizationPresetId: opts.customizationPresetId,\n                        governance: PartyGovernance.GovernanceOpts({\n                            hosts: opts.governanceOpts.hosts,\n                            voteDuration: opts.governanceOpts.voteDuration,\n                            executionDelay: opts.governanceOpts.executionDelay,\n                            passThresholdBps: opts.governanceOpts.passThresholdBps,\n                            totalVotingPower: 0,\n                            feeBps: opts.governanceOpts.feeBps,\n                            feeRecipient: opts.governanceOpts.feeRecipient\n                        }),\n                        proposalEngine: opts.proposalEngineOpts\n                    }),\n                    opts.preciousTokens,\n                    opts.preciousTokenIds,\n                    opts.rageQuitTimestamp\n                );\n        } else {\n            return\n                opts.governanceOpts.partyFactory.createPartyWithMetadata(\n                    opts.governanceOpts.partyImpl,\n                    authorities,\n                    Party.PartyOptions({\n                        name: opts.name,\n                        symbol: opts.symbol,\n                        customizationPresetId: opts.customizationPresetId,\n                        governance: PartyGovernance.GovernanceOpts({\n                            hosts: opts.governanceOpts.hosts,\n                            voteDuration: opts.governanceOpts.voteDuration,\n                            executionDelay: opts.governanceOpts.executionDelay,\n                            passThresholdBps: opts.governanceOpts.passThresholdBps,\n                            totalVotingPower: 0,\n                            feeBps: opts.governanceOpts.feeBps,\n                            feeRecipient: opts.governanceOpts.feeRecipient\n                        }),\n                        proposalEngine: opts.proposalEngineOpts\n                    }),\n                    opts.preciousTokens,\n                    opts.preciousTokenIds,\n                    opts.rageQuitTimestamp,\n                    customMetadataProvider,\n                    customMetadata\n                );\n        }\n    }\n}"
    },
    {
      "filename": "contracts/crowdfund/ETHCrowdfundBase.sol",
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.20;\n\nimport \"../utils/LibAddress.sol\";\nimport \"../utils/LibSafeCast.sol\";\nimport \"../party/Party.sol\";\nimport \"../gatekeepers/IGateKeeper.sol\";\n\ncontract ETHCrowdfundBase is Implementation {\n    using LibRawResult for bytes;\n    using LibSafeCast for uint256;\n    using LibAddress for address payable;\n\n    enum CrowdfundLifecycle {\n        // In practice, this state is never used. If the crowdfund is ever in\n        // this stage, something is wrong (e.g. crowdfund was never initialized).\n        Invalid,\n        // Ready to accept contributions to reach contribution targets\n        // until a deadline or the minimum contribution target is reached and\n        // host finalizes.\n        Active,\n        // Expired and the minimum contribution target was not reached.\n        Lost,\n        // The crowdfund has expired and reached the minimum contribution\n        // target. It is now ready to finalize.\n        Won,\n        // A won crowdfund has been finalized, with funds transferred to the\n        // party and voting power successfully updated.\n        Finalized\n    }\n\n    // Options to be passed into `initialize()` when the crowdfund is created.\n    struct ETHCrowdfundOptions {\n        Party party;\n        address payable initialContributor;\n        address initialDelegate;\n        uint96 minContribution;\n        uint96 maxContribution;\n        bool disableContributingForExistingCard;\n        uint96 minTotalContributions;\n        uint96 maxTotalContributions;\n        uint16 exchangeRateBps;\n        uint16 fundingSplitBps;\n        address payable fundingSplitRecipient;\n        uint40 duration;\n        IGateKeeper gateKeeper;\n        bytes12 gateKeeperId;\n    }\n\n    error WrongLifecycleError(CrowdfundLifecycle lc);\n    error NotAllowedByGateKeeperError(\n        address contributor,\n        IGateKeeper gateKeeper,\n        bytes12 gateKeeperId,\n        bytes gateData\n    );\n    error OnlyPartyHostError();\n    error OnlyPartyDaoError(address notDao);\n    error OnlyPartyDaoOrHostError(address notDao);\n    error NotOwnerError(uint256 tokenId);\n    error OnlyWhenEmergencyActionsAllowedError();\n    error InvalidDelegateError();\n    error NotEnoughContributionsError(uint96 totalContribution, uint96 minTotalContributions);\n    error MinGreaterThanMaxError(uint96 min, uint96 max);\n    error MaxTotalContributionsCannotBeZeroError(uint96 maxTotalContributions);\n    error BelowMinimumContributionsError(uint96 contributions, uint96 minContributions);\n    error AboveMaximumContributionsError(uint96 contributions, uint96 maxContributions);\n    error InvalidExchangeRateError(uint16 exchangeRateBps);\n    error ContributingForExistingCardDisabledError();\n    error ZeroVotingPowerError();\n    error FundingSplitAlreadyPaidError();\n    error FundingSplitNotConfiguredError();\n    error InvalidMessageValue();\n\n    event Contributed(\n        address indexed sender,\n        address indexed contributor,\n        uint256 amount,\n        address delegate\n    );\n    event Finalized();\n    event FundingSplitSent(address indexed fundingSplitRecipient, uint256 amount);\n    event EmergencyExecuteDisabled();\n    event EmergencyExecute(address target, bytes data, uint256 amountEth);\n\n    // The `Globals` contract storing global configuration values. This contract\n    // is immutable and itâ€™s address will never change.\n    IGlobals private immutable _GLOBALS;\n\n    /// @notice The address of the `Party` contract instance associated\n    ///         with the crowdfund.\n    Party public party;\n    /// @notice The minimum amount of ETH that a contributor can send to\n    ///         participate in the crowdfund.\n    uint96 public minContribution;\n    /// @notice The maximum amount of ETH that a contributor can send to\n    ///         participate in the crowdfund per address.\n    uint96 public maxContribution;\n    /// @notice A boolean flag that determines whether contributors are allowed\n    ///         to increase the voting power of their existing party cards.\n    bool public disableContributingForExistingCard;\n    /// @notice Whether the funding split has been claimed by the funding split\n    ///         recipient.\n    bool public fundingSplitPaid;\n    /// @notice Whether the DAO has emergency powers for this crowdfund.\n    bool public emergencyExecuteDisabled;\n    /// @notice The minimum amount of total ETH contributions required for the\n    ///         crowdfund to be considered successful.\n    uint96 public minTotalContributions;\n    /// @notice The maximum amount of total ETH contributions allowed for the\n    ///         crowdfund.\n    uint96 public maxTotalContributions;\n    /// @notice The total amount of ETH contributed to the crowdfund so far.\n    uint96 public totalContributions;\n    /// @notice The timestamp at which the crowdfund will end or ended. If 0, the\n    ///         crowdfund has finalized.\n    uint40 public expiry;\n    /// @notice The exchange rate to use for converting ETH contributions to\n    ///         voting power in basis points (e.g. 10000 = 1:1).\n    uint16 public exchangeRateBps;\n    /// @notice The portion of contributions to send to the funding recipient in\n    ///         basis points (e.g. 100 = 1%).\n    uint16 public fundingSplitBps;\n    /// @notice The address to which a portion of the contributions is sent to.\n    address payable public fundingSplitRecipient;\n    /// @notice The gatekeeper contract used to restrict who can contribute to the party.\n    IGateKeeper public gateKeeper;\n    /// @notice The ID of the gatekeeper to use for restricting contributions to the party.\n    bytes12 public gateKeeperId;\n    /// @notice The address a contributor is delegating their voting power to.\n    mapping(address => address) public delegationsByContributor;\n\n    // Set the `Globals` contract.\n    constructor(IGlobals globals) {\n        _GLOBALS = globals;\n    }\n\n    // Initialize storage for proxy contracts, credit initial contribution (if\n    // any), and setup gatekeeper.\n    function _initialize(ETHCrowdfundOptions memory opts) internal {\n        // Set the minimum and maximum contribution amounts.\n        if (opts.minContribution > opts.maxContribution) {\n            revert MinGreaterThanMaxError(opts.minContribution, opts.maxContribution);\n        }\n        minContribution = opts.minContribution;\n        maxContribution = opts.maxContribution;\n        // Set the min total contributions.\n        if (opts.minTotalContributions > opts.maxTotalContributions) {\n            revert MinGreaterThanMaxError(opts.minTotalContributions, opts.maxTotalContributions);\n        }\n        minTotalContributions = opts.minTotalContributions;\n        // Set the max total contributions.\n        if (opts.maxTotalContributions == 0) {\n            // Prevent this because when `maxTotalContributions` is 0 the\n            // crowdfund is invalid in `getCrowdfundLifecycle()` meaning it has\n            // never been initialized.\n            revert MaxTotalContributionsCannotBeZeroError(opts.maxTotalContributions);\n        }\n        maxTotalContributions = opts.maxTotalContributions;\n        // Set the party crowdfund is for.\n        party = opts.party;\n        // Set the crowdfund start and end timestamps.\n        expiry = uint40(block.timestamp + opts.duration);\n        // Set the exchange rate.\n        if (opts.exchangeRateBps == 0) revert InvalidExchangeRateError(opts.exchangeRateBps);\n        exchangeRateBps = opts.exchangeRateBps;\n        // Set the funding split and its recipient.\n        fundingSplitBps = opts.fundingSplitBps;\n        fundingSplitRecipient = opts.fundingSplitRecipient;\n        // Set whether to disable contributing for existing card.\n        disableContributingForExistingCard = opts.disableContributingForExistingCard;\n    }\n\n    /// @notice Get the current lifecycle of the crowdfund.\n    function getCrowdfundLifecycle() public view returns (CrowdfundLifecycle lifecycle) {\n        if (maxTotalContributions == 0) {\n            return CrowdfundLifecycle.Invalid;\n        }\n\n        uint256 expiry_ = expiry;\n        if (expiry_ == 0) {\n            return CrowdfundLifecycle.Finalized;\n        }\n\n        if (block.timestamp >= expiry_) {\n            if (totalContributions >= minTotalContributions) {\n                return CrowdfundLifecycle.Won;\n            } else {\n                return CrowdfundLifecycle.Lost;\n            }\n        }\n\n        return CrowdfundLifecycle.Active;\n    }\n\n    function _processContribution(\n        address payable contributor,\n        address delegate,\n        uint96 amount\n    ) internal returns (uint96 votingPower) {\n        address oldDelegate = delegationsByContributor[contributor];\n        if (msg.sender == contributor || oldDelegate == address(0)) {\n            // Update delegate.\n            delegationsByContributor[contributor] = delegate;\n        } else {\n            // Prevent changing another's delegate if already delegated.\n            delegate = oldDelegate;\n        }\n\n        emit Contributed(msg.sender, contributor, amount, delegate);\n\n        // OK to contribute with zero just to update delegate.\n        if (amount == 0) return 0;\n\n        // Only allow contributions while the crowdfund is active.\n        CrowdfundLifecycle lc = getCrowdfundLifecycle();\n        if (lc != CrowdfundLifecycle.Active) {\n            revert WrongLifecycleError(lc);\n        }\n\n        // Check that the contribution amount is at or below the maximum.\n        uint96 maxContribution_ = maxContribution;\n        if (amount > maxContribution_) {\n            revert AboveMaximumContributionsError(amount, maxContribution_);\n        }\n\n        uint96 newTotalContributions = totalContributions + amount;\n        uint96 maxTotalContributions_ = maxTotalContributions;\n        if (newTotalContributions >= maxTotalContributions_) {\n            totalContributions = maxTotalContributions_;\n\n            // Finalize the crowdfund.\n            // This occurs before refunding excess contribution to act as a\n            // reentrancy guard.\n            _finalize(maxTotalContributions_);\n\n            // Refund excess contribution.\n            uint96 refundAmount = newTotalContributions - maxTotalContributions;\n            if (refundAmount > 0) {\n                amount -= refundAmount;\n                payable(msg.sender).transferEth(refundAmount);\n            }\n        } else {\n            totalContributions = newTotalContributions;\n        }\n\n        // Check that the contribution amount is at or above the minimum. This\n        // is done after `amount` is potentially reduced if refunding excess\n        // contribution. There is a case where this prevents a crowdfunds from\n        // reaching `maxTotalContributions` if the `minContribution` is greater\n        // than the difference between `maxTotalContributions` and the current\n        // `totalContributions`. In this scenario users will have to wait until\n        // the crowdfund expires or a host finalizes after\n        // `minTotalContribution` has been reached by calling `finalize()`.\n        uint96 minContribution_ = minContribution;\n        if (amount < minContribution_) {\n            revert BelowMinimumContributionsError(amount, minContribution_);\n        }\n\n        // Subtract fee from contribution amount if applicable.\n        address payable fundingSplitRecipient_ = fundingSplitRecipient;\n        uint16 fundingSplitBps_ = fundingSplitBps;\n        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {\n            // Removes funding split from contribution amount in a way that\n            // avoids rounding errors for very small contributions <1e4 wei.\n            amount = (amount * (1e4 - fundingSplitBps_)) / 1e4;\n        }\n\n        // Calculate voting power.\n        votingPower = (amount * exchangeRateBps) / 1e4;\n\n        if (votingPower == 0) revert ZeroVotingPowerError();\n    }\n\n    /// @notice Calculate the contribution amount from the given voting power.\n    /// @param votingPower The voting power to convert to a contribution amount.\n    /// @return amount The contribution amount.\n    function convertVotingPowerToContribution(\n        uint96 votingPower\n    ) public view returns (uint96 amount) {\n        amount = (votingPower * 1e4) / exchangeRateBps;\n\n        // Add back funding split to contribution amount if applicable.\n        address payable fundingSplitRecipient_ = fundingSplitRecipient;\n        uint16 fundingSplitBps_ = fundingSplitBps;\n        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {\n            amount = (amount * 1e4) / (1e4 - fundingSplitBps_);\n        }\n    }\n\n    function finalize() external {\n        uint96 totalContributions_ = totalContributions;\n\n        // Check that the crowdfund is not already finalized.\n        CrowdfundLifecycle lc = getCrowdfundLifecycle();\n        if (lc == CrowdfundLifecycle.Active) {\n            // Allow host to finalize crowdfund early if it has reached its minimum goal.\n            if (!party.isHost(msg.sender)) revert OnlyPartyHostError();\n\n            // Check that the crowdfund has reached its minimum goal.\n            uint96 minTotalContributions_ = minTotalContributions;\n            if (totalContributions_ < minTotalContributions_) {\n                revert NotEnoughContributionsError(totalContributions_, minTotalContributions_);\n            }\n        } else {\n            // Otherwise only allow finalization if the crowdfund has expired\n            // and been won. Can be finalized by anyone.\n            if (lc != CrowdfundLifecycle.Won) {\n                revert WrongLifecycleError(lc);\n            }\n        }\n\n        // Finalize the crowdfund.\n        _finalize(totalContributions_);\n    }\n\n    function _finalize(uint96 totalContributions_) internal {\n        // Finalize the crowdfund.\n        delete expiry;\n\n        // Transfer funding split to recipient if applicable.\n        address payable fundingSplitRecipient_ = fundingSplitRecipient;\n        uint16 fundingSplitBps_ = fundingSplitBps;\n        if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {\n            totalContributions_ -= (totalContributions_ * fundingSplitBps_) / 1e4;\n        }\n\n        // Update the party's total voting"
    }
  ]
}