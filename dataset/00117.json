{
  "Title": "Potentially unsafe cast from negative `int96` values",
  "Content": "**Description:** Where calculations are performed on `int96` values, for example when manipulating stems in [`LibSilo::stalkReward`](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/libraries/Silo/LibSilo.sol#L634-L638), [`LibTokenSilo::grownStalkForDeposit`](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/libraries/Silo/LibTokenSilo.sol#L422), and [`LibTokenSilo::calculateGrownStalkAndStem`](https://github.com/BeanstalkFarms/Beanstalk/blob/dfb418d185cd93eef08168ccaffe9de86bc1f062/protocol/contracts/libraries/Silo/LibTokenSilo.sol#L452), Beanstalk uses the `LibSafeMathSigned96` library. Based on the invariant that the stem for a new deposit should never exceed the stem tip for a given token, casting these values to `uint256` is fine since the difference between the two stem values should never be negative. However, in the event of a bug that violates this invariant, it could be possible to have a negative `int96` value cast to a very large `uint256` value, potentially resulting in a huge amount of stalk being minted.\n\nThis issue is already sufficiently [mitigated](https://github.com/BeanstalkFarms/Beanstalk/blob/08ca0d7d495c94f2a4366fb7f99da561b74cc1c0/protocol/contracts/libraries/Silo/LibTokenSilo.sol#L419-L422) in `LibTokenSilo::grownStalkForDeposit` and it appears the instance in `LibTokenSilo::calculateGrownStalkAndStem` can never reach this state. Additional logic should similarly be added to `LibSilo::stalkReward` to ensure that the result of subtraction is positive and thus the cast to `uint256` is safe.\n\n**Impact:** While it appears not currently exploitable, a bug in the calculation of the stem for a given deposit or stem tip for a given token in `LibSilo::stalkReward` could result in the erroneous minting of a large amount of stalk.\n\n**Proof of Concept:** The following forge test demonstrates this issue:\n```solidity\ncontract TestStemsUnsafeCasting is Test {\n    using LibSafeMathSigned96 for int96;\n\n    function stalkReward(int96 startStem, int96 endStem, uint128 bdv)\n        internal\n        view\n        returns (uint256)\n    {\n        int96 reward = endStem.sub(startStem).mul(int96(bdv));\n        console.logInt(reward);\n        console.logUint(uint128(reward));\n\n        return uint128(reward);\n    }\n\n    function test_stalk_reward() external {\n        uint256 reward = stalkReward(1200, 1000, 1337);\n        console.logUint(reward);\n    }\n}\n```\n\n**Recommended Mitigation:** Add additional logic to safely perform the cast from `int96` or otherwise handle the case where the result of stem subtraction could be negative.",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "protocol/contracts/libraries/Silo/LibSilo.sol",
      "content": "/**\n * SPDX-License-Identifier: MIT\n **/\n\npragma solidity =0.7.6;\npragma abicoder v2;\n\nimport \"../LibAppStorage.sol\";\nimport {C} from \"../../C.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport {LibBytes} from \"../LibBytes.sol\";\nimport {LibPRBMath} from \"../LibPRBMath.sol\";\nimport {LibTokenSilo} from \"./LibTokenSilo.sol\";\nimport {LibSafeMath128} from \"../LibSafeMath128.sol\";\nimport {LibSafeMathSigned96} from \"../LibSafeMathSigned96.sol\";\n\n/**\n * @title LibSilo\n * @author Publius\n * @notice Contains functions for minting, burning, and transferring of\n * Stalk and Roots within the Silo.\n *\n * @dev Here, we refer to \"minting\" as the combination of\n * increasing the total balance of Stalk/Roots, as well as allocating\n * them to a particular account. However, in other places throughout Beanstalk\n * (like during the Sunrise), Beanstalk's total balance of Stalk increases\n * without allocating to a particular account. One example is {Sun-rewardToSilo}\n * which increases `s.s.stalk` but does not allocate it to any account. The\n * allocation occurs during `{SiloFacet-plant}`. Does this change how we should\n * call \"minting\"?\n *\n * In the ERC20 context, \"minting\" increases the supply of a token and allocates\n * the new tokens to an account in one action. I've adjusted the comments below\n * to use \"mint\" in the same sense.\n */\nlibrary LibSilo {\n    using SafeMath for uint256;\n    using LibSafeMath128 for uint128;\n    using LibSafeMathSigned96 for int96;\n    using LibPRBMath for uint256;\n    using SafeCast for uint256;\n    \n    // The `VESTING_PERIOD` is the number of blocks that must pass before\n    // a farmer is credited with their earned beans issued that season. \n    uint256 internal constant VESTING_PERIOD = 10;\n\n    //////////////////////// EVENTS ////////////////////////    \n     \n    /**\n     * @notice Emitted when `account` gains or loses Stalk.\n     * @param account The account that gained or lost Stalk.\n     * @param delta The change in Stalk.\n     * @param deltaRoots The change in Roots.\n     *   \n     * @dev Should be emitted anytime a Deposit is added, removed or transferred\n     * AND anytime an account Mows Grown Stalk.\n     * \n     * BIP-24 included a one-time re-emission of {StalkBalanceChanged} for\n     * accounts that had executed a Deposit transfer between the Replant and\n     * BIP-24 execution. For more, see:\n     *\n     * [BIP-24](https://bean.money/bip-24)\n     * [Event-Emission](https://github.com/BeanstalkFarms/BIP-24-Event-Emission)\n     */\n    event StalkBalanceChanged(\n        address indexed account,\n        int256 delta,\n        int256 deltaRoots\n    );\n\n    /**\n     * @notice Emitted when a deposit is removed from the silo.\n     * \n     * @param account The account assoicated with the removed deposit.\n     * @param token The token address of the removed deposit.\n     * @param stem The stem of the removed deposit.\n     * @param amount The amount of \"token\" removed from an deposit.\n     * @param bdv The instanteous bdv removed from the deposit.\n     */\n    event RemoveDeposit(\n        address indexed account,\n        address indexed token,\n        int96 stem,\n        uint256 amount,\n        uint256 bdv\n    );\n\n    /**\n     * @notice Emitted when multiple deposits are removed from the silo.\n     * \n     * @param account The account assoicated with the removed deposit.\n     * @param token The token address of the removed deposit.\n     * @param stems A list of stems of the removed deposits.\n     * @param amounts A list of amounts removed from the deposits.\n     * @param amount the total summation of the amount removed.\n     * @param bdvs A list of bdvs removed from the deposits.\n     */\n    event RemoveDeposits(\n        address indexed account,\n        address indexed token,\n        int96[] stems,\n        uint256[] amounts,\n        uint256 amount,\n        uint256[] bdvs\n    );\n\n    struct AssetsRemoved {\n        uint256 tokensRemoved;\n        uint256 stalkRemoved;\n        uint256 bdvRemoved;\n    }\n\n    /**\n     * @notice Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator, \n        address indexed from, \n        address indexed to, \n        uint256[] ids, \n        uint256[] values\n    );\n\n    //////////////////////// MINT ////////////////////////\n\n    /**\n     * @dev Mints Stalk and Roots to `account`.\n     *\n     * `roots` are an underlying accounting variable that is used to track\n     * how many earned beans a user has. \n     * \n     * When a farmer's state is updated, the ratio should hold:\n     * \n     *  Total Roots     User Roots\n     * ------------- = ------------\n     *  Total Stalk     User Stalk\n     *  \n     * @param account the address to mint Stalk and Roots to\n     * @param stalk the amount of stalk to mint\n     */\n    function mintStalk(address account, uint256 stalk) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n\n        // Calculate the amount of Roots for the given amount of Stalk.\n        uint256 roots;\n        if (s.s.roots == 0) {\n            roots = uint256(stalk.mul(C.getRootsBase()));\n        } else {\n            roots = s.s.roots.mul(stalk).div(s.s.stalk);\n        }\n        \n        \n        // increment user and total stalk\n        s.s.stalk = s.s.stalk.add(stalk);\n        s.a[account].s.stalk = s.a[account].s.stalk.add(stalk);\n\n        // increment user and total roots\n        s.s.roots = s.s.roots.add(roots);\n        s.a[account].roots = s.a[account].roots.add(roots);\n\n\n        emit StalkBalanceChanged(account, int256(stalk), int256(roots));\n    }\n\n\n    /**\n     * @dev mints grownStalk to `account`.\n     * \n     * per the zero-withdraw update, if a user plants during the vesting period (see constant),\n     * the earned beans of the current season is deferred until the non vesting period.\n     * However, this causes a slight mismatch in the amount of roots to properly allocate to the user.\n     * \n     * The formula for calculating the roots is:\n     * GainedRoots = TotalRoots * GainedStalk / TotalStalk.\n     * \n     * Roots are utilized in {SiloExit.balanceOfEarnedBeans} to calculate the earned beans as such: \n     * EarnedBeans = (TotalStalk * userRoots / TotalRoots) - userStalk  \n     * \n     * Because TotalStalk increments when there are new beans issued (at sunrise), \n     * the amount of roots issued without the earned beans are:\n     * GainedRoots = TotalRoots * GainedStalk / (TotalStalk - NewEarnedStalk)\n     * \n     * since newEarnedStalk is always equal or greater than 0, the gained roots calculated without the earned beans\n     * will always be equal or larger than the gained roots calculated with the earned beans.\n     * \n     * @param account the address to mint Stalk and Roots to\n     * @param stalk the amount of stalk to mint\n     */\n    function mintGrownStalk(address account, uint256 stalk) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n\n        uint256 roots;\n        if (s.s.roots == 0) {\n            roots = stalk.mul(C.getRootsBase());\n        } else {\n            roots = s.s.roots.mul(stalk).div(s.s.stalk);\n            if (inVestingPeriod()) {\n                // Safe Math is unnecessary for because total Stalk > new Earned Stalk\n                uint256 rootsWithoutEarned = s.s.roots.add(s.vestingPeriodRoots).mul(stalk).div(s.s.stalk - s.newEarnedStalk);\n                // Safe Math is unnecessary for because rootsWithoutEarned >= roots\n                uint128 deltaRoots = (rootsWithoutEarned - roots).toUint128();\n                s.vestingPeriodRoots = s.vestingPeriodRoots.add(deltaRoots);\n                s.a[account].deltaRoots = deltaRoots;\n            }\n        }\n\n        // increment user and total stalk\n        s.s.stalk = s.s.stalk.add(stalk);\n        s.a[account].s.stalk = s.a[account].s.stalk.add(stalk);\n\n        // increment user and total roots\n        s.s.roots = s.s.roots.add(roots);\n        s.a[account].roots = s.a[account].roots.add(roots);\n\n        emit StalkBalanceChanged(account, int256(stalk), int256(roots));\n    }\n\n    //////////////////////// BURN ////////////////////////\n\n    /**\n     * @dev Burns Stalk and Roots from `account`.\n     *\n     * if the user withdraws in the vesting period, \n     * they forfeit their earned beans for that season, \n     * distrubuted to the other users.\n     */\n    function burnStalk(address account, uint256 stalk) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        if (stalk == 0) return;\n       \n        uint256 roots;\n        // Calculate the amount of Roots for the given amount of Stalk.\n        // We round up as it prevents an account having roots but no stalk.\n        \n        // if the user withdraws in the vesting period, they forfeit their earned beans for that season\n        // this is distributed to the other users.\n        if(inVestingPeriod()){\n            roots = s.s.roots.mulDiv(\n                stalk,\n                s.s.stalk-s.newEarnedStalk,\n                LibPRBMath.Rounding.Up\n            );\n            // cast to uint256 to prevent overflow\n            uint256 deltaRootsRemoved = uint256(s.a[account].deltaRoots)\n                .mul(stalk)\n                .div(s.a[account].s.stalk);\n            s.a[account].deltaRoots = s.a[account].deltaRoots.sub(deltaRootsRemoved.toUint128());\n        } else {\n            roots = s.s.roots.mulDiv(\n            stalk,\n            s.s.stalk,\n            LibPRBMath.Rounding.Up);\n        }\n\n        if (roots > s.a[account].roots) roots = s.a[account].roots;\n\n        // Decrease supply of Stalk; Remove Stalk from the balance of `account`\n        s.s.stalk = s.s.stalk.sub(stalk);\n        s.a[account].s.stalk = s.a[account].s.stalk.sub(stalk);\n\n        // Decrease supply of Roots; Remove Roots from the balance of `account`\n        s.s.roots = s.s.roots.sub(roots);\n        s.a[account].roots = s.a[account].roots.sub(roots);\n        \n        // Oversaturated was previously referred to as Raining and thus\n        // code references mentioning Rain really refer to Oversaturation\n        // If Beanstalk is Oversaturated, subtract Roots from both the\n        // account's and Beanstalk's Oversaturated Roots balances.\n        // For more info on Oversaturation, See {Weather.handleRain}\n        if (s.season.raining) {\n            s.r.roots = s.r.roots.sub(roots);\n            s.a[account].sop.roots = s.a[account].roots;\n        }\n\n        emit StalkBalanceChanged(account, -int256(stalk), -int256(roots));\n    }\n\n    //////////////////////// TRANSFER ////////////////////////\n\n    /**\n     * @notice Decrements the Stalk and Roots of `sender` and increments the Stalk\n     * and Roots of `recipient` by the same amount.\n     * \n     * If the transfer is done during the vesting period, the earned beans are still\n     * defered until after the vesting period has elapsed. \n     * @dev There may be cases where more than the earned beans \n     * of the current season is vested, but can be claimed after the v.e has ended.\n     * We accept this inefficency due to \n     * 1) the short vesting period.\n     * 2) math complexity/gas costs needed to implement a correct solution.\n     * 3) security risks.\n     */\n    function transferStalk(\n        address sender,\n        address recipient,\n        uint256 stalk\n    ) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint256 roots;\n        if(inVestingPeriod()){\n            // transferring all stalk means that the earned beans is transferred.\n            // deltaRoots cannot be transferred as it is calculated on an account basis. \n            if(stalk == s.a[sender].s.stalk){\n                s.a[sender].deltaRoots = 0;\n            } else {\n                // partial transfer\n                uint256 deltaRootsRemoved = uint256(s.a[sender].deltaRoots)\n                    .mul(stalk)\n                    .div(s.a[sender].s.stalk);\n                s.a[sender].deltaRoots = s.a[sender].deltaRoots.sub(deltaRootsRemoved.toUint128());\n            }\n            roots = stalk == s.a[sender].s.stalk\n                ? s.a[sender].roots\n                : s.s.roots.sub(1).mul(stalk).div(s.s.stalk - s.newEarnedStalk).add(1);\n        } else {\n            roots = stalk == s.a[sender].s.stalk\n            ? s.a[sender].roots\n            : s.s.roots.sub(1).mul(stalk).div(s.s.stalk).add(1);\n        }\n\n        // Subtract Stalk and Roots from the 'sender' balance.        \n        s.a[sender].s.stalk = s.a[sender].s.stalk.sub(stalk);\n        s.a[sender].roots = s.a[sender].roots.sub(roots);\n        emit StalkBalanceChanged(sender, -int256(stalk), -int256(roots));\n\n        // Add Stalk and Roots to the 'recipient' balance.\n        s.a[recipient].s.stalk = s.a[recipient].s.stalk.add(stalk);\n        s.a[recipient].roots = s.a[recipient].roots.add(roots);\n        emit StalkBalanceChanged(recipient, int256(stalk), int256(roots));\n    }\n\n    /**\n     * @dev Claims the Grown Stalk for `account` and applies it to their Stalk\n     * balance. Also handles Season of Plenty related rain.\n     *\n     * This is why `_mow()` must be called before any actions that change Seeds,\n     * including:\n     *  - {SiloFacet-deposit}\n     *  - {SiloFacet-withdrawDeposit}\n     *  - {SiloFacet-withdrawDeposits}\n     *  - {_plant}\n     *  - {SiloFacet-transferDeposit(s)}\n     */\n   function _mow(address account, address token) internal {\n\n        require(!migrationNeeded(account), \"Silo: Migration needed\");\n\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        //sop stuff only needs to be updated once per season\n        //if it started raining and it's still raining, or there was a sop\n        if (s.season.rainStart > s.season.stemStartSeason) {\n            uint32 lastUpdate = _lastUpdate(account);\n            if (lastUpdate <= s.season.rainStart && lastUpdate <= s.season.current) {\n                // Increments `plenty` for `account` if a Flood has occured.\n                // Saves Rain Roots for `account` if it is Raining.\n                handleRainAndSops(account, lastUpdate);\n\n                // Reset timer so that Grown Stalk for a particular Season can only be \n                // claimed one time. \n                s.a[account].lastUpdate = s.season.current;\n            }\n        }\n        \n        // Calculate the amount of Grown Stalk claimable by `account`.\n        // Increase the account's balance of Stalk and Roots.\n        __mow(account, token);\n\n        // was hoping to not have to update lastUpdate, but if you don't, then it's 0 for new depositors, this messes up mow and migrate in unit tests, maybe better to just set this manually for tests?\n        // anyone that would have done any deposit has to go through mowSender which would have init'd it above zero in the pre-migration days\n        s.a[account].lastUpdate = s.season.current;\n    }\n\n    /**\n     * @dev Updates the mowStatus for the given account and token, \n     * and mints Grown Stalk for the given account and token.\n     */\n    function __mow(address account, address token) private {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n\n        int96 _stemTip = LibTokenSilo.stemTipForToken(token);\n        int96 _lastStem =  s.a[account].mowStatuses[token].lastStem;\n        uint128 _bdv = s.a[account].mowStatuses[token].bdv;\n        \n        // if \n        // 1: account has no bdv (new token deposit)\n        // 2: the lastStem is the same as the stemTip (implying that a user has mowed),\n        // then skip calculations to save gas.\n        if (_bdv > 0) {\n            if (_lastStem == _stemTip) {\n                return;\n            }\n\n            mintGrownStalk(\n                account,\n                _balanceOfGrownStalk(\n                    _lastStem,\n                    _stemTip,\n                    _bdv\n                )\n            );\n        }\n\n        // If this `account` has no BDV, skip to save gas. Still need to update lastStem \n        // (happen on initial deposit, since mow is called before any deposit)\n        s.a[account].mowStatuses[token].lastStem = _stemTip;\n        return;\n    }\n\n    /**\n     * @notice returns the last season an account interacted with the silo.\n     */\n    function _lastUpdate(address account) internal view returns (uint32) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return s.a[account].lastUpdate;\n    }\n\n    /**\n     * @dev internal logic to handle when beanstalk is raining.\n     */\n    function handleRainAndSops(address account, uint32 lastUpdate) private {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        // If no roots, reset Sop counters variables\n        if (s.a[account].roots == 0) {\n            s.a[account].lastSop = s.season.rainStart;\n            s.a[account].lastRain = 0;\n            return;\n        }\n        // If a Sop has occured since last update, calculate rewards and set last Sop.\n        if (s.season.lastSopSeason > lastUpdate) {\n            s.a[account].sop.plenty = balanceOfPlenty(account);\n            s.a[account].lastSop = s.season.lastSop;\n        }\n        if (s.season.raining) {\n            // If rain started after update, set account variables to track rain.\n            if (s.season.rainStart > lastUpdate) {\n                s.a[account].lastRain = s.season.rainStart;\n                s.a[account].sop.roots = s.a[account].roots;\n            }\n            // If there has been a Sop since rain started,\n            // save plentyPerRoot in case another SOP happens during rain.\n            if (s.season.lastSop == s.season.rainStart) {\n                s.a[account].sop.plentyPerRoot = s.sops[s.season.lastSop];\n            }\n        } else if (s.a[account].lastRain > 0) {\n            // Reset Last Rain if not raining.\n            s.a[account].lastRain = 0;\n        }\n    }\n\n    /**\n     * @dev returns the balance of amount of grown stalk based on stems.\n     * @param lastStem the stem assoicated with the last mow\n     * @param latestStem the current stem for a given token\n     * @param bdv the bdv used to calculate grown stalk\n     */\n    function _balanceOfGrownStalk(\n        int96 lastStem,\n        int96 latestStem,\n        uint128 bdv\n    ) internal pure returns (uint256)\n    {\n        return stalkReward(lastStem, latestStem, bdv);\n    } \n\n    /**\n     * @dev returns the amount of `plenty` an account has.\n     */\n    function balanceOfPlenty(address account)\n        internal\n        view\n        returns (uint256 plenty)\n    {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        Account.State storage a = s.a[account];\n        plenty = a.sop.plenty;\n        uint256 previousPPR;\n\n        // If lastRain > 0, then check if SOP occured during the rain period.\n        if (s.a[account].lastRain > 0) {\n            // if the last processed SOP = the lastRain processed season,\n            // then we use the stored roots to get the delta.\n            if (a.lastSop == a.lastRain) previousPPR = a.sop.plentyPerRoot;\n            else previousPPR = s.sops[a.lastSop];\n            uint256 lastRainPPR = s.sops[s.a[account].lastRain];\n\n            // If there has been a SOP duing the rain sesssion since last update, process SOP.\n            if (lastRainPPR > previousPPR) {\n                uint256 plentyPerRoot = lastRainPPR - previousPPR;\n                previousPPR = lastRainPPR;\n                plenty = plenty.add(\n                    plentyPerRoot.mul(s.a[account].sop.roots).div(\n                        C.SOP_PRECISION\n                    )\n                );\n            }\n        } else {\n            // If it was not raining, just use the PPR at previous SOP.\n            previousPPR = s.sops[s.a[account].lastSop];\n        }\n\n        // Handle and SOPs that started + ended before after last Silo update.\n        if (s.season.lastSop > _lastUpdate(account)) {\n            uint256 plentyPerRoot = s.sops[s.season.lastSop].sub(previousPPR);\n            plenty = plenty.add(\n                plentyPerRoot.mul(s.a[account].roots).div(\n                    C.SOP_PRECISION\n                )\n            );\n        }\n    }\n\n    //////////////////////// REMOVE ////////////////////////\n\n    /**\n     * @dev Removes from a single Deposit, emits the RemoveDeposit event,\n     * and returns the Stalk/BDV that were removed.\n     *\n     * Used in:\n     * - {TokenSilo:_withdrawDeposit}\n     * - {TokenSilo:_transferDeposit}\n     */\n    function _removeDepositFromAccount(\n        address account,\n        address token,\n        int96 stem,\n        uint256 amount,\n        LibTokenSilo.Transfer transferType\n    )\n        internal\n        returns (\n            uint256 stalkRemoved,\n            uint256 bdvRemoved\n        )\n    {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n\n        bdvRemoved = LibTokenSilo.removeDepositFromAccount(account, token, stem, amount);\n\n        //need to get amount of stalk earned by this deposit (index of now minus index of when deposited)\n        stalkRemoved = bdvRemoved.mul(s.ss[token].stalkIssuedPerBdv).add(\n            stalkReward(\n                stem, //this is the index of when it was deposited\n                LibTokenSilo.stemTipForToken(token), //this is latest for this token\n                bdvRemoved.toUint128()\n            )\n        );\n        /** \n         *  {_removeDepositFromAccount} is used for both withdrawing and transferring deposits.\n         *  In the case of a withdraw, only the {TransferSingle} Event needs to be emitted.\n         *  In the case of a transfer, a different {TransferSingle}/{TransferBatch} \n         *  Event is emitted in {TokenSilo._transferDeposit(s)}, \n         *  and thus, this event is ommited.\n         */\n        if(transferType == LibTokenSilo.Transfer.emitTransferSingle){\n            // \"removing\" a deposit is equivalent to \"burning\" an ERC1155 token.\n            emit LibTokenSilo.TransferSingle(\n                msg.sender, // operator\n                account, // from\n                address(0), // to\n                LibBytes.packAddressAndStem(token, stem), // depositid\n                amount // token amount\n            );\n        }\n        emit RemoveDeposit(account, token, stem, amount, bdvRemoved);\n    }\n\n    /**\n     * @dev Removes from multiple Deposits, emits the RemoveDeposits\n     * event, and returns the Stalk/BDV that were removed.\n     * \n     * Used in:\n     * - {TokenSilo:_withdrawDeposits}\n     * - {SiloFacet:enrootDeposits}\n     */\n    function _removeDepositsFromAccount(\n        address account,\n        address token,\n        int96[] calldata stems,\n        uint256[] calldata amounts\n    ) internal returns (AssetsRemoved memory ar) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n\n        //make bdv array and add here?\n        uint256[] memory bdvsRemoved = new uint256[](stems.length);\n        uint256[] memory removedDepositIDs = new uint256[](stems.length);\n\n        for (uint256 i; i < stems.length; ++i) {\n            uint256 crateBdv = LibTokenSilo.removeDepositFromAccount(\n                account,\n                token,\n                stems[i],\n                amounts[i]\n            );\n            bdvsRemoved[i] = crateBdv;\n            removedDepositIDs[i] = LibBytes.packAddressAndStem(token, stems[i]);\n            ar.bdvRemoved = ar.bdvRemoved.add(crateBdv);\n            ar.tokensRemoved = ar.tokensRemoved.add(amounts[i]);\n\n            ar.stalkRemoved = ar.stalkRemoved.add(\n                stalkReward(\n                    stems[i],\n                    LibTokenSilo.stemTipForToken(token),\n                    crateBdv.toUint128()\n                )\n            );\n\n        }\n\n        ar.stalkRemoved = ar.stalkRemoved.add(\n            ar.bdvRemoved.mul(s.ss[token].stalkIssuedPerBdv)\n        );\n\n        // \"removing\" deposits is equivalent to \"burning\" a batch of ERC1155 tokens.\n        emit TransferBatch(msg.sender, account, address(0), removedDepositIDs, amounts);\n        emit RemoveDeposits(account, token, stems, amounts, ar.tokensRemoved, bdvsRemoved);\n    }\n\n    \n    //////////////////////// UTILITIES ////////////////////////\n\n    /**\n     * @dev Calculates the Stalk reward based on the start and end\n     * stems, and the amount of BDV deposited. Stems represent the\n     * amount of grown stalk per BDV, so the difference between the \n     * start index and end index (stem) multiplied by the amount of\n     * bdv deposited will give the amount of stalk earned.\n     * formula: stalk = bdv * (Î”stalkPerBdv)\n     */\n    function stalkReward(int96 startStem, int96 endStem, uint128 bdv) //are the types what we want here?\n        internal\n        pure\n        returns (uint256)\n    {\n        int96 reward = endStem.sub(startStem).mul(int96(bdv));\n        \n        return uint128(reward);\n    }\n\n    /**\n     * @dev check whether beanstalk is in the vesting period.\n     */\n    function inVestingPeriod() internal view returns (bool) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return block.number - s.season.sunriseBlock <= VESTING_PERIOD;\n    }\n\n    /**\n     * @dev check whether the account needs to be migrated.\n     */\n    function migrationNeeded(address account) internal view returns (bool) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return s.a[account].lastUpdate > 0 && s.a[account].lastUpdate < s.season.stemStartSeason;\n    }\n}"
    }
  ]
}