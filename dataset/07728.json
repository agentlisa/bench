{
  "Title": "[03] Typo Mistakes",
  "Content": "\nhttps://github.com/code-423n4/2022-11-looksrare/blob/main/contracts/libraries/seaport/ConsiderationStructs.sol#L168\n\n```\n    @ are\n *      type is restricted and the offerer or zone are not the caller.\n```\n\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/reports/2022-11-looksrare",
  "Code": [
    {
      "filename": "contracts/libraries/seaport/ConsiderationStructs.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// prettier-ignore\nimport {\n    OrderType,\n    BasicOrderType,\n    ItemType,\n    Side\n} from \"./ConsiderationEnums.sol\";\n\n/**\n * @dev An order contains eleven components: an offerer, a zone (or account that\n *      can cancel the order or restrict who can fulfill the order depending on\n *      the type), the order type (specifying partial fill support as well as\n *      restricted order status), the start and end time, a hash that will be\n *      provided to the zone when validating restricted orders, a salt, a key\n *      corresponding to a given conduit, a counter, and an arbitrary number of\n *      offer items that can be spent along with consideration items that must\n *      be received by their respective recipient.\n */\nstruct OrderComponents {\n    address offerer;\n    address zone;\n    OfferItem[] offer;\n    ConsiderationItem[] consideration;\n    OrderType orderType;\n    uint256 startTime;\n    uint256 endTime;\n    bytes32 zoneHash;\n    uint256 salt;\n    bytes32 conduitKey;\n    uint256 counter;\n}\n\n/**\n * @dev An offer item has five components: an item type (ETH or other native\n *      tokens, ERC20, ERC721, and ERC1155, as well as criteria-based ERC721 and\n *      ERC1155), a token address, a dual-purpose \"identifierOrCriteria\"\n *      component that will either represent a tokenId or a merkle root\n *      depending on the item type, and a start and end amount that support\n *      increasing or decreasing amounts over the duration of the respective\n *      order.\n */\nstruct OfferItem {\n    ItemType itemType;\n    address token;\n    uint256 identifierOrCriteria;\n    uint256 startAmount;\n    uint256 endAmount;\n}\n\n/**\n * @dev A consideration item has the same five components as an offer item and\n *      an additional sixth component designating the required recipient of the\n *      item.\n */\nstruct ConsiderationItem {\n    ItemType itemType;\n    address token;\n    uint256 identifierOrCriteria;\n    uint256 startAmount;\n    uint256 endAmount;\n    address payable recipient;\n}\n\n/**\n * @dev A spent item is translated from a utilized offer item and has four\n *      components: an item type (ETH or other native tokens, ERC20, ERC721, and\n *      ERC1155), a token address, a tokenId, and an amount.\n */\nstruct SpentItem {\n    ItemType itemType;\n    address token;\n    uint256 identifier;\n    uint256 amount;\n}\n\n/**\n * @dev A received item is translated from a utilized consideration item and has\n *      the same four components as a spent item, as well as an additional fifth\n *      component designating the required recipient of the item.\n */\nstruct ReceivedItem {\n    ItemType itemType;\n    address token;\n    uint256 identifier;\n    uint256 amount;\n    address payable recipient;\n}\n\n/**\n * @dev For basic orders involving ETH / native / ERC20 <=> ERC721 / ERC1155\n *      matching, a group of six functions may be called that only requires a\n *      subset of the usual order arguments. Note the use of a \"basicOrderType\"\n *      enum; this represents both the usual order type as well as the \"route\"\n *      of the basic order (a simple derivation function for the basic order\n *      type is `basicOrderType = orderType + (4 * basicOrderRoute)`.)\n */\nstruct BasicOrderParameters {\n    // calldata offset\n    address considerationToken; // 0x24\n    uint256 considerationIdentifier; // 0x44\n    uint256 considerationAmount; // 0x64\n    address payable offerer; // 0x84\n    address zone; // 0xa4\n    address offerToken; // 0xc4\n    uint256 offerIdentifier; // 0xe4\n    uint256 offerAmount; // 0x104\n    BasicOrderType basicOrderType; // 0x124\n    uint256 startTime; // 0x144\n    uint256 endTime; // 0x164\n    bytes32 zoneHash; // 0x184\n    uint256 salt; // 0x1a4\n    bytes32 offererConduitKey; // 0x1c4\n    bytes32 fulfillerConduitKey; // 0x1e4\n    uint256 totalOriginalAdditionalRecipients; // 0x204\n    AdditionalRecipient[] additionalRecipients; // 0x224\n    bytes signature; // 0x244\n    // Total length, excluding dynamic array data: 0x264 (580)\n}\n\n/**\n * @dev Basic orders can supply any number of additional recipients, with the\n *      implied assumption that they are supplied from the offered ETH (or other\n *      native token) or ERC20 token for the order.\n */\nstruct AdditionalRecipient {\n    uint256 amount;\n    address payable recipient;\n}\n\n/**\n * @dev The full set of order components, with the exception of the counter,\n *      must be supplied when fulfilling more sophisticated orders or groups of\n *      orders. The total number of original consideration items must also be\n *      supplied, as the caller may specify additional consideration items.\n */\nstruct OrderParameters {\n    address offerer; // 0x00\n    address zone; // 0x20\n    OfferItem[] offer; // 0x40\n    ConsiderationItem[] consideration; // 0x60\n    OrderType orderType; // 0x80\n    uint256 startTime; // 0xa0\n    uint256 endTime; // 0xc0\n    bytes32 zoneHash; // 0xe0\n    uint256 salt; // 0x100\n    bytes32 conduitKey; // 0x120\n    uint256 totalOriginalConsiderationItems; // 0x140\n    // offer.length                          // 0x160\n}\n\n/**\n * @dev Orders require a signature in addition to the other order parameters.\n */\nstruct Order {\n    OrderParameters parameters;\n    bytes signature;\n}\n\n/**\n * @dev Advanced orders include a numerator (i.e. a fraction to attempt to fill)\n *      and a denominator (the total size of the order) in addition to the\n *      signature and other order parameters. It also supports an optional field\n *      for supplying extra data; this data will be included in a staticcall to\n *      `isValidOrderIncludingExtraData` on the zone for the order if the order\n *      type is restricted and the offerer or zone are not the caller.\n */\nstruct AdvancedOrder {\n    OrderParameters parameters;\n    uint120 numerator;\n    uint120 denominator;\n    bytes signature;\n    bytes extraData;\n}\n\n/**\n * @dev Orders can be validated (either explicitly via `validate`, or as a\n *      consequence of a full or partial fill), specifically cancelled (they can\n *      also be cancelled in bulk via incrementing a per-zone counter), and\n *      partially or fully filled (with the fraction filled represented by a\n *      numerator and denominator).\n */\nstruct OrderStatus {\n    bool isValidated;\n    bool isCancelled;\n    uint120 numerator;\n    uint120 denominator;\n}\n\n/**\n * @dev A criteria resolver specifies an order, side (offer vs. consideration),\n *      and item index. It then provides a chosen identifier (i.e. tokenId)\n *      alongside a merkle proof demonstrating the identifier meets the required\n *      criteria.\n */\nstruct CriteriaResolver {\n    uint256 orderIndex;\n    Side side;\n    uint256 index;\n    uint256 identifier;\n    bytes32[] criteriaProof;\n}\n\n/**\n * @dev A fulfillment is applied to a group of orders. It decrements a series of\n *      offer and consideration items, then generates a single execution\n *      element. A given fulfillment can be applied to as many offer and\n *      consideration items as desired, but must contain at least one offer and\n *      at least one consideration that match. The fulfillment must also remain\n *      consistent on all key parameters across all offer items (same offerer,\n *      token, type, tokenId, and conduit preference) as well as across all\n *      consideration items (token, type, tokenId, and recipient).\n */\nstruct Fulfillment {\n    FulfillmentComponent[] offerComponents;\n    FulfillmentComponent[] considerationComponents;\n}\n\n/**\n * @dev Each fulfillment component contains one index referencing a specific\n *      order and another referencing a specific offer or consideration item.\n */\nstruct FulfillmentComponent {\n    uint256 orderIndex;\n    uint256 itemIndex;\n}\n\n/**\n * @dev An execution is triggered once all consideration items have been zeroed\n *      out. It sends the item in question from the offerer to the item's\n *      recipient, optionally sourcing approvals from either this contract\n *      directly or from the offerer's chosen conduit if one is specified. An\n *      execution is not provided as an argument, but rather is derived via\n *      orders, criteria resolvers, and fulfillments (where the total number of\n *      executions will be less than or equal to the total number of indicated\n *      fulfillments) and returned as part of `matchOrders`.\n */\nstruct Execution {\n    ReceivedItem item;\n    address offerer;\n    bytes32 conduitKey;\n}"
    }
  ]
}