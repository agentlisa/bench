{
  "Title": "Unbounded number of programs could result in errors",
  "Content": "The [`programs`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/rewards/AutoCompoundingRewards.sol#L191) function loops over a potentially unbounded list of programs/pools.\n\n\nRelatedly, the [`pools`](https://github.com/bancorprotocol/contracts-v3/blob/b2224595afab14827ee065cb65a1444d61689fb3/contracts/rewards/AutoCompoundingRewards.sol#L205) function requires that all stored values associated with stored pools are first loaded into memory for the call to complete.\n\n\nIn either case, if too many programs are added to the protocol, these functions will run out of gas.\n\n\nAlthough neither of these functions are used internally, should the number of programs grow too large, they could be problematic for external contracts that might rely on them.\n\n\nConsider either adding a pagination mechanism to limit the number of stored values that must be loaded or adding some warning to the documentation about the need to keep the number of programs bounded to some safe level to avoid issues with these functions.\n\n\n**Update:** *Acknowledged. The client conveyed that simplicity of the external interface was an intentional design choice. If future on-chain usage becomes relevant the respective contract will be upgraded.*\n\n\n",
  "Impact": "LOW",
  "Source": "",
  "Code": [
    {
      "filename": "contracts/rewards/AutoCompoundingRewards.sol",
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { EnumerableSetUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport { IVersioned } from \"../utility/interfaces/IVersioned.sol\";\nimport { Upgradeable } from \"../utility/Upgradeable.sol\";\nimport { Utils, AccessDenied, DoesNotExist, AlreadyExists, InvalidParam } from \"../utility/Utils.sol\";\nimport { Time } from \"../utility/Time.sol\";\n\nimport { INetworkSettings, NotWhitelisted } from \"../network/interfaces/INetworkSettings.sol\";\nimport { IBancorNetwork } from \"../network/interfaces/IBancorNetwork.sol\";\n\nimport { IPoolToken } from \"../pools/interfaces/IPoolToken.sol\";\nimport { IBNTPool } from \"../pools/interfaces/IBNTPool.sol\";\n\nimport { Token } from \"../token/Token.sol\";\nimport { TokenLibrary } from \"../token/TokenLibrary.sol\";\n\nimport { IVault } from \"../vaults/interfaces/IVault.sol\";\nimport { IExternalRewardsVault } from \"../vaults/interfaces/IExternalRewardsVault.sol\";\n\n// prettier-ignore\nimport {\n    IAutoCompoundingRewards,\n    ProgramData,\n    FLAT_DISTRIBUTION,\n    EXP_DECAY_DISTRIBUTION\n} from \"./interfaces/IAutoCompoundingRewards.sol\";\n\nimport { RewardsMath } from \"./RewardsMath.sol\";\n\n/**\n * @dev Auto-compounding Rewards contract\n */\ncontract AutoCompoundingRewards is IAutoCompoundingRewards, ReentrancyGuardUpgradeable, Utils, Time, Upgradeable {\n    using TokenLibrary for Token;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    error InsufficientFunds();\n\n    // the default number of programs to auto-process the rewards for\n    uint8 private constant DEFAULT_AUTO_PROCESS_REWARDS_COUNT = 3;\n\n    // the minimum time elapsed before the rewards of a program can be auto-processed\n    uint16 private constant AUTO_PROCESS_REWARDS_MIN_TIME_DELTA = 1 hours;\n\n    // the factor used to calculate the maximum number of programs to attempt to auto-process in a single attempt\n    uint8 private constant AUTO_PROCESS_MAX_PROGRAMS_FACTOR = 2;\n\n    // the network contract\n    IBancorNetwork private immutable _network;\n\n    // the network settings contract\n    INetworkSettings private immutable _networkSettings;\n\n    // the BNT contract\n    IERC20 private immutable _bnt;\n\n    // the BNT pool contract\n    IBNTPool private immutable _bntPool;\n\n    // the BNT pool token contract\n    IPoolToken private immutable _bntPoolToken;\n\n    // the address of the external rewards vault\n    IExternalRewardsVault private immutable _externalRewardsVault;\n\n    // a mapping between pools and programs\n    mapping(Token => ProgramData) private _programs;\n\n    // a set of all pools that have a rewards program associated with them\n    EnumerableSetUpgradeable.AddressSet private _pools;\n\n    // the number of programs to auto-process the rewards for\n    uint256 private _autoProcessRewardsCount;\n\n    // the index of the next program to auto-process the rewards for\n    uint256 internal _autoProcessRewardsIndex;\n\n    // upgrade forward-compatibility storage gap\n    uint256[MAX_GAP - 5] private __gap;\n\n    /**\n     * @dev triggered when a flat program is created\n     */\n    event FlatProgramCreated(Token indexed pool, uint256 totalRewards, uint32 startTime, uint32 endTime);\n\n    /**\n     * @dev triggered when an exponential-decay program is created\n     */\n    event ExpDecayProgramCreated(Token indexed pool, uint256 totalRewards, uint32 startTime, uint32 halfLife);\n\n    /**\n     * @dev triggered when a program is terminated prematurely\n     */\n    event ProgramTerminated(Token indexed pool, uint32 endTime, uint256 remainingRewards);\n\n    /**\n     * @dev triggered when a program is enabled/disabled\n     */\n    event ProgramEnabled(Token indexed pool, bool status, uint256 remainingRewards);\n\n    /**\n     * @dev triggered when the number of programs to auto-process the rewards for is updated\n     */\n    event AutoProcessRewardsCountUpdated(uint256 prevCount, uint256 newCount);\n\n    /**\n     * @dev triggered when rewards are distributed\n     */\n    event RewardsDistributed(\n        Token indexed pool,\n        uint256 rewardsAmount,\n        uint256 poolTokenAmount,\n        uint256 remainingRewards\n    );\n\n    /**\n     * @dev a \"virtual\" constructor that is only used to set immutable state variables\n     */\n    constructor(\n        IBancorNetwork initNetwork,\n        INetworkSettings initNetworkSettings,\n        IERC20 initBNT,\n        IBNTPool initBNTPool,\n        IExternalRewardsVault initExternalRewardsVault\n    )\n        validAddress(address(initNetwork))\n        validAddress(address(initNetworkSettings))\n        validAddress(address(initBNT))\n        validAddress(address(initBNTPool))\n        validAddress(address(initExternalRewardsVault))\n    {\n        _network = initNetwork;\n        _networkSettings = initNetworkSettings;\n        _bnt = initBNT;\n        _bntPool = initBNTPool;\n        _bntPoolToken = initBNTPool.poolToken();\n        _externalRewardsVault = initExternalRewardsVault;\n    }\n\n    /**\n     * @dev fully initializes the contract and its parents\n     */\n    function initialize() external initializer {\n        __AutoCompoundingRewards_init();\n    }\n\n    // solhint-disable func-name-mixedcase\n\n    /**\n     * @dev initializes the contract and its parents\n     */\n    function __AutoCompoundingRewards_init() internal onlyInitializing {\n        __ReentrancyGuard_init();\n        __Upgradeable_init();\n\n        __AutoCompoundingRewards_init_unchained();\n    }\n\n    /**\n     * @dev performs contract-specific initialization\n     */\n    function __AutoCompoundingRewards_init_unchained() internal onlyInitializing {\n        _autoProcessRewardsCount = DEFAULT_AUTO_PROCESS_REWARDS_COUNT;\n    }\n\n    // solhint-enable func-name-mixedcase\n\n    /**\n     * @inheritdoc Upgradeable\n     */\n    function version() public pure override(IVersioned, Upgradeable) returns (uint16) {\n        return 1;\n    }\n\n    /**\n     * @inheritdoc IAutoCompoundingRewards\n     */\n    function program(Token pool) external view returns (ProgramData memory) {\n        return _programs[pool];\n    }\n\n    /**\n     * @inheritdoc IAutoCompoundingRewards\n     */\n    function programs() external view returns (ProgramData[] memory) {\n        uint256 numPrograms = _pools.length();\n\n        ProgramData[] memory list = new ProgramData[](numPrograms);\n        for (uint256 i = 0; i < numPrograms; i++) {\n            list[i] = _programs[Token(_pools.at(i))];\n        }\n\n        return list;\n    }\n\n    /**\n     * @inheritdoc IAutoCompoundingRewards\n     */\n    function pools() external view returns (address[] memory) {\n        return _pools.values();\n    }\n\n    /**\n     * @inheritdoc IAutoCompoundingRewards\n     */\n    function autoProcessRewardsCount() external view returns (uint256) {\n        return _autoProcessRewardsCount;\n    }\n\n    /**\n     * @dev sets the number of programs to auto-process the rewards for\n     *\n     * requirements:\n     *\n     * - the caller must be the admin of the contract\n     */\n    function setAutoProcessRewardsCount(uint256 newCount) external greaterThanZero(newCount) onlyAdmin {\n        uint256 prevCount = _autoProcessRewardsCount;\n        if (prevCount == newCount) {\n            return;\n        }\n\n        _autoProcessRewardsCount = newCount;\n\n        emit AutoProcessRewardsCountUpdated({ prevCount: prevCount, newCount: newCount });\n    }\n\n    /**\n     * @inheritdoc IAutoCompoundingRewards\n     */\n    function isProgramActive(Token pool) external view returns (bool) {\n        ProgramData memory p = _programs[pool];\n\n        if (!_doesProgramExist(p)) {\n            return false;\n        }\n\n        uint32 currTime = _time();\n\n        if (p.distributionType == EXP_DECAY_DISTRIBUTION) {\n            return p.startTime <= currTime;\n        }\n\n        return p.startTime <= currTime && currTime <= p.endTime;\n    }\n\n    /**\n     * @inheritdoc IAutoCompoundingRewards\n     */\n    function createFlatProgram(\n        Token pool,\n        uint256 totalRewards,\n        uint32 startTime,\n        uint32 endTime\n    ) external {\n        if (startTime >= endTime) {\n            revert InvalidParam();\n        }\n\n        _createProgram(pool, totalRewards, FLAT_DISTRIBUTION, startTime, endTime, 0);\n\n        emit FlatProgramCreated({ pool: pool, totalRewards: totalRewards, startTime: startTime, endTime: endTime });\n    }\n\n    /**\n     * @inheritdoc IAutoCompoundingRewards\n     */\n    function createExpDecayProgram(\n        Token pool,\n        uint256 totalRewards,\n        uint32 startTime,\n        uint32 halfLife\n    ) external {\n        if (halfLife == 0) {\n            revert InvalidParam();\n        }\n\n        _createProgram(pool, totalRewards, EXP_DECAY_DISTRIBUTION, startTime, 0, halfLife);\n\n        emit ExpDecayProgramCreated({\n            pool: pool,\n            totalRewards: totalRewards,\n            startTime: startTime,\n            halfLife: halfLife\n        });\n    }\n\n    /**\n     * @inheritdoc IAutoCompoundingRewards\n     */\n    function terminateProgram(Token pool) external onlyAdmin {\n        ProgramData memory p = _programs[pool];\n\n        if (!_doesProgramExist(p)) {\n            revert DoesNotExist();\n        }\n\n        delete _programs[pool];\n\n        assert(_pools.remove(address(pool)));\n\n        emit ProgramTerminated({ pool: pool, endTime: p.endTime, remainingRewards: p.remainingRewards });\n    }\n\n    /**\n     * @inheritdoc IAutoCompoundingRewards\n     */\n    function enableProgram(Token pool, bool status) external onlyAdmin {\n        ProgramData memory p = _programs[pool];\n\n        if (!_doesProgramExist(p)) {\n            revert DoesNotExist();\n        }\n\n        bool prevStatus = p.isEnabled;\n        if (prevStatus == status) {\n            return;\n        }\n\n        _programs[pool].isEnabled = status;\n\n        emit ProgramEnabled({ pool: pool, status: status, remainingRewards: p.remainingRewards });\n    }\n\n    /**\n     * @inheritdoc IAutoCompoundingRewards\n     */\n    function autoProcessRewards() external nonReentrant {\n        uint256 numOfPools = _pools.length();\n        uint256 index = _autoProcessRewardsIndex;\n        uint256 count = _autoProcessRewardsCount;\n        uint256 maxCount = Math.min(count * AUTO_PROCESS_MAX_PROGRAMS_FACTOR, numOfPools);\n\n        for (uint256 i = 0; i < maxCount; i++) {\n            bool completed = _processRewards(Token(_pools.at(index % numOfPools)), true);\n            index++;\n            if (completed) {\n                count--;\n                if (count == 0) {\n                    break;\n                }\n            }\n        }\n\n        _autoProcessRewardsIndex = index % numOfPools;\n    }\n\n    /**\n     * @inheritdoc IAutoCompoundingRewards\n     */\n    function processRewards(Token pool) external nonReentrant {\n        _processRewards(pool, false);\n    }\n\n    /**\n     * @dev processes the rewards of a given pool and returns true if the rewards processing was completed, and false\n     * if it was skipped\n     */\n    function _processRewards(Token pool, bool skipRecent) private returns (bool) {\n        ProgramData memory p = _programs[pool];\n\n        uint32 currTime = _time();\n\n        if (!p.isEnabled || currTime < p.startTime) {\n            return false;\n        }\n\n        if (skipRecent && currTime < p.prevDistributionTimestamp + AUTO_PROCESS_REWARDS_MIN_TIME_DELTA) {\n            return false;\n        }\n\n        uint256 tokenAmountToDistribute = _tokenAmountToDistribute(p, currTime);\n        if (tokenAmountToDistribute == 0) {\n            return true;\n        }\n\n        uint256 poolTokenAmountToBurn = _poolTokenAmountToBurn(pool, p, tokenAmountToDistribute);\n        if (poolTokenAmountToBurn == 0) {\n            return true;\n        }\n\n        IVault rewardsVault = _rewardsVault(pool);\n        _verifyFunds(poolTokenAmountToBurn, p.poolToken, rewardsVault);\n        rewardsVault.burn(Token(address(p.poolToken)), poolTokenAmountToBurn);\n\n        p.remainingRewards -= tokenAmountToDistribute;\n        p.prevDistributionTimestamp = currTime;\n\n        _programs[pool] = p;\n\n        emit RewardsDistributed({\n            pool: pool,\n            rewardsAmount: tokenAmountToDistribute,\n            poolTokenAmount: poolTokenAmountToBurn,\n            remainingRewards: p.remainingRewards\n        });\n\n        return true;\n    }\n\n    /**\n     * @dev creates a rewards program for a given pool\n     */\n    function _createProgram(\n        Token pool,\n        uint256 totalRewards,\n        uint8 distributionType,\n        uint32 startTime,\n        uint32 endTime,\n        uint32 halfLife\n    ) private validAddress(address(pool)) greaterThanZero(totalRewards) onlyAdmin nonReentrant {\n        if (_doesProgramExist(_programs[pool])) {\n            revert AlreadyExists();\n        }\n\n        IPoolToken poolToken;\n        if (pool.isEqual(_bnt)) {\n            poolToken = _bntPoolToken;\n        } else {\n            if (!_networkSettings.isTokenWhitelisted(pool)) {\n                revert NotWhitelisted();\n            }\n\n            poolToken = _network.collectionByPool(pool).poolToken(pool);\n        }\n\n        if (startTime < _time()) {\n            revert InvalidParam();\n        }\n\n        ProgramData memory p = ProgramData({\n            startTime: startTime,\n            endTime: endTime,\n            halfLife: halfLife,\n            prevDistributionTimestamp: 0,\n            poolToken: poolToken,\n            isEnabled: true,\n            distributionType: distributionType,\n            totalRewards: totalRewards,\n            remainingRewards: totalRewards\n        });\n\n        _verifyFunds(_poolTokenAmountToBurn(pool, p, totalRewards), poolToken, _rewardsVault(pool));\n\n        _programs[pool] = p;\n\n        assert(_pools.add(address(pool)));\n    }\n\n    /**\n     * @dev returns the amount of tokens to distribute\n     */\n    function _tokenAmountToDistribute(ProgramData memory p, uint32 currTime) private pure returns (uint256) {\n        uint32 prevTime = uint32(Math.max(p.prevDistributionTimestamp, p.startTime));\n\n        if (p.distributionType == FLAT_DISTRIBUTION) {\n            uint32 currTimeElapsed = uint32(Math.min(currTime, p.endTime)) - p.startTime;\n            uint32 prevTimeElapsed = uint32(Math.min(prevTime, p.endTime)) - p.startTime;\n            return\n                RewardsMath.calcFlatRewards(p.totalRewards, currTimeElapsed - prevTimeElapsed, p.endTime - p.startTime);\n        } else {\n            uint32 currTimeElapsed = currTime - p.startTime;\n            uint32 prevTimeElapsed = prevTime - p.startTime;\n            return\n                RewardsMath.calcExpDecayRewards(p.totalRewards, currTimeElapsed, p.halfLife) -\n                RewardsMath.calcExpDecayRewards(p.totalRewards, prevTimeElapsed, p.halfLife);\n        }\n    }\n\n    /**\n     * @dev returns the amount of pool tokens to burn\n     */\n    function _poolTokenAmountToBurn(\n        Token pool,\n        ProgramData memory p,\n        uint256 tokenAmountToDistribute\n    ) private view returns (uint256) {\n        if (pool.isEqual(_bnt)) {\n            return _bntPool.poolTokenAmountToBurn(tokenAmountToDistribute);\n        }\n\n        return\n            _network.collectionByPool(pool).poolTokenAmountToBurn(\n                pool,\n                tokenAmountToDistribute,\n                p.poolToken.balanceOf(address(_externalRewardsVault))\n            );\n    }\n\n    /**\n     * @dev returns whether or not a given program exists\n     */\n    function _doesProgramExist(ProgramData memory p) private pure returns (bool) {\n        return address(p.poolToken) != address(0);\n    }\n\n    /**\n     * @dev returns the rewards vault for a given pool\n     */\n    function _rewardsVault(Token pool) private view returns (IVault) {\n        return pool.isEqual(_bnt) ? IVault(_bntPool) : IVault(_externalRewardsVault);\n    }\n\n    /**\n     * @dev verifies that the rewards vault holds a sufficient amount of pool tokens\n     */\n    function _verifyFunds(\n        uint256 requiredAmount,\n        IPoolToken poolToken,\n        IVault rewardsVault\n    ) private view {\n        if (requiredAmount > poolToken.balanceOf(address(rewardsVault))) {\n            revert InsufficientFunds();\n        }\n    }\n}"
    },
    {
      "filename": "contracts/rewards/AutoCompoundingRewards.sol",
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity 0.8.13;\n\nimport { EnumerableSetUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\nimport { ReentrancyGuardUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport { IVersioned } from \"../utility/interfaces/IVersioned.sol\";\nimport { Upgradeable } from \"../utility/Upgradeable.sol\";\nimport { Utils, AccessDenied, DoesNotExist, AlreadyExists, InvalidParam } from \"../utility/Utils.sol\";\nimport { Time } from \"../utility/Time.sol\";\n\nimport { INetworkSettings, NotWhitelisted } from \"../network/interfaces/INetworkSettings.sol\";\nimport { IBancorNetwork } from \"../network/interfaces/IBancorNetwork.sol\";\n\nimport { IPoolToken } from \"../pools/interfaces/IPoolToken.sol\";\nimport { IBNTPool } from \"../pools/interfaces/IBNTPool.sol\";\n\nimport { Token } from \"../token/Token.sol\";\nimport { TokenLibrary } from \"../token/TokenLibrary.sol\";\n\nimport { IVault } from \"../vaults/interfaces/IVault.sol\";\nimport { IExternalRewardsVault } from \"../vaults/interfaces/IExternalRewardsVault.sol\";\n\n// prettier-ignore\nimport {\n    IAutoCompoundingRewards,\n    ProgramData,\n    FLAT_DISTRIBUTION,\n    EXP_DECAY_DISTRIBUTION\n} from \"./interfaces/IAutoCompoundingRewards.sol\";\n\nimport { RewardsMath } from \"./RewardsMath.sol\";\n\n/**\n * @dev Auto-compounding Rewards contract\n */\ncontract AutoCompoundingRewards is IAutoCompoundingRewards, ReentrancyGuardUpgradeable, Utils, Time, Upgradeable {\n    using TokenLibrary for Token;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    error InsufficientFunds();\n\n    // the default number of programs to auto-process the rewards for\n    uint8 private constant DEFAULT_AUTO_PROCESS_REWARDS_COUNT = 3;\n\n    // the minimum time elapsed before the rewards of a program can be auto-processed\n    uint16 private constant AUTO_PROCESS_REWARDS_MIN_TIME_DELTA = 1 hours;\n\n    // the factor used to calculate the maximum number of programs to attempt to auto-process in a single attempt\n    uint8 private constant AUTO_PROCESS_MAX_PROGRAMS_FACTOR = 2;\n\n    // the network contract\n    IBancorNetwork private immutable _network;\n\n    // the network settings contract\n    INetworkSettings private immutable _networkSettings;\n\n    // the BNT contract\n    IERC20 private immutable _bnt;\n\n    // the BNT pool contract\n    IBNTPool private immutable _bntPool;\n\n    // the BNT pool token contract\n    IPoolToken private immutable _bntPoolToken;\n\n    // the address of the external rewards vault\n    IExternalRewardsVault private immutable _externalRewardsVault;\n\n    // a mapping between pools and programs\n    mapping(Token => ProgramData) private _programs;\n\n    // a set of all pools that have a rewards program associated with them\n    EnumerableSetUpgradeable.AddressSet private _pools;\n\n    // the number of programs to auto-process the rewards for\n    uint256 private _autoProcessRewardsCount;\n\n    // the index of the next program to auto-process the rewards for\n    uint256 internal _autoProcessRewardsIndex;\n\n    // upgrade forward-compatibility storage gap\n    uint256[MAX_GAP - 5] private __gap;\n\n    /**\n     * @dev triggered when a flat program is created\n     */\n    event FlatProgramCreated(Token indexed pool, uint256 totalRewards, uint32 startTime, uint32 endTime);\n\n    /**\n     * @dev triggered when an exponential-decay program is created\n     */\n    event ExpDecayProgramCreated(Token indexed pool, uint256 totalRewards, uint32 startTime, uint32 halfLife);\n\n    /**\n     * @dev triggered when a program is terminated prematurely\n     */\n    event ProgramTerminated(Token indexed pool, uint32 endTime, uint256 remainingRewards);\n\n    /**\n     * @dev triggered when a program is enabled/disabled\n     */\n    event ProgramEnabled(Token indexed pool, bool status, uint256 remainingRewards);\n\n    /**\n     * @dev triggered when the number of programs to auto-process the rewards for is updated\n     */\n    event AutoProcessRewardsCountUpdated(uint256 prevCount, uint256 newCount);\n\n    /**\n     * @dev triggered when rewards are distributed\n     */\n    event RewardsDistributed(\n        Token indexed pool,\n        uint256 rewardsAmount,\n        uint256 poolTokenAmount,\n        uint256 remainingRewards\n    );\n\n    /**\n     * @dev a \"virtual\" constructor that is only used to set immutable state variables\n     */\n    constructor(\n        IBancorNetwork initNetwork,\n        INetworkSettings initNetworkSettings,\n        IERC20 initBNT,\n        IBNTPool initBNTPool,\n        IExternalRewardsVault initExternalRewardsVault\n    )\n        validAddress(address(initNetwork))\n        validAddress(address(initNetworkSettings))\n        validAddress(address(initBNT))\n        validAddress(address(initBNTPool))\n        validAddress(address(initExternalRewardsVault))\n    {\n        _network = initNetwork;\n        _networkSettings = initNetworkSettings;\n        _bnt = initBNT;\n        _bntPool = initBNTPool;\n        _bntPoolToken = initBNTPool.poolToken();\n        _externalRewardsVault = initExternalRewardsVault;\n    }\n\n    /**\n     * @dev fully initializes the contract and its parents\n     */\n    function initialize() external initializer {\n        __AutoCompoundingRewards_init();\n    }\n\n    // solhint-disable func-name-mixedcase\n\n    /**\n     * @dev initializes the contract and its parents\n     */\n    function __AutoCompoundingRewards_init() internal onlyInitializing {\n        __ReentrancyGuard_init();\n        __Upgradeable_init();\n\n        __AutoCompoundingRewards_init_unchained();\n    }\n\n    /**\n     * @dev performs contract-specific initialization\n     */\n    function __AutoCompoundingRewards_init_unchained() internal onlyInitializing {\n        _autoProcessRewardsCount = DEFAULT_AUTO_PROCESS_REWARDS_COUNT;\n    }\n\n    // solhint-enable func-name-mixedcase\n\n    /**\n     * @inheritdoc Upgradeable\n     */\n    function version() public pure override(IVersioned, Upgradeable) returns (uint16) {\n        return 1;\n    }\n\n    /**\n     * @inheritdoc IAutoCompoundingRewards\n     */\n    function program(Token pool) external view returns (ProgramData memory) {\n        return _programs[pool];\n    }\n\n    /**\n     * @inheritdoc IAutoCompoundingRewards\n     */\n    function programs() external view returns (ProgramData[] memory) {\n        uint256 numPrograms = _pools.length();\n\n        ProgramData[] memory list = new ProgramData[](numPrograms);\n        for (uint256 i = 0; i < numPrograms; i++) {\n            list[i] = _programs[Token(_pools.at(i))];\n        }\n\n        return list;\n    }\n\n    /**\n     * @inheritdoc IAutoCompoundingRewards\n     */\n    function pools() external view returns (address[] memory) {\n        return _pools.values();\n    }\n\n    /**\n     * @inheritdoc IAutoCompoundingRewards\n     */\n    function autoProcessRewardsCount() external view returns (uint256) {\n        return _autoProcessRewardsCount;\n    }\n\n    /**\n     * @dev sets the number of programs to auto-process the rewards for\n     *\n     * requirements:\n     *\n     * - the caller must be the admin of the contract\n     */\n    function setAutoProcessRewardsCount(uint256 newCount) external greaterThanZero(newCount) onlyAdmin {\n        uint256 prevCount = _autoProcessRewardsCount;\n        if (prevCount == newCount) {\n            return;\n        }\n\n        _autoProcessRewardsCount = newCount;\n\n        emit AutoProcessRewardsCountUpdated({ prevCount: prevCount, newCount: newCount });\n    }\n\n    /**\n     * @inheritdoc IAutoCompoundingRewards\n     */\n    function isProgramActive(Token pool) external view returns (bool) {\n        ProgramData memory p = _programs[pool];\n\n        if (!_doesProgramExist(p)) {\n            return false;\n        }\n\n        uint32 currTime = _time();\n\n        if (p.distributionType == EXP_DECAY_DISTRIBUTION) {\n            return p.startTime <= currTime;\n        }\n\n        return p.startTime <= currTime && currTime <= p.endTime;\n    }\n\n    /**\n     * @inheritdoc IAutoCompoundingRewards\n     */\n    function createFlatProgram(\n        Token pool,\n        uint256 totalRewards,\n        uint32 startTime,\n        uint32 endTime\n    ) external {\n        if (startTime >= endTime) {\n            revert InvalidParam();\n        }\n\n        _createProgram(pool, totalRewards, FLAT_DISTRIBUTION, startTime, endTime, 0);\n\n        emit FlatProgramCreated({ pool: pool, totalRewards: totalRewards, startTime: startTime, endTime: endTime });\n    }\n\n    /**\n     * @inheritdoc IAutoCompoundingRewards\n     */\n    function createExpDecayProgram(\n        Token pool,\n        uint256 totalRewards,\n        uint32 startTime,\n        uint32 halfLife\n    ) external {\n        if (halfLife == 0) {\n            revert InvalidParam();\n        }\n\n        _createProgram(pool, totalRewards, EXP_DECAY_DISTRIBUTION, startTime, 0, halfLife);\n\n        emit ExpDecayProgramCreated({\n            pool: pool,\n            totalRewards: totalRewards,\n            startTime: startTime,\n            halfLife: halfLife\n        });\n    }\n\n    /**\n     * @inheritdoc IAutoCompoundingRewards\n     */\n    function terminateProgram(Token pool) external onlyAdmin {\n        ProgramData memory p = _programs[pool];\n\n        if (!_doesProgramExist(p)) {\n            revert DoesNotExist();\n        }\n\n        delete _programs[pool];\n\n        assert(_pools.remove(address(pool)));\n\n        emit ProgramTerminated({ pool: pool, endTime: p.endTime, remainingRewards: p.remainingRewards });\n    }\n\n    /**\n     * @inheritdoc IAutoCompoundingRewards\n     */\n    function enableProgram(Token pool, bool status) external onlyAdmin {\n        ProgramData memory p = _programs[pool];\n\n        if (!_doesProgramExist(p)) {\n            revert DoesNotExist();\n        }\n\n        bool prevStatus = p.isEnabled;\n        if (prevStatus == status) {\n            return;\n        }\n\n        _programs[pool].isEnabled = status;\n\n        emit ProgramEnabled({ pool: pool, status: status, remainingRewards: p.remainingRewards });\n    }\n\n    /**\n     * @inheritdoc IAutoCompoundingRewards\n     */\n    function autoProcessRewards() external nonReentrant {\n        uint256 numOfPools = _pools.length();\n        uint256 index = _autoProcessRewardsIndex;\n        uint256 count = _autoProcessRewardsCount;\n        uint256 maxCount = Math.min(count * AUTO_PROCESS_MAX_PROGRAMS_FACTOR, numOfPools);\n\n        for (uint256 i = 0; i < maxCount; i++) {\n            bool completed = _processRewards(Token(_pools.at(index % numOfPools)), true);\n            index++;\n            if (completed) {\n                count--;\n                if (count == 0) {\n                    break;\n                }\n            }\n        }\n\n        _autoProcessRewardsIndex = index % numOfPools;\n    }\n\n    /**\n     * @inheritdoc IAutoCompoundingRewards\n     */\n    function processRewards(Token pool) external nonReentrant {\n        _processRewards(pool, false);\n    }\n\n    /**\n     * @dev processes the rewards of a given pool and returns true if the rewards processing was completed, and false\n     * if it was skipped\n     */\n    function _processRewards(Token pool, bool skipRecent) private returns (bool) {\n        ProgramData memory p = _programs[pool];\n\n        uint32 currTime = _time();\n\n        if (!p.isEnabled || currTime < p.startTime) {\n            return false;\n        }\n\n        if (skipRecent && currTime < p.prevDistributionTimestamp + AUTO_PROCESS_REWARDS_MIN_TIME_DELTA) {\n            return false;\n        }\n\n        uint256 tokenAmountToDistribute = _tokenAmountToDistribute(p, currTime);\n        if (tokenAmountToDistribute == 0) {\n            return true;\n        }\n\n        uint256 poolTokenAmountToBurn = _poolTokenAmountToBurn(pool, p, tokenAmountToDistribute);\n        if (poolTokenAmountToBurn == 0) {\n            return true;\n        }\n\n        IVault rewardsVault = _rewardsVault(pool);\n        _verifyFunds(poolTokenAmountToBurn, p.poolToken, rewardsVault);\n        rewardsVault.burn(Token(address(p.poolToken)), poolTokenAmountToBurn);\n\n        p.remainingRewards -= tokenAmountToDistribute;\n        p.prevDistributionTimestamp = currTime;\n\n        _programs[pool] = p;\n\n        emit RewardsDistributed({\n            pool: pool,\n            rewardsAmount: tokenAmountToDistribute,\n            poolTokenAmount: poolTokenAmountToBurn,\n            remainingRewards: p.remainingRewards\n        });\n\n        return true;\n    }\n\n    /**\n     * @dev creates a rewards program for a given pool\n     */\n    function _createProgram(\n        Token pool,\n        uint256 totalRewards,\n        uint8 distributionType,\n        uint32 startTime,\n        uint32 endTime,\n        uint32 halfLife\n    ) private validAddress(address(pool)) greaterThanZero(totalRewards) onlyAdmin nonReentrant {\n        if (_doesProgramExist(_programs[pool])) {\n            revert AlreadyExists();\n        }\n\n        IPoolToken poolToken;\n        if (pool.isEqual(_bnt)) {\n            poolToken = _bntPoolToken;\n        } else {\n            if (!_networkSettings.isTokenWhitelisted(pool)) {\n                revert NotWhitelisted();\n            }\n\n            poolToken = _network.collectionByPool(pool).poolToken(pool);\n        }\n\n        if (startTime < _time()) {\n            revert InvalidParam();\n        }\n\n        ProgramData memory p = ProgramData({\n            startTime: startTime,\n            endTime: endTime,\n            halfLife: halfLife,\n            prevDistributionTimestamp: 0,\n            poolToken: poolToken,\n            isEnabled: true,\n            distributionType: distributionType,\n            totalRewards: totalRewards,\n            remainingRewards: totalRewards\n        });\n\n        _verifyFunds(_poolTokenAmountToBurn(pool, p, totalRewards), poolToken, _rewardsVault(pool));\n\n        _programs[pool] = p;\n\n        assert(_pools.add(address(pool)));\n    }\n\n    /**\n     * @dev returns the amount of tokens to distribute\n     */\n    function _tokenAmountToDistribute(ProgramData memory p, uint32 currTime) private pure returns (uint256) {\n        uint32 prevTime = uint32(Math.max(p.prevDistributionTimestamp, p.startTime));\n\n        if (p.distributionType == FLAT_DISTRIBUTION) {\n            uint32 currTimeElapsed = uint32(Math.min(currTime, p.endTime)) - p.startTime;\n            uint32 prevTimeElapsed = uint32(Math.min(prevTime, p.endTime)) - p.startTime;\n            return\n                RewardsMath.calcFlatRewards(p.totalRewards, currTimeElapsed - prevTimeElapsed, p.endTime - p.startTime);\n        } else {\n            uint32 currTimeElapsed = currTime - p.startTime;\n            uint32 prevTimeElapsed = prevTime - p.startTime;\n            return\n                RewardsMath.calcExpDecayRewards(p.totalRewards, currTimeElapsed, p.halfLife) -\n                RewardsMath.calcExpDecayRewards(p.totalRewards, prevTimeElapsed, p.halfLife);\n        }\n    }\n\n    /**\n     * @dev returns the amount of pool tokens to burn\n     */\n    function _poolTokenAmountToBurn(\n        Token pool,\n        ProgramData memory p,\n        uint256 tokenAmountToDistribute\n    ) private view returns (uint256) {\n        if (pool.isEqual(_bnt)) {\n            return _bntPool.poolTokenAmountToBurn(tokenAmountToDistribute);\n        }\n\n        return\n            _network.collectionByPool(pool).poolTokenAmountToBurn(\n                pool,\n                tokenAmountToDistribute,\n                p.poolToken.balanceOf(address(_externalRewardsVault))\n            );\n    }\n\n    /**\n     * @dev returns whether or not a given program exists\n     */\n    function _doesProgramExist(ProgramData memory p) private pure returns (bool) {\n        return address(p.poolToken) != address(0);\n    }\n\n    /**\n     * @dev returns the rewards vault for a given pool\n     */\n    function _rewardsVault(Token pool) private view returns (IVault) {\n        return pool.isEqual(_bnt) ? IVault(_bntPool) : IVault(_externalRewardsVault);\n    }\n\n    /**\n     * @dev verifies that the rewards vault holds a sufficient amount of pool tokens\n     */\n    function _verifyFunds(\n        uint256 requiredAmount,\n        IPoolToken poolToken,\n        IVault rewardsVault\n    ) private view {"
    }
  ]
}