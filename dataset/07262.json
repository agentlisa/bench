{
  "Title": "[H-16] When Public Vault A buys out Public Vault B's lien tokens, it does not increase Public Vault A's liensOpenForEpoch, which would result in the lien tokens not being repaid",
  "Content": "\nVault A can call buyoutLien to buy out Vault B's lien tokens, which calls LienToken.buyoutLien\n\n```solidity\n  function buyoutLien(\n    ILienToken.Stack[] calldata stack,\n    uint8 position,\n    IAstariaRouter.Commitment calldata incomingTerms\n  )\n    external\n    whenNotPaused\n    returns (ILienToken.Stack[] memory, ILienToken.Stack memory)\n  {\n...\n    return\n      lienToken.buyoutLien(\n        ILienToken.LienActionBuyout({\n          position: position,\n          encumber: ILienToken.LienActionEncumber({\n            amount: owed,\n            receiver: recipient(),\n            lien: ROUTER().validateCommitment({\n              commitment: incomingTerms,\n              timeToSecondEpochEnd: _timeToSecondEndIfPublic()\n            }),\n            stack: stack\n```\n\nIn LienToken.buyoutLien, it will burn Vault B's lien token and mint a new lien token for Vault A\n\n```solidity\n  function _replaceStackAtPositionWithNewLien(\n    LienStorage storage s,\n    ILienToken.Stack[] calldata stack,\n    uint256 position,\n    Stack memory newLien,\n    uint256 oldLienId\n  ) internal returns (ILienToken.Stack[] memory newStack) {\n    newStack = stack;\n    newStack[position] = newLien;\n    _burn(oldLienId);                        // @ audit: burn Vault B's lien token\n    delete s.lienMeta[oldLienId];\n  }\n...\n    newLienId = uint256(keccak256(abi.encode(params.lien)));\n    Point memory point = Point({\n      lienId: newLienId,\n      amount: params.amount.safeCastTo88(),\n      last: block.timestamp.safeCastTo40(),\n      end: (block.timestamp + params.lien.details.duration).safeCastTo40()\n    });\n    _mint(params.receiver, newLienId); // @ audit: mint a new lien token for Vault A\n    return (newLienId, Stack({lien: params.lien, point: point}));\n  }\n```\n\nAnd, when Vault B is a public vault, the handleBuyoutLien function of Vault B will be called to decrease liensOpenForEpoch.<br>\nHowever, when Vault A is a public vault, it does not increase the liensOpenForEpoch of Vault A.\n\n```solidity\n    if (_isPublicVault(s, payee)) {\n      IPublicVault(payee).handleBuyoutLien(\n        IPublicVault.BuyoutLienParams({\n          lienSlope: calculateSlope(params.encumber.stack[params.position]),\n          lienEnd: params.encumber.stack[params.position].point.end,\n          increaseYIntercept: buyout -\n            params.encumber.stack[params.position].point.amount\n        })\n      );\n    }\n...\n  function handleBuyoutLien(BuyoutLienParams calldata params)\n    public\n    onlyLienToken\n  {\n    VaultData storage s = _loadStorageSlot();\n\n    unchecked {\n      uint48 newSlope = s.slope - params.lienSlope.safeCastTo48();\n      _setSlope(s, newSlope);\n      s.yIntercept += params.increaseYIntercept.safeCastTo88();\n      s.last = block.timestamp.safeCastTo40();\n    }\n\n    _decreaseEpochLienCount(s, getLienEpoch(params.lienEnd.safeCastTo64()));  // @audit: decrease liensOpenForEpoch \n    emit YInterceptChanged(s.yIntercept);\n  }\n```\n\nSince the liensOpenForEpoch of the public vault decreases when the lien token is repaid, and since the liensOpenForEpoch of public vault A is not increased, then when that lien token is repaid, \\_payment will fail due to overflow when decreasing the liensOpenForEpoch.\n\n```solidity\n    } else {\n      amount = stack.point.amount;\n      if (isPublicVault) {\n        // since the openLiens count is only positive when there are liens that haven't been paid off\n        // that should be liquidated, this lien should not be counted anymore\n        IPublicVault(lienOwner).decreaseEpochLienCount(  //  @audit: overflow here\n          IPublicVault(lienOwner).getLienEpoch(end)\n        );\n      }\n```\n\nConsider the following case.\n- Public Vault B holds a lien token and B.liensOpenForEpoch == 1\n- Public Vault A buys out B's lien token for refinancing, B.liensOpenForEpoch == 0, A.liensOpenForEpoch == 0\n- borrower wants to repay the loan, in the \\_payment function, the decreaseEpochLienCount function of Vault A will be called, ` A.liensOpenForEpoch--  `will trigger an overflow, resulting in borrower not being able to repay the loan, and borrower's collateral will be auctioned off, but in the call to updateVaultAfterLiquidation function will also fail in decreaseEpochLienCount due to the overflow\n\n```solidity\n  function updateVaultAfterLiquidation(\n    uint256 maxAuctionWindow,\n    AfterLiquidationParams calldata params\n  ) public onlyLienToken returns (address withdrawProxyIfNearBoundary) {\n    VaultData storage s = _loadStorageSlot();\n\n    _accrue(s);\n    unchecked {\n      _setSlope(s, s.slope - params.lienSlope.safeCastTo48());\n    }\n\n    if (s.currentEpoch != 0) {\n      transferWithdrawReserve();\n    }\n    uint64 lienEpoch = getLienEpoch(params.lienEnd);\n    _decreaseEpochLienCount(s, lienEpoch); //  @audit: overflow here\n```\n\nAs a result, the borrower cannot repay the loan and the borrower's collateral cannot be auctioned off, thus causing the depositor of the public vault to suffer a loss\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/VaultImplementation.sol#L313-L351><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/LienToken.sol#L835-L843><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/PublicVault.sol#L640-L655>\n\n### Recommended Mitigation Steps\n\nIn LienToken.buyoutLien, when the caller is a public vault, increase the decreaseEpochLienCount of the public vault.\n\n**[SantiagoGregory (Astaria) confirmed](https://github.com/code-423n4/2023-01-astaria-findings/issues/222)**\n\n\n\n***\n\n",
  "Impact": "HIGH",
  "Source": "https://code4rena.com/reports/2023-01-astaria",
  "Code": [
    {
      "filename": "src/VaultImplementation.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/**                                                     \n*  █████╗ ███████╗████████╗ █████╗ ██████╗ ██╗ █████╗ \n* ██╔══██╗██╔════╝╚══██╔══╝██╔══██╗██╔══██╗██║██╔══██╗\n* ███████║███████╗   ██║   ███████║██████╔╝██║███████║\n* ██╔══██║╚════██║   ██║   ██╔══██║██╔══██╗██║██╔══██║\n* ██║  ██║███████║   ██║   ██║  ██║██║  ██║██║██║  ██║\n* ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═╝\n*\n* Astaria Labs, Inc\n*/\n\npragma solidity =0.8.17;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ERC721, ERC721TokenReceiver} from \"solmate/tokens/ERC721.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {CollateralLookup} from \"core/libraries/CollateralLookup.sol\";\n\nimport {IAstariaRouter} from \"core/interfaces/IAstariaRouter.sol\";\nimport {LienToken} from \"core/LienToken.sol\";\nimport {ILienToken} from \"core/interfaces/ILienToken.sol\";\nimport {IPublicVault} from \"core/interfaces/IPublicVault.sol\";\nimport {AstariaVaultBase} from \"core/AstariaVaultBase.sol\";\nimport {IVaultImplementation} from \"core/interfaces/IVaultImplementation.sol\";\nimport {SafeCastLib} from \"gpl/utils/SafeCastLib.sol\";\n\n/**\n * @title VaultImplementation\n * @notice A base implementation for the minimal features of an Astaria Vault.\n */\nabstract contract VaultImplementation is\n  AstariaVaultBase,\n  ERC721TokenReceiver,\n  IVaultImplementation\n{\n  using SafeTransferLib for ERC20;\n  using SafeCastLib for uint256;\n  using CollateralLookup for address;\n  using FixedPointMathLib for uint256;\n\n  bytes32 public constant STRATEGY_TYPEHASH =\n    keccak256(\"StrategyDetails(uint256 nonce,uint256 deadline,bytes32 root)\");\n\n  bytes32 constant EIP_DOMAIN =\n    keccak256(\n      \"EIP712Domain(string version,uint256 chainId,address verifyingContract)\"\n    );\n  bytes32 constant VERSION = keccak256(\"0\");\n\n  function name() external view virtual override returns (string memory);\n\n  function symbol() external view virtual override returns (string memory);\n\n  uint256 private constant VI_SLOT =\n    uint256(keccak256(\"xyz.astaria.VaultImplementation.storage.location\")) - 1;\n\n  function getStrategistNonce() external view returns (uint256) {\n    return _loadVISlot().strategistNonce;\n  }\n\n  function incrementNonce() external {\n    VIData storage s = _loadVISlot();\n    if (msg.sender != owner() && msg.sender != s.delegate) {\n      revert InvalidRequest(InvalidRequestReason.NO_AUTHORITY);\n    }\n    s.strategistNonce++;\n    emit NonceUpdated(s.strategistNonce);\n  }\n\n  /**\n   * @notice modify the deposit cap for the vault\n   * @param newCap The deposit cap.\n   */\n  function modifyDepositCap(uint256 newCap) external {\n    require(msg.sender == owner()); //owner is \"strategist\"\n    _loadVISlot().depositCap = newCap.safeCastTo88();\n  }\n\n  function _loadVISlot() internal pure returns (VIData storage s) {\n    uint256 slot = VI_SLOT;\n\n    assembly {\n      s.slot := slot\n    }\n  }\n\n  /**\n   * @notice modify the allowlist for the vault\n   * @param depositor the depositor to modify\n   * @param enabled the status of the depositor\n   */\n  function modifyAllowList(address depositor, bool enabled) external virtual {\n    require(msg.sender == owner()); //owner is \"strategist\"\n    _loadVISlot().allowList[depositor] = enabled;\n    emit AllowListUpdated(depositor, enabled);\n  }\n\n  /**\n   * @notice disable the allowList for the vault\n   */\n  function disableAllowList() external virtual {\n    require(msg.sender == owner()); //owner is \"strategist\"\n    _loadVISlot().allowListEnabled = false;\n    emit AllowListEnabled(false);\n  }\n\n  /**\n   * @notice enable the allowList for the vault\n   */\n  function enableAllowList() external virtual {\n    require(msg.sender == owner()); //owner is \"strategist\"\n    _loadVISlot().allowListEnabled = true;\n    emit AllowListEnabled(true);\n  }\n\n  /**\n   * @notice receive hook for ERC721 tokens, nothing special done\n   */\n  function onERC721Received(\n    address, // operator_\n    address, // from_\n    uint256, // tokenId_\n    bytes calldata // data_\n  ) external pure override returns (bytes4) {\n    return ERC721TokenReceiver.onERC721Received.selector;\n  }\n\n  modifier whenNotPaused() {\n    if (ROUTER().paused()) {\n      revert InvalidRequest(InvalidRequestReason.PAUSED);\n    }\n\n    if (_loadVISlot().isShutdown) {\n      revert InvalidRequest(InvalidRequestReason.SHUTDOWN);\n    }\n    _;\n  }\n\n  function getShutdown() external view returns (bool) {\n    return _loadVISlot().isShutdown;\n  }\n\n  function shutdown() external {\n    require(msg.sender == owner()); //owner is \"strategist\"\n    _loadVISlot().isShutdown = true;\n    emit VaultShutdown();\n  }\n\n  function domainSeparator() public view virtual returns (bytes32) {\n    return\n      keccak256(\n        abi.encode(\n          EIP_DOMAIN,\n          VERSION, //version\n          block.chainid,\n          address(this)\n        )\n      );\n  }\n\n  /*\n   * @notice encodes the data for a 712 signature\n   * @param tokenContract The address of the token contract\n   * @param tokenId The id of the token\n   * @param amount The amount of the token\n   */\n  function encodeStrategyData(\n    IAstariaRouter.StrategyDetailsParam calldata strategy,\n    bytes32 root\n  ) external view returns (bytes memory) {\n    VIData storage s = _loadVISlot();\n    return _encodeStrategyData(s, strategy, root);\n  }\n\n  function _encodeStrategyData(\n    VIData storage s,\n    IAstariaRouter.StrategyDetailsParam calldata strategy,\n    bytes32 root\n  ) internal view returns (bytes memory) {\n    bytes32 hash = keccak256(\n      abi.encode(STRATEGY_TYPEHASH, s.strategistNonce, strategy.deadline, root)\n    );\n    return\n      abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), hash);\n  }\n\n  function init(InitParams calldata params) external virtual {\n    require(msg.sender == address(ROUTER()));\n    VIData storage s = _loadVISlot();\n\n    if (params.delegate != address(0)) {\n      s.delegate = params.delegate;\n    }\n    s.depositCap = params.depositCap.safeCastTo88();\n    if (params.allowListEnabled) {\n      s.allowListEnabled = true;\n      uint256 i;\n      for (; i < params.allowList.length; ) {\n        s.allowList[params.allowList[i]] = true;\n        unchecked {\n          ++i;\n        }\n      }\n    }\n  }\n\n  function setDelegate(address delegate_) external {\n    require(msg.sender == owner()); //owner is \"strategist\"\n    VIData storage s = _loadVISlot();\n    s.delegate = delegate_;\n    emit DelegateUpdated(delegate_);\n    emit AllowListUpdated(delegate_, true);\n  }\n\n  /**\n   * @dev Validates the terms for a requested loan.\n   * Who is requesting the borrow, is it a smart contract? or is it a user?\n   * if a smart contract, then ensure that the contract is approved to borrow and is also receiving the funds.\n   * if a user, then ensure that the user is approved to borrow and is also receiving the funds.\n   * The terms are hashed and signed by the borrower, and the signature validated against the strategist's address\n   * lien details are decoded from the obligation data and validated the collateral\n   *\n   * @param params The Commitment information containing the loan parameters and the merkle proof for the strategy supporting the requested loan.\n   * @param receiver The address of the prospective borrower.\n   */\n  function _validateCommitment(\n    IAstariaRouter.Commitment calldata params,\n    address receiver\n  ) internal view {\n    uint256 collateralId = params.tokenContract.computeId(params.tokenId);\n    ERC721 CT = ERC721(address(COLLATERAL_TOKEN()));\n    address holder = CT.ownerOf(collateralId);\n    address operator = CT.getApproved(collateralId);\n    if (\n      msg.sender != holder &&\n      receiver != holder &&\n      receiver != operator &&\n      !CT.isApprovedForAll(holder, msg.sender)\n    ) {\n      revert InvalidRequest(InvalidRequestReason.NO_AUTHORITY);\n    }\n    VIData storage s = _loadVISlot();\n    address recovered = ecrecover(\n      keccak256(\n        _encodeStrategyData(\n          s,\n          params.lienRequest.strategy,\n          params.lienRequest.merkle.root\n        )\n      ),\n      params.lienRequest.v,\n      params.lienRequest.r,\n      params.lienRequest.s\n    );\n    if (\n      (recovered != owner() && recovered != s.delegate) ||\n      recovered == address(0)\n    ) {\n      revert IVaultImplementation.InvalidRequest(\n        InvalidRequestReason.INVALID_SIGNATURE\n      );\n    }\n  }\n\n  function _afterCommitToLien(\n    uint40 end,\n    uint256 lienId,\n    uint256 slope\n  ) internal virtual {}\n\n  function _beforeCommitToLien(IAstariaRouter.Commitment calldata)\n    internal\n    virtual\n  {}\n\n  /**\n   * @notice Pipeline for lifecycle of new loan origination.\n   * Origination consists of a few phases: pre-commitment validation, lien token issuance, strategist reward, and after commitment actions\n   * Starts by depositing collateral and take optimized-out a lien against it. Next, verifies the merkle proof for a loan commitment. Vault owners are then rewarded fees for successful loan origination.\n   * @param params Commitment data for the incoming lien request\n   * @param receiver The borrower receiving the loan.\n   * @return lienId The id of the newly minted lien token.\n   */\n  function commitToLien(\n    IAstariaRouter.Commitment calldata params,\n    address receiver\n  )\n    external\n    whenNotPaused\n    returns (uint256 lienId, ILienToken.Stack[] memory stack, uint256 payout)\n  {\n    _beforeCommitToLien(params);\n    uint256 slopeAddition;\n    (lienId, stack, slopeAddition, payout) = _requestLienAndIssuePayout(\n      params,\n      receiver\n    );\n    _afterCommitToLien(\n      stack[stack.length - 1].point.end,\n      lienId,\n      slopeAddition\n    );\n  }\n\n  /**\n   * @notice Buy optimized-out a lien to replace it with new terms.\n   * @param position The position of the specified lien.\n   * @param incomingTerms The loan terms of the new lien.\n   */\n  function buyoutLien(\n    ILienToken.Stack[] calldata stack,\n    uint8 position,\n    IAstariaRouter.Commitment calldata incomingTerms\n  )\n    external\n    whenNotPaused\n    returns (ILienToken.Stack[] memory, ILienToken.Stack memory)\n  {\n    LienToken lienToken = LienToken(address(ROUTER().LIEN_TOKEN()));\n\n    (uint256 owed, uint256 buyout) = lienToken.getBuyout(stack[position]);\n\n    if (buyout > ERC20(asset()).balanceOf(address(this))) {\n      revert IVaultImplementation.InvalidRequest(\n        InvalidRequestReason.INSUFFICIENT_FUNDS\n      );\n    }\n\n    _validateCommitment(incomingTerms, recipient());\n\n    ERC20(asset()).safeApprove(address(ROUTER().TRANSFER_PROXY()), buyout);\n\n    return\n      lienToken.buyoutLien(\n        ILienToken.LienActionBuyout({\n          position: position,\n          encumber: ILienToken.LienActionEncumber({\n            amount: owed,\n            receiver: recipient(),\n            lien: ROUTER().validateCommitment({\n              commitment: incomingTerms,\n              timeToSecondEpochEnd: _timeToSecondEndIfPublic()\n            }),\n            stack: stack\n          })\n        })\n      );\n  }\n\n  function _timeToSecondEndIfPublic()\n    internal\n    view\n    virtual\n    returns (uint256 timeToSecondEpochEnd)\n  {\n    return 0;\n  }\n\n  /**\n   * @notice Retrieves the recipient of loan repayments. For PublicVaults (VAULT_TYPE 2), this is always the vault address. For PrivateVaults, retrieves the owner() of the vault.\n   * @return The address of the recipient.\n   */\n  function recipient() public view returns (address) {\n    if (IMPL_TYPE() == uint8(IAstariaRouter.ImplementationType.PublicVault)) {\n      return address(this);\n    } else {\n      return owner();\n    }\n  }\n\n  /**\n   * @dev Generates a Lien for a valid loan commitment proof and sends the loan amount to the borrower.\n   * @param c The Commitment information containing the loan parameters and the merkle proof for the strategy supporting the requested loan.\n   * @param receiver The borrower requesting the loan.\n   */\n  function _requestLienAndIssuePayout(\n    IAstariaRouter.Commitment calldata c,\n    address receiver\n  )\n    internal\n    returns (\n      uint256 newLienId,\n      ILienToken.Stack[] memory stack,\n      uint256 slope,\n      uint256 payout\n    )\n  {\n    _validateCommitment(c, receiver);\n    (newLienId, stack, slope) = ROUTER().requestLienPosition(c, recipient());\n    payout = _handleProtocolFee(c.lienRequest.amount);\n    ERC20(asset()).safeTransfer(receiver, payout);\n  }\n\n  function _handleProtocolFee(uint256 amount) internal returns (uint256) {\n    address feeTo = ROUTER().feeTo();\n    bool feeOn = feeTo != address(0);\n    if (feeOn) {\n      uint256 fee = ROUTER().getProtocolFee(amount);\n\n      unchecked {\n        amount -= fee;\n      }\n      ERC20(asset()).safeTransfer(feeTo, fee);\n    }\n    return amount;\n  }\n}"
    },
    {
      "filename": "src/LienToken.sol",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\n/**                                                     \n*  █████╗ ███████╗████████╗ █████╗ ██████╗ ██╗ █████╗ \n* ██╔══██╗██╔════╝╚══██╔══╝██╔══██╗██╔══██╗██║██╔══██╗\n* ███████║███████╗   ██║   ███████║██████╔╝██║███████║\n* ██╔══██║╚════██║   ██║   ██╔══██║██╔══██╗██║██╔══██║\n* ██║  ██║███████║   ██║   ██║  ██║██║  ██║██║██║  ██║\n* ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═╝\n*\n* Astaria Labs, Inc\n*/\n\npragma solidity =0.8.17;\n\npragma experimental ABIEncoderV2;\n\nimport {Auth, Authority} from \"solmate/auth/Auth.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n\nimport {ERC721} from \"gpl/ERC721.sol\";\nimport {IERC721} from \"core/interfaces/IERC721.sol\";\nimport {IERC165} from \"core/interfaces/IERC165.sol\";\nimport {ITransferProxy} from \"core/interfaces/ITransferProxy.sol\";\nimport {SafeCastLib} from \"gpl/utils/SafeCastLib.sol\";\n\nimport {CollateralLookup} from \"core/libraries/CollateralLookup.sol\";\n\nimport {IAstariaRouter} from \"core/interfaces/IAstariaRouter.sol\";\nimport {ICollateralToken} from \"core/interfaces/ICollateralToken.sol\";\nimport {ILienToken} from \"core/interfaces/ILienToken.sol\";\n\nimport {IPublicVault} from \"core/interfaces/IPublicVault.sol\";\nimport {VaultImplementation} from \"./VaultImplementation.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {AuthInitializable} from \"core/AuthInitializable.sol\";\nimport {Initializable} from \"./utils/Initializable.sol\";\n\n/**\n * @title LienToken\n * @notice This contract handles the creation, payments, buyouts, and liquidations of tokenized NFT-collateralized debt (liens). Vaults which originate loans against supported collateral are issued a LienToken representing the right to loan repayments and auctioned funds on liquidation.\n */\ncontract LienToken is ERC721, ILienToken, AuthInitializable {\n  using FixedPointMathLib for uint256;\n  using CollateralLookup for address;\n  using SafeCastLib for uint256;\n  using SafeTransferLib for ERC20;\n\n  uint256 private constant LIEN_SLOT =\n    uint256(keccak256(\"xyz.astaria.LienToken.storage.location\")) - 1;\n\n  bytes32 constant ACTIVE_AUCTION = bytes32(\"ACTIVE_AUCTION\");\n\n  constructor() {\n    _disableInitializers();\n  }\n\n  function initialize(Authority _AUTHORITY, ITransferProxy _TRANSFER_PROXY)\n    public\n    initializer\n  {\n    __initAuth(msg.sender, address(_AUTHORITY));\n    __initERC721(\"Astaria Lien Token\", \"ALT\");\n    LienStorage storage s = _loadLienStorageSlot();\n    s.TRANSFER_PROXY = _TRANSFER_PROXY;\n    s.maxLiens = uint8(5);\n  }\n\n  function _loadLienStorageSlot()\n    internal\n    pure\n    returns (LienStorage storage s)\n  {\n    uint256 slot = LIEN_SLOT;\n\n    assembly {\n      s.slot := slot\n    }\n  }\n\n  function file(File calldata incoming) external requiresAuth {\n    FileType what = incoming.what;\n    bytes memory data = incoming.data;\n    LienStorage storage s = _loadLienStorageSlot();\n    if (what == FileType.CollateralToken) {\n      s.COLLATERAL_TOKEN = ICollateralToken(abi.decode(data, (address)));\n    } else if (what == FileType.AstariaRouter) {\n      s.ASTARIA_ROUTER = IAstariaRouter(abi.decode(data, (address)));\n    } else {\n      revert UnsupportedFile();\n    }\n    emit FileUpdated(what, data);\n  }\n\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    override(ERC721, IERC165)\n    returns (bool)\n  {\n    return\n      interfaceId == type(ILienToken).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n\n  function buyoutLien(ILienToken.LienActionBuyout calldata params)\n    external\n    validateStack(params.encumber.lien.collateralId, params.encumber.stack)\n    returns (Stack[] memory, Stack memory newStack)\n  {\n    if (block.timestamp >= params.encumber.stack[params.position].point.end) {\n      revert InvalidState(InvalidStates.EXPIRED_LIEN);\n    }\n    LienStorage storage s = _loadLienStorageSlot();\n    if (!s.ASTARIA_ROUTER.isValidVault(msg.sender)) {\n      revert InvalidSender();\n    }\n    return _buyoutLien(s, params);\n  }\n\n  function _buyoutLien(\n    LienStorage storage s,\n    ILienToken.LienActionBuyout calldata params\n  ) internal returns (Stack[] memory newStack, Stack memory newLien) {\n    //the borrower shouldn't incur more debt from the buyout than they already owe\n    (, newLien) = _createLien(s, params.encumber);\n    if (\n      !s.ASTARIA_ROUTER.isValidRefinance({\n        newLien: params.encumber.lien,\n        position: params.position,\n        stack: params.encumber.stack\n      })\n    ) {\n      revert InvalidRefinance();\n    }\n\n    if (\n      s.collateralStateHash[params.encumber.lien.collateralId] == ACTIVE_AUCTION\n    ) {\n      revert InvalidState(InvalidStates.COLLATERAL_AUCTION);\n    }\n    (uint256 owed, uint256 buyout) = _getBuyout(\n      s,\n      params.encumber.stack[params.position]\n    );\n\n    if (params.encumber.lien.details.maxAmount < owed) {\n      revert InvalidBuyoutDetails(params.encumber.lien.details.maxAmount, owed);\n    }\n\n    uint256 potentialDebt = 0;\n    for (uint256 i = params.encumber.stack.length; i > 0; ) {\n      uint256 j = i - 1;\n      // should not be able to purchase lien if any lien in the stack is expired (and will be liquidated)\n      if (block.timestamp >= params.encumber.stack[j].point.end) {\n        revert InvalidState(InvalidStates.EXPIRED_LIEN);\n      }\n\n      potentialDebt += _getOwed(\n        params.encumber.stack[j],\n        params.encumber.stack[j].point.end\n      );\n\n      if (\n        potentialDebt >\n        params.encumber.stack[j].lien.details.liquidationInitialAsk\n      ) {\n        revert InvalidState(InvalidStates.INITIAL_ASK_EXCEEDED);\n      }\n\n      unchecked {\n        --i;\n      }\n    }\n\n    address payee = _getPayee(\n      s,\n      params.encumber.stack[params.position].point.lienId\n    );\n    s.TRANSFER_PROXY.tokenTransferFrom(\n      params.encumber.stack[params.position].lien.token,\n      msg.sender,\n      payee,\n      buyout\n    );\n\n    if (_isPublicVault(s, payee)) {\n      IPublicVault(payee).handleBuyoutLien(\n        IPublicVault.BuyoutLienParams({\n          lienSlope: calculateSlope(params.encumber.stack[params.position]),\n          lienEnd: params.encumber.stack[params.position].point.end,\n          increaseYIntercept: buyout -\n            params.encumber.stack[params.position].point.amount\n        })\n      );\n    }\n\n    newStack = _replaceStackAtPositionWithNewLien(\n      s,\n      params.encumber.stack,\n      params.position,\n      newLien,\n      params.encumber.stack[params.position].point.lienId\n    );\n    uint256 maxPotentialDebt;\n    uint256 n = newStack.length;\n    uint256 i;\n    for (i; i < n; ) {\n      maxPotentialDebt += _getOwed(newStack[i], newStack[i].point.end);\n      //no need to check validity before the position we're buying\n      if (i == params.position) {\n        if (maxPotentialDebt > params.encumber.lien.details.maxPotentialDebt) {\n          revert InvalidState(InvalidStates.DEBT_LIMIT);\n        }\n      }\n      if (\n        i > params.position &&\n        (maxPotentialDebt > newStack[i].lien.details.maxPotentialDebt)\n      ) {\n        revert InvalidState(InvalidStates.DEBT_LIMIT);\n      }\n      unchecked {\n        ++i;\n      }\n    }\n\n    s.collateralStateHash[params.encumber.lien.collateralId] = keccak256(\n      abi.encode(newStack)\n    );\n  }\n\n  function _replaceStackAtPositionWithNewLien(\n    LienStorage storage s,\n    ILienToken.Stack[] calldata stack,\n    uint256 position,\n    Stack memory newLien,\n    uint256 oldLienId\n  ) internal returns (ILienToken.Stack[] memory newStack) {\n    newStack = stack;\n    newStack[position] = newLien;\n    _burn(oldLienId);\n    delete s.lienMeta[oldLienId];\n  }\n\n  function getInterest(Stack calldata stack) public view returns (uint256) {\n    return _getInterest(stack, block.timestamp);\n  }\n\n  /**\n   * @dev Computes the interest accrued for a lien since its last payment.\n   * @param stack The Lien for the loan to calculate interest for.\n   * @param timestamp The timestamp at which to compute interest for.\n   */\n  function _getInterest(Stack memory stack, uint256 timestamp)\n    internal\n    pure\n    returns (uint256)\n  {\n    uint256 delta_t = timestamp - stack.point.last;\n\n    return (delta_t * stack.lien.details.rate).mulWadDown(stack.point.amount);\n  }\n\n  modifier validateStack(uint256 collateralId, Stack[] memory stack) {\n    LienStorage storage s = _loadLienStorageSlot();\n    bytes32 stateHash = s.collateralStateHash[collateralId];\n    if (stateHash == bytes32(0) && stack.length != 0) {\n      revert InvalidState(InvalidStates.EMPTY_STATE);\n    }\n    if (stateHash != bytes32(0) && keccak256(abi.encode(stack)) != stateHash) {\n      revert InvalidState(InvalidStates.INVALID_HASH);\n    }\n    _;\n  }\n\n  function stopLiens(\n    uint256 collateralId,\n    uint256 auctionWindow,\n    Stack[] calldata stack,\n    address liquidator\n  ) external validateStack(collateralId, stack) requiresAuth {\n    _stopLiens(\n      _loadLienStorageSlot(),\n      collateralId,\n      auctionWindow,\n      stack,\n      liquidator\n    );\n  }\n\n  function _stopLiens(\n    LienStorage storage s,\n    uint256 collateralId,\n    uint256 auctionWindow,\n    Stack[] calldata stack,\n    address liquidator\n  ) internal {\n    AuctionData memory auctionData;\n    auctionData.liquidator = liquidator;\n    auctionData.stack = new AuctionStack[](stack.length);\n    s.auctionData[collateralId].liquidator = liquidator;\n    uint256 i;\n    for (; i < stack.length; ) {\n      AuctionStack memory auctionStack;\n\n      auctionStack.lienId = stack[i].point.lienId;\n      auctionStack.end = stack[i].point.end;\n      uint88 owed = _getOwed(stack[i], block.timestamp);\n      auctionStack.amountOwed = owed;\n      s.lienMeta[auctionStack.lienId].atLiquidation = true;\n      auctionData.stack[i] = auctionStack;\n      address payee = _getPayee(s, auctionStack.lienId);\n      if (_isPublicVault(s, payee)) {\n        // update the public vault state and get the liquidation accountant back if any\n        address withdrawProxyIfNearBoundary = IPublicVault(payee)\n          .updateVaultAfterLiquidation(\n            auctionWindow,\n            IPublicVault.AfterLiquidationParams({\n              lienSlope: calculateSlope(stack[i]),\n              newAmount: owed,\n              lienEnd: stack[i].point.end\n            })\n          );\n\n        if (withdrawProxyIfNearBoundary != address(0)) {\n          _setPayee(s, auctionStack.lienId, withdrawProxyIfNearBoundary);\n        }\n      }\n      unchecked {\n        ++i;\n      }\n    }\n    s.collateralStateHash[collateralId] = ACTIVE_AUCTION;\n    auctionData.startTime = block.timestamp.safeCastTo48();\n    auctionData.endTime = (block.timestamp + auctionWindow).safeCastTo48();\n    auctionData.startAmount = stack[0]\n      .lien\n      .details\n      .liquidationInitialAsk\n      .safeCastTo88();\n    auctionData.endAmount = uint88(1000 wei);\n    s.COLLATERAL_TOKEN.getClearingHouse(collateralId).setAuctionData(\n      auctionData\n    );\n  }\n\n  function tokenURI(uint256 tokenId)\n    public\n    view\n    override(ERC721, IERC721)\n    returns (string memory)\n  {\n    if (!_exists(tokenId)) {\n      revert InvalidTokenId(tokenId);\n    }\n    return \"\";\n  }\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 id\n  ) public override(ERC721, IERC721) {\n    LienStorage storage s = _loadLienStorageSlot();\n    if (_isPublicVault(s, to)) {\n      revert InvalidState(InvalidStates.PUBLIC_VAULT_RECIPIENT);\n    }\n    if (s.lienMeta[id].atLiquidation) {\n      revert InvalidState(InvalidStates.COLLATERAL_AUCTION);\n    }\n    delete s.lienMeta[id].payee;\n    emit PayeeChanged(id, address(0));\n    super.transferFrom(from, to, id);\n  }\n\n  function ASTARIA_ROUTER() public view returns (IAstariaRouter) {\n    return _loadLienStorageSlot().ASTARIA_ROUTER;\n  }\n\n  function COLLATERAL_TOKEN() public view returns (ICollateralToken) {\n    return _loadLienStorageSlot().COLLATERAL_TOKEN;\n  }\n\n  function _exists(uint256 tokenId) internal view returns (bool) {\n    return _loadERC721Slot()._ownerOf[tokenId] != address(0);\n  }\n\n  function createLien(ILienToken.LienActionEncumber memory params)\n    external\n    requiresAuth\n    validateStack(params.lien.collateralId, params.stack)\n    returns (\n      uint256 lienId,\n      Stack[] memory newStack,\n      uint256 lienSlope\n    )\n  {\n    LienStorage storage s = _loadLienStorageSlot();\n    //0 - 4 are valid\n    Stack memory newStackSlot;\n    (lienId, newStackSlot) = _createLien(s, params);\n\n    newStack = _appendStack(s, params.stack, newStackSlot);\n    s.collateralStateHash[params.lien.collateralId] = keccak256(\n      abi.encode(newStack)\n    );\n\n    lienSlope = calculateSlope(newStackSlot);\n    emit AddLien(\n      params.lien.collateralId,\n      uint8(params.stack.length),\n      lienId,\n      newStackSlot\n    );\n    emit LienStackUpdated(\n      params.lien.collateralId,\n      uint8(params.stack.length),\n      StackAction.ADD,\n      uint8(newStack.length)\n    );\n  }\n\n  function _createLien(\n    LienStorage storage s,\n    ILienToken.LienActionEncumber memory params\n  ) internal returns (uint256 newLienId, ILienToken.Stack memory newSlot) {\n    if (s.collateralStateHash[params.lien.collateralId] == ACTIVE_AUCTION) {\n      revert InvalidState(InvalidStates.COLLATERAL_AUCTION);\n    }\n    if (\n      params.lien.details.liquidationInitialAsk < params.amount ||\n      params.lien.details.liquidationInitialAsk == 0\n    ) {\n      revert InvalidState(InvalidStates.INVALID_LIQUIDATION_INITIAL_ASK);\n    }\n\n    if (params.stack.length > 0) {\n      if (params.lien.collateralId != params.stack[0].lien.collateralId) {\n        revert InvalidState(InvalidStates.COLLATERAL_MISMATCH);\n      }\n\n      if (params.lien.token != params.stack[0].lien.token) {\n        revert InvalidState(InvalidStates.ASSET_MISMATCH);\n      }\n    }\n\n    newLienId = uint256(keccak256(abi.encode(params.lien)));\n    Point memory point = Point({\n      lienId: newLienId,\n      amount: params.amount.safeCastTo88(),\n      last: block.timestamp.safeCastTo40(),\n      end: (block.timestamp + params.lien.details.duration).safeCastTo40()\n    });\n    _mint(params.receiver, newLienId);\n    return (newLienId, Stack({lien: params.lien, point: point}));\n  }\n\n  function _appendStack(\n    LienStorage storage s,\n    Stack[] memory stack,\n    Stack memory newSlot\n  ) internal returns (Stack[] memory newStack) {\n    if (stack.length >= s.maxLiens) {\n      revert InvalidState(InvalidStates.MAX_LIENS);\n    }\n\n    newStack = new Stack[](stack.length + 1);\n    newStack[stack.length] = newSlot;\n\n    uint256 potentialDebt = _getOwed(newSlot, newSlot.point.end);\n    for (uint256 i = stack.length; i > 0; ) {\n      uint256 j = i - 1;\n      newStack[j] = stack[j];\n      if (block.timestamp >= newStack[j].point.end) {\n        revert InvalidState(InvalidStates.EXPIRED_LIEN);\n      }\n\n      unchecked {\n        potentialDebt += _getOwed(newStack[j], newStack[j].point.end);\n      }\n      if (potentialDebt > newStack[j].lien.details.liquidationInitialAsk) {\n        revert InvalidState(InvalidStates.INITIAL_ASK_EXCEEDED);\n      }\n\n      unchecked {\n        --i;\n      }\n    }\n    if (\n      stack.length > 0 && potentialDebt > newSlot.lien.details.maxPotentialDebt\n    ) {\n      revert InvalidState(InvalidStates.DEBT_LIMIT);\n    }\n  }\n\n  function payDebtViaClearingHouse(\n    address token,\n    uint256 collateralId,\n    uint256 payment,\n    AuctionStack[] memory auctionStack\n  ) external {\n    LienStorage storage s = _loadLienStorageSlot();\n    require(\n      msg.sender == address(s.COLLATERAL_TOKEN.getClearingHouse(collateralId))\n    );\n\n    _payDebt(s, token, payment, msg.sender, auctionStack);\n    delete s.collateralStateHash[collateralId];\n  }\n\n  function _payDebt(\n    LienStorage storage s,\n    address token,\n    uint256 payment,\n    address payer,\n    AuctionStack[] memory stack\n  ) internal returns (uint256 totalSpent) {\n    uint256 i;\n    for (; i < stack.length;) {\n      uint256 spent;\n      unchecked {\n        spent = _paymentAH(s, token, stack, i, payment, payer);\n        totalSpent += spent;\n        payment -= spent;\n        ++i;\n      }\n    }\n  }\n\n  function getAuctionData(uint256 collateralId)\n    external\n    view\n    returns (AuctionData memory)\n  {\n    return _loadLienStorageSlot().auctionData[collateralId];\n  }\n\n  function getAuctionLiquidator(uint256 collateralId)\n    external\n    view\n    returns (address liquidator)\n  {\n    liquidator = _loadLienStorageSlot().auctionData[collateralId].liquidator;\n    if (liquidator == address(0)) {\n      revert InvalidState(InvalidStates.COLLATERAL_NOT_LIQUIDATED);\n    }\n  }\n\n  function getAmountOwingAtLiquidation(ILienToken.Stack calldata stack)\n    public\n    view\n    returns (uint256)\n  {\n    return\n      _loadLienStorageSlot()\n        .auctionData[stack.lien.collateralId]\n        .stack[stack.point.lienId]\n        .amountOwed;\n  }\n\n  function validateLien(Lien memory lien) public view returns (uint256 lienId) {\n    lienId = uint256(keccak256(abi.encode(lien)));\n    if (!_exists(lienId)) {\n      revert InvalidState(InvalidStates.INVALID_LIEN_ID);\n    }\n  }\n\n  function getCollateralState(uint256 collateralId)\n    external\n    view\n    returns (bytes32)\n  {\n    return _loadLienStorageSlot().collateralStateHash[collateralId];\n  }\n\n  function getBuyout(Stack calldata stack)\n    public\n    view\n    returns (uint256 owed, uint256 buyout)\n  {\n    return _getBuyout(_loadLienStorageSlot(), stack);\n  }\n\n  function _getBuyout(LienStorage storage s, Stack calldata stack)\n    internal\n    view\n    returns (uint256 owed, uint256 buyout)\n  {\n    owed = _getOwed(stack, block.timestamp);\n    buyout =\n      owed +\n      s.ASTARIA_ROUTER.getBuyoutFee(_getRemainingInterest(s, stack));\n  }\n\n  function makePayment(\n    uint256 collateralId,\n    Stack[] calldata stack,\n    uint256 amount\n  )\n    public\n    validateStack(collateralId, stack)\n    returns (Stack[] memory newStack)\n  {\n    return _makePayment(_loadLienStorageSlot(), stack, amount);\n  }\n\n  function makePayment(\n    uint256 collateralId,\n    Stack[] calldata stack,\n    uint8 position,\n    uint256 amount\n  )\n    external\n    validateStack(collateralId, stack)\n    returns (Stack[] memory newStack)\n  {\n    LienStorage storage s = _loadLienStorageSlot();\n    (newStack, ) = _payment(s, stack, position, amount, msg.sender);\n    _updateCollateralStateHash(s, collateralId, newStack);\n  }\n\n  function _paymentAH(\n    LienStorage storage s,\n    address token,\n    AuctionStack[] memory stack,\n    uint256 position,\n    uint256 payment,\n    address payer\n  ) internal returns (uint256) {\n    uint256 lienId = stack[position].lienId;\n    uint256 end = stack[position].end;\n    uint256 owing = stack[position].amountOwed;\n    //checks the lien exists\n    address payee = _getPayee(s, lienId);\n    uint256 remaining = 0;\n    if (owing > payment.safeCastTo88()) {\n      remaining = owing - payment;\n    } else {\n      payment = owing;\n    }\n    if (payment > 0)\n      s.TRANSFER_PROXY.tokenTransferFrom(token, payer, payee, payment);\n\n    delete s.lienMeta[lienId]; //full delete\n    delete stack[position];\n    _burn(lienId);\n\n    if (_isPublicVault(s, payee)) {\n      IPublicVault(payee).updateAfterLiquidationPayment(\n        IPublicVault.LiquidationPaymentParams({remaining: remaining})\n      );\n    }\n    emit Payment(lienId, payment);\n    return payment;\n  }\n\n  /**\n   * @dev Have a specified payer make a payment for the debt against a CollateralToken.\n   * @param stack the stack for the payment\n   * @param totalCapitalAvailable The amount to pay against the debts\n   */\n  function _makePayment(\n    LienStorage storage s,\n    Stack[] calldata stack,\n    uint256 totalCapitalAvailable\n  ) internal returns (Stack[] memory newStack) {\n    newStack = stack;\n    for (uint256 i; i < newStack.length; ) {\n      uint256 oldLength = newStack.length;\n      uint256 spent;\n      (newStack, spent) = _payme"
    }
  ]
}