{
  "Title": "Failure in emergencyClose results in funds being stuck",
  "Content": "# Failure in emergencyClose results in funds being stuck\n\n### Severity\nMedium Risk\n\n### Relevant GitHub Links\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXEmergency.sol#L176\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXEmergency.sol#L176</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXEmergency.sol#L111-L156\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXEmergency.sol#L111-L156</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXEmergency.sol#L122\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXEmergency.sol#L122</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXManager.sol#L123\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXManager.sol#L123</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXReader.sol#L168\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXReader.sol#L168</a>\n\n<a data-meta=\"codehawks-github-link\" href=\"https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXEmergency.sol#L141\">https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXEmergency.sol#L141</a>\n\n\n## Summary\nIn order to activate the emergency withdrawals, the vault needs to reach the CLOSED status. If the vault fails to do so, users won't be able to withdraw their funds.\n\n## Vulnerability Details\nUsers have the ability to call ```emergencyWithdraw``` method in order to retrieve their funds when the vault is CLOSED [link1](https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXEmergency.sol#L176). However to reach this status, the vault needs to be paused first by the owners and then the ```emergencyClose``` needs to be called [link2](https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXEmergency.sol#L111-L156).\n\nHowever the ```emergencyClose``` has many possible points of failure since it does many external calls:\n1- calls the lending contract to calculate debt and repay it [link3](https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXEmergency.sol#L122) [link4](https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXManager.sol#L123) [link5](https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXReader.sol#L168) [link 6](https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXEmergency.sol#L144)\n\n2- calls a swap router if a trade is needed [link6](https://github.com/Cyfrin/2023-10-SteadeFi/blob/0f909e2f0917cb9ad02986f631d622376510abec/contracts/strategy/gmx/GMXEmergency.sol#L141) (can revert for example if the uniswap router does not provide enough tokenOut when given a fix amount of tokenIn).\n\nIf any of these calls fail, the vault status will remain at PAUSED.\n\n## Impact\nUsers cannot retrieve their funds after the pause unless all the external contracts done in ```emergencyClose``` work as expected and all the debt have been cleared.\n\n## Tools Used\n\n## Recommendations\nUse a time limit after pausing the vault that allows anyone to CLOSE the vault without doing any external calls inside the method.\n\nExample:\n```\nfunction emergencyClose(\n  GMXTypes.Store storage self,\n  uint256 deadline\n) external {\n  GMXChecks.beforeEmergencyCloseChecks(self);\n  \n  if(block.timestamp < self.pauseTimestamp + CLOSE_MAX_DURATION) { \n\n    // Repay all borrowed assets; 1e18 == 100% shareRatio to repay\n    GMXTypes.RepayParams memory _rp;\n    (\n      _rp.repayTokenAAmt,\n      _rp.repayTokenBAmt\n    ) = GMXManager.calcRepay(self, 1e18);\n\n    (\n      bool _swapNeeded,\n      address _tokenFrom,\n      address _tokenTo,\n      uint256 _tokenToAmt\n    ) = GMXManager.calcSwapForRepay(self, _rp);\n\n    if (_swapNeeded) {\n      ISwap.SwapParams memory _sp;\n\n      _sp.tokenIn = _tokenFrom;\n      _sp.tokenOut = _tokenTo;\n      _sp.amountIn = IERC20(_tokenFrom).balanceOf(address(this));\n      _sp.amountOut = _tokenToAmt;\n      _sp.slippage = self.minSlippage;\n      _sp.deadline = deadline;\n\n      GMXManager.swapTokensForExactTokens(self, _sp);\n    }\n\n    GMXManager.repay(\n      self,\n      _rp.repayTokenAAmt,\n      _rp.repayTokenBAmt\n    );\n    \n    self.status = GMXTypes.Status.Closed;\n\n    emit EmergencyClose(\n      _rp.repayTokenAAmt,\n      _rp.repayTokenBAmt\n    );\n\n  } else {\n    self.status = GMXTypes.Status.Closed;\n\n    emit EmergencyClose(\n      0,\n      0\n    );\n  }\n\n}\n\n```",
  "Impact": "LOW",
  "Source": "https://www.codehawks.com/contests/clo38mm260001la08daw5cbuf",
  "Code": [
    {
      "filename": "contracts/strategy/gmx/GMXEmergency.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ISwap } from  \"../../interfaces/swap/ISwap.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXChecks } from \"./GMXChecks.sol\";\nimport { GMXManager } from \"./GMXManager.sol\";\n\n/**\n  * @title GMXEmergency\n  * @author Steadefi\n  * @notice Re-usable library functions for emergency operations for Steadefi leveraged vaults\n*/\nlibrary GMXEmergency {\n  using SafeERC20 for IERC20;\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n  uint256 public constant DUST_AMOUNT = 1e17;\n\n  /* ======================== EVENTS ========================= */\n\n  event EmergencyPause();\n  event EmergencyResume();\n  event EmergencyClose(\n    uint256 repayTokenAAmt,\n    uint256 repayTokenBAmt\n  );\n  event EmergencyWithdraw(\n    address indexed user,\n    uint256 sharesAmt,\n    address assetA,\n    uint256 assetAAmt,\n    address assetB,\n    uint256 assetBAmt\n  );\n\n  /* ================== MUTATIVE FUNCTIONS =================== */\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function emergencyPause(\n    GMXTypes.Store storage self\n  ) external {\n    self.refundee = payable(msg.sender);\n\n    GMXTypes.RemoveLiquidityParams memory _rlp;\n\n    // Remove all of the vault's LP tokens\n    _rlp.lpAmt = self.lpToken.balanceOf(address(this));\n    _rlp.executionFee = msg.value;\n\n    GMXManager.removeLiquidity(\n      self,\n      _rlp\n    );\n\n    self.status = GMXTypes.Status.Paused;\n\n    emit EmergencyPause();\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function emergencyResume(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeEmergencyResumeChecks(self);\n\n    self.status = GMXTypes.Status.Resume;\n\n    self.refundee = payable(msg.sender);\n\n    GMXTypes.AddLiquidityParams memory _alp;\n\n    _alp.tokenAAmt = self.tokenA.balanceOf(address(this));\n    _alp.tokenBAmt = self.tokenB.balanceOf(address(this));\n    _alp.executionFee = msg.value;\n\n    GMXManager.addLiquidity(\n      self,\n      _alp\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processEmergencyResume(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessEmergencyResumeChecks(self);\n\n    self.status = GMXTypes.Status.Open;\n\n    emit EmergencyResume();\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function emergencyClose(\n    GMXTypes.Store storage self,\n    uint256 deadline\n  ) external {\n    GMXChecks.beforeEmergencyCloseChecks(self);\n\n    // Repay all borrowed assets; 1e18 == 100% shareRatio to repay\n    GMXTypes.RepayParams memory _rp;\n    (\n      _rp.repayTokenAAmt,\n      _rp.repayTokenBAmt\n    ) = GMXManager.calcRepay(self, 1e18);\n\n    (\n      bool _swapNeeded,\n      address _tokenFrom,\n      address _tokenTo,\n      uint256 _tokenToAmt\n    ) = GMXManager.calcSwapForRepay(self, _rp);\n\n    if (_swapNeeded) {\n      ISwap.SwapParams memory _sp;\n\n      _sp.tokenIn = _tokenFrom;\n      _sp.tokenOut = _tokenTo;\n      _sp.amountIn = IERC20(_tokenFrom).balanceOf(address(this));\n      _sp.amountOut = _tokenToAmt;\n      _sp.slippage = self.minSlippage;\n      _sp.deadline = deadline;\n\n      GMXManager.swapTokensForExactTokens(self, _sp);\n    }\n\n    GMXManager.repay(\n      self,\n      _rp.repayTokenAAmt,\n      _rp.repayTokenBAmt\n    );\n\n    self.status = GMXTypes.Status.Closed;\n\n    emit EmergencyClose(\n      _rp.repayTokenAAmt,\n      _rp.repayTokenBAmt\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function emergencyWithdraw(\n    GMXTypes.Store storage self,\n    uint256 shareAmt\n  ) external {\n    // check to ensure shares withdrawn does not exceed user's balance\n    uint256 _userShareBalance = IERC20(address(self.vault)).balanceOf(msg.sender);\n\n    // to avoid leaving dust behind\n    unchecked {\n      if (_userShareBalance - shareAmt < DUST_AMOUNT) {\n        shareAmt = _userShareBalance;\n      }\n    }\n\n    GMXChecks.beforeEmergencyWithdrawChecks(self, shareAmt);\n\n    // share ratio calculation must be before burn()\n    uint256 _shareRatio = shareAmt * SAFE_MULTIPLIER\n                          / IERC20(address(self.vault)).totalSupply();\n\n    self.vault.burn(msg.sender, shareAmt);\n\n    uint256 _withdrawAmtTokenA = _shareRatio\n                                 * self.tokenA.balanceOf(address(this))\n                                 / SAFE_MULTIPLIER;\n    uint256 _withdrawAmtTokenB = _shareRatio\n                                 * self.tokenB.balanceOf(address(this))\n                                 / SAFE_MULTIPLIER;\n\n    self.tokenA.safeTransfer(msg.sender, _withdrawAmtTokenA);\n    self.tokenB.safeTransfer(msg.sender, _withdrawAmtTokenB);\n\n    emit EmergencyWithdraw(\n      msg.sender,\n      shareAmt,\n      address(self.tokenA),\n      _withdrawAmtTokenA,\n      address(self.tokenB),\n      _withdrawAmtTokenB\n    );\n  }\n}"
    },
    {
      "filename": "contracts/strategy/gmx/GMXEmergency.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ISwap } from  \"../../interfaces/swap/ISwap.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXChecks } from \"./GMXChecks.sol\";\nimport { GMXManager } from \"./GMXManager.sol\";\n\n/**\n  * @title GMXEmergency\n  * @author Steadefi\n  * @notice Re-usable library functions for emergency operations for Steadefi leveraged vaults\n*/\nlibrary GMXEmergency {\n  using SafeERC20 for IERC20;\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n  uint256 public constant DUST_AMOUNT = 1e17;\n\n  /* ======================== EVENTS ========================= */\n\n  event EmergencyPause();\n  event EmergencyResume();\n  event EmergencyClose(\n    uint256 repayTokenAAmt,\n    uint256 repayTokenBAmt\n  );\n  event EmergencyWithdraw(\n    address indexed user,\n    uint256 sharesAmt,\n    address assetA,\n    uint256 assetAAmt,\n    address assetB,\n    uint256 assetBAmt\n  );\n\n  /* ================== MUTATIVE FUNCTIONS =================== */\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function emergencyPause(\n    GMXTypes.Store storage self\n  ) external {\n    self.refundee = payable(msg.sender);\n\n    GMXTypes.RemoveLiquidityParams memory _rlp;\n\n    // Remove all of the vault's LP tokens\n    _rlp.lpAmt = self.lpToken.balanceOf(address(this));\n    _rlp.executionFee = msg.value;\n\n    GMXManager.removeLiquidity(\n      self,\n      _rlp\n    );\n\n    self.status = GMXTypes.Status.Paused;\n\n    emit EmergencyPause();\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function emergencyResume(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeEmergencyResumeChecks(self);\n\n    self.status = GMXTypes.Status.Resume;\n\n    self.refundee = payable(msg.sender);\n\n    GMXTypes.AddLiquidityParams memory _alp;\n\n    _alp.tokenAAmt = self.tokenA.balanceOf(address(this));\n    _alp.tokenBAmt = self.tokenB.balanceOf(address(this));\n    _alp.executionFee = msg.value;\n\n    GMXManager.addLiquidity(\n      self,\n      _alp\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processEmergencyResume(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessEmergencyResumeChecks(self);\n\n    self.status = GMXTypes.Status.Open;\n\n    emit EmergencyResume();\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function emergencyClose(\n    GMXTypes.Store storage self,\n    uint256 deadline\n  ) external {\n    GMXChecks.beforeEmergencyCloseChecks(self);\n\n    // Repay all borrowed assets; 1e18 == 100% shareRatio to repay\n    GMXTypes.RepayParams memory _rp;\n    (\n      _rp.repayTokenAAmt,\n      _rp.repayTokenBAmt\n    ) = GMXManager.calcRepay(self, 1e18);\n\n    (\n      bool _swapNeeded,\n      address _tokenFrom,\n      address _tokenTo,\n      uint256 _tokenToAmt\n    ) = GMXManager.calcSwapForRepay(self, _rp);\n\n    if (_swapNeeded) {\n      ISwap.SwapParams memory _sp;\n\n      _sp.tokenIn = _tokenFrom;\n      _sp.tokenOut = _tokenTo;\n      _sp.amountIn = IERC20(_tokenFrom).balanceOf(address(this));\n      _sp.amountOut = _tokenToAmt;\n      _sp.slippage = self.minSlippage;\n      _sp.deadline = deadline;\n\n      GMXManager.swapTokensForExactTokens(self, _sp);\n    }\n\n    GMXManager.repay(\n      self,\n      _rp.repayTokenAAmt,\n      _rp.repayTokenBAmt\n    );\n\n    self.status = GMXTypes.Status.Closed;\n\n    emit EmergencyClose(\n      _rp.repayTokenAAmt,\n      _rp.repayTokenBAmt\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function emergencyWithdraw(\n    GMXTypes.Store storage self,\n    uint256 shareAmt\n  ) external {\n    // check to ensure shares withdrawn does not exceed user's balance\n    uint256 _userShareBalance = IERC20(address(self.vault)).balanceOf(msg.sender);\n\n    // to avoid leaving dust behind\n    unchecked {\n      if (_userShareBalance - shareAmt < DUST_AMOUNT) {\n        shareAmt = _userShareBalance;\n      }\n    }\n\n    GMXChecks.beforeEmergencyWithdrawChecks(self, shareAmt);\n\n    // share ratio calculation must be before burn()\n    uint256 _shareRatio = shareAmt * SAFE_MULTIPLIER\n                          / IERC20(address(self.vault)).totalSupply();\n\n    self.vault.burn(msg.sender, shareAmt);\n\n    uint256 _withdrawAmtTokenA = _shareRatio\n                                 * self.tokenA.balanceOf(address(this))\n                                 / SAFE_MULTIPLIER;\n    uint256 _withdrawAmtTokenB = _shareRatio\n                                 * self.tokenB.balanceOf(address(this))\n                                 / SAFE_MULTIPLIER;\n\n    self.tokenA.safeTransfer(msg.sender, _withdrawAmtTokenA);\n    self.tokenB.safeTransfer(msg.sender, _withdrawAmtTokenB);\n\n    emit EmergencyWithdraw(\n      msg.sender,\n      shareAmt,\n      address(self.tokenA),\n      _withdrawAmtTokenA,\n      address(self.tokenB),\n      _withdrawAmtTokenB\n    );\n  }\n}"
    },
    {
      "filename": "contracts/strategy/gmx/GMXEmergency.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ISwap } from  \"../../interfaces/swap/ISwap.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXChecks } from \"./GMXChecks.sol\";\nimport { GMXManager } from \"./GMXManager.sol\";\n\n/**\n  * @title GMXEmergency\n  * @author Steadefi\n  * @notice Re-usable library functions for emergency operations for Steadefi leveraged vaults\n*/\nlibrary GMXEmergency {\n  using SafeERC20 for IERC20;\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n  uint256 public constant DUST_AMOUNT = 1e17;\n\n  /* ======================== EVENTS ========================= */\n\n  event EmergencyPause();\n  event EmergencyResume();\n  event EmergencyClose(\n    uint256 repayTokenAAmt,\n    uint256 repayTokenBAmt\n  );\n  event EmergencyWithdraw(\n    address indexed user,\n    uint256 sharesAmt,\n    address assetA,\n    uint256 assetAAmt,\n    address assetB,\n    uint256 assetBAmt\n  );\n\n  /* ================== MUTATIVE FUNCTIONS =================== */\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function emergencyPause(\n    GMXTypes.Store storage self\n  ) external {\n    self.refundee = payable(msg.sender);\n\n    GMXTypes.RemoveLiquidityParams memory _rlp;\n\n    // Remove all of the vault's LP tokens\n    _rlp.lpAmt = self.lpToken.balanceOf(address(this));\n    _rlp.executionFee = msg.value;\n\n    GMXManager.removeLiquidity(\n      self,\n      _rlp\n    );\n\n    self.status = GMXTypes.Status.Paused;\n\n    emit EmergencyPause();\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function emergencyResume(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeEmergencyResumeChecks(self);\n\n    self.status = GMXTypes.Status.Resume;\n\n    self.refundee = payable(msg.sender);\n\n    GMXTypes.AddLiquidityParams memory _alp;\n\n    _alp.tokenAAmt = self.tokenA.balanceOf(address(this));\n    _alp.tokenBAmt = self.tokenB.balanceOf(address(this));\n    _alp.executionFee = msg.value;\n\n    GMXManager.addLiquidity(\n      self,\n      _alp\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function processEmergencyResume(\n    GMXTypes.Store storage self\n  ) external {\n    GMXChecks.beforeProcessEmergencyResumeChecks(self);\n\n    self.status = GMXTypes.Status.Open;\n\n    emit EmergencyResume();\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function emergencyClose(\n    GMXTypes.Store storage self,\n    uint256 deadline\n  ) external {\n    GMXChecks.beforeEmergencyCloseChecks(self);\n\n    // Repay all borrowed assets; 1e18 == 100% shareRatio to repay\n    GMXTypes.RepayParams memory _rp;\n    (\n      _rp.repayTokenAAmt,\n      _rp.repayTokenBAmt\n    ) = GMXManager.calcRepay(self, 1e18);\n\n    (\n      bool _swapNeeded,\n      address _tokenFrom,\n      address _tokenTo,\n      uint256 _tokenToAmt\n    ) = GMXManager.calcSwapForRepay(self, _rp);\n\n    if (_swapNeeded) {\n      ISwap.SwapParams memory _sp;\n\n      _sp.tokenIn = _tokenFrom;\n      _sp.tokenOut = _tokenTo;\n      _sp.amountIn = IERC20(_tokenFrom).balanceOf(address(this));\n      _sp.amountOut = _tokenToAmt;\n      _sp.slippage = self.minSlippage;\n      _sp.deadline = deadline;\n\n      GMXManager.swapTokensForExactTokens(self, _sp);\n    }\n\n    GMXManager.repay(\n      self,\n      _rp.repayTokenAAmt,\n      _rp.repayTokenBAmt\n    );\n\n    self.status = GMXTypes.Status.Closed;\n\n    emit EmergencyClose(\n      _rp.repayTokenAAmt,\n      _rp.repayTokenBAmt\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function emergencyWithdraw(\n    GMXTypes.Store storage self,\n    uint256 shareAmt\n  ) external {\n    // check to ensure shares withdrawn does not exceed user's balance\n    uint256 _userShareBalance = IERC20(address(self.vault)).balanceOf(msg.sender);\n\n    // to avoid leaving dust behind\n    unchecked {\n      if (_userShareBalance - shareAmt < DUST_AMOUNT) {\n        shareAmt = _userShareBalance;\n      }\n    }\n\n    GMXChecks.beforeEmergencyWithdrawChecks(self, shareAmt);\n\n    // share ratio calculation must be before burn()\n    uint256 _shareRatio = shareAmt * SAFE_MULTIPLIER\n                          / IERC20(address(self.vault)).totalSupply();\n\n    self.vault.burn(msg.sender, shareAmt);\n\n    uint256 _withdrawAmtTokenA = _shareRatio\n                                 * self.tokenA.balanceOf(address(this))\n                                 / SAFE_MULTIPLIER;\n    uint256 _withdrawAmtTokenB = _shareRatio\n                                 * self.tokenB.balanceOf(address(this))\n                                 / SAFE_MULTIPLIER;\n\n    self.tokenA.safeTransfer(msg.sender, _withdrawAmtTokenA);\n    self.tokenB.safeTransfer(msg.sender, _withdrawAmtTokenB);\n\n    emit EmergencyWithdraw(\n      msg.sender,\n      shareAmt,\n      address(self.tokenA),\n      _withdrawAmtTokenA,\n      address(self.tokenB),\n      _withdrawAmtTokenB\n    );\n  }\n}"
    },
    {
      "filename": "contracts/strategy/gmx/GMXManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { ISwap } from  \"../../interfaces/swap/ISwap.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\nimport { GMXReader } from \"./GMXReader.sol\";\nimport { GMXWorker } from \"./GMXWorker.sol\";\n\n/**\n  * @title GMXManager\n  * @author Steadefi\n  * @notice Re-usable library functions for calculations and operations of borrows, repays, swaps\n  * adding and removal of liquidity to yield source\n*/\nlibrary GMXManager {\n  using SafeERC20 for IERC20;\n\n  /* ====================== CONSTANTS ======================== */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n\n  /* ===================== VIEW FUNCTIONS ==================== */\n\n  /**\n    * @notice Calculate if token swap is needed to ensure enough repayment for both tokenA and tokenB\n    * @notice Assume that after swapping one token for the other, there is still enough to repay both tokens\n    * @param self GMXTypes.Store\n    * @param rp GMXTypes.RepayParams\n    * @return swapNeeded boolean if swap is needed\n    * @return tokenFrom address of token to swap from\n    * @return tokenTo address of token to swap to\n    * @return tokenToAmt amount of tokenFrom to swap in token decimals\n  */\n  function calcSwapForRepay(\n    GMXTypes.Store storage self,\n    GMXTypes.RepayParams memory rp\n  ) external view returns (bool, address, address, uint256) {\n    address _tokenFrom;\n    address _tokenTo;\n    uint256 _tokenToAmt;\n\n    if (rp.repayTokenAAmt > self.tokenA.balanceOf(address(this))) {\n      // If more tokenA is needed for repayment\n      _tokenToAmt = rp.repayTokenAAmt - self.tokenA.balanceOf(address(this));\n      _tokenFrom = address(self.tokenB);\n      _tokenTo = address(self.tokenA);\n\n      return (true, _tokenFrom, _tokenTo, _tokenToAmt);\n    } else if (rp.repayTokenBAmt > self.tokenB.balanceOf(address(this))) {\n      // If more tokenB is needed for repayment\n      _tokenToAmt = rp.repayTokenBAmt - self.tokenB.balanceOf(address(this));\n      _tokenFrom = address(self.tokenA);\n      _tokenTo = address(self.tokenB);\n\n      return (true, _tokenFrom, _tokenTo, _tokenToAmt);\n    } else {\n      // If more there is enough to repay both tokens\n      return (false, address(0), address(0), 0);\n    }\n  }\n\n  /**\n    * @notice Calculate amount of tokenA and tokenB to borrow\n    * @param self GMXTypes.Store\n    * @param depositValue USD value in 1e18\n  */\n  function calcBorrow(\n    GMXTypes.Store storage self,\n    uint256 depositValue\n  ) external view returns (uint256, uint256) {\n    // Calculate final position value based on deposit value\n    uint256 _positionValue = depositValue * self.leverage / SAFE_MULTIPLIER;\n\n    // Obtain the value to borrow\n    uint256 _borrowValue = _positionValue - depositValue;\n\n    uint256 _tokenADecimals = IERC20Metadata(address(self.tokenA)).decimals();\n    uint256 _tokenBDecimals = IERC20Metadata(address(self.tokenB)).decimals();\n    uint256 _borrowLongTokenAmt;\n    uint256 _borrowShortTokenAmt;\n\n    // If delta is long, borrow all in short token\n    if (self.delta == GMXTypes.Delta.Long) {\n      _borrowShortTokenAmt = _borrowValue * SAFE_MULTIPLIER\n                             / GMXReader.convertToUsdValue(self, address(self.tokenB), 10**(_tokenBDecimals))\n                             / (10 ** (18 - _tokenBDecimals));\n    }\n\n    // If delta is neutral, borrow appropriate amount in long token to hedge, and the rest in short token\n    if (self.delta == GMXTypes.Delta.Neutral) {\n      // Get token weights in LP, e.g. 50% = 5e17\n      (uint256 _tokenAWeight,) = GMXReader.tokenWeights(self);\n\n      // Get value of long token (typically tokenA)\n      uint256 _longTokenWeightedValue = _tokenAWeight * _positionValue / SAFE_MULTIPLIER;\n\n      // Borrow appropriate amount in long token to hedge\n      _borrowLongTokenAmt = _longTokenWeightedValue * SAFE_MULTIPLIER\n                            / GMXReader.convertToUsdValue(self, address(self.tokenA), 10**(_tokenADecimals))\n                            / (10 ** (18 - _tokenADecimals));\n\n      // Borrow the shortfall value in short token\n      _borrowShortTokenAmt = (_borrowValue - _longTokenWeightedValue) * SAFE_MULTIPLIER\n                             / GMXReader.convertToUsdValue(self, address(self.tokenB), 10**(_tokenBDecimals))\n                             / (10 ** (18 - _tokenBDecimals));\n    }\n\n    return (_borrowLongTokenAmt, _borrowShortTokenAmt);\n  }\n\n  /**\n    * @notice Calculate amount of tokenA and tokenB to repay based on token shares ratio being withdrawn\n    * @param self GMXTypes.Store\n    * @param shareRatio Amount of vault token shares relative to total supply in 1e18\n  */\n  function calcRepay(\n    GMXTypes.Store storage self,\n    uint256 shareRatio\n  ) external view returns (uint256, uint256) {\n    (uint256 tokenADebtAmt, uint256 tokenBDebtAmt) = GMXReader.debtAmt(self);\n\n    uint256 _repayTokenAAmt = shareRatio * tokenADebtAmt / SAFE_MULTIPLIER;\n    uint256 _repayTokenBAmt = shareRatio * tokenBDebtAmt / SAFE_MULTIPLIER;\n\n    return (_repayTokenAAmt, _repayTokenBAmt);\n  }\n\n  /**\n    * @notice Calculate minimum market (GM LP) tokens to receive when adding liquidity\n    * @param self GMXTypes.Store\n    * @param depositValue USD value in 1e18\n    * @param slippage Slippage value in 1e4\n    * @return minMarketTokenAmt in 1e18\n  */\n  function calcMinMarketSlippageAmt(\n    GMXTypes.Store storage self,\n    uint256 depositValue,\n    uint256 slippage\n  ) external view returns (uint256) {\n    uint256 _lpTokenValue = self.gmxOracle.getLpTokenValue(\n      address(self.lpToken),\n      address(self.tokenA),\n      address(self.tokenA),\n      address(self.tokenB),\n      false,\n      false\n    );\n\n    return depositValue\n      * SAFE_MULTIPLIER\n      / _lpTokenValue\n      * (10000 - slippage) / 10000;\n  }\n\n  /**\n    * @notice Calculate minimum tokens to receive when removing liquidity\n    * @dev minLongToken and minShortToken should be the token which we want to receive\n    * after liquidity withdrawal and swap\n    * @param self GMXTypes.Store\n    * @param lpAmt Amt of lp tokens to remove liquidity in 1e18\n    * @param minLongToken Address of token to receive longToken in\n    * @param minShortToken Address of token to receive shortToken in\n    * @param slippage Slippage value in 1e4\n    * @return minTokenAAmt in 1e18\n    * @return minTokenBAmt in 1e18\n  */\n  function calcMinTokensSlippageAmt(\n    GMXTypes.Store storage self,\n    uint256 lpAmt,\n    address minLongToken,\n    address minShortToken,\n    uint256 slippage\n  ) external view returns (uint256, uint256) {\n    uint256 _withdrawValue = lpAmt\n      * self.gmxOracle.getLpTokenValue(\n        address(self.lpToken),\n        address(self.tokenA),\n        address(self.tokenA),\n        address(self.tokenB),\n        false,\n        false\n      )\n      / SAFE_MULTIPLIER;\n\n    (uint256 _tokenAWeight, uint256 _tokenBWeight) = GMXReader.tokenWeights(self);\n\n    uint256 _minLongTokenAmt = _withdrawValue\n      * _tokenAWeight / SAFE_MULTIPLIER\n      * SAFE_MULTIPLIER\n      / GMXReader.convertToUsdValue(\n        self,\n        minLongToken,\n        10**(IERC20Metadata(minLongToken).decimals())\n      )\n      / (10 ** (18 - IERC20Metadata(minLongToken).decimals()));\n\n    uint256 _minShortTokenAmt = _withdrawValue\n      * _tokenBWeight / SAFE_MULTIPLIER\n      * SAFE_MULTIPLIER\n      / GMXReader.convertToUsdValue(\n        self,\n        minShortToken,\n        10**(IERC20Metadata(minShortToken).decimals())\n      )\n      / (10 ** (18 - IERC20Metadata(minShortToken).decimals()));\n\n    return (\n      _minLongTokenAmt * (10000 - slippage) / 10000,\n      _minShortTokenAmt * (10000 - slippage) / 10000\n    );\n  }\n\n\n  /* ================== MUTATIVE FUNCTIONS =================== */\n\n  /**\n    * @notice Borrow tokens from lending vaults\n    * @param self GMXTypes.Store\n    * @param borrowTokenAAmt Amount of tokenA to borrow in token decimals\n    * @param borrowTokenBAmt Amount of tokenB to borrow in token decimals\n  */\n  function borrow(\n    GMXTypes.Store storage self,\n    uint256 borrowTokenAAmt,\n    uint256 borrowTokenBAmt\n  ) public {\n    if (borrowTokenAAmt > 0) {\n      self.tokenALendingVault.borrow(borrowTokenAAmt);\n    }\n    if (borrowTokenBAmt > 0) {\n      self.tokenBLendingVault.borrow(borrowTokenBAmt);\n    }\n  }\n\n  /**\n    * @notice Repay tokens to lending vaults\n    * @param self GMXTypes.Store\n    * @param repayTokenAAmt Amount of tokenA to repay in token decimals\n    * @param repayTokenBAmt Amount of tokenB to repay in token decimals\n  */\n  function repay(\n    GMXTypes.Store storage self,\n    uint256 repayTokenAAmt,\n    uint256 repayTokenBAmt\n  ) public {\n    if (repayTokenAAmt > 0) {\n      self.tokenALendingVault.repay(repayTokenAAmt);\n    }\n    if (repayTokenBAmt > 0) {\n      self.tokenBLendingVault.repay(repayTokenBAmt);\n    }\n  }\n\n  /**\n    * @notice Add liquidity to yield source\n    * @param self GMXTypes.Store\n    * @param alp GMXTypes.AddLiquidityParams\n    * @return depositKey\n  */\n  function addLiquidity(\n    GMXTypes.Store storage self,\n    GMXTypes.AddLiquidityParams memory alp\n  ) public returns (bytes32) {\n    return GMXWorker.addLiquidity(self, alp);\n  }\n\n  /**\n    * @notice Remove liquidity from yield source\n    * @param self GMXTypes.Store\n    * @param rlp GMXTypes.RemoveLiquidityParams\n    * @return withdrawKey\n  */\n  function removeLiquidity(\n    GMXTypes.Store storage self,\n    GMXTypes.RemoveLiquidityParams memory rlp\n  ) public returns (bytes32) {\n    return GMXWorker.removeLiquidity(self, rlp);\n  }\n\n  /**\n    * @notice Swap exact amount of tokenIn for as many possible amount of tokenOut\n    * @param self GMXTypes.Store\n    * @param sp ISwap.SwapParams\n    * @return amountOut in token decimals\n  */\n  function swapExactTokensForTokens(\n    GMXTypes.Store storage self,\n    ISwap.SwapParams memory sp\n  ) external returns (uint256) {\n    if (sp.amountIn > 0) {\n      return GMXWorker.swapExactTokensForTokens(self, sp);\n    } else {\n      return 0;\n    }\n  }\n\n  /**\n    * @notice Swap as little posible tokenIn for exact amount of tokenOut\n    * @param self GMXTypes.Store\n    * @param sp ISwap.SwapParams\n    * @return amountIn in token decimals\n  */\n  function swapTokensForExactTokens(\n    GMXTypes.Store storage self,\n    ISwap.SwapParams memory sp\n  ) external returns (uint256) {\n    if (sp.amountIn > 0) {\n      return GMXWorker.swapTokensForExactTokens(self, sp);\n    } else {\n      return 0;\n    }\n  }\n}"
    },
    {
      "filename": "contracts/strategy/gmx/GMXReader.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { GMXTypes } from \"./GMXTypes.sol\";\n\n/**\n  * @title GMXReader\n  * @author Steadefi\n  * @notice Re-usable library functions for reading data and values for Steadefi leveraged vaults\n*/\nlibrary GMXReader {\n  using SafeCast for uint256;\n\n  /* =================== CONSTANTS FUNCTIONS ================= */\n\n  uint256 public constant SAFE_MULTIPLIER = 1e18;\n\n  /* ===================== VIEW FUNCTIONS ==================== */\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function svTokenValue(GMXTypes.Store storage self) public view returns (uint256) {\n    uint256 equityValue_ = equityValue(self);\n    uint256 totalSupply_ = IERC20(address(self.vault)).totalSupply();\n    if (equityValue_ == 0 || totalSupply_ == 0) return SAFE_MULTIPLIER;\n    return equityValue_ * SAFE_MULTIPLIER / totalSupply_;\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function pendingFee(GMXTypes.Store storage self) public view returns (uint256) {\n    uint256 totalSupply_ = IERC20(address(self.vault)).totalSupply();\n    uint256 _secondsFromLastCollection = block.timestamp - self.lastFeeCollected;\n    return (totalSupply_ * self.feePerSecond * _secondsFromLastCollection) / SAFE_MULTIPLIER;\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function valueToShares(\n    GMXTypes.Store storage self,\n    uint256 value,\n    uint256 currentEquity\n  ) public view returns (uint256) {\n    uint256 _sharesSupply = IERC20(address(self.vault)).totalSupply() + pendingFee(self);\n    if (_sharesSupply == 0 || currentEquity == 0) return value;\n    return value * _sharesSupply / currentEquity;\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function convertToUsdValue(\n    GMXTypes.Store storage self,\n    address token,\n    uint256 amt\n  ) public view returns (uint256) {\n    return amt * 10**(18 - IERC20Metadata(token).decimals())\n                * self.chainlinkOracle.consultIn18Decimals(token)\n                / SAFE_MULTIPLIER;\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function tokenWeights(GMXTypes.Store storage self) public view returns (uint256, uint256) {\n    // Get amounts of tokenA and tokenB in liquidity pool in token decimals\n    (uint256 _reserveA, uint256 _reserveB) = self.gmxOracle.getLpTokenReserves(\n      address(self.lpToken),\n      address(self.tokenA),\n      address(self.tokenA),\n      address(self.tokenB)\n    );\n\n    // Get value of tokenA and tokenB in 1e18\n    uint256 _tokenAValue = convertToUsdValue(self, address(self.tokenA), _reserveA);\n    uint256 _tokenBValue = convertToUsdValue(self, address(self.tokenB), _reserveB);\n\n    uint256 _totalLpValue = _tokenAValue + _tokenBValue;\n\n    return (\n      _tokenAValue * SAFE_MULTIPLIER / _totalLpValue,\n      _tokenBValue * SAFE_MULTIPLIER / _totalLpValue\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function assetValue(GMXTypes.Store storage self) public view returns (uint256) {\n    return lpAmt(self) * self.gmxOracle.getLpTokenValue(\n      address(self.lpToken),\n      address(self.tokenA),\n      address(self.tokenA),\n      address(self.tokenB),\n      false,\n      false\n    ) / SAFE_MULTIPLIER;\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function debtValue(GMXTypes.Store storage self) public view returns (uint256, uint256) {\n    (uint256 _tokenADebtAmt, uint256 _tokenBDebtAmt) = debtAmt(self);\n    return (\n      convertToUsdValue(self, address(self.tokenA), _tokenADebtAmt),\n      convertToUsdValue(self, address(self.tokenB), _tokenBDebtAmt)\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function equityValue(GMXTypes.Store storage self) public view returns (uint256) {\n    (uint256 _tokenADebtAmt, uint256 _tokenBDebtAmt) = debtAmt(self);\n\n    uint256 assetValue_ = assetValue(self);\n\n    uint256 _debtValue = convertToUsdValue(self, address(self.tokenA), _tokenADebtAmt)\n                         + convertToUsdValue(self, address(self.tokenB), _tokenBDebtAmt);\n\n    // in underflow condition return 0\n    unchecked {\n      if (assetValue_ < _debtValue) return 0;\n\n      return assetValue_ - _debtValue;\n    }\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function assetAmt(GMXTypes.Store storage self) public view returns (uint256, uint256) {\n    (uint256 _reserveA, uint256 _reserveB) = self.gmxOracle.getLpTokenReserves(\n      address(self.lpToken),\n      address(self.tokenA),\n      address(self.tokenA),\n      address(self.tokenB)\n    );\n\n    return (\n      _reserveA * SAFE_MULTIPLIER * lpAmt(self) / self.lpToken.totalSupply() / SAFE_MULTIPLIER,\n      _reserveB * SAFE_MULTIPLIER * lpAmt(self) / self.lpToken.totalSupply() / SAFE_MULTIPLIER\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function debtAmt(GMXTypes.Store storage self) public view returns (uint256, uint256) {\n    return (\n      self.tokenALendingVault.maxRepay(address(self.vault)),\n      self.tokenBLendingVault.maxRepay(address(self.vault))\n    );\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function lpAmt(GMXTypes.Store storage self) public view returns (uint256) {\n    return self.lpToken.balanceOf(address(self.vault));\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function leverage(GMXTypes.Store storage self) public view returns (uint256) {\n    if (assetValue(self) == 0 || equityValue(self) == 0) return 0;\n    return assetValue(self) * SAFE_MULTIPLIER / equityValue(self);\n  }\n\n  /**\n    * @notice @inheritdoc GMXVault\n    * @param self GMXTypes.Store\n  */\n  function delta(GMXTypes.Store storage self) public view returns (int256) {\n    (uint256 _tokenAAmt,) = assetAmt(self);\n    (uint256 _tokenADebtAmt,) = debtAmt(self);\n    uint256 equityValue_ = equityValue(self);\n\n    if (_tokenAAmt == 0 && _tokenADebtAmt == 0) ret"
    }
  ]
}