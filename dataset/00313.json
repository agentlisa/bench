{
  "Title": "M-6: _loadContext() uses the wrong pendingGlobal.",
  "Content": "# Issue M-6: _loadContext() uses the wrong pendingGlobal. \n\nSource: https://github.com/sherlock-audit/2024-02-perennial-v2-3-judging/issues/17 \n\n## Found by \nbin2chen\n## Summary\n`StrategyLib._loadContext()` is using the incorrect `pendingGlobal`, causing `currentPosition`, `minPosition`, and `maxPosition` to be incorrect, leading to incorrect rebalance operation.\n\n## Vulnerability Detail\nIn `StrategyLib._loadContext()`, there is a need to compute `currentPosition`, `minPosition`, and `maxPosition`. \nThe code  as follows:\n```solidity\n    function _loadContext(\n        Registration memory registration\n    ) private view returns (MarketStrategyContext memory marketContext) {\n...\n        // current position\n@>      Order memory pendingGlobal = registration.market.pendings(address(this));\n        marketContext.currentPosition = registration.market.position();\n        marketContext.currentPosition.update(pendingGlobal);\n        marketContext.minPosition = marketContext.currentAccountPosition.maker\n            .unsafeSub(marketContext.currentPosition.maker\n                .unsafeSub(marketContext.currentPosition.skew().abs()).min(marketContext.closable));\n        marketContext.maxPosition = marketContext.currentAccountPosition.maker\n            .add(marketContext.riskParameter.makerLimit.unsafeSub(marketContext.currentPosition.maker));\n    }\n```\n\nThe code above `pendingGlobal = registration.market.pendings(address(this));` is wrong\nIt takes the address(this)'s `pendingLocal`.\nThe correct approach is to use `pendingGlobal = registration.market.pending();`.\n\n## Impact\nSince `pendingGlobal` is wrong, `currentPosition`, `minPosition` and `maxPosition` are all wrong.\naffects subsequent rebalance calculations, such as `target.position` etc.\nrebalance does not work properly\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2024-02-perennial-v2-3/blob/main/perennial-v2/packages/perennial-vault/contracts/lib/StrategyLib.sol#L200\n## Tool used\n\nManual Review\n\n## Recommendation\n```diff\n    function _loadContext(\n        Registration memory registration\n    ) private view returns (MarketStrategyContext memory marketContext) {\n...\n        // current position\n-       Order memory pendingGlobal = registration.market.pendings(address(this));\n+       Order memory pendingGlobal = registration.market.pending();\n        marketContext.currentPosition = registration.market.position();\n        marketContext.currentPosition.update(pendingGlobal);\n        marketContext.minPosition = marketContext.currentAccountPosition.maker\n            .unsafeSub(marketContext.currentPosition.maker\n                .unsafeSub(marketContext.currentPosition.skew().abs()).min(marketContext.closable));\n        marketContext.maxPosition = marketContext.currentAccountPosition.maker\n            .add(marketContext.riskParameter.makerLimit.unsafeSub(marketContext.currentPosition.maker));\n    }\n```\n\n\n\n## Discussion\n\n**sherlock-admin4**\n\n2 comment(s) were left on this issue during the judging contest.\n\n**panprog** commented:\n> valid medium, it influences the rebalance process only in very rare edge cases\n\n**takarez** commented:\n>  the reason for it should have been said.\n\n\n\n**sherlock-admin4**\n\nThe protocol team fixed this issue in the following PRs/commits:\nhttps://github.com/equilibria-xyz/perennial-v2/pull/299\n\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/254",
  "Code": [
    {
      "filename": "perennial-v2/packages/perennial-vault/contracts/lib/StrategyLib.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { Fixed6, Fixed6Lib } from \"@equilibria/root/number/types/Fixed6.sol\";\nimport { UFixed6, UFixed6Lib } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport {\n    MarketParameter,\n    RiskParameter,\n    Local,\n    Global,\n    Position,\n    PositionLib,\n    Order,\n    OracleVersion\n} from \"@equilibria/perennial-v2/contracts/interfaces/IMarket.sol\";\nimport { Registration } from \"../types/Registration.sol\";\n\n/// @dev The context of an underlying market\nstruct MarketStrategyContext {\n    /// @dev Registration of the market\n    Registration registration;\n\n    /// @dev The market parameter set\n    MarketParameter marketParameter;\n\n    /// @dev The risk parameter set\n    RiskParameter riskParameter;\n\n    /// @dev The local state of the vault\n    Local local;\n\n    /// @dev The vault's current account position\n    Position currentAccountPosition;\n\n    /// @dev The vault's latest account position\n    Position latestAccountPosition;\n\n    /// @dev The current global position\n    Position currentPosition;\n\n    /// @dev The latest valid price\n    Fixed6 latestPrice;\n\n    /// @dev The margin requirement of the vault\n    UFixed6 margin;\n\n    /// @dev The current closable amount of the vault\n    UFixed6 closable;\n\n    // @dev minimum position size before crossing the net position\n    UFixed6 minPosition;\n\n    // @dev maximum position size before crossing the maker limit\n    UFixed6 maxPosition;\n}\n\nstruct Strategy {\n    UFixed6 totalMargin;\n\n    Fixed6 totalCollateral;\n\n    UFixed6 minAssets;\n\n    MarketStrategyContext[] marketContexts;\n}\nusing StrategyLib for Strategy global;\n\n/// @title Strategy\n/// @notice Logic for vault capital allocation\n/// @dev - Deploys collateral first to satisfy the margin of each market, then deploys the rest by weight.\n///      - Positions are then targeted based on the amount of collateral that ends up deployed to each market.\nlibrary StrategyLib {\n    error StrategyLibInsufficientCollateralError();\n    error StrategyLibInsufficientAssetsError();\n\n    /// @dev The maximum multiplier that is allowed for leverage\n    UFixed6 public constant LEVERAGE_BUFFER = UFixed6.wrap(1.2e6);\n\n    /// @dev The target allocation for a market\n    struct MarketTarget {\n        /// @dev The amount of change in collateral\n        Fixed6 collateral;\n\n        /// @dev The new position\n        UFixed6 position;\n    }\n\n    /// @notice Loads the strategy context of each of the underlying markets\n    /// @param registrations The registrations of the underlying markets\n    /// @return strategy The strategy contexts of the vault\n    function load(Registration[] memory registrations) internal view returns (Strategy memory strategy) {\n        strategy.marketContexts = new MarketStrategyContext[](registrations.length);\n        for (uint256 marketId; marketId < registrations.length; marketId++) {\n            strategy.marketContexts[marketId] = _loadContext(registrations[marketId]);\n            strategy.totalMargin = strategy.totalMargin.add(strategy.marketContexts[marketId].margin);\n            strategy.totalCollateral = strategy.totalCollateral.add(strategy.marketContexts[marketId].local.collateral);\n            strategy.minAssets = strategy.minAssets.max(\n                (registrations[marketId].leverage.isZero() || registrations[marketId].weight.isZero()) ?\n                    UFixed6Lib.ZERO : // skip if no leverage or weight\n                    strategy.marketContexts[marketId].minPosition\n                        .muldiv(strategy.marketContexts[marketId].latestPrice.abs(), registrations[marketId].leverage)\n                        .div(registrations[marketId].weight)\n            );\n        }\n    }\n\n    /// @notice Compute the target allocation for each market\n    /// @param strategy The strategy of the vault\n    /// @param deposit The amount of assets that are being deposited into the vault\n    /// @param withdrawal The amount of assets to make available for withdrawal\n    /// @param ineligable The amount of assets that are inapplicable for allocation\n    function allocate(\n        Strategy memory strategy,\n        UFixed6 deposit,\n        UFixed6 withdrawal,\n        UFixed6 ineligable\n    ) internal pure returns (MarketTarget[] memory targets) {\n        UFixed6 collateral = UFixed6Lib.unsafeFrom(strategy.totalCollateral).add(deposit).unsafeSub(withdrawal);\n        UFixed6 assets = collateral.unsafeSub(ineligable);\n\n        if (collateral.lt(strategy.totalMargin)) revert StrategyLibInsufficientCollateralError();\n        if (assets.lt(strategy.minAssets)) revert StrategyLibInsufficientAssetsError();\n\n        targets = new MarketTarget[](strategy.marketContexts.length);\n        UFixed6 totalMarketCollateral;\n        for (uint256 marketId; marketId < strategy.marketContexts.length; marketId++) {\n            UFixed6 marketCollateral;\n            (targets[marketId], marketCollateral) = _allocateMarket(\n                strategy.marketContexts[marketId],\n                strategy.totalMargin,\n                collateral,\n                assets\n            );\n            totalMarketCollateral = totalMarketCollateral.add(marketCollateral);\n        }\n\n        if (strategy.marketContexts.length != 0)\n            targets[0].collateral = targets[0].collateral.add(Fixed6Lib.from(collateral.sub(totalMarketCollateral)));\n    }\n\n    /// @notice Compute the target allocation for a market\n    /// @param marketContext The context of the market\n    /// @param totalMargin The total margin requirement of the vault\n    /// @param collateral The total amount of collateral of the vault\n    /// @param assets The total amount of collateral available for allocation\n    function _allocateMarket(\n        MarketStrategyContext memory marketContext,\n        UFixed6 totalMargin,\n        UFixed6 collateral,\n        UFixed6 assets\n    ) private pure returns (MarketTarget memory target, UFixed6 marketCollateral) {\n        marketCollateral = marketContext.margin\n            .add(collateral.sub(totalMargin).mul(marketContext.registration.weight));\n\n        UFixed6 marketAssets = assets\n            .mul(marketContext.registration.weight)\n            .min(marketCollateral.mul(LEVERAGE_BUFFER));\n\n        target.collateral = Fixed6Lib.from(marketCollateral).sub(marketContext.local.collateral);\n\n        UFixed6 minAssets = marketContext.riskParameter.minMargin\n            .unsafeDiv(marketContext.registration.leverage.mul(marketContext.riskParameter.maintenance));\n\n        if (marketContext.marketParameter.closed || marketAssets.lt(minAssets)) marketAssets = UFixed6Lib.ZERO;\n\n        target.position = marketAssets\n            .muldiv(marketContext.registration.leverage, marketContext.latestPrice.abs())\n            .max(marketContext.minPosition)\n            .min(marketContext.maxPosition);\n    }\n\n    /// @notice Load the context of a market\n    /// @param registration The registration of the market\n    /// @return marketContext The context of the market\n    function _loadContext(\n        Registration memory registration\n    ) private view returns (MarketStrategyContext memory marketContext) {\n        marketContext.registration = registration;\n        marketContext.marketParameter = registration.market.parameter();\n        marketContext.riskParameter = registration.market.riskParameter();\n        marketContext.local = registration.market.locals(address(this));\n        OracleVersion memory latestVersion = registration.market.oracle().latest();\n\n        marketContext.latestAccountPosition = registration.market.positions(address(this));\n        marketContext.currentAccountPosition = marketContext.latestAccountPosition.clone();\n\n        Order memory pendingLocal = registration.market.pendings(address(this));\n        marketContext.currentAccountPosition.update(pendingLocal);\n\n        marketContext.margin = PositionLib.margin(\n            marketContext.latestAccountPosition.magnitude().add(pendingLocal.pos()),\n            latestVersion,\n            marketContext.riskParameter\n        );\n        marketContext.latestPrice = latestVersion.price;\n\n        marketContext.closable = marketContext.latestAccountPosition.magnitude().sub(pendingLocal.neg());\n\n        // current position\n        Order memory pendingGlobal = registration.market.pendings(address(this));\n        marketContext.currentPosition = registration.market.position();\n        marketContext.currentPosition.update(pendingGlobal);\n        marketContext.minPosition = marketContext.currentAccountPosition.maker\n            .unsafeSub(marketContext.currentPosition.maker\n                .unsafeSub(marketContext.currentPosition.skew().abs()).min(marketContext.closable));\n        marketContext.maxPosition = marketContext.currentAccountPosition.maker\n            .add(marketContext.riskParameter.makerLimit.unsafeSub(marketContext.currentPosition.maker));\n    }\n}"
    }
  ]
}