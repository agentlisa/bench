{
  "Title": "[L-01] Conflicting values of ",
  "Content": "<h2 id=\"l-01-conflicting-values-of-base_divisor\" style=\"position:relative;\"><a href=\"#l-01-conflicting-values-of-base_divisor\" aria-label=\"l 01 conflicting values of base_divisor permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[L-01] Conflicting values of <code>BASE_DIVISOR</code></h2>\n<h3 id=\"line-references\" style=\"position:relative;\"><a href=\"#line-references\" aria-label=\"line references permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Line References</h3>\n<p><a href=\"https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityPool.sol#L20\">https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityPool.sol#L20</a></p>\n<p><a href=\"https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityProviders.sol#L27\">https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityProviders.sol#L27</a></p>\n<h3 id=\"description\" style=\"position:relative;\"><a href=\"#description\" aria-label=\"description permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Description</h3>\n<p><code>BASE_DIVISOR</code> is <code>10_000_000_000</code> in <code>LiquidityPool</code>, but <code>10**18</code> in <code>LiquidityProviders</code>. This can easily confuse 3rd parties integrating the token bridge.</p>\n<h3 id=\"recommended-mitigation-steps-23\" style=\"position:relative;\"><a href=\"#recommended-mitigation-steps-23\" aria-label=\"recommended mitigation steps 23 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recommended Mitigation Steps</h3>\n<p>Rename either variable. I recommend renaming the instance in <code>LiquidityPool</code> to <code>FEE_DIVISOR</code>.</p>\n",
  "Impact": "LOW",
  "Source": "https://code4rena.com/contests/2022-03-biconomy-hyphen-20-contest",
  "Code": [
    {
      "filename": "contracts/hyphen/LiquidityPool.sol",
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.0;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"./metatx/ERC2771ContextUpgradeable.sol\";\nimport \"../security/Pausable.sol\";\nimport \"./interfaces/IExecutorManager.sol\";\nimport \"./interfaces/ILiquidityProviders.sol\";\nimport \"../interfaces/IERC20Permit.sol\";\nimport \"./interfaces/ITokenManager.sol\";\n\ncontract LiquidityPool is ReentrancyGuardUpgradeable, Pausable, OwnableUpgradeable, ERC2771ContextUpgradeable {\n    address private constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    uint256 private constant BASE_DIVISOR = 10000000000; // Basis Points * 100 for better accuracy\n\n    uint256 public baseGas;\n\n    IExecutorManager private executorManager;\n    ITokenManager public tokenManager;\n    ILiquidityProviders public liquidityProviders;\n\n    struct PermitRequest {\n        uint256 nonce;\n        uint256 expiry;\n        bool allowed;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    mapping(bytes32 => bool) public processedHash;\n    mapping(address => uint256) public gasFeeAccumulatedByToken;\n\n    // Gas fee accumulated by token address => executor address\n    mapping(address => mapping(address => uint256)) public gasFeeAccumulated;\n\n    // Incentive Pool amount per token address\n    mapping(address => uint256) public incentivePool;\n\n    event AssetSent(\n        address indexed asset,\n        uint256 indexed amount,\n        uint256 indexed transferredAmount,\n        address target,\n        bytes depositHash,\n        uint256 fromChainId\n    );\n    event FeeDetails(uint256 indexed lpFee, uint256 indexed transferFee, uint256 indexed gasFee);\n    event Received(address indexed from, uint256 indexed amount);\n    event Deposit(\n        address indexed from,\n        address indexed tokenAddress,\n        address indexed receiver,\n        uint256 toChainId,\n        uint256 amount,\n        uint256 reward,\n        string tag\n    );\n    event GasFeeWithdraw(address indexed tokenAddress, address indexed owner, uint256 indexed amount);\n    event TrustedForwarderChanged(address indexed forwarderAddress);\n    event LiquidityProvidersChanged(address indexed liquidityProvidersAddress);\n    event EthReceived(address, uint256);\n\n    // MODIFIERS\n    modifier onlyExecutor() {\n        require(executorManager.getExecutorStatus(_msgSender()), \"Only executor is allowed\");\n        _;\n    }\n\n    modifier onlyLiquidityProviders() {\n        require(_msgSender() == address(liquidityProviders), \"Only liquidityProviders is allowed\");\n        _;\n    }\n\n    modifier tokenChecks(address tokenAddress) {\n        require(tokenAddress != address(0), \"Token address cannot be 0\");\n        require(tokenManager.getTokensInfo(tokenAddress).supportedToken, \"Token not supported\");\n        _;\n    }\n\n    function initialize(\n        address _executorManagerAddress,\n        address _pauser,\n        address _trustedForwarder,\n        address _tokenManager,\n        address _liquidityProviders\n    ) public initializer {\n        require(_executorManagerAddress != address(0), \"ExecutorManager cannot be 0x0\");\n        require(_trustedForwarder != address(0), \"TrustedForwarder cannot be 0x0\");\n        require(_liquidityProviders != address(0), \"LiquidityProviders cannot be 0x0\");\n        __ERC2771Context_init(_trustedForwarder);\n        __ReentrancyGuard_init();\n        __Ownable_init();\n        __Pausable_init(_pauser);\n        executorManager = IExecutorManager(_executorManagerAddress);\n        tokenManager = ITokenManager(_tokenManager);\n        liquidityProviders = ILiquidityProviders(_liquidityProviders);\n        baseGas = 21000;\n    }\n\n    function setTrustedForwarder(address trustedForwarder) public onlyOwner {\n        require(trustedForwarder != address(0), \"TrustedForwarder can't be 0\");\n        _trustedForwarder = trustedForwarder;\n        emit TrustedForwarderChanged(trustedForwarder);\n    }\n\n    function setLiquidityProviders(address _liquidityProviders) public onlyOwner {\n        require(_liquidityProviders != address(0), \"LiquidityProviders can't be 0\");\n        liquidityProviders = ILiquidityProviders(_liquidityProviders);\n        emit LiquidityProvidersChanged(_liquidityProviders);\n    }\n\n    function setBaseGas(uint128 gas) external onlyOwner {\n        baseGas = gas;\n    }\n\n    function getExecutorManager() public view returns (address) {\n        return address(executorManager);\n    }\n\n    function setExecutorManager(address _executorManagerAddress) external onlyOwner {\n        require(_executorManagerAddress != address(0), \"Executor Manager cannot be 0\");\n        executorManager = IExecutorManager(_executorManagerAddress);\n    }\n\n    function getCurrentLiquidity(address tokenAddress) public view returns (uint256 currentLiquidity) {\n        uint256 liquidityPoolBalance = liquidityProviders.getCurrentLiquidity(tokenAddress);\n        \n        currentLiquidity =\n            liquidityPoolBalance -\n            liquidityProviders.totalLPFees(tokenAddress) -\n            gasFeeAccumulatedByToken[tokenAddress] -\n            incentivePool[tokenAddress];\n    }\n\n    /**\n     * @dev Function used to deposit tokens into pool to initiate a cross chain token transfer.\n     * @param toChainId Chain id where funds needs to be transfered\n     * @param tokenAddress ERC20 Token address that needs to be transfered\n     * @param receiver Address on toChainId where tokens needs to be transfered\n     * @param amount Amount of token being transfered\n     */\n    function depositErc20(\n        uint256 toChainId,\n        address tokenAddress,\n        address receiver,\n        uint256 amount,\n        string memory tag\n    ) public tokenChecks(tokenAddress) whenNotPaused nonReentrant {\n        require(\n            tokenManager.getDepositConfig(toChainId, tokenAddress).min <= amount &&\n                tokenManager.getDepositConfig(toChainId, tokenAddress).max >= amount,\n            \"Deposit amount not in Cap limit\"\n        );\n        require(receiver != address(0), \"Receiver address cannot be 0\");\n        require(amount != 0, \"Amount cannot be 0\");\n        address sender = _msgSender();\n\n        uint256 rewardAmount = getRewardAmount(amount, tokenAddress);\n        if (rewardAmount != 0) {\n            incentivePool[tokenAddress] = incentivePool[tokenAddress] - rewardAmount;\n        }\n        liquidityProviders.increaseCurrentLiquidity(tokenAddress, amount);\n        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(tokenAddress), sender, address(this), amount);\n        // Emit (amount + reward amount) in event\n        emit Deposit(sender, tokenAddress, receiver, toChainId, amount + rewardAmount, rewardAmount, tag);\n    }\n\n    function getRewardAmount(uint256 amount, address tokenAddress) public view returns (uint256 rewardAmount) {\n        uint256 currentLiquidity = getCurrentLiquidity(tokenAddress);\n        uint256 providedLiquidity = liquidityProviders.getSuppliedLiquidityByToken(tokenAddress);\n        if (currentLiquidity < providedLiquidity) {\n            uint256 liquidityDifference = providedLiquidity - currentLiquidity;\n            if (amount >= liquidityDifference) {\n                rewardAmount = incentivePool[tokenAddress];\n            } else {\n                // Multiply by 10000000000 to avoid 0 reward amount for small amount and liquidity difference\n                rewardAmount = (amount * incentivePool[tokenAddress] * 10000000000) / liquidityDifference;\n                rewardAmount = rewardAmount / 10000000000;\n            }\n        }\n    }\n\n    /**\n     * DAI permit and Deposit.\n     */\n    function permitAndDepositErc20(\n        address tokenAddress,\n        address receiver,\n        uint256 amount,\n        uint256 toChainId,\n        PermitRequest calldata permitOptions,\n        string memory tag\n    ) external {\n        IERC20Permit(tokenAddress).permit(\n            _msgSender(),\n            address(this),\n            permitOptions.nonce,\n            permitOptions.expiry,\n            permitOptions.allowed,\n            permitOptions.v,\n            permitOptions.r,\n            permitOptions.s\n        );\n        depositErc20(toChainId, tokenAddress, receiver, amount, tag);\n    }\n\n    /**\n     * EIP2612 and Deposit.\n     */\n    function permitEIP2612AndDepositErc20(\n        address tokenAddress,\n        address receiver,\n        uint256 amount,\n        uint256 toChainId,\n        PermitRequest calldata permitOptions,\n        string memory tag\n    ) external {\n        IERC20Permit(tokenAddress).permit(\n            _msgSender(),\n            address(this),\n            amount,\n            permitOptions.expiry,\n            permitOptions.v,\n            permitOptions.r,\n            permitOptions.s\n        );\n        depositErc20(toChainId, tokenAddress, receiver, amount, tag);\n    }\n\n    /**\n     * @dev Function used to deposit native token into pool to initiate a cross chain token transfer.\n     * @param receiver Address on toChainId where tokens needs to be transfered\n     * @param toChainId Chain id where funds needs to be transfered\n     */\n    function depositNative(\n        address receiver,\n        uint256 toChainId,\n        string memory tag\n    ) external payable whenNotPaused nonReentrant {\n        require(\n            tokenManager.getDepositConfig(toChainId, NATIVE).min <= msg.value &&\n                tokenManager.getDepositConfig(toChainId, NATIVE).max >= msg.value,\n            \"Deposit amount not in Cap limit\"\n        );\n        require(receiver != address(0), \"Receiver address cannot be 0\");\n        require(msg.value != 0, \"Amount cannot be 0\");\n\n        uint256 rewardAmount = getRewardAmount(msg.value, NATIVE);\n        if (rewardAmount != 0) {\n            incentivePool[NATIVE] = incentivePool[NATIVE] - rewardAmount;\n        }\n        liquidityProviders.increaseCurrentLiquidity(NATIVE, msg.value);\n        emit Deposit(_msgSender(), NATIVE, receiver, toChainId, msg.value + rewardAmount, rewardAmount, tag);\n    }\n\n    function sendFundsToUser(\n        address tokenAddress,\n        uint256 amount,\n        address payable receiver,\n        bytes memory depositHash,\n        uint256 tokenGasPrice,\n        uint256 fromChainId\n    ) external nonReentrant onlyExecutor tokenChecks(tokenAddress) whenNotPaused {\n        uint256 initialGas = gasleft();\n        require(\n            tokenManager.getTransferConfig(tokenAddress).min <= amount &&\n                tokenManager.getTransferConfig(tokenAddress).max >= amount,\n            \"Withdraw amnt not in Cap limits\"\n        );\n        require(receiver != address(0), \"Bad receiver address\");\n\n        (bytes32 hashSendTransaction, bool status) = checkHashStatus(tokenAddress, amount, receiver, depositHash);\n\n        require(!status, \"Already Processed\");\n        processedHash[hashSendTransaction] = true;\n\n        uint256 amountToTransfer = getAmountToTransfer(initialGas, tokenAddress, amount, tokenGasPrice);\n        liquidityProviders.decreaseCurrentLiquidity(tokenAddress, amountToTransfer);\n\n        if (tokenAddress == NATIVE) {\n            require(address(this).balance >= amountToTransfer, \"Not Enough Balance\");\n            (bool success, ) = receiver.call{value: amountToTransfer}(\"\");\n            require(success, \"Native Transfer Failed\");\n        } else {\n            require(IERC20Upgradeable(tokenAddress).balanceOf(address(this)) >= amountToTransfer, \"Not Enough Balance\");\n            SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(tokenAddress), receiver, amountToTransfer);\n        }\n\n        emit AssetSent(tokenAddress, amount, amountToTransfer, receiver, depositHash, fromChainId);\n    }\n\n    /**\n     * @dev Internal function to calculate amount of token that needs to be transfered afetr deducting all required fees.\n     * Fee to be deducted includes gas fee, lp fee and incentive pool amount if needed.\n     * @param initialGas Gas provided initially before any calculations began\n     * @param tokenAddress Token address for which calculation needs to be done\n     * @param amount Amount of token to be transfered before deducting the fee\n     * @param tokenGasPrice Gas price in the token being transfered to be used to calculate gas fee\n     * @return amountToTransfer Total amount to be transfered after deducting all fees.\n     */\n    function getAmountToTransfer(\n        uint256 initialGas,\n        address tokenAddress,\n        uint256 amount,\n        uint256 tokenGasPrice\n    ) internal returns (uint256 amountToTransfer) {\n        uint256 transferFeePerc = getTransferFee(tokenAddress, amount);\n        uint256 lpFee;\n        if (transferFeePerc > tokenManager.getTokensInfo(tokenAddress).equilibriumFee) {\n            // Here add some fee to incentive pool also\n            lpFee = (amount * tokenManager.getTokensInfo(tokenAddress).equilibriumFee) / BASE_DIVISOR;\n            incentivePool[tokenAddress] =\n                (incentivePool[tokenAddress] +\n                    (amount * (transferFeePerc - tokenManager.getTokensInfo(tokenAddress).equilibriumFee))) /\n                BASE_DIVISOR;\n        } else {\n            lpFee = (amount * transferFeePerc) / BASE_DIVISOR;\n        }\n        uint256 transferFeeAmount = (amount * transferFeePerc) / BASE_DIVISOR;\n\n        liquidityProviders.addLPFee(tokenAddress, lpFee);\n\n        uint256 totalGasUsed = initialGas - gasleft();\n        totalGasUsed = totalGasUsed + tokenManager.getTokensInfo(tokenAddress).transferOverhead;\n        totalGasUsed = totalGasUsed + baseGas;\n\n        uint256 gasFee = totalGasUsed * tokenGasPrice;\n        gasFeeAccumulatedByToken[tokenAddress] = gasFeeAccumulatedByToken[tokenAddress] + gasFee;\n        gasFeeAccumulated[tokenAddress][_msgSender()] = gasFeeAccumulated[tokenAddress][_msgSender()] + gasFee;\n        amountToTransfer = amount - (transferFeeAmount + gasFee);\n\n        emit FeeDetails(lpFee, transferFeeAmount, gasFee);\n    }\n\n    function getTransferFee(address tokenAddress, uint256 amount) public view returns (uint256 fee) {\n        uint256 currentLiquidity = getCurrentLiquidity(tokenAddress);\n        uint256 providedLiquidity = liquidityProviders.getSuppliedLiquidityByToken(tokenAddress);\n\n        uint256 resultingLiquidity = currentLiquidity - amount;\n\n        uint256 equilibriumFee = tokenManager.getTokensInfo(tokenAddress).equilibriumFee;\n        uint256 maxFee = tokenManager.getTokensInfo(tokenAddress).maxFee;\n        // Fee is represented in basis points * 10 for better accuracy\n        uint256 numerator = providedLiquidity * equilibriumFee * maxFee; // F(max) * F(e) * L(e)\n        uint256 denominator = equilibriumFee * providedLiquidity + (maxFee - equilibriumFee) * resultingLiquidity; // F(e) * L(e) + (F(max) - F(e)) * L(r)\n\n        if (denominator == 0) {\n            fee = 0;\n        } else {\n            fee = numerator / denominator;\n        }\n    }\n\n    function checkHashStatus(\n        address tokenAddress,\n        uint256 amount,\n        address payable receiver,\n        bytes memory depositHash\n    ) public view returns (bytes32 hashSendTransaction, bool status) {\n        hashSendTransaction = keccak256(abi.encode(tokenAddress, amount, receiver, keccak256(depositHash)));\n\n        status = processedHash[hashSendTransaction];\n    }\n\n    function withdrawErc20GasFee(address tokenAddress) external onlyExecutor whenNotPaused nonReentrant {\n        require(tokenAddress != NATIVE, \"Can't withdraw native token fee\");\n        // uint256 gasFeeAccumulated = gasFeeAccumulatedByToken[tokenAddress];\n        uint256 _gasFeeAccumulated = gasFeeAccumulated[tokenAddress][_msgSender()];\n        require(_gasFeeAccumulated != 0, \"Gas Fee earned is 0\");\n        gasFeeAccumulatedByToken[tokenAddress] = gasFeeAccumulatedByToken[tokenAddress] - _gasFeeAccumulated;\n        gasFeeAccumulated[tokenAddress][_msgSender()] = 0;\n        SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(tokenAddress), _msgSender(), _gasFeeAccumulated);\n        emit GasFeeWithdraw(tokenAddress, _msgSender(), _gasFeeAccumulated);\n    }\n\n    function withdrawNativeGasFee() external onlyExecutor whenNotPaused nonReentrant {\n        uint256 _gasFeeAccumulated = gasFeeAccumulated[NATIVE][_msgSender()];\n        require(_gasFeeAccumulated != 0, \"Gas Fee earned is 0\");\n        gasFeeAccumulatedByToken[NATIVE] = gasFeeAccumulatedByToken[NATIVE] - _gasFeeAccumulated;\n        gasFeeAccumulated[NATIVE][_msgSender()] = 0;\n        (bool success, ) = payable(_msgSender()).call{value: _gasFeeAccumulated}(\"\");\n        require(success, \"Native Transfer Failed\");\n\n        emit GasFeeWithdraw(address(this), _msgSender(), _gasFeeAccumulated);\n    }\n\n    function transfer(\n        address _tokenAddress,\n        address receiver,\n        uint256 _tokenAmount\n    ) external whenNotPaused onlyLiquidityProviders nonReentrant {\n        require(receiver != address(0), \"Invalid receiver\");\n        if (_tokenAddress == NATIVE) {\n            require(address(this).balance >= _tokenAmount, \"ERR__INSUFFICIENT_BALANCE\");\n            (bool success, ) = receiver.call{value: _tokenAmount}(\"\");\n            require(success, \"ERR__NATIVE_TRANSFER_FAILED\");\n        } else {\n            IERC20Upgradeable baseToken = IERC20Upgradeable(_tokenAddress);\n            require(baseToken.balanceOf(address(this)) >= _tokenAmount, \"ERR__INSUFFICIENT_BALANCE\");\n            SafeERC20Upgradeable.safeTransfer(baseToken, receiver, _tokenAmount);\n        }\n    }\n\n    function _msgSender()\n        internal\n        view\n        virtual\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (address sender)\n    {\n        return ERC2771ContextUpgradeable._msgSender();\n    }\n\n    function _msgData()\n        internal\n        view\n        virtual\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (bytes calldata)\n    {\n        return ERC2771ContextUpgradeable._msgData();\n    }\n\n    receive() external payable {\n        emit EthReceived(_msgSender(), msg.value);\n    }\n}"
    },
    {
      "filename": "contracts/hyphen/LiquidityProviders.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"./metatx/ERC2771ContextUpgradeable.sol\";\n\nimport \"../security/Pausable.sol\";\nimport \"./interfaces/ILPToken.sol\";\nimport \"./interfaces/ITokenManager.sol\";\nimport \"./interfaces/IWhiteListPeriodManager.sol\";\nimport \"./interfaces/ILiquidityPool.sol\";\n\ncontract LiquidityProviders is\n    Initializable,\n    ReentrancyGuardUpgradeable,\n    ERC2771ContextUpgradeable,\n    OwnableUpgradeable,\n    Pausable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    address internal constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    uint256 public constant BASE_DIVISOR = 10**18;\n\n    ILPToken internal lpToken;\n    ILiquidityPool internal liquidityPool;\n    ITokenManager internal tokenManager;\n    IWhiteListPeriodManager internal whiteListPeriodManager;\n\n    event LiquidityAdded(address indexed tokenAddress, uint256 indexed amount, address indexed lp);\n    event LiquidityRemoved(address indexed tokenAddress, uint256 indexed amount, address indexed lp);\n    event FeeClaimed(address indexed tokenAddress, uint256 indexed fee, address indexed lp, uint256 sharesBurnt);\n    event FeeAdded(address indexed tokenAddress, uint256 indexed fee);\n    event EthReceived(address indexed sender, uint256 value);\n    event CurrentLiquidityChanged(address indexed token, uint256 indexed oldValue, uint256 indexed newValue);\n\n    // LP Fee Distribution\n    mapping(address => uint256) public totalReserve; // Include Liquidity + Fee accumulated\n    mapping(address => uint256) public totalLiquidity; // Include Liquidity only\n    mapping(address => uint256) public currentLiquidity; // Include current liquidity, updated on every in and out transfer\n    mapping(address => uint256) public totalLPFees;\n    mapping(address => uint256) public totalSharesMinted;\n\n    /**\n     * @dev Modifier for checking to validate a NFTId and it's ownership\n     * @param _tokenId token id to validate\n     * @param _transactor typically msgSender(), passed to verify against owner of _tokenId\n     */\n    modifier onlyValidLpToken(uint256 _tokenId, address _transactor) {\n        (address token, , ) = lpToken.tokenMetadata(_tokenId);\n        require(lpToken.exists(_tokenId), \"ERR__TOKEN_DOES_NOT_EXIST\");\n        require(lpToken.ownerOf(_tokenId) == _transactor, \"ERR__TRANSACTOR_DOES_NOT_OWN_NFT\");\n        _;\n    }\n\n    /**\n     * @dev Modifier for checking if msg.sender in liquiditypool\n     */\n    modifier onlyLiquidityPool() {\n        require(_msgSender() == address(liquidityPool), \"ERR__UNAUTHORIZED\");\n        _;\n    }\n\n    modifier tokenChecks(address tokenAddress) {\n        require(tokenAddress != address(0), \"Token address cannot be 0\");\n        require(_isSupportedToken(tokenAddress), \"Token not supported\");\n        _;\n    }\n\n    /**\n     * @dev initalizes the contract, acts as constructor\n     * @param _trustedForwarder address of trusted forwarder\n     */\n    function initialize(\n        address _trustedForwarder,\n        address _lpToken,\n        address _tokenManager,\n        address _pauser\n    ) public initializer {\n        __ERC2771Context_init(_trustedForwarder);\n        __Ownable_init();\n        __Pausable_init(_pauser);\n        __ReentrancyGuard_init();\n        _setLPToken(_lpToken);\n        _setTokenManager(_tokenManager);\n    }\n\n    function _isSupportedToken(address _token) internal view returns (bool) {\n        return tokenManager.getTokensInfo(_token).supportedToken;\n    }\n\n    function getTotalReserveByToken(address tokenAddress) public view returns (uint256) {\n        return totalReserve[tokenAddress];\n    }\n\n    function getSuppliedLiquidityByToken(address tokenAddress) public view returns (uint256) {\n        return totalLiquidity[tokenAddress];\n    }\n\n    function getTotalLPFeeByToken(address tokenAddress) public view returns (uint256) {\n        return totalLPFees[tokenAddress];\n    }\n\n    function getCurrentLiquidity(address tokenAddress) public view returns (uint256) {\n        return currentLiquidity[tokenAddress];\n    }\n\n    /**\n     * @dev To be called post initialization, used to set address of NFT Contract\n     * @param _lpToken address of lpToken\n     */\n    function setLpToken(address _lpToken) external onlyOwner {\n        _setLPToken(_lpToken);\n    }\n\n    /**\n     * Internal method to set LP token contract.\n     */\n    function _setLPToken(address _lpToken) internal {\n        lpToken = ILPToken(_lpToken);\n    }\n\n    function increaseCurrentLiquidity(address tokenAddress, uint256 amount) public onlyLiquidityPool {\n        _increaseCurrentLiquidity(tokenAddress, amount);\n    }\n\n    function decreaseCurrentLiquidity(address tokenAddress, uint256 amount) public onlyLiquidityPool {\n        _decreaseCurrentLiquidity(tokenAddress, amount);\n    }\n\n    function _increaseCurrentLiquidity(address tokenAddress, uint256 amount) private {\n        currentLiquidity[tokenAddress] += amount;\n        emit CurrentLiquidityChanged(tokenAddress, currentLiquidity[tokenAddress]-amount, currentLiquidity[tokenAddress]);\n    }\n\n    function _decreaseCurrentLiquidity(address tokenAddress, uint256 amount) private {\n        currentLiquidity[tokenAddress] -= amount;\n        emit CurrentLiquidityChanged(tokenAddress, currentLiquidity[tokenAddress]+amount, currentLiquidity[tokenAddress]);\n    }\n\n    /**\n     * Public method to set TokenManager contract.\n     */\n    function setTokenManager(address _tokenManager) external onlyOwner {\n        _setTokenManager(_tokenManager);\n    }\n\n    /**\n     * Internal method to set TokenManager contract.\n     */\n    function _setTokenManager(address _tokenManager) internal {\n        tokenManager = ITokenManager(_tokenManager);\n    }\n\n    /**\n     * @dev To be called post initialization, used to set address of WhiteListPeriodManager Contract\n     * @param _whiteListPeriodManager address of WhiteListPeriodManager\n     */\n    function setWhiteListPeriodManager(address _whiteListPeriodManager) external onlyOwner {\n        whiteListPeriodManager = IWhiteListPeriodManager(_whiteListPeriodManager);\n    }\n\n    /**\n     * @dev To be called post initialization, used to set address of LiquidityPool Contract\n     * @param _liquidityPool address of LiquidityPool\n     */\n    function setLiquidityPool(address _liquidityPool) external onlyOwner {\n        liquidityPool = ILiquidityPool(_liquidityPool);\n    }\n\n    /**\n     * @dev Returns price of Base token in terms of LP Shares\n     * @param _baseToken address of baseToken\n     * @return Price of Base token in terms of LP Shares\n     */\n    function getTokenPriceInLPShares(address _baseToken) public view returns (uint256) {\n        uint256 supply = totalSharesMinted[_baseToken];\n        if (supply > 0) {\n            return totalSharesMinted[_baseToken] / totalReserve[_baseToken];\n        }\n        return BASE_DIVISOR;\n    }\n\n    /**\n     * @dev Converts shares to token amount\n     */\n\n    function sharesToTokenAmount(uint256 _shares, address _tokenAddress) public view returns (uint256) {\n        return (_shares * totalReserve[_tokenAddress]) / totalSharesMinted[_tokenAddress];\n    }\n\n    /**\n     * @dev Returns the fee accumulated on a given NFT\n     * @param _nftId Id of NFT\n     * @return accumulated fee\n     */\n    function getFeeAccumulatedOnNft(uint256 _nftId) public view returns (uint256) {\n        require(lpToken.exists(_nftId), \"ERR__INVALID_NFT\");\n\n        (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);\n\n        if (totalNFTShares == 0) {\n            return 0;\n        }\n        // Calculate rewards accumulated\n        uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);\n        uint256 lpFeeAccumulated;\n\n        // Handle edge cases where eligibleLiquidity is less than what was supplied by very small amount \n        if(nftSuppliedLiquidity > eligibleLiquidity) {\n            lpFeeAccumulated = 0;\n        } else {\n            unchecked {\n                lpFeeAccumulated = eligibleLiquidity - nftSuppliedLiquidity;\n            }\n        }\n        return lpFeeAccumulated;\n    }\n\n    /**\n     * @dev Records fee being added to total reserve\n     * @param _token Address of Token for which LP fee is being added\n     * @param _amount Amount being added\n     */\n    function addLPFee(address _token, uint256 _amount) external onlyLiquidityPool tokenChecks(_token) whenNotPaused {\n        totalReserve[_token] += _amount;\n        totalLPFees[_token] += _amount;\n        emit FeeAdded(_token, _amount);\n    }\n\n    /**\n     * @dev Internal function to add liquidity to a new NFT\n     */\n    function _addLiquidity(address _token, uint256 _amount) internal {\n        require(_amount > 0, \"ERR__AMOUNT_IS_0\");\n        uint256 nftId = lpToken.mint(_msgSender());\n        LpTokenMetadata memory data = LpTokenMetadata(_token, 0, 0);\n        lpToken.updateTokenMetadata(nftId, data);\n        _increaseLiquidity(nftId, _amount);\n    }\n\n    /**\n     * @dev Function to mint a new NFT for a user, add native liquidity and store the\n     *      record in the newly minted NFT\n     */\n    function addNativeLiquidity() external payable nonReentrant tokenChecks(NATIVE) whenNotPaused {\n        (bool success, ) = address(liquidityPool).call{value: msg.value}(\"\");\n        require(success, \"ERR__NATIVE_TRANSFER_FAILED\");\n        _addLiquidity(NATIVE, msg.value);\n    }\n\n    /**\n     * @dev Function to mint a new NFT for a user, add token liquidity and store the\n     *      record in the newly minted NFT\n     * @param _token Address of token for which liquidity is to be added\n     * @param _amount Amount of liquidity added\n     */\n    function addTokenLiquidity(address _token, uint256 _amount)\n        external\n        nonReentrant\n        tokenChecks(_token)\n        whenNotPaused\n    {\n        require(_token != NATIVE, \"ERR__WRONG_FUNCTION\");\n        require(\n            IERC20Upgradeable(_token).allowance(_msgSender(), address(this)) >= _amount,\n            \"ERR__INSUFFICIENT_ALLOWANCE\"\n        );\n        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(_token), _msgSender(), address(liquidityPool), _amount);\n        _addLiquidity(_token, _amount);\n    }\n\n    /**\n     * @dev Internal helper function to increase liquidity in a given NFT\n     */\n    function _increaseLiquidity(uint256 _nftId, uint256 _amount) internal onlyValidLpToken(_nftId, _msgSender()) {\n        (address token, uint256 totalSuppliedLiquidity, uint256 totalShares) = lpToken.tokenMetadata(_nftId);\n\n        require(_amount > 0, \"ERR__AMOUNT_IS_0\");\n        whiteListPeriodManager.beforeLiquidityAddition(_msgSender(), token, _amount);\n\n        uint256 mintedSharesAmount;\n        // Adding liquidity in the pool for the first time\n        if (totalReserve[token] == 0) {\n            mintedSharesAmount = BASE_DIVISOR * _amount;\n        } else {\n            mintedSharesAmount = (_amount * totalSharesMinted[token]) / totalReserve[token];\n        }\n\n        require(mintedSharesAmount >= BASE_DIVISOR, \"ERR__AMOUNT_BELOW_MIN_LIQUIDITY\");\n\n        totalLiquidity[token] += _amount;\n        totalReserve[token] += _amount;\n        totalSharesMinted[token] += mintedSharesAmount;\n\n        LpTokenMetadata memory data = LpTokenMetadata(\n            token,\n            totalSuppliedLiquidity + _amount,\n            totalShares + mintedSharesAmount\n        );\n        lpToken.updateTokenMetadata(_nftId, data);\n\n        // Increase the current liquidity\n        _increaseCurrentLiquidity(token, _amount);\n        emit LiquidityAdded(token, _amount, _msgSender());\n    }\n\n    /**\n     * @dev Function to allow LPs to add ERC20 token liquidity to existing NFT\n     * @param _nftId ID of NFT for updating the balances\n     * @param _amount Token amount to be added\n     */\n    function increaseTokenLiquidity(uint256 _nftId, uint256 _amount) external nonReentrant whenNotPaused {\n        (address token, , ) = lpToken.tokenMetadata(_nftId);\n        require(_isSupportedToken(token), \"ERR__TOKEN_NOT_SUPPORTED\");\n        require(token != NATIVE, \"ERR__WRONG_FUNCTION\");\n        require(\n            IERC20Upgradeable(token).allowance(_msgSender(), address(this)) >= _amount,\n            \"ERR__INSUFFICIENT_ALLOWANCE\"\n        );\n        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(token), _msgSender(), address(liquidityPool), _amount);\n        _increaseLiquidity(_nftId, _amount);\n    }\n\n    /**\n     * @dev Function to allow LPs to add native token liquidity to existing NFT\n     */\n    function increaseNativeLiquidity(uint256 _nftId) external payable nonReentrant whenNotPaused {\n        (address token, , ) = lpToken.tokenMetadata(_nftId);\n        require(_isSupportedToken(NATIVE), \"ERR__TOKEN_NOT_SUPPORTED\");\n        require(token == NATIVE, \"ERR__WRONG_FUNCTION\");\n        (bool success, ) = address(liquidityPool).call{value: msg.value}(\"\");\n        require(success, \"ERR__NATIVE_TRANSFER_FAILED\");\n        _increaseLiquidity(_nftId, msg.value);\n    }\n\n    /**\n     * @dev Function to allow LPs to remove their liquidity from an existing NFT\n     *      Also automatically redeems any earned fee\n     */\n    function removeLiquidity(uint256 _nftId, uint256 _amount)\n        external\n        nonReentrant\n        onlyValidLpToken(_nftId, _msgSender())\n        whenNotPaused\n    {\n        (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);\n        require(_isSupportedToken(_tokenAddress), \"ERR__TOKEN_NOT_SUPPORTED\");\n\n        require(_amount != 0, \"ERR__INVALID_AMOUNT\");\n        require(nftSuppliedLiquidity >= _amount, \"ERR__INSUFFICIENT_LIQUIDITY\");\n        whiteListPeriodManager.beforeLiquidityRemoval(_msgSender(), _tokenAddress, _amount);\n        // Claculate how much shares represent input amount\n        uint256 lpSharesForInputAmount = _amount * getTokenPriceInLPShares(_tokenAddress);\n\n        // Calculate rewards accumulated\n        uint256 eligibleLiquidity = sharesToTokenAmount(t"
    }
  ]
}