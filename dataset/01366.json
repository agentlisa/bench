{
  "Title": "M-1: UUPSUpgradeable vulnerability in OpenZeppelin Contracts",
  "Content": "# Issue M-1: UUPSUpgradeable vulnerability in OpenZeppelin Contracts \n\nSource: https://github.com/sherlock-audit/2023-07-kyber-swap-judging/issues/25 \n\n## Found by \n0x52, MohammedRizwan\nUUPSUpgradeable vulnerability in OpenZeppelin Contracts\n\n## Vulnerability Detail\nOpenzeppelin has found the critical severity bug in UUPSUpgradeable. The kyber-swap contracts has used both openzeppelin contracts as well as  openzeppelin upgrabable  contracts with version v4.3.1. This is confirmed from package.json.\n\n```Solidity\nFile: ks-elastic-sc/package.json\n\n    \"@openzeppelin/contracts\": \"4.3.1\",\n    \"@openzeppelin/test-helpers\": \"0.5.6\",\n    \"@openzeppelin/contracts-upgradeable\": \"4.3.1\",\n```\n\nThe `UUPSUpgradeable` vulnerability has been found in openzeppelin version as follows,\n\n>>  @openzeppelin/contracts : Affected versions >= 4.1.0 < 4.3.2\n>>  @openzeppelin/contracts-upgradeable : >= 4.1.0 < 4.3.2\n\nHowever, openzeppelin has fixed this issue in versions 4.3.2\n\nOpenzeppelin bug acceptance and fix: [check here](https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-5vp3-v4hc-gx76)\n\nThe following contracts has been affected due to this vulnerability\n\n1) PoolOracle.sol\n2) TokenPositionDescriptor.sol\n\nBoth of these contracts are UUPSUpgradeable and the issue must be fixed.\n\n## Impact\nUpgradeable contracts using UUPSUpgradeable may be vulnerable to an attack affecting uninitialized implementation contracts.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-07-kyber-swap/blob/main/ks-elastic-sc/package.json#L35-L37\n\nhttps://github.com/sherlock-audit/2023-07-kyber-swap/blob/main/ks-elastic-sc/contracts/oracle/PoolOracle.sol#L19\n\nhttps://github.com/sherlock-audit/2023-07-kyber-swap/blob/main/ks-elastic-sc/contracts/periphery/TokenPositionDescriptor.sol#L13\n\n## Tool used\nManual Review\n\n## Recommendation\n1) Update the openzeppelin library to latest version.\n2) Check [this](https://forum.openzeppelin.com/t/security-advisory-initialize-uups-implementation-contracts/15301) openzeppelin security advisory to initialize the UUPS implementation contracts.\n3) Check [this](https://docs.openzeppelin.com/contracts/4.x/api/proxy) openzeppelin UUPS documentation.\n\n\n\n## Discussion\n\n**sherlock-admin**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**Trumpero** commented:\n> valid medium about OZ upgradable 4.3.1\n\n\n\n**manhlx3006**\n\n**Sponsor Confirmed**\n\n- The finding is valid and a known issue (we have initialized all Pool Oracle for deployed contracts and transferred ownership to a multisig). The UUPSUpgradable has a vulnerability with the version we used. If the implementation is not initialized, someone can initialize and try to destroy the implementation.\n- For deployed contracts: We have initialized all implementation of deployed contracts and currently our multisig is the owner of all, thus, for the current deployed contracts, the issue won’t happen.\n- For the future deployment: we will move to the new OZ version 4.3.2.\n\n\n**nevillehuang**\n\nEscalate\n\nThis should be low severity and invalid according to sherlock rules. This comes down to admin deployment errors where admin deploying PoolOracle contract fails to initialize contracts, which kyberswap admins have already done and in fact are aware of this issue.\n\nIt really only affects future deployments, but given kyberswap are moving towards 4.3.2, and no other contracts are going to be deployed with this version of OZ 4.3.1, this is a non-issue as there is no existing risk to the protocol, unless the admin makes an error and mistakenly deploy new contracts with this versions.\n\n**sherlock-admin2**\n\n > Escalate\n> \n> This should be low severity and invalid according to sherlock rules. This comes down to admin deployment errors where admin deploying PoolOracle contract fails to initialize contracts, which kyberswap admins have already done and in fact are aware of this issue.\n> \n> It really only affects future deployments, but given kyberswap are moving towards 4.3.2, and no other contracts are going to be deployed with this version of OZ 4.3.1, this is a non-issue as there is no existing risk to the protocol, unless the admin makes an error and mistakenly deploy new contracts with this versions.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**jkoppel**\n\nEscalate\n\nThis is out of scope. This is at best a flaw in package.json, which is not in scope. The rules about vulns in libraries were changed *during the judging period* and should not apply to this contest.\n\nFurther, Sherlock has in the past ruled it invalid when there is an issue in the code that the protocol team has already fixed by a deployment strategy. https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/146/#issuecomment-1475484578\n\n**sherlock-admin2**\n\n > Escalate\n> \n> This is out of scope. This is at best a flaw in package.json, which is not in scope. The rules about vulns in libraries were changed *during the judging period* and should not apply to this contest.\n> \n> Further, Sherlock has in the past ruled it invalid when there is an issue in the code that the protocol team has already fixed by a deployment strategy. https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/146/#issuecomment-1475484578\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**jingyi2811**\n\nEscalate\n\ni don't agree with both escalations.\n\n[UUPSUpgradeable vulnerability in OpenZeppelin Contracts](https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-5vp3-v4hc-gx76) is a critical vulnerability per the openzeppelin which was found in 2021 and to be noted this was the only second critical issue found till date in openzeppelin library. `If the implementation is not initialized, someone can initialize and try to destroy the implementation` which i agree with the sponsor comment here.\n\nIt should be noted here that [TokenPositionDescriptor.sol](https://github.com/sherlock-audit/2023-07-kyber-swap/blob/e0cb622e7dacf4e8603507f3ea1c1073f9445dbe/ks-elastic-sc/contracts/periphery/TokenPositionDescriptor.sol#L13) as well as [PoolOracle.sol](https://github.com/sherlock-audit/2023-07-kyber-swap/blob/e0cb622e7dacf4e8603507f3ea1c1073f9445dbe/ks-elastic-sc/contracts/oracle/PoolOracle.sol#L19) is affected from this issue. `TokenPositionDescriptor.sol` is also in scope contract. As sponsor confirmed the issue with reasoning and judge reasoning for this issue confirmation too, This is absolutely a valid issue. Below is the additioanal context for raised escalations.\n\nIssues found in used library dependencies has been judged as Medium at sherlock in past irrespective of new judging guidlines. Below are few issues for references,\n\n1) Harpie audit, check  [Issue M-6: Signature malleability not protected against](https://audits.sherlock.xyz/contests/3/report)---Similar openzeppelin library bug issue judged as Medium, However the library issue was High severity and here it is critical severity.\n\n2) UXD audit, check [FullMath library overflow issue](https://github.com/sherlock-audit/2023-01-uxd-judging/issues/273)----library issue taken from uniswap\n\n3) Bond audit, check [Solmate code size issue](https://github.com/sherlock-audit/2022-11-bond-judging/issues/8)-----solmate library token code size issue judged as Medium\n\n4) I wouldn't had added this reference but i think it should be as the escalations focuses on rules and past issues. Check this [issue](https://github.com/sherlock-audit/2023-03-teller-judging/issues/328). The issue is different but the escalation decision revolves around the used library where the Sherlock team reasoning for escalation rejection was  \n> The library is used in the in-scope contract and the error impacts an in-scope contract. This is a valid issue.\n\nTo be noted, all these issues were happened before July, 2023 and the new rules made significant judging changes after July, 2023.(This was not intended to add but to respond a escalation, It was necessary to add for reference purpose only)\n\nPer the sherlock rules too, This finding is valid and Sherlock rules states,\n\n> In case the vulnerability exists in a library and an in-scope contract uses it and is affected by this bug this is a valid issue.\n\nSherlock docs reference [here](https://docs.sherlock.xyz/audits/judging/judging)\n\nContest readme.md also dont have this as known issue even the previous audits done by kyberSwap team does not highlight this critical issue too. I believe this issue is correctly judged by the lead judge and it's good that this issue is being found at sherlock which was missed in previous audits.\n\nI hope, the above explanation is good enough for the validation of this issue. \n\nThank you!\n\n**sherlock-admin2**\n\n > Escalate\n> \n> i don't agree with both escalations.\n> \n> [UUPSUpgradeable vulnerability in OpenZeppelin Contracts](https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-5vp3-v4hc-gx76) is a critical vulnerability per the openzeppelin which was found in 2021 and to be noted this was the only second critical issue found till date in openzeppelin library. `If the implementation is not initialized, someone can initialize and try to destroy the implementation` which i agree with the sponsor comment here.\n> \n> It should be noted here that [TokenPositionDescriptor.sol](https://github.com/sherlock-audit/2023-07-kyber-swap/blob/e0cb622e7dacf4e8603507f3ea1c1073f9445dbe/ks-elastic-sc/contracts/periphery/TokenPositionDescriptor.sol#L13) as well as [PoolOracle.sol](https://github.com/sherlock-audit/2023-07-kyber-swap/blob/e0cb622e7dacf4e8603507f3ea1c1073f9445dbe/ks-elastic-sc/contracts/oracle/PoolOracle.sol#L19) is affected from this issue. `TokenPositionDescriptor.sol` is also in scope contract. As sponsor confirmed the issue with reasoning and judge reasoning for this issue confirmation too, This is absolutely a valid issue. Below is the additioanal context for raised escalations.\n> \n> Issues found in used library dependencies has been judged as Medium at sherlock in past irrespective of new judging guidlines. Below are few issues for references,\n> \n> 1) Harpie audit, check  [Issue M-6: Signature malleability not protected against](https://audits.sherlock.xyz/contests/3/report)---Similar openzeppelin library bug issue judged as Medium, However the library issue was High severity and here it is critical severity.\n> \n> 2) UXD audit, check [FullMath library overflow issue](https://github.com/sherlock-audit/2023-01-uxd-judging/issues/273)----library issue taken from uniswap\n> \n> 3) Bond audit, check [Solmate code size issue](https://github.com/sherlock-audit/2022-11-bond-judging/issues/8)-----solmate library token code size issue judged as Medium\n> \n> 4) I wouldn't had added this reference but i think it should be as the escalations focuses on rules and past issues. Check this [issue](https://github.com/sherlock-audit/2023-03-teller-judging/issues/328). The issue is different but the escalation decision revolves around the used library where the Sherlock team reasoning for escalation rejection was  \n> > The library is used in the in-scope contract and the error impacts an in-scope contract. This is a valid issue.\n> \n> To be noted, all these issues were happened before July, 2023 and the new rules made significant judging changes after July, 2023.(This was not intended to add but to respond a escalation, It was necessary to add for reference purpose only)\n> \n> Per the sherlock rules too, This finding is valid and Sherlock rules states,\n> \n> > In case the vulnerability exists in a library and an in-scope contract uses it and is affected by this bug this is a valid issue.\n> \n> Sherlock docs reference [here](https://docs.sherlock.xyz/audits/judging/judging)\n> \n> Contest readme.md also dont have this as known issue even the previous audits done by kyberSwap team does not highlight this critical issue too. I believe this issue is correctly judged by the lead judge and it's good that this issue is being found at sherlock which was missed in previous audits.\n> \n> I hope, the above explanation is good enough for the validation of this issue. \n> \n> Thank you!\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**jkoppel**\n\n@jingyi2811 The part of the Sherlock rules you cite was added just 9 days ago. https://discord.com/channels/812037309376495636/1087792569196486706/1151162792074813592\n\n**nevillehuang**\n\n> Escalate\n> \n> i don't agree with both escalations.\n> \n> [UUPSUpgradeable vulnerability in OpenZeppelin Contracts](https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-5vp3-v4hc-gx76) is a critical vulnerability per the openzeppelin which was found in 2021 and to be noted this was the only second critical issue found till date in openzeppelin library. `If the implementation is not initialized, someone can initialize and try to destroy the implementation` which i agree with the sponsor comment here.\n> \n> It should be noted here that [TokenPositionDescriptor.sol](https://github.com/sherlock-audit/2023-07-kyber-swap/blob/e0cb622e7dacf4e8603507f3ea1c1073f9445dbe/ks-elastic-sc/contracts/periphery/TokenPositionDescriptor.sol#L13) as well as [PoolOracle.sol](https://github.com/sherlock-audit/2023-07-kyber-swap/blob/e0cb622e7dacf4e8603507f3ea1c1073f9445dbe/ks-elastic-sc/contracts/oracle/PoolOracle.sol#L19) is affected from this issue. `TokenPositionDescriptor.sol` is also in scope contract. As sponsor confirmed the issue with reasoning and judge reasoning for this issue confirmation too, This is absolutely a valid issue. Below is the additioanal context for raised escalations.\n> \n> Issues found in used library dependencies has been judged as Medium at sherlock in past irrespective of new judging guidlines. Below are few issues for references,\n> \n> 1. Harpie audit, check  [Issue M-6: Signature malleability not protected against](https://audits.sherlock.xyz/contests/3/report)---Similar openzeppelin library bug issue judged as Medium, However the library issue was High severity and here it is critical severity.\n> 2. UXD audit, check [FullMath library overflow issue](https://github.com/sherlock-audit/2023-01-uxd-judging/issues/273)----library issue taken from uniswap\n> 3. Bond audit, check [Solmate code size issue](https://github.com/sherlock-audit/2022-11-bond-judging/issues/8)-----solmate library token code size issue judged as Medium\n> 4. I wouldn't had added this reference but i think it should be as the escalations focuses on rules and past issues. Check this [issue](https://github.com/sherlock-audit/2023-03-teller-judging/issues/328). The issue is different but the escalation decision revolves around the used library where the Sherlock team reasoning for escalation rejection was\n> \n> > The library is used in the in-scope contract and the error impacts an in-scope contract. This is a valid issue.\n> \n> To be noted, all these issues were happened before July, 2023 and the new rules made significant judging changes after July, 2023.(This was not intended to add but to respond a escalation, It was necessary to add for reference purpose only)\n> \n> Per the sherlock rules too, This finding is valid and Sherlock rules states,\n> \n> > In case the vulnerability exists in a library and an in-scope contract uses it and is affected by this bug this is a valid issue.\n> \n> Sherlock docs reference [here](https://docs.sherlock.xyz/audits/judging/judging)\n> \n> Contest readme.md also dont have this as known issue even the previous audits done by kyberSwap team does not highlight this critical issue too. I believe this issue is correctly judged by the lead judge and it's good that this issue is being found at sherlock which was missed in previous audits.\n> \n> I hope, the above explanation is good enough for the validation of this issue.\n> \n> Thank you!\n\nSure it is valid in sponsors eyes and yes it is not made a known issue. The point here is it falls under admin error, and thus is invalid according to sherlocks rule [here](https://docs.sherlock.xyz/audits/judging/judging#vii.-list-of-issue-categories-that-are-not-considered-valid). There is no existing risks, and if there is, it revolves around future deployment errors by the admin, where historically admin errors has not been accepted as valid issues.\n\nOn top of that, all the issues u quoted involves user facing functions, whereas this issue revolves admin facing functions. This is in addition to the fact that there will never be another `initialize()` function with OZ 4.3.1 for a user to call for either contracts. Will let @hrishibhat decide on this one.\n\n**jingyi2811**\n\nIf a suggestion made in the in-scope file fix the problem, I would say this is a valid issue. Kindly read 0x52 duplicate issue of this.\n\n**mohammedrizwann123**\n\n> > Escalate\n> > i don't agree with both escalations.\n> > [UUPSUpgradeable vulnerability in OpenZeppelin Contracts](https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-5vp3-v4hc-gx76) is a critical vulnerability per the openzeppelin which was found in 2021 and to be noted this was the only second critical issue found till date in openzeppelin library. `If the implementation is not initialized, someone can initialize and try to destroy the implementation` which i agree with the sponsor comment here.\n> > It should be noted here that [TokenPositionDescriptor.sol](https://github.com/sherlock-audit/2023-07-kyber-swap/blob/e0cb622e7dacf4e8603507f3ea1c1073f9445dbe/ks-elastic-sc/contracts/periphery/TokenPositionDescriptor.sol#L13) as well as [PoolOracle.sol](https://github.com/sherlock-audit/2023-07-kyber-swap/blob/e0cb622e7dacf4e8603507f3ea1c1073f9445dbe/ks-elastic-sc/contracts/oracle/PoolOracle.sol#L19) is affected from this issue. `TokenPositionDescriptor.sol` is also in scope contract. As sponsor confirmed the issue with reasoning and judge reasoning for this issue confirmation too, This is absolutely a valid issue. Below is the additioanal context for raised escalations.\n> > Issues found in used library dependencies has been judged as Medium at sherlock in past irrespective of new judging guidlines. Below are few issues for references,\n> > \n> > 1. Harpie audit, check  [Issue M-6: Signature malleability not protected against](https://audits.sherlock.xyz/contests/3/report)---Similar openzeppelin library bug issue judged as Medium, However the library issue was High severity and here it is critical severity.\n> > 2. UXD audit, check [FullMath library overflow issue](https://github.com/sherlock-audit/2023-01-uxd-judging/issues/273)----library issue taken from uniswap\n> > 3. Bond audit, check [Solmate code size issue](https://github.com/sherlock-audit/2022-11-bond-judging/issues/8)-----solmate library token code size issue judged as Medium\n> > 4. I wouldn't had added this reference but i think it should be as the escalations focuses on rules and past issues. Check this [issue](https://github.com/sherlock-audit/2023-03-teller-judging/issues/328). The issue is different but the escalation decision revolves around the used library where the Sherlock team reasoning for escalation rejection was\n> > \n> > > The library is used in the in-scope contract and the error impacts an in-scope contract. This is a valid issue.\n> > \n> > \n> > To be noted, all these issues were happened before July, 2023 and the new rules made significant judging changes after July, 2023.(This was not intended to add but to respond a escalation, It was necessary to add for reference purpose only)\n> > Per the sherlock rules too, This finding is valid and Sherlock rules states,\n> > > In case the vulnerability exists in a library and an in-scope contract uses it and is affected by this bug this is a valid issue.\n> > \n> > \n> > Sherlock docs reference [here](https://docs.sherlock.xyz/audits/judging/judging)\n> > Contest readme.md also dont have this as known issue even the previous audits done by kyberSwap team does not highlight this critical issue too. I believe this issue is correctly judged by the lead judge and it's good that this issue is being found at sherlock which was missed in previous audits.\n> > I hope, the above explanation is good enough for the validation of this issue.\n> > Thank you!\n> \n> You've created a valid escalation!\n> \n> To remove the escalation from consideration: Delete your comment.\n> \n> You may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\nI agree with @jingyi2811 escalation and the issue is correcty judged and it is valid.\n\n@jkoppel Per the escalation, it is clearly explained the issues judement of such libraries issue have been judged as Medium in past irrespective of new juding guidlines. quoting the link shared by you [here](https://discord.com/channels/812037309376495636/1087792569196486706/1151162792074813592). sherlock team informs about the documentation updates. This announcement by sherlock team does not mention that the new rules wont be applicable to the contest happened before the rules announcement. Its a documentation update which ofcourse help in judging the contest. Please do check the point 4 in @jingyi2811 escalation.\n\n@nevillehuang Thanks for agreeing on some points. Please note the issue arises from the openzeppelin library. Having a critical issue in dependency library is not an admin fault. This can not be considered as an admin error since the admin who is nothing but protocol team has been made aware of this critical issue via sherlock audit reports. If i am correct, the contracts were being audited two times in past and this issue was not raised in any audit report. The sponsor is confirming the issue with the reasoning and the lead judge is also confirming it. I believe the issue is valid. However, Let it be decided by sherlock team and lead judge.\n\n**jkoppel**\n\n@mohammedrizwann123  Can you give an explanation for why this issue should be judged differently from the Blueberry issue I cited?\n\n**Trumpero**\n\nI believe this issue should be considered a valid medium. It isn't obligatory for the admin to initialize the PoolOracle contract after deploying it if the correct version of OZ was utilized. It's a fact that KyberSwap didn't initialize their PoolOracle contracts until this bug was spotted recently before the contest, and they will move to OZ 4.3.2 for the future deployments. However, the protocol team didn't identify this issue as a known issue in the contest docs, so this issue should be valid according to Sherlock rules. \n\nAdditionally, this issue is truly in-scope since the PoolOracle contract inherits the UUPSUpgradeable contract version 4.3.1; it's not similar to using a library. The entire vulnerability exists in the PoolOracle contract, which can be exploited by an attacker.\n\n**jkoppel**\n\n> It's a fact that KyberSwap didn't initialize their PoolOracle contracts until this bug was spotted recently before the contest\n\nLink to transaction or discussion please?\n\nI am still seeing nothing to differentiate this from the Blueberry issue I cited.\n\n**nevillehuang**\n\nThis finding was reported by the OZ team in september of 2021 here:\n\nhttps://forum.openzeppelin.com/t/security-advisory-initialize-uups-implementation-contracts/15301\n\nPretty sure its not “recent”, unless kyberswap intended to mistakenly leave the bug there for 2 years\n\n\n**hrishibhat**\n\nTo address the @jkoppel's comments on blueberry the context of that issue does not apply here:\nThat issue involved a Mockup contract and Sponsor had an unusual implementation mechanism that was already in place. That issue was discussed extensively with the Lead Watson and resolved. On the blueberry decision, there are strong arguments for both sides. But the factors of that decision do not apply here given the Mockup library. \n\nAs pointed out by the above escalation from @jingyi2811 historically using vulnerable external libraries is a valid issue. Especially for the external libraries that have a known bug in them.\nAnd the update of the library-related rule in the rulebook will not impact the decision here as they have always been rewarded. Also the update was intended to address cases like [these](https://github.com/sherlock-audit/2023-03-teller-judging/issues/328). Will add more clarity on the same. \n\nThis is not an admin error. To simplify an admin error is using an incorrect parameter that causes loss because admin is expected to input the right parameter that is supposed to behave as expected. \nIn this case, admin expects the the external library to work correctly. \n\nHence agree with the Lead Judge and escalations that consider this a valid issue. \n\n**hrishibhat**\n\nResult:\nMedium\nHas duplicates\nConsidering this issue a valid medium based on the above comment.\n\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [jingyi2811](https://github.com/sherlock-audit/2023-07-kyber-swap-judging/issues/25/#issuecomment-1730719530): accepted\n- [nevillehuang](https://github.com/sherlock-audit/2023-07-kyber-swap-judging/issues/25/#issuecomment-1728122392): rejected\n- [jkoppel](https://github.com/sherlock-audit/2023-07-kyber-swap-judging/issues/25/#issuecomment-1728144121): rejected\n\n",
  "Impact": "MEDIUM",
  "Source": "https://app.sherlock.xyz/audits/contests/103",
  "Code": [
    {
      "filename": "ks-elastic-sc/package.json",
      "content": "{\n  \"name\": \"kyberswap-v2\",\n  \"version\": \"1.0.0\",\n  \"description\": \"This repository contains the contracts for the KyberSwap v2\",\n  \"main\": \"hardhat.config.ts\",\n  \"directories\": {\n    \"test\": \"test\"\n  },\n  \"scripts\": {\n    \"test\": \"TS_NODE_TRANSPILE_ONLY=1 yarn hardhat test --no-compile\",\n    \"t\": \"UPDATE_SNAPSHOT=1 TS_NODE_TRANSPILE_ONLY=1 yarn hardhat test --no-compile\",\n    \"compile\": \"TS_NODE_TRANSPILE_ONLY=1 yarn hardhat compile\",\n    \"c\": \"printf 'yes' | yarn hardhat compile\",\n    \"coverage\": \"hardhat coverage\",\n    \"prettier\": \"prettier --write\",\n    \"prettierAll\": \"prettier --write contracts/* && prettier --write test/**/*.ts\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/KyberNetwork/pro-amm.git\"\n  },\n  \"author\": \"Kyber SC Team\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/KyberNetwork/pro-amm/issues\"\n  },\n  \"dependencies\": {\n    \"dotenv\": \"8.2.0\",\n    \"solhint\": \"3.3.2\"\n  },\n  \"devDependencies\": {\n    \"@nomiclabs/hardhat-ethers\": \"2.0.2\",\n    \"@nomiclabs/hardhat-etherscan\": \"3.0.0\",\n    \"@nomiclabs/hardhat-waffle\": \"2.0.1\",\n    \"@openzeppelin/contracts\": \"4.3.1\",\n    \"@openzeppelin/test-helpers\": \"0.5.6\",\n    \"@openzeppelin/contracts-upgradeable\": \"4.3.1\",\n    \"@openzeppelin/hardhat-upgrades\": \"^1.18.1\",\n    \"@typechain/ethers-v5\": \"6.0.5\",\n    \"@types/chai\": \"4.2.16\",\n    \"@types/mocha\": \"8.2.2\",\n    \"@types/node\": \"14.14.37\",\n    \"chai\": \"^4.3.4\",\n    \"chai-as-promised\": \"7.1.1\",\n    \"chai-bn\": \"0.2.2\",\n    \"decimal.js\": \"^10.3.1\",\n    \"ethereum-waffle\": \"3.3.0\",\n    \"ethers\": \"5.6.1\",\n    \"hardhat\": \"2.8.0-dev.0\",\n    \"hardhat-contract-sizer\": \"^2.0.3\",\n    \"hardhat-gas-reporter\": \"1.0.4\",\n    \"hardhat-typechain\": \"0.3.5\",\n    \"mocha-chai-jest-snapshot\": \"^1.1.3\",\n    \"prettier\": \"2.4.1\",\n    \"prettier-plugin-solidity\": \"1.0.0-beta.14\",\n    \"solidity-coverage\": \"0.7.16\",\n    \"ts-generator\": \"0.1.1\",\n    \"ts-node\": \"9.1.1\",\n    \"typechain\": \"4.0.3\",\n    \"typescript\": \"4.2.4\"\n  }\n}"
    },
    {
      "filename": "ks-elastic-sc/contracts/oracle/PoolOracle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport {IERC20Upgradeable} from '@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol';\nimport {SafeERC20Upgradeable} from '@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol';\n\nimport {Initializable} from '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport {UUPSUpgradeable} from '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\nimport {OwnableUpgradeable} from '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\n\nimport {IPoolOracle} from './../interfaces/oracle/IPoolOracle.sol';\nimport {IPoolStorage} from './../interfaces/pool/IPoolStorage.sol';\nimport {Oracle} from './../libraries/Oracle.sol';\n\n/// @title KyberSwap v2 Pool Oracle\ncontract PoolOracle is\n  IPoolOracle,\n  Initializable,\n  UUPSUpgradeable,\n  OwnableUpgradeable\n{\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using Oracle for Oracle.Observation[65535];\n\n  struct ObservationData {\n    bool initialized;\n    // the most-recently updated index of the observations array\n    uint16 index;\n    // the current maximum number of observations that are being stored\n    uint16 cardinality;\n    // the next maximum number of observations to store, triggered in observations.write\n    uint16 cardinalityNext;\n  }\n\n  mapping(address => Oracle.Observation[65535]) internal poolOracle;\n  mapping(address => ObservationData) internal poolObservation;\n\n  function initialize() public initializer {\n    __Ownable_init();\n  }\n\n  function _authorizeUpgrade(address) internal override onlyOwner {}\n\n  /// @notice Owner's function to rescue any funds stuck in the contract.\n  function rescueFund(address token, uint256 amount) external onlyOwner {\n    if (token == address(0)) {\n      (bool success, ) = payable(owner()).call{value: amount}('');\n      require(success, \"failed to collect native\");\n    } else {\n      IERC20Upgradeable(token).safeTransfer(owner(), amount);\n    }\n    emit OwnerWithdrew(owner(), token, amount);\n  }\n\n  /// @inheritdoc IPoolOracle\n  function initializeOracle(uint32 time)\n    external override\n    returns (uint16 cardinality, uint16 cardinalityNext)\n  {\n    (cardinality, cardinalityNext) = poolOracle[msg.sender].initialize(time);\n    poolObservation[msg.sender] = ObservationData({\n      initialized: true,\n      index: 0,\n      cardinality: cardinality,\n      cardinalityNext: cardinalityNext\n    });\n  }\n\n  /// @inheritdoc IPoolOracle\n  function write(\n    uint32 blockTimestamp,\n    int24 tick,\n    uint128 liquidity\n  )\n    external override\n    returns (uint16 indexUpdated, uint16 cardinalityUpdated)\n  {\n    return writeNewEntry(\n      poolObservation[msg.sender].index,\n      blockTimestamp,\n      tick,\n      liquidity,\n      poolObservation[msg.sender].cardinality,\n      poolObservation[msg.sender].cardinalityNext\n    );\n  }\n\n  /// @inheritdoc IPoolOracle\n  function increaseObservationCardinalityNext(\n    address pool,\n    uint16 observationCardinalityNext\n  )\n    external\n    override\n  {\n    uint16 observationCardinalityNextOld = poolObservation[pool].cardinalityNext;\n    uint16 observationCardinalityNextNew = poolOracle[pool].grow(\n      observationCardinalityNextOld,\n      observationCardinalityNext\n    );\n    poolObservation[pool].cardinalityNext = observationCardinalityNextNew;\n    if (observationCardinalityNextOld != observationCardinalityNextNew)\n      emit IncreaseObservationCardinalityNext(\n        pool,\n        observationCardinalityNextOld,\n        observationCardinalityNextNew\n      );\n  }\n\n  /// @inheritdoc IPoolOracle\n  function writeNewEntry(\n    uint16 index,\n    uint32 blockTimestamp,\n    int24 tick,\n    uint128 liquidity,\n    uint16 cardinality,\n    uint16 cardinalityNext\n  )\n    public override\n    returns (uint16 indexUpdated, uint16 cardinalityUpdated)\n  {\n    liquidity; // unused for now\n    address pool = msg.sender;\n    (indexUpdated, cardinalityUpdated) = poolOracle[pool].write(\n      index,\n      blockTimestamp,\n      tick,\n      cardinality,\n      cardinalityNext\n    );\n    poolObservation[pool].index = indexUpdated;\n    poolObservation[pool].cardinality = cardinalityUpdated;\n  }\n\n  /// @inheritdoc IPoolOracle\n  function observeFromPool(\n    address pool,\n    uint32[] memory secondsAgos\n  )\n    external view override\n    returns (int56[] memory tickCumulatives)\n  {\n    (, int24 tick, ,) = IPoolStorage(pool).getPoolState();\n    return poolOracle[pool].observe(\n      _blockTimestamp(),\n      secondsAgos,\n      tick,\n      poolObservation[pool].index,\n      poolObservation[pool].cardinality\n    );\n  }\n\n  /// @inheritdoc IPoolOracle\n  function observeSingleFromPool(\n    address pool,\n    uint32 secondsAgo\n  )\n    external view override\n    returns (int56 tickCumulative)\n  {\n    (, int24 tick, ,) = IPoolStorage(pool).getPoolState();\n    return poolOracle[pool].observeSingle(\n      _blockTimestamp(),\n      secondsAgo,\n      tick,\n      poolObservation[pool].index,\n      poolObservation[pool].cardinality\n    );\n  }\n\n  /// @inheritdoc IPoolOracle\n  function getPoolObservation(address pool)\n    external view override\n    returns (bool initialized, uint16 index, uint16 cardinality, uint16 cardinalityNext)\n  {\n    (initialized, index, cardinality, cardinalityNext) = (\n      poolObservation[pool].initialized,\n      poolObservation[pool].index,\n      poolObservation[pool].cardinality,\n      poolObservation[pool].cardinalityNext\n    );\n  }\n\n  /// @inheritdoc IPoolOracle\n  function getObservationAt(address pool, uint256 index)\n    external view override\n    returns (\n      uint32 blockTimestamp,\n      int56 tickCumulative,\n      bool initialized\n    )\n  {\n    Oracle.Observation memory obsData = poolOracle[pool][index];\n    (blockTimestamp, tickCumulative, initialized) = (\n      obsData.blockTimestamp,\n      obsData.tickCumulative,\n      obsData.initialized\n    );\n  }\n\n  /// @dev For overriding in tests\n  function _blockTimestamp() internal view virtual returns (uint32) {\n    return uint32(block.timestamp);\n  }\n}"
    },
    {
      "filename": "ks-elastic-sc/contracts/periphery/TokenPositionDescriptor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '@openzeppelin/contracts/utils/Strings.sol';\nimport '../interfaces/periphery/INonfungibleTokenPositionDescriptor.sol';\n\ncontract TokenPositionDescriptor is\n  INonfungibleTokenPositionDescriptor,\n  Initializable,\n  UUPSUpgradeable,\n  OwnableUpgradeable\n{\n  string private baseURI;\n\n  function initialize() public initializer {\n    __Ownable_init();\n  }\n\n  function _authorizeUpgrade(address) internal override onlyOwner {}\n\n  function setBaseURI(string memory _baseURI) external onlyOwner {\n    baseURI = _baseURI;\n  }\n\n  function tokenURI(IBasePositionManager, uint256 tokenId)\n    external\n    view\n    override\n    returns (string memory)\n  {\n    return\n      bytes(baseURI).length > 0\n        ? string(abi.encodePacked(baseURI, Strings.toString(tokenId)))\n        : '';\n  }\n}"
    },
    {
      "filename": "ks-elastic-sc/contracts/periphery/TokenPositionDescriptor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '@openzeppelin/contracts/utils/Strings.sol';\nimport '../interfaces/periphery/INonfungibleTokenPositionDescriptor.sol';\n\ncontract TokenPositionDescriptor is\n  INonfungibleTokenPositionDescriptor,\n  Initializable,\n  UUPSUpgradeable,\n  OwnableUpgradeable\n{\n  string private baseURI;\n\n  function initialize() public initializer {\n    __Ownable_init();\n  }\n\n  function _authorizeUpgrade(address) internal override onlyOwner {}\n\n  function setBaseURI(string memory _baseURI) external onlyOwner {\n    baseURI = _baseURI;\n  }\n\n  function tokenURI(IBasePositionManager, uint256 tokenId)\n    external\n    view\n    override\n    returns (string memory)\n  {\n    return\n      bytes(baseURI).length > 0\n        ? string(abi.encodePacked(baseURI, Strings.toString(tokenId)))\n        : '';\n  }\n}"
    },
    {
      "filename": "ks-elastic-sc/contracts/periphery/TokenPositionDescriptor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '@openzeppelin/contracts/utils/Strings.sol';\nimport '../interfaces/periphery/INonfungibleTokenPositionDescriptor.sol';\n\ncontract TokenPositionDescriptor is\n  INonfungibleTokenPositionDescriptor,\n  Initializable,\n  UUPSUpgradeable,\n  OwnableUpgradeable\n{\n  string private baseURI;\n\n  function initialize() public initializer {\n    __Ownable_init();\n  }\n\n  function _authorizeUpgrade(address) internal override onlyOwner {}\n\n  function setBaseURI(string memory _baseURI) external onlyOwner {\n    baseURI = _baseURI;\n  }\n\n  function tokenURI(IBasePositionManager, uint256 tokenId)\n    external\n    view\n    override\n    returns (string memory)\n  {\n    return\n      bytes(baseURI).length > 0\n        ? string(abi.encodePacked(baseURI, Strings.toString(tokenId)))\n        : '';\n  }\n}"
    },
    {
      "filename": "ks-elastic-sc/contracts/periphery/TokenPositionDescriptor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '@openzeppelin/contracts/utils/Strings.sol';\nimport '../interfaces/periphery/INonfungibleTokenPositionDescriptor.sol';\n\ncontract TokenPositionDescriptor is\n  INonfungibleTokenPositionDescriptor,\n  Initializable,\n  UUPSUpgradeable,\n  OwnableUpgradeable\n{\n  string private baseURI;\n\n  function initialize() public initializer {\n    __Ownable_init();\n  }\n\n  function _authorizeUpgrade(address) internal override onlyOwner {}\n\n  function setBaseURI(string memory _baseURI) external onlyOwner {\n    baseURI = _baseURI;\n  }\n\n  function tokenURI(IBasePositionManager, uint256 tokenId)\n    external\n    view\n    override\n    returns (string memory)\n  {\n    return\n      bytes(baseURI).length > 0\n        ? string(abi.encodePacked(baseURI, Strings.toString(tokenId)))\n        : '';\n  }\n}"
    },
    {
      "filename": "ks-elastic-sc/contracts/periphery/TokenPositionDescriptor.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '@openzeppelin/contracts/utils/Strings.sol';\nimport '../interfaces/periphery/INonfungibleTokenPositionDescriptor.sol';\n\ncontract TokenPositionDescriptor is\n  INonfungibleTokenPositionDescriptor,\n  Initializable,\n  UUPSUpgradeable,\n  OwnableUpgradeable\n{\n  string private baseURI;\n\n  function initialize() public initializer {\n    __Ownable_init();\n  }\n\n  function _authorizeUpgrade(address) internal override onlyOwner {}\n\n  function setBaseURI(string memory _baseURI) external onlyOwner {\n    baseURI = _baseURI;\n  }\n\n  function tokenURI(IBasePositionManager, uint256 tokenId)\n    external\n    view\n    override\n    returns (string memory)\n  {\n    return\n      bytes(baseURI).length > 0\n        ? string(abi.encodePacked(baseURI, Strings.toString(tokenId)))\n        : '';\n  }\n}"
    }
  ]
}