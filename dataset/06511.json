{
  "Title": "[G-21] Loop best practice to save gas",
  "Content": "\n<details>\n\n```\nfunction Plusi() public view {\n\t\tfor(uint i=0; i<10;) {\n\t\t\tconsole.log(\"Number ==\",i);\n\t\t\tunchecked{\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\t}\n\nbest practice\n-----------------------------------------------------\nfor (uint i = 0; i < length; i = unchecked_inc(i)) {\n    // do something that doesn't change the value of i\n}\n\nfunction unchecked_inc(uint i) returns (uint) {\n    unchecked {\n        return i + 1;\n    }\n}\n```\n\n```solidity\nFile: src/erc-4626/ERC4626MultiToken.sol\n59  unchecked {\n      i++;\n    }\n71  unchecked {\n      i++;\n    }\n\n82  unchecked {\n      i++;\n    }\n\n173 unchecked {\n      i++;\n    }\n\n204 unchecked {\n      i++;\n    }\n\n218 unchecked {\n      i++;\n    }\n\n237 unchecked {\n      i++;\n    }\n\n253 unchecked {\n      i++;\n    }\n\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/erc-4626/ERC4626MultiToken.sol#L59\n\n```solidity\nFile: src/ulysses-amm/UlyssesPool.sol\n197 unchecked {\n      i++;\n    }\n\n264 unchecked {\n      i++;\n    }\n\n288 unchecked {\n      i++;\n    }\n\n930 unchecked {\n      i++;\n    }\n\n1001 unchecked {\n      i++;\n    }\n\n1068 unchecked {\n      i++;\n    }\n```\n\nhttps://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-amm/UlyssesPool.sol#L197\n\n</details>\n\n",
  "Impact": "GAS",
  "Source": "https://code4rena.com/reports/2023-05-maia",
  "Code": [
    {
      "filename": "src/erc-4626/ERC4626MultiToken.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {ReentrancyGuard} from \"solmate/utils/ReentrancyGuard.sol\";\n\nimport {IERC4626MultiToken} from \"./interfaces/IERC4626MultiToken.sol\";\n\n/// @title Minimal ERC4626 tokenized Vault multi asset implementation\n/// @author Maia DAO (https://github.com/Maia-DAO)\nabstract contract ERC4626MultiToken is ERC20, ReentrancyGuard, IERC4626MultiToken {\n    using SafeTransferLib for address;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626MultiToken\n    address[] public assets;\n\n    /// @inheritdoc IERC4626MultiToken\n    uint256[] public weights;\n\n    /// @inheritdoc IERC4626MultiToken\n    mapping(address => uint256) public assetId;\n\n    /// @inheritdoc IERC4626MultiToken\n    uint256 public totalWeights;\n\n    /// @inheritdoc IERC4626MultiToken\n    function getAssets() external view returns (address[] memory) {\n        return assets;\n    }\n\n    constructor(address[] memory _assets, uint256[] memory _weights, string memory _name, string memory _symbol)\n        ERC20(_name, _symbol, 18)\n    {\n        assets = _assets;\n        weights = _weights;\n\n        uint256 length = _weights.length;\n        uint256 _totalWeights;\n\n        if (length != _assets.length || length == 0) revert InvalidLength();\n\n        for (uint256 i = 0; i < length;) {\n            require(ERC20(_assets[i]).decimals() == 18);\n            require(_weights[i] > 0);\n\n            _totalWeights += _weights[i];\n            assetId[_assets[i]] = i + 1;\n\n            emit AssetAdded(_assets[i], _weights[i]);\n\n            unchecked {\n                i++;\n            }\n        }\n        totalWeights = _totalWeights;\n    }\n\n    function receiveAssets(uint256[] memory assetsAmounts) private {\n        uint256 length = assetsAmounts.length;\n        for (uint256 i = 0; i < length;) {\n            assets[i].safeTransferFrom(msg.sender, address(this), assetsAmounts[i]);\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    function sendAssets(uint256[] memory assetsAmounts, address receiver) private {\n        uint256 length = assetsAmounts.length;\n        for (uint256 i = 0; i < length;) {\n            assets[i].safeTransfer(receiver, assetsAmounts[i]);\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626MultiToken\n    function deposit(uint256[] calldata assetsAmounts, address receiver)\n        public\n        virtual\n        nonReentrant\n        returns (uint256 shares)\n    {\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(assetsAmounts)) != 0, \"ZERO_SHARES\");\n\n        // Need to transfer before minting or ERC777s could reenter.\n        receiveAssets(assetsAmounts);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assetsAmounts, shares);\n\n        afterDeposit(assetsAmounts, shares);\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function mint(uint256 shares, address receiver)\n        public\n        virtual\n        nonReentrant\n        returns (uint256[] memory assetsAmounts)\n    {\n        assetsAmounts = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        receiveAssets(assetsAmounts);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assetsAmounts, shares);\n\n        afterDeposit(assetsAmounts, shares);\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function withdraw(uint256[] calldata assetsAmounts, address receiver, address owner)\n        public\n        virtual\n        nonReentrant\n        returns (uint256 shares)\n    {\n        shares = previewWithdraw(assetsAmounts); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        beforeWithdraw(assetsAmounts, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assetsAmounts, shares);\n\n        sendAssets(assetsAmounts, receiver);\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function redeem(uint256 shares, address receiver, address owner)\n        public\n        virtual\n        nonReentrant\n        returns (uint256[] memory assetsAmounts)\n    {\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        assetsAmounts = previewRedeem(shares);\n        uint256 length = assetsAmounts.length;\n        for (uint256 i = 0; i < length;) {\n            // Check for rounding error since we round down in previewRedeem.\n            if (assetsAmounts[i] == 0) revert ZeroAssets();\n            unchecked {\n                i++;\n            }\n        }\n\n        beforeWithdraw(assetsAmounts, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assetsAmounts, shares);\n\n        sendAssets(assetsAmounts, receiver);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function totalAssets() public view virtual returns (uint256);\n\n    /// @inheritdoc IERC4626MultiToken\n    function convertToShares(uint256[] calldata assetsAmounts) public view virtual returns (uint256 shares) {\n        uint256 _totalWeights = totalWeights;\n        uint256 length = assetsAmounts.length;\n\n        if (length != assets.length) revert InvalidLength();\n\n        shares = type(uint256).max;\n        for (uint256 i = 0; i < length;) {\n            uint256 share = assetsAmounts[i].mulDiv(_totalWeights, weights[i]);\n            if (share < shares) shares = share;\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function convertToAssets(uint256 shares) public view virtual returns (uint256[] memory assetsAmounts) {\n        uint256 _totalWeights = totalWeights;\n        uint256 length = assets.length;\n\n        assetsAmounts = new uint256[](length);\n        for (uint256 i = 0; i < length;) {\n            assetsAmounts[i] = shares.mulDiv(weights[i], _totalWeights);\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function previewDeposit(uint256[] calldata assetsAmounts) public view virtual returns (uint256) {\n        return convertToShares(assetsAmounts);\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function previewMint(uint256 shares) public view virtual returns (uint256[] memory assetsAmounts) {\n        uint256 _totalWeights = totalWeights;\n        uint256 length = assets.length;\n\n        assetsAmounts = new uint256[](length);\n        for (uint256 i = 0; i < length;) {\n            assetsAmounts[i] = shares.mulDivUp(weights[i], _totalWeights);\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function previewWithdraw(uint256[] calldata assetsAmounts) public view virtual returns (uint256 shares) {\n        uint256 _totalWeights = totalWeights;\n        uint256 length = assetsAmounts.length;\n\n        if (length != assets.length) revert InvalidLength();\n\n        for (uint256 i = 0; i < length;) {\n            uint256 share = assetsAmounts[i].mulDivUp(_totalWeights, weights[i]);\n            if (share > shares) shares = share;\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function previewRedeem(uint256 shares) public view virtual returns (uint256[] memory) {\n        return convertToAssets(shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IERC4626MultiToken\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function maxWithdraw(address owner) public view virtual returns (uint256[] memory) {\n        return convertToAssets(balanceOf[owner]);\n    }\n\n    /// @inheritdoc IERC4626MultiToken\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function beforeWithdraw(uint256[] memory assetsAmounts, uint256 shares) internal virtual {}\n\n    function afterDeposit(uint256[] memory assetsAmounts, uint256 shares) internal virtual {}\n}"
    },
    {
      "filename": "src/ulysses-amm/UlyssesPool.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {FixedPointMathLib} from \"solady/utils/FixedPointMathLib.sol\";\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\nimport {UlyssesERC4626} from \"@ERC4626/UlyssesERC4626.sol\";\n\nimport {UlyssesFactory} from \"./factories/UlyssesFactory.sol\";\n\nimport {IUlyssesPool} from \"./interfaces/IUlyssesPool.sol\";\n\n/// @title Ulysses Pool - Single Sided Stableswap LP\n/// @author Maia DAO (https://github.com/Maia-DAO)\ncontract UlyssesPool is UlyssesERC4626, Ownable, IUlyssesPool {\n    using SafeTransferLib for address;\n    using FixedPointMathLib for uint256;\n    using SafeCastLib for uint256;\n\n    /// @notice ulysses factory associated with the Ulysses LP\n    UlyssesFactory public immutable factory;\n\n    /// @notice ID of this Ulysses LP\n    uint256 public immutable id;\n\n    /// @notice List of all added LPs\n    BandwidthState[] public bandwidthStateList;\n\n    /// @notice destinations[destinationId] => bandwidthStateList index\n    mapping(uint256 => uint256) public destinations;\n\n    /// @notice destinationIds[address] => destinationId\n    mapping(address => uint256) public destinationIds;\n\n    /// @notice Sum of all weights\n    uint256 public totalWeights;\n\n    /// @notice The minimum amount that can be swapped\n    uint256 private constant MIN_SWAP_AMOUNT = 1e4;\n\n    /// @notice The maximum sum of all weights\n    uint256 private constant MAX_TOTAL_WEIGHT = 256;\n\n    /// @notice The maximum destinations that can be added\n    uint256 private constant MAX_DESTINATIONS = 15;\n\n    /// @notice The maximum protocol fee that can be set (1%)\n    uint256 private constant MAX_PROTOCOL_FEE = 1e16;\n\n    /// @notice The maximum lambda1 that can be set (10%)\n    uint256 private constant MAX_LAMBDA1 = 1e17;\n\n    /// @notice The minimum sigma2 that can be set (1%)\n    uint256 private constant MIN_SIGMA2 = 1e16;\n\n    /*//////////////////////////////////////////////////////////////\n                            FEE PARAMETERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The divisioner for fee calculations\n    uint256 private constant DIVISIONER = 1 ether;\n\n    uint256 public protocolFee = 1e14;\n\n    /// @notice The current rebalancing fees\n    Fees public fees = Fees({lambda1: 20e14, lambda2: 4980e14, sigma1: 6000e14, sigma2: 500e14});\n\n    /**\n     * @param _id the Ulysses LP ID\n     * @param _asset the underlying asset\n     * @param _name the name of the LP\n     * @param _symbol the symbol of the LP\n     * @param _owner the owner of this contract\n     * @param _factory the Ulysses factory\n     */\n    constructor(\n        uint256 _id,\n        address _asset,\n        string memory _name,\n        string memory _symbol,\n        address _owner,\n        address _factory\n    ) UlyssesERC4626(_asset, _name, _symbol) {\n        require(_owner != address(0));\n        factory = UlyssesFactory(_factory);\n        _initializeOwner(_owner);\n        require(_id != 0);\n        id = _id;\n\n        bandwidthStateList.push(BandwidthState({bandwidth: 0, destination: UlyssesPool(address(0)), weight: 0}));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    // @inheritdoc UlyssesERC4626\n    function totalAssets() public view override returns (uint256) {\n        return asset.balanceOf(address(this)) - getProtocolFees();\n    }\n\n    // @inheritdoc UlyssesERC4626\n    function maxRedeem(address owner) public view override returns (uint256) {\n        return balanceOf[owner].min(asset.balanceOf(address(this)));\n    }\n\n    /// @inheritdoc IUlyssesPool\n    function getBandwidth(uint256 destinationId) external view returns (uint256) {\n        /**\n         * @dev bandwidthStateList first element has always 0 bandwidth\n         *      so this line will never fail and return 0 instead\n         */\n        return bandwidthStateList[destinations[destinationId]].bandwidth;\n    }\n\n    /// @inheritdoc IUlyssesPool\n    function getBandwidthStateList() external view returns (BandwidthState[] memory) {\n        return bandwidthStateList;\n    }\n\n    /// @inheritdoc IUlyssesPool\n    function getProtocolFees() public view returns (uint256) {\n        uint256 balance = asset.balanceOf(address(this));\n        uint256 assets;\n\n        for (uint256 i = 1; i < bandwidthStateList.length; i++) {\n            uint256 targetBandwidth = totalSupply.mulDiv(bandwidthStateList[i].weight, totalWeights);\n\n            assets += _calculateRebalancingFee(bandwidthStateList[i].bandwidth, targetBandwidth, false);\n\n            assets += bandwidthStateList[i].bandwidth;\n        }\n\n        if (balance > assets) {\n            return balance - assets;\n        } else {\n            return 0;\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ADMIN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IUlyssesPool\n    function claimProtocolFees() external nonReentrant returns (uint256 claimed) {\n        claimed = getProtocolFees();\n\n        if (claimed > 0) {\n            asset.safeTransfer(factory.owner(), claimed);\n        }\n    }\n\n    /// @inheritdoc IUlyssesPool\n    function addNewBandwidth(uint256 poolId, uint8 weight) external nonReentrant onlyOwner returns (uint256 index) {\n        if (weight == 0) revert InvalidWeight();\n\n        UlyssesPool destination = factory.pools(poolId);\n        uint256 destinationId = destination.id();\n\n        if (destinationIds[address(destination)] != 0 || destinationId == id) revert InvalidPool();\n\n        if (destinationId == 0) revert NotUlyssesLP();\n\n        index = bandwidthStateList.length;\n\n        if (index > MAX_DESTINATIONS) revert TooManyDestinations();\n\n        uint256 oldRebalancingFee;\n\n        for (uint256 i = 1; i < index; i++) {\n            uint256 targetBandwidth = totalSupply.mulDiv(bandwidthStateList[i].weight, totalWeights);\n\n            oldRebalancingFee += _calculateRebalancingFee(bandwidthStateList[i].bandwidth, targetBandwidth, false);\n        }\n\n        uint256 oldTotalWeights = totalWeights;\n        uint256 newTotalWeights = oldTotalWeights + weight;\n        totalWeights = newTotalWeights;\n\n        if (newTotalWeights > MAX_TOTAL_WEIGHT) revert InvalidWeight();\n\n        uint256 newBandwidth;\n\n        for (uint256 i = 1; i < index;) {\n            uint256 oldBandwidth = bandwidthStateList[i].bandwidth;\n            if (oldBandwidth > 0) {\n                bandwidthStateList[i].bandwidth = oldBandwidth.mulDivUp(oldTotalWeights, newTotalWeights).toUint248();\n\n                newBandwidth += oldBandwidth - bandwidthStateList[i].bandwidth;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        bandwidthStateList.push(\n            BandwidthState({bandwidth: newBandwidth.toUint248(), destination: destination, weight: weight})\n        );\n\n        destinations[destinationId] = index;\n        destinationIds[address(destination)] = index;\n\n        uint256 newRebalancingFee;\n\n        for (uint256 i = 1; i <= index; i++) {\n            uint256 targetBandwidth = totalSupply.mulDiv(bandwidthStateList[i].weight, totalWeights);\n\n            newRebalancingFee += _calculateRebalancingFee(bandwidthStateList[i].bandwidth, targetBandwidth, false);\n        }\n\n        if (oldRebalancingFee < newRebalancingFee) {\n            asset.safeTransferFrom(msg.sender, address(this), newRebalancingFee - oldRebalancingFee);\n        }\n    }\n\n    /// @inheritdoc IUlyssesPool\n    function setWeight(uint256 poolId, uint8 weight) external nonReentrant onlyOwner {\n        if (weight == 0) revert InvalidWeight();\n\n        uint256 poolIndex = destinations[poolId];\n\n        if (poolIndex == 0) revert NotUlyssesLP();\n\n        uint256 oldRebalancingFee;\n\n        for (uint256 i = 1; i < bandwidthStateList.length; i++) {\n            uint256 targetBandwidth = totalSupply.mulDiv(bandwidthStateList[i].weight, totalWeights);\n\n            oldRebalancingFee += _calculateRebalancingFee(bandwidthStateList[i].bandwidth, targetBandwidth, false);\n        }\n\n        uint256 oldTotalWeights = totalWeights;\n        uint256 weightsWithoutPool = oldTotalWeights - bandwidthStateList[poolIndex].weight;\n        uint256 newTotalWeights = weightsWithoutPool + weight;\n        totalWeights = newTotalWeights;\n\n        if (totalWeights > MAX_TOTAL_WEIGHT || oldTotalWeights == newTotalWeights) {\n            revert InvalidWeight();\n        }\n\n        uint256 leftOverBandwidth;\n\n        BandwidthState storage poolState = bandwidthStateList[poolIndex];\n        poolState.weight = weight;\n\n        if (oldTotalWeights > newTotalWeights) {\n            for (uint256 i = 1; i < bandwidthStateList.length;) {\n                if (i != poolIndex) {\n                    uint256 oldBandwidth = bandwidthStateList[i].bandwidth;\n                    if (oldBandwidth > 0) {\n                        bandwidthStateList[i].bandwidth =\n                            oldBandwidth.mulDivUp(oldTotalWeights, newTotalWeights).toUint248();\n\n                        leftOverBandwidth += oldBandwidth - bandwidthStateList[i].bandwidth;\n                    }\n                }\n\n                unchecked {\n                    ++i;\n                }\n            }\n\n            poolState.bandwidth += leftOverBandwidth.toUint248();\n        } else {\n            uint256 oldBandwidth = poolState.bandwidth;\n            if (oldBandwidth > 0) {\n                poolState.bandwidth = oldBandwidth.mulDivUp(oldTotalWeights, newTotalWeights).toUint248();\n\n                leftOverBandwidth += oldBandwidth - poolState.bandwidth;\n            }\n\n            for (uint256 i = 1; i < bandwidthStateList.length;) {\n                if (i != poolIndex) {\n                    if (i == bandwidthStateList.length - 1) {\n                        bandwidthStateList[i].bandwidth += leftOverBandwidth.toUint248();\n                    } else if (leftOverBandwidth > 0) {\n                        bandwidthStateList[i].bandwidth +=\n                            leftOverBandwidth.mulDiv(bandwidthStateList[i].weight, weightsWithoutPool).toUint248();\n                    }\n                }\n\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n\n        uint256 newRebalancingFee;\n\n        for (uint256 i = 1; i < bandwidthStateList.length; i++) {\n            uint256 targetBandwidth = totalSupply.mulDiv(bandwidthStateList[i].weight, totalWeights);\n\n            newRebalancingFee += _calculateRebalancingFee(bandwidthStateList[i].bandwidth, targetBandwidth, false);\n        }\n\n        if (oldRebalancingFee < newRebalancingFee) {\n            asset.safeTransferFrom(msg.sender, address(this), newRebalancingFee - oldRebalancingFee);\n        }\n    }\n\n    /// @inheritdoc IUlyssesPool\n    function setFees(Fees calldata _fees) external nonReentrant onlyOwner {\n        // Lower fee must be lower than 1%\n        if (_fees.lambda1 > MAX_LAMBDA1) revert InvalidFee();\n        // Sum of both fees must be 50%\n        if (_fees.lambda1 + _fees.lambda2 != DIVISIONER / 2) revert InvalidFee();\n\n        // Upper bound must be lower than 100%\n        if (_fees.sigma1 > DIVISIONER) revert InvalidFee();\n        // Lower bound must be lower than Upper bound and higher than 1%\n        if (_fees.sigma1 <= _fees.sigma2 || _fees.sigma2 < MIN_SIGMA2) revert InvalidFee();\n\n        fees = _fees;\n    }\n\n    /// @inheritdoc IUlyssesPool\n    function setProtocolFee(uint256 _protocolFee) external nonReentrant {\n        if (msg.sender != factory.owner()) revert Unauthorized();\n\n        // Revert if the protocol fee is larger than 1%\n        if (_protocolFee > MAX_PROTOCOL_FEE) revert InvalidFee();\n\n        protocolFee = _protocolFee;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ULYSSES LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Calculates the bandwidth increase/decrease amount.\n     * Is called when a user is doing a swap or adding/removing liquidity.\n     * @param roundUp Whether to round up or down\n     * @param positiveTransfer Whether the transfer is positive or negative\n     * @param amount The amount to transfer\n     * @param _totalWeights The total weights\n     * @param _totalSupply The total supply\n     */\n    function getBandwidthUpdateAmounts(\n        bool roundUp,\n        bool positiveTransfer,\n        uint256 amount,\n        uint256 _totalWeights,\n        uint256 _totalSupply\n    ) private view returns (uint256[] memory bandwidthUpdateAmounts, uint256 length) {\n        // Get the bandwidth state list length\n        length = bandwidthStateList.length;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Revert if the list is empty\n            if eq(length, 1) {\n                // Store the function selector of `NotInitialized()`.\n                mstore(0x00, 0x87138d5c)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // Revert if the amount is too small\n            if lt(amount, MIN_SWAP_AMOUNT) {\n                // Store the function selector of `AmountTooSmall()`.\n                mstore(0x00, 0xc2f5625a)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n        }\n\n        // Initialize bandwidth update amounts\n        bandwidthUpdateAmounts = new uint256[](length);\n        // Initialize bandwidth differences from target bandwidth\n        uint256[] memory diffs = new uint256[](length);\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Store bandwidth state slot in memory\n            mstore(0x00, bandwidthStateList.slot)\n            // Hash the bandwidth state slot to get the bandwidth state list start\n            let bandwidthStateListStart := keccak256(0x00, 0x20)\n\n            // Total difference from target bandwidth of all bandwidth states\n            let totalDiff\n            // Total difference from target bandwidth of all bandwidth states\n            let transfered\n            // Total amount to be distributed according to each bandwidth weights\n            let transferedChange\n\n            for { let i := 1 } lt(i, length) { i := add(i, 1) } {\n                // Load bandwidth and weight from storage\n                // Each bandwidth state occupies two storage slots\n                let slot := sload(add(bandwidthStateListStart, mul(i, 2)))\n                // Bandwidth is the first 248 bits of the slot\n                let bandwidth := and(slot, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n                // Weight is the last 8 bits of the slot\n                let weight := shr(248, slot)\n\n                // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n                if mul(weight, gt(_totalSupply, div(not(0), weight))) {\n                    // Store the function selector of `MulDivFailed()`.\n                    mstore(0x00, 0xad251c27)\n                    // Revert with (offset, size).\n                    revert(0x1c, 0x04)\n                }\n\n                // Calculate the target bandwidth\n                let targetBandwidth := div(mul(_totalSupply, weight), _totalWeights)\n\n                // Calculate the difference from the target bandwidth\n                switch positiveTransfer\n                // If the transfer is positive, calculate deficit from target bandwidth\n                case true {\n                    // If there is a deficit, store the difference\n                    if gt(targetBandwidth, bandwidth) {\n                        // Calculate the difference\n                        let diff := sub(targetBandwidth, bandwidth)\n                        // Add the difference to the total difference\n                        totalDiff := add(totalDiff, diff)\n                        // Store the difference in the diffs array\n                        mstore(add(diffs, add(mul(i, 0x20), 0x20)), diff)\n                    }\n                }\n                // If the transfer is negative, calculate surplus from target bandwidth\n                default {\n                    // If there is a surplus, store the difference\n                    if gt(bandwidth, targetBandwidth) {\n                        // Calculate the difference\n                        let diff := sub(bandwidth, targetBandwidth)\n                        // Add the difference to the total difference\n                        totalDiff := add(totalDiff, diff)\n                        // Store the difference in the diffs array\n                        mstore(add(diffs, add(mul(i, 0x20), 0x20)), diff)\n                    }\n                }\n            }\n\n            // Calculate the amount to be distributed according deficit/surplus\n            // and/or the amount to be distributed according to each bandwidth weights\n            switch gt(amount, totalDiff)\n            // If the amount is greater than the total deficit/surplus\n            case true {\n                // Total deficit/surplus is distributed\n                transfered := totalDiff\n                // Set rest to be distributed according to each bandwidth weights\n                transferedChange := sub(amount, totalDiff)\n            }\n            // If the amount is less than the total deficit/surplus\n            default {\n                // Amount will be distributed according to deficit/surplus\n                transfered := amount\n            }\n\n            for { let i := 1 } lt(i, length) { i := add(i, 1) } {\n                // Increase/decrease amount of bandwidth for each bandwidth state\n                let bandwidthUpdate\n\n                // If there is a deficit/surplus, calculate the amount to be distributed\n                if gt(transfered, 0) {\n                    // Load the difference from the diffs array\n                    let diff := mload(add(diffs, add(mul(i, 0x20), 0x20)))\n\n                    // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n                    if mul(diff, gt(transfered, div(not(0), diff))) {\n                        // Store the function selector of `MulDivFailed()`.\n                        mstore(0x00, 0xad251c27)\n                        // Revert with (offset, size).\n                        revert(0x1c, 0x04)\n                    }\n\n                    // Calculate the amount to be distributed according to deficit/surplus\n                    switch roundUp\n                    // If round up then do mulDivUp(transfered, diff, totalDiff)\n                    case true {\n                        bandwidthUpdate :=\n                            add(\n                                iszero(iszero(mod(mul(transfered, diff), totalDiff))), div(mul(transfered, diff), totalDiff)\n                            )\n                    }\n                    // If round down then do mulDiv(transfered, diff, totalDiff)\n                    default { bandwidthUpdate := div(mul(transfered, diff), totalDiff) }\n                }\n\n                // If there is a rest, calculate the amount to be distributed according to each bandwidth weights\n                if gt(transferedChange, 0) {\n                    // Load weight from storage\n                    let weight := shr(248, sload(add(bandwidthStateListStart, mul(i, 2))))\n\n                    // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n                    if mul(weight, gt(transferedChange, div(not(0), weight))) {\n                        // Store the function selector of `MulDivFailed()`.\n                        mstore(0x00, 0xad251c27)\n                        // Revert with (offset, size).\n                        revert(0x1c, 0x04)\n                    }\n\n                    // Calculate the amount to be distributed according to each bandwidth weights\n                    switch roundUp\n                    // If round up then do mulDivUp(transferedChange, weight, _totalWeights)\n                    case true {\n                        bandwidthUpdate :=\n                            add(\n                                bandwidthUpdate,\n                                add(\n                                    iszero(iszero(mod(mul(transferedChange, weight), _totalWeights))),\n                                    div(mul(transferedChange, weight), _totalWeights)\n                                )\n                            )\n                    }\n                    // If round down then do mulDiv(transferedChange, weight, _totalWeights)\n                    default {\n                        bandwidthUpdate := add(bandwidthUpdate, div(mul(transferedChange, weight), _totalWeights))\n                    }\n                }\n\n                // If there is an update in bandwidth\n                if gt(bandwidthUpdate, 0) {\n                    // Store the amount to be updated in the bandwidthUpdateAmounts array\n                    mstore(add(bandwidthUpdateAmounts, add(mul(i, 0x20), 0x20)), bandwidthUpdate)\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Updates the bandwidth of the destination Ulysses LP\n     * @param depositFees Whether to deposit fees or not\n     * @param positiveTransfer Whether the transfer is positive or negative\n     * @param destinationState The state of the destination Ulysses LP\n     * @param difference The difference between the old and new total supply\n     * @param _totalWeights The total weights of all Ulysses LPs\n     * @param _totalSupply The total supply of the Ulysses LP\n     * @param _newTotalSupply  The new total supply of the Ulysses LP\n     * @return positivefee The positive fee\n     */\n    function updateBandwidth(\n        bool depositFees,\n        bool positiveTransfer,\n        BandwidthState storage destinationState,\n        uint256 difference,\n        uint256 _totalWeights,\n        uint256 _totalSupply,\n        uint256 _newTotalSupply\n    ) private returns (uint256 positivefee, uint256 negativeFee) {\n        uint256 bandwidth;\n        uint256 targetBandwidth;\n        uint256 weight;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Load bandwidth and weight from storage\n            let slot := sload(destinationState.slot)\n            // Bandwidth is the first 248 bits of the slot\n            bandwidth := and(slot, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            // Weight is the last 8 bits of the slot\n            weight := shr(248, slot)\n\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n            if mul(weight, gt(_totalSupply, div(not(0), weight))) {\n                // Sto"
    }
  ]
}